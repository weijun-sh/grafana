(self["webpackChunkgrafana"] = self["webpackChunkgrafana"] || []).push([["prometheusPlugin"],{

/***/ "./public/app/core/utils/CancelablePromise.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "makePromiseCancelable": () => (/* binding */ makePromiseCancelable)
/* harmony export */ });
// https://github.com/facebook/react/issues/5465
const makePromiseCancelable = promise => {
  let hasCanceled_ = false;
  const wrappedPromise = new Promise((resolve, reject) => {
    promise.then(val => hasCanceled_ ? reject({
      isCanceled: true
    }) : resolve(val));
    promise.catch(error => hasCanceled_ ? reject({
      isCanceled: true
    }) : reject(error));
  });
  return {
    promise: wrappedPromise,

    cancel() {
      hasCanceled_ = true;
    }

  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/add_label_to_query.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addLabelToQuery": () => (/* binding */ addLabelToQuery)
/* harmony export */ });
/* harmony import */ var lezer_promql__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/lezer-promql-virtual-eaf88aa77a/0/cache/lezer-promql-npm-0.22.0-867da6afaa-cdce054700.zip/node_modules/lezer-promql/index.es.js");
/* harmony import */ var _querybuilder_PromQueryModeller__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/PromQueryModeller.ts");
/* harmony import */ var _querybuilder_parsing__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/parsing.ts");




/**
 * Adds label filter to existing query. Useful for query modification for example for ad hoc filters.
 *
 * It uses PromQL parser to find instances of metric and labels, alters them and then splices them back into the query.
 * Ideally we could use the parse -> change -> render is a simple 3 steps but right now building the visual query
 * object does not support all possible queries.
 *
 * So instead this just operates on substrings of the query with labels and operates just on those. This makes this
 * more robust and can alter even invalid queries, and preserves in general the query structure and whitespace.
 * @param query
 * @param key
 * @param value
 * @param operator
 */
function addLabelToQuery(query, key, value, operator = '=') {
  if (!key || !value) {
    throw new Error('Need label to add to query.');
  }

  const vectorSelectorPositions = getVectorSelectorPositions(query);

  if (!vectorSelectorPositions.length) {
    return query;
  }

  const filter = toLabelFilter(key, value, operator);
  return addFilter(query, vectorSelectorPositions, filter);
}

/**
 * Parse the string and get all VectorSelector positions in the query together with parsed representation of the vector
 * selector.
 * @param query
 */
function getVectorSelectorPositions(query) {
  const tree = lezer_promql__WEBPACK_IMPORTED_MODULE_0__.parser.parse(query);
  const positions = [];
  tree.iterate({
    enter: (type, from, to, get) => {
      if (type.name === 'VectorSelector') {
        const visQuery = (0,_querybuilder_parsing__WEBPACK_IMPORTED_MODULE_2__.buildVisualQueryFromString)(query.substring(from, to));
        positions.push({
          query: visQuery.query,
          from,
          to
        });
        return false;
      }
    }
  });
  return positions;
}

function toLabelFilter(key, value, operator) {
  // We need to make sure that we convert the value back to string because it may be a number
  const transformedValue = value === Infinity ? '+Inf' : value.toString();
  return {
    label: key,
    op: operator,
    value: transformedValue
  };
}

function addFilter(query, vectorSelectorPositions, filter) {
  const modeller = new _querybuilder_PromQueryModeller__WEBPACK_IMPORTED_MODULE_1__.PromQueryModeller();
  let newQuery = '';
  let prev = 0;

  for (let i = 0; i < vectorSelectorPositions.length; i++) {
    // This is basically just doing splice on a string for each matched vector selector.
    const match = vectorSelectorPositions[i];
    const isLast = i === vectorSelectorPositions.length - 1;
    const start = query.substring(prev, match.from);
    const end = isLast ? query.substring(match.to) : '';

    if (!labelExists(match.query.labels, filter)) {
      // We don't want to add duplicate labels.
      match.query.labels.push(filter);
    }

    const newLabels = modeller.renderQuery(match.query);
    newQuery += start + newLabels + end;
    prev = match.to;
  }

  return newQuery;
}
/**
 * Check if label exists in the list of labels but ignore the operator.
 * @param labels
 * @param filter
 */


function labelExists(labels, filter) {
  return labels.find(label => label.label === filter.label && label.value === filter.value);
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/components/PromCheatSheet.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _h;




const CHEAT_SHEET_ITEMS = [{
  title: 'Request Rate',
  expression: 'rate(http_request_total[5m])',
  label: 'Given an HTTP request counter, this query calculates the per-second average request rate over the last 5 minutes.'
}, {
  title: '95th Percentile of Request Latencies',
  expression: 'histogram_quantile(0.95, sum(rate(prometheus_http_request_duration_seconds_bucket[5m])) by (le))',
  label: 'Calculates the 95th percentile of HTTP request rate over 5 minute windows.'
}, {
  title: 'Alerts Firing',
  expression: 'sort_desc(sum(sum_over_time(ALERTS{alertstate="firing"}[24h])) by (alertname))',
  label: 'Sums up the alerts that have been firing over the last 24 hours.'
}, {
  title: 'Step',
  label: 'Defines the graph resolution using a duration format (15s, 1m, 3h, ...). Small steps create high-resolution graphs but can be slow over larger time ranges. Using a longer step lowers the resolution and smooths the graph by producing fewer datapoints. If no step is given the resolution is calculated automatically.'
}];

const PromCheatSheet = props => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)("div", {
  children: [_h || (_h = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("h2", {
    children: "PromQL Cheat Sheet"
  })), CHEAT_SHEET_ITEMS.map((item, index) => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)("div", {
    className: "cheat-sheet-item",
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("div", {
      className: "cheat-sheet-item__title",
      children: item.title
    }), item.expression ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("div", {
      className: "cheat-sheet-item__example",
      onClick: e => props.onClickExample({
        refId: 'A',
        expr: item.expression
      }),
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("code", {
        children: item.expression
      })
    }) : null, /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("div", {
      className: "cheat-sheet-item__label",
      children: item.label
    })]
  }, index))]
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PromCheatSheet);

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/components/PromExemplarField.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromExemplarField": () => (/* binding */ PromExemplarField)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_use__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/__virtual__/react-use-virtual-00326e70ba/0/cache/react-use-npm-17.3.2-a032cbeb01-7379460f51.zip/node_modules/react-use/esm/usePrevious.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
const _excluded = ["datasource", "onChange", "query"];

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







function PromExemplarField(_ref) {
  let {
    datasource,
    onChange,
    query
  } = _ref,
      rest = _objectWithoutPropertiesLoose(_ref, _excluded);

  const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.useStyles2)(getStyles);
  const prevError = (0,react_use__WEBPACK_IMPORTED_MODULE_4__["default"])(error);
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
    if (!datasource.exemplarsAvailable) {
      setError('Exemplars for this query are not available');
      onChange(false);
    } else if (query.instant && !query.range) {
      setError('Exemplars are not available for instant queries');
      onChange(false);
    } else {
      setError(null); // If error is cleared, we want to change exemplar to true

      if (prevError && !error) {
        onChange(true);
      }
    }
  }, [datasource.exemplarsAvailable, query.instant, query.range, onChange, prevError, error]);
  const iconButtonStyles = (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.cx)({
    [styles.activeIcon]: !!query.exemplar
  }, styles.eyeIcon);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.InlineLabel, {
    width: "auto",
    "data-testid": rest['data-testid'],
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Tooltip, {
      content: error !== null && error !== void 0 ? error : '',
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)("div", {
        className: styles.iconWrapper,
        children: ["Exemplars", /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.IconButton, {
          name: "eye",
          tooltip: !!query.exemplar ? 'Disable query with exemplars' : 'Enable query with exemplars',
          disabled: !!error,
          className: iconButtonStyles,
          onClick: () => {
            onChange(!query.exemplar);
          }
        })]
      })
    })
  });
}

function getStyles(theme) {
  return {
    eyeIcon: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
      margin-left: ${theme.spacing(2)};
    `,
    activeIcon: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
      color: ${theme.colors.primary.main};
    `,
    iconWrapper: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
      display: flex;
      align-items: center;
    `
  };
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/components/PromExploreExtraField.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromExploreExtraField": () => (/* binding */ PromExploreExtraField),
/* harmony export */   "getQueryTypeChangeHandler": () => (/* binding */ getQueryTypeChangeHandler),
/* harmony export */   "getQueryTypeOptions": () => (/* binding */ getQueryTypeOptions),
/* harmony export */   "testIds": () => (/* binding */ testIds)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_use__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/__virtual__/react-use-virtual-00326e70ba/0/cache/react-use-npm-17.3.2-a032cbeb01-7379460f51.zip/node_modules/react-use/esm/usePrevious.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _PromExemplarField__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromExemplarField.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _InlineFormLabel, _InlineFormLabel2;









const PromExploreExtraField = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_2__.memo)(({
  query,
  datasource,
  onChange,
  onRunQuery
}) => {
  var _query$interval;

  const rangeOptions = getQueryTypeOptions(true);
  const prevQuery = (0,react_use__WEBPACK_IMPORTED_MODULE_6__["default"])(query);
  const onExemplarChange = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)(exemplar => {
    if (!(0,lodash__WEBPACK_IMPORTED_MODULE_1__.isEqual)(query, prevQuery) || exemplar !== query.exemplar) {
      onChange(Object.assign({}, query, {
        exemplar
      }));
    }
  }, [prevQuery, query, onChange]);

  function onChangeQueryStep(interval) {
    onChange(Object.assign({}, query, {
      interval
    }));
  }

  function onStepChange(e) {
    if (e.currentTarget.value !== query.interval) {
      onChangeQueryStep(e.currentTarget.value);
    }
  }

  function onReturnKeyDown(e) {
    if (e.key === 'Enter' && e.shiftKey) {
      onRunQuery();
    }
  }

  const onQueryTypeChange = getQueryTypeChangeHandler(query, onChange);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
    "aria-label": "Prometheus extra field",
    className: "gf-form-inline",
    "data-testid": testIds.extraFieldEditor,
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
      "data-testid": testIds.queryTypeField,
      className: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.cx)('gf-form explore-input-margin', _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
              flex-wrap: nowrap;
            `),
      "aria-label": "Query type field",
      children: [_InlineFormLabel || (_InlineFormLabel = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.InlineFormLabel, {
        width: "auto",
        children: "Query type"
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.RadioButtonGroup, {
        options: rangeOptions,
        value: query.range && query.instant ? 'both' : query.instant ? 'instant' : 'range',
        onChange: onQueryTypeChange
      })]
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
      "data-testid": testIds.stepField,
      className: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.cx)('gf-form', _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
              flex-wrap: nowrap;
            `),
      "aria-label": "Step field",
      children: [_InlineFormLabel2 || (_InlineFormLabel2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.InlineFormLabel, {
        width: 6,
        tooltip: 'Time units and built-in variables can be used here, for example: $__interval, $__rate_interval, 5s, 1m, 3h, 1d, 1y (Default if no unit is specified: s)',
        children: "Min step"
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("input", {
        type: 'text',
        className: "gf-form-input width-4",
        placeholder: 'auto',
        onChange: onStepChange,
        onKeyDown: onReturnKeyDown,
        value: (_query$interval = query.interval) !== null && _query$interval !== void 0 ? _query$interval : ''
      })]
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_PromExemplarField__WEBPACK_IMPORTED_MODULE_4__.PromExemplarField, {
      onChange: onExemplarChange,
      datasource: datasource,
      query: query
    })]
  });
});
PromExploreExtraField.displayName = 'PromExploreExtraField';
function getQueryTypeOptions(includeBoth) {
  const rangeOptions = [{
    value: 'range',
    label: 'Range',
    description: 'Run query over a range of time'
  }, {
    value: 'instant',
    label: 'Instant',
    description: 'Run query against a single point in time. For this query, the "To" time is used'
  }];

  if (includeBoth) {
    rangeOptions.push({
      value: 'both',
      label: 'Both',
      description: 'Run an Instant query and a Range query'
    });
  }

  return rangeOptions;
}
function getQueryTypeChangeHandler(query, onChange) {
  return queryType => {
    if (queryType === 'instant') {
      onChange(Object.assign({}, query, {
        instant: true,
        range: false,
        exemplar: false
      }));
    } else if (queryType === 'range') {
      onChange(Object.assign({}, query, {
        instant: false,
        range: true
      }));
    } else {
      onChange(Object.assign({}, query, {
        instant: true,
        range: true
      }));
    }
  };
}
const testIds = {
  extraFieldEditor: 'prom-editor-extra-field',
  stepField: 'prom-editor-extra-field-step',
  queryTypeField: 'prom-editor-extra-field-query-type'
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/components/PromExploreQueryEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromExploreQueryEditor": () => (/* binding */ PromExploreQueryEditor),
/* harmony export */   "testIds": () => (/* binding */ testIds)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _PromExploreExtraField__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromExploreExtraField.tsx");
/* harmony import */ var _PromQueryField__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromQueryField.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");





const PromExploreQueryEditor = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(props => {
  const {
    range,
    query,
    data,
    datasource,
    history,
    onChange,
    onRunQuery
  } = props; // Setting default values

  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    if (query.expr === undefined) {
      onChange(Object.assign({}, query, {
        expr: ''
      }));
    }

    if (query.exemplar === undefined) {
      onChange(Object.assign({}, query, {
        exemplar: true
      }));
    } // Override query type to "Both" only for new queries (no query.expr).


    if (!query.instant && !query.range && !query.expr) {
      onChange(Object.assign({}, query, {
        instant: true,
        range: true
      }));
    }
  }, [onChange, query]);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_PromQueryField__WEBPACK_IMPORTED_MODULE_3__["default"], {
    app: _grafana_data__WEBPACK_IMPORTED_MODULE_1__.CoreApp.Explore,
    datasource: datasource,
    query: query,
    range: range,
    onRunQuery: onRunQuery,
    onChange: onChange,
    onBlur: () => {},
    history: history,
    data: data,
    "data-testid": testIds.editor,
    ExtraFieldElement: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_PromExploreExtraField__WEBPACK_IMPORTED_MODULE_2__.PromExploreExtraField, {
      query: query,
      onChange: onChange,
      datasource: datasource,
      onRunQuery: onRunQuery
    })
  });
});
PromExploreQueryEditor.displayName = 'PromExploreQueryEditor';
const testIds = {
  editor: 'prom-editor-explore'
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/components/PromLink.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");





const PromLink = ({
  panelData,
  query,
  datasource
}) => {
  const [href, setHref] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
    if (panelData) {
      const getExternalLink = () => {
        if (!panelData.request) {
          return '';
        }

        const {
          request: {
            range,
            interval,
            scopedVars
          }
        } = panelData;
        const start = datasource.getPrometheusTime(range.from, false);
        const end = datasource.getPrometheusTime(range.to, true);
        const rangeDiff = Math.ceil(end - start);
        const endTime = range.to.utc().format('YYYY-MM-DD HH:mm');
        const enrichedScopedVars = Object.assign({}, scopedVars, datasource.getRateIntervalScopedVariable(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.rangeUtil.intervalToSeconds(interval), _grafana_data__WEBPACK_IMPORTED_MODULE_2__.rangeUtil.intervalToSeconds(datasource.interval)));
        const options = {
          interval,
          scopedVars: enrichedScopedVars
        };
        const customQueryParameters = {};

        if (datasource.customQueryParameters) {
          for (const [k, v] of datasource.customQueryParameters) {
            customQueryParameters[k] = v;
          }
        }

        const queryOptions = datasource.createQuery(query, options, start, end);
        const expr = Object.assign({}, customQueryParameters, {
          'g0.expr': queryOptions.expr,
          'g0.range_input': rangeDiff + 's',
          'g0.end_input': endTime,
          'g0.step_input': queryOptions.step,
          'g0.tab': 0
        });
        const args = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.map)(expr, (v, k) => {
          return k + '=' + encodeURIComponent(v);
        }).join('&');
        return `${datasource.directUrl}/graph?${args}`;
      };

      setHref(getExternalLink());
    }
  }, [datasource, panelData, query]);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("a", {
    href: _grafana_data__WEBPACK_IMPORTED_MODULE_2__.textUtil.sanitizeUrl(href),
    target: "_blank",
    rel: "noopener noreferrer",
    children: "Prometheus"
  });
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(PromLink));

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/components/PromQueryEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FORMAT_OPTIONS": () => (/* binding */ FORMAT_OPTIONS),
/* harmony export */   "INTERVAL_FACTOR_OPTIONS": () => (/* binding */ INTERVAL_FACTOR_OPTIONS),
/* harmony export */   "PromQueryEditor": () => (/* binding */ PromQueryEditor),
/* harmony export */   "testIds": () => (/* binding */ testIds)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _PromExemplarField__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromExemplarField.tsx");
/* harmony import */ var _PromLink__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromLink.tsx");
/* harmony import */ var _PromQueryField__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromQueryField.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _InlineFormLabel, _InlineFormLabel2, _div, _div2;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


 // Types









const {
  Switch
} = _grafana_ui__WEBPACK_IMPORTED_MODULE_3__.LegacyForms;
const FORMAT_OPTIONS = [{
  label: 'Time series',
  value: 'time_series'
}, {
  label: 'Table',
  value: 'table'
}, {
  label: 'Heatmap',
  value: 'heatmap'
}];
const INTERVAL_FACTOR_OPTIONS = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.map)([1, 2, 3, 4, 5, 10], value => ({
  value,
  label: '1/' + value
}));
class PromQueryEditor extends react__WEBPACK_IMPORTED_MODULE_1__.PureComponent {
  // Query target to be modified and used for queries
  constructor(props) {
    super(props); // Use default query to prevent undefined input values

    _defineProperty(this, "query", void 0);

    _defineProperty(this, "onFieldChange", (query, override) => {
      this.query.expr = query.expr;
    });

    _defineProperty(this, "onFormatChange", option => {
      this.query.format = option.value;
      this.setState({
        formatOption: option
      }, this.onRunQuery);
    });

    _defineProperty(this, "onInstantChange", e => {
      const instant = e.target.checked;
      this.query.instant = instant;
      this.setState({
        instant
      }, this.onRunQuery);
    });

    _defineProperty(this, "onIntervalChange", e => {
      const interval = e.currentTarget.value;
      this.query.interval = interval;
      this.setState({
        interval
      });
    });

    _defineProperty(this, "onIntervalFactorChange", option => {
      this.query.intervalFactor = option.value;
      this.setState({
        intervalFactorOption: option
      }, this.onRunQuery);
    });

    _defineProperty(this, "onLegendChange", e => {
      const legendFormat = e.currentTarget.value;
      this.query.legendFormat = legendFormat;
      this.setState({
        legendFormat
      });
    });

    _defineProperty(this, "onExemplarChange", isEnabled => {
      this.query.exemplar = isEnabled;
      this.setState({
        exemplar: isEnabled
      }, this.onRunQuery);
    });

    _defineProperty(this, "onRunQuery", () => {
      const {
        query
      } = this; // Change of query.hide happens outside of this component and is just passed as prop. We have to update it when running queries.

      const {
        hide
      } = this.props.query;
      this.props.onChange(Object.assign({}, query, {
        hide
      }));
      this.props.onRunQuery();
    });

    const defaultQuery = {
      expr: '',
      legendFormat: '',
      interval: '',
      // Set exemplar to false for alerting queries
      exemplar: props.app === _grafana_data__WEBPACK_IMPORTED_MODULE_2__.CoreApp.UnifiedAlerting ? false : true
    };

    const _query = Object.assign({}, defaultQuery, props.query);

    this.query = _query; // Query target properties that are fully controlled inputs

    this.state = {
      // Fully controlled text inputs
      interval: _query.interval,
      legendFormat: _query.legendFormat,
      // Select options
      formatOption: FORMAT_OPTIONS.find(option => option.value === _query.format) || FORMAT_OPTIONS[0],
      intervalFactorOption: INTERVAL_FACTOR_OPTIONS.find(option => option.value === _query.intervalFactor) || INTERVAL_FACTOR_OPTIONS[0],
      // Switch options
      instant: Boolean(_query.instant),
      exemplar: Boolean(_query.exemplar)
    };
  }

  render() {
    const {
      datasource,
      query,
      range,
      data
    } = this.props;
    const {
      formatOption,
      instant,
      interval,
      intervalFactorOption,
      legendFormat
    } = this.state; //We want to hide exemplar field for unified alerting as exemplars in alerting don't make sense and are source of confusion

    const showExemplarField = this.props.app !== _grafana_data__WEBPACK_IMPORTED_MODULE_2__.CoreApp.UnifiedAlerting;
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_PromQueryField__WEBPACK_IMPORTED_MODULE_6__["default"], {
      datasource: datasource,
      query: query,
      range: range,
      onRunQuery: this.onRunQuery,
      onChange: this.onFieldChange,
      history: [],
      data: data,
      "data-testid": testIds.editor,
      ExtraFieldElement: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
        className: "gf-form-inline",
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
          className: "gf-form",
          children: [_InlineFormLabel || (_InlineFormLabel = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.InlineFormLabel, {
            width: 7,
            tooltip: "Controls the name of the time series, using name or pattern. For example {{hostname}} will be replaced with label value for the label hostname.",
            children: "Legend"
          })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("input", {
            type: "text",
            className: "gf-form-input",
            placeholder: "legend format",
            value: legendFormat,
            onChange: this.onLegendChange,
            onBlur: this.onRunQuery
          })]
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
          className: "gf-form",
          children: [_InlineFormLabel2 || (_InlineFormLabel2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.InlineFormLabel, {
            width: 7,
            tooltip: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.Fragment, {
              children: ["An additional lower limit for the step parameter of the Prometheus query and for the", ' ', /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("code", {
                children: "$__interval"
              }), " and ", /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("code", {
                children: "$__rate_interval"
              }), " variables. The limit is absolute and not modified by the \"Resolution\" setting."]
            }),
            children: "Min step"
          })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("input", {
            type: "text",
            className: "gf-form-input width-8",
            "aria-label": "Set lower limit for the step parameter",
            placeholder: interval,
            onChange: this.onIntervalChange,
            onBlur: this.onRunQuery,
            value: interval
          })]
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
          className: "gf-form",
          children: [_div || (_div = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
            className: "gf-form-label",
            children: "Resolution"
          })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Select, {
            "aria-label": "Select resolution",
            isSearchable: false,
            options: INTERVAL_FACTOR_OPTIONS,
            onChange: this.onIntervalFactorChange,
            value: intervalFactorOption
          })]
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
          className: "gf-form",
          children: [_div2 || (_div2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
            className: "gf-form-label width-7",
            children: "Format"
          })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Select, {
            className: "select-container",
            width: 16,
            isSearchable: false,
            options: FORMAT_OPTIONS,
            onChange: this.onFormatChange,
            value: formatOption,
            "aria-label": "Select format"
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(Switch, {
            label: "Instant",
            checked: instant,
            onChange: this.onInstantChange
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.InlineFormLabel, {
            width: 10,
            tooltip: "Link to Graph in Prometheus",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_PromLink__WEBPACK_IMPORTED_MODULE_5__["default"], {
              datasource: datasource,
              query: this.query // Use modified query
              ,
              panelData: data
            })
          })]
        }), showExemplarField && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_PromExemplarField__WEBPACK_IMPORTED_MODULE_4__.PromExemplarField, {
          onChange: this.onExemplarChange,
          datasource: datasource,
          query: this.query,
          "data-testid": testIds.exemplar
        })]
      })
    });
  }

}
const testIds = {
  editor: 'prom-editor',
  exemplar: 'exemplar-editor'
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/components/PromQueryEditorByApp.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromQueryEditorByApp": () => (/* binding */ PromQueryEditorByApp),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _querybuilder_components_PromQueryEditorSelector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryEditorSelector.tsx");
/* harmony import */ var _PromExploreQueryEditor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromExploreQueryEditor.tsx");
/* harmony import */ var _PromQueryEditor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromQueryEditor.tsx");
/* harmony import */ var _PromQueryEditorForAlerting__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromQueryEditorForAlerting.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");








function PromQueryEditorByApp(props) {
  const {
    app
  } = props;

  switch (app) {
    case _grafana_data__WEBPACK_IMPORTED_MODULE_1__.CoreApp.CloudAlerting:
      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_PromQueryEditorForAlerting__WEBPACK_IMPORTED_MODULE_6__.PromQueryEditorForAlerting, Object.assign({}, props));

    case _grafana_data__WEBPACK_IMPORTED_MODULE_1__.CoreApp.Explore:
      if (_grafana_runtime__WEBPACK_IMPORTED_MODULE_2__.config.featureToggles.promQueryBuilder) {
        return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_querybuilder_components_PromQueryEditorSelector__WEBPACK_IMPORTED_MODULE_3__.PromQueryEditorSelector, Object.assign({}, props));
      }

      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_PromExploreQueryEditor__WEBPACK_IMPORTED_MODULE_4__.PromExploreQueryEditor, Object.assign({}, props));

    default:
      if (_grafana_runtime__WEBPACK_IMPORTED_MODULE_2__.config.featureToggles.promQueryBuilder) {
        return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_querybuilder_components_PromQueryEditorSelector__WEBPACK_IMPORTED_MODULE_3__.PromQueryEditorSelector, Object.assign({}, props));
      }

      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_PromQueryEditor__WEBPACK_IMPORTED_MODULE_5__.PromQueryEditor, Object.assign({}, props));
  }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(PromQueryEditorByApp));

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/components/PromQueryEditorForAlerting.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromQueryEditorForAlerting": () => (/* binding */ PromQueryEditorForAlerting),
/* harmony export */   "testIds": () => (/* binding */ testIds)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _PromQueryField__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromQueryField.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");



function PromQueryEditorForAlerting(props) {
  const {
    datasource,
    query,
    range,
    data,
    onChange,
    onRunQuery
  } = props;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_PromQueryField__WEBPACK_IMPORTED_MODULE_1__["default"], {
    datasource: datasource,
    query: query,
    onRunQuery: onRunQuery,
    onChange: onChange,
    history: [],
    range: range,
    data: data,
    "data-testid": testIds.editor
  });
}
const testIds = {
  editor: 'prom-editor-cloud-alerting'
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/components/PromQueryField.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RECORDING_RULES_GROUP": () => (/* binding */ RECORDING_RULES_GROUP),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "willApplySuggestion": () => (/* binding */ willApplySuggestion)
/* harmony export */ });
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/prismjs-npm-1.27.0-ca4e1667c6-85c7f4a3e9.zip/node_modules/prismjs/prism.js");
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prismjs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_core_components_LocalStorageValueProvider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/core/components/LocalStorageValueProvider/index.tsx");
/* harmony import */ var app_core_utils_CancelablePromise__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/core/utils/CancelablePromise.ts");
/* harmony import */ var _language_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/prometheus/language_utils.ts");
/* harmony import */ var _PrometheusMetricsBrowser__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PrometheusMetricsBrowser.tsx");
/* harmony import */ var _monaco_query_field_MonacoQueryFieldWrapper__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/monaco-query-field/MonacoQueryFieldWrapper.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }













const RECORDING_RULES_GROUP = '__recording_rules__';
const LAST_USED_LABELS_KEY = 'grafana.datasources.prometheus.browser.labels';

function getChooserText(metricsLookupDisabled, hasSyntax, hasMetrics) {
  if (metricsLookupDisabled) {
    return '(Disabled)';
  }

  if (!hasSyntax) {
    return 'Loading metrics...';
  }

  if (!hasMetrics) {
    return '(No metrics found)';
  }

  return 'Metrics browser';
}

function willApplySuggestion(suggestion, {
  typeaheadContext,
  typeaheadText
}) {
  // Modify suggestion based on context
  switch (typeaheadContext) {
    case 'context-labels':
      {
        const nextChar = _grafana_ui__WEBPACK_IMPORTED_MODULE_3__.DOMUtil.getNextCharacter();

        if (!nextChar || nextChar === '}' || nextChar === ',') {
          suggestion += '=';
        }

        break;
      }

    case 'context-label-values':
      {
        // Always add quotes and remove existing ones instead
        if (!typeaheadText.match(/^(!?=~?"|")/)) {
          suggestion = `"${suggestion}`;
        }

        if (_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.DOMUtil.getNextCharacter() !== '"') {
          suggestion = `${suggestion}"`;
        }

        break;
      }

    default:
  }

  return suggestion;
}

class PromQueryField extends react__WEBPACK_IMPORTED_MODULE_1__.PureComponent {
  constructor(props, context) {
    super(props, context);

    _defineProperty(this, "plugins", void 0);

    _defineProperty(this, "refreshHint", () => {
      const {
        datasource,
        query,
        data
      } = this.props;
      const initHints = datasource.getInitHints();
      const initHint = initHints.length > 0 ? initHints[0] : null;

      if (!data || data.series.length === 0) {
        this.setState({
          hint: initHint
        });
        return;
      }

      const result = (0,_grafana_data__WEBPACK_IMPORTED_MODULE_2__.isDataFrame)(data.series[0]) ? data.series.map(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.toLegacyResponseData) : data.series;
      const queryHints = datasource.getQueryHints(query, result);
      let queryHint = queryHints.length > 0 ? queryHints[0] : null;
      this.setState({
        hint: queryHint !== null && queryHint !== void 0 ? queryHint : initHint
      });
    });

    _defineProperty(this, "refreshMetrics", async () => {
      const {
        datasource: {
          languageProvider
        }
      } = this.props;
      this.languageProviderInitializationPromise = (0,app_core_utils_CancelablePromise__WEBPACK_IMPORTED_MODULE_5__.makePromiseCancelable)(languageProvider.start());

      try {
        const remainingTasks = await this.languageProviderInitializationPromise.promise;
        await Promise.all(remainingTasks);
        this.onUpdateLanguage();
      } catch (err) {
        if (!err.isCanceled) {
          throw err;
        }
      }
    });

    _defineProperty(this, "onChangeLabelBrowser", selector => {
      this.onChangeQuery(selector, true);
      this.setState({
        labelBrowserVisible: false
      });
    });

    _defineProperty(this, "onChangeQuery", (value, override) => {
      // Send text change to parent
      const {
        query,
        onChange,
        onRunQuery
      } = this.props;

      if (onChange) {
        const nextQuery = Object.assign({}, query, {
          expr: value
        });
        onChange(nextQuery);

        if (override && onRunQuery) {
          onRunQuery();
        }
      }
    });

    _defineProperty(this, "onClickChooserButton", () => {
      this.setState(state => ({
        labelBrowserVisible: !state.labelBrowserVisible
      }));
    });

    _defineProperty(this, "onClickHintFix", () => {
      const {
        datasource,
        query,
        onChange,
        onRunQuery
      } = this.props;
      const {
        hint
      } = this.state;
      onChange(datasource.modifyQuery(query, hint.fix.action));
      onRunQuery();
    });

    _defineProperty(this, "onUpdateLanguage", () => {
      const {
        datasource: {
          languageProvider
        }
      } = this.props;
      const {
        metrics
      } = languageProvider;

      if (!metrics) {
        return;
      }

      this.setState({
        syntaxLoaded: true
      });
    });

    _defineProperty(this, "onTypeahead", async typeahead => {
      const {
        datasource: {
          languageProvider
        }
      } = this.props;

      if (!languageProvider) {
        return {
          suggestions: []
        };
      }

      const {
        history
      } = this.props;
      const {
        prefix,
        text,
        value,
        wrapperClasses,
        labelKey
      } = typeahead;
      const result = await languageProvider.provideCompletionItems({
        text,
        value,
        prefix,
        wrapperClasses,
        labelKey
      }, {
        history
      });
      return result;
    });

    this.plugins = [(0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.BracesPlugin)(), (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.SlatePrism)({
      onlyIn: node => node.type === 'code_block',
      getSyntax: node => 'promql'
    }, Object.assign({}, prismjs__WEBPACK_IMPORTED_MODULE_0__.languages, {
      promql: this.props.datasource.languageProvider.syntax
    }))];
    this.state = {
      labelBrowserVisible: false,
      syntaxLoaded: false,
      hint: null
    };
  }

  componentDidMount() {
    if (this.props.datasource.languageProvider) {
      this.refreshMetrics();
    }

    this.refreshHint();
  }

  componentWillUnmount() {
    if (this.languageProviderInitializationPromise) {
      this.languageProviderInitializationPromise.cancel();
    }
  }

  componentDidUpdate(prevProps) {
    const {
      data,
      datasource: {
        languageProvider
      },
      range
    } = this.props;

    if (languageProvider !== prevProps.datasource.languageProvider) {
      // We reset this only on DS change so we do not flesh loading state on every rangeChange which happens on every
      // query run if using relative range.
      this.setState({
        syntaxLoaded: false
      });
    }

    const changedRangeToRefresh = this.rangeChangedToRefresh(range, prevProps.range); // We want to refresh metrics when language provider changes and/or when range changes (we round up intervals to a minute)

    if (languageProvider !== prevProps.datasource.languageProvider || changedRangeToRefresh) {
      this.refreshMetrics();
    }

    if (data && prevProps.data && prevProps.data.series !== data.series) {
      this.refreshHint();
    }
  }

  rangeChangedToRefresh(range, prevRange) {
    if (range && prevRange) {
      const sameMinuteFrom = (0,_language_utils__WEBPACK_IMPORTED_MODULE_6__.roundMsToMin)(range.from.valueOf()) === (0,_language_utils__WEBPACK_IMPORTED_MODULE_6__.roundMsToMin)(prevRange.from.valueOf());
      const sameMinuteTo = (0,_language_utils__WEBPACK_IMPORTED_MODULE_6__.roundMsToMin)(range.to.valueOf()) === (0,_language_utils__WEBPACK_IMPORTED_MODULE_6__.roundMsToMin)(prevRange.to.valueOf()); // If both are same, don't need to refresh.

      return !(sameMinuteFrom && sameMinuteTo);
    }

    return false;
  }
  /**
   * TODO #33976: Remove this, add histogram group (query = `histogram_quantile(0.95, sum(rate(${metric}[5m])) by (le))`;)
   */


  render() {
    const {
      datasource,
      datasource: {
        languageProvider
      },
      query,
      ExtraFieldElement,
      history = []
    } = this.props;
    const {
      labelBrowserVisible,
      syntaxLoaded,
      hint
    } = this.state;
    const hasMetrics = languageProvider.metrics.length > 0;
    const chooserText = getChooserText(datasource.lookupsDisabled, syntaxLoaded, hasMetrics);
    const buttonDisabled = !(syntaxLoaded && hasMetrics);
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(app_core_components_LocalStorageValueProvider__WEBPACK_IMPORTED_MODULE_4__.LocalStorageValueProvider, {
      storageKey: LAST_USED_LABELS_KEY,
      defaultValue: [],
      children: (lastUsedLabels, onLastUsedLabelsSave, onLastUsedLabelsDelete) => {
        var _query$expr;

        return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.Fragment, {
          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsxs)("div", {
            className: "gf-form-inline gf-form-inline--xs-view-flex-column flex-grow-1",
            "data-testid": this.props['data-testid'],
            children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsxs)("button", {
              className: "gf-form-label query-keyword pointer",
              onClick: this.onClickChooserButton,
              disabled: buttonDisabled,
              children: [chooserText, /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Icon, {
                name: labelBrowserVisible ? 'angle-down' : 'angle-right'
              })]
            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("div", {
              className: "gf-form gf-form--grow flex-shrink-1 min-width-15",
              children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(_monaco_query_field_MonacoQueryFieldWrapper__WEBPACK_IMPORTED_MODULE_8__.MonacoQueryFieldWrapper, {
                runQueryOnBlur: this.props.app !== _grafana_data__WEBPACK_IMPORTED_MODULE_2__.CoreApp.Explore,
                languageProvider: languageProvider,
                history: history,
                onChange: this.onChangeQuery,
                onRunQuery: this.props.onRunQuery,
                initialValue: (_query$expr = query.expr) !== null && _query$expr !== void 0 ? _query$expr : ''
              })
            })]
          }), labelBrowserVisible && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("div", {
            className: "gf-form",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(_PrometheusMetricsBrowser__WEBPACK_IMPORTED_MODULE_7__.PrometheusMetricsBrowser, {
              languageProvider: languageProvider,
              onChange: this.onChangeLabelBrowser,
              lastUsedLabels: lastUsedLabels || [],
              storeLastUsedLabels: onLastUsedLabelsSave,
              deleteLastUsedLabels: onLastUsedLabelsDelete
            })
          }), ExtraFieldElement, hint ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("div", {
            className: "query-row-break",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsxs)("div", {
              className: "prom-query-field-info text-warning",
              children: [hint.label, ' ', hint.fix ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("a", {
                className: "text-link muted",
                onClick: this.onClickHintFix,
                children: hint.fix.label
              }) : null]
            })
          }) : null]
        });
      }
    });
  }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PromQueryField);

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/components/PrometheusMetricsBrowser.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PrometheusMetricsBrowser": () => (/* binding */ PrometheusMetricsBrowser),
/* harmony export */   "UnthemedPrometheusMetricsBrowser": () => (/* binding */ UnthemedPrometheusMetricsBrowser),
/* harmony export */   "buildSelector": () => (/* binding */ buildSelector),
/* harmony export */   "facetLabels": () => (/* binding */ facetLabels)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_window__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/__virtual__/react-window-virtual-0f9a8c6a67/0/cache/react-window-npm-1.8.6-4f5a230226-54ccf2b16c.zip/node_modules/react-window/dist/index.esm.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _language_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/language_utils.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _LoadingPlaceholder, _Label, _Label2, _Label3, _Label4;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





 // Hard limit on labels to render



const EMPTY_SELECTOR = '{}';
const METRIC_LABEL = '__name__';
const LIST_ITEM_SIZE = 25;
function buildSelector(labels) {
  let singleMetric = '';
  const selectedLabels = [];

  for (const label of labels) {
    if ((label.name === METRIC_LABEL || label.selected) && label.values && label.values.length > 0) {
      const selectedValues = label.values.filter(value => value.selected).map(value => value.name);

      if (selectedValues.length > 1) {
        selectedLabels.push(`${label.name}=~"${selectedValues.map(_language_utils__WEBPACK_IMPORTED_MODULE_3__.escapeLabelValueInRegexSelector).join('|')}"`);
      } else if (selectedValues.length === 1) {
        if (label.name === METRIC_LABEL) {
          singleMetric = selectedValues[0];
        } else {
          selectedLabels.push(`${label.name}="${(0,_language_utils__WEBPACK_IMPORTED_MODULE_3__.escapeLabelValueInExactSelector)(selectedValues[0])}"`);
        }
      }
    }
  }

  return [singleMetric, '{', selectedLabels.join(','), '}'].join('');
}
function facetLabels(labels, possibleLabels, lastFacetted) {
  return labels.map(label => {
    const possibleValues = possibleLabels[label.name];

    if (possibleValues) {
      let existingValues;

      if (label.name === lastFacetted && label.values) {
        // Facetting this label, show all values
        existingValues = label.values;
      } else {
        var _label$values;

        // Keep selection in other facets
        const selectedValues = new Set(((_label$values = label.values) === null || _label$values === void 0 ? void 0 : _label$values.filter(value => value.selected).map(value => value.name)) || []); // Values for this label have not been requested yet, let's use the facetted ones as the initial values

        existingValues = possibleValues.map(value => ({
          name: value,
          selected: selectedValues.has(value)
        }));
      }

      return Object.assign({}, label, {
        loading: false,
        values: existingValues,
        hidden: !possibleValues,
        facets: existingValues.length
      });
    } // Label is facetted out, hide all values


    return Object.assign({}, label, {
      loading: false,
      hidden: !possibleValues,
      values: undefined,
      facets: 0
    });
  });
}
const getStyles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.stylesFactory)(theme => ({
  wrapper: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    background-color: ${theme.colors.bg2};
    padding: ${theme.spacing.sm};
    width: 100%;
  `,
  list: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    margin-top: ${theme.spacing.sm};
    display: flex;
    flex-wrap: wrap;
    max-height: 200px;
    overflow: auto;
    align-content: flex-start;
  `,
  section: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    & + & {
      margin: ${theme.spacing.md} 0;
    }
    position: relative;
  `,
  selector: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    font-family: ${theme.typography.fontFamily.monospace};
    margin-bottom: ${theme.spacing.sm};
  `,
  status: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    padding: ${theme.spacing.xs};
    color: ${theme.colors.textSemiWeak};
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    /* using absolute positioning because flex interferes with ellipsis */
    position: absolute;
    width: 50%;
    right: 0;
    text-align: right;
    transition: opacity 100ms linear;
    opacity: 0;
  `,
  statusShowing: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    opacity: 1;
  `,
  error: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    color: ${theme.palette.brandDanger};
  `,
  valueList: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    margin-right: ${theme.spacing.sm};
  `,
  valueListWrapper: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    border-left: 1px solid ${theme.colors.border2};
    margin: ${theme.spacing.sm} 0;
    padding: ${theme.spacing.sm} 0 ${theme.spacing.sm} ${theme.spacing.sm};
  `,
  valueListArea: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    display: flex;
    flex-wrap: wrap;
    margin-top: ${theme.spacing.sm};
  `,
  valueTitle: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    margin-left: -${theme.spacing.xs};
    margin-bottom: ${theme.spacing.sm};
  `,
  validationStatus: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    padding: ${theme.spacing.xs};
    margin-bottom: ${theme.spacing.sm};
    color: ${theme.colors.textStrong};
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  `
}));
/**
 * TODO #33976: Remove duplicated code. The component is very similar to LokiLabelBrowser.tsx. Check if it's possible
 *              to create a single, generic component.
 */

class UnthemedPrometheusMetricsBrowser extends react__WEBPACK_IMPORTED_MODULE_1__.Component {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "valueListsRef", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createRef());

    _defineProperty(this, "state", {
      labels: [],
      labelSearchTerm: '',
      metricSearchTerm: '',
      status: 'Ready',
      error: '',
      validationStatus: '',
      valueSearchTerm: ''
    });

    _defineProperty(this, "onChangeLabelSearch", event => {
      this.setState({
        labelSearchTerm: event.target.value
      });
    });

    _defineProperty(this, "onChangeMetricSearch", event => {
      this.setState({
        metricSearchTerm: event.target.value
      });
    });

    _defineProperty(this, "onChangeValueSearch", event => {
      this.setState({
        valueSearchTerm: event.target.value
      });
    });

    _defineProperty(this, "onClickRunQuery", () => {
      const selector = buildSelector(this.state.labels);
      this.props.onChange(selector);
    });

    _defineProperty(this, "onClickRunRateQuery", () => {
      const selector = buildSelector(this.state.labels);
      const query = `rate(${selector}[$__interval])`;
      this.props.onChange(query);
    });

    _defineProperty(this, "onClickClear", () => {
      this.setState(state => {
        const labels = state.labels.map(label => Object.assign({}, label, {
          values: undefined,
          selected: false,
          loading: false,
          hidden: false,
          facets: undefined
        }));
        return {
          labels,
          labelSearchTerm: '',
          metricSearchTerm: '',
          status: '',
          error: '',
          validationStatus: '',
          valueSearchTerm: ''
        };
      });
      this.props.deleteLastUsedLabels(); // Get metrics

      this.fetchValues(METRIC_LABEL, EMPTY_SELECTOR);
    });

    _defineProperty(this, "onClickLabel", (name, value, event) => {
      const label = this.state.labels.find(l => l.name === name);

      if (!label) {
        return;
      } // Toggle selected state


      const selected = !label.selected;
      let nextValue = {
        selected
      };

      if (label.values && !selected) {
        // Deselect all values if label was deselected
        const values = label.values.map(value => Object.assign({}, value, {
          selected: false
        }));
        nextValue = Object.assign({}, nextValue, {
          facets: 0,
          values
        });
      } // Resetting search to prevent empty results


      this.setState({
        labelSearchTerm: ''
      });
      this.updateLabelState(name, nextValue, '', () => this.doFacettingForLabel(name));
    });

    _defineProperty(this, "onClickValue", (name, value, event) => {
      const label = this.state.labels.find(l => l.name === name);

      if (!label || !label.values) {
        return;
      } // Resetting search to prevent empty results


      this.setState({
        labelSearchTerm: ''
      }); // Toggling value for selected label, leaving other values intact

      const values = label.values.map(v => Object.assign({}, v, {
        selected: v.name === value ? !v.selected : v.selected
      }));
      this.updateLabelState(name, {
        values
      }, '', () => this.doFacetting(name));
    });

    _defineProperty(this, "onClickMetric", (name, value, event) => {
      // Finding special metric label
      const label = this.state.labels.find(l => l.name === name);

      if (!label || !label.values) {
        return;
      } // Resetting search to prevent empty results


      this.setState({
        metricSearchTerm: ''
      }); // Toggling value for selected label, leaving other values intact

      const values = label.values.map(v => Object.assign({}, v, {
        selected: v.name === value || v.selected ? !v.selected : v.selected
      })); // Toggle selected state of special metrics label

      const selected = values.some(v => v.selected);
      this.updateLabelState(name, {
        selected,
        values
      }, '', () => this.doFacetting(name));
    });

    _defineProperty(this, "onClickValidate", () => {
      const selector = buildSelector(this.state.labels);
      this.validateSelector(selector);
    });

    _defineProperty(this, "doFacetting", lastFacetted => {
      const selector = buildSelector(this.state.labels);

      if (selector === EMPTY_SELECTOR) {
        // Clear up facetting
        const labels = this.state.labels.map(label => {
          return Object.assign({}, label, {
            facets: 0,
            values: undefined,
            hidden: false
          });
        });
        this.setState({
          labels
        }, () => {
          // Get fresh set of values
          this.state.labels.forEach(label => (label.selected || label.name === METRIC_LABEL) && this.fetchValues(label.name, selector));
        });
      } else {
        // Do facetting
        this.fetchSeries(selector, lastFacetted);
      }
    });
  }

  updateLabelState(name, updatedFields, status = '', cb) {
    this.setState(state => {
      const labels = state.labels.map(label => {
        if (label.name === name) {
          return Object.assign({}, label, updatedFields);
        }

        return label;
      }); // New status overrides errors

      const error = status ? '' : state.error;
      return {
        labels,
        status,
        error,
        validationStatus: ''
      };
    }, cb);
  }

  componentDidMount() {
    const {
      languageProvider,
      lastUsedLabels
    } = this.props;

    if (languageProvider) {
      const selectedLabels = lastUsedLabels;
      languageProvider.start().then(() => {
        let rawLabels = languageProvider.getLabelKeys(); // Get metrics

        this.fetchValues(METRIC_LABEL, EMPTY_SELECTOR); // Auto-select previously selected labels

        const labels = rawLabels.map((label, i, arr) => ({
          name: label,
          selected: selectedLabels.includes(label),
          loading: false
        })); // Pre-fetch values for selected labels

        this.setState({
          labels
        }, () => {
          this.state.labels.forEach(label => {
            if (label.selected) {
              this.fetchValues(label.name, EMPTY_SELECTOR);
            }
          });
        });
      });
    }
  }

  doFacettingForLabel(name) {
    const label = this.state.labels.find(l => l.name === name);

    if (!label) {
      return;
    }

    const selectedLabels = this.state.labels.filter(label => label.selected).map(label => label.name);
    this.props.storeLastUsedLabels(selectedLabels);

    if (label.selected) {
      // Refetch values for newly selected label...
      if (!label.values) {
        this.fetchValues(name, buildSelector(this.state.labels));
      }
    } else {
      // Only need to facet when deselecting labels
      this.doFacetting();
    }
  }

  async fetchValues(name, selector) {
    const {
      languageProvider
    } = this.props;
    this.updateLabelState(name, {
      loading: true
    }, `Fetching values for ${name}`);

    try {
      let rawValues = await languageProvider.getLabelValues(name); // If selector changed, clear loading state and discard result by returning early

      if (selector !== buildSelector(this.state.labels)) {
        this.updateLabelState(name, {
          loading: false
        });
        return;
      }

      const values = [];
      const {
        metricsMetadata
      } = languageProvider;

      for (const labelValue of rawValues) {
        const value = {
          name: labelValue
        }; // Adding type/help text to metrics

        if (name === METRIC_LABEL && metricsMetadata) {
          const meta = metricsMetadata[labelValue];

          if (meta) {
            value.details = `(${meta.type}) ${meta.help}`;
          }
        }

        values.push(value);
      }

      this.updateLabelState(name, {
        values,
        loading: false
      });
    } catch (error) {
      console.error(error);
    }
  }

  async fetchSeries(selector, lastFacetted) {
    const {
      languageProvider
    } = this.props;

    if (lastFacetted) {
      this.updateLabelState(lastFacetted, {
        loading: true
      }, `Facetting labels for ${selector}`);
    }

    try {
      const possibleLabels = await languageProvider.fetchSeriesLabels(selector, true); // If selector changed, clear loading state and discard result by returning early

      if (selector !== buildSelector(this.state.labels)) {
        if (lastFacetted) {
          this.updateLabelState(lastFacetted, {
            loading: false
          });
        }

        return;
      }

      if (Object.keys(possibleLabels).length === 0) {
        this.setState({
          error: `Empty results, no matching label for ${selector}`
        });
        return;
      }

      const labels = facetLabels(this.state.labels, possibleLabels, lastFacetted);
      this.setState({
        labels,
        error: ''
      });

      if (lastFacetted) {
        this.updateLabelState(lastFacetted, {
          loading: false
        });
      }
    } catch (error) {
      console.error(error);
    }
  }

  async validateSelector(selector) {
    const {
      languageProvider
    } = this.props;
    this.setState({
      validationStatus: `Validating selector ${selector}`,
      error: ''
    });
    const streams = await languageProvider.fetchSeries(selector);
    this.setState({
      validationStatus: `Selector is valid (${streams.length} series found)`
    });
  }

  render() {
    var _metrics, _metrics$values2;

    const {
      theme
    } = this.props;
    const {
      labels,
      labelSearchTerm,
      metricSearchTerm,
      status,
      error,
      validationStatus,
      valueSearchTerm
    } = this.state;
    const styles = getStyles(theme);

    if (labels.length === 0) {
      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
        className: styles.wrapper,
        children: _LoadingPlaceholder || (_LoadingPlaceholder = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.LoadingPlaceholder, {
          text: "Loading labels..."
        }))
      });
    } // Filter metrics


    let metrics = labels.find(label => label.name === METRIC_LABEL);

    if (metrics && metricSearchTerm) {
      var _metrics$values;

      metrics = Object.assign({}, metrics, {
        values: (_metrics$values = metrics.values) === null || _metrics$values === void 0 ? void 0 : _metrics$values.filter(value => value.selected || value.name.includes(metricSearchTerm))
      });
    } // Filter labels


    let nonMetricLabels = labels.filter(label => !label.hidden && label.name !== METRIC_LABEL);

    if (labelSearchTerm) {
      nonMetricLabels = nonMetricLabels.filter(label => label.selected || label.name.includes(labelSearchTerm));
    } // Filter non-metric label values


    let selectedLabels = nonMetricLabels.filter(label => label.selected && label.values);

    if (valueSearchTerm) {
      selectedLabels = selectedLabels.map(label => {
        var _label$values2;

        return Object.assign({}, label, {
          values: (_label$values2 = label.values) === null || _label$values2 === void 0 ? void 0 : _label$values2.filter(value => value.selected || value.name.includes(valueSearchTerm))
        });
      });
    }

    const selector = buildSelector(this.state.labels);
    const empty = selector === EMPTY_SELECTOR;
    const metricCount = ((_metrics = metrics) === null || _metrics === void 0 ? void 0 : (_metrics$values2 = _metrics.values) === null || _metrics$values2 === void 0 ? void 0 : _metrics$values2.length) || 0;
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
      className: styles.wrapper,
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.HorizontalGroup, {
        align: "flex-start",
        spacing: "lg",
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
            className: styles.section,
            children: [_Label || (_Label = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Label, {
              description: "Once a metric is selected only possible labels are shown.",
              children: "1. Select a metric"
            })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
              children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Input, {
                onChange: this.onChangeMetricSearch,
                "aria-label": "Filter expression for metric",
                value: metricSearchTerm
              })
            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
              role: "list",
              className: styles.valueListWrapper,
              children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(react_window__WEBPACK_IMPORTED_MODULE_5__.FixedSizeList, {
                height: Math.min(450, metricCount * LIST_ITEM_SIZE),
                itemCount: metricCount,
                itemSize: LIST_ITEM_SIZE,
                itemKey: i => metrics.values[i].name,
                width: 300,
                className: styles.valueList,
                children: ({
                  index,
                  style
                }) => {
                  var _metrics2, _metrics2$values;

                  const value = (_metrics2 = metrics) === null || _metrics2 === void 0 ? void 0 : (_metrics2$values = _metrics2.values) === null || _metrics2$values === void 0 ? void 0 : _metrics2$values[index];

                  if (!value) {
                    return null;
                  }

                  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
                    style: style,
                    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.BrowserLabel, {
                      name: metrics.name,
                      value: value === null || value === void 0 ? void 0 : value.name,
                      title: value.details,
                      active: value === null || value === void 0 ? void 0 : value.selected,
                      onClick: this.onClickMetric,
                      searchTerm: metricSearchTerm
                    })
                  });
                }
              })
            })]
          })
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
            className: styles.section,
            children: [_Label2 || (_Label2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Label, {
              description: "Once label values are selected, only possible label combinations are shown.",
              children: "2. Select labels to search in"
            })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
              children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Input, {
                onChange: this.onChangeLabelSearch,
                "aria-label": "Filter expression for label",
                value: labelSearchTerm
              })
            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
              className: styles.list,
              style: {
                height: 120
              },
              children: nonMetricLabels.map(label => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.BrowserLabel, {
                name: label.name,
                loading: label.loading,
                active: label.selected,
                hidden: label.hidden,
                facets: label.facets,
                onClick: this.onClickLabel,
                searchTerm: labelSearchTerm
              }, label.name))
            })]
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
            className: styles.section,
            children: [_Label3 || (_Label3 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Label, {
              description: "Use the search field to find values across selected labels.",
              children: "3. Select (multiple) values for your labels"
            })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
              children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Input, {
                onChange: this.onChangeValueSearch,
                "aria-label": "Filter expression for label values",
                value: valueSearchTerm
              })
            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
              className: styles.valueListArea,
              ref: this.valueListsRef,
              children: selectedLabels.map(label => {
                var _label$values3, _label$values4, _label$values5;

                return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
                  role: "list",
                  "aria-label": `Values for ${label.name}`,
                  className: styles.valueListWrapper,
                  children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
                    className: styles.valueTitle,
                    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.BrowserLabel, {
                      name: label.name,
                      loading: label.loading,
                      active: label.selected,
                      hidden: label.hidden //If no facets, we want to show number of all label values
                      ,
                      facets: label.facets || ((_label$values3 = label.values) === null || _label$values3 === void 0 ? void 0 : _label$values3.length),
                      onClick: this.onClickLabel
                    })
                  }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(react_window__WEBPACK_IMPORTED_MODULE_5__.FixedSizeList, {
                    height: Math.min(200, LIST_ITEM_SIZE * (((_label$values4 = label.values) === null || _label$values4 === void 0 ? void 0 : _label$values4.length) || 0)),
                    itemCount: ((_label$values5 = label.values) === null || _label$values5 === void 0 ? void 0 : _label$values5.length) || 0,
                    itemSize: 28,
                    itemKey: i => label.values[i].name,
                    width: 200,
                    className: styles.valueList,
                    children: ({
                      index,
                      style
                    }) => {
                      var _label$values6;

                      const value = (_label$values6 = label.values) === null || _label$values6 === void 0 ? void 0 : _label$values6[index];

                      if (!value) {
                        return null;
                      }

                      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
                        style: style,
                        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.BrowserLabel, {
                          name: label.name,
                          value: value === null || value === void 0 ? void 0 : value.name,
                          active: value === null || value === void 0 ? void 0 : value.selected,
                          onClick: this.onClickValue,
                          searchTerm: valueSearchTerm
                        })
                      });
                    }
                  })]
                }, label.name);
              })
            })]
          })]
        })]
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
        className: styles.section,
        children: [_Label4 || (_Label4 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Label, {
          children: "4. Resulting selector"
        })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
          "aria-label": "selector",
          className: styles.selector,
          children: selector
        }), validationStatus && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
          className: styles.validationStatus,
          children: validationStatus
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.HorizontalGroup, {
          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Button, {
            "aria-label": "Use selector for query button",
            disabled: empty,
            onClick: this.onClickRunQuery,
            children: "Use query"
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Button, {
            "aria-label": "Use selector as metrics button",
            variant: "secondary",
            disabled: empty,
            onClick: this.onClickRunRateQuery,
            children: "Use as rate query"
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Button, {
            "aria-label": "Validate submit button",
            variant: "secondary",
            disabled: empty,
            onClick: this.onClickValidate,
            children: "Validate selector"
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Button, {
            "aria-label": "Selector clear button",
            variant: "secondary",
            onClick: this.onClickClear,
            children: "Clear"
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
            className: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.cx)(styles.status, (status || error) && styles.statusShowing),
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("span", {
              className: error ? styles.error : '',
              children: error || status
            })
          })]
        })]
      })]
    });
  }

}
const PrometheusMetricsBrowser = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.withTheme)(UnthemedPrometheusMetricsBrowser);

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/components/monaco-query-field/MonacoQueryFieldLazy.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MonacoQueryFieldLazy": () => (/* binding */ MonacoQueryFieldLazy)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");


const Field = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.lazy(() => __webpack_require__.e(/* import() | prom-query-field */ "prom-query-field").then(__webpack_require__.bind(__webpack_require__, "./public/app/plugins/datasource/prometheus/components/monaco-query-field/MonacoQueryField.tsx")));
const MonacoQueryFieldLazy = props => {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {
    fallback: null,
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Field, Object.assign({}, props))
  });
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/components/monaco-query-field/MonacoQueryFieldWrapper.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MonacoQueryFieldWrapper": () => (/* binding */ MonacoQueryFieldWrapper)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _MonacoQueryFieldLazy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/monaco-query-field/MonacoQueryFieldLazy.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
const _excluded = ["runQueryOnBlur", "onRunQuery", "onChange"];

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }




const MonacoQueryFieldWrapper = props => {
  const lastRunValueRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);

  const {
    runQueryOnBlur,
    onRunQuery,
    onChange
  } = props,
        rest = _objectWithoutPropertiesLoose(props, _excluded);

  const handleRunQuery = value => {
    lastRunValueRef.current = value;
    onChange(value);
    onRunQuery();
  };

  const handleBlur = value => {
    if (runQueryOnBlur) {
      // run handleRunQuery only if the current value is different from the last-time-executed value
      if (value !== lastRunValueRef.current) {
        handleRunQuery(value);
      }
    } else {
      onChange(value);
    }
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_MonacoQueryFieldLazy__WEBPACK_IMPORTED_MODULE_1__.MonacoQueryFieldLazy, Object.assign({
    onRunQuery: handleRunQuery,
    onBlur: handleBlur
  }, rest));
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/configuration/AzureAuthSettings.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AzureAuthSettings": () => (/* binding */ AzureAuthSettings),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _AzureCredentials__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/configuration/AzureCredentials.ts");
/* harmony import */ var _AzureCredentialsConfig__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/configuration/AzureCredentialsConfig.ts");
/* harmony import */ var _AzureCredentialsForm__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/configuration/AzureCredentialsForm.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _h, _h2, _InlineFormLabel;










const AzureAuthSettings = props => {
  const {
    dataSourceConfig,
    onChange
  } = props;
  const credentials = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (0,_AzureCredentialsConfig__WEBPACK_IMPORTED_MODULE_4__.getCredentials)(dataSourceConfig), [dataSourceConfig]);

  const onCredentialsChange = credentials => {
    onChange((0,_AzureCredentialsConfig__WEBPACK_IMPORTED_MODULE_4__.updateCredentials)(dataSourceConfig, credentials));
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.Fragment, {
    children: [_h || (_h = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("h6", {
      children: "Azure Authentication"
    })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_AzureCredentialsForm__WEBPACK_IMPORTED_MODULE_5__.AzureCredentialsForm, {
      managedIdentityEnabled: _grafana_runtime__WEBPACK_IMPORTED_MODULE_1__.config.azure.managedIdentityEnabled,
      credentials: credentials,
      azureCloudOptions: _AzureCredentials__WEBPACK_IMPORTED_MODULE_3__.KnownAzureClouds,
      onCredentialsChange: onCredentialsChange
    }), _h2 || (_h2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("h6", {
      children: "Azure Configuration"
    })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("div", {
      className: "gf-form-group",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("div", {
        className: "gf-form-inline",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("div", {
          className: "gf-form",
          children: [_InlineFormLabel || (_InlineFormLabel = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.InlineFormLabel, {
            className: "width-12",
            children: "AAD resource ID"
          })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("div", {
            className: "width-15",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Input, {
              className: "width-30",
              value: dataSourceConfig.jsonData.azureEndpointResourceId || '',
              onChange: event => onChange(Object.assign({}, dataSourceConfig, {
                jsonData: Object.assign({}, dataSourceConfig.jsonData, {
                  azureEndpointResourceId: event.currentTarget.value
                })
              }))
            })
          })]
        })
      })
    })]
  });
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AzureAuthSettings);

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/configuration/AzureCredentials.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AzureCloud": () => (/* binding */ AzureCloud),
/* harmony export */   "KnownAzureClouds": () => (/* binding */ KnownAzureClouds),
/* harmony export */   "isCredentialsComplete": () => (/* binding */ isCredentialsComplete)
/* harmony export */ });
let AzureCloud;

(function (AzureCloud) {
  AzureCloud["Public"] = "AzureCloud";
  AzureCloud["China"] = "AzureChinaCloud";
  AzureCloud["USGovernment"] = "AzureUSGovernment";
  AzureCloud["Germany"] = "AzureGermanCloud";
  AzureCloud["None"] = "";
})(AzureCloud || (AzureCloud = {}));

const KnownAzureClouds = [{
  value: AzureCloud.Public,
  label: 'Azure'
}, {
  value: AzureCloud.China,
  label: 'Azure China'
}, {
  value: AzureCloud.USGovernment,
  label: 'Azure US Government'
}, {
  value: AzureCloud.Germany,
  label: 'Azure Germany'
}];
function isCredentialsComplete(credentials) {
  switch (credentials.authType) {
    case 'msi':
      return true;

    case 'clientsecret':
      return !!(credentials.azureCloud && credentials.tenantId && credentials.clientId && credentials.clientSecret);
  }
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/configuration/AzureCredentialsConfig.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getCredentials": () => (/* binding */ getCredentials),
/* harmony export */   "getDefaultCredentials": () => (/* binding */ getDefaultCredentials),
/* harmony export */   "hasCredentials": () => (/* binding */ hasCredentials),
/* harmony export */   "resetCredentials": () => (/* binding */ resetCredentials),
/* harmony export */   "setDefaultCredentials": () => (/* binding */ setDefaultCredentials),
/* harmony export */   "updateCredentials": () => (/* binding */ updateCredentials)
/* harmony export */ });
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _AzureCredentials__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/configuration/AzureCredentials.ts");


const concealed = Symbol('Concealed client secret');

function getDefaultAzureCloud() {
  return _grafana_runtime__WEBPACK_IMPORTED_MODULE_0__.config.azure.cloud || _AzureCredentials__WEBPACK_IMPORTED_MODULE_1__.AzureCloud.Public;
}

function getSecret(options) {
  if (options.secureJsonFields.azureClientSecret) {
    // The secret is concealed on server
    return concealed;
  } else {
    var _options$secureJsonDa;

    const secret = (_options$secureJsonDa = options.secureJsonData) === null || _options$secureJsonDa === void 0 ? void 0 : _options$secureJsonDa.azureClientSecret;
    return typeof secret === 'string' && secret.length > 0 ? secret : undefined;
  }
}

function hasCredentials(options) {
  return !!options.jsonData.azureCredentials;
}
function getDefaultCredentials() {
  if (_grafana_runtime__WEBPACK_IMPORTED_MODULE_0__.config.azure.managedIdentityEnabled) {
    return {
      authType: 'msi'
    };
  } else {
    return {
      authType: 'clientsecret',
      azureCloud: getDefaultAzureCloud()
    };
  }
}
function getCredentials(options) {
  const credentials = options.jsonData.azureCredentials; // If no credentials saved, then return empty credentials
  // of type based on whether the managed identity enabled

  if (!credentials) {
    return getDefaultCredentials();
  }

  switch (credentials.authType) {
    case 'msi':
      if (_grafana_runtime__WEBPACK_IMPORTED_MODULE_0__.config.azure.managedIdentityEnabled) {
        return {
          authType: 'msi'
        };
      } else {
        // If authentication type is managed identity but managed identities were disabled in Grafana config,
        // then we should fallback to an empty app registration (client secret) configuration
        return {
          authType: 'clientsecret',
          azureCloud: getDefaultAzureCloud()
        };
      }

    case 'clientsecret':
      return {
        authType: 'clientsecret',
        azureCloud: credentials.azureCloud || getDefaultAzureCloud(),
        tenantId: credentials.tenantId,
        clientId: credentials.clientId,
        clientSecret: getSecret(options)
      };
  }
}
function updateCredentials(options, credentials) {
  switch (credentials.authType) {
    case 'msi':
      if (!_grafana_runtime__WEBPACK_IMPORTED_MODULE_0__.config.azure.managedIdentityEnabled) {
        throw new Error('Managed Identity authentication is not enabled in Grafana config.');
      }

      options = Object.assign({}, options, {
        jsonData: Object.assign({}, options.jsonData, {
          azureCredentials: {
            authType: 'msi'
          }
        })
      });
      return options;

    case 'clientsecret':
      options = Object.assign({}, options, {
        jsonData: Object.assign({}, options.jsonData, {
          azureCredentials: {
            authType: 'clientsecret',
            azureCloud: credentials.azureCloud || getDefaultAzureCloud(),
            tenantId: credentials.tenantId,
            clientId: credentials.clientId
          }
        }),
        secureJsonData: Object.assign({}, options.secureJsonData, {
          azureClientSecret: typeof credentials.clientSecret === 'string' && credentials.clientSecret.length > 0 ? credentials.clientSecret : undefined
        }),
        secureJsonFields: Object.assign({}, options.secureJsonFields, {
          azureClientSecret: typeof credentials.clientSecret === 'symbol'
        })
      });
      return options;
  }
}
function setDefaultCredentials(options) {
  return {
    jsonData: Object.assign({}, options.jsonData, {
      azureCredentials: getDefaultCredentials()
    })
  };
}
function resetCredentials(options) {
  return {
    jsonData: Object.assign({}, options.jsonData, {
      azureAuth: undefined,
      azureCredentials: undefined,
      azureEndpointResourceId: undefined
    })
  };
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/configuration/AzureCredentialsForm.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AzureCredentialsForm": () => (/* binding */ AzureCredentialsForm),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui_src_components__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-ui/src/components/index.ts");
/* harmony import */ var _grafana_ui_src_components_Forms_Legacy_Input_Input__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/components/Forms/Legacy/Input/Input.tsx");
/* harmony import */ var _grafana_ui_src_components_Forms_Legacy_Select_Select__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/components/Forms/Legacy/Select/Select.tsx");
/* harmony import */ var _AzureCredentials__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/configuration/AzureCredentials.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _InlineFormLabel, _InlineFormLabel2, _InlineFormLabel3, _InlineFormLabel4, _div, _InlineFormLabel5, _InlineFormLabel6;









const authTypeOptions = [{
  value: 'msi',
  label: 'Managed Identity'
}, {
  value: 'clientsecret',
  label: 'App Registration'
}];
const AzureCredentialsForm = props => {
  const {
    credentials,
    azureCloudOptions,
    onCredentialsChange,
    getSubscriptions
  } = props;
  const hasRequiredFields = (0,_AzureCredentials__WEBPACK_IMPORTED_MODULE_4__.isCredentialsComplete)(credentials);
  const [subscriptions, setSubscriptions] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);
  const [loadSubscriptionsClicked, onLoadSubscriptions] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(val => val + 1, 0);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    if (!getSubscriptions || !hasRequiredFields) {
      updateSubscriptions([]);
      return;
    }

    let canceled = false;
    getSubscriptions().then(result => {
      if (!canceled) {
        updateSubscriptions(result, loadSubscriptionsClicked);
      }
    });
    return () => {
      canceled = true;
    }; // This effect is intended to be called only once initially and on Load Subscriptions click
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [loadSubscriptionsClicked]);

  const updateSubscriptions = (received, autoSelect = false) => {
    setSubscriptions(received);

    if (getSubscriptions) {
      if (autoSelect && !credentials.defaultSubscriptionId && received.length > 0) {
        // Selecting the default subscription if subscriptions received but no default subscription selected
        onSubscriptionChange(received[0]);
      } else if (credentials.defaultSubscriptionId) {
        const found = received.find(opt => opt.value === credentials.defaultSubscriptionId);

        if (!found) {
          // Unselecting the default subscription if it isn't found among the received subscriptions
          onSubscriptionChange(undefined);
        }
      }
    }
  };

  const onAuthTypeChange = selected => {
    if (onCredentialsChange) {
      setSubscriptions([]);
      const updated = Object.assign({}, credentials, {
        authType: selected.value || 'msi',
        defaultSubscriptionId: undefined
      });
      onCredentialsChange(updated);
    }
  };

  const onAzureCloudChange = selected => {
    if (onCredentialsChange && credentials.authType === 'clientsecret') {
      setSubscriptions([]);
      const updated = Object.assign({}, credentials, {
        azureCloud: selected.value,
        defaultSubscriptionId: undefined
      });
      onCredentialsChange(updated);
    }
  };

  const onTenantIdChange = event => {
    if (onCredentialsChange && credentials.authType === 'clientsecret') {
      setSubscriptions([]);
      const updated = Object.assign({}, credentials, {
        tenantId: event.target.value,
        defaultSubscriptionId: undefined
      });
      onCredentialsChange(updated);
    }
  };

  const onClientIdChange = event => {
    if (onCredentialsChange && credentials.authType === 'clientsecret') {
      setSubscriptions([]);
      const updated = Object.assign({}, credentials, {
        clientId: event.target.value,
        defaultSubscriptionId: undefined
      });
      onCredentialsChange(updated);
    }
  };

  const onClientSecretChange = event => {
    if (onCredentialsChange && credentials.authType === 'clientsecret') {
      setSubscriptions([]);
      const updated = Object.assign({}, credentials, {
        clientSecret: event.target.value,
        defaultSubscriptionId: undefined
      });
      onCredentialsChange(updated);
    }
  };

  const onClientSecretReset = () => {
    if (onCredentialsChange && credentials.authType === 'clientsecret') {
      setSubscriptions([]);
      const updated = Object.assign({}, credentials, {
        clientSecret: '',
        defaultSubscriptionId: undefined
      });
      onCredentialsChange(updated);
    }
  };

  const onSubscriptionChange = selected => {
    if (onCredentialsChange) {
      const updated = Object.assign({}, credentials, {
        defaultSubscriptionId: selected === null || selected === void 0 ? void 0 : selected.value
      });
      onCredentialsChange(updated);
    }
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
    className: "gf-form-group",
    children: [props.managedIdentityEnabled && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
      className: "gf-form-inline",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
        className: "gf-form",
        children: [_InlineFormLabel || (_InlineFormLabel = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components__WEBPACK_IMPORTED_MODULE_1__.InlineFormLabel, {
          className: "width-12",
          tooltip: "Choose the type of authentication to Azure services",
          children: "Authentication"
        })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components_Forms_Legacy_Select_Select__WEBPACK_IMPORTED_MODULE_3__.Select, {
          className: "width-15",
          value: authTypeOptions.find(opt => opt.value === credentials.authType),
          options: authTypeOptions,
          onChange: onAuthTypeChange
        })]
      })
    }), credentials.authType === 'clientsecret' && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
      children: [azureCloudOptions && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
        className: "gf-form-inline",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
          className: "gf-form",
          children: [_InlineFormLabel2 || (_InlineFormLabel2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components__WEBPACK_IMPORTED_MODULE_1__.InlineFormLabel, {
            className: "width-12",
            tooltip: "Choose an Azure Cloud",
            children: "Azure Cloud"
          })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components_Forms_Legacy_Select_Select__WEBPACK_IMPORTED_MODULE_3__.Select, {
            className: "width-15",
            value: azureCloudOptions.find(opt => opt.value === credentials.azureCloud),
            options: azureCloudOptions,
            onChange: onAzureCloudChange
          })]
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
        className: "gf-form-inline",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
          className: "gf-form",
          children: [_InlineFormLabel3 || (_InlineFormLabel3 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components__WEBPACK_IMPORTED_MODULE_1__.InlineFormLabel, {
            className: "width-12",
            children: "Directory (tenant) ID"
          })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
            className: "width-15",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components_Forms_Legacy_Input_Input__WEBPACK_IMPORTED_MODULE_2__.Input, {
              className: "width-30",
              placeholder: "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX",
              value: credentials.tenantId || '',
              onChange: onTenantIdChange
            })
          })]
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
        className: "gf-form-inline",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
          className: "gf-form",
          children: [_InlineFormLabel4 || (_InlineFormLabel4 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components__WEBPACK_IMPORTED_MODULE_1__.InlineFormLabel, {
            className: "width-12",
            children: "Application (client) ID"
          })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
            className: "width-15",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components_Forms_Legacy_Input_Input__WEBPACK_IMPORTED_MODULE_2__.Input, {
              className: "width-30",
              placeholder: "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX",
              value: credentials.clientId || '',
              onChange: onClientIdChange
            })
          })]
        })
      }), typeof credentials.clientSecret === 'symbol' ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
        className: "gf-form-inline",
        children: [_div || (_div = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
          className: "gf-form",
          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components__WEBPACK_IMPORTED_MODULE_1__.InlineFormLabel, {
            className: "width-12",
            children: "Client Secret"
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components_Forms_Legacy_Input_Input__WEBPACK_IMPORTED_MODULE_2__.Input, {
            className: "width-25",
            placeholder: "configured",
            disabled: true
          })]
        })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
          className: "gf-form",
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
            className: "max-width-30 gf-form-inline",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components__WEBPACK_IMPORTED_MODULE_1__.Button, {
              variant: "secondary",
              type: "button",
              onClick: onClientSecretReset,
              children: "reset"
            })
          })
        })]
      }) : /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
        className: "gf-form-inline",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
          className: "gf-form",
          children: [_InlineFormLabel5 || (_InlineFormLabel5 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components__WEBPACK_IMPORTED_MODULE_1__.InlineFormLabel, {
            className: "width-12",
            children: "Client Secret"
          })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
            className: "width-15",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components_Forms_Legacy_Input_Input__WEBPACK_IMPORTED_MODULE_2__.Input, {
              className: "width-30",
              placeholder: "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX",
              value: credentials.clientSecret || '',
              onChange: onClientSecretChange
            })
          })]
        })
      })]
    }), getSubscriptions && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
        className: "gf-form-inline",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
          className: "gf-form",
          children: [_InlineFormLabel6 || (_InlineFormLabel6 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components__WEBPACK_IMPORTED_MODULE_1__.InlineFormLabel, {
            className: "width-12",
            children: "Default Subscription"
          })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
            className: "width-25",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components_Forms_Legacy_Select_Select__WEBPACK_IMPORTED_MODULE_3__.Select, {
              value: credentials.defaultSubscriptionId ? subscriptions.find(opt => opt.value === credentials.defaultSubscriptionId) : undefined,
              options: subscriptions,
              onChange: onSubscriptionChange
            })
          })]
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
        className: "gf-form-inline",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
          className: "gf-form",
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
            className: "max-width-30 gf-form-inline",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components__WEBPACK_IMPORTED_MODULE_1__.Button, {
              variant: "secondary",
              size: "sm",
              type: "button",
              onClick: onLoadSubscriptions,
              disabled: !hasRequiredFields,
              children: "Load Subscriptions"
            })
          })
        })
      })]
    })]
  });
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AzureCredentialsForm);

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/configuration/ConfigEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConfigEditor": () => (/* binding */ ConfigEditor)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_core_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/core/config.ts");
/* harmony import */ var app_features_alerting_unified_utils_alertmanager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/features/alerting/unified/utils/alertmanager.ts");
/* harmony import */ var _AzureAuthSettings__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/configuration/AzureAuthSettings.tsx");
/* harmony import */ var _AzureCredentialsConfig__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/configuration/AzureCredentialsConfig.ts");
/* harmony import */ var _PromSettings__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/prometheus/configuration/PromSettings.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _Alert;











const ConfigEditor = props => {
  var _config$featureToggle;

  const {
    options,
    onOptionsChange
  } = props;
  const alertmanagers = (0,app_features_alerting_unified_utils_alertmanager__WEBPACK_IMPORTED_MODULE_3__.getAllAlertmanagerDataSources)();
  const azureAuthSettings = {
    azureAuthSupported: (_config$featureToggle = app_core_config__WEBPACK_IMPORTED_MODULE_2__.config.featureToggles.prometheus_azure_auth) !== null && _config$featureToggle !== void 0 ? _config$featureToggle : false,
    getAzureAuthEnabled: config => (0,_AzureCredentialsConfig__WEBPACK_IMPORTED_MODULE_5__.hasCredentials)(config),
    setAzureAuthEnabled: (config, enabled) => enabled ? (0,_AzureCredentialsConfig__WEBPACK_IMPORTED_MODULE_5__.setDefaultCredentials)(config) : (0,_AzureCredentialsConfig__WEBPACK_IMPORTED_MODULE_5__.resetCredentials)(config),
    azureSettingsUI: _AzureAuthSettings__WEBPACK_IMPORTED_MODULE_4__.AzureAuthSettings
  };
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.Fragment, {
    children: [options.access === 'direct' && (_Alert || (_Alert = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Alert, {
      title: "Deprecation Notice",
      severity: "warning",
      children: "Browser access mode in the Prometheus datasource is deprecated and will be removed in a future release."
    }))), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.DataSourceHttpSettings, {
      defaultUrl: "http://localhost:9090",
      dataSourceConfig: options,
      showAccessOptions: true,
      onChange: onOptionsChange,
      sigV4AuthToggleEnabled: app_core_config__WEBPACK_IMPORTED_MODULE_2__.config.sigV4AuthEnabled,
      azureAuthSettings: azureAuthSettings
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.AlertingSettings, {
      alertmanagerDataSources: alertmanagers,
      options: options,
      onOptionsChange: onOptionsChange
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_PromSettings__WEBPACK_IMPORTED_MODULE_6__.PromSettings, {
      options: options,
      onOptionsChange: onOptionsChange
    })]
  });
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/configuration/ExemplarSetting.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ExemplarSetting)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_e2e_selectors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-e2e-selectors/src/index.ts");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");








function ExemplarSetting({
  value,
  onChange,
  onDelete
}) {
  const [isInternalLink, setIsInternalLink] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(Boolean(value.datasourceUid));
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
    className: "gf-form-group",
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.InlineField, {
      label: "Internal link",
      labelWidth: 24,
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.InlineSwitch, {
          value: isInternalLink,
          "aria-label": _grafana_e2e_selectors__WEBPACK_IMPORTED_MODULE_2__.selectors.components.DataSource.Prometheus.configPage.internalLinkSwitch,
          onChange: ev => setIsInternalLink(ev.currentTarget.checked)
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Button, {
          variant: "destructive",
          title: "Remove link",
          icon: "times",
          onClick: event => {
            event.preventDefault();
            onDelete();
          },
          className: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
              margin-left: 8px;
            `
        })]
      })
    }), isInternalLink ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.InlineField, {
      label: "Data source",
      labelWidth: 24,
      tooltip: "The data source the exemplar is going to navigate to.",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_runtime__WEBPACK_IMPORTED_MODULE_3__.DataSourcePicker, {
        tracing: true,
        current: value.datasourceUid,
        noDefault: true,
        width: 40,
        onChange: ds => onChange(Object.assign({}, value, {
          datasourceUid: ds.uid,
          url: undefined
        }))
      })
    }) : /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.InlineField, {
      label: "URL",
      labelWidth: 24,
      tooltip: "The URL of the trace backend the user would go to see its trace.",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Input, {
        placeholder: "https://example.com/${__value.raw}",
        spellCheck: false,
        width: 40,
        value: value.url,
        onChange: event => onChange(Object.assign({}, value, {
          datasourceUid: undefined,
          url: event.currentTarget.value
        }))
      })
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.InlineField, {
      label: "URL Label",
      labelWidth: 24,
      tooltip: "Use to override the button label on the exemplar traceID field.",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Input, {
        placeholder: "Go to example.com",
        spellCheck: false,
        width: 40,
        value: value.urlDisplayLabel,
        onChange: event => onChange(Object.assign({}, value, {
          urlDisplayLabel: event.currentTarget.value
        }))
      })
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.InlineField, {
      label: "Label name",
      labelWidth: 24,
      tooltip: "The name of the field in the labels object that should be used to get the traceID.",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Input, {
        placeholder: "traceID",
        spellCheck: false,
        width: 40,
        value: value.name,
        onChange: event => onChange(Object.assign({}, value, {
          name: event.currentTarget.value
        }))
      })
    })]
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/configuration/ExemplarsSettings.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ExemplarsSettings": () => (/* binding */ ExemplarsSettings)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_e2e_selectors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-e2e-selectors/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _ExemplarSetting__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/configuration/ExemplarSetting.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _h;









function ExemplarsSettings({
  options,
  onChange
}) {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
    children: [_h || (_h = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("h3", {
      className: "page-heading",
      children: "Exemplars"
    })), options && options.map((option, index) => {
      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_ExemplarSetting__WEBPACK_IMPORTED_MODULE_4__["default"], {
        value: option,
        onChange: newField => {
          const newOptions = [...options];
          newOptions.splice(index, 1, newField);
          onChange(newOptions);
        },
        onDelete: () => {
          const newOptions = [...options];
          newOptions.splice(index, 1);
          onChange(newOptions);
        }
      }, index);
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
      variant: "secondary",
      "aria-label": _grafana_e2e_selectors__WEBPACK_IMPORTED_MODULE_2__.selectors.components.DataSource.Prometheus.configPage.exemplarsAddButton,
      className: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
          margin-bottom: 10px;
        `,
      icon: "plus",
      onClick: event => {
        event.preventDefault();
        const newOptions = [...(options || []), {
          name: 'traceID'
        }];
        onChange(newOptions);
      },
      children: "Add"
    })]
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/configuration/PromSettings.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromSettings": () => (/* binding */ PromSettings),
/* harmony export */   "getValueFromEventItem": () => (/* binding */ getValueFromEventItem),
/* harmony export */   "promSettingsValidationEvents": () => (/* binding */ promSettingsValidationEvents)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _ExemplarsSettings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/configuration/ExemplarsSettings.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _InlineFormLabel, _h;








const {
  Select,
  Input,
  FormField
} = _grafana_ui__WEBPACK_IMPORTED_MODULE_2__.LegacyForms;
const httpOptions = [{
  value: 'POST',
  label: 'POST'
}, {
  value: 'GET',
  label: 'GET'
}];
const PromSettings = props => {
  var _options$jsonData$dis;

  const {
    options,
    onOptionsChange
  } = props; // We are explicitly adding httpMethod so it is correctly displayed in dropdown. This way, it is more predictable for users.

  if (!options.jsonData.httpMethod) {
    options.jsonData.httpMethod = 'POST';
  }

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
      className: "gf-form-group",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
        className: "gf-form-inline",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
          className: "gf-form",
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(FormField, {
            label: "Scrape interval",
            labelWidth: 13,
            inputEl: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(Input, {
              className: "width-6",
              value: options.jsonData.timeInterval,
              spellCheck: false,
              placeholder: "15s",
              onChange: onChangeHandler('timeInterval', options, onOptionsChange),
              validationEvents: promSettingsValidationEvents
            }),
            tooltip: "Set this to the typical scrape and evaluation interval configured in Prometheus. Defaults to 15s."
          })
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
        className: "gf-form-inline",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
          className: "gf-form",
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(FormField, {
            label: "Query timeout",
            labelWidth: 13,
            inputEl: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(Input, {
              className: "width-6",
              value: options.jsonData.queryTimeout,
              onChange: onChangeHandler('queryTimeout', options, onOptionsChange),
              spellCheck: false,
              placeholder: "60s",
              validationEvents: promSettingsValidationEvents
            }),
            tooltip: "Set the Prometheus query timeout."
          })
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
        className: "gf-form",
        children: [_InlineFormLabel || (_InlineFormLabel = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.InlineFormLabel, {
          width: 13,
          tooltip: "You can use either POST or GET HTTP method to query your Prometheus data source. POST is the recommended method as it allows bigger queries. Change this to GET if you have a Prometheus version older than 2.1 or if POST requests are restricted in your network.",
          children: "HTTP Method"
        })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(Select, {
          "aria-label": "Select HTTP method",
          options: httpOptions,
          value: httpOptions.find(o => o.value === options.jsonData.httpMethod),
          onChange: onChangeHandler('httpMethod', options, onOptionsChange),
          width: 7
        })]
      })]
    }), _h || (_h = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("h3", {
      className: "page-heading",
      children: "Misc"
    })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
      className: "gf-form-group",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
        className: "gf-form",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.InlineField, {
          labelWidth: 28,
          label: "Disable metrics lookup",
          tooltip: "Checking this option will disable the metrics chooser and metric/label support in the query field's autocomplete. This helps if you have performance issues with bigger Prometheus instances.",
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.InlineSwitch, {
            value: (_options$jsonData$dis = options.jsonData.disableMetricsLookup) !== null && _options$jsonData$dis !== void 0 ? _options$jsonData$dis : false,
            onChange: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_1__.onUpdateDatasourceJsonDataOptionChecked)(props, 'disableMetricsLookup')
          })
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
        className: "gf-form-inline",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
          className: "gf-form max-width-30",
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(FormField, {
            label: "Custom query parameters",
            labelWidth: 14,
            tooltip: "Add Custom parameters to all Prometheus or Thanos queries.",
            inputEl: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(Input, {
              className: "width-25",
              value: options.jsonData.customQueryParameters,
              onChange: onChangeHandler('customQueryParameters', options, onOptionsChange),
              spellCheck: false,
              placeholder: "Example: max_source_resolution=5m&timeout=10"
            })
          })
        })
      })]
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_ExemplarsSettings__WEBPACK_IMPORTED_MODULE_3__.ExemplarsSettings, {
      options: options.jsonData.exemplarTraceIdDestinations,
      onChange: exemplarOptions => (0,_grafana_data__WEBPACK_IMPORTED_MODULE_1__.updateDatasourcePluginJsonDataOption)({
        onOptionsChange,
        options
      }, 'exemplarTraceIdDestinations', exemplarOptions)
    })]
  });
};
const promSettingsValidationEvents = {
  [_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.EventsWithValidation.onBlur]: [(0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.regexValidation)(/^$|^\d+(ms|[Mwdhmsy])$/, 'Value is not valid, you can use number with time unit specifier: y, M, w, d, h, m, s')]
};
const getValueFromEventItem = eventItem => {
  if (!eventItem) {
    return '';
  }

  if (eventItem.hasOwnProperty('currentTarget')) {
    return eventItem.currentTarget.value;
  }

  return eventItem.value;
};

const onChangeHandler = (key, options, onOptionsChange) => eventItem => {
  onOptionsChange(Object.assign({}, options, {
    jsonData: Object.assign({}, options.jsonData, {
      [key]: getValueFromEventItem(eventItem)
    })
  }));
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/datasource.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ANNOTATION_QUERY_STEP_DEFAULT": () => (/* binding */ ANNOTATION_QUERY_STEP_DEFAULT),
/* harmony export */   "PrometheusDatasource": () => (/* binding */ PrometheusDatasource),
/* harmony export */   "alignRange": () => (/* binding */ alignRange),
/* harmony export */   "extractRuleMappingFromGroups": () => (/* binding */ extractRuleMappingFromGroups),
/* harmony export */   "prometheusRegularEscape": () => (/* binding */ prometheusRegularEscape),
/* harmony export */   "prometheusSpecialRegexEscape": () => (/* binding */ prometheusSpecialRegexEscape)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/lru-cache-npm-7.9.0-d803108233-c91a293a10.zip/node_modules/lru-cache/index.js");
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lru_cache__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/lastValueFrom.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/of.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/util/pipe.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/merge.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/forkJoin.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/throwError.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/map.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/tap.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/filter.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/catchError.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_core_utils_explore__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/core/utils/explore.ts");
/* harmony import */ var app_features_alerting_unified_api_buildInfo__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/features/alerting/unified/api/buildInfo.ts");
/* harmony import */ var app_features_dashboard_services_TimeSrv__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./public/app/features/dashboard/services/TimeSrv.ts");
/* harmony import */ var app_features_templating_template_srv__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./public/app/features/templating/template_srv.ts");
/* harmony import */ var app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./public/app/types/unified-alerting-dto.ts");
/* harmony import */ var _add_label_to_query__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./public/app/plugins/datasource/prometheus/add_label_to_query.ts");
/* harmony import */ var _language_provider__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./public/app/plugins/datasource/prometheus/language_provider.ts");
/* harmony import */ var _language_utils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./public/app/plugins/datasource/prometheus/language_utils.ts");
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./public/app/plugins/datasource/prometheus/legend.ts");
/* harmony import */ var _metric_find_query__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./public/app/plugins/datasource/prometheus/metric_find_query.ts");
/* harmony import */ var _query_hints__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("./public/app/plugins/datasource/prometheus/query_hints.ts");
/* harmony import */ var _result_transformer__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__("./public/app/plugins/datasource/prometheus/result_transformer.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__("./public/app/plugins/datasource/prometheus/types.ts");
/* harmony import */ var _variables__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__("./public/app/plugins/datasource/prometheus/variables.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _Badge, _Badge2, _Tooltip, _div, _div2;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


























const ANNOTATION_QUERY_STEP_DEFAULT = '60s';
const GET_AND_POST_METADATA_ENDPOINTS = ['api/v1/query', 'api/v1/query_range', 'api/v1/series', 'api/v1/labels'];
class PrometheusDatasource extends _grafana_runtime__WEBPACK_IMPORTED_MODULE_4__.DataSourceWithBackend {
  constructor(instanceSettings, templateSrv = (0,app_features_templating_template_srv__WEBPACK_IMPORTED_MODULE_9__.getTemplateSrv)(), timeSrv = (0,app_features_dashboard_services_TimeSrv__WEBPACK_IMPORTED_MODULE_8__.getTimeSrv)(), languageProvider) {
    var _instanceSettings$jso, _instanceSettings$jso2;

    super(instanceSettings);
    this.templateSrv = templateSrv;
    this.timeSrv = timeSrv;

    _defineProperty(this, "type", void 0);

    _defineProperty(this, "editorSrc", void 0);

    _defineProperty(this, "ruleMappings", void 0);

    _defineProperty(this, "url", void 0);

    _defineProperty(this, "id", void 0);

    _defineProperty(this, "directUrl", void 0);

    _defineProperty(this, "access", void 0);

    _defineProperty(this, "basicAuth", void 0);

    _defineProperty(this, "withCredentials", void 0);

    _defineProperty(this, "metricsNameCache", new (lru_cache__WEBPACK_IMPORTED_MODULE_1___default())({
      max: 10
    }));

    _defineProperty(this, "interval", void 0);

    _defineProperty(this, "queryTimeout", void 0);

    _defineProperty(this, "httpMethod", void 0);

    _defineProperty(this, "languageProvider", void 0);

    _defineProperty(this, "exemplarTraceIdDestinations", void 0);

    _defineProperty(this, "lookupsDisabled", void 0);

    _defineProperty(this, "customQueryParameters", void 0);

    _defineProperty(this, "exemplarsAvailable", void 0);

    _defineProperty(this, "subType", void 0);

    _defineProperty(this, "rulerEnabled", void 0);

    _defineProperty(this, "init", async () => {
      this.loadRules();
      this.exemplarsAvailable = await this.areExemplarsAvailable();
    });

    _defineProperty(this, "prepareTargets", (options, start, end) => {
      const queries = [];
      const activeTargets = [];
      const clonedTargets = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.cloneDeep)(options.targets);

      for (const target of clonedTargets) {
        if (!target.expr || target.hide) {
          continue;
        }

        target.requestId = options.panelId + target.refId;
        const metricName = this.languageProvider.histogramMetrics.find(m => target.expr.includes(m)); // In Explore, we run both (instant and range) queries if both are true (selected) or both are undefined (legacy Explore queries)

        if (options.app === _grafana_data__WEBPACK_IMPORTED_MODULE_3__.CoreApp.Explore && target.range === target.instant) {
          // Create instant target
          const instantTarget = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.cloneDeep)(target);
          instantTarget.format = 'table';
          instantTarget.instant = true;
          instantTarget.range = false;
          instantTarget.valueWithRefId = true;
          delete instantTarget.maxDataPoints;
          instantTarget.requestId += '_instant'; // Create range target

          const rangeTarget = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.cloneDeep)(target);
          rangeTarget.format = 'time_series';
          rangeTarget.instant = false;
          instantTarget.range = true; // Create exemplar query

          if (target.exemplar) {
            // Only create exemplar target for different metric names
            if (!metricName || metricName && !activeTargets.some(activeTarget => activeTarget.expr.includes(metricName))) {
              const exemplarTarget = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.cloneDeep)(target);
              exemplarTarget.instant = false;
              exemplarTarget.requestId += '_exemplar';
              queries.push(this.createQuery(exemplarTarget, options, start, end));
              activeTargets.push(exemplarTarget);
            }

            instantTarget.exemplar = false;
            rangeTarget.exemplar = false;
          } // Add both targets to activeTargets and queries arrays


          activeTargets.push(instantTarget, rangeTarget);
          queries.push(this.createQuery(instantTarget, options, start, end), this.createQuery(rangeTarget, options, start, end)); // If running only instant query in Explore, format as table
        } else if (target.instant && options.app === _grafana_data__WEBPACK_IMPORTED_MODULE_3__.CoreApp.Explore) {
          const instantTarget = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.cloneDeep)(target);
          instantTarget.format = 'table';
          queries.push(this.createQuery(instantTarget, options, start, end));
          activeTargets.push(instantTarget);
        } else {
          // It doesn't make sense to query for exemplars in dashboard if only instant is selected
          if (target.exemplar && !target.instant) {
            if (!metricName || metricName && !activeTargets.some(activeTarget => activeTarget.expr.includes(metricName))) {
              const exemplarTarget = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.cloneDeep)(target);
              exemplarTarget.requestId += '_exemplar';
              queries.push(this.createQuery(exemplarTarget, options, start, end));
              activeTargets.push(exemplarTarget);
            }

            target.exemplar = false;
          }

          queries.push(this.createQuery(target, options, start, end));
          activeTargets.push(target);
        }
      }

      return {
        queries,
        activeTargets
      };
    });

    _defineProperty(this, "handleErrors", (err, target) => {
      const error = {
        message: err && err.statusText || 'Unknown error during query transaction. Please check JS console logs.',
        refId: target.refId
      };

      if (err.data) {
        if (typeof err.data === 'string') {
          error.message = err.data;
        } else if (err.data.error) {
          error.message = (0,app_core_utils_explore__WEBPACK_IMPORTED_MODULE_6__.safeStringifyValue)(err.data.error);
        }
      } else if (err.message) {
        error.message = err.message;
      } else if (typeof err === 'string') {
        error.message = err;
      }

      error.status = err.status;
      error.statusText = err.statusText;
      return error;
    });

    _defineProperty(this, "processAnnotationResponse", (options, data) => {
      const frames = (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_4__.toDataQueryResponse)({
        data: data
      }).data;

      if (!frames || !frames.length) {
        return [];
      }

      const annotation = options.annotation;
      const {
        tagKeys = '',
        titleFormat = '',
        textFormat = ''
      } = annotation;
      const step = _grafana_data__WEBPACK_IMPORTED_MODULE_3__.rangeUtil.intervalToSeconds(annotation.step || ANNOTATION_QUERY_STEP_DEFAULT) * 1000;
      const tagKeysArray = tagKeys.split(',');
      const eventList = [];

      for (const frame of frames) {
        const timeField = frame.fields[0];
        const valueField = frame.fields[1];
        const labels = (valueField === null || valueField === void 0 ? void 0 : valueField.labels) || {};
        const tags = Object.keys(labels).filter(label => tagKeysArray.includes(label)).map(label => labels[label]);
        const timeValueTuple = [];
        let idx = 0;
        valueField.values.toArray().forEach(value => {
          let timeStampValue;
          let valueValue;
          const time = timeField.values.get(idx); // If we want to use value as a time, we use value as timeStampValue and valueValue will be 1

          if (options.annotation.useValueForTime) {
            timeStampValue = Math.floor(parseFloat(value));
            valueValue = 1;
          } else {
            timeStampValue = Math.floor(parseFloat(time));
            valueValue = parseFloat(value);
          }

          idx++;
          timeValueTuple.push([timeStampValue, valueValue]);
        });
        const activeValues = timeValueTuple.filter(value => value[1] >= 1);
        const activeValuesTimestamps = activeValues.map(value => value[0]); // Instead of creating singular annotation for each active event we group events into region if they are less
        // or equal to `step` apart.

        let latestEvent = null;

        for (const timestamp of activeValuesTimestamps) {
          var _latestEvent$timeEnd;

          // We already have event `open` and we have new event that is inside the `step` so we just update the end.
          if (latestEvent && ((_latestEvent$timeEnd = latestEvent.timeEnd) !== null && _latestEvent$timeEnd !== void 0 ? _latestEvent$timeEnd : 0) + step >= timestamp) {
            latestEvent.timeEnd = timestamp;
            continue;
          } // Event exists but new one is outside of the `step` so we add it to eventList.


          if (latestEvent) {
            eventList.push(latestEvent);
          } // We start a new region.


          latestEvent = {
            time: timestamp,
            timeEnd: timestamp,
            annotation,
            title: (0,_legend__WEBPACK_IMPORTED_MODULE_14__.renderLegendFormat)(titleFormat, labels),
            tags,
            text: (0,_legend__WEBPACK_IMPORTED_MODULE_14__.renderLegendFormat)(textFormat, labels)
          };
        }

        if (latestEvent) {
          // Finish up last point if we have one
          latestEvent.timeEnd = activeValuesTimestamps[activeValuesTimestamps.length - 1];
          eventList.push(latestEvent);
        }
      }

      return eventList;
    });

    this.templateSrv = templateSrv;
    this.timeSrv = timeSrv;
    this.type = 'prometheus';
    this.subType = app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_10__.PromApplication.Prometheus;
    this.rulerEnabled = false;
    this.editorSrc = 'app/features/prometheus/partials/query.editor.html';
    this.id = instanceSettings.id;
    this.url = instanceSettings.url;
    this.access = instanceSettings.access;
    this.basicAuth = instanceSettings.basicAuth;
    this.withCredentials = instanceSettings.withCredentials;
    this.interval = instanceSettings.jsonData.timeInterval || '15s';
    this.queryTimeout = instanceSettings.jsonData.queryTimeout;
    this.httpMethod = instanceSettings.jsonData.httpMethod || 'POST'; // `directUrl` is never undefined, we set it at https://github.com/grafana/grafana/blob/main/pkg/api/frontendsettings.go#L108
    // here we "fall back" to this.url to make typescript happy, but it should never happen

    this.directUrl = (_instanceSettings$jso = instanceSettings.jsonData.directUrl) !== null && _instanceSettings$jso !== void 0 ? _instanceSettings$jso : this.url;
    this.exemplarTraceIdDestinations = instanceSettings.jsonData.exemplarTraceIdDestinations;
    this.ruleMappings = {};
    this.languageProvider = languageProvider !== null && languageProvider !== void 0 ? languageProvider : new _language_provider__WEBPACK_IMPORTED_MODULE_12__["default"](this);
    this.lookupsDisabled = (_instanceSettings$jso2 = instanceSettings.jsonData.disableMetricsLookup) !== null && _instanceSettings$jso2 !== void 0 ? _instanceSettings$jso2 : false;
    this.customQueryParameters = new URLSearchParams(instanceSettings.jsonData.customQueryParameters);
    this.variables = new _variables__WEBPACK_IMPORTED_MODULE_19__.PrometheusVariableSupport(this, this.templateSrv, this.timeSrv);
    this.exemplarsAvailable = true;
  }

  getQueryDisplayText(query) {
    return query.expr;
  }

  _addTracingHeaders(httpOptions, options) {
    httpOptions.headers = {};
    const proxyMode = !this.url.match(/^http/);

    if (proxyMode) {
      httpOptions.headers['X-Dashboard-Id'] = options.dashboardId;
      httpOptions.headers['X-Panel-Id'] = options.panelId;
    }
  }
  /**
   * Any request done from this data source should go through here as it contains some common processing for the
   * request. Any processing done here needs to be also copied on the backend as this goes through data source proxy
   * but not through the same code as alerting.
   */


  _request(url, data, overrides = {}) {
    data = data || {};

    for (const [key, value] of this.customQueryParameters) {
      if (data[key] == null) {
        data[key] = value;
      }
    }

    const options = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.defaults)(overrides, {
      url: this.url + url,
      method: this.httpMethod,
      headers: {}
    });

    if (options.method === 'GET') {
      if (data && Object.keys(data).length) {
        options.url = options.url + (options.url.search(/\?/) >= 0 ? '&' : '?') + Object.entries(data).map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`).join('&');
      }
    } else {
      options.headers['Content-Type'] = 'application/x-www-form-urlencoded';
      options.data = data;
    }

    if (this.basicAuth || this.withCredentials) {
      options.withCredentials = true;
    }

    if (this.basicAuth) {
      options.headers.Authorization = this.basicAuth;
    }

    return (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_4__.getBackendSrv)().fetch(options);
  }

  async importFromAbstractQueries(abstractQueries) {
    return abstractQueries.map(abstractQuery => this.languageProvider.importFromAbstractQuery(abstractQuery));
  }

  async exportToAbstractQueries(queries) {
    return queries.map(query => this.languageProvider.exportToAbstractQuery(query));
  } // Use this for tab completion features, wont publish response to other components


  async metadataRequest(url, params = {}) {
    // If URL includes endpoint that supports POST and GET method, try to use configured method. This might fail as POST is supported only in v2.10+.
    if (GET_AND_POST_METADATA_ENDPOINTS.some(endpoint => url.includes(endpoint))) {
      try {
        return await (0,rxjs__WEBPACK_IMPORTED_MODULE_21__.lastValueFrom)(this._request(url, params, {
          method: this.httpMethod,
          hideFromInspector: true
        }));
      } catch (err) {
        // If status code of error is Method Not Allowed (405) and HTTP method is POST, retry with GET
        if (this.httpMethod === 'POST' && err.status === 405) {
          console.warn(`Couldn't use configured POST HTTP method for this request. Trying to use GET method instead.`);
        } else {
          throw err;
        }
      }
    }

    return await (0,rxjs__WEBPACK_IMPORTED_MODULE_21__.lastValueFrom)(this._request(url, params, {
      method: 'GET',
      hideFromInspector: true
    })); // toPromise until we change getTagValues, getTagKeys to Observable
  }

  interpolateQueryExpr(value = [], variable) {
    // if no multi or include all do not regexEscape
    if (!variable.multi && !variable.includeAll) {
      return prometheusRegularEscape(value);
    }

    if (typeof value === 'string') {
      return prometheusSpecialRegexEscape(value);
    }

    const escapedValues = value.map(val => prometheusSpecialRegexEscape(val));

    if (escapedValues.length === 1) {
      return escapedValues[0];
    }

    return '(' + escapedValues.join('|') + ')';
  }

  targetContainsTemplate(target) {
    return this.templateSrv.containsTemplate(target.expr);
  }

  shouldRunExemplarQuery(target, request) {
    if (target.exemplar) {
      // We check all already processed targets and only create exemplar target for not used metric names
      const metricName = this.languageProvider.histogramMetrics.find(m => target.expr.includes(m)); // Remove targets that weren't processed yet (in targets array they are after current target)

      const currentTargetIdx = request.targets.findIndex(t => t.refId === target.refId);
      const targets = request.targets.slice(0, currentTargetIdx);

      if (!metricName || metricName && !targets.some(t => t.expr.includes(metricName))) {
        return true;
      }

      return false;
    }

    return false;
  }

  processTargetV2(target, request) {
    const processedTarget = Object.assign({}, target, {
      queryType: _types__WEBPACK_IMPORTED_MODULE_18__.PromQueryType.timeSeriesQuery,
      exemplar: this.shouldRunExemplarQuery(target, request),
      requestId: request.panelId + target.refId,
      // We need to pass utcOffsetSec to backend to calculate aligned range
      utcOffsetSec: this.timeSrv.timeRange().to.utcOffset() * 60
    });
    return processedTarget;
  }

  query(request) {
    if (this.access === 'proxy') {
      const targets = request.targets.map(target => this.processTargetV2(target, request));
      return super.query(Object.assign({}, request, {
        targets
      })).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_22__.map)(response => (0,_result_transformer__WEBPACK_IMPORTED_MODULE_17__.transformV2)(response, request, {
        exemplarTraceIdDestinations: this.exemplarTraceIdDestinations
      }))); // Run queries trough browser/proxy
    } else {
      const start = this.getPrometheusTime(request.range.from, false);
      const end = this.getPrometheusTime(request.range.to, true);
      const {
        queries,
        activeTargets
      } = this.prepareTargets(request, start, end); // No valid targets, return the empty result to save a round trip.

      if (!queries || !queries.length) {
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_23__.of)({
          data: [],
          state: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.LoadingState.Done
        });
      }

      if (request.app === _grafana_data__WEBPACK_IMPORTED_MODULE_3__.CoreApp.Explore) {
        return this.exploreQuery(queries, activeTargets, end);
      }

      return this.panelsQuery(queries, activeTargets, end, request.requestId, request.scopedVars);
    }
  }

  exploreQuery(queries, activeTargets, end) {
    let runningQueriesCount = queries.length;
    const subQueries = queries.map((query, index) => {
      const target = activeTargets[index];
      const filterAndMapResponse = (0,rxjs__WEBPACK_IMPORTED_MODULE_24__.pipe)( // Decrease the counter here. We assume that each request returns only single value and then completes
      // (should hold until there is some streaming requests involved).
      (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_25__.tap)(() => runningQueriesCount--), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_26__.filter)(response => response.cancelled ? false : true), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_22__.map)(response => {
        const data = (0,_result_transformer__WEBPACK_IMPORTED_MODULE_17__.transform)(response, {
          query,
          target,
          responseListLength: queries.length,
          exemplarTraceIdDestinations: this.exemplarTraceIdDestinations
        });
        return {
          data,
          key: query.requestId,
          state: runningQueriesCount === 0 ? _grafana_data__WEBPACK_IMPORTED_MODULE_3__.LoadingState.Done : _grafana_data__WEBPACK_IMPORTED_MODULE_3__.LoadingState.Loading
        };
      }));
      return this.runQuery(query, end, filterAndMapResponse);
    });
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_27__.merge)(...subQueries);
  }

  panelsQuery(queries, activeTargets, end, requestId, scopedVars) {
    const observables = queries.map((query, index) => {
      const target = activeTargets[index];
      const filterAndMapResponse = (0,rxjs__WEBPACK_IMPORTED_MODULE_24__.pipe)((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_26__.filter)(response => response.cancelled ? false : true), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_22__.map)(response => {
        const data = (0,_result_transformer__WEBPACK_IMPORTED_MODULE_17__.transform)(response, {
          query,
          target,
          responseListLength: queries.length,
          scopedVars,
          exemplarTraceIdDestinations: this.exemplarTraceIdDestinations
        });
        return data;
      }));
      return this.runQuery(query, end, filterAndMapResponse);
    });
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_28__.forkJoin)(observables).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_22__.map)(results => {
      const data = results.reduce((result, current) => {
        return [...result, ...current];
      }, []);
      return {
        data,
        key: requestId,
        state: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.LoadingState.Done
      };
    }));
  }

  runQuery(query, end, filter) {
    if (query.instant) {
      return this.performInstantQuery(query, end).pipe(filter);
    }

    if (query.exemplar) {
      return this.getExemplars(query).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_29__.catchError)(() => {
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_23__.of)({
          data: [],
          state: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.LoadingState.Done
        });
      }), filter);
    }

    return this.performTimeSeriesQuery(query, query.start, query.end).pipe(filter);
  }

  createQuery(target, options, start, end) {
    const query = {
      hinting: target.hinting,
      instant: target.instant,
      exemplar: target.exemplar,
      step: 0,
      expr: '',
      requestId: target.requestId,
      refId: target.refId,
      start: 0,
      end: 0
    };
    const range = Math.ceil(end - start); // options.interval is the dynamically calculated interval

    let interval = _grafana_data__WEBPACK_IMPORTED_MODULE_3__.rangeUtil.intervalToSeconds(options.interval); // Minimum interval ("Min step"), if specified for the query, or same as interval otherwise.

    const minInterval = _grafana_data__WEBPACK_IMPORTED_MODULE_3__.rangeUtil.intervalToSeconds(this.templateSrv.replace(target.interval || options.interval, options.scopedVars)); // Scrape interval as specified for the query ("Min step") or otherwise taken from the datasource.
    // Min step field can have template variables in it, make sure to replace it.

    const scrapeInterval = target.interval ? _grafana_data__WEBPACK_IMPORTED_MODULE_3__.rangeUtil.intervalToSeconds(this.templateSrv.replace(target.interval, options.scopedVars)) : _grafana_data__WEBPACK_IMPORTED_MODULE_3__.rangeUtil.intervalToSeconds(this.interval);
    const intervalFactor = target.intervalFactor || 1; // Adjust the interval to take into account any specified minimum and interval factor plus Prometheus limits

    const adjustedInterval = this.adjustInterval(interval, minInterval, range, intervalFactor);
    let scopedVars = Object.assign({}, options.scopedVars, this.getRangeScopedVars(options.range), this.getRateIntervalScopedVariable(adjustedInterval, scrapeInterval)); // If the interval was adjusted, make a shallow copy of scopedVars with updated interval vars

    if (interval !== adjustedInterval) {
      interval = adjustedInterval;
      scopedVars = Object.assign({}, options.scopedVars, Object.assign({
        __interval: {
          text: interval + 's',
          value: interval + 's'
        },
        __interval_ms: {
          text: interval * 1000,
          value: interval * 1000
        }
      }, this.getRateIntervalScopedVariable(interval, scrapeInterval), this.getRangeScopedVars(options.range)));
    }

    query.step = interval;
    let expr = target.expr; // Apply adhoc filters

    expr = this.enhanceExprWithAdHocFilters(expr); // Only replace vars in expression after having (possibly) updated interval vars

    query.expr = this.templateSrv.replace(expr, scopedVars, this.interpolateQueryExpr); // Align query interval with step to allow query caching and to ensure
    // that about-same-time query results look the same.

    const adjusted = alignRange(start, end, query.step, this.timeSrv.timeRange().to.utcOffset() * 60);
    query.start = adjusted.start;
    query.end = adjusted.end;

    this._addTracingHeaders(query, options);

    return query;
  }

  getRateIntervalScopedVariable(interval, scrapeInterval) {
    // Fall back to the default scrape interval of 15s if scrapeInterval is 0 for some reason.
    if (scrapeInterval === 0) {
      scrapeInterval = 15;
    }

    const rateInterval = Math.max(interval + scrapeInterval, 4 * scrapeInterval);
    return {
      __rate_interval: {
        text: rateInterval + 's',
        value: rateInterval + 's'
      }
    };
  }

  adjustInterval(interval, minInterval, range, intervalFactor) {
    // Prometheus will drop queries that might return more than 11000 data points.
    // Calculate a safe interval as an additional minimum to take into account.
    // Fractional safeIntervals are allowed, however serve little purpose if the interval is greater than 1
    // If this is the case take the ceil of the value.
    let safeInterval = range / 11000;

    if (safeInterval > 1) {
      safeInterval = Math.ceil(safeInterval);
    }

    return Math.max(interval * intervalFactor, minInterval, safeInterval);
  }

  performTimeSeriesQuery(query, start, end) {
    if (start > end) {
      throw {
        message: 'Invalid time range'
      };
    }

    const url = '/api/v1/query_range';
    const data = {
      query: query.expr,
      start,
      end,
      step: query.step
    };

    if (this.queryTimeout) {
      data['timeout'] = this.queryTimeout;
    }

    return this._request(url, data, {
      requestId: query.requestId,
      headers: query.headers
    }).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_29__.catchError)(err => {
      if (err.cancelled) {
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_23__.of)(err);
      }

      return (0,rxjs__WEBPACK_IMPORTED_MODULE_30__.throwError)(this.handleErrors(err, query));
    }));
  }

  performInstantQuery(query, time) {
    const url = '/api/v1/query';
    const data = {
      query: query.expr,
      time
    };

    if (this.queryTimeout) {
      data['timeout'] = this.queryTimeout;
    }

    return this._request(url, data, {
      requestId: query.requestId,
      headers: query.headers
    }).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_29__.catchError)(err => {
      if (err.cancelled) {
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_23__.of)(err);
      }

      return (0,rxjs__WEBPACK_IMPORTED_MODULE_30__.throwError)(this.handleErrors(err, query));
    }));
  }

  metricFindQuery(query) {
    if (!query) {
      return Promise.resolve([]);
    }

    const scopedVars = Object.assign({
      __interval: {
        text: this.interval,
        value: this.interval
      },
      __interval_ms: {
        text: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.rangeUtil.intervalToMs(this.interval),
        value: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.rangeUtil.intervalToMs(this.interval)
      }
    }, this.getRangeScopedVars(this.timeSrv.timeRange()));
    const interpolated = this.templateSrv.replace(query, scopedVars, this.interpolateQueryExpr);
    const metricFindQuery = new _metric_find_query__WEBPACK_IMPORTED_MODULE_15__["default"](this, interpolated);
    return metricFindQuery.process();
  }

  getRangeScopedVars(range = this.timeSrv.timeRange()) {
    const msRange = range.to.diff(range.from);
    const sRange = Math.round(msRange / 1000);
    return {
      __range_ms: {
        text: msRange,
        value: msRange
      },
      __range_s: {
        text: sRange,
        value: sRange
      },
      __range: {
        text: sRange + 's',
        value: sRange + 's'
      }
    };
  }

  async annotationQuery(options) {
    const annotation = options.annotation;
    const {
      expr = ''
    } = annotation;

    if (!expr) {
      return Promise.resolve([]);
    }

    const step = options.annotation.step || ANNOTATION_QUERY_STEP_DEFAULT;
    const queryModel = {
      expr,
      range: true,
      instant: false,
      exemplar: false,
      interval: step,
      queryType: _types__WEBPACK_IMPORTED_MODULE_18__.PromQueryType.timeSeriesQuery,
      refId: 'X',
      datasource: this.getRef()
    };
    return await (0,rxjs__WEBPACK_IMPORTED_MODULE_21__.lastValueFrom)((0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_4__.getBackendSrv)().fetch({
      url: '/api/ds/query',
      method: 'POST',
      data: {
        from: (this.getPrometheusTime(options.range.from, false) * 1000).toString(),
        to: (this.getPrometheusTime(options.range.to, true) * 1000).toString(),
        queries: [this.applyTemplateVariables(queryModel, {})]
      },
      requestId: `prom-query-${annotation.name}`
    }).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_22__.map)(rsp => {
      return this.processAnnotationResponse(options, rsp.data);
    })));
  }

  getExemplars(query) {
    const url = '/api/v1/query_exemplars';
    return this._request(url, {
      query: query.expr,
      start: query.start.toString(),
      end: query.end.toString()
    }, {
      requestId: query.requestId,
      headers: query.headers
    });
  }

  async getSubtitle() {
    const buildInfo = await this.getBuildInfo();
    return buildInfo ? this.getBuildInfoMessage(buildInfo) : null;
  }

  async getTagKeys(options) {
    if (options !== null && options !== void 0 && options.series) {
      // Get tags for the provided series only
      const seriesLabels = await Promise.all(options.series.map(series => this.languageProvider.fetchSeriesLabels(series)));
      const uniqueLabels = [...new Set(...seriesLabels.map(value => Object.keys(value)))];
      return uniqueLabels.map(value => ({
        text: value
      }));
    } else {
      var _result$data$data$map, _result$data, _result$data$data;

      // Get all tags
      const result = await this.metadataRequest('/api/v1/labels');
      return (_result$data$data$map = result === null || result === void 0 ? void 0 : (_result$data = result.data) === null || _result$data === void 0 ? void 0 : (_result$data$data = _result$data.data) === null || _result$data$data === void 0 ? void 0 : _result$data$data.map(value => ({
        text: value
      }))) !== null && _result$data$data$map !== void 0 ? _result$data$data$map : [];
    }
  }

  async getTagValues(options = {}) {
    var _result$data$data$map2, _result$data2, _result$data2$data;

    const result = await this.metadataRequest(`/api/v1/label/${options.key}/values`);
    return (_result$data$data$map2 = result === null || result === void 0 ? void 0 : (_result$data2 = result.data) === null || _result$data2 === void 0 ? void 0 : (_result$data2$data = _result$data2.data) === null || _result$data2$data === void 0 ? void 0 : _result$data2$data.map(value => ({
      text: value
    }))) !== null && _result$data$data$map2 !== void 0 ? _result$data$data$map2 : [];
  }

  async getBuildInfo() {
    try {
      const buildInfo = await (0,app_features_alerting_unified_api_buildInfo__WEBPACK_IMPORTED_MODULE_7__.fetchDataSourceBuildInfo)(this);
      return buildInfo;
    } catch (error) {
      // We don't want to break the rest of functionality if build info does not work correctly
      return undefined;
    }
  }

  getBuildInfoMessage(buildInfo) {
    var _buildInfo$applicatio, _buildInfo$applicatio2;

    const enabled = _Badge || (_Badge = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_5__.Badge, {
      color: "green",
      icon: "check",
      text: "Ruler API enabled"
    }));

    const disabled = _Badge2 || (_Badge2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_5__.Badge, {
      color: "orange",
      icon: "exclamation-triangle",
      text: "Ruler API not enabled"
    }));

    const unsupported = _Tooltip || (_Tooltip = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_5__.Tooltip, {
      placement: "top",
      content: "Prometheus does not allow editing rules, connect to either a Mimir or Cortex datasource to manage alerts via Grafana.",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)("div", {
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_5__.Badge, {
          color: "red",
          icon: "exclamation-triangle",
          text: "Ruler API not supported"
        })
      })
    }));

    const LOGOS = {
      [app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_10__.PromApplication.Cortex]: '/public/app/plugins/datasource/prometheus/img/cortex_logo.svg',
      [app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_10__.PromApplication.Mimir]: '/public/app/plugins/datasource/prometheus/img/mimir_logo.svg',
      [app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_10__.PromApplication.Prometheus]: '/public/app/plugins/datasource/prometheus/img/prometheus_logo.svg'
    };
    const COLORS = {
      [app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_10__.PromApplication.Cortex]: 'blue',
      [app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_10__.PromApplication.Mimir]: 'orange',
      [app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_10__.PromApplication.Prometheus]: 'red'
    }; // this will inform the user about what "subtype" the datasource is; Mimir, Cortex or vanilla Prometheus

    const applicationSubType = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_5__.Badge, {
      text: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsxs)("span", {
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)("img", {
          style: {
            width: 14,
            height: 14,
            verticalAlign: 'text-bottom'
          },
          src: LOGOS[(_buildInfo$applicatio = buildInfo.application) !== null && _buildInfo$applicatio !== void 0 ? _buildInfo$applicatio : app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_10__.PromApplication.Prometheus]
        }), ' ', buildInfo.application]
      }),
      color: COLORS[(_buildInfo$applicatio2 = buildInfo.application) !== null && _buildInfo$applicatio2 !== void 0 ? _buildInfo$applicatio2 : app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_10__.PromApplication.Prometheus]
    });

    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsxs)("div", {
      style: {
        display: 'grid',
        gridTemplateColumns: 'max-content max-content',
        rowGap: '0.5rem',
        columnGap: '2rem',
        marginTop: '1rem'
      },
      children: [_div || (_div = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)("div", {
        children: "Type"
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)("div", {
        children: applicationSubType
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.Fragment, {
        children: [_div2 || (_div2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)("div", {
          children: "Ruler API"
        })), buildInfo.application === app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_10__.PromApplication.Prometheus && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)("div", {
          children: unsupported
        }), buildInfo.application !== app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_10__.PromApplication.Prometheus && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)("div", {
          children: buildInfo.features.rulerApiEnabled ? enabled : disabled
        })]
      })]
    });
  }

  async testDatasource() {
    const now = new Date().getTime();
    const request = {
      targets: [{
        refId: 'test',
        expr: '1+1',
        instant: true
      }],
      requestId: `${this.id}-health`,
      scopedVars: {},
      dashboardId: 0,
      panelId: 0,
      interval: '1m',
      intervalMs: 60000,
      maxDataPoints: 1,
      range: {
        from: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_3__.dateTime)(now - 1000),
        to: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_3__.dateTime)(now)
      }
    };
    const buildInfo = await this.getBuildInfo();
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_21__.lastValueFrom)(this.query(request)).then(res => {
      if (!res || !res.data || res.state !== _grafana_data__WEBPACK_IMPORTED_MODULE_3__.LoadingState.Done) {
        var _res$error;

        return {
          status: 'error',
          message: `Error reading Prometheus: ${res === null || res === void 0 ? void 0 : (_res$error = res.error) === null || _res$error === void 0 ? void 0 : _res$error.message}`
        };
      } else {
        return {
          status: 'success',
          message: 'Data source is working',
          details: buildInfo && {
            verboseMessage: this.getBuildInfoMessage(buildInfo)
          }
        };
      }
    }).catch(err => {
      console.error('Prometheus Error', err);
      return {
        status: 'error',
        message: err.message
      };
    });
  }

  interpolateVariablesInQueries(queries, scopedVars) {
    let expandedQueries = queries;

    if (queries && queries.length) {
      expandedQueries = queries.map(query => {
        const expandedQuery = Object.assign({}, query, {
          datasource: this.getRef(),
          expr: this.templateSrv.replace(query.expr, scopedVars, this.interpolateQueryExpr),
          interval: this.templateSrv.replace(query.interval, scopedVars)
        });
        return expandedQuery;
      });
    }

    return expandedQueries;
  }

  getQueryHints(query, result) {
    var _query$expr;

    return (0,_query_hints__WEBPACK_IMPORTED_MODULE_16__.getQueryHints)((_query$expr = query.expr) !== null && _query$expr !== void 0 ? _query$expr : '', result, this);
  }

  getInitHints() {
    return (0,_query_hints__WEBPACK_IMPORTED_MODULE_16__.getInitHints)(this);
  }

  async loadRules() {
    try {
      var _res$data, _res$data$data;

      const res = await this.metadataRequest('/api/v1/rules');
      const groups = (_res$data = res.data) === null || _res$data === void 0 ? void 0 : (_res$data$data = _res$data.data) === null || _res$data$data === void 0 ? void 0 : _res$data$data.groups;

      if (groups) {
        this.ruleMappings = extractRuleMappingFromGroups(groups);
      }
    } catch (e) {
      console.log('Rules API is experimental. Ignore next error.');
      console.error(e);
    }
  }

  async areExemplarsAvailable() {
    try {
      const res = await this.metadataRequest('/api/v1/query_exemplars', {
        query: 'test'
      });

      if (res.data.status === 'success') {
        return true;
      }

      return false;
    } catch (err) {
      return false;
    }
  }

  modifyQuery(query, action) {
    var _query$expr2;

    let expression = (_query$expr2 = query.expr) !== null && _query$expr2 !== void 0 ? _query$expr2 : '';

    switch (action.type) {
      case 'ADD_FILTER':
        {
          expression = (0,_add_label_to_query__WEBPACK_IMPORTED_MODULE_11__.addLabelToQuery)(expression, action.key, action.value);
          break;
        }

      case 'ADD_FILTER_OUT':
        {
          expression = (0,_add_label_to_query__WEBPACK_IMPORTED_MODULE_11__.addLabelToQuery)(expression, action.key, action.value, '!=');
          break;
        }

      case 'ADD_HISTOGRAM_QUANTILE':
        {
          expression = `histogram_quantile(0.95, sum(rate(${expression}[$__rate_interval])) by (le))`;
          break;
        }

      case 'ADD_RATE':
        {
          expression = `rate(${expression}[$__rate_interval])`;
          break;
        }

      case 'ADD_SUM':
        {
          expression = `sum(${expression.trim()}) by ($1)`;
          break;
        }

      case 'EXPAND_RULES':
        {
          if (action.mapping) {
            expression = (0,_language_utils__WEBPACK_IMPORTED_MODULE_13__.expandRecordingRules)(expression, action.mapping);
          }

          break;
        }

      default:
        break;
    }

    return Object.assign({}, query, {
      expr: expression
    });
  }

  getPrometheusTime(date, roundUp) {
    if (typeof date === 'string') {
      date = _grafana_data__WEBPACK_IMPORTED_MODULE_3__.dateMath.parse(date, roundUp);
    }

    return Math.ceil(date.valueOf() / 1000);
  }

  getTimeRangeParams() {
    const range = this.timeSrv.timeRange();
    return {
      start: this.getPrometheusTime(range.from, false).toString(),
      end: this.getPrometheusTime(range.to, true).toString()
    };
  }

  getOriginalMetricName(labelData) {
    return (0,_result_transformer__WEBPACK_IMPORTED_MODULE_17__.getOriginalMetricName)(labelData);
  }

  enhanceExprWithAdHocFilters(expr) {
    const adhocFilters = this.templateSrv.getAdhocFilters(this.name);
    const finalQuery = adhocFilters.reduce((acc, filter) => {
      const {
        key,
        operator
      } = filter;
      let {
        value
      } = filter;

      if (operator === '=~' || operator === '!~') {
        value = prometheusRegularEscape(value);
      }

      return (0,_add_label_to_query__WEBPACK_IMPORTED_MODULE_11__.addLabelToQuery)(acc, key, value, operator);
    }, expr);
    return finalQuery;
  } // Used when running queries trough backend


  filterQuery(query) {
    if (query.hide || !query.expr) {
      return false;
    }

    return true;
  } // Used when running queries trough backend


  applyTemplateVariables(target, scopedVars) {
    const variables = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.cloneDeep)(scopedVars); // We want to interpolate these variables on backend

    delete variables.__interval;
    delete variables.__interval_ms; //Add ad hoc filters

    const expr = this.enhanceExprWithAdHocFilters(target.expr);
    return Object.assign({}, target, {
      legendFormat: this.templateSrv.replace(target.legendFormat, variables),
      expr: this.templateSrv.replace(expr, variables, this.interpolateQueryExpr),
      interval: this.templateSrv.replace(target.interval, variables)
    });
  }

  getVariables() {
    return this.templateSrv.getVariables().map(v => `$${v.name}`);
  }

  interpolateString(string) {
    return this.templateSrv.replace(string, undefined, this.interpolateQueryExpr);
  }

}
/**
 * Align query range to step.
 * Rounds start and end down to a multiple of step.
 * @param start Timestamp marking the beginning of the range.
 * @param end Timestamp marking the end of the range.
 * @param step Interval to align start and end with.
 * @param utcOffsetSec Number of seconds current timezone is offset from UTC
 */

function alignRange(start, end, step, utcOffsetSec) {
  const alignedEnd = Math.floor((end + utcOffsetSec) / step) * step - utcOffsetSec;
  const alignedStart = Math.floor((start + utcOffsetSec) / step) * step - utcOffsetSec;
  return {
    end: alignedEnd,
    start: alignedStart
  };
}
function extractRuleMappingFromGroups(groups) {
  return groups.reduce((mapping, group) => group.rules.filter(rule => rule.type === 'recording').reduce((acc, rule) => Object.assign({}, acc, {
    [rule.name]: rule.query
  }), mapping), {});
} // NOTE: these two functions are very similar to the escapeLabelValueIn* functions
// in language_utils.ts, but they are not exactly the same algorithm, and we found
// no way to reuse one in the another or vice versa.

function prometheusRegularEscape(value) {
  return typeof value === 'string' ? value.replace(/\\/g, '\\\\').replace(/'/g, "\\\\'") : value;
}
function prometheusSpecialRegexEscape(value) {
  return typeof value === 'string' ? value.replace(/\\/g, '\\\\\\\\').replace(/[$^*{}\[\]\'+?.()|]/g, '\\\\$&') : value;
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/language_provider.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SUGGESTIONS_LIMIT": () => (/* binding */ SUGGESTIONS_LIMIT),
/* harmony export */   "addHistoryMetadata": () => (/* binding */ addHistoryMetadata),
/* harmony export */   "default": () => (/* binding */ PromQlLanguageProvider),
/* harmony export */   "getMetadataString": () => (/* binding */ getMetadataString)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/lru-cache-npm-7.9.0-d803108233-c91a293a10.zip/node_modules/lru-cache/index.js");
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lru_cache__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/prismjs-npm-1.27.0-ca4e1667c6-85c7f4a3e9.zip/node_modules/prismjs/prism.js");
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prismjs__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _language_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/language_utils.ts");
/* harmony import */ var _promql__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/prometheus/promql.ts");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








const DEFAULT_KEYS = ['job', 'instance'];
const EMPTY_SELECTOR = '{}';
const HISTORY_ITEM_COUNT = 5;
const HISTORY_COUNT_CUTOFF = 1000 * 60 * 60 * 24; // 24h
// Max number of items (metrics, labels, values) that we display as suggestions. Prevents from running out of memory.

const SUGGESTIONS_LIMIT = 10000;

const wrapLabel = label => ({
  label
});

const setFunctionKind = suggestion => {
  suggestion.kind = 'function';
  return suggestion;
};

function addHistoryMetadata(item, history) {
  const cutoffTs = Date.now() - HISTORY_COUNT_CUTOFF;
  const historyForItem = history.filter(h => h.ts > cutoffTs && h.query === item.label);
  const count = historyForItem.length;
  const recent = historyForItem[0];
  let hint = `Queried ${count} times in the last 24h.`;

  if (recent) {
    const lastQueried = (0,_grafana_data__WEBPACK_IMPORTED_MODULE_3__.dateTime)(recent.ts).fromNow();
    hint = `${hint} Last queried ${lastQueried}.`;
  }

  return Object.assign({}, item, {
    documentation: hint
  });
}

function addMetricsMetadata(metric, metadata) {
  const item = {
    label: metric
  };

  if (metadata && metadata[metric]) {
    item.documentation = getMetadataString(metric, metadata);
  }

  return item;
}

function getMetadataString(metric, metadata) {
  if (!metadata[metric]) {
    return undefined;
  }

  const {
    type,
    help
  } = metadata[metric];
  return `${type.toUpperCase()}: ${help}`;
}
const PREFIX_DELIMITER_REGEX = /(="|!="|=~"|!~"|\{|\[|\(|\+|-|\/|\*|%|\^|\band\b|\bor\b|\bunless\b|==|>=|!=|<=|>|<|=|~|,)/;
class PromQlLanguageProvider extends _grafana_data__WEBPACK_IMPORTED_MODULE_3__.LanguageProvider {
  /**
   *  Cache for labels of series. This is bit simplistic in the sense that it just counts responses each as a 1 and does
   *  not account for different size of a response. If that is needed a `length` function can be added in the options.
   *  10 as a max size is totally arbitrary right now.
   */
  constructor(datasource, initialValues) {
    super();

    _defineProperty(this, "histogramMetrics", void 0);

    _defineProperty(this, "timeRange", void 0);

    _defineProperty(this, "metrics", void 0);

    _defineProperty(this, "metricsMetadata", void 0);

    _defineProperty(this, "datasource", void 0);

    _defineProperty(this, "labelKeys", []);

    _defineProperty(this, "labelsCache", new (lru_cache__WEBPACK_IMPORTED_MODULE_1___default())({
      max: 10
    }));

    _defineProperty(this, "request", async (url, defaultValue, params = {}) => {
      try {
        const res = await this.datasource.metadataRequest(url, params);
        return res.data.data;
      } catch (error) {
        console.error(error);
      }

      return defaultValue;
    });

    _defineProperty(this, "start", async () => {
      if (this.datasource.lookupsDisabled) {
        return [];
      } // TODO #33976: make those requests parallel


      await this.fetchLabels();
      this.metrics = (await this.fetchLabelValues('__name__')) || [];
      await this.loadMetricsMetadata();
      this.histogramMetrics = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.processHistogramMetrics)(this.metrics).sort();
      return [];
    });

    _defineProperty(this, "provideCompletionItems", async ({
      prefix,
      text,
      value,
      labelKey,
      wrapperClasses
    }, context = {}) => {
      const emptyResult = {
        suggestions: []
      };

      if (!value) {
        return emptyResult;
      } // Local text properties


      const empty = value.document.text.length === 0;
      const selectedLines = value.document.getTextsAtRange(value.selection);
      const currentLine = selectedLines.size === 1 ? selectedLines.first().getText() : null;
      const nextCharacter = currentLine ? currentLine[value.selection.anchor.offset] : null; // Syntax spans have 3 classes by default. More indicate a recognized token

      const tokenRecognized = wrapperClasses.length > 3; // Non-empty prefix, but not inside known token

      const prefixUnrecognized = prefix && !tokenRecognized; // Prevent suggestions in `function(|suffix)`

      const noSuffix = !nextCharacter || nextCharacter === ')'; // Prefix is safe if it does not immediately follow a complete expression and has no text after it

      const safePrefix = prefix && !text.match(/^[\]})\s]+$/) && noSuffix; // About to type next operand if preceded by binary operator

      const operatorsPattern = /[+\-*/^%]/;
      const isNextOperand = text.match(operatorsPattern); // Determine candidates by CSS context

      if (wrapperClasses.includes('context-range')) {
        // Suggestions for metric[|]
        return this.getRangeCompletionItems();
      } else if (wrapperClasses.includes('context-labels')) {
        // Suggestions for metric{|} and metric{foo=|}, as well as metric-independent label queries like {|}
        return this.getLabelCompletionItems({
          prefix,
          text,
          value,
          labelKey,
          wrapperClasses
        });
      } else if (wrapperClasses.includes('context-aggregation')) {
        // Suggestions for sum(metric) by (|)
        return this.getAggregationCompletionItems(value);
      } else if (empty) {
        // Suggestions for empty query field
        return this.getEmptyCompletionItems(context);
      } else if (prefixUnrecognized && noSuffix && !isNextOperand) {
        // Show term suggestions in a couple of scenarios
        return this.getBeginningCompletionItems(context);
      } else if (prefixUnrecognized && safePrefix) {
        // Show term suggestions in a couple of scenarios
        return this.getTermCompletionItems();
      }

      return emptyResult;
    });

    _defineProperty(this, "getBeginningCompletionItems", context => {
      return {
        suggestions: [...this.getEmptyCompletionItems(context).suggestions, ...this.getTermCompletionItems().suggestions]
      };
    });

    _defineProperty(this, "getEmptyCompletionItems", context => {
      const {
        history
      } = context;
      const suggestions = [];

      if (history && history.length) {
        const historyItems = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.chain)(history).map(h => h.query.expr).filter().uniq().take(HISTORY_ITEM_COUNT).map(wrapLabel).map(item => addHistoryMetadata(item, history)).value();
        suggestions.push({
          searchFunctionType: _grafana_ui__WEBPACK_IMPORTED_MODULE_4__.SearchFunctionType.Prefix,
          skipSort: true,
          label: 'History',
          items: historyItems
        });
      }

      return {
        suggestions
      };
    });

    _defineProperty(this, "getTermCompletionItems", () => {
      const {
        metrics,
        metricsMetadata
      } = this;
      const suggestions = [];
      suggestions.push({
        searchFunctionType: _grafana_ui__WEBPACK_IMPORTED_MODULE_4__.SearchFunctionType.Prefix,
        label: 'Functions',
        items: _promql__WEBPACK_IMPORTED_MODULE_6__.FUNCTIONS.map(setFunctionKind)
      });

      if (metrics && metrics.length) {
        suggestions.push({
          label: 'Metrics',
          items: metrics.map(m => addMetricsMetadata(m, metricsMetadata)),
          searchFunctionType: _grafana_ui__WEBPACK_IMPORTED_MODULE_4__.SearchFunctionType.Fuzzy
        });
      }

      return {
        suggestions
      };
    });

    _defineProperty(this, "getAggregationCompletionItems", async value => {
      const suggestions = []; // Stitch all query lines together to support multi-line queries

      let queryOffset;
      const queryText = value.document.getBlocks().reduce((text, block) => {
        if (text === undefined) {
          return '';
        }

        if (!block) {
          return text;
        }

        const blockText = block === null || block === void 0 ? void 0 : block.getText();

        if (value.anchorBlock.key === block.key) {
          // Newline characters are not accounted for but this is irrelevant
          // for the purpose of extracting the selector string
          queryOffset = value.selection.anchor.offset + text.length;
        }

        return text + blockText;
      }, ''); // Try search for selector part on the left-hand side, such as `sum (m) by (l)`

      const openParensAggregationIndex = queryText.lastIndexOf('(', queryOffset);
      let openParensSelectorIndex = queryText.lastIndexOf('(', openParensAggregationIndex - 1);
      let closeParensSelectorIndex = queryText.indexOf(')', openParensSelectorIndex); // Try search for selector part of an alternate aggregation clause, such as `sum by (l) (m)`

      if (openParensSelectorIndex === -1) {
        const closeParensAggregationIndex = queryText.indexOf(')', queryOffset);
        closeParensSelectorIndex = queryText.indexOf(')', closeParensAggregationIndex + 1);
        openParensSelectorIndex = queryText.lastIndexOf('(', closeParensSelectorIndex);
      }

      const result = {
        suggestions,
        context: 'context-aggregation'
      }; // Suggestions are useless for alternative aggregation clauses without a selector in context

      if (openParensSelectorIndex === -1) {
        return result;
      } // Range vector syntax not accounted for by subsequent parse so discard it if present


      const selectorString = queryText.slice(openParensSelectorIndex + 1, closeParensSelectorIndex).replace(/\[[^\]]+\]$/, '');
      const selector = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.parseSelector)(selectorString, selectorString.length - 2).selector;
      const series = await this.getSeries(selector);
      const labelKeys = Object.keys(series);

      if (labelKeys.length > 0) {
        const limitInfo = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.addLimitInfo)(labelKeys);
        suggestions.push({
          label: `Labels${limitInfo}`,
          items: labelKeys.map(wrapLabel),
          searchFunctionType: _grafana_ui__WEBPACK_IMPORTED_MODULE_4__.SearchFunctionType.Fuzzy
        });
      }

      return result;
    });

    _defineProperty(this, "getLabelCompletionItems", async ({
      text,
      wrapperClasses,
      labelKey,
      value
    }) => {
      if (!value) {
        return {
          suggestions: []
        };
      }

      const suggestions = [];
      const line = value.anchorBlock.getText();
      const cursorOffset = value.selection.anchor.offset;
      const suffix = line.substr(cursorOffset);
      const prefix = line.substr(0, cursorOffset);
      const isValueStart = text.match(/^(=|=~|!=|!~)/);
      const isValueEnd = suffix.match(/^"?[,}]|$/); // Detect cursor in front of value, e.g., {key=|"}

      const isPreValue = prefix.match(/(=|=~|!=|!~)$/) && suffix.match(/^"/); // Don't suggest anything at the beginning or inside a value

      const isValueEmpty = isValueStart && isValueEnd;
      const hasValuePrefix = isValueEnd && !isValueStart;

      if (!isValueEmpty && !hasValuePrefix || isPreValue) {
        return {
          suggestions
        };
      } // Get normalized selector


      let selector;
      let parsedSelector;

      try {
        parsedSelector = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.parseSelector)(line, cursorOffset);
        selector = parsedSelector.selector;
      } catch {
        selector = EMPTY_SELECTOR;
      }

      const containsMetric = selector.includes('__name__=');
      const existingKeys = parsedSelector ? parsedSelector.labelKeys : [];
      let series = {}; // Query labels for selector

      if (selector) {
        series = await this.getSeries(selector, !containsMetric);
      }

      if (Object.keys(series).length === 0) {
        console.warn(`Server did not return any values for selector = ${selector}`);
        return {
          suggestions
        };
      }

      let context;

      if (text && isValueStart || wrapperClasses.includes('attr-value')) {
        // Label values
        if (labelKey && series[labelKey]) {
          context = 'context-label-values';
          const limitInfo = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.addLimitInfo)(series[labelKey]);
          suggestions.push({
            label: `Label values for "${labelKey}"${limitInfo}`,
            items: series[labelKey].map(wrapLabel),
            searchFunctionType: _grafana_ui__WEBPACK_IMPORTED_MODULE_4__.SearchFunctionType.Fuzzy
          });
        }
      } else {
        // Label keys
        const labelKeys = series ? Object.keys(series) : containsMetric ? null : DEFAULT_KEYS;

        if (labelKeys) {
          const possibleKeys = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.difference)(labelKeys, existingKeys);

          if (possibleKeys.length) {
            context = 'context-labels';
            const newItems = possibleKeys.map(key => ({
              label: key
            }));
            const limitInfo = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.addLimitInfo)(newItems);
            const newSuggestion = {
              label: `Labels${limitInfo}`,
              items: newItems,
              searchFunctionType: _grafana_ui__WEBPACK_IMPORTED_MODULE_4__.SearchFunctionType.Fuzzy
            };
            suggestions.push(newSuggestion);
          }
        }
      }

      return {
        context,
        suggestions
      };
    });

    _defineProperty(this, "fetchLabelValues", async key => {
      const params = this.datasource.getTimeRangeParams();
      const url = `/api/v1/label/${this.datasource.interpolateString(key)}/values`;
      return await this.request(url, [], params);
    });

    _defineProperty(this, "fetchSeriesLabels", async (name, withName) => {
      const interpolatedName = this.datasource.interpolateString(name);
      const range = this.datasource.getTimeRangeParams();
      const urlParams = Object.assign({}, range, {
        'match[]': interpolatedName
      });
      const url = `/api/v1/series`; // Cache key is a bit different here. We add the `withName` param and also round up to a minute the intervals.
      // The rounding may seem strange but makes relative intervals like now-1h less prone to need separate request every
      // millisecond while still actually getting all the keys for the correct interval. This still can create problems
      // when user does not the newest values for a minute if already cached.

      const cacheParams = new URLSearchParams({
        'match[]': interpolatedName,
        start: (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.roundSecToMin)(parseInt(range.start, 10)).toString(),
        end: (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.roundSecToMin)(parseInt(range.end, 10)).toString(),
        withName: withName ? 'true' : 'false'
      });
      const cacheKey = `/api/v1/series?${cacheParams.toString()}`;
      let value = this.labelsCache.get(cacheKey);

      if (!value) {
        const data = await this.request(url, [], urlParams);
        const {
          values
        } = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.processLabels)(data, withName);
        value = values;
        this.labelsCache.set(cacheKey, value);
      }

      return value;
    });

    _defineProperty(this, "fetchSeries", async match => {
      const url = '/api/v1/series';
      const range = this.datasource.getTimeRangeParams();
      const params = Object.assign({}, range, {
        'match[]': match
      });
      return await this.request(url, {}, params);
    });

    _defineProperty(this, "fetchDefaultSeries", (0,lodash__WEBPACK_IMPORTED_MODULE_0__.once)(async () => {
      const values = await Promise.all(DEFAULT_KEYS.map(key => this.fetchLabelValues(key)));
      return DEFAULT_KEYS.reduce((acc, key, i) => Object.assign({}, acc, {
        [key]: values[i]
      }), {});
    }));

    this.datasource = datasource;
    this.histogramMetrics = [];
    this.timeRange = {
      start: 0,
      end: 0
    };
    this.metrics = [];
    Object.assign(this, initialValues);
  } // Strip syntax chars so that typeahead suggestions can work on clean inputs


  cleanText(s) {
    const parts = s.split(PREFIX_DELIMITER_REGEX);
    const last = parts.pop();
    return last.trimLeft().replace(/"$/, '').replace(/^"/, '');
  }

  get syntax() {
    return _promql__WEBPACK_IMPORTED_MODULE_6__["default"];
  }

  async loadMetricsMetadata() {
    this.metricsMetadata = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.fixSummariesMetadata)(await this.request('/api/v1/metadata', {}));
  }

  getLabelKeys() {
    return this.labelKeys;
  }

  getRangeCompletionItems() {
    return {
      context: 'context-range',
      suggestions: [{
        label: 'Range vector',
        items: [..._promql__WEBPACK_IMPORTED_MODULE_6__.RATE_RANGES]
      }]
    };
  }

  importFromAbstractQuery(labelBasedQuery) {
    return (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.toPromLikeQuery)(labelBasedQuery);
  }

  exportToAbstractQuery(query) {
    const promQuery = query.expr;

    if (!promQuery || promQuery.length === 0) {
      return {
        refId: query.refId,
        labelMatchers: []
      };
    }

    const tokens = prismjs__WEBPACK_IMPORTED_MODULE_2___default().tokenize(promQuery, _promql__WEBPACK_IMPORTED_MODULE_6__["default"]);
    const labelMatchers = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.extractLabelMatchers)(tokens);
    const nameLabelValue = getNameLabelValue(promQuery, tokens);

    if (nameLabelValue && nameLabelValue.length > 0) {
      labelMatchers.push({
        name: '__name__',
        operator: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.AbstractLabelOperator.Equal,
        value: nameLabelValue
      });
    }

    return {
      refId: query.refId,
      labelMatchers
    };
  }

  async getSeries(selector, withName) {
    if (this.datasource.lookupsDisabled) {
      return {};
    }

    try {
      if (selector === EMPTY_SELECTOR) {
        return await this.fetchDefaultSeries();
      } else {
        return await this.fetchSeriesLabels(selector, withName);
      }
    } catch (error) {
      // TODO: better error handling
      console.error(error);
      return {};
    }
  }

  async getLabelValues(key) {
    return await this.fetchLabelValues(key);
  }
  /**
   * Fetches all label keys
   */


  async fetchLabels() {
    const url = '/api/v1/labels';
    const params = this.datasource.getTimeRangeParams();
    this.labelFetchTs = Date.now().valueOf();
    const res = await this.request(url, [], params);

    if (Array.isArray(res)) {
      this.labelKeys = res.slice().sort();
    }

    return [];
  }
  /**
   * Fetch labels for a series. This is cached by it's args but also by the global timeRange currently selected as
   * they can change over requested time.
   * @param name
   * @param withName
   */


}

function getNameLabelValue(promQuery, tokens) {
  let nameLabelValue = '';

  for (let prop in tokens) {
    if (typeof tokens[prop] === 'string') {
      nameLabelValue = tokens[prop];
      break;
    }
  }

  return nameLabelValue;
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/language_utils.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addLimitInfo": () => (/* binding */ addLimitInfo),
/* harmony export */   "escapeLabelValueInExactSelector": () => (/* binding */ escapeLabelValueInExactSelector),
/* harmony export */   "escapeLabelValueInRegexSelector": () => (/* binding */ escapeLabelValueInRegexSelector),
/* harmony export */   "expandRecordingRules": () => (/* binding */ expandRecordingRules),
/* harmony export */   "extractLabelMatchers": () => (/* binding */ extractLabelMatchers),
/* harmony export */   "fixSummariesMetadata": () => (/* binding */ fixSummariesMetadata),
/* harmony export */   "labelRegexp": () => (/* binding */ labelRegexp),
/* harmony export */   "limitSuggestions": () => (/* binding */ limitSuggestions),
/* harmony export */   "parseSelector": () => (/* binding */ parseSelector),
/* harmony export */   "processHistogramMetrics": () => (/* binding */ processHistogramMetrics),
/* harmony export */   "processLabels": () => (/* binding */ processLabels),
/* harmony export */   "roundMsToMin": () => (/* binding */ roundMsToMin),
/* harmony export */   "roundSecToMin": () => (/* binding */ roundSecToMin),
/* harmony export */   "selectorRegexp": () => (/* binding */ selectorRegexp),
/* harmony export */   "toPromLikeExpr": () => (/* binding */ toPromLikeExpr),
/* harmony export */   "toPromLikeQuery": () => (/* binding */ toPromLikeQuery)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/prismjs-npm-1.27.0-ca4e1667c6-85c7f4a3e9.zip/node_modules/prismjs/prism.js");
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prismjs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _add_label_to_query__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/add_label_to_query.ts");
/* harmony import */ var _language_provider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/language_provider.ts");
const _excluded = ["__name__"];

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }






const processHistogramMetrics = metrics => {
  const resultSet = new Set();
  const regexp = new RegExp('_bucket($|:)');

  for (let index = 0; index < metrics.length; index++) {
    const metric = metrics[index];
    const isHistogramValue = regexp.test(metric);

    if (isHistogramValue) {
      resultSet.add(metric);
    }
  }

  return [...resultSet];
};
function processLabels(labels, withName = false) {
  // For processing we are going to use sets as they have significantly better performance than arrays
  // After we process labels, we will convert sets to arrays and return object with label values in arrays
  const valueSet = {};
  labels.forEach(label => {
    const {
      __name__
    } = label,
          rest = _objectWithoutPropertiesLoose(label, _excluded);

    if (withName) {
      valueSet['__name__'] = valueSet['__name__'] || new Set();

      if (!valueSet['__name__'].has(__name__)) {
        valueSet['__name__'].add(__name__);
      }
    }

    Object.keys(rest).forEach(key => {
      if (!valueSet[key]) {
        valueSet[key] = new Set();
      }

      if (!valueSet[key].has(rest[key])) {
        valueSet[key].add(rest[key]);
      }
    });
  }); // valueArray that we are going to return in the object

  const valueArray = {};
  limitSuggestions(Object.keys(valueSet)).forEach(key => {
    valueArray[key] = limitSuggestions(Array.from(valueSet[key]));
  });
  return {
    values: valueArray,
    keys: Object.keys(valueArray)
  };
} // const cleanSelectorRegexp = /\{(\w+="[^"\n]*?")(,\w+="[^"\n]*?")*\}/;

const selectorRegexp = /\{[^}]*?(\}|$)/;
const labelRegexp = /\b(\w+)(!?=~?)("[^"\n]*?")/g;
function parseSelector(query, cursorOffset = 1) {
  if (!query.match(selectorRegexp)) {
    // Special matcher for metrics
    if (query.match(/^[A-Za-z:][\w:]*$/)) {
      return {
        selector: `{__name__="${query}"}`,
        labelKeys: ['__name__']
      };
    }

    throw new Error('Query must contain a selector: ' + query);
  } // Check if inside a selector


  const prefix = query.slice(0, cursorOffset);
  const prefixOpen = prefix.lastIndexOf('{');
  const prefixClose = prefix.lastIndexOf('}');

  if (prefixOpen === -1) {
    throw new Error('Not inside selector, missing open brace: ' + prefix);
  }

  if (prefixClose > -1 && prefixClose > prefixOpen) {
    throw new Error('Not inside selector, previous selector already closed: ' + prefix);
  }

  const suffix = query.slice(cursorOffset);
  const suffixCloseIndex = suffix.indexOf('}');
  const suffixClose = suffixCloseIndex + cursorOffset;
  const suffixOpenIndex = suffix.indexOf('{');
  const suffixOpen = suffixOpenIndex + cursorOffset;

  if (suffixClose === -1) {
    throw new Error('Not inside selector, missing closing brace in suffix: ' + suffix);
  }

  if (suffixOpenIndex > -1 && suffixOpen < suffixClose) {
    throw new Error('Not inside selector, next selector opens before this one closed: ' + suffix);
  } // Extract clean labels to form clean selector, incomplete labels are dropped


  const selector = query.slice(prefixOpen, suffixClose);
  const labels = {};
  selector.replace(labelRegexp, (label, key, operator, value) => {
    const labelOffset = query.indexOf(label);
    const valueStart = labelOffset + key.length + operator.length + 1;
    const valueEnd = labelOffset + key.length + operator.length + value.length - 1; // Skip label if cursor is in value

    if (cursorOffset < valueStart || cursorOffset > valueEnd) {
      labels[key] = {
        value,
        operator
      };
    }

    return '';
  }); // Add metric if there is one before the selector

  const metricPrefix = query.slice(0, prefixOpen);
  const metricMatch = metricPrefix.match(/[A-Za-z:][\w:]*$/);

  if (metricMatch) {
    labels['__name__'] = {
      value: `"${metricMatch[0]}"`,
      operator: '='
    };
  } // Build sorted selector


  const labelKeys = Object.keys(labels).sort();
  const cleanSelector = labelKeys.map(key => `${key}${labels[key].operator}${labels[key].value}`).join(',');
  const selectorString = ['{', cleanSelector, '}'].join('');
  return {
    labelKeys,
    selector: selectorString
  };
}
function expandRecordingRules(query, mapping) {
  const ruleNames = Object.keys(mapping);
  const rulesRegex = new RegExp(`(\\s|^)(${ruleNames.join('|')})(\\s|$|\\(|\\[|\\{)`, 'ig');
  const expandedQuery = query.replace(rulesRegex, (match, pre, name, post) => `${pre}${mapping[name]}${post}`); // Split query into array, so if query uses operators, we can correctly add labels to each individual part.

  const queryArray = expandedQuery.split(/(\+|\-|\*|\/|\%|\^)/); // Regex that matches occurrences of ){ or }{ or ]{ which is a sign of incorrecly added labels.

  const invalidLabelsRegex = /(\)\{|\}\{|\]\{)/;
  const correctlyExpandedQueryArray = queryArray.map(query => {
    return addLabelsToExpression(query, invalidLabelsRegex);
  });
  return correctlyExpandedQueryArray.join('');
}

function addLabelsToExpression(expr, invalidLabelsRegexp) {
  var _match$index;

  const match = expr.match(invalidLabelsRegexp);

  if (!match) {
    return expr;
  } // Split query into 2 parts - before the invalidLabelsRegex match and after.


  const indexOfRegexMatch = (_match$index = match.index) !== null && _match$index !== void 0 ? _match$index : 0;
  const exprBeforeRegexMatch = expr.slice(0, indexOfRegexMatch + 1);
  const exprAfterRegexMatch = expr.slice(indexOfRegexMatch + 1); // Create arrayOfLabelObjects with label objects that have key, operator and value.

  const arrayOfLabelObjects = [];
  exprAfterRegexMatch.replace(labelRegexp, (label, key, operator, value) => {
    arrayOfLabelObjects.push({
      key,
      operator,
      value
    });
    return '';
  }); // Loop through all label objects and add them to query.
  // As a starting point we have valid query without the labels.

  let result = exprBeforeRegexMatch;
  arrayOfLabelObjects.filter(Boolean).forEach(obj => {
    // Remove extra set of quotes from obj.value
    const value = obj.value.slice(1, -1);
    result = (0,_add_label_to_query__WEBPACK_IMPORTED_MODULE_3__.addLabelToQuery)(result, obj.key, value, obj.operator);
  });
  return result;
}
/**
 * Adds metadata for synthetic metrics for which the API does not provide metadata.
 * See https://github.com/grafana/grafana/issues/22337 for details.
 *
 * @param metadata HELP and TYPE metadata from /api/v1/metadata
 */


function fixSummariesMetadata(metadata) {
  if (!metadata) {
    return metadata;
  }

  const baseMetadata = {};
  const summaryMetadata = {};

  for (const metric in metadata) {
    // NOTE: based on prometheus-documentation, we can receive
    // multiple metadata-entries for the given metric, it seems
    // it happens when the same metric is on multiple targets
    // and their help-text differs
    // (https://prometheus.io/docs/prometheus/latest/querying/api/#querying-metric-metadata)
    // for now we just use the first entry.
    const item = metadata[metric][0];
    baseMetadata[metric] = item;

    if (item.type === 'histogram') {
      summaryMetadata[`${metric}_bucket`] = {
        type: 'counter',
        help: `Cumulative counters for the observation buckets (${item.help})`
      };
      summaryMetadata[`${metric}_count`] = {
        type: 'counter',
        help: `Count of events that have been observed for the histogram metric (${item.help})`
      };
      summaryMetadata[`${metric}_sum`] = {
        type: 'counter',
        help: `Total sum of all observed values for the histogram metric (${item.help})`
      };
    }

    if (item.type === 'summary') {
      summaryMetadata[`${metric}_count`] = {
        type: 'counter',
        help: `Count of events that have been observed for the base metric (${item.help})`
      };
      summaryMetadata[`${metric}_sum`] = {
        type: 'counter',
        help: `Total sum of all observed values for the base metric (${item.help})`
      };
    }
  } // Synthetic series


  const syntheticMetadata = {};
  syntheticMetadata['ALERTS'] = {
    type: 'counter',
    help: 'Time series showing pending and firing alerts. The sample value is set to 1 as long as the alert is in the indicated active (pending or firing) state.'
  };
  return Object.assign({}, baseMetadata, summaryMetadata, syntheticMetadata);
}
function roundMsToMin(milliseconds) {
  return roundSecToMin(milliseconds / 1000);
}
function roundSecToMin(seconds) {
  return Math.floor(seconds / 60);
}
function limitSuggestions(items) {
  return items.slice(0, _language_provider__WEBPACK_IMPORTED_MODULE_4__.SUGGESTIONS_LIMIT);
}
function addLimitInfo(items) {
  return items && items.length >= _language_provider__WEBPACK_IMPORTED_MODULE_4__.SUGGESTIONS_LIMIT ? `, limited to the first ${_language_provider__WEBPACK_IMPORTED_MODULE_4__.SUGGESTIONS_LIMIT} received items` : '';
} // NOTE: the following 2 exported functions are very similar to the prometheus*Escape
// functions in datasource.ts, but they are not exactly the same algorithm, and we found
// no way to reuse one in the another or vice versa.
// Prometheus regular-expressions use the RE2 syntax (https://github.com/google/re2/wiki/Syntax),
// so every character that matches something in that list has to be escaped.
// the list of metacharacters is: *+?()|\.[]{}^$
// we make a javascript regular expression that matches those characters:

const RE2_METACHARACTERS = /[*+?()|\\.\[\]{}^$]/g;

function escapePrometheusRegexp(value) {
  return value.replace(RE2_METACHARACTERS, '\\$&');
} // based on the openmetrics-documentation, the 3 symbols we have to handle are:
// - \n ... the newline character
// - \  ... the backslash character
// - "  ... the double-quote character


function escapeLabelValueInExactSelector(labelValue) {
  return labelValue.replace(/\\/g, '\\\\').replace(/\n/g, '\\n').replace(/"/g, '\\"');
}
function escapeLabelValueInRegexSelector(labelValue) {
  return escapeLabelValueInExactSelector(escapePrometheusRegexp(labelValue));
}
const FromPromLikeMap = {
  '=': _grafana_data__WEBPACK_IMPORTED_MODULE_2__.AbstractLabelOperator.Equal,
  '!=': _grafana_data__WEBPACK_IMPORTED_MODULE_2__.AbstractLabelOperator.NotEqual,
  '=~': _grafana_data__WEBPACK_IMPORTED_MODULE_2__.AbstractLabelOperator.EqualRegEx,
  '!~': _grafana_data__WEBPACK_IMPORTED_MODULE_2__.AbstractLabelOperator.NotEqualRegEx
};
const ToPromLikeMap = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.invert)(FromPromLikeMap);
function toPromLikeExpr(labelBasedQuery) {
  const expr = labelBasedQuery.labelMatchers.map(selector => {
    const operator = ToPromLikeMap[selector.operator];

    if (operator) {
      return `${selector.name}${operator}"${selector.value}"`;
    } else {
      return '';
    }
  }).filter(e => e !== '').join(', ');
  return expr ? `{${expr}}` : '';
}
function toPromLikeQuery(labelBasedQuery) {
  return {
    refId: labelBasedQuery.refId,
    expr: toPromLikeExpr(labelBasedQuery),
    range: true
  };
}
function extractLabelMatchers(tokens) {
  const labelMatchers = [];

  for (let prop in tokens) {
    if (tokens[prop] instanceof prismjs__WEBPACK_IMPORTED_MODULE_1__.Token) {
      let token = tokens[prop];

      if (token.type === 'context-labels') {
        let labelKey = '';
        let labelValue = '';
        let labelOperator = '';
        let contentTokens = token.content;

        for (let currentToken in contentTokens) {
          if (typeof contentTokens[currentToken] === 'string') {
            let currentStr;
            currentStr = contentTokens[currentToken];

            if (currentStr === '=' || currentStr === '!=' || currentStr === '=~' || currentStr === '!~') {
              labelOperator = currentStr;
            }
          } else if (contentTokens[currentToken] instanceof prismjs__WEBPACK_IMPORTED_MODULE_1__.Token) {
            switch (contentTokens[currentToken].type) {
              case 'label-key':
                labelKey = contentTokens[currentToken].content;
                break;

              case 'label-value':
                labelValue = contentTokens[currentToken].content;
                labelValue = labelValue.substring(1, labelValue.length - 1);
                const labelComparator = FromPromLikeMap[labelOperator];

                if (labelComparator) {
                  labelMatchers.push({
                    name: labelKey,
                    operator: labelComparator,
                    value: labelValue
                  });
                }

                break;
            }
          }
        }
      }
    }
  }

  return labelMatchers;
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/metric_find_query.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PrometheusMetricFindQuery)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/lastValueFrom.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/map.js");
/* harmony import */ var app_features_dashboard_services_TimeSrv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/features/dashboard/services/TimeSrv.ts");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





class PrometheusMetricFindQuery {
  constructor(datasource, query) {
    this.datasource = datasource;
    this.query = query;

    _defineProperty(this, "range", void 0);

    this.datasource = datasource;
    this.query = query;
    this.datasource = datasource;
    this.query = query;
    this.range = (0,app_features_dashboard_services_TimeSrv__WEBPACK_IMPORTED_MODULE_1__.getTimeSrv)().timeRange();
  }

  process() {
    const labelNamesRegex = /^label_names\(\)\s*$/;
    const labelValuesRegex = /^label_values\((?:(.+),\s*)?([a-zA-Z_][a-zA-Z0-9_]*)\)\s*$/;
    const metricNamesRegex = /^metrics\((.+)\)\s*$/;
    const queryResultRegex = /^query_result\((.+)\)\s*$/;
    const labelNamesQuery = this.query.match(labelNamesRegex);

    if (labelNamesQuery) {
      return this.labelNamesQuery();
    }

    const labelValuesQuery = this.query.match(labelValuesRegex);

    if (labelValuesQuery) {
      if (labelValuesQuery[1]) {
        return this.labelValuesQuery(labelValuesQuery[2], labelValuesQuery[1]);
      } else {
        return this.labelValuesQuery(labelValuesQuery[2]);
      }
    }

    const metricNamesQuery = this.query.match(metricNamesRegex);

    if (metricNamesQuery) {
      return this.metricNameQuery(metricNamesQuery[1]);
    }

    const queryResultQuery = this.query.match(queryResultRegex);

    if (queryResultQuery) {
      return (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.lastValueFrom)(this.queryResultQuery(queryResultQuery[1]));
    } // if query contains full metric name, return metric name and label list


    return this.metricNameAndLabelsQuery(this.query);
  }

  labelNamesQuery() {
    const start = this.datasource.getPrometheusTime(this.range.from, false);
    const end = this.datasource.getPrometheusTime(this.range.to, true);
    const params = {
      start: start.toString(),
      end: end.toString()
    };
    const url = `/api/v1/labels`;
    return this.datasource.metadataRequest(url, params).then(result => {
      return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.map)(result.data.data, value => {
        return {
          text: value
        };
      });
    });
  }

  labelValuesQuery(label, metric) {
    const start = this.datasource.getPrometheusTime(this.range.from, false);
    const end = this.datasource.getPrometheusTime(this.range.to, true);
    let url;

    if (!metric) {
      const params = {
        start: start.toString(),
        end: end.toString()
      }; // return label values globally

      url = `/api/v1/label/${label}/values`;
      return this.datasource.metadataRequest(url, params).then(result => {
        return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.map)(result.data.data, value => {
          return {
            text: value
          };
        });
      });
    } else {
      const params = {
        'match[]': metric,
        start: start.toString(),
        end: end.toString()
      };
      url = `/api/v1/series`;
      return this.datasource.metadataRequest(url, params).then(result => {
        const _labels = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.map)(result.data.data, metric => {
          return metric[label] || '';
        }).filter(label => {
          return label !== '';
        });

        return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.uniq)(_labels).map(metric => {
          return {
            text: metric,
            expandable: true
          };
        });
      });
    }
  }

  metricNameQuery(metricFilterPattern) {
    const start = this.datasource.getPrometheusTime(this.range.from, false);
    const end = this.datasource.getPrometheusTime(this.range.to, true);
    const params = {
      start: start.toString(),
      end: end.toString()
    };
    const url = `/api/v1/label/__name__/values`;
    return this.datasource.metadataRequest(url, params).then(result => {
      return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.chain)(result.data.data).filter(metricName => {
        const r = new RegExp(metricFilterPattern);
        return r.test(metricName);
      }).map(matchedMetricName => {
        return {
          text: matchedMetricName,
          expandable: true
        };
      }).value();
    });
  }

  queryResultQuery(query) {
    const end = this.datasource.getPrometheusTime(this.range.to, true);
    const instantQuery = {
      expr: query
    };
    return this.datasource.performInstantQuery(instantQuery, end).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)(result => {
      return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.map)(result.data.data.result, metricData => {
        let text = metricData.metric.__name__ || '';
        delete metricData.metric.__name__;
        text += '{' + (0,lodash__WEBPACK_IMPORTED_MODULE_0__.map)(metricData.metric, (v, k) => {
          return k + '="' + v + '"';
        }).join(',') + '}';
        text += ' ' + metricData.value[1] + ' ' + metricData.value[0] * 1000;
        return {
          text: text,
          expandable: true
        };
      });
    }));
  }

  metricNameAndLabelsQuery(query) {
    const start = this.datasource.getPrometheusTime(this.range.from, false);
    const end = this.datasource.getPrometheusTime(this.range.to, true);
    const params = {
      'match[]': query,
      start: start.toString(),
      end: end.toString()
    };
    const url = `/api/v1/series`;
    const self = this;
    return this.datasource.metadataRequest(url, params).then(result => {
      return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.map)(result.data.data, metric => {
        return {
          text: self.datasource.getOriginalMetricName(metric),
          expandable: true
        };
      });
    });
  }

}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/module.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "plugin": () => (/* binding */ plugin)
/* harmony export */ });
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _components_PromCheatSheet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromCheatSheet.tsx");
/* harmony import */ var _components_PromQueryEditorByApp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromQueryEditorByApp.tsx");
/* harmony import */ var _configuration_ConfigEditor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/configuration/ConfigEditor.tsx");
/* harmony import */ var _datasource__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/datasource.tsx");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







class PrometheusAnnotationsQueryCtrl {
  constructor() {
    _defineProperty(this, "stepDefaultValuePlaceholder", _datasource__WEBPACK_IMPORTED_MODULE_4__.ANNOTATION_QUERY_STEP_DEFAULT);
  }

}

_defineProperty(PrometheusAnnotationsQueryCtrl, "templateUrl", 'partials/annotations.editor.html');

const plugin = new _grafana_data__WEBPACK_IMPORTED_MODULE_0__.DataSourcePlugin(_datasource__WEBPACK_IMPORTED_MODULE_4__.PrometheusDatasource).setQueryEditor(_components_PromQueryEditorByApp__WEBPACK_IMPORTED_MODULE_2__["default"]).setConfigEditor(_configuration_ConfigEditor__WEBPACK_IMPORTED_MODULE_3__.ConfigEditor).setAnnotationQueryCtrl(PrometheusAnnotationsQueryCtrl).setQueryEditorHelp(_components_PromCheatSheet__WEBPACK_IMPORTED_MODULE_1__["default"]);

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/promql.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FUNCTIONS": () => (/* binding */ FUNCTIONS),
/* harmony export */   "LOGICAL_OPERATORS": () => (/* binding */ LOGICAL_OPERATORS),
/* harmony export */   "OPERATORS": () => (/* binding */ OPERATORS),
/* harmony export */   "PROM_KEYWORDS": () => (/* binding */ PROM_KEYWORDS),
/* harmony export */   "RATE_RANGES": () => (/* binding */ RATE_RANGES),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "promqlGrammar": () => (/* binding */ promqlGrammar)
/* harmony export */ });
// When changing RATE_RANGES, check if Loki/LogQL ranges should be changed too
// @see public/app/plugins/datasource/loki/language_provider.ts
const RATE_RANGES = [{
  label: '$__interval',
  sortValue: '$__interval'
}, {
  label: '$__rate_interval',
  sortValue: '$__rate_interval'
}, {
  label: '$__range',
  sortValue: '$__range'
}, {
  label: '1m',
  sortValue: '00:01:00'
}, {
  label: '5m',
  sortValue: '00:05:00'
}, {
  label: '10m',
  sortValue: '00:10:00'
}, {
  label: '30m',
  sortValue: '00:30:00'
}, {
  label: '1h',
  sortValue: '01:00:00'
}, {
  label: '1d',
  sortValue: '24:00:00'
}];
const OPERATORS = ['by', 'group_left', 'group_right', 'ignoring', 'on', 'offset', 'without'];
const LOGICAL_OPERATORS = ['or', 'and', 'unless'];
const TRIGONOMETRIC_FUNCTIONS = [{
  label: 'acos',
  insertText: 'acos',
  detail: 'acos(v instant-vector)',
  documentation: 'calculates the arccosine of all elements in v'
}, {
  label: 'acosh',
  insertText: 'acosh',
  detail: 'acosh(v instant-vector)',
  documentation: 'calculates the inverse hyperbolic cosine of all elements in v'
}, {
  label: 'asin',
  insertText: 'asin',
  detail: 'asin(v instant-vector)',
  documentation: 'calculates the arcsine of all elements in v'
}, {
  label: 'asinh',
  insertText: 'asinh',
  detail: 'asinh(v instant-vector)',
  documentation: 'calculates the inverse hyperbolic sine of all elements in v'
}, {
  label: 'atan',
  insertText: 'atan',
  detail: 'atan(v instant-vector)',
  documentation: 'calculates the arctangent of all elements in v'
}, {
  label: 'atanh',
  insertText: 'atanh',
  detail: 'atanh(v instant-vector)',
  documentation: 'calculates the inverse hyperbolic tangent of all elements in v'
}, {
  label: 'cos',
  insertText: 'cos',
  detail: 'cos(v instant-vector)',
  documentation: 'calculates the cosine of all elements in v'
}, {
  label: 'cosh',
  insertText: 'cosh',
  detail: 'cosh(v instant-vector)',
  documentation: 'calculates the hyperbolic cosine of all elements in v'
}, {
  label: 'sin',
  insertText: 'sin',
  detail: 'sin(v instant-vector)',
  documentation: 'calculates the sine of all elements in v'
}, {
  label: 'sinh',
  insertText: 'sinh',
  detail: 'sinh(v instant-vector)',
  documentation: 'calculates the hyperbolic sine of all elements in v'
}, {
  label: 'tan',
  insertText: 'tan',
  detail: 'tan(v instant-vector)',
  documentation: 'calculates the tangent of all elements in v'
}, {
  label: 'tanh',
  insertText: 'tanh',
  detail: 'tanh(v instant-vector)',
  documentation: 'calculates the hyperbolic tangent of all elements in v'
}];
const AGGREGATION_OPERATORS = [{
  label: 'sum',
  insertText: 'sum',
  documentation: 'Calculate sum over dimensions'
}, {
  label: 'min',
  insertText: 'min',
  documentation: 'Select minimum over dimensions'
}, {
  label: 'max',
  insertText: 'max',
  documentation: 'Select maximum over dimensions'
}, {
  label: 'avg',
  insertText: 'avg',
  documentation: 'Calculate the average over dimensions'
}, {
  label: 'group',
  insertText: 'group',
  documentation: 'All values in the resulting vector are 1'
}, {
  label: 'stddev',
  insertText: 'stddev',
  documentation: 'Calculate population standard deviation over dimensions'
}, {
  label: 'stdvar',
  insertText: 'stdvar',
  documentation: 'Calculate population standard variance over dimensions'
}, {
  label: 'count',
  insertText: 'count',
  documentation: 'Count number of elements in the vector'
}, {
  label: 'count_values',
  insertText: 'count_values',
  documentation: 'Count number of elements with the same value'
}, {
  label: 'bottomk',
  insertText: 'bottomk',
  documentation: 'Smallest k elements by sample value'
}, {
  label: 'topk',
  insertText: 'topk',
  documentation: 'Largest k elements by sample value'
}, {
  label: 'quantile',
  insertText: 'quantile',
  documentation: 'Calculate -quantile (0    1) over dimensions'
}];
const FUNCTIONS = [...AGGREGATION_OPERATORS, ...TRIGONOMETRIC_FUNCTIONS, {
  insertText: 'abs',
  label: 'abs',
  detail: 'abs(v instant-vector)',
  documentation: 'Returns the input vector with all sample values converted to their absolute value.'
}, {
  insertText: 'absent',
  label: 'absent',
  detail: 'absent(v instant-vector)',
  documentation: 'Returns an empty vector if the vector passed to it has any elements and a 1-element vector with the value 1 if the vector passed to it has no elements. This is useful for alerting on when no time series exist for a given metric name and label combination.'
}, {
  insertText: 'absent_over_time',
  label: 'absent_over_time',
  detail: 'absent(v range-vector)',
  documentation: 'Returns an empty vector if the range vector passed to it has any elements and a 1-element vector with the value 1 if the range vector passed to it has no elements.'
}, {
  insertText: 'ceil',
  label: 'ceil',
  detail: 'ceil(v instant-vector)',
  documentation: 'Rounds the sample values of all elements in `v` up to the nearest integer.'
}, {
  insertText: 'changes',
  label: 'changes',
  detail: 'changes(v range-vector)',
  documentation: 'For each input time series, `changes(v range-vector)` returns the number of times its value has changed within the provided time range as an instant vector.'
}, {
  insertText: 'clamp',
  label: 'clamp',
  detail: 'clamp(v instant-vector, min scalar, max scalar)',
  documentation: 'Clamps the sample values of all elements in `v` to have a lower limit of `min` and an upper limit of `max`.'
}, {
  insertText: 'clamp_max',
  label: 'clamp_max',
  detail: 'clamp_max(v instant-vector, max scalar)',
  documentation: 'Clamps the sample values of all elements in `v` to have an upper limit of `max`.'
}, {
  insertText: 'clamp_min',
  label: 'clamp_min',
  detail: 'clamp_min(v instant-vector, min scalar)',
  documentation: 'Clamps the sample values of all elements in `v` to have a lower limit of `min`.'
}, {
  insertText: 'count_scalar',
  label: 'count_scalar',
  detail: 'count_scalar(v instant-vector)',
  documentation: 'Returns the number of elements in a time series vector as a scalar. This is in contrast to the `count()` aggregation operator, which always returns a vector (an empty one if the input vector is empty) and allows grouping by labels via a `by` clause.'
}, {
  insertText: 'deg',
  label: 'deg',
  detail: 'deg(v instant-vector)',
  documentation: 'Converts radians to degrees for all elements in v'
}, {
  insertText: 'day_of_month',
  label: 'day_of_month',
  detail: 'day_of_month(v=vector(time()) instant-vector)',
  documentation: 'Returns the day of the month for each of the given times in UTC. Returned values are from 1 to 31.'
}, {
  insertText: 'day_of_week',
  label: 'day_of_week',
  detail: 'day_of_week(v=vector(time()) instant-vector)',
  documentation: 'Returns the day of the week for each of the given times in UTC. Returned values are from 0 to 6, where 0 means Sunday etc.'
}, {
  insertText: 'days_in_month',
  label: 'days_in_month',
  detail: 'days_in_month(v=vector(time()) instant-vector)',
  documentation: 'Returns number of days in the month for each of the given times in UTC. Returned values are from 28 to 31.'
}, {
  insertText: 'delta',
  label: 'delta',
  detail: 'delta(v range-vector)',
  documentation: 'Calculates the difference between the first and last value of each time series element in a range vector `v`, returning an instant vector with the given deltas and equivalent labels. The delta is extrapolated to cover the full time range as specified in the range vector selector, so that it is possible to get a non-integer result even if the sample values are all integers.'
}, {
  insertText: 'deriv',
  label: 'deriv',
  detail: 'deriv(v range-vector)',
  documentation: 'Calculates the per-second derivative of the time series in a range vector `v`, using simple linear regression.'
}, {
  insertText: 'drop_common_labels',
  label: 'drop_common_labels',
  detail: 'drop_common_labels(instant-vector)',
  documentation: 'Drops all labels that have the same name and value across all series in the input vector.'
}, {
  insertText: 'exp',
  label: 'exp',
  detail: 'exp(v instant-vector)',
  documentation: 'Calculates the exponential function for all elements in `v`.\nSpecial cases are:\n* `Exp(+Inf) = +Inf` \n* `Exp(NaN) = NaN`'
}, {
  insertText: 'floor',
  label: 'floor',
  detail: 'floor(v instant-vector)',
  documentation: 'Rounds the sample values of all elements in `v` down to the nearest integer.'
}, {
  insertText: 'histogram_quantile',
  label: 'histogram_quantile',
  detail: 'histogram_quantile( float, b instant-vector)',
  documentation: 'Calculates the -quantile (0    1) from the buckets `b` of a histogram. The samples in `b` are the counts of observations in each bucket. Each sample must have a label `le` where the label value denotes the inclusive upper bound of the bucket. (Samples without such a label are silently ignored.) The histogram metric type automatically provides time series with the `_bucket` suffix and the appropriate labels.'
}, {
  insertText: 'holt_winters',
  label: 'holt_winters',
  detail: 'holt_winters(v range-vector, sf scalar, tf scalar)',
  documentation: 'Produces a smoothed value for time series based on the range in `v`. The lower the smoothing factor `sf`, the more importance is given to old data. The higher the trend factor `tf`, the more trends in the data is considered. Both `sf` and `tf` must be between 0 and 1.'
}, {
  insertText: 'hour',
  label: 'hour',
  detail: 'hour(v=vector(time()) instant-vector)',
  documentation: 'Returns the hour of the day for each of the given times in UTC. Returned values are from 0 to 23.'
}, {
  insertText: 'idelta',
  label: 'idelta',
  detail: 'idelta(v range-vector)',
  documentation: 'Calculates the difference between the last two samples in the range vector `v`, returning an instant vector with the given deltas and equivalent labels.'
}, {
  insertText: 'increase',
  label: 'increase',
  detail: 'increase(v range-vector)',
  documentation: 'Calculates the increase in the time series in the range vector. Breaks in monotonicity (such as counter resets due to target restarts) are automatically adjusted for. The increase is extrapolated to cover the full time range as specified in the range vector selector, so that it is possible to get a non-integer result even if a counter increases only by integer increments.'
}, {
  insertText: 'irate',
  label: 'irate',
  detail: 'irate(v range-vector)',
  documentation: 'Calculates the per-second instant rate of increase of the time series in the range vector. This is based on the last two data points. Breaks in monotonicity (such as counter resets due to target restarts) are automatically adjusted for.'
}, {
  insertText: 'label_join',
  label: 'label_join',
  detail: 'label_join(v instant-vector, dst_label string, separator string, src_label_1 string, src_label_2 string, ...)',
  documentation: 'For each timeseries in `v`, joins all the values of all the `src_labels` using `separator` and returns the timeseries with the label `dst_label` containing the joined value. There can be any number of `src_labels` in this function.'
}, {
  insertText: 'label_replace',
  label: 'label_replace',
  detail: 'label_replace(v instant-vector, dst_label string, replacement string, src_label string, regex string)',
  documentation: "For each timeseries in `v`, `label_replace(v instant-vector, dst_label string, replacement string, src_label string, regex string)`  matches the regular expression `regex` against the label `src_label`.  If it matches, then the timeseries is returned with the label `dst_label` replaced by the expansion of `replacement`. `$1` is replaced with the first matching subgroup, `$2` with the second etc. If the regular expression doesn't match then the timeseries is returned unchanged."
}, {
  insertText: 'ln',
  label: 'ln',
  detail: 'ln(v instant-vector)',
  documentation: 'Calculates the natural logarithm for all elements in `v`.\nSpecial cases are:\n * `ln(+Inf) = +Inf`\n * `ln(0) = -Inf`\n * `ln(x < 0) = NaN`\n * `ln(NaN) = NaN`'
}, {
  insertText: 'log2',
  label: 'log2',
  detail: 'log2(v instant-vector)',
  documentation: 'Calculates the binary logarithm for all elements in `v`. The special cases are equivalent to those in `ln`.'
}, {
  insertText: 'log10',
  label: 'log10',
  detail: 'log10(v instant-vector)',
  documentation: 'Calculates the decimal logarithm for all elements in `v`. The special cases are equivalent to those in `ln`.'
}, {
  insertText: 'minute',
  label: 'minute',
  detail: 'minute(v=vector(time()) instant-vector)',
  documentation: 'Returns the minute of the hour for each of the given times in UTC. Returned values are from 0 to 59.'
}, {
  insertText: 'month',
  label: 'month',
  detail: 'month(v=vector(time()) instant-vector)',
  documentation: 'Returns the month of the year for each of the given times in UTC. Returned values are from 1 to 12, where 1 means January etc.'
}, {
  insertText: 'pi',
  label: 'pi',
  detail: 'pi()',
  documentation: 'Returns pi'
}, {
  insertText: 'predict_linear',
  label: 'predict_linear',
  detail: 'predict_linear(v range-vector, t scalar)',
  documentation: 'Predicts the value of time series `t` seconds from now, based on the range vector `v`, using simple linear regression.'
}, {
  insertText: 'rad',
  label: 'rad',
  detail: 'rad(v instant-vector)',
  documentation: 'Converts degrees to radians for all elements in v'
}, {
  insertText: 'rate',
  label: 'rate',
  detail: 'rate(v range-vector)',
  documentation: "Calculates the per-second average rate of increase of the time series in the range vector. Breaks in monotonicity (such as counter resets due to target restarts) are automatically adjusted for. Also, the calculation extrapolates to the ends of the time range, allowing for missed scrapes or imperfect alignment of scrape cycles with the range's time period."
}, {
  insertText: 'resets',
  label: 'resets',
  detail: 'resets(v range-vector)',
  documentation: 'For each input time series, `resets(v range-vector)` returns the number of counter resets within the provided time range as an instant vector. Any decrease in the value between two consecutive samples is interpreted as a counter reset.'
}, {
  insertText: 'round',
  label: 'round',
  detail: 'round(v instant-vector, to_nearest=1 scalar)',
  documentation: 'Rounds the sample values of all elements in `v` to the nearest integer. Ties are resolved by rounding up. The optional `to_nearest` argument allows specifying the nearest multiple to which the sample values should be rounded. This multiple may also be a fraction.'
}, {
  insertText: 'scalar',
  label: 'scalar',
  detail: 'scalar(v instant-vector)',
  documentation: 'Given a single-element input vector, `scalar(v instant-vector)` returns the sample value of that single element as a scalar. If the input vector does not have exactly one element, `scalar` will return `NaN`.'
}, {
  insertText: 'sgn',
  label: 'sgn',
  detail: 'sgn(v instant-vector)',
  documentation: 'Returns a vector with all sample values converted to their sign, defined as this: 1 if v is positive, -1 if v is negative and 0 if v is equal to zero.'
}, {
  insertText: 'sort',
  label: 'sort',
  detail: 'sort(v instant-vector)',
  documentation: 'Returns vector elements sorted by their sample values, in ascending order.'
}, {
  insertText: 'sort_desc',
  label: 'sort_desc',
  detail: 'sort_desc(v instant-vector)',
  documentation: 'Returns vector elements sorted by their sample values, in descending order.'
}, {
  insertText: 'sqrt',
  label: 'sqrt',
  detail: 'sqrt(v instant-vector)',
  documentation: 'Calculates the square root of all elements in `v`.'
}, {
  insertText: 'time',
  label: 'time',
  detail: 'time()',
  documentation: 'Returns the number of seconds since January 1, 1970 UTC. Note that this does not actually return the current time, but the time at which the expression is to be evaluated.'
}, {
  insertText: 'timestamp',
  label: 'timestamp',
  detail: 'timestamp(v instant-vector)',
  documentation: 'Returns the timestamp of each of the samples of the given vector as the number of seconds since January 1, 1970 UTC.'
}, {
  insertText: 'vector',
  label: 'vector',
  detail: 'vector(s scalar)',
  documentation: 'Returns the scalar `s` as a vector with no labels.'
}, {
  insertText: 'year',
  label: 'year',
  detail: 'year(v=vector(time()) instant-vector)',
  documentation: 'Returns the year for each of the given times in UTC.'
}, {
  insertText: 'avg_over_time',
  label: 'avg_over_time',
  detail: 'avg_over_time(range-vector)',
  documentation: 'The average value of all points in the specified interval.'
}, {
  insertText: 'min_over_time',
  label: 'min_over_time',
  detail: 'min_over_time(range-vector)',
  documentation: 'The minimum value of all points in the specified interval.'
}, {
  insertText: 'max_over_time',
  label: 'max_over_time',
  detail: 'max_over_time(range-vector)',
  documentation: 'The maximum value of all points in the specified interval.'
}, {
  insertText: 'sum_over_time',
  label: 'sum_over_time',
  detail: 'sum_over_time(range-vector)',
  documentation: 'The sum of all values in the specified interval.'
}, {
  insertText: 'count_over_time',
  label: 'count_over_time',
  detail: 'count_over_time(range-vector)',
  documentation: 'The count of all values in the specified interval.'
}, {
  insertText: 'quantile_over_time',
  label: 'quantile_over_time',
  detail: 'quantile_over_time(scalar, range-vector)',
  documentation: 'The -quantile (0    1) of the values in the specified interval.'
}, {
  insertText: 'stddev_over_time',
  label: 'stddev_over_time',
  detail: 'stddev_over_time(range-vector)',
  documentation: 'The population standard deviation of the values in the specified interval.'
}, {
  insertText: 'stdvar_over_time',
  label: 'stdvar_over_time',
  detail: 'stdvar_over_time(range-vector)',
  documentation: 'The population standard variance of the values in the specified interval.'
}, {
  insertText: 'last_over_time',
  label: 'last_over_time',
  detail: 'last_over_time(range-vector)',
  documentation: 'The most recent point value in specified interval.'
}];
const PROM_KEYWORDS = FUNCTIONS.map(keyword => keyword.label);
const promqlGrammar = {
  comment: {
    pattern: /#.*/
  },
  'context-aggregation': {
    pattern: /((by|without)\s*)\([^)]*\)/,
    // by ()
    lookbehind: true,
    inside: {
      'label-key': {
        pattern: /[^(),\s][^,)]*[^),\s]*/,
        alias: 'attr-name'
      },
      punctuation: /[()]/
    }
  },
  'context-labels': {
    pattern: /\{[^}]*(?=}?)/,
    greedy: true,
    inside: {
      comment: {
        pattern: /#.*/
      },
      'label-key': {
        pattern: /[a-z_]\w*(?=\s*(=|!=|=~|!~))/,
        alias: 'attr-name',
        greedy: true
      },
      'label-value': {
        pattern: /"(?:\\.|[^\\"])*"/,
        greedy: true,
        alias: 'attr-value'
      },
      punctuation: /[{]/
    }
  },
  function: new RegExp(`\\b(?:${FUNCTIONS.map(f => f.label).join('|')})(?=\\s*\\()`, 'i'),
  'context-range': [{
    pattern: /\[[^\]]*(?=])/,
    // [1m]
    inside: {
      'range-duration': {
        pattern: /\b\d+[smhdwy]\b/i,
        alias: 'number'
      }
    }
  }, {
    pattern: /(offset\s+)\w+/,
    // offset 1m
    lookbehind: true,
    inside: {
      'range-duration': {
        pattern: /\b\d+[smhdwy]\b/i,
        alias: 'number'
      }
    }
  }],
  idList: {
    pattern: /\d+(\|\d+)+/,
    alias: 'number'
  },
  number: /\b-?\d+((\.\d*)?([eE][+-]?\d+)?)?\b/,
  operator: new RegExp(`/[-+*/=%^~]|&&?|\\|?\\||!=?|<(?:=>?|<|>)?|>[>=]?|\\b(?:${OPERATORS.join('|')})\\b`, 'i'),
  punctuation: /[{};()`,.]/
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (promqlGrammar);

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/query_hints.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SUM_HINT_THRESHOLD_COUNT": () => (/* binding */ SUM_HINT_THRESHOLD_COUNT),
/* harmony export */   "getInitHints": () => (/* binding */ getInitHints),
/* harmony export */   "getQueryHints": () => (/* binding */ getQueryHints)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);


/**
 * Number of time series results needed before starting to suggest sum aggregation hints
 */
const SUM_HINT_THRESHOLD_COUNT = 20;
function getQueryHints(query, series, datasource) {
  const hints = []; // ..._bucket metric needs a histogram_quantile()

  const histogramMetric = query.trim().match(/^\w+_bucket$|^\w+_bucket{.*}$/);

  if (histogramMetric) {
    const label = 'Selected metric has buckets.';
    hints.push({
      type: 'HISTOGRAM_QUANTILE',
      label,
      fix: {
        label: 'Consider calculating aggregated quantile by adding histogram_quantile().',
        action: {
          type: 'ADD_HISTOGRAM_QUANTILE',
          query
        }
      }
    });
  } // Check for need of rate()


  if (query.indexOf('rate(') === -1 && query.indexOf('increase(') === -1) {
    var _datasource$languageP, _datasource$languageP2;

    // Use metric metadata for exact types
    const nameMatch = query.match(/\b(\w+_(total|sum|count))\b/);
    let counterNameMetric = nameMatch ? nameMatch[1] : '';
    const metricsMetadata = (_datasource$languageP = datasource === null || datasource === void 0 ? void 0 : (_datasource$languageP2 = datasource.languageProvider) === null || _datasource$languageP2 === void 0 ? void 0 : _datasource$languageP2.metricsMetadata) !== null && _datasource$languageP !== void 0 ? _datasource$languageP : {};
    const metricMetadataKeys = Object.keys(metricsMetadata);
    let certain = false;

    if (metricMetadataKeys.length > 0) {
      var _metricMetadataKeys$f;

      counterNameMetric = (_metricMetadataKeys$f = metricMetadataKeys.find(metricName => {
        // Only considering first type information, could be non-deterministic
        const metadata = metricsMetadata[metricName];

        if (metadata.type.toLowerCase() === 'counter') {
          const metricRegex = new RegExp(`\\b${metricName}\\b`);

          if (query.match(metricRegex)) {
            certain = true;
            return true;
          }
        }

        return false;
      })) !== null && _metricMetadataKeys$f !== void 0 ? _metricMetadataKeys$f : '';
    }

    if (counterNameMetric) {
      // FixableQuery consists of metric name and optionally label-value pairs. We are not offering fix for complex queries yet.
      const fixableQuery = query.trim().match(/^\w+$|^\w+{.*}$/);
      const verb = certain ? 'is' : 'looks like';
      let label = `Selected metric ${verb} a counter.`;
      let fix;

      if (fixableQuery) {
        fix = {
          label: 'Consider calculating rate of counter by adding rate().',
          action: {
            type: 'ADD_RATE',
            query
          }
        };
      } else {
        label = `${label} Consider calculating rate of counter by adding rate().`;
      }

      hints.push({
        type: 'APPLY_RATE',
        label,
        fix
      });
    }
  } // Check for recording rules expansion


  if (datasource && datasource.ruleMappings) {
    const mapping = datasource.ruleMappings;
    const mappingForQuery = Object.keys(mapping).reduce((acc, ruleName) => {
      if (query.search(ruleName) > -1) {
        return Object.assign({}, acc, {
          [ruleName]: mapping[ruleName]
        });
      }

      return acc;
    }, {});

    if ((0,lodash__WEBPACK_IMPORTED_MODULE_0__.size)(mappingForQuery) > 0) {
      const label = 'Query contains recording rules.';
      hints.push({
        type: 'EXPAND_RULES',
        label,
        fix: {
          label: 'Expand rules',
          action: {
            type: 'EXPAND_RULES',
            query,
            mapping: mappingForQuery
          }
        }
      });
    }
  }

  if (series && series.length >= SUM_HINT_THRESHOLD_COUNT) {
    const simpleMetric = query.trim().match(/^\w+$/);

    if (simpleMetric) {
      hints.push({
        type: 'ADD_SUM',
        label: 'Many time series results returned.',
        fix: {
          label: 'Consider aggregating with sum().',
          action: {
            type: 'ADD_SUM',
            query: query,
            preventSubmit: true
          }
        }
      });
    }
  }

  return hints;
}
function getInitHints(datasource) {
  const hints = []; // Hint if using Loki as Prometheus data source

  if (datasource.directUrl.includes('/loki') && !datasource.languageProvider.metrics.length) {
    hints.push({
      label: `Using Loki as a Prometheus data source is no longer supported. You must use the Loki data source for your Loki instance.`,
      type: 'INFO'
    });
  } // Hint for big disabled lookups


  if (datasource.lookupsDisabled) {
    hints.push({
      label: `Labels and metrics lookup was disabled in data source settings.`,
      type: 'INFO'
    });
  }

  return hints;
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/PromQueryModeller.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromQueryModeller": () => (/* binding */ PromQueryModeller),
/* harmony export */   "promQueryModeller": () => (/* binding */ promQueryModeller)
/* harmony export */ });
/* harmony import */ var _promql__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/datasource/prometheus/promql.ts");
/* harmony import */ var _aggregations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/aggregations.ts");
/* harmony import */ var _operations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/operations.ts");
/* harmony import */ var _shared_LokiAndPromQueryModellerBase__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/LokiAndPromQueryModellerBase.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/types.ts");





class PromQueryModeller extends _shared_LokiAndPromQueryModellerBase__WEBPACK_IMPORTED_MODULE_3__.LokiAndPromQueryModellerBase {
  constructor() {
    super(() => {
      const allOperations = [...(0,_operations__WEBPACK_IMPORTED_MODULE_2__.getOperationDefinitions)(), ...(0,_aggregations__WEBPACK_IMPORTED_MODULE_1__.getAggregationOperations)()];

      for (const op of allOperations) {
        const func = _promql__WEBPACK_IMPORTED_MODULE_0__.FUNCTIONS.find(x => x.insertText === op.id);

        if (func) {
          op.documentation = func.documentation;
        }
      }

      return allOperations;
    });
    this.setOperationCategories([_types__WEBPACK_IMPORTED_MODULE_4__.PromVisualQueryOperationCategory.Aggregations, _types__WEBPACK_IMPORTED_MODULE_4__.PromVisualQueryOperationCategory.RangeFunctions, _types__WEBPACK_IMPORTED_MODULE_4__.PromVisualQueryOperationCategory.Functions, _types__WEBPACK_IMPORTED_MODULE_4__.PromVisualQueryOperationCategory.BinaryOps, _types__WEBPACK_IMPORTED_MODULE_4__.PromVisualQueryOperationCategory.Trigonometric, _types__WEBPACK_IMPORTED_MODULE_4__.PromVisualQueryOperationCategory.Time]);
  }

  getQueryPatterns() {
    return [{
      name: 'Rate then sum',
      operations: [{
        id: 'rate',
        params: ['$__rate_interval']
      }, {
        id: 'sum',
        params: []
      }]
    }, {
      name: 'Rate then sum by(label) then avg',
      operations: [{
        id: 'rate',
        params: ['$__rate_interval']
      }, {
        id: '__sum_by',
        params: ['']
      }, {
        id: 'avg',
        params: []
      }]
    }, {
      name: 'Histogram quantile on rate',
      operations: [{
        id: 'rate',
        params: ['$__rate_interval']
      }, {
        id: '__sum_by',
        params: ['le']
      }, {
        id: 'histogram_quantile',
        params: [0.95]
      }]
    }, {
      name: 'Histogram quantile on increase ',
      operations: [{
        id: 'increase',
        params: ['$__rate_interval']
      }, {
        id: '__max_by',
        params: ['le']
      }, {
        id: 'histogram_quantile',
        params: [0.95]
      }]
    }];
  }

}
const promQueryModeller = new PromQueryModeller();

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/aggregations.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getAggregationOperations": () => (/* binding */ getAggregationOperations)
/* harmony export */ });
/* harmony import */ var _operations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/operations.ts");
/* harmony import */ var _shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/types.ts");



function getAggregationOperations() {
  return [...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperation)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Sum), ...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperation)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Avg), ...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperation)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Min), ...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperation)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Max), ...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperation)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Count), ...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperationWithParam)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.TopK, {
    params: [{
      name: 'K-value',
      type: 'number'
    }],
    defaultParams: [5]
  }), ...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperationWithParam)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.BottomK, {
    params: [{
      name: 'K-value',
      type: 'number'
    }],
    defaultParams: [5]
  }), ...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperationWithParam)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.CountValues, {
    params: [{
      name: 'Identifier',
      type: 'string'
    }],
    defaultParams: ['count']
  }), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.SumOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.AvgOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.MinOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.MaxOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.CountOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.LastOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.PresentOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.AbsentOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.StddevOverTime)];
}

function createAggregationOverTime(name) {
  return {
    id: name,
    name: (0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.getPromAndLokiOperationDisplayName)(name),
    params: [(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.getRangeVectorParamDef)()],
    defaultParams: ['$__interval'],
    alternativesKey: 'overtime function',
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.RangeFunctions,
    renderer: operationWithRangeVectorRenderer,
    addOperationHandler: _operations__WEBPACK_IMPORTED_MODULE_0__.addOperationWithRangeVector
  };
}

function operationWithRangeVectorRenderer(model, def, innerExpr) {
  var _, _model$params;

  let rangeVector = (_ = ((_model$params = model.params) !== null && _model$params !== void 0 ? _model$params : [])[0]) !== null && _ !== void 0 ? _ : '$__interval';
  return `${def.id}(${innerExpr}[${rangeVector}])`;
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/binaryScalarOperations.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "binaryScalarDefs": () => (/* binding */ binaryScalarDefs),
/* harmony export */   "binaryScalarOperations": () => (/* binding */ binaryScalarOperations),
/* harmony export */   "binaryScalarOperatorToOperatorName": () => (/* binding */ binaryScalarOperatorToOperatorName)
/* harmony export */ });
/* harmony import */ var _shared_operationUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/types.ts");


const binaryScalarDefs = [{
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.Addition,
  name: 'Add scalar',
  sign: '+'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.Subtraction,
  name: 'Subtract scalar',
  sign: '-'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.MultiplyBy,
  name: 'Multiply by scalar',
  sign: '*'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.DivideBy,
  name: 'Divide by scalar',
  sign: '/'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.Modulo,
  name: 'Modulo by scalar',
  sign: '%'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.Exponent,
  name: 'Exponent',
  sign: '^'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.EqualTo,
  name: 'Equal to',
  sign: '==',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.NotEqualTo,
  name: 'Not equal to',
  sign: '!=',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.GreaterThan,
  name: 'Greater than',
  sign: '>',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.LessThan,
  name: 'Less than',
  sign: '<',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.GreaterOrEqual,
  name: 'Greater or equal to',
  sign: '>=',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.LessOrEqual,
  name: 'Less or equal to',
  sign: '<=',
  comparison: true
}];
const binaryScalarOperatorToOperatorName = binaryScalarDefs.reduce((acc, def) => {
  acc[def.sign] = {
    id: def.id,
    comparison: def.comparison
  };
  return acc;
}, {}); // Not sure about this one. It could also be a more generic 'Simple math operation' where user specifies
// both the operator and the operand in a single input

const binaryScalarOperations = binaryScalarDefs.map(opDef => {
  const params = [{
    name: 'Value',
    type: 'number'
  }];
  const defaultParams = [2];

  if (opDef.comparison) {
    params.push({
      name: 'Bool',
      type: 'boolean',
      description: 'If checked comparison will return 0 or 1 for the value rather than filtering.'
    });
    defaultParams.push(false);
  }

  return {
    id: opDef.id,
    name: opDef.name,
    params,
    defaultParams,
    alternativesKey: 'binary scalar operations',
    category: _types__WEBPACK_IMPORTED_MODULE_1__.PromVisualQueryOperationCategory.BinaryOps,
    renderer: getSimpleBinaryRenderer(opDef.sign),
    addOperationHandler: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_0__.defaultAddOperationHandler
  };
});

function getSimpleBinaryRenderer(operator) {
  return function binaryRenderer(model, def, innerExpr) {
    let param = model.params[0];
    let bool = '';

    if (model.params.length === 2) {
      bool = model.params[1] ? ' bool' : '';
    }

    return `${innerExpr} ${operator}${bool} ${param}`;
  };
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/components/LabelParamEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LabelParamEditor": () => (/* binding */ LabelParamEditor)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _datasource__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/datasource.tsx");
/* harmony import */ var _PromQueryModeller__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/PromQueryModeller.ts");
/* harmony import */ var _shared_operationUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");







function LabelParamEditor({
  onChange,
  index,
  operationIndex,
  value,
  query,
  datasource
}) {
  const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Select, {
    inputId: (0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_5__.getOperationParamId)(operationIndex, index),
    autoFocus: value === '' ? true : undefined,
    openMenuOnFocus: true,
    onOpenMenu: async () => {
      setState({
        isLoading: true
      });
      const options = await loadGroupByLabels(query, datasource);
      setState({
        options,
        isLoading: undefined
      });
    },
    isLoading: state.isLoading,
    allowCustomValue: true,
    noOptionsMessage: "No labels found",
    loadingMessage: "Loading labels",
    options: state.options,
    value: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_1__.toOption)(value),
    onChange: value => onChange(index, value.value)
  });
}

async function loadGroupByLabels(query, datasource) {
  let labels = query.labels; // This function is used by both Prometheus and Loki and this the only difference

  if (datasource instanceof _datasource__WEBPACK_IMPORTED_MODULE_3__.PrometheusDatasource) {
    labels = [{
      label: '__name__',
      op: '=',
      value: query.metric
    }, ...query.labels];
  }

  const expr = _PromQueryModeller__WEBPACK_IMPORTED_MODULE_4__.promQueryModeller.renderLabels(labels);
  const result = await datasource.languageProvider.fetchSeriesLabels(expr);
  return Object.keys(result).map(x => ({
    label: x,
    value: x
  }));
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/components/MetricSelect.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MetricSelect": () => (/* binding */ MetricSelect)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_highlight_words__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/react-highlight-words-virtual-d2265e757c/0/cache/react-highlight-words-npm-0.17.0-880b4a18ed-41b3d0e451.zip/node_modules/react-highlight-words/dist/main.js");
/* harmony import */ var react_highlight_words__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_highlight_words__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-22e4fdfd25/0/cache/@grafana-experimental-npm-0.0.2-canary.30-71a280d204-b5b453b937.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");

 // @ts-ignore






// We are matching words split with space
const splitSeparator = ' ';
function MetricSelect({
  query,
  onChange,
  onGetMetrics
}) {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_5__.useStyles2)(getStyles);
  const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});
  const customFilterOption = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((option, searchQuery) => {
    var _option$label;

    const label = (_option$label = option.label) !== null && _option$label !== void 0 ? _option$label : option.value;

    if (!label) {
      return false;
    } // custom value is not a string label but a react node


    if (!label.toLowerCase) {
      return true;
    }

    const searchWords = searchQuery.split(splitSeparator);
    return searchWords.reduce((acc, cur) => acc && label.toLowerCase().includes(cur.toLowerCase()), true);
  }, []);
  const formatOptionLabel = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((option, meta) => {
    var _option$label2;

    // For newly created custom value we don't want to add highlight
    if (option['__isNew__']) {
      return option.label;
    }

    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)((react_highlight_words__WEBPACK_IMPORTED_MODULE_2___default()), {
      searchWords: meta.inputValue.split(splitSeparator),
      textToHighlight: (_option$label2 = option.label) !== null && _option$label2 !== void 0 ? _option$label2 : '',
      highlightClassName: styles.highlight
    });
  }, [styles.highlight]);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_4__.EditorFieldGroup, {
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_4__.EditorField, {
      label: "Metric",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_5__.Select, {
        inputId: "prometheus-metric-select",
        className: styles.select,
        value: query.metric ? (0,_grafana_data__WEBPACK_IMPORTED_MODULE_3__.toOption)(query.metric) : undefined,
        placeholder: "Select metric",
        allowCustomValue: true,
        formatOptionLabel: formatOptionLabel,
        filterOption: customFilterOption,
        onOpenMenu: async () => {
          setState({
            isLoading: true
          });
          const metrics = await onGetMetrics();
          setState({
            metrics,
            isLoading: undefined
          });
        },
        isLoading: state.isLoading,
        options: state.metrics,
        onChange: ({
          value
        }) => {
          if (value) {
            onChange(Object.assign({}, query, {
              metric: value
            }));
          }
        }
      })
    })
  });
}

const getStyles = theme => ({
  select: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    min-width: 125px;
  `,
  highlight: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    label: select__match-highlight;
    background: inherit;
    padding: inherit;
    color: ${theme.colors.warning.main};
    background-color: rgba(${theme.colors.warning.main}, 0.1);
  `
});

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/components/NestedQuery.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NestedQuery": () => (/* binding */ NestedQuery)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-22e4fdfd25/0/cache/@grafana-experimental-npm-0.0.2-canary.30-71a280d204-b5b453b937.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _binaryScalarOperations__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/binaryScalarOperations.ts");
/* harmony import */ var _shared_AutoSizeInput__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/AutoSizeInput.tsx");
/* harmony import */ var _PromQueryBuilder__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryBuilder.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _FlexItem;











const NestedQuery = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.memo(({
  nestedQuery,
  index,
  datasource,
  onChange,
  onRemove,
  onRunQuery
}) => {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.useStyles2)(getStyles);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsxs)("div", {
    className: styles.card,
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsxs)("div", {
      className: styles.header,
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("div", {
        className: styles.name,
        children: "Operator"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Select, {
        width: "auto",
        options: operators,
        value: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_2__.toOption)(nestedQuery.operator),
        onChange: value => {
          onChange(index, Object.assign({}, nestedQuery, {
            operator: value.value
          }));
        }
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("div", {
        className: styles.name,
        children: "Vector matches"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsxs)("div", {
        className: styles.vectorMatchWrapper,
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Select, {
          width: "auto",
          value: nestedQuery.vectorMatchesType || 'on',
          allowCustomValue: true,
          options: [{
            value: 'on',
            label: 'on'
          }, {
            value: 'ignoring',
            label: 'ignoring'
          }],
          onChange: val => {
            onChange(index, Object.assign({}, nestedQuery, {
              vectorMatchesType: val.value
            }));
          }
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_shared_AutoSizeInput__WEBPACK_IMPORTED_MODULE_6__.AutoSizeInput, {
          className: styles.vectorMatchInput,
          minWidth: 20,
          defaultValue: nestedQuery.vectorMatches,
          onCommitChange: evt => {
            onChange(index, Object.assign({}, nestedQuery, {
              vectorMatches: evt.currentTarget.value,
              vectorMatchesType: nestedQuery.vectorMatchesType || 'on'
            }));
          }
        })]
      }), _FlexItem || (_FlexItem = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_3__.FlexItem, {
        grow: 1
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.IconButton, {
        name: "times",
        size: "sm",
        onClick: () => onRemove(index)
      })]
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("div", {
      className: styles.body,
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_3__.EditorRows, {
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_PromQueryBuilder__WEBPACK_IMPORTED_MODULE_7__.PromQueryBuilder, {
          query: nestedQuery.query,
          datasource: datasource,
          nested: true,
          onRunQuery: onRunQuery,
          onChange: update => {
            onChange(index, Object.assign({}, nestedQuery, {
              query: update
            }));
          }
        })
      })
    })]
  });
});
const operators = _binaryScalarOperations__WEBPACK_IMPORTED_MODULE_5__.binaryScalarDefs.map(def => ({
  label: def.sign,
  value: def.sign
}));
NestedQuery.displayName = 'NestedQuery';

const getStyles = theme => {
  return {
    card: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'card',
      display: 'flex',
      flexDirection: 'column',
      gap: theme.spacing(0.5)
    }),
    header: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'header',
      padding: theme.spacing(0.5, 0.5, 0.5, 1),
      gap: theme.spacing(1),
      display: 'flex',
      alignItems: 'center'
    }),
    name: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'name',
      whiteSpace: 'nowrap'
    }),
    body: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'body',
      paddingLeft: theme.spacing(2)
    }),
    vectorMatchInput: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'vectorMatchInput',
      marginLeft: -1
    }),
    vectorMatchWrapper: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'vectorMatchWrapper',
      display: 'flex'
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/components/NestedQueryList.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NestedQueryList": () => (/* binding */ NestedQueryList)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-22e4fdfd25/0/cache/@grafana-experimental-npm-0.0.2-canary.30-71a280d204-b5b453b937.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _NestedQuery__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/NestedQuery.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");




function NestedQueryList({
  query,
  datasource,
  onChange,
  onRunQuery
}) {
  var _query$binaryQueries;

  const nestedQueries = (_query$binaryQueries = query.binaryQueries) !== null && _query$binaryQueries !== void 0 ? _query$binaryQueries : [];

  const onNestedQueryUpdate = (index, update) => {
    const updatedList = [...nestedQueries];
    updatedList.splice(index, 1, update);
    onChange(Object.assign({}, query, {
      binaryQueries: updatedList
    }));
  };

  const onRemove = index => {
    const updatedList = [...nestedQueries.slice(0, index), ...nestedQueries.slice(index + 1)];
    onChange(Object.assign({}, query, {
      binaryQueries: updatedList
    }));
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.Stack, {
    direction: "column",
    gap: 1,
    children: nestedQueries.map((nestedQuery, index) => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_NestedQuery__WEBPACK_IMPORTED_MODULE_2__.NestedQuery, {
      nestedQuery: nestedQuery,
      index: index,
      onChange: onNestedQueryUpdate,
      datasource: datasource,
      onRemove: onRemove,
      onRunQuery: onRunQuery
    }, index.toString()))
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryBuilder.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromQueryBuilder": () => (/* binding */ PromQueryBuilder)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-22e4fdfd25/0/cache/@grafana-experimental-npm-0.0.2-canary.30-71a280d204-b5b453b937.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _language_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/language_provider.ts");
/* harmony import */ var _PromQueryModeller__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/PromQueryModeller.ts");
/* harmony import */ var _shared_LabelFilters__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/LabelFilters.tsx");
/* harmony import */ var _shared_OperationList__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationList.tsx");
/* harmony import */ var _shared_OperationsEditorRow__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationsEditorRow.tsx");
/* harmony import */ var _MetricSelect__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/MetricSelect.tsx");
/* harmony import */ var _NestedQueryList__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/NestedQueryList.tsx");
/* harmony import */ var _PromQueryBuilderHints__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryBuilderHints.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");













const PromQueryBuilder = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.memo(({
  datasource,
  query,
  onChange,
  onRunQuery,
  data
}) => {
  const onChangeLabels = labels => {
    onChange(Object.assign({}, query, {
      labels
    }));
  };
  /**
   * Map metric metadata to SelectableValue for Select component and also adds defined template variables to the list.
   */


  const withTemplateVariableOptions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async optionsPromise => {
    const variables = datasource.getVariables();
    const options = await optionsPromise;
    return [...variables.map(value => ({
      label: value,
      value
    })), ...options.map(option => ({
      label: option.value,
      value: option.value,
      title: option.description
    }))];
  }, [datasource]);

  const onGetLabelNames = async forLabel => {
    // If no metric we need to use a different method
    if (!query.metric) {
      // Todo add caching but inside language provider!
      await datasource.languageProvider.fetchLabels();
      return datasource.languageProvider.getLabelKeys().map(k => ({
        value: k
      }));
    }

    const labelsToConsider = query.labels.filter(x => x !== forLabel);
    labelsToConsider.push({
      label: '__name__',
      op: '=',
      value: query.metric
    });
    const expr = _PromQueryModeller__WEBPACK_IMPORTED_MODULE_3__.promQueryModeller.renderLabels(labelsToConsider);
    const labelsIndex = await datasource.languageProvider.fetchSeriesLabels(expr); // filter out already used labels

    return Object.keys(labelsIndex).filter(labelName => !labelsToConsider.find(filter => filter.label === labelName)).map(k => ({
      value: k
    }));
  };

  const onGetLabelValues = async forLabel => {
    var _result$forLabelInter;

    if (!forLabel.label) {
      return [];
    } // If no metric we need to use a different method


    if (!query.metric) {
      return (await datasource.languageProvider.getLabelValues(forLabel.label)).map(v => ({
        value: v
      }));
    }

    const labelsToConsider = query.labels.filter(x => x !== forLabel);
    labelsToConsider.push({
      label: '__name__',
      op: '=',
      value: query.metric
    });
    const expr = _PromQueryModeller__WEBPACK_IMPORTED_MODULE_3__.promQueryModeller.renderLabels(labelsToConsider);
    const result = await datasource.languageProvider.fetchSeriesLabels(expr);
    const forLabelInterpolated = datasource.interpolateString(forLabel.label);
    return (_result$forLabelInter = result[forLabelInterpolated].map(v => ({
      value: v
    }))) !== null && _result$forLabelInter !== void 0 ? _result$forLabelInter : [];
  };

  const onGetMetrics = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {
    return withTemplateVariableOptions(getMetrics(datasource, query));
  }, [datasource, query, withTemplateVariableOptions]);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_10__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_10__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_10__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorRow, {
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_10__.jsx)(_MetricSelect__WEBPACK_IMPORTED_MODULE_7__.MetricSelect, {
        query: query,
        onChange: onChange,
        onGetMetrics: onGetMetrics
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_10__.jsx)(_shared_LabelFilters__WEBPACK_IMPORTED_MODULE_4__.LabelFilters, {
        labelsFilters: query.labels,
        onChange: onChangeLabels,
        onGetLabelNames: forLabel => withTemplateVariableOptions(onGetLabelNames(forLabel)),
        onGetLabelValues: forLabel => withTemplateVariableOptions(onGetLabelValues(forLabel))
      })]
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_10__.jsxs)(_shared_OperationsEditorRow__WEBPACK_IMPORTED_MODULE_6__.OperationsEditorRow, {
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_10__.jsx)(_shared_OperationList__WEBPACK_IMPORTED_MODULE_5__.OperationList, {
        queryModeller: _PromQueryModeller__WEBPACK_IMPORTED_MODULE_3__.promQueryModeller,
        datasource: datasource,
        query: query,
        onChange: onChange,
        onRunQuery: onRunQuery
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_10__.jsx)(_PromQueryBuilderHints__WEBPACK_IMPORTED_MODULE_9__.PromQueryBuilderHints, {
        datasource: datasource,
        query: query,
        onChange: onChange,
        data: data
      })]
    }), query.binaryQueries && query.binaryQueries.length > 0 && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_10__.jsx)(_NestedQueryList__WEBPACK_IMPORTED_MODULE_8__.NestedQueryList, {
      query: query,
      datasource: datasource,
      onChange: onChange,
      onRunQuery: onRunQuery
    })]
  });
});
/**
 * Returns list of metrics, either all or filtered by query param. It also adds description string to each metric if it
 * exists.
 * @param datasource
 * @param query
 */

async function getMetrics(datasource, query) {
  // Makes sure we loaded the metadata for metrics. Usually this is done in the start() method of the provider but we
  // don't use it with the visual builder and there is no need to run all the start() setup anyway.
  if (!datasource.languageProvider.metricsMetadata) {
    await datasource.languageProvider.loadMetricsMetadata();
  }

  let metrics;

  if (query.labels.length > 0) {
    var _await$datasource$lan;

    const expr = _PromQueryModeller__WEBPACK_IMPORTED_MODULE_3__.promQueryModeller.renderLabels(query.labels);
    metrics = (_await$datasource$lan = (await datasource.languageProvider.getSeries(expr, true))['__name__']) !== null && _await$datasource$lan !== void 0 ? _await$datasource$lan : [];
  } else {
    var _await$datasource$lan2;

    metrics = (_await$datasource$lan2 = await datasource.languageProvider.getLabelValues('__name__')) !== null && _await$datasource$lan2 !== void 0 ? _await$datasource$lan2 : [];
  }

  return metrics.map(m => ({
    value: m,
    description: (0,_language_provider__WEBPACK_IMPORTED_MODULE_2__.getMetadataString)(m, datasource.languageProvider.metricsMetadata)
  }));
}

PromQueryBuilder.displayName = 'PromQueryBuilder';

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryBuilderContainer.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromQueryBuilderContainer": () => (/* binding */ PromQueryBuilderContainer)
/* harmony export */ });
/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/__virtual__/@reduxjs-toolkit-virtual-341575ab98/0/cache/@reduxjs-toolkit-npm-1.8.0-436263eab0-e229571b80.zip/node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _PromQueryModeller__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/PromQueryModeller.ts");
/* harmony import */ var _parsing__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/parsing.ts");
/* harmony import */ var _PromQueryBuilder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryBuilder.tsx");
/* harmony import */ var _QueryPreview__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/QueryPreview.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");










/**
 * This component is here just to contain the translation logic between string query and the visual query builder model.
 */
function PromQueryBuilderContainer(props) {
  const {
    query,
    onChange,
    onRunQuery,
    datasource,
    data
  } = props;
  const [state, dispatch] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(stateSlice.reducer, {
    expr: query.expr
  }); // Only rebuild visual query if expr changes from outside

  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    dispatch(exprChanged(query.expr));
  }, [query.expr]);

  const onVisQueryChange = visQuery => {
    const expr = _PromQueryModeller__WEBPACK_IMPORTED_MODULE_1__.promQueryModeller.renderQuery(visQuery);
    dispatch(visualQueryChange({
      visQuery,
      expr
    }));
    onChange(Object.assign({}, props.query, {
      expr: expr
    }));
  };

  if (!state.visQuery) {
    return null;
  }

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_PromQueryBuilder__WEBPACK_IMPORTED_MODULE_3__.PromQueryBuilder, {
      query: state.visQuery,
      datasource: datasource,
      onChange: onVisQueryChange,
      onRunQuery: onRunQuery,
      data: data
    }), query.rawQuery && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_QueryPreview__WEBPACK_IMPORTED_MODULE_4__.QueryPreview, {
      query: query.expr
    })]
  });
}
const stateSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_6__.createSlice)({
  name: 'prom-builder-container',
  initialState: {
    expr: ''
  },
  reducers: {
    visualQueryChange: (state, action) => {
      state.expr = action.payload.expr;
      state.visQuery = action.payload.visQuery;
    },
    exprChanged: (state, action) => {
      if (!state.visQuery || state.expr !== action.payload) {
        state.expr = action.payload;
        const parseResult = (0,_parsing__WEBPACK_IMPORTED_MODULE_2__.buildVisualQueryFromString)(action.payload);
        state.visQuery = parseResult.query;
      }
    }
  }
});
const {
  visualQueryChange,
  exprChanged
} = stateSlice.actions;

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryBuilderExplained.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromQueryBuilderExplained": () => (/* binding */ PromQueryBuilderExplained)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-22e4fdfd25/0/cache/@grafana-experimental-npm-0.0.2-canary.30-71a280d204-b5b453b937.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _PromQueryModeller__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/PromQueryModeller.ts");
/* harmony import */ var _parsing__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/parsing.ts");
/* harmony import */ var _shared_OperationExplainedBox__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationExplainedBox.tsx");
/* harmony import */ var _shared_OperationListExplained__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationListExplained.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");








const PromQueryBuilderExplained = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.memo(({
  query,
  nested
}) => {
  const visQuery = (0,_parsing__WEBPACK_IMPORTED_MODULE_3__.buildVisualQueryFromString)(query || '').query;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.Stack, {
    gap: 0,
    direction: "column",
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_shared_OperationExplainedBox__WEBPACK_IMPORTED_MODULE_4__.OperationExplainedBox, {
      stepNumber: 1,
      title: `${visQuery.metric} ${_PromQueryModeller__WEBPACK_IMPORTED_MODULE_2__.promQueryModeller.renderLabels(visQuery.labels)}`,
      children: "Fetch all series matching metric name and label filters."
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_shared_OperationListExplained__WEBPACK_IMPORTED_MODULE_5__.OperationListExplained, {
      stepNumber: 2,
      queryModeller: _PromQueryModeller__WEBPACK_IMPORTED_MODULE_2__.promQueryModeller,
      query: visQuery
    })]
  });
});
PromQueryBuilderExplained.displayName = 'PromQueryBuilderExplained';

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryBuilderHints.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromQueryBuilderHints": () => (/* binding */ PromQueryBuilderHints)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _PromQueryModeller__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/PromQueryModeller.ts");
/* harmony import */ var _parsing__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/parsing.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");







const PromQueryBuilderHints = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.memo(({
  datasource,
  query,
  onChange,
  data
}) => {
  const [hints, setHints] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.useStyles2)(getStyles);
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
    const promQuery = {
      expr: _PromQueryModeller__WEBPACK_IMPORTED_MODULE_3__.promQueryModeller.renderQuery(query),
      refId: ''
    }; // For now show only actionable hints

    const hints = datasource.getQueryHints(promQuery, (data === null || data === void 0 ? void 0 : data.series) || []).filter(hint => {
      var _hint$fix;

      return (_hint$fix = hint.fix) === null || _hint$fix === void 0 ? void 0 : _hint$fix.action;
    });
    setHints(hints);
  }, [datasource, query, onChange, data, styles.hint]);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
    children: hints.length > 0 && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
      className: styles.container,
      children: hints.map(hint => {
        var _hint$fix2, _hint$fix3, _hint$fix3$action;

        return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Tooltip, {
          content: `${hint.label} ${(_hint$fix2 = hint.fix) === null || _hint$fix2 === void 0 ? void 0 : _hint$fix2.label}`,
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Button, {
            onClick: () => {
              const promQuery = {
                expr: _PromQueryModeller__WEBPACK_IMPORTED_MODULE_3__.promQueryModeller.renderQuery(query),
                refId: ''
              };
              const newPromQuery = datasource.modifyQuery(promQuery, hint.fix.action);
              const visualQuery = (0,_parsing__WEBPACK_IMPORTED_MODULE_4__.buildVisualQueryFromString)(newPromQuery.expr);
              return onChange(visualQuery.query);
            },
            fill: "outline",
            size: "sm",
            className: styles.hint,
            children: 'hint: ' + ((_hint$fix3 = hint.fix) === null || _hint$fix3 === void 0 ? void 0 : (_hint$fix3$action = _hint$fix3.action) === null || _hint$fix3$action === void 0 ? void 0 : _hint$fix3$action.type.toLowerCase().replace('_', ' ')) + '()'
          })
        }, hint.type);
      })
    })
  });
});
PromQueryBuilderHints.displayName = 'PromQueryBuilderHints';

const getStyles = theme => {
  return {
    container: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
      display: flex;
      margin-bottom: ${theme.spacing(1)};
      align-items: center;
    `,
    hint: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
      margin-right: ${theme.spacing(1)};
    `
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryBuilderOptions.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromQueryBuilderOptions": () => (/* binding */ PromQueryBuilderOptions)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-22e4fdfd25/0/cache/@grafana-experimental-npm-0.0.2-canary.30-71a280d204-b5b453b937.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _components_PromExploreExtraField__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromExploreExtraField.tsx");
/* harmony import */ var _components_PromQueryEditor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromQueryEditor.tsx");
/* harmony import */ var _shared_AutoSizeInput__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/AutoSizeInput.tsx");
/* harmony import */ var _shared_QueryOptionGroup__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/QueryOptionGroup.tsx");
/* harmony import */ var _PromQueryLegendEditor__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryLegendEditor.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _code, _code2;













const PromQueryBuilderOptions = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.memo(({
  query,
  app,
  onChange,
  onRunQuery
}) => {
  const onChangeFormat = value => {
    onChange(Object.assign({}, query, {
      format: value.value
    }));
    onRunQuery();
  };

  const onChangeStep = evt => {
    onChange(Object.assign({}, query, {
      interval: evt.currentTarget.value
    }));
    onRunQuery();
  };

  const queryTypeOptions = (0,_components_PromExploreExtraField__WEBPACK_IMPORTED_MODULE_4__.getQueryTypeOptions)(app === _grafana_data__WEBPACK_IMPORTED_MODULE_1__.CoreApp.Explore);
  const onQueryTypeChange = (0,_components_PromExploreExtraField__WEBPACK_IMPORTED_MODULE_4__.getQueryTypeChangeHandler)(query, onChange);

  const onExemplarChange = event => {
    const isEnabled = event.currentTarget.checked;
    onChange(Object.assign({}, query, {
      exemplar: isEnabled
    }));
    onRunQuery();
  };

  const onIntervalFactorChange = value => {
    onChange(Object.assign({}, query, {
      intervalFactor: value.value
    }));
    onRunQuery();
  };

  const formatOption = _components_PromQueryEditor__WEBPACK_IMPORTED_MODULE_5__.FORMAT_OPTIONS.find(option => option.value === query.format) || _components_PromQueryEditor__WEBPACK_IMPORTED_MODULE_5__.FORMAT_OPTIONS[0];
  const queryTypeValue = getQueryTypeValue(query);
  const queryTypeLabel = queryTypeOptions.find(x => x.value === queryTypeValue).label;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.EditorRow, {
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsxs)(_shared_QueryOptionGroup__WEBPACK_IMPORTED_MODULE_7__.QueryOptionGroup, {
      title: "Options",
      collapsedInfo: getCollapsedInfo(query, formatOption.label, queryTypeLabel),
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(_PromQueryLegendEditor__WEBPACK_IMPORTED_MODULE_8__.PromQueryLegendEditor, {
        legendFormat: query.legendFormat,
        onChange: legendFormat => onChange(Object.assign({}, query, {
          legendFormat
        })),
        onRunQuery: onRunQuery
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.EditorField, {
        label: "Min step",
        tooltip: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.Fragment, {
          children: ["An additional lower limit for the step parameter of the Prometheus query and for the", ' ', _code || (_code = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("code", {
            children: "$__interval"
          })), " and ", _code2 || (_code2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("code", {
            children: "$__rate_interval"
          })), " variables."]
        }),
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(_shared_AutoSizeInput__WEBPACK_IMPORTED_MODULE_6__.AutoSizeInput, {
          type: "text",
          "aria-label": "Set lower limit for the step parameter",
          placeholder: 'auto',
          minWidth: 10,
          onCommitChange: onChangeStep,
          defaultValue: query.interval
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.EditorField, {
        label: "Format",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Select, {
          value: formatOption,
          allowCustomValue: true,
          onChange: onChangeFormat,
          options: _components_PromQueryEditor__WEBPACK_IMPORTED_MODULE_5__.FORMAT_OPTIONS
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.EditorField, {
        label: "Type",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.RadioButtonGroup, {
          options: queryTypeOptions,
          value: queryTypeValue,
          onChange: onQueryTypeChange
        })
      }), shouldShowExemplarSwitch(query, app) && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.EditorField, {
        label: "Exemplars",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.EditorSwitch, {
          value: query.exemplar,
          onChange: onExemplarChange
        })
      }), query.intervalFactor && query.intervalFactor > 1 && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.EditorField, {
        label: "Resolution",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Select, {
          "aria-label": "Select resolution",
          isSearchable: false,
          options: _components_PromQueryEditor__WEBPACK_IMPORTED_MODULE_5__.INTERVAL_FACTOR_OPTIONS,
          onChange: onIntervalFactorChange,
          value: _components_PromQueryEditor__WEBPACK_IMPORTED_MODULE_5__.INTERVAL_FACTOR_OPTIONS.find(option => option.value === query.intervalFactor)
        })
      })]
    })
  });
});

function shouldShowExemplarSwitch(query, app) {
  if (app === _grafana_data__WEBPACK_IMPORTED_MODULE_1__.CoreApp.UnifiedAlerting || !query.range) {
    return false;
  }

  return true;
}

function getQueryTypeValue(query) {
  return query.range && query.instant ? 'both' : query.instant ? 'instant' : 'range';
}

function getCollapsedInfo(query, formatOption, queryType) {
  const items = [];
  items.push(`Legend: ${(0,_PromQueryLegendEditor__WEBPACK_IMPORTED_MODULE_8__.getLegendModeLabel)(query.legendFormat)}`);
  items.push(`Format: ${formatOption}`);

  if (query.interval) {
    items.push(`Step ${query.interval}`);
  }

  items.push(`Type: ${queryType}`);

  if (query.exemplar) {
    items.push(`Exemplars: true`);
  }

  return items;
}

PromQueryBuilderOptions.displayName = 'PromQueryBuilderOptions';

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryCodeEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromQueryCodeEditor": () => (/* binding */ PromQueryCodeEditor)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _components_PromQueryEditor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromQueryEditor.tsx");
/* harmony import */ var _components_PromQueryField__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromQueryField.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");






function PromQueryCodeEditor({
  query,
  datasource,
  range,
  onRunQuery,
  onChange,
  data,
  app
}) {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.useStyles2)(getStyles);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
    className: styles.wrapper,
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_components_PromQueryField__WEBPACK_IMPORTED_MODULE_4__["default"], {
      datasource: datasource,
      query: query,
      range: range,
      onRunQuery: onRunQuery,
      onChange: onChange,
      history: [],
      data: data,
      "data-testid": _components_PromQueryEditor__WEBPACK_IMPORTED_MODULE_3__.testIds.editor,
      app: app
    })
  });
}

const getStyles = theme => {
  return {
    // This wrapper styling can be removed after the old PromQueryEditor is removed.
    // This is removing margin bottom on the old legacy inline form styles
    wrapper: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
      .gf-form {
        margin-bottom: 0;
      }
    `
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryEditorSelector.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromQueryEditorSelector": () => (/* binding */ PromQueryEditorSelector)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-22e4fdfd25/0/cache/@grafana-experimental-npm-0.0.2-canary.30-71a280d204-b5b453b937.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _PromQueryModeller__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/PromQueryModeller.ts");
/* harmony import */ var _parsing__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/parsing.ts");
/* harmony import */ var _shared_FeedbackLink__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/FeedbackLink.tsx");
/* harmony import */ var _shared_QueryEditorModeToggle__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/QueryEditorModeToggle.tsx");
/* harmony import */ var _shared_QueryHeaderSwitch__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/QueryHeaderSwitch.tsx");
/* harmony import */ var _shared_types__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/types.ts");
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/state.ts");
/* harmony import */ var _PromQueryBuilderContainer__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryBuilderContainer.tsx");
/* harmony import */ var _PromQueryBuilderExplained__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryBuilderExplained.tsx");
/* harmony import */ var _PromQueryBuilderOptions__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryBuilderOptions.tsx");
/* harmony import */ var _PromQueryCodeEditor__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryCodeEditor.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _FeedbackLink, _FlexItem, _Space;




















const PromQueryEditorSelector = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.memo(props => {
  const {
    onChange,
    onRunQuery,
    data,
    app
  } = props;
  const [parseModalOpen, setParseModalOpen] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);
  const [dataIsStale, setDataIsStale] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);
  const query = (0,_state__WEBPACK_IMPORTED_MODULE_11__.getQueryWithDefaults)(props.query, app);
  const editorMode = query.editorMode;
  const onEditorModeChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(newMetricEditorMode => {
    var _query$editorMode;

    (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_3__.reportInteraction)('user_grafana_prometheus_editor_mode_clicked', {
      newEditor: newMetricEditorMode,
      previousEditor: (_query$editorMode = query.editorMode) !== null && _query$editorMode !== void 0 ? _query$editorMode : '',
      newQuery: !query.expr,
      app: app !== null && app !== void 0 ? app : ''
    });

    if (newMetricEditorMode === _shared_types__WEBPACK_IMPORTED_MODULE_10__.QueryEditorMode.Builder) {
      const result = (0,_parsing__WEBPACK_IMPORTED_MODULE_6__.buildVisualQueryFromString)(query.expr || ''); // If there are errors, give user a chance to decide if they want to go to builder as that can loose some data.

      if (result.errors.length) {
        setParseModalOpen(true);
        return;
      }
    }

    (0,_state__WEBPACK_IMPORTED_MODULE_11__.changeEditorMode)(query, newMetricEditorMode, onChange);
  }, [onChange, query, app]);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    setDataIsStale(false);
  }, [data]);

  const onQueryPreviewChange = event => {
    const isEnabled = event.currentTarget.checked;
    onChange(Object.assign({}, query, {
      rawQuery: isEnabled
    }));
  };

  const onChangeInternal = query => {
    setDataIsStale(true);
    onChange(query);
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.ConfirmModal, {
      isOpen: parseModalOpen,
      title: "Query parsing",
      body: "There were errors while trying to parse the query. Continuing to visual builder may loose some parts of the query.",
      confirmText: "Continue",
      onConfirm: () => {
        (0,_state__WEBPACK_IMPORTED_MODULE_11__.changeEditorMode)(query, _shared_types__WEBPACK_IMPORTED_MODULE_10__.QueryEditorMode.Builder, onChange);
        setParseModalOpen(false);
      },
      onDismiss: () => setParseModalOpen(false)
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.EditorHeader, {
      children: [editorMode === _shared_types__WEBPACK_IMPORTED_MODULE_10__.QueryEditorMode.Builder && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.Fragment, {
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.InlineSelect, {
          value: null,
          placeholder: "Query patterns",
          allowCustomValue: true,
          onChange: ({
            value
          }) => {
            // TODO: Bit convoluted as we don't have access to visualQuery model here. Maybe would make sense to
            //  move it inside the editor?
            const result = (0,_parsing__WEBPACK_IMPORTED_MODULE_6__.buildVisualQueryFromString)(query.expr || '');
            result.query.operations = value === null || value === void 0 ? void 0 : value.operations;
            onChange(Object.assign({}, query, {
              expr: _PromQueryModeller__WEBPACK_IMPORTED_MODULE_5__.promQueryModeller.renderQuery(result.query)
            }));
          },
          options: _PromQueryModeller__WEBPACK_IMPORTED_MODULE_5__.promQueryModeller.getQueryPatterns().map(x => ({
            label: x.name,
            value: x
          }))
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsx)(_shared_QueryHeaderSwitch__WEBPACK_IMPORTED_MODULE_9__.QueryHeaderSwitch, {
          label: "Raw query",
          value: query.rawQuery,
          onChange: onQueryPreviewChange
        })]
      }), editorMode === _shared_types__WEBPACK_IMPORTED_MODULE_10__.QueryEditorMode.Builder && (_FeedbackLink || (_FeedbackLink = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsx)(_shared_FeedbackLink__WEBPACK_IMPORTED_MODULE_7__.FeedbackLink, {
        feedbackUrl: "https://github.com/grafana/grafana/discussions/47693"
      }))), _FlexItem || (_FlexItem = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.FlexItem, {
        grow: 1
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Button, {
        variant: dataIsStale ? 'primary' : 'secondary',
        size: "sm",
        onClick: onRunQuery,
        icon: (data === null || data === void 0 ? void 0 : data.state) === _grafana_data__WEBPACK_IMPORTED_MODULE_1__.LoadingState.Loading ? 'fa fa-spinner' : undefined,
        disabled: (data === null || data === void 0 ? void 0 : data.state) === _grafana_data__WEBPACK_IMPORTED_MODULE_1__.LoadingState.Loading,
        children: "Run query"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsx)(_shared_QueryEditorModeToggle__WEBPACK_IMPORTED_MODULE_8__.QueryEditorModeToggle, {
        mode: editorMode,
        onChange: onEditorModeChange
      })]
    }), _Space || (_Space = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.Space, {
      v: 0.5
    })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.EditorRows, {
      children: [editorMode === _shared_types__WEBPACK_IMPORTED_MODULE_10__.QueryEditorMode.Code && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsx)(_PromQueryCodeEditor__WEBPACK_IMPORTED_MODULE_15__.PromQueryCodeEditor, Object.assign({}, props)), editorMode === _shared_types__WEBPACK_IMPORTED_MODULE_10__.QueryEditorMode.Builder && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsx)(_PromQueryBuilderContainer__WEBPACK_IMPORTED_MODULE_12__.PromQueryBuilderContainer, {
        query: query,
        datasource: props.datasource,
        onChange: onChangeInternal,
        onRunQuery: props.onRunQuery,
        data: data
      }), editorMode === _shared_types__WEBPACK_IMPORTED_MODULE_10__.QueryEditorMode.Explain && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsx)(_PromQueryBuilderExplained__WEBPACK_IMPORTED_MODULE_13__.PromQueryBuilderExplained, {
        query: query.expr
      }), editorMode !== _shared_types__WEBPACK_IMPORTED_MODULE_10__.QueryEditorMode.Explain && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_16__.jsx)(_PromQueryBuilderOptions__WEBPACK_IMPORTED_MODULE_14__.PromQueryBuilderOptions, {
        query: query,
        app: props.app,
        onChange: onChange,
        onRunQuery: onRunQuery
      })]
    })]
  });
});
PromQueryEditorSelector.displayName = 'PromQueryEditorSelector';

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryLegendEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromQueryLegendEditor": () => (/* binding */ PromQueryLegendEditor),
/* harmony export */   "getLegendModeLabel": () => (/* binding */ getLegendModeLabel)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-22e4fdfd25/0/cache/@grafana-experimental-npm-0.0.2-canary.30-71a280d204-b5b453b937.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/types.ts");
/* harmony import */ var _shared_AutoSizeInput__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/AutoSizeInput.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");








const legendModeOptions = [{
  label: 'Auto',
  value: _types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Auto,
  description: 'Only includes unique labels'
}, {
  label: 'Verbose',
  value: _types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Verbose,
  description: 'All label names and values'
}, {
  label: 'Custom',
  value: _types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Custom,
  description: 'Provide a naming template'
}];
/**
 * Tests for this component are on the parent level (PromQueryBuilderOptions).
 */

const PromQueryLegendEditor = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.memo(({
  legendFormat,
  onChange,
  onRunQuery
}) => {
  const mode = getLegendMode(legendFormat);
  const inputRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);

  const onLegendFormatChanged = evt => {
    let newFormat = evt.currentTarget.value;

    if (newFormat.length === 0) {
      newFormat = _types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Auto;
    }

    if (newFormat !== legendFormat) {
      onChange(newFormat);
      onRunQuery();
    }
  };

  const onLegendModeChanged = value => {
    switch (value.value) {
      case _types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Auto:
        onChange(_types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Auto);
        break;

      case _types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Custom:
        onChange('{{label_name}}');
        setTimeout(() => {
          var _inputRef$current, _inputRef$current2;

          (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.focus();
          (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 ? void 0 : _inputRef$current2.setSelectionRange(2, 12, 'forward');
        }, 10);
        break;

      case _types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Verbose:
        onChange('');
        break;
    }

    onRunQuery();
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorField, {
    label: "Legend",
    tooltip: "Series name override or template. Ex. {{hostname}} will be replaced with label value for hostname.",
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
      children: [mode === _types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Custom && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_shared_AutoSizeInput__WEBPACK_IMPORTED_MODULE_4__.AutoSizeInput, {
        id: "legendFormat",
        minWidth: 22,
        placeholder: "auto",
        defaultValue: legendFormat,
        onCommitChange: onLegendFormatChanged,
        ref: inputRef
      }), mode !== _types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Custom && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Select, {
        inputId: "legend.mode",
        isSearchable: false,
        placeholder: "Select legend mode",
        options: legendModeOptions,
        width: 22,
        onChange: onLegendModeChanged,
        value: legendModeOptions.find(x => x.value === mode)
      })]
    })
  });
});
PromQueryLegendEditor.displayName = 'PromQueryLegendEditor';

function getLegendMode(legendFormat) {
  // This special value means the new smart minimal series naming
  if (legendFormat === _types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Auto) {
    return _types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Auto;
  } // Missing or empty legend format is the old verbose behavior


  if (legendFormat == null || legendFormat === '') {
    return _types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Verbose;
  }

  return _types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Custom;
}

function getLegendModeLabel(legendFormat) {
  const mode = getLegendMode(legendFormat);

  if (mode !== _types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Custom) {
    var _legendModeOptions$fi;

    return (_legendModeOptions$fi = legendModeOptions.find(x => x.value === mode)) === null || _legendModeOptions$fi === void 0 ? void 0 : _legendModeOptions$fi.label;
  }

  return legendFormat;
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/components/QueryPreview.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "QueryPreview": () => (/* binding */ QueryPreview)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/prismjs-npm-1.27.0-ca4e1667c6-85c7f4a3e9.zip/node_modules/prismjs/prism.js");
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prismjs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-22e4fdfd25/0/cache/@grafana-experimental-npm-0.0.2-canary.30-71a280d204-b5b453b937.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _promql__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/promql.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");







function QueryPreview({
  query
}) {
  const theme = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.useTheme2)();
  const styles = getStyles(theme);
  const highlighted = prismjs__WEBPACK_IMPORTED_MODULE_1___default().highlight(query, _promql__WEBPACK_IMPORTED_MODULE_5__.promqlGrammar, 'promql');
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_3__.EditorRow, {
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_3__.EditorFieldGroup, {
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_3__.EditorField, {
        label: "Raw query",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("div", {
          className: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.cx)(styles.editorField, 'prism-syntax-highlight'),
          "aria-label": "selector",
          dangerouslySetInnerHTML: {
            __html: highlighted
          }
        })
      })
    })
  });
}

const getStyles = theme => {
  return {
    editorField: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      fontFamily: theme.typography.fontFamilyMonospace,
      fontSize: theme.typography.bodySmall.fontSize
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/operations.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addOperationWithRangeVector": () => (/* binding */ addOperationWithRangeVector),
/* harmony export */   "createFunction": () => (/* binding */ createFunction),
/* harmony export */   "createRangeFunction": () => (/* binding */ createRangeFunction),
/* harmony export */   "getOperationDefinitions": () => (/* binding */ getOperationDefinitions),
/* harmony export */   "operationWithRangeVectorRenderer": () => (/* binding */ operationWithRangeVectorRenderer)
/* harmony export */ });
/* harmony import */ var _binaryScalarOperations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/binaryScalarOperations.ts");
/* harmony import */ var _components_LabelParamEditor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/LabelParamEditor.tsx");
/* harmony import */ var _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/types.ts");




function getOperationDefinitions() {
  const list = [{
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.HistogramQuantile,
    name: 'Histogram quantile',
    params: [{
      name: 'Quantile',
      type: 'number',
      options: [0.99, 0.95, 0.9, 0.75, 0.5, 0.25]
    }],
    defaultParams: [0.9],
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Functions,
    renderer: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.functionRendererLeft,
    addOperationHandler: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.defaultAddOperationHandler
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.LabelReplace,
    name: 'Label replace',
    params: [{
      name: 'Destination label',
      type: 'string'
    }, {
      name: 'Replacement',
      type: 'string'
    }, {
      name: 'Source label',
      type: 'string'
    }, {
      name: 'Regex',
      type: 'string'
    }],
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Functions,
    defaultParams: ['', '$1', '', '(.*)'],
    renderer: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.functionRendererRight,
    addOperationHandler: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.defaultAddOperationHandler
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Ln,
    name: 'Ln',
    params: [],
    defaultParams: [],
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Functions,
    renderer: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.functionRendererLeft,
    addOperationHandler: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.defaultAddOperationHandler
  }, createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Changes), createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Rate, true), createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Irate), createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Increase, true), createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Idelta), createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Delta), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.HoltWinters,
    params: [(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.getRangeVectorParamDef)(), {
      name: 'Smoothing Factor',
      type: 'number'
    }, {
      name: 'Trend Factor',
      type: 'number'
    }],
    defaultParams: ['$__interval', 0.5, 0.5],
    alternativesKey: 'range function',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.RangeFunctions,
    renderer: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.rangeRendererRightWithParams,
    addOperationHandler: addOperationWithRangeVector,
    changeTypeHandler: operationTypeChangedHandlerForRangeFunction
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.PredictLinear,
    params: [(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.getRangeVectorParamDef)(), {
      name: 'Seconds from now',
      type: 'number'
    }],
    defaultParams: ['$__interval', 60],
    alternativesKey: 'range function',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.RangeFunctions,
    renderer: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.rangeRendererRightWithParams,
    addOperationHandler: addOperationWithRangeVector,
    changeTypeHandler: operationTypeChangedHandlerForRangeFunction
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.QuantileOverTime,
    params: [(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.getRangeVectorParamDef)(), {
      name: 'Quantile',
      type: 'number'
    }],
    defaultParams: ['$__interval', 0.5],
    alternativesKey: 'overtime function',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.RangeFunctions,
    renderer: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.rangeRendererLeftWithParams,
    addOperationHandler: addOperationWithRangeVector,
    changeTypeHandler: operationTypeChangedHandlerForRangeFunction
  }), ..._binaryScalarOperations__WEBPACK_IMPORTED_MODULE_0__.binaryScalarOperations, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.NestedQuery,
    name: 'Binary operation with query',
    params: [],
    defaultParams: [],
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.BinaryOps,
    renderer: (model, def, innerExpr) => innerExpr,
    addOperationHandler: addNestedQueryHandler
  }, createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Absent
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Acos,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Acosh,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Asin,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Asinh,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Atan,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Atanh,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Ceil
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Clamp,
    name: 'Clamp',
    params: [{
      name: 'Minimum Scalar',
      type: 'number'
    }, {
      name: 'Maximum Scalar',
      type: 'number'
    }],
    defaultParams: [1, 1]
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.ClampMax,
    params: [{
      name: 'Maximum Scalar',
      type: 'number'
    }],
    defaultParams: [1]
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.ClampMin,
    params: [{
      name: 'Minimum Scalar',
      type: 'number'
    }],
    defaultParams: [1]
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Cos,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Cosh,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.DayOfMonth,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Time
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.DayOfWeek,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Time
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.DaysInMonth,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Time
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Deg
  }), createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Deriv), //
  createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Exp
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Floor
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Group
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Hour
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.LabelJoin,
    params: [{
      name: 'Destination Label',
      type: 'string',
      editor: _components_LabelParamEditor__WEBPACK_IMPORTED_MODULE_1__.LabelParamEditor
    }, {
      name: 'Separator',
      type: 'string'
    }, {
      name: 'Source Label',
      type: 'string',
      restParam: true,
      optional: true,
      editor: _components_LabelParamEditor__WEBPACK_IMPORTED_MODULE_1__.LabelParamEditor
    }],
    defaultParams: ['', ',', ''],
    renderer: labelJoinRenderer,
    addOperationHandler: labelJoinAddOperationHandler
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Log10
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Log2
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Minute
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Month
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Pi,
    renderer: model => `${model.id}()`
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Quantile,
    params: [{
      name: 'Value',
      type: 'number'
    }],
    defaultParams: [1],
    renderer: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.functionRendererLeft
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Rad
  }), createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Resets), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Round,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Functions,
    params: [{
      name: 'To Nearest',
      type: 'number'
    }],
    defaultParams: [1]
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Scalar
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Sgn
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Sin,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Sinh,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Sort
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.SortDesc
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Sqrt
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Stddev
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Tan,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Tanh,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Time,
    renderer: model => `${model.id}()`
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Timestamp
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Vector,
    params: [{
      name: 'Value',
      type: 'number'
    }],
    defaultParams: [1],
    renderer: model => `${model.id}(${model.params[0]})`
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Year
  })];
  return list;
}
function createFunction(definition) {
  var _definition$name, _definition$params, _definition$defaultPa, _definition$category, _definition$renderer, _definition$addOperat;

  return Object.assign({}, definition, {
    id: definition.id,
    name: (_definition$name = definition.name) !== null && _definition$name !== void 0 ? _definition$name : (0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.getPromAndLokiOperationDisplayName)(definition.id),
    params: (_definition$params = definition.params) !== null && _definition$params !== void 0 ? _definition$params : [],
    defaultParams: (_definition$defaultPa = definition.defaultParams) !== null && _definition$defaultPa !== void 0 ? _definition$defaultPa : [],
    category: (_definition$category = definition.category) !== null && _definition$category !== void 0 ? _definition$category : _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Functions,
    renderer: (_definition$renderer = definition.renderer) !== null && _definition$renderer !== void 0 ? _definition$renderer : definition.params ? _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.functionRendererRight : _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.functionRendererLeft,
    addOperationHandler: (_definition$addOperat = definition.addOperationHandler) !== null && _definition$addOperat !== void 0 ? _definition$addOperat : _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.defaultAddOperationHandler
  });
}
function createRangeFunction(name, withRateInterval = false) {
  return {
    id: name,
    name: (0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.getPromAndLokiOperationDisplayName)(name),
    params: [(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.getRangeVectorParamDef)(withRateInterval)],
    defaultParams: [withRateInterval ? '$__rate_interval' : '$__interval'],
    alternativesKey: 'range function',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.RangeFunctions,
    renderer: operationWithRangeVectorRenderer,
    addOperationHandler: addOperationWithRangeVector,
    changeTypeHandler: operationTypeChangedHandlerForRangeFunction
  };
}

function operationTypeChangedHandlerForRangeFunction(operation, newDef) {
  // validate current parameter
  if (operation.params[0] === '$__rate_interval' && newDef.defaultParams[0] !== '$__rate_interval') {
    operation.params = newDef.defaultParams;
  } else if (operation.params[0] === '$__interval' && newDef.defaultParams[0] !== '$__interval') {
    operation.params = newDef.defaultParams;
  }

  return operation;
}

function operationWithRangeVectorRenderer(model, def, innerExpr) {
  var _, _model$params;

  let rangeVector = (_ = ((_model$params = model.params) !== null && _model$params !== void 0 ? _model$params : [])[0]) !== null && _ !== void 0 ? _ : '5m';
  return `${def.id}(${innerExpr}[${rangeVector}])`;
}
/**
 * Since there can only be one operation with range vector this will replace the current one (if one was added )
 */

function addOperationWithRangeVector(def, query, modeller) {
  const newOperation = {
    id: def.id,
    params: def.defaultParams
  };

  if (query.operations.length > 0) {
    // If operation exists it has to be in the registry so no point to check if it was found
    const firstOp = modeller.getOperationDef(query.operations[0].id);

    if (firstOp.addOperationHandler === addOperationWithRangeVector) {
      return Object.assign({}, query, {
        operations: [newOperation, ...query.operations.slice(1)]
      });
    }
  }

  return Object.assign({}, query, {
    operations: [newOperation, ...query.operations]
  });
}

function addNestedQueryHandler(def, query) {
  var _query$binaryQueries;

  return Object.assign({}, query, {
    binaryQueries: [...((_query$binaryQueries = query.binaryQueries) !== null && _query$binaryQueries !== void 0 ? _query$binaryQueries : []), {
      operator: '/',
      query
    }]
  });
}

function labelJoinRenderer(model, def, innerExpr) {
  if (typeof model.params[1] !== 'string') {
    throw 'The separator must be a string';
  }

  const separator = `"${model.params[1]}"`;
  return `${model.id}(${innerExpr}, "${model.params[0]}", ${separator}, "${model.params.slice(2).join(separator)}")`;
}

function labelJoinAddOperationHandler(def, query) {
  const newOperation = {
    id: def.id,
    params: def.defaultParams
  };
  return Object.assign({}, query, {
    operations: [...query.operations, newOperation]
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/parsing.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "buildVisualQueryFromString": () => (/* binding */ buildVisualQueryFromString),
/* harmony export */   "handleExpression": () => (/* binding */ handleExpression)
/* harmony export */ });
/* harmony import */ var lezer_promql__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/lezer-promql-virtual-eaf88aa77a/0/cache/lezer-promql-npm-0.22.0-867da6afaa-cdce054700.zip/node_modules/lezer-promql/index.es.js");
/* harmony import */ var _binaryScalarOperations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/binaryScalarOperations.ts");
/* harmony import */ var _shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/parsingUtils.ts");




/**
 * Parses a PromQL query into a visual query model.
 *
 * It traverses the tree and uses sort of state machine to update the query model. The query model is modified
 * during the traversal and sent to each handler as context.
 *
 * @param expr
 */
function buildVisualQueryFromString(expr) {
  const replacedExpr = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.replaceVariables)(expr);
  const tree = lezer_promql__WEBPACK_IMPORTED_MODULE_0__.parser.parse(replacedExpr);
  const node = tree.topNode; // This will be modified in the handlers.

  const visQuery = {
    metric: '',
    labels: [],
    operations: []
  };
  const context = {
    query: visQuery,
    errors: []
  };

  try {
    handleExpression(replacedExpr, node, context);
  } catch (err) {
    // Not ideal to log it here, but otherwise we would lose the stack trace.
    console.error(err);
    context.errors.push({
      text: err.message
    });
  } // If we have empty query, we want to reset errors


  if (isEmptyQuery(context.query)) {
    context.errors = [];
  }

  return context;
}

/**
 * Handler for default state. It will traverse the tree and call the appropriate handler for each node. The node
 * handled here does not necessarily need to be of type == Expr.
 * @param expr
 * @param node
 * @param context
 */
function handleExpression(expr, node, context) {
  const visQuery = context.query;

  switch (node.name) {
    case 'MetricIdentifier':
      {
        // Expectation is that there is only one of those per query.
        visQuery.metric = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, node);
        break;
      }

    case 'LabelMatcher':
      {
        // Same as MetricIdentifier should be just one per query.
        visQuery.labels.push(getLabel(expr, node));
        const err = node.getChild(_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.ErrorName);

        if (err) {
          context.errors.push((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.makeError)(expr, err));
        }

        break;
      }

    case 'FunctionCall':
      {
        handleFunction(expr, node, context);
        break;
      }

    case 'AggregateExpr':
      {
        handleAggregation(expr, node, context);
        break;
      }

    case 'BinaryExpr':
      {
        handleBinary(expr, node, context);
        break;
      }

    case _shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.ErrorName:
      {
        if (isIntervalVariableError(node)) {
          break;
        }

        context.errors.push((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.makeError)(expr, node));
        break;
      }

    default:
      {
        if (node.name === 'ParenExpr') {
          // We don't support parenthesis in the query to group expressions. We just report error but go on with the
          // parsing.
          context.errors.push((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.makeError)(expr, node));
        } // Any other nodes we just ignore and go to it's children. This should be fine as there are lot's of wrapper
        // nodes that can be skipped.
        // TODO: there are probably cases where we will just skip nodes we don't support and we should be able to
        //  detect those and report back.


        let child = node.firstChild;

        while (child) {
          handleExpression(expr, child, context);
          child = child.nextSibling;
        }
      }
  }
}

function isIntervalVariableError(node) {
  var _node$prevSibling, _node$prevSibling2, _node$prevSibling2$fi;

  return ((_node$prevSibling = node.prevSibling) === null || _node$prevSibling === void 0 ? void 0 : _node$prevSibling.name) === 'Expr' && ((_node$prevSibling2 = node.prevSibling) === null || _node$prevSibling2 === void 0 ? void 0 : (_node$prevSibling2$fi = _node$prevSibling2.firstChild) === null || _node$prevSibling2$fi === void 0 ? void 0 : _node$prevSibling2$fi.name) === 'VectorSelector';
}

function getLabel(expr, node) {
  const label = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, node.getChild('LabelName'));
  const op = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, node.getChild('MatchOp'));
  const value = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, node.getChild('StringLiteral')).replace(/"/g, '');
  return {
    label,
    op,
    value
  };
}

const rangeFunctions = ['changes', 'rate', 'irate', 'increase', 'delta'];
/**
 * Handle function call which is usually and identifier and its body > arguments.
 * @param expr
 * @param node
 * @param context
 */

function handleFunction(expr, node, context) {
  const visQuery = context.query;
  const nameNode = node.getChild('FunctionIdentifier');
  const funcName = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, nameNode);
  const body = node.getChild('FunctionCallBody');
  const callArgs = body.getChild('FunctionCallArgs');
  const params = [];
  let interval = ''; // This is a bit of a shortcut to get the interval argument. Reasons are
  // - interval is not part of the function args per promQL grammar but we model it as argument for the function in
  //   the query model.
  // - it is easier to handle template variables this way as template variable is an error for the parser

  if (rangeFunctions.includes(funcName) || funcName.endsWith('_over_time')) {
    let match = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, node).match(/\[(.+)\]/);

    if (match !== null && match !== void 0 && match[1]) {
      interval = match[1];
      params.push(match[1]);
    }
  }

  const op = {
    id: funcName,
    params
  }; // We unshift operations to keep the more natural order that we want to have in the visual query editor.

  visQuery.operations.unshift(op);

  if (callArgs) {
    if ((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, callArgs) === interval + ']') {
      // This is a special case where we have a function with a single argument and it is the interval.
      // This happens when you start adding operations in query builder and did not set a metric yet.
      return;
    }

    updateFunctionArgs(expr, callArgs, context, op);
  }
}
/**
 * Handle aggregation as they are distinct type from other functions.
 * @param expr
 * @param node
 * @param context
 */


function handleAggregation(expr, node, context) {
  const visQuery = context.query;
  const nameNode = node.getChild('AggregateOp');
  let funcName = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, nameNode);
  const modifier = node.getChild('AggregateModifier');
  const labels = [];

  if (modifier) {
    const byModifier = modifier.getChild(`By`);

    if (byModifier && funcName) {
      funcName = `__${funcName}_by`;
    }

    const withoutModifier = modifier.getChild(`Without`);

    if (withoutModifier) {
      funcName = `__${funcName}_without`;
    }

    labels.push(...(0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getAllByType)(expr, modifier, 'GroupingLabel'));
  }

  const body = node.getChild('FunctionCallBody');
  const callArgs = body.getChild('FunctionCallArgs');
  const op = {
    id: funcName,
    params: []
  };
  visQuery.operations.unshift(op);
  updateFunctionArgs(expr, callArgs, context, op); // We add labels after params in the visual query editor.

  op.params.push(...labels);
}
/**
 * Handle (probably) all types of arguments that function or aggregation can have.
 *
 *  FunctionCallArgs are nested bit weirdly basically its [firstArg, ...rest] where rest is again FunctionCallArgs so
 *  we cannot just get all the children and iterate them as arguments we have to again recursively traverse through
 *  them.
 *
 * @param expr
 * @param node
 * @param context
 * @param op - We need the operation to add the params to as an additional context.
 */


function updateFunctionArgs(expr, node, context, op) {
  if (!node) {
    return;
  }

  switch (node.name) {
    // In case we have an expression we don't know what kind so we have to look at the child as it can be anything.
    case 'Expr': // FunctionCallArgs are nested bit weirdly as mentioned so we have to go one deeper in this case.

    case 'FunctionCallArgs':
      {
        let child = node.firstChild;

        while (child) {
          updateFunctionArgs(expr, child, context, op);
          child = child.nextSibling;
        }

        break;
      }

    case 'NumberLiteral':
      {
        op.params.push(parseFloat((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, node)));
        break;
      }

    case 'StringLiteral':
      {
        op.params.push((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, node).replace(/"/g, ''));
        break;
      }

    default:
      {
        // Means we get to something that does not seem like simple function arg and is probably nested query so jump
        // back to main context
        handleExpression(expr, node, context);
      }
  }
}
/**
 * Right now binary expressions can be represented in 2 way in visual query. As additional operation in case it is
 * just operation with scalar or it creates a binaryQuery when it's 2 queries.
 * @param expr
 * @param node
 * @param context
 */


function handleBinary(expr, node, context) {
  const visQuery = context.query;
  const left = node.firstChild;
  const op = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, left.nextSibling);
  const binModifier = getBinaryModifier(expr, node.getChild('BinModifiers'));
  const right = node.lastChild;
  const opDef = _binaryScalarOperations__WEBPACK_IMPORTED_MODULE_1__.binaryScalarOperatorToOperatorName[op];
  const leftNumber = left.getChild('NumberLiteral');
  const rightNumber = right.getChild('NumberLiteral');
  const rightBinary = right.getChild('BinaryExpr');

  if (leftNumber) {// TODO: this should be already handled in case parent is binary expression as it has to be added to parent
    //  if query starts with a number that isn't handled now.
  } else {
    // If this is binary we don't really know if there is a query or just chained scalars. So
    // we have to traverse a bit deeper to know
    handleExpression(expr, left, context);
  }

  if (rightNumber) {
    visQuery.operations.push((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.makeBinOp)(opDef, expr, right, !!(binModifier !== null && binModifier !== void 0 && binModifier.isBool)));
  } else if (rightBinary) {
    // Due to the way binary ops are parsed we can get a binary operation on the right that starts with a number which
    // is a factor for a current binary operation. So we have to add it as an operation now.
    const leftMostChild = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getLeftMostChild)(right);

    if ((leftMostChild === null || leftMostChild === void 0 ? void 0 : leftMostChild.name) === 'NumberLiteral') {
      visQuery.operations.push((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.makeBinOp)(opDef, expr, leftMostChild, !!(binModifier !== null && binModifier !== void 0 && binModifier.isBool)));
    } // If we added the first number literal as operation here we still can continue and handle the rest as the first
    // number will be just skipped.


    handleExpression(expr, right, context);
  } else {
    visQuery.binaryQueries = visQuery.binaryQueries || [];
    const binQuery = {
      operator: op,
      query: {
        metric: '',
        labels: [],
        operations: []
      }
    };

    if (binModifier !== null && binModifier !== void 0 && binModifier.isMatcher) {
      binQuery.vectorMatchesType = binModifier.matchType;
      binQuery.vectorMatches = binModifier.matches;
    }

    visQuery.binaryQueries.push(binQuery);
    handleExpression(expr, right, {
      query: binQuery.query,
      errors: context.errors
    });
  }
}

function getBinaryModifier(expr, node) {
  if (!node) {
    return undefined;
  }

  if (node.getChild('Bool')) {
    return {
      isBool: true,
      isMatcher: false
    };
  } else {
    var _matcher$getChild;

    const matcher = node.getChild('OnOrIgnoring');

    if (!matcher) {
      // Not sure what this could be, maybe should be an error.
      return undefined;
    }

    const labels = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, (_matcher$getChild = matcher.getChild('GroupingLabels')) === null || _matcher$getChild === void 0 ? void 0 : _matcher$getChild.getChild('GroupingLabelList'));
    return {
      isMatcher: true,
      isBool: false,
      matches: labels,
      matchType: matcher.getChild('On') ? 'on' : 'ignoring'
    };
  }
}

function isEmptyQuery(query) {
  if (query.labels.length === 0 && query.operations.length === 0 && !query.metric) {
    return true;
  }

  return false;
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/AutoSizeInput.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AutoSizeInput": () => (/* binding */ AutoSizeInput)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
const _excluded = ["defaultValue", "minWidth", "maxWidth", "onCommitChange", "onKeyDown", "onBlur"];

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }




const AutoSizeInput = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref) => {
  const {
    defaultValue = '',
    minWidth = 10,
    maxWidth,
    onCommitChange,
    onKeyDown,
    onBlur
  } = props,
        restProps = _objectWithoutPropertiesLoose(props, _excluded);

  const [value, setValue] = react__WEBPACK_IMPORTED_MODULE_0__.useState(defaultValue);
  const [inputWidth, setInputWidth] = react__WEBPACK_IMPORTED_MODULE_0__.useState(minWidth);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    setInputWidth(getWidthFor(value.toString(), minWidth, maxWidth));
  }, [value, maxWidth, minWidth]);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Input, Object.assign({}, restProps, {
    ref: ref,
    value: value.toString(),
    onChange: event => {
      setValue(event.currentTarget.value);
    },
    width: inputWidth,
    onBlur: event => {
      if (onCommitChange) {
        onCommitChange(event);
      }

      if (onBlur) {
        onBlur(event);
      }
    },
    onKeyDown: event => {
      if (event.key === 'Enter' && onCommitChange) {
        onCommitChange(event);
      }

      if (onKeyDown) {
        onKeyDown(event);
      }
    },
    "data-testid": 'autosize-input'
  }));
});

function getWidthFor(value, minWidth, maxWidth) {
  if (!value) {
    return minWidth;
  }

  const extraSpace = 3;
  const realWidth = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.measureText)(value.toString(), 14).width / 8 + extraSpace;

  if (minWidth && realWidth < minWidth) {
    return minWidth;
  }

  if (maxWidth && realWidth > maxWidth) {
    return realWidth;
  }

  return realWidth;
}

AutoSizeInput.displayName = 'AutoSizeInput';

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/FeedbackLink.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FeedbackLink": () => (/* binding */ FeedbackLink)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-22e4fdfd25/0/cache/@grafana-experimental-npm-0.0.2-canary.30-71a280d204-b5b453b937.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _Icon;








function FeedbackLink({
  feedbackUrl
}) {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.useStyles2)(getStyles);

  if (!_grafana_runtime__WEBPACK_IMPORTED_MODULE_3__.config.feedbackLinksEnabled) {
    return null;
  }

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.Stack, {
    gap: 1,
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("a", {
      href: feedbackUrl,
      className: styles.link,
      title: "This query builder is new, please let us know how we can improve it",
      target: "_blank",
      rel: "noreferrer noopener",
      children: [_Icon || (_Icon = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Icon, {
        name: "comment-alt-message"
      })), " Give feedback"]
    })
  });
}

function getStyles(theme) {
  return {
    link: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      color: theme.colors.text.secondary,
      fontSize: theme.typography.bodySmall.fontSize,
      ':hover': {
        color: theme.colors.text.link
      }
    })
  };
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/LabelFilterItem.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LabelFilterItem": () => (/* binding */ LabelFilterItem)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-22e4fdfd25/0/cache/@grafana-experimental-npm-0.0.2-canary.30-71a280d204-b5b453b937.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");






function LabelFilterItem({
  item,
  defaultOp,
  onChange,
  onDelete,
  onGetLabelNames,
  onGetLabelValues
}) {
  var _item$op2;

  const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});

  const isMultiSelect = () => {
    return item.op === operators[0].label;
  };

  const getSelectOptionsFromString = item => {
    if (item) {
      if (item.indexOf('|') > 0) {
        return item.split('|');
      }

      return [item];
    }

    return [];
  };

  const getOptions = () => {
    var _state$labelValues;

    return [...getSelectOptionsFromString(item === null || item === void 0 ? void 0 : item.value).map(_grafana_data__WEBPACK_IMPORTED_MODULE_1__.toOption), ...((_state$labelValues = state.labelValues) !== null && _state$labelValues !== void 0 ? _state$labelValues : [])];
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
    "data-testid": "prometheus-dimensions-filter-item",
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.InputGroup, {
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Select, {
        inputId: "prometheus-dimensions-filter-item-key",
        width: "auto",
        value: item.label ? (0,_grafana_data__WEBPACK_IMPORTED_MODULE_1__.toOption)(item.label) : null,
        allowCustomValue: true,
        onOpenMenu: async () => {
          setState({
            isLoadingLabelNames: true
          });
          const labelNames = await onGetLabelNames(item);
          setState({
            labelNames,
            isLoadingLabelNames: undefined
          });
        },
        isLoading: state.isLoadingLabelNames,
        options: state.labelNames,
        onChange: change => {
          if (change.label) {
            var _item$op;

            onChange(Object.assign({}, item, {
              op: (_item$op = item.op) !== null && _item$op !== void 0 ? _item$op : defaultOp,
              label: change.label
            }));
          }
        }
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Select, {
        value: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_1__.toOption)((_item$op2 = item.op) !== null && _item$op2 !== void 0 ? _item$op2 : defaultOp),
        options: operators,
        width: "auto",
        onChange: change => {
          if (change.value != null) {
            onChange(Object.assign({}, item, {
              op: change.value
            }));
          }
        }
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Select, {
        inputId: "prometheus-dimensions-filter-item-value",
        width: "auto",
        value: isMultiSelect() ? getSelectOptionsFromString(item === null || item === void 0 ? void 0 : item.value).map(_grafana_data__WEBPACK_IMPORTED_MODULE_1__.toOption) : getSelectOptionsFromString(item === null || item === void 0 ? void 0 : item.value).map(_grafana_data__WEBPACK_IMPORTED_MODULE_1__.toOption)[0],
        allowCustomValue: true,
        onOpenMenu: async () => {
          setState({
            isLoadingLabelValues: true
          });
          const labelValues = await onGetLabelValues(item);
          setState(Object.assign({}, state, {
            labelValues,
            isLoadingLabelValues: undefined
          }));
        },
        isMulti: isMultiSelect(),
        isLoading: state.isLoadingLabelValues,
        options: getOptions(),
        onChange: change => {
          if (change.value) {
            var _item$op3;

            onChange(Object.assign({}, item, {
              value: change.value,
              op: (_item$op3 = item.op) !== null && _item$op3 !== void 0 ? _item$op3 : defaultOp
            }));
          } else {
            var _item$op4;

            const changes = change.map(change => {
              return change.label;
            }).join('|');
            onChange(Object.assign({}, item, {
              value: changes,
              op: (_item$op4 = item.op) !== null && _item$op4 !== void 0 ? _item$op4 : defaultOp
            }));
          }
        }
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.AccessoryButton, {
        "aria-label": "remove",
        icon: "times",
        variant: "secondary",
        onClick: onDelete
      })]
    })
  });
}
const operators = [{
  label: '=~',
  value: '=~'
}, {
  label: '=',
  value: '='
}, {
  label: '!=',
  value: '!='
}, {
  label: '!~',
  value: '!~'
}];

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/LabelFilters.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LabelFilters": () => (/* binding */ LabelFilters)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-22e4fdfd25/0/cache/@grafana-experimental-npm-0.0.2-canary.30-71a280d204-b5b453b937.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _LabelFilterItem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/LabelFilterItem.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");





function LabelFilters({
  labelsFilters,
  onChange,
  onGetLabelNames,
  onGetLabelValues,
  error
}) {
  const defaultOp = '=';
  const [items, setItems] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([{
    op: defaultOp
  }]);
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
    if (labelsFilters.length > 0) {
      setItems(labelsFilters);
    } else {
      setItems([{
        op: defaultOp
      }]);
    }
  }, [labelsFilters]);

  const onLabelsChange = newItems => {
    setItems(newItems); // Extract full label filters with both label & value

    const newLabels = newItems.filter(x => x.label != null && x.value != null);

    if (!(0,lodash__WEBPACK_IMPORTED_MODULE_0__.isEqual)(newLabels, labelsFilters)) {
      onChange(newLabels);
    }
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.EditorFieldGroup, {
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.EditorField, {
      label: "Labels",
      error: error,
      invalid: !!error,
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.EditorList, {
        items: items,
        onChange: onLabelsChange,
        renderItem: (item, onChangeItem, onDelete) => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_LabelFilterItem__WEBPACK_IMPORTED_MODULE_3__.LabelFilterItem, {
          item: item,
          defaultOp: defaultOp,
          onChange: onChangeItem,
          onDelete: onDelete,
          onGetLabelNames: onGetLabelNames,
          onGetLabelValues: onGetLabelValues
        })
      })
    })
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/LokiAndPromQueryModellerBase.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiAndPromQueryModellerBase": () => (/* binding */ LokiAndPromQueryModellerBase)
/* harmony export */ });
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/types.ts");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



class LokiAndPromQueryModellerBase {
  constructor(getOperations) {
    _defineProperty(this, "operationsRegisty", void 0);

    _defineProperty(this, "categories", []);

    this.operationsRegisty = new _grafana_data__WEBPACK_IMPORTED_MODULE_0__.Registry(getOperations);
  }

  setOperationCategories(categories) {
    this.categories = categories;
  }

  getOperationsForCategory(category) {
    return this.operationsRegisty.list().filter(op => op.category === category && !op.hideFromList);
  }

  getAlternativeOperations(key) {
    return this.operationsRegisty.list().filter(op => op.alternativesKey === key);
  }

  getCategories() {
    return this.categories;
  }

  getOperationDef(id) {
    return this.operationsRegisty.getIfExists(id);
  }

  renderOperations(queryString, operations) {
    for (const operation of operations) {
      const def = this.operationsRegisty.getIfExists(operation.id);

      if (!def) {
        throw new Error(`Could not find operation ${operation.id} in the registry`);
      }

      queryString = def.renderer(operation, def, queryString);
    }

    return queryString;
  }

  renderBinaryQueries(queryString, binaryQueries) {
    if (binaryQueries) {
      for (const binQuery of binaryQueries) {
        queryString = `${this.renderBinaryQuery(queryString, binQuery)}`;
      }
    }

    return queryString;
  }

  renderBinaryQuery(leftOperand, binaryQuery) {
    let result = leftOperand + ` ${binaryQuery.operator} `;

    if (binaryQuery.vectorMatches) {
      result += `${binaryQuery.vectorMatchesType}(${binaryQuery.vectorMatches}) `;
    }

    return result + this.renderQuery(binaryQuery.query, true);
  }

  renderLabels(labels) {
    if (labels.length === 0) {
      return '';
    }

    let expr = '{';

    for (const filter of labels) {
      if (expr !== '{') {
        expr += ', ';
      }

      expr += `${filter.label}${filter.op}"${filter.value}"`;
    }

    return expr + `}`;
  }

  renderQuery(query, nested) {
    var _query$metric, _query$binaryQueries, _query$binaryQueries2;

    let queryString = `${(_query$metric = query.metric) !== null && _query$metric !== void 0 ? _query$metric : ''}${this.renderLabels(query.labels)}`;
    queryString = this.renderOperations(queryString, query.operations);

    if (!nested && this.hasBinaryOp(query) && Boolean((_query$binaryQueries = query.binaryQueries) === null || _query$binaryQueries === void 0 ? void 0 : _query$binaryQueries.length)) {
      queryString = `(${queryString})`;
    }

    queryString = this.renderBinaryQueries(queryString, query.binaryQueries);

    if (nested && (this.hasBinaryOp(query) || Boolean((_query$binaryQueries2 = query.binaryQueries) === null || _query$binaryQueries2 === void 0 ? void 0 : _query$binaryQueries2.length))) {
      queryString = `(${queryString})`;
    }

    return queryString;
  }

  hasBinaryOp(query) {
    return query.operations.find(op => {
      const def = this.getOperationDef(op.id);
      return (def === null || def === void 0 ? void 0 : def.category) === _types__WEBPACK_IMPORTED_MODULE_1__.PromVisualQueryOperationCategory.BinaryOps;
    }) !== undefined;
  }

}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationEditor": () => (/* binding */ OperationEditor)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./.yarn/__virtual__/react-beautiful-dnd-virtual-27e4b658e7/0/cache/react-beautiful-dnd-npm-13.1.0-fcf5568b1c-12b7e9fbe8.zip/node_modules/react-beautiful-dnd/dist/react-beautiful-dnd.esm.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-22e4fdfd25/0/cache/@grafana-experimental-npm-0.0.2-canary.30-71a280d204-b5b453b937.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _OperationHeader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationHeader.tsx");
/* harmony import */ var _OperationParamEditor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationParamEditor.tsx");
/* harmony import */ var _operationUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");










function OperationEditor({
  operation,
  index,
  onRemove,
  onChange,
  onRunQuery,
  queryModeller,
  query,
  datasource,
  highlight
}) {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.useStyles2)(getStyles);
  const def = queryModeller.getOperationDef(operation.id);
  const shouldHighlight = useHighlight(highlight);

  if (!def) {
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("span", {
      children: ["Operation ", operation.id, " not found"]
    });
  }

  const onParamValueChanged = (paramIdx, value) => {
    const update = Object.assign({}, operation, {
      params: [...operation.params]
    });
    update.params[paramIdx] = value;
    callParamChangedThenOnChange(def, update, index, paramIdx, onChange);
  };

  const onAddRestParam = () => {
    const update = Object.assign({}, operation, {
      params: [...operation.params, '']
    });
    callParamChangedThenOnChange(def, update, index, operation.params.length, onChange);
  };

  const onRemoveRestParam = paramIdx => {
    const update = Object.assign({}, operation, {
      params: [...operation.params.slice(0, paramIdx), ...operation.params.slice(paramIdx + 1)]
    });
    callParamChangedThenOnChange(def, update, index, paramIdx, onChange);
  };

  const operationElements = [];

  for (let paramIndex = 0; paramIndex < operation.params.length; paramIndex++) {
    const paramDef = def.params[Math.min(def.params.length - 1, paramIndex)];
    const Editor = (0,_OperationParamEditor__WEBPACK_IMPORTED_MODULE_5__.getOperationParamEditor)(paramDef);
    operationElements.push( /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
      className: styles.paramRow,
      children: [!paramDef.hideName && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
        className: styles.paramName,
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("label", {
          htmlFor: (0,_operationUtils__WEBPACK_IMPORTED_MODULE_6__.getOperationParamId)(index, paramIndex),
          children: paramDef.name
        }), paramDef.description && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Tooltip, {
          placement: "top",
          content: paramDef.description,
          theme: "info",
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Icon, {
            name: "info-circle",
            size: "sm",
            className: styles.infoIcon
          })
        })]
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
        className: styles.paramValue,
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.Stack, {
          gap: 0.5,
          direction: "row",
          alignItems: "center",
          wrap: false,
          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(Editor, {
            index: paramIndex,
            paramDef: paramDef,
            value: operation.params[paramIndex],
            operation: operation,
            operationIndex: index,
            onChange: onParamValueChanged,
            onRunQuery: onRunQuery,
            query: query,
            datasource: datasource
          }), paramDef.restParam && (operation.params.length > def.params.length || paramDef.optional) && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
            "data-testid": `operations.${index}.remove-rest-param`,
            size: "sm",
            fill: "text",
            icon: "times",
            variant: "secondary",
            title: `Remove ${paramDef.name}`,
            onClick: () => onRemoveRestParam(paramIndex)
          })]
        })
      })]
    }, `${paramIndex}-1`));
  } // Handle adding button for rest params


  let restParam;

  if (def.params.length > 0) {
    const lastParamDef = def.params[def.params.length - 1];

    if (lastParamDef.restParam) {
      restParam = renderAddRestParamButton(lastParamDef, onAddRestParam, index, operation.params.length, styles);
    }
  }

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_8__.Draggable, {
    draggableId: `operation-${index}`,
    index: index,
    children: provided => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", Object.assign({
      className: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.cx)(styles.card, shouldHighlight && styles.cardHighlight),
      ref: provided.innerRef
    }, provided.draggableProps, {
      "data-testid": `operations.${index}.wrapper`,
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_OperationHeader__WEBPACK_IMPORTED_MODULE_4__.OperationHeader, {
        operation: operation,
        dragHandleProps: provided.dragHandleProps,
        def: def,
        index: index,
        onChange: onChange,
        onRemove: onRemove,
        queryModeller: queryModeller
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
        className: styles.body,
        children: operationElements
      }), restParam, index < query.operations.length - 1 && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
        className: styles.arrow,
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
          className: styles.arrowLine
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
          className: styles.arrowArrow
        })]
      })]
    }))
  });
}
/**
 * When highlight is switched on makes sure it is switched of right away, so we just flash the highlight and then fade
 * out.
 * @param highlight
 */

function useHighlight(highlight) {
  const [keepHighlight, setKeepHighlight] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
    let t;

    if (highlight) {
      t = setTimeout(() => {
        setKeepHighlight(false);
      }, 1);
    } else {
      setKeepHighlight(true);
    }

    return () => clearTimeout(t);
  }, [highlight]);
  return keepHighlight && highlight;
}

function renderAddRestParamButton(paramDef, onAddRestParam, operationIndex, paramIndex, styles) {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
    className: styles.restParam,
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
      size: "sm",
      icon: "plus",
      title: `Add ${paramDef.name}`,
      variant: "secondary",
      onClick: onAddRestParam,
      "data-testid": `operations.${operationIndex}.add-rest-param`,
      children: paramDef.name
    })
  }, `${paramIndex}-2`);
}

function callParamChangedThenOnChange(def, operation, operationIndex, paramIndex, onChange) {
  if (def.paramChangedHandler) {
    onChange(operationIndex, def.paramChangedHandler(paramIndex, operation, def));
  } else {
    onChange(operationIndex, operation);
  }
}

const getStyles = theme => {
  return {
    card: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      background: theme.colors.background.primary,
      border: `1px solid ${theme.colors.border.medium}`,
      display: 'flex',
      flexDirection: 'column',
      cursor: 'grab',
      borderRadius: theme.shape.borderRadius(1),
      marginBottom: theme.spacing(1),
      position: 'relative',
      transition: 'all 1s ease-in 0s'
    }),
    cardHighlight: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      boxShadow: `0px 0px 4px 0px ${theme.colors.primary.border}`,
      border: `1px solid ${theme.colors.primary.border}`
    }),
    infoIcon: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      marginLeft: theme.spacing(0.5),
      color: theme.colors.text.secondary,
      ':hover': {
        color: theme.colors.text.primary
      }
    }),
    body: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      margin: theme.spacing(1, 1, 0.5, 1),
      display: 'table'
    }),
    paramRow: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'paramRow',
      display: 'table-row',
      verticalAlign: 'middle'
    }),
    paramName: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      display: 'table-cell',
      padding: theme.spacing(0, 1, 0, 0),
      fontSize: theme.typography.bodySmall.fontSize,
      fontWeight: theme.typography.fontWeightMedium,
      verticalAlign: 'middle',
      height: '32px'
    }),
    paramValue: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'paramValue',
      display: 'table-cell',
      verticalAlign: 'middle'
    }),
    restParam: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      padding: theme.spacing(0, 1, 1, 1)
    }),
    arrow: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      position: 'absolute',
      top: '0',
      right: '-18px',
      display: 'flex'
    }),
    arrowLine: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      height: '2px',
      width: '8px',
      backgroundColor: theme.colors.border.strong,
      position: 'relative',
      top: '14px'
    }),
    arrowArrow: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      width: 0,
      height: 0,
      borderTop: `5px solid transparent`,
      borderBottom: `5px solid transparent`,
      borderLeft: `7px solid ${theme.colors.border.strong}`,
      position: 'relative',
      top: '10px'
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationExplainedBox.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationExplainedBox": () => (/* binding */ OperationExplainedBox)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");






function OperationExplainedBox({
  title,
  stepNumber,
  markdown,
  children
}) {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.useStyles2)(getStyles);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
    className: styles.box,
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
      className: styles.stepNumber,
      children: stepNumber
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
      className: styles.boxInner,
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
        className: styles.header,
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("span", {
          children: title
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
        className: styles.body,
        children: [markdown && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
          dangerouslySetInnerHTML: {
            __html: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_2__.renderMarkdown)(markdown)
          }
        }), children]
      })]
    })]
  });
}

const getStyles = theme => {
  return {
    box: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      background: theme.colors.background.secondary,
      padding: theme.spacing(1),
      borderRadius: theme.shape.borderRadius(),
      position: 'relative',
      marginBottom: theme.spacing(0.5)
    }),
    boxInner: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      marginLeft: theme.spacing(4)
    }),
    stepNumber: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      fontWeight: theme.typography.fontWeightMedium,
      background: theme.colors.secondary.main,
      width: '20px',
      height: '20px',
      borderRadius: '50%',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      position: 'absolute',
      top: '10px',
      left: '11px',
      fontSize: theme.typography.bodySmall.fontSize
    }),
    header: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      paddingBottom: theme.spacing(0.5),
      display: 'flex',
      alignItems: 'center',
      fontFamily: theme.typography.fontFamilyMonospace
    }),
    body: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      color: theme.colors.text.secondary,
      'p:last-child': {
        margin: 0
      },
      a: {
        color: theme.colors.text.link,
        textDecoration: 'underline'
      }
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationHeader.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationHeader": () => (/* binding */ OperationHeader)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-22e4fdfd25/0/cache/@grafana-experimental-npm-0.0.2-canary.30-71a280d204-b5b453b937.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _OperationInfoButton__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationInfoButton.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _FlexItem;









const OperationHeader = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.memo(({
  operation,
  def,
  index,
  onChange,
  onRemove,
  queryModeller,
  dragHandleProps
}) => {
  var _def$name;

  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.useStyles2)(getStyles);
  const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});

  const onToggleSwitcher = () => {
    if (state.isOpen) {
      setState(Object.assign({}, state, {
        isOpen: false
      }));
    } else {
      const alternatives = queryModeller.getAlternativeOperations(def.alternativesKey).map(alt => ({
        label: alt.name,
        value: alt
      }));
      setState({
        isOpen: true,
        alternatives
      });
    }
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
    className: styles.header,
    children: [!state.isOpen && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", Object.assign({}, dragHandleProps, {
        children: (_def$name = def.name) !== null && _def$name !== void 0 ? _def$name : def.id
      })), _FlexItem || (_FlexItem = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.FlexItem, {
        grow: 1
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
        className: `${styles.operationHeaderButtons} operation-header-show-on-hover`,
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
          icon: "angle-down",
          size: "sm",
          onClick: onToggleSwitcher,
          fill: "text",
          variant: "secondary",
          title: "Click to view alternative operations"
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_OperationInfoButton__WEBPACK_IMPORTED_MODULE_4__.OperationInfoButton, {
          def: def,
          operation: operation
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
          icon: "times",
          size: "sm",
          onClick: () => onRemove(index),
          fill: "text",
          variant: "secondary",
          title: "Remove operation"
        })]
      })]
    }), state.isOpen && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
      className: styles.selectWrapper,
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Select, {
        autoFocus: true,
        openMenuOnFocus: true,
        placeholder: "Replace with",
        options: state.alternatives,
        isOpen: true,
        onCloseMenu: onToggleSwitcher,
        onChange: value => {
          if (value.value) {
            // Operation should exist if it is selectable
            const newDef = queryModeller.getOperationDef(value.value.id);
            let changedOp = Object.assign({}, operation, {
              id: value.value.id
            });
            onChange(index, def.changeTypeHandler ? def.changeTypeHandler(changedOp, newDef) : changedOp);
          }
        }
      })
    })]
  });
});
OperationHeader.displayName = 'OperationHeader';

const getStyles = theme => {
  return {
    header: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      borderBottom: `1px solid ${theme.colors.border.medium}`,
      padding: theme.spacing(0.5, 0.5, 0.5, 1),
      display: 'flex',
      alignItems: 'center',
      '&:hover .operation-header-show-on-hover': (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
        opacity: 1
      })
    }),
    operationHeaderButtons: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      opacity: 0,
      transition: theme.transitions.create(['opacity'], {
        duration: theme.transitions.duration.short
      })
    }),
    selectWrapper: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      paddingRight: theme.spacing(2)
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationInfoButton.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationInfoButton": () => (/* binding */ OperationInfoButton)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_popper_tooltip__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/__virtual__/react-popper-tooltip-virtual-d9d7047333/0/cache/react-popper-tooltip-npm-4.3.1-91318ee546-82ae84c3b7.zip/node_modules/react-popper-tooltip/dist/esm/react-popper-tooltip.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-22e4fdfd25/0/cache/@grafana-experimental-npm-0.0.2-canary.30-71a280d204-b5b453b937.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _FlexItem;










const OperationInfoButton = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.memo(({
  def,
  operation
}) => {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.useStyles2)(getStyles);
  const [show, setShow] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);
  const {
    getTooltipProps,
    setTooltipRef,
    setTriggerRef,
    visible
  } = (0,react_popper_tooltip__WEBPACK_IMPORTED_MODULE_6__.usePopperTooltip)({
    placement: 'top',
    visible: show,
    offset: [0, 16],
    onVisibleChange: setShow,
    interactive: true,
    trigger: ['click']
  });
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Button, {
      title: "Click to show description",
      ref: setTriggerRef,
      icon: "info-circle",
      size: "sm",
      variant: "secondary",
      fill: "text"
    }), visible && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Portal, {
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", Object.assign({
        ref: setTooltipRef
      }, getTooltipProps(), {
        className: styles.docBox,
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
          className: styles.docBoxHeader,
          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("span", {
            children: def.renderer(operation, def, '<expr>')
          }), _FlexItem || (_FlexItem = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_3__.FlexItem, {
            grow: 1
          })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Button, {
            icon: "times",
            onClick: () => setShow(false),
            fill: "text",
            variant: "secondary",
            title: "Remove operation"
          })]
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
          className: styles.docBoxBody,
          dangerouslySetInnerHTML: {
            __html: getOperationDocs(def, operation)
          }
        })]
      }))
    })]
  });
});
OperationInfoButton.displayName = 'OperationDocs';

const getStyles = theme => {
  return {
    docBox: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      overflow: 'hidden',
      background: theme.colors.background.primary,
      border: `1px solid ${theme.colors.border.strong}`,
      boxShadow: theme.shadows.z3,
      maxWidth: '600px',
      padding: theme.spacing(1),
      borderRadius: theme.shape.borderRadius(),
      zIndex: theme.zIndex.tooltip
    }),
    docBoxHeader: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      fontSize: theme.typography.h5.fontSize,
      fontFamily: theme.typography.fontFamilyMonospace,
      paddingBottom: theme.spacing(1),
      display: 'flex',
      alignItems: 'center'
    }),
    docBoxBody: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      // The markdown paragraph has a marginBottom this removes it
      marginBottom: theme.spacing(-1),
      color: theme.colors.text.secondary
    }),
    signature: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      fontSize: theme.typography.bodySmall.fontSize,
      fontFamily: theme.typography.fontFamilyMonospace
    }),
    dropdown: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      opacity: 0,
      color: theme.colors.text.secondary
    })
  };
};

function getOperationDocs(def, op) {
  var _def$documentation;

  return (0,_grafana_data__WEBPACK_IMPORTED_MODULE_2__.renderMarkdown)(def.explainHandler ? def.explainHandler(op, def) : (_def$documentation = def.documentation) !== null && _def$documentation !== void 0 ? _def$documentation : 'no docs');
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationList.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationList": () => (/* binding */ OperationList)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/__virtual__/react-beautiful-dnd-virtual-27e4b658e7/0/cache/react-beautiful-dnd-npm-13.1.0-fcf5568b1c-12b7e9fbe8.zip/node_modules/react-beautiful-dnd/dist/react-beautiful-dnd.esm.js");
/* harmony import */ var react_use__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/__virtual__/react-use-virtual-00326e70ba/0/cache/react-use-npm-17.3.2-a032cbeb01-7379460f51.zip/node_modules/react-use/esm/useMountedState.js");
/* harmony import */ var react_use__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./.yarn/__virtual__/react-use-virtual-00326e70ba/0/cache/react-use-npm-17.3.2-a032cbeb01-7379460f51.zip/node_modules/react-use/esm/usePrevious.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-22e4fdfd25/0/cache/@grafana-experimental-npm-0.0.2-canary.30-71a280d204-b5b453b937.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _OperationEditor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationEditor.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");









function OperationList({
  query,
  datasource,
  queryModeller,
  onChange,
  onRunQuery
}) {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.useStyles2)(getStyles);
  const {
    operations
  } = query;
  const opsToHighlight = useOperationsHighlight(operations);
  const [cascaderOpen, setCascaderOpen] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);

  const onOperationChange = (index, update) => {
    const updatedList = [...operations];
    updatedList.splice(index, 1, update);
    onChange(Object.assign({}, query, {
      operations: updatedList
    }));
  };

  const onRemove = index => {
    const updatedList = [...operations.slice(0, index), ...operations.slice(index + 1)];
    onChange(Object.assign({}, query, {
      operations: updatedList
    }));
  };

  const addOptions = queryModeller.getCategories().map(category => {
    return {
      value: category,
      label: category,
      items: queryModeller.getOperationsForCategory(category).map(operation => ({
        value: operation.id,
        label: operation.name,
        isLeaf: true
      }))
    };
  });

  const onAddOperation = value => {
    const operationDef = queryModeller.getOperationDef(value);

    if (!operationDef) {
      return;
    }

    onChange(operationDef.addOperationHandler(operationDef, query, queryModeller));
    setCascaderOpen(false);
  };

  const onDragEnd = result => {
    if (!result.destination) {
      return;
    }

    const updatedList = [...operations];
    const element = updatedList[result.source.index];
    updatedList.splice(result.source.index, 1);
    updatedList.splice(result.destination.index, 0, element);
    onChange(Object.assign({}, query, {
      operations: updatedList
    }));
  };

  const onCascaderBlur = () => {
    setCascaderOpen(false);
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.Stack, {
    gap: 1,
    direction: "column",
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.Stack, {
      gap: 1,
      children: [operations.length > 0 && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_6__.DragDropContext, {
        onDragEnd: onDragEnd,
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_6__.Droppable, {
          droppableId: "sortable-field-mappings",
          direction: "horizontal",
          children: provided => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", Object.assign({
            className: styles.operationList,
            ref: provided.innerRef
          }, provided.droppableProps, {
            children: [operations.map((op, index) => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_OperationEditor__WEBPACK_IMPORTED_MODULE_4__.OperationEditor, {
              queryModeller: queryModeller,
              index: index,
              operation: op,
              query: query,
              datasource: datasource,
              onChange: onOperationChange,
              onRemove: onRemove,
              onRunQuery: onRunQuery,
              highlight: opsToHighlight[index]
            }, op.id + index)), provided.placeholder]
          }))
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
        className: styles.addButton,
        children: cascaderOpen ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Cascader, {
          options: addOptions,
          onSelect: onAddOperation,
          onBlur: onCascaderBlur,
          autoFocus: true,
          alwaysOpen: true,
          hideActiveLevelLabel: true,
          placeholder: 'Search'
        }) : /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
          icon: 'plus',
          variant: 'secondary',
          onClick: () => setCascaderOpen(true),
          title: 'Add operation',
          children: "Operations"
        })
      })]
    })
  });
}
/**
 * Returns indexes of operations that should be highlighted. We check the diff of operations added but at the same time
 * we want to highlight operations only after the initial render, so we check for mounted state and calculate the diff
 * only after.
 * @param operations
 */

function useOperationsHighlight(operations) {
  const isMounted = (0,react_use__WEBPACK_IMPORTED_MODULE_7__["default"])();
  const prevOperations = (0,react_use__WEBPACK_IMPORTED_MODULE_8__["default"])(operations);

  if (!isMounted()) {
    return operations.map(() => false);
  }

  if (!prevOperations) {
    return operations.map(() => true);
  }

  let newOps = [];

  if (prevOperations.length - 1 === operations.length && operations.every(op => prevOperations.includes(op))) {
    // In case we remove one op and does not change any ops then don't highlight anything.
    return operations.map(() => false);
  }

  if (prevOperations.length + 1 === operations.length && prevOperations.every(op => operations.includes(op))) {
    // If we add a single op just find it and highlight just that.
    const newOp = operations.find(op => !prevOperations.includes(op));
    newOps = operations.map(op => {
      return op === newOp;
    });
  } else {
    // Default diff of all ops.
    newOps = operations.map((op, index) => {
      var _prevOperations$index;

      return !isSameOp(op.id, (_prevOperations$index = prevOperations[index]) === null || _prevOperations$index === void 0 ? void 0 : _prevOperations$index.id);
    });
  }

  return newOps;
}

function isSameOp(op1, op2) {
  return op1 === op2 || `__${op1}_by` === op2 || op1 === `__${op2}_by`;
}

const getStyles = theme => {
  return {
    heading: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'heading',
      fontSize: 12,
      fontWeight: theme.typography.fontWeightMedium,
      marginBottom: 0
    }),
    operationList: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'operationList',
      display: 'flex',
      flexWrap: 'wrap',
      gap: theme.spacing(2)
    }),
    addButton: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'addButton',
      width: 126,
      paddingBottom: theme.spacing(1)
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationListExplained.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationListExplained": () => (/* binding */ OperationListExplained)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _OperationExplainedBox__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationExplainedBox.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");




function OperationListExplained({
  query,
  queryModeller,
  stepNumber
}) {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, {
    children: query.operations.map((op, index) => {
      var _def$documentation;

      const def = queryModeller.getOperationDef(op.id);

      if (!def) {
        return `Operation ${op.id} not found`;
      }

      const title = def.renderer(op, def, '<expr>');
      const body = def.explainHandler ? def.explainHandler(op, def) : (_def$documentation = def.documentation) !== null && _def$documentation !== void 0 ? _def$documentation : 'no docs';
      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_OperationExplainedBox__WEBPACK_IMPORTED_MODULE_1__.OperationExplainedBox, {
        stepNumber: index + stepNumber,
        title: title,
        markdown: body
      }, index);
    })
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationParamEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getOperationParamEditor": () => (/* binding */ getOperationParamEditor)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _AutoSizeInput__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/AutoSizeInput.tsx");
/* harmony import */ var _operationUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");






function getOperationParamEditor(paramDef) {
  if (paramDef.editor) {
    return paramDef.editor;
  }

  if (paramDef.options) {
    return SelectInputParamEditor;
  }

  switch (paramDef.type) {
    case 'boolean':
      return BoolInputParamEditor;

    case 'number':
    case 'string':
    default:
      return SimpleInputParamEditor;
  }
}

function SimpleInputParamEditor(props) {
  var _props$value;

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_AutoSizeInput__WEBPACK_IMPORTED_MODULE_3__.AutoSizeInput, {
    id: (0,_operationUtils__WEBPACK_IMPORTED_MODULE_4__.getOperationParamId)(props.operationIndex, props.index),
    defaultValue: (_props$value = props.value) === null || _props$value === void 0 ? void 0 : _props$value.toString(),
    minWidth: props.paramDef.minWidth,
    placeholder: props.paramDef.placeholder,
    title: props.paramDef.description,
    onCommitChange: evt => {
      props.onChange(props.index, evt.currentTarget.value);
    }
  });
}

function BoolInputParamEditor(props) {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Checkbox, {
    id: (0,_operationUtils__WEBPACK_IMPORTED_MODULE_4__.getOperationParamId)(props.operationIndex, props.index),
    value: props.value,
    onChange: evt => props.onChange(props.index, evt.currentTarget.checked)
  });
}

function SelectInputParamEditor({
  paramDef,
  value,
  index,
  operationIndex,
  onChange
}) {
  var _selectOptions$, _selectOptions$find;

  let selectOptions = paramDef.options;

  if (!((_selectOptions$ = selectOptions[0]) !== null && _selectOptions$ !== void 0 && _selectOptions$.label)) {
    selectOptions = paramDef.options.map(option => ({
      label: option.toString(),
      value: option
    }));
  }

  let valueOption = (_selectOptions$find = selectOptions.find(x => x.value === value)) !== null && _selectOptions$find !== void 0 ? _selectOptions$find : (0,_grafana_data__WEBPACK_IMPORTED_MODULE_1__.toOption)(value);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Select, {
    id: (0,_operationUtils__WEBPACK_IMPORTED_MODULE_4__.getOperationParamId)(operationIndex, index),
    value: valueOption,
    options: selectOptions,
    placeholder: paramDef.placeholder,
    allowCustomValue: true,
    onChange: value => onChange(index, value.value)
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationsEditorRow.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationsEditorRow": () => (/* binding */ OperationsEditorRow)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-22e4fdfd25/0/cache/@grafana-experimental-npm-0.0.2-canary.30-71a280d204-b5b453b937.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");





function OperationsEditorRow({
  children
}) {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.useStyles2)(getStyles);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
    className: styles.root,
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.Stack, {
      gap: 1,
      children: children
    })
  });
}

const getStyles = theme => {
  return {
    root: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      padding: theme.spacing(1, 1, 0, 1),
      backgroundColor: theme.colors.background.secondary,
      borderRadius: theme.shape.borderRadius(1)
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/QueryEditorModeToggle.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "QueryEditorModeToggle": () => (/* binding */ QueryEditorModeToggle)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/types.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");





const editorModes = [{
  label: 'Explain',
  value: _types__WEBPACK_IMPORTED_MODULE_3__.QueryEditorMode.Explain
}, {
  label: 'Builder',
  value: _types__WEBPACK_IMPORTED_MODULE_3__.QueryEditorMode.Builder,
  component: () => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Tag, {
    className: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      fontSize: 10,
      padding: '1px 5px',
      verticalAlign: 'text-bottom'
    }),
    name: 'Beta',
    colorIndex: 1
  })
}, {
  label: 'Code',
  value: _types__WEBPACK_IMPORTED_MODULE_3__.QueryEditorMode.Code
}];
function QueryEditorModeToggle({
  mode,
  onChange
}) {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
    "data-testid": 'QueryEditorModeToggle',
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.RadioButtonGroup, {
      options: editorModes,
      size: "sm",
      value: mode,
      onChange: onChange
    })
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/QueryHeaderSwitch.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "QueryHeaderSwitch": () => (/* binding */ QueryHeaderSwitch)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-22e4fdfd25/0/cache/@grafana-experimental-npm-0.0.2-canary.30-71a280d204-b5b453b937.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
const _excluded = ["label"];

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








function QueryHeaderSwitch(_ref) {
  let {
    label
  } = _ref,
      inputProps = _objectWithoutPropertiesLoose(_ref, _excluded);

  const dashedLabel = label.replace(' ', '-');
  const switchIdRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)((0,lodash__WEBPACK_IMPORTED_MODULE_1__.uniqueId)(`switch-${dashedLabel}`));
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.useStyles2)(getStyles);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_3__.Stack, {
    gap: 1,
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("label", {
      htmlFor: switchIdRef.current,
      className: styles.switchLabel,
      children: label
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Switch, Object.assign({}, inputProps, {
      id: switchIdRef.current
    }))]
  });
}

const getStyles = theme => {
  return {
    switchLabel: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      color: theme.colors.text.secondary,
      cursor: 'pointer',
      fontSize: theme.typography.bodySmall.fontSize,
      '&:hover': {
        color: theme.colors.text.primary
      }
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/QueryOptionGroup.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "QueryOptionGroup": () => (/* binding */ QueryOptionGroup)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_use__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/__virtual__/react-use-virtual-00326e70ba/0/cache/react-use-npm-17.3.2-a032cbeb01-7379460f51.zip/node_modules/react-use/esm/useToggle.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-22e4fdfd25/0/cache/@grafana-experimental-npm-0.0.2-canary.30-71a280d204-b5b453b937.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");







function QueryOptionGroup({
  title,
  children,
  collapsedInfo
}) {
  const [isOpen, toggleOpen] = (0,react_use__WEBPACK_IMPORTED_MODULE_5__["default"])(false);
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.useStyles2)(getStyles);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.Stack, {
    gap: 0,
    direction: "column",
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
      className: styles.header,
      onClick: toggleOpen,
      title: "Click to edit options",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
        className: styles.toggle,
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Icon, {
          name: isOpen ? 'angle-down' : 'angle-right'
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("h6", {
        className: styles.title,
        children: title
      }), !isOpen && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
        className: styles.description,
        children: collapsedInfo.map((x, i) => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("span", {
          children: x
        }, i))
      })]
    }), isOpen && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
      className: styles.body,
      children: children
    })]
  });
}

const getStyles = theme => {
  return {
    switchLabel: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      color: theme.colors.text.secondary,
      cursor: 'pointer',
      fontSize: theme.typography.bodySmall.fontSize,
      '&:hover': {
        color: theme.colors.text.primary
      }
    }),
    header: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      display: 'flex',
      cursor: 'pointer',
      alignItems: 'baseline',
      color: theme.colors.text.primary,
      '&:hover': {
        background: theme.colors.emphasize(theme.colors.background.primary, 0.03)
      }
    }),
    title: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      flexGrow: 1,
      overflow: 'hidden',
      fontSize: theme.typography.bodySmall.fontSize,
      fontWeight: theme.typography.fontWeightMedium,
      margin: 0
    }),
    description: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      color: theme.colors.text.secondary,
      fontSize: theme.typography.bodySmall.fontSize,
      paddingLeft: theme.spacing(2),
      gap: theme.spacing(2),
      display: 'flex'
    }),
    body: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      display: 'flex',
      paddingTop: theme.spacing(2),
      gap: theme.spacing(2),
      flexWrap: 'wrap'
    }),
    toggle: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      color: theme.colors.text.secondary,
      marginRight: `${theme.spacing(1)}`
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createAggregationOperation": () => (/* binding */ createAggregationOperation),
/* harmony export */   "createAggregationOperationWithParam": () => (/* binding */ createAggregationOperationWithParam),
/* harmony export */   "defaultAddOperationHandler": () => (/* binding */ defaultAddOperationHandler),
/* harmony export */   "functionRendererLeft": () => (/* binding */ functionRendererLeft),
/* harmony export */   "functionRendererRight": () => (/* binding */ functionRendererRight),
/* harmony export */   "getOperationParamId": () => (/* binding */ getOperationParamId),
/* harmony export */   "getPromAndLokiOperationDisplayName": () => (/* binding */ getPromAndLokiOperationDisplayName),
/* harmony export */   "getRangeVectorParamDef": () => (/* binding */ getRangeVectorParamDef),
/* harmony export */   "rangeRendererLeftWithParams": () => (/* binding */ rangeRendererLeftWithParams),
/* harmony export */   "rangeRendererRightWithParams": () => (/* binding */ rangeRendererRightWithParams)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var pluralize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/pluralize-npm-8.0.0-f5f044ed52-08931d4a6a.zip/node_modules/pluralize/pluralize.js");
/* harmony import */ var pluralize__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(pluralize__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _components_LabelParamEditor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/LabelParamEditor.tsx");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/types.ts");




function functionRendererLeft(model, def, innerExpr) {
  const params = renderParams(model, def, innerExpr);
  const str = model.id + '(';

  if (innerExpr) {
    params.push(innerExpr);
  }

  return str + params.join(', ') + ')';
}
function functionRendererRight(model, def, innerExpr) {
  const params = renderParams(model, def, innerExpr);
  const str = model.id + '(';

  if (innerExpr) {
    params.unshift(innerExpr);
  }

  return str + params.join(', ') + ')';
}

function rangeRendererWithParams(model, def, innerExpr, renderLeft) {
  var _, _model$params;

  if (def.params.length < 2) {
    throw `Cannot render a function with params of length [${def.params.length}]`;
  }

  let rangeVector = (_ = ((_model$params = model.params) !== null && _model$params !== void 0 ? _model$params : [])[0]) !== null && _ !== void 0 ? _ : '5m'; // Next frame the remaining parameters, but get rid of the first one because it's used to move the
  // instant vector into a range vector.

  const params = renderParams(Object.assign({}, model, {
    params: model.params.slice(1)
  }), Object.assign({}, def, {
    params: def.params.slice(1),
    defaultParams: def.defaultParams.slice(1)
  }), innerExpr);
  const str = model.id + '('; // Depending on the renderLeft variable, render parameters to the left or right
  // renderLeft === true (renderLeft) => (param1, param2, rangeVector[...])
  // renderLeft === false (renderRight) => (rangeVector[...], param1, param2)

  if (innerExpr) {
    renderLeft ? params.push(`${innerExpr}[${rangeVector}]`) : params.unshift(`${innerExpr}[${rangeVector}]`);
  } // stick everything together


  return str + params.join(', ') + ')';
}

function rangeRendererRightWithParams(model, def, innerExpr) {
  return rangeRendererWithParams(model, def, innerExpr, false);
}
function rangeRendererLeftWithParams(model, def, innerExpr) {
  return rangeRendererWithParams(model, def, innerExpr, true);
}

function renderParams(model, def, innerExpr) {
  var _model$params2;

  return ((_model$params2 = model.params) !== null && _model$params2 !== void 0 ? _model$params2 : []).map((value, index) => {
    const paramDef = def.params[index];

    if (paramDef.type === 'string') {
      return '"' + value + '"';
    }

    return value;
  });
}

function defaultAddOperationHandler(def, query) {
  const newOperation = {
    id: def.id,
    params: def.defaultParams
  };
  return Object.assign({}, query, {
    operations: [...query.operations, newOperation]
  });
}
function getPromAndLokiOperationDisplayName(funcName) {
  return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.capitalize)(funcName.replace(/_/g, ' '));
}
function getOperationParamId(operationIndex, paramIndex) {
  return `operations.${operationIndex}.param.${paramIndex}`;
}
function getRangeVectorParamDef(withRateInterval = false) {
  const param = {
    name: 'Range',
    type: 'string',
    options: [{
      label: '$__interval',
      value: '$__interval' // tooltip: 'Dynamic interval based on max data points, scrape and min interval',

    }, {
      label: '1m',
      value: '1m'
    }, {
      label: '5m',
      value: '5m'
    }, {
      label: '10m',
      value: '10m'
    }, {
      label: '1h',
      value: '1h'
    }, {
      label: '24h',
      value: '24h'
    }]
  };

  if (withRateInterval) {
    param.options.unshift({
      label: '$__rate_interval',
      value: '$__rate_interval' // tooltip: 'Always above 4x scrape interval',

    });
  }

  return param;
}
/**
 * This function is shared between Prometheus and Loki variants
 */

function createAggregationOperation(name, overrides = {}) {
  const operations = [Object.assign({
    id: name,
    name: getPromAndLokiOperationDisplayName(name),
    params: [{
      name: 'By label',
      type: 'string',
      restParam: true,
      optional: true
    }],
    defaultParams: [],
    alternativesKey: 'plain aggregations',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Aggregations,
    renderer: functionRendererLeft,
    paramChangedHandler: getOnLabelAddedHandler(`__${name}_by`),
    explainHandler: getAggregationExplainer(name, ''),
    addOperationHandler: defaultAddOperationHandler
  }, overrides), Object.assign({
    id: `__${name}_by`,
    name: `${getPromAndLokiOperationDisplayName(name)} by`,
    params: [{
      name: 'Label',
      type: 'string',
      restParam: true,
      optional: true,
      editor: _components_LabelParamEditor__WEBPACK_IMPORTED_MODULE_2__.LabelParamEditor
    }],
    defaultParams: [''],
    alternativesKey: 'aggregations by',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Aggregations,
    renderer: getAggregationByRenderer(name),
    paramChangedHandler: getLastLabelRemovedHandler(name),
    explainHandler: getAggregationExplainer(name, 'by'),
    addOperationHandler: defaultAddOperationHandler,
    hideFromList: true
  }, overrides), Object.assign({
    id: `__${name}_without`,
    name: `${getPromAndLokiOperationDisplayName(name)} without`,
    params: [{
      name: 'Label',
      type: 'string',
      restParam: true,
      optional: true,
      editor: _components_LabelParamEditor__WEBPACK_IMPORTED_MODULE_2__.LabelParamEditor
    }],
    defaultParams: [''],
    alternativesKey: 'aggregations by',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Aggregations,
    renderer: getAggregationWithoutRenderer(name),
    paramChangedHandler: getLastLabelRemovedHandler(name),
    explainHandler: getAggregationExplainer(name, 'without'),
    addOperationHandler: defaultAddOperationHandler,
    hideFromList: true
  }, overrides)];
  return operations;
}
function createAggregationOperationWithParam(name, paramsDef, overrides = {}) {
  const operations = createAggregationOperation(name, overrides);
  operations[0].params.unshift(...paramsDef.params);
  operations[1].params.unshift(...paramsDef.params);
  operations[2].params.unshift(...paramsDef.params);
  operations[0].defaultParams = paramsDef.defaultParams;
  operations[1].defaultParams = [...paramsDef.defaultParams, ''];
  operations[2].defaultParams = [...paramsDef.defaultParams, ''];
  operations[1].renderer = getAggregationByRendererWithParameter(name);
  operations[2].renderer = getAggregationByRendererWithParameter(name);
  return operations;
}

function getAggregationByRenderer(aggregation) {
  return function aggregationRenderer(model, def, innerExpr) {
    return `${aggregation} by(${model.params.join(', ')}) (${innerExpr})`;
  };
}

function getAggregationWithoutRenderer(aggregation) {
  return function aggregationRenderer(model, def, innerExpr) {
    return `${aggregation} without(${model.params.join(', ')}) (${innerExpr})`;
  };
}
/**
 * Very simple poc implementation, needs to be modified to support all aggregation operators
 */


function getAggregationExplainer(aggregationName, mode) {
  return function aggregationExplainer(model) {
    const labels = model.params.map(label => `\`${label}\``).join(' and ');
    const labelWord = pluralize__WEBPACK_IMPORTED_MODULE_1___default()('label', model.params.length);

    switch (mode) {
      case 'by':
        return `Calculates ${aggregationName} over dimensions while preserving ${labelWord} ${labels}.`;

      case 'without':
        return `Calculates ${aggregationName} over the dimensions ${labels}. All other labels are preserved.`;

      default:
        return `Calculates ${aggregationName} over the dimensions.`;
    }
  };
}

function getAggregationByRendererWithParameter(aggregation) {
  return function aggregationRenderer(model, def, innerExpr) {
    function mapType(p) {
      if (typeof p === 'string') {
        return `\"${p}\"`;
      }

      return p;
    }

    const params = model.params.slice(0, -1);
    const restParams = model.params.slice(1);
    return `${aggregation} by(${restParams.join(', ')}) (${params.map(mapType).join(', ')}, ${innerExpr})`;
  };
}
/**
 * This function will transform operations without labels to their plan aggregation operation
 */


function getLastLabelRemovedHandler(changeToOperationId) {
  return function onParamChanged(index, op, def) {
    // If definition has more params then is defined there are no optional rest params anymore.
    // We then transform this operation into a different one
    if (op.params.length < def.params.length) {
      return Object.assign({}, op, {
        id: changeToOperationId
      });
    }

    return op;
  };
}

function getOnLabelAddedHandler(changeToOperationId) {
  return function onParamChanged(index, op, def) {
    // Check if we actually have the label param. As it's optional the aggregation can have one less, which is the
    // case of just simple aggregation without label. When user adds the label it now has the same number of params
    // as it's definition, and now we can change it to it's `_by` variant.
    if (op.params.length === def.params.length) {
      return Object.assign({}, op, {
        id: changeToOperationId
      });
    }

    return op;
  };
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/parsingUtils.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ErrorName": () => (/* binding */ ErrorName),
/* harmony export */   "getAllByType": () => (/* binding */ getAllByType),
/* harmony export */   "getLeftMostChild": () => (/* binding */ getLeftMostChild),
/* harmony export */   "getString": () => (/* binding */ getString),
/* harmony export */   "log": () => (/* binding */ log),
/* harmony export */   "makeBinOp": () => (/* binding */ makeBinOp),
/* harmony export */   "makeError": () => (/* binding */ makeError),
/* harmony export */   "replaceVariables": () => (/* binding */ replaceVariables)
/* harmony export */ });
// This is used for error type for some reason
const ErrorName = '';
function getLeftMostChild(cur) {
  return cur.firstChild ? getLeftMostChild(cur.firstChild) : cur;
}
function makeError(expr, node) {
  var _node$parent;

  return {
    text: getString(expr, node),
    // TODO: this are positions in the string with the replaced variables. Means it cannot be used to show exact
    //  placement of the error for the user. We need some translation table to positions before the variable
    //  replace.
    from: node.from,
    to: node.to,
    parentType: (_node$parent = node.parent) === null || _node$parent === void 0 ? void 0 : _node$parent.name
  };
} // Taken from template_srv, but copied so to not mess with the regex.index which is manipulated in the service

/*
 * This regex matches 3 types of variable reference with an optional format specifier
 * \$(\w+)                          $var1
 * \[\[([\s\S]+?)(?::(\w+))?\]\]    [[var2]] or [[var2:fmt2]]
 * \${(\w+)(?::(\w+))?}             ${var3} or ${var3:fmt3}
 */

const variableRegex = /\$(\w+)|\[\[([\s\S]+?)(?::(\w+))?\]\]|\${(\w+)(?:\.([^:^\}]+))?(?::([^\}]+))?}/g;
/**
 * As variables with $ are creating parsing errors, we first replace them with magic string that is parsable and at
 * the same time we can get the variable and it's format back from it.
 * @param expr
 */

function replaceVariables(expr) {
  return expr.replace(variableRegex, (match, var1, var2, fmt2, var3, fieldPath, fmt3) => {
    const fmt = fmt2 || fmt3;
    let variable = var1;
    let varType = '0';

    if (var2) {
      variable = var2;
      varType = '1';
    }

    if (var3) {
      variable = var3;
      varType = '2';
    }

    return `__V_${varType}__` + variable + '__V__' + (fmt ? '__F__' + fmt + '__F__' : '');
  });
}
const varTypeFunc = [(v, f) => `\$${v}`, (v, f) => `[[${v}${f ? `:${f}` : ''}]]`, (v, f) => `\$\{${v}${f ? `:${f}` : ''}\}`];
/**
 * Get back the text with variables in their original format.
 * @param expr
 */

function returnVariables(expr) {
  return expr.replace(/__V_(\d)__(.+?)__V__(?:__F__(\w+)__F__)?/g, (match, type, v, f) => {
    return varTypeFunc[parseInt(type, 10)](v, f);
  });
}
/**
 * Get the actual string of the expression. That is not stored in the tree so we have to get the indexes from the node
 * and then based on that get it from the expression.
 * @param expr
 * @param node
 */


function getString(expr, node) {
  if (!node) {
    return '';
  }

  return returnVariables(expr.substring(node.from, node.to));
}
/**
 * Create simple scalar binary op object.
 * @param opDef - definition of the op to be created
 * @param expr
 * @param numberNode - the node for the scalar
 * @param hasBool - whether operation has a bool modifier. Is used only for ops for which it makes sense.
 */

function makeBinOp(opDef, expr, numberNode, hasBool) {
  const params = [parseFloat(getString(expr, numberNode))];

  if (opDef.comparison) {
    params.push(hasBool);
  }

  return {
    id: opDef.id,
    params
  };
}
/**
 * Get all nodes with type in the tree. This traverses the tree so it is safe only when you know there shouldn't be
 * too much nesting but you just want to skip some of the wrappers. For example getting function args this way would
 * not be safe is it would also find arguments of nested functions.
 * @param expr
 * @param cur
 * @param type
 */

function getAllByType(expr, cur, type) {
  if (cur.name === type) {
    return [getString(expr, cur)];
  }

  const values = [];
  let pos = 0;
  let child = cur.childAfter(pos);

  while (child) {
    values.push(...getAllByType(expr, child, type));
    pos = child.to;
    child = cur.childAfter(pos);
  }

  return values;
} // Debugging function for convenience. Gives you nice output similar to linux tree util.
// @ts-ignore

function log(expr, cur) {
  if (!cur) {
    console.log('<empty>');
    return;
  }

  const json = toJson(expr, cur);
  const text = jsonToText(json);

  if (!text) {
    console.log('<empty>');
    return;
  }

  console.log(text);
}

function toJson(expr, cur) {
  const treeJson = {};
  const name = nodeToString(expr, cur);
  const children = [];
  let pos = 0;
  let child = cur.childAfter(pos);

  while (child) {
    children.push(toJson(expr, child));
    pos = child.to;
    child = cur.childAfter(pos);
  }

  treeJson.name = name;
  treeJson.children = children;
  return treeJson;
}

function jsonToText(node, context = {
  lastChild: true,
  indent: ''
}) {
  const name = node.name;
  const {
    lastChild,
    indent
  } = context;
  const newIndent = indent !== '' ? indent + (lastChild ? '' : '') : '';
  let text = newIndent + name;
  const children = node.children;
  children.forEach((child, index) => {
    const isLastChild = index === children.length - 1;
    text += '\n' + jsonToText(child, {
      lastChild: isLastChild,
      indent: indent + (lastChild ? '  ' : ' ')
    });
  });
  return text;
}

function nodeToString(expr, node) {
  return node.name + ': ' + getString(expr, node);
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/types.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "QueryEditorMode": () => (/* binding */ QueryEditorMode)
/* harmony export */ });
/**
 * Shared types that can be reused by Loki and other data sources
 */
let QueryEditorMode;

(function (QueryEditorMode) {
  QueryEditorMode["Code"] = "code";
  QueryEditorMode["Builder"] = "builder";
  QueryEditorMode["Explain"] = "explain";
})(QueryEditorMode || (QueryEditorMode = {}));

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/state.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "changeEditorMode": () => (/* binding */ changeEditorMode),
/* harmony export */   "getQueryWithDefaults": () => (/* binding */ getQueryWithDefaults)
/* harmony export */ });
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var app_core_store__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/core/store.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/types.ts");
/* harmony import */ var _shared_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/types.ts");




const queryEditorModeDefaultLocalStorageKey = 'PrometheusQueryEditorModeDefault';
function changeEditorMode(query, editorMode, onChange) {
  // If empty query store new mode as default
  if (query.expr === '') {
    app_core_store__WEBPACK_IMPORTED_MODULE_1__["default"].set(queryEditorModeDefaultLocalStorageKey, editorMode);
  }

  onChange(Object.assign({}, query, {
    editorMode
  }));
}

function getDefaultEditorMode(expr) {
  // If we already have an expression default to code view
  if (expr != null && expr !== '') {
    return _shared_types__WEBPACK_IMPORTED_MODULE_3__.QueryEditorMode.Code;
  }

  const value = app_core_store__WEBPACK_IMPORTED_MODULE_1__["default"].get(queryEditorModeDefaultLocalStorageKey);

  switch (value) {
    case _shared_types__WEBPACK_IMPORTED_MODULE_3__.QueryEditorMode.Builder:
    case _shared_types__WEBPACK_IMPORTED_MODULE_3__.QueryEditorMode.Code:
    case _shared_types__WEBPACK_IMPORTED_MODULE_3__.QueryEditorMode.Explain:
      return value;

    default:
      return _shared_types__WEBPACK_IMPORTED_MODULE_3__.QueryEditorMode.Builder;
  }
}
/**
 * Returns query with defaults, and boolean true/false depending on change was required
 */


function getQueryWithDefaults(query, app) {
  let result = query;

  if (!query.editorMode) {
    result = Object.assign({}, query, {
      editorMode: getDefaultEditorMode(query.expr)
    });
  }

  if (query.expr == null) {
    result = Object.assign({}, result, {
      expr: '',
      legendFormat: _types__WEBPACK_IMPORTED_MODULE_2__.LegendFormatMode.Auto
    });
  }

  if (query.range == null && query.instant == null) {
    // Default to range query
    result = Object.assign({}, result, {
      range: true
    }); // In explore we default to both instant & range

    if (app === _grafana_data__WEBPACK_IMPORTED_MODULE_0__.CoreApp.Explore) {
      result.instant = true;
    }
  }

  return result;
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/types.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromOperationId": () => (/* binding */ PromOperationId),
/* harmony export */   "PromVisualQueryOperationCategory": () => (/* binding */ PromVisualQueryOperationCategory)
/* harmony export */ });
/**
 * Visual query model
 */
let PromVisualQueryOperationCategory;

(function (PromVisualQueryOperationCategory) {
  PromVisualQueryOperationCategory["Aggregations"] = "Aggregations";
  PromVisualQueryOperationCategory["RangeFunctions"] = "Range functions";
  PromVisualQueryOperationCategory["Functions"] = "Functions";
  PromVisualQueryOperationCategory["BinaryOps"] = "Binary operations";
  PromVisualQueryOperationCategory["Trigonometric"] = "Trigonometric";
  PromVisualQueryOperationCategory["Time"] = "Time Functions";
})(PromVisualQueryOperationCategory || (PromVisualQueryOperationCategory = {}));

let PromOperationId;

(function (PromOperationId) {
  PromOperationId["Abs"] = "abs";
  PromOperationId["Absent"] = "absent";
  PromOperationId["AbsentOverTime"] = "absent_over_time";
  PromOperationId["Acos"] = "acos";
  PromOperationId["Acosh"] = "acosh";
  PromOperationId["Asin"] = "asin";
  PromOperationId["Asinh"] = "asinh";
  PromOperationId["Atan"] = "atan";
  PromOperationId["Atanh"] = "atanh";
  PromOperationId["Avg"] = "avg";
  PromOperationId["AvgOverTime"] = "avg_over_time";
  PromOperationId["BottomK"] = "bottomk";
  PromOperationId["Ceil"] = "ceil";
  PromOperationId["Changes"] = "changes";
  PromOperationId["Clamp"] = "clamp";
  PromOperationId["ClampMax"] = "clamp_max";
  PromOperationId["ClampMin"] = "clamp_min";
  PromOperationId["Cos"] = "cos";
  PromOperationId["Cosh"] = "cosh";
  PromOperationId["Count"] = "count";
  PromOperationId["CountOverTime"] = "count_over_time";
  PromOperationId["CountScalar"] = "count_scalar";
  PromOperationId["CountValues"] = "count_values";
  PromOperationId["DayOfMonth"] = "day_of_month";
  PromOperationId["DayOfWeek"] = "day_of_week";
  PromOperationId["DaysInMonth"] = "days_in_month";
  PromOperationId["Deg"] = "deg";
  PromOperationId["Delta"] = "delta";
  PromOperationId["Deriv"] = "deriv";
  PromOperationId["DropCommonLabels"] = "drop_common_labels";
  PromOperationId["Exp"] = "exp";
  PromOperationId["Floor"] = "floor";
  PromOperationId["Group"] = "group";
  PromOperationId["HistogramQuantile"] = "histogram_quantile";
  PromOperationId["HoltWinters"] = "holt_winters";
  PromOperationId["Hour"] = "hour";
  PromOperationId["Idelta"] = "idelta";
  PromOperationId["Increase"] = "increase";
  PromOperationId["Irate"] = "irate";
  PromOperationId["LabelJoin"] = "label_join";
  PromOperationId["LabelReplace"] = "label_replace";
  PromOperationId["Last"] = "last";
  PromOperationId["LastOverTime"] = "last_over_time";
  PromOperationId["Ln"] = "ln";
  PromOperationId["Log10"] = "log10";
  PromOperationId["Log2"] = "log2";
  PromOperationId["Max"] = "max";
  PromOperationId["MaxOverTime"] = "max_over_time";
  PromOperationId["Min"] = "min";
  PromOperationId["MinOverTime"] = "min_over_time";
  PromOperationId["Minute"] = "minute";
  PromOperationId["Month"] = "month";
  PromOperationId["Pi"] = "pi";
  PromOperationId["PredictLinear"] = "predict_linear";
  PromOperationId["Present"] = "present";
  PromOperationId["PresentOverTime"] = "present_over_time";
  PromOperationId["Quantile"] = "quantile";
  PromOperationId["QuantileOverTime"] = "quantile_over_time";
  PromOperationId["Rad"] = "rad";
  PromOperationId["Rate"] = "rate";
  PromOperationId["Resets"] = "resets";
  PromOperationId["Round"] = "round";
  PromOperationId["Scalar"] = "scalar";
  PromOperationId["Sgn"] = "sgn";
  PromOperationId["Sin"] = "sin";
  PromOperationId["Sinh"] = "sinh";
  PromOperationId["Sort"] = "sort";
  PromOperationId["SortDesc"] = "sort_desc";
  PromOperationId["Sqrt"] = "sqrt";
  PromOperationId["Stddev"] = "stddev";
  PromOperationId["StddevOverTime"] = "stddev_over_time";
  PromOperationId["Sum"] = "sum";
  PromOperationId["SumOverTime"] = "sum_over_time";
  PromOperationId["Tan"] = "tan";
  PromOperationId["Tanh"] = "tanh";
  PromOperationId["Time"] = "time";
  PromOperationId["Timestamp"] = "timestamp";
  PromOperationId["TopK"] = "topk";
  PromOperationId["Vector"] = "vector";
  PromOperationId["Year"] = "year";
  PromOperationId["Addition"] = "__addition";
  PromOperationId["Subtraction"] = "__subtraction";
  PromOperationId["MultiplyBy"] = "__multiply_by";
  PromOperationId["DivideBy"] = "__divide_by";
  PromOperationId["Modulo"] = "__modulo";
  PromOperationId["Exponent"] = "__exponent";
  PromOperationId["NestedQuery"] = "__nested_query";
  PromOperationId["EqualTo"] = "__equal_to";
  PromOperationId["NotEqualTo"] = "__not_equal_to";
  PromOperationId["GreaterThan"] = "__greater_than";
  PromOperationId["LessThan"] = "__less_than";
  PromOperationId["GreaterOrEqual"] = "__greater_or_equal";
  PromOperationId["LessOrEqual"] = "__less_or_equal";
})(PromOperationId || (PromOperationId = {}));

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/result_transformer.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getOriginalMetricName": () => (/* binding */ getOriginalMetricName),
/* harmony export */   "parseSampleValue": () => (/* binding */ parseSampleValue),
/* harmony export */   "transform": () => (/* binding */ transform),
/* harmony export */   "transformDFToTable": () => (/* binding */ transformDFToTable),
/* harmony export */   "transformV2": () => (/* binding */ transformV2)
/* harmony export */ });
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/d3-npm-5.15.0-0c7696026f-7342d82e55.zip/node_modules/d3/index.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/legend.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/types.ts");
const _excluded = ["__name__"];

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }






 // handles case-insensitive Inf, +Inf, -Inf (with optional "inity" suffix)

const INFINITY_SAMPLE_REGEX = /^[+-]?inf(?:inity)?$/i;

const isTableResult = (dataFrame, options) => {
  var _dataFrame$meta, _dataFrame$meta$custo, _dataFrame$meta2, _dataFrame$meta2$cust;

  // We want to process vector and scalar results in Explore as table
  if (options.app === _grafana_data__WEBPACK_IMPORTED_MODULE_2__.CoreApp.Explore && (((_dataFrame$meta = dataFrame.meta) === null || _dataFrame$meta === void 0 ? void 0 : (_dataFrame$meta$custo = _dataFrame$meta.custom) === null || _dataFrame$meta$custo === void 0 ? void 0 : _dataFrame$meta$custo.resultType) === 'vector' || ((_dataFrame$meta2 = dataFrame.meta) === null || _dataFrame$meta2 === void 0 ? void 0 : (_dataFrame$meta2$cust = _dataFrame$meta2.custom) === null || _dataFrame$meta2$cust === void 0 ? void 0 : _dataFrame$meta2$cust.resultType) === 'scalar')) {
    return true;
  } // We want to process all dataFrames with target.format === 'table' as table


  const target = options.targets.find(target => target.refId === dataFrame.refId);
  return (target === null || target === void 0 ? void 0 : target.format) === 'table';
};

const isHeatmapResult = (dataFrame, options) => {
  const target = options.targets.find(target => target.refId === dataFrame.refId);
  return (target === null || target === void 0 ? void 0 : target.format) === 'heatmap';
}; // V2 result trasnformer used to transform query results from queries that were run trough prometheus backend


function transformV2(response, request, options) {
  const [tableFrames, framesWithoutTable] = (0,lodash__WEBPACK_IMPORTED_MODULE_1__.partition)(response.data, df => isTableResult(df, request));
  const processedTableFrames = transformDFToTable(tableFrames);
  const [exemplarFrames, framesWithoutTableAndExemplars] = (0,lodash__WEBPACK_IMPORTED_MODULE_1__.partition)(framesWithoutTable, df => {
    var _df$meta, _df$meta$custom;

    return ((_df$meta = df.meta) === null || _df$meta === void 0 ? void 0 : (_df$meta$custom = _df$meta.custom) === null || _df$meta$custom === void 0 ? void 0 : _df$meta$custom.resultType) === 'exemplar';
  }); // EXEMPLAR FRAMES: We enrich exemplar frames with data links and add dataTopic meta info

  const {
    exemplarTraceIdDestinations: destinations
  } = options;
  const processedExemplarFrames = exemplarFrames.map(dataFrame => {
    if (destinations !== null && destinations !== void 0 && destinations.length) {
      for (const exemplarTraceIdDestination of destinations) {
        const traceIDField = dataFrame.fields.find(field => field.name === exemplarTraceIdDestination.name);

        if (traceIDField) {
          var _traceIDField$config$;

          const links = getDataLinks(exemplarTraceIdDestination);
          traceIDField.config.links = (_traceIDField$config$ = traceIDField.config.links) !== null && _traceIDField$config$ !== void 0 && _traceIDField$config$.length ? [...traceIDField.config.links, ...links] : links;
        }
      }
    }

    return Object.assign({}, dataFrame, {
      meta: Object.assign({}, dataFrame.meta, {
        dataTopic: _grafana_data__WEBPACK_IMPORTED_MODULE_2__.DataTopic.Annotations
      })
    });
  });
  const [heatmapResults, framesWithoutTableHeatmapsAndExemplars] = (0,lodash__WEBPACK_IMPORTED_MODULE_1__.partition)(framesWithoutTableAndExemplars, df => isHeatmapResult(df, request));
  const processedHeatmapFrames = mergeHeatmapFrames(transformToHistogramOverTime(heatmapResults.sort(sortSeriesByLabel))); // Everything else is processed as time_series result and graph preferredVisualisationType

  const otherFrames = framesWithoutTableHeatmapsAndExemplars.map(dataFrame => {
    const df = Object.assign({}, dataFrame, {
      meta: Object.assign({}, dataFrame.meta, {
        preferredVisualisationType: 'graph'
      })
    });
    return df;
  });
  return Object.assign({}, response, {
    data: [...otherFrames, ...processedTableFrames, ...processedHeatmapFrames, ...processedExemplarFrames]
  });
}
function transformDFToTable(dfs) {
  // If no dataFrames or if 1 dataFrames with no values, return original dataFrame
  if (dfs.length === 0 || dfs.length === 1 && dfs[0].length === 0) {
    return dfs;
  } // Group results by refId and process dataFrames with the same refId as 1 dataFrame


  const dataFramesByRefId = (0,lodash__WEBPACK_IMPORTED_MODULE_1__.groupBy)(dfs, 'refId');
  const refIds = Object.keys(dataFramesByRefId);
  const frames = refIds.map(refId => {
    // Create timeField, valueField and labelFields
    const valueText = getValueText(refIds.length, refId);
    const valueField = getValueField({
      data: [],
      valueName: valueText
    });
    const timeField = getTimeField([]);
    const labelFields = []; // Fill labelsFields with labels from dataFrames

    dataFramesByRefId[refId].forEach(df => {
      var _frameValueField$labe;

      const frameValueField = df.fields[1];
      const promLabels = (_frameValueField$labe = frameValueField.labels) !== null && _frameValueField$labe !== void 0 ? _frameValueField$labe : {};
      Object.keys(promLabels).sort().forEach(label => {
        // If we don't have label in labelFields, add it
        if (!labelFields.some(l => l.name === label)) {
          const numberField = label === 'le';
          labelFields.push({
            name: label,
            config: {
              filterable: true
            },
            type: numberField ? _grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldType.number : _grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldType.string,
            values: new _grafana_data__WEBPACK_IMPORTED_MODULE_2__.ArrayVector()
          });
        }
      });
    }); // Fill valueField, timeField and labelFields with values

    dataFramesByRefId[refId].forEach(df => {
      df.fields[0].values.toArray().forEach(value => timeField.values.add(value));
      df.fields[1].values.toArray().forEach(value => {
        var _df$fields$1$labels;

        valueField.values.add(parseSampleValue(value));
        const labelsForField = (_df$fields$1$labels = df.fields[1].labels) !== null && _df$fields$1$labels !== void 0 ? _df$fields$1$labels : {};
        labelFields.forEach(field => field.values.add(getLabelValue(labelsForField, field.name)));
      });
    });
    const fields = [timeField, ...labelFields, valueField];
    return {
      refId,
      fields,
      meta: Object.assign({}, dfs[0].meta, {
        preferredVisualisationType: 'table'
      }),
      length: timeField.values.length
    };
  });
  return frames;
}

function getValueText(responseLength, refId = '') {
  return responseLength > 1 ? `Value #${refId}` : 'Value';
}

function transform(response, transformOptions) {
  // Create options object from transformOptions
  const options = {
    format: transformOptions.target.format,
    step: transformOptions.query.step,
    legendFormat: transformOptions.target.legendFormat,
    start: transformOptions.query.start,
    end: transformOptions.query.end,
    query: transformOptions.query.expr,
    responseListLength: transformOptions.responseListLength,
    scopedVars: transformOptions.scopedVars,
    refId: transformOptions.target.refId,
    valueWithRefId: transformOptions.target.valueWithRefId,
    meta: {
      // Fix for showing of Prometheus results in Explore table
      preferredVisualisationType: transformOptions.query.instant ? 'table' : 'graph'
    }
  };
  const prometheusResult = response.data.data;

  if ((0,_types__WEBPACK_IMPORTED_MODULE_5__.isExemplarData)(prometheusResult)) {
    var _transformOptions$exe;

    const events = [];
    prometheusResult.forEach(exemplarData => {
      const data = exemplarData.exemplars.map(exemplar => {
        return Object.assign({
          [_grafana_data__WEBPACK_IMPORTED_MODULE_2__.TIME_SERIES_TIME_FIELD_NAME]: exemplar.timestamp * 1000,
          [_grafana_data__WEBPACK_IMPORTED_MODULE_2__.TIME_SERIES_VALUE_FIELD_NAME]: exemplar.value
        }, exemplar.labels, exemplarData.seriesLabels);
      });
      events.push(...data);
    }); // Grouping exemplars by step

    const sampledExemplars = sampleExemplars(events, options);
    const dataFrame = new _grafana_data__WEBPACK_IMPORTED_MODULE_2__.ArrayDataFrame(sampledExemplars);
    dataFrame.meta = {
      dataTopic: _grafana_data__WEBPACK_IMPORTED_MODULE_2__.DataTopic.Annotations
    }; // Add data links if configured

    if ((_transformOptions$exe = transformOptions.exemplarTraceIdDestinations) !== null && _transformOptions$exe !== void 0 && _transformOptions$exe.length) {
      for (const exemplarTraceIdDestination of transformOptions.exemplarTraceIdDestinations) {
        const traceIDField = dataFrame.fields.find(field => field.name === exemplarTraceIdDestination.name);

        if (traceIDField) {
          var _traceIDField$config$2;

          const links = getDataLinks(exemplarTraceIdDestination);
          traceIDField.config.links = (_traceIDField$config$2 = traceIDField.config.links) !== null && _traceIDField$config$2 !== void 0 && _traceIDField$config$2.length ? [...traceIDField.config.links, ...links] : links;
        }
      }
    }

    return [dataFrame];
  }

  if (!(prometheusResult !== null && prometheusResult !== void 0 && prometheusResult.result)) {
    return [];
  } // Return early if result type is scalar


  if (prometheusResult.resultType === 'scalar') {
    return [{
      meta: options.meta,
      refId: options.refId,
      length: 1,
      fields: [getTimeField([prometheusResult.result]), getValueField({
        data: [prometheusResult.result]
      })]
    }];
  } // Return early again if the format is table, this needs special transformation.


  if (options.format === 'table') {
    const tableData = transformMetricDataToTable(prometheusResult.result, options);
    return [tableData];
  } // Process matrix and vector results to DataFrame


  const dataFrame = [];
  prometheusResult.result.forEach(data => dataFrame.push(transformToDataFrame(data, options))); // When format is heatmap use the already created data frames and transform it more

  if (options.format === 'heatmap') {
    return mergeHeatmapFrames(transformToHistogramOverTime(dataFrame.sort(sortSeriesByLabel)));
  } // Return matrix or vector result as DataFrame[]


  return dataFrame;
}

function getDataLinks(options) {
  const dataLinks = [];

  if (options.datasourceUid) {
    var _dsSettings$name;

    const dataSourceSrv = (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_3__.getDataSourceSrv)();
    const dsSettings = dataSourceSrv.getInstanceSettings(options.datasourceUid);
    dataLinks.push({
      title: options.urlDisplayLabel || `Query with ${dsSettings === null || dsSettings === void 0 ? void 0 : dsSettings.name}`,
      url: '',
      internal: {
        query: {
          query: '${__value.raw}',
          queryType: 'traceId'
        },
        datasourceUid: options.datasourceUid,
        datasourceName: (_dsSettings$name = dsSettings === null || dsSettings === void 0 ? void 0 : dsSettings.name) !== null && _dsSettings$name !== void 0 ? _dsSettings$name : 'Data source not found'
      }
    });
  }

  if (options.url) {
    dataLinks.push({
      title: options.urlDisplayLabel || `Go to ${options.url}`,
      url: options.url,
      targetBlank: true
    });
  }

  return dataLinks;
}
/**
 * Reduce the density of the exemplars by making sure that the highest value exemplar is included
 * and then only the ones that are 2 times the standard deviation of the all the values.
 * This makes sure not to show too many dots near each other.
 */


function sampleExemplars(events, options) {
  const step = options.step || 15;
  const bucketedExemplars = {};
  const values = [];

  for (const exemplar of events) {
    // Align exemplar timestamp to nearest step second
    const alignedTs = String(Math.floor(exemplar[_grafana_data__WEBPACK_IMPORTED_MODULE_2__.TIME_SERIES_TIME_FIELD_NAME] / 1000 / step) * step * 1000);

    if (!bucketedExemplars[alignedTs]) {
      // New bucket found
      bucketedExemplars[alignedTs] = [];
    }

    bucketedExemplars[alignedTs].push(exemplar);
    values.push(exemplar[_grafana_data__WEBPACK_IMPORTED_MODULE_2__.TIME_SERIES_VALUE_FIELD_NAME]);
  } // Getting exemplars from each bucket


  const standardDeviation = (0,d3__WEBPACK_IMPORTED_MODULE_0__.deviation)(values);
  const sampledBuckets = Object.keys(bucketedExemplars).sort();
  const sampledExemplars = [];

  for (const ts of sampledBuckets) {
    const exemplarsInBucket = bucketedExemplars[ts];

    if (exemplarsInBucket.length === 1) {
      sampledExemplars.push(exemplarsInBucket[0]);
    } else {
      // Choose which values to sample
      const bucketValues = exemplarsInBucket.map(ex => ex[_grafana_data__WEBPACK_IMPORTED_MODULE_2__.TIME_SERIES_VALUE_FIELD_NAME]).sort(d3__WEBPACK_IMPORTED_MODULE_0__.descending);
      const sampledBucketValues = bucketValues.reduce((acc, curr) => {
        if (acc.length === 0) {
          // First value is max and is always added
          acc.push(curr);
        } else {
          // Then take values only when at least 2 standard deviation distance to previously taken value
          const prev = acc[acc.length - 1];

          if (standardDeviation && prev - curr >= 2 * standardDeviation) {
            acc.push(curr);
          }
        }

        return acc;
      }, []); // Find the exemplars for the sampled values

      sampledExemplars.push(...sampledBucketValues.map(value => exemplarsInBucket.find(ex => ex[_grafana_data__WEBPACK_IMPORTED_MODULE_2__.TIME_SERIES_VALUE_FIELD_NAME] === value)));
    }
  }

  return sampledExemplars;
}
/**
 * Transforms matrix and vector result from Prometheus result to DataFrame
 */


function transformToDataFrame(data, options) {
  const {
    name,
    labels
  } = createLabelInfo(data.metric, options);
  const fields = [];

  if ((0,_types__WEBPACK_IMPORTED_MODULE_5__.isMatrixData)(data)) {
    const stepMs = options.step ? options.step * 1000 : NaN;
    let baseTimestamp = options.start * 1000;
    const dps = [];

    for (const value of data.values) {
      let dpValue = parseSampleValue(value[1]);

      if (isNaN(dpValue)) {
        dpValue = null;
      }

      const timestamp = value[0] * 1000;

      for (let t = baseTimestamp; t < timestamp; t += stepMs) {
        dps.push([t, null]);
      }

      baseTimestamp = timestamp + stepMs;
      dps.push([timestamp, dpValue]);
    }

    const endTimestamp = options.end * 1000;

    for (let t = baseTimestamp; t <= endTimestamp; t += stepMs) {
      dps.push([t, null]);
    }

    fields.push(getTimeField(dps, true));
    fields.push(getValueField({
      data: dps,
      parseValue: false,
      labels,
      displayNameFromDS: name
    }));
  } else {
    fields.push(getTimeField([data.value]));
    fields.push(getValueField({
      data: [data.value],
      labels,
      displayNameFromDS: name
    }));
  }

  return {
    meta: options.meta,
    refId: options.refId,
    length: fields[0].values.length,
    fields,
    name
  };
}

function transformMetricDataToTable(md, options) {
  if (!md || md.length === 0) {
    return {
      meta: options.meta,
      refId: options.refId,
      length: 0,
      fields: []
    };
  }

  const valueText = options.responseListLength > 1 || options.valueWithRefId ? `Value #${options.refId}` : 'Value';
  const timeField = getTimeField([]);
  const metricFields = Object.keys(md.reduce((acc, series) => Object.assign({}, acc, series.metric), {})).sort().map(label => {
    // Labels have string field type, otherwise table tries to figure out the type which can result in unexpected results
    // Only "le" label has a number field type
    const numberField = label === 'le';
    return {
      name: label,
      config: {
        filterable: true
      },
      type: numberField ? _grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldType.number : _grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldType.string,
      values: new _grafana_data__WEBPACK_IMPORTED_MODULE_2__.ArrayVector()
    };
  });
  const valueField = getValueField({
    data: [],
    valueName: valueText
  });
  md.forEach(d => {
    if ((0,_types__WEBPACK_IMPORTED_MODULE_5__.isMatrixData)(d)) {
      d.values.forEach(val => {
        timeField.values.add(val[0] * 1000);
        metricFields.forEach(metricField => metricField.values.add(getLabelValue(d.metric, metricField.name)));
        valueField.values.add(parseSampleValue(val[1]));
      });
    } else {
      timeField.values.add(d.value[0] * 1000);
      metricFields.forEach(metricField => metricField.values.add(getLabelValue(d.metric, metricField.name)));
      valueField.values.add(parseSampleValue(d.value[1]));
    }
  });
  return {
    meta: options.meta,
    refId: options.refId,
    length: timeField.values.length,
    fields: [timeField, ...metricFields, valueField]
  };
}

function getLabelValue(metric, label) {
  if (metric.hasOwnProperty(label)) {
    if (label === 'le') {
      return parseSampleValue(metric[label]);
    }

    return metric[label];
  }

  return '';
}

function getTimeField(data, isMs = false) {
  return {
    name: _grafana_data__WEBPACK_IMPORTED_MODULE_2__.TIME_SERIES_TIME_FIELD_NAME,
    type: _grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldType.time,
    config: {},
    values: new _grafana_data__WEBPACK_IMPORTED_MODULE_2__.ArrayVector(data.map(val => isMs ? val[0] : val[0] * 1000))
  };
}

function getValueField({
  data,
  valueName = _grafana_data__WEBPACK_IMPORTED_MODULE_2__.TIME_SERIES_VALUE_FIELD_NAME,
  parseValue = true,
  labels,
  displayNameFromDS
}) {
  return {
    name: valueName,
    type: _grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldType.number,
    display: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_2__.getDisplayProcessor)(),
    config: {
      displayNameFromDS
    },
    labels,
    values: new _grafana_data__WEBPACK_IMPORTED_MODULE_2__.ArrayVector(data.map(val => parseValue ? parseSampleValue(val[1]) : val[1]))
  };
}

function createLabelInfo(labels, options) {
  if (options !== null && options !== void 0 && options.legendFormat) {
    const title = (0,_legend__WEBPACK_IMPORTED_MODULE_4__.renderLegendFormat)((0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_3__.getTemplateSrv)().replace(options.legendFormat, options === null || options === void 0 ? void 0 : options.scopedVars), labels);
    return {
      name: title,
      labels
    };
  }

  const {
    __name__
  } = labels,
        labelsWithoutName = _objectWithoutPropertiesLoose(labels, _excluded);

  const labelPart = (0,_grafana_data__WEBPACK_IMPORTED_MODULE_2__.formatLabels)(labelsWithoutName);
  let title = `${__name__ !== null && __name__ !== void 0 ? __name__ : ''}${labelPart}`;

  if (!title) {
    title = options.query;
  }

  return {
    name: title,
    labels: labelsWithoutName
  };
}

function getOriginalMetricName(labelData) {
  const metricName = labelData.__name__ || '';
  delete labelData.__name__;
  const labelPart = Object.entries(labelData).map(label => `${label[0]}="${label[1]}"`).join(',');
  return `${metricName}{${labelPart}}`;
}

function mergeHeatmapFrames(frames) {
  if (frames.length === 0) {
    return [];
  }

  const timeField = frames[0].fields.find(field => field.type === _grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldType.time);
  const countFields = frames.map(frame => {
    let field = frame.fields.find(field => field.type === _grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldType.number);
    return Object.assign({}, field, {
      name: field.config.displayNameFromDS
    });
  });
  return [Object.assign({}, frames[0], {
    meta: Object.assign({}, frames[0].meta, {
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_2__.DataFrameType.HeatmapBuckets
    }),
    fields: [timeField, ...countFields]
  })];
}

function transformToHistogramOverTime(seriesList) {
  /*      t1 = timestamp1, t2 = timestamp2 etc.
            t1  t2  t3          t1  t2  t3
    le10    10  10  0     =>    10  10  0
    le20    20  10  30    =>    10  0   30
    le30    30  10  35    =>    10  0   5
    */
  for (let i = seriesList.length - 1; i > 0; i--) {
    const topSeries = seriesList[i].fields.find(s => s.name === _grafana_data__WEBPACK_IMPORTED_MODULE_2__.TIME_SERIES_VALUE_FIELD_NAME);
    const bottomSeries = seriesList[i - 1].fields.find(s => s.name === _grafana_data__WEBPACK_IMPORTED_MODULE_2__.TIME_SERIES_VALUE_FIELD_NAME);

    if (!topSeries || !bottomSeries) {
      throw new Error('Prometheus heatmap transform error: data should be a time series');
    }

    for (let j = 0; j < topSeries.values.length; j++) {
      const bottomPoint = bottomSeries.values.get(j) || [0];
      topSeries.values.toArray()[j] -= bottomPoint;
    }
  }

  return seriesList;
}

function sortSeriesByLabel(s1, s2) {
  let le1, le2;

  try {
    var _s1$name, _s2$name;

    // fail if not integer. might happen with bad queries
    le1 = parseSampleValue((_s1$name = s1.name) !== null && _s1$name !== void 0 ? _s1$name : '');
    le2 = parseSampleValue((_s2$name = s2.name) !== null && _s2$name !== void 0 ? _s2$name : '');
  } catch (err) {
    console.error(err);
    return 0;
  }

  if (le1 > le2) {
    return 1;
  }

  if (le1 < le2) {
    return -1;
  }

  return 0;
}
/** @internal */


function parseSampleValue(value) {
  if (INFINITY_SAMPLE_REGEX.test(value)) {
    return value[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
  }

  return parseFloat(value);
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/types.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LegendFormatMode": () => (/* binding */ LegendFormatMode),
/* harmony export */   "PromQueryType": () => (/* binding */ PromQueryType),
/* harmony export */   "isExemplarData": () => (/* binding */ isExemplarData),
/* harmony export */   "isMatrixData": () => (/* binding */ isMatrixData)
/* harmony export */ });
let PromQueryType;

(function (PromQueryType) {
  PromQueryType["timeSeriesQuery"] = "timeSeriesQuery";
})(PromQueryType || (PromQueryType = {}));

function isMatrixData(result) {
  return 'values' in result;
}
function isExemplarData(result) {
  if (result == null || !Array.isArray(result)) {
    return false;
  }

  return result.length ? 'exemplars' in result[0] : false;
}

/**
 * Auto = query.legendFormat == '__auto'
 * Verbose = query.legendFormat == null/undefined/''
 * Custom query.legendFormat.length > 0 && query.legendFormat !== '__auto'
 */
let LegendFormatMode;

(function (LegendFormatMode) {
  LegendFormatMode["Auto"] = "__auto";
  LegendFormatMode["Verbose"] = "__verbose";
  LegendFormatMode["Custom"] = "__custom";
})(LegendFormatMode || (LegendFormatMode = {}));

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/variables.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PrometheusVariableSupport": () => (/* binding */ PrometheusVariableSupport)
/* harmony export */ });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/of.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/from.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/map.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _features_dashboard_services_TimeSrv__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/dashboard/services/TimeSrv.ts");
/* harmony import */ var _metric_find_query__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/metric_find_query.ts");






class PrometheusVariableSupport extends _grafana_data__WEBPACK_IMPORTED_MODULE_0__.StandardVariableSupport {
  constructor(datasource, templateSrv = (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_1__.getTemplateSrv)(), timeSrv = (0,_features_dashboard_services_TimeSrv__WEBPACK_IMPORTED_MODULE_2__.getTimeSrv)()) {
    super();
    this.datasource = datasource;
    this.templateSrv = templateSrv;
    this.timeSrv = timeSrv;
    this.datasource = datasource;
    this.templateSrv = templateSrv;
    this.timeSrv = timeSrv;
    this.query = this.query.bind(this);
  }

  query(request) {
    const query = request.targets[0].expr;

    if (!query) {
      return (0,rxjs__WEBPACK_IMPORTED_MODULE_4__.of)({
        data: []
      });
    }

    const scopedVars = Object.assign({}, request.scopedVars, {
      __interval: {
        text: this.datasource.interval,
        value: this.datasource.interval
      },
      __interval_ms: {
        text: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.rangeUtil.intervalToMs(this.datasource.interval),
        value: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.rangeUtil.intervalToMs(this.datasource.interval)
      }
    }, this.datasource.getRangeScopedVars(this.timeSrv.timeRange()));
    const interpolated = this.templateSrv.replace(query, scopedVars, this.datasource.interpolateQueryExpr);
    const metricFindQuery = new _metric_find_query__WEBPACK_IMPORTED_MODULE_3__["default"](this.datasource, interpolated);
    const metricFindStream = (0,rxjs__WEBPACK_IMPORTED_MODULE_5__.from)(metricFindQuery.process());
    return metricFindStream.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.map)(results => ({
      data: results
    })));
  }

  toDataQuery(query) {
    return {
      refId: 'PrometheusDatasource-VariableQuery',
      expr: query.query
    };
  }

}

/***/ }),

/***/ "./.yarn/__virtual__/react-use-virtual-00326e70ba/0/cache/react-use-npm-17.3.2-a032cbeb01-7379460f51.zip/node_modules/react-use/esm/usePrevious.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ usePrevious)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");

function usePrevious(state) {
    var ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
        ref.current = state;
    });
    return ref.current;
}


/***/ }),

/***/ "./.yarn/__virtual__/react-use-virtual-00326e70ba/0/cache/react-use-npm-17.3.2-a032cbeb01-7379460f51.zip/node_modules/react-use/esm/useToggle.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");

var toggleReducer = function (state, nextValue) {
    return typeof nextValue === 'boolean' ? nextValue : !state;
};
var useToggle = function (initialValue) {
    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(toggleReducer, initialValue);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (useToggle);


/***/ }),

/***/ "./.yarn/cache/lru-cache-npm-7.9.0-d803108233-c91a293a10.zip/node_modules/lru-cache/index.js":
/***/ ((module) => {

const perf = typeof performance === 'object' && performance &&
  typeof performance.now === 'function' ? performance : Date

const hasAbortController = typeof AbortController === 'function'

// minimal backwards-compatibility polyfill
// this doesn't have nearly all the checks and whatnot that
// actual AbortController/Signal has, but it's enough for
// our purposes, and if used properly, behaves the same.
const AC = hasAbortController ? AbortController : Object.assign(
  class AbortController {
    constructor () { this.signal = new AC.AbortSignal }
    abort () {
      this.signal.dispatchEvent('abort')
    }
  },
  {
    AbortSignal: class AbortSignal {
      constructor () {
        this.aborted = false
        this._listeners = []
      }
      dispatchEvent (type) {
        if (type === 'abort') {
          this.aborted = true
          const e = { type, target: this }
          this.onabort(e)
          this._listeners.forEach(f => f(e), this)
        }
      }
      onabort () {}
      addEventListener (ev, fn) {
        if (ev === 'abort') {
          this._listeners.push(fn)
        }
      }
      removeEventListener (ev, fn) {
        if (ev === 'abort') {
          this._listeners = this._listeners.filter(f => f !== fn)
        }
      }
    }
  }
)

const warned = new Set()
const deprecatedOption = (opt, instead) => {
  const code = `LRU_CACHE_OPTION_${opt}`
  if (shouldWarn(code)) {
    warn(code, `${opt} option`, `options.${instead}`, LRUCache)
  }
}
const deprecatedMethod = (method, instead) => {
  const code = `LRU_CACHE_METHOD_${method}`
  if (shouldWarn(code)) {
    const { prototype } = LRUCache
    const { get } = Object.getOwnPropertyDescriptor(prototype, method)
    warn(code, `${method} method`, `cache.${instead}()`, get)
  }
}
const deprecatedProperty = (field, instead) => {
  const code = `LRU_CACHE_PROPERTY_${field}`
  if (shouldWarn(code)) {
    const { prototype } = LRUCache
    const { get } = Object.getOwnPropertyDescriptor(prototype, field)
    warn(code, `${field} property`, `cache.${instead}`, get)
  }
}

const emitWarning = (...a) => {
  typeof process === 'object' &&
    process &&
    typeof process.emitWarning === 'function'
  ? process.emitWarning(...a)
  : console.error(...a)
}

const shouldWarn = code => !warned.has(code)

const warn = (code, what, instead, fn) => {
  warned.add(code)
  const msg = `The ${what} is deprecated. Please use ${instead} instead.`
  emitWarning(msg, 'DeprecationWarning', code, fn)
}

const isPosInt = n => n && n === Math.floor(n) && n > 0 && isFinite(n)

/* istanbul ignore next - This is a little bit ridiculous, tbh.
 * The maximum array length is 2^32-1 or thereabouts on most JS impls.
 * And well before that point, you're caching the entire world, I mean,
 * that's ~32GB of just integers for the next/prev links, plus whatever
 * else to hold that many keys and values.  Just filling the memory with
 * zeroes at init time is brutal when you get that big.
 * But why not be complete?
 * Maybe in the future, these limits will have expanded. */
const getUintArray = max => !isPosInt(max) ? null
: max <= Math.pow(2, 8) ? Uint8Array
: max <= Math.pow(2, 16) ? Uint16Array
: max <= Math.pow(2, 32) ? Uint32Array
: max <= Number.MAX_SAFE_INTEGER ? ZeroArray
: null

class ZeroArray extends Array {
  constructor (size) {
    super(size)
    this.fill(0)
  }
}

class Stack {
  constructor (max) {
    if (max === 0) {
      return []
    }
    const UintArray = getUintArray(max)
    this.heap = new UintArray(max)
    this.length = 0
  }
  push (n) {
    this.heap[this.length++] = n
  }
  pop () {
    return this.heap[--this.length]
  }
}

class LRUCache {
  constructor (options = {}) {
    const {
      max = 0,
      ttl,
      ttlResolution = 1,
      ttlAutopurge,
      updateAgeOnGet,
      updateAgeOnHas,
      allowStale,
      dispose,
      disposeAfter,
      noDisposeOnSet,
      noUpdateTTL,
      maxSize = 0,
      sizeCalculation,
      fetchMethod,
    } = options

    // deprecated options, don't trigger a warning for getting them if
    // the thing being passed in is another LRUCache we're copying.
    const {
      length,
      maxAge,
      stale,
    } = options instanceof LRUCache ? {} : options

    if (max !== 0 && !isPosInt(max)) {
      throw new TypeError('max option must be a nonnegative integer')
    }

    const UintArray = max ? getUintArray(max) : Array
    if (!UintArray) {
      throw new Error('invalid max value: ' + max)
    }

    this.max = max
    this.maxSize = maxSize
    this.sizeCalculation = sizeCalculation || length
    if (this.sizeCalculation) {
      if (!this.maxSize) {
        throw new TypeError('cannot set sizeCalculation without setting maxSize')
      }
      if (typeof this.sizeCalculation !== 'function') {
        throw new TypeError('sizeCalculation set to non-function')
      }
    }

    this.fetchMethod = fetchMethod || null
    if (this.fetchMethod && typeof this.fetchMethod !== 'function') {
      throw new TypeError('fetchMethod must be a function if specified')
    }

    this.keyMap = new Map()
    this.keyList = new Array(max).fill(null)
    this.valList = new Array(max).fill(null)
    this.next = new UintArray(max)
    this.prev = new UintArray(max)
    this.head = 0
    this.tail = 0
    this.free = new Stack(max)
    this.initialFill = 1
    this.size = 0

    if (typeof dispose === 'function') {
      this.dispose = dispose
    }
    if (typeof disposeAfter === 'function') {
      this.disposeAfter = disposeAfter
      this.disposed = []
    } else {
      this.disposeAfter = null
      this.disposed = null
    }
    this.noDisposeOnSet = !!noDisposeOnSet
    this.noUpdateTTL = !!noUpdateTTL

    if (this.maxSize !== 0) {
      if (!isPosInt(this.maxSize)) {
        throw new TypeError('maxSize must be a positive integer if specified')
      }
      this.initializeSizeTracking()
    }

    this.allowStale = !!allowStale || !!stale
    this.updateAgeOnGet = !!updateAgeOnGet
    this.updateAgeOnHas = !!updateAgeOnHas
    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0
      ? ttlResolution : 1
    this.ttlAutopurge = !!ttlAutopurge
    this.ttl = ttl || maxAge || 0
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError('ttl must be a positive integer if specified')
      }
      this.initializeTTLTracking()
    }

    // do not allow completely unbounded caches
    if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {
      throw new TypeError('At least one of max, maxSize, or ttl is required')
    }
    if (!this.ttlAutopurge && !this.max && !this.maxSize) {
      const code = 'LRU_CACHE_UNBOUNDED'
      if (shouldWarn(code)) {
        warned.add(code)
        const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' +
          'result in unbounded memory consumption.'
        emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache)
      }
    }

    if (stale) {
      deprecatedOption('stale', 'allowStale')
    }
    if (maxAge) {
      deprecatedOption('maxAge', 'ttl')
    }
    if (length) {
      deprecatedOption('length', 'sizeCalculation')
    }
  }

  getRemainingTTL (key) {
    return this.has(key, { updateAgeOnHas: false }) ? Infinity : 0
  }

  initializeTTLTracking () {
    this.ttls = new ZeroArray(this.max)
    this.starts = new ZeroArray(this.max)

    this.setItemTTL = (index, ttl) => {
      this.starts[index] = ttl !== 0 ? perf.now() : 0
      this.ttls[index] = ttl
      if (ttl !== 0 && this.ttlAutopurge) {
        const t = setTimeout(() => {
          if (this.isStale(index)) {
            this.delete(this.keyList[index])
          }
        }, ttl + 1)
        /* istanbul ignore else - unref() not supported on all platforms */
        if (t.unref) {
          t.unref()
        }
      }
    }

    this.updateItemAge = (index) => {
      this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0
    }

    // debounce calls to perf.now() to 1s so we're not hitting
    // that costly call repeatedly.
    let cachedNow = 0
    const getNow = () => {
      const n = perf.now()
      if (this.ttlResolution > 0) {
        cachedNow = n
        const t = setTimeout(() => cachedNow = 0, this.ttlResolution)
        /* istanbul ignore else - not available on all platforms */
        if (t.unref) {
          t.unref()
        }
      }
      return n
    }

    this.getRemainingTTL = (key) => {
      const index = this.keyMap.get(key)
      if (index === undefined) {
        return 0
      }
      return this.ttls[index] === 0 || this.starts[index] === 0 ? Infinity
        : ((this.starts[index] + this.ttls[index]) - (cachedNow || getNow()))
    }

    this.isStale = (index) => {
      return this.ttls[index] !== 0 && this.starts[index] !== 0 &&
        ((cachedNow || getNow()) - this.starts[index] > this.ttls[index])
    }
  }
  updateItemAge (index) {}
  setItemTTL (index, ttl) {}
  isStale (index) { return false }

  initializeSizeTracking () {
    this.calculatedSize = 0
    this.sizes = new ZeroArray(this.max)
    this.removeItemSize = index => this.calculatedSize -= this.sizes[index]
    this.requireSize = (k, v, size, sizeCalculation) => {
      if (!isPosInt(size)) {
        if (sizeCalculation) {
          if (typeof sizeCalculation !== 'function') {
            throw new TypeError('sizeCalculation must be a function')
          }
          size = sizeCalculation(v, k)
          if (!isPosInt(size)) {
            throw new TypeError('sizeCalculation return invalid (expect positive integer)')
          }
        } else {
          throw new TypeError('invalid size value (must be positive integer)')
        }
      }
      return size
    }
    this.addItemSize = (index, v, k, size) => {
      this.sizes[index] = size
      const maxSize = this.maxSize - this.sizes[index]
      while (this.calculatedSize > maxSize) {
        this.evict(true)
      }
      this.calculatedSize += this.sizes[index]
    }
  }
  removeItemSize (index) {}
  addItemSize (index, v, k, size) {}
  requireSize (k, v, size, sizeCalculation) {
    if (size || sizeCalculation) {
      throw new TypeError('cannot set size without setting maxSize on cache')
    }
  }

  *indexes ({ allowStale = this.allowStale } = {}) {
    if (this.size) {
      for (let i = this.tail; true; ) {
        if (!this.isValidIndex(i)) {
          break
        }
        if (allowStale || !this.isStale(i)) {
          yield i
        }
        if (i === this.head) {
          break
        } else {
          i = this.prev[i]
        }
      }
    }
  }

  *rindexes ({ allowStale = this.allowStale } = {}) {
    if (this.size) {
      for (let i = this.head; true; ) {
        if (!this.isValidIndex(i)) {
          break
        }
        if (allowStale || !this.isStale(i)) {
          yield i
        }
        if (i === this.tail) {
          break
        } else {
          i = this.next[i]
        }
      }
    }
  }

  isValidIndex (index) {
    return this.keyMap.get(this.keyList[index]) === index
  }

  *entries () {
    for (const i of this.indexes()) {
      yield [this.keyList[i], this.valList[i]]
    }
  }
  *rentries () {
    for (const i of this.rindexes()) {
      yield [this.keyList[i], this.valList[i]]
    }
  }

  *keys () {
    for (const i of this.indexes()) {
      yield this.keyList[i]
    }
  }
  *rkeys () {
    for (const i of this.rindexes()) {
      yield this.keyList[i]
    }
  }

  *values () {
    for (const i of this.indexes()) {
      yield this.valList[i]
    }
  }
  *rvalues () {
    for (const i of this.rindexes()) {
      yield this.valList[i]
    }
  }

  [Symbol.iterator] () {
    return this.entries()
  }

  find (fn, getOptions = {}) {
    for (const i of this.indexes()) {
      if (fn(this.valList[i], this.keyList[i], this)) {
        return this.get(this.keyList[i], getOptions)
      }
    }
  }

  forEach (fn, thisp = this) {
    for (const i of this.indexes()) {
      fn.call(thisp, this.valList[i], this.keyList[i], this)
    }
  }

  rforEach (fn, thisp = this) {
    for (const i of this.rindexes()) {
      fn.call(thisp, this.valList[i], this.keyList[i], this)
    }
  }

  get prune () {
    deprecatedMethod('prune', 'purgeStale')
    return this.purgeStale
  }

  purgeStale () {
    let deleted = false
    for (const i of this.rindexes({ allowStale: true })) {
      if (this.isStale(i)) {
        this.delete(this.keyList[i])
        deleted = true
      }
    }
    return deleted
  }

  dump () {
    const arr = []
    for (const i of this.indexes()) {
      const key = this.keyList[i]
      const value = this.valList[i]
      const entry = { value }
      if (this.ttls) {
        entry.ttl = this.ttls[i]
      }
      if (this.sizes) {
        entry.size = this.sizes[i]
      }
      arr.unshift([key, entry])
    }
    return arr
  }

  load (arr) {
    this.clear()
    for (const [key, entry] of arr) {
      this.set(key, entry.value, entry)
    }
  }

  dispose (v, k, reason) {}

  set (k, v, {
    ttl = this.ttl,
    noDisposeOnSet = this.noDisposeOnSet,
    size = 0,
    sizeCalculation = this.sizeCalculation,
    noUpdateTTL = this.noUpdateTTL,
  } = {}) {
    size = this.requireSize(k, v, size, sizeCalculation)
    let index = this.size === 0 ? undefined : this.keyMap.get(k)
    if (index === undefined) {
      // addition
      index = this.newIndex()
      this.keyList[index] = k
      this.valList[index] = v
      this.keyMap.set(k, index)
      this.next[this.tail] = index
      this.prev[index] = this.tail
      this.tail = index
      this.size ++
      this.addItemSize(index, v, k, size)
      noUpdateTTL = false
    } else {
      // update
      const oldVal = this.valList[index]
      if (v !== oldVal) {
        if (this.isBackgroundFetch(oldVal)) {
          oldVal.__abortController.abort()
        } else {
          if (!noDisposeOnSet) {
            this.dispose(oldVal, k, 'set')
            if (this.disposeAfter) {
              this.disposed.push([oldVal, k, 'set'])
            }
          }
        }
        this.removeItemSize(index)
        this.valList[index] = v
        this.addItemSize(index, v, k, size)
      }
      this.moveToTail(index)
    }
    if (ttl !== 0 && this.ttl === 0 && !this.ttls) {
      this.initializeTTLTracking()
    }
    if (!noUpdateTTL) {
      this.setItemTTL(index, ttl)
    }
    if (this.disposeAfter) {
      while (this.disposed.length) {
        this.disposeAfter(...this.disposed.shift())
      }
    }
    return this
  }

  newIndex () {
    if (this.size === 0) {
      return this.tail
    }
    if (this.size === this.max && this.max !== 0) {
      return this.evict(false)
    }
    if (this.free.length !== 0) {
      return this.free.pop()
    }
    // initial fill, just keep writing down the list
    return this.initialFill++
  }

  pop () {
    if (this.size) {
      const val = this.valList[this.head]
      this.evict(true)
      return val
    }
  }

  evict (free) {
    const head = this.head
    const k = this.keyList[head]
    const v = this.valList[head]
    if (this.isBackgroundFetch(v)) {
      v.__abortController.abort()
    } else {
      this.dispose(v, k, 'evict')
      if (this.disposeAfter) {
        this.disposed.push([v, k, 'evict'])
      }
    }
    this.removeItemSize(head)
    // if we aren't about to use the index, then null these out
    if (free) {
      this.keyList[head] = null
      this.valList[head] = null
      this.free.push(head)
    }
    this.head = this.next[head]
    this.keyMap.delete(k)
    this.size --
    return head
  }

  has (k, { updateAgeOnHas = this.updateAgeOnHas } = {}) {
    const index = this.keyMap.get(k)
    if (index !== undefined) {
      if (!this.isStale(index)) {
        if (updateAgeOnHas) {
          this.updateItemAge(index)
        }
        return true
      }
    }
    return false
  }

  // like get(), but without any LRU updating or TTL expiration
  peek (k, { allowStale = this.allowStale } = {}) {
    const index = this.keyMap.get(k)
    if (index !== undefined && (allowStale || !this.isStale(index))) {
      return this.valList[index]
    }
  }

  backgroundFetch (k, index, options) {
    const v = index === undefined ? undefined : this.valList[index]
    if (this.isBackgroundFetch(v)) {
      return v
    }
    const ac = new AC()
    const fetchOpts = {
      signal: ac.signal,
      options,
    }
    const p = Promise.resolve(this.fetchMethod(k, v, fetchOpts)).then(v => {
      if (!ac.signal.aborted) {
        this.set(k, v, fetchOpts.options)
      }
      return v
    })
    p.__abortController = ac
    p.__staleWhileFetching = v
    if (index === undefined) {
      this.set(k, p, fetchOpts.options)
      index = this.keyMap.get(k)
    } else {
      this.valList[index] = p
    }
    return p
  }

  isBackgroundFetch (p) {
    return p && typeof p === 'object' && typeof p.then === 'function' &&
      Object.prototype.hasOwnProperty.call(p, '__staleWhileFetching')
  }

  // this takes the union of get() and set() opts, because it does both
  async fetch (k, {
    allowStale = this.allowStale,
    updateAgeOnGet = this.updateAgeOnGet,
    ttl = this.ttl,
    noDisposeOnSet = this.noDisposeOnSet,
    size = 0,
    sizeCalculation = this.sizeCalculation,
    noUpdateTTL = this.noUpdateTTL,
  } = {}) {
    if (!this.fetchMethod) {
      return this.get(k, {allowStale, updateAgeOnGet})
    }

    const options = {
      allowStale,
      updateAgeOnGet,
      ttl,
      noDisposeOnSet,
      size,
      sizeCalculation,
      noUpdateTTL,
    }

    let index = this.keyMap.get(k)
    if (index === undefined) {
      return this.backgroundFetch(k, index, options)
    } else {
      // in cache, maybe already fetching
      const v = this.valList[index]
      if (this.isBackgroundFetch(v)) {
        return allowStale && v.__staleWhileFetching !== undefined
          ? v.__staleWhileFetching : v
      }

      if (!this.isStale(index)) {
        this.moveToTail(index)
        if (updateAgeOnGet) {
          this.updateItemAge(index)
        }
        return v
      }

      // ok, it is stale, and not already fetching
      // refresh the cache.
      const p = this.backgroundFetch(k, index, options)
      return allowStale && p.__staleWhileFetching !== undefined
        ? p.__staleWhileFetching : p
    }
  }

  get (k, {
    allowStale = this.allowStale,
    updateAgeOnGet = this.updateAgeOnGet,
  } = {}) {
    const index = this.keyMap.get(k)
    if (index !== undefined) {
      const value = this.valList[index]
      const fetching = this.isBackgroundFetch(value)
      if (this.isStale(index)) {
        // delete only if not an in-flight background fetch
        if (!fetching) {
          this.delete(k)
          return allowStale ? value : undefined
        } else {
          return allowStale ? value.__staleWhileFetching : undefined
        }
      } else {
        // if we're currently fetching it, we don't actually have it yet
        // it's not stale, which means this isn't a staleWhileRefetching,
        // so we just return undefined
        if (fetching) {
          return undefined
        }
        this.moveToTail(index)
        if (updateAgeOnGet) {
          this.updateItemAge(index)
        }
        return value
      }
    }
  }

  connect (p, n) {
    this.prev[n] = p
    this.next[p] = n
  }

  moveToTail (index) {
    // if tail already, nothing to do
    // if head, move head to next[index]
    // else
    //   move next[prev[index]] to next[index] (head has no prev)
    //   move prev[next[index]] to prev[index]
    // prev[index] = tail
    // next[tail] = index
    // tail = index
    if (index !== this.tail) {
      if (index === this.head) {
        this.head = this.next[index]
      } else {
        this.connect(this.prev[index], this.next[index])
      }
      this.connect(this.tail, index)
      this.tail = index
    }
  }

  get del () {
    deprecatedMethod('del', 'delete')
    return this.delete
  }

  delete (k) {
    let deleted = false
    if (this.size !== 0) {
      const index = this.keyMap.get(k)
      if (index !== undefined) {
        deleted = true
        if (this.size === 1) {
          this.clear()
        } else {
          this.removeItemSize(index)
          const v = this.valList[index]
          if (this.isBackgroundFetch(v)) {
            v.__abortController.abort()
          } else {
            this.dispose(v, k, 'delete')
            if (this.disposeAfter) {
              this.disposed.push([v, k, 'delete'])
            }
          }
          this.keyMap.delete(k)
          this.keyList[index] = null
          this.valList[index] = null
          if (index === this.tail) {
            this.tail = this.prev[index]
          } else if (index === this.head) {
            this.head = this.next[index]
          } else {
            this.next[this.prev[index]] = this.next[index]
            this.prev[this.next[index]] = this.prev[index]
          }
          this.size --
          this.free.push(index)
        }
      }
    }
    if (this.disposed) {
      while (this.disposed.length) {
        this.disposeAfter(...this.disposed.shift())
      }
    }
    return deleted
  }

  clear () {
    for (const index of this.rindexes({ allowStale: true })) {
      const v = this.valList[index]
      if (this.isBackgroundFetch(v)) {
        v.__abortController.abort()
      } else {
        const k = this.keyList[index]
        this.dispose(v, k, 'delete')
        if (this.disposeAfter) {
          this.disposed.push([v, k, 'delete'])
        }
      }
    }

    this.keyMap.clear()
    this.valList.fill(null)
    this.keyList.fill(null)
    if (this.ttls) {
      this.ttls.fill(0)
      this.starts.fill(0)
    }
    if (this.sizes) {
      this.sizes.fill(0)
    }
    this.head = 0
    this.tail = 0
    this.initialFill = 1
    this.free.length = 0
    this.calculatedSize = 0
    this.size = 0
    if (this.disposed) {
      while (this.disposed.length) {
        this.disposeAfter(...this.disposed.shift())
      }
    }
  }

  get reset () {
    deprecatedMethod('reset', 'clear')
    return this.clear
  }

  get length () {
    deprecatedProperty('length', 'size')
    return this.size
  }

  static get AbortController () {
    return AC
  }
}

module.exports = LRUCache


/***/ }),

/***/ "./.yarn/__virtual__/lezer-promql-virtual-eaf88aa77a/0/cache/lezer-promql-npm-0.22.0-867da6afaa-cdce054700.zip/node_modules/lezer-promql/index.es.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Abs": () => (/* binding */ Abs),
/* harmony export */   "Absent": () => (/* binding */ Absent),
/* harmony export */   "AbsentOverTime": () => (/* binding */ AbsentOverTime),
/* harmony export */   "Acos": () => (/* binding */ Acos),
/* harmony export */   "Acosh": () => (/* binding */ Acosh),
/* harmony export */   "Add": () => (/* binding */ Add),
/* harmony export */   "AggregateExpr": () => (/* binding */ AggregateExpr),
/* harmony export */   "AggregateModifier": () => (/* binding */ AggregateModifier),
/* harmony export */   "AggregateOp": () => (/* binding */ AggregateOp),
/* harmony export */   "And": () => (/* binding */ And$1),
/* harmony export */   "Asin": () => (/* binding */ Asin),
/* harmony export */   "Asinh": () => (/* binding */ Asinh),
/* harmony export */   "At": () => (/* binding */ At),
/* harmony export */   "AtModifierPreprocessors": () => (/* binding */ AtModifierPreprocessors),
/* harmony export */   "Atan": () => (/* binding */ Atan),
/* harmony export */   "Atan2": () => (/* binding */ Atan2$1),
/* harmony export */   "Atanh": () => (/* binding */ Atanh),
/* harmony export */   "Avg": () => (/* binding */ Avg$1),
/* harmony export */   "AvgOverTime": () => (/* binding */ AvgOverTime),
/* harmony export */   "BinModifiers": () => (/* binding */ BinModifiers),
/* harmony export */   "BinaryExpr": () => (/* binding */ BinaryExpr),
/* harmony export */   "Bool": () => (/* binding */ Bool$1),
/* harmony export */   "Bottomk": () => (/* binding */ Bottomk$1),
/* harmony export */   "By": () => (/* binding */ By$1),
/* harmony export */   "Ceil": () => (/* binding */ Ceil),
/* harmony export */   "Changes": () => (/* binding */ Changes),
/* harmony export */   "Clamp": () => (/* binding */ Clamp),
/* harmony export */   "ClampMax": () => (/* binding */ ClampMax),
/* harmony export */   "ClampMin": () => (/* binding */ ClampMin),
/* harmony export */   "Cos": () => (/* binding */ Cos),
/* harmony export */   "Cosh": () => (/* binding */ Cosh),
/* harmony export */   "Count": () => (/* binding */ Count$1),
/* harmony export */   "CountOverTime": () => (/* binding */ CountOverTime),
/* harmony export */   "CountValues": () => (/* binding */ CountValues$1),
/* harmony export */   "DayOfMonth": () => (/* binding */ DayOfMonth),
/* harmony export */   "DayOfWeek": () => (/* binding */ DayOfWeek),
/* harmony export */   "DaysInMonth": () => (/* binding */ DaysInMonth),
/* harmony export */   "Deg": () => (/* binding */ Deg),
/* harmony export */   "Delta": () => (/* binding */ Delta),
/* harmony export */   "Deriv": () => (/* binding */ Deriv),
/* harmony export */   "Div": () => (/* binding */ Div),
/* harmony export */   "Duration": () => (/* binding */ Duration),
/* harmony export */   "End": () => (/* binding */ End$1),
/* harmony export */   "Eql": () => (/* binding */ Eql),
/* harmony export */   "EqlRegex": () => (/* binding */ EqlRegex),
/* harmony export */   "EqlSingle": () => (/* binding */ EqlSingle),
/* harmony export */   "Exp": () => (/* binding */ Exp),
/* harmony export */   "Expr": () => (/* binding */ Expr),
/* harmony export */   "Floor": () => (/* binding */ Floor),
/* harmony export */   "FunctionCall": () => (/* binding */ FunctionCall),
/* harmony export */   "FunctionCallArgs": () => (/* binding */ FunctionCallArgs),
/* harmony export */   "FunctionCallBody": () => (/* binding */ FunctionCallBody),
/* harmony export */   "FunctionIdentifier": () => (/* binding */ FunctionIdentifier),
/* harmony export */   "Group": () => (/* binding */ Group$1),
/* harmony export */   "GroupLeft": () => (/* binding */ GroupLeft$1),
/* harmony export */   "GroupRight": () => (/* binding */ GroupRight$1),
/* harmony export */   "GroupingLabel": () => (/* binding */ GroupingLabel),
/* harmony export */   "GroupingLabelList": () => (/* binding */ GroupingLabelList),
/* harmony export */   "GroupingLabels": () => (/* binding */ GroupingLabels),
/* harmony export */   "Gte": () => (/* binding */ Gte),
/* harmony export */   "Gtr": () => (/* binding */ Gtr),
/* harmony export */   "HistogramQuantile": () => (/* binding */ HistogramQuantile),
/* harmony export */   "HoltWinters": () => (/* binding */ HoltWinters),
/* harmony export */   "Hour": () => (/* binding */ Hour),
/* harmony export */   "Idelta": () => (/* binding */ Idelta),
/* harmony export */   "Identifier": () => (/* binding */ Identifier),
/* harmony export */   "Ignoring": () => (/* binding */ Ignoring$1),
/* harmony export */   "Increase": () => (/* binding */ Increase),
/* harmony export */   "Irate": () => (/* binding */ Irate),
/* harmony export */   "LabelJoin": () => (/* binding */ LabelJoin),
/* harmony export */   "LabelMatchList": () => (/* binding */ LabelMatchList),
/* harmony export */   "LabelMatcher": () => (/* binding */ LabelMatcher),
/* harmony export */   "LabelMatchers": () => (/* binding */ LabelMatchers),
/* harmony export */   "LabelName": () => (/* binding */ LabelName),
/* harmony export */   "LabelReplace": () => (/* binding */ LabelReplace),
/* harmony export */   "LastOverTime": () => (/* binding */ LastOverTime),
/* harmony export */   "LineComment": () => (/* binding */ LineComment),
/* harmony export */   "Ln": () => (/* binding */ Ln),
/* harmony export */   "Log10": () => (/* binding */ Log10),
/* harmony export */   "Log2": () => (/* binding */ Log2),
/* harmony export */   "Lss": () => (/* binding */ Lss),
/* harmony export */   "Lte": () => (/* binding */ Lte),
/* harmony export */   "MatchOp": () => (/* binding */ MatchOp),
/* harmony export */   "MatrixSelector": () => (/* binding */ MatrixSelector),
/* harmony export */   "Max": () => (/* binding */ Max$1),
/* harmony export */   "MaxOverTime": () => (/* binding */ MaxOverTime),
/* harmony export */   "MetricIdentifier": () => (/* binding */ MetricIdentifier),
/* harmony export */   "MetricName": () => (/* binding */ MetricName),
/* harmony export */   "Min": () => (/* binding */ Min$1),
/* harmony export */   "MinOverTime": () => (/* binding */ MinOverTime),
/* harmony export */   "Minute": () => (/* binding */ Minute),
/* harmony export */   "Mod": () => (/* binding */ Mod),
/* harmony export */   "Month": () => (/* binding */ Month),
/* harmony export */   "Mul": () => (/* binding */ Mul),
/* harmony export */   "Neq": () => (/* binding */ Neq),
/* harmony export */   "NeqRegex": () => (/* binding */ NeqRegex),
/* harmony export */   "NumberLiteral": () => (/* binding */ NumberLiteral),
/* harmony export */   "Offset": () => (/* binding */ Offset$1),
/* harmony export */   "OffsetExpr": () => (/* binding */ OffsetExpr),
/* harmony export */   "On": () => (/* binding */ On$1),
/* harmony export */   "OnOrIgnoring": () => (/* binding */ OnOrIgnoring),
/* harmony export */   "Or": () => (/* binding */ Or$1),
/* harmony export */   "ParenExpr": () => (/* binding */ ParenExpr),
/* harmony export */   "Pi": () => (/* binding */ Pi),
/* harmony export */   "Pow": () => (/* binding */ Pow),
/* harmony export */   "PredictLinear": () => (/* binding */ PredictLinear),
/* harmony export */   "PresentOverTime": () => (/* binding */ PresentOverTime),
/* harmony export */   "PromQL": () => (/* binding */ PromQL),
/* harmony export */   "Quantile": () => (/* binding */ Quantile$1),
/* harmony export */   "QuantileOverTime": () => (/* binding */ QuantileOverTime),
/* harmony export */   "Rad": () => (/* binding */ Rad),
/* harmony export */   "Rate": () => (/* binding */ Rate),
/* harmony export */   "Resets": () => (/* binding */ Resets),
/* harmony export */   "Round": () => (/* binding */ Round),
/* harmony export */   "Scalar": () => (/* binding */ Scalar),
/* harmony export */   "Sgn": () => (/* binding */ Sgn),
/* harmony export */   "Sin": () => (/* binding */ Sin),
/* harmony export */   "Sinh": () => (/* binding */ Sinh),
/* harmony export */   "Sort": () => (/* binding */ Sort),
/* harmony export */   "SortDesc": () => (/* binding */ SortDesc),
/* harmony export */   "Sqrt": () => (/* binding */ Sqrt),
/* harmony export */   "Start": () => (/* binding */ Start$1),
/* harmony export */   "Stddev": () => (/* binding */ Stddev$1),
/* harmony export */   "StddevOverTime": () => (/* binding */ StddevOverTime),
/* harmony export */   "Stdvar": () => (/* binding */ Stdvar$1),
/* harmony export */   "StdvarOverTime": () => (/* binding */ StdvarOverTime),
/* harmony export */   "StepInvariantExpr": () => (/* binding */ StepInvariantExpr),
/* harmony export */   "StringLiteral": () => (/* binding */ StringLiteral),
/* harmony export */   "Sub": () => (/* binding */ Sub),
/* harmony export */   "SubqueryExpr": () => (/* binding */ SubqueryExpr),
/* harmony export */   "Sum": () => (/* binding */ Sum$1),
/* harmony export */   "SumOverTime": () => (/* binding */ SumOverTime),
/* harmony export */   "Tan": () => (/* binding */ Tan),
/* harmony export */   "Tanh": () => (/* binding */ Tanh),
/* harmony export */   "Time": () => (/* binding */ Time),
/* harmony export */   "Timestamp": () => (/* binding */ Timestamp),
/* harmony export */   "Topk": () => (/* binding */ Topk$1),
/* harmony export */   "UnaryExpr": () => (/* binding */ UnaryExpr),
/* harmony export */   "UnaryOp": () => (/* binding */ UnaryOp),
/* harmony export */   "Unless": () => (/* binding */ Unless$1),
/* harmony export */   "Vector": () => (/* binding */ Vector),
/* harmony export */   "VectorSelector": () => (/* binding */ VectorSelector),
/* harmony export */   "Without": () => (/* binding */ Without$1),
/* harmony export */   "Year": () => (/* binding */ Year),
/* harmony export */   "inf": () => (/* binding */ inf$1),
/* harmony export */   "nan": () => (/* binding */ nan$1),
/* harmony export */   "parser": () => (/* binding */ parser)
/* harmony export */ });
/* harmony import */ var _lezer_lr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@lezer-lr-npm-0.15.8-8c481c39cd-e741225d6a.zip/node_modules/@lezer/lr/dist/index.js");


// This file was generated by lezer-generator. You probably shouldn't edit it.
const 
  inf = 146,
  nan = 147,
  Bool = 1,
  Ignoring = 2,
  On = 3,
  GroupLeft = 4,
  GroupRight = 5,
  Offset = 6,
  Atan2 = 7,
  Avg = 8,
  Bottomk = 9,
  Count = 10,
  CountValues = 11,
  Group = 12,
  Max = 13,
  Min = 14,
  Quantile = 15,
  Stddev = 16,
  Stdvar = 17,
  Sum = 18,
  Topk = 19,
  By = 20,
  Without = 21,
  And = 22,
  Or = 23,
  Unless = 24,
  Start = 25,
  End = 26;

// Copyright 2021 The Prometheus Authors

const keywordTokens = {
    inf: inf,
    nan: nan,
    bool: Bool,
    ignoring: Ignoring,
    on: On,
    group_left: GroupLeft,
    group_right: GroupRight,
    offset: Offset,
};

const specializeIdentifier = (value, stack) => {
    return keywordTokens[value.toLowerCase()] || -1;
};

const contextualKeywordTokens = {
    avg: Avg,
    atan2: Atan2,
    bottomk: Bottomk,
    count: Count,
    count_values: CountValues,
    group: Group,
    max: Max,
    min: Min,
    quantile: Quantile,
    stddev: Stddev,
    stdvar: Stdvar,
    sum: Sum,
    topk: Topk,
    by: By,
    without: Without,
    and: And,
    or: Or,
    unless: Unless,
    start: Start,
    end: End,
};

const extendIdentifier = (value, stack) => {
    return contextualKeywordTokens[value.toLowerCase()] || -1;
};

// This file was generated by lezer-generator. You probably shouldn't edit it.
const spec_Identifier = {__proto__:null,absent_over_time:307, absent:309, abs:311, acos:313, acosh:315, asin:317, asinh:319, atan:321, atanh:323, avg_over_time:325, ceil:327, changes:329, clamp:331, clamp_max:333, clamp_min:335, cos:337, cosh:339, count_over_time:341, days_in_month:343, day_of_month:345, day_of_week:347, deg:349, delta:351, deriv:353, exp:355, floor:357, histogram_quantile:359, holt_winters:361, hour:363, idelta:365, increase:367, irate:369, label_replace:371, label_join:373, last_over_time:375, ln:377, log10:379, log2:381, max_over_time:383, min_over_time:385, minute:387, month:389, pi:391, predict_linear:393, present_over_time:395, quantile_over_time:397, rad:399, rate:401, resets:403, round:405, scalar:407, sgn:409, sin:411, sinh:413, sort:415, sort_desc:417, sqrt:419, stddev_over_time:421, stdvar_over_time:423, sum_over_time:425, tan:427, tanh:429, timestamp:431, time:433, vector:435, year:437};
const parser = _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.LRParser.deserialize({
  version: 13,
  states: "6[OYQPOOO&{QPOOOOQO'#C{'#C{O'QQPO'#CzQ']QQOOOOQO'#De'#DeO'WQPO'#DdOOQO'#E}'#E}O(jQPO'#FTOYQPO'#FPOYQPO'#FSOOQO'#FV'#FVO.fQSO'#FWO.nQQO'#FUOOQO'#FU'#FUOOQO'#Cy'#CyOOQO'#Df'#DfOOQO'#Dh'#DhOOQO'#Di'#DiOOQO'#Dj'#DjOOQO'#Dk'#DkOOQO'#Dl'#DlOOQO'#Dm'#DmOOQO'#Dn'#DnOOQO'#Do'#DoOOQO'#Dp'#DpOOQO'#Dq'#DqOOQO'#Dr'#DrOOQO'#Ds'#DsOOQO'#Dt'#DtOOQO'#Du'#DuOOQO'#Dv'#DvOOQO'#Dw'#DwOOQO'#Dx'#DxOOQO'#Dy'#DyOOQO'#Dz'#DzOOQO'#D{'#D{OOQO'#D|'#D|OOQO'#D}'#D}OOQO'#EO'#EOOOQO'#EP'#EPOOQO'#EQ'#EQOOQO'#ER'#EROOQO'#ES'#ESOOQO'#ET'#ETOOQO'#EU'#EUOOQO'#EV'#EVOOQO'#EW'#EWOOQO'#EX'#EXOOQO'#EY'#EYOOQO'#EZ'#EZOOQO'#E['#E[OOQO'#E]'#E]OOQO'#E^'#E^OOQO'#E_'#E_OOQO'#E`'#E`OOQO'#Ea'#EaOOQO'#Eb'#EbOOQO'#Ec'#EcOOQO'#Ed'#EdOOQO'#Ee'#EeOOQO'#Ef'#EfOOQO'#Eg'#EgOOQO'#Eh'#EhOOQO'#Ei'#EiOOQO'#Ej'#EjOOQO'#Ek'#EkOOQO'#El'#ElOOQO'#Em'#EmOOQO'#En'#EnOOQO'#Eo'#EoOOQO'#Ep'#EpOOQO'#Eq'#EqOOQO'#Er'#ErOOQO'#Es'#EsOOQO'#Et'#EtOOQO'#Eu'#EuOOQO'#Ev'#EvOOQO'#Ew'#EwOOQO'#Ex'#ExOOQO'#Ey'#EyOOQO'#Ez'#EzQOQPOOO0XQPO'#C|O0^QPO'#DRO'WQPO,59fO0eQQO,59fO2RQPO,59oO2RQPO,59oO2RQPO,59oO2RQPO,59oO2RQPO,59oO7}QQO,5;gO8SQQO,5;jO8[QPO,5;yOOQO,5:O,5:OOOQO,5;i,5;iO8sQQO,5;kO8zQQO,5;nO:bQPO'#FYO:pQPO,5;rOOQO'#FX'#FXOOQO,5;r,5;rOOQO,5;p,5;pO:xQSO'#C}OOQO,59h,59hO;QQPO,59mO;YQQO'#DSOOQO,59m,59mOOQO1G/Q1G/QO0XQPO'#DWOAVQPO'#DVOAaQPO'#DVOYQPO1G/ZOYQPO1G/ZOYQPO1G/ZOYQPO1G/ZOYQPO1G/ZOAkQSO1G1ROOQO1G1U1G1UOAsQQO1G1UOAxQPO'#E}OOQO'#Fa'#FaOOQO1G1e1G1eOBTQPO1G1eOOQO1G1V1G1VOOQO'#FZ'#FZOBYQPO,5;tOB_QSO1G1^OOQO1G1^1G1^OOQO'#DP'#DPOBgQPO,59iOOQO'#DO'#DOOOQO,59i,59iOYQPO,59nOOQO1G/X1G/XOOQO,59r,59rOH_QPO,59qOHfQPO,59qOI}QQO7+$uOJ_QQO7+$uOKsQQO7+$uOLZQQO7+$uOMrQQO7+$uOOQO7+&m7+&mON]QQO7+&sOOQO7+&p7+&pONeQPO7+'POOQO1G1`1G1`OOQO1G1_1G1_OOQO7+&x7+&xONjQSO1G/TOOQO1G/T1G/TONrQQO1G/YOOQO1G/]1G/]ON|QPO1G/]OOQO<<J_<<J_O!&oQPO<<J_OOQO<<Jk<<JkOOQO1G/U1G/UOOQO7+$o7+$oOOQO7+$w7+$wOOQOAN?yAN?y",
  stateData: "!&t~O$ZOSkOS~OWQOXQOYQOZQO[QO]QO^QO_QO`QOaQObQOcQO!ZZO#t_O$WVO$XVO$[XO$_`O$`aO$abO$bcO$cdO$deO$efO$fgO$ghO$hiO$ijO$jkO$klO$lmO$mnO$noO$opO$pqO$qrO$rsO$stO$tuO$uvO$vwO$wxO$xyO$yzO$z{O${|O$|}O$}!OO%O!PO%P!QO%Q!RO%R!SO%S!TO%T!UO%U!VO%V!WO%W!XO%X!YO%Y!ZO%Z![O%[!]O%]!^O%^!_O%_!`O%`!aO%a!bO%b!cO%c!dO%d!eO%e!fO%f!gO%g!hO%h!iO%i!jO%j!kO%k!lO%l!mO%m!nO%n!oO%o!pO%p!qO%q!rO%r!sO%uWO%vWO%wVO%y[O~O!ZZO~Od!uOe!uO$[!vO~OU#POV!yOf!|Og!}Oh!|Ox!yO{!yO|!yO}!yO!O!zO!P!zO!Q!{O!R!{O!S!{O!T!{O!U!{O!V!{O$S#QO%s#OO~O$W#SO$X#SO%w#SOW#wXX#wXY#wXZ#wX[#wX]#wX^#wX_#wX`#wXa#wXb#wXc#wX!Z#wX#t#wX$W#wX$X#wX$[#wX$_#wX$`#wX$a#wX$b#wX$c#wX$d#wX$e#wX$f#wX$g#wX$h#wX$i#wX$j#wX$k#wX$l#wX$m#wX$n#wX$o#wX$p#wX$q#wX$r#wX$s#wX$t#wX$u#wX$v#wX$w#wX$x#wX$y#wX$z#wX${#wX$|#wX$}#wX%O#wX%P#wX%Q#wX%R#wX%S#wX%T#wX%U#wX%V#wX%W#wX%X#wX%Y#wX%Z#wX%[#wX%]#wX%^#wX%_#wX%`#wX%a#wX%b#wX%c#wX%d#wX%e#wX%f#wX%g#wX%h#wX%i#wX%j#wX%k#wX%l#wX%m#wX%n#wX%o#wX%p#wX%q#wX%r#wX%u#wX%v#wX%w#wX%y#wX~Ot#VO%z#YO~O%y[OU#xXV#xXf#xXg#xXh#xXx#xX{#xX|#xX}#xX!O#xX!P#xX!Q#xX!R#xX!S#xX!T#xX!U#xX!V#xX$S#xX$V#xX%s#xX$^#xX$]#xX~O$[#[O~O$^#`O~PYOd!uOe!uOUnaVnafnagnahnaxna{na|na}na!Ona!Pna!Qna!Rna!Sna!Tna!Una!Vna$Sna$Vna%sna$^na$]na~OP#dOQ#bOR#bOWyPXyPYyPZyP[yP]yP^yP_yP`yPayPbyPcyP!ZyP#tyP$WyP$XyP$[yP$_yP$`yP$ayP$byP$cyP$dyP$eyP$fyP$gyP$hyP$iyP$jyP$kyP$lyP$myP$nyP$oyP$pyP$qyP$ryP$syP$tyP$uyP$vyP$wyP$xyP$yyP$zyP${yP$|yP$}yP%OyP%PyP%QyP%RyP%SyP%TyP%UyP%VyP%WyP%XyP%YyP%ZyP%[yP%]yP%^yP%_yP%`yP%ayP%byP%cyP%dyP%eyP%fyP%gyP%hyP%iyP%jyP%kyP%lyP%myP%nyP%oyP%pyP%qyP%ryP%uyP%vyP%wyP%yyP~O#p#jO~O!P#lO#p#kO~Oi#nOj#nO$WVO$XVO%u#mO%v#mO%wVO~O$^#qO~P']Ox!yOU#vaV#vaf#vag#vah#va{#va|#va}#va!O#va!P#va!Q#va!R#va!S#va!T#va!U#va!V#va$S#va$V#va%s#va$^#va$]#va~O!V#rO$O#rO$P#rO$Q#rO~O$]#tO%z#uO~Ot#vO$^#yO~O$]#zO$^#{O~O$]vX$^vX~P']OWyXXyXYyXZyX[yX]yX^yX_yX`yXayXbyXcyX!ZyX#tyX$WyX$XyX$[yX$_yX$`yX$ayX$byX$cyX$dyX$eyX$fyX$gyX$hyX$iyX$jyX$kyX$lyX$myX$nyX$oyX$pyX$qyX$ryX$syX$tyX$uyX$vyX$wyX$xyX$yyX$zyX${yX$|yX$}yX%OyX%PyX%QyX%RyX%SyX%TyX%UyX%VyX%WyX%XyX%YyX%ZyX%[yX%]yX%^yX%_yX%`yX%ayX%byX%cyX%dyX%eyX%fyX%gyX%hyX%iyX%jyX%kyX%lyX%myX%nyX%oyX%pyX%qyX%ryX%uyX%vyX%wyX%yyX~OS#}OT#}O~P;dOQ#bOR#bO~P;dO%t$UO%x$VO~O#p$WO~O$W#SO$X#SO%w#SO~O$[$XO~O#t$YO~Ot#VO%z$[O~O$]$]O$^$^O~OWyaXyaYyaZya[ya]ya^ya_ya`yaayabyacya!Zya#tya$Wya$Xya$_ya$`ya$aya$bya$cya$dya$eya$fya$gya$hya$iya$jya$kya$lya$mya$nya$oya$pya$qya$rya$sya$tya$uya$vya$wya$xya$yya$zya${ya$|ya$}ya%Oya%Pya%Qya%Rya%Sya%Tya%Uya%Vya%Wya%Xya%Yya%Zya%[ya%]ya%^ya%_ya%`ya%aya%bya%cya%dya%eya%fya%gya%hya%iya%jya%kya%lya%mya%nya%oya%pya%qya%rya%uya%vya%wya%yya~O$[#[O~PBoOS$aOT$aO$[ya~PBoOx!yOUwqfwqgwqhwq!Owq!Pwq!Qwq!Rwq!Swq!Twq!Uwq!Vwq$Swq$Vwq%swq$^wq$]wq~OVwq{wq|wq}wq~PHsOV!yO{!yO|!yO}!yO~PHsOV!yOx!yO{!yO|!yO}!yO!O!zO!P!zOUwqfwqgwqhwq$Swq$Vwq%swq$^wq$]wq~O!Qwq!Rwq!Swq!Twq!Uwq!Vwq~PJoO!Q!{O!R!{O!S!{O!T!{O!U!{O!V!{O~PJoOV!yOf!|Oh!|Ox!yO{!yO|!yO}!yO!O!zO!P!zO!Q!{O!R!{O!S!{O!T!{O!U!{O!V!{O~OUwqgwq$Swq$Vwq%swq$^wq$]wq~PLqO#p$cO%t$bO~O$^$dO~Ot#vO$^$fO~O$]vi$^vi~P']O$[#[OWyiXyiYyiZyi[yi]yi^yi_yi`yiayibyicyi!Zyi#tyi$Wyi$Xyi$_yi$`yi$ayi$byi$cyi$dyi$eyi$fyi$gyi$hyi$iyi$jyi$kyi$lyi$myi$nyi$oyi$pyi$qyi$ryi$syi$tyi$uyi$vyi$wyi$xyi$yyi$zyi${yi$|yi$}yi%Oyi%Pyi%Qyi%Ryi%Syi%Tyi%Uyi%Vyi%Wyi%Xyi%Yyi%Zyi%[yi%]yi%^yi%_yi%`yi%ayi%byi%cyi%dyi%eyi%fyi%gyi%hyi%iyi%jyi%kyi%lyi%myi%nyi%oyi%pyi%qyi%ryi%uyi%vyi%wyi%yyi~O%t$hO~O",
  goto: "(u$UPPPPPPPPPPPPPPPPPPPPPPPPPPPPP$V$u%R%_%e%q%tP%z&T$uP&W&gPPPPPPPPPPP$u&q&}P&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}$uP'Z$u$uP$u$u'j$u'v(V(f(i(oPPP$uP(rQSOQ#TXQ#UYQ#_!vQ$P#eQ$Q#fQ$R#gQ$S#hQ$T#iR$_#ze_OXY!v#e#f#g#h#i#zeROXY!v#e#f#g#h#i#zQ!wRR#a!xQ#]!uQ#|#bQ$`#}R$g$aR#w#[Q#x#[R$e$]Q!xRQ#RUR#a!wR#^!vQ#e!yQ#f!zQ#g!{Q#h!|R#i!}Y#c!y!z!{!|!}R$O#deUOXY!v#e#f#g#h#i#zeTOXY!v#e#f#g#h#i#zd_OXY!v#e#f#g#h#i#zR#o#QeYOXY!v#e#f#g#h#i#zd]OXY!v#e#f#g#h#i#zR!tPd^OXY!v#e#f#g#h#i#zR#Z]R#W[Q#X[R$Z#tR#s#VR#p#Q",
  nodeNames: " Bool Ignoring On GroupLeft GroupRight Offset Atan2 Avg Bottomk Count CountValues Group Max Min Quantile Stddev Stdvar Sum Topk By Without And Or Unless Start End LineComment PromQL Expr AggregateExpr AggregateOp AggregateModifier GroupingLabels GroupingLabelList GroupingLabel LabelName FunctionCallBody FunctionCallArgs BinaryExpr Pow BinModifiers OnOrIgnoring Mul Div Mod Add Sub Eql Gte Gtr Lte Lss Neq FunctionCall FunctionIdentifier AbsentOverTime Identifier Absent Abs Acos Acosh Asin Asinh Atan Atanh AvgOverTime Ceil Changes Clamp ClampMax ClampMin Cos Cosh CountOverTime DaysInMonth DayOfMonth DayOfWeek Deg Delta Deriv Exp Floor HistogramQuantile HoltWinters Hour Idelta Increase Irate LabelReplace LabelJoin LastOverTime Ln Log10 Log2 MaxOverTime MinOverTime Minute Month Pi PredictLinear PresentOverTime QuantileOverTime Rad Rate Resets Round Scalar Sgn Sin Sinh Sort SortDesc Sqrt StddevOverTime StdvarOverTime SumOverTime Tan Tanh Timestamp Time Vector Year MatrixSelector Duration NumberLiteral OffsetExpr ParenExpr StringLiteral SubqueryExpr UnaryExpr UnaryOp VectorSelector MetricIdentifier LabelMatchers LabelMatchList LabelMatcher MatchOp EqlSingle EqlRegex NeqRegex StepInvariantExpr At AtModifierPreprocessors MetricName",
  maxTerm: 226,
  skippedNodes: [0,27],
  repeatNodeCount: 0,
  tokenData: "1R~RwX^#lpq#lqr$ars$tst%huv%swx%xxy&gyz&lz{&q{|&v|}&}}!O'S!O!P'Z!P!Q(Z!Q!R(`!R![)W![!]-r!^!_.n!_!`.{!`!a/b!b!c/o!c!}/t!}#O0[#P#Q0a#Q#R0f#R#S/t#S#T0k#T#o/t#o#p0w#q#r0|#y#z#l$f$g#l#BY#BZ#l$IS$I_#l$I|$JO#l$JT$JU#l$KV$KW#l&FU&FV#l~#qY$Z~X^#lpq#l#y#z#l$f$g#l#BY#BZ#l$IS$I_#l$I|$JO#l$JT$JU#l$KV$KW#l&FU&FV#l~$dQ!_!`$j#r#s$o~$oO!V~~$tO$Q~~$yU#t~OY$tZr$trs%]s#O$t#O#P%b#P~$t~%bO#t~~%ePO~$t~%mQk~OY%hZ~%h~%xO}~~%}U#t~OY%xZw%xwx%]x#O%x#O#P&a#P~%x~&dPO~%x~&lO$[~~&qO$^~~&vO{~R&}O%vP!OQ~'SO$]~R'ZO%uP!PQP'^P!Q!['aP'fR%wP!Q!['a!g!h'o#X#Y'oP'rR{|'{}!O'{!Q![(RP(OP!Q![(RP(WP%wP!Q![(R~(`O|~R(eZ%wP!O!P'a!Q![)W!g!h'o#W#X){#X#Y'o#[#]*d#a#b*x#g#h+l#k#l+}#l#m-W#m#n,iR)]Y%wP!O!P'a!Q![)W!g!h'o#W#X){#X#Y'o#[#]*d#a#b*x#g#h+l#k#l+}#m#n,iQ*QP#pQ!Q![*TQ*WS!Q![*T#[#]*d#a#b*x#g#h+lQ*iP#pQ!Q![*lQ*oR!Q![*l#a#b*x#g#h+lQ*}Q#pQ!Q![+T#g#h+gQ+WR!Q![+T#a#b+a#g#h+lQ+dP#g#h+gQ+lO#pQQ+qP#pQ!Q![+tQ+wQ!Q![+t#a#b+aQ,SP#pQ!Q![,VQ,YT!Q![,V#W#X){#[#]*d#a#b*x#g#h+lQ,nP#pQ!Q![,qQ,tU!Q![,q#W#X){#[#]*d#a#b*x#g#h+l#k#l+}P-ZR!Q![-d!c!i-d#T#Z-dP-iR%wP!Q![-d!c!i-d#T#Z-dV-yT%xS!ZR!Q![.Y![!].Y!c!}.Y#R#S.Y#T#o.YR._T!ZR!Q![.Y![!].Y!c!}.Y#R#S.Y#T#o.Y~.sP!U~!_!`.v~.{O!T~~/QQ$OP!_!`/W#r#s/]Q/]O!QQ~/bO$P~~/gP!S~!_!`/j~/oO!R~~/tO$S~V/{T!ZRtS!Q![/t![!].Y!c!}/t#R#S/t#T#o/t~0aO%s~~0fO%t~~0kOx~~0nRO#S0k#S#T%]#T~0k~0|O%y~~1RO%z~",
  tokenizers: [0, 1, 2],
  topRules: {"PromQL":[0,28],"MetricName":[1,144]},
  specialized: [{term: 57, get: (value, stack) => (specializeIdentifier(value) << 1)},{term: 57, get: (value, stack) => (extendIdentifier(value) << 1) | 1},{term: 57, get: value => spec_Identifier[value] || -1}],
  tokenPrec: 0
});
// This file was generated by lezer-generator. You probably shouldn't edit it.
const 
  inf$1 = 146,
  nan$1 = 147,
  Bool$1 = 1,
  Ignoring$1 = 2,
  On$1 = 3,
  GroupLeft$1 = 4,
  GroupRight$1 = 5,
  Offset$1 = 6,
  Atan2$1 = 7,
  Avg$1 = 8,
  Bottomk$1 = 9,
  Count$1 = 10,
  CountValues$1 = 11,
  Group$1 = 12,
  Max$1 = 13,
  Min$1 = 14,
  Quantile$1 = 15,
  Stddev$1 = 16,
  Stdvar$1 = 17,
  Sum$1 = 18,
  Topk$1 = 19,
  By$1 = 20,
  Without$1 = 21,
  And$1 = 22,
  Or$1 = 23,
  Unless$1 = 24,
  Start$1 = 25,
  End$1 = 26,
  LineComment = 27,
  PromQL = 28,
  Expr = 29,
  AggregateExpr = 30,
  AggregateOp = 31,
  AggregateModifier = 32,
  GroupingLabels = 33,
  GroupingLabelList = 34,
  GroupingLabel = 35,
  LabelName = 36,
  FunctionCallBody = 37,
  FunctionCallArgs = 38,
  BinaryExpr = 39,
  Pow = 40,
  BinModifiers = 41,
  OnOrIgnoring = 42,
  Mul = 43,
  Div = 44,
  Mod = 45,
  Add = 46,
  Sub = 47,
  Eql = 48,
  Gte = 49,
  Gtr = 50,
  Lte = 51,
  Lss = 52,
  Neq = 53,
  FunctionCall = 54,
  FunctionIdentifier = 55,
  AbsentOverTime = 56,
  Identifier = 57,
  Absent = 58,
  Abs = 59,
  Acos = 60,
  Acosh = 61,
  Asin = 62,
  Asinh = 63,
  Atan = 64,
  Atanh = 65,
  AvgOverTime = 66,
  Ceil = 67,
  Changes = 68,
  Clamp = 69,
  ClampMax = 70,
  ClampMin = 71,
  Cos = 72,
  Cosh = 73,
  CountOverTime = 74,
  DaysInMonth = 75,
  DayOfMonth = 76,
  DayOfWeek = 77,
  Deg = 78,
  Delta = 79,
  Deriv = 80,
  Exp = 81,
  Floor = 82,
  HistogramQuantile = 83,
  HoltWinters = 84,
  Hour = 85,
  Idelta = 86,
  Increase = 87,
  Irate = 88,
  LabelReplace = 89,
  LabelJoin = 90,
  LastOverTime = 91,
  Ln = 92,
  Log10 = 93,
  Log2 = 94,
  MaxOverTime = 95,
  MinOverTime = 96,
  Minute = 97,
  Month = 98,
  Pi = 99,
  PredictLinear = 100,
  PresentOverTime = 101,
  QuantileOverTime = 102,
  Rad = 103,
  Rate = 104,
  Resets = 105,
  Round = 106,
  Scalar = 107,
  Sgn = 108,
  Sin = 109,
  Sinh = 110,
  Sort = 111,
  SortDesc = 112,
  Sqrt = 113,
  StddevOverTime = 114,
  StdvarOverTime = 115,
  SumOverTime = 116,
  Tan = 117,
  Tanh = 118,
  Timestamp = 119,
  Time = 120,
  Vector = 121,
  Year = 122,
  MatrixSelector = 123,
  Duration = 124,
  NumberLiteral = 125,
  OffsetExpr = 126,
  ParenExpr = 127,
  StringLiteral = 128,
  SubqueryExpr = 129,
  UnaryExpr = 130,
  UnaryOp = 131,
  VectorSelector = 132,
  MetricIdentifier = 133,
  LabelMatchers = 134,
  LabelMatchList = 135,
  LabelMatcher = 136,
  MatchOp = 137,
  EqlSingle = 138,
  EqlRegex = 139,
  NeqRegex = 140,
  StepInvariantExpr = 141,
  At = 142,
  AtModifierPreprocessors = 143,
  MetricName = 144;




/***/ }),

/***/ "./.yarn/cache/@lezer-common-npm-0.15.12-62017272b0-dae6581618.zip/node_modules/@lezer/common/dist/index.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DefaultBufferLength": () => (/* binding */ DefaultBufferLength),
/* harmony export */   "MountedTree": () => (/* binding */ MountedTree),
/* harmony export */   "NodeProp": () => (/* binding */ NodeProp),
/* harmony export */   "NodeSet": () => (/* binding */ NodeSet),
/* harmony export */   "NodeType": () => (/* binding */ NodeType),
/* harmony export */   "Parser": () => (/* binding */ Parser),
/* harmony export */   "Tree": () => (/* binding */ Tree),
/* harmony export */   "TreeBuffer": () => (/* binding */ TreeBuffer),
/* harmony export */   "TreeCursor": () => (/* binding */ TreeCursor),
/* harmony export */   "TreeFragment": () => (/* binding */ TreeFragment),
/* harmony export */   "parseMixed": () => (/* binding */ parseMixed)
/* harmony export */ });
// FIXME profile adding a per-Tree TreeNode cache, validating it by
// parent pointer
/// The default maximum length of a `TreeBuffer` node (1024).
const DefaultBufferLength = 1024;
let nextPropID = 0;
class Range {
    constructor(from, to) {
        this.from = from;
        this.to = to;
    }
}
/// Each [node type](#common.NodeType) or [individual tree](#common.Tree)
/// can have metadata associated with it in props. Instances of this
/// class represent prop names.
class NodeProp {
    /// Create a new node prop type.
    constructor(config = {}) {
        this.id = nextPropID++;
        this.perNode = !!config.perNode;
        this.deserialize = config.deserialize || (() => {
            throw new Error("This node type doesn't define a deserialize function");
        });
    }
    /// This is meant to be used with
    /// [`NodeSet.extend`](#common.NodeSet.extend) or
    /// [`LRParser.configure`](#lr.ParserConfig.props) to compute
    /// prop values for each node type in the set. Takes a [match
    /// object](#common.NodeType^match) or function that returns undefined
    /// if the node type doesn't get this prop, and the prop's value if
    /// it does.
    add(match) {
        if (this.perNode)
            throw new RangeError("Can't add per-node props to node types");
        if (typeof match != "function")
            match = NodeType.match(match);
        return (type) => {
            let result = match(type);
            return result === undefined ? null : [this, result];
        };
    }
}
/// Prop that is used to describe matching delimiters. For opening
/// delimiters, this holds an array of node names (written as a
/// space-separated string when declaring this prop in a grammar)
/// for the node types of closing delimiters that match it.
NodeProp.closedBy = new NodeProp({ deserialize: str => str.split(" ") });
/// The inverse of [`closedBy`](#common.NodeProp^closedBy). This is
/// attached to closing delimiters, holding an array of node names
/// of types of matching opening delimiters.
NodeProp.openedBy = new NodeProp({ deserialize: str => str.split(" ") });
/// Used to assign node types to groups (for example, all node
/// types that represent an expression could be tagged with an
/// `"Expression"` group).
NodeProp.group = new NodeProp({ deserialize: str => str.split(" ") });
/// The hash of the [context](#lr.ContextTracker.constructor)
/// that the node was parsed in, if any. Used to limit reuse of
/// contextual nodes.
NodeProp.contextHash = new NodeProp({ perNode: true });
/// The distance beyond the end of the node that the tokenizer
/// looked ahead for any of the tokens inside the node. (The LR
/// parser only stores this when it is larger than 25, for
/// efficiency reasons.)
NodeProp.lookAhead = new NodeProp({ perNode: true });
/// This per-node prop is used to replace a given node, or part of a
/// node, with another tree. This is useful to include trees from
/// different languages.
NodeProp.mounted = new NodeProp({ perNode: true });
/// A mounted tree, which can be [stored](#common.NodeProp^mounted) on
/// a tree node to indicate that parts of its content are
/// represented by another tree.
class MountedTree {
    constructor(
    /// The inner tree.
    tree, 
    /// If this is null, this tree replaces the entire node (it will
    /// be included in the regular iteration instead of its host
    /// node). If not, only the given ranges are considered to be
    /// covered by this tree. This is used for trees that are mixed in
    /// a way that isn't strictly hierarchical. Such mounted trees are
    /// only entered by [`resolveInner`](#common.Tree.resolveInner)
    /// and [`enter`](#common.SyntaxNode.enter).
    overlay, 
    /// The parser used to create this subtree.
    parser) {
        this.tree = tree;
        this.overlay = overlay;
        this.parser = parser;
    }
}
const noProps = Object.create(null);
/// Each node in a syntax tree has a node type associated with it.
class NodeType {
    /// @internal
    constructor(
    /// The name of the node type. Not necessarily unique, but if the
    /// grammar was written properly, different node types with the
    /// same name within a node set should play the same semantic
    /// role.
    name, 
    /// @internal
    props, 
    /// The id of this node in its set. Corresponds to the term ids
    /// used in the parser.
    id, 
    /// @internal
    flags = 0) {
        this.name = name;
        this.props = props;
        this.id = id;
        this.flags = flags;
    }
    static define(spec) {
        let props = spec.props && spec.props.length ? Object.create(null) : noProps;
        let flags = (spec.top ? 1 /* Top */ : 0) | (spec.skipped ? 2 /* Skipped */ : 0) |
            (spec.error ? 4 /* Error */ : 0) | (spec.name == null ? 8 /* Anonymous */ : 0);
        let type = new NodeType(spec.name || "", props, spec.id, flags);
        if (spec.props)
            for (let src of spec.props) {
                if (!Array.isArray(src))
                    src = src(type);
                if (src) {
                    if (src[0].perNode)
                        throw new RangeError("Can't store a per-node prop on a node type");
                    props[src[0].id] = src[1];
                }
            }
        return type;
    }
    /// Retrieves a node prop for this type. Will return `undefined` if
    /// the prop isn't present on this node.
    prop(prop) { return this.props[prop.id]; }
    /// True when this is the top node of a grammar.
    get isTop() { return (this.flags & 1 /* Top */) > 0; }
    /// True when this node is produced by a skip rule.
    get isSkipped() { return (this.flags & 2 /* Skipped */) > 0; }
    /// Indicates whether this is an error node.
    get isError() { return (this.flags & 4 /* Error */) > 0; }
    /// When true, this node type doesn't correspond to a user-declared
    /// named node, for example because it is used to cache repetition.
    get isAnonymous() { return (this.flags & 8 /* Anonymous */) > 0; }
    /// Returns true when this node's name or one of its
    /// [groups](#common.NodeProp^group) matches the given string.
    is(name) {
        if (typeof name == 'string') {
            if (this.name == name)
                return true;
            let group = this.prop(NodeProp.group);
            return group ? group.indexOf(name) > -1 : false;
        }
        return this.id == name;
    }
    /// Create a function from node types to arbitrary values by
    /// specifying an object whose property names are node or
    /// [group](#common.NodeProp^group) names. Often useful with
    /// [`NodeProp.add`](#common.NodeProp.add). You can put multiple
    /// names, separated by spaces, in a single property name to map
    /// multiple node names to a single value.
    static match(map) {
        let direct = Object.create(null);
        for (let prop in map)
            for (let name of prop.split(" "))
                direct[name] = map[prop];
        return (node) => {
            for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
                let found = direct[i < 0 ? node.name : groups[i]];
                if (found)
                    return found;
            }
        };
    }
}
/// An empty dummy node type to use when no actual type is available.
NodeType.none = new NodeType("", Object.create(null), 0, 8 /* Anonymous */);
/// A node set holds a collection of node types. It is used to
/// compactly represent trees by storing their type ids, rather than a
/// full pointer to the type object, in a numeric array. Each parser
/// [has](#lr.LRParser.nodeSet) a node set, and [tree
/// buffers](#common.TreeBuffer) can only store collections of nodes
/// from the same set. A set can have a maximum of 2**16 (65536) node
/// types in it, so that the ids fit into 16-bit typed array slots.
class NodeSet {
    /// Create a set with the given types. The `id` property of each
    /// type should correspond to its position within the array.
    constructor(
    /// The node types in this set, by id.
    types) {
        this.types = types;
        for (let i = 0; i < types.length; i++)
            if (types[i].id != i)
                throw new RangeError("Node type ids should correspond to array positions when creating a node set");
    }
    /// Create a copy of this set with some node properties added. The
    /// arguments to this method should be created with
    /// [`NodeProp.add`](#common.NodeProp.add).
    extend(...props) {
        let newTypes = [];
        for (let type of this.types) {
            let newProps = null;
            for (let source of props) {
                let add = source(type);
                if (add) {
                    if (!newProps)
                        newProps = Object.assign({}, type.props);
                    newProps[add[0].id] = add[1];
                }
            }
            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
        }
        return new NodeSet(newTypes);
    }
}
const CachedNode = new WeakMap(), CachedInnerNode = new WeakMap();
/// A piece of syntax tree. There are two ways to approach these
/// trees: the way they are actually stored in memory, and the
/// convenient way.
///
/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`
/// objects. By packing detail information into `TreeBuffer` leaf
/// nodes, the representation is made a lot more memory-efficient.
///
/// However, when you want to actually work with tree nodes, this
/// representation is very awkward, so most client code will want to
/// use the [`TreeCursor`](#common.TreeCursor) or
/// [`SyntaxNode`](#common.SyntaxNode) interface instead, which provides
/// a view on some part of this data structure, and can be used to
/// move around to adjacent nodes.
class Tree {
    /// Construct a new tree. See also [`Tree.build`](#common.Tree^build).
    constructor(
    /// The type of the top node.
    type, 
    /// This node's child nodes.
    children, 
    /// The positions (offsets relative to the start of this tree) of
    /// the children.
    positions, 
    /// The total length of this tree
    length, 
    /// Per-node [node props](#common.NodeProp) to associate with this node.
    props) {
        this.type = type;
        this.children = children;
        this.positions = positions;
        this.length = length;
        /// @internal
        this.props = null;
        if (props && props.length) {
            this.props = Object.create(null);
            for (let [prop, value] of props)
                this.props[typeof prop == "number" ? prop : prop.id] = value;
        }
    }
    /// @internal
    toString() {
        let mounted = this.prop(NodeProp.mounted);
        if (mounted && !mounted.overlay)
            return mounted.tree.toString();
        let children = "";
        for (let ch of this.children) {
            let str = ch.toString();
            if (str) {
                if (children)
                    children += ",";
                children += str;
            }
        }
        return !this.type.name ? children :
            (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +
                (children.length ? "(" + children + ")" : "");
    }
    /// Get a [tree cursor](#common.TreeCursor) rooted at this tree. When
    /// `pos` is given, the cursor is [moved](#common.TreeCursor.moveTo)
    /// to the given position and side.
    cursor(pos, side = 0) {
        let scope = (pos != null && CachedNode.get(this)) || this.topNode;
        let cursor = new TreeCursor(scope);
        if (pos != null) {
            cursor.moveTo(pos, side);
            CachedNode.set(this, cursor._tree);
        }
        return cursor;
    }
    /// Get a [tree cursor](#common.TreeCursor) that, unlike regular
    /// cursors, doesn't skip through
    /// [anonymous](#common.NodeType.isAnonymous) nodes and doesn't
    /// automatically enter mounted nodes.
    fullCursor() {
        return new TreeCursor(this.topNode, 1 /* Full */);
    }
    /// Get a [syntax node](#common.SyntaxNode) object for the top of the
    /// tree.
    get topNode() {
        return new TreeNode(this, 0, 0, null);
    }
    /// Get the [syntax node](#common.SyntaxNode) at the given position.
    /// If `side` is -1, this will move into nodes that end at the
    /// position. If 1, it'll move into nodes that start at the
    /// position. With 0, it'll only enter nodes that cover the position
    /// from both sides.
    resolve(pos, side = 0) {
        let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
        CachedNode.set(this, node);
        return node;
    }
    /// Like [`resolve`](#common.Tree.resolve), but will enter
    /// [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
    /// pointing into the innermost overlaid tree at the given position
    /// (with parent links going through all parent structure, including
    /// the host trees).
    resolveInner(pos, side = 0) {
        let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
        CachedInnerNode.set(this, node);
        return node;
    }
    /// Iterate over the tree and its children, calling `enter` for any
    /// node that touches the `from`/`to` region (if given) before
    /// running over such a node's children, and `leave` (if given) when
    /// leaving the node. When `enter` returns `false`, that node will
    /// not have its children iterated over (or `leave` called).
    iterate(spec) {
        let { enter, leave, from = 0, to = this.length } = spec;
        for (let c = this.cursor(), get = () => c.node;;) {
            let mustLeave = false;
            if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c.type, c.from, c.to, get) !== false)) {
                if (c.firstChild())
                    continue;
                if (!c.type.isAnonymous)
                    mustLeave = true;
            }
            for (;;) {
                if (mustLeave && leave)
                    leave(c.type, c.from, c.to, get);
                mustLeave = c.type.isAnonymous;
                if (c.nextSibling())
                    break;
                if (!c.parent())
                    return;
                mustLeave = true;
            }
        }
    }
    /// Get the value of the given [node prop](#common.NodeProp) for this
    /// node. Works with both per-node and per-type props.
    prop(prop) {
        return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined;
    }
    /// Returns the node's [per-node props](#common.NodeProp.perNode) in a
    /// format that can be passed to the [`Tree`](#common.Tree)
    /// constructor.
    get propValues() {
        let result = [];
        if (this.props)
            for (let id in this.props)
                result.push([+id, this.props[id]]);
        return result;
    }
    /// Balance the direct children of this tree, producing a copy of
    /// which may have children grouped into subtrees with type
    /// [`NodeType.none`](#common.NodeType^none).
    balance(config = {}) {
        return this.children.length <= 8 /* BranchFactor */ ? this :
            balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));
    }
    /// Build a tree from a postfix-ordered buffer of node information,
    /// or a cursor over such a buffer.
    static build(data) { return buildTree(data); }
}
/// The empty tree
Tree.empty = new Tree(NodeType.none, [], [], 0);
class FlatBufferCursor {
    constructor(buffer, index) {
        this.buffer = buffer;
        this.index = index;
    }
    get id() { return this.buffer[this.index - 4]; }
    get start() { return this.buffer[this.index - 3]; }
    get end() { return this.buffer[this.index - 2]; }
    get size() { return this.buffer[this.index - 1]; }
    get pos() { return this.index; }
    next() { this.index -= 4; }
    fork() { return new FlatBufferCursor(this.buffer, this.index); }
}
/// Tree buffers contain (type, start, end, endIndex) quads for each
/// node. In such a buffer, nodes are stored in prefix order (parents
/// before children, with the endIndex of the parent indicating which
/// children belong to it)
class TreeBuffer {
    /// Create a tree buffer.
    constructor(
    /// The buffer's content.
    buffer, 
    /// The total length of the group of nodes in the buffer.
    length, 
    /// The node set used in this buffer.
    set) {
        this.buffer = buffer;
        this.length = length;
        this.set = set;
    }
    /// @internal
    get type() { return NodeType.none; }
    /// @internal
    toString() {
        let result = [];
        for (let index = 0; index < this.buffer.length;) {
            result.push(this.childString(index));
            index = this.buffer[index + 3];
        }
        return result.join(",");
    }
    /// @internal
    childString(index) {
        let id = this.buffer[index], endIndex = this.buffer[index + 3];
        let type = this.set.types[id], result = type.name;
        if (/\W/.test(result) && !type.isError)
            result = JSON.stringify(result);
        index += 4;
        if (endIndex == index)
            return result;
        let children = [];
        while (index < endIndex) {
            children.push(this.childString(index));
            index = this.buffer[index + 3];
        }
        return result + "(" + children.join(",") + ")";
    }
    /// @internal
    findChild(startIndex, endIndex, dir, pos, side) {
        let { buffer } = this, pick = -1;
        for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
            if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {
                pick = i;
                if (dir > 0)
                    break;
            }
        }
        return pick;
    }
    /// @internal
    slice(startI, endI, from, to) {
        let b = this.buffer;
        let copy = new Uint16Array(endI - startI);
        for (let i = startI, j = 0; i < endI;) {
            copy[j++] = b[i++];
            copy[j++] = b[i++] - from;
            copy[j++] = b[i++] - from;
            copy[j++] = b[i++] - startI;
        }
        return new TreeBuffer(copy, to - from, this.set);
    }
}
function checkSide(side, pos, from, to) {
    switch (side) {
        case -2 /* Before */: return from < pos;
        case -1 /* AtOrBefore */: return to >= pos && from < pos;
        case 0 /* Around */: return from < pos && to > pos;
        case 1 /* AtOrAfter */: return from <= pos && to > pos;
        case 2 /* After */: return to > pos;
        case 4 /* DontCare */: return true;
    }
}
function enterUnfinishedNodesBefore(node, pos) {
    let scan = node.childBefore(pos);
    while (scan) {
        let last = scan.lastChild;
        if (!last || last.to != scan.to)
            break;
        if (last.type.isError && last.from == last.to) {
            node = scan;
            scan = last.prevSibling;
        }
        else {
            scan = last;
        }
    }
    return node;
}
function resolveNode(node, pos, side, overlays) {
    var _a;
    // Move up to a node that actually holds the position, if possible
    while (node.from == node.to ||
        (side < 1 ? node.from >= pos : node.from > pos) ||
        (side > -1 ? node.to <= pos : node.to < pos)) {
        let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
        if (!parent)
            return node;
        node = parent;
    }
    // Must go up out of overlays when those do not overlap with pos
    if (overlays)
        for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
            if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, true)) === null || _a === void 0 ? void 0 : _a.from) != scan.from)
                node = parent;
        }
    for (;;) {
        let inner = node.enter(pos, side, overlays);
        if (!inner)
            return node;
        node = inner;
    }
}
class TreeNode {
    constructor(node, _from, 
    // Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)
    index, _parent) {
        this.node = node;
        this._from = _from;
        this.index = index;
        this._parent = _parent;
    }
    get type() { return this.node.type; }
    get name() { return this.node.type.name; }
    get from() { return this._from; }
    get to() { return this._from + this.node.length; }
    nextChild(i, dir, pos, side, mode = 0) {
        for (let parent = this;;) {
            for (let { children, positions } = parent.node, e = dir > 0 ? children.length : -1; i != e; i += dir) {
                let next = children[i], start = positions[i] + parent._from;
                if (!checkSide(side, pos, start, start + next.length))
                    continue;
                if (next instanceof TreeBuffer) {
                    if (mode & 2 /* NoEnterBuffer */)
                        continue;
                    let index = next.findChild(0, next.buffer.length, dir, pos - start, side);
                    if (index > -1)
                        return new BufferNode(new BufferContext(parent, next, i, start), null, index);
                }
                else if ((mode & 1 /* Full */) || (!next.type.isAnonymous || hasChild(next))) {
                    let mounted;
                    if (!(mode & 1 /* Full */) && next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay)
                        return new TreeNode(mounted.tree, start, i, parent);
                    let inner = new TreeNode(next, start, i, parent);
                    return (mode & 1 /* Full */) || !inner.type.isAnonymous ? inner
                        : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
                }
            }
            if ((mode & 1 /* Full */) || !parent.type.isAnonymous)
                return null;
            if (parent.index >= 0)
                i = parent.index + dir;
            else
                i = dir < 0 ? -1 : parent._parent.node.children.length;
            parent = parent._parent;
            if (!parent)
                return null;
        }
    }
    get firstChild() { return this.nextChild(0, 1, 0, 4 /* DontCare */); }
    get lastChild() { return this.nextChild(this.node.children.length - 1, -1, 0, 4 /* DontCare */); }
    childAfter(pos) { return this.nextChild(0, 1, pos, 2 /* After */); }
    childBefore(pos) { return this.nextChild(this.node.children.length - 1, -1, pos, -2 /* Before */); }
    enter(pos, side, overlays = true, buffers = true) {
        let mounted;
        if (overlays && (mounted = this.node.prop(NodeProp.mounted)) && mounted.overlay) {
            let rPos = pos - this.from;
            for (let { from, to } of mounted.overlay) {
                if ((side > 0 ? from <= rPos : from < rPos) &&
                    (side < 0 ? to >= rPos : to > rPos))
                    return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
            }
        }
        return this.nextChild(0, 1, pos, side, buffers ? 0 : 2 /* NoEnterBuffer */);
    }
    nextSignificantParent() {
        let val = this;
        while (val.type.isAnonymous && val._parent)
            val = val._parent;
        return val;
    }
    get parent() {
        return this._parent ? this._parent.nextSignificantParent() : null;
    }
    get nextSibling() {
        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4 /* DontCare */) : null;
    }
    get prevSibling() {
        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4 /* DontCare */) : null;
    }
    get cursor() { return new TreeCursor(this); }
    get tree() { return this.node; }
    toTree() { return this.node; }
    resolve(pos, side = 0) {
        return resolveNode(this, pos, side, false);
    }
    resolveInner(pos, side = 0) {
        return resolveNode(this, pos, side, true);
    }
    enterUnfinishedNodesBefore(pos) { return enterUnfinishedNodesBefore(this, pos); }
    getChild(type, before = null, after = null) {
        let r = getChildren(this, type, before, after);
        return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
        return getChildren(this, type, before, after);
    }
    /// @internal
    toString() { return this.node.toString(); }
}
function getChildren(node, type, before, after) {
    let cur = node.cursor, result = [];
    if (!cur.firstChild())
        return result;
    if (before != null)
        while (!cur.type.is(before))
            if (!cur.nextSibling())
                return result;
    for (;;) {
        if (after != null && cur.type.is(after))
            return result;
        if (cur.type.is(type))
            result.push(cur.node);
        if (!cur.nextSibling())
            return after == null ? result : [];
    }
}
class BufferContext {
    constructor(parent, buffer, index, start) {
        this.parent = parent;
        this.buffer = buffer;
        this.index = index;
        this.start = start;
    }
}
class BufferNode {
    constructor(context, _parent, index) {
        this.context = context;
        this._parent = _parent;
        this.index = index;
        this.type = context.buffer.set.types[context.buffer.buffer[index]];
    }
    get name() { return this.type.name; }
    get from() { return this.context.start + this.context.buffer.buffer[this.index + 1]; }
    get to() { return this.context.start + this.context.buffer.buffer[this.index + 2]; }
    child(dir, pos, side) {
        let { buffer } = this.context;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
        return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get firstChild() { return this.child(1, 0, 4 /* DontCare */); }
    get lastChild() { return this.child(-1, 0, 4 /* DontCare */); }
    childAfter(pos) { return this.child(1, pos, 2 /* After */); }
    childBefore(pos) { return this.child(-1, pos, -2 /* Before */); }
    enter(pos, side, overlays, buffers = true) {
        if (!buffers)
            return null;
        let { buffer } = this.context;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
        return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get parent() {
        return this._parent || this.context.parent.nextSignificantParent();
    }
    externalSibling(dir) {
        return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4 /* DontCare */);
    }
    get nextSibling() {
        let { buffer } = this.context;
        let after = buffer.buffer[this.index + 3];
        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
            return new BufferNode(this.context, this._parent, after);
        return this.externalSibling(1);
    }
    get prevSibling() {
        let { buffer } = this.context;
        let parentStart = this._parent ? this._parent.index + 4 : 0;
        if (this.index == parentStart)
            return this.externalSibling(-1);
        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4 /* DontCare */));
    }
    get cursor() { return new TreeCursor(this); }
    get tree() { return null; }
    toTree() {
        let children = [], positions = [];
        let { buffer } = this.context;
        let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
        if (endI > startI) {
            let from = buffer.buffer[this.index + 1], to = buffer.buffer[this.index + 2];
            children.push(buffer.slice(startI, endI, from, to));
            positions.push(0);
        }
        return new Tree(this.type, children, positions, this.to - this.from);
    }
    resolve(pos, side = 0) {
        return resolveNode(this, pos, side, false);
    }
    resolveInner(pos, side = 0) {
        return resolveNode(this, pos, side, true);
    }
    enterUnfinishedNodesBefore(pos) { return enterUnfinishedNodesBefore(this, pos); }
    /// @internal
    toString() { return this.context.buffer.childString(this.index); }
    getChild(type, before = null, after = null) {
        let r = getChildren(this, type, before, after);
        return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
        return getChildren(this, type, before, after);
    }
}
/// A tree cursor object focuses on a given node in a syntax tree, and
/// allows you to move to adjacent nodes.
class TreeCursor {
    /// @internal
    constructor(node, 
    /// @internal
    mode = 0) {
        this.mode = mode;
        this.buffer = null;
        this.stack = [];
        this.index = 0;
        this.bufferNode = null;
        if (node instanceof TreeNode) {
            this.yieldNode(node);
        }
        else {
            this._tree = node.context.parent;
            this.buffer = node.context;
            for (let n = node._parent; n; n = n._parent)
                this.stack.unshift(n.index);
            this.bufferNode = node;
            this.yieldBuf(node.index);
        }
    }
    /// Shorthand for `.type.name`.
    get name() { return this.type.name; }
    yieldNode(node) {
        if (!node)
            return false;
        this._tree = node;
        this.type = node.type;
        this.from = node.from;
        this.to = node.to;
        return true;
    }
    yieldBuf(index, type) {
        this.index = index;
        let { start, buffer } = this.buffer;
        this.type = type || buffer.set.types[buffer.buffer[index]];
        this.from = start + buffer.buffer[index + 1];
        this.to = start + buffer.buffer[index + 2];
        return true;
    }
    yield(node) {
        if (!node)
            return false;
        if (node instanceof TreeNode) {
            this.buffer = null;
            return this.yieldNode(node);
        }
        this.buffer = node.context;
        return this.yieldBuf(node.index, node.type);
    }
    /// @internal
    toString() {
        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
    }
    /// @internal
    enterChild(dir, pos, side) {
        if (!this.buffer)
            return this.yield(this._tree.nextChild(dir < 0 ? this._tree.node.children.length - 1 : 0, dir, pos, side, this.mode));
        let { buffer } = this.buffer;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
        if (index < 0)
            return false;
        this.stack.push(this.index);
        return this.yieldBuf(index);
    }
    /// Move the cursor to this node's first child. When this returns
    /// false, the node has no child, and the cursor has not been moved.
    firstChild() { return this.enterChild(1, 0, 4 /* DontCare */); }
    /// Move the cursor to this node's last child.
    lastChild() { return this.enterChild(-1, 0, 4 /* DontCare */); }
    /// Move the cursor to the first child that ends after `pos`.
    childAfter(pos) { return this.enterChild(1, pos, 2 /* After */); }
    /// Move to the last child that starts before `pos`.
    childBefore(pos) { return this.enterChild(-1, pos, -2 /* Before */); }
    /// Move the cursor to the child around `pos`. If side is -1 the
    /// child may end at that position, when 1 it may start there. This
    /// will also enter [overlaid](#common.MountedTree.overlay)
    /// [mounted](#common.NodeProp^mounted) trees unless `overlays` is
    /// set to false.
    enter(pos, side, overlays = true, buffers = true) {
        if (!this.buffer)
            return this.yield(this._tree.enter(pos, side, overlays && !(this.mode & 1 /* Full */), buffers));
        return buffers ? this.enterChild(1, pos, side) : false;
    }
    /// Move to the node's parent node, if this isn't the top node.
    parent() {
        if (!this.buffer)
            return this.yieldNode((this.mode & 1 /* Full */) ? this._tree._parent : this._tree.parent);
        if (this.stack.length)
            return this.yieldBuf(this.stack.pop());
        let parent = (this.mode & 1 /* Full */) ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
        this.buffer = null;
        return this.yieldNode(parent);
    }
    /// @internal
    sibling(dir) {
        if (!this.buffer)
            return !this._tree._parent ? false
                : this.yield(this._tree.index < 0 ? null
                    : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4 /* DontCare */, this.mode));
        let { buffer } = this.buffer, d = this.stack.length - 1;
        if (dir < 0) {
            let parentStart = d < 0 ? 0 : this.stack[d] + 4;
            if (this.index != parentStart)
                return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4 /* DontCare */));
        }
        else {
            let after = buffer.buffer[this.index + 3];
            if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
                return this.yieldBuf(after);
        }
        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4 /* DontCare */, this.mode)) : false;
    }
    /// Move to this node's next sibling, if any.
    nextSibling() { return this.sibling(1); }
    /// Move to this node's previous sibling, if any.
    prevSibling() { return this.sibling(-1); }
    atLastNode(dir) {
        let index, parent, { buffer } = this;
        if (buffer) {
            if (dir > 0) {
                if (this.index < buffer.buffer.buffer.length)
                    return false;
            }
            else {
                for (let i = 0; i < this.index; i++)
                    if (buffer.buffer.buffer[i + 3] < this.index)
                        return false;
            }
            ({ index, parent } = buffer);
        }
        else {
            ({ index, _parent: parent } = this._tree);
        }
        for (; parent; { index, _parent: parent } = parent) {
            if (index > -1)
                for (let i = index + dir, e = dir < 0 ? -1 : parent.node.children.length; i != e; i += dir) {
                    let child = parent.node.children[i];
                    if ((this.mode & 1 /* Full */) || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))
                        return false;
                }
        }
        return true;
    }
    move(dir, enter) {
        if (enter && this.enterChild(dir, 0, 4 /* DontCare */))
            return true;
        for (;;) {
            if (this.sibling(dir))
                return true;
            if (this.atLastNode(dir) || !this.parent())
                return false;
        }
    }
    /// Move to the next node in a
    /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR))
    /// traversal, going from a node to its first child or, if the
    /// current node is empty or `enter` is false, its next sibling or
    /// the next sibling of the first parent node that has one.
    next(enter = true) { return this.move(1, enter); }
    /// Move to the next node in a last-to-first pre-order traveral. A
    /// node is followed by its last child or, if it has none, its
    /// previous sibling or the previous sibling of the first parent
    /// node that has one.
    prev(enter = true) { return this.move(-1, enter); }
    /// Move the cursor to the innermost node that covers `pos`. If
    /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,
    /// it will enter nodes that start at `pos`.
    moveTo(pos, side = 0) {
        // Move up to a node that actually holds the position, if possible
        while (this.from == this.to ||
            (side < 1 ? this.from >= pos : this.from > pos) ||
            (side > -1 ? this.to <= pos : this.to < pos))
            if (!this.parent())
                break;
        // Then scan down into child nodes as far as possible
        while (this.enterChild(1, pos, side)) { }
        return this;
    }
    /// Get a [syntax node](#common.SyntaxNode) at the cursor's current
    /// position.
    get node() {
        if (!this.buffer)
            return this._tree;
        let cache = this.bufferNode, result = null, depth = 0;
        if (cache && cache.context == this.buffer) {
            scan: for (let index = this.index, d = this.stack.length; d >= 0;) {
                for (let c = cache; c; c = c._parent)
                    if (c.index == index) {
                        if (index == this.index)
                            return c;
                        result = c;
                        depth = d + 1;
                        break scan;
                    }
                index = this.stack[--d];
            }
        }
        for (let i = depth; i < this.stack.length; i++)
            result = new BufferNode(this.buffer, result, this.stack[i]);
        return this.bufferNode = new BufferNode(this.buffer, result, this.index);
    }
    /// Get the [tree](#common.Tree) that represents the current node, if
    /// any. Will return null when the node is in a [tree
    /// buffer](#common.TreeBuffer).
    get tree() {
        return this.buffer ? null : this._tree.node;
    }
}
function hasChild(tree) {
    return tree.children.some(ch => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
}
function buildTree(data) {
    var _a;
    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
    let types = nodeSet.types;
    let contextHash = 0, lookAhead = 0;
    function takeNode(parentStart, minPos, children, positions, inRepeat) {
        let { id, start, end, size } = cursor;
        let lookAheadAtStart = lookAhead;
        while (size < 0) {
            cursor.next();
            if (size == -1 /* Reuse */) {
                let node = reused[id];
                children.push(node);
                positions.push(start - parentStart);
                return;
            }
            else if (size == -3 /* ContextChange */) { // Context change
                contextHash = id;
                return;
            }
            else if (size == -4 /* LookAhead */) {
                lookAhead = id;
                return;
            }
            else {
                throw new RangeError(`Unrecognized record size: ${size}`);
            }
        }
        let type = types[id], node, buffer;
        let startPos = start - parentStart;
        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {
            // Small enough for a buffer, and no reused nodes inside
            let data = new Uint16Array(buffer.size - buffer.skip);
            let endPos = cursor.pos - buffer.size, index = data.length;
            while (cursor.pos > endPos)
                index = copyToBuffer(buffer.start, data, index);
            node = new TreeBuffer(data, end - buffer.start, nodeSet);
            startPos = buffer.start - parentStart;
        }
        else { // Make it a node
            let endPos = cursor.pos - size;
            cursor.next();
            let localChildren = [], localPositions = [];
            let localInRepeat = id >= minRepeatType ? id : -1;
            let lastGroup = 0, lastEnd = end;
            while (cursor.pos > endPos) {
                if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
                    if (cursor.end <= lastEnd - maxBufferLength) {
                        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);
                        lastGroup = localChildren.length;
                        lastEnd = cursor.end;
                    }
                    cursor.next();
                }
                else {
                    takeNode(start, endPos, localChildren, localPositions, localInRepeat);
                }
            }
            if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
                makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);
            localChildren.reverse();
            localPositions.reverse();
            if (localInRepeat > -1 && lastGroup > 0) {
                let make = makeBalanced(type);
                node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
            }
            else {
                node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);
            }
        }
        children.push(node);
        positions.push(startPos);
    }
    function makeBalanced(type) {
        return (children, positions, length) => {
            let lookAhead = 0, lastI = children.length - 1, last, lookAheadProp;
            if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {
                if (!lastI && last.type == type && last.length == length)
                    return last;
                if (lookAheadProp = last.prop(NodeProp.lookAhead))
                    lookAhead = positions[lastI] + last.length + lookAheadProp;
            }
            return makeTree(type, children, positions, length, lookAhead);
        };
    }
    function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead) {
        let localChildren = [], localPositions = [];
        while (children.length > i) {
            localChildren.push(children.pop());
            localPositions.push(positions.pop() + base - from);
        }
        children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to));
        positions.push(from - base);
    }
    function makeTree(type, children, positions, length, lookAhead = 0, props) {
        if (contextHash) {
            let pair = [NodeProp.contextHash, contextHash];
            props = props ? [pair].concat(props) : [pair];
        }
        if (lookAhead > 25) {
            let pair = [NodeProp.lookAhead, lookAhead];
            props = props ? [pair].concat(props) : [pair];
        }
        return new Tree(type, children, positions, length, props);
    }
    function findBufferSize(maxSize, inRepeat) {
        // Scan through the buffer to find previous siblings that fit
        // together in a TreeBuffer, and don't contain any reused nodes
        // (which can't be stored in a buffer).
        // If `inRepeat` is > -1, ignore node boundaries of that type for
        // nesting, but make sure the end falls either at the start
        // (`maxSize`) or before such a node.
        let fork = cursor.fork();
        let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
        let result = { size: 0, start: 0, skip: 0 };
        scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {
            let nodeSize = fork.size;
            // Pretend nested repeat nodes of the same type don't exist
            if (fork.id == inRepeat && nodeSize >= 0) {
                // Except that we store the current state as a valid return
                // value.
                result.size = size;
                result.start = start;
                result.skip = skip;
                skip += 4;
                size += 4;
                fork.next();
                continue;
            }
            let startPos = fork.pos - nodeSize;
            if (nodeSize < 0 || startPos < minPos || fork.start < minStart)
                break;
            let localSkipped = fork.id >= minRepeatType ? 4 : 0;
            let nodeStart = fork.start;
            fork.next();
            while (fork.pos > startPos) {
                if (fork.size < 0) {
                    if (fork.size == -3 /* ContextChange */)
                        localSkipped += 4;
                    else
                        break scan;
                }
                else if (fork.id >= minRepeatType) {
                    localSkipped += 4;
                }
                fork.next();
            }
            start = nodeStart;
            size += nodeSize;
            skip += localSkipped;
        }
        if (inRepeat < 0 || size == maxSize) {
            result.size = size;
            result.start = start;
            result.skip = skip;
        }
        return result.size > 4 ? result : undefined;
    }
    function copyToBuffer(bufferStart, buffer, index) {
        let { id, start, end, size } = cursor;
        cursor.next();
        if (size >= 0 && id < minRepeatType) {
            let startIndex = index;
            if (size > 4) {
                let endPos = cursor.pos - (size - 4);
                while (cursor.pos > endPos)
                    index = copyToBuffer(bufferStart, buffer, index);
            }
            buffer[--index] = startIndex;
            buffer[--index] = end - bufferStart;
            buffer[--index] = start - bufferStart;
            buffer[--index] = id;
        }
        else if (size == -3 /* ContextChange */) {
            contextHash = id;
        }
        else if (size == -4 /* LookAhead */) {
            lookAhead = id;
        }
        return index;
    }
    let children = [], positions = [];
    while (cursor.pos > 0)
        takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1);
    let length = (_a = data.length) !== null && _a !== void 0 ? _a : (children.length ? positions[0] + children[0].length : 0);
    return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);
}
const nodeSizeCache = new WeakMap;
function nodeSize(balanceType, node) {
    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)
        return 1;
    let size = nodeSizeCache.get(node);
    if (size == null) {
        size = 1;
        for (let child of node.children) {
            if (child.type != balanceType || !(child instanceof Tree)) {
                size = 1;
                break;
            }
            size += nodeSize(balanceType, child);
        }
        nodeSizeCache.set(node, size);
    }
    return size;
}
function balanceRange(
// The type the balanced tree's inner nodes.
balanceType, 
// The direct children and their positions
children, positions, 
// The index range in children/positions to use
from, to, 
// The start position of the nodes, relative to their parent.
start, 
// Length of the outer node
length, 
// Function to build the top node of the balanced tree
mkTop, 
// Function to build internal nodes for the balanced tree
mkTree) {
    let total = 0;
    for (let i = from; i < to; i++)
        total += nodeSize(balanceType, children[i]);
    let maxChild = Math.ceil((total * 1.5) / 8 /* BranchFactor */);
    let localChildren = [], localPositions = [];
    function divide(children, positions, from, to, offset) {
        for (let i = from; i < to;) {
            let groupFrom = i, groupStart = positions[i], groupSize = nodeSize(balanceType, children[i]);
            i++;
            for (; i < to; i++) {
                let nextSize = nodeSize(balanceType, children[i]);
                if (groupSize + nextSize >= maxChild)
                    break;
                groupSize += nextSize;
            }
            if (i == groupFrom + 1) {
                if (groupSize > maxChild) {
                    let only = children[groupFrom]; // Only trees can have a size > 1
                    divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);
                    continue;
                }
                localChildren.push(children[groupFrom]);
            }
            else {
                let length = positions[i - 1] + children[i - 1].length - groupStart;
                localChildren.push(balanceRange(balanceType, children, positions, groupFrom, i, groupStart, length, null, mkTree));
            }
            localPositions.push(groupStart + offset - start);
        }
    }
    divide(children, positions, from, to, 0);
    return (mkTop || mkTree)(localChildren, localPositions, length);
}

/// Tree fragments are used during [incremental
/// parsing](#common.Parser.startParse) to track parts of old trees
/// that can be reused in a new parse. An array of fragments is used
/// to track regions of an old tree whose nodes might be reused in new
/// parses. Use the static
/// [`applyChanges`](#common.TreeFragment^applyChanges) method to
/// update fragments for document changes.
class TreeFragment {
    /// Construct a tree fragment.
    constructor(
    /// The start of the unchanged range pointed to by this fragment.
    /// This refers to an offset in the _updated_ document (as opposed
    /// to the original tree).
    from, 
    /// The end of the unchanged range.
    to, 
    /// The tree that this fragment is based on.
    tree, 
    /// The offset between the fragment's tree and the document that
    /// this fragment can be used against. Add this when going from
    /// document to tree positions, subtract it to go from tree to
    /// document positions.
    offset, openStart = false, openEnd = false) {
        this.from = from;
        this.to = to;
        this.tree = tree;
        this.offset = offset;
        this.open = (openStart ? 1 /* Start */ : 0) | (openEnd ? 2 /* End */ : 0);
    }
    /// Whether the start of the fragment represents the start of a
    /// parse, or the end of a change. (In the second case, it may not
    /// be safe to reuse some nodes at the start, depending on the
    /// parsing algorithm.)
    get openStart() { return (this.open & 1 /* Start */) > 0; }
    /// Whether the end of the fragment represents the end of a
    /// full-document parse, or the start of a change.
    get openEnd() { return (this.open & 2 /* End */) > 0; }
    /// Create a set of fragments from a freshly parsed tree, or update
    /// an existing set of fragments by replacing the ones that overlap
    /// with a tree with content from the new tree. When `partial` is
    /// true, the parse is treated as incomplete, and the resulting
    /// fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
    /// true.
    static addTree(tree, fragments = [], partial = false) {
        let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];
        for (let f of fragments)
            if (f.to > tree.length)
                result.push(f);
        return result;
    }
    /// Apply a set of edits to an array of fragments, removing or
    /// splitting fragments as necessary to remove edited ranges, and
    /// adjusting offsets for fragments that moved.
    static applyChanges(fragments, changes, minGap = 128) {
        if (!changes.length)
            return fragments;
        let result = [];
        let fI = 1, nextF = fragments.length ? fragments[0] : null;
        for (let cI = 0, pos = 0, off = 0;; cI++) {
            let nextC = cI < changes.length ? changes[cI] : null;
            let nextPos = nextC ? nextC.fromA : 1e9;
            if (nextPos - pos >= minGap)
                while (nextF && nextF.from < nextPos) {
                    let cut = nextF;
                    if (pos >= cut.from || nextPos <= cut.to || off) {
                        let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
                        cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
                    }
                    if (cut)
                        result.push(cut);
                    if (nextF.to > nextPos)
                        break;
                    nextF = fI < fragments.length ? fragments[fI++] : null;
                }
            if (!nextC)
                break;
            pos = nextC.toA;
            off = nextC.toA - nextC.toB;
        }
        return result;
    }
}
/// A superclass that parsers should extend.
class Parser {
    /// Start a parse, returning a [partial parse](#common.PartialParse)
    /// object. [`fragments`](#common.TreeFragment) can be passed in to
    /// make the parse incremental.
    ///
    /// By default, the entire input is parsed. You can pass `ranges`,
    /// which should be a sorted array of non-empty, non-overlapping
    /// ranges, to parse only those ranges. The tree returned in that
    /// case will start at `ranges[0].from`.
    startParse(input, fragments, ranges) {
        if (typeof input == "string")
            input = new StringInput(input);
        ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map(r => new Range(r.from, r.to)) : [new Range(0, 0)];
        return this.createParse(input, fragments || [], ranges);
    }
    /// Run a full parse, returning the resulting tree.
    parse(input, fragments, ranges) {
        let parse = this.startParse(input, fragments, ranges);
        for (;;) {
            let done = parse.advance();
            if (done)
                return done;
        }
    }
}
class StringInput {
    constructor(string) {
        this.string = string;
    }
    get length() { return this.string.length; }
    chunk(from) { return this.string.slice(from); }
    get lineChunks() { return false; }
    read(from, to) { return this.string.slice(from, to); }
}

/// Create a parse wrapper that, after the inner parse completes,
/// scans its tree for mixed language regions with the `nest`
/// function, runs the resulting [inner parses](#common.NestedParse),
/// and then [mounts](#common.NodeProp^mounted) their results onto the
/// tree.
///
/// The nesting function is passed a cursor to provide context for a
/// node, but _should not_ move that cursor, only inspect its
/// properties and optionally access its
/// [node object](#common.TreeCursor.node).
function parseMixed(nest) {
    return (parse, input, fragments, ranges) => new MixedParse(parse, nest, input, fragments, ranges);
}
class InnerParse {
    constructor(parser, parse, overlay, target, ranges) {
        this.parser = parser;
        this.parse = parse;
        this.overlay = overlay;
        this.target = target;
        this.ranges = ranges;
    }
}
class ActiveOverlay {
    constructor(parser, predicate, mounts, index, start, target, prev) {
        this.parser = parser;
        this.predicate = predicate;
        this.mounts = mounts;
        this.index = index;
        this.start = start;
        this.target = target;
        this.prev = prev;
        this.depth = 0;
        this.ranges = [];
    }
}
const stoppedInner = new NodeProp({ perNode: true });
class MixedParse {
    constructor(base, nest, input, fragments, ranges) {
        this.nest = nest;
        this.input = input;
        this.fragments = fragments;
        this.ranges = ranges;
        this.inner = [];
        this.innerDone = 0;
        this.baseTree = null;
        this.stoppedAt = null;
        this.baseParse = base;
    }
    advance() {
        if (this.baseParse) {
            let done = this.baseParse.advance();
            if (!done)
                return null;
            this.baseParse = null;
            this.baseTree = done;
            this.startInner();
            if (this.stoppedAt != null)
                for (let inner of this.inner)
                    inner.parse.stopAt(this.stoppedAt);
        }
        if (this.innerDone == this.inner.length) {
            let result = this.baseTree;
            if (this.stoppedAt != null)
                result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([[stoppedInner, this.stoppedAt]]));
            return result;
        }
        let inner = this.inner[this.innerDone], done = inner.parse.advance();
        if (done) {
            this.innerDone++;
            // This is a somewhat dodgy but super helpful hack where we
            // patch up nodes created by the inner parse (and thus
            // presumably not aliased anywhere else) to hold the information
            // about the inner parse.
            let props = Object.assign(Object.create(null), inner.target.props);
            props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);
            inner.target.props = props;
        }
        return null;
    }
    get parsedPos() {
        if (this.baseParse)
            return 0;
        let pos = this.input.length;
        for (let i = this.innerDone; i < this.inner.length; i++) {
            if (this.inner[i].ranges[0].from < pos)
                pos = Math.min(pos, this.inner[i].parse.parsedPos);
        }
        return pos;
    }
    stopAt(pos) {
        this.stoppedAt = pos;
        if (this.baseParse)
            this.baseParse.stopAt(pos);
        else
            for (let i = this.innerDone; i < this.inner.length; i++)
                this.inner[i].parse.stopAt(pos);
    }
    startInner() {
        let fragmentCursor = new FragmentCursor(this.fragments);
        let overlay = null;
        let covered = null;
        let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), 1 /* Full */);
        scan: for (let nest, isCovered; this.stoppedAt == null || cursor.from < this.stoppedAt;) {
            let enter = true, range;
            if (fragmentCursor.hasNode(cursor)) {
                if (overlay) {
                    let match = overlay.mounts.find(m => m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay);
                    if (match)
                        for (let r of match.mount.overlay) {
                            let from = r.from + match.pos, to = r.to + match.pos;
                            if (from >= cursor.from && to <= cursor.to && !overlay.ranges.some(r => r.from < to && r.to > from))
                                overlay.ranges.push({ from, to });
                        }
                }
                enter = false;
            }
            else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {
                enter = isCovered != 2 /* Full */;
            }
            else if (!cursor.type.isAnonymous && cursor.from < cursor.to && (nest = this.nest(cursor, this.input))) {
                if (!cursor.tree)
                    materialize(cursor);
                let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);
                if (typeof nest.overlay == "function") {
                    overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);
                }
                else {
                    let ranges = punchRanges(this.ranges, nest.overlay || [new Range(cursor.from, cursor.to)]);
                    if (ranges.length)
                        this.inner.push(new InnerParse(nest.parser, nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges), nest.overlay ? nest.overlay.map(r => new Range(r.from - cursor.from, r.to - cursor.from)) : null, cursor.tree, ranges));
                    if (!nest.overlay)
                        enter = false;
                    else if (ranges.length)
                        covered = { ranges, depth: 0, prev: covered };
                }
            }
            else if (overlay && (range = overlay.predicate(cursor))) {
                if (range === true)
                    range = new Range(cursor.from, cursor.to);
                if (range.from < range.to)
                    overlay.ranges.push(range);
            }
            if (enter && cursor.firstChild()) {
                if (overlay)
                    overlay.depth++;
                if (covered)
                    covered.depth++;
            }
            else {
                for (;;) {
                    if (cursor.nextSibling())
                        break;
                    if (!cursor.parent())
                        break scan;
                    if (overlay && !--overlay.depth) {
                        let ranges = punchRanges(this.ranges, overlay.ranges);
                        if (ranges.length)
                            this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map(r => new Range(r.from - overlay.start, r.to - overlay.start)), overlay.target, ranges));
                        overlay = overlay.prev;
                    }
                    if (covered && !--covered.depth)
                        covered = covered.prev;
                }
            }
        }
    }
}
function checkCover(covered, from, to) {
    for (let range of covered) {
        if (range.from >= to)
            break;
        if (range.to > from)
            return range.from <= from && range.to >= to ? 2 /* Full */ : 1 /* Partial */;
    }
    return 0 /* None */;
}
// Take a piece of buffer and convert it into a stand-alone
// TreeBuffer.
function sliceBuf(buf, startI, endI, nodes, positions, off) {
    if (startI < endI) {
        let from = buf.buffer[startI + 1], to = buf.buffer[endI - 2];
        nodes.push(buf.slice(startI, endI, from, to));
        positions.push(from - off);
    }
}
// This function takes a node that's in a buffer, and converts it, and
// its parent buffer nodes, into a Tree. This is again acting on the
// assumption that the trees and buffers have been constructed by the
// parse that was ran via the mix parser, and thus aren't shared with
// any other code, making violations of the immutability safe.
function materialize(cursor) {
    let { node } = cursor, depth = 0;
    // Scan up to the nearest tree
    do {
        cursor.parent();
        depth++;
    } while (!cursor.tree);
    // Find the index of the buffer in that tree
    let i = 0, base = cursor.tree, off = 0;
    for (;; i++) {
        off = base.positions[i] + cursor.from;
        if (off <= node.from && off + base.children[i].length >= node.to)
            break;
    }
    let buf = base.children[i], b = buf.buffer;
    // Split a level in the buffer, putting the nodes before and after
    // the child that contains `node` into new buffers.
    function split(startI, endI, type, innerOffset, length) {
        let i = startI;
        while (b[i + 2] + off <= node.from)
            i = b[i + 3];
        let children = [], positions = [];
        sliceBuf(buf, startI, i, children, positions, innerOffset);
        let from = b[i + 1], to = b[i + 2];
        let isTarget = from + off == node.from && to + off == node.to && b[i] == node.type.id;
        children.push(isTarget ? node.toTree() : split(i + 4, b[i + 3], buf.set.types[b[i]], from, to - from));
        positions.push(from - innerOffset);
        sliceBuf(buf, b[i + 3], endI, children, positions, innerOffset);
        return new Tree(type, children, positions, length);
    }
    base.children[i] = split(0, b.length, NodeType.none, 0, buf.length);
    // Move the cursor back to the target node
    for (let d = 0; d <= depth; d++)
        cursor.childAfter(node.from);
}
class StructureCursor {
    constructor(root, offset) {
        this.offset = offset;
        this.done = false;
        this.cursor = root.fullCursor();
    }
    // Move to the first node (in pre-order) that starts at or after `pos`.
    moveTo(pos) {
        let { cursor } = this, p = pos - this.offset;
        while (!this.done && cursor.from < p) {
            if (cursor.to >= pos && cursor.enter(p, 1, false, false)) ;
            else if (!cursor.next(false))
                this.done = true;
        }
    }
    hasNode(cursor) {
        this.moveTo(cursor.from);
        if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {
            for (let tree = this.cursor.tree;;) {
                if (tree == cursor.tree)
                    return true;
                if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree)
                    tree = tree.children[0];
                else
                    break;
            }
        }
        return false;
    }
}
class FragmentCursor {
    constructor(fragments) {
        var _a;
        this.fragments = fragments;
        this.curTo = 0;
        this.fragI = 0;
        if (fragments.length) {
            let first = this.curFrag = fragments[0];
            this.curTo = (_a = first.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : first.to;
            this.inner = new StructureCursor(first.tree, -first.offset);
        }
        else {
            this.curFrag = this.inner = null;
        }
    }
    hasNode(node) {
        while (this.curFrag && node.from >= this.curTo)
            this.nextFrag();
        return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);
    }
    nextFrag() {
        var _a;
        this.fragI++;
        if (this.fragI == this.fragments.length) {
            this.curFrag = this.inner = null;
        }
        else {
            let frag = this.curFrag = this.fragments[this.fragI];
            this.curTo = (_a = frag.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : frag.to;
            this.inner = new StructureCursor(frag.tree, -frag.offset);
        }
    }
    findMounts(pos, parser) {
        var _a;
        let result = [];
        if (this.inner) {
            this.inner.cursor.moveTo(pos, 1);
            for (let pos = this.inner.cursor.node; pos; pos = pos.parent) {
                let mount = (_a = pos.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);
                if (mount && mount.parser == parser) {
                    for (let i = this.fragI; i < this.fragments.length; i++) {
                        let frag = this.fragments[i];
                        if (frag.from >= pos.to)
                            break;
                        if (frag.tree == this.curFrag.tree)
                            result.push({
                                frag,
                                pos: pos.from - frag.offset,
                                mount
                            });
                    }
                }
            }
        }
        return result;
    }
}
function punchRanges(outer, ranges) {
    let copy = null, current = ranges;
    for (let i = 1, j = 0; i < outer.length; i++) {
        let gapFrom = outer[i - 1].to, gapTo = outer[i].from;
        for (; j < current.length; j++) {
            let r = current[j];
            if (r.from >= gapTo)
                break;
            if (r.to <= gapFrom)
                continue;
            if (!copy)
                current = copy = ranges.slice();
            if (r.from < gapFrom) {
                copy[j] = new Range(r.from, gapFrom);
                if (r.to > gapTo)
                    copy.splice(j + 1, 0, new Range(gapTo, r.to));
            }
            else if (r.to > gapTo) {
                copy[j--] = new Range(gapTo, r.to);
            }
            else {
                copy.splice(j--, 1);
            }
        }
    }
    return current;
}
function findCoverChanges(a, b, from, to) {
    let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;
    let result = [];
    for (;;) {
        let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;
        let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;
        if (inA != inB) {
            let start = Math.max(pos, from), end = Math.min(nextA, nextB, to);
            if (start < end)
                result.push(new Range(start, end));
        }
        pos = Math.min(nextA, nextB);
        if (pos == 1e9)
            break;
        if (nextA == pos) {
            if (!inA)
                inA = true;
            else {
                inA = false;
                iA++;
            }
        }
        if (nextB == pos) {
            if (!inB)
                inB = true;
            else {
                inB = false;
                iB++;
            }
        }
    }
    return result;
}
// Given a number of fragments for the outer tree, and a set of ranges
// to parse, find fragments for inner trees mounted around those
// ranges, if any.
function enterFragments(mounts, ranges) {
    let result = [];
    for (let { pos, mount, frag } of mounts) {
        let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;
        let from = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);
        if (mount.overlay) {
            let overlay = mount.overlay.map(r => new Range(r.from + pos, r.to + pos));
            let changes = findCoverChanges(ranges, overlay, from, to);
            for (let i = 0, pos = from;; i++) {
                let last = i == changes.length, end = last ? to : changes[i].from;
                if (end > pos)
                    result.push(new TreeFragment(pos, end, mount.tree, -startPos, frag.from >= pos, frag.to <= end));
                if (last)
                    break;
                pos = changes[i].to;
            }
        }
        else {
            result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos, frag.to <= endPos));
        }
    }
    return result;
}




/***/ }),

/***/ "./.yarn/cache/@lezer-lr-npm-0.15.8-8c481c39cd-e741225d6a.zip/node_modules/@lezer/lr/dist/index.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ContextTracker": () => (/* binding */ ContextTracker),
/* harmony export */   "ExternalTokenizer": () => (/* binding */ ExternalTokenizer),
/* harmony export */   "InputStream": () => (/* binding */ InputStream),
/* harmony export */   "LRParser": () => (/* binding */ LRParser),
/* harmony export */   "Stack": () => (/* binding */ Stack)
/* harmony export */ });
/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@lezer-common-npm-0.15.12-62017272b0-dae6581618.zip/node_modules/@lezer/common/dist/index.js");


/// A parse stack. These are used internally by the parser to track
/// parsing progress. They also provide some properties and methods
/// that external code such as a tokenizer can use to get information
/// about the parse state.
class Stack {
    /// @internal
    constructor(
    /// The parse that this stack is part of @internal
    p, 
    /// Holds state, input pos, buffer index triplets for all but the
    /// top state @internal
    stack, 
    /// The current parse state @internal
    state, 
    // The position at which the next reduce should take place. This
    // can be less than `this.pos` when skipped expressions have been
    // added to the stack (which should be moved outside of the next
    // reduction)
    /// @internal
    reducePos, 
    /// The input position up to which this stack has parsed.
    pos, 
    /// The dynamic score of the stack, including dynamic precedence
    /// and error-recovery penalties
    /// @internal
    score, 
    // The output buffer. Holds (type, start, end, size) quads
    // representing nodes created by the parser, where `size` is
    // amount of buffer array entries covered by this node.
    /// @internal
    buffer, 
    // The base offset of the buffer. When stacks are split, the split
    // instance shared the buffer history with its parent up to
    // `bufferBase`, which is the absolute offset (including the
    // offset of previous splits) into the buffer at which this stack
    // starts writing.
    /// @internal
    bufferBase, 
    /// @internal
    curContext, 
    /// @internal
    lookAhead = 0, 
    // A parent stack from which this was split off, if any. This is
    // set up so that it always points to a stack that has some
    // additional buffer content, never to a stack with an equal
    // `bufferBase`.
    /// @internal
    parent) {
        this.p = p;
        this.stack = stack;
        this.state = state;
        this.reducePos = reducePos;
        this.pos = pos;
        this.score = score;
        this.buffer = buffer;
        this.bufferBase = bufferBase;
        this.curContext = curContext;
        this.lookAhead = lookAhead;
        this.parent = parent;
    }
    /// @internal
    toString() {
        return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
    }
    // Start an empty stack
    /// @internal
    static start(p, state, pos = 0) {
        let cx = p.parser.context;
        return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);
    }
    /// The stack's current [context](#lr.ContextTracker) value, if
    /// any. Its type will depend on the context tracker's type
    /// parameter, or it will be `null` if there is no context
    /// tracker.
    get context() { return this.curContext ? this.curContext.context : null; }
    // Push a state onto the stack, tracking its start position as well
    // as the buffer base at that point.
    /// @internal
    pushState(state, start) {
        this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
        this.state = state;
    }
    // Apply a reduce action
    /// @internal
    reduce(action) {
        let depth = action >> 19 /* ReduceDepthShift */, type = action & 65535 /* ValueMask */;
        let { parser } = this.p;
        let dPrec = parser.dynamicPrecedence(type);
        if (dPrec)
            this.score += dPrec;
        if (depth == 0) {
            this.pushState(parser.getGoto(this.state, type, true), this.reducePos);
            // Zero-depth reductions are a special casethey add stuff to
            // the stack without popping anything off.
            if (type < parser.minRepeatTerm)
                this.storeNode(type, this.reducePos, this.reducePos, 4, true);
            this.reduceContext(type, this.reducePos);
            return;
        }
        // Find the base index into `this.stack`, content after which will
        // be dropped. Note that with `StayFlag` reductions we need to
        // consume two extra frames (the dummy parent node for the skipped
        // expression and the state that we'll be staying in, which should
        // be moved to `this.state`).
        let base = this.stack.length - ((depth - 1) * 3) - (action & 262144 /* StayFlag */ ? 6 : 0);
        let start = this.stack[base - 2];
        let bufferBase = this.stack[base - 1], count = this.bufferBase + this.buffer.length - bufferBase;
        // Store normal terms or `R -> R R` repeat reductions
        if (type < parser.minRepeatTerm || (action & 131072 /* RepeatFlag */)) {
            let pos = parser.stateFlag(this.state, 1 /* Skipped */) ? this.pos : this.reducePos;
            this.storeNode(type, start, pos, count + 4, true);
        }
        if (action & 262144 /* StayFlag */) {
            this.state = this.stack[base];
        }
        else {
            let baseStateID = this.stack[base - 3];
            this.state = parser.getGoto(baseStateID, type, true);
        }
        while (this.stack.length > base)
            this.stack.pop();
        this.reduceContext(type, start);
    }
    // Shift a value into the buffer
    /// @internal
    storeNode(term, start, end, size = 4, isReduce = false) {
        if (term == 0 /* Err */) { // Try to omit/merge adjacent error nodes
            let cur = this, top = this.buffer.length;
            if (top == 0 && cur.parent) {
                top = cur.bufferBase - cur.parent.bufferBase;
                cur = cur.parent;
            }
            if (top > 0 && cur.buffer[top - 4] == 0 /* Err */ && cur.buffer[top - 1] > -1) {
                if (start == end)
                    return;
                if (cur.buffer[top - 2] >= start) {
                    cur.buffer[top - 2] = end;
                    return;
                }
            }
        }
        if (!isReduce || this.pos == end) { // Simple case, just append
            this.buffer.push(term, start, end, size);
        }
        else { // There may be skipped nodes that have to be moved forward
            let index = this.buffer.length;
            if (index > 0 && this.buffer[index - 4] != 0 /* Err */)
                while (index > 0 && this.buffer[index - 2] > end) {
                    // Move this record forward
                    this.buffer[index] = this.buffer[index - 4];
                    this.buffer[index + 1] = this.buffer[index - 3];
                    this.buffer[index + 2] = this.buffer[index - 2];
                    this.buffer[index + 3] = this.buffer[index - 1];
                    index -= 4;
                    if (size > 4)
                        size -= 4;
                }
            this.buffer[index] = term;
            this.buffer[index + 1] = start;
            this.buffer[index + 2] = end;
            this.buffer[index + 3] = size;
        }
    }
    // Apply a shift action
    /// @internal
    shift(action, next, nextEnd) {
        let start = this.pos;
        if (action & 131072 /* GotoFlag */) {
            this.pushState(action & 65535 /* ValueMask */, this.pos);
        }
        else if ((action & 262144 /* StayFlag */) == 0) { // Regular shift
            let nextState = action, { parser } = this.p;
            if (nextEnd > this.pos || next <= parser.maxNode) {
                this.pos = nextEnd;
                if (!parser.stateFlag(nextState, 1 /* Skipped */))
                    this.reducePos = nextEnd;
            }
            this.pushState(nextState, start);
            this.shiftContext(next, start);
            if (next <= parser.maxNode)
                this.buffer.push(next, start, nextEnd, 4);
        }
        else { // Shift-and-stay, which means this is a skipped token
            this.pos = nextEnd;
            this.shiftContext(next, start);
            if (next <= this.p.parser.maxNode)
                this.buffer.push(next, start, nextEnd, 4);
        }
    }
    // Apply an action
    /// @internal
    apply(action, next, nextEnd) {
        if (action & 65536 /* ReduceFlag */)
            this.reduce(action);
        else
            this.shift(action, next, nextEnd);
    }
    // Add a prebuilt (reused) node into the buffer.
    /// @internal
    useNode(value, next) {
        let index = this.p.reused.length - 1;
        if (index < 0 || this.p.reused[index] != value) {
            this.p.reused.push(value);
            index++;
        }
        let start = this.pos;
        this.reducePos = this.pos = start + value.length;
        this.pushState(next, start);
        this.buffer.push(index, start, this.reducePos, -1 /* size == -1 means this is a reused value */);
        if (this.curContext)
            this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));
    }
    // Split the stack. Due to the buffer sharing and the fact
    // that `this.stack` tends to stay quite shallow, this isn't very
    // expensive.
    /// @internal
    split() {
        let parent = this;
        let off = parent.buffer.length;
        // Because the top of the buffer (after this.pos) may be mutated
        // to reorder reductions and skipped tokens, and shared buffers
        // should be immutable, this copies any outstanding skipped tokens
        // to the new buffer, and puts the base pointer before them.
        while (off > 0 && parent.buffer[off - 2] > parent.reducePos)
            off -= 4;
        let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;
        // Make sure parent points to an actual parent with content, if there is such a parent.
        while (parent && base == parent.bufferBase)
            parent = parent.parent;
        return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);
    }
    // Try to recover from an error by 'deleting' (ignoring) one token.
    /// @internal
    recoverByDelete(next, nextEnd) {
        let isNode = next <= this.p.parser.maxNode;
        if (isNode)
            this.storeNode(next, this.pos, nextEnd, 4);
        this.storeNode(0 /* Err */, this.pos, nextEnd, isNode ? 8 : 4);
        this.pos = this.reducePos = nextEnd;
        this.score -= 190 /* Delete */;
    }
    /// Check if the given term would be able to be shifted (optionally
    /// after some reductions) on this stack. This can be useful for
    /// external tokenizers that want to make sure they only provide a
    /// given token when it applies.
    canShift(term) {
        for (let sim = new SimulatedStack(this);;) {
            let action = this.p.parser.stateSlot(sim.state, 4 /* DefaultReduce */) || this.p.parser.hasAction(sim.state, term);
            if ((action & 65536 /* ReduceFlag */) == 0)
                return true;
            if (action == 0)
                return false;
            sim.reduce(action);
        }
    }
    // Apply up to Recover.MaxNext recovery actions that conceptually
    // inserts some missing token or rule.
    /// @internal
    recoverByInsert(next) {
        if (this.stack.length >= 300 /* MaxInsertStackDepth */)
            return [];
        let nextStates = this.p.parser.nextStates(this.state);
        if (nextStates.length > 4 /* MaxNext */ << 1 || this.stack.length >= 120 /* DampenInsertStackDepth */) {
            let best = [];
            for (let i = 0, s; i < nextStates.length; i += 2) {
                if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))
                    best.push(nextStates[i], s);
            }
            if (this.stack.length < 120 /* DampenInsertStackDepth */)
                for (let i = 0; best.length < 4 /* MaxNext */ << 1 && i < nextStates.length; i += 2) {
                    let s = nextStates[i + 1];
                    if (!best.some((v, i) => (i & 1) && v == s))
                        best.push(nextStates[i], s);
                }
            nextStates = best;
        }
        let result = [];
        for (let i = 0; i < nextStates.length && result.length < 4 /* MaxNext */; i += 2) {
            let s = nextStates[i + 1];
            if (s == this.state)
                continue;
            let stack = this.split();
            stack.storeNode(0 /* Err */, stack.pos, stack.pos, 4, true);
            stack.pushState(s, this.pos);
            stack.shiftContext(nextStates[i], this.pos);
            stack.score -= 200 /* Insert */;
            result.push(stack);
        }
        return result;
    }
    // Force a reduce, if possible. Return false if that can't
    // be done.
    /// @internal
    forceReduce() {
        let reduce = this.p.parser.stateSlot(this.state, 5 /* ForcedReduce */);
        if ((reduce & 65536 /* ReduceFlag */) == 0)
            return false;
        let { parser } = this.p;
        if (!parser.validAction(this.state, reduce)) {
            let depth = reduce >> 19 /* ReduceDepthShift */, term = reduce & 65535 /* ValueMask */;
            let target = this.stack.length - depth * 3;
            if (target < 0 || parser.getGoto(this.stack[target], term, false) < 0)
                return false;
            this.storeNode(0 /* Err */, this.reducePos, this.reducePos, 4, true);
            this.score -= 100 /* Reduce */;
        }
        this.reduce(reduce);
        return true;
    }
    /// @internal
    forceAll() {
        while (!this.p.parser.stateFlag(this.state, 2 /* Accepting */)) {
            if (!this.forceReduce()) {
                this.storeNode(0 /* Err */, this.pos, this.pos, 4, true);
                break;
            }
        }
        return this;
    }
    /// Check whether this state has no further actions (assumed to be a direct descendant of the
    /// top state, since any other states must be able to continue
    /// somehow). @internal
    get deadEnd() {
        if (this.stack.length != 3)
            return false;
        let { parser } = this.p;
        return parser.data[parser.stateSlot(this.state, 1 /* Actions */)] == 65535 /* End */ &&
            !parser.stateSlot(this.state, 4 /* DefaultReduce */);
    }
    /// Restart the stack (put it back in its start state). Only safe
    /// when this.stack.length == 3 (state is directly below the top
    /// state). @internal
    restart() {
        this.state = this.stack[0];
        this.stack.length = 0;
    }
    /// @internal
    sameState(other) {
        if (this.state != other.state || this.stack.length != other.stack.length)
            return false;
        for (let i = 0; i < this.stack.length; i += 3)
            if (this.stack[i] != other.stack[i])
                return false;
        return true;
    }
    /// Get the parser used by this stack.
    get parser() { return this.p.parser; }
    /// Test whether a given dialect (by numeric ID, as exported from
    /// the terms file) is enabled.
    dialectEnabled(dialectID) { return this.p.parser.dialect.flags[dialectID]; }
    shiftContext(term, start) {
        if (this.curContext)
            this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));
    }
    reduceContext(term, start) {
        if (this.curContext)
            this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));
    }
    /// @internal
    emitContext() {
        let last = this.buffer.length - 1;
        if (last < 0 || this.buffer[last] != -3)
            this.buffer.push(this.curContext.hash, this.reducePos, this.reducePos, -3);
    }
    /// @internal
    emitLookAhead() {
        let last = this.buffer.length - 1;
        if (last < 0 || this.buffer[last] != -4)
            this.buffer.push(this.lookAhead, this.reducePos, this.reducePos, -4);
    }
    updateContext(context) {
        if (context != this.curContext.context) {
            let newCx = new StackContext(this.curContext.tracker, context);
            if (newCx.hash != this.curContext.hash)
                this.emitContext();
            this.curContext = newCx;
        }
    }
    /// @internal
    setLookAhead(lookAhead) {
        if (lookAhead > this.lookAhead) {
            this.emitLookAhead();
            this.lookAhead = lookAhead;
        }
    }
    /// @internal
    close() {
        if (this.curContext && this.curContext.tracker.strict)
            this.emitContext();
        if (this.lookAhead > 0)
            this.emitLookAhead();
    }
}
class StackContext {
    constructor(tracker, context) {
        this.tracker = tracker;
        this.context = context;
        this.hash = tracker.strict ? tracker.hash(context) : 0;
    }
}
var Recover;
(function (Recover) {
    Recover[Recover["Insert"] = 200] = "Insert";
    Recover[Recover["Delete"] = 190] = "Delete";
    Recover[Recover["Reduce"] = 100] = "Reduce";
    Recover[Recover["MaxNext"] = 4] = "MaxNext";
    Recover[Recover["MaxInsertStackDepth"] = 300] = "MaxInsertStackDepth";
    Recover[Recover["DampenInsertStackDepth"] = 120] = "DampenInsertStackDepth";
})(Recover || (Recover = {}));
// Used to cheaply run some reductions to scan ahead without mutating
// an entire stack
class SimulatedStack {
    constructor(start) {
        this.start = start;
        this.state = start.state;
        this.stack = start.stack;
        this.base = this.stack.length;
    }
    reduce(action) {
        let term = action & 65535 /* ValueMask */, depth = action >> 19 /* ReduceDepthShift */;
        if (depth == 0) {
            if (this.stack == this.start.stack)
                this.stack = this.stack.slice();
            this.stack.push(this.state, 0, 0);
            this.base += 3;
        }
        else {
            this.base -= (depth - 1) * 3;
        }
        let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);
        this.state = goto;
    }
}
// This is given to `Tree.build` to build a buffer, and encapsulates
// the parent-stack-walking necessary to read the nodes.
class StackBufferCursor {
    constructor(stack, pos, index) {
        this.stack = stack;
        this.pos = pos;
        this.index = index;
        this.buffer = stack.buffer;
        if (this.index == 0)
            this.maybeNext();
    }
    static create(stack, pos = stack.bufferBase + stack.buffer.length) {
        return new StackBufferCursor(stack, pos, pos - stack.bufferBase);
    }
    maybeNext() {
        let next = this.stack.parent;
        if (next != null) {
            this.index = this.stack.bufferBase - next.bufferBase;
            this.stack = next;
            this.buffer = next.buffer;
        }
    }
    get id() { return this.buffer[this.index - 4]; }
    get start() { return this.buffer[this.index - 3]; }
    get end() { return this.buffer[this.index - 2]; }
    get size() { return this.buffer[this.index - 1]; }
    next() {
        this.index -= 4;
        this.pos -= 4;
        if (this.index == 0)
            this.maybeNext();
    }
    fork() {
        return new StackBufferCursor(this.stack, this.pos, this.index);
    }
}

class CachedToken {
    constructor() {
        this.start = -1;
        this.value = -1;
        this.end = -1;
        this.extended = -1;
        this.lookAhead = 0;
        this.mask = 0;
        this.context = 0;
    }
}
const nullToken = new CachedToken;
/// [Tokenizers](#lr.ExternalTokenizer) interact with the input
/// through this interface. It presents the input as a stream of
/// characters, tracking lookahead and hiding the complexity of
/// [ranges](#common.Parser.parse^ranges) from tokenizer code.
class InputStream {
    /// @internal
    constructor(
    /// @internal
    input, 
    /// @internal
    ranges) {
        this.input = input;
        this.ranges = ranges;
        /// @internal
        this.chunk = "";
        /// @internal
        this.chunkOff = 0;
        /// Backup chunk
        this.chunk2 = "";
        this.chunk2Pos = 0;
        /// The character code of the next code unit in the input, or -1
        /// when the stream is at the end of the input.
        this.next = -1;
        /// @internal
        this.token = nullToken;
        this.rangeIndex = 0;
        this.pos = this.chunkPos = ranges[0].from;
        this.range = ranges[0];
        this.end = ranges[ranges.length - 1].to;
        this.readNext();
    }
    resolveOffset(offset, assoc) {
        let range = this.range, index = this.rangeIndex;
        let pos = this.pos + offset;
        while (pos < range.from) {
            if (!index)
                return null;
            let next = this.ranges[--index];
            pos -= range.from - next.to;
            range = next;
        }
        while (assoc < 0 ? pos > range.to : pos >= range.to) {
            if (index == this.ranges.length - 1)
                return null;
            let next = this.ranges[++index];
            pos += next.from - range.to;
            range = next;
        }
        return pos;
    }
    /// Look at a code unit near the stream position. `.peek(0)` equals
    /// `.next`, `.peek(-1)` gives you the previous character, and so
    /// on.
    ///
    /// Note that looking around during tokenizing creates dependencies
    /// on potentially far-away content, which may reduce the
    /// effectiveness incremental parsingwhen looking forwardor even
    /// cause invalid reparses when looking backward more than 25 code
    /// units, since the library does not track lookbehind.
    peek(offset) {
        let idx = this.chunkOff + offset, pos, result;
        if (idx >= 0 && idx < this.chunk.length) {
            pos = this.pos + offset;
            result = this.chunk.charCodeAt(idx);
        }
        else {
            let resolved = this.resolveOffset(offset, 1);
            if (resolved == null)
                return -1;
            pos = resolved;
            if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
                result = this.chunk2.charCodeAt(pos - this.chunk2Pos);
            }
            else {
                let i = this.rangeIndex, range = this.range;
                while (range.to <= pos)
                    range = this.ranges[++i];
                this.chunk2 = this.input.chunk(this.chunk2Pos = pos);
                if (pos + this.chunk2.length > range.to)
                    this.chunk2 = this.chunk2.slice(0, range.to - pos);
                result = this.chunk2.charCodeAt(0);
            }
        }
        if (pos >= this.token.lookAhead)
            this.token.lookAhead = pos + 1;
        return result;
    }
    /// Accept a token. By default, the end of the token is set to the
    /// current stream position, but you can pass an offset (relative to
    /// the stream position) to change that.
    acceptToken(token, endOffset = 0) {
        let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;
        if (end == null || end < this.token.start)
            throw new RangeError("Token end out of bounds");
        this.token.value = token;
        this.token.end = end;
    }
    getChunk() {
        if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
            let { chunk, chunkPos } = this;
            this.chunk = this.chunk2;
            this.chunkPos = this.chunk2Pos;
            this.chunk2 = chunk;
            this.chunk2Pos = chunkPos;
            this.chunkOff = this.pos - this.chunkPos;
        }
        else {
            this.chunk2 = this.chunk;
            this.chunk2Pos = this.chunkPos;
            let nextChunk = this.input.chunk(this.pos);
            let end = this.pos + nextChunk.length;
            this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;
            this.chunkPos = this.pos;
            this.chunkOff = 0;
        }
    }
    readNext() {
        if (this.chunkOff >= this.chunk.length) {
            this.getChunk();
            if (this.chunkOff == this.chunk.length)
                return this.next = -1;
        }
        return this.next = this.chunk.charCodeAt(this.chunkOff);
    }
    /// Move the stream forward N (defaults to 1) code units. Returns
    /// the new value of [`next`](#lr.InputStream.next).
    advance(n = 1) {
        this.chunkOff += n;
        while (this.pos + n >= this.range.to) {
            if (this.rangeIndex == this.ranges.length - 1)
                return this.setDone();
            n -= this.range.to - this.pos;
            this.range = this.ranges[++this.rangeIndex];
            this.pos = this.range.from;
        }
        this.pos += n;
        if (this.pos >= this.token.lookAhead)
            this.token.lookAhead = this.pos + 1;
        return this.readNext();
    }
    setDone() {
        this.pos = this.chunkPos = this.end;
        this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];
        this.chunk = "";
        return this.next = -1;
    }
    /// @internal
    reset(pos, token) {
        if (token) {
            this.token = token;
            token.start = pos;
            token.lookAhead = pos + 1;
            token.value = token.extended = -1;
        }
        else {
            this.token = nullToken;
        }
        if (this.pos != pos) {
            this.pos = pos;
            if (pos == this.end) {
                this.setDone();
                return this;
            }
            while (pos < this.range.from)
                this.range = this.ranges[--this.rangeIndex];
            while (pos >= this.range.to)
                this.range = this.ranges[++this.rangeIndex];
            if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
                this.chunkOff = pos - this.chunkPos;
            }
            else {
                this.chunk = "";
                this.chunkOff = 0;
            }
            this.readNext();
        }
        return this;
    }
    /// @internal
    read(from, to) {
        if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)
            return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);
        if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)
            return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);
        if (from >= this.range.from && to <= this.range.to)
            return this.input.read(from, to);
        let result = "";
        for (let r of this.ranges) {
            if (r.from >= to)
                break;
            if (r.to > from)
                result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));
        }
        return result;
    }
}
/// @internal
class TokenGroup {
    constructor(data, id) {
        this.data = data;
        this.id = id;
    }
    token(input, stack) { readToken(this.data, input, stack, this.id); }
}
TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
/// `@external tokens` declarations in the grammar should resolve to
/// an instance of this class.
class ExternalTokenizer {
    /// Create a tokenizer. The first argument is the function that,
    /// given an input stream, scans for the types of tokens it
    /// recognizes at the stream's position, and calls
    /// [`acceptToken`](#lr.InputStream.acceptToken) when it finds
    /// one.
    constructor(
    /// @internal
    token, options = {}) {
        this.token = token;
        this.contextual = !!options.contextual;
        this.fallback = !!options.fallback;
        this.extend = !!options.extend;
    }
}
// Tokenizer data is stored a big uint16 array containing, for each
// state:
//
//  - A group bitmask, indicating what token groups are reachable from
//    this state, so that paths that can only lead to tokens not in
//    any of the current groups can be cut off early.
//
//  - The position of the end of the state's sequence of accepting
//    tokens
//
//  - The number of outgoing edges for the state
//
//  - The accepting tokens, as (token id, group mask) pairs
//
//  - The outgoing edges, as (start character, end character, state
//    index) triples, with end character being exclusive
//
// This function interprets that data, running through a stream as
// long as new states with the a matching group mask can be reached,
// and updating `token` when it matches a token.
function readToken(data, input, stack, group) {
    let state = 0, groupMask = 1 << group, { parser } = stack.p, { dialect } = parser;
    scan: for (;;) {
        if ((groupMask & data[state]) == 0)
            break;
        let accEnd = data[state + 1];
        // Check whether this state can lead to a token in the current group
        // Accept tokens in this state, possibly overwriting
        // lower-precedence / shorter tokens
        for (let i = state + 3; i < accEnd; i += 2)
            if ((data[i + 1] & groupMask) > 0) {
                let term = data[i];
                if (dialect.allows(term) &&
                    (input.token.value == -1 || input.token.value == term || parser.overrides(term, input.token.value))) {
                    input.acceptToken(term);
                    break;
                }
            }
        // Do a binary search on the state's edges
        for (let next = input.next, low = 0, high = data[state + 2]; low < high;) {
            let mid = (low + high) >> 1;
            let index = accEnd + mid + (mid << 1);
            let from = data[index], to = data[index + 1];
            if (next < from)
                high = mid;
            else if (next >= to)
                low = mid + 1;
            else {
                state = data[index + 2];
                input.advance();
                continue scan;
            }
        }
        break;
    }
}

// See lezer-generator/src/encode.ts for comments about the encoding
// used here
function decodeArray(input, Type = Uint16Array) {
    if (typeof input != "string")
        return input;
    let array = null;
    for (let pos = 0, out = 0; pos < input.length;) {
        let value = 0;
        for (;;) {
            let next = input.charCodeAt(pos++), stop = false;
            if (next == 126 /* BigValCode */) {
                value = 65535 /* BigVal */;
                break;
            }
            if (next >= 92 /* Gap2 */)
                next--;
            if (next >= 34 /* Gap1 */)
                next--;
            let digit = next - 32 /* Start */;
            if (digit >= 46 /* Base */) {
                digit -= 46 /* Base */;
                stop = true;
            }
            value += digit;
            if (stop)
                break;
            value *= 46 /* Base */;
        }
        if (array)
            array[out++] = value;
        else
            array = new Type(value);
    }
    return array;
}

// FIXME find some way to reduce recovery work done when the input
// doesn't match the grammar at all.
// Environment variable used to control console output
const verbose = typeof process != "undefined" && /\bparse\b/.test(({"NODE_ENV":"development"}).LOG);
let stackIDs = null;
var Safety;
(function (Safety) {
    Safety[Safety["Margin"] = 25] = "Margin";
})(Safety || (Safety = {}));
function cutAt(tree, pos, side) {
    let cursor = tree.fullCursor();
    cursor.moveTo(pos);
    for (;;) {
        if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))
            for (;;) {
                if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)
                    return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25 /* Margin */))
                        : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25 /* Margin */));
                if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())
                    break;
                if (!cursor.parent())
                    return side < 0 ? 0 : tree.length;
            }
    }
}
class FragmentCursor {
    constructor(fragments, nodeSet) {
        this.fragments = fragments;
        this.nodeSet = nodeSet;
        this.i = 0;
        this.fragment = null;
        this.safeFrom = -1;
        this.safeTo = -1;
        this.trees = [];
        this.start = [];
        this.index = [];
        this.nextFragment();
    }
    nextFragment() {
        let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
        if (fr) {
            this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
            this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
            while (this.trees.length) {
                this.trees.pop();
                this.start.pop();
                this.index.pop();
            }
            this.trees.push(fr.tree);
            this.start.push(-fr.offset);
            this.index.push(0);
            this.nextStart = this.safeFrom;
        }
        else {
            this.nextStart = 1e9;
        }
    }
    // `pos` must be >= any previously given `pos` for this cursor
    nodeAt(pos) {
        if (pos < this.nextStart)
            return null;
        while (this.fragment && this.safeTo <= pos)
            this.nextFragment();
        if (!this.fragment)
            return null;
        for (;;) {
            let last = this.trees.length - 1;
            if (last < 0) { // End of tree
                this.nextFragment();
                return null;
            }
            let top = this.trees[last], index = this.index[last];
            if (index == top.children.length) {
                this.trees.pop();
                this.start.pop();
                this.index.pop();
                continue;
            }
            let next = top.children[index];
            let start = this.start[last] + top.positions[index];
            if (start > pos) {
                this.nextStart = start;
                return null;
            }
            if (next instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) {
                if (start == pos) {
                    if (start < this.safeFrom)
                        return null;
                    let end = start + next.length;
                    if (end <= this.safeTo) {
                        let lookAhead = next.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.lookAhead);
                        if (!lookAhead || end + lookAhead < this.fragment.to)
                            return next;
                    }
                }
                this.index[last]++;
                if (start + next.length >= Math.max(this.safeFrom, pos)) { // Enter this node
                    this.trees.push(next);
                    this.start.push(start);
                    this.index.push(0);
                }
            }
            else {
                this.index[last]++;
                this.nextStart = start + next.length;
            }
        }
    }
}
class TokenCache {
    constructor(parser, stream) {
        this.stream = stream;
        this.tokens = [];
        this.mainToken = null;
        this.actions = [];
        this.tokens = parser.tokenizers.map(_ => new CachedToken);
    }
    getActions(stack) {
        let actionIndex = 0;
        let main = null;
        let { parser } = stack.p, { tokenizers } = parser;
        let mask = parser.stateSlot(stack.state, 3 /* TokenizerMask */);
        let context = stack.curContext ? stack.curContext.hash : 0;
        let lookAhead = 0;
        for (let i = 0; i < tokenizers.length; i++) {
            if (((1 << i) & mask) == 0)
                continue;
            let tokenizer = tokenizers[i], token = this.tokens[i];
            if (main && !tokenizer.fallback)
                continue;
            if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {
                this.updateCachedToken(token, tokenizer, stack);
                token.mask = mask;
                token.context = context;
            }
            if (token.lookAhead > token.end + 25 /* Margin */)
                lookAhead = Math.max(token.lookAhead, lookAhead);
            if (token.value != 0 /* Err */) {
                let startIndex = actionIndex;
                if (token.extended > -1)
                    actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
                actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
                if (!tokenizer.extend) {
                    main = token;
                    if (actionIndex > startIndex)
                        break;
                }
            }
        }
        while (this.actions.length > actionIndex)
            this.actions.pop();
        if (lookAhead)
            stack.setLookAhead(lookAhead);
        if (!main && stack.pos == this.stream.end) {
            main = new CachedToken;
            main.value = stack.p.parser.eofTerm;
            main.start = main.end = stack.pos;
            actionIndex = this.addActions(stack, main.value, main.end, actionIndex);
        }
        this.mainToken = main;
        return this.actions;
    }
    getMainToken(stack) {
        if (this.mainToken)
            return this.mainToken;
        let main = new CachedToken, { pos, p } = stack;
        main.start = pos;
        main.end = Math.min(pos + 1, p.stream.end);
        main.value = pos == p.stream.end ? p.parser.eofTerm : 0 /* Err */;
        return main;
    }
    updateCachedToken(token, tokenizer, stack) {
        tokenizer.token(this.stream.reset(stack.pos, token), stack);
        if (token.value > -1) {
            let { parser } = stack.p;
            for (let i = 0; i < parser.specialized.length; i++)
                if (parser.specialized[i] == token.value) {
                    let result = parser.specializers[i](this.stream.read(token.start, token.end), stack);
                    if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
                        if ((result & 1) == 0 /* Specialize */)
                            token.value = result >> 1;
                        else
                            token.extended = result >> 1;
                        break;
                    }
                }
        }
        else {
            token.value = 0 /* Err */;
            token.end = Math.min(stack.p.stream.end, stack.pos + 1);
        }
    }
    putAction(action, token, end, index) {
        // Don't add duplicate actions
        for (let i = 0; i < index; i += 3)
            if (this.actions[i] == action)
                return index;
        this.actions[index++] = action;
        this.actions[index++] = token;
        this.actions[index++] = end;
        return index;
    }
    addActions(stack, token, end, index) {
        let { state } = stack, { parser } = stack.p, { data } = parser;
        for (let set = 0; set < 2; set++) {
            for (let i = parser.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */);; i += 3) {
                if (data[i] == 65535 /* End */) {
                    if (data[i + 1] == 1 /* Next */) {
                        i = pair(data, i + 2);
                    }
                    else {
                        if (index == 0 && data[i + 1] == 2 /* Other */)
                            index = this.putAction(pair(data, i + 2), token, end, index);
                        break;
                    }
                }
                if (data[i] == token)
                    index = this.putAction(pair(data, i + 1), token, end, index);
            }
        }
        return index;
    }
}
var Rec;
(function (Rec) {
    Rec[Rec["Distance"] = 5] = "Distance";
    Rec[Rec["MaxRemainingPerStep"] = 3] = "MaxRemainingPerStep";
    // When two stacks have been running independently long enough to
    // add this many elements to their buffers, prune one.
    Rec[Rec["MinBufferLengthPrune"] = 500] = "MinBufferLengthPrune";
    Rec[Rec["ForceReduceLimit"] = 10] = "ForceReduceLimit";
    // Once a stack reaches this depth (in .stack.length) force-reduce
    // it back to CutTo to avoid creating trees that overflow the stack
    // on recursive traversal.
    Rec[Rec["CutDepth"] = 15000] = "CutDepth";
    Rec[Rec["CutTo"] = 9000] = "CutTo";
})(Rec || (Rec = {}));
class Parse {
    constructor(parser, input, fragments, ranges) {
        this.parser = parser;
        this.input = input;
        this.ranges = ranges;
        this.recovering = 0;
        this.nextStackID = 0x2654; // , , , , , , , , , , , , , 
        this.minStackPos = 0;
        this.reused = [];
        this.stoppedAt = null;
        this.stream = new InputStream(input, ranges);
        this.tokens = new TokenCache(parser, this.stream);
        this.topTerm = parser.top[1];
        let { from } = ranges[0];
        this.stacks = [Stack.start(this, parser.top[0], from)];
        this.fragments = fragments.length && this.stream.end - from > parser.bufferLength * 4
            ? new FragmentCursor(fragments, parser.nodeSet) : null;
    }
    get parsedPos() {
        return this.minStackPos;
    }
    // Move the parser forward. This will process all parse stacks at
    // `this.pos` and try to advance them to a further position. If no
    // stack for such a position is found, it'll start error-recovery.
    //
    // When the parse is finished, this will return a syntax tree. When
    // not, it returns `null`.
    advance() {
        let stacks = this.stacks, pos = this.minStackPos;
        // This will hold stacks beyond `pos`.
        let newStacks = this.stacks = [];
        let stopped, stoppedTokens;
        // Keep advancing any stacks at `pos` until they either move
        // forward or can't be advanced. Gather stacks that can't be
        // advanced further in `stopped`.
        for (let i = 0; i < stacks.length; i++) {
            let stack = stacks[i];
            for (;;) {
                this.tokens.mainToken = null;
                if (stack.pos > pos) {
                    newStacks.push(stack);
                }
                else if (this.advanceStack(stack, newStacks, stacks)) {
                    continue;
                }
                else {
                    if (!stopped) {
                        stopped = [];
                        stoppedTokens = [];
                    }
                    stopped.push(stack);
                    let tok = this.tokens.getMainToken(stack);
                    stoppedTokens.push(tok.value, tok.end);
                }
                break;
            }
        }
        if (!newStacks.length) {
            let finished = stopped && findFinished(stopped);
            if (finished)
                return this.stackToTree(finished);
            if (this.parser.strict) {
                if (verbose && stopped)
                    console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"));
                throw new SyntaxError("No parse at " + pos);
            }
            if (!this.recovering)
                this.recovering = 5 /* Distance */;
        }
        if (this.recovering && stopped) {
            let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0]
                : this.runRecovery(stopped, stoppedTokens, newStacks);
            if (finished)
                return this.stackToTree(finished.forceAll());
        }
        if (this.recovering) {
            let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3 /* MaxRemainingPerStep */;
            if (newStacks.length > maxRemaining) {
                newStacks.sort((a, b) => b.score - a.score);
                while (newStacks.length > maxRemaining)
                    newStacks.pop();
            }
            if (newStacks.some(s => s.reducePos > pos))
                this.recovering--;
        }
        else if (newStacks.length > 1) {
            // Prune stacks that are in the same state, or that have been
            // running without splitting for a while, to avoid getting stuck
            // with multiple successful stacks running endlessly on.
            outer: for (let i = 0; i < newStacks.length - 1; i++) {
                let stack = newStacks[i];
                for (let j = i + 1; j < newStacks.length; j++) {
                    let other = newStacks[j];
                    if (stack.sameState(other) ||
                        stack.buffer.length > 500 /* MinBufferLengthPrune */ && other.buffer.length > 500 /* MinBufferLengthPrune */) {
                        if (((stack.score - other.score) || (stack.buffer.length - other.buffer.length)) > 0) {
                            newStacks.splice(j--, 1);
                        }
                        else {
                            newStacks.splice(i--, 1);
                            continue outer;
                        }
                    }
                }
            }
        }
        this.minStackPos = newStacks[0].pos;
        for (let i = 1; i < newStacks.length; i++)
            if (newStacks[i].pos < this.minStackPos)
                this.minStackPos = newStacks[i].pos;
        return null;
    }
    stopAt(pos) {
        if (this.stoppedAt != null && this.stoppedAt < pos)
            throw new RangeError("Can't move stoppedAt forward");
        this.stoppedAt = pos;
    }
    // Returns an updated version of the given stack, or null if the
    // stack can't advance normally. When `split` and `stacks` are
    // given, stacks split off by ambiguous operations will be pushed to
    // `split`, or added to `stacks` if they move `pos` forward.
    advanceStack(stack, stacks, split) {
        let start = stack.pos, { parser } = this;
        let base = verbose ? this.stackID(stack) + " -> " : "";
        if (this.stoppedAt != null && start > this.stoppedAt)
            return stack.forceReduce() ? stack : null;
        if (this.fragments) {
            let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;
            for (let cached = this.fragments.nodeAt(start); cached;) {
                let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;
                if (match > -1 && cached.length && (!strictCx || (cached.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.contextHash) || 0) == cxHash)) {
                    stack.useNode(cached, match);
                    if (verbose)
                        console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);
                    return true;
                }
                if (!(cached instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) || cached.children.length == 0 || cached.positions[0] > 0)
                    break;
                let inner = cached.children[0];
                if (inner instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree && cached.positions[0] == 0)
                    cached = inner;
                else
                    break;
            }
        }
        let defaultReduce = parser.stateSlot(stack.state, 4 /* DefaultReduce */);
        if (defaultReduce > 0) {
            stack.reduce(defaultReduce);
            if (verbose)
                console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535 /* ValueMask */)})`);
            return true;
        }
        if (stack.stack.length >= 15000 /* CutDepth */) {
            while (stack.stack.length > 9000 /* CutTo */ && stack.forceReduce()) { }
        }
        let actions = this.tokens.getActions(stack);
        for (let i = 0; i < actions.length;) {
            let action = actions[i++], term = actions[i++], end = actions[i++];
            let last = i == actions.length || !split;
            let localStack = last ? stack : stack.split();
            localStack.apply(action, term, end);
            if (verbose)
                console.log(base + this.stackID(localStack) + ` (via ${(action & 65536 /* ReduceFlag */) == 0 ? "shift"
                    : `reduce of ${parser.getName(action & 65535 /* ValueMask */)}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? "" : ", split"})`);
            if (last)
                return true;
            else if (localStack.pos > start)
                stacks.push(localStack);
            else
                split.push(localStack);
        }
        return false;
    }
    // Advance a given stack forward as far as it will go. Returns the
    // (possibly updated) stack if it got stuck, or null if it moved
    // forward and was given to `pushStackDedup`.
    advanceFully(stack, newStacks) {
        let pos = stack.pos;
        for (;;) {
            if (!this.advanceStack(stack, null, null))
                return false;
            if (stack.pos > pos) {
                pushStackDedup(stack, newStacks);
                return true;
            }
        }
    }
    runRecovery(stacks, tokens, newStacks) {
        let finished = null, restarted = false;
        for (let i = 0; i < stacks.length; i++) {
            let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];
            let base = verbose ? this.stackID(stack) + " -> " : "";
            if (stack.deadEnd) {
                if (restarted)
                    continue;
                restarted = true;
                stack.restart();
                if (verbose)
                    console.log(base + this.stackID(stack) + " (restarted)");
                let done = this.advanceFully(stack, newStacks);
                if (done)
                    continue;
            }
            let force = stack.split(), forceBase = base;
            for (let j = 0; force.forceReduce() && j < 10 /* ForceReduceLimit */; j++) {
                if (verbose)
                    console.log(forceBase + this.stackID(force) + " (via force-reduce)");
                let done = this.advanceFully(force, newStacks);
                if (done)
                    break;
                if (verbose)
                    forceBase = this.stackID(force) + " -> ";
            }
            for (let insert of stack.recoverByInsert(token)) {
                if (verbose)
                    console.log(base + this.stackID(insert) + " (via recover-insert)");
                this.advanceFully(insert, newStacks);
            }
            if (this.stream.end > stack.pos) {
                if (tokenEnd == stack.pos) {
                    tokenEnd++;
                    token = 0 /* Err */;
                }
                stack.recoverByDelete(token, tokenEnd);
                if (verbose)
                    console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
                pushStackDedup(stack, newStacks);
            }
            else if (!finished || finished.score < stack.score) {
                finished = stack;
            }
        }
        return finished;
    }
    // Convert the stack's buffer to a syntax tree.
    stackToTree(stack) {
        stack.close();
        return _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.build({ buffer: StackBufferCursor.create(stack),
            nodeSet: this.parser.nodeSet,
            topID: this.topTerm,
            maxBufferLength: this.parser.bufferLength,
            reused: this.reused,
            start: this.ranges[0].from,
            length: stack.pos - this.ranges[0].from,
            minRepeatType: this.parser.minRepeatTerm });
    }
    stackID(stack) {
        let id = (stackIDs || (stackIDs = new WeakMap)).get(stack);
        if (!id)
            stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));
        return id + stack;
    }
}
function pushStackDedup(stack, newStacks) {
    for (let i = 0; i < newStacks.length; i++) {
        let other = newStacks[i];
        if (other.pos == stack.pos && other.sameState(stack)) {
            if (newStacks[i].score < stack.score)
                newStacks[i] = stack;
            return;
        }
    }
    newStacks.push(stack);
}
class Dialect {
    constructor(source, flags, disabled) {
        this.source = source;
        this.flags = flags;
        this.disabled = disabled;
    }
    allows(term) { return !this.disabled || this.disabled[term] == 0; }
}
const id = x => x;
/// Context trackers are used to track stateful context (such as
/// indentation in the Python grammar, or parent elements in the XML
/// grammar) needed by external tokenizers. You declare them in a
/// grammar file as `@context exportName from "module"`.
///
/// Context values should be immutable, and can be updated (replaced)
/// on shift or reduce actions.
///
/// The export used in a `@context` declaration should be of this
/// type.
class ContextTracker {
    /// Define a context tracker.
    constructor(spec) {
        this.start = spec.start;
        this.shift = spec.shift || id;
        this.reduce = spec.reduce || id;
        this.reuse = spec.reuse || id;
        this.hash = spec.hash || (() => 0);
        this.strict = spec.strict !== false;
    }
}
/// A parser holds the parse tables for a given grammar, as generated
/// by `lezer-generator`.
class LRParser extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {
    /// @internal
    constructor(spec) {
        super();
        /// @internal
        this.wrappers = [];
        if (spec.version != 13 /* Version */)
            throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${13 /* Version */})`);
        let nodeNames = spec.nodeNames.split(" ");
        this.minRepeatTerm = nodeNames.length;
        for (let i = 0; i < spec.repeatNodeCount; i++)
            nodeNames.push("");
        let topTerms = Object.keys(spec.topRules).map(r => spec.topRules[r][1]);
        let nodeProps = [];
        for (let i = 0; i < nodeNames.length; i++)
            nodeProps.push([]);
        function setProp(nodeID, prop, value) {
            nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
        }
        if (spec.nodeProps)
            for (let propSpec of spec.nodeProps) {
                let prop = propSpec[0];
                for (let i = 1; i < propSpec.length;) {
                    let next = propSpec[i++];
                    if (next >= 0) {
                        setProp(next, prop, propSpec[i++]);
                    }
                    else {
                        let value = propSpec[i + -next];
                        for (let j = -next; j > 0; j--)
                            setProp(propSpec[i++], prop, value);
                        i++;
                    }
                }
            }
        this.nodeSet = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeSet(nodeNames.map((name, i) => _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({
            name: i >= this.minRepeatTerm ? undefined : name,
            id: i,
            props: nodeProps[i],
            top: topTerms.indexOf(i) > -1,
            error: i == 0,
            skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1
        })));
        this.strict = false;
        this.bufferLength = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.DefaultBufferLength;
        let tokenArray = decodeArray(spec.tokenData);
        this.context = spec.context;
        this.specialized = new Uint16Array(spec.specialized ? spec.specialized.length : 0);
        this.specializers = [];
        if (spec.specialized)
            for (let i = 0; i < spec.specialized.length; i++) {
                this.specialized[i] = spec.specialized[i].term;
                this.specializers[i] = spec.specialized[i].get;
            }
        this.states = decodeArray(spec.states, Uint32Array);
        this.data = decodeArray(spec.stateData);
        this.goto = decodeArray(spec.goto);
        this.maxTerm = spec.maxTerm;
        this.tokenizers = spec.tokenizers.map(value => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
        this.topRules = spec.topRules;
        this.dialects = spec.dialects || {};
        this.dynamicPrecedences = spec.dynamicPrecedences || null;
        this.tokenPrecTable = spec.tokenPrec;
        this.termNames = spec.termNames || null;
        this.maxNode = this.nodeSet.types.length - 1;
        this.dialect = this.parseDialect();
        this.top = this.topRules[Object.keys(this.topRules)[0]];
    }
    createParse(input, fragments, ranges) {
        let parse = new Parse(this, input, fragments, ranges);
        for (let w of this.wrappers)
            parse = w(parse, input, fragments, ranges);
        return parse;
    }
    /// Get a goto table entry @internal
    getGoto(state, term, loose = false) {
        let table = this.goto;
        if (term >= table[0])
            return -1;
        for (let pos = table[term + 1];;) {
            let groupTag = table[pos++], last = groupTag & 1;
            let target = table[pos++];
            if (last && loose)
                return target;
            for (let end = pos + (groupTag >> 1); pos < end; pos++)
                if (table[pos] == state)
                    return target;
            if (last)
                return -1;
        }
    }
    /// Check if this state has an action for a given terminal @internal
    hasAction(state, terminal) {
        let data = this.data;
        for (let set = 0; set < 2; set++) {
            for (let i = this.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */), next;; i += 3) {
                if ((next = data[i]) == 65535 /* End */) {
                    if (data[i + 1] == 1 /* Next */)
                        next = data[i = pair(data, i + 2)];
                    else if (data[i + 1] == 2 /* Other */)
                        return pair(data, i + 2);
                    else
                        break;
                }
                if (next == terminal || next == 0 /* Err */)
                    return pair(data, i + 1);
            }
        }
        return 0;
    }
    /// @internal
    stateSlot(state, slot) {
        return this.states[(state * 6 /* Size */) + slot];
    }
    /// @internal
    stateFlag(state, flag) {
        return (this.stateSlot(state, 0 /* Flags */) & flag) > 0;
    }
    /// @internal
    validAction(state, action) {
        if (action == this.stateSlot(state, 4 /* DefaultReduce */))
            return true;
        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {
            if (this.data[i] == 65535 /* End */) {
                if (this.data[i + 1] == 1 /* Next */)
                    i = pair(this.data, i + 2);
                else
                    return false;
            }
            if (action == pair(this.data, i + 1))
                return true;
        }
    }
    /// Get the states that can follow this one through shift actions or
    /// goto jumps. @internal
    nextStates(state) {
        let result = [];
        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {
            if (this.data[i] == 65535 /* End */) {
                if (this.data[i + 1] == 1 /* Next */)
                    i = pair(this.data, i + 2);
                else
                    break;
            }
            if ((this.data[i + 2] & (65536 /* ReduceFlag */ >> 16)) == 0) {
                let value = this.data[i + 1];
                if (!result.some((v, i) => (i & 1) && v == value))
                    result.push(this.data[i], value);
            }
        }
        return result;
    }
    /// @internal
    overrides(token, prev) {
        let iPrev = findOffset(this.data, this.tokenPrecTable, prev);
        return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev;
    }
    /// Configure the parser. Returns a new parser instance that has the
    /// given settings modified. Settings not provided in `config` are
    /// kept from the original parser.
    configure(config) {
        // Hideous reflection-based kludge to make it easy to create a
        // slightly modified copy of a parser.
        let copy = Object.assign(Object.create(LRParser.prototype), this);
        if (config.props)
            copy.nodeSet = this.nodeSet.extend(...config.props);
        if (config.top) {
            let info = this.topRules[config.top];
            if (!info)
                throw new RangeError(`Invalid top rule name ${config.top}`);
            copy.top = info;
        }
        if (config.tokenizers)
            copy.tokenizers = this.tokenizers.map(t => {
                let found = config.tokenizers.find(r => r.from == t);
                return found ? found.to : t;
            });
        if (config.contextTracker)
            copy.context = config.contextTracker;
        if (config.dialect)
            copy.dialect = this.parseDialect(config.dialect);
        if (config.strict != null)
            copy.strict = config.strict;
        if (config.wrap)
            copy.wrappers = copy.wrappers.concat(config.wrap);
        if (config.bufferLength != null)
            copy.bufferLength = config.bufferLength;
        return copy;
    }
    /// Returns the name associated with a given term. This will only
    /// work for all terms when the parser was generated with the
    /// `--names` option. By default, only the names of tagged terms are
    /// stored.
    getName(term) {
        return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
    }
    /// The eof term id is always allocated directly after the node
    /// types. @internal
    get eofTerm() { return this.maxNode + 1; }
    /// The type of top node produced by the parser.
    get topNode() { return this.nodeSet.types[this.top[1]]; }
    /// @internal
    dynamicPrecedence(term) {
        let prec = this.dynamicPrecedences;
        return prec == null ? 0 : prec[term] || 0;
    }
    /// @internal
    parseDialect(dialect) {
        let values = Object.keys(this.dialects), flags = values.map(() => false);
        if (dialect)
            for (let part of dialect.split(" ")) {
                let id = values.indexOf(part);
                if (id >= 0)
                    flags[id] = true;
            }
        let disabled = null;
        for (let i = 0; i < values.length; i++)
            if (!flags[i]) {
                for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535 /* End */;)
                    (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;
            }
        return new Dialect(dialect, flags, disabled);
    }
    /// (used by the output of the parser generator) @internal
    static deserialize(spec) {
        return new LRParser(spec);
    }
}
function pair(data, off) { return data[off] | (data[off + 1] << 16); }
function findOffset(data, start, term) {
    for (let i = start, next; (next = data[i]) != 65535 /* End */; i++)
        if (next == term)
            return i - start;
    return -1;
}
function findFinished(stacks) {
    let best = null;
    for (let stack of stacks) {
        let stopped = stack.p.stoppedAt;
        if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) &&
            stack.p.parser.stateFlag(stack.state, 2 /* Accepting */) &&
            (!best || best.score < stack.score))
            best = stack;
    }
    return best;
}




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtHQUFBQSxxQ0FBQUE7O0FBU0wsSUFBS21CLGVBQVo7O1dBQVlBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FB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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0Msa0JBQWtCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksdUNBQXVDLElBQUk7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsK0JBQStCLElBQUk7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBLDBCQUEwQiwyQkFBMkI7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLGtCQUFrQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsMUJxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFeUk7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RwRDFDOztBQUUvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJEQUEyRCxJQUFJLFNBQVMsRUFBRSxtQ0FBbUM7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQsc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsdUJBQXVCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDZEQUE2RDtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwREFBMEQ7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGtCQUFrQjtBQUNsQixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQSwyREFBMkQseUNBQXlDO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLDhCQUE4QixxQ0FBcUM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUyRSIsInNvdXJjZXMiOlsid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL2NvcmUvdXRpbHMvQ2FuY2VsYWJsZVByb21pc2UudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvYWRkX2xhYmVsX3RvX3F1ZXJ5LnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL2NvbXBvbmVudHMvUHJvbUNoZWF0U2hlZXQudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL2NvbXBvbmVudHMvUHJvbUV4ZW1wbGFyRmllbGQudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL2NvbXBvbmVudHMvUHJvbUV4cGxvcmVFeHRyYUZpZWxkLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9jb21wb25lbnRzL1Byb21FeHBsb3JlUXVlcnlFZGl0b3IudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL2NvbXBvbmVudHMvUHJvbUxpbmsudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL2NvbXBvbmVudHMvUHJvbVF1ZXJ5RWRpdG9yLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9jb21wb25lbnRzL1Byb21RdWVyeUVkaXRvckJ5QXBwLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9jb21wb25lbnRzL1Byb21RdWVyeUVkaXRvckZvckFsZXJ0aW5nLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9jb21wb25lbnRzL1Byb21RdWVyeUZpZWxkLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9jb21wb25lbnRzL1Byb21ldGhldXNNZXRyaWNzQnJvd3Nlci50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvY29tcG9uZW50cy9tb25hY28tcXVlcnktZmllbGQvTW9uYWNvUXVlcnlGaWVsZExhenkudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL2NvbXBvbmVudHMvbW9uYWNvLXF1ZXJ5LWZpZWxkL01vbmFjb1F1ZXJ5RmllbGRXcmFwcGVyLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9jb25maWd1cmF0aW9uL0F6dXJlQXV0aFNldHRpbmdzLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9jb25maWd1cmF0aW9uL0F6dXJlQ3JlZGVudGlhbHMudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvY29uZmlndXJhdGlvbi9BenVyZUNyZWRlbnRpYWxzQ29uZmlnLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL2NvbmZpZ3VyYXRpb24vQXp1cmVDcmVkZW50aWFsc0Zvcm0udHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL2NvbmZpZ3VyYXRpb24vQ29uZmlnRWRpdG9yLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9jb25maWd1cmF0aW9uL0V4ZW1wbGFyU2V0dGluZy50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvY29uZmlndXJhdGlvbi9FeGVtcGxhcnNTZXR0aW5ncy50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvY29uZmlndXJhdGlvbi9Qcm9tU2V0dGluZ3MudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL2RhdGFzb3VyY2UudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL2xhbmd1YWdlX3Byb3ZpZGVyLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL2xhbmd1YWdlX3V0aWxzLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL21ldHJpY19maW5kX3F1ZXJ5LnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL21vZHVsZS50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9wcm9tcWwudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlfaGludHMudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL1Byb21RdWVyeU1vZGVsbGVyLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9hZ2dyZWdhdGlvbnMudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL2JpbmFyeVNjYWxhck9wZXJhdGlvbnMudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL2NvbXBvbmVudHMvTGFiZWxQYXJhbUVkaXRvci50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL2NvbXBvbmVudHMvTWV0cmljU2VsZWN0LnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvY29tcG9uZW50cy9OZXN0ZWRRdWVyeS50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL2NvbXBvbmVudHMvTmVzdGVkUXVlcnlMaXN0LnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvY29tcG9uZW50cy9Qcm9tUXVlcnlCdWlsZGVyLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvY29tcG9uZW50cy9Qcm9tUXVlcnlCdWlsZGVyQ29udGFpbmVyLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvY29tcG9uZW50cy9Qcm9tUXVlcnlCdWlsZGVyRXhwbGFpbmVkLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvY29tcG9uZW50cy9Qcm9tUXVlcnlCdWlsZGVySGludHMudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9jb21wb25lbnRzL1Byb21RdWVyeUJ1aWxkZXJPcHRpb25zLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvY29tcG9uZW50cy9Qcm9tUXVlcnlDb2RlRWRpdG9yLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvY29tcG9uZW50cy9Qcm9tUXVlcnlFZGl0b3JTZWxlY3Rvci50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL2NvbXBvbmVudHMvUHJvbVF1ZXJ5TGVnZW5kRWRpdG9yLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvY29tcG9uZW50cy9RdWVyeVByZXZpZXcudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9vcGVyYXRpb25zLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9wYXJzaW5nLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvQXV0b1NpemVJbnB1dC50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9GZWVkYmFja0xpbmsudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvTGFiZWxGaWx0ZXJJdGVtLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL0xhYmVsRmlsdGVycy50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9Mb2tpQW5kUHJvbVF1ZXJ5TW9kZWxsZXJCYXNlLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvT3BlcmF0aW9uRWRpdG9yLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL09wZXJhdGlvbkV4cGxhaW5lZEJveC50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9PcGVyYXRpb25IZWFkZXIudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvT3BlcmF0aW9uSW5mb0J1dHRvbi50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9PcGVyYXRpb25MaXN0LnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL09wZXJhdGlvbkxpc3RFeHBsYWluZWQudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvT3BlcmF0aW9uUGFyYW1FZGl0b3IudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvT3BlcmF0aW9uc0VkaXRvclJvdy50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9RdWVyeUVkaXRvck1vZGVUb2dnbGUudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvUXVlcnlIZWFkZXJTd2l0Y2gudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvUXVlcnlPcHRpb25Hcm91cC50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9vcGVyYXRpb25VdGlscy50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL3BhcnNpbmdVdGlscy50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL3R5cGVzLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zdGF0ZS50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvdHlwZXMudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcmVzdWx0X3RyYW5zZm9ybWVyLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3R5cGVzLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3ZhcmlhYmxlcy50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vX192aXJ0dWFsX18vcmVhY3QtdXNlLXZpcnR1YWwtMDAzMjZlNzBiYS8wL2NhY2hlL3JlYWN0LXVzZS1ucG0tMTcuMy4yLWEwMzJjYmViMDEtNzM3OTQ2MGY1MS56aXAvbm9kZV9tb2R1bGVzL3JlYWN0LXVzZS9lc20vdXNlUHJldmlvdXMuanMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uLy55YXJuL19fdmlydHVhbF9fL3JlYWN0LXVzZS12aXJ0dWFsLTAwMzI2ZTcwYmEvMC9jYWNoZS9yZWFjdC11c2UtbnBtLTE3LjMuMi1hMDMyY2JlYjAxLTczNzk0NjBmNTEuemlwL25vZGVfbW9kdWxlcy9yZWFjdC11c2UvZXNtL3VzZVRvZ2dsZS5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vY2FjaGUvbHJ1LWNhY2hlLW5wbS03LjkuMC1kODAzMTA4MjMzLWM5MWEyOTNhMTAuemlwL25vZGVfbW9kdWxlcy9scnUtY2FjaGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uLy55YXJuL19fdmlydHVhbF9fL2xlemVyLXByb21xbC12aXJ0dWFsLWVhZjg4YWE3N2EvMC9jYWNoZS9sZXplci1wcm9tcWwtbnBtLTAuMjIuMC04NjdkYTZhZmFhLWNkY2UwNTQ3MDAuemlwL25vZGVfbW9kdWxlcy9sZXplci1wcm9tcWwvaW5kZXguZXMuanMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uLy55YXJuL2NhY2hlL0BsZXplci1jb21tb24tbnBtLTAuMTUuMTItNjIwMTcyNzJiMC1kYWU2NTgxNjE4LnppcC9ub2RlX21vZHVsZXMvQGxlemVyL2NvbW1vbi9kaXN0L2luZGV4LmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9jYWNoZS9AbGV6ZXItbHItbnBtLTAuMTUuOC04YzQ4MWMzOWNkLWU3NDEyMjVkNmEuemlwL25vZGVfbW9kdWxlcy9AbGV6ZXIvbHIvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzU0NjVcblxuZXhwb3J0IGludGVyZmFjZSBDYW5jZWxhYmxlUHJvbWlzZTxUPiB7XG4gIHByb21pc2U6IFByb21pc2U8VD47XG4gIGNhbmNlbDogKCkgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGNvbnN0IG1ha2VQcm9taXNlQ2FuY2VsYWJsZSA9IDxUPihwcm9taXNlOiBQcm9taXNlPFQ+KTogQ2FuY2VsYWJsZVByb21pc2U8VD4gPT4ge1xuICBsZXQgaGFzQ2FuY2VsZWRfID0gZmFsc2U7XG5cbiAgY29uc3Qgd3JhcHBlZFByb21pc2UgPSBuZXcgUHJvbWlzZTxUPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgcHJvbWlzZS50aGVuKCh2YWwpID0+IChoYXNDYW5jZWxlZF8gPyByZWplY3QoeyBpc0NhbmNlbGVkOiB0cnVlIH0pIDogcmVzb2x2ZSh2YWwpKSk7XG4gICAgcHJvbWlzZS5jYXRjaCgoZXJyb3IpID0+IChoYXNDYW5jZWxlZF8gPyByZWplY3QoeyBpc0NhbmNlbGVkOiB0cnVlIH0pIDogcmVqZWN0KGVycm9yKSkpO1xuICB9KTtcblxuICByZXR1cm4ge1xuICAgIHByb21pc2U6IHdyYXBwZWRQcm9taXNlLFxuICAgIGNhbmNlbCgpIHtcbiAgICAgIGhhc0NhbmNlbGVkXyA9IHRydWU7XG4gICAgfSxcbiAgfTtcbn07XG4iLCJpbXBvcnQgeyBwYXJzZXIgfSBmcm9tICdsZXplci1wcm9tcWwnO1xuXG5pbXBvcnQgeyBQcm9tUXVlcnlNb2RlbGxlciB9IGZyb20gJy4vcXVlcnlidWlsZGVyL1Byb21RdWVyeU1vZGVsbGVyJztcbmltcG9ydCB7IGJ1aWxkVmlzdWFsUXVlcnlGcm9tU3RyaW5nIH0gZnJvbSAnLi9xdWVyeWJ1aWxkZXIvcGFyc2luZyc7XG5pbXBvcnQgeyBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlciB9IGZyb20gJy4vcXVlcnlidWlsZGVyL3NoYXJlZC90eXBlcyc7XG5pbXBvcnQgeyBQcm9tVmlzdWFsUXVlcnkgfSBmcm9tICcuL3F1ZXJ5YnVpbGRlci90eXBlcyc7XG5cbi8qKlxuICogQWRkcyBsYWJlbCBmaWx0ZXIgdG8gZXhpc3RpbmcgcXVlcnkuIFVzZWZ1bCBmb3IgcXVlcnkgbW9kaWZpY2F0aW9uIGZvciBleGFtcGxlIGZvciBhZCBob2MgZmlsdGVycy5cbiAqXG4gKiBJdCB1c2VzIFByb21RTCBwYXJzZXIgdG8gZmluZCBpbnN0YW5jZXMgb2YgbWV0cmljIGFuZCBsYWJlbHMsIGFsdGVycyB0aGVtIGFuZCB0aGVuIHNwbGljZXMgdGhlbSBiYWNrIGludG8gdGhlIHF1ZXJ5LlxuICogSWRlYWxseSB3ZSBjb3VsZCB1c2UgdGhlIHBhcnNlIC0+IGNoYW5nZSAtPiByZW5kZXIgaXMgYSBzaW1wbGUgMyBzdGVwcyBidXQgcmlnaHQgbm93IGJ1aWxkaW5nIHRoZSB2aXN1YWwgcXVlcnlcbiAqIG9iamVjdCBkb2VzIG5vdCBzdXBwb3J0IGFsbCBwb3NzaWJsZSBxdWVyaWVzLlxuICpcbiAqIFNvIGluc3RlYWQgdGhpcyBqdXN0IG9wZXJhdGVzIG9uIHN1YnN0cmluZ3Mgb2YgdGhlIHF1ZXJ5IHdpdGggbGFiZWxzIGFuZCBvcGVyYXRlcyBqdXN0IG9uIHRob3NlLiBUaGlzIG1ha2VzIHRoaXNcbiAqIG1vcmUgcm9idXN0IGFuZCBjYW4gYWx0ZXIgZXZlbiBpbnZhbGlkIHF1ZXJpZXMsIGFuZCBwcmVzZXJ2ZXMgaW4gZ2VuZXJhbCB0aGUgcXVlcnkgc3RydWN0dXJlIGFuZCB3aGl0ZXNwYWNlLlxuICogQHBhcmFtIHF1ZXJ5XG4gKiBAcGFyYW0ga2V5XG4gKiBAcGFyYW0gdmFsdWVcbiAqIEBwYXJhbSBvcGVyYXRvclxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkTGFiZWxUb1F1ZXJ5KHF1ZXJ5OiBzdHJpbmcsIGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nIHwgbnVtYmVyLCBvcGVyYXRvciA9ICc9Jyk6IHN0cmluZyB7XG4gIGlmICgha2V5IHx8ICF2YWx1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTmVlZCBsYWJlbCB0byBhZGQgdG8gcXVlcnkuJyk7XG4gIH1cblxuICBjb25zdCB2ZWN0b3JTZWxlY3RvclBvc2l0aW9ucyA9IGdldFZlY3RvclNlbGVjdG9yUG9zaXRpb25zKHF1ZXJ5KTtcbiAgaWYgKCF2ZWN0b3JTZWxlY3RvclBvc2l0aW9ucy5sZW5ndGgpIHtcbiAgICByZXR1cm4gcXVlcnk7XG4gIH1cblxuICBjb25zdCBmaWx0ZXIgPSB0b0xhYmVsRmlsdGVyKGtleSwgdmFsdWUsIG9wZXJhdG9yKTtcbiAgcmV0dXJuIGFkZEZpbHRlcihxdWVyeSwgdmVjdG9yU2VsZWN0b3JQb3NpdGlvbnMsIGZpbHRlcik7XG59XG5cbnR5cGUgVmVjdG9yU2VsZWN0b3JQb3NpdGlvbiA9IHsgZnJvbTogbnVtYmVyOyB0bzogbnVtYmVyOyBxdWVyeTogUHJvbVZpc3VhbFF1ZXJ5IH07XG5cbi8qKlxuICogUGFyc2UgdGhlIHN0cmluZyBhbmQgZ2V0IGFsbCBWZWN0b3JTZWxlY3RvciBwb3NpdGlvbnMgaW4gdGhlIHF1ZXJ5IHRvZ2V0aGVyIHdpdGggcGFyc2VkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcbiAqIHNlbGVjdG9yLlxuICogQHBhcmFtIHF1ZXJ5XG4gKi9cbmZ1bmN0aW9uIGdldFZlY3RvclNlbGVjdG9yUG9zaXRpb25zKHF1ZXJ5OiBzdHJpbmcpOiBWZWN0b3JTZWxlY3RvclBvc2l0aW9uW10ge1xuICBjb25zdCB0cmVlID0gcGFyc2VyLnBhcnNlKHF1ZXJ5KTtcbiAgY29uc3QgcG9zaXRpb25zOiBWZWN0b3JTZWxlY3RvclBvc2l0aW9uW10gPSBbXTtcbiAgdHJlZS5pdGVyYXRlKHtcbiAgICBlbnRlcjogKHR5cGUsIGZyb20sIHRvLCBnZXQpOiBmYWxzZSB8IHZvaWQgPT4ge1xuICAgICAgaWYgKHR5cGUubmFtZSA9PT0gJ1ZlY3RvclNlbGVjdG9yJykge1xuICAgICAgICBjb25zdCB2aXNRdWVyeSA9IGJ1aWxkVmlzdWFsUXVlcnlGcm9tU3RyaW5nKHF1ZXJ5LnN1YnN0cmluZyhmcm9tLCB0bykpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaCh7IHF1ZXJ5OiB2aXNRdWVyeS5xdWVyeSwgZnJvbSwgdG8gfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuICB9KTtcbiAgcmV0dXJuIHBvc2l0aW9ucztcbn1cblxuZnVuY3Rpb24gdG9MYWJlbEZpbHRlcihrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZyB8IG51bWJlciwgb3BlcmF0b3I6IHN0cmluZyk6IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyIHtcbiAgLy8gV2UgbmVlZCB0byBtYWtlIHN1cmUgdGhhdCB3ZSBjb252ZXJ0IHRoZSB2YWx1ZSBiYWNrIHRvIHN0cmluZyBiZWNhdXNlIGl0IG1heSBiZSBhIG51bWJlclxuICBjb25zdCB0cmFuc2Zvcm1lZFZhbHVlID0gdmFsdWUgPT09IEluZmluaXR5ID8gJytJbmYnIDogdmFsdWUudG9TdHJpbmcoKTtcbiAgcmV0dXJuIHsgbGFiZWw6IGtleSwgb3A6IG9wZXJhdG9yLCB2YWx1ZTogdHJhbnNmb3JtZWRWYWx1ZSB9O1xufVxuXG5mdW5jdGlvbiBhZGRGaWx0ZXIoXG4gIHF1ZXJ5OiBzdHJpbmcsXG4gIHZlY3RvclNlbGVjdG9yUG9zaXRpb25zOiBWZWN0b3JTZWxlY3RvclBvc2l0aW9uW10sXG4gIGZpbHRlcjogUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXJcbik6IHN0cmluZyB7XG4gIGNvbnN0IG1vZGVsbGVyID0gbmV3IFByb21RdWVyeU1vZGVsbGVyKCk7XG4gIGxldCBuZXdRdWVyeSA9ICcnO1xuICBsZXQgcHJldiA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZWN0b3JTZWxlY3RvclBvc2l0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIC8vIFRoaXMgaXMgYmFzaWNhbGx5IGp1c3QgZG9pbmcgc3BsaWNlIG9uIGEgc3RyaW5nIGZvciBlYWNoIG1hdGNoZWQgdmVjdG9yIHNlbGVjdG9yLlxuXG4gICAgY29uc3QgbWF0Y2ggPSB2ZWN0b3JTZWxlY3RvclBvc2l0aW9uc1tpXTtcbiAgICBjb25zdCBpc0xhc3QgPSBpID09PSB2ZWN0b3JTZWxlY3RvclBvc2l0aW9ucy5sZW5ndGggLSAxO1xuXG4gICAgY29uc3Qgc3RhcnQgPSBxdWVyeS5zdWJzdHJpbmcocHJldiwgbWF0Y2guZnJvbSk7XG4gICAgY29uc3QgZW5kID0gaXNMYXN0ID8gcXVlcnkuc3Vic3RyaW5nKG1hdGNoLnRvKSA6ICcnO1xuXG4gICAgaWYgKCFsYWJlbEV4aXN0cyhtYXRjaC5xdWVyeS5sYWJlbHMsIGZpbHRlcikpIHtcbiAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gYWRkIGR1cGxpY2F0ZSBsYWJlbHMuXG4gICAgICBtYXRjaC5xdWVyeS5sYWJlbHMucHVzaChmaWx0ZXIpO1xuICAgIH1cbiAgICBjb25zdCBuZXdMYWJlbHMgPSBtb2RlbGxlci5yZW5kZXJRdWVyeShtYXRjaC5xdWVyeSk7XG4gICAgbmV3UXVlcnkgKz0gc3RhcnQgKyBuZXdMYWJlbHMgKyBlbmQ7XG4gICAgcHJldiA9IG1hdGNoLnRvO1xuICB9XG4gIHJldHVybiBuZXdRdWVyeTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBsYWJlbCBleGlzdHMgaW4gdGhlIGxpc3Qgb2YgbGFiZWxzIGJ1dCBpZ25vcmUgdGhlIG9wZXJhdG9yLlxuICogQHBhcmFtIGxhYmVsc1xuICogQHBhcmFtIGZpbHRlclxuICovXG5mdW5jdGlvbiBsYWJlbEV4aXN0cyhsYWJlbHM6IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyW10sIGZpbHRlcjogUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXIpIHtcbiAgcmV0dXJuIGxhYmVscy5maW5kKChsYWJlbCkgPT4gbGFiZWwubGFiZWwgPT09IGZpbHRlci5sYWJlbCAmJiBsYWJlbC52YWx1ZSA9PT0gZmlsdGVyLnZhbHVlKTtcbn1cbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IFF1ZXJ5RWRpdG9ySGVscFByb3BzIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5cbmltcG9ydCB7IFByb21RdWVyeSB9IGZyb20gJy4uL3R5cGVzJztcblxuY29uc3QgQ0hFQVRfU0hFRVRfSVRFTVMgPSBbXG4gIHtcbiAgICB0aXRsZTogJ1JlcXVlc3QgUmF0ZScsXG4gICAgZXhwcmVzc2lvbjogJ3JhdGUoaHR0cF9yZXF1ZXN0X3RvdGFsWzVtXSknLFxuICAgIGxhYmVsOlxuICAgICAgJ0dpdmVuIGFuIEhUVFAgcmVxdWVzdCBjb3VudGVyLCB0aGlzIHF1ZXJ5IGNhbGN1bGF0ZXMgdGhlIHBlci1zZWNvbmQgYXZlcmFnZSByZXF1ZXN0IHJhdGUgb3ZlciB0aGUgbGFzdCA1IG1pbnV0ZXMuJyxcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnOTV0aCBQZXJjZW50aWxlIG9mIFJlcXVlc3QgTGF0ZW5jaWVzJyxcbiAgICBleHByZXNzaW9uOiAnaGlzdG9ncmFtX3F1YW50aWxlKDAuOTUsIHN1bShyYXRlKHByb21ldGhldXNfaHR0cF9yZXF1ZXN0X2R1cmF0aW9uX3NlY29uZHNfYnVja2V0WzVtXSkpIGJ5IChsZSkpJyxcbiAgICBsYWJlbDogJ0NhbGN1bGF0ZXMgdGhlIDk1dGggcGVyY2VudGlsZSBvZiBIVFRQIHJlcXVlc3QgcmF0ZSBvdmVyIDUgbWludXRlIHdpbmRvd3MuJyxcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQWxlcnRzIEZpcmluZycsXG4gICAgZXhwcmVzc2lvbjogJ3NvcnRfZGVzYyhzdW0oc3VtX292ZXJfdGltZShBTEVSVFN7YWxlcnRzdGF0ZT1cImZpcmluZ1wifVsyNGhdKSkgYnkgKGFsZXJ0bmFtZSkpJyxcbiAgICBsYWJlbDogJ1N1bXMgdXAgdGhlIGFsZXJ0cyB0aGF0IGhhdmUgYmVlbiBmaXJpbmcgb3ZlciB0aGUgbGFzdCAyNCBob3Vycy4nLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdTdGVwJyxcbiAgICBsYWJlbDpcbiAgICAgICdEZWZpbmVzIHRoZSBncmFwaCByZXNvbHV0aW9uIHVzaW5nIGEgZHVyYXRpb24gZm9ybWF0ICgxNXMsIDFtLCAzaCwgLi4uKS4gU21hbGwgc3RlcHMgY3JlYXRlIGhpZ2gtcmVzb2x1dGlvbiBncmFwaHMgYnV0IGNhbiBiZSBzbG93IG92ZXIgbGFyZ2VyIHRpbWUgcmFuZ2VzLiBVc2luZyBhIGxvbmdlciBzdGVwIGxvd2VycyB0aGUgcmVzb2x1dGlvbiBhbmQgc21vb3RocyB0aGUgZ3JhcGggYnkgcHJvZHVjaW5nIGZld2VyIGRhdGFwb2ludHMuIElmIG5vIHN0ZXAgaXMgZ2l2ZW4gdGhlIHJlc29sdXRpb24gaXMgY2FsY3VsYXRlZCBhdXRvbWF0aWNhbGx5LicsXG4gIH0sXG5dO1xuXG5jb25zdCBQcm9tQ2hlYXRTaGVldCA9IChwcm9wczogUXVlcnlFZGl0b3JIZWxwUHJvcHM8UHJvbVF1ZXJ5PikgPT4gKFxuICA8ZGl2PlxuICAgIDxoMj5Qcm9tUUwgQ2hlYXQgU2hlZXQ8L2gyPlxuICAgIHtDSEVBVF9TSEVFVF9JVEVNUy5tYXAoKGl0ZW0sIGluZGV4KSA9PiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImNoZWF0LXNoZWV0LWl0ZW1cIiBrZXk9e2luZGV4fT5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjaGVhdC1zaGVldC1pdGVtX190aXRsZVwiPntpdGVtLnRpdGxlfTwvZGl2PlxuICAgICAgICB7aXRlbS5leHByZXNzaW9uID8gKFxuICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cImNoZWF0LXNoZWV0LWl0ZW1fX2V4YW1wbGVcIlxuICAgICAgICAgICAgb25DbGljaz17KGUpID0+IHByb3BzLm9uQ2xpY2tFeGFtcGxlKHsgcmVmSWQ6ICdBJywgZXhwcjogaXRlbS5leHByZXNzaW9uIH0pfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxjb2RlPntpdGVtLmV4cHJlc3Npb259PC9jb2RlPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApIDogbnVsbH1cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjaGVhdC1zaGVldC1pdGVtX19sYWJlbFwiPntpdGVtLmxhYmVsfTwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKSl9XG4gIDwvZGl2PlxuKTtcblxuZXhwb3J0IGRlZmF1bHQgUHJvbUNoZWF0U2hlZXQ7XG4iLCJpbXBvcnQgeyBjc3MsIGN4IH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlUHJldmlvdXMgfSBmcm9tICdyZWFjdC11c2UnO1xuXG5pbXBvcnQgeyBHcmFmYW5hVGhlbWUyIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBJY29uQnV0dG9uLCBJbmxpbmVMYWJlbCwgVG9vbHRpcCwgdXNlU3R5bGVzMiB9IGZyb20gJ0BncmFmYW5hL3VpJztcblxuaW1wb3J0IHsgUHJvbWV0aGV1c0RhdGFzb3VyY2UgfSBmcm9tICcuLi9kYXRhc291cmNlJztcbmltcG9ydCB7IFByb21RdWVyeSB9IGZyb20gJy4uL3R5cGVzJztcblxuaW50ZXJmYWNlIFByb3BzIHtcbiAgb25DaGFuZ2U6IChleGVtcGxhcjogYm9vbGVhbikgPT4gdm9pZDtcbiAgZGF0YXNvdXJjZTogUHJvbWV0aGV1c0RhdGFzb3VyY2U7XG4gIHF1ZXJ5OiBQcm9tUXVlcnk7XG4gICdkYXRhLXRlc3RpZCc/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBQcm9tRXhlbXBsYXJGaWVsZCh7IGRhdGFzb3VyY2UsIG9uQ2hhbmdlLCBxdWVyeSwgLi4ucmVzdCB9OiBQcm9wcykge1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICBjb25zdCBzdHlsZXMgPSB1c2VTdHlsZXMyKGdldFN0eWxlcyk7XG4gIGNvbnN0IHByZXZFcnJvciA9IHVzZVByZXZpb3VzKGVycm9yKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZGF0YXNvdXJjZS5leGVtcGxhcnNBdmFpbGFibGUpIHtcbiAgICAgIHNldEVycm9yKCdFeGVtcGxhcnMgZm9yIHRoaXMgcXVlcnkgYXJlIG5vdCBhdmFpbGFibGUnKTtcbiAgICAgIG9uQ2hhbmdlKGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKHF1ZXJ5Lmluc3RhbnQgJiYgIXF1ZXJ5LnJhbmdlKSB7XG4gICAgICBzZXRFcnJvcignRXhlbXBsYXJzIGFyZSBub3QgYXZhaWxhYmxlIGZvciBpbnN0YW50IHF1ZXJpZXMnKTtcbiAgICAgIG9uQ2hhbmdlKGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0RXJyb3IobnVsbCk7XG4gICAgICAvLyBJZiBlcnJvciBpcyBjbGVhcmVkLCB3ZSB3YW50IHRvIGNoYW5nZSBleGVtcGxhciB0byB0cnVlXG4gICAgICBpZiAocHJldkVycm9yICYmICFlcnJvcikge1xuICAgICAgICBvbkNoYW5nZSh0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtkYXRhc291cmNlLmV4ZW1wbGFyc0F2YWlsYWJsZSwgcXVlcnkuaW5zdGFudCwgcXVlcnkucmFuZ2UsIG9uQ2hhbmdlLCBwcmV2RXJyb3IsIGVycm9yXSk7XG5cbiAgY29uc3QgaWNvbkJ1dHRvblN0eWxlcyA9IGN4KFxuICAgIHtcbiAgICAgIFtzdHlsZXMuYWN0aXZlSWNvbl06ICEhcXVlcnkuZXhlbXBsYXIsXG4gICAgfSxcbiAgICBzdHlsZXMuZXllSWNvblxuICApO1xuXG4gIHJldHVybiAoXG4gICAgPElubGluZUxhYmVsIHdpZHRoPVwiYXV0b1wiIGRhdGEtdGVzdGlkPXtyZXN0WydkYXRhLXRlc3RpZCddfT5cbiAgICAgIDxUb29sdGlwIGNvbnRlbnQ9e2Vycm9yID8/ICcnfT5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5pY29uV3JhcHBlcn0+XG4gICAgICAgICAgRXhlbXBsYXJzXG4gICAgICAgICAgPEljb25CdXR0b25cbiAgICAgICAgICAgIG5hbWU9XCJleWVcIlxuICAgICAgICAgICAgdG9vbHRpcD17ISFxdWVyeS5leGVtcGxhciA/ICdEaXNhYmxlIHF1ZXJ5IHdpdGggZXhlbXBsYXJzJyA6ICdFbmFibGUgcXVlcnkgd2l0aCBleGVtcGxhcnMnfVxuICAgICAgICAgICAgZGlzYWJsZWQ9eyEhZXJyb3J9XG4gICAgICAgICAgICBjbGFzc05hbWU9e2ljb25CdXR0b25TdHlsZXN9XG4gICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiB7XG4gICAgICAgICAgICAgIG9uQ2hhbmdlKCFxdWVyeS5leGVtcGxhcik7XG4gICAgICAgICAgICB9fVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9Ub29sdGlwPlxuICAgIDwvSW5saW5lTGFiZWw+XG4gICk7XG59XG5cbmZ1bmN0aW9uIGdldFN0eWxlcyh0aGVtZTogR3JhZmFuYVRoZW1lMikge1xuICByZXR1cm4ge1xuICAgIGV5ZUljb246IGNzc2BcbiAgICAgIG1hcmdpbi1sZWZ0OiAke3RoZW1lLnNwYWNpbmcoMil9O1xuICAgIGAsXG4gICAgYWN0aXZlSWNvbjogY3NzYFxuICAgICAgY29sb3I6ICR7dGhlbWUuY29sb3JzLnByaW1hcnkubWFpbn07XG4gICAgYCxcbiAgICBpY29uV3JhcHBlcjogY3NzYFxuICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgYCxcbiAgfTtcbn1cbiIsImltcG9ydCB7IGNzcywgY3ggfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IHsgaXNFcXVhbCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgUmVhY3QsIHsgbWVtbywgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VQcmV2aW91cyB9IGZyb20gJ3JlYWN0LXVzZSc7XG5cbmltcG9ydCB7IElubGluZUZvcm1MYWJlbCwgUmFkaW9CdXR0b25Hcm91cCB9IGZyb20gJ0BncmFmYW5hL3VpJztcblxuaW1wb3J0IHsgUHJvbWV0aGV1c0RhdGFzb3VyY2UgfSBmcm9tICcuLi9kYXRhc291cmNlJztcbmltcG9ydCB7IFByb21RdWVyeSB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgUHJvbUV4ZW1wbGFyRmllbGQgfSBmcm9tICcuL1Byb21FeGVtcGxhckZpZWxkJztcblxuZXhwb3J0IGludGVyZmFjZSBQcm9tRXhwbG9yZUV4dHJhRmllbGRQcm9wcyB7XG4gIHF1ZXJ5OiBQcm9tUXVlcnk7XG4gIG9uQ2hhbmdlOiAodmFsdWU6IFByb21RdWVyeSkgPT4gdm9pZDtcbiAgb25SdW5RdWVyeTogKCkgPT4gdm9pZDtcbiAgZGF0YXNvdXJjZTogUHJvbWV0aGV1c0RhdGFzb3VyY2U7XG59XG5cbmV4cG9ydCBjb25zdCBQcm9tRXhwbG9yZUV4dHJhRmllbGQ6IFJlYWN0LkZDPFByb21FeHBsb3JlRXh0cmFGaWVsZFByb3BzPiA9IG1lbW8oXG4gICh7IHF1ZXJ5LCBkYXRhc291cmNlLCBvbkNoYW5nZSwgb25SdW5RdWVyeSB9KSA9PiB7XG4gICAgY29uc3QgcmFuZ2VPcHRpb25zID0gZ2V0UXVlcnlUeXBlT3B0aW9ucyh0cnVlKTtcbiAgICBjb25zdCBwcmV2UXVlcnkgPSB1c2VQcmV2aW91cyhxdWVyeSk7XG5cbiAgICBjb25zdCBvbkV4ZW1wbGFyQ2hhbmdlID0gdXNlQ2FsbGJhY2soXG4gICAgICAoZXhlbXBsYXI6IGJvb2xlYW4pID0+IHtcbiAgICAgICAgaWYgKCFpc0VxdWFsKHF1ZXJ5LCBwcmV2UXVlcnkpIHx8IGV4ZW1wbGFyICE9PSBxdWVyeS5leGVtcGxhcikge1xuICAgICAgICAgIG9uQ2hhbmdlKHsgLi4ucXVlcnksIGV4ZW1wbGFyIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgW3ByZXZRdWVyeSwgcXVlcnksIG9uQ2hhbmdlXVxuICAgICk7XG5cbiAgICBmdW5jdGlvbiBvbkNoYW5nZVF1ZXJ5U3RlcChpbnRlcnZhbDogc3RyaW5nKSB7XG4gICAgICBvbkNoYW5nZSh7IC4uLnF1ZXJ5LCBpbnRlcnZhbCB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvblN0ZXBDaGFuZ2UoZTogUmVhY3QuU3ludGhldGljRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pIHtcbiAgICAgIGlmIChlLmN1cnJlbnRUYXJnZXQudmFsdWUgIT09IHF1ZXJ5LmludGVydmFsKSB7XG4gICAgICAgIG9uQ2hhbmdlUXVlcnlTdGVwKGUuY3VycmVudFRhcmdldC52YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25SZXR1cm5LZXlEb3duKGU6IFJlYWN0LktleWJvYXJkRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pIHtcbiAgICAgIGlmIChlLmtleSA9PT0gJ0VudGVyJyAmJiBlLnNoaWZ0S2V5KSB7XG4gICAgICAgIG9uUnVuUXVlcnkoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBvblF1ZXJ5VHlwZUNoYW5nZSA9IGdldFF1ZXJ5VHlwZUNoYW5nZUhhbmRsZXIocXVlcnksIG9uQ2hhbmdlKTtcblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGFyaWEtbGFiZWw9XCJQcm9tZXRoZXVzIGV4dHJhIGZpZWxkXCIgY2xhc3NOYW1lPVwiZ2YtZm9ybS1pbmxpbmVcIiBkYXRhLXRlc3RpZD17dGVzdElkcy5leHRyYUZpZWxkRWRpdG9yfT5cbiAgICAgICAgey8qUXVlcnkgdHlwZSBmaWVsZCovfVxuICAgICAgICA8ZGl2XG4gICAgICAgICAgZGF0YS10ZXN0aWQ9e3Rlc3RJZHMucXVlcnlUeXBlRmllbGR9XG4gICAgICAgICAgY2xhc3NOYW1lPXtjeChcbiAgICAgICAgICAgICdnZi1mb3JtIGV4cGxvcmUtaW5wdXQtbWFyZ2luJyxcbiAgICAgICAgICAgIGNzc2BcbiAgICAgICAgICAgICAgZmxleC13cmFwOiBub3dyYXA7XG4gICAgICAgICAgICBgXG4gICAgICAgICAgKX1cbiAgICAgICAgICBhcmlhLWxhYmVsPVwiUXVlcnkgdHlwZSBmaWVsZFwiXG4gICAgICAgID5cbiAgICAgICAgICA8SW5saW5lRm9ybUxhYmVsIHdpZHRoPVwiYXV0b1wiPlF1ZXJ5IHR5cGU8L0lubGluZUZvcm1MYWJlbD5cblxuICAgICAgICAgIDxSYWRpb0J1dHRvbkdyb3VwXG4gICAgICAgICAgICBvcHRpb25zPXtyYW5nZU9wdGlvbnN9XG4gICAgICAgICAgICB2YWx1ZT17cXVlcnkucmFuZ2UgJiYgcXVlcnkuaW5zdGFudCA/ICdib3RoJyA6IHF1ZXJ5Lmluc3RhbnQgPyAnaW5zdGFudCcgOiAncmFuZ2UnfVxuICAgICAgICAgICAgb25DaGFuZ2U9e29uUXVlcnlUeXBlQ2hhbmdlfVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICB7LypTdGVwIGZpZWxkKi99XG4gICAgICAgIDxkaXZcbiAgICAgICAgICBkYXRhLXRlc3RpZD17dGVzdElkcy5zdGVwRmllbGR9XG4gICAgICAgICAgY2xhc3NOYW1lPXtjeChcbiAgICAgICAgICAgICdnZi1mb3JtJyxcbiAgICAgICAgICAgIGNzc2BcbiAgICAgICAgICAgICAgZmxleC13cmFwOiBub3dyYXA7XG4gICAgICAgICAgICBgXG4gICAgICAgICAgKX1cbiAgICAgICAgICBhcmlhLWxhYmVsPVwiU3RlcCBmaWVsZFwiXG4gICAgICAgID5cbiAgICAgICAgICA8SW5saW5lRm9ybUxhYmVsXG4gICAgICAgICAgICB3aWR0aD17Nn1cbiAgICAgICAgICAgIHRvb2x0aXA9e1xuICAgICAgICAgICAgICAnVGltZSB1bml0cyBhbmQgYnVpbHQtaW4gdmFyaWFibGVzIGNhbiBiZSB1c2VkIGhlcmUsIGZvciBleGFtcGxlOiAkX19pbnRlcnZhbCwgJF9fcmF0ZV9pbnRlcnZhbCwgNXMsIDFtLCAzaCwgMWQsIDF5IChEZWZhdWx0IGlmIG5vIHVuaXQgaXMgc3BlY2lmaWVkOiBzKSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA+XG4gICAgICAgICAgICBNaW4gc3RlcFxuICAgICAgICAgIDwvSW5saW5lRm9ybUxhYmVsPlxuICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgdHlwZT17J3RleHQnfVxuICAgICAgICAgICAgY2xhc3NOYW1lPVwiZ2YtZm9ybS1pbnB1dCB3aWR0aC00XCJcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyPXsnYXV0byd9XG4gICAgICAgICAgICBvbkNoYW5nZT17b25TdGVwQ2hhbmdlfVxuICAgICAgICAgICAgb25LZXlEb3duPXtvblJldHVybktleURvd259XG4gICAgICAgICAgICB2YWx1ZT17cXVlcnkuaW50ZXJ2YWwgPz8gJyd9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPFByb21FeGVtcGxhckZpZWxkIG9uQ2hhbmdlPXtvbkV4ZW1wbGFyQ2hhbmdlfSBkYXRhc291cmNlPXtkYXRhc291cmNlfSBxdWVyeT17cXVlcnl9IC8+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG4pO1xuXG5Qcm9tRXhwbG9yZUV4dHJhRmllbGQuZGlzcGxheU5hbWUgPSAnUHJvbUV4cGxvcmVFeHRyYUZpZWxkJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFF1ZXJ5VHlwZU9wdGlvbnMoaW5jbHVkZUJvdGg6IGJvb2xlYW4pIHtcbiAgY29uc3QgcmFuZ2VPcHRpb25zID0gW1xuICAgIHsgdmFsdWU6ICdyYW5nZScsIGxhYmVsOiAnUmFuZ2UnLCBkZXNjcmlwdGlvbjogJ1J1biBxdWVyeSBvdmVyIGEgcmFuZ2Ugb2YgdGltZScgfSxcbiAgICB7XG4gICAgICB2YWx1ZTogJ2luc3RhbnQnLFxuICAgICAgbGFiZWw6ICdJbnN0YW50JyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnUnVuIHF1ZXJ5IGFnYWluc3QgYSBzaW5nbGUgcG9pbnQgaW4gdGltZS4gRm9yIHRoaXMgcXVlcnksIHRoZSBcIlRvXCIgdGltZSBpcyB1c2VkJyxcbiAgICB9LFxuICBdO1xuXG4gIGlmIChpbmNsdWRlQm90aCkge1xuICAgIHJhbmdlT3B0aW9ucy5wdXNoKHsgdmFsdWU6ICdib3RoJywgbGFiZWw6ICdCb3RoJywgZGVzY3JpcHRpb246ICdSdW4gYW4gSW5zdGFudCBxdWVyeSBhbmQgYSBSYW5nZSBxdWVyeScgfSk7XG4gIH1cblxuICByZXR1cm4gcmFuZ2VPcHRpb25zO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UXVlcnlUeXBlQ2hhbmdlSGFuZGxlcihxdWVyeTogUHJvbVF1ZXJ5LCBvbkNoYW5nZTogKHVwZGF0ZTogUHJvbVF1ZXJ5KSA9PiB2b2lkKSB7XG4gIHJldHVybiAocXVlcnlUeXBlOiBzdHJpbmcpID0+IHtcbiAgICBpZiAocXVlcnlUeXBlID09PSAnaW5zdGFudCcpIHtcbiAgICAgIG9uQ2hhbmdlKHsgLi4ucXVlcnksIGluc3RhbnQ6IHRydWUsIHJhbmdlOiBmYWxzZSwgZXhlbXBsYXI6IGZhbHNlIH0pO1xuICAgIH0gZWxzZSBpZiAocXVlcnlUeXBlID09PSAncmFuZ2UnKSB7XG4gICAgICBvbkNoYW5nZSh7IC4uLnF1ZXJ5LCBpbnN0YW50OiBmYWxzZSwgcmFuZ2U6IHRydWUgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9uQ2hhbmdlKHsgLi4ucXVlcnksIGluc3RhbnQ6IHRydWUsIHJhbmdlOiB0cnVlIH0pO1xuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IHRlc3RJZHMgPSB7XG4gIGV4dHJhRmllbGRFZGl0b3I6ICdwcm9tLWVkaXRvci1leHRyYS1maWVsZCcsXG4gIHN0ZXBGaWVsZDogJ3Byb20tZWRpdG9yLWV4dHJhLWZpZWxkLXN0ZXAnLFxuICBxdWVyeVR5cGVGaWVsZDogJ3Byb20tZWRpdG9yLWV4dHJhLWZpZWxkLXF1ZXJ5LXR5cGUnLFxufTtcbiIsImltcG9ydCBSZWFjdCwgeyBtZW1vLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IFF1ZXJ5RWRpdG9yUHJvcHMsIENvcmVBcHAgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcblxuaW1wb3J0IHsgUHJvbWV0aGV1c0RhdGFzb3VyY2UgfSBmcm9tICcuLi9kYXRhc291cmNlJztcbmltcG9ydCB7IFByb21RdWVyeSwgUHJvbU9wdGlvbnMgfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IFByb21FeHBsb3JlRXh0cmFGaWVsZCB9IGZyb20gJy4vUHJvbUV4cGxvcmVFeHRyYUZpZWxkJztcbmltcG9ydCBQcm9tUXVlcnlGaWVsZCBmcm9tICcuL1Byb21RdWVyeUZpZWxkJztcblxuZXhwb3J0IHR5cGUgUHJvcHMgPSBRdWVyeUVkaXRvclByb3BzPFByb21ldGhldXNEYXRhc291cmNlLCBQcm9tUXVlcnksIFByb21PcHRpb25zPjtcblxuZXhwb3J0IGNvbnN0IFByb21FeHBsb3JlUXVlcnlFZGl0b3IgPSBtZW1vKChwcm9wczogUHJvcHMpID0+IHtcbiAgY29uc3QgeyByYW5nZSwgcXVlcnksIGRhdGEsIGRhdGFzb3VyY2UsIGhpc3RvcnksIG9uQ2hhbmdlLCBvblJ1blF1ZXJ5IH0gPSBwcm9wcztcblxuICAvLyBTZXR0aW5nIGRlZmF1bHQgdmFsdWVzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHF1ZXJ5LmV4cHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb25DaGFuZ2UoeyAuLi5xdWVyeSwgZXhwcjogJycgfSk7XG4gICAgfVxuICAgIGlmIChxdWVyeS5leGVtcGxhciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvbkNoYW5nZSh7IC4uLnF1ZXJ5LCBleGVtcGxhcjogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICAvLyBPdmVycmlkZSBxdWVyeSB0eXBlIHRvIFwiQm90aFwiIG9ubHkgZm9yIG5ldyBxdWVyaWVzIChubyBxdWVyeS5leHByKS5cbiAgICBpZiAoIXF1ZXJ5Lmluc3RhbnQgJiYgIXF1ZXJ5LnJhbmdlICYmICFxdWVyeS5leHByKSB7XG4gICAgICBvbkNoYW5nZSh7IC4uLnF1ZXJ5LCBpbnN0YW50OiB0cnVlLCByYW5nZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH0sIFtvbkNoYW5nZSwgcXVlcnldKTtcblxuICByZXR1cm4gKFxuICAgIDxQcm9tUXVlcnlGaWVsZFxuICAgICAgYXBwPXtDb3JlQXBwLkV4cGxvcmV9XG4gICAgICBkYXRhc291cmNlPXtkYXRhc291cmNlfVxuICAgICAgcXVlcnk9e3F1ZXJ5fVxuICAgICAgcmFuZ2U9e3JhbmdlfVxuICAgICAgb25SdW5RdWVyeT17b25SdW5RdWVyeX1cbiAgICAgIG9uQ2hhbmdlPXtvbkNoYW5nZX1cbiAgICAgIG9uQmx1cj17KCkgPT4ge319XG4gICAgICBoaXN0b3J5PXtoaXN0b3J5fVxuICAgICAgZGF0YT17ZGF0YX1cbiAgICAgIGRhdGEtdGVzdGlkPXt0ZXN0SWRzLmVkaXRvcn1cbiAgICAgIEV4dHJhRmllbGRFbGVtZW50PXtcbiAgICAgICAgPFByb21FeHBsb3JlRXh0cmFGaWVsZCBxdWVyeT17cXVlcnl9IG9uQ2hhbmdlPXtvbkNoYW5nZX0gZGF0YXNvdXJjZT17ZGF0YXNvdXJjZX0gb25SdW5RdWVyeT17b25SdW5RdWVyeX0gLz5cbiAgICAgIH1cbiAgICAvPlxuICApO1xufSk7XG5cblByb21FeHBsb3JlUXVlcnlFZGl0b3IuZGlzcGxheU5hbWUgPSAnUHJvbUV4cGxvcmVRdWVyeUVkaXRvcic7XG5cbmV4cG9ydCBjb25zdCB0ZXN0SWRzID0ge1xuICBlZGl0b3I6ICdwcm9tLWVkaXRvci1leHBsb3JlJyxcbn07XG4iLCJpbXBvcnQgeyBtYXAgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IFJlYWN0LCB7IEZDLCB1c2VFZmZlY3QsIHVzZVN0YXRlLCBtZW1vIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBEYXRhUXVlcnlSZXF1ZXN0LCBQYW5lbERhdGEsIFNjb3BlZFZhcnMsIHRleHRVdGlsLCByYW5nZVV0aWwgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcblxuaW1wb3J0IHsgUHJvbWV0aGV1c0RhdGFzb3VyY2UgfSBmcm9tICcuLi9kYXRhc291cmNlJztcbmltcG9ydCB7IFByb21RdWVyeSB9IGZyb20gJy4uL3R5cGVzJztcblxuaW50ZXJmYWNlIFByb3BzIHtcbiAgZGF0YXNvdXJjZTogUHJvbWV0aGV1c0RhdGFzb3VyY2U7XG4gIHF1ZXJ5OiBQcm9tUXVlcnk7XG4gIHBhbmVsRGF0YT86IFBhbmVsRGF0YTtcbn1cblxuY29uc3QgUHJvbUxpbms6IEZDPFByb3BzPiA9ICh7IHBhbmVsRGF0YSwgcXVlcnksIGRhdGFzb3VyY2UgfSkgPT4ge1xuICBjb25zdCBbaHJlZiwgc2V0SHJlZl0gPSB1c2VTdGF0ZSgnJyk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAocGFuZWxEYXRhKSB7XG4gICAgICBjb25zdCBnZXRFeHRlcm5hbExpbmsgPSAoKSA9PiB7XG4gICAgICAgIGlmICghcGFuZWxEYXRhLnJlcXVlc3QpIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcmVxdWVzdDogeyByYW5nZSwgaW50ZXJ2YWwsIHNjb3BlZFZhcnMgfSxcbiAgICAgICAgfSA9IHBhbmVsRGF0YTtcblxuICAgICAgICBjb25zdCBzdGFydCA9IGRhdGFzb3VyY2UuZ2V0UHJvbWV0aGV1c1RpbWUocmFuZ2UuZnJvbSwgZmFsc2UpO1xuICAgICAgICBjb25zdCBlbmQgPSBkYXRhc291cmNlLmdldFByb21ldGhldXNUaW1lKHJhbmdlLnRvLCB0cnVlKTtcbiAgICAgICAgY29uc3QgcmFuZ2VEaWZmID0gTWF0aC5jZWlsKGVuZCAtIHN0YXJ0KTtcbiAgICAgICAgY29uc3QgZW5kVGltZSA9IHJhbmdlLnRvLnV0YygpLmZvcm1hdCgnWVlZWS1NTS1ERCBISDptbScpO1xuXG4gICAgICAgIGNvbnN0IGVucmljaGVkU2NvcGVkVmFyczogU2NvcGVkVmFycyA9IHtcbiAgICAgICAgICAuLi5zY29wZWRWYXJzLFxuICAgICAgICAgIC8vIEFzIHdlIHN1cHBvcnQgJF9fcmF0ZV9pbnRlcnZhbCB2YXJpYWJsZSBpbiBtaW4gc3RlcCwgd2UgbmVlZCBhZGQgaXQgdG8gc2NvcGVkVmFyc1xuICAgICAgICAgIC4uLmRhdGFzb3VyY2UuZ2V0UmF0ZUludGVydmFsU2NvcGVkVmFyaWFibGUoXG4gICAgICAgICAgICByYW5nZVV0aWwuaW50ZXJ2YWxUb1NlY29uZHMoaW50ZXJ2YWwpLFxuICAgICAgICAgICAgcmFuZ2VVdGlsLmludGVydmFsVG9TZWNvbmRzKGRhdGFzb3VyY2UuaW50ZXJ2YWwpXG4gICAgICAgICAgKSxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgIGludGVydmFsLFxuICAgICAgICAgIHNjb3BlZFZhcnM6IGVucmljaGVkU2NvcGVkVmFycyxcbiAgICAgICAgfSBhcyBEYXRhUXVlcnlSZXF1ZXN0PFByb21RdWVyeT47XG5cbiAgICAgICAgY29uc3QgY3VzdG9tUXVlcnlQYXJhbWV0ZXJzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge307XG4gICAgICAgIGlmIChkYXRhc291cmNlLmN1c3RvbVF1ZXJ5UGFyYW1ldGVycykge1xuICAgICAgICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIGRhdGFzb3VyY2UuY3VzdG9tUXVlcnlQYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICBjdXN0b21RdWVyeVBhcmFtZXRlcnNba10gPSB2O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHF1ZXJ5T3B0aW9ucyA9IGRhdGFzb3VyY2UuY3JlYXRlUXVlcnkocXVlcnksIG9wdGlvbnMsIHN0YXJ0LCBlbmQpO1xuXG4gICAgICAgIGNvbnN0IGV4cHIgPSB7XG4gICAgICAgICAgLi4uY3VzdG9tUXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICdnMC5leHByJzogcXVlcnlPcHRpb25zLmV4cHIsXG4gICAgICAgICAgJ2cwLnJhbmdlX2lucHV0JzogcmFuZ2VEaWZmICsgJ3MnLFxuICAgICAgICAgICdnMC5lbmRfaW5wdXQnOiBlbmRUaW1lLFxuICAgICAgICAgICdnMC5zdGVwX2lucHV0JzogcXVlcnlPcHRpb25zLnN0ZXAsXG4gICAgICAgICAgJ2cwLnRhYic6IDAsXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgYXJncyA9IG1hcChleHByLCAodjogc3RyaW5nLCBrOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICByZXR1cm4gayArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2KTtcbiAgICAgICAgfSkuam9pbignJicpO1xuICAgICAgICByZXR1cm4gYCR7ZGF0YXNvdXJjZS5kaXJlY3RVcmx9L2dyYXBoPyR7YXJnc31gO1xuICAgICAgfTtcblxuICAgICAgc2V0SHJlZihnZXRFeHRlcm5hbExpbmsoKSk7XG4gICAgfVxuICB9LCBbZGF0YXNvdXJjZSwgcGFuZWxEYXRhLCBxdWVyeV0pO1xuXG4gIHJldHVybiAoXG4gICAgPGEgaHJlZj17dGV4dFV0aWwuc2FuaXRpemVVcmwoaHJlZil9IHRhcmdldD1cIl9ibGFua1wiIHJlbD1cIm5vb3BlbmVyIG5vcmVmZXJyZXJcIj5cbiAgICAgIFByb21ldGhldXNcbiAgICA8L2E+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBtZW1vKFByb21MaW5rKTtcbiIsImltcG9ydCB7IG1hcCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgUmVhY3QsIHsgUHVyZUNvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcblxuLy8gVHlwZXNcbmltcG9ydCB7IENvcmVBcHAsIFNlbGVjdGFibGVWYWx1ZSB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgSW5saW5lRm9ybUxhYmVsLCBMZWdhY3lGb3JtcywgU2VsZWN0IH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5pbXBvcnQgeyBQcm9tUXVlcnkgfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IFByb21FeGVtcGxhckZpZWxkIH0gZnJvbSAnLi9Qcm9tRXhlbXBsYXJGaWVsZCc7XG5pbXBvcnQgUHJvbUxpbmsgZnJvbSAnLi9Qcm9tTGluayc7XG5pbXBvcnQgUHJvbVF1ZXJ5RmllbGQgZnJvbSAnLi9Qcm9tUXVlcnlGaWVsZCc7XG5pbXBvcnQgeyBQcm9tUXVlcnlFZGl0b3JQcm9wcyB9IGZyb20gJy4vdHlwZXMnO1xuXG5jb25zdCB7IFN3aXRjaCB9ID0gTGVnYWN5Rm9ybXM7XG5cbmV4cG9ydCBjb25zdCBGT1JNQVRfT1BUSU9OUzogQXJyYXk8U2VsZWN0YWJsZVZhbHVlPHN0cmluZz4+ID0gW1xuICB7IGxhYmVsOiAnVGltZSBzZXJpZXMnLCB2YWx1ZTogJ3RpbWVfc2VyaWVzJyB9LFxuICB7IGxhYmVsOiAnVGFibGUnLCB2YWx1ZTogJ3RhYmxlJyB9LFxuICB7IGxhYmVsOiAnSGVhdG1hcCcsIHZhbHVlOiAnaGVhdG1hcCcgfSxcbl07XG5cbmV4cG9ydCBjb25zdCBJTlRFUlZBTF9GQUNUT1JfT1BUSU9OUzogQXJyYXk8U2VsZWN0YWJsZVZhbHVlPG51bWJlcj4+ID0gbWFwKFsxLCAyLCAzLCA0LCA1LCAxMF0sICh2YWx1ZTogbnVtYmVyKSA9PiAoe1xuICB2YWx1ZSxcbiAgbGFiZWw6ICcxLycgKyB2YWx1ZSxcbn0pKTtcblxuaW50ZXJmYWNlIFN0YXRlIHtcbiAgbGVnZW5kRm9ybWF0Pzogc3RyaW5nO1xuICBmb3JtYXRPcHRpb246IFNlbGVjdGFibGVWYWx1ZTxzdHJpbmc+O1xuICBpbnRlcnZhbD86IHN0cmluZztcbiAgaW50ZXJ2YWxGYWN0b3JPcHRpb246IFNlbGVjdGFibGVWYWx1ZTxudW1iZXI+O1xuICBpbnN0YW50OiBib29sZWFuO1xuICBleGVtcGxhcjogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNsYXNzIFByb21RdWVyeUVkaXRvciBleHRlbmRzIFB1cmVDb21wb25lbnQ8UHJvbVF1ZXJ5RWRpdG9yUHJvcHMsIFN0YXRlPiB7XG4gIC8vIFF1ZXJ5IHRhcmdldCB0byBiZSBtb2RpZmllZCBhbmQgdXNlZCBmb3IgcXVlcmllc1xuICBxdWVyeTogUHJvbVF1ZXJ5O1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBQcm9tUXVlcnlFZGl0b3JQcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICAvLyBVc2UgZGVmYXVsdCBxdWVyeSB0byBwcmV2ZW50IHVuZGVmaW5lZCBpbnB1dCB2YWx1ZXNcbiAgICBjb25zdCBkZWZhdWx0UXVlcnk6IFBhcnRpYWw8UHJvbVF1ZXJ5PiA9IHtcbiAgICAgIGV4cHI6ICcnLFxuICAgICAgbGVnZW5kRm9ybWF0OiAnJyxcbiAgICAgIGludGVydmFsOiAnJyxcbiAgICAgIC8vIFNldCBleGVtcGxhciB0byBmYWxzZSBmb3IgYWxlcnRpbmcgcXVlcmllc1xuICAgICAgZXhlbXBsYXI6IHByb3BzLmFwcCA9PT0gQ29yZUFwcC5VbmlmaWVkQWxlcnRpbmcgPyBmYWxzZSA6IHRydWUsXG4gICAgfTtcbiAgICBjb25zdCBxdWVyeSA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRRdWVyeSwgcHJvcHMucXVlcnkpO1xuICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgICAvLyBRdWVyeSB0YXJnZXQgcHJvcGVydGllcyB0aGF0IGFyZSBmdWxseSBjb250cm9sbGVkIGlucHV0c1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAvLyBGdWxseSBjb250cm9sbGVkIHRleHQgaW5wdXRzXG4gICAgICBpbnRlcnZhbDogcXVlcnkuaW50ZXJ2YWwsXG4gICAgICBsZWdlbmRGb3JtYXQ6IHF1ZXJ5LmxlZ2VuZEZvcm1hdCxcbiAgICAgIC8vIFNlbGVjdCBvcHRpb25zXG4gICAgICBmb3JtYXRPcHRpb246IEZPUk1BVF9PUFRJT05TLmZpbmQoKG9wdGlvbikgPT4gb3B0aW9uLnZhbHVlID09PSBxdWVyeS5mb3JtYXQpIHx8IEZPUk1BVF9PUFRJT05TWzBdLFxuICAgICAgaW50ZXJ2YWxGYWN0b3JPcHRpb246XG4gICAgICAgIElOVEVSVkFMX0ZBQ1RPUl9PUFRJT05TLmZpbmQoKG9wdGlvbikgPT4gb3B0aW9uLnZhbHVlID09PSBxdWVyeS5pbnRlcnZhbEZhY3RvcikgfHwgSU5URVJWQUxfRkFDVE9SX09QVElPTlNbMF0sXG4gICAgICAvLyBTd2l0Y2ggb3B0aW9uc1xuICAgICAgaW5zdGFudDogQm9vbGVhbihxdWVyeS5pbnN0YW50KSxcbiAgICAgIGV4ZW1wbGFyOiBCb29sZWFuKHF1ZXJ5LmV4ZW1wbGFyKSxcbiAgICB9O1xuICB9XG5cbiAgb25GaWVsZENoYW5nZSA9IChxdWVyeTogUHJvbVF1ZXJ5LCBvdmVycmlkZT86IGFueSkgPT4ge1xuICAgIHRoaXMucXVlcnkuZXhwciA9IHF1ZXJ5LmV4cHI7XG4gIH07XG5cbiAgb25Gb3JtYXRDaGFuZ2UgPSAob3B0aW9uOiBTZWxlY3RhYmxlVmFsdWU8c3RyaW5nPikgPT4ge1xuICAgIHRoaXMucXVlcnkuZm9ybWF0ID0gb3B0aW9uLnZhbHVlO1xuICAgIHRoaXMuc2V0U3RhdGUoeyBmb3JtYXRPcHRpb246IG9wdGlvbiB9LCB0aGlzLm9uUnVuUXVlcnkpO1xuICB9O1xuXG4gIG9uSW5zdGFudENoYW5nZSA9IChlOiBSZWFjdC5TeW50aGV0aWNFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IGluc3RhbnQgPSAoZS50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudCkuY2hlY2tlZDtcbiAgICB0aGlzLnF1ZXJ5Lmluc3RhbnQgPSBpbnN0YW50O1xuICAgIHRoaXMuc2V0U3RhdGUoeyBpbnN0YW50IH0sIHRoaXMub25SdW5RdWVyeSk7XG4gIH07XG5cbiAgb25JbnRlcnZhbENoYW5nZSA9IChlOiBSZWFjdC5TeW50aGV0aWNFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IGludGVydmFsID0gZS5jdXJyZW50VGFyZ2V0LnZhbHVlO1xuICAgIHRoaXMucXVlcnkuaW50ZXJ2YWwgPSBpbnRlcnZhbDtcbiAgICB0aGlzLnNldFN0YXRlKHsgaW50ZXJ2YWwgfSk7XG4gIH07XG5cbiAgb25JbnRlcnZhbEZhY3RvckNoYW5nZSA9IChvcHRpb246IFNlbGVjdGFibGVWYWx1ZTxudW1iZXI+KSA9PiB7XG4gICAgdGhpcy5xdWVyeS5pbnRlcnZhbEZhY3RvciA9IG9wdGlvbi52YWx1ZTtcbiAgICB0aGlzLnNldFN0YXRlKHsgaW50ZXJ2YWxGYWN0b3JPcHRpb246IG9wdGlvbiB9LCB0aGlzLm9uUnVuUXVlcnkpO1xuICB9O1xuXG4gIG9uTGVnZW5kQ2hhbmdlID0gKGU6IFJlYWN0LlN5bnRoZXRpY0V2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3QgbGVnZW5kRm9ybWF0ID0gZS5jdXJyZW50VGFyZ2V0LnZhbHVlO1xuICAgIHRoaXMucXVlcnkubGVnZW5kRm9ybWF0ID0gbGVnZW5kRm9ybWF0O1xuICAgIHRoaXMuc2V0U3RhdGUoeyBsZWdlbmRGb3JtYXQgfSk7XG4gIH07XG5cbiAgb25FeGVtcGxhckNoYW5nZSA9IChpc0VuYWJsZWQ6IGJvb2xlYW4pID0+IHtcbiAgICB0aGlzLnF1ZXJ5LmV4ZW1wbGFyID0gaXNFbmFibGVkO1xuICAgIHRoaXMuc2V0U3RhdGUoeyBleGVtcGxhcjogaXNFbmFibGVkIH0sIHRoaXMub25SdW5RdWVyeSk7XG4gIH07XG5cbiAgb25SdW5RdWVyeSA9ICgpID0+IHtcbiAgICBjb25zdCB7IHF1ZXJ5IH0gPSB0aGlzO1xuICAgIC8vIENoYW5nZSBvZiBxdWVyeS5oaWRlIGhhcHBlbnMgb3V0c2lkZSBvZiB0aGlzIGNvbXBvbmVudCBhbmQgaXMganVzdCBwYXNzZWQgYXMgcHJvcC4gV2UgaGF2ZSB0byB1cGRhdGUgaXQgd2hlbiBydW5uaW5nIHF1ZXJpZXMuXG4gICAgY29uc3QgeyBoaWRlIH0gPSB0aGlzLnByb3BzLnF1ZXJ5O1xuICAgIHRoaXMucHJvcHMub25DaGFuZ2UoeyAuLi5xdWVyeSwgaGlkZSB9KTtcbiAgICB0aGlzLnByb3BzLm9uUnVuUXVlcnkoKTtcbiAgfTtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBkYXRhc291cmNlLCBxdWVyeSwgcmFuZ2UsIGRhdGEgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyBmb3JtYXRPcHRpb24sIGluc3RhbnQsIGludGVydmFsLCBpbnRlcnZhbEZhY3Rvck9wdGlvbiwgbGVnZW5kRm9ybWF0IH0gPSB0aGlzLnN0YXRlO1xuICAgIC8vV2Ugd2FudCB0byBoaWRlIGV4ZW1wbGFyIGZpZWxkIGZvciB1bmlmaWVkIGFsZXJ0aW5nIGFzIGV4ZW1wbGFycyBpbiBhbGVydGluZyBkb24ndCBtYWtlIHNlbnNlIGFuZCBhcmUgc291cmNlIG9mIGNvbmZ1c2lvblxuICAgIGNvbnN0IHNob3dFeGVtcGxhckZpZWxkID0gdGhpcy5wcm9wcy5hcHAgIT09IENvcmVBcHAuVW5pZmllZEFsZXJ0aW5nO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxQcm9tUXVlcnlGaWVsZFxuICAgICAgICBkYXRhc291cmNlPXtkYXRhc291cmNlfVxuICAgICAgICBxdWVyeT17cXVlcnl9XG4gICAgICAgIHJhbmdlPXtyYW5nZX1cbiAgICAgICAgb25SdW5RdWVyeT17dGhpcy5vblJ1blF1ZXJ5fVxuICAgICAgICBvbkNoYW5nZT17dGhpcy5vbkZpZWxkQ2hhbmdlfVxuICAgICAgICBoaXN0b3J5PXtbXX1cbiAgICAgICAgZGF0YT17ZGF0YX1cbiAgICAgICAgZGF0YS10ZXN0aWQ9e3Rlc3RJZHMuZWRpdG9yfVxuICAgICAgICBFeHRyYUZpZWxkRWxlbWVudD17XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtLWlubGluZVwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtXCI+XG4gICAgICAgICAgICAgIDxJbmxpbmVGb3JtTGFiZWxcbiAgICAgICAgICAgICAgICB3aWR0aD17N31cbiAgICAgICAgICAgICAgICB0b29sdGlwPVwiQ29udHJvbHMgdGhlIG5hbWUgb2YgdGhlIHRpbWUgc2VyaWVzLCB1c2luZyBuYW1lIG9yIHBhdHRlcm4uIEZvciBleGFtcGxlXG4gICAgICAgIHt7aG9zdG5hbWV9fSB3aWxsIGJlIHJlcGxhY2VkIHdpdGggbGFiZWwgdmFsdWUgZm9yIHRoZSBsYWJlbCBob3N0bmFtZS5cIlxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgTGVnZW5kXG4gICAgICAgICAgICAgIDwvSW5saW5lRm9ybUxhYmVsPlxuICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZ2YtZm9ybS1pbnB1dFwiXG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJsZWdlbmQgZm9ybWF0XCJcbiAgICAgICAgICAgICAgICB2YWx1ZT17bGVnZW5kRm9ybWF0fVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLm9uTGVnZW5kQ2hhbmdlfVxuICAgICAgICAgICAgICAgIG9uQmx1cj17dGhpcy5vblJ1blF1ZXJ5fVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybVwiPlxuICAgICAgICAgICAgICA8SW5saW5lRm9ybUxhYmVsXG4gICAgICAgICAgICAgICAgd2lkdGg9ezd9XG4gICAgICAgICAgICAgICAgdG9vbHRpcD17XG4gICAgICAgICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgICAgICBBbiBhZGRpdGlvbmFsIGxvd2VyIGxpbWl0IGZvciB0aGUgc3RlcCBwYXJhbWV0ZXIgb2YgdGhlIFByb21ldGhldXMgcXVlcnkgYW5kIGZvciB0aGV7JyAnfVxuICAgICAgICAgICAgICAgICAgICA8Y29kZT4kX19pbnRlcnZhbDwvY29kZT4gYW5kIDxjb2RlPiRfX3JhdGVfaW50ZXJ2YWw8L2NvZGU+IHZhcmlhYmxlcy4gVGhlIGxpbWl0IGlzIGFic29sdXRlIGFuZCBub3RcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWQgYnkgdGhlICZxdW90O1Jlc29sdXRpb24mcXVvdDsgc2V0dGluZy5cbiAgICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIE1pbiBzdGVwXG4gICAgICAgICAgICAgIDwvSW5saW5lRm9ybUxhYmVsPlxuICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZ2YtZm9ybS1pbnB1dCB3aWR0aC04XCJcbiAgICAgICAgICAgICAgICBhcmlhLWxhYmVsPVwiU2V0IGxvd2VyIGxpbWl0IGZvciB0aGUgc3RlcCBwYXJhbWV0ZXJcIlxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPXtpbnRlcnZhbH1cbiAgICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5vbkludGVydmFsQ2hhbmdlfVxuICAgICAgICAgICAgICAgIG9uQmx1cj17dGhpcy5vblJ1blF1ZXJ5fVxuICAgICAgICAgICAgICAgIHZhbHVlPXtpbnRlcnZhbH1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm1cIj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtLWxhYmVsXCI+UmVzb2x1dGlvbjwvZGl2PlxuICAgICAgICAgICAgICA8U2VsZWN0XG4gICAgICAgICAgICAgICAgYXJpYS1sYWJlbD1cIlNlbGVjdCByZXNvbHV0aW9uXCJcbiAgICAgICAgICAgICAgICBpc1NlYXJjaGFibGU9e2ZhbHNlfVxuICAgICAgICAgICAgICAgIG9wdGlvbnM9e0lOVEVSVkFMX0ZBQ1RPUl9PUFRJT05TfVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLm9uSW50ZXJ2YWxGYWN0b3JDaGFuZ2V9XG4gICAgICAgICAgICAgICAgdmFsdWU9e2ludGVydmFsRmFjdG9yT3B0aW9ufVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybVwiPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm0tbGFiZWwgd2lkdGgtN1wiPkZvcm1hdDwvZGl2PlxuICAgICAgICAgICAgICA8U2VsZWN0XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwic2VsZWN0LWNvbnRhaW5lclwiXG4gICAgICAgICAgICAgICAgd2lkdGg9ezE2fVxuICAgICAgICAgICAgICAgIGlzU2VhcmNoYWJsZT17ZmFsc2V9XG4gICAgICAgICAgICAgICAgb3B0aW9ucz17Rk9STUFUX09QVElPTlN9XG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMub25Gb3JtYXRDaGFuZ2V9XG4gICAgICAgICAgICAgICAgdmFsdWU9e2Zvcm1hdE9wdGlvbn1cbiAgICAgICAgICAgICAgICBhcmlhLWxhYmVsPVwiU2VsZWN0IGZvcm1hdFwiXG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIDxTd2l0Y2ggbGFiZWw9XCJJbnN0YW50XCIgY2hlY2tlZD17aW5zdGFudH0gb25DaGFuZ2U9e3RoaXMub25JbnN0YW50Q2hhbmdlfSAvPlxuXG4gICAgICAgICAgICAgIDxJbmxpbmVGb3JtTGFiZWwgd2lkdGg9ezEwfSB0b29sdGlwPVwiTGluayB0byBHcmFwaCBpbiBQcm9tZXRoZXVzXCI+XG4gICAgICAgICAgICAgICAgPFByb21MaW5rXG4gICAgICAgICAgICAgICAgICBkYXRhc291cmNlPXtkYXRhc291cmNlfVxuICAgICAgICAgICAgICAgICAgcXVlcnk9e3RoaXMucXVlcnl9IC8vIFVzZSBtb2RpZmllZCBxdWVyeVxuICAgICAgICAgICAgICAgICAgcGFuZWxEYXRhPXtkYXRhfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIDwvSW5saW5lRm9ybUxhYmVsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICB7c2hvd0V4ZW1wbGFyRmllbGQgJiYgKFxuICAgICAgICAgICAgICA8UHJvbUV4ZW1wbGFyRmllbGRcbiAgICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5vbkV4ZW1wbGFyQ2hhbmdlfVxuICAgICAgICAgICAgICAgIGRhdGFzb3VyY2U9e2RhdGFzb3VyY2V9XG4gICAgICAgICAgICAgICAgcXVlcnk9e3RoaXMucXVlcnl9XG4gICAgICAgICAgICAgICAgZGF0YS10ZXN0aWQ9e3Rlc3RJZHMuZXhlbXBsYXJ9XG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICApfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICB9XG4gICAgICAvPlxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHRlc3RJZHMgPSB7XG4gIGVkaXRvcjogJ3Byb20tZWRpdG9yJyxcbiAgZXhlbXBsYXI6ICdleGVtcGxhci1lZGl0b3InLFxufTtcbiIsImltcG9ydCBSZWFjdCwgeyBtZW1vIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBDb3JlQXBwIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBjb25maWcgfSBmcm9tICdAZ3JhZmFuYS9ydW50aW1lJztcblxuaW1wb3J0IHsgUHJvbVF1ZXJ5RWRpdG9yU2VsZWN0b3IgfSBmcm9tICcuLi9xdWVyeWJ1aWxkZXIvY29tcG9uZW50cy9Qcm9tUXVlcnlFZGl0b3JTZWxlY3Rvcic7XG5cbmltcG9ydCB7IFByb21FeHBsb3JlUXVlcnlFZGl0b3IgfSBmcm9tICcuL1Byb21FeHBsb3JlUXVlcnlFZGl0b3InO1xuaW1wb3J0IHsgUHJvbVF1ZXJ5RWRpdG9yIH0gZnJvbSAnLi9Qcm9tUXVlcnlFZGl0b3InO1xuaW1wb3J0IHsgUHJvbVF1ZXJ5RWRpdG9yRm9yQWxlcnRpbmcgfSBmcm9tICcuL1Byb21RdWVyeUVkaXRvckZvckFsZXJ0aW5nJztcbmltcG9ydCB7IFByb21RdWVyeUVkaXRvclByb3BzIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBQcm9tUXVlcnlFZGl0b3JCeUFwcChwcm9wczogUHJvbVF1ZXJ5RWRpdG9yUHJvcHMpIHtcbiAgY29uc3QgeyBhcHAgfSA9IHByb3BzO1xuXG4gIHN3aXRjaCAoYXBwKSB7XG4gICAgY2FzZSBDb3JlQXBwLkNsb3VkQWxlcnRpbmc6XG4gICAgICByZXR1cm4gPFByb21RdWVyeUVkaXRvckZvckFsZXJ0aW5nIHsuLi5wcm9wc30gLz47XG4gICAgY2FzZSBDb3JlQXBwLkV4cGxvcmU6XG4gICAgICBpZiAoY29uZmlnLmZlYXR1cmVUb2dnbGVzLnByb21RdWVyeUJ1aWxkZXIpIHtcbiAgICAgICAgcmV0dXJuIDxQcm9tUXVlcnlFZGl0b3JTZWxlY3RvciB7Li4ucHJvcHN9IC8+O1xuICAgICAgfVxuICAgICAgcmV0dXJuIDxQcm9tRXhwbG9yZVF1ZXJ5RWRpdG9yIHsuLi5wcm9wc30gLz47XG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChjb25maWcuZmVhdHVyZVRvZ2dsZXMucHJvbVF1ZXJ5QnVpbGRlcikge1xuICAgICAgICByZXR1cm4gPFByb21RdWVyeUVkaXRvclNlbGVjdG9yIHsuLi5wcm9wc30gLz47XG4gICAgICB9XG4gICAgICByZXR1cm4gPFByb21RdWVyeUVkaXRvciB7Li4ucHJvcHN9IC8+O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1lbW8oUHJvbVF1ZXJ5RWRpdG9yQnlBcHApO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IFByb21RdWVyeUZpZWxkIGZyb20gJy4vUHJvbVF1ZXJ5RmllbGQnO1xuaW1wb3J0IHsgUHJvbVF1ZXJ5RWRpdG9yUHJvcHMgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGZ1bmN0aW9uIFByb21RdWVyeUVkaXRvckZvckFsZXJ0aW5nKHByb3BzOiBQcm9tUXVlcnlFZGl0b3JQcm9wcykge1xuICBjb25zdCB7IGRhdGFzb3VyY2UsIHF1ZXJ5LCByYW5nZSwgZGF0YSwgb25DaGFuZ2UsIG9uUnVuUXVlcnkgfSA9IHByb3BzO1xuXG4gIHJldHVybiAoXG4gICAgPFByb21RdWVyeUZpZWxkXG4gICAgICBkYXRhc291cmNlPXtkYXRhc291cmNlfVxuICAgICAgcXVlcnk9e3F1ZXJ5fVxuICAgICAgb25SdW5RdWVyeT17b25SdW5RdWVyeX1cbiAgICAgIG9uQ2hhbmdlPXtvbkNoYW5nZX1cbiAgICAgIGhpc3Rvcnk9e1tdfVxuICAgICAgcmFuZ2U9e3JhbmdlfVxuICAgICAgZGF0YT17ZGF0YX1cbiAgICAgIGRhdGEtdGVzdGlkPXt0ZXN0SWRzLmVkaXRvcn1cbiAgICAvPlxuICApO1xufVxuXG5leHBvcnQgY29uc3QgdGVzdElkcyA9IHtcbiAgZWRpdG9yOiAncHJvbS1lZGl0b3ItY2xvdWQtYWxlcnRpbmcnLFxufTtcbiIsImltcG9ydCB7IExhbmd1YWdlTWFwLCBsYW5ndWFnZXMgYXMgcHJpc21MYW5ndWFnZXMgfSBmcm9tICdwcmlzbWpzJztcbmltcG9ydCBSZWFjdCwgeyBSZWFjdE5vZGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBQbHVnaW4gfSBmcm9tICdzbGF0ZSc7XG5cbmltcG9ydCB7IFF1ZXJ5RWRpdG9yUHJvcHMsIFF1ZXJ5SGludCwgaXNEYXRhRnJhbWUsIHRvTGVnYWN5UmVzcG9uc2VEYXRhLCBUaW1lUmFuZ2UsIENvcmVBcHAgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7XG4gIFNsYXRlUHJpc20sXG4gIFR5cGVhaGVhZElucHV0LFxuICBUeXBlYWhlYWRPdXRwdXQsXG4gIEJyYWNlc1BsdWdpbixcbiAgRE9NVXRpbCxcbiAgU3VnZ2VzdGlvbnNTdGF0ZSxcbiAgSWNvbixcbn0gZnJvbSAnQGdyYWZhbmEvdWknO1xuaW1wb3J0IHsgTG9jYWxTdG9yYWdlVmFsdWVQcm92aWRlciB9IGZyb20gJ2FwcC9jb3JlL2NvbXBvbmVudHMvTG9jYWxTdG9yYWdlVmFsdWVQcm92aWRlcic7XG5pbXBvcnQgeyBDYW5jZWxhYmxlUHJvbWlzZSwgbWFrZVByb21pc2VDYW5jZWxhYmxlIH0gZnJvbSAnYXBwL2NvcmUvdXRpbHMvQ2FuY2VsYWJsZVByb21pc2UnO1xuXG5pbXBvcnQgeyBQcm9tZXRoZXVzRGF0YXNvdXJjZSB9IGZyb20gJy4uL2RhdGFzb3VyY2UnO1xuaW1wb3J0IHsgcm91bmRNc1RvTWluIH0gZnJvbSAnLi4vbGFuZ3VhZ2VfdXRpbHMnO1xuaW1wb3J0IHsgUHJvbVF1ZXJ5LCBQcm9tT3B0aW9ucyB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgUHJvbWV0aGV1c01ldHJpY3NCcm93c2VyIH0gZnJvbSAnLi9Qcm9tZXRoZXVzTWV0cmljc0Jyb3dzZXInO1xuaW1wb3J0IHsgTW9uYWNvUXVlcnlGaWVsZFdyYXBwZXIgfSBmcm9tICcuL21vbmFjby1xdWVyeS1maWVsZC9Nb25hY29RdWVyeUZpZWxkV3JhcHBlcic7XG5cbmV4cG9ydCBjb25zdCBSRUNPUkRJTkdfUlVMRVNfR1JPVVAgPSAnX19yZWNvcmRpbmdfcnVsZXNfXyc7XG5jb25zdCBMQVNUX1VTRURfTEFCRUxTX0tFWSA9ICdncmFmYW5hLmRhdGFzb3VyY2VzLnByb21ldGhldXMuYnJvd3Nlci5sYWJlbHMnO1xuXG5mdW5jdGlvbiBnZXRDaG9vc2VyVGV4dChtZXRyaWNzTG9va3VwRGlzYWJsZWQ6IGJvb2xlYW4sIGhhc1N5bnRheDogYm9vbGVhbiwgaGFzTWV0cmljczogYm9vbGVhbikge1xuICBpZiAobWV0cmljc0xvb2t1cERpc2FibGVkKSB7XG4gICAgcmV0dXJuICcoRGlzYWJsZWQpJztcbiAgfVxuXG4gIGlmICghaGFzU3ludGF4KSB7XG4gICAgcmV0dXJuICdMb2FkaW5nIG1ldHJpY3MuLi4nO1xuICB9XG5cbiAgaWYgKCFoYXNNZXRyaWNzKSB7XG4gICAgcmV0dXJuICcoTm8gbWV0cmljcyBmb3VuZCknO1xuICB9XG5cbiAgcmV0dXJuICdNZXRyaWNzIGJyb3dzZXInO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2lsbEFwcGx5U3VnZ2VzdGlvbihzdWdnZXN0aW9uOiBzdHJpbmcsIHsgdHlwZWFoZWFkQ29udGV4dCwgdHlwZWFoZWFkVGV4dCB9OiBTdWdnZXN0aW9uc1N0YXRlKTogc3RyaW5nIHtcbiAgLy8gTW9kaWZ5IHN1Z2dlc3Rpb24gYmFzZWQgb24gY29udGV4dFxuICBzd2l0Y2ggKHR5cGVhaGVhZENvbnRleHQpIHtcbiAgICBjYXNlICdjb250ZXh0LWxhYmVscyc6IHtcbiAgICAgIGNvbnN0IG5leHRDaGFyID0gRE9NVXRpbC5nZXROZXh0Q2hhcmFjdGVyKCk7XG4gICAgICBpZiAoIW5leHRDaGFyIHx8IG5leHRDaGFyID09PSAnfScgfHwgbmV4dENoYXIgPT09ICcsJykge1xuICAgICAgICBzdWdnZXN0aW9uICs9ICc9JztcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgJ2NvbnRleHQtbGFiZWwtdmFsdWVzJzoge1xuICAgICAgLy8gQWx3YXlzIGFkZCBxdW90ZXMgYW5kIHJlbW92ZSBleGlzdGluZyBvbmVzIGluc3RlYWRcbiAgICAgIGlmICghdHlwZWFoZWFkVGV4dC5tYXRjaCgvXighPz1+P1wifFwiKS8pKSB7XG4gICAgICAgIHN1Z2dlc3Rpb24gPSBgXCIke3N1Z2dlc3Rpb259YDtcbiAgICAgIH1cbiAgICAgIGlmIChET01VdGlsLmdldE5leHRDaGFyYWN0ZXIoKSAhPT0gJ1wiJykge1xuICAgICAgICBzdWdnZXN0aW9uID0gYCR7c3VnZ2VzdGlvbn1cImA7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBkZWZhdWx0OlxuICB9XG4gIHJldHVybiBzdWdnZXN0aW9uO1xufVxuXG5pbnRlcmZhY2UgUHJvbVF1ZXJ5RmllbGRQcm9wcyBleHRlbmRzIFF1ZXJ5RWRpdG9yUHJvcHM8UHJvbWV0aGV1c0RhdGFzb3VyY2UsIFByb21RdWVyeSwgUHJvbU9wdGlvbnM+IHtcbiAgRXh0cmFGaWVsZEVsZW1lbnQ/OiBSZWFjdE5vZGU7XG4gICdkYXRhLXRlc3RpZCc/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBQcm9tUXVlcnlGaWVsZFN0YXRlIHtcbiAgbGFiZWxCcm93c2VyVmlzaWJsZTogYm9vbGVhbjtcbiAgc3ludGF4TG9hZGVkOiBib29sZWFuO1xuICBoaW50OiBRdWVyeUhpbnQgfCBudWxsO1xufVxuXG5jbGFzcyBQcm9tUXVlcnlGaWVsZCBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQ8UHJvbVF1ZXJ5RmllbGRQcm9wcywgUHJvbVF1ZXJ5RmllbGRTdGF0ZT4ge1xuICBwbHVnaW5zOiBQbHVnaW5bXTtcbiAgZGVjbGFyZSBsYW5ndWFnZVByb3ZpZGVySW5pdGlhbGl6YXRpb25Qcm9taXNlOiBDYW5jZWxhYmxlUHJvbWlzZTxhbnk+O1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBQcm9tUXVlcnlGaWVsZFByb3BzLCBjb250ZXh0OiBSZWFjdC5Db250ZXh0PGFueT4pIHtcbiAgICBzdXBlcihwcm9wcywgY29udGV4dCk7XG5cbiAgICB0aGlzLnBsdWdpbnMgPSBbXG4gICAgICBCcmFjZXNQbHVnaW4oKSxcbiAgICAgIFNsYXRlUHJpc20oXG4gICAgICAgIHtcbiAgICAgICAgICBvbmx5SW46IChub2RlOiBhbnkpID0+IG5vZGUudHlwZSA9PT0gJ2NvZGVfYmxvY2snLFxuICAgICAgICAgIGdldFN5bnRheDogKG5vZGU6IGFueSkgPT4gJ3Byb21xbCcsXG4gICAgICAgIH0sXG4gICAgICAgIHsgLi4uKHByaXNtTGFuZ3VhZ2VzIGFzIExhbmd1YWdlTWFwKSwgcHJvbXFsOiB0aGlzLnByb3BzLmRhdGFzb3VyY2UubGFuZ3VhZ2VQcm92aWRlci5zeW50YXggfVxuICAgICAgKSxcbiAgICBdO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGxhYmVsQnJvd3NlclZpc2libGU6IGZhbHNlLFxuICAgICAgc3ludGF4TG9hZGVkOiBmYWxzZSxcbiAgICAgIGhpbnQ6IG51bGwsXG4gICAgfTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGlmICh0aGlzLnByb3BzLmRhdGFzb3VyY2UubGFuZ3VhZ2VQcm92aWRlcikge1xuICAgICAgdGhpcy5yZWZyZXNoTWV0cmljcygpO1xuICAgIH1cbiAgICB0aGlzLnJlZnJlc2hIaW50KCk7XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBpZiAodGhpcy5sYW5ndWFnZVByb3ZpZGVySW5pdGlhbGl6YXRpb25Qcm9taXNlKSB7XG4gICAgICB0aGlzLmxhbmd1YWdlUHJvdmlkZXJJbml0aWFsaXphdGlvblByb21pc2UuY2FuY2VsKCk7XG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wczogUHJvbVF1ZXJ5RmllbGRQcm9wcykge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICBkYXRhc291cmNlOiB7IGxhbmd1YWdlUHJvdmlkZXIgfSxcbiAgICAgIHJhbmdlLFxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgaWYgKGxhbmd1YWdlUHJvdmlkZXIgIT09IHByZXZQcm9wcy5kYXRhc291cmNlLmxhbmd1YWdlUHJvdmlkZXIpIHtcbiAgICAgIC8vIFdlIHJlc2V0IHRoaXMgb25seSBvbiBEUyBjaGFuZ2Ugc28gd2UgZG8gbm90IGZsZXNoIGxvYWRpbmcgc3RhdGUgb24gZXZlcnkgcmFuZ2VDaGFuZ2Ugd2hpY2ggaGFwcGVucyBvbiBldmVyeVxuICAgICAgLy8gcXVlcnkgcnVuIGlmIHVzaW5nIHJlbGF0aXZlIHJhbmdlLlxuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHN5bnRheExvYWRlZDogZmFsc2UsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBjaGFuZ2VkUmFuZ2VUb1JlZnJlc2ggPSB0aGlzLnJhbmdlQ2hhbmdlZFRvUmVmcmVzaChyYW5nZSwgcHJldlByb3BzLnJhbmdlKTtcbiAgICAvLyBXZSB3YW50IHRvIHJlZnJlc2ggbWV0cmljcyB3aGVuIGxhbmd1YWdlIHByb3ZpZGVyIGNoYW5nZXMgYW5kL29yIHdoZW4gcmFuZ2UgY2hhbmdlcyAod2Ugcm91bmQgdXAgaW50ZXJ2YWxzIHRvIGEgbWludXRlKVxuICAgIGlmIChsYW5ndWFnZVByb3ZpZGVyICE9PSBwcmV2UHJvcHMuZGF0YXNvdXJjZS5sYW5ndWFnZVByb3ZpZGVyIHx8IGNoYW5nZWRSYW5nZVRvUmVmcmVzaCkge1xuICAgICAgdGhpcy5yZWZyZXNoTWV0cmljcygpO1xuICAgIH1cblxuICAgIGlmIChkYXRhICYmIHByZXZQcm9wcy5kYXRhICYmIHByZXZQcm9wcy5kYXRhLnNlcmllcyAhPT0gZGF0YS5zZXJpZXMpIHtcbiAgICAgIHRoaXMucmVmcmVzaEhpbnQoKTtcbiAgICB9XG4gIH1cblxuICByZWZyZXNoSGludCA9ICgpID0+IHtcbiAgICBjb25zdCB7IGRhdGFzb3VyY2UsIHF1ZXJ5LCBkYXRhIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGluaXRIaW50cyA9IGRhdGFzb3VyY2UuZ2V0SW5pdEhpbnRzKCk7XG4gICAgY29uc3QgaW5pdEhpbnQgPSBpbml0SGludHMubGVuZ3RoID4gMCA/IGluaXRIaW50c1swXSA6IG51bGw7XG5cbiAgICBpZiAoIWRhdGEgfHwgZGF0YS5zZXJpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaGludDogaW5pdEhpbnQsXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBpc0RhdGFGcmFtZShkYXRhLnNlcmllc1swXSkgPyBkYXRhLnNlcmllcy5tYXAodG9MZWdhY3lSZXNwb25zZURhdGEpIDogZGF0YS5zZXJpZXM7XG4gICAgY29uc3QgcXVlcnlIaW50cyA9IGRhdGFzb3VyY2UuZ2V0UXVlcnlIaW50cyhxdWVyeSwgcmVzdWx0KTtcbiAgICBsZXQgcXVlcnlIaW50ID0gcXVlcnlIaW50cy5sZW5ndGggPiAwID8gcXVlcnlIaW50c1swXSA6IG51bGw7XG5cbiAgICB0aGlzLnNldFN0YXRlKHsgaGludDogcXVlcnlIaW50ID8/IGluaXRIaW50IH0pO1xuICB9O1xuXG4gIHJlZnJlc2hNZXRyaWNzID0gYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGFzb3VyY2U6IHsgbGFuZ3VhZ2VQcm92aWRlciB9LFxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgdGhpcy5sYW5ndWFnZVByb3ZpZGVySW5pdGlhbGl6YXRpb25Qcm9taXNlID0gbWFrZVByb21pc2VDYW5jZWxhYmxlKGxhbmd1YWdlUHJvdmlkZXIuc3RhcnQoKSk7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVtYWluaW5nVGFza3MgPSBhd2FpdCB0aGlzLmxhbmd1YWdlUHJvdmlkZXJJbml0aWFsaXphdGlvblByb21pc2UucHJvbWlzZTtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJlbWFpbmluZ1Rhc2tzKTtcbiAgICAgIHRoaXMub25VcGRhdGVMYW5ndWFnZSgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKCFlcnIuaXNDYW5jZWxlZCkge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJhbmdlQ2hhbmdlZFRvUmVmcmVzaChyYW5nZT86IFRpbWVSYW5nZSwgcHJldlJhbmdlPzogVGltZVJhbmdlKTogYm9vbGVhbiB7XG4gICAgaWYgKHJhbmdlICYmIHByZXZSYW5nZSkge1xuICAgICAgY29uc3Qgc2FtZU1pbnV0ZUZyb20gPSByb3VuZE1zVG9NaW4ocmFuZ2UuZnJvbS52YWx1ZU9mKCkpID09PSByb3VuZE1zVG9NaW4ocHJldlJhbmdlLmZyb20udmFsdWVPZigpKTtcbiAgICAgIGNvbnN0IHNhbWVNaW51dGVUbyA9IHJvdW5kTXNUb01pbihyYW5nZS50by52YWx1ZU9mKCkpID09PSByb3VuZE1zVG9NaW4ocHJldlJhbmdlLnRvLnZhbHVlT2YoKSk7XG4gICAgICAvLyBJZiBib3RoIGFyZSBzYW1lLCBkb24ndCBuZWVkIHRvIHJlZnJlc2guXG4gICAgICByZXR1cm4gIShzYW1lTWludXRlRnJvbSAmJiBzYW1lTWludXRlVG8pO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogVE9ETyAjMzM5NzY6IFJlbW92ZSB0aGlzLCBhZGQgaGlzdG9ncmFtIGdyb3VwIChxdWVyeSA9IGBoaXN0b2dyYW1fcXVhbnRpbGUoMC45NSwgc3VtKHJhdGUoJHttZXRyaWN9WzVtXSkpIGJ5IChsZSkpYDspXG4gICAqL1xuICBvbkNoYW5nZUxhYmVsQnJvd3NlciA9IChzZWxlY3Rvcjogc3RyaW5nKSA9PiB7XG4gICAgdGhpcy5vbkNoYW5nZVF1ZXJ5KHNlbGVjdG9yLCB0cnVlKTtcbiAgICB0aGlzLnNldFN0YXRlKHsgbGFiZWxCcm93c2VyVmlzaWJsZTogZmFsc2UgfSk7XG4gIH07XG5cbiAgb25DaGFuZ2VRdWVyeSA9ICh2YWx1ZTogc3RyaW5nLCBvdmVycmlkZT86IGJvb2xlYW4pID0+IHtcbiAgICAvLyBTZW5kIHRleHQgY2hhbmdlIHRvIHBhcmVudFxuICAgIGNvbnN0IHsgcXVlcnksIG9uQ2hhbmdlLCBvblJ1blF1ZXJ5IH0gPSB0aGlzLnByb3BzO1xuICAgIGlmIChvbkNoYW5nZSkge1xuICAgICAgY29uc3QgbmV4dFF1ZXJ5OiBQcm9tUXVlcnkgPSB7IC4uLnF1ZXJ5LCBleHByOiB2YWx1ZSB9O1xuICAgICAgb25DaGFuZ2UobmV4dFF1ZXJ5KTtcblxuICAgICAgaWYgKG92ZXJyaWRlICYmIG9uUnVuUXVlcnkpIHtcbiAgICAgICAgb25SdW5RdWVyeSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBvbkNsaWNrQ2hvb3NlckJ1dHRvbiA9ICgpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKChzdGF0ZSkgPT4gKHsgbGFiZWxCcm93c2VyVmlzaWJsZTogIXN0YXRlLmxhYmVsQnJvd3NlclZpc2libGUgfSkpO1xuICB9O1xuXG4gIG9uQ2xpY2tIaW50Rml4ID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgZGF0YXNvdXJjZSwgcXVlcnksIG9uQ2hhbmdlLCBvblJ1blF1ZXJ5IH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgaGludCB9ID0gdGhpcy5zdGF0ZTtcblxuICAgIG9uQ2hhbmdlKGRhdGFzb3VyY2UubW9kaWZ5UXVlcnkocXVlcnksIGhpbnQhLmZpeCEuYWN0aW9uKSk7XG4gICAgb25SdW5RdWVyeSgpO1xuICB9O1xuXG4gIG9uVXBkYXRlTGFuZ3VhZ2UgPSAoKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YXNvdXJjZTogeyBsYW5ndWFnZVByb3ZpZGVyIH0sXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyBtZXRyaWNzIH0gPSBsYW5ndWFnZVByb3ZpZGVyO1xuXG4gICAgaWYgKCFtZXRyaWNzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7IHN5bnRheExvYWRlZDogdHJ1ZSB9KTtcbiAgfTtcblxuICBvblR5cGVhaGVhZCA9IGFzeW5jICh0eXBlYWhlYWQ6IFR5cGVhaGVhZElucHV0KTogUHJvbWlzZTxUeXBlYWhlYWRPdXRwdXQ+ID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhc291cmNlOiB7IGxhbmd1YWdlUHJvdmlkZXIgfSxcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIGlmICghbGFuZ3VhZ2VQcm92aWRlcikge1xuICAgICAgcmV0dXJuIHsgc3VnZ2VzdGlvbnM6IFtdIH07XG4gICAgfVxuXG4gICAgY29uc3QgeyBoaXN0b3J5IH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgcHJlZml4LCB0ZXh0LCB2YWx1ZSwgd3JhcHBlckNsYXNzZXMsIGxhYmVsS2V5IH0gPSB0eXBlYWhlYWQ7XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBsYW5ndWFnZVByb3ZpZGVyLnByb3ZpZGVDb21wbGV0aW9uSXRlbXMoXG4gICAgICB7IHRleHQsIHZhbHVlLCBwcmVmaXgsIHdyYXBwZXJDbGFzc2VzLCBsYWJlbEtleSB9LFxuICAgICAgeyBoaXN0b3J5IH1cbiAgICApO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YXNvdXJjZSxcbiAgICAgIGRhdGFzb3VyY2U6IHsgbGFuZ3VhZ2VQcm92aWRlciB9LFxuICAgICAgcXVlcnksXG4gICAgICBFeHRyYUZpZWxkRWxlbWVudCxcbiAgICAgIGhpc3RvcnkgPSBbXSxcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IHsgbGFiZWxCcm93c2VyVmlzaWJsZSwgc3ludGF4TG9hZGVkLCBoaW50IH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGhhc01ldHJpY3MgPSBsYW5ndWFnZVByb3ZpZGVyLm1ldHJpY3MubGVuZ3RoID4gMDtcbiAgICBjb25zdCBjaG9vc2VyVGV4dCA9IGdldENob29zZXJUZXh0KGRhdGFzb3VyY2UubG9va3Vwc0Rpc2FibGVkLCBzeW50YXhMb2FkZWQsIGhhc01ldHJpY3MpO1xuICAgIGNvbnN0IGJ1dHRvbkRpc2FibGVkID0gIShzeW50YXhMb2FkZWQgJiYgaGFzTWV0cmljcyk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPExvY2FsU3RvcmFnZVZhbHVlUHJvdmlkZXI8c3RyaW5nW10+IHN0b3JhZ2VLZXk9e0xBU1RfVVNFRF9MQUJFTFNfS0VZfSBkZWZhdWx0VmFsdWU9e1tdfT5cbiAgICAgICAgeyhsYXN0VXNlZExhYmVscywgb25MYXN0VXNlZExhYmVsc1NhdmUsIG9uTGFzdFVzZWRMYWJlbHNEZWxldGUpID0+IHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImdmLWZvcm0taW5saW5lIGdmLWZvcm0taW5saW5lLS14cy12aWV3LWZsZXgtY29sdW1uIGZsZXgtZ3Jvdy0xXCJcbiAgICAgICAgICAgICAgICBkYXRhLXRlc3RpZD17dGhpcy5wcm9wc1snZGF0YS10ZXN0aWQnXX1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImdmLWZvcm0tbGFiZWwgcXVlcnkta2V5d29yZCBwb2ludGVyXCJcbiAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMub25DbGlja0Nob29zZXJCdXR0b259XG4gICAgICAgICAgICAgICAgICBkaXNhYmxlZD17YnV0dG9uRGlzYWJsZWR9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAge2Nob29zZXJUZXh0fVxuICAgICAgICAgICAgICAgICAgPEljb24gbmFtZT17bGFiZWxCcm93c2VyVmlzaWJsZSA/ICdhbmdsZS1kb3duJyA6ICdhbmdsZS1yaWdodCd9IC8+XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm0gZ2YtZm9ybS0tZ3JvdyBmbGV4LXNocmluay0xIG1pbi13aWR0aC0xNVwiPlxuICAgICAgICAgICAgICAgICAgPE1vbmFjb1F1ZXJ5RmllbGRXcmFwcGVyXG4gICAgICAgICAgICAgICAgICAgIHJ1blF1ZXJ5T25CbHVyPXt0aGlzLnByb3BzLmFwcCAhPT0gQ29yZUFwcC5FeHBsb3JlfVxuICAgICAgICAgICAgICAgICAgICBsYW5ndWFnZVByb3ZpZGVyPXtsYW5ndWFnZVByb3ZpZGVyfVxuICAgICAgICAgICAgICAgICAgICBoaXN0b3J5PXtoaXN0b3J5fVxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5vbkNoYW5nZVF1ZXJ5fVxuICAgICAgICAgICAgICAgICAgICBvblJ1blF1ZXJ5PXt0aGlzLnByb3BzLm9uUnVuUXVlcnl9XG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxWYWx1ZT17cXVlcnkuZXhwciA/PyAnJ31cbiAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICB7bGFiZWxCcm93c2VyVmlzaWJsZSAmJiAoXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtXCI+XG4gICAgICAgICAgICAgICAgICA8UHJvbWV0aGV1c01ldHJpY3NCcm93c2VyXG4gICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlUHJvdmlkZXI9e2xhbmd1YWdlUHJvdmlkZXJ9XG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLm9uQ2hhbmdlTGFiZWxCcm93c2VyfVxuICAgICAgICAgICAgICAgICAgICBsYXN0VXNlZExhYmVscz17bGFzdFVzZWRMYWJlbHMgfHwgW119XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlTGFzdFVzZWRMYWJlbHM9e29uTGFzdFVzZWRMYWJlbHNTYXZlfVxuICAgICAgICAgICAgICAgICAgICBkZWxldGVMYXN0VXNlZExhYmVscz17b25MYXN0VXNlZExhYmVsc0RlbGV0ZX1cbiAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICl9XG5cbiAgICAgICAgICAgICAge0V4dHJhRmllbGRFbGVtZW50fVxuICAgICAgICAgICAgICB7aGludCA/IChcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInF1ZXJ5LXJvdy1icmVha1wiPlxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwcm9tLXF1ZXJ5LWZpZWxkLWluZm8gdGV4dC13YXJuaW5nXCI+XG4gICAgICAgICAgICAgICAgICAgIHtoaW50LmxhYmVsfXsnICd9XG4gICAgICAgICAgICAgICAgICAgIHtoaW50LmZpeCA/IChcbiAgICAgICAgICAgICAgICAgICAgICA8YSBjbGFzc05hbWU9XCJ0ZXh0LWxpbmsgbXV0ZWRcIiBvbkNsaWNrPXt0aGlzLm9uQ2xpY2tIaW50Rml4fT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtoaW50LmZpeC5sYWJlbH1cbiAgICAgICAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICAgICAgICAgICkgOiBudWxsfVxuICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICkgOiBudWxsfVxuICAgICAgICAgICAgPC8+XG4gICAgICAgICAgKTtcbiAgICAgICAgfX1cbiAgICAgIDwvTG9jYWxTdG9yYWdlVmFsdWVQcm92aWRlcj5cbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFByb21RdWVyeUZpZWxkO1xuIiwiaW1wb3J0IHsgY3NzLCBjeCB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgUmVhY3QsIHsgQ2hhbmdlRXZlbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBGaXhlZFNpemVMaXN0IH0gZnJvbSAncmVhY3Qtd2luZG93JztcblxuaW1wb3J0IHsgR3JhZmFuYVRoZW1lIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQge1xuICBCdXR0b24sXG4gIEhvcml6b250YWxHcm91cCxcbiAgSW5wdXQsXG4gIExhYmVsLFxuICBMb2FkaW5nUGxhY2Vob2xkZXIsXG4gIHN0eWxlc0ZhY3RvcnksXG4gIHdpdGhUaGVtZSxcbiAgQnJvd3NlckxhYmVsIGFzIFByb21MYWJlbCxcbn0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5pbXBvcnQgUHJvbVFsTGFuZ3VhZ2VQcm92aWRlciBmcm9tICcuLi9sYW5ndWFnZV9wcm92aWRlcic7XG5pbXBvcnQgeyBlc2NhcGVMYWJlbFZhbHVlSW5FeGFjdFNlbGVjdG9yLCBlc2NhcGVMYWJlbFZhbHVlSW5SZWdleFNlbGVjdG9yIH0gZnJvbSAnLi4vbGFuZ3VhZ2VfdXRpbHMnO1xuXG4vLyBIYXJkIGxpbWl0IG9uIGxhYmVscyB0byByZW5kZXJcbmNvbnN0IEVNUFRZX1NFTEVDVE9SID0gJ3t9JztcbmNvbnN0IE1FVFJJQ19MQUJFTCA9ICdfX25hbWVfXyc7XG5jb25zdCBMSVNUX0lURU1fU0laRSA9IDI1O1xuXG5leHBvcnQgaW50ZXJmYWNlIEJyb3dzZXJQcm9wcyB7XG4gIGxhbmd1YWdlUHJvdmlkZXI6IFByb21RbExhbmd1YWdlUHJvdmlkZXI7XG4gIG9uQ2hhbmdlOiAoc2VsZWN0b3I6IHN0cmluZykgPT4gdm9pZDtcbiAgdGhlbWU6IEdyYWZhbmFUaGVtZTtcbiAgYXV0b1NlbGVjdD86IG51bWJlcjtcbiAgaGlkZT86ICgpID0+IHZvaWQ7XG4gIGxhc3RVc2VkTGFiZWxzOiBzdHJpbmdbXTtcbiAgc3RvcmVMYXN0VXNlZExhYmVsczogKGxhYmVsczogc3RyaW5nW10pID0+IHZvaWQ7XG4gIGRlbGV0ZUxhc3RVc2VkTGFiZWxzOiAoKSA9PiB2b2lkO1xufVxuXG5pbnRlcmZhY2UgQnJvd3NlclN0YXRlIHtcbiAgbGFiZWxzOiBTZWxlY3RhYmxlTGFiZWxbXTtcbiAgbGFiZWxTZWFyY2hUZXJtOiBzdHJpbmc7XG4gIG1ldHJpY1NlYXJjaFRlcm06IHN0cmluZztcbiAgc3RhdHVzOiBzdHJpbmc7XG4gIGVycm9yOiBzdHJpbmc7XG4gIHZhbGlkYXRpb25TdGF0dXM6IHN0cmluZztcbiAgdmFsdWVTZWFyY2hUZXJtOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBGYWNldHRhYmxlVmFsdWUge1xuICBuYW1lOiBzdHJpbmc7XG4gIHNlbGVjdGVkPzogYm9vbGVhbjtcbiAgZGV0YWlscz86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZWxlY3RhYmxlTGFiZWwge1xuICBuYW1lOiBzdHJpbmc7XG4gIHNlbGVjdGVkPzogYm9vbGVhbjtcbiAgbG9hZGluZz86IGJvb2xlYW47XG4gIHZhbHVlcz86IEZhY2V0dGFibGVWYWx1ZVtdO1xuICBoaWRkZW4/OiBib29sZWFuO1xuICBmYWNldHM/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZFNlbGVjdG9yKGxhYmVsczogU2VsZWN0YWJsZUxhYmVsW10pOiBzdHJpbmcge1xuICBsZXQgc2luZ2xlTWV0cmljID0gJyc7XG4gIGNvbnN0IHNlbGVjdGVkTGFiZWxzID0gW107XG4gIGZvciAoY29uc3QgbGFiZWwgb2YgbGFiZWxzKSB7XG4gICAgaWYgKChsYWJlbC5uYW1lID09PSBNRVRSSUNfTEFCRUwgfHwgbGFiZWwuc2VsZWN0ZWQpICYmIGxhYmVsLnZhbHVlcyAmJiBsYWJlbC52YWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgc2VsZWN0ZWRWYWx1ZXMgPSBsYWJlbC52YWx1ZXMuZmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWUuc2VsZWN0ZWQpLm1hcCgodmFsdWUpID0+IHZhbHVlLm5hbWUpO1xuICAgICAgaWYgKHNlbGVjdGVkVmFsdWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgc2VsZWN0ZWRMYWJlbHMucHVzaChgJHtsYWJlbC5uYW1lfT1+XCIke3NlbGVjdGVkVmFsdWVzLm1hcChlc2NhcGVMYWJlbFZhbHVlSW5SZWdleFNlbGVjdG9yKS5qb2luKCd8Jyl9XCJgKTtcbiAgICAgIH0gZWxzZSBpZiAoc2VsZWN0ZWRWYWx1ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmIChsYWJlbC5uYW1lID09PSBNRVRSSUNfTEFCRUwpIHtcbiAgICAgICAgICBzaW5nbGVNZXRyaWMgPSBzZWxlY3RlZFZhbHVlc1swXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxlY3RlZExhYmVscy5wdXNoKGAke2xhYmVsLm5hbWV9PVwiJHtlc2NhcGVMYWJlbFZhbHVlSW5FeGFjdFNlbGVjdG9yKHNlbGVjdGVkVmFsdWVzWzBdKX1cImApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBbc2luZ2xlTWV0cmljLCAneycsIHNlbGVjdGVkTGFiZWxzLmpvaW4oJywnKSwgJ30nXS5qb2luKCcnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZhY2V0TGFiZWxzKFxuICBsYWJlbHM6IFNlbGVjdGFibGVMYWJlbFtdLFxuICBwb3NzaWJsZUxhYmVsczogUmVjb3JkPHN0cmluZywgc3RyaW5nW10+LFxuICBsYXN0RmFjZXR0ZWQ/OiBzdHJpbmdcbik6IFNlbGVjdGFibGVMYWJlbFtdIHtcbiAgcmV0dXJuIGxhYmVscy5tYXAoKGxhYmVsKSA9PiB7XG4gICAgY29uc3QgcG9zc2libGVWYWx1ZXMgPSBwb3NzaWJsZUxhYmVsc1tsYWJlbC5uYW1lXTtcbiAgICBpZiAocG9zc2libGVWYWx1ZXMpIHtcbiAgICAgIGxldCBleGlzdGluZ1ZhbHVlczogRmFjZXR0YWJsZVZhbHVlW107XG4gICAgICBpZiAobGFiZWwubmFtZSA9PT0gbGFzdEZhY2V0dGVkICYmIGxhYmVsLnZhbHVlcykge1xuICAgICAgICAvLyBGYWNldHRpbmcgdGhpcyBsYWJlbCwgc2hvdyBhbGwgdmFsdWVzXG4gICAgICAgIGV4aXN0aW5nVmFsdWVzID0gbGFiZWwudmFsdWVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gS2VlcCBzZWxlY3Rpb24gaW4gb3RoZXIgZmFjZXRzXG4gICAgICAgIGNvbnN0IHNlbGVjdGVkVmFsdWVzOiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQoXG4gICAgICAgICAgbGFiZWwudmFsdWVzPy5maWx0ZXIoKHZhbHVlKSA9PiB2YWx1ZS5zZWxlY3RlZCkubWFwKCh2YWx1ZSkgPT4gdmFsdWUubmFtZSkgfHwgW11cbiAgICAgICAgKTtcbiAgICAgICAgLy8gVmFsdWVzIGZvciB0aGlzIGxhYmVsIGhhdmUgbm90IGJlZW4gcmVxdWVzdGVkIHlldCwgbGV0J3MgdXNlIHRoZSBmYWNldHRlZCBvbmVzIGFzIHRoZSBpbml0aWFsIHZhbHVlc1xuICAgICAgICBleGlzdGluZ1ZhbHVlcyA9IHBvc3NpYmxlVmFsdWVzLm1hcCgodmFsdWUpID0+ICh7IG5hbWU6IHZhbHVlLCBzZWxlY3RlZDogc2VsZWN0ZWRWYWx1ZXMuaGFzKHZhbHVlKSB9KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5sYWJlbCxcbiAgICAgICAgbG9hZGluZzogZmFsc2UsXG4gICAgICAgIHZhbHVlczogZXhpc3RpbmdWYWx1ZXMsXG4gICAgICAgIGhpZGRlbjogIXBvc3NpYmxlVmFsdWVzLFxuICAgICAgICBmYWNldHM6IGV4aXN0aW5nVmFsdWVzLmxlbmd0aCxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gTGFiZWwgaXMgZmFjZXR0ZWQgb3V0LCBoaWRlIGFsbCB2YWx1ZXNcbiAgICByZXR1cm4geyAuLi5sYWJlbCwgbG9hZGluZzogZmFsc2UsIGhpZGRlbjogIXBvc3NpYmxlVmFsdWVzLCB2YWx1ZXM6IHVuZGVmaW5lZCwgZmFjZXRzOiAwIH07XG4gIH0pO1xufVxuXG5jb25zdCBnZXRTdHlsZXMgPSBzdHlsZXNGYWN0b3J5KCh0aGVtZTogR3JhZmFuYVRoZW1lKSA9PiAoe1xuICB3cmFwcGVyOiBjc3NgXG4gICAgYmFja2dyb3VuZC1jb2xvcjogJHt0aGVtZS5jb2xvcnMuYmcyfTtcbiAgICBwYWRkaW5nOiAke3RoZW1lLnNwYWNpbmcuc219O1xuICAgIHdpZHRoOiAxMDAlO1xuICBgLFxuICBsaXN0OiBjc3NgXG4gICAgbWFyZ2luLXRvcDogJHt0aGVtZS5zcGFjaW5nLnNtfTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtd3JhcDogd3JhcDtcbiAgICBtYXgtaGVpZ2h0OiAyMDBweDtcbiAgICBvdmVyZmxvdzogYXV0bztcbiAgICBhbGlnbi1jb250ZW50OiBmbGV4LXN0YXJ0O1xuICBgLFxuICBzZWN0aW9uOiBjc3NgXG4gICAgJiArICYge1xuICAgICAgbWFyZ2luOiAke3RoZW1lLnNwYWNpbmcubWR9IDA7XG4gICAgfVxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgYCxcbiAgc2VsZWN0b3I6IGNzc2BcbiAgICBmb250LWZhbWlseTogJHt0aGVtZS50eXBvZ3JhcGh5LmZvbnRGYW1pbHkubW9ub3NwYWNlfTtcbiAgICBtYXJnaW4tYm90dG9tOiAke3RoZW1lLnNwYWNpbmcuc219O1xuICBgLFxuICBzdGF0dXM6IGNzc2BcbiAgICBwYWRkaW5nOiAke3RoZW1lLnNwYWNpbmcueHN9O1xuICAgIGNvbG9yOiAke3RoZW1lLmNvbG9ycy50ZXh0U2VtaVdlYWt9O1xuICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbiAgICAvKiB1c2luZyBhYnNvbHV0ZSBwb3NpdGlvbmluZyBiZWNhdXNlIGZsZXggaW50ZXJmZXJlcyB3aXRoIGVsbGlwc2lzICovXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHdpZHRoOiA1MCU7XG4gICAgcmlnaHQ6IDA7XG4gICAgdGV4dC1hbGlnbjogcmlnaHQ7XG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAxMDBtcyBsaW5lYXI7XG4gICAgb3BhY2l0eTogMDtcbiAgYCxcbiAgc3RhdHVzU2hvd2luZzogY3NzYFxuICAgIG9wYWNpdHk6IDE7XG4gIGAsXG4gIGVycm9yOiBjc3NgXG4gICAgY29sb3I6ICR7dGhlbWUucGFsZXR0ZS5icmFuZERhbmdlcn07XG4gIGAsXG4gIHZhbHVlTGlzdDogY3NzYFxuICAgIG1hcmdpbi1yaWdodDogJHt0aGVtZS5zcGFjaW5nLnNtfTtcbiAgYCxcbiAgdmFsdWVMaXN0V3JhcHBlcjogY3NzYFxuICAgIGJvcmRlci1sZWZ0OiAxcHggc29saWQgJHt0aGVtZS5jb2xvcnMuYm9yZGVyMn07XG4gICAgbWFyZ2luOiAke3RoZW1lLnNwYWNpbmcuc219IDA7XG4gICAgcGFkZGluZzogJHt0aGVtZS5zcGFjaW5nLnNtfSAwICR7dGhlbWUuc3BhY2luZy5zbX0gJHt0aGVtZS5zcGFjaW5nLnNtfTtcbiAgYCxcbiAgdmFsdWVMaXN0QXJlYTogY3NzYFxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC13cmFwOiB3cmFwO1xuICAgIG1hcmdpbi10b3A6ICR7dGhlbWUuc3BhY2luZy5zbX07XG4gIGAsXG4gIHZhbHVlVGl0bGU6IGNzc2BcbiAgICBtYXJnaW4tbGVmdDogLSR7dGhlbWUuc3BhY2luZy54c307XG4gICAgbWFyZ2luLWJvdHRvbTogJHt0aGVtZS5zcGFjaW5nLnNtfTtcbiAgYCxcbiAgdmFsaWRhdGlvblN0YXR1czogY3NzYFxuICAgIHBhZGRpbmc6ICR7dGhlbWUuc3BhY2luZy54c307XG4gICAgbWFyZ2luLWJvdHRvbTogJHt0aGVtZS5zcGFjaW5nLnNtfTtcbiAgICBjb2xvcjogJHt0aGVtZS5jb2xvcnMudGV4dFN0cm9uZ307XG4gICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuICBgLFxufSkpO1xuXG4vKipcbiAqIFRPRE8gIzMzOTc2OiBSZW1vdmUgZHVwbGljYXRlZCBjb2RlLiBUaGUgY29tcG9uZW50IGlzIHZlcnkgc2ltaWxhciB0byBMb2tpTGFiZWxCcm93c2VyLnRzeC4gQ2hlY2sgaWYgaXQncyBwb3NzaWJsZVxuICogICAgICAgICAgICAgIHRvIGNyZWF0ZSBhIHNpbmdsZSwgZ2VuZXJpYyBjb21wb25lbnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBVbnRoZW1lZFByb21ldGhldXNNZXRyaWNzQnJvd3NlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxCcm93c2VyUHJvcHMsIEJyb3dzZXJTdGF0ZT4ge1xuICB2YWx1ZUxpc3RzUmVmID0gUmVhY3QuY3JlYXRlUmVmPEhUTUxEaXZFbGVtZW50PigpO1xuICBzdGF0ZTogQnJvd3NlclN0YXRlID0ge1xuICAgIGxhYmVsczogW10gYXMgU2VsZWN0YWJsZUxhYmVsW10sXG4gICAgbGFiZWxTZWFyY2hUZXJtOiAnJyxcbiAgICBtZXRyaWNTZWFyY2hUZXJtOiAnJyxcbiAgICBzdGF0dXM6ICdSZWFkeScsXG4gICAgZXJyb3I6ICcnLFxuICAgIHZhbGlkYXRpb25TdGF0dXM6ICcnLFxuICAgIHZhbHVlU2VhcmNoVGVybTogJycsXG4gIH07XG5cbiAgb25DaGFuZ2VMYWJlbFNlYXJjaCA9IChldmVudDogQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHsgbGFiZWxTZWFyY2hUZXJtOiBldmVudC50YXJnZXQudmFsdWUgfSk7XG4gIH07XG5cbiAgb25DaGFuZ2VNZXRyaWNTZWFyY2ggPSAoZXZlbnQ6IENoYW5nZUV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IG1ldHJpY1NlYXJjaFRlcm06IGV2ZW50LnRhcmdldC52YWx1ZSB9KTtcbiAgfTtcblxuICBvbkNoYW5nZVZhbHVlU2VhcmNoID0gKGV2ZW50OiBDaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoeyB2YWx1ZVNlYXJjaFRlcm06IGV2ZW50LnRhcmdldC52YWx1ZSB9KTtcbiAgfTtcblxuICBvbkNsaWNrUnVuUXVlcnkgPSAoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBidWlsZFNlbGVjdG9yKHRoaXMuc3RhdGUubGFiZWxzKTtcbiAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHNlbGVjdG9yKTtcbiAgfTtcblxuICBvbkNsaWNrUnVuUmF0ZVF1ZXJ5ID0gKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdG9yID0gYnVpbGRTZWxlY3Rvcih0aGlzLnN0YXRlLmxhYmVscyk7XG4gICAgY29uc3QgcXVlcnkgPSBgcmF0ZSgke3NlbGVjdG9yfVskX19pbnRlcnZhbF0pYDtcbiAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHF1ZXJ5KTtcbiAgfTtcblxuICBvbkNsaWNrQ2xlYXIgPSAoKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSgoc3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IGxhYmVsczogU2VsZWN0YWJsZUxhYmVsW10gPSBzdGF0ZS5sYWJlbHMubWFwKChsYWJlbCkgPT4gKHtcbiAgICAgICAgLi4ubGFiZWwsXG4gICAgICAgIHZhbHVlczogdW5kZWZpbmVkLFxuICAgICAgICBzZWxlY3RlZDogZmFsc2UsXG4gICAgICAgIGxvYWRpbmc6IGZhbHNlLFxuICAgICAgICBoaWRkZW46IGZhbHNlLFxuICAgICAgICBmYWNldHM6IHVuZGVmaW5lZCxcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxhYmVscyxcbiAgICAgICAgbGFiZWxTZWFyY2hUZXJtOiAnJyxcbiAgICAgICAgbWV0cmljU2VhcmNoVGVybTogJycsXG4gICAgICAgIHN0YXR1czogJycsXG4gICAgICAgIGVycm9yOiAnJyxcbiAgICAgICAgdmFsaWRhdGlvblN0YXR1czogJycsXG4gICAgICAgIHZhbHVlU2VhcmNoVGVybTogJycsXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHRoaXMucHJvcHMuZGVsZXRlTGFzdFVzZWRMYWJlbHMoKTtcbiAgICAvLyBHZXQgbWV0cmljc1xuICAgIHRoaXMuZmV0Y2hWYWx1ZXMoTUVUUklDX0xBQkVMLCBFTVBUWV9TRUxFQ1RPUik7XG4gIH07XG5cbiAgb25DbGlja0xhYmVsID0gKG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyB8IHVuZGVmaW5lZCwgZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQ8SFRNTEVsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLnN0YXRlLmxhYmVscy5maW5kKChsKSA9PiBsLm5hbWUgPT09IG5hbWUpO1xuICAgIGlmICghbGFiZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gVG9nZ2xlIHNlbGVjdGVkIHN0YXRlXG4gICAgY29uc3Qgc2VsZWN0ZWQgPSAhbGFiZWwuc2VsZWN0ZWQ7XG4gICAgbGV0IG5leHRWYWx1ZTogUGFydGlhbDxTZWxlY3RhYmxlTGFiZWw+ID0geyBzZWxlY3RlZCB9O1xuICAgIGlmIChsYWJlbC52YWx1ZXMgJiYgIXNlbGVjdGVkKSB7XG4gICAgICAvLyBEZXNlbGVjdCBhbGwgdmFsdWVzIGlmIGxhYmVsIHdhcyBkZXNlbGVjdGVkXG4gICAgICBjb25zdCB2YWx1ZXMgPSBsYWJlbC52YWx1ZXMubWFwKCh2YWx1ZSkgPT4gKHsgLi4udmFsdWUsIHNlbGVjdGVkOiBmYWxzZSB9KSk7XG4gICAgICBuZXh0VmFsdWUgPSB7IC4uLm5leHRWYWx1ZSwgZmFjZXRzOiAwLCB2YWx1ZXMgfTtcbiAgICB9XG4gICAgLy8gUmVzZXR0aW5nIHNlYXJjaCB0byBwcmV2ZW50IGVtcHR5IHJlc3VsdHNcbiAgICB0aGlzLnNldFN0YXRlKHsgbGFiZWxTZWFyY2hUZXJtOiAnJyB9KTtcbiAgICB0aGlzLnVwZGF0ZUxhYmVsU3RhdGUobmFtZSwgbmV4dFZhbHVlLCAnJywgKCkgPT4gdGhpcy5kb0ZhY2V0dGluZ0ZvckxhYmVsKG5hbWUpKTtcbiAgfTtcblxuICBvbkNsaWNrVmFsdWUgPSAobmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nIHwgdW5kZWZpbmVkLCBldmVudDogUmVhY3QuTW91c2VFdmVudDxIVE1MRWxlbWVudD4pID0+IHtcbiAgICBjb25zdCBsYWJlbCA9IHRoaXMuc3RhdGUubGFiZWxzLmZpbmQoKGwpID0+IGwubmFtZSA9PT0gbmFtZSk7XG4gICAgaWYgKCFsYWJlbCB8fCAhbGFiZWwudmFsdWVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFJlc2V0dGluZyBzZWFyY2ggdG8gcHJldmVudCBlbXB0eSByZXN1bHRzXG4gICAgdGhpcy5zZXRTdGF0ZSh7IGxhYmVsU2VhcmNoVGVybTogJycgfSk7XG4gICAgLy8gVG9nZ2xpbmcgdmFsdWUgZm9yIHNlbGVjdGVkIGxhYmVsLCBsZWF2aW5nIG90aGVyIHZhbHVlcyBpbnRhY3RcbiAgICBjb25zdCB2YWx1ZXMgPSBsYWJlbC52YWx1ZXMubWFwKCh2KSA9PiAoeyAuLi52LCBzZWxlY3RlZDogdi5uYW1lID09PSB2YWx1ZSA/ICF2LnNlbGVjdGVkIDogdi5zZWxlY3RlZCB9KSk7XG4gICAgdGhpcy51cGRhdGVMYWJlbFN0YXRlKG5hbWUsIHsgdmFsdWVzIH0sICcnLCAoKSA9PiB0aGlzLmRvRmFjZXR0aW5nKG5hbWUpKTtcbiAgfTtcblxuICBvbkNsaWNrTWV0cmljID0gKG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyB8IHVuZGVmaW5lZCwgZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQ8SFRNTEVsZW1lbnQ+KSA9PiB7XG4gICAgLy8gRmluZGluZyBzcGVjaWFsIG1ldHJpYyBsYWJlbFxuICAgIGNvbnN0IGxhYmVsID0gdGhpcy5zdGF0ZS5sYWJlbHMuZmluZCgobCkgPT4gbC5uYW1lID09PSBuYW1lKTtcbiAgICBpZiAoIWxhYmVsIHx8ICFsYWJlbC52YWx1ZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gUmVzZXR0aW5nIHNlYXJjaCB0byBwcmV2ZW50IGVtcHR5IHJlc3VsdHNcbiAgICB0aGlzLnNldFN0YXRlKHsgbWV0cmljU2VhcmNoVGVybTogJycgfSk7XG4gICAgLy8gVG9nZ2xpbmcgdmFsdWUgZm9yIHNlbGVjdGVkIGxhYmVsLCBsZWF2aW5nIG90aGVyIHZhbHVlcyBpbnRhY3RcbiAgICBjb25zdCB2YWx1ZXMgPSBsYWJlbC52YWx1ZXMubWFwKCh2KSA9PiAoe1xuICAgICAgLi4udixcbiAgICAgIHNlbGVjdGVkOiB2Lm5hbWUgPT09IHZhbHVlIHx8IHYuc2VsZWN0ZWQgPyAhdi5zZWxlY3RlZCA6IHYuc2VsZWN0ZWQsXG4gICAgfSkpO1xuICAgIC8vIFRvZ2dsZSBzZWxlY3RlZCBzdGF0ZSBvZiBzcGVjaWFsIG1ldHJpY3MgbGFiZWxcbiAgICBjb25zdCBzZWxlY3RlZCA9IHZhbHVlcy5zb21lKCh2KSA9PiB2LnNlbGVjdGVkKTtcbiAgICB0aGlzLnVwZGF0ZUxhYmVsU3RhdGUobmFtZSwgeyBzZWxlY3RlZCwgdmFsdWVzIH0sICcnLCAoKSA9PiB0aGlzLmRvRmFjZXR0aW5nKG5hbWUpKTtcbiAgfTtcblxuICBvbkNsaWNrVmFsaWRhdGUgPSAoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBidWlsZFNlbGVjdG9yKHRoaXMuc3RhdGUubGFiZWxzKTtcbiAgICB0aGlzLnZhbGlkYXRlU2VsZWN0b3Ioc2VsZWN0b3IpO1xuICB9O1xuXG4gIHVwZGF0ZUxhYmVsU3RhdGUobmFtZTogc3RyaW5nLCB1cGRhdGVkRmllbGRzOiBQYXJ0aWFsPFNlbGVjdGFibGVMYWJlbD4sIHN0YXR1cyA9ICcnLCBjYj86ICgpID0+IHZvaWQpIHtcbiAgICB0aGlzLnNldFN0YXRlKChzdGF0ZSkgPT4ge1xuICAgICAgY29uc3QgbGFiZWxzOiBTZWxlY3RhYmxlTGFiZWxbXSA9IHN0YXRlLmxhYmVscy5tYXAoKGxhYmVsKSA9PiB7XG4gICAgICAgIGlmIChsYWJlbC5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHsgLi4ubGFiZWwsIC4uLnVwZGF0ZWRGaWVsZHMgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGFiZWw7XG4gICAgICB9KTtcbiAgICAgIC8vIE5ldyBzdGF0dXMgb3ZlcnJpZGVzIGVycm9yc1xuICAgICAgY29uc3QgZXJyb3IgPSBzdGF0dXMgPyAnJyA6IHN0YXRlLmVycm9yO1xuICAgICAgcmV0dXJuIHsgbGFiZWxzLCBzdGF0dXMsIGVycm9yLCB2YWxpZGF0aW9uU3RhdHVzOiAnJyB9O1xuICAgIH0sIGNiKTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGNvbnN0IHsgbGFuZ3VhZ2VQcm92aWRlciwgbGFzdFVzZWRMYWJlbHMgfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKGxhbmd1YWdlUHJvdmlkZXIpIHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkTGFiZWxzOiBzdHJpbmdbXSA9IGxhc3RVc2VkTGFiZWxzO1xuICAgICAgbGFuZ3VhZ2VQcm92aWRlci5zdGFydCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICBsZXQgcmF3TGFiZWxzOiBzdHJpbmdbXSA9IGxhbmd1YWdlUHJvdmlkZXIuZ2V0TGFiZWxLZXlzKCk7XG4gICAgICAgIC8vIEdldCBtZXRyaWNzXG4gICAgICAgIHRoaXMuZmV0Y2hWYWx1ZXMoTUVUUklDX0xBQkVMLCBFTVBUWV9TRUxFQ1RPUik7XG4gICAgICAgIC8vIEF1dG8tc2VsZWN0IHByZXZpb3VzbHkgc2VsZWN0ZWQgbGFiZWxzXG4gICAgICAgIGNvbnN0IGxhYmVsczogU2VsZWN0YWJsZUxhYmVsW10gPSByYXdMYWJlbHMubWFwKChsYWJlbCwgaSwgYXJyKSA9PiAoe1xuICAgICAgICAgIG5hbWU6IGxhYmVsLFxuICAgICAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZExhYmVscy5pbmNsdWRlcyhsYWJlbCksXG4gICAgICAgICAgbG9hZGluZzogZmFsc2UsXG4gICAgICAgIH0pKTtcbiAgICAgICAgLy8gUHJlLWZldGNoIHZhbHVlcyBmb3Igc2VsZWN0ZWQgbGFiZWxzXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBsYWJlbHMgfSwgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuc3RhdGUubGFiZWxzLmZvckVhY2goKGxhYmVsKSA9PiB7XG4gICAgICAgICAgICBpZiAobGFiZWwuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5mZXRjaFZhbHVlcyhsYWJlbC5uYW1lLCBFTVBUWV9TRUxFQ1RPUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZG9GYWNldHRpbmdGb3JMYWJlbChuYW1lOiBzdHJpbmcpIHtcbiAgICBjb25zdCBsYWJlbCA9IHRoaXMuc3RhdGUubGFiZWxzLmZpbmQoKGwpID0+IGwubmFtZSA9PT0gbmFtZSk7XG4gICAgaWYgKCFsYWJlbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3RlZExhYmVscyA9IHRoaXMuc3RhdGUubGFiZWxzLmZpbHRlcigobGFiZWwpID0+IGxhYmVsLnNlbGVjdGVkKS5tYXAoKGxhYmVsKSA9PiBsYWJlbC5uYW1lKTtcbiAgICB0aGlzLnByb3BzLnN0b3JlTGFzdFVzZWRMYWJlbHMoc2VsZWN0ZWRMYWJlbHMpO1xuICAgIGlmIChsYWJlbC5zZWxlY3RlZCkge1xuICAgICAgLy8gUmVmZXRjaCB2YWx1ZXMgZm9yIG5ld2x5IHNlbGVjdGVkIGxhYmVsLi4uXG4gICAgICBpZiAoIWxhYmVsLnZhbHVlcykge1xuICAgICAgICB0aGlzLmZldGNoVmFsdWVzKG5hbWUsIGJ1aWxkU2VsZWN0b3IodGhpcy5zdGF0ZS5sYWJlbHMpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT25seSBuZWVkIHRvIGZhY2V0IHdoZW4gZGVzZWxlY3RpbmcgbGFiZWxzXG4gICAgICB0aGlzLmRvRmFjZXR0aW5nKCk7XG4gICAgfVxuICB9XG5cbiAgZG9GYWNldHRpbmcgPSAobGFzdEZhY2V0dGVkPzogc3RyaW5nKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBidWlsZFNlbGVjdG9yKHRoaXMuc3RhdGUubGFiZWxzKTtcbiAgICBpZiAoc2VsZWN0b3IgPT09IEVNUFRZX1NFTEVDVE9SKSB7XG4gICAgICAvLyBDbGVhciB1cCBmYWNldHRpbmdcbiAgICAgIGNvbnN0IGxhYmVsczogU2VsZWN0YWJsZUxhYmVsW10gPSB0aGlzLnN0YXRlLmxhYmVscy5tYXAoKGxhYmVsKSA9PiB7XG4gICAgICAgIHJldHVybiB7IC4uLmxhYmVsLCBmYWNldHM6IDAsIHZhbHVlczogdW5kZWZpbmVkLCBoaWRkZW46IGZhbHNlIH07XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBsYWJlbHMgfSwgKCkgPT4ge1xuICAgICAgICAvLyBHZXQgZnJlc2ggc2V0IG9mIHZhbHVlc1xuICAgICAgICB0aGlzLnN0YXRlLmxhYmVscy5mb3JFYWNoKFxuICAgICAgICAgIChsYWJlbCkgPT4gKGxhYmVsLnNlbGVjdGVkIHx8IGxhYmVsLm5hbWUgPT09IE1FVFJJQ19MQUJFTCkgJiYgdGhpcy5mZXRjaFZhbHVlcyhsYWJlbC5uYW1lLCBzZWxlY3RvcilcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEbyBmYWNldHRpbmdcbiAgICAgIHRoaXMuZmV0Y2hTZXJpZXMoc2VsZWN0b3IsIGxhc3RGYWNldHRlZCk7XG4gICAgfVxuICB9O1xuXG4gIGFzeW5jIGZldGNoVmFsdWVzKG5hbWU6IHN0cmluZywgc2VsZWN0b3I6IHN0cmluZykge1xuICAgIGNvbnN0IHsgbGFuZ3VhZ2VQcm92aWRlciB9ID0gdGhpcy5wcm9wcztcbiAgICB0aGlzLnVwZGF0ZUxhYmVsU3RhdGUobmFtZSwgeyBsb2FkaW5nOiB0cnVlIH0sIGBGZXRjaGluZyB2YWx1ZXMgZm9yICR7bmFtZX1gKTtcbiAgICB0cnkge1xuICAgICAgbGV0IHJhd1ZhbHVlcyA9IGF3YWl0IGxhbmd1YWdlUHJvdmlkZXIuZ2V0TGFiZWxWYWx1ZXMobmFtZSk7XG4gICAgICAvLyBJZiBzZWxlY3RvciBjaGFuZ2VkLCBjbGVhciBsb2FkaW5nIHN0YXRlIGFuZCBkaXNjYXJkIHJlc3VsdCBieSByZXR1cm5pbmcgZWFybHlcbiAgICAgIGlmIChzZWxlY3RvciAhPT0gYnVpbGRTZWxlY3Rvcih0aGlzLnN0YXRlLmxhYmVscykpIHtcbiAgICAgICAgdGhpcy51cGRhdGVMYWJlbFN0YXRlKG5hbWUsIHsgbG9hZGluZzogZmFsc2UgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlczogRmFjZXR0YWJsZVZhbHVlW10gPSBbXTtcbiAgICAgIGNvbnN0IHsgbWV0cmljc01ldGFkYXRhIH0gPSBsYW5ndWFnZVByb3ZpZGVyO1xuICAgICAgZm9yIChjb25zdCBsYWJlbFZhbHVlIG9mIHJhd1ZhbHVlcykge1xuICAgICAgICBjb25zdCB2YWx1ZTogRmFjZXR0YWJsZVZhbHVlID0geyBuYW1lOiBsYWJlbFZhbHVlIH07XG4gICAgICAgIC8vIEFkZGluZyB0eXBlL2hlbHAgdGV4dCB0byBtZXRyaWNzXG4gICAgICAgIGlmIChuYW1lID09PSBNRVRSSUNfTEFCRUwgJiYgbWV0cmljc01ldGFkYXRhKSB7XG4gICAgICAgICAgY29uc3QgbWV0YSA9IG1ldHJpY3NNZXRhZGF0YVtsYWJlbFZhbHVlXTtcbiAgICAgICAgICBpZiAobWV0YSkge1xuICAgICAgICAgICAgdmFsdWUuZGV0YWlscyA9IGAoJHttZXRhLnR5cGV9KSAke21ldGEuaGVscH1gO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZUxhYmVsU3RhdGUobmFtZSwgeyB2YWx1ZXMsIGxvYWRpbmc6IGZhbHNlIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBmZXRjaFNlcmllcyhzZWxlY3Rvcjogc3RyaW5nLCBsYXN0RmFjZXR0ZWQ/OiBzdHJpbmcpIHtcbiAgICBjb25zdCB7IGxhbmd1YWdlUHJvdmlkZXIgfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKGxhc3RGYWNldHRlZCkge1xuICAgICAgdGhpcy51cGRhdGVMYWJlbFN0YXRlKGxhc3RGYWNldHRlZCwgeyBsb2FkaW5nOiB0cnVlIH0sIGBGYWNldHRpbmcgbGFiZWxzIGZvciAke3NlbGVjdG9yfWApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgcG9zc2libGVMYWJlbHMgPSBhd2FpdCBsYW5ndWFnZVByb3ZpZGVyLmZldGNoU2VyaWVzTGFiZWxzKHNlbGVjdG9yLCB0cnVlKTtcbiAgICAgIC8vIElmIHNlbGVjdG9yIGNoYW5nZWQsIGNsZWFyIGxvYWRpbmcgc3RhdGUgYW5kIGRpc2NhcmQgcmVzdWx0IGJ5IHJldHVybmluZyBlYXJseVxuICAgICAgaWYgKHNlbGVjdG9yICE9PSBidWlsZFNlbGVjdG9yKHRoaXMuc3RhdGUubGFiZWxzKSkge1xuICAgICAgICBpZiAobGFzdEZhY2V0dGVkKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVMYWJlbFN0YXRlKGxhc3RGYWNldHRlZCwgeyBsb2FkaW5nOiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoT2JqZWN0LmtleXMocG9zc2libGVMYWJlbHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgZXJyb3I6IGBFbXB0eSByZXN1bHRzLCBubyBtYXRjaGluZyBsYWJlbCBmb3IgJHtzZWxlY3Rvcn1gIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBsYWJlbHM6IFNlbGVjdGFibGVMYWJlbFtdID0gZmFjZXRMYWJlbHModGhpcy5zdGF0ZS5sYWJlbHMsIHBvc3NpYmxlTGFiZWxzLCBsYXN0RmFjZXR0ZWQpO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGxhYmVscywgZXJyb3I6ICcnIH0pO1xuICAgICAgaWYgKGxhc3RGYWNldHRlZCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUxhYmVsU3RhdGUobGFzdEZhY2V0dGVkLCB7IGxvYWRpbmc6IGZhbHNlIH0pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyB2YWxpZGF0ZVNlbGVjdG9yKHNlbGVjdG9yOiBzdHJpbmcpIHtcbiAgICBjb25zdCB7IGxhbmd1YWdlUHJvdmlkZXIgfSA9IHRoaXMucHJvcHM7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IHZhbGlkYXRpb25TdGF0dXM6IGBWYWxpZGF0aW5nIHNlbGVjdG9yICR7c2VsZWN0b3J9YCwgZXJyb3I6ICcnIH0pO1xuICAgIGNvbnN0IHN0cmVhbXMgPSBhd2FpdCBsYW5ndWFnZVByb3ZpZGVyLmZldGNoU2VyaWVzKHNlbGVjdG9yKTtcbiAgICB0aGlzLnNldFN0YXRlKHsgdmFsaWRhdGlvblN0YXR1czogYFNlbGVjdG9yIGlzIHZhbGlkICgke3N0cmVhbXMubGVuZ3RofSBzZXJpZXMgZm91bmQpYCB9KTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IHRoZW1lIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgbGFiZWxzLCBsYWJlbFNlYXJjaFRlcm0sIG1ldHJpY1NlYXJjaFRlcm0sIHN0YXR1cywgZXJyb3IsIHZhbGlkYXRpb25TdGF0dXMsIHZhbHVlU2VhcmNoVGVybSB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBzdHlsZXMgPSBnZXRTdHlsZXModGhlbWUpO1xuICAgIGlmIChsYWJlbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLndyYXBwZXJ9PlxuICAgICAgICAgIDxMb2FkaW5nUGxhY2Vob2xkZXIgdGV4dD1cIkxvYWRpbmcgbGFiZWxzLi4uXCIgLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIEZpbHRlciBtZXRyaWNzXG4gICAgbGV0IG1ldHJpY3MgPSBsYWJlbHMuZmluZCgobGFiZWwpID0+IGxhYmVsLm5hbWUgPT09IE1FVFJJQ19MQUJFTCk7XG4gICAgaWYgKG1ldHJpY3MgJiYgbWV0cmljU2VhcmNoVGVybSkge1xuICAgICAgbWV0cmljcyA9IHtcbiAgICAgICAgLi4ubWV0cmljcyxcbiAgICAgICAgdmFsdWVzOiBtZXRyaWNzLnZhbHVlcz8uZmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWUuc2VsZWN0ZWQgfHwgdmFsdWUubmFtZS5pbmNsdWRlcyhtZXRyaWNTZWFyY2hUZXJtKSksXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEZpbHRlciBsYWJlbHNcbiAgICBsZXQgbm9uTWV0cmljTGFiZWxzID0gbGFiZWxzLmZpbHRlcigobGFiZWwpID0+ICFsYWJlbC5oaWRkZW4gJiYgbGFiZWwubmFtZSAhPT0gTUVUUklDX0xBQkVMKTtcbiAgICBpZiAobGFiZWxTZWFyY2hUZXJtKSB7XG4gICAgICBub25NZXRyaWNMYWJlbHMgPSBub25NZXRyaWNMYWJlbHMuZmlsdGVyKChsYWJlbCkgPT4gbGFiZWwuc2VsZWN0ZWQgfHwgbGFiZWwubmFtZS5pbmNsdWRlcyhsYWJlbFNlYXJjaFRlcm0pKTtcbiAgICB9XG5cbiAgICAvLyBGaWx0ZXIgbm9uLW1ldHJpYyBsYWJlbCB2YWx1ZXNcbiAgICBsZXQgc2VsZWN0ZWRMYWJlbHMgPSBub25NZXRyaWNMYWJlbHMuZmlsdGVyKChsYWJlbCkgPT4gbGFiZWwuc2VsZWN0ZWQgJiYgbGFiZWwudmFsdWVzKTtcbiAgICBpZiAodmFsdWVTZWFyY2hUZXJtKSB7XG4gICAgICBzZWxlY3RlZExhYmVscyA9IHNlbGVjdGVkTGFiZWxzLm1hcCgobGFiZWwpID0+ICh7XG4gICAgICAgIC4uLmxhYmVsLFxuICAgICAgICB2YWx1ZXM6IGxhYmVsLnZhbHVlcz8uZmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWUuc2VsZWN0ZWQgfHwgdmFsdWUubmFtZS5pbmNsdWRlcyh2YWx1ZVNlYXJjaFRlcm0pKSxcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBidWlsZFNlbGVjdG9yKHRoaXMuc3RhdGUubGFiZWxzKTtcbiAgICBjb25zdCBlbXB0eSA9IHNlbGVjdG9yID09PSBFTVBUWV9TRUxFQ1RPUjtcbiAgICBjb25zdCBtZXRyaWNDb3VudCA9IG1ldHJpY3M/LnZhbHVlcz8ubGVuZ3RoIHx8IDA7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy53cmFwcGVyfT5cbiAgICAgICAgPEhvcml6b250YWxHcm91cCBhbGlnbj1cImZsZXgtc3RhcnRcIiBzcGFjaW5nPVwibGdcIj5cbiAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5zZWN0aW9ufT5cbiAgICAgICAgICAgICAgPExhYmVsIGRlc2NyaXB0aW9uPVwiT25jZSBhIG1ldHJpYyBpcyBzZWxlY3RlZCBvbmx5IHBvc3NpYmxlIGxhYmVscyBhcmUgc2hvd24uXCI+MS4gU2VsZWN0IGEgbWV0cmljPC9MYWJlbD5cbiAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICA8SW5wdXRcbiAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLm9uQ2hhbmdlTWV0cmljU2VhcmNofVxuICAgICAgICAgICAgICAgICAgYXJpYS1sYWJlbD1cIkZpbHRlciBleHByZXNzaW9uIGZvciBtZXRyaWNcIlxuICAgICAgICAgICAgICAgICAgdmFsdWU9e21ldHJpY1NlYXJjaFRlcm19XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDxkaXYgcm9sZT1cImxpc3RcIiBjbGFzc05hbWU9e3N0eWxlcy52YWx1ZUxpc3RXcmFwcGVyfT5cbiAgICAgICAgICAgICAgICA8Rml4ZWRTaXplTGlzdFxuICAgICAgICAgICAgICAgICAgaGVpZ2h0PXtNYXRoLm1pbig0NTAsIG1ldHJpY0NvdW50ICogTElTVF9JVEVNX1NJWkUpfVxuICAgICAgICAgICAgICAgICAgaXRlbUNvdW50PXttZXRyaWNDb3VudH1cbiAgICAgICAgICAgICAgICAgIGl0ZW1TaXplPXtMSVNUX0lURU1fU0laRX1cbiAgICAgICAgICAgICAgICAgIGl0ZW1LZXk9eyhpKSA9PiAobWV0cmljcyEudmFsdWVzIGFzIEZhY2V0dGFibGVWYWx1ZVtdKVtpXS5uYW1lfVxuICAgICAgICAgICAgICAgICAgd2lkdGg9ezMwMH1cbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLnZhbHVlTGlzdH1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICB7KHsgaW5kZXgsIHN0eWxlIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBtZXRyaWNzPy52YWx1ZXM/LltpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9e3N0eWxlfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxQcm9tTGFiZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT17bWV0cmljcyEubmFtZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3ZhbHVlPy5uYW1lfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZT17dmFsdWUuZGV0YWlsc31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlPXt2YWx1ZT8uc2VsZWN0ZWR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMub25DbGlja01ldHJpY31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoVGVybT17bWV0cmljU2VhcmNoVGVybX1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIDwvRml4ZWRTaXplTGlzdD5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnNlY3Rpb259PlxuICAgICAgICAgICAgICA8TGFiZWwgZGVzY3JpcHRpb249XCJPbmNlIGxhYmVsIHZhbHVlcyBhcmUgc2VsZWN0ZWQsIG9ubHkgcG9zc2libGUgbGFiZWwgY29tYmluYXRpb25zIGFyZSBzaG93bi5cIj5cbiAgICAgICAgICAgICAgICAyLiBTZWxlY3QgbGFiZWxzIHRvIHNlYXJjaCBpblxuICAgICAgICAgICAgICA8L0xhYmVsPlxuICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgIDxJbnB1dFxuICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMub25DaGFuZ2VMYWJlbFNlYXJjaH1cbiAgICAgICAgICAgICAgICAgIGFyaWEtbGFiZWw9XCJGaWx0ZXIgZXhwcmVzc2lvbiBmb3IgbGFiZWxcIlxuICAgICAgICAgICAgICAgICAgdmFsdWU9e2xhYmVsU2VhcmNoVGVybX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgey8qIFVzaW5nIGZpeGVkIGhlaWdodCBoZXJlIHRvIHByZXZlbnQganVtcHkgbGF5b3V0ICovfVxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmxpc3R9IHN0eWxlPXt7IGhlaWdodDogMTIwIH19PlxuICAgICAgICAgICAgICAgIHtub25NZXRyaWNMYWJlbHMubWFwKChsYWJlbCkgPT4gKFxuICAgICAgICAgICAgICAgICAgPFByb21MYWJlbFxuICAgICAgICAgICAgICAgICAgICBrZXk9e2xhYmVsLm5hbWV9XG4gICAgICAgICAgICAgICAgICAgIG5hbWU9e2xhYmVsLm5hbWV9XG4gICAgICAgICAgICAgICAgICAgIGxvYWRpbmc9e2xhYmVsLmxvYWRpbmd9XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZT17bGFiZWwuc2VsZWN0ZWR9XG4gICAgICAgICAgICAgICAgICAgIGhpZGRlbj17bGFiZWwuaGlkZGVufVxuICAgICAgICAgICAgICAgICAgICBmYWNldHM9e2xhYmVsLmZhY2V0c31cbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17dGhpcy5vbkNsaWNrTGFiZWx9XG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaFRlcm09e2xhYmVsU2VhcmNoVGVybX1cbiAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnNlY3Rpb259PlxuICAgICAgICAgICAgICA8TGFiZWwgZGVzY3JpcHRpb249XCJVc2UgdGhlIHNlYXJjaCBmaWVsZCB0byBmaW5kIHZhbHVlcyBhY3Jvc3Mgc2VsZWN0ZWQgbGFiZWxzLlwiPlxuICAgICAgICAgICAgICAgIDMuIFNlbGVjdCAobXVsdGlwbGUpIHZhbHVlcyBmb3IgeW91ciBsYWJlbHNcbiAgICAgICAgICAgICAgPC9MYWJlbD5cbiAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICA8SW5wdXRcbiAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLm9uQ2hhbmdlVmFsdWVTZWFyY2h9XG4gICAgICAgICAgICAgICAgICBhcmlhLWxhYmVsPVwiRmlsdGVyIGV4cHJlc3Npb24gZm9yIGxhYmVsIHZhbHVlc1wiXG4gICAgICAgICAgICAgICAgICB2YWx1ZT17dmFsdWVTZWFyY2hUZXJtfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnZhbHVlTGlzdEFyZWF9IHJlZj17dGhpcy52YWx1ZUxpc3RzUmVmfT5cbiAgICAgICAgICAgICAgICB7c2VsZWN0ZWRMYWJlbHMubWFwKChsYWJlbCkgPT4gKFxuICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICByb2xlPVwibGlzdFwiXG4gICAgICAgICAgICAgICAgICAgIGtleT17bGFiZWwubmFtZX1cbiAgICAgICAgICAgICAgICAgICAgYXJpYS1sYWJlbD17YFZhbHVlcyBmb3IgJHtsYWJlbC5uYW1lfWB9XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLnZhbHVlTGlzdFdyYXBwZXJ9XG4gICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMudmFsdWVUaXRsZX0+XG4gICAgICAgICAgICAgICAgICAgICAgPFByb21MYWJlbFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT17bGFiZWwubmFtZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRpbmc9e2xhYmVsLmxvYWRpbmd9XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmU9e2xhYmVsLnNlbGVjdGVkfVxuICAgICAgICAgICAgICAgICAgICAgICAgaGlkZGVuPXtsYWJlbC5oaWRkZW59XG4gICAgICAgICAgICAgICAgICAgICAgICAvL0lmIG5vIGZhY2V0cywgd2Ugd2FudCB0byBzaG93IG51bWJlciBvZiBhbGwgbGFiZWwgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWNldHM9e2xhYmVsLmZhY2V0cyB8fCBsYWJlbC52YWx1ZXM/Lmxlbmd0aH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMub25DbGlja0xhYmVsfVxuICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8Rml4ZWRTaXplTGlzdFxuICAgICAgICAgICAgICAgICAgICAgIGhlaWdodD17TWF0aC5taW4oMjAwLCBMSVNUX0lURU1fU0laRSAqIChsYWJlbC52YWx1ZXM/Lmxlbmd0aCB8fCAwKSl9XG4gICAgICAgICAgICAgICAgICAgICAgaXRlbUNvdW50PXtsYWJlbC52YWx1ZXM/Lmxlbmd0aCB8fCAwfVxuICAgICAgICAgICAgICAgICAgICAgIGl0ZW1TaXplPXsyOH1cbiAgICAgICAgICAgICAgICAgICAgICBpdGVtS2V5PXsoaSkgPT4gKGxhYmVsLnZhbHVlcyBhcyBGYWNldHRhYmxlVmFsdWVbXSlbaV0ubmFtZX1cbiAgICAgICAgICAgICAgICAgICAgICB3aWR0aD17MjAwfVxuICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLnZhbHVlTGlzdH1cbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgIHsoeyBpbmRleCwgc3R5bGUgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBsYWJlbC52YWx1ZXM/LltpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT17c3R5bGV9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxQcm9tTGFiZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9e2xhYmVsLm5hbWV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17dmFsdWU/Lm5hbWV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmU9e3ZhbHVlPy5zZWxlY3RlZH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMub25DbGlja1ZhbHVlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoVGVybT17dmFsdWVTZWFyY2hUZXJtfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICA8L0ZpeGVkU2l6ZUxpc3Q+XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9Ib3Jpem9udGFsR3JvdXA+XG5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5zZWN0aW9ufT5cbiAgICAgICAgICA8TGFiZWw+NC4gUmVzdWx0aW5nIHNlbGVjdG9yPC9MYWJlbD5cbiAgICAgICAgICA8ZGl2IGFyaWEtbGFiZWw9XCJzZWxlY3RvclwiIGNsYXNzTmFtZT17c3R5bGVzLnNlbGVjdG9yfT5cbiAgICAgICAgICAgIHtzZWxlY3Rvcn1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICB7dmFsaWRhdGlvblN0YXR1cyAmJiA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnZhbGlkYXRpb25TdGF0dXN9Pnt2YWxpZGF0aW9uU3RhdHVzfTwvZGl2Pn1cbiAgICAgICAgICA8SG9yaXpvbnRhbEdyb3VwPlxuICAgICAgICAgICAgPEJ1dHRvbiBhcmlhLWxhYmVsPVwiVXNlIHNlbGVjdG9yIGZvciBxdWVyeSBidXR0b25cIiBkaXNhYmxlZD17ZW1wdHl9IG9uQ2xpY2s9e3RoaXMub25DbGlja1J1blF1ZXJ5fT5cbiAgICAgICAgICAgICAgVXNlIHF1ZXJ5XG4gICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICAgIDxCdXR0b25cbiAgICAgICAgICAgICAgYXJpYS1sYWJlbD1cIlVzZSBzZWxlY3RvciBhcyBtZXRyaWNzIGJ1dHRvblwiXG4gICAgICAgICAgICAgIHZhcmlhbnQ9XCJzZWNvbmRhcnlcIlxuICAgICAgICAgICAgICBkaXNhYmxlZD17ZW1wdHl9XG4gICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMub25DbGlja1J1blJhdGVRdWVyeX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgVXNlIGFzIHJhdGUgcXVlcnlcbiAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgICBhcmlhLWxhYmVsPVwiVmFsaWRhdGUgc3VibWl0IGJ1dHRvblwiXG4gICAgICAgICAgICAgIHZhcmlhbnQ9XCJzZWNvbmRhcnlcIlxuICAgICAgICAgICAgICBkaXNhYmxlZD17ZW1wdHl9XG4gICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMub25DbGlja1ZhbGlkYXRlfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICBWYWxpZGF0ZSBzZWxlY3RvclxuICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICA8QnV0dG9uIGFyaWEtbGFiZWw9XCJTZWxlY3RvciBjbGVhciBidXR0b25cIiB2YXJpYW50PVwic2Vjb25kYXJ5XCIgb25DbGljaz17dGhpcy5vbkNsaWNrQ2xlYXJ9PlxuICAgICAgICAgICAgICBDbGVhclxuICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3goc3R5bGVzLnN0YXR1cywgKHN0YXR1cyB8fCBlcnJvcikgJiYgc3R5bGVzLnN0YXR1c1Nob3dpbmcpfT5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtlcnJvciA/IHN0eWxlcy5lcnJvciA6ICcnfT57ZXJyb3IgfHwgc3RhdHVzfTwvc3Bhbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvSG9yaXpvbnRhbEdyb3VwPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IFByb21ldGhldXNNZXRyaWNzQnJvd3NlciA9IHdpdGhUaGVtZShVbnRoZW1lZFByb21ldGhldXNNZXRyaWNzQnJvd3Nlcik7XG4iLCJpbXBvcnQgUmVhY3QsIHsgU3VzcGVuc2UgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IFByb3BzIH0gZnJvbSAnLi9Nb25hY29RdWVyeUZpZWxkUHJvcHMnO1xuXG5jb25zdCBGaWVsZCA9IFJlYWN0LmxhenkoKCkgPT4gaW1wb3J0KC8qIHdlYnBhY2tDaHVua05hbWU6IFwicHJvbS1xdWVyeS1maWVsZFwiICovICcuL01vbmFjb1F1ZXJ5RmllbGQnKSk7XG5cbmV4cG9ydCBjb25zdCBNb25hY29RdWVyeUZpZWxkTGF6eSA9IChwcm9wczogUHJvcHMpID0+IHtcbiAgcmV0dXJuIChcbiAgICA8U3VzcGVuc2UgZmFsbGJhY2s9e251bGx9PlxuICAgICAgPEZpZWxkIHsuLi5wcm9wc30gLz5cbiAgICA8L1N1c3BlbnNlPlxuICApO1xufTtcbiIsImltcG9ydCBSZWFjdCwgeyB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IE1vbmFjb1F1ZXJ5RmllbGRMYXp5IH0gZnJvbSAnLi9Nb25hY29RdWVyeUZpZWxkTGF6eSc7XG5pbXBvcnQgeyBQcm9wcyBhcyBNb25hY29Qcm9wcyB9IGZyb20gJy4vTW9uYWNvUXVlcnlGaWVsZFByb3BzJztcblxudHlwZSBQcm9wcyA9IE9taXQ8TW9uYWNvUHJvcHMsICdvblJ1blF1ZXJ5JyB8ICdvbkJsdXInPiAmIHtcbiAgb25DaGFuZ2U6IChxdWVyeTogc3RyaW5nKSA9PiB2b2lkO1xuICBvblJ1blF1ZXJ5OiAoKSA9PiB2b2lkO1xuICBydW5RdWVyeU9uQmx1cjogYm9vbGVhbjtcbn07XG5cbmV4cG9ydCBjb25zdCBNb25hY29RdWVyeUZpZWxkV3JhcHBlciA9IChwcm9wczogUHJvcHMpID0+IHtcbiAgY29uc3QgbGFzdFJ1blZhbHVlUmVmID0gdXNlUmVmPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICBjb25zdCB7IHJ1blF1ZXJ5T25CbHVyLCBvblJ1blF1ZXJ5LCBvbkNoYW5nZSwgLi4ucmVzdCB9ID0gcHJvcHM7XG5cbiAgY29uc3QgaGFuZGxlUnVuUXVlcnkgPSAodmFsdWU6IHN0cmluZykgPT4ge1xuICAgIGxhc3RSdW5WYWx1ZVJlZi5jdXJyZW50ID0gdmFsdWU7XG4gICAgb25DaGFuZ2UodmFsdWUpO1xuICAgIG9uUnVuUXVlcnkoKTtcbiAgfTtcblxuICBjb25zdCBoYW5kbGVCbHVyID0gKHZhbHVlOiBzdHJpbmcpID0+IHtcbiAgICBpZiAocnVuUXVlcnlPbkJsdXIpIHtcbiAgICAgIC8vIHJ1biBoYW5kbGVSdW5RdWVyeSBvbmx5IGlmIHRoZSBjdXJyZW50IHZhbHVlIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBsYXN0LXRpbWUtZXhlY3V0ZWQgdmFsdWVcbiAgICAgIGlmICh2YWx1ZSAhPT0gbGFzdFJ1blZhbHVlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgaGFuZGxlUnVuUXVlcnkodmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvbkNoYW5nZSh2YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiA8TW9uYWNvUXVlcnlGaWVsZExhenkgb25SdW5RdWVyeT17aGFuZGxlUnVuUXVlcnl9IG9uQmx1cj17aGFuZGxlQmx1cn0gey4uLnJlc3R9IC8+O1xufTtcbiIsImltcG9ydCBSZWFjdCwgeyBGdW5jdGlvbkNvbXBvbmVudCwgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgY29uZmlnIH0gZnJvbSAnQGdyYWZhbmEvcnVudGltZSc7XG5pbXBvcnQgeyBJbmxpbmVGb3JtTGFiZWwsIElucHV0IH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuaW1wb3J0IHsgSHR0cFNldHRpbmdzQmFzZVByb3BzIH0gZnJvbSAnQGdyYWZhbmEvdWkvc3JjL2NvbXBvbmVudHMvRGF0YVNvdXJjZVNldHRpbmdzL3R5cGVzJztcblxuaW1wb3J0IHsgS25vd25BenVyZUNsb3VkcywgQXp1cmVDcmVkZW50aWFscyB9IGZyb20gJy4vQXp1cmVDcmVkZW50aWFscyc7XG5pbXBvcnQgeyBnZXRDcmVkZW50aWFscywgdXBkYXRlQ3JlZGVudGlhbHMgfSBmcm9tICcuL0F6dXJlQ3JlZGVudGlhbHNDb25maWcnO1xuaW1wb3J0IHsgQXp1cmVDcmVkZW50aWFsc0Zvcm0gfSBmcm9tICcuL0F6dXJlQ3JlZGVudGlhbHNGb3JtJztcblxuZXhwb3J0IGNvbnN0IEF6dXJlQXV0aFNldHRpbmdzOiBGdW5jdGlvbkNvbXBvbmVudDxIdHRwU2V0dGluZ3NCYXNlUHJvcHM+ID0gKHByb3BzOiBIdHRwU2V0dGluZ3NCYXNlUHJvcHMpID0+IHtcbiAgY29uc3QgeyBkYXRhU291cmNlQ29uZmlnLCBvbkNoYW5nZSB9ID0gcHJvcHM7XG5cbiAgY29uc3QgY3JlZGVudGlhbHMgPSB1c2VNZW1vKCgpID0+IGdldENyZWRlbnRpYWxzKGRhdGFTb3VyY2VDb25maWcpLCBbZGF0YVNvdXJjZUNvbmZpZ10pO1xuXG4gIGNvbnN0IG9uQ3JlZGVudGlhbHNDaGFuZ2UgPSAoY3JlZGVudGlhbHM6IEF6dXJlQ3JlZGVudGlhbHMpOiB2b2lkID0+IHtcbiAgICBvbkNoYW5nZSh1cGRhdGVDcmVkZW50aWFscyhkYXRhU291cmNlQ29uZmlnLCBjcmVkZW50aWFscykpO1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxoNj5BenVyZSBBdXRoZW50aWNhdGlvbjwvaDY+XG4gICAgICA8QXp1cmVDcmVkZW50aWFsc0Zvcm1cbiAgICAgICAgbWFuYWdlZElkZW50aXR5RW5hYmxlZD17Y29uZmlnLmF6dXJlLm1hbmFnZWRJZGVudGl0eUVuYWJsZWR9XG4gICAgICAgIGNyZWRlbnRpYWxzPXtjcmVkZW50aWFsc31cbiAgICAgICAgYXp1cmVDbG91ZE9wdGlvbnM9e0tub3duQXp1cmVDbG91ZHN9XG4gICAgICAgIG9uQ3JlZGVudGlhbHNDaGFuZ2U9e29uQ3JlZGVudGlhbHNDaGFuZ2V9XG4gICAgICAvPlxuICAgICAgPGg2PkF6dXJlIENvbmZpZ3VyYXRpb248L2g2PlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtLWdyb3VwXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybS1pbmxpbmVcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm1cIj5cbiAgICAgICAgICAgIDxJbmxpbmVGb3JtTGFiZWwgY2xhc3NOYW1lPVwid2lkdGgtMTJcIj5BQUQgcmVzb3VyY2UgSUQ8L0lubGluZUZvcm1MYWJlbD5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwid2lkdGgtMTVcIj5cbiAgICAgICAgICAgICAgPElucHV0XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwid2lkdGgtMzBcIlxuICAgICAgICAgICAgICAgIHZhbHVlPXtkYXRhU291cmNlQ29uZmlnLmpzb25EYXRhLmF6dXJlRW5kcG9pbnRSZXNvdXJjZUlkIHx8ICcnfVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZXZlbnQpID0+XG4gICAgICAgICAgICAgICAgICBvbkNoYW5nZSh7XG4gICAgICAgICAgICAgICAgICAgIC4uLmRhdGFTb3VyY2VDb25maWcsXG4gICAgICAgICAgICAgICAgICAgIGpzb25EYXRhOiB7IC4uLmRhdGFTb3VyY2VDb25maWcuanNvbkRhdGEsIGF6dXJlRW5kcG9pbnRSZXNvdXJjZUlkOiBldmVudC5jdXJyZW50VGFyZ2V0LnZhbHVlIH0sXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvPlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQXp1cmVBdXRoU2V0dGluZ3M7XG4iLCJpbXBvcnQgeyBTZWxlY3RhYmxlVmFsdWUgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcblxuZXhwb3J0IGVudW0gQXp1cmVDbG91ZCB7XG4gIFB1YmxpYyA9ICdBenVyZUNsb3VkJyxcbiAgQ2hpbmEgPSAnQXp1cmVDaGluYUNsb3VkJyxcbiAgVVNHb3Zlcm5tZW50ID0gJ0F6dXJlVVNHb3Zlcm5tZW50JyxcbiAgR2VybWFueSA9ICdBenVyZUdlcm1hbkNsb3VkJyxcbiAgTm9uZSA9ICcnLFxufVxuXG5leHBvcnQgY29uc3QgS25vd25BenVyZUNsb3VkcyA9IFtcbiAgeyB2YWx1ZTogQXp1cmVDbG91ZC5QdWJsaWMsIGxhYmVsOiAnQXp1cmUnIH0sXG4gIHsgdmFsdWU6IEF6dXJlQ2xvdWQuQ2hpbmEsIGxhYmVsOiAnQXp1cmUgQ2hpbmEnIH0sXG4gIHsgdmFsdWU6IEF6dXJlQ2xvdWQuVVNHb3Zlcm5tZW50LCBsYWJlbDogJ0F6dXJlIFVTIEdvdmVybm1lbnQnIH0sXG4gIHsgdmFsdWU6IEF6dXJlQ2xvdWQuR2VybWFueSwgbGFiZWw6ICdBenVyZSBHZXJtYW55JyB9LFxuXSBhcyBTZWxlY3RhYmxlVmFsdWVbXTtcblxuZXhwb3J0IHR5cGUgQXp1cmVBdXRoVHlwZSA9ICdtc2knIHwgJ2NsaWVudHNlY3JldCc7XG5cbmV4cG9ydCB0eXBlIENvbmNlYWxlZFNlY3JldCA9IHN5bWJvbDtcblxuaW50ZXJmYWNlIEF6dXJlQ3JlZGVudGlhbHNCYXNlIHtcbiAgYXV0aFR5cGU6IEF6dXJlQXV0aFR5cGU7XG4gIGRlZmF1bHRTdWJzY3JpcHRpb25JZD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBenVyZU1hbmFnZWRJZGVudGl0eUNyZWRlbnRpYWxzIGV4dGVuZHMgQXp1cmVDcmVkZW50aWFsc0Jhc2Uge1xuICBhdXRoVHlwZTogJ21zaSc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXp1cmVDbGllbnRTZWNyZXRDcmVkZW50aWFscyBleHRlbmRzIEF6dXJlQ3JlZGVudGlhbHNCYXNlIHtcbiAgYXV0aFR5cGU6ICdjbGllbnRzZWNyZXQnO1xuICBhenVyZUNsb3VkPzogc3RyaW5nO1xuICB0ZW5hbnRJZD86IHN0cmluZztcbiAgY2xpZW50SWQ/OiBzdHJpbmc7XG4gIGNsaWVudFNlY3JldD86IHN0cmluZyB8IENvbmNlYWxlZFNlY3JldDtcbn1cblxuZXhwb3J0IHR5cGUgQXp1cmVDcmVkZW50aWFscyA9IEF6dXJlTWFuYWdlZElkZW50aXR5Q3JlZGVudGlhbHMgfCBBenVyZUNsaWVudFNlY3JldENyZWRlbnRpYWxzO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNDcmVkZW50aWFsc0NvbXBsZXRlKGNyZWRlbnRpYWxzOiBBenVyZUNyZWRlbnRpYWxzKTogYm9vbGVhbiB7XG4gIHN3aXRjaCAoY3JlZGVudGlhbHMuYXV0aFR5cGUpIHtcbiAgICBjYXNlICdtc2knOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSAnY2xpZW50c2VjcmV0JzpcbiAgICAgIHJldHVybiAhIShjcmVkZW50aWFscy5henVyZUNsb3VkICYmIGNyZWRlbnRpYWxzLnRlbmFudElkICYmIGNyZWRlbnRpYWxzLmNsaWVudElkICYmIGNyZWRlbnRpYWxzLmNsaWVudFNlY3JldCk7XG4gIH1cbn1cbiIsImltcG9ydCB7IERhdGFTb3VyY2VTZXR0aW5ncyB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgY29uZmlnIH0gZnJvbSAnQGdyYWZhbmEvcnVudGltZSc7XG5cbmltcG9ydCB7IEF6dXJlQ2xvdWQsIEF6dXJlQ3JlZGVudGlhbHMsIENvbmNlYWxlZFNlY3JldCB9IGZyb20gJy4vQXp1cmVDcmVkZW50aWFscyc7XG5cbmNvbnN0IGNvbmNlYWxlZDogQ29uY2VhbGVkU2VjcmV0ID0gU3ltYm9sKCdDb25jZWFsZWQgY2xpZW50IHNlY3JldCcpO1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0QXp1cmVDbG91ZCgpOiBzdHJpbmcge1xuICByZXR1cm4gY29uZmlnLmF6dXJlLmNsb3VkIHx8IEF6dXJlQ2xvdWQuUHVibGljO1xufVxuXG5mdW5jdGlvbiBnZXRTZWNyZXQob3B0aW9uczogRGF0YVNvdXJjZVNldHRpbmdzPGFueSwgYW55Pik6IHVuZGVmaW5lZCB8IHN0cmluZyB8IENvbmNlYWxlZFNlY3JldCB7XG4gIGlmIChvcHRpb25zLnNlY3VyZUpzb25GaWVsZHMuYXp1cmVDbGllbnRTZWNyZXQpIHtcbiAgICAvLyBUaGUgc2VjcmV0IGlzIGNvbmNlYWxlZCBvbiBzZXJ2ZXJcbiAgICByZXR1cm4gY29uY2VhbGVkO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHNlY3JldCA9IG9wdGlvbnMuc2VjdXJlSnNvbkRhdGE/LmF6dXJlQ2xpZW50U2VjcmV0O1xuICAgIHJldHVybiB0eXBlb2Ygc2VjcmV0ID09PSAnc3RyaW5nJyAmJiBzZWNyZXQubGVuZ3RoID4gMCA/IHNlY3JldCA6IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzQ3JlZGVudGlhbHMob3B0aW9uczogRGF0YVNvdXJjZVNldHRpbmdzPGFueSwgYW55Pik6IGJvb2xlYW4ge1xuICByZXR1cm4gISFvcHRpb25zLmpzb25EYXRhLmF6dXJlQ3JlZGVudGlhbHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0Q3JlZGVudGlhbHMoKTogQXp1cmVDcmVkZW50aWFscyB7XG4gIGlmIChjb25maWcuYXp1cmUubWFuYWdlZElkZW50aXR5RW5hYmxlZCkge1xuICAgIHJldHVybiB7IGF1dGhUeXBlOiAnbXNpJyB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IGF1dGhUeXBlOiAnY2xpZW50c2VjcmV0JywgYXp1cmVDbG91ZDogZ2V0RGVmYXVsdEF6dXJlQ2xvdWQoKSB9O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDcmVkZW50aWFscyhvcHRpb25zOiBEYXRhU291cmNlU2V0dGluZ3M8YW55LCBhbnk+KTogQXp1cmVDcmVkZW50aWFscyB7XG4gIGNvbnN0IGNyZWRlbnRpYWxzID0gb3B0aW9ucy5qc29uRGF0YS5henVyZUNyZWRlbnRpYWxzIGFzIEF6dXJlQ3JlZGVudGlhbHMgfCB1bmRlZmluZWQ7XG5cbiAgLy8gSWYgbm8gY3JlZGVudGlhbHMgc2F2ZWQsIHRoZW4gcmV0dXJuIGVtcHR5IGNyZWRlbnRpYWxzXG4gIC8vIG9mIHR5cGUgYmFzZWQgb24gd2hldGhlciB0aGUgbWFuYWdlZCBpZGVudGl0eSBlbmFibGVkXG4gIGlmICghY3JlZGVudGlhbHMpIHtcbiAgICByZXR1cm4gZ2V0RGVmYXVsdENyZWRlbnRpYWxzKCk7XG4gIH1cblxuICBzd2l0Y2ggKGNyZWRlbnRpYWxzLmF1dGhUeXBlKSB7XG4gICAgY2FzZSAnbXNpJzpcbiAgICAgIGlmIChjb25maWcuYXp1cmUubWFuYWdlZElkZW50aXR5RW5hYmxlZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGF1dGhUeXBlOiAnbXNpJyxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIGF1dGhlbnRpY2F0aW9uIHR5cGUgaXMgbWFuYWdlZCBpZGVudGl0eSBidXQgbWFuYWdlZCBpZGVudGl0aWVzIHdlcmUgZGlzYWJsZWQgaW4gR3JhZmFuYSBjb25maWcsXG4gICAgICAgIC8vIHRoZW4gd2Ugc2hvdWxkIGZhbGxiYWNrIHRvIGFuIGVtcHR5IGFwcCByZWdpc3RyYXRpb24gKGNsaWVudCBzZWNyZXQpIGNvbmZpZ3VyYXRpb25cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhdXRoVHlwZTogJ2NsaWVudHNlY3JldCcsXG4gICAgICAgICAgYXp1cmVDbG91ZDogZ2V0RGVmYXVsdEF6dXJlQ2xvdWQoKSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICBjYXNlICdjbGllbnRzZWNyZXQnOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aFR5cGU6ICdjbGllbnRzZWNyZXQnLFxuICAgICAgICBhenVyZUNsb3VkOiBjcmVkZW50aWFscy5henVyZUNsb3VkIHx8IGdldERlZmF1bHRBenVyZUNsb3VkKCksXG4gICAgICAgIHRlbmFudElkOiBjcmVkZW50aWFscy50ZW5hbnRJZCxcbiAgICAgICAgY2xpZW50SWQ6IGNyZWRlbnRpYWxzLmNsaWVudElkLFxuICAgICAgICBjbGllbnRTZWNyZXQ6IGdldFNlY3JldChvcHRpb25zKSxcbiAgICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUNyZWRlbnRpYWxzKFxuICBvcHRpb25zOiBEYXRhU291cmNlU2V0dGluZ3M8YW55LCBhbnk+LFxuICBjcmVkZW50aWFsczogQXp1cmVDcmVkZW50aWFsc1xuKTogRGF0YVNvdXJjZVNldHRpbmdzPGFueSwgYW55PiB7XG4gIHN3aXRjaCAoY3JlZGVudGlhbHMuYXV0aFR5cGUpIHtcbiAgICBjYXNlICdtc2knOlxuICAgICAgaWYgKCFjb25maWcuYXp1cmUubWFuYWdlZElkZW50aXR5RW5hYmxlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbmFnZWQgSWRlbnRpdHkgYXV0aGVudGljYXRpb24gaXMgbm90IGVuYWJsZWQgaW4gR3JhZmFuYSBjb25maWcuJyk7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGpzb25EYXRhOiB7XG4gICAgICAgICAgLi4ub3B0aW9ucy5qc29uRGF0YSxcbiAgICAgICAgICBhenVyZUNyZWRlbnRpYWxzOiB7XG4gICAgICAgICAgICBhdXRoVHlwZTogJ21zaScsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBvcHRpb25zO1xuXG4gICAgY2FzZSAnY2xpZW50c2VjcmV0JzpcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGpzb25EYXRhOiB7XG4gICAgICAgICAgLi4ub3B0aW9ucy5qc29uRGF0YSxcbiAgICAgICAgICBhenVyZUNyZWRlbnRpYWxzOiB7XG4gICAgICAgICAgICBhdXRoVHlwZTogJ2NsaWVudHNlY3JldCcsXG4gICAgICAgICAgICBhenVyZUNsb3VkOiBjcmVkZW50aWFscy5henVyZUNsb3VkIHx8IGdldERlZmF1bHRBenVyZUNsb3VkKCksXG4gICAgICAgICAgICB0ZW5hbnRJZDogY3JlZGVudGlhbHMudGVuYW50SWQsXG4gICAgICAgICAgICBjbGllbnRJZDogY3JlZGVudGlhbHMuY2xpZW50SWQsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgc2VjdXJlSnNvbkRhdGE6IHtcbiAgICAgICAgICAuLi5vcHRpb25zLnNlY3VyZUpzb25EYXRhLFxuICAgICAgICAgIGF6dXJlQ2xpZW50U2VjcmV0OlxuICAgICAgICAgICAgdHlwZW9mIGNyZWRlbnRpYWxzLmNsaWVudFNlY3JldCA9PT0gJ3N0cmluZycgJiYgY3JlZGVudGlhbHMuY2xpZW50U2VjcmV0Lmxlbmd0aCA+IDBcbiAgICAgICAgICAgICAgPyBjcmVkZW50aWFscy5jbGllbnRTZWNyZXRcbiAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH0sXG4gICAgICAgIHNlY3VyZUpzb25GaWVsZHM6IHtcbiAgICAgICAgICAuLi5vcHRpb25zLnNlY3VyZUpzb25GaWVsZHMsXG4gICAgICAgICAgYXp1cmVDbGllbnRTZWNyZXQ6IHR5cGVvZiBjcmVkZW50aWFscy5jbGllbnRTZWNyZXQgPT09ICdzeW1ib2wnLFxuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldERlZmF1bHRDcmVkZW50aWFscyhvcHRpb25zOiBEYXRhU291cmNlU2V0dGluZ3M8YW55LCBhbnk+KTogUGFydGlhbDxEYXRhU291cmNlU2V0dGluZ3M8YW55LCBhbnk+PiB7XG4gIHJldHVybiB7XG4gICAganNvbkRhdGE6IHtcbiAgICAgIC4uLm9wdGlvbnMuanNvbkRhdGEsXG4gICAgICBhenVyZUNyZWRlbnRpYWxzOiBnZXREZWZhdWx0Q3JlZGVudGlhbHMoKSxcbiAgICB9LFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzZXRDcmVkZW50aWFscyhvcHRpb25zOiBEYXRhU291cmNlU2V0dGluZ3M8YW55LCBhbnk+KTogUGFydGlhbDxEYXRhU291cmNlU2V0dGluZ3M8YW55LCBhbnk+PiB7XG4gIHJldHVybiB7XG4gICAganNvbkRhdGE6IHtcbiAgICAgIC4uLm9wdGlvbnMuanNvbkRhdGEsXG4gICAgICBhenVyZUF1dGg6IHVuZGVmaW5lZCxcbiAgICAgIGF6dXJlQ3JlZGVudGlhbHM6IHVuZGVmaW5lZCxcbiAgICAgIGF6dXJlRW5kcG9pbnRSZXNvdXJjZUlkOiB1bmRlZmluZWQsXG4gICAgfSxcbiAgfTtcbn1cbiIsImltcG9ydCBSZWFjdCwgeyBDaGFuZ2VFdmVudCwgRnVuY3Rpb25Db21wb25lbnQsIHVzZUVmZmVjdCwgdXNlUmVkdWNlciwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IFNlbGVjdGFibGVWYWx1ZSB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgSW5saW5lRm9ybUxhYmVsLCBCdXR0b24gfSBmcm9tICdAZ3JhZmFuYS91aS9zcmMvY29tcG9uZW50cyc7XG5pbXBvcnQgeyBJbnB1dCB9IGZyb20gJ0BncmFmYW5hL3VpL3NyYy9jb21wb25lbnRzL0Zvcm1zL0xlZ2FjeS9JbnB1dC9JbnB1dCc7XG5pbXBvcnQgeyBTZWxlY3QgfSBmcm9tICdAZ3JhZmFuYS91aS9zcmMvY29tcG9uZW50cy9Gb3Jtcy9MZWdhY3kvU2VsZWN0L1NlbGVjdCc7XG5cbmltcG9ydCB7IEF6dXJlQXV0aFR5cGUsIEF6dXJlQ3JlZGVudGlhbHMsIGlzQ3JlZGVudGlhbHNDb21wbGV0ZSB9IGZyb20gJy4vQXp1cmVDcmVkZW50aWFscyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICBtYW5hZ2VkSWRlbnRpdHlFbmFibGVkOiBib29sZWFuO1xuICBjcmVkZW50aWFsczogQXp1cmVDcmVkZW50aWFscztcbiAgYXp1cmVDbG91ZE9wdGlvbnM/OiBTZWxlY3RhYmxlVmFsdWVbXTtcbiAgb25DcmVkZW50aWFsc0NoYW5nZTogKHVwZGF0ZWRDcmVkZW50aWFsczogQXp1cmVDcmVkZW50aWFscykgPT4gdm9pZDtcbiAgZ2V0U3Vic2NyaXB0aW9ucz86ICgpID0+IFByb21pc2U8U2VsZWN0YWJsZVZhbHVlW10+O1xufVxuXG5jb25zdCBhdXRoVHlwZU9wdGlvbnM6IEFycmF5PFNlbGVjdGFibGVWYWx1ZTxBenVyZUF1dGhUeXBlPj4gPSBbXG4gIHtcbiAgICB2YWx1ZTogJ21zaScsXG4gICAgbGFiZWw6ICdNYW5hZ2VkIElkZW50aXR5JyxcbiAgfSxcbiAge1xuICAgIHZhbHVlOiAnY2xpZW50c2VjcmV0JyxcbiAgICBsYWJlbDogJ0FwcCBSZWdpc3RyYXRpb24nLFxuICB9LFxuXTtcblxuZXhwb3J0IGNvbnN0IEF6dXJlQ3JlZGVudGlhbHNGb3JtOiBGdW5jdGlvbkNvbXBvbmVudDxQcm9wcz4gPSAocHJvcHM6IFByb3BzKSA9PiB7XG4gIGNvbnN0IHsgY3JlZGVudGlhbHMsIGF6dXJlQ2xvdWRPcHRpb25zLCBvbkNyZWRlbnRpYWxzQ2hhbmdlLCBnZXRTdWJzY3JpcHRpb25zIH0gPSBwcm9wcztcbiAgY29uc3QgaGFzUmVxdWlyZWRGaWVsZHMgPSBpc0NyZWRlbnRpYWxzQ29tcGxldGUoY3JlZGVudGlhbHMpO1xuXG4gIGNvbnN0IFtzdWJzY3JpcHRpb25zLCBzZXRTdWJzY3JpcHRpb25zXSA9IHVzZVN0YXRlPEFycmF5PFNlbGVjdGFibGVWYWx1ZTxzdHJpbmc+Pj4oW10pO1xuICBjb25zdCBbbG9hZFN1YnNjcmlwdGlvbnNDbGlja2VkLCBvbkxvYWRTdWJzY3JpcHRpb25zXSA9IHVzZVJlZHVjZXIoKHZhbCkgPT4gdmFsICsgMSwgMCk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFnZXRTdWJzY3JpcHRpb25zIHx8ICFoYXNSZXF1aXJlZEZpZWxkcykge1xuICAgICAgdXBkYXRlU3Vic2NyaXB0aW9ucyhbXSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBjYW5jZWxlZCA9IGZhbHNlO1xuICAgIGdldFN1YnNjcmlwdGlvbnMoKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgIGlmICghY2FuY2VsZWQpIHtcbiAgICAgICAgdXBkYXRlU3Vic2NyaXB0aW9ucyhyZXN1bHQsIGxvYWRTdWJzY3JpcHRpb25zQ2xpY2tlZCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNhbmNlbGVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIC8vIFRoaXMgZWZmZWN0IGlzIGludGVuZGVkIHRvIGJlIGNhbGxlZCBvbmx5IG9uY2UgaW5pdGlhbGx5IGFuZCBvbiBMb2FkIFN1YnNjcmlwdGlvbnMgY2xpY2tcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtsb2FkU3Vic2NyaXB0aW9uc0NsaWNrZWRdKTtcblxuICBjb25zdCB1cGRhdGVTdWJzY3JpcHRpb25zID0gKHJlY2VpdmVkOiBBcnJheTxTZWxlY3RhYmxlVmFsdWU8c3RyaW5nPj4sIGF1dG9TZWxlY3QgPSBmYWxzZSkgPT4ge1xuICAgIHNldFN1YnNjcmlwdGlvbnMocmVjZWl2ZWQpO1xuICAgIGlmIChnZXRTdWJzY3JpcHRpb25zKSB7XG4gICAgICBpZiAoYXV0b1NlbGVjdCAmJiAhY3JlZGVudGlhbHMuZGVmYXVsdFN1YnNjcmlwdGlvbklkICYmIHJlY2VpdmVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gU2VsZWN0aW5nIHRoZSBkZWZhdWx0IHN1YnNjcmlwdGlvbiBpZiBzdWJzY3JpcHRpb25zIHJlY2VpdmVkIGJ1dCBubyBkZWZhdWx0IHN1YnNjcmlwdGlvbiBzZWxlY3RlZFxuICAgICAgICBvblN1YnNjcmlwdGlvbkNoYW5nZShyZWNlaXZlZFswXSk7XG4gICAgICB9IGVsc2UgaWYgKGNyZWRlbnRpYWxzLmRlZmF1bHRTdWJzY3JpcHRpb25JZCkge1xuICAgICAgICBjb25zdCBmb3VuZCA9IHJlY2VpdmVkLmZpbmQoKG9wdCkgPT4gb3B0LnZhbHVlID09PSBjcmVkZW50aWFscy5kZWZhdWx0U3Vic2NyaXB0aW9uSWQpO1xuICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgLy8gVW5zZWxlY3RpbmcgdGhlIGRlZmF1bHQgc3Vic2NyaXB0aW9uIGlmIGl0IGlzbid0IGZvdW5kIGFtb25nIHRoZSByZWNlaXZlZCBzdWJzY3JpcHRpb25zXG4gICAgICAgICAgb25TdWJzY3JpcHRpb25DaGFuZ2UodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBjb25zdCBvbkF1dGhUeXBlQ2hhbmdlID0gKHNlbGVjdGVkOiBTZWxlY3RhYmxlVmFsdWU8QXp1cmVBdXRoVHlwZT4pID0+IHtcbiAgICBpZiAob25DcmVkZW50aWFsc0NoYW5nZSkge1xuICAgICAgc2V0U3Vic2NyaXB0aW9ucyhbXSk7XG4gICAgICBjb25zdCB1cGRhdGVkOiBBenVyZUNyZWRlbnRpYWxzID0ge1xuICAgICAgICAuLi5jcmVkZW50aWFscyxcbiAgICAgICAgYXV0aFR5cGU6IHNlbGVjdGVkLnZhbHVlIHx8ICdtc2knLFxuICAgICAgICBkZWZhdWx0U3Vic2NyaXB0aW9uSWQ6IHVuZGVmaW5lZCxcbiAgICAgIH07XG4gICAgICBvbkNyZWRlbnRpYWxzQ2hhbmdlKHVwZGF0ZWQpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBvbkF6dXJlQ2xvdWRDaGFuZ2UgPSAoc2VsZWN0ZWQ6IFNlbGVjdGFibGVWYWx1ZTxzdHJpbmc+KSA9PiB7XG4gICAgaWYgKG9uQ3JlZGVudGlhbHNDaGFuZ2UgJiYgY3JlZGVudGlhbHMuYXV0aFR5cGUgPT09ICdjbGllbnRzZWNyZXQnKSB7XG4gICAgICBzZXRTdWJzY3JpcHRpb25zKFtdKTtcbiAgICAgIGNvbnN0IHVwZGF0ZWQ6IEF6dXJlQ3JlZGVudGlhbHMgPSB7XG4gICAgICAgIC4uLmNyZWRlbnRpYWxzLFxuICAgICAgICBhenVyZUNsb3VkOiBzZWxlY3RlZC52YWx1ZSxcbiAgICAgICAgZGVmYXVsdFN1YnNjcmlwdGlvbklkOiB1bmRlZmluZWQsXG4gICAgICB9O1xuICAgICAgb25DcmVkZW50aWFsc0NoYW5nZSh1cGRhdGVkKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgb25UZW5hbnRJZENoYW5nZSA9IChldmVudDogQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcbiAgICBpZiAob25DcmVkZW50aWFsc0NoYW5nZSAmJiBjcmVkZW50aWFscy5hdXRoVHlwZSA9PT0gJ2NsaWVudHNlY3JldCcpIHtcbiAgICAgIHNldFN1YnNjcmlwdGlvbnMoW10pO1xuICAgICAgY29uc3QgdXBkYXRlZDogQXp1cmVDcmVkZW50aWFscyA9IHtcbiAgICAgICAgLi4uY3JlZGVudGlhbHMsXG4gICAgICAgIHRlbmFudElkOiBldmVudC50YXJnZXQudmFsdWUsXG4gICAgICAgIGRlZmF1bHRTdWJzY3JpcHRpb25JZDogdW5kZWZpbmVkLFxuICAgICAgfTtcbiAgICAgIG9uQ3JlZGVudGlhbHNDaGFuZ2UodXBkYXRlZCk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IG9uQ2xpZW50SWRDaGFuZ2UgPSAoZXZlbnQ6IENoYW5nZUV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgaWYgKG9uQ3JlZGVudGlhbHNDaGFuZ2UgJiYgY3JlZGVudGlhbHMuYXV0aFR5cGUgPT09ICdjbGllbnRzZWNyZXQnKSB7XG4gICAgICBzZXRTdWJzY3JpcHRpb25zKFtdKTtcbiAgICAgIGNvbnN0IHVwZGF0ZWQ6IEF6dXJlQ3JlZGVudGlhbHMgPSB7XG4gICAgICAgIC4uLmNyZWRlbnRpYWxzLFxuICAgICAgICBjbGllbnRJZDogZXZlbnQudGFyZ2V0LnZhbHVlLFxuICAgICAgICBkZWZhdWx0U3Vic2NyaXB0aW9uSWQ6IHVuZGVmaW5lZCxcbiAgICAgIH07XG4gICAgICBvbkNyZWRlbnRpYWxzQ2hhbmdlKHVwZGF0ZWQpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBvbkNsaWVudFNlY3JldENoYW5nZSA9IChldmVudDogQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcbiAgICBpZiAob25DcmVkZW50aWFsc0NoYW5nZSAmJiBjcmVkZW50aWFscy5hdXRoVHlwZSA9PT0gJ2NsaWVudHNlY3JldCcpIHtcbiAgICAgIHNldFN1YnNjcmlwdGlvbnMoW10pO1xuICAgICAgY29uc3QgdXBkYXRlZDogQXp1cmVDcmVkZW50aWFscyA9IHtcbiAgICAgICAgLi4uY3JlZGVudGlhbHMsXG4gICAgICAgIGNsaWVudFNlY3JldDogZXZlbnQudGFyZ2V0LnZhbHVlLFxuICAgICAgICBkZWZhdWx0U3Vic2NyaXB0aW9uSWQ6IHVuZGVmaW5lZCxcbiAgICAgIH07XG4gICAgICBvbkNyZWRlbnRpYWxzQ2hhbmdlKHVwZGF0ZWQpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBvbkNsaWVudFNlY3JldFJlc2V0ID0gKCkgPT4ge1xuICAgIGlmIChvbkNyZWRlbnRpYWxzQ2hhbmdlICYmIGNyZWRlbnRpYWxzLmF1dGhUeXBlID09PSAnY2xpZW50c2VjcmV0Jykge1xuICAgICAgc2V0U3Vic2NyaXB0aW9ucyhbXSk7XG4gICAgICBjb25zdCB1cGRhdGVkOiBBenVyZUNyZWRlbnRpYWxzID0ge1xuICAgICAgICAuLi5jcmVkZW50aWFscyxcbiAgICAgICAgY2xpZW50U2VjcmV0OiAnJyxcbiAgICAgICAgZGVmYXVsdFN1YnNjcmlwdGlvbklkOiB1bmRlZmluZWQsXG4gICAgICB9O1xuICAgICAgb25DcmVkZW50aWFsc0NoYW5nZSh1cGRhdGVkKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgb25TdWJzY3JpcHRpb25DaGFuZ2UgPSAoc2VsZWN0ZWQ6IFNlbGVjdGFibGVWYWx1ZTxzdHJpbmc+IHwgdW5kZWZpbmVkKSA9PiB7XG4gICAgaWYgKG9uQ3JlZGVudGlhbHNDaGFuZ2UpIHtcbiAgICAgIGNvbnN0IHVwZGF0ZWQ6IEF6dXJlQ3JlZGVudGlhbHMgPSB7XG4gICAgICAgIC4uLmNyZWRlbnRpYWxzLFxuICAgICAgICBkZWZhdWx0U3Vic2NyaXB0aW9uSWQ6IHNlbGVjdGVkPy52YWx1ZSxcbiAgICAgIH07XG4gICAgICBvbkNyZWRlbnRpYWxzQ2hhbmdlKHVwZGF0ZWQpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybS1ncm91cFwiPlxuICAgICAge3Byb3BzLm1hbmFnZWRJZGVudGl0eUVuYWJsZWQgJiYgKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm0taW5saW5lXCI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtXCI+XG4gICAgICAgICAgICA8SW5saW5lRm9ybUxhYmVsIGNsYXNzTmFtZT1cIndpZHRoLTEyXCIgdG9vbHRpcD1cIkNob29zZSB0aGUgdHlwZSBvZiBhdXRoZW50aWNhdGlvbiB0byBBenVyZSBzZXJ2aWNlc1wiPlxuICAgICAgICAgICAgICBBdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgPC9JbmxpbmVGb3JtTGFiZWw+XG4gICAgICAgICAgICA8U2VsZWN0XG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cIndpZHRoLTE1XCJcbiAgICAgICAgICAgICAgdmFsdWU9e2F1dGhUeXBlT3B0aW9ucy5maW5kKChvcHQpID0+IG9wdC52YWx1ZSA9PT0gY3JlZGVudGlhbHMuYXV0aFR5cGUpfVxuICAgICAgICAgICAgICBvcHRpb25zPXthdXRoVHlwZU9wdGlvbnN9XG4gICAgICAgICAgICAgIG9uQ2hhbmdlPXtvbkF1dGhUeXBlQ2hhbmdlfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuICAgICAge2NyZWRlbnRpYWxzLmF1dGhUeXBlID09PSAnY2xpZW50c2VjcmV0JyAmJiAoXG4gICAgICAgIDw+XG4gICAgICAgICAge2F6dXJlQ2xvdWRPcHRpb25zICYmIChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybS1pbmxpbmVcIj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtXCI+XG4gICAgICAgICAgICAgICAgPElubGluZUZvcm1MYWJlbCBjbGFzc05hbWU9XCJ3aWR0aC0xMlwiIHRvb2x0aXA9XCJDaG9vc2UgYW4gQXp1cmUgQ2xvdWRcIj5cbiAgICAgICAgICAgICAgICAgIEF6dXJlIENsb3VkXG4gICAgICAgICAgICAgICAgPC9JbmxpbmVGb3JtTGFiZWw+XG4gICAgICAgICAgICAgICAgPFNlbGVjdFxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwid2lkdGgtMTVcIlxuICAgICAgICAgICAgICAgICAgdmFsdWU9e2F6dXJlQ2xvdWRPcHRpb25zLmZpbmQoKG9wdCkgPT4gb3B0LnZhbHVlID09PSBjcmVkZW50aWFscy5henVyZUNsb3VkKX1cbiAgICAgICAgICAgICAgICAgIG9wdGlvbnM9e2F6dXJlQ2xvdWRPcHRpb25zfVxuICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e29uQXp1cmVDbG91ZENoYW5nZX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICl9XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtLWlubGluZVwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtXCI+XG4gICAgICAgICAgICAgIDxJbmxpbmVGb3JtTGFiZWwgY2xhc3NOYW1lPVwid2lkdGgtMTJcIj5EaXJlY3RvcnkgKHRlbmFudCkgSUQ8L0lubGluZUZvcm1MYWJlbD5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3aWR0aC0xNVwiPlxuICAgICAgICAgICAgICAgIDxJbnB1dFxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwid2lkdGgtMzBcIlxuICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcIlxuICAgICAgICAgICAgICAgICAgdmFsdWU9e2NyZWRlbnRpYWxzLnRlbmFudElkIHx8ICcnfVxuICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e29uVGVuYW50SWRDaGFuZ2V9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm0taW5saW5lXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm1cIj5cbiAgICAgICAgICAgICAgPElubGluZUZvcm1MYWJlbCBjbGFzc05hbWU9XCJ3aWR0aC0xMlwiPkFwcGxpY2F0aW9uIChjbGllbnQpIElEPC9JbmxpbmVGb3JtTGFiZWw+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwid2lkdGgtMTVcIj5cbiAgICAgICAgICAgICAgICA8SW5wdXRcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIndpZHRoLTMwXCJcbiAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiWFhYWFhYWFgtWFhYWC1YWFhYLVhYWFgtWFhYWFhYWFhYWFhYXCJcbiAgICAgICAgICAgICAgICAgIHZhbHVlPXtjcmVkZW50aWFscy5jbGllbnRJZCB8fCAnJ31cbiAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtvbkNsaWVudElkQ2hhbmdlfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAge3R5cGVvZiBjcmVkZW50aWFscy5jbGllbnRTZWNyZXQgPT09ICdzeW1ib2wnID8gKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtLWlubGluZVwiPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm1cIj5cbiAgICAgICAgICAgICAgICA8SW5saW5lRm9ybUxhYmVsIGNsYXNzTmFtZT1cIndpZHRoLTEyXCI+Q2xpZW50IFNlY3JldDwvSW5saW5lRm9ybUxhYmVsPlxuICAgICAgICAgICAgICAgIDxJbnB1dCBjbGFzc05hbWU9XCJ3aWR0aC0yNVwiIHBsYWNlaG9sZGVyPVwiY29uZmlndXJlZFwiIGRpc2FibGVkPXt0cnVlfSAvPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYXgtd2lkdGgtMzAgZ2YtZm9ybS1pbmxpbmVcIj5cbiAgICAgICAgICAgICAgICAgIDxCdXR0b24gdmFyaWFudD1cInNlY29uZGFyeVwiIHR5cGU9XCJidXR0b25cIiBvbkNsaWNrPXtvbkNsaWVudFNlY3JldFJlc2V0fT5cbiAgICAgICAgICAgICAgICAgICAgcmVzZXRcbiAgICAgICAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm0taW5saW5lXCI+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybVwiPlxuICAgICAgICAgICAgICAgIDxJbmxpbmVGb3JtTGFiZWwgY2xhc3NOYW1lPVwid2lkdGgtMTJcIj5DbGllbnQgU2VjcmV0PC9JbmxpbmVGb3JtTGFiZWw+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3aWR0aC0xNVwiPlxuICAgICAgICAgICAgICAgICAgPElucHV0XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIndpZHRoLTMwXCJcbiAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcIlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZT17Y3JlZGVudGlhbHMuY2xpZW50U2VjcmV0IHx8ICcnfVxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17b25DbGllbnRTZWNyZXRDaGFuZ2V9XG4gICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICl9XG4gICAgICAgIDwvPlxuICAgICAgKX1cbiAgICAgIHtnZXRTdWJzY3JpcHRpb25zICYmIChcbiAgICAgICAgPD5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm0taW5saW5lXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm1cIj5cbiAgICAgICAgICAgICAgPElubGluZUZvcm1MYWJlbCBjbGFzc05hbWU9XCJ3aWR0aC0xMlwiPkRlZmF1bHQgU3Vic2NyaXB0aW9uPC9JbmxpbmVGb3JtTGFiZWw+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwid2lkdGgtMjVcIj5cbiAgICAgICAgICAgICAgICA8U2VsZWN0XG4gICAgICAgICAgICAgICAgICB2YWx1ZT17XG4gICAgICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxzLmRlZmF1bHRTdWJzY3JpcHRpb25JZFxuICAgICAgICAgICAgICAgICAgICAgID8gc3Vic2NyaXB0aW9ucy5maW5kKChvcHQpID0+IG9wdC52YWx1ZSA9PT0gY3JlZGVudGlhbHMuZGVmYXVsdFN1YnNjcmlwdGlvbklkKVxuICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBvcHRpb25zPXtzdWJzY3JpcHRpb25zfVxuICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e29uU3Vic2NyaXB0aW9uQ2hhbmdlfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtLWlubGluZVwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtXCI+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibWF4LXdpZHRoLTMwIGdmLWZvcm0taW5saW5lXCI+XG4gICAgICAgICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgICAgICAgdmFyaWFudD1cInNlY29uZGFyeVwiXG4gICAgICAgICAgICAgICAgICBzaXplPVwic21cIlxuICAgICAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgICBvbkNsaWNrPXtvbkxvYWRTdWJzY3JpcHRpb25zfVxuICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9eyFoYXNSZXF1aXJlZEZpZWxkc31cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICBMb2FkIFN1YnNjcmlwdGlvbnNcbiAgICAgICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC8+XG4gICAgICApfVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQXp1cmVDcmVkZW50aWFsc0Zvcm07XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBEYXRhU291cmNlUGx1Z2luT3B0aW9uc0VkaXRvclByb3BzLCBEYXRhU291cmNlU2V0dGluZ3MgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IEFsZXJ0aW5nU2V0dGluZ3MsIERhdGFTb3VyY2VIdHRwU2V0dGluZ3MsIEFsZXJ0IH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuaW1wb3J0IHsgY29uZmlnIH0gZnJvbSAnYXBwL2NvcmUvY29uZmlnJztcbmltcG9ydCB7IGdldEFsbEFsZXJ0bWFuYWdlckRhdGFTb3VyY2VzIH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2FsZXJ0aW5nL3VuaWZpZWQvdXRpbHMvYWxlcnRtYW5hZ2VyJztcblxuaW1wb3J0IHsgUHJvbU9wdGlvbnMgfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IEF6dXJlQXV0aFNldHRpbmdzIH0gZnJvbSAnLi9BenVyZUF1dGhTZXR0aW5ncyc7XG5pbXBvcnQgeyBoYXNDcmVkZW50aWFscywgc2V0RGVmYXVsdENyZWRlbnRpYWxzLCByZXNldENyZWRlbnRpYWxzIH0gZnJvbSAnLi9BenVyZUNyZWRlbnRpYWxzQ29uZmlnJztcbmltcG9ydCB7IFByb21TZXR0aW5ncyB9IGZyb20gJy4vUHJvbVNldHRpbmdzJztcblxuZXhwb3J0IHR5cGUgUHJvcHMgPSBEYXRhU291cmNlUGx1Z2luT3B0aW9uc0VkaXRvclByb3BzPFByb21PcHRpb25zPjtcbmV4cG9ydCBjb25zdCBDb25maWdFZGl0b3IgPSAocHJvcHM6IFByb3BzKSA9PiB7XG4gIGNvbnN0IHsgb3B0aW9ucywgb25PcHRpb25zQ2hhbmdlIH0gPSBwcm9wcztcbiAgY29uc3QgYWxlcnRtYW5hZ2VycyA9IGdldEFsbEFsZXJ0bWFuYWdlckRhdGFTb3VyY2VzKCk7XG5cbiAgY29uc3QgYXp1cmVBdXRoU2V0dGluZ3MgPSB7XG4gICAgYXp1cmVBdXRoU3VwcG9ydGVkOiBjb25maWcuZmVhdHVyZVRvZ2dsZXNbJ3Byb21ldGhldXNfYXp1cmVfYXV0aCddID8/IGZhbHNlLFxuICAgIGdldEF6dXJlQXV0aEVuYWJsZWQ6IChjb25maWc6IERhdGFTb3VyY2VTZXR0aW5nczxhbnksIGFueT4pOiBib29sZWFuID0+IGhhc0NyZWRlbnRpYWxzKGNvbmZpZyksXG4gICAgc2V0QXp1cmVBdXRoRW5hYmxlZDogKGNvbmZpZzogRGF0YVNvdXJjZVNldHRpbmdzPGFueSwgYW55PiwgZW5hYmxlZDogYm9vbGVhbikgPT5cbiAgICAgIGVuYWJsZWQgPyBzZXREZWZhdWx0Q3JlZGVudGlhbHMoY29uZmlnKSA6IHJlc2V0Q3JlZGVudGlhbHMoY29uZmlnKSxcbiAgICBhenVyZVNldHRpbmdzVUk6IEF6dXJlQXV0aFNldHRpbmdzLFxuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIHtvcHRpb25zLmFjY2VzcyA9PT0gJ2RpcmVjdCcgJiYgKFxuICAgICAgICA8QWxlcnQgdGl0bGU9XCJEZXByZWNhdGlvbiBOb3RpY2VcIiBzZXZlcml0eT1cIndhcm5pbmdcIj5cbiAgICAgICAgICBCcm93c2VyIGFjY2VzcyBtb2RlIGluIHRoZSBQcm9tZXRoZXVzIGRhdGFzb3VyY2UgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHJlbGVhc2UuXG4gICAgICAgIDwvQWxlcnQ+XG4gICAgICApfVxuXG4gICAgICA8RGF0YVNvdXJjZUh0dHBTZXR0aW5nc1xuICAgICAgICBkZWZhdWx0VXJsPVwiaHR0cDovL2xvY2FsaG9zdDo5MDkwXCJcbiAgICAgICAgZGF0YVNvdXJjZUNvbmZpZz17b3B0aW9uc31cbiAgICAgICAgc2hvd0FjY2Vzc09wdGlvbnM9e3RydWV9XG4gICAgICAgIG9uQ2hhbmdlPXtvbk9wdGlvbnNDaGFuZ2V9XG4gICAgICAgIHNpZ1Y0QXV0aFRvZ2dsZUVuYWJsZWQ9e2NvbmZpZy5zaWdWNEF1dGhFbmFibGVkfVxuICAgICAgICBhenVyZUF1dGhTZXR0aW5ncz17YXp1cmVBdXRoU2V0dGluZ3N9XG4gICAgICAvPlxuXG4gICAgICA8QWxlcnRpbmdTZXR0aW5nczxQcm9tT3B0aW9ucz5cbiAgICAgICAgYWxlcnRtYW5hZ2VyRGF0YVNvdXJjZXM9e2FsZXJ0bWFuYWdlcnN9XG4gICAgICAgIG9wdGlvbnM9e29wdGlvbnN9XG4gICAgICAgIG9uT3B0aW9uc0NoYW5nZT17b25PcHRpb25zQ2hhbmdlfVxuICAgICAgLz5cblxuICAgICAgPFByb21TZXR0aW5ncyBvcHRpb25zPXtvcHRpb25zfSBvbk9wdGlvbnNDaGFuZ2U9e29uT3B0aW9uc0NoYW5nZX0gLz5cbiAgICA8Lz5cbiAgKTtcbn07XG4iLCJpbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBzZWxlY3RvcnMgfSBmcm9tICdAZ3JhZmFuYS9lMmUtc2VsZWN0b3JzJztcbmltcG9ydCB7IERhdGFTb3VyY2VQaWNrZXIgfSBmcm9tICdAZ3JhZmFuYS9ydW50aW1lJztcbmltcG9ydCB7IEJ1dHRvbiwgSW5saW5lRmllbGQsIElubGluZVN3aXRjaCwgSW5wdXQgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5cbmltcG9ydCB7IEV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG50eXBlIFByb3BzID0ge1xuICB2YWx1ZTogRXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb247XG4gIG9uQ2hhbmdlOiAodmFsdWU6IEV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uKSA9PiB2b2lkO1xuICBvbkRlbGV0ZTogKCkgPT4gdm9pZDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEV4ZW1wbGFyU2V0dGluZyh7IHZhbHVlLCBvbkNoYW5nZSwgb25EZWxldGUgfTogUHJvcHMpIHtcbiAgY29uc3QgW2lzSW50ZXJuYWxMaW5rLCBzZXRJc0ludGVybmFsTGlua10gPSB1c2VTdGF0ZShCb29sZWFuKHZhbHVlLmRhdGFzb3VyY2VVaWQpKTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybS1ncm91cFwiPlxuICAgICAgPElubGluZUZpZWxkIGxhYmVsPVwiSW50ZXJuYWwgbGlua1wiIGxhYmVsV2lkdGg9ezI0fT5cbiAgICAgICAgPD5cbiAgICAgICAgICA8SW5saW5lU3dpdGNoXG4gICAgICAgICAgICB2YWx1ZT17aXNJbnRlcm5hbExpbmt9XG4gICAgICAgICAgICBhcmlhLWxhYmVsPXtzZWxlY3RvcnMuY29tcG9uZW50cy5EYXRhU291cmNlLlByb21ldGhldXMuY29uZmlnUGFnZS5pbnRlcm5hbExpbmtTd2l0Y2h9XG4gICAgICAgICAgICBvbkNoYW5nZT17KGV2KSA9PiBzZXRJc0ludGVybmFsTGluayhldi5jdXJyZW50VGFyZ2V0LmNoZWNrZWQpfVxuICAgICAgICAgIC8+XG4gICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgdmFyaWFudD1cImRlc3RydWN0aXZlXCJcbiAgICAgICAgICAgIHRpdGxlPVwiUmVtb3ZlIGxpbmtcIlxuICAgICAgICAgICAgaWNvbj1cInRpbWVzXCJcbiAgICAgICAgICAgIG9uQ2xpY2s9eyhldmVudCkgPT4ge1xuICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICBvbkRlbGV0ZSgpO1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzYFxuICAgICAgICAgICAgICBtYXJnaW4tbGVmdDogOHB4O1xuICAgICAgICAgICAgYH1cbiAgICAgICAgICAvPlxuICAgICAgICA8Lz5cbiAgICAgIDwvSW5saW5lRmllbGQ+XG5cbiAgICAgIHtpc0ludGVybmFsTGluayA/IChcbiAgICAgICAgPElubGluZUZpZWxkXG4gICAgICAgICAgbGFiZWw9XCJEYXRhIHNvdXJjZVwiXG4gICAgICAgICAgbGFiZWxXaWR0aD17MjR9XG4gICAgICAgICAgdG9vbHRpcD1cIlRoZSBkYXRhIHNvdXJjZSB0aGUgZXhlbXBsYXIgaXMgZ29pbmcgdG8gbmF2aWdhdGUgdG8uXCJcbiAgICAgICAgPlxuICAgICAgICAgIDxEYXRhU291cmNlUGlja2VyXG4gICAgICAgICAgICB0cmFjaW5nPXt0cnVlfVxuICAgICAgICAgICAgY3VycmVudD17dmFsdWUuZGF0YXNvdXJjZVVpZH1cbiAgICAgICAgICAgIG5vRGVmYXVsdD17dHJ1ZX1cbiAgICAgICAgICAgIHdpZHRoPXs0MH1cbiAgICAgICAgICAgIG9uQ2hhbmdlPXsoZHMpID0+XG4gICAgICAgICAgICAgIG9uQ2hhbmdlKHtcbiAgICAgICAgICAgICAgICAuLi52YWx1ZSxcbiAgICAgICAgICAgICAgICBkYXRhc291cmNlVWlkOiBkcy51aWQsXG4gICAgICAgICAgICAgICAgdXJsOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9JbmxpbmVGaWVsZD5cbiAgICAgICkgOiAoXG4gICAgICAgIDxJbmxpbmVGaWVsZFxuICAgICAgICAgIGxhYmVsPVwiVVJMXCJcbiAgICAgICAgICBsYWJlbFdpZHRoPXsyNH1cbiAgICAgICAgICB0b29sdGlwPVwiVGhlIFVSTCBvZiB0aGUgdHJhY2UgYmFja2VuZCB0aGUgdXNlciB3b3VsZCBnbyB0byBzZWUgaXRzIHRyYWNlLlwiXG4gICAgICAgID5cbiAgICAgICAgICA8SW5wdXRcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiaHR0cHM6Ly9leGFtcGxlLmNvbS8ke19fdmFsdWUucmF3fVwiXG4gICAgICAgICAgICBzcGVsbENoZWNrPXtmYWxzZX1cbiAgICAgICAgICAgIHdpZHRoPXs0MH1cbiAgICAgICAgICAgIHZhbHVlPXt2YWx1ZS51cmx9XG4gICAgICAgICAgICBvbkNoYW5nZT17KGV2ZW50KSA9PlxuICAgICAgICAgICAgICBvbkNoYW5nZSh7XG4gICAgICAgICAgICAgICAgLi4udmFsdWUsXG4gICAgICAgICAgICAgICAgZGF0YXNvdXJjZVVpZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHVybDogZXZlbnQuY3VycmVudFRhcmdldC52YWx1ZSxcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAvPlxuICAgICAgICA8L0lubGluZUZpZWxkPlxuICAgICAgKX1cblxuICAgICAgPElubGluZUZpZWxkXG4gICAgICAgIGxhYmVsPVwiVVJMIExhYmVsXCJcbiAgICAgICAgbGFiZWxXaWR0aD17MjR9XG4gICAgICAgIHRvb2x0aXA9XCJVc2UgdG8gb3ZlcnJpZGUgdGhlIGJ1dHRvbiBsYWJlbCBvbiB0aGUgZXhlbXBsYXIgdHJhY2VJRCBmaWVsZC5cIlxuICAgICAgPlxuICAgICAgICA8SW5wdXRcbiAgICAgICAgICBwbGFjZWhvbGRlcj1cIkdvIHRvIGV4YW1wbGUuY29tXCJcbiAgICAgICAgICBzcGVsbENoZWNrPXtmYWxzZX1cbiAgICAgICAgICB3aWR0aD17NDB9XG4gICAgICAgICAgdmFsdWU9e3ZhbHVlLnVybERpc3BsYXlMYWJlbH1cbiAgICAgICAgICBvbkNoYW5nZT17KGV2ZW50KSA9PlxuICAgICAgICAgICAgb25DaGFuZ2Uoe1xuICAgICAgICAgICAgICAuLi52YWx1ZSxcbiAgICAgICAgICAgICAgdXJsRGlzcGxheUxhYmVsOiBldmVudC5jdXJyZW50VGFyZ2V0LnZhbHVlLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIC8+XG4gICAgICA8L0lubGluZUZpZWxkPlxuICAgICAgPElubGluZUZpZWxkXG4gICAgICAgIGxhYmVsPVwiTGFiZWwgbmFtZVwiXG4gICAgICAgIGxhYmVsV2lkdGg9ezI0fVxuICAgICAgICB0b29sdGlwPVwiVGhlIG5hbWUgb2YgdGhlIGZpZWxkIGluIHRoZSBsYWJlbHMgb2JqZWN0IHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gZ2V0IHRoZSB0cmFjZUlELlwiXG4gICAgICA+XG4gICAgICAgIDxJbnB1dFxuICAgICAgICAgIHBsYWNlaG9sZGVyPVwidHJhY2VJRFwiXG4gICAgICAgICAgc3BlbGxDaGVjaz17ZmFsc2V9XG4gICAgICAgICAgd2lkdGg9ezQwfVxuICAgICAgICAgIHZhbHVlPXt2YWx1ZS5uYW1lfVxuICAgICAgICAgIG9uQ2hhbmdlPXsoZXZlbnQpID0+XG4gICAgICAgICAgICBvbkNoYW5nZSh7XG4gICAgICAgICAgICAgIC4uLnZhbHVlLFxuICAgICAgICAgICAgICBuYW1lOiBldmVudC5jdXJyZW50VGFyZ2V0LnZhbHVlLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIC8+XG4gICAgICA8L0lubGluZUZpZWxkPlxuICAgIDwvZGl2PlxuICApO1xufVxuIiwiaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IHNlbGVjdG9ycyB9IGZyb20gJ0BncmFmYW5hL2UyZS1zZWxlY3RvcnMnO1xuaW1wb3J0IHsgQnV0dG9uIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5pbXBvcnQgeyBFeGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbiB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IEV4ZW1wbGFyU2V0dGluZyBmcm9tICcuL0V4ZW1wbGFyU2V0dGluZyc7XG5cbnR5cGUgUHJvcHMgPSB7XG4gIG9wdGlvbnM/OiBFeGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbltdO1xuICBvbkNoYW5nZTogKHZhbHVlOiBFeGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbltdKSA9PiB2b2lkO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIEV4ZW1wbGFyc1NldHRpbmdzKHsgb3B0aW9ucywgb25DaGFuZ2UgfTogUHJvcHMpIHtcbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPGgzIGNsYXNzTmFtZT1cInBhZ2UtaGVhZGluZ1wiPkV4ZW1wbGFyczwvaDM+XG5cbiAgICAgIHtvcHRpb25zICYmXG4gICAgICAgIG9wdGlvbnMubWFwKChvcHRpb24sIGluZGV4KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxFeGVtcGxhclNldHRpbmdcbiAgICAgICAgICAgICAga2V5PXtpbmRleH1cbiAgICAgICAgICAgICAgdmFsdWU9e29wdGlvbn1cbiAgICAgICAgICAgICAgb25DaGFuZ2U9eyhuZXdGaWVsZCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld09wdGlvbnMgPSBbLi4ub3B0aW9uc107XG4gICAgICAgICAgICAgICAgbmV3T3B0aW9ucy5zcGxpY2UoaW5kZXgsIDEsIG5ld0ZpZWxkKTtcbiAgICAgICAgICAgICAgICBvbkNoYW5nZShuZXdPcHRpb25zKTtcbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgb25EZWxldGU9eygpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdPcHRpb25zID0gWy4uLm9wdGlvbnNdO1xuICAgICAgICAgICAgICAgIG5ld09wdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICBvbkNoYW5nZShuZXdPcHRpb25zKTtcbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgKTtcbiAgICAgICAgfSl9XG5cbiAgICAgIDxCdXR0b25cbiAgICAgICAgdmFyaWFudD1cInNlY29uZGFyeVwiXG4gICAgICAgIGFyaWEtbGFiZWw9e3NlbGVjdG9ycy5jb21wb25lbnRzLkRhdGFTb3VyY2UuUHJvbWV0aGV1cy5jb25maWdQYWdlLmV4ZW1wbGFyc0FkZEJ1dHRvbn1cbiAgICAgICAgY2xhc3NOYW1lPXtjc3NgXG4gICAgICAgICAgbWFyZ2luLWJvdHRvbTogMTBweDtcbiAgICAgICAgYH1cbiAgICAgICAgaWNvbj1cInBsdXNcIlxuICAgICAgICBvbkNsaWNrPXsoZXZlbnQpID0+IHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGNvbnN0IG5ld09wdGlvbnMgPSBbLi4uKG9wdGlvbnMgfHwgW10pLCB7IG5hbWU6ICd0cmFjZUlEJyB9XTtcbiAgICAgICAgICBvbkNoYW5nZShuZXdPcHRpb25zKTtcbiAgICAgICAgfX1cbiAgICAgID5cbiAgICAgICAgQWRkXG4gICAgICA8L0J1dHRvbj5cbiAgICA8Lz5cbiAgKTtcbn1cbiIsImltcG9ydCBSZWFjdCwgeyBTeW50aGV0aWNFdmVudCB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHtcbiAgRGF0YVNvdXJjZVBsdWdpbk9wdGlvbnNFZGl0b3JQcm9wcyxcbiAgb25VcGRhdGVEYXRhc291cmNlSnNvbkRhdGFPcHRpb25DaGVja2VkLFxuICBTZWxlY3RhYmxlVmFsdWUsXG4gIHVwZGF0ZURhdGFzb3VyY2VQbHVnaW5Kc29uRGF0YU9wdGlvbixcbn0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQge1xuICBJbmxpbmVGaWVsZCxcbiAgSW5saW5lU3dpdGNoLFxuICBFdmVudHNXaXRoVmFsaWRhdGlvbixcbiAgSW5saW5lRm9ybUxhYmVsLFxuICBMZWdhY3lGb3JtcyxcbiAgcmVnZXhWYWxpZGF0aW9uLFxufSBmcm9tICdAZ3JhZmFuYS91aSc7XG5cbmltcG9ydCB7IFByb21PcHRpb25zIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBFeGVtcGxhcnNTZXR0aW5ncyB9IGZyb20gJy4vRXhlbXBsYXJzU2V0dGluZ3MnO1xuY29uc3QgeyBTZWxlY3QsIElucHV0LCBGb3JtRmllbGQgfSA9IExlZ2FjeUZvcm1zO1xuXG5jb25zdCBodHRwT3B0aW9ucyA9IFtcbiAgeyB2YWx1ZTogJ1BPU1QnLCBsYWJlbDogJ1BPU1QnIH0sXG4gIHsgdmFsdWU6ICdHRVQnLCBsYWJlbDogJ0dFVCcgfSxcbl07XG5cbnR5cGUgUHJvcHMgPSBQaWNrPERhdGFTb3VyY2VQbHVnaW5PcHRpb25zRWRpdG9yUHJvcHM8UHJvbU9wdGlvbnM+LCAnb3B0aW9ucycgfCAnb25PcHRpb25zQ2hhbmdlJz47XG5cbmV4cG9ydCBjb25zdCBQcm9tU2V0dGluZ3MgPSAocHJvcHM6IFByb3BzKSA9PiB7XG4gIGNvbnN0IHsgb3B0aW9ucywgb25PcHRpb25zQ2hhbmdlIH0gPSBwcm9wcztcblxuICAvLyBXZSBhcmUgZXhwbGljaXRseSBhZGRpbmcgaHR0cE1ldGhvZCBzbyBpdCBpcyBjb3JyZWN0bHkgZGlzcGxheWVkIGluIGRyb3Bkb3duLiBUaGlzIHdheSwgaXQgaXMgbW9yZSBwcmVkaWN0YWJsZSBmb3IgdXNlcnMuXG5cbiAgaWYgKCFvcHRpb25zLmpzb25EYXRhLmh0dHBNZXRob2QpIHtcbiAgICBvcHRpb25zLmpzb25EYXRhLmh0dHBNZXRob2QgPSAnUE9TVCc7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm0tZ3JvdXBcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtLWlubGluZVwiPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybVwiPlxuICAgICAgICAgICAgPEZvcm1GaWVsZFxuICAgICAgICAgICAgICBsYWJlbD1cIlNjcmFwZSBpbnRlcnZhbFwiXG4gICAgICAgICAgICAgIGxhYmVsV2lkdGg9ezEzfVxuICAgICAgICAgICAgICBpbnB1dEVsPXtcbiAgICAgICAgICAgICAgICA8SW5wdXRcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIndpZHRoLTZcIlxuICAgICAgICAgICAgICAgICAgdmFsdWU9e29wdGlvbnMuanNvbkRhdGEudGltZUludGVydmFsfVxuICAgICAgICAgICAgICAgICAgc3BlbGxDaGVjaz17ZmFsc2V9XG4gICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIjE1c1wiXG4gICAgICAgICAgICAgICAgICBvbkNoYW5nZT17b25DaGFuZ2VIYW5kbGVyKCd0aW1lSW50ZXJ2YWwnLCBvcHRpb25zLCBvbk9wdGlvbnNDaGFuZ2UpfVxuICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbkV2ZW50cz17cHJvbVNldHRpbmdzVmFsaWRhdGlvbkV2ZW50c31cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRvb2x0aXA9XCJTZXQgdGhpcyB0byB0aGUgdHlwaWNhbCBzY3JhcGUgYW5kIGV2YWx1YXRpb24gaW50ZXJ2YWwgY29uZmlndXJlZCBpbiBQcm9tZXRoZXVzLiBEZWZhdWx0cyB0byAxNXMuXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm0taW5saW5lXCI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtXCI+XG4gICAgICAgICAgICA8Rm9ybUZpZWxkXG4gICAgICAgICAgICAgIGxhYmVsPVwiUXVlcnkgdGltZW91dFwiXG4gICAgICAgICAgICAgIGxhYmVsV2lkdGg9ezEzfVxuICAgICAgICAgICAgICBpbnB1dEVsPXtcbiAgICAgICAgICAgICAgICA8SW5wdXRcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIndpZHRoLTZcIlxuICAgICAgICAgICAgICAgICAgdmFsdWU9e29wdGlvbnMuanNvbkRhdGEucXVlcnlUaW1lb3V0fVxuICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e29uQ2hhbmdlSGFuZGxlcigncXVlcnlUaW1lb3V0Jywgb3B0aW9ucywgb25PcHRpb25zQ2hhbmdlKX1cbiAgICAgICAgICAgICAgICAgIHNwZWxsQ2hlY2s9e2ZhbHNlfVxuICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCI2MHNcIlxuICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbkV2ZW50cz17cHJvbVNldHRpbmdzVmFsaWRhdGlvbkV2ZW50c31cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRvb2x0aXA9XCJTZXQgdGhlIFByb21ldGhldXMgcXVlcnkgdGltZW91dC5cIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybVwiPlxuICAgICAgICAgIDxJbmxpbmVGb3JtTGFiZWxcbiAgICAgICAgICAgIHdpZHRoPXsxM31cbiAgICAgICAgICAgIHRvb2x0aXA9XCJZb3UgY2FuIHVzZSBlaXRoZXIgUE9TVCBvciBHRVQgSFRUUCBtZXRob2QgdG8gcXVlcnkgeW91ciBQcm9tZXRoZXVzIGRhdGEgc291cmNlLiBQT1NUIGlzIHRoZSByZWNvbW1lbmRlZCBtZXRob2QgYXMgaXQgYWxsb3dzIGJpZ2dlciBxdWVyaWVzLiBDaGFuZ2UgdGhpcyB0byBHRVQgaWYgeW91IGhhdmUgYSBQcm9tZXRoZXVzIHZlcnNpb24gb2xkZXIgdGhhbiAyLjEgb3IgaWYgUE9TVCByZXF1ZXN0cyBhcmUgcmVzdHJpY3RlZCBpbiB5b3VyIG5ldHdvcmsuXCJcbiAgICAgICAgICA+XG4gICAgICAgICAgICBIVFRQIE1ldGhvZFxuICAgICAgICAgIDwvSW5saW5lRm9ybUxhYmVsPlxuICAgICAgICAgIDxTZWxlY3RcbiAgICAgICAgICAgIGFyaWEtbGFiZWw9XCJTZWxlY3QgSFRUUCBtZXRob2RcIlxuICAgICAgICAgICAgb3B0aW9ucz17aHR0cE9wdGlvbnN9XG4gICAgICAgICAgICB2YWx1ZT17aHR0cE9wdGlvbnMuZmluZCgobykgPT4gby52YWx1ZSA9PT0gb3B0aW9ucy5qc29uRGF0YS5odHRwTWV0aG9kKX1cbiAgICAgICAgICAgIG9uQ2hhbmdlPXtvbkNoYW5nZUhhbmRsZXIoJ2h0dHBNZXRob2QnLCBvcHRpb25zLCBvbk9wdGlvbnNDaGFuZ2UpfVxuICAgICAgICAgICAgd2lkdGg9ezd9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxoMyBjbGFzc05hbWU9XCJwYWdlLWhlYWRpbmdcIj5NaXNjPC9oMz5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybS1ncm91cFwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm1cIj5cbiAgICAgICAgICA8SW5saW5lRmllbGRcbiAgICAgICAgICAgIGxhYmVsV2lkdGg9ezI4fVxuICAgICAgICAgICAgbGFiZWw9XCJEaXNhYmxlIG1ldHJpY3MgbG9va3VwXCJcbiAgICAgICAgICAgIHRvb2x0aXA9XCJDaGVja2luZyB0aGlzIG9wdGlvbiB3aWxsIGRpc2FibGUgdGhlIG1ldHJpY3MgY2hvb3NlciBhbmQgbWV0cmljL2xhYmVsIHN1cHBvcnQgaW4gdGhlIHF1ZXJ5IGZpZWxkJ3MgYXV0b2NvbXBsZXRlLiBUaGlzIGhlbHBzIGlmIHlvdSBoYXZlIHBlcmZvcm1hbmNlIGlzc3VlcyB3aXRoIGJpZ2dlciBQcm9tZXRoZXVzIGluc3RhbmNlcy5cIlxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxJbmxpbmVTd2l0Y2hcbiAgICAgICAgICAgICAgdmFsdWU9e29wdGlvbnMuanNvbkRhdGEuZGlzYWJsZU1ldHJpY3NMb29rdXAgPz8gZmFsc2V9XG4gICAgICAgICAgICAgIG9uQ2hhbmdlPXtvblVwZGF0ZURhdGFzb3VyY2VKc29uRGF0YU9wdGlvbkNoZWNrZWQocHJvcHMsICdkaXNhYmxlTWV0cmljc0xvb2t1cCcpfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L0lubGluZUZpZWxkPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtLWlubGluZVwiPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybSBtYXgtd2lkdGgtMzBcIj5cbiAgICAgICAgICAgIDxGb3JtRmllbGRcbiAgICAgICAgICAgICAgbGFiZWw9XCJDdXN0b20gcXVlcnkgcGFyYW1ldGVyc1wiXG4gICAgICAgICAgICAgIGxhYmVsV2lkdGg9ezE0fVxuICAgICAgICAgICAgICB0b29sdGlwPVwiQWRkIEN1c3RvbSBwYXJhbWV0ZXJzIHRvIGFsbCBQcm9tZXRoZXVzIG9yIFRoYW5vcyBxdWVyaWVzLlwiXG4gICAgICAgICAgICAgIGlucHV0RWw9e1xuICAgICAgICAgICAgICAgIDxJbnB1dFxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwid2lkdGgtMjVcIlxuICAgICAgICAgICAgICAgICAgdmFsdWU9e29wdGlvbnMuanNvbkRhdGEuY3VzdG9tUXVlcnlQYXJhbWV0ZXJzfVxuICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e29uQ2hhbmdlSGFuZGxlcignY3VzdG9tUXVlcnlQYXJhbWV0ZXJzJywgb3B0aW9ucywgb25PcHRpb25zQ2hhbmdlKX1cbiAgICAgICAgICAgICAgICAgIHNwZWxsQ2hlY2s9e2ZhbHNlfVxuICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJFeGFtcGxlOiBtYXhfc291cmNlX3Jlc29sdXRpb249NW0mdGltZW91dD0xMFwiXG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxFeGVtcGxhcnNTZXR0aW5nc1xuICAgICAgICBvcHRpb25zPXtvcHRpb25zLmpzb25EYXRhLmV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uc31cbiAgICAgICAgb25DaGFuZ2U9eyhleGVtcGxhck9wdGlvbnMpID0+XG4gICAgICAgICAgdXBkYXRlRGF0YXNvdXJjZVBsdWdpbkpzb25EYXRhT3B0aW9uKFxuICAgICAgICAgICAgeyBvbk9wdGlvbnNDaGFuZ2UsIG9wdGlvbnMgfSxcbiAgICAgICAgICAgICdleGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbnMnLFxuICAgICAgICAgICAgZXhlbXBsYXJPcHRpb25zXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAvPlxuICAgIDwvPlxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IHByb21TZXR0aW5nc1ZhbGlkYXRpb25FdmVudHMgPSB7XG4gIFtFdmVudHNXaXRoVmFsaWRhdGlvbi5vbkJsdXJdOiBbXG4gICAgcmVnZXhWYWxpZGF0aW9uKFxuICAgICAgL14kfF5cXGQrKG1zfFtNd2RobXN5XSkkLyxcbiAgICAgICdWYWx1ZSBpcyBub3QgdmFsaWQsIHlvdSBjYW4gdXNlIG51bWJlciB3aXRoIHRpbWUgdW5pdCBzcGVjaWZpZXI6IHksIE0sIHcsIGQsIGgsIG0sIHMnXG4gICAgKSxcbiAgXSxcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRWYWx1ZUZyb21FdmVudEl0ZW0gPSAoZXZlbnRJdGVtOiBTeW50aGV0aWNFdmVudDxIVE1MSW5wdXRFbGVtZW50PiB8IFNlbGVjdGFibGVWYWx1ZTxzdHJpbmc+KSA9PiB7XG4gIGlmICghZXZlbnRJdGVtKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKGV2ZW50SXRlbS5oYXNPd25Qcm9wZXJ0eSgnY3VycmVudFRhcmdldCcpKSB7XG4gICAgcmV0dXJuIGV2ZW50SXRlbS5jdXJyZW50VGFyZ2V0LnZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIChldmVudEl0ZW0gYXMgU2VsZWN0YWJsZVZhbHVlPHN0cmluZz4pLnZhbHVlO1xufTtcblxuY29uc3Qgb25DaGFuZ2VIYW5kbGVyID1cbiAgKGtleToga2V5b2YgUHJvbU9wdGlvbnMsIG9wdGlvbnM6IFByb3BzWydvcHRpb25zJ10sIG9uT3B0aW9uc0NoYW5nZTogUHJvcHNbJ29uT3B0aW9uc0NoYW5nZSddKSA9PlxuICAoZXZlbnRJdGVtOiBTeW50aGV0aWNFdmVudDxIVE1MSW5wdXRFbGVtZW50PiB8IFNlbGVjdGFibGVWYWx1ZTxzdHJpbmc+KSA9PiB7XG4gICAgb25PcHRpb25zQ2hhbmdlKHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBqc29uRGF0YToge1xuICAgICAgICAuLi5vcHRpb25zLmpzb25EYXRhLFxuICAgICAgICBba2V5XTogZ2V0VmFsdWVGcm9tRXZlbnRJdGVtKGV2ZW50SXRlbSksXG4gICAgICB9LFxuICAgIH0pO1xuICB9O1xuIiwiaW1wb3J0IHsgY2xvbmVEZWVwLCBkZWZhdWx0cyB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgTFJVIGZyb20gJ2xydS1jYWNoZSc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZm9ya0pvaW4sIGxhc3RWYWx1ZUZyb20sIG1lcmdlLCBPYnNlcnZhYmxlLCBvZiwgT3BlcmF0b3JGdW5jdGlvbiwgcGlwZSwgdGhyb3dFcnJvciB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgY2F0Y2hFcnJvciwgZmlsdGVyLCBtYXAsIHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHtcbiAgQW5ub3RhdGlvbkV2ZW50LFxuICBDb3JlQXBwLFxuICBEYXRhUXVlcnlFcnJvcixcbiAgRGF0YVF1ZXJ5UmVxdWVzdCxcbiAgRGF0YVF1ZXJ5UmVzcG9uc2UsXG4gIERhdGFTb3VyY2VJbnN0YW5jZVNldHRpbmdzLFxuICBEYXRhU291cmNlV2l0aFF1ZXJ5RXhwb3J0U3VwcG9ydCxcbiAgRGF0YVNvdXJjZVdpdGhRdWVyeUltcG9ydFN1cHBvcnQsXG4gIGRhdGVNYXRoLFxuICBEYXRlVGltZSxcbiAgQWJzdHJhY3RRdWVyeSxcbiAgTG9hZGluZ1N0YXRlLFxuICByYW5nZVV0aWwsXG4gIFNjb3BlZFZhcnMsXG4gIFRpbWVSYW5nZSxcbiAgRGF0YUZyYW1lLFxuICBkYXRlVGltZSxcbn0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQge1xuICBCYWNrZW5kU3J2UmVxdWVzdCxcbiAgRmV0Y2hFcnJvcixcbiAgRmV0Y2hSZXNwb25zZSxcbiAgZ2V0QmFja2VuZFNydixcbiAgRGF0YVNvdXJjZVdpdGhCYWNrZW5kLFxuICBCYWNrZW5kRGF0YVNvdXJjZVJlc3BvbnNlLFxuICB0b0RhdGFRdWVyeVJlc3BvbnNlLFxufSBmcm9tICdAZ3JhZmFuYS9ydW50aW1lJztcbmltcG9ydCB7IEJhZGdlLCBCYWRnZUNvbG9yLCBUb29sdGlwIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuaW1wb3J0IHsgc2FmZVN0cmluZ2lmeVZhbHVlIH0gZnJvbSAnYXBwL2NvcmUvdXRpbHMvZXhwbG9yZSc7XG5pbXBvcnQgeyBmZXRjaERhdGFTb3VyY2VCdWlsZEluZm8gfSBmcm9tICdhcHAvZmVhdHVyZXMvYWxlcnRpbmcvdW5pZmllZC9hcGkvYnVpbGRJbmZvJztcbmltcG9ydCB7IGdldFRpbWVTcnYsIFRpbWVTcnYgfSBmcm9tICdhcHAvZmVhdHVyZXMvZGFzaGJvYXJkL3NlcnZpY2VzL1RpbWVTcnYnO1xuaW1wb3J0IHsgZ2V0VGVtcGxhdGVTcnYsIFRlbXBsYXRlU3J2IH0gZnJvbSAnYXBwL2ZlYXR1cmVzL3RlbXBsYXRpbmcvdGVtcGxhdGVfc3J2JztcbmltcG9ydCB7IFByb21BcHBsaWNhdGlvbiwgUHJvbUJ1aWxkSW5mbyB9IGZyb20gJ2FwcC90eXBlcy91bmlmaWVkLWFsZXJ0aW5nLWR0byc7XG5cbmltcG9ydCB7IGFkZExhYmVsVG9RdWVyeSB9IGZyb20gJy4vYWRkX2xhYmVsX3RvX3F1ZXJ5JztcbmltcG9ydCBQcm9tZXRoZXVzTGFuZ3VhZ2VQcm92aWRlciBmcm9tICcuL2xhbmd1YWdlX3Byb3ZpZGVyJztcbmltcG9ydCB7IGV4cGFuZFJlY29yZGluZ1J1bGVzIH0gZnJvbSAnLi9sYW5ndWFnZV91dGlscyc7XG5pbXBvcnQgeyByZW5kZXJMZWdlbmRGb3JtYXQgfSBmcm9tICcuL2xlZ2VuZCc7XG5pbXBvcnQgUHJvbWV0aGV1c01ldHJpY0ZpbmRRdWVyeSBmcm9tICcuL21ldHJpY19maW5kX3F1ZXJ5JztcbmltcG9ydCB7IGdldEluaXRIaW50cywgZ2V0UXVlcnlIaW50cyB9IGZyb20gJy4vcXVlcnlfaGludHMnO1xuaW1wb3J0IHsgZ2V0T3JpZ2luYWxNZXRyaWNOYW1lLCB0cmFuc2Zvcm0sIHRyYW5zZm9ybVYyIH0gZnJvbSAnLi9yZXN1bHRfdHJhbnNmb3JtZXInO1xuaW1wb3J0IHtcbiAgRXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb24sXG4gIFByb21EYXRhRXJyb3JSZXNwb25zZSxcbiAgUHJvbURhdGFTdWNjZXNzUmVzcG9uc2UsXG4gIFByb21FeGVtcGxhckRhdGEsXG4gIFByb21NYXRyaXhEYXRhLFxuICBQcm9tT3B0aW9ucyxcbiAgUHJvbVF1ZXJ5LFxuICBQcm9tUXVlcnlSZXF1ZXN0LFxuICBQcm9tUXVlcnlUeXBlLFxuICBQcm9tU2NhbGFyRGF0YSxcbiAgUHJvbVZlY3RvckRhdGEsXG59IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgUHJvbWV0aGV1c1ZhcmlhYmxlU3VwcG9ydCB9IGZyb20gJy4vdmFyaWFibGVzJztcblxuZXhwb3J0IGNvbnN0IEFOTk9UQVRJT05fUVVFUllfU1RFUF9ERUZBVUxUID0gJzYwcyc7XG5jb25zdCBHRVRfQU5EX1BPU1RfTUVUQURBVEFfRU5EUE9JTlRTID0gWydhcGkvdjEvcXVlcnknLCAnYXBpL3YxL3F1ZXJ5X3JhbmdlJywgJ2FwaS92MS9zZXJpZXMnLCAnYXBpL3YxL2xhYmVscyddO1xuXG5leHBvcnQgY2xhc3MgUHJvbWV0aGV1c0RhdGFzb3VyY2VcbiAgZXh0ZW5kcyBEYXRhU291cmNlV2l0aEJhY2tlbmQ8UHJvbVF1ZXJ5LCBQcm9tT3B0aW9ucz5cbiAgaW1wbGVtZW50cyBEYXRhU291cmNlV2l0aFF1ZXJ5SW1wb3J0U3VwcG9ydDxQcm9tUXVlcnk+LCBEYXRhU291cmNlV2l0aFF1ZXJ5RXhwb3J0U3VwcG9ydDxQcm9tUXVlcnk+XG57XG4gIHR5cGU6IHN0cmluZztcbiAgZWRpdG9yU3JjOiBzdHJpbmc7XG4gIHJ1bGVNYXBwaW5nczogeyBbaW5kZXg6IHN0cmluZ106IHN0cmluZyB9O1xuICB1cmw6IHN0cmluZztcbiAgaWQ6IG51bWJlcjtcbiAgZGlyZWN0VXJsOiBzdHJpbmc7XG4gIGFjY2VzczogJ2RpcmVjdCcgfCAncHJveHknO1xuICBiYXNpY0F1dGg6IGFueTtcbiAgd2l0aENyZWRlbnRpYWxzOiBhbnk7XG4gIG1ldHJpY3NOYW1lQ2FjaGUgPSBuZXcgTFJVPHN0cmluZywgc3RyaW5nW10+KHsgbWF4OiAxMCB9KTtcbiAgaW50ZXJ2YWw6IHN0cmluZztcbiAgcXVlcnlUaW1lb3V0OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIGh0dHBNZXRob2Q6IHN0cmluZztcbiAgbGFuZ3VhZ2VQcm92aWRlcjogUHJvbWV0aGV1c0xhbmd1YWdlUHJvdmlkZXI7XG4gIGV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uczogRXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb25bXSB8IHVuZGVmaW5lZDtcbiAgbG9va3Vwc0Rpc2FibGVkOiBib29sZWFuO1xuICBjdXN0b21RdWVyeVBhcmFtZXRlcnM6IGFueTtcbiAgZXhlbXBsYXJzQXZhaWxhYmxlOiBib29sZWFuO1xuICBzdWJUeXBlOiBQcm9tQXBwbGljYXRpb247XG4gIHJ1bGVyRW5hYmxlZDogYm9vbGVhbjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBpbnN0YW5jZVNldHRpbmdzOiBEYXRhU291cmNlSW5zdGFuY2VTZXR0aW5nczxQcm9tT3B0aW9ucz4sXG4gICAgcHJpdmF0ZSByZWFkb25seSB0ZW1wbGF0ZVNydjogVGVtcGxhdGVTcnYgPSBnZXRUZW1wbGF0ZVNydigpLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgdGltZVNydjogVGltZVNydiA9IGdldFRpbWVTcnYoKSxcbiAgICBsYW5ndWFnZVByb3ZpZGVyPzogUHJvbWV0aGV1c0xhbmd1YWdlUHJvdmlkZXJcbiAgKSB7XG4gICAgc3VwZXIoaW5zdGFuY2VTZXR0aW5ncyk7XG5cbiAgICB0aGlzLnR5cGUgPSAncHJvbWV0aGV1cyc7XG4gICAgdGhpcy5zdWJUeXBlID0gUHJvbUFwcGxpY2F0aW9uLlByb21ldGhldXM7XG4gICAgdGhpcy5ydWxlckVuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmVkaXRvclNyYyA9ICdhcHAvZmVhdHVyZXMvcHJvbWV0aGV1cy9wYXJ0aWFscy9xdWVyeS5lZGl0b3IuaHRtbCc7XG4gICAgdGhpcy5pZCA9IGluc3RhbmNlU2V0dGluZ3MuaWQ7XG4gICAgdGhpcy51cmwgPSBpbnN0YW5jZVNldHRpbmdzLnVybCE7XG4gICAgdGhpcy5hY2Nlc3MgPSBpbnN0YW5jZVNldHRpbmdzLmFjY2VzcztcbiAgICB0aGlzLmJhc2ljQXV0aCA9IGluc3RhbmNlU2V0dGluZ3MuYmFzaWNBdXRoO1xuICAgIHRoaXMud2l0aENyZWRlbnRpYWxzID0gaW5zdGFuY2VTZXR0aW5ncy53aXRoQ3JlZGVudGlhbHM7XG4gICAgdGhpcy5pbnRlcnZhbCA9IGluc3RhbmNlU2V0dGluZ3MuanNvbkRhdGEudGltZUludGVydmFsIHx8ICcxNXMnO1xuICAgIHRoaXMucXVlcnlUaW1lb3V0ID0gaW5zdGFuY2VTZXR0aW5ncy5qc29uRGF0YS5xdWVyeVRpbWVvdXQ7XG4gICAgdGhpcy5odHRwTWV0aG9kID0gaW5zdGFuY2VTZXR0aW5ncy5qc29uRGF0YS5odHRwTWV0aG9kIHx8ICdQT1NUJztcbiAgICAvLyBgZGlyZWN0VXJsYCBpcyBuZXZlciB1bmRlZmluZWQsIHdlIHNldCBpdCBhdCBodHRwczovL2dpdGh1Yi5jb20vZ3JhZmFuYS9ncmFmYW5hL2Jsb2IvbWFpbi9wa2cvYXBpL2Zyb250ZW5kc2V0dGluZ3MuZ28jTDEwOFxuICAgIC8vIGhlcmUgd2UgXCJmYWxsIGJhY2tcIiB0byB0aGlzLnVybCB0byBtYWtlIHR5cGVzY3JpcHQgaGFwcHksIGJ1dCBpdCBzaG91bGQgbmV2ZXIgaGFwcGVuXG4gICAgdGhpcy5kaXJlY3RVcmwgPSBpbnN0YW5jZVNldHRpbmdzLmpzb25EYXRhLmRpcmVjdFVybCA/PyB0aGlzLnVybDtcbiAgICB0aGlzLmV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9ucyA9IGluc3RhbmNlU2V0dGluZ3MuanNvbkRhdGEuZXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb25zO1xuICAgIHRoaXMucnVsZU1hcHBpbmdzID0ge307XG4gICAgdGhpcy5sYW5ndWFnZVByb3ZpZGVyID0gbGFuZ3VhZ2VQcm92aWRlciA/PyBuZXcgUHJvbWV0aGV1c0xhbmd1YWdlUHJvdmlkZXIodGhpcyk7XG4gICAgdGhpcy5sb29rdXBzRGlzYWJsZWQgPSBpbnN0YW5jZVNldHRpbmdzLmpzb25EYXRhLmRpc2FibGVNZXRyaWNzTG9va3VwID8/IGZhbHNlO1xuICAgIHRoaXMuY3VzdG9tUXVlcnlQYXJhbWV0ZXJzID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhpbnN0YW5jZVNldHRpbmdzLmpzb25EYXRhLmN1c3RvbVF1ZXJ5UGFyYW1ldGVycyk7XG4gICAgdGhpcy52YXJpYWJsZXMgPSBuZXcgUHJvbWV0aGV1c1ZhcmlhYmxlU3VwcG9ydCh0aGlzLCB0aGlzLnRlbXBsYXRlU3J2LCB0aGlzLnRpbWVTcnYpO1xuICAgIHRoaXMuZXhlbXBsYXJzQXZhaWxhYmxlID0gdHJ1ZTtcbiAgfVxuXG4gIGluaXQgPSBhc3luYyAoKSA9PiB7XG4gICAgdGhpcy5sb2FkUnVsZXMoKTtcbiAgICB0aGlzLmV4ZW1wbGFyc0F2YWlsYWJsZSA9IGF3YWl0IHRoaXMuYXJlRXhlbXBsYXJzQXZhaWxhYmxlKCk7XG4gIH07XG5cbiAgZ2V0UXVlcnlEaXNwbGF5VGV4dChxdWVyeTogUHJvbVF1ZXJ5KSB7XG4gICAgcmV0dXJuIHF1ZXJ5LmV4cHI7XG4gIH1cblxuICBfYWRkVHJhY2luZ0hlYWRlcnMoaHR0cE9wdGlvbnM6IFByb21RdWVyeVJlcXVlc3QsIG9wdGlvbnM6IERhdGFRdWVyeVJlcXVlc3Q8UHJvbVF1ZXJ5Pikge1xuICAgIGh0dHBPcHRpb25zLmhlYWRlcnMgPSB7fTtcbiAgICBjb25zdCBwcm94eU1vZGUgPSAhdGhpcy51cmwubWF0Y2goL15odHRwLyk7XG4gICAgaWYgKHByb3h5TW9kZSkge1xuICAgICAgaHR0cE9wdGlvbnMuaGVhZGVyc1snWC1EYXNoYm9hcmQtSWQnXSA9IG9wdGlvbnMuZGFzaGJvYXJkSWQ7XG4gICAgICBodHRwT3B0aW9ucy5oZWFkZXJzWydYLVBhbmVsLUlkJ10gPSBvcHRpb25zLnBhbmVsSWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFueSByZXF1ZXN0IGRvbmUgZnJvbSB0aGlzIGRhdGEgc291cmNlIHNob3VsZCBnbyB0aHJvdWdoIGhlcmUgYXMgaXQgY29udGFpbnMgc29tZSBjb21tb24gcHJvY2Vzc2luZyBmb3IgdGhlXG4gICAqIHJlcXVlc3QuIEFueSBwcm9jZXNzaW5nIGRvbmUgaGVyZSBuZWVkcyB0byBiZSBhbHNvIGNvcGllZCBvbiB0aGUgYmFja2VuZCBhcyB0aGlzIGdvZXMgdGhyb3VnaCBkYXRhIHNvdXJjZSBwcm94eVxuICAgKiBidXQgbm90IHRocm91Z2ggdGhlIHNhbWUgY29kZSBhcyBhbGVydGluZy5cbiAgICovXG4gIF9yZXF1ZXN0PFQgPSBhbnk+KFxuICAgIHVybDogc3RyaW5nLFxuICAgIGRhdGE6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gfCBudWxsLFxuICAgIG92ZXJyaWRlczogUGFydGlhbDxCYWNrZW5kU3J2UmVxdWVzdD4gPSB7fVxuICApOiBPYnNlcnZhYmxlPEZldGNoUmVzcG9uc2U8VD4+IHtcbiAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLmN1c3RvbVF1ZXJ5UGFyYW1ldGVycykge1xuICAgICAgaWYgKGRhdGFba2V5XSA9PSBudWxsKSB7XG4gICAgICAgIGRhdGFba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbnM6IEJhY2tlbmRTcnZSZXF1ZXN0ID0gZGVmYXVsdHMob3ZlcnJpZGVzLCB7XG4gICAgICB1cmw6IHRoaXMudXJsICsgdXJsLFxuICAgICAgbWV0aG9kOiB0aGlzLmh0dHBNZXRob2QsXG4gICAgICBoZWFkZXJzOiB7fSxcbiAgICB9KTtcblxuICAgIGlmIChvcHRpb25zLm1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAgIGlmIChkYXRhICYmIE9iamVjdC5rZXlzKGRhdGEpLmxlbmd0aCkge1xuICAgICAgICBvcHRpb25zLnVybCA9XG4gICAgICAgICAgb3B0aW9ucy51cmwgK1xuICAgICAgICAgIChvcHRpb25zLnVybC5zZWFyY2goL1xcPy8pID49IDAgPyAnJicgOiAnPycpICtcbiAgICAgICAgICBPYmplY3QuZW50cmllcyhkYXRhKVxuICAgICAgICAgICAgLm1hcCgoW2ssIHZdKSA9PiBgJHtlbmNvZGVVUklDb21wb25lbnQoayl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHYpfWApXG4gICAgICAgICAgICAuam9pbignJicpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLmhlYWRlcnMhWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuICAgICAgb3B0aW9ucy5kYXRhID0gZGF0YTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5iYXNpY0F1dGggfHwgdGhpcy53aXRoQ3JlZGVudGlhbHMpIHtcbiAgICAgIG9wdGlvbnMud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5iYXNpY0F1dGgpIHtcbiAgICAgIG9wdGlvbnMuaGVhZGVycyEuQXV0aG9yaXphdGlvbiA9IHRoaXMuYmFzaWNBdXRoO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRCYWNrZW5kU3J2KCkuZmV0Y2g8VD4ob3B0aW9ucyk7XG4gIH1cblxuICBhc3luYyBpbXBvcnRGcm9tQWJzdHJhY3RRdWVyaWVzKGFic3RyYWN0UXVlcmllczogQWJzdHJhY3RRdWVyeVtdKTogUHJvbWlzZTxQcm9tUXVlcnlbXT4ge1xuICAgIHJldHVybiBhYnN0cmFjdFF1ZXJpZXMubWFwKChhYnN0cmFjdFF1ZXJ5KSA9PiB0aGlzLmxhbmd1YWdlUHJvdmlkZXIuaW1wb3J0RnJvbUFic3RyYWN0UXVlcnkoYWJzdHJhY3RRdWVyeSkpO1xuICB9XG5cbiAgYXN5bmMgZXhwb3J0VG9BYnN0cmFjdFF1ZXJpZXMocXVlcmllczogUHJvbVF1ZXJ5W10pOiBQcm9taXNlPEFic3RyYWN0UXVlcnlbXT4ge1xuICAgIHJldHVybiBxdWVyaWVzLm1hcCgocXVlcnkpID0+IHRoaXMubGFuZ3VhZ2VQcm92aWRlci5leHBvcnRUb0Fic3RyYWN0UXVlcnkocXVlcnkpKTtcbiAgfVxuXG4gIC8vIFVzZSB0aGlzIGZvciB0YWIgY29tcGxldGlvbiBmZWF0dXJlcywgd29udCBwdWJsaXNoIHJlc3BvbnNlIHRvIG90aGVyIGNvbXBvbmVudHNcbiAgYXN5bmMgbWV0YWRhdGFSZXF1ZXN0PFQgPSBhbnk+KHVybDogc3RyaW5nLCBwYXJhbXMgPSB7fSkge1xuICAgIC8vIElmIFVSTCBpbmNsdWRlcyBlbmRwb2ludCB0aGF0IHN1cHBvcnRzIFBPU1QgYW5kIEdFVCBtZXRob2QsIHRyeSB0byB1c2UgY29uZmlndXJlZCBtZXRob2QuIFRoaXMgbWlnaHQgZmFpbCBhcyBQT1NUIGlzIHN1cHBvcnRlZCBvbmx5IGluIHYyLjEwKy5cbiAgICBpZiAoR0VUX0FORF9QT1NUX01FVEFEQVRBX0VORFBPSU5UUy5zb21lKChlbmRwb2ludCkgPT4gdXJsLmluY2x1ZGVzKGVuZHBvaW50KSkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBsYXN0VmFsdWVGcm9tKHRoaXMuX3JlcXVlc3Q8VD4odXJsLCBwYXJhbXMsIHsgbWV0aG9kOiB0aGlzLmh0dHBNZXRob2QsIGhpZGVGcm9tSW5zcGVjdG9yOiB0cnVlIH0pKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBJZiBzdGF0dXMgY29kZSBvZiBlcnJvciBpcyBNZXRob2QgTm90IEFsbG93ZWQgKDQwNSkgYW5kIEhUVFAgbWV0aG9kIGlzIFBPU1QsIHJldHJ5IHdpdGggR0VUXG4gICAgICAgIGlmICh0aGlzLmh0dHBNZXRob2QgPT09ICdQT1NUJyAmJiBlcnIuc3RhdHVzID09PSA0MDUpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYENvdWxkbid0IHVzZSBjb25maWd1cmVkIFBPU1QgSFRUUCBtZXRob2QgZm9yIHRoaXMgcmVxdWVzdC4gVHJ5aW5nIHRvIHVzZSBHRVQgbWV0aG9kIGluc3RlYWQuYCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0IGxhc3RWYWx1ZUZyb20odGhpcy5fcmVxdWVzdDxUPih1cmwsIHBhcmFtcywgeyBtZXRob2Q6ICdHRVQnLCBoaWRlRnJvbUluc3BlY3RvcjogdHJ1ZSB9KSk7IC8vIHRvUHJvbWlzZSB1bnRpbCB3ZSBjaGFuZ2UgZ2V0VGFnVmFsdWVzLCBnZXRUYWdLZXlzIHRvIE9ic2VydmFibGVcbiAgfVxuXG4gIGludGVycG9sYXRlUXVlcnlFeHByKHZhbHVlOiBzdHJpbmcgfCBzdHJpbmdbXSA9IFtdLCB2YXJpYWJsZTogYW55KSB7XG4gICAgLy8gaWYgbm8gbXVsdGkgb3IgaW5jbHVkZSBhbGwgZG8gbm90IHJlZ2V4RXNjYXBlXG4gICAgaWYgKCF2YXJpYWJsZS5tdWx0aSAmJiAhdmFyaWFibGUuaW5jbHVkZUFsbCkge1xuICAgICAgcmV0dXJuIHByb21ldGhldXNSZWd1bGFyRXNjYXBlKHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHByb21ldGhldXNTcGVjaWFsUmVnZXhFc2NhcGUodmFsdWUpO1xuICAgIH1cblxuICAgIGNvbnN0IGVzY2FwZWRWYWx1ZXMgPSB2YWx1ZS5tYXAoKHZhbCkgPT4gcHJvbWV0aGV1c1NwZWNpYWxSZWdleEVzY2FwZSh2YWwpKTtcblxuICAgIGlmIChlc2NhcGVkVmFsdWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGVzY2FwZWRWYWx1ZXNbMF07XG4gICAgfVxuXG4gICAgcmV0dXJuICcoJyArIGVzY2FwZWRWYWx1ZXMuam9pbignfCcpICsgJyknO1xuICB9XG5cbiAgdGFyZ2V0Q29udGFpbnNUZW1wbGF0ZSh0YXJnZXQ6IFByb21RdWVyeSkge1xuICAgIHJldHVybiB0aGlzLnRlbXBsYXRlU3J2LmNvbnRhaW5zVGVtcGxhdGUodGFyZ2V0LmV4cHIpO1xuICB9XG5cbiAgcHJlcGFyZVRhcmdldHMgPSAob3B0aW9uczogRGF0YVF1ZXJ5UmVxdWVzdDxQcm9tUXVlcnk+LCBzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IHF1ZXJpZXM6IFByb21RdWVyeVJlcXVlc3RbXSA9IFtdO1xuICAgIGNvbnN0IGFjdGl2ZVRhcmdldHM6IFByb21RdWVyeVtdID0gW107XG4gICAgY29uc3QgY2xvbmVkVGFyZ2V0cyA9IGNsb25lRGVlcChvcHRpb25zLnRhcmdldHMpO1xuXG4gICAgZm9yIChjb25zdCB0YXJnZXQgb2YgY2xvbmVkVGFyZ2V0cykge1xuICAgICAgaWYgKCF0YXJnZXQuZXhwciB8fCB0YXJnZXQuaGlkZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0LnJlcXVlc3RJZCA9IG9wdGlvbnMucGFuZWxJZCArIHRhcmdldC5yZWZJZDtcbiAgICAgIGNvbnN0IG1ldHJpY05hbWUgPSB0aGlzLmxhbmd1YWdlUHJvdmlkZXIuaGlzdG9ncmFtTWV0cmljcy5maW5kKChtKSA9PiB0YXJnZXQuZXhwci5pbmNsdWRlcyhtKSk7XG5cbiAgICAgIC8vIEluIEV4cGxvcmUsIHdlIHJ1biBib3RoIChpbnN0YW50IGFuZCByYW5nZSkgcXVlcmllcyBpZiBib3RoIGFyZSB0cnVlIChzZWxlY3RlZCkgb3IgYm90aCBhcmUgdW5kZWZpbmVkIChsZWdhY3kgRXhwbG9yZSBxdWVyaWVzKVxuICAgICAgaWYgKG9wdGlvbnMuYXBwID09PSBDb3JlQXBwLkV4cGxvcmUgJiYgdGFyZ2V0LnJhbmdlID09PSB0YXJnZXQuaW5zdGFudCkge1xuICAgICAgICAvLyBDcmVhdGUgaW5zdGFudCB0YXJnZXRcbiAgICAgICAgY29uc3QgaW5zdGFudFRhcmdldDogYW55ID0gY2xvbmVEZWVwKHRhcmdldCk7XG4gICAgICAgIGluc3RhbnRUYXJnZXQuZm9ybWF0ID0gJ3RhYmxlJztcbiAgICAgICAgaW5zdGFudFRhcmdldC5pbnN0YW50ID0gdHJ1ZTtcbiAgICAgICAgaW5zdGFudFRhcmdldC5yYW5nZSA9IGZhbHNlO1xuICAgICAgICBpbnN0YW50VGFyZ2V0LnZhbHVlV2l0aFJlZklkID0gdHJ1ZTtcbiAgICAgICAgZGVsZXRlIGluc3RhbnRUYXJnZXQubWF4RGF0YVBvaW50cztcbiAgICAgICAgaW5zdGFudFRhcmdldC5yZXF1ZXN0SWQgKz0gJ19pbnN0YW50JztcblxuICAgICAgICAvLyBDcmVhdGUgcmFuZ2UgdGFyZ2V0XG4gICAgICAgIGNvbnN0IHJhbmdlVGFyZ2V0OiBhbnkgPSBjbG9uZURlZXAodGFyZ2V0KTtcbiAgICAgICAgcmFuZ2VUYXJnZXQuZm9ybWF0ID0gJ3RpbWVfc2VyaWVzJztcbiAgICAgICAgcmFuZ2VUYXJnZXQuaW5zdGFudCA9IGZhbHNlO1xuICAgICAgICBpbnN0YW50VGFyZ2V0LnJhbmdlID0gdHJ1ZTtcblxuICAgICAgICAvLyBDcmVhdGUgZXhlbXBsYXIgcXVlcnlcbiAgICAgICAgaWYgKHRhcmdldC5leGVtcGxhcikge1xuICAgICAgICAgIC8vIE9ubHkgY3JlYXRlIGV4ZW1wbGFyIHRhcmdldCBmb3IgZGlmZmVyZW50IG1ldHJpYyBuYW1lc1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFtZXRyaWNOYW1lIHx8XG4gICAgICAgICAgICAobWV0cmljTmFtZSAmJiAhYWN0aXZlVGFyZ2V0cy5zb21lKChhY3RpdmVUYXJnZXQpID0+IGFjdGl2ZVRhcmdldC5leHByLmluY2x1ZGVzKG1ldHJpY05hbWUpKSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnN0IGV4ZW1wbGFyVGFyZ2V0ID0gY2xvbmVEZWVwKHRhcmdldCk7XG4gICAgICAgICAgICBleGVtcGxhclRhcmdldC5pbnN0YW50ID0gZmFsc2U7XG4gICAgICAgICAgICBleGVtcGxhclRhcmdldC5yZXF1ZXN0SWQgKz0gJ19leGVtcGxhcic7XG4gICAgICAgICAgICBxdWVyaWVzLnB1c2godGhpcy5jcmVhdGVRdWVyeShleGVtcGxhclRhcmdldCwgb3B0aW9ucywgc3RhcnQsIGVuZCkpO1xuICAgICAgICAgICAgYWN0aXZlVGFyZ2V0cy5wdXNoKGV4ZW1wbGFyVGFyZ2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5zdGFudFRhcmdldC5leGVtcGxhciA9IGZhbHNlO1xuICAgICAgICAgIHJhbmdlVGFyZ2V0LmV4ZW1wbGFyID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgYm90aCB0YXJnZXRzIHRvIGFjdGl2ZVRhcmdldHMgYW5kIHF1ZXJpZXMgYXJyYXlzXG4gICAgICAgIGFjdGl2ZVRhcmdldHMucHVzaChpbnN0YW50VGFyZ2V0LCByYW5nZVRhcmdldCk7XG4gICAgICAgIHF1ZXJpZXMucHVzaChcbiAgICAgICAgICB0aGlzLmNyZWF0ZVF1ZXJ5KGluc3RhbnRUYXJnZXQsIG9wdGlvbnMsIHN0YXJ0LCBlbmQpLFxuICAgICAgICAgIHRoaXMuY3JlYXRlUXVlcnkocmFuZ2VUYXJnZXQsIG9wdGlvbnMsIHN0YXJ0LCBlbmQpXG4gICAgICAgICk7XG4gICAgICAgIC8vIElmIHJ1bm5pbmcgb25seSBpbnN0YW50IHF1ZXJ5IGluIEV4cGxvcmUsIGZvcm1hdCBhcyB0YWJsZVxuICAgICAgfSBlbHNlIGlmICh0YXJnZXQuaW5zdGFudCAmJiBvcHRpb25zLmFwcCA9PT0gQ29yZUFwcC5FeHBsb3JlKSB7XG4gICAgICAgIGNvbnN0IGluc3RhbnRUYXJnZXQ6IGFueSA9IGNsb25lRGVlcCh0YXJnZXQpO1xuICAgICAgICBpbnN0YW50VGFyZ2V0LmZvcm1hdCA9ICd0YWJsZSc7XG4gICAgICAgIHF1ZXJpZXMucHVzaCh0aGlzLmNyZWF0ZVF1ZXJ5KGluc3RhbnRUYXJnZXQsIG9wdGlvbnMsIHN0YXJ0LCBlbmQpKTtcbiAgICAgICAgYWN0aXZlVGFyZ2V0cy5wdXNoKGluc3RhbnRUYXJnZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSXQgZG9lc24ndCBtYWtlIHNlbnNlIHRvIHF1ZXJ5IGZvciBleGVtcGxhcnMgaW4gZGFzaGJvYXJkIGlmIG9ubHkgaW5zdGFudCBpcyBzZWxlY3RlZFxuICAgICAgICBpZiAodGFyZ2V0LmV4ZW1wbGFyICYmICF0YXJnZXQuaW5zdGFudCkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFtZXRyaWNOYW1lIHx8XG4gICAgICAgICAgICAobWV0cmljTmFtZSAmJiAhYWN0aXZlVGFyZ2V0cy5zb21lKChhY3RpdmVUYXJnZXQpID0+IGFjdGl2ZVRhcmdldC5leHByLmluY2x1ZGVzKG1ldHJpY05hbWUpKSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnN0IGV4ZW1wbGFyVGFyZ2V0ID0gY2xvbmVEZWVwKHRhcmdldCk7XG4gICAgICAgICAgICBleGVtcGxhclRhcmdldC5yZXF1ZXN0SWQgKz0gJ19leGVtcGxhcic7XG4gICAgICAgICAgICBxdWVyaWVzLnB1c2godGhpcy5jcmVhdGVRdWVyeShleGVtcGxhclRhcmdldCwgb3B0aW9ucywgc3RhcnQsIGVuZCkpO1xuICAgICAgICAgICAgYWN0aXZlVGFyZ2V0cy5wdXNoKGV4ZW1wbGFyVGFyZ2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGFyZ2V0LmV4ZW1wbGFyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcXVlcmllcy5wdXNoKHRoaXMuY3JlYXRlUXVlcnkodGFyZ2V0LCBvcHRpb25zLCBzdGFydCwgZW5kKSk7XG4gICAgICAgIGFjdGl2ZVRhcmdldHMucHVzaCh0YXJnZXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBxdWVyaWVzLFxuICAgICAgYWN0aXZlVGFyZ2V0cyxcbiAgICB9O1xuICB9O1xuXG4gIHNob3VsZFJ1bkV4ZW1wbGFyUXVlcnkodGFyZ2V0OiBQcm9tUXVlcnksIHJlcXVlc3Q6IERhdGFRdWVyeVJlcXVlc3Q8UHJvbVF1ZXJ5Pik6IGJvb2xlYW4ge1xuICAgIGlmICh0YXJnZXQuZXhlbXBsYXIpIHtcbiAgICAgIC8vIFdlIGNoZWNrIGFsbCBhbHJlYWR5IHByb2Nlc3NlZCB0YXJnZXRzIGFuZCBvbmx5IGNyZWF0ZSBleGVtcGxhciB0YXJnZXQgZm9yIG5vdCB1c2VkIG1ldHJpYyBuYW1lc1xuICAgICAgY29uc3QgbWV0cmljTmFtZSA9IHRoaXMubGFuZ3VhZ2VQcm92aWRlci5oaXN0b2dyYW1NZXRyaWNzLmZpbmQoKG0pID0+IHRhcmdldC5leHByLmluY2x1ZGVzKG0pKTtcbiAgICAgIC8vIFJlbW92ZSB0YXJnZXRzIHRoYXQgd2VyZW4ndCBwcm9jZXNzZWQgeWV0IChpbiB0YXJnZXRzIGFycmF5IHRoZXkgYXJlIGFmdGVyIGN1cnJlbnQgdGFyZ2V0KVxuICAgICAgY29uc3QgY3VycmVudFRhcmdldElkeCA9IHJlcXVlc3QudGFyZ2V0cy5maW5kSW5kZXgoKHQpID0+IHQucmVmSWQgPT09IHRhcmdldC5yZWZJZCk7XG4gICAgICBjb25zdCB0YXJnZXRzID0gcmVxdWVzdC50YXJnZXRzLnNsaWNlKDAsIGN1cnJlbnRUYXJnZXRJZHgpO1xuXG4gICAgICBpZiAoIW1ldHJpY05hbWUgfHwgKG1ldHJpY05hbWUgJiYgIXRhcmdldHMuc29tZSgodCkgPT4gdC5leHByLmluY2x1ZGVzKG1ldHJpY05hbWUpKSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHByb2Nlc3NUYXJnZXRWMih0YXJnZXQ6IFByb21RdWVyeSwgcmVxdWVzdDogRGF0YVF1ZXJ5UmVxdWVzdDxQcm9tUXVlcnk+KSB7XG4gICAgY29uc3QgcHJvY2Vzc2VkVGFyZ2V0ID0ge1xuICAgICAgLi4udGFyZ2V0LFxuICAgICAgcXVlcnlUeXBlOiBQcm9tUXVlcnlUeXBlLnRpbWVTZXJpZXNRdWVyeSxcbiAgICAgIGV4ZW1wbGFyOiB0aGlzLnNob3VsZFJ1bkV4ZW1wbGFyUXVlcnkodGFyZ2V0LCByZXF1ZXN0KSxcbiAgICAgIHJlcXVlc3RJZDogcmVxdWVzdC5wYW5lbElkICsgdGFyZ2V0LnJlZklkLFxuICAgICAgLy8gV2UgbmVlZCB0byBwYXNzIHV0Y09mZnNldFNlYyB0byBiYWNrZW5kIHRvIGNhbGN1bGF0ZSBhbGlnbmVkIHJhbmdlXG4gICAgICB1dGNPZmZzZXRTZWM6IHRoaXMudGltZVNydi50aW1lUmFuZ2UoKS50by51dGNPZmZzZXQoKSAqIDYwLFxuICAgIH07XG4gICAgcmV0dXJuIHByb2Nlc3NlZFRhcmdldDtcbiAgfVxuXG4gIHF1ZXJ5KHJlcXVlc3Q6IERhdGFRdWVyeVJlcXVlc3Q8UHJvbVF1ZXJ5Pik6IE9ic2VydmFibGU8RGF0YVF1ZXJ5UmVzcG9uc2U+IHtcbiAgICBpZiAodGhpcy5hY2Nlc3MgPT09ICdwcm94eScpIHtcbiAgICAgIGNvbnN0IHRhcmdldHMgPSByZXF1ZXN0LnRhcmdldHMubWFwKCh0YXJnZXQpID0+IHRoaXMucHJvY2Vzc1RhcmdldFYyKHRhcmdldCwgcmVxdWVzdCkpO1xuICAgICAgcmV0dXJuIHN1cGVyXG4gICAgICAgIC5xdWVyeSh7IC4uLnJlcXVlc3QsIHRhcmdldHMgfSlcbiAgICAgICAgLnBpcGUoXG4gICAgICAgICAgbWFwKChyZXNwb25zZSkgPT5cbiAgICAgICAgICAgIHRyYW5zZm9ybVYyKHJlc3BvbnNlLCByZXF1ZXN0LCB7IGV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uczogdGhpcy5leGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbnMgfSlcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAvLyBSdW4gcXVlcmllcyB0cm91Z2ggYnJvd3Nlci9wcm94eVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzdGFydCA9IHRoaXMuZ2V0UHJvbWV0aGV1c1RpbWUocmVxdWVzdC5yYW5nZS5mcm9tLCBmYWxzZSk7XG4gICAgICBjb25zdCBlbmQgPSB0aGlzLmdldFByb21ldGhldXNUaW1lKHJlcXVlc3QucmFuZ2UudG8sIHRydWUpO1xuICAgICAgY29uc3QgeyBxdWVyaWVzLCBhY3RpdmVUYXJnZXRzIH0gPSB0aGlzLnByZXBhcmVUYXJnZXRzKHJlcXVlc3QsIHN0YXJ0LCBlbmQpO1xuXG4gICAgICAvLyBObyB2YWxpZCB0YXJnZXRzLCByZXR1cm4gdGhlIGVtcHR5IHJlc3VsdCB0byBzYXZlIGEgcm91bmQgdHJpcC5cbiAgICAgIGlmICghcXVlcmllcyB8fCAhcXVlcmllcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG9mKHtcbiAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICBzdGF0ZTogTG9hZGluZ1N0YXRlLkRvbmUsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVxdWVzdC5hcHAgPT09IENvcmVBcHAuRXhwbG9yZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHBsb3JlUXVlcnkocXVlcmllcywgYWN0aXZlVGFyZ2V0cywgZW5kKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucGFuZWxzUXVlcnkocXVlcmllcywgYWN0aXZlVGFyZ2V0cywgZW5kLCByZXF1ZXN0LnJlcXVlc3RJZCwgcmVxdWVzdC5zY29wZWRWYXJzKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGV4cGxvcmVRdWVyeShxdWVyaWVzOiBQcm9tUXVlcnlSZXF1ZXN0W10sIGFjdGl2ZVRhcmdldHM6IFByb21RdWVyeVtdLCBlbmQ6IG51bWJlcikge1xuICAgIGxldCBydW5uaW5nUXVlcmllc0NvdW50ID0gcXVlcmllcy5sZW5ndGg7XG5cbiAgICBjb25zdCBzdWJRdWVyaWVzID0gcXVlcmllcy5tYXAoKHF1ZXJ5LCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gYWN0aXZlVGFyZ2V0c1tpbmRleF07XG5cbiAgICAgIGNvbnN0IGZpbHRlckFuZE1hcFJlc3BvbnNlID0gcGlwZShcbiAgICAgICAgLy8gRGVjcmVhc2UgdGhlIGNvdW50ZXIgaGVyZS4gV2UgYXNzdW1lIHRoYXQgZWFjaCByZXF1ZXN0IHJldHVybnMgb25seSBzaW5nbGUgdmFsdWUgYW5kIHRoZW4gY29tcGxldGVzXG4gICAgICAgIC8vIChzaG91bGQgaG9sZCB1bnRpbCB0aGVyZSBpcyBzb21lIHN0cmVhbWluZyByZXF1ZXN0cyBpbnZvbHZlZCkuXG4gICAgICAgIHRhcCgoKSA9PiBydW5uaW5nUXVlcmllc0NvdW50LS0pLFxuICAgICAgICBmaWx0ZXIoKHJlc3BvbnNlOiBhbnkpID0+IChyZXNwb25zZS5jYW5jZWxsZWQgPyBmYWxzZSA6IHRydWUpKSxcbiAgICAgICAgbWFwKChyZXNwb25zZTogYW55KSA9PiB7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IHRyYW5zZm9ybShyZXNwb25zZSwge1xuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICByZXNwb25zZUxpc3RMZW5ndGg6IHF1ZXJpZXMubGVuZ3RoLFxuICAgICAgICAgICAgZXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb25zOiB0aGlzLmV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9ucyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIGtleTogcXVlcnkucmVxdWVzdElkLFxuICAgICAgICAgICAgc3RhdGU6IHJ1bm5pbmdRdWVyaWVzQ291bnQgPT09IDAgPyBMb2FkaW5nU3RhdGUuRG9uZSA6IExvYWRpbmdTdGF0ZS5Mb2FkaW5nLFxuICAgICAgICAgIH0gYXMgRGF0YVF1ZXJ5UmVzcG9uc2U7XG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gdGhpcy5ydW5RdWVyeShxdWVyeSwgZW5kLCBmaWx0ZXJBbmRNYXBSZXNwb25zZSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbWVyZ2UoLi4uc3ViUXVlcmllcyk7XG4gIH1cblxuICBwcml2YXRlIHBhbmVsc1F1ZXJ5KFxuICAgIHF1ZXJpZXM6IFByb21RdWVyeVJlcXVlc3RbXSxcbiAgICBhY3RpdmVUYXJnZXRzOiBQcm9tUXVlcnlbXSxcbiAgICBlbmQ6IG51bWJlcixcbiAgICByZXF1ZXN0SWQ6IHN0cmluZyxcbiAgICBzY29wZWRWYXJzOiBTY29wZWRWYXJzXG4gICkge1xuICAgIGNvbnN0IG9ic2VydmFibGVzID0gcXVlcmllcy5tYXAoKHF1ZXJ5LCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gYWN0aXZlVGFyZ2V0c1tpbmRleF07XG5cbiAgICAgIGNvbnN0IGZpbHRlckFuZE1hcFJlc3BvbnNlID0gcGlwZShcbiAgICAgICAgZmlsdGVyKChyZXNwb25zZTogYW55KSA9PiAocmVzcG9uc2UuY2FuY2VsbGVkID8gZmFsc2UgOiB0cnVlKSksXG4gICAgICAgIG1hcCgocmVzcG9uc2U6IGFueSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSB0cmFuc2Zvcm0ocmVzcG9uc2UsIHtcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgcmVzcG9uc2VMaXN0TGVuZ3RoOiBxdWVyaWVzLmxlbmd0aCxcbiAgICAgICAgICAgIHNjb3BlZFZhcnMsXG4gICAgICAgICAgICBleGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbnM6IHRoaXMuZXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb25zLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHRoaXMucnVuUXVlcnkocXVlcnksIGVuZCwgZmlsdGVyQW5kTWFwUmVzcG9uc2UpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZvcmtKb2luKG9ic2VydmFibGVzKS5waXBlKFxuICAgICAgbWFwKChyZXN1bHRzKSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSByZXN1bHRzLnJlZHVjZSgocmVzdWx0LCBjdXJyZW50KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIFsuLi5yZXN1bHQsIC4uLmN1cnJlbnRdO1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICBrZXk6IHJlcXVlc3RJZCxcbiAgICAgICAgICBzdGF0ZTogTG9hZGluZ1N0YXRlLkRvbmUsXG4gICAgICAgIH07XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIHJ1blF1ZXJ5PFQ+KHF1ZXJ5OiBQcm9tUXVlcnlSZXF1ZXN0LCBlbmQ6IG51bWJlciwgZmlsdGVyOiBPcGVyYXRvckZ1bmN0aW9uPGFueSwgVD4pOiBPYnNlcnZhYmxlPFQ+IHtcbiAgICBpZiAocXVlcnkuaW5zdGFudCkge1xuICAgICAgcmV0dXJuIHRoaXMucGVyZm9ybUluc3RhbnRRdWVyeShxdWVyeSwgZW5kKS5waXBlKGZpbHRlcik7XG4gICAgfVxuXG4gICAgaWYgKHF1ZXJ5LmV4ZW1wbGFyKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRFeGVtcGxhcnMocXVlcnkpLnBpcGUoXG4gICAgICAgIGNhdGNoRXJyb3IoKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBvZih7XG4gICAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICAgIHN0YXRlOiBMb2FkaW5nU3RhdGUuRG9uZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSksXG4gICAgICAgIGZpbHRlclxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wZXJmb3JtVGltZVNlcmllc1F1ZXJ5KHF1ZXJ5LCBxdWVyeS5zdGFydCwgcXVlcnkuZW5kKS5waXBlKGZpbHRlcik7XG4gIH1cblxuICBjcmVhdGVRdWVyeSh0YXJnZXQ6IFByb21RdWVyeSwgb3B0aW9uczogRGF0YVF1ZXJ5UmVxdWVzdDxQcm9tUXVlcnk+LCBzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcikge1xuICAgIGNvbnN0IHF1ZXJ5OiBQcm9tUXVlcnlSZXF1ZXN0ID0ge1xuICAgICAgaGludGluZzogdGFyZ2V0LmhpbnRpbmcsXG4gICAgICBpbnN0YW50OiB0YXJnZXQuaW5zdGFudCxcbiAgICAgIGV4ZW1wbGFyOiB0YXJnZXQuZXhlbXBsYXIsXG4gICAgICBzdGVwOiAwLFxuICAgICAgZXhwcjogJycsXG4gICAgICByZXF1ZXN0SWQ6IHRhcmdldC5yZXF1ZXN0SWQsXG4gICAgICByZWZJZDogdGFyZ2V0LnJlZklkLFxuICAgICAgc3RhcnQ6IDAsXG4gICAgICBlbmQ6IDAsXG4gICAgfTtcbiAgICBjb25zdCByYW5nZSA9IE1hdGguY2VpbChlbmQgLSBzdGFydCk7XG5cbiAgICAvLyBvcHRpb25zLmludGVydmFsIGlzIHRoZSBkeW5hbWljYWxseSBjYWxjdWxhdGVkIGludGVydmFsXG4gICAgbGV0IGludGVydmFsOiBudW1iZXIgPSByYW5nZVV0aWwuaW50ZXJ2YWxUb1NlY29uZHMob3B0aW9ucy5pbnRlcnZhbCk7XG4gICAgLy8gTWluaW11bSBpbnRlcnZhbCAoXCJNaW4gc3RlcFwiKSwgaWYgc3BlY2lmaWVkIGZvciB0aGUgcXVlcnksIG9yIHNhbWUgYXMgaW50ZXJ2YWwgb3RoZXJ3aXNlLlxuICAgIGNvbnN0IG1pbkludGVydmFsID0gcmFuZ2VVdGlsLmludGVydmFsVG9TZWNvbmRzKFxuICAgICAgdGhpcy50ZW1wbGF0ZVNydi5yZXBsYWNlKHRhcmdldC5pbnRlcnZhbCB8fCBvcHRpb25zLmludGVydmFsLCBvcHRpb25zLnNjb3BlZFZhcnMpXG4gICAgKTtcbiAgICAvLyBTY3JhcGUgaW50ZXJ2YWwgYXMgc3BlY2lmaWVkIGZvciB0aGUgcXVlcnkgKFwiTWluIHN0ZXBcIikgb3Igb3RoZXJ3aXNlIHRha2VuIGZyb20gdGhlIGRhdGFzb3VyY2UuXG4gICAgLy8gTWluIHN0ZXAgZmllbGQgY2FuIGhhdmUgdGVtcGxhdGUgdmFyaWFibGVzIGluIGl0LCBtYWtlIHN1cmUgdG8gcmVwbGFjZSBpdC5cbiAgICBjb25zdCBzY3JhcGVJbnRlcnZhbCA9IHRhcmdldC5pbnRlcnZhbFxuICAgICAgPyByYW5nZVV0aWwuaW50ZXJ2YWxUb1NlY29uZHModGhpcy50ZW1wbGF0ZVNydi5yZXBsYWNlKHRhcmdldC5pbnRlcnZhbCwgb3B0aW9ucy5zY29wZWRWYXJzKSlcbiAgICAgIDogcmFuZ2VVdGlsLmludGVydmFsVG9TZWNvbmRzKHRoaXMuaW50ZXJ2YWwpO1xuXG4gICAgY29uc3QgaW50ZXJ2YWxGYWN0b3IgPSB0YXJnZXQuaW50ZXJ2YWxGYWN0b3IgfHwgMTtcbiAgICAvLyBBZGp1c3QgdGhlIGludGVydmFsIHRvIHRha2UgaW50byBhY2NvdW50IGFueSBzcGVjaWZpZWQgbWluaW11bSBhbmQgaW50ZXJ2YWwgZmFjdG9yIHBsdXMgUHJvbWV0aGV1cyBsaW1pdHNcbiAgICBjb25zdCBhZGp1c3RlZEludGVydmFsID0gdGhpcy5hZGp1c3RJbnRlcnZhbChpbnRlcnZhbCwgbWluSW50ZXJ2YWwsIHJhbmdlLCBpbnRlcnZhbEZhY3Rvcik7XG4gICAgbGV0IHNjb3BlZFZhcnMgPSB7XG4gICAgICAuLi5vcHRpb25zLnNjb3BlZFZhcnMsXG4gICAgICAuLi50aGlzLmdldFJhbmdlU2NvcGVkVmFycyhvcHRpb25zLnJhbmdlKSxcbiAgICAgIC4uLnRoaXMuZ2V0UmF0ZUludGVydmFsU2NvcGVkVmFyaWFibGUoYWRqdXN0ZWRJbnRlcnZhbCwgc2NyYXBlSW50ZXJ2YWwpLFxuICAgIH07XG4gICAgLy8gSWYgdGhlIGludGVydmFsIHdhcyBhZGp1c3RlZCwgbWFrZSBhIHNoYWxsb3cgY29weSBvZiBzY29wZWRWYXJzIHdpdGggdXBkYXRlZCBpbnRlcnZhbCB2YXJzXG4gICAgaWYgKGludGVydmFsICE9PSBhZGp1c3RlZEludGVydmFsKSB7XG4gICAgICBpbnRlcnZhbCA9IGFkanVzdGVkSW50ZXJ2YWw7XG4gICAgICBzY29wZWRWYXJzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5zY29wZWRWYXJzLCB7XG4gICAgICAgIF9faW50ZXJ2YWw6IHsgdGV4dDogaW50ZXJ2YWwgKyAncycsIHZhbHVlOiBpbnRlcnZhbCArICdzJyB9LFxuICAgICAgICBfX2ludGVydmFsX21zOiB7IHRleHQ6IGludGVydmFsICogMTAwMCwgdmFsdWU6IGludGVydmFsICogMTAwMCB9LFxuICAgICAgICAuLi50aGlzLmdldFJhdGVJbnRlcnZhbFNjb3BlZFZhcmlhYmxlKGludGVydmFsLCBzY3JhcGVJbnRlcnZhbCksXG4gICAgICAgIC4uLnRoaXMuZ2V0UmFuZ2VTY29wZWRWYXJzKG9wdGlvbnMucmFuZ2UpLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHF1ZXJ5LnN0ZXAgPSBpbnRlcnZhbDtcblxuICAgIGxldCBleHByID0gdGFyZ2V0LmV4cHI7XG5cbiAgICAvLyBBcHBseSBhZGhvYyBmaWx0ZXJzXG4gICAgZXhwciA9IHRoaXMuZW5oYW5jZUV4cHJXaXRoQWRIb2NGaWx0ZXJzKGV4cHIpO1xuXG4gICAgLy8gT25seSByZXBsYWNlIHZhcnMgaW4gZXhwcmVzc2lvbiBhZnRlciBoYXZpbmcgKHBvc3NpYmx5KSB1cGRhdGVkIGludGVydmFsIHZhcnNcbiAgICBxdWVyeS5leHByID0gdGhpcy50ZW1wbGF0ZVNydi5yZXBsYWNlKGV4cHIsIHNjb3BlZFZhcnMsIHRoaXMuaW50ZXJwb2xhdGVRdWVyeUV4cHIpO1xuXG4gICAgLy8gQWxpZ24gcXVlcnkgaW50ZXJ2YWwgd2l0aCBzdGVwIHRvIGFsbG93IHF1ZXJ5IGNhY2hpbmcgYW5kIHRvIGVuc3VyZVxuICAgIC8vIHRoYXQgYWJvdXQtc2FtZS10aW1lIHF1ZXJ5IHJlc3VsdHMgbG9vayB0aGUgc2FtZS5cbiAgICBjb25zdCBhZGp1c3RlZCA9IGFsaWduUmFuZ2Uoc3RhcnQsIGVuZCwgcXVlcnkuc3RlcCwgdGhpcy50aW1lU3J2LnRpbWVSYW5nZSgpLnRvLnV0Y09mZnNldCgpICogNjApO1xuICAgIHF1ZXJ5LnN0YXJ0ID0gYWRqdXN0ZWQuc3RhcnQ7XG4gICAgcXVlcnkuZW5kID0gYWRqdXN0ZWQuZW5kO1xuICAgIHRoaXMuX2FkZFRyYWNpbmdIZWFkZXJzKHF1ZXJ5LCBvcHRpb25zKTtcblxuICAgIHJldHVybiBxdWVyeTtcbiAgfVxuXG4gIGdldFJhdGVJbnRlcnZhbFNjb3BlZFZhcmlhYmxlKGludGVydmFsOiBudW1iZXIsIHNjcmFwZUludGVydmFsOiBudW1iZXIpIHtcbiAgICAvLyBGYWxsIGJhY2sgdG8gdGhlIGRlZmF1bHQgc2NyYXBlIGludGVydmFsIG9mIDE1cyBpZiBzY3JhcGVJbnRlcnZhbCBpcyAwIGZvciBzb21lIHJlYXNvbi5cbiAgICBpZiAoc2NyYXBlSW50ZXJ2YWwgPT09IDApIHtcbiAgICAgIHNjcmFwZUludGVydmFsID0gMTU7XG4gICAgfVxuICAgIGNvbnN0IHJhdGVJbnRlcnZhbCA9IE1hdGgubWF4KGludGVydmFsICsgc2NyYXBlSW50ZXJ2YWwsIDQgKiBzY3JhcGVJbnRlcnZhbCk7XG4gICAgcmV0dXJuIHsgX19yYXRlX2ludGVydmFsOiB7IHRleHQ6IHJhdGVJbnRlcnZhbCArICdzJywgdmFsdWU6IHJhdGVJbnRlcnZhbCArICdzJyB9IH07XG4gIH1cblxuICBhZGp1c3RJbnRlcnZhbChpbnRlcnZhbDogbnVtYmVyLCBtaW5JbnRlcnZhbDogbnVtYmVyLCByYW5nZTogbnVtYmVyLCBpbnRlcnZhbEZhY3RvcjogbnVtYmVyKSB7XG4gICAgLy8gUHJvbWV0aGV1cyB3aWxsIGRyb3AgcXVlcmllcyB0aGF0IG1pZ2h0IHJldHVybiBtb3JlIHRoYW4gMTEwMDAgZGF0YSBwb2ludHMuXG4gICAgLy8gQ2FsY3VsYXRlIGEgc2FmZSBpbnRlcnZhbCBhcyBhbiBhZGRpdGlvbmFsIG1pbmltdW0gdG8gdGFrZSBpbnRvIGFjY291bnQuXG4gICAgLy8gRnJhY3Rpb25hbCBzYWZlSW50ZXJ2YWxzIGFyZSBhbGxvd2VkLCBob3dldmVyIHNlcnZlIGxpdHRsZSBwdXJwb3NlIGlmIHRoZSBpbnRlcnZhbCBpcyBncmVhdGVyIHRoYW4gMVxuICAgIC8vIElmIHRoaXMgaXMgdGhlIGNhc2UgdGFrZSB0aGUgY2VpbCBvZiB0aGUgdmFsdWUuXG4gICAgbGV0IHNhZmVJbnRlcnZhbCA9IHJhbmdlIC8gMTEwMDA7XG4gICAgaWYgKHNhZmVJbnRlcnZhbCA+IDEpIHtcbiAgICAgIHNhZmVJbnRlcnZhbCA9IE1hdGguY2VpbChzYWZlSW50ZXJ2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5tYXgoaW50ZXJ2YWwgKiBpbnRlcnZhbEZhY3RvciwgbWluSW50ZXJ2YWwsIHNhZmVJbnRlcnZhbCk7XG4gIH1cblxuICBwZXJmb3JtVGltZVNlcmllc1F1ZXJ5KHF1ZXJ5OiBQcm9tUXVlcnlSZXF1ZXN0LCBzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcikge1xuICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgdGhyb3cgeyBtZXNzYWdlOiAnSW52YWxpZCB0aW1lIHJhbmdlJyB9O1xuICAgIH1cblxuICAgIGNvbnN0IHVybCA9ICcvYXBpL3YxL3F1ZXJ5X3JhbmdlJztcbiAgICBjb25zdCBkYXRhOiBhbnkgPSB7XG4gICAgICBxdWVyeTogcXVlcnkuZXhwcixcbiAgICAgIHN0YXJ0LFxuICAgICAgZW5kLFxuICAgICAgc3RlcDogcXVlcnkuc3RlcCxcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMucXVlcnlUaW1lb3V0KSB7XG4gICAgICBkYXRhWyd0aW1lb3V0J10gPSB0aGlzLnF1ZXJ5VGltZW91dDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdDxQcm9tRGF0YVN1Y2Nlc3NSZXNwb25zZTxQcm9tTWF0cml4RGF0YT4+KHVybCwgZGF0YSwge1xuICAgICAgcmVxdWVzdElkOiBxdWVyeS5yZXF1ZXN0SWQsXG4gICAgICBoZWFkZXJzOiBxdWVyeS5oZWFkZXJzLFxuICAgIH0pLnBpcGUoXG4gICAgICBjYXRjaEVycm9yKChlcnI6IEZldGNoRXJyb3I8UHJvbURhdGFFcnJvclJlc3BvbnNlPFByb21NYXRyaXhEYXRhPj4pID0+IHtcbiAgICAgICAgaWYgKGVyci5jYW5jZWxsZWQpIHtcbiAgICAgICAgICByZXR1cm4gb2YoZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yKHRoaXMuaGFuZGxlRXJyb3JzKGVyciwgcXVlcnkpKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIHBlcmZvcm1JbnN0YW50UXVlcnkoXG4gICAgcXVlcnk6IFByb21RdWVyeVJlcXVlc3QsXG4gICAgdGltZTogbnVtYmVyXG4gICk6IE9ic2VydmFibGU8RmV0Y2hSZXNwb25zZTxQcm9tRGF0YVN1Y2Nlc3NSZXNwb25zZTxQcm9tVmVjdG9yRGF0YSB8IFByb21TY2FsYXJEYXRhPj4gfCBGZXRjaEVycm9yPiB7XG4gICAgY29uc3QgdXJsID0gJy9hcGkvdjEvcXVlcnknO1xuICAgIGNvbnN0IGRhdGE6IGFueSA9IHtcbiAgICAgIHF1ZXJ5OiBxdWVyeS5leHByLFxuICAgICAgdGltZSxcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMucXVlcnlUaW1lb3V0KSB7XG4gICAgICBkYXRhWyd0aW1lb3V0J10gPSB0aGlzLnF1ZXJ5VGltZW91dDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdDxQcm9tRGF0YVN1Y2Nlc3NSZXNwb25zZTxQcm9tVmVjdG9yRGF0YSB8IFByb21TY2FsYXJEYXRhPj4odXJsLCBkYXRhLCB7XG4gICAgICByZXF1ZXN0SWQ6IHF1ZXJ5LnJlcXVlc3RJZCxcbiAgICAgIGhlYWRlcnM6IHF1ZXJ5LmhlYWRlcnMsXG4gICAgfSkucGlwZShcbiAgICAgIGNhdGNoRXJyb3IoKGVycjogRmV0Y2hFcnJvcjxQcm9tRGF0YUVycm9yUmVzcG9uc2U8UHJvbVZlY3RvckRhdGEgfCBQcm9tU2NhbGFyRGF0YT4+KSA9PiB7XG4gICAgICAgIGlmIChlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgcmV0dXJuIG9mKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhyb3dFcnJvcih0aGlzLmhhbmRsZUVycm9ycyhlcnIsIHF1ZXJ5KSk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBoYW5kbGVFcnJvcnMgPSAoZXJyOiBhbnksIHRhcmdldDogUHJvbVF1ZXJ5KSA9PiB7XG4gICAgY29uc3QgZXJyb3I6IERhdGFRdWVyeUVycm9yID0ge1xuICAgICAgbWVzc2FnZTogKGVyciAmJiBlcnIuc3RhdHVzVGV4dCkgfHwgJ1Vua25vd24gZXJyb3IgZHVyaW5nIHF1ZXJ5IHRyYW5zYWN0aW9uLiBQbGVhc2UgY2hlY2sgSlMgY29uc29sZSBsb2dzLicsXG4gICAgICByZWZJZDogdGFyZ2V0LnJlZklkLFxuICAgIH07XG5cbiAgICBpZiAoZXJyLmRhdGEpIHtcbiAgICAgIGlmICh0eXBlb2YgZXJyLmRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVycm9yLm1lc3NhZ2UgPSBlcnIuZGF0YTtcbiAgICAgIH0gZWxzZSBpZiAoZXJyLmRhdGEuZXJyb3IpIHtcbiAgICAgICAgZXJyb3IubWVzc2FnZSA9IHNhZmVTdHJpbmdpZnlWYWx1ZShlcnIuZGF0YS5lcnJvcik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlcnIubWVzc2FnZSkge1xuICAgICAgZXJyb3IubWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVyciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVycm9yLm1lc3NhZ2UgPSBlcnI7XG4gICAgfVxuXG4gICAgZXJyb3Iuc3RhdHVzID0gZXJyLnN0YXR1cztcbiAgICBlcnJvci5zdGF0dXNUZXh0ID0gZXJyLnN0YXR1c1RleHQ7XG5cbiAgICByZXR1cm4gZXJyb3I7XG4gIH07XG5cbiAgbWV0cmljRmluZFF1ZXJ5KHF1ZXJ5OiBzdHJpbmcpIHtcbiAgICBpZiAoIXF1ZXJ5KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtdKTtcbiAgICB9XG5cbiAgICBjb25zdCBzY29wZWRWYXJzID0ge1xuICAgICAgX19pbnRlcnZhbDogeyB0ZXh0OiB0aGlzLmludGVydmFsLCB2YWx1ZTogdGhpcy5pbnRlcnZhbCB9LFxuICAgICAgX19pbnRlcnZhbF9tczogeyB0ZXh0OiByYW5nZVV0aWwuaW50ZXJ2YWxUb01zKHRoaXMuaW50ZXJ2YWwpLCB2YWx1ZTogcmFuZ2VVdGlsLmludGVydmFsVG9Ncyh0aGlzLmludGVydmFsKSB9LFxuICAgICAgLi4udGhpcy5nZXRSYW5nZVNjb3BlZFZhcnModGhpcy50aW1lU3J2LnRpbWVSYW5nZSgpKSxcbiAgICB9O1xuICAgIGNvbnN0IGludGVycG9sYXRlZCA9IHRoaXMudGVtcGxhdGVTcnYucmVwbGFjZShxdWVyeSwgc2NvcGVkVmFycywgdGhpcy5pbnRlcnBvbGF0ZVF1ZXJ5RXhwcik7XG4gICAgY29uc3QgbWV0cmljRmluZFF1ZXJ5ID0gbmV3IFByb21ldGhldXNNZXRyaWNGaW5kUXVlcnkodGhpcywgaW50ZXJwb2xhdGVkKTtcbiAgICByZXR1cm4gbWV0cmljRmluZFF1ZXJ5LnByb2Nlc3MoKTtcbiAgfVxuXG4gIGdldFJhbmdlU2NvcGVkVmFycyhyYW5nZTogVGltZVJhbmdlID0gdGhpcy50aW1lU3J2LnRpbWVSYW5nZSgpKSB7XG4gICAgY29uc3QgbXNSYW5nZSA9IHJhbmdlLnRvLmRpZmYocmFuZ2UuZnJvbSk7XG4gICAgY29uc3Qgc1JhbmdlID0gTWF0aC5yb3VuZChtc1JhbmdlIC8gMTAwMCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9fcmFuZ2VfbXM6IHsgdGV4dDogbXNSYW5nZSwgdmFsdWU6IG1zUmFuZ2UgfSxcbiAgICAgIF9fcmFuZ2VfczogeyB0ZXh0OiBzUmFuZ2UsIHZhbHVlOiBzUmFuZ2UgfSxcbiAgICAgIF9fcmFuZ2U6IHsgdGV4dDogc1JhbmdlICsgJ3MnLCB2YWx1ZTogc1JhbmdlICsgJ3MnIH0sXG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIGFubm90YXRpb25RdWVyeShvcHRpb25zOiBhbnkpOiBQcm9taXNlPEFubm90YXRpb25FdmVudFtdPiB7XG4gICAgY29uc3QgYW5ub3RhdGlvbiA9IG9wdGlvbnMuYW5ub3RhdGlvbjtcbiAgICBjb25zdCB7IGV4cHIgPSAnJyB9ID0gYW5ub3RhdGlvbjtcblxuICAgIGlmICghZXhwcikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RlcCA9IG9wdGlvbnMuYW5ub3RhdGlvbi5zdGVwIHx8IEFOTk9UQVRJT05fUVVFUllfU1RFUF9ERUZBVUxUO1xuICAgIGNvbnN0IHF1ZXJ5TW9kZWwgPSB7XG4gICAgICBleHByLFxuICAgICAgcmFuZ2U6IHRydWUsXG4gICAgICBpbnN0YW50OiBmYWxzZSxcbiAgICAgIGV4ZW1wbGFyOiBmYWxzZSxcbiAgICAgIGludGVydmFsOiBzdGVwLFxuICAgICAgcXVlcnlUeXBlOiBQcm9tUXVlcnlUeXBlLnRpbWVTZXJpZXNRdWVyeSxcbiAgICAgIHJlZklkOiAnWCcsXG4gICAgICBkYXRhc291cmNlOiB0aGlzLmdldFJlZigpLFxuICAgIH07XG5cbiAgICByZXR1cm4gYXdhaXQgbGFzdFZhbHVlRnJvbShcbiAgICAgIGdldEJhY2tlbmRTcnYoKVxuICAgICAgICAuZmV0Y2g8QmFja2VuZERhdGFTb3VyY2VSZXNwb25zZT4oe1xuICAgICAgICAgIHVybDogJy9hcGkvZHMvcXVlcnknLFxuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGZyb206ICh0aGlzLmdldFByb21ldGhldXNUaW1lKG9wdGlvbnMucmFuZ2UuZnJvbSwgZmFsc2UpICogMTAwMCkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHRvOiAodGhpcy5nZXRQcm9tZXRoZXVzVGltZShvcHRpb25zLnJhbmdlLnRvLCB0cnVlKSAqIDEwMDApLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBxdWVyaWVzOiBbdGhpcy5hcHBseVRlbXBsYXRlVmFyaWFibGVzKHF1ZXJ5TW9kZWwsIHt9KV0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXF1ZXN0SWQ6IGBwcm9tLXF1ZXJ5LSR7YW5ub3RhdGlvbi5uYW1lfWAsXG4gICAgICAgIH0pXG4gICAgICAgIC5waXBlKFxuICAgICAgICAgIG1hcCgocnNwOiBGZXRjaFJlc3BvbnNlPEJhY2tlbmREYXRhU291cmNlUmVzcG9uc2U+KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzQW5ub3RhdGlvblJlc3BvbnNlKG9wdGlvbnMsIHJzcC5kYXRhKTtcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgKTtcbiAgfVxuXG4gIHByb2Nlc3NBbm5vdGF0aW9uUmVzcG9uc2UgPSAob3B0aW9uczogYW55LCBkYXRhOiBCYWNrZW5kRGF0YVNvdXJjZVJlc3BvbnNlKSA9PiB7XG4gICAgY29uc3QgZnJhbWVzOiBEYXRhRnJhbWVbXSA9IHRvRGF0YVF1ZXJ5UmVzcG9uc2UoeyBkYXRhOiBkYXRhIH0pLmRhdGE7XG4gICAgaWYgKCFmcmFtZXMgfHwgIWZyYW1lcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBjb25zdCBhbm5vdGF0aW9uID0gb3B0aW9ucy5hbm5vdGF0aW9uO1xuICAgIGNvbnN0IHsgdGFnS2V5cyA9ICcnLCB0aXRsZUZvcm1hdCA9ICcnLCB0ZXh0Rm9ybWF0ID0gJycgfSA9IGFubm90YXRpb247XG5cbiAgICBjb25zdCBzdGVwID0gcmFuZ2VVdGlsLmludGVydmFsVG9TZWNvbmRzKGFubm90YXRpb24uc3RlcCB8fCBBTk5PVEFUSU9OX1FVRVJZX1NURVBfREVGQVVMVCkgKiAxMDAwO1xuICAgIGNvbnN0IHRhZ0tleXNBcnJheSA9IHRhZ0tleXMuc3BsaXQoJywnKTtcblxuICAgIGNvbnN0IGV2ZW50TGlzdDogQW5ub3RhdGlvbkV2ZW50W10gPSBbXTtcblxuICAgIGZvciAoY29uc3QgZnJhbWUgb2YgZnJhbWVzKSB7XG4gICAgICBjb25zdCB0aW1lRmllbGQgPSBmcmFtZS5maWVsZHNbMF07XG4gICAgICBjb25zdCB2YWx1ZUZpZWxkID0gZnJhbWUuZmllbGRzWzFdO1xuICAgICAgY29uc3QgbGFiZWxzID0gdmFsdWVGaWVsZD8ubGFiZWxzIHx8IHt9O1xuXG4gICAgICBjb25zdCB0YWdzID0gT2JqZWN0LmtleXMobGFiZWxzKVxuICAgICAgICAuZmlsdGVyKChsYWJlbCkgPT4gdGFnS2V5c0FycmF5LmluY2x1ZGVzKGxhYmVsKSlcbiAgICAgICAgLm1hcCgobGFiZWwpID0+IGxhYmVsc1tsYWJlbF0pO1xuXG4gICAgICBjb25zdCB0aW1lVmFsdWVUdXBsZTogQXJyYXk8W251bWJlciwgbnVtYmVyXT4gPSBbXTtcblxuICAgICAgbGV0IGlkeCA9IDA7XG4gICAgICB2YWx1ZUZpZWxkLnZhbHVlcy50b0FycmF5KCkuZm9yRWFjaCgodmFsdWU6IHN0cmluZykgPT4ge1xuICAgICAgICBsZXQgdGltZVN0YW1wVmFsdWU6IG51bWJlcjtcbiAgICAgICAgbGV0IHZhbHVlVmFsdWU6IG51bWJlcjtcbiAgICAgICAgY29uc3QgdGltZSA9IHRpbWVGaWVsZC52YWx1ZXMuZ2V0KGlkeCk7XG5cbiAgICAgICAgLy8gSWYgd2Ugd2FudCB0byB1c2UgdmFsdWUgYXMgYSB0aW1lLCB3ZSB1c2UgdmFsdWUgYXMgdGltZVN0YW1wVmFsdWUgYW5kIHZhbHVlVmFsdWUgd2lsbCBiZSAxXG4gICAgICAgIGlmIChvcHRpb25zLmFubm90YXRpb24udXNlVmFsdWVGb3JUaW1lKSB7XG4gICAgICAgICAgdGltZVN0YW1wVmFsdWUgPSBNYXRoLmZsb29yKHBhcnNlRmxvYXQodmFsdWUpKTtcbiAgICAgICAgICB2YWx1ZVZhbHVlID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aW1lU3RhbXBWYWx1ZSA9IE1hdGguZmxvb3IocGFyc2VGbG9hdCh0aW1lKSk7XG4gICAgICAgICAgdmFsdWVWYWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWR4Kys7XG4gICAgICAgIHRpbWVWYWx1ZVR1cGxlLnB1c2goW3RpbWVTdGFtcFZhbHVlLCB2YWx1ZVZhbHVlXSk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgYWN0aXZlVmFsdWVzID0gdGltZVZhbHVlVHVwbGUuZmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWVbMV0gPj0gMSk7XG4gICAgICBjb25zdCBhY3RpdmVWYWx1ZXNUaW1lc3RhbXBzID0gYWN0aXZlVmFsdWVzLm1hcCgodmFsdWUpID0+IHZhbHVlWzBdKTtcblxuICAgICAgLy8gSW5zdGVhZCBvZiBjcmVhdGluZyBzaW5ndWxhciBhbm5vdGF0aW9uIGZvciBlYWNoIGFjdGl2ZSBldmVudCB3ZSBncm91cCBldmVudHMgaW50byByZWdpb24gaWYgdGhleSBhcmUgbGVzc1xuICAgICAgLy8gb3IgZXF1YWwgdG8gYHN0ZXBgIGFwYXJ0LlxuICAgICAgbGV0IGxhdGVzdEV2ZW50OiBBbm5vdGF0aW9uRXZlbnQgfCBudWxsID0gbnVsbDtcblxuICAgICAgZm9yIChjb25zdCB0aW1lc3RhbXAgb2YgYWN0aXZlVmFsdWVzVGltZXN0YW1wcykge1xuICAgICAgICAvLyBXZSBhbHJlYWR5IGhhdmUgZXZlbnQgYG9wZW5gIGFuZCB3ZSBoYXZlIG5ldyBldmVudCB0aGF0IGlzIGluc2lkZSB0aGUgYHN0ZXBgIHNvIHdlIGp1c3QgdXBkYXRlIHRoZSBlbmQuXG4gICAgICAgIGlmIChsYXRlc3RFdmVudCAmJiAobGF0ZXN0RXZlbnQudGltZUVuZCA/PyAwKSArIHN0ZXAgPj0gdGltZXN0YW1wKSB7XG4gICAgICAgICAgbGF0ZXN0RXZlbnQudGltZUVuZCA9IHRpbWVzdGFtcDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV2ZW50IGV4aXN0cyBidXQgbmV3IG9uZSBpcyBvdXRzaWRlIG9mIHRoZSBgc3RlcGAgc28gd2UgYWRkIGl0IHRvIGV2ZW50TGlzdC5cbiAgICAgICAgaWYgKGxhdGVzdEV2ZW50KSB7XG4gICAgICAgICAgZXZlbnRMaXN0LnB1c2gobGF0ZXN0RXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2Ugc3RhcnQgYSBuZXcgcmVnaW9uLlxuICAgICAgICBsYXRlc3RFdmVudCA9IHtcbiAgICAgICAgICB0aW1lOiB0aW1lc3RhbXAsXG4gICAgICAgICAgdGltZUVuZDogdGltZXN0YW1wLFxuICAgICAgICAgIGFubm90YXRpb24sXG4gICAgICAgICAgdGl0bGU6IHJlbmRlckxlZ2VuZEZvcm1hdCh0aXRsZUZvcm1hdCwgbGFiZWxzKSxcbiAgICAgICAgICB0YWdzLFxuICAgICAgICAgIHRleHQ6IHJlbmRlckxlZ2VuZEZvcm1hdCh0ZXh0Rm9ybWF0LCBsYWJlbHMpLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAobGF0ZXN0RXZlbnQpIHtcbiAgICAgICAgLy8gRmluaXNoIHVwIGxhc3QgcG9pbnQgaWYgd2UgaGF2ZSBvbmVcbiAgICAgICAgbGF0ZXN0RXZlbnQudGltZUVuZCA9IGFjdGl2ZVZhbHVlc1RpbWVzdGFtcHNbYWN0aXZlVmFsdWVzVGltZXN0YW1wcy5sZW5ndGggLSAxXTtcbiAgICAgICAgZXZlbnRMaXN0LnB1c2gobGF0ZXN0RXZlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBldmVudExpc3Q7XG4gIH07XG5cbiAgZ2V0RXhlbXBsYXJzKHF1ZXJ5OiBQcm9tUXVlcnlSZXF1ZXN0KSB7XG4gICAgY29uc3QgdXJsID0gJy9hcGkvdjEvcXVlcnlfZXhlbXBsYXJzJztcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdDxQcm9tRGF0YVN1Y2Nlc3NSZXNwb25zZTxQcm9tRXhlbXBsYXJEYXRhPj4oXG4gICAgICB1cmwsXG4gICAgICB7IHF1ZXJ5OiBxdWVyeS5leHByLCBzdGFydDogcXVlcnkuc3RhcnQudG9TdHJpbmcoKSwgZW5kOiBxdWVyeS5lbmQudG9TdHJpbmcoKSB9LFxuICAgICAgeyByZXF1ZXN0SWQ6IHF1ZXJ5LnJlcXVlc3RJZCwgaGVhZGVyczogcXVlcnkuaGVhZGVycyB9XG4gICAgKTtcbiAgfVxuXG4gIGFzeW5jIGdldFN1YnRpdGxlKCk6IFByb21pc2U8SlNYLkVsZW1lbnQgfCBudWxsPiB7XG4gICAgY29uc3QgYnVpbGRJbmZvID0gYXdhaXQgdGhpcy5nZXRCdWlsZEluZm8oKTtcbiAgICByZXR1cm4gYnVpbGRJbmZvID8gdGhpcy5nZXRCdWlsZEluZm9NZXNzYWdlKGJ1aWxkSW5mbykgOiBudWxsO1xuICB9XG5cbiAgYXN5bmMgZ2V0VGFnS2V5cyhvcHRpb25zPzogYW55KSB7XG4gICAgaWYgKG9wdGlvbnM/LnNlcmllcykge1xuICAgICAgLy8gR2V0IHRhZ3MgZm9yIHRoZSBwcm92aWRlZCBzZXJpZXMgb25seVxuICAgICAgY29uc3Qgc2VyaWVzTGFiZWxzOiBBcnJheTxSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT4+ID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIG9wdGlvbnMuc2VyaWVzLm1hcCgoc2VyaWVzOiBzdHJpbmcpID0+IHRoaXMubGFuZ3VhZ2VQcm92aWRlci5mZXRjaFNlcmllc0xhYmVscyhzZXJpZXMpKVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHVuaXF1ZUxhYmVscyA9IFsuLi5uZXcgU2V0KC4uLnNlcmllc0xhYmVscy5tYXAoKHZhbHVlKSA9PiBPYmplY3Qua2V5cyh2YWx1ZSkpKV07XG4gICAgICByZXR1cm4gdW5pcXVlTGFiZWxzLm1hcCgodmFsdWU6IGFueSkgPT4gKHsgdGV4dDogdmFsdWUgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBHZXQgYWxsIHRhZ3NcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMubWV0YWRhdGFSZXF1ZXN0KCcvYXBpL3YxL2xhYmVscycpO1xuICAgICAgcmV0dXJuIHJlc3VsdD8uZGF0YT8uZGF0YT8ubWFwKCh2YWx1ZTogYW55KSA9PiAoeyB0ZXh0OiB2YWx1ZSB9KSkgPz8gW107XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2V0VGFnVmFsdWVzKG9wdGlvbnM6IHsga2V5Pzogc3RyaW5nIH0gPSB7fSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMubWV0YWRhdGFSZXF1ZXN0KGAvYXBpL3YxL2xhYmVsLyR7b3B0aW9ucy5rZXl9L3ZhbHVlc2ApO1xuICAgIHJldHVybiByZXN1bHQ/LmRhdGE/LmRhdGE/Lm1hcCgodmFsdWU6IGFueSkgPT4gKHsgdGV4dDogdmFsdWUgfSkpID8/IFtdO1xuICB9XG5cbiAgYXN5bmMgZ2V0QnVpbGRJbmZvKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBidWlsZEluZm8gPSBhd2FpdCBmZXRjaERhdGFTb3VyY2VCdWlsZEluZm8odGhpcyk7XG4gICAgICByZXR1cm4gYnVpbGRJbmZvO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRvIGJyZWFrIHRoZSByZXN0IG9mIGZ1bmN0aW9uYWxpdHkgaWYgYnVpbGQgaW5mbyBkb2VzIG5vdCB3b3JrIGNvcnJlY3RseVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICBnZXRCdWlsZEluZm9NZXNzYWdlKGJ1aWxkSW5mbzogUHJvbUJ1aWxkSW5mbykge1xuICAgIGNvbnN0IGVuYWJsZWQgPSA8QmFkZ2UgY29sb3I9XCJncmVlblwiIGljb249XCJjaGVja1wiIHRleHQ9XCJSdWxlciBBUEkgZW5hYmxlZFwiIC8+O1xuICAgIGNvbnN0IGRpc2FibGVkID0gPEJhZGdlIGNvbG9yPVwib3JhbmdlXCIgaWNvbj1cImV4Y2xhbWF0aW9uLXRyaWFuZ2xlXCIgdGV4dD1cIlJ1bGVyIEFQSSBub3QgZW5hYmxlZFwiIC8+O1xuICAgIGNvbnN0IHVuc3VwcG9ydGVkID0gKFxuICAgICAgPFRvb2x0aXBcbiAgICAgICAgcGxhY2VtZW50PVwidG9wXCJcbiAgICAgICAgY29udGVudD1cIlByb21ldGhldXMgZG9lcyBub3QgYWxsb3cgZWRpdGluZyBydWxlcywgY29ubmVjdCB0byBlaXRoZXIgYSBNaW1pciBvciBDb3J0ZXggZGF0YXNvdXJjZSB0byBtYW5hZ2UgYWxlcnRzIHZpYSBHcmFmYW5hLlwiXG4gICAgICA+XG4gICAgICAgIDxkaXY+XG4gICAgICAgICAgPEJhZGdlIGNvbG9yPVwicmVkXCIgaWNvbj1cImV4Y2xhbWF0aW9uLXRyaWFuZ2xlXCIgdGV4dD1cIlJ1bGVyIEFQSSBub3Qgc3VwcG9ydGVkXCIgLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L1Rvb2x0aXA+XG4gICAgKTtcblxuICAgIGNvbnN0IExPR09TID0ge1xuICAgICAgW1Byb21BcHBsaWNhdGlvbi5Db3J0ZXhdOiAnL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvaW1nL2NvcnRleF9sb2dvLnN2ZycsXG4gICAgICBbUHJvbUFwcGxpY2F0aW9uLk1pbWlyXTogJy9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL2ltZy9taW1pcl9sb2dvLnN2ZycsXG4gICAgICBbUHJvbUFwcGxpY2F0aW9uLlByb21ldGhldXNdOiAnL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvaW1nL3Byb21ldGhldXNfbG9nby5zdmcnLFxuICAgIH07XG5cbiAgICBjb25zdCBDT0xPUlM6IFJlY29yZDxQcm9tQXBwbGljYXRpb24sIEJhZGdlQ29sb3I+ID0ge1xuICAgICAgW1Byb21BcHBsaWNhdGlvbi5Db3J0ZXhdOiAnYmx1ZScsXG4gICAgICBbUHJvbUFwcGxpY2F0aW9uLk1pbWlyXTogJ29yYW5nZScsXG4gICAgICBbUHJvbUFwcGxpY2F0aW9uLlByb21ldGhldXNdOiAncmVkJyxcbiAgICB9O1xuXG4gICAgLy8gdGhpcyB3aWxsIGluZm9ybSB0aGUgdXNlciBhYm91dCB3aGF0IFwic3VidHlwZVwiIHRoZSBkYXRhc291cmNlIGlzOyBNaW1pciwgQ29ydGV4IG9yIHZhbmlsbGEgUHJvbWV0aGV1c1xuICAgIGNvbnN0IGFwcGxpY2F0aW9uU3ViVHlwZSA9IChcbiAgICAgIDxCYWRnZVxuICAgICAgICB0ZXh0PXtcbiAgICAgICAgICA8c3Bhbj5cbiAgICAgICAgICAgIDxpbWdcbiAgICAgICAgICAgICAgc3R5bGU9e3sgd2lkdGg6IDE0LCBoZWlnaHQ6IDE0LCB2ZXJ0aWNhbEFsaWduOiAndGV4dC1ib3R0b20nIH19XG4gICAgICAgICAgICAgIHNyYz17TE9HT1NbYnVpbGRJbmZvLmFwcGxpY2F0aW9uID8/IFByb21BcHBsaWNhdGlvbi5Qcm9tZXRoZXVzXX1cbiAgICAgICAgICAgIC8+eycgJ31cbiAgICAgICAgICAgIHtidWlsZEluZm8uYXBwbGljYXRpb259XG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICB9XG4gICAgICAgIGNvbG9yPXtDT0xPUlNbYnVpbGRJbmZvLmFwcGxpY2F0aW9uID8/IFByb21BcHBsaWNhdGlvbi5Qcm9tZXRoZXVzXX1cbiAgICAgIC8+XG4gICAgKTtcblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2XG4gICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgZGlzcGxheTogJ2dyaWQnLFxuICAgICAgICAgIGdyaWRUZW1wbGF0ZUNvbHVtbnM6ICdtYXgtY29udGVudCBtYXgtY29udGVudCcsXG4gICAgICAgICAgcm93R2FwOiAnMC41cmVtJyxcbiAgICAgICAgICBjb2x1bW5HYXA6ICcycmVtJyxcbiAgICAgICAgICBtYXJnaW5Ub3A6ICcxcmVtJyxcbiAgICAgICAgfX1cbiAgICAgID5cbiAgICAgICAgPGRpdj5UeXBlPC9kaXY+XG4gICAgICAgIDxkaXY+e2FwcGxpY2F0aW9uU3ViVHlwZX08L2Rpdj5cbiAgICAgICAgPD5cbiAgICAgICAgICA8ZGl2PlJ1bGVyIEFQSTwvZGl2PlxuICAgICAgICAgIHsvKiBQcm9tZXRoZXVzIGRvZXMgbm90IGhhdmUgYSBSdWxlciBBUEkg4oCTIHNvIHNob3cgdGhhdCBpdCBpcyBub3Qgc3VwcG9ydGVkICovfVxuICAgICAgICAgIHtidWlsZEluZm8uYXBwbGljYXRpb24gPT09IFByb21BcHBsaWNhdGlvbi5Qcm9tZXRoZXVzICYmIDxkaXY+e3Vuc3VwcG9ydGVkfTwvZGl2Pn1cbiAgICAgICAgICB7YnVpbGRJbmZvLmFwcGxpY2F0aW9uICE9PSBQcm9tQXBwbGljYXRpb24uUHJvbWV0aGV1cyAmJiAoXG4gICAgICAgICAgICA8ZGl2PntidWlsZEluZm8uZmVhdHVyZXMucnVsZXJBcGlFbmFibGVkID8gZW5hYmxlZCA6IGRpc2FibGVkfTwvZGl2PlxuICAgICAgICAgICl9XG4gICAgICAgIDwvPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIGFzeW5jIHRlc3REYXRhc291cmNlKCkge1xuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIGNvbnN0IHJlcXVlc3Q6IERhdGFRdWVyeVJlcXVlc3Q8UHJvbVF1ZXJ5PiA9IHtcbiAgICAgIHRhcmdldHM6IFt7IHJlZklkOiAndGVzdCcsIGV4cHI6ICcxKzEnLCBpbnN0YW50OiB0cnVlIH1dLFxuICAgICAgcmVxdWVzdElkOiBgJHt0aGlzLmlkfS1oZWFsdGhgLFxuICAgICAgc2NvcGVkVmFyczoge30sXG4gICAgICBkYXNoYm9hcmRJZDogMCxcbiAgICAgIHBhbmVsSWQ6IDAsXG4gICAgICBpbnRlcnZhbDogJzFtJyxcbiAgICAgIGludGVydmFsTXM6IDYwMDAwLFxuICAgICAgbWF4RGF0YVBvaW50czogMSxcbiAgICAgIHJhbmdlOiB7XG4gICAgICAgIGZyb206IGRhdGVUaW1lKG5vdyAtIDEwMDApLFxuICAgICAgICB0bzogZGF0ZVRpbWUobm93KSxcbiAgICAgIH0sXG4gICAgfSBhcyBEYXRhUXVlcnlSZXF1ZXN0PFByb21RdWVyeT47XG5cbiAgICBjb25zdCBidWlsZEluZm8gPSBhd2FpdCB0aGlzLmdldEJ1aWxkSW5mbygpO1xuXG4gICAgcmV0dXJuIGxhc3RWYWx1ZUZyb20odGhpcy5xdWVyeShyZXF1ZXN0KSlcbiAgICAgIC50aGVuKChyZXM6IERhdGFRdWVyeVJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGlmICghcmVzIHx8ICFyZXMuZGF0YSB8fCByZXMuc3RhdGUgIT09IExvYWRpbmdTdGF0ZS5Eb25lKSB7XG4gICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiAnZXJyb3InLCBtZXNzYWdlOiBgRXJyb3IgcmVhZGluZyBQcm9tZXRoZXVzOiAke3Jlcz8uZXJyb3I/Lm1lc3NhZ2V9YCB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0dXM6ICdzdWNjZXNzJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdEYXRhIHNvdXJjZSBpcyB3b3JraW5nJyxcbiAgICAgICAgICAgIGRldGFpbHM6IGJ1aWxkSW5mbyAmJiB7XG4gICAgICAgICAgICAgIHZlcmJvc2VNZXNzYWdlOiB0aGlzLmdldEJ1aWxkSW5mb01lc3NhZ2UoYnVpbGRJbmZvKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyOiBhbnkpID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcignUHJvbWV0aGV1cyBFcnJvcicsIGVycik7XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogJ2Vycm9yJywgbWVzc2FnZTogZXJyLm1lc3NhZ2UgfTtcbiAgICAgIH0pO1xuICB9XG5cbiAgaW50ZXJwb2xhdGVWYXJpYWJsZXNJblF1ZXJpZXMocXVlcmllczogUHJvbVF1ZXJ5W10sIHNjb3BlZFZhcnM6IFNjb3BlZFZhcnMpOiBQcm9tUXVlcnlbXSB7XG4gICAgbGV0IGV4cGFuZGVkUXVlcmllcyA9IHF1ZXJpZXM7XG4gICAgaWYgKHF1ZXJpZXMgJiYgcXVlcmllcy5sZW5ndGgpIHtcbiAgICAgIGV4cGFuZGVkUXVlcmllcyA9IHF1ZXJpZXMubWFwKChxdWVyeSkgPT4ge1xuICAgICAgICBjb25zdCBleHBhbmRlZFF1ZXJ5ID0ge1xuICAgICAgICAgIC4uLnF1ZXJ5LFxuICAgICAgICAgIGRhdGFzb3VyY2U6IHRoaXMuZ2V0UmVmKCksXG4gICAgICAgICAgZXhwcjogdGhpcy50ZW1wbGF0ZVNydi5yZXBsYWNlKHF1ZXJ5LmV4cHIsIHNjb3BlZFZhcnMsIHRoaXMuaW50ZXJwb2xhdGVRdWVyeUV4cHIpLFxuICAgICAgICAgIGludGVydmFsOiB0aGlzLnRlbXBsYXRlU3J2LnJlcGxhY2UocXVlcnkuaW50ZXJ2YWwsIHNjb3BlZFZhcnMpLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZXhwYW5kZWRRdWVyeTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZXhwYW5kZWRRdWVyaWVzO1xuICB9XG5cbiAgZ2V0UXVlcnlIaW50cyhxdWVyeTogUHJvbVF1ZXJ5LCByZXN1bHQ6IGFueVtdKSB7XG4gICAgcmV0dXJuIGdldFF1ZXJ5SGludHMocXVlcnkuZXhwciA/PyAnJywgcmVzdWx0LCB0aGlzKTtcbiAgfVxuXG4gIGdldEluaXRIaW50cygpIHtcbiAgICByZXR1cm4gZ2V0SW5pdEhpbnRzKHRoaXMpO1xuICB9XG5cbiAgYXN5bmMgbG9hZFJ1bGVzKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLm1ldGFkYXRhUmVxdWVzdCgnL2FwaS92MS9ydWxlcycpO1xuICAgICAgY29uc3QgZ3JvdXBzID0gcmVzLmRhdGE/LmRhdGE/Lmdyb3VwcztcblxuICAgICAgaWYgKGdyb3Vwcykge1xuICAgICAgICB0aGlzLnJ1bGVNYXBwaW5ncyA9IGV4dHJhY3RSdWxlTWFwcGluZ0Zyb21Hcm91cHMoZ3JvdXBzKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmxvZygnUnVsZXMgQVBJIGlzIGV4cGVyaW1lbnRhbC4gSWdub3JlIG5leHQgZXJyb3IuJyk7XG4gICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGFyZUV4ZW1wbGFyc0F2YWlsYWJsZSgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5tZXRhZGF0YVJlcXVlc3QoJy9hcGkvdjEvcXVlcnlfZXhlbXBsYXJzJywgeyBxdWVyeTogJ3Rlc3QnIH0pO1xuICAgICAgaWYgKHJlcy5kYXRhLnN0YXR1cyA9PT0gJ3N1Y2Nlc3MnKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIG1vZGlmeVF1ZXJ5KHF1ZXJ5OiBQcm9tUXVlcnksIGFjdGlvbjogYW55KTogUHJvbVF1ZXJ5IHtcbiAgICBsZXQgZXhwcmVzc2lvbiA9IHF1ZXJ5LmV4cHIgPz8gJyc7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgY2FzZSAnQUREX0ZJTFRFUic6IHtcbiAgICAgICAgZXhwcmVzc2lvbiA9IGFkZExhYmVsVG9RdWVyeShleHByZXNzaW9uLCBhY3Rpb24ua2V5LCBhY3Rpb24udmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ0FERF9GSUxURVJfT1VUJzoge1xuICAgICAgICBleHByZXNzaW9uID0gYWRkTGFiZWxUb1F1ZXJ5KGV4cHJlc3Npb24sIGFjdGlvbi5rZXksIGFjdGlvbi52YWx1ZSwgJyE9Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnQUREX0hJU1RPR1JBTV9RVUFOVElMRSc6IHtcbiAgICAgICAgZXhwcmVzc2lvbiA9IGBoaXN0b2dyYW1fcXVhbnRpbGUoMC45NSwgc3VtKHJhdGUoJHtleHByZXNzaW9ufVskX19yYXRlX2ludGVydmFsXSkpIGJ5IChsZSkpYDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICdBRERfUkFURSc6IHtcbiAgICAgICAgZXhwcmVzc2lvbiA9IGByYXRlKCR7ZXhwcmVzc2lvbn1bJF9fcmF0ZV9pbnRlcnZhbF0pYDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICdBRERfU1VNJzoge1xuICAgICAgICBleHByZXNzaW9uID0gYHN1bSgke2V4cHJlc3Npb24udHJpbSgpfSkgYnkgKCQxKWA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnRVhQQU5EX1JVTEVTJzoge1xuICAgICAgICBpZiAoYWN0aW9uLm1hcHBpbmcpIHtcbiAgICAgICAgICBleHByZXNzaW9uID0gZXhwYW5kUmVjb3JkaW5nUnVsZXMoZXhwcmVzc2lvbiwgYWN0aW9uLm1hcHBpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiB7IC4uLnF1ZXJ5LCBleHByOiBleHByZXNzaW9uIH07XG4gIH1cblxuICBnZXRQcm9tZXRoZXVzVGltZShkYXRlOiBzdHJpbmcgfCBEYXRlVGltZSwgcm91bmRVcDogYm9vbGVhbikge1xuICAgIGlmICh0eXBlb2YgZGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGRhdGUgPSBkYXRlTWF0aC5wYXJzZShkYXRlLCByb3VuZFVwKSE7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGguY2VpbChkYXRlLnZhbHVlT2YoKSAvIDEwMDApO1xuICB9XG5cbiAgZ2V0VGltZVJhbmdlUGFyYW1zKCk6IHsgc3RhcnQ6IHN0cmluZzsgZW5kOiBzdHJpbmcgfSB7XG4gICAgY29uc3QgcmFuZ2UgPSB0aGlzLnRpbWVTcnYudGltZVJhbmdlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiB0aGlzLmdldFByb21ldGhldXNUaW1lKHJhbmdlLmZyb20sIGZhbHNlKS50b1N0cmluZygpLFxuICAgICAgZW5kOiB0aGlzLmdldFByb21ldGhldXNUaW1lKHJhbmdlLnRvLCB0cnVlKS50b1N0cmluZygpLFxuICAgIH07XG4gIH1cblxuICBnZXRPcmlnaW5hbE1ldHJpY05hbWUobGFiZWxEYXRhOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9KSB7XG4gICAgcmV0dXJuIGdldE9yaWdpbmFsTWV0cmljTmFtZShsYWJlbERhdGEpO1xuICB9XG5cbiAgZW5oYW5jZUV4cHJXaXRoQWRIb2NGaWx0ZXJzKGV4cHI6IHN0cmluZykge1xuICAgIGNvbnN0IGFkaG9jRmlsdGVycyA9IHRoaXMudGVtcGxhdGVTcnYuZ2V0QWRob2NGaWx0ZXJzKHRoaXMubmFtZSk7XG5cbiAgICBjb25zdCBmaW5hbFF1ZXJ5ID0gYWRob2NGaWx0ZXJzLnJlZHVjZSgoYWNjOiBzdHJpbmcsIGZpbHRlcjogeyBrZXk/OiBhbnk7IG9wZXJhdG9yPzogYW55OyB2YWx1ZT86IGFueSB9KSA9PiB7XG4gICAgICBjb25zdCB7IGtleSwgb3BlcmF0b3IgfSA9IGZpbHRlcjtcbiAgICAgIGxldCB7IHZhbHVlIH0gPSBmaWx0ZXI7XG4gICAgICBpZiAob3BlcmF0b3IgPT09ICc9ficgfHwgb3BlcmF0b3IgPT09ICchficpIHtcbiAgICAgICAgdmFsdWUgPSBwcm9tZXRoZXVzUmVndWxhckVzY2FwZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWRkTGFiZWxUb1F1ZXJ5KGFjYywga2V5LCB2YWx1ZSwgb3BlcmF0b3IpO1xuICAgIH0sIGV4cHIpO1xuICAgIHJldHVybiBmaW5hbFF1ZXJ5O1xuICB9XG5cbiAgLy8gVXNlZCB3aGVuIHJ1bm5pbmcgcXVlcmllcyB0cm91Z2ggYmFja2VuZFxuICBmaWx0ZXJRdWVyeShxdWVyeTogUHJvbVF1ZXJ5KTogYm9vbGVhbiB7XG4gICAgaWYgKHF1ZXJ5LmhpZGUgfHwgIXF1ZXJ5LmV4cHIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBVc2VkIHdoZW4gcnVubmluZyBxdWVyaWVzIHRyb3VnaCBiYWNrZW5kXG4gIGFwcGx5VGVtcGxhdGVWYXJpYWJsZXModGFyZ2V0OiBQcm9tUXVlcnksIHNjb3BlZFZhcnM6IFNjb3BlZFZhcnMpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgICBjb25zdCB2YXJpYWJsZXMgPSBjbG9uZURlZXAoc2NvcGVkVmFycyk7XG5cbiAgICAvLyBXZSB3YW50IHRvIGludGVycG9sYXRlIHRoZXNlIHZhcmlhYmxlcyBvbiBiYWNrZW5kXG4gICAgZGVsZXRlIHZhcmlhYmxlcy5fX2ludGVydmFsO1xuICAgIGRlbGV0ZSB2YXJpYWJsZXMuX19pbnRlcnZhbF9tcztcblxuICAgIC8vQWRkIGFkIGhvYyBmaWx0ZXJzXG4gICAgY29uc3QgZXhwciA9IHRoaXMuZW5oYW5jZUV4cHJXaXRoQWRIb2NGaWx0ZXJzKHRhcmdldC5leHByKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi50YXJnZXQsXG4gICAgICBsZWdlbmRGb3JtYXQ6IHRoaXMudGVtcGxhdGVTcnYucmVwbGFjZSh0YXJnZXQubGVnZW5kRm9ybWF0LCB2YXJpYWJsZXMpLFxuICAgICAgZXhwcjogdGhpcy50ZW1wbGF0ZVNydi5yZXBsYWNlKGV4cHIsIHZhcmlhYmxlcywgdGhpcy5pbnRlcnBvbGF0ZVF1ZXJ5RXhwciksXG4gICAgICBpbnRlcnZhbDogdGhpcy50ZW1wbGF0ZVNydi5yZXBsYWNlKHRhcmdldC5pbnRlcnZhbCwgdmFyaWFibGVzKSxcbiAgICB9O1xuICB9XG5cbiAgZ2V0VmFyaWFibGVzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy50ZW1wbGF0ZVNydi5nZXRWYXJpYWJsZXMoKS5tYXAoKHYpID0+IGAkJHt2Lm5hbWV9YCk7XG4gIH1cblxuICBpbnRlcnBvbGF0ZVN0cmluZyhzdHJpbmc6IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLnRlbXBsYXRlU3J2LnJlcGxhY2Uoc3RyaW5nLCB1bmRlZmluZWQsIHRoaXMuaW50ZXJwb2xhdGVRdWVyeUV4cHIpO1xuICB9XG59XG5cbi8qKlxuICogQWxpZ24gcXVlcnkgcmFuZ2UgdG8gc3RlcC5cbiAqIFJvdW5kcyBzdGFydCBhbmQgZW5kIGRvd24gdG8gYSBtdWx0aXBsZSBvZiBzdGVwLlxuICogQHBhcmFtIHN0YXJ0IFRpbWVzdGFtcCBtYXJraW5nIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHJhbmdlLlxuICogQHBhcmFtIGVuZCBUaW1lc3RhbXAgbWFya2luZyB0aGUgZW5kIG9mIHRoZSByYW5nZS5cbiAqIEBwYXJhbSBzdGVwIEludGVydmFsIHRvIGFsaWduIHN0YXJ0IGFuZCBlbmQgd2l0aC5cbiAqIEBwYXJhbSB1dGNPZmZzZXRTZWMgTnVtYmVyIG9mIHNlY29uZHMgY3VycmVudCB0aW1lem9uZSBpcyBvZmZzZXQgZnJvbSBVVENcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFsaWduUmFuZ2UoXG4gIHN0YXJ0OiBudW1iZXIsXG4gIGVuZDogbnVtYmVyLFxuICBzdGVwOiBudW1iZXIsXG4gIHV0Y09mZnNldFNlYzogbnVtYmVyXG4pOiB7IGVuZDogbnVtYmVyOyBzdGFydDogbnVtYmVyIH0ge1xuICBjb25zdCBhbGlnbmVkRW5kID0gTWF0aC5mbG9vcigoZW5kICsgdXRjT2Zmc2V0U2VjKSAvIHN0ZXApICogc3RlcCAtIHV0Y09mZnNldFNlYztcbiAgY29uc3QgYWxpZ25lZFN0YXJ0ID0gTWF0aC5mbG9vcigoc3RhcnQgKyB1dGNPZmZzZXRTZWMpIC8gc3RlcCkgKiBzdGVwIC0gdXRjT2Zmc2V0U2VjO1xuICByZXR1cm4ge1xuICAgIGVuZDogYWxpZ25lZEVuZCxcbiAgICBzdGFydDogYWxpZ25lZFN0YXJ0LFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFJ1bGVNYXBwaW5nRnJvbUdyb3Vwcyhncm91cHM6IGFueVtdKSB7XG4gIHJldHVybiBncm91cHMucmVkdWNlKFxuICAgIChtYXBwaW5nLCBncm91cCkgPT5cbiAgICAgIGdyb3VwLnJ1bGVzXG4gICAgICAgIC5maWx0ZXIoKHJ1bGU6IGFueSkgPT4gcnVsZS50eXBlID09PSAncmVjb3JkaW5nJylcbiAgICAgICAgLnJlZHVjZShcbiAgICAgICAgICAoYWNjOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9LCBydWxlOiBhbnkpID0+ICh7XG4gICAgICAgICAgICAuLi5hY2MsXG4gICAgICAgICAgICBbcnVsZS5uYW1lXTogcnVsZS5xdWVyeSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBtYXBwaW5nXG4gICAgICAgICksXG4gICAge31cbiAgKTtcbn1cblxuLy8gTk9URTogdGhlc2UgdHdvIGZ1bmN0aW9ucyBhcmUgdmVyeSBzaW1pbGFyIHRvIHRoZSBlc2NhcGVMYWJlbFZhbHVlSW4qIGZ1bmN0aW9uc1xuLy8gaW4gbGFuZ3VhZ2VfdXRpbHMudHMsIGJ1dCB0aGV5IGFyZSBub3QgZXhhY3RseSB0aGUgc2FtZSBhbGdvcml0aG0sIGFuZCB3ZSBmb3VuZFxuLy8gbm8gd2F5IHRvIHJldXNlIG9uZSBpbiB0aGUgYW5vdGhlciBvciB2aWNlIHZlcnNhLlxuZXhwb3J0IGZ1bmN0aW9uIHByb21ldGhldXNSZWd1bGFyRXNjYXBlKHZhbHVlOiBhbnkpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZS5yZXBsYWNlKC9cXFxcL2csICdcXFxcXFxcXCcpLnJlcGxhY2UoLycvZywgXCJcXFxcXFxcXCdcIikgOiB2YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb21ldGhldXNTcGVjaWFsUmVnZXhFc2NhcGUodmFsdWU6IGFueSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHZhbHVlLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcXFxcXFxcXFwnKS5yZXBsYWNlKC9bJF4qe31cXFtcXF1cXCcrPy4oKXxdL2csICdcXFxcXFxcXCQmJykgOiB2YWx1ZTtcbn1cbiIsImltcG9ydCB7IG9uY2UsIGNoYWluLCBkaWZmZXJlbmNlIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBMUlUgZnJvbSAnbHJ1LWNhY2hlJztcbmltcG9ydCBQcmlzbSBmcm9tICdwcmlzbWpzJztcbmltcG9ydCB7IFZhbHVlIH0gZnJvbSAnc2xhdGUnO1xuXG5pbXBvcnQge1xuICBBYnN0cmFjdExhYmVsTWF0Y2hlcixcbiAgQWJzdHJhY3RMYWJlbE9wZXJhdG9yLFxuICBBYnN0cmFjdFF1ZXJ5LFxuICBkYXRlVGltZSxcbiAgSGlzdG9yeUl0ZW0sXG4gIExhbmd1YWdlUHJvdmlkZXIsXG59IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgQ29tcGxldGlvbkl0ZW0sIENvbXBsZXRpb25JdGVtR3JvdXAsIFNlYXJjaEZ1bmN0aW9uVHlwZSwgVHlwZWFoZWFkSW5wdXQsIFR5cGVhaGVhZE91dHB1dCB9IGZyb20gJ0BncmFmYW5hL3VpJztcblxuaW1wb3J0IHsgUHJvbWV0aGV1c0RhdGFzb3VyY2UgfSBmcm9tICcuL2RhdGFzb3VyY2UnO1xuaW1wb3J0IHtcbiAgYWRkTGltaXRJbmZvLFxuICBleHRyYWN0TGFiZWxNYXRjaGVycyxcbiAgZml4U3VtbWFyaWVzTWV0YWRhdGEsXG4gIHBhcnNlU2VsZWN0b3IsXG4gIHByb2Nlc3NIaXN0b2dyYW1NZXRyaWNzLFxuICBwcm9jZXNzTGFiZWxzLFxuICByb3VuZFNlY1RvTWluLFxuICB0b1Byb21MaWtlUXVlcnksXG59IGZyb20gJy4vbGFuZ3VhZ2VfdXRpbHMnO1xuaW1wb3J0IFByb21xbFN5bnRheCwgeyBGVU5DVElPTlMsIFJBVEVfUkFOR0VTIH0gZnJvbSAnLi9wcm9tcWwnO1xuaW1wb3J0IHsgUHJvbU1ldHJpY3NNZXRhZGF0YSwgUHJvbVF1ZXJ5IH0gZnJvbSAnLi90eXBlcyc7XG5cbmNvbnN0IERFRkFVTFRfS0VZUyA9IFsnam9iJywgJ2luc3RhbmNlJ107XG5jb25zdCBFTVBUWV9TRUxFQ1RPUiA9ICd7fSc7XG5jb25zdCBISVNUT1JZX0lURU1fQ09VTlQgPSA1O1xuY29uc3QgSElTVE9SWV9DT1VOVF9DVVRPRkYgPSAxMDAwICogNjAgKiA2MCAqIDI0OyAvLyAyNGhcbi8vIE1heCBudW1iZXIgb2YgaXRlbXMgKG1ldHJpY3MsIGxhYmVscywgdmFsdWVzKSB0aGF0IHdlIGRpc3BsYXkgYXMgc3VnZ2VzdGlvbnMuIFByZXZlbnRzIGZyb20gcnVubmluZyBvdXQgb2YgbWVtb3J5LlxuZXhwb3J0IGNvbnN0IFNVR0dFU1RJT05TX0xJTUlUID0gMTAwMDA7XG5cbmNvbnN0IHdyYXBMYWJlbCA9IChsYWJlbDogc3RyaW5nKTogQ29tcGxldGlvbkl0ZW0gPT4gKHsgbGFiZWwgfSk7XG5cbmNvbnN0IHNldEZ1bmN0aW9uS2luZCA9IChzdWdnZXN0aW9uOiBDb21wbGV0aW9uSXRlbSk6IENvbXBsZXRpb25JdGVtID0+IHtcbiAgc3VnZ2VzdGlvbi5raW5kID0gJ2Z1bmN0aW9uJztcbiAgcmV0dXJuIHN1Z2dlc3Rpb247XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkSGlzdG9yeU1ldGFkYXRhKGl0ZW06IENvbXBsZXRpb25JdGVtLCBoaXN0b3J5OiBhbnlbXSk6IENvbXBsZXRpb25JdGVtIHtcbiAgY29uc3QgY3V0b2ZmVHMgPSBEYXRlLm5vdygpIC0gSElTVE9SWV9DT1VOVF9DVVRPRkY7XG4gIGNvbnN0IGhpc3RvcnlGb3JJdGVtID0gaGlzdG9yeS5maWx0ZXIoKGgpID0+IGgudHMgPiBjdXRvZmZUcyAmJiBoLnF1ZXJ5ID09PSBpdGVtLmxhYmVsKTtcbiAgY29uc3QgY291bnQgPSBoaXN0b3J5Rm9ySXRlbS5sZW5ndGg7XG4gIGNvbnN0IHJlY2VudCA9IGhpc3RvcnlGb3JJdGVtWzBdO1xuICBsZXQgaGludCA9IGBRdWVyaWVkICR7Y291bnR9IHRpbWVzIGluIHRoZSBsYXN0IDI0aC5gO1xuXG4gIGlmIChyZWNlbnQpIHtcbiAgICBjb25zdCBsYXN0UXVlcmllZCA9IGRhdGVUaW1lKHJlY2VudC50cykuZnJvbU5vdygpO1xuICAgIGhpbnQgPSBgJHtoaW50fSBMYXN0IHF1ZXJpZWQgJHtsYXN0UXVlcmllZH0uYDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLi4uaXRlbSxcbiAgICBkb2N1bWVudGF0aW9uOiBoaW50LFxuICB9O1xufVxuXG5mdW5jdGlvbiBhZGRNZXRyaWNzTWV0YWRhdGEobWV0cmljOiBzdHJpbmcsIG1ldGFkYXRhPzogUHJvbU1ldHJpY3NNZXRhZGF0YSk6IENvbXBsZXRpb25JdGVtIHtcbiAgY29uc3QgaXRlbTogQ29tcGxldGlvbkl0ZW0gPSB7IGxhYmVsOiBtZXRyaWMgfTtcbiAgaWYgKG1ldGFkYXRhICYmIG1ldGFkYXRhW21ldHJpY10pIHtcbiAgICBpdGVtLmRvY3VtZW50YXRpb24gPSBnZXRNZXRhZGF0YVN0cmluZyhtZXRyaWMsIG1ldGFkYXRhKTtcbiAgfVxuICByZXR1cm4gaXRlbTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1ldGFkYXRhU3RyaW5nKG1ldHJpYzogc3RyaW5nLCBtZXRhZGF0YTogUHJvbU1ldHJpY3NNZXRhZGF0YSk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIGlmICghbWV0YWRhdGFbbWV0cmljXSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3QgeyB0eXBlLCBoZWxwIH0gPSBtZXRhZGF0YVttZXRyaWNdO1xuICByZXR1cm4gYCR7dHlwZS50b1VwcGVyQ2FzZSgpfTogJHtoZWxwfWA7XG59XG5cbmNvbnN0IFBSRUZJWF9ERUxJTUlURVJfUkVHRVggPVxuICAvKD1cInwhPVwifD1+XCJ8IX5cInxcXHt8XFxbfFxcKHxcXCt8LXxcXC98XFwqfCV8XFxefFxcYmFuZFxcYnxcXGJvclxcYnxcXGJ1bmxlc3NcXGJ8PT18Pj18IT18PD18Pnw8fD18fnwsKS87XG5cbmludGVyZmFjZSBBdXRvY29tcGxldGVDb250ZXh0IHtcbiAgaGlzdG9yeT86IEFycmF5PEhpc3RvcnlJdGVtPFByb21RdWVyeT4+O1xufVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJvbVFsTGFuZ3VhZ2VQcm92aWRlciBleHRlbmRzIExhbmd1YWdlUHJvdmlkZXIge1xuICBoaXN0b2dyYW1NZXRyaWNzOiBzdHJpbmdbXTtcbiAgdGltZVJhbmdlPzogeyBzdGFydDogbnVtYmVyOyBlbmQ6IG51bWJlciB9O1xuICBtZXRyaWNzOiBzdHJpbmdbXTtcbiAgbWV0cmljc01ldGFkYXRhPzogUHJvbU1ldHJpY3NNZXRhZGF0YTtcbiAgZGVjbGFyZSBzdGFydFRhc2s6IFByb21pc2U8YW55PjtcbiAgZGF0YXNvdXJjZTogUHJvbWV0aGV1c0RhdGFzb3VyY2U7XG4gIGxhYmVsS2V5czogc3RyaW5nW10gPSBbXTtcbiAgZGVjbGFyZSBsYWJlbEZldGNoVHM6IG51bWJlcjtcblxuICAvKipcbiAgICogIENhY2hlIGZvciBsYWJlbHMgb2Ygc2VyaWVzLiBUaGlzIGlzIGJpdCBzaW1wbGlzdGljIGluIHRoZSBzZW5zZSB0aGF0IGl0IGp1c3QgY291bnRzIHJlc3BvbnNlcyBlYWNoIGFzIGEgMSBhbmQgZG9lc1xuICAgKiAgbm90IGFjY291bnQgZm9yIGRpZmZlcmVudCBzaXplIG9mIGEgcmVzcG9uc2UuIElmIHRoYXQgaXMgbmVlZGVkIGEgYGxlbmd0aGAgZnVuY3Rpb24gY2FuIGJlIGFkZGVkIGluIHRoZSBvcHRpb25zLlxuICAgKiAgMTAgYXMgYSBtYXggc2l6ZSBpcyB0b3RhbGx5IGFyYml0cmFyeSByaWdodCBub3cuXG4gICAqL1xuICBwcml2YXRlIGxhYmVsc0NhY2hlID0gbmV3IExSVTxzdHJpbmcsIFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPj4oeyBtYXg6IDEwIH0pO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGFzb3VyY2U6IFByb21ldGhldXNEYXRhc291cmNlLCBpbml0aWFsVmFsdWVzPzogUGFydGlhbDxQcm9tUWxMYW5ndWFnZVByb3ZpZGVyPikge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmRhdGFzb3VyY2UgPSBkYXRhc291cmNlO1xuICAgIHRoaXMuaGlzdG9ncmFtTWV0cmljcyA9IFtdO1xuICAgIHRoaXMudGltZVJhbmdlID0geyBzdGFydDogMCwgZW5kOiAwIH07XG4gICAgdGhpcy5tZXRyaWNzID0gW107XG5cbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIGluaXRpYWxWYWx1ZXMpO1xuICB9XG5cbiAgLy8gU3RyaXAgc3ludGF4IGNoYXJzIHNvIHRoYXQgdHlwZWFoZWFkIHN1Z2dlc3Rpb25zIGNhbiB3b3JrIG9uIGNsZWFuIGlucHV0c1xuICBjbGVhblRleHQoczogc3RyaW5nKSB7XG4gICAgY29uc3QgcGFydHMgPSBzLnNwbGl0KFBSRUZJWF9ERUxJTUlURVJfUkVHRVgpO1xuICAgIGNvbnN0IGxhc3QgPSBwYXJ0cy5wb3AoKSE7XG4gICAgcmV0dXJuIGxhc3QudHJpbUxlZnQoKS5yZXBsYWNlKC9cIiQvLCAnJykucmVwbGFjZSgvXlwiLywgJycpO1xuICB9XG5cbiAgZ2V0IHN5bnRheCgpIHtcbiAgICByZXR1cm4gUHJvbXFsU3ludGF4O1xuICB9XG5cbiAgcmVxdWVzdCA9IGFzeW5jICh1cmw6IHN0cmluZywgZGVmYXVsdFZhbHVlOiBhbnksIHBhcmFtcyA9IHt9KTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5kYXRhc291cmNlLm1ldGFkYXRhUmVxdWVzdCh1cmwsIHBhcmFtcyk7XG4gICAgICByZXR1cm4gcmVzLmRhdGEuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgfTtcblxuICBzdGFydCA9IGFzeW5jICgpOiBQcm9taXNlPGFueVtdPiA9PiB7XG4gICAgaWYgKHRoaXMuZGF0YXNvdXJjZS5sb29rdXBzRGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICAvLyBUT0RPICMzMzk3NjogbWFrZSB0aG9zZSByZXF1ZXN0cyBwYXJhbGxlbFxuICAgIGF3YWl0IHRoaXMuZmV0Y2hMYWJlbHMoKTtcbiAgICB0aGlzLm1ldHJpY3MgPSAoYXdhaXQgdGhpcy5mZXRjaExhYmVsVmFsdWVzKCdfX25hbWVfXycpKSB8fCBbXTtcbiAgICBhd2FpdCB0aGlzLmxvYWRNZXRyaWNzTWV0YWRhdGEoKTtcbiAgICB0aGlzLmhpc3RvZ3JhbU1ldHJpY3MgPSBwcm9jZXNzSGlzdG9ncmFtTWV0cmljcyh0aGlzLm1ldHJpY3MpLnNvcnQoKTtcbiAgICByZXR1cm4gW107XG4gIH07XG5cbiAgYXN5bmMgbG9hZE1ldHJpY3NNZXRhZGF0YSgpIHtcbiAgICB0aGlzLm1ldHJpY3NNZXRhZGF0YSA9IGZpeFN1bW1hcmllc01ldGFkYXRhKGF3YWl0IHRoaXMucmVxdWVzdCgnL2FwaS92MS9tZXRhZGF0YScsIHt9KSk7XG4gIH1cblxuICBnZXRMYWJlbEtleXMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiB0aGlzLmxhYmVsS2V5cztcbiAgfVxuXG4gIHByb3ZpZGVDb21wbGV0aW9uSXRlbXMgPSBhc3luYyAoXG4gICAgeyBwcmVmaXgsIHRleHQsIHZhbHVlLCBsYWJlbEtleSwgd3JhcHBlckNsYXNzZXMgfTogVHlwZWFoZWFkSW5wdXQsXG4gICAgY29udGV4dDogQXV0b2NvbXBsZXRlQ29udGV4dCA9IHt9XG4gICk6IFByb21pc2U8VHlwZWFoZWFkT3V0cHV0PiA9PiB7XG4gICAgY29uc3QgZW1wdHlSZXN1bHQ6IFR5cGVhaGVhZE91dHB1dCA9IHsgc3VnZ2VzdGlvbnM6IFtdIH07XG5cbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4gZW1wdHlSZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gTG9jYWwgdGV4dCBwcm9wZXJ0aWVzXG4gICAgY29uc3QgZW1wdHkgPSB2YWx1ZS5kb2N1bWVudC50ZXh0Lmxlbmd0aCA9PT0gMDtcbiAgICBjb25zdCBzZWxlY3RlZExpbmVzID0gdmFsdWUuZG9jdW1lbnQuZ2V0VGV4dHNBdFJhbmdlKHZhbHVlLnNlbGVjdGlvbik7XG4gICAgY29uc3QgY3VycmVudExpbmUgPSBzZWxlY3RlZExpbmVzLnNpemUgPT09IDEgPyBzZWxlY3RlZExpbmVzLmZpcnN0KCkuZ2V0VGV4dCgpIDogbnVsbDtcblxuICAgIGNvbnN0IG5leHRDaGFyYWN0ZXIgPSBjdXJyZW50TGluZSA/IGN1cnJlbnRMaW5lW3ZhbHVlLnNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0XSA6IG51bGw7XG5cbiAgICAvLyBTeW50YXggc3BhbnMgaGF2ZSAzIGNsYXNzZXMgYnkgZGVmYXVsdC4gTW9yZSBpbmRpY2F0ZSBhIHJlY29nbml6ZWQgdG9rZW5cbiAgICBjb25zdCB0b2tlblJlY29nbml6ZWQgPSB3cmFwcGVyQ2xhc3Nlcy5sZW5ndGggPiAzO1xuICAgIC8vIE5vbi1lbXB0eSBwcmVmaXgsIGJ1dCBub3QgaW5zaWRlIGtub3duIHRva2VuXG4gICAgY29uc3QgcHJlZml4VW5yZWNvZ25pemVkID0gcHJlZml4ICYmICF0b2tlblJlY29nbml6ZWQ7XG5cbiAgICAvLyBQcmV2ZW50IHN1Z2dlc3Rpb25zIGluIGBmdW5jdGlvbih8c3VmZml4KWBcbiAgICBjb25zdCBub1N1ZmZpeCA9ICFuZXh0Q2hhcmFjdGVyIHx8IG5leHRDaGFyYWN0ZXIgPT09ICcpJztcblxuICAgIC8vIFByZWZpeCBpcyBzYWZlIGlmIGl0IGRvZXMgbm90IGltbWVkaWF0ZWx5IGZvbGxvdyBhIGNvbXBsZXRlIGV4cHJlc3Npb24gYW5kIGhhcyBubyB0ZXh0IGFmdGVyIGl0XG4gICAgY29uc3Qgc2FmZVByZWZpeCA9IHByZWZpeCAmJiAhdGV4dC5tYXRjaCgvXltcXF19KVxcc10rJC8pICYmIG5vU3VmZml4O1xuXG4gICAgLy8gQWJvdXQgdG8gdHlwZSBuZXh0IG9wZXJhbmQgaWYgcHJlY2VkZWQgYnkgYmluYXJ5IG9wZXJhdG9yXG4gICAgY29uc3Qgb3BlcmF0b3JzUGF0dGVybiA9IC9bK1xcLSovXiVdLztcbiAgICBjb25zdCBpc05leHRPcGVyYW5kID0gdGV4dC5tYXRjaChvcGVyYXRvcnNQYXR0ZXJuKTtcblxuICAgIC8vIERldGVybWluZSBjYW5kaWRhdGVzIGJ5IENTUyBjb250ZXh0XG4gICAgaWYgKHdyYXBwZXJDbGFzc2VzLmluY2x1ZGVzKCdjb250ZXh0LXJhbmdlJykpIHtcbiAgICAgIC8vIFN1Z2dlc3Rpb25zIGZvciBtZXRyaWNbfF1cbiAgICAgIHJldHVybiB0aGlzLmdldFJhbmdlQ29tcGxldGlvbkl0ZW1zKCk7XG4gICAgfSBlbHNlIGlmICh3cmFwcGVyQ2xhc3Nlcy5pbmNsdWRlcygnY29udGV4dC1sYWJlbHMnKSkge1xuICAgICAgLy8gU3VnZ2VzdGlvbnMgZm9yIG1ldHJpY3t8fSBhbmQgbWV0cmlje2Zvbz18fSwgYXMgd2VsbCBhcyBtZXRyaWMtaW5kZXBlbmRlbnQgbGFiZWwgcXVlcmllcyBsaWtlIHt8fVxuICAgICAgcmV0dXJuIHRoaXMuZ2V0TGFiZWxDb21wbGV0aW9uSXRlbXMoeyBwcmVmaXgsIHRleHQsIHZhbHVlLCBsYWJlbEtleSwgd3JhcHBlckNsYXNzZXMgfSk7XG4gICAgfSBlbHNlIGlmICh3cmFwcGVyQ2xhc3Nlcy5pbmNsdWRlcygnY29udGV4dC1hZ2dyZWdhdGlvbicpKSB7XG4gICAgICAvLyBTdWdnZXN0aW9ucyBmb3Igc3VtKG1ldHJpYykgYnkgKHwpXG4gICAgICByZXR1cm4gdGhpcy5nZXRBZ2dyZWdhdGlvbkNvbXBsZXRpb25JdGVtcyh2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChlbXB0eSkge1xuICAgICAgLy8gU3VnZ2VzdGlvbnMgZm9yIGVtcHR5IHF1ZXJ5IGZpZWxkXG4gICAgICByZXR1cm4gdGhpcy5nZXRFbXB0eUNvbXBsZXRpb25JdGVtcyhjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKHByZWZpeFVucmVjb2duaXplZCAmJiBub1N1ZmZpeCAmJiAhaXNOZXh0T3BlcmFuZCkge1xuICAgICAgLy8gU2hvdyB0ZXJtIHN1Z2dlc3Rpb25zIGluIGEgY291cGxlIG9mIHNjZW5hcmlvc1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0QmVnaW5uaW5nQ29tcGxldGlvbkl0ZW1zKGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAocHJlZml4VW5yZWNvZ25pemVkICYmIHNhZmVQcmVmaXgpIHtcbiAgICAgIC8vIFNob3cgdGVybSBzdWdnZXN0aW9ucyBpbiBhIGNvdXBsZSBvZiBzY2VuYXJpb3NcbiAgICAgIHJldHVybiB0aGlzLmdldFRlcm1Db21wbGV0aW9uSXRlbXMoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW1wdHlSZXN1bHQ7XG4gIH07XG5cbiAgZ2V0QmVnaW5uaW5nQ29tcGxldGlvbkl0ZW1zID0gKGNvbnRleHQ6IEF1dG9jb21wbGV0ZUNvbnRleHQpOiBUeXBlYWhlYWRPdXRwdXQgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBzdWdnZXN0aW9uczogWy4uLnRoaXMuZ2V0RW1wdHlDb21wbGV0aW9uSXRlbXMoY29udGV4dCkuc3VnZ2VzdGlvbnMsIC4uLnRoaXMuZ2V0VGVybUNvbXBsZXRpb25JdGVtcygpLnN1Z2dlc3Rpb25zXSxcbiAgICB9O1xuICB9O1xuXG4gIGdldEVtcHR5Q29tcGxldGlvbkl0ZW1zID0gKGNvbnRleHQ6IEF1dG9jb21wbGV0ZUNvbnRleHQpOiBUeXBlYWhlYWRPdXRwdXQgPT4ge1xuICAgIGNvbnN0IHsgaGlzdG9yeSB9ID0gY29udGV4dDtcbiAgICBjb25zdCBzdWdnZXN0aW9uczogQ29tcGxldGlvbkl0ZW1Hcm91cFtdID0gW107XG5cbiAgICBpZiAoaGlzdG9yeSAmJiBoaXN0b3J5Lmxlbmd0aCkge1xuICAgICAgY29uc3QgaGlzdG9yeUl0ZW1zID0gY2hhaW4oaGlzdG9yeSlcbiAgICAgICAgLm1hcCgoaCkgPT4gaC5xdWVyeS5leHByKVxuICAgICAgICAuZmlsdGVyKClcbiAgICAgICAgLnVuaXEoKVxuICAgICAgICAudGFrZShISVNUT1JZX0lURU1fQ09VTlQpXG4gICAgICAgIC5tYXAod3JhcExhYmVsKVxuICAgICAgICAubWFwKChpdGVtKSA9PiBhZGRIaXN0b3J5TWV0YWRhdGEoaXRlbSwgaGlzdG9yeSkpXG4gICAgICAgIC52YWx1ZSgpO1xuXG4gICAgICBzdWdnZXN0aW9ucy5wdXNoKHtcbiAgICAgICAgc2VhcmNoRnVuY3Rpb25UeXBlOiBTZWFyY2hGdW5jdGlvblR5cGUuUHJlZml4LFxuICAgICAgICBza2lwU29ydDogdHJ1ZSxcbiAgICAgICAgbGFiZWw6ICdIaXN0b3J5JyxcbiAgICAgICAgaXRlbXM6IGhpc3RvcnlJdGVtcyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB7IHN1Z2dlc3Rpb25zIH07XG4gIH07XG5cbiAgZ2V0VGVybUNvbXBsZXRpb25JdGVtcyA9ICgpOiBUeXBlYWhlYWRPdXRwdXQgPT4ge1xuICAgIGNvbnN0IHsgbWV0cmljcywgbWV0cmljc01ldGFkYXRhIH0gPSB0aGlzO1xuICAgIGNvbnN0IHN1Z2dlc3Rpb25zOiBDb21wbGV0aW9uSXRlbUdyb3VwW10gPSBbXTtcblxuICAgIHN1Z2dlc3Rpb25zLnB1c2goe1xuICAgICAgc2VhcmNoRnVuY3Rpb25UeXBlOiBTZWFyY2hGdW5jdGlvblR5cGUuUHJlZml4LFxuICAgICAgbGFiZWw6ICdGdW5jdGlvbnMnLFxuICAgICAgaXRlbXM6IEZVTkNUSU9OUy5tYXAoc2V0RnVuY3Rpb25LaW5kKSxcbiAgICB9KTtcblxuICAgIGlmIChtZXRyaWNzICYmIG1ldHJpY3MubGVuZ3RoKSB7XG4gICAgICBzdWdnZXN0aW9ucy5wdXNoKHtcbiAgICAgICAgbGFiZWw6ICdNZXRyaWNzJyxcbiAgICAgICAgaXRlbXM6IG1ldHJpY3MubWFwKChtKSA9PiBhZGRNZXRyaWNzTWV0YWRhdGEobSwgbWV0cmljc01ldGFkYXRhKSksXG4gICAgICAgIHNlYXJjaEZ1bmN0aW9uVHlwZTogU2VhcmNoRnVuY3Rpb25UeXBlLkZ1enp5LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgc3VnZ2VzdGlvbnMgfTtcbiAgfTtcblxuICBnZXRSYW5nZUNvbXBsZXRpb25JdGVtcygpOiBUeXBlYWhlYWRPdXRwdXQge1xuICAgIHJldHVybiB7XG4gICAgICBjb250ZXh0OiAnY29udGV4dC1yYW5nZScsXG4gICAgICBzdWdnZXN0aW9uczogW1xuICAgICAgICB7XG4gICAgICAgICAgbGFiZWw6ICdSYW5nZSB2ZWN0b3InLFxuICAgICAgICAgIGl0ZW1zOiBbLi4uUkFURV9SQU5HRVNdLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICB9O1xuICB9XG5cbiAgZ2V0QWdncmVnYXRpb25Db21wbGV0aW9uSXRlbXMgPSBhc3luYyAodmFsdWU6IFZhbHVlKTogUHJvbWlzZTxUeXBlYWhlYWRPdXRwdXQ+ID0+IHtcbiAgICBjb25zdCBzdWdnZXN0aW9uczogQ29tcGxldGlvbkl0ZW1Hcm91cFtdID0gW107XG5cbiAgICAvLyBTdGl0Y2ggYWxsIHF1ZXJ5IGxpbmVzIHRvZ2V0aGVyIHRvIHN1cHBvcnQgbXVsdGktbGluZSBxdWVyaWVzXG4gICAgbGV0IHF1ZXJ5T2Zmc2V0O1xuICAgIGNvbnN0IHF1ZXJ5VGV4dCA9IHZhbHVlLmRvY3VtZW50LmdldEJsb2NrcygpLnJlZHVjZSgodGV4dCwgYmxvY2spID0+IHtcbiAgICAgIGlmICh0ZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgaWYgKCFibG9jaykge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYmxvY2tUZXh0ID0gYmxvY2s/LmdldFRleHQoKTtcblxuICAgICAgaWYgKHZhbHVlLmFuY2hvckJsb2NrLmtleSA9PT0gYmxvY2sua2V5KSB7XG4gICAgICAgIC8vIE5ld2xpbmUgY2hhcmFjdGVycyBhcmUgbm90IGFjY291bnRlZCBmb3IgYnV0IHRoaXMgaXMgaXJyZWxldmFudFxuICAgICAgICAvLyBmb3IgdGhlIHB1cnBvc2Ugb2YgZXh0cmFjdGluZyB0aGUgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgIHF1ZXJ5T2Zmc2V0ID0gdmFsdWUuc2VsZWN0aW9uLmFuY2hvci5vZmZzZXQgKyB0ZXh0Lmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRleHQgKyBibG9ja1RleHQ7XG4gICAgfSwgJycpO1xuXG4gICAgLy8gVHJ5IHNlYXJjaCBmb3Igc2VsZWN0b3IgcGFydCBvbiB0aGUgbGVmdC1oYW5kIHNpZGUsIHN1Y2ggYXMgYHN1bSAobSkgYnkgKGwpYFxuICAgIGNvbnN0IG9wZW5QYXJlbnNBZ2dyZWdhdGlvbkluZGV4ID0gcXVlcnlUZXh0Lmxhc3RJbmRleE9mKCcoJywgcXVlcnlPZmZzZXQpO1xuICAgIGxldCBvcGVuUGFyZW5zU2VsZWN0b3JJbmRleCA9IHF1ZXJ5VGV4dC5sYXN0SW5kZXhPZignKCcsIG9wZW5QYXJlbnNBZ2dyZWdhdGlvbkluZGV4IC0gMSk7XG4gICAgbGV0IGNsb3NlUGFyZW5zU2VsZWN0b3JJbmRleCA9IHF1ZXJ5VGV4dC5pbmRleE9mKCcpJywgb3BlblBhcmVuc1NlbGVjdG9ySW5kZXgpO1xuXG4gICAgLy8gVHJ5IHNlYXJjaCBmb3Igc2VsZWN0b3IgcGFydCBvZiBhbiBhbHRlcm5hdGUgYWdncmVnYXRpb24gY2xhdXNlLCBzdWNoIGFzIGBzdW0gYnkgKGwpIChtKWBcbiAgICBpZiAob3BlblBhcmVuc1NlbGVjdG9ySW5kZXggPT09IC0xKSB7XG4gICAgICBjb25zdCBjbG9zZVBhcmVuc0FnZ3JlZ2F0aW9uSW5kZXggPSBxdWVyeVRleHQuaW5kZXhPZignKScsIHF1ZXJ5T2Zmc2V0KTtcbiAgICAgIGNsb3NlUGFyZW5zU2VsZWN0b3JJbmRleCA9IHF1ZXJ5VGV4dC5pbmRleE9mKCcpJywgY2xvc2VQYXJlbnNBZ2dyZWdhdGlvbkluZGV4ICsgMSk7XG4gICAgICBvcGVuUGFyZW5zU2VsZWN0b3JJbmRleCA9IHF1ZXJ5VGV4dC5sYXN0SW5kZXhPZignKCcsIGNsb3NlUGFyZW5zU2VsZWN0b3JJbmRleCk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgc3VnZ2VzdGlvbnMsXG4gICAgICBjb250ZXh0OiAnY29udGV4dC1hZ2dyZWdhdGlvbicsXG4gICAgfTtcblxuICAgIC8vIFN1Z2dlc3Rpb25zIGFyZSB1c2VsZXNzIGZvciBhbHRlcm5hdGl2ZSBhZ2dyZWdhdGlvbiBjbGF1c2VzIHdpdGhvdXQgYSBzZWxlY3RvciBpbiBjb250ZXh0XG4gICAgaWYgKG9wZW5QYXJlbnNTZWxlY3RvckluZGV4ID09PSAtMSkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBSYW5nZSB2ZWN0b3Igc3ludGF4IG5vdCBhY2NvdW50ZWQgZm9yIGJ5IHN1YnNlcXVlbnQgcGFyc2Ugc28gZGlzY2FyZCBpdCBpZiBwcmVzZW50XG4gICAgY29uc3Qgc2VsZWN0b3JTdHJpbmcgPSBxdWVyeVRleHRcbiAgICAgIC5zbGljZShvcGVuUGFyZW5zU2VsZWN0b3JJbmRleCArIDEsIGNsb3NlUGFyZW5zU2VsZWN0b3JJbmRleClcbiAgICAgIC5yZXBsYWNlKC9cXFtbXlxcXV0rXFxdJC8sICcnKTtcblxuICAgIGNvbnN0IHNlbGVjdG9yID0gcGFyc2VTZWxlY3RvcihzZWxlY3RvclN0cmluZywgc2VsZWN0b3JTdHJpbmcubGVuZ3RoIC0gMikuc2VsZWN0b3I7XG5cbiAgICBjb25zdCBzZXJpZXMgPSBhd2FpdCB0aGlzLmdldFNlcmllcyhzZWxlY3Rvcik7XG4gICAgY29uc3QgbGFiZWxLZXlzID0gT2JqZWN0LmtleXMoc2VyaWVzKTtcbiAgICBpZiAobGFiZWxLZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGxpbWl0SW5mbyA9IGFkZExpbWl0SW5mbyhsYWJlbEtleXMpO1xuICAgICAgc3VnZ2VzdGlvbnMucHVzaCh7XG4gICAgICAgIGxhYmVsOiBgTGFiZWxzJHtsaW1pdEluZm99YCxcbiAgICAgICAgaXRlbXM6IGxhYmVsS2V5cy5tYXAod3JhcExhYmVsKSxcbiAgICAgICAgc2VhcmNoRnVuY3Rpb25UeXBlOiBTZWFyY2hGdW5jdGlvblR5cGUuRnV6enksXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBnZXRMYWJlbENvbXBsZXRpb25JdGVtcyA9IGFzeW5jICh7XG4gICAgdGV4dCxcbiAgICB3cmFwcGVyQ2xhc3NlcyxcbiAgICBsYWJlbEtleSxcbiAgICB2YWx1ZSxcbiAgfTogVHlwZWFoZWFkSW5wdXQpOiBQcm9taXNlPFR5cGVhaGVhZE91dHB1dD4gPT4ge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybiB7IHN1Z2dlc3Rpb25zOiBbXSB9O1xuICAgIH1cblxuICAgIGNvbnN0IHN1Z2dlc3Rpb25zOiBDb21wbGV0aW9uSXRlbUdyb3VwW10gPSBbXTtcbiAgICBjb25zdCBsaW5lID0gdmFsdWUuYW5jaG9yQmxvY2suZ2V0VGV4dCgpO1xuICAgIGNvbnN0IGN1cnNvck9mZnNldCA9IHZhbHVlLnNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0O1xuICAgIGNvbnN0IHN1ZmZpeCA9IGxpbmUuc3Vic3RyKGN1cnNvck9mZnNldCk7XG4gICAgY29uc3QgcHJlZml4ID0gbGluZS5zdWJzdHIoMCwgY3Vyc29yT2Zmc2V0KTtcbiAgICBjb25zdCBpc1ZhbHVlU3RhcnQgPSB0ZXh0Lm1hdGNoKC9eKD18PX58IT18IX4pLyk7XG4gICAgY29uc3QgaXNWYWx1ZUVuZCA9IHN1ZmZpeC5tYXRjaCgvXlwiP1ssfV18JC8pO1xuICAgIC8vIERldGVjdCBjdXJzb3IgaW4gZnJvbnQgb2YgdmFsdWUsIGUuZy4sIHtrZXk9fFwifVxuICAgIGNvbnN0IGlzUHJlVmFsdWUgPSBwcmVmaXgubWF0Y2goLyg9fD1+fCE9fCF+KSQvKSAmJiBzdWZmaXgubWF0Y2goL15cIi8pO1xuXG4gICAgLy8gRG9uJ3Qgc3VnZ2VzdCBhbnl0aGluZyBhdCB0aGUgYmVnaW5uaW5nIG9yIGluc2lkZSBhIHZhbHVlXG4gICAgY29uc3QgaXNWYWx1ZUVtcHR5ID0gaXNWYWx1ZVN0YXJ0ICYmIGlzVmFsdWVFbmQ7XG4gICAgY29uc3QgaGFzVmFsdWVQcmVmaXggPSBpc1ZhbHVlRW5kICYmICFpc1ZhbHVlU3RhcnQ7XG4gICAgaWYgKCghaXNWYWx1ZUVtcHR5ICYmICFoYXNWYWx1ZVByZWZpeCkgfHwgaXNQcmVWYWx1ZSkge1xuICAgICAgcmV0dXJuIHsgc3VnZ2VzdGlvbnMgfTtcbiAgICB9XG5cbiAgICAvLyBHZXQgbm9ybWFsaXplZCBzZWxlY3RvclxuICAgIGxldCBzZWxlY3RvcjtcbiAgICBsZXQgcGFyc2VkU2VsZWN0b3I7XG4gICAgdHJ5IHtcbiAgICAgIHBhcnNlZFNlbGVjdG9yID0gcGFyc2VTZWxlY3RvcihsaW5lLCBjdXJzb3JPZmZzZXQpO1xuICAgICAgc2VsZWN0b3IgPSBwYXJzZWRTZWxlY3Rvci5zZWxlY3RvcjtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHNlbGVjdG9yID0gRU1QVFlfU0VMRUNUT1I7XG4gICAgfVxuXG4gICAgY29uc3QgY29udGFpbnNNZXRyaWMgPSBzZWxlY3Rvci5pbmNsdWRlcygnX19uYW1lX189Jyk7XG4gICAgY29uc3QgZXhpc3RpbmdLZXlzID0gcGFyc2VkU2VsZWN0b3IgPyBwYXJzZWRTZWxlY3Rvci5sYWJlbEtleXMgOiBbXTtcblxuICAgIGxldCBzZXJpZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPiA9IHt9O1xuICAgIC8vIFF1ZXJ5IGxhYmVscyBmb3Igc2VsZWN0b3JcbiAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgIHNlcmllcyA9IGF3YWl0IHRoaXMuZ2V0U2VyaWVzKHNlbGVjdG9yLCAhY29udGFpbnNNZXRyaWMpO1xuICAgIH1cblxuICAgIGlmIChPYmplY3Qua2V5cyhzZXJpZXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc29sZS53YXJuKGBTZXJ2ZXIgZGlkIG5vdCByZXR1cm4gYW55IHZhbHVlcyBmb3Igc2VsZWN0b3IgPSAke3NlbGVjdG9yfWApO1xuICAgICAgcmV0dXJuIHsgc3VnZ2VzdGlvbnMgfTtcbiAgICB9XG5cbiAgICBsZXQgY29udGV4dDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4gICAgaWYgKCh0ZXh0ICYmIGlzVmFsdWVTdGFydCkgfHwgd3JhcHBlckNsYXNzZXMuaW5jbHVkZXMoJ2F0dHItdmFsdWUnKSkge1xuICAgICAgLy8gTGFiZWwgdmFsdWVzXG4gICAgICBpZiAobGFiZWxLZXkgJiYgc2VyaWVzW2xhYmVsS2V5XSkge1xuICAgICAgICBjb250ZXh0ID0gJ2NvbnRleHQtbGFiZWwtdmFsdWVzJztcbiAgICAgICAgY29uc3QgbGltaXRJbmZvID0gYWRkTGltaXRJbmZvKHNlcmllc1tsYWJlbEtleV0pO1xuICAgICAgICBzdWdnZXN0aW9ucy5wdXNoKHtcbiAgICAgICAgICBsYWJlbDogYExhYmVsIHZhbHVlcyBmb3IgXCIke2xhYmVsS2V5fVwiJHtsaW1pdEluZm99YCxcbiAgICAgICAgICBpdGVtczogc2VyaWVzW2xhYmVsS2V5XS5tYXAod3JhcExhYmVsKSxcbiAgICAgICAgICBzZWFyY2hGdW5jdGlvblR5cGU6IFNlYXJjaEZ1bmN0aW9uVHlwZS5GdXp6eSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIExhYmVsIGtleXNcbiAgICAgIGNvbnN0IGxhYmVsS2V5cyA9IHNlcmllcyA/IE9iamVjdC5rZXlzKHNlcmllcykgOiBjb250YWluc01ldHJpYyA/IG51bGwgOiBERUZBVUxUX0tFWVM7XG5cbiAgICAgIGlmIChsYWJlbEtleXMpIHtcbiAgICAgICAgY29uc3QgcG9zc2libGVLZXlzID0gZGlmZmVyZW5jZShsYWJlbEtleXMsIGV4aXN0aW5nS2V5cyk7XG4gICAgICAgIGlmIChwb3NzaWJsZUtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgY29udGV4dCA9ICdjb250ZXh0LWxhYmVscyc7XG4gICAgICAgICAgY29uc3QgbmV3SXRlbXMgPSBwb3NzaWJsZUtleXMubWFwKChrZXkpID0+ICh7IGxhYmVsOiBrZXkgfSkpO1xuICAgICAgICAgIGNvbnN0IGxpbWl0SW5mbyA9IGFkZExpbWl0SW5mbyhuZXdJdGVtcyk7XG4gICAgICAgICAgY29uc3QgbmV3U3VnZ2VzdGlvbjogQ29tcGxldGlvbkl0ZW1Hcm91cCA9IHtcbiAgICAgICAgICAgIGxhYmVsOiBgTGFiZWxzJHtsaW1pdEluZm99YCxcbiAgICAgICAgICAgIGl0ZW1zOiBuZXdJdGVtcyxcbiAgICAgICAgICAgIHNlYXJjaEZ1bmN0aW9uVHlwZTogU2VhcmNoRnVuY3Rpb25UeXBlLkZ1enp5LFxuICAgICAgICAgIH07XG4gICAgICAgICAgc3VnZ2VzdGlvbnMucHVzaChuZXdTdWdnZXN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IGNvbnRleHQsIHN1Z2dlc3Rpb25zIH07XG4gIH07XG5cbiAgaW1wb3J0RnJvbUFic3RyYWN0UXVlcnkobGFiZWxCYXNlZFF1ZXJ5OiBBYnN0cmFjdFF1ZXJ5KTogUHJvbVF1ZXJ5IHtcbiAgICByZXR1cm4gdG9Qcm9tTGlrZVF1ZXJ5KGxhYmVsQmFzZWRRdWVyeSk7XG4gIH1cblxuICBleHBvcnRUb0Fic3RyYWN0UXVlcnkocXVlcnk6IFByb21RdWVyeSk6IEFic3RyYWN0UXVlcnkge1xuICAgIGNvbnN0IHByb21RdWVyeSA9IHF1ZXJ5LmV4cHI7XG4gICAgaWYgKCFwcm9tUXVlcnkgfHwgcHJvbVF1ZXJ5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHsgcmVmSWQ6IHF1ZXJ5LnJlZklkLCBsYWJlbE1hdGNoZXJzOiBbXSB9O1xuICAgIH1cbiAgICBjb25zdCB0b2tlbnMgPSBQcmlzbS50b2tlbml6ZShwcm9tUXVlcnksIFByb21xbFN5bnRheCk7XG4gICAgY29uc3QgbGFiZWxNYXRjaGVyczogQWJzdHJhY3RMYWJlbE1hdGNoZXJbXSA9IGV4dHJhY3RMYWJlbE1hdGNoZXJzKHRva2Vucyk7XG4gICAgY29uc3QgbmFtZUxhYmVsVmFsdWUgPSBnZXROYW1lTGFiZWxWYWx1ZShwcm9tUXVlcnksIHRva2Vucyk7XG4gICAgaWYgKG5hbWVMYWJlbFZhbHVlICYmIG5hbWVMYWJlbFZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgIGxhYmVsTWF0Y2hlcnMucHVzaCh7XG4gICAgICAgIG5hbWU6ICdfX25hbWVfXycsXG4gICAgICAgIG9wZXJhdG9yOiBBYnN0cmFjdExhYmVsT3BlcmF0b3IuRXF1YWwsXG4gICAgICAgIHZhbHVlOiBuYW1lTGFiZWxWYWx1ZSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICByZWZJZDogcXVlcnkucmVmSWQsXG4gICAgICBsYWJlbE1hdGNoZXJzLFxuICAgIH07XG4gIH1cblxuICBhc3luYyBnZXRTZXJpZXMoc2VsZWN0b3I6IHN0cmluZywgd2l0aE5hbWU/OiBib29sZWFuKTogUHJvbWlzZTxSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT4+IHtcbiAgICBpZiAodGhpcy5kYXRhc291cmNlLmxvb2t1cHNEaXNhYmxlZCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgaWYgKHNlbGVjdG9yID09PSBFTVBUWV9TRUxFQ1RPUikge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5mZXRjaERlZmF1bHRTZXJpZXMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmZldGNoU2VyaWVzTGFiZWxzKHNlbGVjdG9yLCB3aXRoTmFtZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIFRPRE86IGJldHRlciBlcnJvciBoYW5kbGluZ1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9XG5cbiAgZmV0Y2hMYWJlbFZhbHVlcyA9IGFzeW5jIChrZXk6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nW10+ID0+IHtcbiAgICBjb25zdCBwYXJhbXMgPSB0aGlzLmRhdGFzb3VyY2UuZ2V0VGltZVJhbmdlUGFyYW1zKCk7XG4gICAgY29uc3QgdXJsID0gYC9hcGkvdjEvbGFiZWwvJHt0aGlzLmRhdGFzb3VyY2UuaW50ZXJwb2xhdGVTdHJpbmcoa2V5KX0vdmFsdWVzYDtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5yZXF1ZXN0KHVybCwgW10sIHBhcmFtcyk7XG4gIH07XG5cbiAgYXN5bmMgZ2V0TGFiZWxWYWx1ZXMoa2V5OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZmV0Y2hMYWJlbFZhbHVlcyhrZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoZXMgYWxsIGxhYmVsIGtleXNcbiAgICovXG4gIGFzeW5jIGZldGNoTGFiZWxzKCk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICBjb25zdCB1cmwgPSAnL2FwaS92MS9sYWJlbHMnO1xuICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuZGF0YXNvdXJjZS5nZXRUaW1lUmFuZ2VQYXJhbXMoKTtcbiAgICB0aGlzLmxhYmVsRmV0Y2hUcyA9IERhdGUubm93KCkudmFsdWVPZigpO1xuXG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5yZXF1ZXN0KHVybCwgW10sIHBhcmFtcyk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVzKSkge1xuICAgICAgdGhpcy5sYWJlbEtleXMgPSByZXMuc2xpY2UoKS5zb3J0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGxhYmVscyBmb3IgYSBzZXJpZXMuIFRoaXMgaXMgY2FjaGVkIGJ5IGl0J3MgYXJncyBidXQgYWxzbyBieSB0aGUgZ2xvYmFsIHRpbWVSYW5nZSBjdXJyZW50bHkgc2VsZWN0ZWQgYXNcbiAgICogdGhleSBjYW4gY2hhbmdlIG92ZXIgcmVxdWVzdGVkIHRpbWUuXG4gICAqIEBwYXJhbSBuYW1lXG4gICAqIEBwYXJhbSB3aXRoTmFtZVxuICAgKi9cbiAgZmV0Y2hTZXJpZXNMYWJlbHMgPSBhc3luYyAobmFtZTogc3RyaW5nLCB3aXRoTmFtZT86IGJvb2xlYW4pOiBQcm9taXNlPFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPj4gPT4ge1xuICAgIGNvbnN0IGludGVycG9sYXRlZE5hbWUgPSB0aGlzLmRhdGFzb3VyY2UuaW50ZXJwb2xhdGVTdHJpbmcobmFtZSk7XG4gICAgY29uc3QgcmFuZ2UgPSB0aGlzLmRhdGFzb3VyY2UuZ2V0VGltZVJhbmdlUGFyYW1zKCk7XG4gICAgY29uc3QgdXJsUGFyYW1zID0ge1xuICAgICAgLi4ucmFuZ2UsXG4gICAgICAnbWF0Y2hbXSc6IGludGVycG9sYXRlZE5hbWUsXG4gICAgfTtcbiAgICBjb25zdCB1cmwgPSBgL2FwaS92MS9zZXJpZXNgO1xuICAgIC8vIENhY2hlIGtleSBpcyBhIGJpdCBkaWZmZXJlbnQgaGVyZS4gV2UgYWRkIHRoZSBgd2l0aE5hbWVgIHBhcmFtIGFuZCBhbHNvIHJvdW5kIHVwIHRvIGEgbWludXRlIHRoZSBpbnRlcnZhbHMuXG4gICAgLy8gVGhlIHJvdW5kaW5nIG1heSBzZWVtIHN0cmFuZ2UgYnV0IG1ha2VzIHJlbGF0aXZlIGludGVydmFscyBsaWtlIG5vdy0xaCBsZXNzIHByb25lIHRvIG5lZWQgc2VwYXJhdGUgcmVxdWVzdCBldmVyeVxuICAgIC8vIG1pbGxpc2Vjb25kIHdoaWxlIHN0aWxsIGFjdHVhbGx5IGdldHRpbmcgYWxsIHRoZSBrZXlzIGZvciB0aGUgY29ycmVjdCBpbnRlcnZhbC4gVGhpcyBzdGlsbCBjYW4gY3JlYXRlIHByb2JsZW1zXG4gICAgLy8gd2hlbiB1c2VyIGRvZXMgbm90IHRoZSBuZXdlc3QgdmFsdWVzIGZvciBhIG1pbnV0ZSBpZiBhbHJlYWR5IGNhY2hlZC5cbiAgICBjb25zdCBjYWNoZVBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgJ21hdGNoW10nOiBpbnRlcnBvbGF0ZWROYW1lLFxuICAgICAgc3RhcnQ6IHJvdW5kU2VjVG9NaW4ocGFyc2VJbnQocmFuZ2Uuc3RhcnQsIDEwKSkudG9TdHJpbmcoKSxcbiAgICAgIGVuZDogcm91bmRTZWNUb01pbihwYXJzZUludChyYW5nZS5lbmQsIDEwKSkudG9TdHJpbmcoKSxcbiAgICAgIHdpdGhOYW1lOiB3aXRoTmFtZSA/ICd0cnVlJyA6ICdmYWxzZScsXG4gICAgfSk7XG5cbiAgICBjb25zdCBjYWNoZUtleSA9IGAvYXBpL3YxL3Nlcmllcz8ke2NhY2hlUGFyYW1zLnRvU3RyaW5nKCl9YDtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLmxhYmVsc0NhY2hlLmdldChjYWNoZUtleSk7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMucmVxdWVzdCh1cmwsIFtdLCB1cmxQYXJhbXMpO1xuICAgICAgY29uc3QgeyB2YWx1ZXMgfSA9IHByb2Nlc3NMYWJlbHMoZGF0YSwgd2l0aE5hbWUpO1xuICAgICAgdmFsdWUgPSB2YWx1ZXM7XG4gICAgICB0aGlzLmxhYmVsc0NhY2hlLnNldChjYWNoZUtleSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZldGNoIHNlcmllcyBmb3IgYSBzZWxlY3Rvci4gVXNlIHRoaXMgZm9yIHJhdyByZXN1bHRzLiBVc2UgZmV0Y2hTZXJpZXNMYWJlbHMoKSB0byBnZXQgbGFiZWxzLlxuICAgKiBAcGFyYW0gbWF0Y2hcbiAgICovXG4gIGZldGNoU2VyaWVzID0gYXN5bmMgKG1hdGNoOiBzdHJpbmcpOiBQcm9taXNlPEFycmF5PFJlY29yZDxzdHJpbmcsIHN0cmluZz4+PiA9PiB7XG4gICAgY29uc3QgdXJsID0gJy9hcGkvdjEvc2VyaWVzJztcbiAgICBjb25zdCByYW5nZSA9IHRoaXMuZGF0YXNvdXJjZS5nZXRUaW1lUmFuZ2VQYXJhbXMoKTtcbiAgICBjb25zdCBwYXJhbXMgPSB7IC4uLnJhbmdlLCAnbWF0Y2hbXSc6IG1hdGNoIH07XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucmVxdWVzdCh1cmwsIHt9LCBwYXJhbXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGlzIG9ubHkgb25lIGFzIHdlIGFzc3VtZSB0aGlzIHdvbid0IGNoYW5nZSBvdmVyIHRpbWUuIFRoaXMgaXMgY2FjaGVkIGRpZmZlcmVudGx5IGZyb20gZmV0Y2hTZXJpZXNMYWJlbHNcbiAgICogYmVjYXVzZSB3ZSBjYW4gY2FjaGUgbW9yZSBhZ2dyZXNzaXZlbHkgaGVyZSBhbmQgYWxzbyB3ZSBkbyBub3Qgd2FudCB0byBpbnZhbGlkYXRlIHRoaXMgY2FjaGUgdGhlIHNhbWUgd2F5IGFzIGluXG4gICAqIGZldGNoU2VyaWVzTGFiZWxzLlxuICAgKi9cbiAgZmV0Y2hEZWZhdWx0U2VyaWVzID0gb25jZShhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgdmFsdWVzID0gYXdhaXQgUHJvbWlzZS5hbGwoREVGQVVMVF9LRVlTLm1hcCgoa2V5KSA9PiB0aGlzLmZldGNoTGFiZWxWYWx1ZXMoa2V5KSkpO1xuICAgIHJldHVybiBERUZBVUxUX0tFWVMucmVkdWNlKChhY2MsIGtleSwgaSkgPT4gKHsgLi4uYWNjLCBba2V5XTogdmFsdWVzW2ldIH0pLCB7fSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXROYW1lTGFiZWxWYWx1ZShwcm9tUXVlcnk6IHN0cmluZywgdG9rZW5zOiBhbnkpOiBzdHJpbmcge1xuICBsZXQgbmFtZUxhYmVsVmFsdWUgPSAnJztcbiAgZm9yIChsZXQgcHJvcCBpbiB0b2tlbnMpIHtcbiAgICBpZiAodHlwZW9mIHRva2Vuc1twcm9wXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWVMYWJlbFZhbHVlID0gdG9rZW5zW3Byb3BdIGFzIHN0cmluZztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmFtZUxhYmVsVmFsdWU7XG59XG4iLCJpbXBvcnQgeyBpbnZlcnQgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgVG9rZW4gfSBmcm9tICdwcmlzbWpzJztcblxuaW1wb3J0IHsgRGF0YVF1ZXJ5LCBBYnN0cmFjdFF1ZXJ5LCBBYnN0cmFjdExhYmVsT3BlcmF0b3IsIEFic3RyYWN0TGFiZWxNYXRjaGVyIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5cbmltcG9ydCB7IGFkZExhYmVsVG9RdWVyeSB9IGZyb20gJy4vYWRkX2xhYmVsX3RvX3F1ZXJ5JztcbmltcG9ydCB7IFNVR0dFU1RJT05TX0xJTUlUIH0gZnJvbSAnLi9sYW5ndWFnZV9wcm92aWRlcic7XG5pbXBvcnQgeyBQcm9tTWV0cmljc01ldGFkYXRhLCBQcm9tTWV0cmljc01ldGFkYXRhSXRlbSB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgY29uc3QgcHJvY2Vzc0hpc3RvZ3JhbU1ldHJpY3MgPSAobWV0cmljczogc3RyaW5nW10pID0+IHtcbiAgY29uc3QgcmVzdWx0U2V0OiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQoKTtcbiAgY29uc3QgcmVnZXhwID0gbmV3IFJlZ0V4cCgnX2J1Y2tldCgkfDopJyk7XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBtZXRyaWNzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGNvbnN0IG1ldHJpYyA9IG1ldHJpY3NbaW5kZXhdO1xuICAgIGNvbnN0IGlzSGlzdG9ncmFtVmFsdWUgPSByZWdleHAudGVzdChtZXRyaWMpO1xuICAgIGlmIChpc0hpc3RvZ3JhbVZhbHVlKSB7XG4gICAgICByZXN1bHRTZXQuYWRkKG1ldHJpYyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBbLi4ucmVzdWx0U2V0XTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzTGFiZWxzKGxhYmVsczogQXJyYXk8eyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfT4sIHdpdGhOYW1lID0gZmFsc2UpIHtcbiAgLy8gRm9yIHByb2Nlc3Npbmcgd2UgYXJlIGdvaW5nIHRvIHVzZSBzZXRzIGFzIHRoZXkgaGF2ZSBzaWduaWZpY2FudGx5IGJldHRlciBwZXJmb3JtYW5jZSB0aGFuIGFycmF5c1xuICAvLyBBZnRlciB3ZSBwcm9jZXNzIGxhYmVscywgd2Ugd2lsbCBjb252ZXJ0IHNldHMgdG8gYXJyYXlzIGFuZCByZXR1cm4gb2JqZWN0IHdpdGggbGFiZWwgdmFsdWVzIGluIGFycmF5c1xuICBjb25zdCB2YWx1ZVNldDogeyBba2V5OiBzdHJpbmddOiBTZXQ8c3RyaW5nPiB9ID0ge307XG4gIGxhYmVscy5mb3JFYWNoKChsYWJlbCkgPT4ge1xuICAgIGNvbnN0IHsgX19uYW1lX18sIC4uLnJlc3QgfSA9IGxhYmVsO1xuICAgIGlmICh3aXRoTmFtZSkge1xuICAgICAgdmFsdWVTZXRbJ19fbmFtZV9fJ10gPSB2YWx1ZVNldFsnX19uYW1lX18nXSB8fCBuZXcgU2V0KCk7XG4gICAgICBpZiAoIXZhbHVlU2V0WydfX25hbWVfXyddLmhhcyhfX25hbWVfXykpIHtcbiAgICAgICAgdmFsdWVTZXRbJ19fbmFtZV9fJ10uYWRkKF9fbmFtZV9fKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBPYmplY3Qua2V5cyhyZXN0KS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGlmICghdmFsdWVTZXRba2V5XSkge1xuICAgICAgICB2YWx1ZVNldFtrZXldID0gbmV3IFNldCgpO1xuICAgICAgfVxuICAgICAgaWYgKCF2YWx1ZVNldFtrZXldLmhhcyhyZXN0W2tleV0pKSB7XG4gICAgICAgIHZhbHVlU2V0W2tleV0uYWRkKHJlc3Rba2V5XSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIHZhbHVlQXJyYXkgdGhhdCB3ZSBhcmUgZ29pbmcgdG8gcmV0dXJuIGluIHRoZSBvYmplY3RcbiAgY29uc3QgdmFsdWVBcnJheTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmdbXSB9ID0ge307XG4gIGxpbWl0U3VnZ2VzdGlvbnMoT2JqZWN0LmtleXModmFsdWVTZXQpKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICB2YWx1ZUFycmF5W2tleV0gPSBsaW1pdFN1Z2dlc3Rpb25zKEFycmF5LmZyb20odmFsdWVTZXRba2V5XSkpO1xuICB9KTtcblxuICByZXR1cm4geyB2YWx1ZXM6IHZhbHVlQXJyYXksIGtleXM6IE9iamVjdC5rZXlzKHZhbHVlQXJyYXkpIH07XG59XG5cbi8vIGNvbnN0IGNsZWFuU2VsZWN0b3JSZWdleHAgPSAvXFx7KFxcdys9XCJbXlwiXFxuXSo/XCIpKCxcXHcrPVwiW15cIlxcbl0qP1wiKSpcXH0vO1xuZXhwb3J0IGNvbnN0IHNlbGVjdG9yUmVnZXhwID0gL1xce1tefV0qPyhcXH18JCkvO1xuZXhwb3J0IGNvbnN0IGxhYmVsUmVnZXhwID0gL1xcYihcXHcrKSghPz1+PykoXCJbXlwiXFxuXSo/XCIpL2c7XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VTZWxlY3RvcihxdWVyeTogc3RyaW5nLCBjdXJzb3JPZmZzZXQgPSAxKTogeyBsYWJlbEtleXM6IGFueVtdOyBzZWxlY3Rvcjogc3RyaW5nIH0ge1xuICBpZiAoIXF1ZXJ5Lm1hdGNoKHNlbGVjdG9yUmVnZXhwKSkge1xuICAgIC8vIFNwZWNpYWwgbWF0Y2hlciBmb3IgbWV0cmljc1xuICAgIGlmIChxdWVyeS5tYXRjaCgvXltBLVphLXo6XVtcXHc6XSokLykpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNlbGVjdG9yOiBge19fbmFtZV9fPVwiJHtxdWVyeX1cIn1gLFxuICAgICAgICBsYWJlbEtleXM6IFsnX19uYW1lX18nXSxcbiAgICAgIH07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignUXVlcnkgbXVzdCBjb250YWluIGEgc2VsZWN0b3I6ICcgKyBxdWVyeSk7XG4gIH1cblxuICAvLyBDaGVjayBpZiBpbnNpZGUgYSBzZWxlY3RvclxuICBjb25zdCBwcmVmaXggPSBxdWVyeS5zbGljZSgwLCBjdXJzb3JPZmZzZXQpO1xuICBjb25zdCBwcmVmaXhPcGVuID0gcHJlZml4Lmxhc3RJbmRleE9mKCd7Jyk7XG4gIGNvbnN0IHByZWZpeENsb3NlID0gcHJlZml4Lmxhc3RJbmRleE9mKCd9Jyk7XG4gIGlmIChwcmVmaXhPcGVuID09PSAtMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IGluc2lkZSBzZWxlY3RvciwgbWlzc2luZyBvcGVuIGJyYWNlOiAnICsgcHJlZml4KTtcbiAgfVxuICBpZiAocHJlZml4Q2xvc2UgPiAtMSAmJiBwcmVmaXhDbG9zZSA+IHByZWZpeE9wZW4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbnNpZGUgc2VsZWN0b3IsIHByZXZpb3VzIHNlbGVjdG9yIGFscmVhZHkgY2xvc2VkOiAnICsgcHJlZml4KTtcbiAgfVxuICBjb25zdCBzdWZmaXggPSBxdWVyeS5zbGljZShjdXJzb3JPZmZzZXQpO1xuICBjb25zdCBzdWZmaXhDbG9zZUluZGV4ID0gc3VmZml4LmluZGV4T2YoJ30nKTtcbiAgY29uc3Qgc3VmZml4Q2xvc2UgPSBzdWZmaXhDbG9zZUluZGV4ICsgY3Vyc29yT2Zmc2V0O1xuICBjb25zdCBzdWZmaXhPcGVuSW5kZXggPSBzdWZmaXguaW5kZXhPZigneycpO1xuICBjb25zdCBzdWZmaXhPcGVuID0gc3VmZml4T3BlbkluZGV4ICsgY3Vyc29yT2Zmc2V0O1xuICBpZiAoc3VmZml4Q2xvc2UgPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW5zaWRlIHNlbGVjdG9yLCBtaXNzaW5nIGNsb3NpbmcgYnJhY2UgaW4gc3VmZml4OiAnICsgc3VmZml4KTtcbiAgfVxuICBpZiAoc3VmZml4T3BlbkluZGV4ID4gLTEgJiYgc3VmZml4T3BlbiA8IHN1ZmZpeENsb3NlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW5zaWRlIHNlbGVjdG9yLCBuZXh0IHNlbGVjdG9yIG9wZW5zIGJlZm9yZSB0aGlzIG9uZSBjbG9zZWQ6ICcgKyBzdWZmaXgpO1xuICB9XG5cbiAgLy8gRXh0cmFjdCBjbGVhbiBsYWJlbHMgdG8gZm9ybSBjbGVhbiBzZWxlY3RvciwgaW5jb21wbGV0ZSBsYWJlbHMgYXJlIGRyb3BwZWRcbiAgY29uc3Qgc2VsZWN0b3IgPSBxdWVyeS5zbGljZShwcmVmaXhPcGVuLCBzdWZmaXhDbG9zZSk7XG4gIGNvbnN0IGxhYmVsczogeyBba2V5OiBzdHJpbmddOiB7IHZhbHVlOiBzdHJpbmc7IG9wZXJhdG9yOiBzdHJpbmcgfSB9ID0ge307XG4gIHNlbGVjdG9yLnJlcGxhY2UobGFiZWxSZWdleHAsIChsYWJlbCwga2V5LCBvcGVyYXRvciwgdmFsdWUpID0+IHtcbiAgICBjb25zdCBsYWJlbE9mZnNldCA9IHF1ZXJ5LmluZGV4T2YobGFiZWwpO1xuICAgIGNvbnN0IHZhbHVlU3RhcnQgPSBsYWJlbE9mZnNldCArIGtleS5sZW5ndGggKyBvcGVyYXRvci5sZW5ndGggKyAxO1xuICAgIGNvbnN0IHZhbHVlRW5kID0gbGFiZWxPZmZzZXQgKyBrZXkubGVuZ3RoICsgb3BlcmF0b3IubGVuZ3RoICsgdmFsdWUubGVuZ3RoIC0gMTtcbiAgICAvLyBTa2lwIGxhYmVsIGlmIGN1cnNvciBpcyBpbiB2YWx1ZVxuICAgIGlmIChjdXJzb3JPZmZzZXQgPCB2YWx1ZVN0YXJ0IHx8IGN1cnNvck9mZnNldCA+IHZhbHVlRW5kKSB7XG4gICAgICBsYWJlbHNba2V5XSA9IHsgdmFsdWUsIG9wZXJhdG9yIH07XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfSk7XG5cbiAgLy8gQWRkIG1ldHJpYyBpZiB0aGVyZSBpcyBvbmUgYmVmb3JlIHRoZSBzZWxlY3RvclxuICBjb25zdCBtZXRyaWNQcmVmaXggPSBxdWVyeS5zbGljZSgwLCBwcmVmaXhPcGVuKTtcbiAgY29uc3QgbWV0cmljTWF0Y2ggPSBtZXRyaWNQcmVmaXgubWF0Y2goL1tBLVphLXo6XVtcXHc6XSokLyk7XG4gIGlmIChtZXRyaWNNYXRjaCkge1xuICAgIGxhYmVsc1snX19uYW1lX18nXSA9IHsgdmFsdWU6IGBcIiR7bWV0cmljTWF0Y2hbMF19XCJgLCBvcGVyYXRvcjogJz0nIH07XG4gIH1cblxuICAvLyBCdWlsZCBzb3J0ZWQgc2VsZWN0b3JcbiAgY29uc3QgbGFiZWxLZXlzID0gT2JqZWN0LmtleXMobGFiZWxzKS5zb3J0KCk7XG4gIGNvbnN0IGNsZWFuU2VsZWN0b3IgPSBsYWJlbEtleXMubWFwKChrZXkpID0+IGAke2tleX0ke2xhYmVsc1trZXldLm9wZXJhdG9yfSR7bGFiZWxzW2tleV0udmFsdWV9YCkuam9pbignLCcpO1xuXG4gIGNvbnN0IHNlbGVjdG9yU3RyaW5nID0gWyd7JywgY2xlYW5TZWxlY3RvciwgJ30nXS5qb2luKCcnKTtcblxuICByZXR1cm4geyBsYWJlbEtleXMsIHNlbGVjdG9yOiBzZWxlY3RvclN0cmluZyB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kUmVjb3JkaW5nUnVsZXMocXVlcnk6IHN0cmluZywgbWFwcGluZzogeyBbbmFtZTogc3RyaW5nXTogc3RyaW5nIH0pOiBzdHJpbmcge1xuICBjb25zdCBydWxlTmFtZXMgPSBPYmplY3Qua2V5cyhtYXBwaW5nKTtcbiAgY29uc3QgcnVsZXNSZWdleCA9IG5ldyBSZWdFeHAoYChcXFxcc3xeKSgke3J1bGVOYW1lcy5qb2luKCd8Jyl9KShcXFxcc3wkfFxcXFwofFxcXFxbfFxcXFx7KWAsICdpZycpO1xuICBjb25zdCBleHBhbmRlZFF1ZXJ5ID0gcXVlcnkucmVwbGFjZShydWxlc1JlZ2V4LCAobWF0Y2gsIHByZSwgbmFtZSwgcG9zdCkgPT4gYCR7cHJlfSR7bWFwcGluZ1tuYW1lXX0ke3Bvc3R9YCk7XG5cbiAgLy8gU3BsaXQgcXVlcnkgaW50byBhcnJheSwgc28gaWYgcXVlcnkgdXNlcyBvcGVyYXRvcnMsIHdlIGNhbiBjb3JyZWN0bHkgYWRkIGxhYmVscyB0byBlYWNoIGluZGl2aWR1YWwgcGFydC5cbiAgY29uc3QgcXVlcnlBcnJheSA9IGV4cGFuZGVkUXVlcnkuc3BsaXQoLyhcXCt8XFwtfFxcKnxcXC98XFwlfFxcXikvKTtcblxuICAvLyBSZWdleCB0aGF0IG1hdGNoZXMgb2NjdXJyZW5jZXMgb2YgKXsgb3IgfXsgb3IgXXsgd2hpY2ggaXMgYSBzaWduIG9mIGluY29ycmVjbHkgYWRkZWQgbGFiZWxzLlxuICBjb25zdCBpbnZhbGlkTGFiZWxzUmVnZXggPSAvKFxcKVxce3xcXH1cXHt8XFxdXFx7KS87XG4gIGNvbnN0IGNvcnJlY3RseUV4cGFuZGVkUXVlcnlBcnJheSA9IHF1ZXJ5QXJyYXkubWFwKChxdWVyeSkgPT4ge1xuICAgIHJldHVybiBhZGRMYWJlbHNUb0V4cHJlc3Npb24ocXVlcnksIGludmFsaWRMYWJlbHNSZWdleCk7XG4gIH0pO1xuXG4gIHJldHVybiBjb3JyZWN0bHlFeHBhbmRlZFF1ZXJ5QXJyYXkuam9pbignJyk7XG59XG5cbmZ1bmN0aW9uIGFkZExhYmVsc1RvRXhwcmVzc2lvbihleHByOiBzdHJpbmcsIGludmFsaWRMYWJlbHNSZWdleHA6IFJlZ0V4cCkge1xuICBjb25zdCBtYXRjaCA9IGV4cHIubWF0Y2goaW52YWxpZExhYmVsc1JlZ2V4cCk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gZXhwcjtcbiAgfVxuXG4gIC8vIFNwbGl0IHF1ZXJ5IGludG8gMiBwYXJ0cyAtIGJlZm9yZSB0aGUgaW52YWxpZExhYmVsc1JlZ2V4IG1hdGNoIGFuZCBhZnRlci5cbiAgY29uc3QgaW5kZXhPZlJlZ2V4TWF0Y2ggPSBtYXRjaC5pbmRleCA/PyAwO1xuICBjb25zdCBleHByQmVmb3JlUmVnZXhNYXRjaCA9IGV4cHIuc2xpY2UoMCwgaW5kZXhPZlJlZ2V4TWF0Y2ggKyAxKTtcbiAgY29uc3QgZXhwckFmdGVyUmVnZXhNYXRjaCA9IGV4cHIuc2xpY2UoaW5kZXhPZlJlZ2V4TWF0Y2ggKyAxKTtcblxuICAvLyBDcmVhdGUgYXJyYXlPZkxhYmVsT2JqZWN0cyB3aXRoIGxhYmVsIG9iamVjdHMgdGhhdCBoYXZlIGtleSwgb3BlcmF0b3IgYW5kIHZhbHVlLlxuICBjb25zdCBhcnJheU9mTGFiZWxPYmplY3RzOiBBcnJheTx7IGtleTogc3RyaW5nOyBvcGVyYXRvcjogc3RyaW5nOyB2YWx1ZTogc3RyaW5nIH0+ID0gW107XG4gIGV4cHJBZnRlclJlZ2V4TWF0Y2gucmVwbGFjZShsYWJlbFJlZ2V4cCwgKGxhYmVsLCBrZXksIG9wZXJhdG9yLCB2YWx1ZSkgPT4ge1xuICAgIGFycmF5T2ZMYWJlbE9iamVjdHMucHVzaCh7IGtleSwgb3BlcmF0b3IsIHZhbHVlIH0pO1xuICAgIHJldHVybiAnJztcbiAgfSk7XG5cbiAgLy8gTG9vcCB0aHJvdWdoIGFsbCBsYWJlbCBvYmplY3RzIGFuZCBhZGQgdGhlbSB0byBxdWVyeS5cbiAgLy8gQXMgYSBzdGFydGluZyBwb2ludCB3ZSBoYXZlIHZhbGlkIHF1ZXJ5IHdpdGhvdXQgdGhlIGxhYmVscy5cbiAgbGV0IHJlc3VsdCA9IGV4cHJCZWZvcmVSZWdleE1hdGNoO1xuICBhcnJheU9mTGFiZWxPYmplY3RzLmZpbHRlcihCb29sZWFuKS5mb3JFYWNoKChvYmopID0+IHtcbiAgICAvLyBSZW1vdmUgZXh0cmEgc2V0IG9mIHF1b3RlcyBmcm9tIG9iai52YWx1ZVxuICAgIGNvbnN0IHZhbHVlID0gb2JqLnZhbHVlLnNsaWNlKDEsIC0xKTtcbiAgICByZXN1bHQgPSBhZGRMYWJlbFRvUXVlcnkocmVzdWx0LCBvYmoua2V5LCB2YWx1ZSwgb2JqLm9wZXJhdG9yKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBZGRzIG1ldGFkYXRhIGZvciBzeW50aGV0aWMgbWV0cmljcyBmb3Igd2hpY2ggdGhlIEFQSSBkb2VzIG5vdCBwcm92aWRlIG1ldGFkYXRhLlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmFmYW5hL2dyYWZhbmEvaXNzdWVzLzIyMzM3IGZvciBkZXRhaWxzLlxuICpcbiAqIEBwYXJhbSBtZXRhZGF0YSBIRUxQIGFuZCBUWVBFIG1ldGFkYXRhIGZyb20gL2FwaS92MS9tZXRhZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gZml4U3VtbWFyaWVzTWV0YWRhdGEobWV0YWRhdGE6IHsgW21ldHJpYzogc3RyaW5nXTogUHJvbU1ldHJpY3NNZXRhZGF0YUl0ZW1bXSB9KTogUHJvbU1ldHJpY3NNZXRhZGF0YSB7XG4gIGlmICghbWV0YWRhdGEpIHtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH1cbiAgY29uc3QgYmFzZU1ldGFkYXRhOiBQcm9tTWV0cmljc01ldGFkYXRhID0ge307XG4gIGNvbnN0IHN1bW1hcnlNZXRhZGF0YTogUHJvbU1ldHJpY3NNZXRhZGF0YSA9IHt9O1xuICBmb3IgKGNvbnN0IG1ldHJpYyBpbiBtZXRhZGF0YSkge1xuICAgIC8vIE5PVEU6IGJhc2VkIG9uIHByb21ldGhldXMtZG9jdW1lbnRhdGlvbiwgd2UgY2FuIHJlY2VpdmVcbiAgICAvLyBtdWx0aXBsZSBtZXRhZGF0YS1lbnRyaWVzIGZvciB0aGUgZ2l2ZW4gbWV0cmljLCBpdCBzZWVtc1xuICAgIC8vIGl0IGhhcHBlbnMgd2hlbiB0aGUgc2FtZSBtZXRyaWMgaXMgb24gbXVsdGlwbGUgdGFyZ2V0c1xuICAgIC8vIGFuZCB0aGVpciBoZWxwLXRleHQgZGlmZmVyc1xuICAgIC8vIChodHRwczovL3Byb21ldGhldXMuaW8vZG9jcy9wcm9tZXRoZXVzL2xhdGVzdC9xdWVyeWluZy9hcGkvI3F1ZXJ5aW5nLW1ldHJpYy1tZXRhZGF0YSlcbiAgICAvLyBmb3Igbm93IHdlIGp1c3QgdXNlIHRoZSBmaXJzdCBlbnRyeS5cbiAgICBjb25zdCBpdGVtID0gbWV0YWRhdGFbbWV0cmljXVswXTtcbiAgICBiYXNlTWV0YWRhdGFbbWV0cmljXSA9IGl0ZW07XG5cbiAgICBpZiAoaXRlbS50eXBlID09PSAnaGlzdG9ncmFtJykge1xuICAgICAgc3VtbWFyeU1ldGFkYXRhW2Ake21ldHJpY31fYnVja2V0YF0gPSB7XG4gICAgICAgIHR5cGU6ICdjb3VudGVyJyxcbiAgICAgICAgaGVscDogYEN1bXVsYXRpdmUgY291bnRlcnMgZm9yIHRoZSBvYnNlcnZhdGlvbiBidWNrZXRzICgke2l0ZW0uaGVscH0pYCxcbiAgICAgIH07XG4gICAgICBzdW1tYXJ5TWV0YWRhdGFbYCR7bWV0cmljfV9jb3VudGBdID0ge1xuICAgICAgICB0eXBlOiAnY291bnRlcicsXG4gICAgICAgIGhlbHA6IGBDb3VudCBvZiBldmVudHMgdGhhdCBoYXZlIGJlZW4gb2JzZXJ2ZWQgZm9yIHRoZSBoaXN0b2dyYW0gbWV0cmljICgke2l0ZW0uaGVscH0pYCxcbiAgICAgIH07XG4gICAgICBzdW1tYXJ5TWV0YWRhdGFbYCR7bWV0cmljfV9zdW1gXSA9IHtcbiAgICAgICAgdHlwZTogJ2NvdW50ZXInLFxuICAgICAgICBoZWxwOiBgVG90YWwgc3VtIG9mIGFsbCBvYnNlcnZlZCB2YWx1ZXMgZm9yIHRoZSBoaXN0b2dyYW0gbWV0cmljICgke2l0ZW0uaGVscH0pYCxcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChpdGVtLnR5cGUgPT09ICdzdW1tYXJ5Jykge1xuICAgICAgc3VtbWFyeU1ldGFkYXRhW2Ake21ldHJpY31fY291bnRgXSA9IHtcbiAgICAgICAgdHlwZTogJ2NvdW50ZXInLFxuICAgICAgICBoZWxwOiBgQ291bnQgb2YgZXZlbnRzIHRoYXQgaGF2ZSBiZWVuIG9ic2VydmVkIGZvciB0aGUgYmFzZSBtZXRyaWMgKCR7aXRlbS5oZWxwfSlgLFxuICAgICAgfTtcbiAgICAgIHN1bW1hcnlNZXRhZGF0YVtgJHttZXRyaWN9X3N1bWBdID0ge1xuICAgICAgICB0eXBlOiAnY291bnRlcicsXG4gICAgICAgIGhlbHA6IGBUb3RhbCBzdW0gb2YgYWxsIG9ic2VydmVkIHZhbHVlcyBmb3IgdGhlIGJhc2UgbWV0cmljICgke2l0ZW0uaGVscH0pYCxcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIC8vIFN5bnRoZXRpYyBzZXJpZXNcbiAgY29uc3Qgc3ludGhldGljTWV0YWRhdGE6IFByb21NZXRyaWNzTWV0YWRhdGEgPSB7fTtcbiAgc3ludGhldGljTWV0YWRhdGFbJ0FMRVJUUyddID0ge1xuICAgIHR5cGU6ICdjb3VudGVyJyxcbiAgICBoZWxwOiAnVGltZSBzZXJpZXMgc2hvd2luZyBwZW5kaW5nIGFuZCBmaXJpbmcgYWxlcnRzLiBUaGUgc2FtcGxlIHZhbHVlIGlzIHNldCB0byAxIGFzIGxvbmcgYXMgdGhlIGFsZXJ0IGlzIGluIHRoZSBpbmRpY2F0ZWQgYWN0aXZlIChwZW5kaW5nIG9yIGZpcmluZykgc3RhdGUuJyxcbiAgfTtcblxuICByZXR1cm4geyAuLi5iYXNlTWV0YWRhdGEsIC4uLnN1bW1hcnlNZXRhZGF0YSwgLi4uc3ludGhldGljTWV0YWRhdGEgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kTXNUb01pbihtaWxsaXNlY29uZHM6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiByb3VuZFNlY1RvTWluKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcm91bmRTZWNUb01pbihzZWNvbmRzOiBudW1iZXIpOiBudW1iZXIge1xuICByZXR1cm4gTWF0aC5mbG9vcihzZWNvbmRzIC8gNjApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGltaXRTdWdnZXN0aW9ucyhpdGVtczogc3RyaW5nW10pIHtcbiAgcmV0dXJuIGl0ZW1zLnNsaWNlKDAsIFNVR0dFU1RJT05TX0xJTUlUKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZExpbWl0SW5mbyhpdGVtczogYW55W10gfCB1bmRlZmluZWQpOiBzdHJpbmcge1xuICByZXR1cm4gaXRlbXMgJiYgaXRlbXMubGVuZ3RoID49IFNVR0dFU1RJT05TX0xJTUlUID8gYCwgbGltaXRlZCB0byB0aGUgZmlyc3QgJHtTVUdHRVNUSU9OU19MSU1JVH0gcmVjZWl2ZWQgaXRlbXNgIDogJyc7XG59XG5cbi8vIE5PVEU6IHRoZSBmb2xsb3dpbmcgMiBleHBvcnRlZCBmdW5jdGlvbnMgYXJlIHZlcnkgc2ltaWxhciB0byB0aGUgcHJvbWV0aGV1cypFc2NhcGVcbi8vIGZ1bmN0aW9ucyBpbiBkYXRhc291cmNlLnRzLCBidXQgdGhleSBhcmUgbm90IGV4YWN0bHkgdGhlIHNhbWUgYWxnb3JpdGhtLCBhbmQgd2UgZm91bmRcbi8vIG5vIHdheSB0byByZXVzZSBvbmUgaW4gdGhlIGFub3RoZXIgb3IgdmljZSB2ZXJzYS5cblxuLy8gUHJvbWV0aGV1cyByZWd1bGFyLWV4cHJlc3Npb25zIHVzZSB0aGUgUkUyIHN5bnRheCAoaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9yZTIvd2lraS9TeW50YXgpLFxuLy8gc28gZXZlcnkgY2hhcmFjdGVyIHRoYXQgbWF0Y2hlcyBzb21ldGhpbmcgaW4gdGhhdCBsaXN0IGhhcyB0byBiZSBlc2NhcGVkLlxuLy8gdGhlIGxpc3Qgb2YgbWV0YWNoYXJhY3RlcnMgaXM6ICorPygpfFxcLltde31eJFxuLy8gd2UgbWFrZSBhIGphdmFzY3JpcHQgcmVndWxhciBleHByZXNzaW9uIHRoYXQgbWF0Y2hlcyB0aG9zZSBjaGFyYWN0ZXJzOlxuY29uc3QgUkUyX01FVEFDSEFSQUNURVJTID0gL1sqKz8oKXxcXFxcLlxcW1xcXXt9XiRdL2c7XG5mdW5jdGlvbiBlc2NhcGVQcm9tZXRoZXVzUmVnZXhwKHZhbHVlOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gdmFsdWUucmVwbGFjZShSRTJfTUVUQUNIQVJBQ1RFUlMsICdcXFxcJCYnKTtcbn1cblxuLy8gYmFzZWQgb24gdGhlIG9wZW5tZXRyaWNzLWRvY3VtZW50YXRpb24sIHRoZSAzIHN5bWJvbHMgd2UgaGF2ZSB0byBoYW5kbGUgYXJlOlxuLy8gLSBcXG4gLi4uIHRoZSBuZXdsaW5lIGNoYXJhY3RlclxuLy8gLSBcXCAgLi4uIHRoZSBiYWNrc2xhc2ggY2hhcmFjdGVyXG4vLyAtIFwiICAuLi4gdGhlIGRvdWJsZS1xdW90ZSBjaGFyYWN0ZXJcbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVMYWJlbFZhbHVlSW5FeGFjdFNlbGVjdG9yKGxhYmVsVmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBsYWJlbFZhbHVlLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJykucmVwbGFjZSgvXFxuL2csICdcXFxcbicpLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZUxhYmVsVmFsdWVJblJlZ2V4U2VsZWN0b3IobGFiZWxWYWx1ZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIGVzY2FwZUxhYmVsVmFsdWVJbkV4YWN0U2VsZWN0b3IoZXNjYXBlUHJvbWV0aGV1c1JlZ2V4cChsYWJlbFZhbHVlKSk7XG59XG5cbmNvbnN0IEZyb21Qcm9tTGlrZU1hcDogUmVjb3JkPHN0cmluZywgQWJzdHJhY3RMYWJlbE9wZXJhdG9yPiA9IHtcbiAgJz0nOiBBYnN0cmFjdExhYmVsT3BlcmF0b3IuRXF1YWwsXG4gICchPSc6IEFic3RyYWN0TGFiZWxPcGVyYXRvci5Ob3RFcXVhbCxcbiAgJz1+JzogQWJzdHJhY3RMYWJlbE9wZXJhdG9yLkVxdWFsUmVnRXgsXG4gICchfic6IEFic3RyYWN0TGFiZWxPcGVyYXRvci5Ob3RFcXVhbFJlZ0V4LFxufTtcbmNvbnN0IFRvUHJvbUxpa2VNYXA6IFJlY29yZDxBYnN0cmFjdExhYmVsT3BlcmF0b3IsIHN0cmluZz4gPSBpbnZlcnQoRnJvbVByb21MaWtlTWFwKSBhcyBSZWNvcmQ8XG4gIEFic3RyYWN0TGFiZWxPcGVyYXRvcixcbiAgc3RyaW5nXG4+O1xuXG5leHBvcnQgZnVuY3Rpb24gdG9Qcm9tTGlrZUV4cHIobGFiZWxCYXNlZFF1ZXJ5OiBBYnN0cmFjdFF1ZXJ5KTogc3RyaW5nIHtcbiAgY29uc3QgZXhwciA9IGxhYmVsQmFzZWRRdWVyeS5sYWJlbE1hdGNoZXJzXG4gICAgLm1hcCgoc2VsZWN0b3I6IEFic3RyYWN0TGFiZWxNYXRjaGVyKSA9PiB7XG4gICAgICBjb25zdCBvcGVyYXRvciA9IFRvUHJvbUxpa2VNYXBbc2VsZWN0b3Iub3BlcmF0b3JdO1xuICAgICAgaWYgKG9wZXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBgJHtzZWxlY3Rvci5uYW1lfSR7b3BlcmF0b3J9XCIke3NlbGVjdG9yLnZhbHVlfVwiYDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICB9KVxuICAgIC5maWx0ZXIoKGU6IHN0cmluZykgPT4gZSAhPT0gJycpXG4gICAgLmpvaW4oJywgJyk7XG5cbiAgcmV0dXJuIGV4cHIgPyBgeyR7ZXhwcn19YCA6ICcnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9Qcm9tTGlrZVF1ZXJ5KGxhYmVsQmFzZWRRdWVyeTogQWJzdHJhY3RRdWVyeSk6IFByb21MaWtlUXVlcnkge1xuICByZXR1cm4ge1xuICAgIHJlZklkOiBsYWJlbEJhc2VkUXVlcnkucmVmSWQsXG4gICAgZXhwcjogdG9Qcm9tTGlrZUV4cHIobGFiZWxCYXNlZFF1ZXJ5KSxcbiAgICByYW5nZTogdHJ1ZSxcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9tTGlrZVF1ZXJ5IGV4dGVuZHMgRGF0YVF1ZXJ5IHtcbiAgZXhwcjogc3RyaW5nO1xuICByYW5nZTogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RMYWJlbE1hdGNoZXJzKHRva2VuczogQXJyYXk8c3RyaW5nIHwgVG9rZW4+KTogQWJzdHJhY3RMYWJlbE1hdGNoZXJbXSB7XG4gIGNvbnN0IGxhYmVsTWF0Y2hlcnM6IEFic3RyYWN0TGFiZWxNYXRjaGVyW10gPSBbXTtcblxuICBmb3IgKGxldCBwcm9wIGluIHRva2Vucykge1xuICAgIGlmICh0b2tlbnNbcHJvcF0gaW5zdGFuY2VvZiBUb2tlbikge1xuICAgICAgbGV0IHRva2VuOiBUb2tlbiA9IHRva2Vuc1twcm9wXSBhcyBUb2tlbjtcbiAgICAgIGlmICh0b2tlbi50eXBlID09PSAnY29udGV4dC1sYWJlbHMnKSB7XG4gICAgICAgIGxldCBsYWJlbEtleSA9ICcnO1xuICAgICAgICBsZXQgbGFiZWxWYWx1ZSA9ICcnO1xuICAgICAgICBsZXQgbGFiZWxPcGVyYXRvciA9ICcnO1xuICAgICAgICBsZXQgY29udGVudFRva2VuczogYW55W10gPSB0b2tlbi5jb250ZW50IGFzIGFueVtdO1xuICAgICAgICBmb3IgKGxldCBjdXJyZW50VG9rZW4gaW4gY29udGVudFRva2Vucykge1xuICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudFRva2Vuc1tjdXJyZW50VG9rZW5dID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRTdHI6IHN0cmluZztcbiAgICAgICAgICAgIGN1cnJlbnRTdHIgPSBjb250ZW50VG9rZW5zW2N1cnJlbnRUb2tlbl0gYXMgc3RyaW5nO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRTdHIgPT09ICc9JyB8fCBjdXJyZW50U3RyID09PSAnIT0nIHx8IGN1cnJlbnRTdHIgPT09ICc9ficgfHwgY3VycmVudFN0ciA9PT0gJyF+Jykge1xuICAgICAgICAgICAgICBsYWJlbE9wZXJhdG9yID0gY3VycmVudFN0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGNvbnRlbnRUb2tlbnNbY3VycmVudFRva2VuXSBpbnN0YW5jZW9mIFRva2VuKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNvbnRlbnRUb2tlbnNbY3VycmVudFRva2VuXS50eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ2xhYmVsLWtleSc6XG4gICAgICAgICAgICAgICAgbGFiZWxLZXkgPSBjb250ZW50VG9rZW5zW2N1cnJlbnRUb2tlbl0uY29udGVudCBhcyBzdHJpbmc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ2xhYmVsLXZhbHVlJzpcbiAgICAgICAgICAgICAgICBsYWJlbFZhbHVlID0gY29udGVudFRva2Vuc1tjdXJyZW50VG9rZW5dLmNvbnRlbnQgYXMgc3RyaW5nO1xuICAgICAgICAgICAgICAgIGxhYmVsVmFsdWUgPSBsYWJlbFZhbHVlLnN1YnN0cmluZygxLCBsYWJlbFZhbHVlLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsQ29tcGFyYXRvciA9IEZyb21Qcm9tTGlrZU1hcFtsYWJlbE9wZXJhdG9yXTtcbiAgICAgICAgICAgICAgICBpZiAobGFiZWxDb21wYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgICBsYWJlbE1hdGNoZXJzLnB1c2goeyBuYW1lOiBsYWJlbEtleSwgb3BlcmF0b3I6IGxhYmVsQ29tcGFyYXRvciwgdmFsdWU6IGxhYmVsVmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsYWJlbE1hdGNoZXJzO1xufVxuIiwiaW1wb3J0IHsgY2hhaW4sIG1hcCBhcyBfbWFwLCB1bmlxIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGxhc3RWYWx1ZUZyb20gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgTWV0cmljRmluZFZhbHVlLCBUaW1lUmFuZ2UgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IGdldFRpbWVTcnYgfSBmcm9tICdhcHAvZmVhdHVyZXMvZGFzaGJvYXJkL3NlcnZpY2VzL1RpbWVTcnYnO1xuXG5pbXBvcnQgeyBQcm9tZXRoZXVzRGF0YXNvdXJjZSB9IGZyb20gJy4vZGF0YXNvdXJjZSc7XG5pbXBvcnQgeyBQcm9tUXVlcnlSZXF1ZXN0IH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByb21ldGhldXNNZXRyaWNGaW5kUXVlcnkge1xuICByYW5nZTogVGltZVJhbmdlO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZGF0YXNvdXJjZTogUHJvbWV0aGV1c0RhdGFzb3VyY2UsIHByaXZhdGUgcXVlcnk6IHN0cmluZykge1xuICAgIHRoaXMuZGF0YXNvdXJjZSA9IGRhdGFzb3VyY2U7XG4gICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgIHRoaXMucmFuZ2UgPSBnZXRUaW1lU3J2KCkudGltZVJhbmdlKCk7XG4gIH1cblxuICBwcm9jZXNzKCk6IFByb21pc2U8TWV0cmljRmluZFZhbHVlW10+IHtcbiAgICBjb25zdCBsYWJlbE5hbWVzUmVnZXggPSAvXmxhYmVsX25hbWVzXFwoXFwpXFxzKiQvO1xuICAgIGNvbnN0IGxhYmVsVmFsdWVzUmVnZXggPSAvXmxhYmVsX3ZhbHVlc1xcKCg/OiguKyksXFxzKik/KFthLXpBLVpfXVthLXpBLVowLTlfXSopXFwpXFxzKiQvO1xuICAgIGNvbnN0IG1ldHJpY05hbWVzUmVnZXggPSAvXm1ldHJpY3NcXCgoLispXFwpXFxzKiQvO1xuICAgIGNvbnN0IHF1ZXJ5UmVzdWx0UmVnZXggPSAvXnF1ZXJ5X3Jlc3VsdFxcKCguKylcXClcXHMqJC87XG4gICAgY29uc3QgbGFiZWxOYW1lc1F1ZXJ5ID0gdGhpcy5xdWVyeS5tYXRjaChsYWJlbE5hbWVzUmVnZXgpO1xuICAgIGlmIChsYWJlbE5hbWVzUXVlcnkpIHtcbiAgICAgIHJldHVybiB0aGlzLmxhYmVsTmFtZXNRdWVyeSgpO1xuICAgIH1cblxuICAgIGNvbnN0IGxhYmVsVmFsdWVzUXVlcnkgPSB0aGlzLnF1ZXJ5Lm1hdGNoKGxhYmVsVmFsdWVzUmVnZXgpO1xuICAgIGlmIChsYWJlbFZhbHVlc1F1ZXJ5KSB7XG4gICAgICBpZiAobGFiZWxWYWx1ZXNRdWVyeVsxXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYWJlbFZhbHVlc1F1ZXJ5KGxhYmVsVmFsdWVzUXVlcnlbMl0sIGxhYmVsVmFsdWVzUXVlcnlbMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFiZWxWYWx1ZXNRdWVyeShsYWJlbFZhbHVlc1F1ZXJ5WzJdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBtZXRyaWNOYW1lc1F1ZXJ5ID0gdGhpcy5xdWVyeS5tYXRjaChtZXRyaWNOYW1lc1JlZ2V4KTtcbiAgICBpZiAobWV0cmljTmFtZXNRdWVyeSkge1xuICAgICAgcmV0dXJuIHRoaXMubWV0cmljTmFtZVF1ZXJ5KG1ldHJpY05hbWVzUXVlcnlbMV0pO1xuICAgIH1cblxuICAgIGNvbnN0IHF1ZXJ5UmVzdWx0UXVlcnkgPSB0aGlzLnF1ZXJ5Lm1hdGNoKHF1ZXJ5UmVzdWx0UmVnZXgpO1xuICAgIGlmIChxdWVyeVJlc3VsdFF1ZXJ5KSB7XG4gICAgICByZXR1cm4gbGFzdFZhbHVlRnJvbSh0aGlzLnF1ZXJ5UmVzdWx0UXVlcnkocXVlcnlSZXN1bHRRdWVyeVsxXSkpO1xuICAgIH1cblxuICAgIC8vIGlmIHF1ZXJ5IGNvbnRhaW5zIGZ1bGwgbWV0cmljIG5hbWUsIHJldHVybiBtZXRyaWMgbmFtZSBhbmQgbGFiZWwgbGlzdFxuICAgIHJldHVybiB0aGlzLm1ldHJpY05hbWVBbmRMYWJlbHNRdWVyeSh0aGlzLnF1ZXJ5KTtcbiAgfVxuXG4gIGxhYmVsTmFtZXNRdWVyeSgpIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuZGF0YXNvdXJjZS5nZXRQcm9tZXRoZXVzVGltZSh0aGlzLnJhbmdlLmZyb20sIGZhbHNlKTtcbiAgICBjb25zdCBlbmQgPSB0aGlzLmRhdGFzb3VyY2UuZ2V0UHJvbWV0aGV1c1RpbWUodGhpcy5yYW5nZS50bywgdHJ1ZSk7XG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgc3RhcnQ6IHN0YXJ0LnRvU3RyaW5nKCksXG4gICAgICBlbmQ6IGVuZC50b1N0cmluZygpLFxuICAgIH07XG5cbiAgICBjb25zdCB1cmwgPSBgL2FwaS92MS9sYWJlbHNgO1xuXG4gICAgcmV0dXJuIHRoaXMuZGF0YXNvdXJjZS5tZXRhZGF0YVJlcXVlc3QodXJsLCBwYXJhbXMpLnRoZW4oKHJlc3VsdDogYW55KSA9PiB7XG4gICAgICByZXR1cm4gX21hcChyZXN1bHQuZGF0YS5kYXRhLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHsgdGV4dDogdmFsdWUgfTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgbGFiZWxWYWx1ZXNRdWVyeShsYWJlbDogc3RyaW5nLCBtZXRyaWM/OiBzdHJpbmcpIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuZGF0YXNvdXJjZS5nZXRQcm9tZXRoZXVzVGltZSh0aGlzLnJhbmdlLmZyb20sIGZhbHNlKTtcbiAgICBjb25zdCBlbmQgPSB0aGlzLmRhdGFzb3VyY2UuZ2V0UHJvbWV0aGV1c1RpbWUodGhpcy5yYW5nZS50bywgdHJ1ZSk7XG5cbiAgICBsZXQgdXJsOiBzdHJpbmc7XG5cbiAgICBpZiAoIW1ldHJpYykge1xuICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICBzdGFydDogc3RhcnQudG9TdHJpbmcoKSxcbiAgICAgICAgZW5kOiBlbmQudG9TdHJpbmcoKSxcbiAgICAgIH07XG4gICAgICAvLyByZXR1cm4gbGFiZWwgdmFsdWVzIGdsb2JhbGx5XG4gICAgICB1cmwgPSBgL2FwaS92MS9sYWJlbC8ke2xhYmVsfS92YWx1ZXNgO1xuXG4gICAgICByZXR1cm4gdGhpcy5kYXRhc291cmNlLm1ldGFkYXRhUmVxdWVzdCh1cmwsIHBhcmFtcykudGhlbigocmVzdWx0OiBhbnkpID0+IHtcbiAgICAgICAgcmV0dXJuIF9tYXAocmVzdWx0LmRhdGEuZGF0YSwgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHsgdGV4dDogdmFsdWUgfTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAnbWF0Y2hbXSc6IG1ldHJpYyxcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LnRvU3RyaW5nKCksXG4gICAgICAgIGVuZDogZW5kLnRvU3RyaW5nKCksXG4gICAgICB9O1xuICAgICAgdXJsID0gYC9hcGkvdjEvc2VyaWVzYDtcblxuICAgICAgcmV0dXJuIHRoaXMuZGF0YXNvdXJjZS5tZXRhZGF0YVJlcXVlc3QodXJsLCBwYXJhbXMpLnRoZW4oKHJlc3VsdDogYW55KSA9PiB7XG4gICAgICAgIGNvbnN0IF9sYWJlbHMgPSBfbWFwKHJlc3VsdC5kYXRhLmRhdGEsIChtZXRyaWMpID0+IHtcbiAgICAgICAgICByZXR1cm4gbWV0cmljW2xhYmVsXSB8fCAnJztcbiAgICAgICAgfSkuZmlsdGVyKChsYWJlbCkgPT4ge1xuICAgICAgICAgIHJldHVybiBsYWJlbCAhPT0gJyc7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB1bmlxKF9sYWJlbHMpLm1hcCgobWV0cmljKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRleHQ6IG1ldHJpYyxcbiAgICAgICAgICAgIGV4cGFuZGFibGU6IHRydWUsXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBtZXRyaWNOYW1lUXVlcnkobWV0cmljRmlsdGVyUGF0dGVybjogc3RyaW5nKSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLmRhdGFzb3VyY2UuZ2V0UHJvbWV0aGV1c1RpbWUodGhpcy5yYW5nZS5mcm9tLCBmYWxzZSk7XG4gICAgY29uc3QgZW5kID0gdGhpcy5kYXRhc291cmNlLmdldFByb21ldGhldXNUaW1lKHRoaXMucmFuZ2UudG8sIHRydWUpO1xuICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgIHN0YXJ0OiBzdGFydC50b1N0cmluZygpLFxuICAgICAgZW5kOiBlbmQudG9TdHJpbmcoKSxcbiAgICB9O1xuICAgIGNvbnN0IHVybCA9IGAvYXBpL3YxL2xhYmVsL19fbmFtZV9fL3ZhbHVlc2A7XG5cbiAgICByZXR1cm4gdGhpcy5kYXRhc291cmNlLm1ldGFkYXRhUmVxdWVzdCh1cmwsIHBhcmFtcykudGhlbigocmVzdWx0OiBhbnkpID0+IHtcbiAgICAgIHJldHVybiBjaGFpbihyZXN1bHQuZGF0YS5kYXRhKVxuICAgICAgICAuZmlsdGVyKChtZXRyaWNOYW1lKSA9PiB7XG4gICAgICAgICAgY29uc3QgciA9IG5ldyBSZWdFeHAobWV0cmljRmlsdGVyUGF0dGVybik7XG4gICAgICAgICAgcmV0dXJuIHIudGVzdChtZXRyaWNOYW1lKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm1hcCgobWF0Y2hlZE1ldHJpY05hbWUpID0+IHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dDogbWF0Y2hlZE1ldHJpY05hbWUsXG4gICAgICAgICAgICBleHBhbmRhYmxlOiB0cnVlLFxuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICAgIC52YWx1ZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgcXVlcnlSZXN1bHRRdWVyeShxdWVyeTogc3RyaW5nKSB7XG4gICAgY29uc3QgZW5kID0gdGhpcy5kYXRhc291cmNlLmdldFByb21ldGhldXNUaW1lKHRoaXMucmFuZ2UudG8sIHRydWUpO1xuICAgIGNvbnN0IGluc3RhbnRRdWVyeTogUHJvbVF1ZXJ5UmVxdWVzdCA9IHsgZXhwcjogcXVlcnkgfSBhcyBQcm9tUXVlcnlSZXF1ZXN0O1xuICAgIHJldHVybiB0aGlzLmRhdGFzb3VyY2UucGVyZm9ybUluc3RhbnRRdWVyeShpbnN0YW50UXVlcnksIGVuZCkucGlwZShcbiAgICAgIG1hcCgocmVzdWx0KSA9PiB7XG4gICAgICAgIHJldHVybiBfbWFwKHJlc3VsdC5kYXRhLmRhdGEucmVzdWx0LCAobWV0cmljRGF0YSkgPT4ge1xuICAgICAgICAgIGxldCB0ZXh0ID0gbWV0cmljRGF0YS5tZXRyaWMuX19uYW1lX18gfHwgJyc7XG4gICAgICAgICAgZGVsZXRlIG1ldHJpY0RhdGEubWV0cmljLl9fbmFtZV9fO1xuICAgICAgICAgIHRleHQgKz1cbiAgICAgICAgICAgICd7JyArXG4gICAgICAgICAgICBfbWFwKG1ldHJpY0RhdGEubWV0cmljLCAodiwgaykgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gayArICc9XCInICsgdiArICdcIic7XG4gICAgICAgICAgICB9KS5qb2luKCcsJykgK1xuICAgICAgICAgICAgJ30nO1xuICAgICAgICAgIHRleHQgKz0gJyAnICsgbWV0cmljRGF0YS52YWx1ZVsxXSArICcgJyArIG1ldHJpY0RhdGEudmFsdWVbMF0gKiAxMDAwO1xuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgICBleHBhbmRhYmxlOiB0cnVlLFxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgbWV0cmljTmFtZUFuZExhYmVsc1F1ZXJ5KHF1ZXJ5OiBzdHJpbmcpOiBQcm9taXNlPE1ldHJpY0ZpbmRWYWx1ZVtdPiB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLmRhdGFzb3VyY2UuZ2V0UHJvbWV0aGV1c1RpbWUodGhpcy5yYW5nZS5mcm9tLCBmYWxzZSk7XG4gICAgY29uc3QgZW5kID0gdGhpcy5kYXRhc291cmNlLmdldFByb21ldGhldXNUaW1lKHRoaXMucmFuZ2UudG8sIHRydWUpO1xuICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICdtYXRjaFtdJzogcXVlcnksXG4gICAgICBzdGFydDogc3RhcnQudG9TdHJpbmcoKSxcbiAgICAgIGVuZDogZW5kLnRvU3RyaW5nKCksXG4gICAgfTtcblxuICAgIGNvbnN0IHVybCA9IGAvYXBpL3YxL3Nlcmllc2A7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICByZXR1cm4gdGhpcy5kYXRhc291cmNlLm1ldGFkYXRhUmVxdWVzdCh1cmwsIHBhcmFtcykudGhlbigocmVzdWx0OiBhbnkpID0+IHtcbiAgICAgIHJldHVybiBfbWFwKHJlc3VsdC5kYXRhLmRhdGEsIChtZXRyaWM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0ZXh0OiBzZWxmLmRhdGFzb3VyY2UuZ2V0T3JpZ2luYWxNZXRyaWNOYW1lKG1ldHJpYyksXG4gICAgICAgICAgZXhwYW5kYWJsZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG4iLCJpbXBvcnQgeyBEYXRhU291cmNlUGx1Z2luIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5cbmltcG9ydCBQcm9tQ2hlYXRTaGVldCBmcm9tICcuL2NvbXBvbmVudHMvUHJvbUNoZWF0U2hlZXQnO1xuaW1wb3J0IFByb21RdWVyeUVkaXRvckJ5QXBwIGZyb20gJy4vY29tcG9uZW50cy9Qcm9tUXVlcnlFZGl0b3JCeUFwcCc7XG5pbXBvcnQgeyBDb25maWdFZGl0b3IgfSBmcm9tICcuL2NvbmZpZ3VyYXRpb24vQ29uZmlnRWRpdG9yJztcbmltcG9ydCB7IEFOTk9UQVRJT05fUVVFUllfU1RFUF9ERUZBVUxULCBQcm9tZXRoZXVzRGF0YXNvdXJjZSB9IGZyb20gJy4vZGF0YXNvdXJjZSc7XG5cbmNsYXNzIFByb21ldGhldXNBbm5vdGF0aW9uc1F1ZXJ5Q3RybCB7XG4gIHN0YXRpYyB0ZW1wbGF0ZVVybCA9ICdwYXJ0aWFscy9hbm5vdGF0aW9ucy5lZGl0b3IuaHRtbCc7XG4gIHN0ZXBEZWZhdWx0VmFsdWVQbGFjZWhvbGRlciA9IEFOTk9UQVRJT05fUVVFUllfU1RFUF9ERUZBVUxUO1xufVxuXG5leHBvcnQgY29uc3QgcGx1Z2luID0gbmV3IERhdGFTb3VyY2VQbHVnaW4oUHJvbWV0aGV1c0RhdGFzb3VyY2UpXG4gIC5zZXRRdWVyeUVkaXRvcihQcm9tUXVlcnlFZGl0b3JCeUFwcClcbiAgLnNldENvbmZpZ0VkaXRvcihDb25maWdFZGl0b3IpXG4gIC5zZXRBbm5vdGF0aW9uUXVlcnlDdHJsKFByb21ldGhldXNBbm5vdGF0aW9uc1F1ZXJ5Q3RybClcbiAgLnNldFF1ZXJ5RWRpdG9ySGVscChQcm9tQ2hlYXRTaGVldCk7XG4iLCJpbXBvcnQgeyBHcmFtbWFyIH0gZnJvbSAncHJpc21qcyc7XG5cbmltcG9ydCB7IENvbXBsZXRpb25JdGVtIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG4vLyBXaGVuIGNoYW5naW5nIFJBVEVfUkFOR0VTLCBjaGVjayBpZiBMb2tpL0xvZ1FMIHJhbmdlcyBzaG91bGQgYmUgY2hhbmdlZCB0b29cbi8vIEBzZWUgcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvbG9raS9sYW5ndWFnZV9wcm92aWRlci50c1xuZXhwb3J0IGNvbnN0IFJBVEVfUkFOR0VTOiBDb21wbGV0aW9uSXRlbVtdID0gW1xuICB7IGxhYmVsOiAnJF9faW50ZXJ2YWwnLCBzb3J0VmFsdWU6ICckX19pbnRlcnZhbCcgfSxcbiAgeyBsYWJlbDogJyRfX3JhdGVfaW50ZXJ2YWwnLCBzb3J0VmFsdWU6ICckX19yYXRlX2ludGVydmFsJyB9LFxuICB7IGxhYmVsOiAnJF9fcmFuZ2UnLCBzb3J0VmFsdWU6ICckX19yYW5nZScgfSxcbiAgeyBsYWJlbDogJzFtJywgc29ydFZhbHVlOiAnMDA6MDE6MDAnIH0sXG4gIHsgbGFiZWw6ICc1bScsIHNvcnRWYWx1ZTogJzAwOjA1OjAwJyB9LFxuICB7IGxhYmVsOiAnMTBtJywgc29ydFZhbHVlOiAnMDA6MTA6MDAnIH0sXG4gIHsgbGFiZWw6ICczMG0nLCBzb3J0VmFsdWU6ICcwMDozMDowMCcgfSxcbiAgeyBsYWJlbDogJzFoJywgc29ydFZhbHVlOiAnMDE6MDA6MDAnIH0sXG4gIHsgbGFiZWw6ICcxZCcsIHNvcnRWYWx1ZTogJzI0OjAwOjAwJyB9LFxuXTtcblxuZXhwb3J0IGNvbnN0IE9QRVJBVE9SUyA9IFsnYnknLCAnZ3JvdXBfbGVmdCcsICdncm91cF9yaWdodCcsICdpZ25vcmluZycsICdvbicsICdvZmZzZXQnLCAnd2l0aG91dCddO1xuZXhwb3J0IGNvbnN0IExPR0lDQUxfT1BFUkFUT1JTID0gWydvcicsICdhbmQnLCAndW5sZXNzJ107XG5cbmNvbnN0IFRSSUdPTk9NRVRSSUNfRlVOQ1RJT05TOiBDb21wbGV0aW9uSXRlbVtdID0gW1xuICB7XG4gICAgbGFiZWw6ICdhY29zJyxcbiAgICBpbnNlcnRUZXh0OiAnYWNvcycsXG4gICAgZGV0YWlsOiAnYWNvcyh2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ2NhbGN1bGF0ZXMgdGhlIGFyY2Nvc2luZSBvZiBhbGwgZWxlbWVudHMgaW4gdicsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ2Fjb3NoJyxcbiAgICBpbnNlcnRUZXh0OiAnYWNvc2gnLFxuICAgIGRldGFpbDogJ2Fjb3NoKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnY2FsY3VsYXRlcyB0aGUgaW52ZXJzZSBoeXBlcmJvbGljIGNvc2luZSBvZiBhbGwgZWxlbWVudHMgaW4gdicsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ2FzaW4nLFxuICAgIGluc2VydFRleHQ6ICdhc2luJyxcbiAgICBkZXRhaWw6ICdhc2luKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnY2FsY3VsYXRlcyB0aGUgYXJjc2luZSBvZiBhbGwgZWxlbWVudHMgaW4gdicsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ2FzaW5oJyxcbiAgICBpbnNlcnRUZXh0OiAnYXNpbmgnLFxuICAgIGRldGFpbDogJ2FzaW5oKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnY2FsY3VsYXRlcyB0aGUgaW52ZXJzZSBoeXBlcmJvbGljIHNpbmUgb2YgYWxsIGVsZW1lbnRzIGluIHYnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdhdGFuJyxcbiAgICBpbnNlcnRUZXh0OiAnYXRhbicsXG4gICAgZGV0YWlsOiAnYXRhbih2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ2NhbGN1bGF0ZXMgdGhlIGFyY3RhbmdlbnQgb2YgYWxsIGVsZW1lbnRzIGluIHYnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdhdGFuaCcsXG4gICAgaW5zZXJ0VGV4dDogJ2F0YW5oJyxcbiAgICBkZXRhaWw6ICdhdGFuaCh2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ2NhbGN1bGF0ZXMgdGhlIGludmVyc2UgaHlwZXJib2xpYyB0YW5nZW50IG9mIGFsbCBlbGVtZW50cyBpbiB2JyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnY29zJyxcbiAgICBpbnNlcnRUZXh0OiAnY29zJyxcbiAgICBkZXRhaWw6ICdjb3ModiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdjYWxjdWxhdGVzIHRoZSBjb3NpbmUgb2YgYWxsIGVsZW1lbnRzIGluIHYnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdjb3NoJyxcbiAgICBpbnNlcnRUZXh0OiAnY29zaCcsXG4gICAgZGV0YWlsOiAnY29zaCh2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ2NhbGN1bGF0ZXMgdGhlIGh5cGVyYm9saWMgY29zaW5lIG9mIGFsbCBlbGVtZW50cyBpbiB2JyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnc2luJyxcbiAgICBpbnNlcnRUZXh0OiAnc2luJyxcbiAgICBkZXRhaWw6ICdzaW4odiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdjYWxjdWxhdGVzIHRoZSBzaW5lIG9mIGFsbCBlbGVtZW50cyBpbiB2JyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnc2luaCcsXG4gICAgaW5zZXJ0VGV4dDogJ3NpbmgnLFxuICAgIGRldGFpbDogJ3NpbmgodiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdjYWxjdWxhdGVzIHRoZSBoeXBlcmJvbGljIHNpbmUgb2YgYWxsIGVsZW1lbnRzIGluIHYnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICd0YW4nLFxuICAgIGluc2VydFRleHQ6ICd0YW4nLFxuICAgIGRldGFpbDogJ3Rhbih2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ2NhbGN1bGF0ZXMgdGhlIHRhbmdlbnQgb2YgYWxsIGVsZW1lbnRzIGluIHYnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICd0YW5oJyxcbiAgICBpbnNlcnRUZXh0OiAndGFuaCcsXG4gICAgZGV0YWlsOiAndGFuaCh2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ2NhbGN1bGF0ZXMgdGhlIGh5cGVyYm9saWMgdGFuZ2VudCBvZiBhbGwgZWxlbWVudHMgaW4gdicsXG4gIH0sXG5dO1xuXG5jb25zdCBBR0dSRUdBVElPTl9PUEVSQVRPUlM6IENvbXBsZXRpb25JdGVtW10gPSBbXG4gIHtcbiAgICBsYWJlbDogJ3N1bScsXG4gICAgaW5zZXJ0VGV4dDogJ3N1bScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ0NhbGN1bGF0ZSBzdW0gb3ZlciBkaW1lbnNpb25zJyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnbWluJyxcbiAgICBpbnNlcnRUZXh0OiAnbWluJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnU2VsZWN0IG1pbmltdW0gb3ZlciBkaW1lbnNpb25zJyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnbWF4JyxcbiAgICBpbnNlcnRUZXh0OiAnbWF4JyxcbiAgICBkb2N1bWVudGF0aW9uOiAnU2VsZWN0IG1heGltdW0gb3ZlciBkaW1lbnNpb25zJyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnYXZnJyxcbiAgICBpbnNlcnRUZXh0OiAnYXZnJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnQ2FsY3VsYXRlIHRoZSBhdmVyYWdlIG92ZXIgZGltZW5zaW9ucycsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ2dyb3VwJyxcbiAgICBpbnNlcnRUZXh0OiAnZ3JvdXAnLFxuICAgIGRvY3VtZW50YXRpb246ICdBbGwgdmFsdWVzIGluIHRoZSByZXN1bHRpbmcgdmVjdG9yIGFyZSAxJyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnc3RkZGV2JyxcbiAgICBpbnNlcnRUZXh0OiAnc3RkZGV2JyxcbiAgICBkb2N1bWVudGF0aW9uOiAnQ2FsY3VsYXRlIHBvcHVsYXRpb24gc3RhbmRhcmQgZGV2aWF0aW9uIG92ZXIgZGltZW5zaW9ucycsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ3N0ZHZhcicsXG4gICAgaW5zZXJ0VGV4dDogJ3N0ZHZhcicsXG4gICAgZG9jdW1lbnRhdGlvbjogJ0NhbGN1bGF0ZSBwb3B1bGF0aW9uIHN0YW5kYXJkIHZhcmlhbmNlIG92ZXIgZGltZW5zaW9ucycsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ2NvdW50JyxcbiAgICBpbnNlcnRUZXh0OiAnY291bnQnLFxuICAgIGRvY3VtZW50YXRpb246ICdDb3VudCBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHZlY3RvcicsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ2NvdW50X3ZhbHVlcycsXG4gICAgaW5zZXJ0VGV4dDogJ2NvdW50X3ZhbHVlcycsXG4gICAgZG9jdW1lbnRhdGlvbjogJ0NvdW50IG51bWJlciBvZiBlbGVtZW50cyB3aXRoIHRoZSBzYW1lIHZhbHVlJyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnYm90dG9taycsXG4gICAgaW5zZXJ0VGV4dDogJ2JvdHRvbWsnLFxuICAgIGRvY3VtZW50YXRpb246ICdTbWFsbGVzdCBrIGVsZW1lbnRzIGJ5IHNhbXBsZSB2YWx1ZScsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ3RvcGsnLFxuICAgIGluc2VydFRleHQ6ICd0b3BrJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnTGFyZ2VzdCBrIGVsZW1lbnRzIGJ5IHNhbXBsZSB2YWx1ZScsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ3F1YW50aWxlJyxcbiAgICBpbnNlcnRUZXh0OiAncXVhbnRpbGUnLFxuICAgIGRvY3VtZW50YXRpb246ICdDYWxjdWxhdGUgz4YtcXVhbnRpbGUgKDAg4omkIM+GIOKJpCAxKSBvdmVyIGRpbWVuc2lvbnMnLFxuICB9LFxuXTtcblxuZXhwb3J0IGNvbnN0IEZVTkNUSU9OUyA9IFtcbiAgLi4uQUdHUkVHQVRJT05fT1BFUkFUT1JTLFxuICAuLi5UUklHT05PTUVUUklDX0ZVTkNUSU9OUyxcbiAge1xuICAgIGluc2VydFRleHQ6ICdhYnMnLFxuICAgIGxhYmVsOiAnYWJzJyxcbiAgICBkZXRhaWw6ICdhYnModiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdSZXR1cm5zIHRoZSBpbnB1dCB2ZWN0b3Igd2l0aCBhbGwgc2FtcGxlIHZhbHVlcyBjb252ZXJ0ZWQgdG8gdGhlaXIgYWJzb2x1dGUgdmFsdWUuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdhYnNlbnQnLFxuICAgIGxhYmVsOiAnYWJzZW50JyxcbiAgICBkZXRhaWw6ICdhYnNlbnQodiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnUmV0dXJucyBhbiBlbXB0eSB2ZWN0b3IgaWYgdGhlIHZlY3RvciBwYXNzZWQgdG8gaXQgaGFzIGFueSBlbGVtZW50cyBhbmQgYSAxLWVsZW1lbnQgdmVjdG9yIHdpdGggdGhlIHZhbHVlIDEgaWYgdGhlIHZlY3RvciBwYXNzZWQgdG8gaXQgaGFzIG5vIGVsZW1lbnRzLiBUaGlzIGlzIHVzZWZ1bCBmb3IgYWxlcnRpbmcgb24gd2hlbiBubyB0aW1lIHNlcmllcyBleGlzdCBmb3IgYSBnaXZlbiBtZXRyaWMgbmFtZSBhbmQgbGFiZWwgY29tYmluYXRpb24uJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdhYnNlbnRfb3Zlcl90aW1lJyxcbiAgICBsYWJlbDogJ2Fic2VudF9vdmVyX3RpbWUnLFxuICAgIGRldGFpbDogJ2Fic2VudCh2IHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnUmV0dXJucyBhbiBlbXB0eSB2ZWN0b3IgaWYgdGhlIHJhbmdlIHZlY3RvciBwYXNzZWQgdG8gaXQgaGFzIGFueSBlbGVtZW50cyBhbmQgYSAxLWVsZW1lbnQgdmVjdG9yIHdpdGggdGhlIHZhbHVlIDEgaWYgdGhlIHJhbmdlIHZlY3RvciBwYXNzZWQgdG8gaXQgaGFzIG5vIGVsZW1lbnRzLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnY2VpbCcsXG4gICAgbGFiZWw6ICdjZWlsJyxcbiAgICBkZXRhaWw6ICdjZWlsKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnUm91bmRzIHRoZSBzYW1wbGUgdmFsdWVzIG9mIGFsbCBlbGVtZW50cyBpbiBgdmAgdXAgdG8gdGhlIG5lYXJlc3QgaW50ZWdlci4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2NoYW5nZXMnLFxuICAgIGxhYmVsOiAnY2hhbmdlcycsXG4gICAgZGV0YWlsOiAnY2hhbmdlcyh2IHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnRm9yIGVhY2ggaW5wdXQgdGltZSBzZXJpZXMsIGBjaGFuZ2VzKHYgcmFuZ2UtdmVjdG9yKWAgcmV0dXJucyB0aGUgbnVtYmVyIG9mIHRpbWVzIGl0cyB2YWx1ZSBoYXMgY2hhbmdlZCB3aXRoaW4gdGhlIHByb3ZpZGVkIHRpbWUgcmFuZ2UgYXMgYW4gaW5zdGFudCB2ZWN0b3IuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdjbGFtcCcsXG4gICAgbGFiZWw6ICdjbGFtcCcsXG4gICAgZGV0YWlsOiAnY2xhbXAodiBpbnN0YW50LXZlY3RvciwgbWluIHNjYWxhciwgbWF4IHNjYWxhciknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnQ2xhbXBzIHRoZSBzYW1wbGUgdmFsdWVzIG9mIGFsbCBlbGVtZW50cyBpbiBgdmAgdG8gaGF2ZSBhIGxvd2VyIGxpbWl0IG9mIGBtaW5gIGFuZCBhbiB1cHBlciBsaW1pdCBvZiBgbWF4YC4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2NsYW1wX21heCcsXG4gICAgbGFiZWw6ICdjbGFtcF9tYXgnLFxuICAgIGRldGFpbDogJ2NsYW1wX21heCh2IGluc3RhbnQtdmVjdG9yLCBtYXggc2NhbGFyKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ0NsYW1wcyB0aGUgc2FtcGxlIHZhbHVlcyBvZiBhbGwgZWxlbWVudHMgaW4gYHZgIHRvIGhhdmUgYW4gdXBwZXIgbGltaXQgb2YgYG1heGAuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdjbGFtcF9taW4nLFxuICAgIGxhYmVsOiAnY2xhbXBfbWluJyxcbiAgICBkZXRhaWw6ICdjbGFtcF9taW4odiBpbnN0YW50LXZlY3RvciwgbWluIHNjYWxhciknLFxuICAgIGRvY3VtZW50YXRpb246ICdDbGFtcHMgdGhlIHNhbXBsZSB2YWx1ZXMgb2YgYWxsIGVsZW1lbnRzIGluIGB2YCB0byBoYXZlIGEgbG93ZXIgbGltaXQgb2YgYG1pbmAuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdjb3VudF9zY2FsYXInLFxuICAgIGxhYmVsOiAnY291bnRfc2NhbGFyJyxcbiAgICBkZXRhaWw6ICdjb3VudF9zY2FsYXIodiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIGEgdGltZSBzZXJpZXMgdmVjdG9yIGFzIGEgc2NhbGFyLiBUaGlzIGlzIGluIGNvbnRyYXN0IHRvIHRoZSBgY291bnQoKWAgYWdncmVnYXRpb24gb3BlcmF0b3IsIHdoaWNoIGFsd2F5cyByZXR1cm5zIGEgdmVjdG9yIChhbiBlbXB0eSBvbmUgaWYgdGhlIGlucHV0IHZlY3RvciBpcyBlbXB0eSkgYW5kIGFsbG93cyBncm91cGluZyBieSBsYWJlbHMgdmlhIGEgYGJ5YCBjbGF1c2UuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdkZWcnLFxuICAgIGxhYmVsOiAnZGVnJyxcbiAgICBkZXRhaWw6ICdkZWcodiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdDb252ZXJ0cyByYWRpYW5zIHRvIGRlZ3JlZXMgZm9yIGFsbCBlbGVtZW50cyBpbiB2JyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdkYXlfb2ZfbW9udGgnLFxuICAgIGxhYmVsOiAnZGF5X29mX21vbnRoJyxcbiAgICBkZXRhaWw6ICdkYXlfb2ZfbW9udGgodj12ZWN0b3IodGltZSgpKSBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdSZXR1cm5zIHRoZSBkYXkgb2YgdGhlIG1vbnRoIGZvciBlYWNoIG9mIHRoZSBnaXZlbiB0aW1lcyBpbiBVVEMuIFJldHVybmVkIHZhbHVlcyBhcmUgZnJvbSAxIHRvIDMxLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnZGF5X29mX3dlZWsnLFxuICAgIGxhYmVsOiAnZGF5X29mX3dlZWsnLFxuICAgIGRldGFpbDogJ2RheV9vZl93ZWVrKHY9dmVjdG9yKHRpbWUoKSkgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ1JldHVybnMgdGhlIGRheSBvZiB0aGUgd2VlayBmb3IgZWFjaCBvZiB0aGUgZ2l2ZW4gdGltZXMgaW4gVVRDLiBSZXR1cm5lZCB2YWx1ZXMgYXJlIGZyb20gMCB0byA2LCB3aGVyZSAwIG1lYW5zIFN1bmRheSBldGMuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdkYXlzX2luX21vbnRoJyxcbiAgICBsYWJlbDogJ2RheXNfaW5fbW9udGgnLFxuICAgIGRldGFpbDogJ2RheXNfaW5fbW9udGgodj12ZWN0b3IodGltZSgpKSBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnUmV0dXJucyBudW1iZXIgb2YgZGF5cyBpbiB0aGUgbW9udGggZm9yIGVhY2ggb2YgdGhlIGdpdmVuIHRpbWVzIGluIFVUQy4gUmV0dXJuZWQgdmFsdWVzIGFyZSBmcm9tIDI4IHRvIDMxLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnZGVsdGEnLFxuICAgIGxhYmVsOiAnZGVsdGEnLFxuICAgIGRldGFpbDogJ2RlbHRhKHYgcmFuZ2UtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdDYWxjdWxhdGVzIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIGZpcnN0IGFuZCBsYXN0IHZhbHVlIG9mIGVhY2ggdGltZSBzZXJpZXMgZWxlbWVudCBpbiBhIHJhbmdlIHZlY3RvciBgdmAsIHJldHVybmluZyBhbiBpbnN0YW50IHZlY3RvciB3aXRoIHRoZSBnaXZlbiBkZWx0YXMgYW5kIGVxdWl2YWxlbnQgbGFiZWxzLiBUaGUgZGVsdGEgaXMgZXh0cmFwb2xhdGVkIHRvIGNvdmVyIHRoZSBmdWxsIHRpbWUgcmFuZ2UgYXMgc3BlY2lmaWVkIGluIHRoZSByYW5nZSB2ZWN0b3Igc2VsZWN0b3IsIHNvIHRoYXQgaXQgaXMgcG9zc2libGUgdG8gZ2V0IGEgbm9uLWludGVnZXIgcmVzdWx0IGV2ZW4gaWYgdGhlIHNhbXBsZSB2YWx1ZXMgYXJlIGFsbCBpbnRlZ2Vycy4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2Rlcml2JyxcbiAgICBsYWJlbDogJ2Rlcml2JyxcbiAgICBkZXRhaWw6ICdkZXJpdih2IHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnQ2FsY3VsYXRlcyB0aGUgcGVyLXNlY29uZCBkZXJpdmF0aXZlIG9mIHRoZSB0aW1lIHNlcmllcyBpbiBhIHJhbmdlIHZlY3RvciBgdmAsIHVzaW5nIHNpbXBsZSBsaW5lYXIgcmVncmVzc2lvbi4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2Ryb3BfY29tbW9uX2xhYmVscycsXG4gICAgbGFiZWw6ICdkcm9wX2NvbW1vbl9sYWJlbHMnLFxuICAgIGRldGFpbDogJ2Ryb3BfY29tbW9uX2xhYmVscyhpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdEcm9wcyBhbGwgbGFiZWxzIHRoYXQgaGF2ZSB0aGUgc2FtZSBuYW1lIGFuZCB2YWx1ZSBhY3Jvc3MgYWxsIHNlcmllcyBpbiB0aGUgaW5wdXQgdmVjdG9yLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnZXhwJyxcbiAgICBsYWJlbDogJ2V4cCcsXG4gICAgZGV0YWlsOiAnZXhwKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ0NhbGN1bGF0ZXMgdGhlIGV4cG9uZW50aWFsIGZ1bmN0aW9uIGZvciBhbGwgZWxlbWVudHMgaW4gYHZgLlxcblNwZWNpYWwgY2FzZXMgYXJlOlxcbiogYEV4cCgrSW5mKSA9ICtJbmZgIFxcbiogYEV4cChOYU4pID0gTmFOYCcsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnZmxvb3InLFxuICAgIGxhYmVsOiAnZmxvb3InLFxuICAgIGRldGFpbDogJ2Zsb29yKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnUm91bmRzIHRoZSBzYW1wbGUgdmFsdWVzIG9mIGFsbCBlbGVtZW50cyBpbiBgdmAgZG93biB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnaGlzdG9ncmFtX3F1YW50aWxlJyxcbiAgICBsYWJlbDogJ2hpc3RvZ3JhbV9xdWFudGlsZScsXG4gICAgZGV0YWlsOiAnaGlzdG9ncmFtX3F1YW50aWxlKM+GIGZsb2F0LCBiIGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdDYWxjdWxhdGVzIHRoZSDPhi1xdWFudGlsZSAoMCDiiaQgz4Yg4omkIDEpIGZyb20gdGhlIGJ1Y2tldHMgYGJgIG9mIGEgaGlzdG9ncmFtLiBUaGUgc2FtcGxlcyBpbiBgYmAgYXJlIHRoZSBjb3VudHMgb2Ygb2JzZXJ2YXRpb25zIGluIGVhY2ggYnVja2V0LiBFYWNoIHNhbXBsZSBtdXN0IGhhdmUgYSBsYWJlbCBgbGVgIHdoZXJlIHRoZSBsYWJlbCB2YWx1ZSBkZW5vdGVzIHRoZSBpbmNsdXNpdmUgdXBwZXIgYm91bmQgb2YgdGhlIGJ1Y2tldC4gKFNhbXBsZXMgd2l0aG91dCBzdWNoIGEgbGFiZWwgYXJlIHNpbGVudGx5IGlnbm9yZWQuKSBUaGUgaGlzdG9ncmFtIG1ldHJpYyB0eXBlIGF1dG9tYXRpY2FsbHkgcHJvdmlkZXMgdGltZSBzZXJpZXMgd2l0aCB0aGUgYF9idWNrZXRgIHN1ZmZpeCBhbmQgdGhlIGFwcHJvcHJpYXRlIGxhYmVscy4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2hvbHRfd2ludGVycycsXG4gICAgbGFiZWw6ICdob2x0X3dpbnRlcnMnLFxuICAgIGRldGFpbDogJ2hvbHRfd2ludGVycyh2IHJhbmdlLXZlY3Rvciwgc2Ygc2NhbGFyLCB0ZiBzY2FsYXIpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ1Byb2R1Y2VzIGEgc21vb3RoZWQgdmFsdWUgZm9yIHRpbWUgc2VyaWVzIGJhc2VkIG9uIHRoZSByYW5nZSBpbiBgdmAuIFRoZSBsb3dlciB0aGUgc21vb3RoaW5nIGZhY3RvciBgc2ZgLCB0aGUgbW9yZSBpbXBvcnRhbmNlIGlzIGdpdmVuIHRvIG9sZCBkYXRhLiBUaGUgaGlnaGVyIHRoZSB0cmVuZCBmYWN0b3IgYHRmYCwgdGhlIG1vcmUgdHJlbmRzIGluIHRoZSBkYXRhIGlzIGNvbnNpZGVyZWQuIEJvdGggYHNmYCBhbmQgYHRmYCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMS4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2hvdXInLFxuICAgIGxhYmVsOiAnaG91cicsXG4gICAgZGV0YWlsOiAnaG91cih2PXZlY3Rvcih0aW1lKCkpIGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1JldHVybnMgdGhlIGhvdXIgb2YgdGhlIGRheSBmb3IgZWFjaCBvZiB0aGUgZ2l2ZW4gdGltZXMgaW4gVVRDLiBSZXR1cm5lZCB2YWx1ZXMgYXJlIGZyb20gMCB0byAyMy4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2lkZWx0YScsXG4gICAgbGFiZWw6ICdpZGVsdGEnLFxuICAgIGRldGFpbDogJ2lkZWx0YSh2IHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnQ2FsY3VsYXRlcyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBsYXN0IHR3byBzYW1wbGVzIGluIHRoZSByYW5nZSB2ZWN0b3IgYHZgLCByZXR1cm5pbmcgYW4gaW5zdGFudCB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gZGVsdGFzIGFuZCBlcXVpdmFsZW50IGxhYmVscy4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2luY3JlYXNlJyxcbiAgICBsYWJlbDogJ2luY3JlYXNlJyxcbiAgICBkZXRhaWw6ICdpbmNyZWFzZSh2IHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnQ2FsY3VsYXRlcyB0aGUgaW5jcmVhc2UgaW4gdGhlIHRpbWUgc2VyaWVzIGluIHRoZSByYW5nZSB2ZWN0b3IuIEJyZWFrcyBpbiBtb25vdG9uaWNpdHkgKHN1Y2ggYXMgY291bnRlciByZXNldHMgZHVlIHRvIHRhcmdldCByZXN0YXJ0cykgYXJlIGF1dG9tYXRpY2FsbHkgYWRqdXN0ZWQgZm9yLiBUaGUgaW5jcmVhc2UgaXMgZXh0cmFwb2xhdGVkIHRvIGNvdmVyIHRoZSBmdWxsIHRpbWUgcmFuZ2UgYXMgc3BlY2lmaWVkIGluIHRoZSByYW5nZSB2ZWN0b3Igc2VsZWN0b3IsIHNvIHRoYXQgaXQgaXMgcG9zc2libGUgdG8gZ2V0IGEgbm9uLWludGVnZXIgcmVzdWx0IGV2ZW4gaWYgYSBjb3VudGVyIGluY3JlYXNlcyBvbmx5IGJ5IGludGVnZXIgaW5jcmVtZW50cy4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2lyYXRlJyxcbiAgICBsYWJlbDogJ2lyYXRlJyxcbiAgICBkZXRhaWw6ICdpcmF0ZSh2IHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnQ2FsY3VsYXRlcyB0aGUgcGVyLXNlY29uZCBpbnN0YW50IHJhdGUgb2YgaW5jcmVhc2Ugb2YgdGhlIHRpbWUgc2VyaWVzIGluIHRoZSByYW5nZSB2ZWN0b3IuIFRoaXMgaXMgYmFzZWQgb24gdGhlIGxhc3QgdHdvIGRhdGEgcG9pbnRzLiBCcmVha3MgaW4gbW9ub3RvbmljaXR5IChzdWNoIGFzIGNvdW50ZXIgcmVzZXRzIGR1ZSB0byB0YXJnZXQgcmVzdGFydHMpIGFyZSBhdXRvbWF0aWNhbGx5IGFkanVzdGVkIGZvci4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2xhYmVsX2pvaW4nLFxuICAgIGxhYmVsOiAnbGFiZWxfam9pbicsXG4gICAgZGV0YWlsOlxuICAgICAgJ2xhYmVsX2pvaW4odiBpbnN0YW50LXZlY3RvciwgZHN0X2xhYmVsIHN0cmluZywgc2VwYXJhdG9yIHN0cmluZywgc3JjX2xhYmVsXzEgc3RyaW5nLCBzcmNfbGFiZWxfMiBzdHJpbmcsIC4uLiknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnRm9yIGVhY2ggdGltZXNlcmllcyBpbiBgdmAsIGpvaW5zIGFsbCB0aGUgdmFsdWVzIG9mIGFsbCB0aGUgYHNyY19sYWJlbHNgIHVzaW5nIGBzZXBhcmF0b3JgIGFuZCByZXR1cm5zIHRoZSB0aW1lc2VyaWVzIHdpdGggdGhlIGxhYmVsIGBkc3RfbGFiZWxgIGNvbnRhaW5pbmcgdGhlIGpvaW5lZCB2YWx1ZS4gVGhlcmUgY2FuIGJlIGFueSBudW1iZXIgb2YgYHNyY19sYWJlbHNgIGluIHRoaXMgZnVuY3Rpb24uJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdsYWJlbF9yZXBsYWNlJyxcbiAgICBsYWJlbDogJ2xhYmVsX3JlcGxhY2UnLFxuICAgIGRldGFpbDogJ2xhYmVsX3JlcGxhY2UodiBpbnN0YW50LXZlY3RvciwgZHN0X2xhYmVsIHN0cmluZywgcmVwbGFjZW1lbnQgc3RyaW5nLCBzcmNfbGFiZWwgc3RyaW5nLCByZWdleCBzdHJpbmcpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgXCJGb3IgZWFjaCB0aW1lc2VyaWVzIGluIGB2YCwgYGxhYmVsX3JlcGxhY2UodiBpbnN0YW50LXZlY3RvciwgZHN0X2xhYmVsIHN0cmluZywgcmVwbGFjZW1lbnQgc3RyaW5nLCBzcmNfbGFiZWwgc3RyaW5nLCByZWdleCBzdHJpbmcpYCAgbWF0Y2hlcyB0aGUgcmVndWxhciBleHByZXNzaW9uIGByZWdleGAgYWdhaW5zdCB0aGUgbGFiZWwgYHNyY19sYWJlbGAuICBJZiBpdCBtYXRjaGVzLCB0aGVuIHRoZSB0aW1lc2VyaWVzIGlzIHJldHVybmVkIHdpdGggdGhlIGxhYmVsIGBkc3RfbGFiZWxgIHJlcGxhY2VkIGJ5IHRoZSBleHBhbnNpb24gb2YgYHJlcGxhY2VtZW50YC4gYCQxYCBpcyByZXBsYWNlZCB3aXRoIHRoZSBmaXJzdCBtYXRjaGluZyBzdWJncm91cCwgYCQyYCB3aXRoIHRoZSBzZWNvbmQgZXRjLiBJZiB0aGUgcmVndWxhciBleHByZXNzaW9uIGRvZXNuJ3QgbWF0Y2ggdGhlbiB0aGUgdGltZXNlcmllcyBpcyByZXR1cm5lZCB1bmNoYW5nZWQuXCIsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnbG4nLFxuICAgIGxhYmVsOiAnbG4nLFxuICAgIGRldGFpbDogJ2xuKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ0NhbGN1bGF0ZXMgdGhlIG5hdHVyYWwgbG9nYXJpdGhtIGZvciBhbGwgZWxlbWVudHMgaW4gYHZgLlxcblNwZWNpYWwgY2FzZXMgYXJlOlxcbiAqIGBsbigrSW5mKSA9ICtJbmZgXFxuICogYGxuKDApID0gLUluZmBcXG4gKiBgbG4oeCA8IDApID0gTmFOYFxcbiAqIGBsbihOYU4pID0gTmFOYCcsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnbG9nMicsXG4gICAgbGFiZWw6ICdsb2cyJyxcbiAgICBkZXRhaWw6ICdsb2cyKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ0NhbGN1bGF0ZXMgdGhlIGJpbmFyeSBsb2dhcml0aG0gZm9yIGFsbCBlbGVtZW50cyBpbiBgdmAuIFRoZSBzcGVjaWFsIGNhc2VzIGFyZSBlcXVpdmFsZW50IHRvIHRob3NlIGluIGBsbmAuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdsb2cxMCcsXG4gICAgbGFiZWw6ICdsb2cxMCcsXG4gICAgZGV0YWlsOiAnbG9nMTAodiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnQ2FsY3VsYXRlcyB0aGUgZGVjaW1hbCBsb2dhcml0aG0gZm9yIGFsbCBlbGVtZW50cyBpbiBgdmAuIFRoZSBzcGVjaWFsIGNhc2VzIGFyZSBlcXVpdmFsZW50IHRvIHRob3NlIGluIGBsbmAuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdtaW51dGUnLFxuICAgIGxhYmVsOiAnbWludXRlJyxcbiAgICBkZXRhaWw6ICdtaW51dGUodj12ZWN0b3IodGltZSgpKSBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnUmV0dXJucyB0aGUgbWludXRlIG9mIHRoZSBob3VyIGZvciBlYWNoIG9mIHRoZSBnaXZlbiB0aW1lcyBpbiBVVEMuIFJldHVybmVkIHZhbHVlcyBhcmUgZnJvbSAwIHRvIDU5LicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnbW9udGgnLFxuICAgIGxhYmVsOiAnbW9udGgnLFxuICAgIGRldGFpbDogJ21vbnRoKHY9dmVjdG9yKHRpbWUoKSkgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ1JldHVybnMgdGhlIG1vbnRoIG9mIHRoZSB5ZWFyIGZvciBlYWNoIG9mIHRoZSBnaXZlbiB0aW1lcyBpbiBVVEMuIFJldHVybmVkIHZhbHVlcyBhcmUgZnJvbSAxIHRvIDEyLCB3aGVyZSAxIG1lYW5zIEphbnVhcnkgZXRjLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAncGknLFxuICAgIGxhYmVsOiAncGknLFxuICAgIGRldGFpbDogJ3BpKCknLFxuICAgIGRvY3VtZW50YXRpb246ICdSZXR1cm5zIHBpJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdwcmVkaWN0X2xpbmVhcicsXG4gICAgbGFiZWw6ICdwcmVkaWN0X2xpbmVhcicsXG4gICAgZGV0YWlsOiAncHJlZGljdF9saW5lYXIodiByYW5nZS12ZWN0b3IsIHQgc2NhbGFyKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdQcmVkaWN0cyB0aGUgdmFsdWUgb2YgdGltZSBzZXJpZXMgYHRgIHNlY29uZHMgZnJvbSBub3csIGJhc2VkIG9uIHRoZSByYW5nZSB2ZWN0b3IgYHZgLCB1c2luZyBzaW1wbGUgbGluZWFyIHJlZ3Jlc3Npb24uJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdyYWQnLFxuICAgIGxhYmVsOiAncmFkJyxcbiAgICBkZXRhaWw6ICdyYWQodiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdDb252ZXJ0cyBkZWdyZWVzIHRvIHJhZGlhbnMgZm9yIGFsbCBlbGVtZW50cyBpbiB2JyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdyYXRlJyxcbiAgICBsYWJlbDogJ3JhdGUnLFxuICAgIGRldGFpbDogJ3JhdGUodiByYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgXCJDYWxjdWxhdGVzIHRoZSBwZXItc2Vjb25kIGF2ZXJhZ2UgcmF0ZSBvZiBpbmNyZWFzZSBvZiB0aGUgdGltZSBzZXJpZXMgaW4gdGhlIHJhbmdlIHZlY3Rvci4gQnJlYWtzIGluIG1vbm90b25pY2l0eSAoc3VjaCBhcyBjb3VudGVyIHJlc2V0cyBkdWUgdG8gdGFyZ2V0IHJlc3RhcnRzKSBhcmUgYXV0b21hdGljYWxseSBhZGp1c3RlZCBmb3IuIEFsc28sIHRoZSBjYWxjdWxhdGlvbiBleHRyYXBvbGF0ZXMgdG8gdGhlIGVuZHMgb2YgdGhlIHRpbWUgcmFuZ2UsIGFsbG93aW5nIGZvciBtaXNzZWQgc2NyYXBlcyBvciBpbXBlcmZlY3QgYWxpZ25tZW50IG9mIHNjcmFwZSBjeWNsZXMgd2l0aCB0aGUgcmFuZ2UncyB0aW1lIHBlcmlvZC5cIixcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdyZXNldHMnLFxuICAgIGxhYmVsOiAncmVzZXRzJyxcbiAgICBkZXRhaWw6ICdyZXNldHModiByYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ0ZvciBlYWNoIGlucHV0IHRpbWUgc2VyaWVzLCBgcmVzZXRzKHYgcmFuZ2UtdmVjdG9yKWAgcmV0dXJucyB0aGUgbnVtYmVyIG9mIGNvdW50ZXIgcmVzZXRzIHdpdGhpbiB0aGUgcHJvdmlkZWQgdGltZSByYW5nZSBhcyBhbiBpbnN0YW50IHZlY3Rvci4gQW55IGRlY3JlYXNlIGluIHRoZSB2YWx1ZSBiZXR3ZWVuIHR3byBjb25zZWN1dGl2ZSBzYW1wbGVzIGlzIGludGVycHJldGVkIGFzIGEgY291bnRlciByZXNldC4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3JvdW5kJyxcbiAgICBsYWJlbDogJ3JvdW5kJyxcbiAgICBkZXRhaWw6ICdyb3VuZCh2IGluc3RhbnQtdmVjdG9yLCB0b19uZWFyZXN0PTEgc2NhbGFyKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdSb3VuZHMgdGhlIHNhbXBsZSB2YWx1ZXMgb2YgYWxsIGVsZW1lbnRzIGluIGB2YCB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyLiBUaWVzIGFyZSByZXNvbHZlZCBieSByb3VuZGluZyB1cC4gVGhlIG9wdGlvbmFsIGB0b19uZWFyZXN0YCBhcmd1bWVudCBhbGxvd3Mgc3BlY2lmeWluZyB0aGUgbmVhcmVzdCBtdWx0aXBsZSB0byB3aGljaCB0aGUgc2FtcGxlIHZhbHVlcyBzaG91bGQgYmUgcm91bmRlZC4gVGhpcyBtdWx0aXBsZSBtYXkgYWxzbyBiZSBhIGZyYWN0aW9uLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnc2NhbGFyJyxcbiAgICBsYWJlbDogJ3NjYWxhcicsXG4gICAgZGV0YWlsOiAnc2NhbGFyKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ0dpdmVuIGEgc2luZ2xlLWVsZW1lbnQgaW5wdXQgdmVjdG9yLCBgc2NhbGFyKHYgaW5zdGFudC12ZWN0b3IpYCByZXR1cm5zIHRoZSBzYW1wbGUgdmFsdWUgb2YgdGhhdCBzaW5nbGUgZWxlbWVudCBhcyBhIHNjYWxhci4gSWYgdGhlIGlucHV0IHZlY3RvciBkb2VzIG5vdCBoYXZlIGV4YWN0bHkgb25lIGVsZW1lbnQsIGBzY2FsYXJgIHdpbGwgcmV0dXJuIGBOYU5gLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnc2duJyxcbiAgICBsYWJlbDogJ3NnbicsXG4gICAgZGV0YWlsOiAnc2duKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ1JldHVybnMgYSB2ZWN0b3Igd2l0aCBhbGwgc2FtcGxlIHZhbHVlcyBjb252ZXJ0ZWQgdG8gdGhlaXIgc2lnbiwgZGVmaW5lZCBhcyB0aGlzOiAxIGlmIHYgaXMgcG9zaXRpdmUsIC0xIGlmIHYgaXMgbmVnYXRpdmUgYW5kIDAgaWYgdiBpcyBlcXVhbCB0byB6ZXJvLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnc29ydCcsXG4gICAgbGFiZWw6ICdzb3J0JyxcbiAgICBkZXRhaWw6ICdzb3J0KHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnUmV0dXJucyB2ZWN0b3IgZWxlbWVudHMgc29ydGVkIGJ5IHRoZWlyIHNhbXBsZSB2YWx1ZXMsIGluIGFzY2VuZGluZyBvcmRlci4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3NvcnRfZGVzYycsXG4gICAgbGFiZWw6ICdzb3J0X2Rlc2MnLFxuICAgIGRldGFpbDogJ3NvcnRfZGVzYyh2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1JldHVybnMgdmVjdG9yIGVsZW1lbnRzIHNvcnRlZCBieSB0aGVpciBzYW1wbGUgdmFsdWVzLCBpbiBkZXNjZW5kaW5nIG9yZGVyLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnc3FydCcsXG4gICAgbGFiZWw6ICdzcXJ0JyxcbiAgICBkZXRhaWw6ICdzcXJ0KHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnQ2FsY3VsYXRlcyB0aGUgc3F1YXJlIHJvb3Qgb2YgYWxsIGVsZW1lbnRzIGluIGB2YC4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3RpbWUnLFxuICAgIGxhYmVsOiAndGltZScsXG4gICAgZGV0YWlsOiAndGltZSgpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ1JldHVybnMgdGhlIG51bWJlciBvZiBzZWNvbmRzIHNpbmNlIEphbnVhcnkgMSwgMTk3MCBVVEMuIE5vdGUgdGhhdCB0aGlzIGRvZXMgbm90IGFjdHVhbGx5IHJldHVybiB0aGUgY3VycmVudCB0aW1lLCBidXQgdGhlIHRpbWUgYXQgd2hpY2ggdGhlIGV4cHJlc3Npb24gaXMgdG8gYmUgZXZhbHVhdGVkLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAndGltZXN0YW1wJyxcbiAgICBsYWJlbDogJ3RpbWVzdGFtcCcsXG4gICAgZGV0YWlsOiAndGltZXN0YW1wKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ1JldHVybnMgdGhlIHRpbWVzdGFtcCBvZiBlYWNoIG9mIHRoZSBzYW1wbGVzIG9mIHRoZSBnaXZlbiB2ZWN0b3IgYXMgdGhlIG51bWJlciBvZiBzZWNvbmRzIHNpbmNlIEphbnVhcnkgMSwgMTk3MCBVVEMuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICd2ZWN0b3InLFxuICAgIGxhYmVsOiAndmVjdG9yJyxcbiAgICBkZXRhaWw6ICd2ZWN0b3IocyBzY2FsYXIpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnUmV0dXJucyB0aGUgc2NhbGFyIGBzYCBhcyBhIHZlY3RvciB3aXRoIG5vIGxhYmVscy4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3llYXInLFxuICAgIGxhYmVsOiAneWVhcicsXG4gICAgZGV0YWlsOiAneWVhcih2PXZlY3Rvcih0aW1lKCkpIGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1JldHVybnMgdGhlIHllYXIgZm9yIGVhY2ggb2YgdGhlIGdpdmVuIHRpbWVzIGluIFVUQy4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2F2Z19vdmVyX3RpbWUnLFxuICAgIGxhYmVsOiAnYXZnX292ZXJfdGltZScsXG4gICAgZGV0YWlsOiAnYXZnX292ZXJfdGltZShyYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnVGhlIGF2ZXJhZ2UgdmFsdWUgb2YgYWxsIHBvaW50cyBpbiB0aGUgc3BlY2lmaWVkIGludGVydmFsLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnbWluX292ZXJfdGltZScsXG4gICAgbGFiZWw6ICdtaW5fb3Zlcl90aW1lJyxcbiAgICBkZXRhaWw6ICdtaW5fb3Zlcl90aW1lKHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdUaGUgbWluaW11bSB2YWx1ZSBvZiBhbGwgcG9pbnRzIGluIHRoZSBzcGVjaWZpZWQgaW50ZXJ2YWwuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdtYXhfb3Zlcl90aW1lJyxcbiAgICBsYWJlbDogJ21heF9vdmVyX3RpbWUnLFxuICAgIGRldGFpbDogJ21heF9vdmVyX3RpbWUocmFuZ2UtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1RoZSBtYXhpbXVtIHZhbHVlIG9mIGFsbCBwb2ludHMgaW4gdGhlIHNwZWNpZmllZCBpbnRlcnZhbC4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3N1bV9vdmVyX3RpbWUnLFxuICAgIGxhYmVsOiAnc3VtX292ZXJfdGltZScsXG4gICAgZGV0YWlsOiAnc3VtX292ZXJfdGltZShyYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnVGhlIHN1bSBvZiBhbGwgdmFsdWVzIGluIHRoZSBzcGVjaWZpZWQgaW50ZXJ2YWwuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdjb3VudF9vdmVyX3RpbWUnLFxuICAgIGxhYmVsOiAnY291bnRfb3Zlcl90aW1lJyxcbiAgICBkZXRhaWw6ICdjb3VudF9vdmVyX3RpbWUocmFuZ2UtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1RoZSBjb3VudCBvZiBhbGwgdmFsdWVzIGluIHRoZSBzcGVjaWZpZWQgaW50ZXJ2YWwuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdxdWFudGlsZV9vdmVyX3RpbWUnLFxuICAgIGxhYmVsOiAncXVhbnRpbGVfb3Zlcl90aW1lJyxcbiAgICBkZXRhaWw6ICdxdWFudGlsZV9vdmVyX3RpbWUoc2NhbGFyLCByYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnVGhlIM+GLXF1YW50aWxlICgwIOKJpCDPhiDiiaQgMSkgb2YgdGhlIHZhbHVlcyBpbiB0aGUgc3BlY2lmaWVkIGludGVydmFsLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnc3RkZGV2X292ZXJfdGltZScsXG4gICAgbGFiZWw6ICdzdGRkZXZfb3Zlcl90aW1lJyxcbiAgICBkZXRhaWw6ICdzdGRkZXZfb3Zlcl90aW1lKHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdUaGUgcG9wdWxhdGlvbiBzdGFuZGFyZCBkZXZpYXRpb24gb2YgdGhlIHZhbHVlcyBpbiB0aGUgc3BlY2lmaWVkIGludGVydmFsLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnc3RkdmFyX292ZXJfdGltZScsXG4gICAgbGFiZWw6ICdzdGR2YXJfb3Zlcl90aW1lJyxcbiAgICBkZXRhaWw6ICdzdGR2YXJfb3Zlcl90aW1lKHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdUaGUgcG9wdWxhdGlvbiBzdGFuZGFyZCB2YXJpYW5jZSBvZiB0aGUgdmFsdWVzIGluIHRoZSBzcGVjaWZpZWQgaW50ZXJ2YWwuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdsYXN0X292ZXJfdGltZScsXG4gICAgbGFiZWw6ICdsYXN0X292ZXJfdGltZScsXG4gICAgZGV0YWlsOiAnbGFzdF9vdmVyX3RpbWUocmFuZ2UtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1RoZSBtb3N0IHJlY2VudCBwb2ludCB2YWx1ZSBpbiBzcGVjaWZpZWQgaW50ZXJ2YWwuJyxcbiAgfSxcbl07XG5cbmV4cG9ydCBjb25zdCBQUk9NX0tFWVdPUkRTID0gRlVOQ1RJT05TLm1hcCgoa2V5d29yZCkgPT4ga2V5d29yZC5sYWJlbCk7XG5cbmV4cG9ydCBjb25zdCBwcm9tcWxHcmFtbWFyOiBHcmFtbWFyID0ge1xuICBjb21tZW50OiB7XG4gICAgcGF0dGVybjogLyMuKi8sXG4gIH0sXG4gICdjb250ZXh0LWFnZ3JlZ2F0aW9uJzoge1xuICAgIHBhdHRlcm46IC8oKGJ5fHdpdGhvdXQpXFxzKilcXChbXildKlxcKS8sIC8vIGJ5ICgpXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBpbnNpZGU6IHtcbiAgICAgICdsYWJlbC1rZXknOiB7XG4gICAgICAgIHBhdHRlcm46IC9bXigpLFxcc11bXiwpXSpbXiksXFxzXSovLFxuICAgICAgICBhbGlhczogJ2F0dHItbmFtZScsXG4gICAgICB9LFxuICAgICAgcHVuY3R1YXRpb246IC9bKCldLyxcbiAgICB9LFxuICB9LFxuICAnY29udGV4dC1sYWJlbHMnOiB7XG4gICAgcGF0dGVybjogL1xce1tefV0qKD89fT8pLyxcbiAgICBncmVlZHk6IHRydWUsXG4gICAgaW5zaWRlOiB7XG4gICAgICBjb21tZW50OiB7XG4gICAgICAgIHBhdHRlcm46IC8jLiovLFxuICAgICAgfSxcbiAgICAgICdsYWJlbC1rZXknOiB7XG4gICAgICAgIHBhdHRlcm46IC9bYS16X11cXHcqKD89XFxzKig9fCE9fD1+fCF+KSkvLFxuICAgICAgICBhbGlhczogJ2F0dHItbmFtZScsXG4gICAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIH0sXG4gICAgICAnbGFiZWwtdmFsdWUnOiB7XG4gICAgICAgIHBhdHRlcm46IC9cIig/OlxcXFwufFteXFxcXFwiXSkqXCIvLFxuICAgICAgICBncmVlZHk6IHRydWUsXG4gICAgICAgIGFsaWFzOiAnYXR0ci12YWx1ZScsXG4gICAgICB9LFxuICAgICAgcHVuY3R1YXRpb246IC9be10vLFxuICAgIH0sXG4gIH0sXG4gIGZ1bmN0aW9uOiBuZXcgUmVnRXhwKGBcXFxcYig/OiR7RlVOQ1RJT05TLm1hcCgoZikgPT4gZi5sYWJlbCkuam9pbignfCcpfSkoPz1cXFxccypcXFxcKClgLCAnaScpLFxuICAnY29udGV4dC1yYW5nZSc6IFtcbiAgICB7XG4gICAgICBwYXR0ZXJuOiAvXFxbW15cXF1dKig/PV0pLywgLy8gWzFtXVxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdyYW5nZS1kdXJhdGlvbic6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvXFxiXFxkK1tzbWhkd3ldXFxiL2ksXG4gICAgICAgICAgYWxpYXM6ICdudW1iZXInLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9LFxuICAgIHtcbiAgICAgIHBhdHRlcm46IC8ob2Zmc2V0XFxzKylcXHcrLywgLy8gb2Zmc2V0IDFtXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdyYW5nZS1kdXJhdGlvbic6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvXFxiXFxkK1tzbWhkd3ldXFxiL2ksXG4gICAgICAgICAgYWxpYXM6ICdudW1iZXInLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9LFxuICBdLFxuICBpZExpc3Q6IHtcbiAgICBwYXR0ZXJuOiAvXFxkKyhcXHxcXGQrKSsvLFxuICAgIGFsaWFzOiAnbnVtYmVyJyxcbiAgfSxcbiAgbnVtYmVyOiAvXFxiLT9cXGQrKChcXC5cXGQqKT8oW2VFXVsrLV0/XFxkKyk/KT9cXGIvLFxuICBvcGVyYXRvcjogbmV3IFJlZ0V4cChgL1stKyovPSVefl18JiY/fFxcXFx8P1xcXFx8fCE9P3w8KD86PT4/fDx8Pik/fD5bPj1dP3xcXFxcYig/OiR7T1BFUkFUT1JTLmpvaW4oJ3wnKX0pXFxcXGJgLCAnaScpLFxuICBwdW5jdHVhdGlvbjogL1t7fTsoKWAsLl0vLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgcHJvbXFsR3JhbW1hcjtcbiIsImltcG9ydCB7IHNpemUgfSBmcm9tICdsb2Rhc2gnO1xuXG5pbXBvcnQgeyBRdWVyeUhpbnQsIFF1ZXJ5Rml4IH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5cbmltcG9ydCB7IFByb21ldGhldXNEYXRhc291cmNlIH0gZnJvbSAnLi9kYXRhc291cmNlJztcblxuLyoqXG4gKiBOdW1iZXIgb2YgdGltZSBzZXJpZXMgcmVzdWx0cyBuZWVkZWQgYmVmb3JlIHN0YXJ0aW5nIHRvIHN1Z2dlc3Qgc3VtIGFnZ3JlZ2F0aW9uIGhpbnRzXG4gKi9cbmV4cG9ydCBjb25zdCBTVU1fSElOVF9USFJFU0hPTERfQ09VTlQgPSAyMDtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFF1ZXJ5SGludHMocXVlcnk6IHN0cmluZywgc2VyaWVzPzogYW55W10sIGRhdGFzb3VyY2U/OiBQcm9tZXRoZXVzRGF0YXNvdXJjZSk6IFF1ZXJ5SGludFtdIHtcbiAgY29uc3QgaGludHMgPSBbXTtcblxuICAvLyAuLi5fYnVja2V0IG1ldHJpYyBuZWVkcyBhIGhpc3RvZ3JhbV9xdWFudGlsZSgpXG4gIGNvbnN0IGhpc3RvZ3JhbU1ldHJpYyA9IHF1ZXJ5LnRyaW0oKS5tYXRjaCgvXlxcdytfYnVja2V0JHxeXFx3K19idWNrZXR7Lip9JC8pO1xuICBpZiAoaGlzdG9ncmFtTWV0cmljKSB7XG4gICAgY29uc3QgbGFiZWwgPSAnU2VsZWN0ZWQgbWV0cmljIGhhcyBidWNrZXRzLic7XG4gICAgaGludHMucHVzaCh7XG4gICAgICB0eXBlOiAnSElTVE9HUkFNX1FVQU5USUxFJyxcbiAgICAgIGxhYmVsLFxuICAgICAgZml4OiB7XG4gICAgICAgIGxhYmVsOiAnQ29uc2lkZXIgY2FsY3VsYXRpbmcgYWdncmVnYXRlZCBxdWFudGlsZSBieSBhZGRpbmcgaGlzdG9ncmFtX3F1YW50aWxlKCkuJyxcbiAgICAgICAgYWN0aW9uOiB7XG4gICAgICAgICAgdHlwZTogJ0FERF9ISVNUT0dSQU1fUVVBTlRJTEUnLFxuICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICB9LFxuICAgICAgfSBhcyBRdWVyeUZpeCxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIENoZWNrIGZvciBuZWVkIG9mIHJhdGUoKVxuICBpZiAocXVlcnkuaW5kZXhPZigncmF0ZSgnKSA9PT0gLTEgJiYgcXVlcnkuaW5kZXhPZignaW5jcmVhc2UoJykgPT09IC0xKSB7XG4gICAgLy8gVXNlIG1ldHJpYyBtZXRhZGF0YSBmb3IgZXhhY3QgdHlwZXNcbiAgICBjb25zdCBuYW1lTWF0Y2ggPSBxdWVyeS5tYXRjaCgvXFxiKFxcdytfKHRvdGFsfHN1bXxjb3VudCkpXFxiLyk7XG4gICAgbGV0IGNvdW50ZXJOYW1lTWV0cmljID0gbmFtZU1hdGNoID8gbmFtZU1hdGNoWzFdIDogJyc7XG4gICAgY29uc3QgbWV0cmljc01ldGFkYXRhID0gZGF0YXNvdXJjZT8ubGFuZ3VhZ2VQcm92aWRlcj8ubWV0cmljc01ldGFkYXRhID8/IHt9O1xuICAgIGNvbnN0IG1ldHJpY01ldGFkYXRhS2V5cyA9IE9iamVjdC5rZXlzKG1ldHJpY3NNZXRhZGF0YSk7XG4gICAgbGV0IGNlcnRhaW4gPSBmYWxzZTtcblxuICAgIGlmIChtZXRyaWNNZXRhZGF0YUtleXMubGVuZ3RoID4gMCkge1xuICAgICAgY291bnRlck5hbWVNZXRyaWMgPVxuICAgICAgICBtZXRyaWNNZXRhZGF0YUtleXMuZmluZCgobWV0cmljTmFtZSkgPT4ge1xuICAgICAgICAgIC8vIE9ubHkgY29uc2lkZXJpbmcgZmlyc3QgdHlwZSBpbmZvcm1hdGlvbiwgY291bGQgYmUgbm9uLWRldGVybWluaXN0aWNcbiAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IG1ldHJpY3NNZXRhZGF0YVttZXRyaWNOYW1lXTtcbiAgICAgICAgICBpZiAobWV0YWRhdGEudHlwZS50b0xvd2VyQ2FzZSgpID09PSAnY291bnRlcicpIHtcbiAgICAgICAgICAgIGNvbnN0IG1ldHJpY1JlZ2V4ID0gbmV3IFJlZ0V4cChgXFxcXGIke21ldHJpY05hbWV9XFxcXGJgKTtcbiAgICAgICAgICAgIGlmIChxdWVyeS5tYXRjaChtZXRyaWNSZWdleCkpIHtcbiAgICAgICAgICAgICAgY2VydGFpbiA9IHRydWU7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pID8/ICcnO1xuICAgIH1cblxuICAgIGlmIChjb3VudGVyTmFtZU1ldHJpYykge1xuICAgICAgLy8gRml4YWJsZVF1ZXJ5IGNvbnNpc3RzIG9mIG1ldHJpYyBuYW1lIGFuZCBvcHRpb25hbGx5IGxhYmVsLXZhbHVlIHBhaXJzLiBXZSBhcmUgbm90IG9mZmVyaW5nIGZpeCBmb3IgY29tcGxleCBxdWVyaWVzIHlldC5cbiAgICAgIGNvbnN0IGZpeGFibGVRdWVyeSA9IHF1ZXJ5LnRyaW0oKS5tYXRjaCgvXlxcdyskfF5cXHcrey4qfSQvKTtcbiAgICAgIGNvbnN0IHZlcmIgPSBjZXJ0YWluID8gJ2lzJyA6ICdsb29rcyBsaWtlJztcbiAgICAgIGxldCBsYWJlbCA9IGBTZWxlY3RlZCBtZXRyaWMgJHt2ZXJifSBhIGNvdW50ZXIuYDtcbiAgICAgIGxldCBmaXg6IFF1ZXJ5Rml4IHwgdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoZml4YWJsZVF1ZXJ5KSB7XG4gICAgICAgIGZpeCA9IHtcbiAgICAgICAgICBsYWJlbDogJ0NvbnNpZGVyIGNhbGN1bGF0aW5nIHJhdGUgb2YgY291bnRlciBieSBhZGRpbmcgcmF0ZSgpLicsXG4gICAgICAgICAgYWN0aW9uOiB7XG4gICAgICAgICAgICB0eXBlOiAnQUREX1JBVEUnLFxuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhYmVsID0gYCR7bGFiZWx9IENvbnNpZGVyIGNhbGN1bGF0aW5nIHJhdGUgb2YgY291bnRlciBieSBhZGRpbmcgcmF0ZSgpLmA7XG4gICAgICB9XG5cbiAgICAgIGhpbnRzLnB1c2goe1xuICAgICAgICB0eXBlOiAnQVBQTFlfUkFURScsXG4gICAgICAgIGxhYmVsLFxuICAgICAgICBmaXgsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvLyBDaGVjayBmb3IgcmVjb3JkaW5nIHJ1bGVzIGV4cGFuc2lvblxuICBpZiAoZGF0YXNvdXJjZSAmJiBkYXRhc291cmNlLnJ1bGVNYXBwaW5ncykge1xuICAgIGNvbnN0IG1hcHBpbmcgPSBkYXRhc291cmNlLnJ1bGVNYXBwaW5ncztcbiAgICBjb25zdCBtYXBwaW5nRm9yUXVlcnkgPSBPYmplY3Qua2V5cyhtYXBwaW5nKS5yZWR1Y2UoKGFjYywgcnVsZU5hbWUpID0+IHtcbiAgICAgIGlmIChxdWVyeS5zZWFyY2gocnVsZU5hbWUpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5hY2MsXG4gICAgICAgICAgW3J1bGVOYW1lXTogbWFwcGluZ1tydWxlTmFtZV0sXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgICBpZiAoc2l6ZShtYXBwaW5nRm9yUXVlcnkpID4gMCkge1xuICAgICAgY29uc3QgbGFiZWwgPSAnUXVlcnkgY29udGFpbnMgcmVjb3JkaW5nIHJ1bGVzLic7XG4gICAgICBoaW50cy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ0VYUEFORF9SVUxFUycsXG4gICAgICAgIGxhYmVsLFxuICAgICAgICBmaXg6IHtcbiAgICAgICAgICBsYWJlbDogJ0V4cGFuZCBydWxlcycsXG4gICAgICAgICAgYWN0aW9uOiB7XG4gICAgICAgICAgICB0eXBlOiAnRVhQQU5EX1JVTEVTJyxcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgbWFwcGluZzogbWFwcGluZ0ZvclF1ZXJ5LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0gYXMgYW55IGFzIFF1ZXJ5Rml4LFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHNlcmllcyAmJiBzZXJpZXMubGVuZ3RoID49IFNVTV9ISU5UX1RIUkVTSE9MRF9DT1VOVCkge1xuICAgIGNvbnN0IHNpbXBsZU1ldHJpYyA9IHF1ZXJ5LnRyaW0oKS5tYXRjaCgvXlxcdyskLyk7XG4gICAgaWYgKHNpbXBsZU1ldHJpYykge1xuICAgICAgaGludHMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdBRERfU1VNJyxcbiAgICAgICAgbGFiZWw6ICdNYW55IHRpbWUgc2VyaWVzIHJlc3VsdHMgcmV0dXJuZWQuJyxcbiAgICAgICAgZml4OiB7XG4gICAgICAgICAgbGFiZWw6ICdDb25zaWRlciBhZ2dyZWdhdGluZyB3aXRoIHN1bSgpLicsXG4gICAgICAgICAgYWN0aW9uOiB7XG4gICAgICAgICAgICB0eXBlOiAnQUREX1NVTScsXG4gICAgICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgICAgICBwcmV2ZW50U3VibWl0OiB0cnVlLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0gYXMgUXVlcnlGaXgsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaGludHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbml0SGludHMoZGF0YXNvdXJjZTogUHJvbWV0aGV1c0RhdGFzb3VyY2UpOiBRdWVyeUhpbnRbXSB7XG4gIGNvbnN0IGhpbnRzID0gW107XG4gIC8vIEhpbnQgaWYgdXNpbmcgTG9raSBhcyBQcm9tZXRoZXVzIGRhdGEgc291cmNlXG4gIGlmIChkYXRhc291cmNlLmRpcmVjdFVybC5pbmNsdWRlcygnL2xva2knKSAmJiAhZGF0YXNvdXJjZS5sYW5ndWFnZVByb3ZpZGVyLm1ldHJpY3MubGVuZ3RoKSB7XG4gICAgaGludHMucHVzaCh7XG4gICAgICBsYWJlbDogYFVzaW5nIExva2kgYXMgYSBQcm9tZXRoZXVzIGRhdGEgc291cmNlIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuIFlvdSBtdXN0IHVzZSB0aGUgTG9raSBkYXRhIHNvdXJjZSBmb3IgeW91ciBMb2tpIGluc3RhbmNlLmAsXG4gICAgICB0eXBlOiAnSU5GTycsXG4gICAgfSk7XG4gIH1cblxuICAvLyBIaW50IGZvciBiaWcgZGlzYWJsZWQgbG9va3Vwc1xuICBpZiAoZGF0YXNvdXJjZS5sb29rdXBzRGlzYWJsZWQpIHtcbiAgICBoaW50cy5wdXNoKHtcbiAgICAgIGxhYmVsOiBgTGFiZWxzIGFuZCBtZXRyaWNzIGxvb2t1cCB3YXMgZGlzYWJsZWQgaW4gZGF0YSBzb3VyY2Ugc2V0dGluZ3MuYCxcbiAgICAgIHR5cGU6ICdJTkZPJyxcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBoaW50cztcbn1cbiIsImltcG9ydCB7IEZVTkNUSU9OUyB9IGZyb20gJy4uL3Byb21xbCc7XG5cbmltcG9ydCB7IGdldEFnZ3JlZ2F0aW9uT3BlcmF0aW9ucyB9IGZyb20gJy4vYWdncmVnYXRpb25zJztcbmltcG9ydCB7IGdldE9wZXJhdGlvbkRlZmluaXRpb25zIH0gZnJvbSAnLi9vcGVyYXRpb25zJztcbmltcG9ydCB7IExva2lBbmRQcm9tUXVlcnlNb2RlbGxlckJhc2UgfSBmcm9tICcuL3NoYXJlZC9Mb2tpQW5kUHJvbVF1ZXJ5TW9kZWxsZXJCYXNlJztcbmltcG9ydCB7IFByb21RdWVyeVBhdHRlcm4sIFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5IH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBQcm9tUXVlcnlNb2RlbGxlciBleHRlbmRzIExva2lBbmRQcm9tUXVlcnlNb2RlbGxlckJhc2Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigoKSA9PiB7XG4gICAgICBjb25zdCBhbGxPcGVyYXRpb25zID0gWy4uLmdldE9wZXJhdGlvbkRlZmluaXRpb25zKCksIC4uLmdldEFnZ3JlZ2F0aW9uT3BlcmF0aW9ucygpXTtcbiAgICAgIGZvciAoY29uc3Qgb3Agb2YgYWxsT3BlcmF0aW9ucykge1xuICAgICAgICBjb25zdCBmdW5jID0gRlVOQ1RJT05TLmZpbmQoKHgpID0+IHguaW5zZXJ0VGV4dCA9PT0gb3AuaWQpO1xuICAgICAgICBpZiAoZnVuYykge1xuICAgICAgICAgIG9wLmRvY3VtZW50YXRpb24gPSBmdW5jLmRvY3VtZW50YXRpb247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhbGxPcGVyYXRpb25zO1xuICAgIH0pO1xuXG4gICAgdGhpcy5zZXRPcGVyYXRpb25DYXRlZ29yaWVzKFtcbiAgICAgIFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkFnZ3JlZ2F0aW9ucyxcbiAgICAgIFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlJhbmdlRnVuY3Rpb25zLFxuICAgICAgUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuRnVuY3Rpb25zLFxuICAgICAgUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuQmluYXJ5T3BzLFxuICAgICAgUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuVHJpZ29ub21ldHJpYyxcbiAgICAgIFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlRpbWUsXG4gICAgXSk7XG4gIH1cblxuICBnZXRRdWVyeVBhdHRlcm5zKCk6IFByb21RdWVyeVBhdHRlcm5bXSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ1JhdGUgdGhlbiBzdW0nLFxuICAgICAgICBvcGVyYXRpb25zOiBbXG4gICAgICAgICAgeyBpZDogJ3JhdGUnLCBwYXJhbXM6IFsnJF9fcmF0ZV9pbnRlcnZhbCddIH0sXG4gICAgICAgICAgeyBpZDogJ3N1bScsIHBhcmFtczogW10gfSxcbiAgICAgICAgXSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdSYXRlIHRoZW4gc3VtIGJ5KGxhYmVsKSB0aGVuIGF2ZycsXG4gICAgICAgIG9wZXJhdGlvbnM6IFtcbiAgICAgICAgICB7IGlkOiAncmF0ZScsIHBhcmFtczogWyckX19yYXRlX2ludGVydmFsJ10gfSxcbiAgICAgICAgICB7IGlkOiAnX19zdW1fYnknLCBwYXJhbXM6IFsnJ10gfSxcbiAgICAgICAgICB7IGlkOiAnYXZnJywgcGFyYW1zOiBbXSB9LFxuICAgICAgICBdLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ0hpc3RvZ3JhbSBxdWFudGlsZSBvbiByYXRlJyxcbiAgICAgICAgb3BlcmF0aW9uczogW1xuICAgICAgICAgIHsgaWQ6ICdyYXRlJywgcGFyYW1zOiBbJyRfX3JhdGVfaW50ZXJ2YWwnXSB9LFxuICAgICAgICAgIHsgaWQ6ICdfX3N1bV9ieScsIHBhcmFtczogWydsZSddIH0sXG4gICAgICAgICAgeyBpZDogJ2hpc3RvZ3JhbV9xdWFudGlsZScsIHBhcmFtczogWzAuOTVdIH0sXG4gICAgICAgIF0sXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAnSGlzdG9ncmFtIHF1YW50aWxlIG9uIGluY3JlYXNlICcsXG4gICAgICAgIG9wZXJhdGlvbnM6IFtcbiAgICAgICAgICB7IGlkOiAnaW5jcmVhc2UnLCBwYXJhbXM6IFsnJF9fcmF0ZV9pbnRlcnZhbCddIH0sXG4gICAgICAgICAgeyBpZDogJ19fbWF4X2J5JywgcGFyYW1zOiBbJ2xlJ10gfSxcbiAgICAgICAgICB7IGlkOiAnaGlzdG9ncmFtX3F1YW50aWxlJywgcGFyYW1zOiBbMC45NV0gfSxcbiAgICAgICAgXSxcbiAgICAgIH0sXG4gICAgXTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgcHJvbVF1ZXJ5TW9kZWxsZXIgPSBuZXcgUHJvbVF1ZXJ5TW9kZWxsZXIoKTtcbiIsImltcG9ydCB7IGFkZE9wZXJhdGlvbldpdGhSYW5nZVZlY3RvciB9IGZyb20gJy4vb3BlcmF0aW9ucyc7XG5pbXBvcnQge1xuICBjcmVhdGVBZ2dyZWdhdGlvbk9wZXJhdGlvbixcbiAgY3JlYXRlQWdncmVnYXRpb25PcGVyYXRpb25XaXRoUGFyYW0sXG4gIGdldFByb21BbmRMb2tpT3BlcmF0aW9uRGlzcGxheU5hbWUsXG4gIGdldFJhbmdlVmVjdG9yUGFyYW1EZWYsXG59IGZyb20gJy4vc2hhcmVkL29wZXJhdGlvblV0aWxzJztcbmltcG9ydCB7IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiwgUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmIH0gZnJvbSAnLi9zaGFyZWQvdHlwZXMnO1xuaW1wb3J0IHsgUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnksIFByb21PcGVyYXRpb25JZCB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWdncmVnYXRpb25PcGVyYXRpb25zKCk6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZltdIHtcbiAgcmV0dXJuIFtcbiAgICAuLi5jcmVhdGVBZ2dyZWdhdGlvbk9wZXJhdGlvbihQcm9tT3BlcmF0aW9uSWQuU3VtKSxcbiAgICAuLi5jcmVhdGVBZ2dyZWdhdGlvbk9wZXJhdGlvbihQcm9tT3BlcmF0aW9uSWQuQXZnKSxcbiAgICAuLi5jcmVhdGVBZ2dyZWdhdGlvbk9wZXJhdGlvbihQcm9tT3BlcmF0aW9uSWQuTWluKSxcbiAgICAuLi5jcmVhdGVBZ2dyZWdhdGlvbk9wZXJhdGlvbihQcm9tT3BlcmF0aW9uSWQuTWF4KSxcbiAgICAuLi5jcmVhdGVBZ2dyZWdhdGlvbk9wZXJhdGlvbihQcm9tT3BlcmF0aW9uSWQuQ291bnQpLFxuICAgIC4uLmNyZWF0ZUFnZ3JlZ2F0aW9uT3BlcmF0aW9uV2l0aFBhcmFtKFByb21PcGVyYXRpb25JZC5Ub3BLLCB7XG4gICAgICBwYXJhbXM6IFt7IG5hbWU6ICdLLXZhbHVlJywgdHlwZTogJ251bWJlcicgfV0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbNV0sXG4gICAgfSksXG4gICAgLi4uY3JlYXRlQWdncmVnYXRpb25PcGVyYXRpb25XaXRoUGFyYW0oUHJvbU9wZXJhdGlvbklkLkJvdHRvbUssIHtcbiAgICAgIHBhcmFtczogW3sgbmFtZTogJ0stdmFsdWUnLCB0eXBlOiAnbnVtYmVyJyB9XSxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFs1XSxcbiAgICB9KSxcbiAgICAuLi5jcmVhdGVBZ2dyZWdhdGlvbk9wZXJhdGlvbldpdGhQYXJhbShQcm9tT3BlcmF0aW9uSWQuQ291bnRWYWx1ZXMsIHtcbiAgICAgIHBhcmFtczogW3sgbmFtZTogJ0lkZW50aWZpZXInLCB0eXBlOiAnc3RyaW5nJyB9XSxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFsnY291bnQnXSxcbiAgICB9KSxcbiAgICBjcmVhdGVBZ2dyZWdhdGlvbk92ZXJUaW1lKFByb21PcGVyYXRpb25JZC5TdW1PdmVyVGltZSksXG4gICAgY3JlYXRlQWdncmVnYXRpb25PdmVyVGltZShQcm9tT3BlcmF0aW9uSWQuQXZnT3ZlclRpbWUpLFxuICAgIGNyZWF0ZUFnZ3JlZ2F0aW9uT3ZlclRpbWUoUHJvbU9wZXJhdGlvbklkLk1pbk92ZXJUaW1lKSxcbiAgICBjcmVhdGVBZ2dyZWdhdGlvbk92ZXJUaW1lKFByb21PcGVyYXRpb25JZC5NYXhPdmVyVGltZSksXG4gICAgY3JlYXRlQWdncmVnYXRpb25PdmVyVGltZShQcm9tT3BlcmF0aW9uSWQuQ291bnRPdmVyVGltZSksXG4gICAgY3JlYXRlQWdncmVnYXRpb25PdmVyVGltZShQcm9tT3BlcmF0aW9uSWQuTGFzdE92ZXJUaW1lKSxcbiAgICBjcmVhdGVBZ2dyZWdhdGlvbk92ZXJUaW1lKFByb21PcGVyYXRpb25JZC5QcmVzZW50T3ZlclRpbWUpLFxuICAgIGNyZWF0ZUFnZ3JlZ2F0aW9uT3ZlclRpbWUoUHJvbU9wZXJhdGlvbklkLkFic2VudE92ZXJUaW1lKSxcbiAgICBjcmVhdGVBZ2dyZWdhdGlvbk92ZXJUaW1lKFByb21PcGVyYXRpb25JZC5TdGRkZXZPdmVyVGltZSksXG4gIF07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFnZ3JlZ2F0aW9uT3ZlclRpbWUobmFtZTogc3RyaW5nKTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmIHtcbiAgcmV0dXJuIHtcbiAgICBpZDogbmFtZSxcbiAgICBuYW1lOiBnZXRQcm9tQW5kTG9raU9wZXJhdGlvbkRpc3BsYXlOYW1lKG5hbWUpLFxuICAgIHBhcmFtczogW2dldFJhbmdlVmVjdG9yUGFyYW1EZWYoKV0sXG4gICAgZGVmYXVsdFBhcmFtczogWyckX19pbnRlcnZhbCddLFxuICAgIGFsdGVybmF0aXZlc0tleTogJ292ZXJ0aW1lIGZ1bmN0aW9uJyxcbiAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuUmFuZ2VGdW5jdGlvbnMsXG4gICAgcmVuZGVyZXI6IG9wZXJhdGlvbldpdGhSYW5nZVZlY3RvclJlbmRlcmVyLFxuICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGFkZE9wZXJhdGlvbldpdGhSYW5nZVZlY3RvcixcbiAgfTtcbn1cblxuZnVuY3Rpb24gb3BlcmF0aW9uV2l0aFJhbmdlVmVjdG9yUmVuZGVyZXIoXG4gIG1vZGVsOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sXG4gIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLFxuICBpbm5lckV4cHI6IHN0cmluZ1xuKSB7XG4gIGxldCByYW5nZVZlY3RvciA9IChtb2RlbC5wYXJhbXMgPz8gW10pWzBdID8/ICckX19pbnRlcnZhbCc7XG4gIHJldHVybiBgJHtkZWYuaWR9KCR7aW5uZXJFeHByfVske3JhbmdlVmVjdG9yfV0pYDtcbn1cbiIsImltcG9ydCB7IGRlZmF1bHRBZGRPcGVyYXRpb25IYW5kbGVyIH0gZnJvbSAnLi9zaGFyZWQvb3BlcmF0aW9uVXRpbHMnO1xuaW1wb3J0IHsgUXVlcnlCdWlsZGVyT3BlcmF0aW9uLCBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsIFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmIH0gZnJvbSAnLi9zaGFyZWQvdHlwZXMnO1xuaW1wb3J0IHsgUHJvbU9wZXJhdGlvbklkLCBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeSB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgY29uc3QgYmluYXJ5U2NhbGFyRGVmcyA9IFtcbiAge1xuICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuQWRkaXRpb24sXG4gICAgbmFtZTogJ0FkZCBzY2FsYXInLFxuICAgIHNpZ246ICcrJyxcbiAgfSxcbiAge1xuICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuU3VidHJhY3Rpb24sXG4gICAgbmFtZTogJ1N1YnRyYWN0IHNjYWxhcicsXG4gICAgc2lnbjogJy0nLFxuICB9LFxuICB7XG4gICAgaWQ6IFByb21PcGVyYXRpb25JZC5NdWx0aXBseUJ5LFxuICAgIG5hbWU6ICdNdWx0aXBseSBieSBzY2FsYXInLFxuICAgIHNpZ246ICcqJyxcbiAgfSxcbiAge1xuICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuRGl2aWRlQnksXG4gICAgbmFtZTogJ0RpdmlkZSBieSBzY2FsYXInLFxuICAgIHNpZ246ICcvJyxcbiAgfSxcbiAge1xuICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuTW9kdWxvLFxuICAgIG5hbWU6ICdNb2R1bG8gYnkgc2NhbGFyJyxcbiAgICBzaWduOiAnJScsXG4gIH0sXG4gIHtcbiAgICBpZDogUHJvbU9wZXJhdGlvbklkLkV4cG9uZW50LFxuICAgIG5hbWU6ICdFeHBvbmVudCcsXG4gICAgc2lnbjogJ14nLFxuICB9LFxuICB7XG4gICAgaWQ6IFByb21PcGVyYXRpb25JZC5FcXVhbFRvLFxuICAgIG5hbWU6ICdFcXVhbCB0bycsXG4gICAgc2lnbjogJz09JyxcbiAgICBjb21wYXJpc29uOiB0cnVlLFxuICB9LFxuICB7XG4gICAgaWQ6IFByb21PcGVyYXRpb25JZC5Ob3RFcXVhbFRvLFxuICAgIG5hbWU6ICdOb3QgZXF1YWwgdG8nLFxuICAgIHNpZ246ICchPScsXG4gICAgY29tcGFyaXNvbjogdHJ1ZSxcbiAgfSxcbiAge1xuICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuR3JlYXRlclRoYW4sXG4gICAgbmFtZTogJ0dyZWF0ZXIgdGhhbicsXG4gICAgc2lnbjogJz4nLFxuICAgIGNvbXBhcmlzb246IHRydWUsXG4gIH0sXG4gIHtcbiAgICBpZDogUHJvbU9wZXJhdGlvbklkLkxlc3NUaGFuLFxuICAgIG5hbWU6ICdMZXNzIHRoYW4nLFxuICAgIHNpZ246ICc8JyxcbiAgICBjb21wYXJpc29uOiB0cnVlLFxuICB9LFxuICB7XG4gICAgaWQ6IFByb21PcGVyYXRpb25JZC5HcmVhdGVyT3JFcXVhbCxcbiAgICBuYW1lOiAnR3JlYXRlciBvciBlcXVhbCB0bycsXG4gICAgc2lnbjogJz49JyxcbiAgICBjb21wYXJpc29uOiB0cnVlLFxuICB9LFxuICB7XG4gICAgaWQ6IFByb21PcGVyYXRpb25JZC5MZXNzT3JFcXVhbCxcbiAgICBuYW1lOiAnTGVzcyBvciBlcXVhbCB0bycsXG4gICAgc2lnbjogJzw9JyxcbiAgICBjb21wYXJpc29uOiB0cnVlLFxuICB9LFxuXTtcblxuZXhwb3J0IGNvbnN0IGJpbmFyeVNjYWxhck9wZXJhdG9yVG9PcGVyYXRvck5hbWUgPSBiaW5hcnlTY2FsYXJEZWZzLnJlZHVjZSgoYWNjLCBkZWYpID0+IHtcbiAgYWNjW2RlZi5zaWduXSA9IHtcbiAgICBpZDogZGVmLmlkLFxuICAgIGNvbXBhcmlzb246IGRlZi5jb21wYXJpc29uLFxuICB9O1xuICByZXR1cm4gYWNjO1xufSwge30gYXMgUmVjb3JkPHN0cmluZywgeyBpZDogc3RyaW5nOyBjb21wYXJpc29uPzogYm9vbGVhbiB9Pik7XG5cbi8vIE5vdCBzdXJlIGFib3V0IHRoaXMgb25lLiBJdCBjb3VsZCBhbHNvIGJlIGEgbW9yZSBnZW5lcmljICdTaW1wbGUgbWF0aCBvcGVyYXRpb24nIHdoZXJlIHVzZXIgc3BlY2lmaWVzXG4vLyBib3RoIHRoZSBvcGVyYXRvciBhbmQgdGhlIG9wZXJhbmQgaW4gYSBzaW5nbGUgaW5wdXRcbmV4cG9ydCBjb25zdCBiaW5hcnlTY2FsYXJPcGVyYXRpb25zOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWZbXSA9IGJpbmFyeVNjYWxhckRlZnMubWFwKChvcERlZikgPT4ge1xuICBjb25zdCBwYXJhbXM6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmW10gPSBbeyBuYW1lOiAnVmFsdWUnLCB0eXBlOiAnbnVtYmVyJyB9XTtcbiAgY29uc3QgZGVmYXVsdFBhcmFtczogYW55W10gPSBbMl07XG4gIGlmIChvcERlZi5jb21wYXJpc29uKSB7XG4gICAgcGFyYW1zLnB1c2goe1xuICAgICAgbmFtZTogJ0Jvb2wnLFxuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgZGVzY3JpcHRpb246ICdJZiBjaGVja2VkIGNvbXBhcmlzb24gd2lsbCByZXR1cm4gMCBvciAxIGZvciB0aGUgdmFsdWUgcmF0aGVyIHRoYW4gZmlsdGVyaW5nLicsXG4gICAgfSk7XG4gICAgZGVmYXVsdFBhcmFtcy5wdXNoKGZhbHNlKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaWQ6IG9wRGVmLmlkLFxuICAgIG5hbWU6IG9wRGVmLm5hbWUsXG4gICAgcGFyYW1zLFxuICAgIGRlZmF1bHRQYXJhbXMsXG4gICAgYWx0ZXJuYXRpdmVzS2V5OiAnYmluYXJ5IHNjYWxhciBvcGVyYXRpb25zJyxcbiAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuQmluYXJ5T3BzLFxuICAgIHJlbmRlcmVyOiBnZXRTaW1wbGVCaW5hcnlSZW5kZXJlcihvcERlZi5zaWduKSxcbiAgICBhZGRPcGVyYXRpb25IYW5kbGVyOiBkZWZhdWx0QWRkT3BlcmF0aW9uSGFuZGxlcixcbiAgfTtcbn0pO1xuXG5mdW5jdGlvbiBnZXRTaW1wbGVCaW5hcnlSZW5kZXJlcihvcGVyYXRvcjogc3RyaW5nKSB7XG4gIHJldHVybiBmdW5jdGlvbiBiaW5hcnlSZW5kZXJlcihtb2RlbDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLCBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiwgaW5uZXJFeHByOiBzdHJpbmcpIHtcbiAgICBsZXQgcGFyYW0gPSBtb2RlbC5wYXJhbXNbMF07XG4gICAgbGV0IGJvb2wgPSAnJztcbiAgICBpZiAobW9kZWwucGFyYW1zLmxlbmd0aCA9PT0gMikge1xuICAgICAgYm9vbCA9IG1vZGVsLnBhcmFtc1sxXSA/ICcgYm9vbCcgOiAnJztcbiAgICB9XG5cbiAgICByZXR1cm4gYCR7aW5uZXJFeHByfSAke29wZXJhdG9yfSR7Ym9vbH0gJHtwYXJhbX1gO1xuICB9O1xufVxuIiwiaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBEYXRhU291cmNlQXBpLCBTZWxlY3RhYmxlVmFsdWUsIHRvT3B0aW9uIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBTZWxlY3QgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5cbmltcG9ydCB7IFByb21ldGhldXNEYXRhc291cmNlIH0gZnJvbSAnLi4vLi4vZGF0YXNvdXJjZSc7XG5pbXBvcnQgeyBwcm9tUXVlcnlNb2RlbGxlciB9IGZyb20gJy4uL1Byb21RdWVyeU1vZGVsbGVyJztcbmltcG9ydCB7IGdldE9wZXJhdGlvblBhcmFtSWQgfSBmcm9tICcuLi9zaGFyZWQvb3BlcmF0aW9uVXRpbHMnO1xuaW1wb3J0IHsgUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXIsIFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRWRpdG9yUHJvcHMgfSBmcm9tICcuLi9zaGFyZWQvdHlwZXMnO1xuaW1wb3J0IHsgUHJvbVZpc3VhbFF1ZXJ5IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gTGFiZWxQYXJhbUVkaXRvcih7XG4gIG9uQ2hhbmdlLFxuICBpbmRleCxcbiAgb3BlcmF0aW9uSW5kZXgsXG4gIHZhbHVlLFxuICBxdWVyeSxcbiAgZGF0YXNvdXJjZSxcbn06IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRWRpdG9yUHJvcHMpIHtcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSB1c2VTdGF0ZTx7XG4gICAgb3B0aW9ucz86IEFycmF5PFNlbGVjdGFibGVWYWx1ZTxhbnk+PjtcbiAgICBpc0xvYWRpbmc/OiBib29sZWFuO1xuICB9Pih7fSk7XG5cbiAgcmV0dXJuIChcbiAgICA8U2VsZWN0XG4gICAgICBpbnB1dElkPXtnZXRPcGVyYXRpb25QYXJhbUlkKG9wZXJhdGlvbkluZGV4LCBpbmRleCl9XG4gICAgICBhdXRvRm9jdXM9e3ZhbHVlID09PSAnJyA/IHRydWUgOiB1bmRlZmluZWR9XG4gICAgICBvcGVuTWVudU9uRm9jdXNcbiAgICAgIG9uT3Blbk1lbnU9e2FzeW5jICgpID0+IHtcbiAgICAgICAgc2V0U3RhdGUoeyBpc0xvYWRpbmc6IHRydWUgfSk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBhd2FpdCBsb2FkR3JvdXBCeUxhYmVscyhxdWVyeSwgZGF0YXNvdXJjZSk7XG4gICAgICAgIHNldFN0YXRlKHsgb3B0aW9ucywgaXNMb2FkaW5nOiB1bmRlZmluZWQgfSk7XG4gICAgICB9fVxuICAgICAgaXNMb2FkaW5nPXtzdGF0ZS5pc0xvYWRpbmd9XG4gICAgICBhbGxvd0N1c3RvbVZhbHVlXG4gICAgICBub09wdGlvbnNNZXNzYWdlPVwiTm8gbGFiZWxzIGZvdW5kXCJcbiAgICAgIGxvYWRpbmdNZXNzYWdlPVwiTG9hZGluZyBsYWJlbHNcIlxuICAgICAgb3B0aW9ucz17c3RhdGUub3B0aW9uc31cbiAgICAgIHZhbHVlPXt0b09wdGlvbih2YWx1ZSBhcyBzdHJpbmcpfVxuICAgICAgb25DaGFuZ2U9eyh2YWx1ZSkgPT4gb25DaGFuZ2UoaW5kZXgsIHZhbHVlLnZhbHVlISl9XG4gICAgLz5cbiAgKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gbG9hZEdyb3VwQnlMYWJlbHMoXG4gIHF1ZXJ5OiBQcm9tVmlzdWFsUXVlcnksXG4gIGRhdGFzb3VyY2U6IERhdGFTb3VyY2VBcGlcbik6IFByb21pc2U8QXJyYXk8U2VsZWN0YWJsZVZhbHVlPGFueT4+PiB7XG4gIGxldCBsYWJlbHM6IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyW10gPSBxdWVyeS5sYWJlbHM7XG5cbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJ5IGJvdGggUHJvbWV0aGV1cyBhbmQgTG9raSBhbmQgdGhpcyB0aGUgb25seSBkaWZmZXJlbmNlXG4gIGlmIChkYXRhc291cmNlIGluc3RhbmNlb2YgUHJvbWV0aGV1c0RhdGFzb3VyY2UpIHtcbiAgICBsYWJlbHMgPSBbeyBsYWJlbDogJ19fbmFtZV9fJywgb3A6ICc9JywgdmFsdWU6IHF1ZXJ5Lm1ldHJpYyB9LCAuLi5xdWVyeS5sYWJlbHNdO1xuICB9XG5cbiAgY29uc3QgZXhwciA9IHByb21RdWVyeU1vZGVsbGVyLnJlbmRlckxhYmVscyhsYWJlbHMpO1xuICBjb25zdCByZXN1bHQgPSBhd2FpdCBkYXRhc291cmNlLmxhbmd1YWdlUHJvdmlkZXIuZmV0Y2hTZXJpZXNMYWJlbHMoZXhwcik7XG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKHJlc3VsdCkubWFwKCh4KSA9PiAoe1xuICAgIGxhYmVsOiB4LFxuICAgIHZhbHVlOiB4LFxuICB9KSk7XG59XG4iLCJpbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IFJlYWN0LCB7IHVzZUNhbGxiYWNrLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0Jztcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCBIaWdobGlnaHRlciBmcm9tICdyZWFjdC1oaWdobGlnaHQtd29yZHMnO1xuXG5pbXBvcnQgeyBTZWxlY3RhYmxlVmFsdWUsIHRvT3B0aW9uLCBHcmFmYW5hVGhlbWUyIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBFZGl0b3JGaWVsZCwgRWRpdG9yRmllbGRHcm91cCB9IGZyb20gJ0BncmFmYW5hL2V4cGVyaW1lbnRhbCc7XG5pbXBvcnQgeyBTZWxlY3QsIEZvcm1hdE9wdGlvbkxhYmVsTWV0YSwgdXNlU3R5bGVzMiB9IGZyb20gJ0BncmFmYW5hL3VpJztcblxuaW1wb3J0IHsgUHJvbVZpc3VhbFF1ZXJ5IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG4vLyBXZSBhcmUgbWF0Y2hpbmcgd29yZHMgc3BsaXQgd2l0aCBzcGFjZVxuY29uc3Qgc3BsaXRTZXBhcmF0b3IgPSAnICc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICBxdWVyeTogUHJvbVZpc3VhbFF1ZXJ5O1xuICBvbkNoYW5nZTogKHF1ZXJ5OiBQcm9tVmlzdWFsUXVlcnkpID0+IHZvaWQ7XG4gIG9uR2V0TWV0cmljczogKCkgPT4gUHJvbWlzZTxTZWxlY3RhYmxlVmFsdWVbXT47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBNZXRyaWNTZWxlY3QoeyBxdWVyeSwgb25DaGFuZ2UsIG9uR2V0TWV0cmljcyB9OiBQcm9wcykge1xuICBjb25zdCBzdHlsZXMgPSB1c2VTdHlsZXMyKGdldFN0eWxlcyk7XG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gdXNlU3RhdGU8e1xuICAgIG1ldHJpY3M/OiBBcnJheTxTZWxlY3RhYmxlVmFsdWU8YW55Pj47XG4gICAgaXNMb2FkaW5nPzogYm9vbGVhbjtcbiAgfT4oe30pO1xuXG4gIGNvbnN0IGN1c3RvbUZpbHRlck9wdGlvbiA9IHVzZUNhbGxiYWNrKChvcHRpb246IFNlbGVjdGFibGVWYWx1ZTxhbnk+LCBzZWFyY2hRdWVyeTogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgbGFiZWwgPSBvcHRpb24ubGFiZWwgPz8gb3B0aW9uLnZhbHVlO1xuICAgIGlmICghbGFiZWwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBjdXN0b20gdmFsdWUgaXMgbm90IGEgc3RyaW5nIGxhYmVsIGJ1dCBhIHJlYWN0IG5vZGVcbiAgICBpZiAoIWxhYmVsLnRvTG93ZXJDYXNlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBzZWFyY2hXb3JkcyA9IHNlYXJjaFF1ZXJ5LnNwbGl0KHNwbGl0U2VwYXJhdG9yKTtcbiAgICByZXR1cm4gc2VhcmNoV29yZHMucmVkdWNlKChhY2MsIGN1cikgPT4gYWNjICYmIGxhYmVsLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoY3VyLnRvTG93ZXJDYXNlKCkpLCB0cnVlKTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IGZvcm1hdE9wdGlvbkxhYmVsID0gdXNlQ2FsbGJhY2soXG4gICAgKG9wdGlvbjogU2VsZWN0YWJsZVZhbHVlPGFueT4sIG1ldGE6IEZvcm1hdE9wdGlvbkxhYmVsTWV0YTxhbnk+KSA9PiB7XG4gICAgICAvLyBGb3IgbmV3bHkgY3JlYXRlZCBjdXN0b20gdmFsdWUgd2UgZG9uJ3Qgd2FudCB0byBhZGQgaGlnaGxpZ2h0XG4gICAgICBpZiAob3B0aW9uWydfX2lzTmV3X18nXSkge1xuICAgICAgICByZXR1cm4gb3B0aW9uLmxhYmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKFxuICAgICAgICA8SGlnaGxpZ2h0ZXJcbiAgICAgICAgICBzZWFyY2hXb3Jkcz17bWV0YS5pbnB1dFZhbHVlLnNwbGl0KHNwbGl0U2VwYXJhdG9yKX1cbiAgICAgICAgICB0ZXh0VG9IaWdobGlnaHQ9e29wdGlvbi5sYWJlbCA/PyAnJ31cbiAgICAgICAgICBoaWdobGlnaHRDbGFzc05hbWU9e3N0eWxlcy5oaWdobGlnaHR9XG4gICAgICAgIC8+XG4gICAgICApO1xuICAgIH0sXG4gICAgW3N0eWxlcy5oaWdobGlnaHRdXG4gICk7XG5cbiAgcmV0dXJuIChcbiAgICA8RWRpdG9yRmllbGRHcm91cD5cbiAgICAgIDxFZGl0b3JGaWVsZCBsYWJlbD1cIk1ldHJpY1wiPlxuICAgICAgICA8U2VsZWN0XG4gICAgICAgICAgaW5wdXRJZD1cInByb21ldGhldXMtbWV0cmljLXNlbGVjdFwiXG4gICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMuc2VsZWN0fVxuICAgICAgICAgIHZhbHVlPXtxdWVyeS5tZXRyaWMgPyB0b09wdGlvbihxdWVyeS5tZXRyaWMpIDogdW5kZWZpbmVkfVxuICAgICAgICAgIHBsYWNlaG9sZGVyPVwiU2VsZWN0IG1ldHJpY1wiXG4gICAgICAgICAgYWxsb3dDdXN0b21WYWx1ZVxuICAgICAgICAgIGZvcm1hdE9wdGlvbkxhYmVsPXtmb3JtYXRPcHRpb25MYWJlbH1cbiAgICAgICAgICBmaWx0ZXJPcHRpb249e2N1c3RvbUZpbHRlck9wdGlvbn1cbiAgICAgICAgICBvbk9wZW5NZW51PXthc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBzZXRTdGF0ZSh7IGlzTG9hZGluZzogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGNvbnN0IG1ldHJpY3MgPSBhd2FpdCBvbkdldE1ldHJpY3MoKTtcbiAgICAgICAgICAgIHNldFN0YXRlKHsgbWV0cmljcywgaXNMb2FkaW5nOiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgfX1cbiAgICAgICAgICBpc0xvYWRpbmc9e3N0YXRlLmlzTG9hZGluZ31cbiAgICAgICAgICBvcHRpb25zPXtzdGF0ZS5tZXRyaWNzfVxuICAgICAgICAgIG9uQ2hhbmdlPXsoeyB2YWx1ZSB9KSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgb25DaGFuZ2UoeyAuLi5xdWVyeSwgbWV0cmljOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9fVxuICAgICAgICAvPlxuICAgICAgPC9FZGl0b3JGaWVsZD5cbiAgICA8L0VkaXRvckZpZWxkR3JvdXA+XG4gICk7XG59XG5cbmNvbnN0IGdldFN0eWxlcyA9ICh0aGVtZTogR3JhZmFuYVRoZW1lMikgPT4gKHtcbiAgc2VsZWN0OiBjc3NgXG4gICAgbWluLXdpZHRoOiAxMjVweDtcbiAgYCxcbiAgaGlnaGxpZ2h0OiBjc3NgXG4gICAgbGFiZWw6IHNlbGVjdF9fbWF0Y2gtaGlnaGxpZ2h0O1xuICAgIGJhY2tncm91bmQ6IGluaGVyaXQ7XG4gICAgcGFkZGluZzogaW5oZXJpdDtcbiAgICBjb2xvcjogJHt0aGVtZS5jb2xvcnMud2FybmluZy5tYWlufTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKCR7dGhlbWUuY29sb3JzLndhcm5pbmcubWFpbn0sIDAuMSk7XG4gIGAsXG59KTtcbiIsImltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBHcmFmYW5hVGhlbWUyLCB0b09wdGlvbiB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgRWRpdG9yUm93cywgRmxleEl0ZW0gfSBmcm9tICdAZ3JhZmFuYS9leHBlcmltZW50YWwnO1xuaW1wb3J0IHsgSWNvbkJ1dHRvbiwgU2VsZWN0LCB1c2VTdHlsZXMyIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5pbXBvcnQgeyBQcm9tZXRoZXVzRGF0YXNvdXJjZSB9IGZyb20gJy4uLy4uL2RhdGFzb3VyY2UnO1xuaW1wb3J0IHsgYmluYXJ5U2NhbGFyRGVmcyB9IGZyb20gJy4uL2JpbmFyeVNjYWxhck9wZXJhdGlvbnMnO1xuaW1wb3J0IHsgQXV0b1NpemVJbnB1dCB9IGZyb20gJy4uL3NoYXJlZC9BdXRvU2l6ZUlucHV0JztcbmltcG9ydCB7IFByb21WaXN1YWxRdWVyeUJpbmFyeSB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgUHJvbVF1ZXJ5QnVpbGRlciB9IGZyb20gJy4vUHJvbVF1ZXJ5QnVpbGRlcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICBuZXN0ZWRRdWVyeTogUHJvbVZpc3VhbFF1ZXJ5QmluYXJ5O1xuICBkYXRhc291cmNlOiBQcm9tZXRoZXVzRGF0YXNvdXJjZTtcbiAgaW5kZXg6IG51bWJlcjtcbiAgb25DaGFuZ2U6IChpbmRleDogbnVtYmVyLCB1cGRhdGU6IFByb21WaXN1YWxRdWVyeUJpbmFyeSkgPT4gdm9pZDtcbiAgb25SZW1vdmU6IChpbmRleDogbnVtYmVyKSA9PiB2b2lkO1xuICBvblJ1blF1ZXJ5OiAoKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgY29uc3QgTmVzdGVkUXVlcnkgPSBSZWFjdC5tZW1vPFByb3BzPigoeyBuZXN0ZWRRdWVyeSwgaW5kZXgsIGRhdGFzb3VyY2UsIG9uQ2hhbmdlLCBvblJlbW92ZSwgb25SdW5RdWVyeSB9KSA9PiB7XG4gIGNvbnN0IHN0eWxlcyA9IHVzZVN0eWxlczIoZ2V0U3R5bGVzKTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuY2FyZH0+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmhlYWRlcn0+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMubmFtZX0+T3BlcmF0b3I8L2Rpdj5cbiAgICAgICAgPFNlbGVjdFxuICAgICAgICAgIHdpZHRoPVwiYXV0b1wiXG4gICAgICAgICAgb3B0aW9ucz17b3BlcmF0b3JzfVxuICAgICAgICAgIHZhbHVlPXt0b09wdGlvbihuZXN0ZWRRdWVyeS5vcGVyYXRvcil9XG4gICAgICAgICAgb25DaGFuZ2U9eyh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgb25DaGFuZ2UoaW5kZXgsIHtcbiAgICAgICAgICAgICAgLi4ubmVzdGVkUXVlcnksXG4gICAgICAgICAgICAgIG9wZXJhdG9yOiB2YWx1ZS52YWx1ZSEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9fVxuICAgICAgICAvPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLm5hbWV9PlZlY3RvciBtYXRjaGVzPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMudmVjdG9yTWF0Y2hXcmFwcGVyfT5cbiAgICAgICAgICA8U2VsZWN0PFByb21WaXN1YWxRdWVyeUJpbmFyeVsndmVjdG9yTWF0Y2hlc1R5cGUnXT5cbiAgICAgICAgICAgIHdpZHRoPVwiYXV0b1wiXG4gICAgICAgICAgICB2YWx1ZT17bmVzdGVkUXVlcnkudmVjdG9yTWF0Y2hlc1R5cGUgfHwgJ29uJ31cbiAgICAgICAgICAgIGFsbG93Q3VzdG9tVmFsdWVcbiAgICAgICAgICAgIG9wdGlvbnM9e1tcbiAgICAgICAgICAgICAgeyB2YWx1ZTogJ29uJywgbGFiZWw6ICdvbicgfSxcbiAgICAgICAgICAgICAgeyB2YWx1ZTogJ2lnbm9yaW5nJywgbGFiZWw6ICdpZ25vcmluZycgfSxcbiAgICAgICAgICAgIF19XG4gICAgICAgICAgICBvbkNoYW5nZT17KHZhbCkgPT4ge1xuICAgICAgICAgICAgICBvbkNoYW5nZShpbmRleCwge1xuICAgICAgICAgICAgICAgIC4uLm5lc3RlZFF1ZXJ5LFxuICAgICAgICAgICAgICAgIHZlY3Rvck1hdGNoZXNUeXBlOiB2YWwudmFsdWUsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICAvPlxuICAgICAgICAgIDxBdXRvU2l6ZUlucHV0XG4gICAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy52ZWN0b3JNYXRjaElucHV0fVxuICAgICAgICAgICAgbWluV2lkdGg9ezIwfVxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlPXtuZXN0ZWRRdWVyeS52ZWN0b3JNYXRjaGVzfVxuICAgICAgICAgICAgb25Db21taXRDaGFuZ2U9eyhldnQpID0+IHtcbiAgICAgICAgICAgICAgb25DaGFuZ2UoaW5kZXgsIHtcbiAgICAgICAgICAgICAgICAuLi5uZXN0ZWRRdWVyeSxcbiAgICAgICAgICAgICAgICB2ZWN0b3JNYXRjaGVzOiBldnQuY3VycmVudFRhcmdldC52YWx1ZSxcbiAgICAgICAgICAgICAgICB2ZWN0b3JNYXRjaGVzVHlwZTogbmVzdGVkUXVlcnkudmVjdG9yTWF0Y2hlc1R5cGUgfHwgJ29uJyxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9fVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8RmxleEl0ZW0gZ3Jvdz17MX0gLz5cbiAgICAgICAgPEljb25CdXR0b24gbmFtZT1cInRpbWVzXCIgc2l6ZT1cInNtXCIgb25DbGljaz17KCkgPT4gb25SZW1vdmUoaW5kZXgpfSAvPlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmJvZHl9PlxuICAgICAgICA8RWRpdG9yUm93cz5cbiAgICAgICAgICA8UHJvbVF1ZXJ5QnVpbGRlclxuICAgICAgICAgICAgcXVlcnk9e25lc3RlZFF1ZXJ5LnF1ZXJ5fVxuICAgICAgICAgICAgZGF0YXNvdXJjZT17ZGF0YXNvdXJjZX1cbiAgICAgICAgICAgIG5lc3RlZD17dHJ1ZX1cbiAgICAgICAgICAgIG9uUnVuUXVlcnk9e29uUnVuUXVlcnl9XG4gICAgICAgICAgICBvbkNoYW5nZT17KHVwZGF0ZSkgPT4ge1xuICAgICAgICAgICAgICBvbkNoYW5nZShpbmRleCwgeyAuLi5uZXN0ZWRRdWVyeSwgcXVlcnk6IHVwZGF0ZSB9KTtcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9FZGl0b3JSb3dzPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59KTtcblxuY29uc3Qgb3BlcmF0b3JzID0gYmluYXJ5U2NhbGFyRGVmcy5tYXAoKGRlZikgPT4gKHsgbGFiZWw6IGRlZi5zaWduLCB2YWx1ZTogZGVmLnNpZ24gfSkpO1xuXG5OZXN0ZWRRdWVyeS5kaXNwbGF5TmFtZSA9ICdOZXN0ZWRRdWVyeSc7XG5cbmNvbnN0IGdldFN0eWxlcyA9ICh0aGVtZTogR3JhZmFuYVRoZW1lMikgPT4ge1xuICByZXR1cm4ge1xuICAgIGNhcmQ6IGNzcyh7XG4gICAgICBsYWJlbDogJ2NhcmQnLFxuICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgZmxleERpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgICBnYXA6IHRoZW1lLnNwYWNpbmcoMC41KSxcbiAgICB9KSxcbiAgICBoZWFkZXI6IGNzcyh7XG4gICAgICBsYWJlbDogJ2hlYWRlcicsXG4gICAgICBwYWRkaW5nOiB0aGVtZS5zcGFjaW5nKDAuNSwgMC41LCAwLjUsIDEpLFxuICAgICAgZ2FwOiB0aGVtZS5zcGFjaW5nKDEpLFxuICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgfSksXG4gICAgbmFtZTogY3NzKHtcbiAgICAgIGxhYmVsOiAnbmFtZScsXG4gICAgICB3aGl0ZVNwYWNlOiAnbm93cmFwJyxcbiAgICB9KSxcbiAgICBib2R5OiBjc3Moe1xuICAgICAgbGFiZWw6ICdib2R5JyxcbiAgICAgIHBhZGRpbmdMZWZ0OiB0aGVtZS5zcGFjaW5nKDIpLFxuICAgIH0pLFxuICAgIHZlY3Rvck1hdGNoSW5wdXQ6IGNzcyh7XG4gICAgICBsYWJlbDogJ3ZlY3Rvck1hdGNoSW5wdXQnLFxuICAgICAgbWFyZ2luTGVmdDogLTEsXG4gICAgfSksXG4gICAgdmVjdG9yTWF0Y2hXcmFwcGVyOiBjc3Moe1xuICAgICAgbGFiZWw6ICd2ZWN0b3JNYXRjaFdyYXBwZXInLFxuICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgIH0pLFxuICB9O1xufTtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IFN0YWNrIH0gZnJvbSAnQGdyYWZhbmEvZXhwZXJpbWVudGFsJztcblxuaW1wb3J0IHsgUHJvbWV0aGV1c0RhdGFzb3VyY2UgfSBmcm9tICcuLi8uLi9kYXRhc291cmNlJztcbmltcG9ydCB7IFByb21WaXN1YWxRdWVyeSwgUHJvbVZpc3VhbFF1ZXJ5QmluYXJ5IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBOZXN0ZWRRdWVyeSB9IGZyb20gJy4vTmVzdGVkUXVlcnknO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgcXVlcnk6IFByb21WaXN1YWxRdWVyeTtcbiAgZGF0YXNvdXJjZTogUHJvbWV0aGV1c0RhdGFzb3VyY2U7XG4gIG9uQ2hhbmdlOiAocXVlcnk6IFByb21WaXN1YWxRdWVyeSkgPT4gdm9pZDtcbiAgb25SdW5RdWVyeTogKCkgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIE5lc3RlZFF1ZXJ5TGlzdCh7IHF1ZXJ5LCBkYXRhc291cmNlLCBvbkNoYW5nZSwgb25SdW5RdWVyeSB9OiBQcm9wcykge1xuICBjb25zdCBuZXN0ZWRRdWVyaWVzID0gcXVlcnkuYmluYXJ5UXVlcmllcyA/PyBbXTtcblxuICBjb25zdCBvbk5lc3RlZFF1ZXJ5VXBkYXRlID0gKGluZGV4OiBudW1iZXIsIHVwZGF0ZTogUHJvbVZpc3VhbFF1ZXJ5QmluYXJ5KSA9PiB7XG4gICAgY29uc3QgdXBkYXRlZExpc3QgPSBbLi4ubmVzdGVkUXVlcmllc107XG4gICAgdXBkYXRlZExpc3Quc3BsaWNlKGluZGV4LCAxLCB1cGRhdGUpO1xuICAgIG9uQ2hhbmdlKHsgLi4ucXVlcnksIGJpbmFyeVF1ZXJpZXM6IHVwZGF0ZWRMaXN0IH0pO1xuICB9O1xuXG4gIGNvbnN0IG9uUmVtb3ZlID0gKGluZGV4OiBudW1iZXIpID0+IHtcbiAgICBjb25zdCB1cGRhdGVkTGlzdCA9IFsuLi5uZXN0ZWRRdWVyaWVzLnNsaWNlKDAsIGluZGV4KSwgLi4ubmVzdGVkUXVlcmllcy5zbGljZShpbmRleCArIDEpXTtcbiAgICBvbkNoYW5nZSh7IC4uLnF1ZXJ5LCBiaW5hcnlRdWVyaWVzOiB1cGRhdGVkTGlzdCB9KTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxTdGFjayBkaXJlY3Rpb249XCJjb2x1bW5cIiBnYXA9ezF9PlxuICAgICAge25lc3RlZFF1ZXJpZXMubWFwKChuZXN0ZWRRdWVyeSwgaW5kZXgpID0+IChcbiAgICAgICAgPE5lc3RlZFF1ZXJ5XG4gICAgICAgICAga2V5PXtpbmRleC50b1N0cmluZygpfVxuICAgICAgICAgIG5lc3RlZFF1ZXJ5PXtuZXN0ZWRRdWVyeX1cbiAgICAgICAgICBpbmRleD17aW5kZXh9XG4gICAgICAgICAgb25DaGFuZ2U9e29uTmVzdGVkUXVlcnlVcGRhdGV9XG4gICAgICAgICAgZGF0YXNvdXJjZT17ZGF0YXNvdXJjZX1cbiAgICAgICAgICBvblJlbW92ZT17b25SZW1vdmV9XG4gICAgICAgICAgb25SdW5RdWVyeT17b25SdW5RdWVyeX1cbiAgICAgICAgLz5cbiAgICAgICkpfVxuICAgIDwvU3RhY2s+XG4gICk7XG59XG4iLCJpbXBvcnQgUmVhY3QsIHsgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IERhdGFTb3VyY2VBcGksIFBhbmVsRGF0YSwgU2VsZWN0YWJsZVZhbHVlIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBFZGl0b3JSb3cgfSBmcm9tICdAZ3JhZmFuYS9leHBlcmltZW50YWwnO1xuXG5pbXBvcnQgeyBQcm9tZXRoZXVzRGF0YXNvdXJjZSB9IGZyb20gJy4uLy4uL2RhdGFzb3VyY2UnO1xuaW1wb3J0IHsgZ2V0TWV0YWRhdGFTdHJpbmcgfSBmcm9tICcuLi8uLi9sYW5ndWFnZV9wcm92aWRlcic7XG5pbXBvcnQgeyBwcm9tUXVlcnlNb2RlbGxlciB9IGZyb20gJy4uL1Byb21RdWVyeU1vZGVsbGVyJztcbmltcG9ydCB7IExhYmVsRmlsdGVycyB9IGZyb20gJy4uL3NoYXJlZC9MYWJlbEZpbHRlcnMnO1xuaW1wb3J0IHsgT3BlcmF0aW9uTGlzdCB9IGZyb20gJy4uL3NoYXJlZC9PcGVyYXRpb25MaXN0JztcbmltcG9ydCB7IE9wZXJhdGlvbnNFZGl0b3JSb3cgfSBmcm9tICcuLi9zaGFyZWQvT3BlcmF0aW9uc0VkaXRvclJvdyc7XG5pbXBvcnQgeyBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlciB9IGZyb20gJy4uL3NoYXJlZC90eXBlcyc7XG5pbXBvcnQgeyBQcm9tVmlzdWFsUXVlcnkgfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IE1ldHJpY1NlbGVjdCB9IGZyb20gJy4vTWV0cmljU2VsZWN0JztcbmltcG9ydCB7IE5lc3RlZFF1ZXJ5TGlzdCB9IGZyb20gJy4vTmVzdGVkUXVlcnlMaXN0JztcbmltcG9ydCB7IFByb21RdWVyeUJ1aWxkZXJIaW50cyB9IGZyb20gJy4vUHJvbVF1ZXJ5QnVpbGRlckhpbnRzJztcblxuZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gIHF1ZXJ5OiBQcm9tVmlzdWFsUXVlcnk7XG4gIGRhdGFzb3VyY2U6IFByb21ldGhldXNEYXRhc291cmNlO1xuICBvbkNoYW5nZTogKHVwZGF0ZTogUHJvbVZpc3VhbFF1ZXJ5KSA9PiB2b2lkO1xuICBvblJ1blF1ZXJ5OiAoKSA9PiB2b2lkO1xuICBuZXN0ZWQ/OiBib29sZWFuO1xuICBkYXRhPzogUGFuZWxEYXRhO1xufVxuXG5leHBvcnQgY29uc3QgUHJvbVF1ZXJ5QnVpbGRlciA9IFJlYWN0Lm1lbW88UHJvcHM+KCh7IGRhdGFzb3VyY2UsIHF1ZXJ5LCBvbkNoYW5nZSwgb25SdW5RdWVyeSwgZGF0YSB9KSA9PiB7XG4gIGNvbnN0IG9uQ2hhbmdlTGFiZWxzID0gKGxhYmVsczogUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXJbXSkgPT4ge1xuICAgIG9uQ2hhbmdlKHsgLi4ucXVlcnksIGxhYmVscyB9KTtcbiAgfTtcblxuICAvKipcbiAgICogTWFwIG1ldHJpYyBtZXRhZGF0YSB0byBTZWxlY3RhYmxlVmFsdWUgZm9yIFNlbGVjdCBjb21wb25lbnQgYW5kIGFsc28gYWRkcyBkZWZpbmVkIHRlbXBsYXRlIHZhcmlhYmxlcyB0byB0aGUgbGlzdC5cbiAgICovXG4gIGNvbnN0IHdpdGhUZW1wbGF0ZVZhcmlhYmxlT3B0aW9ucyA9IHVzZUNhbGxiYWNrKFxuICAgIGFzeW5jIChvcHRpb25zUHJvbWlzZTogUHJvbWlzZTxBcnJheTx7IHZhbHVlOiBzdHJpbmc7IGRlc2NyaXB0aW9uPzogc3RyaW5nIH0+Pik6IFByb21pc2U8U2VsZWN0YWJsZVZhbHVlW10+ID0+IHtcbiAgICAgIGNvbnN0IHZhcmlhYmxlcyA9IGRhdGFzb3VyY2UuZ2V0VmFyaWFibGVzKCk7XG4gICAgICBjb25zdCBvcHRpb25zID0gYXdhaXQgb3B0aW9uc1Byb21pc2U7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAuLi52YXJpYWJsZXMubWFwKCh2YWx1ZSkgPT4gKHsgbGFiZWw6IHZhbHVlLCB2YWx1ZSB9KSksXG4gICAgICAgIC4uLm9wdGlvbnMubWFwKChvcHRpb24pID0+ICh7IGxhYmVsOiBvcHRpb24udmFsdWUsIHZhbHVlOiBvcHRpb24udmFsdWUsIHRpdGxlOiBvcHRpb24uZGVzY3JpcHRpb24gfSkpLFxuICAgICAgXTtcbiAgICB9LFxuICAgIFtkYXRhc291cmNlXVxuICApO1xuXG4gIGNvbnN0IG9uR2V0TGFiZWxOYW1lcyA9IGFzeW5jIChmb3JMYWJlbDogUGFydGlhbDxRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcj4pOiBQcm9taXNlPEFycmF5PHsgdmFsdWU6IHN0cmluZyB9Pj4gPT4ge1xuICAgIC8vIElmIG5vIG1ldHJpYyB3ZSBuZWVkIHRvIHVzZSBhIGRpZmZlcmVudCBtZXRob2RcbiAgICBpZiAoIXF1ZXJ5Lm1ldHJpYykge1xuICAgICAgLy8gVG9kbyBhZGQgY2FjaGluZyBidXQgaW5zaWRlIGxhbmd1YWdlIHByb3ZpZGVyIVxuICAgICAgYXdhaXQgZGF0YXNvdXJjZS5sYW5ndWFnZVByb3ZpZGVyLmZldGNoTGFiZWxzKCk7XG4gICAgICByZXR1cm4gZGF0YXNvdXJjZS5sYW5ndWFnZVByb3ZpZGVyLmdldExhYmVsS2V5cygpLm1hcCgoaykgPT4gKHsgdmFsdWU6IGsgfSkpO1xuICAgIH1cblxuICAgIGNvbnN0IGxhYmVsc1RvQ29uc2lkZXIgPSBxdWVyeS5sYWJlbHMuZmlsdGVyKCh4KSA9PiB4ICE9PSBmb3JMYWJlbCk7XG4gICAgbGFiZWxzVG9Db25zaWRlci5wdXNoKHsgbGFiZWw6ICdfX25hbWVfXycsIG9wOiAnPScsIHZhbHVlOiBxdWVyeS5tZXRyaWMgfSk7XG4gICAgY29uc3QgZXhwciA9IHByb21RdWVyeU1vZGVsbGVyLnJlbmRlckxhYmVscyhsYWJlbHNUb0NvbnNpZGVyKTtcbiAgICBjb25zdCBsYWJlbHNJbmRleCA9IGF3YWl0IGRhdGFzb3VyY2UubGFuZ3VhZ2VQcm92aWRlci5mZXRjaFNlcmllc0xhYmVscyhleHByKTtcblxuICAgIC8vIGZpbHRlciBvdXQgYWxyZWFkeSB1c2VkIGxhYmVsc1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhsYWJlbHNJbmRleClcbiAgICAgIC5maWx0ZXIoKGxhYmVsTmFtZSkgPT4gIWxhYmVsc1RvQ29uc2lkZXIuZmluZCgoZmlsdGVyKSA9PiBmaWx0ZXIubGFiZWwgPT09IGxhYmVsTmFtZSkpXG4gICAgICAubWFwKChrKSA9PiAoeyB2YWx1ZTogayB9KSk7XG4gIH07XG5cbiAgY29uc3Qgb25HZXRMYWJlbFZhbHVlcyA9IGFzeW5jIChmb3JMYWJlbDogUGFydGlhbDxRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcj4pID0+IHtcbiAgICBpZiAoIWZvckxhYmVsLmxhYmVsKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgLy8gSWYgbm8gbWV0cmljIHdlIG5lZWQgdG8gdXNlIGEgZGlmZmVyZW50IG1ldGhvZFxuICAgIGlmICghcXVlcnkubWV0cmljKSB7XG4gICAgICByZXR1cm4gKGF3YWl0IGRhdGFzb3VyY2UubGFuZ3VhZ2VQcm92aWRlci5nZXRMYWJlbFZhbHVlcyhmb3JMYWJlbC5sYWJlbCkpLm1hcCgodikgPT4gKHsgdmFsdWU6IHYgfSkpO1xuICAgIH1cblxuICAgIGNvbnN0IGxhYmVsc1RvQ29uc2lkZXIgPSBxdWVyeS5sYWJlbHMuZmlsdGVyKCh4KSA9PiB4ICE9PSBmb3JMYWJlbCk7XG4gICAgbGFiZWxzVG9Db25zaWRlci5wdXNoKHsgbGFiZWw6ICdfX25hbWVfXycsIG9wOiAnPScsIHZhbHVlOiBxdWVyeS5tZXRyaWMgfSk7XG4gICAgY29uc3QgZXhwciA9IHByb21RdWVyeU1vZGVsbGVyLnJlbmRlckxhYmVscyhsYWJlbHNUb0NvbnNpZGVyKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBkYXRhc291cmNlLmxhbmd1YWdlUHJvdmlkZXIuZmV0Y2hTZXJpZXNMYWJlbHMoZXhwcik7XG4gICAgY29uc3QgZm9yTGFiZWxJbnRlcnBvbGF0ZWQgPSBkYXRhc291cmNlLmludGVycG9sYXRlU3RyaW5nKGZvckxhYmVsLmxhYmVsKTtcbiAgICByZXR1cm4gcmVzdWx0W2ZvckxhYmVsSW50ZXJwb2xhdGVkXS5tYXAoKHYpID0+ICh7IHZhbHVlOiB2IH0pKSA/PyBbXTtcbiAgfTtcblxuICBjb25zdCBvbkdldE1ldHJpY3MgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgcmV0dXJuIHdpdGhUZW1wbGF0ZVZhcmlhYmxlT3B0aW9ucyhnZXRNZXRyaWNzKGRhdGFzb3VyY2UsIHF1ZXJ5KSk7XG4gIH0sIFtkYXRhc291cmNlLCBxdWVyeSwgd2l0aFRlbXBsYXRlVmFyaWFibGVPcHRpb25zXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPEVkaXRvclJvdz5cbiAgICAgICAgPE1ldHJpY1NlbGVjdCBxdWVyeT17cXVlcnl9IG9uQ2hhbmdlPXtvbkNoYW5nZX0gb25HZXRNZXRyaWNzPXtvbkdldE1ldHJpY3N9IC8+XG4gICAgICAgIDxMYWJlbEZpbHRlcnNcbiAgICAgICAgICBsYWJlbHNGaWx0ZXJzPXtxdWVyeS5sYWJlbHN9XG4gICAgICAgICAgb25DaGFuZ2U9e29uQ2hhbmdlTGFiZWxzfVxuICAgICAgICAgIG9uR2V0TGFiZWxOYW1lcz17KGZvckxhYmVsOiBQYXJ0aWFsPFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyPikgPT5cbiAgICAgICAgICAgIHdpdGhUZW1wbGF0ZVZhcmlhYmxlT3B0aW9ucyhvbkdldExhYmVsTmFtZXMoZm9yTGFiZWwpKVxuICAgICAgICAgIH1cbiAgICAgICAgICBvbkdldExhYmVsVmFsdWVzPXsoZm9yTGFiZWw6IFBhcnRpYWw8UXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXI+KSA9PlxuICAgICAgICAgICAgd2l0aFRlbXBsYXRlVmFyaWFibGVPcHRpb25zKG9uR2V0TGFiZWxWYWx1ZXMoZm9yTGFiZWwpKVxuICAgICAgICAgIH1cbiAgICAgICAgLz5cbiAgICAgIDwvRWRpdG9yUm93PlxuICAgICAgPE9wZXJhdGlvbnNFZGl0b3JSb3c+XG4gICAgICAgIDxPcGVyYXRpb25MaXN0PFByb21WaXN1YWxRdWVyeT5cbiAgICAgICAgICBxdWVyeU1vZGVsbGVyPXtwcm9tUXVlcnlNb2RlbGxlcn1cbiAgICAgICAgICBkYXRhc291cmNlPXtkYXRhc291cmNlIGFzIERhdGFTb3VyY2VBcGl9XG4gICAgICAgICAgcXVlcnk9e3F1ZXJ5fVxuICAgICAgICAgIG9uQ2hhbmdlPXtvbkNoYW5nZX1cbiAgICAgICAgICBvblJ1blF1ZXJ5PXtvblJ1blF1ZXJ5fVxuICAgICAgICAvPlxuICAgICAgICA8UHJvbVF1ZXJ5QnVpbGRlckhpbnRzIGRhdGFzb3VyY2U9e2RhdGFzb3VyY2V9IHF1ZXJ5PXtxdWVyeX0gb25DaGFuZ2U9e29uQ2hhbmdlfSBkYXRhPXtkYXRhfSAvPlxuICAgICAgPC9PcGVyYXRpb25zRWRpdG9yUm93PlxuICAgICAge3F1ZXJ5LmJpbmFyeVF1ZXJpZXMgJiYgcXVlcnkuYmluYXJ5UXVlcmllcy5sZW5ndGggPiAwICYmIChcbiAgICAgICAgPE5lc3RlZFF1ZXJ5TGlzdCBxdWVyeT17cXVlcnl9IGRhdGFzb3VyY2U9e2RhdGFzb3VyY2V9IG9uQ2hhbmdlPXtvbkNoYW5nZX0gb25SdW5RdWVyeT17b25SdW5RdWVyeX0gLz5cbiAgICAgICl9XG4gICAgPC8+XG4gICk7XG59KTtcblxuLyoqXG4gKiBSZXR1cm5zIGxpc3Qgb2YgbWV0cmljcywgZWl0aGVyIGFsbCBvciBmaWx0ZXJlZCBieSBxdWVyeSBwYXJhbS4gSXQgYWxzbyBhZGRzIGRlc2NyaXB0aW9uIHN0cmluZyB0byBlYWNoIG1ldHJpYyBpZiBpdFxuICogZXhpc3RzLlxuICogQHBhcmFtIGRhdGFzb3VyY2VcbiAqIEBwYXJhbSBxdWVyeVxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRNZXRyaWNzKFxuICBkYXRhc291cmNlOiBQcm9tZXRoZXVzRGF0YXNvdXJjZSxcbiAgcXVlcnk6IFByb21WaXN1YWxRdWVyeVxuKTogUHJvbWlzZTxBcnJheTx7IHZhbHVlOiBzdHJpbmc7IGRlc2NyaXB0aW9uPzogc3RyaW5nIH0+PiB7XG4gIC8vIE1ha2VzIHN1cmUgd2UgbG9hZGVkIHRoZSBtZXRhZGF0YSBmb3IgbWV0cmljcy4gVXN1YWxseSB0aGlzIGlzIGRvbmUgaW4gdGhlIHN0YXJ0KCkgbWV0aG9kIG9mIHRoZSBwcm92aWRlciBidXQgd2VcbiAgLy8gZG9uJ3QgdXNlIGl0IHdpdGggdGhlIHZpc3VhbCBidWlsZGVyIGFuZCB0aGVyZSBpcyBubyBuZWVkIHRvIHJ1biBhbGwgdGhlIHN0YXJ0KCkgc2V0dXAgYW55d2F5LlxuICBpZiAoIWRhdGFzb3VyY2UubGFuZ3VhZ2VQcm92aWRlci5tZXRyaWNzTWV0YWRhdGEpIHtcbiAgICBhd2FpdCBkYXRhc291cmNlLmxhbmd1YWdlUHJvdmlkZXIubG9hZE1ldHJpY3NNZXRhZGF0YSgpO1xuICB9XG5cbiAgbGV0IG1ldHJpY3M7XG4gIGlmIChxdWVyeS5sYWJlbHMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGV4cHIgPSBwcm9tUXVlcnlNb2RlbGxlci5yZW5kZXJMYWJlbHMocXVlcnkubGFiZWxzKTtcbiAgICBtZXRyaWNzID0gKGF3YWl0IGRhdGFzb3VyY2UubGFuZ3VhZ2VQcm92aWRlci5nZXRTZXJpZXMoZXhwciwgdHJ1ZSkpWydfX25hbWVfXyddID8/IFtdO1xuICB9IGVsc2Uge1xuICAgIG1ldHJpY3MgPSAoYXdhaXQgZGF0YXNvdXJjZS5sYW5ndWFnZVByb3ZpZGVyLmdldExhYmVsVmFsdWVzKCdfX25hbWVfXycpKSA/PyBbXTtcbiAgfVxuXG4gIHJldHVybiBtZXRyaWNzLm1hcCgobSkgPT4gKHtcbiAgICB2YWx1ZTogbSxcbiAgICBkZXNjcmlwdGlvbjogZ2V0TWV0YWRhdGFTdHJpbmcobSwgZGF0YXNvdXJjZS5sYW5ndWFnZVByb3ZpZGVyLm1ldHJpY3NNZXRhZGF0YSEpLFxuICB9KSk7XG59XG5cblByb21RdWVyeUJ1aWxkZXIuZGlzcGxheU5hbWUgPSAnUHJvbVF1ZXJ5QnVpbGRlcic7XG4iLCJpbXBvcnQgeyBjcmVhdGVTbGljZSwgUGF5bG9hZEFjdGlvbiB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQnO1xuaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlUmVkdWNlciB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgUGFuZWxEYXRhIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5cbmltcG9ydCB7IFByb21ldGhldXNEYXRhc291cmNlIH0gZnJvbSAnLi4vLi4vZGF0YXNvdXJjZSc7XG5pbXBvcnQgeyBQcm9tUXVlcnkgfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQgeyBwcm9tUXVlcnlNb2RlbGxlciB9IGZyb20gJy4uL1Byb21RdWVyeU1vZGVsbGVyJztcbmltcG9ydCB7IGJ1aWxkVmlzdWFsUXVlcnlGcm9tU3RyaW5nIH0gZnJvbSAnLi4vcGFyc2luZyc7XG5pbXBvcnQgeyBQcm9tVmlzdWFsUXVlcnkgfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IFByb21RdWVyeUJ1aWxkZXIgfSBmcm9tICcuL1Byb21RdWVyeUJ1aWxkZXInO1xuaW1wb3J0IHsgUXVlcnlQcmV2aWV3IH0gZnJvbSAnLi9RdWVyeVByZXZpZXcnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgcXVlcnk6IFByb21RdWVyeTtcbiAgZGF0YXNvdXJjZTogUHJvbWV0aGV1c0RhdGFzb3VyY2U7XG4gIG9uQ2hhbmdlOiAodXBkYXRlOiBQcm9tUXVlcnkpID0+IHZvaWQ7XG4gIG9uUnVuUXVlcnk6ICgpID0+IHZvaWQ7XG4gIGRhdGE/OiBQYW5lbERhdGE7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RhdGUge1xuICB2aXNRdWVyeT86IFByb21WaXN1YWxRdWVyeTtcbiAgZXhwcjogc3RyaW5nO1xufVxuXG4vKipcbiAqIFRoaXMgY29tcG9uZW50IGlzIGhlcmUganVzdCB0byBjb250YWluIHRoZSB0cmFuc2xhdGlvbiBsb2dpYyBiZXR3ZWVuIHN0cmluZyBxdWVyeSBhbmQgdGhlIHZpc3VhbCBxdWVyeSBidWlsZGVyIG1vZGVsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gUHJvbVF1ZXJ5QnVpbGRlckNvbnRhaW5lcihwcm9wczogUHJvcHMpIHtcbiAgY29uc3QgeyBxdWVyeSwgb25DaGFuZ2UsIG9uUnVuUXVlcnksIGRhdGFzb3VyY2UsIGRhdGEgfSA9IHByb3BzO1xuICBjb25zdCBbc3RhdGUsIGRpc3BhdGNoXSA9IHVzZVJlZHVjZXIoc3RhdGVTbGljZS5yZWR1Y2VyLCB7IGV4cHI6IHF1ZXJ5LmV4cHIgfSk7XG5cbiAgLy8gT25seSByZWJ1aWxkIHZpc3VhbCBxdWVyeSBpZiBleHByIGNoYW5nZXMgZnJvbSBvdXRzaWRlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgZGlzcGF0Y2goZXhwckNoYW5nZWQocXVlcnkuZXhwcikpO1xuICB9LCBbcXVlcnkuZXhwcl0pO1xuXG4gIGNvbnN0IG9uVmlzUXVlcnlDaGFuZ2UgPSAodmlzUXVlcnk6IFByb21WaXN1YWxRdWVyeSkgPT4ge1xuICAgIGNvbnN0IGV4cHIgPSBwcm9tUXVlcnlNb2RlbGxlci5yZW5kZXJRdWVyeSh2aXNRdWVyeSk7XG4gICAgZGlzcGF0Y2godmlzdWFsUXVlcnlDaGFuZ2UoeyB2aXNRdWVyeSwgZXhwciB9KSk7XG4gICAgb25DaGFuZ2UoeyAuLi5wcm9wcy5xdWVyeSwgZXhwcjogZXhwciB9KTtcbiAgfTtcblxuICBpZiAoIXN0YXRlLnZpc1F1ZXJ5KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8UHJvbVF1ZXJ5QnVpbGRlclxuICAgICAgICBxdWVyeT17c3RhdGUudmlzUXVlcnl9XG4gICAgICAgIGRhdGFzb3VyY2U9e2RhdGFzb3VyY2V9XG4gICAgICAgIG9uQ2hhbmdlPXtvblZpc1F1ZXJ5Q2hhbmdlfVxuICAgICAgICBvblJ1blF1ZXJ5PXtvblJ1blF1ZXJ5fVxuICAgICAgICBkYXRhPXtkYXRhfVxuICAgICAgLz5cbiAgICAgIHtxdWVyeS5yYXdRdWVyeSAmJiA8UXVlcnlQcmV2aWV3IHF1ZXJ5PXtxdWVyeS5leHByfSAvPn1cbiAgICA8Lz5cbiAgKTtcbn1cblxuY29uc3Qgc3RhdGVTbGljZSA9IGNyZWF0ZVNsaWNlKHtcbiAgbmFtZTogJ3Byb20tYnVpbGRlci1jb250YWluZXInLFxuICBpbml0aWFsU3RhdGU6IHsgZXhwcjogJycgfSBhcyBTdGF0ZSxcbiAgcmVkdWNlcnM6IHtcbiAgICB2aXN1YWxRdWVyeUNoYW5nZTogKHN0YXRlLCBhY3Rpb246IFBheWxvYWRBY3Rpb248eyB2aXNRdWVyeTogUHJvbVZpc3VhbFF1ZXJ5OyBleHByOiBzdHJpbmcgfT4pID0+IHtcbiAgICAgIHN0YXRlLmV4cHIgPSBhY3Rpb24ucGF5bG9hZC5leHByO1xuICAgICAgc3RhdGUudmlzUXVlcnkgPSBhY3Rpb24ucGF5bG9hZC52aXNRdWVyeTtcbiAgICB9LFxuICAgIGV4cHJDaGFuZ2VkOiAoc3RhdGUsIGFjdGlvbjogUGF5bG9hZEFjdGlvbjxzdHJpbmc+KSA9PiB7XG4gICAgICBpZiAoIXN0YXRlLnZpc1F1ZXJ5IHx8IHN0YXRlLmV4cHIgIT09IGFjdGlvbi5wYXlsb2FkKSB7XG4gICAgICAgIHN0YXRlLmV4cHIgPSBhY3Rpb24ucGF5bG9hZDtcbiAgICAgICAgY29uc3QgcGFyc2VSZXN1bHQgPSBidWlsZFZpc3VhbFF1ZXJ5RnJvbVN0cmluZyhhY3Rpb24ucGF5bG9hZCk7XG4gICAgICAgIHN0YXRlLnZpc1F1ZXJ5ID0gcGFyc2VSZXN1bHQucXVlcnk7XG4gICAgICB9XG4gICAgfSxcbiAgfSxcbn0pO1xuXG5jb25zdCB7IHZpc3VhbFF1ZXJ5Q2hhbmdlLCBleHByQ2hhbmdlZCB9ID0gc3RhdGVTbGljZS5hY3Rpb25zO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgU3RhY2sgfSBmcm9tICdAZ3JhZmFuYS9leHBlcmltZW50YWwnO1xuXG5pbXBvcnQgeyBwcm9tUXVlcnlNb2RlbGxlciB9IGZyb20gJy4uL1Byb21RdWVyeU1vZGVsbGVyJztcbmltcG9ydCB7IGJ1aWxkVmlzdWFsUXVlcnlGcm9tU3RyaW5nIH0gZnJvbSAnLi4vcGFyc2luZyc7XG5pbXBvcnQgeyBPcGVyYXRpb25FeHBsYWluZWRCb3ggfSBmcm9tICcuLi9zaGFyZWQvT3BlcmF0aW9uRXhwbGFpbmVkQm94JztcbmltcG9ydCB7IE9wZXJhdGlvbkxpc3RFeHBsYWluZWQgfSBmcm9tICcuLi9zaGFyZWQvT3BlcmF0aW9uTGlzdEV4cGxhaW5lZCc7XG5pbXBvcnQgeyBQcm9tVmlzdWFsUXVlcnkgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICBxdWVyeTogc3RyaW5nO1xuICBuZXN0ZWQ/OiBib29sZWFuO1xufVxuXG5leHBvcnQgY29uc3QgUHJvbVF1ZXJ5QnVpbGRlckV4cGxhaW5lZCA9IFJlYWN0Lm1lbW88UHJvcHM+KCh7IHF1ZXJ5LCBuZXN0ZWQgfSkgPT4ge1xuICBjb25zdCB2aXNRdWVyeSA9IGJ1aWxkVmlzdWFsUXVlcnlGcm9tU3RyaW5nKHF1ZXJ5IHx8ICcnKS5xdWVyeTtcblxuICByZXR1cm4gKFxuICAgIDxTdGFjayBnYXA9ezB9IGRpcmVjdGlvbj1cImNvbHVtblwiPlxuICAgICAgPE9wZXJhdGlvbkV4cGxhaW5lZEJveFxuICAgICAgICBzdGVwTnVtYmVyPXsxfVxuICAgICAgICB0aXRsZT17YCR7dmlzUXVlcnkubWV0cmljfSAke3Byb21RdWVyeU1vZGVsbGVyLnJlbmRlckxhYmVscyh2aXNRdWVyeS5sYWJlbHMpfWB9XG4gICAgICA+XG4gICAgICAgIEZldGNoIGFsbCBzZXJpZXMgbWF0Y2hpbmcgbWV0cmljIG5hbWUgYW5kIGxhYmVsIGZpbHRlcnMuXG4gICAgICA8L09wZXJhdGlvbkV4cGxhaW5lZEJveD5cbiAgICAgIDxPcGVyYXRpb25MaXN0RXhwbGFpbmVkPFByb21WaXN1YWxRdWVyeT4gc3RlcE51bWJlcj17Mn0gcXVlcnlNb2RlbGxlcj17cHJvbVF1ZXJ5TW9kZWxsZXJ9IHF1ZXJ5PXt2aXNRdWVyeX0gLz5cbiAgICA8L1N0YWNrPlxuICApO1xufSk7XG5cblByb21RdWVyeUJ1aWxkZXJFeHBsYWluZWQuZGlzcGxheU5hbWUgPSAnUHJvbVF1ZXJ5QnVpbGRlckV4cGxhaW5lZCc7XG4iLCJpbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IEdyYWZhbmFUaGVtZTIsIFBhbmVsRGF0YSwgUXVlcnlIaW50IH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBCdXR0b24sIFRvb2x0aXAsIHVzZVN0eWxlczIgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5cbmltcG9ydCB7IFByb21ldGhldXNEYXRhc291cmNlIH0gZnJvbSAnLi4vLi4vZGF0YXNvdXJjZSc7XG5pbXBvcnQgeyBwcm9tUXVlcnlNb2RlbGxlciB9IGZyb20gJy4uL1Byb21RdWVyeU1vZGVsbGVyJztcbmltcG9ydCB7IGJ1aWxkVmlzdWFsUXVlcnlGcm9tU3RyaW5nIH0gZnJvbSAnLi4vcGFyc2luZyc7XG5pbXBvcnQgeyBQcm9tVmlzdWFsUXVlcnkgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICBxdWVyeTogUHJvbVZpc3VhbFF1ZXJ5O1xuICBkYXRhc291cmNlOiBQcm9tZXRoZXVzRGF0YXNvdXJjZTtcbiAgb25DaGFuZ2U6ICh1cGRhdGU6IFByb21WaXN1YWxRdWVyeSkgPT4gdm9pZDtcbiAgZGF0YT86IFBhbmVsRGF0YTtcbn1cblxuZXhwb3J0IGNvbnN0IFByb21RdWVyeUJ1aWxkZXJIaW50cyA9IFJlYWN0Lm1lbW88UHJvcHM+KCh7IGRhdGFzb3VyY2UsIHF1ZXJ5LCBvbkNoYW5nZSwgZGF0YSB9KSA9PiB7XG4gIGNvbnN0IFtoaW50cywgc2V0SGludHNdID0gdXNlU3RhdGU8UXVlcnlIaW50W10+KFtdKTtcbiAgY29uc3Qgc3R5bGVzID0gdXNlU3R5bGVzMihnZXRTdHlsZXMpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgcHJvbVF1ZXJ5ID0geyBleHByOiBwcm9tUXVlcnlNb2RlbGxlci5yZW5kZXJRdWVyeShxdWVyeSksIHJlZklkOiAnJyB9O1xuICAgIC8vIEZvciBub3cgc2hvdyBvbmx5IGFjdGlvbmFibGUgaGludHNcbiAgICBjb25zdCBoaW50cyA9IGRhdGFzb3VyY2UuZ2V0UXVlcnlIaW50cyhwcm9tUXVlcnksIGRhdGE/LnNlcmllcyB8fCBbXSkuZmlsdGVyKChoaW50KSA9PiBoaW50LmZpeD8uYWN0aW9uKTtcbiAgICBzZXRIaW50cyhoaW50cyk7XG4gIH0sIFtkYXRhc291cmNlLCBxdWVyeSwgb25DaGFuZ2UsIGRhdGEsIHN0eWxlcy5oaW50XSk7XG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAge2hpbnRzLmxlbmd0aCA+IDAgJiYgKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmNvbnRhaW5lcn0+XG4gICAgICAgICAge2hpbnRzLm1hcCgoaGludCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgPFRvb2x0aXAgY29udGVudD17YCR7aGludC5sYWJlbH0gJHtoaW50LmZpeD8ubGFiZWx9YH0ga2V5PXtoaW50LnR5cGV9PlxuICAgICAgICAgICAgICAgIDxCdXR0b25cbiAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvbVF1ZXJ5ID0geyBleHByOiBwcm9tUXVlcnlNb2RlbGxlci5yZW5kZXJRdWVyeShxdWVyeSksIHJlZklkOiAnJyB9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdQcm9tUXVlcnkgPSBkYXRhc291cmNlLm1vZGlmeVF1ZXJ5KHByb21RdWVyeSwgaGludCEuZml4IS5hY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2aXN1YWxRdWVyeSA9IGJ1aWxkVmlzdWFsUXVlcnlGcm9tU3RyaW5nKG5ld1Byb21RdWVyeS5leHByKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9uQ2hhbmdlKHZpc3VhbFF1ZXJ5LnF1ZXJ5KTtcbiAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICBmaWxsPVwib3V0bGluZVwiXG4gICAgICAgICAgICAgICAgICBzaXplPVwic21cIlxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMuaGludH1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICB7J2hpbnQ6ICcgKyBoaW50LmZpeD8uYWN0aW9uPy50eXBlLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnXycsICcgJykgKyAnKCknfVxuICAgICAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgICA8L1Rvb2x0aXA+XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG4gICAgPC8+XG4gICk7XG59KTtcblxuUHJvbVF1ZXJ5QnVpbGRlckhpbnRzLmRpc3BsYXlOYW1lID0gJ1Byb21RdWVyeUJ1aWxkZXJIaW50cyc7XG5cbmNvbnN0IGdldFN0eWxlcyA9ICh0aGVtZTogR3JhZmFuYVRoZW1lMikgPT4ge1xuICByZXR1cm4ge1xuICAgIGNvbnRhaW5lcjogY3NzYFxuICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIG1hcmdpbi1ib3R0b206ICR7dGhlbWUuc3BhY2luZygxKX07XG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGAsXG4gICAgaGludDogY3NzYFxuICAgICAgbWFyZ2luLXJpZ2h0OiAke3RoZW1lLnNwYWNpbmcoMSl9O1xuICAgIGAsXG4gIH07XG59O1xuIiwiaW1wb3J0IFJlYWN0LCB7IFN5bnRoZXRpY0V2ZW50IH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBDb3JlQXBwLCBTZWxlY3RhYmxlVmFsdWUgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IEVkaXRvclJvdywgRWRpdG9yRmllbGQsIEVkaXRvclN3aXRjaCB9IGZyb20gJ0BncmFmYW5hL2V4cGVyaW1lbnRhbCc7XG5pbXBvcnQgeyBSYWRpb0J1dHRvbkdyb3VwLCBTZWxlY3QgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5cbmltcG9ydCB7IGdldFF1ZXJ5VHlwZUNoYW5nZUhhbmRsZXIsIGdldFF1ZXJ5VHlwZU9wdGlvbnMgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL1Byb21FeHBsb3JlRXh0cmFGaWVsZCc7XG5pbXBvcnQgeyBGT1JNQVRfT1BUSU9OUywgSU5URVJWQUxfRkFDVE9SX09QVElPTlMgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL1Byb21RdWVyeUVkaXRvcic7XG5pbXBvcnQgeyBQcm9tUXVlcnkgfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQgeyBBdXRvU2l6ZUlucHV0IH0gZnJvbSAnLi4vc2hhcmVkL0F1dG9TaXplSW5wdXQnO1xuaW1wb3J0IHsgUXVlcnlPcHRpb25Hcm91cCB9IGZyb20gJy4uL3NoYXJlZC9RdWVyeU9wdGlvbkdyb3VwJztcblxuaW1wb3J0IHsgZ2V0TGVnZW5kTW9kZUxhYmVsLCBQcm9tUXVlcnlMZWdlbmRFZGl0b3IgfSBmcm9tICcuL1Byb21RdWVyeUxlZ2VuZEVkaXRvcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICBxdWVyeTogUHJvbVF1ZXJ5O1xuICBhcHA/OiBDb3JlQXBwO1xuICBvbkNoYW5nZTogKHVwZGF0ZTogUHJvbVF1ZXJ5KSA9PiB2b2lkO1xuICBvblJ1blF1ZXJ5OiAoKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgY29uc3QgUHJvbVF1ZXJ5QnVpbGRlck9wdGlvbnMgPSBSZWFjdC5tZW1vPFByb3BzPigoeyBxdWVyeSwgYXBwLCBvbkNoYW5nZSwgb25SdW5RdWVyeSB9KSA9PiB7XG4gIGNvbnN0IG9uQ2hhbmdlRm9ybWF0ID0gKHZhbHVlOiBTZWxlY3RhYmxlVmFsdWU8c3RyaW5nPikgPT4ge1xuICAgIG9uQ2hhbmdlKHsgLi4ucXVlcnksIGZvcm1hdDogdmFsdWUudmFsdWUgfSk7XG4gICAgb25SdW5RdWVyeSgpO1xuICB9O1xuXG4gIGNvbnN0IG9uQ2hhbmdlU3RlcCA9IChldnQ6IFJlYWN0LkZvcm1FdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgIG9uQ2hhbmdlKHsgLi4ucXVlcnksIGludGVydmFsOiBldnQuY3VycmVudFRhcmdldC52YWx1ZSB9KTtcbiAgICBvblJ1blF1ZXJ5KCk7XG4gIH07XG5cbiAgY29uc3QgcXVlcnlUeXBlT3B0aW9ucyA9IGdldFF1ZXJ5VHlwZU9wdGlvbnMoYXBwID09PSBDb3JlQXBwLkV4cGxvcmUpO1xuICBjb25zdCBvblF1ZXJ5VHlwZUNoYW5nZSA9IGdldFF1ZXJ5VHlwZUNoYW5nZUhhbmRsZXIocXVlcnksIG9uQ2hhbmdlKTtcblxuICBjb25zdCBvbkV4ZW1wbGFyQ2hhbmdlID0gKGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IGlzRW5hYmxlZCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQuY2hlY2tlZDtcbiAgICBvbkNoYW5nZSh7IC4uLnF1ZXJ5LCBleGVtcGxhcjogaXNFbmFibGVkIH0pO1xuICAgIG9uUnVuUXVlcnkoKTtcbiAgfTtcblxuICBjb25zdCBvbkludGVydmFsRmFjdG9yQ2hhbmdlID0gKHZhbHVlOiBTZWxlY3RhYmxlVmFsdWU8bnVtYmVyPikgPT4ge1xuICAgIG9uQ2hhbmdlKHsgLi4ucXVlcnksIGludGVydmFsRmFjdG9yOiB2YWx1ZS52YWx1ZSB9KTtcbiAgICBvblJ1blF1ZXJ5KCk7XG4gIH07XG5cbiAgY29uc3QgZm9ybWF0T3B0aW9uID0gRk9STUFUX09QVElPTlMuZmluZCgob3B0aW9uKSA9PiBvcHRpb24udmFsdWUgPT09IHF1ZXJ5LmZvcm1hdCkgfHwgRk9STUFUX09QVElPTlNbMF07XG4gIGNvbnN0IHF1ZXJ5VHlwZVZhbHVlID0gZ2V0UXVlcnlUeXBlVmFsdWUocXVlcnkpO1xuICBjb25zdCBxdWVyeVR5cGVMYWJlbCA9IHF1ZXJ5VHlwZU9wdGlvbnMuZmluZCgoeCkgPT4geC52YWx1ZSA9PT0gcXVlcnlUeXBlVmFsdWUpIS5sYWJlbDtcblxuICByZXR1cm4gKFxuICAgIDxFZGl0b3JSb3c+XG4gICAgICA8UXVlcnlPcHRpb25Hcm91cCB0aXRsZT1cIk9wdGlvbnNcIiBjb2xsYXBzZWRJbmZvPXtnZXRDb2xsYXBzZWRJbmZvKHF1ZXJ5LCBmb3JtYXRPcHRpb24ubGFiZWwhLCBxdWVyeVR5cGVMYWJlbCl9PlxuICAgICAgICA8UHJvbVF1ZXJ5TGVnZW5kRWRpdG9yXG4gICAgICAgICAgbGVnZW5kRm9ybWF0PXtxdWVyeS5sZWdlbmRGb3JtYXR9XG4gICAgICAgICAgb25DaGFuZ2U9eyhsZWdlbmRGb3JtYXQpID0+IG9uQ2hhbmdlKHsgLi4ucXVlcnksIGxlZ2VuZEZvcm1hdCB9KX1cbiAgICAgICAgICBvblJ1blF1ZXJ5PXtvblJ1blF1ZXJ5fVxuICAgICAgICAvPlxuICAgICAgICA8RWRpdG9yRmllbGRcbiAgICAgICAgICBsYWJlbD1cIk1pbiBzdGVwXCJcbiAgICAgICAgICB0b29sdGlwPXtcbiAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgIEFuIGFkZGl0aW9uYWwgbG93ZXIgbGltaXQgZm9yIHRoZSBzdGVwIHBhcmFtZXRlciBvZiB0aGUgUHJvbWV0aGV1cyBxdWVyeSBhbmQgZm9yIHRoZXsnICd9XG4gICAgICAgICAgICAgIDxjb2RlPiRfX2ludGVydmFsPC9jb2RlPiBhbmQgPGNvZGU+JF9fcmF0ZV9pbnRlcnZhbDwvY29kZT4gdmFyaWFibGVzLlxuICAgICAgICAgICAgPC8+XG4gICAgICAgICAgfVxuICAgICAgICA+XG4gICAgICAgICAgPEF1dG9TaXplSW5wdXRcbiAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgIGFyaWEtbGFiZWw9XCJTZXQgbG93ZXIgbGltaXQgZm9yIHRoZSBzdGVwIHBhcmFtZXRlclwiXG4gICAgICAgICAgICBwbGFjZWhvbGRlcj17J2F1dG8nfVxuICAgICAgICAgICAgbWluV2lkdGg9ezEwfVxuICAgICAgICAgICAgb25Db21taXRDaGFuZ2U9e29uQ2hhbmdlU3RlcH1cbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZT17cXVlcnkuaW50ZXJ2YWx9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9FZGl0b3JGaWVsZD5cbiAgICAgICAgPEVkaXRvckZpZWxkIGxhYmVsPVwiRm9ybWF0XCI+XG4gICAgICAgICAgPFNlbGVjdCB2YWx1ZT17Zm9ybWF0T3B0aW9ufSBhbGxvd0N1c3RvbVZhbHVlIG9uQ2hhbmdlPXtvbkNoYW5nZUZvcm1hdH0gb3B0aW9ucz17Rk9STUFUX09QVElPTlN9IC8+XG4gICAgICAgIDwvRWRpdG9yRmllbGQ+XG4gICAgICAgIDxFZGl0b3JGaWVsZCBsYWJlbD1cIlR5cGVcIj5cbiAgICAgICAgICA8UmFkaW9CdXR0b25Hcm91cCBvcHRpb25zPXtxdWVyeVR5cGVPcHRpb25zfSB2YWx1ZT17cXVlcnlUeXBlVmFsdWV9IG9uQ2hhbmdlPXtvblF1ZXJ5VHlwZUNoYW5nZX0gLz5cbiAgICAgICAgPC9FZGl0b3JGaWVsZD5cbiAgICAgICAge3Nob3VsZFNob3dFeGVtcGxhclN3aXRjaChxdWVyeSwgYXBwKSAmJiAoXG4gICAgICAgICAgPEVkaXRvckZpZWxkIGxhYmVsPVwiRXhlbXBsYXJzXCI+XG4gICAgICAgICAgICA8RWRpdG9yU3dpdGNoIHZhbHVlPXtxdWVyeS5leGVtcGxhcn0gb25DaGFuZ2U9e29uRXhlbXBsYXJDaGFuZ2V9IC8+XG4gICAgICAgICAgPC9FZGl0b3JGaWVsZD5cbiAgICAgICAgKX1cbiAgICAgICAge3F1ZXJ5LmludGVydmFsRmFjdG9yICYmIHF1ZXJ5LmludGVydmFsRmFjdG9yID4gMSAmJiAoXG4gICAgICAgICAgPEVkaXRvckZpZWxkIGxhYmVsPVwiUmVzb2x1dGlvblwiPlxuICAgICAgICAgICAgPFNlbGVjdFxuICAgICAgICAgICAgICBhcmlhLWxhYmVsPVwiU2VsZWN0IHJlc29sdXRpb25cIlxuICAgICAgICAgICAgICBpc1NlYXJjaGFibGU9e2ZhbHNlfVxuICAgICAgICAgICAgICBvcHRpb25zPXtJTlRFUlZBTF9GQUNUT1JfT1BUSU9OU31cbiAgICAgICAgICAgICAgb25DaGFuZ2U9e29uSW50ZXJ2YWxGYWN0b3JDaGFuZ2V9XG4gICAgICAgICAgICAgIHZhbHVlPXtJTlRFUlZBTF9GQUNUT1JfT1BUSU9OUy5maW5kKChvcHRpb24pID0+IG9wdGlvbi52YWx1ZSA9PT0gcXVlcnkuaW50ZXJ2YWxGYWN0b3IpfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L0VkaXRvckZpZWxkPlxuICAgICAgICApfVxuICAgICAgPC9RdWVyeU9wdGlvbkdyb3VwPlxuICAgIDwvRWRpdG9yUm93PlxuICApO1xufSk7XG5cbmZ1bmN0aW9uIHNob3VsZFNob3dFeGVtcGxhclN3aXRjaChxdWVyeTogUHJvbVF1ZXJ5LCBhcHA/OiBDb3JlQXBwKSB7XG4gIGlmIChhcHAgPT09IENvcmVBcHAuVW5pZmllZEFsZXJ0aW5nIHx8ICFxdWVyeS5yYW5nZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBnZXRRdWVyeVR5cGVWYWx1ZShxdWVyeTogUHJvbVF1ZXJ5KSB7XG4gIHJldHVybiBxdWVyeS5yYW5nZSAmJiBxdWVyeS5pbnN0YW50ID8gJ2JvdGgnIDogcXVlcnkuaW5zdGFudCA/ICdpbnN0YW50JyA6ICdyYW5nZSc7XG59XG5cbmZ1bmN0aW9uIGdldENvbGxhcHNlZEluZm8ocXVlcnk6IFByb21RdWVyeSwgZm9ybWF0T3B0aW9uOiBzdHJpbmcsIHF1ZXJ5VHlwZTogc3RyaW5nKTogc3RyaW5nW10ge1xuICBjb25zdCBpdGVtczogc3RyaW5nW10gPSBbXTtcblxuICBpdGVtcy5wdXNoKGBMZWdlbmQ6ICR7Z2V0TGVnZW5kTW9kZUxhYmVsKHF1ZXJ5LmxlZ2VuZEZvcm1hdCl9YCk7XG4gIGl0ZW1zLnB1c2goYEZvcm1hdDogJHtmb3JtYXRPcHRpb259YCk7XG5cbiAgaWYgKHF1ZXJ5LmludGVydmFsKSB7XG4gICAgaXRlbXMucHVzaChgU3RlcCAke3F1ZXJ5LmludGVydmFsfWApO1xuICB9XG5cbiAgaXRlbXMucHVzaChgVHlwZTogJHtxdWVyeVR5cGV9YCk7XG5cbiAgaWYgKHF1ZXJ5LmV4ZW1wbGFyKSB7XG4gICAgaXRlbXMucHVzaChgRXhlbXBsYXJzOiB0cnVlYCk7XG4gIH1cblxuICByZXR1cm4gaXRlbXM7XG59XG5cblByb21RdWVyeUJ1aWxkZXJPcHRpb25zLmRpc3BsYXlOYW1lID0gJ1Byb21RdWVyeUJ1aWxkZXJPcHRpb25zJztcbiIsImltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBHcmFmYW5hVGhlbWUyIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyB1c2VTdHlsZXMyIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5pbXBvcnQgeyB0ZXN0SWRzIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy9Qcm9tUXVlcnlFZGl0b3InO1xuaW1wb3J0IFByb21RdWVyeUZpZWxkIGZyb20gJy4uLy4uL2NvbXBvbmVudHMvUHJvbVF1ZXJ5RmllbGQnO1xuaW1wb3J0IHsgUHJvbVF1ZXJ5RWRpdG9yUHJvcHMgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL3R5cGVzJztcblxuZXhwb3J0IGZ1bmN0aW9uIFByb21RdWVyeUNvZGVFZGl0b3Ioe1xuICBxdWVyeSxcbiAgZGF0YXNvdXJjZSxcbiAgcmFuZ2UsXG4gIG9uUnVuUXVlcnksXG4gIG9uQ2hhbmdlLFxuICBkYXRhLFxuICBhcHAsXG59OiBQcm9tUXVlcnlFZGl0b3JQcm9wcykge1xuICBjb25zdCBzdHlsZXMgPSB1c2VTdHlsZXMyKGdldFN0eWxlcyk7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLndyYXBwZXJ9PlxuICAgICAgPFByb21RdWVyeUZpZWxkXG4gICAgICAgIGRhdGFzb3VyY2U9e2RhdGFzb3VyY2V9XG4gICAgICAgIHF1ZXJ5PXtxdWVyeX1cbiAgICAgICAgcmFuZ2U9e3JhbmdlfVxuICAgICAgICBvblJ1blF1ZXJ5PXtvblJ1blF1ZXJ5fVxuICAgICAgICBvbkNoYW5nZT17b25DaGFuZ2V9XG4gICAgICAgIGhpc3Rvcnk9e1tdfVxuICAgICAgICBkYXRhPXtkYXRhfVxuICAgICAgICBkYXRhLXRlc3RpZD17dGVzdElkcy5lZGl0b3J9XG4gICAgICAgIGFwcD17YXBwfVxuICAgICAgLz5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuY29uc3QgZ2V0U3R5bGVzID0gKHRoZW1lOiBHcmFmYW5hVGhlbWUyKSA9PiB7XG4gIHJldHVybiB7XG4gICAgLy8gVGhpcyB3cmFwcGVyIHN0eWxpbmcgY2FuIGJlIHJlbW92ZWQgYWZ0ZXIgdGhlIG9sZCBQcm9tUXVlcnlFZGl0b3IgaXMgcmVtb3ZlZC5cbiAgICAvLyBUaGlzIGlzIHJlbW92aW5nIG1hcmdpbiBib3R0b20gb24gdGhlIG9sZCBsZWdhY3kgaW5saW5lIGZvcm0gc3R5bGVzXG4gICAgd3JhcHBlcjogY3NzYFxuICAgICAgLmdmLWZvcm0ge1xuICAgICAgICBtYXJnaW4tYm90dG9tOiAwO1xuICAgICAgfVxuICAgIGAsXG4gIH07XG59O1xuIiwiaW1wb3J0IFJlYWN0LCB7IFN5bnRoZXRpY0V2ZW50LCB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgTG9hZGluZ1N0YXRlIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBFZGl0b3JIZWFkZXIsIEVkaXRvclJvd3MsIEZsZXhJdGVtLCBJbmxpbmVTZWxlY3QsIFNwYWNlIH0gZnJvbSAnQGdyYWZhbmEvZXhwZXJpbWVudGFsJztcbmltcG9ydCB7IHJlcG9ydEludGVyYWN0aW9uIH0gZnJvbSAnQGdyYWZhbmEvcnVudGltZSc7XG5pbXBvcnQgeyBCdXR0b24sIENvbmZpcm1Nb2RhbCB9IGZyb20gJ0BncmFmYW5hL3VpJztcblxuaW1wb3J0IHsgUHJvbVF1ZXJ5RWRpdG9yUHJvcHMgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL3R5cGVzJztcbmltcG9ydCB7IFByb21RdWVyeSB9IGZyb20gJy4uLy4uL3R5cGVzJztcbmltcG9ydCB7IHByb21RdWVyeU1vZGVsbGVyIH0gZnJvbSAnLi4vUHJvbVF1ZXJ5TW9kZWxsZXInO1xuaW1wb3J0IHsgYnVpbGRWaXN1YWxRdWVyeUZyb21TdHJpbmcgfSBmcm9tICcuLi9wYXJzaW5nJztcbmltcG9ydCB7IEZlZWRiYWNrTGluayB9IGZyb20gJy4uL3NoYXJlZC9GZWVkYmFja0xpbmsnO1xuaW1wb3J0IHsgUXVlcnlFZGl0b3JNb2RlVG9nZ2xlIH0gZnJvbSAnLi4vc2hhcmVkL1F1ZXJ5RWRpdG9yTW9kZVRvZ2dsZSc7XG5pbXBvcnQgeyBRdWVyeUhlYWRlclN3aXRjaCB9IGZyb20gJy4uL3NoYXJlZC9RdWVyeUhlYWRlclN3aXRjaCc7XG5pbXBvcnQgeyBRdWVyeUVkaXRvck1vZGUgfSBmcm9tICcuLi9zaGFyZWQvdHlwZXMnO1xuaW1wb3J0IHsgY2hhbmdlRWRpdG9yTW9kZSwgZ2V0UXVlcnlXaXRoRGVmYXVsdHMgfSBmcm9tICcuLi9zdGF0ZSc7XG5cbmltcG9ydCB7IFByb21RdWVyeUJ1aWxkZXJDb250YWluZXIgfSBmcm9tICcuL1Byb21RdWVyeUJ1aWxkZXJDb250YWluZXInO1xuaW1wb3J0IHsgUHJvbVF1ZXJ5QnVpbGRlckV4cGxhaW5lZCB9IGZyb20gJy4vUHJvbVF1ZXJ5QnVpbGRlckV4cGxhaW5lZCc7XG5pbXBvcnQgeyBQcm9tUXVlcnlCdWlsZGVyT3B0aW9ucyB9IGZyb20gJy4vUHJvbVF1ZXJ5QnVpbGRlck9wdGlvbnMnO1xuaW1wb3J0IHsgUHJvbVF1ZXJ5Q29kZUVkaXRvciB9IGZyb20gJy4vUHJvbVF1ZXJ5Q29kZUVkaXRvcic7XG5cbmV4cG9ydCBjb25zdCBQcm9tUXVlcnlFZGl0b3JTZWxlY3RvciA9IFJlYWN0Lm1lbW88UHJvbVF1ZXJ5RWRpdG9yUHJvcHM+KChwcm9wcykgPT4ge1xuICBjb25zdCB7IG9uQ2hhbmdlLCBvblJ1blF1ZXJ5LCBkYXRhLCBhcHAgfSA9IHByb3BzO1xuICBjb25zdCBbcGFyc2VNb2RhbE9wZW4sIHNldFBhcnNlTW9kYWxPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2RhdGFJc1N0YWxlLCBzZXREYXRhSXNTdGFsZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgY29uc3QgcXVlcnkgPSBnZXRRdWVyeVdpdGhEZWZhdWx0cyhwcm9wcy5xdWVyeSwgYXBwKTtcbiAgY29uc3QgZWRpdG9yTW9kZSA9IHF1ZXJ5LmVkaXRvck1vZGUhO1xuXG4gIGNvbnN0IG9uRWRpdG9yTW9kZUNoYW5nZSA9IHVzZUNhbGxiYWNrKFxuICAgIChuZXdNZXRyaWNFZGl0b3JNb2RlOiBRdWVyeUVkaXRvck1vZGUpID0+IHtcbiAgICAgIHJlcG9ydEludGVyYWN0aW9uKCd1c2VyX2dyYWZhbmFfcHJvbWV0aGV1c19lZGl0b3JfbW9kZV9jbGlja2VkJywge1xuICAgICAgICBuZXdFZGl0b3I6IG5ld01ldHJpY0VkaXRvck1vZGUsXG4gICAgICAgIHByZXZpb3VzRWRpdG9yOiBxdWVyeS5lZGl0b3JNb2RlID8/ICcnLFxuICAgICAgICBuZXdRdWVyeTogIXF1ZXJ5LmV4cHIsXG4gICAgICAgIGFwcDogYXBwID8/ICcnLFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChuZXdNZXRyaWNFZGl0b3JNb2RlID09PSBRdWVyeUVkaXRvck1vZGUuQnVpbGRlcikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBidWlsZFZpc3VhbFF1ZXJ5RnJvbVN0cmluZyhxdWVyeS5leHByIHx8ICcnKTtcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGVycm9ycywgZ2l2ZSB1c2VyIGEgY2hhbmNlIHRvIGRlY2lkZSBpZiB0aGV5IHdhbnQgdG8gZ28gdG8gYnVpbGRlciBhcyB0aGF0IGNhbiBsb29zZSBzb21lIGRhdGEuXG4gICAgICAgIGlmIChyZXN1bHQuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgIHNldFBhcnNlTW9kYWxPcGVuKHRydWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hhbmdlRWRpdG9yTW9kZShxdWVyeSwgbmV3TWV0cmljRWRpdG9yTW9kZSwgb25DaGFuZ2UpO1xuICAgIH0sXG4gICAgW29uQ2hhbmdlLCBxdWVyeSwgYXBwXVxuICApO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2V0RGF0YUlzU3RhbGUoZmFsc2UpO1xuICB9LCBbZGF0YV0pO1xuXG4gIGNvbnN0IG9uUXVlcnlQcmV2aWV3Q2hhbmdlID0gKGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IGlzRW5hYmxlZCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQuY2hlY2tlZDtcbiAgICBvbkNoYW5nZSh7IC4uLnF1ZXJ5LCByYXdRdWVyeTogaXNFbmFibGVkIH0pO1xuICB9O1xuXG4gIGNvbnN0IG9uQ2hhbmdlSW50ZXJuYWwgPSAocXVlcnk6IFByb21RdWVyeSkgPT4ge1xuICAgIHNldERhdGFJc1N0YWxlKHRydWUpO1xuICAgIG9uQ2hhbmdlKHF1ZXJ5KTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8Q29uZmlybU1vZGFsXG4gICAgICAgIGlzT3Blbj17cGFyc2VNb2RhbE9wZW59XG4gICAgICAgIHRpdGxlPVwiUXVlcnkgcGFyc2luZ1wiXG4gICAgICAgIGJvZHk9XCJUaGVyZSB3ZXJlIGVycm9ycyB3aGlsZSB0cnlpbmcgdG8gcGFyc2UgdGhlIHF1ZXJ5LiBDb250aW51aW5nIHRvIHZpc3VhbCBidWlsZGVyIG1heSBsb29zZSBzb21lIHBhcnRzIG9mIHRoZSBxdWVyeS5cIlxuICAgICAgICBjb25maXJtVGV4dD1cIkNvbnRpbnVlXCJcbiAgICAgICAgb25Db25maXJtPXsoKSA9PiB7XG4gICAgICAgICAgY2hhbmdlRWRpdG9yTW9kZShxdWVyeSwgUXVlcnlFZGl0b3JNb2RlLkJ1aWxkZXIsIG9uQ2hhbmdlKTtcbiAgICAgICAgICBzZXRQYXJzZU1vZGFsT3BlbihmYWxzZSk7XG4gICAgICAgIH19XG4gICAgICAgIG9uRGlzbWlzcz17KCkgPT4gc2V0UGFyc2VNb2RhbE9wZW4oZmFsc2UpfVxuICAgICAgLz5cbiAgICAgIDxFZGl0b3JIZWFkZXI+XG4gICAgICAgIHtlZGl0b3JNb2RlID09PSBRdWVyeUVkaXRvck1vZGUuQnVpbGRlciAmJiAoXG4gICAgICAgICAgPD5cbiAgICAgICAgICAgIDxJbmxpbmVTZWxlY3RcbiAgICAgICAgICAgICAgdmFsdWU9e251bGx9XG4gICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiUXVlcnkgcGF0dGVybnNcIlxuICAgICAgICAgICAgICBhbGxvd0N1c3RvbVZhbHVlXG4gICAgICAgICAgICAgIG9uQ2hhbmdlPXsoeyB2YWx1ZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogQml0IGNvbnZvbHV0ZWQgYXMgd2UgZG9uJ3QgaGF2ZSBhY2Nlc3MgdG8gdmlzdWFsUXVlcnkgbW9kZWwgaGVyZS4gTWF5YmUgd291bGQgbWFrZSBzZW5zZSB0b1xuICAgICAgICAgICAgICAgIC8vICBtb3ZlIGl0IGluc2lkZSB0aGUgZWRpdG9yP1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGJ1aWxkVmlzdWFsUXVlcnlGcm9tU3RyaW5nKHF1ZXJ5LmV4cHIgfHwgJycpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5xdWVyeS5vcGVyYXRpb25zID0gdmFsdWU/Lm9wZXJhdGlvbnMhO1xuICAgICAgICAgICAgICAgIG9uQ2hhbmdlKHtcbiAgICAgICAgICAgICAgICAgIC4uLnF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgZXhwcjogcHJvbVF1ZXJ5TW9kZWxsZXIucmVuZGVyUXVlcnkocmVzdWx0LnF1ZXJ5KSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgb3B0aW9ucz17cHJvbVF1ZXJ5TW9kZWxsZXIuZ2V0UXVlcnlQYXR0ZXJucygpLm1hcCgoeCkgPT4gKHsgbGFiZWw6IHgubmFtZSwgdmFsdWU6IHggfSkpfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxRdWVyeUhlYWRlclN3aXRjaCBsYWJlbD1cIlJhdyBxdWVyeVwiIHZhbHVlPXtxdWVyeS5yYXdRdWVyeX0gb25DaGFuZ2U9e29uUXVlcnlQcmV2aWV3Q2hhbmdlfSAvPlxuICAgICAgICAgIDwvPlxuICAgICAgICApfVxuICAgICAgICB7ZWRpdG9yTW9kZSA9PT0gUXVlcnlFZGl0b3JNb2RlLkJ1aWxkZXIgJiYgKFxuICAgICAgICAgIDxGZWVkYmFja0xpbmsgZmVlZGJhY2tVcmw9XCJodHRwczovL2dpdGh1Yi5jb20vZ3JhZmFuYS9ncmFmYW5hL2Rpc2N1c3Npb25zLzQ3NjkzXCIgLz5cbiAgICAgICAgKX1cbiAgICAgICAgPEZsZXhJdGVtIGdyb3c9ezF9IC8+XG4gICAgICAgIDxCdXR0b25cbiAgICAgICAgICB2YXJpYW50PXtkYXRhSXNTdGFsZSA/ICdwcmltYXJ5JyA6ICdzZWNvbmRhcnknfVxuICAgICAgICAgIHNpemU9XCJzbVwiXG4gICAgICAgICAgb25DbGljaz17b25SdW5RdWVyeX1cbiAgICAgICAgICBpY29uPXtkYXRhPy5zdGF0ZSA9PT0gTG9hZGluZ1N0YXRlLkxvYWRpbmcgPyAnZmEgZmEtc3Bpbm5lcicgOiB1bmRlZmluZWR9XG4gICAgICAgICAgZGlzYWJsZWQ9e2RhdGE/LnN0YXRlID09PSBMb2FkaW5nU3RhdGUuTG9hZGluZ31cbiAgICAgICAgPlxuICAgICAgICAgIFJ1biBxdWVyeVxuICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgPFF1ZXJ5RWRpdG9yTW9kZVRvZ2dsZSBtb2RlPXtlZGl0b3JNb2RlfSBvbkNoYW5nZT17b25FZGl0b3JNb2RlQ2hhbmdlfSAvPlxuICAgICAgPC9FZGl0b3JIZWFkZXI+XG4gICAgICA8U3BhY2Ugdj17MC41fSAvPlxuICAgICAgPEVkaXRvclJvd3M+XG4gICAgICAgIHtlZGl0b3JNb2RlID09PSBRdWVyeUVkaXRvck1vZGUuQ29kZSAmJiA8UHJvbVF1ZXJ5Q29kZUVkaXRvciB7Li4ucHJvcHN9IC8+fVxuICAgICAgICB7ZWRpdG9yTW9kZSA9PT0gUXVlcnlFZGl0b3JNb2RlLkJ1aWxkZXIgJiYgKFxuICAgICAgICAgIDxQcm9tUXVlcnlCdWlsZGVyQ29udGFpbmVyXG4gICAgICAgICAgICBxdWVyeT17cXVlcnl9XG4gICAgICAgICAgICBkYXRhc291cmNlPXtwcm9wcy5kYXRhc291cmNlfVxuICAgICAgICAgICAgb25DaGFuZ2U9e29uQ2hhbmdlSW50ZXJuYWx9XG4gICAgICAgICAgICBvblJ1blF1ZXJ5PXtwcm9wcy5vblJ1blF1ZXJ5fVxuICAgICAgICAgICAgZGF0YT17ZGF0YX1cbiAgICAgICAgICAvPlxuICAgICAgICApfVxuICAgICAgICB7ZWRpdG9yTW9kZSA9PT0gUXVlcnlFZGl0b3JNb2RlLkV4cGxhaW4gJiYgPFByb21RdWVyeUJ1aWxkZXJFeHBsYWluZWQgcXVlcnk9e3F1ZXJ5LmV4cHJ9IC8+fVxuICAgICAgICB7ZWRpdG9yTW9kZSAhPT0gUXVlcnlFZGl0b3JNb2RlLkV4cGxhaW4gJiYgKFxuICAgICAgICAgIDxQcm9tUXVlcnlCdWlsZGVyT3B0aW9ucyBxdWVyeT17cXVlcnl9IGFwcD17cHJvcHMuYXBwfSBvbkNoYW5nZT17b25DaGFuZ2V9IG9uUnVuUXVlcnk9e29uUnVuUXVlcnl9IC8+XG4gICAgICAgICl9XG4gICAgICA8L0VkaXRvclJvd3M+XG4gICAgPC8+XG4gICk7XG59KTtcblxuUHJvbVF1ZXJ5RWRpdG9yU2VsZWN0b3IuZGlzcGxheU5hbWUgPSAnUHJvbVF1ZXJ5RWRpdG9yU2VsZWN0b3InO1xuIiwiaW1wb3J0IFJlYWN0LCB7IHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgU2VsZWN0YWJsZVZhbHVlIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBFZGl0b3JGaWVsZCB9IGZyb20gJ0BncmFmYW5hL2V4cGVyaW1lbnRhbCc7XG5pbXBvcnQgeyBTZWxlY3QgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5cbmltcG9ydCB7IExlZ2VuZEZvcm1hdE1vZGUgfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQgeyBBdXRvU2l6ZUlucHV0IH0gZnJvbSAnLi4vc2hhcmVkL0F1dG9TaXplSW5wdXQnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgbGVnZW5kRm9ybWF0OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIG9uQ2hhbmdlOiAobGVnZW5kRm9ybWF0OiBzdHJpbmcpID0+IHZvaWQ7XG4gIG9uUnVuUXVlcnk6ICgpID0+IHZvaWQ7XG59XG5cbmNvbnN0IGxlZ2VuZE1vZGVPcHRpb25zID0gW1xuICB7XG4gICAgbGFiZWw6ICdBdXRvJyxcbiAgICB2YWx1ZTogTGVnZW5kRm9ybWF0TW9kZS5BdXRvLFxuICAgIGRlc2NyaXB0aW9uOiAnT25seSBpbmNsdWRlcyB1bmlxdWUgbGFiZWxzJyxcbiAgfSxcbiAgeyBsYWJlbDogJ1ZlcmJvc2UnLCB2YWx1ZTogTGVnZW5kRm9ybWF0TW9kZS5WZXJib3NlLCBkZXNjcmlwdGlvbjogJ0FsbCBsYWJlbCBuYW1lcyBhbmQgdmFsdWVzJyB9LFxuICB7IGxhYmVsOiAnQ3VzdG9tJywgdmFsdWU6IExlZ2VuZEZvcm1hdE1vZGUuQ3VzdG9tLCBkZXNjcmlwdGlvbjogJ1Byb3ZpZGUgYSBuYW1pbmcgdGVtcGxhdGUnIH0sXG5dO1xuXG4vKipcbiAqIFRlc3RzIGZvciB0aGlzIGNvbXBvbmVudCBhcmUgb24gdGhlIHBhcmVudCBsZXZlbCAoUHJvbVF1ZXJ5QnVpbGRlck9wdGlvbnMpLlxuICovXG5leHBvcnQgY29uc3QgUHJvbVF1ZXJ5TGVnZW5kRWRpdG9yID0gUmVhY3QubWVtbzxQcm9wcz4oKHsgbGVnZW5kRm9ybWF0LCBvbkNoYW5nZSwgb25SdW5RdWVyeSB9KSA9PiB7XG4gIGNvbnN0IG1vZGUgPSBnZXRMZWdlbmRNb2RlKGxlZ2VuZEZvcm1hdCk7XG4gIGNvbnN0IGlucHV0UmVmID0gdXNlUmVmPEhUTUxJbnB1dEVsZW1lbnQgfCBudWxsPihudWxsKTtcblxuICBjb25zdCBvbkxlZ2VuZEZvcm1hdENoYW5nZWQgPSAoZXZ0OiBSZWFjdC5Gb3JtRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcbiAgICBsZXQgbmV3Rm9ybWF0ID0gZXZ0LmN1cnJlbnRUYXJnZXQudmFsdWU7XG4gICAgaWYgKG5ld0Zvcm1hdC5sZW5ndGggPT09IDApIHtcbiAgICAgIG5ld0Zvcm1hdCA9IExlZ2VuZEZvcm1hdE1vZGUuQXV0bztcbiAgICB9XG5cbiAgICBpZiAobmV3Rm9ybWF0ICE9PSBsZWdlbmRGb3JtYXQpIHtcbiAgICAgIG9uQ2hhbmdlKG5ld0Zvcm1hdCk7XG4gICAgICBvblJ1blF1ZXJ5KCk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IG9uTGVnZW5kTW9kZUNoYW5nZWQgPSAodmFsdWU6IFNlbGVjdGFibGVWYWx1ZTxMZWdlbmRGb3JtYXRNb2RlPikgPT4ge1xuICAgIHN3aXRjaCAodmFsdWUudmFsdWUhKSB7XG4gICAgICBjYXNlIExlZ2VuZEZvcm1hdE1vZGUuQXV0bzpcbiAgICAgICAgb25DaGFuZ2UoTGVnZW5kRm9ybWF0TW9kZS5BdXRvKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIExlZ2VuZEZvcm1hdE1vZGUuQ3VzdG9tOlxuICAgICAgICBvbkNoYW5nZSgne3tsYWJlbF9uYW1lfX0nKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaW5wdXRSZWYuY3VycmVudD8uZm9jdXMoKTtcbiAgICAgICAgICBpbnB1dFJlZi5jdXJyZW50Py5zZXRTZWxlY3Rpb25SYW5nZSgyLCAxMiwgJ2ZvcndhcmQnKTtcbiAgICAgICAgfSwgMTApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTGVnZW5kRm9ybWF0TW9kZS5WZXJib3NlOlxuICAgICAgICBvbkNoYW5nZSgnJyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvblJ1blF1ZXJ5KCk7XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8RWRpdG9yRmllbGRcbiAgICAgIGxhYmVsPVwiTGVnZW5kXCJcbiAgICAgIHRvb2x0aXA9XCJTZXJpZXMgbmFtZSBvdmVycmlkZSBvciB0ZW1wbGF0ZS4gRXguIHt7aG9zdG5hbWV9fSB3aWxsIGJlIHJlcGxhY2VkIHdpdGggbGFiZWwgdmFsdWUgZm9yIGhvc3RuYW1lLlwiXG4gICAgPlxuICAgICAgPD5cbiAgICAgICAge21vZGUgPT09IExlZ2VuZEZvcm1hdE1vZGUuQ3VzdG9tICYmIChcbiAgICAgICAgICA8QXV0b1NpemVJbnB1dFxuICAgICAgICAgICAgaWQ9XCJsZWdlbmRGb3JtYXRcIlxuICAgICAgICAgICAgbWluV2lkdGg9ezIyfVxuICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJhdXRvXCJcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZT17bGVnZW5kRm9ybWF0fVxuICAgICAgICAgICAgb25Db21taXRDaGFuZ2U9e29uTGVnZW5kRm9ybWF0Q2hhbmdlZH1cbiAgICAgICAgICAgIHJlZj17aW5wdXRSZWZ9XG4gICAgICAgICAgLz5cbiAgICAgICAgKX1cbiAgICAgICAge21vZGUgIT09IExlZ2VuZEZvcm1hdE1vZGUuQ3VzdG9tICYmIChcbiAgICAgICAgICA8U2VsZWN0XG4gICAgICAgICAgICBpbnB1dElkPVwibGVnZW5kLm1vZGVcIlxuICAgICAgICAgICAgaXNTZWFyY2hhYmxlPXtmYWxzZX1cbiAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiU2VsZWN0IGxlZ2VuZCBtb2RlXCJcbiAgICAgICAgICAgIG9wdGlvbnM9e2xlZ2VuZE1vZGVPcHRpb25zfVxuICAgICAgICAgICAgd2lkdGg9ezIyfVxuICAgICAgICAgICAgb25DaGFuZ2U9e29uTGVnZW5kTW9kZUNoYW5nZWR9XG4gICAgICAgICAgICB2YWx1ZT17bGVnZW5kTW9kZU9wdGlvbnMuZmluZCgoeCkgPT4geC52YWx1ZSA9PT0gbW9kZSl9XG4gICAgICAgICAgLz5cbiAgICAgICAgKX1cbiAgICAgIDwvPlxuICAgIDwvRWRpdG9yRmllbGQ+XG4gICk7XG59KTtcblxuUHJvbVF1ZXJ5TGVnZW5kRWRpdG9yLmRpc3BsYXlOYW1lID0gJ1Byb21RdWVyeUxlZ2VuZEVkaXRvcic7XG5cbmZ1bmN0aW9uIGdldExlZ2VuZE1vZGUobGVnZW5kRm9ybWF0OiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgLy8gVGhpcyBzcGVjaWFsIHZhbHVlIG1lYW5zIHRoZSBuZXcgc21hcnQgbWluaW1hbCBzZXJpZXMgbmFtaW5nXG4gIGlmIChsZWdlbmRGb3JtYXQgPT09IExlZ2VuZEZvcm1hdE1vZGUuQXV0bykge1xuICAgIHJldHVybiBMZWdlbmRGb3JtYXRNb2RlLkF1dG87XG4gIH1cblxuICAvLyBNaXNzaW5nIG9yIGVtcHR5IGxlZ2VuZCBmb3JtYXQgaXMgdGhlIG9sZCB2ZXJib3NlIGJlaGF2aW9yXG4gIGlmIChsZWdlbmRGb3JtYXQgPT0gbnVsbCB8fCBsZWdlbmRGb3JtYXQgPT09ICcnKSB7XG4gICAgcmV0dXJuIExlZ2VuZEZvcm1hdE1vZGUuVmVyYm9zZTtcbiAgfVxuXG4gIHJldHVybiBMZWdlbmRGb3JtYXRNb2RlLkN1c3RvbTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldExlZ2VuZE1vZGVMYWJlbChsZWdlbmRGb3JtYXQ6IHN0cmluZyB8IHVuZGVmaW5lZCkge1xuICBjb25zdCBtb2RlID0gZ2V0TGVnZW5kTW9kZShsZWdlbmRGb3JtYXQpO1xuICBpZiAobW9kZSAhPT0gTGVnZW5kRm9ybWF0TW9kZS5DdXN0b20pIHtcbiAgICByZXR1cm4gbGVnZW5kTW9kZU9wdGlvbnMuZmluZCgoeCkgPT4geC52YWx1ZSA9PT0gbW9kZSk/LmxhYmVsO1xuICB9XG4gIHJldHVybiBsZWdlbmRGb3JtYXQ7XG59XG4iLCJpbXBvcnQgeyBjc3MsIGN4IH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCBQcmlzbSBmcm9tICdwcmlzbWpzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IEdyYWZhbmFUaGVtZTIgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IEVkaXRvckZpZWxkLCBFZGl0b3JGaWVsZEdyb3VwLCBFZGl0b3JSb3cgfSBmcm9tICdAZ3JhZmFuYS9leHBlcmltZW50YWwnO1xuaW1wb3J0IHsgdXNlVGhlbWUyIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5pbXBvcnQgeyBwcm9tcWxHcmFtbWFyIH0gZnJvbSAnLi4vLi4vcHJvbXFsJztcblxuZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gIHF1ZXJ5OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBRdWVyeVByZXZpZXcoeyBxdWVyeSB9OiBQcm9wcykge1xuICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lMigpO1xuICBjb25zdCBzdHlsZXMgPSBnZXRTdHlsZXModGhlbWUpO1xuICBjb25zdCBoaWdobGlnaHRlZCA9IFByaXNtLmhpZ2hsaWdodChxdWVyeSwgcHJvbXFsR3JhbW1hciwgJ3Byb21xbCcpO1xuXG4gIHJldHVybiAoXG4gICAgPEVkaXRvclJvdz5cbiAgICAgIDxFZGl0b3JGaWVsZEdyb3VwPlxuICAgICAgICA8RWRpdG9yRmllbGQgbGFiZWw9XCJSYXcgcXVlcnlcIj5cbiAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICBjbGFzc05hbWU9e2N4KHN0eWxlcy5lZGl0b3JGaWVsZCwgJ3ByaXNtLXN5bnRheC1oaWdobGlnaHQnKX1cbiAgICAgICAgICAgIGFyaWEtbGFiZWw9XCJzZWxlY3RvclwiXG4gICAgICAgICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTD17eyBfX2h0bWw6IGhpZ2hsaWdodGVkIH19XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9FZGl0b3JGaWVsZD5cbiAgICAgIDwvRWRpdG9yRmllbGRHcm91cD5cbiAgICA8L0VkaXRvclJvdz5cbiAgKTtcbn1cblxuY29uc3QgZ2V0U3R5bGVzID0gKHRoZW1lOiBHcmFmYW5hVGhlbWUyKSA9PiB7XG4gIHJldHVybiB7XG4gICAgZWRpdG9yRmllbGQ6IGNzcyh7XG4gICAgICBmb250RmFtaWx5OiB0aGVtZS50eXBvZ3JhcGh5LmZvbnRGYW1pbHlNb25vc3BhY2UsXG4gICAgICBmb250U2l6ZTogdGhlbWUudHlwb2dyYXBoeS5ib2R5U21hbGwuZm9udFNpemUsXG4gICAgfSksXG4gIH07XG59O1xuIiwiaW1wb3J0IHsgYmluYXJ5U2NhbGFyT3BlcmF0aW9ucyB9IGZyb20gJy4vYmluYXJ5U2NhbGFyT3BlcmF0aW9ucyc7XG5pbXBvcnQgeyBMYWJlbFBhcmFtRWRpdG9yIH0gZnJvbSAnLi9jb21wb25lbnRzL0xhYmVsUGFyYW1FZGl0b3InO1xuaW1wb3J0IHtcbiAgZGVmYXVsdEFkZE9wZXJhdGlvbkhhbmRsZXIsXG4gIGZ1bmN0aW9uUmVuZGVyZXJMZWZ0LFxuICBmdW5jdGlvblJlbmRlcmVyUmlnaHQsXG4gIGdldFByb21BbmRMb2tpT3BlcmF0aW9uRGlzcGxheU5hbWUsXG4gIGdldFJhbmdlVmVjdG9yUGFyYW1EZWYsXG4gIHJhbmdlUmVuZGVyZXJMZWZ0V2l0aFBhcmFtcyxcbiAgcmFuZ2VSZW5kZXJlclJpZ2h0V2l0aFBhcmFtcyxcbn0gZnJvbSAnLi9zaGFyZWQvb3BlcmF0aW9uVXRpbHMnO1xuaW1wb3J0IHtcbiAgUXVlcnlCdWlsZGVyT3BlcmF0aW9uLFxuICBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsXG4gIFF1ZXJ5V2l0aE9wZXJhdGlvbnMsXG4gIFZpc3VhbFF1ZXJ5TW9kZWxsZXIsXG59IGZyb20gJy4vc2hhcmVkL3R5cGVzJztcbmltcG9ydCB7IFByb21PcGVyYXRpb25JZCwgUHJvbVZpc3VhbFF1ZXJ5LCBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeSB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0T3BlcmF0aW9uRGVmaW5pdGlvbnMoKTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmW10ge1xuICBjb25zdCBsaXN0OiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWZbXSA9IFtcbiAgICB7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLkhpc3RvZ3JhbVF1YW50aWxlLFxuICAgICAgbmFtZTogJ0hpc3RvZ3JhbSBxdWFudGlsZScsXG4gICAgICBwYXJhbXM6IFt7IG5hbWU6ICdRdWFudGlsZScsIHR5cGU6ICdudW1iZXInLCBvcHRpb25zOiBbMC45OSwgMC45NSwgMC45LCAwLjc1LCAwLjUsIDAuMjVdIH1dLFxuICAgICAgZGVmYXVsdFBhcmFtczogWzAuOV0sXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuRnVuY3Rpb25zLFxuICAgICAgcmVuZGVyZXI6IGZ1bmN0aW9uUmVuZGVyZXJMZWZ0LFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogZGVmYXVsdEFkZE9wZXJhdGlvbkhhbmRsZXIsXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLkxhYmVsUmVwbGFjZSxcbiAgICAgIG5hbWU6ICdMYWJlbCByZXBsYWNlJyxcbiAgICAgIHBhcmFtczogW1xuICAgICAgICB7IG5hbWU6ICdEZXN0aW5hdGlvbiBsYWJlbCcsIHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICAgIHsgbmFtZTogJ1JlcGxhY2VtZW50JywgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgeyBuYW1lOiAnU291cmNlIGxhYmVsJywgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgeyBuYW1lOiAnUmVnZXgnLCB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgXSxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5GdW5jdGlvbnMsXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbJycsICckMScsICcnLCAnKC4qKSddLFxuICAgICAgcmVuZGVyZXI6IGZ1bmN0aW9uUmVuZGVyZXJSaWdodCxcbiAgICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGRlZmF1bHRBZGRPcGVyYXRpb25IYW5kbGVyLFxuICAgIH0sXG4gICAge1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5MbixcbiAgICAgIG5hbWU6ICdMbicsXG4gICAgICBwYXJhbXM6IFtdLFxuICAgICAgZGVmYXVsdFBhcmFtczogW10sXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuRnVuY3Rpb25zLFxuICAgICAgcmVuZGVyZXI6IGZ1bmN0aW9uUmVuZGVyZXJMZWZ0LFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogZGVmYXVsdEFkZE9wZXJhdGlvbkhhbmRsZXIsXG4gICAgfSxcbiAgICBjcmVhdGVSYW5nZUZ1bmN0aW9uKFByb21PcGVyYXRpb25JZC5DaGFuZ2VzKSxcbiAgICBjcmVhdGVSYW5nZUZ1bmN0aW9uKFByb21PcGVyYXRpb25JZC5SYXRlLCB0cnVlKSxcbiAgICBjcmVhdGVSYW5nZUZ1bmN0aW9uKFByb21PcGVyYXRpb25JZC5JcmF0ZSksXG4gICAgY3JlYXRlUmFuZ2VGdW5jdGlvbihQcm9tT3BlcmF0aW9uSWQuSW5jcmVhc2UsIHRydWUpLFxuICAgIGNyZWF0ZVJhbmdlRnVuY3Rpb24oUHJvbU9wZXJhdGlvbklkLklkZWx0YSksXG4gICAgY3JlYXRlUmFuZ2VGdW5jdGlvbihQcm9tT3BlcmF0aW9uSWQuRGVsdGEpLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuSG9sdFdpbnRlcnMsXG4gICAgICBwYXJhbXM6IFtcbiAgICAgICAgZ2V0UmFuZ2VWZWN0b3JQYXJhbURlZigpLFxuICAgICAgICB7IG5hbWU6ICdTbW9vdGhpbmcgRmFjdG9yJywgdHlwZTogJ251bWJlcicgfSxcbiAgICAgICAgeyBuYW1lOiAnVHJlbmQgRmFjdG9yJywgdHlwZTogJ251bWJlcicgfSxcbiAgICAgIF0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbJyRfX2ludGVydmFsJywgMC41LCAwLjVdLFxuICAgICAgYWx0ZXJuYXRpdmVzS2V5OiAncmFuZ2UgZnVuY3Rpb24nLFxuICAgICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlJhbmdlRnVuY3Rpb25zLFxuICAgICAgcmVuZGVyZXI6IHJhbmdlUmVuZGVyZXJSaWdodFdpdGhQYXJhbXMsXG4gICAgICBhZGRPcGVyYXRpb25IYW5kbGVyOiBhZGRPcGVyYXRpb25XaXRoUmFuZ2VWZWN0b3IsXG4gICAgICBjaGFuZ2VUeXBlSGFuZGxlcjogb3BlcmF0aW9uVHlwZUNoYW5nZWRIYW5kbGVyRm9yUmFuZ2VGdW5jdGlvbixcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLlByZWRpY3RMaW5lYXIsXG4gICAgICBwYXJhbXM6IFtnZXRSYW5nZVZlY3RvclBhcmFtRGVmKCksIHsgbmFtZTogJ1NlY29uZHMgZnJvbSBub3cnLCB0eXBlOiAnbnVtYmVyJyB9XSxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFsnJF9faW50ZXJ2YWwnLCA2MF0sXG4gICAgICBhbHRlcm5hdGl2ZXNLZXk6ICdyYW5nZSBmdW5jdGlvbicsXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuUmFuZ2VGdW5jdGlvbnMsXG4gICAgICByZW5kZXJlcjogcmFuZ2VSZW5kZXJlclJpZ2h0V2l0aFBhcmFtcyxcbiAgICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGFkZE9wZXJhdGlvbldpdGhSYW5nZVZlY3RvcixcbiAgICAgIGNoYW5nZVR5cGVIYW5kbGVyOiBvcGVyYXRpb25UeXBlQ2hhbmdlZEhhbmRsZXJGb3JSYW5nZUZ1bmN0aW9uLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuUXVhbnRpbGVPdmVyVGltZSxcbiAgICAgIHBhcmFtczogW2dldFJhbmdlVmVjdG9yUGFyYW1EZWYoKSwgeyBuYW1lOiAnUXVhbnRpbGUnLCB0eXBlOiAnbnVtYmVyJyB9XSxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFsnJF9faW50ZXJ2YWwnLCAwLjVdLFxuICAgICAgYWx0ZXJuYXRpdmVzS2V5OiAnb3ZlcnRpbWUgZnVuY3Rpb24nLFxuICAgICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlJhbmdlRnVuY3Rpb25zLFxuICAgICAgcmVuZGVyZXI6IHJhbmdlUmVuZGVyZXJMZWZ0V2l0aFBhcmFtcyxcbiAgICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGFkZE9wZXJhdGlvbldpdGhSYW5nZVZlY3RvcixcbiAgICAgIGNoYW5nZVR5cGVIYW5kbGVyOiBvcGVyYXRpb25UeXBlQ2hhbmdlZEhhbmRsZXJGb3JSYW5nZUZ1bmN0aW9uLFxuICAgIH0pLFxuICAgIC4uLmJpbmFyeVNjYWxhck9wZXJhdGlvbnMsXG4gICAge1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5OZXN0ZWRRdWVyeSxcbiAgICAgIG5hbWU6ICdCaW5hcnkgb3BlcmF0aW9uIHdpdGggcXVlcnknLFxuICAgICAgcGFyYW1zOiBbXSxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFtdLFxuICAgICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkJpbmFyeU9wcyxcbiAgICAgIHJlbmRlcmVyOiAobW9kZWwsIGRlZiwgaW5uZXJFeHByKSA9PiBpbm5lckV4cHIsXG4gICAgICBhZGRPcGVyYXRpb25IYW5kbGVyOiBhZGROZXN0ZWRRdWVyeUhhbmRsZXIsXG4gICAgfSxcbiAgICBjcmVhdGVGdW5jdGlvbih7IGlkOiBQcm9tT3BlcmF0aW9uSWQuQWJzZW50IH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuQWNvcyxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5Ucmlnb25vbWV0cmljLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuQWNvc2gsXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuVHJpZ29ub21ldHJpYyxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLkFzaW4sXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuVHJpZ29ub21ldHJpYyxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLkFzaW5oLFxuICAgICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlRyaWdvbm9tZXRyaWMsXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5BdGFuLFxuICAgICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlRyaWdvbm9tZXRyaWMsXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5BdGFuaCxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5Ucmlnb25vbWV0cmljLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHsgaWQ6IFByb21PcGVyYXRpb25JZC5DZWlsIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuQ2xhbXAsXG4gICAgICBuYW1lOiAnQ2xhbXAnLFxuICAgICAgcGFyYW1zOiBbXG4gICAgICAgIHsgbmFtZTogJ01pbmltdW0gU2NhbGFyJywgdHlwZTogJ251bWJlcicgfSxcbiAgICAgICAgeyBuYW1lOiAnTWF4aW11bSBTY2FsYXInLCB0eXBlOiAnbnVtYmVyJyB9LFxuICAgICAgXSxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFsxLCAxXSxcbiAgICB9KSxcblxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuQ2xhbXBNYXgsXG4gICAgICBwYXJhbXM6IFt7IG5hbWU6ICdNYXhpbXVtIFNjYWxhcicsIHR5cGU6ICdudW1iZXInIH1dLFxuICAgICAgZGVmYXVsdFBhcmFtczogWzFdLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuQ2xhbXBNaW4sXG4gICAgICBwYXJhbXM6IFt7IG5hbWU6ICdNaW5pbXVtIFNjYWxhcicsIHR5cGU6ICdudW1iZXInIH1dLFxuICAgICAgZGVmYXVsdFBhcmFtczogWzFdLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuQ29zLFxuICAgICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlRyaWdvbm9tZXRyaWMsXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5Db3NoLFxuICAgICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlRyaWdvbm9tZXRyaWMsXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5EYXlPZk1vbnRoLFxuICAgICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlRpbWUsXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5EYXlPZldlZWssXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuVGltZSxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLkRheXNJbk1vbnRoLFxuICAgICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlRpbWUsXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLkRlZyB9KSxcbiAgICBjcmVhdGVSYW5nZUZ1bmN0aW9uKFByb21PcGVyYXRpb25JZC5EZXJpdiksXG4gICAgLy9cbiAgICBjcmVhdGVGdW5jdGlvbih7IGlkOiBQcm9tT3BlcmF0aW9uSWQuRXhwIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHsgaWQ6IFByb21PcGVyYXRpb25JZC5GbG9vciB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7IGlkOiBQcm9tT3BlcmF0aW9uSWQuR3JvdXAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLkhvdXIgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5MYWJlbEpvaW4sXG4gICAgICBwYXJhbXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdEZXN0aW5hdGlvbiBMYWJlbCcsXG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgZWRpdG9yOiBMYWJlbFBhcmFtRWRpdG9yLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ1NlcGFyYXRvcicsXG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnU291cmNlIExhYmVsJyxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICByZXN0UGFyYW06IHRydWUsXG4gICAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgICAgZWRpdG9yOiBMYWJlbFBhcmFtRWRpdG9yLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFsnJywgJywnLCAnJ10sXG4gICAgICByZW5kZXJlcjogbGFiZWxKb2luUmVuZGVyZXIsXG4gICAgICBhZGRPcGVyYXRpb25IYW5kbGVyOiBsYWJlbEpvaW5BZGRPcGVyYXRpb25IYW5kbGVyLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHsgaWQ6IFByb21PcGVyYXRpb25JZC5Mb2cxMCB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7IGlkOiBQcm9tT3BlcmF0aW9uSWQuTG9nMiB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7IGlkOiBQcm9tT3BlcmF0aW9uSWQuTWludXRlIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHsgaWQ6IFByb21PcGVyYXRpb25JZC5Nb250aCB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLlBpLFxuICAgICAgcmVuZGVyZXI6IChtb2RlbCkgPT4gYCR7bW9kZWwuaWR9KClgLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuUXVhbnRpbGUsXG4gICAgICBwYXJhbXM6IFt7IG5hbWU6ICdWYWx1ZScsIHR5cGU6ICdudW1iZXInIH1dLFxuICAgICAgZGVmYXVsdFBhcmFtczogWzFdLFxuICAgICAgcmVuZGVyZXI6IGZ1bmN0aW9uUmVuZGVyZXJMZWZ0LFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHsgaWQ6IFByb21PcGVyYXRpb25JZC5SYWQgfSksXG4gICAgY3JlYXRlUmFuZ2VGdW5jdGlvbihQcm9tT3BlcmF0aW9uSWQuUmVzZXRzKSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLlJvdW5kLFxuICAgICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkZ1bmN0aW9ucyxcbiAgICAgIHBhcmFtczogW3sgbmFtZTogJ1RvIE5lYXJlc3QnLCB0eXBlOiAnbnVtYmVyJyB9XSxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFsxXSxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7IGlkOiBQcm9tT3BlcmF0aW9uSWQuU2NhbGFyIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHsgaWQ6IFByb21PcGVyYXRpb25JZC5TZ24gfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLlNpbiwgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlRyaWdvbm9tZXRyaWMgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5TaW5oLFxuICAgICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlRyaWdvbm9tZXRyaWMsXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLlNvcnQgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLlNvcnREZXNjIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHsgaWQ6IFByb21PcGVyYXRpb25JZC5TcXJ0IH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHsgaWQ6IFByb21PcGVyYXRpb25JZC5TdGRkZXYgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5UYW4sXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuVHJpZ29ub21ldHJpYyxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLlRhbmgsXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuVHJpZ29ub21ldHJpYyxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLlRpbWUsXG4gICAgICByZW5kZXJlcjogKG1vZGVsKSA9PiBgJHttb2RlbC5pZH0oKWAsXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLlRpbWVzdGFtcCB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLlZlY3RvcixcbiAgICAgIHBhcmFtczogW3sgbmFtZTogJ1ZhbHVlJywgdHlwZTogJ251bWJlcicgfV0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbMV0sXG4gICAgICByZW5kZXJlcjogKG1vZGVsKSA9PiBgJHttb2RlbC5pZH0oJHttb2RlbC5wYXJhbXNbMF19KWAsXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLlllYXIgfSksXG4gIF07XG5cbiAgcmV0dXJuIGxpc3Q7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGdW5jdGlvbihkZWZpbml0aW9uOiBQYXJ0aWFsPFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZj4pOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYge1xuICByZXR1cm4ge1xuICAgIC4uLmRlZmluaXRpb24sXG4gICAgaWQ6IGRlZmluaXRpb24uaWQhLFxuICAgIG5hbWU6IGRlZmluaXRpb24ubmFtZSA/PyBnZXRQcm9tQW5kTG9raU9wZXJhdGlvbkRpc3BsYXlOYW1lKGRlZmluaXRpb24uaWQhKSxcbiAgICBwYXJhbXM6IGRlZmluaXRpb24ucGFyYW1zID8/IFtdLFxuICAgIGRlZmF1bHRQYXJhbXM6IGRlZmluaXRpb24uZGVmYXVsdFBhcmFtcyA/PyBbXSxcbiAgICBjYXRlZ29yeTogZGVmaW5pdGlvbi5jYXRlZ29yeSA/PyBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5GdW5jdGlvbnMsXG4gICAgcmVuZGVyZXI6IGRlZmluaXRpb24ucmVuZGVyZXIgPz8gKGRlZmluaXRpb24ucGFyYW1zID8gZnVuY3Rpb25SZW5kZXJlclJpZ2h0IDogZnVuY3Rpb25SZW5kZXJlckxlZnQpLFxuICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGRlZmluaXRpb24uYWRkT3BlcmF0aW9uSGFuZGxlciA/PyBkZWZhdWx0QWRkT3BlcmF0aW9uSGFuZGxlcixcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJhbmdlRnVuY3Rpb24obmFtZTogc3RyaW5nLCB3aXRoUmF0ZUludGVydmFsID0gZmFsc2UpOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYge1xuICByZXR1cm4ge1xuICAgIGlkOiBuYW1lLFxuICAgIG5hbWU6IGdldFByb21BbmRMb2tpT3BlcmF0aW9uRGlzcGxheU5hbWUobmFtZSksXG4gICAgcGFyYW1zOiBbZ2V0UmFuZ2VWZWN0b3JQYXJhbURlZih3aXRoUmF0ZUludGVydmFsKV0sXG4gICAgZGVmYXVsdFBhcmFtczogW3dpdGhSYXRlSW50ZXJ2YWwgPyAnJF9fcmF0ZV9pbnRlcnZhbCcgOiAnJF9faW50ZXJ2YWwnXSxcbiAgICBhbHRlcm5hdGl2ZXNLZXk6ICdyYW5nZSBmdW5jdGlvbicsXG4gICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlJhbmdlRnVuY3Rpb25zLFxuICAgIHJlbmRlcmVyOiBvcGVyYXRpb25XaXRoUmFuZ2VWZWN0b3JSZW5kZXJlcixcbiAgICBhZGRPcGVyYXRpb25IYW5kbGVyOiBhZGRPcGVyYXRpb25XaXRoUmFuZ2VWZWN0b3IsXG4gICAgY2hhbmdlVHlwZUhhbmRsZXI6IG9wZXJhdGlvblR5cGVDaGFuZ2VkSGFuZGxlckZvclJhbmdlRnVuY3Rpb24sXG4gIH07XG59XG5cbmZ1bmN0aW9uIG9wZXJhdGlvblR5cGVDaGFuZ2VkSGFuZGxlckZvclJhbmdlRnVuY3Rpb24oXG4gIG9wZXJhdGlvbjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLFxuICBuZXdEZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZlxuKSB7XG4gIC8vIHZhbGlkYXRlIGN1cnJlbnQgcGFyYW1ldGVyXG4gIGlmIChvcGVyYXRpb24ucGFyYW1zWzBdID09PSAnJF9fcmF0ZV9pbnRlcnZhbCcgJiYgbmV3RGVmLmRlZmF1bHRQYXJhbXNbMF0gIT09ICckX19yYXRlX2ludGVydmFsJykge1xuICAgIG9wZXJhdGlvbi5wYXJhbXMgPSBuZXdEZWYuZGVmYXVsdFBhcmFtcztcbiAgfSBlbHNlIGlmIChvcGVyYXRpb24ucGFyYW1zWzBdID09PSAnJF9faW50ZXJ2YWwnICYmIG5ld0RlZi5kZWZhdWx0UGFyYW1zWzBdICE9PSAnJF9faW50ZXJ2YWwnKSB7XG4gICAgb3BlcmF0aW9uLnBhcmFtcyA9IG5ld0RlZi5kZWZhdWx0UGFyYW1zO1xuICB9XG5cbiAgcmV0dXJuIG9wZXJhdGlvbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9wZXJhdGlvbldpdGhSYW5nZVZlY3RvclJlbmRlcmVyKFxuICBtb2RlbDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLFxuICBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZixcbiAgaW5uZXJFeHByOiBzdHJpbmdcbikge1xuICBsZXQgcmFuZ2VWZWN0b3IgPSAobW9kZWwucGFyYW1zID8/IFtdKVswXSA/PyAnNW0nO1xuICByZXR1cm4gYCR7ZGVmLmlkfSgke2lubmVyRXhwcn1bJHtyYW5nZVZlY3Rvcn1dKWA7XG59XG5cbi8qKlxuICogU2luY2UgdGhlcmUgY2FuIG9ubHkgYmUgb25lIG9wZXJhdGlvbiB3aXRoIHJhbmdlIHZlY3RvciB0aGlzIHdpbGwgcmVwbGFjZSB0aGUgY3VycmVudCBvbmUgKGlmIG9uZSB3YXMgYWRkZWQgKVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkT3BlcmF0aW9uV2l0aFJhbmdlVmVjdG9yKFxuICBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZixcbiAgcXVlcnk6IFByb21WaXN1YWxRdWVyeSxcbiAgbW9kZWxsZXI6IFZpc3VhbFF1ZXJ5TW9kZWxsZXJcbikge1xuICBjb25zdCBuZXdPcGVyYXRpb246IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiA9IHtcbiAgICBpZDogZGVmLmlkLFxuICAgIHBhcmFtczogZGVmLmRlZmF1bHRQYXJhbXMsXG4gIH07XG5cbiAgaWYgKHF1ZXJ5Lm9wZXJhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgIC8vIElmIG9wZXJhdGlvbiBleGlzdHMgaXQgaGFzIHRvIGJlIGluIHRoZSByZWdpc3RyeSBzbyBubyBwb2ludCB0byBjaGVjayBpZiBpdCB3YXMgZm91bmRcbiAgICBjb25zdCBmaXJzdE9wID0gbW9kZWxsZXIuZ2V0T3BlcmF0aW9uRGVmKHF1ZXJ5Lm9wZXJhdGlvbnNbMF0uaWQpITtcblxuICAgIGlmIChmaXJzdE9wLmFkZE9wZXJhdGlvbkhhbmRsZXIgPT09IGFkZE9wZXJhdGlvbldpdGhSYW5nZVZlY3Rvcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucXVlcnksXG4gICAgICAgIG9wZXJhdGlvbnM6IFtuZXdPcGVyYXRpb24sIC4uLnF1ZXJ5Lm9wZXJhdGlvbnMuc2xpY2UoMSldLFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC4uLnF1ZXJ5LFxuICAgIG9wZXJhdGlvbnM6IFtuZXdPcGVyYXRpb24sIC4uLnF1ZXJ5Lm9wZXJhdGlvbnNdLFxuICB9O1xufVxuXG5mdW5jdGlvbiBhZGROZXN0ZWRRdWVyeUhhbmRsZXIoZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsIHF1ZXJ5OiBQcm9tVmlzdWFsUXVlcnkpOiBQcm9tVmlzdWFsUXVlcnkge1xuICByZXR1cm4ge1xuICAgIC4uLnF1ZXJ5LFxuICAgIGJpbmFyeVF1ZXJpZXM6IFtcbiAgICAgIC4uLihxdWVyeS5iaW5hcnlRdWVyaWVzID8/IFtdKSxcbiAgICAgIHtcbiAgICAgICAgb3BlcmF0b3I6ICcvJyxcbiAgICAgICAgcXVlcnksXG4gICAgICB9LFxuICAgIF0sXG4gIH07XG59XG5cbmZ1bmN0aW9uIGxhYmVsSm9pblJlbmRlcmVyKG1vZGVsOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLCBpbm5lckV4cHI6IHN0cmluZykge1xuICBpZiAodHlwZW9mIG1vZGVsLnBhcmFtc1sxXSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyAnVGhlIHNlcGFyYXRvciBtdXN0IGJlIGEgc3RyaW5nJztcbiAgfVxuICBjb25zdCBzZXBhcmF0b3IgPSBgXCIke21vZGVsLnBhcmFtc1sxXX1cImA7XG4gIHJldHVybiBgJHttb2RlbC5pZH0oJHtpbm5lckV4cHJ9LCBcIiR7bW9kZWwucGFyYW1zWzBdfVwiLCAke3NlcGFyYXRvcn0sIFwiJHttb2RlbC5wYXJhbXMuc2xpY2UoMikuam9pbihzZXBhcmF0b3IpfVwiKWA7XG59XG5cbmZ1bmN0aW9uIGxhYmVsSm9pbkFkZE9wZXJhdGlvbkhhbmRsZXI8VCBleHRlbmRzIFF1ZXJ5V2l0aE9wZXJhdGlvbnM+KGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLCBxdWVyeTogVCkge1xuICBjb25zdCBuZXdPcGVyYXRpb246IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiA9IHtcbiAgICBpZDogZGVmLmlkLFxuICAgIHBhcmFtczogZGVmLmRlZmF1bHRQYXJhbXMsXG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5xdWVyeSxcbiAgICBvcGVyYXRpb25zOiBbLi4ucXVlcnkub3BlcmF0aW9ucywgbmV3T3BlcmF0aW9uXSxcbiAgfTtcbn1cbiIsImltcG9ydCB7IFN5bnRheE5vZGUgfSBmcm9tICdAbGV6ZXIvY29tbW9uJztcbmltcG9ydCB7IHBhcnNlciB9IGZyb20gJ2xlemVyLXByb21xbCc7XG5cbmltcG9ydCB7IGJpbmFyeVNjYWxhck9wZXJhdG9yVG9PcGVyYXRvck5hbWUgfSBmcm9tICcuL2JpbmFyeVNjYWxhck9wZXJhdGlvbnMnO1xuaW1wb3J0IHtcbiAgRXJyb3JOYW1lLFxuICBnZXRBbGxCeVR5cGUsXG4gIGdldExlZnRNb3N0Q2hpbGQsXG4gIGdldFN0cmluZyxcbiAgbWFrZUJpbk9wLFxuICBtYWtlRXJyb3IsXG4gIHJlcGxhY2VWYXJpYWJsZXMsXG59IGZyb20gJy4vc2hhcmVkL3BhcnNpbmdVdGlscyc7XG5pbXBvcnQgeyBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlciwgUXVlcnlCdWlsZGVyT3BlcmF0aW9uIH0gZnJvbSAnLi9zaGFyZWQvdHlwZXMnO1xuaW1wb3J0IHsgUHJvbVZpc3VhbFF1ZXJ5LCBQcm9tVmlzdWFsUXVlcnlCaW5hcnkgfSBmcm9tICcuL3R5cGVzJztcblxuLyoqXG4gKiBQYXJzZXMgYSBQcm9tUUwgcXVlcnkgaW50byBhIHZpc3VhbCBxdWVyeSBtb2RlbC5cbiAqXG4gKiBJdCB0cmF2ZXJzZXMgdGhlIHRyZWUgYW5kIHVzZXMgc29ydCBvZiBzdGF0ZSBtYWNoaW5lIHRvIHVwZGF0ZSB0aGUgcXVlcnkgbW9kZWwuIFRoZSBxdWVyeSBtb2RlbCBpcyBtb2RpZmllZFxuICogZHVyaW5nIHRoZSB0cmF2ZXJzYWwgYW5kIHNlbnQgdG8gZWFjaCBoYW5kbGVyIGFzIGNvbnRleHQuXG4gKlxuICogQHBhcmFtIGV4cHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkVmlzdWFsUXVlcnlGcm9tU3RyaW5nKGV4cHI6IHN0cmluZyk6IENvbnRleHQge1xuICBjb25zdCByZXBsYWNlZEV4cHIgPSByZXBsYWNlVmFyaWFibGVzKGV4cHIpO1xuICBjb25zdCB0cmVlID0gcGFyc2VyLnBhcnNlKHJlcGxhY2VkRXhwcik7XG4gIGNvbnN0IG5vZGUgPSB0cmVlLnRvcE5vZGU7XG5cbiAgLy8gVGhpcyB3aWxsIGJlIG1vZGlmaWVkIGluIHRoZSBoYW5kbGVycy5cbiAgY29uc3QgdmlzUXVlcnk6IFByb21WaXN1YWxRdWVyeSA9IHtcbiAgICBtZXRyaWM6ICcnLFxuICAgIGxhYmVsczogW10sXG4gICAgb3BlcmF0aW9uczogW10sXG4gIH07XG4gIGNvbnN0IGNvbnRleHQ6IENvbnRleHQgPSB7XG4gICAgcXVlcnk6IHZpc1F1ZXJ5LFxuICAgIGVycm9yczogW10sXG4gIH07XG5cbiAgdHJ5IHtcbiAgICBoYW5kbGVFeHByZXNzaW9uKHJlcGxhY2VkRXhwciwgbm9kZSwgY29udGV4dCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIE5vdCBpZGVhbCB0byBsb2cgaXQgaGVyZSwgYnV0IG90aGVyd2lzZSB3ZSB3b3VsZCBsb3NlIHRoZSBzdGFjayB0cmFjZS5cbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgY29udGV4dC5lcnJvcnMucHVzaCh7XG4gICAgICB0ZXh0OiBlcnIubWVzc2FnZSxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIElmIHdlIGhhdmUgZW1wdHkgcXVlcnksIHdlIHdhbnQgdG8gcmVzZXQgZXJyb3JzXG4gIGlmIChpc0VtcHR5UXVlcnkoY29udGV4dC5xdWVyeSkpIHtcbiAgICBjb250ZXh0LmVycm9ycyA9IFtdO1xuICB9XG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5pbnRlcmZhY2UgUGFyc2luZ0Vycm9yIHtcbiAgdGV4dDogc3RyaW5nO1xuICBmcm9tPzogbnVtYmVyO1xuICB0bz86IG51bWJlcjtcbiAgcGFyZW50VHlwZT86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIENvbnRleHQge1xuICBxdWVyeTogUHJvbVZpc3VhbFF1ZXJ5O1xuICBlcnJvcnM6IFBhcnNpbmdFcnJvcltdO1xufVxuXG4vKipcbiAqIEhhbmRsZXIgZm9yIGRlZmF1bHQgc3RhdGUuIEl0IHdpbGwgdHJhdmVyc2UgdGhlIHRyZWUgYW5kIGNhbGwgdGhlIGFwcHJvcHJpYXRlIGhhbmRsZXIgZm9yIGVhY2ggbm9kZS4gVGhlIG5vZGVcbiAqIGhhbmRsZWQgaGVyZSBkb2VzIG5vdCBuZWNlc3NhcmlseSBuZWVkIHRvIGJlIG9mIHR5cGUgPT0gRXhwci5cbiAqIEBwYXJhbSBleHByXG4gKiBAcGFyYW0gbm9kZVxuICogQHBhcmFtIGNvbnRleHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZUV4cHJlc3Npb24oZXhwcjogc3RyaW5nLCBub2RlOiBTeW50YXhOb2RlLCBjb250ZXh0OiBDb250ZXh0KSB7XG4gIGNvbnN0IHZpc1F1ZXJ5ID0gY29udGV4dC5xdWVyeTtcbiAgc3dpdGNoIChub2RlLm5hbWUpIHtcbiAgICBjYXNlICdNZXRyaWNJZGVudGlmaWVyJzoge1xuICAgICAgLy8gRXhwZWN0YXRpb24gaXMgdGhhdCB0aGVyZSBpcyBvbmx5IG9uZSBvZiB0aG9zZSBwZXIgcXVlcnkuXG4gICAgICB2aXNRdWVyeS5tZXRyaWMgPSBnZXRTdHJpbmcoZXhwciwgbm9kZSk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICdMYWJlbE1hdGNoZXInOiB7XG4gICAgICAvLyBTYW1lIGFzIE1ldHJpY0lkZW50aWZpZXIgc2hvdWxkIGJlIGp1c3Qgb25lIHBlciBxdWVyeS5cbiAgICAgIHZpc1F1ZXJ5LmxhYmVscy5wdXNoKGdldExhYmVsKGV4cHIsIG5vZGUpKTtcbiAgICAgIGNvbnN0IGVyciA9IG5vZGUuZ2V0Q2hpbGQoRXJyb3JOYW1lKTtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgY29udGV4dC5lcnJvcnMucHVzaChtYWtlRXJyb3IoZXhwciwgZXJyKSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICdGdW5jdGlvbkNhbGwnOiB7XG4gICAgICBoYW5kbGVGdW5jdGlvbihleHByLCBub2RlLCBjb250ZXh0KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgJ0FnZ3JlZ2F0ZUV4cHInOiB7XG4gICAgICBoYW5kbGVBZ2dyZWdhdGlvbihleHByLCBub2RlLCBjb250ZXh0KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgJ0JpbmFyeUV4cHInOiB7XG4gICAgICBoYW5kbGVCaW5hcnkoZXhwciwgbm9kZSwgY29udGV4dCk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlIEVycm9yTmFtZToge1xuICAgICAgaWYgKGlzSW50ZXJ2YWxWYXJpYWJsZUVycm9yKG5vZGUpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29udGV4dC5lcnJvcnMucHVzaChtYWtlRXJyb3IoZXhwciwgbm9kZSkpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZGVmYXVsdDoge1xuICAgICAgaWYgKG5vZGUubmFtZSA9PT0gJ1BhcmVuRXhwcicpIHtcbiAgICAgICAgLy8gV2UgZG9uJ3Qgc3VwcG9ydCBwYXJlbnRoZXNpcyBpbiB0aGUgcXVlcnkgdG8gZ3JvdXAgZXhwcmVzc2lvbnMuIFdlIGp1c3QgcmVwb3J0IGVycm9yIGJ1dCBnbyBvbiB3aXRoIHRoZVxuICAgICAgICAvLyBwYXJzaW5nLlxuICAgICAgICBjb250ZXh0LmVycm9ycy5wdXNoKG1ha2VFcnJvcihleHByLCBub2RlKSk7XG4gICAgICB9XG4gICAgICAvLyBBbnkgb3RoZXIgbm9kZXMgd2UganVzdCBpZ25vcmUgYW5kIGdvIHRvIGl0J3MgY2hpbGRyZW4uIFRoaXMgc2hvdWxkIGJlIGZpbmUgYXMgdGhlcmUgYXJlIGxvdCdzIG9mIHdyYXBwZXJcbiAgICAgIC8vIG5vZGVzIHRoYXQgY2FuIGJlIHNraXBwZWQuXG4gICAgICAvLyBUT0RPOiB0aGVyZSBhcmUgcHJvYmFibHkgY2FzZXMgd2hlcmUgd2Ugd2lsbCBqdXN0IHNraXAgbm9kZXMgd2UgZG9uJ3Qgc3VwcG9ydCBhbmQgd2Ugc2hvdWxkIGJlIGFibGUgdG9cbiAgICAgIC8vICBkZXRlY3QgdGhvc2UgYW5kIHJlcG9ydCBiYWNrLlxuICAgICAgbGV0IGNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgIGhhbmRsZUV4cHJlc3Npb24oZXhwciwgY2hpbGQsIGNvbnRleHQpO1xuICAgICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc0ludGVydmFsVmFyaWFibGVFcnJvcihub2RlOiBTeW50YXhOb2RlKSB7XG4gIHJldHVybiBub2RlLnByZXZTaWJsaW5nPy5uYW1lID09PSAnRXhwcicgJiYgbm9kZS5wcmV2U2libGluZz8uZmlyc3RDaGlsZD8ubmFtZSA9PT0gJ1ZlY3RvclNlbGVjdG9yJztcbn1cblxuZnVuY3Rpb24gZ2V0TGFiZWwoZXhwcjogc3RyaW5nLCBub2RlOiBTeW50YXhOb2RlKTogUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXIge1xuICBjb25zdCBsYWJlbCA9IGdldFN0cmluZyhleHByLCBub2RlLmdldENoaWxkKCdMYWJlbE5hbWUnKSk7XG4gIGNvbnN0IG9wID0gZ2V0U3RyaW5nKGV4cHIsIG5vZGUuZ2V0Q2hpbGQoJ01hdGNoT3AnKSk7XG4gIGNvbnN0IHZhbHVlID0gZ2V0U3RyaW5nKGV4cHIsIG5vZGUuZ2V0Q2hpbGQoJ1N0cmluZ0xpdGVyYWwnKSkucmVwbGFjZSgvXCIvZywgJycpO1xuICByZXR1cm4ge1xuICAgIGxhYmVsLFxuICAgIG9wLFxuICAgIHZhbHVlLFxuICB9O1xufVxuXG5jb25zdCByYW5nZUZ1bmN0aW9ucyA9IFsnY2hhbmdlcycsICdyYXRlJywgJ2lyYXRlJywgJ2luY3JlYXNlJywgJ2RlbHRhJ107XG4vKipcbiAqIEhhbmRsZSBmdW5jdGlvbiBjYWxsIHdoaWNoIGlzIHVzdWFsbHkgYW5kIGlkZW50aWZpZXIgYW5kIGl0cyBib2R5ID4gYXJndW1lbnRzLlxuICogQHBhcmFtIGV4cHJcbiAqIEBwYXJhbSBub2RlXG4gKiBAcGFyYW0gY29udGV4dFxuICovXG5mdW5jdGlvbiBoYW5kbGVGdW5jdGlvbihleHByOiBzdHJpbmcsIG5vZGU6IFN5bnRheE5vZGUsIGNvbnRleHQ6IENvbnRleHQpIHtcbiAgY29uc3QgdmlzUXVlcnkgPSBjb250ZXh0LnF1ZXJ5O1xuICBjb25zdCBuYW1lTm9kZSA9IG5vZGUuZ2V0Q2hpbGQoJ0Z1bmN0aW9uSWRlbnRpZmllcicpO1xuICBjb25zdCBmdW5jTmFtZSA9IGdldFN0cmluZyhleHByLCBuYW1lTm9kZSk7XG5cbiAgY29uc3QgYm9keSA9IG5vZGUuZ2V0Q2hpbGQoJ0Z1bmN0aW9uQ2FsbEJvZHknKTtcbiAgY29uc3QgY2FsbEFyZ3MgPSBib2R5IS5nZXRDaGlsZCgnRnVuY3Rpb25DYWxsQXJncycpO1xuICBjb25zdCBwYXJhbXMgPSBbXTtcbiAgbGV0IGludGVydmFsID0gJyc7XG5cbiAgLy8gVGhpcyBpcyBhIGJpdCBvZiBhIHNob3J0Y3V0IHRvIGdldCB0aGUgaW50ZXJ2YWwgYXJndW1lbnQuIFJlYXNvbnMgYXJlXG4gIC8vIC0gaW50ZXJ2YWwgaXMgbm90IHBhcnQgb2YgdGhlIGZ1bmN0aW9uIGFyZ3MgcGVyIHByb21RTCBncmFtbWFyIGJ1dCB3ZSBtb2RlbCBpdCBhcyBhcmd1bWVudCBmb3IgdGhlIGZ1bmN0aW9uIGluXG4gIC8vICAgdGhlIHF1ZXJ5IG1vZGVsLlxuICAvLyAtIGl0IGlzIGVhc2llciB0byBoYW5kbGUgdGVtcGxhdGUgdmFyaWFibGVzIHRoaXMgd2F5IGFzIHRlbXBsYXRlIHZhcmlhYmxlIGlzIGFuIGVycm9yIGZvciB0aGUgcGFyc2VyXG4gIGlmIChyYW5nZUZ1bmN0aW9ucy5pbmNsdWRlcyhmdW5jTmFtZSkgfHwgZnVuY05hbWUuZW5kc1dpdGgoJ19vdmVyX3RpbWUnKSkge1xuICAgIGxldCBtYXRjaCA9IGdldFN0cmluZyhleHByLCBub2RlKS5tYXRjaCgvXFxbKC4rKVxcXS8pO1xuICAgIGlmIChtYXRjaD8uWzFdKSB7XG4gICAgICBpbnRlcnZhbCA9IG1hdGNoWzFdO1xuICAgICAgcGFyYW1zLnB1c2gobWF0Y2hbMV0pO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG9wID0geyBpZDogZnVuY05hbWUsIHBhcmFtcyB9O1xuICAvLyBXZSB1bnNoaWZ0IG9wZXJhdGlvbnMgdG8ga2VlcCB0aGUgbW9yZSBuYXR1cmFsIG9yZGVyIHRoYXQgd2Ugd2FudCB0byBoYXZlIGluIHRoZSB2aXN1YWwgcXVlcnkgZWRpdG9yLlxuICB2aXNRdWVyeS5vcGVyYXRpb25zLnVuc2hpZnQob3ApO1xuXG4gIGlmIChjYWxsQXJncykge1xuICAgIGlmIChnZXRTdHJpbmcoZXhwciwgY2FsbEFyZ3MpID09PSBpbnRlcnZhbCArICddJykge1xuICAgICAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZSB3aGVyZSB3ZSBoYXZlIGEgZnVuY3Rpb24gd2l0aCBhIHNpbmdsZSBhcmd1bWVudCBhbmQgaXQgaXMgdGhlIGludGVydmFsLlxuICAgICAgLy8gVGhpcyBoYXBwZW5zIHdoZW4geW91IHN0YXJ0IGFkZGluZyBvcGVyYXRpb25zIGluIHF1ZXJ5IGJ1aWxkZXIgYW5kIGRpZCBub3Qgc2V0IGEgbWV0cmljIHlldC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdXBkYXRlRnVuY3Rpb25BcmdzKGV4cHIsIGNhbGxBcmdzLCBjb250ZXh0LCBvcCk7XG4gIH1cbn1cblxuLyoqXG4gKiBIYW5kbGUgYWdncmVnYXRpb24gYXMgdGhleSBhcmUgZGlzdGluY3QgdHlwZSBmcm9tIG90aGVyIGZ1bmN0aW9ucy5cbiAqIEBwYXJhbSBleHByXG4gKiBAcGFyYW0gbm9kZVxuICogQHBhcmFtIGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gaGFuZGxlQWdncmVnYXRpb24oZXhwcjogc3RyaW5nLCBub2RlOiBTeW50YXhOb2RlLCBjb250ZXh0OiBDb250ZXh0KSB7XG4gIGNvbnN0IHZpc1F1ZXJ5ID0gY29udGV4dC5xdWVyeTtcbiAgY29uc3QgbmFtZU5vZGUgPSBub2RlLmdldENoaWxkKCdBZ2dyZWdhdGVPcCcpO1xuICBsZXQgZnVuY05hbWUgPSBnZXRTdHJpbmcoZXhwciwgbmFtZU5vZGUpO1xuXG4gIGNvbnN0IG1vZGlmaWVyID0gbm9kZS5nZXRDaGlsZCgnQWdncmVnYXRlTW9kaWZpZXInKTtcbiAgY29uc3QgbGFiZWxzID0gW107XG5cbiAgaWYgKG1vZGlmaWVyKSB7XG4gICAgY29uc3QgYnlNb2RpZmllciA9IG1vZGlmaWVyLmdldENoaWxkKGBCeWApO1xuICAgIGlmIChieU1vZGlmaWVyICYmIGZ1bmNOYW1lKSB7XG4gICAgICBmdW5jTmFtZSA9IGBfXyR7ZnVuY05hbWV9X2J5YDtcbiAgICB9XG5cbiAgICBjb25zdCB3aXRob3V0TW9kaWZpZXIgPSBtb2RpZmllci5nZXRDaGlsZChgV2l0aG91dGApO1xuICAgIGlmICh3aXRob3V0TW9kaWZpZXIpIHtcbiAgICAgIGZ1bmNOYW1lID0gYF9fJHtmdW5jTmFtZX1fd2l0aG91dGA7XG4gICAgfVxuXG4gICAgbGFiZWxzLnB1c2goLi4uZ2V0QWxsQnlUeXBlKGV4cHIsIG1vZGlmaWVyLCAnR3JvdXBpbmdMYWJlbCcpKTtcbiAgfVxuXG4gIGNvbnN0IGJvZHkgPSBub2RlLmdldENoaWxkKCdGdW5jdGlvbkNhbGxCb2R5Jyk7XG4gIGNvbnN0IGNhbGxBcmdzID0gYm9keSEuZ2V0Q2hpbGQoJ0Z1bmN0aW9uQ2FsbEFyZ3MnKTtcblxuICBjb25zdCBvcDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uID0geyBpZDogZnVuY05hbWUsIHBhcmFtczogW10gfTtcbiAgdmlzUXVlcnkub3BlcmF0aW9ucy51bnNoaWZ0KG9wKTtcbiAgdXBkYXRlRnVuY3Rpb25BcmdzKGV4cHIsIGNhbGxBcmdzLCBjb250ZXh0LCBvcCk7XG4gIC8vIFdlIGFkZCBsYWJlbHMgYWZ0ZXIgcGFyYW1zIGluIHRoZSB2aXN1YWwgcXVlcnkgZWRpdG9yLlxuICBvcC5wYXJhbXMucHVzaCguLi5sYWJlbHMpO1xufVxuXG4vKipcbiAqIEhhbmRsZSAocHJvYmFibHkpIGFsbCB0eXBlcyBvZiBhcmd1bWVudHMgdGhhdCBmdW5jdGlvbiBvciBhZ2dyZWdhdGlvbiBjYW4gaGF2ZS5cbiAqXG4gKiAgRnVuY3Rpb25DYWxsQXJncyBhcmUgbmVzdGVkIGJpdCB3ZWlyZGx5IGJhc2ljYWxseSBpdHMgW2ZpcnN0QXJnLCAuLi5yZXN0XSB3aGVyZSByZXN0IGlzIGFnYWluIEZ1bmN0aW9uQ2FsbEFyZ3Mgc29cbiAqICB3ZSBjYW5ub3QganVzdCBnZXQgYWxsIHRoZSBjaGlsZHJlbiBhbmQgaXRlcmF0ZSB0aGVtIGFzIGFyZ3VtZW50cyB3ZSBoYXZlIHRvIGFnYWluIHJlY3Vyc2l2ZWx5IHRyYXZlcnNlIHRocm91Z2hcbiAqICB0aGVtLlxuICpcbiAqIEBwYXJhbSBleHByXG4gKiBAcGFyYW0gbm9kZVxuICogQHBhcmFtIGNvbnRleHRcbiAqIEBwYXJhbSBvcCAtIFdlIG5lZWQgdGhlIG9wZXJhdGlvbiB0byBhZGQgdGhlIHBhcmFtcyB0byBhcyBhbiBhZGRpdGlvbmFsIGNvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZUZ1bmN0aW9uQXJncyhleHByOiBzdHJpbmcsIG5vZGU6IFN5bnRheE5vZGUgfCBudWxsLCBjb250ZXh0OiBDb250ZXh0LCBvcDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uKSB7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBzd2l0Y2ggKG5vZGUubmFtZSkge1xuICAgIC8vIEluIGNhc2Ugd2UgaGF2ZSBhbiBleHByZXNzaW9uIHdlIGRvbid0IGtub3cgd2hhdCBraW5kIHNvIHdlIGhhdmUgdG8gbG9vayBhdCB0aGUgY2hpbGQgYXMgaXQgY2FuIGJlIGFueXRoaW5nLlxuICAgIGNhc2UgJ0V4cHInOlxuICAgIC8vIEZ1bmN0aW9uQ2FsbEFyZ3MgYXJlIG5lc3RlZCBiaXQgd2VpcmRseSBhcyBtZW50aW9uZWQgc28gd2UgaGF2ZSB0byBnbyBvbmUgZGVlcGVyIGluIHRoaXMgY2FzZS5cbiAgICBjYXNlICdGdW5jdGlvbkNhbGxBcmdzJzoge1xuICAgICAgbGV0IGNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgIHVwZGF0ZUZ1bmN0aW9uQXJncyhleHByLCBjaGlsZCwgY29udGV4dCwgb3ApO1xuICAgICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSAnTnVtYmVyTGl0ZXJhbCc6IHtcbiAgICAgIG9wLnBhcmFtcy5wdXNoKHBhcnNlRmxvYXQoZ2V0U3RyaW5nKGV4cHIsIG5vZGUpKSk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICdTdHJpbmdMaXRlcmFsJzoge1xuICAgICAgb3AucGFyYW1zLnB1c2goZ2V0U3RyaW5nKGV4cHIsIG5vZGUpLnJlcGxhY2UoL1wiL2csICcnKSk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBkZWZhdWx0OiB7XG4gICAgICAvLyBNZWFucyB3ZSBnZXQgdG8gc29tZXRoaW5nIHRoYXQgZG9lcyBub3Qgc2VlbSBsaWtlIHNpbXBsZSBmdW5jdGlvbiBhcmcgYW5kIGlzIHByb2JhYmx5IG5lc3RlZCBxdWVyeSBzbyBqdW1wXG4gICAgICAvLyBiYWNrIHRvIG1haW4gY29udGV4dFxuICAgICAgaGFuZGxlRXhwcmVzc2lvbihleHByLCBub2RlLCBjb250ZXh0KTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSaWdodCBub3cgYmluYXJ5IGV4cHJlc3Npb25zIGNhbiBiZSByZXByZXNlbnRlZCBpbiAyIHdheSBpbiB2aXN1YWwgcXVlcnkuIEFzIGFkZGl0aW9uYWwgb3BlcmF0aW9uIGluIGNhc2UgaXQgaXNcbiAqIGp1c3Qgb3BlcmF0aW9uIHdpdGggc2NhbGFyIG9yIGl0IGNyZWF0ZXMgYSBiaW5hcnlRdWVyeSB3aGVuIGl0J3MgMiBxdWVyaWVzLlxuICogQHBhcmFtIGV4cHJcbiAqIEBwYXJhbSBub2RlXG4gKiBAcGFyYW0gY29udGV4dFxuICovXG5mdW5jdGlvbiBoYW5kbGVCaW5hcnkoZXhwcjogc3RyaW5nLCBub2RlOiBTeW50YXhOb2RlLCBjb250ZXh0OiBDb250ZXh0KSB7XG4gIGNvbnN0IHZpc1F1ZXJ5ID0gY29udGV4dC5xdWVyeTtcbiAgY29uc3QgbGVmdCA9IG5vZGUuZmlyc3RDaGlsZCE7XG4gIGNvbnN0IG9wID0gZ2V0U3RyaW5nKGV4cHIsIGxlZnQubmV4dFNpYmxpbmcpO1xuICBjb25zdCBiaW5Nb2RpZmllciA9IGdldEJpbmFyeU1vZGlmaWVyKGV4cHIsIG5vZGUuZ2V0Q2hpbGQoJ0Jpbk1vZGlmaWVycycpKTtcblxuICBjb25zdCByaWdodCA9IG5vZGUubGFzdENoaWxkITtcblxuICBjb25zdCBvcERlZiA9IGJpbmFyeVNjYWxhck9wZXJhdG9yVG9PcGVyYXRvck5hbWVbb3BdO1xuXG4gIGNvbnN0IGxlZnROdW1iZXIgPSBsZWZ0LmdldENoaWxkKCdOdW1iZXJMaXRlcmFsJyk7XG4gIGNvbnN0IHJpZ2h0TnVtYmVyID0gcmlnaHQuZ2V0Q2hpbGQoJ051bWJlckxpdGVyYWwnKTtcblxuICBjb25zdCByaWdodEJpbmFyeSA9IHJpZ2h0LmdldENoaWxkKCdCaW5hcnlFeHByJyk7XG5cbiAgaWYgKGxlZnROdW1iZXIpIHtcbiAgICAvLyBUT0RPOiB0aGlzIHNob3VsZCBiZSBhbHJlYWR5IGhhbmRsZWQgaW4gY2FzZSBwYXJlbnQgaXMgYmluYXJ5IGV4cHJlc3Npb24gYXMgaXQgaGFzIHRvIGJlIGFkZGVkIHRvIHBhcmVudFxuICAgIC8vICBpZiBxdWVyeSBzdGFydHMgd2l0aCBhIG51bWJlciB0aGF0IGlzbid0IGhhbmRsZWQgbm93LlxuICB9IGVsc2Uge1xuICAgIC8vIElmIHRoaXMgaXMgYmluYXJ5IHdlIGRvbid0IHJlYWxseSBrbm93IGlmIHRoZXJlIGlzIGEgcXVlcnkgb3IganVzdCBjaGFpbmVkIHNjYWxhcnMuIFNvXG4gICAgLy8gd2UgaGF2ZSB0byB0cmF2ZXJzZSBhIGJpdCBkZWVwZXIgdG8ga25vd1xuICAgIGhhbmRsZUV4cHJlc3Npb24oZXhwciwgbGVmdCwgY29udGV4dCk7XG4gIH1cblxuICBpZiAocmlnaHROdW1iZXIpIHtcbiAgICB2aXNRdWVyeS5vcGVyYXRpb25zLnB1c2gobWFrZUJpbk9wKG9wRGVmLCBleHByLCByaWdodCwgISFiaW5Nb2RpZmllcj8uaXNCb29sKSk7XG4gIH0gZWxzZSBpZiAocmlnaHRCaW5hcnkpIHtcbiAgICAvLyBEdWUgdG8gdGhlIHdheSBiaW5hcnkgb3BzIGFyZSBwYXJzZWQgd2UgY2FuIGdldCBhIGJpbmFyeSBvcGVyYXRpb24gb24gdGhlIHJpZ2h0IHRoYXQgc3RhcnRzIHdpdGggYSBudW1iZXIgd2hpY2hcbiAgICAvLyBpcyBhIGZhY3RvciBmb3IgYSBjdXJyZW50IGJpbmFyeSBvcGVyYXRpb24uIFNvIHdlIGhhdmUgdG8gYWRkIGl0IGFzIGFuIG9wZXJhdGlvbiBub3cuXG4gICAgY29uc3QgbGVmdE1vc3RDaGlsZCA9IGdldExlZnRNb3N0Q2hpbGQocmlnaHQpO1xuICAgIGlmIChsZWZ0TW9zdENoaWxkPy5uYW1lID09PSAnTnVtYmVyTGl0ZXJhbCcpIHtcbiAgICAgIHZpc1F1ZXJ5Lm9wZXJhdGlvbnMucHVzaChtYWtlQmluT3Aob3BEZWYsIGV4cHIsIGxlZnRNb3N0Q2hpbGQsICEhYmluTW9kaWZpZXI/LmlzQm9vbCkpO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGFkZGVkIHRoZSBmaXJzdCBudW1iZXIgbGl0ZXJhbCBhcyBvcGVyYXRpb24gaGVyZSB3ZSBzdGlsbCBjYW4gY29udGludWUgYW5kIGhhbmRsZSB0aGUgcmVzdCBhcyB0aGUgZmlyc3RcbiAgICAvLyBudW1iZXIgd2lsbCBiZSBqdXN0IHNraXBwZWQuXG4gICAgaGFuZGxlRXhwcmVzc2lvbihleHByLCByaWdodCwgY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgdmlzUXVlcnkuYmluYXJ5UXVlcmllcyA9IHZpc1F1ZXJ5LmJpbmFyeVF1ZXJpZXMgfHwgW107XG4gICAgY29uc3QgYmluUXVlcnk6IFByb21WaXN1YWxRdWVyeUJpbmFyeSA9IHtcbiAgICAgIG9wZXJhdG9yOiBvcCxcbiAgICAgIHF1ZXJ5OiB7XG4gICAgICAgIG1ldHJpYzogJycsXG4gICAgICAgIGxhYmVsczogW10sXG4gICAgICAgIG9wZXJhdGlvbnM6IFtdLFxuICAgICAgfSxcbiAgICB9O1xuICAgIGlmIChiaW5Nb2RpZmllcj8uaXNNYXRjaGVyKSB7XG4gICAgICBiaW5RdWVyeS52ZWN0b3JNYXRjaGVzVHlwZSA9IGJpbk1vZGlmaWVyLm1hdGNoVHlwZTtcbiAgICAgIGJpblF1ZXJ5LnZlY3Rvck1hdGNoZXMgPSBiaW5Nb2RpZmllci5tYXRjaGVzO1xuICAgIH1cbiAgICB2aXNRdWVyeS5iaW5hcnlRdWVyaWVzLnB1c2goYmluUXVlcnkpO1xuICAgIGhhbmRsZUV4cHJlc3Npb24oZXhwciwgcmlnaHQsIHtcbiAgICAgIHF1ZXJ5OiBiaW5RdWVyeS5xdWVyeSxcbiAgICAgIGVycm9yczogY29udGV4dC5lcnJvcnMsXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QmluYXJ5TW9kaWZpZXIoXG4gIGV4cHI6IHN0cmluZyxcbiAgbm9kZTogU3ludGF4Tm9kZSB8IG51bGxcbik6XG4gIHwgeyBpc0Jvb2w6IHRydWU7IGlzTWF0Y2hlcjogZmFsc2UgfVxuICB8IHsgaXNCb29sOiBmYWxzZTsgaXNNYXRjaGVyOiB0cnVlOyBtYXRjaGVzOiBzdHJpbmc7IG1hdGNoVHlwZTogJ2lnbm9yaW5nJyB8ICdvbicgfVxuICB8IHVuZGVmaW5lZCB7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKG5vZGUuZ2V0Q2hpbGQoJ0Jvb2wnKSkge1xuICAgIHJldHVybiB7IGlzQm9vbDogdHJ1ZSwgaXNNYXRjaGVyOiBmYWxzZSB9O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG1hdGNoZXIgPSBub2RlLmdldENoaWxkKCdPbk9ySWdub3JpbmcnKTtcbiAgICBpZiAoIW1hdGNoZXIpIHtcbiAgICAgIC8vIE5vdCBzdXJlIHdoYXQgdGhpcyBjb3VsZCBiZSwgbWF5YmUgc2hvdWxkIGJlIGFuIGVycm9yLlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgbGFiZWxzID0gZ2V0U3RyaW5nKGV4cHIsIG1hdGNoZXIuZ2V0Q2hpbGQoJ0dyb3VwaW5nTGFiZWxzJyk/LmdldENoaWxkKCdHcm91cGluZ0xhYmVsTGlzdCcpKTtcbiAgICByZXR1cm4ge1xuICAgICAgaXNNYXRjaGVyOiB0cnVlLFxuICAgICAgaXNCb29sOiBmYWxzZSxcbiAgICAgIG1hdGNoZXM6IGxhYmVscyxcbiAgICAgIG1hdGNoVHlwZTogbWF0Y2hlci5nZXRDaGlsZCgnT24nKSA/ICdvbicgOiAnaWdub3JpbmcnLFxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNFbXB0eVF1ZXJ5KHF1ZXJ5OiBQcm9tVmlzdWFsUXVlcnkpIHtcbiAgaWYgKHF1ZXJ5LmxhYmVscy5sZW5ndGggPT09IDAgJiYgcXVlcnkub3BlcmF0aW9ucy5sZW5ndGggPT09IDAgJiYgIXF1ZXJ5Lm1ldHJpYykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbiIsImltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IElucHV0LCBtZWFzdXJlVGV4dCB9IGZyb20gJ0BncmFmYW5hL3VpJztcbmltcG9ydCB7IFByb3BzIGFzIElucHV0UHJvcHMgfSBmcm9tICdAZ3JhZmFuYS91aS9zcmMvY29tcG9uZW50cy9JbnB1dC9JbnB1dCc7XG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIGV4dGVuZHMgSW5wdXRQcm9wcyB7XG4gIC8qKiBTZXRzIHRoZSBtaW4td2lkdGggdG8gYSBtdWx0aXBsZSBvZiA4cHguIERlZmF1bHQgdmFsdWUgaXMgMTAqL1xuICBtaW5XaWR0aD86IG51bWJlcjtcbiAgLyoqIFNldHMgdGhlIG1heC13aWR0aCB0byBhIG11bHRpcGxlIG9mIDhweC4qL1xuICBtYXhXaWR0aD86IG51bWJlcjtcbiAgLyoqIG9uQ2hhbmdlIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBydW4gb24gb25CbHVyIGFuZCBvbktleVByZXNzIHdpdGggZW50ZXIqL1xuICBvbkNvbW1pdENoYW5nZT86IChldmVudDogUmVhY3QuRm9ybUV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB2b2lkO1xufVxuXG5leHBvcnQgY29uc3QgQXV0b1NpemVJbnB1dCA9IFJlYWN0LmZvcndhcmRSZWY8SFRNTElucHV0RWxlbWVudCwgUHJvcHM+KChwcm9wcywgcmVmKSA9PiB7XG4gIGNvbnN0IHsgZGVmYXVsdFZhbHVlID0gJycsIG1pbldpZHRoID0gMTAsIG1heFdpZHRoLCBvbkNvbW1pdENoYW5nZSwgb25LZXlEb3duLCBvbkJsdXIsIC4uLnJlc3RQcm9wcyB9ID0gcHJvcHM7XG4gIGNvbnN0IFt2YWx1ZSwgc2V0VmFsdWVdID0gUmVhY3QudXNlU3RhdGUoZGVmYXVsdFZhbHVlKTtcbiAgY29uc3QgW2lucHV0V2lkdGgsIHNldElucHV0V2lkdGhdID0gUmVhY3QudXNlU3RhdGUobWluV2lkdGgpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2V0SW5wdXRXaWR0aChnZXRXaWR0aEZvcih2YWx1ZS50b1N0cmluZygpLCBtaW5XaWR0aCwgbWF4V2lkdGgpKTtcbiAgfSwgW3ZhbHVlLCBtYXhXaWR0aCwgbWluV2lkdGhdKTtcblxuICByZXR1cm4gKFxuICAgIDxJbnB1dFxuICAgICAgey4uLnJlc3RQcm9wc31cbiAgICAgIHJlZj17cmVmfVxuICAgICAgdmFsdWU9e3ZhbHVlLnRvU3RyaW5nKCl9XG4gICAgICBvbkNoYW5nZT17KGV2ZW50KSA9PiB7XG4gICAgICAgIHNldFZhbHVlKGV2ZW50LmN1cnJlbnRUYXJnZXQudmFsdWUpO1xuICAgICAgfX1cbiAgICAgIHdpZHRoPXtpbnB1dFdpZHRofVxuICAgICAgb25CbHVyPXsoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKG9uQ29tbWl0Q2hhbmdlKSB7XG4gICAgICAgICAgb25Db21taXRDaGFuZ2UoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkJsdXIpIHtcbiAgICAgICAgICBvbkJsdXIoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9fVxuICAgICAgb25LZXlEb3duPXsoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0VudGVyJyAmJiBvbkNvbW1pdENoYW5nZSkge1xuICAgICAgICAgIG9uQ29tbWl0Q2hhbmdlKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25LZXlEb3duKSB7XG4gICAgICAgICAgb25LZXlEb3duKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfX1cbiAgICAgIGRhdGEtdGVzdGlkPXsnYXV0b3NpemUtaW5wdXQnfVxuICAgIC8+XG4gICk7XG59KTtcblxuZnVuY3Rpb24gZ2V0V2lkdGhGb3IodmFsdWU6IHN0cmluZywgbWluV2lkdGg6IG51bWJlciwgbWF4V2lkdGg6IG51bWJlciB8IHVuZGVmaW5lZCk6IG51bWJlciB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gbWluV2lkdGg7XG4gIH1cblxuICBjb25zdCBleHRyYVNwYWNlID0gMztcbiAgY29uc3QgcmVhbFdpZHRoID0gbWVhc3VyZVRleHQodmFsdWUudG9TdHJpbmcoKSwgMTQpLndpZHRoIC8gOCArIGV4dHJhU3BhY2U7XG5cbiAgaWYgKG1pbldpZHRoICYmIHJlYWxXaWR0aCA8IG1pbldpZHRoKSB7XG4gICAgcmV0dXJuIG1pbldpZHRoO1xuICB9XG5cbiAgaWYgKG1heFdpZHRoICYmIHJlYWxXaWR0aCA+IG1heFdpZHRoKSB7XG4gICAgcmV0dXJuIHJlYWxXaWR0aDtcbiAgfVxuXG4gIHJldHVybiByZWFsV2lkdGg7XG59XG5cbkF1dG9TaXplSW5wdXQuZGlzcGxheU5hbWUgPSAnQXV0b1NpemVJbnB1dCc7XG4iLCJpbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgR3JhZmFuYVRoZW1lMiB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgU3RhY2sgfSBmcm9tICdAZ3JhZmFuYS9leHBlcmltZW50YWwnO1xuaW1wb3J0IHsgY29uZmlnIH0gZnJvbSAnQGdyYWZhbmEvcnVudGltZSc7XG5pbXBvcnQgeyBJY29uLCB1c2VTdHlsZXMyIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgZmVlZGJhY2tVcmw/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBGZWVkYmFja0xpbmsoeyBmZWVkYmFja1VybCB9OiBQcm9wcykge1xuICBjb25zdCBzdHlsZXMgPSB1c2VTdHlsZXMyKGdldFN0eWxlcyk7XG5cbiAgaWYgKCFjb25maWcuZmVlZGJhY2tMaW5rc0VuYWJsZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPFN0YWNrIGdhcD17MX0+XG4gICAgICA8YVxuICAgICAgICBocmVmPXtmZWVkYmFja1VybH1cbiAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMubGlua31cbiAgICAgICAgdGl0bGU9XCJUaGlzIHF1ZXJ5IGJ1aWxkZXIgaXMgbmV3LCBwbGVhc2UgbGV0IHVzIGtub3cgaG93IHdlIGNhbiBpbXByb3ZlIGl0XCJcbiAgICAgICAgdGFyZ2V0PVwiX2JsYW5rXCJcbiAgICAgICAgcmVsPVwibm9yZWZlcnJlciBub29wZW5lclwiXG4gICAgICA+XG4gICAgICAgIDxJY29uIG5hbWU9XCJjb21tZW50LWFsdC1tZXNzYWdlXCIgLz4gR2l2ZSBmZWVkYmFja1xuICAgICAgPC9hPlxuICAgIDwvU3RhY2s+XG4gICk7XG59XG5cbmZ1bmN0aW9uIGdldFN0eWxlcyh0aGVtZTogR3JhZmFuYVRoZW1lMikge1xuICByZXR1cm4ge1xuICAgIGxpbms6IGNzcyh7XG4gICAgICBjb2xvcjogdGhlbWUuY29sb3JzLnRleHQuc2Vjb25kYXJ5LFxuICAgICAgZm9udFNpemU6IHRoZW1lLnR5cG9ncmFwaHkuYm9keVNtYWxsLmZvbnRTaXplLFxuICAgICAgJzpob3Zlcic6IHtcbiAgICAgICAgY29sb3I6IHRoZW1lLmNvbG9ycy50ZXh0LmxpbmssXG4gICAgICB9LFxuICAgIH0pLFxuICB9O1xufVxuIiwiaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBTZWxlY3RhYmxlVmFsdWUsIHRvT3B0aW9uIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBBY2Nlc3NvcnlCdXR0b24sIElucHV0R3JvdXAgfSBmcm9tICdAZ3JhZmFuYS9leHBlcmltZW50YWwnO1xuaW1wb3J0IHsgU2VsZWN0IH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5pbXBvcnQgeyBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlciB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgZGVmYXVsdE9wOiBzdHJpbmc7XG4gIGl0ZW06IFBhcnRpYWw8UXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXI+O1xuICBvbkNoYW5nZTogKHZhbHVlOiBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcikgPT4gdm9pZDtcbiAgb25HZXRMYWJlbE5hbWVzOiAoZm9yTGFiZWw6IFBhcnRpYWw8UXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXI+KSA9PiBQcm9taXNlPFNlbGVjdGFibGVWYWx1ZVtdPjtcbiAgb25HZXRMYWJlbFZhbHVlczogKGZvckxhYmVsOiBQYXJ0aWFsPFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyPikgPT4gUHJvbWlzZTxTZWxlY3RhYmxlVmFsdWVbXT47XG4gIG9uRGVsZXRlOiAoKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gTGFiZWxGaWx0ZXJJdGVtKHsgaXRlbSwgZGVmYXVsdE9wLCBvbkNoYW5nZSwgb25EZWxldGUsIG9uR2V0TGFiZWxOYW1lcywgb25HZXRMYWJlbFZhbHVlcyB9OiBQcm9wcykge1xuICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IHVzZVN0YXRlPHtcbiAgICBsYWJlbE5hbWVzPzogU2VsZWN0YWJsZVZhbHVlW107XG4gICAgbGFiZWxWYWx1ZXM/OiBTZWxlY3RhYmxlVmFsdWVbXTtcbiAgICBpc0xvYWRpbmdMYWJlbE5hbWVzPzogYm9vbGVhbjtcbiAgICBpc0xvYWRpbmdMYWJlbFZhbHVlcz86IGJvb2xlYW47XG4gIH0+KHt9KTtcblxuICBjb25zdCBpc011bHRpU2VsZWN0ID0gKCkgPT4ge1xuICAgIHJldHVybiBpdGVtLm9wID09PSBvcGVyYXRvcnNbMF0ubGFiZWw7XG4gIH07XG5cbiAgY29uc3QgZ2V0U2VsZWN0T3B0aW9uc0Zyb21TdHJpbmcgPSAoaXRlbT86IHN0cmluZyk6IHN0cmluZ1tdID0+IHtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgaWYgKGl0ZW0uaW5kZXhPZignfCcpID4gMCkge1xuICAgICAgICByZXR1cm4gaXRlbS5zcGxpdCgnfCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtpdGVtXTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9O1xuXG4gIGNvbnN0IGdldE9wdGlvbnMgPSAoKTogU2VsZWN0YWJsZVZhbHVlW10gPT4ge1xuICAgIHJldHVybiBbLi4uZ2V0U2VsZWN0T3B0aW9uc0Zyb21TdHJpbmcoaXRlbT8udmFsdWUpLm1hcCh0b09wdGlvbiksIC4uLihzdGF0ZS5sYWJlbFZhbHVlcyA/PyBbXSldO1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBkYXRhLXRlc3RpZD1cInByb21ldGhldXMtZGltZW5zaW9ucy1maWx0ZXItaXRlbVwiPlxuICAgICAgPElucHV0R3JvdXA+XG4gICAgICAgIDxTZWxlY3RcbiAgICAgICAgICBpbnB1dElkPVwicHJvbWV0aGV1cy1kaW1lbnNpb25zLWZpbHRlci1pdGVtLWtleVwiXG4gICAgICAgICAgd2lkdGg9XCJhdXRvXCJcbiAgICAgICAgICB2YWx1ZT17aXRlbS5sYWJlbCA/IHRvT3B0aW9uKGl0ZW0ubGFiZWwpIDogbnVsbH1cbiAgICAgICAgICBhbGxvd0N1c3RvbVZhbHVlXG4gICAgICAgICAgb25PcGVuTWVudT17YXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgc2V0U3RhdGUoeyBpc0xvYWRpbmdMYWJlbE5hbWVzOiB0cnVlIH0pO1xuICAgICAgICAgICAgY29uc3QgbGFiZWxOYW1lcyA9IGF3YWl0IG9uR2V0TGFiZWxOYW1lcyhpdGVtKTtcbiAgICAgICAgICAgIHNldFN0YXRlKHsgbGFiZWxOYW1lcywgaXNMb2FkaW5nTGFiZWxOYW1lczogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgIH19XG4gICAgICAgICAgaXNMb2FkaW5nPXtzdGF0ZS5pc0xvYWRpbmdMYWJlbE5hbWVzfVxuICAgICAgICAgIG9wdGlvbnM9e3N0YXRlLmxhYmVsTmFtZXN9XG4gICAgICAgICAgb25DaGFuZ2U9eyhjaGFuZ2UpID0+IHtcbiAgICAgICAgICAgIGlmIChjaGFuZ2UubGFiZWwpIHtcbiAgICAgICAgICAgICAgb25DaGFuZ2Uoe1xuICAgICAgICAgICAgICAgIC4uLml0ZW0sXG4gICAgICAgICAgICAgICAgb3A6IGl0ZW0ub3AgPz8gZGVmYXVsdE9wLFxuICAgICAgICAgICAgICAgIGxhYmVsOiBjaGFuZ2UubGFiZWwsXG4gICAgICAgICAgICAgIH0gYXMgYW55IGFzIFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9fVxuICAgICAgICAvPlxuXG4gICAgICAgIDxTZWxlY3RcbiAgICAgICAgICB2YWx1ZT17dG9PcHRpb24oaXRlbS5vcCA/PyBkZWZhdWx0T3ApfVxuICAgICAgICAgIG9wdGlvbnM9e29wZXJhdG9yc31cbiAgICAgICAgICB3aWR0aD1cImF1dG9cIlxuICAgICAgICAgIG9uQ2hhbmdlPXsoY2hhbmdlKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hhbmdlLnZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgb25DaGFuZ2UoeyAuLi5pdGVtLCBvcDogY2hhbmdlLnZhbHVlIH0gYXMgYW55IGFzIFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9fVxuICAgICAgICAvPlxuXG4gICAgICAgIDxTZWxlY3RcbiAgICAgICAgICBpbnB1dElkPVwicHJvbWV0aGV1cy1kaW1lbnNpb25zLWZpbHRlci1pdGVtLXZhbHVlXCJcbiAgICAgICAgICB3aWR0aD1cImF1dG9cIlxuICAgICAgICAgIHZhbHVlPXtcbiAgICAgICAgICAgIGlzTXVsdGlTZWxlY3QoKVxuICAgICAgICAgICAgICA/IGdldFNlbGVjdE9wdGlvbnNGcm9tU3RyaW5nKGl0ZW0/LnZhbHVlKS5tYXAodG9PcHRpb24pXG4gICAgICAgICAgICAgIDogZ2V0U2VsZWN0T3B0aW9uc0Zyb21TdHJpbmcoaXRlbT8udmFsdWUpLm1hcCh0b09wdGlvbilbMF1cbiAgICAgICAgICB9XG4gICAgICAgICAgYWxsb3dDdXN0b21WYWx1ZVxuICAgICAgICAgIG9uT3Blbk1lbnU9e2FzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHNldFN0YXRlKHsgaXNMb2FkaW5nTGFiZWxWYWx1ZXM6IHRydWUgfSk7XG4gICAgICAgICAgICBjb25zdCBsYWJlbFZhbHVlcyA9IGF3YWl0IG9uR2V0TGFiZWxWYWx1ZXMoaXRlbSk7XG4gICAgICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICBsYWJlbFZhbHVlcyxcbiAgICAgICAgICAgICAgaXNMb2FkaW5nTGFiZWxWYWx1ZXM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH19XG4gICAgICAgICAgaXNNdWx0aT17aXNNdWx0aVNlbGVjdCgpfVxuICAgICAgICAgIGlzTG9hZGluZz17c3RhdGUuaXNMb2FkaW5nTGFiZWxWYWx1ZXN9XG4gICAgICAgICAgb3B0aW9ucz17Z2V0T3B0aW9ucygpfVxuICAgICAgICAgIG9uQ2hhbmdlPXsoY2hhbmdlKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hhbmdlLnZhbHVlKSB7XG4gICAgICAgICAgICAgIG9uQ2hhbmdlKHsgLi4uaXRlbSwgdmFsdWU6IGNoYW5nZS52YWx1ZSwgb3A6IGl0ZW0ub3AgPz8gZGVmYXVsdE9wIH0gYXMgYW55IGFzIFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNoYW5nZXMgPSBjaGFuZ2VcbiAgICAgICAgICAgICAgICAubWFwKChjaGFuZ2U6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoYW5nZS5sYWJlbDtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5qb2luKCd8Jyk7XG4gICAgICAgICAgICAgIG9uQ2hhbmdlKHsgLi4uaXRlbSwgdmFsdWU6IGNoYW5nZXMsIG9wOiBpdGVtLm9wID8/IGRlZmF1bHRPcCB9IGFzIGFueSBhcyBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfX1cbiAgICAgICAgLz5cbiAgICAgICAgPEFjY2Vzc29yeUJ1dHRvbiBhcmlhLWxhYmVsPVwicmVtb3ZlXCIgaWNvbj1cInRpbWVzXCIgdmFyaWFudD1cInNlY29uZGFyeVwiIG9uQ2xpY2s9e29uRGVsZXRlfSAvPlxuICAgICAgPC9JbnB1dEdyb3VwPlxuICAgIDwvZGl2PlxuICApO1xufVxuXG5jb25zdCBvcGVyYXRvcnMgPSBbXG4gIHsgbGFiZWw6ICc9ficsIHZhbHVlOiAnPX4nIH0sXG4gIHsgbGFiZWw6ICc9JywgdmFsdWU6ICc9JyB9LFxuICB7IGxhYmVsOiAnIT0nLCB2YWx1ZTogJyE9JyB9LFxuICB7IGxhYmVsOiAnIX4nLCB2YWx1ZTogJyF+JyB9LFxuXTtcbiIsImltcG9ydCB7IGlzRXF1YWwgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IFNlbGVjdGFibGVWYWx1ZSB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgRWRpdG9yRmllbGRHcm91cCwgRWRpdG9yTGlzdCwgRWRpdG9yRmllbGQgfSBmcm9tICdAZ3JhZmFuYS9leHBlcmltZW50YWwnO1xuXG5pbXBvcnQgeyBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlciB9IGZyb20gJy4uL3NoYXJlZC90eXBlcyc7XG5cbmltcG9ydCB7IExhYmVsRmlsdGVySXRlbSB9IGZyb20gJy4vTGFiZWxGaWx0ZXJJdGVtJztcblxuZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gIGxhYmVsc0ZpbHRlcnM6IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyW107XG4gIG9uQ2hhbmdlOiAobGFiZWxGaWx0ZXJzOiBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcltdKSA9PiB2b2lkO1xuICBvbkdldExhYmVsTmFtZXM6IChmb3JMYWJlbDogUGFydGlhbDxRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcj4pID0+IFByb21pc2U8U2VsZWN0YWJsZVZhbHVlW10+O1xuICBvbkdldExhYmVsVmFsdWVzOiAoZm9yTGFiZWw6IFBhcnRpYWw8UXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXI+KSA9PiBQcm9taXNlPFNlbGVjdGFibGVWYWx1ZVtdPjtcbiAgZXJyb3I/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBMYWJlbEZpbHRlcnMoeyBsYWJlbHNGaWx0ZXJzLCBvbkNoYW5nZSwgb25HZXRMYWJlbE5hbWVzLCBvbkdldExhYmVsVmFsdWVzLCBlcnJvciB9OiBQcm9wcykge1xuICBjb25zdCBkZWZhdWx0T3AgPSAnPSc7XG4gIGNvbnN0IFtpdGVtcywgc2V0SXRlbXNdID0gdXNlU3RhdGU8QXJyYXk8UGFydGlhbDxRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcj4+PihbeyBvcDogZGVmYXVsdE9wIH1dKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChsYWJlbHNGaWx0ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIHNldEl0ZW1zKGxhYmVsc0ZpbHRlcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRJdGVtcyhbeyBvcDogZGVmYXVsdE9wIH1dKTtcbiAgICB9XG4gIH0sIFtsYWJlbHNGaWx0ZXJzXSk7XG5cbiAgY29uc3Qgb25MYWJlbHNDaGFuZ2UgPSAobmV3SXRlbXM6IEFycmF5PFBhcnRpYWw8UXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXI+PikgPT4ge1xuICAgIHNldEl0ZW1zKG5ld0l0ZW1zKTtcblxuICAgIC8vIEV4dHJhY3QgZnVsbCBsYWJlbCBmaWx0ZXJzIHdpdGggYm90aCBsYWJlbCAmIHZhbHVlXG4gICAgY29uc3QgbmV3TGFiZWxzID0gbmV3SXRlbXMuZmlsdGVyKCh4KSA9PiB4LmxhYmVsICE9IG51bGwgJiYgeC52YWx1ZSAhPSBudWxsKTtcbiAgICBpZiAoIWlzRXF1YWwobmV3TGFiZWxzLCBsYWJlbHNGaWx0ZXJzKSkge1xuICAgICAgb25DaGFuZ2UobmV3TGFiZWxzIGFzIFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyW10pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxFZGl0b3JGaWVsZEdyb3VwPlxuICAgICAgPEVkaXRvckZpZWxkIGxhYmVsPVwiTGFiZWxzXCIgZXJyb3I9e2Vycm9yfSBpbnZhbGlkPXshIWVycm9yfT5cbiAgICAgICAgPEVkaXRvckxpc3RcbiAgICAgICAgICBpdGVtcz17aXRlbXN9XG4gICAgICAgICAgb25DaGFuZ2U9e29uTGFiZWxzQ2hhbmdlfVxuICAgICAgICAgIHJlbmRlckl0ZW09eyhpdGVtLCBvbkNoYW5nZUl0ZW0sIG9uRGVsZXRlKSA9PiAoXG4gICAgICAgICAgICA8TGFiZWxGaWx0ZXJJdGVtXG4gICAgICAgICAgICAgIGl0ZW09e2l0ZW19XG4gICAgICAgICAgICAgIGRlZmF1bHRPcD17ZGVmYXVsdE9wfVxuICAgICAgICAgICAgICBvbkNoYW5nZT17b25DaGFuZ2VJdGVtfVxuICAgICAgICAgICAgICBvbkRlbGV0ZT17b25EZWxldGV9XG4gICAgICAgICAgICAgIG9uR2V0TGFiZWxOYW1lcz17b25HZXRMYWJlbE5hbWVzfVxuICAgICAgICAgICAgICBvbkdldExhYmVsVmFsdWVzPXtvbkdldExhYmVsVmFsdWVzfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICApfVxuICAgICAgICAvPlxuICAgICAgPC9FZGl0b3JGaWVsZD5cbiAgICA8L0VkaXRvckZpZWxkR3JvdXA+XG4gICk7XG59XG4iLCJpbXBvcnQgeyBSZWdpc3RyeSB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuXG5pbXBvcnQgeyBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeSB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXIsIFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiwgUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLCBWaXN1YWxRdWVyeU1vZGVsbGVyIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmlzdWFsUXVlcnlCaW5hcnk8VD4ge1xuICBvcGVyYXRvcjogc3RyaW5nO1xuICB2ZWN0b3JNYXRjaGVzVHlwZT86ICdvbicgfCAnaWdub3JpbmcnO1xuICB2ZWN0b3JNYXRjaGVzPzogc3RyaW5nO1xuICBxdWVyeTogVDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9tTG9raVZpc3VhbFF1ZXJ5IHtcbiAgbWV0cmljPzogc3RyaW5nO1xuICBsYWJlbHM6IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyW107XG4gIG9wZXJhdGlvbnM6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbltdO1xuICBiaW5hcnlRdWVyaWVzPzogQXJyYXk8VmlzdWFsUXVlcnlCaW5hcnk8UHJvbUxva2lWaXN1YWxRdWVyeT4+O1xufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgTG9raUFuZFByb21RdWVyeU1vZGVsbGVyQmFzZSBpbXBsZW1lbnRzIFZpc3VhbFF1ZXJ5TW9kZWxsZXIge1xuICBwcm90ZWN0ZWQgb3BlcmF0aW9uc1JlZ2lzdHk6IFJlZ2lzdHJ5PFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZj47XG4gIHByaXZhdGUgY2F0ZWdvcmllczogc3RyaW5nW10gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihnZXRPcGVyYXRpb25zOiAoKSA9PiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWZbXSkge1xuICAgIHRoaXMub3BlcmF0aW9uc1JlZ2lzdHkgPSBuZXcgUmVnaXN0cnk8UXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmPihnZXRPcGVyYXRpb25zKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBzZXRPcGVyYXRpb25DYXRlZ29yaWVzKGNhdGVnb3JpZXM6IHN0cmluZ1tdKSB7XG4gICAgdGhpcy5jYXRlZ29yaWVzID0gY2F0ZWdvcmllcztcbiAgfVxuXG4gIGdldE9wZXJhdGlvbnNGb3JDYXRlZ29yeShjYXRlZ29yeTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMub3BlcmF0aW9uc1JlZ2lzdHkubGlzdCgpLmZpbHRlcigob3ApID0+IG9wLmNhdGVnb3J5ID09PSBjYXRlZ29yeSAmJiAhb3AuaGlkZUZyb21MaXN0KTtcbiAgfVxuXG4gIGdldEFsdGVybmF0aXZlT3BlcmF0aW9ucyhrZXk6IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLm9wZXJhdGlvbnNSZWdpc3R5Lmxpc3QoKS5maWx0ZXIoKG9wKSA9PiBvcC5hbHRlcm5hdGl2ZXNLZXkgPT09IGtleSk7XG4gIH1cblxuICBnZXRDYXRlZ29yaWVzKCkge1xuICAgIHJldHVybiB0aGlzLmNhdGVnb3JpZXM7XG4gIH1cblxuICBnZXRPcGVyYXRpb25EZWYoaWQ6IHN0cmluZyk6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMub3BlcmF0aW9uc1JlZ2lzdHkuZ2V0SWZFeGlzdHMoaWQpO1xuICB9XG5cbiAgcmVuZGVyT3BlcmF0aW9ucyhxdWVyeVN0cmluZzogc3RyaW5nLCBvcGVyYXRpb25zOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25bXSkge1xuICAgIGZvciAoY29uc3Qgb3BlcmF0aW9uIG9mIG9wZXJhdGlvbnMpIHtcbiAgICAgIGNvbnN0IGRlZiA9IHRoaXMub3BlcmF0aW9uc1JlZ2lzdHkuZ2V0SWZFeGlzdHMob3BlcmF0aW9uLmlkKTtcbiAgICAgIGlmICghZGVmKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgb3BlcmF0aW9uICR7b3BlcmF0aW9uLmlkfSBpbiB0aGUgcmVnaXN0cnlgKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5U3RyaW5nID0gZGVmLnJlbmRlcmVyKG9wZXJhdGlvbiwgZGVmLCBxdWVyeVN0cmluZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHF1ZXJ5U3RyaW5nO1xuICB9XG5cbiAgcmVuZGVyQmluYXJ5UXVlcmllcyhxdWVyeVN0cmluZzogc3RyaW5nLCBiaW5hcnlRdWVyaWVzPzogQXJyYXk8VmlzdWFsUXVlcnlCaW5hcnk8UHJvbUxva2lWaXN1YWxRdWVyeT4+KSB7XG4gICAgaWYgKGJpbmFyeVF1ZXJpZXMpIHtcbiAgICAgIGZvciAoY29uc3QgYmluUXVlcnkgb2YgYmluYXJ5UXVlcmllcykge1xuICAgICAgICBxdWVyeVN0cmluZyA9IGAke3RoaXMucmVuZGVyQmluYXJ5UXVlcnkocXVlcnlTdHJpbmcsIGJpblF1ZXJ5KX1gO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcXVlcnlTdHJpbmc7XG4gIH1cblxuICBwcml2YXRlIHJlbmRlckJpbmFyeVF1ZXJ5KGxlZnRPcGVyYW5kOiBzdHJpbmcsIGJpbmFyeVF1ZXJ5OiBWaXN1YWxRdWVyeUJpbmFyeTxQcm9tTG9raVZpc3VhbFF1ZXJ5Pikge1xuICAgIGxldCByZXN1bHQgPSBsZWZ0T3BlcmFuZCArIGAgJHtiaW5hcnlRdWVyeS5vcGVyYXRvcn0gYDtcblxuICAgIGlmIChiaW5hcnlRdWVyeS52ZWN0b3JNYXRjaGVzKSB7XG4gICAgICByZXN1bHQgKz0gYCR7YmluYXJ5UXVlcnkudmVjdG9yTWF0Y2hlc1R5cGV9KCR7YmluYXJ5UXVlcnkudmVjdG9yTWF0Y2hlc30pIGA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdCArIHRoaXMucmVuZGVyUXVlcnkoYmluYXJ5UXVlcnkucXVlcnksIHRydWUpO1xuICB9XG5cbiAgcmVuZGVyTGFiZWxzKGxhYmVsczogUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXJbXSkge1xuICAgIGlmIChsYWJlbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgbGV0IGV4cHIgPSAneyc7XG4gICAgZm9yIChjb25zdCBmaWx0ZXIgb2YgbGFiZWxzKSB7XG4gICAgICBpZiAoZXhwciAhPT0gJ3snKSB7XG4gICAgICAgIGV4cHIgKz0gJywgJztcbiAgICAgIH1cblxuICAgICAgZXhwciArPSBgJHtmaWx0ZXIubGFiZWx9JHtmaWx0ZXIub3B9XCIke2ZpbHRlci52YWx1ZX1cImA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cHIgKyBgfWA7XG4gIH1cblxuICByZW5kZXJRdWVyeShxdWVyeTogUHJvbUxva2lWaXN1YWxRdWVyeSwgbmVzdGVkPzogYm9vbGVhbikge1xuICAgIGxldCBxdWVyeVN0cmluZyA9IGAke3F1ZXJ5Lm1ldHJpYyA/PyAnJ30ke3RoaXMucmVuZGVyTGFiZWxzKHF1ZXJ5LmxhYmVscyl9YDtcbiAgICBxdWVyeVN0cmluZyA9IHRoaXMucmVuZGVyT3BlcmF0aW9ucyhxdWVyeVN0cmluZywgcXVlcnkub3BlcmF0aW9ucyk7XG5cbiAgICBpZiAoIW5lc3RlZCAmJiB0aGlzLmhhc0JpbmFyeU9wKHF1ZXJ5KSAmJiBCb29sZWFuKHF1ZXJ5LmJpbmFyeVF1ZXJpZXM/Lmxlbmd0aCkpIHtcbiAgICAgIHF1ZXJ5U3RyaW5nID0gYCgke3F1ZXJ5U3RyaW5nfSlgO1xuICAgIH1cblxuICAgIHF1ZXJ5U3RyaW5nID0gdGhpcy5yZW5kZXJCaW5hcnlRdWVyaWVzKHF1ZXJ5U3RyaW5nLCBxdWVyeS5iaW5hcnlRdWVyaWVzKTtcblxuICAgIGlmIChuZXN0ZWQgJiYgKHRoaXMuaGFzQmluYXJ5T3AocXVlcnkpIHx8IEJvb2xlYW4ocXVlcnkuYmluYXJ5UXVlcmllcz8ubGVuZ3RoKSkpIHtcbiAgICAgIHF1ZXJ5U3RyaW5nID0gYCgke3F1ZXJ5U3RyaW5nfSlgO1xuICAgIH1cblxuICAgIHJldHVybiBxdWVyeVN0cmluZztcbiAgfVxuXG4gIGhhc0JpbmFyeU9wKHF1ZXJ5OiBQcm9tTG9raVZpc3VhbFF1ZXJ5KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIChcbiAgICAgIHF1ZXJ5Lm9wZXJhdGlvbnMuZmluZCgob3ApID0+IHtcbiAgICAgICAgY29uc3QgZGVmID0gdGhpcy5nZXRPcGVyYXRpb25EZWYob3AuaWQpO1xuICAgICAgICByZXR1cm4gZGVmPy5jYXRlZ29yeSA9PT0gUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuQmluYXJ5T3BzO1xuICAgICAgfSkgIT09IHVuZGVmaW5lZFxuICAgICk7XG4gIH1cbn1cbiIsImltcG9ydCB7IGNzcywgY3ggfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBEcmFnZ2FibGUgfSBmcm9tICdyZWFjdC1iZWF1dGlmdWwtZG5kJztcblxuaW1wb3J0IHsgRGF0YVNvdXJjZUFwaSwgR3JhZmFuYVRoZW1lMiB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgU3RhY2sgfSBmcm9tICdAZ3JhZmFuYS9leHBlcmltZW50YWwnO1xuaW1wb3J0IHsgQnV0dG9uLCBJY29uLCBUb29sdGlwLCB1c2VTdHlsZXMyIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5pbXBvcnQge1xuICBWaXN1YWxRdWVyeU1vZGVsbGVyLFxuICBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sXG4gIFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtVmFsdWUsXG4gIFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZixcbiAgUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1EZWYsXG59IGZyb20gJy4uL3NoYXJlZC90eXBlcyc7XG5cbmltcG9ydCB7IE9wZXJhdGlvbkhlYWRlciB9IGZyb20gJy4vT3BlcmF0aW9uSGVhZGVyJztcbmltcG9ydCB7IGdldE9wZXJhdGlvblBhcmFtRWRpdG9yIH0gZnJvbSAnLi9PcGVyYXRpb25QYXJhbUVkaXRvcic7XG5pbXBvcnQgeyBnZXRPcGVyYXRpb25QYXJhbUlkIH0gZnJvbSAnLi9vcGVyYXRpb25VdGlscyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICBvcGVyYXRpb246IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbjtcbiAgaW5kZXg6IG51bWJlcjtcbiAgcXVlcnk6IGFueTtcbiAgZGF0YXNvdXJjZTogRGF0YVNvdXJjZUFwaTtcbiAgcXVlcnlNb2RlbGxlcjogVmlzdWFsUXVlcnlNb2RlbGxlcjtcbiAgb25DaGFuZ2U6IChpbmRleDogbnVtYmVyLCB1cGRhdGU6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbikgPT4gdm9pZDtcbiAgb25SZW1vdmU6IChpbmRleDogbnVtYmVyKSA9PiB2b2lkO1xuICBvblJ1blF1ZXJ5OiAoKSA9PiB2b2lkO1xuICBoaWdobGlnaHQ/OiBib29sZWFuO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gT3BlcmF0aW9uRWRpdG9yKHtcbiAgb3BlcmF0aW9uLFxuICBpbmRleCxcbiAgb25SZW1vdmUsXG4gIG9uQ2hhbmdlLFxuICBvblJ1blF1ZXJ5LFxuICBxdWVyeU1vZGVsbGVyLFxuICBxdWVyeSxcbiAgZGF0YXNvdXJjZSxcbiAgaGlnaGxpZ2h0LFxufTogUHJvcHMpIHtcbiAgY29uc3Qgc3R5bGVzID0gdXNlU3R5bGVzMihnZXRTdHlsZXMpO1xuICBjb25zdCBkZWYgPSBxdWVyeU1vZGVsbGVyLmdldE9wZXJhdGlvbkRlZihvcGVyYXRpb24uaWQpO1xuICBjb25zdCBzaG91bGRIaWdobGlnaHQgPSB1c2VIaWdobGlnaHQoaGlnaGxpZ2h0KTtcblxuICBpZiAoIWRlZikge1xuICAgIHJldHVybiA8c3Bhbj5PcGVyYXRpb24ge29wZXJhdGlvbi5pZH0gbm90IGZvdW5kPC9zcGFuPjtcbiAgfVxuXG4gIGNvbnN0IG9uUGFyYW1WYWx1ZUNoYW5nZWQgPSAocGFyYW1JZHg6IG51bWJlciwgdmFsdWU6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtVmFsdWUpID0+IHtcbiAgICBjb25zdCB1cGRhdGU6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiA9IHsgLi4ub3BlcmF0aW9uLCBwYXJhbXM6IFsuLi5vcGVyYXRpb24ucGFyYW1zXSB9O1xuICAgIHVwZGF0ZS5wYXJhbXNbcGFyYW1JZHhdID0gdmFsdWU7XG4gICAgY2FsbFBhcmFtQ2hhbmdlZFRoZW5PbkNoYW5nZShkZWYsIHVwZGF0ZSwgaW5kZXgsIHBhcmFtSWR4LCBvbkNoYW5nZSk7XG4gIH07XG5cbiAgY29uc3Qgb25BZGRSZXN0UGFyYW0gPSAoKSA9PiB7XG4gICAgY29uc3QgdXBkYXRlOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24gPSB7IC4uLm9wZXJhdGlvbiwgcGFyYW1zOiBbLi4ub3BlcmF0aW9uLnBhcmFtcywgJyddIH07XG4gICAgY2FsbFBhcmFtQ2hhbmdlZFRoZW5PbkNoYW5nZShkZWYsIHVwZGF0ZSwgaW5kZXgsIG9wZXJhdGlvbi5wYXJhbXMubGVuZ3RoLCBvbkNoYW5nZSk7XG4gIH07XG5cbiAgY29uc3Qgb25SZW1vdmVSZXN0UGFyYW0gPSAocGFyYW1JZHg6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IHVwZGF0ZTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uID0ge1xuICAgICAgLi4ub3BlcmF0aW9uLFxuICAgICAgcGFyYW1zOiBbLi4ub3BlcmF0aW9uLnBhcmFtcy5zbGljZSgwLCBwYXJhbUlkeCksIC4uLm9wZXJhdGlvbi5wYXJhbXMuc2xpY2UocGFyYW1JZHggKyAxKV0sXG4gICAgfTtcbiAgICBjYWxsUGFyYW1DaGFuZ2VkVGhlbk9uQ2hhbmdlKGRlZiwgdXBkYXRlLCBpbmRleCwgcGFyYW1JZHgsIG9uQ2hhbmdlKTtcbiAgfTtcblxuICBjb25zdCBvcGVyYXRpb25FbGVtZW50czogUmVhY3QuUmVhY3ROb2RlW10gPSBbXTtcblxuICBmb3IgKGxldCBwYXJhbUluZGV4ID0gMDsgcGFyYW1JbmRleCA8IG9wZXJhdGlvbi5wYXJhbXMubGVuZ3RoOyBwYXJhbUluZGV4KyspIHtcbiAgICBjb25zdCBwYXJhbURlZiA9IGRlZi5wYXJhbXNbTWF0aC5taW4oZGVmLnBhcmFtcy5sZW5ndGggLSAxLCBwYXJhbUluZGV4KV07XG4gICAgY29uc3QgRWRpdG9yID0gZ2V0T3BlcmF0aW9uUGFyYW1FZGl0b3IocGFyYW1EZWYpO1xuXG4gICAgb3BlcmF0aW9uRWxlbWVudHMucHVzaChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMucGFyYW1Sb3d9IGtleT17YCR7cGFyYW1JbmRleH0tMWB9PlxuICAgICAgICB7IXBhcmFtRGVmLmhpZGVOYW1lICYmIChcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnBhcmFtTmFtZX0+XG4gICAgICAgICAgICA8bGFiZWwgaHRtbEZvcj17Z2V0T3BlcmF0aW9uUGFyYW1JZChpbmRleCwgcGFyYW1JbmRleCl9PntwYXJhbURlZi5uYW1lfTwvbGFiZWw+XG4gICAgICAgICAgICB7cGFyYW1EZWYuZGVzY3JpcHRpb24gJiYgKFxuICAgICAgICAgICAgICA8VG9vbHRpcCBwbGFjZW1lbnQ9XCJ0b3BcIiBjb250ZW50PXtwYXJhbURlZi5kZXNjcmlwdGlvbn0gdGhlbWU9XCJpbmZvXCI+XG4gICAgICAgICAgICAgICAgPEljb24gbmFtZT1cImluZm8tY2lyY2xlXCIgc2l6ZT1cInNtXCIgY2xhc3NOYW1lPXtzdHlsZXMuaW5mb0ljb259IC8+XG4gICAgICAgICAgICAgIDwvVG9vbHRpcD5cbiAgICAgICAgICAgICl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICl9XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMucGFyYW1WYWx1ZX0+XG4gICAgICAgICAgPFN0YWNrIGdhcD17MC41fSBkaXJlY3Rpb249XCJyb3dcIiBhbGlnbkl0ZW1zPVwiY2VudGVyXCIgd3JhcD17ZmFsc2V9PlxuICAgICAgICAgICAgPEVkaXRvclxuICAgICAgICAgICAgICBpbmRleD17cGFyYW1JbmRleH1cbiAgICAgICAgICAgICAgcGFyYW1EZWY9e3BhcmFtRGVmfVxuICAgICAgICAgICAgICB2YWx1ZT17b3BlcmF0aW9uLnBhcmFtc1twYXJhbUluZGV4XX1cbiAgICAgICAgICAgICAgb3BlcmF0aW9uPXtvcGVyYXRpb259XG4gICAgICAgICAgICAgIG9wZXJhdGlvbkluZGV4PXtpbmRleH1cbiAgICAgICAgICAgICAgb25DaGFuZ2U9e29uUGFyYW1WYWx1ZUNoYW5nZWR9XG4gICAgICAgICAgICAgIG9uUnVuUXVlcnk9e29uUnVuUXVlcnl9XG4gICAgICAgICAgICAgIHF1ZXJ5PXtxdWVyeX1cbiAgICAgICAgICAgICAgZGF0YXNvdXJjZT17ZGF0YXNvdXJjZX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICB7cGFyYW1EZWYucmVzdFBhcmFtICYmIChvcGVyYXRpb24ucGFyYW1zLmxlbmd0aCA+IGRlZi5wYXJhbXMubGVuZ3RoIHx8IHBhcmFtRGVmLm9wdGlvbmFsKSAmJiAoXG4gICAgICAgICAgICAgIDxCdXR0b25cbiAgICAgICAgICAgICAgICBkYXRhLXRlc3RpZD17YG9wZXJhdGlvbnMuJHtpbmRleH0ucmVtb3ZlLXJlc3QtcGFyYW1gfVxuICAgICAgICAgICAgICAgIHNpemU9XCJzbVwiXG4gICAgICAgICAgICAgICAgZmlsbD1cInRleHRcIlxuICAgICAgICAgICAgICAgIGljb249XCJ0aW1lc1wiXG4gICAgICAgICAgICAgICAgdmFyaWFudD1cInNlY29uZGFyeVwiXG4gICAgICAgICAgICAgICAgdGl0bGU9e2BSZW1vdmUgJHtwYXJhbURlZi5uYW1lfWB9XG4gICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gb25SZW1vdmVSZXN0UGFyYW0ocGFyYW1JbmRleCl9XG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICApfVxuICAgICAgICAgIDwvU3RhY2s+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIC8vIEhhbmRsZSBhZGRpbmcgYnV0dG9uIGZvciByZXN0IHBhcmFtc1xuICBsZXQgcmVzdFBhcmFtOiBSZWFjdC5SZWFjdE5vZGUgfCB1bmRlZmluZWQ7XG4gIGlmIChkZWYucGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBsYXN0UGFyYW1EZWYgPSBkZWYucGFyYW1zW2RlZi5wYXJhbXMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGxhc3RQYXJhbURlZi5yZXN0UGFyYW0pIHtcbiAgICAgIHJlc3RQYXJhbSA9IHJlbmRlckFkZFJlc3RQYXJhbUJ1dHRvbihsYXN0UGFyYW1EZWYsIG9uQWRkUmVzdFBhcmFtLCBpbmRleCwgb3BlcmF0aW9uLnBhcmFtcy5sZW5ndGgsIHN0eWxlcyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8RHJhZ2dhYmxlIGRyYWdnYWJsZUlkPXtgb3BlcmF0aW9uLSR7aW5kZXh9YH0gaW5kZXg9e2luZGV4fT5cbiAgICAgIHsocHJvdmlkZWQpID0+IChcbiAgICAgICAgPGRpdlxuICAgICAgICAgIGNsYXNzTmFtZT17Y3goc3R5bGVzLmNhcmQsIHNob3VsZEhpZ2hsaWdodCAmJiBzdHlsZXMuY2FyZEhpZ2hsaWdodCl9XG4gICAgICAgICAgcmVmPXtwcm92aWRlZC5pbm5lclJlZn1cbiAgICAgICAgICB7Li4ucHJvdmlkZWQuZHJhZ2dhYmxlUHJvcHN9XG4gICAgICAgICAgZGF0YS10ZXN0aWQ9e2BvcGVyYXRpb25zLiR7aW5kZXh9LndyYXBwZXJgfVxuICAgICAgICA+XG4gICAgICAgICAgPE9wZXJhdGlvbkhlYWRlclxuICAgICAgICAgICAgb3BlcmF0aW9uPXtvcGVyYXRpb259XG4gICAgICAgICAgICBkcmFnSGFuZGxlUHJvcHM9e3Byb3ZpZGVkLmRyYWdIYW5kbGVQcm9wc31cbiAgICAgICAgICAgIGRlZj17ZGVmfVxuICAgICAgICAgICAgaW5kZXg9e2luZGV4fVxuICAgICAgICAgICAgb25DaGFuZ2U9e29uQ2hhbmdlfVxuICAgICAgICAgICAgb25SZW1vdmU9e29uUmVtb3ZlfVxuICAgICAgICAgICAgcXVlcnlNb2RlbGxlcj17cXVlcnlNb2RlbGxlcn1cbiAgICAgICAgICAvPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuYm9keX0+e29wZXJhdGlvbkVsZW1lbnRzfTwvZGl2PlxuICAgICAgICAgIHtyZXN0UGFyYW19XG4gICAgICAgICAge2luZGV4IDwgcXVlcnkub3BlcmF0aW9ucy5sZW5ndGggLSAxICYmIChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuYXJyb3d9PlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmFycm93TGluZX0gLz5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5hcnJvd0Fycm93fSAvPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgKX1cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuICAgIDwvRHJhZ2dhYmxlPlxuICApO1xufVxuXG4vKipcbiAqIFdoZW4gaGlnaGxpZ2h0IGlzIHN3aXRjaGVkIG9uIG1ha2VzIHN1cmUgaXQgaXMgc3dpdGNoZWQgb2YgcmlnaHQgYXdheSwgc28gd2UganVzdCBmbGFzaCB0aGUgaGlnaGxpZ2h0IGFuZCB0aGVuIGZhZGVcbiAqIG91dC5cbiAqIEBwYXJhbSBoaWdobGlnaHRcbiAqL1xuZnVuY3Rpb24gdXNlSGlnaGxpZ2h0KGhpZ2hsaWdodD86IGJvb2xlYW4pIHtcbiAgY29uc3QgW2tlZXBIaWdobGlnaHQsIHNldEtlZXBIaWdobGlnaHRdID0gdXNlU3RhdGUodHJ1ZSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IHQ6IGFueTtcbiAgICBpZiAoaGlnaGxpZ2h0KSB7XG4gICAgICB0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHNldEtlZXBIaWdobGlnaHQoZmFsc2UpO1xuICAgICAgfSwgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldEtlZXBIaWdobGlnaHQodHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dCh0KTtcbiAgfSwgW2hpZ2hsaWdodF0pO1xuXG4gIHJldHVybiBrZWVwSGlnaGxpZ2h0ICYmIGhpZ2hsaWdodDtcbn1cblxuZnVuY3Rpb24gcmVuZGVyQWRkUmVzdFBhcmFtQnV0dG9uKFxuICBwYXJhbURlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1EZWYsXG4gIG9uQWRkUmVzdFBhcmFtOiAoKSA9PiB2b2lkLFxuICBvcGVyYXRpb25JbmRleDogbnVtYmVyLFxuICBwYXJhbUluZGV4OiBudW1iZXIsXG4gIHN0eWxlczogT3BlcmF0aW9uRWRpdG9yU3R5bGVzXG4pIHtcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnJlc3RQYXJhbX0ga2V5PXtgJHtwYXJhbUluZGV4fS0yYH0+XG4gICAgICA8QnV0dG9uXG4gICAgICAgIHNpemU9XCJzbVwiXG4gICAgICAgIGljb249XCJwbHVzXCJcbiAgICAgICAgdGl0bGU9e2BBZGQgJHtwYXJhbURlZi5uYW1lfWB9XG4gICAgICAgIHZhcmlhbnQ9XCJzZWNvbmRhcnlcIlxuICAgICAgICBvbkNsaWNrPXtvbkFkZFJlc3RQYXJhbX1cbiAgICAgICAgZGF0YS10ZXN0aWQ9e2BvcGVyYXRpb25zLiR7b3BlcmF0aW9uSW5kZXh9LmFkZC1yZXN0LXBhcmFtYH1cbiAgICAgID5cbiAgICAgICAge3BhcmFtRGVmLm5hbWV9XG4gICAgICA8L0J1dHRvbj5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuZnVuY3Rpb24gY2FsbFBhcmFtQ2hhbmdlZFRoZW5PbkNoYW5nZShcbiAgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsXG4gIG9wZXJhdGlvbjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLFxuICBvcGVyYXRpb25JbmRleDogbnVtYmVyLFxuICBwYXJhbUluZGV4OiBudW1iZXIsXG4gIG9uQ2hhbmdlOiAoaW5kZXg6IG51bWJlciwgdXBkYXRlOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24pID0+IHZvaWRcbikge1xuICBpZiAoZGVmLnBhcmFtQ2hhbmdlZEhhbmRsZXIpIHtcbiAgICBvbkNoYW5nZShvcGVyYXRpb25JbmRleCwgZGVmLnBhcmFtQ2hhbmdlZEhhbmRsZXIocGFyYW1JbmRleCwgb3BlcmF0aW9uLCBkZWYpKTtcbiAgfSBlbHNlIHtcbiAgICBvbkNoYW5nZShvcGVyYXRpb25JbmRleCwgb3BlcmF0aW9uKTtcbiAgfVxufVxuXG5jb25zdCBnZXRTdHlsZXMgPSAodGhlbWU6IEdyYWZhbmFUaGVtZTIpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBjYXJkOiBjc3Moe1xuICAgICAgYmFja2dyb3VuZDogdGhlbWUuY29sb3JzLmJhY2tncm91bmQucHJpbWFyeSxcbiAgICAgIGJvcmRlcjogYDFweCBzb2xpZCAke3RoZW1lLmNvbG9ycy5ib3JkZXIubWVkaXVtfWAsXG4gICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICBmbGV4RGlyZWN0aW9uOiAnY29sdW1uJyxcbiAgICAgIGN1cnNvcjogJ2dyYWInLFxuICAgICAgYm9yZGVyUmFkaXVzOiB0aGVtZS5zaGFwZS5ib3JkZXJSYWRpdXMoMSksXG4gICAgICBtYXJnaW5Cb3R0b206IHRoZW1lLnNwYWNpbmcoMSksXG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgIHRyYW5zaXRpb246ICdhbGwgMXMgZWFzZS1pbiAwcycsXG4gICAgfSksXG4gICAgY2FyZEhpZ2hsaWdodDogY3NzKHtcbiAgICAgIGJveFNoYWRvdzogYDBweCAwcHggNHB4IDBweCAke3RoZW1lLmNvbG9ycy5wcmltYXJ5LmJvcmRlcn1gLFxuICAgICAgYm9yZGVyOiBgMXB4IHNvbGlkICR7dGhlbWUuY29sb3JzLnByaW1hcnkuYm9yZGVyfWAsXG4gICAgfSksXG4gICAgaW5mb0ljb246IGNzcyh7XG4gICAgICBtYXJnaW5MZWZ0OiB0aGVtZS5zcGFjaW5nKDAuNSksXG4gICAgICBjb2xvcjogdGhlbWUuY29sb3JzLnRleHQuc2Vjb25kYXJ5LFxuICAgICAgJzpob3Zlcic6IHtcbiAgICAgICAgY29sb3I6IHRoZW1lLmNvbG9ycy50ZXh0LnByaW1hcnksXG4gICAgICB9LFxuICAgIH0pLFxuICAgIGJvZHk6IGNzcyh7XG4gICAgICBtYXJnaW46IHRoZW1lLnNwYWNpbmcoMSwgMSwgMC41LCAxKSxcbiAgICAgIGRpc3BsYXk6ICd0YWJsZScsXG4gICAgfSksXG4gICAgcGFyYW1Sb3c6IGNzcyh7XG4gICAgICBsYWJlbDogJ3BhcmFtUm93JyxcbiAgICAgIGRpc3BsYXk6ICd0YWJsZS1yb3cnLFxuICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZScsXG4gICAgfSksXG4gICAgcGFyYW1OYW1lOiBjc3Moe1xuICAgICAgZGlzcGxheTogJ3RhYmxlLWNlbGwnLFxuICAgICAgcGFkZGluZzogdGhlbWUuc3BhY2luZygwLCAxLCAwLCAwKSxcbiAgICAgIGZvbnRTaXplOiB0aGVtZS50eXBvZ3JhcGh5LmJvZHlTbWFsbC5mb250U2l6ZSxcbiAgICAgIGZvbnRXZWlnaHQ6IHRoZW1lLnR5cG9ncmFwaHkuZm9udFdlaWdodE1lZGl1bSxcbiAgICAgIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICAgICAgaGVpZ2h0OiAnMzJweCcsXG4gICAgfSksXG4gICAgcGFyYW1WYWx1ZTogY3NzKHtcbiAgICAgIGxhYmVsOiAncGFyYW1WYWx1ZScsXG4gICAgICBkaXNwbGF5OiAndGFibGUtY2VsbCcsXG4gICAgICB2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJyxcbiAgICB9KSxcbiAgICByZXN0UGFyYW06IGNzcyh7XG4gICAgICBwYWRkaW5nOiB0aGVtZS5zcGFjaW5nKDAsIDEsIDEsIDEpLFxuICAgIH0pLFxuICAgIGFycm93OiBjc3Moe1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICB0b3A6ICcwJyxcbiAgICAgIHJpZ2h0OiAnLTE4cHgnLFxuICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgIH0pLFxuICAgIGFycm93TGluZTogY3NzKHtcbiAgICAgIGhlaWdodDogJzJweCcsXG4gICAgICB3aWR0aDogJzhweCcsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoZW1lLmNvbG9ycy5ib3JkZXIuc3Ryb25nLFxuICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICB0b3A6ICcxNHB4JyxcbiAgICB9KSxcbiAgICBhcnJvd0Fycm93OiBjc3Moe1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDAsXG4gICAgICBib3JkZXJUb3A6IGA1cHggc29saWQgdHJhbnNwYXJlbnRgLFxuICAgICAgYm9yZGVyQm90dG9tOiBgNXB4IHNvbGlkIHRyYW5zcGFyZW50YCxcbiAgICAgIGJvcmRlckxlZnQ6IGA3cHggc29saWQgJHt0aGVtZS5jb2xvcnMuYm9yZGVyLnN0cm9uZ31gLFxuICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICB0b3A6ICcxMHB4JyxcbiAgICB9KSxcbiAgfTtcbn07XG5cbnR5cGUgT3BlcmF0aW9uRWRpdG9yU3R5bGVzID0gUmV0dXJuVHlwZTx0eXBlb2YgZ2V0U3R5bGVzPjtcbiIsImltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBHcmFmYW5hVGhlbWUyLCByZW5kZXJNYXJrZG93biB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgdXNlU3R5bGVzMiB9IGZyb20gJ0BncmFmYW5hL3VpJztcblxuZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlO1xuICBtYXJrZG93bj86IHN0cmluZztcbiAgc3RlcE51bWJlcjogbnVtYmVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gT3BlcmF0aW9uRXhwbGFpbmVkQm94KHsgdGl0bGUsIHN0ZXBOdW1iZXIsIG1hcmtkb3duLCBjaGlsZHJlbiB9OiBQcm9wcykge1xuICBjb25zdCBzdHlsZXMgPSB1c2VTdHlsZXMyKGdldFN0eWxlcyk7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmJveH0+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnN0ZXBOdW1iZXJ9PntzdGVwTnVtYmVyfTwvZGl2PlxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5ib3hJbm5lcn0+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuaGVhZGVyfT5cbiAgICAgICAgICA8c3Bhbj57dGl0bGV9PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5ib2R5fT5cbiAgICAgICAgICB7bWFya2Rvd24gJiYgPGRpdiBkYW5nZXJvdXNseVNldElubmVySFRNTD17eyBfX2h0bWw6IHJlbmRlck1hcmtkb3duKG1hcmtkb3duKSB9fT48L2Rpdj59XG4gICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufVxuXG5jb25zdCBnZXRTdHlsZXMgPSAodGhlbWU6IEdyYWZhbmFUaGVtZTIpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBib3g6IGNzcyh7XG4gICAgICBiYWNrZ3JvdW5kOiB0aGVtZS5jb2xvcnMuYmFja2dyb3VuZC5zZWNvbmRhcnksXG4gICAgICBwYWRkaW5nOiB0aGVtZS5zcGFjaW5nKDEpLFxuICAgICAgYm9yZGVyUmFkaXVzOiB0aGVtZS5zaGFwZS5ib3JkZXJSYWRpdXMoKSxcbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgbWFyZ2luQm90dG9tOiB0aGVtZS5zcGFjaW5nKDAuNSksXG4gICAgfSksXG4gICAgYm94SW5uZXI6IGNzcyh7XG4gICAgICBtYXJnaW5MZWZ0OiB0aGVtZS5zcGFjaW5nKDQpLFxuICAgIH0pLFxuICAgIHN0ZXBOdW1iZXI6IGNzcyh7XG4gICAgICBmb250V2VpZ2h0OiB0aGVtZS50eXBvZ3JhcGh5LmZvbnRXZWlnaHRNZWRpdW0sXG4gICAgICBiYWNrZ3JvdW5kOiB0aGVtZS5jb2xvcnMuc2Vjb25kYXJ5Lm1haW4sXG4gICAgICB3aWR0aDogJzIwcHgnLFxuICAgICAgaGVpZ2h0OiAnMjBweCcsXG4gICAgICBib3JkZXJSYWRpdXM6ICc1MCUnLFxuICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIHRvcDogJzEwcHgnLFxuICAgICAgbGVmdDogJzExcHgnLFxuICAgICAgZm9udFNpemU6IHRoZW1lLnR5cG9ncmFwaHkuYm9keVNtYWxsLmZvbnRTaXplLFxuICAgIH0pLFxuICAgIGhlYWRlcjogY3NzKHtcbiAgICAgIHBhZGRpbmdCb3R0b206IHRoZW1lLnNwYWNpbmcoMC41KSxcbiAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAgZm9udEZhbWlseTogdGhlbWUudHlwb2dyYXBoeS5mb250RmFtaWx5TW9ub3NwYWNlLFxuICAgIH0pLFxuICAgIGJvZHk6IGNzcyh7XG4gICAgICBjb2xvcjogdGhlbWUuY29sb3JzLnRleHQuc2Vjb25kYXJ5LFxuICAgICAgJ3A6bGFzdC1jaGlsZCc6IHtcbiAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgfSxcbiAgICAgIGE6IHtcbiAgICAgICAgY29sb3I6IHRoZW1lLmNvbG9ycy50ZXh0LmxpbmssXG4gICAgICAgIHRleHREZWNvcmF0aW9uOiAndW5kZXJsaW5lJyxcbiAgICAgIH0sXG4gICAgfSksXG4gIH07XG59O1xuIiwiaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgR3JhZmFuYVRoZW1lMiwgU2VsZWN0YWJsZVZhbHVlIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBGbGV4SXRlbSB9IGZyb20gJ0BncmFmYW5hL2V4cGVyaW1lbnRhbCc7XG5pbXBvcnQgeyBCdXR0b24sIFNlbGVjdCwgdXNlU3R5bGVzMiB9IGZyb20gJ0BncmFmYW5hL3VpJztcblxuaW1wb3J0IHsgT3BlcmF0aW9uSW5mb0J1dHRvbiB9IGZyb20gJy4vT3BlcmF0aW9uSW5mb0J1dHRvbic7XG5pbXBvcnQgeyBWaXN1YWxRdWVyeU1vZGVsbGVyLCBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sIFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgb3BlcmF0aW9uOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb247XG4gIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmO1xuICBpbmRleDogbnVtYmVyO1xuICBxdWVyeU1vZGVsbGVyOiBWaXN1YWxRdWVyeU1vZGVsbGVyO1xuICBkcmFnSGFuZGxlUHJvcHM6IGFueTtcbiAgb25DaGFuZ2U6IChpbmRleDogbnVtYmVyLCB1cGRhdGU6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbikgPT4gdm9pZDtcbiAgb25SZW1vdmU6IChpbmRleDogbnVtYmVyKSA9PiB2b2lkO1xufVxuXG5pbnRlcmZhY2UgU3RhdGUge1xuICBpc09wZW4/OiBib29sZWFuO1xuICBhbHRlcm5hdGl2ZXM/OiBBcnJheTxTZWxlY3RhYmxlVmFsdWU8UXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmPj47XG59XG5cbmV4cG9ydCBjb25zdCBPcGVyYXRpb25IZWFkZXIgPSBSZWFjdC5tZW1vPFByb3BzPihcbiAgKHsgb3BlcmF0aW9uLCBkZWYsIGluZGV4LCBvbkNoYW5nZSwgb25SZW1vdmUsIHF1ZXJ5TW9kZWxsZXIsIGRyYWdIYW5kbGVQcm9wcyB9KSA9PiB7XG4gICAgY29uc3Qgc3R5bGVzID0gdXNlU3R5bGVzMihnZXRTdHlsZXMpO1xuICAgIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gdXNlU3RhdGU8U3RhdGU+KHt9KTtcblxuICAgIGNvbnN0IG9uVG9nZ2xlU3dpdGNoZXIgPSAoKSA9PiB7XG4gICAgICBpZiAoc3RhdGUuaXNPcGVuKSB7XG4gICAgICAgIHNldFN0YXRlKHsgLi4uc3RhdGUsIGlzT3BlbjogZmFsc2UgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBhbHRlcm5hdGl2ZXMgPSBxdWVyeU1vZGVsbGVyXG4gICAgICAgICAgLmdldEFsdGVybmF0aXZlT3BlcmF0aW9ucyhkZWYuYWx0ZXJuYXRpdmVzS2V5ISlcbiAgICAgICAgICAubWFwKChhbHQpID0+ICh7IGxhYmVsOiBhbHQubmFtZSwgdmFsdWU6IGFsdCB9KSk7XG4gICAgICAgIHNldFN0YXRlKHsgaXNPcGVuOiB0cnVlLCBhbHRlcm5hdGl2ZXMgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmhlYWRlcn0+XG4gICAgICAgIHshc3RhdGUuaXNPcGVuICYmIChcbiAgICAgICAgICA8PlxuICAgICAgICAgICAgPGRpdiB7Li4uZHJhZ0hhbmRsZVByb3BzfT57ZGVmLm5hbWUgPz8gZGVmLmlkfTwvZGl2PlxuICAgICAgICAgICAgPEZsZXhJdGVtIGdyb3c9ezF9IC8+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7c3R5bGVzLm9wZXJhdGlvbkhlYWRlckJ1dHRvbnN9IG9wZXJhdGlvbi1oZWFkZXItc2hvdy1vbi1ob3ZlcmB9PlxuICAgICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgICAgaWNvbj1cImFuZ2xlLWRvd25cIlxuICAgICAgICAgICAgICAgIHNpemU9XCJzbVwiXG4gICAgICAgICAgICAgICAgb25DbGljaz17b25Ub2dnbGVTd2l0Y2hlcn1cbiAgICAgICAgICAgICAgICBmaWxsPVwidGV4dFwiXG4gICAgICAgICAgICAgICAgdmFyaWFudD1cInNlY29uZGFyeVwiXG4gICAgICAgICAgICAgICAgdGl0bGU9XCJDbGljayB0byB2aWV3IGFsdGVybmF0aXZlIG9wZXJhdGlvbnNcIlxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8T3BlcmF0aW9uSW5mb0J1dHRvbiBkZWY9e2RlZn0gb3BlcmF0aW9uPXtvcGVyYXRpb259IC8+XG4gICAgICAgICAgICAgIDxCdXR0b25cbiAgICAgICAgICAgICAgICBpY29uPVwidGltZXNcIlxuICAgICAgICAgICAgICAgIHNpemU9XCJzbVwiXG4gICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gb25SZW1vdmUoaW5kZXgpfVxuICAgICAgICAgICAgICAgIGZpbGw9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICB2YXJpYW50PVwic2Vjb25kYXJ5XCJcbiAgICAgICAgICAgICAgICB0aXRsZT1cIlJlbW92ZSBvcGVyYXRpb25cIlxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC8+XG4gICAgICAgICl9XG4gICAgICAgIHtzdGF0ZS5pc09wZW4gJiYgKFxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuc2VsZWN0V3JhcHBlcn0+XG4gICAgICAgICAgICA8U2VsZWN0XG4gICAgICAgICAgICAgIGF1dG9Gb2N1c1xuICAgICAgICAgICAgICBvcGVuTWVudU9uRm9jdXNcbiAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJSZXBsYWNlIHdpdGhcIlxuICAgICAgICAgICAgICBvcHRpb25zPXtzdGF0ZS5hbHRlcm5hdGl2ZXN9XG4gICAgICAgICAgICAgIGlzT3Blbj17dHJ1ZX1cbiAgICAgICAgICAgICAgb25DbG9zZU1lbnU9e29uVG9nZ2xlU3dpdGNoZXJ9XG4gICAgICAgICAgICAgIG9uQ2hhbmdlPXsodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIC8vIE9wZXJhdGlvbiBzaG91bGQgZXhpc3QgaWYgaXQgaXMgc2VsZWN0YWJsZVxuICAgICAgICAgICAgICAgICAgY29uc3QgbmV3RGVmID0gcXVlcnlNb2RlbGxlci5nZXRPcGVyYXRpb25EZWYodmFsdWUudmFsdWUuaWQpITtcbiAgICAgICAgICAgICAgICAgIGxldCBjaGFuZ2VkT3AgPSB7IC4uLm9wZXJhdGlvbiwgaWQ6IHZhbHVlLnZhbHVlLmlkIH07XG4gICAgICAgICAgICAgICAgICBvbkNoYW5nZShpbmRleCwgZGVmLmNoYW5nZVR5cGVIYW5kbGVyID8gZGVmLmNoYW5nZVR5cGVIYW5kbGVyKGNoYW5nZWRPcCwgbmV3RGVmKSA6IGNoYW5nZWRPcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKX1cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbik7XG5cbk9wZXJhdGlvbkhlYWRlci5kaXNwbGF5TmFtZSA9ICdPcGVyYXRpb25IZWFkZXInO1xuXG5jb25zdCBnZXRTdHlsZXMgPSAodGhlbWU6IEdyYWZhbmFUaGVtZTIpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBoZWFkZXI6IGNzcyh7XG4gICAgICBib3JkZXJCb3R0b206IGAxcHggc29saWQgJHt0aGVtZS5jb2xvcnMuYm9yZGVyLm1lZGl1bX1gLFxuICAgICAgcGFkZGluZzogdGhlbWUuc3BhY2luZygwLjUsIDAuNSwgMC41LCAxKSxcbiAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAgJyY6aG92ZXIgLm9wZXJhdGlvbi1oZWFkZXItc2hvdy1vbi1ob3Zlcic6IGNzcyh7XG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICB9KSxcbiAgICB9KSxcbiAgICBvcGVyYXRpb25IZWFkZXJCdXR0b25zOiBjc3Moe1xuICAgICAgb3BhY2l0eTogMCxcbiAgICAgIHRyYW5zaXRpb246IHRoZW1lLnRyYW5zaXRpb25zLmNyZWF0ZShbJ29wYWNpdHknXSwge1xuICAgICAgICBkdXJhdGlvbjogdGhlbWUudHJhbnNpdGlvbnMuZHVyYXRpb24uc2hvcnQsXG4gICAgICB9KSxcbiAgICB9KSxcbiAgICBzZWxlY3RXcmFwcGVyOiBjc3Moe1xuICAgICAgcGFkZGluZ1JpZ2h0OiB0aGVtZS5zcGFjaW5nKDIpLFxuICAgIH0pLFxuICB9O1xufTtcbiIsImltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VQb3BwZXJUb29sdGlwIH0gZnJvbSAncmVhY3QtcG9wcGVyLXRvb2x0aXAnO1xuXG5pbXBvcnQgeyBHcmFmYW5hVGhlbWUyLCByZW5kZXJNYXJrZG93biB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgRmxleEl0ZW0gfSBmcm9tICdAZ3JhZmFuYS9leHBlcmltZW50YWwnO1xuaW1wb3J0IHsgQnV0dG9uLCBQb3J0YWwsIHVzZVN0eWxlczIgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5cbmltcG9ydCB7IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiwgUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICBvcGVyYXRpb246IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbjtcbiAgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWY7XG59XG5cbmV4cG9ydCBjb25zdCBPcGVyYXRpb25JbmZvQnV0dG9uID0gUmVhY3QubWVtbzxQcm9wcz4oKHsgZGVmLCBvcGVyYXRpb24gfSkgPT4ge1xuICBjb25zdCBzdHlsZXMgPSB1c2VTdHlsZXMyKGdldFN0eWxlcyk7XG4gIGNvbnN0IFtzaG93LCBzZXRTaG93XSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgeyBnZXRUb29sdGlwUHJvcHMsIHNldFRvb2x0aXBSZWYsIHNldFRyaWdnZXJSZWYsIHZpc2libGUgfSA9IHVzZVBvcHBlclRvb2x0aXAoe1xuICAgIHBsYWNlbWVudDogJ3RvcCcsXG4gICAgdmlzaWJsZTogc2hvdyxcbiAgICBvZmZzZXQ6IFswLCAxNl0sXG4gICAgb25WaXNpYmxlQ2hhbmdlOiBzZXRTaG93LFxuICAgIGludGVyYWN0aXZlOiB0cnVlLFxuICAgIHRyaWdnZXI6IFsnY2xpY2snXSxcbiAgfSk7XG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPEJ1dHRvblxuICAgICAgICB0aXRsZT1cIkNsaWNrIHRvIHNob3cgZGVzY3JpcHRpb25cIlxuICAgICAgICByZWY9e3NldFRyaWdnZXJSZWZ9XG4gICAgICAgIGljb249XCJpbmZvLWNpcmNsZVwiXG4gICAgICAgIHNpemU9XCJzbVwiXG4gICAgICAgIHZhcmlhbnQ9XCJzZWNvbmRhcnlcIlxuICAgICAgICBmaWxsPVwidGV4dFwiXG4gICAgICAvPlxuICAgICAge3Zpc2libGUgJiYgKFxuICAgICAgICA8UG9ydGFsPlxuICAgICAgICAgIDxkaXYgcmVmPXtzZXRUb29sdGlwUmVmfSB7Li4uZ2V0VG9vbHRpcFByb3BzKCl9IGNsYXNzTmFtZT17c3R5bGVzLmRvY0JveH0+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmRvY0JveEhlYWRlcn0+XG4gICAgICAgICAgICAgIDxzcGFuPntkZWYucmVuZGVyZXIob3BlcmF0aW9uLCBkZWYsICc8ZXhwcj4nKX08L3NwYW4+XG4gICAgICAgICAgICAgIDxGbGV4SXRlbSBncm93PXsxfSAvPlxuICAgICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgICAgaWNvbj1cInRpbWVzXCJcbiAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRTaG93KGZhbHNlKX1cbiAgICAgICAgICAgICAgICBmaWxsPVwidGV4dFwiXG4gICAgICAgICAgICAgICAgdmFyaWFudD1cInNlY29uZGFyeVwiXG4gICAgICAgICAgICAgICAgdGl0bGU9XCJSZW1vdmUgb3BlcmF0aW9uXCJcbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5kb2NCb3hCb2R5fVxuICAgICAgICAgICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTD17eyBfX2h0bWw6IGdldE9wZXJhdGlvbkRvY3MoZGVmLCBvcGVyYXRpb24pIH19XG4gICAgICAgICAgICA+PC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvUG9ydGFsPlxuICAgICAgKX1cbiAgICA8Lz5cbiAgKTtcbn0pO1xuXG5PcGVyYXRpb25JbmZvQnV0dG9uLmRpc3BsYXlOYW1lID0gJ09wZXJhdGlvbkRvY3MnO1xuXG5jb25zdCBnZXRTdHlsZXMgPSAodGhlbWU6IEdyYWZhbmFUaGVtZTIpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBkb2NCb3g6IGNzcyh7XG4gICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICBiYWNrZ3JvdW5kOiB0aGVtZS5jb2xvcnMuYmFja2dyb3VuZC5wcmltYXJ5LFxuICAgICAgYm9yZGVyOiBgMXB4IHNvbGlkICR7dGhlbWUuY29sb3JzLmJvcmRlci5zdHJvbmd9YCxcbiAgICAgIGJveFNoYWRvdzogdGhlbWUuc2hhZG93cy56MyxcbiAgICAgIG1heFdpZHRoOiAnNjAwcHgnLFxuICAgICAgcGFkZGluZzogdGhlbWUuc3BhY2luZygxKSxcbiAgICAgIGJvcmRlclJhZGl1czogdGhlbWUuc2hhcGUuYm9yZGVyUmFkaXVzKCksXG4gICAgICB6SW5kZXg6IHRoZW1lLnpJbmRleC50b29sdGlwLFxuICAgIH0pLFxuICAgIGRvY0JveEhlYWRlcjogY3NzKHtcbiAgICAgIGZvbnRTaXplOiB0aGVtZS50eXBvZ3JhcGh5Lmg1LmZvbnRTaXplLFxuICAgICAgZm9udEZhbWlseTogdGhlbWUudHlwb2dyYXBoeS5mb250RmFtaWx5TW9ub3NwYWNlLFxuICAgICAgcGFkZGluZ0JvdHRvbTogdGhlbWUuc3BhY2luZygxKSxcbiAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgIH0pLFxuICAgIGRvY0JveEJvZHk6IGNzcyh7XG4gICAgICAvLyBUaGUgbWFya2Rvd24gcGFyYWdyYXBoIGhhcyBhIG1hcmdpbkJvdHRvbSB0aGlzIHJlbW92ZXMgaXRcbiAgICAgIG1hcmdpbkJvdHRvbTogdGhlbWUuc3BhY2luZygtMSksXG4gICAgICBjb2xvcjogdGhlbWUuY29sb3JzLnRleHQuc2Vjb25kYXJ5LFxuICAgIH0pLFxuICAgIHNpZ25hdHVyZTogY3NzKHtcbiAgICAgIGZvbnRTaXplOiB0aGVtZS50eXBvZ3JhcGh5LmJvZHlTbWFsbC5mb250U2l6ZSxcbiAgICAgIGZvbnRGYW1pbHk6IHRoZW1lLnR5cG9ncmFwaHkuZm9udEZhbWlseU1vbm9zcGFjZSxcbiAgICB9KSxcbiAgICBkcm9wZG93bjogY3NzKHtcbiAgICAgIG9wYWNpdHk6IDAsXG4gICAgICBjb2xvcjogdGhlbWUuY29sb3JzLnRleHQuc2Vjb25kYXJ5LFxuICAgIH0pLFxuICB9O1xufTtcbmZ1bmN0aW9uIGdldE9wZXJhdGlvbkRvY3MoZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsIG9wOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24pOiBzdHJpbmcge1xuICByZXR1cm4gcmVuZGVyTWFya2Rvd24oZGVmLmV4cGxhaW5IYW5kbGVyID8gZGVmLmV4cGxhaW5IYW5kbGVyKG9wLCBkZWYpIDogZGVmLmRvY3VtZW50YXRpb24gPz8gJ25vIGRvY3MnKTtcbn1cbiIsImltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBEcmFnRHJvcENvbnRleHQsIERyb3BwYWJsZSwgRHJvcFJlc3VsdCB9IGZyb20gJ3JlYWN0LWJlYXV0aWZ1bC1kbmQnO1xuaW1wb3J0IHsgdXNlTW91bnRlZFN0YXRlLCB1c2VQcmV2aW91cyB9IGZyb20gJ3JlYWN0LXVzZSc7XG5cbmltcG9ydCB7IERhdGFTb3VyY2VBcGksIEdyYWZhbmFUaGVtZTIgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IFN0YWNrIH0gZnJvbSAnQGdyYWZhbmEvZXhwZXJpbWVudGFsJztcbmltcG9ydCB7IEJ1dHRvbiwgQ2FzY2FkZXIsIENhc2NhZGVyT3B0aW9uLCB1c2VTdHlsZXMyIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5pbXBvcnQgeyBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sIFF1ZXJ5V2l0aE9wZXJhdGlvbnMsIFZpc3VhbFF1ZXJ5TW9kZWxsZXIgfSBmcm9tICcuLi9zaGFyZWQvdHlwZXMnO1xuXG5pbXBvcnQgeyBPcGVyYXRpb25FZGl0b3IgfSBmcm9tICcuL09wZXJhdGlvbkVkaXRvcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHM8VCBleHRlbmRzIFF1ZXJ5V2l0aE9wZXJhdGlvbnM+IHtcbiAgcXVlcnk6IFQ7XG4gIGRhdGFzb3VyY2U6IERhdGFTb3VyY2VBcGk7XG4gIG9uQ2hhbmdlOiAocXVlcnk6IFQpID0+IHZvaWQ7XG4gIG9uUnVuUXVlcnk6ICgpID0+IHZvaWQ7XG4gIHF1ZXJ5TW9kZWxsZXI6IFZpc3VhbFF1ZXJ5TW9kZWxsZXI7XG4gIGV4cGxhaW5Nb2RlPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIE9wZXJhdGlvbkxpc3Q8VCBleHRlbmRzIFF1ZXJ5V2l0aE9wZXJhdGlvbnM+KHtcbiAgcXVlcnksXG4gIGRhdGFzb3VyY2UsXG4gIHF1ZXJ5TW9kZWxsZXIsXG4gIG9uQ2hhbmdlLFxuICBvblJ1blF1ZXJ5LFxufTogUHJvcHM8VD4pIHtcbiAgY29uc3Qgc3R5bGVzID0gdXNlU3R5bGVzMihnZXRTdHlsZXMpO1xuICBjb25zdCB7IG9wZXJhdGlvbnMgfSA9IHF1ZXJ5O1xuXG4gIGNvbnN0IG9wc1RvSGlnaGxpZ2h0ID0gdXNlT3BlcmF0aW9uc0hpZ2hsaWdodChvcGVyYXRpb25zKTtcblxuICBjb25zdCBbY2FzY2FkZXJPcGVuLCBzZXRDYXNjYWRlck9wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gIGNvbnN0IG9uT3BlcmF0aW9uQ2hhbmdlID0gKGluZGV4OiBudW1iZXIsIHVwZGF0ZTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uKSA9PiB7XG4gICAgY29uc3QgdXBkYXRlZExpc3QgPSBbLi4ub3BlcmF0aW9uc107XG4gICAgdXBkYXRlZExpc3Quc3BsaWNlKGluZGV4LCAxLCB1cGRhdGUpO1xuICAgIG9uQ2hhbmdlKHsgLi4ucXVlcnksIG9wZXJhdGlvbnM6IHVwZGF0ZWRMaXN0IH0pO1xuICB9O1xuXG4gIGNvbnN0IG9uUmVtb3ZlID0gKGluZGV4OiBudW1iZXIpID0+IHtcbiAgICBjb25zdCB1cGRhdGVkTGlzdCA9IFsuLi5vcGVyYXRpb25zLnNsaWNlKDAsIGluZGV4KSwgLi4ub3BlcmF0aW9ucy5zbGljZShpbmRleCArIDEpXTtcbiAgICBvbkNoYW5nZSh7IC4uLnF1ZXJ5LCBvcGVyYXRpb25zOiB1cGRhdGVkTGlzdCB9KTtcbiAgfTtcblxuICBjb25zdCBhZGRPcHRpb25zOiBDYXNjYWRlck9wdGlvbltdID0gcXVlcnlNb2RlbGxlci5nZXRDYXRlZ29yaWVzKCkubWFwKChjYXRlZ29yeSkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogY2F0ZWdvcnksXG4gICAgICBsYWJlbDogY2F0ZWdvcnksXG4gICAgICBpdGVtczogcXVlcnlNb2RlbGxlci5nZXRPcGVyYXRpb25zRm9yQ2F0ZWdvcnkoY2F0ZWdvcnkpLm1hcCgob3BlcmF0aW9uKSA9PiAoe1xuICAgICAgICB2YWx1ZTogb3BlcmF0aW9uLmlkLFxuICAgICAgICBsYWJlbDogb3BlcmF0aW9uLm5hbWUsXG4gICAgICAgIGlzTGVhZjogdHJ1ZSxcbiAgICAgIH0pKSxcbiAgICB9O1xuICB9KTtcblxuICBjb25zdCBvbkFkZE9wZXJhdGlvbiA9ICh2YWx1ZTogc3RyaW5nKSA9PiB7XG4gICAgY29uc3Qgb3BlcmF0aW9uRGVmID0gcXVlcnlNb2RlbGxlci5nZXRPcGVyYXRpb25EZWYodmFsdWUpO1xuICAgIGlmICghb3BlcmF0aW9uRGVmKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG9uQ2hhbmdlKG9wZXJhdGlvbkRlZi5hZGRPcGVyYXRpb25IYW5kbGVyKG9wZXJhdGlvbkRlZiwgcXVlcnksIHF1ZXJ5TW9kZWxsZXIpKTtcbiAgICBzZXRDYXNjYWRlck9wZW4oZmFsc2UpO1xuICB9O1xuXG4gIGNvbnN0IG9uRHJhZ0VuZCA9IChyZXN1bHQ6IERyb3BSZXN1bHQpID0+IHtcbiAgICBpZiAoIXJlc3VsdC5kZXN0aW5hdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHVwZGF0ZWRMaXN0ID0gWy4uLm9wZXJhdGlvbnNdO1xuICAgIGNvbnN0IGVsZW1lbnQgPSB1cGRhdGVkTGlzdFtyZXN1bHQuc291cmNlLmluZGV4XTtcbiAgICB1cGRhdGVkTGlzdC5zcGxpY2UocmVzdWx0LnNvdXJjZS5pbmRleCwgMSk7XG4gICAgdXBkYXRlZExpc3Quc3BsaWNlKHJlc3VsdC5kZXN0aW5hdGlvbi5pbmRleCwgMCwgZWxlbWVudCk7XG4gICAgb25DaGFuZ2UoeyAuLi5xdWVyeSwgb3BlcmF0aW9uczogdXBkYXRlZExpc3QgfSk7XG4gIH07XG5cbiAgY29uc3Qgb25DYXNjYWRlckJsdXIgPSAoKSA9PiB7XG4gICAgc2V0Q2FzY2FkZXJPcGVuKGZhbHNlKTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxTdGFjayBnYXA9ezF9IGRpcmVjdGlvbj1cImNvbHVtblwiPlxuICAgICAgPFN0YWNrIGdhcD17MX0+XG4gICAgICAgIHtvcGVyYXRpb25zLmxlbmd0aCA+IDAgJiYgKFxuICAgICAgICAgIDxEcmFnRHJvcENvbnRleHQgb25EcmFnRW5kPXtvbkRyYWdFbmR9PlxuICAgICAgICAgICAgPERyb3BwYWJsZSBkcm9wcGFibGVJZD1cInNvcnRhYmxlLWZpZWxkLW1hcHBpbmdzXCIgZGlyZWN0aW9uPVwiaG9yaXpvbnRhbFwiPlxuICAgICAgICAgICAgICB7KHByb3ZpZGVkKSA9PiAoXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5vcGVyYXRpb25MaXN0fSByZWY9e3Byb3ZpZGVkLmlubmVyUmVmfSB7Li4ucHJvdmlkZWQuZHJvcHBhYmxlUHJvcHN9PlxuICAgICAgICAgICAgICAgICAge29wZXJhdGlvbnMubWFwKChvcCwgaW5kZXgpID0+IChcbiAgICAgICAgICAgICAgICAgICAgPE9wZXJhdGlvbkVkaXRvclxuICAgICAgICAgICAgICAgICAgICAgIGtleT17b3AuaWQgKyBpbmRleH1cbiAgICAgICAgICAgICAgICAgICAgICBxdWVyeU1vZGVsbGVyPXtxdWVyeU1vZGVsbGVyfVxuICAgICAgICAgICAgICAgICAgICAgIGluZGV4PXtpbmRleH1cbiAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb249e29wfVxuICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5PXtxdWVyeX1cbiAgICAgICAgICAgICAgICAgICAgICBkYXRhc291cmNlPXtkYXRhc291cmNlfVxuICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtvbk9wZXJhdGlvbkNoYW5nZX1cbiAgICAgICAgICAgICAgICAgICAgICBvblJlbW92ZT17b25SZW1vdmV9XG4gICAgICAgICAgICAgICAgICAgICAgb25SdW5RdWVyeT17b25SdW5RdWVyeX1cbiAgICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHQ9e29wc1RvSGlnaGxpZ2h0W2luZGV4XX1cbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICkpfVxuICAgICAgICAgICAgICAgICAge3Byb3ZpZGVkLnBsYWNlaG9sZGVyfVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgPC9Ecm9wcGFibGU+XG4gICAgICAgICAgPC9EcmFnRHJvcENvbnRleHQ+XG4gICAgICAgICl9XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuYWRkQnV0dG9ufT5cbiAgICAgICAgICB7Y2FzY2FkZXJPcGVuID8gKFxuICAgICAgICAgICAgPENhc2NhZGVyXG4gICAgICAgICAgICAgIG9wdGlvbnM9e2FkZE9wdGlvbnN9XG4gICAgICAgICAgICAgIG9uU2VsZWN0PXtvbkFkZE9wZXJhdGlvbn1cbiAgICAgICAgICAgICAgb25CbHVyPXtvbkNhc2NhZGVyQmx1cn1cbiAgICAgICAgICAgICAgYXV0b0ZvY3VzPXt0cnVlfVxuICAgICAgICAgICAgICBhbHdheXNPcGVuPXt0cnVlfVxuICAgICAgICAgICAgICBoaWRlQWN0aXZlTGV2ZWxMYWJlbD17dHJ1ZX1cbiAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9eydTZWFyY2gnfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICApIDogKFxuICAgICAgICAgICAgPEJ1dHRvbiBpY29uPXsncGx1cyd9IHZhcmlhbnQ9eydzZWNvbmRhcnknfSBvbkNsaWNrPXsoKSA9PiBzZXRDYXNjYWRlck9wZW4odHJ1ZSl9IHRpdGxlPXsnQWRkIG9wZXJhdGlvbid9PlxuICAgICAgICAgICAgICBPcGVyYXRpb25zXG4gICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICApfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvU3RhY2s+XG4gICAgPC9TdGFjaz5cbiAgKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGluZGV4ZXMgb2Ygb3BlcmF0aW9ucyB0aGF0IHNob3VsZCBiZSBoaWdobGlnaHRlZC4gV2UgY2hlY2sgdGhlIGRpZmYgb2Ygb3BlcmF0aW9ucyBhZGRlZCBidXQgYXQgdGhlIHNhbWUgdGltZVxuICogd2Ugd2FudCB0byBoaWdobGlnaHQgb3BlcmF0aW9ucyBvbmx5IGFmdGVyIHRoZSBpbml0aWFsIHJlbmRlciwgc28gd2UgY2hlY2sgZm9yIG1vdW50ZWQgc3RhdGUgYW5kIGNhbGN1bGF0ZSB0aGUgZGlmZlxuICogb25seSBhZnRlci5cbiAqIEBwYXJhbSBvcGVyYXRpb25zXG4gKi9cbmZ1bmN0aW9uIHVzZU9wZXJhdGlvbnNIaWdobGlnaHQob3BlcmF0aW9uczogUXVlcnlCdWlsZGVyT3BlcmF0aW9uW10pIHtcbiAgY29uc3QgaXNNb3VudGVkID0gdXNlTW91bnRlZFN0YXRlKCk7XG4gIGNvbnN0IHByZXZPcGVyYXRpb25zID0gdXNlUHJldmlvdXMob3BlcmF0aW9ucyk7XG5cbiAgaWYgKCFpc01vdW50ZWQoKSkge1xuICAgIHJldHVybiBvcGVyYXRpb25zLm1hcCgoKSA9PiBmYWxzZSk7XG4gIH1cblxuICBpZiAoIXByZXZPcGVyYXRpb25zKSB7XG4gICAgcmV0dXJuIG9wZXJhdGlvbnMubWFwKCgpID0+IHRydWUpO1xuICB9XG5cbiAgbGV0IG5ld09wczogYm9vbGVhbltdID0gW107XG5cbiAgaWYgKHByZXZPcGVyYXRpb25zLmxlbmd0aCAtIDEgPT09IG9wZXJhdGlvbnMubGVuZ3RoICYmIG9wZXJhdGlvbnMuZXZlcnkoKG9wKSA9PiBwcmV2T3BlcmF0aW9ucy5pbmNsdWRlcyhvcCkpKSB7XG4gICAgLy8gSW4gY2FzZSB3ZSByZW1vdmUgb25lIG9wIGFuZCBkb2VzIG5vdCBjaGFuZ2UgYW55IG9wcyB0aGVuIGRvbid0IGhpZ2hsaWdodCBhbnl0aGluZy5cbiAgICByZXR1cm4gb3BlcmF0aW9ucy5tYXAoKCkgPT4gZmFsc2UpO1xuICB9XG4gIGlmIChwcmV2T3BlcmF0aW9ucy5sZW5ndGggKyAxID09PSBvcGVyYXRpb25zLmxlbmd0aCAmJiBwcmV2T3BlcmF0aW9ucy5ldmVyeSgob3ApID0+IG9wZXJhdGlvbnMuaW5jbHVkZXMob3ApKSkge1xuICAgIC8vIElmIHdlIGFkZCBhIHNpbmdsZSBvcCBqdXN0IGZpbmQgaXQgYW5kIGhpZ2hsaWdodCBqdXN0IHRoYXQuXG4gICAgY29uc3QgbmV3T3AgPSBvcGVyYXRpb25zLmZpbmQoKG9wKSA9PiAhcHJldk9wZXJhdGlvbnMuaW5jbHVkZXMob3ApKTtcbiAgICBuZXdPcHMgPSBvcGVyYXRpb25zLm1hcCgob3ApID0+IHtcbiAgICAgIHJldHVybiBvcCA9PT0gbmV3T3A7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRGVmYXVsdCBkaWZmIG9mIGFsbCBvcHMuXG4gICAgbmV3T3BzID0gb3BlcmF0aW9ucy5tYXAoKG9wLCBpbmRleCkgPT4ge1xuICAgICAgcmV0dXJuICFpc1NhbWVPcChvcC5pZCwgcHJldk9wZXJhdGlvbnNbaW5kZXhdPy5pZCk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG5ld09wcztcbn1cblxuZnVuY3Rpb24gaXNTYW1lT3Aob3AxPzogc3RyaW5nLCBvcDI/OiBzdHJpbmcpIHtcbiAgcmV0dXJuIG9wMSA9PT0gb3AyIHx8IGBfXyR7b3AxfV9ieWAgPT09IG9wMiB8fCBvcDEgPT09IGBfXyR7b3AyfV9ieWA7XG59XG5cbmNvbnN0IGdldFN0eWxlcyA9ICh0aGVtZTogR3JhZmFuYVRoZW1lMikgPT4ge1xuICByZXR1cm4ge1xuICAgIGhlYWRpbmc6IGNzcyh7XG4gICAgICBsYWJlbDogJ2hlYWRpbmcnLFxuICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgZm9udFdlaWdodDogdGhlbWUudHlwb2dyYXBoeS5mb250V2VpZ2h0TWVkaXVtLFxuICAgICAgbWFyZ2luQm90dG9tOiAwLFxuICAgIH0pLFxuICAgIG9wZXJhdGlvbkxpc3Q6IGNzcyh7XG4gICAgICBsYWJlbDogJ29wZXJhdGlvbkxpc3QnLFxuICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgZmxleFdyYXA6ICd3cmFwJyxcbiAgICAgIGdhcDogdGhlbWUuc3BhY2luZygyKSxcbiAgICB9KSxcbiAgICBhZGRCdXR0b246IGNzcyh7XG4gICAgICBsYWJlbDogJ2FkZEJ1dHRvbicsXG4gICAgICB3aWR0aDogMTI2LFxuICAgICAgcGFkZGluZ0JvdHRvbTogdGhlbWUuc3BhY2luZygxKSxcbiAgICB9KSxcbiAgfTtcbn07XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBPcGVyYXRpb25FeHBsYWluZWRCb3ggfSBmcm9tICcuL09wZXJhdGlvbkV4cGxhaW5lZEJveCc7XG5pbXBvcnQgeyBRdWVyeVdpdGhPcGVyYXRpb25zLCBWaXN1YWxRdWVyeU1vZGVsbGVyIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHM8VCBleHRlbmRzIFF1ZXJ5V2l0aE9wZXJhdGlvbnM+IHtcbiAgcXVlcnk6IFQ7XG4gIHF1ZXJ5TW9kZWxsZXI6IFZpc3VhbFF1ZXJ5TW9kZWxsZXI7XG4gIGV4cGxhaW5Nb2RlPzogYm9vbGVhbjtcbiAgc3RlcE51bWJlcjogbnVtYmVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gT3BlcmF0aW9uTGlzdEV4cGxhaW5lZDxUIGV4dGVuZHMgUXVlcnlXaXRoT3BlcmF0aW9ucz4oeyBxdWVyeSwgcXVlcnlNb2RlbGxlciwgc3RlcE51bWJlciB9OiBQcm9wczxUPikge1xuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICB7cXVlcnkub3BlcmF0aW9ucy5tYXAoKG9wLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBkZWYgPSBxdWVyeU1vZGVsbGVyLmdldE9wZXJhdGlvbkRlZihvcC5pZCk7XG4gICAgICAgIGlmICghZGVmKSB7XG4gICAgICAgICAgcmV0dXJuIGBPcGVyYXRpb24gJHtvcC5pZH0gbm90IGZvdW5kYDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aXRsZSA9IGRlZi5yZW5kZXJlcihvcCwgZGVmLCAnPGV4cHI+Jyk7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBkZWYuZXhwbGFpbkhhbmRsZXIgPyBkZWYuZXhwbGFpbkhhbmRsZXIob3AsIGRlZikgOiBkZWYuZG9jdW1lbnRhdGlvbiA/PyAnbm8gZG9jcyc7XG5cbiAgICAgICAgcmV0dXJuIDxPcGVyYXRpb25FeHBsYWluZWRCb3ggc3RlcE51bWJlcj17aW5kZXggKyBzdGVwTnVtYmVyfSBrZXk9e2luZGV4fSB0aXRsZT17dGl0bGV9IG1hcmtkb3duPXtib2R5fSAvPjtcbiAgICAgIH0pfVxuICAgIDwvPlxuICApO1xufVxuIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudFR5cGUgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IFNlbGVjdGFibGVWYWx1ZSwgdG9PcHRpb24gfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IENoZWNrYm94LCBTZWxlY3QgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5cbmltcG9ydCB7IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmLCBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbUVkaXRvclByb3BzIH0gZnJvbSAnLi4vc2hhcmVkL3R5cGVzJztcblxuaW1wb3J0IHsgQXV0b1NpemVJbnB1dCB9IGZyb20gJy4vQXV0b1NpemVJbnB1dCc7XG5pbXBvcnQgeyBnZXRPcGVyYXRpb25QYXJhbUlkIH0gZnJvbSAnLi9vcGVyYXRpb25VdGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRPcGVyYXRpb25QYXJhbUVkaXRvcihcbiAgcGFyYW1EZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmXG4pOiBDb21wb25lbnRUeXBlPFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRWRpdG9yUHJvcHM+IHtcbiAgaWYgKHBhcmFtRGVmLmVkaXRvcikge1xuICAgIHJldHVybiBwYXJhbURlZi5lZGl0b3I7XG4gIH1cblxuICBpZiAocGFyYW1EZWYub3B0aW9ucykge1xuICAgIHJldHVybiBTZWxlY3RJbnB1dFBhcmFtRWRpdG9yO1xuICB9XG5cbiAgc3dpdGNoIChwYXJhbURlZi50eXBlKSB7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gQm9vbElucHV0UGFyYW1FZGl0b3I7XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gU2ltcGxlSW5wdXRQYXJhbUVkaXRvcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBTaW1wbGVJbnB1dFBhcmFtRWRpdG9yKHByb3BzOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbUVkaXRvclByb3BzKSB7XG4gIHJldHVybiAoXG4gICAgPEF1dG9TaXplSW5wdXRcbiAgICAgIGlkPXtnZXRPcGVyYXRpb25QYXJhbUlkKHByb3BzLm9wZXJhdGlvbkluZGV4LCBwcm9wcy5pbmRleCl9XG4gICAgICBkZWZhdWx0VmFsdWU9e3Byb3BzLnZhbHVlPy50b1N0cmluZygpfVxuICAgICAgbWluV2lkdGg9e3Byb3BzLnBhcmFtRGVmLm1pbldpZHRofVxuICAgICAgcGxhY2Vob2xkZXI9e3Byb3BzLnBhcmFtRGVmLnBsYWNlaG9sZGVyfVxuICAgICAgdGl0bGU9e3Byb3BzLnBhcmFtRGVmLmRlc2NyaXB0aW9ufVxuICAgICAgb25Db21taXRDaGFuZ2U9eyhldnQpID0+IHtcbiAgICAgICAgcHJvcHMub25DaGFuZ2UocHJvcHMuaW5kZXgsIGV2dC5jdXJyZW50VGFyZ2V0LnZhbHVlKTtcbiAgICAgIH19XG4gICAgLz5cbiAgKTtcbn1cblxuZnVuY3Rpb24gQm9vbElucHV0UGFyYW1FZGl0b3IocHJvcHM6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRWRpdG9yUHJvcHMpIHtcbiAgcmV0dXJuIChcbiAgICA8Q2hlY2tib3hcbiAgICAgIGlkPXtnZXRPcGVyYXRpb25QYXJhbUlkKHByb3BzLm9wZXJhdGlvbkluZGV4LCBwcm9wcy5pbmRleCl9XG4gICAgICB2YWx1ZT17cHJvcHMudmFsdWUgYXMgYm9vbGVhbn1cbiAgICAgIG9uQ2hhbmdlPXsoZXZ0KSA9PiBwcm9wcy5vbkNoYW5nZShwcm9wcy5pbmRleCwgZXZ0LmN1cnJlbnRUYXJnZXQuY2hlY2tlZCl9XG4gICAgLz5cbiAgKTtcbn1cblxuZnVuY3Rpb24gU2VsZWN0SW5wdXRQYXJhbUVkaXRvcih7XG4gIHBhcmFtRGVmLFxuICB2YWx1ZSxcbiAgaW5kZXgsXG4gIG9wZXJhdGlvbkluZGV4LFxuICBvbkNoYW5nZSxcbn06IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRWRpdG9yUHJvcHMpIHtcbiAgbGV0IHNlbGVjdE9wdGlvbnMgPSBwYXJhbURlZi5vcHRpb25zIGFzIEFycmF5PFNlbGVjdGFibGVWYWx1ZTxhbnk+PjtcblxuICBpZiAoIXNlbGVjdE9wdGlvbnNbMF0/LmxhYmVsKSB7XG4gICAgc2VsZWN0T3B0aW9ucyA9IHBhcmFtRGVmLm9wdGlvbnMhLm1hcCgob3B0aW9uKSA9PiAoe1xuICAgICAgbGFiZWw6IG9wdGlvbi50b1N0cmluZygpLFxuICAgICAgdmFsdWU6IG9wdGlvbiBhcyBzdHJpbmcsXG4gICAgfSkpO1xuICB9XG5cbiAgbGV0IHZhbHVlT3B0aW9uID0gc2VsZWN0T3B0aW9ucy5maW5kKCh4KSA9PiB4LnZhbHVlID09PSB2YWx1ZSkgPz8gdG9PcHRpb24odmFsdWUgYXMgc3RyaW5nKTtcblxuICByZXR1cm4gKFxuICAgIDxTZWxlY3RcbiAgICAgIGlkPXtnZXRPcGVyYXRpb25QYXJhbUlkKG9wZXJhdGlvbkluZGV4LCBpbmRleCl9XG4gICAgICB2YWx1ZT17dmFsdWVPcHRpb259XG4gICAgICBvcHRpb25zPXtzZWxlY3RPcHRpb25zfVxuICAgICAgcGxhY2Vob2xkZXI9e3BhcmFtRGVmLnBsYWNlaG9sZGVyfVxuICAgICAgYWxsb3dDdXN0b21WYWx1ZT17dHJ1ZX1cbiAgICAgIG9uQ2hhbmdlPXsodmFsdWUpID0+IG9uQ2hhbmdlKGluZGV4LCB2YWx1ZS52YWx1ZSEpfVxuICAgIC8+XG4gICk7XG59XG4iLCJpbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgR3JhZmFuYVRoZW1lMiB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgU3RhY2sgfSBmcm9tICdAZ3JhZmFuYS9leHBlcmltZW50YWwnO1xuaW1wb3J0IHsgdXNlU3R5bGVzMiB9IGZyb20gJ0BncmFmYW5hL3VpJztcblxuaW50ZXJmYWNlIFByb3BzIHtcbiAgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIE9wZXJhdGlvbnNFZGl0b3JSb3coeyBjaGlsZHJlbiB9OiBQcm9wcykge1xuICBjb25zdCBzdHlsZXMgPSB1c2VTdHlsZXMyKGdldFN0eWxlcyk7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnJvb3R9PlxuICAgICAgPFN0YWNrIGdhcD17MX0+e2NoaWxkcmVufTwvU3RhY2s+XG4gICAgPC9kaXY+XG4gICk7XG59XG5cbmNvbnN0IGdldFN0eWxlcyA9ICh0aGVtZTogR3JhZmFuYVRoZW1lMikgPT4ge1xuICByZXR1cm4ge1xuICAgIHJvb3Q6IGNzcyh7XG4gICAgICBwYWRkaW5nOiB0aGVtZS5zcGFjaW5nKDEsIDEsIDAsIDEpLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGVtZS5jb2xvcnMuYmFja2dyb3VuZC5zZWNvbmRhcnksXG4gICAgICBib3JkZXJSYWRpdXM6IHRoZW1lLnNoYXBlLmJvcmRlclJhZGl1cygxKSxcbiAgICB9KSxcbiAgfTtcbn07XG4iLCJpbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgUmFkaW9CdXR0b25Hcm91cCwgVGFnIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5pbXBvcnQgeyBRdWVyeUVkaXRvck1vZGUgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gIG1vZGU6IFF1ZXJ5RWRpdG9yTW9kZTtcbiAgb25DaGFuZ2U6IChtb2RlOiBRdWVyeUVkaXRvck1vZGUpID0+IHZvaWQ7XG59XG5cbmNvbnN0IGVkaXRvck1vZGVzID0gW1xuICB7IGxhYmVsOiAnRXhwbGFpbicsIHZhbHVlOiBRdWVyeUVkaXRvck1vZGUuRXhwbGFpbiB9LFxuICB7XG4gICAgbGFiZWw6ICdCdWlsZGVyJyxcbiAgICB2YWx1ZTogUXVlcnlFZGl0b3JNb2RlLkJ1aWxkZXIsXG4gICAgY29tcG9uZW50OiAoKSA9PiAoXG4gICAgICA8VGFnXG4gICAgICAgIGNsYXNzTmFtZT17Y3NzKHtcbiAgICAgICAgICBmb250U2l6ZTogMTAsXG4gICAgICAgICAgcGFkZGluZzogJzFweCA1cHgnLFxuICAgICAgICAgIHZlcnRpY2FsQWxpZ246ICd0ZXh0LWJvdHRvbScsXG4gICAgICAgIH0pfVxuICAgICAgICBuYW1lPXsnQmV0YSd9XG4gICAgICAgIGNvbG9ySW5kZXg9ezF9XG4gICAgICAvPlxuICAgICksXG4gIH0sXG4gIHsgbGFiZWw6ICdDb2RlJywgdmFsdWU6IFF1ZXJ5RWRpdG9yTW9kZS5Db2RlIH0sXG5dO1xuXG5leHBvcnQgZnVuY3Rpb24gUXVlcnlFZGl0b3JNb2RlVG9nZ2xlKHsgbW9kZSwgb25DaGFuZ2UgfTogUHJvcHMpIHtcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGRhdGEtdGVzdGlkPXsnUXVlcnlFZGl0b3JNb2RlVG9nZ2xlJ30+XG4gICAgICA8UmFkaW9CdXR0b25Hcm91cCBvcHRpb25zPXtlZGl0b3JNb2Rlc30gc2l6ZT1cInNtXCIgdmFsdWU9e21vZGV9IG9uQ2hhbmdlPXtvbkNoYW5nZX0gLz5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cbiIsImltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgeyB1bmlxdWVJZCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgUmVhY3QsIHsgSFRNTFByb3BzLCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IEdyYWZhbmFUaGVtZTIgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IFN0YWNrIH0gZnJvbSAnQGdyYWZhbmEvZXhwZXJpbWVudGFsJztcbmltcG9ydCB7IFN3aXRjaCwgdXNlU3R5bGVzMiB9IGZyb20gJ0BncmFmYW5hL3VpJztcblxuZXhwb3J0IGludGVyZmFjZSBQcm9wcyBleHRlbmRzIE9taXQ8SFRNTFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+LCAndmFsdWUnIHwgJ3JlZic+IHtcbiAgdmFsdWU/OiBib29sZWFuO1xuICBsYWJlbDogc3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUXVlcnlIZWFkZXJTd2l0Y2goeyBsYWJlbCwgLi4uaW5wdXRQcm9wcyB9OiBQcm9wcykge1xuICBjb25zdCBkYXNoZWRMYWJlbCA9IGxhYmVsLnJlcGxhY2UoJyAnLCAnLScpO1xuICBjb25zdCBzd2l0Y2hJZFJlZiA9IHVzZVJlZih1bmlxdWVJZChgc3dpdGNoLSR7ZGFzaGVkTGFiZWx9YCkpO1xuICBjb25zdCBzdHlsZXMgPSB1c2VTdHlsZXMyKGdldFN0eWxlcyk7XG5cbiAgcmV0dXJuIChcbiAgICA8U3RhY2sgZ2FwPXsxfT5cbiAgICAgIDxsYWJlbCBodG1sRm9yPXtzd2l0Y2hJZFJlZi5jdXJyZW50fSBjbGFzc05hbWU9e3N0eWxlcy5zd2l0Y2hMYWJlbH0+XG4gICAgICAgIHtsYWJlbH1cbiAgICAgIDwvbGFiZWw+XG4gICAgICA8U3dpdGNoIHsuLi5pbnB1dFByb3BzfSBpZD17c3dpdGNoSWRSZWYuY3VycmVudH0gLz5cbiAgICA8L1N0YWNrPlxuICApO1xufVxuXG5jb25zdCBnZXRTdHlsZXMgPSAodGhlbWU6IEdyYWZhbmFUaGVtZTIpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBzd2l0Y2hMYWJlbDogY3NzKHtcbiAgICAgIGNvbG9yOiB0aGVtZS5jb2xvcnMudGV4dC5zZWNvbmRhcnksXG4gICAgICBjdXJzb3I6ICdwb2ludGVyJyxcbiAgICAgIGZvbnRTaXplOiB0aGVtZS50eXBvZ3JhcGh5LmJvZHlTbWFsbC5mb250U2l6ZSxcbiAgICAgICcmOmhvdmVyJzoge1xuICAgICAgICBjb2xvcjogdGhlbWUuY29sb3JzLnRleHQucHJpbWFyeSxcbiAgICAgIH0sXG4gICAgfSksXG4gIH07XG59O1xuIiwiaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VUb2dnbGUgfSBmcm9tICdyZWFjdC11c2UnO1xuXG5pbXBvcnQgeyBHcmFmYW5hVGhlbWUyIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBTdGFjayB9IGZyb20gJ0BncmFmYW5hL2V4cGVyaW1lbnRhbCc7XG5pbXBvcnQgeyBJY29uLCB1c2VTdHlsZXMyIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgdGl0bGU6IHN0cmluZztcbiAgY29sbGFwc2VkSW5mbzogc3RyaW5nW107XG4gIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBRdWVyeU9wdGlvbkdyb3VwKHsgdGl0bGUsIGNoaWxkcmVuLCBjb2xsYXBzZWRJbmZvIH06IFByb3BzKSB7XG4gIGNvbnN0IFtpc09wZW4sIHRvZ2dsZU9wZW5dID0gdXNlVG9nZ2xlKGZhbHNlKTtcbiAgY29uc3Qgc3R5bGVzID0gdXNlU3R5bGVzMihnZXRTdHlsZXMpO1xuXG4gIHJldHVybiAoXG4gICAgPFN0YWNrIGdhcD17MH0gZGlyZWN0aW9uPVwiY29sdW1uXCI+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmhlYWRlcn0gb25DbGljaz17dG9nZ2xlT3Blbn0gdGl0bGU9XCJDbGljayB0byBlZGl0IG9wdGlvbnNcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy50b2dnbGV9PlxuICAgICAgICAgIDxJY29uIG5hbWU9e2lzT3BlbiA/ICdhbmdsZS1kb3duJyA6ICdhbmdsZS1yaWdodCd9IC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8aDYgY2xhc3NOYW1lPXtzdHlsZXMudGl0bGV9Pnt0aXRsZX08L2g2PlxuICAgICAgICB7IWlzT3BlbiAmJiAoXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5kZXNjcmlwdGlvbn0+XG4gICAgICAgICAgICB7Y29sbGFwc2VkSW5mby5tYXAoKHgsIGkpID0+IChcbiAgICAgICAgICAgICAgPHNwYW4ga2V5PXtpfT57eH08L3NwYW4+XG4gICAgICAgICAgICApKX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKX1cbiAgICAgIDwvZGl2PlxuICAgICAge2lzT3BlbiAmJiA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmJvZHl9PntjaGlsZHJlbn08L2Rpdj59XG4gICAgPC9TdGFjaz5cbiAgKTtcbn1cblxuY29uc3QgZ2V0U3R5bGVzID0gKHRoZW1lOiBHcmFmYW5hVGhlbWUyKSA9PiB7XG4gIHJldHVybiB7XG4gICAgc3dpdGNoTGFiZWw6IGNzcyh7XG4gICAgICBjb2xvcjogdGhlbWUuY29sb3JzLnRleHQuc2Vjb25kYXJ5LFxuICAgICAgY3Vyc29yOiAncG9pbnRlcicsXG4gICAgICBmb250U2l6ZTogdGhlbWUudHlwb2dyYXBoeS5ib2R5U21hbGwuZm9udFNpemUsXG4gICAgICAnJjpob3Zlcic6IHtcbiAgICAgICAgY29sb3I6IHRoZW1lLmNvbG9ycy50ZXh0LnByaW1hcnksXG4gICAgICB9LFxuICAgIH0pLFxuICAgIGhlYWRlcjogY3NzKHtcbiAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgIGN1cnNvcjogJ3BvaW50ZXInLFxuICAgICAgYWxpZ25JdGVtczogJ2Jhc2VsaW5lJyxcbiAgICAgIGNvbG9yOiB0aGVtZS5jb2xvcnMudGV4dC5wcmltYXJ5LFxuICAgICAgJyY6aG92ZXInOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IHRoZW1lLmNvbG9ycy5lbXBoYXNpemUodGhlbWUuY29sb3JzLmJhY2tncm91bmQucHJpbWFyeSwgMC4wMyksXG4gICAgICB9LFxuICAgIH0pLFxuICAgIHRpdGxlOiBjc3Moe1xuICAgICAgZmxleEdyb3c6IDEsXG4gICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICBmb250U2l6ZTogdGhlbWUudHlwb2dyYXBoeS5ib2R5U21hbGwuZm9udFNpemUsXG4gICAgICBmb250V2VpZ2h0OiB0aGVtZS50eXBvZ3JhcGh5LmZvbnRXZWlnaHRNZWRpdW0sXG4gICAgICBtYXJnaW46IDAsXG4gICAgfSksXG4gICAgZGVzY3JpcHRpb246IGNzcyh7XG4gICAgICBjb2xvcjogdGhlbWUuY29sb3JzLnRleHQuc2Vjb25kYXJ5LFxuICAgICAgZm9udFNpemU6IHRoZW1lLnR5cG9ncmFwaHkuYm9keVNtYWxsLmZvbnRTaXplLFxuICAgICAgcGFkZGluZ0xlZnQ6IHRoZW1lLnNwYWNpbmcoMiksXG4gICAgICBnYXA6IHRoZW1lLnNwYWNpbmcoMiksXG4gICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgfSksXG4gICAgYm9keTogY3NzKHtcbiAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgIHBhZGRpbmdUb3A6IHRoZW1lLnNwYWNpbmcoMiksXG4gICAgICBnYXA6IHRoZW1lLnNwYWNpbmcoMiksXG4gICAgICBmbGV4V3JhcDogJ3dyYXAnLFxuICAgIH0pLFxuICAgIHRvZ2dsZTogY3NzKHtcbiAgICAgIGNvbG9yOiB0aGVtZS5jb2xvcnMudGV4dC5zZWNvbmRhcnksXG4gICAgICBtYXJnaW5SaWdodDogYCR7dGhlbWUuc3BhY2luZygxKX1gLFxuICAgIH0pLFxuICB9O1xufTtcbiIsImltcG9ydCB7IGNhcGl0YWxpemUgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHBsdXJhbGl6ZSBmcm9tICdwbHVyYWxpemUnO1xuXG5pbXBvcnQgeyBTZWxlY3RhYmxlVmFsdWUgfSBmcm9tICdAZ3JhZmFuYS9kYXRhL3NyYyc7XG5cbmltcG9ydCB7IExhYmVsUGFyYW1FZGl0b3IgfSBmcm9tICcuLi9jb21wb25lbnRzL0xhYmVsUGFyYW1FZGl0b3InO1xuaW1wb3J0IHsgUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkgfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7XG4gIFF1ZXJ5QnVpbGRlck9wZXJhdGlvbixcbiAgUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLFxuICBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbURlZixcbiAgUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1WYWx1ZSxcbiAgUXVlcnlXaXRoT3BlcmF0aW9ucyxcbn0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBmdW5jdGlvblJlbmRlcmVyTGVmdChtb2RlbDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLCBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiwgaW5uZXJFeHByOiBzdHJpbmcpIHtcbiAgY29uc3QgcGFyYW1zID0gcmVuZGVyUGFyYW1zKG1vZGVsLCBkZWYsIGlubmVyRXhwcik7XG4gIGNvbnN0IHN0ciA9IG1vZGVsLmlkICsgJygnO1xuXG4gIGlmIChpbm5lckV4cHIpIHtcbiAgICBwYXJhbXMucHVzaChpbm5lckV4cHIpO1xuICB9XG5cbiAgcmV0dXJuIHN0ciArIHBhcmFtcy5qb2luKCcsICcpICsgJyknO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZnVuY3Rpb25SZW5kZXJlclJpZ2h0KG1vZGVsOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLCBpbm5lckV4cHI6IHN0cmluZykge1xuICBjb25zdCBwYXJhbXMgPSByZW5kZXJQYXJhbXMobW9kZWwsIGRlZiwgaW5uZXJFeHByKTtcbiAgY29uc3Qgc3RyID0gbW9kZWwuaWQgKyAnKCc7XG5cbiAgaWYgKGlubmVyRXhwcikge1xuICAgIHBhcmFtcy51bnNoaWZ0KGlubmVyRXhwcik7XG4gIH1cblxuICByZXR1cm4gc3RyICsgcGFyYW1zLmpvaW4oJywgJykgKyAnKSc7XG59XG5cbmZ1bmN0aW9uIHJhbmdlUmVuZGVyZXJXaXRoUGFyYW1zKFxuICBtb2RlbDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLFxuICBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZixcbiAgaW5uZXJFeHByOiBzdHJpbmcsXG4gIHJlbmRlckxlZnQ6IGJvb2xlYW5cbikge1xuICBpZiAoZGVmLnBhcmFtcy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgYENhbm5vdCByZW5kZXIgYSBmdW5jdGlvbiB3aXRoIHBhcmFtcyBvZiBsZW5ndGggWyR7ZGVmLnBhcmFtcy5sZW5ndGh9XWA7XG4gIH1cblxuICBsZXQgcmFuZ2VWZWN0b3IgPSAobW9kZWwucGFyYW1zID8/IFtdKVswXSA/PyAnNW0nO1xuXG4gIC8vIE5leHQgZnJhbWUgdGhlIHJlbWFpbmluZyBwYXJhbWV0ZXJzLCBidXQgZ2V0IHJpZCBvZiB0aGUgZmlyc3Qgb25lIGJlY2F1c2UgaXQncyB1c2VkIHRvIG1vdmUgdGhlXG4gIC8vIGluc3RhbnQgdmVjdG9yIGludG8gYSByYW5nZSB2ZWN0b3IuXG4gIGNvbnN0IHBhcmFtcyA9IHJlbmRlclBhcmFtcyhcbiAgICB7XG4gICAgICAuLi5tb2RlbCxcbiAgICAgIHBhcmFtczogbW9kZWwucGFyYW1zLnNsaWNlKDEpLFxuICAgIH0sXG4gICAge1xuICAgICAgLi4uZGVmLFxuICAgICAgcGFyYW1zOiBkZWYucGFyYW1zLnNsaWNlKDEpLFxuICAgICAgZGVmYXVsdFBhcmFtczogZGVmLmRlZmF1bHRQYXJhbXMuc2xpY2UoMSksXG4gICAgfSxcbiAgICBpbm5lckV4cHJcbiAgKTtcblxuICBjb25zdCBzdHIgPSBtb2RlbC5pZCArICcoJztcblxuICAvLyBEZXBlbmRpbmcgb24gdGhlIHJlbmRlckxlZnQgdmFyaWFibGUsIHJlbmRlciBwYXJhbWV0ZXJzIHRvIHRoZSBsZWZ0IG9yIHJpZ2h0XG4gIC8vIHJlbmRlckxlZnQgPT09IHRydWUgKHJlbmRlckxlZnQpID0+IChwYXJhbTEsIHBhcmFtMiwgcmFuZ2VWZWN0b3JbLi4uXSlcbiAgLy8gcmVuZGVyTGVmdCA9PT0gZmFsc2UgKHJlbmRlclJpZ2h0KSA9PiAocmFuZ2VWZWN0b3JbLi4uXSwgcGFyYW0xLCBwYXJhbTIpXG4gIGlmIChpbm5lckV4cHIpIHtcbiAgICByZW5kZXJMZWZ0ID8gcGFyYW1zLnB1c2goYCR7aW5uZXJFeHByfVske3JhbmdlVmVjdG9yfV1gKSA6IHBhcmFtcy51bnNoaWZ0KGAke2lubmVyRXhwcn1bJHtyYW5nZVZlY3Rvcn1dYCk7XG4gIH1cblxuICAvLyBzdGljayBldmVyeXRoaW5nIHRvZ2V0aGVyXG4gIHJldHVybiBzdHIgKyBwYXJhbXMuam9pbignLCAnKSArICcpJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlUmVuZGVyZXJSaWdodFdpdGhQYXJhbXMoXG4gIG1vZGVsOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sXG4gIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLFxuICBpbm5lckV4cHI6IHN0cmluZ1xuKSB7XG4gIHJldHVybiByYW5nZVJlbmRlcmVyV2l0aFBhcmFtcyhtb2RlbCwgZGVmLCBpbm5lckV4cHIsIGZhbHNlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlUmVuZGVyZXJMZWZ0V2l0aFBhcmFtcyhcbiAgbW9kZWw6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbixcbiAgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsXG4gIGlubmVyRXhwcjogc3RyaW5nXG4pIHtcbiAgcmV0dXJuIHJhbmdlUmVuZGVyZXJXaXRoUGFyYW1zKG1vZGVsLCBkZWYsIGlubmVyRXhwciwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclBhcmFtcyhtb2RlbDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLCBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiwgaW5uZXJFeHByOiBzdHJpbmcpIHtcbiAgcmV0dXJuIChtb2RlbC5wYXJhbXMgPz8gW10pLm1hcCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgcGFyYW1EZWYgPSBkZWYucGFyYW1zW2luZGV4XTtcbiAgICBpZiAocGFyYW1EZWYudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiAnXCInICsgdmFsdWUgKyAnXCInO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0QWRkT3BlcmF0aW9uSGFuZGxlcjxUIGV4dGVuZHMgUXVlcnlXaXRoT3BlcmF0aW9ucz4oZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsIHF1ZXJ5OiBUKSB7XG4gIGNvbnN0IG5ld09wZXJhdGlvbjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uID0ge1xuICAgIGlkOiBkZWYuaWQsXG4gICAgcGFyYW1zOiBkZWYuZGVmYXVsdFBhcmFtcyxcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIC4uLnF1ZXJ5LFxuICAgIG9wZXJhdGlvbnM6IFsuLi5xdWVyeS5vcGVyYXRpb25zLCBuZXdPcGVyYXRpb25dLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJvbUFuZExva2lPcGVyYXRpb25EaXNwbGF5TmFtZShmdW5jTmFtZTogc3RyaW5nKSB7XG4gIHJldHVybiBjYXBpdGFsaXplKGZ1bmNOYW1lLnJlcGxhY2UoL18vZywgJyAnKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRPcGVyYXRpb25QYXJhbUlkKG9wZXJhdGlvbkluZGV4OiBudW1iZXIsIHBhcmFtSW5kZXg6IG51bWJlcikge1xuICByZXR1cm4gYG9wZXJhdGlvbnMuJHtvcGVyYXRpb25JbmRleH0ucGFyYW0uJHtwYXJhbUluZGV4fWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSYW5nZVZlY3RvclBhcmFtRGVmKHdpdGhSYXRlSW50ZXJ2YWwgPSBmYWxzZSk6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmIHtcbiAgY29uc3QgcGFyYW06IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmID0ge1xuICAgIG5hbWU6ICdSYW5nZScsXG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgb3B0aW9uczogW1xuICAgICAge1xuICAgICAgICBsYWJlbDogJyRfX2ludGVydmFsJyxcbiAgICAgICAgdmFsdWU6ICckX19pbnRlcnZhbCcsXG4gICAgICAgIC8vIHRvb2x0aXA6ICdEeW5hbWljIGludGVydmFsIGJhc2VkIG9uIG1heCBkYXRhIHBvaW50cywgc2NyYXBlIGFuZCBtaW4gaW50ZXJ2YWwnLFxuICAgICAgfSxcbiAgICAgIHsgbGFiZWw6ICcxbScsIHZhbHVlOiAnMW0nIH0sXG4gICAgICB7IGxhYmVsOiAnNW0nLCB2YWx1ZTogJzVtJyB9LFxuICAgICAgeyBsYWJlbDogJzEwbScsIHZhbHVlOiAnMTBtJyB9LFxuICAgICAgeyBsYWJlbDogJzFoJywgdmFsdWU6ICcxaCcgfSxcbiAgICAgIHsgbGFiZWw6ICcyNGgnLCB2YWx1ZTogJzI0aCcgfSxcbiAgICBdLFxuICB9O1xuXG4gIGlmICh3aXRoUmF0ZUludGVydmFsKSB7XG4gICAgKHBhcmFtLm9wdGlvbnMgYXMgQXJyYXk8U2VsZWN0YWJsZVZhbHVlPHN0cmluZz4+KS51bnNoaWZ0KHtcbiAgICAgIGxhYmVsOiAnJF9fcmF0ZV9pbnRlcnZhbCcsXG4gICAgICB2YWx1ZTogJyRfX3JhdGVfaW50ZXJ2YWwnLFxuICAgICAgLy8gdG9vbHRpcDogJ0Fsd2F5cyBhYm92ZSA0eCBzY3JhcGUgaW50ZXJ2YWwnLFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHBhcmFtO1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgc2hhcmVkIGJldHdlZW4gUHJvbWV0aGV1cyBhbmQgTG9raSB2YXJpYW50c1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQWdncmVnYXRpb25PcGVyYXRpb248VCBleHRlbmRzIFF1ZXJ5V2l0aE9wZXJhdGlvbnM+KFxuICBuYW1lOiBzdHJpbmcsXG4gIG92ZXJyaWRlczogUGFydGlhbDxRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWY+ID0ge31cbik6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZltdIHtcbiAgY29uc3Qgb3BlcmF0aW9uczogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmW10gPSBbXG4gICAge1xuICAgICAgaWQ6IG5hbWUsXG4gICAgICBuYW1lOiBnZXRQcm9tQW5kTG9raU9wZXJhdGlvbkRpc3BsYXlOYW1lKG5hbWUpLFxuICAgICAgcGFyYW1zOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnQnkgbGFiZWwnLFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIHJlc3RQYXJhbTogdHJ1ZSxcbiAgICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbXSxcbiAgICAgIGFsdGVybmF0aXZlc0tleTogJ3BsYWluIGFnZ3JlZ2F0aW9ucycsXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuQWdncmVnYXRpb25zLFxuICAgICAgcmVuZGVyZXI6IGZ1bmN0aW9uUmVuZGVyZXJMZWZ0LFxuICAgICAgcGFyYW1DaGFuZ2VkSGFuZGxlcjogZ2V0T25MYWJlbEFkZGVkSGFuZGxlcihgX18ke25hbWV9X2J5YCksXG4gICAgICBleHBsYWluSGFuZGxlcjogZ2V0QWdncmVnYXRpb25FeHBsYWluZXIobmFtZSwgJycpLFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogZGVmYXVsdEFkZE9wZXJhdGlvbkhhbmRsZXIsXG4gICAgICAuLi5vdmVycmlkZXMsXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogYF9fJHtuYW1lfV9ieWAsXG4gICAgICBuYW1lOiBgJHtnZXRQcm9tQW5kTG9raU9wZXJhdGlvbkRpc3BsYXlOYW1lKG5hbWUpfSBieWAsXG4gICAgICBwYXJhbXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdMYWJlbCcsXG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgcmVzdFBhcmFtOiB0cnVlLFxuICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgIGVkaXRvcjogTGFiZWxQYXJhbUVkaXRvcixcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbJyddLFxuICAgICAgYWx0ZXJuYXRpdmVzS2V5OiAnYWdncmVnYXRpb25zIGJ5JyxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5BZ2dyZWdhdGlvbnMsXG4gICAgICByZW5kZXJlcjogZ2V0QWdncmVnYXRpb25CeVJlbmRlcmVyKG5hbWUpLFxuICAgICAgcGFyYW1DaGFuZ2VkSGFuZGxlcjogZ2V0TGFzdExhYmVsUmVtb3ZlZEhhbmRsZXIobmFtZSksXG4gICAgICBleHBsYWluSGFuZGxlcjogZ2V0QWdncmVnYXRpb25FeHBsYWluZXIobmFtZSwgJ2J5JyksXG4gICAgICBhZGRPcGVyYXRpb25IYW5kbGVyOiBkZWZhdWx0QWRkT3BlcmF0aW9uSGFuZGxlcixcbiAgICAgIGhpZGVGcm9tTGlzdDogdHJ1ZSxcbiAgICAgIC4uLm92ZXJyaWRlcyxcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiBgX18ke25hbWV9X3dpdGhvdXRgLFxuICAgICAgbmFtZTogYCR7Z2V0UHJvbUFuZExva2lPcGVyYXRpb25EaXNwbGF5TmFtZShuYW1lKX0gd2l0aG91dGAsXG4gICAgICBwYXJhbXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdMYWJlbCcsXG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgcmVzdFBhcmFtOiB0cnVlLFxuICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgIGVkaXRvcjogTGFiZWxQYXJhbUVkaXRvcixcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbJyddLFxuICAgICAgYWx0ZXJuYXRpdmVzS2V5OiAnYWdncmVnYXRpb25zIGJ5JyxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5BZ2dyZWdhdGlvbnMsXG4gICAgICByZW5kZXJlcjogZ2V0QWdncmVnYXRpb25XaXRob3V0UmVuZGVyZXIobmFtZSksXG4gICAgICBwYXJhbUNoYW5nZWRIYW5kbGVyOiBnZXRMYXN0TGFiZWxSZW1vdmVkSGFuZGxlcihuYW1lKSxcbiAgICAgIGV4cGxhaW5IYW5kbGVyOiBnZXRBZ2dyZWdhdGlvbkV4cGxhaW5lcihuYW1lLCAnd2l0aG91dCcpLFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogZGVmYXVsdEFkZE9wZXJhdGlvbkhhbmRsZXIsXG4gICAgICBoaWRlRnJvbUxpc3Q6IHRydWUsXG4gICAgICAuLi5vdmVycmlkZXMsXG4gICAgfSxcbiAgXTtcblxuICByZXR1cm4gb3BlcmF0aW9ucztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUFnZ3JlZ2F0aW9uT3BlcmF0aW9uV2l0aFBhcmFtKFxuICBuYW1lOiBzdHJpbmcsXG4gIHBhcmFtc0RlZjogeyBwYXJhbXM6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmW107IGRlZmF1bHRQYXJhbXM6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtVmFsdWVbXSB9LFxuICBvdmVycmlkZXM6IFBhcnRpYWw8UXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmPiA9IHt9XG4pOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWZbXSB7XG4gIGNvbnN0IG9wZXJhdGlvbnMgPSBjcmVhdGVBZ2dyZWdhdGlvbk9wZXJhdGlvbihuYW1lLCBvdmVycmlkZXMpO1xuICBvcGVyYXRpb25zWzBdLnBhcmFtcy51bnNoaWZ0KC4uLnBhcmFtc0RlZi5wYXJhbXMpO1xuICBvcGVyYXRpb25zWzFdLnBhcmFtcy51bnNoaWZ0KC4uLnBhcmFtc0RlZi5wYXJhbXMpO1xuICBvcGVyYXRpb25zWzJdLnBhcmFtcy51bnNoaWZ0KC4uLnBhcmFtc0RlZi5wYXJhbXMpO1xuICBvcGVyYXRpb25zWzBdLmRlZmF1bHRQYXJhbXMgPSBwYXJhbXNEZWYuZGVmYXVsdFBhcmFtcztcbiAgb3BlcmF0aW9uc1sxXS5kZWZhdWx0UGFyYW1zID0gWy4uLnBhcmFtc0RlZi5kZWZhdWx0UGFyYW1zLCAnJ107XG4gIG9wZXJhdGlvbnNbMl0uZGVmYXVsdFBhcmFtcyA9IFsuLi5wYXJhbXNEZWYuZGVmYXVsdFBhcmFtcywgJyddO1xuICBvcGVyYXRpb25zWzFdLnJlbmRlcmVyID0gZ2V0QWdncmVnYXRpb25CeVJlbmRlcmVyV2l0aFBhcmFtZXRlcihuYW1lKTtcbiAgb3BlcmF0aW9uc1syXS5yZW5kZXJlciA9IGdldEFnZ3JlZ2F0aW9uQnlSZW5kZXJlcldpdGhQYXJhbWV0ZXIobmFtZSk7XG4gIHJldHVybiBvcGVyYXRpb25zO1xufVxuXG5mdW5jdGlvbiBnZXRBZ2dyZWdhdGlvbkJ5UmVuZGVyZXIoYWdncmVnYXRpb246IHN0cmluZykge1xuICByZXR1cm4gZnVuY3Rpb24gYWdncmVnYXRpb25SZW5kZXJlcihtb2RlbDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLCBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiwgaW5uZXJFeHByOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gYCR7YWdncmVnYXRpb259IGJ5KCR7bW9kZWwucGFyYW1zLmpvaW4oJywgJyl9KSAoJHtpbm5lckV4cHJ9KWA7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEFnZ3JlZ2F0aW9uV2l0aG91dFJlbmRlcmVyKGFnZ3JlZ2F0aW9uOiBzdHJpbmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGFnZ3JlZ2F0aW9uUmVuZGVyZXIobW9kZWw6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiwgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsIGlubmVyRXhwcjogc3RyaW5nKSB7XG4gICAgcmV0dXJuIGAke2FnZ3JlZ2F0aW9ufSB3aXRob3V0KCR7bW9kZWwucGFyYW1zLmpvaW4oJywgJyl9KSAoJHtpbm5lckV4cHJ9KWA7XG4gIH07XG59XG5cbi8qKlxuICogVmVyeSBzaW1wbGUgcG9jIGltcGxlbWVudGF0aW9uLCBuZWVkcyB0byBiZSBtb2RpZmllZCB0byBzdXBwb3J0IGFsbCBhZ2dyZWdhdGlvbiBvcGVyYXRvcnNcbiAqL1xuZnVuY3Rpb24gZ2V0QWdncmVnYXRpb25FeHBsYWluZXIoYWdncmVnYXRpb25OYW1lOiBzdHJpbmcsIG1vZGU6ICdieScgfCAnd2l0aG91dCcgfCAnJykge1xuICByZXR1cm4gZnVuY3Rpb24gYWdncmVnYXRpb25FeHBsYWluZXIobW9kZWw6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbikge1xuICAgIGNvbnN0IGxhYmVscyA9IG1vZGVsLnBhcmFtcy5tYXAoKGxhYmVsKSA9PiBgXFxgJHtsYWJlbH1cXGBgKS5qb2luKCcgYW5kICcpO1xuICAgIGNvbnN0IGxhYmVsV29yZCA9IHBsdXJhbGl6ZSgnbGFiZWwnLCBtb2RlbC5wYXJhbXMubGVuZ3RoKTtcblxuICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgY2FzZSAnYnknOlxuICAgICAgICByZXR1cm4gYENhbGN1bGF0ZXMgJHthZ2dyZWdhdGlvbk5hbWV9IG92ZXIgZGltZW5zaW9ucyB3aGlsZSBwcmVzZXJ2aW5nICR7bGFiZWxXb3JkfSAke2xhYmVsc30uYDtcbiAgICAgIGNhc2UgJ3dpdGhvdXQnOlxuICAgICAgICByZXR1cm4gYENhbGN1bGF0ZXMgJHthZ2dyZWdhdGlvbk5hbWV9IG92ZXIgdGhlIGRpbWVuc2lvbnMgJHtsYWJlbHN9LiBBbGwgb3RoZXIgbGFiZWxzIGFyZSBwcmVzZXJ2ZWQuYDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBgQ2FsY3VsYXRlcyAke2FnZ3JlZ2F0aW9uTmFtZX0gb3ZlciB0aGUgZGltZW5zaW9ucy5gO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0QWdncmVnYXRpb25CeVJlbmRlcmVyV2l0aFBhcmFtZXRlcihhZ2dyZWdhdGlvbjogc3RyaW5nKSB7XG4gIHJldHVybiBmdW5jdGlvbiBhZ2dyZWdhdGlvblJlbmRlcmVyKG1vZGVsOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLCBpbm5lckV4cHI6IHN0cmluZykge1xuICAgIGZ1bmN0aW9uIG1hcFR5cGUocDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1WYWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gYFxcXCIke3B9XFxcImA7XG4gICAgICB9XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgY29uc3QgcGFyYW1zID0gbW9kZWwucGFyYW1zLnNsaWNlKDAsIC0xKTtcbiAgICBjb25zdCByZXN0UGFyYW1zID0gbW9kZWwucGFyYW1zLnNsaWNlKDEpO1xuICAgIHJldHVybiBgJHthZ2dyZWdhdGlvbn0gYnkoJHtyZXN0UGFyYW1zLmpvaW4oJywgJyl9KSAoJHtwYXJhbXMubWFwKG1hcFR5cGUpLmpvaW4oJywgJyl9LCAke2lubmVyRXhwcn0pYDtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgdHJhbnNmb3JtIG9wZXJhdGlvbnMgd2l0aG91dCBsYWJlbHMgdG8gdGhlaXIgcGxhbiBhZ2dyZWdhdGlvbiBvcGVyYXRpb25cbiAqL1xuZnVuY3Rpb24gZ2V0TGFzdExhYmVsUmVtb3ZlZEhhbmRsZXIoY2hhbmdlVG9PcGVyYXRpb25JZDogc3RyaW5nKSB7XG4gIHJldHVybiBmdW5jdGlvbiBvblBhcmFtQ2hhbmdlZChpbmRleDogbnVtYmVyLCBvcDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLCBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZikge1xuICAgIC8vIElmIGRlZmluaXRpb24gaGFzIG1vcmUgcGFyYW1zIHRoZW4gaXMgZGVmaW5lZCB0aGVyZSBhcmUgbm8gb3B0aW9uYWwgcmVzdCBwYXJhbXMgYW55bW9yZS5cbiAgICAvLyBXZSB0aGVuIHRyYW5zZm9ybSB0aGlzIG9wZXJhdGlvbiBpbnRvIGEgZGlmZmVyZW50IG9uZVxuICAgIGlmIChvcC5wYXJhbXMubGVuZ3RoIDwgZGVmLnBhcmFtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm9wLFxuICAgICAgICBpZDogY2hhbmdlVG9PcGVyYXRpb25JZCxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wO1xuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRPbkxhYmVsQWRkZWRIYW5kbGVyKGNoYW5nZVRvT3BlcmF0aW9uSWQ6IHN0cmluZykge1xuICByZXR1cm4gZnVuY3Rpb24gb25QYXJhbUNoYW5nZWQoaW5kZXg6IG51bWJlciwgb3A6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiwgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYpIHtcbiAgICAvLyBDaGVjayBpZiB3ZSBhY3R1YWxseSBoYXZlIHRoZSBsYWJlbCBwYXJhbS4gQXMgaXQncyBvcHRpb25hbCB0aGUgYWdncmVnYXRpb24gY2FuIGhhdmUgb25lIGxlc3MsIHdoaWNoIGlzIHRoZVxuICAgIC8vIGNhc2Ugb2YganVzdCBzaW1wbGUgYWdncmVnYXRpb24gd2l0aG91dCBsYWJlbC4gV2hlbiB1c2VyIGFkZHMgdGhlIGxhYmVsIGl0IG5vdyBoYXMgdGhlIHNhbWUgbnVtYmVyIG9mIHBhcmFtc1xuICAgIC8vIGFzIGl0J3MgZGVmaW5pdGlvbiwgYW5kIG5vdyB3ZSBjYW4gY2hhbmdlIGl0IHRvIGl0J3MgYF9ieWAgdmFyaWFudC5cbiAgICBpZiAob3AucGFyYW1zLmxlbmd0aCA9PT0gZGVmLnBhcmFtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm9wLFxuICAgICAgICBpZDogY2hhbmdlVG9PcGVyYXRpb25JZCxcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBvcDtcbiAgfTtcbn1cbiIsImltcG9ydCB7IFN5bnRheE5vZGUsIFRyZWVDdXJzb3IgfSBmcm9tICdAbGV6ZXIvY29tbW9uJztcblxuaW1wb3J0IHsgUXVlcnlCdWlsZGVyT3BlcmF0aW9uIH0gZnJvbSAnLi90eXBlcyc7XG5cbi8vIFRoaXMgaXMgdXNlZCBmb3IgZXJyb3IgdHlwZSBmb3Igc29tZSByZWFzb25cbmV4cG9ydCBjb25zdCBFcnJvck5hbWUgPSAn4pqgJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldExlZnRNb3N0Q2hpbGQoY3VyOiBTeW50YXhOb2RlKTogU3ludGF4Tm9kZSB7XG4gIHJldHVybiBjdXIuZmlyc3RDaGlsZCA/IGdldExlZnRNb3N0Q2hpbGQoY3VyLmZpcnN0Q2hpbGQpIDogY3VyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFrZUVycm9yKGV4cHI6IHN0cmluZywgbm9kZTogU3ludGF4Tm9kZSkge1xuICByZXR1cm4ge1xuICAgIHRleHQ6IGdldFN0cmluZyhleHByLCBub2RlKSxcbiAgICAvLyBUT0RPOiB0aGlzIGFyZSBwb3NpdGlvbnMgaW4gdGhlIHN0cmluZyB3aXRoIHRoZSByZXBsYWNlZCB2YXJpYWJsZXMuIE1lYW5zIGl0IGNhbm5vdCBiZSB1c2VkIHRvIHNob3cgZXhhY3RcbiAgICAvLyAgcGxhY2VtZW50IG9mIHRoZSBlcnJvciBmb3IgdGhlIHVzZXIuIFdlIG5lZWQgc29tZSB0cmFuc2xhdGlvbiB0YWJsZSB0byBwb3NpdGlvbnMgYmVmb3JlIHRoZSB2YXJpYWJsZVxuICAgIC8vICByZXBsYWNlLlxuICAgIGZyb206IG5vZGUuZnJvbSxcbiAgICB0bzogbm9kZS50byxcbiAgICBwYXJlbnRUeXBlOiBub2RlLnBhcmVudD8ubmFtZSxcbiAgfTtcbn1cblxuLy8gVGFrZW4gZnJvbSB0ZW1wbGF0ZV9zcnYsIGJ1dCBjb3BpZWQgc28gdG8gbm90IG1lc3Mgd2l0aCB0aGUgcmVnZXguaW5kZXggd2hpY2ggaXMgbWFuaXB1bGF0ZWQgaW4gdGhlIHNlcnZpY2Vcbi8qXG4gKiBUaGlzIHJlZ2V4IG1hdGNoZXMgMyB0eXBlcyBvZiB2YXJpYWJsZSByZWZlcmVuY2Ugd2l0aCBhbiBvcHRpb25hbCBmb3JtYXQgc3BlY2lmaWVyXG4gKiBcXCQoXFx3KykgICAgICAgICAgICAgICAgICAgICAgICAgICR2YXIxXG4gKiBcXFtcXFsoW1xcc1xcU10rPykoPzo6KFxcdyspKT9cXF1cXF0gICAgW1t2YXIyXV0gb3IgW1t2YXIyOmZtdDJdXVxuICogXFwkeyhcXHcrKSg/OjooXFx3KykpP30gICAgICAgICAgICAgJHt2YXIzfSBvciAke3ZhcjM6Zm10M31cbiAqL1xuY29uc3QgdmFyaWFibGVSZWdleCA9IC9cXCQoXFx3Kyl8XFxbXFxbKFtcXHNcXFNdKz8pKD86OihcXHcrKSk/XFxdXFxdfFxcJHsoXFx3KykoPzpcXC4oW146XlxcfV0rKSk/KD86OihbXlxcfV0rKSk/fS9nO1xuXG4vKipcbiAqIEFzIHZhcmlhYmxlcyB3aXRoICQgYXJlIGNyZWF0aW5nIHBhcnNpbmcgZXJyb3JzLCB3ZSBmaXJzdCByZXBsYWNlIHRoZW0gd2l0aCBtYWdpYyBzdHJpbmcgdGhhdCBpcyBwYXJzYWJsZSBhbmQgYXRcbiAqIHRoZSBzYW1lIHRpbWUgd2UgY2FuIGdldCB0aGUgdmFyaWFibGUgYW5kIGl0J3MgZm9ybWF0IGJhY2sgZnJvbSBpdC5cbiAqIEBwYXJhbSBleHByXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXBsYWNlVmFyaWFibGVzKGV4cHI6IHN0cmluZykge1xuICByZXR1cm4gZXhwci5yZXBsYWNlKHZhcmlhYmxlUmVnZXgsIChtYXRjaCwgdmFyMSwgdmFyMiwgZm10MiwgdmFyMywgZmllbGRQYXRoLCBmbXQzKSA9PiB7XG4gICAgY29uc3QgZm10ID0gZm10MiB8fCBmbXQzO1xuICAgIGxldCB2YXJpYWJsZSA9IHZhcjE7XG4gICAgbGV0IHZhclR5cGUgPSAnMCc7XG5cbiAgICBpZiAodmFyMikge1xuICAgICAgdmFyaWFibGUgPSB2YXIyO1xuICAgICAgdmFyVHlwZSA9ICcxJztcbiAgICB9XG5cbiAgICBpZiAodmFyMykge1xuICAgICAgdmFyaWFibGUgPSB2YXIzO1xuICAgICAgdmFyVHlwZSA9ICcyJztcbiAgICB9XG5cbiAgICByZXR1cm4gYF9fVl8ke3ZhclR5cGV9X19gICsgdmFyaWFibGUgKyAnX19WX18nICsgKGZtdCA/ICdfX0ZfXycgKyBmbXQgKyAnX19GX18nIDogJycpO1xuICB9KTtcbn1cblxuY29uc3QgdmFyVHlwZUZ1bmMgPSBbXG4gICh2OiBzdHJpbmcsIGY/OiBzdHJpbmcpID0+IGBcXCQke3Z9YCxcbiAgKHY6IHN0cmluZywgZj86IHN0cmluZykgPT4gYFtbJHt2fSR7ZiA/IGA6JHtmfWAgOiAnJ31dXWAsXG4gICh2OiBzdHJpbmcsIGY/OiBzdHJpbmcpID0+IGBcXCRcXHske3Z9JHtmID8gYDoke2Z9YCA6ICcnfVxcfWAsXG5dO1xuXG4vKipcbiAqIEdldCBiYWNrIHRoZSB0ZXh0IHdpdGggdmFyaWFibGVzIGluIHRoZWlyIG9yaWdpbmFsIGZvcm1hdC5cbiAqIEBwYXJhbSBleHByXG4gKi9cbmZ1bmN0aW9uIHJldHVyblZhcmlhYmxlcyhleHByOiBzdHJpbmcpIHtcbiAgcmV0dXJuIGV4cHIucmVwbGFjZSgvX19WXyhcXGQpX18oLis/KV9fVl9fKD86X19GX18oXFx3KylfX0ZfXyk/L2csIChtYXRjaCwgdHlwZSwgdiwgZikgPT4ge1xuICAgIHJldHVybiB2YXJUeXBlRnVuY1twYXJzZUludCh0eXBlLCAxMCldKHYsIGYpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGFjdHVhbCBzdHJpbmcgb2YgdGhlIGV4cHJlc3Npb24uIFRoYXQgaXMgbm90IHN0b3JlZCBpbiB0aGUgdHJlZSBzbyB3ZSBoYXZlIHRvIGdldCB0aGUgaW5kZXhlcyBmcm9tIHRoZSBub2RlXG4gKiBhbmQgdGhlbiBiYXNlZCBvbiB0aGF0IGdldCBpdCBmcm9tIHRoZSBleHByZXNzaW9uLlxuICogQHBhcmFtIGV4cHJcbiAqIEBwYXJhbSBub2RlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTdHJpbmcoZXhwcjogc3RyaW5nLCBub2RlOiBTeW50YXhOb2RlIHwgVHJlZUN1cnNvciB8IG51bGwgfCB1bmRlZmluZWQpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHJldHVybiByZXR1cm5WYXJpYWJsZXMoZXhwci5zdWJzdHJpbmcobm9kZS5mcm9tLCBub2RlLnRvKSk7XG59XG5cbi8qKlxuICogQ3JlYXRlIHNpbXBsZSBzY2FsYXIgYmluYXJ5IG9wIG9iamVjdC5cbiAqIEBwYXJhbSBvcERlZiAtIGRlZmluaXRpb24gb2YgdGhlIG9wIHRvIGJlIGNyZWF0ZWRcbiAqIEBwYXJhbSBleHByXG4gKiBAcGFyYW0gbnVtYmVyTm9kZSAtIHRoZSBub2RlIGZvciB0aGUgc2NhbGFyXG4gKiBAcGFyYW0gaGFzQm9vbCAtIHdoZXRoZXIgb3BlcmF0aW9uIGhhcyBhIGJvb2wgbW9kaWZpZXIuIElzIHVzZWQgb25seSBmb3Igb3BzIGZvciB3aGljaCBpdCBtYWtlcyBzZW5zZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VCaW5PcChcbiAgb3BEZWY6IHsgaWQ6IHN0cmluZzsgY29tcGFyaXNvbj86IGJvb2xlYW4gfSxcbiAgZXhwcjogc3RyaW5nLFxuICBudW1iZXJOb2RlOiBTeW50YXhOb2RlLFxuICBoYXNCb29sOiBib29sZWFuXG4pOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24ge1xuICBjb25zdCBwYXJhbXM6IGFueVtdID0gW3BhcnNlRmxvYXQoZ2V0U3RyaW5nKGV4cHIsIG51bWJlck5vZGUpKV07XG4gIGlmIChvcERlZi5jb21wYXJpc29uKSB7XG4gICAgcGFyYW1zLnB1c2goaGFzQm9vbCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpZDogb3BEZWYuaWQsXG4gICAgcGFyYW1zLFxuICB9O1xufVxuXG4vKipcbiAqIEdldCBhbGwgbm9kZXMgd2l0aCB0eXBlIGluIHRoZSB0cmVlLiBUaGlzIHRyYXZlcnNlcyB0aGUgdHJlZSBzbyBpdCBpcyBzYWZlIG9ubHkgd2hlbiB5b3Uga25vdyB0aGVyZSBzaG91bGRuJ3QgYmVcbiAqIHRvbyBtdWNoIG5lc3RpbmcgYnV0IHlvdSBqdXN0IHdhbnQgdG8gc2tpcCBzb21lIG9mIHRoZSB3cmFwcGVycy4gRm9yIGV4YW1wbGUgZ2V0dGluZyBmdW5jdGlvbiBhcmdzIHRoaXMgd2F5IHdvdWxkXG4gKiBub3QgYmUgc2FmZSBpcyBpdCB3b3VsZCBhbHNvIGZpbmQgYXJndW1lbnRzIG9mIG5lc3RlZCBmdW5jdGlvbnMuXG4gKiBAcGFyYW0gZXhwclxuICogQHBhcmFtIGN1clxuICogQHBhcmFtIHR5cGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbEJ5VHlwZShleHByOiBzdHJpbmcsIGN1cjogU3ludGF4Tm9kZSwgdHlwZTogc3RyaW5nKTogc3RyaW5nW10ge1xuICBpZiAoY3VyLm5hbWUgPT09IHR5cGUpIHtcbiAgICByZXR1cm4gW2dldFN0cmluZyhleHByLCBjdXIpXTtcbiAgfVxuICBjb25zdCB2YWx1ZXM6IHN0cmluZ1tdID0gW107XG4gIGxldCBwb3MgPSAwO1xuICBsZXQgY2hpbGQgPSBjdXIuY2hpbGRBZnRlcihwb3MpO1xuICB3aGlsZSAoY2hpbGQpIHtcbiAgICB2YWx1ZXMucHVzaCguLi5nZXRBbGxCeVR5cGUoZXhwciwgY2hpbGQsIHR5cGUpKTtcbiAgICBwb3MgPSBjaGlsZC50bztcbiAgICBjaGlsZCA9IGN1ci5jaGlsZEFmdGVyKHBvcyk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlcztcbn1cblxuLy8gRGVidWdnaW5nIGZ1bmN0aW9uIGZvciBjb252ZW5pZW5jZS4gR2l2ZXMgeW91IG5pY2Ugb3V0cHV0IHNpbWlsYXIgdG8gbGludXggdHJlZSB1dGlsLlxuLy8gQHRzLWlnbm9yZVxuZXhwb3J0IGZ1bmN0aW9uIGxvZyhleHByOiBzdHJpbmcsIGN1cj86IFN5bnRheE5vZGUpIHtcbiAgaWYgKCFjdXIpIHtcbiAgICBjb25zb2xlLmxvZygnPGVtcHR5PicpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBqc29uID0gdG9Kc29uKGV4cHIsIGN1cik7XG4gIGNvbnN0IHRleHQgPSBqc29uVG9UZXh0KGpzb24pO1xuXG4gIGlmICghdGV4dCkge1xuICAgIGNvbnNvbGUubG9nKCc8ZW1wdHk+Jyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnNvbGUubG9nKHRleHQpO1xufVxuXG5mdW5jdGlvbiB0b0pzb24oZXhwcjogc3RyaW5nLCBjdXI6IFN5bnRheE5vZGUpIHtcbiAgY29uc3QgdHJlZUpzb246IGFueSA9IHt9O1xuICBjb25zdCBuYW1lID0gbm9kZVRvU3RyaW5nKGV4cHIsIGN1cik7XG4gIGNvbnN0IGNoaWxkcmVuID0gW107XG5cbiAgbGV0IHBvcyA9IDA7XG4gIGxldCBjaGlsZCA9IGN1ci5jaGlsZEFmdGVyKHBvcyk7XG4gIHdoaWxlIChjaGlsZCkge1xuICAgIGNoaWxkcmVuLnB1c2godG9Kc29uKGV4cHIsIGNoaWxkKSk7XG4gICAgcG9zID0gY2hpbGQudG87XG4gICAgY2hpbGQgPSBjdXIuY2hpbGRBZnRlcihwb3MpO1xuICB9XG5cbiAgdHJlZUpzb24ubmFtZSA9IG5hbWU7XG4gIHRyZWVKc29uLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHJldHVybiB0cmVlSnNvbjtcbn1cblxudHlwZSBKc29uTm9kZSA9IHtcbiAgbmFtZTogc3RyaW5nO1xuICBjaGlsZHJlbjogSnNvbk5vZGVbXTtcbn07XG5cbmZ1bmN0aW9uIGpzb25Ub1RleHQoXG4gIG5vZGU6IEpzb25Ob2RlLFxuICBjb250ZXh0OiB7IGxhc3RDaGlsZDogYm9vbGVhbjsgaW5kZW50OiBzdHJpbmcgfSA9IHtcbiAgICBsYXN0Q2hpbGQ6IHRydWUsXG4gICAgaW5kZW50OiAnJyxcbiAgfVxuKSB7XG4gIGNvbnN0IG5hbWUgPSBub2RlLm5hbWU7XG4gIGNvbnN0IHsgbGFzdENoaWxkLCBpbmRlbnQgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IG5ld0luZGVudCA9IGluZGVudCAhPT0gJycgPyBpbmRlbnQgKyAobGFzdENoaWxkID8gJ+KUlOKUgCcgOiAn4pSc4pSAJykgOiAnJztcbiAgbGV0IHRleHQgPSBuZXdJbmRlbnQgKyBuYW1lO1xuXG4gIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQ6IGFueSwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IGlzTGFzdENoaWxkID0gaW5kZXggPT09IGNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgdGV4dCArPVxuICAgICAgJ1xcbicgK1xuICAgICAganNvblRvVGV4dChjaGlsZCwge1xuICAgICAgICBsYXN0Q2hpbGQ6IGlzTGFzdENoaWxkLFxuICAgICAgICBpbmRlbnQ6IGluZGVudCArIChsYXN0Q2hpbGQgPyAnICAnIDogJ+KUgiAnKSxcbiAgICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gdGV4dDtcbn1cblxuZnVuY3Rpb24gbm9kZVRvU3RyaW5nKGV4cHI6IHN0cmluZywgbm9kZTogU3ludGF4Tm9kZSkge1xuICByZXR1cm4gbm9kZS5uYW1lICsgJzogJyArIGdldFN0cmluZyhleHByLCBub2RlKTtcbn1cbiIsIi8qKlxuICogU2hhcmVkIHR5cGVzIHRoYXQgY2FuIGJlIHJldXNlZCBieSBMb2tpIGFuZCBvdGhlciBkYXRhIHNvdXJjZXNcbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnRUeXBlIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBEYXRhU291cmNlQXBpLCBSZWdpc3RyeUl0ZW0sIFNlbGVjdGFibGVWYWx1ZSB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyIHtcbiAgbGFiZWw6IHN0cmluZztcbiAgb3A6IHN0cmluZztcbiAgdmFsdWU6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBRdWVyeUJ1aWxkZXJPcGVyYXRpb24ge1xuICBpZDogc3RyaW5nO1xuICBwYXJhbXM6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtVmFsdWVbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBRdWVyeVdpdGhPcGVyYXRpb25zIHtcbiAgb3BlcmF0aW9uczogUXVlcnlCdWlsZGVyT3BlcmF0aW9uW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmPFQgPSBhbnk+IGV4dGVuZHMgUmVnaXN0cnlJdGVtIHtcbiAgZG9jdW1lbnRhdGlvbj86IHN0cmluZztcbiAgcGFyYW1zOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbURlZltdO1xuICBkZWZhdWx0UGFyYW1zOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbVZhbHVlW107XG4gIGNhdGVnb3J5OiBzdHJpbmc7XG4gIGhpZGVGcm9tTGlzdD86IGJvb2xlYW47XG4gIGFsdGVybmF0aXZlc0tleT86IHN0cmluZztcbiAgLyoqIENhbiBiZSB1c2VkIHRvIGNvbnRyb2wgb3BlcmF0aW9uIHBsYWNlbWVudCB3aGVuIGFkZGluZyBhIG5ldyBvcGVyYXRpb25zLCBsb3dlciBhcmUgcGxhY2VkIGZpcnN0ICovXG4gIG9yZGVyUmFuaz86IG51bWJlcjtcbiAgcmVuZGVyZXI6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblJlbmRlcmVyO1xuICBhZGRPcGVyYXRpb25IYW5kbGVyOiBRdWVyeUJ1aWxkZXJBZGRPcGVyYXRpb25IYW5kbGVyPFQ+O1xuICBwYXJhbUNoYW5nZWRIYW5kbGVyPzogUXVlcnlCdWlsZGVyT25QYXJhbUNoYW5nZWRIYW5kbGVyO1xuICBleHBsYWluSGFuZGxlcj86IFF1ZXJ5QnVpbGRlckV4cGxhaW5PcGVyYXRpb25IYW5kbGVyO1xuICBjaGFuZ2VUeXBlSGFuZGxlcj86IChvcDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLCBuZXdEZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZjxUPikgPT4gUXVlcnlCdWlsZGVyT3BlcmF0aW9uO1xufVxuXG5leHBvcnQgdHlwZSBRdWVyeUJ1aWxkZXJBZGRPcGVyYXRpb25IYW5kbGVyPFQ+ID0gKFxuICBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZixcbiAgcXVlcnk6IFQsXG4gIG1vZGVsbGVyOiBWaXN1YWxRdWVyeU1vZGVsbGVyXG4pID0+IFQ7XG5cbmV4cG9ydCB0eXBlIFF1ZXJ5QnVpbGRlckV4cGxhaW5PcGVyYXRpb25IYW5kbGVyID0gKG9wOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmKSA9PiBzdHJpbmc7XG5cbmV4cG9ydCB0eXBlIFF1ZXJ5QnVpbGRlck9uUGFyYW1DaGFuZ2VkSGFuZGxlciA9IChcbiAgaW5kZXg6IG51bWJlcixcbiAgb3BlcmF0aW9uOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sXG4gIG9wZXJhdGlvbkRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmXG4pID0+IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbjtcblxuZXhwb3J0IHR5cGUgUXVlcnlCdWlsZGVyT3BlcmF0aW9uUmVuZGVyZXIgPSAoXG4gIG1vZGVsOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sXG4gIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLFxuICBpbm5lckV4cHI6IHN0cmluZ1xuKSA9PiBzdHJpbmc7XG5cbmV4cG9ydCB0eXBlIFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtVmFsdWUgPSBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuO1xuXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmIHtcbiAgbmFtZTogc3RyaW5nO1xuICB0eXBlOiAnc3RyaW5nJyB8ICdudW1iZXInIHwgJ2Jvb2xlYW4nO1xuICBvcHRpb25zPzogc3RyaW5nW10gfCBudW1iZXJbXSB8IEFycmF5PFNlbGVjdGFibGVWYWx1ZTxzdHJpbmc+PjtcbiAgaGlkZU5hbWU/OiBib29sZWFuO1xuICByZXN0UGFyYW0/OiBib29sZWFuO1xuICBvcHRpb25hbD86IGJvb2xlYW47XG4gIHBsYWNlaG9sZGVyPzogc3RyaW5nO1xuICBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgbWluV2lkdGg/OiBudW1iZXI7XG4gIGVkaXRvcj86IENvbXBvbmVudFR5cGU8UXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1FZGl0b3JQcm9wcz47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUXVlcnlCdWlsZGVyT3BlcmF0aW9uRWRpdG9yUHJvcHMge1xuICBvcGVyYXRpb246IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbjtcbiAgaW5kZXg6IG51bWJlcjtcbiAgcXVlcnk6IGFueTtcbiAgZGF0YXNvdXJjZTogRGF0YVNvdXJjZUFwaTtcbiAgcXVlcnlNb2RlbGxlcjogVmlzdWFsUXVlcnlNb2RlbGxlcjtcbiAgb25DaGFuZ2U6IChpbmRleDogbnVtYmVyLCB1cGRhdGU6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbikgPT4gdm9pZDtcbiAgb25SZW1vdmU6IChpbmRleDogbnVtYmVyKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRWRpdG9yUHJvcHMge1xuICB2YWx1ZT86IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtVmFsdWU7XG4gIHBhcmFtRGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbURlZjtcbiAgLyoqIFBhcmFtZXRlciBpbmRleCAqL1xuICBpbmRleDogbnVtYmVyO1xuICBvcGVyYXRpb246IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbjtcbiAgb3BlcmF0aW9uSW5kZXg6IG51bWJlcjtcbiAgcXVlcnk6IGFueTtcbiAgZGF0YXNvdXJjZTogRGF0YVNvdXJjZUFwaTtcbiAgb25DaGFuZ2U6IChpbmRleDogbnVtYmVyLCB2YWx1ZTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1WYWx1ZSkgPT4gdm9pZDtcbiAgb25SdW5RdWVyeTogKCkgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGVudW0gUXVlcnlFZGl0b3JNb2RlIHtcbiAgQ29kZSA9ICdjb2RlJyxcbiAgQnVpbGRlciA9ICdidWlsZGVyJyxcbiAgRXhwbGFpbiA9ICdleHBsYWluJyxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBWaXN1YWxRdWVyeU1vZGVsbGVyIHtcbiAgZ2V0T3BlcmF0aW9uc0ZvckNhdGVnb3J5KGNhdGVnb3J5OiBzdHJpbmcpOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWZbXTtcbiAgZ2V0QWx0ZXJuYXRpdmVPcGVyYXRpb25zKGtleTogc3RyaW5nKTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmW107XG4gIGdldENhdGVnb3JpZXMoKTogc3RyaW5nW107XG4gIGdldE9wZXJhdGlvbkRlZihpZDogc3RyaW5nKTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmIHwgdW5kZWZpbmVkO1xufVxuIiwiaW1wb3J0IHsgQ29yZUFwcCB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHN0b3JlIGZyb20gJ2FwcC9jb3JlL3N0b3JlJztcblxuaW1wb3J0IHsgTGVnZW5kRm9ybWF0TW9kZSwgUHJvbVF1ZXJ5IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBRdWVyeUVkaXRvck1vZGUgfSBmcm9tICcuL3NoYXJlZC90eXBlcyc7XG5cbmNvbnN0IHF1ZXJ5RWRpdG9yTW9kZURlZmF1bHRMb2NhbFN0b3JhZ2VLZXkgPSAnUHJvbWV0aGV1c1F1ZXJ5RWRpdG9yTW9kZURlZmF1bHQnO1xuXG5leHBvcnQgZnVuY3Rpb24gY2hhbmdlRWRpdG9yTW9kZShxdWVyeTogUHJvbVF1ZXJ5LCBlZGl0b3JNb2RlOiBRdWVyeUVkaXRvck1vZGUsIG9uQ2hhbmdlOiAocXVlcnk6IFByb21RdWVyeSkgPT4gdm9pZCkge1xuICAvLyBJZiBlbXB0eSBxdWVyeSBzdG9yZSBuZXcgbW9kZSBhcyBkZWZhdWx0XG4gIGlmIChxdWVyeS5leHByID09PSAnJykge1xuICAgIHN0b3JlLnNldChxdWVyeUVkaXRvck1vZGVEZWZhdWx0TG9jYWxTdG9yYWdlS2V5LCBlZGl0b3JNb2RlKTtcbiAgfVxuXG4gIG9uQ2hhbmdlKHsgLi4ucXVlcnksIGVkaXRvck1vZGUgfSk7XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRFZGl0b3JNb2RlKGV4cHI6IHN0cmluZykge1xuICAvLyBJZiB3ZSBhbHJlYWR5IGhhdmUgYW4gZXhwcmVzc2lvbiBkZWZhdWx0IHRvIGNvZGUgdmlld1xuICBpZiAoZXhwciAhPSBudWxsICYmIGV4cHIgIT09ICcnKSB7XG4gICAgcmV0dXJuIFF1ZXJ5RWRpdG9yTW9kZS5Db2RlO1xuICB9XG5cbiAgY29uc3QgdmFsdWUgPSBzdG9yZS5nZXQocXVlcnlFZGl0b3JNb2RlRGVmYXVsdExvY2FsU3RvcmFnZUtleSkgYXMgUXVlcnlFZGl0b3JNb2RlO1xuICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgY2FzZSBRdWVyeUVkaXRvck1vZGUuQnVpbGRlcjpcbiAgICBjYXNlIFF1ZXJ5RWRpdG9yTW9kZS5Db2RlOlxuICAgIGNhc2UgUXVlcnlFZGl0b3JNb2RlLkV4cGxhaW46XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBRdWVyeUVkaXRvck1vZGUuQnVpbGRlcjtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgcXVlcnkgd2l0aCBkZWZhdWx0cywgYW5kIGJvb2xlYW4gdHJ1ZS9mYWxzZSBkZXBlbmRpbmcgb24gY2hhbmdlIHdhcyByZXF1aXJlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UXVlcnlXaXRoRGVmYXVsdHMocXVlcnk6IFByb21RdWVyeSwgYXBwOiBDb3JlQXBwIHwgdW5kZWZpbmVkKTogUHJvbVF1ZXJ5IHtcbiAgbGV0IHJlc3VsdCA9IHF1ZXJ5O1xuXG4gIGlmICghcXVlcnkuZWRpdG9yTW9kZSkge1xuICAgIHJlc3VsdCA9IHsgLi4ucXVlcnksIGVkaXRvck1vZGU6IGdldERlZmF1bHRFZGl0b3JNb2RlKHF1ZXJ5LmV4cHIpIH07XG4gIH1cblxuICBpZiAocXVlcnkuZXhwciA9PSBudWxsKSB7XG4gICAgcmVzdWx0ID0geyAuLi5yZXN1bHQsIGV4cHI6ICcnLCBsZWdlbmRGb3JtYXQ6IExlZ2VuZEZvcm1hdE1vZGUuQXV0byB9O1xuICB9XG5cbiAgaWYgKHF1ZXJ5LnJhbmdlID09IG51bGwgJiYgcXVlcnkuaW5zdGFudCA9PSBudWxsKSB7XG4gICAgLy8gRGVmYXVsdCB0byByYW5nZSBxdWVyeVxuICAgIHJlc3VsdCA9IHsgLi4ucmVzdWx0LCByYW5nZTogdHJ1ZSB9O1xuXG4gICAgLy8gSW4gZXhwbG9yZSB3ZSBkZWZhdWx0IHRvIGJvdGggaW5zdGFudCAmIHJhbmdlXG4gICAgaWYgKGFwcCA9PT0gQ29yZUFwcC5FeHBsb3JlKSB7XG4gICAgICByZXN1bHQuaW5zdGFudCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsImltcG9ydCB7IFZpc3VhbFF1ZXJ5QmluYXJ5IH0gZnJvbSAnLi9zaGFyZWQvTG9raUFuZFByb21RdWVyeU1vZGVsbGVyQmFzZSc7XG5pbXBvcnQgeyBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlciwgUXVlcnlCdWlsZGVyT3BlcmF0aW9uIH0gZnJvbSAnLi9zaGFyZWQvdHlwZXMnO1xuXG4vKipcbiAqIFZpc3VhbCBxdWVyeSBtb2RlbFxuICovXG5leHBvcnQgaW50ZXJmYWNlIFByb21WaXN1YWxRdWVyeSB7XG4gIG1ldHJpYzogc3RyaW5nO1xuICBsYWJlbHM6IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyW107XG4gIG9wZXJhdGlvbnM6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbltdO1xuICBiaW5hcnlRdWVyaWVzPzogUHJvbVZpc3VhbFF1ZXJ5QmluYXJ5W107XG59XG5cbmV4cG9ydCB0eXBlIFByb21WaXN1YWxRdWVyeUJpbmFyeSA9IFZpc3VhbFF1ZXJ5QmluYXJ5PFByb21WaXN1YWxRdWVyeT47XG5cbmV4cG9ydCBlbnVtIFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5IHtcbiAgQWdncmVnYXRpb25zID0gJ0FnZ3JlZ2F0aW9ucycsXG4gIFJhbmdlRnVuY3Rpb25zID0gJ1JhbmdlIGZ1bmN0aW9ucycsXG4gIEZ1bmN0aW9ucyA9ICdGdW5jdGlvbnMnLFxuICBCaW5hcnlPcHMgPSAnQmluYXJ5IG9wZXJhdGlvbnMnLFxuICBUcmlnb25vbWV0cmljID0gJ1RyaWdvbm9tZXRyaWMnLFxuICBUaW1lID0gJ1RpbWUgRnVuY3Rpb25zJyxcbn1cblxuZXhwb3J0IGVudW0gUHJvbU9wZXJhdGlvbklkIHtcbiAgQWJzID0gJ2FicycsXG4gIEFic2VudCA9ICdhYnNlbnQnLFxuICBBYnNlbnRPdmVyVGltZSA9ICdhYnNlbnRfb3Zlcl90aW1lJyxcbiAgQWNvcyA9ICdhY29zJyxcbiAgQWNvc2ggPSAnYWNvc2gnLFxuICBBc2luID0gJ2FzaW4nLFxuICBBc2luaCA9ICdhc2luaCcsXG4gIEF0YW4gPSAnYXRhbicsXG4gIEF0YW5oID0gJ2F0YW5oJyxcbiAgQXZnID0gJ2F2ZycsXG4gIEF2Z092ZXJUaW1lID0gJ2F2Z19vdmVyX3RpbWUnLFxuICBCb3R0b21LID0gJ2JvdHRvbWsnLFxuICBDZWlsID0gJ2NlaWwnLFxuICBDaGFuZ2VzID0gJ2NoYW5nZXMnLFxuICBDbGFtcCA9ICdjbGFtcCcsXG4gIENsYW1wTWF4ID0gJ2NsYW1wX21heCcsXG4gIENsYW1wTWluID0gJ2NsYW1wX21pbicsXG4gIENvcyA9ICdjb3MnLFxuICBDb3NoID0gJ2Nvc2gnLFxuICBDb3VudCA9ICdjb3VudCcsXG4gIENvdW50T3ZlclRpbWUgPSAnY291bnRfb3Zlcl90aW1lJyxcbiAgQ291bnRTY2FsYXIgPSAnY291bnRfc2NhbGFyJyxcbiAgQ291bnRWYWx1ZXMgPSAnY291bnRfdmFsdWVzJyxcbiAgRGF5T2ZNb250aCA9ICdkYXlfb2ZfbW9udGgnLFxuICBEYXlPZldlZWsgPSAnZGF5X29mX3dlZWsnLFxuICBEYXlzSW5Nb250aCA9ICdkYXlzX2luX21vbnRoJyxcbiAgRGVnID0gJ2RlZycsXG4gIERlbHRhID0gJ2RlbHRhJyxcbiAgRGVyaXYgPSAnZGVyaXYnLFxuICBEcm9wQ29tbW9uTGFiZWxzID0gJ2Ryb3BfY29tbW9uX2xhYmVscycsXG4gIEV4cCA9ICdleHAnLFxuICBGbG9vciA9ICdmbG9vcicsXG4gIEdyb3VwID0gJ2dyb3VwJyxcbiAgSGlzdG9ncmFtUXVhbnRpbGUgPSAnaGlzdG9ncmFtX3F1YW50aWxlJyxcbiAgSG9sdFdpbnRlcnMgPSAnaG9sdF93aW50ZXJzJyxcbiAgSG91ciA9ICdob3VyJyxcbiAgSWRlbHRhID0gJ2lkZWx0YScsXG4gIEluY3JlYXNlID0gJ2luY3JlYXNlJyxcbiAgSXJhdGUgPSAnaXJhdGUnLFxuICBMYWJlbEpvaW4gPSAnbGFiZWxfam9pbicsXG4gIExhYmVsUmVwbGFjZSA9ICdsYWJlbF9yZXBsYWNlJyxcbiAgTGFzdCA9ICdsYXN0JyxcbiAgTGFzdE92ZXJUaW1lID0gJ2xhc3Rfb3Zlcl90aW1lJyxcbiAgTG4gPSAnbG4nLFxuICBMb2cxMCA9ICdsb2cxMCcsXG4gIExvZzIgPSAnbG9nMicsXG4gIE1heCA9ICdtYXgnLFxuICBNYXhPdmVyVGltZSA9ICdtYXhfb3Zlcl90aW1lJyxcbiAgTWluID0gJ21pbicsXG4gIE1pbk92ZXJUaW1lID0gJ21pbl9vdmVyX3RpbWUnLFxuICBNaW51dGUgPSAnbWludXRlJyxcbiAgTW9udGggPSAnbW9udGgnLFxuICBQaSA9ICdwaScsXG4gIFByZWRpY3RMaW5lYXIgPSAncHJlZGljdF9saW5lYXInLFxuICBQcmVzZW50ID0gJ3ByZXNlbnQnLFxuICBQcmVzZW50T3ZlclRpbWUgPSAncHJlc2VudF9vdmVyX3RpbWUnLFxuICBRdWFudGlsZSA9ICdxdWFudGlsZScsXG4gIFF1YW50aWxlT3ZlclRpbWUgPSAncXVhbnRpbGVfb3Zlcl90aW1lJyxcbiAgUmFkID0gJ3JhZCcsXG4gIFJhdGUgPSAncmF0ZScsXG4gIFJlc2V0cyA9ICdyZXNldHMnLFxuICBSb3VuZCA9ICdyb3VuZCcsXG4gIFNjYWxhciA9ICdzY2FsYXInLFxuICBTZ24gPSAnc2duJyxcbiAgU2luID0gJ3NpbicsXG4gIFNpbmggPSAnc2luaCcsXG4gIFNvcnQgPSAnc29ydCcsXG4gIFNvcnREZXNjID0gJ3NvcnRfZGVzYycsXG4gIFNxcnQgPSAnc3FydCcsXG4gIFN0ZGRldiA9ICdzdGRkZXYnLFxuICBTdGRkZXZPdmVyVGltZSA9ICdzdGRkZXZfb3Zlcl90aW1lJyxcbiAgU3VtID0gJ3N1bScsXG4gIFN1bU92ZXJUaW1lID0gJ3N1bV9vdmVyX3RpbWUnLFxuICBUYW4gPSAndGFuJyxcbiAgVGFuaCA9ICd0YW5oJyxcbiAgVGltZSA9ICd0aW1lJyxcbiAgVGltZXN0YW1wID0gJ3RpbWVzdGFtcCcsXG4gIFRvcEsgPSAndG9waycsXG4gIFZlY3RvciA9ICd2ZWN0b3InLFxuICBZZWFyID0gJ3llYXInLFxuICAvLyBCaW5hcnkgb3BzXG4gIEFkZGl0aW9uID0gJ19fYWRkaXRpb24nLFxuICBTdWJ0cmFjdGlvbiA9ICdfX3N1YnRyYWN0aW9uJyxcbiAgTXVsdGlwbHlCeSA9ICdfX211bHRpcGx5X2J5JyxcbiAgRGl2aWRlQnkgPSAnX19kaXZpZGVfYnknLFxuICBNb2R1bG8gPSAnX19tb2R1bG8nLFxuICBFeHBvbmVudCA9ICdfX2V4cG9uZW50JyxcbiAgTmVzdGVkUXVlcnkgPSAnX19uZXN0ZWRfcXVlcnknLFxuICBFcXVhbFRvID0gJ19fZXF1YWxfdG8nLFxuICBOb3RFcXVhbFRvID0gJ19fbm90X2VxdWFsX3RvJyxcbiAgR3JlYXRlclRoYW4gPSAnX19ncmVhdGVyX3RoYW4nLFxuICBMZXNzVGhhbiA9ICdfX2xlc3NfdGhhbicsXG4gIEdyZWF0ZXJPckVxdWFsID0gJ19fZ3JlYXRlcl9vcl9lcXVhbCcsXG4gIExlc3NPckVxdWFsID0gJ19fbGVzc19vcl9lcXVhbCcsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvbVF1ZXJ5UGF0dGVybiB7XG4gIG5hbWU6IHN0cmluZztcbiAgb3BlcmF0aW9uczogUXVlcnlCdWlsZGVyT3BlcmF0aW9uW107XG59XG4iLCJpbXBvcnQgeyBkZXNjZW5kaW5nLCBkZXZpYXRpb24gfSBmcm9tICdkMyc7XG5pbXBvcnQgeyBwYXJ0aXRpb24sIGdyb3VwQnkgfSBmcm9tICdsb2Rhc2gnO1xuXG5pbXBvcnQge1xuICBBcnJheURhdGFGcmFtZSxcbiAgQXJyYXlWZWN0b3IsXG4gIERhdGFGcmFtZSxcbiAgRGF0YUxpbmssXG4gIERhdGFUb3BpYyxcbiAgRmllbGQsXG4gIEZpZWxkVHlwZSxcbiAgZm9ybWF0TGFiZWxzLFxuICBnZXREaXNwbGF5UHJvY2Vzc29yLFxuICBMYWJlbHMsXG4gIE11dGFibGVGaWVsZCxcbiAgU2NvcGVkVmFycyxcbiAgVElNRV9TRVJJRVNfVElNRV9GSUVMRF9OQU1FLFxuICBUSU1FX1NFUklFU19WQUxVRV9GSUVMRF9OQU1FLFxuICBEYXRhUXVlcnlSZXNwb25zZSxcbiAgRGF0YVF1ZXJ5UmVxdWVzdCxcbiAgUHJlZmVycmVkVmlzdWFsaXNhdGlvblR5cGUsXG4gIENvcmVBcHAsXG4gIERhdGFGcmFtZVR5cGUsXG59IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgRmV0Y2hSZXNwb25zZSwgZ2V0RGF0YVNvdXJjZVNydiwgZ2V0VGVtcGxhdGVTcnYgfSBmcm9tICdAZ3JhZmFuYS9ydW50aW1lJztcblxuaW1wb3J0IHsgcmVuZGVyTGVnZW5kRm9ybWF0IH0gZnJvbSAnLi9sZWdlbmQnO1xuaW1wb3J0IHtcbiAgRXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb24sXG4gIGlzRXhlbXBsYXJEYXRhLFxuICBpc01hdHJpeERhdGEsXG4gIE1hdHJpeE9yVmVjdG9yUmVzdWx0LFxuICBQcm9tRGF0YVN1Y2Nlc3NSZXNwb25zZSxcbiAgUHJvbU1ldHJpYyxcbiAgUHJvbVF1ZXJ5LFxuICBQcm9tUXVlcnlSZXF1ZXN0LFxuICBQcm9tVmFsdWUsXG4gIFRyYW5zZm9ybU9wdGlvbnMsXG59IGZyb20gJy4vdHlwZXMnO1xuXG4vLyBoYW5kbGVzIGNhc2UtaW5zZW5zaXRpdmUgSW5mLCArSW5mLCAtSW5mICh3aXRoIG9wdGlvbmFsIFwiaW5pdHlcIiBzdWZmaXgpXG5jb25zdCBJTkZJTklUWV9TQU1QTEVfUkVHRVggPSAvXlsrLV0/aW5mKD86aW5pdHkpPyQvaTtcblxuaW50ZXJmYWNlIFRpbWVBbmRWYWx1ZSB7XG4gIFtUSU1FX1NFUklFU19USU1FX0ZJRUxEX05BTUVdOiBudW1iZXI7XG4gIFtUSU1FX1NFUklFU19WQUxVRV9GSUVMRF9OQU1FXTogbnVtYmVyO1xufVxuXG5jb25zdCBpc1RhYmxlUmVzdWx0ID0gKGRhdGFGcmFtZTogRGF0YUZyYW1lLCBvcHRpb25zOiBEYXRhUXVlcnlSZXF1ZXN0PFByb21RdWVyeT4pOiBib29sZWFuID0+IHtcbiAgLy8gV2Ugd2FudCB0byBwcm9jZXNzIHZlY3RvciBhbmQgc2NhbGFyIHJlc3VsdHMgaW4gRXhwbG9yZSBhcyB0YWJsZVxuICBpZiAoXG4gICAgb3B0aW9ucy5hcHAgPT09IENvcmVBcHAuRXhwbG9yZSAmJlxuICAgIChkYXRhRnJhbWUubWV0YT8uY3VzdG9tPy5yZXN1bHRUeXBlID09PSAndmVjdG9yJyB8fCBkYXRhRnJhbWUubWV0YT8uY3VzdG9tPy5yZXN1bHRUeXBlID09PSAnc2NhbGFyJylcbiAgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBXZSB3YW50IHRvIHByb2Nlc3MgYWxsIGRhdGFGcmFtZXMgd2l0aCB0YXJnZXQuZm9ybWF0ID09PSAndGFibGUnIGFzIHRhYmxlXG4gIGNvbnN0IHRhcmdldCA9IG9wdGlvbnMudGFyZ2V0cy5maW5kKCh0YXJnZXQpID0+IHRhcmdldC5yZWZJZCA9PT0gZGF0YUZyYW1lLnJlZklkKTtcbiAgcmV0dXJuIHRhcmdldD8uZm9ybWF0ID09PSAndGFibGUnO1xufTtcblxuY29uc3QgaXNIZWF0bWFwUmVzdWx0ID0gKGRhdGFGcmFtZTogRGF0YUZyYW1lLCBvcHRpb25zOiBEYXRhUXVlcnlSZXF1ZXN0PFByb21RdWVyeT4pOiBib29sZWFuID0+IHtcbiAgY29uc3QgdGFyZ2V0ID0gb3B0aW9ucy50YXJnZXRzLmZpbmQoKHRhcmdldCkgPT4gdGFyZ2V0LnJlZklkID09PSBkYXRhRnJhbWUucmVmSWQpO1xuICByZXR1cm4gdGFyZ2V0Py5mb3JtYXQgPT09ICdoZWF0bWFwJztcbn07XG5cbi8vIFYyIHJlc3VsdCB0cmFzbmZvcm1lciB1c2VkIHRvIHRyYW5zZm9ybSBxdWVyeSByZXN1bHRzIGZyb20gcXVlcmllcyB0aGF0IHdlcmUgcnVuIHRyb3VnaCBwcm9tZXRoZXVzIGJhY2tlbmRcbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1WMihcbiAgcmVzcG9uc2U6IERhdGFRdWVyeVJlc3BvbnNlLFxuICByZXF1ZXN0OiBEYXRhUXVlcnlSZXF1ZXN0PFByb21RdWVyeT4sXG4gIG9wdGlvbnM6IHsgZXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb25zPzogRXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb25bXSB9XG4pIHtcbiAgY29uc3QgW3RhYmxlRnJhbWVzLCBmcmFtZXNXaXRob3V0VGFibGVdID0gcGFydGl0aW9uPERhdGFGcmFtZT4ocmVzcG9uc2UuZGF0YSwgKGRmKSA9PiBpc1RhYmxlUmVzdWx0KGRmLCByZXF1ZXN0KSk7XG4gIGNvbnN0IHByb2Nlc3NlZFRhYmxlRnJhbWVzID0gdHJhbnNmb3JtREZUb1RhYmxlKHRhYmxlRnJhbWVzKTtcblxuICBjb25zdCBbZXhlbXBsYXJGcmFtZXMsIGZyYW1lc1dpdGhvdXRUYWJsZUFuZEV4ZW1wbGFyc10gPSBwYXJ0aXRpb248RGF0YUZyYW1lPihcbiAgICBmcmFtZXNXaXRob3V0VGFibGUsXG4gICAgKGRmKSA9PiBkZi5tZXRhPy5jdXN0b20/LnJlc3VsdFR5cGUgPT09ICdleGVtcGxhcidcbiAgKTtcblxuICAvLyBFWEVNUExBUiBGUkFNRVM6IFdlIGVucmljaCBleGVtcGxhciBmcmFtZXMgd2l0aCBkYXRhIGxpbmtzIGFuZCBhZGQgZGF0YVRvcGljIG1ldGEgaW5mb1xuICBjb25zdCB7IGV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uczogZGVzdGluYXRpb25zIH0gPSBvcHRpb25zO1xuICBjb25zdCBwcm9jZXNzZWRFeGVtcGxhckZyYW1lcyA9IGV4ZW1wbGFyRnJhbWVzLm1hcCgoZGF0YUZyYW1lKSA9PiB7XG4gICAgaWYgKGRlc3RpbmF0aW9ucz8ubGVuZ3RoKSB7XG4gICAgICBmb3IgKGNvbnN0IGV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uIG9mIGRlc3RpbmF0aW9ucykge1xuICAgICAgICBjb25zdCB0cmFjZUlERmllbGQgPSBkYXRhRnJhbWUuZmllbGRzLmZpbmQoKGZpZWxkKSA9PiBmaWVsZC5uYW1lID09PSBleGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbi5uYW1lKTtcbiAgICAgICAgaWYgKHRyYWNlSURGaWVsZCkge1xuICAgICAgICAgIGNvbnN0IGxpbmtzID0gZ2V0RGF0YUxpbmtzKGV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uKTtcbiAgICAgICAgICB0cmFjZUlERmllbGQuY29uZmlnLmxpbmtzID0gdHJhY2VJREZpZWxkLmNvbmZpZy5saW5rcz8ubGVuZ3RoXG4gICAgICAgICAgICA/IFsuLi50cmFjZUlERmllbGQuY29uZmlnLmxpbmtzLCAuLi5saW5rc11cbiAgICAgICAgICAgIDogbGlua3M7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyAuLi5kYXRhRnJhbWUsIG1ldGE6IHsgLi4uZGF0YUZyYW1lLm1ldGEsIGRhdGFUb3BpYzogRGF0YVRvcGljLkFubm90YXRpb25zIH0gfTtcbiAgfSk7XG5cbiAgY29uc3QgW2hlYXRtYXBSZXN1bHRzLCBmcmFtZXNXaXRob3V0VGFibGVIZWF0bWFwc0FuZEV4ZW1wbGFyc10gPSBwYXJ0aXRpb248RGF0YUZyYW1lPihcbiAgICBmcmFtZXNXaXRob3V0VGFibGVBbmRFeGVtcGxhcnMsXG4gICAgKGRmKSA9PiBpc0hlYXRtYXBSZXN1bHQoZGYsIHJlcXVlc3QpXG4gICk7XG5cbiAgY29uc3QgcHJvY2Vzc2VkSGVhdG1hcEZyYW1lcyA9IG1lcmdlSGVhdG1hcEZyYW1lcyhcbiAgICB0cmFuc2Zvcm1Ub0hpc3RvZ3JhbU92ZXJUaW1lKGhlYXRtYXBSZXN1bHRzLnNvcnQoc29ydFNlcmllc0J5TGFiZWwpKVxuICApO1xuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpcyBwcm9jZXNzZWQgYXMgdGltZV9zZXJpZXMgcmVzdWx0IGFuZCBncmFwaCBwcmVmZXJyZWRWaXN1YWxpc2F0aW9uVHlwZVxuICBjb25zdCBvdGhlckZyYW1lcyA9IGZyYW1lc1dpdGhvdXRUYWJsZUhlYXRtYXBzQW5kRXhlbXBsYXJzLm1hcCgoZGF0YUZyYW1lKSA9PiB7XG4gICAgY29uc3QgZGYgPSB7XG4gICAgICAuLi5kYXRhRnJhbWUsXG4gICAgICBtZXRhOiB7XG4gICAgICAgIC4uLmRhdGFGcmFtZS5tZXRhLFxuICAgICAgICBwcmVmZXJyZWRWaXN1YWxpc2F0aW9uVHlwZTogJ2dyYXBoJyxcbiAgICAgIH0sXG4gICAgfSBhcyBEYXRhRnJhbWU7XG4gICAgcmV0dXJuIGRmO1xuICB9KTtcblxuICByZXR1cm4ge1xuICAgIC4uLnJlc3BvbnNlLFxuICAgIGRhdGE6IFsuLi5vdGhlckZyYW1lcywgLi4ucHJvY2Vzc2VkVGFibGVGcmFtZXMsIC4uLnByb2Nlc3NlZEhlYXRtYXBGcmFtZXMsIC4uLnByb2Nlc3NlZEV4ZW1wbGFyRnJhbWVzXSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybURGVG9UYWJsZShkZnM6IERhdGFGcmFtZVtdKTogRGF0YUZyYW1lW10ge1xuICAvLyBJZiBubyBkYXRhRnJhbWVzIG9yIGlmIDEgZGF0YUZyYW1lcyB3aXRoIG5vIHZhbHVlcywgcmV0dXJuIG9yaWdpbmFsIGRhdGFGcmFtZVxuICBpZiAoZGZzLmxlbmd0aCA9PT0gMCB8fCAoZGZzLmxlbmd0aCA9PT0gMSAmJiBkZnNbMF0ubGVuZ3RoID09PSAwKSkge1xuICAgIHJldHVybiBkZnM7XG4gIH1cblxuICAvLyBHcm91cCByZXN1bHRzIGJ5IHJlZklkIGFuZCBwcm9jZXNzIGRhdGFGcmFtZXMgd2l0aCB0aGUgc2FtZSByZWZJZCBhcyAxIGRhdGFGcmFtZVxuICBjb25zdCBkYXRhRnJhbWVzQnlSZWZJZCA9IGdyb3VwQnkoZGZzLCAncmVmSWQnKTtcbiAgY29uc3QgcmVmSWRzID0gT2JqZWN0LmtleXMoZGF0YUZyYW1lc0J5UmVmSWQpO1xuXG4gIGNvbnN0IGZyYW1lcyA9IHJlZklkcy5tYXAoKHJlZklkKSA9PiB7XG4gICAgLy8gQ3JlYXRlIHRpbWVGaWVsZCwgdmFsdWVGaWVsZCBhbmQgbGFiZWxGaWVsZHNcbiAgICBjb25zdCB2YWx1ZVRleHQgPSBnZXRWYWx1ZVRleHQocmVmSWRzLmxlbmd0aCwgcmVmSWQpO1xuICAgIGNvbnN0IHZhbHVlRmllbGQgPSBnZXRWYWx1ZUZpZWxkKHsgZGF0YTogW10sIHZhbHVlTmFtZTogdmFsdWVUZXh0IH0pO1xuICAgIGNvbnN0IHRpbWVGaWVsZCA9IGdldFRpbWVGaWVsZChbXSk7XG4gICAgY29uc3QgbGFiZWxGaWVsZHM6IE11dGFibGVGaWVsZFtdID0gW107XG5cbiAgICAvLyBGaWxsIGxhYmVsc0ZpZWxkcyB3aXRoIGxhYmVscyBmcm9tIGRhdGFGcmFtZXNcbiAgICBkYXRhRnJhbWVzQnlSZWZJZFtyZWZJZF0uZm9yRWFjaCgoZGYpID0+IHtcbiAgICAgIGNvbnN0IGZyYW1lVmFsdWVGaWVsZCA9IGRmLmZpZWxkc1sxXTtcbiAgICAgIGNvbnN0IHByb21MYWJlbHMgPSBmcmFtZVZhbHVlRmllbGQubGFiZWxzID8/IHt9O1xuXG4gICAgICBPYmplY3Qua2V5cyhwcm9tTGFiZWxzKVxuICAgICAgICAuc29ydCgpXG4gICAgICAgIC5mb3JFYWNoKChsYWJlbCkgPT4ge1xuICAgICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgbGFiZWwgaW4gbGFiZWxGaWVsZHMsIGFkZCBpdFxuICAgICAgICAgIGlmICghbGFiZWxGaWVsZHMuc29tZSgobCkgPT4gbC5uYW1lID09PSBsYWJlbCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG51bWJlckZpZWxkID0gbGFiZWwgPT09ICdsZSc7XG4gICAgICAgICAgICBsYWJlbEZpZWxkcy5wdXNoKHtcbiAgICAgICAgICAgICAgbmFtZTogbGFiZWwsXG4gICAgICAgICAgICAgIGNvbmZpZzogeyBmaWx0ZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgICAgICAgIHR5cGU6IG51bWJlckZpZWxkID8gRmllbGRUeXBlLm51bWJlciA6IEZpZWxkVHlwZS5zdHJpbmcsXG4gICAgICAgICAgICAgIHZhbHVlczogbmV3IEFycmF5VmVjdG9yKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gRmlsbCB2YWx1ZUZpZWxkLCB0aW1lRmllbGQgYW5kIGxhYmVsRmllbGRzIHdpdGggdmFsdWVzXG4gICAgZGF0YUZyYW1lc0J5UmVmSWRbcmVmSWRdLmZvckVhY2goKGRmKSA9PiB7XG4gICAgICBkZi5maWVsZHNbMF0udmFsdWVzLnRvQXJyYXkoKS5mb3JFYWNoKCh2YWx1ZSkgPT4gdGltZUZpZWxkLnZhbHVlcy5hZGQodmFsdWUpKTtcbiAgICAgIGRmLmZpZWxkc1sxXS52YWx1ZXMudG9BcnJheSgpLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICAgIHZhbHVlRmllbGQudmFsdWVzLmFkZChwYXJzZVNhbXBsZVZhbHVlKHZhbHVlKSk7XG4gICAgICAgIGNvbnN0IGxhYmVsc0ZvckZpZWxkID0gZGYuZmllbGRzWzFdLmxhYmVscyA/PyB7fTtcbiAgICAgICAgbGFiZWxGaWVsZHMuZm9yRWFjaCgoZmllbGQpID0+IGZpZWxkLnZhbHVlcy5hZGQoZ2V0TGFiZWxWYWx1ZShsYWJlbHNGb3JGaWVsZCwgZmllbGQubmFtZSkpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgY29uc3QgZmllbGRzID0gW3RpbWVGaWVsZCwgLi4ubGFiZWxGaWVsZHMsIHZhbHVlRmllbGRdO1xuICAgIHJldHVybiB7XG4gICAgICByZWZJZCxcbiAgICAgIGZpZWxkcyxcbiAgICAgIG1ldGE6IHsgLi4uZGZzWzBdLm1ldGEsIHByZWZlcnJlZFZpc3VhbGlzYXRpb25UeXBlOiAndGFibGUnIGFzIFByZWZlcnJlZFZpc3VhbGlzYXRpb25UeXBlIH0sXG4gICAgICBsZW5ndGg6IHRpbWVGaWVsZC52YWx1ZXMubGVuZ3RoLFxuICAgIH07XG4gIH0pO1xuICByZXR1cm4gZnJhbWVzO1xufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZVRleHQocmVzcG9uc2VMZW5ndGg6IG51bWJlciwgcmVmSWQgPSAnJykge1xuICByZXR1cm4gcmVzcG9uc2VMZW5ndGggPiAxID8gYFZhbHVlICMke3JlZklkfWAgOiAnVmFsdWUnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtKFxuICByZXNwb25zZTogRmV0Y2hSZXNwb25zZTxQcm9tRGF0YVN1Y2Nlc3NSZXNwb25zZT4sXG4gIHRyYW5zZm9ybU9wdGlvbnM6IHtcbiAgICBxdWVyeTogUHJvbVF1ZXJ5UmVxdWVzdDtcbiAgICBleGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbnM/OiBFeGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbltdO1xuICAgIHRhcmdldDogUHJvbVF1ZXJ5O1xuICAgIHJlc3BvbnNlTGlzdExlbmd0aDogbnVtYmVyO1xuICAgIHNjb3BlZFZhcnM/OiBTY29wZWRWYXJzO1xuICB9XG4pIHtcbiAgLy8gQ3JlYXRlIG9wdGlvbnMgb2JqZWN0IGZyb20gdHJhbnNmb3JtT3B0aW9uc1xuICBjb25zdCBvcHRpb25zOiBUcmFuc2Zvcm1PcHRpb25zID0ge1xuICAgIGZvcm1hdDogdHJhbnNmb3JtT3B0aW9ucy50YXJnZXQuZm9ybWF0LFxuICAgIHN0ZXA6IHRyYW5zZm9ybU9wdGlvbnMucXVlcnkuc3RlcCxcbiAgICBsZWdlbmRGb3JtYXQ6IHRyYW5zZm9ybU9wdGlvbnMudGFyZ2V0LmxlZ2VuZEZvcm1hdCxcbiAgICBzdGFydDogdHJhbnNmb3JtT3B0aW9ucy5xdWVyeS5zdGFydCxcbiAgICBlbmQ6IHRyYW5zZm9ybU9wdGlvbnMucXVlcnkuZW5kLFxuICAgIHF1ZXJ5OiB0cmFuc2Zvcm1PcHRpb25zLnF1ZXJ5LmV4cHIsXG4gICAgcmVzcG9uc2VMaXN0TGVuZ3RoOiB0cmFuc2Zvcm1PcHRpb25zLnJlc3BvbnNlTGlzdExlbmd0aCxcbiAgICBzY29wZWRWYXJzOiB0cmFuc2Zvcm1PcHRpb25zLnNjb3BlZFZhcnMsXG4gICAgcmVmSWQ6IHRyYW5zZm9ybU9wdGlvbnMudGFyZ2V0LnJlZklkLFxuICAgIHZhbHVlV2l0aFJlZklkOiB0cmFuc2Zvcm1PcHRpb25zLnRhcmdldC52YWx1ZVdpdGhSZWZJZCxcbiAgICBtZXRhOiB7XG4gICAgICAvLyBGaXggZm9yIHNob3dpbmcgb2YgUHJvbWV0aGV1cyByZXN1bHRzIGluIEV4cGxvcmUgdGFibGVcbiAgICAgIHByZWZlcnJlZFZpc3VhbGlzYXRpb25UeXBlOiB0cmFuc2Zvcm1PcHRpb25zLnF1ZXJ5Lmluc3RhbnQgPyAndGFibGUnIDogJ2dyYXBoJyxcbiAgICB9LFxuICB9O1xuICBjb25zdCBwcm9tZXRoZXVzUmVzdWx0ID0gcmVzcG9uc2UuZGF0YS5kYXRhO1xuXG4gIGlmIChpc0V4ZW1wbGFyRGF0YShwcm9tZXRoZXVzUmVzdWx0KSkge1xuICAgIGNvbnN0IGV2ZW50czogVGltZUFuZFZhbHVlW10gPSBbXTtcbiAgICBwcm9tZXRoZXVzUmVzdWx0LmZvckVhY2goKGV4ZW1wbGFyRGF0YSkgPT4ge1xuICAgICAgY29uc3QgZGF0YSA9IGV4ZW1wbGFyRGF0YS5leGVtcGxhcnMubWFwKChleGVtcGxhcikgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIFtUSU1FX1NFUklFU19USU1FX0ZJRUxEX05BTUVdOiBleGVtcGxhci50aW1lc3RhbXAgKiAxMDAwLFxuICAgICAgICAgIFtUSU1FX1NFUklFU19WQUxVRV9GSUVMRF9OQU1FXTogZXhlbXBsYXIudmFsdWUsXG4gICAgICAgICAgLi4uZXhlbXBsYXIubGFiZWxzLFxuICAgICAgICAgIC4uLmV4ZW1wbGFyRGF0YS5zZXJpZXNMYWJlbHMsXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIGV2ZW50cy5wdXNoKC4uLmRhdGEpO1xuICAgIH0pO1xuXG4gICAgLy8gR3JvdXBpbmcgZXhlbXBsYXJzIGJ5IHN0ZXBcbiAgICBjb25zdCBzYW1wbGVkRXhlbXBsYXJzID0gc2FtcGxlRXhlbXBsYXJzKGV2ZW50cywgb3B0aW9ucyk7XG5cbiAgICBjb25zdCBkYXRhRnJhbWUgPSBuZXcgQXJyYXlEYXRhRnJhbWUoc2FtcGxlZEV4ZW1wbGFycyk7XG4gICAgZGF0YUZyYW1lLm1ldGEgPSB7IGRhdGFUb3BpYzogRGF0YVRvcGljLkFubm90YXRpb25zIH07XG5cbiAgICAvLyBBZGQgZGF0YSBsaW5rcyBpZiBjb25maWd1cmVkXG4gICAgaWYgKHRyYW5zZm9ybU9wdGlvbnMuZXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb25zPy5sZW5ndGgpIHtcbiAgICAgIGZvciAoY29uc3QgZXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb24gb2YgdHJhbnNmb3JtT3B0aW9ucy5leGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdHJhY2VJREZpZWxkID0gZGF0YUZyYW1lLmZpZWxkcy5maW5kKChmaWVsZCkgPT4gZmllbGQubmFtZSA9PT0gZXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb24ubmFtZSk7XG4gICAgICAgIGlmICh0cmFjZUlERmllbGQpIHtcbiAgICAgICAgICBjb25zdCBsaW5rcyA9IGdldERhdGFMaW5rcyhleGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbik7XG4gICAgICAgICAgdHJhY2VJREZpZWxkLmNvbmZpZy5saW5rcyA9IHRyYWNlSURGaWVsZC5jb25maWcubGlua3M/Lmxlbmd0aFxuICAgICAgICAgICAgPyBbLi4udHJhY2VJREZpZWxkLmNvbmZpZy5saW5rcywgLi4ubGlua3NdXG4gICAgICAgICAgICA6IGxpbmtzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbZGF0YUZyYW1lXTtcbiAgfVxuXG4gIGlmICghcHJvbWV0aGV1c1Jlc3VsdD8ucmVzdWx0KSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHJlc3VsdCB0eXBlIGlzIHNjYWxhclxuICBpZiAocHJvbWV0aGV1c1Jlc3VsdC5yZXN1bHRUeXBlID09PSAnc2NhbGFyJykge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIG1ldGE6IG9wdGlvbnMubWV0YSxcbiAgICAgICAgcmVmSWQ6IG9wdGlvbnMucmVmSWQsXG4gICAgICAgIGxlbmd0aDogMSxcbiAgICAgICAgZmllbGRzOiBbZ2V0VGltZUZpZWxkKFtwcm9tZXRoZXVzUmVzdWx0LnJlc3VsdF0pLCBnZXRWYWx1ZUZpZWxkKHsgZGF0YTogW3Byb21ldGhldXNSZXN1bHQucmVzdWx0XSB9KV0sXG4gICAgICB9LFxuICAgIF07XG4gIH1cblxuICAvLyBSZXR1cm4gZWFybHkgYWdhaW4gaWYgdGhlIGZvcm1hdCBpcyB0YWJsZSwgdGhpcyBuZWVkcyBzcGVjaWFsIHRyYW5zZm9ybWF0aW9uLlxuICBpZiAob3B0aW9ucy5mb3JtYXQgPT09ICd0YWJsZScpIHtcbiAgICBjb25zdCB0YWJsZURhdGEgPSB0cmFuc2Zvcm1NZXRyaWNEYXRhVG9UYWJsZShwcm9tZXRoZXVzUmVzdWx0LnJlc3VsdCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIFt0YWJsZURhdGFdO1xuICB9XG5cbiAgLy8gUHJvY2VzcyBtYXRyaXggYW5kIHZlY3RvciByZXN1bHRzIHRvIERhdGFGcmFtZVxuICBjb25zdCBkYXRhRnJhbWU6IERhdGFGcmFtZVtdID0gW107XG4gIHByb21ldGhldXNSZXN1bHQucmVzdWx0LmZvckVhY2goKGRhdGE6IE1hdHJpeE9yVmVjdG9yUmVzdWx0KSA9PiBkYXRhRnJhbWUucHVzaCh0cmFuc2Zvcm1Ub0RhdGFGcmFtZShkYXRhLCBvcHRpb25zKSkpO1xuXG4gIC8vIFdoZW4gZm9ybWF0IGlzIGhlYXRtYXAgdXNlIHRoZSBhbHJlYWR5IGNyZWF0ZWQgZGF0YSBmcmFtZXMgYW5kIHRyYW5zZm9ybSBpdCBtb3JlXG4gIGlmIChvcHRpb25zLmZvcm1hdCA9PT0gJ2hlYXRtYXAnKSB7XG4gICAgcmV0dXJuIG1lcmdlSGVhdG1hcEZyYW1lcyh0cmFuc2Zvcm1Ub0hpc3RvZ3JhbU92ZXJUaW1lKGRhdGFGcmFtZS5zb3J0KHNvcnRTZXJpZXNCeUxhYmVsKSkpO1xuICB9XG5cbiAgLy8gUmV0dXJuIG1hdHJpeCBvciB2ZWN0b3IgcmVzdWx0IGFzIERhdGFGcmFtZVtdXG4gIHJldHVybiBkYXRhRnJhbWU7XG59XG5cbmZ1bmN0aW9uIGdldERhdGFMaW5rcyhvcHRpb25zOiBFeGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbik6IERhdGFMaW5rW10ge1xuICBjb25zdCBkYXRhTGlua3M6IERhdGFMaW5rW10gPSBbXTtcblxuICBpZiAob3B0aW9ucy5kYXRhc291cmNlVWlkKSB7XG4gICAgY29uc3QgZGF0YVNvdXJjZVNydiA9IGdldERhdGFTb3VyY2VTcnYoKTtcbiAgICBjb25zdCBkc1NldHRpbmdzID0gZGF0YVNvdXJjZVNydi5nZXRJbnN0YW5jZVNldHRpbmdzKG9wdGlvbnMuZGF0YXNvdXJjZVVpZCk7XG5cbiAgICBkYXRhTGlua3MucHVzaCh7XG4gICAgICB0aXRsZTogb3B0aW9ucy51cmxEaXNwbGF5TGFiZWwgfHwgYFF1ZXJ5IHdpdGggJHtkc1NldHRpbmdzPy5uYW1lfWAsXG4gICAgICB1cmw6ICcnLFxuICAgICAgaW50ZXJuYWw6IHtcbiAgICAgICAgcXVlcnk6IHsgcXVlcnk6ICcke19fdmFsdWUucmF3fScsIHF1ZXJ5VHlwZTogJ3RyYWNlSWQnIH0sXG4gICAgICAgIGRhdGFzb3VyY2VVaWQ6IG9wdGlvbnMuZGF0YXNvdXJjZVVpZCxcbiAgICAgICAgZGF0YXNvdXJjZU5hbWU6IGRzU2V0dGluZ3M/Lm5hbWUgPz8gJ0RhdGEgc291cmNlIG5vdCBmb3VuZCcsXG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMudXJsKSB7XG4gICAgZGF0YUxpbmtzLnB1c2goe1xuICAgICAgdGl0bGU6IG9wdGlvbnMudXJsRGlzcGxheUxhYmVsIHx8IGBHbyB0byAke29wdGlvbnMudXJsfWAsXG4gICAgICB1cmw6IG9wdGlvbnMudXJsLFxuICAgICAgdGFyZ2V0Qmxhbms6IHRydWUsXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGRhdGFMaW5rcztcbn1cblxuLyoqXG4gKiBSZWR1Y2UgdGhlIGRlbnNpdHkgb2YgdGhlIGV4ZW1wbGFycyBieSBtYWtpbmcgc3VyZSB0aGF0IHRoZSBoaWdoZXN0IHZhbHVlIGV4ZW1wbGFyIGlzIGluY2x1ZGVkXG4gKiBhbmQgdGhlbiBvbmx5IHRoZSBvbmVzIHRoYXQgYXJlIDIgdGltZXMgdGhlIHN0YW5kYXJkIGRldmlhdGlvbiBvZiB0aGUgYWxsIHRoZSB2YWx1ZXMuXG4gKiBUaGlzIG1ha2VzIHN1cmUgbm90IHRvIHNob3cgdG9vIG1hbnkgZG90cyBuZWFyIGVhY2ggb3RoZXIuXG4gKi9cbmZ1bmN0aW9uIHNhbXBsZUV4ZW1wbGFycyhldmVudHM6IFRpbWVBbmRWYWx1ZVtdLCBvcHRpb25zOiBUcmFuc2Zvcm1PcHRpb25zKSB7XG4gIGNvbnN0IHN0ZXAgPSBvcHRpb25zLnN0ZXAgfHwgMTU7XG4gIGNvbnN0IGJ1Y2tldGVkRXhlbXBsYXJzOiB7IFt0czogc3RyaW5nXTogVGltZUFuZFZhbHVlW10gfSA9IHt9O1xuICBjb25zdCB2YWx1ZXM6IG51bWJlcltdID0gW107XG4gIGZvciAoY29uc3QgZXhlbXBsYXIgb2YgZXZlbnRzKSB7XG4gICAgLy8gQWxpZ24gZXhlbXBsYXIgdGltZXN0YW1wIHRvIG5lYXJlc3Qgc3RlcCBzZWNvbmRcbiAgICBjb25zdCBhbGlnbmVkVHMgPSBTdHJpbmcoTWF0aC5mbG9vcihleGVtcGxhcltUSU1FX1NFUklFU19USU1FX0ZJRUxEX05BTUVdIC8gMTAwMCAvIHN0ZXApICogc3RlcCAqIDEwMDApO1xuICAgIGlmICghYnVja2V0ZWRFeGVtcGxhcnNbYWxpZ25lZFRzXSkge1xuICAgICAgLy8gTmV3IGJ1Y2tldCBmb3VuZFxuICAgICAgYnVja2V0ZWRFeGVtcGxhcnNbYWxpZ25lZFRzXSA9IFtdO1xuICAgIH1cbiAgICBidWNrZXRlZEV4ZW1wbGFyc1thbGlnbmVkVHNdLnB1c2goZXhlbXBsYXIpO1xuICAgIHZhbHVlcy5wdXNoKGV4ZW1wbGFyW1RJTUVfU0VSSUVTX1ZBTFVFX0ZJRUxEX05BTUVdKTtcbiAgfVxuXG4gIC8vIEdldHRpbmcgZXhlbXBsYXJzIGZyb20gZWFjaCBidWNrZXRcbiAgY29uc3Qgc3RhbmRhcmREZXZpYXRpb24gPSBkZXZpYXRpb24odmFsdWVzKTtcbiAgY29uc3Qgc2FtcGxlZEJ1Y2tldHMgPSBPYmplY3Qua2V5cyhidWNrZXRlZEV4ZW1wbGFycykuc29ydCgpO1xuICBjb25zdCBzYW1wbGVkRXhlbXBsYXJzID0gW107XG4gIGZvciAoY29uc3QgdHMgb2Ygc2FtcGxlZEJ1Y2tldHMpIHtcbiAgICBjb25zdCBleGVtcGxhcnNJbkJ1Y2tldCA9IGJ1Y2tldGVkRXhlbXBsYXJzW3RzXTtcbiAgICBpZiAoZXhlbXBsYXJzSW5CdWNrZXQubGVuZ3RoID09PSAxKSB7XG4gICAgICBzYW1wbGVkRXhlbXBsYXJzLnB1c2goZXhlbXBsYXJzSW5CdWNrZXRbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDaG9vc2Ugd2hpY2ggdmFsdWVzIHRvIHNhbXBsZVxuICAgICAgY29uc3QgYnVja2V0VmFsdWVzID0gZXhlbXBsYXJzSW5CdWNrZXQubWFwKChleCkgPT4gZXhbVElNRV9TRVJJRVNfVkFMVUVfRklFTERfTkFNRV0pLnNvcnQoZGVzY2VuZGluZyk7XG4gICAgICBjb25zdCBzYW1wbGVkQnVja2V0VmFsdWVzID0gYnVja2V0VmFsdWVzLnJlZHVjZSgoYWNjOiBudW1iZXJbXSwgY3VycikgPT4ge1xuICAgICAgICBpZiAoYWNjLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIC8vIEZpcnN0IHZhbHVlIGlzIG1heCBhbmQgaXMgYWx3YXlzIGFkZGVkXG4gICAgICAgICAgYWNjLnB1c2goY3Vycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhlbiB0YWtlIHZhbHVlcyBvbmx5IHdoZW4gYXQgbGVhc3QgMiBzdGFuZGFyZCBkZXZpYXRpb24gZGlzdGFuY2UgdG8gcHJldmlvdXNseSB0YWtlbiB2YWx1ZVxuICAgICAgICAgIGNvbnN0IHByZXYgPSBhY2NbYWNjLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGlmIChzdGFuZGFyZERldmlhdGlvbiAmJiBwcmV2IC0gY3VyciA+PSAyICogc3RhbmRhcmREZXZpYXRpb24pIHtcbiAgICAgICAgICAgIGFjYy5wdXNoKGN1cnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSwgW10pO1xuICAgICAgLy8gRmluZCB0aGUgZXhlbXBsYXJzIGZvciB0aGUgc2FtcGxlZCB2YWx1ZXNcbiAgICAgIHNhbXBsZWRFeGVtcGxhcnMucHVzaChcbiAgICAgICAgLi4uc2FtcGxlZEJ1Y2tldFZhbHVlcy5tYXAoXG4gICAgICAgICAgKHZhbHVlKSA9PiBleGVtcGxhcnNJbkJ1Y2tldC5maW5kKChleCkgPT4gZXhbVElNRV9TRVJJRVNfVkFMVUVfRklFTERfTkFNRV0gPT09IHZhbHVlKSFcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNhbXBsZWRFeGVtcGxhcnM7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyBtYXRyaXggYW5kIHZlY3RvciByZXN1bHQgZnJvbSBQcm9tZXRoZXVzIHJlc3VsdCB0byBEYXRhRnJhbWVcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtVG9EYXRhRnJhbWUoZGF0YTogTWF0cml4T3JWZWN0b3JSZXN1bHQsIG9wdGlvbnM6IFRyYW5zZm9ybU9wdGlvbnMpOiBEYXRhRnJhbWUge1xuICBjb25zdCB7IG5hbWUsIGxhYmVscyB9ID0gY3JlYXRlTGFiZWxJbmZvKGRhdGEubWV0cmljLCBvcHRpb25zKTtcblxuICBjb25zdCBmaWVsZHM6IEZpZWxkW10gPSBbXTtcblxuICBpZiAoaXNNYXRyaXhEYXRhKGRhdGEpKSB7XG4gICAgY29uc3Qgc3RlcE1zID0gb3B0aW9ucy5zdGVwID8gb3B0aW9ucy5zdGVwICogMTAwMCA6IE5hTjtcbiAgICBsZXQgYmFzZVRpbWVzdGFtcCA9IG9wdGlvbnMuc3RhcnQgKiAxMDAwO1xuICAgIGNvbnN0IGRwczogUHJvbVZhbHVlW10gPSBbXTtcblxuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgZGF0YS52YWx1ZXMpIHtcbiAgICAgIGxldCBkcFZhbHVlOiBudW1iZXIgfCBudWxsID0gcGFyc2VTYW1wbGVWYWx1ZSh2YWx1ZVsxXSk7XG5cbiAgICAgIGlmIChpc05hTihkcFZhbHVlKSkge1xuICAgICAgICBkcFZhbHVlID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGltZXN0YW1wID0gdmFsdWVbMF0gKiAxMDAwO1xuICAgICAgZm9yIChsZXQgdCA9IGJhc2VUaW1lc3RhbXA7IHQgPCB0aW1lc3RhbXA7IHQgKz0gc3RlcE1zKSB7XG4gICAgICAgIGRwcy5wdXNoKFt0LCBudWxsXSk7XG4gICAgICB9XG4gICAgICBiYXNlVGltZXN0YW1wID0gdGltZXN0YW1wICsgc3RlcE1zO1xuICAgICAgZHBzLnB1c2goW3RpbWVzdGFtcCwgZHBWYWx1ZV0pO1xuICAgIH1cblxuICAgIGNvbnN0IGVuZFRpbWVzdGFtcCA9IG9wdGlvbnMuZW5kICogMTAwMDtcbiAgICBmb3IgKGxldCB0ID0gYmFzZVRpbWVzdGFtcDsgdCA8PSBlbmRUaW1lc3RhbXA7IHQgKz0gc3RlcE1zKSB7XG4gICAgICBkcHMucHVzaChbdCwgbnVsbF0pO1xuICAgIH1cbiAgICBmaWVsZHMucHVzaChnZXRUaW1lRmllbGQoZHBzLCB0cnVlKSk7XG4gICAgZmllbGRzLnB1c2goZ2V0VmFsdWVGaWVsZCh7IGRhdGE6IGRwcywgcGFyc2VWYWx1ZTogZmFsc2UsIGxhYmVscywgZGlzcGxheU5hbWVGcm9tRFM6IG5hbWUgfSkpO1xuICB9IGVsc2Uge1xuICAgIGZpZWxkcy5wdXNoKGdldFRpbWVGaWVsZChbZGF0YS52YWx1ZV0pKTtcbiAgICBmaWVsZHMucHVzaChnZXRWYWx1ZUZpZWxkKHsgZGF0YTogW2RhdGEudmFsdWVdLCBsYWJlbHMsIGRpc3BsYXlOYW1lRnJvbURTOiBuYW1lIH0pKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWV0YTogb3B0aW9ucy5tZXRhLFxuICAgIHJlZklkOiBvcHRpb25zLnJlZklkLFxuICAgIGxlbmd0aDogZmllbGRzWzBdLnZhbHVlcy5sZW5ndGgsXG4gICAgZmllbGRzLFxuICAgIG5hbWUsXG4gIH07XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1ldHJpY0RhdGFUb1RhYmxlKG1kOiBNYXRyaXhPclZlY3RvclJlc3VsdFtdLCBvcHRpb25zOiBUcmFuc2Zvcm1PcHRpb25zKTogRGF0YUZyYW1lIHtcbiAgaWYgKCFtZCB8fCBtZC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWV0YTogb3B0aW9ucy5tZXRhLFxuICAgICAgcmVmSWQ6IG9wdGlvbnMucmVmSWQsXG4gICAgICBsZW5ndGg6IDAsXG4gICAgICBmaWVsZHM6IFtdLFxuICAgIH07XG4gIH1cblxuICBjb25zdCB2YWx1ZVRleHQgPSBvcHRpb25zLnJlc3BvbnNlTGlzdExlbmd0aCA+IDEgfHwgb3B0aW9ucy52YWx1ZVdpdGhSZWZJZCA/IGBWYWx1ZSAjJHtvcHRpb25zLnJlZklkfWAgOiAnVmFsdWUnO1xuXG4gIGNvbnN0IHRpbWVGaWVsZCA9IGdldFRpbWVGaWVsZChbXSk7XG4gIGNvbnN0IG1ldHJpY0ZpZWxkcyA9IE9iamVjdC5rZXlzKG1kLnJlZHVjZSgoYWNjLCBzZXJpZXMpID0+ICh7IC4uLmFjYywgLi4uc2VyaWVzLm1ldHJpYyB9KSwge30pKVxuICAgIC5zb3J0KClcbiAgICAubWFwKChsYWJlbCkgPT4ge1xuICAgICAgLy8gTGFiZWxzIGhhdmUgc3RyaW5nIGZpZWxkIHR5cGUsIG90aGVyd2lzZSB0YWJsZSB0cmllcyB0byBmaWd1cmUgb3V0IHRoZSB0eXBlIHdoaWNoIGNhbiByZXN1bHQgaW4gdW5leHBlY3RlZCByZXN1bHRzXG4gICAgICAvLyBPbmx5IFwibGVcIiBsYWJlbCBoYXMgYSBudW1iZXIgZmllbGQgdHlwZVxuICAgICAgY29uc3QgbnVtYmVyRmllbGQgPSBsYWJlbCA9PT0gJ2xlJztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IGxhYmVsLFxuICAgICAgICBjb25maWc6IHsgZmlsdGVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICB0eXBlOiBudW1iZXJGaWVsZCA/IEZpZWxkVHlwZS5udW1iZXIgOiBGaWVsZFR5cGUuc3RyaW5nLFxuICAgICAgICB2YWx1ZXM6IG5ldyBBcnJheVZlY3RvcigpLFxuICAgICAgfTtcbiAgICB9KTtcbiAgY29uc3QgdmFsdWVGaWVsZCA9IGdldFZhbHVlRmllbGQoeyBkYXRhOiBbXSwgdmFsdWVOYW1lOiB2YWx1ZVRleHQgfSk7XG5cbiAgbWQuZm9yRWFjaCgoZCkgPT4ge1xuICAgIGlmIChpc01hdHJpeERhdGEoZCkpIHtcbiAgICAgIGQudmFsdWVzLmZvckVhY2goKHZhbCkgPT4ge1xuICAgICAgICB0aW1lRmllbGQudmFsdWVzLmFkZCh2YWxbMF0gKiAxMDAwKTtcbiAgICAgICAgbWV0cmljRmllbGRzLmZvckVhY2goKG1ldHJpY0ZpZWxkKSA9PiBtZXRyaWNGaWVsZC52YWx1ZXMuYWRkKGdldExhYmVsVmFsdWUoZC5tZXRyaWMsIG1ldHJpY0ZpZWxkLm5hbWUpKSk7XG4gICAgICAgIHZhbHVlRmllbGQudmFsdWVzLmFkZChwYXJzZVNhbXBsZVZhbHVlKHZhbFsxXSkpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVGaWVsZC52YWx1ZXMuYWRkKGQudmFsdWVbMF0gKiAxMDAwKTtcbiAgICAgIG1ldHJpY0ZpZWxkcy5mb3JFYWNoKChtZXRyaWNGaWVsZCkgPT4gbWV0cmljRmllbGQudmFsdWVzLmFkZChnZXRMYWJlbFZhbHVlKGQubWV0cmljLCBtZXRyaWNGaWVsZC5uYW1lKSkpO1xuICAgICAgdmFsdWVGaWVsZC52YWx1ZXMuYWRkKHBhcnNlU2FtcGxlVmFsdWUoZC52YWx1ZVsxXSkpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBtZXRhOiBvcHRpb25zLm1ldGEsXG4gICAgcmVmSWQ6IG9wdGlvbnMucmVmSWQsXG4gICAgbGVuZ3RoOiB0aW1lRmllbGQudmFsdWVzLmxlbmd0aCxcbiAgICBmaWVsZHM6IFt0aW1lRmllbGQsIC4uLm1ldHJpY0ZpZWxkcywgdmFsdWVGaWVsZF0sXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldExhYmVsVmFsdWUobWV0cmljOiBQcm9tTWV0cmljLCBsYWJlbDogc3RyaW5nKTogc3RyaW5nIHwgbnVtYmVyIHtcbiAgaWYgKG1ldHJpYy5oYXNPd25Qcm9wZXJ0eShsYWJlbCkpIHtcbiAgICBpZiAobGFiZWwgPT09ICdsZScpIHtcbiAgICAgIHJldHVybiBwYXJzZVNhbXBsZVZhbHVlKG1ldHJpY1tsYWJlbF0pO1xuICAgIH1cbiAgICByZXR1cm4gbWV0cmljW2xhYmVsXTtcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGdldFRpbWVGaWVsZChkYXRhOiBQcm9tVmFsdWVbXSwgaXNNcyA9IGZhbHNlKTogTXV0YWJsZUZpZWxkIHtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBUSU1FX1NFUklFU19USU1FX0ZJRUxEX05BTUUsXG4gICAgdHlwZTogRmllbGRUeXBlLnRpbWUsXG4gICAgY29uZmlnOiB7fSxcbiAgICB2YWx1ZXM6IG5ldyBBcnJheVZlY3RvcjxudW1iZXI+KGRhdGEubWFwKCh2YWwpID0+IChpc01zID8gdmFsWzBdIDogdmFsWzBdICogMTAwMCkpKSxcbiAgfTtcbn1cbnR5cGUgVmFsdWVGaWVsZE9wdGlvbnMgPSB7XG4gIGRhdGE6IFByb21WYWx1ZVtdO1xuICB2YWx1ZU5hbWU/OiBzdHJpbmc7XG4gIHBhcnNlVmFsdWU/OiBib29sZWFuO1xuICBsYWJlbHM/OiBMYWJlbHM7XG4gIGRpc3BsYXlOYW1lRnJvbURTPzogc3RyaW5nO1xufTtcblxuZnVuY3Rpb24gZ2V0VmFsdWVGaWVsZCh7XG4gIGRhdGEsXG4gIHZhbHVlTmFtZSA9IFRJTUVfU0VSSUVTX1ZBTFVFX0ZJRUxEX05BTUUsXG4gIHBhcnNlVmFsdWUgPSB0cnVlLFxuICBsYWJlbHMsXG4gIGRpc3BsYXlOYW1lRnJvbURTLFxufTogVmFsdWVGaWVsZE9wdGlvbnMpOiBNdXRhYmxlRmllbGQge1xuICByZXR1cm4ge1xuICAgIG5hbWU6IHZhbHVlTmFtZSxcbiAgICB0eXBlOiBGaWVsZFR5cGUubnVtYmVyLFxuICAgIGRpc3BsYXk6IGdldERpc3BsYXlQcm9jZXNzb3IoKSxcbiAgICBjb25maWc6IHtcbiAgICAgIGRpc3BsYXlOYW1lRnJvbURTLFxuICAgIH0sXG4gICAgbGFiZWxzLFxuICAgIHZhbHVlczogbmV3IEFycmF5VmVjdG9yPG51bWJlciB8IG51bGw+KGRhdGEubWFwKCh2YWwpID0+IChwYXJzZVZhbHVlID8gcGFyc2VTYW1wbGVWYWx1ZSh2YWxbMV0pIDogdmFsWzFdKSkpLFxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMYWJlbEluZm8obGFiZWxzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9LCBvcHRpb25zOiBUcmFuc2Zvcm1PcHRpb25zKSB7XG4gIGlmIChvcHRpb25zPy5sZWdlbmRGb3JtYXQpIHtcbiAgICBjb25zdCB0aXRsZSA9IHJlbmRlckxlZ2VuZEZvcm1hdChnZXRUZW1wbGF0ZVNydigpLnJlcGxhY2Uob3B0aW9ucy5sZWdlbmRGb3JtYXQsIG9wdGlvbnM/LnNjb3BlZFZhcnMpLCBsYWJlbHMpO1xuICAgIHJldHVybiB7IG5hbWU6IHRpdGxlLCBsYWJlbHMgfTtcbiAgfVxuXG4gIGNvbnN0IHsgX19uYW1lX18sIC4uLmxhYmVsc1dpdGhvdXROYW1lIH0gPSBsYWJlbHM7XG4gIGNvbnN0IGxhYmVsUGFydCA9IGZvcm1hdExhYmVscyhsYWJlbHNXaXRob3V0TmFtZSk7XG4gIGxldCB0aXRsZSA9IGAke19fbmFtZV9fID8/ICcnfSR7bGFiZWxQYXJ0fWA7XG5cbiAgaWYgKCF0aXRsZSkge1xuICAgIHRpdGxlID0gb3B0aW9ucy5xdWVyeTtcbiAgfVxuXG4gIHJldHVybiB7IG5hbWU6IHRpdGxlLCBsYWJlbHM6IGxhYmVsc1dpdGhvdXROYW1lIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRPcmlnaW5hbE1ldHJpY05hbWUobGFiZWxEYXRhOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9KSB7XG4gIGNvbnN0IG1ldHJpY05hbWUgPSBsYWJlbERhdGEuX19uYW1lX18gfHwgJyc7XG4gIGRlbGV0ZSBsYWJlbERhdGEuX19uYW1lX187XG4gIGNvbnN0IGxhYmVsUGFydCA9IE9iamVjdC5lbnRyaWVzKGxhYmVsRGF0YSlcbiAgICAubWFwKChsYWJlbCkgPT4gYCR7bGFiZWxbMF19PVwiJHtsYWJlbFsxXX1cImApXG4gICAgLmpvaW4oJywnKTtcbiAgcmV0dXJuIGAke21ldHJpY05hbWV9eyR7bGFiZWxQYXJ0fX1gO1xufVxuXG5mdW5jdGlvbiBtZXJnZUhlYXRtYXBGcmFtZXMoZnJhbWVzOiBEYXRhRnJhbWVbXSk6IERhdGFGcmFtZVtdIHtcbiAgaWYgKGZyYW1lcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCB0aW1lRmllbGQgPSBmcmFtZXNbMF0uZmllbGRzLmZpbmQoKGZpZWxkKSA9PiBmaWVsZC50eXBlID09PSBGaWVsZFR5cGUudGltZSkhO1xuICBjb25zdCBjb3VudEZpZWxkcyA9IGZyYW1lcy5tYXAoKGZyYW1lKSA9PiB7XG4gICAgbGV0IGZpZWxkID0gZnJhbWUuZmllbGRzLmZpbmQoKGZpZWxkKSA9PiBmaWVsZC50eXBlID09PSBGaWVsZFR5cGUubnVtYmVyKSE7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uZmllbGQsXG4gICAgICBuYW1lOiBmaWVsZC5jb25maWcuZGlzcGxheU5hbWVGcm9tRFMhLFxuICAgIH07XG4gIH0pO1xuXG4gIHJldHVybiBbXG4gICAge1xuICAgICAgLi4uZnJhbWVzWzBdLFxuICAgICAgbWV0YToge1xuICAgICAgICAuLi5mcmFtZXNbMF0ubWV0YSxcbiAgICAgICAgdHlwZTogRGF0YUZyYW1lVHlwZS5IZWF0bWFwQnVja2V0cyxcbiAgICAgIH0sXG4gICAgICBmaWVsZHM6IFt0aW1lRmllbGQhLCAuLi5jb3VudEZpZWxkc10sXG4gICAgfSxcbiAgXTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtVG9IaXN0b2dyYW1PdmVyVGltZShzZXJpZXNMaXN0OiBEYXRhRnJhbWVbXSkge1xuICAvKiAgICAgIHQxID0gdGltZXN0YW1wMSwgdDIgPSB0aW1lc3RhbXAyIGV0Yy5cbiAgICAgICAgICAgIHQxICB0MiAgdDMgICAgICAgICAgdDEgIHQyICB0M1xuICAgIGxlMTAgICAgMTAgIDEwICAwICAgICA9PiAgICAxMCAgMTAgIDBcbiAgICBsZTIwICAgIDIwICAxMCAgMzAgICAgPT4gICAgMTAgIDAgICAzMFxuICAgIGxlMzAgICAgMzAgIDEwICAzNSAgICA9PiAgICAxMCAgMCAgIDVcbiAgICAqL1xuICBmb3IgKGxldCBpID0gc2VyaWVzTGlzdC5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XG4gICAgY29uc3QgdG9wU2VyaWVzID0gc2VyaWVzTGlzdFtpXS5maWVsZHMuZmluZCgocykgPT4gcy5uYW1lID09PSBUSU1FX1NFUklFU19WQUxVRV9GSUVMRF9OQU1FKTtcbiAgICBjb25zdCBib3R0b21TZXJpZXMgPSBzZXJpZXNMaXN0W2kgLSAxXS5maWVsZHMuZmluZCgocykgPT4gcy5uYW1lID09PSBUSU1FX1NFUklFU19WQUxVRV9GSUVMRF9OQU1FKTtcbiAgICBpZiAoIXRvcFNlcmllcyB8fCAhYm90dG9tU2VyaWVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb21ldGhldXMgaGVhdG1hcCB0cmFuc2Zvcm0gZXJyb3I6IGRhdGEgc2hvdWxkIGJlIGEgdGltZSBzZXJpZXMnKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRvcFNlcmllcy52YWx1ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGNvbnN0IGJvdHRvbVBvaW50ID0gYm90dG9tU2VyaWVzLnZhbHVlcy5nZXQoaikgfHwgWzBdO1xuICAgICAgdG9wU2VyaWVzLnZhbHVlcy50b0FycmF5KClbal0gLT0gYm90dG9tUG9pbnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNlcmllc0xpc3Q7XG59XG5cbmZ1bmN0aW9uIHNvcnRTZXJpZXNCeUxhYmVsKHMxOiBEYXRhRnJhbWUsIHMyOiBEYXRhRnJhbWUpOiBudW1iZXIge1xuICBsZXQgbGUxLCBsZTI7XG5cbiAgdHJ5IHtcbiAgICAvLyBmYWlsIGlmIG5vdCBpbnRlZ2VyLiBtaWdodCBoYXBwZW4gd2l0aCBiYWQgcXVlcmllc1xuICAgIGxlMSA9IHBhcnNlU2FtcGxlVmFsdWUoczEubmFtZSA/PyAnJyk7XG4gICAgbGUyID0gcGFyc2VTYW1wbGVWYWx1ZShzMi5uYW1lID8/ICcnKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKGxlMSA+IGxlMikge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgaWYgKGxlMSA8IGxlMikge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VTYW1wbGVWYWx1ZSh2YWx1ZTogc3RyaW5nKTogbnVtYmVyIHtcbiAgaWYgKElORklOSVRZX1NBTVBMRV9SRUdFWC50ZXN0KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZVswXSA9PT0gJy0nID8gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICB9XG4gIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcbn1cbiIsImltcG9ydCB7IERhdGFRdWVyeSwgRGF0YVNvdXJjZUpzb25EYXRhLCBRdWVyeVJlc3VsdE1ldGEsIFNjb3BlZFZhcnMgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcblxuaW1wb3J0IHsgUXVlcnlFZGl0b3JNb2RlIH0gZnJvbSAnLi9xdWVyeWJ1aWxkZXIvc2hhcmVkL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBQcm9tUXVlcnkgZXh0ZW5kcyBEYXRhUXVlcnkge1xuICBleHByOiBzdHJpbmc7XG4gIGZvcm1hdD86IHN0cmluZztcbiAgaW5zdGFudD86IGJvb2xlYW47XG4gIHJhbmdlPzogYm9vbGVhbjtcbiAgZXhlbXBsYXI/OiBib29sZWFuO1xuICBoaW50aW5nPzogYm9vbGVhbjtcbiAgaW50ZXJ2YWw/OiBzdHJpbmc7XG4gIGludGVydmFsRmFjdG9yPzogbnVtYmVyO1xuICAvLyBUaW1lem9uZSBvZmZzZXQgdG8gYWxpZ24gc3RhcnQgJiBlbmQgdGltZSBvbiBiYWNrZW5kXG4gIHV0Y09mZnNldFNlYz86IG51bWJlcjtcbiAgbGVnZW5kRm9ybWF0Pzogc3RyaW5nO1xuICB2YWx1ZVdpdGhSZWZJZD86IGJvb2xlYW47XG4gIHJlcXVlc3RJZD86IHN0cmluZztcbiAgc2hvd2luZ0dyYXBoPzogYm9vbGVhbjtcbiAgc2hvd2luZ1RhYmxlPzogYm9vbGVhbjtcbiAgLyoqIENvZGUsIEJ1aWxkZXIgb3IgRXhwbGFpbiAqL1xuICBlZGl0b3JNb2RlPzogUXVlcnlFZGl0b3JNb2RlO1xuICAvKiogQ29udHJvbHMgaWYgdGhlIHJhdyBxdWVyeSB0ZXh0IGlzIHNob3duICovXG4gIHJhd1F1ZXJ5PzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9tT3B0aW9ucyBleHRlbmRzIERhdGFTb3VyY2VKc29uRGF0YSB7XG4gIHRpbWVJbnRlcnZhbD86IHN0cmluZztcbiAgcXVlcnlUaW1lb3V0Pzogc3RyaW5nO1xuICBodHRwTWV0aG9kPzogc3RyaW5nO1xuICBkaXJlY3RVcmw/OiBzdHJpbmc7XG4gIGN1c3RvbVF1ZXJ5UGFyYW1ldGVycz86IHN0cmluZztcbiAgZGlzYWJsZU1ldHJpY3NMb29rdXA/OiBib29sZWFuO1xuICBleGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbnM/OiBFeGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbltdO1xufVxuXG5leHBvcnQgZW51bSBQcm9tUXVlcnlUeXBlIHtcbiAgdGltZVNlcmllc1F1ZXJ5ID0gJ3RpbWVTZXJpZXNRdWVyeScsXG59XG5cbmV4cG9ydCB0eXBlIEV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uID0ge1xuICBuYW1lOiBzdHJpbmc7XG4gIHVybD86IHN0cmluZztcbiAgdXJsRGlzcGxheUxhYmVsPzogc3RyaW5nO1xuICBkYXRhc291cmNlVWlkPzogc3RyaW5nO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBQcm9tUXVlcnlSZXF1ZXN0IGV4dGVuZHMgUHJvbVF1ZXJ5IHtcbiAgc3RlcD86IG51bWJlcjtcbiAgcmVxdWVzdElkPzogc3RyaW5nO1xuICBzdGFydDogbnVtYmVyO1xuICBlbmQ6IG51bWJlcjtcbiAgaGVhZGVycz86IGFueTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9tTWV0cmljc01ldGFkYXRhSXRlbSB7XG4gIHR5cGU6IHN0cmluZztcbiAgaGVscDogc3RyaW5nO1xuICB1bml0Pzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb21NZXRyaWNzTWV0YWRhdGEge1xuICBbbWV0cmljOiBzdHJpbmddOiBQcm9tTWV0cmljc01ldGFkYXRhSXRlbTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9tRGF0YVN1Y2Nlc3NSZXNwb25zZTxUID0gUHJvbURhdGE+IHtcbiAgc3RhdHVzOiAnc3VjY2Vzcyc7XG4gIGRhdGE6IFQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvbURhdGFFcnJvclJlc3BvbnNlPFQgPSBQcm9tRGF0YT4ge1xuICBzdGF0dXM6ICdlcnJvcic7XG4gIGVycm9yVHlwZTogc3RyaW5nO1xuICBlcnJvcjogc3RyaW5nO1xuICBkYXRhOiBUO1xufVxuXG5leHBvcnQgdHlwZSBQcm9tRGF0YSA9IFByb21NYXRyaXhEYXRhIHwgUHJvbVZlY3RvckRhdGEgfCBQcm9tU2NhbGFyRGF0YSB8IFByb21FeGVtcGxhckRhdGFbXTtcblxuZXhwb3J0IGludGVyZmFjZSBMYWJlbHMge1xuICBbaW5kZXg6IHN0cmluZ106IGFueTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFeGVtcGxhciB7XG4gIGxhYmVsczogTGFiZWxzO1xuICB2YWx1ZTogbnVtYmVyO1xuICB0aW1lc3RhbXA6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9tRXhlbXBsYXJEYXRhIHtcbiAgc2VyaWVzTGFiZWxzOiBQcm9tTWV0cmljO1xuICBleGVtcGxhcnM6IEV4ZW1wbGFyW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvbVZlY3RvckRhdGEge1xuICByZXN1bHRUeXBlOiAndmVjdG9yJztcbiAgcmVzdWx0OiBBcnJheTx7XG4gICAgbWV0cmljOiBQcm9tTWV0cmljO1xuICAgIHZhbHVlOiBQcm9tVmFsdWU7XG4gIH0+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb21NYXRyaXhEYXRhIHtcbiAgcmVzdWx0VHlwZTogJ21hdHJpeCc7XG4gIHJlc3VsdDogQXJyYXk8e1xuICAgIG1ldHJpYzogUHJvbU1ldHJpYztcbiAgICB2YWx1ZXM6IFByb21WYWx1ZVtdO1xuICB9Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9tU2NhbGFyRGF0YSB7XG4gIHJlc3VsdFR5cGU6ICdzY2FsYXInO1xuICByZXN1bHQ6IFByb21WYWx1ZTtcbn1cblxuZXhwb3J0IHR5cGUgUHJvbVZhbHVlID0gW251bWJlciwgYW55XTtcblxuZXhwb3J0IGludGVyZmFjZSBQcm9tTWV0cmljIHtcbiAgX19uYW1lX18/OiBzdHJpbmc7XG4gIFtpbmRleDogc3RyaW5nXTogYW55O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNNYXRyaXhEYXRhKHJlc3VsdDogTWF0cml4T3JWZWN0b3JSZXN1bHQpOiByZXN1bHQgaXMgUHJvbU1hdHJpeERhdGFbJ3Jlc3VsdCddWzBdIHtcbiAgcmV0dXJuICd2YWx1ZXMnIGluIHJlc3VsdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRXhlbXBsYXJEYXRhKHJlc3VsdDogUHJvbURhdGEpOiByZXN1bHQgaXMgUHJvbUV4ZW1wbGFyRGF0YVtdIHtcbiAgaWYgKHJlc3VsdCA9PSBudWxsIHx8ICFBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPyAnZXhlbXBsYXJzJyBpbiByZXN1bHRbMF0gOiBmYWxzZTtcbn1cblxuZXhwb3J0IHR5cGUgTWF0cml4T3JWZWN0b3JSZXN1bHQgPSBQcm9tTWF0cml4RGF0YVsncmVzdWx0J11bMF0gfCBQcm9tVmVjdG9yRGF0YVsncmVzdWx0J11bMF07XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNmb3JtT3B0aW9ucyB7XG4gIGZvcm1hdD86IHN0cmluZztcbiAgc3RlcD86IG51bWJlcjtcbiAgbGVnZW5kRm9ybWF0Pzogc3RyaW5nO1xuICBzdGFydDogbnVtYmVyO1xuICBlbmQ6IG51bWJlcjtcbiAgcXVlcnk6IHN0cmluZztcbiAgcmVzcG9uc2VMaXN0TGVuZ3RoOiBudW1iZXI7XG4gIHNjb3BlZFZhcnM/OiBTY29wZWRWYXJzO1xuICByZWZJZDogc3RyaW5nO1xuICB2YWx1ZVdpdGhSZWZJZD86IGJvb2xlYW47XG4gIG1ldGE6IFF1ZXJ5UmVzdWx0TWV0YTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9tTGFiZWxRdWVyeVJlc3BvbnNlIHtcbiAgZGF0YToge1xuICAgIHN0YXR1czogc3RyaW5nO1xuICAgIGRhdGE6IHN0cmluZ1tdO1xuICB9O1xuICBjYW5jZWxsZWQ/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIEF1dG8gPSBxdWVyeS5sZWdlbmRGb3JtYXQgPT0gJ19fYXV0bydcbiAqIFZlcmJvc2UgPSBxdWVyeS5sZWdlbmRGb3JtYXQgPT0gbnVsbC91bmRlZmluZWQvJydcbiAqIEN1c3RvbSBxdWVyeS5sZWdlbmRGb3JtYXQubGVuZ3RoID4gMCAmJiBxdWVyeS5sZWdlbmRGb3JtYXQgIT09ICdfX2F1dG8nXG4gKi9cbmV4cG9ydCBlbnVtIExlZ2VuZEZvcm1hdE1vZGUge1xuICBBdXRvID0gJ19fYXV0bycsXG4gIFZlcmJvc2UgPSAnX192ZXJib3NlJyxcbiAgQ3VzdG9tID0gJ19fY3VzdG9tJyxcbn1cbiIsImltcG9ydCB7IGZyb20sIE9ic2VydmFibGUsIG9mIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7XG4gIERhdGFRdWVyeVJlcXVlc3QsXG4gIERhdGFRdWVyeVJlc3BvbnNlLFxuICByYW5nZVV0aWwsXG4gIFN0YW5kYXJkVmFyaWFibGVRdWVyeSxcbiAgU3RhbmRhcmRWYXJpYWJsZVN1cHBvcnQsXG59IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgZ2V0VGVtcGxhdGVTcnYsIFRlbXBsYXRlU3J2IH0gZnJvbSAnQGdyYWZhbmEvcnVudGltZSc7XG5cbmltcG9ydCB7IGdldFRpbWVTcnYsIFRpbWVTcnYgfSBmcm9tICcuLi8uLi8uLi9mZWF0dXJlcy9kYXNoYm9hcmQvc2VydmljZXMvVGltZVNydic7XG5cbmltcG9ydCB7IFByb21ldGhldXNEYXRhc291cmNlIH0gZnJvbSAnLi9kYXRhc291cmNlJztcbmltcG9ydCBQcm9tZXRoZXVzTWV0cmljRmluZFF1ZXJ5IGZyb20gJy4vbWV0cmljX2ZpbmRfcXVlcnknO1xuaW1wb3J0IHsgUHJvbVF1ZXJ5IH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBQcm9tZXRoZXVzVmFyaWFibGVTdXBwb3J0IGV4dGVuZHMgU3RhbmRhcmRWYXJpYWJsZVN1cHBvcnQ8UHJvbWV0aGV1c0RhdGFzb3VyY2U+IHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBkYXRhc291cmNlOiBQcm9tZXRoZXVzRGF0YXNvdXJjZSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHRlbXBsYXRlU3J2OiBUZW1wbGF0ZVNydiA9IGdldFRlbXBsYXRlU3J2KCksXG4gICAgcHJpdmF0ZSByZWFkb25seSB0aW1lU3J2OiBUaW1lU3J2ID0gZ2V0VGltZVNydigpXG4gICkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5xdWVyeSA9IHRoaXMucXVlcnkuYmluZCh0aGlzKTtcbiAgfVxuXG4gIHF1ZXJ5KHJlcXVlc3Q6IERhdGFRdWVyeVJlcXVlc3Q8UHJvbVF1ZXJ5Pik6IE9ic2VydmFibGU8RGF0YVF1ZXJ5UmVzcG9uc2U+IHtcbiAgICBjb25zdCBxdWVyeSA9IHJlcXVlc3QudGFyZ2V0c1swXS5leHByO1xuICAgIGlmICghcXVlcnkpIHtcbiAgICAgIHJldHVybiBvZih7IGRhdGE6IFtdIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHNjb3BlZFZhcnMgPSB7XG4gICAgICAuLi5yZXF1ZXN0LnNjb3BlZFZhcnMsXG4gICAgICBfX2ludGVydmFsOiB7IHRleHQ6IHRoaXMuZGF0YXNvdXJjZS5pbnRlcnZhbCwgdmFsdWU6IHRoaXMuZGF0YXNvdXJjZS5pbnRlcnZhbCB9LFxuICAgICAgX19pbnRlcnZhbF9tczoge1xuICAgICAgICB0ZXh0OiByYW5nZVV0aWwuaW50ZXJ2YWxUb01zKHRoaXMuZGF0YXNvdXJjZS5pbnRlcnZhbCksXG4gICAgICAgIHZhbHVlOiByYW5nZVV0aWwuaW50ZXJ2YWxUb01zKHRoaXMuZGF0YXNvdXJjZS5pbnRlcnZhbCksXG4gICAgICB9LFxuICAgICAgLi4udGhpcy5kYXRhc291cmNlLmdldFJhbmdlU2NvcGVkVmFycyh0aGlzLnRpbWVTcnYudGltZVJhbmdlKCkpLFxuICAgIH07XG5cbiAgICBjb25zdCBpbnRlcnBvbGF0ZWQgPSB0aGlzLnRlbXBsYXRlU3J2LnJlcGxhY2UocXVlcnksIHNjb3BlZFZhcnMsIHRoaXMuZGF0YXNvdXJjZS5pbnRlcnBvbGF0ZVF1ZXJ5RXhwcik7XG4gICAgY29uc3QgbWV0cmljRmluZFF1ZXJ5ID0gbmV3IFByb21ldGhldXNNZXRyaWNGaW5kUXVlcnkodGhpcy5kYXRhc291cmNlLCBpbnRlcnBvbGF0ZWQpO1xuICAgIGNvbnN0IG1ldHJpY0ZpbmRTdHJlYW0gPSBmcm9tKG1ldHJpY0ZpbmRRdWVyeS5wcm9jZXNzKCkpO1xuXG4gICAgcmV0dXJuIG1ldHJpY0ZpbmRTdHJlYW0ucGlwZShtYXAoKHJlc3VsdHMpID0+ICh7IGRhdGE6IHJlc3VsdHMgfSkpKTtcbiAgfVxuXG4gIHRvRGF0YVF1ZXJ5KHF1ZXJ5OiBTdGFuZGFyZFZhcmlhYmxlUXVlcnkpOiBQcm9tUXVlcnkge1xuICAgIHJldHVybiB7XG4gICAgICByZWZJZDogJ1Byb21ldGhldXNEYXRhc291cmNlLVZhcmlhYmxlUXVlcnknLFxuICAgICAgZXhwcjogcXVlcnkucXVlcnksXG4gICAgfTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VQcmV2aW91cyhzdGF0ZSkge1xuICAgIHZhciByZWYgPSB1c2VSZWYoKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICByZWYuY3VycmVudCA9IHN0YXRlO1xuICAgIH0pO1xuICAgIHJldHVybiByZWYuY3VycmVudDtcbn1cbiIsImltcG9ydCB7IHVzZVJlZHVjZXIgfSBmcm9tICdyZWFjdCc7XG52YXIgdG9nZ2xlUmVkdWNlciA9IGZ1bmN0aW9uIChzdGF0ZSwgbmV4dFZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBuZXh0VmFsdWUgPT09ICdib29sZWFuJyA/IG5leHRWYWx1ZSA6ICFzdGF0ZTtcbn07XG52YXIgdXNlVG9nZ2xlID0gZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgIHJldHVybiB1c2VSZWR1Y2VyKHRvZ2dsZVJlZHVjZXIsIGluaXRpYWxWYWx1ZSk7XG59O1xuZXhwb3J0IGRlZmF1bHQgdXNlVG9nZ2xlO1xuIiwiY29uc3QgcGVyZiA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ29iamVjdCcgJiYgcGVyZm9ybWFuY2UgJiZcbiAgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJyA/IHBlcmZvcm1hbmNlIDogRGF0ZVxuXG5jb25zdCBoYXNBYm9ydENvbnRyb2xsZXIgPSB0eXBlb2YgQWJvcnRDb250cm9sbGVyID09PSAnZnVuY3Rpb24nXG5cbi8vIG1pbmltYWwgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgcG9seWZpbGxcbi8vIHRoaXMgZG9lc24ndCBoYXZlIG5lYXJseSBhbGwgdGhlIGNoZWNrcyBhbmQgd2hhdG5vdCB0aGF0XG4vLyBhY3R1YWwgQWJvcnRDb250cm9sbGVyL1NpZ25hbCBoYXMsIGJ1dCBpdCdzIGVub3VnaCBmb3Jcbi8vIG91ciBwdXJwb3NlcywgYW5kIGlmIHVzZWQgcHJvcGVybHksIGJlaGF2ZXMgdGhlIHNhbWUuXG5jb25zdCBBQyA9IGhhc0Fib3J0Q29udHJvbGxlciA/IEFib3J0Q29udHJvbGxlciA6IE9iamVjdC5hc3NpZ24oXG4gIGNsYXNzIEFib3J0Q29udHJvbGxlciB7XG4gICAgY29uc3RydWN0b3IgKCkgeyB0aGlzLnNpZ25hbCA9IG5ldyBBQy5BYm9ydFNpZ25hbCB9XG4gICAgYWJvcnQgKCkge1xuICAgICAgdGhpcy5zaWduYWwuZGlzcGF0Y2hFdmVudCgnYWJvcnQnKVxuICAgIH1cbiAgfSxcbiAge1xuICAgIEFib3J0U2lnbmFsOiBjbGFzcyBBYm9ydFNpZ25hbCB7XG4gICAgICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgICAgIHRoaXMuYWJvcnRlZCA9IGZhbHNlXG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IFtdXG4gICAgICB9XG4gICAgICBkaXNwYXRjaEV2ZW50ICh0eXBlKSB7XG4gICAgICAgIGlmICh0eXBlID09PSAnYWJvcnQnKSB7XG4gICAgICAgICAgdGhpcy5hYm9ydGVkID0gdHJ1ZVxuICAgICAgICAgIGNvbnN0IGUgPSB7IHR5cGUsIHRhcmdldDogdGhpcyB9XG4gICAgICAgICAgdGhpcy5vbmFib3J0KGUpXG4gICAgICAgICAgdGhpcy5fbGlzdGVuZXJzLmZvckVhY2goZiA9PiBmKGUpLCB0aGlzKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvbmFib3J0ICgpIHt9XG4gICAgICBhZGRFdmVudExpc3RlbmVyIChldiwgZm4pIHtcbiAgICAgICAgaWYgKGV2ID09PSAnYWJvcnQnKSB7XG4gICAgICAgICAgdGhpcy5fbGlzdGVuZXJzLnB1c2goZm4pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIgKGV2LCBmbikge1xuICAgICAgICBpZiAoZXYgPT09ICdhYm9ydCcpIHtcbiAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnMuZmlsdGVyKGYgPT4gZiAhPT0gZm4pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbilcblxuY29uc3Qgd2FybmVkID0gbmV3IFNldCgpXG5jb25zdCBkZXByZWNhdGVkT3B0aW9uID0gKG9wdCwgaW5zdGVhZCkgPT4ge1xuICBjb25zdCBjb2RlID0gYExSVV9DQUNIRV9PUFRJT05fJHtvcHR9YFxuICBpZiAoc2hvdWxkV2Fybihjb2RlKSkge1xuICAgIHdhcm4oY29kZSwgYCR7b3B0fSBvcHRpb25gLCBgb3B0aW9ucy4ke2luc3RlYWR9YCwgTFJVQ2FjaGUpXG4gIH1cbn1cbmNvbnN0IGRlcHJlY2F0ZWRNZXRob2QgPSAobWV0aG9kLCBpbnN0ZWFkKSA9PiB7XG4gIGNvbnN0IGNvZGUgPSBgTFJVX0NBQ0hFX01FVEhPRF8ke21ldGhvZH1gXG4gIGlmIChzaG91bGRXYXJuKGNvZGUpKSB7XG4gICAgY29uc3QgeyBwcm90b3R5cGUgfSA9IExSVUNhY2hlXG4gICAgY29uc3QgeyBnZXQgfSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG90eXBlLCBtZXRob2QpXG4gICAgd2Fybihjb2RlLCBgJHttZXRob2R9IG1ldGhvZGAsIGBjYWNoZS4ke2luc3RlYWR9KClgLCBnZXQpXG4gIH1cbn1cbmNvbnN0IGRlcHJlY2F0ZWRQcm9wZXJ0eSA9IChmaWVsZCwgaW5zdGVhZCkgPT4ge1xuICBjb25zdCBjb2RlID0gYExSVV9DQUNIRV9QUk9QRVJUWV8ke2ZpZWxkfWBcbiAgaWYgKHNob3VsZFdhcm4oY29kZSkpIHtcbiAgICBjb25zdCB7IHByb3RvdHlwZSB9ID0gTFJVQ2FjaGVcbiAgICBjb25zdCB7IGdldCB9ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90b3R5cGUsIGZpZWxkKVxuICAgIHdhcm4oY29kZSwgYCR7ZmllbGR9IHByb3BlcnR5YCwgYGNhY2hlLiR7aW5zdGVhZH1gLCBnZXQpXG4gIH1cbn1cblxuY29uc3QgZW1pdFdhcm5pbmcgPSAoLi4uYSkgPT4ge1xuICB0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiZcbiAgICBwcm9jZXNzICYmXG4gICAgdHlwZW9mIHByb2Nlc3MuZW1pdFdhcm5pbmcgPT09ICdmdW5jdGlvbidcbiAgPyBwcm9jZXNzLmVtaXRXYXJuaW5nKC4uLmEpXG4gIDogY29uc29sZS5lcnJvciguLi5hKVxufVxuXG5jb25zdCBzaG91bGRXYXJuID0gY29kZSA9PiAhd2FybmVkLmhhcyhjb2RlKVxuXG5jb25zdCB3YXJuID0gKGNvZGUsIHdoYXQsIGluc3RlYWQsIGZuKSA9PiB7XG4gIHdhcm5lZC5hZGQoY29kZSlcbiAgY29uc3QgbXNnID0gYFRoZSAke3doYXR9IGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgJHtpbnN0ZWFkfSBpbnN0ZWFkLmBcbiAgZW1pdFdhcm5pbmcobXNnLCAnRGVwcmVjYXRpb25XYXJuaW5nJywgY29kZSwgZm4pXG59XG5cbmNvbnN0IGlzUG9zSW50ID0gbiA9PiBuICYmIG4gPT09IE1hdGguZmxvb3IobikgJiYgbiA+IDAgJiYgaXNGaW5pdGUobilcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSBUaGlzIGlzIGEgbGl0dGxlIGJpdCByaWRpY3Vsb3VzLCB0YmguXG4gKiBUaGUgbWF4aW11bSBhcnJheSBsZW5ndGggaXMgMl4zMi0xIG9yIHRoZXJlYWJvdXRzIG9uIG1vc3QgSlMgaW1wbHMuXG4gKiBBbmQgd2VsbCBiZWZvcmUgdGhhdCBwb2ludCwgeW91J3JlIGNhY2hpbmcgdGhlIGVudGlyZSB3b3JsZCwgSSBtZWFuLFxuICogdGhhdCdzIH4zMkdCIG9mIGp1c3QgaW50ZWdlcnMgZm9yIHRoZSBuZXh0L3ByZXYgbGlua3MsIHBsdXMgd2hhdGV2ZXJcbiAqIGVsc2UgdG8gaG9sZCB0aGF0IG1hbnkga2V5cyBhbmQgdmFsdWVzLiAgSnVzdCBmaWxsaW5nIHRoZSBtZW1vcnkgd2l0aFxuICogemVyb2VzIGF0IGluaXQgdGltZSBpcyBicnV0YWwgd2hlbiB5b3UgZ2V0IHRoYXQgYmlnLlxuICogQnV0IHdoeSBub3QgYmUgY29tcGxldGU/XG4gKiBNYXliZSBpbiB0aGUgZnV0dXJlLCB0aGVzZSBsaW1pdHMgd2lsbCBoYXZlIGV4cGFuZGVkLiAqL1xuY29uc3QgZ2V0VWludEFycmF5ID0gbWF4ID0+ICFpc1Bvc0ludChtYXgpID8gbnVsbFxuOiBtYXggPD0gTWF0aC5wb3coMiwgOCkgPyBVaW50OEFycmF5XG46IG1heCA8PSBNYXRoLnBvdygyLCAxNikgPyBVaW50MTZBcnJheVxuOiBtYXggPD0gTWF0aC5wb3coMiwgMzIpID8gVWludDMyQXJyYXlcbjogbWF4IDw9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSID8gWmVyb0FycmF5XG46IG51bGxcblxuY2xhc3MgWmVyb0FycmF5IGV4dGVuZHMgQXJyYXkge1xuICBjb25zdHJ1Y3RvciAoc2l6ZSkge1xuICAgIHN1cGVyKHNpemUpXG4gICAgdGhpcy5maWxsKDApXG4gIH1cbn1cblxuY2xhc3MgU3RhY2sge1xuICBjb25zdHJ1Y3RvciAobWF4KSB7XG4gICAgaWYgKG1heCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuICAgIGNvbnN0IFVpbnRBcnJheSA9IGdldFVpbnRBcnJheShtYXgpXG4gICAgdGhpcy5oZWFwID0gbmV3IFVpbnRBcnJheShtYXgpXG4gICAgdGhpcy5sZW5ndGggPSAwXG4gIH1cbiAgcHVzaCAobikge1xuICAgIHRoaXMuaGVhcFt0aGlzLmxlbmd0aCsrXSA9IG5cbiAgfVxuICBwb3AgKCkge1xuICAgIHJldHVybiB0aGlzLmhlYXBbLS10aGlzLmxlbmd0aF1cbiAgfVxufVxuXG5jbGFzcyBMUlVDYWNoZSB7XG4gIGNvbnN0cnVjdG9yIChvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICBtYXggPSAwLFxuICAgICAgdHRsLFxuICAgICAgdHRsUmVzb2x1dGlvbiA9IDEsXG4gICAgICB0dGxBdXRvcHVyZ2UsXG4gICAgICB1cGRhdGVBZ2VPbkdldCxcbiAgICAgIHVwZGF0ZUFnZU9uSGFzLFxuICAgICAgYWxsb3dTdGFsZSxcbiAgICAgIGRpc3Bvc2UsXG4gICAgICBkaXNwb3NlQWZ0ZXIsXG4gICAgICBub0Rpc3Bvc2VPblNldCxcbiAgICAgIG5vVXBkYXRlVFRMLFxuICAgICAgbWF4U2l6ZSA9IDAsXG4gICAgICBzaXplQ2FsY3VsYXRpb24sXG4gICAgICBmZXRjaE1ldGhvZCxcbiAgICB9ID0gb3B0aW9uc1xuXG4gICAgLy8gZGVwcmVjYXRlZCBvcHRpb25zLCBkb24ndCB0cmlnZ2VyIGEgd2FybmluZyBmb3IgZ2V0dGluZyB0aGVtIGlmXG4gICAgLy8gdGhlIHRoaW5nIGJlaW5nIHBhc3NlZCBpbiBpcyBhbm90aGVyIExSVUNhY2hlIHdlJ3JlIGNvcHlpbmcuXG4gICAgY29uc3Qge1xuICAgICAgbGVuZ3RoLFxuICAgICAgbWF4QWdlLFxuICAgICAgc3RhbGUsXG4gICAgfSA9IG9wdGlvbnMgaW5zdGFuY2VvZiBMUlVDYWNoZSA/IHt9IDogb3B0aW9uc1xuXG4gICAgaWYgKG1heCAhPT0gMCAmJiAhaXNQb3NJbnQobWF4KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4IG9wdGlvbiBtdXN0IGJlIGEgbm9ubmVnYXRpdmUgaW50ZWdlcicpXG4gICAgfVxuXG4gICAgY29uc3QgVWludEFycmF5ID0gbWF4ID8gZ2V0VWludEFycmF5KG1heCkgOiBBcnJheVxuICAgIGlmICghVWludEFycmF5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgbWF4IHZhbHVlOiAnICsgbWF4KVxuICAgIH1cblxuICAgIHRoaXMubWF4ID0gbWF4XG4gICAgdGhpcy5tYXhTaXplID0gbWF4U2l6ZVxuICAgIHRoaXMuc2l6ZUNhbGN1bGF0aW9uID0gc2l6ZUNhbGN1bGF0aW9uIHx8IGxlbmd0aFxuICAgIGlmICh0aGlzLnNpemVDYWxjdWxhdGlvbikge1xuICAgICAgaWYgKCF0aGlzLm1heFNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2Fubm90IHNldCBzaXplQ2FsY3VsYXRpb24gd2l0aG91dCBzZXR0aW5nIG1heFNpemUnKVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnNpemVDYWxjdWxhdGlvbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzaXplQ2FsY3VsYXRpb24gc2V0IHRvIG5vbi1mdW5jdGlvbicpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5mZXRjaE1ldGhvZCA9IGZldGNoTWV0aG9kIHx8IG51bGxcbiAgICBpZiAodGhpcy5mZXRjaE1ldGhvZCAmJiB0eXBlb2YgdGhpcy5mZXRjaE1ldGhvZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZmV0Y2hNZXRob2QgbXVzdCBiZSBhIGZ1bmN0aW9uIGlmIHNwZWNpZmllZCcpXG4gICAgfVxuXG4gICAgdGhpcy5rZXlNYXAgPSBuZXcgTWFwKClcbiAgICB0aGlzLmtleUxpc3QgPSBuZXcgQXJyYXkobWF4KS5maWxsKG51bGwpXG4gICAgdGhpcy52YWxMaXN0ID0gbmV3IEFycmF5KG1heCkuZmlsbChudWxsKVxuICAgIHRoaXMubmV4dCA9IG5ldyBVaW50QXJyYXkobWF4KVxuICAgIHRoaXMucHJldiA9IG5ldyBVaW50QXJyYXkobWF4KVxuICAgIHRoaXMuaGVhZCA9IDBcbiAgICB0aGlzLnRhaWwgPSAwXG4gICAgdGhpcy5mcmVlID0gbmV3IFN0YWNrKG1heClcbiAgICB0aGlzLmluaXRpYWxGaWxsID0gMVxuICAgIHRoaXMuc2l6ZSA9IDBcblxuICAgIGlmICh0eXBlb2YgZGlzcG9zZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5kaXNwb3NlID0gZGlzcG9zZVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGRpc3Bvc2VBZnRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5kaXNwb3NlQWZ0ZXIgPSBkaXNwb3NlQWZ0ZXJcbiAgICAgIHRoaXMuZGlzcG9zZWQgPSBbXVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpc3Bvc2VBZnRlciA9IG51bGxcbiAgICAgIHRoaXMuZGlzcG9zZWQgPSBudWxsXG4gICAgfVxuICAgIHRoaXMubm9EaXNwb3NlT25TZXQgPSAhIW5vRGlzcG9zZU9uU2V0XG4gICAgdGhpcy5ub1VwZGF0ZVRUTCA9ICEhbm9VcGRhdGVUVExcblxuICAgIGlmICh0aGlzLm1heFNpemUgIT09IDApIHtcbiAgICAgIGlmICghaXNQb3NJbnQodGhpcy5tYXhTaXplKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXhTaXplIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGlmIHNwZWNpZmllZCcpXG4gICAgICB9XG4gICAgICB0aGlzLmluaXRpYWxpemVTaXplVHJhY2tpbmcoKVxuICAgIH1cblxuICAgIHRoaXMuYWxsb3dTdGFsZSA9ICEhYWxsb3dTdGFsZSB8fCAhIXN0YWxlXG4gICAgdGhpcy51cGRhdGVBZ2VPbkdldCA9ICEhdXBkYXRlQWdlT25HZXRcbiAgICB0aGlzLnVwZGF0ZUFnZU9uSGFzID0gISF1cGRhdGVBZ2VPbkhhc1xuICAgIHRoaXMudHRsUmVzb2x1dGlvbiA9IGlzUG9zSW50KHR0bFJlc29sdXRpb24pIHx8IHR0bFJlc29sdXRpb24gPT09IDBcbiAgICAgID8gdHRsUmVzb2x1dGlvbiA6IDFcbiAgICB0aGlzLnR0bEF1dG9wdXJnZSA9ICEhdHRsQXV0b3B1cmdlXG4gICAgdGhpcy50dGwgPSB0dGwgfHwgbWF4QWdlIHx8IDBcbiAgICBpZiAodGhpcy50dGwpIHtcbiAgICAgIGlmICghaXNQb3NJbnQodGhpcy50dGwpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3R0bCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBpZiBzcGVjaWZpZWQnKVxuICAgICAgfVxuICAgICAgdGhpcy5pbml0aWFsaXplVFRMVHJhY2tpbmcoKVxuICAgIH1cblxuICAgIC8vIGRvIG5vdCBhbGxvdyBjb21wbGV0ZWx5IHVuYm91bmRlZCBjYWNoZXNcbiAgICBpZiAodGhpcy5tYXggPT09IDAgJiYgdGhpcy50dGwgPT09IDAgJiYgdGhpcy5tYXhTaXplID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBdCBsZWFzdCBvbmUgb2YgbWF4LCBtYXhTaXplLCBvciB0dGwgaXMgcmVxdWlyZWQnKVxuICAgIH1cbiAgICBpZiAoIXRoaXMudHRsQXV0b3B1cmdlICYmICF0aGlzLm1heCAmJiAhdGhpcy5tYXhTaXplKSB7XG4gICAgICBjb25zdCBjb2RlID0gJ0xSVV9DQUNIRV9VTkJPVU5ERUQnXG4gICAgICBpZiAoc2hvdWxkV2Fybihjb2RlKSkge1xuICAgICAgICB3YXJuZWQuYWRkKGNvZGUpXG4gICAgICAgIGNvbnN0IG1zZyA9ICdUVEwgY2FjaGluZyB3aXRob3V0IHR0bEF1dG9wdXJnZSwgbWF4LCBvciBtYXhTaXplIGNhbiAnICtcbiAgICAgICAgICAncmVzdWx0IGluIHVuYm91bmRlZCBtZW1vcnkgY29uc3VtcHRpb24uJ1xuICAgICAgICBlbWl0V2FybmluZyhtc2csICdVbmJvdW5kZWRDYWNoZVdhcm5pbmcnLCBjb2RlLCBMUlVDYWNoZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RhbGUpIHtcbiAgICAgIGRlcHJlY2F0ZWRPcHRpb24oJ3N0YWxlJywgJ2FsbG93U3RhbGUnKVxuICAgIH1cbiAgICBpZiAobWF4QWdlKSB7XG4gICAgICBkZXByZWNhdGVkT3B0aW9uKCdtYXhBZ2UnLCAndHRsJylcbiAgICB9XG4gICAgaWYgKGxlbmd0aCkge1xuICAgICAgZGVwcmVjYXRlZE9wdGlvbignbGVuZ3RoJywgJ3NpemVDYWxjdWxhdGlvbicpXG4gICAgfVxuICB9XG5cbiAgZ2V0UmVtYWluaW5nVFRMIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5oYXMoa2V5LCB7IHVwZGF0ZUFnZU9uSGFzOiBmYWxzZSB9KSA/IEluZmluaXR5IDogMFxuICB9XG5cbiAgaW5pdGlhbGl6ZVRUTFRyYWNraW5nICgpIHtcbiAgICB0aGlzLnR0bHMgPSBuZXcgWmVyb0FycmF5KHRoaXMubWF4KVxuICAgIHRoaXMuc3RhcnRzID0gbmV3IFplcm9BcnJheSh0aGlzLm1heClcblxuICAgIHRoaXMuc2V0SXRlbVRUTCA9IChpbmRleCwgdHRsKSA9PiB7XG4gICAgICB0aGlzLnN0YXJ0c1tpbmRleF0gPSB0dGwgIT09IDAgPyBwZXJmLm5vdygpIDogMFxuICAgICAgdGhpcy50dGxzW2luZGV4XSA9IHR0bFxuICAgICAgaWYgKHR0bCAhPT0gMCAmJiB0aGlzLnR0bEF1dG9wdXJnZSkge1xuICAgICAgICBjb25zdCB0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuaXNTdGFsZShpbmRleCkpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlKHRoaXMua2V5TGlzdFtpbmRleF0pXG4gICAgICAgICAgfVxuICAgICAgICB9LCB0dGwgKyAxKVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAtIHVucmVmKCkgbm90IHN1cHBvcnRlZCBvbiBhbGwgcGxhdGZvcm1zICovXG4gICAgICAgIGlmICh0LnVucmVmKSB7XG4gICAgICAgICAgdC51bnJlZigpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZUl0ZW1BZ2UgPSAoaW5kZXgpID0+IHtcbiAgICAgIHRoaXMuc3RhcnRzW2luZGV4XSA9IHRoaXMudHRsc1tpbmRleF0gIT09IDAgPyBwZXJmLm5vdygpIDogMFxuICAgIH1cblxuICAgIC8vIGRlYm91bmNlIGNhbGxzIHRvIHBlcmYubm93KCkgdG8gMXMgc28gd2UncmUgbm90IGhpdHRpbmdcbiAgICAvLyB0aGF0IGNvc3RseSBjYWxsIHJlcGVhdGVkbHkuXG4gICAgbGV0IGNhY2hlZE5vdyA9IDBcbiAgICBjb25zdCBnZXROb3cgPSAoKSA9PiB7XG4gICAgICBjb25zdCBuID0gcGVyZi5ub3coKVxuICAgICAgaWYgKHRoaXMudHRsUmVzb2x1dGlvbiA+IDApIHtcbiAgICAgICAgY2FjaGVkTm93ID0gblxuICAgICAgICBjb25zdCB0ID0gc2V0VGltZW91dCgoKSA9PiBjYWNoZWROb3cgPSAwLCB0aGlzLnR0bFJlc29sdXRpb24pXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlIC0gbm90IGF2YWlsYWJsZSBvbiBhbGwgcGxhdGZvcm1zICovXG4gICAgICAgIGlmICh0LnVucmVmKSB7XG4gICAgICAgICAgdC51bnJlZigpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuXG4gICAgfVxuXG4gICAgdGhpcy5nZXRSZW1haW5pbmdUVEwgPSAoa2V5KSA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMua2V5TWFwLmdldChrZXkpXG4gICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudHRsc1tpbmRleF0gPT09IDAgfHwgdGhpcy5zdGFydHNbaW5kZXhdID09PSAwID8gSW5maW5pdHlcbiAgICAgICAgOiAoKHRoaXMuc3RhcnRzW2luZGV4XSArIHRoaXMudHRsc1tpbmRleF0pIC0gKGNhY2hlZE5vdyB8fCBnZXROb3coKSkpXG4gICAgfVxuXG4gICAgdGhpcy5pc1N0YWxlID0gKGluZGV4KSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy50dGxzW2luZGV4XSAhPT0gMCAmJiB0aGlzLnN0YXJ0c1tpbmRleF0gIT09IDAgJiZcbiAgICAgICAgKChjYWNoZWROb3cgfHwgZ2V0Tm93KCkpIC0gdGhpcy5zdGFydHNbaW5kZXhdID4gdGhpcy50dGxzW2luZGV4XSlcbiAgICB9XG4gIH1cbiAgdXBkYXRlSXRlbUFnZSAoaW5kZXgpIHt9XG4gIHNldEl0ZW1UVEwgKGluZGV4LCB0dGwpIHt9XG4gIGlzU3RhbGUgKGluZGV4KSB7IHJldHVybiBmYWxzZSB9XG5cbiAgaW5pdGlhbGl6ZVNpemVUcmFja2luZyAoKSB7XG4gICAgdGhpcy5jYWxjdWxhdGVkU2l6ZSA9IDBcbiAgICB0aGlzLnNpemVzID0gbmV3IFplcm9BcnJheSh0aGlzLm1heClcbiAgICB0aGlzLnJlbW92ZUl0ZW1TaXplID0gaW5kZXggPT4gdGhpcy5jYWxjdWxhdGVkU2l6ZSAtPSB0aGlzLnNpemVzW2luZGV4XVxuICAgIHRoaXMucmVxdWlyZVNpemUgPSAoaywgdiwgc2l6ZSwgc2l6ZUNhbGN1bGF0aW9uKSA9PiB7XG4gICAgICBpZiAoIWlzUG9zSW50KHNpemUpKSB7XG4gICAgICAgIGlmIChzaXplQ2FsY3VsYXRpb24pIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHNpemVDYWxjdWxhdGlvbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2l6ZUNhbGN1bGF0aW9uIG11c3QgYmUgYSBmdW5jdGlvbicpXG4gICAgICAgICAgfVxuICAgICAgICAgIHNpemUgPSBzaXplQ2FsY3VsYXRpb24odiwgaylcbiAgICAgICAgICBpZiAoIWlzUG9zSW50KHNpemUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzaXplQ2FsY3VsYXRpb24gcmV0dXJuIGludmFsaWQgKGV4cGVjdCBwb3NpdGl2ZSBpbnRlZ2VyKScpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgc2l6ZSB2YWx1ZSAobXVzdCBiZSBwb3NpdGl2ZSBpbnRlZ2VyKScpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzaXplXG4gICAgfVxuICAgIHRoaXMuYWRkSXRlbVNpemUgPSAoaW5kZXgsIHYsIGssIHNpemUpID0+IHtcbiAgICAgIHRoaXMuc2l6ZXNbaW5kZXhdID0gc2l6ZVxuICAgICAgY29uc3QgbWF4U2l6ZSA9IHRoaXMubWF4U2l6ZSAtIHRoaXMuc2l6ZXNbaW5kZXhdXG4gICAgICB3aGlsZSAodGhpcy5jYWxjdWxhdGVkU2l6ZSA+IG1heFNpemUpIHtcbiAgICAgICAgdGhpcy5ldmljdCh0cnVlKVxuICAgICAgfVxuICAgICAgdGhpcy5jYWxjdWxhdGVkU2l6ZSArPSB0aGlzLnNpemVzW2luZGV4XVxuICAgIH1cbiAgfVxuICByZW1vdmVJdGVtU2l6ZSAoaW5kZXgpIHt9XG4gIGFkZEl0ZW1TaXplIChpbmRleCwgdiwgaywgc2l6ZSkge31cbiAgcmVxdWlyZVNpemUgKGssIHYsIHNpemUsIHNpemVDYWxjdWxhdGlvbikge1xuICAgIGlmIChzaXplIHx8IHNpemVDYWxjdWxhdGlvbikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2Fubm90IHNldCBzaXplIHdpdGhvdXQgc2V0dGluZyBtYXhTaXplIG9uIGNhY2hlJylcbiAgICB9XG4gIH1cblxuICAqaW5kZXhlcyAoeyBhbGxvd1N0YWxlID0gdGhpcy5hbGxvd1N0YWxlIH0gPSB7fSkge1xuICAgIGlmICh0aGlzLnNpemUpIHtcbiAgICAgIGZvciAobGV0IGkgPSB0aGlzLnRhaWw7IHRydWU7ICkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZEluZGV4KGkpKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxsb3dTdGFsZSB8fCAhdGhpcy5pc1N0YWxlKGkpKSB7XG4gICAgICAgICAgeWllbGQgaVxuICAgICAgICB9XG4gICAgICAgIGlmIChpID09PSB0aGlzLmhlYWQpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGkgPSB0aGlzLnByZXZbaV1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gICpyaW5kZXhlcyAoeyBhbGxvd1N0YWxlID0gdGhpcy5hbGxvd1N0YWxlIH0gPSB7fSkge1xuICAgIGlmICh0aGlzLnNpemUpIHtcbiAgICAgIGZvciAobGV0IGkgPSB0aGlzLmhlYWQ7IHRydWU7ICkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZEluZGV4KGkpKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxsb3dTdGFsZSB8fCAhdGhpcy5pc1N0YWxlKGkpKSB7XG4gICAgICAgICAgeWllbGQgaVxuICAgICAgICB9XG4gICAgICAgIGlmIChpID09PSB0aGlzLnRhaWwpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGkgPSB0aGlzLm5leHRbaV1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlzVmFsaWRJbmRleCAoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5rZXlNYXAuZ2V0KHRoaXMua2V5TGlzdFtpbmRleF0pID09PSBpbmRleFxuICB9XG5cbiAgKmVudHJpZXMgKCkge1xuICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLmluZGV4ZXMoKSkge1xuICAgICAgeWllbGQgW3RoaXMua2V5TGlzdFtpXSwgdGhpcy52YWxMaXN0W2ldXVxuICAgIH1cbiAgfVxuICAqcmVudHJpZXMgKCkge1xuICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLnJpbmRleGVzKCkpIHtcbiAgICAgIHlpZWxkIFt0aGlzLmtleUxpc3RbaV0sIHRoaXMudmFsTGlzdFtpXV1cbiAgICB9XG4gIH1cblxuICAqa2V5cyAoKSB7XG4gICAgZm9yIChjb25zdCBpIG9mIHRoaXMuaW5kZXhlcygpKSB7XG4gICAgICB5aWVsZCB0aGlzLmtleUxpc3RbaV1cbiAgICB9XG4gIH1cbiAgKnJrZXlzICgpIHtcbiAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy5yaW5kZXhlcygpKSB7XG4gICAgICB5aWVsZCB0aGlzLmtleUxpc3RbaV1cbiAgICB9XG4gIH1cblxuICAqdmFsdWVzICgpIHtcbiAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy5pbmRleGVzKCkpIHtcbiAgICAgIHlpZWxkIHRoaXMudmFsTGlzdFtpXVxuICAgIH1cbiAgfVxuICAqcnZhbHVlcyAoKSB7XG4gICAgZm9yIChjb25zdCBpIG9mIHRoaXMucmluZGV4ZXMoKSkge1xuICAgICAgeWllbGQgdGhpcy52YWxMaXN0W2ldXG4gICAgfVxuICB9XG5cbiAgW1N5bWJvbC5pdGVyYXRvcl0gKCkge1xuICAgIHJldHVybiB0aGlzLmVudHJpZXMoKVxuICB9XG5cbiAgZmluZCAoZm4sIGdldE9wdGlvbnMgPSB7fSkge1xuICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLmluZGV4ZXMoKSkge1xuICAgICAgaWYgKGZuKHRoaXMudmFsTGlzdFtpXSwgdGhpcy5rZXlMaXN0W2ldLCB0aGlzKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQodGhpcy5rZXlMaXN0W2ldLCBnZXRPcHRpb25zKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvckVhY2ggKGZuLCB0aGlzcCA9IHRoaXMpIHtcbiAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy5pbmRleGVzKCkpIHtcbiAgICAgIGZuLmNhbGwodGhpc3AsIHRoaXMudmFsTGlzdFtpXSwgdGhpcy5rZXlMaXN0W2ldLCB0aGlzKVxuICAgIH1cbiAgfVxuXG4gIHJmb3JFYWNoIChmbiwgdGhpc3AgPSB0aGlzKSB7XG4gICAgZm9yIChjb25zdCBpIG9mIHRoaXMucmluZGV4ZXMoKSkge1xuICAgICAgZm4uY2FsbCh0aGlzcCwgdGhpcy52YWxMaXN0W2ldLCB0aGlzLmtleUxpc3RbaV0sIHRoaXMpXG4gICAgfVxuICB9XG5cbiAgZ2V0IHBydW5lICgpIHtcbiAgICBkZXByZWNhdGVkTWV0aG9kKCdwcnVuZScsICdwdXJnZVN0YWxlJylcbiAgICByZXR1cm4gdGhpcy5wdXJnZVN0YWxlXG4gIH1cblxuICBwdXJnZVN0YWxlICgpIHtcbiAgICBsZXQgZGVsZXRlZCA9IGZhbHNlXG4gICAgZm9yIChjb25zdCBpIG9mIHRoaXMucmluZGV4ZXMoeyBhbGxvd1N0YWxlOiB0cnVlIH0pKSB7XG4gICAgICBpZiAodGhpcy5pc1N0YWxlKGkpKSB7XG4gICAgICAgIHRoaXMuZGVsZXRlKHRoaXMua2V5TGlzdFtpXSlcbiAgICAgICAgZGVsZXRlZCA9IHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlbGV0ZWRcbiAgfVxuXG4gIGR1bXAgKCkge1xuICAgIGNvbnN0IGFyciA9IFtdXG4gICAgZm9yIChjb25zdCBpIG9mIHRoaXMuaW5kZXhlcygpKSB7XG4gICAgICBjb25zdCBrZXkgPSB0aGlzLmtleUxpc3RbaV1cbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy52YWxMaXN0W2ldXG4gICAgICBjb25zdCBlbnRyeSA9IHsgdmFsdWUgfVxuICAgICAgaWYgKHRoaXMudHRscykge1xuICAgICAgICBlbnRyeS50dGwgPSB0aGlzLnR0bHNbaV1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNpemVzKSB7XG4gICAgICAgIGVudHJ5LnNpemUgPSB0aGlzLnNpemVzW2ldXG4gICAgICB9XG4gICAgICBhcnIudW5zaGlmdChba2V5LCBlbnRyeV0pXG4gICAgfVxuICAgIHJldHVybiBhcnJcbiAgfVxuXG4gIGxvYWQgKGFycikge1xuICAgIHRoaXMuY2xlYXIoKVxuICAgIGZvciAoY29uc3QgW2tleSwgZW50cnldIG9mIGFycikge1xuICAgICAgdGhpcy5zZXQoa2V5LCBlbnRyeS52YWx1ZSwgZW50cnkpXG4gICAgfVxuICB9XG5cbiAgZGlzcG9zZSAodiwgaywgcmVhc29uKSB7fVxuXG4gIHNldCAoaywgdiwge1xuICAgIHR0bCA9IHRoaXMudHRsLFxuICAgIG5vRGlzcG9zZU9uU2V0ID0gdGhpcy5ub0Rpc3Bvc2VPblNldCxcbiAgICBzaXplID0gMCxcbiAgICBzaXplQ2FsY3VsYXRpb24gPSB0aGlzLnNpemVDYWxjdWxhdGlvbixcbiAgICBub1VwZGF0ZVRUTCA9IHRoaXMubm9VcGRhdGVUVEwsXG4gIH0gPSB7fSkge1xuICAgIHNpemUgPSB0aGlzLnJlcXVpcmVTaXplKGssIHYsIHNpemUsIHNpemVDYWxjdWxhdGlvbilcbiAgICBsZXQgaW5kZXggPSB0aGlzLnNpemUgPT09IDAgPyB1bmRlZmluZWQgOiB0aGlzLmtleU1hcC5nZXQoaylcbiAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gYWRkaXRpb25cbiAgICAgIGluZGV4ID0gdGhpcy5uZXdJbmRleCgpXG4gICAgICB0aGlzLmtleUxpc3RbaW5kZXhdID0ga1xuICAgICAgdGhpcy52YWxMaXN0W2luZGV4XSA9IHZcbiAgICAgIHRoaXMua2V5TWFwLnNldChrLCBpbmRleClcbiAgICAgIHRoaXMubmV4dFt0aGlzLnRhaWxdID0gaW5kZXhcbiAgICAgIHRoaXMucHJldltpbmRleF0gPSB0aGlzLnRhaWxcbiAgICAgIHRoaXMudGFpbCA9IGluZGV4XG4gICAgICB0aGlzLnNpemUgKytcbiAgICAgIHRoaXMuYWRkSXRlbVNpemUoaW5kZXgsIHYsIGssIHNpemUpXG4gICAgICBub1VwZGF0ZVRUTCA9IGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVwZGF0ZVxuICAgICAgY29uc3Qgb2xkVmFsID0gdGhpcy52YWxMaXN0W2luZGV4XVxuICAgICAgaWYgKHYgIT09IG9sZFZhbCkge1xuICAgICAgICBpZiAodGhpcy5pc0JhY2tncm91bmRGZXRjaChvbGRWYWwpKSB7XG4gICAgICAgICAgb2xkVmFsLl9fYWJvcnRDb250cm9sbGVyLmFib3J0KClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIW5vRGlzcG9zZU9uU2V0KSB7XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2Uob2xkVmFsLCBrLCAnc2V0JylcbiAgICAgICAgICAgIGlmICh0aGlzLmRpc3Bvc2VBZnRlcikge1xuICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2VkLnB1c2goW29sZFZhbCwgaywgJ3NldCddKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUl0ZW1TaXplKGluZGV4KVxuICAgICAgICB0aGlzLnZhbExpc3RbaW5kZXhdID0gdlxuICAgICAgICB0aGlzLmFkZEl0ZW1TaXplKGluZGV4LCB2LCBrLCBzaXplKVxuICAgICAgfVxuICAgICAgdGhpcy5tb3ZlVG9UYWlsKGluZGV4KVxuICAgIH1cbiAgICBpZiAodHRsICE9PSAwICYmIHRoaXMudHRsID09PSAwICYmICF0aGlzLnR0bHMpIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZVRUTFRyYWNraW5nKClcbiAgICB9XG4gICAgaWYgKCFub1VwZGF0ZVRUTCkge1xuICAgICAgdGhpcy5zZXRJdGVtVFRMKGluZGV4LCB0dGwpXG4gICAgfVxuICAgIGlmICh0aGlzLmRpc3Bvc2VBZnRlcikge1xuICAgICAgd2hpbGUgKHRoaXMuZGlzcG9zZWQubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuZGlzcG9zZUFmdGVyKC4uLnRoaXMuZGlzcG9zZWQuc2hpZnQoKSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIG5ld0luZGV4ICgpIHtcbiAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy50YWlsXG4gICAgfVxuICAgIGlmICh0aGlzLnNpemUgPT09IHRoaXMubWF4ICYmIHRoaXMubWF4ICE9PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5ldmljdChmYWxzZSlcbiAgICB9XG4gICAgaWYgKHRoaXMuZnJlZS5sZW5ndGggIT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmZyZWUucG9wKClcbiAgICB9XG4gICAgLy8gaW5pdGlhbCBmaWxsLCBqdXN0IGtlZXAgd3JpdGluZyBkb3duIHRoZSBsaXN0XG4gICAgcmV0dXJuIHRoaXMuaW5pdGlhbEZpbGwrK1xuICB9XG5cbiAgcG9wICgpIHtcbiAgICBpZiAodGhpcy5zaXplKSB7XG4gICAgICBjb25zdCB2YWwgPSB0aGlzLnZhbExpc3RbdGhpcy5oZWFkXVxuICAgICAgdGhpcy5ldmljdCh0cnVlKVxuICAgICAgcmV0dXJuIHZhbFxuICAgIH1cbiAgfVxuXG4gIGV2aWN0IChmcmVlKSB7XG4gICAgY29uc3QgaGVhZCA9IHRoaXMuaGVhZFxuICAgIGNvbnN0IGsgPSB0aGlzLmtleUxpc3RbaGVhZF1cbiAgICBjb25zdCB2ID0gdGhpcy52YWxMaXN0W2hlYWRdXG4gICAgaWYgKHRoaXMuaXNCYWNrZ3JvdW5kRmV0Y2godikpIHtcbiAgICAgIHYuX19hYm9ydENvbnRyb2xsZXIuYWJvcnQoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpc3Bvc2UodiwgaywgJ2V2aWN0JylcbiAgICAgIGlmICh0aGlzLmRpc3Bvc2VBZnRlcikge1xuICAgICAgICB0aGlzLmRpc3Bvc2VkLnB1c2goW3YsIGssICdldmljdCddKVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJlbW92ZUl0ZW1TaXplKGhlYWQpXG4gICAgLy8gaWYgd2UgYXJlbid0IGFib3V0IHRvIHVzZSB0aGUgaW5kZXgsIHRoZW4gbnVsbCB0aGVzZSBvdXRcbiAgICBpZiAoZnJlZSkge1xuICAgICAgdGhpcy5rZXlMaXN0W2hlYWRdID0gbnVsbFxuICAgICAgdGhpcy52YWxMaXN0W2hlYWRdID0gbnVsbFxuICAgICAgdGhpcy5mcmVlLnB1c2goaGVhZClcbiAgICB9XG4gICAgdGhpcy5oZWFkID0gdGhpcy5uZXh0W2hlYWRdXG4gICAgdGhpcy5rZXlNYXAuZGVsZXRlKGspXG4gICAgdGhpcy5zaXplIC0tXG4gICAgcmV0dXJuIGhlYWRcbiAgfVxuXG4gIGhhcyAoaywgeyB1cGRhdGVBZ2VPbkhhcyA9IHRoaXMudXBkYXRlQWdlT25IYXMgfSA9IHt9KSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmtleU1hcC5nZXQoaylcbiAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCF0aGlzLmlzU3RhbGUoaW5kZXgpKSB7XG4gICAgICAgIGlmICh1cGRhdGVBZ2VPbkhhcykge1xuICAgICAgICAgIHRoaXMudXBkYXRlSXRlbUFnZShpbmRleClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIGxpa2UgZ2V0KCksIGJ1dCB3aXRob3V0IGFueSBMUlUgdXBkYXRpbmcgb3IgVFRMIGV4cGlyYXRpb25cbiAgcGVlayAoaywgeyBhbGxvd1N0YWxlID0gdGhpcy5hbGxvd1N0YWxlIH0gPSB7fSkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5rZXlNYXAuZ2V0KGspXG4gICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQgJiYgKGFsbG93U3RhbGUgfHwgIXRoaXMuaXNTdGFsZShpbmRleCkpKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWxMaXN0W2luZGV4XVxuICAgIH1cbiAgfVxuXG4gIGJhY2tncm91bmRGZXRjaCAoaywgaW5kZXgsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB2ID0gaW5kZXggPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHRoaXMudmFsTGlzdFtpbmRleF1cbiAgICBpZiAodGhpcy5pc0JhY2tncm91bmRGZXRjaCh2KSkge1xuICAgICAgcmV0dXJuIHZcbiAgICB9XG4gICAgY29uc3QgYWMgPSBuZXcgQUMoKVxuICAgIGNvbnN0IGZldGNoT3B0cyA9IHtcbiAgICAgIHNpZ25hbDogYWMuc2lnbmFsLFxuICAgICAgb3B0aW9ucyxcbiAgICB9XG4gICAgY29uc3QgcCA9IFByb21pc2UucmVzb2x2ZSh0aGlzLmZldGNoTWV0aG9kKGssIHYsIGZldGNoT3B0cykpLnRoZW4odiA9PiB7XG4gICAgICBpZiAoIWFjLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHRoaXMuc2V0KGssIHYsIGZldGNoT3B0cy5vcHRpb25zKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZcbiAgICB9KVxuICAgIHAuX19hYm9ydENvbnRyb2xsZXIgPSBhY1xuICAgIHAuX19zdGFsZVdoaWxlRmV0Y2hpbmcgPSB2XG4gICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuc2V0KGssIHAsIGZldGNoT3B0cy5vcHRpb25zKVxuICAgICAgaW5kZXggPSB0aGlzLmtleU1hcC5nZXQoaylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy52YWxMaXN0W2luZGV4XSA9IHBcbiAgICB9XG4gICAgcmV0dXJuIHBcbiAgfVxuXG4gIGlzQmFja2dyb3VuZEZldGNoIChwKSB7XG4gICAgcmV0dXJuIHAgJiYgdHlwZW9mIHAgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwLnRoZW4gPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwLCAnX19zdGFsZVdoaWxlRmV0Y2hpbmcnKVxuICB9XG5cbiAgLy8gdGhpcyB0YWtlcyB0aGUgdW5pb24gb2YgZ2V0KCkgYW5kIHNldCgpIG9wdHMsIGJlY2F1c2UgaXQgZG9lcyBib3RoXG4gIGFzeW5jIGZldGNoIChrLCB7XG4gICAgYWxsb3dTdGFsZSA9IHRoaXMuYWxsb3dTdGFsZSxcbiAgICB1cGRhdGVBZ2VPbkdldCA9IHRoaXMudXBkYXRlQWdlT25HZXQsXG4gICAgdHRsID0gdGhpcy50dGwsXG4gICAgbm9EaXNwb3NlT25TZXQgPSB0aGlzLm5vRGlzcG9zZU9uU2V0LFxuICAgIHNpemUgPSAwLFxuICAgIHNpemVDYWxjdWxhdGlvbiA9IHRoaXMuc2l6ZUNhbGN1bGF0aW9uLFxuICAgIG5vVXBkYXRlVFRMID0gdGhpcy5ub1VwZGF0ZVRUTCxcbiAgfSA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmZldGNoTWV0aG9kKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQoaywge2FsbG93U3RhbGUsIHVwZGF0ZUFnZU9uR2V0fSlcbiAgICB9XG5cbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgYWxsb3dTdGFsZSxcbiAgICAgIHVwZGF0ZUFnZU9uR2V0LFxuICAgICAgdHRsLFxuICAgICAgbm9EaXNwb3NlT25TZXQsXG4gICAgICBzaXplLFxuICAgICAgc2l6ZUNhbGN1bGF0aW9uLFxuICAgICAgbm9VcGRhdGVUVEwsXG4gICAgfVxuXG4gICAgbGV0IGluZGV4ID0gdGhpcy5rZXlNYXAuZ2V0KGspXG4gICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmJhY2tncm91bmRGZXRjaChrLCBpbmRleCwgb3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaW4gY2FjaGUsIG1heWJlIGFscmVhZHkgZmV0Y2hpbmdcbiAgICAgIGNvbnN0IHYgPSB0aGlzLnZhbExpc3RbaW5kZXhdXG4gICAgICBpZiAodGhpcy5pc0JhY2tncm91bmRGZXRjaCh2KSkge1xuICAgICAgICByZXR1cm4gYWxsb3dTdGFsZSAmJiB2Ll9fc3RhbGVXaGlsZUZldGNoaW5nICE9PSB1bmRlZmluZWRcbiAgICAgICAgICA/IHYuX19zdGFsZVdoaWxlRmV0Y2hpbmcgOiB2XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5pc1N0YWxlKGluZGV4KSkge1xuICAgICAgICB0aGlzLm1vdmVUb1RhaWwoaW5kZXgpXG4gICAgICAgIGlmICh1cGRhdGVBZ2VPbkdldCkge1xuICAgICAgICAgIHRoaXMudXBkYXRlSXRlbUFnZShpbmRleClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdlxuICAgICAgfVxuXG4gICAgICAvLyBvaywgaXQgaXMgc3RhbGUsIGFuZCBub3QgYWxyZWFkeSBmZXRjaGluZ1xuICAgICAgLy8gcmVmcmVzaCB0aGUgY2FjaGUuXG4gICAgICBjb25zdCBwID0gdGhpcy5iYWNrZ3JvdW5kRmV0Y2goaywgaW5kZXgsIG9wdGlvbnMpXG4gICAgICByZXR1cm4gYWxsb3dTdGFsZSAmJiBwLl9fc3RhbGVXaGlsZUZldGNoaW5nICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBwLl9fc3RhbGVXaGlsZUZldGNoaW5nIDogcFxuICAgIH1cbiAgfVxuXG4gIGdldCAoaywge1xuICAgIGFsbG93U3RhbGUgPSB0aGlzLmFsbG93U3RhbGUsXG4gICAgdXBkYXRlQWdlT25HZXQgPSB0aGlzLnVwZGF0ZUFnZU9uR2V0LFxuICB9ID0ge30pIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMua2V5TWFwLmdldChrKVxuICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMudmFsTGlzdFtpbmRleF1cbiAgICAgIGNvbnN0IGZldGNoaW5nID0gdGhpcy5pc0JhY2tncm91bmRGZXRjaCh2YWx1ZSlcbiAgICAgIGlmICh0aGlzLmlzU3RhbGUoaW5kZXgpKSB7XG4gICAgICAgIC8vIGRlbGV0ZSBvbmx5IGlmIG5vdCBhbiBpbi1mbGlnaHQgYmFja2dyb3VuZCBmZXRjaFxuICAgICAgICBpZiAoIWZldGNoaW5nKSB7XG4gICAgICAgICAgdGhpcy5kZWxldGUoaylcbiAgICAgICAgICByZXR1cm4gYWxsb3dTdGFsZSA/IHZhbHVlIDogdW5kZWZpbmVkXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGFsbG93U3RhbGUgPyB2YWx1ZS5fX3N0YWxlV2hpbGVGZXRjaGluZyA6IHVuZGVmaW5lZFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiB3ZSdyZSBjdXJyZW50bHkgZmV0Y2hpbmcgaXQsIHdlIGRvbid0IGFjdHVhbGx5IGhhdmUgaXQgeWV0XG4gICAgICAgIC8vIGl0J3Mgbm90IHN0YWxlLCB3aGljaCBtZWFucyB0aGlzIGlzbid0IGEgc3RhbGVXaGlsZVJlZmV0Y2hpbmcsXG4gICAgICAgIC8vIHNvIHdlIGp1c3QgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZiAoZmV0Y2hpbmcpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb3ZlVG9UYWlsKGluZGV4KVxuICAgICAgICBpZiAodXBkYXRlQWdlT25HZXQpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUl0ZW1BZ2UoaW5kZXgpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdCAocCwgbikge1xuICAgIHRoaXMucHJldltuXSA9IHBcbiAgICB0aGlzLm5leHRbcF0gPSBuXG4gIH1cblxuICBtb3ZlVG9UYWlsIChpbmRleCkge1xuICAgIC8vIGlmIHRhaWwgYWxyZWFkeSwgbm90aGluZyB0byBkb1xuICAgIC8vIGlmIGhlYWQsIG1vdmUgaGVhZCB0byBuZXh0W2luZGV4XVxuICAgIC8vIGVsc2VcbiAgICAvLyAgIG1vdmUgbmV4dFtwcmV2W2luZGV4XV0gdG8gbmV4dFtpbmRleF0gKGhlYWQgaGFzIG5vIHByZXYpXG4gICAgLy8gICBtb3ZlIHByZXZbbmV4dFtpbmRleF1dIHRvIHByZXZbaW5kZXhdXG4gICAgLy8gcHJldltpbmRleF0gPSB0YWlsXG4gICAgLy8gbmV4dFt0YWlsXSA9IGluZGV4XG4gICAgLy8gdGFpbCA9IGluZGV4XG4gICAgaWYgKGluZGV4ICE9PSB0aGlzLnRhaWwpIHtcbiAgICAgIGlmIChpbmRleCA9PT0gdGhpcy5oZWFkKSB7XG4gICAgICAgIHRoaXMuaGVhZCA9IHRoaXMubmV4dFtpbmRleF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29ubmVjdCh0aGlzLnByZXZbaW5kZXhdLCB0aGlzLm5leHRbaW5kZXhdKVxuICAgICAgfVxuICAgICAgdGhpcy5jb25uZWN0KHRoaXMudGFpbCwgaW5kZXgpXG4gICAgICB0aGlzLnRhaWwgPSBpbmRleFxuICAgIH1cbiAgfVxuXG4gIGdldCBkZWwgKCkge1xuICAgIGRlcHJlY2F0ZWRNZXRob2QoJ2RlbCcsICdkZWxldGUnKVxuICAgIHJldHVybiB0aGlzLmRlbGV0ZVxuICB9XG5cbiAgZGVsZXRlIChrKSB7XG4gICAgbGV0IGRlbGV0ZWQgPSBmYWxzZVxuICAgIGlmICh0aGlzLnNpemUgIT09IDApIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5rZXlNYXAuZ2V0KGspXG4gICAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWxldGVkID0gdHJ1ZVxuICAgICAgICBpZiAodGhpcy5zaXplID09PSAxKSB7XG4gICAgICAgICAgdGhpcy5jbGVhcigpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVJdGVtU2l6ZShpbmRleClcbiAgICAgICAgICBjb25zdCB2ID0gdGhpcy52YWxMaXN0W2luZGV4XVxuICAgICAgICAgIGlmICh0aGlzLmlzQmFja2dyb3VuZEZldGNoKHYpKSB7XG4gICAgICAgICAgICB2Ll9fYWJvcnRDb250cm9sbGVyLmFib3J0KClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlKHYsIGssICdkZWxldGUnKVxuICAgICAgICAgICAgaWYgKHRoaXMuZGlzcG9zZUFmdGVyKSB7XG4gICAgICAgICAgICAgIHRoaXMuZGlzcG9zZWQucHVzaChbdiwgaywgJ2RlbGV0ZSddKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmtleU1hcC5kZWxldGUoaylcbiAgICAgICAgICB0aGlzLmtleUxpc3RbaW5kZXhdID0gbnVsbFxuICAgICAgICAgIHRoaXMudmFsTGlzdFtpbmRleF0gPSBudWxsXG4gICAgICAgICAgaWYgKGluZGV4ID09PSB0aGlzLnRhaWwpIHtcbiAgICAgICAgICAgIHRoaXMudGFpbCA9IHRoaXMucHJldltpbmRleF1cbiAgICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID09PSB0aGlzLmhlYWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHRoaXMubmV4dFtpbmRleF1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5uZXh0W3RoaXMucHJldltpbmRleF1dID0gdGhpcy5uZXh0W2luZGV4XVxuICAgICAgICAgICAgdGhpcy5wcmV2W3RoaXMubmV4dFtpbmRleF1dID0gdGhpcy5wcmV2W2luZGV4XVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnNpemUgLS1cbiAgICAgICAgICB0aGlzLmZyZWUucHVzaChpbmRleClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5kaXNwb3NlZCkge1xuICAgICAgd2hpbGUgKHRoaXMuZGlzcG9zZWQubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuZGlzcG9zZUFmdGVyKC4uLnRoaXMuZGlzcG9zZWQuc2hpZnQoKSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlbGV0ZWRcbiAgfVxuXG4gIGNsZWFyICgpIHtcbiAgICBmb3IgKGNvbnN0IGluZGV4IG9mIHRoaXMucmluZGV4ZXMoeyBhbGxvd1N0YWxlOiB0cnVlIH0pKSB7XG4gICAgICBjb25zdCB2ID0gdGhpcy52YWxMaXN0W2luZGV4XVxuICAgICAgaWYgKHRoaXMuaXNCYWNrZ3JvdW5kRmV0Y2godikpIHtcbiAgICAgICAgdi5fX2Fib3J0Q29udHJvbGxlci5hYm9ydCgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBrID0gdGhpcy5rZXlMaXN0W2luZGV4XVxuICAgICAgICB0aGlzLmRpc3Bvc2UodiwgaywgJ2RlbGV0ZScpXG4gICAgICAgIGlmICh0aGlzLmRpc3Bvc2VBZnRlcikge1xuICAgICAgICAgIHRoaXMuZGlzcG9zZWQucHVzaChbdiwgaywgJ2RlbGV0ZSddKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5rZXlNYXAuY2xlYXIoKVxuICAgIHRoaXMudmFsTGlzdC5maWxsKG51bGwpXG4gICAgdGhpcy5rZXlMaXN0LmZpbGwobnVsbClcbiAgICBpZiAodGhpcy50dGxzKSB7XG4gICAgICB0aGlzLnR0bHMuZmlsbCgwKVxuICAgICAgdGhpcy5zdGFydHMuZmlsbCgwKVxuICAgIH1cbiAgICBpZiAodGhpcy5zaXplcykge1xuICAgICAgdGhpcy5zaXplcy5maWxsKDApXG4gICAgfVxuICAgIHRoaXMuaGVhZCA9IDBcbiAgICB0aGlzLnRhaWwgPSAwXG4gICAgdGhpcy5pbml0aWFsRmlsbCA9IDFcbiAgICB0aGlzLmZyZWUubGVuZ3RoID0gMFxuICAgIHRoaXMuY2FsY3VsYXRlZFNpemUgPSAwXG4gICAgdGhpcy5zaXplID0gMFxuICAgIGlmICh0aGlzLmRpc3Bvc2VkKSB7XG4gICAgICB3aGlsZSAodGhpcy5kaXNwb3NlZC5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5kaXNwb3NlQWZ0ZXIoLi4udGhpcy5kaXNwb3NlZC5zaGlmdCgpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldCByZXNldCAoKSB7XG4gICAgZGVwcmVjYXRlZE1ldGhvZCgncmVzZXQnLCAnY2xlYXInKVxuICAgIHJldHVybiB0aGlzLmNsZWFyXG4gIH1cblxuICBnZXQgbGVuZ3RoICgpIHtcbiAgICBkZXByZWNhdGVkUHJvcGVydHkoJ2xlbmd0aCcsICdzaXplJylcbiAgICByZXR1cm4gdGhpcy5zaXplXG4gIH1cblxuICBzdGF0aWMgZ2V0IEFib3J0Q29udHJvbGxlciAoKSB7XG4gICAgcmV0dXJuIEFDXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMUlVDYWNoZVxuIiwiaW1wb3J0IHsgTFJQYXJzZXIgfSBmcm9tICdAbGV6ZXIvbHInO1xuXG4vLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBsZXplci1nZW5lcmF0b3IuIFlvdSBwcm9iYWJseSBzaG91bGRuJ3QgZWRpdCBpdC5cbmNvbnN0IFxuICBpbmYgPSAxNDYsXG4gIG5hbiA9IDE0NyxcbiAgQm9vbCA9IDEsXG4gIElnbm9yaW5nID0gMixcbiAgT24gPSAzLFxuICBHcm91cExlZnQgPSA0LFxuICBHcm91cFJpZ2h0ID0gNSxcbiAgT2Zmc2V0ID0gNixcbiAgQXRhbjIgPSA3LFxuICBBdmcgPSA4LFxuICBCb3R0b21rID0gOSxcbiAgQ291bnQgPSAxMCxcbiAgQ291bnRWYWx1ZXMgPSAxMSxcbiAgR3JvdXAgPSAxMixcbiAgTWF4ID0gMTMsXG4gIE1pbiA9IDE0LFxuICBRdWFudGlsZSA9IDE1LFxuICBTdGRkZXYgPSAxNixcbiAgU3RkdmFyID0gMTcsXG4gIFN1bSA9IDE4LFxuICBUb3BrID0gMTksXG4gIEJ5ID0gMjAsXG4gIFdpdGhvdXQgPSAyMSxcbiAgQW5kID0gMjIsXG4gIE9yID0gMjMsXG4gIFVubGVzcyA9IDI0LFxuICBTdGFydCA9IDI1LFxuICBFbmQgPSAyNjtcblxuLy8gQ29weXJpZ2h0IDIwMjEgVGhlIFByb21ldGhldXMgQXV0aG9yc1xuXG5jb25zdCBrZXl3b3JkVG9rZW5zID0ge1xuICAgIGluZjogaW5mLFxuICAgIG5hbjogbmFuLFxuICAgIGJvb2w6IEJvb2wsXG4gICAgaWdub3Jpbmc6IElnbm9yaW5nLFxuICAgIG9uOiBPbixcbiAgICBncm91cF9sZWZ0OiBHcm91cExlZnQsXG4gICAgZ3JvdXBfcmlnaHQ6IEdyb3VwUmlnaHQsXG4gICAgb2Zmc2V0OiBPZmZzZXQsXG59O1xuXG5jb25zdCBzcGVjaWFsaXplSWRlbnRpZmllciA9ICh2YWx1ZSwgc3RhY2spID0+IHtcbiAgICByZXR1cm4ga2V5d29yZFRva2Vuc1t2YWx1ZS50b0xvd2VyQ2FzZSgpXSB8fCAtMTtcbn07XG5cbmNvbnN0IGNvbnRleHR1YWxLZXl3b3JkVG9rZW5zID0ge1xuICAgIGF2ZzogQXZnLFxuICAgIGF0YW4yOiBBdGFuMixcbiAgICBib3R0b21rOiBCb3R0b21rLFxuICAgIGNvdW50OiBDb3VudCxcbiAgICBjb3VudF92YWx1ZXM6IENvdW50VmFsdWVzLFxuICAgIGdyb3VwOiBHcm91cCxcbiAgICBtYXg6IE1heCxcbiAgICBtaW46IE1pbixcbiAgICBxdWFudGlsZTogUXVhbnRpbGUsXG4gICAgc3RkZGV2OiBTdGRkZXYsXG4gICAgc3RkdmFyOiBTdGR2YXIsXG4gICAgc3VtOiBTdW0sXG4gICAgdG9wazogVG9wayxcbiAgICBieTogQnksXG4gICAgd2l0aG91dDogV2l0aG91dCxcbiAgICBhbmQ6IEFuZCxcbiAgICBvcjogT3IsXG4gICAgdW5sZXNzOiBVbmxlc3MsXG4gICAgc3RhcnQ6IFN0YXJ0LFxuICAgIGVuZDogRW5kLFxufTtcblxuY29uc3QgZXh0ZW5kSWRlbnRpZmllciA9ICh2YWx1ZSwgc3RhY2spID0+IHtcbiAgICByZXR1cm4gY29udGV4dHVhbEtleXdvcmRUb2tlbnNbdmFsdWUudG9Mb3dlckNhc2UoKV0gfHwgLTE7XG59O1xuXG4vLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBsZXplci1nZW5lcmF0b3IuIFlvdSBwcm9iYWJseSBzaG91bGRuJ3QgZWRpdCBpdC5cbmNvbnN0IHNwZWNfSWRlbnRpZmllciA9IHtfX3Byb3RvX186bnVsbCxhYnNlbnRfb3Zlcl90aW1lOjMwNywgYWJzZW50OjMwOSwgYWJzOjMxMSwgYWNvczozMTMsIGFjb3NoOjMxNSwgYXNpbjozMTcsIGFzaW5oOjMxOSwgYXRhbjozMjEsIGF0YW5oOjMyMywgYXZnX292ZXJfdGltZTozMjUsIGNlaWw6MzI3LCBjaGFuZ2VzOjMyOSwgY2xhbXA6MzMxLCBjbGFtcF9tYXg6MzMzLCBjbGFtcF9taW46MzM1LCBjb3M6MzM3LCBjb3NoOjMzOSwgY291bnRfb3Zlcl90aW1lOjM0MSwgZGF5c19pbl9tb250aDozNDMsIGRheV9vZl9tb250aDozNDUsIGRheV9vZl93ZWVrOjM0NywgZGVnOjM0OSwgZGVsdGE6MzUxLCBkZXJpdjozNTMsIGV4cDozNTUsIGZsb29yOjM1NywgaGlzdG9ncmFtX3F1YW50aWxlOjM1OSwgaG9sdF93aW50ZXJzOjM2MSwgaG91cjozNjMsIGlkZWx0YTozNjUsIGluY3JlYXNlOjM2NywgaXJhdGU6MzY5LCBsYWJlbF9yZXBsYWNlOjM3MSwgbGFiZWxfam9pbjozNzMsIGxhc3Rfb3Zlcl90aW1lOjM3NSwgbG46Mzc3LCBsb2cxMDozNzksIGxvZzI6MzgxLCBtYXhfb3Zlcl90aW1lOjM4MywgbWluX292ZXJfdGltZTozODUsIG1pbnV0ZTozODcsIG1vbnRoOjM4OSwgcGk6MzkxLCBwcmVkaWN0X2xpbmVhcjozOTMsIHByZXNlbnRfb3Zlcl90aW1lOjM5NSwgcXVhbnRpbGVfb3Zlcl90aW1lOjM5NywgcmFkOjM5OSwgcmF0ZTo0MDEsIHJlc2V0czo0MDMsIHJvdW5kOjQwNSwgc2NhbGFyOjQwNywgc2duOjQwOSwgc2luOjQxMSwgc2luaDo0MTMsIHNvcnQ6NDE1LCBzb3J0X2Rlc2M6NDE3LCBzcXJ0OjQxOSwgc3RkZGV2X292ZXJfdGltZTo0MjEsIHN0ZHZhcl9vdmVyX3RpbWU6NDIzLCBzdW1fb3Zlcl90aW1lOjQyNSwgdGFuOjQyNywgdGFuaDo0MjksIHRpbWVzdGFtcDo0MzEsIHRpbWU6NDMzLCB2ZWN0b3I6NDM1LCB5ZWFyOjQzN307XG5jb25zdCBwYXJzZXIgPSBMUlBhcnNlci5kZXNlcmlhbGl6ZSh7XG4gIHZlcnNpb246IDEzLFxuICBzdGF0ZXM6IFwiNltPWVFQT09PJntRUE9PT09RTycjQ3snI0N7TydRUVBPJyNDelEnXVFRT09PT1FPJyNEZScjRGVPJ1dRUE8nI0RkT09RTycjRX0nI0V9TyhqUVBPJyNGVE9ZUVBPJyNGUE9ZUVBPJyNGU09PUU8nI0ZWJyNGVk8uZlFTTycjRldPLm5RUU8nI0ZVT09RTycjRlUnI0ZVT09RTycjQ3knI0N5T09RTycjRGYnI0RmT09RTycjRGgnI0RoT09RTycjRGknI0RpT09RTycjRGonI0RqT09RTycjRGsnI0RrT09RTycjRGwnI0RsT09RTycjRG0nI0RtT09RTycjRG4nI0RuT09RTycjRG8nI0RvT09RTycjRHAnI0RwT09RTycjRHEnI0RxT09RTycjRHInI0RyT09RTycjRHMnI0RzT09RTycjRHQnI0R0T09RTycjRHUnI0R1T09RTycjRHYnI0R2T09RTycjRHcnI0R3T09RTycjRHgnI0R4T09RTycjRHknI0R5T09RTycjRHonI0R6T09RTycjRHsnI0R7T09RTycjRHwnI0R8T09RTycjRH0nI0R9T09RTycjRU8nI0VPT09RTycjRVAnI0VQT09RTycjRVEnI0VRT09RTycjRVInI0VST09RTycjRVMnI0VTT09RTycjRVQnI0VUT09RTycjRVUnI0VVT09RTycjRVYnI0VWT09RTycjRVcnI0VXT09RTycjRVgnI0VYT09RTycjRVknI0VZT09RTycjRVonI0VaT09RTycjRVsnI0VbT09RTycjRV0nI0VdT09RTycjRV4nI0VeT09RTycjRV8nI0VfT09RTycjRWAnI0VgT09RTycjRWEnI0VhT09RTycjRWInI0ViT09RTycjRWMnI0VjT09RTycjRWQnI0VkT09RTycjRWUnI0VlT09RTycjRWYnI0VmT09RTycjRWcnI0VnT09RTycjRWgnI0VoT09RTycjRWknI0VpT09RTycjRWonI0VqT09RTycjRWsnI0VrT09RTycjRWwnI0VsT09RTycjRW0nI0VtT09RTycjRW4nI0VuT09RTycjRW8nI0VvT09RTycjRXAnI0VwT09RTycjRXEnI0VxT09RTycjRXInI0VyT09RTycjRXMnI0VzT09RTycjRXQnI0V0T09RTycjRXUnI0V1T09RTycjRXYnI0V2T09RTycjRXcnI0V3T09RTycjRXgnI0V4T09RTycjRXknI0V5T09RTycjRXonI0V6UU9RUE9PTzBYUVBPJyNDfE8wXlFQTycjRFJPJ1dRUE8sNTlmTzBlUVFPLDU5Zk8yUlFQTyw1OW9PMlJRUE8sNTlvTzJSUVBPLDU5b08yUlFQTyw1OW9PMlJRUE8sNTlvTzd9UVFPLDU7Z084U1FRTyw1O2pPOFtRUE8sNTt5T09RTyw1Ok8sNTpPT09RTyw1O2ksNTtpTzhzUVFPLDU7a084elFRTyw1O25POmJRUE8nI0ZZTzpwUVBPLDU7ck9PUU8nI0ZYJyNGWE9PUU8sNTtyLDU7ck9PUU8sNTtwLDU7cE86eFFTTycjQ31PT1FPLDU5aCw1OWhPO1FRUE8sNTltTztZUVFPJyNEU09PUU8sNTltLDU5bU9PUU8xRy9RMUcvUU8wWFFQTycjRFdPQVZRUE8nI0RWT0FhUVBPJyNEVk9ZUVBPMUcvWk9ZUVBPMUcvWk9ZUVBPMUcvWk9ZUVBPMUcvWk9ZUVBPMUcvWk9Ba1FTTzFHMVJPT1FPMUcxVTFHMVVPQXNRUU8xRzFVT0F4UVBPJyNFfU9PUU8nI0ZhJyNGYU9PUU8xRzFlMUcxZU9CVFFQTzFHMWVPT1FPMUcxVjFHMVZPT1FPJyNGWicjRlpPQllRUE8sNTt0T0JfUVNPMUcxXk9PUU8xRzFeMUcxXk9PUU8nI0RQJyNEUE9CZ1FQTyw1OWlPT1FPJyNETycjRE9PT1FPLDU5aSw1OWlPWVFQTyw1OW5PT1FPMUcvWDFHL1hPT1FPLDU5ciw1OXJPSF9RUE8sNTlxT0hmUVBPLDU5cU9JfVFRTzcrJHVPSl9RUU83KyR1T0tzUVFPNyskdU9MWlFRTzcrJHVPTXJRUU83KyR1T09RTzcrJm03KyZtT05dUVFPNysmc09PUU83KyZwNysmcE9OZVFQTzcrJ1BPT1FPMUcxYDFHMWBPT1FPMUcxXzFHMV9PT1FPNysmeDcrJnhPTmpRU08xRy9UT09RTzFHL1QxRy9UT05yUVFPMUcvWU9PUU8xRy9dMUcvXU9OfFFQTzFHL11PT1FPPDxKXzw8Sl9PISZvUVBPPDxKX09PUU88PEprPDxKa09PUU8xRy9VMUcvVU9PUU83KyRvNyskb09PUU83KyR3Nyskd09PUU9BTj95QU4/eVwiLFxuICBzdGF0ZURhdGE6IFwiISZ0fk8kWk9Ta09Tfk9XUU9YUU9ZUU9aUU9bUU9dUU9eUU9fUU9gUU9hUU9iUU9jUU8hWlpPI3RfTyRXVk8kWFZPJFtYTyRfYE8kYGFPJGFiTyRiY08kY2RPJGRlTyRlZk8kZmdPJGdoTyRoaU8kaWpPJGprTyRrbE8kbG1PJG1uTyRub08kb3BPJHBxTyRxck8kcnNPJHN0TyR0dU8kdXZPJHZ3TyR3eE8keHlPJHl6TyR6e08ke3xPJHx9TyR9IU9PJU8hUE8lUCFRTyVRIVJPJVIhU08lUyFUTyVUIVVPJVUhVk8lViFXTyVXIVhPJVghWU8lWSFaTyVaIVtPJVshXU8lXSFeTyVeIV9PJV8hYE8lYCFhTyVhIWJPJWIhY08lYyFkTyVkIWVPJWUhZk8lZiFnTyVnIWhPJWghaU8laSFqTyVqIWtPJWshbE8lbCFtTyVtIW5PJW4hb08lbyFwTyVwIXFPJXEhck8lciFzTyV1V08ldldPJXdWTyV5W09+TyFaWk9+T2QhdU9lIXVPJFshdk9+T1UjUE9WIXlPZiF8T2chfU9oIXxPeCF5T3sheU98IXlPfSF5TyFPIXpPIVAhek8hUSF7TyFSIXtPIVMhe08hVCF7TyFVIXtPIVYhe08kUyNRTyVzI09Pfk8kVyNTTyRYI1NPJXcjU09XI3dYWCN3WFkjd1haI3dYWyN3WF0jd1heI3dYXyN3WGAjd1hhI3dYYiN3WGMjd1ghWiN3WCN0I3dYJFcjd1gkWCN3WCRbI3dYJF8jd1gkYCN3WCRhI3dYJGIjd1gkYyN3WCRkI3dYJGUjd1gkZiN3WCRnI3dYJGgjd1gkaSN3WCRqI3dYJGsjd1gkbCN3WCRtI3dYJG4jd1gkbyN3WCRwI3dYJHEjd1gkciN3WCRzI3dYJHQjd1gkdSN3WCR2I3dYJHcjd1gkeCN3WCR5I3dYJHojd1gkeyN3WCR8I3dYJH0jd1glTyN3WCVQI3dYJVEjd1glUiN3WCVTI3dYJVQjd1glVSN3WCVWI3dYJVcjd1glWCN3WCVZI3dYJVojd1glWyN3WCVdI3dYJV4jd1glXyN3WCVgI3dYJWEjd1glYiN3WCVjI3dYJWQjd1glZSN3WCVmI3dYJWcjd1glaCN3WCVpI3dYJWojd1glayN3WCVsI3dYJW0jd1glbiN3WCVvI3dYJXAjd1glcSN3WCVyI3dYJXUjd1gldiN3WCV3I3dYJXkjd1h+T3QjVk8leiNZT35PJXlbT1UjeFhWI3hYZiN4WGcjeFhoI3hYeCN4WHsjeFh8I3hYfSN4WCFPI3hYIVAjeFghUSN4WCFSI3hYIVMjeFghVCN4WCFVI3hYIVYjeFgkUyN4WCRWI3hYJXMjeFgkXiN4WCRdI3hYfk8kWyNbT35PJF4jYE9+UFlPZCF1T2UhdU9VbmFWbmFmbmFnbmFobmF4bmF7bmF8bmF9bmEhT25hIVBuYSFRbmEhUm5hIVNuYSFUbmEhVW5hIVZuYSRTbmEkVm5hJXNuYSRebmEkXW5hfk9QI2RPUSNiT1IjYk9XeVBYeVBZeVBaeVBbeVBdeVBeeVBfeVBgeVBheVBieVBjeVAhWnlQI3R5UCRXeVAkWHlQJFt5UCRfeVAkYHlQJGF5UCRieVAkY3lQJGR5UCRleVAkZnlQJGd5UCRoeVAkaXlQJGp5UCRreVAkbHlQJG15UCRueVAkb3lQJHB5UCRxeVAkcnlQJHN5UCR0eVAkdXlQJHZ5UCR3eVAkeHlQJHl5UCR6eVAke3lQJHx5UCR9eVAlT3lQJVB5UCVReVAlUnlQJVN5UCVUeVAlVXlQJVZ5UCVXeVAlWHlQJVl5UCVaeVAlW3lQJV15UCVeeVAlX3lQJWB5UCVheVAlYnlQJWN5UCVkeVAlZXlQJWZ5UCVneVAlaHlQJWl5UCVqeVAla3lQJWx5UCVteVAlbnlQJW95UCVweVAlcXlQJXJ5UCV1eVAldnlQJXd5UCV5eVB+TyNwI2pPfk8hUCNsTyNwI2tPfk9pI25PaiNuTyRXVk8kWFZPJXUjbU8ldiNtTyV3Vk9+TyReI3FPflAnXU94IXlPVSN2YVYjdmFmI3ZhZyN2YWgjdmF7I3ZhfCN2YX0jdmEhTyN2YSFQI3ZhIVEjdmEhUiN2YSFTI3ZhIVQjdmEhVSN2YSFWI3ZhJFMjdmEkViN2YSVzI3ZhJF4jdmEkXSN2YX5PIVYjck8kTyNyTyRQI3JPJFEjck9+TyRdI3RPJXojdU9+T3Qjdk8kXiN5T35PJF0jek8kXiN7T35PJF12WCRedlh+UCddT1d5WFh5WFl5WFp5WFt5WF15WF55WF95WGB5WGF5WGJ5WGN5WCFaeVgjdHlYJFd5WCRYeVgkW3lYJF95WCRgeVgkYXlYJGJ5WCRjeVgkZHlYJGV5WCRmeVgkZ3lYJGh5WCRpeVgkanlYJGt5WCRseVgkbXlYJG55WCRveVgkcHlYJHF5WCRyeVgkc3lYJHR5WCR1eVgkdnlYJHd5WCR4eVgkeXlYJHp5WCR7eVgkfHlYJH15WCVPeVglUHlYJVF5WCVSeVglU3lYJVR5WCVVeVglVnlYJVd5WCVYeVglWXlYJVp5WCVbeVglXXlYJV55WCVfeVglYHlYJWF5WCVieVglY3lYJWR5WCVleVglZnlYJWd5WCVoeVglaXlYJWp5WCVreVglbHlYJW15WCVueVglb3lYJXB5WCVxeVglcnlYJXV5WCV2eVgld3lYJXl5WH5PUyN9T1QjfU9+UDtkT1EjYk9SI2JPflA7ZE8ldCRVTyV4JFZPfk8jcCRXT35PJFcjU08kWCNTTyV3I1NPfk8kWyRYT35PI3QkWU9+T3QjVk8leiRbT35PJF0kXU8kXiReT35PV3lhWHlhWXlhWnlhW3lhXXlhXnlhX3lhYHlhYXlhYnlhY3lhIVp5YSN0eWEkV3lhJFh5YSRfeWEkYHlhJGF5YSRieWEkY3lhJGR5YSRleWEkZnlhJGd5YSRoeWEkaXlhJGp5YSRreWEkbHlhJG15YSRueWEkb3lhJHB5YSRxeWEkcnlhJHN5YSR0eWEkdXlhJHZ5YSR3eWEkeHlhJHl5YSR6eWEke3lhJHx5YSR9eWElT3lhJVB5YSVReWElUnlhJVN5YSVUeWElVXlhJVZ5YSVXeWElWHlhJVl5YSVaeWElW3lhJV15YSVeeWElX3lhJWB5YSVheWElYnlhJWN5YSVkeWElZXlhJWZ5YSVneWElaHlhJWl5YSVqeWEla3lhJWx5YSVteWElbnlhJW95YSVweWElcXlhJXJ5YSV1eWEldnlhJXd5YSV5eWF+TyRbI1tPflBCb09TJGFPVCRhTyRbeWF+UEJvT3gheU9Vd3Fmd3Fnd3Fod3EhT3dxIVB3cSFRd3EhUndxIVN3cSFUd3EhVXdxIVZ3cSRTd3EkVndxJXN3cSRed3EkXXdxfk9Wd3F7d3F8d3F9d3F+UEhzT1YheU97IXlPfCF5T30heU9+UEhzT1YheU94IXlPeyF5T3wheU99IXlPIU8hek8hUCF6T1V3cWZ3cWd3cWh3cSRTd3EkVndxJXN3cSRed3EkXXdxfk8hUXdxIVJ3cSFTd3EhVHdxIVV3cSFWd3F+UEpvTyFRIXtPIVIhe08hUyF7TyFUIXtPIVUhe08hViF7T35QSm9PViF5T2YhfE9oIXxPeCF5T3sheU98IXlPfSF5TyFPIXpPIVAhek8hUSF7TyFSIXtPIVMhe08hVCF7TyFVIXtPIVYhe09+T1V3cWd3cSRTd3EkVndxJXN3cSRed3EkXXdxflBMcU8jcCRjTyV0JGJPfk8kXiRkT35PdCN2TyReJGZPfk8kXXZpJF52aX5QJ11PJFsjW09XeWlYeWlZeWlaeWlbeWldeWleeWlfeWlgeWlheWlieWljeWkhWnlpI3R5aSRXeWkkWHlpJF95aSRgeWkkYXlpJGJ5aSRjeWkkZHlpJGV5aSRmeWkkZ3lpJGh5aSRpeWkkanlpJGt5aSRseWkkbXlpJG55aSRveWkkcHlpJHF5aSRyeWkkc3lpJHR5aSR1eWkkdnlpJHd5aSR4eWkkeXlpJHp5aSR7eWkkfHlpJH15aSVPeWklUHlpJVF5aSVSeWklU3lpJVR5aSVVeWklVnlpJVd5aSVYeWklWXlpJVp5aSVbeWklXXlpJV55aSVfeWklYHlpJWF5aSVieWklY3lpJWR5aSVleWklZnlpJWd5aSVoeWklaXlpJWp5aSVreWklbHlpJW15aSVueWklb3lpJXB5aSVxeWklcnlpJXV5aSV2eWkld3lpJXl5aX5PJXQkaE9+T1wiLFxuICBnb3RvOiBcIih1JFVQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUCRWJHUlUiVfJWUlcSV0UCV6JlQkdVAmVyZnUFBQUFBQUFBQUFAkdSZxJn1QJn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSR1UCdaJHUkdVAkdSR1J2okdSd2KFYoZihpKG9QUFAkdVAoclFTT1EjVFhRI1VZUSNfIXZRJFAjZVEkUSNmUSRSI2dRJFMjaFEkVCNpUiRfI3plX09YWSF2I2UjZiNnI2gjaSN6ZVJPWFkhdiNlI2YjZyNoI2kjelEhd1JSI2EheFEjXSF1USN8I2JRJGAjfVIkZyRhUiN3I1tRI3gjW1IkZSRdUSF4UlEjUlVSI2Ehd1IjXiF2USNlIXlRI2YhelEjZyF7USNoIXxSI2khfVkjYyF5IXoheyF8IX1SJE8jZGVVT1hZIXYjZSNmI2cjaCNpI3plVE9YWSF2I2UjZiNnI2gjaSN6ZF9PWFkhdiNlI2YjZyNoI2kjelIjbyNRZVlPWFkhdiNlI2YjZyNoI2kjemRdT1hZIXYjZSNmI2cjaCNpI3pSIXRQZF5PWFkhdiNlI2YjZyNoI2kjelIjWl1SI1dbUSNYW1IkWiN0UiNzI1ZSI3AjUVwiLFxuICBub2RlTmFtZXM6IFwi4pqgIEJvb2wgSWdub3JpbmcgT24gR3JvdXBMZWZ0IEdyb3VwUmlnaHQgT2Zmc2V0IEF0YW4yIEF2ZyBCb3R0b21rIENvdW50IENvdW50VmFsdWVzIEdyb3VwIE1heCBNaW4gUXVhbnRpbGUgU3RkZGV2IFN0ZHZhciBTdW0gVG9wayBCeSBXaXRob3V0IEFuZCBPciBVbmxlc3MgU3RhcnQgRW5kIExpbmVDb21tZW50IFByb21RTCBFeHByIEFnZ3JlZ2F0ZUV4cHIgQWdncmVnYXRlT3AgQWdncmVnYXRlTW9kaWZpZXIgR3JvdXBpbmdMYWJlbHMgR3JvdXBpbmdMYWJlbExpc3QgR3JvdXBpbmdMYWJlbCBMYWJlbE5hbWUgRnVuY3Rpb25DYWxsQm9keSBGdW5jdGlvbkNhbGxBcmdzIEJpbmFyeUV4cHIgUG93IEJpbk1vZGlmaWVycyBPbk9ySWdub3JpbmcgTXVsIERpdiBNb2QgQWRkIFN1YiBFcWwgR3RlIEd0ciBMdGUgTHNzIE5lcSBGdW5jdGlvbkNhbGwgRnVuY3Rpb25JZGVudGlmaWVyIEFic2VudE92ZXJUaW1lIElkZW50aWZpZXIgQWJzZW50IEFicyBBY29zIEFjb3NoIEFzaW4gQXNpbmggQXRhbiBBdGFuaCBBdmdPdmVyVGltZSBDZWlsIENoYW5nZXMgQ2xhbXAgQ2xhbXBNYXggQ2xhbXBNaW4gQ29zIENvc2ggQ291bnRPdmVyVGltZSBEYXlzSW5Nb250aCBEYXlPZk1vbnRoIERheU9mV2VlayBEZWcgRGVsdGEgRGVyaXYgRXhwIEZsb29yIEhpc3RvZ3JhbVF1YW50aWxlIEhvbHRXaW50ZXJzIEhvdXIgSWRlbHRhIEluY3JlYXNlIElyYXRlIExhYmVsUmVwbGFjZSBMYWJlbEpvaW4gTGFzdE92ZXJUaW1lIExuIExvZzEwIExvZzIgTWF4T3ZlclRpbWUgTWluT3ZlclRpbWUgTWludXRlIE1vbnRoIFBpIFByZWRpY3RMaW5lYXIgUHJlc2VudE92ZXJUaW1lIFF1YW50aWxlT3ZlclRpbWUgUmFkIFJhdGUgUmVzZXRzIFJvdW5kIFNjYWxhciBTZ24gU2luIFNpbmggU29ydCBTb3J0RGVzYyBTcXJ0IFN0ZGRldk92ZXJUaW1lIFN0ZHZhck92ZXJUaW1lIFN1bU92ZXJUaW1lIFRhbiBUYW5oIFRpbWVzdGFtcCBUaW1lIFZlY3RvciBZZWFyIE1hdHJpeFNlbGVjdG9yIER1cmF0aW9uIE51bWJlckxpdGVyYWwgT2Zmc2V0RXhwciBQYXJlbkV4cHIgU3RyaW5nTGl0ZXJhbCBTdWJxdWVyeUV4cHIgVW5hcnlFeHByIFVuYXJ5T3AgVmVjdG9yU2VsZWN0b3IgTWV0cmljSWRlbnRpZmllciBMYWJlbE1hdGNoZXJzIExhYmVsTWF0Y2hMaXN0IExhYmVsTWF0Y2hlciBNYXRjaE9wIEVxbFNpbmdsZSBFcWxSZWdleCBOZXFSZWdleCBTdGVwSW52YXJpYW50RXhwciBBdCBBdE1vZGlmaWVyUHJlcHJvY2Vzc29ycyBNZXRyaWNOYW1lXCIsXG4gIG1heFRlcm06IDIyNixcbiAgc2tpcHBlZE5vZGVzOiBbMCwyN10sXG4gIHJlcGVhdE5vZGVDb3VudDogMCxcbiAgdG9rZW5EYXRhOiBcIjFSflJ3WF4jbHBxI2xxciRhcnMkdHN0JWh1diVzd3gleHh5Jmd5eiZsensmcXt8JnZ8fSZ9fSFPJ1MhTyFQJ1ohUCFRKFohUSFSKGAhUiFbKVchWyFdLXIhXiFfLm4hXyFgLnshYCFhL2IhYiFjL28hYyF9L3QhfSNPMFsjUCNRMGEjUSNSMGYjUiNTL3QjUyNUMGsjVCNvL3QjbyNwMHcjcSNyMHwjeSN6I2wkZiRnI2wjQlkjQlojbCRJUyRJXyNsJEl8JEpPI2wkSlQkSlUjbCRLViRLVyNsJkZVJkZWI2x+I3FZJFp+WF4jbHBxI2wjeSN6I2wkZiRnI2wjQlkjQlojbCRJUyRJXyNsJEl8JEpPI2wkSlQkSlUjbCRLViRLVyNsJkZVJkZWI2x+JGRRIV8hYCRqI3IjcyRvfiRvTyFWfn4kdE8kUX5+JHlVI3R+T1kkdFpyJHRycyVdcyNPJHQjTyNQJWIjUH4kdH4lYk8jdH5+JWVQT34kdH4lbVFrfk9ZJWhafiVofiV4T31+fiV9VSN0fk9ZJXhadyV4d3glXXgjTyV4I08jUCZhI1B+JXh+JmRQT34leH4mbE8kW35+JnFPJF5+fiZ2T3t+UiZ9TyV2UCFPUX4nU08kXX5SJ1pPJXVQIVBRUCdeUCFRIVsnYVAnZlIld1AhUSFbJ2EhZyFoJ28jWCNZJ29QJ3JSe3wne30hTyd7IVEhWyhSUChPUCFRIVsoUlAoV1Ald1AhUSFbKFJ+KGBPfH5SKGVaJXdQIU8hUCdhIVEhWylXIWchaCdvI1cjWCl7I1gjWSdvI1sjXSpkI2EjYip4I2cjaCtsI2sjbCt9I2wjbS1XI20jbixpUildWSV3UCFPIVAnYSFRIVspVyFnIWgnbyNXI1gpeyNYI1knbyNbI10qZCNhI2IqeCNnI2grbCNrI2wrfSNtI24saVEqUVAjcFEhUSFbKlRRKldTIVEhWypUI1sjXSpkI2EjYip4I2cjaCtsUSppUCNwUSFRIVsqbFEqb1IhUSFbKmwjYSNiKngjZyNoK2xRKn1RI3BRIVEhWytUI2cjaCtnUStXUiFRIVsrVCNhI2IrYSNnI2grbFErZFAjZyNoK2dRK2xPI3BRUStxUCNwUSFRIVsrdFErd1EhUSFbK3QjYSNiK2FRLFNQI3BRIVEhWyxWUSxZVCFRIVssViNXI1gpeyNbI10qZCNhI2IqeCNnI2grbFEsblAjcFEhUSFbLHFRLHRVIVEhWyxxI1cjWCl7I1sjXSpkI2EjYip4I2cjaCtsI2sjbCt9UC1aUiFRIVstZCFjIWktZCNUI1otZFAtaVIld1AhUSFbLWQhYyFpLWQjVCNaLWRWLXlUJXhTIVpSIVEhWy5ZIVshXS5ZIWMhfS5ZI1IjUy5ZI1Qjby5ZUi5fVCFaUiFRIVsuWSFbIV0uWSFjIX0uWSNSI1MuWSNUI28uWX4uc1AhVX4hXyFgLnZ+LntPIVR+fi9RUSRPUCFfIWAvVyNyI3MvXVEvXU8hUVF+L2JPJFB+fi9nUCFTfiFfIWAvan4vb08hUn5+L3RPJFN+Vi97VCFaUnRTIVEhWy90IVshXS5ZIWMhfS90I1IjUy90I1Qjby90fjBhTyVzfn4wZk8ldH5+MGtPeH5+MG5STyNTMGsjUyNUJV0jVH4wa34wfE8leX5+MVJPJXp+XCIsXG4gIHRva2VuaXplcnM6IFswLCAxLCAyXSxcbiAgdG9wUnVsZXM6IHtcIlByb21RTFwiOlswLDI4XSxcIk1ldHJpY05hbWVcIjpbMSwxNDRdfSxcbiAgc3BlY2lhbGl6ZWQ6IFt7dGVybTogNTcsIGdldDogKHZhbHVlLCBzdGFjaykgPT4gKHNwZWNpYWxpemVJZGVudGlmaWVyKHZhbHVlKSA8PCAxKX0se3Rlcm06IDU3LCBnZXQ6ICh2YWx1ZSwgc3RhY2spID0+IChleHRlbmRJZGVudGlmaWVyKHZhbHVlKSA8PCAxKSB8IDF9LHt0ZXJtOiA1NywgZ2V0OiB2YWx1ZSA9PiBzcGVjX0lkZW50aWZpZXJbdmFsdWVdIHx8IC0xfV0sXG4gIHRva2VuUHJlYzogMFxufSk7XG4vLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBsZXplci1nZW5lcmF0b3IuIFlvdSBwcm9iYWJseSBzaG91bGRuJ3QgZWRpdCBpdC5cbmNvbnN0IFxuICBpbmYkMSA9IDE0NixcbiAgbmFuJDEgPSAxNDcsXG4gIEJvb2wkMSA9IDEsXG4gIElnbm9yaW5nJDEgPSAyLFxuICBPbiQxID0gMyxcbiAgR3JvdXBMZWZ0JDEgPSA0LFxuICBHcm91cFJpZ2h0JDEgPSA1LFxuICBPZmZzZXQkMSA9IDYsXG4gIEF0YW4yJDEgPSA3LFxuICBBdmckMSA9IDgsXG4gIEJvdHRvbWskMSA9IDksXG4gIENvdW50JDEgPSAxMCxcbiAgQ291bnRWYWx1ZXMkMSA9IDExLFxuICBHcm91cCQxID0gMTIsXG4gIE1heCQxID0gMTMsXG4gIE1pbiQxID0gMTQsXG4gIFF1YW50aWxlJDEgPSAxNSxcbiAgU3RkZGV2JDEgPSAxNixcbiAgU3RkdmFyJDEgPSAxNyxcbiAgU3VtJDEgPSAxOCxcbiAgVG9wayQxID0gMTksXG4gIEJ5JDEgPSAyMCxcbiAgV2l0aG91dCQxID0gMjEsXG4gIEFuZCQxID0gMjIsXG4gIE9yJDEgPSAyMyxcbiAgVW5sZXNzJDEgPSAyNCxcbiAgU3RhcnQkMSA9IDI1LFxuICBFbmQkMSA9IDI2LFxuICBMaW5lQ29tbWVudCA9IDI3LFxuICBQcm9tUUwgPSAyOCxcbiAgRXhwciA9IDI5LFxuICBBZ2dyZWdhdGVFeHByID0gMzAsXG4gIEFnZ3JlZ2F0ZU9wID0gMzEsXG4gIEFnZ3JlZ2F0ZU1vZGlmaWVyID0gMzIsXG4gIEdyb3VwaW5nTGFiZWxzID0gMzMsXG4gIEdyb3VwaW5nTGFiZWxMaXN0ID0gMzQsXG4gIEdyb3VwaW5nTGFiZWwgPSAzNSxcbiAgTGFiZWxOYW1lID0gMzYsXG4gIEZ1bmN0aW9uQ2FsbEJvZHkgPSAzNyxcbiAgRnVuY3Rpb25DYWxsQXJncyA9IDM4LFxuICBCaW5hcnlFeHByID0gMzksXG4gIFBvdyA9IDQwLFxuICBCaW5Nb2RpZmllcnMgPSA0MSxcbiAgT25Pcklnbm9yaW5nID0gNDIsXG4gIE11bCA9IDQzLFxuICBEaXYgPSA0NCxcbiAgTW9kID0gNDUsXG4gIEFkZCA9IDQ2LFxuICBTdWIgPSA0NyxcbiAgRXFsID0gNDgsXG4gIEd0ZSA9IDQ5LFxuICBHdHIgPSA1MCxcbiAgTHRlID0gNTEsXG4gIExzcyA9IDUyLFxuICBOZXEgPSA1MyxcbiAgRnVuY3Rpb25DYWxsID0gNTQsXG4gIEZ1bmN0aW9uSWRlbnRpZmllciA9IDU1LFxuICBBYnNlbnRPdmVyVGltZSA9IDU2LFxuICBJZGVudGlmaWVyID0gNTcsXG4gIEFic2VudCA9IDU4LFxuICBBYnMgPSA1OSxcbiAgQWNvcyA9IDYwLFxuICBBY29zaCA9IDYxLFxuICBBc2luID0gNjIsXG4gIEFzaW5oID0gNjMsXG4gIEF0YW4gPSA2NCxcbiAgQXRhbmggPSA2NSxcbiAgQXZnT3ZlclRpbWUgPSA2NixcbiAgQ2VpbCA9IDY3LFxuICBDaGFuZ2VzID0gNjgsXG4gIENsYW1wID0gNjksXG4gIENsYW1wTWF4ID0gNzAsXG4gIENsYW1wTWluID0gNzEsXG4gIENvcyA9IDcyLFxuICBDb3NoID0gNzMsXG4gIENvdW50T3ZlclRpbWUgPSA3NCxcbiAgRGF5c0luTW9udGggPSA3NSxcbiAgRGF5T2ZNb250aCA9IDc2LFxuICBEYXlPZldlZWsgPSA3NyxcbiAgRGVnID0gNzgsXG4gIERlbHRhID0gNzksXG4gIERlcml2ID0gODAsXG4gIEV4cCA9IDgxLFxuICBGbG9vciA9IDgyLFxuICBIaXN0b2dyYW1RdWFudGlsZSA9IDgzLFxuICBIb2x0V2ludGVycyA9IDg0LFxuICBIb3VyID0gODUsXG4gIElkZWx0YSA9IDg2LFxuICBJbmNyZWFzZSA9IDg3LFxuICBJcmF0ZSA9IDg4LFxuICBMYWJlbFJlcGxhY2UgPSA4OSxcbiAgTGFiZWxKb2luID0gOTAsXG4gIExhc3RPdmVyVGltZSA9IDkxLFxuICBMbiA9IDkyLFxuICBMb2cxMCA9IDkzLFxuICBMb2cyID0gOTQsXG4gIE1heE92ZXJUaW1lID0gOTUsXG4gIE1pbk92ZXJUaW1lID0gOTYsXG4gIE1pbnV0ZSA9IDk3LFxuICBNb250aCA9IDk4LFxuICBQaSA9IDk5LFxuICBQcmVkaWN0TGluZWFyID0gMTAwLFxuICBQcmVzZW50T3ZlclRpbWUgPSAxMDEsXG4gIFF1YW50aWxlT3ZlclRpbWUgPSAxMDIsXG4gIFJhZCA9IDEwMyxcbiAgUmF0ZSA9IDEwNCxcbiAgUmVzZXRzID0gMTA1LFxuICBSb3VuZCA9IDEwNixcbiAgU2NhbGFyID0gMTA3LFxuICBTZ24gPSAxMDgsXG4gIFNpbiA9IDEwOSxcbiAgU2luaCA9IDExMCxcbiAgU29ydCA9IDExMSxcbiAgU29ydERlc2MgPSAxMTIsXG4gIFNxcnQgPSAxMTMsXG4gIFN0ZGRldk92ZXJUaW1lID0gMTE0LFxuICBTdGR2YXJPdmVyVGltZSA9IDExNSxcbiAgU3VtT3ZlclRpbWUgPSAxMTYsXG4gIFRhbiA9IDExNyxcbiAgVGFuaCA9IDExOCxcbiAgVGltZXN0YW1wID0gMTE5LFxuICBUaW1lID0gMTIwLFxuICBWZWN0b3IgPSAxMjEsXG4gIFllYXIgPSAxMjIsXG4gIE1hdHJpeFNlbGVjdG9yID0gMTIzLFxuICBEdXJhdGlvbiA9IDEyNCxcbiAgTnVtYmVyTGl0ZXJhbCA9IDEyNSxcbiAgT2Zmc2V0RXhwciA9IDEyNixcbiAgUGFyZW5FeHByID0gMTI3LFxuICBTdHJpbmdMaXRlcmFsID0gMTI4LFxuICBTdWJxdWVyeUV4cHIgPSAxMjksXG4gIFVuYXJ5RXhwciA9IDEzMCxcbiAgVW5hcnlPcCA9IDEzMSxcbiAgVmVjdG9yU2VsZWN0b3IgPSAxMzIsXG4gIE1ldHJpY0lkZW50aWZpZXIgPSAxMzMsXG4gIExhYmVsTWF0Y2hlcnMgPSAxMzQsXG4gIExhYmVsTWF0Y2hMaXN0ID0gMTM1LFxuICBMYWJlbE1hdGNoZXIgPSAxMzYsXG4gIE1hdGNoT3AgPSAxMzcsXG4gIEVxbFNpbmdsZSA9IDEzOCxcbiAgRXFsUmVnZXggPSAxMzksXG4gIE5lcVJlZ2V4ID0gMTQwLFxuICBTdGVwSW52YXJpYW50RXhwciA9IDE0MSxcbiAgQXQgPSAxNDIsXG4gIEF0TW9kaWZpZXJQcmVwcm9jZXNzb3JzID0gMTQzLFxuICBNZXRyaWNOYW1lID0gMTQ0O1xuXG5leHBvcnQgeyBBYnMsIEFic2VudCwgQWJzZW50T3ZlclRpbWUsIEFjb3MsIEFjb3NoLCBBZGQsIEFnZ3JlZ2F0ZUV4cHIsIEFnZ3JlZ2F0ZU1vZGlmaWVyLCBBZ2dyZWdhdGVPcCwgQW5kJDEgYXMgQW5kLCBBc2luLCBBc2luaCwgQXQsIEF0TW9kaWZpZXJQcmVwcm9jZXNzb3JzLCBBdGFuLCBBdGFuMiQxIGFzIEF0YW4yLCBBdGFuaCwgQXZnJDEgYXMgQXZnLCBBdmdPdmVyVGltZSwgQmluTW9kaWZpZXJzLCBCaW5hcnlFeHByLCBCb29sJDEgYXMgQm9vbCwgQm90dG9tayQxIGFzIEJvdHRvbWssIEJ5JDEgYXMgQnksIENlaWwsIENoYW5nZXMsIENsYW1wLCBDbGFtcE1heCwgQ2xhbXBNaW4sIENvcywgQ29zaCwgQ291bnQkMSBhcyBDb3VudCwgQ291bnRPdmVyVGltZSwgQ291bnRWYWx1ZXMkMSBhcyBDb3VudFZhbHVlcywgRGF5T2ZNb250aCwgRGF5T2ZXZWVrLCBEYXlzSW5Nb250aCwgRGVnLCBEZWx0YSwgRGVyaXYsIERpdiwgRHVyYXRpb24sIEVuZCQxIGFzIEVuZCwgRXFsLCBFcWxSZWdleCwgRXFsU2luZ2xlLCBFeHAsIEV4cHIsIEZsb29yLCBGdW5jdGlvbkNhbGwsIEZ1bmN0aW9uQ2FsbEFyZ3MsIEZ1bmN0aW9uQ2FsbEJvZHksIEZ1bmN0aW9uSWRlbnRpZmllciwgR3JvdXAkMSBhcyBHcm91cCwgR3JvdXBMZWZ0JDEgYXMgR3JvdXBMZWZ0LCBHcm91cFJpZ2h0JDEgYXMgR3JvdXBSaWdodCwgR3JvdXBpbmdMYWJlbCwgR3JvdXBpbmdMYWJlbExpc3QsIEdyb3VwaW5nTGFiZWxzLCBHdGUsIEd0ciwgSGlzdG9ncmFtUXVhbnRpbGUsIEhvbHRXaW50ZXJzLCBIb3VyLCBJZGVsdGEsIElkZW50aWZpZXIsIElnbm9yaW5nJDEgYXMgSWdub3JpbmcsIEluY3JlYXNlLCBJcmF0ZSwgTGFiZWxKb2luLCBMYWJlbE1hdGNoTGlzdCwgTGFiZWxNYXRjaGVyLCBMYWJlbE1hdGNoZXJzLCBMYWJlbE5hbWUsIExhYmVsUmVwbGFjZSwgTGFzdE92ZXJUaW1lLCBMaW5lQ29tbWVudCwgTG4sIExvZzEwLCBMb2cyLCBMc3MsIEx0ZSwgTWF0Y2hPcCwgTWF0cml4U2VsZWN0b3IsIE1heCQxIGFzIE1heCwgTWF4T3ZlclRpbWUsIE1ldHJpY0lkZW50aWZpZXIsIE1ldHJpY05hbWUsIE1pbiQxIGFzIE1pbiwgTWluT3ZlclRpbWUsIE1pbnV0ZSwgTW9kLCBNb250aCwgTXVsLCBOZXEsIE5lcVJlZ2V4LCBOdW1iZXJMaXRlcmFsLCBPZmZzZXQkMSBhcyBPZmZzZXQsIE9mZnNldEV4cHIsIE9uJDEgYXMgT24sIE9uT3JJZ25vcmluZywgT3IkMSBhcyBPciwgUGFyZW5FeHByLCBQaSwgUG93LCBQcmVkaWN0TGluZWFyLCBQcmVzZW50T3ZlclRpbWUsIFByb21RTCwgUXVhbnRpbGUkMSBhcyBRdWFudGlsZSwgUXVhbnRpbGVPdmVyVGltZSwgUmFkLCBSYXRlLCBSZXNldHMsIFJvdW5kLCBTY2FsYXIsIFNnbiwgU2luLCBTaW5oLCBTb3J0LCBTb3J0RGVzYywgU3FydCwgU3RhcnQkMSBhcyBTdGFydCwgU3RkZGV2JDEgYXMgU3RkZGV2LCBTdGRkZXZPdmVyVGltZSwgU3RkdmFyJDEgYXMgU3RkdmFyLCBTdGR2YXJPdmVyVGltZSwgU3RlcEludmFyaWFudEV4cHIsIFN0cmluZ0xpdGVyYWwsIFN1YiwgU3VicXVlcnlFeHByLCBTdW0kMSBhcyBTdW0sIFN1bU92ZXJUaW1lLCBUYW4sIFRhbmgsIFRpbWUsIFRpbWVzdGFtcCwgVG9wayQxIGFzIFRvcGssIFVuYXJ5RXhwciwgVW5hcnlPcCwgVW5sZXNzJDEgYXMgVW5sZXNzLCBWZWN0b3IsIFZlY3RvclNlbGVjdG9yLCBXaXRob3V0JDEgYXMgV2l0aG91dCwgWWVhciwgaW5mJDEgYXMgaW5mLCBuYW4kMSBhcyBuYW4sIHBhcnNlciB9O1xuIiwiLy8gRklYTUUgcHJvZmlsZSBhZGRpbmcgYSBwZXItVHJlZSBUcmVlTm9kZSBjYWNoZSwgdmFsaWRhdGluZyBpdCBieVxuLy8gcGFyZW50IHBvaW50ZXJcbi8vLyBUaGUgZGVmYXVsdCBtYXhpbXVtIGxlbmd0aCBvZiBhIGBUcmVlQnVmZmVyYCBub2RlICgxMDI0KS5cbmNvbnN0IERlZmF1bHRCdWZmZXJMZW5ndGggPSAxMDI0O1xubGV0IG5leHRQcm9wSUQgPSAwO1xuY2xhc3MgUmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG59XG4vLy8gRWFjaCBbbm9kZSB0eXBlXSgjY29tbW9uLk5vZGVUeXBlKSBvciBbaW5kaXZpZHVhbCB0cmVlXSgjY29tbW9uLlRyZWUpXG4vLy8gY2FuIGhhdmUgbWV0YWRhdGEgYXNzb2NpYXRlZCB3aXRoIGl0IGluIHByb3BzLiBJbnN0YW5jZXMgb2YgdGhpc1xuLy8vIGNsYXNzIHJlcHJlc2VudCBwcm9wIG5hbWVzLlxuY2xhc3MgTm9kZVByb3Age1xuICAgIC8vLyBDcmVhdGUgYSBuZXcgbm9kZSBwcm9wIHR5cGUuXG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgdGhpcy5pZCA9IG5leHRQcm9wSUQrKztcbiAgICAgICAgdGhpcy5wZXJOb2RlID0gISFjb25maWcucGVyTm9kZTtcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZSA9IGNvbmZpZy5kZXNlcmlhbGl6ZSB8fCAoKCkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBub2RlIHR5cGUgZG9lc24ndCBkZWZpbmUgYSBkZXNlcmlhbGl6ZSBmdW5jdGlvblwiKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vLyBUaGlzIGlzIG1lYW50IHRvIGJlIHVzZWQgd2l0aFxuICAgIC8vLyBbYE5vZGVTZXQuZXh0ZW5kYF0oI2NvbW1vbi5Ob2RlU2V0LmV4dGVuZCkgb3JcbiAgICAvLy8gW2BMUlBhcnNlci5jb25maWd1cmVgXSgjbHIuUGFyc2VyQ29uZmlnLnByb3BzKSB0byBjb21wdXRlXG4gICAgLy8vIHByb3AgdmFsdWVzIGZvciBlYWNoIG5vZGUgdHlwZSBpbiB0aGUgc2V0LiBUYWtlcyBhIFttYXRjaFxuICAgIC8vLyBvYmplY3RdKCNjb21tb24uTm9kZVR5cGVebWF0Y2gpIG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB1bmRlZmluZWRcbiAgICAvLy8gaWYgdGhlIG5vZGUgdHlwZSBkb2Vzbid0IGdldCB0aGlzIHByb3AsIGFuZCB0aGUgcHJvcCdzIHZhbHVlIGlmXG4gICAgLy8vIGl0IGRvZXMuXG4gICAgYWRkKG1hdGNoKSB7XG4gICAgICAgIGlmICh0aGlzLnBlck5vZGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNhbid0IGFkZCBwZXItbm9kZSBwcm9wcyB0byBub2RlIHR5cGVzXCIpO1xuICAgICAgICBpZiAodHlwZW9mIG1hdGNoICE9IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIG1hdGNoID0gTm9kZVR5cGUubWF0Y2gobWF0Y2gpO1xuICAgICAgICByZXR1cm4gKHR5cGUpID0+IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBtYXRjaCh0eXBlKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBbdGhpcywgcmVzdWx0XTtcbiAgICAgICAgfTtcbiAgICB9XG59XG4vLy8gUHJvcCB0aGF0IGlzIHVzZWQgdG8gZGVzY3JpYmUgbWF0Y2hpbmcgZGVsaW1pdGVycy4gRm9yIG9wZW5pbmdcbi8vLyBkZWxpbWl0ZXJzLCB0aGlzIGhvbGRzIGFuIGFycmF5IG9mIG5vZGUgbmFtZXMgKHdyaXR0ZW4gYXMgYVxuLy8vIHNwYWNlLXNlcGFyYXRlZCBzdHJpbmcgd2hlbiBkZWNsYXJpbmcgdGhpcyBwcm9wIGluIGEgZ3JhbW1hcilcbi8vLyBmb3IgdGhlIG5vZGUgdHlwZXMgb2YgY2xvc2luZyBkZWxpbWl0ZXJzIHRoYXQgbWF0Y2ggaXQuXG5Ob2RlUHJvcC5jbG9zZWRCeSA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8vLyBUaGUgaW52ZXJzZSBvZiBbYGNsb3NlZEJ5YF0oI2NvbW1vbi5Ob2RlUHJvcF5jbG9zZWRCeSkuIFRoaXMgaXNcbi8vLyBhdHRhY2hlZCB0byBjbG9zaW5nIGRlbGltaXRlcnMsIGhvbGRpbmcgYW4gYXJyYXkgb2Ygbm9kZSBuYW1lc1xuLy8vIG9mIHR5cGVzIG9mIG1hdGNoaW5nIG9wZW5pbmcgZGVsaW1pdGVycy5cbk5vZGVQcm9wLm9wZW5lZEJ5ID0gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6IHN0ciA9PiBzdHIuc3BsaXQoXCIgXCIpIH0pO1xuLy8vIFVzZWQgdG8gYXNzaWduIG5vZGUgdHlwZXMgdG8gZ3JvdXBzIChmb3IgZXhhbXBsZSwgYWxsIG5vZGVcbi8vLyB0eXBlcyB0aGF0IHJlcHJlc2VudCBhbiBleHByZXNzaW9uIGNvdWxkIGJlIHRhZ2dlZCB3aXRoIGFuXG4vLy8gYFwiRXhwcmVzc2lvblwiYCBncm91cCkuXG5Ob2RlUHJvcC5ncm91cCA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8vLyBUaGUgaGFzaCBvZiB0aGUgW2NvbnRleHRdKCNsci5Db250ZXh0VHJhY2tlci5jb25zdHJ1Y3Rvcilcbi8vLyB0aGF0IHRoZSBub2RlIHdhcyBwYXJzZWQgaW4sIGlmIGFueS4gVXNlZCB0byBsaW1pdCByZXVzZSBvZlxuLy8vIGNvbnRleHR1YWwgbm9kZXMuXG5Ob2RlUHJvcC5jb250ZXh0SGFzaCA9IG5ldyBOb2RlUHJvcCh7IHBlck5vZGU6IHRydWUgfSk7XG4vLy8gVGhlIGRpc3RhbmNlIGJleW9uZCB0aGUgZW5kIG9mIHRoZSBub2RlIHRoYXQgdGhlIHRva2VuaXplclxuLy8vIGxvb2tlZCBhaGVhZCBmb3IgYW55IG9mIHRoZSB0b2tlbnMgaW5zaWRlIHRoZSBub2RlLiAoVGhlIExSXG4vLy8gcGFyc2VyIG9ubHkgc3RvcmVzIHRoaXMgd2hlbiBpdCBpcyBsYXJnZXIgdGhhbiAyNSwgZm9yXG4vLy8gZWZmaWNpZW5jeSByZWFzb25zLilcbk5vZGVQcm9wLmxvb2tBaGVhZCA9IG5ldyBOb2RlUHJvcCh7IHBlck5vZGU6IHRydWUgfSk7XG4vLy8gVGhpcyBwZXItbm9kZSBwcm9wIGlzIHVzZWQgdG8gcmVwbGFjZSBhIGdpdmVuIG5vZGUsIG9yIHBhcnQgb2YgYVxuLy8vIG5vZGUsIHdpdGggYW5vdGhlciB0cmVlLiBUaGlzIGlzIHVzZWZ1bCB0byBpbmNsdWRlIHRyZWVzIGZyb21cbi8vLyBkaWZmZXJlbnQgbGFuZ3VhZ2VzLlxuTm9kZVByb3AubW91bnRlZCA9IG5ldyBOb2RlUHJvcCh7IHBlck5vZGU6IHRydWUgfSk7XG4vLy8gQSBtb3VudGVkIHRyZWUsIHdoaWNoIGNhbiBiZSBbc3RvcmVkXSgjY29tbW9uLk5vZGVQcm9wXm1vdW50ZWQpIG9uXG4vLy8gYSB0cmVlIG5vZGUgdG8gaW5kaWNhdGUgdGhhdCBwYXJ0cyBvZiBpdHMgY29udGVudCBhcmVcbi8vLyByZXByZXNlbnRlZCBieSBhbm90aGVyIHRyZWUuXG5jbGFzcyBNb3VudGVkVHJlZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIFRoZSBpbm5lciB0cmVlLlxuICAgIHRyZWUsIFxuICAgIC8vLyBJZiB0aGlzIGlzIG51bGwsIHRoaXMgdHJlZSByZXBsYWNlcyB0aGUgZW50aXJlIG5vZGUgKGl0IHdpbGxcbiAgICAvLy8gYmUgaW5jbHVkZWQgaW4gdGhlIHJlZ3VsYXIgaXRlcmF0aW9uIGluc3RlYWQgb2YgaXRzIGhvc3RcbiAgICAvLy8gbm9kZSkuIElmIG5vdCwgb25seSB0aGUgZ2l2ZW4gcmFuZ2VzIGFyZSBjb25zaWRlcmVkIHRvIGJlXG4gICAgLy8vIGNvdmVyZWQgYnkgdGhpcyB0cmVlLiBUaGlzIGlzIHVzZWQgZm9yIHRyZWVzIHRoYXQgYXJlIG1peGVkIGluXG4gICAgLy8vIGEgd2F5IHRoYXQgaXNuJ3Qgc3RyaWN0bHkgaGllcmFyY2hpY2FsLiBTdWNoIG1vdW50ZWQgdHJlZXMgYXJlXG4gICAgLy8vIG9ubHkgZW50ZXJlZCBieSBbYHJlc29sdmVJbm5lcmBdKCNjb21tb24uVHJlZS5yZXNvbHZlSW5uZXIpXG4gICAgLy8vIGFuZCBbYGVudGVyYF0oI2NvbW1vbi5TeW50YXhOb2RlLmVudGVyKS5cbiAgICBvdmVybGF5LCBcbiAgICAvLy8gVGhlIHBhcnNlciB1c2VkIHRvIGNyZWF0ZSB0aGlzIHN1YnRyZWUuXG4gICAgcGFyc2VyKSB7XG4gICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XG4gICAgICAgIHRoaXMub3ZlcmxheSA9IG92ZXJsYXk7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIH1cbn1cbmNvbnN0IG5vUHJvcHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLy8vIEVhY2ggbm9kZSBpbiBhIHN5bnRheCB0cmVlIGhhcyBhIG5vZGUgdHlwZSBhc3NvY2lhdGVkIHdpdGggaXQuXG5jbGFzcyBOb2RlVHlwZSB7XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBUaGUgbmFtZSBvZiB0aGUgbm9kZSB0eXBlLiBOb3QgbmVjZXNzYXJpbHkgdW5pcXVlLCBidXQgaWYgdGhlXG4gICAgLy8vIGdyYW1tYXIgd2FzIHdyaXR0ZW4gcHJvcGVybHksIGRpZmZlcmVudCBub2RlIHR5cGVzIHdpdGggdGhlXG4gICAgLy8vIHNhbWUgbmFtZSB3aXRoaW4gYSBub2RlIHNldCBzaG91bGQgcGxheSB0aGUgc2FtZSBzZW1hbnRpY1xuICAgIC8vLyByb2xlLlxuICAgIG5hbWUsIFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBwcm9wcywgXG4gICAgLy8vIFRoZSBpZCBvZiB0aGlzIG5vZGUgaW4gaXRzIHNldC4gQ29ycmVzcG9uZHMgdG8gdGhlIHRlcm0gaWRzXG4gICAgLy8vIHVzZWQgaW4gdGhlIHBhcnNlci5cbiAgICBpZCwgXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGZsYWdzID0gMCkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgIH1cbiAgICBzdGF0aWMgZGVmaW5lKHNwZWMpIHtcbiAgICAgICAgbGV0IHByb3BzID0gc3BlYy5wcm9wcyAmJiBzcGVjLnByb3BzLmxlbmd0aCA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiBub1Byb3BzO1xuICAgICAgICBsZXQgZmxhZ3MgPSAoc3BlYy50b3AgPyAxIC8qIFRvcCAqLyA6IDApIHwgKHNwZWMuc2tpcHBlZCA/IDIgLyogU2tpcHBlZCAqLyA6IDApIHxcbiAgICAgICAgICAgIChzcGVjLmVycm9yID8gNCAvKiBFcnJvciAqLyA6IDApIHwgKHNwZWMubmFtZSA9PSBudWxsID8gOCAvKiBBbm9ueW1vdXMgKi8gOiAwKTtcbiAgICAgICAgbGV0IHR5cGUgPSBuZXcgTm9kZVR5cGUoc3BlYy5uYW1lIHx8IFwiXCIsIHByb3BzLCBzcGVjLmlkLCBmbGFncyk7XG4gICAgICAgIGlmIChzcGVjLnByb3BzKVxuICAgICAgICAgICAgZm9yIChsZXQgc3JjIG9mIHNwZWMucHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3JjKSlcbiAgICAgICAgICAgICAgICAgICAgc3JjID0gc3JjKHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNyY1swXS5wZXJOb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4ndCBzdG9yZSBhIHBlci1ub2RlIHByb3Agb24gYSBub2RlIHR5cGVcIik7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzW3NyY1swXS5pZF0gPSBzcmNbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgLy8vIFJldHJpZXZlcyBhIG5vZGUgcHJvcCBmb3IgdGhpcyB0eXBlLiBXaWxsIHJldHVybiBgdW5kZWZpbmVkYCBpZlxuICAgIC8vLyB0aGUgcHJvcCBpc24ndCBwcmVzZW50IG9uIHRoaXMgbm9kZS5cbiAgICBwcm9wKHByb3ApIHsgcmV0dXJuIHRoaXMucHJvcHNbcHJvcC5pZF07IH1cbiAgICAvLy8gVHJ1ZSB3aGVuIHRoaXMgaXMgdGhlIHRvcCBub2RlIG9mIGEgZ3JhbW1hci5cbiAgICBnZXQgaXNUb3AoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDEgLyogVG9wICovKSA+IDA7IH1cbiAgICAvLy8gVHJ1ZSB3aGVuIHRoaXMgbm9kZSBpcyBwcm9kdWNlZCBieSBhIHNraXAgcnVsZS5cbiAgICBnZXQgaXNTa2lwcGVkKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiAyIC8qIFNraXBwZWQgKi8pID4gMDsgfVxuICAgIC8vLyBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIGlzIGFuIGVycm9yIG5vZGUuXG4gICAgZ2V0IGlzRXJyb3IoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDQgLyogRXJyb3IgKi8pID4gMDsgfVxuICAgIC8vLyBXaGVuIHRydWUsIHRoaXMgbm9kZSB0eXBlIGRvZXNuJ3QgY29ycmVzcG9uZCB0byBhIHVzZXItZGVjbGFyZWRcbiAgICAvLy8gbmFtZWQgbm9kZSwgZm9yIGV4YW1wbGUgYmVjYXVzZSBpdCBpcyB1c2VkIHRvIGNhY2hlIHJlcGV0aXRpb24uXG4gICAgZ2V0IGlzQW5vbnltb3VzKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiA4IC8qIEFub255bW91cyAqLykgPiAwOyB9XG4gICAgLy8vIFJldHVybnMgdHJ1ZSB3aGVuIHRoaXMgbm9kZSdzIG5hbWUgb3Igb25lIG9mIGl0c1xuICAgIC8vLyBbZ3JvdXBzXSgjY29tbW9uLk5vZGVQcm9wXmdyb3VwKSBtYXRjaGVzIHRoZSBnaXZlbiBzdHJpbmcuXG4gICAgaXMobmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5hbWUgPT0gbmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBncm91cCA9IHRoaXMucHJvcChOb2RlUHJvcC5ncm91cCk7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXAgPyBncm91cC5pbmRleE9mKG5hbWUpID4gLTEgOiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pZCA9PSBuYW1lO1xuICAgIH1cbiAgICAvLy8gQ3JlYXRlIGEgZnVuY3Rpb24gZnJvbSBub2RlIHR5cGVzIHRvIGFyYml0cmFyeSB2YWx1ZXMgYnlcbiAgICAvLy8gc3BlY2lmeWluZyBhbiBvYmplY3Qgd2hvc2UgcHJvcGVydHkgbmFtZXMgYXJlIG5vZGUgb3JcbiAgICAvLy8gW2dyb3VwXSgjY29tbW9uLk5vZGVQcm9wXmdyb3VwKSBuYW1lcy4gT2Z0ZW4gdXNlZnVsIHdpdGhcbiAgICAvLy8gW2BOb2RlUHJvcC5hZGRgXSgjY29tbW9uLk5vZGVQcm9wLmFkZCkuIFlvdSBjYW4gcHV0IG11bHRpcGxlXG4gICAgLy8vIG5hbWVzLCBzZXBhcmF0ZWQgYnkgc3BhY2VzLCBpbiBhIHNpbmdsZSBwcm9wZXJ0eSBuYW1lIHRvIG1hcFxuICAgIC8vLyBtdWx0aXBsZSBub2RlIG5hbWVzIHRvIGEgc2luZ2xlIHZhbHVlLlxuICAgIHN0YXRpYyBtYXRjaChtYXApIHtcbiAgICAgICAgbGV0IGRpcmVjdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gbWFwKVxuICAgICAgICAgICAgZm9yIChsZXQgbmFtZSBvZiBwcm9wLnNwbGl0KFwiIFwiKSlcbiAgICAgICAgICAgICAgICBkaXJlY3RbbmFtZV0gPSBtYXBbcHJvcF07XG4gICAgICAgIHJldHVybiAobm9kZSkgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgZ3JvdXBzID0gbm9kZS5wcm9wKE5vZGVQcm9wLmdyb3VwKSwgaSA9IC0xOyBpIDwgKGdyb3VwcyA/IGdyb3Vwcy5sZW5ndGggOiAwKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gZGlyZWN0W2kgPCAwID8gbm9kZS5uYW1lIDogZ3JvdXBzW2ldXTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG4vLy8gQW4gZW1wdHkgZHVtbXkgbm9kZSB0eXBlIHRvIHVzZSB3aGVuIG5vIGFjdHVhbCB0eXBlIGlzIGF2YWlsYWJsZS5cbk5vZGVUeXBlLm5vbmUgPSBuZXcgTm9kZVR5cGUoXCJcIiwgT2JqZWN0LmNyZWF0ZShudWxsKSwgMCwgOCAvKiBBbm9ueW1vdXMgKi8pO1xuLy8vIEEgbm9kZSBzZXQgaG9sZHMgYSBjb2xsZWN0aW9uIG9mIG5vZGUgdHlwZXMuIEl0IGlzIHVzZWQgdG9cbi8vLyBjb21wYWN0bHkgcmVwcmVzZW50IHRyZWVzIGJ5IHN0b3JpbmcgdGhlaXIgdHlwZSBpZHMsIHJhdGhlciB0aGFuIGFcbi8vLyBmdWxsIHBvaW50ZXIgdG8gdGhlIHR5cGUgb2JqZWN0LCBpbiBhIG51bWVyaWMgYXJyYXkuIEVhY2ggcGFyc2VyXG4vLy8gW2hhc10oI2xyLkxSUGFyc2VyLm5vZGVTZXQpIGEgbm9kZSBzZXQsIGFuZCBbdHJlZVxuLy8vIGJ1ZmZlcnNdKCNjb21tb24uVHJlZUJ1ZmZlcikgY2FuIG9ubHkgc3RvcmUgY29sbGVjdGlvbnMgb2Ygbm9kZXNcbi8vLyBmcm9tIHRoZSBzYW1lIHNldC4gQSBzZXQgY2FuIGhhdmUgYSBtYXhpbXVtIG9mIDIqKjE2ICg2NTUzNikgbm9kZVxuLy8vIHR5cGVzIGluIGl0LCBzbyB0aGF0IHRoZSBpZHMgZml0IGludG8gMTYtYml0IHR5cGVkIGFycmF5IHNsb3RzLlxuY2xhc3MgTm9kZVNldCB7XG4gICAgLy8vIENyZWF0ZSBhIHNldCB3aXRoIHRoZSBnaXZlbiB0eXBlcy4gVGhlIGBpZGAgcHJvcGVydHkgb2YgZWFjaFxuICAgIC8vLyB0eXBlIHNob3VsZCBjb3JyZXNwb25kIHRvIGl0cyBwb3NpdGlvbiB3aXRoaW4gdGhlIGFycmF5LlxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBUaGUgbm9kZSB0eXBlcyBpbiB0aGlzIHNldCwgYnkgaWQuXG4gICAgdHlwZXMpIHtcbiAgICAgICAgdGhpcy50eXBlcyA9IHR5cGVzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHR5cGVzW2ldLmlkICE9IGkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJOb2RlIHR5cGUgaWRzIHNob3VsZCBjb3JyZXNwb25kIHRvIGFycmF5IHBvc2l0aW9ucyB3aGVuIGNyZWF0aW5nIGEgbm9kZSBzZXRcIik7XG4gICAgfVxuICAgIC8vLyBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgc2V0IHdpdGggc29tZSBub2RlIHByb3BlcnRpZXMgYWRkZWQuIFRoZVxuICAgIC8vLyBhcmd1bWVudHMgdG8gdGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNyZWF0ZWQgd2l0aFxuICAgIC8vLyBbYE5vZGVQcm9wLmFkZGBdKCNjb21tb24uTm9kZVByb3AuYWRkKS5cbiAgICBleHRlbmQoLi4ucHJvcHMpIHtcbiAgICAgICAgbGV0IG5ld1R5cGVzID0gW107XG4gICAgICAgIGZvciAobGV0IHR5cGUgb2YgdGhpcy50eXBlcykge1xuICAgICAgICAgICAgbGV0IG5ld1Byb3BzID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAobGV0IHNvdXJjZSBvZiBwcm9wcykge1xuICAgICAgICAgICAgICAgIGxldCBhZGQgPSBzb3VyY2UodHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGFkZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld1Byb3BzKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCB0eXBlLnByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHNbYWRkWzBdLmlkXSA9IGFkZFsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdUeXBlcy5wdXNoKG5ld1Byb3BzID8gbmV3IE5vZGVUeXBlKHR5cGUubmFtZSwgbmV3UHJvcHMsIHR5cGUuaWQsIHR5cGUuZmxhZ3MpIDogdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlU2V0KG5ld1R5cGVzKTtcbiAgICB9XG59XG5jb25zdCBDYWNoZWROb2RlID0gbmV3IFdlYWtNYXAoKSwgQ2FjaGVkSW5uZXJOb2RlID0gbmV3IFdlYWtNYXAoKTtcbi8vLyBBIHBpZWNlIG9mIHN5bnRheCB0cmVlLiBUaGVyZSBhcmUgdHdvIHdheXMgdG8gYXBwcm9hY2ggdGhlc2Vcbi8vLyB0cmVlczogdGhlIHdheSB0aGV5IGFyZSBhY3R1YWxseSBzdG9yZWQgaW4gbWVtb3J5LCBhbmQgdGhlXG4vLy8gY29udmVuaWVudCB3YXkuXG4vLy9cbi8vLyBTeW50YXggdHJlZXMgYXJlIHN0b3JlZCBhcyBhIHRyZWUgb2YgYFRyZWVgIGFuZCBgVHJlZUJ1ZmZlcmBcbi8vLyBvYmplY3RzLiBCeSBwYWNraW5nIGRldGFpbCBpbmZvcm1hdGlvbiBpbnRvIGBUcmVlQnVmZmVyYCBsZWFmXG4vLy8gbm9kZXMsIHRoZSByZXByZXNlbnRhdGlvbiBpcyBtYWRlIGEgbG90IG1vcmUgbWVtb3J5LWVmZmljaWVudC5cbi8vL1xuLy8vIEhvd2V2ZXIsIHdoZW4geW91IHdhbnQgdG8gYWN0dWFsbHkgd29yayB3aXRoIHRyZWUgbm9kZXMsIHRoaXNcbi8vLyByZXByZXNlbnRhdGlvbiBpcyB2ZXJ5IGF3a3dhcmQsIHNvIG1vc3QgY2xpZW50IGNvZGUgd2lsbCB3YW50IHRvXG4vLy8gdXNlIHRoZSBbYFRyZWVDdXJzb3JgXSgjY29tbW9uLlRyZWVDdXJzb3IpIG9yXG4vLy8gW2BTeW50YXhOb2RlYF0oI2NvbW1vbi5TeW50YXhOb2RlKSBpbnRlcmZhY2UgaW5zdGVhZCwgd2hpY2ggcHJvdmlkZXNcbi8vLyBhIHZpZXcgb24gc29tZSBwYXJ0IG9mIHRoaXMgZGF0YSBzdHJ1Y3R1cmUsIGFuZCBjYW4gYmUgdXNlZCB0b1xuLy8vIG1vdmUgYXJvdW5kIHRvIGFkamFjZW50IG5vZGVzLlxuY2xhc3MgVHJlZSB7XG4gICAgLy8vIENvbnN0cnVjdCBhIG5ldyB0cmVlLiBTZWUgYWxzbyBbYFRyZWUuYnVpbGRgXSgjY29tbW9uLlRyZWVeYnVpbGQpLlxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBUaGUgdHlwZSBvZiB0aGUgdG9wIG5vZGUuXG4gICAgdHlwZSwgXG4gICAgLy8vIFRoaXMgbm9kZSdzIGNoaWxkIG5vZGVzLlxuICAgIGNoaWxkcmVuLCBcbiAgICAvLy8gVGhlIHBvc2l0aW9ucyAob2Zmc2V0cyByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhpcyB0cmVlKSBvZlxuICAgIC8vLyB0aGUgY2hpbGRyZW4uXG4gICAgcG9zaXRpb25zLCBcbiAgICAvLy8gVGhlIHRvdGFsIGxlbmd0aCBvZiB0aGlzIHRyZWVcbiAgICBsZW5ndGgsIFxuICAgIC8vLyBQZXItbm9kZSBbbm9kZSBwcm9wc10oI2NvbW1vbi5Ob2RlUHJvcCkgdG8gYXNzb2NpYXRlIHdpdGggdGhpcyBub2RlLlxuICAgIHByb3BzKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5wb3NpdGlvbnMgPSBwb3NpdGlvbnM7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICAvLy8gQGludGVybmFsXG4gICAgICAgIHRoaXMucHJvcHMgPSBudWxsO1xuICAgICAgICBpZiAocHJvcHMgJiYgcHJvcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIGZvciAobGV0IFtwcm9wLCB2YWx1ZV0gb2YgcHJvcHMpXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wc1t0eXBlb2YgcHJvcCA9PSBcIm51bWJlclwiID8gcHJvcCA6IHByb3AuaWRdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgbW91bnRlZCA9IHRoaXMucHJvcChOb2RlUHJvcC5tb3VudGVkKTtcbiAgICAgICAgaWYgKG1vdW50ZWQgJiYgIW1vdW50ZWQub3ZlcmxheSlcbiAgICAgICAgICAgIHJldHVybiBtb3VudGVkLnRyZWUudG9TdHJpbmcoKTtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgY2ggb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgbGV0IHN0ciA9IGNoLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAoc3RyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuKVxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiArPSBcIixcIjtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiArPSBzdHI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICF0aGlzLnR5cGUubmFtZSA/IGNoaWxkcmVuIDpcbiAgICAgICAgICAgICgvXFxXLy50ZXN0KHRoaXMudHlwZS5uYW1lKSAmJiAhdGhpcy50eXBlLmlzRXJyb3IgPyBKU09OLnN0cmluZ2lmeSh0aGlzLnR5cGUubmFtZSkgOiB0aGlzLnR5cGUubmFtZSkgK1xuICAgICAgICAgICAgICAgIChjaGlsZHJlbi5sZW5ndGggPyBcIihcIiArIGNoaWxkcmVuICsgXCIpXCIgOiBcIlwiKTtcbiAgICB9XG4gICAgLy8vIEdldCBhIFt0cmVlIGN1cnNvcl0oI2NvbW1vbi5UcmVlQ3Vyc29yKSByb290ZWQgYXQgdGhpcyB0cmVlLiBXaGVuXG4gICAgLy8vIGBwb3NgIGlzIGdpdmVuLCB0aGUgY3Vyc29yIGlzIFttb3ZlZF0oI2NvbW1vbi5UcmVlQ3Vyc29yLm1vdmVUbylcbiAgICAvLy8gdG8gdGhlIGdpdmVuIHBvc2l0aW9uIGFuZCBzaWRlLlxuICAgIGN1cnNvcihwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIGxldCBzY29wZSA9IChwb3MgIT0gbnVsbCAmJiBDYWNoZWROb2RlLmdldCh0aGlzKSkgfHwgdGhpcy50b3BOb2RlO1xuICAgICAgICBsZXQgY3Vyc29yID0gbmV3IFRyZWVDdXJzb3Ioc2NvcGUpO1xuICAgICAgICBpZiAocG9zICE9IG51bGwpIHtcbiAgICAgICAgICAgIGN1cnNvci5tb3ZlVG8ocG9zLCBzaWRlKTtcbiAgICAgICAgICAgIENhY2hlZE5vZGUuc2V0KHRoaXMsIGN1cnNvci5fdHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnNvcjtcbiAgICB9XG4gICAgLy8vIEdldCBhIFt0cmVlIGN1cnNvcl0oI2NvbW1vbi5UcmVlQ3Vyc29yKSB0aGF0LCB1bmxpa2UgcmVndWxhclxuICAgIC8vLyBjdXJzb3JzLCBkb2Vzbid0IHNraXAgdGhyb3VnaFxuICAgIC8vLyBbYW5vbnltb3VzXSgjY29tbW9uLk5vZGVUeXBlLmlzQW5vbnltb3VzKSBub2RlcyBhbmQgZG9lc24ndFxuICAgIC8vLyBhdXRvbWF0aWNhbGx5IGVudGVyIG1vdW50ZWQgbm9kZXMuXG4gICAgZnVsbEN1cnNvcigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlQ3Vyc29yKHRoaXMudG9wTm9kZSwgMSAvKiBGdWxsICovKTtcbiAgICB9XG4gICAgLy8vIEdldCBhIFtzeW50YXggbm9kZV0oI2NvbW1vbi5TeW50YXhOb2RlKSBvYmplY3QgZm9yIHRoZSB0b3Agb2YgdGhlXG4gICAgLy8vIHRyZWUuXG4gICAgZ2V0IHRvcE5vZGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZU5vZGUodGhpcywgMCwgMCwgbnVsbCk7XG4gICAgfVxuICAgIC8vLyBHZXQgdGhlIFtzeW50YXggbm9kZV0oI2NvbW1vbi5TeW50YXhOb2RlKSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgLy8vIElmIGBzaWRlYCBpcyAtMSwgdGhpcyB3aWxsIG1vdmUgaW50byBub2RlcyB0aGF0IGVuZCBhdCB0aGVcbiAgICAvLy8gcG9zaXRpb24uIElmIDEsIGl0J2xsIG1vdmUgaW50byBub2RlcyB0aGF0IHN0YXJ0IGF0IHRoZVxuICAgIC8vLyBwb3NpdGlvbi4gV2l0aCAwLCBpdCdsbCBvbmx5IGVudGVyIG5vZGVzIHRoYXQgY292ZXIgdGhlIHBvc2l0aW9uXG4gICAgLy8vIGZyb20gYm90aCBzaWRlcy5cbiAgICByZXNvbHZlKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgbGV0IG5vZGUgPSByZXNvbHZlTm9kZShDYWNoZWROb2RlLmdldCh0aGlzKSB8fCB0aGlzLnRvcE5vZGUsIHBvcywgc2lkZSwgZmFsc2UpO1xuICAgICAgICBDYWNoZWROb2RlLnNldCh0aGlzLCBub2RlKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIC8vLyBMaWtlIFtgcmVzb2x2ZWBdKCNjb21tb24uVHJlZS5yZXNvbHZlKSwgYnV0IHdpbGwgZW50ZXJcbiAgICAvLy8gW292ZXJsYWlkXSgjY29tbW9uLk1vdW50ZWRUcmVlLm92ZXJsYXkpIG5vZGVzLCBwcm9kdWNpbmcgYSBzeW50YXggbm9kZVxuICAgIC8vLyBwb2ludGluZyBpbnRvIHRoZSBpbm5lcm1vc3Qgb3ZlcmxhaWQgdHJlZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb25cbiAgICAvLy8gKHdpdGggcGFyZW50IGxpbmtzIGdvaW5nIHRocm91Z2ggYWxsIHBhcmVudCBzdHJ1Y3R1cmUsIGluY2x1ZGluZ1xuICAgIC8vLyB0aGUgaG9zdCB0cmVlcykuXG4gICAgcmVzb2x2ZUlubmVyKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgbGV0IG5vZGUgPSByZXNvbHZlTm9kZShDYWNoZWRJbm5lck5vZGUuZ2V0KHRoaXMpIHx8IHRoaXMudG9wTm9kZSwgcG9zLCBzaWRlLCB0cnVlKTtcbiAgICAgICAgQ2FjaGVkSW5uZXJOb2RlLnNldCh0aGlzLCBub2RlKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIC8vLyBJdGVyYXRlIG92ZXIgdGhlIHRyZWUgYW5kIGl0cyBjaGlsZHJlbiwgY2FsbGluZyBgZW50ZXJgIGZvciBhbnlcbiAgICAvLy8gbm9kZSB0aGF0IHRvdWNoZXMgdGhlIGBmcm9tYC9gdG9gIHJlZ2lvbiAoaWYgZ2l2ZW4pIGJlZm9yZVxuICAgIC8vLyBydW5uaW5nIG92ZXIgc3VjaCBhIG5vZGUncyBjaGlsZHJlbiwgYW5kIGBsZWF2ZWAgKGlmIGdpdmVuKSB3aGVuXG4gICAgLy8vIGxlYXZpbmcgdGhlIG5vZGUuIFdoZW4gYGVudGVyYCByZXR1cm5zIGBmYWxzZWAsIHRoYXQgbm9kZSB3aWxsXG4gICAgLy8vIG5vdCBoYXZlIGl0cyBjaGlsZHJlbiBpdGVyYXRlZCBvdmVyIChvciBgbGVhdmVgIGNhbGxlZCkuXG4gICAgaXRlcmF0ZShzcGVjKSB7XG4gICAgICAgIGxldCB7IGVudGVyLCBsZWF2ZSwgZnJvbSA9IDAsIHRvID0gdGhpcy5sZW5ndGggfSA9IHNwZWM7XG4gICAgICAgIGZvciAobGV0IGMgPSB0aGlzLmN1cnNvcigpLCBnZXQgPSAoKSA9PiBjLm5vZGU7Oykge1xuICAgICAgICAgICAgbGV0IG11c3RMZWF2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGMuZnJvbSA8PSB0byAmJiBjLnRvID49IGZyb20gJiYgKGMudHlwZS5pc0Fub255bW91cyB8fCBlbnRlcihjLnR5cGUsIGMuZnJvbSwgYy50bywgZ2V0KSAhPT0gZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMuZmlyc3RDaGlsZCgpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAoIWMudHlwZS5pc0Fub255bW91cylcbiAgICAgICAgICAgICAgICAgICAgbXVzdExlYXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBpZiAobXVzdExlYXZlICYmIGxlYXZlKVxuICAgICAgICAgICAgICAgICAgICBsZWF2ZShjLnR5cGUsIGMuZnJvbSwgYy50bywgZ2V0KTtcbiAgICAgICAgICAgICAgICBtdXN0TGVhdmUgPSBjLnR5cGUuaXNBbm9ueW1vdXM7XG4gICAgICAgICAgICAgICAgaWYgKGMubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKCFjLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgbXVzdExlYXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gR2V0IHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gW25vZGUgcHJvcF0oI2NvbW1vbi5Ob2RlUHJvcCkgZm9yIHRoaXNcbiAgICAvLy8gbm9kZS4gV29ya3Mgd2l0aCBib3RoIHBlci1ub2RlIGFuZCBwZXItdHlwZSBwcm9wcy5cbiAgICBwcm9wKHByb3ApIHtcbiAgICAgICAgcmV0dXJuICFwcm9wLnBlck5vZGUgPyB0aGlzLnR5cGUucHJvcChwcm9wKSA6IHRoaXMucHJvcHMgPyB0aGlzLnByb3BzW3Byb3AuaWRdIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLy8gUmV0dXJucyB0aGUgbm9kZSdzIFtwZXItbm9kZSBwcm9wc10oI2NvbW1vbi5Ob2RlUHJvcC5wZXJOb2RlKSBpbiBhXG4gICAgLy8vIGZvcm1hdCB0aGF0IGNhbiBiZSBwYXNzZWQgdG8gdGhlIFtgVHJlZWBdKCNjb21tb24uVHJlZSlcbiAgICAvLy8gY29uc3RydWN0b3IuXG4gICAgZ2V0IHByb3BWYWx1ZXMoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMpXG4gICAgICAgICAgICBmb3IgKGxldCBpZCBpbiB0aGlzLnByb3BzKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFsraWQsIHRoaXMucHJvcHNbaWRdXSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vLyBCYWxhbmNlIHRoZSBkaXJlY3QgY2hpbGRyZW4gb2YgdGhpcyB0cmVlLCBwcm9kdWNpbmcgYSBjb3B5IG9mXG4gICAgLy8vIHdoaWNoIG1heSBoYXZlIGNoaWxkcmVuIGdyb3VwZWQgaW50byBzdWJ0cmVlcyB3aXRoIHR5cGVcbiAgICAvLy8gW2BOb2RlVHlwZS5ub25lYF0oI2NvbW1vbi5Ob2RlVHlwZV5ub25lKS5cbiAgICBiYWxhbmNlKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmxlbmd0aCA8PSA4IC8qIEJyYW5jaEZhY3RvciAqLyA/IHRoaXMgOlxuICAgICAgICAgICAgYmFsYW5jZVJhbmdlKE5vZGVUeXBlLm5vbmUsIHRoaXMuY2hpbGRyZW4sIHRoaXMucG9zaXRpb25zLCAwLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCwgMCwgdGhpcy5sZW5ndGgsIChjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpID0+IG5ldyBUcmVlKHRoaXMudHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoLCB0aGlzLnByb3BWYWx1ZXMpLCBjb25maWcubWFrZVRyZWUgfHwgKChjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpID0+IG5ldyBUcmVlKE5vZGVUeXBlLm5vbmUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCkpKTtcbiAgICB9XG4gICAgLy8vIEJ1aWxkIGEgdHJlZSBmcm9tIGEgcG9zdGZpeC1vcmRlcmVkIGJ1ZmZlciBvZiBub2RlIGluZm9ybWF0aW9uLFxuICAgIC8vLyBvciBhIGN1cnNvciBvdmVyIHN1Y2ggYSBidWZmZXIuXG4gICAgc3RhdGljIGJ1aWxkKGRhdGEpIHsgcmV0dXJuIGJ1aWxkVHJlZShkYXRhKTsgfVxufVxuLy8vIFRoZSBlbXB0eSB0cmVlXG5UcmVlLmVtcHR5ID0gbmV3IFRyZWUoTm9kZVR5cGUubm9uZSwgW10sIFtdLCAwKTtcbmNsYXNzIEZsYXRCdWZmZXJDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGJ1ZmZlciwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB9XG4gICAgZ2V0IGlkKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDRdOyB9XG4gICAgZ2V0IHN0YXJ0KCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDNdOyB9XG4gICAgZ2V0IGVuZCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAyXTsgfVxuICAgIGdldCBzaXplKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDFdOyB9XG4gICAgZ2V0IHBvcygpIHsgcmV0dXJuIHRoaXMuaW5kZXg7IH1cbiAgICBuZXh0KCkgeyB0aGlzLmluZGV4IC09IDQ7IH1cbiAgICBmb3JrKCkgeyByZXR1cm4gbmV3IEZsYXRCdWZmZXJDdXJzb3IodGhpcy5idWZmZXIsIHRoaXMuaW5kZXgpOyB9XG59XG4vLy8gVHJlZSBidWZmZXJzIGNvbnRhaW4gKHR5cGUsIHN0YXJ0LCBlbmQsIGVuZEluZGV4KSBxdWFkcyBmb3IgZWFjaFxuLy8vIG5vZGUuIEluIHN1Y2ggYSBidWZmZXIsIG5vZGVzIGFyZSBzdG9yZWQgaW4gcHJlZml4IG9yZGVyIChwYXJlbnRzXG4vLy8gYmVmb3JlIGNoaWxkcmVuLCB3aXRoIHRoZSBlbmRJbmRleCBvZiB0aGUgcGFyZW50IGluZGljYXRpbmcgd2hpY2hcbi8vLyBjaGlsZHJlbiBiZWxvbmcgdG8gaXQpXG5jbGFzcyBUcmVlQnVmZmVyIHtcbiAgICAvLy8gQ3JlYXRlIGEgdHJlZSBidWZmZXIuXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIFRoZSBidWZmZXIncyBjb250ZW50LlxuICAgIGJ1ZmZlciwgXG4gICAgLy8vIFRoZSB0b3RhbCBsZW5ndGggb2YgdGhlIGdyb3VwIG9mIG5vZGVzIGluIHRoZSBidWZmZXIuXG4gICAgbGVuZ3RoLCBcbiAgICAvLy8gVGhlIG5vZGUgc2V0IHVzZWQgaW4gdGhpcyBidWZmZXIuXG4gICAgc2V0KSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5zZXQgPSBzZXQ7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBnZXQgdHlwZSgpIHsgcmV0dXJuIE5vZGVUeXBlLm5vbmU7IH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuYnVmZmVyLmxlbmd0aDspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuY2hpbGRTdHJpbmcoaW5kZXgpKTtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5idWZmZXJbaW5kZXggKyAzXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCIsXCIpO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgY2hpbGRTdHJpbmcoaW5kZXgpIHtcbiAgICAgICAgbGV0IGlkID0gdGhpcy5idWZmZXJbaW5kZXhdLCBlbmRJbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIGxldCB0eXBlID0gdGhpcy5zZXQudHlwZXNbaWRdLCByZXN1bHQgPSB0eXBlLm5hbWU7XG4gICAgICAgIGlmICgvXFxXLy50ZXN0KHJlc3VsdCkgJiYgIXR5cGUuaXNFcnJvcilcbiAgICAgICAgICAgIHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgICAgIGluZGV4ICs9IDQ7XG4gICAgICAgIGlmIChlbmRJbmRleCA9PSBpbmRleClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBlbmRJbmRleCkge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkU3RyaW5nKGluZGV4KSk7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIFwiKFwiICsgY2hpbGRyZW4uam9pbihcIixcIikgKyBcIilcIjtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGZpbmRDaGlsZChzdGFydEluZGV4LCBlbmRJbmRleCwgZGlyLCBwb3MsIHNpZGUpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLCBwaWNrID0gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpICE9IGVuZEluZGV4OyBpID0gYnVmZmVyW2kgKyAzXSkge1xuICAgICAgICAgICAgaWYgKGNoZWNrU2lkZShzaWRlLCBwb3MsIGJ1ZmZlcltpICsgMV0sIGJ1ZmZlcltpICsgMl0pKSB7XG4gICAgICAgICAgICAgICAgcGljayA9IGk7XG4gICAgICAgICAgICAgICAgaWYgKGRpciA+IDApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwaWNrO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgc2xpY2Uoc3RhcnRJLCBlbmRJLCBmcm9tLCB0bykge1xuICAgICAgICBsZXQgYiA9IHRoaXMuYnVmZmVyO1xuICAgICAgICBsZXQgY29weSA9IG5ldyBVaW50MTZBcnJheShlbmRJIC0gc3RhcnRJKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0SSwgaiA9IDA7IGkgPCBlbmRJOykge1xuICAgICAgICAgICAgY29weVtqKytdID0gYltpKytdO1xuICAgICAgICAgICAgY29weVtqKytdID0gYltpKytdIC0gZnJvbTtcbiAgICAgICAgICAgIGNvcHlbaisrXSA9IGJbaSsrXSAtIGZyb207XG4gICAgICAgICAgICBjb3B5W2orK10gPSBiW2krK10gLSBzdGFydEk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlQnVmZmVyKGNvcHksIHRvIC0gZnJvbSwgdGhpcy5zZXQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrU2lkZShzaWRlLCBwb3MsIGZyb20sIHRvKSB7XG4gICAgc3dpdGNoIChzaWRlKSB7XG4gICAgICAgIGNhc2UgLTIgLyogQmVmb3JlICovOiByZXR1cm4gZnJvbSA8IHBvcztcbiAgICAgICAgY2FzZSAtMSAvKiBBdE9yQmVmb3JlICovOiByZXR1cm4gdG8gPj0gcG9zICYmIGZyb20gPCBwb3M7XG4gICAgICAgIGNhc2UgMCAvKiBBcm91bmQgKi86IHJldHVybiBmcm9tIDwgcG9zICYmIHRvID4gcG9zO1xuICAgICAgICBjYXNlIDEgLyogQXRPckFmdGVyICovOiByZXR1cm4gZnJvbSA8PSBwb3MgJiYgdG8gPiBwb3M7XG4gICAgICAgIGNhc2UgMiAvKiBBZnRlciAqLzogcmV0dXJuIHRvID4gcG9zO1xuICAgICAgICBjYXNlIDQgLyogRG9udENhcmUgKi86IHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVudGVyVW5maW5pc2hlZE5vZGVzQmVmb3JlKG5vZGUsIHBvcykge1xuICAgIGxldCBzY2FuID0gbm9kZS5jaGlsZEJlZm9yZShwb3MpO1xuICAgIHdoaWxlIChzY2FuKSB7XG4gICAgICAgIGxldCBsYXN0ID0gc2Nhbi5sYXN0Q2hpbGQ7XG4gICAgICAgIGlmICghbGFzdCB8fCBsYXN0LnRvICE9IHNjYW4udG8pXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKGxhc3QudHlwZS5pc0Vycm9yICYmIGxhc3QuZnJvbSA9PSBsYXN0LnRvKSB7XG4gICAgICAgICAgICBub2RlID0gc2NhbjtcbiAgICAgICAgICAgIHNjYW4gPSBsYXN0LnByZXZTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2NhbiA9IGxhc3Q7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiByZXNvbHZlTm9kZShub2RlLCBwb3MsIHNpZGUsIG92ZXJsYXlzKSB7XG4gICAgdmFyIF9hO1xuICAgIC8vIE1vdmUgdXAgdG8gYSBub2RlIHRoYXQgYWN0dWFsbHkgaG9sZHMgdGhlIHBvc2l0aW9uLCBpZiBwb3NzaWJsZVxuICAgIHdoaWxlIChub2RlLmZyb20gPT0gbm9kZS50byB8fFxuICAgICAgICAoc2lkZSA8IDEgPyBub2RlLmZyb20gPj0gcG9zIDogbm9kZS5mcm9tID4gcG9zKSB8fFxuICAgICAgICAoc2lkZSA+IC0xID8gbm9kZS50byA8PSBwb3MgOiBub2RlLnRvIDwgcG9zKSkge1xuICAgICAgICBsZXQgcGFyZW50ID0gIW92ZXJsYXlzICYmIG5vZGUgaW5zdGFuY2VvZiBUcmVlTm9kZSAmJiBub2RlLmluZGV4IDwgMCA/IG51bGwgOiBub2RlLnBhcmVudDtcbiAgICAgICAgaWYgKCFwYXJlbnQpXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICB9XG4gICAgLy8gTXVzdCBnbyB1cCBvdXQgb2Ygb3ZlcmxheXMgd2hlbiB0aG9zZSBkbyBub3Qgb3ZlcmxhcCB3aXRoIHBvc1xuICAgIGlmIChvdmVybGF5cylcbiAgICAgICAgZm9yIChsZXQgc2NhbiA9IG5vZGUsIHBhcmVudCA9IHNjYW4ucGFyZW50OyBwYXJlbnQ7IHNjYW4gPSBwYXJlbnQsIHBhcmVudCA9IHNjYW4ucGFyZW50KSB7XG4gICAgICAgICAgICBpZiAoc2NhbiBpbnN0YW5jZW9mIFRyZWVOb2RlICYmIHNjYW4uaW5kZXggPCAwICYmICgoX2EgPSBwYXJlbnQuZW50ZXIocG9zLCBzaWRlLCB0cnVlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZyb20pICE9IHNjYW4uZnJvbSlcbiAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgZm9yICg7Oykge1xuICAgICAgICBsZXQgaW5uZXIgPSBub2RlLmVudGVyKHBvcywgc2lkZSwgb3ZlcmxheXMpO1xuICAgICAgICBpZiAoIWlubmVyKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIG5vZGUgPSBpbm5lcjtcbiAgICB9XG59XG5jbGFzcyBUcmVlTm9kZSB7XG4gICAgY29uc3RydWN0b3Iobm9kZSwgX2Zyb20sIFxuICAgIC8vIEluZGV4IGluIHBhcmVudCBub2RlLCBzZXQgdG8gLTEgaWYgdGhlIG5vZGUgaXMgbm90IGEgZGlyZWN0IGNoaWxkIG9mIF9wYXJlbnQubm9kZSAob3ZlcmxheSlcbiAgICBpbmRleCwgX3BhcmVudCkge1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLl9mcm9tID0gX2Zyb207XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gX3BhcmVudDtcbiAgICB9XG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiB0aGlzLm5vZGUudHlwZTsgfVxuICAgIGdldCBuYW1lKCkgeyByZXR1cm4gdGhpcy5ub2RlLnR5cGUubmFtZTsgfVxuICAgIGdldCBmcm9tKCkgeyByZXR1cm4gdGhpcy5fZnJvbTsgfVxuICAgIGdldCB0bygpIHsgcmV0dXJuIHRoaXMuX2Zyb20gKyB0aGlzLm5vZGUubGVuZ3RoOyB9XG4gICAgbmV4dENoaWxkKGksIGRpciwgcG9zLCBzaWRlLCBtb2RlID0gMCkge1xuICAgICAgICBmb3IgKGxldCBwYXJlbnQgPSB0aGlzOzspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHsgY2hpbGRyZW4sIHBvc2l0aW9ucyB9ID0gcGFyZW50Lm5vZGUsIGUgPSBkaXIgPiAwID8gY2hpbGRyZW4ubGVuZ3RoIDogLTE7IGkgIT0gZTsgaSArPSBkaXIpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGNoaWxkcmVuW2ldLCBzdGFydCA9IHBvc2l0aW9uc1tpXSArIHBhcmVudC5fZnJvbTtcbiAgICAgICAgICAgICAgICBpZiAoIWNoZWNrU2lkZShzaWRlLCBwb3MsIHN0YXJ0LCBzdGFydCArIG5leHQubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgaW5zdGFuY2VvZiBUcmVlQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlICYgMiAvKiBOb0VudGVyQnVmZmVyICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IG5leHQuZmluZENoaWxkKDAsIG5leHQuYnVmZmVyLmxlbmd0aCwgZGlyLCBwb3MgLSBzdGFydCwgc2lkZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJOb2RlKG5ldyBCdWZmZXJDb250ZXh0KHBhcmVudCwgbmV4dCwgaSwgc3RhcnQpLCBudWxsLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChtb2RlICYgMSAvKiBGdWxsICovKSB8fCAoIW5leHQudHlwZS5pc0Fub255bW91cyB8fCBoYXNDaGlsZChuZXh0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1vdW50ZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG1vZGUgJiAxIC8qIEZ1bGwgKi8pICYmIG5leHQucHJvcHMgJiYgKG1vdW50ZWQgPSBuZXh0LnByb3AoTm9kZVByb3AubW91bnRlZCkpICYmICFtb3VudGVkLm92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRyZWVOb2RlKG1vdW50ZWQudHJlZSwgc3RhcnQsIGksIHBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbm5lciA9IG5ldyBUcmVlTm9kZShuZXh0LCBzdGFydCwgaSwgcGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChtb2RlICYgMSAvKiBGdWxsICovKSB8fCAhaW5uZXIudHlwZS5pc0Fub255bW91cyA/IGlubmVyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGlubmVyLm5leHRDaGlsZChkaXIgPCAwID8gbmV4dC5jaGlsZHJlbi5sZW5ndGggLSAxIDogMCwgZGlyLCBwb3MsIHNpZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgobW9kZSAmIDEgLyogRnVsbCAqLykgfHwgIXBhcmVudC50eXBlLmlzQW5vbnltb3VzKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKHBhcmVudC5pbmRleCA+PSAwKVxuICAgICAgICAgICAgICAgIGkgPSBwYXJlbnQuaW5kZXggKyBkaXI7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgaSA9IGRpciA8IDAgPyAtMSA6IHBhcmVudC5fcGFyZW50Lm5vZGUuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50Ll9wYXJlbnQ7XG4gICAgICAgICAgICBpZiAoIXBhcmVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMubmV4dENoaWxkKDAsIDEsIDAsIDQgLyogRG9udENhcmUgKi8pOyB9XG4gICAgZ2V0IGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMubmV4dENoaWxkKHRoaXMubm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxLCAtMSwgMCwgNCAvKiBEb250Q2FyZSAqLyk7IH1cbiAgICBjaGlsZEFmdGVyKHBvcykgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQoMCwgMSwgcG9zLCAyIC8qIEFmdGVyICovKTsgfVxuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQodGhpcy5ub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDEsIC0xLCBwb3MsIC0yIC8qIEJlZm9yZSAqLyk7IH1cbiAgICBlbnRlcihwb3MsIHNpZGUsIG92ZXJsYXlzID0gdHJ1ZSwgYnVmZmVycyA9IHRydWUpIHtcbiAgICAgICAgbGV0IG1vdW50ZWQ7XG4gICAgICAgIGlmIChvdmVybGF5cyAmJiAobW91bnRlZCA9IHRoaXMubm9kZS5wcm9wKE5vZGVQcm9wLm1vdW50ZWQpKSAmJiBtb3VudGVkLm92ZXJsYXkpIHtcbiAgICAgICAgICAgIGxldCByUG9zID0gcG9zIC0gdGhpcy5mcm9tO1xuICAgICAgICAgICAgZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIG1vdW50ZWQub3ZlcmxheSkge1xuICAgICAgICAgICAgICAgIGlmICgoc2lkZSA+IDAgPyBmcm9tIDw9IHJQb3MgOiBmcm9tIDwgclBvcykgJiZcbiAgICAgICAgICAgICAgICAgICAgKHNpZGUgPCAwID8gdG8gPj0gclBvcyA6IHRvID4gclBvcykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHJlZU5vZGUobW91bnRlZC50cmVlLCBtb3VudGVkLm92ZXJsYXlbMF0uZnJvbSArIHRoaXMuZnJvbSwgLTEsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRDaGlsZCgwLCAxLCBwb3MsIHNpZGUsIGJ1ZmZlcnMgPyAwIDogMiAvKiBOb0VudGVyQnVmZmVyICovKTtcbiAgICB9XG4gICAgbmV4dFNpZ25pZmljYW50UGFyZW50KCkge1xuICAgICAgICBsZXQgdmFsID0gdGhpcztcbiAgICAgICAgd2hpbGUgKHZhbC50eXBlLmlzQW5vbnltb3VzICYmIHZhbC5fcGFyZW50KVxuICAgICAgICAgICAgdmFsID0gdmFsLl9wYXJlbnQ7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPyB0aGlzLl9wYXJlbnQubmV4dFNpZ25pZmljYW50UGFyZW50KCkgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgbmV4dFNpYmxpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgJiYgdGhpcy5pbmRleCA+PSAwID8gdGhpcy5fcGFyZW50Lm5leHRDaGlsZCh0aGlzLmluZGV4ICsgMSwgMSwgMCwgNCAvKiBEb250Q2FyZSAqLykgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgcHJldlNpYmxpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgJiYgdGhpcy5pbmRleCA+PSAwID8gdGhpcy5fcGFyZW50Lm5leHRDaGlsZCh0aGlzLmluZGV4IC0gMSwgLTEsIDAsIDQgLyogRG9udENhcmUgKi8pIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IGN1cnNvcigpIHsgcmV0dXJuIG5ldyBUcmVlQ3Vyc29yKHRoaXMpOyB9XG4gICAgZ2V0IHRyZWUoKSB7IHJldHVybiB0aGlzLm5vZGU7IH1cbiAgICB0b1RyZWUoKSB7IHJldHVybiB0aGlzLm5vZGU7IH1cbiAgICByZXNvbHZlKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVOb2RlKHRoaXMsIHBvcywgc2lkZSwgZmFsc2UpO1xuICAgIH1cbiAgICByZXNvbHZlSW5uZXIocG9zLCBzaWRlID0gMCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZU5vZGUodGhpcywgcG9zLCBzaWRlLCB0cnVlKTtcbiAgICB9XG4gICAgZW50ZXJVbmZpbmlzaGVkTm9kZXNCZWZvcmUocG9zKSB7IHJldHVybiBlbnRlclVuZmluaXNoZWROb2Rlc0JlZm9yZSh0aGlzLCBwb3MpOyB9XG4gICAgZ2V0Q2hpbGQodHlwZSwgYmVmb3JlID0gbnVsbCwgYWZ0ZXIgPSBudWxsKSB7XG4gICAgICAgIGxldCByID0gZ2V0Q2hpbGRyZW4odGhpcywgdHlwZSwgYmVmb3JlLCBhZnRlcik7XG4gICAgICAgIHJldHVybiByLmxlbmd0aCA/IHJbMF0gOiBudWxsO1xuICAgIH1cbiAgICBnZXRDaGlsZHJlbih0eXBlLCBiZWZvcmUgPSBudWxsLCBhZnRlciA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGdldENoaWxkcmVuKHRoaXMsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLm5vZGUudG9TdHJpbmcoKTsgfVxufVxuZnVuY3Rpb24gZ2V0Q2hpbGRyZW4obm9kZSwgdHlwZSwgYmVmb3JlLCBhZnRlcikge1xuICAgIGxldCBjdXIgPSBub2RlLmN1cnNvciwgcmVzdWx0ID0gW107XG4gICAgaWYgKCFjdXIuZmlyc3RDaGlsZCgpKVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIGlmIChiZWZvcmUgIT0gbnVsbClcbiAgICAgICAgd2hpbGUgKCFjdXIudHlwZS5pcyhiZWZvcmUpKVxuICAgICAgICAgICAgaWYgKCFjdXIubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKGFmdGVyICE9IG51bGwgJiYgY3VyLnR5cGUuaXMoYWZ0ZXIpKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgaWYgKGN1ci50eXBlLmlzKHR5cGUpKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goY3VyLm5vZGUpO1xuICAgICAgICBpZiAoIWN1ci5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgcmV0dXJuIGFmdGVyID09IG51bGwgPyByZXN1bHQgOiBbXTtcbiAgICB9XG59XG5jbGFzcyBCdWZmZXJDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIGJ1ZmZlciwgaW5kZXgsIHN0YXJ0KSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgfVxufVxuY2xhc3MgQnVmZmVyTm9kZSB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgX3BhcmVudCwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gX3BhcmVudDtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLnR5cGUgPSBjb250ZXh0LmJ1ZmZlci5zZXQudHlwZXNbY29udGV4dC5idWZmZXIuYnVmZmVyW2luZGV4XV07XG4gICAgfVxuICAgIGdldCBuYW1lKCkgeyByZXR1cm4gdGhpcy50eXBlLm5hbWU7IH1cbiAgICBnZXQgZnJvbSgpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5zdGFydCArIHRoaXMuY29udGV4dC5idWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAxXTsgfVxuICAgIGdldCB0bygpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5zdGFydCArIHRoaXMuY29udGV4dC5idWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAyXTsgfVxuICAgIGNoaWxkKGRpciwgcG9zLCBzaWRlKSB7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgaW5kZXggPSBidWZmZXIuZmluZENoaWxkKHRoaXMuaW5kZXggKyA0LCBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXSwgZGlyLCBwb3MgLSB0aGlzLmNvbnRleHQuc3RhcnQsIHNpZGUpO1xuICAgICAgICByZXR1cm4gaW5kZXggPCAwID8gbnVsbCA6IG5ldyBCdWZmZXJOb2RlKHRoaXMuY29udGV4dCwgdGhpcywgaW5kZXgpO1xuICAgIH1cbiAgICBnZXQgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY2hpbGQoMSwgMCwgNCAvKiBEb250Q2FyZSAqLyk7IH1cbiAgICBnZXQgbGFzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5jaGlsZCgtMSwgMCwgNCAvKiBEb250Q2FyZSAqLyk7IH1cbiAgICBjaGlsZEFmdGVyKHBvcykgeyByZXR1cm4gdGhpcy5jaGlsZCgxLCBwb3MsIDIgLyogQWZ0ZXIgKi8pOyB9XG4gICAgY2hpbGRCZWZvcmUocG9zKSB7IHJldHVybiB0aGlzLmNoaWxkKC0xLCBwb3MsIC0yIC8qIEJlZm9yZSAqLyk7IH1cbiAgICBlbnRlcihwb3MsIHNpZGUsIG92ZXJsYXlzLCBidWZmZXJzID0gdHJ1ZSkge1xuICAgICAgICBpZiAoIWJ1ZmZlcnMpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBpbmRleCA9IGJ1ZmZlci5maW5kQ2hpbGQodGhpcy5pbmRleCArIDQsIGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdLCBzaWRlID4gMCA/IDEgOiAtMSwgcG9zIC0gdGhpcy5jb250ZXh0LnN0YXJ0LCBzaWRlKTtcbiAgICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IG51bGwgOiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMsIGluZGV4KTtcbiAgICB9XG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCB8fCB0aGlzLmNvbnRleHQucGFyZW50Lm5leHRTaWduaWZpY2FudFBhcmVudCgpO1xuICAgIH1cbiAgICBleHRlcm5hbFNpYmxpbmcoZGlyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPyBudWxsIDogdGhpcy5jb250ZXh0LnBhcmVudC5uZXh0Q2hpbGQodGhpcy5jb250ZXh0LmluZGV4ICsgZGlyLCBkaXIsIDAsIDQgLyogRG9udENhcmUgKi8pO1xuICAgIH1cbiAgICBnZXQgbmV4dFNpYmxpbmcoKSB7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgYWZ0ZXIgPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXTtcbiAgICAgICAgaWYgKGFmdGVyIDwgKHRoaXMuX3BhcmVudCA/IGJ1ZmZlci5idWZmZXJbdGhpcy5fcGFyZW50LmluZGV4ICsgM10gOiBidWZmZXIuYnVmZmVyLmxlbmd0aCkpXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlck5vZGUodGhpcy5jb250ZXh0LCB0aGlzLl9wYXJlbnQsIGFmdGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZXJuYWxTaWJsaW5nKDEpO1xuICAgIH1cbiAgICBnZXQgcHJldlNpYmxpbmcoKSB7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgcGFyZW50U3RhcnQgPSB0aGlzLl9wYXJlbnQgPyB0aGlzLl9wYXJlbnQuaW5kZXggKyA0IDogMDtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPT0gcGFyZW50U3RhcnQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHRlcm5hbFNpYmxpbmcoLTEpO1xuICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlck5vZGUodGhpcy5jb250ZXh0LCB0aGlzLl9wYXJlbnQsIGJ1ZmZlci5maW5kQ2hpbGQocGFyZW50U3RhcnQsIHRoaXMuaW5kZXgsIC0xLCAwLCA0IC8qIERvbnRDYXJlICovKSk7XG4gICAgfVxuICAgIGdldCBjdXJzb3IoKSB7IHJldHVybiBuZXcgVHJlZUN1cnNvcih0aGlzKTsgfVxuICAgIGdldCB0cmVlKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIHRvVHJlZSgpIHtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gW10sIHBvc2l0aW9ucyA9IFtdO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHN0YXJ0SSA9IHRoaXMuaW5kZXggKyA0LCBlbmRJID0gYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM107XG4gICAgICAgIGlmIChlbmRJID4gc3RhcnRJKSB7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDFdLCB0byA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDJdO1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChidWZmZXIuc2xpY2Uoc3RhcnRJLCBlbmRJLCBmcm9tLCB0bykpO1xuICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlKHRoaXMudHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgdGhpcy50byAtIHRoaXMuZnJvbSk7XG4gICAgfVxuICAgIHJlc29sdmUocG9zLCBzaWRlID0gMCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZU5vZGUodGhpcywgcG9zLCBzaWRlLCBmYWxzZSk7XG4gICAgfVxuICAgIHJlc29sdmVJbm5lcihwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlTm9kZSh0aGlzLCBwb3MsIHNpZGUsIHRydWUpO1xuICAgIH1cbiAgICBlbnRlclVuZmluaXNoZWROb2Rlc0JlZm9yZShwb3MpIHsgcmV0dXJuIGVudGVyVW5maW5pc2hlZE5vZGVzQmVmb3JlKHRoaXMsIHBvcyk7IH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLmNvbnRleHQuYnVmZmVyLmNoaWxkU3RyaW5nKHRoaXMuaW5kZXgpOyB9XG4gICAgZ2V0Q2hpbGQodHlwZSwgYmVmb3JlID0gbnVsbCwgYWZ0ZXIgPSBudWxsKSB7XG4gICAgICAgIGxldCByID0gZ2V0Q2hpbGRyZW4odGhpcywgdHlwZSwgYmVmb3JlLCBhZnRlcik7XG4gICAgICAgIHJldHVybiByLmxlbmd0aCA/IHJbMF0gOiBudWxsO1xuICAgIH1cbiAgICBnZXRDaGlsZHJlbih0eXBlLCBiZWZvcmUgPSBudWxsLCBhZnRlciA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGdldENoaWxkcmVuKHRoaXMsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpO1xuICAgIH1cbn1cbi8vLyBBIHRyZWUgY3Vyc29yIG9iamVjdCBmb2N1c2VzIG9uIGEgZ2l2ZW4gbm9kZSBpbiBhIHN5bnRheCB0cmVlLCBhbmRcbi8vLyBhbGxvd3MgeW91IHRvIG1vdmUgdG8gYWRqYWNlbnQgbm9kZXMuXG5jbGFzcyBUcmVlQ3Vyc29yIHtcbiAgICAvLy8gQGludGVybmFsXG4gICAgY29uc3RydWN0b3Iobm9kZSwgXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIG1vZGUgPSAwKSB7XG4gICAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5idWZmZXJOb2RlID0gbnVsbDtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBUcmVlTm9kZSkge1xuICAgICAgICAgICAgdGhpcy55aWVsZE5vZGUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90cmVlID0gbm9kZS5jb250ZXh0LnBhcmVudDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbm9kZS5jb250ZXh0O1xuICAgICAgICAgICAgZm9yIChsZXQgbiA9IG5vZGUuX3BhcmVudDsgbjsgbiA9IG4uX3BhcmVudClcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnVuc2hpZnQobi5pbmRleCk7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlck5vZGUgPSBub2RlO1xuICAgICAgICAgICAgdGhpcy55aWVsZEJ1Zihub2RlLmluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gU2hvcnRoYW5kIGZvciBgLnR5cGUubmFtZWAuXG4gICAgZ2V0IG5hbWUoKSB7IHJldHVybiB0aGlzLnR5cGUubmFtZTsgfVxuICAgIHlpZWxkTm9kZShub2RlKSB7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5fdHJlZSA9IG5vZGU7XG4gICAgICAgIHRoaXMudHlwZSA9IG5vZGUudHlwZTtcbiAgICAgICAgdGhpcy5mcm9tID0gbm9kZS5mcm9tO1xuICAgICAgICB0aGlzLnRvID0gbm9kZS50bztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHlpZWxkQnVmKGluZGV4LCB0eXBlKSB7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgbGV0IHsgc3RhcnQsIGJ1ZmZlciB9ID0gdGhpcy5idWZmZXI7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGUgfHwgYnVmZmVyLnNldC50eXBlc1tidWZmZXIuYnVmZmVyW2luZGV4XV07XG4gICAgICAgIHRoaXMuZnJvbSA9IHN0YXJ0ICsgYnVmZmVyLmJ1ZmZlcltpbmRleCArIDFdO1xuICAgICAgICB0aGlzLnRvID0gc3RhcnQgKyBidWZmZXIuYnVmZmVyW2luZGV4ICsgMl07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB5aWVsZChub2RlKSB7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBUcmVlTm9kZSkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGROb2RlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbm9kZS5jb250ZXh0O1xuICAgICAgICByZXR1cm4gdGhpcy55aWVsZEJ1Zihub2RlLmluZGV4LCBub2RlLnR5cGUpO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlciA/IHRoaXMuYnVmZmVyLmJ1ZmZlci5jaGlsZFN0cmluZyh0aGlzLmluZGV4KSA6IHRoaXMuX3RyZWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGVudGVyQ2hpbGQoZGlyLCBwb3MsIHNpZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkKHRoaXMuX3RyZWUubmV4dENoaWxkKGRpciA8IDAgPyB0aGlzLl90cmVlLm5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMSA6IDAsIGRpciwgcG9zLCBzaWRlLCB0aGlzLm1vZGUpKTtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgbGV0IGluZGV4ID0gYnVmZmVyLmZpbmRDaGlsZCh0aGlzLmluZGV4ICsgNCwgYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM10sIGRpciwgcG9zIC0gdGhpcy5idWZmZXIuc3RhcnQsIHNpZGUpO1xuICAgICAgICBpZiAoaW5kZXggPCAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5pbmRleCk7XG4gICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKGluZGV4KTtcbiAgICB9XG4gICAgLy8vIE1vdmUgdGhlIGN1cnNvciB0byB0aGlzIG5vZGUncyBmaXJzdCBjaGlsZC4gV2hlbiB0aGlzIHJldHVybnNcbiAgICAvLy8gZmFsc2UsIHRoZSBub2RlIGhhcyBubyBjaGlsZCwgYW5kIHRoZSBjdXJzb3IgaGFzIG5vdCBiZWVuIG1vdmVkLlxuICAgIGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmVudGVyQ2hpbGQoMSwgMCwgNCAvKiBEb250Q2FyZSAqLyk7IH1cbiAgICAvLy8gTW92ZSB0aGUgY3Vyc29yIHRvIHRoaXMgbm9kZSdzIGxhc3QgY2hpbGQuXG4gICAgbGFzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5lbnRlckNoaWxkKC0xLCAwLCA0IC8qIERvbnRDYXJlICovKTsgfVxuICAgIC8vLyBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGZpcnN0IGNoaWxkIHRoYXQgZW5kcyBhZnRlciBgcG9zYC5cbiAgICBjaGlsZEFmdGVyKHBvcykgeyByZXR1cm4gdGhpcy5lbnRlckNoaWxkKDEsIHBvcywgMiAvKiBBZnRlciAqLyk7IH1cbiAgICAvLy8gTW92ZSB0byB0aGUgbGFzdCBjaGlsZCB0aGF0IHN0YXJ0cyBiZWZvcmUgYHBvc2AuXG4gICAgY2hpbGRCZWZvcmUocG9zKSB7IHJldHVybiB0aGlzLmVudGVyQ2hpbGQoLTEsIHBvcywgLTIgLyogQmVmb3JlICovKTsgfVxuICAgIC8vLyBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGNoaWxkIGFyb3VuZCBgcG9zYC4gSWYgc2lkZSBpcyAtMSB0aGVcbiAgICAvLy8gY2hpbGQgbWF5IGVuZCBhdCB0aGF0IHBvc2l0aW9uLCB3aGVuIDEgaXQgbWF5IHN0YXJ0IHRoZXJlLiBUaGlzXG4gICAgLy8vIHdpbGwgYWxzbyBlbnRlciBbb3ZlcmxhaWRdKCNjb21tb24uTW91bnRlZFRyZWUub3ZlcmxheSlcbiAgICAvLy8gW21vdW50ZWRdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgdHJlZXMgdW5sZXNzIGBvdmVybGF5c2AgaXNcbiAgICAvLy8gc2V0IHRvIGZhbHNlLlxuICAgIGVudGVyKHBvcywgc2lkZSwgb3ZlcmxheXMgPSB0cnVlLCBidWZmZXJzID0gdHJ1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGQodGhpcy5fdHJlZS5lbnRlcihwb3MsIHNpZGUsIG92ZXJsYXlzICYmICEodGhpcy5tb2RlICYgMSAvKiBGdWxsICovKSwgYnVmZmVycykpO1xuICAgICAgICByZXR1cm4gYnVmZmVycyA/IHRoaXMuZW50ZXJDaGlsZCgxLCBwb3MsIHNpZGUpIDogZmFsc2U7XG4gICAgfVxuICAgIC8vLyBNb3ZlIHRvIHRoZSBub2RlJ3MgcGFyZW50IG5vZGUsIGlmIHRoaXMgaXNuJ3QgdGhlIHRvcCBub2RlLlxuICAgIHBhcmVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkTm9kZSgodGhpcy5tb2RlICYgMSAvKiBGdWxsICovKSA/IHRoaXMuX3RyZWUuX3BhcmVudCA6IHRoaXMuX3RyZWUucGFyZW50KTtcbiAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYodGhpcy5zdGFjay5wb3AoKSk7XG4gICAgICAgIGxldCBwYXJlbnQgPSAodGhpcy5tb2RlICYgMSAvKiBGdWxsICovKSA/IHRoaXMuYnVmZmVyLnBhcmVudCA6IHRoaXMuYnVmZmVyLnBhcmVudC5uZXh0U2lnbmlmaWNhbnRQYXJlbnQoKTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy55aWVsZE5vZGUocGFyZW50KTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHNpYmxpbmcoZGlyKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuX3RyZWUuX3BhcmVudCA/IGZhbHNlXG4gICAgICAgICAgICAgICAgOiB0aGlzLnlpZWxkKHRoaXMuX3RyZWUuaW5kZXggPCAwID8gbnVsbFxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX3RyZWUuX3BhcmVudC5uZXh0Q2hpbGQodGhpcy5fdHJlZS5pbmRleCArIGRpciwgZGlyLCAwLCA0IC8qIERvbnRDYXJlICovLCB0aGlzLm1vZGUpKTtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmJ1ZmZlciwgZCA9IHRoaXMuc3RhY2subGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGRpciA8IDApIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnRTdGFydCA9IGQgPCAwID8gMCA6IHRoaXMuc3RhY2tbZF0gKyA0O1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXggIT0gcGFyZW50U3RhcnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYoYnVmZmVyLmZpbmRDaGlsZChwYXJlbnRTdGFydCwgdGhpcy5pbmRleCwgLTEsIDAsIDQgLyogRG9udENhcmUgKi8pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBhZnRlciA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICAgICAgaWYgKGFmdGVyIDwgKGQgPCAwID8gYnVmZmVyLmJ1ZmZlci5sZW5ndGggOiBidWZmZXIuYnVmZmVyW3RoaXMuc3RhY2tbZF0gKyAzXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYoYWZ0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkIDwgMCA/IHRoaXMueWllbGQodGhpcy5idWZmZXIucGFyZW50Lm5leHRDaGlsZCh0aGlzLmJ1ZmZlci5pbmRleCArIGRpciwgZGlyLCAwLCA0IC8qIERvbnRDYXJlICovLCB0aGlzLm1vZGUpKSA6IGZhbHNlO1xuICAgIH1cbiAgICAvLy8gTW92ZSB0byB0aGlzIG5vZGUncyBuZXh0IHNpYmxpbmcsIGlmIGFueS5cbiAgICBuZXh0U2libGluZygpIHsgcmV0dXJuIHRoaXMuc2libGluZygxKTsgfVxuICAgIC8vLyBNb3ZlIHRvIHRoaXMgbm9kZSdzIHByZXZpb3VzIHNpYmxpbmcsIGlmIGFueS5cbiAgICBwcmV2U2libGluZygpIHsgcmV0dXJuIHRoaXMuc2libGluZygtMSk7IH1cbiAgICBhdExhc3ROb2RlKGRpcikge1xuICAgICAgICBsZXQgaW5kZXgsIHBhcmVudCwgeyBidWZmZXIgfSA9IHRoaXM7XG4gICAgICAgIGlmIChidWZmZXIpIHtcbiAgICAgICAgICAgIGlmIChkaXIgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXggPCBidWZmZXIuYnVmZmVyLmJ1ZmZlci5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pbmRleDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVyLmJ1ZmZlci5idWZmZXJbaSArIDNdIDwgdGhpcy5pbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICh7IGluZGV4LCBwYXJlbnQgfSA9IGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAoeyBpbmRleCwgX3BhcmVudDogcGFyZW50IH0gPSB0aGlzLl90cmVlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgcGFyZW50OyB7IGluZGV4LCBfcGFyZW50OiBwYXJlbnQgfSA9IHBhcmVudCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGluZGV4ICsgZGlyLCBlID0gZGlyIDwgMCA/IC0xIDogcGFyZW50Lm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpICE9IGU7IGkgKz0gZGlyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IHBhcmVudC5ub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHRoaXMubW9kZSAmIDEgLyogRnVsbCAqLykgfHwgY2hpbGQgaW5zdGFuY2VvZiBUcmVlQnVmZmVyIHx8ICFjaGlsZC50eXBlLmlzQW5vbnltb3VzIHx8IGhhc0NoaWxkKGNoaWxkKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIG1vdmUoZGlyLCBlbnRlcikge1xuICAgICAgICBpZiAoZW50ZXIgJiYgdGhpcy5lbnRlckNoaWxkKGRpciwgMCwgNCAvKiBEb250Q2FyZSAqLykpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2libGluZyhkaXIpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXRMYXN0Tm9kZShkaXIpIHx8ICF0aGlzLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gTW92ZSB0byB0aGUgbmV4dCBub2RlIGluIGFcbiAgICAvLy8gW3ByZS1vcmRlcl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVHJlZV90cmF2ZXJzYWwjUHJlLW9yZGVyXyhOTFIpKVxuICAgIC8vLyB0cmF2ZXJzYWwsIGdvaW5nIGZyb20gYSBub2RlIHRvIGl0cyBmaXJzdCBjaGlsZCBvciwgaWYgdGhlXG4gICAgLy8vIGN1cnJlbnQgbm9kZSBpcyBlbXB0eSBvciBgZW50ZXJgIGlzIGZhbHNlLCBpdHMgbmV4dCBzaWJsaW5nIG9yXG4gICAgLy8vIHRoZSBuZXh0IHNpYmxpbmcgb2YgdGhlIGZpcnN0IHBhcmVudCBub2RlIHRoYXQgaGFzIG9uZS5cbiAgICBuZXh0KGVudGVyID0gdHJ1ZSkgeyByZXR1cm4gdGhpcy5tb3ZlKDEsIGVudGVyKTsgfVxuICAgIC8vLyBNb3ZlIHRvIHRoZSBuZXh0IG5vZGUgaW4gYSBsYXN0LXRvLWZpcnN0IHByZS1vcmRlciB0cmF2ZXJhbC4gQVxuICAgIC8vLyBub2RlIGlzIGZvbGxvd2VkIGJ5IGl0cyBsYXN0IGNoaWxkIG9yLCBpZiBpdCBoYXMgbm9uZSwgaXRzXG4gICAgLy8vIHByZXZpb3VzIHNpYmxpbmcgb3IgdGhlIHByZXZpb3VzIHNpYmxpbmcgb2YgdGhlIGZpcnN0IHBhcmVudFxuICAgIC8vLyBub2RlIHRoYXQgaGFzIG9uZS5cbiAgICBwcmV2KGVudGVyID0gdHJ1ZSkgeyByZXR1cm4gdGhpcy5tb3ZlKC0xLCBlbnRlcik7IH1cbiAgICAvLy8gTW92ZSB0aGUgY3Vyc29yIHRvIHRoZSBpbm5lcm1vc3Qgbm9kZSB0aGF0IGNvdmVycyBgcG9zYC4gSWZcbiAgICAvLy8gYHNpZGVgIGlzIC0xLCBpdCB3aWxsIGVudGVyIG5vZGVzIHRoYXQgZW5kIGF0IGBwb3NgLiBJZiBpdCBpcyAxLFxuICAgIC8vLyBpdCB3aWxsIGVudGVyIG5vZGVzIHRoYXQgc3RhcnQgYXQgYHBvc2AuXG4gICAgbW92ZVRvKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgLy8gTW92ZSB1cCB0byBhIG5vZGUgdGhhdCBhY3R1YWxseSBob2xkcyB0aGUgcG9zaXRpb24sIGlmIHBvc3NpYmxlXG4gICAgICAgIHdoaWxlICh0aGlzLmZyb20gPT0gdGhpcy50byB8fFxuICAgICAgICAgICAgKHNpZGUgPCAxID8gdGhpcy5mcm9tID49IHBvcyA6IHRoaXMuZnJvbSA+IHBvcykgfHxcbiAgICAgICAgICAgIChzaWRlID4gLTEgPyB0aGlzLnRvIDw9IHBvcyA6IHRoaXMudG8gPCBwb3MpKVxuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBUaGVuIHNjYW4gZG93biBpbnRvIGNoaWxkIG5vZGVzIGFzIGZhciBhcyBwb3NzaWJsZVxuICAgICAgICB3aGlsZSAodGhpcy5lbnRlckNoaWxkKDEsIHBvcywgc2lkZSkpIHsgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8vIEdldCBhIFtzeW50YXggbm9kZV0oI2NvbW1vbi5TeW50YXhOb2RlKSBhdCB0aGUgY3Vyc29yJ3MgY3VycmVudFxuICAgIC8vLyBwb3NpdGlvbi5cbiAgICBnZXQgbm9kZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmVlO1xuICAgICAgICBsZXQgY2FjaGUgPSB0aGlzLmJ1ZmZlck5vZGUsIHJlc3VsdCA9IG51bGwsIGRlcHRoID0gMDtcbiAgICAgICAgaWYgKGNhY2hlICYmIGNhY2hlLmNvbnRleHQgPT0gdGhpcy5idWZmZXIpIHtcbiAgICAgICAgICAgIHNjYW46IGZvciAobGV0IGluZGV4ID0gdGhpcy5pbmRleCwgZCA9IHRoaXMuc3RhY2subGVuZ3RoOyBkID49IDA7KSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYyA9IGNhY2hlOyBjOyBjID0gYy5fcGFyZW50KVxuICAgICAgICAgICAgICAgICAgICBpZiAoYy5pbmRleCA9PSBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09IHRoaXMuaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGggPSBkICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHNjYW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMuc3RhY2tbLS1kXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gZGVwdGg7IGkgPCB0aGlzLnN0YWNrLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEJ1ZmZlck5vZGUodGhpcy5idWZmZXIsIHJlc3VsdCwgdGhpcy5zdGFja1tpXSk7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlck5vZGUgPSBuZXcgQnVmZmVyTm9kZSh0aGlzLmJ1ZmZlciwgcmVzdWx0LCB0aGlzLmluZGV4KTtcbiAgICB9XG4gICAgLy8vIEdldCB0aGUgW3RyZWVdKCNjb21tb24uVHJlZSkgdGhhdCByZXByZXNlbnRzIHRoZSBjdXJyZW50IG5vZGUsIGlmXG4gICAgLy8vIGFueS4gV2lsbCByZXR1cm4gbnVsbCB3aGVuIHRoZSBub2RlIGlzIGluIGEgW3RyZWVcbiAgICAvLy8gYnVmZmVyXSgjY29tbW9uLlRyZWVCdWZmZXIpLlxuICAgIGdldCB0cmVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIgPyBudWxsIDogdGhpcy5fdHJlZS5ub2RlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhc0NoaWxkKHRyZWUpIHtcbiAgICByZXR1cm4gdHJlZS5jaGlsZHJlbi5zb21lKGNoID0+IGNoIGluc3RhbmNlb2YgVHJlZUJ1ZmZlciB8fCAhY2gudHlwZS5pc0Fub255bW91cyB8fCBoYXNDaGlsZChjaCkpO1xufVxuZnVuY3Rpb24gYnVpbGRUcmVlKGRhdGEpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHsgYnVmZmVyLCBub2RlU2V0LCBtYXhCdWZmZXJMZW5ndGggPSBEZWZhdWx0QnVmZmVyTGVuZ3RoLCByZXVzZWQgPSBbXSwgbWluUmVwZWF0VHlwZSA9IG5vZGVTZXQudHlwZXMubGVuZ3RoIH0gPSBkYXRhO1xuICAgIGxldCBjdXJzb3IgPSBBcnJheS5pc0FycmF5KGJ1ZmZlcikgPyBuZXcgRmxhdEJ1ZmZlckN1cnNvcihidWZmZXIsIGJ1ZmZlci5sZW5ndGgpIDogYnVmZmVyO1xuICAgIGxldCB0eXBlcyA9IG5vZGVTZXQudHlwZXM7XG4gICAgbGV0IGNvbnRleHRIYXNoID0gMCwgbG9va0FoZWFkID0gMDtcbiAgICBmdW5jdGlvbiB0YWtlTm9kZShwYXJlbnRTdGFydCwgbWluUG9zLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBpblJlcGVhdCkge1xuICAgICAgICBsZXQgeyBpZCwgc3RhcnQsIGVuZCwgc2l6ZSB9ID0gY3Vyc29yO1xuICAgICAgICBsZXQgbG9va0FoZWFkQXRTdGFydCA9IGxvb2tBaGVhZDtcbiAgICAgICAgd2hpbGUgKHNpemUgPCAwKSB7XG4gICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgaWYgKHNpemUgPT0gLTEgLyogUmV1c2UgKi8pIHtcbiAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IHJldXNlZFtpZF07XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbnMucHVzaChzdGFydCAtIHBhcmVudFN0YXJ0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaXplID09IC0zIC8qIENvbnRleHRDaGFuZ2UgKi8pIHsgLy8gQ29udGV4dCBjaGFuZ2VcbiAgICAgICAgICAgICAgICBjb250ZXh0SGFzaCA9IGlkO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNpemUgPT0gLTQgLyogTG9va0FoZWFkICovKSB7XG4gICAgICAgICAgICAgICAgbG9va0FoZWFkID0gaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFVucmVjb2duaXplZCByZWNvcmQgc2l6ZTogJHtzaXplfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCB0eXBlID0gdHlwZXNbaWRdLCBub2RlLCBidWZmZXI7XG4gICAgICAgIGxldCBzdGFydFBvcyA9IHN0YXJ0IC0gcGFyZW50U3RhcnQ7XG4gICAgICAgIGlmIChlbmQgLSBzdGFydCA8PSBtYXhCdWZmZXJMZW5ndGggJiYgKGJ1ZmZlciA9IGZpbmRCdWZmZXJTaXplKGN1cnNvci5wb3MgLSBtaW5Qb3MsIGluUmVwZWF0KSkpIHtcbiAgICAgICAgICAgIC8vIFNtYWxsIGVub3VnaCBmb3IgYSBidWZmZXIsIGFuZCBubyByZXVzZWQgbm9kZXMgaW5zaWRlXG4gICAgICAgICAgICBsZXQgZGF0YSA9IG5ldyBVaW50MTZBcnJheShidWZmZXIuc2l6ZSAtIGJ1ZmZlci5za2lwKTtcbiAgICAgICAgICAgIGxldCBlbmRQb3MgPSBjdXJzb3IucG9zIC0gYnVmZmVyLnNpemUsIGluZGV4ID0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IGVuZFBvcylcbiAgICAgICAgICAgICAgICBpbmRleCA9IGNvcHlUb0J1ZmZlcihidWZmZXIuc3RhcnQsIGRhdGEsIGluZGV4KTtcbiAgICAgICAgICAgIG5vZGUgPSBuZXcgVHJlZUJ1ZmZlcihkYXRhLCBlbmQgLSBidWZmZXIuc3RhcnQsIG5vZGVTZXQpO1xuICAgICAgICAgICAgc3RhcnRQb3MgPSBidWZmZXIuc3RhcnQgLSBwYXJlbnRTdGFydDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gTWFrZSBpdCBhIG5vZGVcbiAgICAgICAgICAgIGxldCBlbmRQb3MgPSBjdXJzb3IucG9zIC0gc2l6ZTtcbiAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICBsZXQgbG9jYWxDaGlsZHJlbiA9IFtdLCBsb2NhbFBvc2l0aW9ucyA9IFtdO1xuICAgICAgICAgICAgbGV0IGxvY2FsSW5SZXBlYXQgPSBpZCA+PSBtaW5SZXBlYXRUeXBlID8gaWQgOiAtMTtcbiAgICAgICAgICAgIGxldCBsYXN0R3JvdXAgPSAwLCBsYXN0RW5kID0gZW5kO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnNvci5wb3MgPiBlbmRQb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxJblJlcGVhdCA+PSAwICYmIGN1cnNvci5pZCA9PSBsb2NhbEluUmVwZWF0ICYmIGN1cnNvci5zaXplID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnNvci5lbmQgPD0gbGFzdEVuZCAtIG1heEJ1ZmZlckxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZVJlcGVhdExlYWYobG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIHN0YXJ0LCBsYXN0R3JvdXAsIGN1cnNvci5lbmQsIGxhc3RFbmQsIGxvY2FsSW5SZXBlYXQsIGxvb2tBaGVhZEF0U3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdyb3VwID0gbG9jYWxDaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0RW5kID0gY3Vyc29yLmVuZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFrZU5vZGUoc3RhcnQsIGVuZFBvcywgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIGxvY2FsSW5SZXBlYXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsb2NhbEluUmVwZWF0ID49IDAgJiYgbGFzdEdyb3VwID4gMCAmJiBsYXN0R3JvdXAgPCBsb2NhbENoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgICAgICBtYWtlUmVwZWF0TGVhZihsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgc3RhcnQsIGxhc3RHcm91cCwgc3RhcnQsIGxhc3RFbmQsIGxvY2FsSW5SZXBlYXQsIGxvb2tBaGVhZEF0U3RhcnQpO1xuICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5yZXZlcnNlKCk7XG4gICAgICAgICAgICBsb2NhbFBvc2l0aW9ucy5yZXZlcnNlKCk7XG4gICAgICAgICAgICBpZiAobG9jYWxJblJlcGVhdCA+IC0xICYmIGxhc3RHcm91cCA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFrZSA9IG1ha2VCYWxhbmNlZCh0eXBlKTtcbiAgICAgICAgICAgICAgICBub2RlID0gYmFsYW5jZVJhbmdlKHR5cGUsIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCAwLCBsb2NhbENoaWxkcmVuLmxlbmd0aCwgMCwgZW5kIC0gc3RhcnQsIG1ha2UsIG1ha2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG1ha2VUcmVlKHR5cGUsIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBlbmQgLSBzdGFydCwgbG9va0FoZWFkQXRTdGFydCAtIGVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goc3RhcnRQb3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlQmFsYW5jZWQodHlwZSkge1xuICAgICAgICByZXR1cm4gKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCkgPT4ge1xuICAgICAgICAgICAgbGV0IGxvb2tBaGVhZCA9IDAsIGxhc3RJID0gY2hpbGRyZW4ubGVuZ3RoIC0gMSwgbGFzdCwgbG9va0FoZWFkUHJvcDtcbiAgICAgICAgICAgIGlmIChsYXN0SSA+PSAwICYmIChsYXN0ID0gY2hpbGRyZW5bbGFzdEldKSBpbnN0YW5jZW9mIFRyZWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWxhc3RJICYmIGxhc3QudHlwZSA9PSB0eXBlICYmIGxhc3QubGVuZ3RoID09IGxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhc3Q7XG4gICAgICAgICAgICAgICAgaWYgKGxvb2tBaGVhZFByb3AgPSBsYXN0LnByb3AoTm9kZVByb3AubG9va0FoZWFkKSlcbiAgICAgICAgICAgICAgICAgICAgbG9va0FoZWFkID0gcG9zaXRpb25zW2xhc3RJXSArIGxhc3QubGVuZ3RoICsgbG9va0FoZWFkUHJvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYWtlVHJlZSh0eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgsIGxvb2tBaGVhZCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VSZXBlYXRMZWFmKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGJhc2UsIGksIGZyb20sIHRvLCB0eXBlLCBsb29rQWhlYWQpIHtcbiAgICAgICAgbGV0IGxvY2FsQ2hpbGRyZW4gPSBbXSwgbG9jYWxQb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgd2hpbGUgKGNoaWxkcmVuLmxlbmd0aCA+IGkpIHtcbiAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaChjaGlsZHJlbi5wb3AoKSk7XG4gICAgICAgICAgICBsb2NhbFBvc2l0aW9ucy5wdXNoKHBvc2l0aW9ucy5wb3AoKSArIGJhc2UgLSBmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbi5wdXNoKG1ha2VUcmVlKG5vZGVTZXQudHlwZXNbdHlwZV0sIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCB0byAtIGZyb20sIGxvb2tBaGVhZCAtIHRvKSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKGZyb20gLSBiYXNlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZVRyZWUodHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoLCBsb29rQWhlYWQgPSAwLCBwcm9wcykge1xuICAgICAgICBpZiAoY29udGV4dEhhc2gpIHtcbiAgICAgICAgICAgIGxldCBwYWlyID0gW05vZGVQcm9wLmNvbnRleHRIYXNoLCBjb250ZXh0SGFzaF07XG4gICAgICAgICAgICBwcm9wcyA9IHByb3BzID8gW3BhaXJdLmNvbmNhdChwcm9wcykgOiBbcGFpcl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvb2tBaGVhZCA+IDI1KSB7XG4gICAgICAgICAgICBsZXQgcGFpciA9IFtOb2RlUHJvcC5sb29rQWhlYWQsIGxvb2tBaGVhZF07XG4gICAgICAgICAgICBwcm9wcyA9IHByb3BzID8gW3BhaXJdLmNvbmNhdChwcm9wcykgOiBbcGFpcl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlKHR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCwgcHJvcHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kQnVmZmVyU2l6ZShtYXhTaXplLCBpblJlcGVhdCkge1xuICAgICAgICAvLyBTY2FuIHRocm91Z2ggdGhlIGJ1ZmZlciB0byBmaW5kIHByZXZpb3VzIHNpYmxpbmdzIHRoYXQgZml0XG4gICAgICAgIC8vIHRvZ2V0aGVyIGluIGEgVHJlZUJ1ZmZlciwgYW5kIGRvbid0IGNvbnRhaW4gYW55IHJldXNlZCBub2Rlc1xuICAgICAgICAvLyAod2hpY2ggY2FuJ3QgYmUgc3RvcmVkIGluIGEgYnVmZmVyKS5cbiAgICAgICAgLy8gSWYgYGluUmVwZWF0YCBpcyA+IC0xLCBpZ25vcmUgbm9kZSBib3VuZGFyaWVzIG9mIHRoYXQgdHlwZSBmb3JcbiAgICAgICAgLy8gbmVzdGluZywgYnV0IG1ha2Ugc3VyZSB0aGUgZW5kIGZhbGxzIGVpdGhlciBhdCB0aGUgc3RhcnRcbiAgICAgICAgLy8gKGBtYXhTaXplYCkgb3IgYmVmb3JlIHN1Y2ggYSBub2RlLlxuICAgICAgICBsZXQgZm9yayA9IGN1cnNvci5mb3JrKCk7XG4gICAgICAgIGxldCBzaXplID0gMCwgc3RhcnQgPSAwLCBza2lwID0gMCwgbWluU3RhcnQgPSBmb3JrLmVuZCAtIG1heEJ1ZmZlckxlbmd0aDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgc2l6ZTogMCwgc3RhcnQ6IDAsIHNraXA6IDAgfTtcbiAgICAgICAgc2NhbjogZm9yIChsZXQgbWluUG9zID0gZm9yay5wb3MgLSBtYXhTaXplOyBmb3JrLnBvcyA+IG1pblBvczspIHtcbiAgICAgICAgICAgIGxldCBub2RlU2l6ZSA9IGZvcmsuc2l6ZTtcbiAgICAgICAgICAgIC8vIFByZXRlbmQgbmVzdGVkIHJlcGVhdCBub2RlcyBvZiB0aGUgc2FtZSB0eXBlIGRvbid0IGV4aXN0XG4gICAgICAgICAgICBpZiAoZm9yay5pZCA9PSBpblJlcGVhdCAmJiBub2RlU2l6ZSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gRXhjZXB0IHRoYXQgd2Ugc3RvcmUgdGhlIGN1cnJlbnQgc3RhdGUgYXMgYSB2YWxpZCByZXR1cm5cbiAgICAgICAgICAgICAgICAvLyB2YWx1ZS5cbiAgICAgICAgICAgICAgICByZXN1bHQuc2l6ZSA9IHNpemU7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNraXAgPSBza2lwO1xuICAgICAgICAgICAgICAgIHNraXAgKz0gNDtcbiAgICAgICAgICAgICAgICBzaXplICs9IDQ7XG4gICAgICAgICAgICAgICAgZm9yay5uZXh0KCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc3RhcnRQb3MgPSBmb3JrLnBvcyAtIG5vZGVTaXplO1xuICAgICAgICAgICAgaWYgKG5vZGVTaXplIDwgMCB8fCBzdGFydFBvcyA8IG1pblBvcyB8fCBmb3JrLnN0YXJ0IDwgbWluU3RhcnQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgbG9jYWxTa2lwcGVkID0gZm9yay5pZCA+PSBtaW5SZXBlYXRUeXBlID8gNCA6IDA7XG4gICAgICAgICAgICBsZXQgbm9kZVN0YXJ0ID0gZm9yay5zdGFydDtcbiAgICAgICAgICAgIGZvcmsubmV4dCgpO1xuICAgICAgICAgICAgd2hpbGUgKGZvcmsucG9zID4gc3RhcnRQb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9yay5zaXplIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9yay5zaXplID09IC0zIC8qIENvbnRleHRDaGFuZ2UgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFNraXBwZWQgKz0gNDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgc2NhbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9yay5pZCA+PSBtaW5SZXBlYXRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU2tpcHBlZCArPSA0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3JrLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXJ0ID0gbm9kZVN0YXJ0O1xuICAgICAgICAgICAgc2l6ZSArPSBub2RlU2l6ZTtcbiAgICAgICAgICAgIHNraXAgKz0gbG9jYWxTa2lwcGVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpblJlcGVhdCA8IDAgfHwgc2l6ZSA9PSBtYXhTaXplKSB7XG4gICAgICAgICAgICByZXN1bHQuc2l6ZSA9IHNpemU7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgIHJlc3VsdC5za2lwID0gc2tpcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LnNpemUgPiA0ID8gcmVzdWx0IDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb3B5VG9CdWZmZXIoYnVmZmVyU3RhcnQsIGJ1ZmZlciwgaW5kZXgpIHtcbiAgICAgICAgbGV0IHsgaWQsIHN0YXJ0LCBlbmQsIHNpemUgfSA9IGN1cnNvcjtcbiAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgaWYgKHNpemUgPj0gMCAmJiBpZCA8IG1pblJlcGVhdFR5cGUpIHtcbiAgICAgICAgICAgIGxldCBzdGFydEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICBpZiAoc2l6ZSA+IDQpIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5kUG9zID0gY3Vyc29yLnBvcyAtIChzaXplIC0gNCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1cnNvci5wb3MgPiBlbmRQb3MpXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gY29weVRvQnVmZmVyKGJ1ZmZlclN0YXJ0LCBidWZmZXIsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IHN0YXJ0SW5kZXg7XG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBlbmQgLSBidWZmZXJTdGFydDtcbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IHN0YXJ0IC0gYnVmZmVyU3RhcnQ7XG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBpZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzaXplID09IC0zIC8qIENvbnRleHRDaGFuZ2UgKi8pIHtcbiAgICAgICAgICAgIGNvbnRleHRIYXNoID0gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2l6ZSA9PSAtNCAvKiBMb29rQWhlYWQgKi8pIHtcbiAgICAgICAgICAgIGxvb2tBaGVhZCA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gICAgbGV0IGNoaWxkcmVuID0gW10sIHBvc2l0aW9ucyA9IFtdO1xuICAgIHdoaWxlIChjdXJzb3IucG9zID4gMClcbiAgICAgICAgdGFrZU5vZGUoZGF0YS5zdGFydCB8fCAwLCBkYXRhLmJ1ZmZlclN0YXJ0IHx8IDAsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIC0xKTtcbiAgICBsZXQgbGVuZ3RoID0gKF9hID0gZGF0YS5sZW5ndGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChjaGlsZHJlbi5sZW5ndGggPyBwb3NpdGlvbnNbMF0gKyBjaGlsZHJlblswXS5sZW5ndGggOiAwKTtcbiAgICByZXR1cm4gbmV3IFRyZWUodHlwZXNbZGF0YS50b3BJRF0sIGNoaWxkcmVuLnJldmVyc2UoKSwgcG9zaXRpb25zLnJldmVyc2UoKSwgbGVuZ3RoKTtcbn1cbmNvbnN0IG5vZGVTaXplQ2FjaGUgPSBuZXcgV2Vha01hcDtcbmZ1bmN0aW9uIG5vZGVTaXplKGJhbGFuY2VUeXBlLCBub2RlKSB7XG4gICAgaWYgKCFiYWxhbmNlVHlwZS5pc0Fub255bW91cyB8fCBub2RlIGluc3RhbmNlb2YgVHJlZUJ1ZmZlciB8fCBub2RlLnR5cGUgIT0gYmFsYW5jZVR5cGUpXG4gICAgICAgIHJldHVybiAxO1xuICAgIGxldCBzaXplID0gbm9kZVNpemVDYWNoZS5nZXQobm9kZSk7XG4gICAgaWYgKHNpemUgPT0gbnVsbCkge1xuICAgICAgICBzaXplID0gMTtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgIT0gYmFsYW5jZVR5cGUgfHwgIShjaGlsZCBpbnN0YW5jZW9mIFRyZWUpKSB7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaXplICs9IG5vZGVTaXplKGJhbGFuY2VUeXBlLCBjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZVNpemVDYWNoZS5zZXQobm9kZSwgc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiBzaXplO1xufVxuZnVuY3Rpb24gYmFsYW5jZVJhbmdlKFxuLy8gVGhlIHR5cGUgdGhlIGJhbGFuY2VkIHRyZWUncyBpbm5lciBub2Rlcy5cbmJhbGFuY2VUeXBlLCBcbi8vIFRoZSBkaXJlY3QgY2hpbGRyZW4gYW5kIHRoZWlyIHBvc2l0aW9uc1xuY2hpbGRyZW4sIHBvc2l0aW9ucywgXG4vLyBUaGUgaW5kZXggcmFuZ2UgaW4gY2hpbGRyZW4vcG9zaXRpb25zIHRvIHVzZVxuZnJvbSwgdG8sIFxuLy8gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSBub2RlcywgcmVsYXRpdmUgdG8gdGhlaXIgcGFyZW50Llxuc3RhcnQsIFxuLy8gTGVuZ3RoIG9mIHRoZSBvdXRlciBub2RlXG5sZW5ndGgsIFxuLy8gRnVuY3Rpb24gdG8gYnVpbGQgdGhlIHRvcCBub2RlIG9mIHRoZSBiYWxhbmNlZCB0cmVlXG5ta1RvcCwgXG4vLyBGdW5jdGlvbiB0byBidWlsZCBpbnRlcm5hbCBub2RlcyBmb3IgdGhlIGJhbGFuY2VkIHRyZWVcbm1rVHJlZSkge1xuICAgIGxldCB0b3RhbCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKVxuICAgICAgICB0b3RhbCArPSBub2RlU2l6ZShiYWxhbmNlVHlwZSwgY2hpbGRyZW5baV0pO1xuICAgIGxldCBtYXhDaGlsZCA9IE1hdGguY2VpbCgodG90YWwgKiAxLjUpIC8gOCAvKiBCcmFuY2hGYWN0b3IgKi8pO1xuICAgIGxldCBsb2NhbENoaWxkcmVuID0gW10sIGxvY2FsUG9zaXRpb25zID0gW107XG4gICAgZnVuY3Rpb24gZGl2aWRlKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGZyb20sIHRvLCBvZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzspIHtcbiAgICAgICAgICAgIGxldCBncm91cEZyb20gPSBpLCBncm91cFN0YXJ0ID0gcG9zaXRpb25zW2ldLCBncm91cFNpemUgPSBub2RlU2l6ZShiYWxhbmNlVHlwZSwgY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgZm9yICg7IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHRTaXplID0gbm9kZVNpemUoYmFsYW5jZVR5cGUsIGNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBTaXplICsgbmV4dFNpemUgPj0gbWF4Q2hpbGQpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGdyb3VwU2l6ZSArPSBuZXh0U2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID09IGdyb3VwRnJvbSArIDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBTaXplID4gbWF4Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9ubHkgPSBjaGlsZHJlbltncm91cEZyb21dOyAvLyBPbmx5IHRyZWVzIGNhbiBoYXZlIGEgc2l6ZSA+IDFcbiAgICAgICAgICAgICAgICAgICAgZGl2aWRlKG9ubHkuY2hpbGRyZW4sIG9ubHkucG9zaXRpb25zLCAwLCBvbmx5LmNoaWxkcmVuLmxlbmd0aCwgcG9zaXRpb25zW2dyb3VwRnJvbV0gKyBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5wdXNoKGNoaWxkcmVuW2dyb3VwRnJvbV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGxlbmd0aCA9IHBvc2l0aW9uc1tpIC0gMV0gKyBjaGlsZHJlbltpIC0gMV0ubGVuZ3RoIC0gZ3JvdXBTdGFydDtcbiAgICAgICAgICAgICAgICBsb2NhbENoaWxkcmVuLnB1c2goYmFsYW5jZVJhbmdlKGJhbGFuY2VUeXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBncm91cEZyb20sIGksIGdyb3VwU3RhcnQsIGxlbmd0aCwgbnVsbCwgbWtUcmVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2NhbFBvc2l0aW9ucy5wdXNoKGdyb3VwU3RhcnQgKyBvZmZzZXQgLSBzdGFydCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGl2aWRlKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGZyb20sIHRvLCAwKTtcbiAgICByZXR1cm4gKG1rVG9wIHx8IG1rVHJlZSkobG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIGxlbmd0aCk7XG59XG5cbi8vLyBUcmVlIGZyYWdtZW50cyBhcmUgdXNlZCBkdXJpbmcgW2luY3JlbWVudGFsXG4vLy8gcGFyc2luZ10oI2NvbW1vbi5QYXJzZXIuc3RhcnRQYXJzZSkgdG8gdHJhY2sgcGFydHMgb2Ygb2xkIHRyZWVzXG4vLy8gdGhhdCBjYW4gYmUgcmV1c2VkIGluIGEgbmV3IHBhcnNlLiBBbiBhcnJheSBvZiBmcmFnbWVudHMgaXMgdXNlZFxuLy8vIHRvIHRyYWNrIHJlZ2lvbnMgb2YgYW4gb2xkIHRyZWUgd2hvc2Ugbm9kZXMgbWlnaHQgYmUgcmV1c2VkIGluIG5ld1xuLy8vIHBhcnNlcy4gVXNlIHRoZSBzdGF0aWNcbi8vLyBbYGFwcGx5Q2hhbmdlc2BdKCNjb21tb24uVHJlZUZyYWdtZW50XmFwcGx5Q2hhbmdlcykgbWV0aG9kIHRvXG4vLy8gdXBkYXRlIGZyYWdtZW50cyBmb3IgZG9jdW1lbnQgY2hhbmdlcy5cbmNsYXNzIFRyZWVGcmFnbWVudCB7XG4gICAgLy8vIENvbnN0cnVjdCBhIHRyZWUgZnJhZ21lbnQuXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIFRoZSBzdGFydCBvZiB0aGUgdW5jaGFuZ2VkIHJhbmdlIHBvaW50ZWQgdG8gYnkgdGhpcyBmcmFnbWVudC5cbiAgICAvLy8gVGhpcyByZWZlcnMgdG8gYW4gb2Zmc2V0IGluIHRoZSBfdXBkYXRlZF8gZG9jdW1lbnQgKGFzIG9wcG9zZWRcbiAgICAvLy8gdG8gdGhlIG9yaWdpbmFsIHRyZWUpLlxuICAgIGZyb20sIFxuICAgIC8vLyBUaGUgZW5kIG9mIHRoZSB1bmNoYW5nZWQgcmFuZ2UuXG4gICAgdG8sIFxuICAgIC8vLyBUaGUgdHJlZSB0aGF0IHRoaXMgZnJhZ21lbnQgaXMgYmFzZWQgb24uXG4gICAgdHJlZSwgXG4gICAgLy8vIFRoZSBvZmZzZXQgYmV0d2VlbiB0aGUgZnJhZ21lbnQncyB0cmVlIGFuZCB0aGUgZG9jdW1lbnQgdGhhdFxuICAgIC8vLyB0aGlzIGZyYWdtZW50IGNhbiBiZSB1c2VkIGFnYWluc3QuIEFkZCB0aGlzIHdoZW4gZ29pbmcgZnJvbVxuICAgIC8vLyBkb2N1bWVudCB0byB0cmVlIHBvc2l0aW9ucywgc3VidHJhY3QgaXQgdG8gZ28gZnJvbSB0cmVlIHRvXG4gICAgLy8vIGRvY3VtZW50IHBvc2l0aW9ucy5cbiAgICBvZmZzZXQsIG9wZW5TdGFydCA9IGZhbHNlLCBvcGVuRW5kID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5vcGVuID0gKG9wZW5TdGFydCA/IDEgLyogU3RhcnQgKi8gOiAwKSB8IChvcGVuRW5kID8gMiAvKiBFbmQgKi8gOiAwKTtcbiAgICB9XG4gICAgLy8vIFdoZXRoZXIgdGhlIHN0YXJ0IG9mIHRoZSBmcmFnbWVudCByZXByZXNlbnRzIHRoZSBzdGFydCBvZiBhXG4gICAgLy8vIHBhcnNlLCBvciB0aGUgZW5kIG9mIGEgY2hhbmdlLiAoSW4gdGhlIHNlY29uZCBjYXNlLCBpdCBtYXkgbm90XG4gICAgLy8vIGJlIHNhZmUgdG8gcmV1c2Ugc29tZSBub2RlcyBhdCB0aGUgc3RhcnQsIGRlcGVuZGluZyBvbiB0aGVcbiAgICAvLy8gcGFyc2luZyBhbGdvcml0aG0uKVxuICAgIGdldCBvcGVuU3RhcnQoKSB7IHJldHVybiAodGhpcy5vcGVuICYgMSAvKiBTdGFydCAqLykgPiAwOyB9XG4gICAgLy8vIFdoZXRoZXIgdGhlIGVuZCBvZiB0aGUgZnJhZ21lbnQgcmVwcmVzZW50cyB0aGUgZW5kIG9mIGFcbiAgICAvLy8gZnVsbC1kb2N1bWVudCBwYXJzZSwgb3IgdGhlIHN0YXJ0IG9mIGEgY2hhbmdlLlxuICAgIGdldCBvcGVuRW5kKCkgeyByZXR1cm4gKHRoaXMub3BlbiAmIDIgLyogRW5kICovKSA+IDA7IH1cbiAgICAvLy8gQ3JlYXRlIGEgc2V0IG9mIGZyYWdtZW50cyBmcm9tIGEgZnJlc2hseSBwYXJzZWQgdHJlZSwgb3IgdXBkYXRlXG4gICAgLy8vIGFuIGV4aXN0aW5nIHNldCBvZiBmcmFnbWVudHMgYnkgcmVwbGFjaW5nIHRoZSBvbmVzIHRoYXQgb3ZlcmxhcFxuICAgIC8vLyB3aXRoIGEgdHJlZSB3aXRoIGNvbnRlbnQgZnJvbSB0aGUgbmV3IHRyZWUuIFdoZW4gYHBhcnRpYWxgIGlzXG4gICAgLy8vIHRydWUsIHRoZSBwYXJzZSBpcyB0cmVhdGVkIGFzIGluY29tcGxldGUsIGFuZCB0aGUgcmVzdWx0aW5nXG4gICAgLy8vIGZyYWdtZW50IGhhcyBbYG9wZW5FbmRgXSgjY29tbW9uLlRyZWVGcmFnbWVudC5vcGVuRW5kKSBzZXQgdG9cbiAgICAvLy8gdHJ1ZS5cbiAgICBzdGF0aWMgYWRkVHJlZSh0cmVlLCBmcmFnbWVudHMgPSBbXSwgcGFydGlhbCA9IGZhbHNlKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbbmV3IFRyZWVGcmFnbWVudCgwLCB0cmVlLmxlbmd0aCwgdHJlZSwgMCwgZmFsc2UsIHBhcnRpYWwpXTtcbiAgICAgICAgZm9yIChsZXQgZiBvZiBmcmFnbWVudHMpXG4gICAgICAgICAgICBpZiAoZi50byA+IHRyZWUubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGYpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLy8gQXBwbHkgYSBzZXQgb2YgZWRpdHMgdG8gYW4gYXJyYXkgb2YgZnJhZ21lbnRzLCByZW1vdmluZyBvclxuICAgIC8vLyBzcGxpdHRpbmcgZnJhZ21lbnRzIGFzIG5lY2Vzc2FyeSB0byByZW1vdmUgZWRpdGVkIHJhbmdlcywgYW5kXG4gICAgLy8vIGFkanVzdGluZyBvZmZzZXRzIGZvciBmcmFnbWVudHMgdGhhdCBtb3ZlZC5cbiAgICBzdGF0aWMgYXBwbHlDaGFuZ2VzKGZyYWdtZW50cywgY2hhbmdlcywgbWluR2FwID0gMTI4KSB7XG4gICAgICAgIGlmICghY2hhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnRzO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBmSSA9IDEsIG5leHRGID0gZnJhZ21lbnRzLmxlbmd0aCA/IGZyYWdtZW50c1swXSA6IG51bGw7XG4gICAgICAgIGZvciAobGV0IGNJID0gMCwgcG9zID0gMCwgb2ZmID0gMDs7IGNJKyspIHtcbiAgICAgICAgICAgIGxldCBuZXh0QyA9IGNJIDwgY2hhbmdlcy5sZW5ndGggPyBjaGFuZ2VzW2NJXSA6IG51bGw7XG4gICAgICAgICAgICBsZXQgbmV4dFBvcyA9IG5leHRDID8gbmV4dEMuZnJvbUEgOiAxZTk7XG4gICAgICAgICAgICBpZiAobmV4dFBvcyAtIHBvcyA+PSBtaW5HYXApXG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHRGICYmIG5leHRGLmZyb20gPCBuZXh0UG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXQgPSBuZXh0RjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA+PSBjdXQuZnJvbSB8fCBuZXh0UG9zIDw9IGN1dC50byB8fCBvZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmRnJvbSA9IE1hdGgubWF4KGN1dC5mcm9tLCBwb3MpIC0gb2ZmLCBmVG8gPSBNYXRoLm1pbihjdXQudG8sIG5leHRQb3MpIC0gb2ZmO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3V0ID0gZkZyb20gPj0gZlRvID8gbnVsbCA6IG5ldyBUcmVlRnJhZ21lbnQoZkZyb20sIGZUbywgY3V0LnRyZWUsIGN1dC5vZmZzZXQgKyBvZmYsIGNJID4gMCwgISFuZXh0Qyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1dClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Ri50byA+IG5leHRQb3MpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgbmV4dEYgPSBmSSA8IGZyYWdtZW50cy5sZW5ndGggPyBmcmFnbWVudHNbZkkrK10gOiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmV4dEMpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBwb3MgPSBuZXh0Qy50b0E7XG4gICAgICAgICAgICBvZmYgPSBuZXh0Qy50b0EgLSBuZXh0Qy50b0I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vLy8gQSBzdXBlcmNsYXNzIHRoYXQgcGFyc2VycyBzaG91bGQgZXh0ZW5kLlxuY2xhc3MgUGFyc2VyIHtcbiAgICAvLy8gU3RhcnQgYSBwYXJzZSwgcmV0dXJuaW5nIGEgW3BhcnRpYWwgcGFyc2VdKCNjb21tb24uUGFydGlhbFBhcnNlKVxuICAgIC8vLyBvYmplY3QuIFtgZnJhZ21lbnRzYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnQpIGNhbiBiZSBwYXNzZWQgaW4gdG9cbiAgICAvLy8gbWFrZSB0aGUgcGFyc2UgaW5jcmVtZW50YWwuXG4gICAgLy8vXG4gICAgLy8vIEJ5IGRlZmF1bHQsIHRoZSBlbnRpcmUgaW5wdXQgaXMgcGFyc2VkLiBZb3UgY2FuIHBhc3MgYHJhbmdlc2AsXG4gICAgLy8vIHdoaWNoIHNob3VsZCBiZSBhIHNvcnRlZCBhcnJheSBvZiBub24tZW1wdHksIG5vbi1vdmVybGFwcGluZ1xuICAgIC8vLyByYW5nZXMsIHRvIHBhcnNlIG9ubHkgdGhvc2UgcmFuZ2VzLiBUaGUgdHJlZSByZXR1cm5lZCBpbiB0aGF0XG4gICAgLy8vIGNhc2Ugd2lsbCBzdGFydCBhdCBgcmFuZ2VzWzBdLmZyb21gLlxuICAgIHN0YXJ0UGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGlucHV0ID0gbmV3IFN0cmluZ0lucHV0KGlucHV0KTtcbiAgICAgICAgcmFuZ2VzID0gIXJhbmdlcyA/IFtuZXcgUmFuZ2UoMCwgaW5wdXQubGVuZ3RoKV0gOiByYW5nZXMubGVuZ3RoID8gcmFuZ2VzLm1hcChyID0+IG5ldyBSYW5nZShyLmZyb20sIHIudG8pKSA6IFtuZXcgUmFuZ2UoMCwgMCldO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVQYXJzZShpbnB1dCwgZnJhZ21lbnRzIHx8IFtdLCByYW5nZXMpO1xuICAgIH1cbiAgICAvLy8gUnVuIGEgZnVsbCBwYXJzZSwgcmV0dXJuaW5nIHRoZSByZXN1bHRpbmcgdHJlZS5cbiAgICBwYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgbGV0IHBhcnNlID0gdGhpcy5zdGFydFBhcnNlKGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcyk7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBkb25lID0gcGFyc2UuYWR2YW5jZSgpO1xuICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbmU7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBTdHJpbmdJbnB1dCB7XG4gICAgY29uc3RydWN0b3Ioc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy5zdHJpbmcubGVuZ3RoOyB9XG4gICAgY2h1bmsoZnJvbSkgeyByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UoZnJvbSk7IH1cbiAgICBnZXQgbGluZUNodW5rcygpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgcmVhZChmcm9tLCB0bykgeyByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UoZnJvbSwgdG8pOyB9XG59XG5cbi8vLyBDcmVhdGUgYSBwYXJzZSB3cmFwcGVyIHRoYXQsIGFmdGVyIHRoZSBpbm5lciBwYXJzZSBjb21wbGV0ZXMsXG4vLy8gc2NhbnMgaXRzIHRyZWUgZm9yIG1peGVkIGxhbmd1YWdlIHJlZ2lvbnMgd2l0aCB0aGUgYG5lc3RgXG4vLy8gZnVuY3Rpb24sIHJ1bnMgdGhlIHJlc3VsdGluZyBbaW5uZXIgcGFyc2VzXSgjY29tbW9uLk5lc3RlZFBhcnNlKSxcbi8vLyBhbmQgdGhlbiBbbW91bnRzXSgjY29tbW9uLk5vZGVQcm9wXm1vdW50ZWQpIHRoZWlyIHJlc3VsdHMgb250byB0aGVcbi8vLyB0cmVlLlxuLy8vXG4vLy8gVGhlIG5lc3RpbmcgZnVuY3Rpb24gaXMgcGFzc2VkIGEgY3Vyc29yIHRvIHByb3ZpZGUgY29udGV4dCBmb3IgYVxuLy8vIG5vZGUsIGJ1dCBfc2hvdWxkIG5vdF8gbW92ZSB0aGF0IGN1cnNvciwgb25seSBpbnNwZWN0IGl0c1xuLy8vIHByb3BlcnRpZXMgYW5kIG9wdGlvbmFsbHkgYWNjZXNzIGl0c1xuLy8vIFtub2RlIG9iamVjdF0oI2NvbW1vbi5UcmVlQ3Vyc29yLm5vZGUpLlxuZnVuY3Rpb24gcGFyc2VNaXhlZChuZXN0KSB7XG4gICAgcmV0dXJuIChwYXJzZSwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSA9PiBuZXcgTWl4ZWRQYXJzZShwYXJzZSwgbmVzdCwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKTtcbn1cbmNsYXNzIElubmVyUGFyc2Uge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgcGFyc2UsIG92ZXJsYXksIHRhcmdldCwgcmFuZ2VzKSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLnBhcnNlID0gcGFyc2U7XG4gICAgICAgIHRoaXMub3ZlcmxheSA9IG92ZXJsYXk7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICB9XG59XG5jbGFzcyBBY3RpdmVPdmVybGF5IHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIHByZWRpY2F0ZSwgbW91bnRzLCBpbmRleCwgc3RhcnQsIHRhcmdldCwgcHJldikge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIHRoaXMubW91bnRzID0gbW91bnRzO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMucHJldiA9IHByZXY7XG4gICAgICAgIHRoaXMuZGVwdGggPSAwO1xuICAgICAgICB0aGlzLnJhbmdlcyA9IFtdO1xuICAgIH1cbn1cbmNvbnN0IHN0b3BwZWRJbm5lciA9IG5ldyBOb2RlUHJvcCh7IHBlck5vZGU6IHRydWUgfSk7XG5jbGFzcyBNaXhlZFBhcnNlIHtcbiAgICBjb25zdHJ1Y3RvcihiYXNlLCBuZXN0LCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgdGhpcy5uZXN0ID0gbmVzdDtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIHRoaXMuaW5uZXIgPSBbXTtcbiAgICAgICAgdGhpcy5pbm5lckRvbmUgPSAwO1xuICAgICAgICB0aGlzLmJhc2VUcmVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBudWxsO1xuICAgICAgICB0aGlzLmJhc2VQYXJzZSA9IGJhc2U7XG4gICAgfVxuICAgIGFkdmFuY2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmJhc2VQYXJzZSkge1xuICAgICAgICAgICAgbGV0IGRvbmUgPSB0aGlzLmJhc2VQYXJzZS5hZHZhbmNlKCk7XG4gICAgICAgICAgICBpZiAoIWRvbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB0aGlzLmJhc2VQYXJzZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmJhc2VUcmVlID0gZG9uZTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRJbm5lcigpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RvcHBlZEF0ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaW5uZXIgb2YgdGhpcy5pbm5lcilcbiAgICAgICAgICAgICAgICAgICAgaW5uZXIucGFyc2Uuc3RvcEF0KHRoaXMuc3RvcHBlZEF0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbm5lckRvbmUgPT0gdGhpcy5pbm5lci5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLmJhc2VUcmVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RvcHBlZEF0ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFRyZWUocmVzdWx0LnR5cGUsIHJlc3VsdC5jaGlsZHJlbiwgcmVzdWx0LnBvc2l0aW9ucywgcmVzdWx0Lmxlbmd0aCwgcmVzdWx0LnByb3BWYWx1ZXMuY29uY2F0KFtbc3RvcHBlZElubmVyLCB0aGlzLnN0b3BwZWRBdF1dKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbm5lciA9IHRoaXMuaW5uZXJbdGhpcy5pbm5lckRvbmVdLCBkb25lID0gaW5uZXIucGFyc2UuYWR2YW5jZSgpO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgdGhpcy5pbm5lckRvbmUrKztcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBzb21ld2hhdCBkb2RneSBidXQgc3VwZXIgaGVscGZ1bCBoYWNrIHdoZXJlIHdlXG4gICAgICAgICAgICAvLyBwYXRjaCB1cCBub2RlcyBjcmVhdGVkIGJ5IHRoZSBpbm5lciBwYXJzZSAoYW5kIHRodXNcbiAgICAgICAgICAgIC8vIHByZXN1bWFibHkgbm90IGFsaWFzZWQgYW55d2hlcmUgZWxzZSkgdG8gaG9sZCB0aGUgaW5mb3JtYXRpb25cbiAgICAgICAgICAgIC8vIGFib3V0IHRoZSBpbm5lciBwYXJzZS5cbiAgICAgICAgICAgIGxldCBwcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwgaW5uZXIudGFyZ2V0LnByb3BzKTtcbiAgICAgICAgICAgIHByb3BzW05vZGVQcm9wLm1vdW50ZWQuaWRdID0gbmV3IE1vdW50ZWRUcmVlKGRvbmUsIGlubmVyLm92ZXJsYXksIGlubmVyLnBhcnNlcik7XG4gICAgICAgICAgICBpbm5lci50YXJnZXQucHJvcHMgPSBwcm9wcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZ2V0IHBhcnNlZFBvcygpIHtcbiAgICAgICAgaWYgKHRoaXMuYmFzZVBhcnNlKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLmlucHV0Lmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuaW5uZXJEb25lOyBpIDwgdGhpcy5pbm5lci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5uZXJbaV0ucmFuZ2VzWzBdLmZyb20gPCBwb3MpXG4gICAgICAgICAgICAgICAgcG9zID0gTWF0aC5taW4ocG9zLCB0aGlzLmlubmVyW2ldLnBhcnNlLnBhcnNlZFBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgc3RvcEF0KHBvcykge1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IHBvcztcbiAgICAgICAgaWYgKHRoaXMuYmFzZVBhcnNlKVxuICAgICAgICAgICAgdGhpcy5iYXNlUGFyc2Uuc3RvcEF0KHBvcyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmlubmVyRG9uZTsgaSA8IHRoaXMuaW5uZXIubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgdGhpcy5pbm5lcltpXS5wYXJzZS5zdG9wQXQocG9zKTtcbiAgICB9XG4gICAgc3RhcnRJbm5lcigpIHtcbiAgICAgICAgbGV0IGZyYWdtZW50Q3Vyc29yID0gbmV3IEZyYWdtZW50Q3Vyc29yKHRoaXMuZnJhZ21lbnRzKTtcbiAgICAgICAgbGV0IG92ZXJsYXkgPSBudWxsO1xuICAgICAgICBsZXQgY292ZXJlZCA9IG51bGw7XG4gICAgICAgIGxldCBjdXJzb3IgPSBuZXcgVHJlZUN1cnNvcihuZXcgVHJlZU5vZGUodGhpcy5iYXNlVHJlZSwgdGhpcy5yYW5nZXNbMF0uZnJvbSwgMCwgbnVsbCksIDEgLyogRnVsbCAqLyk7XG4gICAgICAgIHNjYW46IGZvciAobGV0IG5lc3QsIGlzQ292ZXJlZDsgdGhpcy5zdG9wcGVkQXQgPT0gbnVsbCB8fCBjdXJzb3IuZnJvbSA8IHRoaXMuc3RvcHBlZEF0Oykge1xuICAgICAgICAgICAgbGV0IGVudGVyID0gdHJ1ZSwgcmFuZ2U7XG4gICAgICAgICAgICBpZiAoZnJhZ21lbnRDdXJzb3IuaGFzTm9kZShjdXJzb3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hdGNoID0gb3ZlcmxheS5tb3VudHMuZmluZChtID0+IG0uZnJhZy5mcm9tIDw9IGN1cnNvci5mcm9tICYmIG0uZnJhZy50byA+PSBjdXJzb3IudG8gJiYgbS5tb3VudC5vdmVybGF5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgciBvZiBtYXRjaC5tb3VudC5vdmVybGF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZyb20gPSByLmZyb20gKyBtYXRjaC5wb3MsIHRvID0gci50byArIG1hdGNoLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbSA+PSBjdXJzb3IuZnJvbSAmJiB0byA8PSBjdXJzb3IudG8gJiYgIW92ZXJsYXkucmFuZ2VzLnNvbWUociA9PiByLmZyb20gPCB0byAmJiByLnRvID4gZnJvbSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXkucmFuZ2VzLnB1c2goeyBmcm9tLCB0byB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZW50ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvdmVyZWQgJiYgKGlzQ292ZXJlZCA9IGNoZWNrQ292ZXIoY292ZXJlZC5yYW5nZXMsIGN1cnNvci5mcm9tLCBjdXJzb3IudG8pKSkge1xuICAgICAgICAgICAgICAgIGVudGVyID0gaXNDb3ZlcmVkICE9IDIgLyogRnVsbCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFjdXJzb3IudHlwZS5pc0Fub255bW91cyAmJiBjdXJzb3IuZnJvbSA8IGN1cnNvci50byAmJiAobmVzdCA9IHRoaXMubmVzdChjdXJzb3IsIHRoaXMuaW5wdXQpKSkge1xuICAgICAgICAgICAgICAgIGlmICghY3Vyc29yLnRyZWUpXG4gICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsaXplKGN1cnNvcik7XG4gICAgICAgICAgICAgICAgbGV0IG9sZE1vdW50cyA9IGZyYWdtZW50Q3Vyc29yLmZpbmRNb3VudHMoY3Vyc29yLmZyb20sIG5lc3QucGFyc2VyKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5lc3Qub3ZlcmxheSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheSA9IG5ldyBBY3RpdmVPdmVybGF5KG5lc3QucGFyc2VyLCBuZXN0Lm92ZXJsYXksIG9sZE1vdW50cywgdGhpcy5pbm5lci5sZW5ndGgsIGN1cnNvci5mcm9tLCBjdXJzb3IudHJlZSwgb3ZlcmxheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZ2VzID0gcHVuY2hSYW5nZXModGhpcy5yYW5nZXMsIG5lc3Qub3ZlcmxheSB8fCBbbmV3IFJhbmdlKGN1cnNvci5mcm9tLCBjdXJzb3IudG8pXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbm5lci5wdXNoKG5ldyBJbm5lclBhcnNlKG5lc3QucGFyc2VyLCBuZXN0LnBhcnNlci5zdGFydFBhcnNlKHRoaXMuaW5wdXQsIGVudGVyRnJhZ21lbnRzKG9sZE1vdW50cywgcmFuZ2VzKSwgcmFuZ2VzKSwgbmVzdC5vdmVybGF5ID8gbmVzdC5vdmVybGF5Lm1hcChyID0+IG5ldyBSYW5nZShyLmZyb20gLSBjdXJzb3IuZnJvbSwgci50byAtIGN1cnNvci5mcm9tKSkgOiBudWxsLCBjdXJzb3IudHJlZSwgcmFuZ2VzKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmVzdC5vdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgZW50ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdmVyZWQgPSB7IHJhbmdlcywgZGVwdGg6IDAsIHByZXY6IGNvdmVyZWQgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvdmVybGF5ICYmIChyYW5nZSA9IG92ZXJsYXkucHJlZGljYXRlKGN1cnNvcikpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlID09PSB0cnVlKVxuICAgICAgICAgICAgICAgICAgICByYW5nZSA9IG5ldyBSYW5nZShjdXJzb3IuZnJvbSwgY3Vyc29yLnRvKTtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UuZnJvbSA8IHJhbmdlLnRvKVxuICAgICAgICAgICAgICAgICAgICBvdmVybGF5LnJhbmdlcy5wdXNoKHJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbnRlciAmJiBjdXJzb3IuZmlyc3RDaGlsZCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXkuZGVwdGgrKztcbiAgICAgICAgICAgICAgICBpZiAoY292ZXJlZClcbiAgICAgICAgICAgICAgICAgICAgY292ZXJlZC5kZXB0aCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3Vyc29yLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBzY2FuO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSAmJiAhLS1vdmVybGF5LmRlcHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZ2VzID0gcHVuY2hSYW5nZXModGhpcy5yYW5nZXMsIG92ZXJsYXkucmFuZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5uZXIuc3BsaWNlKG92ZXJsYXkuaW5kZXgsIDAsIG5ldyBJbm5lclBhcnNlKG92ZXJsYXkucGFyc2VyLCBvdmVybGF5LnBhcnNlci5zdGFydFBhcnNlKHRoaXMuaW5wdXQsIGVudGVyRnJhZ21lbnRzKG92ZXJsYXkubW91bnRzLCByYW5nZXMpLCByYW5nZXMpLCBvdmVybGF5LnJhbmdlcy5tYXAociA9PiBuZXcgUmFuZ2Uoci5mcm9tIC0gb3ZlcmxheS5zdGFydCwgci50byAtIG92ZXJsYXkuc3RhcnQpKSwgb3ZlcmxheS50YXJnZXQsIHJhbmdlcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheSA9IG92ZXJsYXkucHJldjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY292ZXJlZCAmJiAhLS1jb3ZlcmVkLmRlcHRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgY292ZXJlZCA9IGNvdmVyZWQucHJldjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja0NvdmVyKGNvdmVyZWQsIGZyb20sIHRvKSB7XG4gICAgZm9yIChsZXQgcmFuZ2Ugb2YgY292ZXJlZCkge1xuICAgICAgICBpZiAocmFuZ2UuZnJvbSA+PSB0bylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAocmFuZ2UudG8gPiBmcm9tKVxuICAgICAgICAgICAgcmV0dXJuIHJhbmdlLmZyb20gPD0gZnJvbSAmJiByYW5nZS50byA+PSB0byA/IDIgLyogRnVsbCAqLyA6IDEgLyogUGFydGlhbCAqLztcbiAgICB9XG4gICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbn1cbi8vIFRha2UgYSBwaWVjZSBvZiBidWZmZXIgYW5kIGNvbnZlcnQgaXQgaW50byBhIHN0YW5kLWFsb25lXG4vLyBUcmVlQnVmZmVyLlxuZnVuY3Rpb24gc2xpY2VCdWYoYnVmLCBzdGFydEksIGVuZEksIG5vZGVzLCBwb3NpdGlvbnMsIG9mZikge1xuICAgIGlmIChzdGFydEkgPCBlbmRJKSB7XG4gICAgICAgIGxldCBmcm9tID0gYnVmLmJ1ZmZlcltzdGFydEkgKyAxXSwgdG8gPSBidWYuYnVmZmVyW2VuZEkgLSAyXTtcbiAgICAgICAgbm9kZXMucHVzaChidWYuc2xpY2Uoc3RhcnRJLCBlbmRJLCBmcm9tLCB0bykpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaChmcm9tIC0gb2ZmKTtcbiAgICB9XG59XG4vLyBUaGlzIGZ1bmN0aW9uIHRha2VzIGEgbm9kZSB0aGF0J3MgaW4gYSBidWZmZXIsIGFuZCBjb252ZXJ0cyBpdCwgYW5kXG4vLyBpdHMgcGFyZW50IGJ1ZmZlciBub2RlcywgaW50byBhIFRyZWUuIFRoaXMgaXMgYWdhaW4gYWN0aW5nIG9uIHRoZVxuLy8gYXNzdW1wdGlvbiB0aGF0IHRoZSB0cmVlcyBhbmQgYnVmZmVycyBoYXZlIGJlZW4gY29uc3RydWN0ZWQgYnkgdGhlXG4vLyBwYXJzZSB0aGF0IHdhcyByYW4gdmlhIHRoZSBtaXggcGFyc2VyLCBhbmQgdGh1cyBhcmVuJ3Qgc2hhcmVkIHdpdGhcbi8vIGFueSBvdGhlciBjb2RlLCBtYWtpbmcgdmlvbGF0aW9ucyBvZiB0aGUgaW1tdXRhYmlsaXR5IHNhZmUuXG5mdW5jdGlvbiBtYXRlcmlhbGl6ZShjdXJzb3IpIHtcbiAgICBsZXQgeyBub2RlIH0gPSBjdXJzb3IsIGRlcHRoID0gMDtcbiAgICAvLyBTY2FuIHVwIHRvIHRoZSBuZWFyZXN0IHRyZWVcbiAgICBkbyB7XG4gICAgICAgIGN1cnNvci5wYXJlbnQoKTtcbiAgICAgICAgZGVwdGgrKztcbiAgICB9IHdoaWxlICghY3Vyc29yLnRyZWUpO1xuICAgIC8vIEZpbmQgdGhlIGluZGV4IG9mIHRoZSBidWZmZXIgaW4gdGhhdCB0cmVlXG4gICAgbGV0IGkgPSAwLCBiYXNlID0gY3Vyc29yLnRyZWUsIG9mZiA9IDA7XG4gICAgZm9yICg7OyBpKyspIHtcbiAgICAgICAgb2ZmID0gYmFzZS5wb3NpdGlvbnNbaV0gKyBjdXJzb3IuZnJvbTtcbiAgICAgICAgaWYgKG9mZiA8PSBub2RlLmZyb20gJiYgb2ZmICsgYmFzZS5jaGlsZHJlbltpXS5sZW5ndGggPj0gbm9kZS50bylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBsZXQgYnVmID0gYmFzZS5jaGlsZHJlbltpXSwgYiA9IGJ1Zi5idWZmZXI7XG4gICAgLy8gU3BsaXQgYSBsZXZlbCBpbiB0aGUgYnVmZmVyLCBwdXR0aW5nIHRoZSBub2RlcyBiZWZvcmUgYW5kIGFmdGVyXG4gICAgLy8gdGhlIGNoaWxkIHRoYXQgY29udGFpbnMgYG5vZGVgIGludG8gbmV3IGJ1ZmZlcnMuXG4gICAgZnVuY3Rpb24gc3BsaXQoc3RhcnRJLCBlbmRJLCB0eXBlLCBpbm5lck9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgIGxldCBpID0gc3RhcnRJO1xuICAgICAgICB3aGlsZSAoYltpICsgMl0gKyBvZmYgPD0gbm9kZS5mcm9tKVxuICAgICAgICAgICAgaSA9IGJbaSArIDNdO1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBbXSwgcG9zaXRpb25zID0gW107XG4gICAgICAgIHNsaWNlQnVmKGJ1Ziwgc3RhcnRJLCBpLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBpbm5lck9mZnNldCk7XG4gICAgICAgIGxldCBmcm9tID0gYltpICsgMV0sIHRvID0gYltpICsgMl07XG4gICAgICAgIGxldCBpc1RhcmdldCA9IGZyb20gKyBvZmYgPT0gbm9kZS5mcm9tICYmIHRvICsgb2ZmID09IG5vZGUudG8gJiYgYltpXSA9PSBub2RlLnR5cGUuaWQ7XG4gICAgICAgIGNoaWxkcmVuLnB1c2goaXNUYXJnZXQgPyBub2RlLnRvVHJlZSgpIDogc3BsaXQoaSArIDQsIGJbaSArIDNdLCBidWYuc2V0LnR5cGVzW2JbaV1dLCBmcm9tLCB0byAtIGZyb20pKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goZnJvbSAtIGlubmVyT2Zmc2V0KTtcbiAgICAgICAgc2xpY2VCdWYoYnVmLCBiW2kgKyAzXSwgZW5kSSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgaW5uZXJPZmZzZXQpO1xuICAgICAgICByZXR1cm4gbmV3IFRyZWUodHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKTtcbiAgICB9XG4gICAgYmFzZS5jaGlsZHJlbltpXSA9IHNwbGl0KDAsIGIubGVuZ3RoLCBOb2RlVHlwZS5ub25lLCAwLCBidWYubGVuZ3RoKTtcbiAgICAvLyBNb3ZlIHRoZSBjdXJzb3IgYmFjayB0byB0aGUgdGFyZ2V0IG5vZGVcbiAgICBmb3IgKGxldCBkID0gMDsgZCA8PSBkZXB0aDsgZCsrKVxuICAgICAgICBjdXJzb3IuY2hpbGRBZnRlcihub2RlLmZyb20pO1xufVxuY2xhc3MgU3RydWN0dXJlQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3Rvcihyb290LCBvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmN1cnNvciA9IHJvb3QuZnVsbEN1cnNvcigpO1xuICAgIH1cbiAgICAvLyBNb3ZlIHRvIHRoZSBmaXJzdCBub2RlIChpbiBwcmUtb3JkZXIpIHRoYXQgc3RhcnRzIGF0IG9yIGFmdGVyIGBwb3NgLlxuICAgIG1vdmVUbyhwb3MpIHtcbiAgICAgICAgbGV0IHsgY3Vyc29yIH0gPSB0aGlzLCBwID0gcG9zIC0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIHdoaWxlICghdGhpcy5kb25lICYmIGN1cnNvci5mcm9tIDwgcCkge1xuICAgICAgICAgICAgaWYgKGN1cnNvci50byA+PSBwb3MgJiYgY3Vyc29yLmVudGVyKHAsIDEsIGZhbHNlLCBmYWxzZSkpIDtcbiAgICAgICAgICAgIGVsc2UgaWYgKCFjdXJzb3IubmV4dChmYWxzZSkpXG4gICAgICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXNOb2RlKGN1cnNvcikge1xuICAgICAgICB0aGlzLm1vdmVUbyhjdXJzb3IuZnJvbSk7XG4gICAgICAgIGlmICghdGhpcy5kb25lICYmIHRoaXMuY3Vyc29yLmZyb20gKyB0aGlzLm9mZnNldCA9PSBjdXJzb3IuZnJvbSAmJiB0aGlzLmN1cnNvci50cmVlKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB0cmVlID0gdGhpcy5jdXJzb3IudHJlZTs7KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyZWUgPT0gY3Vyc29yLnRyZWUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICh0cmVlLmNoaWxkcmVuLmxlbmd0aCAmJiB0cmVlLnBvc2l0aW9uc1swXSA9PSAwICYmIHRyZWUuY2hpbGRyZW5bMF0gaW5zdGFuY2VvZiBUcmVlKVxuICAgICAgICAgICAgICAgICAgICB0cmVlID0gdHJlZS5jaGlsZHJlblswXTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5jbGFzcyBGcmFnbWVudEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnRzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHM7XG4gICAgICAgIHRoaXMuY3VyVG8gPSAwO1xuICAgICAgICB0aGlzLmZyYWdJID0gMDtcbiAgICAgICAgaWYgKGZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IHRoaXMuY3VyRnJhZyA9IGZyYWdtZW50c1swXTtcbiAgICAgICAgICAgIHRoaXMuY3VyVG8gPSAoX2EgPSBmaXJzdC50cmVlLnByb3Aoc3RvcHBlZElubmVyKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmlyc3QudG87XG4gICAgICAgICAgICB0aGlzLmlubmVyID0gbmV3IFN0cnVjdHVyZUN1cnNvcihmaXJzdC50cmVlLCAtZmlyc3Qub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VyRnJhZyA9IHRoaXMuaW5uZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhc05vZGUobm9kZSkge1xuICAgICAgICB3aGlsZSAodGhpcy5jdXJGcmFnICYmIG5vZGUuZnJvbSA+PSB0aGlzLmN1clRvKVxuICAgICAgICAgICAgdGhpcy5uZXh0RnJhZygpO1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJGcmFnICYmIHRoaXMuY3VyRnJhZy5mcm9tIDw9IG5vZGUuZnJvbSAmJiB0aGlzLmN1clRvID49IG5vZGUudG8gJiYgdGhpcy5pbm5lci5oYXNOb2RlKG5vZGUpO1xuICAgIH1cbiAgICBuZXh0RnJhZygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmZyYWdJKys7XG4gICAgICAgIGlmICh0aGlzLmZyYWdJID09IHRoaXMuZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5jdXJGcmFnID0gdGhpcy5pbm5lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZnJhZyA9IHRoaXMuY3VyRnJhZyA9IHRoaXMuZnJhZ21lbnRzW3RoaXMuZnJhZ0ldO1xuICAgICAgICAgICAgdGhpcy5jdXJUbyA9IChfYSA9IGZyYWcudHJlZS5wcm9wKHN0b3BwZWRJbm5lcikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZyYWcudG87XG4gICAgICAgICAgICB0aGlzLmlubmVyID0gbmV3IFN0cnVjdHVyZUN1cnNvcihmcmFnLnRyZWUsIC1mcmFnLm9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluZE1vdW50cyhwb3MsIHBhcnNlcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuaW5uZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaW5uZXIuY3Vyc29yLm1vdmVUbyhwb3MsIDEpO1xuICAgICAgICAgICAgZm9yIChsZXQgcG9zID0gdGhpcy5pbm5lci5jdXJzb3Iubm9kZTsgcG9zOyBwb3MgPSBwb3MucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IG1vdW50ID0gKF9hID0gcG9zLnRyZWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wcm9wKE5vZGVQcm9wLm1vdW50ZWQpO1xuICAgICAgICAgICAgICAgIGlmIChtb3VudCAmJiBtb3VudC5wYXJzZXIgPT0gcGFyc2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmZyYWdJOyBpIDwgdGhpcy5mcmFnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmcmFnID0gdGhpcy5mcmFnbWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZy5mcm9tID49IHBvcy50bylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFnLnRyZWUgPT0gdGhpcy5jdXJGcmFnLnRyZWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3M6IHBvcy5mcm9tIC0gZnJhZy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5mdW5jdGlvbiBwdW5jaFJhbmdlcyhvdXRlciwgcmFuZ2VzKSB7XG4gICAgbGV0IGNvcHkgPSBudWxsLCBjdXJyZW50ID0gcmFuZ2VzO1xuICAgIGZvciAobGV0IGkgPSAxLCBqID0gMDsgaSA8IG91dGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBnYXBGcm9tID0gb3V0ZXJbaSAtIDFdLnRvLCBnYXBUbyA9IG91dGVyW2ldLmZyb207XG4gICAgICAgIGZvciAoOyBqIDwgY3VycmVudC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbGV0IHIgPSBjdXJyZW50W2pdO1xuICAgICAgICAgICAgaWYgKHIuZnJvbSA+PSBnYXBUbylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChyLnRvIDw9IGdhcEZyb20pXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoIWNvcHkpXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGNvcHkgPSByYW5nZXMuc2xpY2UoKTtcbiAgICAgICAgICAgIGlmIChyLmZyb20gPCBnYXBGcm9tKSB7XG4gICAgICAgICAgICAgICAgY29weVtqXSA9IG5ldyBSYW5nZShyLmZyb20sIGdhcEZyb20pO1xuICAgICAgICAgICAgICAgIGlmIChyLnRvID4gZ2FwVG8pXG4gICAgICAgICAgICAgICAgICAgIGNvcHkuc3BsaWNlKGogKyAxLCAwLCBuZXcgUmFuZ2UoZ2FwVG8sIHIudG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHIudG8gPiBnYXBUbykge1xuICAgICAgICAgICAgICAgIGNvcHlbai0tXSA9IG5ldyBSYW5nZShnYXBUbywgci50byk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3B5LnNwbGljZShqLS0sIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50O1xufVxuZnVuY3Rpb24gZmluZENvdmVyQ2hhbmdlcyhhLCBiLCBmcm9tLCB0bykge1xuICAgIGxldCBpQSA9IDAsIGlCID0gMCwgaW5BID0gZmFsc2UsIGluQiA9IGZhbHNlLCBwb3MgPSAtMWU5O1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGxldCBuZXh0QSA9IGlBID09IGEubGVuZ3RoID8gMWU5IDogaW5BID8gYVtpQV0udG8gOiBhW2lBXS5mcm9tO1xuICAgICAgICBsZXQgbmV4dEIgPSBpQiA9PSBiLmxlbmd0aCA/IDFlOSA6IGluQiA/IGJbaUJdLnRvIDogYltpQl0uZnJvbTtcbiAgICAgICAgaWYgKGluQSAhPSBpbkIpIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IE1hdGgubWF4KHBvcywgZnJvbSksIGVuZCA9IE1hdGgubWluKG5leHRBLCBuZXh0QiwgdG8pO1xuICAgICAgICAgICAgaWYgKHN0YXJ0IDwgZW5kKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBSYW5nZShzdGFydCwgZW5kKSk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gTWF0aC5taW4obmV4dEEsIG5leHRCKTtcbiAgICAgICAgaWYgKHBvcyA9PSAxZTkpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKG5leHRBID09IHBvcykge1xuICAgICAgICAgICAgaWYgKCFpbkEpXG4gICAgICAgICAgICAgICAgaW5BID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluQSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlBKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHRCID09IHBvcykge1xuICAgICAgICAgICAgaWYgKCFpbkIpXG4gICAgICAgICAgICAgICAgaW5CID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluQiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlCKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIEdpdmVuIGEgbnVtYmVyIG9mIGZyYWdtZW50cyBmb3IgdGhlIG91dGVyIHRyZWUsIGFuZCBhIHNldCBvZiByYW5nZXNcbi8vIHRvIHBhcnNlLCBmaW5kIGZyYWdtZW50cyBmb3IgaW5uZXIgdHJlZXMgbW91bnRlZCBhcm91bmQgdGhvc2Vcbi8vIHJhbmdlcywgaWYgYW55LlxuZnVuY3Rpb24gZW50ZXJGcmFnbWVudHMobW91bnRzLCByYW5nZXMpIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgeyBwb3MsIG1vdW50LCBmcmFnIH0gb2YgbW91bnRzKSB7XG4gICAgICAgIGxldCBzdGFydFBvcyA9IHBvcyArIChtb3VudC5vdmVybGF5ID8gbW91bnQub3ZlcmxheVswXS5mcm9tIDogMCksIGVuZFBvcyA9IHN0YXJ0UG9zICsgbW91bnQudHJlZS5sZW5ndGg7XG4gICAgICAgIGxldCBmcm9tID0gTWF0aC5tYXgoZnJhZy5mcm9tLCBzdGFydFBvcyksIHRvID0gTWF0aC5taW4oZnJhZy50bywgZW5kUG9zKTtcbiAgICAgICAgaWYgKG1vdW50Lm92ZXJsYXkpIHtcbiAgICAgICAgICAgIGxldCBvdmVybGF5ID0gbW91bnQub3ZlcmxheS5tYXAociA9PiBuZXcgUmFuZ2Uoci5mcm9tICsgcG9zLCByLnRvICsgcG9zKSk7XG4gICAgICAgICAgICBsZXQgY2hhbmdlcyA9IGZpbmRDb3ZlckNoYW5nZXMocmFuZ2VzLCBvdmVybGF5LCBmcm9tLCB0byk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gZnJvbTs7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBsYXN0ID0gaSA9PSBjaGFuZ2VzLmxlbmd0aCwgZW5kID0gbGFzdCA/IHRvIDogY2hhbmdlc1tpXS5mcm9tO1xuICAgICAgICAgICAgICAgIGlmIChlbmQgPiBwb3MpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBUcmVlRnJhZ21lbnQocG9zLCBlbmQsIG1vdW50LnRyZWUsIC1zdGFydFBvcywgZnJhZy5mcm9tID49IHBvcywgZnJhZy50byA8PSBlbmQpKTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgcG9zID0gY2hhbmdlc1tpXS50bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBUcmVlRnJhZ21lbnQoZnJvbSwgdG8sIG1vdW50LnRyZWUsIC1zdGFydFBvcywgZnJhZy5mcm9tID49IHN0YXJ0UG9zLCBmcmFnLnRvIDw9IGVuZFBvcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCB7IERlZmF1bHRCdWZmZXJMZW5ndGgsIE1vdW50ZWRUcmVlLCBOb2RlUHJvcCwgTm9kZVNldCwgTm9kZVR5cGUsIFBhcnNlciwgVHJlZSwgVHJlZUJ1ZmZlciwgVHJlZUN1cnNvciwgVHJlZUZyYWdtZW50LCBwYXJzZU1peGVkIH07XG4iLCJpbXBvcnQgeyBQYXJzZXIsIE5vZGVTZXQsIE5vZGVUeXBlLCBEZWZhdWx0QnVmZmVyTGVuZ3RoLCBOb2RlUHJvcCwgVHJlZSB9IGZyb20gJ0BsZXplci9jb21tb24nO1xuXG4vLy8gQSBwYXJzZSBzdGFjay4gVGhlc2UgYXJlIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgcGFyc2VyIHRvIHRyYWNrXG4vLy8gcGFyc2luZyBwcm9ncmVzcy4gVGhleSBhbHNvIHByb3ZpZGUgc29tZSBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzXG4vLy8gdGhhdCBleHRlcm5hbCBjb2RlIHN1Y2ggYXMgYSB0b2tlbml6ZXIgY2FuIHVzZSB0byBnZXQgaW5mb3JtYXRpb25cbi8vLyBhYm91dCB0aGUgcGFyc2Ugc3RhdGUuXG5jbGFzcyBTdGFjayB7XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBUaGUgcGFyc2UgdGhhdCB0aGlzIHN0YWNrIGlzIHBhcnQgb2YgQGludGVybmFsXG4gICAgcCwgXG4gICAgLy8vIEhvbGRzIHN0YXRlLCBpbnB1dCBwb3MsIGJ1ZmZlciBpbmRleCB0cmlwbGV0cyBmb3IgYWxsIGJ1dCB0aGVcbiAgICAvLy8gdG9wIHN0YXRlIEBpbnRlcm5hbFxuICAgIHN0YWNrLCBcbiAgICAvLy8gVGhlIGN1cnJlbnQgcGFyc2Ugc3RhdGUgQGludGVybmFsXG4gICAgc3RhdGUsIFxuICAgIC8vIFRoZSBwb3NpdGlvbiBhdCB3aGljaCB0aGUgbmV4dCByZWR1Y2Ugc2hvdWxkIHRha2UgcGxhY2UuIFRoaXNcbiAgICAvLyBjYW4gYmUgbGVzcyB0aGFuIGB0aGlzLnBvc2Agd2hlbiBza2lwcGVkIGV4cHJlc3Npb25zIGhhdmUgYmVlblxuICAgIC8vIGFkZGVkIHRvIHRoZSBzdGFjayAod2hpY2ggc2hvdWxkIGJlIG1vdmVkIG91dHNpZGUgb2YgdGhlIG5leHRcbiAgICAvLyByZWR1Y3Rpb24pXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHJlZHVjZVBvcywgXG4gICAgLy8vIFRoZSBpbnB1dCBwb3NpdGlvbiB1cCB0byB3aGljaCB0aGlzIHN0YWNrIGhhcyBwYXJzZWQuXG4gICAgcG9zLCBcbiAgICAvLy8gVGhlIGR5bmFtaWMgc2NvcmUgb2YgdGhlIHN0YWNrLCBpbmNsdWRpbmcgZHluYW1pYyBwcmVjZWRlbmNlXG4gICAgLy8vIGFuZCBlcnJvci1yZWNvdmVyeSBwZW5hbHRpZXNcbiAgICAvLy8gQGludGVybmFsXG4gICAgc2NvcmUsIFxuICAgIC8vIFRoZSBvdXRwdXQgYnVmZmVyLiBIb2xkcyAodHlwZSwgc3RhcnQsIGVuZCwgc2l6ZSkgcXVhZHNcbiAgICAvLyByZXByZXNlbnRpbmcgbm9kZXMgY3JlYXRlZCBieSB0aGUgcGFyc2VyLCB3aGVyZSBgc2l6ZWAgaXNcbiAgICAvLyBhbW91bnQgb2YgYnVmZmVyIGFycmF5IGVudHJpZXMgY292ZXJlZCBieSB0aGlzIG5vZGUuXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGJ1ZmZlciwgXG4gICAgLy8gVGhlIGJhc2Ugb2Zmc2V0IG9mIHRoZSBidWZmZXIuIFdoZW4gc3RhY2tzIGFyZSBzcGxpdCwgdGhlIHNwbGl0XG4gICAgLy8gaW5zdGFuY2Ugc2hhcmVkIHRoZSBidWZmZXIgaGlzdG9yeSB3aXRoIGl0cyBwYXJlbnQgdXAgdG9cbiAgICAvLyBgYnVmZmVyQmFzZWAsIHdoaWNoIGlzIHRoZSBhYnNvbHV0ZSBvZmZzZXQgKGluY2x1ZGluZyB0aGVcbiAgICAvLyBvZmZzZXQgb2YgcHJldmlvdXMgc3BsaXRzKSBpbnRvIHRoZSBidWZmZXIgYXQgd2hpY2ggdGhpcyBzdGFja1xuICAgIC8vIHN0YXJ0cyB3cml0aW5nLlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBidWZmZXJCYXNlLCBcbiAgICAvLy8gQGludGVybmFsXG4gICAgY3VyQ29udGV4dCwgXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGxvb2tBaGVhZCA9IDAsIFxuICAgIC8vIEEgcGFyZW50IHN0YWNrIGZyb20gd2hpY2ggdGhpcyB3YXMgc3BsaXQgb2ZmLCBpZiBhbnkuIFRoaXMgaXNcbiAgICAvLyBzZXQgdXAgc28gdGhhdCBpdCBhbHdheXMgcG9pbnRzIHRvIGEgc3RhY2sgdGhhdCBoYXMgc29tZVxuICAgIC8vIGFkZGl0aW9uYWwgYnVmZmVyIGNvbnRlbnQsIG5ldmVyIHRvIGEgc3RhY2sgd2l0aCBhbiBlcXVhbFxuICAgIC8vIGBidWZmZXJCYXNlYC5cbiAgICAvLy8gQGludGVybmFsXG4gICAgcGFyZW50KSB7XG4gICAgICAgIHRoaXMucCA9IHA7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBzdGFjaztcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLnJlZHVjZVBvcyA9IHJlZHVjZVBvcztcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuc2NvcmUgPSBzY29yZTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMuYnVmZmVyQmFzZSA9IGJ1ZmZlckJhc2U7XG4gICAgICAgIHRoaXMuY3VyQ29udGV4dCA9IGN1ckNvbnRleHQ7XG4gICAgICAgIHRoaXMubG9va0FoZWFkID0gbG9va0FoZWFkO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYFske3RoaXMuc3RhY2suZmlsdGVyKChfLCBpKSA9PiBpICUgMyA9PSAwKS5jb25jYXQodGhpcy5zdGF0ZSl9XUAke3RoaXMucG9zfSR7dGhpcy5zY29yZSA/IFwiIVwiICsgdGhpcy5zY29yZSA6IFwiXCJ9YDtcbiAgICB9XG4gICAgLy8gU3RhcnQgYW4gZW1wdHkgc3RhY2tcbiAgICAvLy8gQGludGVybmFsXG4gICAgc3RhdGljIHN0YXJ0KHAsIHN0YXRlLCBwb3MgPSAwKSB7XG4gICAgICAgIGxldCBjeCA9IHAucGFyc2VyLmNvbnRleHQ7XG4gICAgICAgIHJldHVybiBuZXcgU3RhY2socCwgW10sIHN0YXRlLCBwb3MsIHBvcywgMCwgW10sIDAsIGN4ID8gbmV3IFN0YWNrQ29udGV4dChjeCwgY3guc3RhcnQpIDogbnVsbCwgMCwgbnVsbCk7XG4gICAgfVxuICAgIC8vLyBUaGUgc3RhY2sncyBjdXJyZW50IFtjb250ZXh0XSgjbHIuQ29udGV4dFRyYWNrZXIpIHZhbHVlLCBpZlxuICAgIC8vLyBhbnkuIEl0cyB0eXBlIHdpbGwgZGVwZW5kIG9uIHRoZSBjb250ZXh0IHRyYWNrZXIncyB0eXBlXG4gICAgLy8vIHBhcmFtZXRlciwgb3IgaXQgd2lsbCBiZSBgbnVsbGAgaWYgdGhlcmUgaXMgbm8gY29udGV4dFxuICAgIC8vLyB0cmFja2VyLlxuICAgIGdldCBjb250ZXh0KCkgeyByZXR1cm4gdGhpcy5jdXJDb250ZXh0ID8gdGhpcy5jdXJDb250ZXh0LmNvbnRleHQgOiBudWxsOyB9XG4gICAgLy8gUHVzaCBhIHN0YXRlIG9udG8gdGhlIHN0YWNrLCB0cmFja2luZyBpdHMgc3RhcnQgcG9zaXRpb24gYXMgd2VsbFxuICAgIC8vIGFzIHRoZSBidWZmZXIgYmFzZSBhdCB0aGF0IHBvaW50LlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBwdXNoU3RhdGUoc3RhdGUsIHN0YXJ0KSB7XG4gICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLnN0YXRlLCBzdGFydCwgdGhpcy5idWZmZXJCYXNlICsgdGhpcy5idWZmZXIubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIH1cbiAgICAvLyBBcHBseSBhIHJlZHVjZSBhY3Rpb25cbiAgICAvLy8gQGludGVybmFsXG4gICAgcmVkdWNlKGFjdGlvbikge1xuICAgICAgICBsZXQgZGVwdGggPSBhY3Rpb24gPj4gMTkgLyogUmVkdWNlRGVwdGhTaGlmdCAqLywgdHlwZSA9IGFjdGlvbiAmIDY1NTM1IC8qIFZhbHVlTWFzayAqLztcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSB0aGlzLnA7XG4gICAgICAgIGxldCBkUHJlYyA9IHBhcnNlci5keW5hbWljUHJlY2VkZW5jZSh0eXBlKTtcbiAgICAgICAgaWYgKGRQcmVjKVxuICAgICAgICAgICAgdGhpcy5zY29yZSArPSBkUHJlYztcbiAgICAgICAgaWYgKGRlcHRoID09IDApIHtcbiAgICAgICAgICAgIHRoaXMucHVzaFN0YXRlKHBhcnNlci5nZXRHb3RvKHRoaXMuc3RhdGUsIHR5cGUsIHRydWUpLCB0aGlzLnJlZHVjZVBvcyk7XG4gICAgICAgICAgICAvLyBaZXJvLWRlcHRoIHJlZHVjdGlvbnMgYXJlIGEgc3BlY2lhbCBjYXNl4oCUdGhleSBhZGQgc3R1ZmYgdG9cbiAgICAgICAgICAgIC8vIHRoZSBzdGFjayB3aXRob3V0IHBvcHBpbmcgYW55dGhpbmcgb2ZmLlxuICAgICAgICAgICAgaWYgKHR5cGUgPCBwYXJzZXIubWluUmVwZWF0VGVybSlcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JlTm9kZSh0eXBlLCB0aGlzLnJlZHVjZVBvcywgdGhpcy5yZWR1Y2VQb3MsIDQsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5yZWR1Y2VDb250ZXh0KHR5cGUsIHRoaXMucmVkdWNlUG9zKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5kIHRoZSBiYXNlIGluZGV4IGludG8gYHRoaXMuc3RhY2tgLCBjb250ZW50IGFmdGVyIHdoaWNoIHdpbGxcbiAgICAgICAgLy8gYmUgZHJvcHBlZC4gTm90ZSB0aGF0IHdpdGggYFN0YXlGbGFnYCByZWR1Y3Rpb25zIHdlIG5lZWQgdG9cbiAgICAgICAgLy8gY29uc3VtZSB0d28gZXh0cmEgZnJhbWVzICh0aGUgZHVtbXkgcGFyZW50IG5vZGUgZm9yIHRoZSBza2lwcGVkXG4gICAgICAgIC8vIGV4cHJlc3Npb24gYW5kIHRoZSBzdGF0ZSB0aGF0IHdlJ2xsIGJlIHN0YXlpbmcgaW4sIHdoaWNoIHNob3VsZFxuICAgICAgICAvLyBiZSBtb3ZlZCB0byBgdGhpcy5zdGF0ZWApLlxuICAgICAgICBsZXQgYmFzZSA9IHRoaXMuc3RhY2subGVuZ3RoIC0gKChkZXB0aCAtIDEpICogMykgLSAoYWN0aW9uICYgMjYyMTQ0IC8qIFN0YXlGbGFnICovID8gNiA6IDApO1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnN0YWNrW2Jhc2UgLSAyXTtcbiAgICAgICAgbGV0IGJ1ZmZlckJhc2UgPSB0aGlzLnN0YWNrW2Jhc2UgLSAxXSwgY291bnQgPSB0aGlzLmJ1ZmZlckJhc2UgKyB0aGlzLmJ1ZmZlci5sZW5ndGggLSBidWZmZXJCYXNlO1xuICAgICAgICAvLyBTdG9yZSBub3JtYWwgdGVybXMgb3IgYFIgLT4gUiBSYCByZXBlYXQgcmVkdWN0aW9uc1xuICAgICAgICBpZiAodHlwZSA8IHBhcnNlci5taW5SZXBlYXRUZXJtIHx8IChhY3Rpb24gJiAxMzEwNzIgLyogUmVwZWF0RmxhZyAqLykpIHtcbiAgICAgICAgICAgIGxldCBwb3MgPSBwYXJzZXIuc3RhdGVGbGFnKHRoaXMuc3RhdGUsIDEgLyogU2tpcHBlZCAqLykgPyB0aGlzLnBvcyA6IHRoaXMucmVkdWNlUG9zO1xuICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUodHlwZSwgc3RhcnQsIHBvcywgY291bnQgKyA0LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aW9uICYgMjYyMTQ0IC8qIFN0YXlGbGFnICovKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5zdGFja1tiYXNlXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBiYXNlU3RhdGVJRCA9IHRoaXMuc3RhY2tbYmFzZSAtIDNdO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHBhcnNlci5nZXRHb3RvKGJhc2VTdGF0ZUlELCB0eXBlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodGhpcy5zdGFjay5sZW5ndGggPiBiYXNlKVxuICAgICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgdGhpcy5yZWR1Y2VDb250ZXh0KHR5cGUsIHN0YXJ0KTtcbiAgICB9XG4gICAgLy8gU2hpZnQgYSB2YWx1ZSBpbnRvIHRoZSBidWZmZXJcbiAgICAvLy8gQGludGVybmFsXG4gICAgc3RvcmVOb2RlKHRlcm0sIHN0YXJ0LCBlbmQsIHNpemUgPSA0LCBpc1JlZHVjZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0ZXJtID09IDAgLyogRXJyICovKSB7IC8vIFRyeSB0byBvbWl0L21lcmdlIGFkamFjZW50IGVycm9yIG5vZGVzXG4gICAgICAgICAgICBsZXQgY3VyID0gdGhpcywgdG9wID0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHRvcCA9PSAwICYmIGN1ci5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB0b3AgPSBjdXIuYnVmZmVyQmFzZSAtIGN1ci5wYXJlbnQuYnVmZmVyQmFzZTtcbiAgICAgICAgICAgICAgICBjdXIgPSBjdXIucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvcCA+IDAgJiYgY3VyLmJ1ZmZlclt0b3AgLSA0XSA9PSAwIC8qIEVyciAqLyAmJiBjdXIuYnVmZmVyW3RvcCAtIDFdID4gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPT0gZW5kKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKGN1ci5idWZmZXJbdG9wIC0gMl0gPj0gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyLmJ1ZmZlclt0b3AgLSAyXSA9IGVuZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzUmVkdWNlIHx8IHRoaXMucG9zID09IGVuZCkgeyAvLyBTaW1wbGUgY2FzZSwganVzdCBhcHBlbmRcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2godGVybSwgc3RhcnQsIGVuZCwgc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIFRoZXJlIG1heSBiZSBza2lwcGVkIG5vZGVzIHRoYXQgaGF2ZSB0byBiZSBtb3ZlZCBmb3J3YXJkXG4gICAgICAgICAgICBsZXQgaW5kZXggPSB0aGlzLmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAwICYmIHRoaXMuYnVmZmVyW2luZGV4IC0gNF0gIT0gMCAvKiBFcnIgKi8pXG4gICAgICAgICAgICAgICAgd2hpbGUgKGluZGV4ID4gMCAmJiB0aGlzLmJ1ZmZlcltpbmRleCAtIDJdID4gZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgdGhpcyByZWNvcmQgZm9yd2FyZFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleF0gPSB0aGlzLmJ1ZmZlcltpbmRleCAtIDRdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDFdID0gdGhpcy5idWZmZXJbaW5kZXggLSAzXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAyXSA9IHRoaXMuYnVmZmVyW2luZGV4IC0gMl07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgM10gPSB0aGlzLmJ1ZmZlcltpbmRleCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCAtPSA0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2l6ZSA+IDQpXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplIC09IDQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXhdID0gdGVybTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgMV0gPSBzdGFydDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgMl0gPSBlbmQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDNdID0gc2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBcHBseSBhIHNoaWZ0IGFjdGlvblxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzaGlmdChhY3Rpb24sIG5leHQsIG5leHRFbmQpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIGlmIChhY3Rpb24gJiAxMzEwNzIgLyogR290b0ZsYWcgKi8pIHtcbiAgICAgICAgICAgIHRoaXMucHVzaFN0YXRlKGFjdGlvbiAmIDY1NTM1IC8qIFZhbHVlTWFzayAqLywgdGhpcy5wb3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChhY3Rpb24gJiAyNjIxNDQgLyogU3RheUZsYWcgKi8pID09IDApIHsgLy8gUmVndWxhciBzaGlmdFxuICAgICAgICAgICAgbGV0IG5leHRTdGF0ZSA9IGFjdGlvbiwgeyBwYXJzZXIgfSA9IHRoaXMucDtcbiAgICAgICAgICAgIGlmIChuZXh0RW5kID4gdGhpcy5wb3MgfHwgbmV4dCA8PSBwYXJzZXIubWF4Tm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gbmV4dEVuZDtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlci5zdGF0ZUZsYWcobmV4dFN0YXRlLCAxIC8qIFNraXBwZWQgKi8pKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZHVjZVBvcyA9IG5leHRFbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnB1c2hTdGF0ZShuZXh0U3RhdGUsIHN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuc2hpZnRDb250ZXh0KG5leHQsIHN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChuZXh0IDw9IHBhcnNlci5tYXhOb2RlKVxuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2gobmV4dCwgc3RhcnQsIG5leHRFbmQsIDQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBTaGlmdC1hbmQtc3RheSwgd2hpY2ggbWVhbnMgdGhpcyBpcyBhIHNraXBwZWQgdG9rZW5cbiAgICAgICAgICAgIHRoaXMucG9zID0gbmV4dEVuZDtcbiAgICAgICAgICAgIHRoaXMuc2hpZnRDb250ZXh0KG5leHQsIHN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChuZXh0IDw9IHRoaXMucC5wYXJzZXIubWF4Tm9kZSlcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKG5leHQsIHN0YXJ0LCBuZXh0RW5kLCA0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBcHBseSBhbiBhY3Rpb25cbiAgICAvLy8gQGludGVybmFsXG4gICAgYXBwbHkoYWN0aW9uLCBuZXh0LCBuZXh0RW5kKSB7XG4gICAgICAgIGlmIChhY3Rpb24gJiA2NTUzNiAvKiBSZWR1Y2VGbGFnICovKVxuICAgICAgICAgICAgdGhpcy5yZWR1Y2UoYWN0aW9uKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5zaGlmdChhY3Rpb24sIG5leHQsIG5leHRFbmQpO1xuICAgIH1cbiAgICAvLyBBZGQgYSBwcmVidWlsdCAocmV1c2VkKSBub2RlIGludG8gdGhlIGJ1ZmZlci5cbiAgICAvLy8gQGludGVybmFsXG4gICAgdXNlTm9kZSh2YWx1ZSwgbmV4dCkge1xuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLnAucmV1c2VkLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgdGhpcy5wLnJldXNlZFtpbmRleF0gIT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMucC5yZXVzZWQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMucG9zO1xuICAgICAgICB0aGlzLnJlZHVjZVBvcyA9IHRoaXMucG9zID0gc3RhcnQgKyB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIHRoaXMucHVzaFN0YXRlKG5leHQsIHN0YXJ0KTtcbiAgICAgICAgdGhpcy5idWZmZXIucHVzaChpbmRleCwgc3RhcnQsIHRoaXMucmVkdWNlUG9zLCAtMSAvKiBzaXplID09IC0xIG1lYW5zIHRoaXMgaXMgYSByZXVzZWQgdmFsdWUgKi8pO1xuICAgICAgICBpZiAodGhpcy5jdXJDb250ZXh0KVxuICAgICAgICAgICAgdGhpcy51cGRhdGVDb250ZXh0KHRoaXMuY3VyQ29udGV4dC50cmFja2VyLnJldXNlKHRoaXMuY3VyQ29udGV4dC5jb250ZXh0LCB2YWx1ZSwgdGhpcywgdGhpcy5wLnN0cmVhbS5yZXNldCh0aGlzLnBvcyAtIHZhbHVlLmxlbmd0aCkpKTtcbiAgICB9XG4gICAgLy8gU3BsaXQgdGhlIHN0YWNrLiBEdWUgdG8gdGhlIGJ1ZmZlciBzaGFyaW5nIGFuZCB0aGUgZmFjdFxuICAgIC8vIHRoYXQgYHRoaXMuc3RhY2tgIHRlbmRzIHRvIHN0YXkgcXVpdGUgc2hhbGxvdywgdGhpcyBpc24ndCB2ZXJ5XG4gICAgLy8gZXhwZW5zaXZlLlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzcGxpdCgpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXM7XG4gICAgICAgIGxldCBvZmYgPSBwYXJlbnQuYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgLy8gQmVjYXVzZSB0aGUgdG9wIG9mIHRoZSBidWZmZXIgKGFmdGVyIHRoaXMucG9zKSBtYXkgYmUgbXV0YXRlZFxuICAgICAgICAvLyB0byByZW9yZGVyIHJlZHVjdGlvbnMgYW5kIHNraXBwZWQgdG9rZW5zLCBhbmQgc2hhcmVkIGJ1ZmZlcnNcbiAgICAgICAgLy8gc2hvdWxkIGJlIGltbXV0YWJsZSwgdGhpcyBjb3BpZXMgYW55IG91dHN0YW5kaW5nIHNraXBwZWQgdG9rZW5zXG4gICAgICAgIC8vIHRvIHRoZSBuZXcgYnVmZmVyLCBhbmQgcHV0cyB0aGUgYmFzZSBwb2ludGVyIGJlZm9yZSB0aGVtLlxuICAgICAgICB3aGlsZSAob2ZmID4gMCAmJiBwYXJlbnQuYnVmZmVyW29mZiAtIDJdID4gcGFyZW50LnJlZHVjZVBvcylcbiAgICAgICAgICAgIG9mZiAtPSA0O1xuICAgICAgICBsZXQgYnVmZmVyID0gcGFyZW50LmJ1ZmZlci5zbGljZShvZmYpLCBiYXNlID0gcGFyZW50LmJ1ZmZlckJhc2UgKyBvZmY7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBwYXJlbnQgcG9pbnRzIHRvIGFuIGFjdHVhbCBwYXJlbnQgd2l0aCBjb250ZW50LCBpZiB0aGVyZSBpcyBzdWNoIGEgcGFyZW50LlxuICAgICAgICB3aGlsZSAocGFyZW50ICYmIGJhc2UgPT0gcGFyZW50LmJ1ZmZlckJhc2UpXG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrKHRoaXMucCwgdGhpcy5zdGFjay5zbGljZSgpLCB0aGlzLnN0YXRlLCB0aGlzLnJlZHVjZVBvcywgdGhpcy5wb3MsIHRoaXMuc2NvcmUsIGJ1ZmZlciwgYmFzZSwgdGhpcy5jdXJDb250ZXh0LCB0aGlzLmxvb2tBaGVhZCwgcGFyZW50KTtcbiAgICB9XG4gICAgLy8gVHJ5IHRvIHJlY292ZXIgZnJvbSBhbiBlcnJvciBieSAnZGVsZXRpbmcnIChpZ25vcmluZykgb25lIHRva2VuLlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICByZWNvdmVyQnlEZWxldGUobmV4dCwgbmV4dEVuZCkge1xuICAgICAgICBsZXQgaXNOb2RlID0gbmV4dCA8PSB0aGlzLnAucGFyc2VyLm1heE5vZGU7XG4gICAgICAgIGlmIChpc05vZGUpXG4gICAgICAgICAgICB0aGlzLnN0b3JlTm9kZShuZXh0LCB0aGlzLnBvcywgbmV4dEVuZCwgNCk7XG4gICAgICAgIHRoaXMuc3RvcmVOb2RlKDAgLyogRXJyICovLCB0aGlzLnBvcywgbmV4dEVuZCwgaXNOb2RlID8gOCA6IDQpO1xuICAgICAgICB0aGlzLnBvcyA9IHRoaXMucmVkdWNlUG9zID0gbmV4dEVuZDtcbiAgICAgICAgdGhpcy5zY29yZSAtPSAxOTAgLyogRGVsZXRlICovO1xuICAgIH1cbiAgICAvLy8gQ2hlY2sgaWYgdGhlIGdpdmVuIHRlcm0gd291bGQgYmUgYWJsZSB0byBiZSBzaGlmdGVkIChvcHRpb25hbGx5XG4gICAgLy8vIGFmdGVyIHNvbWUgcmVkdWN0aW9ucykgb24gdGhpcyBzdGFjay4gVGhpcyBjYW4gYmUgdXNlZnVsIGZvclxuICAgIC8vLyBleHRlcm5hbCB0b2tlbml6ZXJzIHRoYXQgd2FudCB0byBtYWtlIHN1cmUgdGhleSBvbmx5IHByb3ZpZGUgYVxuICAgIC8vLyBnaXZlbiB0b2tlbiB3aGVuIGl0IGFwcGxpZXMuXG4gICAgY2FuU2hpZnQodGVybSkge1xuICAgICAgICBmb3IgKGxldCBzaW0gPSBuZXcgU2ltdWxhdGVkU3RhY2sodGhpcyk7Oykge1xuICAgICAgICAgICAgbGV0IGFjdGlvbiA9IHRoaXMucC5wYXJzZXIuc3RhdGVTbG90KHNpbS5zdGF0ZSwgNCAvKiBEZWZhdWx0UmVkdWNlICovKSB8fCB0aGlzLnAucGFyc2VyLmhhc0FjdGlvbihzaW0uc3RhdGUsIHRlcm0pO1xuICAgICAgICAgICAgaWYgKChhY3Rpb24gJiA2NTUzNiAvKiBSZWR1Y2VGbGFnICovKSA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKGFjdGlvbiA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHNpbS5yZWR1Y2UoYWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBcHBseSB1cCB0byBSZWNvdmVyLk1heE5leHQgcmVjb3ZlcnkgYWN0aW9ucyB0aGF0IGNvbmNlcHR1YWxseVxuICAgIC8vIGluc2VydHMgc29tZSBtaXNzaW5nIHRva2VuIG9yIHJ1bGUuXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHJlY292ZXJCeUluc2VydChuZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA+PSAzMDAgLyogTWF4SW5zZXJ0U3RhY2tEZXB0aCAqLylcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgbGV0IG5leHRTdGF0ZXMgPSB0aGlzLnAucGFyc2VyLm5leHRTdGF0ZXModGhpcy5zdGF0ZSk7XG4gICAgICAgIGlmIChuZXh0U3RhdGVzLmxlbmd0aCA+IDQgLyogTWF4TmV4dCAqLyA8PCAxIHx8IHRoaXMuc3RhY2subGVuZ3RoID49IDEyMCAvKiBEYW1wZW5JbnNlcnRTdGFja0RlcHRoICovKSB7XG4gICAgICAgICAgICBsZXQgYmVzdCA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHM7IGkgPCBuZXh0U3RhdGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgaWYgKChzID0gbmV4dFN0YXRlc1tpICsgMV0pICE9IHRoaXMuc3RhdGUgJiYgdGhpcy5wLnBhcnNlci5oYXNBY3Rpb24ocywgbmV4dCkpXG4gICAgICAgICAgICAgICAgICAgIGJlc3QucHVzaChuZXh0U3RhdGVzW2ldLCBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDEyMCAvKiBEYW1wZW5JbnNlcnRTdGFja0RlcHRoICovKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBiZXN0Lmxlbmd0aCA8IDQgLyogTWF4TmV4dCAqLyA8PCAxICYmIGkgPCBuZXh0U3RhdGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzID0gbmV4dFN0YXRlc1tpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghYmVzdC5zb21lKCh2LCBpKSA9PiAoaSAmIDEpICYmIHYgPT0gcykpXG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0LnB1c2gobmV4dFN0YXRlc1tpXSwgcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dFN0YXRlcyA9IGJlc3Q7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5leHRTdGF0ZXMubGVuZ3RoICYmIHJlc3VsdC5sZW5ndGggPCA0IC8qIE1heE5leHQgKi87IGkgKz0gMikge1xuICAgICAgICAgICAgbGV0IHMgPSBuZXh0U3RhdGVzW2kgKyAxXTtcbiAgICAgICAgICAgIGlmIChzID09IHRoaXMuc3RhdGUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgc3RhY2sgPSB0aGlzLnNwbGl0KCk7XG4gICAgICAgICAgICBzdGFjay5zdG9yZU5vZGUoMCAvKiBFcnIgKi8sIHN0YWNrLnBvcywgc3RhY2sucG9zLCA0LCB0cnVlKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2hTdGF0ZShzLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICBzdGFjay5zaGlmdENvbnRleHQobmV4dFN0YXRlc1tpXSwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgc3RhY2suc2NvcmUgLT0gMjAwIC8qIEluc2VydCAqLztcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBGb3JjZSBhIHJlZHVjZSwgaWYgcG9zc2libGUuIFJldHVybiBmYWxzZSBpZiB0aGF0IGNhbid0XG4gICAgLy8gYmUgZG9uZS5cbiAgICAvLy8gQGludGVybmFsXG4gICAgZm9yY2VSZWR1Y2UoKSB7XG4gICAgICAgIGxldCByZWR1Y2UgPSB0aGlzLnAucGFyc2VyLnN0YXRlU2xvdCh0aGlzLnN0YXRlLCA1IC8qIEZvcmNlZFJlZHVjZSAqLyk7XG4gICAgICAgIGlmICgocmVkdWNlICYgNjU1MzYgLyogUmVkdWNlRmxhZyAqLykgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSB0aGlzLnA7XG4gICAgICAgIGlmICghcGFyc2VyLnZhbGlkQWN0aW9uKHRoaXMuc3RhdGUsIHJlZHVjZSkpIHtcbiAgICAgICAgICAgIGxldCBkZXB0aCA9IHJlZHVjZSA+PiAxOSAvKiBSZWR1Y2VEZXB0aFNoaWZ0ICovLCB0ZXJtID0gcmVkdWNlICYgNjU1MzUgLyogVmFsdWVNYXNrICovO1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IHRoaXMuc3RhY2subGVuZ3RoIC0gZGVwdGggKiAzO1xuICAgICAgICAgICAgaWYgKHRhcmdldCA8IDAgfHwgcGFyc2VyLmdldEdvdG8odGhpcy5zdGFja1t0YXJnZXRdLCB0ZXJtLCBmYWxzZSkgPCAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKDAgLyogRXJyICovLCB0aGlzLnJlZHVjZVBvcywgdGhpcy5yZWR1Y2VQb3MsIDQsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5zY29yZSAtPSAxMDAgLyogUmVkdWNlICovO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVkdWNlKHJlZHVjZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgZm9yY2VBbGwoKSB7XG4gICAgICAgIHdoaWxlICghdGhpcy5wLnBhcnNlci5zdGF0ZUZsYWcodGhpcy5zdGF0ZSwgMiAvKiBBY2NlcHRpbmcgKi8pKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZm9yY2VSZWR1Y2UoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKDAgLyogRXJyICovLCB0aGlzLnBvcywgdGhpcy5wb3MsIDQsIHRydWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLy8gQ2hlY2sgd2hldGhlciB0aGlzIHN0YXRlIGhhcyBubyBmdXJ0aGVyIGFjdGlvbnMgKGFzc3VtZWQgdG8gYmUgYSBkaXJlY3QgZGVzY2VuZGFudCBvZiB0aGVcbiAgICAvLy8gdG9wIHN0YXRlLCBzaW5jZSBhbnkgb3RoZXIgc3RhdGVzIG11c3QgYmUgYWJsZSB0byBjb250aW51ZVxuICAgIC8vLyBzb21laG93KS4gQGludGVybmFsXG4gICAgZ2V0IGRlYWRFbmQoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCAhPSAzKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHRoaXMucDtcbiAgICAgICAgcmV0dXJuIHBhcnNlci5kYXRhW3BhcnNlci5zdGF0ZVNsb3QodGhpcy5zdGF0ZSwgMSAvKiBBY3Rpb25zICovKV0gPT0gNjU1MzUgLyogRW5kICovICYmXG4gICAgICAgICAgICAhcGFyc2VyLnN0YXRlU2xvdCh0aGlzLnN0YXRlLCA0IC8qIERlZmF1bHRSZWR1Y2UgKi8pO1xuICAgIH1cbiAgICAvLy8gUmVzdGFydCB0aGUgc3RhY2sgKHB1dCBpdCBiYWNrIGluIGl0cyBzdGFydCBzdGF0ZSkuIE9ubHkgc2FmZVxuICAgIC8vLyB3aGVuIHRoaXMuc3RhY2subGVuZ3RoID09IDMgKHN0YXRlIGlzIGRpcmVjdGx5IGJlbG93IHRoZSB0b3BcbiAgICAvLy8gc3RhdGUpLiBAaW50ZXJuYWxcbiAgICByZXN0YXJ0KCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5zdGFja1swXTtcbiAgICAgICAgdGhpcy5zdGFjay5sZW5ndGggPSAwO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgc2FtZVN0YXRlKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9IG90aGVyLnN0YXRlIHx8IHRoaXMuc3RhY2subGVuZ3RoICE9IG90aGVyLnN0YWNrLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN0YWNrLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhY2tbaV0gIT0gb3RoZXIuc3RhY2tbaV0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8vIEdldCB0aGUgcGFyc2VyIHVzZWQgYnkgdGhpcyBzdGFjay5cbiAgICBnZXQgcGFyc2VyKCkgeyByZXR1cm4gdGhpcy5wLnBhcnNlcjsgfVxuICAgIC8vLyBUZXN0IHdoZXRoZXIgYSBnaXZlbiBkaWFsZWN0IChieSBudW1lcmljIElELCBhcyBleHBvcnRlZCBmcm9tXG4gICAgLy8vIHRoZSB0ZXJtcyBmaWxlKSBpcyBlbmFibGVkLlxuICAgIGRpYWxlY3RFbmFibGVkKGRpYWxlY3RJRCkgeyByZXR1cm4gdGhpcy5wLnBhcnNlci5kaWFsZWN0LmZsYWdzW2RpYWxlY3RJRF07IH1cbiAgICBzaGlmdENvbnRleHQodGVybSwgc3RhcnQpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VyQ29udGV4dClcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29udGV4dCh0aGlzLmN1ckNvbnRleHQudHJhY2tlci5zaGlmdCh0aGlzLmN1ckNvbnRleHQuY29udGV4dCwgdGVybSwgdGhpcywgdGhpcy5wLnN0cmVhbS5yZXNldChzdGFydCkpKTtcbiAgICB9XG4gICAgcmVkdWNlQ29udGV4dCh0ZXJtLCBzdGFydCkge1xuICAgICAgICBpZiAodGhpcy5jdXJDb250ZXh0KVxuICAgICAgICAgICAgdGhpcy51cGRhdGVDb250ZXh0KHRoaXMuY3VyQ29udGV4dC50cmFja2VyLnJlZHVjZSh0aGlzLmN1ckNvbnRleHQuY29udGV4dCwgdGVybSwgdGhpcywgdGhpcy5wLnN0cmVhbS5yZXNldChzdGFydCkpKTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGVtaXRDb250ZXh0KCkge1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMuYnVmZmVyLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChsYXN0IDwgMCB8fCB0aGlzLmJ1ZmZlcltsYXN0XSAhPSAtMylcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2godGhpcy5jdXJDb250ZXh0Lmhhc2gsIHRoaXMucmVkdWNlUG9zLCB0aGlzLnJlZHVjZVBvcywgLTMpO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgZW1pdExvb2tBaGVhZCgpIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmJ1ZmZlci5sZW5ndGggLSAxO1xuICAgICAgICBpZiAobGFzdCA8IDAgfHwgdGhpcy5idWZmZXJbbGFzdF0gIT0gLTQpXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHRoaXMubG9va0FoZWFkLCB0aGlzLnJlZHVjZVBvcywgdGhpcy5yZWR1Y2VQb3MsIC00KTtcbiAgICB9XG4gICAgdXBkYXRlQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ICE9IHRoaXMuY3VyQ29udGV4dC5jb250ZXh0KSB7XG4gICAgICAgICAgICBsZXQgbmV3Q3ggPSBuZXcgU3RhY2tDb250ZXh0KHRoaXMuY3VyQ29udGV4dC50cmFja2VyLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChuZXdDeC5oYXNoICE9IHRoaXMuY3VyQ29udGV4dC5oYXNoKVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdENvbnRleHQoKTtcbiAgICAgICAgICAgIHRoaXMuY3VyQ29udGV4dCA9IG5ld0N4O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzZXRMb29rQWhlYWQobG9va0FoZWFkKSB7XG4gICAgICAgIGlmIChsb29rQWhlYWQgPiB0aGlzLmxvb2tBaGVhZCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0TG9va0FoZWFkKCk7XG4gICAgICAgICAgICB0aGlzLmxvb2tBaGVhZCA9IGxvb2tBaGVhZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1ckNvbnRleHQgJiYgdGhpcy5jdXJDb250ZXh0LnRyYWNrZXIuc3RyaWN0KVxuICAgICAgICAgICAgdGhpcy5lbWl0Q29udGV4dCgpO1xuICAgICAgICBpZiAodGhpcy5sb29rQWhlYWQgPiAwKVxuICAgICAgICAgICAgdGhpcy5lbWl0TG9va0FoZWFkKCk7XG4gICAgfVxufVxuY2xhc3MgU3RhY2tDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3Rvcih0cmFja2VyLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudHJhY2tlciA9IHRyYWNrZXI7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuaGFzaCA9IHRyYWNrZXIuc3RyaWN0ID8gdHJhY2tlci5oYXNoKGNvbnRleHQpIDogMDtcbiAgICB9XG59XG52YXIgUmVjb3ZlcjtcbihmdW5jdGlvbiAoUmVjb3Zlcikge1xuICAgIFJlY292ZXJbUmVjb3ZlcltcIkluc2VydFwiXSA9IDIwMF0gPSBcIkluc2VydFwiO1xuICAgIFJlY292ZXJbUmVjb3ZlcltcIkRlbGV0ZVwiXSA9IDE5MF0gPSBcIkRlbGV0ZVwiO1xuICAgIFJlY292ZXJbUmVjb3ZlcltcIlJlZHVjZVwiXSA9IDEwMF0gPSBcIlJlZHVjZVwiO1xuICAgIFJlY292ZXJbUmVjb3ZlcltcIk1heE5leHRcIl0gPSA0XSA9IFwiTWF4TmV4dFwiO1xuICAgIFJlY292ZXJbUmVjb3ZlcltcIk1heEluc2VydFN0YWNrRGVwdGhcIl0gPSAzMDBdID0gXCJNYXhJbnNlcnRTdGFja0RlcHRoXCI7XG4gICAgUmVjb3ZlcltSZWNvdmVyW1wiRGFtcGVuSW5zZXJ0U3RhY2tEZXB0aFwiXSA9IDEyMF0gPSBcIkRhbXBlbkluc2VydFN0YWNrRGVwdGhcIjtcbn0pKFJlY292ZXIgfHwgKFJlY292ZXIgPSB7fSkpO1xuLy8gVXNlZCB0byBjaGVhcGx5IHJ1biBzb21lIHJlZHVjdGlvbnMgdG8gc2NhbiBhaGVhZCB3aXRob3V0IG11dGF0aW5nXG4vLyBhbiBlbnRpcmUgc3RhY2tcbmNsYXNzIFNpbXVsYXRlZFN0YWNrIHtcbiAgICBjb25zdHJ1Y3RvcihzdGFydCkge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGFydC5zdGF0ZTtcbiAgICAgICAgdGhpcy5zdGFjayA9IHN0YXJ0LnN0YWNrO1xuICAgICAgICB0aGlzLmJhc2UgPSB0aGlzLnN0YWNrLmxlbmd0aDtcbiAgICB9XG4gICAgcmVkdWNlKGFjdGlvbikge1xuICAgICAgICBsZXQgdGVybSA9IGFjdGlvbiAmIDY1NTM1IC8qIFZhbHVlTWFzayAqLywgZGVwdGggPSBhY3Rpb24gPj4gMTkgLyogUmVkdWNlRGVwdGhTaGlmdCAqLztcbiAgICAgICAgaWYgKGRlcHRoID09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YWNrID09IHRoaXMuc3RhcnQuc3RhY2spXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFjayA9IHRoaXMuc3RhY2suc2xpY2UoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLnN0YXRlLCAwLCAwKTtcbiAgICAgICAgICAgIHRoaXMuYmFzZSArPSAzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5iYXNlIC09IChkZXB0aCAtIDEpICogMztcbiAgICAgICAgfVxuICAgICAgICBsZXQgZ290byA9IHRoaXMuc3RhcnQucC5wYXJzZXIuZ2V0R290byh0aGlzLnN0YWNrW3RoaXMuYmFzZSAtIDNdLCB0ZXJtLCB0cnVlKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IGdvdG87XG4gICAgfVxufVxuLy8gVGhpcyBpcyBnaXZlbiB0byBgVHJlZS5idWlsZGAgdG8gYnVpbGQgYSBidWZmZXIsIGFuZCBlbmNhcHN1bGF0ZXNcbi8vIHRoZSBwYXJlbnQtc3RhY2std2Fsa2luZyBuZWNlc3NhcnkgdG8gcmVhZCB0aGUgbm9kZXMuXG5jbGFzcyBTdGFja0J1ZmZlckN1cnNvciB7XG4gICAgY29uc3RydWN0b3Ioc3RhY2ssIHBvcywgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5zdGFjayA9IHN0YWNrO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IHN0YWNrLmJ1ZmZlcjtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPT0gMClcbiAgICAgICAgICAgIHRoaXMubWF5YmVOZXh0KCk7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoc3RhY2ssIHBvcyA9IHN0YWNrLmJ1ZmZlckJhc2UgKyBzdGFjay5idWZmZXIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RhY2tCdWZmZXJDdXJzb3Ioc3RhY2ssIHBvcywgcG9zIC0gc3RhY2suYnVmZmVyQmFzZSk7XG4gICAgfVxuICAgIG1heWJlTmV4dCgpIHtcbiAgICAgICAgbGV0IG5leHQgPSB0aGlzLnN0YWNrLnBhcmVudDtcbiAgICAgICAgaWYgKG5leHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IHRoaXMuc3RhY2suYnVmZmVyQmFzZSAtIG5leHQuYnVmZmVyQmFzZTtcbiAgICAgICAgICAgIHRoaXMuc3RhY2sgPSBuZXh0O1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBuZXh0LmJ1ZmZlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaWQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gNF07IH1cbiAgICBnZXQgc3RhcnQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gM107IH1cbiAgICBnZXQgZW5kKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDJdOyB9XG4gICAgZ2V0IHNpemUoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMV07IH1cbiAgICBuZXh0KCkge1xuICAgICAgICB0aGlzLmluZGV4IC09IDQ7XG4gICAgICAgIHRoaXMucG9zIC09IDQ7XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID09IDApXG4gICAgICAgICAgICB0aGlzLm1heWJlTmV4dCgpO1xuICAgIH1cbiAgICBmb3JrKCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrQnVmZmVyQ3Vyc29yKHRoaXMuc3RhY2ssIHRoaXMucG9zLCB0aGlzLmluZGV4KTtcbiAgICB9XG59XG5cbmNsYXNzIENhY2hlZFRva2VuIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IC0xO1xuICAgICAgICB0aGlzLnZhbHVlID0gLTE7XG4gICAgICAgIHRoaXMuZW5kID0gLTE7XG4gICAgICAgIHRoaXMuZXh0ZW5kZWQgPSAtMTtcbiAgICAgICAgdGhpcy5sb29rQWhlYWQgPSAwO1xuICAgICAgICB0aGlzLm1hc2sgPSAwO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSAwO1xuICAgIH1cbn1cbmNvbnN0IG51bGxUb2tlbiA9IG5ldyBDYWNoZWRUb2tlbjtcbi8vLyBbVG9rZW5pemVyc10oI2xyLkV4dGVybmFsVG9rZW5pemVyKSBpbnRlcmFjdCB3aXRoIHRoZSBpbnB1dFxuLy8vIHRocm91Z2ggdGhpcyBpbnRlcmZhY2UuIEl0IHByZXNlbnRzIHRoZSBpbnB1dCBhcyBhIHN0cmVhbSBvZlxuLy8vIGNoYXJhY3RlcnMsIHRyYWNraW5nIGxvb2thaGVhZCBhbmQgaGlkaW5nIHRoZSBjb21wbGV4aXR5IG9mXG4vLy8gW3Jhbmdlc10oI2NvbW1vbi5QYXJzZXIucGFyc2VecmFuZ2VzKSBmcm9tIHRva2VuaXplciBjb2RlLlxuY2xhc3MgSW5wdXRTdHJlYW0ge1xuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gQGludGVybmFsXG4gICAgaW5wdXQsIFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICByYW5nZXMpIHtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgLy8vIEBpbnRlcm5hbFxuICAgICAgICB0aGlzLmNodW5rID0gXCJcIjtcbiAgICAgICAgLy8vIEBpbnRlcm5hbFxuICAgICAgICB0aGlzLmNodW5rT2ZmID0gMDtcbiAgICAgICAgLy8vIEJhY2t1cCBjaHVua1xuICAgICAgICB0aGlzLmNodW5rMiA9IFwiXCI7XG4gICAgICAgIHRoaXMuY2h1bmsyUG9zID0gMDtcbiAgICAgICAgLy8vIFRoZSBjaGFyYWN0ZXIgY29kZSBvZiB0aGUgbmV4dCBjb2RlIHVuaXQgaW4gdGhlIGlucHV0LCBvciAtMVxuICAgICAgICAvLy8gd2hlbiB0aGUgc3RyZWFtIGlzIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0LlxuICAgICAgICB0aGlzLm5leHQgPSAtMTtcbiAgICAgICAgLy8vIEBpbnRlcm5hbFxuICAgICAgICB0aGlzLnRva2VuID0gbnVsbFRva2VuO1xuICAgICAgICB0aGlzLnJhbmdlSW5kZXggPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IHRoaXMuY2h1bmtQb3MgPSByYW5nZXNbMF0uZnJvbTtcbiAgICAgICAgdGhpcy5yYW5nZSA9IHJhbmdlc1swXTtcbiAgICAgICAgdGhpcy5lbmQgPSByYW5nZXNbcmFuZ2VzLmxlbmd0aCAtIDFdLnRvO1xuICAgICAgICB0aGlzLnJlYWROZXh0KCk7XG4gICAgfVxuICAgIHJlc29sdmVPZmZzZXQob2Zmc2V0LCBhc3NvYykge1xuICAgICAgICBsZXQgcmFuZ2UgPSB0aGlzLnJhbmdlLCBpbmRleCA9IHRoaXMucmFuZ2VJbmRleDtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMucG9zICsgb2Zmc2V0O1xuICAgICAgICB3aGlsZSAocG9zIDwgcmFuZ2UuZnJvbSkge1xuICAgICAgICAgICAgaWYgKCFpbmRleClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5yYW5nZXNbLS1pbmRleF07XG4gICAgICAgICAgICBwb3MgLT0gcmFuZ2UuZnJvbSAtIG5leHQudG87XG4gICAgICAgICAgICByYW5nZSA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGFzc29jIDwgMCA/IHBvcyA+IHJhbmdlLnRvIDogcG9zID49IHJhbmdlLnRvKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gdGhpcy5yYW5nZXMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5yYW5nZXNbKytpbmRleF07XG4gICAgICAgICAgICBwb3MgKz0gbmV4dC5mcm9tIC0gcmFuZ2UudG87XG4gICAgICAgICAgICByYW5nZSA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgLy8vIExvb2sgYXQgYSBjb2RlIHVuaXQgbmVhciB0aGUgc3RyZWFtIHBvc2l0aW9uLiBgLnBlZWsoMClgIGVxdWFsc1xuICAgIC8vLyBgLm5leHRgLCBgLnBlZWsoLTEpYCBnaXZlcyB5b3UgdGhlIHByZXZpb3VzIGNoYXJhY3RlciwgYW5kIHNvXG4gICAgLy8vIG9uLlxuICAgIC8vL1xuICAgIC8vLyBOb3RlIHRoYXQgbG9va2luZyBhcm91bmQgZHVyaW5nIHRva2VuaXppbmcgY3JlYXRlcyBkZXBlbmRlbmNpZXNcbiAgICAvLy8gb24gcG90ZW50aWFsbHkgZmFyLWF3YXkgY29udGVudCwgd2hpY2ggbWF5IHJlZHVjZSB0aGVcbiAgICAvLy8gZWZmZWN0aXZlbmVzcyBpbmNyZW1lbnRhbCBwYXJzaW5n4oCUd2hlbiBsb29raW5nIGZvcndhcmTigJRvciBldmVuXG4gICAgLy8vIGNhdXNlIGludmFsaWQgcmVwYXJzZXMgd2hlbiBsb29raW5nIGJhY2t3YXJkIG1vcmUgdGhhbiAyNSBjb2RlXG4gICAgLy8vIHVuaXRzLCBzaW5jZSB0aGUgbGlicmFyeSBkb2VzIG5vdCB0cmFjayBsb29rYmVoaW5kLlxuICAgIHBlZWsob2Zmc2V0KSB7XG4gICAgICAgIGxldCBpZHggPSB0aGlzLmNodW5rT2ZmICsgb2Zmc2V0LCBwb3MsIHJlc3VsdDtcbiAgICAgICAgaWYgKGlkeCA+PSAwICYmIGlkeCA8IHRoaXMuY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICBwb3MgPSB0aGlzLnBvcyArIG9mZnNldDtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY2h1bmsuY2hhckNvZGVBdChpZHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHJlc29sdmVkID0gdGhpcy5yZXNvbHZlT2Zmc2V0KG9mZnNldCwgMSk7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZWQgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICBwb3MgPSByZXNvbHZlZDtcbiAgICAgICAgICAgIGlmIChwb3MgPj0gdGhpcy5jaHVuazJQb3MgJiYgcG9zIDwgdGhpcy5jaHVuazJQb3MgKyB0aGlzLmNodW5rMi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNodW5rMi5jaGFyQ29kZUF0KHBvcyAtIHRoaXMuY2h1bmsyUG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBpID0gdGhpcy5yYW5nZUluZGV4LCByYW5nZSA9IHRoaXMucmFuZ2U7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJhbmdlLnRvIDw9IHBvcylcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSB0aGlzLnJhbmdlc1srK2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuY2h1bmsyID0gdGhpcy5pbnB1dC5jaHVuayh0aGlzLmNodW5rMlBvcyA9IHBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyArIHRoaXMuY2h1bmsyLmxlbmd0aCA+IHJhbmdlLnRvKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNodW5rMiA9IHRoaXMuY2h1bmsyLnNsaWNlKDAsIHJhbmdlLnRvIC0gcG9zKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNodW5rMi5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgPj0gdGhpcy50b2tlbi5sb29rQWhlYWQpXG4gICAgICAgICAgICB0aGlzLnRva2VuLmxvb2tBaGVhZCA9IHBvcyArIDE7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vLyBBY2NlcHQgYSB0b2tlbi4gQnkgZGVmYXVsdCwgdGhlIGVuZCBvZiB0aGUgdG9rZW4gaXMgc2V0IHRvIHRoZVxuICAgIC8vLyBjdXJyZW50IHN0cmVhbSBwb3NpdGlvbiwgYnV0IHlvdSBjYW4gcGFzcyBhbiBvZmZzZXQgKHJlbGF0aXZlIHRvXG4gICAgLy8vIHRoZSBzdHJlYW0gcG9zaXRpb24pIHRvIGNoYW5nZSB0aGF0LlxuICAgIGFjY2VwdFRva2VuKHRva2VuLCBlbmRPZmZzZXQgPSAwKSB7XG4gICAgICAgIGxldCBlbmQgPSBlbmRPZmZzZXQgPyB0aGlzLnJlc29sdmVPZmZzZXQoZW5kT2Zmc2V0LCAtMSkgOiB0aGlzLnBvcztcbiAgICAgICAgaWYgKGVuZCA9PSBudWxsIHx8IGVuZCA8IHRoaXMudG9rZW4uc3RhcnQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRva2VuIGVuZCBvdXQgb2YgYm91bmRzXCIpO1xuICAgICAgICB0aGlzLnRva2VuLnZhbHVlID0gdG9rZW47XG4gICAgICAgIHRoaXMudG9rZW4uZW5kID0gZW5kO1xuICAgIH1cbiAgICBnZXRDaHVuaygpIHtcbiAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMuY2h1bmsyUG9zICYmIHRoaXMucG9zIDwgdGhpcy5jaHVuazJQb3MgKyB0aGlzLmNodW5rMi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCB7IGNodW5rLCBjaHVua1BvcyB9ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuY2h1bmsgPSB0aGlzLmNodW5rMjtcbiAgICAgICAgICAgIHRoaXMuY2h1bmtQb3MgPSB0aGlzLmNodW5rMlBvcztcbiAgICAgICAgICAgIHRoaXMuY2h1bmsyID0gY2h1bms7XG4gICAgICAgICAgICB0aGlzLmNodW5rMlBvcyA9IGNodW5rUG9zO1xuICAgICAgICAgICAgdGhpcy5jaHVua09mZiA9IHRoaXMucG9zIC0gdGhpcy5jaHVua1BvcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2h1bmsyID0gdGhpcy5jaHVuaztcbiAgICAgICAgICAgIHRoaXMuY2h1bmsyUG9zID0gdGhpcy5jaHVua1BvcztcbiAgICAgICAgICAgIGxldCBuZXh0Q2h1bmsgPSB0aGlzLmlucHV0LmNodW5rKHRoaXMucG9zKTtcbiAgICAgICAgICAgIGxldCBlbmQgPSB0aGlzLnBvcyArIG5leHRDaHVuay5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLmNodW5rID0gZW5kID4gdGhpcy5yYW5nZS50byA/IG5leHRDaHVuay5zbGljZSgwLCB0aGlzLnJhbmdlLnRvIC0gdGhpcy5wb3MpIDogbmV4dENodW5rO1xuICAgICAgICAgICAgdGhpcy5jaHVua1BvcyA9IHRoaXMucG9zO1xuICAgICAgICAgICAgdGhpcy5jaHVua09mZiA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVhZE5leHQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNodW5rT2ZmID49IHRoaXMuY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmdldENodW5rKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jaHVua09mZiA9PSB0aGlzLmNodW5rLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZXh0ID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dCA9IHRoaXMuY2h1bmsuY2hhckNvZGVBdCh0aGlzLmNodW5rT2ZmKTtcbiAgICB9XG4gICAgLy8vIE1vdmUgdGhlIHN0cmVhbSBmb3J3YXJkIE4gKGRlZmF1bHRzIHRvIDEpIGNvZGUgdW5pdHMuIFJldHVybnNcbiAgICAvLy8gdGhlIG5ldyB2YWx1ZSBvZiBbYG5leHRgXSgjbHIuSW5wdXRTdHJlYW0ubmV4dCkuXG4gICAgYWR2YW5jZShuID0gMSkge1xuICAgICAgICB0aGlzLmNodW5rT2ZmICs9IG47XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyArIG4gPj0gdGhpcy5yYW5nZS50bykge1xuICAgICAgICAgICAgaWYgKHRoaXMucmFuZ2VJbmRleCA9PSB0aGlzLnJhbmdlcy5sZW5ndGggLSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldERvbmUoKTtcbiAgICAgICAgICAgIG4gLT0gdGhpcy5yYW5nZS50byAtIHRoaXMucG9zO1xuICAgICAgICAgICAgdGhpcy5yYW5nZSA9IHRoaXMucmFuZ2VzWysrdGhpcy5yYW5nZUluZGV4XTtcbiAgICAgICAgICAgIHRoaXMucG9zID0gdGhpcy5yYW5nZS5mcm9tO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9zICs9IG47XG4gICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLnRva2VuLmxvb2tBaGVhZClcbiAgICAgICAgICAgIHRoaXMudG9rZW4ubG9va0FoZWFkID0gdGhpcy5wb3MgKyAxO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkTmV4dCgpO1xuICAgIH1cbiAgICBzZXREb25lKCkge1xuICAgICAgICB0aGlzLnBvcyA9IHRoaXMuY2h1bmtQb3MgPSB0aGlzLmVuZDtcbiAgICAgICAgdGhpcy5yYW5nZSA9IHRoaXMucmFuZ2VzW3RoaXMucmFuZ2VJbmRleCA9IHRoaXMucmFuZ2VzLmxlbmd0aCAtIDFdO1xuICAgICAgICB0aGlzLmNodW5rID0gXCJcIjtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dCA9IC0xO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgcmVzZXQocG9zLCB0b2tlbikge1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgIHRva2VuLnN0YXJ0ID0gcG9zO1xuICAgICAgICAgICAgdG9rZW4ubG9va0FoZWFkID0gcG9zICsgMTtcbiAgICAgICAgICAgIHRva2VuLnZhbHVlID0gdG9rZW4uZXh0ZW5kZWQgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudG9rZW4gPSBudWxsVG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucG9zICE9IHBvcykge1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgICAgICBpZiAocG9zID09IHRoaXMuZW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXREb25lKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAocG9zIDwgdGhpcy5yYW5nZS5mcm9tKVxuICAgICAgICAgICAgICAgIHRoaXMucmFuZ2UgPSB0aGlzLnJhbmdlc1stLXRoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICB3aGlsZSAocG9zID49IHRoaXMucmFuZ2UudG8pXG4gICAgICAgICAgICAgICAgdGhpcy5yYW5nZSA9IHRoaXMucmFuZ2VzWysrdGhpcy5yYW5nZUluZGV4XTtcbiAgICAgICAgICAgIGlmIChwb3MgPj0gdGhpcy5jaHVua1BvcyAmJiBwb3MgPCB0aGlzLmNodW5rUG9zICsgdGhpcy5jaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rT2ZmID0gcG9zIC0gdGhpcy5jaHVua1BvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2h1bmsgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHRoaXMuY2h1bmtPZmYgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWFkTmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgcmVhZChmcm9tLCB0bykge1xuICAgICAgICBpZiAoZnJvbSA+PSB0aGlzLmNodW5rUG9zICYmIHRvIDw9IHRoaXMuY2h1bmtQb3MgKyB0aGlzLmNodW5rLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNodW5rLnNsaWNlKGZyb20gLSB0aGlzLmNodW5rUG9zLCB0byAtIHRoaXMuY2h1bmtQb3MpO1xuICAgICAgICBpZiAoZnJvbSA+PSB0aGlzLmNodW5rMlBvcyAmJiB0byA8PSB0aGlzLmNodW5rMlBvcyArIHRoaXMuY2h1bmsyLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNodW5rMi5zbGljZShmcm9tIC0gdGhpcy5jaHVuazJQb3MsIHRvIC0gdGhpcy5jaHVuazJQb3MpO1xuICAgICAgICBpZiAoZnJvbSA+PSB0aGlzLnJhbmdlLmZyb20gJiYgdG8gPD0gdGhpcy5yYW5nZS50bylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlucHV0LnJlYWQoZnJvbSwgdG8pO1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgciBvZiB0aGlzLnJhbmdlcykge1xuICAgICAgICAgICAgaWYgKHIuZnJvbSA+PSB0bylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChyLnRvID4gZnJvbSlcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5pbnB1dC5yZWFkKE1hdGgubWF4KHIuZnJvbSwgZnJvbSksIE1hdGgubWluKHIudG8sIHRvKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vLy8gQGludGVybmFsXG5jbGFzcyBUb2tlbkdyb3VwIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBpZCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgfVxuICAgIHRva2VuKGlucHV0LCBzdGFjaykgeyByZWFkVG9rZW4odGhpcy5kYXRhLCBpbnB1dCwgc3RhY2ssIHRoaXMuaWQpOyB9XG59XG5Ub2tlbkdyb3VwLnByb3RvdHlwZS5jb250ZXh0dWFsID0gVG9rZW5Hcm91cC5wcm90b3R5cGUuZmFsbGJhY2sgPSBUb2tlbkdyb3VwLnByb3RvdHlwZS5leHRlbmQgPSBmYWxzZTtcbi8vLyBgQGV4dGVybmFsIHRva2Vuc2AgZGVjbGFyYXRpb25zIGluIHRoZSBncmFtbWFyIHNob3VsZCByZXNvbHZlIHRvXG4vLy8gYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbmNsYXNzIEV4dGVybmFsVG9rZW5pemVyIHtcbiAgICAvLy8gQ3JlYXRlIGEgdG9rZW5pemVyLiBUaGUgZmlyc3QgYXJndW1lbnQgaXMgdGhlIGZ1bmN0aW9uIHRoYXQsXG4gICAgLy8vIGdpdmVuIGFuIGlucHV0IHN0cmVhbSwgc2NhbnMgZm9yIHRoZSB0eXBlcyBvZiB0b2tlbnMgaXRcbiAgICAvLy8gcmVjb2duaXplcyBhdCB0aGUgc3RyZWFtJ3MgcG9zaXRpb24sIGFuZCBjYWxsc1xuICAgIC8vLyBbYGFjY2VwdFRva2VuYF0oI2xyLklucHV0U3RyZWFtLmFjY2VwdFRva2VuKSB3aGVuIGl0IGZpbmRzXG4gICAgLy8vIG9uZS5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gQGludGVybmFsXG4gICAgdG9rZW4sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgIHRoaXMuY29udGV4dHVhbCA9ICEhb3B0aW9ucy5jb250ZXh0dWFsO1xuICAgICAgICB0aGlzLmZhbGxiYWNrID0gISFvcHRpb25zLmZhbGxiYWNrO1xuICAgICAgICB0aGlzLmV4dGVuZCA9ICEhb3B0aW9ucy5leHRlbmQ7XG4gICAgfVxufVxuLy8gVG9rZW5pemVyIGRhdGEgaXMgc3RvcmVkIGEgYmlnIHVpbnQxNiBhcnJheSBjb250YWluaW5nLCBmb3IgZWFjaFxuLy8gc3RhdGU6XG4vL1xuLy8gIC0gQSBncm91cCBiaXRtYXNrLCBpbmRpY2F0aW5nIHdoYXQgdG9rZW4gZ3JvdXBzIGFyZSByZWFjaGFibGUgZnJvbVxuLy8gICAgdGhpcyBzdGF0ZSwgc28gdGhhdCBwYXRocyB0aGF0IGNhbiBvbmx5IGxlYWQgdG8gdG9rZW5zIG5vdCBpblxuLy8gICAgYW55IG9mIHRoZSBjdXJyZW50IGdyb3VwcyBjYW4gYmUgY3V0IG9mZiBlYXJseS5cbi8vXG4vLyAgLSBUaGUgcG9zaXRpb24gb2YgdGhlIGVuZCBvZiB0aGUgc3RhdGUncyBzZXF1ZW5jZSBvZiBhY2NlcHRpbmdcbi8vICAgIHRva2Vuc1xuLy9cbi8vICAtIFRoZSBudW1iZXIgb2Ygb3V0Z29pbmcgZWRnZXMgZm9yIHRoZSBzdGF0ZVxuLy9cbi8vICAtIFRoZSBhY2NlcHRpbmcgdG9rZW5zLCBhcyAodG9rZW4gaWQsIGdyb3VwIG1hc2spIHBhaXJzXG4vL1xuLy8gIC0gVGhlIG91dGdvaW5nIGVkZ2VzLCBhcyAoc3RhcnQgY2hhcmFjdGVyLCBlbmQgY2hhcmFjdGVyLCBzdGF0ZVxuLy8gICAgaW5kZXgpIHRyaXBsZXMsIHdpdGggZW5kIGNoYXJhY3RlciBiZWluZyBleGNsdXNpdmVcbi8vXG4vLyBUaGlzIGZ1bmN0aW9uIGludGVycHJldHMgdGhhdCBkYXRhLCBydW5uaW5nIHRocm91Z2ggYSBzdHJlYW0gYXNcbi8vIGxvbmcgYXMgbmV3IHN0YXRlcyB3aXRoIHRoZSBhIG1hdGNoaW5nIGdyb3VwIG1hc2sgY2FuIGJlIHJlYWNoZWQsXG4vLyBhbmQgdXBkYXRpbmcgYHRva2VuYCB3aGVuIGl0IG1hdGNoZXMgYSB0b2tlbi5cbmZ1bmN0aW9uIHJlYWRUb2tlbihkYXRhLCBpbnB1dCwgc3RhY2ssIGdyb3VwKSB7XG4gICAgbGV0IHN0YXRlID0gMCwgZ3JvdXBNYXNrID0gMSA8PCBncm91cCwgeyBwYXJzZXIgfSA9IHN0YWNrLnAsIHsgZGlhbGVjdCB9ID0gcGFyc2VyO1xuICAgIHNjYW46IGZvciAoOzspIHtcbiAgICAgICAgaWYgKChncm91cE1hc2sgJiBkYXRhW3N0YXRlXSkgPT0gMClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBsZXQgYWNjRW5kID0gZGF0YVtzdGF0ZSArIDFdO1xuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoaXMgc3RhdGUgY2FuIGxlYWQgdG8gYSB0b2tlbiBpbiB0aGUgY3VycmVudCBncm91cFxuICAgICAgICAvLyBBY2NlcHQgdG9rZW5zIGluIHRoaXMgc3RhdGUsIHBvc3NpYmx5IG92ZXJ3cml0aW5nXG4gICAgICAgIC8vIGxvd2VyLXByZWNlZGVuY2UgLyBzaG9ydGVyIHRva2Vuc1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhdGUgKyAzOyBpIDwgYWNjRW5kOyBpICs9IDIpXG4gICAgICAgICAgICBpZiAoKGRhdGFbaSArIDFdICYgZ3JvdXBNYXNrKSA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgdGVybSA9IGRhdGFbaV07XG4gICAgICAgICAgICAgICAgaWYgKGRpYWxlY3QuYWxsb3dzKHRlcm0pICYmXG4gICAgICAgICAgICAgICAgICAgIChpbnB1dC50b2tlbi52YWx1ZSA9PSAtMSB8fCBpbnB1dC50b2tlbi52YWx1ZSA9PSB0ZXJtIHx8IHBhcnNlci5vdmVycmlkZXModGVybSwgaW5wdXQudG9rZW4udmFsdWUpKSkge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dC5hY2NlcHRUb2tlbih0ZXJtKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAvLyBEbyBhIGJpbmFyeSBzZWFyY2ggb24gdGhlIHN0YXRlJ3MgZWRnZXNcbiAgICAgICAgZm9yIChsZXQgbmV4dCA9IGlucHV0Lm5leHQsIGxvdyA9IDAsIGhpZ2ggPSBkYXRhW3N0YXRlICsgMl07IGxvdyA8IGhpZ2g7KSB7XG4gICAgICAgICAgICBsZXQgbWlkID0gKGxvdyArIGhpZ2gpID4+IDE7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBhY2NFbmQgKyBtaWQgKyAobWlkIDw8IDEpO1xuICAgICAgICAgICAgbGV0IGZyb20gPSBkYXRhW2luZGV4XSwgdG8gPSBkYXRhW2luZGV4ICsgMV07XG4gICAgICAgICAgICBpZiAobmV4dCA8IGZyb20pXG4gICAgICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPj0gdG8pXG4gICAgICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXRlID0gZGF0YVtpbmRleCArIDJdO1xuICAgICAgICAgICAgICAgIGlucHV0LmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZSBzY2FuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbn1cblxuLy8gU2VlIGxlemVyLWdlbmVyYXRvci9zcmMvZW5jb2RlLnRzIGZvciBjb21tZW50cyBhYm91dCB0aGUgZW5jb2Rpbmdcbi8vIHVzZWQgaGVyZVxuZnVuY3Rpb24gZGVjb2RlQXJyYXkoaW5wdXQsIFR5cGUgPSBVaW50MTZBcnJheSkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIGxldCBhcnJheSA9IG51bGw7XG4gICAgZm9yIChsZXQgcG9zID0gMCwgb3V0ID0gMDsgcG9zIDwgaW5wdXQubGVuZ3RoOykge1xuICAgICAgICBsZXQgdmFsdWUgPSAwO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQocG9zKyspLCBzdG9wID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAobmV4dCA9PSAxMjYgLyogQmlnVmFsQ29kZSAqLykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gNjU1MzUgLyogQmlnVmFsICovO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHQgPj0gOTIgLyogR2FwMiAqLylcbiAgICAgICAgICAgICAgICBuZXh0LS07XG4gICAgICAgICAgICBpZiAobmV4dCA+PSAzNCAvKiBHYXAxICovKVxuICAgICAgICAgICAgICAgIG5leHQtLTtcbiAgICAgICAgICAgIGxldCBkaWdpdCA9IG5leHQgLSAzMiAvKiBTdGFydCAqLztcbiAgICAgICAgICAgIGlmIChkaWdpdCA+PSA0NiAvKiBCYXNlICovKSB7XG4gICAgICAgICAgICAgICAgZGlnaXQgLT0gNDYgLyogQmFzZSAqLztcbiAgICAgICAgICAgICAgICBzdG9wID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlICs9IGRpZ2l0O1xuICAgICAgICAgICAgaWYgKHN0b3ApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB2YWx1ZSAqPSA0NiAvKiBCYXNlICovO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcnJheSlcbiAgICAgICAgICAgIGFycmF5W291dCsrXSA9IHZhbHVlO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBhcnJheSA9IG5ldyBUeXBlKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuXG4vLyBGSVhNRSBmaW5kIHNvbWUgd2F5IHRvIHJlZHVjZSByZWNvdmVyeSB3b3JrIGRvbmUgd2hlbiB0aGUgaW5wdXRcbi8vIGRvZXNuJ3QgbWF0Y2ggdGhlIGdyYW1tYXIgYXQgYWxsLlxuLy8gRW52aXJvbm1lbnQgdmFyaWFibGUgdXNlZCB0byBjb250cm9sIGNvbnNvbGUgb3V0cHV0XG5jb25zdCB2ZXJib3NlID0gdHlwZW9mIHByb2Nlc3MgIT0gXCJ1bmRlZmluZWRcIiAmJiAvXFxicGFyc2VcXGIvLnRlc3QocHJvY2Vzcy5lbnYuTE9HKTtcbmxldCBzdGFja0lEcyA9IG51bGw7XG52YXIgU2FmZXR5O1xuKGZ1bmN0aW9uIChTYWZldHkpIHtcbiAgICBTYWZldHlbU2FmZXR5W1wiTWFyZ2luXCJdID0gMjVdID0gXCJNYXJnaW5cIjtcbn0pKFNhZmV0eSB8fCAoU2FmZXR5ID0ge30pKTtcbmZ1bmN0aW9uIGN1dEF0KHRyZWUsIHBvcywgc2lkZSkge1xuICAgIGxldCBjdXJzb3IgPSB0cmVlLmZ1bGxDdXJzb3IoKTtcbiAgICBjdXJzb3IubW92ZVRvKHBvcyk7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAoIShzaWRlIDwgMCA/IGN1cnNvci5jaGlsZEJlZm9yZShwb3MpIDogY3Vyc29yLmNoaWxkQWZ0ZXIocG9zKSkpXG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgaWYgKChzaWRlIDwgMCA/IGN1cnNvci50byA8IHBvcyA6IGN1cnNvci5mcm9tID4gcG9zKSAmJiAhY3Vyc29yLnR5cGUuaXNFcnJvcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZGUgPCAwID8gTWF0aC5tYXgoMCwgTWF0aC5taW4oY3Vyc29yLnRvIC0gMSwgcG9zIC0gMjUgLyogTWFyZ2luICovKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogTWF0aC5taW4odHJlZS5sZW5ndGgsIE1hdGgubWF4KGN1cnNvci5mcm9tICsgMSwgcG9zICsgMjUgLyogTWFyZ2luICovKSk7XG4gICAgICAgICAgICAgICAgaWYgKHNpZGUgPCAwID8gY3Vyc29yLnByZXZTaWJsaW5nKCkgOiBjdXJzb3IubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWRlIDwgMCA/IDAgOiB0cmVlLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBGcmFnbWVudEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnRzLCBub2RlU2V0KSB7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLm5vZGVTZXQgPSBub2RlU2V0O1xuICAgICAgICB0aGlzLmkgPSAwO1xuICAgICAgICB0aGlzLmZyYWdtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5zYWZlRnJvbSA9IC0xO1xuICAgICAgICB0aGlzLnNhZmVUbyA9IC0xO1xuICAgICAgICB0aGlzLnRyZWVzID0gW107XG4gICAgICAgIHRoaXMuc3RhcnQgPSBbXTtcbiAgICAgICAgdGhpcy5pbmRleCA9IFtdO1xuICAgICAgICB0aGlzLm5leHRGcmFnbWVudCgpO1xuICAgIH1cbiAgICBuZXh0RnJhZ21lbnQoKSB7XG4gICAgICAgIGxldCBmciA9IHRoaXMuZnJhZ21lbnQgPSB0aGlzLmkgPT0gdGhpcy5mcmFnbWVudHMubGVuZ3RoID8gbnVsbCA6IHRoaXMuZnJhZ21lbnRzW3RoaXMuaSsrXTtcbiAgICAgICAgaWYgKGZyKSB7XG4gICAgICAgICAgICB0aGlzLnNhZmVGcm9tID0gZnIub3BlblN0YXJ0ID8gY3V0QXQoZnIudHJlZSwgZnIuZnJvbSArIGZyLm9mZnNldCwgMSkgLSBmci5vZmZzZXQgOiBmci5mcm9tO1xuICAgICAgICAgICAgdGhpcy5zYWZlVG8gPSBmci5vcGVuRW5kID8gY3V0QXQoZnIudHJlZSwgZnIudG8gKyBmci5vZmZzZXQsIC0xKSAtIGZyLm9mZnNldCA6IGZyLnRvO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMudHJlZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmVlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0LnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyZWVzLnB1c2goZnIudHJlZSk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0LnB1c2goLWZyLm9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLmluZGV4LnB1c2goMCk7XG4gICAgICAgICAgICB0aGlzLm5leHRTdGFydCA9IHRoaXMuc2FmZUZyb207XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm5leHRTdGFydCA9IDFlOTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBgcG9zYCBtdXN0IGJlID49IGFueSBwcmV2aW91c2x5IGdpdmVuIGBwb3NgIGZvciB0aGlzIGN1cnNvclxuICAgIG5vZGVBdChwb3MpIHtcbiAgICAgICAgaWYgKHBvcyA8IHRoaXMubmV4dFN0YXJ0KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHdoaWxlICh0aGlzLmZyYWdtZW50ICYmIHRoaXMuc2FmZVRvIDw9IHBvcylcbiAgICAgICAgICAgIHRoaXMubmV4dEZyYWdtZW50KCk7XG4gICAgICAgIGlmICghdGhpcy5mcmFnbWVudClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgbGFzdCA9IHRoaXMudHJlZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGlmIChsYXN0IDwgMCkgeyAvLyBFbmQgb2YgdHJlZVxuICAgICAgICAgICAgICAgIHRoaXMubmV4dEZyYWdtZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdG9wID0gdGhpcy50cmVlc1tsYXN0XSwgaW5kZXggPSB0aGlzLmluZGV4W2xhc3RdO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IHRvcC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyZWVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleC5wb3AoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBuZXh0ID0gdG9wLmNoaWxkcmVuW2luZGV4XTtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMuc3RhcnRbbGFzdF0gKyB0b3AucG9zaXRpb25zW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChzdGFydCA+IHBvcykge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dFN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dCBpbnN0YW5jZW9mIFRyZWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPT0gcG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydCA8IHRoaXMuc2FmZUZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVuZCA9IHN0YXJ0ICsgbmV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmQgPD0gdGhpcy5zYWZlVG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsb29rQWhlYWQgPSBuZXh0LnByb3AoTm9kZVByb3AubG9va0FoZWFkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbG9va0FoZWFkIHx8IGVuZCArIGxvb2tBaGVhZCA8IHRoaXMuZnJhZ21lbnQudG8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleFtsYXN0XSsrO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCArIG5leHQubGVuZ3RoID49IE1hdGgubWF4KHRoaXMuc2FmZUZyb20sIHBvcykpIHsgLy8gRW50ZXIgdGhpcyBub2RlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZXMucHVzaChuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydC5wdXNoKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleC5wdXNoKDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhbbGFzdF0rKztcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRTdGFydCA9IHN0YXJ0ICsgbmV4dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBUb2tlbkNhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIHN0cmVhbSkge1xuICAgICAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBbXTtcbiAgICAgICAgdGhpcy5tYWluVG9rZW4gPSBudWxsO1xuICAgICAgICB0aGlzLmFjdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBwYXJzZXIudG9rZW5pemVycy5tYXAoXyA9PiBuZXcgQ2FjaGVkVG9rZW4pO1xuICAgIH1cbiAgICBnZXRBY3Rpb25zKHN0YWNrKSB7XG4gICAgICAgIGxldCBhY3Rpb25JbmRleCA9IDA7XG4gICAgICAgIGxldCBtYWluID0gbnVsbDtcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSBzdGFjay5wLCB7IHRva2VuaXplcnMgfSA9IHBhcnNlcjtcbiAgICAgICAgbGV0IG1hc2sgPSBwYXJzZXIuc3RhdGVTbG90KHN0YWNrLnN0YXRlLCAzIC8qIFRva2VuaXplck1hc2sgKi8pO1xuICAgICAgICBsZXQgY29udGV4dCA9IHN0YWNrLmN1ckNvbnRleHQgPyBzdGFjay5jdXJDb250ZXh0Lmhhc2ggOiAwO1xuICAgICAgICBsZXQgbG9va0FoZWFkID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbml6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoKCgxIDw8IGkpICYgbWFzaykgPT0gMClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCB0b2tlbml6ZXIgPSB0b2tlbml6ZXJzW2ldLCB0b2tlbiA9IHRoaXMudG9rZW5zW2ldO1xuICAgICAgICAgICAgaWYgKG1haW4gJiYgIXRva2VuaXplci5mYWxsYmFjaylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICh0b2tlbml6ZXIuY29udGV4dHVhbCB8fCB0b2tlbi5zdGFydCAhPSBzdGFjay5wb3MgfHwgdG9rZW4ubWFzayAhPSBtYXNrIHx8IHRva2VuLmNvbnRleHQgIT0gY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ2FjaGVkVG9rZW4odG9rZW4sIHRva2VuaXplciwgc3RhY2spO1xuICAgICAgICAgICAgICAgIHRva2VuLm1hc2sgPSBtYXNrO1xuICAgICAgICAgICAgICAgIHRva2VuLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRva2VuLmxvb2tBaGVhZCA+IHRva2VuLmVuZCArIDI1IC8qIE1hcmdpbiAqLylcbiAgICAgICAgICAgICAgICBsb29rQWhlYWQgPSBNYXRoLm1heCh0b2tlbi5sb29rQWhlYWQsIGxvb2tBaGVhZCk7XG4gICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgIT0gMCAvKiBFcnIgKi8pIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRJbmRleCA9IGFjdGlvbkluZGV4O1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbi5leHRlbmRlZCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25JbmRleCA9IHRoaXMuYWRkQWN0aW9ucyhzdGFjaywgdG9rZW4uZXh0ZW5kZWQsIHRva2VuLmVuZCwgYWN0aW9uSW5kZXgpO1xuICAgICAgICAgICAgICAgIGFjdGlvbkluZGV4ID0gdGhpcy5hZGRBY3Rpb25zKHN0YWNrLCB0b2tlbi52YWx1ZSwgdG9rZW4uZW5kLCBhY3Rpb25JbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKCF0b2tlbml6ZXIuZXh0ZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIG1haW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbkluZGV4ID4gc3RhcnRJbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodGhpcy5hY3Rpb25zLmxlbmd0aCA+IGFjdGlvbkluZGV4KVxuICAgICAgICAgICAgdGhpcy5hY3Rpb25zLnBvcCgpO1xuICAgICAgICBpZiAobG9va0FoZWFkKVxuICAgICAgICAgICAgc3RhY2suc2V0TG9va0FoZWFkKGxvb2tBaGVhZCk7XG4gICAgICAgIGlmICghbWFpbiAmJiBzdGFjay5wb3MgPT0gdGhpcy5zdHJlYW0uZW5kKSB7XG4gICAgICAgICAgICBtYWluID0gbmV3IENhY2hlZFRva2VuO1xuICAgICAgICAgICAgbWFpbi52YWx1ZSA9IHN0YWNrLnAucGFyc2VyLmVvZlRlcm07XG4gICAgICAgICAgICBtYWluLnN0YXJ0ID0gbWFpbi5lbmQgPSBzdGFjay5wb3M7XG4gICAgICAgICAgICBhY3Rpb25JbmRleCA9IHRoaXMuYWRkQWN0aW9ucyhzdGFjaywgbWFpbi52YWx1ZSwgbWFpbi5lbmQsIGFjdGlvbkluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1haW5Ub2tlbiA9IG1haW47XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGlvbnM7XG4gICAgfVxuICAgIGdldE1haW5Ub2tlbihzdGFjaykge1xuICAgICAgICBpZiAodGhpcy5tYWluVG9rZW4pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYWluVG9rZW47XG4gICAgICAgIGxldCBtYWluID0gbmV3IENhY2hlZFRva2VuLCB7IHBvcywgcCB9ID0gc3RhY2s7XG4gICAgICAgIG1haW4uc3RhcnQgPSBwb3M7XG4gICAgICAgIG1haW4uZW5kID0gTWF0aC5taW4ocG9zICsgMSwgcC5zdHJlYW0uZW5kKTtcbiAgICAgICAgbWFpbi52YWx1ZSA9IHBvcyA9PSBwLnN0cmVhbS5lbmQgPyBwLnBhcnNlci5lb2ZUZXJtIDogMCAvKiBFcnIgKi87XG4gICAgICAgIHJldHVybiBtYWluO1xuICAgIH1cbiAgICB1cGRhdGVDYWNoZWRUb2tlbih0b2tlbiwgdG9rZW5pemVyLCBzdGFjaykge1xuICAgICAgICB0b2tlbml6ZXIudG9rZW4odGhpcy5zdHJlYW0ucmVzZXQoc3RhY2sucG9zLCB0b2tlbiksIHN0YWNrKTtcbiAgICAgICAgaWYgKHRva2VuLnZhbHVlID4gLTEpIHtcbiAgICAgICAgICAgIGxldCB7IHBhcnNlciB9ID0gc3RhY2sucDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyc2VyLnNwZWNpYWxpemVkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChwYXJzZXIuc3BlY2lhbGl6ZWRbaV0gPT0gdG9rZW4udmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlci5zcGVjaWFsaXplcnNbaV0odGhpcy5zdHJlYW0ucmVhZCh0b2tlbi5zdGFydCwgdG9rZW4uZW5kKSwgc3RhY2spO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID49IDAgJiYgc3RhY2sucC5wYXJzZXIuZGlhbGVjdC5hbGxvd3MocmVzdWx0ID4+IDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHJlc3VsdCAmIDEpID09IDAgLyogU3BlY2lhbGl6ZSAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi52YWx1ZSA9IHJlc3VsdCA+PiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLmV4dGVuZGVkID0gcmVzdWx0ID4+IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRva2VuLnZhbHVlID0gMCAvKiBFcnIgKi87XG4gICAgICAgICAgICB0b2tlbi5lbmQgPSBNYXRoLm1pbihzdGFjay5wLnN0cmVhbS5lbmQsIHN0YWNrLnBvcyArIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHB1dEFjdGlvbihhY3Rpb24sIHRva2VuLCBlbmQsIGluZGV4KSB7XG4gICAgICAgIC8vIERvbid0IGFkZCBkdXBsaWNhdGUgYWN0aW9uc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4OyBpICs9IDMpXG4gICAgICAgICAgICBpZiAodGhpcy5hY3Rpb25zW2ldID09IGFjdGlvbilcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIHRoaXMuYWN0aW9uc1tpbmRleCsrXSA9IGFjdGlvbjtcbiAgICAgICAgdGhpcy5hY3Rpb25zW2luZGV4KytdID0gdG9rZW47XG4gICAgICAgIHRoaXMuYWN0aW9uc1tpbmRleCsrXSA9IGVuZDtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgICBhZGRBY3Rpb25zKHN0YWNrLCB0b2tlbiwgZW5kLCBpbmRleCkge1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gc3RhY2ssIHsgcGFyc2VyIH0gPSBzdGFjay5wLCB7IGRhdGEgfSA9IHBhcnNlcjtcbiAgICAgICAgZm9yIChsZXQgc2V0ID0gMDsgc2V0IDwgMjsgc2V0KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBwYXJzZXIuc3RhdGVTbG90KHN0YXRlLCBzZXQgPyAyIC8qIFNraXAgKi8gOiAxIC8qIEFjdGlvbnMgKi8pOzsgaSArPSAzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbaV0gPT0gNjU1MzUgLyogRW5kICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhW2kgKyAxXSA9PSAxIC8qIE5leHQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBwYWlyKGRhdGEsIGkgKyAyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PSAwICYmIGRhdGFbaSArIDFdID09IDIgLyogT3RoZXIgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLnB1dEFjdGlvbihwYWlyKGRhdGEsIGkgKyAyKSwgdG9rZW4sIGVuZCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbaV0gPT0gdG9rZW4pXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5wdXRBY3Rpb24ocGFpcihkYXRhLCBpICsgMSksIHRva2VuLCBlbmQsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxufVxudmFyIFJlYztcbihmdW5jdGlvbiAoUmVjKSB7XG4gICAgUmVjW1JlY1tcIkRpc3RhbmNlXCJdID0gNV0gPSBcIkRpc3RhbmNlXCI7XG4gICAgUmVjW1JlY1tcIk1heFJlbWFpbmluZ1BlclN0ZXBcIl0gPSAzXSA9IFwiTWF4UmVtYWluaW5nUGVyU3RlcFwiO1xuICAgIC8vIFdoZW4gdHdvIHN0YWNrcyBoYXZlIGJlZW4gcnVubmluZyBpbmRlcGVuZGVudGx5IGxvbmcgZW5vdWdoIHRvXG4gICAgLy8gYWRkIHRoaXMgbWFueSBlbGVtZW50cyB0byB0aGVpciBidWZmZXJzLCBwcnVuZSBvbmUuXG4gICAgUmVjW1JlY1tcIk1pbkJ1ZmZlckxlbmd0aFBydW5lXCJdID0gNTAwXSA9IFwiTWluQnVmZmVyTGVuZ3RoUHJ1bmVcIjtcbiAgICBSZWNbUmVjW1wiRm9yY2VSZWR1Y2VMaW1pdFwiXSA9IDEwXSA9IFwiRm9yY2VSZWR1Y2VMaW1pdFwiO1xuICAgIC8vIE9uY2UgYSBzdGFjayByZWFjaGVzIHRoaXMgZGVwdGggKGluIC5zdGFjay5sZW5ndGgpIGZvcmNlLXJlZHVjZVxuICAgIC8vIGl0IGJhY2sgdG8gQ3V0VG8gdG8gYXZvaWQgY3JlYXRpbmcgdHJlZXMgdGhhdCBvdmVyZmxvdyB0aGUgc3RhY2tcbiAgICAvLyBvbiByZWN1cnNpdmUgdHJhdmVyc2FsLlxuICAgIFJlY1tSZWNbXCJDdXREZXB0aFwiXSA9IDE1MDAwXSA9IFwiQ3V0RGVwdGhcIjtcbiAgICBSZWNbUmVjW1wiQ3V0VG9cIl0gPSA5MDAwXSA9IFwiQ3V0VG9cIjtcbn0pKFJlYyB8fCAoUmVjID0ge30pKTtcbmNsYXNzIFBhcnNlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgdGhpcy5yZWNvdmVyaW5nID0gMDtcbiAgICAgICAgdGhpcy5uZXh0U3RhY2tJRCA9IDB4MjY1NDsgLy8g4pmULCDimZUsIOKZliwg4pmXLCDimZgsIOKZmSwg4pmgLCDimaEsIOKZoiwg4pmjLCDimaQsIOKZpSwg4pmmLCDimadcbiAgICAgICAgdGhpcy5taW5TdGFja1BvcyA9IDA7XG4gICAgICAgIHRoaXMucmV1c2VkID0gW107XG4gICAgICAgIHRoaXMuc3RvcHBlZEF0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBuZXcgSW5wdXRTdHJlYW0oaW5wdXQsIHJhbmdlcyk7XG4gICAgICAgIHRoaXMudG9rZW5zID0gbmV3IFRva2VuQ2FjaGUocGFyc2VyLCB0aGlzLnN0cmVhbSk7XG4gICAgICAgIHRoaXMudG9wVGVybSA9IHBhcnNlci50b3BbMV07XG4gICAgICAgIGxldCB7IGZyb20gfSA9IHJhbmdlc1swXTtcbiAgICAgICAgdGhpcy5zdGFja3MgPSBbU3RhY2suc3RhcnQodGhpcywgcGFyc2VyLnRvcFswXSwgZnJvbSldO1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cy5sZW5ndGggJiYgdGhpcy5zdHJlYW0uZW5kIC0gZnJvbSA+IHBhcnNlci5idWZmZXJMZW5ndGggKiA0XG4gICAgICAgICAgICA/IG5ldyBGcmFnbWVudEN1cnNvcihmcmFnbWVudHMsIHBhcnNlci5ub2RlU2V0KSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBwYXJzZWRQb3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pblN0YWNrUG9zO1xuICAgIH1cbiAgICAvLyBNb3ZlIHRoZSBwYXJzZXIgZm9yd2FyZC4gVGhpcyB3aWxsIHByb2Nlc3MgYWxsIHBhcnNlIHN0YWNrcyBhdFxuICAgIC8vIGB0aGlzLnBvc2AgYW5kIHRyeSB0byBhZHZhbmNlIHRoZW0gdG8gYSBmdXJ0aGVyIHBvc2l0aW9uLiBJZiBub1xuICAgIC8vIHN0YWNrIGZvciBzdWNoIGEgcG9zaXRpb24gaXMgZm91bmQsIGl0J2xsIHN0YXJ0IGVycm9yLXJlY292ZXJ5LlxuICAgIC8vXG4gICAgLy8gV2hlbiB0aGUgcGFyc2UgaXMgZmluaXNoZWQsIHRoaXMgd2lsbCByZXR1cm4gYSBzeW50YXggdHJlZS4gV2hlblxuICAgIC8vIG5vdCwgaXQgcmV0dXJucyBgbnVsbGAuXG4gICAgYWR2YW5jZSgpIHtcbiAgICAgICAgbGV0IHN0YWNrcyA9IHRoaXMuc3RhY2tzLCBwb3MgPSB0aGlzLm1pblN0YWNrUG9zO1xuICAgICAgICAvLyBUaGlzIHdpbGwgaG9sZCBzdGFja3MgYmV5b25kIGBwb3NgLlxuICAgICAgICBsZXQgbmV3U3RhY2tzID0gdGhpcy5zdGFja3MgPSBbXTtcbiAgICAgICAgbGV0IHN0b3BwZWQsIHN0b3BwZWRUb2tlbnM7XG4gICAgICAgIC8vIEtlZXAgYWR2YW5jaW5nIGFueSBzdGFja3MgYXQgYHBvc2AgdW50aWwgdGhleSBlaXRoZXIgbW92ZVxuICAgICAgICAvLyBmb3J3YXJkIG9yIGNhbid0IGJlIGFkdmFuY2VkLiBHYXRoZXIgc3RhY2tzIHRoYXQgY2FuJ3QgYmVcbiAgICAgICAgLy8gYWR2YW5jZWQgZnVydGhlciBpbiBgc3RvcHBlZGAuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RhY2sgPSBzdGFja3NbaV07XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgdGhpcy50b2tlbnMubWFpblRva2VuID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoc3RhY2sucG9zID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5wdXNoKHN0YWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5hZHZhbmNlU3RhY2soc3RhY2ssIG5ld1N0YWNrcywgc3RhY2tzKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3RvcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcHBlZCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcHBlZFRva2VucyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0b3BwZWQucHVzaChzdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0b2sgPSB0aGlzLnRva2Vucy5nZXRNYWluVG9rZW4oc3RhY2spO1xuICAgICAgICAgICAgICAgICAgICBzdG9wcGVkVG9rZW5zLnB1c2godG9rLnZhbHVlLCB0b2suZW5kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFuZXdTdGFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgZmluaXNoZWQgPSBzdG9wcGVkICYmIGZpbmRGaW5pc2hlZChzdG9wcGVkKTtcbiAgICAgICAgICAgIGlmIChmaW5pc2hlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFja1RvVHJlZShmaW5pc2hlZCk7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJzZXIuc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UgJiYgc3RvcHBlZClcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTdHVjayB3aXRoIHRva2VuIFwiICsgKHRoaXMudG9rZW5zLm1haW5Ub2tlbiA/IHRoaXMucGFyc2VyLmdldE5hbWUodGhpcy50b2tlbnMubWFpblRva2VuLnZhbHVlKSA6IFwibm9uZVwiKSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiTm8gcGFyc2UgYXQgXCIgKyBwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLnJlY292ZXJpbmcpXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvdmVyaW5nID0gNSAvKiBEaXN0YW5jZSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWNvdmVyaW5nICYmIHN0b3BwZWQpIHtcbiAgICAgICAgICAgIGxldCBmaW5pc2hlZCA9IHRoaXMuc3RvcHBlZEF0ICE9IG51bGwgJiYgc3RvcHBlZFswXS5wb3MgPiB0aGlzLnN0b3BwZWRBdCA/IHN0b3BwZWRbMF1cbiAgICAgICAgICAgICAgICA6IHRoaXMucnVuUmVjb3Zlcnkoc3RvcHBlZCwgc3RvcHBlZFRva2VucywgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgIGlmIChmaW5pc2hlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFja1RvVHJlZShmaW5pc2hlZC5mb3JjZUFsbCgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWNvdmVyaW5nKSB7XG4gICAgICAgICAgICBsZXQgbWF4UmVtYWluaW5nID0gdGhpcy5yZWNvdmVyaW5nID09IDEgPyAxIDogdGhpcy5yZWNvdmVyaW5nICogMyAvKiBNYXhSZW1haW5pbmdQZXJTdGVwICovO1xuICAgICAgICAgICAgaWYgKG5ld1N0YWNrcy5sZW5ndGggPiBtYXhSZW1haW5pbmcpIHtcbiAgICAgICAgICAgICAgICBuZXdTdGFja3Muc29ydCgoYSwgYikgPT4gYi5zY29yZSAtIGEuc2NvcmUpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChuZXdTdGFja3MubGVuZ3RoID4gbWF4UmVtYWluaW5nKVxuICAgICAgICAgICAgICAgICAgICBuZXdTdGFja3MucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3U3RhY2tzLnNvbWUocyA9PiBzLnJlZHVjZVBvcyA+IHBvcykpXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvdmVyaW5nLS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV3U3RhY2tzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIC8vIFBydW5lIHN0YWNrcyB0aGF0IGFyZSBpbiB0aGUgc2FtZSBzdGF0ZSwgb3IgdGhhdCBoYXZlIGJlZW5cbiAgICAgICAgICAgIC8vIHJ1bm5pbmcgd2l0aG91dCBzcGxpdHRpbmcgZm9yIGEgd2hpbGUsIHRvIGF2b2lkIGdldHRpbmcgc3R1Y2tcbiAgICAgICAgICAgIC8vIHdpdGggbXVsdGlwbGUgc3VjY2Vzc2Z1bCBzdGFja3MgcnVubmluZyBlbmRsZXNzbHkgb24uXG4gICAgICAgICAgICBvdXRlcjogZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdTdGFja3MubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YWNrID0gbmV3U3RhY2tzW2ldO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IG5ld1N0YWNrcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb3RoZXIgPSBuZXdTdGFja3Nbal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5zYW1lU3RhdGUob3RoZXIpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5idWZmZXIubGVuZ3RoID4gNTAwIC8qIE1pbkJ1ZmZlckxlbmd0aFBydW5lICovICYmIG90aGVyLmJ1ZmZlci5sZW5ndGggPiA1MDAgLyogTWluQnVmZmVyTGVuZ3RoUHJ1bmUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoKHN0YWNrLnNjb3JlIC0gb3RoZXIuc2NvcmUpIHx8IChzdGFjay5idWZmZXIubGVuZ3RoIC0gb3RoZXIuYnVmZmVyLmxlbmd0aCkpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5zcGxpY2Uoai0tLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1pblN0YWNrUG9zID0gbmV3U3RhY2tzWzBdLnBvcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBuZXdTdGFja3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAobmV3U3RhY2tzW2ldLnBvcyA8IHRoaXMubWluU3RhY2tQb3MpXG4gICAgICAgICAgICAgICAgdGhpcy5taW5TdGFja1BvcyA9IG5ld1N0YWNrc1tpXS5wb3M7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzdG9wQXQocG9zKSB7XG4gICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsICYmIHRoaXMuc3RvcHBlZEF0IDwgcG9zKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4ndCBtb3ZlIHN0b3BwZWRBdCBmb3J3YXJkXCIpO1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IHBvcztcbiAgICB9XG4gICAgLy8gUmV0dXJucyBhbiB1cGRhdGVkIHZlcnNpb24gb2YgdGhlIGdpdmVuIHN0YWNrLCBvciBudWxsIGlmIHRoZVxuICAgIC8vIHN0YWNrIGNhbid0IGFkdmFuY2Ugbm9ybWFsbHkuIFdoZW4gYHNwbGl0YCBhbmQgYHN0YWNrc2AgYXJlXG4gICAgLy8gZ2l2ZW4sIHN0YWNrcyBzcGxpdCBvZmYgYnkgYW1iaWd1b3VzIG9wZXJhdGlvbnMgd2lsbCBiZSBwdXNoZWQgdG9cbiAgICAvLyBgc3BsaXRgLCBvciBhZGRlZCB0byBgc3RhY2tzYCBpZiB0aGV5IG1vdmUgYHBvc2AgZm9yd2FyZC5cbiAgICBhZHZhbmNlU3RhY2soc3RhY2ssIHN0YWNrcywgc3BsaXQpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gc3RhY2sucG9zLCB7IHBhcnNlciB9ID0gdGhpcztcbiAgICAgICAgbGV0IGJhc2UgPSB2ZXJib3NlID8gdGhpcy5zdGFja0lEKHN0YWNrKSArIFwiIC0+IFwiIDogXCJcIjtcbiAgICAgICAgaWYgKHRoaXMuc3RvcHBlZEF0ICE9IG51bGwgJiYgc3RhcnQgPiB0aGlzLnN0b3BwZWRBdClcbiAgICAgICAgICAgIHJldHVybiBzdGFjay5mb3JjZVJlZHVjZSgpID8gc3RhY2sgOiBudWxsO1xuICAgICAgICBpZiAodGhpcy5mcmFnbWVudHMpIHtcbiAgICAgICAgICAgIGxldCBzdHJpY3RDeCA9IHN0YWNrLmN1ckNvbnRleHQgJiYgc3RhY2suY3VyQ29udGV4dC50cmFja2VyLnN0cmljdCwgY3hIYXNoID0gc3RyaWN0Q3ggPyBzdGFjay5jdXJDb250ZXh0Lmhhc2ggOiAwO1xuICAgICAgICAgICAgZm9yIChsZXQgY2FjaGVkID0gdGhpcy5mcmFnbWVudHMubm9kZUF0KHN0YXJ0KTsgY2FjaGVkOykge1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IHRoaXMucGFyc2VyLm5vZGVTZXQudHlwZXNbY2FjaGVkLnR5cGUuaWRdID09IGNhY2hlZC50eXBlID8gcGFyc2VyLmdldEdvdG8oc3RhY2suc3RhdGUsIGNhY2hlZC50eXBlLmlkKSA6IC0xO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCA+IC0xICYmIGNhY2hlZC5sZW5ndGggJiYgKCFzdHJpY3RDeCB8fCAoY2FjaGVkLnByb3AoTm9kZVByb3AuY29udGV4dEhhc2gpIHx8IDApID09IGN4SGFzaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sudXNlTm9kZShjYWNoZWQsIG1hdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKHN0YWNrKSArIGAgKHZpYSByZXVzZSBvZiAke3BhcnNlci5nZXROYW1lKGNhY2hlZC50eXBlLmlkKX0pYCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIShjYWNoZWQgaW5zdGFuY2VvZiBUcmVlKSB8fCBjYWNoZWQuY2hpbGRyZW4ubGVuZ3RoID09IDAgfHwgY2FjaGVkLnBvc2l0aW9uc1swXSA+IDApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGxldCBpbm5lciA9IGNhY2hlZC5jaGlsZHJlblswXTtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXIgaW5zdGFuY2VvZiBUcmVlICYmIGNhY2hlZC5wb3NpdGlvbnNbMF0gPT0gMClcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkID0gaW5uZXI7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVmYXVsdFJlZHVjZSA9IHBhcnNlci5zdGF0ZVNsb3Qoc3RhY2suc3RhdGUsIDQgLyogRGVmYXVsdFJlZHVjZSAqLyk7XG4gICAgICAgIGlmIChkZWZhdWx0UmVkdWNlID4gMCkge1xuICAgICAgICAgICAgc3RhY2sucmVkdWNlKGRlZmF1bHRSZWR1Y2UpO1xuICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChzdGFjaykgKyBgICh2aWEgYWx3YXlzLXJlZHVjZSAke3BhcnNlci5nZXROYW1lKGRlZmF1bHRSZWR1Y2UgJiA2NTUzNSAvKiBWYWx1ZU1hc2sgKi8pfSlgKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFjay5zdGFjay5sZW5ndGggPj0gMTUwMDAgLyogQ3V0RGVwdGggKi8pIHtcbiAgICAgICAgICAgIHdoaWxlIChzdGFjay5zdGFjay5sZW5ndGggPiA5MDAwIC8qIEN1dFRvICovICYmIHN0YWNrLmZvcmNlUmVkdWNlKCkpIHsgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBhY3Rpb25zID0gdGhpcy50b2tlbnMuZ2V0QWN0aW9ucyhzdGFjayk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWN0aW9ucy5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgYWN0aW9uID0gYWN0aW9uc1tpKytdLCB0ZXJtID0gYWN0aW9uc1tpKytdLCBlbmQgPSBhY3Rpb25zW2krK107XG4gICAgICAgICAgICBsZXQgbGFzdCA9IGkgPT0gYWN0aW9ucy5sZW5ndGggfHwgIXNwbGl0O1xuICAgICAgICAgICAgbGV0IGxvY2FsU3RhY2sgPSBsYXN0ID8gc3RhY2sgOiBzdGFjay5zcGxpdCgpO1xuICAgICAgICAgICAgbG9jYWxTdGFjay5hcHBseShhY3Rpb24sIHRlcm0sIGVuZCk7XG4gICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKGxvY2FsU3RhY2spICsgYCAodmlhICR7KGFjdGlvbiAmIDY1NTM2IC8qIFJlZHVjZUZsYWcgKi8pID09IDAgPyBcInNoaWZ0XCJcbiAgICAgICAgICAgICAgICAgICAgOiBgcmVkdWNlIG9mICR7cGFyc2VyLmdldE5hbWUoYWN0aW9uICYgNjU1MzUgLyogVmFsdWVNYXNrICovKX1gfSBmb3IgJHtwYXJzZXIuZ2V0TmFtZSh0ZXJtKX0gQCAke3N0YXJ0fSR7bG9jYWxTdGFjayA9PSBzdGFjayA/IFwiXCIgOiBcIiwgc3BsaXRcIn0pYCk7XG4gICAgICAgICAgICBpZiAobGFzdClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGxvY2FsU3RhY2sucG9zID4gc3RhcnQpXG4gICAgICAgICAgICAgICAgc3RhY2tzLnB1c2gobG9jYWxTdGFjayk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc3BsaXQucHVzaChsb2NhbFN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIEFkdmFuY2UgYSBnaXZlbiBzdGFjayBmb3J3YXJkIGFzIGZhciBhcyBpdCB3aWxsIGdvLiBSZXR1cm5zIHRoZVxuICAgIC8vIChwb3NzaWJseSB1cGRhdGVkKSBzdGFjayBpZiBpdCBnb3Qgc3R1Y2ssIG9yIG51bGwgaWYgaXQgbW92ZWRcbiAgICAvLyBmb3J3YXJkIGFuZCB3YXMgZ2l2ZW4gdG8gYHB1c2hTdGFja0RlZHVwYC5cbiAgICBhZHZhbmNlRnVsbHkoc3RhY2ssIG5ld1N0YWNrcykge1xuICAgICAgICBsZXQgcG9zID0gc3RhY2sucG9zO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWR2YW5jZVN0YWNrKHN0YWNrLCBudWxsLCBudWxsKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoc3RhY2sucG9zID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgcHVzaFN0YWNrRGVkdXAoc3RhY2ssIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcnVuUmVjb3Zlcnkoc3RhY2tzLCB0b2tlbnMsIG5ld1N0YWNrcykge1xuICAgICAgICBsZXQgZmluaXNoZWQgPSBudWxsLCByZXN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdGFjayA9IHN0YWNrc1tpXSwgdG9rZW4gPSB0b2tlbnNbaSA8PCAxXSwgdG9rZW5FbmQgPSB0b2tlbnNbKGkgPDwgMSkgKyAxXTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gdmVyYm9zZSA/IHRoaXMuc3RhY2tJRChzdGFjaykgKyBcIiAtPiBcIiA6IFwiXCI7XG4gICAgICAgICAgICBpZiAoc3RhY2suZGVhZEVuZCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXN0YXJ0ZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHJlc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhY2sucmVzdGFydCgpO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKHN0YWNrKSArIFwiIChyZXN0YXJ0ZWQpXCIpO1xuICAgICAgICAgICAgICAgIGxldCBkb25lID0gdGhpcy5hZHZhbmNlRnVsbHkoc3RhY2ssIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZvcmNlID0gc3RhY2suc3BsaXQoKSwgZm9yY2VCYXNlID0gYmFzZTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBmb3JjZS5mb3JjZVJlZHVjZSgpICYmIGogPCAxMCAvKiBGb3JjZVJlZHVjZUxpbWl0ICovOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZm9yY2VCYXNlICsgdGhpcy5zdGFja0lEKGZvcmNlKSArIFwiICh2aWEgZm9yY2UtcmVkdWNlKVwiKTtcbiAgICAgICAgICAgICAgICBsZXQgZG9uZSA9IHRoaXMuYWR2YW5jZUZ1bGx5KGZvcmNlLCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VCYXNlID0gdGhpcy5zdGFja0lEKGZvcmNlKSArIFwiIC0+IFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaW5zZXJ0IG9mIHN0YWNrLnJlY292ZXJCeUluc2VydCh0b2tlbikpIHtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChpbnNlcnQpICsgXCIgKHZpYSByZWNvdmVyLWluc2VydClcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlRnVsbHkoaW5zZXJ0LCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RyZWFtLmVuZCA+IHN0YWNrLnBvcykge1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbkVuZCA9PSBzdGFjay5wb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5FbmQrKztcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSAwIC8qIEVyciAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhY2sucmVjb3ZlckJ5RGVsZXRlKHRva2VuLCB0b2tlbkVuZCk7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoc3RhY2spICsgYCAodmlhIHJlY292ZXItZGVsZXRlICR7dGhpcy5wYXJzZXIuZ2V0TmFtZSh0b2tlbil9KWApO1xuICAgICAgICAgICAgICAgIHB1c2hTdGFja0RlZHVwKHN0YWNrLCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWZpbmlzaGVkIHx8IGZpbmlzaGVkLnNjb3JlIDwgc3RhY2suc2NvcmUpIHtcbiAgICAgICAgICAgICAgICBmaW5pc2hlZCA9IHN0YWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaW5pc2hlZDtcbiAgICB9XG4gICAgLy8gQ29udmVydCB0aGUgc3RhY2sncyBidWZmZXIgdG8gYSBzeW50YXggdHJlZS5cbiAgICBzdGFja1RvVHJlZShzdGFjaykge1xuICAgICAgICBzdGFjay5jbG9zZSgpO1xuICAgICAgICByZXR1cm4gVHJlZS5idWlsZCh7IGJ1ZmZlcjogU3RhY2tCdWZmZXJDdXJzb3IuY3JlYXRlKHN0YWNrKSxcbiAgICAgICAgICAgIG5vZGVTZXQ6IHRoaXMucGFyc2VyLm5vZGVTZXQsXG4gICAgICAgICAgICB0b3BJRDogdGhpcy50b3BUZXJtLFxuICAgICAgICAgICAgbWF4QnVmZmVyTGVuZ3RoOiB0aGlzLnBhcnNlci5idWZmZXJMZW5ndGgsXG4gICAgICAgICAgICByZXVzZWQ6IHRoaXMucmV1c2VkLFxuICAgICAgICAgICAgc3RhcnQ6IHRoaXMucmFuZ2VzWzBdLmZyb20sXG4gICAgICAgICAgICBsZW5ndGg6IHN0YWNrLnBvcyAtIHRoaXMucmFuZ2VzWzBdLmZyb20sXG4gICAgICAgICAgICBtaW5SZXBlYXRUeXBlOiB0aGlzLnBhcnNlci5taW5SZXBlYXRUZXJtIH0pO1xuICAgIH1cbiAgICBzdGFja0lEKHN0YWNrKSB7XG4gICAgICAgIGxldCBpZCA9IChzdGFja0lEcyB8fCAoc3RhY2tJRHMgPSBuZXcgV2Vha01hcCkpLmdldChzdGFjayk7XG4gICAgICAgIGlmICghaWQpXG4gICAgICAgICAgICBzdGFja0lEcy5zZXQoc3RhY2ssIGlkID0gU3RyaW5nLmZyb21Db2RlUG9pbnQodGhpcy5uZXh0U3RhY2tJRCsrKSk7XG4gICAgICAgIHJldHVybiBpZCArIHN0YWNrO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHB1c2hTdGFja0RlZHVwKHN0YWNrLCBuZXdTdGFja3MpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld1N0YWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgb3RoZXIgPSBuZXdTdGFja3NbaV07XG4gICAgICAgIGlmIChvdGhlci5wb3MgPT0gc3RhY2sucG9zICYmIG90aGVyLnNhbWVTdGF0ZShzdGFjaykpIHtcbiAgICAgICAgICAgIGlmIChuZXdTdGFja3NbaV0uc2NvcmUgPCBzdGFjay5zY29yZSlcbiAgICAgICAgICAgICAgICBuZXdTdGFja3NbaV0gPSBzdGFjaztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZXdTdGFja3MucHVzaChzdGFjayk7XG59XG5jbGFzcyBEaWFsZWN0IHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIGZsYWdzLCBkaXNhYmxlZCkge1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgfVxuICAgIGFsbG93cyh0ZXJtKSB7IHJldHVybiAhdGhpcy5kaXNhYmxlZCB8fCB0aGlzLmRpc2FibGVkW3Rlcm1dID09IDA7IH1cbn1cbmNvbnN0IGlkID0geCA9PiB4O1xuLy8vIENvbnRleHQgdHJhY2tlcnMgYXJlIHVzZWQgdG8gdHJhY2sgc3RhdGVmdWwgY29udGV4dCAoc3VjaCBhc1xuLy8vIGluZGVudGF0aW9uIGluIHRoZSBQeXRob24gZ3JhbW1hciwgb3IgcGFyZW50IGVsZW1lbnRzIGluIHRoZSBYTUxcbi8vLyBncmFtbWFyKSBuZWVkZWQgYnkgZXh0ZXJuYWwgdG9rZW5pemVycy4gWW91IGRlY2xhcmUgdGhlbSBpbiBhXG4vLy8gZ3JhbW1hciBmaWxlIGFzIGBAY29udGV4dCBleHBvcnROYW1lIGZyb20gXCJtb2R1bGVcImAuXG4vLy9cbi8vLyBDb250ZXh0IHZhbHVlcyBzaG91bGQgYmUgaW1tdXRhYmxlLCBhbmQgY2FuIGJlIHVwZGF0ZWQgKHJlcGxhY2VkKVxuLy8vIG9uIHNoaWZ0IG9yIHJlZHVjZSBhY3Rpb25zLlxuLy8vXG4vLy8gVGhlIGV4cG9ydCB1c2VkIGluIGEgYEBjb250ZXh0YCBkZWNsYXJhdGlvbiBzaG91bGQgYmUgb2YgdGhpc1xuLy8vIHR5cGUuXG5jbGFzcyBDb250ZXh0VHJhY2tlciB7XG4gICAgLy8vIERlZmluZSBhIGNvbnRleHQgdHJhY2tlci5cbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzcGVjLnN0YXJ0O1xuICAgICAgICB0aGlzLnNoaWZ0ID0gc3BlYy5zaGlmdCB8fCBpZDtcbiAgICAgICAgdGhpcy5yZWR1Y2UgPSBzcGVjLnJlZHVjZSB8fCBpZDtcbiAgICAgICAgdGhpcy5yZXVzZSA9IHNwZWMucmV1c2UgfHwgaWQ7XG4gICAgICAgIHRoaXMuaGFzaCA9IHNwZWMuaGFzaCB8fCAoKCkgPT4gMCk7XG4gICAgICAgIHRoaXMuc3RyaWN0ID0gc3BlYy5zdHJpY3QgIT09IGZhbHNlO1xuICAgIH1cbn1cbi8vLyBBIHBhcnNlciBob2xkcyB0aGUgcGFyc2UgdGFibGVzIGZvciBhIGdpdmVuIGdyYW1tYXIsIGFzIGdlbmVyYXRlZFxuLy8vIGJ5IGBsZXplci1nZW5lcmF0b3JgLlxuY2xhc3MgTFJQYXJzZXIgZXh0ZW5kcyBQYXJzZXIge1xuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vLyBAaW50ZXJuYWxcbiAgICAgICAgdGhpcy53cmFwcGVycyA9IFtdO1xuICAgICAgICBpZiAoc3BlYy52ZXJzaW9uICE9IDEzIC8qIFZlcnNpb24gKi8pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgUGFyc2VyIHZlcnNpb24gKCR7c3BlYy52ZXJzaW9ufSkgZG9lc24ndCBtYXRjaCBydW50aW1lIHZlcnNpb24gKCR7MTMgLyogVmVyc2lvbiAqL30pYCk7XG4gICAgICAgIGxldCBub2RlTmFtZXMgPSBzcGVjLm5vZGVOYW1lcy5zcGxpdChcIiBcIik7XG4gICAgICAgIHRoaXMubWluUmVwZWF0VGVybSA9IG5vZGVOYW1lcy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3BlYy5yZXBlYXROb2RlQ291bnQ7IGkrKylcbiAgICAgICAgICAgIG5vZGVOYW1lcy5wdXNoKFwiXCIpO1xuICAgICAgICBsZXQgdG9wVGVybXMgPSBPYmplY3Qua2V5cyhzcGVjLnRvcFJ1bGVzKS5tYXAociA9PiBzcGVjLnRvcFJ1bGVzW3JdWzFdKTtcbiAgICAgICAgbGV0IG5vZGVQcm9wcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVOYW1lcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIG5vZGVQcm9wcy5wdXNoKFtdKTtcbiAgICAgICAgZnVuY3Rpb24gc2V0UHJvcChub2RlSUQsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgICBub2RlUHJvcHNbbm9kZUlEXS5wdXNoKFtwcm9wLCBwcm9wLmRlc2VyaWFsaXplKFN0cmluZyh2YWx1ZSkpXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNwZWMubm9kZVByb3BzKVxuICAgICAgICAgICAgZm9yIChsZXQgcHJvcFNwZWMgb2Ygc3BlYy5ub2RlUHJvcHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJvcCA9IHByb3BTcGVjWzBdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcHJvcFNwZWMubGVuZ3RoOykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHByb3BTcGVjW2krK107XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFByb3AobmV4dCwgcHJvcCwgcHJvcFNwZWNbaSsrXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBwcm9wU3BlY1tpICsgLW5leHRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IC1uZXh0OyBqID4gMDsgai0tKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFByb3AocHJvcFNwZWNbaSsrXSwgcHJvcCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB0aGlzLm5vZGVTZXQgPSBuZXcgTm9kZVNldChub2RlTmFtZXMubWFwKChuYW1lLCBpKSA9PiBOb2RlVHlwZS5kZWZpbmUoe1xuICAgICAgICAgICAgbmFtZTogaSA+PSB0aGlzLm1pblJlcGVhdFRlcm0gPyB1bmRlZmluZWQgOiBuYW1lLFxuICAgICAgICAgICAgaWQ6IGksXG4gICAgICAgICAgICBwcm9wczogbm9kZVByb3BzW2ldLFxuICAgICAgICAgICAgdG9wOiB0b3BUZXJtcy5pbmRleE9mKGkpID4gLTEsXG4gICAgICAgICAgICBlcnJvcjogaSA9PSAwLFxuICAgICAgICAgICAgc2tpcHBlZDogc3BlYy5za2lwcGVkTm9kZXMgJiYgc3BlYy5za2lwcGVkTm9kZXMuaW5kZXhPZihpKSA+IC0xXG4gICAgICAgIH0pKSk7XG4gICAgICAgIHRoaXMuc3RyaWN0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVmZmVyTGVuZ3RoID0gRGVmYXVsdEJ1ZmZlckxlbmd0aDtcbiAgICAgICAgbGV0IHRva2VuQXJyYXkgPSBkZWNvZGVBcnJheShzcGVjLnRva2VuRGF0YSk7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IHNwZWMuY29udGV4dDtcbiAgICAgICAgdGhpcy5zcGVjaWFsaXplZCA9IG5ldyBVaW50MTZBcnJheShzcGVjLnNwZWNpYWxpemVkID8gc3BlYy5zcGVjaWFsaXplZC5sZW5ndGggOiAwKTtcbiAgICAgICAgdGhpcy5zcGVjaWFsaXplcnMgPSBbXTtcbiAgICAgICAgaWYgKHNwZWMuc3BlY2lhbGl6ZWQpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwZWMuc3BlY2lhbGl6ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNwZWNpYWxpemVkW2ldID0gc3BlYy5zcGVjaWFsaXplZFtpXS50ZXJtO1xuICAgICAgICAgICAgICAgIHRoaXMuc3BlY2lhbGl6ZXJzW2ldID0gc3BlYy5zcGVjaWFsaXplZFtpXS5nZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGVzID0gZGVjb2RlQXJyYXkoc3BlYy5zdGF0ZXMsIFVpbnQzMkFycmF5KTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGVjb2RlQXJyYXkoc3BlYy5zdGF0ZURhdGEpO1xuICAgICAgICB0aGlzLmdvdG8gPSBkZWNvZGVBcnJheShzcGVjLmdvdG8pO1xuICAgICAgICB0aGlzLm1heFRlcm0gPSBzcGVjLm1heFRlcm07XG4gICAgICAgIHRoaXMudG9rZW5pemVycyA9IHNwZWMudG9rZW5pemVycy5tYXAodmFsdWUgPT4gdHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIgPyBuZXcgVG9rZW5Hcm91cCh0b2tlbkFycmF5LCB2YWx1ZSkgOiB2YWx1ZSk7XG4gICAgICAgIHRoaXMudG9wUnVsZXMgPSBzcGVjLnRvcFJ1bGVzO1xuICAgICAgICB0aGlzLmRpYWxlY3RzID0gc3BlYy5kaWFsZWN0cyB8fCB7fTtcbiAgICAgICAgdGhpcy5keW5hbWljUHJlY2VkZW5jZXMgPSBzcGVjLmR5bmFtaWNQcmVjZWRlbmNlcyB8fCBudWxsO1xuICAgICAgICB0aGlzLnRva2VuUHJlY1RhYmxlID0gc3BlYy50b2tlblByZWM7XG4gICAgICAgIHRoaXMudGVybU5hbWVzID0gc3BlYy50ZXJtTmFtZXMgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5tYXhOb2RlID0gdGhpcy5ub2RlU2V0LnR5cGVzLmxlbmd0aCAtIDE7XG4gICAgICAgIHRoaXMuZGlhbGVjdCA9IHRoaXMucGFyc2VEaWFsZWN0KCk7XG4gICAgICAgIHRoaXMudG9wID0gdGhpcy50b3BSdWxlc1tPYmplY3Qua2V5cyh0aGlzLnRvcFJ1bGVzKVswXV07XG4gICAgfVxuICAgIGNyZWF0ZVBhcnNlKGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICBsZXQgcGFyc2UgPSBuZXcgUGFyc2UodGhpcywgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKTtcbiAgICAgICAgZm9yIChsZXQgdyBvZiB0aGlzLndyYXBwZXJzKVxuICAgICAgICAgICAgcGFyc2UgPSB3KHBhcnNlLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xuICAgICAgICByZXR1cm4gcGFyc2U7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBnb3RvIHRhYmxlIGVudHJ5IEBpbnRlcm5hbFxuICAgIGdldEdvdG8oc3RhdGUsIHRlcm0sIGxvb3NlID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IHRhYmxlID0gdGhpcy5nb3RvO1xuICAgICAgICBpZiAodGVybSA+PSB0YWJsZVswXSlcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gdGFibGVbdGVybSArIDFdOzspIHtcbiAgICAgICAgICAgIGxldCBncm91cFRhZyA9IHRhYmxlW3BvcysrXSwgbGFzdCA9IGdyb3VwVGFnICYgMTtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSB0YWJsZVtwb3MrK107XG4gICAgICAgICAgICBpZiAobGFzdCAmJiBsb29zZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgZm9yIChsZXQgZW5kID0gcG9zICsgKGdyb3VwVGFnID4+IDEpOyBwb3MgPCBlbmQ7IHBvcysrKVxuICAgICAgICAgICAgICAgIGlmICh0YWJsZVtwb3NdID09IHN0YXRlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgaWYgKGxhc3QpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vLyBDaGVjayBpZiB0aGlzIHN0YXRlIGhhcyBhbiBhY3Rpb24gZm9yIGEgZ2l2ZW4gdGVybWluYWwgQGludGVybmFsXG4gICAgaGFzQWN0aW9uKHN0YXRlLCB0ZXJtaW5hbCkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgZm9yIChsZXQgc2V0ID0gMDsgc2V0IDwgMjsgc2V0KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnN0YXRlU2xvdChzdGF0ZSwgc2V0ID8gMiAvKiBTa2lwICovIDogMSAvKiBBY3Rpb25zICovKSwgbmV4dDs7IGkgKz0gMykge1xuICAgICAgICAgICAgICAgIGlmICgobmV4dCA9IGRhdGFbaV0pID09IDY1NTM1IC8qIEVuZCAqLykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtpICsgMV0gPT0gMSAvKiBOZXh0ICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGRhdGFbaSA9IHBhaXIoZGF0YSwgaSArIDIpXTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGF0YVtpICsgMV0gPT0gMiAvKiBPdGhlciAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYWlyKGRhdGEsIGkgKyAyKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZXh0ID09IHRlcm1pbmFsIHx8IG5leHQgPT0gMCAvKiBFcnIgKi8pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYWlyKGRhdGEsIGkgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHN0YXRlU2xvdChzdGF0ZSwgc2xvdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZXNbKHN0YXRlICogNiAvKiBTaXplICovKSArIHNsb3RdO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgc3RhdGVGbGFnKHN0YXRlLCBmbGFnKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIDAgLyogRmxhZ3MgKi8pICYgZmxhZykgPiAwO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgdmFsaWRBY3Rpb24oc3RhdGUsIGFjdGlvbikge1xuICAgICAgICBpZiAoYWN0aW9uID09IHRoaXMuc3RhdGVTbG90KHN0YXRlLCA0IC8qIERlZmF1bHRSZWR1Y2UgKi8pKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnN0YXRlU2xvdChzdGF0ZSwgMSAvKiBBY3Rpb25zICovKTs7IGkgKz0gMykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVtpXSA9PSA2NTUzNSAvKiBFbmQgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kYXRhW2kgKyAxXSA9PSAxIC8qIE5leHQgKi8pXG4gICAgICAgICAgICAgICAgICAgIGkgPSBwYWlyKHRoaXMuZGF0YSwgaSArIDIpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFjdGlvbiA9PSBwYWlyKHRoaXMuZGF0YSwgaSArIDEpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vLyBHZXQgdGhlIHN0YXRlcyB0aGF0IGNhbiBmb2xsb3cgdGhpcyBvbmUgdGhyb3VnaCBzaGlmdCBhY3Rpb25zIG9yXG4gICAgLy8vIGdvdG8ganVtcHMuIEBpbnRlcm5hbFxuICAgIG5leHRTdGF0ZXMoc3RhdGUpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIDEgLyogQWN0aW9ucyAqLyk7OyBpICs9IDMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbaV0gPT0gNjU1MzUgLyogRW5kICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVtpICsgMV0gPT0gMSAvKiBOZXh0ICovKVxuICAgICAgICAgICAgICAgICAgICBpID0gcGFpcih0aGlzLmRhdGEsIGkgKyAyKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh0aGlzLmRhdGFbaSArIDJdICYgKDY1NTM2IC8qIFJlZHVjZUZsYWcgKi8gPj4gMTYpKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5kYXRhW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5zb21lKCh2LCBpKSA9PiAoaSAmIDEpICYmIHYgPT0gdmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmRhdGFbaV0sIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgb3ZlcnJpZGVzKHRva2VuLCBwcmV2KSB7XG4gICAgICAgIGxldCBpUHJldiA9IGZpbmRPZmZzZXQodGhpcy5kYXRhLCB0aGlzLnRva2VuUHJlY1RhYmxlLCBwcmV2KTtcbiAgICAgICAgcmV0dXJuIGlQcmV2IDwgMCB8fCBmaW5kT2Zmc2V0KHRoaXMuZGF0YSwgdGhpcy50b2tlblByZWNUYWJsZSwgdG9rZW4pIDwgaVByZXY7XG4gICAgfVxuICAgIC8vLyBDb25maWd1cmUgdGhlIHBhcnNlci4gUmV0dXJucyBhIG5ldyBwYXJzZXIgaW5zdGFuY2UgdGhhdCBoYXMgdGhlXG4gICAgLy8vIGdpdmVuIHNldHRpbmdzIG1vZGlmaWVkLiBTZXR0aW5ncyBub3QgcHJvdmlkZWQgaW4gYGNvbmZpZ2AgYXJlXG4gICAgLy8vIGtlcHQgZnJvbSB0aGUgb3JpZ2luYWwgcGFyc2VyLlxuICAgIGNvbmZpZ3VyZShjb25maWcpIHtcbiAgICAgICAgLy8gSGlkZW91cyByZWZsZWN0aW9uLWJhc2VkIGtsdWRnZSB0byBtYWtlIGl0IGVhc3kgdG8gY3JlYXRlIGFcbiAgICAgICAgLy8gc2xpZ2h0bHkgbW9kaWZpZWQgY29weSBvZiBhIHBhcnNlci5cbiAgICAgICAgbGV0IGNvcHkgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUoTFJQYXJzZXIucHJvdG90eXBlKSwgdGhpcyk7XG4gICAgICAgIGlmIChjb25maWcucHJvcHMpXG4gICAgICAgICAgICBjb3B5Lm5vZGVTZXQgPSB0aGlzLm5vZGVTZXQuZXh0ZW5kKC4uLmNvbmZpZy5wcm9wcyk7XG4gICAgICAgIGlmIChjb25maWcudG9wKSB7XG4gICAgICAgICAgICBsZXQgaW5mbyA9IHRoaXMudG9wUnVsZXNbY29uZmlnLnRvcF07XG4gICAgICAgICAgICBpZiAoIWluZm8pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgdG9wIHJ1bGUgbmFtZSAke2NvbmZpZy50b3B9YCk7XG4gICAgICAgICAgICBjb3B5LnRvcCA9IGluZm87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy50b2tlbml6ZXJzKVxuICAgICAgICAgICAgY29weS50b2tlbml6ZXJzID0gdGhpcy50b2tlbml6ZXJzLm1hcCh0ID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBjb25maWcudG9rZW5pemVycy5maW5kKHIgPT4gci5mcm9tID09IHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZCA/IGZvdW5kLnRvIDogdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAoY29uZmlnLmNvbnRleHRUcmFja2VyKVxuICAgICAgICAgICAgY29weS5jb250ZXh0ID0gY29uZmlnLmNvbnRleHRUcmFja2VyO1xuICAgICAgICBpZiAoY29uZmlnLmRpYWxlY3QpXG4gICAgICAgICAgICBjb3B5LmRpYWxlY3QgPSB0aGlzLnBhcnNlRGlhbGVjdChjb25maWcuZGlhbGVjdCk7XG4gICAgICAgIGlmIChjb25maWcuc3RyaWN0ICE9IG51bGwpXG4gICAgICAgICAgICBjb3B5LnN0cmljdCA9IGNvbmZpZy5zdHJpY3Q7XG4gICAgICAgIGlmIChjb25maWcud3JhcClcbiAgICAgICAgICAgIGNvcHkud3JhcHBlcnMgPSBjb3B5LndyYXBwZXJzLmNvbmNhdChjb25maWcud3JhcCk7XG4gICAgICAgIGlmIChjb25maWcuYnVmZmVyTGVuZ3RoICE9IG51bGwpXG4gICAgICAgICAgICBjb3B5LmJ1ZmZlckxlbmd0aCA9IGNvbmZpZy5idWZmZXJMZW5ndGg7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbiAgICAvLy8gUmV0dXJucyB0aGUgbmFtZSBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiB0ZXJtLiBUaGlzIHdpbGwgb25seVxuICAgIC8vLyB3b3JrIGZvciBhbGwgdGVybXMgd2hlbiB0aGUgcGFyc2VyIHdhcyBnZW5lcmF0ZWQgd2l0aCB0aGVcbiAgICAvLy8gYC0tbmFtZXNgIG9wdGlvbi4gQnkgZGVmYXVsdCwgb25seSB0aGUgbmFtZXMgb2YgdGFnZ2VkIHRlcm1zIGFyZVxuICAgIC8vLyBzdG9yZWQuXG4gICAgZ2V0TmFtZSh0ZXJtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRlcm1OYW1lcyA/IHRoaXMudGVybU5hbWVzW3Rlcm1dIDogU3RyaW5nKHRlcm0gPD0gdGhpcy5tYXhOb2RlICYmIHRoaXMubm9kZVNldC50eXBlc1t0ZXJtXS5uYW1lIHx8IHRlcm0pO1xuICAgIH1cbiAgICAvLy8gVGhlIGVvZiB0ZXJtIGlkIGlzIGFsd2F5cyBhbGxvY2F0ZWQgZGlyZWN0bHkgYWZ0ZXIgdGhlIG5vZGVcbiAgICAvLy8gdHlwZXMuIEBpbnRlcm5hbFxuICAgIGdldCBlb2ZUZXJtKCkgeyByZXR1cm4gdGhpcy5tYXhOb2RlICsgMTsgfVxuICAgIC8vLyBUaGUgdHlwZSBvZiB0b3Agbm9kZSBwcm9kdWNlZCBieSB0aGUgcGFyc2VyLlxuICAgIGdldCB0b3BOb2RlKCkgeyByZXR1cm4gdGhpcy5ub2RlU2V0LnR5cGVzW3RoaXMudG9wWzFdXTsgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBkeW5hbWljUHJlY2VkZW5jZSh0ZXJtKSB7XG4gICAgICAgIGxldCBwcmVjID0gdGhpcy5keW5hbWljUHJlY2VkZW5jZXM7XG4gICAgICAgIHJldHVybiBwcmVjID09IG51bGwgPyAwIDogcHJlY1t0ZXJtXSB8fCAwO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgcGFyc2VEaWFsZWN0KGRpYWxlY3QpIHtcbiAgICAgICAgbGV0IHZhbHVlcyA9IE9iamVjdC5rZXlzKHRoaXMuZGlhbGVjdHMpLCBmbGFncyA9IHZhbHVlcy5tYXAoKCkgPT4gZmFsc2UpO1xuICAgICAgICBpZiAoZGlhbGVjdClcbiAgICAgICAgICAgIGZvciAobGV0IHBhcnQgb2YgZGlhbGVjdC5zcGxpdChcIiBcIikpIHtcbiAgICAgICAgICAgICAgICBsZXQgaWQgPSB2YWx1ZXMuaW5kZXhPZihwYXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoaWQgPj0gMClcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3NbaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgbGV0IGRpc2FibGVkID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIWZsYWdzW2ldKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IHRoaXMuZGlhbGVjdHNbdmFsdWVzW2ldXSwgaWQ7IChpZCA9IHRoaXMuZGF0YVtqKytdKSAhPSA2NTUzNSAvKiBFbmQgKi87KVxuICAgICAgICAgICAgICAgICAgICAoZGlzYWJsZWQgfHwgKGRpc2FibGVkID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5tYXhUZXJtICsgMSkpKVtpZF0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IERpYWxlY3QoZGlhbGVjdCwgZmxhZ3MsIGRpc2FibGVkKTtcbiAgICB9XG4gICAgLy8vICh1c2VkIGJ5IHRoZSBvdXRwdXQgb2YgdGhlIHBhcnNlciBnZW5lcmF0b3IpIEBpbnRlcm5hbFxuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZShzcGVjKSB7XG4gICAgICAgIHJldHVybiBuZXcgTFJQYXJzZXIoc3BlYyk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFpcihkYXRhLCBvZmYpIHsgcmV0dXJuIGRhdGFbb2ZmXSB8IChkYXRhW29mZiArIDFdIDw8IDE2KTsgfVxuZnVuY3Rpb24gZmluZE9mZnNldChkYXRhLCBzdGFydCwgdGVybSkge1xuICAgIGZvciAobGV0IGkgPSBzdGFydCwgbmV4dDsgKG5leHQgPSBkYXRhW2ldKSAhPSA2NTUzNSAvKiBFbmQgKi87IGkrKylcbiAgICAgICAgaWYgKG5leHQgPT0gdGVybSlcbiAgICAgICAgICAgIHJldHVybiBpIC0gc3RhcnQ7XG4gICAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gZmluZEZpbmlzaGVkKHN0YWNrcykge1xuICAgIGxldCBiZXN0ID0gbnVsbDtcbiAgICBmb3IgKGxldCBzdGFjayBvZiBzdGFja3MpIHtcbiAgICAgICAgbGV0IHN0b3BwZWQgPSBzdGFjay5wLnN0b3BwZWRBdDtcbiAgICAgICAgaWYgKChzdGFjay5wb3MgPT0gc3RhY2sucC5zdHJlYW0uZW5kIHx8IHN0b3BwZWQgIT0gbnVsbCAmJiBzdGFjay5wb3MgPiBzdG9wcGVkKSAmJlxuICAgICAgICAgICAgc3RhY2sucC5wYXJzZXIuc3RhdGVGbGFnKHN0YWNrLnN0YXRlLCAyIC8qIEFjY2VwdGluZyAqLykgJiZcbiAgICAgICAgICAgICghYmVzdCB8fCBiZXN0LnNjb3JlIDwgc3RhY2suc2NvcmUpKVxuICAgICAgICAgICAgYmVzdCA9IHN0YWNrO1xuICAgIH1cbiAgICByZXR1cm4gYmVzdDtcbn1cblxuZXhwb3J0IHsgQ29udGV4dFRyYWNrZXIsIEV4dGVybmFsVG9rZW5pemVyLCBJbnB1dFN0cmVhbSwgTFJQYXJzZXIsIFN0YWNrIH07XG4iXSwibmFtZXMiOlsibWFrZVByb21pc2VDYW5jZWxhYmxlIiwicHJvbWlzZSIsImhhc0NhbmNlbGVkXyIsIndyYXBwZWRQcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJ0aGVuIiwidmFsIiwiaXNDYW5jZWxlZCIsImNhdGNoIiwiZXJyb3IiLCJjYW5jZWwiLCJwYXJzZXIiLCJQcm9tUXVlcnlNb2RlbGxlciIsImJ1aWxkVmlzdWFsUXVlcnlGcm9tU3RyaW5nIiwiYWRkTGFiZWxUb1F1ZXJ5IiwicXVlcnkiLCJrZXkiLCJ2YWx1ZSIsIm9wZXJhdG9yIiwiRXJyb3IiLCJ2ZWN0b3JTZWxlY3RvclBvc2l0aW9ucyIsImdldFZlY3RvclNlbGVjdG9yUG9zaXRpb25zIiwibGVuZ3RoIiwiZmlsdGVyIiwidG9MYWJlbEZpbHRlciIsImFkZEZpbHRlciIsInRyZWUiLCJwYXJzZSIsInBvc2l0aW9ucyIsIml0ZXJhdGUiLCJlbnRlciIsInR5cGUiLCJmcm9tIiwidG8iLCJnZXQiLCJuYW1lIiwidmlzUXVlcnkiLCJzdWJzdHJpbmciLCJwdXNoIiwidHJhbnNmb3JtZWRWYWx1ZSIsIkluZmluaXR5IiwidG9TdHJpbmciLCJsYWJlbCIsIm9wIiwibW9kZWxsZXIiLCJuZXdRdWVyeSIsInByZXYiLCJpIiwibWF0Y2giLCJpc0xhc3QiLCJzdGFydCIsImVuZCIsImxhYmVsRXhpc3RzIiwibGFiZWxzIiwibmV3TGFiZWxzIiwicmVuZGVyUXVlcnkiLCJmaW5kIiwiUmVhY3QiLCJDSEVBVF9TSEVFVF9JVEVNUyIsInRpdGxlIiwiZXhwcmVzc2lvbiIsIlByb21DaGVhdFNoZWV0IiwicHJvcHMiLCJtYXAiLCJpdGVtIiwiaW5kZXgiLCJlIiwib25DbGlja0V4YW1wbGUiLCJyZWZJZCIsImV4cHIiLCJjc3MiLCJjeCIsInVzZUVmZmVjdCIsInVzZVN0YXRlIiwidXNlUHJldmlvdXMiLCJJY29uQnV0dG9uIiwiSW5saW5lTGFiZWwiLCJUb29sdGlwIiwidXNlU3R5bGVzMiIsIlByb21FeGVtcGxhckZpZWxkIiwiZGF0YXNvdXJjZSIsIm9uQ2hhbmdlIiwicmVzdCIsInNldEVycm9yIiwic3R5bGVzIiwiZ2V0U3R5bGVzIiwicHJldkVycm9yIiwiZXhlbXBsYXJzQXZhaWxhYmxlIiwiaW5zdGFudCIsInJhbmdlIiwiaWNvbkJ1dHRvblN0eWxlcyIsImFjdGl2ZUljb24iLCJleGVtcGxhciIsImV5ZUljb24iLCJpY29uV3JhcHBlciIsInRoZW1lIiwic3BhY2luZyIsImNvbG9ycyIsInByaW1hcnkiLCJtYWluIiwiaXNFcXVhbCIsIm1lbW8iLCJ1c2VDYWxsYmFjayIsIklubGluZUZvcm1MYWJlbCIsIlJhZGlvQnV0dG9uR3JvdXAiLCJQcm9tRXhwbG9yZUV4dHJhRmllbGQiLCJvblJ1blF1ZXJ5IiwicmFuZ2VPcHRpb25zIiwiZ2V0UXVlcnlUeXBlT3B0aW9ucyIsInByZXZRdWVyeSIsIm9uRXhlbXBsYXJDaGFuZ2UiLCJvbkNoYW5nZVF1ZXJ5U3RlcCIsImludGVydmFsIiwib25TdGVwQ2hhbmdlIiwiY3VycmVudFRhcmdldCIsIm9uUmV0dXJuS2V5RG93biIsInNoaWZ0S2V5Iiwib25RdWVyeVR5cGVDaGFuZ2UiLCJnZXRRdWVyeVR5cGVDaGFuZ2VIYW5kbGVyIiwidGVzdElkcyIsImV4dHJhRmllbGRFZGl0b3IiLCJxdWVyeVR5cGVGaWVsZCIsInN0ZXBGaWVsZCIsImRpc3BsYXlOYW1lIiwiaW5jbHVkZUJvdGgiLCJkZXNjcmlwdGlvbiIsInF1ZXJ5VHlwZSIsIkNvcmVBcHAiLCJQcm9tUXVlcnlGaWVsZCIsIlByb21FeHBsb3JlUXVlcnlFZGl0b3IiLCJkYXRhIiwiaGlzdG9yeSIsInVuZGVmaW5lZCIsIkV4cGxvcmUiLCJlZGl0b3IiLCJ0ZXh0VXRpbCIsInJhbmdlVXRpbCIsIlByb21MaW5rIiwicGFuZWxEYXRhIiwiaHJlZiIsInNldEhyZWYiLCJnZXRFeHRlcm5hbExpbmsiLCJyZXF1ZXN0Iiwic2NvcGVkVmFycyIsImdldFByb21ldGhldXNUaW1lIiwicmFuZ2VEaWZmIiwiTWF0aCIsImNlaWwiLCJlbmRUaW1lIiwidXRjIiwiZm9ybWF0IiwiZW5yaWNoZWRTY29wZWRWYXJzIiwiZ2V0UmF0ZUludGVydmFsU2NvcGVkVmFyaWFibGUiLCJpbnRlcnZhbFRvU2Vjb25kcyIsIm9wdGlvbnMiLCJjdXN0b21RdWVyeVBhcmFtZXRlcnMiLCJrIiwidiIsInF1ZXJ5T3B0aW9ucyIsImNyZWF0ZVF1ZXJ5Iiwic3RlcCIsImFyZ3MiLCJlbmNvZGVVUklDb21wb25lbnQiLCJqb2luIiwiZGlyZWN0VXJsIiwic2FuaXRpemVVcmwiLCJQdXJlQ29tcG9uZW50IiwiTGVnYWN5Rm9ybXMiLCJTZWxlY3QiLCJTd2l0Y2giLCJGT1JNQVRfT1BUSU9OUyIsIklOVEVSVkFMX0ZBQ1RPUl9PUFRJT05TIiwiUHJvbVF1ZXJ5RWRpdG9yIiwiY29uc3RydWN0b3IiLCJvdmVycmlkZSIsIm9wdGlvbiIsInNldFN0YXRlIiwiZm9ybWF0T3B0aW9uIiwidGFyZ2V0IiwiY2hlY2tlZCIsImludGVydmFsRmFjdG9yIiwiaW50ZXJ2YWxGYWN0b3JPcHRpb24iLCJsZWdlbmRGb3JtYXQiLCJpc0VuYWJsZWQiLCJoaWRlIiwiZGVmYXVsdFF1ZXJ5IiwiYXBwIiwiVW5pZmllZEFsZXJ0aW5nIiwiT2JqZWN0IiwiYXNzaWduIiwic3RhdGUiLCJCb29sZWFuIiwicmVuZGVyIiwic2hvd0V4ZW1wbGFyRmllbGQiLCJvbkZpZWxkQ2hhbmdlIiwib25MZWdlbmRDaGFuZ2UiLCJvbkludGVydmFsQ2hhbmdlIiwib25JbnRlcnZhbEZhY3RvckNoYW5nZSIsIm9uRm9ybWF0Q2hhbmdlIiwib25JbnN0YW50Q2hhbmdlIiwiY29uZmlnIiwiUHJvbVF1ZXJ5RWRpdG9yU2VsZWN0b3IiLCJQcm9tUXVlcnlFZGl0b3JGb3JBbGVydGluZyIsIlByb21RdWVyeUVkaXRvckJ5QXBwIiwiQ2xvdWRBbGVydGluZyIsImZlYXR1cmVUb2dnbGVzIiwicHJvbVF1ZXJ5QnVpbGRlciIsImxhbmd1YWdlcyIsInByaXNtTGFuZ3VhZ2VzIiwiaXNEYXRhRnJhbWUiLCJ0b0xlZ2FjeVJlc3BvbnNlRGF0YSIsIlNsYXRlUHJpc20iLCJCcmFjZXNQbHVnaW4iLCJET01VdGlsIiwiSWNvbiIsIkxvY2FsU3RvcmFnZVZhbHVlUHJvdmlkZXIiLCJyb3VuZE1zVG9NaW4iLCJQcm9tZXRoZXVzTWV0cmljc0Jyb3dzZXIiLCJNb25hY29RdWVyeUZpZWxkV3JhcHBlciIsIlJFQ09SRElOR19SVUxFU19HUk9VUCIsIkxBU1RfVVNFRF9MQUJFTFNfS0VZIiwiZ2V0Q2hvb3NlclRleHQiLCJtZXRyaWNzTG9va3VwRGlzYWJsZWQiLCJoYXNTeW50YXgiLCJoYXNNZXRyaWNzIiwid2lsbEFwcGx5U3VnZ2VzdGlvbiIsInN1Z2dlc3Rpb24iLCJ0eXBlYWhlYWRDb250ZXh0IiwidHlwZWFoZWFkVGV4dCIsIm5leHRDaGFyIiwiZ2V0TmV4dENoYXJhY3RlciIsImNvbnRleHQiLCJpbml0SGludHMiLCJnZXRJbml0SGludHMiLCJpbml0SGludCIsInNlcmllcyIsImhpbnQiLCJyZXN1bHQiLCJxdWVyeUhpbnRzIiwiZ2V0UXVlcnlIaW50cyIsInF1ZXJ5SGludCIsImxhbmd1YWdlUHJvdmlkZXIiLCJsYW5ndWFnZVByb3ZpZGVySW5pdGlhbGl6YXRpb25Qcm9taXNlIiwicmVtYWluaW5nVGFza3MiLCJhbGwiLCJvblVwZGF0ZUxhbmd1YWdlIiwiZXJyIiwic2VsZWN0b3IiLCJvbkNoYW5nZVF1ZXJ5IiwibGFiZWxCcm93c2VyVmlzaWJsZSIsIm5leHRRdWVyeSIsIm1vZGlmeVF1ZXJ5IiwiZml4IiwiYWN0aW9uIiwibWV0cmljcyIsInN5bnRheExvYWRlZCIsInR5cGVhaGVhZCIsInN1Z2dlc3Rpb25zIiwicHJlZml4IiwidGV4dCIsIndyYXBwZXJDbGFzc2VzIiwibGFiZWxLZXkiLCJwcm92aWRlQ29tcGxldGlvbkl0ZW1zIiwicGx1Z2lucyIsIm9ubHlJbiIsIm5vZGUiLCJnZXRTeW50YXgiLCJwcm9tcWwiLCJzeW50YXgiLCJjb21wb25lbnREaWRNb3VudCIsInJlZnJlc2hNZXRyaWNzIiwicmVmcmVzaEhpbnQiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsImNvbXBvbmVudERpZFVwZGF0ZSIsInByZXZQcm9wcyIsImNoYW5nZWRSYW5nZVRvUmVmcmVzaCIsInJhbmdlQ2hhbmdlZFRvUmVmcmVzaCIsInByZXZSYW5nZSIsInNhbWVNaW51dGVGcm9tIiwidmFsdWVPZiIsInNhbWVNaW51dGVUbyIsIkV4dHJhRmllbGRFbGVtZW50IiwiY2hvb3NlclRleHQiLCJsb29rdXBzRGlzYWJsZWQiLCJidXR0b25EaXNhYmxlZCIsImxhc3RVc2VkTGFiZWxzIiwib25MYXN0VXNlZExhYmVsc1NhdmUiLCJvbkxhc3RVc2VkTGFiZWxzRGVsZXRlIiwib25DbGlja0Nob29zZXJCdXR0b24iLCJvbkNoYW5nZUxhYmVsQnJvd3NlciIsIm9uQ2xpY2tIaW50Rml4IiwiRml4ZWRTaXplTGlzdCIsIkJ1dHRvbiIsIkhvcml6b250YWxHcm91cCIsIklucHV0IiwiTGFiZWwiLCJMb2FkaW5nUGxhY2Vob2xkZXIiLCJzdHlsZXNGYWN0b3J5Iiwid2l0aFRoZW1lIiwiQnJvd3NlckxhYmVsIiwiUHJvbUxhYmVsIiwiZXNjYXBlTGFiZWxWYWx1ZUluRXhhY3RTZWxlY3RvciIsImVzY2FwZUxhYmVsVmFsdWVJblJlZ2V4U2VsZWN0b3IiLCJFTVBUWV9TRUxFQ1RPUiIsIk1FVFJJQ19MQUJFTCIsIkxJU1RfSVRFTV9TSVpFIiwiYnVpbGRTZWxlY3RvciIsInNpbmdsZU1ldHJpYyIsInNlbGVjdGVkTGFiZWxzIiwic2VsZWN0ZWQiLCJ2YWx1ZXMiLCJzZWxlY3RlZFZhbHVlcyIsImZhY2V0TGFiZWxzIiwicG9zc2libGVMYWJlbHMiLCJsYXN0RmFjZXR0ZWQiLCJwb3NzaWJsZVZhbHVlcyIsImV4aXN0aW5nVmFsdWVzIiwiU2V0IiwiaGFzIiwibG9hZGluZyIsImhpZGRlbiIsImZhY2V0cyIsIndyYXBwZXIiLCJiZzIiLCJzbSIsImxpc3QiLCJzZWN0aW9uIiwibWQiLCJ0eXBvZ3JhcGh5IiwiZm9udEZhbWlseSIsIm1vbm9zcGFjZSIsInN0YXR1cyIsInhzIiwidGV4dFNlbWlXZWFrIiwic3RhdHVzU2hvd2luZyIsInBhbGV0dGUiLCJicmFuZERhbmdlciIsInZhbHVlTGlzdCIsInZhbHVlTGlzdFdyYXBwZXIiLCJib3JkZXIyIiwidmFsdWVMaXN0QXJlYSIsInZhbHVlVGl0bGUiLCJ2YWxpZGF0aW9uU3RhdHVzIiwidGV4dFN0cm9uZyIsIlVudGhlbWVkUHJvbWV0aGV1c01ldHJpY3NCcm93c2VyIiwiQ29tcG9uZW50IiwiY3JlYXRlUmVmIiwibGFiZWxTZWFyY2hUZXJtIiwibWV0cmljU2VhcmNoVGVybSIsInZhbHVlU2VhcmNoVGVybSIsImV2ZW50IiwiZGVsZXRlTGFzdFVzZWRMYWJlbHMiLCJmZXRjaFZhbHVlcyIsImwiLCJuZXh0VmFsdWUiLCJ1cGRhdGVMYWJlbFN0YXRlIiwiZG9GYWNldHRpbmdGb3JMYWJlbCIsImRvRmFjZXR0aW5nIiwic29tZSIsInZhbGlkYXRlU2VsZWN0b3IiLCJmb3JFYWNoIiwiZmV0Y2hTZXJpZXMiLCJ1cGRhdGVkRmllbGRzIiwiY2IiLCJyYXdMYWJlbHMiLCJnZXRMYWJlbEtleXMiLCJhcnIiLCJpbmNsdWRlcyIsInN0b3JlTGFzdFVzZWRMYWJlbHMiLCJyYXdWYWx1ZXMiLCJnZXRMYWJlbFZhbHVlcyIsIm1ldHJpY3NNZXRhZGF0YSIsImxhYmVsVmFsdWUiLCJtZXRhIiwiZGV0YWlscyIsImhlbHAiLCJjb25zb2xlIiwiZmV0Y2hTZXJpZXNMYWJlbHMiLCJrZXlzIiwic3RyZWFtcyIsIm5vbk1ldHJpY0xhYmVscyIsImVtcHR5IiwibWV0cmljQ291bnQiLCJvbkNoYW5nZU1ldHJpY1NlYXJjaCIsIm1pbiIsInN0eWxlIiwib25DbGlja01ldHJpYyIsIm9uQ2hhbmdlTGFiZWxTZWFyY2giLCJoZWlnaHQiLCJvbkNsaWNrTGFiZWwiLCJvbkNoYW5nZVZhbHVlU2VhcmNoIiwidmFsdWVMaXN0c1JlZiIsIm9uQ2xpY2tWYWx1ZSIsIm9uQ2xpY2tSdW5RdWVyeSIsIm9uQ2xpY2tSdW5SYXRlUXVlcnkiLCJvbkNsaWNrVmFsaWRhdGUiLCJvbkNsaWNrQ2xlYXIiLCJTdXNwZW5zZSIsIkZpZWxkIiwibGF6eSIsIk1vbmFjb1F1ZXJ5RmllbGRMYXp5IiwidXNlUmVmIiwibGFzdFJ1blZhbHVlUmVmIiwicnVuUXVlcnlPbkJsdXIiLCJoYW5kbGVSdW5RdWVyeSIsImN1cnJlbnQiLCJoYW5kbGVCbHVyIiwidXNlTWVtbyIsIktub3duQXp1cmVDbG91ZHMiLCJnZXRDcmVkZW50aWFscyIsInVwZGF0ZUNyZWRlbnRpYWxzIiwiQXp1cmVDcmVkZW50aWFsc0Zvcm0iLCJBenVyZUF1dGhTZXR0aW5ncyIsImRhdGFTb3VyY2VDb25maWciLCJjcmVkZW50aWFscyIsIm9uQ3JlZGVudGlhbHNDaGFuZ2UiLCJhenVyZSIsIm1hbmFnZWRJZGVudGl0eUVuYWJsZWQiLCJqc29uRGF0YSIsImF6dXJlRW5kcG9pbnRSZXNvdXJjZUlkIiwiQXp1cmVDbG91ZCIsIlB1YmxpYyIsIkNoaW5hIiwiVVNHb3Zlcm5tZW50IiwiR2VybWFueSIsImlzQ3JlZGVudGlhbHNDb21wbGV0ZSIsImF1dGhUeXBlIiwiYXp1cmVDbG91ZCIsInRlbmFudElkIiwiY2xpZW50SWQiLCJjbGllbnRTZWNyZXQiLCJjb25jZWFsZWQiLCJTeW1ib2wiLCJnZXREZWZhdWx0QXp1cmVDbG91ZCIsImNsb3VkIiwiZ2V0U2VjcmV0Iiwic2VjdXJlSnNvbkZpZWxkcyIsImF6dXJlQ2xpZW50U2VjcmV0Iiwic2VjcmV0Iiwic2VjdXJlSnNvbkRhdGEiLCJoYXNDcmVkZW50aWFscyIsImF6dXJlQ3JlZGVudGlhbHMiLCJnZXREZWZhdWx0Q3JlZGVudGlhbHMiLCJzZXREZWZhdWx0Q3JlZGVudGlhbHMiLCJyZXNldENyZWRlbnRpYWxzIiwiYXp1cmVBdXRoIiwidXNlUmVkdWNlciIsImF1dGhUeXBlT3B0aW9ucyIsImF6dXJlQ2xvdWRPcHRpb25zIiwiZ2V0U3Vic2NyaXB0aW9ucyIsImhhc1JlcXVpcmVkRmllbGRzIiwic3Vic2NyaXB0aW9ucyIsInNldFN1YnNjcmlwdGlvbnMiLCJsb2FkU3Vic2NyaXB0aW9uc0NsaWNrZWQiLCJvbkxvYWRTdWJzY3JpcHRpb25zIiwidXBkYXRlU3Vic2NyaXB0aW9ucyIsImNhbmNlbGVkIiwicmVjZWl2ZWQiLCJhdXRvU2VsZWN0IiwiZGVmYXVsdFN1YnNjcmlwdGlvbklkIiwib25TdWJzY3JpcHRpb25DaGFuZ2UiLCJmb3VuZCIsIm9wdCIsIm9uQXV0aFR5cGVDaGFuZ2UiLCJ1cGRhdGVkIiwib25BenVyZUNsb3VkQ2hhbmdlIiwib25UZW5hbnRJZENoYW5nZSIsIm9uQ2xpZW50SWRDaGFuZ2UiLCJvbkNsaWVudFNlY3JldENoYW5nZSIsIm9uQ2xpZW50U2VjcmV0UmVzZXQiLCJBbGVydGluZ1NldHRpbmdzIiwiRGF0YVNvdXJjZUh0dHBTZXR0aW5ncyIsIkFsZXJ0IiwiZ2V0QWxsQWxlcnRtYW5hZ2VyRGF0YVNvdXJjZXMiLCJQcm9tU2V0dGluZ3MiLCJDb25maWdFZGl0b3IiLCJvbk9wdGlvbnNDaGFuZ2UiLCJhbGVydG1hbmFnZXJzIiwiYXp1cmVBdXRoU2V0dGluZ3MiLCJhenVyZUF1dGhTdXBwb3J0ZWQiLCJnZXRBenVyZUF1dGhFbmFibGVkIiwic2V0QXp1cmVBdXRoRW5hYmxlZCIsImVuYWJsZWQiLCJhenVyZVNldHRpbmdzVUkiLCJhY2Nlc3MiLCJzaWdWNEF1dGhFbmFibGVkIiwic2VsZWN0b3JzIiwiRGF0YVNvdXJjZVBpY2tlciIsIklubGluZUZpZWxkIiwiSW5saW5lU3dpdGNoIiwiRXhlbXBsYXJTZXR0aW5nIiwib25EZWxldGUiLCJpc0ludGVybmFsTGluayIsInNldElzSW50ZXJuYWxMaW5rIiwiZGF0YXNvdXJjZVVpZCIsImNvbXBvbmVudHMiLCJEYXRhU291cmNlIiwiUHJvbWV0aGV1cyIsImNvbmZpZ1BhZ2UiLCJpbnRlcm5hbExpbmtTd2l0Y2giLCJldiIsInByZXZlbnREZWZhdWx0IiwiZHMiLCJ1aWQiLCJ1cmwiLCJ1cmxEaXNwbGF5TGFiZWwiLCJFeGVtcGxhcnNTZXR0aW5ncyIsIm5ld0ZpZWxkIiwibmV3T3B0aW9ucyIsInNwbGljZSIsImV4ZW1wbGFyc0FkZEJ1dHRvbiIsIm9uVXBkYXRlRGF0YXNvdXJjZUpzb25EYXRhT3B0aW9uQ2hlY2tlZCIsInVwZGF0ZURhdGFzb3VyY2VQbHVnaW5Kc29uRGF0YU9wdGlvbiIsIkV2ZW50c1dpdGhWYWxpZGF0aW9uIiwicmVnZXhWYWxpZGF0aW9uIiwiRm9ybUZpZWxkIiwiaHR0cE9wdGlvbnMiLCJodHRwTWV0aG9kIiwidGltZUludGVydmFsIiwib25DaGFuZ2VIYW5kbGVyIiwicHJvbVNldHRpbmdzVmFsaWRhdGlvbkV2ZW50cyIsInF1ZXJ5VGltZW91dCIsIm8iLCJkaXNhYmxlTWV0cmljc0xvb2t1cCIsImV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9ucyIsImV4ZW1wbGFyT3B0aW9ucyIsIm9uQmx1ciIsImdldFZhbHVlRnJvbUV2ZW50SXRlbSIsImV2ZW50SXRlbSIsImhhc093blByb3BlcnR5IiwiY2xvbmVEZWVwIiwiZGVmYXVsdHMiLCJMUlUiLCJmb3JrSm9pbiIsImxhc3RWYWx1ZUZyb20iLCJtZXJnZSIsIm9mIiwicGlwZSIsInRocm93RXJyb3IiLCJjYXRjaEVycm9yIiwidGFwIiwiZGF0ZU1hdGgiLCJMb2FkaW5nU3RhdGUiLCJkYXRlVGltZSIsImdldEJhY2tlbmRTcnYiLCJEYXRhU291cmNlV2l0aEJhY2tlbmQiLCJ0b0RhdGFRdWVyeVJlc3BvbnNlIiwiQmFkZ2UiLCJzYWZlU3RyaW5naWZ5VmFsdWUiLCJmZXRjaERhdGFTb3VyY2VCdWlsZEluZm8iLCJnZXRUaW1lU3J2IiwiZ2V0VGVtcGxhdGVTcnYiLCJQcm9tQXBwbGljYXRpb24iLCJQcm9tZXRoZXVzTGFuZ3VhZ2VQcm92aWRlciIsImV4cGFuZFJlY29yZGluZ1J1bGVzIiwicmVuZGVyTGVnZW5kRm9ybWF0IiwiUHJvbWV0aGV1c01ldHJpY0ZpbmRRdWVyeSIsImdldE9yaWdpbmFsTWV0cmljTmFtZSIsInRyYW5zZm9ybSIsInRyYW5zZm9ybVYyIiwiUHJvbVF1ZXJ5VHlwZSIsIlByb21ldGhldXNWYXJpYWJsZVN1cHBvcnQiLCJBTk5PVEFUSU9OX1FVRVJZX1NURVBfREVGQVVMVCIsIkdFVF9BTkRfUE9TVF9NRVRBREFUQV9FTkRQT0lOVFMiLCJQcm9tZXRoZXVzRGF0YXNvdXJjZSIsImluc3RhbmNlU2V0dGluZ3MiLCJ0ZW1wbGF0ZVNydiIsInRpbWVTcnYiLCJtYXgiLCJsb2FkUnVsZXMiLCJhcmVFeGVtcGxhcnNBdmFpbGFibGUiLCJxdWVyaWVzIiwiYWN0aXZlVGFyZ2V0cyIsImNsb25lZFRhcmdldHMiLCJ0YXJnZXRzIiwicmVxdWVzdElkIiwicGFuZWxJZCIsIm1ldHJpY05hbWUiLCJoaXN0b2dyYW1NZXRyaWNzIiwibSIsImluc3RhbnRUYXJnZXQiLCJ2YWx1ZVdpdGhSZWZJZCIsIm1heERhdGFQb2ludHMiLCJyYW5nZVRhcmdldCIsImFjdGl2ZVRhcmdldCIsImV4ZW1wbGFyVGFyZ2V0IiwibWVzc2FnZSIsInN0YXR1c1RleHQiLCJmcmFtZXMiLCJhbm5vdGF0aW9uIiwidGFnS2V5cyIsInRpdGxlRm9ybWF0IiwidGV4dEZvcm1hdCIsInRhZ0tleXNBcnJheSIsInNwbGl0IiwiZXZlbnRMaXN0IiwiZnJhbWUiLCJ0aW1lRmllbGQiLCJmaWVsZHMiLCJ2YWx1ZUZpZWxkIiwidGFncyIsInRpbWVWYWx1ZVR1cGxlIiwiaWR4IiwidG9BcnJheSIsInRpbWVTdGFtcFZhbHVlIiwidmFsdWVWYWx1ZSIsInRpbWUiLCJ1c2VWYWx1ZUZvclRpbWUiLCJmbG9vciIsInBhcnNlRmxvYXQiLCJhY3RpdmVWYWx1ZXMiLCJhY3RpdmVWYWx1ZXNUaW1lc3RhbXBzIiwibGF0ZXN0RXZlbnQiLCJ0aW1lc3RhbXAiLCJ0aW1lRW5kIiwic3ViVHlwZSIsInJ1bGVyRW5hYmxlZCIsImVkaXRvclNyYyIsImlkIiwiYmFzaWNBdXRoIiwid2l0aENyZWRlbnRpYWxzIiwicnVsZU1hcHBpbmdzIiwiVVJMU2VhcmNoUGFyYW1zIiwidmFyaWFibGVzIiwiZ2V0UXVlcnlEaXNwbGF5VGV4dCIsIl9hZGRUcmFjaW5nSGVhZGVycyIsImhlYWRlcnMiLCJwcm94eU1vZGUiLCJkYXNoYm9hcmRJZCIsIl9yZXF1ZXN0Iiwib3ZlcnJpZGVzIiwibWV0aG9kIiwic2VhcmNoIiwiZW50cmllcyIsIkF1dGhvcml6YXRpb24iLCJmZXRjaCIsImltcG9ydEZyb21BYnN0cmFjdFF1ZXJpZXMiLCJhYnN0cmFjdFF1ZXJpZXMiLCJhYnN0cmFjdFF1ZXJ5IiwiaW1wb3J0RnJvbUFic3RyYWN0UXVlcnkiLCJleHBvcnRUb0Fic3RyYWN0UXVlcmllcyIsImV4cG9ydFRvQWJzdHJhY3RRdWVyeSIsIm1ldGFkYXRhUmVxdWVzdCIsInBhcmFtcyIsImVuZHBvaW50IiwiaGlkZUZyb21JbnNwZWN0b3IiLCJ3YXJuIiwiaW50ZXJwb2xhdGVRdWVyeUV4cHIiLCJ2YXJpYWJsZSIsIm11bHRpIiwiaW5jbHVkZUFsbCIsInByb21ldGhldXNSZWd1bGFyRXNjYXBlIiwicHJvbWV0aGV1c1NwZWNpYWxSZWdleEVzY2FwZSIsImVzY2FwZWRWYWx1ZXMiLCJ0YXJnZXRDb250YWluc1RlbXBsYXRlIiwiY29udGFpbnNUZW1wbGF0ZSIsInNob3VsZFJ1bkV4ZW1wbGFyUXVlcnkiLCJjdXJyZW50VGFyZ2V0SWR4IiwiZmluZEluZGV4IiwidCIsInNsaWNlIiwicHJvY2Vzc1RhcmdldFYyIiwicHJvY2Vzc2VkVGFyZ2V0IiwidGltZVNlcmllc1F1ZXJ5IiwidXRjT2Zmc2V0U2VjIiwidGltZVJhbmdlIiwidXRjT2Zmc2V0IiwicmVzcG9uc2UiLCJwcmVwYXJlVGFyZ2V0cyIsIkRvbmUiLCJleHBsb3JlUXVlcnkiLCJwYW5lbHNRdWVyeSIsInJ1bm5pbmdRdWVyaWVzQ291bnQiLCJzdWJRdWVyaWVzIiwiZmlsdGVyQW5kTWFwUmVzcG9uc2UiLCJjYW5jZWxsZWQiLCJyZXNwb25zZUxpc3RMZW5ndGgiLCJMb2FkaW5nIiwicnVuUXVlcnkiLCJvYnNlcnZhYmxlcyIsInJlc3VsdHMiLCJyZWR1Y2UiLCJwZXJmb3JtSW5zdGFudFF1ZXJ5IiwiZ2V0RXhlbXBsYXJzIiwicGVyZm9ybVRpbWVTZXJpZXNRdWVyeSIsImhpbnRpbmciLCJtaW5JbnRlcnZhbCIsInJlcGxhY2UiLCJzY3JhcGVJbnRlcnZhbCIsImFkanVzdGVkSW50ZXJ2YWwiLCJhZGp1c3RJbnRlcnZhbCIsImdldFJhbmdlU2NvcGVkVmFycyIsIl9faW50ZXJ2YWwiLCJfX2ludGVydmFsX21zIiwiZW5oYW5jZUV4cHJXaXRoQWRIb2NGaWx0ZXJzIiwiYWRqdXN0ZWQiLCJhbGlnblJhbmdlIiwicmF0ZUludGVydmFsIiwiX19yYXRlX2ludGVydmFsIiwic2FmZUludGVydmFsIiwiaGFuZGxlRXJyb3JzIiwibWV0cmljRmluZFF1ZXJ5IiwiaW50ZXJ2YWxUb01zIiwiaW50ZXJwb2xhdGVkIiwicHJvY2VzcyIsIm1zUmFuZ2UiLCJkaWZmIiwic1JhbmdlIiwicm91bmQiLCJfX3JhbmdlX21zIiwiX19yYW5nZV9zIiwiX19yYW5nZSIsImFubm90YXRpb25RdWVyeSIsInF1ZXJ5TW9kZWwiLCJnZXRSZWYiLCJhcHBseVRlbXBsYXRlVmFyaWFibGVzIiwicnNwIiwicHJvY2Vzc0Fubm90YXRpb25SZXNwb25zZSIsImdldFN1YnRpdGxlIiwiYnVpbGRJbmZvIiwiZ2V0QnVpbGRJbmZvIiwiZ2V0QnVpbGRJbmZvTWVzc2FnZSIsImdldFRhZ0tleXMiLCJzZXJpZXNMYWJlbHMiLCJ1bmlxdWVMYWJlbHMiLCJnZXRUYWdWYWx1ZXMiLCJkaXNhYmxlZCIsInVuc3VwcG9ydGVkIiwiTE9HT1MiLCJDb3J0ZXgiLCJNaW1pciIsIkNPTE9SUyIsImFwcGxpY2F0aW9uU3ViVHlwZSIsIndpZHRoIiwidmVydGljYWxBbGlnbiIsImFwcGxpY2F0aW9uIiwiZGlzcGxheSIsImdyaWRUZW1wbGF0ZUNvbHVtbnMiLCJyb3dHYXAiLCJjb2x1bW5HYXAiLCJtYXJnaW5Ub3AiLCJmZWF0dXJlcyIsInJ1bGVyQXBpRW5hYmxlZCIsInRlc3REYXRhc291cmNlIiwibm93IiwiRGF0ZSIsImdldFRpbWUiLCJpbnRlcnZhbE1zIiwicmVzIiwidmVyYm9zZU1lc3NhZ2UiLCJpbnRlcnBvbGF0ZVZhcmlhYmxlc0luUXVlcmllcyIsImV4cGFuZGVkUXVlcmllcyIsImV4cGFuZGVkUXVlcnkiLCJncm91cHMiLCJleHRyYWN0UnVsZU1hcHBpbmdGcm9tR3JvdXBzIiwibG9nIiwidHJpbSIsIm1hcHBpbmciLCJkYXRlIiwicm91bmRVcCIsImdldFRpbWVSYW5nZVBhcmFtcyIsImxhYmVsRGF0YSIsImFkaG9jRmlsdGVycyIsImdldEFkaG9jRmlsdGVycyIsImZpbmFsUXVlcnkiLCJhY2MiLCJmaWx0ZXJRdWVyeSIsImdldFZhcmlhYmxlcyIsImludGVycG9sYXRlU3RyaW5nIiwic3RyaW5nIiwiYWxpZ25lZEVuZCIsImFsaWduZWRTdGFydCIsImdyb3VwIiwicnVsZXMiLCJydWxlIiwib25jZSIsImNoYWluIiwiZGlmZmVyZW5jZSIsIlByaXNtIiwiQWJzdHJhY3RMYWJlbE9wZXJhdG9yIiwiTGFuZ3VhZ2VQcm92aWRlciIsIlNlYXJjaEZ1bmN0aW9uVHlwZSIsImFkZExpbWl0SW5mbyIsImV4dHJhY3RMYWJlbE1hdGNoZXJzIiwiZml4U3VtbWFyaWVzTWV0YWRhdGEiLCJwYXJzZVNlbGVjdG9yIiwicHJvY2Vzc0hpc3RvZ3JhbU1ldHJpY3MiLCJwcm9jZXNzTGFiZWxzIiwicm91bmRTZWNUb01pbiIsInRvUHJvbUxpa2VRdWVyeSIsIlByb21xbFN5bnRheCIsIkZVTkNUSU9OUyIsIlJBVEVfUkFOR0VTIiwiREVGQVVMVF9LRVlTIiwiSElTVE9SWV9JVEVNX0NPVU5UIiwiSElTVE9SWV9DT1VOVF9DVVRPRkYiLCJTVUdHRVNUSU9OU19MSU1JVCIsIndyYXBMYWJlbCIsInNldEZ1bmN0aW9uS2luZCIsImtpbmQiLCJhZGRIaXN0b3J5TWV0YWRhdGEiLCJjdXRvZmZUcyIsImhpc3RvcnlGb3JJdGVtIiwiaCIsInRzIiwiY291bnQiLCJyZWNlbnQiLCJsYXN0UXVlcmllZCIsImZyb21Ob3ciLCJkb2N1bWVudGF0aW9uIiwiYWRkTWV0cmljc01ldGFkYXRhIiwibWV0cmljIiwibWV0YWRhdGEiLCJnZXRNZXRhZGF0YVN0cmluZyIsInRvVXBwZXJDYXNlIiwiUFJFRklYX0RFTElNSVRFUl9SRUdFWCIsIlByb21RbExhbmd1YWdlUHJvdmlkZXIiLCJpbml0aWFsVmFsdWVzIiwiZGVmYXVsdFZhbHVlIiwiZmV0Y2hMYWJlbHMiLCJmZXRjaExhYmVsVmFsdWVzIiwibG9hZE1ldHJpY3NNZXRhZGF0YSIsInNvcnQiLCJlbXB0eVJlc3VsdCIsImRvY3VtZW50Iiwic2VsZWN0ZWRMaW5lcyIsImdldFRleHRzQXRSYW5nZSIsInNlbGVjdGlvbiIsImN1cnJlbnRMaW5lIiwic2l6ZSIsImZpcnN0IiwiZ2V0VGV4dCIsIm5leHRDaGFyYWN0ZXIiLCJhbmNob3IiLCJvZmZzZXQiLCJ0b2tlblJlY29nbml6ZWQiLCJwcmVmaXhVbnJlY29nbml6ZWQiLCJub1N1ZmZpeCIsInNhZmVQcmVmaXgiLCJvcGVyYXRvcnNQYXR0ZXJuIiwiaXNOZXh0T3BlcmFuZCIsImdldFJhbmdlQ29tcGxldGlvbkl0ZW1zIiwiZ2V0TGFiZWxDb21wbGV0aW9uSXRlbXMiLCJnZXRBZ2dyZWdhdGlvbkNvbXBsZXRpb25JdGVtcyIsImdldEVtcHR5Q29tcGxldGlvbkl0ZW1zIiwiZ2V0QmVnaW5uaW5nQ29tcGxldGlvbkl0ZW1zIiwiZ2V0VGVybUNvbXBsZXRpb25JdGVtcyIsImhpc3RvcnlJdGVtcyIsInVuaXEiLCJ0YWtlIiwic2VhcmNoRnVuY3Rpb25UeXBlIiwiUHJlZml4Iiwic2tpcFNvcnQiLCJpdGVtcyIsIkZ1enp5IiwicXVlcnlPZmZzZXQiLCJxdWVyeVRleHQiLCJnZXRCbG9ja3MiLCJibG9jayIsImJsb2NrVGV4dCIsImFuY2hvckJsb2NrIiwib3BlblBhcmVuc0FnZ3JlZ2F0aW9uSW5kZXgiLCJsYXN0SW5kZXhPZiIsIm9wZW5QYXJlbnNTZWxlY3RvckluZGV4IiwiY2xvc2VQYXJlbnNTZWxlY3RvckluZGV4IiwiaW5kZXhPZiIsImNsb3NlUGFyZW5zQWdncmVnYXRpb25JbmRleCIsInNlbGVjdG9yU3RyaW5nIiwiZ2V0U2VyaWVzIiwibGFiZWxLZXlzIiwibGltaXRJbmZvIiwibGluZSIsImN1cnNvck9mZnNldCIsInN1ZmZpeCIsInN1YnN0ciIsImlzVmFsdWVTdGFydCIsImlzVmFsdWVFbmQiLCJpc1ByZVZhbHVlIiwiaXNWYWx1ZUVtcHR5IiwiaGFzVmFsdWVQcmVmaXgiLCJwYXJzZWRTZWxlY3RvciIsImNvbnRhaW5zTWV0cmljIiwiZXhpc3RpbmdLZXlzIiwicG9zc2libGVLZXlzIiwibmV3SXRlbXMiLCJuZXdTdWdnZXN0aW9uIiwid2l0aE5hbWUiLCJpbnRlcnBvbGF0ZWROYW1lIiwidXJsUGFyYW1zIiwiY2FjaGVQYXJhbXMiLCJwYXJzZUludCIsImNhY2hlS2V5IiwibGFiZWxzQ2FjaGUiLCJzZXQiLCJjbGVhblRleHQiLCJzIiwicGFydHMiLCJsYXN0IiwicG9wIiwidHJpbUxlZnQiLCJsYWJlbEJhc2VkUXVlcnkiLCJwcm9tUXVlcnkiLCJsYWJlbE1hdGNoZXJzIiwidG9rZW5zIiwidG9rZW5pemUiLCJuYW1lTGFiZWxWYWx1ZSIsImdldE5hbWVMYWJlbFZhbHVlIiwiRXF1YWwiLCJmZXRjaERlZmF1bHRTZXJpZXMiLCJsYWJlbEZldGNoVHMiLCJBcnJheSIsImlzQXJyYXkiLCJwcm9wIiwiaW52ZXJ0IiwiVG9rZW4iLCJyZXN1bHRTZXQiLCJyZWdleHAiLCJSZWdFeHAiLCJpc0hpc3RvZ3JhbVZhbHVlIiwidGVzdCIsImFkZCIsInZhbHVlU2V0IiwiX19uYW1lX18iLCJ2YWx1ZUFycmF5IiwibGltaXRTdWdnZXN0aW9ucyIsInNlbGVjdG9yUmVnZXhwIiwibGFiZWxSZWdleHAiLCJwcmVmaXhPcGVuIiwicHJlZml4Q2xvc2UiLCJzdWZmaXhDbG9zZUluZGV4Iiwic3VmZml4Q2xvc2UiLCJzdWZmaXhPcGVuSW5kZXgiLCJzdWZmaXhPcGVuIiwibGFiZWxPZmZzZXQiLCJ2YWx1ZVN0YXJ0IiwidmFsdWVFbmQiLCJtZXRyaWNQcmVmaXgiLCJtZXRyaWNNYXRjaCIsImNsZWFuU2VsZWN0b3IiLCJydWxlTmFtZXMiLCJydWxlc1JlZ2V4IiwicHJlIiwicG9zdCIsInF1ZXJ5QXJyYXkiLCJpbnZhbGlkTGFiZWxzUmVnZXgiLCJjb3JyZWN0bHlFeHBhbmRlZFF1ZXJ5QXJyYXkiLCJhZGRMYWJlbHNUb0V4cHJlc3Npb24iLCJpbnZhbGlkTGFiZWxzUmVnZXhwIiwiaW5kZXhPZlJlZ2V4TWF0Y2giLCJleHByQmVmb3JlUmVnZXhNYXRjaCIsImV4cHJBZnRlclJlZ2V4TWF0Y2giLCJhcnJheU9mTGFiZWxPYmplY3RzIiwib2JqIiwiYmFzZU1ldGFkYXRhIiwic3VtbWFyeU1ldGFkYXRhIiwic3ludGhldGljTWV0YWRhdGEiLCJtaWxsaXNlY29uZHMiLCJzZWNvbmRzIiwiUkUyX01FVEFDSEFSQUNURVJTIiwiZXNjYXBlUHJvbWV0aGV1c1JlZ2V4cCIsIkZyb21Qcm9tTGlrZU1hcCIsIk5vdEVxdWFsIiwiRXF1YWxSZWdFeCIsIk5vdEVxdWFsUmVnRXgiLCJUb1Byb21MaWtlTWFwIiwidG9Qcm9tTGlrZUV4cHIiLCJ0b2tlbiIsImxhYmVsT3BlcmF0b3IiLCJjb250ZW50VG9rZW5zIiwiY29udGVudCIsImN1cnJlbnRUb2tlbiIsImN1cnJlbnRTdHIiLCJsYWJlbENvbXBhcmF0b3IiLCJfbWFwIiwibGFiZWxOYW1lc1JlZ2V4IiwibGFiZWxWYWx1ZXNSZWdleCIsIm1ldHJpY05hbWVzUmVnZXgiLCJxdWVyeVJlc3VsdFJlZ2V4IiwibGFiZWxOYW1lc1F1ZXJ5IiwibGFiZWxWYWx1ZXNRdWVyeSIsIm1ldHJpY05hbWVzUXVlcnkiLCJtZXRyaWNOYW1lUXVlcnkiLCJxdWVyeVJlc3VsdFF1ZXJ5IiwibWV0cmljTmFtZUFuZExhYmVsc1F1ZXJ5IiwiX2xhYmVscyIsImV4cGFuZGFibGUiLCJtZXRyaWNGaWx0ZXJQYXR0ZXJuIiwiciIsIm1hdGNoZWRNZXRyaWNOYW1lIiwiaW5zdGFudFF1ZXJ5IiwibWV0cmljRGF0YSIsInNlbGYiLCJEYXRhU291cmNlUGx1Z2luIiwiUHJvbWV0aGV1c0Fubm90YXRpb25zUXVlcnlDdHJsIiwicGx1Z2luIiwic2V0UXVlcnlFZGl0b3IiLCJzZXRDb25maWdFZGl0b3IiLCJzZXRBbm5vdGF0aW9uUXVlcnlDdHJsIiwic2V0UXVlcnlFZGl0b3JIZWxwIiwic29ydFZhbHVlIiwiT1BFUkFUT1JTIiwiTE9HSUNBTF9PUEVSQVRPUlMiLCJUUklHT05PTUVUUklDX0ZVTkNUSU9OUyIsImluc2VydFRleHQiLCJkZXRhaWwiLCJBR0dSRUdBVElPTl9PUEVSQVRPUlMiLCJQUk9NX0tFWVdPUkRTIiwia2V5d29yZCIsInByb21xbEdyYW1tYXIiLCJjb21tZW50IiwicGF0dGVybiIsImxvb2tiZWhpbmQiLCJpbnNpZGUiLCJhbGlhcyIsInB1bmN0dWF0aW9uIiwiZ3JlZWR5IiwiZnVuY3Rpb24iLCJmIiwiaWRMaXN0IiwibnVtYmVyIiwiU1VNX0hJTlRfVEhSRVNIT0xEX0NPVU5UIiwiaGludHMiLCJoaXN0b2dyYW1NZXRyaWMiLCJuYW1lTWF0Y2giLCJjb3VudGVyTmFtZU1ldHJpYyIsIm1ldHJpY01ldGFkYXRhS2V5cyIsImNlcnRhaW4iLCJ0b0xvd2VyQ2FzZSIsIm1ldHJpY1JlZ2V4IiwiZml4YWJsZVF1ZXJ5IiwidmVyYiIsIm1hcHBpbmdGb3JRdWVyeSIsInJ1bGVOYW1lIiwic2ltcGxlTWV0cmljIiwicHJldmVudFN1Ym1pdCIsImdldEFnZ3JlZ2F0aW9uT3BlcmF0aW9ucyIsImdldE9wZXJhdGlvbkRlZmluaXRpb25zIiwiTG9raUFuZFByb21RdWVyeU1vZGVsbGVyQmFzZSIsIlByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5IiwiYWxsT3BlcmF0aW9ucyIsImZ1bmMiLCJ4Iiwic2V0T3BlcmF0aW9uQ2F0ZWdvcmllcyIsIkFnZ3JlZ2F0aW9ucyIsIlJhbmdlRnVuY3Rpb25zIiwiRnVuY3Rpb25zIiwiQmluYXJ5T3BzIiwiVHJpZ29ub21ldHJpYyIsIlRpbWUiLCJnZXRRdWVyeVBhdHRlcm5zIiwib3BlcmF0aW9ucyIsInByb21RdWVyeU1vZGVsbGVyIiwiYWRkT3BlcmF0aW9uV2l0aFJhbmdlVmVjdG9yIiwiY3JlYXRlQWdncmVnYXRpb25PcGVyYXRpb24iLCJjcmVhdGVBZ2dyZWdhdGlvbk9wZXJhdGlvbldpdGhQYXJhbSIsImdldFByb21BbmRMb2tpT3BlcmF0aW9uRGlzcGxheU5hbWUiLCJnZXRSYW5nZVZlY3RvclBhcmFtRGVmIiwiUHJvbU9wZXJhdGlvbklkIiwiU3VtIiwiQXZnIiwiTWluIiwiTWF4IiwiQ291bnQiLCJUb3BLIiwiZGVmYXVsdFBhcmFtcyIsIkJvdHRvbUsiLCJDb3VudFZhbHVlcyIsImNyZWF0ZUFnZ3JlZ2F0aW9uT3ZlclRpbWUiLCJTdW1PdmVyVGltZSIsIkF2Z092ZXJUaW1lIiwiTWluT3ZlclRpbWUiLCJNYXhPdmVyVGltZSIsIkNvdW50T3ZlclRpbWUiLCJMYXN0T3ZlclRpbWUiLCJQcmVzZW50T3ZlclRpbWUiLCJBYnNlbnRPdmVyVGltZSIsIlN0ZGRldk92ZXJUaW1lIiwiYWx0ZXJuYXRpdmVzS2V5IiwiY2F0ZWdvcnkiLCJyZW5kZXJlciIsIm9wZXJhdGlvbldpdGhSYW5nZVZlY3RvclJlbmRlcmVyIiwiYWRkT3BlcmF0aW9uSGFuZGxlciIsIm1vZGVsIiwiZGVmIiwiaW5uZXJFeHByIiwicmFuZ2VWZWN0b3IiLCJkZWZhdWx0QWRkT3BlcmF0aW9uSGFuZGxlciIsImJpbmFyeVNjYWxhckRlZnMiLCJBZGRpdGlvbiIsInNpZ24iLCJTdWJ0cmFjdGlvbiIsIk11bHRpcGx5QnkiLCJEaXZpZGVCeSIsIk1vZHVsbyIsIkV4cG9uZW50IiwiRXF1YWxUbyIsImNvbXBhcmlzb24iLCJOb3RFcXVhbFRvIiwiR3JlYXRlclRoYW4iLCJMZXNzVGhhbiIsIkdyZWF0ZXJPckVxdWFsIiwiTGVzc09yRXF1YWwiLCJiaW5hcnlTY2FsYXJPcGVyYXRvclRvT3BlcmF0b3JOYW1lIiwiYmluYXJ5U2NhbGFyT3BlcmF0aW9ucyIsIm9wRGVmIiwiZ2V0U2ltcGxlQmluYXJ5UmVuZGVyZXIiLCJiaW5hcnlSZW5kZXJlciIsInBhcmFtIiwiYm9vbCIsInRvT3B0aW9uIiwiZ2V0T3BlcmF0aW9uUGFyYW1JZCIsIkxhYmVsUGFyYW1FZGl0b3IiLCJvcGVyYXRpb25JbmRleCIsImlzTG9hZGluZyIsImxvYWRHcm91cEJ5TGFiZWxzIiwicmVuZGVyTGFiZWxzIiwiSGlnaGxpZ2h0ZXIiLCJFZGl0b3JGaWVsZCIsIkVkaXRvckZpZWxkR3JvdXAiLCJzcGxpdFNlcGFyYXRvciIsIk1ldHJpY1NlbGVjdCIsIm9uR2V0TWV0cmljcyIsImN1c3RvbUZpbHRlck9wdGlvbiIsInNlYXJjaFF1ZXJ5Iiwic2VhcmNoV29yZHMiLCJjdXIiLCJmb3JtYXRPcHRpb25MYWJlbCIsImlucHV0VmFsdWUiLCJoaWdobGlnaHQiLCJzZWxlY3QiLCJ3YXJuaW5nIiwiRWRpdG9yUm93cyIsIkZsZXhJdGVtIiwiQXV0b1NpemVJbnB1dCIsIlByb21RdWVyeUJ1aWxkZXIiLCJOZXN0ZWRRdWVyeSIsIm5lc3RlZFF1ZXJ5Iiwib25SZW1vdmUiLCJjYXJkIiwiaGVhZGVyIiwib3BlcmF0b3JzIiwidmVjdG9yTWF0Y2hXcmFwcGVyIiwidmVjdG9yTWF0Y2hlc1R5cGUiLCJ2ZWN0b3JNYXRjaElucHV0IiwidmVjdG9yTWF0Y2hlcyIsImV2dCIsImJvZHkiLCJ1cGRhdGUiLCJmbGV4RGlyZWN0aW9uIiwiZ2FwIiwicGFkZGluZyIsImFsaWduSXRlbXMiLCJ3aGl0ZVNwYWNlIiwicGFkZGluZ0xlZnQiLCJtYXJnaW5MZWZ0IiwiU3RhY2siLCJOZXN0ZWRRdWVyeUxpc3QiLCJuZXN0ZWRRdWVyaWVzIiwiYmluYXJ5UXVlcmllcyIsIm9uTmVzdGVkUXVlcnlVcGRhdGUiLCJ1cGRhdGVkTGlzdCIsIkVkaXRvclJvdyIsIkxhYmVsRmlsdGVycyIsIk9wZXJhdGlvbkxpc3QiLCJPcGVyYXRpb25zRWRpdG9yUm93IiwiUHJvbVF1ZXJ5QnVpbGRlckhpbnRzIiwib25DaGFuZ2VMYWJlbHMiLCJ3aXRoVGVtcGxhdGVWYXJpYWJsZU9wdGlvbnMiLCJvcHRpb25zUHJvbWlzZSIsIm9uR2V0TGFiZWxOYW1lcyIsImZvckxhYmVsIiwibGFiZWxzVG9Db25zaWRlciIsImxhYmVsc0luZGV4IiwibGFiZWxOYW1lIiwib25HZXRMYWJlbFZhbHVlcyIsImZvckxhYmVsSW50ZXJwb2xhdGVkIiwiZ2V0TWV0cmljcyIsImNyZWF0ZVNsaWNlIiwiUXVlcnlQcmV2aWV3IiwiUHJvbVF1ZXJ5QnVpbGRlckNvbnRhaW5lciIsImRpc3BhdGNoIiwic3RhdGVTbGljZSIsInJlZHVjZXIiLCJleHByQ2hhbmdlZCIsIm9uVmlzUXVlcnlDaGFuZ2UiLCJ2aXN1YWxRdWVyeUNoYW5nZSIsInJhd1F1ZXJ5IiwiaW5pdGlhbFN0YXRlIiwicmVkdWNlcnMiLCJwYXlsb2FkIiwicGFyc2VSZXN1bHQiLCJhY3Rpb25zIiwiT3BlcmF0aW9uRXhwbGFpbmVkQm94IiwiT3BlcmF0aW9uTGlzdEV4cGxhaW5lZCIsIlByb21RdWVyeUJ1aWxkZXJFeHBsYWluZWQiLCJuZXN0ZWQiLCJzZXRIaW50cyIsImNvbnRhaW5lciIsIm5ld1Byb21RdWVyeSIsInZpc3VhbFF1ZXJ5IiwiRWRpdG9yU3dpdGNoIiwiUXVlcnlPcHRpb25Hcm91cCIsImdldExlZ2VuZE1vZGVMYWJlbCIsIlByb21RdWVyeUxlZ2VuZEVkaXRvciIsIlByb21RdWVyeUJ1aWxkZXJPcHRpb25zIiwib25DaGFuZ2VGb3JtYXQiLCJvbkNoYW5nZVN0ZXAiLCJxdWVyeVR5cGVPcHRpb25zIiwicXVlcnlUeXBlVmFsdWUiLCJnZXRRdWVyeVR5cGVWYWx1ZSIsInF1ZXJ5VHlwZUxhYmVsIiwiZ2V0Q29sbGFwc2VkSW5mbyIsInNob3VsZFNob3dFeGVtcGxhclN3aXRjaCIsIlByb21RdWVyeUNvZGVFZGl0b3IiLCJFZGl0b3JIZWFkZXIiLCJJbmxpbmVTZWxlY3QiLCJTcGFjZSIsInJlcG9ydEludGVyYWN0aW9uIiwiQ29uZmlybU1vZGFsIiwiRmVlZGJhY2tMaW5rIiwiUXVlcnlFZGl0b3JNb2RlVG9nZ2xlIiwiUXVlcnlIZWFkZXJTd2l0Y2giLCJRdWVyeUVkaXRvck1vZGUiLCJjaGFuZ2VFZGl0b3JNb2RlIiwiZ2V0UXVlcnlXaXRoRGVmYXVsdHMiLCJwYXJzZU1vZGFsT3BlbiIsInNldFBhcnNlTW9kYWxPcGVuIiwiZGF0YUlzU3RhbGUiLCJzZXREYXRhSXNTdGFsZSIsImVkaXRvck1vZGUiLCJvbkVkaXRvck1vZGVDaGFuZ2UiLCJuZXdNZXRyaWNFZGl0b3JNb2RlIiwibmV3RWRpdG9yIiwicHJldmlvdXNFZGl0b3IiLCJCdWlsZGVyIiwiZXJyb3JzIiwib25RdWVyeVByZXZpZXdDaGFuZ2UiLCJvbkNoYW5nZUludGVybmFsIiwiQ29kZSIsIkV4cGxhaW4iLCJMZWdlbmRGb3JtYXRNb2RlIiwibGVnZW5kTW9kZU9wdGlvbnMiLCJBdXRvIiwiVmVyYm9zZSIsIkN1c3RvbSIsIm1vZGUiLCJnZXRMZWdlbmRNb2RlIiwiaW5wdXRSZWYiLCJvbkxlZ2VuZEZvcm1hdENoYW5nZWQiLCJuZXdGb3JtYXQiLCJvbkxlZ2VuZE1vZGVDaGFuZ2VkIiwic2V0VGltZW91dCIsImZvY3VzIiwic2V0U2VsZWN0aW9uUmFuZ2UiLCJ1c2VUaGVtZTIiLCJoaWdobGlnaHRlZCIsImVkaXRvckZpZWxkIiwiX19odG1sIiwiZm9udEZhbWlseU1vbm9zcGFjZSIsImZvbnRTaXplIiwiYm9keVNtYWxsIiwiZnVuY3Rpb25SZW5kZXJlckxlZnQiLCJmdW5jdGlvblJlbmRlcmVyUmlnaHQiLCJyYW5nZVJlbmRlcmVyTGVmdFdpdGhQYXJhbXMiLCJyYW5nZVJlbmRlcmVyUmlnaHRXaXRoUGFyYW1zIiwiSGlzdG9ncmFtUXVhbnRpbGUiLCJMYWJlbFJlcGxhY2UiLCJMbiIsImNyZWF0ZVJhbmdlRnVuY3Rpb24iLCJDaGFuZ2VzIiwiUmF0ZSIsIklyYXRlIiwiSW5jcmVhc2UiLCJJZGVsdGEiLCJEZWx0YSIsImNyZWF0ZUZ1bmN0aW9uIiwiSG9sdFdpbnRlcnMiLCJjaGFuZ2VUeXBlSGFuZGxlciIsIm9wZXJhdGlvblR5cGVDaGFuZ2VkSGFuZGxlckZvclJhbmdlRnVuY3Rpb24iLCJQcmVkaWN0TGluZWFyIiwiUXVhbnRpbGVPdmVyVGltZSIsImFkZE5lc3RlZFF1ZXJ5SGFuZGxlciIsIkFic2VudCIsIkFjb3MiLCJBY29zaCIsIkFzaW4iLCJBc2luaCIsIkF0YW4iLCJBdGFuaCIsIkNlaWwiLCJDbGFtcCIsIkNsYW1wTWF4IiwiQ2xhbXBNaW4iLCJDb3MiLCJDb3NoIiwiRGF5T2ZNb250aCIsIkRheU9mV2VlayIsIkRheXNJbk1vbnRoIiwiRGVnIiwiRGVyaXYiLCJFeHAiLCJGbG9vciIsIkdyb3VwIiwiSG91ciIsIkxhYmVsSm9pbiIsInJlc3RQYXJhbSIsIm9wdGlvbmFsIiwibGFiZWxKb2luUmVuZGVyZXIiLCJsYWJlbEpvaW5BZGRPcGVyYXRpb25IYW5kbGVyIiwiTG9nMTAiLCJMb2cyIiwiTWludXRlIiwiTW9udGgiLCJQaSIsIlF1YW50aWxlIiwiUmFkIiwiUmVzZXRzIiwiUm91bmQiLCJTY2FsYXIiLCJTZ24iLCJTaW4iLCJTaW5oIiwiU29ydCIsIlNvcnREZXNjIiwiU3FydCIsIlN0ZGRldiIsIlRhbiIsIlRhbmgiLCJUaW1lc3RhbXAiLCJWZWN0b3IiLCJZZWFyIiwiZGVmaW5pdGlvbiIsIndpdGhSYXRlSW50ZXJ2YWwiLCJvcGVyYXRpb24iLCJuZXdEZWYiLCJuZXdPcGVyYXRpb24iLCJmaXJzdE9wIiwiZ2V0T3BlcmF0aW9uRGVmIiwic2VwYXJhdG9yIiwiRXJyb3JOYW1lIiwiZ2V0QWxsQnlUeXBlIiwiZ2V0TGVmdE1vc3RDaGlsZCIsImdldFN0cmluZyIsIm1ha2VCaW5PcCIsIm1ha2VFcnJvciIsInJlcGxhY2VWYXJpYWJsZXMiLCJyZXBsYWNlZEV4cHIiLCJ0b3BOb2RlIiwiaGFuZGxlRXhwcmVzc2lvbiIsImlzRW1wdHlRdWVyeSIsImdldExhYmVsIiwiZ2V0Q2hpbGQiLCJoYW5kbGVGdW5jdGlvbiIsImhhbmRsZUFnZ3JlZ2F0aW9uIiwiaGFuZGxlQmluYXJ5IiwiaXNJbnRlcnZhbFZhcmlhYmxlRXJyb3IiLCJjaGlsZCIsImZpcnN0Q2hpbGQiLCJuZXh0U2libGluZyIsInByZXZTaWJsaW5nIiwicmFuZ2VGdW5jdGlvbnMiLCJuYW1lTm9kZSIsImZ1bmNOYW1lIiwiY2FsbEFyZ3MiLCJlbmRzV2l0aCIsInVuc2hpZnQiLCJ1cGRhdGVGdW5jdGlvbkFyZ3MiLCJtb2RpZmllciIsImJ5TW9kaWZpZXIiLCJ3aXRob3V0TW9kaWZpZXIiLCJsZWZ0IiwiYmluTW9kaWZpZXIiLCJnZXRCaW5hcnlNb2RpZmllciIsInJpZ2h0IiwibGFzdENoaWxkIiwibGVmdE51bWJlciIsInJpZ2h0TnVtYmVyIiwicmlnaHRCaW5hcnkiLCJpc0Jvb2wiLCJsZWZ0TW9zdENoaWxkIiwiYmluUXVlcnkiLCJpc01hdGNoZXIiLCJtYXRjaFR5cGUiLCJtYXRjaGVzIiwibWF0Y2hlciIsIm1lYXN1cmVUZXh0IiwiZm9yd2FyZFJlZiIsInJlZiIsIm1pbldpZHRoIiwibWF4V2lkdGgiLCJvbkNvbW1pdENoYW5nZSIsIm9uS2V5RG93biIsInJlc3RQcm9wcyIsInNldFZhbHVlIiwiaW5wdXRXaWR0aCIsInNldElucHV0V2lkdGgiLCJnZXRXaWR0aEZvciIsImV4dHJhU3BhY2UiLCJyZWFsV2lkdGgiLCJmZWVkYmFja1VybCIsImZlZWRiYWNrTGlua3NFbmFibGVkIiwibGluayIsImNvbG9yIiwic2Vjb25kYXJ5IiwiQWNjZXNzb3J5QnV0dG9uIiwiSW5wdXRHcm91cCIsIkxhYmVsRmlsdGVySXRlbSIsImRlZmF1bHRPcCIsImlzTXVsdGlTZWxlY3QiLCJnZXRTZWxlY3RPcHRpb25zRnJvbVN0cmluZyIsImdldE9wdGlvbnMiLCJsYWJlbFZhbHVlcyIsImlzTG9hZGluZ0xhYmVsTmFtZXMiLCJsYWJlbE5hbWVzIiwiY2hhbmdlIiwiaXNMb2FkaW5nTGFiZWxWYWx1ZXMiLCJjaGFuZ2VzIiwiRWRpdG9yTGlzdCIsImxhYmVsc0ZpbHRlcnMiLCJzZXRJdGVtcyIsIm9uTGFiZWxzQ2hhbmdlIiwib25DaGFuZ2VJdGVtIiwiUmVnaXN0cnkiLCJnZXRPcGVyYXRpb25zIiwib3BlcmF0aW9uc1JlZ2lzdHkiLCJjYXRlZ29yaWVzIiwiZ2V0T3BlcmF0aW9uc0ZvckNhdGVnb3J5IiwiaGlkZUZyb21MaXN0IiwiZ2V0QWx0ZXJuYXRpdmVPcGVyYXRpb25zIiwiZ2V0Q2F0ZWdvcmllcyIsImdldElmRXhpc3RzIiwicmVuZGVyT3BlcmF0aW9ucyIsInF1ZXJ5U3RyaW5nIiwicmVuZGVyQmluYXJ5UXVlcmllcyIsInJlbmRlckJpbmFyeVF1ZXJ5IiwibGVmdE9wZXJhbmQiLCJiaW5hcnlRdWVyeSIsImhhc0JpbmFyeU9wIiwiRHJhZ2dhYmxlIiwiT3BlcmF0aW9uSGVhZGVyIiwiZ2V0T3BlcmF0aW9uUGFyYW1FZGl0b3IiLCJPcGVyYXRpb25FZGl0b3IiLCJxdWVyeU1vZGVsbGVyIiwic2hvdWxkSGlnaGxpZ2h0IiwidXNlSGlnaGxpZ2h0Iiwib25QYXJhbVZhbHVlQ2hhbmdlZCIsInBhcmFtSWR4IiwiY2FsbFBhcmFtQ2hhbmdlZFRoZW5PbkNoYW5nZSIsIm9uQWRkUmVzdFBhcmFtIiwib25SZW1vdmVSZXN0UGFyYW0iLCJvcGVyYXRpb25FbGVtZW50cyIsInBhcmFtSW5kZXgiLCJwYXJhbURlZiIsIkVkaXRvciIsInBhcmFtUm93IiwiaGlkZU5hbWUiLCJwYXJhbU5hbWUiLCJpbmZvSWNvbiIsInBhcmFtVmFsdWUiLCJsYXN0UGFyYW1EZWYiLCJyZW5kZXJBZGRSZXN0UGFyYW1CdXR0b24iLCJwcm92aWRlZCIsImNhcmRIaWdobGlnaHQiLCJpbm5lclJlZiIsImRyYWdnYWJsZVByb3BzIiwiZHJhZ0hhbmRsZVByb3BzIiwiYXJyb3ciLCJhcnJvd0xpbmUiLCJhcnJvd0Fycm93Iiwia2VlcEhpZ2hsaWdodCIsInNldEtlZXBIaWdobGlnaHQiLCJjbGVhclRpbWVvdXQiLCJwYXJhbUNoYW5nZWRIYW5kbGVyIiwiYmFja2dyb3VuZCIsImJvcmRlciIsIm1lZGl1bSIsImN1cnNvciIsImJvcmRlclJhZGl1cyIsInNoYXBlIiwibWFyZ2luQm90dG9tIiwicG9zaXRpb24iLCJ0cmFuc2l0aW9uIiwiYm94U2hhZG93IiwibWFyZ2luIiwiZm9udFdlaWdodCIsImZvbnRXZWlnaHRNZWRpdW0iLCJ0b3AiLCJiYWNrZ3JvdW5kQ29sb3IiLCJzdHJvbmciLCJib3JkZXJUb3AiLCJib3JkZXJCb3R0b20iLCJib3JkZXJMZWZ0IiwicmVuZGVyTWFya2Rvd24iLCJzdGVwTnVtYmVyIiwibWFya2Rvd24iLCJjaGlsZHJlbiIsImJveCIsImJveElubmVyIiwianVzdGlmeUNvbnRlbnQiLCJwYWRkaW5nQm90dG9tIiwiYSIsInRleHREZWNvcmF0aW9uIiwiT3BlcmF0aW9uSW5mb0J1dHRvbiIsIm9uVG9nZ2xlU3dpdGNoZXIiLCJpc09wZW4iLCJhbHRlcm5hdGl2ZXMiLCJhbHQiLCJvcGVyYXRpb25IZWFkZXJCdXR0b25zIiwic2VsZWN0V3JhcHBlciIsImNoYW5nZWRPcCIsIm9wYWNpdHkiLCJ0cmFuc2l0aW9ucyIsImNyZWF0ZSIsImR1cmF0aW9uIiwic2hvcnQiLCJwYWRkaW5nUmlnaHQiLCJ1c2VQb3BwZXJUb29sdGlwIiwiUG9ydGFsIiwic2hvdyIsInNldFNob3ciLCJnZXRUb29sdGlwUHJvcHMiLCJzZXRUb29sdGlwUmVmIiwic2V0VHJpZ2dlclJlZiIsInZpc2libGUiLCJwbGFjZW1lbnQiLCJvblZpc2libGVDaGFuZ2UiLCJpbnRlcmFjdGl2ZSIsInRyaWdnZXIiLCJkb2NCb3giLCJkb2NCb3hIZWFkZXIiLCJkb2NCb3hCb2R5IiwiZ2V0T3BlcmF0aW9uRG9jcyIsIm92ZXJmbG93Iiwic2hhZG93cyIsInozIiwiekluZGV4IiwidG9vbHRpcCIsImg1Iiwic2lnbmF0dXJlIiwiZHJvcGRvd24iLCJleHBsYWluSGFuZGxlciIsIkRyYWdEcm9wQ29udGV4dCIsIkRyb3BwYWJsZSIsInVzZU1vdW50ZWRTdGF0ZSIsIkNhc2NhZGVyIiwib3BzVG9IaWdobGlnaHQiLCJ1c2VPcGVyYXRpb25zSGlnaGxpZ2h0IiwiY2FzY2FkZXJPcGVuIiwic2V0Q2FzY2FkZXJPcGVuIiwib25PcGVyYXRpb25DaGFuZ2UiLCJhZGRPcHRpb25zIiwiaXNMZWFmIiwib25BZGRPcGVyYXRpb24iLCJvcGVyYXRpb25EZWYiLCJvbkRyYWdFbmQiLCJkZXN0aW5hdGlvbiIsImVsZW1lbnQiLCJzb3VyY2UiLCJvbkNhc2NhZGVyQmx1ciIsIm9wZXJhdGlvbkxpc3QiLCJkcm9wcGFibGVQcm9wcyIsInBsYWNlaG9sZGVyIiwiYWRkQnV0dG9uIiwiaXNNb3VudGVkIiwicHJldk9wZXJhdGlvbnMiLCJuZXdPcHMiLCJldmVyeSIsIm5ld09wIiwiaXNTYW1lT3AiLCJvcDEiLCJvcDIiLCJoZWFkaW5nIiwiZmxleFdyYXAiLCJDaGVja2JveCIsIlNlbGVjdElucHV0UGFyYW1FZGl0b3IiLCJCb29sSW5wdXRQYXJhbUVkaXRvciIsIlNpbXBsZUlucHV0UGFyYW1FZGl0b3IiLCJzZWxlY3RPcHRpb25zIiwidmFsdWVPcHRpb24iLCJyb290IiwiVGFnIiwiZWRpdG9yTW9kZXMiLCJjb21wb25lbnQiLCJ1bmlxdWVJZCIsImlucHV0UHJvcHMiLCJkYXNoZWRMYWJlbCIsInN3aXRjaElkUmVmIiwic3dpdGNoTGFiZWwiLCJ1c2VUb2dnbGUiLCJjb2xsYXBzZWRJbmZvIiwidG9nZ2xlT3BlbiIsInRvZ2dsZSIsImVtcGhhc2l6ZSIsImZsZXhHcm93IiwicGFkZGluZ1RvcCIsIm1hcmdpblJpZ2h0IiwiY2FwaXRhbGl6ZSIsInBsdXJhbGl6ZSIsInJlbmRlclBhcmFtcyIsInN0ciIsInJhbmdlUmVuZGVyZXJXaXRoUGFyYW1zIiwicmVuZGVyTGVmdCIsImdldE9uTGFiZWxBZGRlZEhhbmRsZXIiLCJnZXRBZ2dyZWdhdGlvbkV4cGxhaW5lciIsImdldEFnZ3JlZ2F0aW9uQnlSZW5kZXJlciIsImdldExhc3RMYWJlbFJlbW92ZWRIYW5kbGVyIiwiZ2V0QWdncmVnYXRpb25XaXRob3V0UmVuZGVyZXIiLCJwYXJhbXNEZWYiLCJnZXRBZ2dyZWdhdGlvbkJ5UmVuZGVyZXJXaXRoUGFyYW1ldGVyIiwiYWdncmVnYXRpb24iLCJhZ2dyZWdhdGlvblJlbmRlcmVyIiwiYWdncmVnYXRpb25OYW1lIiwiYWdncmVnYXRpb25FeHBsYWluZXIiLCJsYWJlbFdvcmQiLCJtYXBUeXBlIiwicCIsInJlc3RQYXJhbXMiLCJjaGFuZ2VUb09wZXJhdGlvbklkIiwib25QYXJhbUNoYW5nZWQiLCJwYXJlbnRUeXBlIiwicGFyZW50IiwidmFyaWFibGVSZWdleCIsInZhcjEiLCJ2YXIyIiwiZm10MiIsInZhcjMiLCJmaWVsZFBhdGgiLCJmbXQzIiwiZm10IiwidmFyVHlwZSIsInZhclR5cGVGdW5jIiwicmV0dXJuVmFyaWFibGVzIiwibnVtYmVyTm9kZSIsImhhc0Jvb2wiLCJwb3MiLCJjaGlsZEFmdGVyIiwianNvbiIsInRvSnNvbiIsImpzb25Ub1RleHQiLCJ0cmVlSnNvbiIsIm5vZGVUb1N0cmluZyIsImluZGVudCIsIm5ld0luZGVudCIsImlzTGFzdENoaWxkIiwic3RvcmUiLCJxdWVyeUVkaXRvck1vZGVEZWZhdWx0TG9jYWxTdG9yYWdlS2V5IiwiZ2V0RGVmYXVsdEVkaXRvck1vZGUiLCJkZXNjZW5kaW5nIiwiZGV2aWF0aW9uIiwicGFydGl0aW9uIiwiZ3JvdXBCeSIsIkFycmF5RGF0YUZyYW1lIiwiQXJyYXlWZWN0b3IiLCJEYXRhVG9waWMiLCJGaWVsZFR5cGUiLCJmb3JtYXRMYWJlbHMiLCJnZXREaXNwbGF5UHJvY2Vzc29yIiwiVElNRV9TRVJJRVNfVElNRV9GSUVMRF9OQU1FIiwiVElNRV9TRVJJRVNfVkFMVUVfRklFTERfTkFNRSIsIkRhdGFGcmFtZVR5cGUiLCJnZXREYXRhU291cmNlU3J2IiwiaXNFeGVtcGxhckRhdGEiLCJpc01hdHJpeERhdGEiLCJJTkZJTklUWV9TQU1QTEVfUkVHRVgiLCJpc1RhYmxlUmVzdWx0IiwiZGF0YUZyYW1lIiwiY3VzdG9tIiwicmVzdWx0VHlwZSIsImlzSGVhdG1hcFJlc3VsdCIsInRhYmxlRnJhbWVzIiwiZnJhbWVzV2l0aG91dFRhYmxlIiwiZGYiLCJwcm9jZXNzZWRUYWJsZUZyYW1lcyIsInRyYW5zZm9ybURGVG9UYWJsZSIsImV4ZW1wbGFyRnJhbWVzIiwiZnJhbWVzV2l0aG91dFRhYmxlQW5kRXhlbXBsYXJzIiwiZGVzdGluYXRpb25zIiwicHJvY2Vzc2VkRXhlbXBsYXJGcmFtZXMiLCJleGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbiIsInRyYWNlSURGaWVsZCIsImZpZWxkIiwibGlua3MiLCJnZXREYXRhTGlua3MiLCJkYXRhVG9waWMiLCJBbm5vdGF0aW9ucyIsImhlYXRtYXBSZXN1bHRzIiwiZnJhbWVzV2l0aG91dFRhYmxlSGVhdG1hcHNBbmRFeGVtcGxhcnMiLCJwcm9jZXNzZWRIZWF0bWFwRnJhbWVzIiwibWVyZ2VIZWF0bWFwRnJhbWVzIiwidHJhbnNmb3JtVG9IaXN0b2dyYW1PdmVyVGltZSIsInNvcnRTZXJpZXNCeUxhYmVsIiwib3RoZXJGcmFtZXMiLCJwcmVmZXJyZWRWaXN1YWxpc2F0aW9uVHlwZSIsImRmcyIsImRhdGFGcmFtZXNCeVJlZklkIiwicmVmSWRzIiwidmFsdWVUZXh0IiwiZ2V0VmFsdWVUZXh0IiwiZ2V0VmFsdWVGaWVsZCIsInZhbHVlTmFtZSIsImdldFRpbWVGaWVsZCIsImxhYmVsRmllbGRzIiwiZnJhbWVWYWx1ZUZpZWxkIiwicHJvbUxhYmVscyIsIm51bWJlckZpZWxkIiwiZmlsdGVyYWJsZSIsInBhcnNlU2FtcGxlVmFsdWUiLCJsYWJlbHNGb3JGaWVsZCIsImdldExhYmVsVmFsdWUiLCJyZXNwb25zZUxlbmd0aCIsInRyYW5zZm9ybU9wdGlvbnMiLCJwcm9tZXRoZXVzUmVzdWx0IiwiZXZlbnRzIiwiZXhlbXBsYXJEYXRhIiwiZXhlbXBsYXJzIiwic2FtcGxlZEV4ZW1wbGFycyIsInNhbXBsZUV4ZW1wbGFycyIsInRhYmxlRGF0YSIsInRyYW5zZm9ybU1ldHJpY0RhdGFUb1RhYmxlIiwidHJhbnNmb3JtVG9EYXRhRnJhbWUiLCJkYXRhTGlua3MiLCJkYXRhU291cmNlU3J2IiwiZHNTZXR0aW5ncyIsImdldEluc3RhbmNlU2V0dGluZ3MiLCJpbnRlcm5hbCIsImRhdGFzb3VyY2VOYW1lIiwidGFyZ2V0QmxhbmsiLCJidWNrZXRlZEV4ZW1wbGFycyIsImFsaWduZWRUcyIsIlN0cmluZyIsInN0YW5kYXJkRGV2aWF0aW9uIiwic2FtcGxlZEJ1Y2tldHMiLCJleGVtcGxhcnNJbkJ1Y2tldCIsImJ1Y2tldFZhbHVlcyIsImV4Iiwic2FtcGxlZEJ1Y2tldFZhbHVlcyIsImN1cnIiLCJjcmVhdGVMYWJlbEluZm8iLCJzdGVwTXMiLCJOYU4iLCJiYXNlVGltZXN0YW1wIiwiZHBzIiwiZHBWYWx1ZSIsImlzTmFOIiwiZW5kVGltZXN0YW1wIiwicGFyc2VWYWx1ZSIsImRpc3BsYXlOYW1lRnJvbURTIiwibWV0cmljRmllbGRzIiwiZCIsIm1ldHJpY0ZpZWxkIiwiaXNNcyIsImxhYmVsc1dpdGhvdXROYW1lIiwibGFiZWxQYXJ0IiwiY291bnRGaWVsZHMiLCJIZWF0bWFwQnVja2V0cyIsInNlcmllc0xpc3QiLCJ0b3BTZXJpZXMiLCJib3R0b21TZXJpZXMiLCJqIiwiYm90dG9tUG9pbnQiLCJzMSIsInMyIiwibGUxIiwibGUyIiwiTnVtYmVyIiwiTkVHQVRJVkVfSU5GSU5JVFkiLCJQT1NJVElWRV9JTkZJTklUWSIsIlN0YW5kYXJkVmFyaWFibGVTdXBwb3J0IiwiYmluZCIsIm1ldHJpY0ZpbmRTdHJlYW0iLCJ0b0RhdGFRdWVyeSJdLCJzb3VyY2VSb290IjoiIn0=