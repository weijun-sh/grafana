(self["webpackChunkgrafana"] = self["webpackChunkgrafana"] || []).push([["lokiPlugin"],{

/***/ "./public/app/plugins/datasource/loki/LokiAnnotationsQueryCtrl.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiAnnotationsQueryCtrl": () => (/* binding */ LokiAnnotationsQueryCtrl)
/* harmony export */ });
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Just a simple wrapper for a react component that is actually implementing the query editor.
 */
class LokiAnnotationsQueryCtrl {
  /** @ngInject */
  constructor($scope) {
    this.annotation = $scope.ctrl.annotation;
    this.annotation.target = this.annotation.target || {};
    this.onQueryChange = this.onQueryChange.bind(this);
  }

  onQueryChange(query) {
    this.annotation.expr = query.expr;
    this.annotation.maxLines = query.maxLines;
    this.annotation.instant = query.instant;
  }

}
LokiAnnotationsQueryCtrl.$inject = ["$scope"];

_defineProperty(LokiAnnotationsQueryCtrl, "templateUrl", 'partials/annotations.editor.html');

/***/ }),

/***/ "./public/app/plugins/datasource/loki/add_label_to_query.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addLabelToQuery": () => (/* binding */ addLabelToQuery),
/* harmony export */   "addLabelToSelector": () => (/* binding */ addLabelToSelector),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var app_plugins_datasource_prometheus_promql__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/promql.ts");
/* harmony import */ var _syntax__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/loki/syntax.ts");



const builtInWords = [...app_plugins_datasource_prometheus_promql__WEBPACK_IMPORTED_MODULE_1__.PROM_KEYWORDS, ...app_plugins_datasource_prometheus_promql__WEBPACK_IMPORTED_MODULE_1__.OPERATORS, ...app_plugins_datasource_prometheus_promql__WEBPACK_IMPORTED_MODULE_1__.LOGICAL_OPERATORS, ..._syntax__WEBPACK_IMPORTED_MODULE_2__.LOKI_KEYWORDS]; // We want to extract all possible metrics and also keywords

const metricsAndKeywordsRegexp = /([A-Za-z:][\w:]*)\b(?![\]{=!",])/g;
function addLabelToQuery(query, key, value, operator, hasNoMetrics) {
  if (!key || !value) {
    throw new Error('Need label to add to query.');
  } // We need to make sure that we convert the value back to string because it may be a number


  const transformedValue = value === Infinity ? '+Inf' : value.toString(); // Add empty selectors to bare metric names

  let previousWord;
  query = query.replace(metricsAndKeywordsRegexp, (match, word, offset) => {
    const isMetric = isWordMetric(query, word, offset, previousWord, hasNoMetrics);
    previousWord = word;
    return isMetric ? `${word}{}` : word;
  }); //This is a RegExp for stream selector - e.g. {job="grafana"}

  const selectorRegexp = /(\$)?{([^{]*)}/g;
  const parts = [];
  let lastIndex = 0;
  let suffix = '';
  let match = selectorRegexp.exec(query);
  /* 
    There are 2 possible false positive scenarios: 
    
    1. We match Grafana's variables with ${ syntax - such as${__rate_s}. To filter these out we could use negative lookbehind,
    but Safari browser currently doesn't support it. Therefore we need to hack this by creating 2 matching groups. 
    (\$) is for the Grafana's variables and if we match it, we know this is not a stream selector and we don't want to add label.
     2. Log queries can include {{.label}} syntax when line_format is used. We need to filter these out by checking
    if match starts with "{."
  */

  while (match) {
    const prefix = query.slice(lastIndex, match.index);
    lastIndex = match.index + match[2].length + 2;
    suffix = query.slice(match.index + match[0].length); // Filtering our false positives

    if (match[0].startsWith('{.') || match[1]) {
      parts.push(prefix);
      parts.push(match[0]);
    } else {
      // If we didn't match first group, we are inside selector and we want to add labels
      const selector = match[2];
      const selectorWithLabel = addLabelToSelector(selector, key, transformedValue, operator);
      parts.push(prefix, selectorWithLabel);
    }

    match = selectorRegexp.exec(query);
  }

  parts.push(suffix);
  return parts.join('');
}
const labelRegexp = /(\w+)\s*(=|!=|=~|!~)\s*("[^"]*")/g;
function addLabelToSelector(selector, labelKey, labelValue, labelOperator) {
  const parsedLabels = []; // Split selector into labels

  if (selector) {
    let match = labelRegexp.exec(selector);

    while (match) {
      parsedLabels.push({
        key: match[1],
        operator: match[2],
        value: match[3]
      });
      match = labelRegexp.exec(selector);
    }
  } // Add new label


  const operatorForLabelKey = labelOperator || '=';
  parsedLabels.push({
    key: labelKey,
    operator: operatorForLabelKey,
    value: `"${labelValue}"`
  }); // Sort labels by key and put them together

  const formatted = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.chain)(parsedLabels).uniqWith(lodash__WEBPACK_IMPORTED_MODULE_0__.isEqual).compact().sortBy('key').map(({
    key,
    operator,
    value
  }) => `${key}${operator}${value}`).value().join(',');
  return `{${formatted}}`;
}

function isPositionInsideChars(text, position, openChar, closeChar) {
  const nextSelectorStart = text.slice(position).indexOf(openChar);
  const nextSelectorEnd = text.slice(position).indexOf(closeChar);
  return nextSelectorEnd > -1 && (nextSelectorStart === -1 || nextSelectorStart > nextSelectorEnd);
}

function isWordMetric(query, word, offset, previousWord, hasNoMetrics) {
  const insideSelector = isPositionInsideChars(query, offset, '{', '}'); // Handle "sum by (key) (metric)"

  const previousWordIsKeyWord = previousWord && app_plugins_datasource_prometheus_promql__WEBPACK_IMPORTED_MODULE_1__.OPERATORS.indexOf(previousWord) > -1; // Check for colon as as "word boundary" symbol

  const isColonBounded = word.endsWith(':'); // Check for words that start with " which means that they are not metrics

  const startsWithQuote = query[offset - 1] === '"'; // Check for template variables

  const isTemplateVariable = query[offset - 1] === '$'; // Check for time units

  const isTimeUnit = ['s', 'm', 'h', 'd', 'w'].includes(word) && Boolean(Number(query[offset - 1]));

  if (!hasNoMetrics && !insideSelector && !isColonBounded && !previousWordIsKeyWord && !startsWithQuote && !isTemplateVariable && !isTimeUnit && builtInWords.indexOf(word) === -1) {
    return true;
  }

  return false;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (addLabelToQuery);

/***/ }),

/***/ "./public/app/plugins/datasource/loki/backendResultTransformer.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "transformBackendResult": () => (/* binding */ transformBackendResult)
/* harmony export */ });
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _getDerivedFields__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/loki/getDerivedFields.ts");
/* harmony import */ var _makeTableFrames__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/loki/makeTableFrames.ts");
/* harmony import */ var _query_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/loki/query_utils.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/loki/types.ts");
const _excluded = ["meta"],
      _excluded2 = ["data"];

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







function isMetricFrame(frame) {
  return frame.fields.every(field => field.type === _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.time || field.type === _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.number);
} // returns a new frame, with meta merged with it's original meta


function setFrameMeta(frame, meta) {
  const {
    meta: oldMeta
  } = frame,
        rest = _objectWithoutPropertiesLoose(frame, _excluded); // meta maybe be undefined, we need to handle that


  const newMeta = Object.assign({}, oldMeta, meta);
  return Object.assign({}, rest, {
    meta: newMeta
  });
}

function processStreamFrame(frame, query, derivedFieldConfigs) {
  const meta = {
    preferredVisualisationType: 'logs',
    limit: query === null || query === void 0 ? void 0 : query.maxLines,
    searchWords: query !== undefined ? (0,_query_utils__WEBPACK_IMPORTED_MODULE_3__.getHighlighterExpressionsFromQuery)((0,_query_utils__WEBPACK_IMPORTED_MODULE_3__.formatQuery)(query.expr)) : undefined,
    custom: {
      // used by logs_model
      lokiQueryStatKey: 'Summary: total bytes processed'
    }
  };
  const newFrame = setFrameMeta(frame, meta);
  const derivedFields = (0,_getDerivedFields__WEBPACK_IMPORTED_MODULE_1__.getDerivedFields)(newFrame, derivedFieldConfigs);
  return Object.assign({}, newFrame, {
    fields: [...newFrame.fields, ...derivedFields]
  });
}

function processStreamsFrames(frames, queryMap, derivedFieldConfigs) {
  return frames.map(frame => {
    const query = frame.refId !== undefined ? queryMap.get(frame.refId) : undefined;
    return processStreamFrame(frame, query, derivedFieldConfigs);
  });
}

function processMetricInstantFrames(frames) {
  return frames.length > 0 ? (0,_makeTableFrames__WEBPACK_IMPORTED_MODULE_2__.makeTableFrames)(frames) : [];
}

function processMetricRangeFrames(frames) {
  const meta = {
    preferredVisualisationType: 'graph'
  };
  return frames.map(frame => setFrameMeta(frame, meta));
} // we split the frames into 3 groups, because we will handle
// each group slightly differently


function groupFrames(frames, queryMap) {
  const streamsFrames = [];
  const metricInstantFrames = [];
  const metricRangeFrames = [];
  frames.forEach(frame => {
    if (!isMetricFrame(frame)) {
      streamsFrames.push(frame);
    } else {
      var _queryMap$get;

      const isInstantFrame = frame.refId != null && ((_queryMap$get = queryMap.get(frame.refId)) === null || _queryMap$get === void 0 ? void 0 : _queryMap$get.queryType) === _types__WEBPACK_IMPORTED_MODULE_4__.LokiQueryType.Instant;

      if (isInstantFrame) {
        metricInstantFrames.push(frame);
      } else {
        metricRangeFrames.push(frame);
      }
    }
  });
  return {
    streamsFrames,
    metricInstantFrames,
    metricRangeFrames
  };
}

function transformBackendResult(response, queries, derivedFieldConfigs) {
  const {
    data
  } = response,
        rest = _objectWithoutPropertiesLoose(response, _excluded2); // in the typescript type, data is an array of basically anything.
  // we do know that they have to be dataframes, so we make a quick check,
  // this way we can be sure, and also typescript is happy.


  const dataFrames = data.map(d => {
    if (!(0,_grafana_data__WEBPACK_IMPORTED_MODULE_0__.isDataFrame)(d)) {
      throw new Error('transformation only supports dataframe responses');
    }

    return d;
  });
  const queryMap = new Map(queries.map(query => [query.refId, query]));
  const {
    streamsFrames,
    metricInstantFrames,
    metricRangeFrames
  } = groupFrames(dataFrames, queryMap);
  return Object.assign({}, rest, {
    data: [...processMetricRangeFrames(metricRangeFrames), ...processMetricInstantFrames(metricInstantFrames), ...processStreamsFrames(streamsFrames, queryMap, derivedFieldConfigs)]
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/components/LokiCheatSheet.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LokiCheatSheet)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _h, _div, _div2, _div3, _div4, _div5, _div6, _div7, _div8;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





const DEFAULT_EXAMPLES = ['{job="default/prometheus"}'];
const PREFERRED_LABELS = ['job', 'app', 'k8s_app'];
const EXAMPLES_LIMIT = 5;
const LOGQL_EXAMPLES = [{
  title: 'Log pipeline',
  expression: '{job="mysql"} |= "metrics" | logfmt | duration > 10s',
  label: 'This query targets the MySQL job, filters out logs that don’t contain the word "metrics" and parses each log line to extract more labels and filters with them.'
}, {
  title: 'Count over time',
  expression: 'count_over_time({job="mysql"}[5m])',
  label: 'This query counts all the log lines within the last five minutes for the MySQL job.'
}, {
  title: 'Rate',
  expression: 'rate(({job="mysql"} |= "error" != "timeout")[10s])',
  label: 'This query gets the per-second rate of all non-timeout errors within the last ten seconds for the MySQL job.'
}, {
  title: 'Aggregate, count, and group',
  expression: 'sum(count_over_time({job="mysql"}[5m])) by (level)',
  label: 'Get the count of logs during the last five minutes, grouping by level.'
}];
class LokiCheatSheet extends react__WEBPACK_IMPORTED_MODULE_1__.PureComponent {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "state", {
      userExamples: []
    });

    _defineProperty(this, "checkUserLabels", async () => {
      var _this$props$datasourc;

      // Set example from user labels
      const provider = (_this$props$datasourc = this.props.datasource) === null || _this$props$datasourc === void 0 ? void 0 : _this$props$datasourc.languageProvider;

      if (provider.started) {
        const labels = provider.getLabelKeys() || [];
        const preferredLabel = PREFERRED_LABELS.find(l => labels.includes(l));

        if (preferredLabel) {
          const values = await provider.getLabelValues(preferredLabel);
          const userExamples = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.shuffle)(values).slice(0, EXAMPLES_LIMIT).map(value => `{${preferredLabel}="${value}"}`);
          this.setState({
            userExamples
          });
        }
      } else {
        this.scheduleUserLabelChecking();
      }
    });
  }

  componentDidMount() {
    this.scheduleUserLabelChecking();
  }

  componentWillUnmount() {
    clearTimeout(this.userLabelTimer);
  }

  scheduleUserLabelChecking() {
    this.userLabelTimer = setTimeout(this.checkUserLabels, 1000);
  }

  renderExpression(expr) {
    const {
      onClickExample
    } = this.props;
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)("div", {
      className: "cheat-sheet-item__example",
      onClick: e => onClickExample({
        refId: 'A',
        expr
      }),
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)("code", {
        children: expr
      })
    }, expr);
  }

  render() {
    const {
      userExamples
    } = this.state;
    const hasUserExamples = userExamples.length > 0;
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)("div", {
      children: [_h || (_h = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)("h2", {
        children: "Loki Cheat Sheet"
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)("div", {
        className: "cheat-sheet-item",
        children: [_div || (_div = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)("div", {
          className: "cheat-sheet-item__title",
          children: "See your logs"
        })), _div2 || (_div2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)("div", {
          className: "cheat-sheet-item__label",
          children: "Start by selecting a log stream from the Log browser, or alternatively you can write a stream selector into the query field."
        })), hasUserExamples ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)("div", {
          children: [_div3 || (_div3 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)("div", {
            className: "cheat-sheet-item__label",
            children: "Here are some example streams from your logs:"
          })), userExamples.map(example => this.renderExpression(example))]
        }) : /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)("div", {
          children: [_div4 || (_div4 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)("div", {
            className: "cheat-sheet-item__label",
            children: "Here is an example of a log stream:"
          })), this.renderExpression(DEFAULT_EXAMPLES[0])]
        })]
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)("div", {
        className: "cheat-sheet-item",
        children: [_div5 || (_div5 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)("div", {
          className: "cheat-sheet-item__title",
          children: "Combine stream selectors"
        })), this.renderExpression('{app="cassandra",namespace="prod"}'), _div6 || (_div6 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)("div", {
          className: "cheat-sheet-item__label",
          children: "Returns all log lines from streams that have both labels."
        }))]
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)("div", {
        className: "cheat-sheet-item",
        children: [_div7 || (_div7 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)("div", {
          className: "cheat-sheet-item__title",
          children: "Filtering for search terms."
        })), this.renderExpression('{app="cassandra"} |~ "(duration|latency)s*(=|is|of)s*[d.]+"'), this.renderExpression('{app="cassandra"} |= "exact match"'), this.renderExpression('{app="cassandra"} != "do not match"'), _div8 || (_div8 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)("div", {
          className: "cheat-sheet-item__label",
          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)("a", {
            href: "https://grafana.com/docs/loki/latest/logql/#log-pipeline",
            target: "logql",
            children: "LogQL"
          }), ' ', "supports exact and regular expression filters."]
        }))]
      }), LOGQL_EXAMPLES.map(item => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)("div", {
        className: "cheat-sheet-item",
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)("div", {
          className: "cheat-sheet-item__title",
          children: item.title
        }), this.renderExpression(item.expression), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)("div", {
          className: "cheat-sheet-item__label",
          children: item.label
        })]
      }, item.expression))]
    });
  }

}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/components/LokiExploreQueryEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiExploreQueryEditor": () => (/* binding */ LokiExploreQueryEditor),
/* harmony export */   "testIds": () => (/* binding */ testIds)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _LokiOptionFields__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiOptionFields.tsx");
/* harmony import */ var _LokiQueryField__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiQueryField.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
// Libraries
 // Types




const LokiExploreQueryEditor = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(props => {
  var _query$maxLines;

  const {
    query,
    data,
    datasource,
    history,
    onChange,
    onRunQuery,
    range
  } = props;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_LokiQueryField__WEBPACK_IMPORTED_MODULE_2__.LokiQueryField, {
    datasource: datasource,
    query: query,
    onChange: onChange,
    onBlur: () => {},
    onRunQuery: onRunQuery,
    history: history,
    data: data,
    range: range,
    "data-testid": testIds.editor,
    ExtraFieldElement: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_LokiOptionFields__WEBPACK_IMPORTED_MODULE_1__.LokiOptionFields, {
      lineLimitValue: (query === null || query === void 0 ? void 0 : (_query$maxLines = query.maxLines) === null || _query$maxLines === void 0 ? void 0 : _query$maxLines.toString()) || '',
      resolution: query.resolution || 1,
      query: query,
      onRunQuery: onRunQuery,
      onChange: onChange
    })
  });
});
LokiExploreQueryEditor.displayName = 'LokiExploreQueryEditor';
const testIds = {
  editor: 'loki-editor-explore'
};

/***/ }),

/***/ "./public/app/plugins/datasource/loki/components/LokiLabelBrowser.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiLabelBrowser": () => (/* binding */ LokiLabelBrowser),
/* harmony export */   "UnthemedLokiLabelBrowser": () => (/* binding */ UnthemedLokiLabelBrowser),
/* harmony export */   "buildSelector": () => (/* binding */ buildSelector),
/* harmony export */   "facetLabels": () => (/* binding */ facetLabels)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_window__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/__virtual__/react-window-virtual-0f9a8c6a67/0/cache/react-window-npm-1.8.6-4f5a230226-54ccf2b16c.zip/node_modules/react-window/dist/index.esm.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _language_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/loki/language_utils.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _LoadingPlaceholder, _Label, _Label2, _Label3;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






 // Hard limit on labels to render



const MAX_LABEL_COUNT = 1000;
const MAX_VALUE_COUNT = 10000;
const MAX_AUTO_SELECT = 4;
const EMPTY_SELECTOR = '{}';
function buildSelector(labels) {
  const selectedLabels = [];

  for (const label of labels) {
    if (label.selected && label.values && label.values.length > 0) {
      const selectedValues = label.values.filter(value => value.selected).map(value => value.name);

      if (selectedValues.length > 1) {
        selectedLabels.push(`${label.name}=~"${selectedValues.map(_language_utils__WEBPACK_IMPORTED_MODULE_4__.escapeLabelValueInRegexSelector).join('|')}"`);
      } else if (selectedValues.length === 1) {
        selectedLabels.push(`${label.name}="${(0,_language_utils__WEBPACK_IMPORTED_MODULE_4__.escapeLabelValueInExactSelector)(selectedValues[0])}"`);
      }
    }
  }

  return ['{', selectedLabels.join(','), '}'].join('');
}
function facetLabels(labels, possibleLabels, lastFacetted) {
  return labels.map(label => {
    const possibleValues = possibleLabels[label.name];

    if (possibleValues) {
      let existingValues;

      if (label.name === lastFacetted && label.values) {
        // Facetting this label, show all values
        existingValues = label.values;
      } else {
        var _label$values;

        // Keep selection in other facets
        const selectedValues = new Set(((_label$values = label.values) === null || _label$values === void 0 ? void 0 : _label$values.filter(value => value.selected).map(value => value.name)) || []); // Values for this label have not been requested yet, let's use the facetted ones as the initial values

        existingValues = possibleValues.map(value => ({
          name: value,
          selected: selectedValues.has(value)
        }));
      }

      return Object.assign({}, label, {
        loading: false,
        values: existingValues,
        facets: existingValues.length
      });
    } // Label is facetted out, hide all values


    return Object.assign({}, label, {
      loading: false,
      hidden: !possibleValues,
      values: undefined,
      facets: 0
    });
  });
}

const getStyles = theme => ({
  wrapper: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    background-color: ${theme.colors.background.secondary};
    padding: ${theme.spacing(2)};
    width: 100%;
  `,
  list: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    margin-top: ${theme.spacing(1)};
    display: flex;
    flex-wrap: wrap;
    max-height: 200px;
    overflow: auto;
  `,
  section: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    & + & {
      margin: ${theme.spacing(2, 0)};
    }
    position: relative;
  `,
  selector: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    font-family: ${theme.typography.fontFamilyMonospace};
    margin-bottom: ${theme.spacing(1)};
  `,
  status: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    padding: ${theme.spacing(0.5)};
    color: ${theme.colors.text.secondary};
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    /* using absolute positioning because flex interferes with ellipsis */
    position: absolute;
    width: 50%;
    right: 0;
    text-align: right;
    transition: opacity 100ms linear;
    opacity: 0;
  `,
  statusShowing: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    opacity: 1;
  `,
  error: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    color: ${theme.colors.error.main};
  `,
  valueList: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    margin-right: ${theme.spacing(1)};
  `,
  valueListWrapper: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    border-left: 1px solid ${theme.colors.border.medium};
    margin: ${theme.spacing(1, 0)};
    padding: ${theme.spacing(1, 0, 1, 1)};
  `,
  valueListArea: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    display: flex;
    flex-wrap: wrap;
    margin-top: ${theme.spacing(1)};
  `,
  valueTitle: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    margin-left: -${theme.spacing(0.5)};
    margin-bottom: ${theme.spacing(1)};
  `,
  validationStatus: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    padding: ${theme.spacing(0.5)};
    margin-bottom: ${theme.spacing(1)};
    color: ${theme.colors.text.maxContrast};
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  `
});

class UnthemedLokiLabelBrowser extends react__WEBPACK_IMPORTED_MODULE_2__.Component {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "state", {
      labels: [],
      searchTerm: '',
      status: 'Ready',
      error: '',
      validationStatus: ''
    });

    _defineProperty(this, "onChangeSearch", event => {
      this.setState({
        searchTerm: event.target.value
      });
    });

    _defineProperty(this, "onClickRunLogsQuery", () => {
      const selector = buildSelector(this.state.labels);
      this.props.onChange(selector);
    });

    _defineProperty(this, "onClickRunMetricsQuery", () => {
      const selector = buildSelector(this.state.labels);
      const query = `rate(${selector}[$__interval])`;
      this.props.onChange(query);
    });

    _defineProperty(this, "onClickClear", () => {
      this.setState(state => {
        const labels = state.labels.map(label => Object.assign({}, label, {
          values: undefined,
          selected: false,
          loading: false,
          hidden: false,
          facets: undefined
        }));
        return {
          labels,
          searchTerm: '',
          status: '',
          error: '',
          validationStatus: ''
        };
      });
      this.props.deleteLastUsedLabels();
    });

    _defineProperty(this, "onClickLabel", (name, value, event) => {
      const label = this.state.labels.find(l => l.name === name);

      if (!label) {
        return;
      } // Toggle selected state


      const selected = !label.selected;
      let nextValue = {
        selected
      };

      if (label.values && !selected) {
        // Deselect all values if label was deselected
        const values = label.values.map(value => Object.assign({}, value, {
          selected: false
        }));
        nextValue = Object.assign({}, nextValue, {
          facets: 0,
          values
        });
      } // Resetting search to prevent empty results


      this.setState({
        searchTerm: ''
      });
      this.updateLabelState(name, nextValue, '', () => this.doFacettingForLabel(name));
    });

    _defineProperty(this, "onClickValue", (name, value, event) => {
      const label = this.state.labels.find(l => l.name === name);

      if (!label || !label.values) {
        return;
      } // Resetting search to prevent empty results


      this.setState({
        searchTerm: ''
      }); // Toggling value for selected label, leaving other values intact

      const values = label.values.map(v => Object.assign({}, v, {
        selected: v.name === value ? !v.selected : v.selected
      }));
      this.updateLabelState(name, {
        values
      }, '', () => this.doFacetting(name));
    });

    _defineProperty(this, "onClickValidate", () => {
      const selector = buildSelector(this.state.labels);
      this.validateSelector(selector);
    });

    _defineProperty(this, "doFacetting", lastFacetted => {
      const selector = buildSelector(this.state.labels);

      if (selector === EMPTY_SELECTOR) {
        // Clear up facetting
        const labels = this.state.labels.map(label => {
          return Object.assign({}, label, {
            facets: 0,
            values: undefined,
            hidden: false
          });
        });
        this.setState({
          labels
        }, () => {
          // Get fresh set of values
          this.state.labels.forEach(label => label.selected && this.fetchValues(label.name, selector));
        });
      } else {
        // Do facetting
        this.fetchSeries(selector, lastFacetted);
      }
    });
  }

  updateLabelState(name, updatedFields, status = '', cb) {
    this.setState(state => {
      const labels = state.labels.map(label => {
        if (label.name === name) {
          return Object.assign({}, label, updatedFields);
        }

        return label;
      }); // New status overrides errors

      const error = status ? '' : state.error;
      return {
        labels,
        status,
        error,
        validationStatus: ''
      };
    }, cb);
  }

  componentDidMount() {
    const {
      languageProvider,
      autoSelect = MAX_AUTO_SELECT,
      lastUsedLabels
    } = this.props;

    if (languageProvider) {
      const selectedLabels = lastUsedLabels;
      languageProvider.start().then(() => {
        let rawLabels = languageProvider.getLabelKeys();

        if (rawLabels.length > MAX_LABEL_COUNT) {
          const error = `Too many labels found (showing only ${MAX_LABEL_COUNT} of ${rawLabels.length})`;
          rawLabels = rawLabels.slice(0, MAX_LABEL_COUNT);
          this.setState({
            error
          });
        } // Auto-select all labels if label list is small enough


        const labels = rawLabels.map((label, i, arr) => ({
          name: label,
          selected: arr.length <= autoSelect && selectedLabels.length === 0 || selectedLabels.includes(label),
          loading: false
        })); // Pre-fetch values for selected labels

        this.setState({
          labels
        }, () => {
          this.state.labels.forEach(label => {
            if (label.selected) {
              this.fetchValues(label.name, EMPTY_SELECTOR);
            }
          });
        });
      });
    }
  }

  doFacettingForLabel(name) {
    const label = this.state.labels.find(l => l.name === name);

    if (!label) {
      return;
    }

    const selectedLabels = this.state.labels.filter(label => label.selected).map(label => label.name);
    this.props.storeLastUsedLabels(selectedLabels);

    if (label.selected) {
      // Refetch values for newly selected label...
      if (!label.values) {
        this.fetchValues(name, buildSelector(this.state.labels));
      }
    } else {
      // Only need to facet when deselecting labels
      this.doFacetting();
    }
  }

  async fetchValues(name, selector) {
    const {
      languageProvider
    } = this.props;
    this.updateLabelState(name, {
      loading: true
    }, `Fetching values for ${name}`);

    try {
      let rawValues = await languageProvider.getLabelValues(name); // If selector changed, clear loading state and discard result by returning early

      if (selector !== buildSelector(this.state.labels)) {
        this.updateLabelState(name, {
          loading: false
        }, '');
        return;
      }

      if (rawValues.length > MAX_VALUE_COUNT) {
        const error = `Too many values for ${name} (showing only ${MAX_VALUE_COUNT} of ${rawValues.length})`;
        rawValues = rawValues.slice(0, MAX_VALUE_COUNT);
        this.setState({
          error
        });
      }

      const values = rawValues.map(value => ({
        name: value
      }));
      this.updateLabelState(name, {
        values,
        loading: false
      });
    } catch (error) {
      console.error(error);
    }
  }

  async fetchSeries(selector, lastFacetted) {
    const {
      languageProvider
    } = this.props;

    if (lastFacetted) {
      this.updateLabelState(lastFacetted, {
        loading: true
      }, `Facetting labels for ${selector}`);
    }

    try {
      const possibleLabels = await languageProvider.fetchSeriesLabels(selector, true); // If selector changed, clear loading state and discard result by returning early

      if (selector !== buildSelector(this.state.labels)) {
        if (lastFacetted) {
          this.updateLabelState(lastFacetted, {
            loading: false
          });
        }

        return;
      }

      if (Object.keys(possibleLabels).length === 0) {
        this.setState({
          error: `Empty results, no matching label for ${selector}`
        });
        return;
      }

      const labels = facetLabels(this.state.labels, possibleLabels, lastFacetted);
      this.setState({
        labels,
        error: ''
      });

      if (lastFacetted) {
        this.updateLabelState(lastFacetted, {
          loading: false
        });
      }
    } catch (error) {
      console.error(error);
    }
  }

  async validateSelector(selector) {
    const {
      languageProvider
    } = this.props;
    this.setState({
      validationStatus: `Validating selector ${selector}`,
      error: ''
    });
    const streams = await languageProvider.fetchSeries(selector);
    this.setState({
      validationStatus: `Selector is valid (${streams.length} streams found)`
    });
  }

  render() {
    const {
      theme
    } = this.props;
    const {
      labels,
      searchTerm,
      status,
      error,
      validationStatus
    } = this.state;

    if (labels.length === 0) {
      return _LoadingPlaceholder || (_LoadingPlaceholder = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.LoadingPlaceholder, {
        text: "Loading labels..."
      }));
    }

    const styles = getStyles(theme);
    const selector = buildSelector(this.state.labels);
    const empty = selector === EMPTY_SELECTOR;
    let selectedLabels = labels.filter(label => label.selected && label.values);

    if (searchTerm) {
      selectedLabels = selectedLabels.map(label => {
        const searchResults = label.values.filter(value => {
          // Always return selected values
          if (value.selected) {
            value.highlightParts = undefined;
            return true;
          }

          const fuzzyMatchResult = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.fuzzyMatch)(value.name.toLowerCase(), searchTerm.toLowerCase());

          if (fuzzyMatchResult.found) {
            value.highlightParts = fuzzyMatchResult.ranges;
            value.order = fuzzyMatchResult.distance;
            return true;
          } else {
            return false;
          }
        });
        return Object.assign({}, label, {
          values: (0,lodash__WEBPACK_IMPORTED_MODULE_1__.sortBy)(searchResults, value => value.selected ? -Infinity : value.order)
        });
      });
    } else {
      // Clear highlight parts when searchTerm is cleared
      selectedLabels = this.state.labels.filter(label => label.selected && label.values).map(label => Object.assign({}, label, {
        values: label !== null && label !== void 0 && label.values ? label.values.map(value => Object.assign({}, value, {
          highlightParts: undefined
        })) : []
      }));
    }

    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
      className: styles.wrapper,
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
        className: styles.section,
        children: [_Label || (_Label = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Label, {
          description: "Which labels would you like to consider for your search?",
          children: "1. Select labels to search in"
        })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
          className: styles.list,
          children: labels.map(label => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.BrowserLabel, {
            name: label.name,
            loading: label.loading,
            active: label.selected,
            hidden: label.hidden,
            facets: label.facets,
            onClick: this.onClickLabel
          }, label.name))
        })]
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
        className: styles.section,
        children: [_Label2 || (_Label2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Label, {
          description: "Choose the label values that you would like to use for the query. Use the search field to find values across selected labels.",
          children: "2. Find values for the selected labels"
        })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Input, {
            onChange: this.onChangeSearch,
            "aria-label": "Filter expression for values",
            value: searchTerm
          })
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
          className: styles.valueListArea,
          children: selectedLabels.map(label => {
            var _label$values2, _label$values3;

            return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
              role: "list",
              className: styles.valueListWrapper,
              children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
                className: styles.valueTitle,
                "aria-label": `Values for ${label.name}`,
                children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.BrowserLabel, {
                  name: label.name,
                  loading: label.loading,
                  active: label.selected,
                  hidden: label.hidden //If no facets, we want to show number of all label values
                  ,
                  facets: label.facets || ((_label$values2 = label.values) === null || _label$values2 === void 0 ? void 0 : _label$values2.length),
                  onClick: this.onClickLabel
                })
              }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react_window__WEBPACK_IMPORTED_MODULE_6__.FixedSizeList, {
                height: 200,
                itemCount: ((_label$values3 = label.values) === null || _label$values3 === void 0 ? void 0 : _label$values3.length) || 0,
                itemSize: 28,
                itemKey: i => label.values[i].name,
                width: 200,
                className: styles.valueList,
                children: ({
                  index,
                  style
                }) => {
                  var _label$values4;

                  const value = (_label$values4 = label.values) === null || _label$values4 === void 0 ? void 0 : _label$values4[index];

                  if (!value) {
                    return null;
                  }

                  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
                    style: style,
                    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.BrowserLabel, {
                      name: label.name,
                      value: value === null || value === void 0 ? void 0 : value.name,
                      active: value === null || value === void 0 ? void 0 : value.selected,
                      highlightParts: value === null || value === void 0 ? void 0 : value.highlightParts,
                      onClick: this.onClickValue,
                      searchTerm: searchTerm
                    })
                  });
                }
              })]
            }, label.name);
          })
        })]
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
        className: styles.section,
        children: [_Label3 || (_Label3 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Label, {
          children: "3. Resulting selector"
        })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
          "aria-label": "selector",
          className: styles.selector,
          children: selector
        }), validationStatus && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
          className: styles.validationStatus,
          children: validationStatus
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.HorizontalGroup, {
          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
            "aria-label": "Use selector as logs button",
            disabled: empty,
            onClick: this.onClickRunLogsQuery,
            children: "Show logs"
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
            "aria-label": "Use selector as metrics button",
            variant: "secondary",
            disabled: empty,
            onClick: this.onClickRunMetricsQuery,
            children: "Show logs rate"
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
            "aria-label": "Validate submit button",
            variant: "secondary",
            disabled: empty,
            onClick: this.onClickValidate,
            children: "Validate selector"
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
            "aria-label": "Selector clear button",
            variant: "secondary",
            onClick: this.onClickClear,
            children: "Clear"
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
            className: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.cx)(styles.status, (status || error) && styles.statusShowing),
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("span", {
              className: error ? styles.error : '',
              children: error || status
            })
          })]
        })]
      })]
    });
  }

}
const LokiLabelBrowser = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.withTheme2)(UnthemedLokiLabelBrowser);

/***/ }),

/***/ "./public/app/plugins/datasource/loki/components/LokiOptionFields.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEFAULT_RESOLUTION": () => (/* binding */ DEFAULT_RESOLUTION),
/* harmony export */   "LokiOptionFields": () => (/* binding */ LokiOptionFields),
/* harmony export */   "RESOLUTION_OPTIONS": () => (/* binding */ RESOLUTION_OPTIONS),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "preprocessMaxLines": () => (/* binding */ preprocessMaxLines),
/* harmony export */   "queryTypeOptions": () => (/* binding */ queryTypeOptions)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/loki/types.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _InlineFormLabel;

const _excluded = ["instant", "range"];

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

// Libraries


 // Types






const queryTypeOptions = [{
  value: _types__WEBPACK_IMPORTED_MODULE_5__.LokiQueryType.Range,
  label: 'Range',
  description: 'Run query over a range of time.'
}, {
  value: _types__WEBPACK_IMPORTED_MODULE_5__.LokiQueryType.Instant,
  label: 'Instant',
  description: 'Run query against a single point in time. For this query, the "To" time is used.'
}];

if (_grafana_runtime__WEBPACK_IMPORTED_MODULE_3__.config.featureToggles.lokiLive) {
  queryTypeOptions.push({
    value: _types__WEBPACK_IMPORTED_MODULE_5__.LokiQueryType.Stream,
    label: 'Stream',
    description: 'Run a query and keep sending results on an interval'
  });
}

const DEFAULT_RESOLUTION = {
  value: 1,
  label: '1/1'
};
const RESOLUTION_OPTIONS = [DEFAULT_RESOLUTION].concat((0,lodash__WEBPACK_IMPORTED_MODULE_1__.map)([2, 3, 4, 5, 10], value => ({
  value,
  label: '1/' + value
})));
function LokiOptionFields(props) {
  var _props$query, _query$queryType;

  const {
    lineLimitValue,
    resolution,
    onRunQuery,
    runOnBlur,
    onChange
  } = props;
  const query = (_props$query = props.query) !== null && _props$query !== void 0 ? _props$query : {};
  let queryType = (_query$queryType = query.queryType) !== null && _query$queryType !== void 0 ? _query$queryType : query.instant ? _types__WEBPACK_IMPORTED_MODULE_5__.LokiQueryType.Instant : _types__WEBPACK_IMPORTED_MODULE_5__.LokiQueryType.Range;

  function onChangeQueryLimit(value) {
    const nextQuery = Object.assign({}, query, {
      maxLines: preprocessMaxLines(value)
    });
    onChange(nextQuery);
  }

  function onQueryTypeChange(queryType) {
    const rest = _objectWithoutPropertiesLoose(query, _excluded);

    onChange(Object.assign({}, rest, {
      queryType
    }));
  }

  function onMaxLinesChange(e) {
    if (query.maxLines !== preprocessMaxLines(e.currentTarget.value)) {
      onChangeQueryLimit(e.currentTarget.value);
    }
  }

  function onReturnKeyDown(e) {
    if (e.key === 'Enter') {
      onRunQuery();
    }
  }

  function onResolutionChange(option) {
    const nextQuery = Object.assign({}, query, {
      resolution: option.value
    });
    onChange(nextQuery);
  }

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("div", {
    "aria-label": "Loki extra field",
    className: "gf-form-inline",
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("div", {
      "data-testid": "queryTypeField",
      className: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.cx)('gf-form explore-input-margin', _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
            flex-wrap: nowrap;
          `),
      "aria-label": "Query type field",
      children: [_InlineFormLabel || (_InlineFormLabel = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.InlineFormLabel, {
        width: "auto",
        children: "Query type"
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.RadioButtonGroup, {
        options: queryTypeOptions,
        value: queryType,
        onChange: type => {
          onQueryTypeChange(type);

          if (runOnBlur) {
            onRunQuery();
          }
        }
      })]
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("div", {
      "data-testid": "lineLimitField",
      className: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.cx)('gf-form', _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
            flex-wrap: nowrap;
          `),
      "aria-label": "Line limit field",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.InlineField, {
        label: "Line limit",
        tooltip: 'Upper limit for number of log lines returned by query.',
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Input, {
          className: "width-4",
          placeholder: "auto",
          type: "number",
          min: 0,
          onChange: onMaxLinesChange,
          onKeyDown: onReturnKeyDown,
          value: lineLimitValue,
          onBlur: () => {
            if (runOnBlur) {
              onRunQuery();
            }
          }
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.InlineField, {
        label: "Resolution",
        tooltip: 'Resolution 1/1 sets step parameter of Loki metrics range queries such that each pixel corresponds to one data point. For better performance, lower resolutions can be picked. 1/2 only retrieves a data point for every other pixel, and 1/10 retrieves one data point per 10 pixels.',
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Select, {
          isSearchable: false,
          onChange: onResolutionChange,
          options: RESOLUTION_OPTIONS,
          value: resolution,
          "aria-label": "Select resolution"
        })
      })]
    })]
  });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_2__.memo)(LokiOptionFields));
function preprocessMaxLines(value) {
  if (value.length === 0) {
    // empty input - falls back to dataSource.maxLines limit
    return NaN;
  } else if (value.length > 0 && (isNaN(+value) || +value < 0)) {
    // input with at least 1 character and that is either incorrect (value in the input field is not a number) or negative
    // falls back to the limit of 0 lines
    return 0;
  } else {
    // default case - correct input
    return +value;
  }
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/components/LokiQueryEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiQueryEditor": () => (/* binding */ LokiQueryEditor),
/* harmony export */   "testIds": () => (/* binding */ testIds)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _LokiOptionFields__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiOptionFields.tsx");
/* harmony import */ var _LokiQueryField__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiQueryField.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _InlineFormLabel;

// Libraries
 // Types







function LokiQueryEditor(props) {
  var _query$maxLines;

  const {
    query,
    data,
    datasource,
    onChange,
    onRunQuery,
    range
  } = props;

  const onLegendChange = e => {
    const nextQuery = Object.assign({}, query, {
      legendFormat: e.currentTarget.value
    });
    onChange(nextQuery);
  };

  const legendField = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
    className: "gf-form-inline",
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
      className: "gf-form",
      children: [_InlineFormLabel || (_InlineFormLabel = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.InlineFormLabel, {
        width: 6,
        tooltip: "Controls the name of the time series, using name or pattern. For example {{hostname}} will be replaced with label value for the label hostname. The legend only applies to metric queries.",
        children: "Legend"
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("input", {
        type: "text",
        className: "gf-form-input",
        placeholder: "legend format",
        value: query.legendFormat || '',
        onChange: onLegendChange,
        onBlur: onRunQuery
      })]
    })
  });

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_LokiQueryField__WEBPACK_IMPORTED_MODULE_3__.LokiQueryField, {
    datasource: datasource,
    query: query,
    onChange: onChange,
    onRunQuery: onRunQuery,
    onBlur: onRunQuery,
    history: [],
    data: data,
    "data-testid": testIds.editor,
    range: range,
    ExtraFieldElement: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.Fragment, {
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_LokiOptionFields__WEBPACK_IMPORTED_MODULE_2__.LokiOptionFields, {
        lineLimitValue: (query === null || query === void 0 ? void 0 : (_query$maxLines = query.maxLines) === null || _query$maxLines === void 0 ? void 0 : _query$maxLines.toString()) || '',
        resolution: (query === null || query === void 0 ? void 0 : query.resolution) || 1,
        query: query,
        onRunQuery: onRunQuery,
        onChange: onChange,
        runOnBlur: true
      }), legendField]
    })
  });
}
const testIds = {
  editor: 'loki-editor'
};

/***/ }),

/***/ "./public/app/plugins/datasource/loki/components/LokiQueryEditorByApp.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiQueryEditorByApp": () => (/* binding */ LokiQueryEditorByApp),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _querybuilder_components_LokiQueryEditorSelector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/components/LokiQueryEditorSelector.tsx");
/* harmony import */ var _LokiExploreQueryEditor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiExploreQueryEditor.tsx");
/* harmony import */ var _LokiQueryEditor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiQueryEditor.tsx");
/* harmony import */ var _LokiQueryEditorForAlerting__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiQueryEditorForAlerting.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");








function LokiQueryEditorByApp(props) {
  const {
    app
  } = props;

  switch (app) {
    case _grafana_data__WEBPACK_IMPORTED_MODULE_1__.CoreApp.CloudAlerting:
      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_LokiQueryEditorForAlerting__WEBPACK_IMPORTED_MODULE_6__.LokiQueryEditorForAlerting, Object.assign({}, props));

    case _grafana_data__WEBPACK_IMPORTED_MODULE_1__.CoreApp.Explore:
      if (_grafana_runtime__WEBPACK_IMPORTED_MODULE_2__.config.featureToggles.lokiQueryBuilder) {
        return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_querybuilder_components_LokiQueryEditorSelector__WEBPACK_IMPORTED_MODULE_3__.LokiQueryEditorSelector, Object.assign({}, props));
      }

      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_LokiExploreQueryEditor__WEBPACK_IMPORTED_MODULE_4__.LokiExploreQueryEditor, Object.assign({}, props));

    default:
      if (_grafana_runtime__WEBPACK_IMPORTED_MODULE_2__.config.featureToggles.lokiQueryBuilder) {
        return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_querybuilder_components_LokiQueryEditorSelector__WEBPACK_IMPORTED_MODULE_3__.LokiQueryEditorSelector, Object.assign({}, props));
      }

      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_LokiQueryEditor__WEBPACK_IMPORTED_MODULE_5__.LokiQueryEditor, Object.assign({}, props));
  }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(LokiQueryEditorByApp));

/***/ }),

/***/ "./public/app/plugins/datasource/loki/components/LokiQueryEditorForAlerting.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiQueryEditorForAlerting": () => (/* binding */ LokiQueryEditorForAlerting),
/* harmony export */   "testIds": () => (/* binding */ testIds)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _LokiQueryField__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiQueryField.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");



function LokiQueryEditorForAlerting(props) {
  const {
    query,
    data,
    datasource,
    onChange,
    onRunQuery
  } = props;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_LokiQueryField__WEBPACK_IMPORTED_MODULE_1__.LokiQueryField, {
    datasource: datasource,
    query: query,
    onChange: onChange,
    onRunQuery: onRunQuery,
    onBlur: onRunQuery,
    history: [],
    data: data,
    placeholder: "Enter a Loki query",
    "data-testid": testIds.editor
  });
}
const testIds = {
  editor: 'loki-editor-cloud-alerting'
};

/***/ }),

/***/ "./public/app/plugins/datasource/loki/components/LokiQueryField.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiQueryField": () => (/* binding */ LokiQueryField)
/* harmony export */ });
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/prismjs-npm-1.27.0-ca4e1667c6-85c7f4a3e9.zip/node_modules/prismjs/prism.js");
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prismjs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_core_components_LocalStorageValueProvider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/core/components/LocalStorageValueProvider/index.tsx");
/* harmony import */ var _language_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/loki/language_utils.ts");
/* harmony import */ var _LokiLabelBrowser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiLabelBrowser.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }










const LAST_USED_LABELS_KEY = 'grafana.datasources.loki.browser.labels';

function getChooserText(hasSyntax, hasLogLabels) {
  if (!hasSyntax) {
    return 'Loading labels...';
  }

  if (!hasLogLabels) {
    return '(No logs found)';
  }

  return 'Log browser';
}

function willApplySuggestion(suggestion, {
  typeaheadContext,
  typeaheadText
}) {
  // Modify suggestion based on context
  switch (typeaheadContext) {
    case 'context-labels':
      {
        const nextChar = _grafana_ui__WEBPACK_IMPORTED_MODULE_2__.DOMUtil.getNextCharacter();

        if (!nextChar || nextChar === '}' || nextChar === ',') {
          suggestion += '=';
        }

        break;
      }

    case 'context-label-values':
      {
        // Always add quotes and remove existing ones instead
        let suggestionModified = '';

        if (!typeaheadText.match(/^(!?=~?"|")/)) {
          suggestionModified = '"';
        }

        suggestionModified += (0,_language_utils__WEBPACK_IMPORTED_MODULE_4__.escapeLabelValueInSelector)(suggestion, typeaheadText);

        if (_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.DOMUtil.getNextCharacter() !== '"') {
          suggestionModified += '"';
        }

        suggestion = suggestionModified;
        break;
      }

    default:
  }

  return suggestion;
}

class LokiQueryField extends react__WEBPACK_IMPORTED_MODULE_1__.PureComponent {
  constructor(props) {
    super(props);

    _defineProperty(this, "plugins", void 0);

    _defineProperty(this, "_isMounted", false);

    _defineProperty(this, "onChangeLabelBrowser", selector => {
      this.onChangeQuery(selector, true);
      this.setState({
        labelBrowserVisible: false
      });
    });

    _defineProperty(this, "onChangeQuery", (value, override) => {
      // Send text change to parent
      const {
        query,
        onChange,
        onRunQuery
      } = this.props;

      if (onChange) {
        const nextQuery = Object.assign({}, query, {
          expr: value
        });
        onChange(nextQuery);

        if (override && onRunQuery) {
          onRunQuery();
        }
      }
    });

    _defineProperty(this, "onClickChooserButton", () => {
      this.setState(state => ({
        labelBrowserVisible: !state.labelBrowserVisible
      }));
    });

    _defineProperty(this, "onTypeahead", async typeahead => {
      const {
        datasource
      } = this.props;

      if (!datasource.languageProvider) {
        return {
          suggestions: []
        };
      }

      const lokiLanguageProvider = datasource.languageProvider;
      const {
        history
      } = this.props;
      const {
        prefix,
        text,
        value,
        wrapperClasses,
        labelKey
      } = typeahead;
      const result = await lokiLanguageProvider.provideCompletionItems({
        text,
        value,
        prefix,
        wrapperClasses,
        labelKey
      }, {
        history
      });
      return result;
    });

    this.state = {
      labelsLoaded: false,
      labelBrowserVisible: false
    };
    this.plugins = [(0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.BracesPlugin)(), (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.SlatePrism)({
      onlyIn: node => node.object === 'block' && node.type === 'code_block',
      getSyntax: node => 'logql'
    }, Object.assign({}, prismjs__WEBPACK_IMPORTED_MODULE_0__.languages, {
      logql: this.props.datasource.languageProvider.getSyntax()
    }))];
  }

  async componentDidMount() {
    this._isMounted = true;
    await this.props.datasource.languageProvider.start();

    if (this._isMounted) {
      this.setState({
        labelsLoaded: true
      });
    }
  }

  componentWillUnmount() {
    this._isMounted = false;
  }

  componentDidUpdate(prevProps) {
    const {
      range,
      datasource: {
        languageProvider
      }
    } = this.props;
    const refreshLabels = (0,_language_utils__WEBPACK_IMPORTED_MODULE_4__.shouldRefreshLabels)(range, prevProps.range); // We want to refresh labels when range changes (we round up intervals to a minute)

    if (refreshLabels) {
      languageProvider.fetchLabels();
    }
  }

  render() {
    const {
      ExtraFieldElement,
      query,
      datasource,
      placeholder = 'Enter a Loki query (run with Shift+Enter)'
    } = this.props;
    const {
      labelsLoaded,
      labelBrowserVisible
    } = this.state;
    const lokiLanguageProvider = datasource.languageProvider;
    const cleanText = datasource.languageProvider ? lokiLanguageProvider.cleanText : undefined;
    const hasLogLabels = lokiLanguageProvider.getLabelKeys().length > 0;
    const chooserText = getChooserText(labelsLoaded, hasLogLabels);
    const buttonDisabled = !(labelsLoaded && hasLogLabels);
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(app_core_components_LocalStorageValueProvider__WEBPACK_IMPORTED_MODULE_3__.LocalStorageValueProvider, {
      storageKey: LAST_USED_LABELS_KEY,
      defaultValue: [],
      children: (lastUsedLabels, onLastUsedLabelsSave, onLastUsedLabelsDelete) => {
        return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.Fragment, {
          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("div", {
            className: "gf-form-inline gf-form-inline--xs-view-flex-column flex-grow-1",
            "data-testid": this.props['data-testid'],
            children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("button", {
              className: "gf-form-label query-keyword pointer",
              onClick: this.onClickChooserButton,
              disabled: buttonDisabled,
              children: [chooserText, /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Icon, {
                name: labelBrowserVisible ? 'angle-down' : 'angle-right'
              })]
            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("div", {
              className: "gf-form gf-form--grow flex-shrink-1 min-width-15",
              children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.QueryField, {
                additionalPlugins: this.plugins,
                cleanText: cleanText,
                query: query.expr,
                onTypeahead: this.onTypeahead,
                onWillApplySuggestion: willApplySuggestion,
                onChange: this.onChangeQuery,
                onBlur: this.props.onBlur,
                onRunQuery: this.props.onRunQuery,
                placeholder: placeholder,
                portalOrigin: "loki"
              })
            })]
          }), labelBrowserVisible && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("div", {
            className: "gf-form",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_LokiLabelBrowser__WEBPACK_IMPORTED_MODULE_5__.LokiLabelBrowser, {
              languageProvider: lokiLanguageProvider,
              onChange: this.onChangeLabelBrowser,
              lastUsedLabels: lastUsedLabels || [],
              storeLastUsedLabels: onLastUsedLabelsSave,
              deleteLastUsedLabels: onLastUsedLabelsDelete
            })
          }), ExtraFieldElement]
        });
      }
    });
  }

}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/configuration/ConfigEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConfigEditor": () => (/* binding */ ConfigEditor)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_features_alerting_unified_utils_alertmanager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/alerting/unified/utils/alertmanager.ts");
/* harmony import */ var _DerivedFields__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/loki/configuration/DerivedFields.tsx");
/* harmony import */ var _MaxLinesField__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/loki/configuration/MaxLinesField.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");









const makeJsonUpdater = field => (options, value) => {
  return Object.assign({}, options, {
    jsonData: Object.assign({}, options.jsonData, {
      [field]: value
    })
  });
};

const setMaxLines = makeJsonUpdater('maxLines');
const setDerivedFields = makeJsonUpdater('derivedFields');
const ConfigEditor = props => {
  const {
    options,
    onOptionsChange
  } = props;
  const alertmanagers = (0,app_features_alerting_unified_utils_alertmanager__WEBPACK_IMPORTED_MODULE_2__.getAllAlertmanagerDataSources)();
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.DataSourceHttpSettings, {
      defaultUrl: 'http://localhost:3100',
      dataSourceConfig: options,
      showAccessOptions: false,
      onChange: onOptionsChange
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.AlertingSettings, {
      alertmanagerDataSources: alertmanagers,
      options: options,
      onOptionsChange: onOptionsChange
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
      className: "gf-form-group",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
        className: "gf-form-inline",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
          className: "gf-form",
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_MaxLinesField__WEBPACK_IMPORTED_MODULE_4__.MaxLinesField, {
            value: options.jsonData.maxLines || '',
            onChange: value => onOptionsChange(setMaxLines(options, value))
          })
        })
      })
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_DerivedFields__WEBPACK_IMPORTED_MODULE_3__.DerivedFields, {
      value: options.jsonData.derivedFields,
      onChange: value => onOptionsChange(setDerivedFields(options, value))
    })]
  });
};

/***/ }),

/***/ "./public/app/plugins/datasource/loki/configuration/DebugSection.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DebugSection": () => (/* binding */ DebugSection)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/classnames-npm-2.3.1-f2ae0a8d3c-14db8889d5.zip/node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _features_explore_utils_links__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/features/explore/utils/links.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _thead;









const {
  FormField
} = _grafana_ui__WEBPACK_IMPORTED_MODULE_4__.LegacyForms;
const DebugSection = props => {
  const {
    derivedFields,
    className
  } = props;
  const [debugText, setDebugText] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)('');
  let debugFields = [];

  if (debugText && derivedFields) {
    debugFields = makeDebugFields(derivedFields, debugText);
  }

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("div", {
    className: className,
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(FormField, {
      labelWidth: 12,
      label: 'Debug log message',
      inputEl: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("textarea", {
        placeholder: 'Paste an example log line here to test the regular expressions of your derived fields',
        className: classnames__WEBPACK_IMPORTED_MODULE_1___default()('gf-form-input gf-form-textarea', _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
                width: 100%;
              `),
        value: debugText,
        onChange: event => setDebugText(event.currentTarget.value)
      })
    }), !!debugFields.length && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(DebugFields, {
      fields: debugFields
    })]
  });
};

const DebugFields = ({
  fields
}) => {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("table", {
    className: 'filter-table',
    children: [_thead || (_thead = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("thead", {
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("tr", {
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("th", {
          children: "Name"
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("th", {
          children: "Value"
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("th", {
          children: "Url"
        })]
      })
    })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("tbody", {
      children: fields.map(field => {
        let value = field.value;

        if (field.error) {
          value = field.error.message;
        } else if (field.href) {
          value = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("a", {
            href: field.href,
            children: value
          });
        }

        return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("tr", {
          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("td", {
            children: field.name
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("td", {
            children: value
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("td", {
            children: field.href ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("a", {
              href: field.href,
              children: field.href
            }) : ''
          })]
        }, `${field.name}=${field.value}`);
      })
    })]
  });
};

function makeDebugFields(derivedFields, debugText) {
  return derivedFields.filter(field => field.name && field.matcherRegex).map(field => {
    try {
      const testMatch = debugText.match(field.matcherRegex);
      const value = testMatch && testMatch[1];
      let link = null;

      if (field.url && value) {
        link = (0,_features_explore_utils_links__WEBPACK_IMPORTED_MODULE_5__.getFieldLinksForExplore)({
          field: {
            name: '',
            type: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.FieldType.string,
            values: new _grafana_data__WEBPACK_IMPORTED_MODULE_3__.ArrayVector([value]),
            config: {
              links: [{
                title: '',
                url: field.url
              }]
            }
          },
          rowIndex: 0,
          range: {}
        })[0];
      }

      return {
        name: field.name,
        value: value || '<no match>',
        href: link && link.href
      };
    } catch (error) {
      return {
        name: field.name,
        error
      };
    }
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/configuration/DerivedField.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DerivedField": () => (/* binding */ DerivedField)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_use__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/__virtual__/react-use-virtual-00326e70ba/0/cache/react-use-npm-17.3.2-a032cbeb01-7379460f51.zip/node_modules/react-use/esm/usePrevious.js");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");







const {
  Switch,
  FormField
} = _grafana_ui__WEBPACK_IMPORTED_MODULE_3__.LegacyForms;
const getStyles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.stylesFactory)(() => ({
  row: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    display: flex;
    align-items: baseline;
  `,
  nameField: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    flex: 2;
  `,
  regexField: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    flex: 3;
  `,
  urlField: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    flex: 1;
  `,
  urlDisplayLabelField: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    flex: 1;
  `
}));
const DerivedField = props => {
  const {
    value,
    onChange,
    onDelete,
    suggestions,
    className
  } = props;
  const styles = getStyles();
  const [showInternalLink, setShowInternalLink] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!!value.datasourceUid);
  const previousUid = (0,react_use__WEBPACK_IMPORTED_MODULE_5__["default"])(value.datasourceUid); // Force internal link visibility change if uid changed outside of this component.

  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
    if (!previousUid && value.datasourceUid && !showInternalLink) {
      setShowInternalLink(true);
    }

    if (previousUid && !value.datasourceUid && showInternalLink) {
      setShowInternalLink(false);
    }
  }, [previousUid, value.datasourceUid, showInternalLink]);

  const handleChange = field => event => {
    onChange(Object.assign({}, value, {
      [field]: event.currentTarget.value
    }));
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
    className: className,
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
      className: styles.row,
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(FormField, {
        className: styles.nameField,
        labelWidth: 5 // A bit of a hack to prevent using default value for the width from FormField
        ,
        inputWidth: null,
        label: "Name",
        type: "text",
        value: value.name,
        onChange: handleChange('name')
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(FormField, {
        className: styles.regexField,
        inputWidth: null,
        label: "Regex",
        type: "text",
        value: value.matcherRegex,
        onChange: handleChange('matcherRegex'),
        tooltip: 'Use to parse and capture some part of the log message. You can use the captured groups in the template.'
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
        variant: "destructive",
        title: "Remove field",
        icon: "times",
        onClick: event => {
          event.preventDefault();
          onDelete();
        },
        className: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
            margin-left: 8px;
          `
      })]
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
      className: styles.row,
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(FormField, {
        label: showInternalLink ? 'Query' : 'URL',
        inputEl: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.DataLinkInput, {
          placeholder: showInternalLink ? '${__value.raw}' : 'http://example.com/${__value.raw}',
          value: value.url || '',
          onChange: newValue => onChange(Object.assign({}, value, {
            url: newValue
          })),
          suggestions: suggestions
        }),
        className: styles.urlField
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(FormField, {
        className: styles.urlDisplayLabelField,
        inputWidth: null,
        label: "URL Label",
        type: "text",
        value: value.urlDisplayLabel,
        onChange: handleChange('urlDisplayLabel'),
        tooltip: 'Use to override the button label when this derived field is found in a log.'
      })]
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
      className: styles.row,
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(Switch, {
        label: "Internal link",
        checked: showInternalLink,
        onChange: () => {
          if (showInternalLink) {
            onChange(Object.assign({}, value, {
              datasourceUid: undefined
            }));
          }

          setShowInternalLink(!showInternalLink);
        }
      }), showInternalLink && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_runtime__WEBPACK_IMPORTED_MODULE_2__.DataSourcePicker, {
        tracing: true,
        onChange: ds => onChange(Object.assign({}, value, {
          datasourceUid: ds.uid
        })),
        current: value.datasourceUid
      })]
    })]
  });
};

/***/ }),

/***/ "./public/app/plugins/datasource/loki/configuration/DerivedFields.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DerivedFields": () => (/* binding */ DerivedFields)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _DebugSection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/loki/configuration/DebugSection.tsx");
/* harmony import */ var _DerivedField__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/loki/configuration/DerivedField.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _h;











const getStyles = theme => ({
  infoText: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    padding-bottom: ${theme.spacing(2)};
    color: ${theme.colors.text.secondary};
  `,
  derivedField: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    margin-bottom: ${theme.spacing(1)};
  `
});

const DerivedFields = props => {
  const {
    value,
    onChange
  } = props;
  const theme = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.useTheme2)();
  const styles = getStyles(theme);
  const [showDebug, setShowDebug] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.Fragment, {
    children: [_h || (_h = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("h3", {
      className: "page-heading",
      children: "Derived fields"
    })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("div", {
      className: styles.infoText,
      children: "Derived fields can be used to extract new fields from a log message and create a link from its value."
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("div", {
      className: "gf-form-group",
      children: [value && value.map((field, index) => {
        return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_DerivedField__WEBPACK_IMPORTED_MODULE_5__.DerivedField, {
          className: styles.derivedField,
          value: field,
          onChange: newField => {
            const newDerivedFields = [...value];
            newDerivedFields.splice(index, 1, newField);
            onChange(newDerivedFields);
          },
          onDelete: () => {
            const newDerivedFields = [...value];
            newDerivedFields.splice(index, 1);
            onChange(newDerivedFields);
          },
          suggestions: [{
            value: _grafana_data__WEBPACK_IMPORTED_MODULE_2__.DataLinkBuiltInVars.valueRaw,
            label: 'Raw value',
            documentation: 'Exact string captured by the regular expression',
            origin: _grafana_data__WEBPACK_IMPORTED_MODULE_2__.VariableOrigin.Value
          }]
        }, index);
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("div", {
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
          variant: "secondary",
          className: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
              margin-right: 10px;
            `,
          icon: "plus",
          onClick: event => {
            event.preventDefault();
            const newDerivedFields = [...(value || []), {
              name: '',
              matcherRegex: ''
            }];
            onChange(newDerivedFields);
          },
          children: "Add"
        }), value && value.length > 0 && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
          variant: "secondary",
          type: "button",
          onClick: () => setShowDebug(!showDebug),
          children: showDebug ? 'Hide example log message' : 'Show example log message'
        })]
      })]
    }), showDebug && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("div", {
      className: "gf-form-group",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_DebugSection__WEBPACK_IMPORTED_MODULE_4__.DebugSection, {
        className: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
              margin-bottom: 10px;
            `,
        derivedFields: value
      })
    })]
  });
};

/***/ }),

/***/ "./public/app/plugins/datasource/loki/configuration/MaxLinesField.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MaxLinesField": () => (/* binding */ MaxLinesField)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");




const {
  FormField
} = _grafana_ui__WEBPACK_IMPORTED_MODULE_1__.LegacyForms;
const MaxLinesField = props => {
  const {
    value,
    onChange
  } = props;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(FormField, {
    label: "Maximum lines",
    labelWidth: 11,
    inputWidth: 20,
    inputEl: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)("input", {
      type: "number",
      className: "gf-form-input width-8 gf-form-input--has-help-icon",
      value: value,
      onChange: event => onChange(event.currentTarget.value),
      spellCheck: false,
      placeholder: "1000"
    }),
    tooltip: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, {
      children: "Loki queries must contain a limit of the maximum number of lines returned (default: 1000). Increase this limit to have a bigger result set for ad-hoc analysis. Decrease this limit if your browser becomes sluggish when displaying the log results."
    })
  });
};

/***/ }),

/***/ "./public/app/plugins/datasource/loki/datasource.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEFAULT_MAX_LINES": () => (/* binding */ DEFAULT_MAX_LINES),
/* harmony export */   "LOKI_ENDPOINT": () => (/* binding */ LOKI_ENDPOINT),
/* harmony export */   "LokiDatasource": () => (/* binding */ LokiDatasource),
/* harmony export */   "isMetricsQuery": () => (/* binding */ isMetricsQuery),
/* harmony export */   "lokiRegularEscape": () => (/* binding */ lokiRegularEscape),
/* harmony export */   "lokiSpecialRegexEscape": () => (/* binding */ lokiSpecialRegexEscape)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/prismjs-npm-1.27.0-ca4e1667c6-85c7f4a3e9.zip/node_modules/prismjs/prism.js");
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prismjs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/throwError.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/lastValueFrom.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/of.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/merge.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/map.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/catchError.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/switchMap.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var app_core_logs_model__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/core/logs_model.ts");
/* harmony import */ var app_core_utils_explore__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/core/utils/explore.ts");
/* harmony import */ var app_features_dashboard_services_TimeSrv__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/features/dashboard/services/TimeSrv.ts");
/* harmony import */ var app_features_templating_template_srv__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/features/templating/template_srv.ts");
/* harmony import */ var _core_utils_fetch__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./public/app/core/utils/fetch.ts");
/* harmony import */ var _prometheus_legend__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./public/app/plugins/datasource/prometheus/legend.ts");
/* harmony import */ var _add_label_to_query__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./public/app/plugins/datasource/loki/add_label_to_query.ts");
/* harmony import */ var _backendResultTransformer__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./public/app/plugins/datasource/loki/backendResultTransformer.ts");
/* harmony import */ var _components_LokiOptionFields__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiOptionFields.tsx");
/* harmony import */ var _language_provider__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./public/app/plugins/datasource/loki/language_provider.ts");
/* harmony import */ var _language_utils__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./public/app/plugins/datasource/loki/language_utils.ts");
/* harmony import */ var _live_streams__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./public/app/plugins/datasource/loki/live_streams.ts");
/* harmony import */ var _query_utils__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("./public/app/plugins/datasource/loki/query_utils.ts");
/* harmony import */ var _result_transformer__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__("./public/app/plugins/datasource/loki/result_transformer.ts");
/* harmony import */ var _sortDataFrame__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__("./public/app/plugins/datasource/loki/sortDataFrame.ts");
/* harmony import */ var _streaming__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__("./public/app/plugins/datasource/loki/streaming.ts");
/* harmony import */ var _syntax__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__("./public/app/plugins/datasource/loki/syntax.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__("./public/app/plugins/datasource/loki/types.ts");
const _excluded = ["__interval", "__interval_ms"];

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Libraries



 // Types





















const DEFAULT_MAX_LINES = 1000;
const LOKI_ENDPOINT = '/loki/api/v1';
const NS_IN_MS = 1000000;
const RANGE_QUERY_ENDPOINT = `${LOKI_ENDPOINT}/query_range`;
const INSTANT_QUERY_ENDPOINT = `${LOKI_ENDPOINT}/query`;
const DEFAULT_QUERY_PARAMS = {
  limit: DEFAULT_MAX_LINES,
  query: ''
};

function makeRequest(query, range, app, requestId) {
  const intervalInfo = _grafana_data__WEBPACK_IMPORTED_MODULE_2__.rangeUtil.calculateInterval(range, 1);
  return {
    targets: [query],
    requestId,
    interval: intervalInfo.interval,
    intervalMs: intervalInfo.intervalMs,
    range: range,
    scopedVars: {},
    timezone: 'UTC',
    app,
    startTime: Date.now()
  };
}

class LokiDatasource extends _grafana_runtime__WEBPACK_IMPORTED_MODULE_3__.DataSourceWithBackend {
  constructor(instanceSettings, templateSrv = (0,app_features_templating_template_srv__WEBPACK_IMPORTED_MODULE_7__.getTemplateSrv)(), timeSrv = (0,app_features_dashboard_services_TimeSrv__WEBPACK_IMPORTED_MODULE_6__.getTimeSrv)()) {
    var _settingsData$maxLine;

    super(instanceSettings);
    this.instanceSettings = instanceSettings;
    this.templateSrv = templateSrv;
    this.timeSrv = timeSrv;

    _defineProperty(this, "streams", new _live_streams__WEBPACK_IMPORTED_MODULE_15__.LiveStreams());

    _defineProperty(this, "languageProvider", void 0);

    _defineProperty(this, "maxLines", void 0);

    _defineProperty(this, "runInstantQuery", (target, options, responseListLength = 1) => {
      const timeNs = this.getTime(options.range.to, true);
      const queryLimit = isMetricsQuery(target.expr) ? options.maxDataPoints : target.maxLines;
      const query = {
        query: target.expr,
        time: `${timeNs + (1e9 - timeNs % 1e9)}`,
        limit: Math.min(queryLimit || Infinity, this.maxLines),
        direction: target.direction === _types__WEBPACK_IMPORTED_MODULE_21__.LokiQueryDirection.Forward ? 'FORWARD' : 'BACKWARD'
      };
      /** Used only for results of metrics instant queries */

      const meta = {
        preferredVisualisationType: 'table'
      };
      return this._request(INSTANT_QUERY_ENDPOINT, query).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_22__.map)(response => {
        if (response.data.data.resultType === _types__WEBPACK_IMPORTED_MODULE_21__.LokiResultType.Stream) {
          return {
            data: response.data ? (0,_result_transformer__WEBPACK_IMPORTED_MODULE_17__.lokiStreamsToDataFrames)(response.data, target, query.limit, this.instanceSettings.jsonData) : [],
            key: `${target.refId}_instant`
          };
        }

        return {
          data: [(0,_result_transformer__WEBPACK_IMPORTED_MODULE_17__.lokiResultsToTableModel)(response.data.data.result, responseListLength, target.refId, meta)],
          key: `${target.refId}_instant`
        };
      }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_23__.catchError)(err => (0,rxjs__WEBPACK_IMPORTED_MODULE_24__.throwError)(() => this.processError(err, target))));
    });

    _defineProperty(this, "runRangeQuery", (target, options) => {
      // For metric query we use maxDataPoints from the request options which should be something like width of the
      // visualisation in pixels. In case of logs request we either use lines limit defined in the query target or
      // global limit defined for the data source which ever is lower.
      let maxDataPoints = isMetricsQuery(target.expr) ? // We fallback to maxLines here because maxDataPoints is defined as possibly undefined. Not sure that can
      // actually happen both Dashboards and Explore should send some value here. If not maxLines does not make that
      // much sense but nor any other arbitrary value.
      options.maxDataPoints || this.maxLines : // If user wants maxLines 0 we still fallback to data source limit. I think that makes sense as why would anyone
      // want to do a query and not see any results?
      target.maxLines || this.maxLines;

      if (options.liveStreaming) {
        return this.runLiveQuery(target, maxDataPoints);
      }

      const query = this.createRangeQuery(target, options, maxDataPoints);
      const headers = target.volumeQuery ? {
        'X-Query-Tags': 'Source=logvolhist'
      } : undefined;
      return this._request(RANGE_QUERY_ENDPOINT, query, {
        headers
      }).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_23__.catchError)(err => (0,rxjs__WEBPACK_IMPORTED_MODULE_24__.throwError)(() => this.processError(err, target))), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_25__.switchMap)(response => (0,_result_transformer__WEBPACK_IMPORTED_MODULE_17__.processRangeQueryResponse)(response.data, target, query, maxDataPoints, this.instanceSettings.jsonData, options.scopedVars)));
    });

    _defineProperty(this, "runLiveQuery", (target, maxDataPoints) => {
      const liveTarget = this.createLiveTarget(target, maxDataPoints);
      return this.streams.getStream(liveTarget).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_22__.map)(data => ({
        data: data || [],
        key: `loki-${liveTarget.refId}`,
        state: _grafana_data__WEBPACK_IMPORTED_MODULE_2__.LoadingState.Streaming
      })), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_23__.catchError)(err => {
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_24__.throwError)(() => `Live tailing was stopped due to following error: ${err.reason}`);
      }));
    });

    _defineProperty(this, "getLogRowContext", (row, options) => {
      const direction = options && options.direction || 'BACKWARD';
      const limit = options && options.limit || 10;
      const {
        query,
        range
      } = this.prepareLogRowContextQueryTarget(row, limit, direction);

      const processDataFrame = frame => {
        // log-row-context requires specific field-names to work, so we set them here: "ts", "line", "id"
        const cache = new _grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldCache(frame);
        const timestampField = cache.getFirstFieldOfType(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldType.time);
        const lineField = cache.getFirstFieldOfType(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldType.string);
        const idField = cache.getFieldByName('id');

        if (timestampField === undefined || lineField === undefined || idField === undefined) {
          // this should never really happen, but i want to keep typescript happy
          return Object.assign({}, frame, {
            fields: []
          });
        }

        return Object.assign({}, frame, {
          fields: [Object.assign({}, timestampField, {
            name: 'ts'
          }), Object.assign({}, lineField, {
            name: 'line'
          }), Object.assign({}, idField, {
            name: 'id'
          })]
        });
      };

      const processResults = result => {
        const frames = result.data;
        const processedFrames = frames.map(frame => (0,_sortDataFrame__WEBPACK_IMPORTED_MODULE_18__.sortDataFrameByTime)(frame, 'DESCENDING')).map(frame => processDataFrame(frame)); // rename fields if needed

        return Object.assign({}, result, {
          data: processedFrames
        });
      }; // this can only be called from explore currently


      const app = _grafana_data__WEBPACK_IMPORTED_MODULE_2__.CoreApp.Explore;
      return (0,rxjs__WEBPACK_IMPORTED_MODULE_26__.lastValueFrom)(this.query(makeRequest(query, range, app, `log-row-context-query-${direction}`)).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_23__.catchError)(err => {
        const error = {
          message: 'Error during context query. Please check JS console logs.',
          status: err.status,
          statusText: err.statusText
        };
        throw error;
      }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_25__.switchMap)(res => (0,rxjs__WEBPACK_IMPORTED_MODULE_27__.of)(processResults(res)))));
    });

    _defineProperty(this, "prepareLogRowContextQueryTarget", (row, limit, direction) => {
      const labels = this.languageProvider.getLabelKeys();
      const expr = Object.keys(row.labels).map(label => {
        if (labels.includes(label)) {
          // escape backslashes in label as users can't escape them by themselves
          return `${label}="${row.labels[label].replace(/\\/g, '\\\\')}"`;
        }

        return '';
      }) // Filter empty strings
      .filter(label => !!label).join(',');
      const contextTimeBuffer = 2 * 60 * 60 * 1000; // 2h buffer

      const queryDirection = direction === 'FORWARD' ? _types__WEBPACK_IMPORTED_MODULE_21__.LokiQueryDirection.Forward : _types__WEBPACK_IMPORTED_MODULE_21__.LokiQueryDirection.Backward;
      const query = {
        expr: `{${expr}}`,
        queryType: _types__WEBPACK_IMPORTED_MODULE_21__.LokiQueryType.Range,
        refId: '',
        maxLines: limit,
        direction: queryDirection
      };
      const fieldCache = new _grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldCache(row.dataFrame);
      const tsField = fieldCache.getFirstFieldOfType(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldType.time);

      if (tsField === undefined) {
        throw new Error('loki: dataframe missing time-field, should never happen');
      }

      const tsValue = tsField.values.get(row.rowIndex);
      const timestamp = (0,_grafana_data__WEBPACK_IMPORTED_MODULE_2__.toUtc)(tsValue);
      const range = queryDirection === _types__WEBPACK_IMPORTED_MODULE_21__.LokiQueryDirection.Forward ? {
        // start param in Loki API is inclusive so we'll have to filter out the row that this request is based from
        // and any other that were logged in the same ns but before the row. Right now these rows will be lost
        // because the are before but came it he response that should return only rows after.
        from: timestamp,
        // convert to ns, we loose some precision here but it is not that important at the far points of the context
        to: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_2__.toUtc)(row.timeEpochMs + contextTimeBuffer)
      } : {
        // convert to ns, we loose some precision here but it is not that important at the far points of the context
        from: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_2__.toUtc)(row.timeEpochMs - contextTimeBuffer),
        to: timestamp
      };
      return {
        query,
        range: {
          from: range.from,
          to: range.to,
          raw: range
        }
      };
    });

    this.instanceSettings = instanceSettings;
    this.templateSrv = templateSrv;
    this.timeSrv = timeSrv;
    this.languageProvider = new _language_provider__WEBPACK_IMPORTED_MODULE_13__["default"](this);
    const settingsData = instanceSettings.jsonData || {};
    this.maxLines = parseInt((_settingsData$maxLine = settingsData.maxLines) !== null && _settingsData$maxLine !== void 0 ? _settingsData$maxLine : '0', 10) || DEFAULT_MAX_LINES;
  }

  _request(apiUrl, data, options) {
    const baseUrl = this.instanceSettings.url;
    const params = data ? (0,_core_utils_fetch__WEBPACK_IMPORTED_MODULE_8__.serializeParams)(data) : '';
    const url = `${baseUrl}${apiUrl}${params.length ? `?${params}` : ''}`;

    if (this.instanceSettings.withCredentials || this.instanceSettings.basicAuth) {
      options = Object.assign({}, options, {
        withCredentials: true
      });

      if (this.instanceSettings.basicAuth) {
        options.headers = Object.assign({}, options.headers, {
          Authorization: this.instanceSettings.basicAuth
        });
      }
    }

    const req = Object.assign({}, options, {
      url
    });
    return (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_3__.getBackendSrv)().fetch(req);
  }

  getLogsVolumeDataProvider(request) {
    const isLogsVolumeAvailable = request.targets.some(target => target.expr && !isMetricsQuery(target.expr));

    if (!isLogsVolumeAvailable) {
      return undefined;
    }

    const logsVolumeRequest = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.cloneDeep)(request);
    logsVolumeRequest.targets = logsVolumeRequest.targets.filter(target => target.expr && !isMetricsQuery(target.expr)).map(target => {
      return Object.assign({}, target, {
        instant: false,
        volumeQuery: true,
        expr: `sum by (level) (count_over_time(${target.expr}[$__interval]))`
      });
    });
    return (0,app_core_logs_model__WEBPACK_IMPORTED_MODULE_4__.queryLogsVolume)(this, logsVolumeRequest, {
      extractLevel,
      range: request.range,
      targets: request.targets
    });
  }

  query(request) {
    const subQueries = [];
    const scopedVars = Object.assign({}, request.scopedVars, this.getRangeScopedVars(request.range));

    if (_grafana_runtime__WEBPACK_IMPORTED_MODULE_3__.config.featureToggles.lokiBackendMode) {
      // we "fix" the loki queries to have `.queryType` and not have `.instant` and `.range`
      const fixedRequest = Object.assign({}, request, {
        targets: request.targets.map(_query_utils__WEBPACK_IMPORTED_MODULE_16__.getNormalizedLokiQuery)
      });

      if (fixedRequest.liveStreaming) {
        return this.runLiveQueryThroughBackend(fixedRequest);
      } else {
        return super.query(fixedRequest).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_22__.map)(response => {
          var _this$instanceSetting;

          return (0,_backendResultTransformer__WEBPACK_IMPORTED_MODULE_11__.transformBackendResult)(response, fixedRequest.targets, (_this$instanceSetting = this.instanceSettings.jsonData.derivedFields) !== null && _this$instanceSetting !== void 0 ? _this$instanceSetting : []);
        }));
      }
    }

    const filteredTargets = request.targets.filter(target => target.expr && !target.hide).map(target => {
      const expr = this.addAdHocFilters(target.expr);
      return Object.assign({}, target, {
        expr: this.templateSrv.replace(expr, scopedVars, this.interpolateQueryExpr)
      });
    });

    for (const target of filteredTargets) {
      var _request$rangeRaw;

      if (target.instant || target.queryType === _types__WEBPACK_IMPORTED_MODULE_21__.LokiQueryType.Instant) {
        subQueries.push(this.runInstantQuery(target, request, filteredTargets.length));
      } else if (_grafana_runtime__WEBPACK_IMPORTED_MODULE_3__.config.featureToggles.lokiLive && target.queryType === _types__WEBPACK_IMPORTED_MODULE_21__.LokiQueryType.Stream && ((_request$rangeRaw = request.rangeRaw) === null || _request$rangeRaw === void 0 ? void 0 : _request$rangeRaw.to) === 'now') {
        subQueries.push((0,_streaming__WEBPACK_IMPORTED_MODULE_19__.doLokiChannelStream)(target, this, request));
      } else {
        subQueries.push(this.runRangeQuery(target, request));
      }
    } // No valid targets, return the empty result to save a round trip.


    if ((0,lodash__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(subQueries)) {
      return (0,rxjs__WEBPACK_IMPORTED_MODULE_27__.of)({
        data: [],
        state: _grafana_data__WEBPACK_IMPORTED_MODULE_2__.LoadingState.Done
      });
    }

    return (0,rxjs__WEBPACK_IMPORTED_MODULE_28__.merge)(...subQueries);
  }

  runLiveQueryThroughBackend(request) {
    // this only works in explore-mode, so variables don't need to be handled,
    //  and only for logs-queries, not metric queries
    const logsQueries = request.targets.filter(query => query.expr !== '' && !isMetricsQuery(query.expr));

    if (logsQueries.length === 0) {
      return (0,rxjs__WEBPACK_IMPORTED_MODULE_27__.of)({
        data: [],
        state: _grafana_data__WEBPACK_IMPORTED_MODULE_2__.LoadingState.Done
      });
    }

    const subQueries = logsQueries.map(query => {
      const maxDataPoints = query.maxLines || this.maxLines; // FIXME: currently we are running it through the frontend still.

      return this.runLiveQuery(query, maxDataPoints);
    });
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_28__.merge)(...subQueries);
  }

  createRangeQuery(target, options, limit) {
    const query = target.expr;
    let range = {};

    if (options.range) {
      const startNs = this.getTime(options.range.from, false);
      const endNs = this.getTime(options.range.to, true);
      const rangeMs = Math.ceil((endNs - startNs) / 1e6);
      const resolution = target.resolution || _components_LokiOptionFields__WEBPACK_IMPORTED_MODULE_12__.DEFAULT_RESOLUTION.value;
      const adjustedInterval = this.adjustInterval(options.intervalMs || 1000, resolution, rangeMs) / 1000; // We want to ceil to 3 decimal places

      const step = Math.ceil(adjustedInterval * 1000) / 1000;
      range = {
        start: startNs,
        end: endNs,
        step
      };
    }

    return Object.assign({}, DEFAULT_QUERY_PARAMS, range, {
      query,
      limit,
      direction: target.direction === _types__WEBPACK_IMPORTED_MODULE_21__.LokiQueryDirection.Forward ? 'FORWARD' : 'BACKWARD'
    });
  }
  /**
   * Attempts to send a query to /loki/api/v1/query_range
   */


  createLiveTarget(target, maxDataPoints) {
    const query = target.expr;
    const baseUrl = this.instanceSettings.url;
    const params = (0,_core_utils_fetch__WEBPACK_IMPORTED_MODULE_8__.serializeParams)({
      query
    });
    return {
      query,
      url: (0,app_core_utils_explore__WEBPACK_IMPORTED_MODULE_5__.convertToWebSocketUrl)(`${baseUrl}/loki/api/v1/tail?${params}`),
      refId: target.refId,
      size: maxDataPoints
    };
  }
  /**
   * Runs live queries which in this case means creating a websocket and listening on it for new logs.
   * This returns a bit different dataFrame than runQueries as it returns single dataframe even if there are multiple
   * Loki streams, sets only common labels on dataframe.labels and has additional dataframe.fields.labels for unique
   * labels per row.
   */


  getRangeScopedVars(range = this.timeSrv.timeRange()) {
    const msRange = range.to.diff(range.from);
    const sRange = Math.round(msRange / 1000);
    return {
      __range_ms: {
        text: msRange,
        value: msRange
      },
      __range_s: {
        text: sRange,
        value: sRange
      },
      __range: {
        text: sRange + 's',
        value: sRange + 's'
      }
    };
  }

  interpolateVariablesInQueries(queries, scopedVars) {
    let expandedQueries = queries;

    if (queries && queries.length) {
      expandedQueries = queries.map(query => Object.assign({}, query, {
        datasource: this.getRef(),
        expr: this.templateSrv.replace(query.expr, scopedVars, this.interpolateQueryExpr)
      }));
    }

    return expandedQueries;
  }

  getQueryDisplayText(query) {
    return query.expr;
  }

  getTimeRangeParams() {
    const timeRange = this.timeSrv.timeRange();
    return {
      start: timeRange.from.valueOf() * NS_IN_MS,
      end: timeRange.to.valueOf() * NS_IN_MS
    };
  }

  async importFromAbstractQueries(abstractQueries) {
    await this.languageProvider.start();
    const existingKeys = this.languageProvider.labelKeys;

    if (existingKeys && existingKeys.length) {
      abstractQueries = abstractQueries.map(abstractQuery => {
        abstractQuery.labelMatchers = abstractQuery.labelMatchers.filter(labelMatcher => {
          return existingKeys.includes(labelMatcher.name);
        });
        return abstractQuery;
      });
    }

    return abstractQueries.map(abstractQuery => this.languageProvider.importFromAbstractQuery(abstractQuery));
  }

  async exportToAbstractQueries(queries) {
    return queries.map(query => this.languageProvider.exportToAbstractQuery(query));
  }

  async metadataRequest(url, params) {
    // url must not start with a `/`, otherwise the AJAX-request
    // going from the browser will contain `//`, which can cause problems.
    if (url.startsWith('/')) {
      throw new Error(`invalid metadata request url: ${url}`);
    }

    const res = await this.getResource(url, params);
    return res.data || [];
  }

  async metricFindQuery(query) {
    if (!query) {
      return Promise.resolve([]);
    }

    const interpolated = this.templateSrv.replace(query, {}, this.interpolateQueryExpr);
    return await this.processMetricFindQuery(interpolated);
  }

  async processMetricFindQuery(query) {
    const labelNamesRegex = /^label_names\(\)\s*$/;
    const labelValuesRegex = /^label_values\((?:(.+),\s*)?([a-zA-Z_][a-zA-Z0-9_]*)\)\s*$/;
    const labelNames = query.match(labelNamesRegex);

    if (labelNames) {
      return await this.labelNamesQuery();
    }

    const labelValues = query.match(labelValuesRegex);

    if (labelValues) {
      // If we have query expr, use /series endpoint
      if (labelValues[1]) {
        return await this.labelValuesSeriesQuery(labelValues[1], labelValues[2]);
      }

      return await this.labelValuesQuery(labelValues[2]);
    }

    return Promise.resolve([]);
  }

  async labelNamesQuery() {
    const url = 'labels';
    const params = this.getTimeRangeParams();
    const result = await this.metadataRequest(url, params);
    return result.map(value => ({
      text: value
    }));
  }

  async labelValuesQuery(label) {
    const params = this.getTimeRangeParams();
    const url = `label/${label}/values`;
    const result = await this.metadataRequest(url, params);
    return result.map(value => ({
      text: value
    }));
  }

  async labelValuesSeriesQuery(expr, label) {
    const timeParams = this.getTimeRangeParams();
    const params = Object.assign({}, timeParams, {
      'match[]': expr
    });
    const url = 'series';
    const streams = new Set();
    const result = await this.metadataRequest(url, params);
    result.forEach(stream => {
      if (stream[label]) {
        streams.add({
          text: stream[label]
        });
      }
    });
    return Array.from(streams);
  } // By implementing getTagKeys and getTagValues we add ad-hoc filtters functionality


  async getTagKeys() {
    return await this.labelNamesQuery();
  }

  async getTagValues(options = {}) {
    return await this.labelValuesQuery(options.key);
  }

  interpolateQueryExpr(value, variable) {
    // if no multi or include all do not regexEscape
    if (!variable.multi && !variable.includeAll) {
      return lokiRegularEscape(value);
    }

    if (typeof value === 'string') {
      return lokiSpecialRegexEscape(value);
    }

    const escapedValues = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.map)(value, lokiSpecialRegexEscape);
    return escapedValues.join('|');
  }

  modifyQuery(query, action) {
    var _query$expr;

    let expression = (_query$expr = query.expr) !== null && _query$expr !== void 0 ? _query$expr : '';

    switch (action.type) {
      case 'ADD_FILTER':
        {
          expression = this.addLabelToQuery(expression, action.key, action.value, '=');
          break;
        }

      case 'ADD_FILTER_OUT':
        {
          expression = this.addLabelToQuery(expression, action.key, action.value, '!=');
          break;
        }

      default:
        break;
    }

    return Object.assign({}, query, {
      expr: expression
    });
  }

  getTime(date, roundUp) {
    if (typeof date === 'string') {
      date = _grafana_data__WEBPACK_IMPORTED_MODULE_2__.dateMath.parse(date, roundUp);
    }

    return Math.ceil(date.valueOf() * 1e6);
  }

  testDatasource() {
    // Consider only last 10 minutes otherwise request takes too long
    const nowMs = Date.now();
    const params = {
      start: (nowMs - 10 * 60 * 1000) * NS_IN_MS,
      end: nowMs * NS_IN_MS
    };
    return this.metadataRequest('labels', params).then(values => {
      return values.length > 0 ? {
        status: 'success',
        message: 'Data source connected and labels found.'
      } : {
        status: 'error',
        message: 'Data source connected, but no labels received. Verify that Loki and Promtail is configured properly.'
      };
    }, err => {
      var _err$data$message, _err$data;

      // we did a resource-call that failed.
      // the only info we have, if exists, is err.data.message
      // (when in development-mode, err.data.error exists too, but not in production-mode)
      // things like err.status & err.statusText does not help,
      // because those will only describe how the request between browser<>server failed
      const info = (_err$data$message = err === null || err === void 0 ? void 0 : (_err$data = err.data) === null || _err$data === void 0 ? void 0 : _err$data.message) !== null && _err$data$message !== void 0 ? _err$data$message : '';
      const infoInParentheses = info !== '' ? ` (${info})` : '';
      const message = `Unable to fetch labels from Loki${infoInParentheses}, please check the server logs for more details`;
      return {
        status: 'error',
        message: message
      };
    });
  }

  async annotationQuery(options) {
    const {
      expr,
      maxLines,
      instant,
      tagKeys = '',
      titleFormat = '',
      textFormat = ''
    } = options.annotation;

    if (!expr) {
      return [];
    }

    const id = `annotation-${options.annotation.name}`;
    const query = {
      refId: id,
      expr,
      maxLines,
      instant,
      queryType: instant ? _types__WEBPACK_IMPORTED_MODULE_21__.LokiQueryType.Instant : _types__WEBPACK_IMPORTED_MODULE_21__.LokiQueryType.Range
    };
    const request = makeRequest(query, options.range, _grafana_data__WEBPACK_IMPORTED_MODULE_2__.CoreApp.Dashboard, id);
    const {
      data
    } = await (0,rxjs__WEBPACK_IMPORTED_MODULE_26__.lastValueFrom)(this.query(request));
    const annotations = [];
    const splitKeys = tagKeys.split(',').filter(v => v !== '');

    for (const frame of data) {
      const view = new _grafana_data__WEBPACK_IMPORTED_MODULE_2__.DataFrameView(frame);
      view.forEach(row => {
        const {
          labels
        } = row;
        const maybeDuplicatedTags = Object.entries(labels).map(([key, val]) => [key, val.trim()]) // trim all label-values
        .filter(([key, val]) => {
          if (val === '') {
            // remove empty
            return false;
          } // if tags are specified, remove label if does not match tags


          if (splitKeys.length && !splitKeys.includes(key)) {
            return false;
          }

          return true;
        }).map(([key, val]) => val); // keep only the label-value
        // remove duplicates

        const tags = Array.from(new Set(maybeDuplicatedTags));
        annotations.push({
          time: new Date(row.ts).valueOf(),
          title: (0,_prometheus_legend__WEBPACK_IMPORTED_MODULE_9__.renderLegendFormat)(titleFormat, labels),
          text: (0,_prometheus_legend__WEBPACK_IMPORTED_MODULE_9__.renderLegendFormat)(textFormat, labels) || row.line,
          tags
        });
      });
    }

    return annotations;
  }

  showContextToggle(row) {
    return (row && row.searchWords && row.searchWords.length > 0) === true;
  }

  processError(err, target) {
    let error = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.cloneDeep)(err);
    error.refId = target.refId;

    if (error.data && err.data.message.includes('escape') && target.expr.includes('\\')) {
      error.data.message = `Error: ${err.data.message}. Make sure that all special characters are escaped with \\. For more information on escaping of special characters visit LogQL documentation at https://grafana.com/docs/loki/latest/logql/.`;
    }

    return error;
  }

  adjustInterval(dynamicInterval, resolution, range) {
    // Loki will drop queries that might return more than 11000 data points.
    // Calibrate interval if it is too small.
    let safeInterval = range / 11000;

    if (safeInterval > 1) {
      safeInterval = Math.ceil(safeInterval);
    }

    let adjustedInterval = Math.max(resolution * dynamicInterval, safeInterval);
    return adjustedInterval;
  }

  addAdHocFilters(queryExpr) {
    const adhocFilters = this.templateSrv.getAdhocFilters(this.name);
    let expr = queryExpr;
    expr = adhocFilters.reduce((acc, filter) => {
      const {
        key,
        operator
      } = filter;
      let {
        value
      } = filter;
      return this.addLabelToQuery(acc, key, value, operator, true);
    }, expr);
    return expr;
  }

  addLabelToQuery(queryExpr, key, value, operator, // Override to make sure that we use label as actual label and not parsed label
  notParsedLabelOverride) {
    let escapedValue = (0,_language_utils__WEBPACK_IMPORTED_MODULE_14__.escapeLabelValueInSelector)(value.toString(), operator);

    if ((0,_query_utils__WEBPACK_IMPORTED_MODULE_16__.queryHasPipeParser)(queryExpr) && !isMetricsQuery(queryExpr) && !notParsedLabelOverride) {
      // If query has parser, we treat all labels as parsed and use | key="value" syntax
      return (0,_query_utils__WEBPACK_IMPORTED_MODULE_16__.addParsedLabelToQuery)(queryExpr, key, escapedValue, operator);
    } else {
      return (0,_add_label_to_query__WEBPACK_IMPORTED_MODULE_10__.addLabelToQuery)(queryExpr, key, escapedValue, operator, true);
    }
  } // Used when running queries through backend


  filterQuery(query) {
    if (query.hide || query.expr === '') {
      return false;
    }

    return true;
  } // Used when running queries through backend


  applyTemplateVariables(target, scopedVars) {
    // We want to interpolate these variables on backend
    const rest = _objectWithoutPropertiesLoose(scopedVars, _excluded);

    return Object.assign({}, target, {
      legendFormat: this.templateSrv.replace(target.legendFormat, rest),
      expr: this.templateSrv.replace(target.expr, rest, this.interpolateQueryExpr)
    });
  }

  interpolateString(string) {
    return this.templateSrv.replace(string, undefined, this.interpolateQueryExpr);
  }

  getVariables() {
    return this.templateSrv.getVariables().map(v => `$${v.name}`);
  }

}
function lokiRegularEscape(value) {
  if (typeof value === 'string') {
    return value.replace(/'/g, "\\\\'");
  }

  return value;
}
function lokiSpecialRegexEscape(value) {
  if (typeof value === 'string') {
    return lokiRegularEscape(value.replace(/\\/g, '\\\\\\\\').replace(/[$^*{}\[\]+?.()|]/g, '\\\\$&'));
  }

  return value;
}
/**
 * Checks if the query expression uses function and so should return a time series instead of logs.
 * Sometimes important to know that before we actually do the query.
 */

function isMetricsQuery(query) {
  if (!query) {
    return false;
  }

  const tokens = prismjs__WEBPACK_IMPORTED_MODULE_1___default().tokenize(query, _syntax__WEBPACK_IMPORTED_MODULE_20__["default"]);
  return tokens.some(t => {
    // Not sure in which cases it can be string maybe if nothing matched which means it should not be a function
    return typeof t !== 'string' && t.type === 'function';
  });
}

function extractLevel(dataFrame) {
  var _valueField;

  let valueField;

  try {
    valueField = new _grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldCache(dataFrame).getFirstFieldOfType(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldType.number);
  } catch {}

  return (_valueField = valueField) !== null && _valueField !== void 0 && _valueField.labels ? getLogLevelFromLabels(valueField.labels) : _grafana_data__WEBPACK_IMPORTED_MODULE_2__.LogLevel.unknown;
}

function getLogLevelFromLabels(labels) {
  const labelNames = ['level', 'lvl', 'loglevel'];
  let levelLabel;

  for (let labelName of labelNames) {
    if (labelName in labels) {
      levelLabel = labelName;
      break;
    }
  }

  return levelLabel ? (0,_grafana_data__WEBPACK_IMPORTED_MODULE_2__.getLogLevelFromKey)(labels[levelLabel]) : _grafana_data__WEBPACK_IMPORTED_MODULE_2__.LogLevel.unknown;
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/getDerivedFields.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getDerivedFields": () => (/* binding */ getDerivedFields)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");



function getDerivedFields(dataFrame, derivedFieldConfigs) {
  if (!derivedFieldConfigs.length) {
    return [];
  }

  const derivedFieldsGrouped = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.groupBy)(derivedFieldConfigs, 'name');
  const newFields = Object.values(derivedFieldsGrouped).map(fieldFromDerivedFieldConfig); // line-field is the first string-field
  // NOTE: we should create some common log-frame-extra-string-field code somewhere

  const lineField = dataFrame.fields.find(f => f.type === _grafana_data__WEBPACK_IMPORTED_MODULE_1__.FieldType.string);

  if (lineField === undefined) {
    // if this is happening, something went wrong, let's raise an error
    throw new Error('invalid logs-dataframe, string-field missing');
  }

  lineField.values.toArray().forEach(line => {
    for (const field of newFields) {
      const logMatch = line.match(derivedFieldsGrouped[field.name][0].matcherRegex);
      field.values.add(logMatch && logMatch[1]);
    }
  });
  return newFields;
}
/**
 * Transform derivedField config into dataframe field with config that contains link.
 */

function fieldFromDerivedFieldConfig(derivedFieldConfigs) {
  const dataSourceSrv = (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_2__.getDataSourceSrv)();
  const dataLinks = derivedFieldConfigs.reduce((acc, derivedFieldConfig) => {
    // Having field.datasourceUid means it is an internal link.
    if (derivedFieldConfig.datasourceUid) {
      var _dsSettings$name;

      const dsSettings = dataSourceSrv.getInstanceSettings(derivedFieldConfig.datasourceUid);
      acc.push({
        // Will be filled out later
        title: derivedFieldConfig.urlDisplayLabel || '',
        url: '',
        // This is hardcoded for Jaeger or Zipkin not way right now to specify datasource specific query object
        internal: {
          query: {
            query: derivedFieldConfig.url
          },
          datasourceUid: derivedFieldConfig.datasourceUid,
          datasourceName: (_dsSettings$name = dsSettings === null || dsSettings === void 0 ? void 0 : dsSettings.name) !== null && _dsSettings$name !== void 0 ? _dsSettings$name : 'Data source not found'
        }
      });
    } else if (derivedFieldConfig.url) {
      acc.push({
        // We do not know what title to give here so we count on presentation layer to create a title from metadata.
        title: derivedFieldConfig.urlDisplayLabel || '',
        // This is hardcoded for Jaeger or Zipkin not way right now to specify datasource specific query object
        url: derivedFieldConfig.url
      });
    }

    return acc;
  }, []);
  return {
    name: derivedFieldConfigs[0].name,
    type: _grafana_data__WEBPACK_IMPORTED_MODULE_1__.FieldType.string,
    config: {
      links: dataLinks
    },
    // We are adding values later on
    values: new _grafana_data__WEBPACK_IMPORTED_MODULE_1__.ArrayVector([])
  };
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/language_provider.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LABEL_REFRESH_INTERVAL": () => (/* binding */ LABEL_REFRESH_INTERVAL),
/* harmony export */   "addHistoryMetadata": () => (/* binding */ addHistoryMetadata),
/* harmony export */   "default": () => (/* binding */ LokiLanguageProvider)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/lru-cache-npm-7.9.0-d803108233-c91a293a10.zip/node_modules/lru-cache/index.js");
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lru_cache__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/prismjs-npm-1.27.0-ca4e1667c6-85c7f4a3e9.zip/node_modules/prismjs/prism.js");
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prismjs__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var app_plugins_datasource_prometheus_language_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/language_utils.ts");
/* harmony import */ var _syntax__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/loki/syntax.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/loki/types.ts");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








const DEFAULT_KEYS = ['job', 'namespace'];
const EMPTY_SELECTOR = '{}';
const HISTORY_ITEM_COUNT = 10;
const HISTORY_COUNT_CUTOFF = 1000 * 60 * 60 * 24; // 24h

const NS_IN_MS = 1000000; // When changing RATE_RANGES, check if Prometheus/PromQL ranges should be changed too
// @see public/app/plugins/datasource/prometheus/promql.ts

const RATE_RANGES = [{
  label: '$__interval',
  sortValue: '$__interval'
}, {
  label: '$__range',
  sortValue: '$__range'
}, {
  label: '1m',
  sortValue: '00:01:00'
}, {
  label: '5m',
  sortValue: '00:05:00'
}, {
  label: '10m',
  sortValue: '00:10:00'
}, {
  label: '30m',
  sortValue: '00:30:00'
}, {
  label: '1h',
  sortValue: '01:00:00'
}, {
  label: '1d',
  sortValue: '24:00:00'
}];
const LABEL_REFRESH_INTERVAL = 1000 * 30; // 30sec

const wrapLabel = label => ({
  label,
  filterText: `\"${label}\"`
});

function addHistoryMetadata(item, history) {
  const cutoffTs = Date.now() - HISTORY_COUNT_CUTOFF;
  const historyForItem = history.filter(h => h.ts > cutoffTs && h.query.expr === item.label);
  let hint = `Queried ${historyForItem.length} times in the last 24h.`;
  const recent = historyForItem[0];

  if (recent) {
    const lastQueried = (0,_grafana_data__WEBPACK_IMPORTED_MODULE_3__.dateTime)(recent.ts).fromNow();
    hint = `${hint} Last queried ${lastQueried}.`;
  }

  return Object.assign({}, item, {
    documentation: hint
  });
}
class LokiLanguageProvider extends _grafana_data__WEBPACK_IMPORTED_MODULE_3__.LanguageProvider {
  // Dynamically set to true for big/slow instances

  /**
   *  Cache for labels of series. This is bit simplistic in the sense that it just counts responses each as a 1 and does
   *  not account for different size of a response. If that is needed a `length` function can be added in the options.
   *  10 as a max size is totally arbitrary right now.
   */
  constructor(datasource, initialValues) {
    super();

    _defineProperty(this, "labelKeys", void 0);

    _defineProperty(this, "labelFetchTs", void 0);

    _defineProperty(this, "started", false);

    _defineProperty(this, "datasource", void 0);

    _defineProperty(this, "lookupsDisabled", false);

    _defineProperty(this, "seriesCache", new (lru_cache__WEBPACK_IMPORTED_MODULE_1___default())({
      max: 10
    }));

    _defineProperty(this, "labelsCache", new (lru_cache__WEBPACK_IMPORTED_MODULE_1___default())({
      max: 10
    }));

    _defineProperty(this, "cleanText", s => s.replace(/[{}[\]="(),!~+\-*/^%\|]/g, '').trim());

    _defineProperty(this, "request", async (url, params) => {
      try {
        return await this.datasource.metadataRequest(url, params);
      } catch (error) {
        console.error(error);
      }

      return undefined;
    });

    _defineProperty(this, "start", () => {
      if (!this.startTask) {
        this.startTask = this.fetchLabels().then(() => {
          this.started = true;
          return [];
        });
      }

      return this.startTask;
    });

    _defineProperty(this, "getBeginningCompletionItems", context => {
      return {
        suggestions: [...this.getEmptyCompletionItems(context).suggestions, ...this.getTermCompletionItems().suggestions]
      };
    });

    _defineProperty(this, "getTermCompletionItems", () => {
      const suggestions = [];
      suggestions.push({
        prefixMatch: true,
        label: 'Functions',
        items: _syntax__WEBPACK_IMPORTED_MODULE_5__.FUNCTIONS.map(suggestion => Object.assign({}, suggestion, {
          kind: 'function'
        }))
      });
      return {
        suggestions
      };
    });

    _defineProperty(this, "getPipeCompletionItem", () => {
      const suggestions = [];
      suggestions.push({
        label: 'Operators',
        items: _syntax__WEBPACK_IMPORTED_MODULE_5__.PIPE_OPERATORS.map(suggestion => Object.assign({}, suggestion, {
          kind: 'operators'
        }))
      });
      suggestions.push({
        label: 'Parsers',
        items: _syntax__WEBPACK_IMPORTED_MODULE_5__.PIPE_PARSERS.map(suggestion => Object.assign({}, suggestion, {
          kind: 'parsers'
        }))
      });
      return {
        suggestions
      };
    });

    _defineProperty(this, "fetchSeriesLabels", async match => {
      const interpolatedMatch = this.datasource.interpolateString(match);
      const url = 'series';
      const {
        start,
        end
      } = this.datasource.getTimeRangeParams();
      const cacheKey = this.generateCacheKey(url, start, end, interpolatedMatch);
      let value = this.seriesCache.get(cacheKey);

      if (!value) {
        // Clear value when requesting new one. Empty object being truthy also makes sure we don't request twice.
        this.seriesCache.set(cacheKey, {});
        const params = {
          'match[]': interpolatedMatch,
          start,
          end
        };
        const data = await this.request(url, params);
        const {
          values
        } = (0,app_plugins_datasource_prometheus_language_utils__WEBPACK_IMPORTED_MODULE_4__.processLabels)(data);
        value = values;
        this.seriesCache.set(cacheKey, value);
      }

      return value;
    });

    _defineProperty(this, "fetchSeries", async match => {
      const url = 'series';
      const {
        start,
        end
      } = this.datasource.getTimeRangeParams();
      const params = {
        'match[]': match,
        start,
        end
      };
      return await this.request(url, params);
    });

    this.datasource = datasource;
    this.labelKeys = [];
    this.labelFetchTs = 0;
    Object.assign(this, initialValues);
  } // Strip syntax chars


  getSyntax() {
    return _syntax__WEBPACK_IMPORTED_MODULE_5__["default"];
  }

  getLabelKeys() {
    return this.labelKeys;
  }
  /**
   * Return suggestions based on input that can be then plugged into a typeahead dropdown.
   * Keep this DOM-free for testing
   * @param input
   * @param context Is optional in types but is required in case we are doing getLabelCompletionItems
   * @param context.absoluteRange Required in case we are doing getLabelCompletionItems
   * @param context.history Optional used only in getEmptyCompletionItems
   */


  async provideCompletionItems(input, context) {
    const {
      wrapperClasses,
      value,
      prefix,
      text
    } = input;
    const emptyResult = {
      suggestions: []
    };

    if (!value) {
      return emptyResult;
    } // Local text properties


    const empty = (value === null || value === void 0 ? void 0 : value.document.text.length) === 0;
    const selectedLines = value.document.getTextsAtRange(value.selection);
    const currentLine = selectedLines.size === 1 ? selectedLines.first().getText() : null;
    const nextCharacter = currentLine ? currentLine[value.selection.anchor.offset] : null; // Syntax spans have 3 classes by default. More indicate a recognized token

    const tokenRecognized = wrapperClasses.length > 3; // Non-empty prefix, but not inside known token

    const prefixUnrecognized = prefix && !tokenRecognized; // Prevent suggestions in `function(|suffix)`

    const noSuffix = !nextCharacter || nextCharacter === ')'; // Prefix is safe if it does not immediately follow a complete expression and has no text after it

    const safePrefix = prefix && !text.match(/^['"~=\]})\s]+$/) && noSuffix; // About to type next operand if preceded by binary operator

    const operatorsPattern = /[+\-*/^%]/;
    const isNextOperand = text.match(operatorsPattern); // Determine candidates by CSS context

    if (wrapperClasses.includes('context-range')) {
      // Suggestions for metric[|]
      return this.getRangeCompletionItems();
    } else if (wrapperClasses.includes('context-labels')) {
      // Suggestions for {|} and {foo=|}
      return await this.getLabelCompletionItems(input);
    } else if (wrapperClasses.includes('context-pipe')) {
      return this.getPipeCompletionItem();
    } else if (empty) {
      // Suggestions for empty query field
      return this.getEmptyCompletionItems(context);
    } else if (prefixUnrecognized && noSuffix && !isNextOperand) {
      // Show term suggestions in a couple of scenarios
      return this.getBeginningCompletionItems(context);
    } else if (prefixUnrecognized && safePrefix) {
      // Show term suggestions in a couple of scenarios
      return this.getTermCompletionItems();
    }

    return emptyResult;
  }

  getEmptyCompletionItems(context) {
    const history = context === null || context === void 0 ? void 0 : context.history;
    const suggestions = [];

    if (history !== null && history !== void 0 && history.length) {
      const historyItems = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.chain)(history).map(h => h.query.expr).filter().uniq().take(HISTORY_ITEM_COUNT).map(wrapLabel).map(item => addHistoryMetadata(item, history)).value();
      suggestions.push({
        prefixMatch: true,
        skipSort: true,
        label: 'History',
        items: historyItems
      });
    }

    return {
      suggestions
    };
  }

  getRangeCompletionItems() {
    return {
      context: 'context-range',
      suggestions: [{
        label: 'Range vector',
        items: [...RATE_RANGES]
      }]
    };
  }

  async getLabelCompletionItems({
    text,
    wrapperClasses,
    labelKey,
    value
  }) {
    let context = 'context-labels';
    const suggestions = [];

    if (!value) {
      return {
        context,
        suggestions: []
      };
    }

    const line = value.anchorBlock.getText();
    const cursorOffset = value.selection.anchor.offset;
    const isValueStart = text.match(/^(=|=~|!=|!~)/); // Get normalized selector

    let selector;
    let parsedSelector;

    try {
      parsedSelector = (0,app_plugins_datasource_prometheus_language_utils__WEBPACK_IMPORTED_MODULE_4__.parseSelector)(line, cursorOffset);
      selector = parsedSelector.selector;
    } catch {
      selector = EMPTY_SELECTOR;
    }

    if (!labelKey && selector === EMPTY_SELECTOR) {
      // start task gets all labels
      await this.start();
      const allLabels = this.getLabelKeys();
      return {
        context,
        suggestions: [{
          label: `Labels`,
          items: allLabels.map(wrapLabel)
        }]
      };
    }

    const existingKeys = parsedSelector ? parsedSelector.labelKeys : [];
    let labelValues; // Query labels for selector

    if (selector) {
      if (selector === EMPTY_SELECTOR && labelKey) {
        const labelValuesForKey = await this.getLabelValues(labelKey);
        labelValues = {
          [labelKey]: labelValuesForKey
        };
      } else {
        labelValues = await this.getSeriesLabels(selector);
      }
    }

    if (!labelValues) {
      console.warn(`Server did not return any values for selector = ${selector}`);
      return {
        context,
        suggestions
      };
    }

    if (text && isValueStart || wrapperClasses.includes('attr-value')) {
      // Label values
      if (labelKey && labelValues[labelKey]) {
        context = 'context-label-values';
        suggestions.push({
          label: `Label values for "${labelKey}"`,
          // Filter to prevent previously selected values from being repeatedly suggested
          items: labelValues[labelKey].map(wrapLabel).filter(({
            filterText
          }) => filterText !== text)
        });
      }
    } else {
      // Label keys
      const labelKeys = labelValues ? Object.keys(labelValues) : DEFAULT_KEYS;

      if (labelKeys) {
        const possibleKeys = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.difference)(labelKeys, existingKeys);

        if (possibleKeys.length) {
          const newItems = possibleKeys.map(key => ({
            label: key
          }));
          const newSuggestion = {
            label: `Labels`,
            items: newItems
          };
          suggestions.push(newSuggestion);
        }
      }
    }

    return {
      context,
      suggestions
    };
  }

  importFromAbstractQuery(labelBasedQuery) {
    return {
      refId: labelBasedQuery.refId,
      expr: (0,app_plugins_datasource_prometheus_language_utils__WEBPACK_IMPORTED_MODULE_4__.toPromLikeExpr)(labelBasedQuery),
      queryType: _types__WEBPACK_IMPORTED_MODULE_6__.LokiQueryType.Range
    };
  }

  exportToAbstractQuery(query) {
    const lokiQuery = query.expr;

    if (!lokiQuery || lokiQuery.length === 0) {
      return {
        refId: query.refId,
        labelMatchers: []
      };
    }

    const tokens = prismjs__WEBPACK_IMPORTED_MODULE_2___default().tokenize(lokiQuery, _syntax__WEBPACK_IMPORTED_MODULE_5__["default"]);
    return {
      refId: query.refId,
      labelMatchers: (0,app_plugins_datasource_prometheus_language_utils__WEBPACK_IMPORTED_MODULE_4__.extractLabelMatchers)(tokens)
    };
  }

  async getSeriesLabels(selector) {
    if (this.lookupsDisabled) {
      return undefined;
    }

    try {
      return await this.fetchSeriesLabels(selector);
    } catch (error) {
      // TODO: better error handling
      console.error(error);
      return undefined;
    }
  }
  /**
   * Fetches all label keys
   */


  async fetchLabels() {
    const url = 'labels';
    const timeRange = this.datasource.getTimeRangeParams();
    this.labelFetchTs = Date.now().valueOf();
    const res = await this.request(url, timeRange);

    if (Array.isArray(res)) {
      const labels = res.slice().sort().filter(label => label !== '__name__');
      this.labelKeys = labels;
    }

    return [];
  }

  async refreshLogLabels(forceRefresh) {
    if (this.labelKeys && Date.now().valueOf() - this.labelFetchTs > LABEL_REFRESH_INTERVAL || forceRefresh) {
      await this.fetchLabels();
    }
  }
  /**
   * Fetch labels for a selector. This is cached by it's args but also by the global timeRange currently selected as
   * they can change over requested time.
   * @param name
   */


  // Cache key is a bit different here. We round up to a minute the intervals.
  // The rounding may seem strange but makes relative intervals like now-1h less prone to need separate request every
  // millisecond while still actually getting all the keys for the correct interval. This still can create problems
  // when user does not the newest values for a minute if already cached.
  generateCacheKey(url, start, end, param) {
    return [url, this.roundTime(start), this.roundTime(end), param].join();
  } // Round nanos epoch to nearest 5 minute interval


  roundTime(nanos) {
    return nanos ? Math.floor(nanos / NS_IN_MS / 1000 / 60 / 5) : 0;
  }

  async getLabelValues(key) {
    return await this.fetchLabelValues(key);
  }

  async fetchLabelValues(key) {
    var _labelValues;

    const interpolatedKey = this.datasource.interpolateString(key);
    const url = `label/${interpolatedKey}/values`;
    const rangeParams = this.datasource.getTimeRangeParams();
    const {
      start,
      end
    } = rangeParams;
    const cacheKey = this.generateCacheKey(url, start, end, interpolatedKey);
    const params = {
      start,
      end
    };
    let labelValues = this.labelsCache.get(cacheKey);

    if (!labelValues) {
      // Clear value when requesting new one. Empty object being truthy also makes sure we don't request twice.
      this.labelsCache.set(cacheKey, []);
      const res = await this.request(url, params);

      if (Array.isArray(res)) {
        labelValues = res.slice().sort();
        this.labelsCache.set(cacheKey, labelValues);
      }
    }

    return (_labelValues = labelValues) !== null && _labelValues !== void 0 ? _labelValues : [];
  }

}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/language_utils.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "escapeLabelValueInExactSelector": () => (/* binding */ escapeLabelValueInExactSelector),
/* harmony export */   "escapeLabelValueInRegexSelector": () => (/* binding */ escapeLabelValueInRegexSelector),
/* harmony export */   "escapeLabelValueInSelector": () => (/* binding */ escapeLabelValueInSelector),
/* harmony export */   "isRegexSelector": () => (/* binding */ isRegexSelector),
/* harmony export */   "shouldRefreshLabels": () => (/* binding */ shouldRefreshLabels)
/* harmony export */ });
function roundMsToMin(milliseconds) {
  return roundSecToMin(milliseconds / 1000);
}

function roundSecToMin(seconds) {
  return Math.floor(seconds / 60);
}

function shouldRefreshLabels(range, prevRange) {
  if (range && prevRange) {
    const sameMinuteFrom = roundMsToMin(range.from.valueOf()) === roundMsToMin(prevRange.from.valueOf());
    const sameMinuteTo = roundMsToMin(range.to.valueOf()) === roundMsToMin(prevRange.to.valueOf()); // If both are same, don't need to refresh

    return !(sameMinuteFrom && sameMinuteTo);
  }

  return false;
} // Loki regular-expressions use the RE2 syntax (https://github.com/google/re2/wiki/Syntax),
// so every character that matches something in that list has to be escaped.
// the list of meta characters is: *+?()|\.[]{}^$
// we make a javascript regular expression that matches those characters:

const RE2_METACHARACTERS = /[*+?()|\\.\[\]{}^$]/g;

function escapeLokiRegexp(value) {
  return value.replace(RE2_METACHARACTERS, '\\$&');
} // based on the openmetrics-documentation, the 3 symbols we have to handle are:
// - \n ... the newline character
// - \  ... the backslash character
// - "  ... the double-quote character


function escapeLabelValueInExactSelector(labelValue) {
  return labelValue.replace(/\\/g, '\\\\').replace(/\n/g, '\\n').replace(/"/g, '\\"');
}
function escapeLabelValueInRegexSelector(labelValue) {
  return escapeLabelValueInExactSelector(escapeLokiRegexp(labelValue));
}
function escapeLabelValueInSelector(labelValue, selector) {
  return isRegexSelector(selector) ? escapeLabelValueInRegexSelector(labelValue) : escapeLabelValueInExactSelector(labelValue);
}
function isRegexSelector(selector) {
  if (selector && (selector.includes('=~') || selector.includes('!~'))) {
    return true;
  }

  return false;
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/live_streams.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LiveStreams": () => (/* binding */ LiveStreams)
/* harmony export */ });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/timer.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/throwError.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/map.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/retryWhen.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/finalize.js");
/* harmony import */ var rxjs_webSocket__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/dom/webSocket.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _result_transformer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/loki/result_transformer.ts");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







/**
 * Cache of websocket streams that can be returned as observable. In case there already is a stream for particular
 * target it is returned and on subscription returns the latest dataFrame.
 */
class LiveStreams {
  constructor() {
    _defineProperty(this, "streams", {});
  }

  getStream(target, retryInterval = 5000) {
    let stream = this.streams[target.url];

    if (stream) {
      return stream;
    }

    const data = new _grafana_data__WEBPACK_IMPORTED_MODULE_0__.CircularDataFrame({
      capacity: target.size
    });
    data.addField({
      name: 'labels',
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.other
    }); // The labels for each line

    data.addField({
      name: 'ts',
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.time,
      config: {
        displayName: 'Time'
      }
    });
    data.addField({
      name: 'line',
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.string
    }).labels = (0,_grafana_data__WEBPACK_IMPORTED_MODULE_0__.parseLabels)(target.query);
    data.addField({
      name: 'id',
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.string
    });
    data.addField({
      name: 'tsNs',
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.time,
      config: {
        displayName: 'Time ns'
      }
    });
    data.meta = Object.assign({}, data.meta, {
      preferredVisualisationType: 'logs'
    });
    data.refId = target.refId;
    stream = (0,rxjs_webSocket__WEBPACK_IMPORTED_MODULE_2__.webSocket)(target.url).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)(response => {
      (0,_result_transformer__WEBPACK_IMPORTED_MODULE_1__.appendResponseToBufferedData)(response, data);
      return [data];
    }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.retryWhen)(attempts => attempts.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.mergeMap)((error, i) => {
      const retryAttempt = i + 1; // Code 1006 is used to indicate that a connection was closed abnormally.
      // Added hard limit of 30 on number of retries.
      // If connection was closed abnormally, and we wish to retry, otherwise throw error.

      if (error.code === 1006 && retryAttempt < 30) {
        if (retryAttempt > 10) {
          // If more than 10 times retried, consol.warn, but keep reconnecting
          console.warn(`Websocket connection is being disrupted. We keep reconnecting but consider starting new live tailing again. Error: ${error.reason}`);
        } // Retry every 5s


        return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.timer)(retryInterval);
      }

      return (0,rxjs__WEBPACK_IMPORTED_MODULE_7__.throwError)(error);
    }))), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_8__.finalize)(() => {
      delete this.streams[target.url];
    }));
    this.streams[target.url] = stream;
    return stream;
  }

}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/makeTableFrames.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "makeTableFrames": () => (/* binding */ makeTableFrames)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");


function makeTableFrames(instantMetricFrames) {
  // first we remove frames that have no refId
  // (we will group them by refId, so we need it to be set)
  const framesWithRefId = instantMetricFrames.filter(f => f.refId !== undefined);
  const framesByRefId = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.groupBy)(framesWithRefId, frame => frame.refId);
  return Object.entries(framesByRefId).map(([refId, frames]) => makeTableFrame(frames, refId));
}

function makeTableFrame(instantMetricFrames, refId) {
  const tableTimeField = {
    name: 'Time',
    config: {},
    values: new _grafana_data__WEBPACK_IMPORTED_MODULE_1__.ArrayVector(),
    type: _grafana_data__WEBPACK_IMPORTED_MODULE_1__.FieldType.time
  };
  const tableValueField = {
    name: `Value #${refId}`,
    config: {},
    values: new _grafana_data__WEBPACK_IMPORTED_MODULE_1__.ArrayVector(),
    type: _grafana_data__WEBPACK_IMPORTED_MODULE_1__.FieldType.number
  }; // Sort metric labels, create columns for them and record their index

  const allLabelNames = new Set(instantMetricFrames.map(frame => frame.fields.map(field => {
    var _field$labels;

    return Object.keys((_field$labels = field.labels) !== null && _field$labels !== void 0 ? _field$labels : {});
  }).flat()).flat());
  const sortedLabelNames = Array.from(allLabelNames).sort();
  const labelFields = sortedLabelNames.map(labelName => ({
    name: labelName,
    config: {
      filterable: true
    },
    values: new _grafana_data__WEBPACK_IMPORTED_MODULE_1__.ArrayVector(),
    type: _grafana_data__WEBPACK_IMPORTED_MODULE_1__.FieldType.string
  }));
  instantMetricFrames.forEach(frame => {
    var _valueField$labels;

    const timeField = frame.fields.find(field => field.type === _grafana_data__WEBPACK_IMPORTED_MODULE_1__.FieldType.time);
    const valueField = frame.fields.find(field => field.type === _grafana_data__WEBPACK_IMPORTED_MODULE_1__.FieldType.number);

    if (timeField == null || valueField == null) {
      return;
    }

    const timeArray = timeField.values.toArray();
    const valueArray = valueField.values.toArray();

    for (let x of timeArray) {
      tableTimeField.values.add(x);
    }

    for (let x of valueArray) {
      tableValueField.values.add(x);
    }

    const labels = (_valueField$labels = valueField.labels) !== null && _valueField$labels !== void 0 ? _valueField$labels : {};

    for (let f of labelFields) {
      var _labels$f$name;

      const text = (_labels$f$name = labels[f.name]) !== null && _labels$f$name !== void 0 ? _labels$f$name : ''; // we insert the labels as many times as we have values

      for (let i = 0; i < valueArray.length; i++) {
        f.values.add(text);
      }
    }
  });
  return {
    fields: [tableTimeField, ...labelFields, tableValueField],
    refId,
    meta: {
      preferredVisualisationType: 'table'
    },
    length: tableTimeField.values.length
  };
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/module.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "plugin": () => (/* binding */ plugin)
/* harmony export */ });
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _LokiAnnotationsQueryCtrl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/loki/LokiAnnotationsQueryCtrl.tsx");
/* harmony import */ var _components_LokiCheatSheet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiCheatSheet.tsx");
/* harmony import */ var _components_LokiQueryEditorByApp__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiQueryEditorByApp.tsx");
/* harmony import */ var _configuration_ConfigEditor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/loki/configuration/ConfigEditor.tsx");
/* harmony import */ var _datasource__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/loki/datasource.ts");






const plugin = new _grafana_data__WEBPACK_IMPORTED_MODULE_0__.DataSourcePlugin(_datasource__WEBPACK_IMPORTED_MODULE_5__.LokiDatasource).setQueryEditor(_components_LokiQueryEditorByApp__WEBPACK_IMPORTED_MODULE_3__["default"]).setConfigEditor(_configuration_ConfigEditor__WEBPACK_IMPORTED_MODULE_4__.ConfigEditor).setQueryEditorHelp(_components_LokiCheatSheet__WEBPACK_IMPORTED_MODULE_2__["default"]).setAnnotationQueryCtrl(_LokiAnnotationsQueryCtrl__WEBPACK_IMPORTED_MODULE_1__.LokiAnnotationsQueryCtrl);

/***/ }),

/***/ "./public/app/plugins/datasource/loki/query_utils.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addParsedLabelToQuery": () => (/* binding */ addParsedLabelToQuery),
/* harmony export */   "formatQuery": () => (/* binding */ formatQuery),
/* harmony export */   "getHighlighterExpressionsFromQuery": () => (/* binding */ getHighlighterExpressionsFromQuery),
/* harmony export */   "getNormalizedLokiQuery": () => (/* binding */ getNormalizedLokiQuery),
/* harmony export */   "queryHasPipeParser": () => (/* binding */ queryHasPipeParser)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _syntax__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/loki/syntax.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/loki/types.ts");
const _excluded = ["instant", "range"],
      _excluded2 = ["instant", "range"],
      _excluded3 = ["instant", "range"];

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }




function formatQuery(selector) {
  return `${selector || ''}`.trim();
}
/**
 * Returns search terms from a LogQL query.
 * E.g., `{} |= foo |=bar != baz` returns `['foo', 'bar']`.
 */

function getHighlighterExpressionsFromQuery(input) {
  let expression = input;
  const results = []; // Consume filter expression from left to right

  while (expression) {
    const filterStart = expression.search(/\|=|\|~|!=|!~/); // Nothing more to search

    if (filterStart === -1) {
      break;
    } // Drop terms for negative filters


    const filterOperator = expression.slice(filterStart, filterStart + 2);
    const skip = expression.slice(filterStart).search(/!=|!~/) === 0;
    expression = expression.slice(filterStart + 2);

    if (skip) {
      continue;
    } // Check if there is more chained


    const filterEnd = expression.search(/\|=|\|~|!=|!~/);
    let filterTerm;

    if (filterEnd === -1) {
      filterTerm = expression.trim();
    } else {
      filterTerm = expression.slice(0, filterEnd).trim();
      expression = expression.slice(filterEnd);
    }

    const quotedTerm = filterTerm.match(/"(.*?)"/);
    const backtickedTerm = filterTerm.match(/`(.*?)`/);
    const term = quotedTerm || backtickedTerm;

    if (term) {
      const unwrappedFilterTerm = term[1];
      const regexOperator = filterOperator === '|~'; // Only filter expressions with |~ operator are treated as regular expressions

      if (regexOperator) {
        // When using backticks, Loki doesn't require to escape special characters and we can just push regular expression to highlights array
        // When using quotes, we have extra backslash escaping and we need to replace \\ with \
        results.push(backtickedTerm ? unwrappedFilterTerm : unwrappedFilterTerm.replace(/\\\\/g, '\\'));
      } else {
        // We need to escape this string so it is not matched as regular expression
        results.push((0,lodash__WEBPACK_IMPORTED_MODULE_0__.escapeRegExp)(unwrappedFilterTerm));
      }
    } else {
      return results;
    }
  }

  return results;
}
function queryHasPipeParser(expr) {
  const parsers = _syntax__WEBPACK_IMPORTED_MODULE_1__.PIPE_PARSERS.map(parser => `${parser.label}`).join('|');
  const regexp = new RegExp(`\\\|\\\s?(${parsers})`);
  return regexp.test(expr);
}
function addParsedLabelToQuery(expr, key, value, operator) {
  return expr + ` | ${key}${operator}"${value.toString()}"`;
} // we are migrating from `.instant` and `.range` to `.queryType`
// this function returns a new query object that:
// - has `.queryType`
// - does not have `.instant`
// - does not have `.range`

function getNormalizedLokiQuery(query) {
  // if queryType exists, it is respected
  if (query.queryType !== undefined) {
    const rest = _objectWithoutPropertiesLoose(query, _excluded);

    return rest;
  } // if no queryType, and instant===true, it's instant


  if (query.instant === true) {
    const rest = _objectWithoutPropertiesLoose(query, _excluded2);

    return Object.assign({}, rest, {
      queryType: _types__WEBPACK_IMPORTED_MODULE_2__.LokiQueryType.Instant
    });
  } // otherwise it is range


  const rest = _objectWithoutPropertiesLoose(query, _excluded3);

  return Object.assign({}, rest, {
    queryType: _types__WEBPACK_IMPORTED_MODULE_2__.LokiQueryType.Range
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/LokiQueryModeller.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiQueryModeller": () => (/* binding */ LokiQueryModeller),
/* harmony export */   "lokiQueryModeller": () => (/* binding */ lokiQueryModeller)
/* harmony export */ });
/* harmony import */ var _prometheus_querybuilder_shared_LokiAndPromQueryModellerBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/LokiAndPromQueryModellerBase.ts");
/* harmony import */ var _operations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/operations.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/types.ts");



class LokiQueryModeller extends _prometheus_querybuilder_shared_LokiAndPromQueryModellerBase__WEBPACK_IMPORTED_MODULE_0__.LokiAndPromQueryModellerBase {
  constructor() {
    super(_operations__WEBPACK_IMPORTED_MODULE_1__.getOperationDefinitions);
    this.setOperationCategories([_types__WEBPACK_IMPORTED_MODULE_2__.LokiVisualQueryOperationCategory.Aggregations, _types__WEBPACK_IMPORTED_MODULE_2__.LokiVisualQueryOperationCategory.RangeFunctions, _types__WEBPACK_IMPORTED_MODULE_2__.LokiVisualQueryOperationCategory.Formats, _types__WEBPACK_IMPORTED_MODULE_2__.LokiVisualQueryOperationCategory.BinaryOps, _types__WEBPACK_IMPORTED_MODULE_2__.LokiVisualQueryOperationCategory.LabelFilters, _types__WEBPACK_IMPORTED_MODULE_2__.LokiVisualQueryOperationCategory.LineFilters]);
  }

  renderLabels(labels) {
    if (labels.length === 0) {
      return '{}';
    }

    return super.renderLabels(labels);
  }

  getQueryPatterns() {
    return [{
      name: 'Log query and label filter',
      operations: [{
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.LineMatchesRegex,
        params: ['']
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.Logfmt,
        params: []
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.LabelFilterNoErrors,
        params: []
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.LabelFilter,
        params: ['', '=', '']
      }]
    }, {
      name: 'Time series query on value inside log line',
      operations: [{
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.LineMatchesRegex,
        params: ['']
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.Logfmt,
        params: []
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.LabelFilterNoErrors,
        params: []
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.Unwrap,
        params: ['']
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.SumOverTime,
        params: ['$__interval']
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.Sum,
        params: []
      }]
    }];
  }

}
const lokiQueryModeller = new LokiQueryModeller();

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/binaryScalarOperations.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "binaryScalarDefs": () => (/* binding */ binaryScalarDefs),
/* harmony export */   "binaryScalarOperations": () => (/* binding */ binaryScalarOperations)
/* harmony export */ });
/* harmony import */ var _prometheus_querybuilder_shared_operationUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/types.ts");


const binaryScalarDefs = [{
  id: _types__WEBPACK_IMPORTED_MODULE_1__.LokiOperationId.Addition,
  name: 'Add scalar',
  sign: '+'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.LokiOperationId.Subtraction,
  name: 'Subtract scalar',
  sign: '-'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.LokiOperationId.MultiplyBy,
  name: 'Multiply by scalar',
  sign: '*'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.LokiOperationId.DivideBy,
  name: 'Divide by scalar',
  sign: '/'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.LokiOperationId.Modulo,
  name: 'Modulo by scalar',
  sign: '%'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.LokiOperationId.Exponent,
  name: 'Exponent',
  sign: '^'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.LokiOperationId.EqualTo,
  name: 'Equal to',
  sign: '==',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.LokiOperationId.NotEqualTo,
  name: 'Not equal to',
  sign: '!=',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.LokiOperationId.GreaterThan,
  name: 'Greater than',
  sign: '>',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.LokiOperationId.LessThan,
  name: 'Less than',
  sign: '<',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.LokiOperationId.GreaterOrEqual,
  name: 'Greater or equal to',
  sign: '>=',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.LokiOperationId.LessOrEqual,
  name: 'Less or equal to',
  sign: '<=',
  comparison: true
}]; // Not sure about this one. It could also be a more generic 'Simple math operation' where user specifies
// both the operator and the operand in a single input

const binaryScalarOperations = binaryScalarDefs.map(opDef => {
  const params = [{
    name: 'Value',
    type: 'number'
  }];
  const defaultParams = [2];

  if (opDef.comparison) {
    params.unshift({
      name: 'Bool',
      type: 'boolean',
      description: 'If checked comparison will return 0 or 1 for the value rather than filtering.'
    });
    defaultParams.unshift(false);
  }

  return {
    id: opDef.id,
    name: opDef.name,
    params,
    defaultParams,
    alternativesKey: 'binary scalar operations',
    category: _types__WEBPACK_IMPORTED_MODULE_1__.LokiVisualQueryOperationCategory.BinaryOps,
    renderer: getSimpleBinaryRenderer(opDef.sign),
    addOperationHandler: _prometheus_querybuilder_shared_operationUtils__WEBPACK_IMPORTED_MODULE_0__.defaultAddOperationHandler
  };
});

function getSimpleBinaryRenderer(operator) {
  return function binaryRenderer(model, def, innerExpr) {
    let param = model.params[0];
    let bool = '';

    if (model.params.length === 2) {
      param = model.params[1];
      bool = model.params[0] ? ' bool' : '';
    }

    return `${innerExpr} ${operator}${bool} ${param}`;
  };
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/components/LokiQueryBuilder.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiQueryBuilder": () => (/* binding */ LokiQueryBuilder)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-22e4fdfd25/0/cache/@grafana-experimental-npm-0.0.2-canary.30-71a280d204-b5b453b937.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var app_plugins_datasource_prometheus_querybuilder_shared_LabelFilters__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/LabelFilters.tsx");
/* harmony import */ var app_plugins_datasource_prometheus_querybuilder_shared_OperationList__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationList.tsx");
/* harmony import */ var app_plugins_datasource_prometheus_querybuilder_shared_OperationsEditorRow__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationsEditorRow.tsx");
/* harmony import */ var _language_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/loki/language_utils.ts");
/* harmony import */ var _LokiQueryModeller__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/LokiQueryModeller.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/types.ts");
/* harmony import */ var _NestedQueryList__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/components/NestedQueryList.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");












const LokiQueryBuilder = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.memo(({
  datasource,
  query,
  nested,
  onChange,
  onRunQuery
}) => {
  const onChangeLabels = labels => {
    onChange(Object.assign({}, query, {
      labels
    }));
  };

  const withTemplateVariableOptions = async optionsPromise => {
    const options = await optionsPromise;
    return [...datasource.getVariables(), ...options].map(value => ({
      label: value,
      value
    }));
  };

  const onGetLabelNames = async forLabel => {
    const labelsToConsider = query.labels.filter(x => x !== forLabel);

    if (labelsToConsider.length === 0) {
      await datasource.languageProvider.refreshLogLabels();
      return datasource.languageProvider.getLabelKeys();
    }

    const expr = _LokiQueryModeller__WEBPACK_IMPORTED_MODULE_6__.lokiQueryModeller.renderLabels(labelsToConsider);
    const series = await datasource.languageProvider.fetchSeriesLabels(expr);
    return Object.keys(series).sort();
  };

  const onGetLabelValues = async forLabel => {
    if (!forLabel.label) {
      return [];
    }

    let values;
    const labelsToConsider = query.labels.filter(x => x !== forLabel);

    if (labelsToConsider.length === 0) {
      values = await datasource.languageProvider.fetchLabelValues(forLabel.label);
    } else {
      const expr = _LokiQueryModeller__WEBPACK_IMPORTED_MODULE_6__.lokiQueryModeller.renderLabels(labelsToConsider);
      const result = await datasource.languageProvider.fetchSeriesLabels(expr);
      values = result[datasource.interpolateString(forLabel.label)];
    }

    return values ? values.map(v => (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.escapeLabelValueInSelector)(v, forLabel.op)) : []; // Escape values in return
  };

  const labelFilterError = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    const {
      labels,
      operations: op
    } = query;

    if (!labels.length && op.length) {
      // We don't want to show error for initial state with empty line contains operation
      if (op.length === 1 && op[0].id === _types__WEBPACK_IMPORTED_MODULE_7__.LokiOperationId.LineContains && op[0].params[0] === '') {
        return undefined;
      }

      return 'You need to specify at least 1 label filter (stream selector)';
    }

    return undefined;
  }, [query]);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorRow, {
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(app_plugins_datasource_prometheus_querybuilder_shared_LabelFilters__WEBPACK_IMPORTED_MODULE_2__.LabelFilters, {
        onGetLabelNames: forLabel => withTemplateVariableOptions(onGetLabelNames(forLabel)),
        onGetLabelValues: forLabel => withTemplateVariableOptions(onGetLabelValues(forLabel)),
        labelsFilters: query.labels,
        onChange: onChangeLabels,
        error: labelFilterError
      })
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(app_plugins_datasource_prometheus_querybuilder_shared_OperationsEditorRow__WEBPACK_IMPORTED_MODULE_4__.OperationsEditorRow, {
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(app_plugins_datasource_prometheus_querybuilder_shared_OperationList__WEBPACK_IMPORTED_MODULE_3__.OperationList, {
        queryModeller: _LokiQueryModeller__WEBPACK_IMPORTED_MODULE_6__.lokiQueryModeller,
        query: query,
        onChange: onChange,
        onRunQuery: onRunQuery,
        datasource: datasource
      })
    }), query.binaryQueries && query.binaryQueries.length > 0 && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(_NestedQueryList__WEBPACK_IMPORTED_MODULE_8__.NestedQueryList, {
      query: query,
      datasource: datasource,
      onChange: onChange,
      onRunQuery: onRunQuery
    })]
  });
});
LokiQueryBuilder.displayName = 'LokiQueryBuilder';

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/components/LokiQueryBuilderContainer.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiQueryBuilderContainer": () => (/* binding */ LokiQueryBuilderContainer)
/* harmony export */ });
/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/__virtual__/@reduxjs-toolkit-virtual-341575ab98/0/cache/@reduxjs-toolkit-npm-1.8.0-436263eab0-e229571b80.zip/node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _LokiQueryModeller__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/LokiQueryModeller.ts");
/* harmony import */ var _parsing__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/parsing.ts");
/* harmony import */ var _LokiQueryBuilder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/components/LokiQueryBuilder.tsx");
/* harmony import */ var _QueryPreview__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/components/QueryPreview.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");










/**
 * This component is here just to contain the translation logic between string query and the visual query builder model.
 */
function LokiQueryBuilderContainer(props) {
  const {
    query,
    onChange,
    onRunQuery,
    datasource
  } = props;
  const [state, dispatch] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(stateSlice.reducer, {
    expr: query.expr,
    // Use initial visual query only if query.expr is empty string
    visQuery: query.expr === '' ? {
      labels: [],
      operations: [{
        id: '__line_contains',
        params: ['']
      }]
    } : undefined
  }); // Only rebuild visual query if expr changes from outside

  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    dispatch(exprChanged(query.expr));
  }, [query.expr]);

  const onVisQueryChange = visQuery => {
    const expr = _LokiQueryModeller__WEBPACK_IMPORTED_MODULE_1__.lokiQueryModeller.renderQuery(visQuery);
    dispatch(visualQueryChange({
      visQuery,
      expr
    }));
    onChange(Object.assign({}, props.query, {
      expr: expr
    }));
  };

  if (!state.visQuery) {
    return null;
  }

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_LokiQueryBuilder__WEBPACK_IMPORTED_MODULE_3__.LokiQueryBuilder, {
      query: state.visQuery,
      datasource: datasource,
      onChange: onVisQueryChange,
      onRunQuery: onRunQuery
    }), query.rawQuery && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_QueryPreview__WEBPACK_IMPORTED_MODULE_4__.QueryPreview, {
      query: query.expr
    })]
  });
}
const stateSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_6__.createSlice)({
  name: 'loki-builder-container',
  initialState: {
    expr: ''
  },
  reducers: {
    visualQueryChange: (state, action) => {
      state.expr = action.payload.expr;
      state.visQuery = action.payload.visQuery;
    },
    exprChanged: (state, action) => {
      if (!state.visQuery || state.expr !== action.payload) {
        state.expr = action.payload;
        const parseResult = (0,_parsing__WEBPACK_IMPORTED_MODULE_2__.buildVisualQueryFromString)(action.payload);
        state.visQuery = parseResult.query;
      }
    }
  }
});
const {
  visualQueryChange,
  exprChanged
} = stateSlice.actions;

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/components/LokiQueryBuilderExplained.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiQueryBuilderExplained": () => (/* binding */ LokiQueryBuilderExplained)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-22e4fdfd25/0/cache/@grafana-experimental-npm-0.0.2-canary.30-71a280d204-b5b453b937.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var app_plugins_datasource_prometheus_querybuilder_shared_OperationExplainedBox__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationExplainedBox.tsx");
/* harmony import */ var app_plugins_datasource_prometheus_querybuilder_shared_OperationListExplained__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationListExplained.tsx");
/* harmony import */ var _LokiQueryModeller__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/LokiQueryModeller.ts");
/* harmony import */ var _parsing__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/parsing.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");








const LokiQueryBuilderExplained = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.memo(({
  query,
  nested
}) => {
  const visQuery = (0,_parsing__WEBPACK_IMPORTED_MODULE_5__.buildVisualQueryFromString)(query || '').query;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.Stack, {
    gap: 0,
    direction: "column",
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(app_plugins_datasource_prometheus_querybuilder_shared_OperationExplainedBox__WEBPACK_IMPORTED_MODULE_2__.OperationExplainedBox, {
      stepNumber: 1,
      title: `${_LokiQueryModeller__WEBPACK_IMPORTED_MODULE_4__.lokiQueryModeller.renderLabels(visQuery.labels)}`,
      children: "Fetch all log lines matching label filters."
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(app_plugins_datasource_prometheus_querybuilder_shared_OperationListExplained__WEBPACK_IMPORTED_MODULE_3__.OperationListExplained, {
      stepNumber: 2,
      queryModeller: _LokiQueryModeller__WEBPACK_IMPORTED_MODULE_4__.lokiQueryModeller,
      query: visQuery
    })]
  });
});
LokiQueryBuilderExplained.displayName = 'LokiQueryBuilderExplained';

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/components/LokiQueryBuilderOptions.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiQueryBuilderOptions": () => (/* binding */ LokiQueryBuilderOptions)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-22e4fdfd25/0/cache/@grafana-experimental-npm-0.0.2-canary.30-71a280d204-b5b453b937.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_plugins_datasource_prometheus_querybuilder_shared_AutoSizeInput__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/AutoSizeInput.tsx");
/* harmony import */ var app_plugins_datasource_prometheus_querybuilder_shared_QueryOptionGroup__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/QueryOptionGroup.tsx");
/* harmony import */ var _components_LokiOptionFields__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiOptionFields.tsx");
/* harmony import */ var _datasource__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/loki/datasource.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/plugins/datasource/loki/types.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");










const LokiQueryBuilderOptions = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.memo(({
  query,
  onChange,
  onRunQuery
}) => {
  var _query$queryType, _query$maxLines$toStr, _query$maxLines;

  const onQueryTypeChange = value => {
    onChange(Object.assign({}, query, {
      queryType: value
    }));
    onRunQuery();
  };

  const onResolutionChange = option => {
    onChange(Object.assign({}, query, {
      resolution: option.value
    }));
    onRunQuery();
  };

  const onLegendFormatChanged = evt => {
    onChange(Object.assign({}, query, {
      legendFormat: evt.currentTarget.value
    }));
    onRunQuery();
  };

  function onMaxLinesChange(e) {
    const newMaxLines = (0,_components_LokiOptionFields__WEBPACK_IMPORTED_MODULE_5__.preprocessMaxLines)(e.currentTarget.value);

    if (query.maxLines !== newMaxLines) {
      onChange(Object.assign({}, query, {
        maxLines: newMaxLines
      }));
      onRunQuery();
    }
  }

  let queryType = (_query$queryType = query.queryType) !== null && _query$queryType !== void 0 ? _query$queryType : query.instant ? _types__WEBPACK_IMPORTED_MODULE_7__.LokiQueryType.Instant : _types__WEBPACK_IMPORTED_MODULE_7__.LokiQueryType.Range;
  let showMaxLines = !(0,_datasource__WEBPACK_IMPORTED_MODULE_6__.isMetricsQuery)(query.expr);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorRow, {
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsxs)(app_plugins_datasource_prometheus_querybuilder_shared_QueryOptionGroup__WEBPACK_IMPORTED_MODULE_4__.QueryOptionGroup, {
      title: "Options",
      collapsedInfo: getCollapsedInfo(query, queryType, showMaxLines),
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorField, {
        label: "Legend",
        tooltip: "Series name override or template. Ex. {{hostname}} will be replaced with label value for hostname.",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(app_plugins_datasource_prometheus_querybuilder_shared_AutoSizeInput__WEBPACK_IMPORTED_MODULE_3__.AutoSizeInput, {
          placeholder: "{{label}}",
          id: "loki-query-editor-legend-format",
          type: "string",
          minWidth: 14,
          defaultValue: query.legendFormat,
          onCommitChange: onLegendFormatChanged
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorField, {
        label: "Type",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.RadioButtonGroup, {
          options: _components_LokiOptionFields__WEBPACK_IMPORTED_MODULE_5__.queryTypeOptions,
          value: queryType,
          onChange: onQueryTypeChange
        })
      }), showMaxLines && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorField, {
        label: "Line limit",
        tooltip: "Upper limit for number of log lines returned by query.",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(app_plugins_datasource_prometheus_querybuilder_shared_AutoSizeInput__WEBPACK_IMPORTED_MODULE_3__.AutoSizeInput, {
          className: "width-4",
          placeholder: "auto",
          type: "number",
          min: 0,
          defaultValue: (_query$maxLines$toStr = (_query$maxLines = query.maxLines) === null || _query$maxLines === void 0 ? void 0 : _query$maxLines.toString()) !== null && _query$maxLines$toStr !== void 0 ? _query$maxLines$toStr : '',
          onCommitChange: onMaxLinesChange
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorField, {
        label: "Resolution",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Select, {
          isSearchable: false,
          onChange: onResolutionChange,
          options: _components_LokiOptionFields__WEBPACK_IMPORTED_MODULE_5__.RESOLUTION_OPTIONS,
          value: query.resolution || 1,
          "aria-label": "Select resolution"
        })
      })]
    })
  });
});

function getCollapsedInfo(query, queryType, showMaxLines) {
  const queryTypeLabel = _components_LokiOptionFields__WEBPACK_IMPORTED_MODULE_5__.queryTypeOptions.find(x => x.value === queryType);
  const resolutionLabel = _components_LokiOptionFields__WEBPACK_IMPORTED_MODULE_5__.RESOLUTION_OPTIONS.find(x => {
    var _query$resolution;

    return x.value === ((_query$resolution = query.resolution) !== null && _query$resolution !== void 0 ? _query$resolution : 1);
  });
  const items = [];

  if (query.legendFormat) {
    items.push(`Legend: ${query.legendFormat}`);
  }

  if (query.resolution) {
    items.push(`Resolution: ${resolutionLabel === null || resolutionLabel === void 0 ? void 0 : resolutionLabel.label}`);
  }

  items.push(`Type: ${queryTypeLabel === null || queryTypeLabel === void 0 ? void 0 : queryTypeLabel.label}`);

  if (showMaxLines && query.maxLines) {
    items.push(`Line limit: ${query.maxLines}`);
  }

  return items;
}

LokiQueryBuilderOptions.displayName = 'LokiQueryBuilderOptions';

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/components/LokiQueryCodeEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiQueryCodeEditor": () => (/* binding */ LokiQueryCodeEditor)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _components_LokiQueryEditor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiQueryEditor.tsx");
/* harmony import */ var _components_LokiQueryField__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiQueryField.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");






function LokiQueryCodeEditor({
  query,
  datasource,
  range,
  onRunQuery,
  onChange,
  data
}) {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.useStyles2)(getStyles);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
    className: styles.wrapper,
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_components_LokiQueryField__WEBPACK_IMPORTED_MODULE_4__.LokiQueryField, {
      datasource: datasource,
      query: query,
      range: range,
      onRunQuery: onRunQuery,
      onChange: onChange,
      history: [],
      data: data,
      "data-testid": _components_LokiQueryEditor__WEBPACK_IMPORTED_MODULE_3__.testIds.editor
    })
  });
}

const getStyles = theme => {
  return {
    // This wrapper styling can be removed after the old PromQueryEditor is removed.
    // This is removing margin bottom on the old legacy inline form styles
    wrapper: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
      .gf-form {
        margin-bottom: 0;
      }
    `
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/components/LokiQueryEditorSelector.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiQueryEditorSelector": () => (/* binding */ LokiQueryEditorSelector)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-22e4fdfd25/0/cache/@grafana-experimental-npm-0.0.2-canary.30-71a280d204-b5b453b937.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_plugins_datasource_prometheus_querybuilder_shared_QueryEditorModeToggle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/QueryEditorModeToggle.tsx");
/* harmony import */ var app_plugins_datasource_prometheus_querybuilder_shared_QueryHeaderSwitch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/QueryHeaderSwitch.tsx");
/* harmony import */ var app_plugins_datasource_prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/types.ts");
/* harmony import */ var _LokiQueryModeller__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/LokiQueryModeller.ts");
/* harmony import */ var _parsing__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/parsing.ts");
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/state.ts");
/* harmony import */ var _LokiQueryBuilderContainer__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/components/LokiQueryBuilderContainer.tsx");
/* harmony import */ var _LokiQueryBuilderExplained__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/components/LokiQueryBuilderExplained.tsx");
/* harmony import */ var _LokiQueryBuilderOptions__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/components/LokiQueryBuilderOptions.tsx");
/* harmony import */ var _LokiQueryCodeEditor__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/components/LokiQueryCodeEditor.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _FlexItem, _Space;


















const LokiQueryEditorSelector = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.memo(props => {
  var _query$editorMode;

  const {
    onChange,
    onRunQuery,
    data
  } = props;
  const [parseModalOpen, setParseModalOpen] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);
  const [dataIsStale, setDataIsStale] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);
  const query = (0,_state__WEBPACK_IMPORTED_MODULE_9__.getQueryWithDefaults)(props.query);
  const onEditorModeChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(newEditorMode => {
    if (newEditorMode === app_plugins_datasource_prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_6__.QueryEditorMode.Builder) {
      const result = (0,_parsing__WEBPACK_IMPORTED_MODULE_8__.buildVisualQueryFromString)(query.expr || ''); // If there are errors, give user a chance to decide if they want to go to builder as that can loose some data.

      if (result.errors.length) {
        setParseModalOpen(true);
        return;
      }
    }

    (0,_state__WEBPACK_IMPORTED_MODULE_9__.changeEditorMode)(query, newEditorMode, onChange);
  }, [onChange, query]);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    setDataIsStale(false);
  }, [data]);

  const onChangeInternal = query => {
    setDataIsStale(true);
    onChange(query);
  };

  const onQueryPreviewChange = event => {
    const isEnabled = event.currentTarget.checked;
    onChange(Object.assign({}, query, {
      rawQuery: isEnabled
    }));
  }; // If no expr (ie new query) then default to builder


  const editorMode = (_query$editorMode = query.editorMode) !== null && _query$editorMode !== void 0 ? _query$editorMode : query.expr ? app_plugins_datasource_prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_6__.QueryEditorMode.Code : app_plugins_datasource_prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_6__.QueryEditorMode.Builder;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_14__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_14__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_14__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.ConfirmModal, {
      isOpen: parseModalOpen,
      title: "Query parsing",
      body: "There were errors while trying to parse the query. Continuing to visual builder may loose some parts of the query.",
      confirmText: "Continue",
      onConfirm: () => {
        onChange(Object.assign({}, query, {
          editorMode: app_plugins_datasource_prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_6__.QueryEditorMode.Builder
        }));
        setParseModalOpen(false);
      },
      onDismiss: () => setParseModalOpen(false)
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_14__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.EditorHeader, {
      children: [editorMode === app_plugins_datasource_prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_6__.QueryEditorMode.Builder && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_14__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_14__.Fragment, {
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_14__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.InlineSelect, {
          value: null,
          placeholder: "Query patterns",
          allowCustomValue: true,
          onChange: ({
            value
          }) => {
            const result = (0,_parsing__WEBPACK_IMPORTED_MODULE_8__.buildVisualQueryFromString)(query.expr || '');
            result.query.operations = value === null || value === void 0 ? void 0 : value.operations;
            onChange(Object.assign({}, query, {
              expr: _LokiQueryModeller__WEBPACK_IMPORTED_MODULE_7__.lokiQueryModeller.renderQuery(result.query)
            }));
          },
          options: _LokiQueryModeller__WEBPACK_IMPORTED_MODULE_7__.lokiQueryModeller.getQueryPatterns().map(x => ({
            label: x.name,
            value: x
          }))
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_14__.jsx)(app_plugins_datasource_prometheus_querybuilder_shared_QueryHeaderSwitch__WEBPACK_IMPORTED_MODULE_5__.QueryHeaderSwitch, {
          label: "Raw query",
          value: query.rawQuery,
          onChange: onQueryPreviewChange
        })]
      }), _FlexItem || (_FlexItem = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_14__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.FlexItem, {
        grow: 1
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_14__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
        variant: dataIsStale ? 'primary' : 'secondary',
        size: "sm",
        onClick: onRunQuery,
        icon: (data === null || data === void 0 ? void 0 : data.state) === _grafana_data__WEBPACK_IMPORTED_MODULE_1__.LoadingState.Loading ? 'fa fa-spinner' : undefined,
        disabled: (data === null || data === void 0 ? void 0 : data.state) === _grafana_data__WEBPACK_IMPORTED_MODULE_1__.LoadingState.Loading,
        children: "Run query"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_14__.jsx)(app_plugins_datasource_prometheus_querybuilder_shared_QueryEditorModeToggle__WEBPACK_IMPORTED_MODULE_4__.QueryEditorModeToggle, {
        mode: editorMode,
        onChange: onEditorModeChange
      })]
    }), _Space || (_Space = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_14__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.Space, {
      v: 0.5
    })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_14__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.EditorRows, {
      children: [editorMode === app_plugins_datasource_prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_6__.QueryEditorMode.Code && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_14__.jsx)(_LokiQueryCodeEditor__WEBPACK_IMPORTED_MODULE_13__.LokiQueryCodeEditor, Object.assign({}, props)), editorMode === app_plugins_datasource_prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_6__.QueryEditorMode.Builder && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_14__.jsx)(_LokiQueryBuilderContainer__WEBPACK_IMPORTED_MODULE_10__.LokiQueryBuilderContainer, {
        datasource: props.datasource,
        query: query,
        onChange: onChangeInternal,
        onRunQuery: props.onRunQuery
      }), editorMode === app_plugins_datasource_prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_6__.QueryEditorMode.Explain && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_14__.jsx)(_LokiQueryBuilderExplained__WEBPACK_IMPORTED_MODULE_11__.LokiQueryBuilderExplained, {
        query: query.expr
      }), editorMode !== app_plugins_datasource_prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_6__.QueryEditorMode.Explain && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_14__.jsx)(_LokiQueryBuilderOptions__WEBPACK_IMPORTED_MODULE_12__.LokiQueryBuilderOptions, {
        query: query,
        onChange: onChange,
        onRunQuery: onRunQuery
      })]
    })]
  });
});
LokiQueryEditorSelector.displayName = 'LokiQueryEditorSelector';

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/components/NestedQuery.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NestedQuery": () => (/* binding */ NestedQuery)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-22e4fdfd25/0/cache/@grafana-experimental-npm-0.0.2-canary.30-71a280d204-b5b453b937.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_plugins_datasource_prometheus_querybuilder_shared_AutoSizeInput__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/AutoSizeInput.tsx");
/* harmony import */ var _binaryScalarOperations__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/binaryScalarOperations.ts");
/* harmony import */ var _LokiQueryBuilder__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/components/LokiQueryBuilder.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _FlexItem;











const NestedQuery = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.memo(({
  nestedQuery,
  index,
  datasource,
  onChange,
  onRemove,
  onRunQuery
}) => {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.useStyles2)(getStyles);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsxs)("div", {
    className: styles.card,
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsxs)("div", {
      className: styles.header,
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("div", {
        className: styles.name,
        children: "Operator"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Select, {
        width: "auto",
        options: operators,
        value: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_2__.toOption)(nestedQuery.operator),
        onChange: value => {
          onChange(index, Object.assign({}, nestedQuery, {
            operator: value.value
          }));
        }
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("div", {
        className: styles.name,
        children: "Vector matches"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsxs)("div", {
        className: styles.vectorMatchWrapper,
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Select, {
          width: "auto",
          value: nestedQuery.vectorMatchesType || 'on',
          allowCustomValue: true,
          options: [{
            value: 'on',
            label: 'on'
          }, {
            value: 'ignoring',
            label: 'ignoring'
          }],
          onChange: val => {
            onChange(index, Object.assign({}, nestedQuery, {
              vectorMatchesType: val.value
            }));
          }
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(app_plugins_datasource_prometheus_querybuilder_shared_AutoSizeInput__WEBPACK_IMPORTED_MODULE_5__.AutoSizeInput, {
          className: styles.vectorMatchInput,
          minWidth: 20,
          defaultValue: nestedQuery.vectorMatches,
          onCommitChange: evt => {
            onChange(index, Object.assign({}, nestedQuery, {
              vectorMatches: evt.currentTarget.value,
              vectorMatchesType: nestedQuery.vectorMatchesType || 'on'
            }));
          }
        })]
      }), _FlexItem || (_FlexItem = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_3__.FlexItem, {
        grow: 1
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.IconButton, {
        name: "times",
        size: "sm",
        onClick: () => onRemove(index)
      })]
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("div", {
      className: styles.body,
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_3__.EditorRows, {
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_LokiQueryBuilder__WEBPACK_IMPORTED_MODULE_7__.LokiQueryBuilder, {
          query: nestedQuery.query,
          datasource: datasource,
          nested: true,
          onRunQuery: onRunQuery,
          onChange: update => {
            onChange(index, Object.assign({}, nestedQuery, {
              query: update
            }));
          }
        })
      })
    })]
  });
});
const operators = _binaryScalarOperations__WEBPACK_IMPORTED_MODULE_6__.binaryScalarDefs.map(def => ({
  label: def.sign,
  value: def.sign
}));
NestedQuery.displayName = 'NestedQuery';

const getStyles = theme => {
  return {
    card: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'card',
      display: 'flex',
      flexDirection: 'column',
      gap: theme.spacing(0.5)
    }),
    header: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'header',
      padding: theme.spacing(0.5, 0.5, 0.5, 1),
      gap: theme.spacing(1),
      display: 'flex',
      alignItems: 'center'
    }),
    name: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'name',
      whiteSpace: 'nowrap'
    }),
    body: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'body',
      paddingLeft: theme.spacing(2)
    }),
    vectorMatchInput: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'vectorMatchInput',
      marginLeft: -1
    }),
    vectorMatchWrapper: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'vectorMatchWrapper',
      display: 'flex'
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/components/NestedQueryList.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NestedQueryList": () => (/* binding */ NestedQueryList)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-22e4fdfd25/0/cache/@grafana-experimental-npm-0.0.2-canary.30-71a280d204-b5b453b937.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _NestedQuery__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/components/NestedQuery.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");




function NestedQueryList({
  query,
  datasource,
  onChange,
  onRunQuery
}) {
  var _query$binaryQueries;

  const nestedQueries = (_query$binaryQueries = query.binaryQueries) !== null && _query$binaryQueries !== void 0 ? _query$binaryQueries : [];

  const onNestedQueryUpdate = (index, update) => {
    const updatedList = [...nestedQueries];
    updatedList.splice(index, 1, update);
    onChange(Object.assign({}, query, {
      binaryQueries: updatedList
    }));
  };

  const onRemove = index => {
    const updatedList = [...nestedQueries.slice(0, index), ...nestedQueries.slice(index + 1)];
    onChange(Object.assign({}, query, {
      binaryQueries: updatedList
    }));
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.Stack, {
    direction: "column",
    gap: 1,
    children: nestedQueries.map((nestedQuery, index) => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_NestedQuery__WEBPACK_IMPORTED_MODULE_2__.NestedQuery, {
      nestedQuery: nestedQuery,
      index: index,
      onChange: onNestedQueryUpdate,
      datasource: datasource,
      onRemove: onRemove,
      onRunQuery: onRunQuery
    }, index.toString()))
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/components/QueryPreview.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "QueryPreview": () => (/* binding */ QueryPreview)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/prismjs-npm-1.27.0-ca4e1667c6-85c7f4a3e9.zip/node_modules/prismjs/prism.js");
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prismjs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-22e4fdfd25/0/cache/@grafana-experimental-npm-0.0.2-canary.30-71a280d204-b5b453b937.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _syntax__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/loki/syntax.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");







function QueryPreview({
  query
}) {
  const theme = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.useTheme2)();
  const styles = getStyles(theme);
  const highlighted = prismjs__WEBPACK_IMPORTED_MODULE_1___default().highlight(query, _syntax__WEBPACK_IMPORTED_MODULE_5__.lokiGrammar, 'lokiql');
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_3__.EditorRow, {
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_3__.EditorFieldGroup, {
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_3__.EditorField, {
        label: "Raw query",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("div", {
          className: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.cx)(styles.editorField, 'prism-syntax-highlight'),
          "aria-label": "selector",
          dangerouslySetInnerHTML: {
            __html: highlighted
          }
        })
      })
    })
  });
}

const getStyles = theme => {
  return {
    editorField: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      fontFamily: theme.typography.fontFamilyMonospace,
      fontSize: theme.typography.bodySmall.fontSize
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/operations.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addLokiOperation": () => (/* binding */ addLokiOperation),
/* harmony export */   "getOperationDefinitions": () => (/* binding */ getOperationDefinitions)
/* harmony export */ });
/* harmony import */ var _prometheus_querybuilder_shared_operationUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts");
/* harmony import */ var _syntax__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/loki/syntax.ts");
/* harmony import */ var _binaryScalarOperations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/binaryScalarOperations.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/types.ts");




function getOperationDefinitions() {
  const aggregations = [_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Sum, _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Min, _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Max, _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Avg, _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Stddev, _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Stdvar, _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Count].flatMap(opId => (0,_prometheus_querybuilder_shared_operationUtils__WEBPACK_IMPORTED_MODULE_0__.createAggregationOperation)(opId, {
    addOperationHandler: addLokiOperation,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.Last
  }));
  const aggregationsWithParam = [_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.TopK, _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.BottomK].flatMap(opId => {
    return (0,_prometheus_querybuilder_shared_operationUtils__WEBPACK_IMPORTED_MODULE_0__.createAggregationOperationWithParam)(opId, {
      params: [{
        name: 'K-value',
        type: 'number'
      }],
      defaultParams: [5]
    }, {
      addOperationHandler: addLokiOperation,
      orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.Last
    });
  });
  const list = [createRangeOperation(_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Rate), createRangeOperation(_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.CountOverTime), createRangeOperation(_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.SumOverTime), createRangeOperation(_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.BytesRate), createRangeOperation(_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.BytesOverTime), createRangeOperation(_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.AbsentOverTime), createRangeOperation(_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.AvgOverTime), createRangeOperation(_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.MaxOverTime), createRangeOperation(_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.MinOverTime), createRangeOperation(_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.FirstOverTime), createRangeOperation(_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.LastOverTime), createRangeOperation(_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.StdvarOverTime), createRangeOperation(_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.StddevOverTime), createRangeOperation(_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.QuantileOverTime), ...aggregations, ...aggregationsWithParam, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Json,
    name: 'Json',
    params: [],
    defaultParams: [],
    alternativesKey: 'format',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.Formats,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.LineFormats,
    renderer: pipelineRenderer,
    addOperationHandler: addLokiOperation
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Logfmt,
    name: 'Logfmt',
    params: [],
    defaultParams: [],
    alternativesKey: 'format',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.Formats,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.LineFormats,
    renderer: pipelineRenderer,
    addOperationHandler: addLokiOperation,
    explainHandler: () => `This will extract all keys and values from a [logfmt](https://grafana.com/docs/loki/latest/logql/log_queries/#logfmt) formatted log line as labels. The extracted labels can be used in label filter expressions and used as values for a range aggregation via the unwrap operation.`
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Regexp,
    name: 'Regexp',
    params: [{
      name: 'String',
      type: 'string',
      hideName: true,
      placeholder: '<re>',
      description: 'The regexp expression that matches the structure of a log line.',
      minWidth: 20
    }],
    defaultParams: [''],
    alternativesKey: 'format',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.Formats,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.LineFormats,
    renderer: (model, def, innerExpr) => `${innerExpr} | regexp \`${model.params[0]}\``,
    addOperationHandler: addLokiOperation,
    explainHandler: () => `The [regexp parser](https://grafana.com/docs/loki/latest/logql/log_queries/#regular-expression) takes a single parameter | regexp "<re>" which is the regular expression using the Golang RE2 syntax. The regular expression must contain a least one named sub-match (e.g (?P<name>re)), each sub-match will extract a different label. The expression matches the structure of a log line. The extracted labels can be used in label filter expressions and used as values for a range aggregation via the unwrap operation.`
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Pattern,
    name: 'Pattern',
    params: [{
      name: 'String',
      type: 'string',
      hideName: true,
      placeholder: '<pattern-expression>',
      description: 'The expression that matches the structure of a log line.',
      minWidth: 20
    }],
    defaultParams: [''],
    alternativesKey: 'format',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.Formats,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.LineFormats,
    renderer: (model, def, innerExpr) => `${innerExpr} | pattern \`${model.params[0]}\``,
    addOperationHandler: addLokiOperation,
    explainHandler: () => `The [pattern parser](https://grafana.com/docs/loki/latest/logql/log_queries/#pattern) allows the explicit extraction of fields from log lines by defining a pattern expression (| pattern \`<pattern-expression>\`). The expression matches the structure of a log line. The extracted labels can be used in label filter expressions and used as values for a range aggregation via the unwrap operation.`
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Unpack,
    name: 'Unpack',
    params: [],
    defaultParams: [],
    alternativesKey: 'format',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.Formats,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.LineFormats,
    renderer: pipelineRenderer,
    addOperationHandler: addLokiOperation,
    explainHandler: () => `This will extract all keys and values from a JSON log line, [unpacking](https://grafana.com/docs/loki/latest/logql/log_queries/#unpack) all embedded labels in the pack stage. The extracted labels can be used in label filter expressions and used as values for a range aggregation via the unwrap operation.`
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.LineFormat,
    name: 'Line format',
    params: [{
      name: 'String',
      type: 'string',
      hideName: true,
      placeholder: '{{.status_code}}',
      description: 'A line template that can refer to stream labels and extracted labels.',
      minWidth: 20
    }],
    defaultParams: [''],
    alternativesKey: 'format',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.Formats,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.LineFormats,
    renderer: (model, def, innerExpr) => `${innerExpr} | line_format \`${model.params[0]}\``,
    addOperationHandler: addLokiOperation,
    explainHandler: () => `This will replace log line using a specified template. The template can refer to stream labels and extracted labels.

        Example: \`{{.status_code}} - {{.message}}\`

        [Read the docs](https://grafana.com/docs/loki/latest/logql/log_queries/#line-format-expression) for more.
        `
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.LabelFormat,
    name: 'Label format',
    params: [{
      name: 'Label',
      type: 'string'
    }, {
      name: 'Rename',
      type: 'string'
    }],
    defaultParams: ['', ''],
    alternativesKey: 'format',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.Formats,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.LineFormats,
    renderer: (model, def, innerExpr) => `${innerExpr} | label_format ${model.params[1]}=\`${model.params[0]}\``,
    addOperationHandler: addLokiOperation,
    explainHandler: () => `This will change name of label to desired new label. In the example below, label "error_level" will be renamed to "level".

        Example: error_level=\`level\`

        [Read the docs](https://grafana.com/docs/loki/latest/logql/log_queries/#labels-format-expression) for more.
        `
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.LineContains,
    name: 'Line contains',
    params: [{
      name: 'String',
      type: 'string',
      hideName: true,
      placeholder: 'Text to find',
      description: 'Find log lines that contains this text',
      minWidth: 20
    }],
    defaultParams: [''],
    alternativesKey: 'line filter',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.LineFilters,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.LineFilters,
    renderer: getLineFilterRenderer('|='),
    addOperationHandler: addLokiOperation,
    explainHandler: op => `Return log lines that contain string \`${op.params[0]}\`.`
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.LineContainsNot,
    name: 'Line does not contain',
    params: [{
      name: 'String',
      type: 'string',
      hideName: true,
      placeholder: 'Text to exclude',
      description: 'Find log lines that does not contain this text',
      minWidth: 26
    }],
    defaultParams: [''],
    alternativesKey: 'line filter',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.LineFilters,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.LineFilters,
    renderer: getLineFilterRenderer('!='),
    addOperationHandler: addLokiOperation,
    explainHandler: op => `Return log lines that does not contain string \`${op.params[0]}\`.`
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.LineMatchesRegex,
    name: 'Line contains regex match',
    params: [{
      name: 'Regex',
      type: 'string',
      hideName: true,
      placeholder: 'Pattern to match',
      description: 'Find log lines that match this regex pattern',
      minWidth: 30
    }],
    defaultParams: [''],
    alternativesKey: 'line filter',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.LineFilters,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.LineFilters,
    renderer: getLineFilterRenderer('|~'),
    addOperationHandler: addLokiOperation,
    explainHandler: op => `Return log lines that match regex \`${op.params[0]}\`.`
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.LineMatchesRegexNot,
    name: 'Line does not match regex',
    params: [{
      name: 'Regex',
      type: 'string',
      hideName: true,
      placeholder: 'Pattern to exclude',
      description: 'Find log lines that does not match this regex pattern',
      minWidth: 30
    }],
    defaultParams: [''],
    alternativesKey: 'line filter',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.LineFilters,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.LineFilters,
    renderer: getLineFilterRenderer('!~'),
    addOperationHandler: addLokiOperation,
    explainHandler: op => `Return log lines that does not match regex \`${op.params[0]}\`.`
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.LabelFilter,
    name: 'Label filter expression',
    params: [{
      name: 'Label',
      type: 'string'
    }, {
      name: 'Operator',
      type: 'string',
      options: ['=', '!=', '>', '<', '>=', '<=']
    }, {
      name: 'Value',
      type: 'string'
    }],
    defaultParams: ['', '=', ''],
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.LabelFilters,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.LabelFilters,
    renderer: labelFilterRenderer,
    addOperationHandler: addLokiOperation,
    explainHandler: () => `Label expression filter allows filtering using original and extracted labels.`
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.LabelFilterNoErrors,
    name: 'No pipeline errors',
    params: [],
    defaultParams: [],
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.LabelFilters,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.NoErrors,
    renderer: (model, def, innerExpr) => `${innerExpr} | __error__=\`\``,
    addOperationHandler: addLokiOperation,
    explainHandler: () => `Filter out all formatting and parsing errors.`
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Unwrap,
    name: 'Unwrap',
    params: [{
      name: 'Identifier',
      type: 'string',
      hideName: true,
      minWidth: 16,
      placeholder: 'Label key'
    }],
    defaultParams: [''],
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.Formats,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.Unwrap,
    renderer: (op, def, innerExpr) => `${innerExpr} | unwrap ${op.params[0]}`,
    addOperationHandler: addLokiOperation,
    explainHandler: op => {
      let label = String(op.params[0]).length > 0 ? op.params[0] : '<label>';
      return `Use the extracted label \`${label}\` as sample values instead of log lines for the subsequent range aggregation.`;
    }
  }, ..._binaryScalarOperations__WEBPACK_IMPORTED_MODULE_2__.binaryScalarOperations, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.NestedQuery,
    name: 'Binary operation with query',
    params: [],
    defaultParams: [],
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.BinaryOps,
    renderer: (model, def, innerExpr) => innerExpr,
    addOperationHandler: addNestedQueryHandler
  }];
  return list;
}

function createRangeOperation(name) {
  const params = [getRangeVectorParamDef()];
  const defaultParams = ['$__interval'];
  let renderer = operationWithRangeVectorRenderer;

  if (name === _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.QuantileOverTime) {
    defaultParams.push('0.95');
    params.push({
      name: 'Quantile',
      type: 'number'
    });
    renderer = operationWithRangeVectorRendererAndParam;
  }

  return {
    id: name,
    name: (0,_prometheus_querybuilder_shared_operationUtils__WEBPACK_IMPORTED_MODULE_0__.getPromAndLokiOperationDisplayName)(name),
    params,
    defaultParams,
    alternativesKey: 'range function',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.RangeFunctions,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.RangeVectorFunction,
    renderer,
    addOperationHandler: addLokiOperation,
    explainHandler: (op, def) => {
      var _FUNCTIONS$find$docum, _FUNCTIONS$find;

      let opDocs = (_FUNCTIONS$find$docum = (_FUNCTIONS$find = _syntax__WEBPACK_IMPORTED_MODULE_1__.FUNCTIONS.find(x => x.insertText === op.id)) === null || _FUNCTIONS$find === void 0 ? void 0 : _FUNCTIONS$find.documentation) !== null && _FUNCTIONS$find$docum !== void 0 ? _FUNCTIONS$find$docum : '';

      if (op.params[0] === '$__interval') {
        return `${opDocs} \`$__interval\` is variable that will be replaced with a calculated interval based on **Max data points**,  **Min interval** and query time range. You find these options you find under **Query options** at the right of the data source select dropdown.`;
      } else {
        return `${opDocs} The [range vector](https://grafana.com/docs/loki/latest/logql/metric_queries/#range-vector-aggregation) is set to \`${op.params[0]}\`.`;
      }
    }
  };
}

function getRangeVectorParamDef() {
  return {
    name: 'Range',
    type: 'string',
    options: ['$__interval', '$__range', '1m', '5m', '10m', '1h', '24h']
  };
}

function operationWithRangeVectorRenderer(model, def, innerExpr) {
  var _, _model$params;

  let rangeVector = (_ = ((_model$params = model.params) !== null && _model$params !== void 0 ? _model$params : [])[0]) !== null && _ !== void 0 ? _ : '$__interval';
  return `${def.id}(${innerExpr} [${rangeVector}])`;
}

function operationWithRangeVectorRendererAndParam(model, def, innerExpr) {
  var _model$params2, _params$;

  const params = (_model$params2 = model.params) !== null && _model$params2 !== void 0 ? _model$params2 : [];
  const rangeVector = (_params$ = params[0]) !== null && _params$ !== void 0 ? _params$ : '$__interval';
  const param = params[1];
  return `${def.id}(${param}, ${innerExpr} [${rangeVector}])`;
}

function getLineFilterRenderer(operation) {
  return function lineFilterRenderer(model, def, innerExpr) {
    if (model.params[0] === '') {
      return innerExpr;
    }

    return `${innerExpr} ${operation} \`${model.params[0]}\``;
  };
}

function labelFilterRenderer(model, def, innerExpr) {
  if (model.params[0] === '') {
    return innerExpr;
  }

  if (model.params[1] === '<' || model.params[1] === '>') {
    return `${innerExpr} | ${model.params[0]} ${model.params[1]} ${model.params[2]}`;
  }

  return `${innerExpr} | ${model.params[0]}${model.params[1]}\`${model.params[2]}\``;
}

function pipelineRenderer(model, def, innerExpr) {
  return `${innerExpr} | ${model.id}`;
}

function isRangeVectorFunction(def) {
  return def.category === _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.RangeFunctions;
}

function getIndexOfOrLast(operations, queryModeller, condition) {
  const index = operations.findIndex(x => {
    const opDef = queryModeller.getOperationDef(x.id);

    if (!opDef) {
      return false;
    }

    return condition(opDef);
  });
  return index === -1 ? operations.length : index;
}

function addLokiOperation(def, query, modeller) {
  const newOperation = {
    id: def.id,
    params: def.defaultParams
  };
  const operations = [...query.operations];
  const existingRangeVectorFunction = operations.find(x => {
    const opDef = modeller.getOperationDef(x.id);

    if (!opDef) {
      return false;
    }

    return isRangeVectorFunction(opDef);
  });

  switch (def.category) {
    case _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.Aggregations:
    case _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.Functions:
      // If we are adding a function but we have not range vector function yet add one
      if (!existingRangeVectorFunction) {
        const placeToInsert = getIndexOfOrLast(operations, modeller, def => def.category === _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.Functions);
        operations.splice(placeToInsert, 0, {
          id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Rate,
          params: ['$__interval']
        });
      }

      operations.push(newOperation);
      break;

    case _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.RangeFunctions:
      // If adding a range function and range function is already added replace it
      if (existingRangeVectorFunction) {
        const index = operations.indexOf(existingRangeVectorFunction);
        operations[index] = newOperation;
        break;
      }

    // Add range functions after any formats, line filters and label filters

    default:
      const placeToInsert = getIndexOfOrLast(operations, modeller, x => {
        var _def$orderRank, _x$orderRank;

        return ((_def$orderRank = def.orderRank) !== null && _def$orderRank !== void 0 ? _def$orderRank : 100) < ((_x$orderRank = x.orderRank) !== null && _x$orderRank !== void 0 ? _x$orderRank : 100);
      });
      operations.splice(placeToInsert, 0, newOperation);
      break;
  }

  return Object.assign({}, query, {
    operations
  });
}

function addNestedQueryHandler(def, query) {
  var _query$binaryQueries;

  return Object.assign({}, query, {
    binaryQueries: [...((_query$binaryQueries = query.binaryQueries) !== null && _query$binaryQueries !== void 0 ? _query$binaryQueries : []), {
      operator: '/',
      query
    }]
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/parsing.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "buildVisualQueryFromString": () => (/* binding */ buildVisualQueryFromString),
/* harmony export */   "handleExpression": () => (/* binding */ handleExpression)
/* harmony export */ });
/* harmony import */ var _grafana_lezer_logql__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@grafana-lezer-logql-virtual-9250dbecf8/0/cache/@grafana-lezer-logql-npm-0.0.11-d7d249e74a-0427e59528.zip/node_modules/@grafana/lezer-logql/index.es.js");
/* harmony import */ var _prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/parsingUtils.ts");
/* harmony import */ var _binaryScalarOperations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/binaryScalarOperations.ts");



function buildVisualQueryFromString(expr) {
  const replacedExpr = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.replaceVariables)(expr);
  const tree = _grafana_lezer_logql__WEBPACK_IMPORTED_MODULE_0__.parser.parse(replacedExpr);
  const node = tree.topNode; // This will be modified in the handleExpression

  const visQuery = {
    labels: [],
    operations: []
  };
  const context = {
    query: visQuery,
    errors: []
  };

  try {
    handleExpression(replacedExpr, node, context);
  } catch (err) {
    // Not ideal to log it here, but otherwise we would lose the stack trace.
    console.error(err);
    context.errors.push({
      text: err.message
    });
  } // If we have empty query, we want to reset errors


  if (isEmptyQuery(context.query)) {
    context.errors = [];
  }

  return context;
}
function handleExpression(expr, node, context) {
  const visQuery = context.query;

  switch (node.name) {
    case 'Matcher':
      {
        visQuery.labels.push(getLabel(expr, node));
        const err = node.getChild(_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.ErrorName);

        if (err) {
          context.errors.push((0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.makeError)(expr, err));
        }

        break;
      }

    case 'LineFilter':
      {
        const {
          operation,
          error
        } = getLineFilter(expr, node);

        if (operation) {
          visQuery.operations.push(operation);
        } // Show error for query patterns not supported in visual query builder


        if (error) {
          context.errors.push(createNotSupportedError(expr, node, error));
        }

        break;
      }

    case 'LabelParser':
      {
        visQuery.operations.push(getLabelParser(expr, node));
        break;
      }

    case 'LabelFilter':
      {
        const {
          operation,
          error
        } = getLabelFilter(expr, node);

        if (operation) {
          visQuery.operations.push(operation);
        } // Show error for query patterns not supported in visual query builder


        if (error) {
          context.errors.push(createNotSupportedError(expr, node, error));
        }

        break;
      }

    case 'JsonExpressionParser':
      {
        // JsonExpressionParser is not supported in query builder
        const error = 'JsonExpressionParser not supported in visual query builder';
        context.errors.push(createNotSupportedError(expr, node, error));
      }

    case 'LineFormatExpr':
      {
        visQuery.operations.push(getLineFormat(expr, node));
        break;
      }

    case 'LabelFormatMatcher':
      {
        visQuery.operations.push(getLabelFormat(expr, node));
        break;
      }

    case 'UnwrapExpr':
      {
        const {
          operation,
          error
        } = getUnwrap(expr, node);

        if (operation) {
          visQuery.operations.push(operation);
        } // Show error for query patterns not supported in visual query builder


        if (error) {
          context.errors.push(createNotSupportedError(expr, node, error));
        }

        break;
      }

    case 'RangeAggregationExpr':
      {
        visQuery.operations.push(handleRangeAggregation(expr, node, context));
        break;
      }

    case 'VectorAggregationExpr':
      {
        visQuery.operations.push(handleVectorAggregation(expr, node, context));
        break;
      }

    case 'BinOpExpr':
      {
        handleBinary(expr, node, context);
        break;
      }

    case _prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.ErrorName:
      {
        if (isIntervalVariableError(node)) {
          break;
        }

        context.errors.push((0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.makeError)(expr, node));
        break;
      }

    default:
      {
        // Any other nodes we just ignore and go to it's children. This should be fine as there are lot's of wrapper
        // nodes that can be skipped.
        // TODO: there are probably cases where we will just skip nodes we don't support and we should be able to
        //  detect those and report back.
        let child = node.firstChild;

        while (child) {
          handleExpression(expr, child, context);
          child = child.nextSibling;
        }
      }
  }
}

function getLabel(expr, node) {
  const labelNode = node.getChild('Identifier');
  const label = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, labelNode);
  const op = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, labelNode.nextSibling);
  const value = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, node.getChild('String')).replace(/"/g, '');
  return {
    label,
    op,
    value
  };
}

function getLineFilter(expr, node) {
  // Check for nodes not supported in visual builder and return error
  const ipLineFilter = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getAllByType)(expr, node, 'Ip');

  if (ipLineFilter.length > 0) {
    return {
      error: 'Matching ip addresses not supported in query builder'
    };
  }

  const mapFilter = {
    '|=': '__line_contains',
    '!=': '__line_contains_not',
    '|~': '__line_matches_regex',
    '!~': '"__line_matches_regex"_not'
  };
  const filter = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, node.getChild('Filter'));
  const filterExpr = handleQuotes((0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, node.getChild('String')));
  return {
    operation: {
      id: mapFilter[filter],
      params: [filterExpr]
    }
  };
}

function getLabelParser(expr, node) {
  const parserNode = node.firstChild;
  const parser = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, parserNode);
  const string = handleQuotes((0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, node.getChild('String')));
  const params = !!string ? [string] : [];
  return {
    id: parser,
    params
  };
}

function getLabelFilter(expr, node) {
  // Check for nodes not supported in visual builder and return error
  if (node.getChild('Or') || node.getChild('And') || node.getChild('Comma')) {
    return {
      error: 'Label filter with comma, "and", "or" not supported in query builder'
    };
  }

  if (node.firstChild.name === 'IpLabelFilter') {
    return {
      error: 'IpLabelFilter not supported in query builder'
    };
  }

  const id = '__label_filter';

  if (node.firstChild.name === 'UnitFilter') {
    const filter = node.firstChild.firstChild;
    const label = filter.firstChild;
    const op = label.nextSibling;
    const value = op.nextSibling;
    const valueString = handleQuotes((0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, value));
    return {
      operation: {
        id,
        params: [(0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, label), (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, op), valueString]
      }
    };
  } // In this case it is Matcher or NumberFilter


  const filter = node.firstChild;
  const label = filter.firstChild;
  const op = label.nextSibling;
  const value = op.nextSibling;
  const params = [(0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, label), (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, op), handleQuotes((0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, value))]; // Special case of pipe filtering - no errors

  if (params.join('') === `__error__=`) {
    return {
      operation: {
        id: '__label_filter_no_errors',
        params: []
      }
    };
  }

  return {
    operation: {
      id,
      params
    }
  };
}

function getLineFormat(expr, node) {
  const id = 'line_format';
  const string = handleQuotes((0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, node.getChild('String')));
  return {
    id,
    params: [string]
  };
}

function getLabelFormat(expr, node) {
  const id = 'label_format';
  const identifier = node.getChild('Identifier');
  const op = identifier.nextSibling;
  const value = op.nextSibling;
  let valueString = handleQuotes((0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, value));
  return {
    id,
    params: [(0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, identifier), valueString]
  };
}

function getUnwrap(expr, node) {
  // Check for nodes not supported in visual builder and return error
  if (node.getChild('ConvOp')) {
    return {
      error: 'Unwrap with conversion operator not supported in query builder'
    };
  }

  const id = 'unwrap';
  const string = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, node.getChild('Identifier'));
  return {
    operation: {
      id,
      params: [string]
    }
  };
}

function handleRangeAggregation(expr, node, context) {
  const nameNode = node.getChild('RangeOp');
  const funcName = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, nameNode);
  const number = node.getChild('Number');
  const logExpr = node.getChild('LogRangeExpr');
  const params = number !== null && number !== undefined ? [(0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, number)] : [];
  let match = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, node).match(/\[(.+)\]/);

  if (match !== null && match !== void 0 && match[1]) {
    params.push(match[1]);
  }

  const op = {
    id: funcName,
    params
  };

  if (logExpr) {
    handleExpression(expr, logExpr, context);
  }

  return op;
}

function handleVectorAggregation(expr, node, context) {
  const nameNode = node.getChild('VectorOp');
  let funcName = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, nameNode);
  const grouping = node.getChild('Grouping');
  const labels = [];

  if (grouping) {
    const byModifier = grouping.getChild(`By`);

    if (byModifier && funcName) {
      funcName = `__${funcName}_by`;
    }

    const withoutModifier = grouping.getChild(`Without`);

    if (withoutModifier) {
      funcName = `__${funcName}_without`;
    }

    labels.push(...(0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getAllByType)(expr, grouping, 'Identifier'));
  }

  const metricExpr = node.getChild('MetricExpr');
  const op = {
    id: funcName,
    params: labels
  };

  if (metricExpr) {
    handleExpression(expr, metricExpr, context);
  }

  return op;
}

const operatorToOpName = _binaryScalarOperations__WEBPACK_IMPORTED_MODULE_2__.binaryScalarDefs.reduce((acc, def) => {
  acc[def.sign] = {
    id: def.id,
    comparison: def.comparison
  };
  return acc;
}, {});
/**
 * Right now binary expressions can be represented in 2 way in visual query. As additional operation in case it is
 * just operation with scalar or it creates a binaryQuery when it's 2 queries.
 * @param expr
 * @param node
 * @param context
 */

function handleBinary(expr, node, context) {
  const visQuery = context.query;
  const left = node.firstChild;
  const op = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, left.nextSibling);
  const binModifier = getBinaryModifier(expr, node.getChild('BinModifiers'));
  const right = node.lastChild;
  const opDef = operatorToOpName[op];
  const leftNumber = getLastChildWithSelector(left, 'MetricExpr.LiteralExpr.Number');
  const rightNumber = getLastChildWithSelector(right, 'MetricExpr.LiteralExpr.Number');
  const rightBinary = right.getChild('BinOpExpr');

  if (leftNumber) {// TODO: this should be already handled in case parent is binary expression as it has to be added to parent
    //  if query starts with a number that isn't handled now.
  } else {
    // If this is binary we don't really know if there is a query or just chained scalars. So
    // we have to traverse a bit deeper to know
    handleExpression(expr, left, context);
  }

  if (rightNumber) {
    visQuery.operations.push((0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.makeBinOp)(opDef, expr, right, !!(binModifier !== null && binModifier !== void 0 && binModifier.isBool)));
  } else if (rightBinary) {
    // Due to the way binary ops are parsed we can get a binary operation on the right that starts with a number which
    // is a factor for a current binary operation. So we have to add it as an operation now.
    const leftMostChild = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getLeftMostChild)(right);

    if ((leftMostChild === null || leftMostChild === void 0 ? void 0 : leftMostChild.name) === 'Number') {
      visQuery.operations.push((0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.makeBinOp)(opDef, expr, leftMostChild, !!(binModifier !== null && binModifier !== void 0 && binModifier.isBool)));
    } // If we added the first number literal as operation here we still can continue and handle the rest as the first
    // number will be just skipped.


    handleExpression(expr, right, context);
  } else {
    visQuery.binaryQueries = visQuery.binaryQueries || [];
    const binQuery = {
      operator: op,
      query: {
        labels: [],
        operations: []
      }
    };

    if (binModifier !== null && binModifier !== void 0 && binModifier.isMatcher) {
      binQuery.vectorMatchesType = binModifier.matchType;
      binQuery.vectorMatches = binModifier.matches;
    }

    visQuery.binaryQueries.push(binQuery);
    handleExpression(expr, right, {
      query: binQuery.query,
      errors: context.errors
    });
  }
}

function getBinaryModifier(expr, node) {
  if (!node) {
    return undefined;
  }

  if (node.getChild('Bool')) {
    return {
      isBool: true,
      isMatcher: false
    };
  } else {
    var _matcher$getChild;

    const matcher = node.getChild('OnOrIgnoring');

    if (!matcher) {
      // Not sure what this could be, maybe should be an error.
      return undefined;
    }

    const labels = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, (_matcher$getChild = matcher.getChild('GroupingLabels')) === null || _matcher$getChild === void 0 ? void 0 : _matcher$getChild.getChild('GroupingLabelList'));
    return {
      isMatcher: true,
      isBool: false,
      matches: labels,
      matchType: matcher.getChild('On') ? 'on' : 'ignoring'
    };
  }
}

function isIntervalVariableError(node) {
  var _node$parent;

  return (node === null || node === void 0 ? void 0 : (_node$parent = node.parent) === null || _node$parent === void 0 ? void 0 : _node$parent.name) === 'Range';
}

function handleQuotes(string) {
  if (string[0] === `"` && string[string.length - 1] === `"`) {
    return string.replace(/"/g, '').replace(/\\\\/g, '\\');
  }

  return string.replace(/`/g, '');
}
/**
 * Simple helper to traverse the syntax tree. Instead of node.getChild('foo')?.getChild('bar')?.getChild('baz') you
 * can write getChildWithSelector(node, 'foo.bar.baz')
 * @param node
 * @param selector
 */


function getLastChildWithSelector(node, selector) {
  let child = node;
  const children = selector.split('.');

  for (const s of children) {
    child = child.getChild(s);

    if (!child) {
      return null;
    }
  }

  return child;
}
/**
 * Helper function to enrich error text with information that visual query builder doesn't support that logQL
 * @param expr
 * @param node
 * @param error
 */


function createNotSupportedError(expr, node, error) {
  const err = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.makeError)(expr, node);
  err.text = `${error}: ${err.text}`;
  return err;
}

function isEmptyQuery(query) {
  if (query.labels.length === 0 && query.operations.length === 0) {
    return true;
  }

  return false;
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/state.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "changeEditorMode": () => (/* binding */ changeEditorMode),
/* harmony export */   "getDefaultEditorMode": () => (/* binding */ getDefaultEditorMode),
/* harmony export */   "getQueryWithDefaults": () => (/* binding */ getQueryWithDefaults)
/* harmony export */ });
/* harmony import */ var app_core_store__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/core/store.ts");
/* harmony import */ var _prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/types.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/loki/types.ts");



const queryEditorModeDefaultLocalStorageKey = 'LokiQueryEditorModeDefault';
function changeEditorMode(query, editorMode, onChange) {
  // If empty query store new mode as default
  if (query.expr === '') {
    app_core_store__WEBPACK_IMPORTED_MODULE_0__["default"].set(queryEditorModeDefaultLocalStorageKey, editorMode);
  }

  onChange(Object.assign({}, query, {
    editorMode
  }));
}
function getDefaultEditorMode(expr) {
  // If we already have an expression default to code view
  if (expr != null && expr !== '') {
    return _prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_1__.QueryEditorMode.Code;
  }

  const value = app_core_store__WEBPACK_IMPORTED_MODULE_0__["default"].get(queryEditorModeDefaultLocalStorageKey);

  switch (value) {
    case _prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_1__.QueryEditorMode.Builder:
    case _prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_1__.QueryEditorMode.Code:
    case _prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_1__.QueryEditorMode.Explain:
      return value;

    default:
      return _prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_1__.QueryEditorMode.Builder;
  }
}
/**
 * Returns query with defaults, and boolean true/false depending on change was required
 */

function getQueryWithDefaults(query) {
  // If no expr (ie new query) then default to builder
  let result = query;

  if (!query.editorMode) {
    result = Object.assign({}, query, {
      editorMode: getDefaultEditorMode(query.expr)
    });
  }

  if (query.expr == null) {
    result = Object.assign({}, result, {
      expr: ''
    });
  }

  if (query.queryType == null) {
    // Default to range query
    result = Object.assign({}, result, {
      queryType: _types__WEBPACK_IMPORTED_MODULE_2__.LokiQueryType.Range
    });
  }

  return result;
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/types.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiOperationId": () => (/* binding */ LokiOperationId),
/* harmony export */   "LokiOperationOrder": () => (/* binding */ LokiOperationOrder),
/* harmony export */   "LokiVisualQueryOperationCategory": () => (/* binding */ LokiVisualQueryOperationCategory)
/* harmony export */ });
/**
 * Visual query model
 */
let LokiVisualQueryOperationCategory;

(function (LokiVisualQueryOperationCategory) {
  LokiVisualQueryOperationCategory["Aggregations"] = "Aggregations";
  LokiVisualQueryOperationCategory["RangeFunctions"] = "Range functions";
  LokiVisualQueryOperationCategory["Functions"] = "Functions";
  LokiVisualQueryOperationCategory["Formats"] = "Formats";
  LokiVisualQueryOperationCategory["LineFilters"] = "Line filters";
  LokiVisualQueryOperationCategory["LabelFilters"] = "Label filters";
  LokiVisualQueryOperationCategory["BinaryOps"] = "Binary operations";
})(LokiVisualQueryOperationCategory || (LokiVisualQueryOperationCategory = {}));

let LokiOperationId;

(function (LokiOperationId) {
  LokiOperationId["Json"] = "json";
  LokiOperationId["Logfmt"] = "logfmt";
  LokiOperationId["Regexp"] = "regexp";
  LokiOperationId["Pattern"] = "pattern";
  LokiOperationId["Unpack"] = "unpack";
  LokiOperationId["LineFormat"] = "line_format";
  LokiOperationId["LabelFormat"] = "label_format";
  LokiOperationId["Rate"] = "rate";
  LokiOperationId["CountOverTime"] = "count_over_time";
  LokiOperationId["SumOverTime"] = "sum_over_time";
  LokiOperationId["AvgOverTime"] = "avg_over_time";
  LokiOperationId["MaxOverTime"] = "max_over_time";
  LokiOperationId["MinOverTime"] = "min_over_time";
  LokiOperationId["FirstOverTime"] = "first_over_time";
  LokiOperationId["LastOverTime"] = "last_over_time";
  LokiOperationId["StdvarOverTime"] = "stdvar_over_time";
  LokiOperationId["StddevOverTime"] = "stddev_over_time";
  LokiOperationId["QuantileOverTime"] = "quantile_over_time";
  LokiOperationId["BytesRate"] = "bytes_rate";
  LokiOperationId["BytesOverTime"] = "bytes_over_time";
  LokiOperationId["AbsentOverTime"] = "absent_over_time";
  LokiOperationId["Sum"] = "sum";
  LokiOperationId["Avg"] = "avg";
  LokiOperationId["Min"] = "min";
  LokiOperationId["Max"] = "max";
  LokiOperationId["Stddev"] = "stddev";
  LokiOperationId["Stdvar"] = "stdvar";
  LokiOperationId["Count"] = "count";
  LokiOperationId["TopK"] = "topk";
  LokiOperationId["BottomK"] = "bottomk";
  LokiOperationId["LineContains"] = "__line_contains";
  LokiOperationId["LineContainsNot"] = "__line_contains_not";
  LokiOperationId["LineMatchesRegex"] = "__line_matches_regex";
  LokiOperationId["LineMatchesRegexNot"] = "__line_matches_regex_not";
  LokiOperationId["LabelFilter"] = "__label_filter";
  LokiOperationId["LabelFilterNoErrors"] = "__label_filter_no_errors";
  LokiOperationId["Unwrap"] = "unwrap";
  LokiOperationId["Addition"] = "__addition";
  LokiOperationId["Subtraction"] = "__subtraction";
  LokiOperationId["MultiplyBy"] = "__multiply_by";
  LokiOperationId["DivideBy"] = "__divide_by";
  LokiOperationId["Modulo"] = "__modulo";
  LokiOperationId["Exponent"] = "__exponent";
  LokiOperationId["NestedQuery"] = "__nested_query";
  LokiOperationId["EqualTo"] = "__equal_to";
  LokiOperationId["NotEqualTo"] = "__not_equal_to";
  LokiOperationId["GreaterThan"] = "__greater_than";
  LokiOperationId["LessThan"] = "__less_than";
  LokiOperationId["GreaterOrEqual"] = "__greater_or_equal";
  LokiOperationId["LessOrEqual"] = "__less_or_equal";
})(LokiOperationId || (LokiOperationId = {}));

let LokiOperationOrder;

(function (LokiOperationOrder) {
  LokiOperationOrder[LokiOperationOrder["LineFilters"] = 1] = "LineFilters";
  LokiOperationOrder[LokiOperationOrder["LineFormats"] = 2] = "LineFormats";
  LokiOperationOrder[LokiOperationOrder["LabelFilters"] = 3] = "LabelFilters";
  LokiOperationOrder[LokiOperationOrder["Unwrap"] = 4] = "Unwrap";
  LokiOperationOrder[LokiOperationOrder["NoErrors"] = 5] = "NoErrors";
  LokiOperationOrder[LokiOperationOrder["RangeVectorFunction"] = 5] = "RangeVectorFunction";
  LokiOperationOrder[LokiOperationOrder["Last"] = 6] = "Last";
})(LokiOperationOrder || (LokiOperationOrder = {}));

/***/ }),

/***/ "./public/app/plugins/datasource/loki/result_transformer.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "appendResponseToBufferedData": () => (/* binding */ appendResponseToBufferedData),
/* harmony export */   "createMetricLabel": () => (/* binding */ createMetricLabel),
/* harmony export */   "decamelize": () => (/* binding */ decamelize),
/* harmony export */   "enhanceDataFrame": () => (/* binding */ enhanceDataFrame),
/* harmony export */   "lokiPointsToTimeseriesPoints": () => (/* binding */ lokiPointsToTimeseriesPoints),
/* harmony export */   "lokiResultsToTableModel": () => (/* binding */ lokiResultsToTableModel),
/* harmony export */   "lokiStreamsToDataFrames": () => (/* binding */ lokiStreamsToDataFrames),
/* harmony export */   "lokiStreamsToRawDataFrame": () => (/* binding */ lokiStreamsToRawDataFrame),
/* harmony export */   "processRangeQueryResponse": () => (/* binding */ processRangeQueryResponse),
/* harmony export */   "rangeQueryResponseToDataFrames": () => (/* binding */ rangeQueryResponseToDataFrames)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/of.js");
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/cache/uuid-npm-8.3.2-eca0baba53-5575a8a75c.zip/node_modules/uuid/dist/esm-browser/v5.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var app_core_table_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/core/table_model.ts");
/* harmony import */ var _prometheus_legend__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/legend.ts");
/* harmony import */ var _query_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/loki/query_utils.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/loki/types.ts");









const UUID_NAMESPACE = '6ec946da-0f49-47a8-983a-1d76d17e7c92';
/**
 * Transforms LokiStreamResult structure into a dataFrame. Used when doing standard queries
 */

function lokiStreamsToRawDataFrame(streams, refId) {
  const labels = new _grafana_data__WEBPACK_IMPORTED_MODULE_1__.ArrayVector([]);
  const times = new _grafana_data__WEBPACK_IMPORTED_MODULE_1__.ArrayVector([]);
  const timesNs = new _grafana_data__WEBPACK_IMPORTED_MODULE_1__.ArrayVector([]);
  const lines = new _grafana_data__WEBPACK_IMPORTED_MODULE_1__.ArrayVector([]);
  const uids = new _grafana_data__WEBPACK_IMPORTED_MODULE_1__.ArrayVector([]); // We need to store and track all used uids to ensure that uids are unique

  const usedUids = {};

  for (const stream of streams) {
    const streamLabels = stream.stream;
    const labelsString = Object.entries(streamLabels).map(([key, val]) => `${key}="${val}"`).sort().join('');

    for (const [ts, line] of stream.values) {
      labels.add(streamLabels); // num ns epoch in string, we convert it to iso string here so it matches old format

      times.add(new Date(parseInt(ts.slice(0, -6), 10)).toISOString());
      timesNs.add(ts);
      lines.add(line);
      uids.add(createUid(ts, labelsString, line, usedUids, refId));
    }
  }

  return constructDataFrame(times, timesNs, lines, uids, labels, refId);
}
/**
 * Constructs dataFrame with supplied fields and other data.
 */

function constructDataFrame(times, timesNs, lines, uids, labels, refId) {
  const dataFrame = {
    refId,
    fields: [{
      name: 'labels',
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_1__.FieldType.other,
      config: {},
      values: labels
    }, {
      name: 'ts',
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_1__.FieldType.time,
      config: {
        displayName: 'Time'
      },
      values: times
    }, // Time
    {
      name: 'line',
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_1__.FieldType.string,
      config: {},
      values: lines
    }, // Line - needs to be the first field with string type
    {
      name: 'tsNs',
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_1__.FieldType.time,
      config: {
        displayName: 'Time ns'
      },
      values: timesNs
    }, // Time
    {
      name: 'id',
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_1__.FieldType.string,
      config: {},
      values: uids
    }],
    length: times.length
  };
  return dataFrame;
}
/**
 * Transform LokiResponse data and appends it to MutableDataFrame. Used for streaming where the dataFrame can be
 * a CircularDataFrame creating a fixed size rolling buffer.
 * TODO: Probably could be unified with the logStreamToDataFrame function.
 * @param response
 * @param data Needs to have ts, line, labels, id as fields
 */


function appendResponseToBufferedData(response, data) {
  // Should we do anything with: response.dropped_entries?
  const streams = response.streams;

  if (!streams || !streams.length) {
    return;
  }

  let baseLabels = {};

  for (const f of data.fields) {
    if (f.type === _grafana_data__WEBPACK_IMPORTED_MODULE_1__.FieldType.string) {
      if (f.labels) {
        baseLabels = f.labels;
      }

      break;
    }
  }

  const labelsField = data.fields[0];
  const tsField = data.fields[1];
  const lineField = data.fields[2];
  const idField = data.fields[3];
  const tsNsField = data.fields[4]; // We are comparing used ids only within the received stream. This could be a problem if the same line + labels + nanosecond timestamp came in 2 separate batches.
  // As this is very unlikely, and the result would only affect live-tailing css animation we have decided to not compare all received uids from data param as this would slow down processing.

  const usedUids = {};

  for (const stream of streams) {
    // Find unique labels
    const unique = (0,_grafana_data__WEBPACK_IMPORTED_MODULE_1__.findUniqueLabels)(stream.stream, baseLabels);
    const allLabelsString = Object.entries(stream.stream).map(([key, val]) => `${key}="${val}"`).sort().join(''); // Add each line

    for (const [ts, line] of stream.values) {
      tsField.values.add(new Date(parseInt(ts.slice(0, -6), 10)).toISOString());
      tsNsField.values.add(ts);
      lineField.values.add(line);
      labelsField.values.add(unique);
      idField.values.add(createUid(ts, allLabelsString, line, usedUids, data.refId));
    }
  }
}

function createUid(ts, labelsString, line, usedUids, refId) {
  // Generate id as hashed nanosecond timestamp, labels and line (this does not have to be unique)
  let id = (0,uuid__WEBPACK_IMPORTED_MODULE_7__["default"])(`${ts}_${labelsString}_${line}`, UUID_NAMESPACE); // Check if generated id is unique
  // If not and we've already used it, append it's count after it

  if (id in usedUids) {
    // Increase the count
    const newCount = usedUids[id] + 1;
    usedUids[id] = newCount; // Append count to generated id to make it unique

    id = `${id}_${newCount}`;
  } else {
    // If id is unique and wasn't used, add it to usedUids and start count at 0
    usedUids[id] = 0;
  } // Return unique id


  if (refId) {
    return `${id}_${refId}`;
  }

  return id;
}

function lokiMatrixToTimeSeries(matrixResult, options) {
  const name = createMetricLabel(matrixResult.metric, options);
  return {
    target: name,
    title: name,
    datapoints: lokiPointsToTimeseriesPoints(matrixResult.values),
    tags: matrixResult.metric,
    meta: options.meta,
    refId: options.refId
  };
}

function parsePrometheusFormatSampleValue(value) {
  switch (value) {
    case '+Inf':
      return Number.POSITIVE_INFINITY;

    case '-Inf':
      return Number.NEGATIVE_INFINITY;

    default:
      return parseFloat(value);
  }
}

function lokiPointsToTimeseriesPoints(data) {
  const datapoints = [];

  for (const [time, value] of data) {
    let datapointValue = parsePrometheusFormatSampleValue(value);
    const timestamp = time * 1000;
    datapoints.push([datapointValue, timestamp]);
  }

  return datapoints;
}
function lokiResultsToTableModel(lokiResults, resultCount, refId, meta) {
  if (!lokiResults || lokiResults.length === 0) {
    return new app_core_table_model__WEBPACK_IMPORTED_MODULE_3__["default"]();
  } // Collect all labels across all metrics


  const metricLabels = new Set(lokiResults.reduce((acc, cur) => acc.concat(Object.keys(cur.metric)), [])); // Sort metric labels, create columns for them and record their index

  const sortedLabels = [...metricLabels.values()].sort();
  const table = new app_core_table_model__WEBPACK_IMPORTED_MODULE_3__["default"]();
  table.refId = refId;
  table.meta = meta;
  table.columns = [{
    text: 'Time',
    type: _grafana_data__WEBPACK_IMPORTED_MODULE_1__.FieldType.time
  }, ...sortedLabels.map(label => ({
    text: label,
    filterable: true,
    type: _grafana_data__WEBPACK_IMPORTED_MODULE_1__.FieldType.string
  })), {
    text: `Value #${refId}`,
    type: _grafana_data__WEBPACK_IMPORTED_MODULE_1__.FieldType.number
  }]; // Populate rows, set value to empty string when label not present.

  lokiResults.forEach(series => {
    const newSeries = {
      metric: series.metric,
      values: series.value ? [series.value] : series.values
    };

    if (!newSeries.values) {
      return;
    }

    if (!newSeries.metric) {
      table.rows.concat(newSeries.values.map(([a, b]) => [a * 1000, parseFloat(b)]));
    } else {
      table.rows.push(...newSeries.values.map(([a, b]) => [a * 1000, ...sortedLabels.map(label => newSeries.metric[label] || ''), parseFloat(b)]));
    }
  });
  return table;
}
function createMetricLabel(labelData, options) {
  var _options$legendFormat;

  let label = options === undefined || (0,lodash__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(options.legendFormat) ? getOriginalMetricName(labelData) : (0,_prometheus_legend__WEBPACK_IMPORTED_MODULE_4__.renderLegendFormat)((0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_2__.getTemplateSrv)().replace((_options$legendFormat = options.legendFormat) !== null && _options$legendFormat !== void 0 ? _options$legendFormat : '', options.scopedVars), labelData);

  if (!label && options) {
    label = options.query;
  }

  return label;
}

function getOriginalMetricName(labelData) {
  const labelPart = Object.entries(labelData).map(label => `${label[0]}="${label[1]}"`).join(',');
  return `{${labelPart}}`;
}

function decamelize(s) {
  return s.replace(/[A-Z]/g, m => ` ${m.toLowerCase()}`);
} // Turn loki stats { metric: value } into meta stat { title: metric, value: value }

function lokiStatsToMetaStat(stats) {
  const result = [];

  if (!stats) {
    return result;
  }

  for (const section in stats) {
    const values = stats[section];

    for (const label in values) {
      const value = values[label];
      let unit;

      if (/time/i.test(label) && value) {
        unit = 's';
      } else if (/bytes.*persecond/i.test(label)) {
        unit = 'Bps';
      } else if (/bytes/i.test(label)) {
        unit = 'decbytes';
      }

      const title = `${(0,lodash__WEBPACK_IMPORTED_MODULE_0__.capitalize)(section)}: ${decamelize(label)}`;
      result.push({
        displayName: title,
        value,
        unit
      });
    }
  }

  return result;
}

function lokiStreamsToDataFrames(response, target, limit, config) {
  const data = limit > 0 ? response.data.result : [];
  const stats = lokiStatsToMetaStat(response.data.stats); // Use custom mechanism to identify which stat we want to promote to label

  const custom = {
    lokiQueryStatKey: 'Summary: total bytes processed'
  };
  const meta = {
    searchWords: (0,_query_utils__WEBPACK_IMPORTED_MODULE_5__.getHighlighterExpressionsFromQuery)((0,_query_utils__WEBPACK_IMPORTED_MODULE_5__.formatQuery)(target.expr)),
    limit,
    stats,
    custom,
    preferredVisualisationType: 'logs'
  };
  const dataFrame = lokiStreamsToRawDataFrame(data, target.refId);
  enhanceDataFrame(dataFrame, config);

  if (meta.custom && dataFrame.fields.some(f => f.labels && Object.keys(f.labels).some(l => l === '__error__'))) {
    meta.custom.error = 'Error when parsing some of the logs';
  }

  if (stats.length && !data.length) {
    return [{
      fields: [],
      length: 0,
      refId: target.refId,
      meta
    }];
  }

  return [Object.assign({}, dataFrame, {
    refId: target.refId,
    meta
  })];
}
/**
 * Adds new fields and DataLinks to DataFrame based on DataSource instance config.
 */

const enhanceDataFrame = (dataFrame, config) => {
  var _config$derivedFields;

  if (!config) {
    return;
  }

  const derivedFields = (_config$derivedFields = config.derivedFields) !== null && _config$derivedFields !== void 0 ? _config$derivedFields : [];

  if (!derivedFields.length) {
    return;
  }

  const derivedFieldsGrouped = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.groupBy)(derivedFields, 'name');
  const newFields = Object.values(derivedFieldsGrouped).map(fieldFromDerivedFieldConfig);
  const view = new _grafana_data__WEBPACK_IMPORTED_MODULE_1__.DataFrameView(dataFrame);
  view.forEach(row => {
    for (const field of newFields) {
      const logMatch = row.line.match(derivedFieldsGrouped[field.name][0].matcherRegex);
      field.values.add(logMatch && logMatch[1]);
    }
  });
  dataFrame.fields = [...dataFrame.fields, ...newFields];
};
/**
 * Transform derivedField config into dataframe field with config that contains link.
 */

function fieldFromDerivedFieldConfig(derivedFieldConfigs) {
  const dataSourceSrv = (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_2__.getDataSourceSrv)();
  const dataLinks = derivedFieldConfigs.reduce((acc, derivedFieldConfig) => {
    // Having field.datasourceUid means it is an internal link.
    if (derivedFieldConfig.datasourceUid) {
      var _dsSettings$name;

      const dsSettings = dataSourceSrv.getInstanceSettings(derivedFieldConfig.datasourceUid);
      acc.push({
        // Will be filled out later
        title: derivedFieldConfig.urlDisplayLabel || '',
        url: '',
        // This is hardcoded for Jaeger or Zipkin not way right now to specify datasource specific query object
        internal: {
          query: {
            query: derivedFieldConfig.url
          },
          datasourceUid: derivedFieldConfig.datasourceUid,
          datasourceName: (_dsSettings$name = dsSettings === null || dsSettings === void 0 ? void 0 : dsSettings.name) !== null && _dsSettings$name !== void 0 ? _dsSettings$name : 'Data source not found'
        }
      });
    } else if (derivedFieldConfig.url) {
      acc.push({
        // We do not know what title to give here so we count on presentation layer to create a title from metadata.
        title: derivedFieldConfig.urlDisplayLabel || '',
        // This is hardcoded for Jaeger or Zipkin not way right now to specify datasource specific query object
        url: derivedFieldConfig.url
      });
    }

    return acc;
  }, []);
  return {
    name: derivedFieldConfigs[0].name,
    type: _grafana_data__WEBPACK_IMPORTED_MODULE_1__.FieldType.string,
    config: {
      links: dataLinks
    },
    // We are adding values later on
    values: new _grafana_data__WEBPACK_IMPORTED_MODULE_1__.ArrayVector([])
  };
}

function rangeQueryResponseToTimeSeries(response, query, target, scopedVars) {
  var _target$legendFormat;

  /** Show results of Loki metric queries only in graph */
  const meta = {
    preferredVisualisationType: 'graph'
  };
  const transformerOptions = {
    legendFormat: (_target$legendFormat = target.legendFormat) !== null && _target$legendFormat !== void 0 ? _target$legendFormat : '',
    query: query.query,
    refId: target.refId,
    meta,
    scopedVars
  };

  switch (response.data.resultType) {
    case _types__WEBPACK_IMPORTED_MODULE_6__.LokiResultType.Vector:
      return response.data.result.map(vecResult => lokiMatrixToTimeSeries({
        metric: vecResult.metric,
        values: [vecResult.value]
      }, transformerOptions));

    case _types__WEBPACK_IMPORTED_MODULE_6__.LokiResultType.Matrix:
      return response.data.result.map(matrixResult => lokiMatrixToTimeSeries(matrixResult, transformerOptions));

    default:
      return [];
  }
}

function rangeQueryResponseToDataFrames(response, query, target, scopedVars) {
  const series = rangeQueryResponseToTimeSeries(response, query, target, scopedVars);
  const frames = series.map(s => (0,_grafana_data__WEBPACK_IMPORTED_MODULE_1__.toDataFrame)(s));
  const {
    step
  } = query;

  if (step != null) {
    const intervalMs = step * 1000;
    frames.forEach(frame => {
      frame.fields.forEach(field => {
        if (field.type === _grafana_data__WEBPACK_IMPORTED_MODULE_1__.FieldType.time) {
          field.config.interval = intervalMs;
        }
      });
    });
  }

  return frames;
}
function processRangeQueryResponse(response, target, query, limit, config, scopedVars) {
  switch (response.data.resultType) {
    case _types__WEBPACK_IMPORTED_MODULE_6__.LokiResultType.Stream:
      return (0,rxjs__WEBPACK_IMPORTED_MODULE_8__.of)({
        data: lokiStreamsToDataFrames(response, target, limit, config),
        key: `${target.refId}_log`
      });

    case _types__WEBPACK_IMPORTED_MODULE_6__.LokiResultType.Vector:
    case _types__WEBPACK_IMPORTED_MODULE_6__.LokiResultType.Matrix:
      return (0,rxjs__WEBPACK_IMPORTED_MODULE_8__.of)({
        data: rangeQueryResponseToDataFrames(response, query, target, scopedVars),
        key: target.refId
      });

    default:
      throw new Error(`Unknown result type "${response.data.resultType}".`);
  }
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/sortDataFrame.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sortDataFrameByTime": () => (/* binding */ sortDataFrameByTime)
/* harmony export */ });
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
const _excluded = ["fields"];

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }



// creates the `index` for the sorting.
// this is needed by the `SortedVector`.
// the index is an array of numbers, and it defines an order.
// at every slot in the index the values is the position of
// the sorted item.
// for example, an index of [3,1,2] means that
// in the dataframe, that has 3 rows, after sorting:
// - the third row will become the first
// - the first row will become the second
// - the second row will become the third
function makeIndex(field, dir) {
  const fieldValues = field.values.toArray(); // we first build an array which is [0,1,2,3....]

  const index = Array(fieldValues.length);

  for (let i = 0; i < index.length; i++) {
    index[i] = i;
  }

  const isAsc = dir === 'ASCENDING';
  index.sort((a, b) => {
    // we need to answer this question:
    // in the field-used-for-sorting, how would we compare value-at-index-a to value-at-index-b?
    const valA = fieldValues[a];
    const valB = fieldValues[b];

    if (valA < valB) {
      return isAsc ? -1 : 1;
    }

    if (valA > valB) {
      return isAsc ? 1 : -1;
    }

    return 0;
  });
  return index;
} // sort a dataframe that is in the Loki format ascending or descending,
// based on the nanosecond-timestamp


function sortDataFrameByTime(frame, dir) {
  const {
    fields
  } = frame,
        rest = _objectWithoutPropertiesLoose(frame, _excluded); // we use the approach used in @grafana/data/sortDataframe.
  // we cannot use it directly, because our tsNs field has a type=time,
  // so we have to build the `index` manually.


  const tsNsField = fields.find(field => field.name === 'tsNs');

  if (tsNsField === undefined) {
    throw new Error('missing nanosecond-timestamp field. should never happen');
  }

  const index = makeIndex(tsNsField, dir);
  return Object.assign({}, rest, {
    fields: fields.map(field => Object.assign({}, field, {
      values: new _grafana_data__WEBPACK_IMPORTED_MODULE_0__.SortedVector(field.values, index)
    }))
  });
  return frame;
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/streaming.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "doLokiChannelStream": () => (/* binding */ doLokiChannelStream),
/* harmony export */   "getLiveStreamKey": () => (/* binding */ getLiveStreamKey)
/* harmony export */ });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/defer.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/map.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var app_features_live_data_StreamingDataFrame__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/live/data/StreamingDataFrame.ts");





/**
 * Calculate a unique key for the query.  The key is used to pick a channel and should
 * be unique for each distinct query execution plan.  This key is not secure and is only picked to avoid
 * possible collisions
 */
async function getLiveStreamKey(query) {
  const str = JSON.stringify({
    expr: query.expr
  });
  const msgUint8 = new TextEncoder().encode(str); // encode as (utf-8) Uint8Array

  const hashBuffer = await crypto.subtle.digest('SHA-1', msgUint8); // hash the message

  const hashArray = Array.from(new Uint8Array(hashBuffer.slice(0, 8))); // first 8 bytes

  return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
} // This will get both v1 and v2 result formats

function doLokiChannelStream(query, ds, options) {
  var _options$maxDataPoint;

  // maximum time to keep values
  const range = options.range;
  const maxDelta = range.to.valueOf() - range.from.valueOf() + 1000;
  let maxLength = (_options$maxDataPoint = options.maxDataPoints) !== null && _options$maxDataPoint !== void 0 ? _options$maxDataPoint : 1000;

  if (maxLength > 100) {
    // for small buffers, keep them small
    maxLength *= 2;
  }

  let frame = undefined;

  const updateFrame = msg => {
    if (msg !== null && msg !== void 0 && msg.message) {
      const p = msg.message;

      if (!frame) {
        frame = app_features_live_data_StreamingDataFrame__WEBPACK_IMPORTED_MODULE_2__.StreamingDataFrame.fromDataFrameJSON(p, {
          maxLength,
          maxDelta,
          displayNameFormat: query.legendFormat
        });
      } else {
        frame.push(p);
      }
    }

    return frame;
  };

  return (0,rxjs__WEBPACK_IMPORTED_MODULE_3__.defer)(() => getLiveStreamKey(query)).pipe((0,rxjs__WEBPACK_IMPORTED_MODULE_4__.mergeMap)(key => {
    return (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_1__.getGrafanaLiveSrv)().getStream({
      scope: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.LiveChannelScope.DataSource,
      namespace: ds.uid,
      path: `tail/${key}`,
      data: Object.assign({}, query, {
        timeRange: {
          from: range.from.valueOf().toString(),
          to: range.to.valueOf().toString()
        }
      })
    }).pipe((0,rxjs__WEBPACK_IMPORTED_MODULE_5__.map)(evt => {
      const frame = updateFrame(evt);
      return {
        data: frame ? [frame] : [],
        state: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.LoadingState.Streaming
      };
    }));
  }));
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/syntax.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FUNCTIONS": () => (/* binding */ FUNCTIONS),
/* harmony export */   "LOKI_KEYWORDS": () => (/* binding */ LOKI_KEYWORDS),
/* harmony export */   "PIPE_OPERATORS": () => (/* binding */ PIPE_OPERATORS),
/* harmony export */   "PIPE_PARSERS": () => (/* binding */ PIPE_PARSERS),
/* harmony export */   "RANGE_VEC_FUNCTIONS": () => (/* binding */ RANGE_VEC_FUNCTIONS),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "lokiGrammar": () => (/* binding */ lokiGrammar)
/* harmony export */ });
const AGGREGATION_OPERATORS = [{
  label: 'sum',
  insertText: 'sum',
  documentation: 'Calculate sum over dimensions'
}, {
  label: 'min',
  insertText: 'min',
  documentation: 'Select minimum over dimensions'
}, {
  label: 'max',
  insertText: 'max',
  documentation: 'Select maximum over dimensions'
}, {
  label: 'avg',
  insertText: 'avg',
  documentation: 'Calculate the average over dimensions'
}, {
  label: 'stddev',
  insertText: 'stddev',
  documentation: 'Calculate population standard deviation over dimensions'
}, {
  label: 'stdvar',
  insertText: 'stdvar',
  documentation: 'Calculate population standard variance over dimensions'
}, {
  label: 'count',
  insertText: 'count',
  documentation: 'Count number of elements in the vector'
}, {
  label: 'bottomk',
  insertText: 'bottomk',
  documentation: 'Smallest k elements by sample value'
}, {
  label: 'topk',
  insertText: 'topk',
  documentation: 'Largest k elements by sample value'
}];
const PIPE_PARSERS = [{
  label: 'json',
  insertText: 'json',
  documentation: 'Extracting labels from the log line using json parser. Only available in Loki 2.0+.'
}, {
  label: 'regexp',
  insertText: 'regexp ""',
  documentation: 'Extracting labels from the log line using regexp parser. Only available in Loki 2.0+.',
  move: -1
}, {
  label: 'logfmt',
  insertText: 'logfmt',
  documentation: 'Extracting labels from the log line using logfmt parser. Only available in Loki 2.0+.'
}, {
  label: 'pattern',
  insertText: 'pattern',
  documentation: 'Extracting labels from the log line using pattern parser. Only available in Loki 2.3+.'
}];
const PIPE_OPERATORS = [{
  label: 'unwrap',
  insertText: 'unwrap',
  detail: 'unwrap identifier',
  documentation: 'Take labels and use the values as sample data for metric aggregations. Only available in Loki 2.0+.'
}, {
  label: 'unpack',
  insertText: 'unpack',
  detail: 'unpack identifier',
  documentation: 'Parses a JSON log line, unpacking all embedded labels in the pack stage. A special property "_entry" will also be used to replace the original log line. Only available in Loki 2.0+.'
}, {
  label: 'label_format',
  insertText: 'label_format',
  documentation: 'Use to rename, modify or add labels. For example, | label_format foo=bar . Only available in Loki 2.0+.'
}, {
  label: 'line_format',
  insertText: 'line_format',
  documentation: 'Rewrites log line content. For example, | line_format "{{.query}} {{.duration}}" . Only available in Loki 2.0+.'
}];
const RANGE_VEC_FUNCTIONS = [{
  insertText: 'avg_over_time',
  label: 'avg_over_time',
  detail: 'avg_over_time(range-vector)',
  documentation: 'The average of all values in the specified interval. Only available in Loki 2.0+.'
}, {
  insertText: 'min_over_time',
  label: 'min_over_time',
  detail: 'min_over_time(range-vector)',
  documentation: 'The minimum of all values in the specified interval. Only available in Loki 2.0+.'
}, {
  insertText: 'max_over_time',
  label: 'max_over_time',
  detail: 'max_over_time(range-vector)',
  documentation: 'The maximum of all values in the specified interval. Only available in Loki 2.0+.'
}, {
  insertText: 'sum_over_time',
  label: 'sum_over_time',
  detail: 'sum_over_time(range-vector)',
  documentation: 'The sum of all values in the specified interval. Only available in Loki 2.0+.'
}, {
  insertText: 'count_over_time',
  label: 'count_over_time',
  detail: 'count_over_time(range-vector)',
  documentation: 'The count of all values in the specified interval.'
}, {
  insertText: 'stdvar_over_time',
  label: 'stdvar_over_time',
  detail: 'stdvar_over_time(range-vector)',
  documentation: 'The population standard variance of the values in the specified interval. Only available in Loki 2.0+.'
}, {
  insertText: 'stddev_over_time',
  label: 'stddev_over_time',
  detail: 'stddev_over_time(range-vector)',
  documentation: 'The population standard deviation of the values in the specified interval. Only available in Loki 2.0+.'
}, {
  insertText: 'quantile_over_time',
  label: 'quantile_over_time',
  detail: 'quantile_over_time(scalar, range-vector)',
  documentation: 'The φ-quantile (0 ≤ φ ≤ 1) of the values in the specified interval. Only available in Loki 2.0+.'
}, {
  insertText: 'bytes_over_time',
  label: 'bytes_over_time',
  detail: 'bytes_over_time(range-vector)',
  documentation: 'Counts the amount of bytes used by each log stream for a given range'
}, {
  insertText: 'bytes_rate',
  label: 'bytes_rate',
  detail: 'bytes_rate(range-vector)',
  documentation: 'Calculates the number of bytes per second for each stream.'
}, {
  insertText: 'rate',
  label: 'rate',
  detail: 'rate(v range-vector)',
  documentation: 'Calculates the number of entries per second.'
}];
const FUNCTIONS = [...AGGREGATION_OPERATORS, ...RANGE_VEC_FUNCTIONS];
const LOKI_KEYWORDS = [...FUNCTIONS, ...PIPE_OPERATORS, ...PIPE_PARSERS].map(keyword => keyword.label);
const lokiGrammar = {
  comment: {
    pattern: /#.*/
  },
  'context-aggregation': {
    pattern: /((without|by)\s*)\([^)]*\)/,
    // by ()
    lookbehind: true,
    inside: {
      'label-key': {
        pattern: /[^(),\s][^,)]*[^),\s]*/,
        alias: 'attr-name'
      },
      punctuation: /[()]/
    }
  },
  'context-labels': {
    pattern: /\{[^}]*(?=}?)/,
    greedy: true,
    inside: {
      comment: {
        pattern: /#.*/
      },
      'label-key': {
        pattern: /[a-zA-Z_]\w*(?=\s*(=|!=|=~|!~))/,
        alias: 'attr-name',
        greedy: true
      },
      'label-value': {
        pattern: /"(?:\\.|[^\\"])*"/,
        greedy: true,
        alias: 'attr-value'
      },
      punctuation: /[{]/
    }
  },
  'context-pipe': {
    pattern: /\s\|[^=~]\s?\w*/i,
    inside: {
      'pipe-operator': {
        pattern: /\|/i,
        alias: 'operator'
      },
      'pipe-operations': {
        pattern: new RegExp(`${[...PIPE_PARSERS, ...PIPE_OPERATORS].map(f => f.label).join('|')}`, 'i'),
        alias: 'keyword'
      }
    }
  },
  function: new RegExp(`\\b(?:${FUNCTIONS.map(f => f.label).join('|')})(?=\\s*\\()`, 'i'),
  'context-range': [{
    pattern: /\[[^\]]*(?=\])/,
    // [1m]
    inside: {
      'range-duration': {
        pattern: /\b\d+[smhdwy]\b/i,
        alias: 'number'
      }
    }
  }, {
    pattern: /(offset\s+)\w+/,
    // offset 1m
    lookbehind: true,
    inside: {
      'range-duration': {
        pattern: /\b\d+[smhdwy]\b/i,
        alias: 'number'
      }
    }
  }],
  quote: {
    pattern: /"(?:\\.|[^\\"])*"/,
    alias: 'string',
    greedy: true
  },
  backticks: {
    pattern: /`(?:\\.|[^\\`])*`/,
    alias: 'string',
    greedy: true
  },
  number: /\b-?\d+((\.\d*)?([eE][+-]?\d+)?)?\b/,
  operator: /\s?(\|[=~]?|!=?|<(?:=>?|<|>)?|>[>=]?)\s?/i,
  punctuation: /[{}(),.]/
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (lokiGrammar);

/***/ }),

/***/ "./public/app/plugins/datasource/loki/types.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiQueryDirection": () => (/* binding */ LokiQueryDirection),
/* harmony export */   "LokiQueryType": () => (/* binding */ LokiQueryType),
/* harmony export */   "LokiResultType": () => (/* binding */ LokiResultType)
/* harmony export */ });
let LokiResultType;

(function (LokiResultType) {
  LokiResultType["Stream"] = "streams";
  LokiResultType["Vector"] = "vector";
  LokiResultType["Matrix"] = "matrix";
})(LokiResultType || (LokiResultType = {}));

let LokiQueryType;

(function (LokiQueryType) {
  LokiQueryType["Range"] = "range";
  LokiQueryType["Instant"] = "instant";
  LokiQueryType["Stream"] = "stream";
})(LokiQueryType || (LokiQueryType = {}));

let LokiQueryDirection;

(function (LokiQueryDirection) {
  LokiQueryDirection["Backward"] = "backward";
  LokiQueryDirection["Forward"] = "forward";
})(LokiQueryDirection || (LokiQueryDirection = {}));

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/add_label_to_query.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addLabelToQuery": () => (/* binding */ addLabelToQuery)
/* harmony export */ });
/* harmony import */ var lezer_promql__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/lezer-promql-virtual-eaf88aa77a/0/cache/lezer-promql-npm-0.22.0-867da6afaa-cdce054700.zip/node_modules/lezer-promql/index.es.js");
/* harmony import */ var _querybuilder_PromQueryModeller__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/PromQueryModeller.ts");
/* harmony import */ var _querybuilder_parsing__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/parsing.ts");




/**
 * Adds label filter to existing query. Useful for query modification for example for ad hoc filters.
 *
 * It uses PromQL parser to find instances of metric and labels, alters them and then splices them back into the query.
 * Ideally we could use the parse -> change -> render is a simple 3 steps but right now building the visual query
 * object does not support all possible queries.
 *
 * So instead this just operates on substrings of the query with labels and operates just on those. This makes this
 * more robust and can alter even invalid queries, and preserves in general the query structure and whitespace.
 * @param query
 * @param key
 * @param value
 * @param operator
 */
function addLabelToQuery(query, key, value, operator = '=') {
  if (!key || !value) {
    throw new Error('Need label to add to query.');
  }

  const vectorSelectorPositions = getVectorSelectorPositions(query);

  if (!vectorSelectorPositions.length) {
    return query;
  }

  const filter = toLabelFilter(key, value, operator);
  return addFilter(query, vectorSelectorPositions, filter);
}

/**
 * Parse the string and get all VectorSelector positions in the query together with parsed representation of the vector
 * selector.
 * @param query
 */
function getVectorSelectorPositions(query) {
  const tree = lezer_promql__WEBPACK_IMPORTED_MODULE_0__.parser.parse(query);
  const positions = [];
  tree.iterate({
    enter: (type, from, to, get) => {
      if (type.name === 'VectorSelector') {
        const visQuery = (0,_querybuilder_parsing__WEBPACK_IMPORTED_MODULE_2__.buildVisualQueryFromString)(query.substring(from, to));
        positions.push({
          query: visQuery.query,
          from,
          to
        });
        return false;
      }
    }
  });
  return positions;
}

function toLabelFilter(key, value, operator) {
  // We need to make sure that we convert the value back to string because it may be a number
  const transformedValue = value === Infinity ? '+Inf' : value.toString();
  return {
    label: key,
    op: operator,
    value: transformedValue
  };
}

function addFilter(query, vectorSelectorPositions, filter) {
  const modeller = new _querybuilder_PromQueryModeller__WEBPACK_IMPORTED_MODULE_1__.PromQueryModeller();
  let newQuery = '';
  let prev = 0;

  for (let i = 0; i < vectorSelectorPositions.length; i++) {
    // This is basically just doing splice on a string for each matched vector selector.
    const match = vectorSelectorPositions[i];
    const isLast = i === vectorSelectorPositions.length - 1;
    const start = query.substring(prev, match.from);
    const end = isLast ? query.substring(match.to) : '';

    if (!labelExists(match.query.labels, filter)) {
      // We don't want to add duplicate labels.
      match.query.labels.push(filter);
    }

    const newLabels = modeller.renderQuery(match.query);
    newQuery += start + newLabels + end;
    prev = match.to;
  }

  return newQuery;
}
/**
 * Check if label exists in the list of labels but ignore the operator.
 * @param labels
 * @param filter
 */


function labelExists(labels, filter) {
  return labels.find(label => label.label === filter.label && label.value === filter.value);
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/datasource.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ANNOTATION_QUERY_STEP_DEFAULT": () => (/* binding */ ANNOTATION_QUERY_STEP_DEFAULT),
/* harmony export */   "PrometheusDatasource": () => (/* binding */ PrometheusDatasource),
/* harmony export */   "alignRange": () => (/* binding */ alignRange),
/* harmony export */   "extractRuleMappingFromGroups": () => (/* binding */ extractRuleMappingFromGroups),
/* harmony export */   "prometheusRegularEscape": () => (/* binding */ prometheusRegularEscape),
/* harmony export */   "prometheusSpecialRegexEscape": () => (/* binding */ prometheusSpecialRegexEscape)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/lru-cache-npm-7.9.0-d803108233-c91a293a10.zip/node_modules/lru-cache/index.js");
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lru_cache__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/lastValueFrom.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/of.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/util/pipe.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/merge.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/forkJoin.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/throwError.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/map.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/tap.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/filter.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/catchError.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_core_utils_explore__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/core/utils/explore.ts");
/* harmony import */ var app_features_alerting_unified_api_buildInfo__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/features/alerting/unified/api/buildInfo.ts");
/* harmony import */ var app_features_dashboard_services_TimeSrv__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./public/app/features/dashboard/services/TimeSrv.ts");
/* harmony import */ var app_features_templating_template_srv__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./public/app/features/templating/template_srv.ts");
/* harmony import */ var app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./public/app/types/unified-alerting-dto.ts");
/* harmony import */ var _add_label_to_query__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./public/app/plugins/datasource/prometheus/add_label_to_query.ts");
/* harmony import */ var _language_provider__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./public/app/plugins/datasource/prometheus/language_provider.ts");
/* harmony import */ var _language_utils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./public/app/plugins/datasource/prometheus/language_utils.ts");
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./public/app/plugins/datasource/prometheus/legend.ts");
/* harmony import */ var _metric_find_query__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./public/app/plugins/datasource/prometheus/metric_find_query.ts");
/* harmony import */ var _query_hints__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("./public/app/plugins/datasource/prometheus/query_hints.ts");
/* harmony import */ var _result_transformer__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__("./public/app/plugins/datasource/prometheus/result_transformer.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__("./public/app/plugins/datasource/prometheus/types.ts");
/* harmony import */ var _variables__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__("./public/app/plugins/datasource/prometheus/variables.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _Badge, _Badge2, _Tooltip, _div, _div2;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


























const ANNOTATION_QUERY_STEP_DEFAULT = '60s';
const GET_AND_POST_METADATA_ENDPOINTS = ['api/v1/query', 'api/v1/query_range', 'api/v1/series', 'api/v1/labels'];
class PrometheusDatasource extends _grafana_runtime__WEBPACK_IMPORTED_MODULE_4__.DataSourceWithBackend {
  constructor(instanceSettings, templateSrv = (0,app_features_templating_template_srv__WEBPACK_IMPORTED_MODULE_9__.getTemplateSrv)(), timeSrv = (0,app_features_dashboard_services_TimeSrv__WEBPACK_IMPORTED_MODULE_8__.getTimeSrv)(), languageProvider) {
    var _instanceSettings$jso, _instanceSettings$jso2;

    super(instanceSettings);
    this.templateSrv = templateSrv;
    this.timeSrv = timeSrv;

    _defineProperty(this, "type", void 0);

    _defineProperty(this, "editorSrc", void 0);

    _defineProperty(this, "ruleMappings", void 0);

    _defineProperty(this, "url", void 0);

    _defineProperty(this, "id", void 0);

    _defineProperty(this, "directUrl", void 0);

    _defineProperty(this, "access", void 0);

    _defineProperty(this, "basicAuth", void 0);

    _defineProperty(this, "withCredentials", void 0);

    _defineProperty(this, "metricsNameCache", new (lru_cache__WEBPACK_IMPORTED_MODULE_1___default())({
      max: 10
    }));

    _defineProperty(this, "interval", void 0);

    _defineProperty(this, "queryTimeout", void 0);

    _defineProperty(this, "httpMethod", void 0);

    _defineProperty(this, "languageProvider", void 0);

    _defineProperty(this, "exemplarTraceIdDestinations", void 0);

    _defineProperty(this, "lookupsDisabled", void 0);

    _defineProperty(this, "customQueryParameters", void 0);

    _defineProperty(this, "exemplarsAvailable", void 0);

    _defineProperty(this, "subType", void 0);

    _defineProperty(this, "rulerEnabled", void 0);

    _defineProperty(this, "init", async () => {
      this.loadRules();
      this.exemplarsAvailable = await this.areExemplarsAvailable();
    });

    _defineProperty(this, "prepareTargets", (options, start, end) => {
      const queries = [];
      const activeTargets = [];
      const clonedTargets = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.cloneDeep)(options.targets);

      for (const target of clonedTargets) {
        if (!target.expr || target.hide) {
          continue;
        }

        target.requestId = options.panelId + target.refId;
        const metricName = this.languageProvider.histogramMetrics.find(m => target.expr.includes(m)); // In Explore, we run both (instant and range) queries if both are true (selected) or both are undefined (legacy Explore queries)

        if (options.app === _grafana_data__WEBPACK_IMPORTED_MODULE_3__.CoreApp.Explore && target.range === target.instant) {
          // Create instant target
          const instantTarget = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.cloneDeep)(target);
          instantTarget.format = 'table';
          instantTarget.instant = true;
          instantTarget.range = false;
          instantTarget.valueWithRefId = true;
          delete instantTarget.maxDataPoints;
          instantTarget.requestId += '_instant'; // Create range target

          const rangeTarget = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.cloneDeep)(target);
          rangeTarget.format = 'time_series';
          rangeTarget.instant = false;
          instantTarget.range = true; // Create exemplar query

          if (target.exemplar) {
            // Only create exemplar target for different metric names
            if (!metricName || metricName && !activeTargets.some(activeTarget => activeTarget.expr.includes(metricName))) {
              const exemplarTarget = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.cloneDeep)(target);
              exemplarTarget.instant = false;
              exemplarTarget.requestId += '_exemplar';
              queries.push(this.createQuery(exemplarTarget, options, start, end));
              activeTargets.push(exemplarTarget);
            }

            instantTarget.exemplar = false;
            rangeTarget.exemplar = false;
          } // Add both targets to activeTargets and queries arrays


          activeTargets.push(instantTarget, rangeTarget);
          queries.push(this.createQuery(instantTarget, options, start, end), this.createQuery(rangeTarget, options, start, end)); // If running only instant query in Explore, format as table
        } else if (target.instant && options.app === _grafana_data__WEBPACK_IMPORTED_MODULE_3__.CoreApp.Explore) {
          const instantTarget = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.cloneDeep)(target);
          instantTarget.format = 'table';
          queries.push(this.createQuery(instantTarget, options, start, end));
          activeTargets.push(instantTarget);
        } else {
          // It doesn't make sense to query for exemplars in dashboard if only instant is selected
          if (target.exemplar && !target.instant) {
            if (!metricName || metricName && !activeTargets.some(activeTarget => activeTarget.expr.includes(metricName))) {
              const exemplarTarget = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.cloneDeep)(target);
              exemplarTarget.requestId += '_exemplar';
              queries.push(this.createQuery(exemplarTarget, options, start, end));
              activeTargets.push(exemplarTarget);
            }

            target.exemplar = false;
          }

          queries.push(this.createQuery(target, options, start, end));
          activeTargets.push(target);
        }
      }

      return {
        queries,
        activeTargets
      };
    });

    _defineProperty(this, "handleErrors", (err, target) => {
      const error = {
        message: err && err.statusText || 'Unknown error during query transaction. Please check JS console logs.',
        refId: target.refId
      };

      if (err.data) {
        if (typeof err.data === 'string') {
          error.message = err.data;
        } else if (err.data.error) {
          error.message = (0,app_core_utils_explore__WEBPACK_IMPORTED_MODULE_6__.safeStringifyValue)(err.data.error);
        }
      } else if (err.message) {
        error.message = err.message;
      } else if (typeof err === 'string') {
        error.message = err;
      }

      error.status = err.status;
      error.statusText = err.statusText;
      return error;
    });

    _defineProperty(this, "processAnnotationResponse", (options, data) => {
      const frames = (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_4__.toDataQueryResponse)({
        data: data
      }).data;

      if (!frames || !frames.length) {
        return [];
      }

      const annotation = options.annotation;
      const {
        tagKeys = '',
        titleFormat = '',
        textFormat = ''
      } = annotation;
      const step = _grafana_data__WEBPACK_IMPORTED_MODULE_3__.rangeUtil.intervalToSeconds(annotation.step || ANNOTATION_QUERY_STEP_DEFAULT) * 1000;
      const tagKeysArray = tagKeys.split(',');
      const eventList = [];

      for (const frame of frames) {
        const timeField = frame.fields[0];
        const valueField = frame.fields[1];
        const labels = (valueField === null || valueField === void 0 ? void 0 : valueField.labels) || {};
        const tags = Object.keys(labels).filter(label => tagKeysArray.includes(label)).map(label => labels[label]);
        const timeValueTuple = [];
        let idx = 0;
        valueField.values.toArray().forEach(value => {
          let timeStampValue;
          let valueValue;
          const time = timeField.values.get(idx); // If we want to use value as a time, we use value as timeStampValue and valueValue will be 1

          if (options.annotation.useValueForTime) {
            timeStampValue = Math.floor(parseFloat(value));
            valueValue = 1;
          } else {
            timeStampValue = Math.floor(parseFloat(time));
            valueValue = parseFloat(value);
          }

          idx++;
          timeValueTuple.push([timeStampValue, valueValue]);
        });
        const activeValues = timeValueTuple.filter(value => value[1] >= 1);
        const activeValuesTimestamps = activeValues.map(value => value[0]); // Instead of creating singular annotation for each active event we group events into region if they are less
        // or equal to `step` apart.

        let latestEvent = null;

        for (const timestamp of activeValuesTimestamps) {
          var _latestEvent$timeEnd;

          // We already have event `open` and we have new event that is inside the `step` so we just update the end.
          if (latestEvent && ((_latestEvent$timeEnd = latestEvent.timeEnd) !== null && _latestEvent$timeEnd !== void 0 ? _latestEvent$timeEnd : 0) + step >= timestamp) {
            latestEvent.timeEnd = timestamp;
            continue;
          } // Event exists but new one is outside of the `step` so we add it to eventList.


          if (latestEvent) {
            eventList.push(latestEvent);
          } // We start a new region.


          latestEvent = {
            time: timestamp,
            timeEnd: timestamp,
            annotation,
            title: (0,_legend__WEBPACK_IMPORTED_MODULE_14__.renderLegendFormat)(titleFormat, labels),
            tags,
            text: (0,_legend__WEBPACK_IMPORTED_MODULE_14__.renderLegendFormat)(textFormat, labels)
          };
        }

        if (latestEvent) {
          // Finish up last point if we have one
          latestEvent.timeEnd = activeValuesTimestamps[activeValuesTimestamps.length - 1];
          eventList.push(latestEvent);
        }
      }

      return eventList;
    });

    this.templateSrv = templateSrv;
    this.timeSrv = timeSrv;
    this.type = 'prometheus';
    this.subType = app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_10__.PromApplication.Prometheus;
    this.rulerEnabled = false;
    this.editorSrc = 'app/features/prometheus/partials/query.editor.html';
    this.id = instanceSettings.id;
    this.url = instanceSettings.url;
    this.access = instanceSettings.access;
    this.basicAuth = instanceSettings.basicAuth;
    this.withCredentials = instanceSettings.withCredentials;
    this.interval = instanceSettings.jsonData.timeInterval || '15s';
    this.queryTimeout = instanceSettings.jsonData.queryTimeout;
    this.httpMethod = instanceSettings.jsonData.httpMethod || 'POST'; // `directUrl` is never undefined, we set it at https://github.com/grafana/grafana/blob/main/pkg/api/frontendsettings.go#L108
    // here we "fall back" to this.url to make typescript happy, but it should never happen

    this.directUrl = (_instanceSettings$jso = instanceSettings.jsonData.directUrl) !== null && _instanceSettings$jso !== void 0 ? _instanceSettings$jso : this.url;
    this.exemplarTraceIdDestinations = instanceSettings.jsonData.exemplarTraceIdDestinations;
    this.ruleMappings = {};
    this.languageProvider = languageProvider !== null && languageProvider !== void 0 ? languageProvider : new _language_provider__WEBPACK_IMPORTED_MODULE_12__["default"](this);
    this.lookupsDisabled = (_instanceSettings$jso2 = instanceSettings.jsonData.disableMetricsLookup) !== null && _instanceSettings$jso2 !== void 0 ? _instanceSettings$jso2 : false;
    this.customQueryParameters = new URLSearchParams(instanceSettings.jsonData.customQueryParameters);
    this.variables = new _variables__WEBPACK_IMPORTED_MODULE_19__.PrometheusVariableSupport(this, this.templateSrv, this.timeSrv);
    this.exemplarsAvailable = true;
  }

  getQueryDisplayText(query) {
    return query.expr;
  }

  _addTracingHeaders(httpOptions, options) {
    httpOptions.headers = {};
    const proxyMode = !this.url.match(/^http/);

    if (proxyMode) {
      httpOptions.headers['X-Dashboard-Id'] = options.dashboardId;
      httpOptions.headers['X-Panel-Id'] = options.panelId;
    }
  }
  /**
   * Any request done from this data source should go through here as it contains some common processing for the
   * request. Any processing done here needs to be also copied on the backend as this goes through data source proxy
   * but not through the same code as alerting.
   */


  _request(url, data, overrides = {}) {
    data = data || {};

    for (const [key, value] of this.customQueryParameters) {
      if (data[key] == null) {
        data[key] = value;
      }
    }

    const options = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.defaults)(overrides, {
      url: this.url + url,
      method: this.httpMethod,
      headers: {}
    });

    if (options.method === 'GET') {
      if (data && Object.keys(data).length) {
        options.url = options.url + (options.url.search(/\?/) >= 0 ? '&' : '?') + Object.entries(data).map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`).join('&');
      }
    } else {
      options.headers['Content-Type'] = 'application/x-www-form-urlencoded';
      options.data = data;
    }

    if (this.basicAuth || this.withCredentials) {
      options.withCredentials = true;
    }

    if (this.basicAuth) {
      options.headers.Authorization = this.basicAuth;
    }

    return (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_4__.getBackendSrv)().fetch(options);
  }

  async importFromAbstractQueries(abstractQueries) {
    return abstractQueries.map(abstractQuery => this.languageProvider.importFromAbstractQuery(abstractQuery));
  }

  async exportToAbstractQueries(queries) {
    return queries.map(query => this.languageProvider.exportToAbstractQuery(query));
  } // Use this for tab completion features, wont publish response to other components


  async metadataRequest(url, params = {}) {
    // If URL includes endpoint that supports POST and GET method, try to use configured method. This might fail as POST is supported only in v2.10+.
    if (GET_AND_POST_METADATA_ENDPOINTS.some(endpoint => url.includes(endpoint))) {
      try {
        return await (0,rxjs__WEBPACK_IMPORTED_MODULE_21__.lastValueFrom)(this._request(url, params, {
          method: this.httpMethod,
          hideFromInspector: true
        }));
      } catch (err) {
        // If status code of error is Method Not Allowed (405) and HTTP method is POST, retry with GET
        if (this.httpMethod === 'POST' && err.status === 405) {
          console.warn(`Couldn't use configured POST HTTP method for this request. Trying to use GET method instead.`);
        } else {
          throw err;
        }
      }
    }

    return await (0,rxjs__WEBPACK_IMPORTED_MODULE_21__.lastValueFrom)(this._request(url, params, {
      method: 'GET',
      hideFromInspector: true
    })); // toPromise until we change getTagValues, getTagKeys to Observable
  }

  interpolateQueryExpr(value = [], variable) {
    // if no multi or include all do not regexEscape
    if (!variable.multi && !variable.includeAll) {
      return prometheusRegularEscape(value);
    }

    if (typeof value === 'string') {
      return prometheusSpecialRegexEscape(value);
    }

    const escapedValues = value.map(val => prometheusSpecialRegexEscape(val));

    if (escapedValues.length === 1) {
      return escapedValues[0];
    }

    return '(' + escapedValues.join('|') + ')';
  }

  targetContainsTemplate(target) {
    return this.templateSrv.containsTemplate(target.expr);
  }

  shouldRunExemplarQuery(target, request) {
    if (target.exemplar) {
      // We check all already processed targets and only create exemplar target for not used metric names
      const metricName = this.languageProvider.histogramMetrics.find(m => target.expr.includes(m)); // Remove targets that weren't processed yet (in targets array they are after current target)

      const currentTargetIdx = request.targets.findIndex(t => t.refId === target.refId);
      const targets = request.targets.slice(0, currentTargetIdx);

      if (!metricName || metricName && !targets.some(t => t.expr.includes(metricName))) {
        return true;
      }

      return false;
    }

    return false;
  }

  processTargetV2(target, request) {
    const processedTarget = Object.assign({}, target, {
      queryType: _types__WEBPACK_IMPORTED_MODULE_18__.PromQueryType.timeSeriesQuery,
      exemplar: this.shouldRunExemplarQuery(target, request),
      requestId: request.panelId + target.refId,
      // We need to pass utcOffsetSec to backend to calculate aligned range
      utcOffsetSec: this.timeSrv.timeRange().to.utcOffset() * 60
    });
    return processedTarget;
  }

  query(request) {
    if (this.access === 'proxy') {
      const targets = request.targets.map(target => this.processTargetV2(target, request));
      return super.query(Object.assign({}, request, {
        targets
      })).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_22__.map)(response => (0,_result_transformer__WEBPACK_IMPORTED_MODULE_17__.transformV2)(response, request, {
        exemplarTraceIdDestinations: this.exemplarTraceIdDestinations
      }))); // Run queries trough browser/proxy
    } else {
      const start = this.getPrometheusTime(request.range.from, false);
      const end = this.getPrometheusTime(request.range.to, true);
      const {
        queries,
        activeTargets
      } = this.prepareTargets(request, start, end); // No valid targets, return the empty result to save a round trip.

      if (!queries || !queries.length) {
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_23__.of)({
          data: [],
          state: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.LoadingState.Done
        });
      }

      if (request.app === _grafana_data__WEBPACK_IMPORTED_MODULE_3__.CoreApp.Explore) {
        return this.exploreQuery(queries, activeTargets, end);
      }

      return this.panelsQuery(queries, activeTargets, end, request.requestId, request.scopedVars);
    }
  }

  exploreQuery(queries, activeTargets, end) {
    let runningQueriesCount = queries.length;
    const subQueries = queries.map((query, index) => {
      const target = activeTargets[index];
      const filterAndMapResponse = (0,rxjs__WEBPACK_IMPORTED_MODULE_24__.pipe)( // Decrease the counter here. We assume that each request returns only single value and then completes
      // (should hold until there is some streaming requests involved).
      (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_25__.tap)(() => runningQueriesCount--), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_26__.filter)(response => response.cancelled ? false : true), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_22__.map)(response => {
        const data = (0,_result_transformer__WEBPACK_IMPORTED_MODULE_17__.transform)(response, {
          query,
          target,
          responseListLength: queries.length,
          exemplarTraceIdDestinations: this.exemplarTraceIdDestinations
        });
        return {
          data,
          key: query.requestId,
          state: runningQueriesCount === 0 ? _grafana_data__WEBPACK_IMPORTED_MODULE_3__.LoadingState.Done : _grafana_data__WEBPACK_IMPORTED_MODULE_3__.LoadingState.Loading
        };
      }));
      return this.runQuery(query, end, filterAndMapResponse);
    });
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_27__.merge)(...subQueries);
  }

  panelsQuery(queries, activeTargets, end, requestId, scopedVars) {
    const observables = queries.map((query, index) => {
      const target = activeTargets[index];
      const filterAndMapResponse = (0,rxjs__WEBPACK_IMPORTED_MODULE_24__.pipe)((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_26__.filter)(response => response.cancelled ? false : true), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_22__.map)(response => {
        const data = (0,_result_transformer__WEBPACK_IMPORTED_MODULE_17__.transform)(response, {
          query,
          target,
          responseListLength: queries.length,
          scopedVars,
          exemplarTraceIdDestinations: this.exemplarTraceIdDestinations
        });
        return data;
      }));
      return this.runQuery(query, end, filterAndMapResponse);
    });
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_28__.forkJoin)(observables).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_22__.map)(results => {
      const data = results.reduce((result, current) => {
        return [...result, ...current];
      }, []);
      return {
        data,
        key: requestId,
        state: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.LoadingState.Done
      };
    }));
  }

  runQuery(query, end, filter) {
    if (query.instant) {
      return this.performInstantQuery(query, end).pipe(filter);
    }

    if (query.exemplar) {
      return this.getExemplars(query).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_29__.catchError)(() => {
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_23__.of)({
          data: [],
          state: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.LoadingState.Done
        });
      }), filter);
    }

    return this.performTimeSeriesQuery(query, query.start, query.end).pipe(filter);
  }

  createQuery(target, options, start, end) {
    const query = {
      hinting: target.hinting,
      instant: target.instant,
      exemplar: target.exemplar,
      step: 0,
      expr: '',
      requestId: target.requestId,
      refId: target.refId,
      start: 0,
      end: 0
    };
    const range = Math.ceil(end - start); // options.interval is the dynamically calculated interval

    let interval = _grafana_data__WEBPACK_IMPORTED_MODULE_3__.rangeUtil.intervalToSeconds(options.interval); // Minimum interval ("Min step"), if specified for the query, or same as interval otherwise.

    const minInterval = _grafana_data__WEBPACK_IMPORTED_MODULE_3__.rangeUtil.intervalToSeconds(this.templateSrv.replace(target.interval || options.interval, options.scopedVars)); // Scrape interval as specified for the query ("Min step") or otherwise taken from the datasource.
    // Min step field can have template variables in it, make sure to replace it.

    const scrapeInterval = target.interval ? _grafana_data__WEBPACK_IMPORTED_MODULE_3__.rangeUtil.intervalToSeconds(this.templateSrv.replace(target.interval, options.scopedVars)) : _grafana_data__WEBPACK_IMPORTED_MODULE_3__.rangeUtil.intervalToSeconds(this.interval);
    const intervalFactor = target.intervalFactor || 1; // Adjust the interval to take into account any specified minimum and interval factor plus Prometheus limits

    const adjustedInterval = this.adjustInterval(interval, minInterval, range, intervalFactor);
    let scopedVars = Object.assign({}, options.scopedVars, this.getRangeScopedVars(options.range), this.getRateIntervalScopedVariable(adjustedInterval, scrapeInterval)); // If the interval was adjusted, make a shallow copy of scopedVars with updated interval vars

    if (interval !== adjustedInterval) {
      interval = adjustedInterval;
      scopedVars = Object.assign({}, options.scopedVars, Object.assign({
        __interval: {
          text: interval + 's',
          value: interval + 's'
        },
        __interval_ms: {
          text: interval * 1000,
          value: interval * 1000
        }
      }, this.getRateIntervalScopedVariable(interval, scrapeInterval), this.getRangeScopedVars(options.range)));
    }

    query.step = interval;
    let expr = target.expr; // Apply adhoc filters

    expr = this.enhanceExprWithAdHocFilters(expr); // Only replace vars in expression after having (possibly) updated interval vars

    query.expr = this.templateSrv.replace(expr, scopedVars, this.interpolateQueryExpr); // Align query interval with step to allow query caching and to ensure
    // that about-same-time query results look the same.

    const adjusted = alignRange(start, end, query.step, this.timeSrv.timeRange().to.utcOffset() * 60);
    query.start = adjusted.start;
    query.end = adjusted.end;

    this._addTracingHeaders(query, options);

    return query;
  }

  getRateIntervalScopedVariable(interval, scrapeInterval) {
    // Fall back to the default scrape interval of 15s if scrapeInterval is 0 for some reason.
    if (scrapeInterval === 0) {
      scrapeInterval = 15;
    }

    const rateInterval = Math.max(interval + scrapeInterval, 4 * scrapeInterval);
    return {
      __rate_interval: {
        text: rateInterval + 's',
        value: rateInterval + 's'
      }
    };
  }

  adjustInterval(interval, minInterval, range, intervalFactor) {
    // Prometheus will drop queries that might return more than 11000 data points.
    // Calculate a safe interval as an additional minimum to take into account.
    // Fractional safeIntervals are allowed, however serve little purpose if the interval is greater than 1
    // If this is the case take the ceil of the value.
    let safeInterval = range / 11000;

    if (safeInterval > 1) {
      safeInterval = Math.ceil(safeInterval);
    }

    return Math.max(interval * intervalFactor, minInterval, safeInterval);
  }

  performTimeSeriesQuery(query, start, end) {
    if (start > end) {
      throw {
        message: 'Invalid time range'
      };
    }

    const url = '/api/v1/query_range';
    const data = {
      query: query.expr,
      start,
      end,
      step: query.step
    };

    if (this.queryTimeout) {
      data['timeout'] = this.queryTimeout;
    }

    return this._request(url, data, {
      requestId: query.requestId,
      headers: query.headers
    }).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_29__.catchError)(err => {
      if (err.cancelled) {
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_23__.of)(err);
      }

      return (0,rxjs__WEBPACK_IMPORTED_MODULE_30__.throwError)(this.handleErrors(err, query));
    }));
  }

  performInstantQuery(query, time) {
    const url = '/api/v1/query';
    const data = {
      query: query.expr,
      time
    };

    if (this.queryTimeout) {
      data['timeout'] = this.queryTimeout;
    }

    return this._request(url, data, {
      requestId: query.requestId,
      headers: query.headers
    }).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_29__.catchError)(err => {
      if (err.cancelled) {
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_23__.of)(err);
      }

      return (0,rxjs__WEBPACK_IMPORTED_MODULE_30__.throwError)(this.handleErrors(err, query));
    }));
  }

  metricFindQuery(query) {
    if (!query) {
      return Promise.resolve([]);
    }

    const scopedVars = Object.assign({
      __interval: {
        text: this.interval,
        value: this.interval
      },
      __interval_ms: {
        text: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.rangeUtil.intervalToMs(this.interval),
        value: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.rangeUtil.intervalToMs(this.interval)
      }
    }, this.getRangeScopedVars(this.timeSrv.timeRange()));
    const interpolated = this.templateSrv.replace(query, scopedVars, this.interpolateQueryExpr);
    const metricFindQuery = new _metric_find_query__WEBPACK_IMPORTED_MODULE_15__["default"](this, interpolated);
    return metricFindQuery.process();
  }

  getRangeScopedVars(range = this.timeSrv.timeRange()) {
    const msRange = range.to.diff(range.from);
    const sRange = Math.round(msRange / 1000);
    return {
      __range_ms: {
        text: msRange,
        value: msRange
      },
      __range_s: {
        text: sRange,
        value: sRange
      },
      __range: {
        text: sRange + 's',
        value: sRange + 's'
      }
    };
  }

  async annotationQuery(options) {
    const annotation = options.annotation;
    const {
      expr = ''
    } = annotation;

    if (!expr) {
      return Promise.resolve([]);
    }

    const step = options.annotation.step || ANNOTATION_QUERY_STEP_DEFAULT;
    const queryModel = {
      expr,
      range: true,
      instant: false,
      exemplar: false,
      interval: step,
      queryType: _types__WEBPACK_IMPORTED_MODULE_18__.PromQueryType.timeSeriesQuery,
      refId: 'X',
      datasource: this.getRef()
    };
    return await (0,rxjs__WEBPACK_IMPORTED_MODULE_21__.lastValueFrom)((0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_4__.getBackendSrv)().fetch({
      url: '/api/ds/query',
      method: 'POST',
      data: {
        from: (this.getPrometheusTime(options.range.from, false) * 1000).toString(),
        to: (this.getPrometheusTime(options.range.to, true) * 1000).toString(),
        queries: [this.applyTemplateVariables(queryModel, {})]
      },
      requestId: `prom-query-${annotation.name}`
    }).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_22__.map)(rsp => {
      return this.processAnnotationResponse(options, rsp.data);
    })));
  }

  getExemplars(query) {
    const url = '/api/v1/query_exemplars';
    return this._request(url, {
      query: query.expr,
      start: query.start.toString(),
      end: query.end.toString()
    }, {
      requestId: query.requestId,
      headers: query.headers
    });
  }

  async getSubtitle() {
    const buildInfo = await this.getBuildInfo();
    return buildInfo ? this.getBuildInfoMessage(buildInfo) : null;
  }

  async getTagKeys(options) {
    if (options !== null && options !== void 0 && options.series) {
      // Get tags for the provided series only
      const seriesLabels = await Promise.all(options.series.map(series => this.languageProvider.fetchSeriesLabels(series)));
      const uniqueLabels = [...new Set(...seriesLabels.map(value => Object.keys(value)))];
      return uniqueLabels.map(value => ({
        text: value
      }));
    } else {
      var _result$data$data$map, _result$data, _result$data$data;

      // Get all tags
      const result = await this.metadataRequest('/api/v1/labels');
      return (_result$data$data$map = result === null || result === void 0 ? void 0 : (_result$data = result.data) === null || _result$data === void 0 ? void 0 : (_result$data$data = _result$data.data) === null || _result$data$data === void 0 ? void 0 : _result$data$data.map(value => ({
        text: value
      }))) !== null && _result$data$data$map !== void 0 ? _result$data$data$map : [];
    }
  }

  async getTagValues(options = {}) {
    var _result$data$data$map2, _result$data2, _result$data2$data;

    const result = await this.metadataRequest(`/api/v1/label/${options.key}/values`);
    return (_result$data$data$map2 = result === null || result === void 0 ? void 0 : (_result$data2 = result.data) === null || _result$data2 === void 0 ? void 0 : (_result$data2$data = _result$data2.data) === null || _result$data2$data === void 0 ? void 0 : _result$data2$data.map(value => ({
      text: value
    }))) !== null && _result$data$data$map2 !== void 0 ? _result$data$data$map2 : [];
  }

  async getBuildInfo() {
    try {
      const buildInfo = await (0,app_features_alerting_unified_api_buildInfo__WEBPACK_IMPORTED_MODULE_7__.fetchDataSourceBuildInfo)(this);
      return buildInfo;
    } catch (error) {
      // We don't want to break the rest of functionality if build info does not work correctly
      return undefined;
    }
  }

  getBuildInfoMessage(buildInfo) {
    var _buildInfo$applicatio, _buildInfo$applicatio2;

    const enabled = _Badge || (_Badge = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_5__.Badge, {
      color: "green",
      icon: "check",
      text: "Ruler API enabled"
    }));

    const disabled = _Badge2 || (_Badge2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_5__.Badge, {
      color: "orange",
      icon: "exclamation-triangle",
      text: "Ruler API not enabled"
    }));

    const unsupported = _Tooltip || (_Tooltip = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_5__.Tooltip, {
      placement: "top",
      content: "Prometheus does not allow editing rules, connect to either a Mimir or Cortex datasource to manage alerts via Grafana.",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)("div", {
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_5__.Badge, {
          color: "red",
          icon: "exclamation-triangle",
          text: "Ruler API not supported"
        })
      })
    }));

    const LOGOS = {
      [app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_10__.PromApplication.Cortex]: '/public/app/plugins/datasource/prometheus/img/cortex_logo.svg',
      [app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_10__.PromApplication.Mimir]: '/public/app/plugins/datasource/prometheus/img/mimir_logo.svg',
      [app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_10__.PromApplication.Prometheus]: '/public/app/plugins/datasource/prometheus/img/prometheus_logo.svg'
    };
    const COLORS = {
      [app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_10__.PromApplication.Cortex]: 'blue',
      [app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_10__.PromApplication.Mimir]: 'orange',
      [app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_10__.PromApplication.Prometheus]: 'red'
    }; // this will inform the user about what "subtype" the datasource is; Mimir, Cortex or vanilla Prometheus

    const applicationSubType = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_5__.Badge, {
      text: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsxs)("span", {
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)("img", {
          style: {
            width: 14,
            height: 14,
            verticalAlign: 'text-bottom'
          },
          src: LOGOS[(_buildInfo$applicatio = buildInfo.application) !== null && _buildInfo$applicatio !== void 0 ? _buildInfo$applicatio : app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_10__.PromApplication.Prometheus]
        }), ' ', buildInfo.application]
      }),
      color: COLORS[(_buildInfo$applicatio2 = buildInfo.application) !== null && _buildInfo$applicatio2 !== void 0 ? _buildInfo$applicatio2 : app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_10__.PromApplication.Prometheus]
    });

    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsxs)("div", {
      style: {
        display: 'grid',
        gridTemplateColumns: 'max-content max-content',
        rowGap: '0.5rem',
        columnGap: '2rem',
        marginTop: '1rem'
      },
      children: [_div || (_div = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)("div", {
        children: "Type"
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)("div", {
        children: applicationSubType
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.Fragment, {
        children: [_div2 || (_div2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)("div", {
          children: "Ruler API"
        })), buildInfo.application === app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_10__.PromApplication.Prometheus && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)("div", {
          children: unsupported
        }), buildInfo.application !== app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_10__.PromApplication.Prometheus && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)("div", {
          children: buildInfo.features.rulerApiEnabled ? enabled : disabled
        })]
      })]
    });
  }

  async testDatasource() {
    const now = new Date().getTime();
    const request = {
      targets: [{
        refId: 'test',
        expr: '1+1',
        instant: true
      }],
      requestId: `${this.id}-health`,
      scopedVars: {},
      dashboardId: 0,
      panelId: 0,
      interval: '1m',
      intervalMs: 60000,
      maxDataPoints: 1,
      range: {
        from: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_3__.dateTime)(now - 1000),
        to: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_3__.dateTime)(now)
      }
    };
    const buildInfo = await this.getBuildInfo();
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_21__.lastValueFrom)(this.query(request)).then(res => {
      if (!res || !res.data || res.state !== _grafana_data__WEBPACK_IMPORTED_MODULE_3__.LoadingState.Done) {
        var _res$error;

        return {
          status: 'error',
          message: `Error reading Prometheus: ${res === null || res === void 0 ? void 0 : (_res$error = res.error) === null || _res$error === void 0 ? void 0 : _res$error.message}`
        };
      } else {
        return {
          status: 'success',
          message: 'Data source is working',
          details: buildInfo && {
            verboseMessage: this.getBuildInfoMessage(buildInfo)
          }
        };
      }
    }).catch(err => {
      console.error('Prometheus Error', err);
      return {
        status: 'error',
        message: err.message
      };
    });
  }

  interpolateVariablesInQueries(queries, scopedVars) {
    let expandedQueries = queries;

    if (queries && queries.length) {
      expandedQueries = queries.map(query => {
        const expandedQuery = Object.assign({}, query, {
          datasource: this.getRef(),
          expr: this.templateSrv.replace(query.expr, scopedVars, this.interpolateQueryExpr),
          interval: this.templateSrv.replace(query.interval, scopedVars)
        });
        return expandedQuery;
      });
    }

    return expandedQueries;
  }

  getQueryHints(query, result) {
    var _query$expr;

    return (0,_query_hints__WEBPACK_IMPORTED_MODULE_16__.getQueryHints)((_query$expr = query.expr) !== null && _query$expr !== void 0 ? _query$expr : '', result, this);
  }

  getInitHints() {
    return (0,_query_hints__WEBPACK_IMPORTED_MODULE_16__.getInitHints)(this);
  }

  async loadRules() {
    try {
      var _res$data, _res$data$data;

      const res = await this.metadataRequest('/api/v1/rules');
      const groups = (_res$data = res.data) === null || _res$data === void 0 ? void 0 : (_res$data$data = _res$data.data) === null || _res$data$data === void 0 ? void 0 : _res$data$data.groups;

      if (groups) {
        this.ruleMappings = extractRuleMappingFromGroups(groups);
      }
    } catch (e) {
      console.log('Rules API is experimental. Ignore next error.');
      console.error(e);
    }
  }

  async areExemplarsAvailable() {
    try {
      const res = await this.metadataRequest('/api/v1/query_exemplars', {
        query: 'test'
      });

      if (res.data.status === 'success') {
        return true;
      }

      return false;
    } catch (err) {
      return false;
    }
  }

  modifyQuery(query, action) {
    var _query$expr2;

    let expression = (_query$expr2 = query.expr) !== null && _query$expr2 !== void 0 ? _query$expr2 : '';

    switch (action.type) {
      case 'ADD_FILTER':
        {
          expression = (0,_add_label_to_query__WEBPACK_IMPORTED_MODULE_11__.addLabelToQuery)(expression, action.key, action.value);
          break;
        }

      case 'ADD_FILTER_OUT':
        {
          expression = (0,_add_label_to_query__WEBPACK_IMPORTED_MODULE_11__.addLabelToQuery)(expression, action.key, action.value, '!=');
          break;
        }

      case 'ADD_HISTOGRAM_QUANTILE':
        {
          expression = `histogram_quantile(0.95, sum(rate(${expression}[$__rate_interval])) by (le))`;
          break;
        }

      case 'ADD_RATE':
        {
          expression = `rate(${expression}[$__rate_interval])`;
          break;
        }

      case 'ADD_SUM':
        {
          expression = `sum(${expression.trim()}) by ($1)`;
          break;
        }

      case 'EXPAND_RULES':
        {
          if (action.mapping) {
            expression = (0,_language_utils__WEBPACK_IMPORTED_MODULE_13__.expandRecordingRules)(expression, action.mapping);
          }

          break;
        }

      default:
        break;
    }

    return Object.assign({}, query, {
      expr: expression
    });
  }

  getPrometheusTime(date, roundUp) {
    if (typeof date === 'string') {
      date = _grafana_data__WEBPACK_IMPORTED_MODULE_3__.dateMath.parse(date, roundUp);
    }

    return Math.ceil(date.valueOf() / 1000);
  }

  getTimeRangeParams() {
    const range = this.timeSrv.timeRange();
    return {
      start: this.getPrometheusTime(range.from, false).toString(),
      end: this.getPrometheusTime(range.to, true).toString()
    };
  }

  getOriginalMetricName(labelData) {
    return (0,_result_transformer__WEBPACK_IMPORTED_MODULE_17__.getOriginalMetricName)(labelData);
  }

  enhanceExprWithAdHocFilters(expr) {
    const adhocFilters = this.templateSrv.getAdhocFilters(this.name);
    const finalQuery = adhocFilters.reduce((acc, filter) => {
      const {
        key,
        operator
      } = filter;
      let {
        value
      } = filter;

      if (operator === '=~' || operator === '!~') {
        value = prometheusRegularEscape(value);
      }

      return (0,_add_label_to_query__WEBPACK_IMPORTED_MODULE_11__.addLabelToQuery)(acc, key, value, operator);
    }, expr);
    return finalQuery;
  } // Used when running queries trough backend


  filterQuery(query) {
    if (query.hide || !query.expr) {
      return false;
    }

    return true;
  } // Used when running queries trough backend


  applyTemplateVariables(target, scopedVars) {
    const variables = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.cloneDeep)(scopedVars); // We want to interpolate these variables on backend

    delete variables.__interval;
    delete variables.__interval_ms; //Add ad hoc filters

    const expr = this.enhanceExprWithAdHocFilters(target.expr);
    return Object.assign({}, target, {
      legendFormat: this.templateSrv.replace(target.legendFormat, variables),
      expr: this.templateSrv.replace(expr, variables, this.interpolateQueryExpr),
      interval: this.templateSrv.replace(target.interval, variables)
    });
  }

  getVariables() {
    return this.templateSrv.getVariables().map(v => `$${v.name}`);
  }

  interpolateString(string) {
    return this.templateSrv.replace(string, undefined, this.interpolateQueryExpr);
  }

}
/**
 * Align query range to step.
 * Rounds start and end down to a multiple of step.
 * @param start Timestamp marking the beginning of the range.
 * @param end Timestamp marking the end of the range.
 * @param step Interval to align start and end with.
 * @param utcOffsetSec Number of seconds current timezone is offset from UTC
 */

function alignRange(start, end, step, utcOffsetSec) {
  const alignedEnd = Math.floor((end + utcOffsetSec) / step) * step - utcOffsetSec;
  const alignedStart = Math.floor((start + utcOffsetSec) / step) * step - utcOffsetSec;
  return {
    end: alignedEnd,
    start: alignedStart
  };
}
function extractRuleMappingFromGroups(groups) {
  return groups.reduce((mapping, group) => group.rules.filter(rule => rule.type === 'recording').reduce((acc, rule) => Object.assign({}, acc, {
    [rule.name]: rule.query
  }), mapping), {});
} // NOTE: these two functions are very similar to the escapeLabelValueIn* functions
// in language_utils.ts, but they are not exactly the same algorithm, and we found
// no way to reuse one in the another or vice versa.

function prometheusRegularEscape(value) {
  return typeof value === 'string' ? value.replace(/\\/g, '\\\\').replace(/'/g, "\\\\'") : value;
}
function prometheusSpecialRegexEscape(value) {
  return typeof value === 'string' ? value.replace(/\\/g, '\\\\\\\\').replace(/[$^*{}\[\]\'+?.()|]/g, '\\\\$&') : value;
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/language_provider.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SUGGESTIONS_LIMIT": () => (/* binding */ SUGGESTIONS_LIMIT),
/* harmony export */   "addHistoryMetadata": () => (/* binding */ addHistoryMetadata),
/* harmony export */   "default": () => (/* binding */ PromQlLanguageProvider),
/* harmony export */   "getMetadataString": () => (/* binding */ getMetadataString)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/lru-cache-npm-7.9.0-d803108233-c91a293a10.zip/node_modules/lru-cache/index.js");
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lru_cache__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/prismjs-npm-1.27.0-ca4e1667c6-85c7f4a3e9.zip/node_modules/prismjs/prism.js");
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prismjs__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _language_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/language_utils.ts");
/* harmony import */ var _promql__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/prometheus/promql.ts");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








const DEFAULT_KEYS = ['job', 'instance'];
const EMPTY_SELECTOR = '{}';
const HISTORY_ITEM_COUNT = 5;
const HISTORY_COUNT_CUTOFF = 1000 * 60 * 60 * 24; // 24h
// Max number of items (metrics, labels, values) that we display as suggestions. Prevents from running out of memory.

const SUGGESTIONS_LIMIT = 10000;

const wrapLabel = label => ({
  label
});

const setFunctionKind = suggestion => {
  suggestion.kind = 'function';
  return suggestion;
};

function addHistoryMetadata(item, history) {
  const cutoffTs = Date.now() - HISTORY_COUNT_CUTOFF;
  const historyForItem = history.filter(h => h.ts > cutoffTs && h.query === item.label);
  const count = historyForItem.length;
  const recent = historyForItem[0];
  let hint = `Queried ${count} times in the last 24h.`;

  if (recent) {
    const lastQueried = (0,_grafana_data__WEBPACK_IMPORTED_MODULE_3__.dateTime)(recent.ts).fromNow();
    hint = `${hint} Last queried ${lastQueried}.`;
  }

  return Object.assign({}, item, {
    documentation: hint
  });
}

function addMetricsMetadata(metric, metadata) {
  const item = {
    label: metric
  };

  if (metadata && metadata[metric]) {
    item.documentation = getMetadataString(metric, metadata);
  }

  return item;
}

function getMetadataString(metric, metadata) {
  if (!metadata[metric]) {
    return undefined;
  }

  const {
    type,
    help
  } = metadata[metric];
  return `${type.toUpperCase()}: ${help}`;
}
const PREFIX_DELIMITER_REGEX = /(="|!="|=~"|!~"|\{|\[|\(|\+|-|\/|\*|%|\^|\band\b|\bor\b|\bunless\b|==|>=|!=|<=|>|<|=|~|,)/;
class PromQlLanguageProvider extends _grafana_data__WEBPACK_IMPORTED_MODULE_3__.LanguageProvider {
  /**
   *  Cache for labels of series. This is bit simplistic in the sense that it just counts responses each as a 1 and does
   *  not account for different size of a response. If that is needed a `length` function can be added in the options.
   *  10 as a max size is totally arbitrary right now.
   */
  constructor(datasource, initialValues) {
    super();

    _defineProperty(this, "histogramMetrics", void 0);

    _defineProperty(this, "timeRange", void 0);

    _defineProperty(this, "metrics", void 0);

    _defineProperty(this, "metricsMetadata", void 0);

    _defineProperty(this, "datasource", void 0);

    _defineProperty(this, "labelKeys", []);

    _defineProperty(this, "labelsCache", new (lru_cache__WEBPACK_IMPORTED_MODULE_1___default())({
      max: 10
    }));

    _defineProperty(this, "request", async (url, defaultValue, params = {}) => {
      try {
        const res = await this.datasource.metadataRequest(url, params);
        return res.data.data;
      } catch (error) {
        console.error(error);
      }

      return defaultValue;
    });

    _defineProperty(this, "start", async () => {
      if (this.datasource.lookupsDisabled) {
        return [];
      } // TODO #33976: make those requests parallel


      await this.fetchLabels();
      this.metrics = (await this.fetchLabelValues('__name__')) || [];
      await this.loadMetricsMetadata();
      this.histogramMetrics = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.processHistogramMetrics)(this.metrics).sort();
      return [];
    });

    _defineProperty(this, "provideCompletionItems", async ({
      prefix,
      text,
      value,
      labelKey,
      wrapperClasses
    }, context = {}) => {
      const emptyResult = {
        suggestions: []
      };

      if (!value) {
        return emptyResult;
      } // Local text properties


      const empty = value.document.text.length === 0;
      const selectedLines = value.document.getTextsAtRange(value.selection);
      const currentLine = selectedLines.size === 1 ? selectedLines.first().getText() : null;
      const nextCharacter = currentLine ? currentLine[value.selection.anchor.offset] : null; // Syntax spans have 3 classes by default. More indicate a recognized token

      const tokenRecognized = wrapperClasses.length > 3; // Non-empty prefix, but not inside known token

      const prefixUnrecognized = prefix && !tokenRecognized; // Prevent suggestions in `function(|suffix)`

      const noSuffix = !nextCharacter || nextCharacter === ')'; // Prefix is safe if it does not immediately follow a complete expression and has no text after it

      const safePrefix = prefix && !text.match(/^[\]})\s]+$/) && noSuffix; // About to type next operand if preceded by binary operator

      const operatorsPattern = /[+\-*/^%]/;
      const isNextOperand = text.match(operatorsPattern); // Determine candidates by CSS context

      if (wrapperClasses.includes('context-range')) {
        // Suggestions for metric[|]
        return this.getRangeCompletionItems();
      } else if (wrapperClasses.includes('context-labels')) {
        // Suggestions for metric{|} and metric{foo=|}, as well as metric-independent label queries like {|}
        return this.getLabelCompletionItems({
          prefix,
          text,
          value,
          labelKey,
          wrapperClasses
        });
      } else if (wrapperClasses.includes('context-aggregation')) {
        // Suggestions for sum(metric) by (|)
        return this.getAggregationCompletionItems(value);
      } else if (empty) {
        // Suggestions for empty query field
        return this.getEmptyCompletionItems(context);
      } else if (prefixUnrecognized && noSuffix && !isNextOperand) {
        // Show term suggestions in a couple of scenarios
        return this.getBeginningCompletionItems(context);
      } else if (prefixUnrecognized && safePrefix) {
        // Show term suggestions in a couple of scenarios
        return this.getTermCompletionItems();
      }

      return emptyResult;
    });

    _defineProperty(this, "getBeginningCompletionItems", context => {
      return {
        suggestions: [...this.getEmptyCompletionItems(context).suggestions, ...this.getTermCompletionItems().suggestions]
      };
    });

    _defineProperty(this, "getEmptyCompletionItems", context => {
      const {
        history
      } = context;
      const suggestions = [];

      if (history && history.length) {
        const historyItems = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.chain)(history).map(h => h.query.expr).filter().uniq().take(HISTORY_ITEM_COUNT).map(wrapLabel).map(item => addHistoryMetadata(item, history)).value();
        suggestions.push({
          searchFunctionType: _grafana_ui__WEBPACK_IMPORTED_MODULE_4__.SearchFunctionType.Prefix,
          skipSort: true,
          label: 'History',
          items: historyItems
        });
      }

      return {
        suggestions
      };
    });

    _defineProperty(this, "getTermCompletionItems", () => {
      const {
        metrics,
        metricsMetadata
      } = this;
      const suggestions = [];
      suggestions.push({
        searchFunctionType: _grafana_ui__WEBPACK_IMPORTED_MODULE_4__.SearchFunctionType.Prefix,
        label: 'Functions',
        items: _promql__WEBPACK_IMPORTED_MODULE_6__.FUNCTIONS.map(setFunctionKind)
      });

      if (metrics && metrics.length) {
        suggestions.push({
          label: 'Metrics',
          items: metrics.map(m => addMetricsMetadata(m, metricsMetadata)),
          searchFunctionType: _grafana_ui__WEBPACK_IMPORTED_MODULE_4__.SearchFunctionType.Fuzzy
        });
      }

      return {
        suggestions
      };
    });

    _defineProperty(this, "getAggregationCompletionItems", async value => {
      const suggestions = []; // Stitch all query lines together to support multi-line queries

      let queryOffset;
      const queryText = value.document.getBlocks().reduce((text, block) => {
        if (text === undefined) {
          return '';
        }

        if (!block) {
          return text;
        }

        const blockText = block === null || block === void 0 ? void 0 : block.getText();

        if (value.anchorBlock.key === block.key) {
          // Newline characters are not accounted for but this is irrelevant
          // for the purpose of extracting the selector string
          queryOffset = value.selection.anchor.offset + text.length;
        }

        return text + blockText;
      }, ''); // Try search for selector part on the left-hand side, such as `sum (m) by (l)`

      const openParensAggregationIndex = queryText.lastIndexOf('(', queryOffset);
      let openParensSelectorIndex = queryText.lastIndexOf('(', openParensAggregationIndex - 1);
      let closeParensSelectorIndex = queryText.indexOf(')', openParensSelectorIndex); // Try search for selector part of an alternate aggregation clause, such as `sum by (l) (m)`

      if (openParensSelectorIndex === -1) {
        const closeParensAggregationIndex = queryText.indexOf(')', queryOffset);
        closeParensSelectorIndex = queryText.indexOf(')', closeParensAggregationIndex + 1);
        openParensSelectorIndex = queryText.lastIndexOf('(', closeParensSelectorIndex);
      }

      const result = {
        suggestions,
        context: 'context-aggregation'
      }; // Suggestions are useless for alternative aggregation clauses without a selector in context

      if (openParensSelectorIndex === -1) {
        return result;
      } // Range vector syntax not accounted for by subsequent parse so discard it if present


      const selectorString = queryText.slice(openParensSelectorIndex + 1, closeParensSelectorIndex).replace(/\[[^\]]+\]$/, '');
      const selector = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.parseSelector)(selectorString, selectorString.length - 2).selector;
      const series = await this.getSeries(selector);
      const labelKeys = Object.keys(series);

      if (labelKeys.length > 0) {
        const limitInfo = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.addLimitInfo)(labelKeys);
        suggestions.push({
          label: `Labels${limitInfo}`,
          items: labelKeys.map(wrapLabel),
          searchFunctionType: _grafana_ui__WEBPACK_IMPORTED_MODULE_4__.SearchFunctionType.Fuzzy
        });
      }

      return result;
    });

    _defineProperty(this, "getLabelCompletionItems", async ({
      text,
      wrapperClasses,
      labelKey,
      value
    }) => {
      if (!value) {
        return {
          suggestions: []
        };
      }

      const suggestions = [];
      const line = value.anchorBlock.getText();
      const cursorOffset = value.selection.anchor.offset;
      const suffix = line.substr(cursorOffset);
      const prefix = line.substr(0, cursorOffset);
      const isValueStart = text.match(/^(=|=~|!=|!~)/);
      const isValueEnd = suffix.match(/^"?[,}]|$/); // Detect cursor in front of value, e.g., {key=|"}

      const isPreValue = prefix.match(/(=|=~|!=|!~)$/) && suffix.match(/^"/); // Don't suggest anything at the beginning or inside a value

      const isValueEmpty = isValueStart && isValueEnd;
      const hasValuePrefix = isValueEnd && !isValueStart;

      if (!isValueEmpty && !hasValuePrefix || isPreValue) {
        return {
          suggestions
        };
      } // Get normalized selector


      let selector;
      let parsedSelector;

      try {
        parsedSelector = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.parseSelector)(line, cursorOffset);
        selector = parsedSelector.selector;
      } catch {
        selector = EMPTY_SELECTOR;
      }

      const containsMetric = selector.includes('__name__=');
      const existingKeys = parsedSelector ? parsedSelector.labelKeys : [];
      let series = {}; // Query labels for selector

      if (selector) {
        series = await this.getSeries(selector, !containsMetric);
      }

      if (Object.keys(series).length === 0) {
        console.warn(`Server did not return any values for selector = ${selector}`);
        return {
          suggestions
        };
      }

      let context;

      if (text && isValueStart || wrapperClasses.includes('attr-value')) {
        // Label values
        if (labelKey && series[labelKey]) {
          context = 'context-label-values';
          const limitInfo = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.addLimitInfo)(series[labelKey]);
          suggestions.push({
            label: `Label values for "${labelKey}"${limitInfo}`,
            items: series[labelKey].map(wrapLabel),
            searchFunctionType: _grafana_ui__WEBPACK_IMPORTED_MODULE_4__.SearchFunctionType.Fuzzy
          });
        }
      } else {
        // Label keys
        const labelKeys = series ? Object.keys(series) : containsMetric ? null : DEFAULT_KEYS;

        if (labelKeys) {
          const possibleKeys = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.difference)(labelKeys, existingKeys);

          if (possibleKeys.length) {
            context = 'context-labels';
            const newItems = possibleKeys.map(key => ({
              label: key
            }));
            const limitInfo = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.addLimitInfo)(newItems);
            const newSuggestion = {
              label: `Labels${limitInfo}`,
              items: newItems,
              searchFunctionType: _grafana_ui__WEBPACK_IMPORTED_MODULE_4__.SearchFunctionType.Fuzzy
            };
            suggestions.push(newSuggestion);
          }
        }
      }

      return {
        context,
        suggestions
      };
    });

    _defineProperty(this, "fetchLabelValues", async key => {
      const params = this.datasource.getTimeRangeParams();
      const url = `/api/v1/label/${this.datasource.interpolateString(key)}/values`;
      return await this.request(url, [], params);
    });

    _defineProperty(this, "fetchSeriesLabels", async (name, withName) => {
      const interpolatedName = this.datasource.interpolateString(name);
      const range = this.datasource.getTimeRangeParams();
      const urlParams = Object.assign({}, range, {
        'match[]': interpolatedName
      });
      const url = `/api/v1/series`; // Cache key is a bit different here. We add the `withName` param and also round up to a minute the intervals.
      // The rounding may seem strange but makes relative intervals like now-1h less prone to need separate request every
      // millisecond while still actually getting all the keys for the correct interval. This still can create problems
      // when user does not the newest values for a minute if already cached.

      const cacheParams = new URLSearchParams({
        'match[]': interpolatedName,
        start: (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.roundSecToMin)(parseInt(range.start, 10)).toString(),
        end: (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.roundSecToMin)(parseInt(range.end, 10)).toString(),
        withName: withName ? 'true' : 'false'
      });
      const cacheKey = `/api/v1/series?${cacheParams.toString()}`;
      let value = this.labelsCache.get(cacheKey);

      if (!value) {
        const data = await this.request(url, [], urlParams);
        const {
          values
        } = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.processLabels)(data, withName);
        value = values;
        this.labelsCache.set(cacheKey, value);
      }

      return value;
    });

    _defineProperty(this, "fetchSeries", async match => {
      const url = '/api/v1/series';
      const range = this.datasource.getTimeRangeParams();
      const params = Object.assign({}, range, {
        'match[]': match
      });
      return await this.request(url, {}, params);
    });

    _defineProperty(this, "fetchDefaultSeries", (0,lodash__WEBPACK_IMPORTED_MODULE_0__.once)(async () => {
      const values = await Promise.all(DEFAULT_KEYS.map(key => this.fetchLabelValues(key)));
      return DEFAULT_KEYS.reduce((acc, key, i) => Object.assign({}, acc, {
        [key]: values[i]
      }), {});
    }));

    this.datasource = datasource;
    this.histogramMetrics = [];
    this.timeRange = {
      start: 0,
      end: 0
    };
    this.metrics = [];
    Object.assign(this, initialValues);
  } // Strip syntax chars so that typeahead suggestions can work on clean inputs


  cleanText(s) {
    const parts = s.split(PREFIX_DELIMITER_REGEX);
    const last = parts.pop();
    return last.trimLeft().replace(/"$/, '').replace(/^"/, '');
  }

  get syntax() {
    return _promql__WEBPACK_IMPORTED_MODULE_6__["default"];
  }

  async loadMetricsMetadata() {
    this.metricsMetadata = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.fixSummariesMetadata)(await this.request('/api/v1/metadata', {}));
  }

  getLabelKeys() {
    return this.labelKeys;
  }

  getRangeCompletionItems() {
    return {
      context: 'context-range',
      suggestions: [{
        label: 'Range vector',
        items: [..._promql__WEBPACK_IMPORTED_MODULE_6__.RATE_RANGES]
      }]
    };
  }

  importFromAbstractQuery(labelBasedQuery) {
    return (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.toPromLikeQuery)(labelBasedQuery);
  }

  exportToAbstractQuery(query) {
    const promQuery = query.expr;

    if (!promQuery || promQuery.length === 0) {
      return {
        refId: query.refId,
        labelMatchers: []
      };
    }

    const tokens = prismjs__WEBPACK_IMPORTED_MODULE_2___default().tokenize(promQuery, _promql__WEBPACK_IMPORTED_MODULE_6__["default"]);
    const labelMatchers = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.extractLabelMatchers)(tokens);
    const nameLabelValue = getNameLabelValue(promQuery, tokens);

    if (nameLabelValue && nameLabelValue.length > 0) {
      labelMatchers.push({
        name: '__name__',
        operator: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.AbstractLabelOperator.Equal,
        value: nameLabelValue
      });
    }

    return {
      refId: query.refId,
      labelMatchers
    };
  }

  async getSeries(selector, withName) {
    if (this.datasource.lookupsDisabled) {
      return {};
    }

    try {
      if (selector === EMPTY_SELECTOR) {
        return await this.fetchDefaultSeries();
      } else {
        return await this.fetchSeriesLabels(selector, withName);
      }
    } catch (error) {
      // TODO: better error handling
      console.error(error);
      return {};
    }
  }

  async getLabelValues(key) {
    return await this.fetchLabelValues(key);
  }
  /**
   * Fetches all label keys
   */


  async fetchLabels() {
    const url = '/api/v1/labels';
    const params = this.datasource.getTimeRangeParams();
    this.labelFetchTs = Date.now().valueOf();
    const res = await this.request(url, [], params);

    if (Array.isArray(res)) {
      this.labelKeys = res.slice().sort();
    }

    return [];
  }
  /**
   * Fetch labels for a series. This is cached by it's args but also by the global timeRange currently selected as
   * they can change over requested time.
   * @param name
   * @param withName
   */


}

function getNameLabelValue(promQuery, tokens) {
  let nameLabelValue = '';

  for (let prop in tokens) {
    if (typeof tokens[prop] === 'string') {
      nameLabelValue = tokens[prop];
      break;
    }
  }

  return nameLabelValue;
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/language_utils.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addLimitInfo": () => (/* binding */ addLimitInfo),
/* harmony export */   "escapeLabelValueInExactSelector": () => (/* binding */ escapeLabelValueInExactSelector),
/* harmony export */   "escapeLabelValueInRegexSelector": () => (/* binding */ escapeLabelValueInRegexSelector),
/* harmony export */   "expandRecordingRules": () => (/* binding */ expandRecordingRules),
/* harmony export */   "extractLabelMatchers": () => (/* binding */ extractLabelMatchers),
/* harmony export */   "fixSummariesMetadata": () => (/* binding */ fixSummariesMetadata),
/* harmony export */   "labelRegexp": () => (/* binding */ labelRegexp),
/* harmony export */   "limitSuggestions": () => (/* binding */ limitSuggestions),
/* harmony export */   "parseSelector": () => (/* binding */ parseSelector),
/* harmony export */   "processHistogramMetrics": () => (/* binding */ processHistogramMetrics),
/* harmony export */   "processLabels": () => (/* binding */ processLabels),
/* harmony export */   "roundMsToMin": () => (/* binding */ roundMsToMin),
/* harmony export */   "roundSecToMin": () => (/* binding */ roundSecToMin),
/* harmony export */   "selectorRegexp": () => (/* binding */ selectorRegexp),
/* harmony export */   "toPromLikeExpr": () => (/* binding */ toPromLikeExpr),
/* harmony export */   "toPromLikeQuery": () => (/* binding */ toPromLikeQuery)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/prismjs-npm-1.27.0-ca4e1667c6-85c7f4a3e9.zip/node_modules/prismjs/prism.js");
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prismjs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _add_label_to_query__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/add_label_to_query.ts");
/* harmony import */ var _language_provider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/language_provider.ts");
const _excluded = ["__name__"];

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }






const processHistogramMetrics = metrics => {
  const resultSet = new Set();
  const regexp = new RegExp('_bucket($|:)');

  for (let index = 0; index < metrics.length; index++) {
    const metric = metrics[index];
    const isHistogramValue = regexp.test(metric);

    if (isHistogramValue) {
      resultSet.add(metric);
    }
  }

  return [...resultSet];
};
function processLabels(labels, withName = false) {
  // For processing we are going to use sets as they have significantly better performance than arrays
  // After we process labels, we will convert sets to arrays and return object with label values in arrays
  const valueSet = {};
  labels.forEach(label => {
    const {
      __name__
    } = label,
          rest = _objectWithoutPropertiesLoose(label, _excluded);

    if (withName) {
      valueSet['__name__'] = valueSet['__name__'] || new Set();

      if (!valueSet['__name__'].has(__name__)) {
        valueSet['__name__'].add(__name__);
      }
    }

    Object.keys(rest).forEach(key => {
      if (!valueSet[key]) {
        valueSet[key] = new Set();
      }

      if (!valueSet[key].has(rest[key])) {
        valueSet[key].add(rest[key]);
      }
    });
  }); // valueArray that we are going to return in the object

  const valueArray = {};
  limitSuggestions(Object.keys(valueSet)).forEach(key => {
    valueArray[key] = limitSuggestions(Array.from(valueSet[key]));
  });
  return {
    values: valueArray,
    keys: Object.keys(valueArray)
  };
} // const cleanSelectorRegexp = /\{(\w+="[^"\n]*?")(,\w+="[^"\n]*?")*\}/;

const selectorRegexp = /\{[^}]*?(\}|$)/;
const labelRegexp = /\b(\w+)(!?=~?)("[^"\n]*?")/g;
function parseSelector(query, cursorOffset = 1) {
  if (!query.match(selectorRegexp)) {
    // Special matcher for metrics
    if (query.match(/^[A-Za-z:][\w:]*$/)) {
      return {
        selector: `{__name__="${query}"}`,
        labelKeys: ['__name__']
      };
    }

    throw new Error('Query must contain a selector: ' + query);
  } // Check if inside a selector


  const prefix = query.slice(0, cursorOffset);
  const prefixOpen = prefix.lastIndexOf('{');
  const prefixClose = prefix.lastIndexOf('}');

  if (prefixOpen === -1) {
    throw new Error('Not inside selector, missing open brace: ' + prefix);
  }

  if (prefixClose > -1 && prefixClose > prefixOpen) {
    throw new Error('Not inside selector, previous selector already closed: ' + prefix);
  }

  const suffix = query.slice(cursorOffset);
  const suffixCloseIndex = suffix.indexOf('}');
  const suffixClose = suffixCloseIndex + cursorOffset;
  const suffixOpenIndex = suffix.indexOf('{');
  const suffixOpen = suffixOpenIndex + cursorOffset;

  if (suffixClose === -1) {
    throw new Error('Not inside selector, missing closing brace in suffix: ' + suffix);
  }

  if (suffixOpenIndex > -1 && suffixOpen < suffixClose) {
    throw new Error('Not inside selector, next selector opens before this one closed: ' + suffix);
  } // Extract clean labels to form clean selector, incomplete labels are dropped


  const selector = query.slice(prefixOpen, suffixClose);
  const labels = {};
  selector.replace(labelRegexp, (label, key, operator, value) => {
    const labelOffset = query.indexOf(label);
    const valueStart = labelOffset + key.length + operator.length + 1;
    const valueEnd = labelOffset + key.length + operator.length + value.length - 1; // Skip label if cursor is in value

    if (cursorOffset < valueStart || cursorOffset > valueEnd) {
      labels[key] = {
        value,
        operator
      };
    }

    return '';
  }); // Add metric if there is one before the selector

  const metricPrefix = query.slice(0, prefixOpen);
  const metricMatch = metricPrefix.match(/[A-Za-z:][\w:]*$/);

  if (metricMatch) {
    labels['__name__'] = {
      value: `"${metricMatch[0]}"`,
      operator: '='
    };
  } // Build sorted selector


  const labelKeys = Object.keys(labels).sort();
  const cleanSelector = labelKeys.map(key => `${key}${labels[key].operator}${labels[key].value}`).join(',');
  const selectorString = ['{', cleanSelector, '}'].join('');
  return {
    labelKeys,
    selector: selectorString
  };
}
function expandRecordingRules(query, mapping) {
  const ruleNames = Object.keys(mapping);
  const rulesRegex = new RegExp(`(\\s|^)(${ruleNames.join('|')})(\\s|$|\\(|\\[|\\{)`, 'ig');
  const expandedQuery = query.replace(rulesRegex, (match, pre, name, post) => `${pre}${mapping[name]}${post}`); // Split query into array, so if query uses operators, we can correctly add labels to each individual part.

  const queryArray = expandedQuery.split(/(\+|\-|\*|\/|\%|\^)/); // Regex that matches occurrences of ){ or }{ or ]{ which is a sign of incorrecly added labels.

  const invalidLabelsRegex = /(\)\{|\}\{|\]\{)/;
  const correctlyExpandedQueryArray = queryArray.map(query => {
    return addLabelsToExpression(query, invalidLabelsRegex);
  });
  return correctlyExpandedQueryArray.join('');
}

function addLabelsToExpression(expr, invalidLabelsRegexp) {
  var _match$index;

  const match = expr.match(invalidLabelsRegexp);

  if (!match) {
    return expr;
  } // Split query into 2 parts - before the invalidLabelsRegex match and after.


  const indexOfRegexMatch = (_match$index = match.index) !== null && _match$index !== void 0 ? _match$index : 0;
  const exprBeforeRegexMatch = expr.slice(0, indexOfRegexMatch + 1);
  const exprAfterRegexMatch = expr.slice(indexOfRegexMatch + 1); // Create arrayOfLabelObjects with label objects that have key, operator and value.

  const arrayOfLabelObjects = [];
  exprAfterRegexMatch.replace(labelRegexp, (label, key, operator, value) => {
    arrayOfLabelObjects.push({
      key,
      operator,
      value
    });
    return '';
  }); // Loop through all label objects and add them to query.
  // As a starting point we have valid query without the labels.

  let result = exprBeforeRegexMatch;
  arrayOfLabelObjects.filter(Boolean).forEach(obj => {
    // Remove extra set of quotes from obj.value
    const value = obj.value.slice(1, -1);
    result = (0,_add_label_to_query__WEBPACK_IMPORTED_MODULE_3__.addLabelToQuery)(result, obj.key, value, obj.operator);
  });
  return result;
}
/**
 * Adds metadata for synthetic metrics for which the API does not provide metadata.
 * See https://github.com/grafana/grafana/issues/22337 for details.
 *
 * @param metadata HELP and TYPE metadata from /api/v1/metadata
 */


function fixSummariesMetadata(metadata) {
  if (!metadata) {
    return metadata;
  }

  const baseMetadata = {};
  const summaryMetadata = {};

  for (const metric in metadata) {
    // NOTE: based on prometheus-documentation, we can receive
    // multiple metadata-entries for the given metric, it seems
    // it happens when the same metric is on multiple targets
    // and their help-text differs
    // (https://prometheus.io/docs/prometheus/latest/querying/api/#querying-metric-metadata)
    // for now we just use the first entry.
    const item = metadata[metric][0];
    baseMetadata[metric] = item;

    if (item.type === 'histogram') {
      summaryMetadata[`${metric}_bucket`] = {
        type: 'counter',
        help: `Cumulative counters for the observation buckets (${item.help})`
      };
      summaryMetadata[`${metric}_count`] = {
        type: 'counter',
        help: `Count of events that have been observed for the histogram metric (${item.help})`
      };
      summaryMetadata[`${metric}_sum`] = {
        type: 'counter',
        help: `Total sum of all observed values for the histogram metric (${item.help})`
      };
    }

    if (item.type === 'summary') {
      summaryMetadata[`${metric}_count`] = {
        type: 'counter',
        help: `Count of events that have been observed for the base metric (${item.help})`
      };
      summaryMetadata[`${metric}_sum`] = {
        type: 'counter',
        help: `Total sum of all observed values for the base metric (${item.help})`
      };
    }
  } // Synthetic series


  const syntheticMetadata = {};
  syntheticMetadata['ALERTS'] = {
    type: 'counter',
    help: 'Time series showing pending and firing alerts. The sample value is set to 1 as long as the alert is in the indicated active (pending or firing) state.'
  };
  return Object.assign({}, baseMetadata, summaryMetadata, syntheticMetadata);
}
function roundMsToMin(milliseconds) {
  return roundSecToMin(milliseconds / 1000);
}
function roundSecToMin(seconds) {
  return Math.floor(seconds / 60);
}
function limitSuggestions(items) {
  return items.slice(0, _language_provider__WEBPACK_IMPORTED_MODULE_4__.SUGGESTIONS_LIMIT);
}
function addLimitInfo(items) {
  return items && items.length >= _language_provider__WEBPACK_IMPORTED_MODULE_4__.SUGGESTIONS_LIMIT ? `, limited to the first ${_language_provider__WEBPACK_IMPORTED_MODULE_4__.SUGGESTIONS_LIMIT} received items` : '';
} // NOTE: the following 2 exported functions are very similar to the prometheus*Escape
// functions in datasource.ts, but they are not exactly the same algorithm, and we found
// no way to reuse one in the another or vice versa.
// Prometheus regular-expressions use the RE2 syntax (https://github.com/google/re2/wiki/Syntax),
// so every character that matches something in that list has to be escaped.
// the list of metacharacters is: *+?()|\.[]{}^$
// we make a javascript regular expression that matches those characters:

const RE2_METACHARACTERS = /[*+?()|\\.\[\]{}^$]/g;

function escapePrometheusRegexp(value) {
  return value.replace(RE2_METACHARACTERS, '\\$&');
} // based on the openmetrics-documentation, the 3 symbols we have to handle are:
// - \n ... the newline character
// - \  ... the backslash character
// - "  ... the double-quote character


function escapeLabelValueInExactSelector(labelValue) {
  return labelValue.replace(/\\/g, '\\\\').replace(/\n/g, '\\n').replace(/"/g, '\\"');
}
function escapeLabelValueInRegexSelector(labelValue) {
  return escapeLabelValueInExactSelector(escapePrometheusRegexp(labelValue));
}
const FromPromLikeMap = {
  '=': _grafana_data__WEBPACK_IMPORTED_MODULE_2__.AbstractLabelOperator.Equal,
  '!=': _grafana_data__WEBPACK_IMPORTED_MODULE_2__.AbstractLabelOperator.NotEqual,
  '=~': _grafana_data__WEBPACK_IMPORTED_MODULE_2__.AbstractLabelOperator.EqualRegEx,
  '!~': _grafana_data__WEBPACK_IMPORTED_MODULE_2__.AbstractLabelOperator.NotEqualRegEx
};
const ToPromLikeMap = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.invert)(FromPromLikeMap);
function toPromLikeExpr(labelBasedQuery) {
  const expr = labelBasedQuery.labelMatchers.map(selector => {
    const operator = ToPromLikeMap[selector.operator];

    if (operator) {
      return `${selector.name}${operator}"${selector.value}"`;
    } else {
      return '';
    }
  }).filter(e => e !== '').join(', ');
  return expr ? `{${expr}}` : '';
}
function toPromLikeQuery(labelBasedQuery) {
  return {
    refId: labelBasedQuery.refId,
    expr: toPromLikeExpr(labelBasedQuery),
    range: true
  };
}
function extractLabelMatchers(tokens) {
  const labelMatchers = [];

  for (let prop in tokens) {
    if (tokens[prop] instanceof prismjs__WEBPACK_IMPORTED_MODULE_1__.Token) {
      let token = tokens[prop];

      if (token.type === 'context-labels') {
        let labelKey = '';
        let labelValue = '';
        let labelOperator = '';
        let contentTokens = token.content;

        for (let currentToken in contentTokens) {
          if (typeof contentTokens[currentToken] === 'string') {
            let currentStr;
            currentStr = contentTokens[currentToken];

            if (currentStr === '=' || currentStr === '!=' || currentStr === '=~' || currentStr === '!~') {
              labelOperator = currentStr;
            }
          } else if (contentTokens[currentToken] instanceof prismjs__WEBPACK_IMPORTED_MODULE_1__.Token) {
            switch (contentTokens[currentToken].type) {
              case 'label-key':
                labelKey = contentTokens[currentToken].content;
                break;

              case 'label-value':
                labelValue = contentTokens[currentToken].content;
                labelValue = labelValue.substring(1, labelValue.length - 1);
                const labelComparator = FromPromLikeMap[labelOperator];

                if (labelComparator) {
                  labelMatchers.push({
                    name: labelKey,
                    operator: labelComparator,
                    value: labelValue
                  });
                }

                break;
            }
          }
        }
      }
    }
  }

  return labelMatchers;
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/metric_find_query.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PrometheusMetricFindQuery)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/lastValueFrom.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/map.js");
/* harmony import */ var app_features_dashboard_services_TimeSrv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/features/dashboard/services/TimeSrv.ts");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





class PrometheusMetricFindQuery {
  constructor(datasource, query) {
    this.datasource = datasource;
    this.query = query;

    _defineProperty(this, "range", void 0);

    this.datasource = datasource;
    this.query = query;
    this.datasource = datasource;
    this.query = query;
    this.range = (0,app_features_dashboard_services_TimeSrv__WEBPACK_IMPORTED_MODULE_1__.getTimeSrv)().timeRange();
  }

  process() {
    const labelNamesRegex = /^label_names\(\)\s*$/;
    const labelValuesRegex = /^label_values\((?:(.+),\s*)?([a-zA-Z_][a-zA-Z0-9_]*)\)\s*$/;
    const metricNamesRegex = /^metrics\((.+)\)\s*$/;
    const queryResultRegex = /^query_result\((.+)\)\s*$/;
    const labelNamesQuery = this.query.match(labelNamesRegex);

    if (labelNamesQuery) {
      return this.labelNamesQuery();
    }

    const labelValuesQuery = this.query.match(labelValuesRegex);

    if (labelValuesQuery) {
      if (labelValuesQuery[1]) {
        return this.labelValuesQuery(labelValuesQuery[2], labelValuesQuery[1]);
      } else {
        return this.labelValuesQuery(labelValuesQuery[2]);
      }
    }

    const metricNamesQuery = this.query.match(metricNamesRegex);

    if (metricNamesQuery) {
      return this.metricNameQuery(metricNamesQuery[1]);
    }

    const queryResultQuery = this.query.match(queryResultRegex);

    if (queryResultQuery) {
      return (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.lastValueFrom)(this.queryResultQuery(queryResultQuery[1]));
    } // if query contains full metric name, return metric name and label list


    return this.metricNameAndLabelsQuery(this.query);
  }

  labelNamesQuery() {
    const start = this.datasource.getPrometheusTime(this.range.from, false);
    const end = this.datasource.getPrometheusTime(this.range.to, true);
    const params = {
      start: start.toString(),
      end: end.toString()
    };
    const url = `/api/v1/labels`;
    return this.datasource.metadataRequest(url, params).then(result => {
      return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.map)(result.data.data, value => {
        return {
          text: value
        };
      });
    });
  }

  labelValuesQuery(label, metric) {
    const start = this.datasource.getPrometheusTime(this.range.from, false);
    const end = this.datasource.getPrometheusTime(this.range.to, true);
    let url;

    if (!metric) {
      const params = {
        start: start.toString(),
        end: end.toString()
      }; // return label values globally

      url = `/api/v1/label/${label}/values`;
      return this.datasource.metadataRequest(url, params).then(result => {
        return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.map)(result.data.data, value => {
          return {
            text: value
          };
        });
      });
    } else {
      const params = {
        'match[]': metric,
        start: start.toString(),
        end: end.toString()
      };
      url = `/api/v1/series`;
      return this.datasource.metadataRequest(url, params).then(result => {
        const _labels = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.map)(result.data.data, metric => {
          return metric[label] || '';
        }).filter(label => {
          return label !== '';
        });

        return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.uniq)(_labels).map(metric => {
          return {
            text: metric,
            expandable: true
          };
        });
      });
    }
  }

  metricNameQuery(metricFilterPattern) {
    const start = this.datasource.getPrometheusTime(this.range.from, false);
    const end = this.datasource.getPrometheusTime(this.range.to, true);
    const params = {
      start: start.toString(),
      end: end.toString()
    };
    const url = `/api/v1/label/__name__/values`;
    return this.datasource.metadataRequest(url, params).then(result => {
      return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.chain)(result.data.data).filter(metricName => {
        const r = new RegExp(metricFilterPattern);
        return r.test(metricName);
      }).map(matchedMetricName => {
        return {
          text: matchedMetricName,
          expandable: true
        };
      }).value();
    });
  }

  queryResultQuery(query) {
    const end = this.datasource.getPrometheusTime(this.range.to, true);
    const instantQuery = {
      expr: query
    };
    return this.datasource.performInstantQuery(instantQuery, end).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)(result => {
      return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.map)(result.data.data.result, metricData => {
        let text = metricData.metric.__name__ || '';
        delete metricData.metric.__name__;
        text += '{' + (0,lodash__WEBPACK_IMPORTED_MODULE_0__.map)(metricData.metric, (v, k) => {
          return k + '="' + v + '"';
        }).join(',') + '}';
        text += ' ' + metricData.value[1] + ' ' + metricData.value[0] * 1000;
        return {
          text: text,
          expandable: true
        };
      });
    }));
  }

  metricNameAndLabelsQuery(query) {
    const start = this.datasource.getPrometheusTime(this.range.from, false);
    const end = this.datasource.getPrometheusTime(this.range.to, true);
    const params = {
      'match[]': query,
      start: start.toString(),
      end: end.toString()
    };
    const url = `/api/v1/series`;
    const self = this;
    return this.datasource.metadataRequest(url, params).then(result => {
      return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.map)(result.data.data, metric => {
        return {
          text: self.datasource.getOriginalMetricName(metric),
          expandable: true
        };
      });
    });
  }

}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/promql.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FUNCTIONS": () => (/* binding */ FUNCTIONS),
/* harmony export */   "LOGICAL_OPERATORS": () => (/* binding */ LOGICAL_OPERATORS),
/* harmony export */   "OPERATORS": () => (/* binding */ OPERATORS),
/* harmony export */   "PROM_KEYWORDS": () => (/* binding */ PROM_KEYWORDS),
/* harmony export */   "RATE_RANGES": () => (/* binding */ RATE_RANGES),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "promqlGrammar": () => (/* binding */ promqlGrammar)
/* harmony export */ });
// When changing RATE_RANGES, check if Loki/LogQL ranges should be changed too
// @see public/app/plugins/datasource/loki/language_provider.ts
const RATE_RANGES = [{
  label: '$__interval',
  sortValue: '$__interval'
}, {
  label: '$__rate_interval',
  sortValue: '$__rate_interval'
}, {
  label: '$__range',
  sortValue: '$__range'
}, {
  label: '1m',
  sortValue: '00:01:00'
}, {
  label: '5m',
  sortValue: '00:05:00'
}, {
  label: '10m',
  sortValue: '00:10:00'
}, {
  label: '30m',
  sortValue: '00:30:00'
}, {
  label: '1h',
  sortValue: '01:00:00'
}, {
  label: '1d',
  sortValue: '24:00:00'
}];
const OPERATORS = ['by', 'group_left', 'group_right', 'ignoring', 'on', 'offset', 'without'];
const LOGICAL_OPERATORS = ['or', 'and', 'unless'];
const TRIGONOMETRIC_FUNCTIONS = [{
  label: 'acos',
  insertText: 'acos',
  detail: 'acos(v instant-vector)',
  documentation: 'calculates the arccosine of all elements in v'
}, {
  label: 'acosh',
  insertText: 'acosh',
  detail: 'acosh(v instant-vector)',
  documentation: 'calculates the inverse hyperbolic cosine of all elements in v'
}, {
  label: 'asin',
  insertText: 'asin',
  detail: 'asin(v instant-vector)',
  documentation: 'calculates the arcsine of all elements in v'
}, {
  label: 'asinh',
  insertText: 'asinh',
  detail: 'asinh(v instant-vector)',
  documentation: 'calculates the inverse hyperbolic sine of all elements in v'
}, {
  label: 'atan',
  insertText: 'atan',
  detail: 'atan(v instant-vector)',
  documentation: 'calculates the arctangent of all elements in v'
}, {
  label: 'atanh',
  insertText: 'atanh',
  detail: 'atanh(v instant-vector)',
  documentation: 'calculates the inverse hyperbolic tangent of all elements in v'
}, {
  label: 'cos',
  insertText: 'cos',
  detail: 'cos(v instant-vector)',
  documentation: 'calculates the cosine of all elements in v'
}, {
  label: 'cosh',
  insertText: 'cosh',
  detail: 'cosh(v instant-vector)',
  documentation: 'calculates the hyperbolic cosine of all elements in v'
}, {
  label: 'sin',
  insertText: 'sin',
  detail: 'sin(v instant-vector)',
  documentation: 'calculates the sine of all elements in v'
}, {
  label: 'sinh',
  insertText: 'sinh',
  detail: 'sinh(v instant-vector)',
  documentation: 'calculates the hyperbolic sine of all elements in v'
}, {
  label: 'tan',
  insertText: 'tan',
  detail: 'tan(v instant-vector)',
  documentation: 'calculates the tangent of all elements in v'
}, {
  label: 'tanh',
  insertText: 'tanh',
  detail: 'tanh(v instant-vector)',
  documentation: 'calculates the hyperbolic tangent of all elements in v'
}];
const AGGREGATION_OPERATORS = [{
  label: 'sum',
  insertText: 'sum',
  documentation: 'Calculate sum over dimensions'
}, {
  label: 'min',
  insertText: 'min',
  documentation: 'Select minimum over dimensions'
}, {
  label: 'max',
  insertText: 'max',
  documentation: 'Select maximum over dimensions'
}, {
  label: 'avg',
  insertText: 'avg',
  documentation: 'Calculate the average over dimensions'
}, {
  label: 'group',
  insertText: 'group',
  documentation: 'All values in the resulting vector are 1'
}, {
  label: 'stddev',
  insertText: 'stddev',
  documentation: 'Calculate population standard deviation over dimensions'
}, {
  label: 'stdvar',
  insertText: 'stdvar',
  documentation: 'Calculate population standard variance over dimensions'
}, {
  label: 'count',
  insertText: 'count',
  documentation: 'Count number of elements in the vector'
}, {
  label: 'count_values',
  insertText: 'count_values',
  documentation: 'Count number of elements with the same value'
}, {
  label: 'bottomk',
  insertText: 'bottomk',
  documentation: 'Smallest k elements by sample value'
}, {
  label: 'topk',
  insertText: 'topk',
  documentation: 'Largest k elements by sample value'
}, {
  label: 'quantile',
  insertText: 'quantile',
  documentation: 'Calculate φ-quantile (0 ≤ φ ≤ 1) over dimensions'
}];
const FUNCTIONS = [...AGGREGATION_OPERATORS, ...TRIGONOMETRIC_FUNCTIONS, {
  insertText: 'abs',
  label: 'abs',
  detail: 'abs(v instant-vector)',
  documentation: 'Returns the input vector with all sample values converted to their absolute value.'
}, {
  insertText: 'absent',
  label: 'absent',
  detail: 'absent(v instant-vector)',
  documentation: 'Returns an empty vector if the vector passed to it has any elements and a 1-element vector with the value 1 if the vector passed to it has no elements. This is useful for alerting on when no time series exist for a given metric name and label combination.'
}, {
  insertText: 'absent_over_time',
  label: 'absent_over_time',
  detail: 'absent(v range-vector)',
  documentation: 'Returns an empty vector if the range vector passed to it has any elements and a 1-element vector with the value 1 if the range vector passed to it has no elements.'
}, {
  insertText: 'ceil',
  label: 'ceil',
  detail: 'ceil(v instant-vector)',
  documentation: 'Rounds the sample values of all elements in `v` up to the nearest integer.'
}, {
  insertText: 'changes',
  label: 'changes',
  detail: 'changes(v range-vector)',
  documentation: 'For each input time series, `changes(v range-vector)` returns the number of times its value has changed within the provided time range as an instant vector.'
}, {
  insertText: 'clamp',
  label: 'clamp',
  detail: 'clamp(v instant-vector, min scalar, max scalar)',
  documentation: 'Clamps the sample values of all elements in `v` to have a lower limit of `min` and an upper limit of `max`.'
}, {
  insertText: 'clamp_max',
  label: 'clamp_max',
  detail: 'clamp_max(v instant-vector, max scalar)',
  documentation: 'Clamps the sample values of all elements in `v` to have an upper limit of `max`.'
}, {
  insertText: 'clamp_min',
  label: 'clamp_min',
  detail: 'clamp_min(v instant-vector, min scalar)',
  documentation: 'Clamps the sample values of all elements in `v` to have a lower limit of `min`.'
}, {
  insertText: 'count_scalar',
  label: 'count_scalar',
  detail: 'count_scalar(v instant-vector)',
  documentation: 'Returns the number of elements in a time series vector as a scalar. This is in contrast to the `count()` aggregation operator, which always returns a vector (an empty one if the input vector is empty) and allows grouping by labels via a `by` clause.'
}, {
  insertText: 'deg',
  label: 'deg',
  detail: 'deg(v instant-vector)',
  documentation: 'Converts radians to degrees for all elements in v'
}, {
  insertText: 'day_of_month',
  label: 'day_of_month',
  detail: 'day_of_month(v=vector(time()) instant-vector)',
  documentation: 'Returns the day of the month for each of the given times in UTC. Returned values are from 1 to 31.'
}, {
  insertText: 'day_of_week',
  label: 'day_of_week',
  detail: 'day_of_week(v=vector(time()) instant-vector)',
  documentation: 'Returns the day of the week for each of the given times in UTC. Returned values are from 0 to 6, where 0 means Sunday etc.'
}, {
  insertText: 'days_in_month',
  label: 'days_in_month',
  detail: 'days_in_month(v=vector(time()) instant-vector)',
  documentation: 'Returns number of days in the month for each of the given times in UTC. Returned values are from 28 to 31.'
}, {
  insertText: 'delta',
  label: 'delta',
  detail: 'delta(v range-vector)',
  documentation: 'Calculates the difference between the first and last value of each time series element in a range vector `v`, returning an instant vector with the given deltas and equivalent labels. The delta is extrapolated to cover the full time range as specified in the range vector selector, so that it is possible to get a non-integer result even if the sample values are all integers.'
}, {
  insertText: 'deriv',
  label: 'deriv',
  detail: 'deriv(v range-vector)',
  documentation: 'Calculates the per-second derivative of the time series in a range vector `v`, using simple linear regression.'
}, {
  insertText: 'drop_common_labels',
  label: 'drop_common_labels',
  detail: 'drop_common_labels(instant-vector)',
  documentation: 'Drops all labels that have the same name and value across all series in the input vector.'
}, {
  insertText: 'exp',
  label: 'exp',
  detail: 'exp(v instant-vector)',
  documentation: 'Calculates the exponential function for all elements in `v`.\nSpecial cases are:\n* `Exp(+Inf) = +Inf` \n* `Exp(NaN) = NaN`'
}, {
  insertText: 'floor',
  label: 'floor',
  detail: 'floor(v instant-vector)',
  documentation: 'Rounds the sample values of all elements in `v` down to the nearest integer.'
}, {
  insertText: 'histogram_quantile',
  label: 'histogram_quantile',
  detail: 'histogram_quantile(φ float, b instant-vector)',
  documentation: 'Calculates the φ-quantile (0 ≤ φ ≤ 1) from the buckets `b` of a histogram. The samples in `b` are the counts of observations in each bucket. Each sample must have a label `le` where the label value denotes the inclusive upper bound of the bucket. (Samples without such a label are silently ignored.) The histogram metric type automatically provides time series with the `_bucket` suffix and the appropriate labels.'
}, {
  insertText: 'holt_winters',
  label: 'holt_winters',
  detail: 'holt_winters(v range-vector, sf scalar, tf scalar)',
  documentation: 'Produces a smoothed value for time series based on the range in `v`. The lower the smoothing factor `sf`, the more importance is given to old data. The higher the trend factor `tf`, the more trends in the data is considered. Both `sf` and `tf` must be between 0 and 1.'
}, {
  insertText: 'hour',
  label: 'hour',
  detail: 'hour(v=vector(time()) instant-vector)',
  documentation: 'Returns the hour of the day for each of the given times in UTC. Returned values are from 0 to 23.'
}, {
  insertText: 'idelta',
  label: 'idelta',
  detail: 'idelta(v range-vector)',
  documentation: 'Calculates the difference between the last two samples in the range vector `v`, returning an instant vector with the given deltas and equivalent labels.'
}, {
  insertText: 'increase',
  label: 'increase',
  detail: 'increase(v range-vector)',
  documentation: 'Calculates the increase in the time series in the range vector. Breaks in monotonicity (such as counter resets due to target restarts) are automatically adjusted for. The increase is extrapolated to cover the full time range as specified in the range vector selector, so that it is possible to get a non-integer result even if a counter increases only by integer increments.'
}, {
  insertText: 'irate',
  label: 'irate',
  detail: 'irate(v range-vector)',
  documentation: 'Calculates the per-second instant rate of increase of the time series in the range vector. This is based on the last two data points. Breaks in monotonicity (such as counter resets due to target restarts) are automatically adjusted for.'
}, {
  insertText: 'label_join',
  label: 'label_join',
  detail: 'label_join(v instant-vector, dst_label string, separator string, src_label_1 string, src_label_2 string, ...)',
  documentation: 'For each timeseries in `v`, joins all the values of all the `src_labels` using `separator` and returns the timeseries with the label `dst_label` containing the joined value. There can be any number of `src_labels` in this function.'
}, {
  insertText: 'label_replace',
  label: 'label_replace',
  detail: 'label_replace(v instant-vector, dst_label string, replacement string, src_label string, regex string)',
  documentation: "For each timeseries in `v`, `label_replace(v instant-vector, dst_label string, replacement string, src_label string, regex string)`  matches the regular expression `regex` against the label `src_label`.  If it matches, then the timeseries is returned with the label `dst_label` replaced by the expansion of `replacement`. `$1` is replaced with the first matching subgroup, `$2` with the second etc. If the regular expression doesn't match then the timeseries is returned unchanged."
}, {
  insertText: 'ln',
  label: 'ln',
  detail: 'ln(v instant-vector)',
  documentation: 'Calculates the natural logarithm for all elements in `v`.\nSpecial cases are:\n * `ln(+Inf) = +Inf`\n * `ln(0) = -Inf`\n * `ln(x < 0) = NaN`\n * `ln(NaN) = NaN`'
}, {
  insertText: 'log2',
  label: 'log2',
  detail: 'log2(v instant-vector)',
  documentation: 'Calculates the binary logarithm for all elements in `v`. The special cases are equivalent to those in `ln`.'
}, {
  insertText: 'log10',
  label: 'log10',
  detail: 'log10(v instant-vector)',
  documentation: 'Calculates the decimal logarithm for all elements in `v`. The special cases are equivalent to those in `ln`.'
}, {
  insertText: 'minute',
  label: 'minute',
  detail: 'minute(v=vector(time()) instant-vector)',
  documentation: 'Returns the minute of the hour for each of the given times in UTC. Returned values are from 0 to 59.'
}, {
  insertText: 'month',
  label: 'month',
  detail: 'month(v=vector(time()) instant-vector)',
  documentation: 'Returns the month of the year for each of the given times in UTC. Returned values are from 1 to 12, where 1 means January etc.'
}, {
  insertText: 'pi',
  label: 'pi',
  detail: 'pi()',
  documentation: 'Returns pi'
}, {
  insertText: 'predict_linear',
  label: 'predict_linear',
  detail: 'predict_linear(v range-vector, t scalar)',
  documentation: 'Predicts the value of time series `t` seconds from now, based on the range vector `v`, using simple linear regression.'
}, {
  insertText: 'rad',
  label: 'rad',
  detail: 'rad(v instant-vector)',
  documentation: 'Converts degrees to radians for all elements in v'
}, {
  insertText: 'rate',
  label: 'rate',
  detail: 'rate(v range-vector)',
  documentation: "Calculates the per-second average rate of increase of the time series in the range vector. Breaks in monotonicity (such as counter resets due to target restarts) are automatically adjusted for. Also, the calculation extrapolates to the ends of the time range, allowing for missed scrapes or imperfect alignment of scrape cycles with the range's time period."
}, {
  insertText: 'resets',
  label: 'resets',
  detail: 'resets(v range-vector)',
  documentation: 'For each input time series, `resets(v range-vector)` returns the number of counter resets within the provided time range as an instant vector. Any decrease in the value between two consecutive samples is interpreted as a counter reset.'
}, {
  insertText: 'round',
  label: 'round',
  detail: 'round(v instant-vector, to_nearest=1 scalar)',
  documentation: 'Rounds the sample values of all elements in `v` to the nearest integer. Ties are resolved by rounding up. The optional `to_nearest` argument allows specifying the nearest multiple to which the sample values should be rounded. This multiple may also be a fraction.'
}, {
  insertText: 'scalar',
  label: 'scalar',
  detail: 'scalar(v instant-vector)',
  documentation: 'Given a single-element input vector, `scalar(v instant-vector)` returns the sample value of that single element as a scalar. If the input vector does not have exactly one element, `scalar` will return `NaN`.'
}, {
  insertText: 'sgn',
  label: 'sgn',
  detail: 'sgn(v instant-vector)',
  documentation: 'Returns a vector with all sample values converted to their sign, defined as this: 1 if v is positive, -1 if v is negative and 0 if v is equal to zero.'
}, {
  insertText: 'sort',
  label: 'sort',
  detail: 'sort(v instant-vector)',
  documentation: 'Returns vector elements sorted by their sample values, in ascending order.'
}, {
  insertText: 'sort_desc',
  label: 'sort_desc',
  detail: 'sort_desc(v instant-vector)',
  documentation: 'Returns vector elements sorted by their sample values, in descending order.'
}, {
  insertText: 'sqrt',
  label: 'sqrt',
  detail: 'sqrt(v instant-vector)',
  documentation: 'Calculates the square root of all elements in `v`.'
}, {
  insertText: 'time',
  label: 'time',
  detail: 'time()',
  documentation: 'Returns the number of seconds since January 1, 1970 UTC. Note that this does not actually return the current time, but the time at which the expression is to be evaluated.'
}, {
  insertText: 'timestamp',
  label: 'timestamp',
  detail: 'timestamp(v instant-vector)',
  documentation: 'Returns the timestamp of each of the samples of the given vector as the number of seconds since January 1, 1970 UTC.'
}, {
  insertText: 'vector',
  label: 'vector',
  detail: 'vector(s scalar)',
  documentation: 'Returns the scalar `s` as a vector with no labels.'
}, {
  insertText: 'year',
  label: 'year',
  detail: 'year(v=vector(time()) instant-vector)',
  documentation: 'Returns the year for each of the given times in UTC.'
}, {
  insertText: 'avg_over_time',
  label: 'avg_over_time',
  detail: 'avg_over_time(range-vector)',
  documentation: 'The average value of all points in the specified interval.'
}, {
  insertText: 'min_over_time',
  label: 'min_over_time',
  detail: 'min_over_time(range-vector)',
  documentation: 'The minimum value of all points in the specified interval.'
}, {
  insertText: 'max_over_time',
  label: 'max_over_time',
  detail: 'max_over_time(range-vector)',
  documentation: 'The maximum value of all points in the specified interval.'
}, {
  insertText: 'sum_over_time',
  label: 'sum_over_time',
  detail: 'sum_over_time(range-vector)',
  documentation: 'The sum of all values in the specified interval.'
}, {
  insertText: 'count_over_time',
  label: 'count_over_time',
  detail: 'count_over_time(range-vector)',
  documentation: 'The count of all values in the specified interval.'
}, {
  insertText: 'quantile_over_time',
  label: 'quantile_over_time',
  detail: 'quantile_over_time(scalar, range-vector)',
  documentation: 'The φ-quantile (0 ≤ φ ≤ 1) of the values in the specified interval.'
}, {
  insertText: 'stddev_over_time',
  label: 'stddev_over_time',
  detail: 'stddev_over_time(range-vector)',
  documentation: 'The population standard deviation of the values in the specified interval.'
}, {
  insertText: 'stdvar_over_time',
  label: 'stdvar_over_time',
  detail: 'stdvar_over_time(range-vector)',
  documentation: 'The population standard variance of the values in the specified interval.'
}, {
  insertText: 'last_over_time',
  label: 'last_over_time',
  detail: 'last_over_time(range-vector)',
  documentation: 'The most recent point value in specified interval.'
}];
const PROM_KEYWORDS = FUNCTIONS.map(keyword => keyword.label);
const promqlGrammar = {
  comment: {
    pattern: /#.*/
  },
  'context-aggregation': {
    pattern: /((by|without)\s*)\([^)]*\)/,
    // by ()
    lookbehind: true,
    inside: {
      'label-key': {
        pattern: /[^(),\s][^,)]*[^),\s]*/,
        alias: 'attr-name'
      },
      punctuation: /[()]/
    }
  },
  'context-labels': {
    pattern: /\{[^}]*(?=}?)/,
    greedy: true,
    inside: {
      comment: {
        pattern: /#.*/
      },
      'label-key': {
        pattern: /[a-z_]\w*(?=\s*(=|!=|=~|!~))/,
        alias: 'attr-name',
        greedy: true
      },
      'label-value': {
        pattern: /"(?:\\.|[^\\"])*"/,
        greedy: true,
        alias: 'attr-value'
      },
      punctuation: /[{]/
    }
  },
  function: new RegExp(`\\b(?:${FUNCTIONS.map(f => f.label).join('|')})(?=\\s*\\()`, 'i'),
  'context-range': [{
    pattern: /\[[^\]]*(?=])/,
    // [1m]
    inside: {
      'range-duration': {
        pattern: /\b\d+[smhdwy]\b/i,
        alias: 'number'
      }
    }
  }, {
    pattern: /(offset\s+)\w+/,
    // offset 1m
    lookbehind: true,
    inside: {
      'range-duration': {
        pattern: /\b\d+[smhdwy]\b/i,
        alias: 'number'
      }
    }
  }],
  idList: {
    pattern: /\d+(\|\d+)+/,
    alias: 'number'
  },
  number: /\b-?\d+((\.\d*)?([eE][+-]?\d+)?)?\b/,
  operator: new RegExp(`/[-+*/=%^~]|&&?|\\|?\\||!=?|<(?:=>?|<|>)?|>[>=]?|\\b(?:${OPERATORS.join('|')})\\b`, 'i'),
  punctuation: /[{};()`,.]/
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (promqlGrammar);

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/query_hints.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SUM_HINT_THRESHOLD_COUNT": () => (/* binding */ SUM_HINT_THRESHOLD_COUNT),
/* harmony export */   "getInitHints": () => (/* binding */ getInitHints),
/* harmony export */   "getQueryHints": () => (/* binding */ getQueryHints)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);


/**
 * Number of time series results needed before starting to suggest sum aggregation hints
 */
const SUM_HINT_THRESHOLD_COUNT = 20;
function getQueryHints(query, series, datasource) {
  const hints = []; // ..._bucket metric needs a histogram_quantile()

  const histogramMetric = query.trim().match(/^\w+_bucket$|^\w+_bucket{.*}$/);

  if (histogramMetric) {
    const label = 'Selected metric has buckets.';
    hints.push({
      type: 'HISTOGRAM_QUANTILE',
      label,
      fix: {
        label: 'Consider calculating aggregated quantile by adding histogram_quantile().',
        action: {
          type: 'ADD_HISTOGRAM_QUANTILE',
          query
        }
      }
    });
  } // Check for need of rate()


  if (query.indexOf('rate(') === -1 && query.indexOf('increase(') === -1) {
    var _datasource$languageP, _datasource$languageP2;

    // Use metric metadata for exact types
    const nameMatch = query.match(/\b(\w+_(total|sum|count))\b/);
    let counterNameMetric = nameMatch ? nameMatch[1] : '';
    const metricsMetadata = (_datasource$languageP = datasource === null || datasource === void 0 ? void 0 : (_datasource$languageP2 = datasource.languageProvider) === null || _datasource$languageP2 === void 0 ? void 0 : _datasource$languageP2.metricsMetadata) !== null && _datasource$languageP !== void 0 ? _datasource$languageP : {};
    const metricMetadataKeys = Object.keys(metricsMetadata);
    let certain = false;

    if (metricMetadataKeys.length > 0) {
      var _metricMetadataKeys$f;

      counterNameMetric = (_metricMetadataKeys$f = metricMetadataKeys.find(metricName => {
        // Only considering first type information, could be non-deterministic
        const metadata = metricsMetadata[metricName];

        if (metadata.type.toLowerCase() === 'counter') {
          const metricRegex = new RegExp(`\\b${metricName}\\b`);

          if (query.match(metricRegex)) {
            certain = true;
            return true;
          }
        }

        return false;
      })) !== null && _metricMetadataKeys$f !== void 0 ? _metricMetadataKeys$f : '';
    }

    if (counterNameMetric) {
      // FixableQuery consists of metric name and optionally label-value pairs. We are not offering fix for complex queries yet.
      const fixableQuery = query.trim().match(/^\w+$|^\w+{.*}$/);
      const verb = certain ? 'is' : 'looks like';
      let label = `Selected metric ${verb} a counter.`;
      let fix;

      if (fixableQuery) {
        fix = {
          label: 'Consider calculating rate of counter by adding rate().',
          action: {
            type: 'ADD_RATE',
            query
          }
        };
      } else {
        label = `${label} Consider calculating rate of counter by adding rate().`;
      }

      hints.push({
        type: 'APPLY_RATE',
        label,
        fix
      });
    }
  } // Check for recording rules expansion


  if (datasource && datasource.ruleMappings) {
    const mapping = datasource.ruleMappings;
    const mappingForQuery = Object.keys(mapping).reduce((acc, ruleName) => {
      if (query.search(ruleName) > -1) {
        return Object.assign({}, acc, {
          [ruleName]: mapping[ruleName]
        });
      }

      return acc;
    }, {});

    if ((0,lodash__WEBPACK_IMPORTED_MODULE_0__.size)(mappingForQuery) > 0) {
      const label = 'Query contains recording rules.';
      hints.push({
        type: 'EXPAND_RULES',
        label,
        fix: {
          label: 'Expand rules',
          action: {
            type: 'EXPAND_RULES',
            query,
            mapping: mappingForQuery
          }
        }
      });
    }
  }

  if (series && series.length >= SUM_HINT_THRESHOLD_COUNT) {
    const simpleMetric = query.trim().match(/^\w+$/);

    if (simpleMetric) {
      hints.push({
        type: 'ADD_SUM',
        label: 'Many time series results returned.',
        fix: {
          label: 'Consider aggregating with sum().',
          action: {
            type: 'ADD_SUM',
            query: query,
            preventSubmit: true
          }
        }
      });
    }
  }

  return hints;
}
function getInitHints(datasource) {
  const hints = []; // Hint if using Loki as Prometheus data source

  if (datasource.directUrl.includes('/loki') && !datasource.languageProvider.metrics.length) {
    hints.push({
      label: `Using Loki as a Prometheus data source is no longer supported. You must use the Loki data source for your Loki instance.`,
      type: 'INFO'
    });
  } // Hint for big disabled lookups


  if (datasource.lookupsDisabled) {
    hints.push({
      label: `Labels and metrics lookup was disabled in data source settings.`,
      type: 'INFO'
    });
  }

  return hints;
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/PromQueryModeller.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromQueryModeller": () => (/* binding */ PromQueryModeller),
/* harmony export */   "promQueryModeller": () => (/* binding */ promQueryModeller)
/* harmony export */ });
/* harmony import */ var _promql__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/datasource/prometheus/promql.ts");
/* harmony import */ var _aggregations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/aggregations.ts");
/* harmony import */ var _operations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/operations.ts");
/* harmony import */ var _shared_LokiAndPromQueryModellerBase__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/LokiAndPromQueryModellerBase.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/types.ts");





class PromQueryModeller extends _shared_LokiAndPromQueryModellerBase__WEBPACK_IMPORTED_MODULE_3__.LokiAndPromQueryModellerBase {
  constructor() {
    super(() => {
      const allOperations = [...(0,_operations__WEBPACK_IMPORTED_MODULE_2__.getOperationDefinitions)(), ...(0,_aggregations__WEBPACK_IMPORTED_MODULE_1__.getAggregationOperations)()];

      for (const op of allOperations) {
        const func = _promql__WEBPACK_IMPORTED_MODULE_0__.FUNCTIONS.find(x => x.insertText === op.id);

        if (func) {
          op.documentation = func.documentation;
        }
      }

      return allOperations;
    });
    this.setOperationCategories([_types__WEBPACK_IMPORTED_MODULE_4__.PromVisualQueryOperationCategory.Aggregations, _types__WEBPACK_IMPORTED_MODULE_4__.PromVisualQueryOperationCategory.RangeFunctions, _types__WEBPACK_IMPORTED_MODULE_4__.PromVisualQueryOperationCategory.Functions, _types__WEBPACK_IMPORTED_MODULE_4__.PromVisualQueryOperationCategory.BinaryOps, _types__WEBPACK_IMPORTED_MODULE_4__.PromVisualQueryOperationCategory.Trigonometric, _types__WEBPACK_IMPORTED_MODULE_4__.PromVisualQueryOperationCategory.Time]);
  }

  getQueryPatterns() {
    return [{
      name: 'Rate then sum',
      operations: [{
        id: 'rate',
        params: ['$__rate_interval']
      }, {
        id: 'sum',
        params: []
      }]
    }, {
      name: 'Rate then sum by(label) then avg',
      operations: [{
        id: 'rate',
        params: ['$__rate_interval']
      }, {
        id: '__sum_by',
        params: ['']
      }, {
        id: 'avg',
        params: []
      }]
    }, {
      name: 'Histogram quantile on rate',
      operations: [{
        id: 'rate',
        params: ['$__rate_interval']
      }, {
        id: '__sum_by',
        params: ['le']
      }, {
        id: 'histogram_quantile',
        params: [0.95]
      }]
    }, {
      name: 'Histogram quantile on increase ',
      operations: [{
        id: 'increase',
        params: ['$__rate_interval']
      }, {
        id: '__max_by',
        params: ['le']
      }, {
        id: 'histogram_quantile',
        params: [0.95]
      }]
    }];
  }

}
const promQueryModeller = new PromQueryModeller();

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/aggregations.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getAggregationOperations": () => (/* binding */ getAggregationOperations)
/* harmony export */ });
/* harmony import */ var _operations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/operations.ts");
/* harmony import */ var _shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/types.ts");



function getAggregationOperations() {
  return [...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperation)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Sum), ...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperation)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Avg), ...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperation)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Min), ...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperation)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Max), ...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperation)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Count), ...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperationWithParam)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.TopK, {
    params: [{
      name: 'K-value',
      type: 'number'
    }],
    defaultParams: [5]
  }), ...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperationWithParam)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.BottomK, {
    params: [{
      name: 'K-value',
      type: 'number'
    }],
    defaultParams: [5]
  }), ...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperationWithParam)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.CountValues, {
    params: [{
      name: 'Identifier',
      type: 'string'
    }],
    defaultParams: ['count']
  }), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.SumOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.AvgOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.MinOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.MaxOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.CountOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.LastOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.PresentOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.AbsentOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.StddevOverTime)];
}

function createAggregationOverTime(name) {
  return {
    id: name,
    name: (0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.getPromAndLokiOperationDisplayName)(name),
    params: [(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.getRangeVectorParamDef)()],
    defaultParams: ['$__interval'],
    alternativesKey: 'overtime function',
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.RangeFunctions,
    renderer: operationWithRangeVectorRenderer,
    addOperationHandler: _operations__WEBPACK_IMPORTED_MODULE_0__.addOperationWithRangeVector
  };
}

function operationWithRangeVectorRenderer(model, def, innerExpr) {
  var _, _model$params;

  let rangeVector = (_ = ((_model$params = model.params) !== null && _model$params !== void 0 ? _model$params : [])[0]) !== null && _ !== void 0 ? _ : '$__interval';
  return `${def.id}(${innerExpr}[${rangeVector}])`;
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/binaryScalarOperations.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "binaryScalarDefs": () => (/* binding */ binaryScalarDefs),
/* harmony export */   "binaryScalarOperations": () => (/* binding */ binaryScalarOperations),
/* harmony export */   "binaryScalarOperatorToOperatorName": () => (/* binding */ binaryScalarOperatorToOperatorName)
/* harmony export */ });
/* harmony import */ var _shared_operationUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/types.ts");


const binaryScalarDefs = [{
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.Addition,
  name: 'Add scalar',
  sign: '+'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.Subtraction,
  name: 'Subtract scalar',
  sign: '-'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.MultiplyBy,
  name: 'Multiply by scalar',
  sign: '*'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.DivideBy,
  name: 'Divide by scalar',
  sign: '/'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.Modulo,
  name: 'Modulo by scalar',
  sign: '%'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.Exponent,
  name: 'Exponent',
  sign: '^'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.EqualTo,
  name: 'Equal to',
  sign: '==',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.NotEqualTo,
  name: 'Not equal to',
  sign: '!=',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.GreaterThan,
  name: 'Greater than',
  sign: '>',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.LessThan,
  name: 'Less than',
  sign: '<',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.GreaterOrEqual,
  name: 'Greater or equal to',
  sign: '>=',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.PromOperationId.LessOrEqual,
  name: 'Less or equal to',
  sign: '<=',
  comparison: true
}];
const binaryScalarOperatorToOperatorName = binaryScalarDefs.reduce((acc, def) => {
  acc[def.sign] = {
    id: def.id,
    comparison: def.comparison
  };
  return acc;
}, {}); // Not sure about this one. It could also be a more generic 'Simple math operation' where user specifies
// both the operator and the operand in a single input

const binaryScalarOperations = binaryScalarDefs.map(opDef => {
  const params = [{
    name: 'Value',
    type: 'number'
  }];
  const defaultParams = [2];

  if (opDef.comparison) {
    params.push({
      name: 'Bool',
      type: 'boolean',
      description: 'If checked comparison will return 0 or 1 for the value rather than filtering.'
    });
    defaultParams.push(false);
  }

  return {
    id: opDef.id,
    name: opDef.name,
    params,
    defaultParams,
    alternativesKey: 'binary scalar operations',
    category: _types__WEBPACK_IMPORTED_MODULE_1__.PromVisualQueryOperationCategory.BinaryOps,
    renderer: getSimpleBinaryRenderer(opDef.sign),
    addOperationHandler: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_0__.defaultAddOperationHandler
  };
});

function getSimpleBinaryRenderer(operator) {
  return function binaryRenderer(model, def, innerExpr) {
    let param = model.params[0];
    let bool = '';

    if (model.params.length === 2) {
      bool = model.params[1] ? ' bool' : '';
    }

    return `${innerExpr} ${operator}${bool} ${param}`;
  };
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/components/LabelParamEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LabelParamEditor": () => (/* binding */ LabelParamEditor)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _datasource__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/datasource.tsx");
/* harmony import */ var _PromQueryModeller__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/PromQueryModeller.ts");
/* harmony import */ var _shared_operationUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");







function LabelParamEditor({
  onChange,
  index,
  operationIndex,
  value,
  query,
  datasource
}) {
  const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Select, {
    inputId: (0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_5__.getOperationParamId)(operationIndex, index),
    autoFocus: value === '' ? true : undefined,
    openMenuOnFocus: true,
    onOpenMenu: async () => {
      setState({
        isLoading: true
      });
      const options = await loadGroupByLabels(query, datasource);
      setState({
        options,
        isLoading: undefined
      });
    },
    isLoading: state.isLoading,
    allowCustomValue: true,
    noOptionsMessage: "No labels found",
    loadingMessage: "Loading labels",
    options: state.options,
    value: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_1__.toOption)(value),
    onChange: value => onChange(index, value.value)
  });
}

async function loadGroupByLabels(query, datasource) {
  let labels = query.labels; // This function is used by both Prometheus and Loki and this the only difference

  if (datasource instanceof _datasource__WEBPACK_IMPORTED_MODULE_3__.PrometheusDatasource) {
    labels = [{
      label: '__name__',
      op: '=',
      value: query.metric
    }, ...query.labels];
  }

  const expr = _PromQueryModeller__WEBPACK_IMPORTED_MODULE_4__.promQueryModeller.renderLabels(labels);
  const result = await datasource.languageProvider.fetchSeriesLabels(expr);
  return Object.keys(result).map(x => ({
    label: x,
    value: x
  }));
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/operations.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addOperationWithRangeVector": () => (/* binding */ addOperationWithRangeVector),
/* harmony export */   "createFunction": () => (/* binding */ createFunction),
/* harmony export */   "createRangeFunction": () => (/* binding */ createRangeFunction),
/* harmony export */   "getOperationDefinitions": () => (/* binding */ getOperationDefinitions),
/* harmony export */   "operationWithRangeVectorRenderer": () => (/* binding */ operationWithRangeVectorRenderer)
/* harmony export */ });
/* harmony import */ var _binaryScalarOperations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/binaryScalarOperations.ts");
/* harmony import */ var _components_LabelParamEditor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/LabelParamEditor.tsx");
/* harmony import */ var _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/types.ts");




function getOperationDefinitions() {
  const list = [{
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.HistogramQuantile,
    name: 'Histogram quantile',
    params: [{
      name: 'Quantile',
      type: 'number',
      options: [0.99, 0.95, 0.9, 0.75, 0.5, 0.25]
    }],
    defaultParams: [0.9],
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Functions,
    renderer: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.functionRendererLeft,
    addOperationHandler: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.defaultAddOperationHandler
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.LabelReplace,
    name: 'Label replace',
    params: [{
      name: 'Destination label',
      type: 'string'
    }, {
      name: 'Replacement',
      type: 'string'
    }, {
      name: 'Source label',
      type: 'string'
    }, {
      name: 'Regex',
      type: 'string'
    }],
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Functions,
    defaultParams: ['', '$1', '', '(.*)'],
    renderer: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.functionRendererRight,
    addOperationHandler: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.defaultAddOperationHandler
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Ln,
    name: 'Ln',
    params: [],
    defaultParams: [],
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Functions,
    renderer: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.functionRendererLeft,
    addOperationHandler: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.defaultAddOperationHandler
  }, createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Changes), createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Rate, true), createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Irate), createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Increase, true), createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Idelta), createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Delta), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.HoltWinters,
    params: [(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.getRangeVectorParamDef)(), {
      name: 'Smoothing Factor',
      type: 'number'
    }, {
      name: 'Trend Factor',
      type: 'number'
    }],
    defaultParams: ['$__interval', 0.5, 0.5],
    alternativesKey: 'range function',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.RangeFunctions,
    renderer: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.rangeRendererRightWithParams,
    addOperationHandler: addOperationWithRangeVector,
    changeTypeHandler: operationTypeChangedHandlerForRangeFunction
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.PredictLinear,
    params: [(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.getRangeVectorParamDef)(), {
      name: 'Seconds from now',
      type: 'number'
    }],
    defaultParams: ['$__interval', 60],
    alternativesKey: 'range function',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.RangeFunctions,
    renderer: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.rangeRendererRightWithParams,
    addOperationHandler: addOperationWithRangeVector,
    changeTypeHandler: operationTypeChangedHandlerForRangeFunction
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.QuantileOverTime,
    params: [(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.getRangeVectorParamDef)(), {
      name: 'Quantile',
      type: 'number'
    }],
    defaultParams: ['$__interval', 0.5],
    alternativesKey: 'overtime function',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.RangeFunctions,
    renderer: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.rangeRendererLeftWithParams,
    addOperationHandler: addOperationWithRangeVector,
    changeTypeHandler: operationTypeChangedHandlerForRangeFunction
  }), ..._binaryScalarOperations__WEBPACK_IMPORTED_MODULE_0__.binaryScalarOperations, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.NestedQuery,
    name: 'Binary operation with query',
    params: [],
    defaultParams: [],
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.BinaryOps,
    renderer: (model, def, innerExpr) => innerExpr,
    addOperationHandler: addNestedQueryHandler
  }, createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Absent
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Acos,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Acosh,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Asin,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Asinh,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Atan,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Atanh,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Ceil
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Clamp,
    name: 'Clamp',
    params: [{
      name: 'Minimum Scalar',
      type: 'number'
    }, {
      name: 'Maximum Scalar',
      type: 'number'
    }],
    defaultParams: [1, 1]
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.ClampMax,
    params: [{
      name: 'Maximum Scalar',
      type: 'number'
    }],
    defaultParams: [1]
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.ClampMin,
    params: [{
      name: 'Minimum Scalar',
      type: 'number'
    }],
    defaultParams: [1]
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Cos,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Cosh,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.DayOfMonth,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Time
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.DayOfWeek,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Time
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.DaysInMonth,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Time
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Deg
  }), createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Deriv), //
  createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Exp
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Floor
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Group
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Hour
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.LabelJoin,
    params: [{
      name: 'Destination Label',
      type: 'string',
      editor: _components_LabelParamEditor__WEBPACK_IMPORTED_MODULE_1__.LabelParamEditor
    }, {
      name: 'Separator',
      type: 'string'
    }, {
      name: 'Source Label',
      type: 'string',
      restParam: true,
      optional: true,
      editor: _components_LabelParamEditor__WEBPACK_IMPORTED_MODULE_1__.LabelParamEditor
    }],
    defaultParams: ['', ',', ''],
    renderer: labelJoinRenderer,
    addOperationHandler: labelJoinAddOperationHandler
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Log10
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Log2
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Minute
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Month
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Pi,
    renderer: model => `${model.id}()`
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Quantile,
    params: [{
      name: 'Value',
      type: 'number'
    }],
    defaultParams: [1],
    renderer: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.functionRendererLeft
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Rad
  }), createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Resets), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Round,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Functions,
    params: [{
      name: 'To Nearest',
      type: 'number'
    }],
    defaultParams: [1]
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Scalar
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Sgn
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Sin,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Sinh,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Sort
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.SortDesc
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Sqrt
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Stddev
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Tan,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Tanh,
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Time,
    renderer: model => `${model.id}()`
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Timestamp
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Vector,
    params: [{
      name: 'Value',
      type: 'number'
    }],
    defaultParams: [1],
    renderer: model => `${model.id}(${model.params[0]})`
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_3__.PromOperationId.Year
  })];
  return list;
}
function createFunction(definition) {
  var _definition$name, _definition$params, _definition$defaultPa, _definition$category, _definition$renderer, _definition$addOperat;

  return Object.assign({}, definition, {
    id: definition.id,
    name: (_definition$name = definition.name) !== null && _definition$name !== void 0 ? _definition$name : (0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.getPromAndLokiOperationDisplayName)(definition.id),
    params: (_definition$params = definition.params) !== null && _definition$params !== void 0 ? _definition$params : [],
    defaultParams: (_definition$defaultPa = definition.defaultParams) !== null && _definition$defaultPa !== void 0 ? _definition$defaultPa : [],
    category: (_definition$category = definition.category) !== null && _definition$category !== void 0 ? _definition$category : _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Functions,
    renderer: (_definition$renderer = definition.renderer) !== null && _definition$renderer !== void 0 ? _definition$renderer : definition.params ? _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.functionRendererRight : _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.functionRendererLeft,
    addOperationHandler: (_definition$addOperat = definition.addOperationHandler) !== null && _definition$addOperat !== void 0 ? _definition$addOperat : _shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.defaultAddOperationHandler
  });
}
function createRangeFunction(name, withRateInterval = false) {
  return {
    id: name,
    name: (0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.getPromAndLokiOperationDisplayName)(name),
    params: [(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_2__.getRangeVectorParamDef)(withRateInterval)],
    defaultParams: [withRateInterval ? '$__rate_interval' : '$__interval'],
    alternativesKey: 'range function',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.RangeFunctions,
    renderer: operationWithRangeVectorRenderer,
    addOperationHandler: addOperationWithRangeVector,
    changeTypeHandler: operationTypeChangedHandlerForRangeFunction
  };
}

function operationTypeChangedHandlerForRangeFunction(operation, newDef) {
  // validate current parameter
  if (operation.params[0] === '$__rate_interval' && newDef.defaultParams[0] !== '$__rate_interval') {
    operation.params = newDef.defaultParams;
  } else if (operation.params[0] === '$__interval' && newDef.defaultParams[0] !== '$__interval') {
    operation.params = newDef.defaultParams;
  }

  return operation;
}

function operationWithRangeVectorRenderer(model, def, innerExpr) {
  var _, _model$params;

  let rangeVector = (_ = ((_model$params = model.params) !== null && _model$params !== void 0 ? _model$params : [])[0]) !== null && _ !== void 0 ? _ : '5m';
  return `${def.id}(${innerExpr}[${rangeVector}])`;
}
/**
 * Since there can only be one operation with range vector this will replace the current one (if one was added )
 */

function addOperationWithRangeVector(def, query, modeller) {
  const newOperation = {
    id: def.id,
    params: def.defaultParams
  };

  if (query.operations.length > 0) {
    // If operation exists it has to be in the registry so no point to check if it was found
    const firstOp = modeller.getOperationDef(query.operations[0].id);

    if (firstOp.addOperationHandler === addOperationWithRangeVector) {
      return Object.assign({}, query, {
        operations: [newOperation, ...query.operations.slice(1)]
      });
    }
  }

  return Object.assign({}, query, {
    operations: [newOperation, ...query.operations]
  });
}

function addNestedQueryHandler(def, query) {
  var _query$binaryQueries;

  return Object.assign({}, query, {
    binaryQueries: [...((_query$binaryQueries = query.binaryQueries) !== null && _query$binaryQueries !== void 0 ? _query$binaryQueries : []), {
      operator: '/',
      query
    }]
  });
}

function labelJoinRenderer(model, def, innerExpr) {
  if (typeof model.params[1] !== 'string') {
    throw 'The separator must be a string';
  }

  const separator = `"${model.params[1]}"`;
  return `${model.id}(${innerExpr}, "${model.params[0]}", ${separator}, "${model.params.slice(2).join(separator)}")`;
}

function labelJoinAddOperationHandler(def, query) {
  const newOperation = {
    id: def.id,
    params: def.defaultParams
  };
  return Object.assign({}, query, {
    operations: [...query.operations, newOperation]
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/parsing.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "buildVisualQueryFromString": () => (/* binding */ buildVisualQueryFromString),
/* harmony export */   "handleExpression": () => (/* binding */ handleExpression)
/* harmony export */ });
/* harmony import */ var lezer_promql__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/lezer-promql-virtual-eaf88aa77a/0/cache/lezer-promql-npm-0.22.0-867da6afaa-cdce054700.zip/node_modules/lezer-promql/index.es.js");
/* harmony import */ var _binaryScalarOperations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/binaryScalarOperations.ts");
/* harmony import */ var _shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/parsingUtils.ts");




/**
 * Parses a PromQL query into a visual query model.
 *
 * It traverses the tree and uses sort of state machine to update the query model. The query model is modified
 * during the traversal and sent to each handler as context.
 *
 * @param expr
 */
function buildVisualQueryFromString(expr) {
  const replacedExpr = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.replaceVariables)(expr);
  const tree = lezer_promql__WEBPACK_IMPORTED_MODULE_0__.parser.parse(replacedExpr);
  const node = tree.topNode; // This will be modified in the handlers.

  const visQuery = {
    metric: '',
    labels: [],
    operations: []
  };
  const context = {
    query: visQuery,
    errors: []
  };

  try {
    handleExpression(replacedExpr, node, context);
  } catch (err) {
    // Not ideal to log it here, but otherwise we would lose the stack trace.
    console.error(err);
    context.errors.push({
      text: err.message
    });
  } // If we have empty query, we want to reset errors


  if (isEmptyQuery(context.query)) {
    context.errors = [];
  }

  return context;
}

/**
 * Handler for default state. It will traverse the tree and call the appropriate handler for each node. The node
 * handled here does not necessarily need to be of type == Expr.
 * @param expr
 * @param node
 * @param context
 */
function handleExpression(expr, node, context) {
  const visQuery = context.query;

  switch (node.name) {
    case 'MetricIdentifier':
      {
        // Expectation is that there is only one of those per query.
        visQuery.metric = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, node);
        break;
      }

    case 'LabelMatcher':
      {
        // Same as MetricIdentifier should be just one per query.
        visQuery.labels.push(getLabel(expr, node));
        const err = node.getChild(_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.ErrorName);

        if (err) {
          context.errors.push((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.makeError)(expr, err));
        }

        break;
      }

    case 'FunctionCall':
      {
        handleFunction(expr, node, context);
        break;
      }

    case 'AggregateExpr':
      {
        handleAggregation(expr, node, context);
        break;
      }

    case 'BinaryExpr':
      {
        handleBinary(expr, node, context);
        break;
      }

    case _shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.ErrorName:
      {
        if (isIntervalVariableError(node)) {
          break;
        }

        context.errors.push((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.makeError)(expr, node));
        break;
      }

    default:
      {
        if (node.name === 'ParenExpr') {
          // We don't support parenthesis in the query to group expressions. We just report error but go on with the
          // parsing.
          context.errors.push((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.makeError)(expr, node));
        } // Any other nodes we just ignore and go to it's children. This should be fine as there are lot's of wrapper
        // nodes that can be skipped.
        // TODO: there are probably cases where we will just skip nodes we don't support and we should be able to
        //  detect those and report back.


        let child = node.firstChild;

        while (child) {
          handleExpression(expr, child, context);
          child = child.nextSibling;
        }
      }
  }
}

function isIntervalVariableError(node) {
  var _node$prevSibling, _node$prevSibling2, _node$prevSibling2$fi;

  return ((_node$prevSibling = node.prevSibling) === null || _node$prevSibling === void 0 ? void 0 : _node$prevSibling.name) === 'Expr' && ((_node$prevSibling2 = node.prevSibling) === null || _node$prevSibling2 === void 0 ? void 0 : (_node$prevSibling2$fi = _node$prevSibling2.firstChild) === null || _node$prevSibling2$fi === void 0 ? void 0 : _node$prevSibling2$fi.name) === 'VectorSelector';
}

function getLabel(expr, node) {
  const label = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, node.getChild('LabelName'));
  const op = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, node.getChild('MatchOp'));
  const value = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, node.getChild('StringLiteral')).replace(/"/g, '');
  return {
    label,
    op,
    value
  };
}

const rangeFunctions = ['changes', 'rate', 'irate', 'increase', 'delta'];
/**
 * Handle function call which is usually and identifier and its body > arguments.
 * @param expr
 * @param node
 * @param context
 */

function handleFunction(expr, node, context) {
  const visQuery = context.query;
  const nameNode = node.getChild('FunctionIdentifier');
  const funcName = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, nameNode);
  const body = node.getChild('FunctionCallBody');
  const callArgs = body.getChild('FunctionCallArgs');
  const params = [];
  let interval = ''; // This is a bit of a shortcut to get the interval argument. Reasons are
  // - interval is not part of the function args per promQL grammar but we model it as argument for the function in
  //   the query model.
  // - it is easier to handle template variables this way as template variable is an error for the parser

  if (rangeFunctions.includes(funcName) || funcName.endsWith('_over_time')) {
    let match = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, node).match(/\[(.+)\]/);

    if (match !== null && match !== void 0 && match[1]) {
      interval = match[1];
      params.push(match[1]);
    }
  }

  const op = {
    id: funcName,
    params
  }; // We unshift operations to keep the more natural order that we want to have in the visual query editor.

  visQuery.operations.unshift(op);

  if (callArgs) {
    if ((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, callArgs) === interval + ']') {
      // This is a special case where we have a function with a single argument and it is the interval.
      // This happens when you start adding operations in query builder and did not set a metric yet.
      return;
    }

    updateFunctionArgs(expr, callArgs, context, op);
  }
}
/**
 * Handle aggregation as they are distinct type from other functions.
 * @param expr
 * @param node
 * @param context
 */


function handleAggregation(expr, node, context) {
  const visQuery = context.query;
  const nameNode = node.getChild('AggregateOp');
  let funcName = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, nameNode);
  const modifier = node.getChild('AggregateModifier');
  const labels = [];

  if (modifier) {
    const byModifier = modifier.getChild(`By`);

    if (byModifier && funcName) {
      funcName = `__${funcName}_by`;
    }

    const withoutModifier = modifier.getChild(`Without`);

    if (withoutModifier) {
      funcName = `__${funcName}_without`;
    }

    labels.push(...(0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getAllByType)(expr, modifier, 'GroupingLabel'));
  }

  const body = node.getChild('FunctionCallBody');
  const callArgs = body.getChild('FunctionCallArgs');
  const op = {
    id: funcName,
    params: []
  };
  visQuery.operations.unshift(op);
  updateFunctionArgs(expr, callArgs, context, op); // We add labels after params in the visual query editor.

  op.params.push(...labels);
}
/**
 * Handle (probably) all types of arguments that function or aggregation can have.
 *
 *  FunctionCallArgs are nested bit weirdly basically its [firstArg, ...rest] where rest is again FunctionCallArgs so
 *  we cannot just get all the children and iterate them as arguments we have to again recursively traverse through
 *  them.
 *
 * @param expr
 * @param node
 * @param context
 * @param op - We need the operation to add the params to as an additional context.
 */


function updateFunctionArgs(expr, node, context, op) {
  if (!node) {
    return;
  }

  switch (node.name) {
    // In case we have an expression we don't know what kind so we have to look at the child as it can be anything.
    case 'Expr': // FunctionCallArgs are nested bit weirdly as mentioned so we have to go one deeper in this case.

    case 'FunctionCallArgs':
      {
        let child = node.firstChild;

        while (child) {
          updateFunctionArgs(expr, child, context, op);
          child = child.nextSibling;
        }

        break;
      }

    case 'NumberLiteral':
      {
        op.params.push(parseFloat((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, node)));
        break;
      }

    case 'StringLiteral':
      {
        op.params.push((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, node).replace(/"/g, ''));
        break;
      }

    default:
      {
        // Means we get to something that does not seem like simple function arg and is probably nested query so jump
        // back to main context
        handleExpression(expr, node, context);
      }
  }
}
/**
 * Right now binary expressions can be represented in 2 way in visual query. As additional operation in case it is
 * just operation with scalar or it creates a binaryQuery when it's 2 queries.
 * @param expr
 * @param node
 * @param context
 */


function handleBinary(expr, node, context) {
  const visQuery = context.query;
  const left = node.firstChild;
  const op = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, left.nextSibling);
  const binModifier = getBinaryModifier(expr, node.getChild('BinModifiers'));
  const right = node.lastChild;
  const opDef = _binaryScalarOperations__WEBPACK_IMPORTED_MODULE_1__.binaryScalarOperatorToOperatorName[op];
  const leftNumber = left.getChild('NumberLiteral');
  const rightNumber = right.getChild('NumberLiteral');
  const rightBinary = right.getChild('BinaryExpr');

  if (leftNumber) {// TODO: this should be already handled in case parent is binary expression as it has to be added to parent
    //  if query starts with a number that isn't handled now.
  } else {
    // If this is binary we don't really know if there is a query or just chained scalars. So
    // we have to traverse a bit deeper to know
    handleExpression(expr, left, context);
  }

  if (rightNumber) {
    visQuery.operations.push((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.makeBinOp)(opDef, expr, right, !!(binModifier !== null && binModifier !== void 0 && binModifier.isBool)));
  } else if (rightBinary) {
    // Due to the way binary ops are parsed we can get a binary operation on the right that starts with a number which
    // is a factor for a current binary operation. So we have to add it as an operation now.
    const leftMostChild = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getLeftMostChild)(right);

    if ((leftMostChild === null || leftMostChild === void 0 ? void 0 : leftMostChild.name) === 'NumberLiteral') {
      visQuery.operations.push((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.makeBinOp)(opDef, expr, leftMostChild, !!(binModifier !== null && binModifier !== void 0 && binModifier.isBool)));
    } // If we added the first number literal as operation here we still can continue and handle the rest as the first
    // number will be just skipped.


    handleExpression(expr, right, context);
  } else {
    visQuery.binaryQueries = visQuery.binaryQueries || [];
    const binQuery = {
      operator: op,
      query: {
        metric: '',
        labels: [],
        operations: []
      }
    };

    if (binModifier !== null && binModifier !== void 0 && binModifier.isMatcher) {
      binQuery.vectorMatchesType = binModifier.matchType;
      binQuery.vectorMatches = binModifier.matches;
    }

    visQuery.binaryQueries.push(binQuery);
    handleExpression(expr, right, {
      query: binQuery.query,
      errors: context.errors
    });
  }
}

function getBinaryModifier(expr, node) {
  if (!node) {
    return undefined;
  }

  if (node.getChild('Bool')) {
    return {
      isBool: true,
      isMatcher: false
    };
  } else {
    var _matcher$getChild;

    const matcher = node.getChild('OnOrIgnoring');

    if (!matcher) {
      // Not sure what this could be, maybe should be an error.
      return undefined;
    }

    const labels = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, (_matcher$getChild = matcher.getChild('GroupingLabels')) === null || _matcher$getChild === void 0 ? void 0 : _matcher$getChild.getChild('GroupingLabelList'));
    return {
      isMatcher: true,
      isBool: false,
      matches: labels,
      matchType: matcher.getChild('On') ? 'on' : 'ignoring'
    };
  }
}

function isEmptyQuery(query) {
  if (query.labels.length === 0 && query.operations.length === 0 && !query.metric) {
    return true;
  }

  return false;
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/AutoSizeInput.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AutoSizeInput": () => (/* binding */ AutoSizeInput)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
const _excluded = ["defaultValue", "minWidth", "maxWidth", "onCommitChange", "onKeyDown", "onBlur"];

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }




const AutoSizeInput = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref) => {
  const {
    defaultValue = '',
    minWidth = 10,
    maxWidth,
    onCommitChange,
    onKeyDown,
    onBlur
  } = props,
        restProps = _objectWithoutPropertiesLoose(props, _excluded);

  const [value, setValue] = react__WEBPACK_IMPORTED_MODULE_0__.useState(defaultValue);
  const [inputWidth, setInputWidth] = react__WEBPACK_IMPORTED_MODULE_0__.useState(minWidth);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    setInputWidth(getWidthFor(value.toString(), minWidth, maxWidth));
  }, [value, maxWidth, minWidth]);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Input, Object.assign({}, restProps, {
    ref: ref,
    value: value.toString(),
    onChange: event => {
      setValue(event.currentTarget.value);
    },
    width: inputWidth,
    onBlur: event => {
      if (onCommitChange) {
        onCommitChange(event);
      }

      if (onBlur) {
        onBlur(event);
      }
    },
    onKeyDown: event => {
      if (event.key === 'Enter' && onCommitChange) {
        onCommitChange(event);
      }

      if (onKeyDown) {
        onKeyDown(event);
      }
    },
    "data-testid": 'autosize-input'
  }));
});

function getWidthFor(value, minWidth, maxWidth) {
  if (!value) {
    return minWidth;
  }

  const extraSpace = 3;
  const realWidth = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.measureText)(value.toString(), 14).width / 8 + extraSpace;

  if (minWidth && realWidth < minWidth) {
    return minWidth;
  }

  if (maxWidth && realWidth > maxWidth) {
    return realWidth;
  }

  return realWidth;
}

AutoSizeInput.displayName = 'AutoSizeInput';

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/LabelFilterItem.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LabelFilterItem": () => (/* binding */ LabelFilterItem)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-22e4fdfd25/0/cache/@grafana-experimental-npm-0.0.2-canary.30-71a280d204-b5b453b937.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");






function LabelFilterItem({
  item,
  defaultOp,
  onChange,
  onDelete,
  onGetLabelNames,
  onGetLabelValues
}) {
  var _item$op2;

  const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});

  const isMultiSelect = () => {
    return item.op === operators[0].label;
  };

  const getSelectOptionsFromString = item => {
    if (item) {
      if (item.indexOf('|') > 0) {
        return item.split('|');
      }

      return [item];
    }

    return [];
  };

  const getOptions = () => {
    var _state$labelValues;

    return [...getSelectOptionsFromString(item === null || item === void 0 ? void 0 : item.value).map(_grafana_data__WEBPACK_IMPORTED_MODULE_1__.toOption), ...((_state$labelValues = state.labelValues) !== null && _state$labelValues !== void 0 ? _state$labelValues : [])];
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
    "data-testid": "prometheus-dimensions-filter-item",
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.InputGroup, {
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Select, {
        inputId: "prometheus-dimensions-filter-item-key",
        width: "auto",
        value: item.label ? (0,_grafana_data__WEBPACK_IMPORTED_MODULE_1__.toOption)(item.label) : null,
        allowCustomValue: true,
        onOpenMenu: async () => {
          setState({
            isLoadingLabelNames: true
          });
          const labelNames = await onGetLabelNames(item);
          setState({
            labelNames,
            isLoadingLabelNames: undefined
          });
        },
        isLoading: state.isLoadingLabelNames,
        options: state.labelNames,
        onChange: change => {
          if (change.label) {
            var _item$op;

            onChange(Object.assign({}, item, {
              op: (_item$op = item.op) !== null && _item$op !== void 0 ? _item$op : defaultOp,
              label: change.label
            }));
          }
        }
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Select, {
        value: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_1__.toOption)((_item$op2 = item.op) !== null && _item$op2 !== void 0 ? _item$op2 : defaultOp),
        options: operators,
        width: "auto",
        onChange: change => {
          if (change.value != null) {
            onChange(Object.assign({}, item, {
              op: change.value
            }));
          }
        }
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Select, {
        inputId: "prometheus-dimensions-filter-item-value",
        width: "auto",
        value: isMultiSelect() ? getSelectOptionsFromString(item === null || item === void 0 ? void 0 : item.value).map(_grafana_data__WEBPACK_IMPORTED_MODULE_1__.toOption) : getSelectOptionsFromString(item === null || item === void 0 ? void 0 : item.value).map(_grafana_data__WEBPACK_IMPORTED_MODULE_1__.toOption)[0],
        allowCustomValue: true,
        onOpenMenu: async () => {
          setState({
            isLoadingLabelValues: true
          });
          const labelValues = await onGetLabelValues(item);
          setState(Object.assign({}, state, {
            labelValues,
            isLoadingLabelValues: undefined
          }));
        },
        isMulti: isMultiSelect(),
        isLoading: state.isLoadingLabelValues,
        options: getOptions(),
        onChange: change => {
          if (change.value) {
            var _item$op3;

            onChange(Object.assign({}, item, {
              value: change.value,
              op: (_item$op3 = item.op) !== null && _item$op3 !== void 0 ? _item$op3 : defaultOp
            }));
          } else {
            var _item$op4;

            const changes = change.map(change => {
              return change.label;
            }).join('|');
            onChange(Object.assign({}, item, {
              value: changes,
              op: (_item$op4 = item.op) !== null && _item$op4 !== void 0 ? _item$op4 : defaultOp
            }));
          }
        }
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.AccessoryButton, {
        "aria-label": "remove",
        icon: "times",
        variant: "secondary",
        onClick: onDelete
      })]
    })
  });
}
const operators = [{
  label: '=~',
  value: '=~'
}, {
  label: '=',
  value: '='
}, {
  label: '!=',
  value: '!='
}, {
  label: '!~',
  value: '!~'
}];

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/LabelFilters.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LabelFilters": () => (/* binding */ LabelFilters)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-22e4fdfd25/0/cache/@grafana-experimental-npm-0.0.2-canary.30-71a280d204-b5b453b937.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _LabelFilterItem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/LabelFilterItem.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");





function LabelFilters({
  labelsFilters,
  onChange,
  onGetLabelNames,
  onGetLabelValues,
  error
}) {
  const defaultOp = '=';
  const [items, setItems] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([{
    op: defaultOp
  }]);
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
    if (labelsFilters.length > 0) {
      setItems(labelsFilters);
    } else {
      setItems([{
        op: defaultOp
      }]);
    }
  }, [labelsFilters]);

  const onLabelsChange = newItems => {
    setItems(newItems); // Extract full label filters with both label & value

    const newLabels = newItems.filter(x => x.label != null && x.value != null);

    if (!(0,lodash__WEBPACK_IMPORTED_MODULE_0__.isEqual)(newLabels, labelsFilters)) {
      onChange(newLabels);
    }
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.EditorFieldGroup, {
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.EditorField, {
      label: "Labels",
      error: error,
      invalid: !!error,
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.EditorList, {
        items: items,
        onChange: onLabelsChange,
        renderItem: (item, onChangeItem, onDelete) => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_LabelFilterItem__WEBPACK_IMPORTED_MODULE_3__.LabelFilterItem, {
          item: item,
          defaultOp: defaultOp,
          onChange: onChangeItem,
          onDelete: onDelete,
          onGetLabelNames: onGetLabelNames,
          onGetLabelValues: onGetLabelValues
        })
      })
    })
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/LokiAndPromQueryModellerBase.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiAndPromQueryModellerBase": () => (/* binding */ LokiAndPromQueryModellerBase)
/* harmony export */ });
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/types.ts");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



class LokiAndPromQueryModellerBase {
  constructor(getOperations) {
    _defineProperty(this, "operationsRegisty", void 0);

    _defineProperty(this, "categories", []);

    this.operationsRegisty = new _grafana_data__WEBPACK_IMPORTED_MODULE_0__.Registry(getOperations);
  }

  setOperationCategories(categories) {
    this.categories = categories;
  }

  getOperationsForCategory(category) {
    return this.operationsRegisty.list().filter(op => op.category === category && !op.hideFromList);
  }

  getAlternativeOperations(key) {
    return this.operationsRegisty.list().filter(op => op.alternativesKey === key);
  }

  getCategories() {
    return this.categories;
  }

  getOperationDef(id) {
    return this.operationsRegisty.getIfExists(id);
  }

  renderOperations(queryString, operations) {
    for (const operation of operations) {
      const def = this.operationsRegisty.getIfExists(operation.id);

      if (!def) {
        throw new Error(`Could not find operation ${operation.id} in the registry`);
      }

      queryString = def.renderer(operation, def, queryString);
    }

    return queryString;
  }

  renderBinaryQueries(queryString, binaryQueries) {
    if (binaryQueries) {
      for (const binQuery of binaryQueries) {
        queryString = `${this.renderBinaryQuery(queryString, binQuery)}`;
      }
    }

    return queryString;
  }

  renderBinaryQuery(leftOperand, binaryQuery) {
    let result = leftOperand + ` ${binaryQuery.operator} `;

    if (binaryQuery.vectorMatches) {
      result += `${binaryQuery.vectorMatchesType}(${binaryQuery.vectorMatches}) `;
    }

    return result + this.renderQuery(binaryQuery.query, true);
  }

  renderLabels(labels) {
    if (labels.length === 0) {
      return '';
    }

    let expr = '{';

    for (const filter of labels) {
      if (expr !== '{') {
        expr += ', ';
      }

      expr += `${filter.label}${filter.op}"${filter.value}"`;
    }

    return expr + `}`;
  }

  renderQuery(query, nested) {
    var _query$metric, _query$binaryQueries, _query$binaryQueries2;

    let queryString = `${(_query$metric = query.metric) !== null && _query$metric !== void 0 ? _query$metric : ''}${this.renderLabels(query.labels)}`;
    queryString = this.renderOperations(queryString, query.operations);

    if (!nested && this.hasBinaryOp(query) && Boolean((_query$binaryQueries = query.binaryQueries) === null || _query$binaryQueries === void 0 ? void 0 : _query$binaryQueries.length)) {
      queryString = `(${queryString})`;
    }

    queryString = this.renderBinaryQueries(queryString, query.binaryQueries);

    if (nested && (this.hasBinaryOp(query) || Boolean((_query$binaryQueries2 = query.binaryQueries) === null || _query$binaryQueries2 === void 0 ? void 0 : _query$binaryQueries2.length))) {
      queryString = `(${queryString})`;
    }

    return queryString;
  }

  hasBinaryOp(query) {
    return query.operations.find(op => {
      const def = this.getOperationDef(op.id);
      return (def === null || def === void 0 ? void 0 : def.category) === _types__WEBPACK_IMPORTED_MODULE_1__.PromVisualQueryOperationCategory.BinaryOps;
    }) !== undefined;
  }

}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationEditor": () => (/* binding */ OperationEditor)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./.yarn/__virtual__/react-beautiful-dnd-virtual-27e4b658e7/0/cache/react-beautiful-dnd-npm-13.1.0-fcf5568b1c-12b7e9fbe8.zip/node_modules/react-beautiful-dnd/dist/react-beautiful-dnd.esm.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-22e4fdfd25/0/cache/@grafana-experimental-npm-0.0.2-canary.30-71a280d204-b5b453b937.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _OperationHeader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationHeader.tsx");
/* harmony import */ var _OperationParamEditor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationParamEditor.tsx");
/* harmony import */ var _operationUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");










function OperationEditor({
  operation,
  index,
  onRemove,
  onChange,
  onRunQuery,
  queryModeller,
  query,
  datasource,
  highlight
}) {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.useStyles2)(getStyles);
  const def = queryModeller.getOperationDef(operation.id);
  const shouldHighlight = useHighlight(highlight);

  if (!def) {
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("span", {
      children: ["Operation ", operation.id, " not found"]
    });
  }

  const onParamValueChanged = (paramIdx, value) => {
    const update = Object.assign({}, operation, {
      params: [...operation.params]
    });
    update.params[paramIdx] = value;
    callParamChangedThenOnChange(def, update, index, paramIdx, onChange);
  };

  const onAddRestParam = () => {
    const update = Object.assign({}, operation, {
      params: [...operation.params, '']
    });
    callParamChangedThenOnChange(def, update, index, operation.params.length, onChange);
  };

  const onRemoveRestParam = paramIdx => {
    const update = Object.assign({}, operation, {
      params: [...operation.params.slice(0, paramIdx), ...operation.params.slice(paramIdx + 1)]
    });
    callParamChangedThenOnChange(def, update, index, paramIdx, onChange);
  };

  const operationElements = [];

  for (let paramIndex = 0; paramIndex < operation.params.length; paramIndex++) {
    const paramDef = def.params[Math.min(def.params.length - 1, paramIndex)];
    const Editor = (0,_OperationParamEditor__WEBPACK_IMPORTED_MODULE_5__.getOperationParamEditor)(paramDef);
    operationElements.push( /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
      className: styles.paramRow,
      children: [!paramDef.hideName && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
        className: styles.paramName,
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("label", {
          htmlFor: (0,_operationUtils__WEBPACK_IMPORTED_MODULE_6__.getOperationParamId)(index, paramIndex),
          children: paramDef.name
        }), paramDef.description && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Tooltip, {
          placement: "top",
          content: paramDef.description,
          theme: "info",
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Icon, {
            name: "info-circle",
            size: "sm",
            className: styles.infoIcon
          })
        })]
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
        className: styles.paramValue,
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.Stack, {
          gap: 0.5,
          direction: "row",
          alignItems: "center",
          wrap: false,
          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(Editor, {
            index: paramIndex,
            paramDef: paramDef,
            value: operation.params[paramIndex],
            operation: operation,
            operationIndex: index,
            onChange: onParamValueChanged,
            onRunQuery: onRunQuery,
            query: query,
            datasource: datasource
          }), paramDef.restParam && (operation.params.length > def.params.length || paramDef.optional) && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
            "data-testid": `operations.${index}.remove-rest-param`,
            size: "sm",
            fill: "text",
            icon: "times",
            variant: "secondary",
            title: `Remove ${paramDef.name}`,
            onClick: () => onRemoveRestParam(paramIndex)
          })]
        })
      })]
    }, `${paramIndex}-1`));
  } // Handle adding button for rest params


  let restParam;

  if (def.params.length > 0) {
    const lastParamDef = def.params[def.params.length - 1];

    if (lastParamDef.restParam) {
      restParam = renderAddRestParamButton(lastParamDef, onAddRestParam, index, operation.params.length, styles);
    }
  }

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_8__.Draggable, {
    draggableId: `operation-${index}`,
    index: index,
    children: provided => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", Object.assign({
      className: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.cx)(styles.card, shouldHighlight && styles.cardHighlight),
      ref: provided.innerRef
    }, provided.draggableProps, {
      "data-testid": `operations.${index}.wrapper`,
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_OperationHeader__WEBPACK_IMPORTED_MODULE_4__.OperationHeader, {
        operation: operation,
        dragHandleProps: provided.dragHandleProps,
        def: def,
        index: index,
        onChange: onChange,
        onRemove: onRemove,
        queryModeller: queryModeller
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
        className: styles.body,
        children: operationElements
      }), restParam, index < query.operations.length - 1 && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
        className: styles.arrow,
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
          className: styles.arrowLine
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
          className: styles.arrowArrow
        })]
      })]
    }))
  });
}
/**
 * When highlight is switched on makes sure it is switched of right away, so we just flash the highlight and then fade
 * out.
 * @param highlight
 */

function useHighlight(highlight) {
  const [keepHighlight, setKeepHighlight] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
    let t;

    if (highlight) {
      t = setTimeout(() => {
        setKeepHighlight(false);
      }, 1);
    } else {
      setKeepHighlight(true);
    }

    return () => clearTimeout(t);
  }, [highlight]);
  return keepHighlight && highlight;
}

function renderAddRestParamButton(paramDef, onAddRestParam, operationIndex, paramIndex, styles) {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
    className: styles.restParam,
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
      size: "sm",
      icon: "plus",
      title: `Add ${paramDef.name}`,
      variant: "secondary",
      onClick: onAddRestParam,
      "data-testid": `operations.${operationIndex}.add-rest-param`,
      children: paramDef.name
    })
  }, `${paramIndex}-2`);
}

function callParamChangedThenOnChange(def, operation, operationIndex, paramIndex, onChange) {
  if (def.paramChangedHandler) {
    onChange(operationIndex, def.paramChangedHandler(paramIndex, operation, def));
  } else {
    onChange(operationIndex, operation);
  }
}

const getStyles = theme => {
  return {
    card: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      background: theme.colors.background.primary,
      border: `1px solid ${theme.colors.border.medium}`,
      display: 'flex',
      flexDirection: 'column',
      cursor: 'grab',
      borderRadius: theme.shape.borderRadius(1),
      marginBottom: theme.spacing(1),
      position: 'relative',
      transition: 'all 1s ease-in 0s'
    }),
    cardHighlight: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      boxShadow: `0px 0px 4px 0px ${theme.colors.primary.border}`,
      border: `1px solid ${theme.colors.primary.border}`
    }),
    infoIcon: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      marginLeft: theme.spacing(0.5),
      color: theme.colors.text.secondary,
      ':hover': {
        color: theme.colors.text.primary
      }
    }),
    body: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      margin: theme.spacing(1, 1, 0.5, 1),
      display: 'table'
    }),
    paramRow: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'paramRow',
      display: 'table-row',
      verticalAlign: 'middle'
    }),
    paramName: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      display: 'table-cell',
      padding: theme.spacing(0, 1, 0, 0),
      fontSize: theme.typography.bodySmall.fontSize,
      fontWeight: theme.typography.fontWeightMedium,
      verticalAlign: 'middle',
      height: '32px'
    }),
    paramValue: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'paramValue',
      display: 'table-cell',
      verticalAlign: 'middle'
    }),
    restParam: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      padding: theme.spacing(0, 1, 1, 1)
    }),
    arrow: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      position: 'absolute',
      top: '0',
      right: '-18px',
      display: 'flex'
    }),
    arrowLine: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      height: '2px',
      width: '8px',
      backgroundColor: theme.colors.border.strong,
      position: 'relative',
      top: '14px'
    }),
    arrowArrow: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      width: 0,
      height: 0,
      borderTop: `5px solid transparent`,
      borderBottom: `5px solid transparent`,
      borderLeft: `7px solid ${theme.colors.border.strong}`,
      position: 'relative',
      top: '10px'
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationExplainedBox.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationExplainedBox": () => (/* binding */ OperationExplainedBox)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");






function OperationExplainedBox({
  title,
  stepNumber,
  markdown,
  children
}) {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.useStyles2)(getStyles);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
    className: styles.box,
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
      className: styles.stepNumber,
      children: stepNumber
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
      className: styles.boxInner,
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
        className: styles.header,
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("span", {
          children: title
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
        className: styles.body,
        children: [markdown && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
          dangerouslySetInnerHTML: {
            __html: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_2__.renderMarkdown)(markdown)
          }
        }), children]
      })]
    })]
  });
}

const getStyles = theme => {
  return {
    box: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      background: theme.colors.background.secondary,
      padding: theme.spacing(1),
      borderRadius: theme.shape.borderRadius(),
      position: 'relative',
      marginBottom: theme.spacing(0.5)
    }),
    boxInner: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      marginLeft: theme.spacing(4)
    }),
    stepNumber: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      fontWeight: theme.typography.fontWeightMedium,
      background: theme.colors.secondary.main,
      width: '20px',
      height: '20px',
      borderRadius: '50%',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      position: 'absolute',
      top: '10px',
      left: '11px',
      fontSize: theme.typography.bodySmall.fontSize
    }),
    header: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      paddingBottom: theme.spacing(0.5),
      display: 'flex',
      alignItems: 'center',
      fontFamily: theme.typography.fontFamilyMonospace
    }),
    body: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      color: theme.colors.text.secondary,
      'p:last-child': {
        margin: 0
      },
      a: {
        color: theme.colors.text.link,
        textDecoration: 'underline'
      }
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationHeader.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationHeader": () => (/* binding */ OperationHeader)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-22e4fdfd25/0/cache/@grafana-experimental-npm-0.0.2-canary.30-71a280d204-b5b453b937.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _OperationInfoButton__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationInfoButton.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _FlexItem;









const OperationHeader = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.memo(({
  operation,
  def,
  index,
  onChange,
  onRemove,
  queryModeller,
  dragHandleProps
}) => {
  var _def$name;

  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.useStyles2)(getStyles);
  const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});

  const onToggleSwitcher = () => {
    if (state.isOpen) {
      setState(Object.assign({}, state, {
        isOpen: false
      }));
    } else {
      const alternatives = queryModeller.getAlternativeOperations(def.alternativesKey).map(alt => ({
        label: alt.name,
        value: alt
      }));
      setState({
        isOpen: true,
        alternatives
      });
    }
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
    className: styles.header,
    children: [!state.isOpen && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", Object.assign({}, dragHandleProps, {
        children: (_def$name = def.name) !== null && _def$name !== void 0 ? _def$name : def.id
      })), _FlexItem || (_FlexItem = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.FlexItem, {
        grow: 1
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
        className: `${styles.operationHeaderButtons} operation-header-show-on-hover`,
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
          icon: "angle-down",
          size: "sm",
          onClick: onToggleSwitcher,
          fill: "text",
          variant: "secondary",
          title: "Click to view alternative operations"
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_OperationInfoButton__WEBPACK_IMPORTED_MODULE_4__.OperationInfoButton, {
          def: def,
          operation: operation
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
          icon: "times",
          size: "sm",
          onClick: () => onRemove(index),
          fill: "text",
          variant: "secondary",
          title: "Remove operation"
        })]
      })]
    }), state.isOpen && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
      className: styles.selectWrapper,
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Select, {
        autoFocus: true,
        openMenuOnFocus: true,
        placeholder: "Replace with",
        options: state.alternatives,
        isOpen: true,
        onCloseMenu: onToggleSwitcher,
        onChange: value => {
          if (value.value) {
            // Operation should exist if it is selectable
            const newDef = queryModeller.getOperationDef(value.value.id);
            let changedOp = Object.assign({}, operation, {
              id: value.value.id
            });
            onChange(index, def.changeTypeHandler ? def.changeTypeHandler(changedOp, newDef) : changedOp);
          }
        }
      })
    })]
  });
});
OperationHeader.displayName = 'OperationHeader';

const getStyles = theme => {
  return {
    header: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      borderBottom: `1px solid ${theme.colors.border.medium}`,
      padding: theme.spacing(0.5, 0.5, 0.5, 1),
      display: 'flex',
      alignItems: 'center',
      '&:hover .operation-header-show-on-hover': (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
        opacity: 1
      })
    }),
    operationHeaderButtons: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      opacity: 0,
      transition: theme.transitions.create(['opacity'], {
        duration: theme.transitions.duration.short
      })
    }),
    selectWrapper: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      paddingRight: theme.spacing(2)
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationInfoButton.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationInfoButton": () => (/* binding */ OperationInfoButton)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_popper_tooltip__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/__virtual__/react-popper-tooltip-virtual-d9d7047333/0/cache/react-popper-tooltip-npm-4.3.1-91318ee546-82ae84c3b7.zip/node_modules/react-popper-tooltip/dist/esm/react-popper-tooltip.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-22e4fdfd25/0/cache/@grafana-experimental-npm-0.0.2-canary.30-71a280d204-b5b453b937.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _FlexItem;










const OperationInfoButton = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.memo(({
  def,
  operation
}) => {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.useStyles2)(getStyles);
  const [show, setShow] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);
  const {
    getTooltipProps,
    setTooltipRef,
    setTriggerRef,
    visible
  } = (0,react_popper_tooltip__WEBPACK_IMPORTED_MODULE_6__.usePopperTooltip)({
    placement: 'top',
    visible: show,
    offset: [0, 16],
    onVisibleChange: setShow,
    interactive: true,
    trigger: ['click']
  });
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Button, {
      title: "Click to show description",
      ref: setTriggerRef,
      icon: "info-circle",
      size: "sm",
      variant: "secondary",
      fill: "text"
    }), visible && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Portal, {
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", Object.assign({
        ref: setTooltipRef
      }, getTooltipProps(), {
        className: styles.docBox,
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
          className: styles.docBoxHeader,
          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("span", {
            children: def.renderer(operation, def, '<expr>')
          }), _FlexItem || (_FlexItem = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_3__.FlexItem, {
            grow: 1
          })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Button, {
            icon: "times",
            onClick: () => setShow(false),
            fill: "text",
            variant: "secondary",
            title: "Remove operation"
          })]
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
          className: styles.docBoxBody,
          dangerouslySetInnerHTML: {
            __html: getOperationDocs(def, operation)
          }
        })]
      }))
    })]
  });
});
OperationInfoButton.displayName = 'OperationDocs';

const getStyles = theme => {
  return {
    docBox: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      overflow: 'hidden',
      background: theme.colors.background.primary,
      border: `1px solid ${theme.colors.border.strong}`,
      boxShadow: theme.shadows.z3,
      maxWidth: '600px',
      padding: theme.spacing(1),
      borderRadius: theme.shape.borderRadius(),
      zIndex: theme.zIndex.tooltip
    }),
    docBoxHeader: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      fontSize: theme.typography.h5.fontSize,
      fontFamily: theme.typography.fontFamilyMonospace,
      paddingBottom: theme.spacing(1),
      display: 'flex',
      alignItems: 'center'
    }),
    docBoxBody: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      // The markdown paragraph has a marginBottom this removes it
      marginBottom: theme.spacing(-1),
      color: theme.colors.text.secondary
    }),
    signature: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      fontSize: theme.typography.bodySmall.fontSize,
      fontFamily: theme.typography.fontFamilyMonospace
    }),
    dropdown: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      opacity: 0,
      color: theme.colors.text.secondary
    })
  };
};

function getOperationDocs(def, op) {
  var _def$documentation;

  return (0,_grafana_data__WEBPACK_IMPORTED_MODULE_2__.renderMarkdown)(def.explainHandler ? def.explainHandler(op, def) : (_def$documentation = def.documentation) !== null && _def$documentation !== void 0 ? _def$documentation : 'no docs');
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationList.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationList": () => (/* binding */ OperationList)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/__virtual__/react-beautiful-dnd-virtual-27e4b658e7/0/cache/react-beautiful-dnd-npm-13.1.0-fcf5568b1c-12b7e9fbe8.zip/node_modules/react-beautiful-dnd/dist/react-beautiful-dnd.esm.js");
/* harmony import */ var react_use__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/__virtual__/react-use-virtual-00326e70ba/0/cache/react-use-npm-17.3.2-a032cbeb01-7379460f51.zip/node_modules/react-use/esm/useMountedState.js");
/* harmony import */ var react_use__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./.yarn/__virtual__/react-use-virtual-00326e70ba/0/cache/react-use-npm-17.3.2-a032cbeb01-7379460f51.zip/node_modules/react-use/esm/usePrevious.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-22e4fdfd25/0/cache/@grafana-experimental-npm-0.0.2-canary.30-71a280d204-b5b453b937.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _OperationEditor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationEditor.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");









function OperationList({
  query,
  datasource,
  queryModeller,
  onChange,
  onRunQuery
}) {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.useStyles2)(getStyles);
  const {
    operations
  } = query;
  const opsToHighlight = useOperationsHighlight(operations);
  const [cascaderOpen, setCascaderOpen] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);

  const onOperationChange = (index, update) => {
    const updatedList = [...operations];
    updatedList.splice(index, 1, update);
    onChange(Object.assign({}, query, {
      operations: updatedList
    }));
  };

  const onRemove = index => {
    const updatedList = [...operations.slice(0, index), ...operations.slice(index + 1)];
    onChange(Object.assign({}, query, {
      operations: updatedList
    }));
  };

  const addOptions = queryModeller.getCategories().map(category => {
    return {
      value: category,
      label: category,
      items: queryModeller.getOperationsForCategory(category).map(operation => ({
        value: operation.id,
        label: operation.name,
        isLeaf: true
      }))
    };
  });

  const onAddOperation = value => {
    const operationDef = queryModeller.getOperationDef(value);

    if (!operationDef) {
      return;
    }

    onChange(operationDef.addOperationHandler(operationDef, query, queryModeller));
    setCascaderOpen(false);
  };

  const onDragEnd = result => {
    if (!result.destination) {
      return;
    }

    const updatedList = [...operations];
    const element = updatedList[result.source.index];
    updatedList.splice(result.source.index, 1);
    updatedList.splice(result.destination.index, 0, element);
    onChange(Object.assign({}, query, {
      operations: updatedList
    }));
  };

  const onCascaderBlur = () => {
    setCascaderOpen(false);
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.Stack, {
    gap: 1,
    direction: "column",
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.Stack, {
      gap: 1,
      children: [operations.length > 0 && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_6__.DragDropContext, {
        onDragEnd: onDragEnd,
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_6__.Droppable, {
          droppableId: "sortable-field-mappings",
          direction: "horizontal",
          children: provided => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", Object.assign({
            className: styles.operationList,
            ref: provided.innerRef
          }, provided.droppableProps, {
            children: [operations.map((op, index) => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_OperationEditor__WEBPACK_IMPORTED_MODULE_4__.OperationEditor, {
              queryModeller: queryModeller,
              index: index,
              operation: op,
              query: query,
              datasource: datasource,
              onChange: onOperationChange,
              onRemove: onRemove,
              onRunQuery: onRunQuery,
              highlight: opsToHighlight[index]
            }, op.id + index)), provided.placeholder]
          }))
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
        className: styles.addButton,
        children: cascaderOpen ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Cascader, {
          options: addOptions,
          onSelect: onAddOperation,
          onBlur: onCascaderBlur,
          autoFocus: true,
          alwaysOpen: true,
          hideActiveLevelLabel: true,
          placeholder: 'Search'
        }) : /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
          icon: 'plus',
          variant: 'secondary',
          onClick: () => setCascaderOpen(true),
          title: 'Add operation',
          children: "Operations"
        })
      })]
    })
  });
}
/**
 * Returns indexes of operations that should be highlighted. We check the diff of operations added but at the same time
 * we want to highlight operations only after the initial render, so we check for mounted state and calculate the diff
 * only after.
 * @param operations
 */

function useOperationsHighlight(operations) {
  const isMounted = (0,react_use__WEBPACK_IMPORTED_MODULE_7__["default"])();
  const prevOperations = (0,react_use__WEBPACK_IMPORTED_MODULE_8__["default"])(operations);

  if (!isMounted()) {
    return operations.map(() => false);
  }

  if (!prevOperations) {
    return operations.map(() => true);
  }

  let newOps = [];

  if (prevOperations.length - 1 === operations.length && operations.every(op => prevOperations.includes(op))) {
    // In case we remove one op and does not change any ops then don't highlight anything.
    return operations.map(() => false);
  }

  if (prevOperations.length + 1 === operations.length && prevOperations.every(op => operations.includes(op))) {
    // If we add a single op just find it and highlight just that.
    const newOp = operations.find(op => !prevOperations.includes(op));
    newOps = operations.map(op => {
      return op === newOp;
    });
  } else {
    // Default diff of all ops.
    newOps = operations.map((op, index) => {
      var _prevOperations$index;

      return !isSameOp(op.id, (_prevOperations$index = prevOperations[index]) === null || _prevOperations$index === void 0 ? void 0 : _prevOperations$index.id);
    });
  }

  return newOps;
}

function isSameOp(op1, op2) {
  return op1 === op2 || `__${op1}_by` === op2 || op1 === `__${op2}_by`;
}

const getStyles = theme => {
  return {
    heading: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'heading',
      fontSize: 12,
      fontWeight: theme.typography.fontWeightMedium,
      marginBottom: 0
    }),
    operationList: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'operationList',
      display: 'flex',
      flexWrap: 'wrap',
      gap: theme.spacing(2)
    }),
    addButton: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'addButton',
      width: 126,
      paddingBottom: theme.spacing(1)
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationListExplained.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationListExplained": () => (/* binding */ OperationListExplained)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _OperationExplainedBox__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationExplainedBox.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");




function OperationListExplained({
  query,
  queryModeller,
  stepNumber
}) {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, {
    children: query.operations.map((op, index) => {
      var _def$documentation;

      const def = queryModeller.getOperationDef(op.id);

      if (!def) {
        return `Operation ${op.id} not found`;
      }

      const title = def.renderer(op, def, '<expr>');
      const body = def.explainHandler ? def.explainHandler(op, def) : (_def$documentation = def.documentation) !== null && _def$documentation !== void 0 ? _def$documentation : 'no docs';
      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_OperationExplainedBox__WEBPACK_IMPORTED_MODULE_1__.OperationExplainedBox, {
        stepNumber: index + stepNumber,
        title: title,
        markdown: body
      }, index);
    })
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationParamEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getOperationParamEditor": () => (/* binding */ getOperationParamEditor)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _AutoSizeInput__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/AutoSizeInput.tsx");
/* harmony import */ var _operationUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");






function getOperationParamEditor(paramDef) {
  if (paramDef.editor) {
    return paramDef.editor;
  }

  if (paramDef.options) {
    return SelectInputParamEditor;
  }

  switch (paramDef.type) {
    case 'boolean':
      return BoolInputParamEditor;

    case 'number':
    case 'string':
    default:
      return SimpleInputParamEditor;
  }
}

function SimpleInputParamEditor(props) {
  var _props$value;

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_AutoSizeInput__WEBPACK_IMPORTED_MODULE_3__.AutoSizeInput, {
    id: (0,_operationUtils__WEBPACK_IMPORTED_MODULE_4__.getOperationParamId)(props.operationIndex, props.index),
    defaultValue: (_props$value = props.value) === null || _props$value === void 0 ? void 0 : _props$value.toString(),
    minWidth: props.paramDef.minWidth,
    placeholder: props.paramDef.placeholder,
    title: props.paramDef.description,
    onCommitChange: evt => {
      props.onChange(props.index, evt.currentTarget.value);
    }
  });
}

function BoolInputParamEditor(props) {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Checkbox, {
    id: (0,_operationUtils__WEBPACK_IMPORTED_MODULE_4__.getOperationParamId)(props.operationIndex, props.index),
    value: props.value,
    onChange: evt => props.onChange(props.index, evt.currentTarget.checked)
  });
}

function SelectInputParamEditor({
  paramDef,
  value,
  index,
  operationIndex,
  onChange
}) {
  var _selectOptions$, _selectOptions$find;

  let selectOptions = paramDef.options;

  if (!((_selectOptions$ = selectOptions[0]) !== null && _selectOptions$ !== void 0 && _selectOptions$.label)) {
    selectOptions = paramDef.options.map(option => ({
      label: option.toString(),
      value: option
    }));
  }

  let valueOption = (_selectOptions$find = selectOptions.find(x => x.value === value)) !== null && _selectOptions$find !== void 0 ? _selectOptions$find : (0,_grafana_data__WEBPACK_IMPORTED_MODULE_1__.toOption)(value);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Select, {
    id: (0,_operationUtils__WEBPACK_IMPORTED_MODULE_4__.getOperationParamId)(operationIndex, index),
    value: valueOption,
    options: selectOptions,
    placeholder: paramDef.placeholder,
    allowCustomValue: true,
    onChange: value => onChange(index, value.value)
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationsEditorRow.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationsEditorRow": () => (/* binding */ OperationsEditorRow)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-22e4fdfd25/0/cache/@grafana-experimental-npm-0.0.2-canary.30-71a280d204-b5b453b937.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");





function OperationsEditorRow({
  children
}) {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.useStyles2)(getStyles);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
    className: styles.root,
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.Stack, {
      gap: 1,
      children: children
    })
  });
}

const getStyles = theme => {
  return {
    root: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      padding: theme.spacing(1, 1, 0, 1),
      backgroundColor: theme.colors.background.secondary,
      borderRadius: theme.shape.borderRadius(1)
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/QueryEditorModeToggle.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "QueryEditorModeToggle": () => (/* binding */ QueryEditorModeToggle)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/types.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");





const editorModes = [{
  label: 'Explain',
  value: _types__WEBPACK_IMPORTED_MODULE_3__.QueryEditorMode.Explain
}, {
  label: 'Builder',
  value: _types__WEBPACK_IMPORTED_MODULE_3__.QueryEditorMode.Builder,
  component: () => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Tag, {
    className: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      fontSize: 10,
      padding: '1px 5px',
      verticalAlign: 'text-bottom'
    }),
    name: 'Beta',
    colorIndex: 1
  })
}, {
  label: 'Code',
  value: _types__WEBPACK_IMPORTED_MODULE_3__.QueryEditorMode.Code
}];
function QueryEditorModeToggle({
  mode,
  onChange
}) {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
    "data-testid": 'QueryEditorModeToggle',
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.RadioButtonGroup, {
      options: editorModes,
      size: "sm",
      value: mode,
      onChange: onChange
    })
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/QueryHeaderSwitch.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "QueryHeaderSwitch": () => (/* binding */ QueryHeaderSwitch)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-22e4fdfd25/0/cache/@grafana-experimental-npm-0.0.2-canary.30-71a280d204-b5b453b937.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
const _excluded = ["label"];

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








function QueryHeaderSwitch(_ref) {
  let {
    label
  } = _ref,
      inputProps = _objectWithoutPropertiesLoose(_ref, _excluded);

  const dashedLabel = label.replace(' ', '-');
  const switchIdRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)((0,lodash__WEBPACK_IMPORTED_MODULE_1__.uniqueId)(`switch-${dashedLabel}`));
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.useStyles2)(getStyles);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_3__.Stack, {
    gap: 1,
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("label", {
      htmlFor: switchIdRef.current,
      className: styles.switchLabel,
      children: label
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Switch, Object.assign({}, inputProps, {
      id: switchIdRef.current
    }))]
  });
}

const getStyles = theme => {
  return {
    switchLabel: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      color: theme.colors.text.secondary,
      cursor: 'pointer',
      fontSize: theme.typography.bodySmall.fontSize,
      '&:hover': {
        color: theme.colors.text.primary
      }
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/QueryOptionGroup.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "QueryOptionGroup": () => (/* binding */ QueryOptionGroup)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_use__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/__virtual__/react-use-virtual-00326e70ba/0/cache/react-use-npm-17.3.2-a032cbeb01-7379460f51.zip/node_modules/react-use/esm/useToggle.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-22e4fdfd25/0/cache/@grafana-experimental-npm-0.0.2-canary.30-71a280d204-b5b453b937.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");







function QueryOptionGroup({
  title,
  children,
  collapsedInfo
}) {
  const [isOpen, toggleOpen] = (0,react_use__WEBPACK_IMPORTED_MODULE_5__["default"])(false);
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.useStyles2)(getStyles);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.Stack, {
    gap: 0,
    direction: "column",
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
      className: styles.header,
      onClick: toggleOpen,
      title: "Click to edit options",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
        className: styles.toggle,
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Icon, {
          name: isOpen ? 'angle-down' : 'angle-right'
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("h6", {
        className: styles.title,
        children: title
      }), !isOpen && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
        className: styles.description,
        children: collapsedInfo.map((x, i) => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("span", {
          children: x
        }, i))
      })]
    }), isOpen && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
      className: styles.body,
      children: children
    })]
  });
}

const getStyles = theme => {
  return {
    switchLabel: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      color: theme.colors.text.secondary,
      cursor: 'pointer',
      fontSize: theme.typography.bodySmall.fontSize,
      '&:hover': {
        color: theme.colors.text.primary
      }
    }),
    header: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      display: 'flex',
      cursor: 'pointer',
      alignItems: 'baseline',
      color: theme.colors.text.primary,
      '&:hover': {
        background: theme.colors.emphasize(theme.colors.background.primary, 0.03)
      }
    }),
    title: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      flexGrow: 1,
      overflow: 'hidden',
      fontSize: theme.typography.bodySmall.fontSize,
      fontWeight: theme.typography.fontWeightMedium,
      margin: 0
    }),
    description: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      color: theme.colors.text.secondary,
      fontSize: theme.typography.bodySmall.fontSize,
      paddingLeft: theme.spacing(2),
      gap: theme.spacing(2),
      display: 'flex'
    }),
    body: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      display: 'flex',
      paddingTop: theme.spacing(2),
      gap: theme.spacing(2),
      flexWrap: 'wrap'
    }),
    toggle: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      color: theme.colors.text.secondary,
      marginRight: `${theme.spacing(1)}`
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createAggregationOperation": () => (/* binding */ createAggregationOperation),
/* harmony export */   "createAggregationOperationWithParam": () => (/* binding */ createAggregationOperationWithParam),
/* harmony export */   "defaultAddOperationHandler": () => (/* binding */ defaultAddOperationHandler),
/* harmony export */   "functionRendererLeft": () => (/* binding */ functionRendererLeft),
/* harmony export */   "functionRendererRight": () => (/* binding */ functionRendererRight),
/* harmony export */   "getOperationParamId": () => (/* binding */ getOperationParamId),
/* harmony export */   "getPromAndLokiOperationDisplayName": () => (/* binding */ getPromAndLokiOperationDisplayName),
/* harmony export */   "getRangeVectorParamDef": () => (/* binding */ getRangeVectorParamDef),
/* harmony export */   "rangeRendererLeftWithParams": () => (/* binding */ rangeRendererLeftWithParams),
/* harmony export */   "rangeRendererRightWithParams": () => (/* binding */ rangeRendererRightWithParams)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var pluralize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/pluralize-npm-8.0.0-f5f044ed52-08931d4a6a.zip/node_modules/pluralize/pluralize.js");
/* harmony import */ var pluralize__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(pluralize__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _components_LabelParamEditor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/LabelParamEditor.tsx");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/types.ts");




function functionRendererLeft(model, def, innerExpr) {
  const params = renderParams(model, def, innerExpr);
  const str = model.id + '(';

  if (innerExpr) {
    params.push(innerExpr);
  }

  return str + params.join(', ') + ')';
}
function functionRendererRight(model, def, innerExpr) {
  const params = renderParams(model, def, innerExpr);
  const str = model.id + '(';

  if (innerExpr) {
    params.unshift(innerExpr);
  }

  return str + params.join(', ') + ')';
}

function rangeRendererWithParams(model, def, innerExpr, renderLeft) {
  var _, _model$params;

  if (def.params.length < 2) {
    throw `Cannot render a function with params of length [${def.params.length}]`;
  }

  let rangeVector = (_ = ((_model$params = model.params) !== null && _model$params !== void 0 ? _model$params : [])[0]) !== null && _ !== void 0 ? _ : '5m'; // Next frame the remaining parameters, but get rid of the first one because it's used to move the
  // instant vector into a range vector.

  const params = renderParams(Object.assign({}, model, {
    params: model.params.slice(1)
  }), Object.assign({}, def, {
    params: def.params.slice(1),
    defaultParams: def.defaultParams.slice(1)
  }), innerExpr);
  const str = model.id + '('; // Depending on the renderLeft variable, render parameters to the left or right
  // renderLeft === true (renderLeft) => (param1, param2, rangeVector[...])
  // renderLeft === false (renderRight) => (rangeVector[...], param1, param2)

  if (innerExpr) {
    renderLeft ? params.push(`${innerExpr}[${rangeVector}]`) : params.unshift(`${innerExpr}[${rangeVector}]`);
  } // stick everything together


  return str + params.join(', ') + ')';
}

function rangeRendererRightWithParams(model, def, innerExpr) {
  return rangeRendererWithParams(model, def, innerExpr, false);
}
function rangeRendererLeftWithParams(model, def, innerExpr) {
  return rangeRendererWithParams(model, def, innerExpr, true);
}

function renderParams(model, def, innerExpr) {
  var _model$params2;

  return ((_model$params2 = model.params) !== null && _model$params2 !== void 0 ? _model$params2 : []).map((value, index) => {
    const paramDef = def.params[index];

    if (paramDef.type === 'string') {
      return '"' + value + '"';
    }

    return value;
  });
}

function defaultAddOperationHandler(def, query) {
  const newOperation = {
    id: def.id,
    params: def.defaultParams
  };
  return Object.assign({}, query, {
    operations: [...query.operations, newOperation]
  });
}
function getPromAndLokiOperationDisplayName(funcName) {
  return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.capitalize)(funcName.replace(/_/g, ' '));
}
function getOperationParamId(operationIndex, paramIndex) {
  return `operations.${operationIndex}.param.${paramIndex}`;
}
function getRangeVectorParamDef(withRateInterval = false) {
  const param = {
    name: 'Range',
    type: 'string',
    options: [{
      label: '$__interval',
      value: '$__interval' // tooltip: 'Dynamic interval based on max data points, scrape and min interval',

    }, {
      label: '1m',
      value: '1m'
    }, {
      label: '5m',
      value: '5m'
    }, {
      label: '10m',
      value: '10m'
    }, {
      label: '1h',
      value: '1h'
    }, {
      label: '24h',
      value: '24h'
    }]
  };

  if (withRateInterval) {
    param.options.unshift({
      label: '$__rate_interval',
      value: '$__rate_interval' // tooltip: 'Always above 4x scrape interval',

    });
  }

  return param;
}
/**
 * This function is shared between Prometheus and Loki variants
 */

function createAggregationOperation(name, overrides = {}) {
  const operations = [Object.assign({
    id: name,
    name: getPromAndLokiOperationDisplayName(name),
    params: [{
      name: 'By label',
      type: 'string',
      restParam: true,
      optional: true
    }],
    defaultParams: [],
    alternativesKey: 'plain aggregations',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Aggregations,
    renderer: functionRendererLeft,
    paramChangedHandler: getOnLabelAddedHandler(`__${name}_by`),
    explainHandler: getAggregationExplainer(name, ''),
    addOperationHandler: defaultAddOperationHandler
  }, overrides), Object.assign({
    id: `__${name}_by`,
    name: `${getPromAndLokiOperationDisplayName(name)} by`,
    params: [{
      name: 'Label',
      type: 'string',
      restParam: true,
      optional: true,
      editor: _components_LabelParamEditor__WEBPACK_IMPORTED_MODULE_2__.LabelParamEditor
    }],
    defaultParams: [''],
    alternativesKey: 'aggregations by',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Aggregations,
    renderer: getAggregationByRenderer(name),
    paramChangedHandler: getLastLabelRemovedHandler(name),
    explainHandler: getAggregationExplainer(name, 'by'),
    addOperationHandler: defaultAddOperationHandler,
    hideFromList: true
  }, overrides), Object.assign({
    id: `__${name}_without`,
    name: `${getPromAndLokiOperationDisplayName(name)} without`,
    params: [{
      name: 'Label',
      type: 'string',
      restParam: true,
      optional: true,
      editor: _components_LabelParamEditor__WEBPACK_IMPORTED_MODULE_2__.LabelParamEditor
    }],
    defaultParams: [''],
    alternativesKey: 'aggregations by',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.PromVisualQueryOperationCategory.Aggregations,
    renderer: getAggregationWithoutRenderer(name),
    paramChangedHandler: getLastLabelRemovedHandler(name),
    explainHandler: getAggregationExplainer(name, 'without'),
    addOperationHandler: defaultAddOperationHandler,
    hideFromList: true
  }, overrides)];
  return operations;
}
function createAggregationOperationWithParam(name, paramsDef, overrides = {}) {
  const operations = createAggregationOperation(name, overrides);
  operations[0].params.unshift(...paramsDef.params);
  operations[1].params.unshift(...paramsDef.params);
  operations[2].params.unshift(...paramsDef.params);
  operations[0].defaultParams = paramsDef.defaultParams;
  operations[1].defaultParams = [...paramsDef.defaultParams, ''];
  operations[2].defaultParams = [...paramsDef.defaultParams, ''];
  operations[1].renderer = getAggregationByRendererWithParameter(name);
  operations[2].renderer = getAggregationByRendererWithParameter(name);
  return operations;
}

function getAggregationByRenderer(aggregation) {
  return function aggregationRenderer(model, def, innerExpr) {
    return `${aggregation} by(${model.params.join(', ')}) (${innerExpr})`;
  };
}

function getAggregationWithoutRenderer(aggregation) {
  return function aggregationRenderer(model, def, innerExpr) {
    return `${aggregation} without(${model.params.join(', ')}) (${innerExpr})`;
  };
}
/**
 * Very simple poc implementation, needs to be modified to support all aggregation operators
 */


function getAggregationExplainer(aggregationName, mode) {
  return function aggregationExplainer(model) {
    const labels = model.params.map(label => `\`${label}\``).join(' and ');
    const labelWord = pluralize__WEBPACK_IMPORTED_MODULE_1___default()('label', model.params.length);

    switch (mode) {
      case 'by':
        return `Calculates ${aggregationName} over dimensions while preserving ${labelWord} ${labels}.`;

      case 'without':
        return `Calculates ${aggregationName} over the dimensions ${labels}. All other labels are preserved.`;

      default:
        return `Calculates ${aggregationName} over the dimensions.`;
    }
  };
}

function getAggregationByRendererWithParameter(aggregation) {
  return function aggregationRenderer(model, def, innerExpr) {
    function mapType(p) {
      if (typeof p === 'string') {
        return `\"${p}\"`;
      }

      return p;
    }

    const params = model.params.slice(0, -1);
    const restParams = model.params.slice(1);
    return `${aggregation} by(${restParams.join(', ')}) (${params.map(mapType).join(', ')}, ${innerExpr})`;
  };
}
/**
 * This function will transform operations without labels to their plan aggregation operation
 */


function getLastLabelRemovedHandler(changeToOperationId) {
  return function onParamChanged(index, op, def) {
    // If definition has more params then is defined there are no optional rest params anymore.
    // We then transform this operation into a different one
    if (op.params.length < def.params.length) {
      return Object.assign({}, op, {
        id: changeToOperationId
      });
    }

    return op;
  };
}

function getOnLabelAddedHandler(changeToOperationId) {
  return function onParamChanged(index, op, def) {
    // Check if we actually have the label param. As it's optional the aggregation can have one less, which is the
    // case of just simple aggregation without label. When user adds the label it now has the same number of params
    // as it's definition, and now we can change it to it's `_by` variant.
    if (op.params.length === def.params.length) {
      return Object.assign({}, op, {
        id: changeToOperationId
      });
    }

    return op;
  };
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/parsingUtils.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ErrorName": () => (/* binding */ ErrorName),
/* harmony export */   "getAllByType": () => (/* binding */ getAllByType),
/* harmony export */   "getLeftMostChild": () => (/* binding */ getLeftMostChild),
/* harmony export */   "getString": () => (/* binding */ getString),
/* harmony export */   "log": () => (/* binding */ log),
/* harmony export */   "makeBinOp": () => (/* binding */ makeBinOp),
/* harmony export */   "makeError": () => (/* binding */ makeError),
/* harmony export */   "replaceVariables": () => (/* binding */ replaceVariables)
/* harmony export */ });
// This is used for error type for some reason
const ErrorName = '⚠';
function getLeftMostChild(cur) {
  return cur.firstChild ? getLeftMostChild(cur.firstChild) : cur;
}
function makeError(expr, node) {
  var _node$parent;

  return {
    text: getString(expr, node),
    // TODO: this are positions in the string with the replaced variables. Means it cannot be used to show exact
    //  placement of the error for the user. We need some translation table to positions before the variable
    //  replace.
    from: node.from,
    to: node.to,
    parentType: (_node$parent = node.parent) === null || _node$parent === void 0 ? void 0 : _node$parent.name
  };
} // Taken from template_srv, but copied so to not mess with the regex.index which is manipulated in the service

/*
 * This regex matches 3 types of variable reference with an optional format specifier
 * \$(\w+)                          $var1
 * \[\[([\s\S]+?)(?::(\w+))?\]\]    [[var2]] or [[var2:fmt2]]
 * \${(\w+)(?::(\w+))?}             ${var3} or ${var3:fmt3}
 */

const variableRegex = /\$(\w+)|\[\[([\s\S]+?)(?::(\w+))?\]\]|\${(\w+)(?:\.([^:^\}]+))?(?::([^\}]+))?}/g;
/**
 * As variables with $ are creating parsing errors, we first replace them with magic string that is parsable and at
 * the same time we can get the variable and it's format back from it.
 * @param expr
 */

function replaceVariables(expr) {
  return expr.replace(variableRegex, (match, var1, var2, fmt2, var3, fieldPath, fmt3) => {
    const fmt = fmt2 || fmt3;
    let variable = var1;
    let varType = '0';

    if (var2) {
      variable = var2;
      varType = '1';
    }

    if (var3) {
      variable = var3;
      varType = '2';
    }

    return `__V_${varType}__` + variable + '__V__' + (fmt ? '__F__' + fmt + '__F__' : '');
  });
}
const varTypeFunc = [(v, f) => `\$${v}`, (v, f) => `[[${v}${f ? `:${f}` : ''}]]`, (v, f) => `\$\{${v}${f ? `:${f}` : ''}\}`];
/**
 * Get back the text with variables in their original format.
 * @param expr
 */

function returnVariables(expr) {
  return expr.replace(/__V_(\d)__(.+?)__V__(?:__F__(\w+)__F__)?/g, (match, type, v, f) => {
    return varTypeFunc[parseInt(type, 10)](v, f);
  });
}
/**
 * Get the actual string of the expression. That is not stored in the tree so we have to get the indexes from the node
 * and then based on that get it from the expression.
 * @param expr
 * @param node
 */


function getString(expr, node) {
  if (!node) {
    return '';
  }

  return returnVariables(expr.substring(node.from, node.to));
}
/**
 * Create simple scalar binary op object.
 * @param opDef - definition of the op to be created
 * @param expr
 * @param numberNode - the node for the scalar
 * @param hasBool - whether operation has a bool modifier. Is used only for ops for which it makes sense.
 */

function makeBinOp(opDef, expr, numberNode, hasBool) {
  const params = [parseFloat(getString(expr, numberNode))];

  if (opDef.comparison) {
    params.push(hasBool);
  }

  return {
    id: opDef.id,
    params
  };
}
/**
 * Get all nodes with type in the tree. This traverses the tree so it is safe only when you know there shouldn't be
 * too much nesting but you just want to skip some of the wrappers. For example getting function args this way would
 * not be safe is it would also find arguments of nested functions.
 * @param expr
 * @param cur
 * @param type
 */

function getAllByType(expr, cur, type) {
  if (cur.name === type) {
    return [getString(expr, cur)];
  }

  const values = [];
  let pos = 0;
  let child = cur.childAfter(pos);

  while (child) {
    values.push(...getAllByType(expr, child, type));
    pos = child.to;
    child = cur.childAfter(pos);
  }

  return values;
} // Debugging function for convenience. Gives you nice output similar to linux tree util.
// @ts-ignore

function log(expr, cur) {
  if (!cur) {
    console.log('<empty>');
    return;
  }

  const json = toJson(expr, cur);
  const text = jsonToText(json);

  if (!text) {
    console.log('<empty>');
    return;
  }

  console.log(text);
}

function toJson(expr, cur) {
  const treeJson = {};
  const name = nodeToString(expr, cur);
  const children = [];
  let pos = 0;
  let child = cur.childAfter(pos);

  while (child) {
    children.push(toJson(expr, child));
    pos = child.to;
    child = cur.childAfter(pos);
  }

  treeJson.name = name;
  treeJson.children = children;
  return treeJson;
}

function jsonToText(node, context = {
  lastChild: true,
  indent: ''
}) {
  const name = node.name;
  const {
    lastChild,
    indent
  } = context;
  const newIndent = indent !== '' ? indent + (lastChild ? '└─' : '├─') : '';
  let text = newIndent + name;
  const children = node.children;
  children.forEach((child, index) => {
    const isLastChild = index === children.length - 1;
    text += '\n' + jsonToText(child, {
      lastChild: isLastChild,
      indent: indent + (lastChild ? '  ' : '│ ')
    });
  });
  return text;
}

function nodeToString(expr, node) {
  return node.name + ': ' + getString(expr, node);
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/types.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "QueryEditorMode": () => (/* binding */ QueryEditorMode)
/* harmony export */ });
/**
 * Shared types that can be reused by Loki and other data sources
 */
let QueryEditorMode;

(function (QueryEditorMode) {
  QueryEditorMode["Code"] = "code";
  QueryEditorMode["Builder"] = "builder";
  QueryEditorMode["Explain"] = "explain";
})(QueryEditorMode || (QueryEditorMode = {}));

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/types.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromOperationId": () => (/* binding */ PromOperationId),
/* harmony export */   "PromVisualQueryOperationCategory": () => (/* binding */ PromVisualQueryOperationCategory)
/* harmony export */ });
/**
 * Visual query model
 */
let PromVisualQueryOperationCategory;

(function (PromVisualQueryOperationCategory) {
  PromVisualQueryOperationCategory["Aggregations"] = "Aggregations";
  PromVisualQueryOperationCategory["RangeFunctions"] = "Range functions";
  PromVisualQueryOperationCategory["Functions"] = "Functions";
  PromVisualQueryOperationCategory["BinaryOps"] = "Binary operations";
  PromVisualQueryOperationCategory["Trigonometric"] = "Trigonometric";
  PromVisualQueryOperationCategory["Time"] = "Time Functions";
})(PromVisualQueryOperationCategory || (PromVisualQueryOperationCategory = {}));

let PromOperationId;

(function (PromOperationId) {
  PromOperationId["Abs"] = "abs";
  PromOperationId["Absent"] = "absent";
  PromOperationId["AbsentOverTime"] = "absent_over_time";
  PromOperationId["Acos"] = "acos";
  PromOperationId["Acosh"] = "acosh";
  PromOperationId["Asin"] = "asin";
  PromOperationId["Asinh"] = "asinh";
  PromOperationId["Atan"] = "atan";
  PromOperationId["Atanh"] = "atanh";
  PromOperationId["Avg"] = "avg";
  PromOperationId["AvgOverTime"] = "avg_over_time";
  PromOperationId["BottomK"] = "bottomk";
  PromOperationId["Ceil"] = "ceil";
  PromOperationId["Changes"] = "changes";
  PromOperationId["Clamp"] = "clamp";
  PromOperationId["ClampMax"] = "clamp_max";
  PromOperationId["ClampMin"] = "clamp_min";
  PromOperationId["Cos"] = "cos";
  PromOperationId["Cosh"] = "cosh";
  PromOperationId["Count"] = "count";
  PromOperationId["CountOverTime"] = "count_over_time";
  PromOperationId["CountScalar"] = "count_scalar";
  PromOperationId["CountValues"] = "count_values";
  PromOperationId["DayOfMonth"] = "day_of_month";
  PromOperationId["DayOfWeek"] = "day_of_week";
  PromOperationId["DaysInMonth"] = "days_in_month";
  PromOperationId["Deg"] = "deg";
  PromOperationId["Delta"] = "delta";
  PromOperationId["Deriv"] = "deriv";
  PromOperationId["DropCommonLabels"] = "drop_common_labels";
  PromOperationId["Exp"] = "exp";
  PromOperationId["Floor"] = "floor";
  PromOperationId["Group"] = "group";
  PromOperationId["HistogramQuantile"] = "histogram_quantile";
  PromOperationId["HoltWinters"] = "holt_winters";
  PromOperationId["Hour"] = "hour";
  PromOperationId["Idelta"] = "idelta";
  PromOperationId["Increase"] = "increase";
  PromOperationId["Irate"] = "irate";
  PromOperationId["LabelJoin"] = "label_join";
  PromOperationId["LabelReplace"] = "label_replace";
  PromOperationId["Last"] = "last";
  PromOperationId["LastOverTime"] = "last_over_time";
  PromOperationId["Ln"] = "ln";
  PromOperationId["Log10"] = "log10";
  PromOperationId["Log2"] = "log2";
  PromOperationId["Max"] = "max";
  PromOperationId["MaxOverTime"] = "max_over_time";
  PromOperationId["Min"] = "min";
  PromOperationId["MinOverTime"] = "min_over_time";
  PromOperationId["Minute"] = "minute";
  PromOperationId["Month"] = "month";
  PromOperationId["Pi"] = "pi";
  PromOperationId["PredictLinear"] = "predict_linear";
  PromOperationId["Present"] = "present";
  PromOperationId["PresentOverTime"] = "present_over_time";
  PromOperationId["Quantile"] = "quantile";
  PromOperationId["QuantileOverTime"] = "quantile_over_time";
  PromOperationId["Rad"] = "rad";
  PromOperationId["Rate"] = "rate";
  PromOperationId["Resets"] = "resets";
  PromOperationId["Round"] = "round";
  PromOperationId["Scalar"] = "scalar";
  PromOperationId["Sgn"] = "sgn";
  PromOperationId["Sin"] = "sin";
  PromOperationId["Sinh"] = "sinh";
  PromOperationId["Sort"] = "sort";
  PromOperationId["SortDesc"] = "sort_desc";
  PromOperationId["Sqrt"] = "sqrt";
  PromOperationId["Stddev"] = "stddev";
  PromOperationId["StddevOverTime"] = "stddev_over_time";
  PromOperationId["Sum"] = "sum";
  PromOperationId["SumOverTime"] = "sum_over_time";
  PromOperationId["Tan"] = "tan";
  PromOperationId["Tanh"] = "tanh";
  PromOperationId["Time"] = "time";
  PromOperationId["Timestamp"] = "timestamp";
  PromOperationId["TopK"] = "topk";
  PromOperationId["Vector"] = "vector";
  PromOperationId["Year"] = "year";
  PromOperationId["Addition"] = "__addition";
  PromOperationId["Subtraction"] = "__subtraction";
  PromOperationId["MultiplyBy"] = "__multiply_by";
  PromOperationId["DivideBy"] = "__divide_by";
  PromOperationId["Modulo"] = "__modulo";
  PromOperationId["Exponent"] = "__exponent";
  PromOperationId["NestedQuery"] = "__nested_query";
  PromOperationId["EqualTo"] = "__equal_to";
  PromOperationId["NotEqualTo"] = "__not_equal_to";
  PromOperationId["GreaterThan"] = "__greater_than";
  PromOperationId["LessThan"] = "__less_than";
  PromOperationId["GreaterOrEqual"] = "__greater_or_equal";
  PromOperationId["LessOrEqual"] = "__less_or_equal";
})(PromOperationId || (PromOperationId = {}));

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/result_transformer.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getOriginalMetricName": () => (/* binding */ getOriginalMetricName),
/* harmony export */   "parseSampleValue": () => (/* binding */ parseSampleValue),
/* harmony export */   "transform": () => (/* binding */ transform),
/* harmony export */   "transformDFToTable": () => (/* binding */ transformDFToTable),
/* harmony export */   "transformV2": () => (/* binding */ transformV2)
/* harmony export */ });
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/d3-npm-5.15.0-0c7696026f-7342d82e55.zip/node_modules/d3/index.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/legend.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/types.ts");
const _excluded = ["__name__"];

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }






 // handles case-insensitive Inf, +Inf, -Inf (with optional "inity" suffix)

const INFINITY_SAMPLE_REGEX = /^[+-]?inf(?:inity)?$/i;

const isTableResult = (dataFrame, options) => {
  var _dataFrame$meta, _dataFrame$meta$custo, _dataFrame$meta2, _dataFrame$meta2$cust;

  // We want to process vector and scalar results in Explore as table
  if (options.app === _grafana_data__WEBPACK_IMPORTED_MODULE_2__.CoreApp.Explore && (((_dataFrame$meta = dataFrame.meta) === null || _dataFrame$meta === void 0 ? void 0 : (_dataFrame$meta$custo = _dataFrame$meta.custom) === null || _dataFrame$meta$custo === void 0 ? void 0 : _dataFrame$meta$custo.resultType) === 'vector' || ((_dataFrame$meta2 = dataFrame.meta) === null || _dataFrame$meta2 === void 0 ? void 0 : (_dataFrame$meta2$cust = _dataFrame$meta2.custom) === null || _dataFrame$meta2$cust === void 0 ? void 0 : _dataFrame$meta2$cust.resultType) === 'scalar')) {
    return true;
  } // We want to process all dataFrames with target.format === 'table' as table


  const target = options.targets.find(target => target.refId === dataFrame.refId);
  return (target === null || target === void 0 ? void 0 : target.format) === 'table';
};

const isHeatmapResult = (dataFrame, options) => {
  const target = options.targets.find(target => target.refId === dataFrame.refId);
  return (target === null || target === void 0 ? void 0 : target.format) === 'heatmap';
}; // V2 result trasnformer used to transform query results from queries that were run trough prometheus backend


function transformV2(response, request, options) {
  const [tableFrames, framesWithoutTable] = (0,lodash__WEBPACK_IMPORTED_MODULE_1__.partition)(response.data, df => isTableResult(df, request));
  const processedTableFrames = transformDFToTable(tableFrames);
  const [exemplarFrames, framesWithoutTableAndExemplars] = (0,lodash__WEBPACK_IMPORTED_MODULE_1__.partition)(framesWithoutTable, df => {
    var _df$meta, _df$meta$custom;

    return ((_df$meta = df.meta) === null || _df$meta === void 0 ? void 0 : (_df$meta$custom = _df$meta.custom) === null || _df$meta$custom === void 0 ? void 0 : _df$meta$custom.resultType) === 'exemplar';
  }); // EXEMPLAR FRAMES: We enrich exemplar frames with data links and add dataTopic meta info

  const {
    exemplarTraceIdDestinations: destinations
  } = options;
  const processedExemplarFrames = exemplarFrames.map(dataFrame => {
    if (destinations !== null && destinations !== void 0 && destinations.length) {
      for (const exemplarTraceIdDestination of destinations) {
        const traceIDField = dataFrame.fields.find(field => field.name === exemplarTraceIdDestination.name);

        if (traceIDField) {
          var _traceIDField$config$;

          const links = getDataLinks(exemplarTraceIdDestination);
          traceIDField.config.links = (_traceIDField$config$ = traceIDField.config.links) !== null && _traceIDField$config$ !== void 0 && _traceIDField$config$.length ? [...traceIDField.config.links, ...links] : links;
        }
      }
    }

    return Object.assign({}, dataFrame, {
      meta: Object.assign({}, dataFrame.meta, {
        dataTopic: _grafana_data__WEBPACK_IMPORTED_MODULE_2__.DataTopic.Annotations
      })
    });
  });
  const [heatmapResults, framesWithoutTableHeatmapsAndExemplars] = (0,lodash__WEBPACK_IMPORTED_MODULE_1__.partition)(framesWithoutTableAndExemplars, df => isHeatmapResult(df, request));
  const processedHeatmapFrames = mergeHeatmapFrames(transformToHistogramOverTime(heatmapResults.sort(sortSeriesByLabel))); // Everything else is processed as time_series result and graph preferredVisualisationType

  const otherFrames = framesWithoutTableHeatmapsAndExemplars.map(dataFrame => {
    const df = Object.assign({}, dataFrame, {
      meta: Object.assign({}, dataFrame.meta, {
        preferredVisualisationType: 'graph'
      })
    });
    return df;
  });
  return Object.assign({}, response, {
    data: [...otherFrames, ...processedTableFrames, ...processedHeatmapFrames, ...processedExemplarFrames]
  });
}
function transformDFToTable(dfs) {
  // If no dataFrames or if 1 dataFrames with no values, return original dataFrame
  if (dfs.length === 0 || dfs.length === 1 && dfs[0].length === 0) {
    return dfs;
  } // Group results by refId and process dataFrames with the same refId as 1 dataFrame


  const dataFramesByRefId = (0,lodash__WEBPACK_IMPORTED_MODULE_1__.groupBy)(dfs, 'refId');
  const refIds = Object.keys(dataFramesByRefId);
  const frames = refIds.map(refId => {
    // Create timeField, valueField and labelFields
    const valueText = getValueText(refIds.length, refId);
    const valueField = getValueField({
      data: [],
      valueName: valueText
    });
    const timeField = getTimeField([]);
    const labelFields = []; // Fill labelsFields with labels from dataFrames

    dataFramesByRefId[refId].forEach(df => {
      var _frameValueField$labe;

      const frameValueField = df.fields[1];
      const promLabels = (_frameValueField$labe = frameValueField.labels) !== null && _frameValueField$labe !== void 0 ? _frameValueField$labe : {};
      Object.keys(promLabels).sort().forEach(label => {
        // If we don't have label in labelFields, add it
        if (!labelFields.some(l => l.name === label)) {
          const numberField = label === 'le';
          labelFields.push({
            name: label,
            config: {
              filterable: true
            },
            type: numberField ? _grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldType.number : _grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldType.string,
            values: new _grafana_data__WEBPACK_IMPORTED_MODULE_2__.ArrayVector()
          });
        }
      });
    }); // Fill valueField, timeField and labelFields with values

    dataFramesByRefId[refId].forEach(df => {
      df.fields[0].values.toArray().forEach(value => timeField.values.add(value));
      df.fields[1].values.toArray().forEach(value => {
        var _df$fields$1$labels;

        valueField.values.add(parseSampleValue(value));
        const labelsForField = (_df$fields$1$labels = df.fields[1].labels) !== null && _df$fields$1$labels !== void 0 ? _df$fields$1$labels : {};
        labelFields.forEach(field => field.values.add(getLabelValue(labelsForField, field.name)));
      });
    });
    const fields = [timeField, ...labelFields, valueField];
    return {
      refId,
      fields,
      meta: Object.assign({}, dfs[0].meta, {
        preferredVisualisationType: 'table'
      }),
      length: timeField.values.length
    };
  });
  return frames;
}

function getValueText(responseLength, refId = '') {
  return responseLength > 1 ? `Value #${refId}` : 'Value';
}

function transform(response, transformOptions) {
  // Create options object from transformOptions
  const options = {
    format: transformOptions.target.format,
    step: transformOptions.query.step,
    legendFormat: transformOptions.target.legendFormat,
    start: transformOptions.query.start,
    end: transformOptions.query.end,
    query: transformOptions.query.expr,
    responseListLength: transformOptions.responseListLength,
    scopedVars: transformOptions.scopedVars,
    refId: transformOptions.target.refId,
    valueWithRefId: transformOptions.target.valueWithRefId,
    meta: {
      // Fix for showing of Prometheus results in Explore table
      preferredVisualisationType: transformOptions.query.instant ? 'table' : 'graph'
    }
  };
  const prometheusResult = response.data.data;

  if ((0,_types__WEBPACK_IMPORTED_MODULE_5__.isExemplarData)(prometheusResult)) {
    var _transformOptions$exe;

    const events = [];
    prometheusResult.forEach(exemplarData => {
      const data = exemplarData.exemplars.map(exemplar => {
        return Object.assign({
          [_grafana_data__WEBPACK_IMPORTED_MODULE_2__.TIME_SERIES_TIME_FIELD_NAME]: exemplar.timestamp * 1000,
          [_grafana_data__WEBPACK_IMPORTED_MODULE_2__.TIME_SERIES_VALUE_FIELD_NAME]: exemplar.value
        }, exemplar.labels, exemplarData.seriesLabels);
      });
      events.push(...data);
    }); // Grouping exemplars by step

    const sampledExemplars = sampleExemplars(events, options);
    const dataFrame = new _grafana_data__WEBPACK_IMPORTED_MODULE_2__.ArrayDataFrame(sampledExemplars);
    dataFrame.meta = {
      dataTopic: _grafana_data__WEBPACK_IMPORTED_MODULE_2__.DataTopic.Annotations
    }; // Add data links if configured

    if ((_transformOptions$exe = transformOptions.exemplarTraceIdDestinations) !== null && _transformOptions$exe !== void 0 && _transformOptions$exe.length) {
      for (const exemplarTraceIdDestination of transformOptions.exemplarTraceIdDestinations) {
        const traceIDField = dataFrame.fields.find(field => field.name === exemplarTraceIdDestination.name);

        if (traceIDField) {
          var _traceIDField$config$2;

          const links = getDataLinks(exemplarTraceIdDestination);
          traceIDField.config.links = (_traceIDField$config$2 = traceIDField.config.links) !== null && _traceIDField$config$2 !== void 0 && _traceIDField$config$2.length ? [...traceIDField.config.links, ...links] : links;
        }
      }
    }

    return [dataFrame];
  }

  if (!(prometheusResult !== null && prometheusResult !== void 0 && prometheusResult.result)) {
    return [];
  } // Return early if result type is scalar


  if (prometheusResult.resultType === 'scalar') {
    return [{
      meta: options.meta,
      refId: options.refId,
      length: 1,
      fields: [getTimeField([prometheusResult.result]), getValueField({
        data: [prometheusResult.result]
      })]
    }];
  } // Return early again if the format is table, this needs special transformation.


  if (options.format === 'table') {
    const tableData = transformMetricDataToTable(prometheusResult.result, options);
    return [tableData];
  } // Process matrix and vector results to DataFrame


  const dataFrame = [];
  prometheusResult.result.forEach(data => dataFrame.push(transformToDataFrame(data, options))); // When format is heatmap use the already created data frames and transform it more

  if (options.format === 'heatmap') {
    return mergeHeatmapFrames(transformToHistogramOverTime(dataFrame.sort(sortSeriesByLabel)));
  } // Return matrix or vector result as DataFrame[]


  return dataFrame;
}

function getDataLinks(options) {
  const dataLinks = [];

  if (options.datasourceUid) {
    var _dsSettings$name;

    const dataSourceSrv = (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_3__.getDataSourceSrv)();
    const dsSettings = dataSourceSrv.getInstanceSettings(options.datasourceUid);
    dataLinks.push({
      title: options.urlDisplayLabel || `Query with ${dsSettings === null || dsSettings === void 0 ? void 0 : dsSettings.name}`,
      url: '',
      internal: {
        query: {
          query: '${__value.raw}',
          queryType: 'traceId'
        },
        datasourceUid: options.datasourceUid,
        datasourceName: (_dsSettings$name = dsSettings === null || dsSettings === void 0 ? void 0 : dsSettings.name) !== null && _dsSettings$name !== void 0 ? _dsSettings$name : 'Data source not found'
      }
    });
  }

  if (options.url) {
    dataLinks.push({
      title: options.urlDisplayLabel || `Go to ${options.url}`,
      url: options.url,
      targetBlank: true
    });
  }

  return dataLinks;
}
/**
 * Reduce the density of the exemplars by making sure that the highest value exemplar is included
 * and then only the ones that are 2 times the standard deviation of the all the values.
 * This makes sure not to show too many dots near each other.
 */


function sampleExemplars(events, options) {
  const step = options.step || 15;
  const bucketedExemplars = {};
  const values = [];

  for (const exemplar of events) {
    // Align exemplar timestamp to nearest step second
    const alignedTs = String(Math.floor(exemplar[_grafana_data__WEBPACK_IMPORTED_MODULE_2__.TIME_SERIES_TIME_FIELD_NAME] / 1000 / step) * step * 1000);

    if (!bucketedExemplars[alignedTs]) {
      // New bucket found
      bucketedExemplars[alignedTs] = [];
    }

    bucketedExemplars[alignedTs].push(exemplar);
    values.push(exemplar[_grafana_data__WEBPACK_IMPORTED_MODULE_2__.TIME_SERIES_VALUE_FIELD_NAME]);
  } // Getting exemplars from each bucket


  const standardDeviation = (0,d3__WEBPACK_IMPORTED_MODULE_0__.deviation)(values);
  const sampledBuckets = Object.keys(bucketedExemplars).sort();
  const sampledExemplars = [];

  for (const ts of sampledBuckets) {
    const exemplarsInBucket = bucketedExemplars[ts];

    if (exemplarsInBucket.length === 1) {
      sampledExemplars.push(exemplarsInBucket[0]);
    } else {
      // Choose which values to sample
      const bucketValues = exemplarsInBucket.map(ex => ex[_grafana_data__WEBPACK_IMPORTED_MODULE_2__.TIME_SERIES_VALUE_FIELD_NAME]).sort(d3__WEBPACK_IMPORTED_MODULE_0__.descending);
      const sampledBucketValues = bucketValues.reduce((acc, curr) => {
        if (acc.length === 0) {
          // First value is max and is always added
          acc.push(curr);
        } else {
          // Then take values only when at least 2 standard deviation distance to previously taken value
          const prev = acc[acc.length - 1];

          if (standardDeviation && prev - curr >= 2 * standardDeviation) {
            acc.push(curr);
          }
        }

        return acc;
      }, []); // Find the exemplars for the sampled values

      sampledExemplars.push(...sampledBucketValues.map(value => exemplarsInBucket.find(ex => ex[_grafana_data__WEBPACK_IMPORTED_MODULE_2__.TIME_SERIES_VALUE_FIELD_NAME] === value)));
    }
  }

  return sampledExemplars;
}
/**
 * Transforms matrix and vector result from Prometheus result to DataFrame
 */


function transformToDataFrame(data, options) {
  const {
    name,
    labels
  } = createLabelInfo(data.metric, options);
  const fields = [];

  if ((0,_types__WEBPACK_IMPORTED_MODULE_5__.isMatrixData)(data)) {
    const stepMs = options.step ? options.step * 1000 : NaN;
    let baseTimestamp = options.start * 1000;
    const dps = [];

    for (const value of data.values) {
      let dpValue = parseSampleValue(value[1]);

      if (isNaN(dpValue)) {
        dpValue = null;
      }

      const timestamp = value[0] * 1000;

      for (let t = baseTimestamp; t < timestamp; t += stepMs) {
        dps.push([t, null]);
      }

      baseTimestamp = timestamp + stepMs;
      dps.push([timestamp, dpValue]);
    }

    const endTimestamp = options.end * 1000;

    for (let t = baseTimestamp; t <= endTimestamp; t += stepMs) {
      dps.push([t, null]);
    }

    fields.push(getTimeField(dps, true));
    fields.push(getValueField({
      data: dps,
      parseValue: false,
      labels,
      displayNameFromDS: name
    }));
  } else {
    fields.push(getTimeField([data.value]));
    fields.push(getValueField({
      data: [data.value],
      labels,
      displayNameFromDS: name
    }));
  }

  return {
    meta: options.meta,
    refId: options.refId,
    length: fields[0].values.length,
    fields,
    name
  };
}

function transformMetricDataToTable(md, options) {
  if (!md || md.length === 0) {
    return {
      meta: options.meta,
      refId: options.refId,
      length: 0,
      fields: []
    };
  }

  const valueText = options.responseListLength > 1 || options.valueWithRefId ? `Value #${options.refId}` : 'Value';
  const timeField = getTimeField([]);
  const metricFields = Object.keys(md.reduce((acc, series) => Object.assign({}, acc, series.metric), {})).sort().map(label => {
    // Labels have string field type, otherwise table tries to figure out the type which can result in unexpected results
    // Only "le" label has a number field type
    const numberField = label === 'le';
    return {
      name: label,
      config: {
        filterable: true
      },
      type: numberField ? _grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldType.number : _grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldType.string,
      values: new _grafana_data__WEBPACK_IMPORTED_MODULE_2__.ArrayVector()
    };
  });
  const valueField = getValueField({
    data: [],
    valueName: valueText
  });
  md.forEach(d => {
    if ((0,_types__WEBPACK_IMPORTED_MODULE_5__.isMatrixData)(d)) {
      d.values.forEach(val => {
        timeField.values.add(val[0] * 1000);
        metricFields.forEach(metricField => metricField.values.add(getLabelValue(d.metric, metricField.name)));
        valueField.values.add(parseSampleValue(val[1]));
      });
    } else {
      timeField.values.add(d.value[0] * 1000);
      metricFields.forEach(metricField => metricField.values.add(getLabelValue(d.metric, metricField.name)));
      valueField.values.add(parseSampleValue(d.value[1]));
    }
  });
  return {
    meta: options.meta,
    refId: options.refId,
    length: timeField.values.length,
    fields: [timeField, ...metricFields, valueField]
  };
}

function getLabelValue(metric, label) {
  if (metric.hasOwnProperty(label)) {
    if (label === 'le') {
      return parseSampleValue(metric[label]);
    }

    return metric[label];
  }

  return '';
}

function getTimeField(data, isMs = false) {
  return {
    name: _grafana_data__WEBPACK_IMPORTED_MODULE_2__.TIME_SERIES_TIME_FIELD_NAME,
    type: _grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldType.time,
    config: {},
    values: new _grafana_data__WEBPACK_IMPORTED_MODULE_2__.ArrayVector(data.map(val => isMs ? val[0] : val[0] * 1000))
  };
}

function getValueField({
  data,
  valueName = _grafana_data__WEBPACK_IMPORTED_MODULE_2__.TIME_SERIES_VALUE_FIELD_NAME,
  parseValue = true,
  labels,
  displayNameFromDS
}) {
  return {
    name: valueName,
    type: _grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldType.number,
    display: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_2__.getDisplayProcessor)(),
    config: {
      displayNameFromDS
    },
    labels,
    values: new _grafana_data__WEBPACK_IMPORTED_MODULE_2__.ArrayVector(data.map(val => parseValue ? parseSampleValue(val[1]) : val[1]))
  };
}

function createLabelInfo(labels, options) {
  if (options !== null && options !== void 0 && options.legendFormat) {
    const title = (0,_legend__WEBPACK_IMPORTED_MODULE_4__.renderLegendFormat)((0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_3__.getTemplateSrv)().replace(options.legendFormat, options === null || options === void 0 ? void 0 : options.scopedVars), labels);
    return {
      name: title,
      labels
    };
  }

  const {
    __name__
  } = labels,
        labelsWithoutName = _objectWithoutPropertiesLoose(labels, _excluded);

  const labelPart = (0,_grafana_data__WEBPACK_IMPORTED_MODULE_2__.formatLabels)(labelsWithoutName);
  let title = `${__name__ !== null && __name__ !== void 0 ? __name__ : ''}${labelPart}`;

  if (!title) {
    title = options.query;
  }

  return {
    name: title,
    labels: labelsWithoutName
  };
}

function getOriginalMetricName(labelData) {
  const metricName = labelData.__name__ || '';
  delete labelData.__name__;
  const labelPart = Object.entries(labelData).map(label => `${label[0]}="${label[1]}"`).join(',');
  return `${metricName}{${labelPart}}`;
}

function mergeHeatmapFrames(frames) {
  if (frames.length === 0) {
    return [];
  }

  const timeField = frames[0].fields.find(field => field.type === _grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldType.time);
  const countFields = frames.map(frame => {
    let field = frame.fields.find(field => field.type === _grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldType.number);
    return Object.assign({}, field, {
      name: field.config.displayNameFromDS
    });
  });
  return [Object.assign({}, frames[0], {
    meta: Object.assign({}, frames[0].meta, {
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_2__.DataFrameType.HeatmapBuckets
    }),
    fields: [timeField, ...countFields]
  })];
}

function transformToHistogramOverTime(seriesList) {
  /*      t1 = timestamp1, t2 = timestamp2 etc.
            t1  t2  t3          t1  t2  t3
    le10    10  10  0     =>    10  10  0
    le20    20  10  30    =>    10  0   30
    le30    30  10  35    =>    10  0   5
    */
  for (let i = seriesList.length - 1; i > 0; i--) {
    const topSeries = seriesList[i].fields.find(s => s.name === _grafana_data__WEBPACK_IMPORTED_MODULE_2__.TIME_SERIES_VALUE_FIELD_NAME);
    const bottomSeries = seriesList[i - 1].fields.find(s => s.name === _grafana_data__WEBPACK_IMPORTED_MODULE_2__.TIME_SERIES_VALUE_FIELD_NAME);

    if (!topSeries || !bottomSeries) {
      throw new Error('Prometheus heatmap transform error: data should be a time series');
    }

    for (let j = 0; j < topSeries.values.length; j++) {
      const bottomPoint = bottomSeries.values.get(j) || [0];
      topSeries.values.toArray()[j] -= bottomPoint;
    }
  }

  return seriesList;
}

function sortSeriesByLabel(s1, s2) {
  let le1, le2;

  try {
    var _s1$name, _s2$name;

    // fail if not integer. might happen with bad queries
    le1 = parseSampleValue((_s1$name = s1.name) !== null && _s1$name !== void 0 ? _s1$name : '');
    le2 = parseSampleValue((_s2$name = s2.name) !== null && _s2$name !== void 0 ? _s2$name : '');
  } catch (err) {
    console.error(err);
    return 0;
  }

  if (le1 > le2) {
    return 1;
  }

  if (le1 < le2) {
    return -1;
  }

  return 0;
}
/** @internal */


function parseSampleValue(value) {
  if (INFINITY_SAMPLE_REGEX.test(value)) {
    return value[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
  }

  return parseFloat(value);
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/types.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LegendFormatMode": () => (/* binding */ LegendFormatMode),
/* harmony export */   "PromQueryType": () => (/* binding */ PromQueryType),
/* harmony export */   "isExemplarData": () => (/* binding */ isExemplarData),
/* harmony export */   "isMatrixData": () => (/* binding */ isMatrixData)
/* harmony export */ });
let PromQueryType;

(function (PromQueryType) {
  PromQueryType["timeSeriesQuery"] = "timeSeriesQuery";
})(PromQueryType || (PromQueryType = {}));

function isMatrixData(result) {
  return 'values' in result;
}
function isExemplarData(result) {
  if (result == null || !Array.isArray(result)) {
    return false;
  }

  return result.length ? 'exemplars' in result[0] : false;
}

/**
 * Auto = query.legendFormat == '__auto'
 * Verbose = query.legendFormat == null/undefined/''
 * Custom query.legendFormat.length > 0 && query.legendFormat !== '__auto'
 */
let LegendFormatMode;

(function (LegendFormatMode) {
  LegendFormatMode["Auto"] = "__auto";
  LegendFormatMode["Verbose"] = "__verbose";
  LegendFormatMode["Custom"] = "__custom";
})(LegendFormatMode || (LegendFormatMode = {}));

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/variables.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PrometheusVariableSupport": () => (/* binding */ PrometheusVariableSupport)
/* harmony export */ });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/of.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/from.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/map.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _features_dashboard_services_TimeSrv__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/dashboard/services/TimeSrv.ts");
/* harmony import */ var _metric_find_query__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/metric_find_query.ts");






class PrometheusVariableSupport extends _grafana_data__WEBPACK_IMPORTED_MODULE_0__.StandardVariableSupport {
  constructor(datasource, templateSrv = (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_1__.getTemplateSrv)(), timeSrv = (0,_features_dashboard_services_TimeSrv__WEBPACK_IMPORTED_MODULE_2__.getTimeSrv)()) {
    super();
    this.datasource = datasource;
    this.templateSrv = templateSrv;
    this.timeSrv = timeSrv;
    this.datasource = datasource;
    this.templateSrv = templateSrv;
    this.timeSrv = timeSrv;
    this.query = this.query.bind(this);
  }

  query(request) {
    const query = request.targets[0].expr;

    if (!query) {
      return (0,rxjs__WEBPACK_IMPORTED_MODULE_4__.of)({
        data: []
      });
    }

    const scopedVars = Object.assign({}, request.scopedVars, {
      __interval: {
        text: this.datasource.interval,
        value: this.datasource.interval
      },
      __interval_ms: {
        text: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.rangeUtil.intervalToMs(this.datasource.interval),
        value: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.rangeUtil.intervalToMs(this.datasource.interval)
      }
    }, this.datasource.getRangeScopedVars(this.timeSrv.timeRange()));
    const interpolated = this.templateSrv.replace(query, scopedVars, this.datasource.interpolateQueryExpr);
    const metricFindQuery = new _metric_find_query__WEBPACK_IMPORTED_MODULE_3__["default"](this.datasource, interpolated);
    const metricFindStream = (0,rxjs__WEBPACK_IMPORTED_MODULE_5__.from)(metricFindQuery.process());
    return metricFindStream.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.map)(results => ({
      data: results
    })));
  }

  toDataQuery(query) {
    return {
      refId: 'PrometheusDatasource-VariableQuery',
      expr: query.query
    };
  }

}

/***/ }),

/***/ "./.yarn/__virtual__/react-use-virtual-00326e70ba/0/cache/react-use-npm-17.3.2-a032cbeb01-7379460f51.zip/node_modules/react-use/esm/usePrevious.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ usePrevious)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");

function usePrevious(state) {
    var ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
        ref.current = state;
    });
    return ref.current;
}


/***/ }),

/***/ "./.yarn/__virtual__/react-use-virtual-00326e70ba/0/cache/react-use-npm-17.3.2-a032cbeb01-7379460f51.zip/node_modules/react-use/esm/useToggle.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");

var toggleReducer = function (state, nextValue) {
    return typeof nextValue === 'boolean' ? nextValue : !state;
};
var useToggle = function (initialValue) {
    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(toggleReducer, initialValue);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (useToggle);


/***/ }),

/***/ "./.yarn/cache/lru-cache-npm-7.9.0-d803108233-c91a293a10.zip/node_modules/lru-cache/index.js":
/***/ ((module) => {

const perf = typeof performance === 'object' && performance &&
  typeof performance.now === 'function' ? performance : Date

const hasAbortController = typeof AbortController === 'function'

// minimal backwards-compatibility polyfill
// this doesn't have nearly all the checks and whatnot that
// actual AbortController/Signal has, but it's enough for
// our purposes, and if used properly, behaves the same.
const AC = hasAbortController ? AbortController : Object.assign(
  class AbortController {
    constructor () { this.signal = new AC.AbortSignal }
    abort () {
      this.signal.dispatchEvent('abort')
    }
  },
  {
    AbortSignal: class AbortSignal {
      constructor () {
        this.aborted = false
        this._listeners = []
      }
      dispatchEvent (type) {
        if (type === 'abort') {
          this.aborted = true
          const e = { type, target: this }
          this.onabort(e)
          this._listeners.forEach(f => f(e), this)
        }
      }
      onabort () {}
      addEventListener (ev, fn) {
        if (ev === 'abort') {
          this._listeners.push(fn)
        }
      }
      removeEventListener (ev, fn) {
        if (ev === 'abort') {
          this._listeners = this._listeners.filter(f => f !== fn)
        }
      }
    }
  }
)

const warned = new Set()
const deprecatedOption = (opt, instead) => {
  const code = `LRU_CACHE_OPTION_${opt}`
  if (shouldWarn(code)) {
    warn(code, `${opt} option`, `options.${instead}`, LRUCache)
  }
}
const deprecatedMethod = (method, instead) => {
  const code = `LRU_CACHE_METHOD_${method}`
  if (shouldWarn(code)) {
    const { prototype } = LRUCache
    const { get } = Object.getOwnPropertyDescriptor(prototype, method)
    warn(code, `${method} method`, `cache.${instead}()`, get)
  }
}
const deprecatedProperty = (field, instead) => {
  const code = `LRU_CACHE_PROPERTY_${field}`
  if (shouldWarn(code)) {
    const { prototype } = LRUCache
    const { get } = Object.getOwnPropertyDescriptor(prototype, field)
    warn(code, `${field} property`, `cache.${instead}`, get)
  }
}

const emitWarning = (...a) => {
  typeof process === 'object' &&
    process &&
    typeof process.emitWarning === 'function'
  ? process.emitWarning(...a)
  : console.error(...a)
}

const shouldWarn = code => !warned.has(code)

const warn = (code, what, instead, fn) => {
  warned.add(code)
  const msg = `The ${what} is deprecated. Please use ${instead} instead.`
  emitWarning(msg, 'DeprecationWarning', code, fn)
}

const isPosInt = n => n && n === Math.floor(n) && n > 0 && isFinite(n)

/* istanbul ignore next - This is a little bit ridiculous, tbh.
 * The maximum array length is 2^32-1 or thereabouts on most JS impls.
 * And well before that point, you're caching the entire world, I mean,
 * that's ~32GB of just integers for the next/prev links, plus whatever
 * else to hold that many keys and values.  Just filling the memory with
 * zeroes at init time is brutal when you get that big.
 * But why not be complete?
 * Maybe in the future, these limits will have expanded. */
const getUintArray = max => !isPosInt(max) ? null
: max <= Math.pow(2, 8) ? Uint8Array
: max <= Math.pow(2, 16) ? Uint16Array
: max <= Math.pow(2, 32) ? Uint32Array
: max <= Number.MAX_SAFE_INTEGER ? ZeroArray
: null

class ZeroArray extends Array {
  constructor (size) {
    super(size)
    this.fill(0)
  }
}

class Stack {
  constructor (max) {
    if (max === 0) {
      return []
    }
    const UintArray = getUintArray(max)
    this.heap = new UintArray(max)
    this.length = 0
  }
  push (n) {
    this.heap[this.length++] = n
  }
  pop () {
    return this.heap[--this.length]
  }
}

class LRUCache {
  constructor (options = {}) {
    const {
      max = 0,
      ttl,
      ttlResolution = 1,
      ttlAutopurge,
      updateAgeOnGet,
      updateAgeOnHas,
      allowStale,
      dispose,
      disposeAfter,
      noDisposeOnSet,
      noUpdateTTL,
      maxSize = 0,
      sizeCalculation,
      fetchMethod,
    } = options

    // deprecated options, don't trigger a warning for getting them if
    // the thing being passed in is another LRUCache we're copying.
    const {
      length,
      maxAge,
      stale,
    } = options instanceof LRUCache ? {} : options

    if (max !== 0 && !isPosInt(max)) {
      throw new TypeError('max option must be a nonnegative integer')
    }

    const UintArray = max ? getUintArray(max) : Array
    if (!UintArray) {
      throw new Error('invalid max value: ' + max)
    }

    this.max = max
    this.maxSize = maxSize
    this.sizeCalculation = sizeCalculation || length
    if (this.sizeCalculation) {
      if (!this.maxSize) {
        throw new TypeError('cannot set sizeCalculation without setting maxSize')
      }
      if (typeof this.sizeCalculation !== 'function') {
        throw new TypeError('sizeCalculation set to non-function')
      }
    }

    this.fetchMethod = fetchMethod || null
    if (this.fetchMethod && typeof this.fetchMethod !== 'function') {
      throw new TypeError('fetchMethod must be a function if specified')
    }

    this.keyMap = new Map()
    this.keyList = new Array(max).fill(null)
    this.valList = new Array(max).fill(null)
    this.next = new UintArray(max)
    this.prev = new UintArray(max)
    this.head = 0
    this.tail = 0
    this.free = new Stack(max)
    this.initialFill = 1
    this.size = 0

    if (typeof dispose === 'function') {
      this.dispose = dispose
    }
    if (typeof disposeAfter === 'function') {
      this.disposeAfter = disposeAfter
      this.disposed = []
    } else {
      this.disposeAfter = null
      this.disposed = null
    }
    this.noDisposeOnSet = !!noDisposeOnSet
    this.noUpdateTTL = !!noUpdateTTL

    if (this.maxSize !== 0) {
      if (!isPosInt(this.maxSize)) {
        throw new TypeError('maxSize must be a positive integer if specified')
      }
      this.initializeSizeTracking()
    }

    this.allowStale = !!allowStale || !!stale
    this.updateAgeOnGet = !!updateAgeOnGet
    this.updateAgeOnHas = !!updateAgeOnHas
    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0
      ? ttlResolution : 1
    this.ttlAutopurge = !!ttlAutopurge
    this.ttl = ttl || maxAge || 0
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError('ttl must be a positive integer if specified')
      }
      this.initializeTTLTracking()
    }

    // do not allow completely unbounded caches
    if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {
      throw new TypeError('At least one of max, maxSize, or ttl is required')
    }
    if (!this.ttlAutopurge && !this.max && !this.maxSize) {
      const code = 'LRU_CACHE_UNBOUNDED'
      if (shouldWarn(code)) {
        warned.add(code)
        const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' +
          'result in unbounded memory consumption.'
        emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache)
      }
    }

    if (stale) {
      deprecatedOption('stale', 'allowStale')
    }
    if (maxAge) {
      deprecatedOption('maxAge', 'ttl')
    }
    if (length) {
      deprecatedOption('length', 'sizeCalculation')
    }
  }

  getRemainingTTL (key) {
    return this.has(key, { updateAgeOnHas: false }) ? Infinity : 0
  }

  initializeTTLTracking () {
    this.ttls = new ZeroArray(this.max)
    this.starts = new ZeroArray(this.max)

    this.setItemTTL = (index, ttl) => {
      this.starts[index] = ttl !== 0 ? perf.now() : 0
      this.ttls[index] = ttl
      if (ttl !== 0 && this.ttlAutopurge) {
        const t = setTimeout(() => {
          if (this.isStale(index)) {
            this.delete(this.keyList[index])
          }
        }, ttl + 1)
        /* istanbul ignore else - unref() not supported on all platforms */
        if (t.unref) {
          t.unref()
        }
      }
    }

    this.updateItemAge = (index) => {
      this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0
    }

    // debounce calls to perf.now() to 1s so we're not hitting
    // that costly call repeatedly.
    let cachedNow = 0
    const getNow = () => {
      const n = perf.now()
      if (this.ttlResolution > 0) {
        cachedNow = n
        const t = setTimeout(() => cachedNow = 0, this.ttlResolution)
        /* istanbul ignore else - not available on all platforms */
        if (t.unref) {
          t.unref()
        }
      }
      return n
    }

    this.getRemainingTTL = (key) => {
      const index = this.keyMap.get(key)
      if (index === undefined) {
        return 0
      }
      return this.ttls[index] === 0 || this.starts[index] === 0 ? Infinity
        : ((this.starts[index] + this.ttls[index]) - (cachedNow || getNow()))
    }

    this.isStale = (index) => {
      return this.ttls[index] !== 0 && this.starts[index] !== 0 &&
        ((cachedNow || getNow()) - this.starts[index] > this.ttls[index])
    }
  }
  updateItemAge (index) {}
  setItemTTL (index, ttl) {}
  isStale (index) { return false }

  initializeSizeTracking () {
    this.calculatedSize = 0
    this.sizes = new ZeroArray(this.max)
    this.removeItemSize = index => this.calculatedSize -= this.sizes[index]
    this.requireSize = (k, v, size, sizeCalculation) => {
      if (!isPosInt(size)) {
        if (sizeCalculation) {
          if (typeof sizeCalculation !== 'function') {
            throw new TypeError('sizeCalculation must be a function')
          }
          size = sizeCalculation(v, k)
          if (!isPosInt(size)) {
            throw new TypeError('sizeCalculation return invalid (expect positive integer)')
          }
        } else {
          throw new TypeError('invalid size value (must be positive integer)')
        }
      }
      return size
    }
    this.addItemSize = (index, v, k, size) => {
      this.sizes[index] = size
      const maxSize = this.maxSize - this.sizes[index]
      while (this.calculatedSize > maxSize) {
        this.evict(true)
      }
      this.calculatedSize += this.sizes[index]
    }
  }
  removeItemSize (index) {}
  addItemSize (index, v, k, size) {}
  requireSize (k, v, size, sizeCalculation) {
    if (size || sizeCalculation) {
      throw new TypeError('cannot set size without setting maxSize on cache')
    }
  }

  *indexes ({ allowStale = this.allowStale } = {}) {
    if (this.size) {
      for (let i = this.tail; true; ) {
        if (!this.isValidIndex(i)) {
          break
        }
        if (allowStale || !this.isStale(i)) {
          yield i
        }
        if (i === this.head) {
          break
        } else {
          i = this.prev[i]
        }
      }
    }
  }

  *rindexes ({ allowStale = this.allowStale } = {}) {
    if (this.size) {
      for (let i = this.head; true; ) {
        if (!this.isValidIndex(i)) {
          break
        }
        if (allowStale || !this.isStale(i)) {
          yield i
        }
        if (i === this.tail) {
          break
        } else {
          i = this.next[i]
        }
      }
    }
  }

  isValidIndex (index) {
    return this.keyMap.get(this.keyList[index]) === index
  }

  *entries () {
    for (const i of this.indexes()) {
      yield [this.keyList[i], this.valList[i]]
    }
  }
  *rentries () {
    for (const i of this.rindexes()) {
      yield [this.keyList[i], this.valList[i]]
    }
  }

  *keys () {
    for (const i of this.indexes()) {
      yield this.keyList[i]
    }
  }
  *rkeys () {
    for (const i of this.rindexes()) {
      yield this.keyList[i]
    }
  }

  *values () {
    for (const i of this.indexes()) {
      yield this.valList[i]
    }
  }
  *rvalues () {
    for (const i of this.rindexes()) {
      yield this.valList[i]
    }
  }

  [Symbol.iterator] () {
    return this.entries()
  }

  find (fn, getOptions = {}) {
    for (const i of this.indexes()) {
      if (fn(this.valList[i], this.keyList[i], this)) {
        return this.get(this.keyList[i], getOptions)
      }
    }
  }

  forEach (fn, thisp = this) {
    for (const i of this.indexes()) {
      fn.call(thisp, this.valList[i], this.keyList[i], this)
    }
  }

  rforEach (fn, thisp = this) {
    for (const i of this.rindexes()) {
      fn.call(thisp, this.valList[i], this.keyList[i], this)
    }
  }

  get prune () {
    deprecatedMethod('prune', 'purgeStale')
    return this.purgeStale
  }

  purgeStale () {
    let deleted = false
    for (const i of this.rindexes({ allowStale: true })) {
      if (this.isStale(i)) {
        this.delete(this.keyList[i])
        deleted = true
      }
    }
    return deleted
  }

  dump () {
    const arr = []
    for (const i of this.indexes()) {
      const key = this.keyList[i]
      const value = this.valList[i]
      const entry = { value }
      if (this.ttls) {
        entry.ttl = this.ttls[i]
      }
      if (this.sizes) {
        entry.size = this.sizes[i]
      }
      arr.unshift([key, entry])
    }
    return arr
  }

  load (arr) {
    this.clear()
    for (const [key, entry] of arr) {
      this.set(key, entry.value, entry)
    }
  }

  dispose (v, k, reason) {}

  set (k, v, {
    ttl = this.ttl,
    noDisposeOnSet = this.noDisposeOnSet,
    size = 0,
    sizeCalculation = this.sizeCalculation,
    noUpdateTTL = this.noUpdateTTL,
  } = {}) {
    size = this.requireSize(k, v, size, sizeCalculation)
    let index = this.size === 0 ? undefined : this.keyMap.get(k)
    if (index === undefined) {
      // addition
      index = this.newIndex()
      this.keyList[index] = k
      this.valList[index] = v
      this.keyMap.set(k, index)
      this.next[this.tail] = index
      this.prev[index] = this.tail
      this.tail = index
      this.size ++
      this.addItemSize(index, v, k, size)
      noUpdateTTL = false
    } else {
      // update
      const oldVal = this.valList[index]
      if (v !== oldVal) {
        if (this.isBackgroundFetch(oldVal)) {
          oldVal.__abortController.abort()
        } else {
          if (!noDisposeOnSet) {
            this.dispose(oldVal, k, 'set')
            if (this.disposeAfter) {
              this.disposed.push([oldVal, k, 'set'])
            }
          }
        }
        this.removeItemSize(index)
        this.valList[index] = v
        this.addItemSize(index, v, k, size)
      }
      this.moveToTail(index)
    }
    if (ttl !== 0 && this.ttl === 0 && !this.ttls) {
      this.initializeTTLTracking()
    }
    if (!noUpdateTTL) {
      this.setItemTTL(index, ttl)
    }
    if (this.disposeAfter) {
      while (this.disposed.length) {
        this.disposeAfter(...this.disposed.shift())
      }
    }
    return this
  }

  newIndex () {
    if (this.size === 0) {
      return this.tail
    }
    if (this.size === this.max && this.max !== 0) {
      return this.evict(false)
    }
    if (this.free.length !== 0) {
      return this.free.pop()
    }
    // initial fill, just keep writing down the list
    return this.initialFill++
  }

  pop () {
    if (this.size) {
      const val = this.valList[this.head]
      this.evict(true)
      return val
    }
  }

  evict (free) {
    const head = this.head
    const k = this.keyList[head]
    const v = this.valList[head]
    if (this.isBackgroundFetch(v)) {
      v.__abortController.abort()
    } else {
      this.dispose(v, k, 'evict')
      if (this.disposeAfter) {
        this.disposed.push([v, k, 'evict'])
      }
    }
    this.removeItemSize(head)
    // if we aren't about to use the index, then null these out
    if (free) {
      this.keyList[head] = null
      this.valList[head] = null
      this.free.push(head)
    }
    this.head = this.next[head]
    this.keyMap.delete(k)
    this.size --
    return head
  }

  has (k, { updateAgeOnHas = this.updateAgeOnHas } = {}) {
    const index = this.keyMap.get(k)
    if (index !== undefined) {
      if (!this.isStale(index)) {
        if (updateAgeOnHas) {
          this.updateItemAge(index)
        }
        return true
      }
    }
    return false
  }

  // like get(), but without any LRU updating or TTL expiration
  peek (k, { allowStale = this.allowStale } = {}) {
    const index = this.keyMap.get(k)
    if (index !== undefined && (allowStale || !this.isStale(index))) {
      return this.valList[index]
    }
  }

  backgroundFetch (k, index, options) {
    const v = index === undefined ? undefined : this.valList[index]
    if (this.isBackgroundFetch(v)) {
      return v
    }
    const ac = new AC()
    const fetchOpts = {
      signal: ac.signal,
      options,
    }
    const p = Promise.resolve(this.fetchMethod(k, v, fetchOpts)).then(v => {
      if (!ac.signal.aborted) {
        this.set(k, v, fetchOpts.options)
      }
      return v
    })
    p.__abortController = ac
    p.__staleWhileFetching = v
    if (index === undefined) {
      this.set(k, p, fetchOpts.options)
      index = this.keyMap.get(k)
    } else {
      this.valList[index] = p
    }
    return p
  }

  isBackgroundFetch (p) {
    return p && typeof p === 'object' && typeof p.then === 'function' &&
      Object.prototype.hasOwnProperty.call(p, '__staleWhileFetching')
  }

  // this takes the union of get() and set() opts, because it does both
  async fetch (k, {
    allowStale = this.allowStale,
    updateAgeOnGet = this.updateAgeOnGet,
    ttl = this.ttl,
    noDisposeOnSet = this.noDisposeOnSet,
    size = 0,
    sizeCalculation = this.sizeCalculation,
    noUpdateTTL = this.noUpdateTTL,
  } = {}) {
    if (!this.fetchMethod) {
      return this.get(k, {allowStale, updateAgeOnGet})
    }

    const options = {
      allowStale,
      updateAgeOnGet,
      ttl,
      noDisposeOnSet,
      size,
      sizeCalculation,
      noUpdateTTL,
    }

    let index = this.keyMap.get(k)
    if (index === undefined) {
      return this.backgroundFetch(k, index, options)
    } else {
      // in cache, maybe already fetching
      const v = this.valList[index]
      if (this.isBackgroundFetch(v)) {
        return allowStale && v.__staleWhileFetching !== undefined
          ? v.__staleWhileFetching : v
      }

      if (!this.isStale(index)) {
        this.moveToTail(index)
        if (updateAgeOnGet) {
          this.updateItemAge(index)
        }
        return v
      }

      // ok, it is stale, and not already fetching
      // refresh the cache.
      const p = this.backgroundFetch(k, index, options)
      return allowStale && p.__staleWhileFetching !== undefined
        ? p.__staleWhileFetching : p
    }
  }

  get (k, {
    allowStale = this.allowStale,
    updateAgeOnGet = this.updateAgeOnGet,
  } = {}) {
    const index = this.keyMap.get(k)
    if (index !== undefined) {
      const value = this.valList[index]
      const fetching = this.isBackgroundFetch(value)
      if (this.isStale(index)) {
        // delete only if not an in-flight background fetch
        if (!fetching) {
          this.delete(k)
          return allowStale ? value : undefined
        } else {
          return allowStale ? value.__staleWhileFetching : undefined
        }
      } else {
        // if we're currently fetching it, we don't actually have it yet
        // it's not stale, which means this isn't a staleWhileRefetching,
        // so we just return undefined
        if (fetching) {
          return undefined
        }
        this.moveToTail(index)
        if (updateAgeOnGet) {
          this.updateItemAge(index)
        }
        return value
      }
    }
  }

  connect (p, n) {
    this.prev[n] = p
    this.next[p] = n
  }

  moveToTail (index) {
    // if tail already, nothing to do
    // if head, move head to next[index]
    // else
    //   move next[prev[index]] to next[index] (head has no prev)
    //   move prev[next[index]] to prev[index]
    // prev[index] = tail
    // next[tail] = index
    // tail = index
    if (index !== this.tail) {
      if (index === this.head) {
        this.head = this.next[index]
      } else {
        this.connect(this.prev[index], this.next[index])
      }
      this.connect(this.tail, index)
      this.tail = index
    }
  }

  get del () {
    deprecatedMethod('del', 'delete')
    return this.delete
  }

  delete (k) {
    let deleted = false
    if (this.size !== 0) {
      const index = this.keyMap.get(k)
      if (index !== undefined) {
        deleted = true
        if (this.size === 1) {
          this.clear()
        } else {
          this.removeItemSize(index)
          const v = this.valList[index]
          if (this.isBackgroundFetch(v)) {
            v.__abortController.abort()
          } else {
            this.dispose(v, k, 'delete')
            if (this.disposeAfter) {
              this.disposed.push([v, k, 'delete'])
            }
          }
          this.keyMap.delete(k)
          this.keyList[index] = null
          this.valList[index] = null
          if (index === this.tail) {
            this.tail = this.prev[index]
          } else if (index === this.head) {
            this.head = this.next[index]
          } else {
            this.next[this.prev[index]] = this.next[index]
            this.prev[this.next[index]] = this.prev[index]
          }
          this.size --
          this.free.push(index)
        }
      }
    }
    if (this.disposed) {
      while (this.disposed.length) {
        this.disposeAfter(...this.disposed.shift())
      }
    }
    return deleted
  }

  clear () {
    for (const index of this.rindexes({ allowStale: true })) {
      const v = this.valList[index]
      if (this.isBackgroundFetch(v)) {
        v.__abortController.abort()
      } else {
        const k = this.keyList[index]
        this.dispose(v, k, 'delete')
        if (this.disposeAfter) {
          this.disposed.push([v, k, 'delete'])
        }
      }
    }

    this.keyMap.clear()
    this.valList.fill(null)
    this.keyList.fill(null)
    if (this.ttls) {
      this.ttls.fill(0)
      this.starts.fill(0)
    }
    if (this.sizes) {
      this.sizes.fill(0)
    }
    this.head = 0
    this.tail = 0
    this.initialFill = 1
    this.free.length = 0
    this.calculatedSize = 0
    this.size = 0
    if (this.disposed) {
      while (this.disposed.length) {
        this.disposeAfter(...this.disposed.shift())
      }
    }
  }

  get reset () {
    deprecatedMethod('reset', 'clear')
    return this.clear
  }

  get length () {
    deprecatedProperty('length', 'size')
    return this.size
  }

  static get AbortController () {
    return AC
  }
}

module.exports = LRUCache


/***/ }),

/***/ "./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/dom/WebSocketSubject.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WebSocketSubject": () => (/* binding */ WebSocketSubject)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/tslib-npm-2.3.1-0e21e18015-de17a98d46.zip/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/Subject.js");
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/Subscriber.js");
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/Observable.js");
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/Subscription.js");
/* harmony import */ var _ReplaySubject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/ReplaySubject.js");






var DEFAULT_WEBSOCKET_CONFIG = {
    url: '',
    deserializer: function (e) { return JSON.parse(e.data); },
    serializer: function (value) { return JSON.stringify(value); },
};
var WEBSOCKETSUBJECT_INVALID_ERROR_OBJECT = 'WebSocketSubject.error must be called with an object with an error code, and an optional reason: { code: number, reason: string }';
var WebSocketSubject = (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(WebSocketSubject, _super);
    function WebSocketSubject(urlConfigOrSource, destination) {
        var _this = _super.call(this) || this;
        _this._socket = null;
        if (urlConfigOrSource instanceof _Observable__WEBPACK_IMPORTED_MODULE_1__.Observable) {
            _this.destination = destination;
            _this.source = urlConfigOrSource;
        }
        else {
            var config = (_this._config = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)({}, DEFAULT_WEBSOCKET_CONFIG));
            _this._output = new _Subject__WEBPACK_IMPORTED_MODULE_2__.Subject();
            if (typeof urlConfigOrSource === 'string') {
                config.url = urlConfigOrSource;
            }
            else {
                for (var key in urlConfigOrSource) {
                    if (urlConfigOrSource.hasOwnProperty(key)) {
                        config[key] = urlConfigOrSource[key];
                    }
                }
            }
            if (!config.WebSocketCtor && WebSocket) {
                config.WebSocketCtor = WebSocket;
            }
            else if (!config.WebSocketCtor) {
                throw new Error('no WebSocket constructor can be found');
            }
            _this.destination = new _ReplaySubject__WEBPACK_IMPORTED_MODULE_3__.ReplaySubject();
        }
        return _this;
    }
    WebSocketSubject.prototype.lift = function (operator) {
        var sock = new WebSocketSubject(this._config, this.destination);
        sock.operator = operator;
        sock.source = this;
        return sock;
    };
    WebSocketSubject.prototype._resetState = function () {
        this._socket = null;
        if (!this.source) {
            this.destination = new _ReplaySubject__WEBPACK_IMPORTED_MODULE_3__.ReplaySubject();
        }
        this._output = new _Subject__WEBPACK_IMPORTED_MODULE_2__.Subject();
    };
    WebSocketSubject.prototype.multiplex = function (subMsg, unsubMsg, messageFilter) {
        var self = this;
        return new _Observable__WEBPACK_IMPORTED_MODULE_1__.Observable(function (observer) {
            try {
                self.next(subMsg());
            }
            catch (err) {
                observer.error(err);
            }
            var subscription = self.subscribe({
                next: function (x) {
                    try {
                        if (messageFilter(x)) {
                            observer.next(x);
                        }
                    }
                    catch (err) {
                        observer.error(err);
                    }
                },
                error: function (err) { return observer.error(err); },
                complete: function () { return observer.complete(); },
            });
            return function () {
                try {
                    self.next(unsubMsg());
                }
                catch (err) {
                    observer.error(err);
                }
                subscription.unsubscribe();
            };
        });
    };
    WebSocketSubject.prototype._connectSocket = function () {
        var _this = this;
        var _a = this._config, WebSocketCtor = _a.WebSocketCtor, protocol = _a.protocol, url = _a.url, binaryType = _a.binaryType;
        var observer = this._output;
        var socket = null;
        try {
            socket = protocol ? new WebSocketCtor(url, protocol) : new WebSocketCtor(url);
            this._socket = socket;
            if (binaryType) {
                this._socket.binaryType = binaryType;
            }
        }
        catch (e) {
            observer.error(e);
            return;
        }
        var subscription = new _Subscription__WEBPACK_IMPORTED_MODULE_4__.Subscription(function () {
            _this._socket = null;
            if (socket && socket.readyState === 1) {
                socket.close();
            }
        });
        socket.onopen = function (evt) {
            var _socket = _this._socket;
            if (!_socket) {
                socket.close();
                _this._resetState();
                return;
            }
            var openObserver = _this._config.openObserver;
            if (openObserver) {
                openObserver.next(evt);
            }
            var queue = _this.destination;
            _this.destination = _Subscriber__WEBPACK_IMPORTED_MODULE_5__.Subscriber.create(function (x) {
                if (socket.readyState === 1) {
                    try {
                        var serializer = _this._config.serializer;
                        socket.send(serializer(x));
                    }
                    catch (e) {
                        _this.destination.error(e);
                    }
                }
            }, function (err) {
                var closingObserver = _this._config.closingObserver;
                if (closingObserver) {
                    closingObserver.next(undefined);
                }
                if (err && err.code) {
                    socket.close(err.code, err.reason);
                }
                else {
                    observer.error(new TypeError(WEBSOCKETSUBJECT_INVALID_ERROR_OBJECT));
                }
                _this._resetState();
            }, function () {
                var closingObserver = _this._config.closingObserver;
                if (closingObserver) {
                    closingObserver.next(undefined);
                }
                socket.close();
                _this._resetState();
            });
            if (queue && queue instanceof _ReplaySubject__WEBPACK_IMPORTED_MODULE_3__.ReplaySubject) {
                subscription.add(queue.subscribe(_this.destination));
            }
        };
        socket.onerror = function (e) {
            _this._resetState();
            observer.error(e);
        };
        socket.onclose = function (e) {
            if (socket === _this._socket) {
                _this._resetState();
            }
            var closeObserver = _this._config.closeObserver;
            if (closeObserver) {
                closeObserver.next(e);
            }
            if (e.wasClean) {
                observer.complete();
            }
            else {
                observer.error(e);
            }
        };
        socket.onmessage = function (e) {
            try {
                var deserializer = _this._config.deserializer;
                observer.next(deserializer(e));
            }
            catch (err) {
                observer.error(err);
            }
        };
    };
    WebSocketSubject.prototype._subscribe = function (subscriber) {
        var _this = this;
        var source = this.source;
        if (source) {
            return source.subscribe(subscriber);
        }
        if (!this._socket) {
            this._connectSocket();
        }
        this._output.subscribe(subscriber);
        subscriber.add(function () {
            var _socket = _this._socket;
            if (_this._output.observers.length === 0) {
                if (_socket && (_socket.readyState === 1 || _socket.readyState === 0)) {
                    _socket.close();
                }
                _this._resetState();
            }
        });
        return subscriber;
    };
    WebSocketSubject.prototype.unsubscribe = function () {
        var _socket = this._socket;
        if (_socket && (_socket.readyState === 1 || _socket.readyState === 0)) {
            _socket.close();
        }
        this._resetState();
        _super.prototype.unsubscribe.call(this);
    };
    return WebSocketSubject;
}(_Subject__WEBPACK_IMPORTED_MODULE_2__.AnonymousSubject));

//# sourceMappingURL=WebSocketSubject.js.map

/***/ }),

/***/ "./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/dom/webSocket.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "webSocket": () => (/* binding */ webSocket)
/* harmony export */ });
/* harmony import */ var _WebSocketSubject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/dom/WebSocketSubject.js");

function webSocket(urlConfigOrSource) {
    return new _WebSocketSubject__WEBPACK_IMPORTED_MODULE_0__.WebSocketSubject(urlConfigOrSource);
}
//# sourceMappingURL=webSocket.js.map

/***/ }),

/***/ "./.yarn/cache/uuid-npm-8.3.2-eca0baba53-5575a8a75c.zip/node_modules/uuid/dist/esm-browser/parse.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/uuid-npm-8.3.2-eca0baba53-5575a8a75c.zip/node_modules/uuid/dist/esm-browser/validate.js");


function parse(uuid) {
  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
    throw TypeError('Invalid UUID');
  }

  var v;
  var arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parse);

/***/ }),

/***/ "./.yarn/cache/uuid-npm-8.3.2-eca0baba53-5575a8a75c.zip/node_modules/uuid/dist/esm-browser/sha1.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;

    case 1:
      return x ^ y ^ z;

    case 2:
      return x & y ^ x & z ^ y & z;

    case 3:
      return x ^ y ^ z;
  }
}

function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}

function sha1(bytes) {
  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

  if (typeof bytes === 'string') {
    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = [];

    for (var i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    // Convert Array-like to Array
    bytes = Array.prototype.slice.call(bytes);
  }

  bytes.push(0x80);
  var l = bytes.length / 4 + 2;
  var N = Math.ceil(l / 16);
  var M = new Array(N);

  for (var _i = 0; _i < N; ++_i) {
    var arr = new Uint32Array(16);

    for (var j = 0; j < 16; ++j) {
      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
    }

    M[_i] = arr;
  }

  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;

  for (var _i2 = 0; _i2 < N; ++_i2) {
    var W = new Uint32Array(80);

    for (var t = 0; t < 16; ++t) {
      W[t] = M[_i2][t];
    }

    for (var _t = 16; _t < 80; ++_t) {
      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
    }

    var a = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];

    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s = Math.floor(_t2 / 20);
      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }

    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }

  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sha1);

/***/ }),

/***/ "./.yarn/cache/uuid-npm-8.3.2-eca0baba53-5575a8a75c.zip/node_modules/uuid/dist/esm-browser/v35.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DNS": () => (/* binding */ DNS),
/* harmony export */   "URL": () => (/* binding */ URL),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/uuid-npm-8.3.2-eca0baba53-5575a8a75c.zip/node_modules/uuid/dist/esm-browser/stringify.js");
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/uuid-npm-8.3.2-eca0baba53-5575a8a75c.zip/node_modules/uuid/dist/esm-browser/parse.js");



function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  var bytes = [];

  for (var i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

var DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
var URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__["default"])(namespace);
    }

    if (namespace.length !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    var bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__["default"])(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}

/***/ }),

/***/ "./.yarn/cache/uuid-npm-8.3.2-eca0baba53-5575a8a75c.zip/node_modules/uuid/dist/esm-browser/v5.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/uuid-npm-8.3.2-eca0baba53-5575a8a75c.zip/node_modules/uuid/dist/esm-browser/v35.js");
/* harmony import */ var _sha1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/uuid-npm-8.3.2-eca0baba53-5575a8a75c.zip/node_modules/uuid/dist/esm-browser/sha1.js");


var v5 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__["default"])('v5', 0x50, _sha1_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v5);

/***/ }),

/***/ "./.yarn/__virtual__/@grafana-lezer-logql-virtual-9250dbecf8/0/cache/@grafana-lezer-logql-npm-0.0.11-d7d249e74a-0427e59528.zip/node_modules/@grafana/lezer-logql/index.es.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AbsentOverTime": () => (/* binding */ AbsentOverTime),
/* harmony export */   "Add": () => (/* binding */ Add),
/* harmony export */   "And": () => (/* binding */ And),
/* harmony export */   "Avg": () => (/* binding */ Avg),
/* harmony export */   "AvgOverTime": () => (/* binding */ AvgOverTime),
/* harmony export */   "BinOpExpr": () => (/* binding */ BinOpExpr),
/* harmony export */   "BinOpModifier": () => (/* binding */ BinOpModifier),
/* harmony export */   "Bool": () => (/* binding */ Bool),
/* harmony export */   "Bottomk": () => (/* binding */ Bottomk),
/* harmony export */   "By": () => (/* binding */ By),
/* harmony export */   "Bytes": () => (/* binding */ Bytes),
/* harmony export */   "BytesConv": () => (/* binding */ BytesConv),
/* harmony export */   "BytesFilter": () => (/* binding */ BytesFilter),
/* harmony export */   "BytesOverTime": () => (/* binding */ BytesOverTime),
/* harmony export */   "BytesRate": () => (/* binding */ BytesRate),
/* harmony export */   "ConvOp": () => (/* binding */ ConvOp),
/* harmony export */   "Count": () => (/* binding */ Count),
/* harmony export */   "CountOverTime": () => (/* binding */ CountOverTime),
/* harmony export */   "Div": () => (/* binding */ Div),
/* harmony export */   "Duration": () => (/* binding */ Duration),
/* harmony export */   "DurationConv": () => (/* binding */ DurationConv),
/* harmony export */   "DurationFilter": () => (/* binding */ DurationFilter),
/* harmony export */   "DurationSecondsConv": () => (/* binding */ DurationSecondsConv),
/* harmony export */   "Eq": () => (/* binding */ Eq),
/* harmony export */   "Eql": () => (/* binding */ Eql),
/* harmony export */   "Expr": () => (/* binding */ Expr),
/* harmony export */   "Filter": () => (/* binding */ Filter),
/* harmony export */   "FilterOp": () => (/* binding */ FilterOp),
/* harmony export */   "FirstOverTime": () => (/* binding */ FirstOverTime),
/* harmony export */   "GroupLeft": () => (/* binding */ GroupLeft),
/* harmony export */   "GroupRight": () => (/* binding */ GroupRight),
/* harmony export */   "Grouping": () => (/* binding */ Grouping),
/* harmony export */   "GroupingLabel": () => (/* binding */ GroupingLabel),
/* harmony export */   "GroupingLabelList": () => (/* binding */ GroupingLabelList),
/* harmony export */   "GroupingLabels": () => (/* binding */ GroupingLabels),
/* harmony export */   "Gte": () => (/* binding */ Gte),
/* harmony export */   "Gtr": () => (/* binding */ Gtr),
/* harmony export */   "Identifier": () => (/* binding */ Identifier),
/* harmony export */   "Ignoring": () => (/* binding */ Ignoring),
/* harmony export */   "Ip": () => (/* binding */ Ip),
/* harmony export */   "IpLabelFilter": () => (/* binding */ IpLabelFilter),
/* harmony export */   "Json": () => (/* binding */ Json),
/* harmony export */   "JsonExpression": () => (/* binding */ JsonExpression),
/* harmony export */   "JsonExpressionList": () => (/* binding */ JsonExpressionList),
/* harmony export */   "JsonExpressionParser": () => (/* binding */ JsonExpressionParser),
/* harmony export */   "LabelFilter": () => (/* binding */ LabelFilter),
/* harmony export */   "LabelFormat": () => (/* binding */ LabelFormat),
/* harmony export */   "LabelFormatExpr": () => (/* binding */ LabelFormatExpr),
/* harmony export */   "LabelFormatMatcher": () => (/* binding */ LabelFormatMatcher),
/* harmony export */   "LabelName": () => (/* binding */ LabelName),
/* harmony export */   "LabelParser": () => (/* binding */ LabelParser),
/* harmony export */   "LabelReplace": () => (/* binding */ LabelReplace),
/* harmony export */   "LabelReplaceExpr": () => (/* binding */ LabelReplaceExpr),
/* harmony export */   "Labels": () => (/* binding */ Labels),
/* harmony export */   "LabelsFormat": () => (/* binding */ LabelsFormat),
/* harmony export */   "LastOverTime": () => (/* binding */ LastOverTime),
/* harmony export */   "LineComment": () => (/* binding */ LineComment),
/* harmony export */   "LineFilter": () => (/* binding */ LineFilter),
/* harmony export */   "LineFilters": () => (/* binding */ LineFilters),
/* harmony export */   "LineFormat": () => (/* binding */ LineFormat),
/* harmony export */   "LineFormatExpr": () => (/* binding */ LineFormatExpr),
/* harmony export */   "LiteralExpr": () => (/* binding */ LiteralExpr),
/* harmony export */   "LogExpr": () => (/* binding */ LogExpr),
/* harmony export */   "LogQL": () => (/* binding */ LogQL),
/* harmony export */   "LogRangeExpr": () => (/* binding */ LogRangeExpr),
/* harmony export */   "Logfmt": () => (/* binding */ Logfmt),
/* harmony export */   "Lss": () => (/* binding */ Lss),
/* harmony export */   "Lte": () => (/* binding */ Lte),
/* harmony export */   "Matcher": () => (/* binding */ Matcher),
/* harmony export */   "Matchers": () => (/* binding */ Matchers),
/* harmony export */   "Max": () => (/* binding */ Max),
/* harmony export */   "MaxOverTime": () => (/* binding */ MaxOverTime),
/* harmony export */   "MetricExpr": () => (/* binding */ MetricExpr),
/* harmony export */   "Min": () => (/* binding */ Min),
/* harmony export */   "MinOverTime": () => (/* binding */ MinOverTime),
/* harmony export */   "Mod": () => (/* binding */ Mod),
/* harmony export */   "Mul": () => (/* binding */ Mul),
/* harmony export */   "Neq": () => (/* binding */ Neq),
/* harmony export */   "Nre": () => (/* binding */ Nre),
/* harmony export */   "Number": () => (/* binding */ Number),
/* harmony export */   "NumberFilter": () => (/* binding */ NumberFilter),
/* harmony export */   "Offset": () => (/* binding */ Offset),
/* harmony export */   "OffsetExpr": () => (/* binding */ OffsetExpr),
/* harmony export */   "On": () => (/* binding */ On),
/* harmony export */   "OnOrIgnoringModifier": () => (/* binding */ OnOrIgnoringModifier),
/* harmony export */   "Or": () => (/* binding */ Or),
/* harmony export */   "Pattern": () => (/* binding */ Pattern),
/* harmony export */   "Pipe": () => (/* binding */ Pipe),
/* harmony export */   "PipeExact": () => (/* binding */ PipeExact),
/* harmony export */   "PipeMatch": () => (/* binding */ PipeMatch),
/* harmony export */   "PipelineExpr": () => (/* binding */ PipelineExpr),
/* harmony export */   "PipelineStage": () => (/* binding */ PipelineStage),
/* harmony export */   "Pow": () => (/* binding */ Pow),
/* harmony export */   "QuantileOverTime": () => (/* binding */ QuantileOverTime),
/* harmony export */   "Range": () => (/* binding */ Range),
/* harmony export */   "RangeAggregationExpr": () => (/* binding */ RangeAggregationExpr),
/* harmony export */   "RangeOp": () => (/* binding */ RangeOp),
/* harmony export */   "Rate": () => (/* binding */ Rate),
/* harmony export */   "Re": () => (/* binding */ Re),
/* harmony export */   "Regexp": () => (/* binding */ Regexp),
/* harmony export */   "Selector": () => (/* binding */ Selector),
/* harmony export */   "Stddev": () => (/* binding */ Stddev),
/* harmony export */   "StddevOverTime": () => (/* binding */ StddevOverTime),
/* harmony export */   "Stdvar": () => (/* binding */ Stdvar),
/* harmony export */   "StdvarOverTime": () => (/* binding */ StdvarOverTime),
/* harmony export */   "String": () => (/* binding */ String),
/* harmony export */   "Sub": () => (/* binding */ Sub),
/* harmony export */   "Sum": () => (/* binding */ Sum),
/* harmony export */   "SumOverTime": () => (/* binding */ SumOverTime),
/* harmony export */   "Topk": () => (/* binding */ Topk),
/* harmony export */   "UnitFilter": () => (/* binding */ UnitFilter),
/* harmony export */   "Unless": () => (/* binding */ Unless),
/* harmony export */   "Unpack": () => (/* binding */ Unpack),
/* harmony export */   "Unwrap": () => (/* binding */ Unwrap),
/* harmony export */   "UnwrapExpr": () => (/* binding */ UnwrapExpr),
/* harmony export */   "VectorAggregationExpr": () => (/* binding */ VectorAggregationExpr),
/* harmony export */   "VectorOp": () => (/* binding */ VectorOp),
/* harmony export */   "Without": () => (/* binding */ Without),
/* harmony export */   "parser": () => (/* binding */ parser)
/* harmony export */ });
/* harmony import */ var _lezer_lr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@lezer-lr-npm-0.15.8-8c481c39cd-e741225d6a.zip/node_modules/@lezer/lr/dist/index.js");


// This file was generated by lezer-generator. You probably shouldn't edit it.
const Json$1 = 1,
  Logfmt$1 = 2,
  Unpack$1 = 3,
  Pattern$1 = 4,
  Regexp$1 = 5,
  Unwrap$1 = 6,
  Ip$1 = 7,
  LabelFormat$1 = 8,
  LineFormat$1 = 9,
  LabelReplace$1 = 10,
  Offset$1 = 11,
  Bool$1 = 12,
  On$1 = 13,
  Ignoring$1 = 14,
  GroupLeft$1 = 15,
  GroupRight$1 = 16,
  BytesConv$1 = 17,
  DurationConv$1 = 18,
  DurationSecondsConv$1 = 19,
  By$1 = 20,
  Without$1 = 21,
  And$1 = 22,
  Or$1 = 23,
  Unless$1 = 24,
  Sum$1 = 25,
  Avg$1 = 26,
  Count$1 = 27,
  Max$1 = 28,
  Min$1 = 29,
  Stddev$1 = 30,
  Stdvar$1 = 31,
  Bottomk$1 = 32,
  Topk$1 = 33;

const keywordTokens = {
    json: Json$1,
    logfmt : Logfmt$1,
    unpack: Unpack$1,
    pattern : Pattern$1,
    regexp : Regexp$1,
    ip : Ip$1,
    label_format : LabelFormat$1,
    line_format : LineFormat$1,
    label_replace: LabelReplace$1,
    offset: Offset$1,
    bool: Bool$1,
    on: On$1,
    ignoring: Ignoring$1,
    group_left: GroupLeft$1,
    group_right: GroupRight$1,
    unwrap: Unwrap$1,
    bytes: BytesConv$1,
    duration: DurationConv$1,
    duration_seconds: DurationSecondsConv$1
};

const specializeIdentifier = (value, stack) => {
    return keywordTokens[value.toLowerCase()] || -1;
};


const contextualKeywordTokens = {
    by: By$1,
    without: Without$1,
    and: And$1,
    or: Or$1,
    unless: Unless$1,
    sum: Sum$1,
    avg: Avg$1,
    count: Count$1,
    max: Max$1,
    min: Min$1,
    stddev: Stddev$1,
    stdvar: Stdvar$1,
    bottomk: Bottomk$1,
    topk: Topk$1
};

const extendIdentifier = (value, stack) => {
    return contextualKeywordTokens[value.toLowerCase()] || -1;
};

// This file was generated by lezer-generator. You probably shouldn't edit it.
const spec_Identifier = {__proto__:null,count_over_time:255, rate:257, bytes_over_time:259, bytes_rate:261, avg_over_time:263, sum_over_time:265, min_over_time:267, max_over_time:269, stddev_over_time:271, stdvar_over_time:273, quantile_over_time:275, first_over_time:277, last_over_time:279, absent_over_time:281};
const parser = _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.LRParser.deserialize({
  version: 13,
  states: "@jOYQPOOO#VQPO'#DSO$fQPO'#DROYQPO'#DROOQO'#EO'#EOO$sQPO'#D}OOQO'#Eg'#EgO$xQPO'#EfQ%TQPOOOOQO'#Eu'#EuO&UQPO'#EuO&ZQPO'#EvOOQO'#D|'#D|OOQO'#DQ'#DQOOQO'#EP'#EPOOQO'#EQ'#EQOOQO'#ER'#EROOQO'#ES'#ESOOQO'#ET'#ETOOQO'#EU'#EUOOQO'#EV'#EVOOQO'#EW'#EWOOQO'#EX'#EXOOQO'#EY'#EYOOQO'#EZ'#EZOOQO'#E['#E[OOQO'#E]'#E]OOQO'#E^'#E^O&`QPO'#DUOOQO'#DT'#DTO&nQPO,59nOOQO'#Da'#DaO&vQPO'#D`O'OQPO'#D_OOQO'#D^'#D^O(lQPO'#D^OOQO'#D]'#D]O*hQPO,59mO+vQPO,59mO+}QPO,5:hO,UQPO,5:iO,aQPO'#EdO.`QPO,5;QO.gQPO,5;QO.lQPO,5;SO.lQPO,5;SO.lQPO,5;SO.lQPO,5;SO.lQPO,5;SO.lQPO,5;SOOQO,5;a,5;aOYQPO,5;bO0rQPO,59pO0wQPO1G/YOOQO1G/Y1G/YOOQO'#Dd'#DdOOQO,59z,59zO1PQPO,59zOOQO,59y,59yO1UQPO'#DUO1sQPO'#DfOOQO'#Df'#DfO3dQPO'#DfO3iQPO'#DmOOQO'#Dl'#DlOOQO'#Dj'#DjO)RQPO'#DjO4QQPO,59xO5nQPO'#DxO5sQPO'#DyOOQO,59x,59xOOQO,59w,59wOOQO1G/X1G/XOOQO1G0S1G0SO5xQPO'#E_O,XQPO'#E_O6aQPO1G0TO6fQPO1G0TO6kQPO,5;OO6sQPO1G0lO8OQPO1G0lO8VQPO1G0lO8^QPO'#EjO:`QPO'#EiO:jQPO'#EiOYQPO1G0nOYQPO1G0nOYQPO1G0nOYQPO1G0nOYQPO1G0nOYQPO1G0nO:tQPO1G0|OOQO1G/[1G/[OOQO1G/Z1G/ZOOQO7+$t7+$tO:{QPO1G/fO;QQPO,59pO;WQPO,5:`O;`QPO'#DiO;eQPO'#DhOOQO,5:R,5:ROOQO,5:Q,5:QO=RQPO,5:XO=WQPO,5:UO)RQPO,5:UO)RQPO,5:UOOQO,5:d,5:dO=fQPO'#D{OOQO'#Dz'#DzO=kQPO,5:eO?XQPO'#D^O5xQPO,5:yO?`QPO'#E`O?eQPO'#EbO@OQPO,5:yO6[QPO,5:yO@YQPO,5:yO@aQPO,5:yO@fQPO7+%oO,XQPO7+%oOOQO'#Ee'#EeOAvQPO1G0jOOQO1G0j1G0jOBOQPO7+&WOYQPO7+&WOC`QPO7+&WOCgQPO7+&WOCnQQO'#EkOOQO,5;U,5;UOEpQPO,5;TOEwQPO,5;TOGYQPO7+&YOGaQPO7+&YOOQO7+&Y7+&YOGnQPO7+&YOGuQPO7+&YOHzQPO7+&YOI[QPO7+&hOIaQPO7+%QOIfQPO1G/qOOQO1G/z1G/zOOQO1G/|1G/|OIkQPO,5:TOIpQPO,5:SOOQO1G/s1G/sOOQO1G/p1G/pOIuQPO1G/pOKcQPO,5:gO5sQPO,5:fOKkQPO,5:|OKyQPO1G0eO6[QPO1G0eOLRQPO,5:zO)RQPO,5:|OLWQPO1G0eOL_QPO'#EaOLWQPO1G0eOOQO1G0e1G0eOLdQPO1G0eO6[QPO1G0eOLkQPO1G0eOOQO<<IZ<<IZOLsQPO<<IZOLxQPO,5;POOQO7+&U7+&UOOQO<<Ir<<IrOL}QPO<<IrOYQPO<<IrOOQO'#Em'#EmOMUQPO,5;VOOQO'#El'#ElOOQO,5;V,5;VOOQO1G0o1G0oOM^QPO1G0oO! ZQPO<<JSOOQO<<Hl<<HlO! `QPO7+%]OOQO1G/o1G/oOOQO1G/n1G/nOOQO1G0R1G0ROOQO1G0Q1G0QOOQO'#Ec'#EcOOQO1G0h1G0hO! eQPO1G0hOOQO7+&P7+&POOQO1G0f1G0fO! jQPO1G0hOOQO,5:{,5:{O! {QPO7+&PO6[QPO7+&PO!!SQPO7+&PO!!bQPOAN>uOOQO1G0k1G0kO!#rQPOAN?^O!%SQPOAN?^O!%ZQQO1G0qOOQO1G0q1G0qOOQO7+&Z7+&ZO!%cQPOAN?nO!%hQPO<<HwO!%mQPO7+&SOOQO<<Ik<<IkO!%rQPO<<IkO!%zQPO<<IkO!&VQPO'#EbOOQOG24aG24aOOQOG24xG24xOOQO1G0r1G0rOOQO7+&]7+&]O!&[QPOG25YOOQOAN>cAN>cO!&aQPO<<InOOQOAN?VAN?VO!&fQPOLD*tOOQOAN?YAN?YOOQO,5:e,5:eO!&kQPO!$'N`O!&pQPO!)9CzO!&uQPO!.K9fOOQO!4//Q!4//QO5sQPO'#DyO!&zQPO'#D^O!'lQPO,59mO!'vQPO'#DROYQPO1G0nOYQPO1G0nOYQPO1G0nOYQPO1G0nOYQPO1G0nOYQPO1G0nO.lQPO,5;SO.lQPO,5;SO.lQPO,5;SO.lQPO,5;SO.lQPO,5;SO.lQPO,5;SO!)RQPO7+&YO!)YQPO7+&YO!)gQPO7+&YO!*oQPO7+&YO!*vQPO7+&YO!)nQPO'#Eh",
  stateData: "!+T~O#mOSrOS~OYZOiUOjUOkUOlUOmUOnUOoUOpUOqUO!kXO#cYO#dYO#nPO#qRO#s^O#t_O#u`O#vaO#wbO#xcO#ydO#zeO#{fO#|gO#}hO$OiO$PjO$QkO~OylO~O|oO!OoO!UoO!VoOfuXguXhuX!buX!duX!euX!fuX!guX#cuX#duX#euX#fuX#guX#huX~O!XsO#kuX#ruX~P#[O#qxO~OdyOeyO#qzO~Of}Og|Oh}O|!RO!b!RO!d!RO!e!RO!f!RO!g!RO#c!OO#d!OO#e!PO#f!PO#g!PO#h!QO~O!k!SO~O#q!TO~Oz!UO|!UO}!UO!O!UO~O#o!VO#p!WO~OV!XO{!YO~O|oO!OoO!UoO!VoOf!RXg!RXh!RX!X!RX!b!RX!d!RX!e!RX!f!RX!g!RX#c!RX#d!RX#e!RX#f!RX#g!RX#h!RX#k!RX#r!RXU!RX$R!RX#o!RX~OP!^OQ!_OR!_OS!`OT!`OW!gOX!fOb!aOy!]O#q!dO~O|oO!OoO!UoO!VoOfuaguahua!bua!dua!eua!fua!gua#cua#dua#eua#fua#gua#hua~O!XsO#kua#rua~P)^OftXgtXhtX|tX!btX!dtX!etX!ftX!gtX#ctX#dtX#etX#ftX#gtX#htX~O#r!jO~P*uO#r!kO~P*uO!k!oO#nPO#q!mO~O#q!pO~OYZOiUOjUOkUOlUOmUOnUOoUOpUOqUO#cYO#dYO#nPO#qRO#s^O#t_O#u`O#vaO#wbO#xcO#ydO#zeO#{fO#|gO#}hO$OiO$PjO$QkO~O!k!rO~P,fO#q!sO~O[!vO]!tO^!tOY#]Pi#]Pj#]Pk#]Pl#]Pm#]Pn#]Po#]Pp#]Pq#]P!k#]P#c#]P#d#]P#n#]P#q#]P#s#]P#t#]P#u#]P#v#]P#w#]P#x#]P#y#]P#z#]P#{#]P#|#]P#}#]P$O#]P$P#]P$Q#]P~O{#OO~OylO#p#QO~O#q#RO~Oz#SO|#SO}!UO!O!UO!b#TO!d#TO!e#TO!f#TO!g#TO~Oy#UOf!YXg!YXh!YX|!YX!O!YX!U!YX!V!YX!X!YX!b!YX!d!YX!e!YX!f!YX!g!YX#c!YX#d!YX#e!YX#f!YX#g!YX#h!YX#k!YX#r!YXU!YX$R!YX#o!YX~O{#XO~Oz#YO|#YO!b#YO!d#YO!e#YO!f#YO!g#YO~Of#[Og#]O#o#[Oh!Qa|!Qa!O!Qa!U!Qa!V!Qa!X!Qa!b!Qa!d!Qa!e!Qa!f!Qa!g!Qa#c!Qa#d!Qa#e!Qa#f!Qa#g!Qa#h!Qa#k!Qa#r!QaU!Qa$R!Qa~O{#^O~Oy#_O~OU#eO|oO!OoO!UoO!VoO!X#bO$R#dO~O#r#jO~O#o#kO~Oy#lO#r#nO~O#r#oO~P*uOf#iXg#iXh#iX|#iX!b#iX!d#iX!e#iX!f#iX!g#iX#c#iX#d#iX#e#iX#f#iX#g#iX#h#iX#r#iX~O#o#pO~P6zO!k#rO~P,fO#q#sO~OY#]Xi#]Xj#]Xk#]Xl#]Xm#]Xn#]Xo#]Xp#]Xq#]X!k#]X#c#]X#d#]X#n#]X#q#]X#s#]X#t#]X#u#]X#v#]X#w#]X#x#]X#y#]X#z#]X#{#]X#|#]X#}#]X$O#]X$P#]X$Q#]X~O_#uO`#uO~P8cO]!tO^!tO~P8cO#o#}O~P*uO{$OO~OV$PO{#OO!i$QO!k$RO~Oz$SO~O#o$TOf![Xg![Xh![X|![X!O![X!U![X!V![X!X![X!b![X!d![X!e![X!f![X!g![X#c![X#d![X#e![X#f![X#g![X#h![X#k![X#r![XU![X$R![X~O!c$UO~Of#[Og#]O#o#[O#r$VO~Oz$XO~O#o$YOf!mag!mah!ma|!ma!O!ma!U!ma!V!ma!X!ma!b!ma!d!ma!e!ma!f!ma!g!ma#c!ma#d!ma#e!ma#f!ma#g!ma#h!ma#k!ma#r!maU!ma$R!ma~OU$ZO~P(lO!c$^O~O!X$_O~OU#eO|oO!OoO!UoO!VoO!X#bO~OZ$aO#r#Ra~P?jO#r$eO~P5xO#r$cO~OdyOeyOf!qqg!qqh!qq|!qq!b!qq!d!qq!e!qq!f!qq!g!qq#c!qq#d!qq#e!qq#f!qq#g!qq#h!qq#k!qq#r!qq#o!qq~O#o$iO#r$jO~OdyOeyOf#Yqg#Yqh#Yq|#Yq!b#Yq!d#Yq!e#Yq!f#Yq!g#Yq#c#Yq#d#Yq#e#Yq#f#Yq#g#Yq#h#Yq#k#Yq#r#Yq#o#Yq~O#r$kO~P*uO#o$mO~P6zO#b$nO#r$qO~OY#]ai#]aj#]ak#]al#]am#]an#]ao#]ap#]aq#]a!k#]a#c#]a#d#]a#n#]a#s#]a#t#]a#u#]a#v#]a#w#]a#x#]a#y#]a#z#]a#{#]a#|#]a#}#]a$O#]a$P#]a$Q#]a~O#q#sO~PCvO_$sO`$sO#q#]a~PCvOf}Oh}O|!RO!b!RO!d!RO!e!RO!f!RO!g!RO#c!OO#d!OO#e#[q#f#[q#g#[q#h#[q#k#[q#r#[q~Og#[q~PFUOf#[qg#[qh#[q~PF[Og|O~PFUO#k#[q#r#[q~P%TOf#[qg#[qh#[q|#[q!b#[q!d#[q!e#[q!f#[q!g#[q#e#[q#f#[q#g#[q#h#[q~O#c!OO#d!OO#k#[q#r#[q~PHPO{$tO~O#r$uO~O#q$vO~O{$wO~Oy#UO~Of#[O#o#[Og!^ih!^i|!^i!O!^i!U!^i!V!^i!X!^i!b!^i!d!^i!e!^i!f!^i!g!^i#c!^i#d!^i#e!^i#f!^i#g!^i#h!^i#k!^i#r!^iU!^i$R!^i~Oy$yO{$yO~Oa${Ob${Oc${Oy$|O~OZ$aO#r#Ri~O$S%PO~O#r#Ri~P?jO!c%RO~O#r%TO~P5xO#r%TO$R#dO~O#r%VO~Oy%WO~O#r%XO~P*uO#o%ZO#r%[O~O#q#sOY#]ii#]ij#]ik#]il#]im#]in#]io#]ip#]iq#]i!k#]i#c#]i#d#]i#n#]i#s#]i#t#]i#u#]i#v#]i#w#]i#x#]i#y#]i#z#]i#{#]i#|#]i#}#]i$O#]i$P#]i$Q#]i~O#o%^O~O{%_O~O#q%`O~Of#[Og#]O#o#[O$R#Ui#r#Ui~O#r#Rq~P?jOU#eOZ%cO!X%dO#r#Rq~OdyOeyOf!q!Rg!q!Rh!q!R|!q!R!b!q!R!d!q!R!e!q!R!f!q!R!g!q!R#c!q!R#d!q!R#e!q!R#f!q!R#g!q!R#h!q!R#k!q!R#r!q!R#o!q!R~OdyOeyOf#Y!Rg#Y!Rh#Y!R|#Y!R!b#Y!R!d#Y!R!e#Y!R!f#Y!R!g#Y!R#c#Y!R#d#Y!R#e#Y!R#f#Y!R#g#Y!R#h#Y!R#k#Y!R#r#Y!R#o#Y!R~O#r%fO~P*uO#b$nO#r%hO~O{%iO~O#r%jO~Oy%kO~OZ$aO#r#Ry~OU#eO!X%dO!c%RO~OU$ZO~O#o%mO~O#r%nO~O{%pO~O#o%qO~O{%rO~O#r%sO~OP!^OQ!_OR!_OS!`OT!`OW%tOX!fOb!aOy!]O#q!dO~O!X%uO#oua~P)^O!X%uO#ouX~P#[Of&POh&PO|&TO!b&TO!d&TO!e&TO!f&TO!g&TO#c&QO#d&QO#e#[q#f#[q#g#[q#h#[q#o#[q~Og#[q~P!(QOf#[qg#[qh#[q~P!(WOg&OO~P!(QOf&POg&OOh&PO|&TO!b&TO!d&TO!e&TO!f&TO!g&TO#c&QO#d&QO#e&RO#f&RO#g&RO#h&SO~O#o#[q~P!)nO#c&QO#d&QO#o#[q~PHPO",
  goto: "/Y#kPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP#l$k%S%r%uPPPPPP&U&h&x'W'iPP'xP'{'{(Q(T(Z(l(l(uPPPPPP(uP(lP'{'{)O)U)]*O*e*z*z*z*z*z*z*z*z*z*z*z*z*z*z+a+j+},Z,s,v-V*O-Y*O-o.e.v/P/SPPPPPPP*O*O[WORz!s#p$mQ#w!wQ#x!xS#y!y%zQ#z!zQ#{!{Q#|!|Q&U%xQ&V%yQ&W%{Q&X%|Q&Y%}R&Z!Tt]Oz!T!s!w!x!y!z!{!|#p$m%x%y%z%{%|%}RvRjQORz!T!s!w!x!y!z!{!|#p$mS!lx#kQ#h!m]%w%x%y%z%{%|%}RnPQmP^!cs!d#[#]#b$_%uR#P!VQuQQ#c!lQ$`#fQ$d#hQ%S$bR%v%w[tQ!l#f#h$b%w]!iu#c$`$d%S%virQu!l#c#f#h$`$b$d%S%v%whqQu!l#c#f#h$`$b$d%S%v%wR![qkpQqu!l#c#f#h$`$b$d%S%v%wR!ZpV!hs#b%uR#W!^Q#V!^R$x$TU!es#b%uQ#Z!dQ$V#[Q$W#]R%Q$__!cs!d#[#]#b$_%u_!bs!d#[#]#b$_%uQ#a!gR%o%tS#`!g%tR$z$Yj]O!w!x!y!z!{!|%x%y%z%{%|%}QwRQ!qzQ!}!TQ#q!sQ$l#pR%Y$mw[ORz!T!s!w!x!y!z!{!|#p$m%x%y%z%{%|%}wTORz!T!s!w!x!y!z!{!|#p$m%x%y%z%{%|%}wSORz!T!s!w!x!y!z!{!|#p$m%x%y%z%{%|%}Q!nxQ#i!mR$h#kS#f!l#hW$[#c#g$d$fQ%O$]Q%U$eR%b%TQ$b#fQ%O$[Q%a%UR%l%bQ#g!lS$]#c$dQ$c#fQ$f#hS%O$`$bS%a%S%UR%l%cR$}$ZQ{VQ$g#jQ$k#oQ%e%VR%f%XR#m!pwVORz!T!s!w!x!y!z!{!|#p$m%x%y%z%{%|%}Q!w|Q!x}Q!y!OQ!z!PQ!{!QQ!|!RQ%x&OQ%y&PQ%z&QQ%{&RQ%|&SR%}&Th!u|}!O!P!Q!R&O&P&Q&R&S&TR#v!vQ#t!tQ$r#uR%]$sR$o#sQ$p#sR%g%Z",
  nodeNames: "⚠ Json Logfmt Unpack Pattern Regexp Unwrap Ip LabelFormat LineFormat LabelReplace Offset Bool On Ignoring GroupLeft GroupRight BytesConv DurationConv DurationSecondsConv By Without And Or Unless Sum Avg Count Max Min Stddev Stdvar Bottomk Topk LineComment LogQL Expr LogExpr Selector Matchers Matcher Identifier Eq String Neq Re Nre PipelineExpr PipelineStage LineFilters LineFilter Filter PipeExact PipeMatch FilterOp Pipe LabelParser JsonExpressionParser JsonExpressionList JsonExpression LabelFilter IpLabelFilter UnitFilter DurationFilter Gtr Duration Gte Lss Lte Eql BytesFilter Bytes NumberFilter Number LineFormatExpr LabelFormatExpr LabelsFormat LabelFormatMatcher MetricExpr RangeAggregationExpr RangeOp CountOverTime Rate BytesOverTime BytesRate AvgOverTime SumOverTime MinOverTime MaxOverTime StddevOverTime StdvarOverTime QuantileOverTime FirstOverTime LastOverTime AbsentOverTime LogRangeExpr Range OffsetExpr UnwrapExpr ConvOp Grouping Labels VectorAggregationExpr VectorOp BinOpExpr BinOpModifier OnOrIgnoringModifier GroupingLabels GroupingLabelList GroupingLabel LabelName Add Sub Mul Div Mod Pow LiteralExpr LabelReplaceExpr",
  maxTerm: 142,
  skippedNodes: [0,34],
  repeatNodeCount: 0,
  tokenData: "3{~RwX^#lpq#lqr$ars$tst%huv%swx%xxy&gyz&lz{&q{|&v|}&{}!O'Q!O!P'V!P!Q(V!Q!R([!R![)r![!]0r!^!_1W!_!`1e!`!a1z!c!}2X!}#O2o#P#Q2t#Q#R2y#R#S2X#S#T3O#T#o2X#o#p3[#p#q3a#q#r3v#y#z#l$f$g#l#BY#BZ#l$IS$I_#l$I|$JO#l$JT$JU#l$KV$KW#l&FU&FV#l~#qY#m~X^#lpq#l#y#z#l$f$g#l#BY#BZ#l$IS$I_#l$I|$JO#l$JT$JU#l$KV$KW#l&FU&FV#l~$dQ!_!`$j#r#s$o~$oO|~~$tO!O~~$yU{~OY$tZr$trs%]s#O$t#O#P%b#P~$t~%bO{~~%ePO~$t~%mQr~OY%hZ~%h~%xO#g~~%}U{~OY%xZw%xwx%]x#O%x#O#P&a#P~%x~&dPO~%x~&lO#q~~&qO#r~~&vO#e~~&{O#c~~'QO#o~~'VO#d~~'YP!Q![']~'bR!k~!Q![']!g!h'k#X#Y'k~'nR{|'w}!O'w!Q!['}~'zP!Q!['}~(SP!k~!Q!['}~([O#f~~(ae!k~!O!P']!Q![)r!g!h+V!i!j+t!m!n+t!o!p+t!r!s+t!v!w+t#U#V+i#W#X+}#X#Y.P#Z#[.c#[#],f#_#`.c#a#b.l#d#e.c#g#h-n#h#i.c#k#l.}#l#m0W#m#n/i~)wd!k~!O!P']!Q![)r!g!h+V!i!j+t!m!n+t!o!p+t!r!s+t!v!w+t#U#V+i#W#X+}#X#Y.P#Z#[.c#[#],f#_#`.c#a#b.l#d#e.c#g#h-n#h#i.c#k#l.}#m#n/i~+YT{|'w}!O'w!Q!['}!d!e+i#]#^+n~+nO!i~~+qP#U#V+i~+wQ!d!e+i#]#^+n~,SP!c~!Q![,V~,YS!Q![,V#[#],f#a#b,z#g#h-n~,kP!c~!Q![,n~,qR!Q![,n#a#b,z#g#h-n~-PQ!c~!Q![-V#g#h-i~-YR!Q![-V#a#b-c#g#h-n~-fP#g#h-i~-nO!c~~-sP!c~!Q![-v~-yQ!Q![-v#a#b-c~.ST{|'w}!O'w!Q!['}#U#V+i#]#^+n~.fQ#U#V+i#]#^+n~.qS!c~!Q![-V#U#V+i#]#^+n#g#h-i~/SP!c~!Q![/V~/YT!Q![/V#W#X+}#[#],f#a#b,z#g#h-n~/nP!c~!Q![/q~/tU!Q![/q#W#X+}#[#],f#a#b,z#g#h-n#k#l.}~0ZR!Q![0d!c!i0d#T#Z0d~0iR!k~!Q![0d!c!i0d#T#Z0dP0wTyP!Q![0r![!]0r!c!}0r#R#S0r#T#o0r~1]P!e~!_!`1`~1eO!f~~1jQz~!_!`1p#r#s1u~1uO!g~~1zO}~~2PP!b~!_!`2S~2XO!d~R2`TyP#bQ!Q![2X![!]0r!c!}2X#R#S2X#T#o2X~2tO$R~~2yO$S~~3OO#h~~3RRO#S3O#S#T%]#T~3O~3aO#n~~3fQ!X~!_!`3l#r#s3q~3qO!U~~3vO!V~~3{O#p~",
  tokenizers: [0, 1],
  topRules: {"LogQL":[0,35]},
  specialized: [{term: 41, get: (value, stack) => (specializeIdentifier(value) << 1)},{term: 41, get: (value, stack) => (extendIdentifier(value) << 1) | 1},{term: 41, get: value => spec_Identifier[value] || -1}],
  tokenPrec: 0
});
// This file was generated by lezer-generator. You probably shouldn't edit it.
const Json = 1,
  Logfmt = 2,
  Unpack = 3,
  Pattern = 4,
  Regexp = 5,
  Unwrap = 6,
  Ip = 7,
  LabelFormat = 8,
  LineFormat = 9,
  LabelReplace = 10,
  Offset = 11,
  Bool = 12,
  On = 13,
  Ignoring = 14,
  GroupLeft = 15,
  GroupRight = 16,
  BytesConv = 17,
  DurationConv = 18,
  DurationSecondsConv = 19,
  By = 20,
  Without = 21,
  And = 22,
  Or = 23,
  Unless = 24,
  Sum = 25,
  Avg = 26,
  Count = 27,
  Max = 28,
  Min = 29,
  Stddev = 30,
  Stdvar = 31,
  Bottomk = 32,
  Topk = 33,
  LineComment = 34,
  LogQL = 35,
  Expr = 36,
  LogExpr = 37,
  Selector = 38,
  Matchers = 39,
  Matcher = 40,
  Identifier = 41,
  Eq = 42,
  String = 43,
  Neq = 44,
  Re = 45,
  Nre = 46,
  PipelineExpr = 47,
  PipelineStage = 48,
  LineFilters = 49,
  LineFilter = 50,
  Filter = 51,
  PipeExact = 52,
  PipeMatch = 53,
  FilterOp = 54,
  Pipe = 55,
  LabelParser = 56,
  JsonExpressionParser = 57,
  JsonExpressionList = 58,
  JsonExpression = 59,
  LabelFilter = 60,
  IpLabelFilter = 61,
  UnitFilter = 62,
  DurationFilter = 63,
  Gtr = 64,
  Duration = 65,
  Gte = 66,
  Lss = 67,
  Lte = 68,
  Eql = 69,
  BytesFilter = 70,
  Bytes = 71,
  NumberFilter = 72,
  Number = 73,
  LineFormatExpr = 74,
  LabelFormatExpr = 75,
  LabelsFormat = 76,
  LabelFormatMatcher = 77,
  MetricExpr = 78,
  RangeAggregationExpr = 79,
  RangeOp = 80,
  CountOverTime = 81,
  Rate = 82,
  BytesOverTime = 83,
  BytesRate = 84,
  AvgOverTime = 85,
  SumOverTime = 86,
  MinOverTime = 87,
  MaxOverTime = 88,
  StddevOverTime = 89,
  StdvarOverTime = 90,
  QuantileOverTime = 91,
  FirstOverTime = 92,
  LastOverTime = 93,
  AbsentOverTime = 94,
  LogRangeExpr = 95,
  Range = 96,
  OffsetExpr = 97,
  UnwrapExpr = 98,
  ConvOp = 99,
  Grouping = 100,
  Labels = 101,
  VectorAggregationExpr = 102,
  VectorOp = 103,
  BinOpExpr = 104,
  BinOpModifier = 105,
  OnOrIgnoringModifier = 106,
  GroupingLabels = 107,
  GroupingLabelList = 108,
  GroupingLabel = 109,
  LabelName = 110,
  Add = 111,
  Sub = 112,
  Mul = 113,
  Div = 114,
  Mod = 115,
  Pow = 116,
  LiteralExpr = 117,
  LabelReplaceExpr = 118;




/***/ }),

/***/ "./.yarn/__virtual__/lezer-promql-virtual-eaf88aa77a/0/cache/lezer-promql-npm-0.22.0-867da6afaa-cdce054700.zip/node_modules/lezer-promql/index.es.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Abs": () => (/* binding */ Abs),
/* harmony export */   "Absent": () => (/* binding */ Absent),
/* harmony export */   "AbsentOverTime": () => (/* binding */ AbsentOverTime),
/* harmony export */   "Acos": () => (/* binding */ Acos),
/* harmony export */   "Acosh": () => (/* binding */ Acosh),
/* harmony export */   "Add": () => (/* binding */ Add),
/* harmony export */   "AggregateExpr": () => (/* binding */ AggregateExpr),
/* harmony export */   "AggregateModifier": () => (/* binding */ AggregateModifier),
/* harmony export */   "AggregateOp": () => (/* binding */ AggregateOp),
/* harmony export */   "And": () => (/* binding */ And$1),
/* harmony export */   "Asin": () => (/* binding */ Asin),
/* harmony export */   "Asinh": () => (/* binding */ Asinh),
/* harmony export */   "At": () => (/* binding */ At),
/* harmony export */   "AtModifierPreprocessors": () => (/* binding */ AtModifierPreprocessors),
/* harmony export */   "Atan": () => (/* binding */ Atan),
/* harmony export */   "Atan2": () => (/* binding */ Atan2$1),
/* harmony export */   "Atanh": () => (/* binding */ Atanh),
/* harmony export */   "Avg": () => (/* binding */ Avg$1),
/* harmony export */   "AvgOverTime": () => (/* binding */ AvgOverTime),
/* harmony export */   "BinModifiers": () => (/* binding */ BinModifiers),
/* harmony export */   "BinaryExpr": () => (/* binding */ BinaryExpr),
/* harmony export */   "Bool": () => (/* binding */ Bool$1),
/* harmony export */   "Bottomk": () => (/* binding */ Bottomk$1),
/* harmony export */   "By": () => (/* binding */ By$1),
/* harmony export */   "Ceil": () => (/* binding */ Ceil),
/* harmony export */   "Changes": () => (/* binding */ Changes),
/* harmony export */   "Clamp": () => (/* binding */ Clamp),
/* harmony export */   "ClampMax": () => (/* binding */ ClampMax),
/* harmony export */   "ClampMin": () => (/* binding */ ClampMin),
/* harmony export */   "Cos": () => (/* binding */ Cos),
/* harmony export */   "Cosh": () => (/* binding */ Cosh),
/* harmony export */   "Count": () => (/* binding */ Count$1),
/* harmony export */   "CountOverTime": () => (/* binding */ CountOverTime),
/* harmony export */   "CountValues": () => (/* binding */ CountValues$1),
/* harmony export */   "DayOfMonth": () => (/* binding */ DayOfMonth),
/* harmony export */   "DayOfWeek": () => (/* binding */ DayOfWeek),
/* harmony export */   "DaysInMonth": () => (/* binding */ DaysInMonth),
/* harmony export */   "Deg": () => (/* binding */ Deg),
/* harmony export */   "Delta": () => (/* binding */ Delta),
/* harmony export */   "Deriv": () => (/* binding */ Deriv),
/* harmony export */   "Div": () => (/* binding */ Div),
/* harmony export */   "Duration": () => (/* binding */ Duration),
/* harmony export */   "End": () => (/* binding */ End$1),
/* harmony export */   "Eql": () => (/* binding */ Eql),
/* harmony export */   "EqlRegex": () => (/* binding */ EqlRegex),
/* harmony export */   "EqlSingle": () => (/* binding */ EqlSingle),
/* harmony export */   "Exp": () => (/* binding */ Exp),
/* harmony export */   "Expr": () => (/* binding */ Expr),
/* harmony export */   "Floor": () => (/* binding */ Floor),
/* harmony export */   "FunctionCall": () => (/* binding */ FunctionCall),
/* harmony export */   "FunctionCallArgs": () => (/* binding */ FunctionCallArgs),
/* harmony export */   "FunctionCallBody": () => (/* binding */ FunctionCallBody),
/* harmony export */   "FunctionIdentifier": () => (/* binding */ FunctionIdentifier),
/* harmony export */   "Group": () => (/* binding */ Group$1),
/* harmony export */   "GroupLeft": () => (/* binding */ GroupLeft$1),
/* harmony export */   "GroupRight": () => (/* binding */ GroupRight$1),
/* harmony export */   "GroupingLabel": () => (/* binding */ GroupingLabel),
/* harmony export */   "GroupingLabelList": () => (/* binding */ GroupingLabelList),
/* harmony export */   "GroupingLabels": () => (/* binding */ GroupingLabels),
/* harmony export */   "Gte": () => (/* binding */ Gte),
/* harmony export */   "Gtr": () => (/* binding */ Gtr),
/* harmony export */   "HistogramQuantile": () => (/* binding */ HistogramQuantile),
/* harmony export */   "HoltWinters": () => (/* binding */ HoltWinters),
/* harmony export */   "Hour": () => (/* binding */ Hour),
/* harmony export */   "Idelta": () => (/* binding */ Idelta),
/* harmony export */   "Identifier": () => (/* binding */ Identifier),
/* harmony export */   "Ignoring": () => (/* binding */ Ignoring$1),
/* harmony export */   "Increase": () => (/* binding */ Increase),
/* harmony export */   "Irate": () => (/* binding */ Irate),
/* harmony export */   "LabelJoin": () => (/* binding */ LabelJoin),
/* harmony export */   "LabelMatchList": () => (/* binding */ LabelMatchList),
/* harmony export */   "LabelMatcher": () => (/* binding */ LabelMatcher),
/* harmony export */   "LabelMatchers": () => (/* binding */ LabelMatchers),
/* harmony export */   "LabelName": () => (/* binding */ LabelName),
/* harmony export */   "LabelReplace": () => (/* binding */ LabelReplace),
/* harmony export */   "LastOverTime": () => (/* binding */ LastOverTime),
/* harmony export */   "LineComment": () => (/* binding */ LineComment),
/* harmony export */   "Ln": () => (/* binding */ Ln),
/* harmony export */   "Log10": () => (/* binding */ Log10),
/* harmony export */   "Log2": () => (/* binding */ Log2),
/* harmony export */   "Lss": () => (/* binding */ Lss),
/* harmony export */   "Lte": () => (/* binding */ Lte),
/* harmony export */   "MatchOp": () => (/* binding */ MatchOp),
/* harmony export */   "MatrixSelector": () => (/* binding */ MatrixSelector),
/* harmony export */   "Max": () => (/* binding */ Max$1),
/* harmony export */   "MaxOverTime": () => (/* binding */ MaxOverTime),
/* harmony export */   "MetricIdentifier": () => (/* binding */ MetricIdentifier),
/* harmony export */   "MetricName": () => (/* binding */ MetricName),
/* harmony export */   "Min": () => (/* binding */ Min$1),
/* harmony export */   "MinOverTime": () => (/* binding */ MinOverTime),
/* harmony export */   "Minute": () => (/* binding */ Minute),
/* harmony export */   "Mod": () => (/* binding */ Mod),
/* harmony export */   "Month": () => (/* binding */ Month),
/* harmony export */   "Mul": () => (/* binding */ Mul),
/* harmony export */   "Neq": () => (/* binding */ Neq),
/* harmony export */   "NeqRegex": () => (/* binding */ NeqRegex),
/* harmony export */   "NumberLiteral": () => (/* binding */ NumberLiteral),
/* harmony export */   "Offset": () => (/* binding */ Offset$1),
/* harmony export */   "OffsetExpr": () => (/* binding */ OffsetExpr),
/* harmony export */   "On": () => (/* binding */ On$1),
/* harmony export */   "OnOrIgnoring": () => (/* binding */ OnOrIgnoring),
/* harmony export */   "Or": () => (/* binding */ Or$1),
/* harmony export */   "ParenExpr": () => (/* binding */ ParenExpr),
/* harmony export */   "Pi": () => (/* binding */ Pi),
/* harmony export */   "Pow": () => (/* binding */ Pow),
/* harmony export */   "PredictLinear": () => (/* binding */ PredictLinear),
/* harmony export */   "PresentOverTime": () => (/* binding */ PresentOverTime),
/* harmony export */   "PromQL": () => (/* binding */ PromQL),
/* harmony export */   "Quantile": () => (/* binding */ Quantile$1),
/* harmony export */   "QuantileOverTime": () => (/* binding */ QuantileOverTime),
/* harmony export */   "Rad": () => (/* binding */ Rad),
/* harmony export */   "Rate": () => (/* binding */ Rate),
/* harmony export */   "Resets": () => (/* binding */ Resets),
/* harmony export */   "Round": () => (/* binding */ Round),
/* harmony export */   "Scalar": () => (/* binding */ Scalar),
/* harmony export */   "Sgn": () => (/* binding */ Sgn),
/* harmony export */   "Sin": () => (/* binding */ Sin),
/* harmony export */   "Sinh": () => (/* binding */ Sinh),
/* harmony export */   "Sort": () => (/* binding */ Sort),
/* harmony export */   "SortDesc": () => (/* binding */ SortDesc),
/* harmony export */   "Sqrt": () => (/* binding */ Sqrt),
/* harmony export */   "Start": () => (/* binding */ Start$1),
/* harmony export */   "Stddev": () => (/* binding */ Stddev$1),
/* harmony export */   "StddevOverTime": () => (/* binding */ StddevOverTime),
/* harmony export */   "Stdvar": () => (/* binding */ Stdvar$1),
/* harmony export */   "StdvarOverTime": () => (/* binding */ StdvarOverTime),
/* harmony export */   "StepInvariantExpr": () => (/* binding */ StepInvariantExpr),
/* harmony export */   "StringLiteral": () => (/* binding */ StringLiteral),
/* harmony export */   "Sub": () => (/* binding */ Sub),
/* harmony export */   "SubqueryExpr": () => (/* binding */ SubqueryExpr),
/* harmony export */   "Sum": () => (/* binding */ Sum$1),
/* harmony export */   "SumOverTime": () => (/* binding */ SumOverTime),
/* harmony export */   "Tan": () => (/* binding */ Tan),
/* harmony export */   "Tanh": () => (/* binding */ Tanh),
/* harmony export */   "Time": () => (/* binding */ Time),
/* harmony export */   "Timestamp": () => (/* binding */ Timestamp),
/* harmony export */   "Topk": () => (/* binding */ Topk$1),
/* harmony export */   "UnaryExpr": () => (/* binding */ UnaryExpr),
/* harmony export */   "UnaryOp": () => (/* binding */ UnaryOp),
/* harmony export */   "Unless": () => (/* binding */ Unless$1),
/* harmony export */   "Vector": () => (/* binding */ Vector),
/* harmony export */   "VectorSelector": () => (/* binding */ VectorSelector),
/* harmony export */   "Without": () => (/* binding */ Without$1),
/* harmony export */   "Year": () => (/* binding */ Year),
/* harmony export */   "inf": () => (/* binding */ inf$1),
/* harmony export */   "nan": () => (/* binding */ nan$1),
/* harmony export */   "parser": () => (/* binding */ parser)
/* harmony export */ });
/* harmony import */ var _lezer_lr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@lezer-lr-npm-0.15.8-8c481c39cd-e741225d6a.zip/node_modules/@lezer/lr/dist/index.js");


// This file was generated by lezer-generator. You probably shouldn't edit it.
const 
  inf = 146,
  nan = 147,
  Bool = 1,
  Ignoring = 2,
  On = 3,
  GroupLeft = 4,
  GroupRight = 5,
  Offset = 6,
  Atan2 = 7,
  Avg = 8,
  Bottomk = 9,
  Count = 10,
  CountValues = 11,
  Group = 12,
  Max = 13,
  Min = 14,
  Quantile = 15,
  Stddev = 16,
  Stdvar = 17,
  Sum = 18,
  Topk = 19,
  By = 20,
  Without = 21,
  And = 22,
  Or = 23,
  Unless = 24,
  Start = 25,
  End = 26;

// Copyright 2021 The Prometheus Authors

const keywordTokens = {
    inf: inf,
    nan: nan,
    bool: Bool,
    ignoring: Ignoring,
    on: On,
    group_left: GroupLeft,
    group_right: GroupRight,
    offset: Offset,
};

const specializeIdentifier = (value, stack) => {
    return keywordTokens[value.toLowerCase()] || -1;
};

const contextualKeywordTokens = {
    avg: Avg,
    atan2: Atan2,
    bottomk: Bottomk,
    count: Count,
    count_values: CountValues,
    group: Group,
    max: Max,
    min: Min,
    quantile: Quantile,
    stddev: Stddev,
    stdvar: Stdvar,
    sum: Sum,
    topk: Topk,
    by: By,
    without: Without,
    and: And,
    or: Or,
    unless: Unless,
    start: Start,
    end: End,
};

const extendIdentifier = (value, stack) => {
    return contextualKeywordTokens[value.toLowerCase()] || -1;
};

// This file was generated by lezer-generator. You probably shouldn't edit it.
const spec_Identifier = {__proto__:null,absent_over_time:307, absent:309, abs:311, acos:313, acosh:315, asin:317, asinh:319, atan:321, atanh:323, avg_over_time:325, ceil:327, changes:329, clamp:331, clamp_max:333, clamp_min:335, cos:337, cosh:339, count_over_time:341, days_in_month:343, day_of_month:345, day_of_week:347, deg:349, delta:351, deriv:353, exp:355, floor:357, histogram_quantile:359, holt_winters:361, hour:363, idelta:365, increase:367, irate:369, label_replace:371, label_join:373, last_over_time:375, ln:377, log10:379, log2:381, max_over_time:383, min_over_time:385, minute:387, month:389, pi:391, predict_linear:393, present_over_time:395, quantile_over_time:397, rad:399, rate:401, resets:403, round:405, scalar:407, sgn:409, sin:411, sinh:413, sort:415, sort_desc:417, sqrt:419, stddev_over_time:421, stdvar_over_time:423, sum_over_time:425, tan:427, tanh:429, timestamp:431, time:433, vector:435, year:437};
const parser = _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.LRParser.deserialize({
  version: 13,
  states: "6[OYQPOOO&{QPOOOOQO'#C{'#C{O'QQPO'#CzQ']QQOOOOQO'#De'#DeO'WQPO'#DdOOQO'#E}'#E}O(jQPO'#FTOYQPO'#FPOYQPO'#FSOOQO'#FV'#FVO.fQSO'#FWO.nQQO'#FUOOQO'#FU'#FUOOQO'#Cy'#CyOOQO'#Df'#DfOOQO'#Dh'#DhOOQO'#Di'#DiOOQO'#Dj'#DjOOQO'#Dk'#DkOOQO'#Dl'#DlOOQO'#Dm'#DmOOQO'#Dn'#DnOOQO'#Do'#DoOOQO'#Dp'#DpOOQO'#Dq'#DqOOQO'#Dr'#DrOOQO'#Ds'#DsOOQO'#Dt'#DtOOQO'#Du'#DuOOQO'#Dv'#DvOOQO'#Dw'#DwOOQO'#Dx'#DxOOQO'#Dy'#DyOOQO'#Dz'#DzOOQO'#D{'#D{OOQO'#D|'#D|OOQO'#D}'#D}OOQO'#EO'#EOOOQO'#EP'#EPOOQO'#EQ'#EQOOQO'#ER'#EROOQO'#ES'#ESOOQO'#ET'#ETOOQO'#EU'#EUOOQO'#EV'#EVOOQO'#EW'#EWOOQO'#EX'#EXOOQO'#EY'#EYOOQO'#EZ'#EZOOQO'#E['#E[OOQO'#E]'#E]OOQO'#E^'#E^OOQO'#E_'#E_OOQO'#E`'#E`OOQO'#Ea'#EaOOQO'#Eb'#EbOOQO'#Ec'#EcOOQO'#Ed'#EdOOQO'#Ee'#EeOOQO'#Ef'#EfOOQO'#Eg'#EgOOQO'#Eh'#EhOOQO'#Ei'#EiOOQO'#Ej'#EjOOQO'#Ek'#EkOOQO'#El'#ElOOQO'#Em'#EmOOQO'#En'#EnOOQO'#Eo'#EoOOQO'#Ep'#EpOOQO'#Eq'#EqOOQO'#Er'#ErOOQO'#Es'#EsOOQO'#Et'#EtOOQO'#Eu'#EuOOQO'#Ev'#EvOOQO'#Ew'#EwOOQO'#Ex'#ExOOQO'#Ey'#EyOOQO'#Ez'#EzQOQPOOO0XQPO'#C|O0^QPO'#DRO'WQPO,59fO0eQQO,59fO2RQPO,59oO2RQPO,59oO2RQPO,59oO2RQPO,59oO2RQPO,59oO7}QQO,5;gO8SQQO,5;jO8[QPO,5;yOOQO,5:O,5:OOOQO,5;i,5;iO8sQQO,5;kO8zQQO,5;nO:bQPO'#FYO:pQPO,5;rOOQO'#FX'#FXOOQO,5;r,5;rOOQO,5;p,5;pO:xQSO'#C}OOQO,59h,59hO;QQPO,59mO;YQQO'#DSOOQO,59m,59mOOQO1G/Q1G/QO0XQPO'#DWOAVQPO'#DVOAaQPO'#DVOYQPO1G/ZOYQPO1G/ZOYQPO1G/ZOYQPO1G/ZOYQPO1G/ZOAkQSO1G1ROOQO1G1U1G1UOAsQQO1G1UOAxQPO'#E}OOQO'#Fa'#FaOOQO1G1e1G1eOBTQPO1G1eOOQO1G1V1G1VOOQO'#FZ'#FZOBYQPO,5;tOB_QSO1G1^OOQO1G1^1G1^OOQO'#DP'#DPOBgQPO,59iOOQO'#DO'#DOOOQO,59i,59iOYQPO,59nOOQO1G/X1G/XOOQO,59r,59rOH_QPO,59qOHfQPO,59qOI}QQO7+$uOJ_QQO7+$uOKsQQO7+$uOLZQQO7+$uOMrQQO7+$uOOQO7+&m7+&mON]QQO7+&sOOQO7+&p7+&pONeQPO7+'POOQO1G1`1G1`OOQO1G1_1G1_OOQO7+&x7+&xONjQSO1G/TOOQO1G/T1G/TONrQQO1G/YOOQO1G/]1G/]ON|QPO1G/]OOQO<<J_<<J_O!&oQPO<<J_OOQO<<Jk<<JkOOQO1G/U1G/UOOQO7+$o7+$oOOQO7+$w7+$wOOQOAN?yAN?y",
  stateData: "!&t~O$ZOSkOS~OWQOXQOYQOZQO[QO]QO^QO_QO`QOaQObQOcQO!ZZO#t_O$WVO$XVO$[XO$_`O$`aO$abO$bcO$cdO$deO$efO$fgO$ghO$hiO$ijO$jkO$klO$lmO$mnO$noO$opO$pqO$qrO$rsO$stO$tuO$uvO$vwO$wxO$xyO$yzO$z{O${|O$|}O$}!OO%O!PO%P!QO%Q!RO%R!SO%S!TO%T!UO%U!VO%V!WO%W!XO%X!YO%Y!ZO%Z![O%[!]O%]!^O%^!_O%_!`O%`!aO%a!bO%b!cO%c!dO%d!eO%e!fO%f!gO%g!hO%h!iO%i!jO%j!kO%k!lO%l!mO%m!nO%n!oO%o!pO%p!qO%q!rO%r!sO%uWO%vWO%wVO%y[O~O!ZZO~Od!uOe!uO$[!vO~OU#POV!yOf!|Og!}Oh!|Ox!yO{!yO|!yO}!yO!O!zO!P!zO!Q!{O!R!{O!S!{O!T!{O!U!{O!V!{O$S#QO%s#OO~O$W#SO$X#SO%w#SOW#wXX#wXY#wXZ#wX[#wX]#wX^#wX_#wX`#wXa#wXb#wXc#wX!Z#wX#t#wX$W#wX$X#wX$[#wX$_#wX$`#wX$a#wX$b#wX$c#wX$d#wX$e#wX$f#wX$g#wX$h#wX$i#wX$j#wX$k#wX$l#wX$m#wX$n#wX$o#wX$p#wX$q#wX$r#wX$s#wX$t#wX$u#wX$v#wX$w#wX$x#wX$y#wX$z#wX${#wX$|#wX$}#wX%O#wX%P#wX%Q#wX%R#wX%S#wX%T#wX%U#wX%V#wX%W#wX%X#wX%Y#wX%Z#wX%[#wX%]#wX%^#wX%_#wX%`#wX%a#wX%b#wX%c#wX%d#wX%e#wX%f#wX%g#wX%h#wX%i#wX%j#wX%k#wX%l#wX%m#wX%n#wX%o#wX%p#wX%q#wX%r#wX%u#wX%v#wX%w#wX%y#wX~Ot#VO%z#YO~O%y[OU#xXV#xXf#xXg#xXh#xXx#xX{#xX|#xX}#xX!O#xX!P#xX!Q#xX!R#xX!S#xX!T#xX!U#xX!V#xX$S#xX$V#xX%s#xX$^#xX$]#xX~O$[#[O~O$^#`O~PYOd!uOe!uOUnaVnafnagnahnaxna{na|na}na!Ona!Pna!Qna!Rna!Sna!Tna!Una!Vna$Sna$Vna%sna$^na$]na~OP#dOQ#bOR#bOWyPXyPYyPZyP[yP]yP^yP_yP`yPayPbyPcyP!ZyP#tyP$WyP$XyP$[yP$_yP$`yP$ayP$byP$cyP$dyP$eyP$fyP$gyP$hyP$iyP$jyP$kyP$lyP$myP$nyP$oyP$pyP$qyP$ryP$syP$tyP$uyP$vyP$wyP$xyP$yyP$zyP${yP$|yP$}yP%OyP%PyP%QyP%RyP%SyP%TyP%UyP%VyP%WyP%XyP%YyP%ZyP%[yP%]yP%^yP%_yP%`yP%ayP%byP%cyP%dyP%eyP%fyP%gyP%hyP%iyP%jyP%kyP%lyP%myP%nyP%oyP%pyP%qyP%ryP%uyP%vyP%wyP%yyP~O#p#jO~O!P#lO#p#kO~Oi#nOj#nO$WVO$XVO%u#mO%v#mO%wVO~O$^#qO~P']Ox!yOU#vaV#vaf#vag#vah#va{#va|#va}#va!O#va!P#va!Q#va!R#va!S#va!T#va!U#va!V#va$S#va$V#va%s#va$^#va$]#va~O!V#rO$O#rO$P#rO$Q#rO~O$]#tO%z#uO~Ot#vO$^#yO~O$]#zO$^#{O~O$]vX$^vX~P']OWyXXyXYyXZyX[yX]yX^yX_yX`yXayXbyXcyX!ZyX#tyX$WyX$XyX$[yX$_yX$`yX$ayX$byX$cyX$dyX$eyX$fyX$gyX$hyX$iyX$jyX$kyX$lyX$myX$nyX$oyX$pyX$qyX$ryX$syX$tyX$uyX$vyX$wyX$xyX$yyX$zyX${yX$|yX$}yX%OyX%PyX%QyX%RyX%SyX%TyX%UyX%VyX%WyX%XyX%YyX%ZyX%[yX%]yX%^yX%_yX%`yX%ayX%byX%cyX%dyX%eyX%fyX%gyX%hyX%iyX%jyX%kyX%lyX%myX%nyX%oyX%pyX%qyX%ryX%uyX%vyX%wyX%yyX~OS#}OT#}O~P;dOQ#bOR#bO~P;dO%t$UO%x$VO~O#p$WO~O$W#SO$X#SO%w#SO~O$[$XO~O#t$YO~Ot#VO%z$[O~O$]$]O$^$^O~OWyaXyaYyaZya[ya]ya^ya_ya`yaayabyacya!Zya#tya$Wya$Xya$_ya$`ya$aya$bya$cya$dya$eya$fya$gya$hya$iya$jya$kya$lya$mya$nya$oya$pya$qya$rya$sya$tya$uya$vya$wya$xya$yya$zya${ya$|ya$}ya%Oya%Pya%Qya%Rya%Sya%Tya%Uya%Vya%Wya%Xya%Yya%Zya%[ya%]ya%^ya%_ya%`ya%aya%bya%cya%dya%eya%fya%gya%hya%iya%jya%kya%lya%mya%nya%oya%pya%qya%rya%uya%vya%wya%yya~O$[#[O~PBoOS$aOT$aO$[ya~PBoOx!yOUwqfwqgwqhwq!Owq!Pwq!Qwq!Rwq!Swq!Twq!Uwq!Vwq$Swq$Vwq%swq$^wq$]wq~OVwq{wq|wq}wq~PHsOV!yO{!yO|!yO}!yO~PHsOV!yOx!yO{!yO|!yO}!yO!O!zO!P!zOUwqfwqgwqhwq$Swq$Vwq%swq$^wq$]wq~O!Qwq!Rwq!Swq!Twq!Uwq!Vwq~PJoO!Q!{O!R!{O!S!{O!T!{O!U!{O!V!{O~PJoOV!yOf!|Oh!|Ox!yO{!yO|!yO}!yO!O!zO!P!zO!Q!{O!R!{O!S!{O!T!{O!U!{O!V!{O~OUwqgwq$Swq$Vwq%swq$^wq$]wq~PLqO#p$cO%t$bO~O$^$dO~Ot#vO$^$fO~O$]vi$^vi~P']O$[#[OWyiXyiYyiZyi[yi]yi^yi_yi`yiayibyicyi!Zyi#tyi$Wyi$Xyi$_yi$`yi$ayi$byi$cyi$dyi$eyi$fyi$gyi$hyi$iyi$jyi$kyi$lyi$myi$nyi$oyi$pyi$qyi$ryi$syi$tyi$uyi$vyi$wyi$xyi$yyi$zyi${yi$|yi$}yi%Oyi%Pyi%Qyi%Ryi%Syi%Tyi%Uyi%Vyi%Wyi%Xyi%Yyi%Zyi%[yi%]yi%^yi%_yi%`yi%ayi%byi%cyi%dyi%eyi%fyi%gyi%hyi%iyi%jyi%kyi%lyi%myi%nyi%oyi%pyi%qyi%ryi%uyi%vyi%wyi%yyi~O%t$hO~O",
  goto: "(u$UPPPPPPPPPPPPPPPPPPPPPPPPPPPPP$V$u%R%_%e%q%tP%z&T$uP&W&gPPPPPPPPPPP$u&q&}P&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}$uP'Z$u$uP$u$u'j$u'v(V(f(i(oPPP$uP(rQSOQ#TXQ#UYQ#_!vQ$P#eQ$Q#fQ$R#gQ$S#hQ$T#iR$_#ze_OXY!v#e#f#g#h#i#zeROXY!v#e#f#g#h#i#zQ!wRR#a!xQ#]!uQ#|#bQ$`#}R$g$aR#w#[Q#x#[R$e$]Q!xRQ#RUR#a!wR#^!vQ#e!yQ#f!zQ#g!{Q#h!|R#i!}Y#c!y!z!{!|!}R$O#deUOXY!v#e#f#g#h#i#zeTOXY!v#e#f#g#h#i#zd_OXY!v#e#f#g#h#i#zR#o#QeYOXY!v#e#f#g#h#i#zd]OXY!v#e#f#g#h#i#zR!tPd^OXY!v#e#f#g#h#i#zR#Z]R#W[Q#X[R$Z#tR#s#VR#p#Q",
  nodeNames: "⚠ Bool Ignoring On GroupLeft GroupRight Offset Atan2 Avg Bottomk Count CountValues Group Max Min Quantile Stddev Stdvar Sum Topk By Without And Or Unless Start End LineComment PromQL Expr AggregateExpr AggregateOp AggregateModifier GroupingLabels GroupingLabelList GroupingLabel LabelName FunctionCallBody FunctionCallArgs BinaryExpr Pow BinModifiers OnOrIgnoring Mul Div Mod Add Sub Eql Gte Gtr Lte Lss Neq FunctionCall FunctionIdentifier AbsentOverTime Identifier Absent Abs Acos Acosh Asin Asinh Atan Atanh AvgOverTime Ceil Changes Clamp ClampMax ClampMin Cos Cosh CountOverTime DaysInMonth DayOfMonth DayOfWeek Deg Delta Deriv Exp Floor HistogramQuantile HoltWinters Hour Idelta Increase Irate LabelReplace LabelJoin LastOverTime Ln Log10 Log2 MaxOverTime MinOverTime Minute Month Pi PredictLinear PresentOverTime QuantileOverTime Rad Rate Resets Round Scalar Sgn Sin Sinh Sort SortDesc Sqrt StddevOverTime StdvarOverTime SumOverTime Tan Tanh Timestamp Time Vector Year MatrixSelector Duration NumberLiteral OffsetExpr ParenExpr StringLiteral SubqueryExpr UnaryExpr UnaryOp VectorSelector MetricIdentifier LabelMatchers LabelMatchList LabelMatcher MatchOp EqlSingle EqlRegex NeqRegex StepInvariantExpr At AtModifierPreprocessors MetricName",
  maxTerm: 226,
  skippedNodes: [0,27],
  repeatNodeCount: 0,
  tokenData: "1R~RwX^#lpq#lqr$ars$tst%huv%swx%xxy&gyz&lz{&q{|&v|}&}}!O'S!O!P'Z!P!Q(Z!Q!R(`!R![)W![!]-r!^!_.n!_!`.{!`!a/b!b!c/o!c!}/t!}#O0[#P#Q0a#Q#R0f#R#S/t#S#T0k#T#o/t#o#p0w#q#r0|#y#z#l$f$g#l#BY#BZ#l$IS$I_#l$I|$JO#l$JT$JU#l$KV$KW#l&FU&FV#l~#qY$Z~X^#lpq#l#y#z#l$f$g#l#BY#BZ#l$IS$I_#l$I|$JO#l$JT$JU#l$KV$KW#l&FU&FV#l~$dQ!_!`$j#r#s$o~$oO!V~~$tO$Q~~$yU#t~OY$tZr$trs%]s#O$t#O#P%b#P~$t~%bO#t~~%ePO~$t~%mQk~OY%hZ~%h~%xO}~~%}U#t~OY%xZw%xwx%]x#O%x#O#P&a#P~%x~&dPO~%x~&lO$[~~&qO$^~~&vO{~R&}O%vP!OQ~'SO$]~R'ZO%uP!PQP'^P!Q!['aP'fR%wP!Q!['a!g!h'o#X#Y'oP'rR{|'{}!O'{!Q![(RP(OP!Q![(RP(WP%wP!Q![(R~(`O|~R(eZ%wP!O!P'a!Q![)W!g!h'o#W#X){#X#Y'o#[#]*d#a#b*x#g#h+l#k#l+}#l#m-W#m#n,iR)]Y%wP!O!P'a!Q![)W!g!h'o#W#X){#X#Y'o#[#]*d#a#b*x#g#h+l#k#l+}#m#n,iQ*QP#pQ!Q![*TQ*WS!Q![*T#[#]*d#a#b*x#g#h+lQ*iP#pQ!Q![*lQ*oR!Q![*l#a#b*x#g#h+lQ*}Q#pQ!Q![+T#g#h+gQ+WR!Q![+T#a#b+a#g#h+lQ+dP#g#h+gQ+lO#pQQ+qP#pQ!Q![+tQ+wQ!Q![+t#a#b+aQ,SP#pQ!Q![,VQ,YT!Q![,V#W#X){#[#]*d#a#b*x#g#h+lQ,nP#pQ!Q![,qQ,tU!Q![,q#W#X){#[#]*d#a#b*x#g#h+l#k#l+}P-ZR!Q![-d!c!i-d#T#Z-dP-iR%wP!Q![-d!c!i-d#T#Z-dV-yT%xS!ZR!Q![.Y![!].Y!c!}.Y#R#S.Y#T#o.YR._T!ZR!Q![.Y![!].Y!c!}.Y#R#S.Y#T#o.Y~.sP!U~!_!`.v~.{O!T~~/QQ$OP!_!`/W#r#s/]Q/]O!QQ~/bO$P~~/gP!S~!_!`/j~/oO!R~~/tO$S~V/{T!ZRtS!Q![/t![!].Y!c!}/t#R#S/t#T#o/t~0aO%s~~0fO%t~~0kOx~~0nRO#S0k#S#T%]#T~0k~0|O%y~~1RO%z~",
  tokenizers: [0, 1, 2],
  topRules: {"PromQL":[0,28],"MetricName":[1,144]},
  specialized: [{term: 57, get: (value, stack) => (specializeIdentifier(value) << 1)},{term: 57, get: (value, stack) => (extendIdentifier(value) << 1) | 1},{term: 57, get: value => spec_Identifier[value] || -1}],
  tokenPrec: 0
});
// This file was generated by lezer-generator. You probably shouldn't edit it.
const 
  inf$1 = 146,
  nan$1 = 147,
  Bool$1 = 1,
  Ignoring$1 = 2,
  On$1 = 3,
  GroupLeft$1 = 4,
  GroupRight$1 = 5,
  Offset$1 = 6,
  Atan2$1 = 7,
  Avg$1 = 8,
  Bottomk$1 = 9,
  Count$1 = 10,
  CountValues$1 = 11,
  Group$1 = 12,
  Max$1 = 13,
  Min$1 = 14,
  Quantile$1 = 15,
  Stddev$1 = 16,
  Stdvar$1 = 17,
  Sum$1 = 18,
  Topk$1 = 19,
  By$1 = 20,
  Without$1 = 21,
  And$1 = 22,
  Or$1 = 23,
  Unless$1 = 24,
  Start$1 = 25,
  End$1 = 26,
  LineComment = 27,
  PromQL = 28,
  Expr = 29,
  AggregateExpr = 30,
  AggregateOp = 31,
  AggregateModifier = 32,
  GroupingLabels = 33,
  GroupingLabelList = 34,
  GroupingLabel = 35,
  LabelName = 36,
  FunctionCallBody = 37,
  FunctionCallArgs = 38,
  BinaryExpr = 39,
  Pow = 40,
  BinModifiers = 41,
  OnOrIgnoring = 42,
  Mul = 43,
  Div = 44,
  Mod = 45,
  Add = 46,
  Sub = 47,
  Eql = 48,
  Gte = 49,
  Gtr = 50,
  Lte = 51,
  Lss = 52,
  Neq = 53,
  FunctionCall = 54,
  FunctionIdentifier = 55,
  AbsentOverTime = 56,
  Identifier = 57,
  Absent = 58,
  Abs = 59,
  Acos = 60,
  Acosh = 61,
  Asin = 62,
  Asinh = 63,
  Atan = 64,
  Atanh = 65,
  AvgOverTime = 66,
  Ceil = 67,
  Changes = 68,
  Clamp = 69,
  ClampMax = 70,
  ClampMin = 71,
  Cos = 72,
  Cosh = 73,
  CountOverTime = 74,
  DaysInMonth = 75,
  DayOfMonth = 76,
  DayOfWeek = 77,
  Deg = 78,
  Delta = 79,
  Deriv = 80,
  Exp = 81,
  Floor = 82,
  HistogramQuantile = 83,
  HoltWinters = 84,
  Hour = 85,
  Idelta = 86,
  Increase = 87,
  Irate = 88,
  LabelReplace = 89,
  LabelJoin = 90,
  LastOverTime = 91,
  Ln = 92,
  Log10 = 93,
  Log2 = 94,
  MaxOverTime = 95,
  MinOverTime = 96,
  Minute = 97,
  Month = 98,
  Pi = 99,
  PredictLinear = 100,
  PresentOverTime = 101,
  QuantileOverTime = 102,
  Rad = 103,
  Rate = 104,
  Resets = 105,
  Round = 106,
  Scalar = 107,
  Sgn = 108,
  Sin = 109,
  Sinh = 110,
  Sort = 111,
  SortDesc = 112,
  Sqrt = 113,
  StddevOverTime = 114,
  StdvarOverTime = 115,
  SumOverTime = 116,
  Tan = 117,
  Tanh = 118,
  Timestamp = 119,
  Time = 120,
  Vector = 121,
  Year = 122,
  MatrixSelector = 123,
  Duration = 124,
  NumberLiteral = 125,
  OffsetExpr = 126,
  ParenExpr = 127,
  StringLiteral = 128,
  SubqueryExpr = 129,
  UnaryExpr = 130,
  UnaryOp = 131,
  VectorSelector = 132,
  MetricIdentifier = 133,
  LabelMatchers = 134,
  LabelMatchList = 135,
  LabelMatcher = 136,
  MatchOp = 137,
  EqlSingle = 138,
  EqlRegex = 139,
  NeqRegex = 140,
  StepInvariantExpr = 141,
  At = 142,
  AtModifierPreprocessors = 143,
  MetricName = 144;




/***/ }),

/***/ "./.yarn/cache/@lezer-common-npm-0.15.12-62017272b0-dae6581618.zip/node_modules/@lezer/common/dist/index.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DefaultBufferLength": () => (/* binding */ DefaultBufferLength),
/* harmony export */   "MountedTree": () => (/* binding */ MountedTree),
/* harmony export */   "NodeProp": () => (/* binding */ NodeProp),
/* harmony export */   "NodeSet": () => (/* binding */ NodeSet),
/* harmony export */   "NodeType": () => (/* binding */ NodeType),
/* harmony export */   "Parser": () => (/* binding */ Parser),
/* harmony export */   "Tree": () => (/* binding */ Tree),
/* harmony export */   "TreeBuffer": () => (/* binding */ TreeBuffer),
/* harmony export */   "TreeCursor": () => (/* binding */ TreeCursor),
/* harmony export */   "TreeFragment": () => (/* binding */ TreeFragment),
/* harmony export */   "parseMixed": () => (/* binding */ parseMixed)
/* harmony export */ });
// FIXME profile adding a per-Tree TreeNode cache, validating it by
// parent pointer
/// The default maximum length of a `TreeBuffer` node (1024).
const DefaultBufferLength = 1024;
let nextPropID = 0;
class Range {
    constructor(from, to) {
        this.from = from;
        this.to = to;
    }
}
/// Each [node type](#common.NodeType) or [individual tree](#common.Tree)
/// can have metadata associated with it in props. Instances of this
/// class represent prop names.
class NodeProp {
    /// Create a new node prop type.
    constructor(config = {}) {
        this.id = nextPropID++;
        this.perNode = !!config.perNode;
        this.deserialize = config.deserialize || (() => {
            throw new Error("This node type doesn't define a deserialize function");
        });
    }
    /// This is meant to be used with
    /// [`NodeSet.extend`](#common.NodeSet.extend) or
    /// [`LRParser.configure`](#lr.ParserConfig.props) to compute
    /// prop values for each node type in the set. Takes a [match
    /// object](#common.NodeType^match) or function that returns undefined
    /// if the node type doesn't get this prop, and the prop's value if
    /// it does.
    add(match) {
        if (this.perNode)
            throw new RangeError("Can't add per-node props to node types");
        if (typeof match != "function")
            match = NodeType.match(match);
        return (type) => {
            let result = match(type);
            return result === undefined ? null : [this, result];
        };
    }
}
/// Prop that is used to describe matching delimiters. For opening
/// delimiters, this holds an array of node names (written as a
/// space-separated string when declaring this prop in a grammar)
/// for the node types of closing delimiters that match it.
NodeProp.closedBy = new NodeProp({ deserialize: str => str.split(" ") });
/// The inverse of [`closedBy`](#common.NodeProp^closedBy). This is
/// attached to closing delimiters, holding an array of node names
/// of types of matching opening delimiters.
NodeProp.openedBy = new NodeProp({ deserialize: str => str.split(" ") });
/// Used to assign node types to groups (for example, all node
/// types that represent an expression could be tagged with an
/// `"Expression"` group).
NodeProp.group = new NodeProp({ deserialize: str => str.split(" ") });
/// The hash of the [context](#lr.ContextTracker.constructor)
/// that the node was parsed in, if any. Used to limit reuse of
/// contextual nodes.
NodeProp.contextHash = new NodeProp({ perNode: true });
/// The distance beyond the end of the node that the tokenizer
/// looked ahead for any of the tokens inside the node. (The LR
/// parser only stores this when it is larger than 25, for
/// efficiency reasons.)
NodeProp.lookAhead = new NodeProp({ perNode: true });
/// This per-node prop is used to replace a given node, or part of a
/// node, with another tree. This is useful to include trees from
/// different languages.
NodeProp.mounted = new NodeProp({ perNode: true });
/// A mounted tree, which can be [stored](#common.NodeProp^mounted) on
/// a tree node to indicate that parts of its content are
/// represented by another tree.
class MountedTree {
    constructor(
    /// The inner tree.
    tree, 
    /// If this is null, this tree replaces the entire node (it will
    /// be included in the regular iteration instead of its host
    /// node). If not, only the given ranges are considered to be
    /// covered by this tree. This is used for trees that are mixed in
    /// a way that isn't strictly hierarchical. Such mounted trees are
    /// only entered by [`resolveInner`](#common.Tree.resolveInner)
    /// and [`enter`](#common.SyntaxNode.enter).
    overlay, 
    /// The parser used to create this subtree.
    parser) {
        this.tree = tree;
        this.overlay = overlay;
        this.parser = parser;
    }
}
const noProps = Object.create(null);
/// Each node in a syntax tree has a node type associated with it.
class NodeType {
    /// @internal
    constructor(
    /// The name of the node type. Not necessarily unique, but if the
    /// grammar was written properly, different node types with the
    /// same name within a node set should play the same semantic
    /// role.
    name, 
    /// @internal
    props, 
    /// The id of this node in its set. Corresponds to the term ids
    /// used in the parser.
    id, 
    /// @internal
    flags = 0) {
        this.name = name;
        this.props = props;
        this.id = id;
        this.flags = flags;
    }
    static define(spec) {
        let props = spec.props && spec.props.length ? Object.create(null) : noProps;
        let flags = (spec.top ? 1 /* Top */ : 0) | (spec.skipped ? 2 /* Skipped */ : 0) |
            (spec.error ? 4 /* Error */ : 0) | (spec.name == null ? 8 /* Anonymous */ : 0);
        let type = new NodeType(spec.name || "", props, spec.id, flags);
        if (spec.props)
            for (let src of spec.props) {
                if (!Array.isArray(src))
                    src = src(type);
                if (src) {
                    if (src[0].perNode)
                        throw new RangeError("Can't store a per-node prop on a node type");
                    props[src[0].id] = src[1];
                }
            }
        return type;
    }
    /// Retrieves a node prop for this type. Will return `undefined` if
    /// the prop isn't present on this node.
    prop(prop) { return this.props[prop.id]; }
    /// True when this is the top node of a grammar.
    get isTop() { return (this.flags & 1 /* Top */) > 0; }
    /// True when this node is produced by a skip rule.
    get isSkipped() { return (this.flags & 2 /* Skipped */) > 0; }
    /// Indicates whether this is an error node.
    get isError() { return (this.flags & 4 /* Error */) > 0; }
    /// When true, this node type doesn't correspond to a user-declared
    /// named node, for example because it is used to cache repetition.
    get isAnonymous() { return (this.flags & 8 /* Anonymous */) > 0; }
    /// Returns true when this node's name or one of its
    /// [groups](#common.NodeProp^group) matches the given string.
    is(name) {
        if (typeof name == 'string') {
            if (this.name == name)
                return true;
            let group = this.prop(NodeProp.group);
            return group ? group.indexOf(name) > -1 : false;
        }
        return this.id == name;
    }
    /// Create a function from node types to arbitrary values by
    /// specifying an object whose property names are node or
    /// [group](#common.NodeProp^group) names. Often useful with
    /// [`NodeProp.add`](#common.NodeProp.add). You can put multiple
    /// names, separated by spaces, in a single property name to map
    /// multiple node names to a single value.
    static match(map) {
        let direct = Object.create(null);
        for (let prop in map)
            for (let name of prop.split(" "))
                direct[name] = map[prop];
        return (node) => {
            for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
                let found = direct[i < 0 ? node.name : groups[i]];
                if (found)
                    return found;
            }
        };
    }
}
/// An empty dummy node type to use when no actual type is available.
NodeType.none = new NodeType("", Object.create(null), 0, 8 /* Anonymous */);
/// A node set holds a collection of node types. It is used to
/// compactly represent trees by storing their type ids, rather than a
/// full pointer to the type object, in a numeric array. Each parser
/// [has](#lr.LRParser.nodeSet) a node set, and [tree
/// buffers](#common.TreeBuffer) can only store collections of nodes
/// from the same set. A set can have a maximum of 2**16 (65536) node
/// types in it, so that the ids fit into 16-bit typed array slots.
class NodeSet {
    /// Create a set with the given types. The `id` property of each
    /// type should correspond to its position within the array.
    constructor(
    /// The node types in this set, by id.
    types) {
        this.types = types;
        for (let i = 0; i < types.length; i++)
            if (types[i].id != i)
                throw new RangeError("Node type ids should correspond to array positions when creating a node set");
    }
    /// Create a copy of this set with some node properties added. The
    /// arguments to this method should be created with
    /// [`NodeProp.add`](#common.NodeProp.add).
    extend(...props) {
        let newTypes = [];
        for (let type of this.types) {
            let newProps = null;
            for (let source of props) {
                let add = source(type);
                if (add) {
                    if (!newProps)
                        newProps = Object.assign({}, type.props);
                    newProps[add[0].id] = add[1];
                }
            }
            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
        }
        return new NodeSet(newTypes);
    }
}
const CachedNode = new WeakMap(), CachedInnerNode = new WeakMap();
/// A piece of syntax tree. There are two ways to approach these
/// trees: the way they are actually stored in memory, and the
/// convenient way.
///
/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`
/// objects. By packing detail information into `TreeBuffer` leaf
/// nodes, the representation is made a lot more memory-efficient.
///
/// However, when you want to actually work with tree nodes, this
/// representation is very awkward, so most client code will want to
/// use the [`TreeCursor`](#common.TreeCursor) or
/// [`SyntaxNode`](#common.SyntaxNode) interface instead, which provides
/// a view on some part of this data structure, and can be used to
/// move around to adjacent nodes.
class Tree {
    /// Construct a new tree. See also [`Tree.build`](#common.Tree^build).
    constructor(
    /// The type of the top node.
    type, 
    /// This node's child nodes.
    children, 
    /// The positions (offsets relative to the start of this tree) of
    /// the children.
    positions, 
    /// The total length of this tree
    length, 
    /// Per-node [node props](#common.NodeProp) to associate with this node.
    props) {
        this.type = type;
        this.children = children;
        this.positions = positions;
        this.length = length;
        /// @internal
        this.props = null;
        if (props && props.length) {
            this.props = Object.create(null);
            for (let [prop, value] of props)
                this.props[typeof prop == "number" ? prop : prop.id] = value;
        }
    }
    /// @internal
    toString() {
        let mounted = this.prop(NodeProp.mounted);
        if (mounted && !mounted.overlay)
            return mounted.tree.toString();
        let children = "";
        for (let ch of this.children) {
            let str = ch.toString();
            if (str) {
                if (children)
                    children += ",";
                children += str;
            }
        }
        return !this.type.name ? children :
            (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +
                (children.length ? "(" + children + ")" : "");
    }
    /// Get a [tree cursor](#common.TreeCursor) rooted at this tree. When
    /// `pos` is given, the cursor is [moved](#common.TreeCursor.moveTo)
    /// to the given position and side.
    cursor(pos, side = 0) {
        let scope = (pos != null && CachedNode.get(this)) || this.topNode;
        let cursor = new TreeCursor(scope);
        if (pos != null) {
            cursor.moveTo(pos, side);
            CachedNode.set(this, cursor._tree);
        }
        return cursor;
    }
    /// Get a [tree cursor](#common.TreeCursor) that, unlike regular
    /// cursors, doesn't skip through
    /// [anonymous](#common.NodeType.isAnonymous) nodes and doesn't
    /// automatically enter mounted nodes.
    fullCursor() {
        return new TreeCursor(this.topNode, 1 /* Full */);
    }
    /// Get a [syntax node](#common.SyntaxNode) object for the top of the
    /// tree.
    get topNode() {
        return new TreeNode(this, 0, 0, null);
    }
    /// Get the [syntax node](#common.SyntaxNode) at the given position.
    /// If `side` is -1, this will move into nodes that end at the
    /// position. If 1, it'll move into nodes that start at the
    /// position. With 0, it'll only enter nodes that cover the position
    /// from both sides.
    resolve(pos, side = 0) {
        let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
        CachedNode.set(this, node);
        return node;
    }
    /// Like [`resolve`](#common.Tree.resolve), but will enter
    /// [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
    /// pointing into the innermost overlaid tree at the given position
    /// (with parent links going through all parent structure, including
    /// the host trees).
    resolveInner(pos, side = 0) {
        let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
        CachedInnerNode.set(this, node);
        return node;
    }
    /// Iterate over the tree and its children, calling `enter` for any
    /// node that touches the `from`/`to` region (if given) before
    /// running over such a node's children, and `leave` (if given) when
    /// leaving the node. When `enter` returns `false`, that node will
    /// not have its children iterated over (or `leave` called).
    iterate(spec) {
        let { enter, leave, from = 0, to = this.length } = spec;
        for (let c = this.cursor(), get = () => c.node;;) {
            let mustLeave = false;
            if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c.type, c.from, c.to, get) !== false)) {
                if (c.firstChild())
                    continue;
                if (!c.type.isAnonymous)
                    mustLeave = true;
            }
            for (;;) {
                if (mustLeave && leave)
                    leave(c.type, c.from, c.to, get);
                mustLeave = c.type.isAnonymous;
                if (c.nextSibling())
                    break;
                if (!c.parent())
                    return;
                mustLeave = true;
            }
        }
    }
    /// Get the value of the given [node prop](#common.NodeProp) for this
    /// node. Works with both per-node and per-type props.
    prop(prop) {
        return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined;
    }
    /// Returns the node's [per-node props](#common.NodeProp.perNode) in a
    /// format that can be passed to the [`Tree`](#common.Tree)
    /// constructor.
    get propValues() {
        let result = [];
        if (this.props)
            for (let id in this.props)
                result.push([+id, this.props[id]]);
        return result;
    }
    /// Balance the direct children of this tree, producing a copy of
    /// which may have children grouped into subtrees with type
    /// [`NodeType.none`](#common.NodeType^none).
    balance(config = {}) {
        return this.children.length <= 8 /* BranchFactor */ ? this :
            balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));
    }
    /// Build a tree from a postfix-ordered buffer of node information,
    /// or a cursor over such a buffer.
    static build(data) { return buildTree(data); }
}
/// The empty tree
Tree.empty = new Tree(NodeType.none, [], [], 0);
class FlatBufferCursor {
    constructor(buffer, index) {
        this.buffer = buffer;
        this.index = index;
    }
    get id() { return this.buffer[this.index - 4]; }
    get start() { return this.buffer[this.index - 3]; }
    get end() { return this.buffer[this.index - 2]; }
    get size() { return this.buffer[this.index - 1]; }
    get pos() { return this.index; }
    next() { this.index -= 4; }
    fork() { return new FlatBufferCursor(this.buffer, this.index); }
}
/// Tree buffers contain (type, start, end, endIndex) quads for each
/// node. In such a buffer, nodes are stored in prefix order (parents
/// before children, with the endIndex of the parent indicating which
/// children belong to it)
class TreeBuffer {
    /// Create a tree buffer.
    constructor(
    /// The buffer's content.
    buffer, 
    /// The total length of the group of nodes in the buffer.
    length, 
    /// The node set used in this buffer.
    set) {
        this.buffer = buffer;
        this.length = length;
        this.set = set;
    }
    /// @internal
    get type() { return NodeType.none; }
    /// @internal
    toString() {
        let result = [];
        for (let index = 0; index < this.buffer.length;) {
            result.push(this.childString(index));
            index = this.buffer[index + 3];
        }
        return result.join(",");
    }
    /// @internal
    childString(index) {
        let id = this.buffer[index], endIndex = this.buffer[index + 3];
        let type = this.set.types[id], result = type.name;
        if (/\W/.test(result) && !type.isError)
            result = JSON.stringify(result);
        index += 4;
        if (endIndex == index)
            return result;
        let children = [];
        while (index < endIndex) {
            children.push(this.childString(index));
            index = this.buffer[index + 3];
        }
        return result + "(" + children.join(",") + ")";
    }
    /// @internal
    findChild(startIndex, endIndex, dir, pos, side) {
        let { buffer } = this, pick = -1;
        for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
            if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {
                pick = i;
                if (dir > 0)
                    break;
            }
        }
        return pick;
    }
    /// @internal
    slice(startI, endI, from, to) {
        let b = this.buffer;
        let copy = new Uint16Array(endI - startI);
        for (let i = startI, j = 0; i < endI;) {
            copy[j++] = b[i++];
            copy[j++] = b[i++] - from;
            copy[j++] = b[i++] - from;
            copy[j++] = b[i++] - startI;
        }
        return new TreeBuffer(copy, to - from, this.set);
    }
}
function checkSide(side, pos, from, to) {
    switch (side) {
        case -2 /* Before */: return from < pos;
        case -1 /* AtOrBefore */: return to >= pos && from < pos;
        case 0 /* Around */: return from < pos && to > pos;
        case 1 /* AtOrAfter */: return from <= pos && to > pos;
        case 2 /* After */: return to > pos;
        case 4 /* DontCare */: return true;
    }
}
function enterUnfinishedNodesBefore(node, pos) {
    let scan = node.childBefore(pos);
    while (scan) {
        let last = scan.lastChild;
        if (!last || last.to != scan.to)
            break;
        if (last.type.isError && last.from == last.to) {
            node = scan;
            scan = last.prevSibling;
        }
        else {
            scan = last;
        }
    }
    return node;
}
function resolveNode(node, pos, side, overlays) {
    var _a;
    // Move up to a node that actually holds the position, if possible
    while (node.from == node.to ||
        (side < 1 ? node.from >= pos : node.from > pos) ||
        (side > -1 ? node.to <= pos : node.to < pos)) {
        let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
        if (!parent)
            return node;
        node = parent;
    }
    // Must go up out of overlays when those do not overlap with pos
    if (overlays)
        for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
            if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, true)) === null || _a === void 0 ? void 0 : _a.from) != scan.from)
                node = parent;
        }
    for (;;) {
        let inner = node.enter(pos, side, overlays);
        if (!inner)
            return node;
        node = inner;
    }
}
class TreeNode {
    constructor(node, _from, 
    // Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)
    index, _parent) {
        this.node = node;
        this._from = _from;
        this.index = index;
        this._parent = _parent;
    }
    get type() { return this.node.type; }
    get name() { return this.node.type.name; }
    get from() { return this._from; }
    get to() { return this._from + this.node.length; }
    nextChild(i, dir, pos, side, mode = 0) {
        for (let parent = this;;) {
            for (let { children, positions } = parent.node, e = dir > 0 ? children.length : -1; i != e; i += dir) {
                let next = children[i], start = positions[i] + parent._from;
                if (!checkSide(side, pos, start, start + next.length))
                    continue;
                if (next instanceof TreeBuffer) {
                    if (mode & 2 /* NoEnterBuffer */)
                        continue;
                    let index = next.findChild(0, next.buffer.length, dir, pos - start, side);
                    if (index > -1)
                        return new BufferNode(new BufferContext(parent, next, i, start), null, index);
                }
                else if ((mode & 1 /* Full */) || (!next.type.isAnonymous || hasChild(next))) {
                    let mounted;
                    if (!(mode & 1 /* Full */) && next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay)
                        return new TreeNode(mounted.tree, start, i, parent);
                    let inner = new TreeNode(next, start, i, parent);
                    return (mode & 1 /* Full */) || !inner.type.isAnonymous ? inner
                        : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
                }
            }
            if ((mode & 1 /* Full */) || !parent.type.isAnonymous)
                return null;
            if (parent.index >= 0)
                i = parent.index + dir;
            else
                i = dir < 0 ? -1 : parent._parent.node.children.length;
            parent = parent._parent;
            if (!parent)
                return null;
        }
    }
    get firstChild() { return this.nextChild(0, 1, 0, 4 /* DontCare */); }
    get lastChild() { return this.nextChild(this.node.children.length - 1, -1, 0, 4 /* DontCare */); }
    childAfter(pos) { return this.nextChild(0, 1, pos, 2 /* After */); }
    childBefore(pos) { return this.nextChild(this.node.children.length - 1, -1, pos, -2 /* Before */); }
    enter(pos, side, overlays = true, buffers = true) {
        let mounted;
        if (overlays && (mounted = this.node.prop(NodeProp.mounted)) && mounted.overlay) {
            let rPos = pos - this.from;
            for (let { from, to } of mounted.overlay) {
                if ((side > 0 ? from <= rPos : from < rPos) &&
                    (side < 0 ? to >= rPos : to > rPos))
                    return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
            }
        }
        return this.nextChild(0, 1, pos, side, buffers ? 0 : 2 /* NoEnterBuffer */);
    }
    nextSignificantParent() {
        let val = this;
        while (val.type.isAnonymous && val._parent)
            val = val._parent;
        return val;
    }
    get parent() {
        return this._parent ? this._parent.nextSignificantParent() : null;
    }
    get nextSibling() {
        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4 /* DontCare */) : null;
    }
    get prevSibling() {
        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4 /* DontCare */) : null;
    }
    get cursor() { return new TreeCursor(this); }
    get tree() { return this.node; }
    toTree() { return this.node; }
    resolve(pos, side = 0) {
        return resolveNode(this, pos, side, false);
    }
    resolveInner(pos, side = 0) {
        return resolveNode(this, pos, side, true);
    }
    enterUnfinishedNodesBefore(pos) { return enterUnfinishedNodesBefore(this, pos); }
    getChild(type, before = null, after = null) {
        let r = getChildren(this, type, before, after);
        return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
        return getChildren(this, type, before, after);
    }
    /// @internal
    toString() { return this.node.toString(); }
}
function getChildren(node, type, before, after) {
    let cur = node.cursor, result = [];
    if (!cur.firstChild())
        return result;
    if (before != null)
        while (!cur.type.is(before))
            if (!cur.nextSibling())
                return result;
    for (;;) {
        if (after != null && cur.type.is(after))
            return result;
        if (cur.type.is(type))
            result.push(cur.node);
        if (!cur.nextSibling())
            return after == null ? result : [];
    }
}
class BufferContext {
    constructor(parent, buffer, index, start) {
        this.parent = parent;
        this.buffer = buffer;
        this.index = index;
        this.start = start;
    }
}
class BufferNode {
    constructor(context, _parent, index) {
        this.context = context;
        this._parent = _parent;
        this.index = index;
        this.type = context.buffer.set.types[context.buffer.buffer[index]];
    }
    get name() { return this.type.name; }
    get from() { return this.context.start + this.context.buffer.buffer[this.index + 1]; }
    get to() { return this.context.start + this.context.buffer.buffer[this.index + 2]; }
    child(dir, pos, side) {
        let { buffer } = this.context;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
        return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get firstChild() { return this.child(1, 0, 4 /* DontCare */); }
    get lastChild() { return this.child(-1, 0, 4 /* DontCare */); }
    childAfter(pos) { return this.child(1, pos, 2 /* After */); }
    childBefore(pos) { return this.child(-1, pos, -2 /* Before */); }
    enter(pos, side, overlays, buffers = true) {
        if (!buffers)
            return null;
        let { buffer } = this.context;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
        return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get parent() {
        return this._parent || this.context.parent.nextSignificantParent();
    }
    externalSibling(dir) {
        return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4 /* DontCare */);
    }
    get nextSibling() {
        let { buffer } = this.context;
        let after = buffer.buffer[this.index + 3];
        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
            return new BufferNode(this.context, this._parent, after);
        return this.externalSibling(1);
    }
    get prevSibling() {
        let { buffer } = this.context;
        let parentStart = this._parent ? this._parent.index + 4 : 0;
        if (this.index == parentStart)
            return this.externalSibling(-1);
        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4 /* DontCare */));
    }
    get cursor() { return new TreeCursor(this); }
    get tree() { return null; }
    toTree() {
        let children = [], positions = [];
        let { buffer } = this.context;
        let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
        if (endI > startI) {
            let from = buffer.buffer[this.index + 1], to = buffer.buffer[this.index + 2];
            children.push(buffer.slice(startI, endI, from, to));
            positions.push(0);
        }
        return new Tree(this.type, children, positions, this.to - this.from);
    }
    resolve(pos, side = 0) {
        return resolveNode(this, pos, side, false);
    }
    resolveInner(pos, side = 0) {
        return resolveNode(this, pos, side, true);
    }
    enterUnfinishedNodesBefore(pos) { return enterUnfinishedNodesBefore(this, pos); }
    /// @internal
    toString() { return this.context.buffer.childString(this.index); }
    getChild(type, before = null, after = null) {
        let r = getChildren(this, type, before, after);
        return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
        return getChildren(this, type, before, after);
    }
}
/// A tree cursor object focuses on a given node in a syntax tree, and
/// allows you to move to adjacent nodes.
class TreeCursor {
    /// @internal
    constructor(node, 
    /// @internal
    mode = 0) {
        this.mode = mode;
        this.buffer = null;
        this.stack = [];
        this.index = 0;
        this.bufferNode = null;
        if (node instanceof TreeNode) {
            this.yieldNode(node);
        }
        else {
            this._tree = node.context.parent;
            this.buffer = node.context;
            for (let n = node._parent; n; n = n._parent)
                this.stack.unshift(n.index);
            this.bufferNode = node;
            this.yieldBuf(node.index);
        }
    }
    /// Shorthand for `.type.name`.
    get name() { return this.type.name; }
    yieldNode(node) {
        if (!node)
            return false;
        this._tree = node;
        this.type = node.type;
        this.from = node.from;
        this.to = node.to;
        return true;
    }
    yieldBuf(index, type) {
        this.index = index;
        let { start, buffer } = this.buffer;
        this.type = type || buffer.set.types[buffer.buffer[index]];
        this.from = start + buffer.buffer[index + 1];
        this.to = start + buffer.buffer[index + 2];
        return true;
    }
    yield(node) {
        if (!node)
            return false;
        if (node instanceof TreeNode) {
            this.buffer = null;
            return this.yieldNode(node);
        }
        this.buffer = node.context;
        return this.yieldBuf(node.index, node.type);
    }
    /// @internal
    toString() {
        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
    }
    /// @internal
    enterChild(dir, pos, side) {
        if (!this.buffer)
            return this.yield(this._tree.nextChild(dir < 0 ? this._tree.node.children.length - 1 : 0, dir, pos, side, this.mode));
        let { buffer } = this.buffer;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
        if (index < 0)
            return false;
        this.stack.push(this.index);
        return this.yieldBuf(index);
    }
    /// Move the cursor to this node's first child. When this returns
    /// false, the node has no child, and the cursor has not been moved.
    firstChild() { return this.enterChild(1, 0, 4 /* DontCare */); }
    /// Move the cursor to this node's last child.
    lastChild() { return this.enterChild(-1, 0, 4 /* DontCare */); }
    /// Move the cursor to the first child that ends after `pos`.
    childAfter(pos) { return this.enterChild(1, pos, 2 /* After */); }
    /// Move to the last child that starts before `pos`.
    childBefore(pos) { return this.enterChild(-1, pos, -2 /* Before */); }
    /// Move the cursor to the child around `pos`. If side is -1 the
    /// child may end at that position, when 1 it may start there. This
    /// will also enter [overlaid](#common.MountedTree.overlay)
    /// [mounted](#common.NodeProp^mounted) trees unless `overlays` is
    /// set to false.
    enter(pos, side, overlays = true, buffers = true) {
        if (!this.buffer)
            return this.yield(this._tree.enter(pos, side, overlays && !(this.mode & 1 /* Full */), buffers));
        return buffers ? this.enterChild(1, pos, side) : false;
    }
    /// Move to the node's parent node, if this isn't the top node.
    parent() {
        if (!this.buffer)
            return this.yieldNode((this.mode & 1 /* Full */) ? this._tree._parent : this._tree.parent);
        if (this.stack.length)
            return this.yieldBuf(this.stack.pop());
        let parent = (this.mode & 1 /* Full */) ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
        this.buffer = null;
        return this.yieldNode(parent);
    }
    /// @internal
    sibling(dir) {
        if (!this.buffer)
            return !this._tree._parent ? false
                : this.yield(this._tree.index < 0 ? null
                    : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4 /* DontCare */, this.mode));
        let { buffer } = this.buffer, d = this.stack.length - 1;
        if (dir < 0) {
            let parentStart = d < 0 ? 0 : this.stack[d] + 4;
            if (this.index != parentStart)
                return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4 /* DontCare */));
        }
        else {
            let after = buffer.buffer[this.index + 3];
            if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
                return this.yieldBuf(after);
        }
        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4 /* DontCare */, this.mode)) : false;
    }
    /// Move to this node's next sibling, if any.
    nextSibling() { return this.sibling(1); }
    /// Move to this node's previous sibling, if any.
    prevSibling() { return this.sibling(-1); }
    atLastNode(dir) {
        let index, parent, { buffer } = this;
        if (buffer) {
            if (dir > 0) {
                if (this.index < buffer.buffer.buffer.length)
                    return false;
            }
            else {
                for (let i = 0; i < this.index; i++)
                    if (buffer.buffer.buffer[i + 3] < this.index)
                        return false;
            }
            ({ index, parent } = buffer);
        }
        else {
            ({ index, _parent: parent } = this._tree);
        }
        for (; parent; { index, _parent: parent } = parent) {
            if (index > -1)
                for (let i = index + dir, e = dir < 0 ? -1 : parent.node.children.length; i != e; i += dir) {
                    let child = parent.node.children[i];
                    if ((this.mode & 1 /* Full */) || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))
                        return false;
                }
        }
        return true;
    }
    move(dir, enter) {
        if (enter && this.enterChild(dir, 0, 4 /* DontCare */))
            return true;
        for (;;) {
            if (this.sibling(dir))
                return true;
            if (this.atLastNode(dir) || !this.parent())
                return false;
        }
    }
    /// Move to the next node in a
    /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR))
    /// traversal, going from a node to its first child or, if the
    /// current node is empty or `enter` is false, its next sibling or
    /// the next sibling of the first parent node that has one.
    next(enter = true) { return this.move(1, enter); }
    /// Move to the next node in a last-to-first pre-order traveral. A
    /// node is followed by its last child or, if it has none, its
    /// previous sibling or the previous sibling of the first parent
    /// node that has one.
    prev(enter = true) { return this.move(-1, enter); }
    /// Move the cursor to the innermost node that covers `pos`. If
    /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,
    /// it will enter nodes that start at `pos`.
    moveTo(pos, side = 0) {
        // Move up to a node that actually holds the position, if possible
        while (this.from == this.to ||
            (side < 1 ? this.from >= pos : this.from > pos) ||
            (side > -1 ? this.to <= pos : this.to < pos))
            if (!this.parent())
                break;
        // Then scan down into child nodes as far as possible
        while (this.enterChild(1, pos, side)) { }
        return this;
    }
    /// Get a [syntax node](#common.SyntaxNode) at the cursor's current
    /// position.
    get node() {
        if (!this.buffer)
            return this._tree;
        let cache = this.bufferNode, result = null, depth = 0;
        if (cache && cache.context == this.buffer) {
            scan: for (let index = this.index, d = this.stack.length; d >= 0;) {
                for (let c = cache; c; c = c._parent)
                    if (c.index == index) {
                        if (index == this.index)
                            return c;
                        result = c;
                        depth = d + 1;
                        break scan;
                    }
                index = this.stack[--d];
            }
        }
        for (let i = depth; i < this.stack.length; i++)
            result = new BufferNode(this.buffer, result, this.stack[i]);
        return this.bufferNode = new BufferNode(this.buffer, result, this.index);
    }
    /// Get the [tree](#common.Tree) that represents the current node, if
    /// any. Will return null when the node is in a [tree
    /// buffer](#common.TreeBuffer).
    get tree() {
        return this.buffer ? null : this._tree.node;
    }
}
function hasChild(tree) {
    return tree.children.some(ch => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
}
function buildTree(data) {
    var _a;
    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
    let types = nodeSet.types;
    let contextHash = 0, lookAhead = 0;
    function takeNode(parentStart, minPos, children, positions, inRepeat) {
        let { id, start, end, size } = cursor;
        let lookAheadAtStart = lookAhead;
        while (size < 0) {
            cursor.next();
            if (size == -1 /* Reuse */) {
                let node = reused[id];
                children.push(node);
                positions.push(start - parentStart);
                return;
            }
            else if (size == -3 /* ContextChange */) { // Context change
                contextHash = id;
                return;
            }
            else if (size == -4 /* LookAhead */) {
                lookAhead = id;
                return;
            }
            else {
                throw new RangeError(`Unrecognized record size: ${size}`);
            }
        }
        let type = types[id], node, buffer;
        let startPos = start - parentStart;
        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {
            // Small enough for a buffer, and no reused nodes inside
            let data = new Uint16Array(buffer.size - buffer.skip);
            let endPos = cursor.pos - buffer.size, index = data.length;
            while (cursor.pos > endPos)
                index = copyToBuffer(buffer.start, data, index);
            node = new TreeBuffer(data, end - buffer.start, nodeSet);
            startPos = buffer.start - parentStart;
        }
        else { // Make it a node
            let endPos = cursor.pos - size;
            cursor.next();
            let localChildren = [], localPositions = [];
            let localInRepeat = id >= minRepeatType ? id : -1;
            let lastGroup = 0, lastEnd = end;
            while (cursor.pos > endPos) {
                if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
                    if (cursor.end <= lastEnd - maxBufferLength) {
                        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);
                        lastGroup = localChildren.length;
                        lastEnd = cursor.end;
                    }
                    cursor.next();
                }
                else {
                    takeNode(start, endPos, localChildren, localPositions, localInRepeat);
                }
            }
            if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
                makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);
            localChildren.reverse();
            localPositions.reverse();
            if (localInRepeat > -1 && lastGroup > 0) {
                let make = makeBalanced(type);
                node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
            }
            else {
                node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);
            }
        }
        children.push(node);
        positions.push(startPos);
    }
    function makeBalanced(type) {
        return (children, positions, length) => {
            let lookAhead = 0, lastI = children.length - 1, last, lookAheadProp;
            if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {
                if (!lastI && last.type == type && last.length == length)
                    return last;
                if (lookAheadProp = last.prop(NodeProp.lookAhead))
                    lookAhead = positions[lastI] + last.length + lookAheadProp;
            }
            return makeTree(type, children, positions, length, lookAhead);
        };
    }
    function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead) {
        let localChildren = [], localPositions = [];
        while (children.length > i) {
            localChildren.push(children.pop());
            localPositions.push(positions.pop() + base - from);
        }
        children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to));
        positions.push(from - base);
    }
    function makeTree(type, children, positions, length, lookAhead = 0, props) {
        if (contextHash) {
            let pair = [NodeProp.contextHash, contextHash];
            props = props ? [pair].concat(props) : [pair];
        }
        if (lookAhead > 25) {
            let pair = [NodeProp.lookAhead, lookAhead];
            props = props ? [pair].concat(props) : [pair];
        }
        return new Tree(type, children, positions, length, props);
    }
    function findBufferSize(maxSize, inRepeat) {
        // Scan through the buffer to find previous siblings that fit
        // together in a TreeBuffer, and don't contain any reused nodes
        // (which can't be stored in a buffer).
        // If `inRepeat` is > -1, ignore node boundaries of that type for
        // nesting, but make sure the end falls either at the start
        // (`maxSize`) or before such a node.
        let fork = cursor.fork();
        let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
        let result = { size: 0, start: 0, skip: 0 };
        scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {
            let nodeSize = fork.size;
            // Pretend nested repeat nodes of the same type don't exist
            if (fork.id == inRepeat && nodeSize >= 0) {
                // Except that we store the current state as a valid return
                // value.
                result.size = size;
                result.start = start;
                result.skip = skip;
                skip += 4;
                size += 4;
                fork.next();
                continue;
            }
            let startPos = fork.pos - nodeSize;
            if (nodeSize < 0 || startPos < minPos || fork.start < minStart)
                break;
            let localSkipped = fork.id >= minRepeatType ? 4 : 0;
            let nodeStart = fork.start;
            fork.next();
            while (fork.pos > startPos) {
                if (fork.size < 0) {
                    if (fork.size == -3 /* ContextChange */)
                        localSkipped += 4;
                    else
                        break scan;
                }
                else if (fork.id >= minRepeatType) {
                    localSkipped += 4;
                }
                fork.next();
            }
            start = nodeStart;
            size += nodeSize;
            skip += localSkipped;
        }
        if (inRepeat < 0 || size == maxSize) {
            result.size = size;
            result.start = start;
            result.skip = skip;
        }
        return result.size > 4 ? result : undefined;
    }
    function copyToBuffer(bufferStart, buffer, index) {
        let { id, start, end, size } = cursor;
        cursor.next();
        if (size >= 0 && id < minRepeatType) {
            let startIndex = index;
            if (size > 4) {
                let endPos = cursor.pos - (size - 4);
                while (cursor.pos > endPos)
                    index = copyToBuffer(bufferStart, buffer, index);
            }
            buffer[--index] = startIndex;
            buffer[--index] = end - bufferStart;
            buffer[--index] = start - bufferStart;
            buffer[--index] = id;
        }
        else if (size == -3 /* ContextChange */) {
            contextHash = id;
        }
        else if (size == -4 /* LookAhead */) {
            lookAhead = id;
        }
        return index;
    }
    let children = [], positions = [];
    while (cursor.pos > 0)
        takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1);
    let length = (_a = data.length) !== null && _a !== void 0 ? _a : (children.length ? positions[0] + children[0].length : 0);
    return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);
}
const nodeSizeCache = new WeakMap;
function nodeSize(balanceType, node) {
    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)
        return 1;
    let size = nodeSizeCache.get(node);
    if (size == null) {
        size = 1;
        for (let child of node.children) {
            if (child.type != balanceType || !(child instanceof Tree)) {
                size = 1;
                break;
            }
            size += nodeSize(balanceType, child);
        }
        nodeSizeCache.set(node, size);
    }
    return size;
}
function balanceRange(
// The type the balanced tree's inner nodes.
balanceType, 
// The direct children and their positions
children, positions, 
// The index range in children/positions to use
from, to, 
// The start position of the nodes, relative to their parent.
start, 
// Length of the outer node
length, 
// Function to build the top node of the balanced tree
mkTop, 
// Function to build internal nodes for the balanced tree
mkTree) {
    let total = 0;
    for (let i = from; i < to; i++)
        total += nodeSize(balanceType, children[i]);
    let maxChild = Math.ceil((total * 1.5) / 8 /* BranchFactor */);
    let localChildren = [], localPositions = [];
    function divide(children, positions, from, to, offset) {
        for (let i = from; i < to;) {
            let groupFrom = i, groupStart = positions[i], groupSize = nodeSize(balanceType, children[i]);
            i++;
            for (; i < to; i++) {
                let nextSize = nodeSize(balanceType, children[i]);
                if (groupSize + nextSize >= maxChild)
                    break;
                groupSize += nextSize;
            }
            if (i == groupFrom + 1) {
                if (groupSize > maxChild) {
                    let only = children[groupFrom]; // Only trees can have a size > 1
                    divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);
                    continue;
                }
                localChildren.push(children[groupFrom]);
            }
            else {
                let length = positions[i - 1] + children[i - 1].length - groupStart;
                localChildren.push(balanceRange(balanceType, children, positions, groupFrom, i, groupStart, length, null, mkTree));
            }
            localPositions.push(groupStart + offset - start);
        }
    }
    divide(children, positions, from, to, 0);
    return (mkTop || mkTree)(localChildren, localPositions, length);
}

/// Tree fragments are used during [incremental
/// parsing](#common.Parser.startParse) to track parts of old trees
/// that can be reused in a new parse. An array of fragments is used
/// to track regions of an old tree whose nodes might be reused in new
/// parses. Use the static
/// [`applyChanges`](#common.TreeFragment^applyChanges) method to
/// update fragments for document changes.
class TreeFragment {
    /// Construct a tree fragment.
    constructor(
    /// The start of the unchanged range pointed to by this fragment.
    /// This refers to an offset in the _updated_ document (as opposed
    /// to the original tree).
    from, 
    /// The end of the unchanged range.
    to, 
    /// The tree that this fragment is based on.
    tree, 
    /// The offset between the fragment's tree and the document that
    /// this fragment can be used against. Add this when going from
    /// document to tree positions, subtract it to go from tree to
    /// document positions.
    offset, openStart = false, openEnd = false) {
        this.from = from;
        this.to = to;
        this.tree = tree;
        this.offset = offset;
        this.open = (openStart ? 1 /* Start */ : 0) | (openEnd ? 2 /* End */ : 0);
    }
    /// Whether the start of the fragment represents the start of a
    /// parse, or the end of a change. (In the second case, it may not
    /// be safe to reuse some nodes at the start, depending on the
    /// parsing algorithm.)
    get openStart() { return (this.open & 1 /* Start */) > 0; }
    /// Whether the end of the fragment represents the end of a
    /// full-document parse, or the start of a change.
    get openEnd() { return (this.open & 2 /* End */) > 0; }
    /// Create a set of fragments from a freshly parsed tree, or update
    /// an existing set of fragments by replacing the ones that overlap
    /// with a tree with content from the new tree. When `partial` is
    /// true, the parse is treated as incomplete, and the resulting
    /// fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
    /// true.
    static addTree(tree, fragments = [], partial = false) {
        let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];
        for (let f of fragments)
            if (f.to > tree.length)
                result.push(f);
        return result;
    }
    /// Apply a set of edits to an array of fragments, removing or
    /// splitting fragments as necessary to remove edited ranges, and
    /// adjusting offsets for fragments that moved.
    static applyChanges(fragments, changes, minGap = 128) {
        if (!changes.length)
            return fragments;
        let result = [];
        let fI = 1, nextF = fragments.length ? fragments[0] : null;
        for (let cI = 0, pos = 0, off = 0;; cI++) {
            let nextC = cI < changes.length ? changes[cI] : null;
            let nextPos = nextC ? nextC.fromA : 1e9;
            if (nextPos - pos >= minGap)
                while (nextF && nextF.from < nextPos) {
                    let cut = nextF;
                    if (pos >= cut.from || nextPos <= cut.to || off) {
                        let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
                        cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
                    }
                    if (cut)
                        result.push(cut);
                    if (nextF.to > nextPos)
                        break;
                    nextF = fI < fragments.length ? fragments[fI++] : null;
                }
            if (!nextC)
                break;
            pos = nextC.toA;
            off = nextC.toA - nextC.toB;
        }
        return result;
    }
}
/// A superclass that parsers should extend.
class Parser {
    /// Start a parse, returning a [partial parse](#common.PartialParse)
    /// object. [`fragments`](#common.TreeFragment) can be passed in to
    /// make the parse incremental.
    ///
    /// By default, the entire input is parsed. You can pass `ranges`,
    /// which should be a sorted array of non-empty, non-overlapping
    /// ranges, to parse only those ranges. The tree returned in that
    /// case will start at `ranges[0].from`.
    startParse(input, fragments, ranges) {
        if (typeof input == "string")
            input = new StringInput(input);
        ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map(r => new Range(r.from, r.to)) : [new Range(0, 0)];
        return this.createParse(input, fragments || [], ranges);
    }
    /// Run a full parse, returning the resulting tree.
    parse(input, fragments, ranges) {
        let parse = this.startParse(input, fragments, ranges);
        for (;;) {
            let done = parse.advance();
            if (done)
                return done;
        }
    }
}
class StringInput {
    constructor(string) {
        this.string = string;
    }
    get length() { return this.string.length; }
    chunk(from) { return this.string.slice(from); }
    get lineChunks() { return false; }
    read(from, to) { return this.string.slice(from, to); }
}

/// Create a parse wrapper that, after the inner parse completes,
/// scans its tree for mixed language regions with the `nest`
/// function, runs the resulting [inner parses](#common.NestedParse),
/// and then [mounts](#common.NodeProp^mounted) their results onto the
/// tree.
///
/// The nesting function is passed a cursor to provide context for a
/// node, but _should not_ move that cursor, only inspect its
/// properties and optionally access its
/// [node object](#common.TreeCursor.node).
function parseMixed(nest) {
    return (parse, input, fragments, ranges) => new MixedParse(parse, nest, input, fragments, ranges);
}
class InnerParse {
    constructor(parser, parse, overlay, target, ranges) {
        this.parser = parser;
        this.parse = parse;
        this.overlay = overlay;
        this.target = target;
        this.ranges = ranges;
    }
}
class ActiveOverlay {
    constructor(parser, predicate, mounts, index, start, target, prev) {
        this.parser = parser;
        this.predicate = predicate;
        this.mounts = mounts;
        this.index = index;
        this.start = start;
        this.target = target;
        this.prev = prev;
        this.depth = 0;
        this.ranges = [];
    }
}
const stoppedInner = new NodeProp({ perNode: true });
class MixedParse {
    constructor(base, nest, input, fragments, ranges) {
        this.nest = nest;
        this.input = input;
        this.fragments = fragments;
        this.ranges = ranges;
        this.inner = [];
        this.innerDone = 0;
        this.baseTree = null;
        this.stoppedAt = null;
        this.baseParse = base;
    }
    advance() {
        if (this.baseParse) {
            let done = this.baseParse.advance();
            if (!done)
                return null;
            this.baseParse = null;
            this.baseTree = done;
            this.startInner();
            if (this.stoppedAt != null)
                for (let inner of this.inner)
                    inner.parse.stopAt(this.stoppedAt);
        }
        if (this.innerDone == this.inner.length) {
            let result = this.baseTree;
            if (this.stoppedAt != null)
                result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([[stoppedInner, this.stoppedAt]]));
            return result;
        }
        let inner = this.inner[this.innerDone], done = inner.parse.advance();
        if (done) {
            this.innerDone++;
            // This is a somewhat dodgy but super helpful hack where we
            // patch up nodes created by the inner parse (and thus
            // presumably not aliased anywhere else) to hold the information
            // about the inner parse.
            let props = Object.assign(Object.create(null), inner.target.props);
            props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);
            inner.target.props = props;
        }
        return null;
    }
    get parsedPos() {
        if (this.baseParse)
            return 0;
        let pos = this.input.length;
        for (let i = this.innerDone; i < this.inner.length; i++) {
            if (this.inner[i].ranges[0].from < pos)
                pos = Math.min(pos, this.inner[i].parse.parsedPos);
        }
        return pos;
    }
    stopAt(pos) {
        this.stoppedAt = pos;
        if (this.baseParse)
            this.baseParse.stopAt(pos);
        else
            for (let i = this.innerDone; i < this.inner.length; i++)
                this.inner[i].parse.stopAt(pos);
    }
    startInner() {
        let fragmentCursor = new FragmentCursor(this.fragments);
        let overlay = null;
        let covered = null;
        let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), 1 /* Full */);
        scan: for (let nest, isCovered; this.stoppedAt == null || cursor.from < this.stoppedAt;) {
            let enter = true, range;
            if (fragmentCursor.hasNode(cursor)) {
                if (overlay) {
                    let match = overlay.mounts.find(m => m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay);
                    if (match)
                        for (let r of match.mount.overlay) {
                            let from = r.from + match.pos, to = r.to + match.pos;
                            if (from >= cursor.from && to <= cursor.to && !overlay.ranges.some(r => r.from < to && r.to > from))
                                overlay.ranges.push({ from, to });
                        }
                }
                enter = false;
            }
            else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {
                enter = isCovered != 2 /* Full */;
            }
            else if (!cursor.type.isAnonymous && cursor.from < cursor.to && (nest = this.nest(cursor, this.input))) {
                if (!cursor.tree)
                    materialize(cursor);
                let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);
                if (typeof nest.overlay == "function") {
                    overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);
                }
                else {
                    let ranges = punchRanges(this.ranges, nest.overlay || [new Range(cursor.from, cursor.to)]);
                    if (ranges.length)
                        this.inner.push(new InnerParse(nest.parser, nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges), nest.overlay ? nest.overlay.map(r => new Range(r.from - cursor.from, r.to - cursor.from)) : null, cursor.tree, ranges));
                    if (!nest.overlay)
                        enter = false;
                    else if (ranges.length)
                        covered = { ranges, depth: 0, prev: covered };
                }
            }
            else if (overlay && (range = overlay.predicate(cursor))) {
                if (range === true)
                    range = new Range(cursor.from, cursor.to);
                if (range.from < range.to)
                    overlay.ranges.push(range);
            }
            if (enter && cursor.firstChild()) {
                if (overlay)
                    overlay.depth++;
                if (covered)
                    covered.depth++;
            }
            else {
                for (;;) {
                    if (cursor.nextSibling())
                        break;
                    if (!cursor.parent())
                        break scan;
                    if (overlay && !--overlay.depth) {
                        let ranges = punchRanges(this.ranges, overlay.ranges);
                        if (ranges.length)
                            this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map(r => new Range(r.from - overlay.start, r.to - overlay.start)), overlay.target, ranges));
                        overlay = overlay.prev;
                    }
                    if (covered && !--covered.depth)
                        covered = covered.prev;
                }
            }
        }
    }
}
function checkCover(covered, from, to) {
    for (let range of covered) {
        if (range.from >= to)
            break;
        if (range.to > from)
            return range.from <= from && range.to >= to ? 2 /* Full */ : 1 /* Partial */;
    }
    return 0 /* None */;
}
// Take a piece of buffer and convert it into a stand-alone
// TreeBuffer.
function sliceBuf(buf, startI, endI, nodes, positions, off) {
    if (startI < endI) {
        let from = buf.buffer[startI + 1], to = buf.buffer[endI - 2];
        nodes.push(buf.slice(startI, endI, from, to));
        positions.push(from - off);
    }
}
// This function takes a node that's in a buffer, and converts it, and
// its parent buffer nodes, into a Tree. This is again acting on the
// assumption that the trees and buffers have been constructed by the
// parse that was ran via the mix parser, and thus aren't shared with
// any other code, making violations of the immutability safe.
function materialize(cursor) {
    let { node } = cursor, depth = 0;
    // Scan up to the nearest tree
    do {
        cursor.parent();
        depth++;
    } while (!cursor.tree);
    // Find the index of the buffer in that tree
    let i = 0, base = cursor.tree, off = 0;
    for (;; i++) {
        off = base.positions[i] + cursor.from;
        if (off <= node.from && off + base.children[i].length >= node.to)
            break;
    }
    let buf = base.children[i], b = buf.buffer;
    // Split a level in the buffer, putting the nodes before and after
    // the child that contains `node` into new buffers.
    function split(startI, endI, type, innerOffset, length) {
        let i = startI;
        while (b[i + 2] + off <= node.from)
            i = b[i + 3];
        let children = [], positions = [];
        sliceBuf(buf, startI, i, children, positions, innerOffset);
        let from = b[i + 1], to = b[i + 2];
        let isTarget = from + off == node.from && to + off == node.to && b[i] == node.type.id;
        children.push(isTarget ? node.toTree() : split(i + 4, b[i + 3], buf.set.types[b[i]], from, to - from));
        positions.push(from - innerOffset);
        sliceBuf(buf, b[i + 3], endI, children, positions, innerOffset);
        return new Tree(type, children, positions, length);
    }
    base.children[i] = split(0, b.length, NodeType.none, 0, buf.length);
    // Move the cursor back to the target node
    for (let d = 0; d <= depth; d++)
        cursor.childAfter(node.from);
}
class StructureCursor {
    constructor(root, offset) {
        this.offset = offset;
        this.done = false;
        this.cursor = root.fullCursor();
    }
    // Move to the first node (in pre-order) that starts at or after `pos`.
    moveTo(pos) {
        let { cursor } = this, p = pos - this.offset;
        while (!this.done && cursor.from < p) {
            if (cursor.to >= pos && cursor.enter(p, 1, false, false)) ;
            else if (!cursor.next(false))
                this.done = true;
        }
    }
    hasNode(cursor) {
        this.moveTo(cursor.from);
        if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {
            for (let tree = this.cursor.tree;;) {
                if (tree == cursor.tree)
                    return true;
                if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree)
                    tree = tree.children[0];
                else
                    break;
            }
        }
        return false;
    }
}
class FragmentCursor {
    constructor(fragments) {
        var _a;
        this.fragments = fragments;
        this.curTo = 0;
        this.fragI = 0;
        if (fragments.length) {
            let first = this.curFrag = fragments[0];
            this.curTo = (_a = first.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : first.to;
            this.inner = new StructureCursor(first.tree, -first.offset);
        }
        else {
            this.curFrag = this.inner = null;
        }
    }
    hasNode(node) {
        while (this.curFrag && node.from >= this.curTo)
            this.nextFrag();
        return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);
    }
    nextFrag() {
        var _a;
        this.fragI++;
        if (this.fragI == this.fragments.length) {
            this.curFrag = this.inner = null;
        }
        else {
            let frag = this.curFrag = this.fragments[this.fragI];
            this.curTo = (_a = frag.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : frag.to;
            this.inner = new StructureCursor(frag.tree, -frag.offset);
        }
    }
    findMounts(pos, parser) {
        var _a;
        let result = [];
        if (this.inner) {
            this.inner.cursor.moveTo(pos, 1);
            for (let pos = this.inner.cursor.node; pos; pos = pos.parent) {
                let mount = (_a = pos.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);
                if (mount && mount.parser == parser) {
                    for (let i = this.fragI; i < this.fragments.length; i++) {
                        let frag = this.fragments[i];
                        if (frag.from >= pos.to)
                            break;
                        if (frag.tree == this.curFrag.tree)
                            result.push({
                                frag,
                                pos: pos.from - frag.offset,
                                mount
                            });
                    }
                }
            }
        }
        return result;
    }
}
function punchRanges(outer, ranges) {
    let copy = null, current = ranges;
    for (let i = 1, j = 0; i < outer.length; i++) {
        let gapFrom = outer[i - 1].to, gapTo = outer[i].from;
        for (; j < current.length; j++) {
            let r = current[j];
            if (r.from >= gapTo)
                break;
            if (r.to <= gapFrom)
                continue;
            if (!copy)
                current = copy = ranges.slice();
            if (r.from < gapFrom) {
                copy[j] = new Range(r.from, gapFrom);
                if (r.to > gapTo)
                    copy.splice(j + 1, 0, new Range(gapTo, r.to));
            }
            else if (r.to > gapTo) {
                copy[j--] = new Range(gapTo, r.to);
            }
            else {
                copy.splice(j--, 1);
            }
        }
    }
    return current;
}
function findCoverChanges(a, b, from, to) {
    let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;
    let result = [];
    for (;;) {
        let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;
        let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;
        if (inA != inB) {
            let start = Math.max(pos, from), end = Math.min(nextA, nextB, to);
            if (start < end)
                result.push(new Range(start, end));
        }
        pos = Math.min(nextA, nextB);
        if (pos == 1e9)
            break;
        if (nextA == pos) {
            if (!inA)
                inA = true;
            else {
                inA = false;
                iA++;
            }
        }
        if (nextB == pos) {
            if (!inB)
                inB = true;
            else {
                inB = false;
                iB++;
            }
        }
    }
    return result;
}
// Given a number of fragments for the outer tree, and a set of ranges
// to parse, find fragments for inner trees mounted around those
// ranges, if any.
function enterFragments(mounts, ranges) {
    let result = [];
    for (let { pos, mount, frag } of mounts) {
        let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;
        let from = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);
        if (mount.overlay) {
            let overlay = mount.overlay.map(r => new Range(r.from + pos, r.to + pos));
            let changes = findCoverChanges(ranges, overlay, from, to);
            for (let i = 0, pos = from;; i++) {
                let last = i == changes.length, end = last ? to : changes[i].from;
                if (end > pos)
                    result.push(new TreeFragment(pos, end, mount.tree, -startPos, frag.from >= pos, frag.to <= end));
                if (last)
                    break;
                pos = changes[i].to;
            }
        }
        else {
            result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos, frag.to <= endPos));
        }
    }
    return result;
}




/***/ }),

/***/ "./.yarn/cache/@lezer-lr-npm-0.15.8-8c481c39cd-e741225d6a.zip/node_modules/@lezer/lr/dist/index.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ContextTracker": () => (/* binding */ ContextTracker),
/* harmony export */   "ExternalTokenizer": () => (/* binding */ ExternalTokenizer),
/* harmony export */   "InputStream": () => (/* binding */ InputStream),
/* harmony export */   "LRParser": () => (/* binding */ LRParser),
/* harmony export */   "Stack": () => (/* binding */ Stack)
/* harmony export */ });
/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@lezer-common-npm-0.15.12-62017272b0-dae6581618.zip/node_modules/@lezer/common/dist/index.js");


/// A parse stack. These are used internally by the parser to track
/// parsing progress. They also provide some properties and methods
/// that external code such as a tokenizer can use to get information
/// about the parse state.
class Stack {
    /// @internal
    constructor(
    /// The parse that this stack is part of @internal
    p, 
    /// Holds state, input pos, buffer index triplets for all but the
    /// top state @internal
    stack, 
    /// The current parse state @internal
    state, 
    // The position at which the next reduce should take place. This
    // can be less than `this.pos` when skipped expressions have been
    // added to the stack (which should be moved outside of the next
    // reduction)
    /// @internal
    reducePos, 
    /// The input position up to which this stack has parsed.
    pos, 
    /// The dynamic score of the stack, including dynamic precedence
    /// and error-recovery penalties
    /// @internal
    score, 
    // The output buffer. Holds (type, start, end, size) quads
    // representing nodes created by the parser, where `size` is
    // amount of buffer array entries covered by this node.
    /// @internal
    buffer, 
    // The base offset of the buffer. When stacks are split, the split
    // instance shared the buffer history with its parent up to
    // `bufferBase`, which is the absolute offset (including the
    // offset of previous splits) into the buffer at which this stack
    // starts writing.
    /// @internal
    bufferBase, 
    /// @internal
    curContext, 
    /// @internal
    lookAhead = 0, 
    // A parent stack from which this was split off, if any. This is
    // set up so that it always points to a stack that has some
    // additional buffer content, never to a stack with an equal
    // `bufferBase`.
    /// @internal
    parent) {
        this.p = p;
        this.stack = stack;
        this.state = state;
        this.reducePos = reducePos;
        this.pos = pos;
        this.score = score;
        this.buffer = buffer;
        this.bufferBase = bufferBase;
        this.curContext = curContext;
        this.lookAhead = lookAhead;
        this.parent = parent;
    }
    /// @internal
    toString() {
        return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
    }
    // Start an empty stack
    /// @internal
    static start(p, state, pos = 0) {
        let cx = p.parser.context;
        return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);
    }
    /// The stack's current [context](#lr.ContextTracker) value, if
    /// any. Its type will depend on the context tracker's type
    /// parameter, or it will be `null` if there is no context
    /// tracker.
    get context() { return this.curContext ? this.curContext.context : null; }
    // Push a state onto the stack, tracking its start position as well
    // as the buffer base at that point.
    /// @internal
    pushState(state, start) {
        this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
        this.state = state;
    }
    // Apply a reduce action
    /// @internal
    reduce(action) {
        let depth = action >> 19 /* ReduceDepthShift */, type = action & 65535 /* ValueMask */;
        let { parser } = this.p;
        let dPrec = parser.dynamicPrecedence(type);
        if (dPrec)
            this.score += dPrec;
        if (depth == 0) {
            this.pushState(parser.getGoto(this.state, type, true), this.reducePos);
            // Zero-depth reductions are a special case—they add stuff to
            // the stack without popping anything off.
            if (type < parser.minRepeatTerm)
                this.storeNode(type, this.reducePos, this.reducePos, 4, true);
            this.reduceContext(type, this.reducePos);
            return;
        }
        // Find the base index into `this.stack`, content after which will
        // be dropped. Note that with `StayFlag` reductions we need to
        // consume two extra frames (the dummy parent node for the skipped
        // expression and the state that we'll be staying in, which should
        // be moved to `this.state`).
        let base = this.stack.length - ((depth - 1) * 3) - (action & 262144 /* StayFlag */ ? 6 : 0);
        let start = this.stack[base - 2];
        let bufferBase = this.stack[base - 1], count = this.bufferBase + this.buffer.length - bufferBase;
        // Store normal terms or `R -> R R` repeat reductions
        if (type < parser.minRepeatTerm || (action & 131072 /* RepeatFlag */)) {
            let pos = parser.stateFlag(this.state, 1 /* Skipped */) ? this.pos : this.reducePos;
            this.storeNode(type, start, pos, count + 4, true);
        }
        if (action & 262144 /* StayFlag */) {
            this.state = this.stack[base];
        }
        else {
            let baseStateID = this.stack[base - 3];
            this.state = parser.getGoto(baseStateID, type, true);
        }
        while (this.stack.length > base)
            this.stack.pop();
        this.reduceContext(type, start);
    }
    // Shift a value into the buffer
    /// @internal
    storeNode(term, start, end, size = 4, isReduce = false) {
        if (term == 0 /* Err */) { // Try to omit/merge adjacent error nodes
            let cur = this, top = this.buffer.length;
            if (top == 0 && cur.parent) {
                top = cur.bufferBase - cur.parent.bufferBase;
                cur = cur.parent;
            }
            if (top > 0 && cur.buffer[top - 4] == 0 /* Err */ && cur.buffer[top - 1] > -1) {
                if (start == end)
                    return;
                if (cur.buffer[top - 2] >= start) {
                    cur.buffer[top - 2] = end;
                    return;
                }
            }
        }
        if (!isReduce || this.pos == end) { // Simple case, just append
            this.buffer.push(term, start, end, size);
        }
        else { // There may be skipped nodes that have to be moved forward
            let index = this.buffer.length;
            if (index > 0 && this.buffer[index - 4] != 0 /* Err */)
                while (index > 0 && this.buffer[index - 2] > end) {
                    // Move this record forward
                    this.buffer[index] = this.buffer[index - 4];
                    this.buffer[index + 1] = this.buffer[index - 3];
                    this.buffer[index + 2] = this.buffer[index - 2];
                    this.buffer[index + 3] = this.buffer[index - 1];
                    index -= 4;
                    if (size > 4)
                        size -= 4;
                }
            this.buffer[index] = term;
            this.buffer[index + 1] = start;
            this.buffer[index + 2] = end;
            this.buffer[index + 3] = size;
        }
    }
    // Apply a shift action
    /// @internal
    shift(action, next, nextEnd) {
        let start = this.pos;
        if (action & 131072 /* GotoFlag */) {
            this.pushState(action & 65535 /* ValueMask */, this.pos);
        }
        else if ((action & 262144 /* StayFlag */) == 0) { // Regular shift
            let nextState = action, { parser } = this.p;
            if (nextEnd > this.pos || next <= parser.maxNode) {
                this.pos = nextEnd;
                if (!parser.stateFlag(nextState, 1 /* Skipped */))
                    this.reducePos = nextEnd;
            }
            this.pushState(nextState, start);
            this.shiftContext(next, start);
            if (next <= parser.maxNode)
                this.buffer.push(next, start, nextEnd, 4);
        }
        else { // Shift-and-stay, which means this is a skipped token
            this.pos = nextEnd;
            this.shiftContext(next, start);
            if (next <= this.p.parser.maxNode)
                this.buffer.push(next, start, nextEnd, 4);
        }
    }
    // Apply an action
    /// @internal
    apply(action, next, nextEnd) {
        if (action & 65536 /* ReduceFlag */)
            this.reduce(action);
        else
            this.shift(action, next, nextEnd);
    }
    // Add a prebuilt (reused) node into the buffer.
    /// @internal
    useNode(value, next) {
        let index = this.p.reused.length - 1;
        if (index < 0 || this.p.reused[index] != value) {
            this.p.reused.push(value);
            index++;
        }
        let start = this.pos;
        this.reducePos = this.pos = start + value.length;
        this.pushState(next, start);
        this.buffer.push(index, start, this.reducePos, -1 /* size == -1 means this is a reused value */);
        if (this.curContext)
            this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));
    }
    // Split the stack. Due to the buffer sharing and the fact
    // that `this.stack` tends to stay quite shallow, this isn't very
    // expensive.
    /// @internal
    split() {
        let parent = this;
        let off = parent.buffer.length;
        // Because the top of the buffer (after this.pos) may be mutated
        // to reorder reductions and skipped tokens, and shared buffers
        // should be immutable, this copies any outstanding skipped tokens
        // to the new buffer, and puts the base pointer before them.
        while (off > 0 && parent.buffer[off - 2] > parent.reducePos)
            off -= 4;
        let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;
        // Make sure parent points to an actual parent with content, if there is such a parent.
        while (parent && base == parent.bufferBase)
            parent = parent.parent;
        return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);
    }
    // Try to recover from an error by 'deleting' (ignoring) one token.
    /// @internal
    recoverByDelete(next, nextEnd) {
        let isNode = next <= this.p.parser.maxNode;
        if (isNode)
            this.storeNode(next, this.pos, nextEnd, 4);
        this.storeNode(0 /* Err */, this.pos, nextEnd, isNode ? 8 : 4);
        this.pos = this.reducePos = nextEnd;
        this.score -= 190 /* Delete */;
    }
    /// Check if the given term would be able to be shifted (optionally
    /// after some reductions) on this stack. This can be useful for
    /// external tokenizers that want to make sure they only provide a
    /// given token when it applies.
    canShift(term) {
        for (let sim = new SimulatedStack(this);;) {
            let action = this.p.parser.stateSlot(sim.state, 4 /* DefaultReduce */) || this.p.parser.hasAction(sim.state, term);
            if ((action & 65536 /* ReduceFlag */) == 0)
                return true;
            if (action == 0)
                return false;
            sim.reduce(action);
        }
    }
    // Apply up to Recover.MaxNext recovery actions that conceptually
    // inserts some missing token or rule.
    /// @internal
    recoverByInsert(next) {
        if (this.stack.length >= 300 /* MaxInsertStackDepth */)
            return [];
        let nextStates = this.p.parser.nextStates(this.state);
        if (nextStates.length > 4 /* MaxNext */ << 1 || this.stack.length >= 120 /* DampenInsertStackDepth */) {
            let best = [];
            for (let i = 0, s; i < nextStates.length; i += 2) {
                if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))
                    best.push(nextStates[i], s);
            }
            if (this.stack.length < 120 /* DampenInsertStackDepth */)
                for (let i = 0; best.length < 4 /* MaxNext */ << 1 && i < nextStates.length; i += 2) {
                    let s = nextStates[i + 1];
                    if (!best.some((v, i) => (i & 1) && v == s))
                        best.push(nextStates[i], s);
                }
            nextStates = best;
        }
        let result = [];
        for (let i = 0; i < nextStates.length && result.length < 4 /* MaxNext */; i += 2) {
            let s = nextStates[i + 1];
            if (s == this.state)
                continue;
            let stack = this.split();
            stack.storeNode(0 /* Err */, stack.pos, stack.pos, 4, true);
            stack.pushState(s, this.pos);
            stack.shiftContext(nextStates[i], this.pos);
            stack.score -= 200 /* Insert */;
            result.push(stack);
        }
        return result;
    }
    // Force a reduce, if possible. Return false if that can't
    // be done.
    /// @internal
    forceReduce() {
        let reduce = this.p.parser.stateSlot(this.state, 5 /* ForcedReduce */);
        if ((reduce & 65536 /* ReduceFlag */) == 0)
            return false;
        let { parser } = this.p;
        if (!parser.validAction(this.state, reduce)) {
            let depth = reduce >> 19 /* ReduceDepthShift */, term = reduce & 65535 /* ValueMask */;
            let target = this.stack.length - depth * 3;
            if (target < 0 || parser.getGoto(this.stack[target], term, false) < 0)
                return false;
            this.storeNode(0 /* Err */, this.reducePos, this.reducePos, 4, true);
            this.score -= 100 /* Reduce */;
        }
        this.reduce(reduce);
        return true;
    }
    /// @internal
    forceAll() {
        while (!this.p.parser.stateFlag(this.state, 2 /* Accepting */)) {
            if (!this.forceReduce()) {
                this.storeNode(0 /* Err */, this.pos, this.pos, 4, true);
                break;
            }
        }
        return this;
    }
    /// Check whether this state has no further actions (assumed to be a direct descendant of the
    /// top state, since any other states must be able to continue
    /// somehow). @internal
    get deadEnd() {
        if (this.stack.length != 3)
            return false;
        let { parser } = this.p;
        return parser.data[parser.stateSlot(this.state, 1 /* Actions */)] == 65535 /* End */ &&
            !parser.stateSlot(this.state, 4 /* DefaultReduce */);
    }
    /// Restart the stack (put it back in its start state). Only safe
    /// when this.stack.length == 3 (state is directly below the top
    /// state). @internal
    restart() {
        this.state = this.stack[0];
        this.stack.length = 0;
    }
    /// @internal
    sameState(other) {
        if (this.state != other.state || this.stack.length != other.stack.length)
            return false;
        for (let i = 0; i < this.stack.length; i += 3)
            if (this.stack[i] != other.stack[i])
                return false;
        return true;
    }
    /// Get the parser used by this stack.
    get parser() { return this.p.parser; }
    /// Test whether a given dialect (by numeric ID, as exported from
    /// the terms file) is enabled.
    dialectEnabled(dialectID) { return this.p.parser.dialect.flags[dialectID]; }
    shiftContext(term, start) {
        if (this.curContext)
            this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));
    }
    reduceContext(term, start) {
        if (this.curContext)
            this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));
    }
    /// @internal
    emitContext() {
        let last = this.buffer.length - 1;
        if (last < 0 || this.buffer[last] != -3)
            this.buffer.push(this.curContext.hash, this.reducePos, this.reducePos, -3);
    }
    /// @internal
    emitLookAhead() {
        let last = this.buffer.length - 1;
        if (last < 0 || this.buffer[last] != -4)
            this.buffer.push(this.lookAhead, this.reducePos, this.reducePos, -4);
    }
    updateContext(context) {
        if (context != this.curContext.context) {
            let newCx = new StackContext(this.curContext.tracker, context);
            if (newCx.hash != this.curContext.hash)
                this.emitContext();
            this.curContext = newCx;
        }
    }
    /// @internal
    setLookAhead(lookAhead) {
        if (lookAhead > this.lookAhead) {
            this.emitLookAhead();
            this.lookAhead = lookAhead;
        }
    }
    /// @internal
    close() {
        if (this.curContext && this.curContext.tracker.strict)
            this.emitContext();
        if (this.lookAhead > 0)
            this.emitLookAhead();
    }
}
class StackContext {
    constructor(tracker, context) {
        this.tracker = tracker;
        this.context = context;
        this.hash = tracker.strict ? tracker.hash(context) : 0;
    }
}
var Recover;
(function (Recover) {
    Recover[Recover["Insert"] = 200] = "Insert";
    Recover[Recover["Delete"] = 190] = "Delete";
    Recover[Recover["Reduce"] = 100] = "Reduce";
    Recover[Recover["MaxNext"] = 4] = "MaxNext";
    Recover[Recover["MaxInsertStackDepth"] = 300] = "MaxInsertStackDepth";
    Recover[Recover["DampenInsertStackDepth"] = 120] = "DampenInsertStackDepth";
})(Recover || (Recover = {}));
// Used to cheaply run some reductions to scan ahead without mutating
// an entire stack
class SimulatedStack {
    constructor(start) {
        this.start = start;
        this.state = start.state;
        this.stack = start.stack;
        this.base = this.stack.length;
    }
    reduce(action) {
        let term = action & 65535 /* ValueMask */, depth = action >> 19 /* ReduceDepthShift */;
        if (depth == 0) {
            if (this.stack == this.start.stack)
                this.stack = this.stack.slice();
            this.stack.push(this.state, 0, 0);
            this.base += 3;
        }
        else {
            this.base -= (depth - 1) * 3;
        }
        let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);
        this.state = goto;
    }
}
// This is given to `Tree.build` to build a buffer, and encapsulates
// the parent-stack-walking necessary to read the nodes.
class StackBufferCursor {
    constructor(stack, pos, index) {
        this.stack = stack;
        this.pos = pos;
        this.index = index;
        this.buffer = stack.buffer;
        if (this.index == 0)
            this.maybeNext();
    }
    static create(stack, pos = stack.bufferBase + stack.buffer.length) {
        return new StackBufferCursor(stack, pos, pos - stack.bufferBase);
    }
    maybeNext() {
        let next = this.stack.parent;
        if (next != null) {
            this.index = this.stack.bufferBase - next.bufferBase;
            this.stack = next;
            this.buffer = next.buffer;
        }
    }
    get id() { return this.buffer[this.index - 4]; }
    get start() { return this.buffer[this.index - 3]; }
    get end() { return this.buffer[this.index - 2]; }
    get size() { return this.buffer[this.index - 1]; }
    next() {
        this.index -= 4;
        this.pos -= 4;
        if (this.index == 0)
            this.maybeNext();
    }
    fork() {
        return new StackBufferCursor(this.stack, this.pos, this.index);
    }
}

class CachedToken {
    constructor() {
        this.start = -1;
        this.value = -1;
        this.end = -1;
        this.extended = -1;
        this.lookAhead = 0;
        this.mask = 0;
        this.context = 0;
    }
}
const nullToken = new CachedToken;
/// [Tokenizers](#lr.ExternalTokenizer) interact with the input
/// through this interface. It presents the input as a stream of
/// characters, tracking lookahead and hiding the complexity of
/// [ranges](#common.Parser.parse^ranges) from tokenizer code.
class InputStream {
    /// @internal
    constructor(
    /// @internal
    input, 
    /// @internal
    ranges) {
        this.input = input;
        this.ranges = ranges;
        /// @internal
        this.chunk = "";
        /// @internal
        this.chunkOff = 0;
        /// Backup chunk
        this.chunk2 = "";
        this.chunk2Pos = 0;
        /// The character code of the next code unit in the input, or -1
        /// when the stream is at the end of the input.
        this.next = -1;
        /// @internal
        this.token = nullToken;
        this.rangeIndex = 0;
        this.pos = this.chunkPos = ranges[0].from;
        this.range = ranges[0];
        this.end = ranges[ranges.length - 1].to;
        this.readNext();
    }
    resolveOffset(offset, assoc) {
        let range = this.range, index = this.rangeIndex;
        let pos = this.pos + offset;
        while (pos < range.from) {
            if (!index)
                return null;
            let next = this.ranges[--index];
            pos -= range.from - next.to;
            range = next;
        }
        while (assoc < 0 ? pos > range.to : pos >= range.to) {
            if (index == this.ranges.length - 1)
                return null;
            let next = this.ranges[++index];
            pos += next.from - range.to;
            range = next;
        }
        return pos;
    }
    /// Look at a code unit near the stream position. `.peek(0)` equals
    /// `.next`, `.peek(-1)` gives you the previous character, and so
    /// on.
    ///
    /// Note that looking around during tokenizing creates dependencies
    /// on potentially far-away content, which may reduce the
    /// effectiveness incremental parsing—when looking forward—or even
    /// cause invalid reparses when looking backward more than 25 code
    /// units, since the library does not track lookbehind.
    peek(offset) {
        let idx = this.chunkOff + offset, pos, result;
        if (idx >= 0 && idx < this.chunk.length) {
            pos = this.pos + offset;
            result = this.chunk.charCodeAt(idx);
        }
        else {
            let resolved = this.resolveOffset(offset, 1);
            if (resolved == null)
                return -1;
            pos = resolved;
            if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
                result = this.chunk2.charCodeAt(pos - this.chunk2Pos);
            }
            else {
                let i = this.rangeIndex, range = this.range;
                while (range.to <= pos)
                    range = this.ranges[++i];
                this.chunk2 = this.input.chunk(this.chunk2Pos = pos);
                if (pos + this.chunk2.length > range.to)
                    this.chunk2 = this.chunk2.slice(0, range.to - pos);
                result = this.chunk2.charCodeAt(0);
            }
        }
        if (pos >= this.token.lookAhead)
            this.token.lookAhead = pos + 1;
        return result;
    }
    /// Accept a token. By default, the end of the token is set to the
    /// current stream position, but you can pass an offset (relative to
    /// the stream position) to change that.
    acceptToken(token, endOffset = 0) {
        let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;
        if (end == null || end < this.token.start)
            throw new RangeError("Token end out of bounds");
        this.token.value = token;
        this.token.end = end;
    }
    getChunk() {
        if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
            let { chunk, chunkPos } = this;
            this.chunk = this.chunk2;
            this.chunkPos = this.chunk2Pos;
            this.chunk2 = chunk;
            this.chunk2Pos = chunkPos;
            this.chunkOff = this.pos - this.chunkPos;
        }
        else {
            this.chunk2 = this.chunk;
            this.chunk2Pos = this.chunkPos;
            let nextChunk = this.input.chunk(this.pos);
            let end = this.pos + nextChunk.length;
            this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;
            this.chunkPos = this.pos;
            this.chunkOff = 0;
        }
    }
    readNext() {
        if (this.chunkOff >= this.chunk.length) {
            this.getChunk();
            if (this.chunkOff == this.chunk.length)
                return this.next = -1;
        }
        return this.next = this.chunk.charCodeAt(this.chunkOff);
    }
    /// Move the stream forward N (defaults to 1) code units. Returns
    /// the new value of [`next`](#lr.InputStream.next).
    advance(n = 1) {
        this.chunkOff += n;
        while (this.pos + n >= this.range.to) {
            if (this.rangeIndex == this.ranges.length - 1)
                return this.setDone();
            n -= this.range.to - this.pos;
            this.range = this.ranges[++this.rangeIndex];
            this.pos = this.range.from;
        }
        this.pos += n;
        if (this.pos >= this.token.lookAhead)
            this.token.lookAhead = this.pos + 1;
        return this.readNext();
    }
    setDone() {
        this.pos = this.chunkPos = this.end;
        this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];
        this.chunk = "";
        return this.next = -1;
    }
    /// @internal
    reset(pos, token) {
        if (token) {
            this.token = token;
            token.start = pos;
            token.lookAhead = pos + 1;
            token.value = token.extended = -1;
        }
        else {
            this.token = nullToken;
        }
        if (this.pos != pos) {
            this.pos = pos;
            if (pos == this.end) {
                this.setDone();
                return this;
            }
            while (pos < this.range.from)
                this.range = this.ranges[--this.rangeIndex];
            while (pos >= this.range.to)
                this.range = this.ranges[++this.rangeIndex];
            if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
                this.chunkOff = pos - this.chunkPos;
            }
            else {
                this.chunk = "";
                this.chunkOff = 0;
            }
            this.readNext();
        }
        return this;
    }
    /// @internal
    read(from, to) {
        if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)
            return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);
        if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)
            return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);
        if (from >= this.range.from && to <= this.range.to)
            return this.input.read(from, to);
        let result = "";
        for (let r of this.ranges) {
            if (r.from >= to)
                break;
            if (r.to > from)
                result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));
        }
        return result;
    }
}
/// @internal
class TokenGroup {
    constructor(data, id) {
        this.data = data;
        this.id = id;
    }
    token(input, stack) { readToken(this.data, input, stack, this.id); }
}
TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
/// `@external tokens` declarations in the grammar should resolve to
/// an instance of this class.
class ExternalTokenizer {
    /// Create a tokenizer. The first argument is the function that,
    /// given an input stream, scans for the types of tokens it
    /// recognizes at the stream's position, and calls
    /// [`acceptToken`](#lr.InputStream.acceptToken) when it finds
    /// one.
    constructor(
    /// @internal
    token, options = {}) {
        this.token = token;
        this.contextual = !!options.contextual;
        this.fallback = !!options.fallback;
        this.extend = !!options.extend;
    }
}
// Tokenizer data is stored a big uint16 array containing, for each
// state:
//
//  - A group bitmask, indicating what token groups are reachable from
//    this state, so that paths that can only lead to tokens not in
//    any of the current groups can be cut off early.
//
//  - The position of the end of the state's sequence of accepting
//    tokens
//
//  - The number of outgoing edges for the state
//
//  - The accepting tokens, as (token id, group mask) pairs
//
//  - The outgoing edges, as (start character, end character, state
//    index) triples, with end character being exclusive
//
// This function interprets that data, running through a stream as
// long as new states with the a matching group mask can be reached,
// and updating `token` when it matches a token.
function readToken(data, input, stack, group) {
    let state = 0, groupMask = 1 << group, { parser } = stack.p, { dialect } = parser;
    scan: for (;;) {
        if ((groupMask & data[state]) == 0)
            break;
        let accEnd = data[state + 1];
        // Check whether this state can lead to a token in the current group
        // Accept tokens in this state, possibly overwriting
        // lower-precedence / shorter tokens
        for (let i = state + 3; i < accEnd; i += 2)
            if ((data[i + 1] & groupMask) > 0) {
                let term = data[i];
                if (dialect.allows(term) &&
                    (input.token.value == -1 || input.token.value == term || parser.overrides(term, input.token.value))) {
                    input.acceptToken(term);
                    break;
                }
            }
        // Do a binary search on the state's edges
        for (let next = input.next, low = 0, high = data[state + 2]; low < high;) {
            let mid = (low + high) >> 1;
            let index = accEnd + mid + (mid << 1);
            let from = data[index], to = data[index + 1];
            if (next < from)
                high = mid;
            else if (next >= to)
                low = mid + 1;
            else {
                state = data[index + 2];
                input.advance();
                continue scan;
            }
        }
        break;
    }
}

// See lezer-generator/src/encode.ts for comments about the encoding
// used here
function decodeArray(input, Type = Uint16Array) {
    if (typeof input != "string")
        return input;
    let array = null;
    for (let pos = 0, out = 0; pos < input.length;) {
        let value = 0;
        for (;;) {
            let next = input.charCodeAt(pos++), stop = false;
            if (next == 126 /* BigValCode */) {
                value = 65535 /* BigVal */;
                break;
            }
            if (next >= 92 /* Gap2 */)
                next--;
            if (next >= 34 /* Gap1 */)
                next--;
            let digit = next - 32 /* Start */;
            if (digit >= 46 /* Base */) {
                digit -= 46 /* Base */;
                stop = true;
            }
            value += digit;
            if (stop)
                break;
            value *= 46 /* Base */;
        }
        if (array)
            array[out++] = value;
        else
            array = new Type(value);
    }
    return array;
}

// FIXME find some way to reduce recovery work done when the input
// doesn't match the grammar at all.
// Environment variable used to control console output
const verbose = typeof process != "undefined" && /\bparse\b/.test(({"NODE_ENV":"development"}).LOG);
let stackIDs = null;
var Safety;
(function (Safety) {
    Safety[Safety["Margin"] = 25] = "Margin";
})(Safety || (Safety = {}));
function cutAt(tree, pos, side) {
    let cursor = tree.fullCursor();
    cursor.moveTo(pos);
    for (;;) {
        if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))
            for (;;) {
                if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)
                    return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25 /* Margin */))
                        : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25 /* Margin */));
                if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())
                    break;
                if (!cursor.parent())
                    return side < 0 ? 0 : tree.length;
            }
    }
}
class FragmentCursor {
    constructor(fragments, nodeSet) {
        this.fragments = fragments;
        this.nodeSet = nodeSet;
        this.i = 0;
        this.fragment = null;
        this.safeFrom = -1;
        this.safeTo = -1;
        this.trees = [];
        this.start = [];
        this.index = [];
        this.nextFragment();
    }
    nextFragment() {
        let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
        if (fr) {
            this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
            this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
            while (this.trees.length) {
                this.trees.pop();
                this.start.pop();
                this.index.pop();
            }
            this.trees.push(fr.tree);
            this.start.push(-fr.offset);
            this.index.push(0);
            this.nextStart = this.safeFrom;
        }
        else {
            this.nextStart = 1e9;
        }
    }
    // `pos` must be >= any previously given `pos` for this cursor
    nodeAt(pos) {
        if (pos < this.nextStart)
            return null;
        while (this.fragment && this.safeTo <= pos)
            this.nextFragment();
        if (!this.fragment)
            return null;
        for (;;) {
            let last = this.trees.length - 1;
            if (last < 0) { // End of tree
                this.nextFragment();
                return null;
            }
            let top = this.trees[last], index = this.index[last];
            if (index == top.children.length) {
                this.trees.pop();
                this.start.pop();
                this.index.pop();
                continue;
            }
            let next = top.children[index];
            let start = this.start[last] + top.positions[index];
            if (start > pos) {
                this.nextStart = start;
                return null;
            }
            if (next instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) {
                if (start == pos) {
                    if (start < this.safeFrom)
                        return null;
                    let end = start + next.length;
                    if (end <= this.safeTo) {
                        let lookAhead = next.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.lookAhead);
                        if (!lookAhead || end + lookAhead < this.fragment.to)
                            return next;
                    }
                }
                this.index[last]++;
                if (start + next.length >= Math.max(this.safeFrom, pos)) { // Enter this node
                    this.trees.push(next);
                    this.start.push(start);
                    this.index.push(0);
                }
            }
            else {
                this.index[last]++;
                this.nextStart = start + next.length;
            }
        }
    }
}
class TokenCache {
    constructor(parser, stream) {
        this.stream = stream;
        this.tokens = [];
        this.mainToken = null;
        this.actions = [];
        this.tokens = parser.tokenizers.map(_ => new CachedToken);
    }
    getActions(stack) {
        let actionIndex = 0;
        let main = null;
        let { parser } = stack.p, { tokenizers } = parser;
        let mask = parser.stateSlot(stack.state, 3 /* TokenizerMask */);
        let context = stack.curContext ? stack.curContext.hash : 0;
        let lookAhead = 0;
        for (let i = 0; i < tokenizers.length; i++) {
            if (((1 << i) & mask) == 0)
                continue;
            let tokenizer = tokenizers[i], token = this.tokens[i];
            if (main && !tokenizer.fallback)
                continue;
            if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {
                this.updateCachedToken(token, tokenizer, stack);
                token.mask = mask;
                token.context = context;
            }
            if (token.lookAhead > token.end + 25 /* Margin */)
                lookAhead = Math.max(token.lookAhead, lookAhead);
            if (token.value != 0 /* Err */) {
                let startIndex = actionIndex;
                if (token.extended > -1)
                    actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
                actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
                if (!tokenizer.extend) {
                    main = token;
                    if (actionIndex > startIndex)
                        break;
                }
            }
        }
        while (this.actions.length > actionIndex)
            this.actions.pop();
        if (lookAhead)
            stack.setLookAhead(lookAhead);
        if (!main && stack.pos == this.stream.end) {
            main = new CachedToken;
            main.value = stack.p.parser.eofTerm;
            main.start = main.end = stack.pos;
            actionIndex = this.addActions(stack, main.value, main.end, actionIndex);
        }
        this.mainToken = main;
        return this.actions;
    }
    getMainToken(stack) {
        if (this.mainToken)
            return this.mainToken;
        let main = new CachedToken, { pos, p } = stack;
        main.start = pos;
        main.end = Math.min(pos + 1, p.stream.end);
        main.value = pos == p.stream.end ? p.parser.eofTerm : 0 /* Err */;
        return main;
    }
    updateCachedToken(token, tokenizer, stack) {
        tokenizer.token(this.stream.reset(stack.pos, token), stack);
        if (token.value > -1) {
            let { parser } = stack.p;
            for (let i = 0; i < parser.specialized.length; i++)
                if (parser.specialized[i] == token.value) {
                    let result = parser.specializers[i](this.stream.read(token.start, token.end), stack);
                    if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
                        if ((result & 1) == 0 /* Specialize */)
                            token.value = result >> 1;
                        else
                            token.extended = result >> 1;
                        break;
                    }
                }
        }
        else {
            token.value = 0 /* Err */;
            token.end = Math.min(stack.p.stream.end, stack.pos + 1);
        }
    }
    putAction(action, token, end, index) {
        // Don't add duplicate actions
        for (let i = 0; i < index; i += 3)
            if (this.actions[i] == action)
                return index;
        this.actions[index++] = action;
        this.actions[index++] = token;
        this.actions[index++] = end;
        return index;
    }
    addActions(stack, token, end, index) {
        let { state } = stack, { parser } = stack.p, { data } = parser;
        for (let set = 0; set < 2; set++) {
            for (let i = parser.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */);; i += 3) {
                if (data[i] == 65535 /* End */) {
                    if (data[i + 1] == 1 /* Next */) {
                        i = pair(data, i + 2);
                    }
                    else {
                        if (index == 0 && data[i + 1] == 2 /* Other */)
                            index = this.putAction(pair(data, i + 2), token, end, index);
                        break;
                    }
                }
                if (data[i] == token)
                    index = this.putAction(pair(data, i + 1), token, end, index);
            }
        }
        return index;
    }
}
var Rec;
(function (Rec) {
    Rec[Rec["Distance"] = 5] = "Distance";
    Rec[Rec["MaxRemainingPerStep"] = 3] = "MaxRemainingPerStep";
    // When two stacks have been running independently long enough to
    // add this many elements to their buffers, prune one.
    Rec[Rec["MinBufferLengthPrune"] = 500] = "MinBufferLengthPrune";
    Rec[Rec["ForceReduceLimit"] = 10] = "ForceReduceLimit";
    // Once a stack reaches this depth (in .stack.length) force-reduce
    // it back to CutTo to avoid creating trees that overflow the stack
    // on recursive traversal.
    Rec[Rec["CutDepth"] = 15000] = "CutDepth";
    Rec[Rec["CutTo"] = 9000] = "CutTo";
})(Rec || (Rec = {}));
class Parse {
    constructor(parser, input, fragments, ranges) {
        this.parser = parser;
        this.input = input;
        this.ranges = ranges;
        this.recovering = 0;
        this.nextStackID = 0x2654; // ♔, ♕, ♖, ♗, ♘, ♙, ♠, ♡, ♢, ♣, ♤, ♥, ♦, ♧
        this.minStackPos = 0;
        this.reused = [];
        this.stoppedAt = null;
        this.stream = new InputStream(input, ranges);
        this.tokens = new TokenCache(parser, this.stream);
        this.topTerm = parser.top[1];
        let { from } = ranges[0];
        this.stacks = [Stack.start(this, parser.top[0], from)];
        this.fragments = fragments.length && this.stream.end - from > parser.bufferLength * 4
            ? new FragmentCursor(fragments, parser.nodeSet) : null;
    }
    get parsedPos() {
        return this.minStackPos;
    }
    // Move the parser forward. This will process all parse stacks at
    // `this.pos` and try to advance them to a further position. If no
    // stack for such a position is found, it'll start error-recovery.
    //
    // When the parse is finished, this will return a syntax tree. When
    // not, it returns `null`.
    advance() {
        let stacks = this.stacks, pos = this.minStackPos;
        // This will hold stacks beyond `pos`.
        let newStacks = this.stacks = [];
        let stopped, stoppedTokens;
        // Keep advancing any stacks at `pos` until they either move
        // forward or can't be advanced. Gather stacks that can't be
        // advanced further in `stopped`.
        for (let i = 0; i < stacks.length; i++) {
            let stack = stacks[i];
            for (;;) {
                this.tokens.mainToken = null;
                if (stack.pos > pos) {
                    newStacks.push(stack);
                }
                else if (this.advanceStack(stack, newStacks, stacks)) {
                    continue;
                }
                else {
                    if (!stopped) {
                        stopped = [];
                        stoppedTokens = [];
                    }
                    stopped.push(stack);
                    let tok = this.tokens.getMainToken(stack);
                    stoppedTokens.push(tok.value, tok.end);
                }
                break;
            }
        }
        if (!newStacks.length) {
            let finished = stopped && findFinished(stopped);
            if (finished)
                return this.stackToTree(finished);
            if (this.parser.strict) {
                if (verbose && stopped)
                    console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"));
                throw new SyntaxError("No parse at " + pos);
            }
            if (!this.recovering)
                this.recovering = 5 /* Distance */;
        }
        if (this.recovering && stopped) {
            let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0]
                : this.runRecovery(stopped, stoppedTokens, newStacks);
            if (finished)
                return this.stackToTree(finished.forceAll());
        }
        if (this.recovering) {
            let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3 /* MaxRemainingPerStep */;
            if (newStacks.length > maxRemaining) {
                newStacks.sort((a, b) => b.score - a.score);
                while (newStacks.length > maxRemaining)
                    newStacks.pop();
            }
            if (newStacks.some(s => s.reducePos > pos))
                this.recovering--;
        }
        else if (newStacks.length > 1) {
            // Prune stacks that are in the same state, or that have been
            // running without splitting for a while, to avoid getting stuck
            // with multiple successful stacks running endlessly on.
            outer: for (let i = 0; i < newStacks.length - 1; i++) {
                let stack = newStacks[i];
                for (let j = i + 1; j < newStacks.length; j++) {
                    let other = newStacks[j];
                    if (stack.sameState(other) ||
                        stack.buffer.length > 500 /* MinBufferLengthPrune */ && other.buffer.length > 500 /* MinBufferLengthPrune */) {
                        if (((stack.score - other.score) || (stack.buffer.length - other.buffer.length)) > 0) {
                            newStacks.splice(j--, 1);
                        }
                        else {
                            newStacks.splice(i--, 1);
                            continue outer;
                        }
                    }
                }
            }
        }
        this.minStackPos = newStacks[0].pos;
        for (let i = 1; i < newStacks.length; i++)
            if (newStacks[i].pos < this.minStackPos)
                this.minStackPos = newStacks[i].pos;
        return null;
    }
    stopAt(pos) {
        if (this.stoppedAt != null && this.stoppedAt < pos)
            throw new RangeError("Can't move stoppedAt forward");
        this.stoppedAt = pos;
    }
    // Returns an updated version of the given stack, or null if the
    // stack can't advance normally. When `split` and `stacks` are
    // given, stacks split off by ambiguous operations will be pushed to
    // `split`, or added to `stacks` if they move `pos` forward.
    advanceStack(stack, stacks, split) {
        let start = stack.pos, { parser } = this;
        let base = verbose ? this.stackID(stack) + " -> " : "";
        if (this.stoppedAt != null && start > this.stoppedAt)
            return stack.forceReduce() ? stack : null;
        if (this.fragments) {
            let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;
            for (let cached = this.fragments.nodeAt(start); cached;) {
                let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;
                if (match > -1 && cached.length && (!strictCx || (cached.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.contextHash) || 0) == cxHash)) {
                    stack.useNode(cached, match);
                    if (verbose)
                        console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);
                    return true;
                }
                if (!(cached instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) || cached.children.length == 0 || cached.positions[0] > 0)
                    break;
                let inner = cached.children[0];
                if (inner instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree && cached.positions[0] == 0)
                    cached = inner;
                else
                    break;
            }
        }
        let defaultReduce = parser.stateSlot(stack.state, 4 /* DefaultReduce */);
        if (defaultReduce > 0) {
            stack.reduce(defaultReduce);
            if (verbose)
                console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535 /* ValueMask */)})`);
            return true;
        }
        if (stack.stack.length >= 15000 /* CutDepth */) {
            while (stack.stack.length > 9000 /* CutTo */ && stack.forceReduce()) { }
        }
        let actions = this.tokens.getActions(stack);
        for (let i = 0; i < actions.length;) {
            let action = actions[i++], term = actions[i++], end = actions[i++];
            let last = i == actions.length || !split;
            let localStack = last ? stack : stack.split();
            localStack.apply(action, term, end);
            if (verbose)
                console.log(base + this.stackID(localStack) + ` (via ${(action & 65536 /* ReduceFlag */) == 0 ? "shift"
                    : `reduce of ${parser.getName(action & 65535 /* ValueMask */)}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? "" : ", split"})`);
            if (last)
                return true;
            else if (localStack.pos > start)
                stacks.push(localStack);
            else
                split.push(localStack);
        }
        return false;
    }
    // Advance a given stack forward as far as it will go. Returns the
    // (possibly updated) stack if it got stuck, or null if it moved
    // forward and was given to `pushStackDedup`.
    advanceFully(stack, newStacks) {
        let pos = stack.pos;
        for (;;) {
            if (!this.advanceStack(stack, null, null))
                return false;
            if (stack.pos > pos) {
                pushStackDedup(stack, newStacks);
                return true;
            }
        }
    }
    runRecovery(stacks, tokens, newStacks) {
        let finished = null, restarted = false;
        for (let i = 0; i < stacks.length; i++) {
            let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];
            let base = verbose ? this.stackID(stack) + " -> " : "";
            if (stack.deadEnd) {
                if (restarted)
                    continue;
                restarted = true;
                stack.restart();
                if (verbose)
                    console.log(base + this.stackID(stack) + " (restarted)");
                let done = this.advanceFully(stack, newStacks);
                if (done)
                    continue;
            }
            let force = stack.split(), forceBase = base;
            for (let j = 0; force.forceReduce() && j < 10 /* ForceReduceLimit */; j++) {
                if (verbose)
                    console.log(forceBase + this.stackID(force) + " (via force-reduce)");
                let done = this.advanceFully(force, newStacks);
                if (done)
                    break;
                if (verbose)
                    forceBase = this.stackID(force) + " -> ";
            }
            for (let insert of stack.recoverByInsert(token)) {
                if (verbose)
                    console.log(base + this.stackID(insert) + " (via recover-insert)");
                this.advanceFully(insert, newStacks);
            }
            if (this.stream.end > stack.pos) {
                if (tokenEnd == stack.pos) {
                    tokenEnd++;
                    token = 0 /* Err */;
                }
                stack.recoverByDelete(token, tokenEnd);
                if (verbose)
                    console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
                pushStackDedup(stack, newStacks);
            }
            else if (!finished || finished.score < stack.score) {
                finished = stack;
            }
        }
        return finished;
    }
    // Convert the stack's buffer to a syntax tree.
    stackToTree(stack) {
        stack.close();
        return _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.build({ buffer: StackBufferCursor.create(stack),
            nodeSet: this.parser.nodeSet,
            topID: this.topTerm,
            maxBufferLength: this.parser.bufferLength,
            reused: this.reused,
            start: this.ranges[0].from,
            length: stack.pos - this.ranges[0].from,
            minRepeatType: this.parser.minRepeatTerm });
    }
    stackID(stack) {
        let id = (stackIDs || (stackIDs = new WeakMap)).get(stack);
        if (!id)
            stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));
        return id + stack;
    }
}
function pushStackDedup(stack, newStacks) {
    for (let i = 0; i < newStacks.length; i++) {
        let other = newStacks[i];
        if (other.pos == stack.pos && other.sameState(stack)) {
            if (newStacks[i].score < stack.score)
                newStacks[i] = stack;
            return;
        }
    }
    newStacks.push(stack);
}
class Dialect {
    constructor(source, flags, disabled) {
        this.source = source;
        this.flags = flags;
        this.disabled = disabled;
    }
    allows(term) { return !this.disabled || this.disabled[term] == 0; }
}
const id = x => x;
/// Context trackers are used to track stateful context (such as
/// indentation in the Python grammar, or parent elements in the XML
/// grammar) needed by external tokenizers. You declare them in a
/// grammar file as `@context exportName from "module"`.
///
/// Context values should be immutable, and can be updated (replaced)
/// on shift or reduce actions.
///
/// The export used in a `@context` declaration should be of this
/// type.
class ContextTracker {
    /// Define a context tracker.
    constructor(spec) {
        this.start = spec.start;
        this.shift = spec.shift || id;
        this.reduce = spec.reduce || id;
        this.reuse = spec.reuse || id;
        this.hash = spec.hash || (() => 0);
        this.strict = spec.strict !== false;
    }
}
/// A parser holds the parse tables for a given grammar, as generated
/// by `lezer-generator`.
class LRParser extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {
    /// @internal
    constructor(spec) {
        super();
        /// @internal
        this.wrappers = [];
        if (spec.version != 13 /* Version */)
            throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${13 /* Version */})`);
        let nodeNames = spec.nodeNames.split(" ");
        this.minRepeatTerm = nodeNames.length;
        for (let i = 0; i < spec.repeatNodeCount; i++)
            nodeNames.push("");
        let topTerms = Object.keys(spec.topRules).map(r => spec.topRules[r][1]);
        let nodeProps = [];
        for (let i = 0; i < nodeNames.length; i++)
            nodeProps.push([]);
        function setProp(nodeID, prop, value) {
            nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
        }
        if (spec.nodeProps)
            for (let propSpec of spec.nodeProps) {
                let prop = propSpec[0];
                for (let i = 1; i < propSpec.length;) {
                    let next = propSpec[i++];
                    if (next >= 0) {
                        setProp(next, prop, propSpec[i++]);
                    }
                    else {
                        let value = propSpec[i + -next];
                        for (let j = -next; j > 0; j--)
                            setProp(propSpec[i++], prop, value);
                        i++;
                    }
                }
            }
        this.nodeSet = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeSet(nodeNames.map((name, i) => _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({
            name: i >= this.minRepeatTerm ? undefined : name,
            id: i,
            props: nodeProps[i],
            top: topTerms.indexOf(i) > -1,
            error: i == 0,
            skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1
        })));
        this.strict = false;
        this.bufferLength = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.DefaultBufferLength;
        let tokenArray = decodeArray(spec.tokenData);
        this.context = spec.context;
        this.specialized = new Uint16Array(spec.specialized ? spec.specialized.length : 0);
        this.specializers = [];
        if (spec.specialized)
            for (let i = 0; i < spec.specialized.length; i++) {
                this.specialized[i] = spec.specialized[i].term;
                this.specializers[i] = spec.specialized[i].get;
            }
        this.states = decodeArray(spec.states, Uint32Array);
        this.data = decodeArray(spec.stateData);
        this.goto = decodeArray(spec.goto);
        this.maxTerm = spec.maxTerm;
        this.tokenizers = spec.tokenizers.map(value => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
        this.topRules = spec.topRules;
        this.dialects = spec.dialects || {};
        this.dynamicPrecedences = spec.dynamicPrecedences || null;
        this.tokenPrecTable = spec.tokenPrec;
        this.termNames = spec.termNames || null;
        this.maxNode = this.nodeSet.types.length - 1;
        this.dialect = this.parseDialect();
        this.top = this.topRules[Object.keys(this.topRules)[0]];
    }
    createParse(input, fragments, ranges) {
        let parse = new Parse(this, input, fragments, ranges);
        for (let w of this.wrappers)
            parse = w(parse, input, fragments, ranges);
        return parse;
    }
    /// Get a goto table entry @internal
    getGoto(state, term, loose = false) {
        let table = this.goto;
        if (term >= table[0])
            return -1;
        for (let pos = table[term + 1];;) {
            let groupTag = table[pos++], last = groupTag & 1;
            let target = table[pos++];
            if (last && loose)
                return target;
            for (let end = pos + (groupTag >> 1); pos < end; pos++)
                if (table[pos] == state)
                    return target;
            if (last)
                return -1;
        }
    }
    /// Check if this state has an action for a given terminal @internal
    hasAction(state, terminal) {
        let data = this.data;
        for (let set = 0; set < 2; set++) {
            for (let i = this.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */), next;; i += 3) {
                if ((next = data[i]) == 65535 /* End */) {
                    if (data[i + 1] == 1 /* Next */)
                        next = data[i = pair(data, i + 2)];
                    else if (data[i + 1] == 2 /* Other */)
                        return pair(data, i + 2);
                    else
                        break;
                }
                if (next == terminal || next == 0 /* Err */)
                    return pair(data, i + 1);
            }
        }
        return 0;
    }
    /// @internal
    stateSlot(state, slot) {
        return this.states[(state * 6 /* Size */) + slot];
    }
    /// @internal
    stateFlag(state, flag) {
        return (this.stateSlot(state, 0 /* Flags */) & flag) > 0;
    }
    /// @internal
    validAction(state, action) {
        if (action == this.stateSlot(state, 4 /* DefaultReduce */))
            return true;
        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {
            if (this.data[i] == 65535 /* End */) {
                if (this.data[i + 1] == 1 /* Next */)
                    i = pair(this.data, i + 2);
                else
                    return false;
            }
            if (action == pair(this.data, i + 1))
                return true;
        }
    }
    /// Get the states that can follow this one through shift actions or
    /// goto jumps. @internal
    nextStates(state) {
        let result = [];
        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {
            if (this.data[i] == 65535 /* End */) {
                if (this.data[i + 1] == 1 /* Next */)
                    i = pair(this.data, i + 2);
                else
                    break;
            }
            if ((this.data[i + 2] & (65536 /* ReduceFlag */ >> 16)) == 0) {
                let value = this.data[i + 1];
                if (!result.some((v, i) => (i & 1) && v == value))
                    result.push(this.data[i], value);
            }
        }
        return result;
    }
    /// @internal
    overrides(token, prev) {
        let iPrev = findOffset(this.data, this.tokenPrecTable, prev);
        return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev;
    }
    /// Configure the parser. Returns a new parser instance that has the
    /// given settings modified. Settings not provided in `config` are
    /// kept from the original parser.
    configure(config) {
        // Hideous reflection-based kludge to make it easy to create a
        // slightly modified copy of a parser.
        let copy = Object.assign(Object.create(LRParser.prototype), this);
        if (config.props)
            copy.nodeSet = this.nodeSet.extend(...config.props);
        if (config.top) {
            let info = this.topRules[config.top];
            if (!info)
                throw new RangeError(`Invalid top rule name ${config.top}`);
            copy.top = info;
        }
        if (config.tokenizers)
            copy.tokenizers = this.tokenizers.map(t => {
                let found = config.tokenizers.find(r => r.from == t);
                return found ? found.to : t;
            });
        if (config.contextTracker)
            copy.context = config.contextTracker;
        if (config.dialect)
            copy.dialect = this.parseDialect(config.dialect);
        if (config.strict != null)
            copy.strict = config.strict;
        if (config.wrap)
            copy.wrappers = copy.wrappers.concat(config.wrap);
        if (config.bufferLength != null)
            copy.bufferLength = config.bufferLength;
        return copy;
    }
    /// Returns the name associated with a given term. This will only
    /// work for all terms when the parser was generated with the
    /// `--names` option. By default, only the names of tagged terms are
    /// stored.
    getName(term) {
        return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
    }
    /// The eof term id is always allocated directly after the node
    /// types. @internal
    get eofTerm() { return this.maxNode + 1; }
    /// The type of top node produced by the parser.
    get topNode() { return this.nodeSet.types[this.top[1]]; }
    /// @internal
    dynamicPrecedence(term) {
        let prec = this.dynamicPrecedences;
        return prec == null ? 0 : prec[term] || 0;
    }
    /// @internal
    parseDialect(dialect) {
        let values = Object.keys(this.dialects), flags = values.map(() => false);
        if (dialect)
            for (let part of dialect.split(" ")) {
                let id = values.indexOf(part);
                if (id >= 0)
                    flags[id] = true;
            }
        let disabled = null;
        for (let i = 0; i < values.length; i++)
            if (!flags[i]) {
                for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535 /* End */;)
                    (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;
            }
        return new Dialect(dialect, flags, disabled);
    }
    /// (used by the output of the parser generator) @internal
    static deserialize(spec) {
        return new LRParser(spec);
    }
}
function pair(data, off) { return data[off] | (data[off + 1] << 16); }
function findOffset(data, start, term) {
    for (let i = start, next; (next = data[i]) != 65535 /* End */; i++)
        if (next == term)
            return i - start;
    return -1;
}
function findFinished(stacks) {
    let best = null;
    for (let stack of stacks) {
        let stopped = stack.p.stoppedAt;
        if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) &&
            stack.p.parser.stateFlag(stack.state, 2 /* Accepting */) &&
            (!best || best.score < stack.score))
            best = stack;
    }
    return best;
}




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0dBQUFBLHFDQUFBQTs7QUFVTCxJQUFLRCxlQUFaOztXQUFZQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtBQUFBQSxFQUFBQTtHQUFBQSxvQkFBQUE7O0FBc0RMLElBQUsySyxrQkFBWjs7V0FBWUE7QUFBQUEsRUFBQUEsbUJBQUFBO0FBQUFBLEVBQUFBLG1CQUFBQTtBQUFBQSxFQUFBQSxtQkFBQUE7QUFBQUEsRUFBQUEsbUJBQUFBO0FBQUFBLEVBQUFBLG1CQUFBQTtBQUFBQSxFQUFBQSxtQkFBQUE7QUFBQUEsRUFBQUEsbUJBQUFBO0dBQUFBLHVCQUFBQTs7Ozs7Ozs7Ozs7Ozs7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RUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEs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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxtQ0FBbUM7O0FBRXpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQix1QkFBdUI7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYywrQkFBK0IsSUFBSTtBQUNqRDtBQUNBLDhCQUE4QixNQUFNO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLCtCQUErQixJQUFJO0FBQ2xEO0FBQ0EsOEJBQThCLE1BQU07QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQyxrQkFBa0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSx1Q0FBdUMsSUFBSTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSwrQkFBK0IsSUFBSTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0EsMEJBQTBCLDJCQUEyQjtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNsTjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU2dkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5Tnh0Qzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFeUk7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RwRDFDOztBQUUvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJEQUEyRCxJQUFJLFNBQVMsRUFBRSxtQ0FBbUM7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQsc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsdUJBQXVCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDZEQUE2RDtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwREFBMEQ7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGtCQUFrQjtBQUNsQixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsU0FBUyxhQUFhLFVBQVU7QUFDN0UsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxZQUFZO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxXQUFXO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQkFBbUI7QUFDbEQ7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsNEJBQVc7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywrQ0FBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDZEQUFrQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVMsYUFBYSxhQUFhO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0IsNEJBQTRCLCtCQUErQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsV0FBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRLFdBQVcsU0FBUyxhQUFhLE9BQU87QUFDOUQsMEJBQTBCLFNBQVM7QUFDbkMseUZBQXlGO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0JBQWtCO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsMEJBQTBCO0FBQzdEO0FBQ0Esb0NBQW9DLHNCQUFzQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsU0FBUztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELE9BQU87QUFDbkU7QUFDQSw4RUFBOEUsK0RBQW9CO0FBQ2xHO0FBQ0E7QUFDQSxtRkFBbUYsK0JBQStCO0FBQ2xIO0FBQ0E7QUFDQSx3Q0FBd0MsK0NBQUk7QUFDNUM7QUFDQTtBQUNBLHFDQUFxQywrQ0FBSTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Ysc0RBQXNEO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RSxtQ0FBbUMsK0NBQStDLEdBQUcsTUFBTSxzQkFBc0IsSUFBSSxNQUFNLEVBQUUscUNBQXFDO0FBQ2xLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0RBQXNEO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsMkJBQTJCO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFEQUFVLEdBQUc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlEQUFNO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxhQUFhLG1DQUFtQyxpQkFBaUI7QUFDckg7QUFDQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxvQkFBb0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrREFBTyw0QkFBNEIsMERBQWU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsNEJBQTRCLDhEQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDZCQUE2QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxXQUFXO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixTQUFTO0FBQ25DLDZGQUE2RjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsV0FBVztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQSwyREFBMkQseUNBQXlDO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLDhCQUE4QixxQ0FBcUM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUyRSIsInNvdXJjZXMiOlsid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9sb2tpL0xva2lBbm5vdGF0aW9uc1F1ZXJ5Q3RybC50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvYWRkX2xhYmVsX3RvX3F1ZXJ5LnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9sb2tpL2JhY2tlbmRSZXN1bHRUcmFuc2Zvcm1lci50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvbG9raS9jb21wb25lbnRzL0xva2lDaGVhdFNoZWV0LnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvbG9raS9jb21wb25lbnRzL0xva2lFeHBsb3JlUXVlcnlFZGl0b3IudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9sb2tpL2NvbXBvbmVudHMvTG9raUxhYmVsQnJvd3Nlci50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvY29tcG9uZW50cy9Mb2tpT3B0aW9uRmllbGRzLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvbG9raS9jb21wb25lbnRzL0xva2lRdWVyeUVkaXRvci50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvY29tcG9uZW50cy9Mb2tpUXVlcnlFZGl0b3JCeUFwcC50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvY29tcG9uZW50cy9Mb2tpUXVlcnlFZGl0b3JGb3JBbGVydGluZy50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvY29tcG9uZW50cy9Mb2tpUXVlcnlGaWVsZC50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvY29uZmlndXJhdGlvbi9Db25maWdFZGl0b3IudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9sb2tpL2NvbmZpZ3VyYXRpb24vRGVidWdTZWN0aW9uLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvbG9raS9jb25maWd1cmF0aW9uL0Rlcml2ZWRGaWVsZC50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvY29uZmlndXJhdGlvbi9EZXJpdmVkRmllbGRzLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvbG9raS9jb25maWd1cmF0aW9uL01heExpbmVzRmllbGQudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9sb2tpL2RhdGFzb3VyY2UudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvZ2V0RGVyaXZlZEZpZWxkcy50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvbG9raS9sYW5ndWFnZV9wcm92aWRlci50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvbG9raS9sYW5ndWFnZV91dGlscy50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvbG9raS9saXZlX3N0cmVhbXMudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvbWFrZVRhYmxlRnJhbWVzLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9sb2tpL21vZHVsZS50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvbG9raS9xdWVyeV91dGlscy50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvbG9raS9xdWVyeWJ1aWxkZXIvTG9raVF1ZXJ5TW9kZWxsZXIudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvcXVlcnlidWlsZGVyL2JpbmFyeVNjYWxhck9wZXJhdGlvbnMudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvcXVlcnlidWlsZGVyL2NvbXBvbmVudHMvTG9raVF1ZXJ5QnVpbGRlci50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvcXVlcnlidWlsZGVyL2NvbXBvbmVudHMvTG9raVF1ZXJ5QnVpbGRlckNvbnRhaW5lci50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvcXVlcnlidWlsZGVyL2NvbXBvbmVudHMvTG9raVF1ZXJ5QnVpbGRlckV4cGxhaW5lZC50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvcXVlcnlidWlsZGVyL2NvbXBvbmVudHMvTG9raVF1ZXJ5QnVpbGRlck9wdGlvbnMudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9sb2tpL3F1ZXJ5YnVpbGRlci9jb21wb25lbnRzL0xva2lRdWVyeUNvZGVFZGl0b3IudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9sb2tpL3F1ZXJ5YnVpbGRlci9jb21wb25lbnRzL0xva2lRdWVyeUVkaXRvclNlbGVjdG9yLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvbG9raS9xdWVyeWJ1aWxkZXIvY29tcG9uZW50cy9OZXN0ZWRRdWVyeS50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvcXVlcnlidWlsZGVyL2NvbXBvbmVudHMvTmVzdGVkUXVlcnlMaXN0LnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvbG9raS9xdWVyeWJ1aWxkZXIvY29tcG9uZW50cy9RdWVyeVByZXZpZXcudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9sb2tpL3F1ZXJ5YnVpbGRlci9vcGVyYXRpb25zLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9sb2tpL3F1ZXJ5YnVpbGRlci9wYXJzaW5nLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9sb2tpL3F1ZXJ5YnVpbGRlci9zdGF0ZS50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvbG9raS9xdWVyeWJ1aWxkZXIvdHlwZXMudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvcmVzdWx0X3RyYW5zZm9ybWVyLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9sb2tpL3NvcnREYXRhRnJhbWUudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvc3RyZWFtaW5nLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9sb2tpL3N5bnRheC50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvbG9raS90eXBlcy50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9hZGRfbGFiZWxfdG9fcXVlcnkudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvZGF0YXNvdXJjZS50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvbGFuZ3VhZ2VfcHJvdmlkZXIudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvbGFuZ3VhZ2VfdXRpbHMudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvbWV0cmljX2ZpbmRfcXVlcnkudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcHJvbXFsLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5X2hpbnRzLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9Qcm9tUXVlcnlNb2RlbGxlci50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvYWdncmVnYXRpb25zLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9iaW5hcnlTY2FsYXJPcGVyYXRpb25zLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9jb21wb25lbnRzL0xhYmVsUGFyYW1FZGl0b3IudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9vcGVyYXRpb25zLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9wYXJzaW5nLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvQXV0b1NpemVJbnB1dC50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9MYWJlbEZpbHRlckl0ZW0udHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvTGFiZWxGaWx0ZXJzLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL0xva2lBbmRQcm9tUXVlcnlNb2RlbGxlckJhc2UudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9PcGVyYXRpb25FZGl0b3IudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvT3BlcmF0aW9uRXhwbGFpbmVkQm94LnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL09wZXJhdGlvbkhlYWRlci50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9PcGVyYXRpb25JbmZvQnV0dG9uLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL09wZXJhdGlvbkxpc3QudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvT3BlcmF0aW9uTGlzdEV4cGxhaW5lZC50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9PcGVyYXRpb25QYXJhbUVkaXRvci50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9PcGVyYXRpb25zRWRpdG9yUm93LnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL1F1ZXJ5RWRpdG9yTW9kZVRvZ2dsZS50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9RdWVyeUhlYWRlclN3aXRjaC50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9RdWVyeU9wdGlvbkdyb3VwLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL29wZXJhdGlvblV0aWxzLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvcGFyc2luZ1V0aWxzLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvdHlwZXMudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3R5cGVzLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3Jlc3VsdF90cmFuc2Zvcm1lci50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy90eXBlcy50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy92YXJpYWJsZXMudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uLy55YXJuL19fdmlydHVhbF9fL3JlYWN0LXVzZS12aXJ0dWFsLTAwMzI2ZTcwYmEvMC9jYWNoZS9yZWFjdC11c2UtbnBtLTE3LjMuMi1hMDMyY2JlYjAxLTczNzk0NjBmNTEuemlwL25vZGVfbW9kdWxlcy9yZWFjdC11c2UvZXNtL3VzZVByZXZpb3VzLmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9fX3ZpcnR1YWxfXy9yZWFjdC11c2UtdmlydHVhbC0wMDMyNmU3MGJhLzAvY2FjaGUvcmVhY3QtdXNlLW5wbS0xNy4zLjItYTAzMmNiZWIwMS03Mzc5NDYwZjUxLnppcC9ub2RlX21vZHVsZXMvcmVhY3QtdXNlL2VzbS91c2VUb2dnbGUuanMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uLy55YXJuL2NhY2hlL2xydS1jYWNoZS1ucG0tNy45LjAtZDgwMzEwODIzMy1jOTFhMjkzYTEwLnppcC9ub2RlX21vZHVsZXMvbHJ1LWNhY2hlL2luZGV4LmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9jYWNoZS9yeGpzLW5wbS03LjUuNS1kMDU0NmIxY2NiLWUwMzRmNjA4MDUuemlwL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vYnNlcnZhYmxlL2RvbS9XZWJTb2NrZXRTdWJqZWN0LmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9jYWNoZS9yeGpzLW5wbS03LjUuNS1kMDU0NmIxY2NiLWUwMzRmNjA4MDUuemlwL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vYnNlcnZhYmxlL2RvbS93ZWJTb2NrZXQuanMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uLy55YXJuL2NhY2hlL3V1aWQtbnBtLTguMy4yLWVjYTBiYWJhNTMtNTU3NWE4YTc1Yy56aXAvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9wYXJzZS5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vY2FjaGUvdXVpZC1ucG0tOC4zLjItZWNhMGJhYmE1My01NTc1YThhNzVjLnppcC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3NoYTEuanMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uLy55YXJuL2NhY2hlL3V1aWQtbnBtLTguMy4yLWVjYTBiYWJhNTMtNTU3NWE4YTc1Yy56aXAvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci92MzUuanMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uLy55YXJuL2NhY2hlL3V1aWQtbnBtLTguMy4yLWVjYTBiYWJhNTMtNTU3NWE4YTc1Yy56aXAvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci92NS5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vX192aXJ0dWFsX18vQGdyYWZhbmEtbGV6ZXItbG9ncWwtdmlydHVhbC05MjUwZGJlY2Y4LzAvY2FjaGUvQGdyYWZhbmEtbGV6ZXItbG9ncWwtbnBtLTAuMC4xMS1kN2QyNDllNzRhLTA0MjdlNTk1MjguemlwL25vZGVfbW9kdWxlcy9AZ3JhZmFuYS9sZXplci1sb2dxbC9pbmRleC5lcy5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vX192aXJ0dWFsX18vbGV6ZXItcHJvbXFsLXZpcnR1YWwtZWFmODhhYTc3YS8wL2NhY2hlL2xlemVyLXByb21xbC1ucG0tMC4yMi4wLTg2N2RhNmFmYWEtY2RjZTA1NDcwMC56aXAvbm9kZV9tb2R1bGVzL2xlemVyLXByb21xbC9pbmRleC5lcy5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vY2FjaGUvQGxlemVyLWNvbW1vbi1ucG0tMC4xNS4xMi02MjAxNzI3MmIwLWRhZTY1ODE2MTguemlwL25vZGVfbW9kdWxlcy9AbGV6ZXIvY29tbW9uL2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uLy55YXJuL2NhY2hlL0BsZXplci1sci1ucG0tMC4xNS44LThjNDgxYzM5Y2QtZTc0MTIyNWQ2YS56aXAvbm9kZV9tb2R1bGVzL0BsZXplci9sci9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExva2lRdWVyeSB9IGZyb20gJy4vdHlwZXMnO1xuLyoqXG4gKiBKdXN0IGEgc2ltcGxlIHdyYXBwZXIgZm9yIGEgcmVhY3QgY29tcG9uZW50IHRoYXQgaXMgYWN0dWFsbHkgaW1wbGVtZW50aW5nIHRoZSBxdWVyeSBlZGl0b3IuXG4gKi9cbmV4cG9ydCBjbGFzcyBMb2tpQW5ub3RhdGlvbnNRdWVyeUN0cmwge1xuICBzdGF0aWMgdGVtcGxhdGVVcmwgPSAncGFydGlhbHMvYW5ub3RhdGlvbnMuZWRpdG9yLmh0bWwnO1xuICBkZWNsYXJlIGFubm90YXRpb246IGFueTtcblxuICAvKiogQG5nSW5qZWN0ICovXG4gIGNvbnN0cnVjdG9yKCRzY29wZTogYW55KSB7XG4gICAgdGhpcy5hbm5vdGF0aW9uID0gJHNjb3BlLmN0cmwuYW5ub3RhdGlvbjtcbiAgICB0aGlzLmFubm90YXRpb24udGFyZ2V0ID0gdGhpcy5hbm5vdGF0aW9uLnRhcmdldCB8fCB7fTtcbiAgICB0aGlzLm9uUXVlcnlDaGFuZ2UgPSB0aGlzLm9uUXVlcnlDaGFuZ2UuYmluZCh0aGlzKTtcbiAgfVxuXG4gIG9uUXVlcnlDaGFuZ2UocXVlcnk6IExva2lRdWVyeSkge1xuICAgIHRoaXMuYW5ub3RhdGlvbi5leHByID0gcXVlcnkuZXhwcjtcbiAgICB0aGlzLmFubm90YXRpb24ubWF4TGluZXMgPSBxdWVyeS5tYXhMaW5lcztcbiAgICB0aGlzLmFubm90YXRpb24uaW5zdGFudCA9IHF1ZXJ5Lmluc3RhbnQ7XG4gIH1cbn1cbiIsImltcG9ydCB7IGNoYWluLCBpc0VxdWFsIH0gZnJvbSAnbG9kYXNoJztcblxuaW1wb3J0IHsgUFJPTV9LRVlXT1JEUywgT1BFUkFUT1JTLCBMT0dJQ0FMX09QRVJBVE9SUyB9IGZyb20gJ2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9wcm9tcWwnO1xuXG5pbXBvcnQgeyBMT0tJX0tFWVdPUkRTIH0gZnJvbSAnLi9zeW50YXgnO1xuXG5jb25zdCBidWlsdEluV29yZHMgPSBbLi4uUFJPTV9LRVlXT1JEUywgLi4uT1BFUkFUT1JTLCAuLi5MT0dJQ0FMX09QRVJBVE9SUywgLi4uTE9LSV9LRVlXT1JEU107XG5cbi8vIFdlIHdhbnQgdG8gZXh0cmFjdCBhbGwgcG9zc2libGUgbWV0cmljcyBhbmQgYWxzbyBrZXl3b3Jkc1xuY29uc3QgbWV0cmljc0FuZEtleXdvcmRzUmVnZXhwID0gLyhbQS1aYS16Ol1bXFx3Ol0qKVxcYig/IVtcXF17PSFcIixdKS9nO1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkTGFiZWxUb1F1ZXJ5KFxuICBxdWVyeTogc3RyaW5nLFxuICBrZXk6IHN0cmluZyxcbiAgdmFsdWU6IHN0cmluZyB8IG51bWJlcixcbiAgb3BlcmF0b3I/OiBzdHJpbmcsXG4gIGhhc05vTWV0cmljcz86IGJvb2xlYW5cbik6IHN0cmluZyB7XG4gIGlmICgha2V5IHx8ICF2YWx1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTmVlZCBsYWJlbCB0byBhZGQgdG8gcXVlcnkuJyk7XG4gIH1cblxuICAvLyBXZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IHdlIGNvbnZlcnQgdGhlIHZhbHVlIGJhY2sgdG8gc3RyaW5nIGJlY2F1c2UgaXQgbWF5IGJlIGEgbnVtYmVyXG4gIGNvbnN0IHRyYW5zZm9ybWVkVmFsdWUgPSB2YWx1ZSA9PT0gSW5maW5pdHkgPyAnK0luZicgOiB2YWx1ZS50b1N0cmluZygpO1xuXG4gIC8vIEFkZCBlbXB0eSBzZWxlY3RvcnMgdG8gYmFyZSBtZXRyaWMgbmFtZXNcbiAgbGV0IHByZXZpb3VzV29yZDogc3RyaW5nO1xuXG4gIHF1ZXJ5ID0gcXVlcnkucmVwbGFjZShtZXRyaWNzQW5kS2V5d29yZHNSZWdleHAsIChtYXRjaCwgd29yZCwgb2Zmc2V0KSA9PiB7XG4gICAgY29uc3QgaXNNZXRyaWMgPSBpc1dvcmRNZXRyaWMocXVlcnksIHdvcmQsIG9mZnNldCwgcHJldmlvdXNXb3JkLCBoYXNOb01ldHJpY3MpO1xuICAgIHByZXZpb3VzV29yZCA9IHdvcmQ7XG5cbiAgICByZXR1cm4gaXNNZXRyaWMgPyBgJHt3b3JkfXt9YCA6IHdvcmQ7XG4gIH0pO1xuXG4gIC8vVGhpcyBpcyBhIFJlZ0V4cCBmb3Igc3RyZWFtIHNlbGVjdG9yIC0gZS5nLiB7am9iPVwiZ3JhZmFuYVwifVxuICBjb25zdCBzZWxlY3RvclJlZ2V4cCA9IC8oXFwkKT97KFtee10qKX0vZztcbiAgY29uc3QgcGFydHMgPSBbXTtcbiAgbGV0IGxhc3RJbmRleCA9IDA7XG4gIGxldCBzdWZmaXggPSAnJztcblxuICBsZXQgbWF0Y2ggPSBzZWxlY3RvclJlZ2V4cC5leGVjKHF1ZXJ5KTtcbiAgLyogXG4gICAgVGhlcmUgYXJlIDIgcG9zc2libGUgZmFsc2UgcG9zaXRpdmUgc2NlbmFyaW9zOiBcbiAgICBcbiAgICAxLiBXZSBtYXRjaCBHcmFmYW5hJ3MgdmFyaWFibGVzIHdpdGggJHsgc3ludGF4IC0gc3VjaCBhcyR7X19yYXRlX3N9LiBUbyBmaWx0ZXIgdGhlc2Ugb3V0IHdlIGNvdWxkIHVzZSBuZWdhdGl2ZSBsb29rYmVoaW5kLFxuICAgIGJ1dCBTYWZhcmkgYnJvd3NlciBjdXJyZW50bHkgZG9lc24ndCBzdXBwb3J0IGl0LiBUaGVyZWZvcmUgd2UgbmVlZCB0byBoYWNrIHRoaXMgYnkgY3JlYXRpbmcgMiBtYXRjaGluZyBncm91cHMuIFxuICAgIChcXCQpIGlzIGZvciB0aGUgR3JhZmFuYSdzIHZhcmlhYmxlcyBhbmQgaWYgd2UgbWF0Y2ggaXQsIHdlIGtub3cgdGhpcyBpcyBub3QgYSBzdHJlYW0gc2VsZWN0b3IgYW5kIHdlIGRvbid0IHdhbnQgdG8gYWRkIGxhYmVsLlxuXG4gICAgMi4gTG9nIHF1ZXJpZXMgY2FuIGluY2x1ZGUge3subGFiZWx9fSBzeW50YXggd2hlbiBsaW5lX2Zvcm1hdCBpcyB1c2VkLiBXZSBuZWVkIHRvIGZpbHRlciB0aGVzZSBvdXQgYnkgY2hlY2tpbmdcbiAgICBpZiBtYXRjaCBzdGFydHMgd2l0aCBcInsuXCJcbiAgKi9cbiAgd2hpbGUgKG1hdGNoKSB7XG4gICAgY29uc3QgcHJlZml4ID0gcXVlcnkuc2xpY2UobGFzdEluZGV4LCBtYXRjaC5pbmRleCk7XG4gICAgbGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFsyXS5sZW5ndGggKyAyO1xuICAgIHN1ZmZpeCA9IHF1ZXJ5LnNsaWNlKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcblxuICAgIC8vIEZpbHRlcmluZyBvdXIgZmFsc2UgcG9zaXRpdmVzXG4gICAgaWYgKG1hdGNoWzBdLnN0YXJ0c1dpdGgoJ3suJykgfHwgbWF0Y2hbMV0pIHtcbiAgICAgIHBhcnRzLnB1c2gocHJlZml4KTtcbiAgICAgIHBhcnRzLnB1c2gobWF0Y2hbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB3ZSBkaWRuJ3QgbWF0Y2ggZmlyc3QgZ3JvdXAsIHdlIGFyZSBpbnNpZGUgc2VsZWN0b3IgYW5kIHdlIHdhbnQgdG8gYWRkIGxhYmVsc1xuICAgICAgY29uc3Qgc2VsZWN0b3IgPSBtYXRjaFsyXTtcbiAgICAgIGNvbnN0IHNlbGVjdG9yV2l0aExhYmVsID0gYWRkTGFiZWxUb1NlbGVjdG9yKHNlbGVjdG9yLCBrZXksIHRyYW5zZm9ybWVkVmFsdWUsIG9wZXJhdG9yKTtcbiAgICAgIHBhcnRzLnB1c2gocHJlZml4LCBzZWxlY3RvcldpdGhMYWJlbCk7XG4gICAgfVxuXG4gICAgbWF0Y2ggPSBzZWxlY3RvclJlZ2V4cC5leGVjKHF1ZXJ5KTtcbiAgfVxuXG4gIHBhcnRzLnB1c2goc3VmZml4KTtcbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpO1xufVxuXG5jb25zdCBsYWJlbFJlZ2V4cCA9IC8oXFx3KylcXHMqKD18IT18PX58IX4pXFxzKihcIlteXCJdKlwiKS9nO1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkTGFiZWxUb1NlbGVjdG9yKHNlbGVjdG9yOiBzdHJpbmcsIGxhYmVsS2V5OiBzdHJpbmcsIGxhYmVsVmFsdWU6IHN0cmluZywgbGFiZWxPcGVyYXRvcj86IHN0cmluZykge1xuICBjb25zdCBwYXJzZWRMYWJlbHMgPSBbXTtcblxuICAvLyBTcGxpdCBzZWxlY3RvciBpbnRvIGxhYmVsc1xuICBpZiAoc2VsZWN0b3IpIHtcbiAgICBsZXQgbWF0Y2ggPSBsYWJlbFJlZ2V4cC5leGVjKHNlbGVjdG9yKTtcbiAgICB3aGlsZSAobWF0Y2gpIHtcbiAgICAgIHBhcnNlZExhYmVscy5wdXNoKHsga2V5OiBtYXRjaFsxXSwgb3BlcmF0b3I6IG1hdGNoWzJdLCB2YWx1ZTogbWF0Y2hbM10gfSk7XG4gICAgICBtYXRjaCA9IGxhYmVsUmVnZXhwLmV4ZWMoc2VsZWN0b3IpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCBuZXcgbGFiZWxcbiAgY29uc3Qgb3BlcmF0b3JGb3JMYWJlbEtleSA9IGxhYmVsT3BlcmF0b3IgfHwgJz0nO1xuICBwYXJzZWRMYWJlbHMucHVzaCh7IGtleTogbGFiZWxLZXksIG9wZXJhdG9yOiBvcGVyYXRvckZvckxhYmVsS2V5LCB2YWx1ZTogYFwiJHtsYWJlbFZhbHVlfVwiYCB9KTtcblxuICAvLyBTb3J0IGxhYmVscyBieSBrZXkgYW5kIHB1dCB0aGVtIHRvZ2V0aGVyXG4gIGNvbnN0IGZvcm1hdHRlZCA9IGNoYWluKHBhcnNlZExhYmVscylcbiAgICAudW5pcVdpdGgoaXNFcXVhbClcbiAgICAuY29tcGFjdCgpXG4gICAgLnNvcnRCeSgna2V5JylcbiAgICAubWFwKCh7IGtleSwgb3BlcmF0b3IsIHZhbHVlIH0pID0+IGAke2tleX0ke29wZXJhdG9yfSR7dmFsdWV9YClcbiAgICAudmFsdWUoKVxuICAgIC5qb2luKCcsJyk7XG5cbiAgcmV0dXJuIGB7JHtmb3JtYXR0ZWR9fWA7XG59XG5cbmZ1bmN0aW9uIGlzUG9zaXRpb25JbnNpZGVDaGFycyh0ZXh0OiBzdHJpbmcsIHBvc2l0aW9uOiBudW1iZXIsIG9wZW5DaGFyOiBzdHJpbmcsIGNsb3NlQ2hhcjogc3RyaW5nKSB7XG4gIGNvbnN0IG5leHRTZWxlY3RvclN0YXJ0ID0gdGV4dC5zbGljZShwb3NpdGlvbikuaW5kZXhPZihvcGVuQ2hhcik7XG4gIGNvbnN0IG5leHRTZWxlY3RvckVuZCA9IHRleHQuc2xpY2UocG9zaXRpb24pLmluZGV4T2YoY2xvc2VDaGFyKTtcbiAgcmV0dXJuIG5leHRTZWxlY3RvckVuZCA+IC0xICYmIChuZXh0U2VsZWN0b3JTdGFydCA9PT0gLTEgfHwgbmV4dFNlbGVjdG9yU3RhcnQgPiBuZXh0U2VsZWN0b3JFbmQpO1xufVxuXG5mdW5jdGlvbiBpc1dvcmRNZXRyaWMocXVlcnk6IHN0cmluZywgd29yZDogc3RyaW5nLCBvZmZzZXQ6IG51bWJlciwgcHJldmlvdXNXb3JkOiBzdHJpbmcsIGhhc05vTWV0cmljcz86IGJvb2xlYW4pIHtcbiAgY29uc3QgaW5zaWRlU2VsZWN0b3IgPSBpc1Bvc2l0aW9uSW5zaWRlQ2hhcnMocXVlcnksIG9mZnNldCwgJ3snLCAnfScpO1xuICAvLyBIYW5kbGUgXCJzdW0gYnkgKGtleSkgKG1ldHJpYylcIlxuICBjb25zdCBwcmV2aW91c1dvcmRJc0tleVdvcmQgPSBwcmV2aW91c1dvcmQgJiYgT1BFUkFUT1JTLmluZGV4T2YocHJldmlvdXNXb3JkKSA+IC0xO1xuICAvLyBDaGVjayBmb3IgY29sb24gYXMgYXMgXCJ3b3JkIGJvdW5kYXJ5XCIgc3ltYm9sXG4gIGNvbnN0IGlzQ29sb25Cb3VuZGVkID0gd29yZC5lbmRzV2l0aCgnOicpO1xuICAvLyBDaGVjayBmb3Igd29yZHMgdGhhdCBzdGFydCB3aXRoIFwiIHdoaWNoIG1lYW5zIHRoYXQgdGhleSBhcmUgbm90IG1ldHJpY3NcbiAgY29uc3Qgc3RhcnRzV2l0aFF1b3RlID0gcXVlcnlbb2Zmc2V0IC0gMV0gPT09ICdcIic7XG4gIC8vIENoZWNrIGZvciB0ZW1wbGF0ZSB2YXJpYWJsZXNcbiAgY29uc3QgaXNUZW1wbGF0ZVZhcmlhYmxlID0gcXVlcnlbb2Zmc2V0IC0gMV0gPT09ICckJztcbiAgLy8gQ2hlY2sgZm9yIHRpbWUgdW5pdHNcbiAgY29uc3QgaXNUaW1lVW5pdCA9IFsncycsICdtJywgJ2gnLCAnZCcsICd3J10uaW5jbHVkZXMod29yZCkgJiYgQm9vbGVhbihOdW1iZXIocXVlcnlbb2Zmc2V0IC0gMV0pKTtcblxuICBpZiAoXG4gICAgIWhhc05vTWV0cmljcyAmJlxuICAgICFpbnNpZGVTZWxlY3RvciAmJlxuICAgICFpc0NvbG9uQm91bmRlZCAmJlxuICAgICFwcmV2aW91c1dvcmRJc0tleVdvcmQgJiZcbiAgICAhc3RhcnRzV2l0aFF1b3RlICYmXG4gICAgIWlzVGVtcGxhdGVWYXJpYWJsZSAmJlxuICAgICFpc1RpbWVVbml0ICYmXG4gICAgYnVpbHRJbldvcmRzLmluZGV4T2Yod29yZCkgPT09IC0xXG4gICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYWRkTGFiZWxUb1F1ZXJ5O1xuIiwiaW1wb3J0IHsgRGF0YVF1ZXJ5UmVzcG9uc2UsIERhdGFGcmFtZSwgaXNEYXRhRnJhbWUsIEZpZWxkVHlwZSwgUXVlcnlSZXN1bHRNZXRhIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5cbmltcG9ydCB7IGdldERlcml2ZWRGaWVsZHMgfSBmcm9tICcuL2dldERlcml2ZWRGaWVsZHMnO1xuaW1wb3J0IHsgbWFrZVRhYmxlRnJhbWVzIH0gZnJvbSAnLi9tYWtlVGFibGVGcmFtZXMnO1xuaW1wb3J0IHsgZm9ybWF0UXVlcnksIGdldEhpZ2hsaWdodGVyRXhwcmVzc2lvbnNGcm9tUXVlcnkgfSBmcm9tICcuL3F1ZXJ5X3V0aWxzJztcbmltcG9ydCB7IERlcml2ZWRGaWVsZENvbmZpZywgTG9raVF1ZXJ5LCBMb2tpUXVlcnlUeXBlIH0gZnJvbSAnLi90eXBlcyc7XG5cbmZ1bmN0aW9uIGlzTWV0cmljRnJhbWUoZnJhbWU6IERhdGFGcmFtZSk6IGJvb2xlYW4ge1xuICByZXR1cm4gZnJhbWUuZmllbGRzLmV2ZXJ5KChmaWVsZCkgPT4gZmllbGQudHlwZSA9PT0gRmllbGRUeXBlLnRpbWUgfHwgZmllbGQudHlwZSA9PT0gRmllbGRUeXBlLm51bWJlcik7XG59XG5cbi8vIHJldHVybnMgYSBuZXcgZnJhbWUsIHdpdGggbWV0YSBtZXJnZWQgd2l0aCBpdCdzIG9yaWdpbmFsIG1ldGFcbmZ1bmN0aW9uIHNldEZyYW1lTWV0YShmcmFtZTogRGF0YUZyYW1lLCBtZXRhOiBRdWVyeVJlc3VsdE1ldGEpOiBEYXRhRnJhbWUge1xuICBjb25zdCB7IG1ldGE6IG9sZE1ldGEsIC4uLnJlc3QgfSA9IGZyYW1lO1xuICAvLyBtZXRhIG1heWJlIGJlIHVuZGVmaW5lZCwgd2UgbmVlZCB0byBoYW5kbGUgdGhhdFxuICBjb25zdCBuZXdNZXRhID0geyAuLi5vbGRNZXRhLCAuLi5tZXRhIH07XG4gIHJldHVybiB7XG4gICAgLi4ucmVzdCxcbiAgICBtZXRhOiBuZXdNZXRhLFxuICB9O1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzU3RyZWFtRnJhbWUoXG4gIGZyYW1lOiBEYXRhRnJhbWUsXG4gIHF1ZXJ5OiBMb2tpUXVlcnkgfCB1bmRlZmluZWQsXG4gIGRlcml2ZWRGaWVsZENvbmZpZ3M6IERlcml2ZWRGaWVsZENvbmZpZ1tdXG4pOiBEYXRhRnJhbWUge1xuICBjb25zdCBtZXRhOiBRdWVyeVJlc3VsdE1ldGEgPSB7XG4gICAgcHJlZmVycmVkVmlzdWFsaXNhdGlvblR5cGU6ICdsb2dzJyxcbiAgICBsaW1pdDogcXVlcnk/Lm1heExpbmVzLFxuICAgIHNlYXJjaFdvcmRzOiBxdWVyeSAhPT0gdW5kZWZpbmVkID8gZ2V0SGlnaGxpZ2h0ZXJFeHByZXNzaW9uc0Zyb21RdWVyeShmb3JtYXRRdWVyeShxdWVyeS5leHByKSkgOiB1bmRlZmluZWQsXG4gICAgY3VzdG9tOiB7XG4gICAgICAvLyB1c2VkIGJ5IGxvZ3NfbW9kZWxcbiAgICAgIGxva2lRdWVyeVN0YXRLZXk6ICdTdW1tYXJ5OiB0b3RhbCBieXRlcyBwcm9jZXNzZWQnLFxuICAgIH0sXG4gIH07XG5cbiAgY29uc3QgbmV3RnJhbWUgPSBzZXRGcmFtZU1ldGEoZnJhbWUsIG1ldGEpO1xuICBjb25zdCBkZXJpdmVkRmllbGRzID0gZ2V0RGVyaXZlZEZpZWxkcyhuZXdGcmFtZSwgZGVyaXZlZEZpZWxkQ29uZmlncyk7XG4gIHJldHVybiB7XG4gICAgLi4ubmV3RnJhbWUsXG4gICAgZmllbGRzOiBbLi4ubmV3RnJhbWUuZmllbGRzLCAuLi5kZXJpdmVkRmllbGRzXSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1N0cmVhbXNGcmFtZXMoXG4gIGZyYW1lczogRGF0YUZyYW1lW10sXG4gIHF1ZXJ5TWFwOiBNYXA8c3RyaW5nLCBMb2tpUXVlcnk+LFxuICBkZXJpdmVkRmllbGRDb25maWdzOiBEZXJpdmVkRmllbGRDb25maWdbXVxuKTogRGF0YUZyYW1lW10ge1xuICByZXR1cm4gZnJhbWVzLm1hcCgoZnJhbWUpID0+IHtcbiAgICBjb25zdCBxdWVyeSA9IGZyYW1lLnJlZklkICE9PSB1bmRlZmluZWQgPyBxdWVyeU1hcC5nZXQoZnJhbWUucmVmSWQpIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiBwcm9jZXNzU3RyZWFtRnJhbWUoZnJhbWUsIHF1ZXJ5LCBkZXJpdmVkRmllbGRDb25maWdzKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NNZXRyaWNJbnN0YW50RnJhbWVzKGZyYW1lczogRGF0YUZyYW1lW10pOiBEYXRhRnJhbWVbXSB7XG4gIHJldHVybiBmcmFtZXMubGVuZ3RoID4gMCA/IG1ha2VUYWJsZUZyYW1lcyhmcmFtZXMpIDogW107XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NNZXRyaWNSYW5nZUZyYW1lcyhmcmFtZXM6IERhdGFGcmFtZVtdKTogRGF0YUZyYW1lW10ge1xuICBjb25zdCBtZXRhOiBRdWVyeVJlc3VsdE1ldGEgPSB7IHByZWZlcnJlZFZpc3VhbGlzYXRpb25UeXBlOiAnZ3JhcGgnIH07XG4gIHJldHVybiBmcmFtZXMubWFwKChmcmFtZSkgPT4gc2V0RnJhbWVNZXRhKGZyYW1lLCBtZXRhKSk7XG59XG5cbi8vIHdlIHNwbGl0IHRoZSBmcmFtZXMgaW50byAzIGdyb3VwcywgYmVjYXVzZSB3ZSB3aWxsIGhhbmRsZVxuLy8gZWFjaCBncm91cCBzbGlnaHRseSBkaWZmZXJlbnRseVxuZnVuY3Rpb24gZ3JvdXBGcmFtZXMoXG4gIGZyYW1lczogRGF0YUZyYW1lW10sXG4gIHF1ZXJ5TWFwOiBNYXA8c3RyaW5nLCBMb2tpUXVlcnk+XG4pOiB7XG4gIHN0cmVhbXNGcmFtZXM6IERhdGFGcmFtZVtdO1xuICBtZXRyaWNJbnN0YW50RnJhbWVzOiBEYXRhRnJhbWVbXTtcbiAgbWV0cmljUmFuZ2VGcmFtZXM6IERhdGFGcmFtZVtdO1xufSB7XG4gIGNvbnN0IHN0cmVhbXNGcmFtZXM6IERhdGFGcmFtZVtdID0gW107XG4gIGNvbnN0IG1ldHJpY0luc3RhbnRGcmFtZXM6IERhdGFGcmFtZVtdID0gW107XG4gIGNvbnN0IG1ldHJpY1JhbmdlRnJhbWVzOiBEYXRhRnJhbWVbXSA9IFtdO1xuXG4gIGZyYW1lcy5mb3JFYWNoKChmcmFtZSkgPT4ge1xuICAgIGlmICghaXNNZXRyaWNGcmFtZShmcmFtZSkpIHtcbiAgICAgIHN0cmVhbXNGcmFtZXMucHVzaChmcmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGlzSW5zdGFudEZyYW1lID0gZnJhbWUucmVmSWQgIT0gbnVsbCAmJiBxdWVyeU1hcC5nZXQoZnJhbWUucmVmSWQpPy5xdWVyeVR5cGUgPT09IExva2lRdWVyeVR5cGUuSW5zdGFudDtcbiAgICAgIGlmIChpc0luc3RhbnRGcmFtZSkge1xuICAgICAgICBtZXRyaWNJbnN0YW50RnJhbWVzLnB1c2goZnJhbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWV0cmljUmFuZ2VGcmFtZXMucHVzaChmcmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4geyBzdHJlYW1zRnJhbWVzLCBtZXRyaWNJbnN0YW50RnJhbWVzLCBtZXRyaWNSYW5nZUZyYW1lcyB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtQmFja2VuZFJlc3VsdChcbiAgcmVzcG9uc2U6IERhdGFRdWVyeVJlc3BvbnNlLFxuICBxdWVyaWVzOiBMb2tpUXVlcnlbXSxcbiAgZGVyaXZlZEZpZWxkQ29uZmlnczogRGVyaXZlZEZpZWxkQ29uZmlnW11cbik6IERhdGFRdWVyeVJlc3BvbnNlIHtcbiAgY29uc3QgeyBkYXRhLCAuLi5yZXN0IH0gPSByZXNwb25zZTtcblxuICAvLyBpbiB0aGUgdHlwZXNjcmlwdCB0eXBlLCBkYXRhIGlzIGFuIGFycmF5IG9mIGJhc2ljYWxseSBhbnl0aGluZy5cbiAgLy8gd2UgZG8ga25vdyB0aGF0IHRoZXkgaGF2ZSB0byBiZSBkYXRhZnJhbWVzLCBzbyB3ZSBtYWtlIGEgcXVpY2sgY2hlY2ssXG4gIC8vIHRoaXMgd2F5IHdlIGNhbiBiZSBzdXJlLCBhbmQgYWxzbyB0eXBlc2NyaXB0IGlzIGhhcHB5LlxuICBjb25zdCBkYXRhRnJhbWVzID0gZGF0YS5tYXAoKGQpID0+IHtcbiAgICBpZiAoIWlzRGF0YUZyYW1lKGQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYW5zZm9ybWF0aW9uIG9ubHkgc3VwcG9ydHMgZGF0YWZyYW1lIHJlc3BvbnNlcycpO1xuICAgIH1cbiAgICByZXR1cm4gZDtcbiAgfSk7XG5cbiAgY29uc3QgcXVlcnlNYXAgPSBuZXcgTWFwKHF1ZXJpZXMubWFwKChxdWVyeSkgPT4gW3F1ZXJ5LnJlZklkLCBxdWVyeV0pKTtcblxuICBjb25zdCB7IHN0cmVhbXNGcmFtZXMsIG1ldHJpY0luc3RhbnRGcmFtZXMsIG1ldHJpY1JhbmdlRnJhbWVzIH0gPSBncm91cEZyYW1lcyhkYXRhRnJhbWVzLCBxdWVyeU1hcCk7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5yZXN0LFxuICAgIGRhdGE6IFtcbiAgICAgIC4uLnByb2Nlc3NNZXRyaWNSYW5nZUZyYW1lcyhtZXRyaWNSYW5nZUZyYW1lcyksXG4gICAgICAuLi5wcm9jZXNzTWV0cmljSW5zdGFudEZyYW1lcyhtZXRyaWNJbnN0YW50RnJhbWVzKSxcbiAgICAgIC4uLnByb2Nlc3NTdHJlYW1zRnJhbWVzKHN0cmVhbXNGcmFtZXMsIHF1ZXJ5TWFwLCBkZXJpdmVkRmllbGRDb25maWdzKSxcbiAgICBdLFxuICB9O1xufVxuIiwiaW1wb3J0IHsgc2h1ZmZsZSB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgUmVhY3QsIHsgUHVyZUNvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgUXVlcnlFZGl0b3JIZWxwUHJvcHMgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcblxuaW1wb3J0IExva2lMYW5ndWFnZVByb3ZpZGVyIGZyb20gJy4uL2xhbmd1YWdlX3Byb3ZpZGVyJztcbmltcG9ydCB7IExva2lRdWVyeSB9IGZyb20gJy4uL3R5cGVzJztcblxuY29uc3QgREVGQVVMVF9FWEFNUExFUyA9IFsne2pvYj1cImRlZmF1bHQvcHJvbWV0aGV1c1wifSddO1xuY29uc3QgUFJFRkVSUkVEX0xBQkVMUyA9IFsnam9iJywgJ2FwcCcsICdrOHNfYXBwJ107XG5jb25zdCBFWEFNUExFU19MSU1JVCA9IDU7XG5cbmNvbnN0IExPR1FMX0VYQU1QTEVTID0gW1xuICB7XG4gICAgdGl0bGU6ICdMb2cgcGlwZWxpbmUnLFxuICAgIGV4cHJlc3Npb246ICd7am9iPVwibXlzcWxcIn0gfD0gXCJtZXRyaWNzXCIgfCBsb2dmbXQgfCBkdXJhdGlvbiA+IDEwcycsXG4gICAgbGFiZWw6XG4gICAgICAnVGhpcyBxdWVyeSB0YXJnZXRzIHRoZSBNeVNRTCBqb2IsIGZpbHRlcnMgb3V0IGxvZ3MgdGhhdCBkb27igJl0IGNvbnRhaW4gdGhlIHdvcmQgXCJtZXRyaWNzXCIgYW5kIHBhcnNlcyBlYWNoIGxvZyBsaW5lIHRvIGV4dHJhY3QgbW9yZSBsYWJlbHMgYW5kIGZpbHRlcnMgd2l0aCB0aGVtLicsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0NvdW50IG92ZXIgdGltZScsXG4gICAgZXhwcmVzc2lvbjogJ2NvdW50X292ZXJfdGltZSh7am9iPVwibXlzcWxcIn1bNW1dKScsXG4gICAgbGFiZWw6ICdUaGlzIHF1ZXJ5IGNvdW50cyBhbGwgdGhlIGxvZyBsaW5lcyB3aXRoaW4gdGhlIGxhc3QgZml2ZSBtaW51dGVzIGZvciB0aGUgTXlTUUwgam9iLicsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ1JhdGUnLFxuICAgIGV4cHJlc3Npb246ICdyYXRlKCh7am9iPVwibXlzcWxcIn0gfD0gXCJlcnJvclwiICE9IFwidGltZW91dFwiKVsxMHNdKScsXG4gICAgbGFiZWw6XG4gICAgICAnVGhpcyBxdWVyeSBnZXRzIHRoZSBwZXItc2Vjb25kIHJhdGUgb2YgYWxsIG5vbi10aW1lb3V0IGVycm9ycyB3aXRoaW4gdGhlIGxhc3QgdGVuIHNlY29uZHMgZm9yIHRoZSBNeVNRTCBqb2IuJyxcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQWdncmVnYXRlLCBjb3VudCwgYW5kIGdyb3VwJyxcbiAgICBleHByZXNzaW9uOiAnc3VtKGNvdW50X292ZXJfdGltZSh7am9iPVwibXlzcWxcIn1bNW1dKSkgYnkgKGxldmVsKScsXG4gICAgbGFiZWw6ICdHZXQgdGhlIGNvdW50IG9mIGxvZ3MgZHVyaW5nIHRoZSBsYXN0IGZpdmUgbWludXRlcywgZ3JvdXBpbmcgYnkgbGV2ZWwuJyxcbiAgfSxcbl07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExva2lDaGVhdFNoZWV0IGV4dGVuZHMgUHVyZUNvbXBvbmVudDxRdWVyeUVkaXRvckhlbHBQcm9wczxMb2tpUXVlcnk+LCB7IHVzZXJFeGFtcGxlczogc3RyaW5nW10gfT4ge1xuICBkZWNsYXJlIHVzZXJMYWJlbFRpbWVyOiBOb2RlSlMuVGltZW91dDtcbiAgc3RhdGUgPSB7XG4gICAgdXNlckV4YW1wbGVzOiBbXSxcbiAgfTtcblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLnNjaGVkdWxlVXNlckxhYmVsQ2hlY2tpbmcoKTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnVzZXJMYWJlbFRpbWVyKTtcbiAgfVxuXG4gIHNjaGVkdWxlVXNlckxhYmVsQ2hlY2tpbmcoKSB7XG4gICAgdGhpcy51c2VyTGFiZWxUaW1lciA9IHNldFRpbWVvdXQodGhpcy5jaGVja1VzZXJMYWJlbHMsIDEwMDApO1xuICB9XG5cbiAgY2hlY2tVc2VyTGFiZWxzID0gYXN5bmMgKCkgPT4ge1xuICAgIC8vIFNldCBleGFtcGxlIGZyb20gdXNlciBsYWJlbHNcbiAgICBjb25zdCBwcm92aWRlcjogTG9raUxhbmd1YWdlUHJvdmlkZXIgPSB0aGlzLnByb3BzLmRhdGFzb3VyY2U/Lmxhbmd1YWdlUHJvdmlkZXI7XG4gICAgaWYgKHByb3ZpZGVyLnN0YXJ0ZWQpIHtcbiAgICAgIGNvbnN0IGxhYmVscyA9IHByb3ZpZGVyLmdldExhYmVsS2V5cygpIHx8IFtdO1xuICAgICAgY29uc3QgcHJlZmVycmVkTGFiZWwgPSBQUkVGRVJSRURfTEFCRUxTLmZpbmQoKGwpID0+IGxhYmVscy5pbmNsdWRlcyhsKSk7XG4gICAgICBpZiAocHJlZmVycmVkTGFiZWwpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gYXdhaXQgcHJvdmlkZXIuZ2V0TGFiZWxWYWx1ZXMocHJlZmVycmVkTGFiZWwpO1xuICAgICAgICBjb25zdCB1c2VyRXhhbXBsZXMgPSBzaHVmZmxlKHZhbHVlcylcbiAgICAgICAgICAuc2xpY2UoMCwgRVhBTVBMRVNfTElNSVQpXG4gICAgICAgICAgLm1hcCgodmFsdWUpID0+IGB7JHtwcmVmZXJyZWRMYWJlbH09XCIke3ZhbHVlfVwifWApO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgdXNlckV4YW1wbGVzIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNjaGVkdWxlVXNlckxhYmVsQ2hlY2tpbmcoKTtcbiAgICB9XG4gIH07XG5cbiAgcmVuZGVyRXhwcmVzc2lvbihleHByOiBzdHJpbmcpIHtcbiAgICBjb25zdCB7IG9uQ2xpY2tFeGFtcGxlIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2hlYXQtc2hlZXQtaXRlbV9fZXhhbXBsZVwiIGtleT17ZXhwcn0gb25DbGljaz17KGUpID0+IG9uQ2xpY2tFeGFtcGxlKHsgcmVmSWQ6ICdBJywgZXhwciB9KX0+XG4gICAgICAgIDxjb2RlPntleHByfTwvY29kZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyB1c2VyRXhhbXBsZXMgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgaGFzVXNlckV4YW1wbGVzID0gdXNlckV4YW1wbGVzLmxlbmd0aCA+IDA7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdj5cbiAgICAgICAgPGgyPkxva2kgQ2hlYXQgU2hlZXQ8L2gyPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNoZWF0LXNoZWV0LWl0ZW1cIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNoZWF0LXNoZWV0LWl0ZW1fX3RpdGxlXCI+U2VlIHlvdXIgbG9nczwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2hlYXQtc2hlZXQtaXRlbV9fbGFiZWxcIj5cbiAgICAgICAgICAgIFN0YXJ0IGJ5IHNlbGVjdGluZyBhIGxvZyBzdHJlYW0gZnJvbSB0aGUgTG9nIGJyb3dzZXIsIG9yIGFsdGVybmF0aXZlbHkgeW91IGNhbiB3cml0ZSBhIHN0cmVhbSBzZWxlY3RvciBpbnRvXG4gICAgICAgICAgICB0aGUgcXVlcnkgZmllbGQuXG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAge2hhc1VzZXJFeGFtcGxlcyA/IChcbiAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2hlYXQtc2hlZXQtaXRlbV9fbGFiZWxcIj5IZXJlIGFyZSBzb21lIGV4YW1wbGUgc3RyZWFtcyBmcm9tIHlvdXIgbG9nczo8L2Rpdj5cbiAgICAgICAgICAgICAge3VzZXJFeGFtcGxlcy5tYXAoKGV4YW1wbGUpID0+IHRoaXMucmVuZGVyRXhwcmVzc2lvbihleGFtcGxlKSl9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICApIDogKFxuICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjaGVhdC1zaGVldC1pdGVtX19sYWJlbFwiPkhlcmUgaXMgYW4gZXhhbXBsZSBvZiBhIGxvZyBzdHJlYW06PC9kaXY+XG4gICAgICAgICAgICAgIHt0aGlzLnJlbmRlckV4cHJlc3Npb24oREVGQVVMVF9FWEFNUExFU1swXSl9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICApfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjaGVhdC1zaGVldC1pdGVtXCI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjaGVhdC1zaGVldC1pdGVtX190aXRsZVwiPkNvbWJpbmUgc3RyZWFtIHNlbGVjdG9yczwvZGl2PlxuICAgICAgICAgIHt0aGlzLnJlbmRlckV4cHJlc3Npb24oJ3thcHA9XCJjYXNzYW5kcmFcIixuYW1lc3BhY2U9XCJwcm9kXCJ9Jyl9XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjaGVhdC1zaGVldC1pdGVtX19sYWJlbFwiPlJldHVybnMgYWxsIGxvZyBsaW5lcyBmcm9tIHN0cmVhbXMgdGhhdCBoYXZlIGJvdGggbGFiZWxzLjwvZGl2PlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNoZWF0LXNoZWV0LWl0ZW1cIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNoZWF0LXNoZWV0LWl0ZW1fX3RpdGxlXCI+RmlsdGVyaW5nIGZvciBzZWFyY2ggdGVybXMuPC9kaXY+XG4gICAgICAgICAge3RoaXMucmVuZGVyRXhwcmVzc2lvbigne2FwcD1cImNhc3NhbmRyYVwifSB8fiBcIihkdXJhdGlvbnxsYXRlbmN5KXMqKD18aXN8b2YpcypbZC5dK1wiJyl9XG4gICAgICAgICAge3RoaXMucmVuZGVyRXhwcmVzc2lvbigne2FwcD1cImNhc3NhbmRyYVwifSB8PSBcImV4YWN0IG1hdGNoXCInKX1cbiAgICAgICAgICB7dGhpcy5yZW5kZXJFeHByZXNzaW9uKCd7YXBwPVwiY2Fzc2FuZHJhXCJ9ICE9IFwiZG8gbm90IG1hdGNoXCInKX1cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNoZWF0LXNoZWV0LWl0ZW1fX2xhYmVsXCI+XG4gICAgICAgICAgICA8YSBocmVmPVwiaHR0cHM6Ly9ncmFmYW5hLmNvbS9kb2NzL2xva2kvbGF0ZXN0L2xvZ3FsLyNsb2ctcGlwZWxpbmVcIiB0YXJnZXQ9XCJsb2dxbFwiPlxuICAgICAgICAgICAgICBMb2dRTFxuICAgICAgICAgICAgPC9hPnsnICd9XG4gICAgICAgICAgICBzdXBwb3J0cyBleGFjdCBhbmQgcmVndWxhciBleHByZXNzaW9uIGZpbHRlcnMuXG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICB7TE9HUUxfRVhBTVBMRVMubWFwKChpdGVtKSA9PiAoXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjaGVhdC1zaGVldC1pdGVtXCIga2V5PXtpdGVtLmV4cHJlc3Npb259PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjaGVhdC1zaGVldC1pdGVtX190aXRsZVwiPntpdGVtLnRpdGxlfTwvZGl2PlxuICAgICAgICAgICAge3RoaXMucmVuZGVyRXhwcmVzc2lvbihpdGVtLmV4cHJlc3Npb24pfVxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjaGVhdC1zaGVldC1pdGVtX19sYWJlbFwiPntpdGVtLmxhYmVsfTwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApKX1cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cbiIsIi8vIExpYnJhcmllc1xuaW1wb3J0IFJlYWN0LCB7IG1lbW8gfSBmcm9tICdyZWFjdCc7XG5cbi8vIFR5cGVzXG5pbXBvcnQgeyBRdWVyeUVkaXRvclByb3BzIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5cbmltcG9ydCB7IExva2lEYXRhc291cmNlIH0gZnJvbSAnLi4vZGF0YXNvdXJjZSc7XG5pbXBvcnQgeyBMb2tpUXVlcnksIExva2lPcHRpb25zIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBMb2tpT3B0aW9uRmllbGRzIH0gZnJvbSAnLi9Mb2tpT3B0aW9uRmllbGRzJztcbmltcG9ydCB7IExva2lRdWVyeUZpZWxkIH0gZnJvbSAnLi9Mb2tpUXVlcnlGaWVsZCc7XG5cbnR5cGUgUHJvcHMgPSBRdWVyeUVkaXRvclByb3BzPExva2lEYXRhc291cmNlLCBMb2tpUXVlcnksIExva2lPcHRpb25zPjtcblxuZXhwb3J0IGNvbnN0IExva2lFeHBsb3JlUXVlcnlFZGl0b3IgPSBtZW1vKChwcm9wczogUHJvcHMpID0+IHtcbiAgY29uc3QgeyBxdWVyeSwgZGF0YSwgZGF0YXNvdXJjZSwgaGlzdG9yeSwgb25DaGFuZ2UsIG9uUnVuUXVlcnksIHJhbmdlIH0gPSBwcm9wcztcblxuICByZXR1cm4gKFxuICAgIDxMb2tpUXVlcnlGaWVsZFxuICAgICAgZGF0YXNvdXJjZT17ZGF0YXNvdXJjZX1cbiAgICAgIHF1ZXJ5PXtxdWVyeX1cbiAgICAgIG9uQ2hhbmdlPXtvbkNoYW5nZX1cbiAgICAgIG9uQmx1cj17KCkgPT4ge319XG4gICAgICBvblJ1blF1ZXJ5PXtvblJ1blF1ZXJ5fVxuICAgICAgaGlzdG9yeT17aGlzdG9yeX1cbiAgICAgIGRhdGE9e2RhdGF9XG4gICAgICByYW5nZT17cmFuZ2V9XG4gICAgICBkYXRhLXRlc3RpZD17dGVzdElkcy5lZGl0b3J9XG4gICAgICBFeHRyYUZpZWxkRWxlbWVudD17XG4gICAgICAgIDxMb2tpT3B0aW9uRmllbGRzXG4gICAgICAgICAgbGluZUxpbWl0VmFsdWU9e3F1ZXJ5Py5tYXhMaW5lcz8udG9TdHJpbmcoKSB8fCAnJ31cbiAgICAgICAgICByZXNvbHV0aW9uPXtxdWVyeS5yZXNvbHV0aW9uIHx8IDF9XG4gICAgICAgICAgcXVlcnk9e3F1ZXJ5fVxuICAgICAgICAgIG9uUnVuUXVlcnk9e29uUnVuUXVlcnl9XG4gICAgICAgICAgb25DaGFuZ2U9e29uQ2hhbmdlfVxuICAgICAgICAvPlxuICAgICAgfVxuICAgIC8+XG4gICk7XG59KTtcblxuTG9raUV4cGxvcmVRdWVyeUVkaXRvci5kaXNwbGF5TmFtZSA9ICdMb2tpRXhwbG9yZVF1ZXJ5RWRpdG9yJztcblxuZXhwb3J0IGNvbnN0IHRlc3RJZHMgPSB7XG4gIGVkaXRvcjogJ2xva2ktZWRpdG9yLWV4cGxvcmUnLFxufTtcbiIsImltcG9ydCB7IGNzcywgY3ggfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IHsgc29ydEJ5IH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBSZWFjdCwgeyBDaGFuZ2VFdmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEZpeGVkU2l6ZUxpc3QgfSBmcm9tICdyZWFjdC13aW5kb3cnO1xuXG5pbXBvcnQgeyBHcmFmYW5hVGhlbWUyIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQge1xuICBCdXR0b24sXG4gIEhpZ2hsaWdodFBhcnQsXG4gIEhvcml6b250YWxHcm91cCxcbiAgSW5wdXQsXG4gIExhYmVsLFxuICBMb2FkaW5nUGxhY2Vob2xkZXIsXG4gIHdpdGhUaGVtZTIsXG4gIEJyb3dzZXJMYWJlbCBhcyBMb2tpTGFiZWwsXG4gIGZ1enp5TWF0Y2gsXG59IGZyb20gJ0BncmFmYW5hL3VpJztcblxuaW1wb3J0IFByb21RbExhbmd1YWdlUHJvdmlkZXIgZnJvbSAnLi4vLi4vcHJvbWV0aGV1cy9sYW5ndWFnZV9wcm92aWRlcic7XG5pbXBvcnQgTG9raUxhbmd1YWdlUHJvdmlkZXIgZnJvbSAnLi4vbGFuZ3VhZ2VfcHJvdmlkZXInO1xuaW1wb3J0IHsgZXNjYXBlTGFiZWxWYWx1ZUluRXhhY3RTZWxlY3RvciwgZXNjYXBlTGFiZWxWYWx1ZUluUmVnZXhTZWxlY3RvciB9IGZyb20gJy4uL2xhbmd1YWdlX3V0aWxzJztcblxuLy8gSGFyZCBsaW1pdCBvbiBsYWJlbHMgdG8gcmVuZGVyXG5jb25zdCBNQVhfTEFCRUxfQ09VTlQgPSAxMDAwO1xuY29uc3QgTUFYX1ZBTFVFX0NPVU5UID0gMTAwMDA7XG5jb25zdCBNQVhfQVVUT19TRUxFQ1QgPSA0O1xuY29uc3QgRU1QVFlfU0VMRUNUT1IgPSAne30nO1xuXG5leHBvcnQgaW50ZXJmYWNlIEJyb3dzZXJQcm9wcyB7XG4gIC8vIFRPRE8gIzMzOTc2OiBJcyBpdCBwb3NzaWJsZSB0byB1c2UgYSBjb21tb24gaW50ZXJmYWNlIGhlcmU/IEZvciBleGFtcGxlOiBMYWJlbHNMYW5ndWFnZVByb3ZpZGVyXG4gIGxhbmd1YWdlUHJvdmlkZXI6IExva2lMYW5ndWFnZVByb3ZpZGVyIHwgUHJvbVFsTGFuZ3VhZ2VQcm92aWRlcjtcbiAgb25DaGFuZ2U6IChzZWxlY3Rvcjogc3RyaW5nKSA9PiB2b2lkO1xuICB0aGVtZTogR3JhZmFuYVRoZW1lMjtcbiAgYXV0b1NlbGVjdD86IG51bWJlcjtcbiAgaGlkZT86ICgpID0+IHZvaWQ7XG4gIGxhc3RVc2VkTGFiZWxzOiBzdHJpbmdbXTtcbiAgc3RvcmVMYXN0VXNlZExhYmVsczogKGxhYmVsczogc3RyaW5nW10pID0+IHZvaWQ7XG4gIGRlbGV0ZUxhc3RVc2VkTGFiZWxzOiAoKSA9PiB2b2lkO1xufVxuXG5pbnRlcmZhY2UgQnJvd3NlclN0YXRlIHtcbiAgbGFiZWxzOiBTZWxlY3RhYmxlTGFiZWxbXTtcbiAgc2VhcmNoVGVybTogc3RyaW5nO1xuICBzdGF0dXM6IHN0cmluZztcbiAgZXJyb3I6IHN0cmluZztcbiAgdmFsaWRhdGlvblN0YXR1czogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgRmFjZXR0YWJsZVZhbHVlIHtcbiAgbmFtZTogc3RyaW5nO1xuICBzZWxlY3RlZD86IGJvb2xlYW47XG4gIGhpZ2hsaWdodFBhcnRzPzogSGlnaGxpZ2h0UGFydFtdO1xuICBvcmRlcj86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZWxlY3RhYmxlTGFiZWwge1xuICBuYW1lOiBzdHJpbmc7XG4gIHNlbGVjdGVkPzogYm9vbGVhbjtcbiAgbG9hZGluZz86IGJvb2xlYW47XG4gIHZhbHVlcz86IEZhY2V0dGFibGVWYWx1ZVtdO1xuICBoaWRkZW4/OiBib29sZWFuO1xuICBmYWNldHM/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZFNlbGVjdG9yKGxhYmVsczogU2VsZWN0YWJsZUxhYmVsW10pOiBzdHJpbmcge1xuICBjb25zdCBzZWxlY3RlZExhYmVscyA9IFtdO1xuICBmb3IgKGNvbnN0IGxhYmVsIG9mIGxhYmVscykge1xuICAgIGlmIChsYWJlbC5zZWxlY3RlZCAmJiBsYWJlbC52YWx1ZXMgJiYgbGFiZWwudmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkVmFsdWVzID0gbGFiZWwudmFsdWVzLmZpbHRlcigodmFsdWUpID0+IHZhbHVlLnNlbGVjdGVkKS5tYXAoKHZhbHVlKSA9PiB2YWx1ZS5uYW1lKTtcbiAgICAgIGlmIChzZWxlY3RlZFZhbHVlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHNlbGVjdGVkTGFiZWxzLnB1c2goYCR7bGFiZWwubmFtZX09flwiJHtzZWxlY3RlZFZhbHVlcy5tYXAoZXNjYXBlTGFiZWxWYWx1ZUluUmVnZXhTZWxlY3Rvcikuam9pbignfCcpfVwiYCk7XG4gICAgICB9IGVsc2UgaWYgKHNlbGVjdGVkVmFsdWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBzZWxlY3RlZExhYmVscy5wdXNoKGAke2xhYmVsLm5hbWV9PVwiJHtlc2NhcGVMYWJlbFZhbHVlSW5FeGFjdFNlbGVjdG9yKHNlbGVjdGVkVmFsdWVzWzBdKX1cImApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gWyd7Jywgc2VsZWN0ZWRMYWJlbHMuam9pbignLCcpLCAnfSddLmpvaW4oJycpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmFjZXRMYWJlbHMoXG4gIGxhYmVsczogU2VsZWN0YWJsZUxhYmVsW10sXG4gIHBvc3NpYmxlTGFiZWxzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT4sXG4gIGxhc3RGYWNldHRlZD86IHN0cmluZ1xuKTogU2VsZWN0YWJsZUxhYmVsW10ge1xuICByZXR1cm4gbGFiZWxzLm1hcCgobGFiZWwpID0+IHtcbiAgICBjb25zdCBwb3NzaWJsZVZhbHVlcyA9IHBvc3NpYmxlTGFiZWxzW2xhYmVsLm5hbWVdO1xuICAgIGlmIChwb3NzaWJsZVZhbHVlcykge1xuICAgICAgbGV0IGV4aXN0aW5nVmFsdWVzOiBGYWNldHRhYmxlVmFsdWVbXTtcbiAgICAgIGlmIChsYWJlbC5uYW1lID09PSBsYXN0RmFjZXR0ZWQgJiYgbGFiZWwudmFsdWVzKSB7XG4gICAgICAgIC8vIEZhY2V0dGluZyB0aGlzIGxhYmVsLCBzaG93IGFsbCB2YWx1ZXNcbiAgICAgICAgZXhpc3RpbmdWYWx1ZXMgPSBsYWJlbC52YWx1ZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBLZWVwIHNlbGVjdGlvbiBpbiBvdGhlciBmYWNldHNcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRWYWx1ZXM6IFNldDxzdHJpbmc+ID0gbmV3IFNldChcbiAgICAgICAgICBsYWJlbC52YWx1ZXM/LmZpbHRlcigodmFsdWUpID0+IHZhbHVlLnNlbGVjdGVkKS5tYXAoKHZhbHVlKSA9PiB2YWx1ZS5uYW1lKSB8fCBbXVxuICAgICAgICApO1xuICAgICAgICAvLyBWYWx1ZXMgZm9yIHRoaXMgbGFiZWwgaGF2ZSBub3QgYmVlbiByZXF1ZXN0ZWQgeWV0LCBsZXQncyB1c2UgdGhlIGZhY2V0dGVkIG9uZXMgYXMgdGhlIGluaXRpYWwgdmFsdWVzXG4gICAgICAgIGV4aXN0aW5nVmFsdWVzID0gcG9zc2libGVWYWx1ZXMubWFwKCh2YWx1ZSkgPT4gKHsgbmFtZTogdmFsdWUsIHNlbGVjdGVkOiBzZWxlY3RlZFZhbHVlcy5oYXModmFsdWUpIH0pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IC4uLmxhYmVsLCBsb2FkaW5nOiBmYWxzZSwgdmFsdWVzOiBleGlzdGluZ1ZhbHVlcywgZmFjZXRzOiBleGlzdGluZ1ZhbHVlcy5sZW5ndGggfTtcbiAgICB9XG5cbiAgICAvLyBMYWJlbCBpcyBmYWNldHRlZCBvdXQsIGhpZGUgYWxsIHZhbHVlc1xuICAgIHJldHVybiB7IC4uLmxhYmVsLCBsb2FkaW5nOiBmYWxzZSwgaGlkZGVuOiAhcG9zc2libGVWYWx1ZXMsIHZhbHVlczogdW5kZWZpbmVkLCBmYWNldHM6IDAgfTtcbiAgfSk7XG59XG5cbmNvbnN0IGdldFN0eWxlcyA9ICh0aGVtZTogR3JhZmFuYVRoZW1lMikgPT4gKHtcbiAgd3JhcHBlcjogY3NzYFxuICAgIGJhY2tncm91bmQtY29sb3I6ICR7dGhlbWUuY29sb3JzLmJhY2tncm91bmQuc2Vjb25kYXJ5fTtcbiAgICBwYWRkaW5nOiAke3RoZW1lLnNwYWNpbmcoMil9O1xuICAgIHdpZHRoOiAxMDAlO1xuICBgLFxuICBsaXN0OiBjc3NgXG4gICAgbWFyZ2luLXRvcDogJHt0aGVtZS5zcGFjaW5nKDEpfTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtd3JhcDogd3JhcDtcbiAgICBtYXgtaGVpZ2h0OiAyMDBweDtcbiAgICBvdmVyZmxvdzogYXV0bztcbiAgYCxcbiAgc2VjdGlvbjogY3NzYFxuICAgICYgKyAmIHtcbiAgICAgIG1hcmdpbjogJHt0aGVtZS5zcGFjaW5nKDIsIDApfTtcbiAgICB9XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICBgLFxuICBzZWxlY3RvcjogY3NzYFxuICAgIGZvbnQtZmFtaWx5OiAke3RoZW1lLnR5cG9ncmFwaHkuZm9udEZhbWlseU1vbm9zcGFjZX07XG4gICAgbWFyZ2luLWJvdHRvbTogJHt0aGVtZS5zcGFjaW5nKDEpfTtcbiAgYCxcbiAgc3RhdHVzOiBjc3NgXG4gICAgcGFkZGluZzogJHt0aGVtZS5zcGFjaW5nKDAuNSl9O1xuICAgIGNvbG9yOiAke3RoZW1lLmNvbG9ycy50ZXh0LnNlY29uZGFyeX07XG4gICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuICAgIC8qIHVzaW5nIGFic29sdXRlIHBvc2l0aW9uaW5nIGJlY2F1c2UgZmxleCBpbnRlcmZlcmVzIHdpdGggZWxsaXBzaXMgKi9cbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgd2lkdGg6IDUwJTtcbiAgICByaWdodDogMDtcbiAgICB0ZXh0LWFsaWduOiByaWdodDtcbiAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDEwMG1zIGxpbmVhcjtcbiAgICBvcGFjaXR5OiAwO1xuICBgLFxuICBzdGF0dXNTaG93aW5nOiBjc3NgXG4gICAgb3BhY2l0eTogMTtcbiAgYCxcbiAgZXJyb3I6IGNzc2BcbiAgICBjb2xvcjogJHt0aGVtZS5jb2xvcnMuZXJyb3IubWFpbn07XG4gIGAsXG4gIHZhbHVlTGlzdDogY3NzYFxuICAgIG1hcmdpbi1yaWdodDogJHt0aGVtZS5zcGFjaW5nKDEpfTtcbiAgYCxcbiAgdmFsdWVMaXN0V3JhcHBlcjogY3NzYFxuICAgIGJvcmRlci1sZWZ0OiAxcHggc29saWQgJHt0aGVtZS5jb2xvcnMuYm9yZGVyLm1lZGl1bX07XG4gICAgbWFyZ2luOiAke3RoZW1lLnNwYWNpbmcoMSwgMCl9O1xuICAgIHBhZGRpbmc6ICR7dGhlbWUuc3BhY2luZygxLCAwLCAxLCAxKX07XG4gIGAsXG4gIHZhbHVlTGlzdEFyZWE6IGNzc2BcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtd3JhcDogd3JhcDtcbiAgICBtYXJnaW4tdG9wOiAke3RoZW1lLnNwYWNpbmcoMSl9O1xuICBgLFxuICB2YWx1ZVRpdGxlOiBjc3NgXG4gICAgbWFyZ2luLWxlZnQ6IC0ke3RoZW1lLnNwYWNpbmcoMC41KX07XG4gICAgbWFyZ2luLWJvdHRvbTogJHt0aGVtZS5zcGFjaW5nKDEpfTtcbiAgYCxcbiAgdmFsaWRhdGlvblN0YXR1czogY3NzYFxuICAgIHBhZGRpbmc6ICR7dGhlbWUuc3BhY2luZygwLjUpfTtcbiAgICBtYXJnaW4tYm90dG9tOiAke3RoZW1lLnNwYWNpbmcoMSl9O1xuICAgIGNvbG9yOiAke3RoZW1lLmNvbG9ycy50ZXh0Lm1heENvbnRyYXN0fTtcbiAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG4gIGAsXG59KTtcblxuZXhwb3J0IGNsYXNzIFVudGhlbWVkTG9raUxhYmVsQnJvd3NlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxCcm93c2VyUHJvcHMsIEJyb3dzZXJTdGF0ZT4ge1xuICBzdGF0ZTogQnJvd3NlclN0YXRlID0ge1xuICAgIGxhYmVsczogW10gYXMgU2VsZWN0YWJsZUxhYmVsW10sXG4gICAgc2VhcmNoVGVybTogJycsXG4gICAgc3RhdHVzOiAnUmVhZHknLFxuICAgIGVycm9yOiAnJyxcbiAgICB2YWxpZGF0aW9uU3RhdHVzOiAnJyxcbiAgfTtcblxuICBvbkNoYW5nZVNlYXJjaCA9IChldmVudDogQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHsgc2VhcmNoVGVybTogZXZlbnQudGFyZ2V0LnZhbHVlIH0pO1xuICB9O1xuXG4gIG9uQ2xpY2tSdW5Mb2dzUXVlcnkgPSAoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBidWlsZFNlbGVjdG9yKHRoaXMuc3RhdGUubGFiZWxzKTtcbiAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHNlbGVjdG9yKTtcbiAgfTtcblxuICBvbkNsaWNrUnVuTWV0cmljc1F1ZXJ5ID0gKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdG9yID0gYnVpbGRTZWxlY3Rvcih0aGlzLnN0YXRlLmxhYmVscyk7XG4gICAgY29uc3QgcXVlcnkgPSBgcmF0ZSgke3NlbGVjdG9yfVskX19pbnRlcnZhbF0pYDtcbiAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHF1ZXJ5KTtcbiAgfTtcblxuICBvbkNsaWNrQ2xlYXIgPSAoKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSgoc3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IGxhYmVsczogU2VsZWN0YWJsZUxhYmVsW10gPSBzdGF0ZS5sYWJlbHMubWFwKChsYWJlbCkgPT4gKHtcbiAgICAgICAgLi4ubGFiZWwsXG4gICAgICAgIHZhbHVlczogdW5kZWZpbmVkLFxuICAgICAgICBzZWxlY3RlZDogZmFsc2UsXG4gICAgICAgIGxvYWRpbmc6IGZhbHNlLFxuICAgICAgICBoaWRkZW46IGZhbHNlLFxuICAgICAgICBmYWNldHM6IHVuZGVmaW5lZCxcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiB7IGxhYmVscywgc2VhcmNoVGVybTogJycsIHN0YXR1czogJycsIGVycm9yOiAnJywgdmFsaWRhdGlvblN0YXR1czogJycgfTtcbiAgICB9KTtcbiAgICB0aGlzLnByb3BzLmRlbGV0ZUxhc3RVc2VkTGFiZWxzKCk7XG4gIH07XG5cbiAgb25DbGlja0xhYmVsID0gKG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyB8IHVuZGVmaW5lZCwgZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQ8SFRNTEVsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLnN0YXRlLmxhYmVscy5maW5kKChsKSA9PiBsLm5hbWUgPT09IG5hbWUpO1xuICAgIGlmICghbGFiZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gVG9nZ2xlIHNlbGVjdGVkIHN0YXRlXG4gICAgY29uc3Qgc2VsZWN0ZWQgPSAhbGFiZWwuc2VsZWN0ZWQ7XG4gICAgbGV0IG5leHRWYWx1ZTogUGFydGlhbDxTZWxlY3RhYmxlTGFiZWw+ID0geyBzZWxlY3RlZCB9O1xuICAgIGlmIChsYWJlbC52YWx1ZXMgJiYgIXNlbGVjdGVkKSB7XG4gICAgICAvLyBEZXNlbGVjdCBhbGwgdmFsdWVzIGlmIGxhYmVsIHdhcyBkZXNlbGVjdGVkXG4gICAgICBjb25zdCB2YWx1ZXMgPSBsYWJlbC52YWx1ZXMubWFwKCh2YWx1ZSkgPT4gKHsgLi4udmFsdWUsIHNlbGVjdGVkOiBmYWxzZSB9KSk7XG4gICAgICBuZXh0VmFsdWUgPSB7IC4uLm5leHRWYWx1ZSwgZmFjZXRzOiAwLCB2YWx1ZXMgfTtcbiAgICB9XG4gICAgLy8gUmVzZXR0aW5nIHNlYXJjaCB0byBwcmV2ZW50IGVtcHR5IHJlc3VsdHNcbiAgICB0aGlzLnNldFN0YXRlKHsgc2VhcmNoVGVybTogJycgfSk7XG4gICAgdGhpcy51cGRhdGVMYWJlbFN0YXRlKG5hbWUsIG5leHRWYWx1ZSwgJycsICgpID0+IHRoaXMuZG9GYWNldHRpbmdGb3JMYWJlbChuYW1lKSk7XG4gIH07XG5cbiAgb25DbGlja1ZhbHVlID0gKG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyB8IHVuZGVmaW5lZCwgZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQ8SFRNTEVsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLnN0YXRlLmxhYmVscy5maW5kKChsKSA9PiBsLm5hbWUgPT09IG5hbWUpO1xuICAgIGlmICghbGFiZWwgfHwgIWxhYmVsLnZhbHVlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBSZXNldHRpbmcgc2VhcmNoIHRvIHByZXZlbnQgZW1wdHkgcmVzdWx0c1xuICAgIHRoaXMuc2V0U3RhdGUoeyBzZWFyY2hUZXJtOiAnJyB9KTtcbiAgICAvLyBUb2dnbGluZyB2YWx1ZSBmb3Igc2VsZWN0ZWQgbGFiZWwsIGxlYXZpbmcgb3RoZXIgdmFsdWVzIGludGFjdFxuICAgIGNvbnN0IHZhbHVlcyA9IGxhYmVsLnZhbHVlcy5tYXAoKHYpID0+ICh7IC4uLnYsIHNlbGVjdGVkOiB2Lm5hbWUgPT09IHZhbHVlID8gIXYuc2VsZWN0ZWQgOiB2LnNlbGVjdGVkIH0pKTtcbiAgICB0aGlzLnVwZGF0ZUxhYmVsU3RhdGUobmFtZSwgeyB2YWx1ZXMgfSwgJycsICgpID0+IHRoaXMuZG9GYWNldHRpbmcobmFtZSkpO1xuICB9O1xuXG4gIG9uQ2xpY2tWYWxpZGF0ZSA9ICgpID0+IHtcbiAgICBjb25zdCBzZWxlY3RvciA9IGJ1aWxkU2VsZWN0b3IodGhpcy5zdGF0ZS5sYWJlbHMpO1xuICAgIHRoaXMudmFsaWRhdGVTZWxlY3RvcihzZWxlY3Rvcik7XG4gIH07XG5cbiAgdXBkYXRlTGFiZWxTdGF0ZShuYW1lOiBzdHJpbmcsIHVwZGF0ZWRGaWVsZHM6IFBhcnRpYWw8U2VsZWN0YWJsZUxhYmVsPiwgc3RhdHVzID0gJycsIGNiPzogKCkgPT4gdm9pZCkge1xuICAgIHRoaXMuc2V0U3RhdGUoKHN0YXRlKSA9PiB7XG4gICAgICBjb25zdCBsYWJlbHM6IFNlbGVjdGFibGVMYWJlbFtdID0gc3RhdGUubGFiZWxzLm1hcCgobGFiZWwpID0+IHtcbiAgICAgICAgaWYgKGxhYmVsLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4geyAuLi5sYWJlbCwgLi4udXBkYXRlZEZpZWxkcyB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYWJlbDtcbiAgICAgIH0pO1xuICAgICAgLy8gTmV3IHN0YXR1cyBvdmVycmlkZXMgZXJyb3JzXG4gICAgICBjb25zdCBlcnJvciA9IHN0YXR1cyA/ICcnIDogc3RhdGUuZXJyb3I7XG4gICAgICByZXR1cm4geyBsYWJlbHMsIHN0YXR1cywgZXJyb3IsIHZhbGlkYXRpb25TdGF0dXM6ICcnIH07XG4gICAgfSwgY2IpO1xuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgY29uc3QgeyBsYW5ndWFnZVByb3ZpZGVyLCBhdXRvU2VsZWN0ID0gTUFYX0FVVE9fU0VMRUNULCBsYXN0VXNlZExhYmVscyB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAobGFuZ3VhZ2VQcm92aWRlcikge1xuICAgICAgY29uc3Qgc2VsZWN0ZWRMYWJlbHM6IHN0cmluZ1tdID0gbGFzdFVzZWRMYWJlbHM7XG4gICAgICBsYW5ndWFnZVByb3ZpZGVyLnN0YXJ0KCkudGhlbigoKSA9PiB7XG4gICAgICAgIGxldCByYXdMYWJlbHM6IHN0cmluZ1tdID0gbGFuZ3VhZ2VQcm92aWRlci5nZXRMYWJlbEtleXMoKTtcbiAgICAgICAgaWYgKHJhd0xhYmVscy5sZW5ndGggPiBNQVhfTEFCRUxfQ09VTlQpIHtcbiAgICAgICAgICBjb25zdCBlcnJvciA9IGBUb28gbWFueSBsYWJlbHMgZm91bmQgKHNob3dpbmcgb25seSAke01BWF9MQUJFTF9DT1VOVH0gb2YgJHtyYXdMYWJlbHMubGVuZ3RofSlgO1xuICAgICAgICAgIHJhd0xhYmVscyA9IHJhd0xhYmVscy5zbGljZSgwLCBNQVhfTEFCRUxfQ09VTlQpO1xuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBlcnJvciB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBdXRvLXNlbGVjdCBhbGwgbGFiZWxzIGlmIGxhYmVsIGxpc3QgaXMgc21hbGwgZW5vdWdoXG4gICAgICAgIGNvbnN0IGxhYmVsczogU2VsZWN0YWJsZUxhYmVsW10gPSByYXdMYWJlbHMubWFwKChsYWJlbCwgaSwgYXJyKSA9PiAoe1xuICAgICAgICAgIG5hbWU6IGxhYmVsLFxuICAgICAgICAgIHNlbGVjdGVkOiAoYXJyLmxlbmd0aCA8PSBhdXRvU2VsZWN0ICYmIHNlbGVjdGVkTGFiZWxzLmxlbmd0aCA9PT0gMCkgfHwgc2VsZWN0ZWRMYWJlbHMuaW5jbHVkZXMobGFiZWwpLFxuICAgICAgICAgIGxvYWRpbmc6IGZhbHNlLFxuICAgICAgICB9KSk7XG4gICAgICAgIC8vIFByZS1mZXRjaCB2YWx1ZXMgZm9yIHNlbGVjdGVkIGxhYmVsc1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgbGFiZWxzIH0sICgpID0+IHtcbiAgICAgICAgICB0aGlzLnN0YXRlLmxhYmVscy5mb3JFYWNoKChsYWJlbCkgPT4ge1xuICAgICAgICAgICAgaWYgKGxhYmVsLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgIHRoaXMuZmV0Y2hWYWx1ZXMobGFiZWwubmFtZSwgRU1QVFlfU0VMRUNUT1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGRvRmFjZXR0aW5nRm9yTGFiZWwobmFtZTogc3RyaW5nKSB7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLnN0YXRlLmxhYmVscy5maW5kKChsKSA9PiBsLm5hbWUgPT09IG5hbWUpO1xuICAgIGlmICghbGFiZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0ZWRMYWJlbHMgPSB0aGlzLnN0YXRlLmxhYmVscy5maWx0ZXIoKGxhYmVsKSA9PiBsYWJlbC5zZWxlY3RlZCkubWFwKChsYWJlbCkgPT4gbGFiZWwubmFtZSk7XG4gICAgdGhpcy5wcm9wcy5zdG9yZUxhc3RVc2VkTGFiZWxzKHNlbGVjdGVkTGFiZWxzKTtcbiAgICBpZiAobGFiZWwuc2VsZWN0ZWQpIHtcbiAgICAgIC8vIFJlZmV0Y2ggdmFsdWVzIGZvciBuZXdseSBzZWxlY3RlZCBsYWJlbC4uLlxuICAgICAgaWYgKCFsYWJlbC52YWx1ZXMpIHtcbiAgICAgICAgdGhpcy5mZXRjaFZhbHVlcyhuYW1lLCBidWlsZFNlbGVjdG9yKHRoaXMuc3RhdGUubGFiZWxzKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9ubHkgbmVlZCB0byBmYWNldCB3aGVuIGRlc2VsZWN0aW5nIGxhYmVsc1xuICAgICAgdGhpcy5kb0ZhY2V0dGluZygpO1xuICAgIH1cbiAgfVxuXG4gIGRvRmFjZXR0aW5nID0gKGxhc3RGYWNldHRlZD86IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHNlbGVjdG9yID0gYnVpbGRTZWxlY3Rvcih0aGlzLnN0YXRlLmxhYmVscyk7XG4gICAgaWYgKHNlbGVjdG9yID09PSBFTVBUWV9TRUxFQ1RPUikge1xuICAgICAgLy8gQ2xlYXIgdXAgZmFjZXR0aW5nXG4gICAgICBjb25zdCBsYWJlbHM6IFNlbGVjdGFibGVMYWJlbFtdID0gdGhpcy5zdGF0ZS5sYWJlbHMubWFwKChsYWJlbCkgPT4ge1xuICAgICAgICByZXR1cm4geyAuLi5sYWJlbCwgZmFjZXRzOiAwLCB2YWx1ZXM6IHVuZGVmaW5lZCwgaGlkZGVuOiBmYWxzZSB9O1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgbGFiZWxzIH0sICgpID0+IHtcbiAgICAgICAgLy8gR2V0IGZyZXNoIHNldCBvZiB2YWx1ZXNcbiAgICAgICAgdGhpcy5zdGF0ZS5sYWJlbHMuZm9yRWFjaCgobGFiZWwpID0+IGxhYmVsLnNlbGVjdGVkICYmIHRoaXMuZmV0Y2hWYWx1ZXMobGFiZWwubmFtZSwgc2VsZWN0b3IpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEbyBmYWNldHRpbmdcbiAgICAgIHRoaXMuZmV0Y2hTZXJpZXMoc2VsZWN0b3IsIGxhc3RGYWNldHRlZCk7XG4gICAgfVxuICB9O1xuXG4gIGFzeW5jIGZldGNoVmFsdWVzKG5hbWU6IHN0cmluZywgc2VsZWN0b3I6IHN0cmluZykge1xuICAgIGNvbnN0IHsgbGFuZ3VhZ2VQcm92aWRlciB9ID0gdGhpcy5wcm9wcztcbiAgICB0aGlzLnVwZGF0ZUxhYmVsU3RhdGUobmFtZSwgeyBsb2FkaW5nOiB0cnVlIH0sIGBGZXRjaGluZyB2YWx1ZXMgZm9yICR7bmFtZX1gKTtcbiAgICB0cnkge1xuICAgICAgbGV0IHJhd1ZhbHVlcyA9IGF3YWl0IGxhbmd1YWdlUHJvdmlkZXIuZ2V0TGFiZWxWYWx1ZXMobmFtZSk7XG4gICAgICAvLyBJZiBzZWxlY3RvciBjaGFuZ2VkLCBjbGVhciBsb2FkaW5nIHN0YXRlIGFuZCBkaXNjYXJkIHJlc3VsdCBieSByZXR1cm5pbmcgZWFybHlcbiAgICAgIGlmIChzZWxlY3RvciAhPT0gYnVpbGRTZWxlY3Rvcih0aGlzLnN0YXRlLmxhYmVscykpIHtcbiAgICAgICAgdGhpcy51cGRhdGVMYWJlbFN0YXRlKG5hbWUsIHsgbG9hZGluZzogZmFsc2UgfSwgJycpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocmF3VmFsdWVzLmxlbmd0aCA+IE1BWF9WQUxVRV9DT1VOVCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IGBUb28gbWFueSB2YWx1ZXMgZm9yICR7bmFtZX0gKHNob3dpbmcgb25seSAke01BWF9WQUxVRV9DT1VOVH0gb2YgJHtyYXdWYWx1ZXMubGVuZ3RofSlgO1xuICAgICAgICByYXdWYWx1ZXMgPSByYXdWYWx1ZXMuc2xpY2UoMCwgTUFYX1ZBTFVFX0NPVU5UKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGVycm9yIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWVzOiBGYWNldHRhYmxlVmFsdWVbXSA9IHJhd1ZhbHVlcy5tYXAoKHZhbHVlKSA9PiAoeyBuYW1lOiB2YWx1ZSB9KSk7XG4gICAgICB0aGlzLnVwZGF0ZUxhYmVsU3RhdGUobmFtZSwgeyB2YWx1ZXMsIGxvYWRpbmc6IGZhbHNlIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBmZXRjaFNlcmllcyhzZWxlY3Rvcjogc3RyaW5nLCBsYXN0RmFjZXR0ZWQ/OiBzdHJpbmcpIHtcbiAgICBjb25zdCB7IGxhbmd1YWdlUHJvdmlkZXIgfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKGxhc3RGYWNldHRlZCkge1xuICAgICAgdGhpcy51cGRhdGVMYWJlbFN0YXRlKGxhc3RGYWNldHRlZCwgeyBsb2FkaW5nOiB0cnVlIH0sIGBGYWNldHRpbmcgbGFiZWxzIGZvciAke3NlbGVjdG9yfWApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgcG9zc2libGVMYWJlbHMgPSBhd2FpdCBsYW5ndWFnZVByb3ZpZGVyLmZldGNoU2VyaWVzTGFiZWxzKHNlbGVjdG9yLCB0cnVlKTtcbiAgICAgIC8vIElmIHNlbGVjdG9yIGNoYW5nZWQsIGNsZWFyIGxvYWRpbmcgc3RhdGUgYW5kIGRpc2NhcmQgcmVzdWx0IGJ5IHJldHVybmluZyBlYXJseVxuICAgICAgaWYgKHNlbGVjdG9yICE9PSBidWlsZFNlbGVjdG9yKHRoaXMuc3RhdGUubGFiZWxzKSkge1xuICAgICAgICBpZiAobGFzdEZhY2V0dGVkKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVMYWJlbFN0YXRlKGxhc3RGYWNldHRlZCwgeyBsb2FkaW5nOiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoT2JqZWN0LmtleXMocG9zc2libGVMYWJlbHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgZXJyb3I6IGBFbXB0eSByZXN1bHRzLCBubyBtYXRjaGluZyBsYWJlbCBmb3IgJHtzZWxlY3Rvcn1gIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBsYWJlbHM6IFNlbGVjdGFibGVMYWJlbFtdID0gZmFjZXRMYWJlbHModGhpcy5zdGF0ZS5sYWJlbHMsIHBvc3NpYmxlTGFiZWxzLCBsYXN0RmFjZXR0ZWQpO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGxhYmVscywgZXJyb3I6ICcnIH0pO1xuICAgICAgaWYgKGxhc3RGYWNldHRlZCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUxhYmVsU3RhdGUobGFzdEZhY2V0dGVkLCB7IGxvYWRpbmc6IGZhbHNlIH0pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyB2YWxpZGF0ZVNlbGVjdG9yKHNlbGVjdG9yOiBzdHJpbmcpIHtcbiAgICBjb25zdCB7IGxhbmd1YWdlUHJvdmlkZXIgfSA9IHRoaXMucHJvcHM7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IHZhbGlkYXRpb25TdGF0dXM6IGBWYWxpZGF0aW5nIHNlbGVjdG9yICR7c2VsZWN0b3J9YCwgZXJyb3I6ICcnIH0pO1xuICAgIGNvbnN0IHN0cmVhbXMgPSBhd2FpdCBsYW5ndWFnZVByb3ZpZGVyLmZldGNoU2VyaWVzKHNlbGVjdG9yKTtcbiAgICB0aGlzLnNldFN0YXRlKHsgdmFsaWRhdGlvblN0YXR1czogYFNlbGVjdG9yIGlzIHZhbGlkICgke3N0cmVhbXMubGVuZ3RofSBzdHJlYW1zIGZvdW5kKWAgfSk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyB0aGVtZSB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IGxhYmVscywgc2VhcmNoVGVybSwgc3RhdHVzLCBlcnJvciwgdmFsaWRhdGlvblN0YXR1cyB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAobGFiZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIDxMb2FkaW5nUGxhY2Vob2xkZXIgdGV4dD1cIkxvYWRpbmcgbGFiZWxzLi4uXCIgLz47XG4gICAgfVxuICAgIGNvbnN0IHN0eWxlcyA9IGdldFN0eWxlcyh0aGVtZSk7XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBidWlsZFNlbGVjdG9yKHRoaXMuc3RhdGUubGFiZWxzKTtcbiAgICBjb25zdCBlbXB0eSA9IHNlbGVjdG9yID09PSBFTVBUWV9TRUxFQ1RPUjtcblxuICAgIGxldCBzZWxlY3RlZExhYmVscyA9IGxhYmVscy5maWx0ZXIoKGxhYmVsKSA9PiBsYWJlbC5zZWxlY3RlZCAmJiBsYWJlbC52YWx1ZXMpO1xuICAgIGlmIChzZWFyY2hUZXJtKSB7XG4gICAgICBzZWxlY3RlZExhYmVscyA9IHNlbGVjdGVkTGFiZWxzLm1hcCgobGFiZWwpID0+IHtcbiAgICAgICAgY29uc3Qgc2VhcmNoUmVzdWx0cyA9IGxhYmVsLnZhbHVlcyEuZmlsdGVyKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgIC8vIEFsd2F5cyByZXR1cm4gc2VsZWN0ZWQgdmFsdWVzXG4gICAgICAgICAgaWYgKHZhbHVlLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICB2YWx1ZS5oaWdobGlnaHRQYXJ0cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBmdXp6eU1hdGNoUmVzdWx0ID0gZnV6enlNYXRjaCh2YWx1ZS5uYW1lLnRvTG93ZXJDYXNlKCksIHNlYXJjaFRlcm0udG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgaWYgKGZ1enp5TWF0Y2hSZXN1bHQuZm91bmQpIHtcbiAgICAgICAgICAgIHZhbHVlLmhpZ2hsaWdodFBhcnRzID0gZnV6enlNYXRjaFJlc3VsdC5yYW5nZXM7XG4gICAgICAgICAgICB2YWx1ZS5vcmRlciA9IGZ1enp5TWF0Y2hSZXN1bHQuZGlzdGFuY2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4ubGFiZWwsXG4gICAgICAgICAgdmFsdWVzOiBzb3J0Qnkoc2VhcmNoUmVzdWx0cywgKHZhbHVlKSA9PiAodmFsdWUuc2VsZWN0ZWQgPyAtSW5maW5pdHkgOiB2YWx1ZS5vcmRlcikpLFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENsZWFyIGhpZ2hsaWdodCBwYXJ0cyB3aGVuIHNlYXJjaFRlcm0gaXMgY2xlYXJlZFxuICAgICAgc2VsZWN0ZWRMYWJlbHMgPSB0aGlzLnN0YXRlLmxhYmVsc1xuICAgICAgICAuZmlsdGVyKChsYWJlbCkgPT4gbGFiZWwuc2VsZWN0ZWQgJiYgbGFiZWwudmFsdWVzKVxuICAgICAgICAubWFwKChsYWJlbCkgPT4gKHtcbiAgICAgICAgICAuLi5sYWJlbCxcbiAgICAgICAgICB2YWx1ZXM6IGxhYmVsPy52YWx1ZXMgPyBsYWJlbC52YWx1ZXMubWFwKCh2YWx1ZSkgPT4gKHsgLi4udmFsdWUsIGhpZ2hsaWdodFBhcnRzOiB1bmRlZmluZWQgfSkpIDogW10sXG4gICAgICAgIH0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy53cmFwcGVyfT5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5zZWN0aW9ufT5cbiAgICAgICAgICA8TGFiZWwgZGVzY3JpcHRpb249XCJXaGljaCBsYWJlbHMgd291bGQgeW91IGxpa2UgdG8gY29uc2lkZXIgZm9yIHlvdXIgc2VhcmNoP1wiPlxuICAgICAgICAgICAgMS4gU2VsZWN0IGxhYmVscyB0byBzZWFyY2ggaW5cbiAgICAgICAgICA8L0xhYmVsPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMubGlzdH0+XG4gICAgICAgICAgICB7bGFiZWxzLm1hcCgobGFiZWwpID0+IChcbiAgICAgICAgICAgICAgPExva2lMYWJlbFxuICAgICAgICAgICAgICAgIGtleT17bGFiZWwubmFtZX1cbiAgICAgICAgICAgICAgICBuYW1lPXtsYWJlbC5uYW1lfVxuICAgICAgICAgICAgICAgIGxvYWRpbmc9e2xhYmVsLmxvYWRpbmd9XG4gICAgICAgICAgICAgICAgYWN0aXZlPXtsYWJlbC5zZWxlY3RlZH1cbiAgICAgICAgICAgICAgICBoaWRkZW49e2xhYmVsLmhpZGRlbn1cbiAgICAgICAgICAgICAgICBmYWNldHM9e2xhYmVsLmZhY2V0c31cbiAgICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLm9uQ2xpY2tMYWJlbH1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICkpfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5zZWN0aW9ufT5cbiAgICAgICAgICA8TGFiZWwgZGVzY3JpcHRpb249XCJDaG9vc2UgdGhlIGxhYmVsIHZhbHVlcyB0aGF0IHlvdSB3b3VsZCBsaWtlIHRvIHVzZSBmb3IgdGhlIHF1ZXJ5LiBVc2UgdGhlIHNlYXJjaCBmaWVsZCB0byBmaW5kIHZhbHVlcyBhY3Jvc3Mgc2VsZWN0ZWQgbGFiZWxzLlwiPlxuICAgICAgICAgICAgMi4gRmluZCB2YWx1ZXMgZm9yIHRoZSBzZWxlY3RlZCBsYWJlbHNcbiAgICAgICAgICA8L0xhYmVsPlxuICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICA8SW5wdXQgb25DaGFuZ2U9e3RoaXMub25DaGFuZ2VTZWFyY2h9IGFyaWEtbGFiZWw9XCJGaWx0ZXIgZXhwcmVzc2lvbiBmb3IgdmFsdWVzXCIgdmFsdWU9e3NlYXJjaFRlcm19IC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy52YWx1ZUxpc3RBcmVhfT5cbiAgICAgICAgICAgIHtzZWxlY3RlZExhYmVscy5tYXAoKGxhYmVsKSA9PiAoXG4gICAgICAgICAgICAgIDxkaXYgcm9sZT1cImxpc3RcIiBrZXk9e2xhYmVsLm5hbWV9IGNsYXNzTmFtZT17c3R5bGVzLnZhbHVlTGlzdFdyYXBwZXJ9PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMudmFsdWVUaXRsZX0gYXJpYS1sYWJlbD17YFZhbHVlcyBmb3IgJHtsYWJlbC5uYW1lfWB9PlxuICAgICAgICAgICAgICAgICAgPExva2lMYWJlbFxuICAgICAgICAgICAgICAgICAgICBuYW1lPXtsYWJlbC5uYW1lfVxuICAgICAgICAgICAgICAgICAgICBsb2FkaW5nPXtsYWJlbC5sb2FkaW5nfVxuICAgICAgICAgICAgICAgICAgICBhY3RpdmU9e2xhYmVsLnNlbGVjdGVkfVxuICAgICAgICAgICAgICAgICAgICBoaWRkZW49e2xhYmVsLmhpZGRlbn1cbiAgICAgICAgICAgICAgICAgICAgLy9JZiBubyBmYWNldHMsIHdlIHdhbnQgdG8gc2hvdyBudW1iZXIgb2YgYWxsIGxhYmVsIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICBmYWNldHM9e2xhYmVsLmZhY2V0cyB8fCBsYWJlbC52YWx1ZXM/Lmxlbmd0aH1cbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17dGhpcy5vbkNsaWNrTGFiZWx9XG4gICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxGaXhlZFNpemVMaXN0XG4gICAgICAgICAgICAgICAgICBoZWlnaHQ9ezIwMH1cbiAgICAgICAgICAgICAgICAgIGl0ZW1Db3VudD17bGFiZWwudmFsdWVzPy5sZW5ndGggfHwgMH1cbiAgICAgICAgICAgICAgICAgIGl0ZW1TaXplPXsyOH1cbiAgICAgICAgICAgICAgICAgIGl0ZW1LZXk9eyhpKSA9PiAobGFiZWwudmFsdWVzIGFzIEZhY2V0dGFibGVWYWx1ZVtdKVtpXS5uYW1lfVxuICAgICAgICAgICAgICAgICAgd2lkdGg9ezIwMH1cbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLnZhbHVlTGlzdH1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICB7KHsgaW5kZXgsIHN0eWxlIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBsYWJlbC52YWx1ZXM/LltpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9e3N0eWxlfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxMb2tpTGFiZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT17bGFiZWwubmFtZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3ZhbHVlPy5uYW1lfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmU9e3ZhbHVlPy5zZWxlY3RlZH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0UGFydHM9e3ZhbHVlPy5oaWdobGlnaHRQYXJ0c31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17dGhpcy5vbkNsaWNrVmFsdWV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaFRlcm09e3NlYXJjaFRlcm19XG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICA8L0ZpeGVkU2l6ZUxpc3Q+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKSl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnNlY3Rpb259PlxuICAgICAgICAgIDxMYWJlbD4zLiBSZXN1bHRpbmcgc2VsZWN0b3I8L0xhYmVsPlxuICAgICAgICAgIDxkaXYgYXJpYS1sYWJlbD1cInNlbGVjdG9yXCIgY2xhc3NOYW1lPXtzdHlsZXMuc2VsZWN0b3J9PlxuICAgICAgICAgICAge3NlbGVjdG9yfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIHt2YWxpZGF0aW9uU3RhdHVzICYmIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMudmFsaWRhdGlvblN0YXR1c30+e3ZhbGlkYXRpb25TdGF0dXN9PC9kaXY+fVxuICAgICAgICAgIDxIb3Jpem9udGFsR3JvdXA+XG4gICAgICAgICAgICA8QnV0dG9uIGFyaWEtbGFiZWw9XCJVc2Ugc2VsZWN0b3IgYXMgbG9ncyBidXR0b25cIiBkaXNhYmxlZD17ZW1wdHl9IG9uQ2xpY2s9e3RoaXMub25DbGlja1J1bkxvZ3NRdWVyeX0+XG4gICAgICAgICAgICAgIFNob3cgbG9nc1xuICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgIGFyaWEtbGFiZWw9XCJVc2Ugc2VsZWN0b3IgYXMgbWV0cmljcyBidXR0b25cIlxuICAgICAgICAgICAgICB2YXJpYW50PVwic2Vjb25kYXJ5XCJcbiAgICAgICAgICAgICAgZGlzYWJsZWQ9e2VtcHR5fVxuICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLm9uQ2xpY2tSdW5NZXRyaWNzUXVlcnl9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIFNob3cgbG9ncyByYXRlXG4gICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICAgIDxCdXR0b25cbiAgICAgICAgICAgICAgYXJpYS1sYWJlbD1cIlZhbGlkYXRlIHN1Ym1pdCBidXR0b25cIlxuICAgICAgICAgICAgICB2YXJpYW50PVwic2Vjb25kYXJ5XCJcbiAgICAgICAgICAgICAgZGlzYWJsZWQ9e2VtcHR5fVxuICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLm9uQ2xpY2tWYWxpZGF0ZX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgVmFsaWRhdGUgc2VsZWN0b3JcbiAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgPEJ1dHRvbiBhcmlhLWxhYmVsPVwiU2VsZWN0b3IgY2xlYXIgYnV0dG9uXCIgdmFyaWFudD1cInNlY29uZGFyeVwiIG9uQ2xpY2s9e3RoaXMub25DbGlja0NsZWFyfT5cbiAgICAgICAgICAgICAgQ2xlYXJcbiAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2N4KHN0eWxlcy5zdGF0dXMsIChzdGF0dXMgfHwgZXJyb3IpICYmIHN0eWxlcy5zdGF0dXNTaG93aW5nKX0+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17ZXJyb3IgPyBzdHlsZXMuZXJyb3IgOiAnJ30+e2Vycm9yIHx8IHN0YXR1c308L3NwYW4+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L0hvcml6b250YWxHcm91cD5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBMb2tpTGFiZWxCcm93c2VyID0gd2l0aFRoZW1lMihVbnRoZW1lZExva2lMYWJlbEJyb3dzZXIpO1xuIiwiLy8gTGlicmFyaWVzXG5pbXBvcnQgeyBjc3MsIGN4IH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCB7IG1hcCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgUmVhY3QsIHsgbWVtbyB9IGZyb20gJ3JlYWN0JztcblxuLy8gVHlwZXNcbmltcG9ydCB7IFNlbGVjdGFibGVWYWx1ZSB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgY29uZmlnIH0gZnJvbSAnQGdyYWZhbmEvcnVudGltZSc7XG5pbXBvcnQgeyBJbmxpbmVGb3JtTGFiZWwsIFJhZGlvQnV0dG9uR3JvdXAsIElubGluZUZpZWxkLCBJbnB1dCwgU2VsZWN0IH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5pbXBvcnQgeyBMb2tpUXVlcnksIExva2lRdWVyeVR5cGUgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9raU9wdGlvbkZpZWxkc1Byb3BzIHtcbiAgbGluZUxpbWl0VmFsdWU6IHN0cmluZztcbiAgcmVzb2x1dGlvbjogbnVtYmVyO1xuICBxdWVyeTogTG9raVF1ZXJ5O1xuICBvbkNoYW5nZTogKHZhbHVlOiBMb2tpUXVlcnkpID0+IHZvaWQ7XG4gIG9uUnVuUXVlcnk6ICgpID0+IHZvaWQ7XG4gIHJ1bk9uQmx1cj86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjb25zdCBxdWVyeVR5cGVPcHRpb25zOiBBcnJheTxTZWxlY3RhYmxlVmFsdWU8TG9raVF1ZXJ5VHlwZT4+ID0gW1xuICB7IHZhbHVlOiBMb2tpUXVlcnlUeXBlLlJhbmdlLCBsYWJlbDogJ1JhbmdlJywgZGVzY3JpcHRpb246ICdSdW4gcXVlcnkgb3ZlciBhIHJhbmdlIG9mIHRpbWUuJyB9LFxuICB7XG4gICAgdmFsdWU6IExva2lRdWVyeVR5cGUuSW5zdGFudCxcbiAgICBsYWJlbDogJ0luc3RhbnQnLFxuICAgIGRlc2NyaXB0aW9uOiAnUnVuIHF1ZXJ5IGFnYWluc3QgYSBzaW5nbGUgcG9pbnQgaW4gdGltZS4gRm9yIHRoaXMgcXVlcnksIHRoZSBcIlRvXCIgdGltZSBpcyB1c2VkLicsXG4gIH0sXG5dO1xuXG5pZiAoY29uZmlnLmZlYXR1cmVUb2dnbGVzLmxva2lMaXZlKSB7XG4gIHF1ZXJ5VHlwZU9wdGlvbnMucHVzaCh7XG4gICAgdmFsdWU6IExva2lRdWVyeVR5cGUuU3RyZWFtLFxuICAgIGxhYmVsOiAnU3RyZWFtJyxcbiAgICBkZXNjcmlwdGlvbjogJ1J1biBhIHF1ZXJ5IGFuZCBrZWVwIHNlbmRpbmcgcmVzdWx0cyBvbiBhbiBpbnRlcnZhbCcsXG4gIH0pO1xufVxuXG5leHBvcnQgY29uc3QgREVGQVVMVF9SRVNPTFVUSU9OOiBTZWxlY3RhYmxlVmFsdWU8bnVtYmVyPiA9IHtcbiAgdmFsdWU6IDEsXG4gIGxhYmVsOiAnMS8xJyxcbn07XG5cbmV4cG9ydCBjb25zdCBSRVNPTFVUSU9OX09QVElPTlM6IEFycmF5PFNlbGVjdGFibGVWYWx1ZTxudW1iZXI+PiA9IFtERUZBVUxUX1JFU09MVVRJT05dLmNvbmNhdChcbiAgbWFwKFsyLCAzLCA0LCA1LCAxMF0sICh2YWx1ZTogbnVtYmVyKSA9PiAoe1xuICAgIHZhbHVlLFxuICAgIGxhYmVsOiAnMS8nICsgdmFsdWUsXG4gIH0pKVxuKTtcblxuZXhwb3J0IGZ1bmN0aW9uIExva2lPcHRpb25GaWVsZHMocHJvcHM6IExva2lPcHRpb25GaWVsZHNQcm9wcykge1xuICBjb25zdCB7IGxpbmVMaW1pdFZhbHVlLCByZXNvbHV0aW9uLCBvblJ1blF1ZXJ5LCBydW5PbkJsdXIsIG9uQ2hhbmdlIH0gPSBwcm9wcztcbiAgY29uc3QgcXVlcnkgPSBwcm9wcy5xdWVyeSA/PyB7fTtcbiAgbGV0IHF1ZXJ5VHlwZSA9IHF1ZXJ5LnF1ZXJ5VHlwZSA/PyAocXVlcnkuaW5zdGFudCA/IExva2lRdWVyeVR5cGUuSW5zdGFudCA6IExva2lRdWVyeVR5cGUuUmFuZ2UpO1xuXG4gIGZ1bmN0aW9uIG9uQ2hhbmdlUXVlcnlMaW1pdCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgY29uc3QgbmV4dFF1ZXJ5ID0geyAuLi5xdWVyeSwgbWF4TGluZXM6IHByZXByb2Nlc3NNYXhMaW5lcyh2YWx1ZSkgfTtcbiAgICBvbkNoYW5nZShuZXh0UXVlcnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25RdWVyeVR5cGVDaGFuZ2UocXVlcnlUeXBlOiBMb2tpUXVlcnlUeXBlKSB7XG4gICAgY29uc3QgeyBpbnN0YW50LCByYW5nZSwgLi4ucmVzdCB9ID0gcXVlcnk7XG4gICAgb25DaGFuZ2UoeyAuLi5yZXN0LCBxdWVyeVR5cGUgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBvbk1heExpbmVzQ2hhbmdlKGU6IFJlYWN0LlN5bnRoZXRpY0V2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSB7XG4gICAgaWYgKHF1ZXJ5Lm1heExpbmVzICE9PSBwcmVwcm9jZXNzTWF4TGluZXMoZS5jdXJyZW50VGFyZ2V0LnZhbHVlKSkge1xuICAgICAgb25DaGFuZ2VRdWVyeUxpbWl0KGUuY3VycmVudFRhcmdldC52YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25SZXR1cm5LZXlEb3duKGU6IFJlYWN0LktleWJvYXJkRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pIHtcbiAgICBpZiAoZS5rZXkgPT09ICdFbnRlcicpIHtcbiAgICAgIG9uUnVuUXVlcnkoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvblJlc29sdXRpb25DaGFuZ2Uob3B0aW9uOiBTZWxlY3RhYmxlVmFsdWU8bnVtYmVyPikge1xuICAgIGNvbnN0IG5leHRRdWVyeSA9IHsgLi4ucXVlcnksIHJlc29sdXRpb246IG9wdGlvbi52YWx1ZSB9O1xuICAgIG9uQ2hhbmdlKG5leHRRdWVyeSk7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxkaXYgYXJpYS1sYWJlbD1cIkxva2kgZXh0cmEgZmllbGRcIiBjbGFzc05hbWU9XCJnZi1mb3JtLWlubGluZVwiPlxuICAgICAgey8qUXVlcnkgdHlwZSBmaWVsZCovfVxuICAgICAgPGRpdlxuICAgICAgICBkYXRhLXRlc3RpZD1cInF1ZXJ5VHlwZUZpZWxkXCJcbiAgICAgICAgY2xhc3NOYW1lPXtjeChcbiAgICAgICAgICAnZ2YtZm9ybSBleHBsb3JlLWlucHV0LW1hcmdpbicsXG4gICAgICAgICAgY3NzYFxuICAgICAgICAgICAgZmxleC13cmFwOiBub3dyYXA7XG4gICAgICAgICAgYFxuICAgICAgICApfVxuICAgICAgICBhcmlhLWxhYmVsPVwiUXVlcnkgdHlwZSBmaWVsZFwiXG4gICAgICA+XG4gICAgICAgIDxJbmxpbmVGb3JtTGFiZWwgd2lkdGg9XCJhdXRvXCI+UXVlcnkgdHlwZTwvSW5saW5lRm9ybUxhYmVsPlxuXG4gICAgICAgIDxSYWRpb0J1dHRvbkdyb3VwXG4gICAgICAgICAgb3B0aW9ucz17cXVlcnlUeXBlT3B0aW9uc31cbiAgICAgICAgICB2YWx1ZT17cXVlcnlUeXBlfVxuICAgICAgICAgIG9uQ2hhbmdlPXsodHlwZTogTG9raVF1ZXJ5VHlwZSkgPT4ge1xuICAgICAgICAgICAgb25RdWVyeVR5cGVDaGFuZ2UodHlwZSk7XG4gICAgICAgICAgICBpZiAocnVuT25CbHVyKSB7XG4gICAgICAgICAgICAgIG9uUnVuUXVlcnkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9fVxuICAgICAgICAvPlxuICAgICAgPC9kaXY+XG4gICAgICB7LypMaW5lIGxpbWl0IGZpZWxkKi99XG4gICAgICA8ZGl2XG4gICAgICAgIGRhdGEtdGVzdGlkPVwibGluZUxpbWl0RmllbGRcIlxuICAgICAgICBjbGFzc05hbWU9e2N4KFxuICAgICAgICAgICdnZi1mb3JtJyxcbiAgICAgICAgICBjc3NgXG4gICAgICAgICAgICBmbGV4LXdyYXA6IG5vd3JhcDtcbiAgICAgICAgICBgXG4gICAgICAgICl9XG4gICAgICAgIGFyaWEtbGFiZWw9XCJMaW5lIGxpbWl0IGZpZWxkXCJcbiAgICAgID5cbiAgICAgICAgPElubGluZUZpZWxkIGxhYmVsPVwiTGluZSBsaW1pdFwiIHRvb2x0aXA9eydVcHBlciBsaW1pdCBmb3IgbnVtYmVyIG9mIGxvZyBsaW5lcyByZXR1cm5lZCBieSBxdWVyeS4nfT5cbiAgICAgICAgICA8SW5wdXRcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cIndpZHRoLTRcIlxuICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJhdXRvXCJcbiAgICAgICAgICAgIHR5cGU9XCJudW1iZXJcIlxuICAgICAgICAgICAgbWluPXswfVxuICAgICAgICAgICAgb25DaGFuZ2U9e29uTWF4TGluZXNDaGFuZ2V9XG4gICAgICAgICAgICBvbktleURvd249e29uUmV0dXJuS2V5RG93bn1cbiAgICAgICAgICAgIHZhbHVlPXtsaW5lTGltaXRWYWx1ZX1cbiAgICAgICAgICAgIG9uQmx1cj17KCkgPT4ge1xuICAgICAgICAgICAgICBpZiAocnVuT25CbHVyKSB7XG4gICAgICAgICAgICAgICAgb25SdW5RdWVyeSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9fVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvSW5saW5lRmllbGQ+XG4gICAgICAgIDxJbmxpbmVGaWVsZFxuICAgICAgICAgIGxhYmVsPVwiUmVzb2x1dGlvblwiXG4gICAgICAgICAgdG9vbHRpcD17XG4gICAgICAgICAgICAnUmVzb2x1dGlvbiAxLzEgc2V0cyBzdGVwIHBhcmFtZXRlciBvZiBMb2tpIG1ldHJpY3MgcmFuZ2UgcXVlcmllcyBzdWNoIHRoYXQgZWFjaCBwaXhlbCBjb3JyZXNwb25kcyB0byBvbmUgZGF0YSBwb2ludC4gRm9yIGJldHRlciBwZXJmb3JtYW5jZSwgbG93ZXIgcmVzb2x1dGlvbnMgY2FuIGJlIHBpY2tlZC4gMS8yIG9ubHkgcmV0cmlldmVzIGEgZGF0YSBwb2ludCBmb3IgZXZlcnkgb3RoZXIgcGl4ZWwsIGFuZCAxLzEwIHJldHJpZXZlcyBvbmUgZGF0YSBwb2ludCBwZXIgMTAgcGl4ZWxzLidcbiAgICAgICAgICB9XG4gICAgICAgID5cbiAgICAgICAgICA8U2VsZWN0XG4gICAgICAgICAgICBpc1NlYXJjaGFibGU9e2ZhbHNlfVxuICAgICAgICAgICAgb25DaGFuZ2U9e29uUmVzb2x1dGlvbkNoYW5nZX1cbiAgICAgICAgICAgIG9wdGlvbnM9e1JFU09MVVRJT05fT1BUSU9OU31cbiAgICAgICAgICAgIHZhbHVlPXtyZXNvbHV0aW9ufVxuICAgICAgICAgICAgYXJpYS1sYWJlbD1cIlNlbGVjdCByZXNvbHV0aW9uXCJcbiAgICAgICAgICAvPlxuICAgICAgICA8L0lubGluZUZpZWxkPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1lbW8oTG9raU9wdGlvbkZpZWxkcyk7XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmVwcm9jZXNzTWF4TGluZXModmFsdWU6IHN0cmluZyk6IG51bWJlciB7XG4gIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBlbXB0eSBpbnB1dCAtIGZhbGxzIGJhY2sgdG8gZGF0YVNvdXJjZS5tYXhMaW5lcyBsaW1pdFxuICAgIHJldHVybiBOYU47XG4gIH0gZWxzZSBpZiAodmFsdWUubGVuZ3RoID4gMCAmJiAoaXNOYU4oK3ZhbHVlKSB8fCArdmFsdWUgPCAwKSkge1xuICAgIC8vIGlucHV0IHdpdGggYXQgbGVhc3QgMSBjaGFyYWN0ZXIgYW5kIHRoYXQgaXMgZWl0aGVyIGluY29ycmVjdCAodmFsdWUgaW4gdGhlIGlucHV0IGZpZWxkIGlzIG5vdCBhIG51bWJlcikgb3IgbmVnYXRpdmVcbiAgICAvLyBmYWxscyBiYWNrIHRvIHRoZSBsaW1pdCBvZiAwIGxpbmVzXG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gZGVmYXVsdCBjYXNlIC0gY29ycmVjdCBpbnB1dFxuICAgIHJldHVybiArdmFsdWU7XG4gIH1cbn1cbiIsIi8vIExpYnJhcmllc1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLy8gVHlwZXNcbmltcG9ydCB7IElubGluZUZvcm1MYWJlbCB9IGZyb20gJ0BncmFmYW5hL3VpJztcblxuaW1wb3J0IHsgTG9raU9wdGlvbkZpZWxkcyB9IGZyb20gJy4vTG9raU9wdGlvbkZpZWxkcyc7XG5pbXBvcnQgeyBMb2tpUXVlcnlGaWVsZCB9IGZyb20gJy4vTG9raVF1ZXJ5RmllbGQnO1xuaW1wb3J0IHsgTG9raVF1ZXJ5RWRpdG9yUHJvcHMgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGZ1bmN0aW9uIExva2lRdWVyeUVkaXRvcihwcm9wczogTG9raVF1ZXJ5RWRpdG9yUHJvcHMpIHtcbiAgY29uc3QgeyBxdWVyeSwgZGF0YSwgZGF0YXNvdXJjZSwgb25DaGFuZ2UsIG9uUnVuUXVlcnksIHJhbmdlIH0gPSBwcm9wcztcblxuICBjb25zdCBvbkxlZ2VuZENoYW5nZSA9IChlOiBSZWFjdC5TeW50aGV0aWNFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IG5leHRRdWVyeSA9IHsgLi4ucXVlcnksIGxlZ2VuZEZvcm1hdDogZS5jdXJyZW50VGFyZ2V0LnZhbHVlIH07XG4gICAgb25DaGFuZ2UobmV4dFF1ZXJ5KTtcbiAgfTtcblxuICBjb25zdCBsZWdlbmRGaWVsZCA9IChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm0taW5saW5lXCI+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm1cIj5cbiAgICAgICAgPElubGluZUZvcm1MYWJlbFxuICAgICAgICAgIHdpZHRoPXs2fVxuICAgICAgICAgIHRvb2x0aXA9XCJDb250cm9scyB0aGUgbmFtZSBvZiB0aGUgdGltZSBzZXJpZXMsIHVzaW5nIG5hbWUgb3IgcGF0dGVybi4gRm9yIGV4YW1wbGVcbiAgICAgICAge3tob3N0bmFtZX19IHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBsYWJlbCB2YWx1ZSBmb3IgdGhlIGxhYmVsIGhvc3RuYW1lLiBUaGUgbGVnZW5kIG9ubHkgYXBwbGllcyB0byBtZXRyaWMgcXVlcmllcy5cIlxuICAgICAgICA+XG4gICAgICAgICAgTGVnZW5kXG4gICAgICAgIDwvSW5saW5lRm9ybUxhYmVsPlxuICAgICAgICA8aW5wdXRcbiAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgY2xhc3NOYW1lPVwiZ2YtZm9ybS1pbnB1dFwiXG4gICAgICAgICAgcGxhY2Vob2xkZXI9XCJsZWdlbmQgZm9ybWF0XCJcbiAgICAgICAgICB2YWx1ZT17cXVlcnkubGVnZW5kRm9ybWF0IHx8ICcnfVxuICAgICAgICAgIG9uQ2hhbmdlPXtvbkxlZ2VuZENoYW5nZX1cbiAgICAgICAgICBvbkJsdXI9e29uUnVuUXVlcnl9XG4gICAgICAgIC8+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcblxuICByZXR1cm4gKFxuICAgIDxMb2tpUXVlcnlGaWVsZFxuICAgICAgZGF0YXNvdXJjZT17ZGF0YXNvdXJjZX1cbiAgICAgIHF1ZXJ5PXtxdWVyeX1cbiAgICAgIG9uQ2hhbmdlPXtvbkNoYW5nZX1cbiAgICAgIG9uUnVuUXVlcnk9e29uUnVuUXVlcnl9XG4gICAgICBvbkJsdXI9e29uUnVuUXVlcnl9XG4gICAgICBoaXN0b3J5PXtbXX1cbiAgICAgIGRhdGE9e2RhdGF9XG4gICAgICBkYXRhLXRlc3RpZD17dGVzdElkcy5lZGl0b3J9XG4gICAgICByYW5nZT17cmFuZ2V9XG4gICAgICBFeHRyYUZpZWxkRWxlbWVudD17XG4gICAgICAgIDw+XG4gICAgICAgICAgPExva2lPcHRpb25GaWVsZHNcbiAgICAgICAgICAgIGxpbmVMaW1pdFZhbHVlPXtxdWVyeT8ubWF4TGluZXM/LnRvU3RyaW5nKCkgfHwgJyd9XG4gICAgICAgICAgICByZXNvbHV0aW9uPXtxdWVyeT8ucmVzb2x1dGlvbiB8fCAxfVxuICAgICAgICAgICAgcXVlcnk9e3F1ZXJ5fVxuICAgICAgICAgICAgb25SdW5RdWVyeT17b25SdW5RdWVyeX1cbiAgICAgICAgICAgIG9uQ2hhbmdlPXtvbkNoYW5nZX1cbiAgICAgICAgICAgIHJ1bk9uQmx1cj17dHJ1ZX1cbiAgICAgICAgICAvPlxuICAgICAgICAgIHtsZWdlbmRGaWVsZH1cbiAgICAgICAgPC8+XG4gICAgICB9XG4gICAgLz5cbiAgKTtcbn1cblxuZXhwb3J0IGNvbnN0IHRlc3RJZHMgPSB7XG4gIGVkaXRvcjogJ2xva2ktZWRpdG9yJyxcbn07XG4iLCJpbXBvcnQgUmVhY3QsIHsgbWVtbyB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgQ29yZUFwcCB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgY29uZmlnIH0gZnJvbSAnQGdyYWZhbmEvcnVudGltZSc7XG5cbmltcG9ydCB7IExva2lRdWVyeUVkaXRvclNlbGVjdG9yIH0gZnJvbSAnLi4vcXVlcnlidWlsZGVyL2NvbXBvbmVudHMvTG9raVF1ZXJ5RWRpdG9yU2VsZWN0b3InO1xuXG5pbXBvcnQgeyBMb2tpRXhwbG9yZVF1ZXJ5RWRpdG9yIH0gZnJvbSAnLi9Mb2tpRXhwbG9yZVF1ZXJ5RWRpdG9yJztcbmltcG9ydCB7IExva2lRdWVyeUVkaXRvciB9IGZyb20gJy4vTG9raVF1ZXJ5RWRpdG9yJztcbmltcG9ydCB7IExva2lRdWVyeUVkaXRvckZvckFsZXJ0aW5nIH0gZnJvbSAnLi9Mb2tpUXVlcnlFZGl0b3JGb3JBbGVydGluZyc7XG5pbXBvcnQgeyBMb2tpUXVlcnlFZGl0b3JQcm9wcyB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gTG9raVF1ZXJ5RWRpdG9yQnlBcHAocHJvcHM6IExva2lRdWVyeUVkaXRvclByb3BzKSB7XG4gIGNvbnN0IHsgYXBwIH0gPSBwcm9wcztcblxuICBzd2l0Y2ggKGFwcCkge1xuICAgIGNhc2UgQ29yZUFwcC5DbG91ZEFsZXJ0aW5nOlxuICAgICAgcmV0dXJuIDxMb2tpUXVlcnlFZGl0b3JGb3JBbGVydGluZyB7Li4ucHJvcHN9IC8+O1xuICAgIGNhc2UgQ29yZUFwcC5FeHBsb3JlOlxuICAgICAgaWYgKGNvbmZpZy5mZWF0dXJlVG9nZ2xlcy5sb2tpUXVlcnlCdWlsZGVyKSB7XG4gICAgICAgIHJldHVybiA8TG9raVF1ZXJ5RWRpdG9yU2VsZWN0b3Igey4uLnByb3BzfSAvPjtcbiAgICAgIH1cbiAgICAgIHJldHVybiA8TG9raUV4cGxvcmVRdWVyeUVkaXRvciB7Li4ucHJvcHN9IC8+O1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoY29uZmlnLmZlYXR1cmVUb2dnbGVzLmxva2lRdWVyeUJ1aWxkZXIpIHtcbiAgICAgICAgcmV0dXJuIDxMb2tpUXVlcnlFZGl0b3JTZWxlY3RvciB7Li4ucHJvcHN9IC8+O1xuICAgICAgfVxuICAgICAgcmV0dXJuIDxMb2tpUXVlcnlFZGl0b3Igey4uLnByb3BzfSAvPjtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBtZW1vKExva2lRdWVyeUVkaXRvckJ5QXBwKTtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IExva2lRdWVyeUZpZWxkIH0gZnJvbSAnLi9Mb2tpUXVlcnlGaWVsZCc7XG5pbXBvcnQgeyBMb2tpUXVlcnlFZGl0b3JQcm9wcyB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gTG9raVF1ZXJ5RWRpdG9yRm9yQWxlcnRpbmcocHJvcHM6IExva2lRdWVyeUVkaXRvclByb3BzKSB7XG4gIGNvbnN0IHsgcXVlcnksIGRhdGEsIGRhdGFzb3VyY2UsIG9uQ2hhbmdlLCBvblJ1blF1ZXJ5IH0gPSBwcm9wcztcblxuICByZXR1cm4gKFxuICAgIDxMb2tpUXVlcnlGaWVsZFxuICAgICAgZGF0YXNvdXJjZT17ZGF0YXNvdXJjZX1cbiAgICAgIHF1ZXJ5PXtxdWVyeX1cbiAgICAgIG9uQ2hhbmdlPXtvbkNoYW5nZX1cbiAgICAgIG9uUnVuUXVlcnk9e29uUnVuUXVlcnl9XG4gICAgICBvbkJsdXI9e29uUnVuUXVlcnl9XG4gICAgICBoaXN0b3J5PXtbXX1cbiAgICAgIGRhdGE9e2RhdGF9XG4gICAgICBwbGFjZWhvbGRlcj1cIkVudGVyIGEgTG9raSBxdWVyeVwiXG4gICAgICBkYXRhLXRlc3RpZD17dGVzdElkcy5lZGl0b3J9XG4gICAgLz5cbiAgKTtcbn1cblxuZXhwb3J0IGNvbnN0IHRlc3RJZHMgPSB7XG4gIGVkaXRvcjogJ2xva2ktZWRpdG9yLWNsb3VkLWFsZXJ0aW5nJyxcbn07XG4iLCJpbXBvcnQgeyBMYW5ndWFnZU1hcCwgbGFuZ3VhZ2VzIGFzIHByaXNtTGFuZ3VhZ2VzIH0gZnJvbSAncHJpc21qcyc7XG5pbXBvcnQgUmVhY3QsIHsgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUGx1Z2luLCBOb2RlIH0gZnJvbSAnc2xhdGUnO1xuXG5pbXBvcnQgeyBRdWVyeUVkaXRvclByb3BzIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQge1xuICBTbGF0ZVByaXNtLFxuICBUeXBlYWhlYWRPdXRwdXQsXG4gIFN1Z2dlc3Rpb25zU3RhdGUsXG4gIFF1ZXJ5RmllbGQsXG4gIFR5cGVhaGVhZElucHV0LFxuICBCcmFjZXNQbHVnaW4sXG4gIERPTVV0aWwsXG4gIEljb24sXG59IGZyb20gJ0BncmFmYW5hL3VpJztcbmltcG9ydCB7IExvY2FsU3RvcmFnZVZhbHVlUHJvdmlkZXIgfSBmcm9tICdhcHAvY29yZS9jb21wb25lbnRzL0xvY2FsU3RvcmFnZVZhbHVlUHJvdmlkZXInO1xuXG5pbXBvcnQgeyBMb2tpRGF0YXNvdXJjZSB9IGZyb20gJy4uL2RhdGFzb3VyY2UnO1xuaW1wb3J0IExva2lMYW5ndWFnZVByb3ZpZGVyIGZyb20gJy4uL2xhbmd1YWdlX3Byb3ZpZGVyJztcbmltcG9ydCB7IGVzY2FwZUxhYmVsVmFsdWVJblNlbGVjdG9yLCBzaG91bGRSZWZyZXNoTGFiZWxzIH0gZnJvbSAnLi4vbGFuZ3VhZ2VfdXRpbHMnO1xuaW1wb3J0IHsgTG9raVF1ZXJ5LCBMb2tpT3B0aW9ucyB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgTG9raUxhYmVsQnJvd3NlciB9IGZyb20gJy4vTG9raUxhYmVsQnJvd3Nlcic7XG5cbmNvbnN0IExBU1RfVVNFRF9MQUJFTFNfS0VZID0gJ2dyYWZhbmEuZGF0YXNvdXJjZXMubG9raS5icm93c2VyLmxhYmVscyc7XG5cbmZ1bmN0aW9uIGdldENob29zZXJUZXh0KGhhc1N5bnRheDogYm9vbGVhbiwgaGFzTG9nTGFiZWxzOiBib29sZWFuKSB7XG4gIGlmICghaGFzU3ludGF4KSB7XG4gICAgcmV0dXJuICdMb2FkaW5nIGxhYmVscy4uLic7XG4gIH1cbiAgaWYgKCFoYXNMb2dMYWJlbHMpIHtcbiAgICByZXR1cm4gJyhObyBsb2dzIGZvdW5kKSc7XG4gIH1cbiAgcmV0dXJuICdMb2cgYnJvd3Nlcic7XG59XG5cbmZ1bmN0aW9uIHdpbGxBcHBseVN1Z2dlc3Rpb24oc3VnZ2VzdGlvbjogc3RyaW5nLCB7IHR5cGVhaGVhZENvbnRleHQsIHR5cGVhaGVhZFRleHQgfTogU3VnZ2VzdGlvbnNTdGF0ZSk6IHN0cmluZyB7XG4gIC8vIE1vZGlmeSBzdWdnZXN0aW9uIGJhc2VkIG9uIGNvbnRleHRcbiAgc3dpdGNoICh0eXBlYWhlYWRDb250ZXh0KSB7XG4gICAgY2FzZSAnY29udGV4dC1sYWJlbHMnOiB7XG4gICAgICBjb25zdCBuZXh0Q2hhciA9IERPTVV0aWwuZ2V0TmV4dENoYXJhY3RlcigpO1xuICAgICAgaWYgKCFuZXh0Q2hhciB8fCBuZXh0Q2hhciA9PT0gJ30nIHx8IG5leHRDaGFyID09PSAnLCcpIHtcbiAgICAgICAgc3VnZ2VzdGlvbiArPSAnPSc7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICdjb250ZXh0LWxhYmVsLXZhbHVlcyc6IHtcbiAgICAgIC8vIEFsd2F5cyBhZGQgcXVvdGVzIGFuZCByZW1vdmUgZXhpc3Rpbmcgb25lcyBpbnN0ZWFkXG4gICAgICBsZXQgc3VnZ2VzdGlvbk1vZGlmaWVkID0gJyc7XG5cbiAgICAgIGlmICghdHlwZWFoZWFkVGV4dC5tYXRjaCgvXighPz1+P1wifFwiKS8pKSB7XG4gICAgICAgIHN1Z2dlc3Rpb25Nb2RpZmllZCA9ICdcIic7XG4gICAgICB9XG5cbiAgICAgIHN1Z2dlc3Rpb25Nb2RpZmllZCArPSBlc2NhcGVMYWJlbFZhbHVlSW5TZWxlY3RvcihzdWdnZXN0aW9uLCB0eXBlYWhlYWRUZXh0KTtcblxuICAgICAgaWYgKERPTVV0aWwuZ2V0TmV4dENoYXJhY3RlcigpICE9PSAnXCInKSB7XG4gICAgICAgIHN1Z2dlc3Rpb25Nb2RpZmllZCArPSAnXCInO1xuICAgICAgfVxuXG4gICAgICBzdWdnZXN0aW9uID0gc3VnZ2VzdGlvbk1vZGlmaWVkO1xuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBkZWZhdWx0OlxuICB9XG5cbiAgcmV0dXJuIHN1Z2dlc3Rpb247XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9raVF1ZXJ5RmllbGRQcm9wcyBleHRlbmRzIFF1ZXJ5RWRpdG9yUHJvcHM8TG9raURhdGFzb3VyY2UsIExva2lRdWVyeSwgTG9raU9wdGlvbnM+IHtcbiAgRXh0cmFGaWVsZEVsZW1lbnQ/OiBSZWFjdE5vZGU7XG4gIHBsYWNlaG9sZGVyPzogc3RyaW5nO1xuICAnZGF0YS10ZXN0aWQnPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgTG9raVF1ZXJ5RmllbGRTdGF0ZSB7XG4gIGxhYmVsc0xvYWRlZDogYm9vbGVhbjtcbiAgbGFiZWxCcm93c2VyVmlzaWJsZTogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNsYXNzIExva2lRdWVyeUZpZWxkIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudDxMb2tpUXVlcnlGaWVsZFByb3BzLCBMb2tpUXVlcnlGaWVsZFN0YXRlPiB7XG4gIHBsdWdpbnM6IFBsdWdpbltdO1xuICBfaXNNb3VudGVkID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IocHJvcHM6IExva2lRdWVyeUZpZWxkUHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG5cbiAgICB0aGlzLnN0YXRlID0geyBsYWJlbHNMb2FkZWQ6IGZhbHNlLCBsYWJlbEJyb3dzZXJWaXNpYmxlOiBmYWxzZSB9O1xuXG4gICAgdGhpcy5wbHVnaW5zID0gW1xuICAgICAgQnJhY2VzUGx1Z2luKCksXG4gICAgICBTbGF0ZVByaXNtKFxuICAgICAgICB7XG4gICAgICAgICAgb25seUluOiAobm9kZTogTm9kZSkgPT4gbm9kZS5vYmplY3QgPT09ICdibG9jaycgJiYgbm9kZS50eXBlID09PSAnY29kZV9ibG9jaycsXG4gICAgICAgICAgZ2V0U3ludGF4OiAobm9kZTogTm9kZSkgPT4gJ2xvZ3FsJyxcbiAgICAgICAgfSxcbiAgICAgICAgeyAuLi4ocHJpc21MYW5ndWFnZXMgYXMgTGFuZ3VhZ2VNYXApLCBsb2dxbDogdGhpcy5wcm9wcy5kYXRhc291cmNlLmxhbmd1YWdlUHJvdmlkZXIuZ2V0U3ludGF4KCkgfVxuICAgICAgKSxcbiAgICBdO1xuICB9XG5cbiAgYXN5bmMgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICBhd2FpdCB0aGlzLnByb3BzLmRhdGFzb3VyY2UubGFuZ3VhZ2VQcm92aWRlci5zdGFydCgpO1xuICAgIGlmICh0aGlzLl9pc01vdW50ZWQpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBsYWJlbHNMb2FkZWQ6IHRydWUgfSk7XG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5faXNNb3VudGVkID0gZmFsc2U7XG4gIH1cblxuICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzOiBMb2tpUXVlcnlGaWVsZFByb3BzKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmFuZ2UsXG4gICAgICBkYXRhc291cmNlOiB7IGxhbmd1YWdlUHJvdmlkZXIgfSxcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCByZWZyZXNoTGFiZWxzID0gc2hvdWxkUmVmcmVzaExhYmVscyhyYW5nZSwgcHJldlByb3BzLnJhbmdlKTtcbiAgICAvLyBXZSB3YW50IHRvIHJlZnJlc2ggbGFiZWxzIHdoZW4gcmFuZ2UgY2hhbmdlcyAod2Ugcm91bmQgdXAgaW50ZXJ2YWxzIHRvIGEgbWludXRlKVxuICAgIGlmIChyZWZyZXNoTGFiZWxzKSB7XG4gICAgICBsYW5ndWFnZVByb3ZpZGVyLmZldGNoTGFiZWxzKCk7XG4gICAgfVxuICB9XG5cbiAgb25DaGFuZ2VMYWJlbEJyb3dzZXIgPSAoc2VsZWN0b3I6IHN0cmluZykgPT4ge1xuICAgIHRoaXMub25DaGFuZ2VRdWVyeShzZWxlY3RvciwgdHJ1ZSk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGxhYmVsQnJvd3NlclZpc2libGU6IGZhbHNlIH0pO1xuICB9O1xuXG4gIG9uQ2hhbmdlUXVlcnkgPSAodmFsdWU6IHN0cmluZywgb3ZlcnJpZGU/OiBib29sZWFuKSA9PiB7XG4gICAgLy8gU2VuZCB0ZXh0IGNoYW5nZSB0byBwYXJlbnRcbiAgICBjb25zdCB7IHF1ZXJ5LCBvbkNoYW5nZSwgb25SdW5RdWVyeSB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAob25DaGFuZ2UpIHtcbiAgICAgIGNvbnN0IG5leHRRdWVyeSA9IHsgLi4ucXVlcnksIGV4cHI6IHZhbHVlIH07XG4gICAgICBvbkNoYW5nZShuZXh0UXVlcnkpO1xuXG4gICAgICBpZiAob3ZlcnJpZGUgJiYgb25SdW5RdWVyeSkge1xuICAgICAgICBvblJ1blF1ZXJ5KCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIG9uQ2xpY2tDaG9vc2VyQnV0dG9uID0gKCkgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoKHN0YXRlKSA9PiAoeyBsYWJlbEJyb3dzZXJWaXNpYmxlOiAhc3RhdGUubGFiZWxCcm93c2VyVmlzaWJsZSB9KSk7XG4gIH07XG5cbiAgb25UeXBlYWhlYWQgPSBhc3luYyAodHlwZWFoZWFkOiBUeXBlYWhlYWRJbnB1dCk6IFByb21pc2U8VHlwZWFoZWFkT3V0cHV0PiA9PiB7XG4gICAgY29uc3QgeyBkYXRhc291cmNlIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgaWYgKCFkYXRhc291cmNlLmxhbmd1YWdlUHJvdmlkZXIpIHtcbiAgICAgIHJldHVybiB7IHN1Z2dlc3Rpb25zOiBbXSB9O1xuICAgIH1cblxuICAgIGNvbnN0IGxva2lMYW5ndWFnZVByb3ZpZGVyID0gZGF0YXNvdXJjZS5sYW5ndWFnZVByb3ZpZGVyIGFzIExva2lMYW5ndWFnZVByb3ZpZGVyO1xuICAgIGNvbnN0IHsgaGlzdG9yeSB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IHByZWZpeCwgdGV4dCwgdmFsdWUsIHdyYXBwZXJDbGFzc2VzLCBsYWJlbEtleSB9ID0gdHlwZWFoZWFkO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbG9raUxhbmd1YWdlUHJvdmlkZXIucHJvdmlkZUNvbXBsZXRpb25JdGVtcyhcbiAgICAgIHsgdGV4dCwgdmFsdWUsIHByZWZpeCwgd3JhcHBlckNsYXNzZXMsIGxhYmVsS2V5IH0sXG4gICAgICB7IGhpc3RvcnkgfVxuICAgICk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgRXh0cmFGaWVsZEVsZW1lbnQsXG4gICAgICBxdWVyeSxcbiAgICAgIGRhdGFzb3VyY2UsXG4gICAgICBwbGFjZWhvbGRlciA9ICdFbnRlciBhIExva2kgcXVlcnkgKHJ1biB3aXRoIFNoaWZ0K0VudGVyKScsXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCB7IGxhYmVsc0xvYWRlZCwgbGFiZWxCcm93c2VyVmlzaWJsZSB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBsb2tpTGFuZ3VhZ2VQcm92aWRlciA9IGRhdGFzb3VyY2UubGFuZ3VhZ2VQcm92aWRlciBhcyBMb2tpTGFuZ3VhZ2VQcm92aWRlcjtcbiAgICBjb25zdCBjbGVhblRleHQgPSBkYXRhc291cmNlLmxhbmd1YWdlUHJvdmlkZXIgPyBsb2tpTGFuZ3VhZ2VQcm92aWRlci5jbGVhblRleHQgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgaGFzTG9nTGFiZWxzID0gbG9raUxhbmd1YWdlUHJvdmlkZXIuZ2V0TGFiZWxLZXlzKCkubGVuZ3RoID4gMDtcbiAgICBjb25zdCBjaG9vc2VyVGV4dCA9IGdldENob29zZXJUZXh0KGxhYmVsc0xvYWRlZCwgaGFzTG9nTGFiZWxzKTtcbiAgICBjb25zdCBidXR0b25EaXNhYmxlZCA9ICEobGFiZWxzTG9hZGVkICYmIGhhc0xvZ0xhYmVscyk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPExvY2FsU3RvcmFnZVZhbHVlUHJvdmlkZXI8c3RyaW5nW10+IHN0b3JhZ2VLZXk9e0xBU1RfVVNFRF9MQUJFTFNfS0VZfSBkZWZhdWx0VmFsdWU9e1tdfT5cbiAgICAgICAgeyhsYXN0VXNlZExhYmVscywgb25MYXN0VXNlZExhYmVsc1NhdmUsIG9uTGFzdFVzZWRMYWJlbHNEZWxldGUpID0+IHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImdmLWZvcm0taW5saW5lIGdmLWZvcm0taW5saW5lLS14cy12aWV3LWZsZXgtY29sdW1uIGZsZXgtZ3Jvdy0xXCJcbiAgICAgICAgICAgICAgICBkYXRhLXRlc3RpZD17dGhpcy5wcm9wc1snZGF0YS10ZXN0aWQnXX1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImdmLWZvcm0tbGFiZWwgcXVlcnkta2V5d29yZCBwb2ludGVyXCJcbiAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMub25DbGlja0Nob29zZXJCdXR0b259XG4gICAgICAgICAgICAgICAgICBkaXNhYmxlZD17YnV0dG9uRGlzYWJsZWR9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAge2Nob29zZXJUZXh0fVxuICAgICAgICAgICAgICAgICAgPEljb24gbmFtZT17bGFiZWxCcm93c2VyVmlzaWJsZSA/ICdhbmdsZS1kb3duJyA6ICdhbmdsZS1yaWdodCd9IC8+XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtIGdmLWZvcm0tLWdyb3cgZmxleC1zaHJpbmstMSBtaW4td2lkdGgtMTVcIj5cbiAgICAgICAgICAgICAgICAgIDxRdWVyeUZpZWxkXG4gICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxQbHVnaW5zPXt0aGlzLnBsdWdpbnN9XG4gICAgICAgICAgICAgICAgICAgIGNsZWFuVGV4dD17Y2xlYW5UZXh0fVxuICAgICAgICAgICAgICAgICAgICBxdWVyeT17cXVlcnkuZXhwcn1cbiAgICAgICAgICAgICAgICAgICAgb25UeXBlYWhlYWQ9e3RoaXMub25UeXBlYWhlYWR9XG4gICAgICAgICAgICAgICAgICAgIG9uV2lsbEFwcGx5U3VnZ2VzdGlvbj17d2lsbEFwcGx5U3VnZ2VzdGlvbn1cbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMub25DaGFuZ2VRdWVyeX1cbiAgICAgICAgICAgICAgICAgICAgb25CbHVyPXt0aGlzLnByb3BzLm9uQmx1cn1cbiAgICAgICAgICAgICAgICAgICAgb25SdW5RdWVyeT17dGhpcy5wcm9wcy5vblJ1blF1ZXJ5fVxuICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj17cGxhY2Vob2xkZXJ9XG4gICAgICAgICAgICAgICAgICAgIHBvcnRhbE9yaWdpbj1cImxva2lcIlxuICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIHtsYWJlbEJyb3dzZXJWaXNpYmxlICYmIChcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm1cIj5cbiAgICAgICAgICAgICAgICAgIDxMb2tpTGFiZWxCcm93c2VyXG4gICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlUHJvdmlkZXI9e2xva2lMYW5ndWFnZVByb3ZpZGVyfVxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5vbkNoYW5nZUxhYmVsQnJvd3Nlcn1cbiAgICAgICAgICAgICAgICAgICAgbGFzdFVzZWRMYWJlbHM9e2xhc3RVc2VkTGFiZWxzIHx8IFtdfVxuICAgICAgICAgICAgICAgICAgICBzdG9yZUxhc3RVc2VkTGFiZWxzPXtvbkxhc3RVc2VkTGFiZWxzU2F2ZX1cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlTGFzdFVzZWRMYWJlbHM9e29uTGFzdFVzZWRMYWJlbHNEZWxldGV9XG4gICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICApfVxuXG4gICAgICAgICAgICAgIHtFeHRyYUZpZWxkRWxlbWVudH1cbiAgICAgICAgICAgIDwvPlxuICAgICAgICAgICk7XG4gICAgICAgIH19XG4gICAgICA8L0xvY2FsU3RvcmFnZVZhbHVlUHJvdmlkZXI+XG4gICAgKTtcbiAgfVxufVxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgRGF0YVNvdXJjZVBsdWdpbk9wdGlvbnNFZGl0b3JQcm9wcywgRGF0YVNvdXJjZVNldHRpbmdzIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBBbGVydGluZ1NldHRpbmdzLCBEYXRhU291cmNlSHR0cFNldHRpbmdzIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuaW1wb3J0IHsgZ2V0QWxsQWxlcnRtYW5hZ2VyRGF0YVNvdXJjZXMgfSBmcm9tICdhcHAvZmVhdHVyZXMvYWxlcnRpbmcvdW5pZmllZC91dGlscy9hbGVydG1hbmFnZXInO1xuXG5pbXBvcnQgeyBMb2tpT3B0aW9ucyB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgRGVyaXZlZEZpZWxkcyB9IGZyb20gJy4vRGVyaXZlZEZpZWxkcyc7XG5pbXBvcnQgeyBNYXhMaW5lc0ZpZWxkIH0gZnJvbSAnLi9NYXhMaW5lc0ZpZWxkJztcblxuZXhwb3J0IHR5cGUgUHJvcHMgPSBEYXRhU291cmNlUGx1Z2luT3B0aW9uc0VkaXRvclByb3BzPExva2lPcHRpb25zPjtcblxuY29uc3QgbWFrZUpzb25VcGRhdGVyID1cbiAgPFQgZXh0ZW5kcyBhbnk+KGZpZWxkOiBrZXlvZiBMb2tpT3B0aW9ucykgPT5cbiAgKG9wdGlvbnM6IERhdGFTb3VyY2VTZXR0aW5nczxMb2tpT3B0aW9ucz4sIHZhbHVlOiBUKTogRGF0YVNvdXJjZVNldHRpbmdzPExva2lPcHRpb25zPiA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBqc29uRGF0YToge1xuICAgICAgICAuLi5vcHRpb25zLmpzb25EYXRhLFxuICAgICAgICBbZmllbGRdOiB2YWx1ZSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfTtcblxuY29uc3Qgc2V0TWF4TGluZXMgPSBtYWtlSnNvblVwZGF0ZXIoJ21heExpbmVzJyk7XG5jb25zdCBzZXREZXJpdmVkRmllbGRzID0gbWFrZUpzb25VcGRhdGVyKCdkZXJpdmVkRmllbGRzJyk7XG5cbmV4cG9ydCBjb25zdCBDb25maWdFZGl0b3IgPSAocHJvcHM6IFByb3BzKSA9PiB7XG4gIGNvbnN0IHsgb3B0aW9ucywgb25PcHRpb25zQ2hhbmdlIH0gPSBwcm9wcztcbiAgY29uc3QgYWxlcnRtYW5hZ2VycyA9IGdldEFsbEFsZXJ0bWFuYWdlckRhdGFTb3VyY2VzKCk7XG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPERhdGFTb3VyY2VIdHRwU2V0dGluZ3NcbiAgICAgICAgZGVmYXVsdFVybD17J2h0dHA6Ly9sb2NhbGhvc3Q6MzEwMCd9XG4gICAgICAgIGRhdGFTb3VyY2VDb25maWc9e29wdGlvbnN9XG4gICAgICAgIHNob3dBY2Nlc3NPcHRpb25zPXtmYWxzZX1cbiAgICAgICAgb25DaGFuZ2U9e29uT3B0aW9uc0NoYW5nZX1cbiAgICAgIC8+XG5cbiAgICAgIDxBbGVydGluZ1NldHRpbmdzPExva2lPcHRpb25zPlxuICAgICAgICBhbGVydG1hbmFnZXJEYXRhU291cmNlcz17YWxlcnRtYW5hZ2Vyc31cbiAgICAgICAgb3B0aW9ucz17b3B0aW9uc31cbiAgICAgICAgb25PcHRpb25zQ2hhbmdlPXtvbk9wdGlvbnNDaGFuZ2V9XG4gICAgICAvPlxuXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm0tZ3JvdXBcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtLWlubGluZVwiPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybVwiPlxuICAgICAgICAgICAgPE1heExpbmVzRmllbGRcbiAgICAgICAgICAgICAgdmFsdWU9e29wdGlvbnMuanNvbkRhdGEubWF4TGluZXMgfHwgJyd9XG4gICAgICAgICAgICAgIG9uQ2hhbmdlPXsodmFsdWUpID0+IG9uT3B0aW9uc0NoYW5nZShzZXRNYXhMaW5lcyhvcHRpb25zLCB2YWx1ZSkpfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cblxuICAgICAgPERlcml2ZWRGaWVsZHNcbiAgICAgICAgdmFsdWU9e29wdGlvbnMuanNvbkRhdGEuZGVyaXZlZEZpZWxkc31cbiAgICAgICAgb25DaGFuZ2U9eyh2YWx1ZSkgPT4gb25PcHRpb25zQ2hhbmdlKHNldERlcml2ZWRGaWVsZHMob3B0aW9ucywgdmFsdWUpKX1cbiAgICAgIC8+XG4gICAgPC8+XG4gICk7XG59O1xuIiwiaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCBjeCBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgQXJyYXlWZWN0b3IsIEZpZWxkLCBGaWVsZFR5cGUsIExpbmtNb2RlbCB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgTGVnYWN5Rm9ybXMgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5cbmltcG9ydCB7IGdldEZpZWxkTGlua3NGb3JFeHBsb3JlIH0gZnJvbSAnLi4vLi4vLi4vLi4vZmVhdHVyZXMvZXhwbG9yZS91dGlscy9saW5rcyc7XG5pbXBvcnQgeyBEZXJpdmVkRmllbGRDb25maWcgfSBmcm9tICcuLi90eXBlcyc7XG5cbmNvbnN0IHsgRm9ybUZpZWxkIH0gPSBMZWdhY3lGb3JtcztcblxudHlwZSBQcm9wcyA9IHtcbiAgZGVyaXZlZEZpZWxkcz86IERlcml2ZWRGaWVsZENvbmZpZ1tdO1xuICBjbGFzc05hbWU/OiBzdHJpbmc7XG59O1xuZXhwb3J0IGNvbnN0IERlYnVnU2VjdGlvbiA9IChwcm9wczogUHJvcHMpID0+IHtcbiAgY29uc3QgeyBkZXJpdmVkRmllbGRzLCBjbGFzc05hbWUgfSA9IHByb3BzO1xuICBjb25zdCBbZGVidWdUZXh0LCBzZXREZWJ1Z1RleHRdID0gdXNlU3RhdGUoJycpO1xuXG4gIGxldCBkZWJ1Z0ZpZWxkczogRGVidWdGaWVsZFtdID0gW107XG4gIGlmIChkZWJ1Z1RleHQgJiYgZGVyaXZlZEZpZWxkcykge1xuICAgIGRlYnVnRmllbGRzID0gbWFrZURlYnVnRmllbGRzKGRlcml2ZWRGaWVsZHMsIGRlYnVnVGV4dCk7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWV9PlxuICAgICAgPEZvcm1GaWVsZFxuICAgICAgICBsYWJlbFdpZHRoPXsxMn1cbiAgICAgICAgbGFiZWw9eydEZWJ1ZyBsb2cgbWVzc2FnZSd9XG4gICAgICAgIGlucHV0RWw9e1xuICAgICAgICAgIDx0ZXh0YXJlYVxuICAgICAgICAgICAgcGxhY2Vob2xkZXI9eydQYXN0ZSBhbiBleGFtcGxlIGxvZyBsaW5lIGhlcmUgdG8gdGVzdCB0aGUgcmVndWxhciBleHByZXNzaW9ucyBvZiB5b3VyIGRlcml2ZWQgZmllbGRzJ31cbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y3goXG4gICAgICAgICAgICAgICdnZi1mb3JtLWlucHV0IGdmLWZvcm0tdGV4dGFyZWEnLFxuICAgICAgICAgICAgICBjc3NgXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgICAgICAgIGBcbiAgICAgICAgICAgICl9XG4gICAgICAgICAgICB2YWx1ZT17ZGVidWdUZXh0fVxuICAgICAgICAgICAgb25DaGFuZ2U9eyhldmVudCkgPT4gc2V0RGVidWdUZXh0KGV2ZW50LmN1cnJlbnRUYXJnZXQudmFsdWUpfVxuICAgICAgICAgIC8+XG4gICAgICAgIH1cbiAgICAgIC8+XG4gICAgICB7ISFkZWJ1Z0ZpZWxkcy5sZW5ndGggJiYgPERlYnVnRmllbGRzIGZpZWxkcz17ZGVidWdGaWVsZHN9IC8+fVxuICAgIDwvZGl2PlxuICApO1xufTtcblxudHlwZSBEZWJ1Z0ZpZWxkSXRlbVByb3BzID0ge1xuICBmaWVsZHM6IERlYnVnRmllbGRbXTtcbn07XG5jb25zdCBEZWJ1Z0ZpZWxkcyA9ICh7IGZpZWxkcyB9OiBEZWJ1Z0ZpZWxkSXRlbVByb3BzKSA9PiB7XG4gIHJldHVybiAoXG4gICAgPHRhYmxlIGNsYXNzTmFtZT17J2ZpbHRlci10YWJsZSd9PlxuICAgICAgPHRoZWFkPlxuICAgICAgICA8dHI+XG4gICAgICAgICAgPHRoPk5hbWU8L3RoPlxuICAgICAgICAgIDx0aD5WYWx1ZTwvdGg+XG4gICAgICAgICAgPHRoPlVybDwvdGg+XG4gICAgICAgIDwvdHI+XG4gICAgICA8L3RoZWFkPlxuICAgICAgPHRib2R5PlxuICAgICAgICB7ZmllbGRzLm1hcCgoZmllbGQpID0+IHtcbiAgICAgICAgICBsZXQgdmFsdWU6IGFueSA9IGZpZWxkLnZhbHVlO1xuICAgICAgICAgIGlmIChmaWVsZC5lcnJvcikge1xuICAgICAgICAgICAgdmFsdWUgPSBmaWVsZC5lcnJvci5tZXNzYWdlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZmllbGQuaHJlZikge1xuICAgICAgICAgICAgdmFsdWUgPSA8YSBocmVmPXtmaWVsZC5ocmVmfT57dmFsdWV9PC9hPjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDx0ciBrZXk9e2Ake2ZpZWxkLm5hbWV9PSR7ZmllbGQudmFsdWV9YH0+XG4gICAgICAgICAgICAgIDx0ZD57ZmllbGQubmFtZX08L3RkPlxuICAgICAgICAgICAgICA8dGQ+e3ZhbHVlfTwvdGQ+XG4gICAgICAgICAgICAgIDx0ZD57ZmllbGQuaHJlZiA/IDxhIGhyZWY9e2ZpZWxkLmhyZWZ9PntmaWVsZC5ocmVmfTwvYT4gOiAnJ308L3RkPlxuICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICApO1xuICAgICAgICB9KX1cbiAgICAgIDwvdGJvZHk+XG4gICAgPC90YWJsZT5cbiAgKTtcbn07XG5cbnR5cGUgRGVidWdGaWVsZCA9IHtcbiAgbmFtZTogc3RyaW5nO1xuICBlcnJvcj86IGFueTtcbiAgdmFsdWU/OiBzdHJpbmc7XG4gIGhyZWY/OiBzdHJpbmc7XG59O1xuXG5mdW5jdGlvbiBtYWtlRGVidWdGaWVsZHMoZGVyaXZlZEZpZWxkczogRGVyaXZlZEZpZWxkQ29uZmlnW10sIGRlYnVnVGV4dDogc3RyaW5nKTogRGVidWdGaWVsZFtdIHtcbiAgcmV0dXJuIGRlcml2ZWRGaWVsZHNcbiAgICAuZmlsdGVyKChmaWVsZCkgPT4gZmllbGQubmFtZSAmJiBmaWVsZC5tYXRjaGVyUmVnZXgpXG4gICAgLm1hcCgoZmllbGQpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHRlc3RNYXRjaCA9IGRlYnVnVGV4dC5tYXRjaChmaWVsZC5tYXRjaGVyUmVnZXgpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRlc3RNYXRjaCAmJiB0ZXN0TWF0Y2hbMV07XG4gICAgICAgIGxldCBsaW5rOiBMaW5rTW9kZWw8RmllbGQ+IHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgaWYgKGZpZWxkLnVybCAmJiB2YWx1ZSkge1xuICAgICAgICAgIGxpbmsgPSBnZXRGaWVsZExpbmtzRm9yRXhwbG9yZSh7XG4gICAgICAgICAgICBmaWVsZDoge1xuICAgICAgICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgICAgICAgdHlwZTogRmllbGRUeXBlLnN0cmluZyxcbiAgICAgICAgICAgICAgdmFsdWVzOiBuZXcgQXJyYXlWZWN0b3IoW3ZhbHVlXSksXG4gICAgICAgICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgICAgICAgIGxpbmtzOiBbeyB0aXRsZTogJycsIHVybDogZmllbGQudXJsIH1dLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJvd0luZGV4OiAwLFxuICAgICAgICAgICAgcmFuZ2U6IHt9IGFzIGFueSxcbiAgICAgICAgICB9KVswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogZmllbGQubmFtZSxcbiAgICAgICAgICB2YWx1ZTogdmFsdWUgfHwgJzxubyBtYXRjaD4nLFxuICAgICAgICAgIGhyZWY6IGxpbmsgJiYgbGluay5ocmVmLFxuICAgICAgICB9IGFzIERlYnVnRmllbGQ7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IGZpZWxkLm5hbWUsXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgIH0gYXMgRGVidWdGaWVsZDtcbiAgICAgIH1cbiAgICB9KTtcbn1cbiIsImltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVByZXZpb3VzIH0gZnJvbSAncmVhY3QtdXNlJztcblxuaW1wb3J0IHsgVmFyaWFibGVTdWdnZXN0aW9uIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBEYXRhU291cmNlUGlja2VyIH0gZnJvbSAnQGdyYWZhbmEvcnVudGltZSc7XG5pbXBvcnQgeyBCdXR0b24sIERhdGFMaW5rSW5wdXQsIHN0eWxlc0ZhY3RvcnksIExlZ2FjeUZvcm1zIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5pbXBvcnQgeyBEZXJpdmVkRmllbGRDb25maWcgfSBmcm9tICcuLi90eXBlcyc7XG5cbmNvbnN0IHsgU3dpdGNoLCBGb3JtRmllbGQgfSA9IExlZ2FjeUZvcm1zO1xuXG5jb25zdCBnZXRTdHlsZXMgPSBzdHlsZXNGYWN0b3J5KCgpID0+ICh7XG4gIHJvdzogY3NzYFxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGJhc2VsaW5lO1xuICBgLFxuICBuYW1lRmllbGQ6IGNzc2BcbiAgICBmbGV4OiAyO1xuICBgLFxuICByZWdleEZpZWxkOiBjc3NgXG4gICAgZmxleDogMztcbiAgYCxcbiAgdXJsRmllbGQ6IGNzc2BcbiAgICBmbGV4OiAxO1xuICBgLFxuICB1cmxEaXNwbGF5TGFiZWxGaWVsZDogY3NzYFxuICAgIGZsZXg6IDE7XG4gIGAsXG59KSk7XG5cbnR5cGUgUHJvcHMgPSB7XG4gIHZhbHVlOiBEZXJpdmVkRmllbGRDb25maWc7XG4gIG9uQ2hhbmdlOiAodmFsdWU6IERlcml2ZWRGaWVsZENvbmZpZykgPT4gdm9pZDtcbiAgb25EZWxldGU6ICgpID0+IHZvaWQ7XG4gIHN1Z2dlc3Rpb25zOiBWYXJpYWJsZVN1Z2dlc3Rpb25bXTtcbiAgY2xhc3NOYW1lPzogc3RyaW5nO1xufTtcbmV4cG9ydCBjb25zdCBEZXJpdmVkRmllbGQgPSAocHJvcHM6IFByb3BzKSA9PiB7XG4gIGNvbnN0IHsgdmFsdWUsIG9uQ2hhbmdlLCBvbkRlbGV0ZSwgc3VnZ2VzdGlvbnMsIGNsYXNzTmFtZSB9ID0gcHJvcHM7XG4gIGNvbnN0IHN0eWxlcyA9IGdldFN0eWxlcygpO1xuICBjb25zdCBbc2hvd0ludGVybmFsTGluaywgc2V0U2hvd0ludGVybmFsTGlua10gPSB1c2VTdGF0ZSghIXZhbHVlLmRhdGFzb3VyY2VVaWQpO1xuICBjb25zdCBwcmV2aW91c1VpZCA9IHVzZVByZXZpb3VzKHZhbHVlLmRhdGFzb3VyY2VVaWQpO1xuXG4gIC8vIEZvcmNlIGludGVybmFsIGxpbmsgdmlzaWJpbGl0eSBjaGFuZ2UgaWYgdWlkIGNoYW5nZWQgb3V0c2lkZSBvZiB0aGlzIGNvbXBvbmVudC5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXByZXZpb3VzVWlkICYmIHZhbHVlLmRhdGFzb3VyY2VVaWQgJiYgIXNob3dJbnRlcm5hbExpbmspIHtcbiAgICAgIHNldFNob3dJbnRlcm5hbExpbmsodHJ1ZSk7XG4gICAgfVxuICAgIGlmIChwcmV2aW91c1VpZCAmJiAhdmFsdWUuZGF0YXNvdXJjZVVpZCAmJiBzaG93SW50ZXJuYWxMaW5rKSB7XG4gICAgICBzZXRTaG93SW50ZXJuYWxMaW5rKGZhbHNlKTtcbiAgICB9XG4gIH0sIFtwcmV2aW91c1VpZCwgdmFsdWUuZGF0YXNvdXJjZVVpZCwgc2hvd0ludGVybmFsTGlua10pO1xuXG4gIGNvbnN0IGhhbmRsZUNoYW5nZSA9IChmaWVsZDoga2V5b2YgdHlwZW9mIHZhbHVlKSA9PiAoZXZlbnQ6IFJlYWN0LkNoYW5nZUV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgb25DaGFuZ2Uoe1xuICAgICAgLi4udmFsdWUsXG4gICAgICBbZmllbGRdOiBldmVudC5jdXJyZW50VGFyZ2V0LnZhbHVlLFxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZX0+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnJvd30+XG4gICAgICAgIDxGb3JtRmllbGRcbiAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5uYW1lRmllbGR9XG4gICAgICAgICAgbGFiZWxXaWR0aD17NX1cbiAgICAgICAgICAvLyBBIGJpdCBvZiBhIGhhY2sgdG8gcHJldmVudCB1c2luZyBkZWZhdWx0IHZhbHVlIGZvciB0aGUgd2lkdGggZnJvbSBGb3JtRmllbGRcbiAgICAgICAgICBpbnB1dFdpZHRoPXtudWxsfVxuICAgICAgICAgIGxhYmVsPVwiTmFtZVwiXG4gICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgIHZhbHVlPXt2YWx1ZS5uYW1lfVxuICAgICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2UoJ25hbWUnKX1cbiAgICAgICAgLz5cbiAgICAgICAgPEZvcm1GaWVsZFxuICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLnJlZ2V4RmllbGR9XG4gICAgICAgICAgaW5wdXRXaWR0aD17bnVsbH1cbiAgICAgICAgICBsYWJlbD1cIlJlZ2V4XCJcbiAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgdmFsdWU9e3ZhbHVlLm1hdGNoZXJSZWdleH1cbiAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlKCdtYXRjaGVyUmVnZXgnKX1cbiAgICAgICAgICB0b29sdGlwPXtcbiAgICAgICAgICAgICdVc2UgdG8gcGFyc2UgYW5kIGNhcHR1cmUgc29tZSBwYXJ0IG9mIHRoZSBsb2cgbWVzc2FnZS4gWW91IGNhbiB1c2UgdGhlIGNhcHR1cmVkIGdyb3VwcyBpbiB0aGUgdGVtcGxhdGUuJ1xuICAgICAgICAgIH1cbiAgICAgICAgLz5cbiAgICAgICAgPEJ1dHRvblxuICAgICAgICAgIHZhcmlhbnQ9XCJkZXN0cnVjdGl2ZVwiXG4gICAgICAgICAgdGl0bGU9XCJSZW1vdmUgZmllbGRcIlxuICAgICAgICAgIGljb249XCJ0aW1lc1wiXG4gICAgICAgICAgb25DbGljaz17KGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgb25EZWxldGUoKTtcbiAgICAgICAgICB9fVxuICAgICAgICAgIGNsYXNzTmFtZT17Y3NzYFxuICAgICAgICAgICAgbWFyZ2luLWxlZnQ6IDhweDtcbiAgICAgICAgICBgfVxuICAgICAgICAvPlxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMucm93fT5cbiAgICAgICAgPEZvcm1GaWVsZFxuICAgICAgICAgIGxhYmVsPXtzaG93SW50ZXJuYWxMaW5rID8gJ1F1ZXJ5JyA6ICdVUkwnfVxuICAgICAgICAgIGlucHV0RWw9e1xuICAgICAgICAgICAgPERhdGFMaW5rSW5wdXRcbiAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9e3Nob3dJbnRlcm5hbExpbmsgPyAnJHtfX3ZhbHVlLnJhd30nIDogJ2h0dHA6Ly9leGFtcGxlLmNvbS8ke19fdmFsdWUucmF3fSd9XG4gICAgICAgICAgICAgIHZhbHVlPXt2YWx1ZS51cmwgfHwgJyd9XG4gICAgICAgICAgICAgIG9uQ2hhbmdlPXsobmV3VmFsdWUpID0+XG4gICAgICAgICAgICAgICAgb25DaGFuZ2Uoe1xuICAgICAgICAgICAgICAgICAgLi4udmFsdWUsXG4gICAgICAgICAgICAgICAgICB1cmw6IG5ld1ZhbHVlLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3VnZ2VzdGlvbnM9e3N1Z2dlc3Rpb25zfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICB9XG4gICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMudXJsRmllbGR9XG4gICAgICAgIC8+XG4gICAgICAgIDxGb3JtRmllbGRcbiAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy51cmxEaXNwbGF5TGFiZWxGaWVsZH1cbiAgICAgICAgICBpbnB1dFdpZHRoPXtudWxsfVxuICAgICAgICAgIGxhYmVsPVwiVVJMIExhYmVsXCJcbiAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgdmFsdWU9e3ZhbHVlLnVybERpc3BsYXlMYWJlbH1cbiAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlKCd1cmxEaXNwbGF5TGFiZWwnKX1cbiAgICAgICAgICB0b29sdGlwPXsnVXNlIHRvIG92ZXJyaWRlIHRoZSBidXR0b24gbGFiZWwgd2hlbiB0aGlzIGRlcml2ZWQgZmllbGQgaXMgZm91bmQgaW4gYSBsb2cuJ31cbiAgICAgICAgLz5cbiAgICAgIDwvZGl2PlxuXG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnJvd30+XG4gICAgICAgIDxTd2l0Y2hcbiAgICAgICAgICBsYWJlbD1cIkludGVybmFsIGxpbmtcIlxuICAgICAgICAgIGNoZWNrZWQ9e3Nob3dJbnRlcm5hbExpbmt9XG4gICAgICAgICAgb25DaGFuZ2U9eygpID0+IHtcbiAgICAgICAgICAgIGlmIChzaG93SW50ZXJuYWxMaW5rKSB7XG4gICAgICAgICAgICAgIG9uQ2hhbmdlKHtcbiAgICAgICAgICAgICAgICAuLi52YWx1ZSxcbiAgICAgICAgICAgICAgICBkYXRhc291cmNlVWlkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0U2hvd0ludGVybmFsTGluayghc2hvd0ludGVybmFsTGluayk7XG4gICAgICAgICAgfX1cbiAgICAgICAgLz5cblxuICAgICAgICB7c2hvd0ludGVybmFsTGluayAmJiAoXG4gICAgICAgICAgPERhdGFTb3VyY2VQaWNrZXJcbiAgICAgICAgICAgIHRyYWNpbmc9e3RydWV9XG4gICAgICAgICAgICBvbkNoYW5nZT17KGRzKSA9PlxuICAgICAgICAgICAgICBvbkNoYW5nZSh7XG4gICAgICAgICAgICAgICAgLi4udmFsdWUsXG4gICAgICAgICAgICAgICAgZGF0YXNvdXJjZVVpZDogZHMudWlkLFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudD17dmFsdWUuZGF0YXNvdXJjZVVpZH1cbiAgICAgICAgICAvPlxuICAgICAgICApfVxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuIiwiaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgR3JhZmFuYVRoZW1lMiwgVmFyaWFibGVPcmlnaW4sIERhdGFMaW5rQnVpbHRJblZhcnMgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IEJ1dHRvbiwgdXNlVGhlbWUyIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5pbXBvcnQgeyBEZXJpdmVkRmllbGRDb25maWcgfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IERlYnVnU2VjdGlvbiB9IGZyb20gJy4vRGVidWdTZWN0aW9uJztcbmltcG9ydCB7IERlcml2ZWRGaWVsZCB9IGZyb20gJy4vRGVyaXZlZEZpZWxkJztcblxuY29uc3QgZ2V0U3R5bGVzID0gKHRoZW1lOiBHcmFmYW5hVGhlbWUyKSA9PiAoe1xuICBpbmZvVGV4dDogY3NzYFxuICAgIHBhZGRpbmctYm90dG9tOiAke3RoZW1lLnNwYWNpbmcoMil9O1xuICAgIGNvbG9yOiAke3RoZW1lLmNvbG9ycy50ZXh0LnNlY29uZGFyeX07XG4gIGAsXG4gIGRlcml2ZWRGaWVsZDogY3NzYFxuICAgIG1hcmdpbi1ib3R0b206ICR7dGhlbWUuc3BhY2luZygxKX07XG4gIGAsXG59KTtcblxudHlwZSBQcm9wcyA9IHtcbiAgdmFsdWU/OiBEZXJpdmVkRmllbGRDb25maWdbXTtcbiAgb25DaGFuZ2U6ICh2YWx1ZTogRGVyaXZlZEZpZWxkQ29uZmlnW10pID0+IHZvaWQ7XG59O1xuXG5leHBvcnQgY29uc3QgRGVyaXZlZEZpZWxkcyA9IChwcm9wczogUHJvcHMpID0+IHtcbiAgY29uc3QgeyB2YWx1ZSwgb25DaGFuZ2UgfSA9IHByb3BzO1xuICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lMigpO1xuICBjb25zdCBzdHlsZXMgPSBnZXRTdHlsZXModGhlbWUpO1xuXG4gIGNvbnN0IFtzaG93RGVidWcsIHNldFNob3dEZWJ1Z10gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPGgzIGNsYXNzTmFtZT1cInBhZ2UtaGVhZGluZ1wiPkRlcml2ZWQgZmllbGRzPC9oMz5cblxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5pbmZvVGV4dH0+XG4gICAgICAgIERlcml2ZWQgZmllbGRzIGNhbiBiZSB1c2VkIHRvIGV4dHJhY3QgbmV3IGZpZWxkcyBmcm9tIGEgbG9nIG1lc3NhZ2UgYW5kIGNyZWF0ZSBhIGxpbmsgZnJvbSBpdHMgdmFsdWUuXG4gICAgICA8L2Rpdj5cblxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtLWdyb3VwXCI+XG4gICAgICAgIHt2YWx1ZSAmJlxuICAgICAgICAgIHZhbHVlLm1hcCgoZmllbGQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICA8RGVyaXZlZEZpZWxkXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMuZGVyaXZlZEZpZWxkfVxuICAgICAgICAgICAgICAgIGtleT17aW5kZXh9XG4gICAgICAgICAgICAgICAgdmFsdWU9e2ZpZWxkfVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsobmV3RmllbGQpID0+IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0Rlcml2ZWRGaWVsZHMgPSBbLi4udmFsdWVdO1xuICAgICAgICAgICAgICAgICAgbmV3RGVyaXZlZEZpZWxkcy5zcGxpY2UoaW5kZXgsIDEsIG5ld0ZpZWxkKTtcbiAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlKG5ld0Rlcml2ZWRGaWVsZHMpO1xuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgb25EZWxldGU9eygpID0+IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0Rlcml2ZWRGaWVsZHMgPSBbLi4udmFsdWVdO1xuICAgICAgICAgICAgICAgICAgbmV3RGVyaXZlZEZpZWxkcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgb25DaGFuZ2UobmV3RGVyaXZlZEZpZWxkcyk7XG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICBzdWdnZXN0aW9ucz17W1xuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogRGF0YUxpbmtCdWlsdEluVmFycy52YWx1ZVJhdyxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdSYXcgdmFsdWUnLFxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudGF0aW9uOiAnRXhhY3Qgc3RyaW5nIGNhcHR1cmVkIGJ5IHRoZSByZWd1bGFyIGV4cHJlc3Npb24nLFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW46IFZhcmlhYmxlT3JpZ2luLlZhbHVlLFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdfVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KX1cbiAgICAgICAgPGRpdj5cbiAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICB2YXJpYW50PVwic2Vjb25kYXJ5XCJcbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzYFxuICAgICAgICAgICAgICBtYXJnaW4tcmlnaHQ6IDEwcHg7XG4gICAgICAgICAgICBgfVxuICAgICAgICAgICAgaWNvbj1cInBsdXNcIlxuICAgICAgICAgICAgb25DbGljaz17KGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIGNvbnN0IG5ld0Rlcml2ZWRGaWVsZHMgPSBbLi4uKHZhbHVlIHx8IFtdKSwgeyBuYW1lOiAnJywgbWF0Y2hlclJlZ2V4OiAnJyB9XTtcbiAgICAgICAgICAgICAgb25DaGFuZ2UobmV3RGVyaXZlZEZpZWxkcyk7XG4gICAgICAgICAgICB9fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIEFkZFxuICAgICAgICAgIDwvQnV0dG9uPlxuXG4gICAgICAgICAge3ZhbHVlICYmIHZhbHVlLmxlbmd0aCA+IDAgJiYgKFxuICAgICAgICAgICAgPEJ1dHRvbiB2YXJpYW50PVwic2Vjb25kYXJ5XCIgdHlwZT1cImJ1dHRvblwiIG9uQ2xpY2s9eygpID0+IHNldFNob3dEZWJ1Zyghc2hvd0RlYnVnKX0+XG4gICAgICAgICAgICAgIHtzaG93RGVidWcgPyAnSGlkZSBleGFtcGxlIGxvZyBtZXNzYWdlJyA6ICdTaG93IGV4YW1wbGUgbG9nIG1lc3NhZ2UnfVxuICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgKX1cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cblxuICAgICAge3Nob3dEZWJ1ZyAmJiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybS1ncm91cFwiPlxuICAgICAgICAgIDxEZWJ1Z1NlY3Rpb25cbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzYFxuICAgICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAxMHB4O1xuICAgICAgICAgICAgYH1cbiAgICAgICAgICAgIGRlcml2ZWRGaWVsZHM9e3ZhbHVlfVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKX1cbiAgICA8Lz5cbiAgKTtcbn07XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBMZWdhY3lGb3JtcyB9IGZyb20gJ0BncmFmYW5hL3VpJztcbmNvbnN0IHsgRm9ybUZpZWxkIH0gPSBMZWdhY3lGb3JtcztcblxudHlwZSBQcm9wcyA9IHtcbiAgdmFsdWU6IHN0cmluZztcbiAgb25DaGFuZ2U6ICh2YWx1ZTogc3RyaW5nKSA9PiB2b2lkO1xufTtcblxuZXhwb3J0IGNvbnN0IE1heExpbmVzRmllbGQgPSAocHJvcHM6IFByb3BzKSA9PiB7XG4gIGNvbnN0IHsgdmFsdWUsIG9uQ2hhbmdlIH0gPSBwcm9wcztcbiAgcmV0dXJuIChcbiAgICA8Rm9ybUZpZWxkXG4gICAgICBsYWJlbD1cIk1heGltdW0gbGluZXNcIlxuICAgICAgbGFiZWxXaWR0aD17MTF9XG4gICAgICBpbnB1dFdpZHRoPXsyMH1cbiAgICAgIGlucHV0RWw9e1xuICAgICAgICA8aW5wdXRcbiAgICAgICAgICB0eXBlPVwibnVtYmVyXCJcbiAgICAgICAgICBjbGFzc05hbWU9XCJnZi1mb3JtLWlucHV0IHdpZHRoLTggZ2YtZm9ybS1pbnB1dC0taGFzLWhlbHAtaWNvblwiXG4gICAgICAgICAgdmFsdWU9e3ZhbHVlfVxuICAgICAgICAgIG9uQ2hhbmdlPXsoZXZlbnQpID0+IG9uQ2hhbmdlKGV2ZW50LmN1cnJlbnRUYXJnZXQudmFsdWUpfVxuICAgICAgICAgIHNwZWxsQ2hlY2s9e2ZhbHNlfVxuICAgICAgICAgIHBsYWNlaG9sZGVyPVwiMTAwMFwiXG4gICAgICAgIC8+XG4gICAgICB9XG4gICAgICB0b29sdGlwPXtcbiAgICAgICAgPD5cbiAgICAgICAgICBMb2tpIHF1ZXJpZXMgbXVzdCBjb250YWluIGEgbGltaXQgb2YgdGhlIG1heGltdW0gbnVtYmVyIG9mIGxpbmVzIHJldHVybmVkIChkZWZhdWx0OiAxMDAwKS4gSW5jcmVhc2UgdGhpcyBsaW1pdFxuICAgICAgICAgIHRvIGhhdmUgYSBiaWdnZXIgcmVzdWx0IHNldCBmb3IgYWQtaG9jIGFuYWx5c2lzLiBEZWNyZWFzZSB0aGlzIGxpbWl0IGlmIHlvdXIgYnJvd3NlciBiZWNvbWVzIHNsdWdnaXNoIHdoZW5cbiAgICAgICAgICBkaXNwbGF5aW5nIHRoZSBsb2cgcmVzdWx0cy5cbiAgICAgICAgPC8+XG4gICAgICB9XG4gICAgLz5cbiAgKTtcbn07XG4iLCIvLyBMaWJyYXJpZXNcbmltcG9ydCB7IGNsb25lRGVlcCwgaXNFbXB0eSwgbWFwIGFzIGxvZGFzaE1hcCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgUHJpc20gZnJvbSAncHJpc21qcyc7XG5pbXBvcnQgeyBsYXN0VmFsdWVGcm9tLCBtZXJnZSwgT2JzZXJ2YWJsZSwgb2YsIHRocm93RXJyb3IgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGNhdGNoRXJyb3IsIG1hcCwgc3dpdGNoTWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG4vLyBUeXBlc1xuaW1wb3J0IHtcbiAgQW5ub3RhdGlvbkV2ZW50LFxuICBBbm5vdGF0aW9uUXVlcnlSZXF1ZXN0LFxuICBDb3JlQXBwLFxuICBEYXRhRnJhbWUsXG4gIERhdGFGcmFtZVZpZXcsXG4gIERhdGFRdWVyeUVycm9yLFxuICBEYXRhUXVlcnlSZXF1ZXN0LFxuICBEYXRhUXVlcnlSZXNwb25zZSxcbiAgRGF0YVNvdXJjZUluc3RhbmNlU2V0dGluZ3MsXG4gIERhdGFTb3VyY2VXaXRoTG9nc0NvbnRleHRTdXBwb3J0LFxuICBEYXRhU291cmNlV2l0aExvZ3NWb2x1bWVTdXBwb3J0LFxuICBEYXRhU291cmNlV2l0aFF1ZXJ5RXhwb3J0U3VwcG9ydCxcbiAgRGF0YVNvdXJjZVdpdGhRdWVyeUltcG9ydFN1cHBvcnQsXG4gIGRhdGVNYXRoLFxuICBEYXRlVGltZSxcbiAgRmllbGRDYWNoZSxcbiAgQWJzdHJhY3RRdWVyeSxcbiAgRmllbGRUeXBlLFxuICBnZXRMb2dMZXZlbEZyb21LZXksXG4gIExhYmVscyxcbiAgTG9hZGluZ1N0YXRlLFxuICBMb2dMZXZlbCxcbiAgTG9nUm93TW9kZWwsXG4gIFF1ZXJ5UmVzdWx0TWV0YSxcbiAgU2NvcGVkVmFycyxcbiAgVGltZVJhbmdlLFxuICByYW5nZVV0aWwsXG4gIHRvVXRjLFxufSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IEJhY2tlbmRTcnZSZXF1ZXN0LCBGZXRjaEVycm9yLCBnZXRCYWNrZW5kU3J2LCBjb25maWcsIERhdGFTb3VyY2VXaXRoQmFja2VuZCB9IGZyb20gJ0BncmFmYW5hL3J1bnRpbWUnO1xuaW1wb3J0IHsgUm93Q29udGV4dE9wdGlvbnMgfSBmcm9tICdAZ3JhZmFuYS91aS9zcmMvY29tcG9uZW50cy9Mb2dzL0xvZ1Jvd0NvbnRleHRQcm92aWRlcic7XG5pbXBvcnQgeyBxdWVyeUxvZ3NWb2x1bWUgfSBmcm9tICdhcHAvY29yZS9sb2dzX21vZGVsJztcbmltcG9ydCB7IGNvbnZlcnRUb1dlYlNvY2tldFVybCB9IGZyb20gJ2FwcC9jb3JlL3V0aWxzL2V4cGxvcmUnO1xuaW1wb3J0IHsgZ2V0VGltZVNydiwgVGltZVNydiB9IGZyb20gJ2FwcC9mZWF0dXJlcy9kYXNoYm9hcmQvc2VydmljZXMvVGltZVNydic7XG5pbXBvcnQgeyBnZXRUZW1wbGF0ZVNydiwgVGVtcGxhdGVTcnYgfSBmcm9tICdhcHAvZmVhdHVyZXMvdGVtcGxhdGluZy90ZW1wbGF0ZV9zcnYnO1xuXG5pbXBvcnQgeyBzZXJpYWxpemVQYXJhbXMgfSBmcm9tICcuLi8uLi8uLi9jb3JlL3V0aWxzL2ZldGNoJztcbmltcG9ydCB7IHJlbmRlckxlZ2VuZEZvcm1hdCB9IGZyb20gJy4uL3Byb21ldGhldXMvbGVnZW5kJztcblxuaW1wb3J0IHsgYWRkTGFiZWxUb1F1ZXJ5IH0gZnJvbSAnLi9hZGRfbGFiZWxfdG9fcXVlcnknO1xuaW1wb3J0IHsgdHJhbnNmb3JtQmFja2VuZFJlc3VsdCB9IGZyb20gJy4vYmFja2VuZFJlc3VsdFRyYW5zZm9ybWVyJztcbmltcG9ydCB7IERFRkFVTFRfUkVTT0xVVElPTiB9IGZyb20gJy4vY29tcG9uZW50cy9Mb2tpT3B0aW9uRmllbGRzJztcbmltcG9ydCBMYW5ndWFnZVByb3ZpZGVyIGZyb20gJy4vbGFuZ3VhZ2VfcHJvdmlkZXInO1xuaW1wb3J0IHsgZXNjYXBlTGFiZWxWYWx1ZUluU2VsZWN0b3IgfSBmcm9tICcuL2xhbmd1YWdlX3V0aWxzJztcbmltcG9ydCB7IExpdmVTdHJlYW1zLCBMb2tpTGl2ZVRhcmdldCB9IGZyb20gJy4vbGl2ZV9zdHJlYW1zJztcbmltcG9ydCB7IGFkZFBhcnNlZExhYmVsVG9RdWVyeSwgZ2V0Tm9ybWFsaXplZExva2lRdWVyeSwgcXVlcnlIYXNQaXBlUGFyc2VyIH0gZnJvbSAnLi9xdWVyeV91dGlscyc7XG5pbXBvcnQgeyBsb2tpUmVzdWx0c1RvVGFibGVNb2RlbCwgbG9raVN0cmVhbXNUb0RhdGFGcmFtZXMsIHByb2Nlc3NSYW5nZVF1ZXJ5UmVzcG9uc2UgfSBmcm9tICcuL3Jlc3VsdF90cmFuc2Zvcm1lcic7XG5pbXBvcnQgeyBzb3J0RGF0YUZyYW1lQnlUaW1lIH0gZnJvbSAnLi9zb3J0RGF0YUZyYW1lJztcbmltcG9ydCB7IGRvTG9raUNoYW5uZWxTdHJlYW0gfSBmcm9tICcuL3N0cmVhbWluZyc7XG5pbXBvcnQgc3ludGF4IGZyb20gJy4vc3ludGF4JztcbmltcG9ydCB7XG4gIExva2lPcHRpb25zLFxuICBMb2tpUXVlcnksXG4gIExva2lRdWVyeURpcmVjdGlvbixcbiAgTG9raVF1ZXJ5VHlwZSxcbiAgTG9raVJhbmdlUXVlcnlSZXF1ZXN0LFxuICBMb2tpUmVzdWx0VHlwZSxcbiAgTG9raVN0cmVhbVJlc3BvbnNlLFxufSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IHR5cGUgUmFuZ2VRdWVyeU9wdGlvbnMgPSBEYXRhUXVlcnlSZXF1ZXN0PExva2lRdWVyeT4gfCBBbm5vdGF0aW9uUXVlcnlSZXF1ZXN0PExva2lRdWVyeT47XG5leHBvcnQgY29uc3QgREVGQVVMVF9NQVhfTElORVMgPSAxMDAwO1xuZXhwb3J0IGNvbnN0IExPS0lfRU5EUE9JTlQgPSAnL2xva2kvYXBpL3YxJztcbmNvbnN0IE5TX0lOX01TID0gMTAwMDAwMDtcblxuY29uc3QgUkFOR0VfUVVFUllfRU5EUE9JTlQgPSBgJHtMT0tJX0VORFBPSU5UfS9xdWVyeV9yYW5nZWA7XG5jb25zdCBJTlNUQU5UX1FVRVJZX0VORFBPSU5UID0gYCR7TE9LSV9FTkRQT0lOVH0vcXVlcnlgO1xuXG5jb25zdCBERUZBVUxUX1FVRVJZX1BBUkFNUzogUGFydGlhbDxMb2tpUmFuZ2VRdWVyeVJlcXVlc3Q+ID0ge1xuICBsaW1pdDogREVGQVVMVF9NQVhfTElORVMsXG4gIHF1ZXJ5OiAnJyxcbn07XG5cbmZ1bmN0aW9uIG1ha2VSZXF1ZXN0KHF1ZXJ5OiBMb2tpUXVlcnksIHJhbmdlOiBUaW1lUmFuZ2UsIGFwcDogQ29yZUFwcCwgcmVxdWVzdElkOiBzdHJpbmcpOiBEYXRhUXVlcnlSZXF1ZXN0PExva2lRdWVyeT4ge1xuICBjb25zdCBpbnRlcnZhbEluZm8gPSByYW5nZVV0aWwuY2FsY3VsYXRlSW50ZXJ2YWwocmFuZ2UsIDEpO1xuICByZXR1cm4ge1xuICAgIHRhcmdldHM6IFtxdWVyeV0sXG4gICAgcmVxdWVzdElkLFxuICAgIGludGVydmFsOiBpbnRlcnZhbEluZm8uaW50ZXJ2YWwsXG4gICAgaW50ZXJ2YWxNczogaW50ZXJ2YWxJbmZvLmludGVydmFsTXMsXG4gICAgcmFuZ2U6IHJhbmdlLFxuICAgIHNjb3BlZFZhcnM6IHt9LFxuICAgIHRpbWV6b25lOiAnVVRDJyxcbiAgICBhcHAsXG4gICAgc3RhcnRUaW1lOiBEYXRlLm5vdygpLFxuICB9O1xufVxuXG5leHBvcnQgY2xhc3MgTG9raURhdGFzb3VyY2VcbiAgZXh0ZW5kcyBEYXRhU291cmNlV2l0aEJhY2tlbmQ8TG9raVF1ZXJ5LCBMb2tpT3B0aW9ucz5cbiAgaW1wbGVtZW50c1xuICAgIERhdGFTb3VyY2VXaXRoTG9nc0NvbnRleHRTdXBwb3J0LFxuICAgIERhdGFTb3VyY2VXaXRoTG9nc1ZvbHVtZVN1cHBvcnQ8TG9raVF1ZXJ5PixcbiAgICBEYXRhU291cmNlV2l0aFF1ZXJ5SW1wb3J0U3VwcG9ydDxMb2tpUXVlcnk+LFxuICAgIERhdGFTb3VyY2VXaXRoUXVlcnlFeHBvcnRTdXBwb3J0PExva2lRdWVyeT5cbntcbiAgcHJpdmF0ZSBzdHJlYW1zID0gbmV3IExpdmVTdHJlYW1zKCk7XG4gIGxhbmd1YWdlUHJvdmlkZXI6IExhbmd1YWdlUHJvdmlkZXI7XG4gIG1heExpbmVzOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBpbnN0YW5jZVNldHRpbmdzOiBEYXRhU291cmNlSW5zdGFuY2VTZXR0aW5nczxMb2tpT3B0aW9ucz4sXG4gICAgcHJpdmF0ZSByZWFkb25seSB0ZW1wbGF0ZVNydjogVGVtcGxhdGVTcnYgPSBnZXRUZW1wbGF0ZVNydigpLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgdGltZVNydjogVGltZVNydiA9IGdldFRpbWVTcnYoKVxuICApIHtcbiAgICBzdXBlcihpbnN0YW5jZVNldHRpbmdzKTtcblxuICAgIHRoaXMubGFuZ3VhZ2VQcm92aWRlciA9IG5ldyBMYW5ndWFnZVByb3ZpZGVyKHRoaXMpO1xuICAgIGNvbnN0IHNldHRpbmdzRGF0YSA9IGluc3RhbmNlU2V0dGluZ3MuanNvbkRhdGEgfHwge307XG4gICAgdGhpcy5tYXhMaW5lcyA9IHBhcnNlSW50KHNldHRpbmdzRGF0YS5tYXhMaW5lcyA/PyAnMCcsIDEwKSB8fCBERUZBVUxUX01BWF9MSU5FUztcbiAgfVxuXG4gIF9yZXF1ZXN0KGFwaVVybDogc3RyaW5nLCBkYXRhPzogYW55LCBvcHRpb25zPzogUGFydGlhbDxCYWNrZW5kU3J2UmVxdWVzdD4pOiBPYnNlcnZhYmxlPFJlY29yZDxzdHJpbmcsIGFueT4+IHtcbiAgICBjb25zdCBiYXNlVXJsID0gdGhpcy5pbnN0YW5jZVNldHRpbmdzLnVybDtcbiAgICBjb25zdCBwYXJhbXMgPSBkYXRhID8gc2VyaWFsaXplUGFyYW1zKGRhdGEpIDogJyc7XG4gICAgY29uc3QgdXJsID0gYCR7YmFzZVVybH0ke2FwaVVybH0ke3BhcmFtcy5sZW5ndGggPyBgPyR7cGFyYW1zfWAgOiAnJ31gO1xuICAgIGlmICh0aGlzLmluc3RhbmNlU2V0dGluZ3Mud2l0aENyZWRlbnRpYWxzIHx8IHRoaXMuaW5zdGFuY2VTZXR0aW5ncy5iYXNpY0F1dGgpIHtcbiAgICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIHdpdGhDcmVkZW50aWFsczogdHJ1ZSB9O1xuICAgICAgaWYgKHRoaXMuaW5zdGFuY2VTZXR0aW5ncy5iYXNpY0F1dGgpIHtcbiAgICAgICAgb3B0aW9ucy5oZWFkZXJzID0geyAuLi5vcHRpb25zLmhlYWRlcnMsIEF1dGhvcml6YXRpb246IHRoaXMuaW5zdGFuY2VTZXR0aW5ncy5iYXNpY0F1dGggfTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVxID0ge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHVybCxcbiAgICB9O1xuXG4gICAgcmV0dXJuIGdldEJhY2tlbmRTcnYoKS5mZXRjaDxSZWNvcmQ8c3RyaW5nLCBhbnk+PihyZXEpO1xuICB9XG5cbiAgZ2V0TG9nc1ZvbHVtZURhdGFQcm92aWRlcihyZXF1ZXN0OiBEYXRhUXVlcnlSZXF1ZXN0PExva2lRdWVyeT4pOiBPYnNlcnZhYmxlPERhdGFRdWVyeVJlc3BvbnNlPiB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgaXNMb2dzVm9sdW1lQXZhaWxhYmxlID0gcmVxdWVzdC50YXJnZXRzLnNvbWUoKHRhcmdldCkgPT4gdGFyZ2V0LmV4cHIgJiYgIWlzTWV0cmljc1F1ZXJ5KHRhcmdldC5leHByKSk7XG4gICAgaWYgKCFpc0xvZ3NWb2x1bWVBdmFpbGFibGUpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3QgbG9nc1ZvbHVtZVJlcXVlc3QgPSBjbG9uZURlZXAocmVxdWVzdCk7XG4gICAgbG9nc1ZvbHVtZVJlcXVlc3QudGFyZ2V0cyA9IGxvZ3NWb2x1bWVSZXF1ZXN0LnRhcmdldHNcbiAgICAgIC5maWx0ZXIoKHRhcmdldCkgPT4gdGFyZ2V0LmV4cHIgJiYgIWlzTWV0cmljc1F1ZXJ5KHRhcmdldC5leHByKSlcbiAgICAgIC5tYXAoKHRhcmdldCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnRhcmdldCxcbiAgICAgICAgICBpbnN0YW50OiBmYWxzZSxcbiAgICAgICAgICB2b2x1bWVRdWVyeTogdHJ1ZSxcbiAgICAgICAgICBleHByOiBgc3VtIGJ5IChsZXZlbCkgKGNvdW50X292ZXJfdGltZSgke3RhcmdldC5leHByfVskX19pbnRlcnZhbF0pKWAsXG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgIHJldHVybiBxdWVyeUxvZ3NWb2x1bWUodGhpcywgbG9nc1ZvbHVtZVJlcXVlc3QsIHtcbiAgICAgIGV4dHJhY3RMZXZlbCxcbiAgICAgIHJhbmdlOiByZXF1ZXN0LnJhbmdlLFxuICAgICAgdGFyZ2V0czogcmVxdWVzdC50YXJnZXRzLFxuICAgIH0pO1xuICB9XG5cbiAgcXVlcnkocmVxdWVzdDogRGF0YVF1ZXJ5UmVxdWVzdDxMb2tpUXVlcnk+KTogT2JzZXJ2YWJsZTxEYXRhUXVlcnlSZXNwb25zZT4ge1xuICAgIGNvbnN0IHN1YlF1ZXJpZXM6IEFycmF5PE9ic2VydmFibGU8RGF0YVF1ZXJ5UmVzcG9uc2U+PiA9IFtdO1xuICAgIGNvbnN0IHNjb3BlZFZhcnMgPSB7XG4gICAgICAuLi5yZXF1ZXN0LnNjb3BlZFZhcnMsXG4gICAgICAuLi50aGlzLmdldFJhbmdlU2NvcGVkVmFycyhyZXF1ZXN0LnJhbmdlKSxcbiAgICB9O1xuXG4gICAgaWYgKGNvbmZpZy5mZWF0dXJlVG9nZ2xlcy5sb2tpQmFja2VuZE1vZGUpIHtcbiAgICAgIC8vIHdlIFwiZml4XCIgdGhlIGxva2kgcXVlcmllcyB0byBoYXZlIGAucXVlcnlUeXBlYCBhbmQgbm90IGhhdmUgYC5pbnN0YW50YCBhbmQgYC5yYW5nZWBcbiAgICAgIGNvbnN0IGZpeGVkUmVxdWVzdCA9IHtcbiAgICAgICAgLi4ucmVxdWVzdCxcbiAgICAgICAgdGFyZ2V0czogcmVxdWVzdC50YXJnZXRzLm1hcChnZXROb3JtYWxpemVkTG9raVF1ZXJ5KSxcbiAgICAgIH07XG5cbiAgICAgIGlmIChmaXhlZFJlcXVlc3QubGl2ZVN0cmVhbWluZykge1xuICAgICAgICByZXR1cm4gdGhpcy5ydW5MaXZlUXVlcnlUaHJvdWdoQmFja2VuZChmaXhlZFJlcXVlc3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyXG4gICAgICAgICAgLnF1ZXJ5KGZpeGVkUmVxdWVzdClcbiAgICAgICAgICAucGlwZShcbiAgICAgICAgICAgIG1hcCgocmVzcG9uc2UpID0+XG4gICAgICAgICAgICAgIHRyYW5zZm9ybUJhY2tlbmRSZXN1bHQocmVzcG9uc2UsIGZpeGVkUmVxdWVzdC50YXJnZXRzLCB0aGlzLmluc3RhbmNlU2V0dGluZ3MuanNvbkRhdGEuZGVyaXZlZEZpZWxkcyA/PyBbXSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGZpbHRlcmVkVGFyZ2V0cyA9IHJlcXVlc3QudGFyZ2V0c1xuICAgICAgLmZpbHRlcigodGFyZ2V0KSA9PiB0YXJnZXQuZXhwciAmJiAhdGFyZ2V0LmhpZGUpXG4gICAgICAubWFwKCh0YXJnZXQpID0+IHtcbiAgICAgICAgY29uc3QgZXhwciA9IHRoaXMuYWRkQWRIb2NGaWx0ZXJzKHRhcmdldC5leHByKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi50YXJnZXQsXG4gICAgICAgICAgZXhwcjogdGhpcy50ZW1wbGF0ZVNydi5yZXBsYWNlKGV4cHIsIHNjb3BlZFZhcnMsIHRoaXMuaW50ZXJwb2xhdGVRdWVyeUV4cHIpLFxuICAgICAgICB9O1xuICAgICAgfSk7XG5cbiAgICBmb3IgKGNvbnN0IHRhcmdldCBvZiBmaWx0ZXJlZFRhcmdldHMpIHtcbiAgICAgIGlmICh0YXJnZXQuaW5zdGFudCB8fCB0YXJnZXQucXVlcnlUeXBlID09PSBMb2tpUXVlcnlUeXBlLkluc3RhbnQpIHtcbiAgICAgICAgc3ViUXVlcmllcy5wdXNoKHRoaXMucnVuSW5zdGFudFF1ZXJ5KHRhcmdldCwgcmVxdWVzdCwgZmlsdGVyZWRUYXJnZXRzLmxlbmd0aCkpO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgY29uZmlnLmZlYXR1cmVUb2dnbGVzLmxva2lMaXZlICYmXG4gICAgICAgIHRhcmdldC5xdWVyeVR5cGUgPT09IExva2lRdWVyeVR5cGUuU3RyZWFtICYmXG4gICAgICAgIHJlcXVlc3QucmFuZ2VSYXc/LnRvID09PSAnbm93J1xuICAgICAgKSB7XG4gICAgICAgIHN1YlF1ZXJpZXMucHVzaChkb0xva2lDaGFubmVsU3RyZWFtKHRhcmdldCwgdGhpcywgcmVxdWVzdCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3ViUXVlcmllcy5wdXNoKHRoaXMucnVuUmFuZ2VRdWVyeSh0YXJnZXQsIHJlcXVlc3QpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBObyB2YWxpZCB0YXJnZXRzLCByZXR1cm4gdGhlIGVtcHR5IHJlc3VsdCB0byBzYXZlIGEgcm91bmQgdHJpcC5cbiAgICBpZiAoaXNFbXB0eShzdWJRdWVyaWVzKSkge1xuICAgICAgcmV0dXJuIG9mKHtcbiAgICAgICAgZGF0YTogW10sXG4gICAgICAgIHN0YXRlOiBMb2FkaW5nU3RhdGUuRG9uZSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBtZXJnZSguLi5zdWJRdWVyaWVzKTtcbiAgfVxuXG4gIHJ1bkxpdmVRdWVyeVRocm91Z2hCYWNrZW5kKHJlcXVlc3Q6IERhdGFRdWVyeVJlcXVlc3Q8TG9raVF1ZXJ5Pik6IE9ic2VydmFibGU8RGF0YVF1ZXJ5UmVzcG9uc2U+IHtcbiAgICAvLyB0aGlzIG9ubHkgd29ya3MgaW4gZXhwbG9yZS1tb2RlLCBzbyB2YXJpYWJsZXMgZG9uJ3QgbmVlZCB0byBiZSBoYW5kbGVkLFxuICAgIC8vICBhbmQgb25seSBmb3IgbG9ncy1xdWVyaWVzLCBub3QgbWV0cmljIHF1ZXJpZXNcbiAgICBjb25zdCBsb2dzUXVlcmllcyA9IHJlcXVlc3QudGFyZ2V0cy5maWx0ZXIoKHF1ZXJ5KSA9PiBxdWVyeS5leHByICE9PSAnJyAmJiAhaXNNZXRyaWNzUXVlcnkocXVlcnkuZXhwcikpO1xuXG4gICAgaWYgKGxvZ3NRdWVyaWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG9mKHtcbiAgICAgICAgZGF0YTogW10sXG4gICAgICAgIHN0YXRlOiBMb2FkaW5nU3RhdGUuRG9uZSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHN1YlF1ZXJpZXMgPSBsb2dzUXVlcmllcy5tYXAoKHF1ZXJ5KSA9PiB7XG4gICAgICBjb25zdCBtYXhEYXRhUG9pbnRzID0gcXVlcnkubWF4TGluZXMgfHwgdGhpcy5tYXhMaW5lcztcbiAgICAgIC8vIEZJWE1FOiBjdXJyZW50bHkgd2UgYXJlIHJ1bm5pbmcgaXQgdGhyb3VnaCB0aGUgZnJvbnRlbmQgc3RpbGwuXG4gICAgICByZXR1cm4gdGhpcy5ydW5MaXZlUXVlcnkocXVlcnksIG1heERhdGFQb2ludHMpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG1lcmdlKC4uLnN1YlF1ZXJpZXMpO1xuICB9XG5cbiAgcnVuSW5zdGFudFF1ZXJ5ID0gKFxuICAgIHRhcmdldDogTG9raVF1ZXJ5LFxuICAgIG9wdGlvbnM6IERhdGFRdWVyeVJlcXVlc3Q8TG9raVF1ZXJ5PixcbiAgICByZXNwb25zZUxpc3RMZW5ndGggPSAxXG4gICk6IE9ic2VydmFibGU8RGF0YVF1ZXJ5UmVzcG9uc2U+ID0+IHtcbiAgICBjb25zdCB0aW1lTnMgPSB0aGlzLmdldFRpbWUob3B0aW9ucy5yYW5nZS50bywgdHJ1ZSk7XG4gICAgY29uc3QgcXVlcnlMaW1pdCA9IGlzTWV0cmljc1F1ZXJ5KHRhcmdldC5leHByKSA/IG9wdGlvbnMubWF4RGF0YVBvaW50cyA6IHRhcmdldC5tYXhMaW5lcztcbiAgICBjb25zdCBxdWVyeSA9IHtcbiAgICAgIHF1ZXJ5OiB0YXJnZXQuZXhwcixcbiAgICAgIHRpbWU6IGAke3RpbWVOcyArICgxZTkgLSAodGltZU5zICUgMWU5KSl9YCxcbiAgICAgIGxpbWl0OiBNYXRoLm1pbihxdWVyeUxpbWl0IHx8IEluZmluaXR5LCB0aGlzLm1heExpbmVzKSxcbiAgICAgIGRpcmVjdGlvbjogdGFyZ2V0LmRpcmVjdGlvbiA9PT0gTG9raVF1ZXJ5RGlyZWN0aW9uLkZvcndhcmQgPyAnRk9SV0FSRCcgOiAnQkFDS1dBUkQnLFxuICAgIH07XG5cbiAgICAvKiogVXNlZCBvbmx5IGZvciByZXN1bHRzIG9mIG1ldHJpY3MgaW5zdGFudCBxdWVyaWVzICovXG4gICAgY29uc3QgbWV0YTogUXVlcnlSZXN1bHRNZXRhID0ge1xuICAgICAgcHJlZmVycmVkVmlzdWFsaXNhdGlvblR5cGU6ICd0YWJsZScsXG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KElOU1RBTlRfUVVFUllfRU5EUE9JTlQsIHF1ZXJ5KS5waXBlKFxuICAgICAgbWFwKChyZXNwb25zZSkgPT4ge1xuICAgICAgICBpZiAocmVzcG9uc2UuZGF0YS5kYXRhLnJlc3VsdFR5cGUgPT09IExva2lSZXN1bHRUeXBlLlN0cmVhbSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiByZXNwb25zZS5kYXRhXG4gICAgICAgICAgICAgID8gbG9raVN0cmVhbXNUb0RhdGFGcmFtZXMoXG4gICAgICAgICAgICAgICAgICByZXNwb25zZS5kYXRhIGFzIExva2lTdHJlYW1SZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICAgIHF1ZXJ5LmxpbWl0LFxuICAgICAgICAgICAgICAgICAgdGhpcy5pbnN0YW5jZVNldHRpbmdzLmpzb25EYXRhXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICAgICAga2V5OiBgJHt0YXJnZXQucmVmSWR9X2luc3RhbnRgLFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IFtsb2tpUmVzdWx0c1RvVGFibGVNb2RlbChyZXNwb25zZS5kYXRhLmRhdGEucmVzdWx0LCByZXNwb25zZUxpc3RMZW5ndGgsIHRhcmdldC5yZWZJZCwgbWV0YSldLFxuICAgICAgICAgIGtleTogYCR7dGFyZ2V0LnJlZklkfV9pbnN0YW50YCxcbiAgICAgICAgfTtcbiAgICAgIH0pLFxuICAgICAgY2F0Y2hFcnJvcigoZXJyKSA9PiB0aHJvd0Vycm9yKCgpID0+IHRoaXMucHJvY2Vzc0Vycm9yKGVyciwgdGFyZ2V0KSkpXG4gICAgKTtcbiAgfTtcblxuICBjcmVhdGVSYW5nZVF1ZXJ5KHRhcmdldDogTG9raVF1ZXJ5LCBvcHRpb25zOiBSYW5nZVF1ZXJ5T3B0aW9ucywgbGltaXQ6IG51bWJlcik6IExva2lSYW5nZVF1ZXJ5UmVxdWVzdCB7XG4gICAgY29uc3QgcXVlcnkgPSB0YXJnZXQuZXhwcjtcbiAgICBsZXQgcmFuZ2U6IHsgc3RhcnQ/OiBudW1iZXI7IGVuZD86IG51bWJlcjsgc3RlcD86IG51bWJlciB9ID0ge307XG4gICAgaWYgKG9wdGlvbnMucmFuZ2UpIHtcbiAgICAgIGNvbnN0IHN0YXJ0TnMgPSB0aGlzLmdldFRpbWUob3B0aW9ucy5yYW5nZS5mcm9tLCBmYWxzZSk7XG4gICAgICBjb25zdCBlbmROcyA9IHRoaXMuZ2V0VGltZShvcHRpb25zLnJhbmdlLnRvLCB0cnVlKTtcbiAgICAgIGNvbnN0IHJhbmdlTXMgPSBNYXRoLmNlaWwoKGVuZE5zIC0gc3RhcnROcykgLyAxZTYpO1xuXG4gICAgICBjb25zdCByZXNvbHV0aW9uID0gdGFyZ2V0LnJlc29sdXRpb24gfHwgKERFRkFVTFRfUkVTT0xVVElPTi52YWx1ZSBhcyBudW1iZXIpO1xuXG4gICAgICBjb25zdCBhZGp1c3RlZEludGVydmFsID1cbiAgICAgICAgdGhpcy5hZGp1c3RJbnRlcnZhbCgob3B0aW9ucyBhcyBEYXRhUXVlcnlSZXF1ZXN0PExva2lRdWVyeT4pLmludGVydmFsTXMgfHwgMTAwMCwgcmVzb2x1dGlvbiwgcmFuZ2VNcykgLyAxMDAwO1xuICAgICAgLy8gV2Ugd2FudCB0byBjZWlsIHRvIDMgZGVjaW1hbCBwbGFjZXNcbiAgICAgIGNvbnN0IHN0ZXAgPSBNYXRoLmNlaWwoYWRqdXN0ZWRJbnRlcnZhbCAqIDEwMDApIC8gMTAwMDtcblxuICAgICAgcmFuZ2UgPSB7XG4gICAgICAgIHN0YXJ0OiBzdGFydE5zLFxuICAgICAgICBlbmQ6IGVuZE5zLFxuICAgICAgICBzdGVwLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uREVGQVVMVF9RVUVSWV9QQVJBTVMsXG4gICAgICAuLi5yYW5nZSxcbiAgICAgIHF1ZXJ5LFxuICAgICAgbGltaXQsXG4gICAgICBkaXJlY3Rpb246IHRhcmdldC5kaXJlY3Rpb24gPT09IExva2lRdWVyeURpcmVjdGlvbi5Gb3J3YXJkID8gJ0ZPUldBUkQnIDogJ0JBQ0tXQVJEJyxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHRvIHNlbmQgYSBxdWVyeSB0byAvbG9raS9hcGkvdjEvcXVlcnlfcmFuZ2VcbiAgICovXG4gIHJ1blJhbmdlUXVlcnkgPSAodGFyZ2V0OiBMb2tpUXVlcnksIG9wdGlvbnM6IFJhbmdlUXVlcnlPcHRpb25zKTogT2JzZXJ2YWJsZTxEYXRhUXVlcnlSZXNwb25zZT4gPT4ge1xuICAgIC8vIEZvciBtZXRyaWMgcXVlcnkgd2UgdXNlIG1heERhdGFQb2ludHMgZnJvbSB0aGUgcmVxdWVzdCBvcHRpb25zIHdoaWNoIHNob3VsZCBiZSBzb21ldGhpbmcgbGlrZSB3aWR0aCBvZiB0aGVcbiAgICAvLyB2aXN1YWxpc2F0aW9uIGluIHBpeGVscy4gSW4gY2FzZSBvZiBsb2dzIHJlcXVlc3Qgd2UgZWl0aGVyIHVzZSBsaW5lcyBsaW1pdCBkZWZpbmVkIGluIHRoZSBxdWVyeSB0YXJnZXQgb3JcbiAgICAvLyBnbG9iYWwgbGltaXQgZGVmaW5lZCBmb3IgdGhlIGRhdGEgc291cmNlIHdoaWNoIGV2ZXIgaXMgbG93ZXIuXG4gICAgbGV0IG1heERhdGFQb2ludHMgPSBpc01ldHJpY3NRdWVyeSh0YXJnZXQuZXhwcilcbiAgICAgID8gLy8gV2UgZmFsbGJhY2sgdG8gbWF4TGluZXMgaGVyZSBiZWNhdXNlIG1heERhdGFQb2ludHMgaXMgZGVmaW5lZCBhcyBwb3NzaWJseSB1bmRlZmluZWQuIE5vdCBzdXJlIHRoYXQgY2FuXG4gICAgICAgIC8vIGFjdHVhbGx5IGhhcHBlbiBib3RoIERhc2hib2FyZHMgYW5kIEV4cGxvcmUgc2hvdWxkIHNlbmQgc29tZSB2YWx1ZSBoZXJlLiBJZiBub3QgbWF4TGluZXMgZG9lcyBub3QgbWFrZSB0aGF0XG4gICAgICAgIC8vIG11Y2ggc2Vuc2UgYnV0IG5vciBhbnkgb3RoZXIgYXJiaXRyYXJ5IHZhbHVlLlxuICAgICAgICAob3B0aW9ucyBhcyBEYXRhUXVlcnlSZXF1ZXN0PExva2lRdWVyeT4pLm1heERhdGFQb2ludHMgfHwgdGhpcy5tYXhMaW5lc1xuICAgICAgOiAvLyBJZiB1c2VyIHdhbnRzIG1heExpbmVzIDAgd2Ugc3RpbGwgZmFsbGJhY2sgdG8gZGF0YSBzb3VyY2UgbGltaXQuIEkgdGhpbmsgdGhhdCBtYWtlcyBzZW5zZSBhcyB3aHkgd291bGQgYW55b25lXG4gICAgICAgIC8vIHdhbnQgdG8gZG8gYSBxdWVyeSBhbmQgbm90IHNlZSBhbnkgcmVzdWx0cz9cbiAgICAgICAgdGFyZ2V0Lm1heExpbmVzIHx8IHRoaXMubWF4TGluZXM7XG5cbiAgICBpZiAoKG9wdGlvbnMgYXMgRGF0YVF1ZXJ5UmVxdWVzdDxMb2tpUXVlcnk+KS5saXZlU3RyZWFtaW5nKSB7XG4gICAgICByZXR1cm4gdGhpcy5ydW5MaXZlUXVlcnkodGFyZ2V0LCBtYXhEYXRhUG9pbnRzKTtcbiAgICB9XG4gICAgY29uc3QgcXVlcnkgPSB0aGlzLmNyZWF0ZVJhbmdlUXVlcnkodGFyZ2V0LCBvcHRpb25zLCBtYXhEYXRhUG9pbnRzKTtcblxuICAgIGNvbnN0IGhlYWRlcnMgPSB0YXJnZXQudm9sdW1lUXVlcnkgPyB7ICdYLVF1ZXJ5LVRhZ3MnOiAnU291cmNlPWxvZ3ZvbGhpc3QnIH0gOiB1bmRlZmluZWQ7XG5cbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdChSQU5HRV9RVUVSWV9FTkRQT0lOVCwgcXVlcnksIHsgaGVhZGVycyB9KS5waXBlKFxuICAgICAgY2F0Y2hFcnJvcigoZXJyKSA9PiB0aHJvd0Vycm9yKCgpID0+IHRoaXMucHJvY2Vzc0Vycm9yKGVyciwgdGFyZ2V0KSkpLFxuICAgICAgc3dpdGNoTWFwKChyZXNwb25zZSkgPT5cbiAgICAgICAgcHJvY2Vzc1JhbmdlUXVlcnlSZXNwb25zZShcbiAgICAgICAgICByZXNwb25zZS5kYXRhLFxuICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICBtYXhEYXRhUG9pbnRzLFxuICAgICAgICAgIHRoaXMuaW5zdGFuY2VTZXR0aW5ncy5qc29uRGF0YSxcbiAgICAgICAgICAob3B0aW9ucyBhcyBEYXRhUXVlcnlSZXF1ZXN0PExva2lRdWVyeT4pLnNjb3BlZFZhcnNcbiAgICAgICAgKVxuICAgICAgKVxuICAgICk7XG4gIH07XG5cbiAgY3JlYXRlTGl2ZVRhcmdldCh0YXJnZXQ6IExva2lRdWVyeSwgbWF4RGF0YVBvaW50czogbnVtYmVyKTogTG9raUxpdmVUYXJnZXQge1xuICAgIGNvbnN0IHF1ZXJ5ID0gdGFyZ2V0LmV4cHI7XG4gICAgY29uc3QgYmFzZVVybCA9IHRoaXMuaW5zdGFuY2VTZXR0aW5ncy51cmw7XG4gICAgY29uc3QgcGFyYW1zID0gc2VyaWFsaXplUGFyYW1zKHsgcXVlcnkgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcXVlcnksXG4gICAgICB1cmw6IGNvbnZlcnRUb1dlYlNvY2tldFVybChgJHtiYXNlVXJsfS9sb2tpL2FwaS92MS90YWlsPyR7cGFyYW1zfWApLFxuICAgICAgcmVmSWQ6IHRhcmdldC5yZWZJZCxcbiAgICAgIHNpemU6IG1heERhdGFQb2ludHMsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW5zIGxpdmUgcXVlcmllcyB3aGljaCBpbiB0aGlzIGNhc2UgbWVhbnMgY3JlYXRpbmcgYSB3ZWJzb2NrZXQgYW5kIGxpc3RlbmluZyBvbiBpdCBmb3IgbmV3IGxvZ3MuXG4gICAqIFRoaXMgcmV0dXJucyBhIGJpdCBkaWZmZXJlbnQgZGF0YUZyYW1lIHRoYW4gcnVuUXVlcmllcyBhcyBpdCByZXR1cm5zIHNpbmdsZSBkYXRhZnJhbWUgZXZlbiBpZiB0aGVyZSBhcmUgbXVsdGlwbGVcbiAgICogTG9raSBzdHJlYW1zLCBzZXRzIG9ubHkgY29tbW9uIGxhYmVscyBvbiBkYXRhZnJhbWUubGFiZWxzIGFuZCBoYXMgYWRkaXRpb25hbCBkYXRhZnJhbWUuZmllbGRzLmxhYmVscyBmb3IgdW5pcXVlXG4gICAqIGxhYmVscyBwZXIgcm93LlxuICAgKi9cbiAgcnVuTGl2ZVF1ZXJ5ID0gKHRhcmdldDogTG9raVF1ZXJ5LCBtYXhEYXRhUG9pbnRzOiBudW1iZXIpOiBPYnNlcnZhYmxlPERhdGFRdWVyeVJlc3BvbnNlPiA9PiB7XG4gICAgY29uc3QgbGl2ZVRhcmdldCA9IHRoaXMuY3JlYXRlTGl2ZVRhcmdldCh0YXJnZXQsIG1heERhdGFQb2ludHMpO1xuXG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtcy5nZXRTdHJlYW0obGl2ZVRhcmdldCkucGlwZShcbiAgICAgIG1hcCgoZGF0YSkgPT4gKHtcbiAgICAgICAgZGF0YTogZGF0YSB8fCBbXSxcbiAgICAgICAga2V5OiBgbG9raS0ke2xpdmVUYXJnZXQucmVmSWR9YCxcbiAgICAgICAgc3RhdGU6IExvYWRpbmdTdGF0ZS5TdHJlYW1pbmcsXG4gICAgICB9KSksXG4gICAgICBjYXRjaEVycm9yKChlcnI6IGFueSkgPT4ge1xuICAgICAgICByZXR1cm4gdGhyb3dFcnJvcigoKSA9PiBgTGl2ZSB0YWlsaW5nIHdhcyBzdG9wcGVkIGR1ZSB0byBmb2xsb3dpbmcgZXJyb3I6ICR7ZXJyLnJlYXNvbn1gKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfTtcblxuICBnZXRSYW5nZVNjb3BlZFZhcnMocmFuZ2U6IFRpbWVSYW5nZSA9IHRoaXMudGltZVNydi50aW1lUmFuZ2UoKSkge1xuICAgIGNvbnN0IG1zUmFuZ2UgPSByYW5nZS50by5kaWZmKHJhbmdlLmZyb20pO1xuICAgIGNvbnN0IHNSYW5nZSA9IE1hdGgucm91bmQobXNSYW5nZSAvIDEwMDApO1xuICAgIHJldHVybiB7XG4gICAgICBfX3JhbmdlX21zOiB7IHRleHQ6IG1zUmFuZ2UsIHZhbHVlOiBtc1JhbmdlIH0sXG4gICAgICBfX3JhbmdlX3M6IHsgdGV4dDogc1JhbmdlLCB2YWx1ZTogc1JhbmdlIH0sXG4gICAgICBfX3JhbmdlOiB7IHRleHQ6IHNSYW5nZSArICdzJywgdmFsdWU6IHNSYW5nZSArICdzJyB9LFxuICAgIH07XG4gIH1cblxuICBpbnRlcnBvbGF0ZVZhcmlhYmxlc0luUXVlcmllcyhxdWVyaWVzOiBMb2tpUXVlcnlbXSwgc2NvcGVkVmFyczogU2NvcGVkVmFycyk6IExva2lRdWVyeVtdIHtcbiAgICBsZXQgZXhwYW5kZWRRdWVyaWVzID0gcXVlcmllcztcbiAgICBpZiAocXVlcmllcyAmJiBxdWVyaWVzLmxlbmd0aCkge1xuICAgICAgZXhwYW5kZWRRdWVyaWVzID0gcXVlcmllcy5tYXAoKHF1ZXJ5KSA9PiAoe1xuICAgICAgICAuLi5xdWVyeSxcbiAgICAgICAgZGF0YXNvdXJjZTogdGhpcy5nZXRSZWYoKSxcbiAgICAgICAgZXhwcjogdGhpcy50ZW1wbGF0ZVNydi5yZXBsYWNlKHF1ZXJ5LmV4cHIsIHNjb3BlZFZhcnMsIHRoaXMuaW50ZXJwb2xhdGVRdWVyeUV4cHIpLFxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHJldHVybiBleHBhbmRlZFF1ZXJpZXM7XG4gIH1cblxuICBnZXRRdWVyeURpc3BsYXlUZXh0KHF1ZXJ5OiBMb2tpUXVlcnkpIHtcbiAgICByZXR1cm4gcXVlcnkuZXhwcjtcbiAgfVxuXG4gIGdldFRpbWVSYW5nZVBhcmFtcygpIHtcbiAgICBjb25zdCB0aW1lUmFuZ2UgPSB0aGlzLnRpbWVTcnYudGltZVJhbmdlKCk7XG4gICAgcmV0dXJuIHsgc3RhcnQ6IHRpbWVSYW5nZS5mcm9tLnZhbHVlT2YoKSAqIE5TX0lOX01TLCBlbmQ6IHRpbWVSYW5nZS50by52YWx1ZU9mKCkgKiBOU19JTl9NUyB9O1xuICB9XG5cbiAgYXN5bmMgaW1wb3J0RnJvbUFic3RyYWN0UXVlcmllcyhhYnN0cmFjdFF1ZXJpZXM6IEFic3RyYWN0UXVlcnlbXSk6IFByb21pc2U8TG9raVF1ZXJ5W10+IHtcbiAgICBhd2FpdCB0aGlzLmxhbmd1YWdlUHJvdmlkZXIuc3RhcnQoKTtcbiAgICBjb25zdCBleGlzdGluZ0tleXMgPSB0aGlzLmxhbmd1YWdlUHJvdmlkZXIubGFiZWxLZXlzO1xuXG4gICAgaWYgKGV4aXN0aW5nS2V5cyAmJiBleGlzdGluZ0tleXMubGVuZ3RoKSB7XG4gICAgICBhYnN0cmFjdFF1ZXJpZXMgPSBhYnN0cmFjdFF1ZXJpZXMubWFwKChhYnN0cmFjdFF1ZXJ5KSA9PiB7XG4gICAgICAgIGFic3RyYWN0UXVlcnkubGFiZWxNYXRjaGVycyA9IGFic3RyYWN0UXVlcnkubGFiZWxNYXRjaGVycy5maWx0ZXIoKGxhYmVsTWF0Y2hlcikgPT4ge1xuICAgICAgICAgIHJldHVybiBleGlzdGluZ0tleXMuaW5jbHVkZXMobGFiZWxNYXRjaGVyLm5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGFic3RyYWN0UXVlcnk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWJzdHJhY3RRdWVyaWVzLm1hcCgoYWJzdHJhY3RRdWVyeSkgPT4gdGhpcy5sYW5ndWFnZVByb3ZpZGVyLmltcG9ydEZyb21BYnN0cmFjdFF1ZXJ5KGFic3RyYWN0UXVlcnkpKTtcbiAgfVxuXG4gIGFzeW5jIGV4cG9ydFRvQWJzdHJhY3RRdWVyaWVzKHF1ZXJpZXM6IExva2lRdWVyeVtdKTogUHJvbWlzZTxBYnN0cmFjdFF1ZXJ5W10+IHtcbiAgICByZXR1cm4gcXVlcmllcy5tYXAoKHF1ZXJ5KSA9PiB0aGlzLmxhbmd1YWdlUHJvdmlkZXIuZXhwb3J0VG9BYnN0cmFjdFF1ZXJ5KHF1ZXJ5KSk7XG4gIH1cblxuICBhc3luYyBtZXRhZGF0YVJlcXVlc3QodXJsOiBzdHJpbmcsIHBhcmFtcz86IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bWJlcj4pIHtcbiAgICAvLyB1cmwgbXVzdCBub3Qgc3RhcnQgd2l0aCBhIGAvYCwgb3RoZXJ3aXNlIHRoZSBBSkFYLXJlcXVlc3RcbiAgICAvLyBnb2luZyBmcm9tIHRoZSBicm93c2VyIHdpbGwgY29udGFpbiBgLy9gLCB3aGljaCBjYW4gY2F1c2UgcHJvYmxlbXMuXG4gICAgaWYgKHVybC5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBtZXRhZGF0YSByZXF1ZXN0IHVybDogJHt1cmx9YCk7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZ2V0UmVzb3VyY2UodXJsLCBwYXJhbXMpO1xuICAgIHJldHVybiByZXMuZGF0YSB8fCBbXTtcbiAgfVxuXG4gIGFzeW5jIG1ldHJpY0ZpbmRRdWVyeShxdWVyeTogc3RyaW5nKSB7XG4gICAgaWYgKCFxdWVyeSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgfVxuXG4gICAgY29uc3QgaW50ZXJwb2xhdGVkID0gdGhpcy50ZW1wbGF0ZVNydi5yZXBsYWNlKHF1ZXJ5LCB7fSwgdGhpcy5pbnRlcnBvbGF0ZVF1ZXJ5RXhwcik7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucHJvY2Vzc01ldHJpY0ZpbmRRdWVyeShpbnRlcnBvbGF0ZWQpO1xuICB9XG5cbiAgYXN5bmMgcHJvY2Vzc01ldHJpY0ZpbmRRdWVyeShxdWVyeTogc3RyaW5nKSB7XG4gICAgY29uc3QgbGFiZWxOYW1lc1JlZ2V4ID0gL15sYWJlbF9uYW1lc1xcKFxcKVxccyokLztcbiAgICBjb25zdCBsYWJlbFZhbHVlc1JlZ2V4ID0gL15sYWJlbF92YWx1ZXNcXCgoPzooLispLFxccyopPyhbYS16QS1aX11bYS16QS1aMC05X10qKVxcKVxccyokLztcblxuICAgIGNvbnN0IGxhYmVsTmFtZXMgPSBxdWVyeS5tYXRjaChsYWJlbE5hbWVzUmVnZXgpO1xuICAgIGlmIChsYWJlbE5hbWVzKSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5sYWJlbE5hbWVzUXVlcnkoKTtcbiAgICB9XG5cbiAgICBjb25zdCBsYWJlbFZhbHVlcyA9IHF1ZXJ5Lm1hdGNoKGxhYmVsVmFsdWVzUmVnZXgpO1xuICAgIGlmIChsYWJlbFZhbHVlcykge1xuICAgICAgLy8gSWYgd2UgaGF2ZSBxdWVyeSBleHByLCB1c2UgL3NlcmllcyBlbmRwb2ludFxuICAgICAgaWYgKGxhYmVsVmFsdWVzWzFdKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmxhYmVsVmFsdWVzU2VyaWVzUXVlcnkobGFiZWxWYWx1ZXNbMV0sIGxhYmVsVmFsdWVzWzJdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmxhYmVsVmFsdWVzUXVlcnkobGFiZWxWYWx1ZXNbMl0pO1xuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pO1xuICB9XG5cbiAgYXN5bmMgbGFiZWxOYW1lc1F1ZXJ5KCkge1xuICAgIGNvbnN0IHVybCA9ICdsYWJlbHMnO1xuICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuZ2V0VGltZVJhbmdlUGFyYW1zKCk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5tZXRhZGF0YVJlcXVlc3QodXJsLCBwYXJhbXMpO1xuICAgIHJldHVybiByZXN1bHQubWFwKCh2YWx1ZTogc3RyaW5nKSA9PiAoeyB0ZXh0OiB2YWx1ZSB9KSk7XG4gIH1cblxuICBhc3luYyBsYWJlbFZhbHVlc1F1ZXJ5KGxhYmVsOiBzdHJpbmcpIHtcbiAgICBjb25zdCBwYXJhbXMgPSB0aGlzLmdldFRpbWVSYW5nZVBhcmFtcygpO1xuICAgIGNvbnN0IHVybCA9IGBsYWJlbC8ke2xhYmVsfS92YWx1ZXNgO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMubWV0YWRhdGFSZXF1ZXN0KHVybCwgcGFyYW1zKTtcbiAgICByZXR1cm4gcmVzdWx0Lm1hcCgodmFsdWU6IHN0cmluZykgPT4gKHsgdGV4dDogdmFsdWUgfSkpO1xuICB9XG5cbiAgYXN5bmMgbGFiZWxWYWx1ZXNTZXJpZXNRdWVyeShleHByOiBzdHJpbmcsIGxhYmVsOiBzdHJpbmcpIHtcbiAgICBjb25zdCB0aW1lUGFyYW1zID0gdGhpcy5nZXRUaW1lUmFuZ2VQYXJhbXMoKTtcbiAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAuLi50aW1lUGFyYW1zLFxuICAgICAgJ21hdGNoW10nOiBleHByLFxuICAgIH07XG4gICAgY29uc3QgdXJsID0gJ3Nlcmllcyc7XG4gICAgY29uc3Qgc3RyZWFtcyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLm1ldGFkYXRhUmVxdWVzdCh1cmwsIHBhcmFtcyk7XG4gICAgcmVzdWx0LmZvckVhY2goKHN0cmVhbTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSkgPT4ge1xuICAgICAgaWYgKHN0cmVhbVtsYWJlbF0pIHtcbiAgICAgICAgc3RyZWFtcy5hZGQoeyB0ZXh0OiBzdHJlYW1bbGFiZWxdIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIEFycmF5LmZyb20oc3RyZWFtcyk7XG4gIH1cblxuICAvLyBCeSBpbXBsZW1lbnRpbmcgZ2V0VGFnS2V5cyBhbmQgZ2V0VGFnVmFsdWVzIHdlIGFkZCBhZC1ob2MgZmlsdHRlcnMgZnVuY3Rpb25hbGl0eVxuICBhc3luYyBnZXRUYWdLZXlzKCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmxhYmVsTmFtZXNRdWVyeSgpO1xuICB9XG5cbiAgYXN5bmMgZ2V0VGFnVmFsdWVzKG9wdGlvbnM6IGFueSA9IHt9KSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMubGFiZWxWYWx1ZXNRdWVyeShvcHRpb25zLmtleSk7XG4gIH1cblxuICBpbnRlcnBvbGF0ZVF1ZXJ5RXhwcih2YWx1ZTogYW55LCB2YXJpYWJsZTogYW55KSB7XG4gICAgLy8gaWYgbm8gbXVsdGkgb3IgaW5jbHVkZSBhbGwgZG8gbm90IHJlZ2V4RXNjYXBlXG4gICAgaWYgKCF2YXJpYWJsZS5tdWx0aSAmJiAhdmFyaWFibGUuaW5jbHVkZUFsbCkge1xuICAgICAgcmV0dXJuIGxva2lSZWd1bGFyRXNjYXBlKHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGxva2lTcGVjaWFsUmVnZXhFc2NhcGUodmFsdWUpO1xuICAgIH1cblxuICAgIGNvbnN0IGVzY2FwZWRWYWx1ZXMgPSBsb2Rhc2hNYXAodmFsdWUsIGxva2lTcGVjaWFsUmVnZXhFc2NhcGUpO1xuICAgIHJldHVybiBlc2NhcGVkVmFsdWVzLmpvaW4oJ3wnKTtcbiAgfVxuXG4gIG1vZGlmeVF1ZXJ5KHF1ZXJ5OiBMb2tpUXVlcnksIGFjdGlvbjogYW55KTogTG9raVF1ZXJ5IHtcbiAgICBsZXQgZXhwcmVzc2lvbiA9IHF1ZXJ5LmV4cHIgPz8gJyc7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgY2FzZSAnQUREX0ZJTFRFUic6IHtcbiAgICAgICAgZXhwcmVzc2lvbiA9IHRoaXMuYWRkTGFiZWxUb1F1ZXJ5KGV4cHJlc3Npb24sIGFjdGlvbi5rZXksIGFjdGlvbi52YWx1ZSwgJz0nKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICdBRERfRklMVEVSX09VVCc6IHtcbiAgICAgICAgZXhwcmVzc2lvbiA9IHRoaXMuYWRkTGFiZWxUb1F1ZXJ5KGV4cHJlc3Npb24sIGFjdGlvbi5rZXksIGFjdGlvbi52YWx1ZSwgJyE9Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiB7IC4uLnF1ZXJ5LCBleHByOiBleHByZXNzaW9uIH07XG4gIH1cblxuICBnZXRUaW1lKGRhdGU6IHN0cmluZyB8IERhdGVUaW1lLCByb3VuZFVwOiBib29sZWFuKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgZGF0ZSA9IGRhdGVNYXRoLnBhcnNlKGRhdGUsIHJvdW5kVXApITtcbiAgICB9XG5cbiAgICByZXR1cm4gTWF0aC5jZWlsKGRhdGUudmFsdWVPZigpICogMWU2KTtcbiAgfVxuXG4gIGdldExvZ1Jvd0NvbnRleHQgPSAocm93OiBMb2dSb3dNb2RlbCwgb3B0aW9ucz86IFJvd0NvbnRleHRPcHRpb25zKTogUHJvbWlzZTx7IGRhdGE6IERhdGFGcmFtZVtdIH0+ID0+IHtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSAob3B0aW9ucyAmJiBvcHRpb25zLmRpcmVjdGlvbikgfHwgJ0JBQ0tXQVJEJztcbiAgICBjb25zdCBsaW1pdCA9IChvcHRpb25zICYmIG9wdGlvbnMubGltaXQpIHx8IDEwO1xuICAgIGNvbnN0IHsgcXVlcnksIHJhbmdlIH0gPSB0aGlzLnByZXBhcmVMb2dSb3dDb250ZXh0UXVlcnlUYXJnZXQocm93LCBsaW1pdCwgZGlyZWN0aW9uKTtcblxuICAgIGNvbnN0IHByb2Nlc3NEYXRhRnJhbWUgPSAoZnJhbWU6IERhdGFGcmFtZSk6IERhdGFGcmFtZSA9PiB7XG4gICAgICAvLyBsb2ctcm93LWNvbnRleHQgcmVxdWlyZXMgc3BlY2lmaWMgZmllbGQtbmFtZXMgdG8gd29yaywgc28gd2Ugc2V0IHRoZW0gaGVyZTogXCJ0c1wiLCBcImxpbmVcIiwgXCJpZFwiXG4gICAgICBjb25zdCBjYWNoZSA9IG5ldyBGaWVsZENhY2hlKGZyYW1lKTtcbiAgICAgIGNvbnN0IHRpbWVzdGFtcEZpZWxkID0gY2FjaGUuZ2V0Rmlyc3RGaWVsZE9mVHlwZShGaWVsZFR5cGUudGltZSk7XG4gICAgICBjb25zdCBsaW5lRmllbGQgPSBjYWNoZS5nZXRGaXJzdEZpZWxkT2ZUeXBlKEZpZWxkVHlwZS5zdHJpbmcpO1xuICAgICAgY29uc3QgaWRGaWVsZCA9IGNhY2hlLmdldEZpZWxkQnlOYW1lKCdpZCcpO1xuXG4gICAgICBpZiAodGltZXN0YW1wRmllbGQgPT09IHVuZGVmaW5lZCB8fCBsaW5lRmllbGQgPT09IHVuZGVmaW5lZCB8fCBpZEZpZWxkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gdGhpcyBzaG91bGQgbmV2ZXIgcmVhbGx5IGhhcHBlbiwgYnV0IGkgd2FudCB0byBrZWVwIHR5cGVzY3JpcHQgaGFwcHlcbiAgICAgICAgcmV0dXJuIHsgLi4uZnJhbWUsIGZpZWxkczogW10gfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZnJhbWUsXG4gICAgICAgIGZpZWxkczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIC4uLnRpbWVzdGFtcEZpZWxkLFxuICAgICAgICAgICAgbmFtZTogJ3RzJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC4uLmxpbmVGaWVsZCxcbiAgICAgICAgICAgIG5hbWU6ICdsaW5lJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC4uLmlkRmllbGQsXG4gICAgICAgICAgICBuYW1lOiAnaWQnLFxuICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBwcm9jZXNzUmVzdWx0cyA9IChyZXN1bHQ6IERhdGFRdWVyeVJlc3BvbnNlKTogRGF0YVF1ZXJ5UmVzcG9uc2UgPT4ge1xuICAgICAgY29uc3QgZnJhbWVzOiBEYXRhRnJhbWVbXSA9IHJlc3VsdC5kYXRhO1xuICAgICAgY29uc3QgcHJvY2Vzc2VkRnJhbWVzID0gZnJhbWVzXG4gICAgICAgIC5tYXAoKGZyYW1lKSA9PiBzb3J0RGF0YUZyYW1lQnlUaW1lKGZyYW1lLCAnREVTQ0VORElORycpKVxuICAgICAgICAubWFwKChmcmFtZSkgPT4gcHJvY2Vzc0RhdGFGcmFtZShmcmFtZSkpOyAvLyByZW5hbWUgZmllbGRzIGlmIG5lZWRlZFxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgIGRhdGE6IHByb2Nlc3NlZEZyYW1lcyxcbiAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIHRoaXMgY2FuIG9ubHkgYmUgY2FsbGVkIGZyb20gZXhwbG9yZSBjdXJyZW50bHlcbiAgICBjb25zdCBhcHAgPSBDb3JlQXBwLkV4cGxvcmU7XG5cbiAgICByZXR1cm4gbGFzdFZhbHVlRnJvbShcbiAgICAgIHRoaXMucXVlcnkobWFrZVJlcXVlc3QocXVlcnksIHJhbmdlLCBhcHAsIGBsb2ctcm93LWNvbnRleHQtcXVlcnktJHtkaXJlY3Rpb259YCkpLnBpcGUoXG4gICAgICAgIGNhdGNoRXJyb3IoKGVycikgPT4ge1xuICAgICAgICAgIGNvbnN0IGVycm9yOiBEYXRhUXVlcnlFcnJvciA9IHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdFcnJvciBkdXJpbmcgY29udGV4dCBxdWVyeS4gUGxlYXNlIGNoZWNrIEpTIGNvbnNvbGUgbG9ncy4nLFxuICAgICAgICAgICAgc3RhdHVzOiBlcnIuc3RhdHVzLFxuICAgICAgICAgICAgc3RhdHVzVGV4dDogZXJyLnN0YXR1c1RleHQsXG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSksXG4gICAgICAgIHN3aXRjaE1hcCgocmVzKSA9PiBvZihwcm9jZXNzUmVzdWx0cyhyZXMpKSlcbiAgICAgIClcbiAgICApO1xuICB9O1xuXG4gIHByZXBhcmVMb2dSb3dDb250ZXh0UXVlcnlUYXJnZXQgPSAoXG4gICAgcm93OiBMb2dSb3dNb2RlbCxcbiAgICBsaW1pdDogbnVtYmVyLFxuICAgIGRpcmVjdGlvbjogJ0JBQ0tXQVJEJyB8ICdGT1JXQVJEJ1xuICApOiB7IHF1ZXJ5OiBMb2tpUXVlcnk7IHJhbmdlOiBUaW1lUmFuZ2UgfSA9PiB7XG4gICAgY29uc3QgbGFiZWxzID0gdGhpcy5sYW5ndWFnZVByb3ZpZGVyLmdldExhYmVsS2V5cygpO1xuICAgIGNvbnN0IGV4cHIgPSBPYmplY3Qua2V5cyhyb3cubGFiZWxzKVxuICAgICAgLm1hcCgobGFiZWw6IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAobGFiZWxzLmluY2x1ZGVzKGxhYmVsKSkge1xuICAgICAgICAgIC8vIGVzY2FwZSBiYWNrc2xhc2hlcyBpbiBsYWJlbCBhcyB1c2VycyBjYW4ndCBlc2NhcGUgdGhlbSBieSB0aGVtc2VsdmVzXG4gICAgICAgICAgcmV0dXJuIGAke2xhYmVsfT1cIiR7cm93LmxhYmVsc1tsYWJlbF0ucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKX1cImA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfSlcbiAgICAgIC8vIEZpbHRlciBlbXB0eSBzdHJpbmdzXG4gICAgICAuZmlsdGVyKChsYWJlbCkgPT4gISFsYWJlbClcbiAgICAgIC5qb2luKCcsJyk7XG5cbiAgICBjb25zdCBjb250ZXh0VGltZUJ1ZmZlciA9IDIgKiA2MCAqIDYwICogMTAwMDsgLy8gMmggYnVmZmVyXG5cbiAgICBjb25zdCBxdWVyeURpcmVjdGlvbiA9IGRpcmVjdGlvbiA9PT0gJ0ZPUldBUkQnID8gTG9raVF1ZXJ5RGlyZWN0aW9uLkZvcndhcmQgOiBMb2tpUXVlcnlEaXJlY3Rpb24uQmFja3dhcmQ7XG5cbiAgICBjb25zdCBxdWVyeTogTG9raVF1ZXJ5ID0ge1xuICAgICAgZXhwcjogYHske2V4cHJ9fWAsXG4gICAgICBxdWVyeVR5cGU6IExva2lRdWVyeVR5cGUuUmFuZ2UsXG4gICAgICByZWZJZDogJycsXG4gICAgICBtYXhMaW5lczogbGltaXQsXG4gICAgICBkaXJlY3Rpb246IHF1ZXJ5RGlyZWN0aW9uLFxuICAgIH07XG5cbiAgICBjb25zdCBmaWVsZENhY2hlID0gbmV3IEZpZWxkQ2FjaGUocm93LmRhdGFGcmFtZSk7XG4gICAgY29uc3QgdHNGaWVsZCA9IGZpZWxkQ2FjaGUuZ2V0Rmlyc3RGaWVsZE9mVHlwZShGaWVsZFR5cGUudGltZSk7XG4gICAgaWYgKHRzRmllbGQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdsb2tpOiBkYXRhZnJhbWUgbWlzc2luZyB0aW1lLWZpZWxkLCBzaG91bGQgbmV2ZXIgaGFwcGVuJyk7XG4gICAgfVxuICAgIGNvbnN0IHRzVmFsdWUgPSB0c0ZpZWxkLnZhbHVlcy5nZXQocm93LnJvd0luZGV4KTtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSB0b1V0Yyh0c1ZhbHVlKTtcblxuICAgIGNvbnN0IHJhbmdlID1cbiAgICAgIHF1ZXJ5RGlyZWN0aW9uID09PSBMb2tpUXVlcnlEaXJlY3Rpb24uRm9yd2FyZFxuICAgICAgICA/IHtcbiAgICAgICAgICAgIC8vIHN0YXJ0IHBhcmFtIGluIExva2kgQVBJIGlzIGluY2x1c2l2ZSBzbyB3ZSdsbCBoYXZlIHRvIGZpbHRlciBvdXQgdGhlIHJvdyB0aGF0IHRoaXMgcmVxdWVzdCBpcyBiYXNlZCBmcm9tXG4gICAgICAgICAgICAvLyBhbmQgYW55IG90aGVyIHRoYXQgd2VyZSBsb2dnZWQgaW4gdGhlIHNhbWUgbnMgYnV0IGJlZm9yZSB0aGUgcm93LiBSaWdodCBub3cgdGhlc2Ugcm93cyB3aWxsIGJlIGxvc3RcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhlIGFyZSBiZWZvcmUgYnV0IGNhbWUgaXQgaGUgcmVzcG9uc2UgdGhhdCBzaG91bGQgcmV0dXJuIG9ubHkgcm93cyBhZnRlci5cbiAgICAgICAgICAgIGZyb206IHRpbWVzdGFtcCxcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgdG8gbnMsIHdlIGxvb3NlIHNvbWUgcHJlY2lzaW9uIGhlcmUgYnV0IGl0IGlzIG5vdCB0aGF0IGltcG9ydGFudCBhdCB0aGUgZmFyIHBvaW50cyBvZiB0aGUgY29udGV4dFxuICAgICAgICAgICAgdG86IHRvVXRjKHJvdy50aW1lRXBvY2hNcyArIGNvbnRleHRUaW1lQnVmZmVyKSxcbiAgICAgICAgICB9XG4gICAgICAgIDoge1xuICAgICAgICAgICAgLy8gY29udmVydCB0byBucywgd2UgbG9vc2Ugc29tZSBwcmVjaXNpb24gaGVyZSBidXQgaXQgaXMgbm90IHRoYXQgaW1wb3J0YW50IGF0IHRoZSBmYXIgcG9pbnRzIG9mIHRoZSBjb250ZXh0XG4gICAgICAgICAgICBmcm9tOiB0b1V0Yyhyb3cudGltZUVwb2NoTXMgLSBjb250ZXh0VGltZUJ1ZmZlciksXG4gICAgICAgICAgICB0bzogdGltZXN0YW1wLFxuICAgICAgICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgcXVlcnksXG4gICAgICByYW5nZToge1xuICAgICAgICBmcm9tOiByYW5nZS5mcm9tLFxuICAgICAgICB0bzogcmFuZ2UudG8sXG4gICAgICAgIHJhdzogcmFuZ2UsXG4gICAgICB9LFxuICAgIH07XG4gIH07XG5cbiAgdGVzdERhdGFzb3VyY2UoKTogUHJvbWlzZTx7IHN0YXR1czogc3RyaW5nOyBtZXNzYWdlOiBzdHJpbmcgfT4ge1xuICAgIC8vIENvbnNpZGVyIG9ubHkgbGFzdCAxMCBtaW51dGVzIG90aGVyd2lzZSByZXF1ZXN0IHRha2VzIHRvbyBsb25nXG4gICAgY29uc3Qgbm93TXMgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgIHN0YXJ0OiAobm93TXMgLSAxMCAqIDYwICogMTAwMCkgKiBOU19JTl9NUyxcbiAgICAgIGVuZDogbm93TXMgKiBOU19JTl9NUyxcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMubWV0YWRhdGFSZXF1ZXN0KCdsYWJlbHMnLCBwYXJhbXMpLnRoZW4oXG4gICAgICAodmFsdWVzKSA9PiB7XG4gICAgICAgIHJldHVybiB2YWx1ZXMubGVuZ3RoID4gMFxuICAgICAgICAgID8geyBzdGF0dXM6ICdzdWNjZXNzJywgbWVzc2FnZTogJ0RhdGEgc291cmNlIGNvbm5lY3RlZCBhbmQgbGFiZWxzIGZvdW5kLicgfVxuICAgICAgICAgIDoge1xuICAgICAgICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6XG4gICAgICAgICAgICAgICAgJ0RhdGEgc291cmNlIGNvbm5lY3RlZCwgYnV0IG5vIGxhYmVscyByZWNlaXZlZC4gVmVyaWZ5IHRoYXQgTG9raSBhbmQgUHJvbXRhaWwgaXMgY29uZmlndXJlZCBwcm9wZXJseS4nLFxuICAgICAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICAoZXJyKSA9PiB7XG4gICAgICAgIC8vIHdlIGRpZCBhIHJlc291cmNlLWNhbGwgdGhhdCBmYWlsZWQuXG4gICAgICAgIC8vIHRoZSBvbmx5IGluZm8gd2UgaGF2ZSwgaWYgZXhpc3RzLCBpcyBlcnIuZGF0YS5tZXNzYWdlXG4gICAgICAgIC8vICh3aGVuIGluIGRldmVsb3BtZW50LW1vZGUsIGVyci5kYXRhLmVycm9yIGV4aXN0cyB0b28sIGJ1dCBub3QgaW4gcHJvZHVjdGlvbi1tb2RlKVxuICAgICAgICAvLyB0aGluZ3MgbGlrZSBlcnIuc3RhdHVzICYgZXJyLnN0YXR1c1RleHQgZG9lcyBub3QgaGVscCxcbiAgICAgICAgLy8gYmVjYXVzZSB0aG9zZSB3aWxsIG9ubHkgZGVzY3JpYmUgaG93IHRoZSByZXF1ZXN0IGJldHdlZW4gYnJvd3Nlcjw+c2VydmVyIGZhaWxlZFxuICAgICAgICBjb25zdCBpbmZvOiBzdHJpbmcgPSBlcnI/LmRhdGE/Lm1lc3NhZ2UgPz8gJyc7XG4gICAgICAgIGNvbnN0IGluZm9JblBhcmVudGhlc2VzID0gaW5mbyAhPT0gJycgPyBgICgke2luZm99KWAgOiAnJztcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBVbmFibGUgdG8gZmV0Y2ggbGFiZWxzIGZyb20gTG9raSR7aW5mb0luUGFyZW50aGVzZXN9LCBwbGVhc2UgY2hlY2sgdGhlIHNlcnZlciBsb2dzIGZvciBtb3JlIGRldGFpbHNgO1xuICAgICAgICByZXR1cm4geyBzdGF0dXM6ICdlcnJvcicsIG1lc3NhZ2U6IG1lc3NhZ2UgfTtcbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgYXN5bmMgYW5ub3RhdGlvblF1ZXJ5KG9wdGlvbnM6IGFueSk6IFByb21pc2U8QW5ub3RhdGlvbkV2ZW50W10+IHtcbiAgICBjb25zdCB7IGV4cHIsIG1heExpbmVzLCBpbnN0YW50LCB0YWdLZXlzID0gJycsIHRpdGxlRm9ybWF0ID0gJycsIHRleHRGb3JtYXQgPSAnJyB9ID0gb3B0aW9ucy5hbm5vdGF0aW9uO1xuXG4gICAgaWYgKCFleHByKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgaWQgPSBgYW5ub3RhdGlvbi0ke29wdGlvbnMuYW5ub3RhdGlvbi5uYW1lfWA7XG5cbiAgICBjb25zdCBxdWVyeTogTG9raVF1ZXJ5ID0ge1xuICAgICAgcmVmSWQ6IGlkLFxuICAgICAgZXhwcixcbiAgICAgIG1heExpbmVzLFxuICAgICAgaW5zdGFudCxcbiAgICAgIHF1ZXJ5VHlwZTogaW5zdGFudCA/IExva2lRdWVyeVR5cGUuSW5zdGFudCA6IExva2lRdWVyeVR5cGUuUmFuZ2UsXG4gICAgfTtcblxuICAgIGNvbnN0IHJlcXVlc3QgPSBtYWtlUmVxdWVzdChxdWVyeSwgb3B0aW9ucy5yYW5nZSwgQ29yZUFwcC5EYXNoYm9hcmQsIGlkKTtcblxuICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgbGFzdFZhbHVlRnJvbSh0aGlzLnF1ZXJ5KHJlcXVlc3QpKTtcblxuICAgIGNvbnN0IGFubm90YXRpb25zOiBBbm5vdGF0aW9uRXZlbnRbXSA9IFtdO1xuICAgIGNvbnN0IHNwbGl0S2V5czogc3RyaW5nW10gPSB0YWdLZXlzLnNwbGl0KCcsJykuZmlsdGVyKCh2OiBzdHJpbmcpID0+IHYgIT09ICcnKTtcblxuICAgIGZvciAoY29uc3QgZnJhbWUgb2YgZGF0YSkge1xuICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhRnJhbWVWaWV3PHsgdHM6IHN0cmluZzsgbGluZTogc3RyaW5nOyBsYWJlbHM6IExhYmVscyB9PihmcmFtZSk7XG5cbiAgICAgIHZpZXcuZm9yRWFjaCgocm93KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbGFiZWxzIH0gPSByb3c7XG5cbiAgICAgICAgY29uc3QgbWF5YmVEdXBsaWNhdGVkVGFncyA9IE9iamVjdC5lbnRyaWVzKGxhYmVscylcbiAgICAgICAgICAubWFwKChba2V5LCB2YWxdKSA9PiBba2V5LCB2YWwudHJpbSgpXSkgLy8gdHJpbSBhbGwgbGFiZWwtdmFsdWVzXG4gICAgICAgICAgLmZpbHRlcigoW2tleSwgdmFsXSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgLy8gcmVtb3ZlIGVtcHR5XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGFncyBhcmUgc3BlY2lmaWVkLCByZW1vdmUgbGFiZWwgaWYgZG9lcyBub3QgbWF0Y2ggdGFnc1xuICAgICAgICAgICAgaWYgKHNwbGl0S2V5cy5sZW5ndGggJiYgIXNwbGl0S2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAubWFwKChba2V5LCB2YWxdKSA9PiB2YWwpOyAvLyBrZWVwIG9ubHkgdGhlIGxhYmVsLXZhbHVlXG5cbiAgICAgICAgLy8gcmVtb3ZlIGR1cGxpY2F0ZXNcbiAgICAgICAgY29uc3QgdGFncyA9IEFycmF5LmZyb20obmV3IFNldChtYXliZUR1cGxpY2F0ZWRUYWdzKSk7XG5cbiAgICAgICAgYW5ub3RhdGlvbnMucHVzaCh7XG4gICAgICAgICAgdGltZTogbmV3IERhdGUocm93LnRzKS52YWx1ZU9mKCksXG4gICAgICAgICAgdGl0bGU6IHJlbmRlckxlZ2VuZEZvcm1hdCh0aXRsZUZvcm1hdCwgbGFiZWxzKSxcbiAgICAgICAgICB0ZXh0OiByZW5kZXJMZWdlbmRGb3JtYXQodGV4dEZvcm1hdCwgbGFiZWxzKSB8fCByb3cubGluZSxcbiAgICAgICAgICB0YWdzLFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBhbm5vdGF0aW9ucztcbiAgfVxuXG4gIHNob3dDb250ZXh0VG9nZ2xlKHJvdz86IExvZ1Jvd01vZGVsKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIChyb3cgJiYgcm93LnNlYXJjaFdvcmRzICYmIHJvdy5zZWFyY2hXb3Jkcy5sZW5ndGggPiAwKSA9PT0gdHJ1ZTtcbiAgfVxuXG4gIHByb2Nlc3NFcnJvcihlcnI6IEZldGNoRXJyb3IsIHRhcmdldDogTG9raVF1ZXJ5KSB7XG4gICAgbGV0IGVycm9yOiBEYXRhUXVlcnlFcnJvciA9IGNsb25lRGVlcChlcnIpO1xuICAgIGVycm9yLnJlZklkID0gdGFyZ2V0LnJlZklkO1xuXG4gICAgaWYgKGVycm9yLmRhdGEgJiYgZXJyLmRhdGEubWVzc2FnZS5pbmNsdWRlcygnZXNjYXBlJykgJiYgdGFyZ2V0LmV4cHIuaW5jbHVkZXMoJ1xcXFwnKSkge1xuICAgICAgZXJyb3IuZGF0YS5tZXNzYWdlID0gYEVycm9yOiAke2Vyci5kYXRhLm1lc3NhZ2V9LiBNYWtlIHN1cmUgdGhhdCBhbGwgc3BlY2lhbCBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkIHdpdGggXFxcXC4gRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gZXNjYXBpbmcgb2Ygc3BlY2lhbCBjaGFyYWN0ZXJzIHZpc2l0IExvZ1FMIGRvY3VtZW50YXRpb24gYXQgaHR0cHM6Ly9ncmFmYW5hLmNvbS9kb2NzL2xva2kvbGF0ZXN0L2xvZ3FsLy5gO1xuICAgIH1cblxuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuXG4gIGFkanVzdEludGVydmFsKGR5bmFtaWNJbnRlcnZhbDogbnVtYmVyLCByZXNvbHV0aW9uOiBudW1iZXIsIHJhbmdlOiBudW1iZXIpIHtcbiAgICAvLyBMb2tpIHdpbGwgZHJvcCBxdWVyaWVzIHRoYXQgbWlnaHQgcmV0dXJuIG1vcmUgdGhhbiAxMTAwMCBkYXRhIHBvaW50cy5cbiAgICAvLyBDYWxpYnJhdGUgaW50ZXJ2YWwgaWYgaXQgaXMgdG9vIHNtYWxsLlxuICAgIGxldCBzYWZlSW50ZXJ2YWwgPSByYW5nZSAvIDExMDAwO1xuICAgIGlmIChzYWZlSW50ZXJ2YWwgPiAxKSB7XG4gICAgICBzYWZlSW50ZXJ2YWwgPSBNYXRoLmNlaWwoc2FmZUludGVydmFsKTtcbiAgICB9XG5cbiAgICBsZXQgYWRqdXN0ZWRJbnRlcnZhbCA9IE1hdGgubWF4KHJlc29sdXRpb24gKiBkeW5hbWljSW50ZXJ2YWwsIHNhZmVJbnRlcnZhbCk7XG4gICAgcmV0dXJuIGFkanVzdGVkSW50ZXJ2YWw7XG4gIH1cblxuICBhZGRBZEhvY0ZpbHRlcnMocXVlcnlFeHByOiBzdHJpbmcpIHtcbiAgICBjb25zdCBhZGhvY0ZpbHRlcnMgPSB0aGlzLnRlbXBsYXRlU3J2LmdldEFkaG9jRmlsdGVycyh0aGlzLm5hbWUpO1xuICAgIGxldCBleHByID0gcXVlcnlFeHByO1xuXG4gICAgZXhwciA9IGFkaG9jRmlsdGVycy5yZWR1Y2UoKGFjYzogc3RyaW5nLCBmaWx0ZXI6IHsga2V5PzogYW55OyBvcGVyYXRvcj86IGFueTsgdmFsdWU/OiBhbnkgfSkgPT4ge1xuICAgICAgY29uc3QgeyBrZXksIG9wZXJhdG9yIH0gPSBmaWx0ZXI7XG4gICAgICBsZXQgeyB2YWx1ZSB9ID0gZmlsdGVyO1xuICAgICAgcmV0dXJuIHRoaXMuYWRkTGFiZWxUb1F1ZXJ5KGFjYywga2V5LCB2YWx1ZSwgb3BlcmF0b3IsIHRydWUpO1xuICAgIH0sIGV4cHIpO1xuXG4gICAgcmV0dXJuIGV4cHI7XG4gIH1cblxuICBhZGRMYWJlbFRvUXVlcnkoXG4gICAgcXVlcnlFeHByOiBzdHJpbmcsXG4gICAga2V5OiBzdHJpbmcsXG4gICAgdmFsdWU6IHN0cmluZyB8IG51bWJlcixcbiAgICBvcGVyYXRvcjogc3RyaW5nLFxuICAgIC8vIE92ZXJyaWRlIHRvIG1ha2Ugc3VyZSB0aGF0IHdlIHVzZSBsYWJlbCBhcyBhY3R1YWwgbGFiZWwgYW5kIG5vdCBwYXJzZWQgbGFiZWxcbiAgICBub3RQYXJzZWRMYWJlbE92ZXJyaWRlPzogYm9vbGVhblxuICApIHtcbiAgICBsZXQgZXNjYXBlZFZhbHVlID0gZXNjYXBlTGFiZWxWYWx1ZUluU2VsZWN0b3IodmFsdWUudG9TdHJpbmcoKSwgb3BlcmF0b3IpO1xuXG4gICAgaWYgKHF1ZXJ5SGFzUGlwZVBhcnNlcihxdWVyeUV4cHIpICYmICFpc01ldHJpY3NRdWVyeShxdWVyeUV4cHIpICYmICFub3RQYXJzZWRMYWJlbE92ZXJyaWRlKSB7XG4gICAgICAvLyBJZiBxdWVyeSBoYXMgcGFyc2VyLCB3ZSB0cmVhdCBhbGwgbGFiZWxzIGFzIHBhcnNlZCBhbmQgdXNlIHwga2V5PVwidmFsdWVcIiBzeW50YXhcbiAgICAgIHJldHVybiBhZGRQYXJzZWRMYWJlbFRvUXVlcnkocXVlcnlFeHByLCBrZXksIGVzY2FwZWRWYWx1ZSwgb3BlcmF0b3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYWRkTGFiZWxUb1F1ZXJ5KHF1ZXJ5RXhwciwga2V5LCBlc2NhcGVkVmFsdWUsIG9wZXJhdG9yLCB0cnVlKTtcbiAgICB9XG4gIH1cblxuICAvLyBVc2VkIHdoZW4gcnVubmluZyBxdWVyaWVzIHRocm91Z2ggYmFja2VuZFxuICBmaWx0ZXJRdWVyeShxdWVyeTogTG9raVF1ZXJ5KTogYm9vbGVhbiB7XG4gICAgaWYgKHF1ZXJ5LmhpZGUgfHwgcXVlcnkuZXhwciA9PT0gJycpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBVc2VkIHdoZW4gcnVubmluZyBxdWVyaWVzIHRocm91Z2ggYmFja2VuZFxuICBhcHBseVRlbXBsYXRlVmFyaWFibGVzKHRhcmdldDogTG9raVF1ZXJ5LCBzY29wZWRWYXJzOiBTY29wZWRWYXJzKTogTG9raVF1ZXJ5IHtcbiAgICAvLyBXZSB3YW50IHRvIGludGVycG9sYXRlIHRoZXNlIHZhcmlhYmxlcyBvbiBiYWNrZW5kXG4gICAgY29uc3QgeyBfX2ludGVydmFsLCBfX2ludGVydmFsX21zLCAuLi5yZXN0IH0gPSBzY29wZWRWYXJzO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRhcmdldCxcbiAgICAgIGxlZ2VuZEZvcm1hdDogdGhpcy50ZW1wbGF0ZVNydi5yZXBsYWNlKHRhcmdldC5sZWdlbmRGb3JtYXQsIHJlc3QpLFxuICAgICAgZXhwcjogdGhpcy50ZW1wbGF0ZVNydi5yZXBsYWNlKHRhcmdldC5leHByLCByZXN0LCB0aGlzLmludGVycG9sYXRlUXVlcnlFeHByKSxcbiAgICB9O1xuICB9XG5cbiAgaW50ZXJwb2xhdGVTdHJpbmcoc3RyaW5nOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy50ZW1wbGF0ZVNydi5yZXBsYWNlKHN0cmluZywgdW5kZWZpbmVkLCB0aGlzLmludGVycG9sYXRlUXVlcnlFeHByKTtcbiAgfVxuXG4gIGdldFZhcmlhYmxlcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMudGVtcGxhdGVTcnYuZ2V0VmFyaWFibGVzKCkubWFwKCh2KSA9PiBgJCR7di5uYW1lfWApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2tpUmVndWxhckVzY2FwZSh2YWx1ZTogYW55KSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoLycvZywgXCJcXFxcXFxcXCdcIik7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9raVNwZWNpYWxSZWdleEVzY2FwZSh2YWx1ZTogYW55KSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGxva2lSZWd1bGFyRXNjYXBlKHZhbHVlLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcXFxcXFxcXFwnKS5yZXBsYWNlKC9bJF4qe31cXFtcXF0rPy4oKXxdL2csICdcXFxcXFxcXCQmJykpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHF1ZXJ5IGV4cHJlc3Npb24gdXNlcyBmdW5jdGlvbiBhbmQgc28gc2hvdWxkIHJldHVybiBhIHRpbWUgc2VyaWVzIGluc3RlYWQgb2YgbG9ncy5cbiAqIFNvbWV0aW1lcyBpbXBvcnRhbnQgdG8ga25vdyB0aGF0IGJlZm9yZSB3ZSBhY3R1YWxseSBkbyB0aGUgcXVlcnkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc01ldHJpY3NRdWVyeShxdWVyeTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGlmICghcXVlcnkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgdG9rZW5zID0gUHJpc20udG9rZW5pemUocXVlcnksIHN5bnRheCk7XG4gIHJldHVybiB0b2tlbnMuc29tZSgodCkgPT4ge1xuICAgIC8vIE5vdCBzdXJlIGluIHdoaWNoIGNhc2VzIGl0IGNhbiBiZSBzdHJpbmcgbWF5YmUgaWYgbm90aGluZyBtYXRjaGVkIHdoaWNoIG1lYW5zIGl0IHNob3VsZCBub3QgYmUgYSBmdW5jdGlvblxuICAgIHJldHVybiB0eXBlb2YgdCAhPT0gJ3N0cmluZycgJiYgdC50eXBlID09PSAnZnVuY3Rpb24nO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdExldmVsKGRhdGFGcmFtZTogRGF0YUZyYW1lKTogTG9nTGV2ZWwge1xuICBsZXQgdmFsdWVGaWVsZDtcbiAgdHJ5IHtcbiAgICB2YWx1ZUZpZWxkID0gbmV3IEZpZWxkQ2FjaGUoZGF0YUZyYW1lKS5nZXRGaXJzdEZpZWxkT2ZUeXBlKEZpZWxkVHlwZS5udW1iZXIpO1xuICB9IGNhdGNoIHt9XG4gIHJldHVybiB2YWx1ZUZpZWxkPy5sYWJlbHMgPyBnZXRMb2dMZXZlbEZyb21MYWJlbHModmFsdWVGaWVsZC5sYWJlbHMpIDogTG9nTGV2ZWwudW5rbm93bjtcbn1cblxuZnVuY3Rpb24gZ2V0TG9nTGV2ZWxGcm9tTGFiZWxzKGxhYmVsczogTGFiZWxzKTogTG9nTGV2ZWwge1xuICBjb25zdCBsYWJlbE5hbWVzID0gWydsZXZlbCcsICdsdmwnLCAnbG9nbGV2ZWwnXTtcbiAgbGV0IGxldmVsTGFiZWw7XG4gIGZvciAobGV0IGxhYmVsTmFtZSBvZiBsYWJlbE5hbWVzKSB7XG4gICAgaWYgKGxhYmVsTmFtZSBpbiBsYWJlbHMpIHtcbiAgICAgIGxldmVsTGFiZWwgPSBsYWJlbE5hbWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxldmVsTGFiZWwgPyBnZXRMb2dMZXZlbEZyb21LZXkobGFiZWxzW2xldmVsTGFiZWxdKSA6IExvZ0xldmVsLnVua25vd247XG59XG4iLCJpbXBvcnQgeyBncm91cEJ5IH0gZnJvbSAnbG9kYXNoJztcblxuaW1wb3J0IHsgRmllbGRUeXBlLCBEYXRhRnJhbWUsIEFycmF5VmVjdG9yLCBEYXRhTGluaywgRmllbGQgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IGdldERhdGFTb3VyY2VTcnYgfSBmcm9tICdAZ3JhZmFuYS9ydW50aW1lJztcblxuaW1wb3J0IHsgRGVyaXZlZEZpZWxkQ29uZmlnIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREZXJpdmVkRmllbGRzKGRhdGFGcmFtZTogRGF0YUZyYW1lLCBkZXJpdmVkRmllbGRDb25maWdzOiBEZXJpdmVkRmllbGRDb25maWdbXSk6IEZpZWxkW10ge1xuICBpZiAoIWRlcml2ZWRGaWVsZENvbmZpZ3MubGVuZ3RoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGNvbnN0IGRlcml2ZWRGaWVsZHNHcm91cGVkID0gZ3JvdXBCeShkZXJpdmVkRmllbGRDb25maWdzLCAnbmFtZScpO1xuXG4gIGNvbnN0IG5ld0ZpZWxkcyA9IE9iamVjdC52YWx1ZXMoZGVyaXZlZEZpZWxkc0dyb3VwZWQpLm1hcChmaWVsZEZyb21EZXJpdmVkRmllbGRDb25maWcpO1xuXG4gIC8vIGxpbmUtZmllbGQgaXMgdGhlIGZpcnN0IHN0cmluZy1maWVsZFxuICAvLyBOT1RFOiB3ZSBzaG91bGQgY3JlYXRlIHNvbWUgY29tbW9uIGxvZy1mcmFtZS1leHRyYS1zdHJpbmctZmllbGQgY29kZSBzb21ld2hlcmVcbiAgY29uc3QgbGluZUZpZWxkID0gZGF0YUZyYW1lLmZpZWxkcy5maW5kKChmKSA9PiBmLnR5cGUgPT09IEZpZWxkVHlwZS5zdHJpbmcpO1xuXG4gIGlmIChsaW5lRmllbGQgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGlmIHRoaXMgaXMgaGFwcGVuaW5nLCBzb21ldGhpbmcgd2VudCB3cm9uZywgbGV0J3MgcmFpc2UgYW4gZXJyb3JcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgbG9ncy1kYXRhZnJhbWUsIHN0cmluZy1maWVsZCBtaXNzaW5nJyk7XG4gIH1cblxuICBsaW5lRmllbGQudmFsdWVzLnRvQXJyYXkoKS5mb3JFYWNoKChsaW5lKSA9PiB7XG4gICAgZm9yIChjb25zdCBmaWVsZCBvZiBuZXdGaWVsZHMpIHtcbiAgICAgIGNvbnN0IGxvZ01hdGNoID0gbGluZS5tYXRjaChkZXJpdmVkRmllbGRzR3JvdXBlZFtmaWVsZC5uYW1lXVswXS5tYXRjaGVyUmVnZXgpO1xuICAgICAgZmllbGQudmFsdWVzLmFkZChsb2dNYXRjaCAmJiBsb2dNYXRjaFsxXSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gbmV3RmllbGRzO1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBkZXJpdmVkRmllbGQgY29uZmlnIGludG8gZGF0YWZyYW1lIGZpZWxkIHdpdGggY29uZmlnIHRoYXQgY29udGFpbnMgbGluay5cbiAqL1xuZnVuY3Rpb24gZmllbGRGcm9tRGVyaXZlZEZpZWxkQ29uZmlnKGRlcml2ZWRGaWVsZENvbmZpZ3M6IERlcml2ZWRGaWVsZENvbmZpZ1tdKTogRmllbGQ8YW55LCBBcnJheVZlY3Rvcj4ge1xuICBjb25zdCBkYXRhU291cmNlU3J2ID0gZ2V0RGF0YVNvdXJjZVNydigpO1xuXG4gIGNvbnN0IGRhdGFMaW5rcyA9IGRlcml2ZWRGaWVsZENvbmZpZ3MucmVkdWNlKChhY2MsIGRlcml2ZWRGaWVsZENvbmZpZykgPT4ge1xuICAgIC8vIEhhdmluZyBmaWVsZC5kYXRhc291cmNlVWlkIG1lYW5zIGl0IGlzIGFuIGludGVybmFsIGxpbmsuXG4gICAgaWYgKGRlcml2ZWRGaWVsZENvbmZpZy5kYXRhc291cmNlVWlkKSB7XG4gICAgICBjb25zdCBkc1NldHRpbmdzID0gZGF0YVNvdXJjZVNydi5nZXRJbnN0YW5jZVNldHRpbmdzKGRlcml2ZWRGaWVsZENvbmZpZy5kYXRhc291cmNlVWlkKTtcblxuICAgICAgYWNjLnB1c2goe1xuICAgICAgICAvLyBXaWxsIGJlIGZpbGxlZCBvdXQgbGF0ZXJcbiAgICAgICAgdGl0bGU6IGRlcml2ZWRGaWVsZENvbmZpZy51cmxEaXNwbGF5TGFiZWwgfHwgJycsXG4gICAgICAgIHVybDogJycsXG4gICAgICAgIC8vIFRoaXMgaXMgaGFyZGNvZGVkIGZvciBKYWVnZXIgb3IgWmlwa2luIG5vdCB3YXkgcmlnaHQgbm93IHRvIHNwZWNpZnkgZGF0YXNvdXJjZSBzcGVjaWZpYyBxdWVyeSBvYmplY3RcbiAgICAgICAgaW50ZXJuYWw6IHtcbiAgICAgICAgICBxdWVyeTogeyBxdWVyeTogZGVyaXZlZEZpZWxkQ29uZmlnLnVybCB9LFxuICAgICAgICAgIGRhdGFzb3VyY2VVaWQ6IGRlcml2ZWRGaWVsZENvbmZpZy5kYXRhc291cmNlVWlkLFxuICAgICAgICAgIGRhdGFzb3VyY2VOYW1lOiBkc1NldHRpbmdzPy5uYW1lID8/ICdEYXRhIHNvdXJjZSBub3QgZm91bmQnLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChkZXJpdmVkRmllbGRDb25maWcudXJsKSB7XG4gICAgICBhY2MucHVzaCh7XG4gICAgICAgIC8vIFdlIGRvIG5vdCBrbm93IHdoYXQgdGl0bGUgdG8gZ2l2ZSBoZXJlIHNvIHdlIGNvdW50IG9uIHByZXNlbnRhdGlvbiBsYXllciB0byBjcmVhdGUgYSB0aXRsZSBmcm9tIG1ldGFkYXRhLlxuICAgICAgICB0aXRsZTogZGVyaXZlZEZpZWxkQ29uZmlnLnVybERpc3BsYXlMYWJlbCB8fCAnJyxcbiAgICAgICAgLy8gVGhpcyBpcyBoYXJkY29kZWQgZm9yIEphZWdlciBvciBaaXBraW4gbm90IHdheSByaWdodCBub3cgdG8gc3BlY2lmeSBkYXRhc291cmNlIHNwZWNpZmljIHF1ZXJ5IG9iamVjdFxuICAgICAgICB1cmw6IGRlcml2ZWRGaWVsZENvbmZpZy51cmwsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFjYztcbiAgfSwgW10gYXMgRGF0YUxpbmtbXSk7XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBkZXJpdmVkRmllbGRDb25maWdzWzBdLm5hbWUsXG4gICAgdHlwZTogRmllbGRUeXBlLnN0cmluZyxcbiAgICBjb25maWc6IHtcbiAgICAgIGxpbmtzOiBkYXRhTGlua3MsXG4gICAgfSxcbiAgICAvLyBXZSBhcmUgYWRkaW5nIHZhbHVlcyBsYXRlciBvblxuICAgIHZhbHVlczogbmV3IEFycmF5VmVjdG9yPHN0cmluZz4oW10pLFxuICB9O1xufVxuIiwiaW1wb3J0IHsgY2hhaW4sIGRpZmZlcmVuY2UgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IExSVSBmcm9tICdscnUtY2FjaGUnO1xuaW1wb3J0IFByaXNtLCB7IEdyYW1tYXIgfSBmcm9tICdwcmlzbWpzJztcblxuaW1wb3J0IHsgZGF0ZVRpbWUsIEFic29sdXRlVGltZVJhbmdlLCBMYW5ndWFnZVByb3ZpZGVyLCBIaXN0b3J5SXRlbSwgQWJzdHJhY3RRdWVyeSB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgQ29tcGxldGlvbkl0ZW0sIFR5cGVhaGVhZElucHV0LCBUeXBlYWhlYWRPdXRwdXQsIENvbXBsZXRpb25JdGVtR3JvdXAgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5pbXBvcnQge1xuICBleHRyYWN0TGFiZWxNYXRjaGVycyxcbiAgcGFyc2VTZWxlY3RvcixcbiAgcHJvY2Vzc0xhYmVscyxcbiAgdG9Qcm9tTGlrZUV4cHIsXG59IGZyb20gJ2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9sYW5ndWFnZV91dGlscyc7XG5cbmltcG9ydCB7IExva2lEYXRhc291cmNlIH0gZnJvbSAnLi9kYXRhc291cmNlJztcbmltcG9ydCBzeW50YXgsIHsgRlVOQ1RJT05TLCBQSVBFX1BBUlNFUlMsIFBJUEVfT1BFUkFUT1JTIH0gZnJvbSAnLi9zeW50YXgnO1xuaW1wb3J0IHsgTG9raVF1ZXJ5LCBMb2tpUXVlcnlUeXBlIH0gZnJvbSAnLi90eXBlcyc7XG5cbmNvbnN0IERFRkFVTFRfS0VZUyA9IFsnam9iJywgJ25hbWVzcGFjZSddO1xuY29uc3QgRU1QVFlfU0VMRUNUT1IgPSAne30nO1xuY29uc3QgSElTVE9SWV9JVEVNX0NPVU5UID0gMTA7XG5jb25zdCBISVNUT1JZX0NPVU5UX0NVVE9GRiA9IDEwMDAgKiA2MCAqIDYwICogMjQ7IC8vIDI0aFxuY29uc3QgTlNfSU5fTVMgPSAxMDAwMDAwO1xuXG4vLyBXaGVuIGNoYW5naW5nIFJBVEVfUkFOR0VTLCBjaGVjayBpZiBQcm9tZXRoZXVzL1Byb21RTCByYW5nZXMgc2hvdWxkIGJlIGNoYW5nZWQgdG9vXG4vLyBAc2VlIHB1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcHJvbXFsLnRzXG5jb25zdCBSQVRFX1JBTkdFUzogQ29tcGxldGlvbkl0ZW1bXSA9IFtcbiAgeyBsYWJlbDogJyRfX2ludGVydmFsJywgc29ydFZhbHVlOiAnJF9faW50ZXJ2YWwnIH0sXG4gIHsgbGFiZWw6ICckX19yYW5nZScsIHNvcnRWYWx1ZTogJyRfX3JhbmdlJyB9LFxuICB7IGxhYmVsOiAnMW0nLCBzb3J0VmFsdWU6ICcwMDowMTowMCcgfSxcbiAgeyBsYWJlbDogJzVtJywgc29ydFZhbHVlOiAnMDA6MDU6MDAnIH0sXG4gIHsgbGFiZWw6ICcxMG0nLCBzb3J0VmFsdWU6ICcwMDoxMDowMCcgfSxcbiAgeyBsYWJlbDogJzMwbScsIHNvcnRWYWx1ZTogJzAwOjMwOjAwJyB9LFxuICB7IGxhYmVsOiAnMWgnLCBzb3J0VmFsdWU6ICcwMTowMDowMCcgfSxcbiAgeyBsYWJlbDogJzFkJywgc29ydFZhbHVlOiAnMjQ6MDA6MDAnIH0sXG5dO1xuXG5leHBvcnQgY29uc3QgTEFCRUxfUkVGUkVTSF9JTlRFUlZBTCA9IDEwMDAgKiAzMDsgLy8gMzBzZWNcblxuY29uc3Qgd3JhcExhYmVsID0gKGxhYmVsOiBzdHJpbmcpID0+ICh7IGxhYmVsLCBmaWx0ZXJUZXh0OiBgXFxcIiR7bGFiZWx9XFxcImAgfSk7XG5cbmV4cG9ydCB0eXBlIExva2lIaXN0b3J5SXRlbSA9IEhpc3RvcnlJdGVtPExva2lRdWVyeT47XG5cbnR5cGUgVHlwZWFoZWFkQ29udGV4dCA9IHtcbiAgaGlzdG9yeT86IExva2lIaXN0b3J5SXRlbVtdO1xuICBhYnNvbHV0ZVJhbmdlPzogQWJzb2x1dGVUaW1lUmFuZ2U7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkSGlzdG9yeU1ldGFkYXRhKGl0ZW06IENvbXBsZXRpb25JdGVtLCBoaXN0b3J5OiBMb2tpSGlzdG9yeUl0ZW1bXSk6IENvbXBsZXRpb25JdGVtIHtcbiAgY29uc3QgY3V0b2ZmVHMgPSBEYXRlLm5vdygpIC0gSElTVE9SWV9DT1VOVF9DVVRPRkY7XG4gIGNvbnN0IGhpc3RvcnlGb3JJdGVtID0gaGlzdG9yeS5maWx0ZXIoKGgpID0+IGgudHMgPiBjdXRvZmZUcyAmJiBoLnF1ZXJ5LmV4cHIgPT09IGl0ZW0ubGFiZWwpO1xuICBsZXQgaGludCA9IGBRdWVyaWVkICR7aGlzdG9yeUZvckl0ZW0ubGVuZ3RofSB0aW1lcyBpbiB0aGUgbGFzdCAyNGguYDtcbiAgY29uc3QgcmVjZW50ID0gaGlzdG9yeUZvckl0ZW1bMF07XG5cbiAgaWYgKHJlY2VudCkge1xuICAgIGNvbnN0IGxhc3RRdWVyaWVkID0gZGF0ZVRpbWUocmVjZW50LnRzKS5mcm9tTm93KCk7XG4gICAgaGludCA9IGAke2hpbnR9IExhc3QgcXVlcmllZCAke2xhc3RRdWVyaWVkfS5gO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5pdGVtLFxuICAgIGRvY3VtZW50YXRpb246IGhpbnQsXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExva2lMYW5ndWFnZVByb3ZpZGVyIGV4dGVuZHMgTGFuZ3VhZ2VQcm92aWRlciB7XG4gIGxhYmVsS2V5czogc3RyaW5nW107XG4gIGxhYmVsRmV0Y2hUczogbnVtYmVyO1xuICBzdGFydGVkID0gZmFsc2U7XG4gIGRhdGFzb3VyY2U6IExva2lEYXRhc291cmNlO1xuICBsb29rdXBzRGlzYWJsZWQgPSBmYWxzZTsgLy8gRHluYW1pY2FsbHkgc2V0IHRvIHRydWUgZm9yIGJpZy9zbG93IGluc3RhbmNlc1xuXG4gIC8qKlxuICAgKiAgQ2FjaGUgZm9yIGxhYmVscyBvZiBzZXJpZXMuIFRoaXMgaXMgYml0IHNpbXBsaXN0aWMgaW4gdGhlIHNlbnNlIHRoYXQgaXQganVzdCBjb3VudHMgcmVzcG9uc2VzIGVhY2ggYXMgYSAxIGFuZCBkb2VzXG4gICAqICBub3QgYWNjb3VudCBmb3IgZGlmZmVyZW50IHNpemUgb2YgYSByZXNwb25zZS4gSWYgdGhhdCBpcyBuZWVkZWQgYSBgbGVuZ3RoYCBmdW5jdGlvbiBjYW4gYmUgYWRkZWQgaW4gdGhlIG9wdGlvbnMuXG4gICAqICAxMCBhcyBhIG1heCBzaXplIGlzIHRvdGFsbHkgYXJiaXRyYXJ5IHJpZ2h0IG5vdy5cbiAgICovXG4gIHByaXZhdGUgc2VyaWVzQ2FjaGUgPSBuZXcgTFJVPHN0cmluZywgUmVjb3JkPHN0cmluZywgc3RyaW5nW10+Pih7IG1heDogMTAgfSk7XG4gIHByaXZhdGUgbGFiZWxzQ2FjaGUgPSBuZXcgTFJVPHN0cmluZywgc3RyaW5nW10+KHsgbWF4OiAxMCB9KTtcblxuICBjb25zdHJ1Y3RvcihkYXRhc291cmNlOiBMb2tpRGF0YXNvdXJjZSwgaW5pdGlhbFZhbHVlcz86IGFueSkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmRhdGFzb3VyY2UgPSBkYXRhc291cmNlO1xuICAgIHRoaXMubGFiZWxLZXlzID0gW107XG4gICAgdGhpcy5sYWJlbEZldGNoVHMgPSAwO1xuXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBpbml0aWFsVmFsdWVzKTtcbiAgfVxuXG4gIC8vIFN0cmlwIHN5bnRheCBjaGFyc1xuICBjbGVhblRleHQgPSAoczogc3RyaW5nKSA9PiBzLnJlcGxhY2UoL1t7fVtcXF09XCIoKSwhfitcXC0qL14lXFx8XS9nLCAnJykudHJpbSgpO1xuXG4gIGdldFN5bnRheCgpOiBHcmFtbWFyIHtcbiAgICByZXR1cm4gc3ludGF4O1xuICB9XG5cbiAgcmVxdWVzdCA9IGFzeW5jICh1cmw6IHN0cmluZywgcGFyYW1zPzogYW55KTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZGF0YXNvdXJjZS5tZXRhZGF0YVJlcXVlc3QodXJsLCBwYXJhbXMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXNlIHRoZSBsYW5ndWFnZSBwcm92aWRlciBieSBmZXRjaGluZyBzZXQgb2YgbGFiZWxzLiBXaXRob3V0IHRoaXMgaW5pdGlhbGlzYXRpb24gdGhlIHByb3ZpZGVyIHdvdWxkIHJldHVyblxuICAgKiBqdXN0IGEgc2V0IG9mIGhhcmRjb2RlZCBkZWZhdWx0IGxhYmVscyBvbiBwcm92aWRlQ29tcGxldGlvbkl0ZW1zIG9yIGEgcmVjZW50IHF1ZXJpZXMgZnJvbSBoaXN0b3J5LlxuICAgKi9cbiAgc3RhcnQgPSAoKSA9PiB7XG4gICAgaWYgKCF0aGlzLnN0YXJ0VGFzaykge1xuICAgICAgdGhpcy5zdGFydFRhc2sgPSB0aGlzLmZldGNoTGFiZWxzKCkudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0YXJ0VGFzaztcbiAgfTtcblxuICBnZXRMYWJlbEtleXMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiB0aGlzLmxhYmVsS2V5cztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gc3VnZ2VzdGlvbnMgYmFzZWQgb24gaW5wdXQgdGhhdCBjYW4gYmUgdGhlbiBwbHVnZ2VkIGludG8gYSB0eXBlYWhlYWQgZHJvcGRvd24uXG4gICAqIEtlZXAgdGhpcyBET00tZnJlZSBmb3IgdGVzdGluZ1xuICAgKiBAcGFyYW0gaW5wdXRcbiAgICogQHBhcmFtIGNvbnRleHQgSXMgb3B0aW9uYWwgaW4gdHlwZXMgYnV0IGlzIHJlcXVpcmVkIGluIGNhc2Ugd2UgYXJlIGRvaW5nIGdldExhYmVsQ29tcGxldGlvbkl0ZW1zXG4gICAqIEBwYXJhbSBjb250ZXh0LmFic29sdXRlUmFuZ2UgUmVxdWlyZWQgaW4gY2FzZSB3ZSBhcmUgZG9pbmcgZ2V0TGFiZWxDb21wbGV0aW9uSXRlbXNcbiAgICogQHBhcmFtIGNvbnRleHQuaGlzdG9yeSBPcHRpb25hbCB1c2VkIG9ubHkgaW4gZ2V0RW1wdHlDb21wbGV0aW9uSXRlbXNcbiAgICovXG4gIGFzeW5jIHByb3ZpZGVDb21wbGV0aW9uSXRlbXMoaW5wdXQ6IFR5cGVhaGVhZElucHV0LCBjb250ZXh0PzogVHlwZWFoZWFkQ29udGV4dCk6IFByb21pc2U8VHlwZWFoZWFkT3V0cHV0PiB7XG4gICAgY29uc3QgeyB3cmFwcGVyQ2xhc3NlcywgdmFsdWUsIHByZWZpeCwgdGV4dCB9ID0gaW5wdXQ7XG4gICAgY29uc3QgZW1wdHlSZXN1bHQ6IFR5cGVhaGVhZE91dHB1dCA9IHsgc3VnZ2VzdGlvbnM6IFtdIH07XG5cbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4gZW1wdHlSZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gTG9jYWwgdGV4dCBwcm9wZXJ0aWVzXG4gICAgY29uc3QgZW1wdHkgPSB2YWx1ZT8uZG9jdW1lbnQudGV4dC5sZW5ndGggPT09IDA7XG4gICAgY29uc3Qgc2VsZWN0ZWRMaW5lcyA9IHZhbHVlLmRvY3VtZW50LmdldFRleHRzQXRSYW5nZSh2YWx1ZS5zZWxlY3Rpb24pO1xuICAgIGNvbnN0IGN1cnJlbnRMaW5lID0gc2VsZWN0ZWRMaW5lcy5zaXplID09PSAxID8gc2VsZWN0ZWRMaW5lcy5maXJzdCgpLmdldFRleHQoKSA6IG51bGw7XG5cbiAgICBjb25zdCBuZXh0Q2hhcmFjdGVyID0gY3VycmVudExpbmUgPyBjdXJyZW50TGluZVt2YWx1ZS5zZWxlY3Rpb24uYW5jaG9yLm9mZnNldF0gOiBudWxsO1xuXG4gICAgLy8gU3ludGF4IHNwYW5zIGhhdmUgMyBjbGFzc2VzIGJ5IGRlZmF1bHQuIE1vcmUgaW5kaWNhdGUgYSByZWNvZ25pemVkIHRva2VuXG4gICAgY29uc3QgdG9rZW5SZWNvZ25pemVkID0gd3JhcHBlckNsYXNzZXMubGVuZ3RoID4gMztcblxuICAgIC8vIE5vbi1lbXB0eSBwcmVmaXgsIGJ1dCBub3QgaW5zaWRlIGtub3duIHRva2VuXG4gICAgY29uc3QgcHJlZml4VW5yZWNvZ25pemVkID0gcHJlZml4ICYmICF0b2tlblJlY29nbml6ZWQ7XG5cbiAgICAvLyBQcmV2ZW50IHN1Z2dlc3Rpb25zIGluIGBmdW5jdGlvbih8c3VmZml4KWBcbiAgICBjb25zdCBub1N1ZmZpeCA9ICFuZXh0Q2hhcmFjdGVyIHx8IG5leHRDaGFyYWN0ZXIgPT09ICcpJztcblxuICAgIC8vIFByZWZpeCBpcyBzYWZlIGlmIGl0IGRvZXMgbm90IGltbWVkaWF0ZWx5IGZvbGxvdyBhIGNvbXBsZXRlIGV4cHJlc3Npb24gYW5kIGhhcyBubyB0ZXh0IGFmdGVyIGl0XG4gICAgY29uc3Qgc2FmZVByZWZpeCA9IHByZWZpeCAmJiAhdGV4dC5tYXRjaCgvXlsnXCJ+PVxcXX0pXFxzXSskLykgJiYgbm9TdWZmaXg7XG5cbiAgICAvLyBBYm91dCB0byB0eXBlIG5leHQgb3BlcmFuZCBpZiBwcmVjZWRlZCBieSBiaW5hcnkgb3BlcmF0b3JcbiAgICBjb25zdCBvcGVyYXRvcnNQYXR0ZXJuID0gL1srXFwtKi9eJV0vO1xuICAgIGNvbnN0IGlzTmV4dE9wZXJhbmQgPSB0ZXh0Lm1hdGNoKG9wZXJhdG9yc1BhdHRlcm4pO1xuXG4gICAgLy8gRGV0ZXJtaW5lIGNhbmRpZGF0ZXMgYnkgQ1NTIGNvbnRleHRcbiAgICBpZiAod3JhcHBlckNsYXNzZXMuaW5jbHVkZXMoJ2NvbnRleHQtcmFuZ2UnKSkge1xuICAgICAgLy8gU3VnZ2VzdGlvbnMgZm9yIG1ldHJpY1t8XVxuICAgICAgcmV0dXJuIHRoaXMuZ2V0UmFuZ2VDb21wbGV0aW9uSXRlbXMoKTtcbiAgICB9IGVsc2UgaWYgKHdyYXBwZXJDbGFzc2VzLmluY2x1ZGVzKCdjb250ZXh0LWxhYmVscycpKSB7XG4gICAgICAvLyBTdWdnZXN0aW9ucyBmb3Ige3x9IGFuZCB7Zm9vPXx9XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRMYWJlbENvbXBsZXRpb25JdGVtcyhpbnB1dCk7XG4gICAgfSBlbHNlIGlmICh3cmFwcGVyQ2xhc3Nlcy5pbmNsdWRlcygnY29udGV4dC1waXBlJykpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFBpcGVDb21wbGV0aW9uSXRlbSgpO1xuICAgIH0gZWxzZSBpZiAoZW1wdHkpIHtcbiAgICAgIC8vIFN1Z2dlc3Rpb25zIGZvciBlbXB0eSBxdWVyeSBmaWVsZFxuICAgICAgcmV0dXJuIHRoaXMuZ2V0RW1wdHlDb21wbGV0aW9uSXRlbXMoY29udGV4dCk7XG4gICAgfSBlbHNlIGlmIChwcmVmaXhVbnJlY29nbml6ZWQgJiYgbm9TdWZmaXggJiYgIWlzTmV4dE9wZXJhbmQpIHtcbiAgICAgIC8vIFNob3cgdGVybSBzdWdnZXN0aW9ucyBpbiBhIGNvdXBsZSBvZiBzY2VuYXJpb3NcbiAgICAgIHJldHVybiB0aGlzLmdldEJlZ2lubmluZ0NvbXBsZXRpb25JdGVtcyhjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKHByZWZpeFVucmVjb2duaXplZCAmJiBzYWZlUHJlZml4KSB7XG4gICAgICAvLyBTaG93IHRlcm0gc3VnZ2VzdGlvbnMgaW4gYSBjb3VwbGUgb2Ygc2NlbmFyaW9zXG4gICAgICByZXR1cm4gdGhpcy5nZXRUZXJtQ29tcGxldGlvbkl0ZW1zKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVtcHR5UmVzdWx0O1xuICB9XG5cbiAgZ2V0QmVnaW5uaW5nQ29tcGxldGlvbkl0ZW1zID0gKGNvbnRleHQ/OiBUeXBlYWhlYWRDb250ZXh0KTogVHlwZWFoZWFkT3V0cHV0ID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgc3VnZ2VzdGlvbnM6IFsuLi50aGlzLmdldEVtcHR5Q29tcGxldGlvbkl0ZW1zKGNvbnRleHQpLnN1Z2dlc3Rpb25zLCAuLi50aGlzLmdldFRlcm1Db21wbGV0aW9uSXRlbXMoKS5zdWdnZXN0aW9uc10sXG4gICAgfTtcbiAgfTtcblxuICBnZXRFbXB0eUNvbXBsZXRpb25JdGVtcyhjb250ZXh0PzogVHlwZWFoZWFkQ29udGV4dCk6IFR5cGVhaGVhZE91dHB1dCB7XG4gICAgY29uc3QgaGlzdG9yeSA9IGNvbnRleHQ/Lmhpc3Rvcnk7XG4gICAgY29uc3Qgc3VnZ2VzdGlvbnMgPSBbXTtcblxuICAgIGlmIChoaXN0b3J5Py5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGhpc3RvcnlJdGVtcyA9IGNoYWluKGhpc3RvcnkpXG4gICAgICAgIC5tYXAoKGgpID0+IGgucXVlcnkuZXhwcilcbiAgICAgICAgLmZpbHRlcigpXG4gICAgICAgIC51bmlxKClcbiAgICAgICAgLnRha2UoSElTVE9SWV9JVEVNX0NPVU5UKVxuICAgICAgICAubWFwKHdyYXBMYWJlbClcbiAgICAgICAgLm1hcCgoaXRlbSkgPT4gYWRkSGlzdG9yeU1ldGFkYXRhKGl0ZW0sIGhpc3RvcnkpKVxuICAgICAgICAudmFsdWUoKTtcblxuICAgICAgc3VnZ2VzdGlvbnMucHVzaCh7XG4gICAgICAgIHByZWZpeE1hdGNoOiB0cnVlLFxuICAgICAgICBza2lwU29ydDogdHJ1ZSxcbiAgICAgICAgbGFiZWw6ICdIaXN0b3J5JyxcbiAgICAgICAgaXRlbXM6IGhpc3RvcnlJdGVtcyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB7IHN1Z2dlc3Rpb25zIH07XG4gIH1cblxuICBnZXRUZXJtQ29tcGxldGlvbkl0ZW1zID0gKCk6IFR5cGVhaGVhZE91dHB1dCA9PiB7XG4gICAgY29uc3Qgc3VnZ2VzdGlvbnMgPSBbXTtcblxuICAgIHN1Z2dlc3Rpb25zLnB1c2goe1xuICAgICAgcHJlZml4TWF0Y2g6IHRydWUsXG4gICAgICBsYWJlbDogJ0Z1bmN0aW9ucycsXG4gICAgICBpdGVtczogRlVOQ1RJT05TLm1hcCgoc3VnZ2VzdGlvbikgPT4gKHsgLi4uc3VnZ2VzdGlvbiwga2luZDogJ2Z1bmN0aW9uJyB9KSksXG4gICAgfSk7XG5cbiAgICByZXR1cm4geyBzdWdnZXN0aW9ucyB9O1xuICB9O1xuXG4gIGdldFBpcGVDb21wbGV0aW9uSXRlbSA9ICgpOiBUeXBlYWhlYWRPdXRwdXQgPT4ge1xuICAgIGNvbnN0IHN1Z2dlc3Rpb25zID0gW107XG5cbiAgICBzdWdnZXN0aW9ucy5wdXNoKHtcbiAgICAgIGxhYmVsOiAnT3BlcmF0b3JzJyxcbiAgICAgIGl0ZW1zOiBQSVBFX09QRVJBVE9SUy5tYXAoKHN1Z2dlc3Rpb24pID0+ICh7IC4uLnN1Z2dlc3Rpb24sIGtpbmQ6ICdvcGVyYXRvcnMnIH0pKSxcbiAgICB9KTtcblxuICAgIHN1Z2dlc3Rpb25zLnB1c2goe1xuICAgICAgbGFiZWw6ICdQYXJzZXJzJyxcbiAgICAgIGl0ZW1zOiBQSVBFX1BBUlNFUlMubWFwKChzdWdnZXN0aW9uKSA9PiAoeyAuLi5zdWdnZXN0aW9uLCBraW5kOiAncGFyc2VycycgfSkpLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHsgc3VnZ2VzdGlvbnMgfTtcbiAgfTtcblxuICBnZXRSYW5nZUNvbXBsZXRpb25JdGVtcygpOiBUeXBlYWhlYWRPdXRwdXQge1xuICAgIHJldHVybiB7XG4gICAgICBjb250ZXh0OiAnY29udGV4dC1yYW5nZScsXG4gICAgICBzdWdnZXN0aW9uczogW1xuICAgICAgICB7XG4gICAgICAgICAgbGFiZWw6ICdSYW5nZSB2ZWN0b3InLFxuICAgICAgICAgIGl0ZW1zOiBbLi4uUkFURV9SQU5HRVNdLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICB9O1xuICB9XG5cbiAgYXN5bmMgZ2V0TGFiZWxDb21wbGV0aW9uSXRlbXMoeyB0ZXh0LCB3cmFwcGVyQ2xhc3NlcywgbGFiZWxLZXksIHZhbHVlIH06IFR5cGVhaGVhZElucHV0KTogUHJvbWlzZTxUeXBlYWhlYWRPdXRwdXQ+IHtcbiAgICBsZXQgY29udGV4dCA9ICdjb250ZXh0LWxhYmVscyc7XG4gICAgY29uc3Qgc3VnZ2VzdGlvbnM6IENvbXBsZXRpb25JdGVtR3JvdXBbXSA9IFtdO1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybiB7IGNvbnRleHQsIHN1Z2dlc3Rpb25zOiBbXSB9O1xuICAgIH1cbiAgICBjb25zdCBsaW5lID0gdmFsdWUuYW5jaG9yQmxvY2suZ2V0VGV4dCgpO1xuICAgIGNvbnN0IGN1cnNvck9mZnNldCA9IHZhbHVlLnNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0O1xuICAgIGNvbnN0IGlzVmFsdWVTdGFydCA9IHRleHQubWF0Y2goL14oPXw9fnwhPXwhfikvKTtcblxuICAgIC8vIEdldCBub3JtYWxpemVkIHNlbGVjdG9yXG4gICAgbGV0IHNlbGVjdG9yO1xuICAgIGxldCBwYXJzZWRTZWxlY3RvcjtcbiAgICB0cnkge1xuICAgICAgcGFyc2VkU2VsZWN0b3IgPSBwYXJzZVNlbGVjdG9yKGxpbmUsIGN1cnNvck9mZnNldCk7XG4gICAgICBzZWxlY3RvciA9IHBhcnNlZFNlbGVjdG9yLnNlbGVjdG9yO1xuICAgIH0gY2F0Y2gge1xuICAgICAgc2VsZWN0b3IgPSBFTVBUWV9TRUxFQ1RPUjtcbiAgICB9XG5cbiAgICBpZiAoIWxhYmVsS2V5ICYmIHNlbGVjdG9yID09PSBFTVBUWV9TRUxFQ1RPUikge1xuICAgICAgLy8gc3RhcnQgdGFzayBnZXRzIGFsbCBsYWJlbHNcbiAgICAgIGF3YWl0IHRoaXMuc3RhcnQoKTtcbiAgICAgIGNvbnN0IGFsbExhYmVscyA9IHRoaXMuZ2V0TGFiZWxLZXlzKCk7XG4gICAgICByZXR1cm4geyBjb250ZXh0LCBzdWdnZXN0aW9uczogW3sgbGFiZWw6IGBMYWJlbHNgLCBpdGVtczogYWxsTGFiZWxzLm1hcCh3cmFwTGFiZWwpIH1dIH07XG4gICAgfVxuXG4gICAgY29uc3QgZXhpc3RpbmdLZXlzID0gcGFyc2VkU2VsZWN0b3IgPyBwYXJzZWRTZWxlY3Rvci5sYWJlbEtleXMgOiBbXTtcblxuICAgIGxldCBsYWJlbFZhbHVlcztcbiAgICAvLyBRdWVyeSBsYWJlbHMgZm9yIHNlbGVjdG9yXG4gICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICBpZiAoc2VsZWN0b3IgPT09IEVNUFRZX1NFTEVDVE9SICYmIGxhYmVsS2V5KSB7XG4gICAgICAgIGNvbnN0IGxhYmVsVmFsdWVzRm9yS2V5ID0gYXdhaXQgdGhpcy5nZXRMYWJlbFZhbHVlcyhsYWJlbEtleSk7XG4gICAgICAgIGxhYmVsVmFsdWVzID0geyBbbGFiZWxLZXldOiBsYWJlbFZhbHVlc0ZvcktleSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFiZWxWYWx1ZXMgPSBhd2FpdCB0aGlzLmdldFNlcmllc0xhYmVscyhzZWxlY3Rvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFsYWJlbFZhbHVlcykge1xuICAgICAgY29uc29sZS53YXJuKGBTZXJ2ZXIgZGlkIG5vdCByZXR1cm4gYW55IHZhbHVlcyBmb3Igc2VsZWN0b3IgPSAke3NlbGVjdG9yfWApO1xuICAgICAgcmV0dXJuIHsgY29udGV4dCwgc3VnZ2VzdGlvbnMgfTtcbiAgICB9XG5cbiAgICBpZiAoKHRleHQgJiYgaXNWYWx1ZVN0YXJ0KSB8fCB3cmFwcGVyQ2xhc3Nlcy5pbmNsdWRlcygnYXR0ci12YWx1ZScpKSB7XG4gICAgICAvLyBMYWJlbCB2YWx1ZXNcbiAgICAgIGlmIChsYWJlbEtleSAmJiBsYWJlbFZhbHVlc1tsYWJlbEtleV0pIHtcbiAgICAgICAgY29udGV4dCA9ICdjb250ZXh0LWxhYmVsLXZhbHVlcyc7XG4gICAgICAgIHN1Z2dlc3Rpb25zLnB1c2goe1xuICAgICAgICAgIGxhYmVsOiBgTGFiZWwgdmFsdWVzIGZvciBcIiR7bGFiZWxLZXl9XCJgLFxuICAgICAgICAgIC8vIEZpbHRlciB0byBwcmV2ZW50IHByZXZpb3VzbHkgc2VsZWN0ZWQgdmFsdWVzIGZyb20gYmVpbmcgcmVwZWF0ZWRseSBzdWdnZXN0ZWRcbiAgICAgICAgICBpdGVtczogbGFiZWxWYWx1ZXNbbGFiZWxLZXldLm1hcCh3cmFwTGFiZWwpLmZpbHRlcigoeyBmaWx0ZXJUZXh0IH0pID0+IGZpbHRlclRleHQgIT09IHRleHQpLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTGFiZWwga2V5c1xuICAgICAgY29uc3QgbGFiZWxLZXlzID0gbGFiZWxWYWx1ZXMgPyBPYmplY3Qua2V5cyhsYWJlbFZhbHVlcykgOiBERUZBVUxUX0tFWVM7XG4gICAgICBpZiAobGFiZWxLZXlzKSB7XG4gICAgICAgIGNvbnN0IHBvc3NpYmxlS2V5cyA9IGRpZmZlcmVuY2UobGFiZWxLZXlzLCBleGlzdGluZ0tleXMpO1xuICAgICAgICBpZiAocG9zc2libGVLZXlzLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IG5ld0l0ZW1zID0gcG9zc2libGVLZXlzLm1hcCgoa2V5KSA9PiAoeyBsYWJlbDoga2V5IH0pKTtcbiAgICAgICAgICBjb25zdCBuZXdTdWdnZXN0aW9uOiBDb21wbGV0aW9uSXRlbUdyb3VwID0geyBsYWJlbDogYExhYmVsc2AsIGl0ZW1zOiBuZXdJdGVtcyB9O1xuICAgICAgICAgIHN1Z2dlc3Rpb25zLnB1c2gobmV3U3VnZ2VzdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyBjb250ZXh0LCBzdWdnZXN0aW9ucyB9O1xuICB9XG5cbiAgaW1wb3J0RnJvbUFic3RyYWN0UXVlcnkobGFiZWxCYXNlZFF1ZXJ5OiBBYnN0cmFjdFF1ZXJ5KTogTG9raVF1ZXJ5IHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVmSWQ6IGxhYmVsQmFzZWRRdWVyeS5yZWZJZCxcbiAgICAgIGV4cHI6IHRvUHJvbUxpa2VFeHByKGxhYmVsQmFzZWRRdWVyeSksXG4gICAgICBxdWVyeVR5cGU6IExva2lRdWVyeVR5cGUuUmFuZ2UsXG4gICAgfTtcbiAgfVxuXG4gIGV4cG9ydFRvQWJzdHJhY3RRdWVyeShxdWVyeTogTG9raVF1ZXJ5KTogQWJzdHJhY3RRdWVyeSB7XG4gICAgY29uc3QgbG9raVF1ZXJ5ID0gcXVlcnkuZXhwcjtcbiAgICBpZiAoIWxva2lRdWVyeSB8fCBsb2tpUXVlcnkubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4geyByZWZJZDogcXVlcnkucmVmSWQsIGxhYmVsTWF0Y2hlcnM6IFtdIH07XG4gICAgfVxuICAgIGNvbnN0IHRva2VucyA9IFByaXNtLnRva2VuaXplKGxva2lRdWVyeSwgc3ludGF4KTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVmSWQ6IHF1ZXJ5LnJlZklkLFxuICAgICAgbGFiZWxNYXRjaGVyczogZXh0cmFjdExhYmVsTWF0Y2hlcnModG9rZW5zKSxcbiAgICB9O1xuICB9XG5cbiAgYXN5bmMgZ2V0U2VyaWVzTGFiZWxzKHNlbGVjdG9yOiBzdHJpbmcpIHtcbiAgICBpZiAodGhpcy5sb29rdXBzRGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5mZXRjaFNlcmllc0xhYmVscyhzZWxlY3Rvcik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIFRPRE86IGJldHRlciBlcnJvciBoYW5kbGluZ1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaGVzIGFsbCBsYWJlbCBrZXlzXG4gICAqL1xuICBhc3luYyBmZXRjaExhYmVscygpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgY29uc3QgdXJsID0gJ2xhYmVscyc7XG4gICAgY29uc3QgdGltZVJhbmdlID0gdGhpcy5kYXRhc291cmNlLmdldFRpbWVSYW5nZVBhcmFtcygpO1xuICAgIHRoaXMubGFiZWxGZXRjaFRzID0gRGF0ZS5ub3coKS52YWx1ZU9mKCk7XG5cbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLnJlcXVlc3QodXJsLCB0aW1lUmFuZ2UpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlcykpIHtcbiAgICAgIGNvbnN0IGxhYmVscyA9IHJlc1xuICAgICAgICAuc2xpY2UoKVxuICAgICAgICAuc29ydCgpXG4gICAgICAgIC5maWx0ZXIoKGxhYmVsKSA9PiBsYWJlbCAhPT0gJ19fbmFtZV9fJyk7XG4gICAgICB0aGlzLmxhYmVsS2V5cyA9IGxhYmVscztcbiAgICB9XG5cbiAgICByZXR1cm4gW107XG4gIH1cblxuICBhc3luYyByZWZyZXNoTG9nTGFiZWxzKGZvcmNlUmVmcmVzaD86IGJvb2xlYW4pIHtcbiAgICBpZiAoKHRoaXMubGFiZWxLZXlzICYmIERhdGUubm93KCkudmFsdWVPZigpIC0gdGhpcy5sYWJlbEZldGNoVHMgPiBMQUJFTF9SRUZSRVNIX0lOVEVSVkFMKSB8fCBmb3JjZVJlZnJlc2gpIHtcbiAgICAgIGF3YWl0IHRoaXMuZmV0Y2hMYWJlbHMoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggbGFiZWxzIGZvciBhIHNlbGVjdG9yLiBUaGlzIGlzIGNhY2hlZCBieSBpdCdzIGFyZ3MgYnV0IGFsc28gYnkgdGhlIGdsb2JhbCB0aW1lUmFuZ2UgY3VycmVudGx5IHNlbGVjdGVkIGFzXG4gICAqIHRoZXkgY2FuIGNoYW5nZSBvdmVyIHJlcXVlc3RlZCB0aW1lLlxuICAgKiBAcGFyYW0gbmFtZVxuICAgKi9cbiAgZmV0Y2hTZXJpZXNMYWJlbHMgPSBhc3luYyAobWF0Y2g6IHN0cmluZyk6IFByb21pc2U8UmVjb3JkPHN0cmluZywgc3RyaW5nW10+PiA9PiB7XG4gICAgY29uc3QgaW50ZXJwb2xhdGVkTWF0Y2ggPSB0aGlzLmRhdGFzb3VyY2UuaW50ZXJwb2xhdGVTdHJpbmcobWF0Y2gpO1xuICAgIGNvbnN0IHVybCA9ICdzZXJpZXMnO1xuICAgIGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gdGhpcy5kYXRhc291cmNlLmdldFRpbWVSYW5nZVBhcmFtcygpO1xuXG4gICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLmdlbmVyYXRlQ2FjaGVLZXkodXJsLCBzdGFydCwgZW5kLCBpbnRlcnBvbGF0ZWRNYXRjaCk7XG4gICAgbGV0IHZhbHVlID0gdGhpcy5zZXJpZXNDYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIC8vIENsZWFyIHZhbHVlIHdoZW4gcmVxdWVzdGluZyBuZXcgb25lLiBFbXB0eSBvYmplY3QgYmVpbmcgdHJ1dGh5IGFsc28gbWFrZXMgc3VyZSB3ZSBkb24ndCByZXF1ZXN0IHR3aWNlLlxuICAgICAgdGhpcy5zZXJpZXNDYWNoZS5zZXQoY2FjaGVLZXksIHt9KTtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHsgJ21hdGNoW10nOiBpbnRlcnBvbGF0ZWRNYXRjaCwgc3RhcnQsIGVuZCB9O1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMucmVxdWVzdCh1cmwsIHBhcmFtcyk7XG4gICAgICBjb25zdCB7IHZhbHVlcyB9ID0gcHJvY2Vzc0xhYmVscyhkYXRhKTtcbiAgICAgIHZhbHVlID0gdmFsdWVzO1xuICAgICAgdGhpcy5zZXJpZXNDYWNoZS5zZXQoY2FjaGVLZXksIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGZXRjaCBzZXJpZXMgZm9yIGEgc2VsZWN0b3IuIFVzZSB0aGlzIGZvciByYXcgcmVzdWx0cy4gVXNlIGZldGNoU2VyaWVzTGFiZWxzKCkgdG8gZ2V0IGxhYmVscy5cbiAgICogQHBhcmFtIG1hdGNoXG4gICAqL1xuICBmZXRjaFNlcmllcyA9IGFzeW5jIChtYXRjaDogc3RyaW5nKTogUHJvbWlzZTxBcnJheTxSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+Pj4gPT4ge1xuICAgIGNvbnN0IHVybCA9ICdzZXJpZXMnO1xuICAgIGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gdGhpcy5kYXRhc291cmNlLmdldFRpbWVSYW5nZVBhcmFtcygpO1xuICAgIGNvbnN0IHBhcmFtcyA9IHsgJ21hdGNoW10nOiBtYXRjaCwgc3RhcnQsIGVuZCB9O1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnJlcXVlc3QodXJsLCBwYXJhbXMpO1xuICB9O1xuXG4gIC8vIENhY2hlIGtleSBpcyBhIGJpdCBkaWZmZXJlbnQgaGVyZS4gV2Ugcm91bmQgdXAgdG8gYSBtaW51dGUgdGhlIGludGVydmFscy5cbiAgLy8gVGhlIHJvdW5kaW5nIG1heSBzZWVtIHN0cmFuZ2UgYnV0IG1ha2VzIHJlbGF0aXZlIGludGVydmFscyBsaWtlIG5vdy0xaCBsZXNzIHByb25lIHRvIG5lZWQgc2VwYXJhdGUgcmVxdWVzdCBldmVyeVxuICAvLyBtaWxsaXNlY29uZCB3aGlsZSBzdGlsbCBhY3R1YWxseSBnZXR0aW5nIGFsbCB0aGUga2V5cyBmb3IgdGhlIGNvcnJlY3QgaW50ZXJ2YWwuIFRoaXMgc3RpbGwgY2FuIGNyZWF0ZSBwcm9ibGVtc1xuICAvLyB3aGVuIHVzZXIgZG9lcyBub3QgdGhlIG5ld2VzdCB2YWx1ZXMgZm9yIGEgbWludXRlIGlmIGFscmVhZHkgY2FjaGVkLlxuICBnZW5lcmF0ZUNhY2hlS2V5KHVybDogc3RyaW5nLCBzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlciwgcGFyYW06IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIFt1cmwsIHRoaXMucm91bmRUaW1lKHN0YXJ0KSwgdGhpcy5yb3VuZFRpbWUoZW5kKSwgcGFyYW1dLmpvaW4oKTtcbiAgfVxuXG4gIC8vIFJvdW5kIG5hbm9zIGVwb2NoIHRvIG5lYXJlc3QgNSBtaW51dGUgaW50ZXJ2YWxcbiAgcm91bmRUaW1lKG5hbm9zOiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiBuYW5vcyA/IE1hdGguZmxvb3IobmFub3MgLyBOU19JTl9NUyAvIDEwMDAgLyA2MCAvIDUpIDogMDtcbiAgfVxuXG4gIGFzeW5jIGdldExhYmVsVmFsdWVzKGtleTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmZldGNoTGFiZWxWYWx1ZXMoa2V5KTtcbiAgfVxuXG4gIGFzeW5jIGZldGNoTGFiZWxWYWx1ZXMoa2V5OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgY29uc3QgaW50ZXJwb2xhdGVkS2V5ID0gdGhpcy5kYXRhc291cmNlLmludGVycG9sYXRlU3RyaW5nKGtleSk7XG4gICAgY29uc3QgdXJsID0gYGxhYmVsLyR7aW50ZXJwb2xhdGVkS2V5fS92YWx1ZXNgO1xuICAgIGNvbnN0IHJhbmdlUGFyYW1zID0gdGhpcy5kYXRhc291cmNlLmdldFRpbWVSYW5nZVBhcmFtcygpO1xuICAgIGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gcmFuZ2VQYXJhbXM7XG5cbiAgICBjb25zdCBjYWNoZUtleSA9IHRoaXMuZ2VuZXJhdGVDYWNoZUtleSh1cmwsIHN0YXJ0LCBlbmQsIGludGVycG9sYXRlZEtleSk7XG4gICAgY29uc3QgcGFyYW1zID0geyBzdGFydCwgZW5kIH07XG5cbiAgICBsZXQgbGFiZWxWYWx1ZXMgPSB0aGlzLmxhYmVsc0NhY2hlLmdldChjYWNoZUtleSk7XG4gICAgaWYgKCFsYWJlbFZhbHVlcykge1xuICAgICAgLy8gQ2xlYXIgdmFsdWUgd2hlbiByZXF1ZXN0aW5nIG5ldyBvbmUuIEVtcHR5IG9iamVjdCBiZWluZyB0cnV0aHkgYWxzbyBtYWtlcyBzdXJlIHdlIGRvbid0IHJlcXVlc3QgdHdpY2UuXG4gICAgICB0aGlzLmxhYmVsc0NhY2hlLnNldChjYWNoZUtleSwgW10pO1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5yZXF1ZXN0KHVybCwgcGFyYW1zKTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlcykpIHtcbiAgICAgICAgbGFiZWxWYWx1ZXMgPSByZXMuc2xpY2UoKS5zb3J0KCk7XG4gICAgICAgIHRoaXMubGFiZWxzQ2FjaGUuc2V0KGNhY2hlS2V5LCBsYWJlbFZhbHVlcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhYmVsVmFsdWVzID8/IFtdO1xuICB9XG59XG4iLCJpbXBvcnQgeyBUaW1lUmFuZ2UgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcblxuZnVuY3Rpb24gcm91bmRNc1RvTWluKG1pbGxpc2Vjb25kczogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIHJvdW5kU2VjVG9NaW4obWlsbGlzZWNvbmRzIC8gMTAwMCk7XG59XG5cbmZ1bmN0aW9uIHJvdW5kU2VjVG9NaW4oc2Vjb25kczogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIE1hdGguZmxvb3Ioc2Vjb25kcyAvIDYwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNob3VsZFJlZnJlc2hMYWJlbHMocmFuZ2U/OiBUaW1lUmFuZ2UsIHByZXZSYW5nZT86IFRpbWVSYW5nZSk6IGJvb2xlYW4ge1xuICBpZiAocmFuZ2UgJiYgcHJldlJhbmdlKSB7XG4gICAgY29uc3Qgc2FtZU1pbnV0ZUZyb20gPSByb3VuZE1zVG9NaW4ocmFuZ2UuZnJvbS52YWx1ZU9mKCkpID09PSByb3VuZE1zVG9NaW4ocHJldlJhbmdlLmZyb20udmFsdWVPZigpKTtcbiAgICBjb25zdCBzYW1lTWludXRlVG8gPSByb3VuZE1zVG9NaW4ocmFuZ2UudG8udmFsdWVPZigpKSA9PT0gcm91bmRNc1RvTWluKHByZXZSYW5nZS50by52YWx1ZU9mKCkpO1xuICAgIC8vIElmIGJvdGggYXJlIHNhbWUsIGRvbid0IG5lZWQgdG8gcmVmcmVzaFxuICAgIHJldHVybiAhKHNhbWVNaW51dGVGcm9tICYmIHNhbWVNaW51dGVUbyk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBMb2tpIHJlZ3VsYXItZXhwcmVzc2lvbnMgdXNlIHRoZSBSRTIgc3ludGF4IChodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL3JlMi93aWtpL1N5bnRheCksXG4vLyBzbyBldmVyeSBjaGFyYWN0ZXIgdGhhdCBtYXRjaGVzIHNvbWV0aGluZyBpbiB0aGF0IGxpc3QgaGFzIHRvIGJlIGVzY2FwZWQuXG4vLyB0aGUgbGlzdCBvZiBtZXRhIGNoYXJhY3RlcnMgaXM6ICorPygpfFxcLltde31eJFxuLy8gd2UgbWFrZSBhIGphdmFzY3JpcHQgcmVndWxhciBleHByZXNzaW9uIHRoYXQgbWF0Y2hlcyB0aG9zZSBjaGFyYWN0ZXJzOlxuY29uc3QgUkUyX01FVEFDSEFSQUNURVJTID0gL1sqKz8oKXxcXFxcLlxcW1xcXXt9XiRdL2c7XG5mdW5jdGlvbiBlc2NhcGVMb2tpUmVnZXhwKHZhbHVlOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gdmFsdWUucmVwbGFjZShSRTJfTUVUQUNIQVJBQ1RFUlMsICdcXFxcJCYnKTtcbn1cblxuLy8gYmFzZWQgb24gdGhlIG9wZW5tZXRyaWNzLWRvY3VtZW50YXRpb24sIHRoZSAzIHN5bWJvbHMgd2UgaGF2ZSB0byBoYW5kbGUgYXJlOlxuLy8gLSBcXG4gLi4uIHRoZSBuZXdsaW5lIGNoYXJhY3RlclxuLy8gLSBcXCAgLi4uIHRoZSBiYWNrc2xhc2ggY2hhcmFjdGVyXG4vLyAtIFwiICAuLi4gdGhlIGRvdWJsZS1xdW90ZSBjaGFyYWN0ZXJcbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVMYWJlbFZhbHVlSW5FeGFjdFNlbGVjdG9yKGxhYmVsVmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBsYWJlbFZhbHVlLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJykucmVwbGFjZSgvXFxuL2csICdcXFxcbicpLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZUxhYmVsVmFsdWVJblJlZ2V4U2VsZWN0b3IobGFiZWxWYWx1ZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIGVzY2FwZUxhYmVsVmFsdWVJbkV4YWN0U2VsZWN0b3IoZXNjYXBlTG9raVJlZ2V4cChsYWJlbFZhbHVlKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVMYWJlbFZhbHVlSW5TZWxlY3RvcihsYWJlbFZhbHVlOiBzdHJpbmcsIHNlbGVjdG9yPzogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIGlzUmVnZXhTZWxlY3RvcihzZWxlY3RvcilcbiAgICA/IGVzY2FwZUxhYmVsVmFsdWVJblJlZ2V4U2VsZWN0b3IobGFiZWxWYWx1ZSlcbiAgICA6IGVzY2FwZUxhYmVsVmFsdWVJbkV4YWN0U2VsZWN0b3IobGFiZWxWYWx1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1JlZ2V4U2VsZWN0b3Ioc2VsZWN0b3I/OiBzdHJpbmcpIHtcbiAgaWYgKHNlbGVjdG9yICYmIChzZWxlY3Rvci5pbmNsdWRlcygnPX4nKSB8fCBzZWxlY3Rvci5pbmNsdWRlcygnIX4nKSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG4iLCJpbXBvcnQgeyBPYnNlcnZhYmxlLCB0aHJvd0Vycm9yLCB0aW1lciB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZmluYWxpemUsIG1hcCwgcmV0cnlXaGVuLCBtZXJnZU1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IHdlYlNvY2tldCB9IGZyb20gJ3J4anMvd2ViU29ja2V0JztcblxuaW1wb3J0IHsgRGF0YUZyYW1lLCBGaWVsZFR5cGUsIHBhcnNlTGFiZWxzLCBLZXlWYWx1ZSwgQ2lyY3VsYXJEYXRhRnJhbWUgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcblxuaW1wb3J0IHsgYXBwZW5kUmVzcG9uc2VUb0J1ZmZlcmVkRGF0YSB9IGZyb20gJy4vcmVzdWx0X3RyYW5zZm9ybWVyJztcbmltcG9ydCB7IExva2lUYWlsUmVzcG9uc2UgfSBmcm9tICcuL3R5cGVzJztcblxuLyoqXG4gKiBNYXBzIGRpcmVjdGx5IHRvIGEgcXVlcnkgaW4gdGhlIFVJIChyZWZJZCBpcyBrZXkpXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTG9raUxpdmVUYXJnZXQge1xuICBxdWVyeTogc3RyaW5nO1xuICB1cmw6IHN0cmluZztcbiAgcmVmSWQ6IHN0cmluZztcbiAgc2l6ZTogbnVtYmVyO1xufVxuXG4vKipcbiAqIENhY2hlIG9mIHdlYnNvY2tldCBzdHJlYW1zIHRoYXQgY2FuIGJlIHJldHVybmVkIGFzIG9ic2VydmFibGUuIEluIGNhc2UgdGhlcmUgYWxyZWFkeSBpcyBhIHN0cmVhbSBmb3IgcGFydGljdWxhclxuICogdGFyZ2V0IGl0IGlzIHJldHVybmVkIGFuZCBvbiBzdWJzY3JpcHRpb24gcmV0dXJucyB0aGUgbGF0ZXN0IGRhdGFGcmFtZS5cbiAqL1xuZXhwb3J0IGNsYXNzIExpdmVTdHJlYW1zIHtcbiAgcHJpdmF0ZSBzdHJlYW1zOiBLZXlWYWx1ZTxPYnNlcnZhYmxlPERhdGFGcmFtZVtdPj4gPSB7fTtcblxuICBnZXRTdHJlYW0odGFyZ2V0OiBMb2tpTGl2ZVRhcmdldCwgcmV0cnlJbnRlcnZhbCA9IDUwMDApOiBPYnNlcnZhYmxlPERhdGFGcmFtZVtdPiB7XG4gICAgbGV0IHN0cmVhbSA9IHRoaXMuc3RyZWFtc1t0YXJnZXQudXJsXTtcblxuICAgIGlmIChzdHJlYW0pIHtcbiAgICAgIHJldHVybiBzdHJlYW07XG4gICAgfVxuXG4gICAgY29uc3QgZGF0YSA9IG5ldyBDaXJjdWxhckRhdGFGcmFtZSh7IGNhcGFjaXR5OiB0YXJnZXQuc2l6ZSB9KTtcbiAgICBkYXRhLmFkZEZpZWxkKHsgbmFtZTogJ2xhYmVscycsIHR5cGU6IEZpZWxkVHlwZS5vdGhlciB9KTsgLy8gVGhlIGxhYmVscyBmb3IgZWFjaCBsaW5lXG4gICAgZGF0YS5hZGRGaWVsZCh7IG5hbWU6ICd0cycsIHR5cGU6IEZpZWxkVHlwZS50aW1lLCBjb25maWc6IHsgZGlzcGxheU5hbWU6ICdUaW1lJyB9IH0pO1xuICAgIGRhdGEuYWRkRmllbGQoeyBuYW1lOiAnbGluZScsIHR5cGU6IEZpZWxkVHlwZS5zdHJpbmcgfSkubGFiZWxzID0gcGFyc2VMYWJlbHModGFyZ2V0LnF1ZXJ5KTtcbiAgICBkYXRhLmFkZEZpZWxkKHsgbmFtZTogJ2lkJywgdHlwZTogRmllbGRUeXBlLnN0cmluZyB9KTtcbiAgICBkYXRhLmFkZEZpZWxkKHsgbmFtZTogJ3RzTnMnLCB0eXBlOiBGaWVsZFR5cGUudGltZSwgY29uZmlnOiB7IGRpc3BsYXlOYW1lOiAnVGltZSBucycgfSB9KTtcbiAgICBkYXRhLm1ldGEgPSB7IC4uLmRhdGEubWV0YSwgcHJlZmVycmVkVmlzdWFsaXNhdGlvblR5cGU6ICdsb2dzJyB9O1xuICAgIGRhdGEucmVmSWQgPSB0YXJnZXQucmVmSWQ7XG5cbiAgICBzdHJlYW0gPSB3ZWJTb2NrZXQ8TG9raVRhaWxSZXNwb25zZT4odGFyZ2V0LnVybCkucGlwZShcbiAgICAgIG1hcCgocmVzcG9uc2U6IExva2lUYWlsUmVzcG9uc2UpID0+IHtcbiAgICAgICAgYXBwZW5kUmVzcG9uc2VUb0J1ZmZlcmVkRGF0YShyZXNwb25zZSwgZGF0YSk7XG4gICAgICAgIHJldHVybiBbZGF0YV07XG4gICAgICB9KSxcbiAgICAgIHJldHJ5V2hlbigoYXR0ZW1wdHM6IE9ic2VydmFibGU8YW55PikgPT5cbiAgICAgICAgYXR0ZW1wdHMucGlwZShcbiAgICAgICAgICBtZXJnZU1hcCgoZXJyb3IsIGkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHJ5QXR0ZW1wdCA9IGkgKyAxO1xuICAgICAgICAgICAgLy8gQ29kZSAxMDA2IGlzIHVzZWQgdG8gaW5kaWNhdGUgdGhhdCBhIGNvbm5lY3Rpb24gd2FzIGNsb3NlZCBhYm5vcm1hbGx5LlxuICAgICAgICAgICAgLy8gQWRkZWQgaGFyZCBsaW1pdCBvZiAzMCBvbiBudW1iZXIgb2YgcmV0cmllcy5cbiAgICAgICAgICAgIC8vIElmIGNvbm5lY3Rpb24gd2FzIGNsb3NlZCBhYm5vcm1hbGx5LCBhbmQgd2Ugd2lzaCB0byByZXRyeSwgb3RoZXJ3aXNlIHRocm93IGVycm9yLlxuICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IDEwMDYgJiYgcmV0cnlBdHRlbXB0IDwgMzApIHtcbiAgICAgICAgICAgICAgaWYgKHJldHJ5QXR0ZW1wdCA+IDEwKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgbW9yZSB0aGFuIDEwIHRpbWVzIHJldHJpZWQsIGNvbnNvbC53YXJuLCBidXQga2VlcCByZWNvbm5lY3RpbmdcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICBgV2Vic29ja2V0IGNvbm5lY3Rpb24gaXMgYmVpbmcgZGlzcnVwdGVkLiBXZSBrZWVwIHJlY29ubmVjdGluZyBidXQgY29uc2lkZXIgc3RhcnRpbmcgbmV3IGxpdmUgdGFpbGluZyBhZ2Fpbi4gRXJyb3I6ICR7ZXJyb3IucmVhc29ufWBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIFJldHJ5IGV2ZXJ5IDVzXG4gICAgICAgICAgICAgIHJldHVybiB0aW1lcihyZXRyeUludGVydmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKGVycm9yKTtcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApLFxuICAgICAgZmluYWxpemUoKCkgPT4ge1xuICAgICAgICBkZWxldGUgdGhpcy5zdHJlYW1zW3RhcmdldC51cmxdO1xuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMuc3RyZWFtc1t0YXJnZXQudXJsXSA9IHN0cmVhbTtcblxuICAgIHJldHVybiBzdHJlYW07XG4gIH1cbn1cbiIsImltcG9ydCB7IGdyb3VwQnkgfSBmcm9tICdsb2Rhc2gnO1xuXG5pbXBvcnQgeyBEYXRhRnJhbWUsIEZpZWxkLCBGaWVsZFR5cGUsIEFycmF5VmVjdG9yIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlVGFibGVGcmFtZXMoaW5zdGFudE1ldHJpY0ZyYW1lczogRGF0YUZyYW1lW10pOiBEYXRhRnJhbWVbXSB7XG4gIC8vIGZpcnN0IHdlIHJlbW92ZSBmcmFtZXMgdGhhdCBoYXZlIG5vIHJlZklkXG4gIC8vICh3ZSB3aWxsIGdyb3VwIHRoZW0gYnkgcmVmSWQsIHNvIHdlIG5lZWQgaXQgdG8gYmUgc2V0KVxuICBjb25zdCBmcmFtZXNXaXRoUmVmSWQgPSBpbnN0YW50TWV0cmljRnJhbWVzLmZpbHRlcigoZikgPT4gZi5yZWZJZCAhPT0gdW5kZWZpbmVkKTtcblxuICBjb25zdCBmcmFtZXNCeVJlZklkID0gZ3JvdXBCeShmcmFtZXNXaXRoUmVmSWQsIChmcmFtZSkgPT4gZnJhbWUucmVmSWQpO1xuXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhmcmFtZXNCeVJlZklkKS5tYXAoKFtyZWZJZCwgZnJhbWVzXSkgPT4gbWFrZVRhYmxlRnJhbWUoZnJhbWVzLCByZWZJZCkpO1xufVxuXG50eXBlIE51bWJlckZpZWxkID0gRmllbGQ8bnVtYmVyLCBBcnJheVZlY3RvcjxudW1iZXI+PjtcbnR5cGUgU3RyaW5nRmllbGQgPSBGaWVsZDxzdHJpbmcsIEFycmF5VmVjdG9yPHN0cmluZz4+O1xuXG5mdW5jdGlvbiBtYWtlVGFibGVGcmFtZShpbnN0YW50TWV0cmljRnJhbWVzOiBEYXRhRnJhbWVbXSwgcmVmSWQ6IHN0cmluZyk6IERhdGFGcmFtZSB7XG4gIGNvbnN0IHRhYmxlVGltZUZpZWxkOiBOdW1iZXJGaWVsZCA9IHsgbmFtZTogJ1RpbWUnLCBjb25maWc6IHt9LCB2YWx1ZXM6IG5ldyBBcnJheVZlY3RvcigpLCB0eXBlOiBGaWVsZFR5cGUudGltZSB9O1xuICBjb25zdCB0YWJsZVZhbHVlRmllbGQ6IE51bWJlckZpZWxkID0ge1xuICAgIG5hbWU6IGBWYWx1ZSAjJHtyZWZJZH1gLFxuICAgIGNvbmZpZzoge30sXG4gICAgdmFsdWVzOiBuZXcgQXJyYXlWZWN0b3IoKSxcbiAgICB0eXBlOiBGaWVsZFR5cGUubnVtYmVyLFxuICB9O1xuXG4gIC8vIFNvcnQgbWV0cmljIGxhYmVscywgY3JlYXRlIGNvbHVtbnMgZm9yIHRoZW0gYW5kIHJlY29yZCB0aGVpciBpbmRleFxuICBjb25zdCBhbGxMYWJlbE5hbWVzID0gbmV3IFNldChcbiAgICBpbnN0YW50TWV0cmljRnJhbWVzLm1hcCgoZnJhbWUpID0+IGZyYW1lLmZpZWxkcy5tYXAoKGZpZWxkKSA9PiBPYmplY3Qua2V5cyhmaWVsZC5sYWJlbHMgPz8ge30pKS5mbGF0KCkpLmZsYXQoKVxuICApO1xuXG4gIGNvbnN0IHNvcnRlZExhYmVsTmFtZXMgPSBBcnJheS5mcm9tKGFsbExhYmVsTmFtZXMpLnNvcnQoKTtcblxuICBjb25zdCBsYWJlbEZpZWxkczogU3RyaW5nRmllbGRbXSA9IHNvcnRlZExhYmVsTmFtZXMubWFwKChsYWJlbE5hbWUpID0+ICh7XG4gICAgbmFtZTogbGFiZWxOYW1lLFxuICAgIGNvbmZpZzogeyBmaWx0ZXJhYmxlOiB0cnVlIH0sXG4gICAgdmFsdWVzOiBuZXcgQXJyYXlWZWN0b3IoKSxcbiAgICB0eXBlOiBGaWVsZFR5cGUuc3RyaW5nLFxuICB9KSk7XG5cbiAgaW5zdGFudE1ldHJpY0ZyYW1lcy5mb3JFYWNoKChmcmFtZSkgPT4ge1xuICAgIGNvbnN0IHRpbWVGaWVsZCA9IGZyYW1lLmZpZWxkcy5maW5kKChmaWVsZCkgPT4gZmllbGQudHlwZSA9PT0gRmllbGRUeXBlLnRpbWUpO1xuICAgIGNvbnN0IHZhbHVlRmllbGQgPSBmcmFtZS5maWVsZHMuZmluZCgoZmllbGQpID0+IGZpZWxkLnR5cGUgPT09IEZpZWxkVHlwZS5udW1iZXIpO1xuICAgIGlmICh0aW1lRmllbGQgPT0gbnVsbCB8fCB2YWx1ZUZpZWxkID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB0aW1lQXJyYXkgPSB0aW1lRmllbGQudmFsdWVzLnRvQXJyYXkoKTtcbiAgICBjb25zdCB2YWx1ZUFycmF5ID0gdmFsdWVGaWVsZC52YWx1ZXMudG9BcnJheSgpO1xuXG4gICAgZm9yIChsZXQgeCBvZiB0aW1lQXJyYXkpIHtcbiAgICAgIHRhYmxlVGltZUZpZWxkLnZhbHVlcy5hZGQoeCk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgeCBvZiB2YWx1ZUFycmF5KSB7XG4gICAgICB0YWJsZVZhbHVlRmllbGQudmFsdWVzLmFkZCh4KTtcbiAgICB9XG5cbiAgICBjb25zdCBsYWJlbHMgPSB2YWx1ZUZpZWxkLmxhYmVscyA/PyB7fTtcblxuICAgIGZvciAobGV0IGYgb2YgbGFiZWxGaWVsZHMpIHtcbiAgICAgIGNvbnN0IHRleHQgPSBsYWJlbHNbZi5uYW1lXSA/PyAnJztcbiAgICAgIC8vIHdlIGluc2VydCB0aGUgbGFiZWxzIGFzIG1hbnkgdGltZXMgYXMgd2UgaGF2ZSB2YWx1ZXNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBmLnZhbHVlcy5hZGQodGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4ge1xuICAgIGZpZWxkczogW3RhYmxlVGltZUZpZWxkLCAuLi5sYWJlbEZpZWxkcywgdGFibGVWYWx1ZUZpZWxkXSxcbiAgICByZWZJZCxcbiAgICBtZXRhOiB7IHByZWZlcnJlZFZpc3VhbGlzYXRpb25UeXBlOiAndGFibGUnIH0sXG4gICAgbGVuZ3RoOiB0YWJsZVRpbWVGaWVsZC52YWx1ZXMubGVuZ3RoLFxuICB9O1xufVxuIiwiaW1wb3J0IHsgRGF0YVNvdXJjZVBsdWdpbiB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuXG5pbXBvcnQgeyBMb2tpQW5ub3RhdGlvbnNRdWVyeUN0cmwgfSBmcm9tICcuL0xva2lBbm5vdGF0aW9uc1F1ZXJ5Q3RybCc7XG5pbXBvcnQgTG9raUNoZWF0U2hlZXQgZnJvbSAnLi9jb21wb25lbnRzL0xva2lDaGVhdFNoZWV0JztcbmltcG9ydCBMb2tpUXVlcnlFZGl0b3JCeUFwcCBmcm9tICcuL2NvbXBvbmVudHMvTG9raVF1ZXJ5RWRpdG9yQnlBcHAnO1xuaW1wb3J0IHsgQ29uZmlnRWRpdG9yIH0gZnJvbSAnLi9jb25maWd1cmF0aW9uL0NvbmZpZ0VkaXRvcic7XG5pbXBvcnQgeyBMb2tpRGF0YXNvdXJjZSB9IGZyb20gJy4vZGF0YXNvdXJjZSc7XG5cbmV4cG9ydCBjb25zdCBwbHVnaW4gPSBuZXcgRGF0YVNvdXJjZVBsdWdpbihMb2tpRGF0YXNvdXJjZSlcbiAgLnNldFF1ZXJ5RWRpdG9yKExva2lRdWVyeUVkaXRvckJ5QXBwKVxuICAuc2V0Q29uZmlnRWRpdG9yKENvbmZpZ0VkaXRvcilcbiAgLnNldFF1ZXJ5RWRpdG9ySGVscChMb2tpQ2hlYXRTaGVldClcbiAgLnNldEFubm90YXRpb25RdWVyeUN0cmwoTG9raUFubm90YXRpb25zUXVlcnlDdHJsKTtcbiIsImltcG9ydCB7IGVzY2FwZVJlZ0V4cCB9IGZyb20gJ2xvZGFzaCc7XG5cbmltcG9ydCB7IFBJUEVfUEFSU0VSUyB9IGZyb20gJy4vc3ludGF4JztcbmltcG9ydCB7IExva2lRdWVyeSwgTG9raVF1ZXJ5VHlwZSB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0UXVlcnkoc2VsZWN0b3I6IHN0cmluZyB8IHVuZGVmaW5lZCk6IHN0cmluZyB7XG4gIHJldHVybiBgJHtzZWxlY3RvciB8fCAnJ31gLnRyaW0oKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHNlYXJjaCB0ZXJtcyBmcm9tIGEgTG9nUUwgcXVlcnkuXG4gKiBFLmcuLCBge30gfD0gZm9vIHw9YmFyICE9IGJhemAgcmV0dXJucyBgWydmb28nLCAnYmFyJ11gLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SGlnaGxpZ2h0ZXJFeHByZXNzaW9uc0Zyb21RdWVyeShpbnB1dDogc3RyaW5nKTogc3RyaW5nW10ge1xuICBsZXQgZXhwcmVzc2lvbiA9IGlucHV0O1xuICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgLy8gQ29uc3VtZSBmaWx0ZXIgZXhwcmVzc2lvbiBmcm9tIGxlZnQgdG8gcmlnaHRcbiAgd2hpbGUgKGV4cHJlc3Npb24pIHtcbiAgICBjb25zdCBmaWx0ZXJTdGFydCA9IGV4cHJlc3Npb24uc2VhcmNoKC9cXHw9fFxcfH58IT18IX4vKTtcbiAgICAvLyBOb3RoaW5nIG1vcmUgdG8gc2VhcmNoXG4gICAgaWYgKGZpbHRlclN0YXJ0ID09PSAtMSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIERyb3AgdGVybXMgZm9yIG5lZ2F0aXZlIGZpbHRlcnNcbiAgICBjb25zdCBmaWx0ZXJPcGVyYXRvciA9IGV4cHJlc3Npb24uc2xpY2UoZmlsdGVyU3RhcnQsIGZpbHRlclN0YXJ0ICsgMik7XG4gICAgY29uc3Qgc2tpcCA9IGV4cHJlc3Npb24uc2xpY2UoZmlsdGVyU3RhcnQpLnNlYXJjaCgvIT18IX4vKSA9PT0gMDtcbiAgICBleHByZXNzaW9uID0gZXhwcmVzc2lvbi5zbGljZShmaWx0ZXJTdGFydCArIDIpO1xuICAgIGlmIChza2lwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgdGhlcmUgaXMgbW9yZSBjaGFpbmVkXG4gICAgY29uc3QgZmlsdGVyRW5kID0gZXhwcmVzc2lvbi5zZWFyY2goL1xcfD18XFx8fnwhPXwhfi8pO1xuICAgIGxldCBmaWx0ZXJUZXJtO1xuICAgIGlmIChmaWx0ZXJFbmQgPT09IC0xKSB7XG4gICAgICBmaWx0ZXJUZXJtID0gZXhwcmVzc2lvbi50cmltKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbHRlclRlcm0gPSBleHByZXNzaW9uLnNsaWNlKDAsIGZpbHRlckVuZCkudHJpbSgpO1xuICAgICAgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb24uc2xpY2UoZmlsdGVyRW5kKTtcbiAgICB9XG5cbiAgICBjb25zdCBxdW90ZWRUZXJtID0gZmlsdGVyVGVybS5tYXRjaCgvXCIoLio/KVwiLyk7XG4gICAgY29uc3QgYmFja3RpY2tlZFRlcm0gPSBmaWx0ZXJUZXJtLm1hdGNoKC9gKC4qPylgLyk7XG4gICAgY29uc3QgdGVybSA9IHF1b3RlZFRlcm0gfHwgYmFja3RpY2tlZFRlcm07XG5cbiAgICBpZiAodGVybSkge1xuICAgICAgY29uc3QgdW53cmFwcGVkRmlsdGVyVGVybSA9IHRlcm1bMV07XG4gICAgICBjb25zdCByZWdleE9wZXJhdG9yID0gZmlsdGVyT3BlcmF0b3IgPT09ICd8fic7XG5cbiAgICAgIC8vIE9ubHkgZmlsdGVyIGV4cHJlc3Npb25zIHdpdGggfH4gb3BlcmF0b3IgYXJlIHRyZWF0ZWQgYXMgcmVndWxhciBleHByZXNzaW9uc1xuICAgICAgaWYgKHJlZ2V4T3BlcmF0b3IpIHtcbiAgICAgICAgLy8gV2hlbiB1c2luZyBiYWNrdGlja3MsIExva2kgZG9lc24ndCByZXF1aXJlIHRvIGVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgYW5kIHdlIGNhbiBqdXN0IHB1c2ggcmVndWxhciBleHByZXNzaW9uIHRvIGhpZ2hsaWdodHMgYXJyYXlcbiAgICAgICAgLy8gV2hlbiB1c2luZyBxdW90ZXMsIHdlIGhhdmUgZXh0cmEgYmFja3NsYXNoIGVzY2FwaW5nIGFuZCB3ZSBuZWVkIHRvIHJlcGxhY2UgXFxcXCB3aXRoIFxcXG4gICAgICAgIHJlc3VsdHMucHVzaChiYWNrdGlja2VkVGVybSA/IHVud3JhcHBlZEZpbHRlclRlcm0gOiB1bndyYXBwZWRGaWx0ZXJUZXJtLnJlcGxhY2UoL1xcXFxcXFxcL2csICdcXFxcJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBlc2NhcGUgdGhpcyBzdHJpbmcgc28gaXQgaXMgbm90IG1hdGNoZWQgYXMgcmVndWxhciBleHByZXNzaW9uXG4gICAgICAgIHJlc3VsdHMucHVzaChlc2NhcGVSZWdFeHAodW53cmFwcGVkRmlsdGVyVGVybSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHF1ZXJ5SGFzUGlwZVBhcnNlcihleHByOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgY29uc3QgcGFyc2VycyA9IFBJUEVfUEFSU0VSUy5tYXAoKHBhcnNlcikgPT4gYCR7cGFyc2VyLmxhYmVsfWApLmpvaW4oJ3wnKTtcbiAgY29uc3QgcmVnZXhwID0gbmV3IFJlZ0V4cChgXFxcXFxcfFxcXFxcXHM/KCR7cGFyc2Vyc30pYCk7XG4gIHJldHVybiByZWdleHAudGVzdChleHByKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZFBhcnNlZExhYmVsVG9RdWVyeShleHByOiBzdHJpbmcsIGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nIHwgbnVtYmVyLCBvcGVyYXRvcjogc3RyaW5nKSB7XG4gIHJldHVybiBleHByICsgYCB8ICR7a2V5fSR7b3BlcmF0b3J9XCIke3ZhbHVlLnRvU3RyaW5nKCl9XCJgO1xufVxuXG4vLyB3ZSBhcmUgbWlncmF0aW5nIGZyb20gYC5pbnN0YW50YCBhbmQgYC5yYW5nZWAgdG8gYC5xdWVyeVR5cGVgXG4vLyB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYSBuZXcgcXVlcnkgb2JqZWN0IHRoYXQ6XG4vLyAtIGhhcyBgLnF1ZXJ5VHlwZWBcbi8vIC0gZG9lcyBub3QgaGF2ZSBgLmluc3RhbnRgXG4vLyAtIGRvZXMgbm90IGhhdmUgYC5yYW5nZWBcbmV4cG9ydCBmdW5jdGlvbiBnZXROb3JtYWxpemVkTG9raVF1ZXJ5KHF1ZXJ5OiBMb2tpUXVlcnkpOiBMb2tpUXVlcnkge1xuICAvLyBpZiBxdWVyeVR5cGUgZXhpc3RzLCBpdCBpcyByZXNwZWN0ZWRcbiAgaWYgKHF1ZXJ5LnF1ZXJ5VHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgeyBpbnN0YW50LCByYW5nZSwgLi4ucmVzdCB9ID0gcXVlcnk7XG4gICAgcmV0dXJuIHJlc3Q7XG4gIH1cblxuICAvLyBpZiBubyBxdWVyeVR5cGUsIGFuZCBpbnN0YW50PT09dHJ1ZSwgaXQncyBpbnN0YW50XG4gIGlmIChxdWVyeS5pbnN0YW50ID09PSB0cnVlKSB7XG4gICAgY29uc3QgeyBpbnN0YW50LCByYW5nZSwgLi4ucmVzdCB9ID0gcXVlcnk7XG4gICAgcmV0dXJuIHsgLi4ucmVzdCwgcXVlcnlUeXBlOiBMb2tpUXVlcnlUeXBlLkluc3RhbnQgfTtcbiAgfVxuXG4gIC8vIG90aGVyd2lzZSBpdCBpcyByYW5nZVxuICBjb25zdCB7IGluc3RhbnQsIHJhbmdlLCAuLi5yZXN0IH0gPSBxdWVyeTtcbiAgcmV0dXJuIHsgLi4ucmVzdCwgcXVlcnlUeXBlOiBMb2tpUXVlcnlUeXBlLlJhbmdlIH07XG59XG4iLCJpbXBvcnQgeyBMb2tpQW5kUHJvbVF1ZXJ5TW9kZWxsZXJCYXNlIH0gZnJvbSAnLi4vLi4vcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL0xva2lBbmRQcm9tUXVlcnlNb2RlbGxlckJhc2UnO1xuaW1wb3J0IHsgUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXIgfSBmcm9tICcuLi8uLi9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvdHlwZXMnO1xuXG5pbXBvcnQgeyBnZXRPcGVyYXRpb25EZWZpbml0aW9ucyB9IGZyb20gJy4vb3BlcmF0aW9ucyc7XG5pbXBvcnQgeyBMb2tpT3BlcmF0aW9uSWQsIExva2lRdWVyeVBhdHRlcm4sIExva2lWaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5IH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBMb2tpUXVlcnlNb2RlbGxlciBleHRlbmRzIExva2lBbmRQcm9tUXVlcnlNb2RlbGxlckJhc2Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihnZXRPcGVyYXRpb25EZWZpbml0aW9ucyk7XG5cbiAgICB0aGlzLnNldE9wZXJhdGlvbkNhdGVnb3JpZXMoW1xuICAgICAgTG9raVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuQWdncmVnYXRpb25zLFxuICAgICAgTG9raVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuUmFuZ2VGdW5jdGlvbnMsXG4gICAgICBMb2tpVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5Gb3JtYXRzLFxuICAgICAgTG9raVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuQmluYXJ5T3BzLFxuICAgICAgTG9raVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuTGFiZWxGaWx0ZXJzLFxuICAgICAgTG9raVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuTGluZUZpbHRlcnMsXG4gICAgXSk7XG4gIH1cblxuICByZW5kZXJMYWJlbHMobGFiZWxzOiBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcltdKSB7XG4gICAgaWYgKGxhYmVscy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAne30nO1xuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5yZW5kZXJMYWJlbHMobGFiZWxzKTtcbiAgfVxuXG4gIGdldFF1ZXJ5UGF0dGVybnMoKTogTG9raVF1ZXJ5UGF0dGVybltdIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICBuYW1lOiAnTG9nIHF1ZXJ5IGFuZCBsYWJlbCBmaWx0ZXInLFxuICAgICAgICBvcGVyYXRpb25zOiBbXG4gICAgICAgICAgeyBpZDogTG9raU9wZXJhdGlvbklkLkxpbmVNYXRjaGVzUmVnZXgsIHBhcmFtczogWycnXSB9LFxuICAgICAgICAgIHsgaWQ6IExva2lPcGVyYXRpb25JZC5Mb2dmbXQsIHBhcmFtczogW10gfSxcbiAgICAgICAgICB7IGlkOiBMb2tpT3BlcmF0aW9uSWQuTGFiZWxGaWx0ZXJOb0Vycm9ycywgcGFyYW1zOiBbXSB9LFxuICAgICAgICAgIHsgaWQ6IExva2lPcGVyYXRpb25JZC5MYWJlbEZpbHRlciwgcGFyYW1zOiBbJycsICc9JywgJyddIH0sXG4gICAgICAgIF0sXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAnVGltZSBzZXJpZXMgcXVlcnkgb24gdmFsdWUgaW5zaWRlIGxvZyBsaW5lJyxcbiAgICAgICAgb3BlcmF0aW9uczogW1xuICAgICAgICAgIHsgaWQ6IExva2lPcGVyYXRpb25JZC5MaW5lTWF0Y2hlc1JlZ2V4LCBwYXJhbXM6IFsnJ10gfSxcbiAgICAgICAgICB7IGlkOiBMb2tpT3BlcmF0aW9uSWQuTG9nZm10LCBwYXJhbXM6IFtdIH0sXG4gICAgICAgICAgeyBpZDogTG9raU9wZXJhdGlvbklkLkxhYmVsRmlsdGVyTm9FcnJvcnMsIHBhcmFtczogW10gfSxcbiAgICAgICAgICB7IGlkOiBMb2tpT3BlcmF0aW9uSWQuVW53cmFwLCBwYXJhbXM6IFsnJ10gfSxcbiAgICAgICAgICB7IGlkOiBMb2tpT3BlcmF0aW9uSWQuU3VtT3ZlclRpbWUsIHBhcmFtczogWyckX19pbnRlcnZhbCddIH0sXG4gICAgICAgICAgeyBpZDogTG9raU9wZXJhdGlvbklkLlN1bSwgcGFyYW1zOiBbXSB9LFxuICAgICAgICBdLFxuICAgICAgfSxcbiAgICBdO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBsb2tpUXVlcnlNb2RlbGxlciA9IG5ldyBMb2tpUXVlcnlNb2RlbGxlcigpO1xuIiwiaW1wb3J0IHsgZGVmYXVsdEFkZE9wZXJhdGlvbkhhbmRsZXIgfSBmcm9tICcuLi8uLi9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvb3BlcmF0aW9uVXRpbHMnO1xuaW1wb3J0IHtcbiAgUXVlcnlCdWlsZGVyT3BlcmF0aW9uLFxuICBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsXG4gIFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmLFxufSBmcm9tICcuLi8uLi9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvdHlwZXMnO1xuXG5pbXBvcnQgeyBMb2tpT3BlcmF0aW9uSWQsIExva2lWaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5IH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBjb25zdCBiaW5hcnlTY2FsYXJEZWZzID0gW1xuICB7XG4gICAgaWQ6IExva2lPcGVyYXRpb25JZC5BZGRpdGlvbixcbiAgICBuYW1lOiAnQWRkIHNjYWxhcicsXG4gICAgc2lnbjogJysnLFxuICB9LFxuICB7XG4gICAgaWQ6IExva2lPcGVyYXRpb25JZC5TdWJ0cmFjdGlvbixcbiAgICBuYW1lOiAnU3VidHJhY3Qgc2NhbGFyJyxcbiAgICBzaWduOiAnLScsXG4gIH0sXG4gIHtcbiAgICBpZDogTG9raU9wZXJhdGlvbklkLk11bHRpcGx5QnksXG4gICAgbmFtZTogJ011bHRpcGx5IGJ5IHNjYWxhcicsXG4gICAgc2lnbjogJyonLFxuICB9LFxuICB7XG4gICAgaWQ6IExva2lPcGVyYXRpb25JZC5EaXZpZGVCeSxcbiAgICBuYW1lOiAnRGl2aWRlIGJ5IHNjYWxhcicsXG4gICAgc2lnbjogJy8nLFxuICB9LFxuICB7XG4gICAgaWQ6IExva2lPcGVyYXRpb25JZC5Nb2R1bG8sXG4gICAgbmFtZTogJ01vZHVsbyBieSBzY2FsYXInLFxuICAgIHNpZ246ICclJyxcbiAgfSxcbiAge1xuICAgIGlkOiBMb2tpT3BlcmF0aW9uSWQuRXhwb25lbnQsXG4gICAgbmFtZTogJ0V4cG9uZW50JyxcbiAgICBzaWduOiAnXicsXG4gIH0sXG4gIHtcbiAgICBpZDogTG9raU9wZXJhdGlvbklkLkVxdWFsVG8sXG4gICAgbmFtZTogJ0VxdWFsIHRvJyxcbiAgICBzaWduOiAnPT0nLFxuICAgIGNvbXBhcmlzb246IHRydWUsXG4gIH0sXG4gIHtcbiAgICBpZDogTG9raU9wZXJhdGlvbklkLk5vdEVxdWFsVG8sXG4gICAgbmFtZTogJ05vdCBlcXVhbCB0bycsXG4gICAgc2lnbjogJyE9JyxcbiAgICBjb21wYXJpc29uOiB0cnVlLFxuICB9LFxuICB7XG4gICAgaWQ6IExva2lPcGVyYXRpb25JZC5HcmVhdGVyVGhhbixcbiAgICBuYW1lOiAnR3JlYXRlciB0aGFuJyxcbiAgICBzaWduOiAnPicsXG4gICAgY29tcGFyaXNvbjogdHJ1ZSxcbiAgfSxcbiAge1xuICAgIGlkOiBMb2tpT3BlcmF0aW9uSWQuTGVzc1RoYW4sXG4gICAgbmFtZTogJ0xlc3MgdGhhbicsXG4gICAgc2lnbjogJzwnLFxuICAgIGNvbXBhcmlzb246IHRydWUsXG4gIH0sXG4gIHtcbiAgICBpZDogTG9raU9wZXJhdGlvbklkLkdyZWF0ZXJPckVxdWFsLFxuICAgIG5hbWU6ICdHcmVhdGVyIG9yIGVxdWFsIHRvJyxcbiAgICBzaWduOiAnPj0nLFxuICAgIGNvbXBhcmlzb246IHRydWUsXG4gIH0sXG4gIHtcbiAgICBpZDogTG9raU9wZXJhdGlvbklkLkxlc3NPckVxdWFsLFxuICAgIG5hbWU6ICdMZXNzIG9yIGVxdWFsIHRvJyxcbiAgICBzaWduOiAnPD0nLFxuICAgIGNvbXBhcmlzb246IHRydWUsXG4gIH0sXG5dO1xuXG4vLyBOb3Qgc3VyZSBhYm91dCB0aGlzIG9uZS4gSXQgY291bGQgYWxzbyBiZSBhIG1vcmUgZ2VuZXJpYyAnU2ltcGxlIG1hdGggb3BlcmF0aW9uJyB3aGVyZSB1c2VyIHNwZWNpZmllc1xuLy8gYm90aCB0aGUgb3BlcmF0b3IgYW5kIHRoZSBvcGVyYW5kIGluIGEgc2luZ2xlIGlucHV0XG5leHBvcnQgY29uc3QgYmluYXJ5U2NhbGFyT3BlcmF0aW9uczogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmW10gPSBiaW5hcnlTY2FsYXJEZWZzLm1hcCgob3BEZWYpID0+IHtcbiAgY29uc3QgcGFyYW1zOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbURlZltdID0gW3sgbmFtZTogJ1ZhbHVlJywgdHlwZTogJ251bWJlcicgfV07XG4gIGNvbnN0IGRlZmF1bHRQYXJhbXM6IGFueVtdID0gWzJdO1xuICBpZiAob3BEZWYuY29tcGFyaXNvbikge1xuICAgIHBhcmFtcy51bnNoaWZ0KHtcbiAgICAgIG5hbWU6ICdCb29sJyxcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnSWYgY2hlY2tlZCBjb21wYXJpc29uIHdpbGwgcmV0dXJuIDAgb3IgMSBmb3IgdGhlIHZhbHVlIHJhdGhlciB0aGFuIGZpbHRlcmluZy4nLFxuICAgIH0pO1xuICAgIGRlZmF1bHRQYXJhbXMudW5zaGlmdChmYWxzZSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGlkOiBvcERlZi5pZCxcbiAgICBuYW1lOiBvcERlZi5uYW1lLFxuICAgIHBhcmFtcyxcbiAgICBkZWZhdWx0UGFyYW1zLFxuICAgIGFsdGVybmF0aXZlc0tleTogJ2JpbmFyeSBzY2FsYXIgb3BlcmF0aW9ucycsXG4gICAgY2F0ZWdvcnk6IExva2lWaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkJpbmFyeU9wcyxcbiAgICByZW5kZXJlcjogZ2V0U2ltcGxlQmluYXJ5UmVuZGVyZXIob3BEZWYuc2lnbiksXG4gICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogZGVmYXVsdEFkZE9wZXJhdGlvbkhhbmRsZXIsXG4gIH07XG59KTtcblxuZnVuY3Rpb24gZ2V0U2ltcGxlQmluYXJ5UmVuZGVyZXIob3BlcmF0b3I6IHN0cmluZykge1xuICByZXR1cm4gZnVuY3Rpb24gYmluYXJ5UmVuZGVyZXIobW9kZWw6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiwgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsIGlubmVyRXhwcjogc3RyaW5nKSB7XG4gICAgbGV0IHBhcmFtID0gbW9kZWwucGFyYW1zWzBdO1xuICAgIGxldCBib29sID0gJyc7XG4gICAgaWYgKG1vZGVsLnBhcmFtcy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHBhcmFtID0gbW9kZWwucGFyYW1zWzFdO1xuICAgICAgYm9vbCA9IG1vZGVsLnBhcmFtc1swXSA/ICcgYm9vbCcgOiAnJztcbiAgICB9XG5cbiAgICByZXR1cm4gYCR7aW5uZXJFeHByfSAke29wZXJhdG9yfSR7Ym9vbH0gJHtwYXJhbX1gO1xuICB9O1xufVxuIiwiaW1wb3J0IFJlYWN0LCB7IHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IERhdGFTb3VyY2VBcGksIFNlbGVjdGFibGVWYWx1ZSB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgRWRpdG9yUm93IH0gZnJvbSAnQGdyYWZhbmEvZXhwZXJpbWVudGFsJztcbmltcG9ydCB7IExhYmVsRmlsdGVycyB9IGZyb20gJ2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL0xhYmVsRmlsdGVycyc7XG5pbXBvcnQgeyBPcGVyYXRpb25MaXN0IH0gZnJvbSAnYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvT3BlcmF0aW9uTGlzdCc7XG5pbXBvcnQgeyBPcGVyYXRpb25zRWRpdG9yUm93IH0gZnJvbSAnYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvT3BlcmF0aW9uc0VkaXRvclJvdyc7XG5pbXBvcnQgeyBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlciB9IGZyb20gJ2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL3R5cGVzJztcblxuaW1wb3J0IHsgTG9raURhdGFzb3VyY2UgfSBmcm9tICcuLi8uLi9kYXRhc291cmNlJztcbmltcG9ydCB7IGVzY2FwZUxhYmVsVmFsdWVJblNlbGVjdG9yIH0gZnJvbSAnLi4vLi4vbGFuZ3VhZ2VfdXRpbHMnO1xuaW1wb3J0IHsgbG9raVF1ZXJ5TW9kZWxsZXIgfSBmcm9tICcuLi9Mb2tpUXVlcnlNb2RlbGxlcic7XG5pbXBvcnQgeyBMb2tpT3BlcmF0aW9uSWQsIExva2lWaXN1YWxRdWVyeSB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgTmVzdGVkUXVlcnlMaXN0IH0gZnJvbSAnLi9OZXN0ZWRRdWVyeUxpc3QnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgcXVlcnk6IExva2lWaXN1YWxRdWVyeTtcbiAgZGF0YXNvdXJjZTogTG9raURhdGFzb3VyY2U7XG4gIG9uQ2hhbmdlOiAodXBkYXRlOiBMb2tpVmlzdWFsUXVlcnkpID0+IHZvaWQ7XG4gIG9uUnVuUXVlcnk6ICgpID0+IHZvaWQ7XG4gIG5lc3RlZD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjb25zdCBMb2tpUXVlcnlCdWlsZGVyID0gUmVhY3QubWVtbzxQcm9wcz4oKHsgZGF0YXNvdXJjZSwgcXVlcnksIG5lc3RlZCwgb25DaGFuZ2UsIG9uUnVuUXVlcnkgfSkgPT4ge1xuICBjb25zdCBvbkNoYW5nZUxhYmVscyA9IChsYWJlbHM6IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyW10pID0+IHtcbiAgICBvbkNoYW5nZSh7IC4uLnF1ZXJ5LCBsYWJlbHMgfSk7XG4gIH07XG5cbiAgY29uc3Qgd2l0aFRlbXBsYXRlVmFyaWFibGVPcHRpb25zID0gYXN5bmMgKG9wdGlvbnNQcm9taXNlOiBQcm9taXNlPHN0cmluZ1tdPik6IFByb21pc2U8U2VsZWN0YWJsZVZhbHVlW10+ID0+IHtcbiAgICBjb25zdCBvcHRpb25zID0gYXdhaXQgb3B0aW9uc1Byb21pc2U7XG4gICAgcmV0dXJuIFsuLi5kYXRhc291cmNlLmdldFZhcmlhYmxlcygpLCAuLi5vcHRpb25zXS5tYXAoKHZhbHVlKSA9PiAoeyBsYWJlbDogdmFsdWUsIHZhbHVlIH0pKTtcbiAgfTtcblxuICBjb25zdCBvbkdldExhYmVsTmFtZXMgPSBhc3luYyAoZm9yTGFiZWw6IFBhcnRpYWw8UXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXI+KTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgICBjb25zdCBsYWJlbHNUb0NvbnNpZGVyID0gcXVlcnkubGFiZWxzLmZpbHRlcigoeCkgPT4geCAhPT0gZm9yTGFiZWwpO1xuXG4gICAgaWYgKGxhYmVsc1RvQ29uc2lkZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICBhd2FpdCBkYXRhc291cmNlLmxhbmd1YWdlUHJvdmlkZXIucmVmcmVzaExvZ0xhYmVscygpO1xuICAgICAgcmV0dXJuIGRhdGFzb3VyY2UubGFuZ3VhZ2VQcm92aWRlci5nZXRMYWJlbEtleXMoKTtcbiAgICB9XG5cbiAgICBjb25zdCBleHByID0gbG9raVF1ZXJ5TW9kZWxsZXIucmVuZGVyTGFiZWxzKGxhYmVsc1RvQ29uc2lkZXIpO1xuICAgIGNvbnN0IHNlcmllcyA9IGF3YWl0IGRhdGFzb3VyY2UubGFuZ3VhZ2VQcm92aWRlci5mZXRjaFNlcmllc0xhYmVscyhleHByKTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoc2VyaWVzKS5zb3J0KCk7XG4gIH07XG5cbiAgY29uc3Qgb25HZXRMYWJlbFZhbHVlcyA9IGFzeW5jIChmb3JMYWJlbDogUGFydGlhbDxRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcj4pID0+IHtcbiAgICBpZiAoIWZvckxhYmVsLmxhYmVsKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgbGV0IHZhbHVlcztcbiAgICBjb25zdCBsYWJlbHNUb0NvbnNpZGVyID0gcXVlcnkubGFiZWxzLmZpbHRlcigoeCkgPT4geCAhPT0gZm9yTGFiZWwpO1xuICAgIGlmIChsYWJlbHNUb0NvbnNpZGVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdmFsdWVzID0gYXdhaXQgZGF0YXNvdXJjZS5sYW5ndWFnZVByb3ZpZGVyLmZldGNoTGFiZWxWYWx1ZXMoZm9yTGFiZWwubGFiZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBleHByID0gbG9raVF1ZXJ5TW9kZWxsZXIucmVuZGVyTGFiZWxzKGxhYmVsc1RvQ29uc2lkZXIpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZGF0YXNvdXJjZS5sYW5ndWFnZVByb3ZpZGVyLmZldGNoU2VyaWVzTGFiZWxzKGV4cHIpO1xuICAgICAgdmFsdWVzID0gcmVzdWx0W2RhdGFzb3VyY2UuaW50ZXJwb2xhdGVTdHJpbmcoZm9yTGFiZWwubGFiZWwpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVzID8gdmFsdWVzLm1hcCgodikgPT4gZXNjYXBlTGFiZWxWYWx1ZUluU2VsZWN0b3IodiwgZm9yTGFiZWwub3ApKSA6IFtdOyAvLyBFc2NhcGUgdmFsdWVzIGluIHJldHVyblxuICB9O1xuXG4gIGNvbnN0IGxhYmVsRmlsdGVyRXJyb3I6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHsgbGFiZWxzLCBvcGVyYXRpb25zOiBvcCB9ID0gcXVlcnk7XG4gICAgaWYgKCFsYWJlbHMubGVuZ3RoICYmIG9wLmxlbmd0aCkge1xuICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBzaG93IGVycm9yIGZvciBpbml0aWFsIHN0YXRlIHdpdGggZW1wdHkgbGluZSBjb250YWlucyBvcGVyYXRpb25cbiAgICAgIGlmIChvcC5sZW5ndGggPT09IDEgJiYgb3BbMF0uaWQgPT09IExva2lPcGVyYXRpb25JZC5MaW5lQ29udGFpbnMgJiYgb3BbMF0ucGFyYW1zWzBdID09PSAnJykge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuICdZb3UgbmVlZCB0byBzcGVjaWZ5IGF0IGxlYXN0IDEgbGFiZWwgZmlsdGVyIChzdHJlYW0gc2VsZWN0b3IpJztcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSwgW3F1ZXJ5XSk7XG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPEVkaXRvclJvdz5cbiAgICAgICAgPExhYmVsRmlsdGVyc1xuICAgICAgICAgIG9uR2V0TGFiZWxOYW1lcz17KGZvckxhYmVsOiBQYXJ0aWFsPFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyPikgPT5cbiAgICAgICAgICAgIHdpdGhUZW1wbGF0ZVZhcmlhYmxlT3B0aW9ucyhvbkdldExhYmVsTmFtZXMoZm9yTGFiZWwpKVxuICAgICAgICAgIH1cbiAgICAgICAgICBvbkdldExhYmVsVmFsdWVzPXsoZm9yTGFiZWw6IFBhcnRpYWw8UXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXI+KSA9PlxuICAgICAgICAgICAgd2l0aFRlbXBsYXRlVmFyaWFibGVPcHRpb25zKG9uR2V0TGFiZWxWYWx1ZXMoZm9yTGFiZWwpKVxuICAgICAgICAgIH1cbiAgICAgICAgICBsYWJlbHNGaWx0ZXJzPXtxdWVyeS5sYWJlbHN9XG4gICAgICAgICAgb25DaGFuZ2U9e29uQ2hhbmdlTGFiZWxzfVxuICAgICAgICAgIGVycm9yPXtsYWJlbEZpbHRlckVycm9yfVxuICAgICAgICAvPlxuICAgICAgPC9FZGl0b3JSb3c+XG4gICAgICA8T3BlcmF0aW9uc0VkaXRvclJvdz5cbiAgICAgICAgPE9wZXJhdGlvbkxpc3RcbiAgICAgICAgICBxdWVyeU1vZGVsbGVyPXtsb2tpUXVlcnlNb2RlbGxlcn1cbiAgICAgICAgICBxdWVyeT17cXVlcnl9XG4gICAgICAgICAgb25DaGFuZ2U9e29uQ2hhbmdlfVxuICAgICAgICAgIG9uUnVuUXVlcnk9e29uUnVuUXVlcnl9XG4gICAgICAgICAgZGF0YXNvdXJjZT17ZGF0YXNvdXJjZSBhcyBEYXRhU291cmNlQXBpfVxuICAgICAgICAvPlxuICAgICAgPC9PcGVyYXRpb25zRWRpdG9yUm93PlxuICAgICAge3F1ZXJ5LmJpbmFyeVF1ZXJpZXMgJiYgcXVlcnkuYmluYXJ5UXVlcmllcy5sZW5ndGggPiAwICYmIChcbiAgICAgICAgPE5lc3RlZFF1ZXJ5TGlzdCBxdWVyeT17cXVlcnl9IGRhdGFzb3VyY2U9e2RhdGFzb3VyY2V9IG9uQ2hhbmdlPXtvbkNoYW5nZX0gb25SdW5RdWVyeT17b25SdW5RdWVyeX0gLz5cbiAgICAgICl9XG4gICAgPC8+XG4gICk7XG59KTtcblxuTG9raVF1ZXJ5QnVpbGRlci5kaXNwbGF5TmFtZSA9ICdMb2tpUXVlcnlCdWlsZGVyJztcbiIsImltcG9ydCB7IGNyZWF0ZVNsaWNlLCBQYXlsb2FkQWN0aW9uIH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdCc7XG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VSZWR1Y2VyIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBMb2tpRGF0YXNvdXJjZSB9IGZyb20gJy4uLy4uL2RhdGFzb3VyY2UnO1xuaW1wb3J0IHsgTG9raVF1ZXJ5IH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuaW1wb3J0IHsgbG9raVF1ZXJ5TW9kZWxsZXIgfSBmcm9tICcuLi9Mb2tpUXVlcnlNb2RlbGxlcic7XG5pbXBvcnQgeyBidWlsZFZpc3VhbFF1ZXJ5RnJvbVN0cmluZyB9IGZyb20gJy4uL3BhcnNpbmcnO1xuaW1wb3J0IHsgTG9raVZpc3VhbFF1ZXJ5IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBMb2tpUXVlcnlCdWlsZGVyIH0gZnJvbSAnLi9Mb2tpUXVlcnlCdWlsZGVyJztcbmltcG9ydCB7IFF1ZXJ5UHJldmlldyB9IGZyb20gJy4vUXVlcnlQcmV2aWV3JztcblxuZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gIHF1ZXJ5OiBMb2tpUXVlcnk7XG4gIGRhdGFzb3VyY2U6IExva2lEYXRhc291cmNlO1xuICBvbkNoYW5nZTogKHVwZGF0ZTogTG9raVF1ZXJ5KSA9PiB2b2lkO1xuICBvblJ1blF1ZXJ5OiAoKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRlIHtcbiAgdmlzUXVlcnk/OiBMb2tpVmlzdWFsUXVlcnk7XG4gIGV4cHI6IHN0cmluZztcbn1cblxuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCBpcyBoZXJlIGp1c3QgdG8gY29udGFpbiB0aGUgdHJhbnNsYXRpb24gbG9naWMgYmV0d2VlbiBzdHJpbmcgcXVlcnkgYW5kIHRoZSB2aXN1YWwgcXVlcnkgYnVpbGRlciBtb2RlbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIExva2lRdWVyeUJ1aWxkZXJDb250YWluZXIocHJvcHM6IFByb3BzKSB7XG4gIGNvbnN0IHsgcXVlcnksIG9uQ2hhbmdlLCBvblJ1blF1ZXJ5LCBkYXRhc291cmNlIH0gPSBwcm9wcztcbiAgY29uc3QgW3N0YXRlLCBkaXNwYXRjaF0gPSB1c2VSZWR1Y2VyKHN0YXRlU2xpY2UucmVkdWNlciwge1xuICAgIGV4cHI6IHF1ZXJ5LmV4cHIsXG4gICAgLy8gVXNlIGluaXRpYWwgdmlzdWFsIHF1ZXJ5IG9ubHkgaWYgcXVlcnkuZXhwciBpcyBlbXB0eSBzdHJpbmdcbiAgICB2aXNRdWVyeTpcbiAgICAgIHF1ZXJ5LmV4cHIgPT09ICcnXG4gICAgICAgID8ge1xuICAgICAgICAgICAgbGFiZWxzOiBbXSxcbiAgICAgICAgICAgIG9wZXJhdGlvbnM6IFt7IGlkOiAnX19saW5lX2NvbnRhaW5zJywgcGFyYW1zOiBbJyddIH1dLFxuICAgICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQsXG4gIH0pO1xuXG4gIC8vIE9ubHkgcmVidWlsZCB2aXN1YWwgcXVlcnkgaWYgZXhwciBjaGFuZ2VzIGZyb20gb3V0c2lkZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGRpc3BhdGNoKGV4cHJDaGFuZ2VkKHF1ZXJ5LmV4cHIpKTtcbiAgfSwgW3F1ZXJ5LmV4cHJdKTtcblxuICBjb25zdCBvblZpc1F1ZXJ5Q2hhbmdlID0gKHZpc1F1ZXJ5OiBMb2tpVmlzdWFsUXVlcnkpID0+IHtcbiAgICBjb25zdCBleHByID0gbG9raVF1ZXJ5TW9kZWxsZXIucmVuZGVyUXVlcnkodmlzUXVlcnkpO1xuICAgIGRpc3BhdGNoKHZpc3VhbFF1ZXJ5Q2hhbmdlKHsgdmlzUXVlcnksIGV4cHIgfSkpO1xuICAgIG9uQ2hhbmdlKHsgLi4ucHJvcHMucXVlcnksIGV4cHI6IGV4cHIgfSk7XG4gIH07XG5cbiAgaWYgKCFzdGF0ZS52aXNRdWVyeSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPExva2lRdWVyeUJ1aWxkZXJcbiAgICAgICAgcXVlcnk9e3N0YXRlLnZpc1F1ZXJ5fVxuICAgICAgICBkYXRhc291cmNlPXtkYXRhc291cmNlfVxuICAgICAgICBvbkNoYW5nZT17b25WaXNRdWVyeUNoYW5nZX1cbiAgICAgICAgb25SdW5RdWVyeT17b25SdW5RdWVyeX1cbiAgICAgIC8+XG4gICAgICB7cXVlcnkucmF3UXVlcnkgJiYgPFF1ZXJ5UHJldmlldyBxdWVyeT17cXVlcnkuZXhwcn0gLz59XG4gICAgPC8+XG4gICk7XG59XG5cbmNvbnN0IHN0YXRlU2xpY2UgPSBjcmVhdGVTbGljZSh7XG4gIG5hbWU6ICdsb2tpLWJ1aWxkZXItY29udGFpbmVyJyxcbiAgaW5pdGlhbFN0YXRlOiB7IGV4cHI6ICcnIH0gYXMgU3RhdGUsXG4gIHJlZHVjZXJzOiB7XG4gICAgdmlzdWFsUXVlcnlDaGFuZ2U6IChzdGF0ZSwgYWN0aW9uOiBQYXlsb2FkQWN0aW9uPHsgdmlzUXVlcnk6IExva2lWaXN1YWxRdWVyeTsgZXhwcjogc3RyaW5nIH0+KSA9PiB7XG4gICAgICBzdGF0ZS5leHByID0gYWN0aW9uLnBheWxvYWQuZXhwcjtcbiAgICAgIHN0YXRlLnZpc1F1ZXJ5ID0gYWN0aW9uLnBheWxvYWQudmlzUXVlcnk7XG4gICAgfSxcbiAgICBleHByQ2hhbmdlZDogKHN0YXRlLCBhY3Rpb246IFBheWxvYWRBY3Rpb248c3RyaW5nPikgPT4ge1xuICAgICAgaWYgKCFzdGF0ZS52aXNRdWVyeSB8fCBzdGF0ZS5leHByICE9PSBhY3Rpb24ucGF5bG9hZCkge1xuICAgICAgICBzdGF0ZS5leHByID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gYnVpbGRWaXN1YWxRdWVyeUZyb21TdHJpbmcoYWN0aW9uLnBheWxvYWQpO1xuICAgICAgICBzdGF0ZS52aXNRdWVyeSA9IHBhcnNlUmVzdWx0LnF1ZXJ5O1xuICAgICAgfVxuICAgIH0sXG4gIH0sXG59KTtcblxuY29uc3QgeyB2aXN1YWxRdWVyeUNoYW5nZSwgZXhwckNoYW5nZWQgfSA9IHN0YXRlU2xpY2UuYWN0aW9ucztcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IFN0YWNrIH0gZnJvbSAnQGdyYWZhbmEvZXhwZXJpbWVudGFsJztcbmltcG9ydCB7IE9wZXJhdGlvbkV4cGxhaW5lZEJveCB9IGZyb20gJ2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL09wZXJhdGlvbkV4cGxhaW5lZEJveCc7XG5pbXBvcnQgeyBPcGVyYXRpb25MaXN0RXhwbGFpbmVkIH0gZnJvbSAnYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvT3BlcmF0aW9uTGlzdEV4cGxhaW5lZCc7XG5cbmltcG9ydCB7IGxva2lRdWVyeU1vZGVsbGVyIH0gZnJvbSAnLi4vTG9raVF1ZXJ5TW9kZWxsZXInO1xuaW1wb3J0IHsgYnVpbGRWaXN1YWxRdWVyeUZyb21TdHJpbmcgfSBmcm9tICcuLi9wYXJzaW5nJztcbmltcG9ydCB7IExva2lWaXN1YWxRdWVyeSB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gIHF1ZXJ5OiBzdHJpbmc7XG4gIG5lc3RlZD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjb25zdCBMb2tpUXVlcnlCdWlsZGVyRXhwbGFpbmVkID0gUmVhY3QubWVtbzxQcm9wcz4oKHsgcXVlcnksIG5lc3RlZCB9KSA9PiB7XG4gIGNvbnN0IHZpc1F1ZXJ5ID0gYnVpbGRWaXN1YWxRdWVyeUZyb21TdHJpbmcocXVlcnkgfHwgJycpLnF1ZXJ5O1xuXG4gIHJldHVybiAoXG4gICAgPFN0YWNrIGdhcD17MH0gZGlyZWN0aW9uPVwiY29sdW1uXCI+XG4gICAgICA8T3BlcmF0aW9uRXhwbGFpbmVkQm94IHN0ZXBOdW1iZXI9ezF9IHRpdGxlPXtgJHtsb2tpUXVlcnlNb2RlbGxlci5yZW5kZXJMYWJlbHModmlzUXVlcnkubGFiZWxzKX1gfT5cbiAgICAgICAgRmV0Y2ggYWxsIGxvZyBsaW5lcyBtYXRjaGluZyBsYWJlbCBmaWx0ZXJzLlxuICAgICAgPC9PcGVyYXRpb25FeHBsYWluZWRCb3g+XG4gICAgICA8T3BlcmF0aW9uTGlzdEV4cGxhaW5lZDxMb2tpVmlzdWFsUXVlcnk+IHN0ZXBOdW1iZXI9ezJ9IHF1ZXJ5TW9kZWxsZXI9e2xva2lRdWVyeU1vZGVsbGVyfSBxdWVyeT17dmlzUXVlcnl9IC8+XG4gICAgPC9TdGFjaz5cbiAgKTtcbn0pO1xuXG5Mb2tpUXVlcnlCdWlsZGVyRXhwbGFpbmVkLmRpc3BsYXlOYW1lID0gJ0xva2lRdWVyeUJ1aWxkZXJFeHBsYWluZWQnO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgU2VsZWN0YWJsZVZhbHVlIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBFZGl0b3JSb3csIEVkaXRvckZpZWxkIH0gZnJvbSAnQGdyYWZhbmEvZXhwZXJpbWVudGFsJztcbmltcG9ydCB7IFJhZGlvQnV0dG9uR3JvdXAsIFNlbGVjdCB9IGZyb20gJ0BncmFmYW5hL3VpJztcbmltcG9ydCB7IEF1dG9TaXplSW5wdXQgfSBmcm9tICdhcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9BdXRvU2l6ZUlucHV0JztcbmltcG9ydCB7IFF1ZXJ5T3B0aW9uR3JvdXAgfSBmcm9tICdhcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9RdWVyeU9wdGlvbkdyb3VwJztcblxuaW1wb3J0IHsgcHJlcHJvY2Vzc01heExpbmVzLCBxdWVyeVR5cGVPcHRpb25zLCBSRVNPTFVUSU9OX09QVElPTlMgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL0xva2lPcHRpb25GaWVsZHMnO1xuaW1wb3J0IHsgaXNNZXRyaWNzUXVlcnkgfSBmcm9tICcuLi8uLi9kYXRhc291cmNlJztcbmltcG9ydCB7IExva2lRdWVyeSwgTG9raVF1ZXJ5VHlwZSB9IGZyb20gJy4uLy4uL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gIHF1ZXJ5OiBMb2tpUXVlcnk7XG4gIG9uQ2hhbmdlOiAodXBkYXRlOiBMb2tpUXVlcnkpID0+IHZvaWQ7XG4gIG9uUnVuUXVlcnk6ICgpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBjb25zdCBMb2tpUXVlcnlCdWlsZGVyT3B0aW9ucyA9IFJlYWN0Lm1lbW88UHJvcHM+KCh7IHF1ZXJ5LCBvbkNoYW5nZSwgb25SdW5RdWVyeSB9KSA9PiB7XG4gIGNvbnN0IG9uUXVlcnlUeXBlQ2hhbmdlID0gKHZhbHVlOiBMb2tpUXVlcnlUeXBlKSA9PiB7XG4gICAgb25DaGFuZ2UoeyAuLi5xdWVyeSwgcXVlcnlUeXBlOiB2YWx1ZSB9KTtcbiAgICBvblJ1blF1ZXJ5KCk7XG4gIH07XG5cbiAgY29uc3Qgb25SZXNvbHV0aW9uQ2hhbmdlID0gKG9wdGlvbjogU2VsZWN0YWJsZVZhbHVlPG51bWJlcj4pID0+IHtcbiAgICBvbkNoYW5nZSh7IC4uLnF1ZXJ5LCByZXNvbHV0aW9uOiBvcHRpb24udmFsdWUgfSk7XG4gICAgb25SdW5RdWVyeSgpO1xuICB9O1xuXG4gIGNvbnN0IG9uTGVnZW5kRm9ybWF0Q2hhbmdlZCA9IChldnQ6IFJlYWN0LkZvcm1FdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgIG9uQ2hhbmdlKHsgLi4ucXVlcnksIGxlZ2VuZEZvcm1hdDogZXZ0LmN1cnJlbnRUYXJnZXQudmFsdWUgfSk7XG4gICAgb25SdW5RdWVyeSgpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG9uTWF4TGluZXNDaGFuZ2UoZTogUmVhY3QuU3ludGhldGljRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pIHtcbiAgICBjb25zdCBuZXdNYXhMaW5lcyA9IHByZXByb2Nlc3NNYXhMaW5lcyhlLmN1cnJlbnRUYXJnZXQudmFsdWUpO1xuICAgIGlmIChxdWVyeS5tYXhMaW5lcyAhPT0gbmV3TWF4TGluZXMpIHtcbiAgICAgIG9uQ2hhbmdlKHsgLi4ucXVlcnksIG1heExpbmVzOiBuZXdNYXhMaW5lcyB9KTtcbiAgICAgIG9uUnVuUXVlcnkoKTtcbiAgICB9XG4gIH1cblxuICBsZXQgcXVlcnlUeXBlID0gcXVlcnkucXVlcnlUeXBlID8/IChxdWVyeS5pbnN0YW50ID8gTG9raVF1ZXJ5VHlwZS5JbnN0YW50IDogTG9raVF1ZXJ5VHlwZS5SYW5nZSk7XG4gIGxldCBzaG93TWF4TGluZXMgPSAhaXNNZXRyaWNzUXVlcnkocXVlcnkuZXhwcik7XG5cbiAgcmV0dXJuIChcbiAgICA8RWRpdG9yUm93PlxuICAgICAgPFF1ZXJ5T3B0aW9uR3JvdXAgdGl0bGU9XCJPcHRpb25zXCIgY29sbGFwc2VkSW5mbz17Z2V0Q29sbGFwc2VkSW5mbyhxdWVyeSwgcXVlcnlUeXBlLCBzaG93TWF4TGluZXMpfT5cbiAgICAgICAgPEVkaXRvckZpZWxkXG4gICAgICAgICAgbGFiZWw9XCJMZWdlbmRcIlxuICAgICAgICAgIHRvb2x0aXA9XCJTZXJpZXMgbmFtZSBvdmVycmlkZSBvciB0ZW1wbGF0ZS4gRXguIHt7aG9zdG5hbWV9fSB3aWxsIGJlIHJlcGxhY2VkIHdpdGggbGFiZWwgdmFsdWUgZm9yIGhvc3RuYW1lLlwiXG4gICAgICAgID5cbiAgICAgICAgICA8QXV0b1NpemVJbnB1dFxuICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJ7e2xhYmVsfX1cIlxuICAgICAgICAgICAgaWQ9XCJsb2tpLXF1ZXJ5LWVkaXRvci1sZWdlbmQtZm9ybWF0XCJcbiAgICAgICAgICAgIHR5cGU9XCJzdHJpbmdcIlxuICAgICAgICAgICAgbWluV2lkdGg9ezE0fVxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlPXtxdWVyeS5sZWdlbmRGb3JtYXR9XG4gICAgICAgICAgICBvbkNvbW1pdENoYW5nZT17b25MZWdlbmRGb3JtYXRDaGFuZ2VkfVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvRWRpdG9yRmllbGQ+XG4gICAgICAgIDxFZGl0b3JGaWVsZCBsYWJlbD1cIlR5cGVcIj5cbiAgICAgICAgICA8UmFkaW9CdXR0b25Hcm91cCBvcHRpb25zPXtxdWVyeVR5cGVPcHRpb25zfSB2YWx1ZT17cXVlcnlUeXBlfSBvbkNoYW5nZT17b25RdWVyeVR5cGVDaGFuZ2V9IC8+XG4gICAgICAgIDwvRWRpdG9yRmllbGQ+XG4gICAgICAgIHtzaG93TWF4TGluZXMgJiYgKFxuICAgICAgICAgIDxFZGl0b3JGaWVsZCBsYWJlbD1cIkxpbmUgbGltaXRcIiB0b29sdGlwPVwiVXBwZXIgbGltaXQgZm9yIG51bWJlciBvZiBsb2cgbGluZXMgcmV0dXJuZWQgYnkgcXVlcnkuXCI+XG4gICAgICAgICAgICA8QXV0b1NpemVJbnB1dFxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3aWR0aC00XCJcbiAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJhdXRvXCJcbiAgICAgICAgICAgICAgdHlwZT1cIm51bWJlclwiXG4gICAgICAgICAgICAgIG1pbj17MH1cbiAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlPXtxdWVyeS5tYXhMaW5lcz8udG9TdHJpbmcoKSA/PyAnJ31cbiAgICAgICAgICAgICAgb25Db21taXRDaGFuZ2U9e29uTWF4TGluZXNDaGFuZ2V9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvRWRpdG9yRmllbGQ+XG4gICAgICAgICl9XG4gICAgICAgIDxFZGl0b3JGaWVsZCBsYWJlbD1cIlJlc29sdXRpb25cIj5cbiAgICAgICAgICA8U2VsZWN0XG4gICAgICAgICAgICBpc1NlYXJjaGFibGU9e2ZhbHNlfVxuICAgICAgICAgICAgb25DaGFuZ2U9e29uUmVzb2x1dGlvbkNoYW5nZX1cbiAgICAgICAgICAgIG9wdGlvbnM9e1JFU09MVVRJT05fT1BUSU9OU31cbiAgICAgICAgICAgIHZhbHVlPXtxdWVyeS5yZXNvbHV0aW9uIHx8IDF9XG4gICAgICAgICAgICBhcmlhLWxhYmVsPVwiU2VsZWN0IHJlc29sdXRpb25cIlxuICAgICAgICAgIC8+XG4gICAgICAgIDwvRWRpdG9yRmllbGQ+XG4gICAgICA8L1F1ZXJ5T3B0aW9uR3JvdXA+XG4gICAgPC9FZGl0b3JSb3c+XG4gICk7XG59KTtcblxuZnVuY3Rpb24gZ2V0Q29sbGFwc2VkSW5mbyhxdWVyeTogTG9raVF1ZXJ5LCBxdWVyeVR5cGU6IExva2lRdWVyeVR5cGUsIHNob3dNYXhMaW5lczogYm9vbGVhbik6IHN0cmluZ1tdIHtcbiAgY29uc3QgcXVlcnlUeXBlTGFiZWwgPSBxdWVyeVR5cGVPcHRpb25zLmZpbmQoKHgpID0+IHgudmFsdWUgPT09IHF1ZXJ5VHlwZSk7XG4gIGNvbnN0IHJlc29sdXRpb25MYWJlbCA9IFJFU09MVVRJT05fT1BUSU9OUy5maW5kKCh4KSA9PiB4LnZhbHVlID09PSAocXVlcnkucmVzb2x1dGlvbiA/PyAxKSk7XG5cbiAgY29uc3QgaXRlbXM6IHN0cmluZ1tdID0gW107XG5cbiAgaWYgKHF1ZXJ5LmxlZ2VuZEZvcm1hdCkge1xuICAgIGl0ZW1zLnB1c2goYExlZ2VuZDogJHtxdWVyeS5sZWdlbmRGb3JtYXR9YCk7XG4gIH1cblxuICBpZiAocXVlcnkucmVzb2x1dGlvbikge1xuICAgIGl0ZW1zLnB1c2goYFJlc29sdXRpb246ICR7cmVzb2x1dGlvbkxhYmVsPy5sYWJlbH1gKTtcbiAgfVxuXG4gIGl0ZW1zLnB1c2goYFR5cGU6ICR7cXVlcnlUeXBlTGFiZWw/LmxhYmVsfWApO1xuXG4gIGlmIChzaG93TWF4TGluZXMgJiYgcXVlcnkubWF4TGluZXMpIHtcbiAgICBpdGVtcy5wdXNoKGBMaW5lIGxpbWl0OiAke3F1ZXJ5Lm1heExpbmVzfWApO1xuICB9XG5cbiAgcmV0dXJuIGl0ZW1zO1xufVxuXG5Mb2tpUXVlcnlCdWlsZGVyT3B0aW9ucy5kaXNwbGF5TmFtZSA9ICdMb2tpUXVlcnlCdWlsZGVyT3B0aW9ucyc7XG4iLCJpbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgR3JhZmFuYVRoZW1lMiB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgdXNlU3R5bGVzMiB9IGZyb20gJ0BncmFmYW5hL3VpJztcblxuaW1wb3J0IHsgdGVzdElkcyB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvTG9raVF1ZXJ5RWRpdG9yJztcbmltcG9ydCB7IExva2lRdWVyeUZpZWxkIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy9Mb2tpUXVlcnlGaWVsZCc7XG5pbXBvcnQgeyBMb2tpUXVlcnlFZGl0b3JQcm9wcyB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvdHlwZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gTG9raVF1ZXJ5Q29kZUVkaXRvcih7IHF1ZXJ5LCBkYXRhc291cmNlLCByYW5nZSwgb25SdW5RdWVyeSwgb25DaGFuZ2UsIGRhdGEgfTogTG9raVF1ZXJ5RWRpdG9yUHJvcHMpIHtcbiAgY29uc3Qgc3R5bGVzID0gdXNlU3R5bGVzMihnZXRTdHlsZXMpO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy53cmFwcGVyfT5cbiAgICAgIDxMb2tpUXVlcnlGaWVsZFxuICAgICAgICBkYXRhc291cmNlPXtkYXRhc291cmNlfVxuICAgICAgICBxdWVyeT17cXVlcnl9XG4gICAgICAgIHJhbmdlPXtyYW5nZX1cbiAgICAgICAgb25SdW5RdWVyeT17b25SdW5RdWVyeX1cbiAgICAgICAgb25DaGFuZ2U9e29uQ2hhbmdlfVxuICAgICAgICBoaXN0b3J5PXtbXX1cbiAgICAgICAgZGF0YT17ZGF0YX1cbiAgICAgICAgZGF0YS10ZXN0aWQ9e3Rlc3RJZHMuZWRpdG9yfVxuICAgICAgLz5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuY29uc3QgZ2V0U3R5bGVzID0gKHRoZW1lOiBHcmFmYW5hVGhlbWUyKSA9PiB7XG4gIHJldHVybiB7XG4gICAgLy8gVGhpcyB3cmFwcGVyIHN0eWxpbmcgY2FuIGJlIHJlbW92ZWQgYWZ0ZXIgdGhlIG9sZCBQcm9tUXVlcnlFZGl0b3IgaXMgcmVtb3ZlZC5cbiAgICAvLyBUaGlzIGlzIHJlbW92aW5nIG1hcmdpbiBib3R0b20gb24gdGhlIG9sZCBsZWdhY3kgaW5saW5lIGZvcm0gc3R5bGVzXG4gICAgd3JhcHBlcjogY3NzYFxuICAgICAgLmdmLWZvcm0ge1xuICAgICAgICBtYXJnaW4tYm90dG9tOiAwO1xuICAgICAgfVxuICAgIGAsXG4gIH07XG59O1xuIiwiaW1wb3J0IFJlYWN0LCB7IFN5bnRoZXRpY0V2ZW50LCB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgTG9hZGluZ1N0YXRlIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBFZGl0b3JIZWFkZXIsIEVkaXRvclJvd3MsIEZsZXhJdGVtLCBJbmxpbmVTZWxlY3QsIFNwYWNlIH0gZnJvbSAnQGdyYWZhbmEvZXhwZXJpbWVudGFsJztcbmltcG9ydCB7IEJ1dHRvbiwgQ29uZmlybU1vZGFsIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuaW1wb3J0IHsgUXVlcnlFZGl0b3JNb2RlVG9nZ2xlIH0gZnJvbSAnYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvUXVlcnlFZGl0b3JNb2RlVG9nZ2xlJztcbmltcG9ydCB7IFF1ZXJ5SGVhZGVyU3dpdGNoIH0gZnJvbSAnYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvUXVlcnlIZWFkZXJTd2l0Y2gnO1xuaW1wb3J0IHsgUXVlcnlFZGl0b3JNb2RlIH0gZnJvbSAnYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvdHlwZXMnO1xuXG5pbXBvcnQgeyBMb2tpUXVlcnlFZGl0b3JQcm9wcyB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvdHlwZXMnO1xuaW1wb3J0IHsgTG9raVF1ZXJ5IH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuaW1wb3J0IHsgbG9raVF1ZXJ5TW9kZWxsZXIgfSBmcm9tICcuLi9Mb2tpUXVlcnlNb2RlbGxlcic7XG5pbXBvcnQgeyBidWlsZFZpc3VhbFF1ZXJ5RnJvbVN0cmluZyB9IGZyb20gJy4uL3BhcnNpbmcnO1xuaW1wb3J0IHsgY2hhbmdlRWRpdG9yTW9kZSwgZ2V0UXVlcnlXaXRoRGVmYXVsdHMgfSBmcm9tICcuLi9zdGF0ZSc7XG5cbmltcG9ydCB7IExva2lRdWVyeUJ1aWxkZXJDb250YWluZXIgfSBmcm9tICcuL0xva2lRdWVyeUJ1aWxkZXJDb250YWluZXInO1xuaW1wb3J0IHsgTG9raVF1ZXJ5QnVpbGRlckV4cGxhaW5lZCB9IGZyb20gJy4vTG9raVF1ZXJ5QnVpbGRlckV4cGxhaW5lZCc7XG5pbXBvcnQgeyBMb2tpUXVlcnlCdWlsZGVyT3B0aW9ucyB9IGZyb20gJy4vTG9raVF1ZXJ5QnVpbGRlck9wdGlvbnMnO1xuaW1wb3J0IHsgTG9raVF1ZXJ5Q29kZUVkaXRvciB9IGZyb20gJy4vTG9raVF1ZXJ5Q29kZUVkaXRvcic7XG5cbmV4cG9ydCBjb25zdCBMb2tpUXVlcnlFZGl0b3JTZWxlY3RvciA9IFJlYWN0Lm1lbW88TG9raVF1ZXJ5RWRpdG9yUHJvcHM+KChwcm9wcykgPT4ge1xuICBjb25zdCB7IG9uQ2hhbmdlLCBvblJ1blF1ZXJ5LCBkYXRhIH0gPSBwcm9wcztcbiAgY29uc3QgW3BhcnNlTW9kYWxPcGVuLCBzZXRQYXJzZU1vZGFsT3Blbl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtkYXRhSXNTdGFsZSwgc2V0RGF0YUlzU3RhbGVdID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gIGNvbnN0IHF1ZXJ5ID0gZ2V0UXVlcnlXaXRoRGVmYXVsdHMocHJvcHMucXVlcnkpO1xuXG4gIGNvbnN0IG9uRWRpdG9yTW9kZUNoYW5nZSA9IHVzZUNhbGxiYWNrKFxuICAgIChuZXdFZGl0b3JNb2RlOiBRdWVyeUVkaXRvck1vZGUpID0+IHtcbiAgICAgIGlmIChuZXdFZGl0b3JNb2RlID09PSBRdWVyeUVkaXRvck1vZGUuQnVpbGRlcikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBidWlsZFZpc3VhbFF1ZXJ5RnJvbVN0cmluZyhxdWVyeS5leHByIHx8ICcnKTtcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGVycm9ycywgZ2l2ZSB1c2VyIGEgY2hhbmNlIHRvIGRlY2lkZSBpZiB0aGV5IHdhbnQgdG8gZ28gdG8gYnVpbGRlciBhcyB0aGF0IGNhbiBsb29zZSBzb21lIGRhdGEuXG4gICAgICAgIGlmIChyZXN1bHQuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgIHNldFBhcnNlTW9kYWxPcGVuKHRydWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hhbmdlRWRpdG9yTW9kZShxdWVyeSwgbmV3RWRpdG9yTW9kZSwgb25DaGFuZ2UpO1xuICAgIH0sXG4gICAgW29uQ2hhbmdlLCBxdWVyeV1cbiAgKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHNldERhdGFJc1N0YWxlKGZhbHNlKTtcbiAgfSwgW2RhdGFdKTtcblxuICBjb25zdCBvbkNoYW5nZUludGVybmFsID0gKHF1ZXJ5OiBMb2tpUXVlcnkpID0+IHtcbiAgICBzZXREYXRhSXNTdGFsZSh0cnVlKTtcbiAgICBvbkNoYW5nZShxdWVyeSk7XG4gIH07XG5cbiAgY29uc3Qgb25RdWVyeVByZXZpZXdDaGFuZ2UgPSAoZXZlbnQ6IFN5bnRoZXRpY0V2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3QgaXNFbmFibGVkID0gZXZlbnQuY3VycmVudFRhcmdldC5jaGVja2VkO1xuICAgIG9uQ2hhbmdlKHsgLi4ucXVlcnksIHJhd1F1ZXJ5OiBpc0VuYWJsZWQgfSk7XG4gIH07XG5cbiAgLy8gSWYgbm8gZXhwciAoaWUgbmV3IHF1ZXJ5KSB0aGVuIGRlZmF1bHQgdG8gYnVpbGRlclxuICBjb25zdCBlZGl0b3JNb2RlID0gcXVlcnkuZWRpdG9yTW9kZSA/PyAocXVlcnkuZXhwciA/IFF1ZXJ5RWRpdG9yTW9kZS5Db2RlIDogUXVlcnlFZGl0b3JNb2RlLkJ1aWxkZXIpO1xuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8Q29uZmlybU1vZGFsXG4gICAgICAgIGlzT3Blbj17cGFyc2VNb2RhbE9wZW59XG4gICAgICAgIHRpdGxlPVwiUXVlcnkgcGFyc2luZ1wiXG4gICAgICAgIGJvZHk9XCJUaGVyZSB3ZXJlIGVycm9ycyB3aGlsZSB0cnlpbmcgdG8gcGFyc2UgdGhlIHF1ZXJ5LiBDb250aW51aW5nIHRvIHZpc3VhbCBidWlsZGVyIG1heSBsb29zZSBzb21lIHBhcnRzIG9mIHRoZSBxdWVyeS5cIlxuICAgICAgICBjb25maXJtVGV4dD1cIkNvbnRpbnVlXCJcbiAgICAgICAgb25Db25maXJtPXsoKSA9PiB7XG4gICAgICAgICAgb25DaGFuZ2UoeyAuLi5xdWVyeSwgZWRpdG9yTW9kZTogUXVlcnlFZGl0b3JNb2RlLkJ1aWxkZXIgfSk7XG4gICAgICAgICAgc2V0UGFyc2VNb2RhbE9wZW4oZmFsc2UpO1xuICAgICAgICB9fVxuICAgICAgICBvbkRpc21pc3M9eygpID0+IHNldFBhcnNlTW9kYWxPcGVuKGZhbHNlKX1cbiAgICAgIC8+XG4gICAgICA8RWRpdG9ySGVhZGVyPlxuICAgICAgICB7ZWRpdG9yTW9kZSA9PT0gUXVlcnlFZGl0b3JNb2RlLkJ1aWxkZXIgJiYgKFxuICAgICAgICAgIDw+XG4gICAgICAgICAgICA8SW5saW5lU2VsZWN0XG4gICAgICAgICAgICAgIHZhbHVlPXtudWxsfVxuICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIlF1ZXJ5IHBhdHRlcm5zXCJcbiAgICAgICAgICAgICAgYWxsb3dDdXN0b21WYWx1ZVxuICAgICAgICAgICAgICBvbkNoYW5nZT17KHsgdmFsdWUgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGJ1aWxkVmlzdWFsUXVlcnlGcm9tU3RyaW5nKHF1ZXJ5LmV4cHIgfHwgJycpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5xdWVyeS5vcGVyYXRpb25zID0gdmFsdWU/Lm9wZXJhdGlvbnMhO1xuICAgICAgICAgICAgICAgIG9uQ2hhbmdlKHtcbiAgICAgICAgICAgICAgICAgIC4uLnF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgZXhwcjogbG9raVF1ZXJ5TW9kZWxsZXIucmVuZGVyUXVlcnkocmVzdWx0LnF1ZXJ5KSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgb3B0aW9ucz17bG9raVF1ZXJ5TW9kZWxsZXIuZ2V0UXVlcnlQYXR0ZXJucygpLm1hcCgoeCkgPT4gKHsgbGFiZWw6IHgubmFtZSwgdmFsdWU6IHggfSkpfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxRdWVyeUhlYWRlclN3aXRjaCBsYWJlbD1cIlJhdyBxdWVyeVwiIHZhbHVlPXtxdWVyeS5yYXdRdWVyeX0gb25DaGFuZ2U9e29uUXVlcnlQcmV2aWV3Q2hhbmdlfSAvPlxuICAgICAgICAgIDwvPlxuICAgICAgICApfVxuICAgICAgICA8RmxleEl0ZW0gZ3Jvdz17MX0gLz5cbiAgICAgICAgPEJ1dHRvblxuICAgICAgICAgIHZhcmlhbnQ9e2RhdGFJc1N0YWxlID8gJ3ByaW1hcnknIDogJ3NlY29uZGFyeSd9XG4gICAgICAgICAgc2l6ZT1cInNtXCJcbiAgICAgICAgICBvbkNsaWNrPXtvblJ1blF1ZXJ5fVxuICAgICAgICAgIGljb249e2RhdGE/LnN0YXRlID09PSBMb2FkaW5nU3RhdGUuTG9hZGluZyA/ICdmYSBmYS1zcGlubmVyJyA6IHVuZGVmaW5lZH1cbiAgICAgICAgICBkaXNhYmxlZD17ZGF0YT8uc3RhdGUgPT09IExvYWRpbmdTdGF0ZS5Mb2FkaW5nfVxuICAgICAgICA+XG4gICAgICAgICAgUnVuIHF1ZXJ5XG4gICAgICAgIDwvQnV0dG9uPlxuICAgICAgICA8UXVlcnlFZGl0b3JNb2RlVG9nZ2xlIG1vZGU9e2VkaXRvck1vZGUhfSBvbkNoYW5nZT17b25FZGl0b3JNb2RlQ2hhbmdlfSAvPlxuICAgICAgPC9FZGl0b3JIZWFkZXI+XG4gICAgICA8U3BhY2Ugdj17MC41fSAvPlxuICAgICAgPEVkaXRvclJvd3M+XG4gICAgICAgIHtlZGl0b3JNb2RlID09PSBRdWVyeUVkaXRvck1vZGUuQ29kZSAmJiA8TG9raVF1ZXJ5Q29kZUVkaXRvciB7Li4ucHJvcHN9IC8+fVxuICAgICAgICB7ZWRpdG9yTW9kZSA9PT0gUXVlcnlFZGl0b3JNb2RlLkJ1aWxkZXIgJiYgKFxuICAgICAgICAgIDxMb2tpUXVlcnlCdWlsZGVyQ29udGFpbmVyXG4gICAgICAgICAgICBkYXRhc291cmNlPXtwcm9wcy5kYXRhc291cmNlfVxuICAgICAgICAgICAgcXVlcnk9e3F1ZXJ5fVxuICAgICAgICAgICAgb25DaGFuZ2U9e29uQ2hhbmdlSW50ZXJuYWx9XG4gICAgICAgICAgICBvblJ1blF1ZXJ5PXtwcm9wcy5vblJ1blF1ZXJ5fVxuICAgICAgICAgIC8+XG4gICAgICAgICl9XG4gICAgICAgIHtlZGl0b3JNb2RlID09PSBRdWVyeUVkaXRvck1vZGUuRXhwbGFpbiAmJiA8TG9raVF1ZXJ5QnVpbGRlckV4cGxhaW5lZCBxdWVyeT17cXVlcnkuZXhwcn0gLz59XG4gICAgICAgIHtlZGl0b3JNb2RlICE9PSBRdWVyeUVkaXRvck1vZGUuRXhwbGFpbiAmJiAoXG4gICAgICAgICAgPExva2lRdWVyeUJ1aWxkZXJPcHRpb25zIHF1ZXJ5PXtxdWVyeX0gb25DaGFuZ2U9e29uQ2hhbmdlfSBvblJ1blF1ZXJ5PXtvblJ1blF1ZXJ5fSAvPlxuICAgICAgICApfVxuICAgICAgPC9FZGl0b3JSb3dzPlxuICAgIDwvPlxuICApO1xufSk7XG5cbkxva2lRdWVyeUVkaXRvclNlbGVjdG9yLmRpc3BsYXlOYW1lID0gJ0xva2lRdWVyeUVkaXRvclNlbGVjdG9yJztcbiIsImltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBHcmFmYW5hVGhlbWUyLCB0b09wdGlvbiB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgRWRpdG9yUm93cywgRmxleEl0ZW0gfSBmcm9tICdAZ3JhZmFuYS9leHBlcmltZW50YWwnO1xuaW1wb3J0IHsgSWNvbkJ1dHRvbiwgU2VsZWN0LCB1c2VTdHlsZXMyIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuaW1wb3J0IHsgQXV0b1NpemVJbnB1dCB9IGZyb20gJ2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL0F1dG9TaXplSW5wdXQnO1xuXG5pbXBvcnQgeyBMb2tpRGF0YXNvdXJjZSB9IGZyb20gJy4uLy4uL2RhdGFzb3VyY2UnO1xuaW1wb3J0IHsgYmluYXJ5U2NhbGFyRGVmcyB9IGZyb20gJy4uL2JpbmFyeVNjYWxhck9wZXJhdGlvbnMnO1xuaW1wb3J0IHsgTG9raVZpc3VhbFF1ZXJ5QmluYXJ5IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBMb2tpUXVlcnlCdWlsZGVyIH0gZnJvbSAnLi9Mb2tpUXVlcnlCdWlsZGVyJztcblxuZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gIG5lc3RlZFF1ZXJ5OiBMb2tpVmlzdWFsUXVlcnlCaW5hcnk7XG4gIGRhdGFzb3VyY2U6IExva2lEYXRhc291cmNlO1xuICBpbmRleDogbnVtYmVyO1xuICBvbkNoYW5nZTogKGluZGV4OiBudW1iZXIsIHVwZGF0ZTogTG9raVZpc3VhbFF1ZXJ5QmluYXJ5KSA9PiB2b2lkO1xuICBvblJlbW92ZTogKGluZGV4OiBudW1iZXIpID0+IHZvaWQ7XG4gIG9uUnVuUXVlcnk6ICgpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBjb25zdCBOZXN0ZWRRdWVyeSA9IFJlYWN0Lm1lbW88UHJvcHM+KCh7IG5lc3RlZFF1ZXJ5LCBpbmRleCwgZGF0YXNvdXJjZSwgb25DaGFuZ2UsIG9uUmVtb3ZlLCBvblJ1blF1ZXJ5IH0pID0+IHtcbiAgY29uc3Qgc3R5bGVzID0gdXNlU3R5bGVzMihnZXRTdHlsZXMpO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5jYXJkfT5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuaGVhZGVyfT5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5uYW1lfT5PcGVyYXRvcjwvZGl2PlxuICAgICAgICA8U2VsZWN0XG4gICAgICAgICAgd2lkdGg9XCJhdXRvXCJcbiAgICAgICAgICBvcHRpb25zPXtvcGVyYXRvcnN9XG4gICAgICAgICAgdmFsdWU9e3RvT3B0aW9uKG5lc3RlZFF1ZXJ5Lm9wZXJhdG9yKX1cbiAgICAgICAgICBvbkNoYW5nZT17KHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBvbkNoYW5nZShpbmRleCwge1xuICAgICAgICAgICAgICAuLi5uZXN0ZWRRdWVyeSxcbiAgICAgICAgICAgICAgb3BlcmF0b3I6IHZhbHVlLnZhbHVlISxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH19XG4gICAgICAgIC8+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMubmFtZX0+VmVjdG9yIG1hdGNoZXM8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy52ZWN0b3JNYXRjaFdyYXBwZXJ9PlxuICAgICAgICAgIDxTZWxlY3Q8TG9raVZpc3VhbFF1ZXJ5QmluYXJ5Wyd2ZWN0b3JNYXRjaGVzVHlwZSddPlxuICAgICAgICAgICAgd2lkdGg9XCJhdXRvXCJcbiAgICAgICAgICAgIHZhbHVlPXtuZXN0ZWRRdWVyeS52ZWN0b3JNYXRjaGVzVHlwZSB8fCAnb24nfVxuICAgICAgICAgICAgYWxsb3dDdXN0b21WYWx1ZVxuICAgICAgICAgICAgb3B0aW9ucz17W1xuICAgICAgICAgICAgICB7IHZhbHVlOiAnb24nLCBsYWJlbDogJ29uJyB9LFxuICAgICAgICAgICAgICB7IHZhbHVlOiAnaWdub3JpbmcnLCBsYWJlbDogJ2lnbm9yaW5nJyB9LFxuICAgICAgICAgICAgXX1cbiAgICAgICAgICAgIG9uQ2hhbmdlPXsodmFsKSA9PiB7XG4gICAgICAgICAgICAgIG9uQ2hhbmdlKGluZGV4LCB7XG4gICAgICAgICAgICAgICAgLi4ubmVzdGVkUXVlcnksXG4gICAgICAgICAgICAgICAgdmVjdG9yTWF0Y2hlc1R5cGU6IHZhbC52YWx1ZSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9fVxuICAgICAgICAgIC8+XG4gICAgICAgICAgPEF1dG9TaXplSW5wdXRcbiAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLnZlY3Rvck1hdGNoSW5wdXR9XG4gICAgICAgICAgICBtaW5XaWR0aD17MjB9XG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU9e25lc3RlZFF1ZXJ5LnZlY3Rvck1hdGNoZXN9XG4gICAgICAgICAgICBvbkNvbW1pdENoYW5nZT17KGV2dCkgPT4ge1xuICAgICAgICAgICAgICBvbkNoYW5nZShpbmRleCwge1xuICAgICAgICAgICAgICAgIC4uLm5lc3RlZFF1ZXJ5LFxuICAgICAgICAgICAgICAgIHZlY3Rvck1hdGNoZXM6IGV2dC5jdXJyZW50VGFyZ2V0LnZhbHVlLFxuICAgICAgICAgICAgICAgIHZlY3Rvck1hdGNoZXNUeXBlOiBuZXN0ZWRRdWVyeS52ZWN0b3JNYXRjaGVzVHlwZSB8fCAnb24nLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxGbGV4SXRlbSBncm93PXsxfSAvPlxuICAgICAgICA8SWNvbkJ1dHRvbiBuYW1lPVwidGltZXNcIiBzaXplPVwic21cIiBvbkNsaWNrPXsoKSA9PiBvblJlbW92ZShpbmRleCl9IC8+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuYm9keX0+XG4gICAgICAgIDxFZGl0b3JSb3dzPlxuICAgICAgICAgIDxMb2tpUXVlcnlCdWlsZGVyXG4gICAgICAgICAgICBxdWVyeT17bmVzdGVkUXVlcnkucXVlcnl9XG4gICAgICAgICAgICBkYXRhc291cmNlPXtkYXRhc291cmNlfVxuICAgICAgICAgICAgbmVzdGVkPXt0cnVlfVxuICAgICAgICAgICAgb25SdW5RdWVyeT17b25SdW5RdWVyeX1cbiAgICAgICAgICAgIG9uQ2hhbmdlPXsodXBkYXRlKSA9PiB7XG4gICAgICAgICAgICAgIG9uQ2hhbmdlKGluZGV4LCB7IC4uLm5lc3RlZFF1ZXJ5LCBxdWVyeTogdXBkYXRlIH0pO1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICAvPlxuICAgICAgICA8L0VkaXRvclJvd3M+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn0pO1xuXG5jb25zdCBvcGVyYXRvcnMgPSBiaW5hcnlTY2FsYXJEZWZzLm1hcCgoZGVmKSA9PiAoeyBsYWJlbDogZGVmLnNpZ24sIHZhbHVlOiBkZWYuc2lnbiB9KSk7XG5cbk5lc3RlZFF1ZXJ5LmRpc3BsYXlOYW1lID0gJ05lc3RlZFF1ZXJ5JztcblxuY29uc3QgZ2V0U3R5bGVzID0gKHRoZW1lOiBHcmFmYW5hVGhlbWUyKSA9PiB7XG4gIHJldHVybiB7XG4gICAgY2FyZDogY3NzKHtcbiAgICAgIGxhYmVsOiAnY2FyZCcsXG4gICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICBmbGV4RGlyZWN0aW9uOiAnY29sdW1uJyxcbiAgICAgIGdhcDogdGhlbWUuc3BhY2luZygwLjUpLFxuICAgIH0pLFxuICAgIGhlYWRlcjogY3NzKHtcbiAgICAgIGxhYmVsOiAnaGVhZGVyJyxcbiAgICAgIHBhZGRpbmc6IHRoZW1lLnNwYWNpbmcoMC41LCAwLjUsIDAuNSwgMSksXG4gICAgICBnYXA6IHRoZW1lLnNwYWNpbmcoMSksXG4gICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICB9KSxcbiAgICBuYW1lOiBjc3Moe1xuICAgICAgbGFiZWw6ICduYW1lJyxcbiAgICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICAgIH0pLFxuICAgIGJvZHk6IGNzcyh7XG4gICAgICBsYWJlbDogJ2JvZHknLFxuICAgICAgcGFkZGluZ0xlZnQ6IHRoZW1lLnNwYWNpbmcoMiksXG4gICAgfSksXG4gICAgdmVjdG9yTWF0Y2hJbnB1dDogY3NzKHtcbiAgICAgIGxhYmVsOiAndmVjdG9yTWF0Y2hJbnB1dCcsXG4gICAgICBtYXJnaW5MZWZ0OiAtMSxcbiAgICB9KSxcbiAgICB2ZWN0b3JNYXRjaFdyYXBwZXI6IGNzcyh7XG4gICAgICBsYWJlbDogJ3ZlY3Rvck1hdGNoV3JhcHBlcicsXG4gICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgfSksXG4gIH07XG59O1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgU3RhY2sgfSBmcm9tICdAZ3JhZmFuYS9leHBlcmltZW50YWwnO1xuXG5pbXBvcnQgeyBMb2tpRGF0YXNvdXJjZSB9IGZyb20gJy4uLy4uL2RhdGFzb3VyY2UnO1xuaW1wb3J0IHsgTG9raVZpc3VhbFF1ZXJ5LCBMb2tpVmlzdWFsUXVlcnlCaW5hcnkgfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IE5lc3RlZFF1ZXJ5IH0gZnJvbSAnLi9OZXN0ZWRRdWVyeSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICBxdWVyeTogTG9raVZpc3VhbFF1ZXJ5O1xuICBkYXRhc291cmNlOiBMb2tpRGF0YXNvdXJjZTtcbiAgb25DaGFuZ2U6IChxdWVyeTogTG9raVZpc3VhbFF1ZXJ5KSA9PiB2b2lkO1xuICBvblJ1blF1ZXJ5OiAoKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gTmVzdGVkUXVlcnlMaXN0KHsgcXVlcnksIGRhdGFzb3VyY2UsIG9uQ2hhbmdlLCBvblJ1blF1ZXJ5IH06IFByb3BzKSB7XG4gIGNvbnN0IG5lc3RlZFF1ZXJpZXMgPSBxdWVyeS5iaW5hcnlRdWVyaWVzID8/IFtdO1xuXG4gIGNvbnN0IG9uTmVzdGVkUXVlcnlVcGRhdGUgPSAoaW5kZXg6IG51bWJlciwgdXBkYXRlOiBMb2tpVmlzdWFsUXVlcnlCaW5hcnkpID0+IHtcbiAgICBjb25zdCB1cGRhdGVkTGlzdCA9IFsuLi5uZXN0ZWRRdWVyaWVzXTtcbiAgICB1cGRhdGVkTGlzdC5zcGxpY2UoaW5kZXgsIDEsIHVwZGF0ZSk7XG4gICAgb25DaGFuZ2UoeyAuLi5xdWVyeSwgYmluYXJ5UXVlcmllczogdXBkYXRlZExpc3QgfSk7XG4gIH07XG5cbiAgY29uc3Qgb25SZW1vdmUgPSAoaW5kZXg6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IHVwZGF0ZWRMaXN0ID0gWy4uLm5lc3RlZFF1ZXJpZXMuc2xpY2UoMCwgaW5kZXgpLCAuLi5uZXN0ZWRRdWVyaWVzLnNsaWNlKGluZGV4ICsgMSldO1xuICAgIG9uQ2hhbmdlKHsgLi4ucXVlcnksIGJpbmFyeVF1ZXJpZXM6IHVwZGF0ZWRMaXN0IH0pO1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPFN0YWNrIGRpcmVjdGlvbj1cImNvbHVtblwiIGdhcD17MX0+XG4gICAgICB7bmVzdGVkUXVlcmllcy5tYXAoKG5lc3RlZFF1ZXJ5LCBpbmRleCkgPT4gKFxuICAgICAgICA8TmVzdGVkUXVlcnlcbiAgICAgICAgICBrZXk9e2luZGV4LnRvU3RyaW5nKCl9XG4gICAgICAgICAgbmVzdGVkUXVlcnk9e25lc3RlZFF1ZXJ5fVxuICAgICAgICAgIGluZGV4PXtpbmRleH1cbiAgICAgICAgICBvbkNoYW5nZT17b25OZXN0ZWRRdWVyeVVwZGF0ZX1cbiAgICAgICAgICBkYXRhc291cmNlPXtkYXRhc291cmNlfVxuICAgICAgICAgIG9uUmVtb3ZlPXtvblJlbW92ZX1cbiAgICAgICAgICBvblJ1blF1ZXJ5PXtvblJ1blF1ZXJ5fVxuICAgICAgICAvPlxuICAgICAgKSl9XG4gICAgPC9TdGFjaz5cbiAgKTtcbn1cbiIsImltcG9ydCB7IGNzcywgY3ggfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IFByaXNtIGZyb20gJ3ByaXNtanMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgR3JhZmFuYVRoZW1lMiB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgRWRpdG9yRmllbGQsIEVkaXRvckZpZWxkR3JvdXAsIEVkaXRvclJvdyB9IGZyb20gJ0BncmFmYW5hL2V4cGVyaW1lbnRhbCc7XG5pbXBvcnQgeyB1c2VUaGVtZTIgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5cbmltcG9ydCB7IGxva2lHcmFtbWFyIH0gZnJvbSAnLi4vLi4vc3ludGF4JztcblxuZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gIHF1ZXJ5OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBRdWVyeVByZXZpZXcoeyBxdWVyeSB9OiBQcm9wcykge1xuICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lMigpO1xuICBjb25zdCBzdHlsZXMgPSBnZXRTdHlsZXModGhlbWUpO1xuICBjb25zdCBoaWdobGlnaHRlZCA9IFByaXNtLmhpZ2hsaWdodChxdWVyeSwgbG9raUdyYW1tYXIsICdsb2tpcWwnKTtcblxuICByZXR1cm4gKFxuICAgIDxFZGl0b3JSb3c+XG4gICAgICA8RWRpdG9yRmllbGRHcm91cD5cbiAgICAgICAgPEVkaXRvckZpZWxkIGxhYmVsPVwiUmF3IHF1ZXJ5XCI+XG4gICAgICAgICAgPGRpdlxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjeChzdHlsZXMuZWRpdG9yRmllbGQsICdwcmlzbS1zeW50YXgtaGlnaGxpZ2h0Jyl9XG4gICAgICAgICAgICBhcmlhLWxhYmVsPVwic2VsZWN0b3JcIlxuICAgICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e3sgX19odG1sOiBoaWdobGlnaHRlZCB9fVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvRWRpdG9yRmllbGQ+XG4gICAgICA8L0VkaXRvckZpZWxkR3JvdXA+XG4gICAgPC9FZGl0b3JSb3c+XG4gICk7XG59XG5cbmNvbnN0IGdldFN0eWxlcyA9ICh0aGVtZTogR3JhZmFuYVRoZW1lMikgPT4ge1xuICByZXR1cm4ge1xuICAgIGVkaXRvckZpZWxkOiBjc3Moe1xuICAgICAgZm9udEZhbWlseTogdGhlbWUudHlwb2dyYXBoeS5mb250RmFtaWx5TW9ub3NwYWNlLFxuICAgICAgZm9udFNpemU6IHRoZW1lLnR5cG9ncmFwaHkuYm9keVNtYWxsLmZvbnRTaXplLFxuICAgIH0pLFxuICB9O1xufTtcbiIsImltcG9ydCB7XG4gIGNyZWF0ZUFnZ3JlZ2F0aW9uT3BlcmF0aW9uLFxuICBjcmVhdGVBZ2dyZWdhdGlvbk9wZXJhdGlvbldpdGhQYXJhbSxcbiAgZ2V0UHJvbUFuZExva2lPcGVyYXRpb25EaXNwbGF5TmFtZSxcbn0gZnJvbSAnLi4vLi4vcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL29wZXJhdGlvblV0aWxzJztcbmltcG9ydCB7XG4gIFF1ZXJ5QnVpbGRlck9wZXJhdGlvbixcbiAgUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLFxuICBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbURlZixcbiAgVmlzdWFsUXVlcnlNb2RlbGxlcixcbn0gZnJvbSAnLi4vLi4vcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL3R5cGVzJztcbmltcG9ydCB7IEZVTkNUSU9OUyB9IGZyb20gJy4uL3N5bnRheCc7XG5cbmltcG9ydCB7IGJpbmFyeVNjYWxhck9wZXJhdGlvbnMgfSBmcm9tICcuL2JpbmFyeVNjYWxhck9wZXJhdGlvbnMnO1xuaW1wb3J0IHsgTG9raU9wZXJhdGlvbklkLCBMb2tpT3BlcmF0aW9uT3JkZXIsIExva2lWaXN1YWxRdWVyeSwgTG9raVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldE9wZXJhdGlvbkRlZmluaXRpb25zKCk6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZltdIHtcbiAgY29uc3QgYWdncmVnYXRpb25zID0gW1xuICAgIExva2lPcGVyYXRpb25JZC5TdW0sXG4gICAgTG9raU9wZXJhdGlvbklkLk1pbixcbiAgICBMb2tpT3BlcmF0aW9uSWQuTWF4LFxuICAgIExva2lPcGVyYXRpb25JZC5BdmcsXG4gICAgTG9raU9wZXJhdGlvbklkLlN0ZGRldixcbiAgICBMb2tpT3BlcmF0aW9uSWQuU3RkdmFyLFxuICAgIExva2lPcGVyYXRpb25JZC5Db3VudCxcbiAgXS5mbGF0TWFwKChvcElkKSA9PlxuICAgIGNyZWF0ZUFnZ3JlZ2F0aW9uT3BlcmF0aW9uKG9wSWQsIHtcbiAgICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGFkZExva2lPcGVyYXRpb24sXG4gICAgICBvcmRlclJhbms6IExva2lPcGVyYXRpb25PcmRlci5MYXN0LFxuICAgIH0pXG4gICk7XG5cbiAgY29uc3QgYWdncmVnYXRpb25zV2l0aFBhcmFtID0gW0xva2lPcGVyYXRpb25JZC5Ub3BLLCBMb2tpT3BlcmF0aW9uSWQuQm90dG9tS10uZmxhdE1hcCgob3BJZCkgPT4ge1xuICAgIHJldHVybiBjcmVhdGVBZ2dyZWdhdGlvbk9wZXJhdGlvbldpdGhQYXJhbShcbiAgICAgIG9wSWQsXG4gICAgICB7XG4gICAgICAgIHBhcmFtczogW3sgbmFtZTogJ0stdmFsdWUnLCB0eXBlOiAnbnVtYmVyJyB9XSxcbiAgICAgICAgZGVmYXVsdFBhcmFtczogWzVdLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogYWRkTG9raU9wZXJhdGlvbixcbiAgICAgICAgb3JkZXJSYW5rOiBMb2tpT3BlcmF0aW9uT3JkZXIuTGFzdCxcbiAgICAgIH1cbiAgICApO1xuICB9KTtcblxuICBjb25zdCBsaXN0OiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWZbXSA9IFtcbiAgICBjcmVhdGVSYW5nZU9wZXJhdGlvbihMb2tpT3BlcmF0aW9uSWQuUmF0ZSksXG4gICAgY3JlYXRlUmFuZ2VPcGVyYXRpb24oTG9raU9wZXJhdGlvbklkLkNvdW50T3ZlclRpbWUpLFxuICAgIGNyZWF0ZVJhbmdlT3BlcmF0aW9uKExva2lPcGVyYXRpb25JZC5TdW1PdmVyVGltZSksXG4gICAgY3JlYXRlUmFuZ2VPcGVyYXRpb24oTG9raU9wZXJhdGlvbklkLkJ5dGVzUmF0ZSksXG4gICAgY3JlYXRlUmFuZ2VPcGVyYXRpb24oTG9raU9wZXJhdGlvbklkLkJ5dGVzT3ZlclRpbWUpLFxuICAgIGNyZWF0ZVJhbmdlT3BlcmF0aW9uKExva2lPcGVyYXRpb25JZC5BYnNlbnRPdmVyVGltZSksXG4gICAgY3JlYXRlUmFuZ2VPcGVyYXRpb24oTG9raU9wZXJhdGlvbklkLkF2Z092ZXJUaW1lKSxcbiAgICBjcmVhdGVSYW5nZU9wZXJhdGlvbihMb2tpT3BlcmF0aW9uSWQuTWF4T3ZlclRpbWUpLFxuICAgIGNyZWF0ZVJhbmdlT3BlcmF0aW9uKExva2lPcGVyYXRpb25JZC5NaW5PdmVyVGltZSksXG4gICAgY3JlYXRlUmFuZ2VPcGVyYXRpb24oTG9raU9wZXJhdGlvbklkLkZpcnN0T3ZlclRpbWUpLFxuICAgIGNyZWF0ZVJhbmdlT3BlcmF0aW9uKExva2lPcGVyYXRpb25JZC5MYXN0T3ZlclRpbWUpLFxuICAgIGNyZWF0ZVJhbmdlT3BlcmF0aW9uKExva2lPcGVyYXRpb25JZC5TdGR2YXJPdmVyVGltZSksXG4gICAgY3JlYXRlUmFuZ2VPcGVyYXRpb24oTG9raU9wZXJhdGlvbklkLlN0ZGRldk92ZXJUaW1lKSxcbiAgICBjcmVhdGVSYW5nZU9wZXJhdGlvbihMb2tpT3BlcmF0aW9uSWQuUXVhbnRpbGVPdmVyVGltZSksXG4gICAgLi4uYWdncmVnYXRpb25zLFxuICAgIC4uLmFnZ3JlZ2F0aW9uc1dpdGhQYXJhbSxcbiAgICB7XG4gICAgICBpZDogTG9raU9wZXJhdGlvbklkLkpzb24sXG4gICAgICBuYW1lOiAnSnNvbicsXG4gICAgICBwYXJhbXM6IFtdLFxuICAgICAgZGVmYXVsdFBhcmFtczogW10sXG4gICAgICBhbHRlcm5hdGl2ZXNLZXk6ICdmb3JtYXQnLFxuICAgICAgY2F0ZWdvcnk6IExva2lWaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkZvcm1hdHMsXG4gICAgICBvcmRlclJhbms6IExva2lPcGVyYXRpb25PcmRlci5MaW5lRm9ybWF0cyxcbiAgICAgIHJlbmRlcmVyOiBwaXBlbGluZVJlbmRlcmVyLFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogYWRkTG9raU9wZXJhdGlvbixcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiBMb2tpT3BlcmF0aW9uSWQuTG9nZm10LFxuICAgICAgbmFtZTogJ0xvZ2ZtdCcsXG4gICAgICBwYXJhbXM6IFtdLFxuICAgICAgZGVmYXVsdFBhcmFtczogW10sXG4gICAgICBhbHRlcm5hdGl2ZXNLZXk6ICdmb3JtYXQnLFxuICAgICAgY2F0ZWdvcnk6IExva2lWaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkZvcm1hdHMsXG4gICAgICBvcmRlclJhbms6IExva2lPcGVyYXRpb25PcmRlci5MaW5lRm9ybWF0cyxcbiAgICAgIHJlbmRlcmVyOiBwaXBlbGluZVJlbmRlcmVyLFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogYWRkTG9raU9wZXJhdGlvbixcbiAgICAgIGV4cGxhaW5IYW5kbGVyOiAoKSA9PlxuICAgICAgICBgVGhpcyB3aWxsIGV4dHJhY3QgYWxsIGtleXMgYW5kIHZhbHVlcyBmcm9tIGEgW2xvZ2ZtdF0oaHR0cHM6Ly9ncmFmYW5hLmNvbS9kb2NzL2xva2kvbGF0ZXN0L2xvZ3FsL2xvZ19xdWVyaWVzLyNsb2dmbXQpIGZvcm1hdHRlZCBsb2cgbGluZSBhcyBsYWJlbHMuIFRoZSBleHRyYWN0ZWQgbGFiZWxzIGNhbiBiZSB1c2VkIGluIGxhYmVsIGZpbHRlciBleHByZXNzaW9ucyBhbmQgdXNlZCBhcyB2YWx1ZXMgZm9yIGEgcmFuZ2UgYWdncmVnYXRpb24gdmlhIHRoZSB1bndyYXAgb3BlcmF0aW9uLmAsXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogTG9raU9wZXJhdGlvbklkLlJlZ2V4cCxcbiAgICAgIG5hbWU6ICdSZWdleHAnLFxuICAgICAgcGFyYW1zOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnU3RyaW5nJyxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBoaWRlTmFtZTogdHJ1ZSxcbiAgICAgICAgICBwbGFjZWhvbGRlcjogJzxyZT4nLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnVGhlIHJlZ2V4cCBleHByZXNzaW9uIHRoYXQgbWF0Y2hlcyB0aGUgc3RydWN0dXJlIG9mIGEgbG9nIGxpbmUuJyxcbiAgICAgICAgICBtaW5XaWR0aDogMjAsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgZGVmYXVsdFBhcmFtczogWycnXSxcbiAgICAgIGFsdGVybmF0aXZlc0tleTogJ2Zvcm1hdCcsXG4gICAgICBjYXRlZ29yeTogTG9raVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuRm9ybWF0cyxcbiAgICAgIG9yZGVyUmFuazogTG9raU9wZXJhdGlvbk9yZGVyLkxpbmVGb3JtYXRzLFxuICAgICAgcmVuZGVyZXI6IChtb2RlbCwgZGVmLCBpbm5lckV4cHIpID0+IGAke2lubmVyRXhwcn0gfCByZWdleHAgXFxgJHttb2RlbC5wYXJhbXNbMF19XFxgYCxcbiAgICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGFkZExva2lPcGVyYXRpb24sXG4gICAgICBleHBsYWluSGFuZGxlcjogKCkgPT5cbiAgICAgICAgYFRoZSBbcmVnZXhwIHBhcnNlcl0oaHR0cHM6Ly9ncmFmYW5hLmNvbS9kb2NzL2xva2kvbGF0ZXN0L2xvZ3FsL2xvZ19xdWVyaWVzLyNyZWd1bGFyLWV4cHJlc3Npb24pIHRha2VzIGEgc2luZ2xlIHBhcmFtZXRlciB8IHJlZ2V4cCBcIjxyZT5cIiB3aGljaCBpcyB0aGUgcmVndWxhciBleHByZXNzaW9uIHVzaW5nIHRoZSBHb2xhbmcgUkUyIHN5bnRheC4gVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBtdXN0IGNvbnRhaW4gYSBsZWFzdCBvbmUgbmFtZWQgc3ViLW1hdGNoIChlLmcgKD9QPG5hbWU+cmUpKSwgZWFjaCBzdWItbWF0Y2ggd2lsbCBleHRyYWN0IGEgZGlmZmVyZW50IGxhYmVsLiBUaGUgZXhwcmVzc2lvbiBtYXRjaGVzIHRoZSBzdHJ1Y3R1cmUgb2YgYSBsb2cgbGluZS4gVGhlIGV4dHJhY3RlZCBsYWJlbHMgY2FuIGJlIHVzZWQgaW4gbGFiZWwgZmlsdGVyIGV4cHJlc3Npb25zIGFuZCB1c2VkIGFzIHZhbHVlcyBmb3IgYSByYW5nZSBhZ2dyZWdhdGlvbiB2aWEgdGhlIHVud3JhcCBvcGVyYXRpb24uYCxcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiBMb2tpT3BlcmF0aW9uSWQuUGF0dGVybixcbiAgICAgIG5hbWU6ICdQYXR0ZXJuJyxcbiAgICAgIHBhcmFtczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ1N0cmluZycsXG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgaGlkZU5hbWU6IHRydWUsXG4gICAgICAgICAgcGxhY2Vob2xkZXI6ICc8cGF0dGVybi1leHByZXNzaW9uPicsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdUaGUgZXhwcmVzc2lvbiB0aGF0IG1hdGNoZXMgdGhlIHN0cnVjdHVyZSBvZiBhIGxvZyBsaW5lLicsXG4gICAgICAgICAgbWluV2lkdGg6IDIwLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFsnJ10sXG4gICAgICBhbHRlcm5hdGl2ZXNLZXk6ICdmb3JtYXQnLFxuICAgICAgY2F0ZWdvcnk6IExva2lWaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkZvcm1hdHMsXG4gICAgICBvcmRlclJhbms6IExva2lPcGVyYXRpb25PcmRlci5MaW5lRm9ybWF0cyxcbiAgICAgIHJlbmRlcmVyOiAobW9kZWwsIGRlZiwgaW5uZXJFeHByKSA9PiBgJHtpbm5lckV4cHJ9IHwgcGF0dGVybiBcXGAke21vZGVsLnBhcmFtc1swXX1cXGBgLFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogYWRkTG9raU9wZXJhdGlvbixcbiAgICAgIGV4cGxhaW5IYW5kbGVyOiAoKSA9PlxuICAgICAgICBgVGhlIFtwYXR0ZXJuIHBhcnNlcl0oaHR0cHM6Ly9ncmFmYW5hLmNvbS9kb2NzL2xva2kvbGF0ZXN0L2xvZ3FsL2xvZ19xdWVyaWVzLyNwYXR0ZXJuKSBhbGxvd3MgdGhlIGV4cGxpY2l0IGV4dHJhY3Rpb24gb2YgZmllbGRzIGZyb20gbG9nIGxpbmVzIGJ5IGRlZmluaW5nIGEgcGF0dGVybiBleHByZXNzaW9uICh8IHBhdHRlcm4gXFxgPHBhdHRlcm4tZXhwcmVzc2lvbj5cXGApLiBUaGUgZXhwcmVzc2lvbiBtYXRjaGVzIHRoZSBzdHJ1Y3R1cmUgb2YgYSBsb2cgbGluZS4gVGhlIGV4dHJhY3RlZCBsYWJlbHMgY2FuIGJlIHVzZWQgaW4gbGFiZWwgZmlsdGVyIGV4cHJlc3Npb25zIGFuZCB1c2VkIGFzIHZhbHVlcyBmb3IgYSByYW5nZSBhZ2dyZWdhdGlvbiB2aWEgdGhlIHVud3JhcCBvcGVyYXRpb24uYCxcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiBMb2tpT3BlcmF0aW9uSWQuVW5wYWNrLFxuICAgICAgbmFtZTogJ1VucGFjaycsXG4gICAgICBwYXJhbXM6IFtdLFxuICAgICAgZGVmYXVsdFBhcmFtczogW10sXG4gICAgICBhbHRlcm5hdGl2ZXNLZXk6ICdmb3JtYXQnLFxuICAgICAgY2F0ZWdvcnk6IExva2lWaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkZvcm1hdHMsXG4gICAgICBvcmRlclJhbms6IExva2lPcGVyYXRpb25PcmRlci5MaW5lRm9ybWF0cyxcbiAgICAgIHJlbmRlcmVyOiBwaXBlbGluZVJlbmRlcmVyLFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogYWRkTG9raU9wZXJhdGlvbixcbiAgICAgIGV4cGxhaW5IYW5kbGVyOiAoKSA9PlxuICAgICAgICBgVGhpcyB3aWxsIGV4dHJhY3QgYWxsIGtleXMgYW5kIHZhbHVlcyBmcm9tIGEgSlNPTiBsb2cgbGluZSwgW3VucGFja2luZ10oaHR0cHM6Ly9ncmFmYW5hLmNvbS9kb2NzL2xva2kvbGF0ZXN0L2xvZ3FsL2xvZ19xdWVyaWVzLyN1bnBhY2spIGFsbCBlbWJlZGRlZCBsYWJlbHMgaW4gdGhlIHBhY2sgc3RhZ2UuIFRoZSBleHRyYWN0ZWQgbGFiZWxzIGNhbiBiZSB1c2VkIGluIGxhYmVsIGZpbHRlciBleHByZXNzaW9ucyBhbmQgdXNlZCBhcyB2YWx1ZXMgZm9yIGEgcmFuZ2UgYWdncmVnYXRpb24gdmlhIHRoZSB1bndyYXAgb3BlcmF0aW9uLmAsXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogTG9raU9wZXJhdGlvbklkLkxpbmVGb3JtYXQsXG4gICAgICBuYW1lOiAnTGluZSBmb3JtYXQnLFxuICAgICAgcGFyYW1zOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnU3RyaW5nJyxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBoaWRlTmFtZTogdHJ1ZSxcbiAgICAgICAgICBwbGFjZWhvbGRlcjogJ3t7LnN0YXR1c19jb2RlfX0nLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnQSBsaW5lIHRlbXBsYXRlIHRoYXQgY2FuIHJlZmVyIHRvIHN0cmVhbSBsYWJlbHMgYW5kIGV4dHJhY3RlZCBsYWJlbHMuJyxcbiAgICAgICAgICBtaW5XaWR0aDogMjAsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgZGVmYXVsdFBhcmFtczogWycnXSxcbiAgICAgIGFsdGVybmF0aXZlc0tleTogJ2Zvcm1hdCcsXG4gICAgICBjYXRlZ29yeTogTG9raVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuRm9ybWF0cyxcbiAgICAgIG9yZGVyUmFuazogTG9raU9wZXJhdGlvbk9yZGVyLkxpbmVGb3JtYXRzLFxuICAgICAgcmVuZGVyZXI6IChtb2RlbCwgZGVmLCBpbm5lckV4cHIpID0+IGAke2lubmVyRXhwcn0gfCBsaW5lX2Zvcm1hdCBcXGAke21vZGVsLnBhcmFtc1swXX1cXGBgLFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogYWRkTG9raU9wZXJhdGlvbixcbiAgICAgIGV4cGxhaW5IYW5kbGVyOiAoKSA9PlxuICAgICAgICBgVGhpcyB3aWxsIHJlcGxhY2UgbG9nIGxpbmUgdXNpbmcgYSBzcGVjaWZpZWQgdGVtcGxhdGUuIFRoZSB0ZW1wbGF0ZSBjYW4gcmVmZXIgdG8gc3RyZWFtIGxhYmVscyBhbmQgZXh0cmFjdGVkIGxhYmVscy5cblxuICAgICAgICBFeGFtcGxlOiBcXGB7ey5zdGF0dXNfY29kZX19IC0ge3subWVzc2FnZX19XFxgXG5cbiAgICAgICAgW1JlYWQgdGhlIGRvY3NdKGh0dHBzOi8vZ3JhZmFuYS5jb20vZG9jcy9sb2tpL2xhdGVzdC9sb2dxbC9sb2dfcXVlcmllcy8jbGluZS1mb3JtYXQtZXhwcmVzc2lvbikgZm9yIG1vcmUuXG4gICAgICAgIGAsXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogTG9raU9wZXJhdGlvbklkLkxhYmVsRm9ybWF0LFxuICAgICAgbmFtZTogJ0xhYmVsIGZvcm1hdCcsXG4gICAgICBwYXJhbXM6IFtcbiAgICAgICAgeyBuYW1lOiAnTGFiZWwnLCB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgICB7IG5hbWU6ICdSZW5hbWUnLCB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgXSxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFsnJywgJyddLFxuICAgICAgYWx0ZXJuYXRpdmVzS2V5OiAnZm9ybWF0JyxcbiAgICAgIGNhdGVnb3J5OiBMb2tpVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5Gb3JtYXRzLFxuICAgICAgb3JkZXJSYW5rOiBMb2tpT3BlcmF0aW9uT3JkZXIuTGluZUZvcm1hdHMsXG4gICAgICByZW5kZXJlcjogKG1vZGVsLCBkZWYsIGlubmVyRXhwcikgPT4gYCR7aW5uZXJFeHByfSB8IGxhYmVsX2Zvcm1hdCAke21vZGVsLnBhcmFtc1sxXX09XFxgJHttb2RlbC5wYXJhbXNbMF19XFxgYCxcbiAgICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGFkZExva2lPcGVyYXRpb24sXG4gICAgICBleHBsYWluSGFuZGxlcjogKCkgPT5cbiAgICAgICAgYFRoaXMgd2lsbCBjaGFuZ2UgbmFtZSBvZiBsYWJlbCB0byBkZXNpcmVkIG5ldyBsYWJlbC4gSW4gdGhlIGV4YW1wbGUgYmVsb3csIGxhYmVsIFwiZXJyb3JfbGV2ZWxcIiB3aWxsIGJlIHJlbmFtZWQgdG8gXCJsZXZlbFwiLlxuXG4gICAgICAgIEV4YW1wbGU6IGVycm9yX2xldmVsPVxcYGxldmVsXFxgXG5cbiAgICAgICAgW1JlYWQgdGhlIGRvY3NdKGh0dHBzOi8vZ3JhZmFuYS5jb20vZG9jcy9sb2tpL2xhdGVzdC9sb2dxbC9sb2dfcXVlcmllcy8jbGFiZWxzLWZvcm1hdC1leHByZXNzaW9uKSBmb3IgbW9yZS5cbiAgICAgICAgYCxcbiAgICB9LFxuXG4gICAge1xuICAgICAgaWQ6IExva2lPcGVyYXRpb25JZC5MaW5lQ29udGFpbnMsXG4gICAgICBuYW1lOiAnTGluZSBjb250YWlucycsXG4gICAgICBwYXJhbXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdTdHJpbmcnLFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGhpZGVOYW1lOiB0cnVlLFxuICAgICAgICAgIHBsYWNlaG9sZGVyOiAnVGV4dCB0byBmaW5kJyxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ0ZpbmQgbG9nIGxpbmVzIHRoYXQgY29udGFpbnMgdGhpcyB0ZXh0JyxcbiAgICAgICAgICBtaW5XaWR0aDogMjAsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgZGVmYXVsdFBhcmFtczogWycnXSxcbiAgICAgIGFsdGVybmF0aXZlc0tleTogJ2xpbmUgZmlsdGVyJyxcbiAgICAgIGNhdGVnb3J5OiBMb2tpVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5MaW5lRmlsdGVycyxcbiAgICAgIG9yZGVyUmFuazogTG9raU9wZXJhdGlvbk9yZGVyLkxpbmVGaWx0ZXJzLFxuICAgICAgcmVuZGVyZXI6IGdldExpbmVGaWx0ZXJSZW5kZXJlcignfD0nKSxcbiAgICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGFkZExva2lPcGVyYXRpb24sXG4gICAgICBleHBsYWluSGFuZGxlcjogKG9wKSA9PiBgUmV0dXJuIGxvZyBsaW5lcyB0aGF0IGNvbnRhaW4gc3RyaW5nIFxcYCR7b3AucGFyYW1zWzBdfVxcYC5gLFxuICAgIH0sXG4gICAge1xuICAgICAgaWQ6IExva2lPcGVyYXRpb25JZC5MaW5lQ29udGFpbnNOb3QsXG4gICAgICBuYW1lOiAnTGluZSBkb2VzIG5vdCBjb250YWluJyxcbiAgICAgIHBhcmFtczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ1N0cmluZycsXG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgaGlkZU5hbWU6IHRydWUsXG4gICAgICAgICAgcGxhY2Vob2xkZXI6ICdUZXh0IHRvIGV4Y2x1ZGUnLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnRmluZCBsb2cgbGluZXMgdGhhdCBkb2VzIG5vdCBjb250YWluIHRoaXMgdGV4dCcsXG4gICAgICAgICAgbWluV2lkdGg6IDI2LFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFsnJ10sXG4gICAgICBhbHRlcm5hdGl2ZXNLZXk6ICdsaW5lIGZpbHRlcicsXG4gICAgICBjYXRlZ29yeTogTG9raVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuTGluZUZpbHRlcnMsXG4gICAgICBvcmRlclJhbms6IExva2lPcGVyYXRpb25PcmRlci5MaW5lRmlsdGVycyxcbiAgICAgIHJlbmRlcmVyOiBnZXRMaW5lRmlsdGVyUmVuZGVyZXIoJyE9JyksXG4gICAgICBhZGRPcGVyYXRpb25IYW5kbGVyOiBhZGRMb2tpT3BlcmF0aW9uLFxuICAgICAgZXhwbGFpbkhhbmRsZXI6IChvcCkgPT4gYFJldHVybiBsb2cgbGluZXMgdGhhdCBkb2VzIG5vdCBjb250YWluIHN0cmluZyBcXGAke29wLnBhcmFtc1swXX1cXGAuYCxcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiBMb2tpT3BlcmF0aW9uSWQuTGluZU1hdGNoZXNSZWdleCxcbiAgICAgIG5hbWU6ICdMaW5lIGNvbnRhaW5zIHJlZ2V4IG1hdGNoJyxcbiAgICAgIHBhcmFtczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ1JlZ2V4JyxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBoaWRlTmFtZTogdHJ1ZSxcbiAgICAgICAgICBwbGFjZWhvbGRlcjogJ1BhdHRlcm4gdG8gbWF0Y2gnLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnRmluZCBsb2cgbGluZXMgdGhhdCBtYXRjaCB0aGlzIHJlZ2V4IHBhdHRlcm4nLFxuICAgICAgICAgIG1pbldpZHRoOiAzMCxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbJyddLFxuICAgICAgYWx0ZXJuYXRpdmVzS2V5OiAnbGluZSBmaWx0ZXInLFxuICAgICAgY2F0ZWdvcnk6IExva2lWaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkxpbmVGaWx0ZXJzLFxuICAgICAgb3JkZXJSYW5rOiBMb2tpT3BlcmF0aW9uT3JkZXIuTGluZUZpbHRlcnMsXG4gICAgICByZW5kZXJlcjogZ2V0TGluZUZpbHRlclJlbmRlcmVyKCd8ficpLFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogYWRkTG9raU9wZXJhdGlvbixcbiAgICAgIGV4cGxhaW5IYW5kbGVyOiAob3ApID0+IGBSZXR1cm4gbG9nIGxpbmVzIHRoYXQgbWF0Y2ggcmVnZXggXFxgJHtvcC5wYXJhbXNbMF19XFxgLmAsXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogTG9raU9wZXJhdGlvbklkLkxpbmVNYXRjaGVzUmVnZXhOb3QsXG4gICAgICBuYW1lOiAnTGluZSBkb2VzIG5vdCBtYXRjaCByZWdleCcsXG4gICAgICBwYXJhbXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdSZWdleCcsXG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgaGlkZU5hbWU6IHRydWUsXG4gICAgICAgICAgcGxhY2Vob2xkZXI6ICdQYXR0ZXJuIHRvIGV4Y2x1ZGUnLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnRmluZCBsb2cgbGluZXMgdGhhdCBkb2VzIG5vdCBtYXRjaCB0aGlzIHJlZ2V4IHBhdHRlcm4nLFxuICAgICAgICAgIG1pbldpZHRoOiAzMCxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbJyddLFxuICAgICAgYWx0ZXJuYXRpdmVzS2V5OiAnbGluZSBmaWx0ZXInLFxuICAgICAgY2F0ZWdvcnk6IExva2lWaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkxpbmVGaWx0ZXJzLFxuICAgICAgb3JkZXJSYW5rOiBMb2tpT3BlcmF0aW9uT3JkZXIuTGluZUZpbHRlcnMsXG4gICAgICByZW5kZXJlcjogZ2V0TGluZUZpbHRlclJlbmRlcmVyKCchficpLFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogYWRkTG9raU9wZXJhdGlvbixcbiAgICAgIGV4cGxhaW5IYW5kbGVyOiAob3ApID0+IGBSZXR1cm4gbG9nIGxpbmVzIHRoYXQgZG9lcyBub3QgbWF0Y2ggcmVnZXggXFxgJHtvcC5wYXJhbXNbMF19XFxgLmAsXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogTG9raU9wZXJhdGlvbklkLkxhYmVsRmlsdGVyLFxuICAgICAgbmFtZTogJ0xhYmVsIGZpbHRlciBleHByZXNzaW9uJyxcbiAgICAgIHBhcmFtczogW1xuICAgICAgICB7IG5hbWU6ICdMYWJlbCcsIHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICAgIHsgbmFtZTogJ09wZXJhdG9yJywgdHlwZTogJ3N0cmluZycsIG9wdGlvbnM6IFsnPScsICchPScsICc+JywgJzwnLCAnPj0nLCAnPD0nXSB9LFxuICAgICAgICB7IG5hbWU6ICdWYWx1ZScsIHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICBdLFxuICAgICAgZGVmYXVsdFBhcmFtczogWycnLCAnPScsICcnXSxcbiAgICAgIGNhdGVnb3J5OiBMb2tpVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5MYWJlbEZpbHRlcnMsXG4gICAgICBvcmRlclJhbms6IExva2lPcGVyYXRpb25PcmRlci5MYWJlbEZpbHRlcnMsXG4gICAgICByZW5kZXJlcjogbGFiZWxGaWx0ZXJSZW5kZXJlcixcbiAgICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGFkZExva2lPcGVyYXRpb24sXG4gICAgICBleHBsYWluSGFuZGxlcjogKCkgPT4gYExhYmVsIGV4cHJlc3Npb24gZmlsdGVyIGFsbG93cyBmaWx0ZXJpbmcgdXNpbmcgb3JpZ2luYWwgYW5kIGV4dHJhY3RlZCBsYWJlbHMuYCxcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiBMb2tpT3BlcmF0aW9uSWQuTGFiZWxGaWx0ZXJOb0Vycm9ycyxcbiAgICAgIG5hbWU6ICdObyBwaXBlbGluZSBlcnJvcnMnLFxuICAgICAgcGFyYW1zOiBbXSxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFtdLFxuICAgICAgY2F0ZWdvcnk6IExva2lWaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkxhYmVsRmlsdGVycyxcbiAgICAgIG9yZGVyUmFuazogTG9raU9wZXJhdGlvbk9yZGVyLk5vRXJyb3JzLFxuICAgICAgcmVuZGVyZXI6IChtb2RlbCwgZGVmLCBpbm5lckV4cHIpID0+IGAke2lubmVyRXhwcn0gfCBfX2Vycm9yX189XFxgXFxgYCxcbiAgICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGFkZExva2lPcGVyYXRpb24sXG4gICAgICBleHBsYWluSGFuZGxlcjogKCkgPT4gYEZpbHRlciBvdXQgYWxsIGZvcm1hdHRpbmcgYW5kIHBhcnNpbmcgZXJyb3JzLmAsXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogTG9raU9wZXJhdGlvbklkLlVud3JhcCxcbiAgICAgIG5hbWU6ICdVbndyYXAnLFxuICAgICAgcGFyYW1zOiBbeyBuYW1lOiAnSWRlbnRpZmllcicsIHR5cGU6ICdzdHJpbmcnLCBoaWRlTmFtZTogdHJ1ZSwgbWluV2lkdGg6IDE2LCBwbGFjZWhvbGRlcjogJ0xhYmVsIGtleScgfV0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbJyddLFxuICAgICAgY2F0ZWdvcnk6IExva2lWaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkZvcm1hdHMsXG4gICAgICBvcmRlclJhbms6IExva2lPcGVyYXRpb25PcmRlci5VbndyYXAsXG4gICAgICByZW5kZXJlcjogKG9wLCBkZWYsIGlubmVyRXhwcikgPT4gYCR7aW5uZXJFeHByfSB8IHVud3JhcCAke29wLnBhcmFtc1swXX1gLFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogYWRkTG9raU9wZXJhdGlvbixcbiAgICAgIGV4cGxhaW5IYW5kbGVyOiAob3ApID0+IHtcbiAgICAgICAgbGV0IGxhYmVsID0gU3RyaW5nKG9wLnBhcmFtc1swXSkubGVuZ3RoID4gMCA/IG9wLnBhcmFtc1swXSA6ICc8bGFiZWw+JztcbiAgICAgICAgcmV0dXJuIGBVc2UgdGhlIGV4dHJhY3RlZCBsYWJlbCBcXGAke2xhYmVsfVxcYCBhcyBzYW1wbGUgdmFsdWVzIGluc3RlYWQgb2YgbG9nIGxpbmVzIGZvciB0aGUgc3Vic2VxdWVudCByYW5nZSBhZ2dyZWdhdGlvbi5gO1xuICAgICAgfSxcbiAgICB9LFxuICAgIC4uLmJpbmFyeVNjYWxhck9wZXJhdGlvbnMsXG4gICAge1xuICAgICAgaWQ6IExva2lPcGVyYXRpb25JZC5OZXN0ZWRRdWVyeSxcbiAgICAgIG5hbWU6ICdCaW5hcnkgb3BlcmF0aW9uIHdpdGggcXVlcnknLFxuICAgICAgcGFyYW1zOiBbXSxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFtdLFxuICAgICAgY2F0ZWdvcnk6IExva2lWaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkJpbmFyeU9wcyxcbiAgICAgIHJlbmRlcmVyOiAobW9kZWwsIGRlZiwgaW5uZXJFeHByKSA9PiBpbm5lckV4cHIsXG4gICAgICBhZGRPcGVyYXRpb25IYW5kbGVyOiBhZGROZXN0ZWRRdWVyeUhhbmRsZXIsXG4gICAgfSxcbiAgXTtcblxuICByZXR1cm4gbGlzdDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUmFuZ2VPcGVyYXRpb24obmFtZTogc3RyaW5nKTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmIHtcbiAgY29uc3QgcGFyYW1zID0gW2dldFJhbmdlVmVjdG9yUGFyYW1EZWYoKV07XG4gIGNvbnN0IGRlZmF1bHRQYXJhbXMgPSBbJyRfX2ludGVydmFsJ107XG4gIGxldCByZW5kZXJlciA9IG9wZXJhdGlvbldpdGhSYW5nZVZlY3RvclJlbmRlcmVyO1xuXG4gIGlmIChuYW1lID09PSBMb2tpT3BlcmF0aW9uSWQuUXVhbnRpbGVPdmVyVGltZSkge1xuICAgIGRlZmF1bHRQYXJhbXMucHVzaCgnMC45NScpO1xuICAgIHBhcmFtcy5wdXNoKHtcbiAgICAgIG5hbWU6ICdRdWFudGlsZScsXG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICB9KTtcbiAgICByZW5kZXJlciA9IG9wZXJhdGlvbldpdGhSYW5nZVZlY3RvclJlbmRlcmVyQW5kUGFyYW07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGlkOiBuYW1lLFxuICAgIG5hbWU6IGdldFByb21BbmRMb2tpT3BlcmF0aW9uRGlzcGxheU5hbWUobmFtZSksXG4gICAgcGFyYW1zLFxuICAgIGRlZmF1bHRQYXJhbXMsXG4gICAgYWx0ZXJuYXRpdmVzS2V5OiAncmFuZ2UgZnVuY3Rpb24nLFxuICAgIGNhdGVnb3J5OiBMb2tpVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5SYW5nZUZ1bmN0aW9ucyxcbiAgICBvcmRlclJhbms6IExva2lPcGVyYXRpb25PcmRlci5SYW5nZVZlY3RvckZ1bmN0aW9uLFxuICAgIHJlbmRlcmVyLFxuICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGFkZExva2lPcGVyYXRpb24sXG4gICAgZXhwbGFpbkhhbmRsZXI6IChvcCwgZGVmKSA9PiB7XG4gICAgICBsZXQgb3BEb2NzID0gRlVOQ1RJT05TLmZpbmQoKHgpID0+IHguaW5zZXJ0VGV4dCA9PT0gb3AuaWQpPy5kb2N1bWVudGF0aW9uID8/ICcnO1xuXG4gICAgICBpZiAob3AucGFyYW1zWzBdID09PSAnJF9faW50ZXJ2YWwnKSB7XG4gICAgICAgIHJldHVybiBgJHtvcERvY3N9IFxcYCRfX2ludGVydmFsXFxgIGlzIHZhcmlhYmxlIHRoYXQgd2lsbCBiZSByZXBsYWNlZCB3aXRoIGEgY2FsY3VsYXRlZCBpbnRlcnZhbCBiYXNlZCBvbiAqKk1heCBkYXRhIHBvaW50cyoqLCAgKipNaW4gaW50ZXJ2YWwqKiBhbmQgcXVlcnkgdGltZSByYW5nZS4gWW91IGZpbmQgdGhlc2Ugb3B0aW9ucyB5b3UgZmluZCB1bmRlciAqKlF1ZXJ5IG9wdGlvbnMqKiBhdCB0aGUgcmlnaHQgb2YgdGhlIGRhdGEgc291cmNlIHNlbGVjdCBkcm9wZG93bi5gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGAke29wRG9jc30gVGhlIFtyYW5nZSB2ZWN0b3JdKGh0dHBzOi8vZ3JhZmFuYS5jb20vZG9jcy9sb2tpL2xhdGVzdC9sb2dxbC9tZXRyaWNfcXVlcmllcy8jcmFuZ2UtdmVjdG9yLWFnZ3JlZ2F0aW9uKSBpcyBzZXQgdG8gXFxgJHtvcC5wYXJhbXNbMF19XFxgLmA7XG4gICAgICB9XG4gICAgfSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UmFuZ2VWZWN0b3JQYXJhbURlZigpOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbURlZiB7XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ1JhbmdlJyxcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICBvcHRpb25zOiBbJyRfX2ludGVydmFsJywgJyRfX3JhbmdlJywgJzFtJywgJzVtJywgJzEwbScsICcxaCcsICcyNGgnXSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gb3BlcmF0aW9uV2l0aFJhbmdlVmVjdG9yUmVuZGVyZXIoXG4gIG1vZGVsOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sXG4gIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLFxuICBpbm5lckV4cHI6IHN0cmluZ1xuKSB7XG4gIGxldCByYW5nZVZlY3RvciA9IChtb2RlbC5wYXJhbXMgPz8gW10pWzBdID8/ICckX19pbnRlcnZhbCc7XG4gIHJldHVybiBgJHtkZWYuaWR9KCR7aW5uZXJFeHByfSBbJHtyYW5nZVZlY3Rvcn1dKWA7XG59XG5cbmZ1bmN0aW9uIG9wZXJhdGlvbldpdGhSYW5nZVZlY3RvclJlbmRlcmVyQW5kUGFyYW0oXG4gIG1vZGVsOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sXG4gIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLFxuICBpbm5lckV4cHI6IHN0cmluZ1xuKSB7XG4gIGNvbnN0IHBhcmFtcyA9IG1vZGVsLnBhcmFtcyA/PyBbXTtcbiAgY29uc3QgcmFuZ2VWZWN0b3IgPSBwYXJhbXNbMF0gPz8gJyRfX2ludGVydmFsJztcbiAgY29uc3QgcGFyYW0gPSBwYXJhbXNbMV07XG4gIHJldHVybiBgJHtkZWYuaWR9KCR7cGFyYW19LCAke2lubmVyRXhwcn0gWyR7cmFuZ2VWZWN0b3J9XSlgO1xufVxuXG5mdW5jdGlvbiBnZXRMaW5lRmlsdGVyUmVuZGVyZXIob3BlcmF0aW9uOiBzdHJpbmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGxpbmVGaWx0ZXJSZW5kZXJlcihtb2RlbDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLCBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiwgaW5uZXJFeHByOiBzdHJpbmcpIHtcbiAgICBpZiAobW9kZWwucGFyYW1zWzBdID09PSAnJykge1xuICAgICAgcmV0dXJuIGlubmVyRXhwcjtcbiAgICB9XG4gICAgcmV0dXJuIGAke2lubmVyRXhwcn0gJHtvcGVyYXRpb259IFxcYCR7bW9kZWwucGFyYW1zWzBdfVxcYGA7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGxhYmVsRmlsdGVyUmVuZGVyZXIobW9kZWw6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiwgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsIGlubmVyRXhwcjogc3RyaW5nKSB7XG4gIGlmIChtb2RlbC5wYXJhbXNbMF0gPT09ICcnKSB7XG4gICAgcmV0dXJuIGlubmVyRXhwcjtcbiAgfVxuXG4gIGlmIChtb2RlbC5wYXJhbXNbMV0gPT09ICc8JyB8fCBtb2RlbC5wYXJhbXNbMV0gPT09ICc+Jykge1xuICAgIHJldHVybiBgJHtpbm5lckV4cHJ9IHwgJHttb2RlbC5wYXJhbXNbMF19ICR7bW9kZWwucGFyYW1zWzFdfSAke21vZGVsLnBhcmFtc1syXX1gO1xuICB9XG5cbiAgcmV0dXJuIGAke2lubmVyRXhwcn0gfCAke21vZGVsLnBhcmFtc1swXX0ke21vZGVsLnBhcmFtc1sxXX1cXGAke21vZGVsLnBhcmFtc1syXX1cXGBgO1xufVxuXG5mdW5jdGlvbiBwaXBlbGluZVJlbmRlcmVyKG1vZGVsOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLCBpbm5lckV4cHI6IHN0cmluZykge1xuICByZXR1cm4gYCR7aW5uZXJFeHByfSB8ICR7bW9kZWwuaWR9YDtcbn1cblxuZnVuY3Rpb24gaXNSYW5nZVZlY3RvckZ1bmN0aW9uKGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmKSB7XG4gIHJldHVybiBkZWYuY2F0ZWdvcnkgPT09IExva2lWaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlJhbmdlRnVuY3Rpb25zO1xufVxuXG5mdW5jdGlvbiBnZXRJbmRleE9mT3JMYXN0KFxuICBvcGVyYXRpb25zOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25bXSxcbiAgcXVlcnlNb2RlbGxlcjogVmlzdWFsUXVlcnlNb2RlbGxlcixcbiAgY29uZGl0aW9uOiAoZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYpID0+IGJvb2xlYW5cbikge1xuICBjb25zdCBpbmRleCA9IG9wZXJhdGlvbnMuZmluZEluZGV4KCh4KSA9PiB7XG4gICAgY29uc3Qgb3BEZWYgPSBxdWVyeU1vZGVsbGVyLmdldE9wZXJhdGlvbkRlZih4LmlkKTtcbiAgICBpZiAoIW9wRGVmKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBjb25kaXRpb24ob3BEZWYpO1xuICB9KTtcblxuICByZXR1cm4gaW5kZXggPT09IC0xID8gb3BlcmF0aW9ucy5sZW5ndGggOiBpbmRleDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZExva2lPcGVyYXRpb24oXG4gIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLFxuICBxdWVyeTogTG9raVZpc3VhbFF1ZXJ5LFxuICBtb2RlbGxlcjogVmlzdWFsUXVlcnlNb2RlbGxlclxuKTogTG9raVZpc3VhbFF1ZXJ5IHtcbiAgY29uc3QgbmV3T3BlcmF0aW9uOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24gPSB7XG4gICAgaWQ6IGRlZi5pZCxcbiAgICBwYXJhbXM6IGRlZi5kZWZhdWx0UGFyYW1zLFxuICB9O1xuXG4gIGNvbnN0IG9wZXJhdGlvbnMgPSBbLi4ucXVlcnkub3BlcmF0aW9uc107XG5cbiAgY29uc3QgZXhpc3RpbmdSYW5nZVZlY3RvckZ1bmN0aW9uID0gb3BlcmF0aW9ucy5maW5kKCh4KSA9PiB7XG4gICAgY29uc3Qgb3BEZWYgPSBtb2RlbGxlci5nZXRPcGVyYXRpb25EZWYoeC5pZCk7XG4gICAgaWYgKCFvcERlZikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gaXNSYW5nZVZlY3RvckZ1bmN0aW9uKG9wRGVmKTtcbiAgfSk7XG5cbiAgc3dpdGNoIChkZWYuY2F0ZWdvcnkpIHtcbiAgICBjYXNlIExva2lWaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkFnZ3JlZ2F0aW9uczpcbiAgICBjYXNlIExva2lWaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkZ1bmN0aW9uczpcbiAgICAgIC8vIElmIHdlIGFyZSBhZGRpbmcgYSBmdW5jdGlvbiBidXQgd2UgaGF2ZSBub3QgcmFuZ2UgdmVjdG9yIGZ1bmN0aW9uIHlldCBhZGQgb25lXG4gICAgICBpZiAoIWV4aXN0aW5nUmFuZ2VWZWN0b3JGdW5jdGlvbikge1xuICAgICAgICBjb25zdCBwbGFjZVRvSW5zZXJ0ID0gZ2V0SW5kZXhPZk9yTGFzdChcbiAgICAgICAgICBvcGVyYXRpb25zLFxuICAgICAgICAgIG1vZGVsbGVyLFxuICAgICAgICAgIChkZWYpID0+IGRlZi5jYXRlZ29yeSA9PT0gTG9raVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuRnVuY3Rpb25zXG4gICAgICAgICk7XG4gICAgICAgIG9wZXJhdGlvbnMuc3BsaWNlKHBsYWNlVG9JbnNlcnQsIDAsIHsgaWQ6IExva2lPcGVyYXRpb25JZC5SYXRlLCBwYXJhbXM6IFsnJF9faW50ZXJ2YWwnXSB9KTtcbiAgICAgIH1cbiAgICAgIG9wZXJhdGlvbnMucHVzaChuZXdPcGVyYXRpb24pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBMb2tpVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5SYW5nZUZ1bmN0aW9uczpcbiAgICAgIC8vIElmIGFkZGluZyBhIHJhbmdlIGZ1bmN0aW9uIGFuZCByYW5nZSBmdW5jdGlvbiBpcyBhbHJlYWR5IGFkZGVkIHJlcGxhY2UgaXRcbiAgICAgIGlmIChleGlzdGluZ1JhbmdlVmVjdG9yRnVuY3Rpb24pIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBvcGVyYXRpb25zLmluZGV4T2YoZXhpc3RpbmdSYW5nZVZlY3RvckZ1bmN0aW9uKTtcbiAgICAgICAgb3BlcmF0aW9uc1tpbmRleF0gPSBuZXdPcGVyYXRpb247XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgLy8gQWRkIHJhbmdlIGZ1bmN0aW9ucyBhZnRlciBhbnkgZm9ybWF0cywgbGluZSBmaWx0ZXJzIGFuZCBsYWJlbCBmaWx0ZXJzXG4gICAgZGVmYXVsdDpcbiAgICAgIGNvbnN0IHBsYWNlVG9JbnNlcnQgPSBnZXRJbmRleE9mT3JMYXN0KFxuICAgICAgICBvcGVyYXRpb25zLFxuICAgICAgICBtb2RlbGxlcixcbiAgICAgICAgKHgpID0+IChkZWYub3JkZXJSYW5rID8/IDEwMCkgPCAoeC5vcmRlclJhbmsgPz8gMTAwKVxuICAgICAgKTtcbiAgICAgIG9wZXJhdGlvbnMuc3BsaWNlKHBsYWNlVG9JbnNlcnQsIDAsIG5ld09wZXJhdGlvbik7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLi4ucXVlcnksXG4gICAgb3BlcmF0aW9ucyxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYWRkTmVzdGVkUXVlcnlIYW5kbGVyKGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLCBxdWVyeTogTG9raVZpc3VhbFF1ZXJ5KTogTG9raVZpc3VhbFF1ZXJ5IHtcbiAgcmV0dXJuIHtcbiAgICAuLi5xdWVyeSxcbiAgICBiaW5hcnlRdWVyaWVzOiBbXG4gICAgICAuLi4ocXVlcnkuYmluYXJ5UXVlcmllcyA/PyBbXSksXG4gICAgICB7XG4gICAgICAgIG9wZXJhdG9yOiAnLycsXG4gICAgICAgIHF1ZXJ5LFxuICAgICAgfSxcbiAgICBdLFxuICB9O1xufVxuIiwiaW1wb3J0IHsgU3ludGF4Tm9kZSB9IGZyb20gJ0BsZXplci9jb21tb24nO1xuXG5pbXBvcnQgeyBwYXJzZXIgfSBmcm9tICdAZ3JhZmFuYS9sZXplci1sb2dxbCc7XG5cbmltcG9ydCB7XG4gIEVycm9yTmFtZSxcbiAgZ2V0QWxsQnlUeXBlLFxuICBnZXRMZWZ0TW9zdENoaWxkLFxuICBnZXRTdHJpbmcsXG4gIG1ha2VCaW5PcCxcbiAgbWFrZUVycm9yLFxuICByZXBsYWNlVmFyaWFibGVzLFxufSBmcm9tICcuLi8uLi9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvcGFyc2luZ1V0aWxzJztcbmltcG9ydCB7IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyLCBRdWVyeUJ1aWxkZXJPcGVyYXRpb24gfSBmcm9tICcuLi8uLi9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvdHlwZXMnO1xuXG5pbXBvcnQgeyBiaW5hcnlTY2FsYXJEZWZzIH0gZnJvbSAnLi9iaW5hcnlTY2FsYXJPcGVyYXRpb25zJztcbmltcG9ydCB7IExva2lWaXN1YWxRdWVyeSwgTG9raVZpc3VhbFF1ZXJ5QmluYXJ5IH0gZnJvbSAnLi90eXBlcyc7XG5cbmludGVyZmFjZSBDb250ZXh0IHtcbiAgcXVlcnk6IExva2lWaXN1YWxRdWVyeTtcbiAgZXJyb3JzOiBQYXJzaW5nRXJyb3JbXTtcbn1cblxuaW50ZXJmYWNlIFBhcnNpbmdFcnJvciB7XG4gIHRleHQ6IHN0cmluZztcbiAgZnJvbT86IG51bWJlcjtcbiAgdG8/OiBudW1iZXI7XG4gIHBhcmVudFR5cGU/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZFZpc3VhbFF1ZXJ5RnJvbVN0cmluZyhleHByOiBzdHJpbmcpOiBDb250ZXh0IHtcbiAgY29uc3QgcmVwbGFjZWRFeHByID0gcmVwbGFjZVZhcmlhYmxlcyhleHByKTtcbiAgY29uc3QgdHJlZSA9IHBhcnNlci5wYXJzZShyZXBsYWNlZEV4cHIpO1xuICBjb25zdCBub2RlID0gdHJlZS50b3BOb2RlO1xuXG4gIC8vIFRoaXMgd2lsbCBiZSBtb2RpZmllZCBpbiB0aGUgaGFuZGxlRXhwcmVzc2lvblxuICBjb25zdCB2aXNRdWVyeTogTG9raVZpc3VhbFF1ZXJ5ID0ge1xuICAgIGxhYmVsczogW10sXG4gICAgb3BlcmF0aW9uczogW10sXG4gIH07XG5cbiAgY29uc3QgY29udGV4dDogQ29udGV4dCA9IHtcbiAgICBxdWVyeTogdmlzUXVlcnksXG4gICAgZXJyb3JzOiBbXSxcbiAgfTtcblxuICB0cnkge1xuICAgIGhhbmRsZUV4cHJlc3Npb24ocmVwbGFjZWRFeHByLCBub2RlLCBjb250ZXh0KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gTm90IGlkZWFsIHRvIGxvZyBpdCBoZXJlLCBidXQgb3RoZXJ3aXNlIHdlIHdvdWxkIGxvc2UgdGhlIHN0YWNrIHRyYWNlLlxuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICBjb250ZXh0LmVycm9ycy5wdXNoKHtcbiAgICAgIHRleHQ6IGVyci5tZXNzYWdlLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gSWYgd2UgaGF2ZSBlbXB0eSBxdWVyeSwgd2Ugd2FudCB0byByZXNldCBlcnJvcnNcbiAgaWYgKGlzRW1wdHlRdWVyeShjb250ZXh0LnF1ZXJ5KSkge1xuICAgIGNvbnRleHQuZXJyb3JzID0gW107XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVFeHByZXNzaW9uKGV4cHI6IHN0cmluZywgbm9kZTogU3ludGF4Tm9kZSwgY29udGV4dDogQ29udGV4dCkge1xuICBjb25zdCB2aXNRdWVyeSA9IGNvbnRleHQucXVlcnk7XG4gIHN3aXRjaCAobm9kZS5uYW1lKSB7XG4gICAgY2FzZSAnTWF0Y2hlcic6IHtcbiAgICAgIHZpc1F1ZXJ5LmxhYmVscy5wdXNoKGdldExhYmVsKGV4cHIsIG5vZGUpKTtcbiAgICAgIGNvbnN0IGVyciA9IG5vZGUuZ2V0Q2hpbGQoRXJyb3JOYW1lKTtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgY29udGV4dC5lcnJvcnMucHVzaChtYWtlRXJyb3IoZXhwciwgZXJyKSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICdMaW5lRmlsdGVyJzoge1xuICAgICAgY29uc3QgeyBvcGVyYXRpb24sIGVycm9yIH0gPSBnZXRMaW5lRmlsdGVyKGV4cHIsIG5vZGUpO1xuICAgICAgaWYgKG9wZXJhdGlvbikge1xuICAgICAgICB2aXNRdWVyeS5vcGVyYXRpb25zLnB1c2gob3BlcmF0aW9uKTtcbiAgICAgIH1cbiAgICAgIC8vIFNob3cgZXJyb3IgZm9yIHF1ZXJ5IHBhdHRlcm5zIG5vdCBzdXBwb3J0ZWQgaW4gdmlzdWFsIHF1ZXJ5IGJ1aWxkZXJcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb250ZXh0LmVycm9ycy5wdXNoKGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yKGV4cHIsIG5vZGUsIGVycm9yKSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICdMYWJlbFBhcnNlcic6IHtcbiAgICAgIHZpc1F1ZXJ5Lm9wZXJhdGlvbnMucHVzaChnZXRMYWJlbFBhcnNlcihleHByLCBub2RlKSk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICdMYWJlbEZpbHRlcic6IHtcbiAgICAgIGNvbnN0IHsgb3BlcmF0aW9uLCBlcnJvciB9ID0gZ2V0TGFiZWxGaWx0ZXIoZXhwciwgbm9kZSk7XG4gICAgICBpZiAob3BlcmF0aW9uKSB7XG4gICAgICAgIHZpc1F1ZXJ5Lm9wZXJhdGlvbnMucHVzaChvcGVyYXRpb24pO1xuICAgICAgfVxuICAgICAgLy8gU2hvdyBlcnJvciBmb3IgcXVlcnkgcGF0dGVybnMgbm90IHN1cHBvcnRlZCBpbiB2aXN1YWwgcXVlcnkgYnVpbGRlclxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnRleHQuZXJyb3JzLnB1c2goY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IoZXhwciwgbm9kZSwgZXJyb3IpKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgJ0pzb25FeHByZXNzaW9uUGFyc2VyJzoge1xuICAgICAgLy8gSnNvbkV4cHJlc3Npb25QYXJzZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBxdWVyeSBidWlsZGVyXG4gICAgICBjb25zdCBlcnJvciA9ICdKc29uRXhwcmVzc2lvblBhcnNlciBub3Qgc3VwcG9ydGVkIGluIHZpc3VhbCBxdWVyeSBidWlsZGVyJztcblxuICAgICAgY29udGV4dC5lcnJvcnMucHVzaChjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvcihleHByLCBub2RlLCBlcnJvcikpO1xuICAgIH1cblxuICAgIGNhc2UgJ0xpbmVGb3JtYXRFeHByJzoge1xuICAgICAgdmlzUXVlcnkub3BlcmF0aW9ucy5wdXNoKGdldExpbmVGb3JtYXQoZXhwciwgbm9kZSkpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSAnTGFiZWxGb3JtYXRNYXRjaGVyJzoge1xuICAgICAgdmlzUXVlcnkub3BlcmF0aW9ucy5wdXNoKGdldExhYmVsRm9ybWF0KGV4cHIsIG5vZGUpKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgJ1Vud3JhcEV4cHInOiB7XG4gICAgICBjb25zdCB7IG9wZXJhdGlvbiwgZXJyb3IgfSA9IGdldFVud3JhcChleHByLCBub2RlKTtcbiAgICAgIGlmIChvcGVyYXRpb24pIHtcbiAgICAgICAgdmlzUXVlcnkub3BlcmF0aW9ucy5wdXNoKG9wZXJhdGlvbik7XG4gICAgICB9XG4gICAgICAvLyBTaG93IGVycm9yIGZvciBxdWVyeSBwYXR0ZXJucyBub3Qgc3VwcG9ydGVkIGluIHZpc3VhbCBxdWVyeSBidWlsZGVyXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY29udGV4dC5lcnJvcnMucHVzaChjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvcihleHByLCBub2RlLCBlcnJvcikpO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICdSYW5nZUFnZ3JlZ2F0aW9uRXhwcic6IHtcbiAgICAgIHZpc1F1ZXJ5Lm9wZXJhdGlvbnMucHVzaChoYW5kbGVSYW5nZUFnZ3JlZ2F0aW9uKGV4cHIsIG5vZGUsIGNvbnRleHQpKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgJ1ZlY3RvckFnZ3JlZ2F0aW9uRXhwcic6IHtcbiAgICAgIHZpc1F1ZXJ5Lm9wZXJhdGlvbnMucHVzaChoYW5kbGVWZWN0b3JBZ2dyZWdhdGlvbihleHByLCBub2RlLCBjb250ZXh0KSk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICdCaW5PcEV4cHInOiB7XG4gICAgICBoYW5kbGVCaW5hcnkoZXhwciwgbm9kZSwgY29udGV4dCk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlIEVycm9yTmFtZToge1xuICAgICAgaWYgKGlzSW50ZXJ2YWxWYXJpYWJsZUVycm9yKG5vZGUpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29udGV4dC5lcnJvcnMucHVzaChtYWtlRXJyb3IoZXhwciwgbm9kZSkpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZGVmYXVsdDoge1xuICAgICAgLy8gQW55IG90aGVyIG5vZGVzIHdlIGp1c3QgaWdub3JlIGFuZCBnbyB0byBpdCdzIGNoaWxkcmVuLiBUaGlzIHNob3VsZCBiZSBmaW5lIGFzIHRoZXJlIGFyZSBsb3QncyBvZiB3cmFwcGVyXG4gICAgICAvLyBub2RlcyB0aGF0IGNhbiBiZSBza2lwcGVkLlxuICAgICAgLy8gVE9ETzogdGhlcmUgYXJlIHByb2JhYmx5IGNhc2VzIHdoZXJlIHdlIHdpbGwganVzdCBza2lwIG5vZGVzIHdlIGRvbid0IHN1cHBvcnQgYW5kIHdlIHNob3VsZCBiZSBhYmxlIHRvXG4gICAgICAvLyAgZGV0ZWN0IHRob3NlIGFuZCByZXBvcnQgYmFjay5cbiAgICAgIGxldCBjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICBoYW5kbGVFeHByZXNzaW9uKGV4cHIsIGNoaWxkLCBjb250ZXh0KTtcbiAgICAgICAgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TGFiZWwoZXhwcjogc3RyaW5nLCBub2RlOiBTeW50YXhOb2RlKTogUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXIge1xuICBjb25zdCBsYWJlbE5vZGUgPSBub2RlLmdldENoaWxkKCdJZGVudGlmaWVyJyk7XG4gIGNvbnN0IGxhYmVsID0gZ2V0U3RyaW5nKGV4cHIsIGxhYmVsTm9kZSk7XG4gIGNvbnN0IG9wID0gZ2V0U3RyaW5nKGV4cHIsIGxhYmVsTm9kZSEubmV4dFNpYmxpbmcpO1xuICBjb25zdCB2YWx1ZSA9IGdldFN0cmluZyhleHByLCBub2RlLmdldENoaWxkKCdTdHJpbmcnKSkucmVwbGFjZSgvXCIvZywgJycpO1xuXG4gIHJldHVybiB7XG4gICAgbGFiZWwsXG4gICAgb3AsXG4gICAgdmFsdWUsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldExpbmVGaWx0ZXIoZXhwcjogc3RyaW5nLCBub2RlOiBTeW50YXhOb2RlKTogeyBvcGVyYXRpb24/OiBRdWVyeUJ1aWxkZXJPcGVyYXRpb247IGVycm9yPzogc3RyaW5nIH0ge1xuICAvLyBDaGVjayBmb3Igbm9kZXMgbm90IHN1cHBvcnRlZCBpbiB2aXN1YWwgYnVpbGRlciBhbmQgcmV0dXJuIGVycm9yXG4gIGNvbnN0IGlwTGluZUZpbHRlciA9IGdldEFsbEJ5VHlwZShleHByLCBub2RlLCAnSXAnKTtcbiAgaWYgKGlwTGluZUZpbHRlci5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVycm9yOiAnTWF0Y2hpbmcgaXAgYWRkcmVzc2VzIG5vdCBzdXBwb3J0ZWQgaW4gcXVlcnkgYnVpbGRlcicsXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IG1hcEZpbHRlcjogYW55ID0ge1xuICAgICd8PSc6ICdfX2xpbmVfY29udGFpbnMnLFxuICAgICchPSc6ICdfX2xpbmVfY29udGFpbnNfbm90JyxcbiAgICAnfH4nOiAnX19saW5lX21hdGNoZXNfcmVnZXgnLFxuICAgICchfic6ICdcIl9fbGluZV9tYXRjaGVzX3JlZ2V4XCJfbm90JyxcbiAgfTtcbiAgY29uc3QgZmlsdGVyID0gZ2V0U3RyaW5nKGV4cHIsIG5vZGUuZ2V0Q2hpbGQoJ0ZpbHRlcicpKTtcbiAgY29uc3QgZmlsdGVyRXhwciA9IGhhbmRsZVF1b3RlcyhnZXRTdHJpbmcoZXhwciwgbm9kZS5nZXRDaGlsZCgnU3RyaW5nJykpKTtcblxuICByZXR1cm4ge1xuICAgIG9wZXJhdGlvbjoge1xuICAgICAgaWQ6IG1hcEZpbHRlcltmaWx0ZXJdLFxuICAgICAgcGFyYW1zOiBbZmlsdGVyRXhwcl0sXG4gICAgfSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0TGFiZWxQYXJzZXIoZXhwcjogc3RyaW5nLCBub2RlOiBTeW50YXhOb2RlKTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uIHtcbiAgY29uc3QgcGFyc2VyTm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgY29uc3QgcGFyc2VyID0gZ2V0U3RyaW5nKGV4cHIsIHBhcnNlck5vZGUpO1xuXG4gIGNvbnN0IHN0cmluZyA9IGhhbmRsZVF1b3RlcyhnZXRTdHJpbmcoZXhwciwgbm9kZS5nZXRDaGlsZCgnU3RyaW5nJykpKTtcbiAgY29uc3QgcGFyYW1zID0gISFzdHJpbmcgPyBbc3RyaW5nXSA6IFtdO1xuICByZXR1cm4ge1xuICAgIGlkOiBwYXJzZXIsXG4gICAgcGFyYW1zLFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRMYWJlbEZpbHRlcihleHByOiBzdHJpbmcsIG5vZGU6IFN5bnRheE5vZGUpOiB7IG9wZXJhdGlvbj86IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbjsgZXJyb3I/OiBzdHJpbmcgfSB7XG4gIC8vIENoZWNrIGZvciBub2RlcyBub3Qgc3VwcG9ydGVkIGluIHZpc3VhbCBidWlsZGVyIGFuZCByZXR1cm4gZXJyb3JcbiAgaWYgKG5vZGUuZ2V0Q2hpbGQoJ09yJykgfHwgbm9kZS5nZXRDaGlsZCgnQW5kJykgfHwgbm9kZS5nZXRDaGlsZCgnQ29tbWEnKSkge1xuICAgIHJldHVybiB7XG4gICAgICBlcnJvcjogJ0xhYmVsIGZpbHRlciB3aXRoIGNvbW1hLCBcImFuZFwiLCBcIm9yXCIgbm90IHN1cHBvcnRlZCBpbiBxdWVyeSBidWlsZGVyJyxcbiAgICB9O1xuICB9XG4gIGlmIChub2RlLmZpcnN0Q2hpbGQhLm5hbWUgPT09ICdJcExhYmVsRmlsdGVyJykge1xuICAgIHJldHVybiB7XG4gICAgICBlcnJvcjogJ0lwTGFiZWxGaWx0ZXIgbm90IHN1cHBvcnRlZCBpbiBxdWVyeSBidWlsZGVyJyxcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgaWQgPSAnX19sYWJlbF9maWx0ZXInO1xuICBpZiAobm9kZS5maXJzdENoaWxkIS5uYW1lID09PSAnVW5pdEZpbHRlcicpIHtcbiAgICBjb25zdCBmaWx0ZXIgPSBub2RlLmZpcnN0Q2hpbGQhLmZpcnN0Q2hpbGQ7XG4gICAgY29uc3QgbGFiZWwgPSBmaWx0ZXIhLmZpcnN0Q2hpbGQ7XG4gICAgY29uc3Qgb3AgPSBsYWJlbCEubmV4dFNpYmxpbmc7XG4gICAgY29uc3QgdmFsdWUgPSBvcCEubmV4dFNpYmxpbmc7XG4gICAgY29uc3QgdmFsdWVTdHJpbmcgPSBoYW5kbGVRdW90ZXMoZ2V0U3RyaW5nKGV4cHIsIHZhbHVlKSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgb3BlcmF0aW9uOiB7XG4gICAgICAgIGlkLFxuICAgICAgICBwYXJhbXM6IFtnZXRTdHJpbmcoZXhwciwgbGFiZWwpLCBnZXRTdHJpbmcoZXhwciwgb3ApLCB2YWx1ZVN0cmluZ10sXG4gICAgICB9LFxuICAgIH07XG4gIH1cbiAgLy8gSW4gdGhpcyBjYXNlIGl0IGlzIE1hdGNoZXIgb3IgTnVtYmVyRmlsdGVyXG4gIGNvbnN0IGZpbHRlciA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgY29uc3QgbGFiZWwgPSBmaWx0ZXIhLmZpcnN0Q2hpbGQ7XG4gIGNvbnN0IG9wID0gbGFiZWwhLm5leHRTaWJsaW5nO1xuICBjb25zdCB2YWx1ZSA9IG9wIS5uZXh0U2libGluZztcbiAgY29uc3QgcGFyYW1zID0gW2dldFN0cmluZyhleHByLCBsYWJlbCksIGdldFN0cmluZyhleHByLCBvcCksIGhhbmRsZVF1b3RlcyhnZXRTdHJpbmcoZXhwciwgdmFsdWUpKV07XG5cbiAgLy8gU3BlY2lhbCBjYXNlIG9mIHBpcGUgZmlsdGVyaW5nIC0gbm8gZXJyb3JzXG4gIGlmIChwYXJhbXMuam9pbignJykgPT09IGBfX2Vycm9yX189YCkge1xuICAgIHJldHVybiB7XG4gICAgICBvcGVyYXRpb246IHtcbiAgICAgICAgaWQ6ICdfX2xhYmVsX2ZpbHRlcl9ub19lcnJvcnMnLFxuICAgICAgICBwYXJhbXM6IFtdLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBvcGVyYXRpb246IHtcbiAgICAgIGlkLFxuICAgICAgcGFyYW1zLFxuICAgIH0sXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldExpbmVGb3JtYXQoZXhwcjogc3RyaW5nLCBub2RlOiBTeW50YXhOb2RlKTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uIHtcbiAgY29uc3QgaWQgPSAnbGluZV9mb3JtYXQnO1xuICBjb25zdCBzdHJpbmcgPSBoYW5kbGVRdW90ZXMoZ2V0U3RyaW5nKGV4cHIsIG5vZGUuZ2V0Q2hpbGQoJ1N0cmluZycpKSk7XG5cbiAgcmV0dXJuIHtcbiAgICBpZCxcbiAgICBwYXJhbXM6IFtzdHJpbmddLFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRMYWJlbEZvcm1hdChleHByOiBzdHJpbmcsIG5vZGU6IFN5bnRheE5vZGUpOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24ge1xuICBjb25zdCBpZCA9ICdsYWJlbF9mb3JtYXQnO1xuICBjb25zdCBpZGVudGlmaWVyID0gbm9kZS5nZXRDaGlsZCgnSWRlbnRpZmllcicpO1xuICBjb25zdCBvcCA9IGlkZW50aWZpZXIhLm5leHRTaWJsaW5nO1xuICBjb25zdCB2YWx1ZSA9IG9wIS5uZXh0U2libGluZztcblxuICBsZXQgdmFsdWVTdHJpbmcgPSBoYW5kbGVRdW90ZXMoZ2V0U3RyaW5nKGV4cHIsIHZhbHVlKSk7XG5cbiAgcmV0dXJuIHtcbiAgICBpZCxcbiAgICBwYXJhbXM6IFtnZXRTdHJpbmcoZXhwciwgaWRlbnRpZmllciksIHZhbHVlU3RyaW5nXSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0VW53cmFwKGV4cHI6IHN0cmluZywgbm9kZTogU3ludGF4Tm9kZSk6IHsgb3BlcmF0aW9uPzogUXVlcnlCdWlsZGVyT3BlcmF0aW9uOyBlcnJvcj86IHN0cmluZyB9IHtcbiAgLy8gQ2hlY2sgZm9yIG5vZGVzIG5vdCBzdXBwb3J0ZWQgaW4gdmlzdWFsIGJ1aWxkZXIgYW5kIHJldHVybiBlcnJvclxuICBpZiAobm9kZS5nZXRDaGlsZCgnQ29udk9wJykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3I6ICdVbndyYXAgd2l0aCBjb252ZXJzaW9uIG9wZXJhdG9yIG5vdCBzdXBwb3J0ZWQgaW4gcXVlcnkgYnVpbGRlcicsXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IGlkID0gJ3Vud3JhcCc7XG4gIGNvbnN0IHN0cmluZyA9IGdldFN0cmluZyhleHByLCBub2RlLmdldENoaWxkKCdJZGVudGlmaWVyJykpO1xuXG4gIHJldHVybiB7XG4gICAgb3BlcmF0aW9uOiB7XG4gICAgICBpZCxcbiAgICAgIHBhcmFtczogW3N0cmluZ10sXG4gICAgfSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlUmFuZ2VBZ2dyZWdhdGlvbihleHByOiBzdHJpbmcsIG5vZGU6IFN5bnRheE5vZGUsIGNvbnRleHQ6IENvbnRleHQpIHtcbiAgY29uc3QgbmFtZU5vZGUgPSBub2RlLmdldENoaWxkKCdSYW5nZU9wJyk7XG4gIGNvbnN0IGZ1bmNOYW1lID0gZ2V0U3RyaW5nKGV4cHIsIG5hbWVOb2RlKTtcbiAgY29uc3QgbnVtYmVyID0gbm9kZS5nZXRDaGlsZCgnTnVtYmVyJyk7XG4gIGNvbnN0IGxvZ0V4cHIgPSBub2RlLmdldENoaWxkKCdMb2dSYW5nZUV4cHInKTtcbiAgY29uc3QgcGFyYW1zID0gbnVtYmVyICE9PSBudWxsICYmIG51bWJlciAhPT0gdW5kZWZpbmVkID8gW2dldFN0cmluZyhleHByLCBudW1iZXIpXSA6IFtdO1xuXG4gIGxldCBtYXRjaCA9IGdldFN0cmluZyhleHByLCBub2RlKS5tYXRjaCgvXFxbKC4rKVxcXS8pO1xuICBpZiAobWF0Y2g/LlsxXSkge1xuICAgIHBhcmFtcy5wdXNoKG1hdGNoWzFdKTtcbiAgfVxuXG4gIGNvbnN0IG9wID0ge1xuICAgIGlkOiBmdW5jTmFtZSxcbiAgICBwYXJhbXMsXG4gIH07XG5cbiAgaWYgKGxvZ0V4cHIpIHtcbiAgICBoYW5kbGVFeHByZXNzaW9uKGV4cHIsIGxvZ0V4cHIsIGNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIG9wO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVWZWN0b3JBZ2dyZWdhdGlvbihleHByOiBzdHJpbmcsIG5vZGU6IFN5bnRheE5vZGUsIGNvbnRleHQ6IENvbnRleHQpIHtcbiAgY29uc3QgbmFtZU5vZGUgPSBub2RlLmdldENoaWxkKCdWZWN0b3JPcCcpO1xuICBsZXQgZnVuY05hbWUgPSBnZXRTdHJpbmcoZXhwciwgbmFtZU5vZGUpO1xuXG4gIGNvbnN0IGdyb3VwaW5nID0gbm9kZS5nZXRDaGlsZCgnR3JvdXBpbmcnKTtcbiAgY29uc3QgbGFiZWxzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIGlmIChncm91cGluZykge1xuICAgIGNvbnN0IGJ5TW9kaWZpZXIgPSBncm91cGluZy5nZXRDaGlsZChgQnlgKTtcbiAgICBpZiAoYnlNb2RpZmllciAmJiBmdW5jTmFtZSkge1xuICAgICAgZnVuY05hbWUgPSBgX18ke2Z1bmNOYW1lfV9ieWA7XG4gICAgfVxuXG4gICAgY29uc3Qgd2l0aG91dE1vZGlmaWVyID0gZ3JvdXBpbmcuZ2V0Q2hpbGQoYFdpdGhvdXRgKTtcbiAgICBpZiAod2l0aG91dE1vZGlmaWVyKSB7XG4gICAgICBmdW5jTmFtZSA9IGBfXyR7ZnVuY05hbWV9X3dpdGhvdXRgO1xuICAgIH1cblxuICAgIGxhYmVscy5wdXNoKC4uLmdldEFsbEJ5VHlwZShleHByLCBncm91cGluZywgJ0lkZW50aWZpZXInKSk7XG4gIH1cblxuICBjb25zdCBtZXRyaWNFeHByID0gbm9kZS5nZXRDaGlsZCgnTWV0cmljRXhwcicpO1xuICBjb25zdCBvcDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uID0geyBpZDogZnVuY05hbWUsIHBhcmFtczogbGFiZWxzIH07XG5cbiAgaWYgKG1ldHJpY0V4cHIpIHtcbiAgICBoYW5kbGVFeHByZXNzaW9uKGV4cHIsIG1ldHJpY0V4cHIsIGNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIG9wO1xufVxuXG5jb25zdCBvcGVyYXRvclRvT3BOYW1lID0gYmluYXJ5U2NhbGFyRGVmcy5yZWR1Y2UoKGFjYywgZGVmKSA9PiB7XG4gIGFjY1tkZWYuc2lnbl0gPSB7XG4gICAgaWQ6IGRlZi5pZCxcbiAgICBjb21wYXJpc29uOiBkZWYuY29tcGFyaXNvbixcbiAgfTtcbiAgcmV0dXJuIGFjYztcbn0sIHt9IGFzIFJlY29yZDxzdHJpbmcsIHsgaWQ6IHN0cmluZzsgY29tcGFyaXNvbj86IGJvb2xlYW4gfT4pO1xuXG4vKipcbiAqIFJpZ2h0IG5vdyBiaW5hcnkgZXhwcmVzc2lvbnMgY2FuIGJlIHJlcHJlc2VudGVkIGluIDIgd2F5IGluIHZpc3VhbCBxdWVyeS4gQXMgYWRkaXRpb25hbCBvcGVyYXRpb24gaW4gY2FzZSBpdCBpc1xuICoganVzdCBvcGVyYXRpb24gd2l0aCBzY2FsYXIgb3IgaXQgY3JlYXRlcyBhIGJpbmFyeVF1ZXJ5IHdoZW4gaXQncyAyIHF1ZXJpZXMuXG4gKiBAcGFyYW0gZXhwclxuICogQHBhcmFtIG5vZGVcbiAqIEBwYXJhbSBjb250ZXh0XG4gKi9cbmZ1bmN0aW9uIGhhbmRsZUJpbmFyeShleHByOiBzdHJpbmcsIG5vZGU6IFN5bnRheE5vZGUsIGNvbnRleHQ6IENvbnRleHQpIHtcbiAgY29uc3QgdmlzUXVlcnkgPSBjb250ZXh0LnF1ZXJ5O1xuICBjb25zdCBsZWZ0ID0gbm9kZS5maXJzdENoaWxkITtcbiAgY29uc3Qgb3AgPSBnZXRTdHJpbmcoZXhwciwgbGVmdC5uZXh0U2libGluZyk7XG4gIGNvbnN0IGJpbk1vZGlmaWVyID0gZ2V0QmluYXJ5TW9kaWZpZXIoZXhwciwgbm9kZS5nZXRDaGlsZCgnQmluTW9kaWZpZXJzJykpO1xuXG4gIGNvbnN0IHJpZ2h0ID0gbm9kZS5sYXN0Q2hpbGQhO1xuXG4gIGNvbnN0IG9wRGVmID0gb3BlcmF0b3JUb09wTmFtZVtvcF07XG5cbiAgY29uc3QgbGVmdE51bWJlciA9IGdldExhc3RDaGlsZFdpdGhTZWxlY3RvcihsZWZ0LCAnTWV0cmljRXhwci5MaXRlcmFsRXhwci5OdW1iZXInKTtcbiAgY29uc3QgcmlnaHROdW1iZXIgPSBnZXRMYXN0Q2hpbGRXaXRoU2VsZWN0b3IocmlnaHQsICdNZXRyaWNFeHByLkxpdGVyYWxFeHByLk51bWJlcicpO1xuXG4gIGNvbnN0IHJpZ2h0QmluYXJ5ID0gcmlnaHQuZ2V0Q2hpbGQoJ0Jpbk9wRXhwcicpO1xuXG4gIGlmIChsZWZ0TnVtYmVyKSB7XG4gICAgLy8gVE9ETzogdGhpcyBzaG91bGQgYmUgYWxyZWFkeSBoYW5kbGVkIGluIGNhc2UgcGFyZW50IGlzIGJpbmFyeSBleHByZXNzaW9uIGFzIGl0IGhhcyB0byBiZSBhZGRlZCB0byBwYXJlbnRcbiAgICAvLyAgaWYgcXVlcnkgc3RhcnRzIHdpdGggYSBudW1iZXIgdGhhdCBpc24ndCBoYW5kbGVkIG5vdy5cbiAgfSBlbHNlIHtcbiAgICAvLyBJZiB0aGlzIGlzIGJpbmFyeSB3ZSBkb24ndCByZWFsbHkga25vdyBpZiB0aGVyZSBpcyBhIHF1ZXJ5IG9yIGp1c3QgY2hhaW5lZCBzY2FsYXJzLiBTb1xuICAgIC8vIHdlIGhhdmUgdG8gdHJhdmVyc2UgYSBiaXQgZGVlcGVyIHRvIGtub3dcbiAgICBoYW5kbGVFeHByZXNzaW9uKGV4cHIsIGxlZnQsIGNvbnRleHQpO1xuICB9XG5cbiAgaWYgKHJpZ2h0TnVtYmVyKSB7XG4gICAgdmlzUXVlcnkub3BlcmF0aW9ucy5wdXNoKG1ha2VCaW5PcChvcERlZiwgZXhwciwgcmlnaHQsICEhYmluTW9kaWZpZXI/LmlzQm9vbCkpO1xuICB9IGVsc2UgaWYgKHJpZ2h0QmluYXJ5KSB7XG4gICAgLy8gRHVlIHRvIHRoZSB3YXkgYmluYXJ5IG9wcyBhcmUgcGFyc2VkIHdlIGNhbiBnZXQgYSBiaW5hcnkgb3BlcmF0aW9uIG9uIHRoZSByaWdodCB0aGF0IHN0YXJ0cyB3aXRoIGEgbnVtYmVyIHdoaWNoXG4gICAgLy8gaXMgYSBmYWN0b3IgZm9yIGEgY3VycmVudCBiaW5hcnkgb3BlcmF0aW9uLiBTbyB3ZSBoYXZlIHRvIGFkZCBpdCBhcyBhbiBvcGVyYXRpb24gbm93LlxuICAgIGNvbnN0IGxlZnRNb3N0Q2hpbGQgPSBnZXRMZWZ0TW9zdENoaWxkKHJpZ2h0KTtcbiAgICBpZiAobGVmdE1vc3RDaGlsZD8ubmFtZSA9PT0gJ051bWJlcicpIHtcbiAgICAgIHZpc1F1ZXJ5Lm9wZXJhdGlvbnMucHVzaChtYWtlQmluT3Aob3BEZWYsIGV4cHIsIGxlZnRNb3N0Q2hpbGQsICEhYmluTW9kaWZpZXI/LmlzQm9vbCkpO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGFkZGVkIHRoZSBmaXJzdCBudW1iZXIgbGl0ZXJhbCBhcyBvcGVyYXRpb24gaGVyZSB3ZSBzdGlsbCBjYW4gY29udGludWUgYW5kIGhhbmRsZSB0aGUgcmVzdCBhcyB0aGUgZmlyc3RcbiAgICAvLyBudW1iZXIgd2lsbCBiZSBqdXN0IHNraXBwZWQuXG4gICAgaGFuZGxlRXhwcmVzc2lvbihleHByLCByaWdodCwgY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgdmlzUXVlcnkuYmluYXJ5UXVlcmllcyA9IHZpc1F1ZXJ5LmJpbmFyeVF1ZXJpZXMgfHwgW107XG4gICAgY29uc3QgYmluUXVlcnk6IExva2lWaXN1YWxRdWVyeUJpbmFyeSA9IHtcbiAgICAgIG9wZXJhdG9yOiBvcCxcbiAgICAgIHF1ZXJ5OiB7XG4gICAgICAgIGxhYmVsczogW10sXG4gICAgICAgIG9wZXJhdGlvbnM6IFtdLFxuICAgICAgfSxcbiAgICB9O1xuICAgIGlmIChiaW5Nb2RpZmllcj8uaXNNYXRjaGVyKSB7XG4gICAgICBiaW5RdWVyeS52ZWN0b3JNYXRjaGVzVHlwZSA9IGJpbk1vZGlmaWVyLm1hdGNoVHlwZTtcbiAgICAgIGJpblF1ZXJ5LnZlY3Rvck1hdGNoZXMgPSBiaW5Nb2RpZmllci5tYXRjaGVzO1xuICAgIH1cbiAgICB2aXNRdWVyeS5iaW5hcnlRdWVyaWVzLnB1c2goYmluUXVlcnkpO1xuICAgIGhhbmRsZUV4cHJlc3Npb24oZXhwciwgcmlnaHQsIHtcbiAgICAgIHF1ZXJ5OiBiaW5RdWVyeS5xdWVyeSxcbiAgICAgIGVycm9yczogY29udGV4dC5lcnJvcnMsXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QmluYXJ5TW9kaWZpZXIoXG4gIGV4cHI6IHN0cmluZyxcbiAgbm9kZTogU3ludGF4Tm9kZSB8IG51bGxcbik6XG4gIHwgeyBpc0Jvb2w6IHRydWU7IGlzTWF0Y2hlcjogZmFsc2UgfVxuICB8IHsgaXNCb29sOiBmYWxzZTsgaXNNYXRjaGVyOiB0cnVlOyBtYXRjaGVzOiBzdHJpbmc7IG1hdGNoVHlwZTogJ2lnbm9yaW5nJyB8ICdvbicgfVxuICB8IHVuZGVmaW5lZCB7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKG5vZGUuZ2V0Q2hpbGQoJ0Jvb2wnKSkge1xuICAgIHJldHVybiB7IGlzQm9vbDogdHJ1ZSwgaXNNYXRjaGVyOiBmYWxzZSB9O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG1hdGNoZXIgPSBub2RlLmdldENoaWxkKCdPbk9ySWdub3JpbmcnKTtcbiAgICBpZiAoIW1hdGNoZXIpIHtcbiAgICAgIC8vIE5vdCBzdXJlIHdoYXQgdGhpcyBjb3VsZCBiZSwgbWF5YmUgc2hvdWxkIGJlIGFuIGVycm9yLlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgbGFiZWxzID0gZ2V0U3RyaW5nKGV4cHIsIG1hdGNoZXIuZ2V0Q2hpbGQoJ0dyb3VwaW5nTGFiZWxzJyk/LmdldENoaWxkKCdHcm91cGluZ0xhYmVsTGlzdCcpKTtcbiAgICByZXR1cm4ge1xuICAgICAgaXNNYXRjaGVyOiB0cnVlLFxuICAgICAgaXNCb29sOiBmYWxzZSxcbiAgICAgIG1hdGNoZXM6IGxhYmVscyxcbiAgICAgIG1hdGNoVHlwZTogbWF0Y2hlci5nZXRDaGlsZCgnT24nKSA/ICdvbicgOiAnaWdub3JpbmcnLFxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNJbnRlcnZhbFZhcmlhYmxlRXJyb3Iobm9kZTogU3ludGF4Tm9kZSkge1xuICByZXR1cm4gbm9kZT8ucGFyZW50Py5uYW1lID09PSAnUmFuZ2UnO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVRdW90ZXMoc3RyaW5nOiBzdHJpbmcpIHtcbiAgaWYgKHN0cmluZ1swXSA9PT0gYFwiYCAmJiBzdHJpbmdbc3RyaW5nLmxlbmd0aCAtIDFdID09PSBgXCJgKSB7XG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9cIi9nLCAnJykucmVwbGFjZSgvXFxcXFxcXFwvZywgJ1xcXFwnKTtcbiAgfVxuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL2AvZywgJycpO1xufVxuXG4vKipcbiAqIFNpbXBsZSBoZWxwZXIgdG8gdHJhdmVyc2UgdGhlIHN5bnRheCB0cmVlLiBJbnN0ZWFkIG9mIG5vZGUuZ2V0Q2hpbGQoJ2ZvbycpPy5nZXRDaGlsZCgnYmFyJyk/LmdldENoaWxkKCdiYXonKSB5b3VcbiAqIGNhbiB3cml0ZSBnZXRDaGlsZFdpdGhTZWxlY3Rvcihub2RlLCAnZm9vLmJhci5iYXonKVxuICogQHBhcmFtIG5vZGVcbiAqIEBwYXJhbSBzZWxlY3RvclxuICovXG5mdW5jdGlvbiBnZXRMYXN0Q2hpbGRXaXRoU2VsZWN0b3Iobm9kZTogU3ludGF4Tm9kZSwgc2VsZWN0b3I6IHN0cmluZykge1xuICBsZXQgY2hpbGQ6IFN5bnRheE5vZGUgfCBudWxsID0gbm9kZTtcbiAgY29uc3QgY2hpbGRyZW4gPSBzZWxlY3Rvci5zcGxpdCgnLicpO1xuICBmb3IgKGNvbnN0IHMgb2YgY2hpbGRyZW4pIHtcbiAgICBjaGlsZCA9IGNoaWxkLmdldENoaWxkKHMpO1xuICAgIGlmICghY2hpbGQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2hpbGQ7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGVucmljaCBlcnJvciB0ZXh0IHdpdGggaW5mb3JtYXRpb24gdGhhdCB2aXN1YWwgcXVlcnkgYnVpbGRlciBkb2Vzbid0IHN1cHBvcnQgdGhhdCBsb2dRTFxuICogQHBhcmFtIGV4cHJcbiAqIEBwYXJhbSBub2RlXG4gKiBAcGFyYW0gZXJyb3JcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IoZXhwcjogc3RyaW5nLCBub2RlOiBTeW50YXhOb2RlLCBlcnJvcjogc3RyaW5nKSB7XG4gIGNvbnN0IGVyciA9IG1ha2VFcnJvcihleHByLCBub2RlKTtcbiAgZXJyLnRleHQgPSBgJHtlcnJvcn06ICR7ZXJyLnRleHR9YDtcbiAgcmV0dXJuIGVycjtcbn1cblxuZnVuY3Rpb24gaXNFbXB0eVF1ZXJ5KHF1ZXJ5OiBMb2tpVmlzdWFsUXVlcnkpIHtcbiAgaWYgKHF1ZXJ5LmxhYmVscy5sZW5ndGggPT09IDAgJiYgcXVlcnkub3BlcmF0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG4iLCJpbXBvcnQgc3RvcmUgZnJvbSAnYXBwL2NvcmUvc3RvcmUnO1xuXG5pbXBvcnQgeyBRdWVyeUVkaXRvck1vZGUgfSBmcm9tICcuLi8uLi9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvdHlwZXMnO1xuaW1wb3J0IHsgTG9raVF1ZXJ5LCBMb2tpUXVlcnlUeXBlIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5jb25zdCBxdWVyeUVkaXRvck1vZGVEZWZhdWx0TG9jYWxTdG9yYWdlS2V5ID0gJ0xva2lRdWVyeUVkaXRvck1vZGVEZWZhdWx0JztcblxuZXhwb3J0IGZ1bmN0aW9uIGNoYW5nZUVkaXRvck1vZGUocXVlcnk6IExva2lRdWVyeSwgZWRpdG9yTW9kZTogUXVlcnlFZGl0b3JNb2RlLCBvbkNoYW5nZTogKHF1ZXJ5OiBMb2tpUXVlcnkpID0+IHZvaWQpIHtcbiAgLy8gSWYgZW1wdHkgcXVlcnkgc3RvcmUgbmV3IG1vZGUgYXMgZGVmYXVsdFxuICBpZiAocXVlcnkuZXhwciA9PT0gJycpIHtcbiAgICBzdG9yZS5zZXQocXVlcnlFZGl0b3JNb2RlRGVmYXVsdExvY2FsU3RvcmFnZUtleSwgZWRpdG9yTW9kZSk7XG4gIH1cblxuICBvbkNoYW5nZSh7IC4uLnF1ZXJ5LCBlZGl0b3JNb2RlIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdEVkaXRvck1vZGUoZXhwcjogc3RyaW5nKSB7XG4gIC8vIElmIHdlIGFscmVhZHkgaGF2ZSBhbiBleHByZXNzaW9uIGRlZmF1bHQgdG8gY29kZSB2aWV3XG4gIGlmIChleHByICE9IG51bGwgJiYgZXhwciAhPT0gJycpIHtcbiAgICByZXR1cm4gUXVlcnlFZGl0b3JNb2RlLkNvZGU7XG4gIH1cblxuICBjb25zdCB2YWx1ZSA9IHN0b3JlLmdldChxdWVyeUVkaXRvck1vZGVEZWZhdWx0TG9jYWxTdG9yYWdlS2V5KSBhcyBRdWVyeUVkaXRvck1vZGU7XG4gIHN3aXRjaCAodmFsdWUpIHtcbiAgICBjYXNlIFF1ZXJ5RWRpdG9yTW9kZS5CdWlsZGVyOlxuICAgIGNhc2UgUXVlcnlFZGl0b3JNb2RlLkNvZGU6XG4gICAgY2FzZSBRdWVyeUVkaXRvck1vZGUuRXhwbGFpbjpcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFF1ZXJ5RWRpdG9yTW9kZS5CdWlsZGVyO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBxdWVyeSB3aXRoIGRlZmF1bHRzLCBhbmQgYm9vbGVhbiB0cnVlL2ZhbHNlIGRlcGVuZGluZyBvbiBjaGFuZ2Ugd2FzIHJlcXVpcmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRRdWVyeVdpdGhEZWZhdWx0cyhxdWVyeTogTG9raVF1ZXJ5KTogTG9raVF1ZXJ5IHtcbiAgLy8gSWYgbm8gZXhwciAoaWUgbmV3IHF1ZXJ5KSB0aGVuIGRlZmF1bHQgdG8gYnVpbGRlclxuICBsZXQgcmVzdWx0ID0gcXVlcnk7XG5cbiAgaWYgKCFxdWVyeS5lZGl0b3JNb2RlKSB7XG4gICAgcmVzdWx0ID0geyAuLi5xdWVyeSwgZWRpdG9yTW9kZTogZ2V0RGVmYXVsdEVkaXRvck1vZGUocXVlcnkuZXhwcikgfTtcbiAgfVxuXG4gIGlmIChxdWVyeS5leHByID09IG51bGwpIHtcbiAgICByZXN1bHQgPSB7IC4uLnJlc3VsdCwgZXhwcjogJycgfTtcbiAgfVxuXG4gIGlmIChxdWVyeS5xdWVyeVR5cGUgPT0gbnVsbCkge1xuICAgIC8vIERlZmF1bHQgdG8gcmFuZ2UgcXVlcnlcbiAgICByZXN1bHQgPSB7IC4uLnJlc3VsdCwgcXVlcnlUeXBlOiBMb2tpUXVlcnlUeXBlLlJhbmdlIH07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuIiwiaW1wb3J0IHsgVmlzdWFsUXVlcnlCaW5hcnkgfSBmcm9tICcuLi8uLi9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvTG9raUFuZFByb21RdWVyeU1vZGVsbGVyQmFzZSc7XG5pbXBvcnQgeyBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlciwgUXVlcnlCdWlsZGVyT3BlcmF0aW9uIH0gZnJvbSAnLi4vLi4vcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL3R5cGVzJztcblxuLyoqXG4gKiBWaXN1YWwgcXVlcnkgbW9kZWxcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBMb2tpVmlzdWFsUXVlcnkge1xuICBsYWJlbHM6IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyW107XG4gIG9wZXJhdGlvbnM6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbltdO1xuICBiaW5hcnlRdWVyaWVzPzogTG9raVZpc3VhbFF1ZXJ5QmluYXJ5W107XG59XG5cbmV4cG9ydCB0eXBlIExva2lWaXN1YWxRdWVyeUJpbmFyeSA9IFZpc3VhbFF1ZXJ5QmluYXJ5PExva2lWaXN1YWxRdWVyeT47XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9raVF1ZXJ5UGF0dGVybiB7XG4gIG5hbWU6IHN0cmluZztcbiAgb3BlcmF0aW9uczogUXVlcnlCdWlsZGVyT3BlcmF0aW9uW107XG59XG5cbmV4cG9ydCBlbnVtIExva2lWaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5IHtcbiAgQWdncmVnYXRpb25zID0gJ0FnZ3JlZ2F0aW9ucycsXG4gIFJhbmdlRnVuY3Rpb25zID0gJ1JhbmdlIGZ1bmN0aW9ucycsXG4gIEZ1bmN0aW9ucyA9ICdGdW5jdGlvbnMnLFxuICBGb3JtYXRzID0gJ0Zvcm1hdHMnLFxuICBMaW5lRmlsdGVycyA9ICdMaW5lIGZpbHRlcnMnLFxuICBMYWJlbEZpbHRlcnMgPSAnTGFiZWwgZmlsdGVycycsXG4gIEJpbmFyeU9wcyA9ICdCaW5hcnkgb3BlcmF0aW9ucycsXG59XG5cbmV4cG9ydCBlbnVtIExva2lPcGVyYXRpb25JZCB7XG4gIEpzb24gPSAnanNvbicsXG4gIExvZ2ZtdCA9ICdsb2dmbXQnLFxuICBSZWdleHAgPSAncmVnZXhwJyxcbiAgUGF0dGVybiA9ICdwYXR0ZXJuJyxcbiAgVW5wYWNrID0gJ3VucGFjaycsXG4gIExpbmVGb3JtYXQgPSAnbGluZV9mb3JtYXQnLFxuICBMYWJlbEZvcm1hdCA9ICdsYWJlbF9mb3JtYXQnLFxuICBSYXRlID0gJ3JhdGUnLFxuICBDb3VudE92ZXJUaW1lID0gJ2NvdW50X292ZXJfdGltZScsXG4gIFN1bU92ZXJUaW1lID0gJ3N1bV9vdmVyX3RpbWUnLFxuICBBdmdPdmVyVGltZSA9ICdhdmdfb3Zlcl90aW1lJyxcbiAgTWF4T3ZlclRpbWUgPSAnbWF4X292ZXJfdGltZScsXG4gIE1pbk92ZXJUaW1lID0gJ21pbl9vdmVyX3RpbWUnLFxuICBGaXJzdE92ZXJUaW1lID0gJ2ZpcnN0X292ZXJfdGltZScsXG4gIExhc3RPdmVyVGltZSA9ICdsYXN0X292ZXJfdGltZScsXG4gIFN0ZHZhck92ZXJUaW1lID0gJ3N0ZHZhcl9vdmVyX3RpbWUnLFxuICBTdGRkZXZPdmVyVGltZSA9ICdzdGRkZXZfb3Zlcl90aW1lJyxcbiAgUXVhbnRpbGVPdmVyVGltZSA9ICdxdWFudGlsZV9vdmVyX3RpbWUnLFxuICBCeXRlc1JhdGUgPSAnYnl0ZXNfcmF0ZScsXG4gIEJ5dGVzT3ZlclRpbWUgPSAnYnl0ZXNfb3Zlcl90aW1lJyxcbiAgQWJzZW50T3ZlclRpbWUgPSAnYWJzZW50X292ZXJfdGltZScsXG4gIFN1bSA9ICdzdW0nLFxuICBBdmcgPSAnYXZnJyxcbiAgTWluID0gJ21pbicsXG4gIE1heCA9ICdtYXgnLFxuICBTdGRkZXYgPSAnc3RkZGV2JyxcbiAgU3RkdmFyID0gJ3N0ZHZhcicsXG4gIENvdW50ID0gJ2NvdW50JyxcbiAgVG9wSyA9ICd0b3BrJyxcbiAgQm90dG9tSyA9ICdib3R0b21rJyxcbiAgTGluZUNvbnRhaW5zID0gJ19fbGluZV9jb250YWlucycsXG4gIExpbmVDb250YWluc05vdCA9ICdfX2xpbmVfY29udGFpbnNfbm90JyxcbiAgTGluZU1hdGNoZXNSZWdleCA9ICdfX2xpbmVfbWF0Y2hlc19yZWdleCcsXG4gIExpbmVNYXRjaGVzUmVnZXhOb3QgPSAnX19saW5lX21hdGNoZXNfcmVnZXhfbm90JyxcbiAgTGFiZWxGaWx0ZXIgPSAnX19sYWJlbF9maWx0ZXInLFxuICBMYWJlbEZpbHRlck5vRXJyb3JzID0gJ19fbGFiZWxfZmlsdGVyX25vX2Vycm9ycycsXG4gIFVud3JhcCA9ICd1bndyYXAnLFxuICAvLyBCaW5hcnkgb3BzXG4gIEFkZGl0aW9uID0gJ19fYWRkaXRpb24nLFxuICBTdWJ0cmFjdGlvbiA9ICdfX3N1YnRyYWN0aW9uJyxcbiAgTXVsdGlwbHlCeSA9ICdfX211bHRpcGx5X2J5JyxcbiAgRGl2aWRlQnkgPSAnX19kaXZpZGVfYnknLFxuICBNb2R1bG8gPSAnX19tb2R1bG8nLFxuICBFeHBvbmVudCA9ICdfX2V4cG9uZW50JyxcbiAgTmVzdGVkUXVlcnkgPSAnX19uZXN0ZWRfcXVlcnknLFxuICBFcXVhbFRvID0gJ19fZXF1YWxfdG8nLFxuICBOb3RFcXVhbFRvID0gJ19fbm90X2VxdWFsX3RvJyxcbiAgR3JlYXRlclRoYW4gPSAnX19ncmVhdGVyX3RoYW4nLFxuICBMZXNzVGhhbiA9ICdfX2xlc3NfdGhhbicsXG4gIEdyZWF0ZXJPckVxdWFsID0gJ19fZ3JlYXRlcl9vcl9lcXVhbCcsXG4gIExlc3NPckVxdWFsID0gJ19fbGVzc19vcl9lcXVhbCcsXG59XG5cbmV4cG9ydCBlbnVtIExva2lPcGVyYXRpb25PcmRlciB7XG4gIExpbmVGaWx0ZXJzID0gMSxcbiAgTGluZUZvcm1hdHMgPSAyLFxuICBMYWJlbEZpbHRlcnMgPSAzLFxuICBVbndyYXAgPSA0LFxuICBOb0Vycm9ycyA9IDUsXG4gIFJhbmdlVmVjdG9yRnVuY3Rpb24gPSA1LFxuICBMYXN0ID0gNixcbn1cbiIsImltcG9ydCB7IGNhcGl0YWxpemUsIGdyb3VwQnksIGlzRW1wdHkgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgb2YgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHY1IGFzIHV1aWR2NSB9IGZyb20gJ3V1aWQnO1xuXG5pbXBvcnQge1xuICBGaWVsZFR5cGUsXG4gIFRpbWVTZXJpZXMsXG4gIExhYmVscyxcbiAgRGF0YUZyYW1lLFxuICBBcnJheVZlY3RvcixcbiAgTXV0YWJsZURhdGFGcmFtZSxcbiAgZmluZFVuaXF1ZUxhYmVscyxcbiAgRGF0YUZyYW1lVmlldyxcbiAgRGF0YUxpbmssXG4gIEZpZWxkLFxuICBRdWVyeVJlc3VsdE1ldGFTdGF0LFxuICBRdWVyeVJlc3VsdE1ldGEsXG4gIFRpbWVTZXJpZXNWYWx1ZSxcbiAgU2NvcGVkVmFycyxcbiAgdG9EYXRhRnJhbWUsXG59IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgZ2V0VGVtcGxhdGVTcnYsIGdldERhdGFTb3VyY2VTcnYgfSBmcm9tICdAZ3JhZmFuYS9ydW50aW1lJztcbmltcG9ydCBUYWJsZU1vZGVsIGZyb20gJ2FwcC9jb3JlL3RhYmxlX21vZGVsJztcblxuaW1wb3J0IHsgcmVuZGVyTGVnZW5kRm9ybWF0IH0gZnJvbSAnLi4vcHJvbWV0aGV1cy9sZWdlbmQnO1xuXG5pbXBvcnQgeyBmb3JtYXRRdWVyeSwgZ2V0SGlnaGxpZ2h0ZXJFeHByZXNzaW9uc0Zyb21RdWVyeSB9IGZyb20gJy4vcXVlcnlfdXRpbHMnO1xuaW1wb3J0IHtcbiAgTG9raVJhbmdlUXVlcnlSZXF1ZXN0LFxuICBMb2tpUmVzcG9uc2UsXG4gIExva2lNYXRyaXhSZXN1bHQsXG4gIExva2lWZWN0b3JSZXN1bHQsXG4gIFRyYW5zZm9ybWVyT3B0aW9ucyxcbiAgTG9raVJlc3VsdFR5cGUsXG4gIExva2lTdHJlYW1SZXN1bHQsXG4gIExva2lUYWlsUmVzcG9uc2UsXG4gIExva2lRdWVyeSxcbiAgTG9raU9wdGlvbnMsXG4gIERlcml2ZWRGaWVsZENvbmZpZyxcbiAgTG9raVN0cmVhbVJlc3BvbnNlLFxuICBMb2tpU3RhdHMsXG59IGZyb20gJy4vdHlwZXMnO1xuXG5jb25zdCBVVUlEX05BTUVTUEFDRSA9ICc2ZWM5NDZkYS0wZjQ5LTQ3YTgtOTgzYS0xZDc2ZDE3ZTdjOTInO1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgTG9raVN0cmVhbVJlc3VsdCBzdHJ1Y3R1cmUgaW50byBhIGRhdGFGcmFtZS4gVXNlZCB3aGVuIGRvaW5nIHN0YW5kYXJkIHF1ZXJpZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxva2lTdHJlYW1zVG9SYXdEYXRhRnJhbWUoc3RyZWFtczogTG9raVN0cmVhbVJlc3VsdFtdLCByZWZJZD86IHN0cmluZyk6IERhdGFGcmFtZSB7XG4gIGNvbnN0IGxhYmVscyA9IG5ldyBBcnJheVZlY3Rvcjx7fT4oW10pO1xuICBjb25zdCB0aW1lcyA9IG5ldyBBcnJheVZlY3RvcjxzdHJpbmc+KFtdKTtcbiAgY29uc3QgdGltZXNOcyA9IG5ldyBBcnJheVZlY3RvcjxzdHJpbmc+KFtdKTtcbiAgY29uc3QgbGluZXMgPSBuZXcgQXJyYXlWZWN0b3I8c3RyaW5nPihbXSk7XG4gIGNvbnN0IHVpZHMgPSBuZXcgQXJyYXlWZWN0b3I8c3RyaW5nPihbXSk7XG5cbiAgLy8gV2UgbmVlZCB0byBzdG9yZSBhbmQgdHJhY2sgYWxsIHVzZWQgdWlkcyB0byBlbnN1cmUgdGhhdCB1aWRzIGFyZSB1bmlxdWVcbiAgY29uc3QgdXNlZFVpZHM6IHsgc3RyaW5nPzogbnVtYmVyIH0gPSB7fTtcblxuICBmb3IgKGNvbnN0IHN0cmVhbSBvZiBzdHJlYW1zKSB7XG4gICAgY29uc3Qgc3RyZWFtTGFiZWxzOiBMYWJlbHMgPSBzdHJlYW0uc3RyZWFtO1xuICAgIGNvbnN0IGxhYmVsc1N0cmluZyA9IE9iamVjdC5lbnRyaWVzKHN0cmVhbUxhYmVscylcbiAgICAgIC5tYXAoKFtrZXksIHZhbF0pID0+IGAke2tleX09XCIke3ZhbH1cImApXG4gICAgICAuc29ydCgpXG4gICAgICAuam9pbignJyk7XG5cbiAgICBmb3IgKGNvbnN0IFt0cywgbGluZV0gb2Ygc3RyZWFtLnZhbHVlcykge1xuICAgICAgbGFiZWxzLmFkZChzdHJlYW1MYWJlbHMpO1xuICAgICAgLy8gbnVtIG5zIGVwb2NoIGluIHN0cmluZywgd2UgY29udmVydCBpdCB0byBpc28gc3RyaW5nIGhlcmUgc28gaXQgbWF0Y2hlcyBvbGQgZm9ybWF0XG4gICAgICB0aW1lcy5hZGQobmV3IERhdGUocGFyc2VJbnQodHMuc2xpY2UoMCwgLTYpLCAxMCkpLnRvSVNPU3RyaW5nKCkpO1xuICAgICAgdGltZXNOcy5hZGQodHMpO1xuICAgICAgbGluZXMuYWRkKGxpbmUpO1xuICAgICAgdWlkcy5hZGQoY3JlYXRlVWlkKHRzLCBsYWJlbHNTdHJpbmcsIGxpbmUsIHVzZWRVaWRzLCByZWZJZCkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25zdHJ1Y3REYXRhRnJhbWUodGltZXMsIHRpbWVzTnMsIGxpbmVzLCB1aWRzLCBsYWJlbHMsIHJlZklkKTtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGRhdGFGcmFtZSB3aXRoIHN1cHBsaWVkIGZpZWxkcyBhbmQgb3RoZXIgZGF0YS5cbiAqL1xuZnVuY3Rpb24gY29uc3RydWN0RGF0YUZyYW1lKFxuICB0aW1lczogQXJyYXlWZWN0b3I8c3RyaW5nPixcbiAgdGltZXNOczogQXJyYXlWZWN0b3I8c3RyaW5nPixcbiAgbGluZXM6IEFycmF5VmVjdG9yPHN0cmluZz4sXG4gIHVpZHM6IEFycmF5VmVjdG9yPHN0cmluZz4sXG4gIGxhYmVsczogQXJyYXlWZWN0b3I8e30+LFxuICByZWZJZD86IHN0cmluZ1xuKSB7XG4gIGNvbnN0IGRhdGFGcmFtZSA9IHtcbiAgICByZWZJZCxcbiAgICBmaWVsZHM6IFtcbiAgICAgIHsgbmFtZTogJ2xhYmVscycsIHR5cGU6IEZpZWxkVHlwZS5vdGhlciwgY29uZmlnOiB7fSwgdmFsdWVzOiBsYWJlbHMgfSxcbiAgICAgIHsgbmFtZTogJ3RzJywgdHlwZTogRmllbGRUeXBlLnRpbWUsIGNvbmZpZzogeyBkaXNwbGF5TmFtZTogJ1RpbWUnIH0sIHZhbHVlczogdGltZXMgfSwgLy8gVGltZVxuICAgICAgeyBuYW1lOiAnbGluZScsIHR5cGU6IEZpZWxkVHlwZS5zdHJpbmcsIGNvbmZpZzoge30sIHZhbHVlczogbGluZXMgfSwgLy8gTGluZSAtIG5lZWRzIHRvIGJlIHRoZSBmaXJzdCBmaWVsZCB3aXRoIHN0cmluZyB0eXBlXG4gICAgICB7IG5hbWU6ICd0c05zJywgdHlwZTogRmllbGRUeXBlLnRpbWUsIGNvbmZpZzogeyBkaXNwbGF5TmFtZTogJ1RpbWUgbnMnIH0sIHZhbHVlczogdGltZXNOcyB9LCAvLyBUaW1lXG4gICAgICB7IG5hbWU6ICdpZCcsIHR5cGU6IEZpZWxkVHlwZS5zdHJpbmcsIGNvbmZpZzoge30sIHZhbHVlczogdWlkcyB9LFxuICAgIF0sXG4gICAgbGVuZ3RoOiB0aW1lcy5sZW5ndGgsXG4gIH07XG5cbiAgcmV0dXJuIGRhdGFGcmFtZTtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gTG9raVJlc3BvbnNlIGRhdGEgYW5kIGFwcGVuZHMgaXQgdG8gTXV0YWJsZURhdGFGcmFtZS4gVXNlZCBmb3Igc3RyZWFtaW5nIHdoZXJlIHRoZSBkYXRhRnJhbWUgY2FuIGJlXG4gKiBhIENpcmN1bGFyRGF0YUZyYW1lIGNyZWF0aW5nIGEgZml4ZWQgc2l6ZSByb2xsaW5nIGJ1ZmZlci5cbiAqIFRPRE86IFByb2JhYmx5IGNvdWxkIGJlIHVuaWZpZWQgd2l0aCB0aGUgbG9nU3RyZWFtVG9EYXRhRnJhbWUgZnVuY3Rpb24uXG4gKiBAcGFyYW0gcmVzcG9uc2VcbiAqIEBwYXJhbSBkYXRhIE5lZWRzIHRvIGhhdmUgdHMsIGxpbmUsIGxhYmVscywgaWQgYXMgZmllbGRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRSZXNwb25zZVRvQnVmZmVyZWREYXRhKHJlc3BvbnNlOiBMb2tpVGFpbFJlc3BvbnNlLCBkYXRhOiBNdXRhYmxlRGF0YUZyYW1lKSB7XG4gIC8vIFNob3VsZCB3ZSBkbyBhbnl0aGluZyB3aXRoOiByZXNwb25zZS5kcm9wcGVkX2VudHJpZXM/XG5cbiAgY29uc3Qgc3RyZWFtczogTG9raVN0cmVhbVJlc3VsdFtdID0gcmVzcG9uc2Uuc3RyZWFtcztcbiAgaWYgKCFzdHJlYW1zIHx8ICFzdHJlYW1zLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBiYXNlTGFiZWxzOiBMYWJlbHMgPSB7fTtcbiAgZm9yIChjb25zdCBmIG9mIGRhdGEuZmllbGRzKSB7XG4gICAgaWYgKGYudHlwZSA9PT0gRmllbGRUeXBlLnN0cmluZykge1xuICAgICAgaWYgKGYubGFiZWxzKSB7XG4gICAgICAgIGJhc2VMYWJlbHMgPSBmLmxhYmVscztcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGxhYmVsc0ZpZWxkID0gZGF0YS5maWVsZHNbMF07XG4gIGNvbnN0IHRzRmllbGQgPSBkYXRhLmZpZWxkc1sxXTtcbiAgY29uc3QgbGluZUZpZWxkID0gZGF0YS5maWVsZHNbMl07XG4gIGNvbnN0IGlkRmllbGQgPSBkYXRhLmZpZWxkc1szXTtcbiAgY29uc3QgdHNOc0ZpZWxkID0gZGF0YS5maWVsZHNbNF07XG5cbiAgLy8gV2UgYXJlIGNvbXBhcmluZyB1c2VkIGlkcyBvbmx5IHdpdGhpbiB0aGUgcmVjZWl2ZWQgc3RyZWFtLiBUaGlzIGNvdWxkIGJlIGEgcHJvYmxlbSBpZiB0aGUgc2FtZSBsaW5lICsgbGFiZWxzICsgbmFub3NlY29uZCB0aW1lc3RhbXAgY2FtZSBpbiAyIHNlcGFyYXRlIGJhdGNoZXMuXG4gIC8vIEFzIHRoaXMgaXMgdmVyeSB1bmxpa2VseSwgYW5kIHRoZSByZXN1bHQgd291bGQgb25seSBhZmZlY3QgbGl2ZS10YWlsaW5nIGNzcyBhbmltYXRpb24gd2UgaGF2ZSBkZWNpZGVkIHRvIG5vdCBjb21wYXJlIGFsbCByZWNlaXZlZCB1aWRzIGZyb20gZGF0YSBwYXJhbSBhcyB0aGlzIHdvdWxkIHNsb3cgZG93biBwcm9jZXNzaW5nLlxuICBjb25zdCB1c2VkVWlkczogeyBzdHJpbmc/OiBudW1iZXIgfSA9IHt9O1xuXG4gIGZvciAoY29uc3Qgc3RyZWFtIG9mIHN0cmVhbXMpIHtcbiAgICAvLyBGaW5kIHVuaXF1ZSBsYWJlbHNcbiAgICBjb25zdCB1bmlxdWUgPSBmaW5kVW5pcXVlTGFiZWxzKHN0cmVhbS5zdHJlYW0sIGJhc2VMYWJlbHMpO1xuICAgIGNvbnN0IGFsbExhYmVsc1N0cmluZyA9IE9iamVjdC5lbnRyaWVzKHN0cmVhbS5zdHJlYW0pXG4gICAgICAubWFwKChba2V5LCB2YWxdKSA9PiBgJHtrZXl9PVwiJHt2YWx9XCJgKVxuICAgICAgLnNvcnQoKVxuICAgICAgLmpvaW4oJycpO1xuXG4gICAgLy8gQWRkIGVhY2ggbGluZVxuICAgIGZvciAoY29uc3QgW3RzLCBsaW5lXSBvZiBzdHJlYW0udmFsdWVzKSB7XG4gICAgICB0c0ZpZWxkLnZhbHVlcy5hZGQobmV3IERhdGUocGFyc2VJbnQodHMuc2xpY2UoMCwgLTYpLCAxMCkpLnRvSVNPU3RyaW5nKCkpO1xuICAgICAgdHNOc0ZpZWxkLnZhbHVlcy5hZGQodHMpO1xuICAgICAgbGluZUZpZWxkLnZhbHVlcy5hZGQobGluZSk7XG4gICAgICBsYWJlbHNGaWVsZC52YWx1ZXMuYWRkKHVuaXF1ZSk7XG4gICAgICBpZEZpZWxkLnZhbHVlcy5hZGQoY3JlYXRlVWlkKHRzLCBhbGxMYWJlbHNTdHJpbmcsIGxpbmUsIHVzZWRVaWRzLCBkYXRhLnJlZklkKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVVpZCh0czogc3RyaW5nLCBsYWJlbHNTdHJpbmc6IHN0cmluZywgbGluZTogc3RyaW5nLCB1c2VkVWlkczogYW55LCByZWZJZD86IHN0cmluZyk6IHN0cmluZyB7XG4gIC8vIEdlbmVyYXRlIGlkIGFzIGhhc2hlZCBuYW5vc2Vjb25kIHRpbWVzdGFtcCwgbGFiZWxzIGFuZCBsaW5lICh0aGlzIGRvZXMgbm90IGhhdmUgdG8gYmUgdW5pcXVlKVxuICBsZXQgaWQgPSB1dWlkdjUoYCR7dHN9XyR7bGFiZWxzU3RyaW5nfV8ke2xpbmV9YCwgVVVJRF9OQU1FU1BBQ0UpO1xuXG4gIC8vIENoZWNrIGlmIGdlbmVyYXRlZCBpZCBpcyB1bmlxdWVcbiAgLy8gSWYgbm90IGFuZCB3ZSd2ZSBhbHJlYWR5IHVzZWQgaXQsIGFwcGVuZCBpdCdzIGNvdW50IGFmdGVyIGl0XG4gIGlmIChpZCBpbiB1c2VkVWlkcykge1xuICAgIC8vIEluY3JlYXNlIHRoZSBjb3VudFxuICAgIGNvbnN0IG5ld0NvdW50ID0gdXNlZFVpZHNbaWRdICsgMTtcbiAgICB1c2VkVWlkc1tpZF0gPSBuZXdDb3VudDtcbiAgICAvLyBBcHBlbmQgY291bnQgdG8gZ2VuZXJhdGVkIGlkIHRvIG1ha2UgaXQgdW5pcXVlXG4gICAgaWQgPSBgJHtpZH1fJHtuZXdDb3VudH1gO1xuICB9IGVsc2Uge1xuICAgIC8vIElmIGlkIGlzIHVuaXF1ZSBhbmQgd2Fzbid0IHVzZWQsIGFkZCBpdCB0byB1c2VkVWlkcyBhbmQgc3RhcnQgY291bnQgYXQgMFxuICAgIHVzZWRVaWRzW2lkXSA9IDA7XG4gIH1cbiAgLy8gUmV0dXJuIHVuaXF1ZSBpZFxuICBpZiAocmVmSWQpIHtcbiAgICByZXR1cm4gYCR7aWR9XyR7cmVmSWR9YDtcbiAgfVxuICByZXR1cm4gaWQ7XG59XG5cbmZ1bmN0aW9uIGxva2lNYXRyaXhUb1RpbWVTZXJpZXMobWF0cml4UmVzdWx0OiBMb2tpTWF0cml4UmVzdWx0LCBvcHRpb25zOiBUcmFuc2Zvcm1lck9wdGlvbnMpOiBUaW1lU2VyaWVzIHtcbiAgY29uc3QgbmFtZSA9IGNyZWF0ZU1ldHJpY0xhYmVsKG1hdHJpeFJlc3VsdC5tZXRyaWMsIG9wdGlvbnMpO1xuICByZXR1cm4ge1xuICAgIHRhcmdldDogbmFtZSxcbiAgICB0aXRsZTogbmFtZSxcbiAgICBkYXRhcG9pbnRzOiBsb2tpUG9pbnRzVG9UaW1lc2VyaWVzUG9pbnRzKG1hdHJpeFJlc3VsdC52YWx1ZXMpLFxuICAgIHRhZ3M6IG1hdHJpeFJlc3VsdC5tZXRyaWMsXG4gICAgbWV0YTogb3B0aW9ucy5tZXRhLFxuICAgIHJlZklkOiBvcHRpb25zLnJlZklkLFxuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZVByb21ldGhldXNGb3JtYXRTYW1wbGVWYWx1ZSh2YWx1ZTogc3RyaW5nKTogbnVtYmVyIHtcbiAgc3dpdGNoICh2YWx1ZSkge1xuICAgIGNhc2UgJytJbmYnOlxuICAgICAgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBjYXNlICctSW5mJzpcbiAgICAgIHJldHVybiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9raVBvaW50c1RvVGltZXNlcmllc1BvaW50cyhkYXRhOiBBcnJheTxbbnVtYmVyLCBzdHJpbmddPik6IFRpbWVTZXJpZXNWYWx1ZVtdW10ge1xuICBjb25zdCBkYXRhcG9pbnRzOiBUaW1lU2VyaWVzVmFsdWVbXVtdID0gW107XG5cbiAgZm9yIChjb25zdCBbdGltZSwgdmFsdWVdIG9mIGRhdGEpIHtcbiAgICBsZXQgZGF0YXBvaW50VmFsdWU6IFRpbWVTZXJpZXNWYWx1ZSA9IHBhcnNlUHJvbWV0aGV1c0Zvcm1hdFNhbXBsZVZhbHVlKHZhbHVlKTtcblxuICAgIGNvbnN0IHRpbWVzdGFtcCA9IHRpbWUgKiAxMDAwO1xuXG4gICAgZGF0YXBvaW50cy5wdXNoKFtkYXRhcG9pbnRWYWx1ZSwgdGltZXN0YW1wXSk7XG4gIH1cblxuICByZXR1cm4gZGF0YXBvaW50cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxva2lSZXN1bHRzVG9UYWJsZU1vZGVsKFxuICBsb2tpUmVzdWx0czogQXJyYXk8TG9raU1hdHJpeFJlc3VsdCB8IExva2lWZWN0b3JSZXN1bHQ+LFxuICByZXN1bHRDb3VudDogbnVtYmVyLFxuICByZWZJZDogc3RyaW5nLFxuICBtZXRhOiBRdWVyeVJlc3VsdE1ldGFcbik6IFRhYmxlTW9kZWwge1xuICBpZiAoIWxva2lSZXN1bHRzIHx8IGxva2lSZXN1bHRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgVGFibGVNb2RlbCgpO1xuICB9XG5cbiAgLy8gQ29sbGVjdCBhbGwgbGFiZWxzIGFjcm9zcyBhbGwgbWV0cmljc1xuICBjb25zdCBtZXRyaWNMYWJlbHM6IFNldDxzdHJpbmc+ID0gbmV3IFNldDxzdHJpbmc+KFxuICAgIGxva2lSZXN1bHRzLnJlZHVjZSgoYWNjLCBjdXIpID0+IGFjYy5jb25jYXQoT2JqZWN0LmtleXMoY3VyLm1ldHJpYykpLCBbXSBhcyBzdHJpbmdbXSlcbiAgKTtcblxuICAvLyBTb3J0IG1ldHJpYyBsYWJlbHMsIGNyZWF0ZSBjb2x1bW5zIGZvciB0aGVtIGFuZCByZWNvcmQgdGhlaXIgaW5kZXhcbiAgY29uc3Qgc29ydGVkTGFiZWxzID0gWy4uLm1ldHJpY0xhYmVscy52YWx1ZXMoKV0uc29ydCgpO1xuICBjb25zdCB0YWJsZSA9IG5ldyBUYWJsZU1vZGVsKCk7XG4gIHRhYmxlLnJlZklkID0gcmVmSWQ7XG4gIHRhYmxlLm1ldGEgPSBtZXRhO1xuICB0YWJsZS5jb2x1bW5zID0gW1xuICAgIHsgdGV4dDogJ1RpbWUnLCB0eXBlOiBGaWVsZFR5cGUudGltZSB9LFxuICAgIC4uLnNvcnRlZExhYmVscy5tYXAoKGxhYmVsKSA9PiAoeyB0ZXh0OiBsYWJlbCwgZmlsdGVyYWJsZTogdHJ1ZSwgdHlwZTogRmllbGRUeXBlLnN0cmluZyB9KSksXG4gICAgeyB0ZXh0OiBgVmFsdWUgIyR7cmVmSWR9YCwgdHlwZTogRmllbGRUeXBlLm51bWJlciB9LFxuICBdO1xuXG4gIC8vIFBvcHVsYXRlIHJvd3MsIHNldCB2YWx1ZSB0byBlbXB0eSBzdHJpbmcgd2hlbiBsYWJlbCBub3QgcHJlc2VudC5cbiAgbG9raVJlc3VsdHMuZm9yRWFjaCgoc2VyaWVzKSA9PiB7XG4gICAgY29uc3QgbmV3U2VyaWVzOiBMb2tpTWF0cml4UmVzdWx0ID0ge1xuICAgICAgbWV0cmljOiBzZXJpZXMubWV0cmljLFxuICAgICAgdmFsdWVzOiAoc2VyaWVzIGFzIExva2lWZWN0b3JSZXN1bHQpLnZhbHVlXG4gICAgICAgID8gWyhzZXJpZXMgYXMgTG9raVZlY3RvclJlc3VsdCkudmFsdWVdXG4gICAgICAgIDogKHNlcmllcyBhcyBMb2tpTWF0cml4UmVzdWx0KS52YWx1ZXMsXG4gICAgfTtcblxuICAgIGlmICghbmV3U2VyaWVzLnZhbHVlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghbmV3U2VyaWVzLm1ldHJpYykge1xuICAgICAgdGFibGUucm93cy5jb25jYXQobmV3U2VyaWVzLnZhbHVlcy5tYXAoKFthLCBiXSkgPT4gW2EgKiAxMDAwLCBwYXJzZUZsb2F0KGIpXSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YWJsZS5yb3dzLnB1c2goXG4gICAgICAgIC4uLm5ld1Nlcmllcy52YWx1ZXMubWFwKChbYSwgYl0pID0+IFtcbiAgICAgICAgICBhICogMTAwMCxcbiAgICAgICAgICAuLi5zb3J0ZWRMYWJlbHMubWFwKChsYWJlbCkgPT4gbmV3U2VyaWVzLm1ldHJpY1tsYWJlbF0gfHwgJycpLFxuICAgICAgICAgIHBhcnNlRmxvYXQoYiksXG4gICAgICAgIF0pXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRhYmxlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWV0cmljTGFiZWwobGFiZWxEYXRhOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9LCBvcHRpb25zPzogVHJhbnNmb3JtZXJPcHRpb25zKSB7XG4gIGxldCBsYWJlbCA9XG4gICAgb3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8IGlzRW1wdHkob3B0aW9ucy5sZWdlbmRGb3JtYXQpXG4gICAgICA/IGdldE9yaWdpbmFsTWV0cmljTmFtZShsYWJlbERhdGEpXG4gICAgICA6IHJlbmRlckxlZ2VuZEZvcm1hdChnZXRUZW1wbGF0ZVNydigpLnJlcGxhY2Uob3B0aW9ucy5sZWdlbmRGb3JtYXQgPz8gJycsIG9wdGlvbnMuc2NvcGVkVmFycyksIGxhYmVsRGF0YSk7XG5cbiAgaWYgKCFsYWJlbCAmJiBvcHRpb25zKSB7XG4gICAgbGFiZWwgPSBvcHRpb25zLnF1ZXJ5O1xuICB9XG4gIHJldHVybiBsYWJlbDtcbn1cblxuZnVuY3Rpb24gZ2V0T3JpZ2luYWxNZXRyaWNOYW1lKGxhYmVsRGF0YTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSkge1xuICBjb25zdCBsYWJlbFBhcnQgPSBPYmplY3QuZW50cmllcyhsYWJlbERhdGEpXG4gICAgLm1hcCgobGFiZWwpID0+IGAke2xhYmVsWzBdfT1cIiR7bGFiZWxbMV19XCJgKVxuICAgIC5qb2luKCcsJyk7XG4gIHJldHVybiBgeyR7bGFiZWxQYXJ0fX1gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVjYW1lbGl6ZShzOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gcy5yZXBsYWNlKC9bQS1aXS9nLCAobSkgPT4gYCAke20udG9Mb3dlckNhc2UoKX1gKTtcbn1cblxuLy8gVHVybiBsb2tpIHN0YXRzIHsgbWV0cmljOiB2YWx1ZSB9IGludG8gbWV0YSBzdGF0IHsgdGl0bGU6IG1ldHJpYywgdmFsdWU6IHZhbHVlIH1cbmZ1bmN0aW9uIGxva2lTdGF0c1RvTWV0YVN0YXQoc3RhdHM6IExva2lTdGF0cyB8IHVuZGVmaW5lZCk6IFF1ZXJ5UmVzdWx0TWV0YVN0YXRbXSB7XG4gIGNvbnN0IHJlc3VsdDogUXVlcnlSZXN1bHRNZXRhU3RhdFtdID0gW107XG5cbiAgaWYgKCFzdGF0cykge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmb3IgKGNvbnN0IHNlY3Rpb24gaW4gc3RhdHMpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBzdGF0c1tzZWN0aW9uXTtcbiAgICBmb3IgKGNvbnN0IGxhYmVsIGluIHZhbHVlcykge1xuICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbbGFiZWxdO1xuICAgICAgbGV0IHVuaXQ7XG4gICAgICBpZiAoL3RpbWUvaS50ZXN0KGxhYmVsKSAmJiB2YWx1ZSkge1xuICAgICAgICB1bml0ID0gJ3MnO1xuICAgICAgfSBlbHNlIGlmICgvYnl0ZXMuKnBlcnNlY29uZC9pLnRlc3QobGFiZWwpKSB7XG4gICAgICAgIHVuaXQgPSAnQnBzJztcbiAgICAgIH0gZWxzZSBpZiAoL2J5dGVzL2kudGVzdChsYWJlbCkpIHtcbiAgICAgICAgdW5pdCA9ICdkZWNieXRlcyc7XG4gICAgICB9XG4gICAgICBjb25zdCB0aXRsZSA9IGAke2NhcGl0YWxpemUoc2VjdGlvbil9OiAke2RlY2FtZWxpemUobGFiZWwpfWA7XG4gICAgICByZXN1bHQucHVzaCh7IGRpc3BsYXlOYW1lOiB0aXRsZSwgdmFsdWUsIHVuaXQgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxva2lTdHJlYW1zVG9EYXRhRnJhbWVzKFxuICByZXNwb25zZTogTG9raVN0cmVhbVJlc3BvbnNlLFxuICB0YXJnZXQ6IExva2lRdWVyeSxcbiAgbGltaXQ6IG51bWJlcixcbiAgY29uZmlnOiBMb2tpT3B0aW9uc1xuKTogRGF0YUZyYW1lW10ge1xuICBjb25zdCBkYXRhID0gbGltaXQgPiAwID8gcmVzcG9uc2UuZGF0YS5yZXN1bHQgOiBbXTtcbiAgY29uc3Qgc3RhdHM6IFF1ZXJ5UmVzdWx0TWV0YVN0YXRbXSA9IGxva2lTdGF0c1RvTWV0YVN0YXQocmVzcG9uc2UuZGF0YS5zdGF0cyk7XG4gIC8vIFVzZSBjdXN0b20gbWVjaGFuaXNtIHRvIGlkZW50aWZ5IHdoaWNoIHN0YXQgd2Ugd2FudCB0byBwcm9tb3RlIHRvIGxhYmVsXG4gIGNvbnN0IGN1c3RvbSA9IHtcbiAgICBsb2tpUXVlcnlTdGF0S2V5OiAnU3VtbWFyeTogdG90YWwgYnl0ZXMgcHJvY2Vzc2VkJyxcbiAgfTtcblxuICBjb25zdCBtZXRhOiBRdWVyeVJlc3VsdE1ldGEgPSB7XG4gICAgc2VhcmNoV29yZHM6IGdldEhpZ2hsaWdodGVyRXhwcmVzc2lvbnNGcm9tUXVlcnkoZm9ybWF0UXVlcnkodGFyZ2V0LmV4cHIpKSxcbiAgICBsaW1pdCxcbiAgICBzdGF0cyxcbiAgICBjdXN0b20sXG4gICAgcHJlZmVycmVkVmlzdWFsaXNhdGlvblR5cGU6ICdsb2dzJyxcbiAgfTtcblxuICBjb25zdCBkYXRhRnJhbWUgPSBsb2tpU3RyZWFtc1RvUmF3RGF0YUZyYW1lKGRhdGEsIHRhcmdldC5yZWZJZCk7XG4gIGVuaGFuY2VEYXRhRnJhbWUoZGF0YUZyYW1lLCBjb25maWcpO1xuXG4gIGlmIChtZXRhLmN1c3RvbSAmJiBkYXRhRnJhbWUuZmllbGRzLnNvbWUoKGYpID0+IGYubGFiZWxzICYmIE9iamVjdC5rZXlzKGYubGFiZWxzKS5zb21lKChsKSA9PiBsID09PSAnX19lcnJvcl9fJykpKSB7XG4gICAgbWV0YS5jdXN0b20uZXJyb3IgPSAnRXJyb3Igd2hlbiBwYXJzaW5nIHNvbWUgb2YgdGhlIGxvZ3MnO1xuICB9XG5cbiAgaWYgKHN0YXRzLmxlbmd0aCAmJiAhZGF0YS5sZW5ndGgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICBmaWVsZHM6IFtdLFxuICAgICAgICBsZW5ndGg6IDAsXG4gICAgICAgIHJlZklkOiB0YXJnZXQucmVmSWQsXG4gICAgICAgIG1ldGEsXG4gICAgICB9LFxuICAgIF07XG4gIH1cblxuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIC4uLmRhdGFGcmFtZSxcbiAgICAgIHJlZklkOiB0YXJnZXQucmVmSWQsXG4gICAgICBtZXRhLFxuICAgIH0sXG4gIF07XG59XG5cbi8qKlxuICogQWRkcyBuZXcgZmllbGRzIGFuZCBEYXRhTGlua3MgdG8gRGF0YUZyYW1lIGJhc2VkIG9uIERhdGFTb3VyY2UgaW5zdGFuY2UgY29uZmlnLlxuICovXG5leHBvcnQgY29uc3QgZW5oYW5jZURhdGFGcmFtZSA9IChkYXRhRnJhbWU6IERhdGFGcmFtZSwgY29uZmlnOiBMb2tpT3B0aW9ucyB8IG51bGwpOiB2b2lkID0+IHtcbiAgaWYgKCFjb25maWcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBkZXJpdmVkRmllbGRzID0gY29uZmlnLmRlcml2ZWRGaWVsZHMgPz8gW107XG4gIGlmICghZGVyaXZlZEZpZWxkcy5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZGVyaXZlZEZpZWxkc0dyb3VwZWQgPSBncm91cEJ5KGRlcml2ZWRGaWVsZHMsICduYW1lJyk7XG5cbiAgY29uc3QgbmV3RmllbGRzID0gT2JqZWN0LnZhbHVlcyhkZXJpdmVkRmllbGRzR3JvdXBlZCkubWFwKGZpZWxkRnJvbURlcml2ZWRGaWVsZENvbmZpZyk7XG5cbiAgY29uc3QgdmlldyA9IG5ldyBEYXRhRnJhbWVWaWV3KGRhdGFGcmFtZSk7XG4gIHZpZXcuZm9yRWFjaCgocm93OiB7IGxpbmU6IHN0cmluZyB9KSA9PiB7XG4gICAgZm9yIChjb25zdCBmaWVsZCBvZiBuZXdGaWVsZHMpIHtcbiAgICAgIGNvbnN0IGxvZ01hdGNoID0gcm93LmxpbmUubWF0Y2goZGVyaXZlZEZpZWxkc0dyb3VwZWRbZmllbGQubmFtZV1bMF0ubWF0Y2hlclJlZ2V4KTtcbiAgICAgIGZpZWxkLnZhbHVlcy5hZGQobG9nTWF0Y2ggJiYgbG9nTWF0Y2hbMV0pO1xuICAgIH1cbiAgfSk7XG5cbiAgZGF0YUZyYW1lLmZpZWxkcyA9IFsuLi5kYXRhRnJhbWUuZmllbGRzLCAuLi5uZXdGaWVsZHNdO1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gZGVyaXZlZEZpZWxkIGNvbmZpZyBpbnRvIGRhdGFmcmFtZSBmaWVsZCB3aXRoIGNvbmZpZyB0aGF0IGNvbnRhaW5zIGxpbmsuXG4gKi9cbmZ1bmN0aW9uIGZpZWxkRnJvbURlcml2ZWRGaWVsZENvbmZpZyhkZXJpdmVkRmllbGRDb25maWdzOiBEZXJpdmVkRmllbGRDb25maWdbXSk6IEZpZWxkPGFueSwgQXJyYXlWZWN0b3I+IHtcbiAgY29uc3QgZGF0YVNvdXJjZVNydiA9IGdldERhdGFTb3VyY2VTcnYoKTtcblxuICBjb25zdCBkYXRhTGlua3MgPSBkZXJpdmVkRmllbGRDb25maWdzLnJlZHVjZSgoYWNjLCBkZXJpdmVkRmllbGRDb25maWcpID0+IHtcbiAgICAvLyBIYXZpbmcgZmllbGQuZGF0YXNvdXJjZVVpZCBtZWFucyBpdCBpcyBhbiBpbnRlcm5hbCBsaW5rLlxuICAgIGlmIChkZXJpdmVkRmllbGRDb25maWcuZGF0YXNvdXJjZVVpZCkge1xuICAgICAgY29uc3QgZHNTZXR0aW5ncyA9IGRhdGFTb3VyY2VTcnYuZ2V0SW5zdGFuY2VTZXR0aW5ncyhkZXJpdmVkRmllbGRDb25maWcuZGF0YXNvdXJjZVVpZCk7XG5cbiAgICAgIGFjYy5wdXNoKHtcbiAgICAgICAgLy8gV2lsbCBiZSBmaWxsZWQgb3V0IGxhdGVyXG4gICAgICAgIHRpdGxlOiBkZXJpdmVkRmllbGRDb25maWcudXJsRGlzcGxheUxhYmVsIHx8ICcnLFxuICAgICAgICB1cmw6ICcnLFxuICAgICAgICAvLyBUaGlzIGlzIGhhcmRjb2RlZCBmb3IgSmFlZ2VyIG9yIFppcGtpbiBub3Qgd2F5IHJpZ2h0IG5vdyB0byBzcGVjaWZ5IGRhdGFzb3VyY2Ugc3BlY2lmaWMgcXVlcnkgb2JqZWN0XG4gICAgICAgIGludGVybmFsOiB7XG4gICAgICAgICAgcXVlcnk6IHsgcXVlcnk6IGRlcml2ZWRGaWVsZENvbmZpZy51cmwgfSxcbiAgICAgICAgICBkYXRhc291cmNlVWlkOiBkZXJpdmVkRmllbGRDb25maWcuZGF0YXNvdXJjZVVpZCxcbiAgICAgICAgICBkYXRhc291cmNlTmFtZTogZHNTZXR0aW5ncz8ubmFtZSA/PyAnRGF0YSBzb3VyY2Ugbm90IGZvdW5kJyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoZGVyaXZlZEZpZWxkQ29uZmlnLnVybCkge1xuICAgICAgYWNjLnB1c2goe1xuICAgICAgICAvLyBXZSBkbyBub3Qga25vdyB3aGF0IHRpdGxlIHRvIGdpdmUgaGVyZSBzbyB3ZSBjb3VudCBvbiBwcmVzZW50YXRpb24gbGF5ZXIgdG8gY3JlYXRlIGEgdGl0bGUgZnJvbSBtZXRhZGF0YS5cbiAgICAgICAgdGl0bGU6IGRlcml2ZWRGaWVsZENvbmZpZy51cmxEaXNwbGF5TGFiZWwgfHwgJycsXG4gICAgICAgIC8vIFRoaXMgaXMgaGFyZGNvZGVkIGZvciBKYWVnZXIgb3IgWmlwa2luIG5vdCB3YXkgcmlnaHQgbm93IHRvIHNwZWNpZnkgZGF0YXNvdXJjZSBzcGVjaWZpYyBxdWVyeSBvYmplY3RcbiAgICAgICAgdXJsOiBkZXJpdmVkRmllbGRDb25maWcudXJsLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBhY2M7XG4gIH0sIFtdIGFzIERhdGFMaW5rW10pO1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogZGVyaXZlZEZpZWxkQ29uZmlnc1swXS5uYW1lLFxuICAgIHR5cGU6IEZpZWxkVHlwZS5zdHJpbmcsXG4gICAgY29uZmlnOiB7XG4gICAgICBsaW5rczogZGF0YUxpbmtzLFxuICAgIH0sXG4gICAgLy8gV2UgYXJlIGFkZGluZyB2YWx1ZXMgbGF0ZXIgb25cbiAgICB2YWx1ZXM6IG5ldyBBcnJheVZlY3RvcjxzdHJpbmc+KFtdKSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmFuZ2VRdWVyeVJlc3BvbnNlVG9UaW1lU2VyaWVzKFxuICByZXNwb25zZTogTG9raVJlc3BvbnNlLFxuICBxdWVyeTogTG9raVJhbmdlUXVlcnlSZXF1ZXN0LFxuICB0YXJnZXQ6IExva2lRdWVyeSxcbiAgc2NvcGVkVmFyczogU2NvcGVkVmFyc1xuKTogVGltZVNlcmllc1tdIHtcbiAgLyoqIFNob3cgcmVzdWx0cyBvZiBMb2tpIG1ldHJpYyBxdWVyaWVzIG9ubHkgaW4gZ3JhcGggKi9cbiAgY29uc3QgbWV0YTogUXVlcnlSZXN1bHRNZXRhID0ge1xuICAgIHByZWZlcnJlZFZpc3VhbGlzYXRpb25UeXBlOiAnZ3JhcGgnLFxuICB9O1xuICBjb25zdCB0cmFuc2Zvcm1lck9wdGlvbnM6IFRyYW5zZm9ybWVyT3B0aW9ucyA9IHtcbiAgICBsZWdlbmRGb3JtYXQ6IHRhcmdldC5sZWdlbmRGb3JtYXQgPz8gJycsXG4gICAgcXVlcnk6IHF1ZXJ5LnF1ZXJ5LFxuICAgIHJlZklkOiB0YXJnZXQucmVmSWQsXG4gICAgbWV0YSxcbiAgICBzY29wZWRWYXJzLFxuICB9O1xuXG4gIHN3aXRjaCAocmVzcG9uc2UuZGF0YS5yZXN1bHRUeXBlKSB7XG4gICAgY2FzZSBMb2tpUmVzdWx0VHlwZS5WZWN0b3I6XG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YS5yZXN1bHQubWFwKCh2ZWNSZXN1bHQpID0+XG4gICAgICAgIGxva2lNYXRyaXhUb1RpbWVTZXJpZXMoeyBtZXRyaWM6IHZlY1Jlc3VsdC5tZXRyaWMsIHZhbHVlczogW3ZlY1Jlc3VsdC52YWx1ZV0gfSwgdHJhbnNmb3JtZXJPcHRpb25zKVxuICAgICAgKTtcbiAgICBjYXNlIExva2lSZXN1bHRUeXBlLk1hdHJpeDpcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhLnJlc3VsdC5tYXAoKG1hdHJpeFJlc3VsdCkgPT4gbG9raU1hdHJpeFRvVGltZVNlcmllcyhtYXRyaXhSZXN1bHQsIHRyYW5zZm9ybWVyT3B0aW9ucykpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gW107XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlUXVlcnlSZXNwb25zZVRvRGF0YUZyYW1lcyhcbiAgcmVzcG9uc2U6IExva2lSZXNwb25zZSxcbiAgcXVlcnk6IExva2lSYW5nZVF1ZXJ5UmVxdWVzdCxcbiAgdGFyZ2V0OiBMb2tpUXVlcnksXG4gIHNjb3BlZFZhcnM6IFNjb3BlZFZhcnNcbik6IERhdGFGcmFtZVtdIHtcbiAgY29uc3Qgc2VyaWVzID0gcmFuZ2VRdWVyeVJlc3BvbnNlVG9UaW1lU2VyaWVzKHJlc3BvbnNlLCBxdWVyeSwgdGFyZ2V0LCBzY29wZWRWYXJzKTtcbiAgY29uc3QgZnJhbWVzID0gc2VyaWVzLm1hcCgocykgPT4gdG9EYXRhRnJhbWUocykpO1xuXG4gIGNvbnN0IHsgc3RlcCB9ID0gcXVlcnk7XG5cbiAgaWYgKHN0ZXAgIT0gbnVsbCkge1xuICAgIGNvbnN0IGludGVydmFsTXMgPSBzdGVwICogMTAwMDtcblxuICAgIGZyYW1lcy5mb3JFYWNoKChmcmFtZSkgPT4ge1xuICAgICAgZnJhbWUuZmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgICAgIGlmIChmaWVsZC50eXBlID09PSBGaWVsZFR5cGUudGltZSkge1xuICAgICAgICAgIGZpZWxkLmNvbmZpZy5pbnRlcnZhbCA9IGludGVydmFsTXM7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGZyYW1lcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NSYW5nZVF1ZXJ5UmVzcG9uc2UoXG4gIHJlc3BvbnNlOiBMb2tpUmVzcG9uc2UsXG4gIHRhcmdldDogTG9raVF1ZXJ5LFxuICBxdWVyeTogTG9raVJhbmdlUXVlcnlSZXF1ZXN0LFxuICBsaW1pdDogbnVtYmVyLFxuICBjb25maWc6IExva2lPcHRpb25zLFxuICBzY29wZWRWYXJzOiBTY29wZWRWYXJzXG4pIHtcbiAgc3dpdGNoIChyZXNwb25zZS5kYXRhLnJlc3VsdFR5cGUpIHtcbiAgICBjYXNlIExva2lSZXN1bHRUeXBlLlN0cmVhbTpcbiAgICAgIHJldHVybiBvZih7XG4gICAgICAgIGRhdGE6IGxva2lTdHJlYW1zVG9EYXRhRnJhbWVzKHJlc3BvbnNlIGFzIExva2lTdHJlYW1SZXNwb25zZSwgdGFyZ2V0LCBsaW1pdCwgY29uZmlnKSxcbiAgICAgICAga2V5OiBgJHt0YXJnZXQucmVmSWR9X2xvZ2AsXG4gICAgICB9KTtcblxuICAgIGNhc2UgTG9raVJlc3VsdFR5cGUuVmVjdG9yOlxuICAgIGNhc2UgTG9raVJlc3VsdFR5cGUuTWF0cml4OlxuICAgICAgcmV0dXJuIG9mKHtcbiAgICAgICAgZGF0YTogcmFuZ2VRdWVyeVJlc3BvbnNlVG9EYXRhRnJhbWVzKHJlc3BvbnNlLCBxdWVyeSwgdGFyZ2V0LCBzY29wZWRWYXJzKSxcbiAgICAgICAga2V5OiB0YXJnZXQucmVmSWQsXG4gICAgICB9KTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHJlc3VsdCB0eXBlIFwiJHsocmVzcG9uc2UuZGF0YSBhcyBhbnkpLnJlc3VsdFR5cGV9XCIuYCk7XG4gIH1cbn1cbiIsImltcG9ydCB7IERhdGFGcmFtZSwgRmllbGQsIFNvcnRlZFZlY3RvciB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuXG50eXBlIFNvcnREaXJlY3Rpb24gPSAnQVNDRU5ESU5HJyB8ICdERVNDRU5ESU5HJztcblxuLy8gY3JlYXRlcyB0aGUgYGluZGV4YCBmb3IgdGhlIHNvcnRpbmcuXG4vLyB0aGlzIGlzIG5lZWRlZCBieSB0aGUgYFNvcnRlZFZlY3RvcmAuXG4vLyB0aGUgaW5kZXggaXMgYW4gYXJyYXkgb2YgbnVtYmVycywgYW5kIGl0IGRlZmluZXMgYW4gb3JkZXIuXG4vLyBhdCBldmVyeSBzbG90IGluIHRoZSBpbmRleCB0aGUgdmFsdWVzIGlzIHRoZSBwb3NpdGlvbiBvZlxuLy8gdGhlIHNvcnRlZCBpdGVtLlxuLy8gZm9yIGV4YW1wbGUsIGFuIGluZGV4IG9mIFszLDEsMl0gbWVhbnMgdGhhdFxuLy8gaW4gdGhlIGRhdGFmcmFtZSwgdGhhdCBoYXMgMyByb3dzLCBhZnRlciBzb3J0aW5nOlxuLy8gLSB0aGUgdGhpcmQgcm93IHdpbGwgYmVjb21lIHRoZSBmaXJzdFxuLy8gLSB0aGUgZmlyc3Qgcm93IHdpbGwgYmVjb21lIHRoZSBzZWNvbmRcbi8vIC0gdGhlIHNlY29uZCByb3cgd2lsbCBiZWNvbWUgdGhlIHRoaXJkXG5mdW5jdGlvbiBtYWtlSW5kZXgoZmllbGQ6IEZpZWxkPHN0cmluZz4sIGRpcjogU29ydERpcmVjdGlvbik6IG51bWJlcltdIHtcbiAgY29uc3QgZmllbGRWYWx1ZXM6IHN0cmluZ1tdID0gZmllbGQudmFsdWVzLnRvQXJyYXkoKTtcblxuICAvLyB3ZSBmaXJzdCBidWlsZCBhbiBhcnJheSB3aGljaCBpcyBbMCwxLDIsMy4uLi5dXG4gIGNvbnN0IGluZGV4ID0gQXJyYXkoZmllbGRWYWx1ZXMubGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleC5sZW5ndGg7IGkrKykge1xuICAgIGluZGV4W2ldID0gaTtcbiAgfVxuXG4gIGNvbnN0IGlzQXNjID0gZGlyID09PSAnQVNDRU5ESU5HJztcblxuICBpbmRleC5zb3J0KChhOiBudW1iZXIsIGI6IG51bWJlcik6IG51bWJlciA9PiB7XG4gICAgLy8gd2UgbmVlZCB0byBhbnN3ZXIgdGhpcyBxdWVzdGlvbjpcbiAgICAvLyBpbiB0aGUgZmllbGQtdXNlZC1mb3Itc29ydGluZywgaG93IHdvdWxkIHdlIGNvbXBhcmUgdmFsdWUtYXQtaW5kZXgtYSB0byB2YWx1ZS1hdC1pbmRleC1iP1xuICAgIGNvbnN0IHZhbEEgPSBmaWVsZFZhbHVlc1thXTtcbiAgICBjb25zdCB2YWxCID0gZmllbGRWYWx1ZXNbYl07XG4gICAgaWYgKHZhbEEgPCB2YWxCKSB7XG4gICAgICByZXR1cm4gaXNBc2MgPyAtMSA6IDE7XG4gICAgfVxuXG4gICAgaWYgKHZhbEEgPiB2YWxCKSB7XG4gICAgICByZXR1cm4gaXNBc2MgPyAxIDogLTE7XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG4gIH0pO1xuXG4gIHJldHVybiBpbmRleDtcbn1cblxuLy8gc29ydCBhIGRhdGFmcmFtZSB0aGF0IGlzIGluIHRoZSBMb2tpIGZvcm1hdCBhc2NlbmRpbmcgb3IgZGVzY2VuZGluZyxcbi8vIGJhc2VkIG9uIHRoZSBuYW5vc2Vjb25kLXRpbWVzdGFtcFxuZXhwb3J0IGZ1bmN0aW9uIHNvcnREYXRhRnJhbWVCeVRpbWUoZnJhbWU6IERhdGFGcmFtZSwgZGlyOiBTb3J0RGlyZWN0aW9uKTogRGF0YUZyYW1lIHtcbiAgY29uc3QgeyBmaWVsZHMsIC4uLnJlc3QgfSA9IGZyYW1lO1xuXG4gIC8vIHdlIHVzZSB0aGUgYXBwcm9hY2ggdXNlZCBpbiBAZ3JhZmFuYS9kYXRhL3NvcnREYXRhZnJhbWUuXG4gIC8vIHdlIGNhbm5vdCB1c2UgaXQgZGlyZWN0bHksIGJlY2F1c2Ugb3VyIHRzTnMgZmllbGQgaGFzIGEgdHlwZT10aW1lLFxuICAvLyBzbyB3ZSBoYXZlIHRvIGJ1aWxkIHRoZSBgaW5kZXhgIG1hbnVhbGx5LlxuXG4gIGNvbnN0IHRzTnNGaWVsZCA9IGZpZWxkcy5maW5kKChmaWVsZCkgPT4gZmllbGQubmFtZSA9PT0gJ3RzTnMnKTtcbiAgaWYgKHRzTnNGaWVsZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIG5hbm9zZWNvbmQtdGltZXN0YW1wIGZpZWxkLiBzaG91bGQgbmV2ZXIgaGFwcGVuJyk7XG4gIH1cblxuICBjb25zdCBpbmRleCA9IG1ha2VJbmRleCh0c05zRmllbGQsIGRpcik7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5yZXN0LFxuICAgIGZpZWxkczogZmllbGRzLm1hcCgoZmllbGQpID0+ICh7XG4gICAgICAuLi5maWVsZCxcbiAgICAgIHZhbHVlczogbmV3IFNvcnRlZFZlY3RvcihmaWVsZC52YWx1ZXMsIGluZGV4KSxcbiAgICB9KSksXG4gIH07XG5cbiAgcmV0dXJuIGZyYW1lO1xufVxuIiwiaW1wb3J0IHsgbWFwLCBPYnNlcnZhYmxlLCBkZWZlciwgbWVyZ2VNYXAgfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgRGF0YUZyYW1lSlNPTiwgRGF0YVF1ZXJ5UmVxdWVzdCwgRGF0YVF1ZXJ5UmVzcG9uc2UsIExpdmVDaGFubmVsU2NvcGUsIExvYWRpbmdTdGF0ZSB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgZ2V0R3JhZmFuYUxpdmVTcnYgfSBmcm9tICdAZ3JhZmFuYS9ydW50aW1lJztcbmltcG9ydCB7IFN0cmVhbWluZ0RhdGFGcmFtZSB9IGZyb20gJ2FwcC9mZWF0dXJlcy9saXZlL2RhdGEvU3RyZWFtaW5nRGF0YUZyYW1lJztcblxuaW1wb3J0IHsgTG9raURhdGFzb3VyY2UgfSBmcm9tICcuL2RhdGFzb3VyY2UnO1xuaW1wb3J0IHsgTG9raVF1ZXJ5IH0gZnJvbSAnLi90eXBlcyc7XG5cbi8qKlxuICogQ2FsY3VsYXRlIGEgdW5pcXVlIGtleSBmb3IgdGhlIHF1ZXJ5LiAgVGhlIGtleSBpcyB1c2VkIHRvIHBpY2sgYSBjaGFubmVsIGFuZCBzaG91bGRcbiAqIGJlIHVuaXF1ZSBmb3IgZWFjaCBkaXN0aW5jdCBxdWVyeSBleGVjdXRpb24gcGxhbi4gIFRoaXMga2V5IGlzIG5vdCBzZWN1cmUgYW5kIGlzIG9ubHkgcGlja2VkIHRvIGF2b2lkXG4gKiBwb3NzaWJsZSBjb2xsaXNpb25zXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRMaXZlU3RyZWFtS2V5KHF1ZXJ5OiBMb2tpUXVlcnkpOiBQcm9taXNlPHN0cmluZz4ge1xuICBjb25zdCBzdHIgPSBKU09OLnN0cmluZ2lmeSh7IGV4cHI6IHF1ZXJ5LmV4cHIgfSk7XG5cbiAgY29uc3QgbXNnVWludDggPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKTsgLy8gZW5jb2RlIGFzICh1dGYtOCkgVWludDhBcnJheVxuICBjb25zdCBoYXNoQnVmZmVyID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5kaWdlc3QoJ1NIQS0xJywgbXNnVWludDgpOyAvLyBoYXNoIHRoZSBtZXNzYWdlXG4gIGNvbnN0IGhhc2hBcnJheSA9IEFycmF5LmZyb20obmV3IFVpbnQ4QXJyYXkoaGFzaEJ1ZmZlci5zbGljZSgwLCA4KSkpOyAvLyBmaXJzdCA4IGJ5dGVzXG4gIHJldHVybiBoYXNoQXJyYXkubWFwKChiKSA9PiBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKS5qb2luKCcnKTtcbn1cblxuLy8gVGhpcyB3aWxsIGdldCBib3RoIHYxIGFuZCB2MiByZXN1bHQgZm9ybWF0c1xuZXhwb3J0IGZ1bmN0aW9uIGRvTG9raUNoYW5uZWxTdHJlYW0oXG4gIHF1ZXJ5OiBMb2tpUXVlcnksXG4gIGRzOiBMb2tpRGF0YXNvdXJjZSxcbiAgb3B0aW9uczogRGF0YVF1ZXJ5UmVxdWVzdDxMb2tpUXVlcnk+XG4pOiBPYnNlcnZhYmxlPERhdGFRdWVyeVJlc3BvbnNlPiB7XG4gIC8vIG1heGltdW0gdGltZSB0byBrZWVwIHZhbHVlc1xuICBjb25zdCByYW5nZSA9IG9wdGlvbnMucmFuZ2U7XG4gIGNvbnN0IG1heERlbHRhID0gcmFuZ2UudG8udmFsdWVPZigpIC0gcmFuZ2UuZnJvbS52YWx1ZU9mKCkgKyAxMDAwO1xuICBsZXQgbWF4TGVuZ3RoID0gb3B0aW9ucy5tYXhEYXRhUG9pbnRzID8/IDEwMDA7XG4gIGlmIChtYXhMZW5ndGggPiAxMDApIHtcbiAgICAvLyBmb3Igc21hbGwgYnVmZmVycywga2VlcCB0aGVtIHNtYWxsXG4gICAgbWF4TGVuZ3RoICo9IDI7XG4gIH1cblxuICBsZXQgZnJhbWU6IFN0cmVhbWluZ0RhdGFGcmFtZSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgY29uc3QgdXBkYXRlRnJhbWUgPSAobXNnOiBhbnkpID0+IHtcbiAgICBpZiAobXNnPy5tZXNzYWdlKSB7XG4gICAgICBjb25zdCBwID0gbXNnLm1lc3NhZ2UgYXMgRGF0YUZyYW1lSlNPTjtcbiAgICAgIGlmICghZnJhbWUpIHtcbiAgICAgICAgZnJhbWUgPSBTdHJlYW1pbmdEYXRhRnJhbWUuZnJvbURhdGFGcmFtZUpTT04ocCwge1xuICAgICAgICAgIG1heExlbmd0aCxcbiAgICAgICAgICBtYXhEZWx0YSxcbiAgICAgICAgICBkaXNwbGF5TmFtZUZvcm1hdDogcXVlcnkubGVnZW5kRm9ybWF0LFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyYW1lLnB1c2gocCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmcmFtZTtcbiAgfTtcblxuICByZXR1cm4gZGVmZXIoKCkgPT4gZ2V0TGl2ZVN0cmVhbUtleShxdWVyeSkpLnBpcGUoXG4gICAgbWVyZ2VNYXAoKGtleSkgPT4ge1xuICAgICAgcmV0dXJuIGdldEdyYWZhbmFMaXZlU3J2KClcbiAgICAgICAgLmdldFN0cmVhbTxhbnk+KHtcbiAgICAgICAgICBzY29wZTogTGl2ZUNoYW5uZWxTY29wZS5EYXRhU291cmNlLFxuICAgICAgICAgIG5hbWVzcGFjZTogZHMudWlkLFxuICAgICAgICAgIHBhdGg6IGB0YWlsLyR7a2V5fWAsXG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgLi4ucXVlcnksXG4gICAgICAgICAgICB0aW1lUmFuZ2U6IHtcbiAgICAgICAgICAgICAgZnJvbTogcmFuZ2UuZnJvbS52YWx1ZU9mKCkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgdG86IHJhbmdlLnRvLnZhbHVlT2YoKS50b1N0cmluZygpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgICAgICAucGlwZShcbiAgICAgICAgICBtYXAoKGV2dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnJhbWUgPSB1cGRhdGVGcmFtZShldnQpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZGF0YTogZnJhbWUgPyBbZnJhbWVdIDogW10sXG4gICAgICAgICAgICAgIHN0YXRlOiBMb2FkaW5nU3RhdGUuU3RyZWFtaW5nLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH0pXG4gICk7XG59XG4iLCJpbXBvcnQgeyBHcmFtbWFyIH0gZnJvbSAncHJpc21qcyc7XG5cbmltcG9ydCB7IENvbXBsZXRpb25JdGVtIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5jb25zdCBBR0dSRUdBVElPTl9PUEVSQVRPUlM6IENvbXBsZXRpb25JdGVtW10gPSBbXG4gIHtcbiAgICBsYWJlbDogJ3N1bScsXG4gICAgaW5zZXJ0VGV4dDogJ3N1bScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ0NhbGN1bGF0ZSBzdW0gb3ZlciBkaW1lbnNpb25zJyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnbWluJyxcbiAgICBpbnNlcnRUZXh0OiAnbWluJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnU2VsZWN0IG1pbmltdW0gb3ZlciBkaW1lbnNpb25zJyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnbWF4JyxcbiAgICBpbnNlcnRUZXh0OiAnbWF4JyxcbiAgICBkb2N1bWVudGF0aW9uOiAnU2VsZWN0IG1heGltdW0gb3ZlciBkaW1lbnNpb25zJyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnYXZnJyxcbiAgICBpbnNlcnRUZXh0OiAnYXZnJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnQ2FsY3VsYXRlIHRoZSBhdmVyYWdlIG92ZXIgZGltZW5zaW9ucycsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ3N0ZGRldicsXG4gICAgaW5zZXJ0VGV4dDogJ3N0ZGRldicsXG4gICAgZG9jdW1lbnRhdGlvbjogJ0NhbGN1bGF0ZSBwb3B1bGF0aW9uIHN0YW5kYXJkIGRldmlhdGlvbiBvdmVyIGRpbWVuc2lvbnMnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdzdGR2YXInLFxuICAgIGluc2VydFRleHQ6ICdzdGR2YXInLFxuICAgIGRvY3VtZW50YXRpb246ICdDYWxjdWxhdGUgcG9wdWxhdGlvbiBzdGFuZGFyZCB2YXJpYW5jZSBvdmVyIGRpbWVuc2lvbnMnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdjb3VudCcsXG4gICAgaW5zZXJ0VGV4dDogJ2NvdW50JyxcbiAgICBkb2N1bWVudGF0aW9uOiAnQ291bnQgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSB2ZWN0b3InLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdib3R0b21rJyxcbiAgICBpbnNlcnRUZXh0OiAnYm90dG9taycsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1NtYWxsZXN0IGsgZWxlbWVudHMgYnkgc2FtcGxlIHZhbHVlJyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAndG9waycsXG4gICAgaW5zZXJ0VGV4dDogJ3RvcGsnLFxuICAgIGRvY3VtZW50YXRpb246ICdMYXJnZXN0IGsgZWxlbWVudHMgYnkgc2FtcGxlIHZhbHVlJyxcbiAgfSxcbl07XG5cbmV4cG9ydCBjb25zdCBQSVBFX1BBUlNFUlM6IENvbXBsZXRpb25JdGVtW10gPSBbXG4gIHtcbiAgICBsYWJlbDogJ2pzb24nLFxuICAgIGluc2VydFRleHQ6ICdqc29uJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnRXh0cmFjdGluZyBsYWJlbHMgZnJvbSB0aGUgbG9nIGxpbmUgdXNpbmcganNvbiBwYXJzZXIuIE9ubHkgYXZhaWxhYmxlIGluIExva2kgMi4wKy4nLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdyZWdleHAnLFxuICAgIGluc2VydFRleHQ6ICdyZWdleHAgXCJcIicsXG4gICAgZG9jdW1lbnRhdGlvbjogJ0V4dHJhY3RpbmcgbGFiZWxzIGZyb20gdGhlIGxvZyBsaW5lIHVzaW5nIHJlZ2V4cCBwYXJzZXIuIE9ubHkgYXZhaWxhYmxlIGluIExva2kgMi4wKy4nLFxuICAgIG1vdmU6IC0xLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdsb2dmbXQnLFxuICAgIGluc2VydFRleHQ6ICdsb2dmbXQnLFxuICAgIGRvY3VtZW50YXRpb246ICdFeHRyYWN0aW5nIGxhYmVscyBmcm9tIHRoZSBsb2cgbGluZSB1c2luZyBsb2dmbXQgcGFyc2VyLiBPbmx5IGF2YWlsYWJsZSBpbiBMb2tpIDIuMCsuJyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAncGF0dGVybicsXG4gICAgaW5zZXJ0VGV4dDogJ3BhdHRlcm4nLFxuICAgIGRvY3VtZW50YXRpb246ICdFeHRyYWN0aW5nIGxhYmVscyBmcm9tIHRoZSBsb2cgbGluZSB1c2luZyBwYXR0ZXJuIHBhcnNlci4gT25seSBhdmFpbGFibGUgaW4gTG9raSAyLjMrLicsXG4gIH0sXG5dO1xuXG5leHBvcnQgY29uc3QgUElQRV9PUEVSQVRPUlM6IENvbXBsZXRpb25JdGVtW10gPSBbXG4gIHtcbiAgICBsYWJlbDogJ3Vud3JhcCcsXG4gICAgaW5zZXJ0VGV4dDogJ3Vud3JhcCcsXG4gICAgZGV0YWlsOiAndW53cmFwIGlkZW50aWZpZXInLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnVGFrZSBsYWJlbHMgYW5kIHVzZSB0aGUgdmFsdWVzIGFzIHNhbXBsZSBkYXRhIGZvciBtZXRyaWMgYWdncmVnYXRpb25zLiBPbmx5IGF2YWlsYWJsZSBpbiBMb2tpIDIuMCsuJyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAndW5wYWNrJyxcbiAgICBpbnNlcnRUZXh0OiAndW5wYWNrJyxcbiAgICBkZXRhaWw6ICd1bnBhY2sgaWRlbnRpZmllcicsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdQYXJzZXMgYSBKU09OIGxvZyBsaW5lLCB1bnBhY2tpbmcgYWxsIGVtYmVkZGVkIGxhYmVscyBpbiB0aGUgcGFjayBzdGFnZS4gQSBzcGVjaWFsIHByb3BlcnR5IFwiX2VudHJ5XCIgd2lsbCBhbHNvIGJlIHVzZWQgdG8gcmVwbGFjZSB0aGUgb3JpZ2luYWwgbG9nIGxpbmUuIE9ubHkgYXZhaWxhYmxlIGluIExva2kgMi4wKy4nLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdsYWJlbF9mb3JtYXQnLFxuICAgIGluc2VydFRleHQ6ICdsYWJlbF9mb3JtYXQnLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnVXNlIHRvIHJlbmFtZSwgbW9kaWZ5IG9yIGFkZCBsYWJlbHMuIEZvciBleGFtcGxlLCB8IGxhYmVsX2Zvcm1hdCBmb289YmFyIC4gT25seSBhdmFpbGFibGUgaW4gTG9raSAyLjArLicsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ2xpbmVfZm9ybWF0JyxcbiAgICBpbnNlcnRUZXh0OiAnbGluZV9mb3JtYXQnLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnUmV3cml0ZXMgbG9nIGxpbmUgY29udGVudC4gRm9yIGV4YW1wbGUsIHwgbGluZV9mb3JtYXQgXCJ7ey5xdWVyeX19IHt7LmR1cmF0aW9ufX1cIiAuIE9ubHkgYXZhaWxhYmxlIGluIExva2kgMi4wKy4nLFxuICB9LFxuXTtcblxuZXhwb3J0IGNvbnN0IFJBTkdFX1ZFQ19GVU5DVElPTlMgPSBbXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnYXZnX292ZXJfdGltZScsXG4gICAgbGFiZWw6ICdhdmdfb3Zlcl90aW1lJyxcbiAgICBkZXRhaWw6ICdhdmdfb3Zlcl90aW1lKHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdUaGUgYXZlcmFnZSBvZiBhbGwgdmFsdWVzIGluIHRoZSBzcGVjaWZpZWQgaW50ZXJ2YWwuIE9ubHkgYXZhaWxhYmxlIGluIExva2kgMi4wKy4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ21pbl9vdmVyX3RpbWUnLFxuICAgIGxhYmVsOiAnbWluX292ZXJfdGltZScsXG4gICAgZGV0YWlsOiAnbWluX292ZXJfdGltZShyYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnVGhlIG1pbmltdW0gb2YgYWxsIHZhbHVlcyBpbiB0aGUgc3BlY2lmaWVkIGludGVydmFsLiBPbmx5IGF2YWlsYWJsZSBpbiBMb2tpIDIuMCsuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdtYXhfb3Zlcl90aW1lJyxcbiAgICBsYWJlbDogJ21heF9vdmVyX3RpbWUnLFxuICAgIGRldGFpbDogJ21heF9vdmVyX3RpbWUocmFuZ2UtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1RoZSBtYXhpbXVtIG9mIGFsbCB2YWx1ZXMgaW4gdGhlIHNwZWNpZmllZCBpbnRlcnZhbC4gT25seSBhdmFpbGFibGUgaW4gTG9raSAyLjArLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnc3VtX292ZXJfdGltZScsXG4gICAgbGFiZWw6ICdzdW1fb3Zlcl90aW1lJyxcbiAgICBkZXRhaWw6ICdzdW1fb3Zlcl90aW1lKHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdUaGUgc3VtIG9mIGFsbCB2YWx1ZXMgaW4gdGhlIHNwZWNpZmllZCBpbnRlcnZhbC4gT25seSBhdmFpbGFibGUgaW4gTG9raSAyLjArLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnY291bnRfb3Zlcl90aW1lJyxcbiAgICBsYWJlbDogJ2NvdW50X292ZXJfdGltZScsXG4gICAgZGV0YWlsOiAnY291bnRfb3Zlcl90aW1lKHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdUaGUgY291bnQgb2YgYWxsIHZhbHVlcyBpbiB0aGUgc3BlY2lmaWVkIGludGVydmFsLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnc3RkdmFyX292ZXJfdGltZScsXG4gICAgbGFiZWw6ICdzdGR2YXJfb3Zlcl90aW1lJyxcbiAgICBkZXRhaWw6ICdzdGR2YXJfb3Zlcl90aW1lKHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnVGhlIHBvcHVsYXRpb24gc3RhbmRhcmQgdmFyaWFuY2Ugb2YgdGhlIHZhbHVlcyBpbiB0aGUgc3BlY2lmaWVkIGludGVydmFsLiBPbmx5IGF2YWlsYWJsZSBpbiBMb2tpIDIuMCsuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdzdGRkZXZfb3Zlcl90aW1lJyxcbiAgICBsYWJlbDogJ3N0ZGRldl9vdmVyX3RpbWUnLFxuICAgIGRldGFpbDogJ3N0ZGRldl9vdmVyX3RpbWUocmFuZ2UtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdUaGUgcG9wdWxhdGlvbiBzdGFuZGFyZCBkZXZpYXRpb24gb2YgdGhlIHZhbHVlcyBpbiB0aGUgc3BlY2lmaWVkIGludGVydmFsLiBPbmx5IGF2YWlsYWJsZSBpbiBMb2tpIDIuMCsuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdxdWFudGlsZV9vdmVyX3RpbWUnLFxuICAgIGxhYmVsOiAncXVhbnRpbGVfb3Zlcl90aW1lJyxcbiAgICBkZXRhaWw6ICdxdWFudGlsZV9vdmVyX3RpbWUoc2NhbGFyLCByYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnVGhlIM+GLXF1YW50aWxlICgwIOKJpCDPhiDiiaQgMSkgb2YgdGhlIHZhbHVlcyBpbiB0aGUgc3BlY2lmaWVkIGludGVydmFsLiBPbmx5IGF2YWlsYWJsZSBpbiBMb2tpIDIuMCsuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdieXRlc19vdmVyX3RpbWUnLFxuICAgIGxhYmVsOiAnYnl0ZXNfb3Zlcl90aW1lJyxcbiAgICBkZXRhaWw6ICdieXRlc19vdmVyX3RpbWUocmFuZ2UtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ0NvdW50cyB0aGUgYW1vdW50IG9mIGJ5dGVzIHVzZWQgYnkgZWFjaCBsb2cgc3RyZWFtIGZvciBhIGdpdmVuIHJhbmdlJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdieXRlc19yYXRlJyxcbiAgICBsYWJlbDogJ2J5dGVzX3JhdGUnLFxuICAgIGRldGFpbDogJ2J5dGVzX3JhdGUocmFuZ2UtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ0NhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBieXRlcyBwZXIgc2Vjb25kIGZvciBlYWNoIHN0cmVhbS4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3JhdGUnLFxuICAgIGxhYmVsOiAncmF0ZScsXG4gICAgZGV0YWlsOiAncmF0ZSh2IHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgZW50cmllcyBwZXIgc2Vjb25kLicsXG4gIH0sXG5dO1xuXG5leHBvcnQgY29uc3QgRlVOQ1RJT05TID0gWy4uLkFHR1JFR0FUSU9OX09QRVJBVE9SUywgLi4uUkFOR0VfVkVDX0ZVTkNUSU9OU107XG5leHBvcnQgY29uc3QgTE9LSV9LRVlXT1JEUyA9IFsuLi5GVU5DVElPTlMsIC4uLlBJUEVfT1BFUkFUT1JTLCAuLi5QSVBFX1BBUlNFUlNdLm1hcCgoa2V5d29yZCkgPT4ga2V5d29yZC5sYWJlbCk7XG5cbmV4cG9ydCBjb25zdCBsb2tpR3JhbW1hcjogR3JhbW1hciA9IHtcbiAgY29tbWVudDoge1xuICAgIHBhdHRlcm46IC8jLiovLFxuICB9LFxuICAnY29udGV4dC1hZ2dyZWdhdGlvbic6IHtcbiAgICBwYXR0ZXJuOiAvKCh3aXRob3V0fGJ5KVxccyopXFwoW14pXSpcXCkvLCAvLyBieSAoKVxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgaW5zaWRlOiB7XG4gICAgICAnbGFiZWwta2V5Jzoge1xuICAgICAgICBwYXR0ZXJuOiAvW14oKSxcXHNdW14sKV0qW14pLFxcc10qLyxcbiAgICAgICAgYWxpYXM6ICdhdHRyLW5hbWUnLFxuICAgICAgfSxcbiAgICAgIHB1bmN0dWF0aW9uOiAvWygpXS8sXG4gICAgfSxcbiAgfSxcbiAgJ2NvbnRleHQtbGFiZWxzJzoge1xuICAgIHBhdHRlcm46IC9cXHtbXn1dKig/PX0/KS8sXG4gICAgZ3JlZWR5OiB0cnVlLFxuICAgIGluc2lkZToge1xuICAgICAgY29tbWVudDoge1xuICAgICAgICBwYXR0ZXJuOiAvIy4qLyxcbiAgICAgIH0sXG4gICAgICAnbGFiZWwta2V5Jzoge1xuICAgICAgICBwYXR0ZXJuOiAvW2EtekEtWl9dXFx3Kig/PVxccyooPXwhPXw9fnwhfikpLyxcbiAgICAgICAgYWxpYXM6ICdhdHRyLW5hbWUnLFxuICAgICAgICBncmVlZHk6IHRydWUsXG4gICAgICB9LFxuICAgICAgJ2xhYmVsLXZhbHVlJzoge1xuICAgICAgICBwYXR0ZXJuOiAvXCIoPzpcXFxcLnxbXlxcXFxcIl0pKlwiLyxcbiAgICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgICBhbGlhczogJ2F0dHItdmFsdWUnLFxuICAgICAgfSxcbiAgICAgIHB1bmN0dWF0aW9uOiAvW3tdLyxcbiAgICB9LFxuICB9LFxuICAnY29udGV4dC1waXBlJzoge1xuICAgIHBhdHRlcm46IC9cXHNcXHxbXj1+XVxccz9cXHcqL2ksXG4gICAgaW5zaWRlOiB7XG4gICAgICAncGlwZS1vcGVyYXRvcic6IHtcbiAgICAgICAgcGF0dGVybjogL1xcfC9pLFxuICAgICAgICBhbGlhczogJ29wZXJhdG9yJyxcbiAgICAgIH0sXG4gICAgICAncGlwZS1vcGVyYXRpb25zJzoge1xuICAgICAgICBwYXR0ZXJuOiBuZXcgUmVnRXhwKGAke1suLi5QSVBFX1BBUlNFUlMsIC4uLlBJUEVfT1BFUkFUT1JTXS5tYXAoKGYpID0+IGYubGFiZWwpLmpvaW4oJ3wnKX1gLCAnaScpLFxuICAgICAgICBhbGlhczogJ2tleXdvcmQnLFxuICAgICAgfSxcbiAgICB9LFxuICB9LFxuICBmdW5jdGlvbjogbmV3IFJlZ0V4cChgXFxcXGIoPzoke0ZVTkNUSU9OUy5tYXAoKGYpID0+IGYubGFiZWwpLmpvaW4oJ3wnKX0pKD89XFxcXHMqXFxcXCgpYCwgJ2knKSxcbiAgJ2NvbnRleHQtcmFuZ2UnOiBbXG4gICAge1xuICAgICAgcGF0dGVybjogL1xcW1teXFxdXSooPz1cXF0pLywgLy8gWzFtXVxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdyYW5nZS1kdXJhdGlvbic6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvXFxiXFxkK1tzbWhkd3ldXFxiL2ksXG4gICAgICAgICAgYWxpYXM6ICdudW1iZXInLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9LFxuICAgIHtcbiAgICAgIHBhdHRlcm46IC8ob2Zmc2V0XFxzKylcXHcrLywgLy8gb2Zmc2V0IDFtXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdyYW5nZS1kdXJhdGlvbic6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvXFxiXFxkK1tzbWhkd3ldXFxiL2ksXG4gICAgICAgICAgYWxpYXM6ICdudW1iZXInLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9LFxuICBdLFxuICBxdW90ZToge1xuICAgIHBhdHRlcm46IC9cIig/OlxcXFwufFteXFxcXFwiXSkqXCIvLFxuICAgIGFsaWFzOiAnc3RyaW5nJyxcbiAgICBncmVlZHk6IHRydWUsXG4gIH0sXG4gIGJhY2t0aWNrczoge1xuICAgIHBhdHRlcm46IC9gKD86XFxcXC58W15cXFxcYF0pKmAvLFxuICAgIGFsaWFzOiAnc3RyaW5nJyxcbiAgICBncmVlZHk6IHRydWUsXG4gIH0sXG4gIG51bWJlcjogL1xcYi0/XFxkKygoXFwuXFxkKik/KFtlRV1bKy1dP1xcZCspPyk/XFxiLyxcbiAgb3BlcmF0b3I6IC9cXHM/KFxcfFs9fl0/fCE9P3w8KD86PT4/fDx8Pik/fD5bPj1dPylcXHM/L2ksXG4gIHB1bmN0dWF0aW9uOiAvW3t9KCksLl0vLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgbG9raUdyYW1tYXI7XG4iLCJpbXBvcnQgeyBEYXRhUXVlcnksIERhdGFTb3VyY2VKc29uRGF0YSwgUXVlcnlSZXN1bHRNZXRhLCBTY29wZWRWYXJzIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5cbmltcG9ydCB7IFF1ZXJ5RWRpdG9yTW9kZSB9IGZyb20gJy4uL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9raUluc3RhbnRRdWVyeVJlcXVlc3Qge1xuICBxdWVyeTogc3RyaW5nO1xuICBsaW1pdD86IG51bWJlcjtcbiAgdGltZT86IHN0cmluZztcbiAgZGlyZWN0aW9uPzogJ0JBQ0tXQVJEJyB8ICdGT1JXQVJEJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2tpUmFuZ2VRdWVyeVJlcXVlc3Qge1xuICBxdWVyeTogc3RyaW5nO1xuICBsaW1pdD86IG51bWJlcjtcbiAgc3RhcnQ/OiBudW1iZXI7XG4gIGVuZD86IG51bWJlcjtcbiAgc3RlcD86IG51bWJlcjtcbiAgZGlyZWN0aW9uPzogJ0JBQ0tXQVJEJyB8ICdGT1JXQVJEJztcbn1cblxuZXhwb3J0IGVudW0gTG9raVJlc3VsdFR5cGUge1xuICBTdHJlYW0gPSAnc3RyZWFtcycsXG4gIFZlY3RvciA9ICd2ZWN0b3InLFxuICBNYXRyaXggPSAnbWF0cml4Jyxcbn1cblxuZXhwb3J0IGVudW0gTG9raVF1ZXJ5VHlwZSB7XG4gIFJhbmdlID0gJ3JhbmdlJyxcbiAgSW5zdGFudCA9ICdpbnN0YW50JyxcbiAgU3RyZWFtID0gJ3N0cmVhbScsXG59XG5cbmV4cG9ydCBlbnVtIExva2lRdWVyeURpcmVjdGlvbiB7XG4gIEJhY2t3YXJkID0gJ2JhY2t3YXJkJyxcbiAgRm9yd2FyZCA9ICdmb3J3YXJkJyxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2tpUXVlcnkgZXh0ZW5kcyBEYXRhUXVlcnkge1xuICBxdWVyeVR5cGU/OiBMb2tpUXVlcnlUeXBlO1xuICBleHByOiBzdHJpbmc7XG4gIGRpcmVjdGlvbj86IExva2lRdWVyeURpcmVjdGlvbjtcbiAgbGVnZW5kRm9ybWF0Pzogc3RyaW5nO1xuICBtYXhMaW5lcz86IG51bWJlcjtcbiAgcmVzb2x1dGlvbj86IG51bWJlcjtcbiAgLyoqIFVzZWQgaW4gcmFuZ2UgcXVlcmllcyAqL1xuICB2b2x1bWVRdWVyeT86IGJvb2xlYW47XG4gIC8qIEBkZXByZWNhdGVkIG5vdyB1c2UgcXVlcnlUeXBlICovXG4gIHJhbmdlPzogYm9vbGVhbjtcbiAgLyogQGRlcHJlY2F0ZWQgbm93IHVzZSBxdWVyeVR5cGUgKi9cbiAgaW5zdGFudD86IGJvb2xlYW47XG4gIGVkaXRvck1vZGU/OiBRdWVyeUVkaXRvck1vZGU7XG4gIC8qKiBDb250cm9scyBpZiB0aGUgcmF3IHF1ZXJ5IHRleHQgaXMgc2hvd24gKi9cbiAgcmF3UXVlcnk/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExva2lPcHRpb25zIGV4dGVuZHMgRGF0YVNvdXJjZUpzb25EYXRhIHtcbiAgbWF4TGluZXM/OiBzdHJpbmc7XG4gIGRlcml2ZWRGaWVsZHM/OiBEZXJpdmVkRmllbGRDb25maWdbXTtcbiAgYWxlcnRtYW5hZ2VyPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExva2lTdGF0cyB7XG4gIFtjb21wb25lbnQ6IHN0cmluZ106IHtcbiAgICBbbGFiZWw6IHN0cmluZ106IG51bWJlcjtcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2tpVmVjdG9yUmVzdWx0IHtcbiAgbWV0cmljOiB7IFtsYWJlbDogc3RyaW5nXTogc3RyaW5nIH07XG4gIHZhbHVlOiBbbnVtYmVyLCBzdHJpbmddO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExva2lWZWN0b3JSZXNwb25zZSB7XG4gIHN0YXR1czogc3RyaW5nO1xuICBkYXRhOiB7XG4gICAgcmVzdWx0VHlwZTogTG9raVJlc3VsdFR5cGUuVmVjdG9yO1xuICAgIHJlc3VsdDogTG9raVZlY3RvclJlc3VsdFtdO1xuICAgIHN0YXRzPzogTG9raVN0YXRzO1xuICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExva2lNYXRyaXhSZXN1bHQge1xuICBtZXRyaWM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gIHZhbHVlczogQXJyYXk8W251bWJlciwgc3RyaW5nXT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9raU1hdHJpeFJlc3BvbnNlIHtcbiAgc3RhdHVzOiBzdHJpbmc7XG4gIGRhdGE6IHtcbiAgICByZXN1bHRUeXBlOiBMb2tpUmVzdWx0VHlwZS5NYXRyaXg7XG4gICAgcmVzdWx0OiBMb2tpTWF0cml4UmVzdWx0W107XG4gICAgc3RhdHM/OiBMb2tpU3RhdHM7XG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9raVN0cmVhbVJlc3VsdCB7XG4gIHN0cmVhbTogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgdmFsdWVzOiBBcnJheTxbc3RyaW5nLCBzdHJpbmddPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2tpU3RyZWFtUmVzcG9uc2Uge1xuICBzdGF0dXM6IHN0cmluZztcbiAgZGF0YToge1xuICAgIHJlc3VsdFR5cGU6IExva2lSZXN1bHRUeXBlLlN0cmVhbTtcbiAgICByZXN1bHQ6IExva2lTdHJlYW1SZXN1bHRbXTtcbiAgICBzdGF0cz86IExva2lTdGF0cztcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2tpVGFpbFJlc3BvbnNlIHtcbiAgc3RyZWFtczogTG9raVN0cmVhbVJlc3VsdFtdO1xuICBkcm9wcGVkX2VudHJpZXM/OiBBcnJheTx7XG4gICAgbGFiZWxzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICAgIHRpbWVzdGFtcDogc3RyaW5nO1xuICB9PiB8IG51bGw7XG59XG5cbmV4cG9ydCB0eXBlIExva2lSZXN1bHQgPSBMb2tpVmVjdG9yUmVzdWx0IHwgTG9raU1hdHJpeFJlc3VsdCB8IExva2lTdHJlYW1SZXN1bHQ7XG5leHBvcnQgdHlwZSBMb2tpUmVzcG9uc2UgPSBMb2tpVmVjdG9yUmVzcG9uc2UgfCBMb2tpTWF0cml4UmVzcG9uc2UgfCBMb2tpU3RyZWFtUmVzcG9uc2U7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9raUxvZ3NTdHJlYW1FbnRyeSB7XG4gIGxpbmU6IHN0cmluZztcbiAgdHM6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2tpRXhwcmVzc2lvbiB7XG4gIHJlZ2V4cDogc3RyaW5nO1xuICBxdWVyeTogc3RyaW5nO1xufVxuXG5leHBvcnQgdHlwZSBEZXJpdmVkRmllbGRDb25maWcgPSB7XG4gIG1hdGNoZXJSZWdleDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIHVybD86IHN0cmluZztcbiAgdXJsRGlzcGxheUxhYmVsPzogc3RyaW5nO1xuICBkYXRhc291cmNlVWlkPzogc3RyaW5nO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2Zvcm1lck9wdGlvbnMge1xuICBsZWdlbmRGb3JtYXQ/OiBzdHJpbmc7XG4gIHF1ZXJ5OiBzdHJpbmc7XG4gIHJlZklkOiBzdHJpbmc7XG4gIHNjb3BlZFZhcnM6IFNjb3BlZFZhcnM7XG4gIG1ldGE/OiBRdWVyeVJlc3VsdE1ldGE7XG59XG4iLCJpbXBvcnQgeyBwYXJzZXIgfSBmcm9tICdsZXplci1wcm9tcWwnO1xuXG5pbXBvcnQgeyBQcm9tUXVlcnlNb2RlbGxlciB9IGZyb20gJy4vcXVlcnlidWlsZGVyL1Byb21RdWVyeU1vZGVsbGVyJztcbmltcG9ydCB7IGJ1aWxkVmlzdWFsUXVlcnlGcm9tU3RyaW5nIH0gZnJvbSAnLi9xdWVyeWJ1aWxkZXIvcGFyc2luZyc7XG5pbXBvcnQgeyBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlciB9IGZyb20gJy4vcXVlcnlidWlsZGVyL3NoYXJlZC90eXBlcyc7XG5pbXBvcnQgeyBQcm9tVmlzdWFsUXVlcnkgfSBmcm9tICcuL3F1ZXJ5YnVpbGRlci90eXBlcyc7XG5cbi8qKlxuICogQWRkcyBsYWJlbCBmaWx0ZXIgdG8gZXhpc3RpbmcgcXVlcnkuIFVzZWZ1bCBmb3IgcXVlcnkgbW9kaWZpY2F0aW9uIGZvciBleGFtcGxlIGZvciBhZCBob2MgZmlsdGVycy5cbiAqXG4gKiBJdCB1c2VzIFByb21RTCBwYXJzZXIgdG8gZmluZCBpbnN0YW5jZXMgb2YgbWV0cmljIGFuZCBsYWJlbHMsIGFsdGVycyB0aGVtIGFuZCB0aGVuIHNwbGljZXMgdGhlbSBiYWNrIGludG8gdGhlIHF1ZXJ5LlxuICogSWRlYWxseSB3ZSBjb3VsZCB1c2UgdGhlIHBhcnNlIC0+IGNoYW5nZSAtPiByZW5kZXIgaXMgYSBzaW1wbGUgMyBzdGVwcyBidXQgcmlnaHQgbm93IGJ1aWxkaW5nIHRoZSB2aXN1YWwgcXVlcnlcbiAqIG9iamVjdCBkb2VzIG5vdCBzdXBwb3J0IGFsbCBwb3NzaWJsZSBxdWVyaWVzLlxuICpcbiAqIFNvIGluc3RlYWQgdGhpcyBqdXN0IG9wZXJhdGVzIG9uIHN1YnN0cmluZ3Mgb2YgdGhlIHF1ZXJ5IHdpdGggbGFiZWxzIGFuZCBvcGVyYXRlcyBqdXN0IG9uIHRob3NlLiBUaGlzIG1ha2VzIHRoaXNcbiAqIG1vcmUgcm9idXN0IGFuZCBjYW4gYWx0ZXIgZXZlbiBpbnZhbGlkIHF1ZXJpZXMsIGFuZCBwcmVzZXJ2ZXMgaW4gZ2VuZXJhbCB0aGUgcXVlcnkgc3RydWN0dXJlIGFuZCB3aGl0ZXNwYWNlLlxuICogQHBhcmFtIHF1ZXJ5XG4gKiBAcGFyYW0ga2V5XG4gKiBAcGFyYW0gdmFsdWVcbiAqIEBwYXJhbSBvcGVyYXRvclxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkTGFiZWxUb1F1ZXJ5KHF1ZXJ5OiBzdHJpbmcsIGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nIHwgbnVtYmVyLCBvcGVyYXRvciA9ICc9Jyk6IHN0cmluZyB7XG4gIGlmICgha2V5IHx8ICF2YWx1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTmVlZCBsYWJlbCB0byBhZGQgdG8gcXVlcnkuJyk7XG4gIH1cblxuICBjb25zdCB2ZWN0b3JTZWxlY3RvclBvc2l0aW9ucyA9IGdldFZlY3RvclNlbGVjdG9yUG9zaXRpb25zKHF1ZXJ5KTtcbiAgaWYgKCF2ZWN0b3JTZWxlY3RvclBvc2l0aW9ucy5sZW5ndGgpIHtcbiAgICByZXR1cm4gcXVlcnk7XG4gIH1cblxuICBjb25zdCBmaWx0ZXIgPSB0b0xhYmVsRmlsdGVyKGtleSwgdmFsdWUsIG9wZXJhdG9yKTtcbiAgcmV0dXJuIGFkZEZpbHRlcihxdWVyeSwgdmVjdG9yU2VsZWN0b3JQb3NpdGlvbnMsIGZpbHRlcik7XG59XG5cbnR5cGUgVmVjdG9yU2VsZWN0b3JQb3NpdGlvbiA9IHsgZnJvbTogbnVtYmVyOyB0bzogbnVtYmVyOyBxdWVyeTogUHJvbVZpc3VhbFF1ZXJ5IH07XG5cbi8qKlxuICogUGFyc2UgdGhlIHN0cmluZyBhbmQgZ2V0IGFsbCBWZWN0b3JTZWxlY3RvciBwb3NpdGlvbnMgaW4gdGhlIHF1ZXJ5IHRvZ2V0aGVyIHdpdGggcGFyc2VkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcbiAqIHNlbGVjdG9yLlxuICogQHBhcmFtIHF1ZXJ5XG4gKi9cbmZ1bmN0aW9uIGdldFZlY3RvclNlbGVjdG9yUG9zaXRpb25zKHF1ZXJ5OiBzdHJpbmcpOiBWZWN0b3JTZWxlY3RvclBvc2l0aW9uW10ge1xuICBjb25zdCB0cmVlID0gcGFyc2VyLnBhcnNlKHF1ZXJ5KTtcbiAgY29uc3QgcG9zaXRpb25zOiBWZWN0b3JTZWxlY3RvclBvc2l0aW9uW10gPSBbXTtcbiAgdHJlZS5pdGVyYXRlKHtcbiAgICBlbnRlcjogKHR5cGUsIGZyb20sIHRvLCBnZXQpOiBmYWxzZSB8IHZvaWQgPT4ge1xuICAgICAgaWYgKHR5cGUubmFtZSA9PT0gJ1ZlY3RvclNlbGVjdG9yJykge1xuICAgICAgICBjb25zdCB2aXNRdWVyeSA9IGJ1aWxkVmlzdWFsUXVlcnlGcm9tU3RyaW5nKHF1ZXJ5LnN1YnN0cmluZyhmcm9tLCB0bykpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaCh7IHF1ZXJ5OiB2aXNRdWVyeS5xdWVyeSwgZnJvbSwgdG8gfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuICB9KTtcbiAgcmV0dXJuIHBvc2l0aW9ucztcbn1cblxuZnVuY3Rpb24gdG9MYWJlbEZpbHRlcihrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZyB8IG51bWJlciwgb3BlcmF0b3I6IHN0cmluZyk6IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyIHtcbiAgLy8gV2UgbmVlZCB0byBtYWtlIHN1cmUgdGhhdCB3ZSBjb252ZXJ0IHRoZSB2YWx1ZSBiYWNrIHRvIHN0cmluZyBiZWNhdXNlIGl0IG1heSBiZSBhIG51bWJlclxuICBjb25zdCB0cmFuc2Zvcm1lZFZhbHVlID0gdmFsdWUgPT09IEluZmluaXR5ID8gJytJbmYnIDogdmFsdWUudG9TdHJpbmcoKTtcbiAgcmV0dXJuIHsgbGFiZWw6IGtleSwgb3A6IG9wZXJhdG9yLCB2YWx1ZTogdHJhbnNmb3JtZWRWYWx1ZSB9O1xufVxuXG5mdW5jdGlvbiBhZGRGaWx0ZXIoXG4gIHF1ZXJ5OiBzdHJpbmcsXG4gIHZlY3RvclNlbGVjdG9yUG9zaXRpb25zOiBWZWN0b3JTZWxlY3RvclBvc2l0aW9uW10sXG4gIGZpbHRlcjogUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXJcbik6IHN0cmluZyB7XG4gIGNvbnN0IG1vZGVsbGVyID0gbmV3IFByb21RdWVyeU1vZGVsbGVyKCk7XG4gIGxldCBuZXdRdWVyeSA9ICcnO1xuICBsZXQgcHJldiA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZWN0b3JTZWxlY3RvclBvc2l0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIC8vIFRoaXMgaXMgYmFzaWNhbGx5IGp1c3QgZG9pbmcgc3BsaWNlIG9uIGEgc3RyaW5nIGZvciBlYWNoIG1hdGNoZWQgdmVjdG9yIHNlbGVjdG9yLlxuXG4gICAgY29uc3QgbWF0Y2ggPSB2ZWN0b3JTZWxlY3RvclBvc2l0aW9uc1tpXTtcbiAgICBjb25zdCBpc0xhc3QgPSBpID09PSB2ZWN0b3JTZWxlY3RvclBvc2l0aW9ucy5sZW5ndGggLSAxO1xuXG4gICAgY29uc3Qgc3RhcnQgPSBxdWVyeS5zdWJzdHJpbmcocHJldiwgbWF0Y2guZnJvbSk7XG4gICAgY29uc3QgZW5kID0gaXNMYXN0ID8gcXVlcnkuc3Vic3RyaW5nKG1hdGNoLnRvKSA6ICcnO1xuXG4gICAgaWYgKCFsYWJlbEV4aXN0cyhtYXRjaC5xdWVyeS5sYWJlbHMsIGZpbHRlcikpIHtcbiAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gYWRkIGR1cGxpY2F0ZSBsYWJlbHMuXG4gICAgICBtYXRjaC5xdWVyeS5sYWJlbHMucHVzaChmaWx0ZXIpO1xuICAgIH1cbiAgICBjb25zdCBuZXdMYWJlbHMgPSBtb2RlbGxlci5yZW5kZXJRdWVyeShtYXRjaC5xdWVyeSk7XG4gICAgbmV3UXVlcnkgKz0gc3RhcnQgKyBuZXdMYWJlbHMgKyBlbmQ7XG4gICAgcHJldiA9IG1hdGNoLnRvO1xuICB9XG4gIHJldHVybiBuZXdRdWVyeTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBsYWJlbCBleGlzdHMgaW4gdGhlIGxpc3Qgb2YgbGFiZWxzIGJ1dCBpZ25vcmUgdGhlIG9wZXJhdG9yLlxuICogQHBhcmFtIGxhYmVsc1xuICogQHBhcmFtIGZpbHRlclxuICovXG5mdW5jdGlvbiBsYWJlbEV4aXN0cyhsYWJlbHM6IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyW10sIGZpbHRlcjogUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXIpIHtcbiAgcmV0dXJuIGxhYmVscy5maW5kKChsYWJlbCkgPT4gbGFiZWwubGFiZWwgPT09IGZpbHRlci5sYWJlbCAmJiBsYWJlbC52YWx1ZSA9PT0gZmlsdGVyLnZhbHVlKTtcbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCwgZGVmYXVsdHMgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IExSVSBmcm9tICdscnUtY2FjaGUnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGZvcmtKb2luLCBsYXN0VmFsdWVGcm9tLCBtZXJnZSwgT2JzZXJ2YWJsZSwgb2YsIE9wZXJhdG9yRnVuY3Rpb24sIHBpcGUsIHRocm93RXJyb3IgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGNhdGNoRXJyb3IsIGZpbHRlciwgbWFwLCB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7XG4gIEFubm90YXRpb25FdmVudCxcbiAgQ29yZUFwcCxcbiAgRGF0YVF1ZXJ5RXJyb3IsXG4gIERhdGFRdWVyeVJlcXVlc3QsXG4gIERhdGFRdWVyeVJlc3BvbnNlLFxuICBEYXRhU291cmNlSW5zdGFuY2VTZXR0aW5ncyxcbiAgRGF0YVNvdXJjZVdpdGhRdWVyeUV4cG9ydFN1cHBvcnQsXG4gIERhdGFTb3VyY2VXaXRoUXVlcnlJbXBvcnRTdXBwb3J0LFxuICBkYXRlTWF0aCxcbiAgRGF0ZVRpbWUsXG4gIEFic3RyYWN0UXVlcnksXG4gIExvYWRpbmdTdGF0ZSxcbiAgcmFuZ2VVdGlsLFxuICBTY29wZWRWYXJzLFxuICBUaW1lUmFuZ2UsXG4gIERhdGFGcmFtZSxcbiAgZGF0ZVRpbWUsXG59IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHtcbiAgQmFja2VuZFNydlJlcXVlc3QsXG4gIEZldGNoRXJyb3IsXG4gIEZldGNoUmVzcG9uc2UsXG4gIGdldEJhY2tlbmRTcnYsXG4gIERhdGFTb3VyY2VXaXRoQmFja2VuZCxcbiAgQmFja2VuZERhdGFTb3VyY2VSZXNwb25zZSxcbiAgdG9EYXRhUXVlcnlSZXNwb25zZSxcbn0gZnJvbSAnQGdyYWZhbmEvcnVudGltZSc7XG5pbXBvcnQgeyBCYWRnZSwgQmFkZ2VDb2xvciwgVG9vbHRpcCB9IGZyb20gJ0BncmFmYW5hL3VpJztcbmltcG9ydCB7IHNhZmVTdHJpbmdpZnlWYWx1ZSB9IGZyb20gJ2FwcC9jb3JlL3V0aWxzL2V4cGxvcmUnO1xuaW1wb3J0IHsgZmV0Y2hEYXRhU291cmNlQnVpbGRJbmZvIH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2FsZXJ0aW5nL3VuaWZpZWQvYXBpL2J1aWxkSW5mbyc7XG5pbXBvcnQgeyBnZXRUaW1lU3J2LCBUaW1lU3J2IH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2Rhc2hib2FyZC9zZXJ2aWNlcy9UaW1lU3J2JztcbmltcG9ydCB7IGdldFRlbXBsYXRlU3J2LCBUZW1wbGF0ZVNydiB9IGZyb20gJ2FwcC9mZWF0dXJlcy90ZW1wbGF0aW5nL3RlbXBsYXRlX3Nydic7XG5pbXBvcnQgeyBQcm9tQXBwbGljYXRpb24sIFByb21CdWlsZEluZm8gfSBmcm9tICdhcHAvdHlwZXMvdW5pZmllZC1hbGVydGluZy1kdG8nO1xuXG5pbXBvcnQgeyBhZGRMYWJlbFRvUXVlcnkgfSBmcm9tICcuL2FkZF9sYWJlbF90b19xdWVyeSc7XG5pbXBvcnQgUHJvbWV0aGV1c0xhbmd1YWdlUHJvdmlkZXIgZnJvbSAnLi9sYW5ndWFnZV9wcm92aWRlcic7XG5pbXBvcnQgeyBleHBhbmRSZWNvcmRpbmdSdWxlcyB9IGZyb20gJy4vbGFuZ3VhZ2VfdXRpbHMnO1xuaW1wb3J0IHsgcmVuZGVyTGVnZW5kRm9ybWF0IH0gZnJvbSAnLi9sZWdlbmQnO1xuaW1wb3J0IFByb21ldGhldXNNZXRyaWNGaW5kUXVlcnkgZnJvbSAnLi9tZXRyaWNfZmluZF9xdWVyeSc7XG5pbXBvcnQgeyBnZXRJbml0SGludHMsIGdldFF1ZXJ5SGludHMgfSBmcm9tICcuL3F1ZXJ5X2hpbnRzJztcbmltcG9ydCB7IGdldE9yaWdpbmFsTWV0cmljTmFtZSwgdHJhbnNmb3JtLCB0cmFuc2Zvcm1WMiB9IGZyb20gJy4vcmVzdWx0X3RyYW5zZm9ybWVyJztcbmltcG9ydCB7XG4gIEV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uLFxuICBQcm9tRGF0YUVycm9yUmVzcG9uc2UsXG4gIFByb21EYXRhU3VjY2Vzc1Jlc3BvbnNlLFxuICBQcm9tRXhlbXBsYXJEYXRhLFxuICBQcm9tTWF0cml4RGF0YSxcbiAgUHJvbU9wdGlvbnMsXG4gIFByb21RdWVyeSxcbiAgUHJvbVF1ZXJ5UmVxdWVzdCxcbiAgUHJvbVF1ZXJ5VHlwZSxcbiAgUHJvbVNjYWxhckRhdGEsXG4gIFByb21WZWN0b3JEYXRhLFxufSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IFByb21ldGhldXNWYXJpYWJsZVN1cHBvcnQgfSBmcm9tICcuL3ZhcmlhYmxlcyc7XG5cbmV4cG9ydCBjb25zdCBBTk5PVEFUSU9OX1FVRVJZX1NURVBfREVGQVVMVCA9ICc2MHMnO1xuY29uc3QgR0VUX0FORF9QT1NUX01FVEFEQVRBX0VORFBPSU5UUyA9IFsnYXBpL3YxL3F1ZXJ5JywgJ2FwaS92MS9xdWVyeV9yYW5nZScsICdhcGkvdjEvc2VyaWVzJywgJ2FwaS92MS9sYWJlbHMnXTtcblxuZXhwb3J0IGNsYXNzIFByb21ldGhldXNEYXRhc291cmNlXG4gIGV4dGVuZHMgRGF0YVNvdXJjZVdpdGhCYWNrZW5kPFByb21RdWVyeSwgUHJvbU9wdGlvbnM+XG4gIGltcGxlbWVudHMgRGF0YVNvdXJjZVdpdGhRdWVyeUltcG9ydFN1cHBvcnQ8UHJvbVF1ZXJ5PiwgRGF0YVNvdXJjZVdpdGhRdWVyeUV4cG9ydFN1cHBvcnQ8UHJvbVF1ZXJ5Plxue1xuICB0eXBlOiBzdHJpbmc7XG4gIGVkaXRvclNyYzogc3RyaW5nO1xuICBydWxlTWFwcGluZ3M6IHsgW2luZGV4OiBzdHJpbmddOiBzdHJpbmcgfTtcbiAgdXJsOiBzdHJpbmc7XG4gIGlkOiBudW1iZXI7XG4gIGRpcmVjdFVybDogc3RyaW5nO1xuICBhY2Nlc3M6ICdkaXJlY3QnIHwgJ3Byb3h5JztcbiAgYmFzaWNBdXRoOiBhbnk7XG4gIHdpdGhDcmVkZW50aWFsczogYW55O1xuICBtZXRyaWNzTmFtZUNhY2hlID0gbmV3IExSVTxzdHJpbmcsIHN0cmluZ1tdPih7IG1heDogMTAgfSk7XG4gIGludGVydmFsOiBzdHJpbmc7XG4gIHF1ZXJ5VGltZW91dDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICBodHRwTWV0aG9kOiBzdHJpbmc7XG4gIGxhbmd1YWdlUHJvdmlkZXI6IFByb21ldGhldXNMYW5ndWFnZVByb3ZpZGVyO1xuICBleGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbnM6IEV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uW10gfCB1bmRlZmluZWQ7XG4gIGxvb2t1cHNEaXNhYmxlZDogYm9vbGVhbjtcbiAgY3VzdG9tUXVlcnlQYXJhbWV0ZXJzOiBhbnk7XG4gIGV4ZW1wbGFyc0F2YWlsYWJsZTogYm9vbGVhbjtcbiAgc3ViVHlwZTogUHJvbUFwcGxpY2F0aW9uO1xuICBydWxlckVuYWJsZWQ6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IoXG4gICAgaW5zdGFuY2VTZXR0aW5nczogRGF0YVNvdXJjZUluc3RhbmNlU2V0dGluZ3M8UHJvbU9wdGlvbnM+LFxuICAgIHByaXZhdGUgcmVhZG9ubHkgdGVtcGxhdGVTcnY6IFRlbXBsYXRlU3J2ID0gZ2V0VGVtcGxhdGVTcnYoKSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHRpbWVTcnY6IFRpbWVTcnYgPSBnZXRUaW1lU3J2KCksXG4gICAgbGFuZ3VhZ2VQcm92aWRlcj86IFByb21ldGhldXNMYW5ndWFnZVByb3ZpZGVyXG4gICkge1xuICAgIHN1cGVyKGluc3RhbmNlU2V0dGluZ3MpO1xuXG4gICAgdGhpcy50eXBlID0gJ3Byb21ldGhldXMnO1xuICAgIHRoaXMuc3ViVHlwZSA9IFByb21BcHBsaWNhdGlvbi5Qcm9tZXRoZXVzO1xuICAgIHRoaXMucnVsZXJFbmFibGVkID0gZmFsc2U7XG4gICAgdGhpcy5lZGl0b3JTcmMgPSAnYXBwL2ZlYXR1cmVzL3Byb21ldGhldXMvcGFydGlhbHMvcXVlcnkuZWRpdG9yLmh0bWwnO1xuICAgIHRoaXMuaWQgPSBpbnN0YW5jZVNldHRpbmdzLmlkO1xuICAgIHRoaXMudXJsID0gaW5zdGFuY2VTZXR0aW5ncy51cmwhO1xuICAgIHRoaXMuYWNjZXNzID0gaW5zdGFuY2VTZXR0aW5ncy5hY2Nlc3M7XG4gICAgdGhpcy5iYXNpY0F1dGggPSBpbnN0YW5jZVNldHRpbmdzLmJhc2ljQXV0aDtcbiAgICB0aGlzLndpdGhDcmVkZW50aWFscyA9IGluc3RhbmNlU2V0dGluZ3Mud2l0aENyZWRlbnRpYWxzO1xuICAgIHRoaXMuaW50ZXJ2YWwgPSBpbnN0YW5jZVNldHRpbmdzLmpzb25EYXRhLnRpbWVJbnRlcnZhbCB8fCAnMTVzJztcbiAgICB0aGlzLnF1ZXJ5VGltZW91dCA9IGluc3RhbmNlU2V0dGluZ3MuanNvbkRhdGEucXVlcnlUaW1lb3V0O1xuICAgIHRoaXMuaHR0cE1ldGhvZCA9IGluc3RhbmNlU2V0dGluZ3MuanNvbkRhdGEuaHR0cE1ldGhvZCB8fCAnUE9TVCc7XG4gICAgLy8gYGRpcmVjdFVybGAgaXMgbmV2ZXIgdW5kZWZpbmVkLCB3ZSBzZXQgaXQgYXQgaHR0cHM6Ly9naXRodWIuY29tL2dyYWZhbmEvZ3JhZmFuYS9ibG9iL21haW4vcGtnL2FwaS9mcm9udGVuZHNldHRpbmdzLmdvI0wxMDhcbiAgICAvLyBoZXJlIHdlIFwiZmFsbCBiYWNrXCIgdG8gdGhpcy51cmwgdG8gbWFrZSB0eXBlc2NyaXB0IGhhcHB5LCBidXQgaXQgc2hvdWxkIG5ldmVyIGhhcHBlblxuICAgIHRoaXMuZGlyZWN0VXJsID0gaW5zdGFuY2VTZXR0aW5ncy5qc29uRGF0YS5kaXJlY3RVcmwgPz8gdGhpcy51cmw7XG4gICAgdGhpcy5leGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbnMgPSBpbnN0YW5jZVNldHRpbmdzLmpzb25EYXRhLmV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9ucztcbiAgICB0aGlzLnJ1bGVNYXBwaW5ncyA9IHt9O1xuICAgIHRoaXMubGFuZ3VhZ2VQcm92aWRlciA9IGxhbmd1YWdlUHJvdmlkZXIgPz8gbmV3IFByb21ldGhldXNMYW5ndWFnZVByb3ZpZGVyKHRoaXMpO1xuICAgIHRoaXMubG9va3Vwc0Rpc2FibGVkID0gaW5zdGFuY2VTZXR0aW5ncy5qc29uRGF0YS5kaXNhYmxlTWV0cmljc0xvb2t1cCA/PyBmYWxzZTtcbiAgICB0aGlzLmN1c3RvbVF1ZXJ5UGFyYW1ldGVycyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoaW5zdGFuY2VTZXR0aW5ncy5qc29uRGF0YS5jdXN0b21RdWVyeVBhcmFtZXRlcnMpO1xuICAgIHRoaXMudmFyaWFibGVzID0gbmV3IFByb21ldGhldXNWYXJpYWJsZVN1cHBvcnQodGhpcywgdGhpcy50ZW1wbGF0ZVNydiwgdGhpcy50aW1lU3J2KTtcbiAgICB0aGlzLmV4ZW1wbGFyc0F2YWlsYWJsZSA9IHRydWU7XG4gIH1cblxuICBpbml0ID0gYXN5bmMgKCkgPT4ge1xuICAgIHRoaXMubG9hZFJ1bGVzKCk7XG4gICAgdGhpcy5leGVtcGxhcnNBdmFpbGFibGUgPSBhd2FpdCB0aGlzLmFyZUV4ZW1wbGFyc0F2YWlsYWJsZSgpO1xuICB9O1xuXG4gIGdldFF1ZXJ5RGlzcGxheVRleHQocXVlcnk6IFByb21RdWVyeSkge1xuICAgIHJldHVybiBxdWVyeS5leHByO1xuICB9XG5cbiAgX2FkZFRyYWNpbmdIZWFkZXJzKGh0dHBPcHRpb25zOiBQcm9tUXVlcnlSZXF1ZXN0LCBvcHRpb25zOiBEYXRhUXVlcnlSZXF1ZXN0PFByb21RdWVyeT4pIHtcbiAgICBodHRwT3B0aW9ucy5oZWFkZXJzID0ge307XG4gICAgY29uc3QgcHJveHlNb2RlID0gIXRoaXMudXJsLm1hdGNoKC9eaHR0cC8pO1xuICAgIGlmIChwcm94eU1vZGUpIHtcbiAgICAgIGh0dHBPcHRpb25zLmhlYWRlcnNbJ1gtRGFzaGJvYXJkLUlkJ10gPSBvcHRpb25zLmRhc2hib2FyZElkO1xuICAgICAgaHR0cE9wdGlvbnMuaGVhZGVyc1snWC1QYW5lbC1JZCddID0gb3B0aW9ucy5wYW5lbElkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBbnkgcmVxdWVzdCBkb25lIGZyb20gdGhpcyBkYXRhIHNvdXJjZSBzaG91bGQgZ28gdGhyb3VnaCBoZXJlIGFzIGl0IGNvbnRhaW5zIHNvbWUgY29tbW9uIHByb2Nlc3NpbmcgZm9yIHRoZVxuICAgKiByZXF1ZXN0LiBBbnkgcHJvY2Vzc2luZyBkb25lIGhlcmUgbmVlZHMgdG8gYmUgYWxzbyBjb3BpZWQgb24gdGhlIGJhY2tlbmQgYXMgdGhpcyBnb2VzIHRocm91Z2ggZGF0YSBzb3VyY2UgcHJveHlcbiAgICogYnV0IG5vdCB0aHJvdWdoIHRoZSBzYW1lIGNvZGUgYXMgYWxlcnRpbmcuXG4gICAqL1xuICBfcmVxdWVzdDxUID0gYW55PihcbiAgICB1cmw6IHN0cmluZyxcbiAgICBkYXRhOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHwgbnVsbCxcbiAgICBvdmVycmlkZXM6IFBhcnRpYWw8QmFja2VuZFNydlJlcXVlc3Q+ID0ge31cbiAgKTogT2JzZXJ2YWJsZTxGZXRjaFJlc3BvbnNlPFQ+PiB7XG4gICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5jdXN0b21RdWVyeVBhcmFtZXRlcnMpIHtcbiAgICAgIGlmIChkYXRhW2tleV0gPT0gbnVsbCkge1xuICAgICAgICBkYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBvcHRpb25zOiBCYWNrZW5kU3J2UmVxdWVzdCA9IGRlZmF1bHRzKG92ZXJyaWRlcywge1xuICAgICAgdXJsOiB0aGlzLnVybCArIHVybCxcbiAgICAgIG1ldGhvZDogdGhpcy5odHRwTWV0aG9kLFxuICAgICAgaGVhZGVyczoge30sXG4gICAgfSk7XG5cbiAgICBpZiAob3B0aW9ucy5tZXRob2QgPT09ICdHRVQnKSB7XG4gICAgICBpZiAoZGF0YSAmJiBPYmplY3Qua2V5cyhkYXRhKS5sZW5ndGgpIHtcbiAgICAgICAgb3B0aW9ucy51cmwgPVxuICAgICAgICAgIG9wdGlvbnMudXJsICtcbiAgICAgICAgICAob3B0aW9ucy51cmwuc2VhcmNoKC9cXD8vKSA+PSAwID8gJyYnIDogJz8nKSArXG4gICAgICAgICAgT2JqZWN0LmVudHJpZXMoZGF0YSlcbiAgICAgICAgICAgIC5tYXAoKFtrLCB2XSkgPT4gYCR7ZW5jb2RlVVJJQ29tcG9uZW50KGspfT0ke2VuY29kZVVSSUNvbXBvbmVudCh2KX1gKVxuICAgICAgICAgICAgLmpvaW4oJyYnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucy5oZWFkZXJzIVsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJztcbiAgICAgIG9wdGlvbnMuZGF0YSA9IGRhdGE7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYmFzaWNBdXRoIHx8IHRoaXMud2l0aENyZWRlbnRpYWxzKSB7XG4gICAgICBvcHRpb25zLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYmFzaWNBdXRoKSB7XG4gICAgICBvcHRpb25zLmhlYWRlcnMhLkF1dGhvcml6YXRpb24gPSB0aGlzLmJhc2ljQXV0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0QmFja2VuZFNydigpLmZldGNoPFQ+KG9wdGlvbnMpO1xuICB9XG5cbiAgYXN5bmMgaW1wb3J0RnJvbUFic3RyYWN0UXVlcmllcyhhYnN0cmFjdFF1ZXJpZXM6IEFic3RyYWN0UXVlcnlbXSk6IFByb21pc2U8UHJvbVF1ZXJ5W10+IHtcbiAgICByZXR1cm4gYWJzdHJhY3RRdWVyaWVzLm1hcCgoYWJzdHJhY3RRdWVyeSkgPT4gdGhpcy5sYW5ndWFnZVByb3ZpZGVyLmltcG9ydEZyb21BYnN0cmFjdFF1ZXJ5KGFic3RyYWN0UXVlcnkpKTtcbiAgfVxuXG4gIGFzeW5jIGV4cG9ydFRvQWJzdHJhY3RRdWVyaWVzKHF1ZXJpZXM6IFByb21RdWVyeVtdKTogUHJvbWlzZTxBYnN0cmFjdFF1ZXJ5W10+IHtcbiAgICByZXR1cm4gcXVlcmllcy5tYXAoKHF1ZXJ5KSA9PiB0aGlzLmxhbmd1YWdlUHJvdmlkZXIuZXhwb3J0VG9BYnN0cmFjdFF1ZXJ5KHF1ZXJ5KSk7XG4gIH1cblxuICAvLyBVc2UgdGhpcyBmb3IgdGFiIGNvbXBsZXRpb24gZmVhdHVyZXMsIHdvbnQgcHVibGlzaCByZXNwb25zZSB0byBvdGhlciBjb21wb25lbnRzXG4gIGFzeW5jIG1ldGFkYXRhUmVxdWVzdDxUID0gYW55Pih1cmw6IHN0cmluZywgcGFyYW1zID0ge30pIHtcbiAgICAvLyBJZiBVUkwgaW5jbHVkZXMgZW5kcG9pbnQgdGhhdCBzdXBwb3J0cyBQT1NUIGFuZCBHRVQgbWV0aG9kLCB0cnkgdG8gdXNlIGNvbmZpZ3VyZWQgbWV0aG9kLiBUaGlzIG1pZ2h0IGZhaWwgYXMgUE9TVCBpcyBzdXBwb3J0ZWQgb25seSBpbiB2Mi4xMCsuXG4gICAgaWYgKEdFVF9BTkRfUE9TVF9NRVRBREFUQV9FTkRQT0lOVFMuc29tZSgoZW5kcG9pbnQpID0+IHVybC5pbmNsdWRlcyhlbmRwb2ludCkpKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgbGFzdFZhbHVlRnJvbSh0aGlzLl9yZXF1ZXN0PFQ+KHVybCwgcGFyYW1zLCB7IG1ldGhvZDogdGhpcy5odHRwTWV0aG9kLCBoaWRlRnJvbUluc3BlY3RvcjogdHJ1ZSB9KSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gSWYgc3RhdHVzIGNvZGUgb2YgZXJyb3IgaXMgTWV0aG9kIE5vdCBBbGxvd2VkICg0MDUpIGFuZCBIVFRQIG1ldGhvZCBpcyBQT1NULCByZXRyeSB3aXRoIEdFVFxuICAgICAgICBpZiAodGhpcy5odHRwTWV0aG9kID09PSAnUE9TVCcgJiYgZXJyLnN0YXR1cyA9PT0gNDA1KSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBDb3VsZG4ndCB1c2UgY29uZmlndXJlZCBQT1NUIEhUVFAgbWV0aG9kIGZvciB0aGlzIHJlcXVlc3QuIFRyeWluZyB0byB1c2UgR0VUIG1ldGhvZCBpbnN0ZWFkLmApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCBsYXN0VmFsdWVGcm9tKHRoaXMuX3JlcXVlc3Q8VD4odXJsLCBwYXJhbXMsIHsgbWV0aG9kOiAnR0VUJywgaGlkZUZyb21JbnNwZWN0b3I6IHRydWUgfSkpOyAvLyB0b1Byb21pc2UgdW50aWwgd2UgY2hhbmdlIGdldFRhZ1ZhbHVlcywgZ2V0VGFnS2V5cyB0byBPYnNlcnZhYmxlXG4gIH1cblxuICBpbnRlcnBvbGF0ZVF1ZXJ5RXhwcih2YWx1ZTogc3RyaW5nIHwgc3RyaW5nW10gPSBbXSwgdmFyaWFibGU6IGFueSkge1xuICAgIC8vIGlmIG5vIG11bHRpIG9yIGluY2x1ZGUgYWxsIGRvIG5vdCByZWdleEVzY2FwZVxuICAgIGlmICghdmFyaWFibGUubXVsdGkgJiYgIXZhcmlhYmxlLmluY2x1ZGVBbGwpIHtcbiAgICAgIHJldHVybiBwcm9tZXRoZXVzUmVndWxhckVzY2FwZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBwcm9tZXRoZXVzU3BlY2lhbFJlZ2V4RXNjYXBlKHZhbHVlKTtcbiAgICB9XG5cbiAgICBjb25zdCBlc2NhcGVkVmFsdWVzID0gdmFsdWUubWFwKCh2YWwpID0+IHByb21ldGhldXNTcGVjaWFsUmVnZXhFc2NhcGUodmFsKSk7XG5cbiAgICBpZiAoZXNjYXBlZFZhbHVlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBlc2NhcGVkVmFsdWVzWzBdO1xuICAgIH1cblxuICAgIHJldHVybiAnKCcgKyBlc2NhcGVkVmFsdWVzLmpvaW4oJ3wnKSArICcpJztcbiAgfVxuXG4gIHRhcmdldENvbnRhaW5zVGVtcGxhdGUodGFyZ2V0OiBQcm9tUXVlcnkpIHtcbiAgICByZXR1cm4gdGhpcy50ZW1wbGF0ZVNydi5jb250YWluc1RlbXBsYXRlKHRhcmdldC5leHByKTtcbiAgfVxuXG4gIHByZXBhcmVUYXJnZXRzID0gKG9wdGlvbnM6IERhdGFRdWVyeVJlcXVlc3Q8UHJvbVF1ZXJ5Piwgc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIpID0+IHtcbiAgICBjb25zdCBxdWVyaWVzOiBQcm9tUXVlcnlSZXF1ZXN0W10gPSBbXTtcbiAgICBjb25zdCBhY3RpdmVUYXJnZXRzOiBQcm9tUXVlcnlbXSA9IFtdO1xuICAgIGNvbnN0IGNsb25lZFRhcmdldHMgPSBjbG9uZURlZXAob3B0aW9ucy50YXJnZXRzKTtcblxuICAgIGZvciAoY29uc3QgdGFyZ2V0IG9mIGNsb25lZFRhcmdldHMpIHtcbiAgICAgIGlmICghdGFyZ2V0LmV4cHIgfHwgdGFyZ2V0LmhpZGUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHRhcmdldC5yZXF1ZXN0SWQgPSBvcHRpb25zLnBhbmVsSWQgKyB0YXJnZXQucmVmSWQ7XG4gICAgICBjb25zdCBtZXRyaWNOYW1lID0gdGhpcy5sYW5ndWFnZVByb3ZpZGVyLmhpc3RvZ3JhbU1ldHJpY3MuZmluZCgobSkgPT4gdGFyZ2V0LmV4cHIuaW5jbHVkZXMobSkpO1xuXG4gICAgICAvLyBJbiBFeHBsb3JlLCB3ZSBydW4gYm90aCAoaW5zdGFudCBhbmQgcmFuZ2UpIHF1ZXJpZXMgaWYgYm90aCBhcmUgdHJ1ZSAoc2VsZWN0ZWQpIG9yIGJvdGggYXJlIHVuZGVmaW5lZCAobGVnYWN5IEV4cGxvcmUgcXVlcmllcylcbiAgICAgIGlmIChvcHRpb25zLmFwcCA9PT0gQ29yZUFwcC5FeHBsb3JlICYmIHRhcmdldC5yYW5nZSA9PT0gdGFyZ2V0Lmluc3RhbnQpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGluc3RhbnQgdGFyZ2V0XG4gICAgICAgIGNvbnN0IGluc3RhbnRUYXJnZXQ6IGFueSA9IGNsb25lRGVlcCh0YXJnZXQpO1xuICAgICAgICBpbnN0YW50VGFyZ2V0LmZvcm1hdCA9ICd0YWJsZSc7XG4gICAgICAgIGluc3RhbnRUYXJnZXQuaW5zdGFudCA9IHRydWU7XG4gICAgICAgIGluc3RhbnRUYXJnZXQucmFuZ2UgPSBmYWxzZTtcbiAgICAgICAgaW5zdGFudFRhcmdldC52YWx1ZVdpdGhSZWZJZCA9IHRydWU7XG4gICAgICAgIGRlbGV0ZSBpbnN0YW50VGFyZ2V0Lm1heERhdGFQb2ludHM7XG4gICAgICAgIGluc3RhbnRUYXJnZXQucmVxdWVzdElkICs9ICdfaW5zdGFudCc7XG5cbiAgICAgICAgLy8gQ3JlYXRlIHJhbmdlIHRhcmdldFxuICAgICAgICBjb25zdCByYW5nZVRhcmdldDogYW55ID0gY2xvbmVEZWVwKHRhcmdldCk7XG4gICAgICAgIHJhbmdlVGFyZ2V0LmZvcm1hdCA9ICd0aW1lX3Nlcmllcyc7XG4gICAgICAgIHJhbmdlVGFyZ2V0Lmluc3RhbnQgPSBmYWxzZTtcbiAgICAgICAgaW5zdGFudFRhcmdldC5yYW5nZSA9IHRydWU7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGV4ZW1wbGFyIHF1ZXJ5XG4gICAgICAgIGlmICh0YXJnZXQuZXhlbXBsYXIpIHtcbiAgICAgICAgICAvLyBPbmx5IGNyZWF0ZSBleGVtcGxhciB0YXJnZXQgZm9yIGRpZmZlcmVudCBtZXRyaWMgbmFtZXNcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhbWV0cmljTmFtZSB8fFxuICAgICAgICAgICAgKG1ldHJpY05hbWUgJiYgIWFjdGl2ZVRhcmdldHMuc29tZSgoYWN0aXZlVGFyZ2V0KSA9PiBhY3RpdmVUYXJnZXQuZXhwci5pbmNsdWRlcyhtZXRyaWNOYW1lKSkpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCBleGVtcGxhclRhcmdldCA9IGNsb25lRGVlcCh0YXJnZXQpO1xuICAgICAgICAgICAgZXhlbXBsYXJUYXJnZXQuaW5zdGFudCA9IGZhbHNlO1xuICAgICAgICAgICAgZXhlbXBsYXJUYXJnZXQucmVxdWVzdElkICs9ICdfZXhlbXBsYXInO1xuICAgICAgICAgICAgcXVlcmllcy5wdXNoKHRoaXMuY3JlYXRlUXVlcnkoZXhlbXBsYXJUYXJnZXQsIG9wdGlvbnMsIHN0YXJ0LCBlbmQpKTtcbiAgICAgICAgICAgIGFjdGl2ZVRhcmdldHMucHVzaChleGVtcGxhclRhcmdldCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGluc3RhbnRUYXJnZXQuZXhlbXBsYXIgPSBmYWxzZTtcbiAgICAgICAgICByYW5nZVRhcmdldC5leGVtcGxhciA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIGJvdGggdGFyZ2V0cyB0byBhY3RpdmVUYXJnZXRzIGFuZCBxdWVyaWVzIGFycmF5c1xuICAgICAgICBhY3RpdmVUYXJnZXRzLnB1c2goaW5zdGFudFRhcmdldCwgcmFuZ2VUYXJnZXQpO1xuICAgICAgICBxdWVyaWVzLnB1c2goXG4gICAgICAgICAgdGhpcy5jcmVhdGVRdWVyeShpbnN0YW50VGFyZ2V0LCBvcHRpb25zLCBzdGFydCwgZW5kKSxcbiAgICAgICAgICB0aGlzLmNyZWF0ZVF1ZXJ5KHJhbmdlVGFyZ2V0LCBvcHRpb25zLCBzdGFydCwgZW5kKVxuICAgICAgICApO1xuICAgICAgICAvLyBJZiBydW5uaW5nIG9ubHkgaW5zdGFudCBxdWVyeSBpbiBFeHBsb3JlLCBmb3JtYXQgYXMgdGFibGVcbiAgICAgIH0gZWxzZSBpZiAodGFyZ2V0Lmluc3RhbnQgJiYgb3B0aW9ucy5hcHAgPT09IENvcmVBcHAuRXhwbG9yZSkge1xuICAgICAgICBjb25zdCBpbnN0YW50VGFyZ2V0OiBhbnkgPSBjbG9uZURlZXAodGFyZ2V0KTtcbiAgICAgICAgaW5zdGFudFRhcmdldC5mb3JtYXQgPSAndGFibGUnO1xuICAgICAgICBxdWVyaWVzLnB1c2godGhpcy5jcmVhdGVRdWVyeShpbnN0YW50VGFyZ2V0LCBvcHRpb25zLCBzdGFydCwgZW5kKSk7XG4gICAgICAgIGFjdGl2ZVRhcmdldHMucHVzaChpbnN0YW50VGFyZ2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEl0IGRvZXNuJ3QgbWFrZSBzZW5zZSB0byBxdWVyeSBmb3IgZXhlbXBsYXJzIGluIGRhc2hib2FyZCBpZiBvbmx5IGluc3RhbnQgaXMgc2VsZWN0ZWRcbiAgICAgICAgaWYgKHRhcmdldC5leGVtcGxhciAmJiAhdGFyZ2V0Lmluc3RhbnQpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhbWV0cmljTmFtZSB8fFxuICAgICAgICAgICAgKG1ldHJpY05hbWUgJiYgIWFjdGl2ZVRhcmdldHMuc29tZSgoYWN0aXZlVGFyZ2V0KSA9PiBhY3RpdmVUYXJnZXQuZXhwci5pbmNsdWRlcyhtZXRyaWNOYW1lKSkpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCBleGVtcGxhclRhcmdldCA9IGNsb25lRGVlcCh0YXJnZXQpO1xuICAgICAgICAgICAgZXhlbXBsYXJUYXJnZXQucmVxdWVzdElkICs9ICdfZXhlbXBsYXInO1xuICAgICAgICAgICAgcXVlcmllcy5wdXNoKHRoaXMuY3JlYXRlUXVlcnkoZXhlbXBsYXJUYXJnZXQsIG9wdGlvbnMsIHN0YXJ0LCBlbmQpKTtcbiAgICAgICAgICAgIGFjdGl2ZVRhcmdldHMucHVzaChleGVtcGxhclRhcmdldCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRhcmdldC5leGVtcGxhciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHF1ZXJpZXMucHVzaCh0aGlzLmNyZWF0ZVF1ZXJ5KHRhcmdldCwgb3B0aW9ucywgc3RhcnQsIGVuZCkpO1xuICAgICAgICBhY3RpdmVUYXJnZXRzLnB1c2godGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcXVlcmllcyxcbiAgICAgIGFjdGl2ZVRhcmdldHMsXG4gICAgfTtcbiAgfTtcblxuICBzaG91bGRSdW5FeGVtcGxhclF1ZXJ5KHRhcmdldDogUHJvbVF1ZXJ5LCByZXF1ZXN0OiBEYXRhUXVlcnlSZXF1ZXN0PFByb21RdWVyeT4pOiBib29sZWFuIHtcbiAgICBpZiAodGFyZ2V0LmV4ZW1wbGFyKSB7XG4gICAgICAvLyBXZSBjaGVjayBhbGwgYWxyZWFkeSBwcm9jZXNzZWQgdGFyZ2V0cyBhbmQgb25seSBjcmVhdGUgZXhlbXBsYXIgdGFyZ2V0IGZvciBub3QgdXNlZCBtZXRyaWMgbmFtZXNcbiAgICAgIGNvbnN0IG1ldHJpY05hbWUgPSB0aGlzLmxhbmd1YWdlUHJvdmlkZXIuaGlzdG9ncmFtTWV0cmljcy5maW5kKChtKSA9PiB0YXJnZXQuZXhwci5pbmNsdWRlcyhtKSk7XG4gICAgICAvLyBSZW1vdmUgdGFyZ2V0cyB0aGF0IHdlcmVuJ3QgcHJvY2Vzc2VkIHlldCAoaW4gdGFyZ2V0cyBhcnJheSB0aGV5IGFyZSBhZnRlciBjdXJyZW50IHRhcmdldClcbiAgICAgIGNvbnN0IGN1cnJlbnRUYXJnZXRJZHggPSByZXF1ZXN0LnRhcmdldHMuZmluZEluZGV4KCh0KSA9PiB0LnJlZklkID09PSB0YXJnZXQucmVmSWQpO1xuICAgICAgY29uc3QgdGFyZ2V0cyA9IHJlcXVlc3QudGFyZ2V0cy5zbGljZSgwLCBjdXJyZW50VGFyZ2V0SWR4KTtcblxuICAgICAgaWYgKCFtZXRyaWNOYW1lIHx8IChtZXRyaWNOYW1lICYmICF0YXJnZXRzLnNvbWUoKHQpID0+IHQuZXhwci5pbmNsdWRlcyhtZXRyaWNOYW1lKSkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwcm9jZXNzVGFyZ2V0VjIodGFyZ2V0OiBQcm9tUXVlcnksIHJlcXVlc3Q6IERhdGFRdWVyeVJlcXVlc3Q8UHJvbVF1ZXJ5Pikge1xuICAgIGNvbnN0IHByb2Nlc3NlZFRhcmdldCA9IHtcbiAgICAgIC4uLnRhcmdldCxcbiAgICAgIHF1ZXJ5VHlwZTogUHJvbVF1ZXJ5VHlwZS50aW1lU2VyaWVzUXVlcnksXG4gICAgICBleGVtcGxhcjogdGhpcy5zaG91bGRSdW5FeGVtcGxhclF1ZXJ5KHRhcmdldCwgcmVxdWVzdCksXG4gICAgICByZXF1ZXN0SWQ6IHJlcXVlc3QucGFuZWxJZCArIHRhcmdldC5yZWZJZCxcbiAgICAgIC8vIFdlIG5lZWQgdG8gcGFzcyB1dGNPZmZzZXRTZWMgdG8gYmFja2VuZCB0byBjYWxjdWxhdGUgYWxpZ25lZCByYW5nZVxuICAgICAgdXRjT2Zmc2V0U2VjOiB0aGlzLnRpbWVTcnYudGltZVJhbmdlKCkudG8udXRjT2Zmc2V0KCkgKiA2MCxcbiAgICB9O1xuICAgIHJldHVybiBwcm9jZXNzZWRUYXJnZXQ7XG4gIH1cblxuICBxdWVyeShyZXF1ZXN0OiBEYXRhUXVlcnlSZXF1ZXN0PFByb21RdWVyeT4pOiBPYnNlcnZhYmxlPERhdGFRdWVyeVJlc3BvbnNlPiB7XG4gICAgaWYgKHRoaXMuYWNjZXNzID09PSAncHJveHknKSB7XG4gICAgICBjb25zdCB0YXJnZXRzID0gcmVxdWVzdC50YXJnZXRzLm1hcCgodGFyZ2V0KSA9PiB0aGlzLnByb2Nlc3NUYXJnZXRWMih0YXJnZXQsIHJlcXVlc3QpKTtcbiAgICAgIHJldHVybiBzdXBlclxuICAgICAgICAucXVlcnkoeyAuLi5yZXF1ZXN0LCB0YXJnZXRzIH0pXG4gICAgICAgIC5waXBlKFxuICAgICAgICAgIG1hcCgocmVzcG9uc2UpID0+XG4gICAgICAgICAgICB0cmFuc2Zvcm1WMihyZXNwb25zZSwgcmVxdWVzdCwgeyBleGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbnM6IHRoaXMuZXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb25zIH0pXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgLy8gUnVuIHF1ZXJpZXMgdHJvdWdoIGJyb3dzZXIvcHJveHlcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLmdldFByb21ldGhldXNUaW1lKHJlcXVlc3QucmFuZ2UuZnJvbSwgZmFsc2UpO1xuICAgICAgY29uc3QgZW5kID0gdGhpcy5nZXRQcm9tZXRoZXVzVGltZShyZXF1ZXN0LnJhbmdlLnRvLCB0cnVlKTtcbiAgICAgIGNvbnN0IHsgcXVlcmllcywgYWN0aXZlVGFyZ2V0cyB9ID0gdGhpcy5wcmVwYXJlVGFyZ2V0cyhyZXF1ZXN0LCBzdGFydCwgZW5kKTtcblxuICAgICAgLy8gTm8gdmFsaWQgdGFyZ2V0cywgcmV0dXJuIHRoZSBlbXB0eSByZXN1bHQgdG8gc2F2ZSBhIHJvdW5kIHRyaXAuXG4gICAgICBpZiAoIXF1ZXJpZXMgfHwgIXF1ZXJpZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBvZih7XG4gICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgc3RhdGU6IExvYWRpbmdTdGF0ZS5Eb25lLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlcXVlc3QuYXBwID09PSBDb3JlQXBwLkV4cGxvcmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwbG9yZVF1ZXJ5KHF1ZXJpZXMsIGFjdGl2ZVRhcmdldHMsIGVuZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnBhbmVsc1F1ZXJ5KHF1ZXJpZXMsIGFjdGl2ZVRhcmdldHMsIGVuZCwgcmVxdWVzdC5yZXF1ZXN0SWQsIHJlcXVlc3Quc2NvcGVkVmFycyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBleHBsb3JlUXVlcnkocXVlcmllczogUHJvbVF1ZXJ5UmVxdWVzdFtdLCBhY3RpdmVUYXJnZXRzOiBQcm9tUXVlcnlbXSwgZW5kOiBudW1iZXIpIHtcbiAgICBsZXQgcnVubmluZ1F1ZXJpZXNDb3VudCA9IHF1ZXJpZXMubGVuZ3RoO1xuXG4gICAgY29uc3Qgc3ViUXVlcmllcyA9IHF1ZXJpZXMubWFwKChxdWVyeSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGFjdGl2ZVRhcmdldHNbaW5kZXhdO1xuXG4gICAgICBjb25zdCBmaWx0ZXJBbmRNYXBSZXNwb25zZSA9IHBpcGUoXG4gICAgICAgIC8vIERlY3JlYXNlIHRoZSBjb3VudGVyIGhlcmUuIFdlIGFzc3VtZSB0aGF0IGVhY2ggcmVxdWVzdCByZXR1cm5zIG9ubHkgc2luZ2xlIHZhbHVlIGFuZCB0aGVuIGNvbXBsZXRlc1xuICAgICAgICAvLyAoc2hvdWxkIGhvbGQgdW50aWwgdGhlcmUgaXMgc29tZSBzdHJlYW1pbmcgcmVxdWVzdHMgaW52b2x2ZWQpLlxuICAgICAgICB0YXAoKCkgPT4gcnVubmluZ1F1ZXJpZXNDb3VudC0tKSxcbiAgICAgICAgZmlsdGVyKChyZXNwb25zZTogYW55KSA9PiAocmVzcG9uc2UuY2FuY2VsbGVkID8gZmFsc2UgOiB0cnVlKSksXG4gICAgICAgIG1hcCgocmVzcG9uc2U6IGFueSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSB0cmFuc2Zvcm0ocmVzcG9uc2UsIHtcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgcmVzcG9uc2VMaXN0TGVuZ3RoOiBxdWVyaWVzLmxlbmd0aCxcbiAgICAgICAgICAgIGV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uczogdGhpcy5leGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbnMsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBrZXk6IHF1ZXJ5LnJlcXVlc3RJZCxcbiAgICAgICAgICAgIHN0YXRlOiBydW5uaW5nUXVlcmllc0NvdW50ID09PSAwID8gTG9hZGluZ1N0YXRlLkRvbmUgOiBMb2FkaW5nU3RhdGUuTG9hZGluZyxcbiAgICAgICAgICB9IGFzIERhdGFRdWVyeVJlc3BvbnNlO1xuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHRoaXMucnVuUXVlcnkocXVlcnksIGVuZCwgZmlsdGVyQW5kTWFwUmVzcG9uc2UpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG1lcmdlKC4uLnN1YlF1ZXJpZXMpO1xuICB9XG5cbiAgcHJpdmF0ZSBwYW5lbHNRdWVyeShcbiAgICBxdWVyaWVzOiBQcm9tUXVlcnlSZXF1ZXN0W10sXG4gICAgYWN0aXZlVGFyZ2V0czogUHJvbVF1ZXJ5W10sXG4gICAgZW5kOiBudW1iZXIsXG4gICAgcmVxdWVzdElkOiBzdHJpbmcsXG4gICAgc2NvcGVkVmFyczogU2NvcGVkVmFyc1xuICApIHtcbiAgICBjb25zdCBvYnNlcnZhYmxlcyA9IHF1ZXJpZXMubWFwKChxdWVyeSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGFjdGl2ZVRhcmdldHNbaW5kZXhdO1xuXG4gICAgICBjb25zdCBmaWx0ZXJBbmRNYXBSZXNwb25zZSA9IHBpcGUoXG4gICAgICAgIGZpbHRlcigocmVzcG9uc2U6IGFueSkgPT4gKHJlc3BvbnNlLmNhbmNlbGxlZCA/IGZhbHNlIDogdHJ1ZSkpLFxuICAgICAgICBtYXAoKHJlc3BvbnNlOiBhbnkpID0+IHtcbiAgICAgICAgICBjb25zdCBkYXRhID0gdHJhbnNmb3JtKHJlc3BvbnNlLCB7XG4gICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgIHJlc3BvbnNlTGlzdExlbmd0aDogcXVlcmllcy5sZW5ndGgsXG4gICAgICAgICAgICBzY29wZWRWYXJzLFxuICAgICAgICAgICAgZXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb25zOiB0aGlzLmV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9ucyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiB0aGlzLnJ1blF1ZXJ5KHF1ZXJ5LCBlbmQsIGZpbHRlckFuZE1hcFJlc3BvbnNlKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBmb3JrSm9pbihvYnNlcnZhYmxlcykucGlwZShcbiAgICAgIG1hcCgocmVzdWx0cykgPT4ge1xuICAgICAgICBjb25zdCBkYXRhID0gcmVzdWx0cy5yZWR1Y2UoKHJlc3VsdCwgY3VycmVudCkgPT4ge1xuICAgICAgICAgIHJldHVybiBbLi4ucmVzdWx0LCAuLi5jdXJyZW50XTtcbiAgICAgICAgfSwgW10pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGEsXG4gICAgICAgICAga2V5OiByZXF1ZXN0SWQsXG4gICAgICAgICAgc3RhdGU6IExvYWRpbmdTdGF0ZS5Eb25lLFxuICAgICAgICB9O1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBydW5RdWVyeTxUPihxdWVyeTogUHJvbVF1ZXJ5UmVxdWVzdCwgZW5kOiBudW1iZXIsIGZpbHRlcjogT3BlcmF0b3JGdW5jdGlvbjxhbnksIFQ+KTogT2JzZXJ2YWJsZTxUPiB7XG4gICAgaWYgKHF1ZXJ5Lmluc3RhbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnBlcmZvcm1JbnN0YW50UXVlcnkocXVlcnksIGVuZCkucGlwZShmaWx0ZXIpO1xuICAgIH1cblxuICAgIGlmIChxdWVyeS5leGVtcGxhcikge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RXhlbXBsYXJzKHF1ZXJ5KS5waXBlKFxuICAgICAgICBjYXRjaEVycm9yKCgpID0+IHtcbiAgICAgICAgICByZXR1cm4gb2Yoe1xuICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgICBzdGF0ZTogTG9hZGluZ1N0YXRlLkRvbmUsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pLFxuICAgICAgICBmaWx0ZXJcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucGVyZm9ybVRpbWVTZXJpZXNRdWVyeShxdWVyeSwgcXVlcnkuc3RhcnQsIHF1ZXJ5LmVuZCkucGlwZShmaWx0ZXIpO1xuICB9XG5cbiAgY3JlYXRlUXVlcnkodGFyZ2V0OiBQcm9tUXVlcnksIG9wdGlvbnM6IERhdGFRdWVyeVJlcXVlc3Q8UHJvbVF1ZXJ5Piwgc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIpIHtcbiAgICBjb25zdCBxdWVyeTogUHJvbVF1ZXJ5UmVxdWVzdCA9IHtcbiAgICAgIGhpbnRpbmc6IHRhcmdldC5oaW50aW5nLFxuICAgICAgaW5zdGFudDogdGFyZ2V0Lmluc3RhbnQsXG4gICAgICBleGVtcGxhcjogdGFyZ2V0LmV4ZW1wbGFyLFxuICAgICAgc3RlcDogMCxcbiAgICAgIGV4cHI6ICcnLFxuICAgICAgcmVxdWVzdElkOiB0YXJnZXQucmVxdWVzdElkLFxuICAgICAgcmVmSWQ6IHRhcmdldC5yZWZJZCxcbiAgICAgIHN0YXJ0OiAwLFxuICAgICAgZW5kOiAwLFxuICAgIH07XG4gICAgY29uc3QgcmFuZ2UgPSBNYXRoLmNlaWwoZW5kIC0gc3RhcnQpO1xuXG4gICAgLy8gb3B0aW9ucy5pbnRlcnZhbCBpcyB0aGUgZHluYW1pY2FsbHkgY2FsY3VsYXRlZCBpbnRlcnZhbFxuICAgIGxldCBpbnRlcnZhbDogbnVtYmVyID0gcmFuZ2VVdGlsLmludGVydmFsVG9TZWNvbmRzKG9wdGlvbnMuaW50ZXJ2YWwpO1xuICAgIC8vIE1pbmltdW0gaW50ZXJ2YWwgKFwiTWluIHN0ZXBcIiksIGlmIHNwZWNpZmllZCBmb3IgdGhlIHF1ZXJ5LCBvciBzYW1lIGFzIGludGVydmFsIG90aGVyd2lzZS5cbiAgICBjb25zdCBtaW5JbnRlcnZhbCA9IHJhbmdlVXRpbC5pbnRlcnZhbFRvU2Vjb25kcyhcbiAgICAgIHRoaXMudGVtcGxhdGVTcnYucmVwbGFjZSh0YXJnZXQuaW50ZXJ2YWwgfHwgb3B0aW9ucy5pbnRlcnZhbCwgb3B0aW9ucy5zY29wZWRWYXJzKVxuICAgICk7XG4gICAgLy8gU2NyYXBlIGludGVydmFsIGFzIHNwZWNpZmllZCBmb3IgdGhlIHF1ZXJ5IChcIk1pbiBzdGVwXCIpIG9yIG90aGVyd2lzZSB0YWtlbiBmcm9tIHRoZSBkYXRhc291cmNlLlxuICAgIC8vIE1pbiBzdGVwIGZpZWxkIGNhbiBoYXZlIHRlbXBsYXRlIHZhcmlhYmxlcyBpbiBpdCwgbWFrZSBzdXJlIHRvIHJlcGxhY2UgaXQuXG4gICAgY29uc3Qgc2NyYXBlSW50ZXJ2YWwgPSB0YXJnZXQuaW50ZXJ2YWxcbiAgICAgID8gcmFuZ2VVdGlsLmludGVydmFsVG9TZWNvbmRzKHRoaXMudGVtcGxhdGVTcnYucmVwbGFjZSh0YXJnZXQuaW50ZXJ2YWwsIG9wdGlvbnMuc2NvcGVkVmFycykpXG4gICAgICA6IHJhbmdlVXRpbC5pbnRlcnZhbFRvU2Vjb25kcyh0aGlzLmludGVydmFsKTtcblxuICAgIGNvbnN0IGludGVydmFsRmFjdG9yID0gdGFyZ2V0LmludGVydmFsRmFjdG9yIHx8IDE7XG4gICAgLy8gQWRqdXN0IHRoZSBpbnRlcnZhbCB0byB0YWtlIGludG8gYWNjb3VudCBhbnkgc3BlY2lmaWVkIG1pbmltdW0gYW5kIGludGVydmFsIGZhY3RvciBwbHVzIFByb21ldGhldXMgbGltaXRzXG4gICAgY29uc3QgYWRqdXN0ZWRJbnRlcnZhbCA9IHRoaXMuYWRqdXN0SW50ZXJ2YWwoaW50ZXJ2YWwsIG1pbkludGVydmFsLCByYW5nZSwgaW50ZXJ2YWxGYWN0b3IpO1xuICAgIGxldCBzY29wZWRWYXJzID0ge1xuICAgICAgLi4ub3B0aW9ucy5zY29wZWRWYXJzLFxuICAgICAgLi4udGhpcy5nZXRSYW5nZVNjb3BlZFZhcnMob3B0aW9ucy5yYW5nZSksXG4gICAgICAuLi50aGlzLmdldFJhdGVJbnRlcnZhbFNjb3BlZFZhcmlhYmxlKGFkanVzdGVkSW50ZXJ2YWwsIHNjcmFwZUludGVydmFsKSxcbiAgICB9O1xuICAgIC8vIElmIHRoZSBpbnRlcnZhbCB3YXMgYWRqdXN0ZWQsIG1ha2UgYSBzaGFsbG93IGNvcHkgb2Ygc2NvcGVkVmFycyB3aXRoIHVwZGF0ZWQgaW50ZXJ2YWwgdmFyc1xuICAgIGlmIChpbnRlcnZhbCAhPT0gYWRqdXN0ZWRJbnRlcnZhbCkge1xuICAgICAgaW50ZXJ2YWwgPSBhZGp1c3RlZEludGVydmFsO1xuICAgICAgc2NvcGVkVmFycyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMuc2NvcGVkVmFycywge1xuICAgICAgICBfX2ludGVydmFsOiB7IHRleHQ6IGludGVydmFsICsgJ3MnLCB2YWx1ZTogaW50ZXJ2YWwgKyAncycgfSxcbiAgICAgICAgX19pbnRlcnZhbF9tczogeyB0ZXh0OiBpbnRlcnZhbCAqIDEwMDAsIHZhbHVlOiBpbnRlcnZhbCAqIDEwMDAgfSxcbiAgICAgICAgLi4udGhpcy5nZXRSYXRlSW50ZXJ2YWxTY29wZWRWYXJpYWJsZShpbnRlcnZhbCwgc2NyYXBlSW50ZXJ2YWwpLFxuICAgICAgICAuLi50aGlzLmdldFJhbmdlU2NvcGVkVmFycyhvcHRpb25zLnJhbmdlKSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBxdWVyeS5zdGVwID0gaW50ZXJ2YWw7XG5cbiAgICBsZXQgZXhwciA9IHRhcmdldC5leHByO1xuXG4gICAgLy8gQXBwbHkgYWRob2MgZmlsdGVyc1xuICAgIGV4cHIgPSB0aGlzLmVuaGFuY2VFeHByV2l0aEFkSG9jRmlsdGVycyhleHByKTtcblxuICAgIC8vIE9ubHkgcmVwbGFjZSB2YXJzIGluIGV4cHJlc3Npb24gYWZ0ZXIgaGF2aW5nIChwb3NzaWJseSkgdXBkYXRlZCBpbnRlcnZhbCB2YXJzXG4gICAgcXVlcnkuZXhwciA9IHRoaXMudGVtcGxhdGVTcnYucmVwbGFjZShleHByLCBzY29wZWRWYXJzLCB0aGlzLmludGVycG9sYXRlUXVlcnlFeHByKTtcblxuICAgIC8vIEFsaWduIHF1ZXJ5IGludGVydmFsIHdpdGggc3RlcCB0byBhbGxvdyBxdWVyeSBjYWNoaW5nIGFuZCB0byBlbnN1cmVcbiAgICAvLyB0aGF0IGFib3V0LXNhbWUtdGltZSBxdWVyeSByZXN1bHRzIGxvb2sgdGhlIHNhbWUuXG4gICAgY29uc3QgYWRqdXN0ZWQgPSBhbGlnblJhbmdlKHN0YXJ0LCBlbmQsIHF1ZXJ5LnN0ZXAsIHRoaXMudGltZVNydi50aW1lUmFuZ2UoKS50by51dGNPZmZzZXQoKSAqIDYwKTtcbiAgICBxdWVyeS5zdGFydCA9IGFkanVzdGVkLnN0YXJ0O1xuICAgIHF1ZXJ5LmVuZCA9IGFkanVzdGVkLmVuZDtcbiAgICB0aGlzLl9hZGRUcmFjaW5nSGVhZGVycyhxdWVyeSwgb3B0aW9ucyk7XG5cbiAgICByZXR1cm4gcXVlcnk7XG4gIH1cblxuICBnZXRSYXRlSW50ZXJ2YWxTY29wZWRWYXJpYWJsZShpbnRlcnZhbDogbnVtYmVyLCBzY3JhcGVJbnRlcnZhbDogbnVtYmVyKSB7XG4gICAgLy8gRmFsbCBiYWNrIHRvIHRoZSBkZWZhdWx0IHNjcmFwZSBpbnRlcnZhbCBvZiAxNXMgaWYgc2NyYXBlSW50ZXJ2YWwgaXMgMCBmb3Igc29tZSByZWFzb24uXG4gICAgaWYgKHNjcmFwZUludGVydmFsID09PSAwKSB7XG4gICAgICBzY3JhcGVJbnRlcnZhbCA9IDE1O1xuICAgIH1cbiAgICBjb25zdCByYXRlSW50ZXJ2YWwgPSBNYXRoLm1heChpbnRlcnZhbCArIHNjcmFwZUludGVydmFsLCA0ICogc2NyYXBlSW50ZXJ2YWwpO1xuICAgIHJldHVybiB7IF9fcmF0ZV9pbnRlcnZhbDogeyB0ZXh0OiByYXRlSW50ZXJ2YWwgKyAncycsIHZhbHVlOiByYXRlSW50ZXJ2YWwgKyAncycgfSB9O1xuICB9XG5cbiAgYWRqdXN0SW50ZXJ2YWwoaW50ZXJ2YWw6IG51bWJlciwgbWluSW50ZXJ2YWw6IG51bWJlciwgcmFuZ2U6IG51bWJlciwgaW50ZXJ2YWxGYWN0b3I6IG51bWJlcikge1xuICAgIC8vIFByb21ldGhldXMgd2lsbCBkcm9wIHF1ZXJpZXMgdGhhdCBtaWdodCByZXR1cm4gbW9yZSB0aGFuIDExMDAwIGRhdGEgcG9pbnRzLlxuICAgIC8vIENhbGN1bGF0ZSBhIHNhZmUgaW50ZXJ2YWwgYXMgYW4gYWRkaXRpb25hbCBtaW5pbXVtIHRvIHRha2UgaW50byBhY2NvdW50LlxuICAgIC8vIEZyYWN0aW9uYWwgc2FmZUludGVydmFscyBhcmUgYWxsb3dlZCwgaG93ZXZlciBzZXJ2ZSBsaXR0bGUgcHVycG9zZSBpZiB0aGUgaW50ZXJ2YWwgaXMgZ3JlYXRlciB0aGFuIDFcbiAgICAvLyBJZiB0aGlzIGlzIHRoZSBjYXNlIHRha2UgdGhlIGNlaWwgb2YgdGhlIHZhbHVlLlxuICAgIGxldCBzYWZlSW50ZXJ2YWwgPSByYW5nZSAvIDExMDAwO1xuICAgIGlmIChzYWZlSW50ZXJ2YWwgPiAxKSB7XG4gICAgICBzYWZlSW50ZXJ2YWwgPSBNYXRoLmNlaWwoc2FmZUludGVydmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgubWF4KGludGVydmFsICogaW50ZXJ2YWxGYWN0b3IsIG1pbkludGVydmFsLCBzYWZlSW50ZXJ2YWwpO1xuICB9XG5cbiAgcGVyZm9ybVRpbWVTZXJpZXNRdWVyeShxdWVyeTogUHJvbVF1ZXJ5UmVxdWVzdCwgc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIpIHtcbiAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgIHRocm93IHsgbWVzc2FnZTogJ0ludmFsaWQgdGltZSByYW5nZScgfTtcbiAgICB9XG5cbiAgICBjb25zdCB1cmwgPSAnL2FwaS92MS9xdWVyeV9yYW5nZSc7XG4gICAgY29uc3QgZGF0YTogYW55ID0ge1xuICAgICAgcXVlcnk6IHF1ZXJ5LmV4cHIsXG4gICAgICBzdGFydCxcbiAgICAgIGVuZCxcbiAgICAgIHN0ZXA6IHF1ZXJ5LnN0ZXAsXG4gICAgfTtcblxuICAgIGlmICh0aGlzLnF1ZXJ5VGltZW91dCkge1xuICAgICAgZGF0YVsndGltZW91dCddID0gdGhpcy5xdWVyeVRpbWVvdXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3Q8UHJvbURhdGFTdWNjZXNzUmVzcG9uc2U8UHJvbU1hdHJpeERhdGE+Pih1cmwsIGRhdGEsIHtcbiAgICAgIHJlcXVlc3RJZDogcXVlcnkucmVxdWVzdElkLFxuICAgICAgaGVhZGVyczogcXVlcnkuaGVhZGVycyxcbiAgICB9KS5waXBlKFxuICAgICAgY2F0Y2hFcnJvcigoZXJyOiBGZXRjaEVycm9yPFByb21EYXRhRXJyb3JSZXNwb25zZTxQcm9tTWF0cml4RGF0YT4+KSA9PiB7XG4gICAgICAgIGlmIChlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgcmV0dXJuIG9mKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhyb3dFcnJvcih0aGlzLmhhbmRsZUVycm9ycyhlcnIsIHF1ZXJ5KSk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBwZXJmb3JtSW5zdGFudFF1ZXJ5KFxuICAgIHF1ZXJ5OiBQcm9tUXVlcnlSZXF1ZXN0LFxuICAgIHRpbWU6IG51bWJlclxuICApOiBPYnNlcnZhYmxlPEZldGNoUmVzcG9uc2U8UHJvbURhdGFTdWNjZXNzUmVzcG9uc2U8UHJvbVZlY3RvckRhdGEgfCBQcm9tU2NhbGFyRGF0YT4+IHwgRmV0Y2hFcnJvcj4ge1xuICAgIGNvbnN0IHVybCA9ICcvYXBpL3YxL3F1ZXJ5JztcbiAgICBjb25zdCBkYXRhOiBhbnkgPSB7XG4gICAgICBxdWVyeTogcXVlcnkuZXhwcixcbiAgICAgIHRpbWUsXG4gICAgfTtcblxuICAgIGlmICh0aGlzLnF1ZXJ5VGltZW91dCkge1xuICAgICAgZGF0YVsndGltZW91dCddID0gdGhpcy5xdWVyeVRpbWVvdXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3Q8UHJvbURhdGFTdWNjZXNzUmVzcG9uc2U8UHJvbVZlY3RvckRhdGEgfCBQcm9tU2NhbGFyRGF0YT4+KHVybCwgZGF0YSwge1xuICAgICAgcmVxdWVzdElkOiBxdWVyeS5yZXF1ZXN0SWQsXG4gICAgICBoZWFkZXJzOiBxdWVyeS5oZWFkZXJzLFxuICAgIH0pLnBpcGUoXG4gICAgICBjYXRjaEVycm9yKChlcnI6IEZldGNoRXJyb3I8UHJvbURhdGFFcnJvclJlc3BvbnNlPFByb21WZWN0b3JEYXRhIHwgUHJvbVNjYWxhckRhdGE+PikgPT4ge1xuICAgICAgICBpZiAoZXJyLmNhbmNlbGxlZCkge1xuICAgICAgICAgIHJldHVybiBvZihlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IodGhpcy5oYW5kbGVFcnJvcnMoZXJyLCBxdWVyeSkpO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgaGFuZGxlRXJyb3JzID0gKGVycjogYW55LCB0YXJnZXQ6IFByb21RdWVyeSkgPT4ge1xuICAgIGNvbnN0IGVycm9yOiBEYXRhUXVlcnlFcnJvciA9IHtcbiAgICAgIG1lc3NhZ2U6IChlcnIgJiYgZXJyLnN0YXR1c1RleHQpIHx8ICdVbmtub3duIGVycm9yIGR1cmluZyBxdWVyeSB0cmFuc2FjdGlvbi4gUGxlYXNlIGNoZWNrIEpTIGNvbnNvbGUgbG9ncy4nLFxuICAgICAgcmVmSWQ6IHRhcmdldC5yZWZJZCxcbiAgICB9O1xuXG4gICAgaWYgKGVyci5kYXRhKSB7XG4gICAgICBpZiAodHlwZW9mIGVyci5kYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICBlcnJvci5tZXNzYWdlID0gZXJyLmRhdGE7XG4gICAgICB9IGVsc2UgaWYgKGVyci5kYXRhLmVycm9yKSB7XG4gICAgICAgIGVycm9yLm1lc3NhZ2UgPSBzYWZlU3RyaW5naWZ5VmFsdWUoZXJyLmRhdGEuZXJyb3IpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZXJyLm1lc3NhZ2UpIHtcbiAgICAgIGVycm9yLm1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlcnIgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlcnJvci5tZXNzYWdlID0gZXJyO1xuICAgIH1cblxuICAgIGVycm9yLnN0YXR1cyA9IGVyci5zdGF0dXM7XG4gICAgZXJyb3Iuc3RhdHVzVGV4dCA9IGVyci5zdGF0dXNUZXh0O1xuXG4gICAgcmV0dXJuIGVycm9yO1xuICB9O1xuXG4gIG1ldHJpY0ZpbmRRdWVyeShxdWVyeTogc3RyaW5nKSB7XG4gICAgaWYgKCFxdWVyeSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2NvcGVkVmFycyA9IHtcbiAgICAgIF9faW50ZXJ2YWw6IHsgdGV4dDogdGhpcy5pbnRlcnZhbCwgdmFsdWU6IHRoaXMuaW50ZXJ2YWwgfSxcbiAgICAgIF9faW50ZXJ2YWxfbXM6IHsgdGV4dDogcmFuZ2VVdGlsLmludGVydmFsVG9Ncyh0aGlzLmludGVydmFsKSwgdmFsdWU6IHJhbmdlVXRpbC5pbnRlcnZhbFRvTXModGhpcy5pbnRlcnZhbCkgfSxcbiAgICAgIC4uLnRoaXMuZ2V0UmFuZ2VTY29wZWRWYXJzKHRoaXMudGltZVNydi50aW1lUmFuZ2UoKSksXG4gICAgfTtcbiAgICBjb25zdCBpbnRlcnBvbGF0ZWQgPSB0aGlzLnRlbXBsYXRlU3J2LnJlcGxhY2UocXVlcnksIHNjb3BlZFZhcnMsIHRoaXMuaW50ZXJwb2xhdGVRdWVyeUV4cHIpO1xuICAgIGNvbnN0IG1ldHJpY0ZpbmRRdWVyeSA9IG5ldyBQcm9tZXRoZXVzTWV0cmljRmluZFF1ZXJ5KHRoaXMsIGludGVycG9sYXRlZCk7XG4gICAgcmV0dXJuIG1ldHJpY0ZpbmRRdWVyeS5wcm9jZXNzKCk7XG4gIH1cblxuICBnZXRSYW5nZVNjb3BlZFZhcnMocmFuZ2U6IFRpbWVSYW5nZSA9IHRoaXMudGltZVNydi50aW1lUmFuZ2UoKSkge1xuICAgIGNvbnN0IG1zUmFuZ2UgPSByYW5nZS50by5kaWZmKHJhbmdlLmZyb20pO1xuICAgIGNvbnN0IHNSYW5nZSA9IE1hdGgucm91bmQobXNSYW5nZSAvIDEwMDApO1xuICAgIHJldHVybiB7XG4gICAgICBfX3JhbmdlX21zOiB7IHRleHQ6IG1zUmFuZ2UsIHZhbHVlOiBtc1JhbmdlIH0sXG4gICAgICBfX3JhbmdlX3M6IHsgdGV4dDogc1JhbmdlLCB2YWx1ZTogc1JhbmdlIH0sXG4gICAgICBfX3JhbmdlOiB7IHRleHQ6IHNSYW5nZSArICdzJywgdmFsdWU6IHNSYW5nZSArICdzJyB9LFxuICAgIH07XG4gIH1cblxuICBhc3luYyBhbm5vdGF0aW9uUXVlcnkob3B0aW9uczogYW55KTogUHJvbWlzZTxBbm5vdGF0aW9uRXZlbnRbXT4ge1xuICAgIGNvbnN0IGFubm90YXRpb24gPSBvcHRpb25zLmFubm90YXRpb247XG4gICAgY29uc3QgeyBleHByID0gJycgfSA9IGFubm90YXRpb247XG5cbiAgICBpZiAoIWV4cHIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pO1xuICAgIH1cblxuICAgIGNvbnN0IHN0ZXAgPSBvcHRpb25zLmFubm90YXRpb24uc3RlcCB8fCBBTk5PVEFUSU9OX1FVRVJZX1NURVBfREVGQVVMVDtcbiAgICBjb25zdCBxdWVyeU1vZGVsID0ge1xuICAgICAgZXhwcixcbiAgICAgIHJhbmdlOiB0cnVlLFxuICAgICAgaW5zdGFudDogZmFsc2UsXG4gICAgICBleGVtcGxhcjogZmFsc2UsXG4gICAgICBpbnRlcnZhbDogc3RlcCxcbiAgICAgIHF1ZXJ5VHlwZTogUHJvbVF1ZXJ5VHlwZS50aW1lU2VyaWVzUXVlcnksXG4gICAgICByZWZJZDogJ1gnLFxuICAgICAgZGF0YXNvdXJjZTogdGhpcy5nZXRSZWYoKSxcbiAgICB9O1xuXG4gICAgcmV0dXJuIGF3YWl0IGxhc3RWYWx1ZUZyb20oXG4gICAgICBnZXRCYWNrZW5kU3J2KClcbiAgICAgICAgLmZldGNoPEJhY2tlbmREYXRhU291cmNlUmVzcG9uc2U+KHtcbiAgICAgICAgICB1cmw6ICcvYXBpL2RzL3F1ZXJ5JyxcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBmcm9tOiAodGhpcy5nZXRQcm9tZXRoZXVzVGltZShvcHRpb25zLnJhbmdlLmZyb20sIGZhbHNlKSAqIDEwMDApLnRvU3RyaW5nKCksXG4gICAgICAgICAgICB0bzogKHRoaXMuZ2V0UHJvbWV0aGV1c1RpbWUob3B0aW9ucy5yYW5nZS50bywgdHJ1ZSkgKiAxMDAwKS50b1N0cmluZygpLFxuICAgICAgICAgICAgcXVlcmllczogW3RoaXMuYXBwbHlUZW1wbGF0ZVZhcmlhYmxlcyhxdWVyeU1vZGVsLCB7fSldLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVxdWVzdElkOiBgcHJvbS1xdWVyeS0ke2Fubm90YXRpb24ubmFtZX1gLFxuICAgICAgICB9KVxuICAgICAgICAucGlwZShcbiAgICAgICAgICBtYXAoKHJzcDogRmV0Y2hSZXNwb25zZTxCYWNrZW5kRGF0YVNvdXJjZVJlc3BvbnNlPikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc0Fubm90YXRpb25SZXNwb25zZShvcHRpb25zLCByc3AuZGF0YSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICk7XG4gIH1cblxuICBwcm9jZXNzQW5ub3RhdGlvblJlc3BvbnNlID0gKG9wdGlvbnM6IGFueSwgZGF0YTogQmFja2VuZERhdGFTb3VyY2VSZXNwb25zZSkgPT4ge1xuICAgIGNvbnN0IGZyYW1lczogRGF0YUZyYW1lW10gPSB0b0RhdGFRdWVyeVJlc3BvbnNlKHsgZGF0YTogZGF0YSB9KS5kYXRhO1xuICAgIGlmICghZnJhbWVzIHx8ICFmcmFtZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgYW5ub3RhdGlvbiA9IG9wdGlvbnMuYW5ub3RhdGlvbjtcbiAgICBjb25zdCB7IHRhZ0tleXMgPSAnJywgdGl0bGVGb3JtYXQgPSAnJywgdGV4dEZvcm1hdCA9ICcnIH0gPSBhbm5vdGF0aW9uO1xuXG4gICAgY29uc3Qgc3RlcCA9IHJhbmdlVXRpbC5pbnRlcnZhbFRvU2Vjb25kcyhhbm5vdGF0aW9uLnN0ZXAgfHwgQU5OT1RBVElPTl9RVUVSWV9TVEVQX0RFRkFVTFQpICogMTAwMDtcbiAgICBjb25zdCB0YWdLZXlzQXJyYXkgPSB0YWdLZXlzLnNwbGl0KCcsJyk7XG5cbiAgICBjb25zdCBldmVudExpc3Q6IEFubm90YXRpb25FdmVudFtdID0gW107XG5cbiAgICBmb3IgKGNvbnN0IGZyYW1lIG9mIGZyYW1lcykge1xuICAgICAgY29uc3QgdGltZUZpZWxkID0gZnJhbWUuZmllbGRzWzBdO1xuICAgICAgY29uc3QgdmFsdWVGaWVsZCA9IGZyYW1lLmZpZWxkc1sxXTtcbiAgICAgIGNvbnN0IGxhYmVscyA9IHZhbHVlRmllbGQ/LmxhYmVscyB8fCB7fTtcblxuICAgICAgY29uc3QgdGFncyA9IE9iamVjdC5rZXlzKGxhYmVscylcbiAgICAgICAgLmZpbHRlcigobGFiZWwpID0+IHRhZ0tleXNBcnJheS5pbmNsdWRlcyhsYWJlbCkpXG4gICAgICAgIC5tYXAoKGxhYmVsKSA9PiBsYWJlbHNbbGFiZWxdKTtcblxuICAgICAgY29uc3QgdGltZVZhbHVlVHVwbGU6IEFycmF5PFtudW1iZXIsIG51bWJlcl0+ID0gW107XG5cbiAgICAgIGxldCBpZHggPSAwO1xuICAgICAgdmFsdWVGaWVsZC52YWx1ZXMudG9BcnJheSgpLmZvckVhY2goKHZhbHVlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgbGV0IHRpbWVTdGFtcFZhbHVlOiBudW1iZXI7XG4gICAgICAgIGxldCB2YWx1ZVZhbHVlOiBudW1iZXI7XG4gICAgICAgIGNvbnN0IHRpbWUgPSB0aW1lRmllbGQudmFsdWVzLmdldChpZHgpO1xuXG4gICAgICAgIC8vIElmIHdlIHdhbnQgdG8gdXNlIHZhbHVlIGFzIGEgdGltZSwgd2UgdXNlIHZhbHVlIGFzIHRpbWVTdGFtcFZhbHVlIGFuZCB2YWx1ZVZhbHVlIHdpbGwgYmUgMVxuICAgICAgICBpZiAob3B0aW9ucy5hbm5vdGF0aW9uLnVzZVZhbHVlRm9yVGltZSkge1xuICAgICAgICAgIHRpbWVTdGFtcFZhbHVlID0gTWF0aC5mbG9vcihwYXJzZUZsb2F0KHZhbHVlKSk7XG4gICAgICAgICAgdmFsdWVWYWx1ZSA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGltZVN0YW1wVmFsdWUgPSBNYXRoLmZsb29yKHBhcnNlRmxvYXQodGltZSkpO1xuICAgICAgICAgIHZhbHVlVmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlkeCsrO1xuICAgICAgICB0aW1lVmFsdWVUdXBsZS5wdXNoKFt0aW1lU3RhbXBWYWx1ZSwgdmFsdWVWYWx1ZV0pO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGFjdGl2ZVZhbHVlcyA9IHRpbWVWYWx1ZVR1cGxlLmZpbHRlcigodmFsdWUpID0+IHZhbHVlWzFdID49IDEpO1xuICAgICAgY29uc3QgYWN0aXZlVmFsdWVzVGltZXN0YW1wcyA9IGFjdGl2ZVZhbHVlcy5tYXAoKHZhbHVlKSA9PiB2YWx1ZVswXSk7XG5cbiAgICAgIC8vIEluc3RlYWQgb2YgY3JlYXRpbmcgc2luZ3VsYXIgYW5ub3RhdGlvbiBmb3IgZWFjaCBhY3RpdmUgZXZlbnQgd2UgZ3JvdXAgZXZlbnRzIGludG8gcmVnaW9uIGlmIHRoZXkgYXJlIGxlc3NcbiAgICAgIC8vIG9yIGVxdWFsIHRvIGBzdGVwYCBhcGFydC5cbiAgICAgIGxldCBsYXRlc3RFdmVudDogQW5ub3RhdGlvbkV2ZW50IHwgbnVsbCA9IG51bGw7XG5cbiAgICAgIGZvciAoY29uc3QgdGltZXN0YW1wIG9mIGFjdGl2ZVZhbHVlc1RpbWVzdGFtcHMpIHtcbiAgICAgICAgLy8gV2UgYWxyZWFkeSBoYXZlIGV2ZW50IGBvcGVuYCBhbmQgd2UgaGF2ZSBuZXcgZXZlbnQgdGhhdCBpcyBpbnNpZGUgdGhlIGBzdGVwYCBzbyB3ZSBqdXN0IHVwZGF0ZSB0aGUgZW5kLlxuICAgICAgICBpZiAobGF0ZXN0RXZlbnQgJiYgKGxhdGVzdEV2ZW50LnRpbWVFbmQgPz8gMCkgKyBzdGVwID49IHRpbWVzdGFtcCkge1xuICAgICAgICAgIGxhdGVzdEV2ZW50LnRpbWVFbmQgPSB0aW1lc3RhbXA7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFdmVudCBleGlzdHMgYnV0IG5ldyBvbmUgaXMgb3V0c2lkZSBvZiB0aGUgYHN0ZXBgIHNvIHdlIGFkZCBpdCB0byBldmVudExpc3QuXG4gICAgICAgIGlmIChsYXRlc3RFdmVudCkge1xuICAgICAgICAgIGV2ZW50TGlzdC5wdXNoKGxhdGVzdEV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIHN0YXJ0IGEgbmV3IHJlZ2lvbi5cbiAgICAgICAgbGF0ZXN0RXZlbnQgPSB7XG4gICAgICAgICAgdGltZTogdGltZXN0YW1wLFxuICAgICAgICAgIHRpbWVFbmQ6IHRpbWVzdGFtcCxcbiAgICAgICAgICBhbm5vdGF0aW9uLFxuICAgICAgICAgIHRpdGxlOiByZW5kZXJMZWdlbmRGb3JtYXQodGl0bGVGb3JtYXQsIGxhYmVscyksXG4gICAgICAgICAgdGFncyxcbiAgICAgICAgICB0ZXh0OiByZW5kZXJMZWdlbmRGb3JtYXQodGV4dEZvcm1hdCwgbGFiZWxzKSxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxhdGVzdEV2ZW50KSB7XG4gICAgICAgIC8vIEZpbmlzaCB1cCBsYXN0IHBvaW50IGlmIHdlIGhhdmUgb25lXG4gICAgICAgIGxhdGVzdEV2ZW50LnRpbWVFbmQgPSBhY3RpdmVWYWx1ZXNUaW1lc3RhbXBzW2FjdGl2ZVZhbHVlc1RpbWVzdGFtcHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGV2ZW50TGlzdC5wdXNoKGxhdGVzdEV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXZlbnRMaXN0O1xuICB9O1xuXG4gIGdldEV4ZW1wbGFycyhxdWVyeTogUHJvbVF1ZXJ5UmVxdWVzdCkge1xuICAgIGNvbnN0IHVybCA9ICcvYXBpL3YxL3F1ZXJ5X2V4ZW1wbGFycyc7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3Q8UHJvbURhdGFTdWNjZXNzUmVzcG9uc2U8UHJvbUV4ZW1wbGFyRGF0YT4+KFxuICAgICAgdXJsLFxuICAgICAgeyBxdWVyeTogcXVlcnkuZXhwciwgc3RhcnQ6IHF1ZXJ5LnN0YXJ0LnRvU3RyaW5nKCksIGVuZDogcXVlcnkuZW5kLnRvU3RyaW5nKCkgfSxcbiAgICAgIHsgcmVxdWVzdElkOiBxdWVyeS5yZXF1ZXN0SWQsIGhlYWRlcnM6IHF1ZXJ5LmhlYWRlcnMgfVxuICAgICk7XG4gIH1cblxuICBhc3luYyBnZXRTdWJ0aXRsZSgpOiBQcm9taXNlPEpTWC5FbGVtZW50IHwgbnVsbD4ge1xuICAgIGNvbnN0IGJ1aWxkSW5mbyA9IGF3YWl0IHRoaXMuZ2V0QnVpbGRJbmZvKCk7XG4gICAgcmV0dXJuIGJ1aWxkSW5mbyA/IHRoaXMuZ2V0QnVpbGRJbmZvTWVzc2FnZShidWlsZEluZm8pIDogbnVsbDtcbiAgfVxuXG4gIGFzeW5jIGdldFRhZ0tleXMob3B0aW9ucz86IGFueSkge1xuICAgIGlmIChvcHRpb25zPy5zZXJpZXMpIHtcbiAgICAgIC8vIEdldCB0YWdzIGZvciB0aGUgcHJvdmlkZWQgc2VyaWVzIG9ubHlcbiAgICAgIGNvbnN0IHNlcmllc0xhYmVsczogQXJyYXk8UmVjb3JkPHN0cmluZywgc3RyaW5nW10+PiA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICBvcHRpb25zLnNlcmllcy5tYXAoKHNlcmllczogc3RyaW5nKSA9PiB0aGlzLmxhbmd1YWdlUHJvdmlkZXIuZmV0Y2hTZXJpZXNMYWJlbHMoc2VyaWVzKSlcbiAgICAgICk7XG4gICAgICBjb25zdCB1bmlxdWVMYWJlbHMgPSBbLi4ubmV3IFNldCguLi5zZXJpZXNMYWJlbHMubWFwKCh2YWx1ZSkgPT4gT2JqZWN0LmtleXModmFsdWUpKSldO1xuICAgICAgcmV0dXJuIHVuaXF1ZUxhYmVscy5tYXAoKHZhbHVlOiBhbnkpID0+ICh7IHRleHQ6IHZhbHVlIH0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gR2V0IGFsbCB0YWdzXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLm1ldGFkYXRhUmVxdWVzdCgnL2FwaS92MS9sYWJlbHMnKTtcbiAgICAgIHJldHVybiByZXN1bHQ/LmRhdGE/LmRhdGE/Lm1hcCgodmFsdWU6IGFueSkgPT4gKHsgdGV4dDogdmFsdWUgfSkpID8/IFtdO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldFRhZ1ZhbHVlcyhvcHRpb25zOiB7IGtleT86IHN0cmluZyB9ID0ge30pIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLm1ldGFkYXRhUmVxdWVzdChgL2FwaS92MS9sYWJlbC8ke29wdGlvbnMua2V5fS92YWx1ZXNgKTtcbiAgICByZXR1cm4gcmVzdWx0Py5kYXRhPy5kYXRhPy5tYXAoKHZhbHVlOiBhbnkpID0+ICh7IHRleHQ6IHZhbHVlIH0pKSA/PyBbXTtcbiAgfVxuXG4gIGFzeW5jIGdldEJ1aWxkSW5mbygpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYnVpbGRJbmZvID0gYXdhaXQgZmV0Y2hEYXRhU291cmNlQnVpbGRJbmZvKHRoaXMpO1xuICAgICAgcmV0dXJuIGJ1aWxkSW5mbztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBicmVhayB0aGUgcmVzdCBvZiBmdW5jdGlvbmFsaXR5IGlmIGJ1aWxkIGluZm8gZG9lcyBub3Qgd29yayBjb3JyZWN0bHlcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgZ2V0QnVpbGRJbmZvTWVzc2FnZShidWlsZEluZm86IFByb21CdWlsZEluZm8pIHtcbiAgICBjb25zdCBlbmFibGVkID0gPEJhZGdlIGNvbG9yPVwiZ3JlZW5cIiBpY29uPVwiY2hlY2tcIiB0ZXh0PVwiUnVsZXIgQVBJIGVuYWJsZWRcIiAvPjtcbiAgICBjb25zdCBkaXNhYmxlZCA9IDxCYWRnZSBjb2xvcj1cIm9yYW5nZVwiIGljb249XCJleGNsYW1hdGlvbi10cmlhbmdsZVwiIHRleHQ9XCJSdWxlciBBUEkgbm90IGVuYWJsZWRcIiAvPjtcbiAgICBjb25zdCB1bnN1cHBvcnRlZCA9IChcbiAgICAgIDxUb29sdGlwXG4gICAgICAgIHBsYWNlbWVudD1cInRvcFwiXG4gICAgICAgIGNvbnRlbnQ9XCJQcm9tZXRoZXVzIGRvZXMgbm90IGFsbG93IGVkaXRpbmcgcnVsZXMsIGNvbm5lY3QgdG8gZWl0aGVyIGEgTWltaXIgb3IgQ29ydGV4IGRhdGFzb3VyY2UgdG8gbWFuYWdlIGFsZXJ0cyB2aWEgR3JhZmFuYS5cIlxuICAgICAgPlxuICAgICAgICA8ZGl2PlxuICAgICAgICAgIDxCYWRnZSBjb2xvcj1cInJlZFwiIGljb249XCJleGNsYW1hdGlvbi10cmlhbmdsZVwiIHRleHQ9XCJSdWxlciBBUEkgbm90IHN1cHBvcnRlZFwiIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9Ub29sdGlwPlxuICAgICk7XG5cbiAgICBjb25zdCBMT0dPUyA9IHtcbiAgICAgIFtQcm9tQXBwbGljYXRpb24uQ29ydGV4XTogJy9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL2ltZy9jb3J0ZXhfbG9nby5zdmcnLFxuICAgICAgW1Byb21BcHBsaWNhdGlvbi5NaW1pcl06ICcvcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9pbWcvbWltaXJfbG9nby5zdmcnLFxuICAgICAgW1Byb21BcHBsaWNhdGlvbi5Qcm9tZXRoZXVzXTogJy9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL2ltZy9wcm9tZXRoZXVzX2xvZ28uc3ZnJyxcbiAgICB9O1xuXG4gICAgY29uc3QgQ09MT1JTOiBSZWNvcmQ8UHJvbUFwcGxpY2F0aW9uLCBCYWRnZUNvbG9yPiA9IHtcbiAgICAgIFtQcm9tQXBwbGljYXRpb24uQ29ydGV4XTogJ2JsdWUnLFxuICAgICAgW1Byb21BcHBsaWNhdGlvbi5NaW1pcl06ICdvcmFuZ2UnLFxuICAgICAgW1Byb21BcHBsaWNhdGlvbi5Qcm9tZXRoZXVzXTogJ3JlZCcsXG4gICAgfTtcblxuICAgIC8vIHRoaXMgd2lsbCBpbmZvcm0gdGhlIHVzZXIgYWJvdXQgd2hhdCBcInN1YnR5cGVcIiB0aGUgZGF0YXNvdXJjZSBpczsgTWltaXIsIENvcnRleCBvciB2YW5pbGxhIFByb21ldGhldXNcbiAgICBjb25zdCBhcHBsaWNhdGlvblN1YlR5cGUgPSAoXG4gICAgICA8QmFkZ2VcbiAgICAgICAgdGV4dD17XG4gICAgICAgICAgPHNwYW4+XG4gICAgICAgICAgICA8aW1nXG4gICAgICAgICAgICAgIHN0eWxlPXt7IHdpZHRoOiAxNCwgaGVpZ2h0OiAxNCwgdmVydGljYWxBbGlnbjogJ3RleHQtYm90dG9tJyB9fVxuICAgICAgICAgICAgICBzcmM9e0xPR09TW2J1aWxkSW5mby5hcHBsaWNhdGlvbiA/PyBQcm9tQXBwbGljYXRpb24uUHJvbWV0aGV1c119XG4gICAgICAgICAgICAvPnsnICd9XG4gICAgICAgICAgICB7YnVpbGRJbmZvLmFwcGxpY2F0aW9ufVxuICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgfVxuICAgICAgICBjb2xvcj17Q09MT1JTW2J1aWxkSW5mby5hcHBsaWNhdGlvbiA/PyBQcm9tQXBwbGljYXRpb24uUHJvbWV0aGV1c119XG4gICAgICAvPlxuICAgICk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdlxuICAgICAgICBzdHlsZT17e1xuICAgICAgICAgIGRpc3BsYXk6ICdncmlkJyxcbiAgICAgICAgICBncmlkVGVtcGxhdGVDb2x1bW5zOiAnbWF4LWNvbnRlbnQgbWF4LWNvbnRlbnQnLFxuICAgICAgICAgIHJvd0dhcDogJzAuNXJlbScsXG4gICAgICAgICAgY29sdW1uR2FwOiAnMnJlbScsXG4gICAgICAgICAgbWFyZ2luVG9wOiAnMXJlbScsXG4gICAgICAgIH19XG4gICAgICA+XG4gICAgICAgIDxkaXY+VHlwZTwvZGl2PlxuICAgICAgICA8ZGl2PnthcHBsaWNhdGlvblN1YlR5cGV9PC9kaXY+XG4gICAgICAgIDw+XG4gICAgICAgICAgPGRpdj5SdWxlciBBUEk8L2Rpdj5cbiAgICAgICAgICB7LyogUHJvbWV0aGV1cyBkb2VzIG5vdCBoYXZlIGEgUnVsZXIgQVBJIOKAkyBzbyBzaG93IHRoYXQgaXQgaXMgbm90IHN1cHBvcnRlZCAqL31cbiAgICAgICAgICB7YnVpbGRJbmZvLmFwcGxpY2F0aW9uID09PSBQcm9tQXBwbGljYXRpb24uUHJvbWV0aGV1cyAmJiA8ZGl2Pnt1bnN1cHBvcnRlZH08L2Rpdj59XG4gICAgICAgICAge2J1aWxkSW5mby5hcHBsaWNhdGlvbiAhPT0gUHJvbUFwcGxpY2F0aW9uLlByb21ldGhldXMgJiYgKFxuICAgICAgICAgICAgPGRpdj57YnVpbGRJbmZvLmZlYXR1cmVzLnJ1bGVyQXBpRW5hYmxlZCA/IGVuYWJsZWQgOiBkaXNhYmxlZH08L2Rpdj5cbiAgICAgICAgICApfVxuICAgICAgICA8Lz5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICBhc3luYyB0ZXN0RGF0YXNvdXJjZSgpIHtcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICBjb25zdCByZXF1ZXN0OiBEYXRhUXVlcnlSZXF1ZXN0PFByb21RdWVyeT4gPSB7XG4gICAgICB0YXJnZXRzOiBbeyByZWZJZDogJ3Rlc3QnLCBleHByOiAnMSsxJywgaW5zdGFudDogdHJ1ZSB9XSxcbiAgICAgIHJlcXVlc3RJZDogYCR7dGhpcy5pZH0taGVhbHRoYCxcbiAgICAgIHNjb3BlZFZhcnM6IHt9LFxuICAgICAgZGFzaGJvYXJkSWQ6IDAsXG4gICAgICBwYW5lbElkOiAwLFxuICAgICAgaW50ZXJ2YWw6ICcxbScsXG4gICAgICBpbnRlcnZhbE1zOiA2MDAwMCxcbiAgICAgIG1heERhdGFQb2ludHM6IDEsXG4gICAgICByYW5nZToge1xuICAgICAgICBmcm9tOiBkYXRlVGltZShub3cgLSAxMDAwKSxcbiAgICAgICAgdG86IGRhdGVUaW1lKG5vdyksXG4gICAgICB9LFxuICAgIH0gYXMgRGF0YVF1ZXJ5UmVxdWVzdDxQcm9tUXVlcnk+O1xuXG4gICAgY29uc3QgYnVpbGRJbmZvID0gYXdhaXQgdGhpcy5nZXRCdWlsZEluZm8oKTtcblxuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKHRoaXMucXVlcnkocmVxdWVzdCkpXG4gICAgICAudGhlbigocmVzOiBEYXRhUXVlcnlSZXNwb25zZSkgPT4ge1xuICAgICAgICBpZiAoIXJlcyB8fCAhcmVzLmRhdGEgfHwgcmVzLnN0YXRlICE9PSBMb2FkaW5nU3RhdGUuRG9uZSkge1xuICAgICAgICAgIHJldHVybiB7IHN0YXR1czogJ2Vycm9yJywgbWVzc2FnZTogYEVycm9yIHJlYWRpbmcgUHJvbWV0aGV1czogJHtyZXM/LmVycm9yPy5tZXNzYWdlfWAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdHVzOiAnc3VjY2VzcycsXG4gICAgICAgICAgICBtZXNzYWdlOiAnRGF0YSBzb3VyY2UgaXMgd29ya2luZycsXG4gICAgICAgICAgICBkZXRhaWxzOiBidWlsZEluZm8gJiYge1xuICAgICAgICAgICAgICB2ZXJib3NlTWVzc2FnZTogdGhpcy5nZXRCdWlsZEluZm9NZXNzYWdlKGJ1aWxkSW5mbyksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycjogYW55KSA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1Byb21ldGhldXMgRXJyb3InLCBlcnIpO1xuICAgICAgICByZXR1cm4geyBzdGF0dXM6ICdlcnJvcicsIG1lc3NhZ2U6IGVyci5tZXNzYWdlIH07XG4gICAgICB9KTtcbiAgfVxuXG4gIGludGVycG9sYXRlVmFyaWFibGVzSW5RdWVyaWVzKHF1ZXJpZXM6IFByb21RdWVyeVtdLCBzY29wZWRWYXJzOiBTY29wZWRWYXJzKTogUHJvbVF1ZXJ5W10ge1xuICAgIGxldCBleHBhbmRlZFF1ZXJpZXMgPSBxdWVyaWVzO1xuICAgIGlmIChxdWVyaWVzICYmIHF1ZXJpZXMubGVuZ3RoKSB7XG4gICAgICBleHBhbmRlZFF1ZXJpZXMgPSBxdWVyaWVzLm1hcCgocXVlcnkpID0+IHtcbiAgICAgICAgY29uc3QgZXhwYW5kZWRRdWVyeSA9IHtcbiAgICAgICAgICAuLi5xdWVyeSxcbiAgICAgICAgICBkYXRhc291cmNlOiB0aGlzLmdldFJlZigpLFxuICAgICAgICAgIGV4cHI6IHRoaXMudGVtcGxhdGVTcnYucmVwbGFjZShxdWVyeS5leHByLCBzY29wZWRWYXJzLCB0aGlzLmludGVycG9sYXRlUXVlcnlFeHByKSxcbiAgICAgICAgICBpbnRlcnZhbDogdGhpcy50ZW1wbGF0ZVNydi5yZXBsYWNlKHF1ZXJ5LmludGVydmFsLCBzY29wZWRWYXJzKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGV4cGFuZGVkUXVlcnk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cGFuZGVkUXVlcmllcztcbiAgfVxuXG4gIGdldFF1ZXJ5SGludHMocXVlcnk6IFByb21RdWVyeSwgcmVzdWx0OiBhbnlbXSkge1xuICAgIHJldHVybiBnZXRRdWVyeUhpbnRzKHF1ZXJ5LmV4cHIgPz8gJycsIHJlc3VsdCwgdGhpcyk7XG4gIH1cblxuICBnZXRJbml0SGludHMoKSB7XG4gICAgcmV0dXJuIGdldEluaXRIaW50cyh0aGlzKTtcbiAgfVxuXG4gIGFzeW5jIGxvYWRSdWxlcygpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5tZXRhZGF0YVJlcXVlc3QoJy9hcGkvdjEvcnVsZXMnKTtcbiAgICAgIGNvbnN0IGdyb3VwcyA9IHJlcy5kYXRhPy5kYXRhPy5ncm91cHM7XG5cbiAgICAgIGlmIChncm91cHMpIHtcbiAgICAgICAgdGhpcy5ydWxlTWFwcGluZ3MgPSBleHRyYWN0UnVsZU1hcHBpbmdGcm9tR3JvdXBzKGdyb3Vwcyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5sb2coJ1J1bGVzIEFQSSBpcyBleHBlcmltZW50YWwuIElnbm9yZSBuZXh0IGVycm9yLicpO1xuICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBhcmVFeGVtcGxhcnNBdmFpbGFibGUoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMubWV0YWRhdGFSZXF1ZXN0KCcvYXBpL3YxL3F1ZXJ5X2V4ZW1wbGFycycsIHsgcXVlcnk6ICd0ZXN0JyB9KTtcbiAgICAgIGlmIChyZXMuZGF0YS5zdGF0dXMgPT09ICdzdWNjZXNzJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBtb2RpZnlRdWVyeShxdWVyeTogUHJvbVF1ZXJ5LCBhY3Rpb246IGFueSk6IFByb21RdWVyeSB7XG4gICAgbGV0IGV4cHJlc3Npb24gPSBxdWVyeS5leHByID8/ICcnO1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgIGNhc2UgJ0FERF9GSUxURVInOiB7XG4gICAgICAgIGV4cHJlc3Npb24gPSBhZGRMYWJlbFRvUXVlcnkoZXhwcmVzc2lvbiwgYWN0aW9uLmtleSwgYWN0aW9uLnZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICdBRERfRklMVEVSX09VVCc6IHtcbiAgICAgICAgZXhwcmVzc2lvbiA9IGFkZExhYmVsVG9RdWVyeShleHByZXNzaW9uLCBhY3Rpb24ua2V5LCBhY3Rpb24udmFsdWUsICchPScpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ0FERF9ISVNUT0dSQU1fUVVBTlRJTEUnOiB7XG4gICAgICAgIGV4cHJlc3Npb24gPSBgaGlzdG9ncmFtX3F1YW50aWxlKDAuOTUsIHN1bShyYXRlKCR7ZXhwcmVzc2lvbn1bJF9fcmF0ZV9pbnRlcnZhbF0pKSBieSAobGUpKWA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnQUREX1JBVEUnOiB7XG4gICAgICAgIGV4cHJlc3Npb24gPSBgcmF0ZSgke2V4cHJlc3Npb259WyRfX3JhdGVfaW50ZXJ2YWxdKWA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnQUREX1NVTSc6IHtcbiAgICAgICAgZXhwcmVzc2lvbiA9IGBzdW0oJHtleHByZXNzaW9uLnRyaW0oKX0pIGJ5ICgkMSlgO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ0VYUEFORF9SVUxFUyc6IHtcbiAgICAgICAgaWYgKGFjdGlvbi5tYXBwaW5nKSB7XG4gICAgICAgICAgZXhwcmVzc2lvbiA9IGV4cGFuZFJlY29yZGluZ1J1bGVzKGV4cHJlc3Npb24sIGFjdGlvbi5tYXBwaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4geyAuLi5xdWVyeSwgZXhwcjogZXhwcmVzc2lvbiB9O1xuICB9XG5cbiAgZ2V0UHJvbWV0aGV1c1RpbWUoZGF0ZTogc3RyaW5nIHwgRGF0ZVRpbWUsIHJvdW5kVXA6IGJvb2xlYW4pIHtcbiAgICBpZiAodHlwZW9mIGRhdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBkYXRlID0gZGF0ZU1hdGgucGFyc2UoZGF0ZSwgcm91bmRVcCkhO1xuICAgIH1cblxuICAgIHJldHVybiBNYXRoLmNlaWwoZGF0ZS52YWx1ZU9mKCkgLyAxMDAwKTtcbiAgfVxuXG4gIGdldFRpbWVSYW5nZVBhcmFtcygpOiB7IHN0YXJ0OiBzdHJpbmc7IGVuZDogc3RyaW5nIH0ge1xuICAgIGNvbnN0IHJhbmdlID0gdGhpcy50aW1lU3J2LnRpbWVSYW5nZSgpO1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogdGhpcy5nZXRQcm9tZXRoZXVzVGltZShyYW5nZS5mcm9tLCBmYWxzZSkudG9TdHJpbmcoKSxcbiAgICAgIGVuZDogdGhpcy5nZXRQcm9tZXRoZXVzVGltZShyYW5nZS50bywgdHJ1ZSkudG9TdHJpbmcoKSxcbiAgICB9O1xuICB9XG5cbiAgZ2V0T3JpZ2luYWxNZXRyaWNOYW1lKGxhYmVsRGF0YTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSkge1xuICAgIHJldHVybiBnZXRPcmlnaW5hbE1ldHJpY05hbWUobGFiZWxEYXRhKTtcbiAgfVxuXG4gIGVuaGFuY2VFeHByV2l0aEFkSG9jRmlsdGVycyhleHByOiBzdHJpbmcpIHtcbiAgICBjb25zdCBhZGhvY0ZpbHRlcnMgPSB0aGlzLnRlbXBsYXRlU3J2LmdldEFkaG9jRmlsdGVycyh0aGlzLm5hbWUpO1xuXG4gICAgY29uc3QgZmluYWxRdWVyeSA9IGFkaG9jRmlsdGVycy5yZWR1Y2UoKGFjYzogc3RyaW5nLCBmaWx0ZXI6IHsga2V5PzogYW55OyBvcGVyYXRvcj86IGFueTsgdmFsdWU/OiBhbnkgfSkgPT4ge1xuICAgICAgY29uc3QgeyBrZXksIG9wZXJhdG9yIH0gPSBmaWx0ZXI7XG4gICAgICBsZXQgeyB2YWx1ZSB9ID0gZmlsdGVyO1xuICAgICAgaWYgKG9wZXJhdG9yID09PSAnPX4nIHx8IG9wZXJhdG9yID09PSAnIX4nKSB7XG4gICAgICAgIHZhbHVlID0gcHJvbWV0aGV1c1JlZ3VsYXJFc2NhcGUodmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFkZExhYmVsVG9RdWVyeShhY2MsIGtleSwgdmFsdWUsIG9wZXJhdG9yKTtcbiAgICB9LCBleHByKTtcbiAgICByZXR1cm4gZmluYWxRdWVyeTtcbiAgfVxuXG4gIC8vIFVzZWQgd2hlbiBydW5uaW5nIHF1ZXJpZXMgdHJvdWdoIGJhY2tlbmRcbiAgZmlsdGVyUXVlcnkocXVlcnk6IFByb21RdWVyeSk6IGJvb2xlYW4ge1xuICAgIGlmIChxdWVyeS5oaWRlIHx8ICFxdWVyeS5leHByKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gVXNlZCB3aGVuIHJ1bm5pbmcgcXVlcmllcyB0cm91Z2ggYmFja2VuZFxuICBhcHBseVRlbXBsYXRlVmFyaWFibGVzKHRhcmdldDogUHJvbVF1ZXJ5LCBzY29wZWRWYXJzOiBTY29wZWRWYXJzKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gICAgY29uc3QgdmFyaWFibGVzID0gY2xvbmVEZWVwKHNjb3BlZFZhcnMpO1xuXG4gICAgLy8gV2Ugd2FudCB0byBpbnRlcnBvbGF0ZSB0aGVzZSB2YXJpYWJsZXMgb24gYmFja2VuZFxuICAgIGRlbGV0ZSB2YXJpYWJsZXMuX19pbnRlcnZhbDtcbiAgICBkZWxldGUgdmFyaWFibGVzLl9faW50ZXJ2YWxfbXM7XG5cbiAgICAvL0FkZCBhZCBob2MgZmlsdGVyc1xuICAgIGNvbnN0IGV4cHIgPSB0aGlzLmVuaGFuY2VFeHByV2l0aEFkSG9jRmlsdGVycyh0YXJnZXQuZXhwcik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4udGFyZ2V0LFxuICAgICAgbGVnZW5kRm9ybWF0OiB0aGlzLnRlbXBsYXRlU3J2LnJlcGxhY2UodGFyZ2V0LmxlZ2VuZEZvcm1hdCwgdmFyaWFibGVzKSxcbiAgICAgIGV4cHI6IHRoaXMudGVtcGxhdGVTcnYucmVwbGFjZShleHByLCB2YXJpYWJsZXMsIHRoaXMuaW50ZXJwb2xhdGVRdWVyeUV4cHIpLFxuICAgICAgaW50ZXJ2YWw6IHRoaXMudGVtcGxhdGVTcnYucmVwbGFjZSh0YXJnZXQuaW50ZXJ2YWwsIHZhcmlhYmxlcyksXG4gICAgfTtcbiAgfVxuXG4gIGdldFZhcmlhYmxlcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMudGVtcGxhdGVTcnYuZ2V0VmFyaWFibGVzKCkubWFwKCh2KSA9PiBgJCR7di5uYW1lfWApO1xuICB9XG5cbiAgaW50ZXJwb2xhdGVTdHJpbmcoc3RyaW5nOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy50ZW1wbGF0ZVNydi5yZXBsYWNlKHN0cmluZywgdW5kZWZpbmVkLCB0aGlzLmludGVycG9sYXRlUXVlcnlFeHByKTtcbiAgfVxufVxuXG4vKipcbiAqIEFsaWduIHF1ZXJ5IHJhbmdlIHRvIHN0ZXAuXG4gKiBSb3VuZHMgc3RhcnQgYW5kIGVuZCBkb3duIHRvIGEgbXVsdGlwbGUgb2Ygc3RlcC5cbiAqIEBwYXJhbSBzdGFydCBUaW1lc3RhbXAgbWFya2luZyB0aGUgYmVnaW5uaW5nIG9mIHRoZSByYW5nZS5cbiAqIEBwYXJhbSBlbmQgVGltZXN0YW1wIG1hcmtpbmcgdGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gKiBAcGFyYW0gc3RlcCBJbnRlcnZhbCB0byBhbGlnbiBzdGFydCBhbmQgZW5kIHdpdGguXG4gKiBAcGFyYW0gdXRjT2Zmc2V0U2VjIE51bWJlciBvZiBzZWNvbmRzIGN1cnJlbnQgdGltZXpvbmUgaXMgb2Zmc2V0IGZyb20gVVRDXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbGlnblJhbmdlKFxuICBzdGFydDogbnVtYmVyLFxuICBlbmQ6IG51bWJlcixcbiAgc3RlcDogbnVtYmVyLFxuICB1dGNPZmZzZXRTZWM6IG51bWJlclxuKTogeyBlbmQ6IG51bWJlcjsgc3RhcnQ6IG51bWJlciB9IHtcbiAgY29uc3QgYWxpZ25lZEVuZCA9IE1hdGguZmxvb3IoKGVuZCArIHV0Y09mZnNldFNlYykgLyBzdGVwKSAqIHN0ZXAgLSB1dGNPZmZzZXRTZWM7XG4gIGNvbnN0IGFsaWduZWRTdGFydCA9IE1hdGguZmxvb3IoKHN0YXJ0ICsgdXRjT2Zmc2V0U2VjKSAvIHN0ZXApICogc3RlcCAtIHV0Y09mZnNldFNlYztcbiAgcmV0dXJuIHtcbiAgICBlbmQ6IGFsaWduZWRFbmQsXG4gICAgc3RhcnQ6IGFsaWduZWRTdGFydCxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RSdWxlTWFwcGluZ0Zyb21Hcm91cHMoZ3JvdXBzOiBhbnlbXSkge1xuICByZXR1cm4gZ3JvdXBzLnJlZHVjZShcbiAgICAobWFwcGluZywgZ3JvdXApID0+XG4gICAgICBncm91cC5ydWxlc1xuICAgICAgICAuZmlsdGVyKChydWxlOiBhbnkpID0+IHJ1bGUudHlwZSA9PT0gJ3JlY29yZGluZycpXG4gICAgICAgIC5yZWR1Y2UoXG4gICAgICAgICAgKGFjYzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSwgcnVsZTogYW55KSA9PiAoe1xuICAgICAgICAgICAgLi4uYWNjLFxuICAgICAgICAgICAgW3J1bGUubmFtZV06IHJ1bGUucXVlcnksXG4gICAgICAgICAgfSksXG4gICAgICAgICAgbWFwcGluZ1xuICAgICAgICApLFxuICAgIHt9XG4gICk7XG59XG5cbi8vIE5PVEU6IHRoZXNlIHR3byBmdW5jdGlvbnMgYXJlIHZlcnkgc2ltaWxhciB0byB0aGUgZXNjYXBlTGFiZWxWYWx1ZUluKiBmdW5jdGlvbnNcbi8vIGluIGxhbmd1YWdlX3V0aWxzLnRzLCBidXQgdGhleSBhcmUgbm90IGV4YWN0bHkgdGhlIHNhbWUgYWxnb3JpdGhtLCBhbmQgd2UgZm91bmRcbi8vIG5vIHdheSB0byByZXVzZSBvbmUgaW4gdGhlIGFub3RoZXIgb3IgdmljZSB2ZXJzYS5cbmV4cG9ydCBmdW5jdGlvbiBwcm9tZXRoZXVzUmVndWxhckVzY2FwZSh2YWx1ZTogYW55KSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gdmFsdWUucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKS5yZXBsYWNlKC8nL2csIFwiXFxcXFxcXFwnXCIpIDogdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9tZXRoZXVzU3BlY2lhbFJlZ2V4RXNjYXBlKHZhbHVlOiBhbnkpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZS5yZXBsYWNlKC9cXFxcL2csICdcXFxcXFxcXFxcXFxcXFxcJykucmVwbGFjZSgvWyReKnt9XFxbXFxdXFwnKz8uKCl8XS9nLCAnXFxcXFxcXFwkJicpIDogdmFsdWU7XG59XG4iLCJpbXBvcnQgeyBvbmNlLCBjaGFpbiwgZGlmZmVyZW5jZSB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgTFJVIGZyb20gJ2xydS1jYWNoZSc7XG5pbXBvcnQgUHJpc20gZnJvbSAncHJpc21qcyc7XG5pbXBvcnQgeyBWYWx1ZSB9IGZyb20gJ3NsYXRlJztcblxuaW1wb3J0IHtcbiAgQWJzdHJhY3RMYWJlbE1hdGNoZXIsXG4gIEFic3RyYWN0TGFiZWxPcGVyYXRvcixcbiAgQWJzdHJhY3RRdWVyeSxcbiAgZGF0ZVRpbWUsXG4gIEhpc3RvcnlJdGVtLFxuICBMYW5ndWFnZVByb3ZpZGVyLFxufSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IENvbXBsZXRpb25JdGVtLCBDb21wbGV0aW9uSXRlbUdyb3VwLCBTZWFyY2hGdW5jdGlvblR5cGUsIFR5cGVhaGVhZElucHV0LCBUeXBlYWhlYWRPdXRwdXQgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5cbmltcG9ydCB7IFByb21ldGhldXNEYXRhc291cmNlIH0gZnJvbSAnLi9kYXRhc291cmNlJztcbmltcG9ydCB7XG4gIGFkZExpbWl0SW5mbyxcbiAgZXh0cmFjdExhYmVsTWF0Y2hlcnMsXG4gIGZpeFN1bW1hcmllc01ldGFkYXRhLFxuICBwYXJzZVNlbGVjdG9yLFxuICBwcm9jZXNzSGlzdG9ncmFtTWV0cmljcyxcbiAgcHJvY2Vzc0xhYmVscyxcbiAgcm91bmRTZWNUb01pbixcbiAgdG9Qcm9tTGlrZVF1ZXJ5LFxufSBmcm9tICcuL2xhbmd1YWdlX3V0aWxzJztcbmltcG9ydCBQcm9tcWxTeW50YXgsIHsgRlVOQ1RJT05TLCBSQVRFX1JBTkdFUyB9IGZyb20gJy4vcHJvbXFsJztcbmltcG9ydCB7IFByb21NZXRyaWNzTWV0YWRhdGEsIFByb21RdWVyeSB9IGZyb20gJy4vdHlwZXMnO1xuXG5jb25zdCBERUZBVUxUX0tFWVMgPSBbJ2pvYicsICdpbnN0YW5jZSddO1xuY29uc3QgRU1QVFlfU0VMRUNUT1IgPSAne30nO1xuY29uc3QgSElTVE9SWV9JVEVNX0NPVU5UID0gNTtcbmNvbnN0IEhJU1RPUllfQ09VTlRfQ1VUT0ZGID0gMTAwMCAqIDYwICogNjAgKiAyNDsgLy8gMjRoXG4vLyBNYXggbnVtYmVyIG9mIGl0ZW1zIChtZXRyaWNzLCBsYWJlbHMsIHZhbHVlcykgdGhhdCB3ZSBkaXNwbGF5IGFzIHN1Z2dlc3Rpb25zLiBQcmV2ZW50cyBmcm9tIHJ1bm5pbmcgb3V0IG9mIG1lbW9yeS5cbmV4cG9ydCBjb25zdCBTVUdHRVNUSU9OU19MSU1JVCA9IDEwMDAwO1xuXG5jb25zdCB3cmFwTGFiZWwgPSAobGFiZWw6IHN0cmluZyk6IENvbXBsZXRpb25JdGVtID0+ICh7IGxhYmVsIH0pO1xuXG5jb25zdCBzZXRGdW5jdGlvbktpbmQgPSAoc3VnZ2VzdGlvbjogQ29tcGxldGlvbkl0ZW0pOiBDb21wbGV0aW9uSXRlbSA9PiB7XG4gIHN1Z2dlc3Rpb24ua2luZCA9ICdmdW5jdGlvbic7XG4gIHJldHVybiBzdWdnZXN0aW9uO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEhpc3RvcnlNZXRhZGF0YShpdGVtOiBDb21wbGV0aW9uSXRlbSwgaGlzdG9yeTogYW55W10pOiBDb21wbGV0aW9uSXRlbSB7XG4gIGNvbnN0IGN1dG9mZlRzID0gRGF0ZS5ub3coKSAtIEhJU1RPUllfQ09VTlRfQ1VUT0ZGO1xuICBjb25zdCBoaXN0b3J5Rm9ySXRlbSA9IGhpc3RvcnkuZmlsdGVyKChoKSA9PiBoLnRzID4gY3V0b2ZmVHMgJiYgaC5xdWVyeSA9PT0gaXRlbS5sYWJlbCk7XG4gIGNvbnN0IGNvdW50ID0gaGlzdG9yeUZvckl0ZW0ubGVuZ3RoO1xuICBjb25zdCByZWNlbnQgPSBoaXN0b3J5Rm9ySXRlbVswXTtcbiAgbGV0IGhpbnQgPSBgUXVlcmllZCAke2NvdW50fSB0aW1lcyBpbiB0aGUgbGFzdCAyNGguYDtcblxuICBpZiAocmVjZW50KSB7XG4gICAgY29uc3QgbGFzdFF1ZXJpZWQgPSBkYXRlVGltZShyZWNlbnQudHMpLmZyb21Ob3coKTtcbiAgICBoaW50ID0gYCR7aGludH0gTGFzdCBxdWVyaWVkICR7bGFzdFF1ZXJpZWR9LmA7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC4uLml0ZW0sXG4gICAgZG9jdW1lbnRhdGlvbjogaGludCxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYWRkTWV0cmljc01ldGFkYXRhKG1ldHJpYzogc3RyaW5nLCBtZXRhZGF0YT86IFByb21NZXRyaWNzTWV0YWRhdGEpOiBDb21wbGV0aW9uSXRlbSB7XG4gIGNvbnN0IGl0ZW06IENvbXBsZXRpb25JdGVtID0geyBsYWJlbDogbWV0cmljIH07XG4gIGlmIChtZXRhZGF0YSAmJiBtZXRhZGF0YVttZXRyaWNdKSB7XG4gICAgaXRlbS5kb2N1bWVudGF0aW9uID0gZ2V0TWV0YWRhdGFTdHJpbmcobWV0cmljLCBtZXRhZGF0YSk7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRNZXRhZGF0YVN0cmluZyhtZXRyaWM6IHN0cmluZywgbWV0YWRhdGE6IFByb21NZXRyaWNzTWV0YWRhdGEpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICBpZiAoIW1ldGFkYXRhW21ldHJpY10pIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGNvbnN0IHsgdHlwZSwgaGVscCB9ID0gbWV0YWRhdGFbbWV0cmljXTtcbiAgcmV0dXJuIGAke3R5cGUudG9VcHBlckNhc2UoKX06ICR7aGVscH1gO1xufVxuXG5jb25zdCBQUkVGSVhfREVMSU1JVEVSX1JFR0VYID1cbiAgLyg9XCJ8IT1cInw9flwifCF+XCJ8XFx7fFxcW3xcXCh8XFwrfC18XFwvfFxcKnwlfFxcXnxcXGJhbmRcXGJ8XFxib3JcXGJ8XFxidW5sZXNzXFxifD09fD49fCE9fDw9fD58PHw9fH58LCkvO1xuXG5pbnRlcmZhY2UgQXV0b2NvbXBsZXRlQ29udGV4dCB7XG4gIGhpc3Rvcnk/OiBBcnJheTxIaXN0b3J5SXRlbTxQcm9tUXVlcnk+Pjtcbn1cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByb21RbExhbmd1YWdlUHJvdmlkZXIgZXh0ZW5kcyBMYW5ndWFnZVByb3ZpZGVyIHtcbiAgaGlzdG9ncmFtTWV0cmljczogc3RyaW5nW107XG4gIHRpbWVSYW5nZT86IHsgc3RhcnQ6IG51bWJlcjsgZW5kOiBudW1iZXIgfTtcbiAgbWV0cmljczogc3RyaW5nW107XG4gIG1ldHJpY3NNZXRhZGF0YT86IFByb21NZXRyaWNzTWV0YWRhdGE7XG4gIGRlY2xhcmUgc3RhcnRUYXNrOiBQcm9taXNlPGFueT47XG4gIGRhdGFzb3VyY2U6IFByb21ldGhldXNEYXRhc291cmNlO1xuICBsYWJlbEtleXM6IHN0cmluZ1tdID0gW107XG4gIGRlY2xhcmUgbGFiZWxGZXRjaFRzOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqICBDYWNoZSBmb3IgbGFiZWxzIG9mIHNlcmllcy4gVGhpcyBpcyBiaXQgc2ltcGxpc3RpYyBpbiB0aGUgc2Vuc2UgdGhhdCBpdCBqdXN0IGNvdW50cyByZXNwb25zZXMgZWFjaCBhcyBhIDEgYW5kIGRvZXNcbiAgICogIG5vdCBhY2NvdW50IGZvciBkaWZmZXJlbnQgc2l6ZSBvZiBhIHJlc3BvbnNlLiBJZiB0aGF0IGlzIG5lZWRlZCBhIGBsZW5ndGhgIGZ1bmN0aW9uIGNhbiBiZSBhZGRlZCBpbiB0aGUgb3B0aW9ucy5cbiAgICogIDEwIGFzIGEgbWF4IHNpemUgaXMgdG90YWxseSBhcmJpdHJhcnkgcmlnaHQgbm93LlxuICAgKi9cbiAgcHJpdmF0ZSBsYWJlbHNDYWNoZSA9IG5ldyBMUlU8c3RyaW5nLCBSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT4+KHsgbWF4OiAxMCB9KTtcblxuICBjb25zdHJ1Y3RvcihkYXRhc291cmNlOiBQcm9tZXRoZXVzRGF0YXNvdXJjZSwgaW5pdGlhbFZhbHVlcz86IFBhcnRpYWw8UHJvbVFsTGFuZ3VhZ2VQcm92aWRlcj4pIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5kYXRhc291cmNlID0gZGF0YXNvdXJjZTtcbiAgICB0aGlzLmhpc3RvZ3JhbU1ldHJpY3MgPSBbXTtcbiAgICB0aGlzLnRpbWVSYW5nZSA9IHsgc3RhcnQ6IDAsIGVuZDogMCB9O1xuICAgIHRoaXMubWV0cmljcyA9IFtdO1xuXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBpbml0aWFsVmFsdWVzKTtcbiAgfVxuXG4gIC8vIFN0cmlwIHN5bnRheCBjaGFycyBzbyB0aGF0IHR5cGVhaGVhZCBzdWdnZXN0aW9ucyBjYW4gd29yayBvbiBjbGVhbiBpbnB1dHNcbiAgY2xlYW5UZXh0KHM6IHN0cmluZykge1xuICAgIGNvbnN0IHBhcnRzID0gcy5zcGxpdChQUkVGSVhfREVMSU1JVEVSX1JFR0VYKTtcbiAgICBjb25zdCBsYXN0ID0gcGFydHMucG9wKCkhO1xuICAgIHJldHVybiBsYXN0LnRyaW1MZWZ0KCkucmVwbGFjZSgvXCIkLywgJycpLnJlcGxhY2UoL15cIi8sICcnKTtcbiAgfVxuXG4gIGdldCBzeW50YXgoKSB7XG4gICAgcmV0dXJuIFByb21xbFN5bnRheDtcbiAgfVxuXG4gIHJlcXVlc3QgPSBhc3luYyAodXJsOiBzdHJpbmcsIGRlZmF1bHRWYWx1ZTogYW55LCBwYXJhbXMgPSB7fSk6IFByb21pc2U8YW55PiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZGF0YXNvdXJjZS5tZXRhZGF0YVJlcXVlc3QodXJsLCBwYXJhbXMpO1xuICAgICAgcmV0dXJuIHJlcy5kYXRhLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gIH07XG5cbiAgc3RhcnQgPSBhc3luYyAoKTogUHJvbWlzZTxhbnlbXT4gPT4ge1xuICAgIGlmICh0aGlzLmRhdGFzb3VyY2UubG9va3Vwc0Rpc2FibGVkKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgLy8gVE9ETyAjMzM5NzY6IG1ha2UgdGhvc2UgcmVxdWVzdHMgcGFyYWxsZWxcbiAgICBhd2FpdCB0aGlzLmZldGNoTGFiZWxzKCk7XG4gICAgdGhpcy5tZXRyaWNzID0gKGF3YWl0IHRoaXMuZmV0Y2hMYWJlbFZhbHVlcygnX19uYW1lX18nKSkgfHwgW107XG4gICAgYXdhaXQgdGhpcy5sb2FkTWV0cmljc01ldGFkYXRhKCk7XG4gICAgdGhpcy5oaXN0b2dyYW1NZXRyaWNzID0gcHJvY2Vzc0hpc3RvZ3JhbU1ldHJpY3ModGhpcy5tZXRyaWNzKS5zb3J0KCk7XG4gICAgcmV0dXJuIFtdO1xuICB9O1xuXG4gIGFzeW5jIGxvYWRNZXRyaWNzTWV0YWRhdGEoKSB7XG4gICAgdGhpcy5tZXRyaWNzTWV0YWRhdGEgPSBmaXhTdW1tYXJpZXNNZXRhZGF0YShhd2FpdCB0aGlzLnJlcXVlc3QoJy9hcGkvdjEvbWV0YWRhdGEnLCB7fSkpO1xuICB9XG5cbiAgZ2V0TGFiZWxLZXlzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5sYWJlbEtleXM7XG4gIH1cblxuICBwcm92aWRlQ29tcGxldGlvbkl0ZW1zID0gYXN5bmMgKFxuICAgIHsgcHJlZml4LCB0ZXh0LCB2YWx1ZSwgbGFiZWxLZXksIHdyYXBwZXJDbGFzc2VzIH06IFR5cGVhaGVhZElucHV0LFxuICAgIGNvbnRleHQ6IEF1dG9jb21wbGV0ZUNvbnRleHQgPSB7fVxuICApOiBQcm9taXNlPFR5cGVhaGVhZE91dHB1dD4gPT4ge1xuICAgIGNvbnN0IGVtcHR5UmVzdWx0OiBUeXBlYWhlYWRPdXRwdXQgPSB7IHN1Z2dlc3Rpb25zOiBbXSB9O1xuXG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgcmV0dXJuIGVtcHR5UmVzdWx0O1xuICAgIH1cblxuICAgIC8vIExvY2FsIHRleHQgcHJvcGVydGllc1xuICAgIGNvbnN0IGVtcHR5ID0gdmFsdWUuZG9jdW1lbnQudGV4dC5sZW5ndGggPT09IDA7XG4gICAgY29uc3Qgc2VsZWN0ZWRMaW5lcyA9IHZhbHVlLmRvY3VtZW50LmdldFRleHRzQXRSYW5nZSh2YWx1ZS5zZWxlY3Rpb24pO1xuICAgIGNvbnN0IGN1cnJlbnRMaW5lID0gc2VsZWN0ZWRMaW5lcy5zaXplID09PSAxID8gc2VsZWN0ZWRMaW5lcy5maXJzdCgpLmdldFRleHQoKSA6IG51bGw7XG5cbiAgICBjb25zdCBuZXh0Q2hhcmFjdGVyID0gY3VycmVudExpbmUgPyBjdXJyZW50TGluZVt2YWx1ZS5zZWxlY3Rpb24uYW5jaG9yLm9mZnNldF0gOiBudWxsO1xuXG4gICAgLy8gU3ludGF4IHNwYW5zIGhhdmUgMyBjbGFzc2VzIGJ5IGRlZmF1bHQuIE1vcmUgaW5kaWNhdGUgYSByZWNvZ25pemVkIHRva2VuXG4gICAgY29uc3QgdG9rZW5SZWNvZ25pemVkID0gd3JhcHBlckNsYXNzZXMubGVuZ3RoID4gMztcbiAgICAvLyBOb24tZW1wdHkgcHJlZml4LCBidXQgbm90IGluc2lkZSBrbm93biB0b2tlblxuICAgIGNvbnN0IHByZWZpeFVucmVjb2duaXplZCA9IHByZWZpeCAmJiAhdG9rZW5SZWNvZ25pemVkO1xuXG4gICAgLy8gUHJldmVudCBzdWdnZXN0aW9ucyBpbiBgZnVuY3Rpb24ofHN1ZmZpeClgXG4gICAgY29uc3Qgbm9TdWZmaXggPSAhbmV4dENoYXJhY3RlciB8fCBuZXh0Q2hhcmFjdGVyID09PSAnKSc7XG5cbiAgICAvLyBQcmVmaXggaXMgc2FmZSBpZiBpdCBkb2VzIG5vdCBpbW1lZGlhdGVseSBmb2xsb3cgYSBjb21wbGV0ZSBleHByZXNzaW9uIGFuZCBoYXMgbm8gdGV4dCBhZnRlciBpdFxuICAgIGNvbnN0IHNhZmVQcmVmaXggPSBwcmVmaXggJiYgIXRleHQubWF0Y2goL15bXFxdfSlcXHNdKyQvKSAmJiBub1N1ZmZpeDtcblxuICAgIC8vIEFib3V0IHRvIHR5cGUgbmV4dCBvcGVyYW5kIGlmIHByZWNlZGVkIGJ5IGJpbmFyeSBvcGVyYXRvclxuICAgIGNvbnN0IG9wZXJhdG9yc1BhdHRlcm4gPSAvWytcXC0qL14lXS87XG4gICAgY29uc3QgaXNOZXh0T3BlcmFuZCA9IHRleHQubWF0Y2gob3BlcmF0b3JzUGF0dGVybik7XG5cbiAgICAvLyBEZXRlcm1pbmUgY2FuZGlkYXRlcyBieSBDU1MgY29udGV4dFxuICAgIGlmICh3cmFwcGVyQ2xhc3Nlcy5pbmNsdWRlcygnY29udGV4dC1yYW5nZScpKSB7XG4gICAgICAvLyBTdWdnZXN0aW9ucyBmb3IgbWV0cmljW3xdXG4gICAgICByZXR1cm4gdGhpcy5nZXRSYW5nZUNvbXBsZXRpb25JdGVtcygpO1xuICAgIH0gZWxzZSBpZiAod3JhcHBlckNsYXNzZXMuaW5jbHVkZXMoJ2NvbnRleHQtbGFiZWxzJykpIHtcbiAgICAgIC8vIFN1Z2dlc3Rpb25zIGZvciBtZXRyaWN7fH0gYW5kIG1ldHJpY3tmb289fH0sIGFzIHdlbGwgYXMgbWV0cmljLWluZGVwZW5kZW50IGxhYmVsIHF1ZXJpZXMgbGlrZSB7fH1cbiAgICAgIHJldHVybiB0aGlzLmdldExhYmVsQ29tcGxldGlvbkl0ZW1zKHsgcHJlZml4LCB0ZXh0LCB2YWx1ZSwgbGFiZWxLZXksIHdyYXBwZXJDbGFzc2VzIH0pO1xuICAgIH0gZWxzZSBpZiAod3JhcHBlckNsYXNzZXMuaW5jbHVkZXMoJ2NvbnRleHQtYWdncmVnYXRpb24nKSkge1xuICAgICAgLy8gU3VnZ2VzdGlvbnMgZm9yIHN1bShtZXRyaWMpIGJ5ICh8KVxuICAgICAgcmV0dXJuIHRoaXMuZ2V0QWdncmVnYXRpb25Db21wbGV0aW9uSXRlbXModmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoZW1wdHkpIHtcbiAgICAgIC8vIFN1Z2dlc3Rpb25zIGZvciBlbXB0eSBxdWVyeSBmaWVsZFxuICAgICAgcmV0dXJuIHRoaXMuZ2V0RW1wdHlDb21wbGV0aW9uSXRlbXMoY29udGV4dCk7XG4gICAgfSBlbHNlIGlmIChwcmVmaXhVbnJlY29nbml6ZWQgJiYgbm9TdWZmaXggJiYgIWlzTmV4dE9wZXJhbmQpIHtcbiAgICAgIC8vIFNob3cgdGVybSBzdWdnZXN0aW9ucyBpbiBhIGNvdXBsZSBvZiBzY2VuYXJpb3NcbiAgICAgIHJldHVybiB0aGlzLmdldEJlZ2lubmluZ0NvbXBsZXRpb25JdGVtcyhjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKHByZWZpeFVucmVjb2duaXplZCAmJiBzYWZlUHJlZml4KSB7XG4gICAgICAvLyBTaG93IHRlcm0gc3VnZ2VzdGlvbnMgaW4gYSBjb3VwbGUgb2Ygc2NlbmFyaW9zXG4gICAgICByZXR1cm4gdGhpcy5nZXRUZXJtQ29tcGxldGlvbkl0ZW1zKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVtcHR5UmVzdWx0O1xuICB9O1xuXG4gIGdldEJlZ2lubmluZ0NvbXBsZXRpb25JdGVtcyA9IChjb250ZXh0OiBBdXRvY29tcGxldGVDb250ZXh0KTogVHlwZWFoZWFkT3V0cHV0ID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgc3VnZ2VzdGlvbnM6IFsuLi50aGlzLmdldEVtcHR5Q29tcGxldGlvbkl0ZW1zKGNvbnRleHQpLnN1Z2dlc3Rpb25zLCAuLi50aGlzLmdldFRlcm1Db21wbGV0aW9uSXRlbXMoKS5zdWdnZXN0aW9uc10sXG4gICAgfTtcbiAgfTtcblxuICBnZXRFbXB0eUNvbXBsZXRpb25JdGVtcyA9IChjb250ZXh0OiBBdXRvY29tcGxldGVDb250ZXh0KTogVHlwZWFoZWFkT3V0cHV0ID0+IHtcbiAgICBjb25zdCB7IGhpc3RvcnkgfSA9IGNvbnRleHQ7XG4gICAgY29uc3Qgc3VnZ2VzdGlvbnM6IENvbXBsZXRpb25JdGVtR3JvdXBbXSA9IFtdO1xuXG4gICAgaWYgKGhpc3RvcnkgJiYgaGlzdG9yeS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGhpc3RvcnlJdGVtcyA9IGNoYWluKGhpc3RvcnkpXG4gICAgICAgIC5tYXAoKGgpID0+IGgucXVlcnkuZXhwcilcbiAgICAgICAgLmZpbHRlcigpXG4gICAgICAgIC51bmlxKClcbiAgICAgICAgLnRha2UoSElTVE9SWV9JVEVNX0NPVU5UKVxuICAgICAgICAubWFwKHdyYXBMYWJlbClcbiAgICAgICAgLm1hcCgoaXRlbSkgPT4gYWRkSGlzdG9yeU1ldGFkYXRhKGl0ZW0sIGhpc3RvcnkpKVxuICAgICAgICAudmFsdWUoKTtcblxuICAgICAgc3VnZ2VzdGlvbnMucHVzaCh7XG4gICAgICAgIHNlYXJjaEZ1bmN0aW9uVHlwZTogU2VhcmNoRnVuY3Rpb25UeXBlLlByZWZpeCxcbiAgICAgICAgc2tpcFNvcnQ6IHRydWUsXG4gICAgICAgIGxhYmVsOiAnSGlzdG9yeScsXG4gICAgICAgIGl0ZW1zOiBoaXN0b3J5SXRlbXMsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBzdWdnZXN0aW9ucyB9O1xuICB9O1xuXG4gIGdldFRlcm1Db21wbGV0aW9uSXRlbXMgPSAoKTogVHlwZWFoZWFkT3V0cHV0ID0+IHtcbiAgICBjb25zdCB7IG1ldHJpY3MsIG1ldHJpY3NNZXRhZGF0YSB9ID0gdGhpcztcbiAgICBjb25zdCBzdWdnZXN0aW9uczogQ29tcGxldGlvbkl0ZW1Hcm91cFtdID0gW107XG5cbiAgICBzdWdnZXN0aW9ucy5wdXNoKHtcbiAgICAgIHNlYXJjaEZ1bmN0aW9uVHlwZTogU2VhcmNoRnVuY3Rpb25UeXBlLlByZWZpeCxcbiAgICAgIGxhYmVsOiAnRnVuY3Rpb25zJyxcbiAgICAgIGl0ZW1zOiBGVU5DVElPTlMubWFwKHNldEZ1bmN0aW9uS2luZCksXG4gICAgfSk7XG5cbiAgICBpZiAobWV0cmljcyAmJiBtZXRyaWNzLmxlbmd0aCkge1xuICAgICAgc3VnZ2VzdGlvbnMucHVzaCh7XG4gICAgICAgIGxhYmVsOiAnTWV0cmljcycsXG4gICAgICAgIGl0ZW1zOiBtZXRyaWNzLm1hcCgobSkgPT4gYWRkTWV0cmljc01ldGFkYXRhKG0sIG1ldHJpY3NNZXRhZGF0YSkpLFxuICAgICAgICBzZWFyY2hGdW5jdGlvblR5cGU6IFNlYXJjaEZ1bmN0aW9uVHlwZS5GdXp6eSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB7IHN1Z2dlc3Rpb25zIH07XG4gIH07XG5cbiAgZ2V0UmFuZ2VDb21wbGV0aW9uSXRlbXMoKTogVHlwZWFoZWFkT3V0cHV0IHtcbiAgICByZXR1cm4ge1xuICAgICAgY29udGV4dDogJ2NvbnRleHQtcmFuZ2UnLFxuICAgICAgc3VnZ2VzdGlvbnM6IFtcbiAgICAgICAge1xuICAgICAgICAgIGxhYmVsOiAnUmFuZ2UgdmVjdG9yJyxcbiAgICAgICAgICBpdGVtczogWy4uLlJBVEVfUkFOR0VTXSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgfTtcbiAgfVxuXG4gIGdldEFnZ3JlZ2F0aW9uQ29tcGxldGlvbkl0ZW1zID0gYXN5bmMgKHZhbHVlOiBWYWx1ZSk6IFByb21pc2U8VHlwZWFoZWFkT3V0cHV0PiA9PiB7XG4gICAgY29uc3Qgc3VnZ2VzdGlvbnM6IENvbXBsZXRpb25JdGVtR3JvdXBbXSA9IFtdO1xuXG4gICAgLy8gU3RpdGNoIGFsbCBxdWVyeSBsaW5lcyB0b2dldGhlciB0byBzdXBwb3J0IG11bHRpLWxpbmUgcXVlcmllc1xuICAgIGxldCBxdWVyeU9mZnNldDtcbiAgICBjb25zdCBxdWVyeVRleHQgPSB2YWx1ZS5kb2N1bWVudC5nZXRCbG9ja3MoKS5yZWR1Y2UoKHRleHQsIGJsb2NrKSA9PiB7XG4gICAgICBpZiAodGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIGlmICghYmxvY2spIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJsb2NrVGV4dCA9IGJsb2NrPy5nZXRUZXh0KCk7XG5cbiAgICAgIGlmICh2YWx1ZS5hbmNob3JCbG9jay5rZXkgPT09IGJsb2NrLmtleSkge1xuICAgICAgICAvLyBOZXdsaW5lIGNoYXJhY3RlcnMgYXJlIG5vdCBhY2NvdW50ZWQgZm9yIGJ1dCB0aGlzIGlzIGlycmVsZXZhbnRcbiAgICAgICAgLy8gZm9yIHRoZSBwdXJwb3NlIG9mIGV4dHJhY3RpbmcgdGhlIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICBxdWVyeU9mZnNldCA9IHZhbHVlLnNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0ICsgdGV4dC5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ZXh0ICsgYmxvY2tUZXh0O1xuICAgIH0sICcnKTtcblxuICAgIC8vIFRyeSBzZWFyY2ggZm9yIHNlbGVjdG9yIHBhcnQgb24gdGhlIGxlZnQtaGFuZCBzaWRlLCBzdWNoIGFzIGBzdW0gKG0pIGJ5IChsKWBcbiAgICBjb25zdCBvcGVuUGFyZW5zQWdncmVnYXRpb25JbmRleCA9IHF1ZXJ5VGV4dC5sYXN0SW5kZXhPZignKCcsIHF1ZXJ5T2Zmc2V0KTtcbiAgICBsZXQgb3BlblBhcmVuc1NlbGVjdG9ySW5kZXggPSBxdWVyeVRleHQubGFzdEluZGV4T2YoJygnLCBvcGVuUGFyZW5zQWdncmVnYXRpb25JbmRleCAtIDEpO1xuICAgIGxldCBjbG9zZVBhcmVuc1NlbGVjdG9ySW5kZXggPSBxdWVyeVRleHQuaW5kZXhPZignKScsIG9wZW5QYXJlbnNTZWxlY3RvckluZGV4KTtcblxuICAgIC8vIFRyeSBzZWFyY2ggZm9yIHNlbGVjdG9yIHBhcnQgb2YgYW4gYWx0ZXJuYXRlIGFnZ3JlZ2F0aW9uIGNsYXVzZSwgc3VjaCBhcyBgc3VtIGJ5IChsKSAobSlgXG4gICAgaWYgKG9wZW5QYXJlbnNTZWxlY3RvckluZGV4ID09PSAtMSkge1xuICAgICAgY29uc3QgY2xvc2VQYXJlbnNBZ2dyZWdhdGlvbkluZGV4ID0gcXVlcnlUZXh0LmluZGV4T2YoJyknLCBxdWVyeU9mZnNldCk7XG4gICAgICBjbG9zZVBhcmVuc1NlbGVjdG9ySW5kZXggPSBxdWVyeVRleHQuaW5kZXhPZignKScsIGNsb3NlUGFyZW5zQWdncmVnYXRpb25JbmRleCArIDEpO1xuICAgICAgb3BlblBhcmVuc1NlbGVjdG9ySW5kZXggPSBxdWVyeVRleHQubGFzdEluZGV4T2YoJygnLCBjbG9zZVBhcmVuc1NlbGVjdG9ySW5kZXgpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIHN1Z2dlc3Rpb25zLFxuICAgICAgY29udGV4dDogJ2NvbnRleHQtYWdncmVnYXRpb24nLFxuICAgIH07XG5cbiAgICAvLyBTdWdnZXN0aW9ucyBhcmUgdXNlbGVzcyBmb3IgYWx0ZXJuYXRpdmUgYWdncmVnYXRpb24gY2xhdXNlcyB3aXRob3V0IGEgc2VsZWN0b3IgaW4gY29udGV4dFxuICAgIGlmIChvcGVuUGFyZW5zU2VsZWN0b3JJbmRleCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gUmFuZ2UgdmVjdG9yIHN5bnRheCBub3QgYWNjb3VudGVkIGZvciBieSBzdWJzZXF1ZW50IHBhcnNlIHNvIGRpc2NhcmQgaXQgaWYgcHJlc2VudFxuICAgIGNvbnN0IHNlbGVjdG9yU3RyaW5nID0gcXVlcnlUZXh0XG4gICAgICAuc2xpY2Uob3BlblBhcmVuc1NlbGVjdG9ySW5kZXggKyAxLCBjbG9zZVBhcmVuc1NlbGVjdG9ySW5kZXgpXG4gICAgICAucmVwbGFjZSgvXFxbW15cXF1dK1xcXSQvLCAnJyk7XG5cbiAgICBjb25zdCBzZWxlY3RvciA9IHBhcnNlU2VsZWN0b3Ioc2VsZWN0b3JTdHJpbmcsIHNlbGVjdG9yU3RyaW5nLmxlbmd0aCAtIDIpLnNlbGVjdG9yO1xuXG4gICAgY29uc3Qgc2VyaWVzID0gYXdhaXQgdGhpcy5nZXRTZXJpZXMoc2VsZWN0b3IpO1xuICAgIGNvbnN0IGxhYmVsS2V5cyA9IE9iamVjdC5rZXlzKHNlcmllcyk7XG4gICAgaWYgKGxhYmVsS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBsaW1pdEluZm8gPSBhZGRMaW1pdEluZm8obGFiZWxLZXlzKTtcbiAgICAgIHN1Z2dlc3Rpb25zLnB1c2goe1xuICAgICAgICBsYWJlbDogYExhYmVscyR7bGltaXRJbmZvfWAsXG4gICAgICAgIGl0ZW1zOiBsYWJlbEtleXMubWFwKHdyYXBMYWJlbCksXG4gICAgICAgIHNlYXJjaEZ1bmN0aW9uVHlwZTogU2VhcmNoRnVuY3Rpb25UeXBlLkZ1enp5LFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgZ2V0TGFiZWxDb21wbGV0aW9uSXRlbXMgPSBhc3luYyAoe1xuICAgIHRleHQsXG4gICAgd3JhcHBlckNsYXNzZXMsXG4gICAgbGFiZWxLZXksXG4gICAgdmFsdWUsXG4gIH06IFR5cGVhaGVhZElucHV0KTogUHJvbWlzZTxUeXBlYWhlYWRPdXRwdXQ+ID0+IHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4geyBzdWdnZXN0aW9uczogW10gfTtcbiAgICB9XG5cbiAgICBjb25zdCBzdWdnZXN0aW9uczogQ29tcGxldGlvbkl0ZW1Hcm91cFtdID0gW107XG4gICAgY29uc3QgbGluZSA9IHZhbHVlLmFuY2hvckJsb2NrLmdldFRleHQoKTtcbiAgICBjb25zdCBjdXJzb3JPZmZzZXQgPSB2YWx1ZS5zZWxlY3Rpb24uYW5jaG9yLm9mZnNldDtcbiAgICBjb25zdCBzdWZmaXggPSBsaW5lLnN1YnN0cihjdXJzb3JPZmZzZXQpO1xuICAgIGNvbnN0IHByZWZpeCA9IGxpbmUuc3Vic3RyKDAsIGN1cnNvck9mZnNldCk7XG4gICAgY29uc3QgaXNWYWx1ZVN0YXJ0ID0gdGV4dC5tYXRjaCgvXig9fD1+fCE9fCF+KS8pO1xuICAgIGNvbnN0IGlzVmFsdWVFbmQgPSBzdWZmaXgubWF0Y2goL15cIj9bLH1dfCQvKTtcbiAgICAvLyBEZXRlY3QgY3Vyc29yIGluIGZyb250IG9mIHZhbHVlLCBlLmcuLCB7a2V5PXxcIn1cbiAgICBjb25zdCBpc1ByZVZhbHVlID0gcHJlZml4Lm1hdGNoKC8oPXw9fnwhPXwhfikkLykgJiYgc3VmZml4Lm1hdGNoKC9eXCIvKTtcblxuICAgIC8vIERvbid0IHN1Z2dlc3QgYW55dGhpbmcgYXQgdGhlIGJlZ2lubmluZyBvciBpbnNpZGUgYSB2YWx1ZVxuICAgIGNvbnN0IGlzVmFsdWVFbXB0eSA9IGlzVmFsdWVTdGFydCAmJiBpc1ZhbHVlRW5kO1xuICAgIGNvbnN0IGhhc1ZhbHVlUHJlZml4ID0gaXNWYWx1ZUVuZCAmJiAhaXNWYWx1ZVN0YXJ0O1xuICAgIGlmICgoIWlzVmFsdWVFbXB0eSAmJiAhaGFzVmFsdWVQcmVmaXgpIHx8IGlzUHJlVmFsdWUpIHtcbiAgICAgIHJldHVybiB7IHN1Z2dlc3Rpb25zIH07XG4gICAgfVxuXG4gICAgLy8gR2V0IG5vcm1hbGl6ZWQgc2VsZWN0b3JcbiAgICBsZXQgc2VsZWN0b3I7XG4gICAgbGV0IHBhcnNlZFNlbGVjdG9yO1xuICAgIHRyeSB7XG4gICAgICBwYXJzZWRTZWxlY3RvciA9IHBhcnNlU2VsZWN0b3IobGluZSwgY3Vyc29yT2Zmc2V0KTtcbiAgICAgIHNlbGVjdG9yID0gcGFyc2VkU2VsZWN0b3Iuc2VsZWN0b3I7XG4gICAgfSBjYXRjaCB7XG4gICAgICBzZWxlY3RvciA9IEVNUFRZX1NFTEVDVE9SO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnRhaW5zTWV0cmljID0gc2VsZWN0b3IuaW5jbHVkZXMoJ19fbmFtZV9fPScpO1xuICAgIGNvbnN0IGV4aXN0aW5nS2V5cyA9IHBhcnNlZFNlbGVjdG9yID8gcGFyc2VkU2VsZWN0b3IubGFiZWxLZXlzIDogW107XG5cbiAgICBsZXQgc2VyaWVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT4gPSB7fTtcbiAgICAvLyBRdWVyeSBsYWJlbHMgZm9yIHNlbGVjdG9yXG4gICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICBzZXJpZXMgPSBhd2FpdCB0aGlzLmdldFNlcmllcyhzZWxlY3RvciwgIWNvbnRhaW5zTWV0cmljKTtcbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0LmtleXMoc2VyaWVzKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnNvbGUud2FybihgU2VydmVyIGRpZCBub3QgcmV0dXJuIGFueSB2YWx1ZXMgZm9yIHNlbGVjdG9yID0gJHtzZWxlY3Rvcn1gKTtcbiAgICAgIHJldHVybiB7IHN1Z2dlc3Rpb25zIH07XG4gICAgfVxuXG4gICAgbGV0IGNvbnRleHQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICAgIGlmICgodGV4dCAmJiBpc1ZhbHVlU3RhcnQpIHx8IHdyYXBwZXJDbGFzc2VzLmluY2x1ZGVzKCdhdHRyLXZhbHVlJykpIHtcbiAgICAgIC8vIExhYmVsIHZhbHVlc1xuICAgICAgaWYgKGxhYmVsS2V5ICYmIHNlcmllc1tsYWJlbEtleV0pIHtcbiAgICAgICAgY29udGV4dCA9ICdjb250ZXh0LWxhYmVsLXZhbHVlcyc7XG4gICAgICAgIGNvbnN0IGxpbWl0SW5mbyA9IGFkZExpbWl0SW5mbyhzZXJpZXNbbGFiZWxLZXldKTtcbiAgICAgICAgc3VnZ2VzdGlvbnMucHVzaCh7XG4gICAgICAgICAgbGFiZWw6IGBMYWJlbCB2YWx1ZXMgZm9yIFwiJHtsYWJlbEtleX1cIiR7bGltaXRJbmZvfWAsXG4gICAgICAgICAgaXRlbXM6IHNlcmllc1tsYWJlbEtleV0ubWFwKHdyYXBMYWJlbCksXG4gICAgICAgICAgc2VhcmNoRnVuY3Rpb25UeXBlOiBTZWFyY2hGdW5jdGlvblR5cGUuRnV6enksXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBMYWJlbCBrZXlzXG4gICAgICBjb25zdCBsYWJlbEtleXMgPSBzZXJpZXMgPyBPYmplY3Qua2V5cyhzZXJpZXMpIDogY29udGFpbnNNZXRyaWMgPyBudWxsIDogREVGQVVMVF9LRVlTO1xuXG4gICAgICBpZiAobGFiZWxLZXlzKSB7XG4gICAgICAgIGNvbnN0IHBvc3NpYmxlS2V5cyA9IGRpZmZlcmVuY2UobGFiZWxLZXlzLCBleGlzdGluZ0tleXMpO1xuICAgICAgICBpZiAocG9zc2libGVLZXlzLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnRleHQgPSAnY29udGV4dC1sYWJlbHMnO1xuICAgICAgICAgIGNvbnN0IG5ld0l0ZW1zID0gcG9zc2libGVLZXlzLm1hcCgoa2V5KSA9PiAoeyBsYWJlbDoga2V5IH0pKTtcbiAgICAgICAgICBjb25zdCBsaW1pdEluZm8gPSBhZGRMaW1pdEluZm8obmV3SXRlbXMpO1xuICAgICAgICAgIGNvbnN0IG5ld1N1Z2dlc3Rpb246IENvbXBsZXRpb25JdGVtR3JvdXAgPSB7XG4gICAgICAgICAgICBsYWJlbDogYExhYmVscyR7bGltaXRJbmZvfWAsXG4gICAgICAgICAgICBpdGVtczogbmV3SXRlbXMsXG4gICAgICAgICAgICBzZWFyY2hGdW5jdGlvblR5cGU6IFNlYXJjaEZ1bmN0aW9uVHlwZS5GdXp6eSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIHN1Z2dlc3Rpb25zLnB1c2gobmV3U3VnZ2VzdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyBjb250ZXh0LCBzdWdnZXN0aW9ucyB9O1xuICB9O1xuXG4gIGltcG9ydEZyb21BYnN0cmFjdFF1ZXJ5KGxhYmVsQmFzZWRRdWVyeTogQWJzdHJhY3RRdWVyeSk6IFByb21RdWVyeSB7XG4gICAgcmV0dXJuIHRvUHJvbUxpa2VRdWVyeShsYWJlbEJhc2VkUXVlcnkpO1xuICB9XG5cbiAgZXhwb3J0VG9BYnN0cmFjdFF1ZXJ5KHF1ZXJ5OiBQcm9tUXVlcnkpOiBBYnN0cmFjdFF1ZXJ5IHtcbiAgICBjb25zdCBwcm9tUXVlcnkgPSBxdWVyeS5leHByO1xuICAgIGlmICghcHJvbVF1ZXJ5IHx8IHByb21RdWVyeS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB7IHJlZklkOiBxdWVyeS5yZWZJZCwgbGFiZWxNYXRjaGVyczogW10gfTtcbiAgICB9XG4gICAgY29uc3QgdG9rZW5zID0gUHJpc20udG9rZW5pemUocHJvbVF1ZXJ5LCBQcm9tcWxTeW50YXgpO1xuICAgIGNvbnN0IGxhYmVsTWF0Y2hlcnM6IEFic3RyYWN0TGFiZWxNYXRjaGVyW10gPSBleHRyYWN0TGFiZWxNYXRjaGVycyh0b2tlbnMpO1xuICAgIGNvbnN0IG5hbWVMYWJlbFZhbHVlID0gZ2V0TmFtZUxhYmVsVmFsdWUocHJvbVF1ZXJ5LCB0b2tlbnMpO1xuICAgIGlmIChuYW1lTGFiZWxWYWx1ZSAmJiBuYW1lTGFiZWxWYWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICBsYWJlbE1hdGNoZXJzLnB1c2goe1xuICAgICAgICBuYW1lOiAnX19uYW1lX18nLFxuICAgICAgICBvcGVyYXRvcjogQWJzdHJhY3RMYWJlbE9wZXJhdG9yLkVxdWFsLFxuICAgICAgICB2YWx1ZTogbmFtZUxhYmVsVmFsdWUsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcmVmSWQ6IHF1ZXJ5LnJlZklkLFxuICAgICAgbGFiZWxNYXRjaGVycyxcbiAgICB9O1xuICB9XG5cbiAgYXN5bmMgZ2V0U2VyaWVzKHNlbGVjdG9yOiBzdHJpbmcsIHdpdGhOYW1lPzogYm9vbGVhbik6IFByb21pc2U8UmVjb3JkPHN0cmluZywgc3RyaW5nW10+PiB7XG4gICAgaWYgKHRoaXMuZGF0YXNvdXJjZS5sb29rdXBzRGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGlmIChzZWxlY3RvciA9PT0gRU1QVFlfU0VMRUNUT1IpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZmV0Y2hEZWZhdWx0U2VyaWVzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5mZXRjaFNlcmllc0xhYmVscyhzZWxlY3Rvciwgd2l0aE5hbWUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBUT0RPOiBiZXR0ZXIgZXJyb3IgaGFuZGxpbmdcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfVxuXG4gIGZldGNoTGFiZWxWYWx1ZXMgPSBhc3luYyAoa2V5OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZ1tdPiA9PiB7XG4gICAgY29uc3QgcGFyYW1zID0gdGhpcy5kYXRhc291cmNlLmdldFRpbWVSYW5nZVBhcmFtcygpO1xuICAgIGNvbnN0IHVybCA9IGAvYXBpL3YxL2xhYmVsLyR7dGhpcy5kYXRhc291cmNlLmludGVycG9sYXRlU3RyaW5nKGtleSl9L3ZhbHVlc2A7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucmVxdWVzdCh1cmwsIFtdLCBwYXJhbXMpO1xuICB9O1xuXG4gIGFzeW5jIGdldExhYmVsVmFsdWVzKGtleTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmZldGNoTGFiZWxWYWx1ZXMoa2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaGVzIGFsbCBsYWJlbCBrZXlzXG4gICAqL1xuICBhc3luYyBmZXRjaExhYmVscygpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgY29uc3QgdXJsID0gJy9hcGkvdjEvbGFiZWxzJztcbiAgICBjb25zdCBwYXJhbXMgPSB0aGlzLmRhdGFzb3VyY2UuZ2V0VGltZVJhbmdlUGFyYW1zKCk7XG4gICAgdGhpcy5sYWJlbEZldGNoVHMgPSBEYXRlLm5vdygpLnZhbHVlT2YoKTtcblxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMucmVxdWVzdCh1cmwsIFtdLCBwYXJhbXMpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlcykpIHtcbiAgICAgIHRoaXMubGFiZWxLZXlzID0gcmVzLnNsaWNlKCkuc29ydCgpO1xuICAgIH1cblxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBsYWJlbHMgZm9yIGEgc2VyaWVzLiBUaGlzIGlzIGNhY2hlZCBieSBpdCdzIGFyZ3MgYnV0IGFsc28gYnkgdGhlIGdsb2JhbCB0aW1lUmFuZ2UgY3VycmVudGx5IHNlbGVjdGVkIGFzXG4gICAqIHRoZXkgY2FuIGNoYW5nZSBvdmVyIHJlcXVlc3RlZCB0aW1lLlxuICAgKiBAcGFyYW0gbmFtZVxuICAgKiBAcGFyYW0gd2l0aE5hbWVcbiAgICovXG4gIGZldGNoU2VyaWVzTGFiZWxzID0gYXN5bmMgKG5hbWU6IHN0cmluZywgd2l0aE5hbWU/OiBib29sZWFuKTogUHJvbWlzZTxSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT4+ID0+IHtcbiAgICBjb25zdCBpbnRlcnBvbGF0ZWROYW1lID0gdGhpcy5kYXRhc291cmNlLmludGVycG9sYXRlU3RyaW5nKG5hbWUpO1xuICAgIGNvbnN0IHJhbmdlID0gdGhpcy5kYXRhc291cmNlLmdldFRpbWVSYW5nZVBhcmFtcygpO1xuICAgIGNvbnN0IHVybFBhcmFtcyA9IHtcbiAgICAgIC4uLnJhbmdlLFxuICAgICAgJ21hdGNoW10nOiBpbnRlcnBvbGF0ZWROYW1lLFxuICAgIH07XG4gICAgY29uc3QgdXJsID0gYC9hcGkvdjEvc2VyaWVzYDtcbiAgICAvLyBDYWNoZSBrZXkgaXMgYSBiaXQgZGlmZmVyZW50IGhlcmUuIFdlIGFkZCB0aGUgYHdpdGhOYW1lYCBwYXJhbSBhbmQgYWxzbyByb3VuZCB1cCB0byBhIG1pbnV0ZSB0aGUgaW50ZXJ2YWxzLlxuICAgIC8vIFRoZSByb3VuZGluZyBtYXkgc2VlbSBzdHJhbmdlIGJ1dCBtYWtlcyByZWxhdGl2ZSBpbnRlcnZhbHMgbGlrZSBub3ctMWggbGVzcyBwcm9uZSB0byBuZWVkIHNlcGFyYXRlIHJlcXVlc3QgZXZlcnlcbiAgICAvLyBtaWxsaXNlY29uZCB3aGlsZSBzdGlsbCBhY3R1YWxseSBnZXR0aW5nIGFsbCB0aGUga2V5cyBmb3IgdGhlIGNvcnJlY3QgaW50ZXJ2YWwuIFRoaXMgc3RpbGwgY2FuIGNyZWF0ZSBwcm9ibGVtc1xuICAgIC8vIHdoZW4gdXNlciBkb2VzIG5vdCB0aGUgbmV3ZXN0IHZhbHVlcyBmb3IgYSBtaW51dGUgaWYgYWxyZWFkeSBjYWNoZWQuXG4gICAgY29uc3QgY2FjaGVQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICdtYXRjaFtdJzogaW50ZXJwb2xhdGVkTmFtZSxcbiAgICAgIHN0YXJ0OiByb3VuZFNlY1RvTWluKHBhcnNlSW50KHJhbmdlLnN0YXJ0LCAxMCkpLnRvU3RyaW5nKCksXG4gICAgICBlbmQ6IHJvdW5kU2VjVG9NaW4ocGFyc2VJbnQocmFuZ2UuZW5kLCAxMCkpLnRvU3RyaW5nKCksXG4gICAgICB3aXRoTmFtZTogd2l0aE5hbWUgPyAndHJ1ZScgOiAnZmFsc2UnLFxuICAgIH0pO1xuXG4gICAgY29uc3QgY2FjaGVLZXkgPSBgL2FwaS92MS9zZXJpZXM/JHtjYWNoZVBhcmFtcy50b1N0cmluZygpfWA7XG4gICAgbGV0IHZhbHVlID0gdGhpcy5sYWJlbHNDYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLnJlcXVlc3QodXJsLCBbXSwgdXJsUGFyYW1zKTtcbiAgICAgIGNvbnN0IHsgdmFsdWVzIH0gPSBwcm9jZXNzTGFiZWxzKGRhdGEsIHdpdGhOYW1lKTtcbiAgICAgIHZhbHVlID0gdmFsdWVzO1xuICAgICAgdGhpcy5sYWJlbHNDYWNoZS5zZXQoY2FjaGVLZXksIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGZXRjaCBzZXJpZXMgZm9yIGEgc2VsZWN0b3IuIFVzZSB0aGlzIGZvciByYXcgcmVzdWx0cy4gVXNlIGZldGNoU2VyaWVzTGFiZWxzKCkgdG8gZ2V0IGxhYmVscy5cbiAgICogQHBhcmFtIG1hdGNoXG4gICAqL1xuICBmZXRjaFNlcmllcyA9IGFzeW5jIChtYXRjaDogc3RyaW5nKTogUHJvbWlzZTxBcnJheTxSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+Pj4gPT4ge1xuICAgIGNvbnN0IHVybCA9ICcvYXBpL3YxL3Nlcmllcyc7XG4gICAgY29uc3QgcmFuZ2UgPSB0aGlzLmRhdGFzb3VyY2UuZ2V0VGltZVJhbmdlUGFyYW1zKCk7XG4gICAgY29uc3QgcGFyYW1zID0geyAuLi5yYW5nZSwgJ21hdGNoW10nOiBtYXRjaCB9O1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnJlcXVlc3QodXJsLCB7fSwgcGFyYW1zKTtcbiAgfTtcblxuICAvKipcbiAgICogRmV0Y2ggdGhpcyBvbmx5IG9uZSBhcyB3ZSBhc3N1bWUgdGhpcyB3b24ndCBjaGFuZ2Ugb3ZlciB0aW1lLiBUaGlzIGlzIGNhY2hlZCBkaWZmZXJlbnRseSBmcm9tIGZldGNoU2VyaWVzTGFiZWxzXG4gICAqIGJlY2F1c2Ugd2UgY2FuIGNhY2hlIG1vcmUgYWdncmVzc2l2ZWx5IGhlcmUgYW5kIGFsc28gd2UgZG8gbm90IHdhbnQgdG8gaW52YWxpZGF0ZSB0aGlzIGNhY2hlIHRoZSBzYW1lIHdheSBhcyBpblxuICAgKiBmZXRjaFNlcmllc0xhYmVscy5cbiAgICovXG4gIGZldGNoRGVmYXVsdFNlcmllcyA9IG9uY2UoYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHZhbHVlcyA9IGF3YWl0IFByb21pc2UuYWxsKERFRkFVTFRfS0VZUy5tYXAoKGtleSkgPT4gdGhpcy5mZXRjaExhYmVsVmFsdWVzKGtleSkpKTtcbiAgICByZXR1cm4gREVGQVVMVF9LRVlTLnJlZHVjZSgoYWNjLCBrZXksIGkpID0+ICh7IC4uLmFjYywgW2tleV06IHZhbHVlc1tpXSB9KSwge30pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0TmFtZUxhYmVsVmFsdWUocHJvbVF1ZXJ5OiBzdHJpbmcsIHRva2VuczogYW55KTogc3RyaW5nIHtcbiAgbGV0IG5hbWVMYWJlbFZhbHVlID0gJyc7XG4gIGZvciAobGV0IHByb3AgaW4gdG9rZW5zKSB7XG4gICAgaWYgKHR5cGVvZiB0b2tlbnNbcHJvcF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICBuYW1lTGFiZWxWYWx1ZSA9IHRva2Vuc1twcm9wXSBhcyBzdHJpbmc7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5hbWVMYWJlbFZhbHVlO1xufVxuIiwiaW1wb3J0IHsgaW52ZXJ0IH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IFRva2VuIH0gZnJvbSAncHJpc21qcyc7XG5cbmltcG9ydCB7IERhdGFRdWVyeSwgQWJzdHJhY3RRdWVyeSwgQWJzdHJhY3RMYWJlbE9wZXJhdG9yLCBBYnN0cmFjdExhYmVsTWF0Y2hlciB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuXG5pbXBvcnQgeyBhZGRMYWJlbFRvUXVlcnkgfSBmcm9tICcuL2FkZF9sYWJlbF90b19xdWVyeSc7XG5pbXBvcnQgeyBTVUdHRVNUSU9OU19MSU1JVCB9IGZyb20gJy4vbGFuZ3VhZ2VfcHJvdmlkZXInO1xuaW1wb3J0IHsgUHJvbU1ldHJpY3NNZXRhZGF0YSwgUHJvbU1ldHJpY3NNZXRhZGF0YUl0ZW0gfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGNvbnN0IHByb2Nlc3NIaXN0b2dyYW1NZXRyaWNzID0gKG1ldHJpY3M6IHN0cmluZ1tdKSA9PiB7XG4gIGNvbnN0IHJlc3VsdFNldDogU2V0PHN0cmluZz4gPSBuZXcgU2V0KCk7XG4gIGNvbnN0IHJlZ2V4cCA9IG5ldyBSZWdFeHAoJ19idWNrZXQoJHw6KScpO1xuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbWV0cmljcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBtZXRyaWMgPSBtZXRyaWNzW2luZGV4XTtcbiAgICBjb25zdCBpc0hpc3RvZ3JhbVZhbHVlID0gcmVnZXhwLnRlc3QobWV0cmljKTtcbiAgICBpZiAoaXNIaXN0b2dyYW1WYWx1ZSkge1xuICAgICAgcmVzdWx0U2V0LmFkZChtZXRyaWMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gWy4uLnJlc3VsdFNldF07XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc0xhYmVscyhsYWJlbHM6IEFycmF5PHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0+LCB3aXRoTmFtZSA9IGZhbHNlKSB7XG4gIC8vIEZvciBwcm9jZXNzaW5nIHdlIGFyZSBnb2luZyB0byB1c2Ugc2V0cyBhcyB0aGV5IGhhdmUgc2lnbmlmaWNhbnRseSBiZXR0ZXIgcGVyZm9ybWFuY2UgdGhhbiBhcnJheXNcbiAgLy8gQWZ0ZXIgd2UgcHJvY2VzcyBsYWJlbHMsIHdlIHdpbGwgY29udmVydCBzZXRzIHRvIGFycmF5cyBhbmQgcmV0dXJuIG9iamVjdCB3aXRoIGxhYmVsIHZhbHVlcyBpbiBhcnJheXNcbiAgY29uc3QgdmFsdWVTZXQ6IHsgW2tleTogc3RyaW5nXTogU2V0PHN0cmluZz4gfSA9IHt9O1xuICBsYWJlbHMuZm9yRWFjaCgobGFiZWwpID0+IHtcbiAgICBjb25zdCB7IF9fbmFtZV9fLCAuLi5yZXN0IH0gPSBsYWJlbDtcbiAgICBpZiAod2l0aE5hbWUpIHtcbiAgICAgIHZhbHVlU2V0WydfX25hbWVfXyddID0gdmFsdWVTZXRbJ19fbmFtZV9fJ10gfHwgbmV3IFNldCgpO1xuICAgICAgaWYgKCF2YWx1ZVNldFsnX19uYW1lX18nXS5oYXMoX19uYW1lX18pKSB7XG4gICAgICAgIHZhbHVlU2V0WydfX25hbWVfXyddLmFkZChfX25hbWVfXyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgT2JqZWN0LmtleXMocmVzdCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBpZiAoIXZhbHVlU2V0W2tleV0pIHtcbiAgICAgICAgdmFsdWVTZXRba2V5XSA9IG5ldyBTZXQoKTtcbiAgICAgIH1cbiAgICAgIGlmICghdmFsdWVTZXRba2V5XS5oYXMocmVzdFtrZXldKSkge1xuICAgICAgICB2YWx1ZVNldFtrZXldLmFkZChyZXN0W2tleV0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICAvLyB2YWx1ZUFycmF5IHRoYXQgd2UgYXJlIGdvaW5nIHRvIHJldHVybiBpbiB0aGUgb2JqZWN0XG4gIGNvbnN0IHZhbHVlQXJyYXk6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nW10gfSA9IHt9O1xuICBsaW1pdFN1Z2dlc3Rpb25zKE9iamVjdC5rZXlzKHZhbHVlU2V0KSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgdmFsdWVBcnJheVtrZXldID0gbGltaXRTdWdnZXN0aW9ucyhBcnJheS5mcm9tKHZhbHVlU2V0W2tleV0pKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHsgdmFsdWVzOiB2YWx1ZUFycmF5LCBrZXlzOiBPYmplY3Qua2V5cyh2YWx1ZUFycmF5KSB9O1xufVxuXG4vLyBjb25zdCBjbGVhblNlbGVjdG9yUmVnZXhwID0gL1xceyhcXHcrPVwiW15cIlxcbl0qP1wiKSgsXFx3Kz1cIlteXCJcXG5dKj9cIikqXFx9LztcbmV4cG9ydCBjb25zdCBzZWxlY3RvclJlZ2V4cCA9IC9cXHtbXn1dKj8oXFx9fCQpLztcbmV4cG9ydCBjb25zdCBsYWJlbFJlZ2V4cCA9IC9cXGIoXFx3KykoIT89fj8pKFwiW15cIlxcbl0qP1wiKS9nO1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU2VsZWN0b3IocXVlcnk6IHN0cmluZywgY3Vyc29yT2Zmc2V0ID0gMSk6IHsgbGFiZWxLZXlzOiBhbnlbXTsgc2VsZWN0b3I6IHN0cmluZyB9IHtcbiAgaWYgKCFxdWVyeS5tYXRjaChzZWxlY3RvclJlZ2V4cCkpIHtcbiAgICAvLyBTcGVjaWFsIG1hdGNoZXIgZm9yIG1ldHJpY3NcbiAgICBpZiAocXVlcnkubWF0Y2goL15bQS1aYS16Ol1bXFx3Ol0qJC8pKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZWxlY3RvcjogYHtfX25hbWVfXz1cIiR7cXVlcnl9XCJ9YCxcbiAgICAgICAgbGFiZWxLZXlzOiBbJ19fbmFtZV9fJ10sXG4gICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1F1ZXJ5IG11c3QgY29udGFpbiBhIHNlbGVjdG9yOiAnICsgcXVlcnkpO1xuICB9XG5cbiAgLy8gQ2hlY2sgaWYgaW5zaWRlIGEgc2VsZWN0b3JcbiAgY29uc3QgcHJlZml4ID0gcXVlcnkuc2xpY2UoMCwgY3Vyc29yT2Zmc2V0KTtcbiAgY29uc3QgcHJlZml4T3BlbiA9IHByZWZpeC5sYXN0SW5kZXhPZigneycpO1xuICBjb25zdCBwcmVmaXhDbG9zZSA9IHByZWZpeC5sYXN0SW5kZXhPZignfScpO1xuICBpZiAocHJlZml4T3BlbiA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbnNpZGUgc2VsZWN0b3IsIG1pc3Npbmcgb3BlbiBicmFjZTogJyArIHByZWZpeCk7XG4gIH1cbiAgaWYgKHByZWZpeENsb3NlID4gLTEgJiYgcHJlZml4Q2xvc2UgPiBwcmVmaXhPcGVuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW5zaWRlIHNlbGVjdG9yLCBwcmV2aW91cyBzZWxlY3RvciBhbHJlYWR5IGNsb3NlZDogJyArIHByZWZpeCk7XG4gIH1cbiAgY29uc3Qgc3VmZml4ID0gcXVlcnkuc2xpY2UoY3Vyc29yT2Zmc2V0KTtcbiAgY29uc3Qgc3VmZml4Q2xvc2VJbmRleCA9IHN1ZmZpeC5pbmRleE9mKCd9Jyk7XG4gIGNvbnN0IHN1ZmZpeENsb3NlID0gc3VmZml4Q2xvc2VJbmRleCArIGN1cnNvck9mZnNldDtcbiAgY29uc3Qgc3VmZml4T3BlbkluZGV4ID0gc3VmZml4LmluZGV4T2YoJ3snKTtcbiAgY29uc3Qgc3VmZml4T3BlbiA9IHN1ZmZpeE9wZW5JbmRleCArIGN1cnNvck9mZnNldDtcbiAgaWYgKHN1ZmZpeENsb3NlID09PSAtMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IGluc2lkZSBzZWxlY3RvciwgbWlzc2luZyBjbG9zaW5nIGJyYWNlIGluIHN1ZmZpeDogJyArIHN1ZmZpeCk7XG4gIH1cbiAgaWYgKHN1ZmZpeE9wZW5JbmRleCA+IC0xICYmIHN1ZmZpeE9wZW4gPCBzdWZmaXhDbG9zZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IGluc2lkZSBzZWxlY3RvciwgbmV4dCBzZWxlY3RvciBvcGVucyBiZWZvcmUgdGhpcyBvbmUgY2xvc2VkOiAnICsgc3VmZml4KTtcbiAgfVxuXG4gIC8vIEV4dHJhY3QgY2xlYW4gbGFiZWxzIHRvIGZvcm0gY2xlYW4gc2VsZWN0b3IsIGluY29tcGxldGUgbGFiZWxzIGFyZSBkcm9wcGVkXG4gIGNvbnN0IHNlbGVjdG9yID0gcXVlcnkuc2xpY2UocHJlZml4T3Blbiwgc3VmZml4Q2xvc2UpO1xuICBjb25zdCBsYWJlbHM6IHsgW2tleTogc3RyaW5nXTogeyB2YWx1ZTogc3RyaW5nOyBvcGVyYXRvcjogc3RyaW5nIH0gfSA9IHt9O1xuICBzZWxlY3Rvci5yZXBsYWNlKGxhYmVsUmVnZXhwLCAobGFiZWwsIGtleSwgb3BlcmF0b3IsIHZhbHVlKSA9PiB7XG4gICAgY29uc3QgbGFiZWxPZmZzZXQgPSBxdWVyeS5pbmRleE9mKGxhYmVsKTtcbiAgICBjb25zdCB2YWx1ZVN0YXJ0ID0gbGFiZWxPZmZzZXQgKyBrZXkubGVuZ3RoICsgb3BlcmF0b3IubGVuZ3RoICsgMTtcbiAgICBjb25zdCB2YWx1ZUVuZCA9IGxhYmVsT2Zmc2V0ICsga2V5Lmxlbmd0aCArIG9wZXJhdG9yLmxlbmd0aCArIHZhbHVlLmxlbmd0aCAtIDE7XG4gICAgLy8gU2tpcCBsYWJlbCBpZiBjdXJzb3IgaXMgaW4gdmFsdWVcbiAgICBpZiAoY3Vyc29yT2Zmc2V0IDwgdmFsdWVTdGFydCB8fCBjdXJzb3JPZmZzZXQgPiB2YWx1ZUVuZCkge1xuICAgICAgbGFiZWxzW2tleV0gPSB7IHZhbHVlLCBvcGVyYXRvciB9O1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH0pO1xuXG4gIC8vIEFkZCBtZXRyaWMgaWYgdGhlcmUgaXMgb25lIGJlZm9yZSB0aGUgc2VsZWN0b3JcbiAgY29uc3QgbWV0cmljUHJlZml4ID0gcXVlcnkuc2xpY2UoMCwgcHJlZml4T3Blbik7XG4gIGNvbnN0IG1ldHJpY01hdGNoID0gbWV0cmljUHJlZml4Lm1hdGNoKC9bQS1aYS16Ol1bXFx3Ol0qJC8pO1xuICBpZiAobWV0cmljTWF0Y2gpIHtcbiAgICBsYWJlbHNbJ19fbmFtZV9fJ10gPSB7IHZhbHVlOiBgXCIke21ldHJpY01hdGNoWzBdfVwiYCwgb3BlcmF0b3I6ICc9JyB9O1xuICB9XG5cbiAgLy8gQnVpbGQgc29ydGVkIHNlbGVjdG9yXG4gIGNvbnN0IGxhYmVsS2V5cyA9IE9iamVjdC5rZXlzKGxhYmVscykuc29ydCgpO1xuICBjb25zdCBjbGVhblNlbGVjdG9yID0gbGFiZWxLZXlzLm1hcCgoa2V5KSA9PiBgJHtrZXl9JHtsYWJlbHNba2V5XS5vcGVyYXRvcn0ke2xhYmVsc1trZXldLnZhbHVlfWApLmpvaW4oJywnKTtcblxuICBjb25zdCBzZWxlY3RvclN0cmluZyA9IFsneycsIGNsZWFuU2VsZWN0b3IsICd9J10uam9pbignJyk7XG5cbiAgcmV0dXJuIHsgbGFiZWxLZXlzLCBzZWxlY3Rvcjogc2VsZWN0b3JTdHJpbmcgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZFJlY29yZGluZ1J1bGVzKHF1ZXJ5OiBzdHJpbmcsIG1hcHBpbmc6IHsgW25hbWU6IHN0cmluZ106IHN0cmluZyB9KTogc3RyaW5nIHtcbiAgY29uc3QgcnVsZU5hbWVzID0gT2JqZWN0LmtleXMobWFwcGluZyk7XG4gIGNvbnN0IHJ1bGVzUmVnZXggPSBuZXcgUmVnRXhwKGAoXFxcXHN8XikoJHtydWxlTmFtZXMuam9pbignfCcpfSkoXFxcXHN8JHxcXFxcKHxcXFxcW3xcXFxceylgLCAnaWcnKTtcbiAgY29uc3QgZXhwYW5kZWRRdWVyeSA9IHF1ZXJ5LnJlcGxhY2UocnVsZXNSZWdleCwgKG1hdGNoLCBwcmUsIG5hbWUsIHBvc3QpID0+IGAke3ByZX0ke21hcHBpbmdbbmFtZV19JHtwb3N0fWApO1xuXG4gIC8vIFNwbGl0IHF1ZXJ5IGludG8gYXJyYXksIHNvIGlmIHF1ZXJ5IHVzZXMgb3BlcmF0b3JzLCB3ZSBjYW4gY29ycmVjdGx5IGFkZCBsYWJlbHMgdG8gZWFjaCBpbmRpdmlkdWFsIHBhcnQuXG4gIGNvbnN0IHF1ZXJ5QXJyYXkgPSBleHBhbmRlZFF1ZXJ5LnNwbGl0KC8oXFwrfFxcLXxcXCp8XFwvfFxcJXxcXF4pLyk7XG5cbiAgLy8gUmVnZXggdGhhdCBtYXRjaGVzIG9jY3VycmVuY2VzIG9mICl7IG9yIH17IG9yIF17IHdoaWNoIGlzIGEgc2lnbiBvZiBpbmNvcnJlY2x5IGFkZGVkIGxhYmVscy5cbiAgY29uc3QgaW52YWxpZExhYmVsc1JlZ2V4ID0gLyhcXClcXHt8XFx9XFx7fFxcXVxceykvO1xuICBjb25zdCBjb3JyZWN0bHlFeHBhbmRlZFF1ZXJ5QXJyYXkgPSBxdWVyeUFycmF5Lm1hcCgocXVlcnkpID0+IHtcbiAgICByZXR1cm4gYWRkTGFiZWxzVG9FeHByZXNzaW9uKHF1ZXJ5LCBpbnZhbGlkTGFiZWxzUmVnZXgpO1xuICB9KTtcblxuICByZXR1cm4gY29ycmVjdGx5RXhwYW5kZWRRdWVyeUFycmF5LmpvaW4oJycpO1xufVxuXG5mdW5jdGlvbiBhZGRMYWJlbHNUb0V4cHJlc3Npb24oZXhwcjogc3RyaW5nLCBpbnZhbGlkTGFiZWxzUmVnZXhwOiBSZWdFeHApIHtcbiAgY29uc3QgbWF0Y2ggPSBleHByLm1hdGNoKGludmFsaWRMYWJlbHNSZWdleHApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIGV4cHI7XG4gIH1cblxuICAvLyBTcGxpdCBxdWVyeSBpbnRvIDIgcGFydHMgLSBiZWZvcmUgdGhlIGludmFsaWRMYWJlbHNSZWdleCBtYXRjaCBhbmQgYWZ0ZXIuXG4gIGNvbnN0IGluZGV4T2ZSZWdleE1hdGNoID0gbWF0Y2guaW5kZXggPz8gMDtcbiAgY29uc3QgZXhwckJlZm9yZVJlZ2V4TWF0Y2ggPSBleHByLnNsaWNlKDAsIGluZGV4T2ZSZWdleE1hdGNoICsgMSk7XG4gIGNvbnN0IGV4cHJBZnRlclJlZ2V4TWF0Y2ggPSBleHByLnNsaWNlKGluZGV4T2ZSZWdleE1hdGNoICsgMSk7XG5cbiAgLy8gQ3JlYXRlIGFycmF5T2ZMYWJlbE9iamVjdHMgd2l0aCBsYWJlbCBvYmplY3RzIHRoYXQgaGF2ZSBrZXksIG9wZXJhdG9yIGFuZCB2YWx1ZS5cbiAgY29uc3QgYXJyYXlPZkxhYmVsT2JqZWN0czogQXJyYXk8eyBrZXk6IHN0cmluZzsgb3BlcmF0b3I6IHN0cmluZzsgdmFsdWU6IHN0cmluZyB9PiA9IFtdO1xuICBleHByQWZ0ZXJSZWdleE1hdGNoLnJlcGxhY2UobGFiZWxSZWdleHAsIChsYWJlbCwga2V5LCBvcGVyYXRvciwgdmFsdWUpID0+IHtcbiAgICBhcnJheU9mTGFiZWxPYmplY3RzLnB1c2goeyBrZXksIG9wZXJhdG9yLCB2YWx1ZSB9KTtcbiAgICByZXR1cm4gJyc7XG4gIH0pO1xuXG4gIC8vIExvb3AgdGhyb3VnaCBhbGwgbGFiZWwgb2JqZWN0cyBhbmQgYWRkIHRoZW0gdG8gcXVlcnkuXG4gIC8vIEFzIGEgc3RhcnRpbmcgcG9pbnQgd2UgaGF2ZSB2YWxpZCBxdWVyeSB3aXRob3V0IHRoZSBsYWJlbHMuXG4gIGxldCByZXN1bHQgPSBleHByQmVmb3JlUmVnZXhNYXRjaDtcbiAgYXJyYXlPZkxhYmVsT2JqZWN0cy5maWx0ZXIoQm9vbGVhbikuZm9yRWFjaCgob2JqKSA9PiB7XG4gICAgLy8gUmVtb3ZlIGV4dHJhIHNldCBvZiBxdW90ZXMgZnJvbSBvYmoudmFsdWVcbiAgICBjb25zdCB2YWx1ZSA9IG9iai52YWx1ZS5zbGljZSgxLCAtMSk7XG4gICAgcmVzdWx0ID0gYWRkTGFiZWxUb1F1ZXJ5KHJlc3VsdCwgb2JqLmtleSwgdmFsdWUsIG9iai5vcGVyYXRvcik7XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQWRkcyBtZXRhZGF0YSBmb3Igc3ludGhldGljIG1ldHJpY3MgZm9yIHdoaWNoIHRoZSBBUEkgZG9lcyBub3QgcHJvdmlkZSBtZXRhZGF0YS5cbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZ3JhZmFuYS9ncmFmYW5hL2lzc3Vlcy8yMjMzNyBmb3IgZGV0YWlscy5cbiAqXG4gKiBAcGFyYW0gbWV0YWRhdGEgSEVMUCBhbmQgVFlQRSBtZXRhZGF0YSBmcm9tIC9hcGkvdjEvbWV0YWRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpeFN1bW1hcmllc01ldGFkYXRhKG1ldGFkYXRhOiB7IFttZXRyaWM6IHN0cmluZ106IFByb21NZXRyaWNzTWV0YWRhdGFJdGVtW10gfSk6IFByb21NZXRyaWNzTWV0YWRhdGEge1xuICBpZiAoIW1ldGFkYXRhKSB7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9XG4gIGNvbnN0IGJhc2VNZXRhZGF0YTogUHJvbU1ldHJpY3NNZXRhZGF0YSA9IHt9O1xuICBjb25zdCBzdW1tYXJ5TWV0YWRhdGE6IFByb21NZXRyaWNzTWV0YWRhdGEgPSB7fTtcbiAgZm9yIChjb25zdCBtZXRyaWMgaW4gbWV0YWRhdGEpIHtcbiAgICAvLyBOT1RFOiBiYXNlZCBvbiBwcm9tZXRoZXVzLWRvY3VtZW50YXRpb24sIHdlIGNhbiByZWNlaXZlXG4gICAgLy8gbXVsdGlwbGUgbWV0YWRhdGEtZW50cmllcyBmb3IgdGhlIGdpdmVuIG1ldHJpYywgaXQgc2VlbXNcbiAgICAvLyBpdCBoYXBwZW5zIHdoZW4gdGhlIHNhbWUgbWV0cmljIGlzIG9uIG11bHRpcGxlIHRhcmdldHNcbiAgICAvLyBhbmQgdGhlaXIgaGVscC10ZXh0IGRpZmZlcnNcbiAgICAvLyAoaHR0cHM6Ly9wcm9tZXRoZXVzLmlvL2RvY3MvcHJvbWV0aGV1cy9sYXRlc3QvcXVlcnlpbmcvYXBpLyNxdWVyeWluZy1tZXRyaWMtbWV0YWRhdGEpXG4gICAgLy8gZm9yIG5vdyB3ZSBqdXN0IHVzZSB0aGUgZmlyc3QgZW50cnkuXG4gICAgY29uc3QgaXRlbSA9IG1ldGFkYXRhW21ldHJpY11bMF07XG4gICAgYmFzZU1ldGFkYXRhW21ldHJpY10gPSBpdGVtO1xuXG4gICAgaWYgKGl0ZW0udHlwZSA9PT0gJ2hpc3RvZ3JhbScpIHtcbiAgICAgIHN1bW1hcnlNZXRhZGF0YVtgJHttZXRyaWN9X2J1Y2tldGBdID0ge1xuICAgICAgICB0eXBlOiAnY291bnRlcicsXG4gICAgICAgIGhlbHA6IGBDdW11bGF0aXZlIGNvdW50ZXJzIGZvciB0aGUgb2JzZXJ2YXRpb24gYnVja2V0cyAoJHtpdGVtLmhlbHB9KWAsXG4gICAgICB9O1xuICAgICAgc3VtbWFyeU1ldGFkYXRhW2Ake21ldHJpY31fY291bnRgXSA9IHtcbiAgICAgICAgdHlwZTogJ2NvdW50ZXInLFxuICAgICAgICBoZWxwOiBgQ291bnQgb2YgZXZlbnRzIHRoYXQgaGF2ZSBiZWVuIG9ic2VydmVkIGZvciB0aGUgaGlzdG9ncmFtIG1ldHJpYyAoJHtpdGVtLmhlbHB9KWAsXG4gICAgICB9O1xuICAgICAgc3VtbWFyeU1ldGFkYXRhW2Ake21ldHJpY31fc3VtYF0gPSB7XG4gICAgICAgIHR5cGU6ICdjb3VudGVyJyxcbiAgICAgICAgaGVscDogYFRvdGFsIHN1bSBvZiBhbGwgb2JzZXJ2ZWQgdmFsdWVzIGZvciB0aGUgaGlzdG9ncmFtIG1ldHJpYyAoJHtpdGVtLmhlbHB9KWAsXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoaXRlbS50eXBlID09PSAnc3VtbWFyeScpIHtcbiAgICAgIHN1bW1hcnlNZXRhZGF0YVtgJHttZXRyaWN9X2NvdW50YF0gPSB7XG4gICAgICAgIHR5cGU6ICdjb3VudGVyJyxcbiAgICAgICAgaGVscDogYENvdW50IG9mIGV2ZW50cyB0aGF0IGhhdmUgYmVlbiBvYnNlcnZlZCBmb3IgdGhlIGJhc2UgbWV0cmljICgke2l0ZW0uaGVscH0pYCxcbiAgICAgIH07XG4gICAgICBzdW1tYXJ5TWV0YWRhdGFbYCR7bWV0cmljfV9zdW1gXSA9IHtcbiAgICAgICAgdHlwZTogJ2NvdW50ZXInLFxuICAgICAgICBoZWxwOiBgVG90YWwgc3VtIG9mIGFsbCBvYnNlcnZlZCB2YWx1ZXMgZm9yIHRoZSBiYXNlIG1ldHJpYyAoJHtpdGVtLmhlbHB9KWAsXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICAvLyBTeW50aGV0aWMgc2VyaWVzXG4gIGNvbnN0IHN5bnRoZXRpY01ldGFkYXRhOiBQcm9tTWV0cmljc01ldGFkYXRhID0ge307XG4gIHN5bnRoZXRpY01ldGFkYXRhWydBTEVSVFMnXSA9IHtcbiAgICB0eXBlOiAnY291bnRlcicsXG4gICAgaGVscDogJ1RpbWUgc2VyaWVzIHNob3dpbmcgcGVuZGluZyBhbmQgZmlyaW5nIGFsZXJ0cy4gVGhlIHNhbXBsZSB2YWx1ZSBpcyBzZXQgdG8gMSBhcyBsb25nIGFzIHRoZSBhbGVydCBpcyBpbiB0aGUgaW5kaWNhdGVkIGFjdGl2ZSAocGVuZGluZyBvciBmaXJpbmcpIHN0YXRlLicsXG4gIH07XG5cbiAgcmV0dXJuIHsgLi4uYmFzZU1ldGFkYXRhLCAuLi5zdW1tYXJ5TWV0YWRhdGEsIC4uLnN5bnRoZXRpY01ldGFkYXRhIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByb3VuZE1zVG9NaW4obWlsbGlzZWNvbmRzOiBudW1iZXIpOiBudW1iZXIge1xuICByZXR1cm4gcm91bmRTZWNUb01pbihtaWxsaXNlY29uZHMgLyAxMDAwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kU2VjVG9NaW4oc2Vjb25kczogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIE1hdGguZmxvb3Ioc2Vjb25kcyAvIDYwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxpbWl0U3VnZ2VzdGlvbnMoaXRlbXM6IHN0cmluZ1tdKSB7XG4gIHJldHVybiBpdGVtcy5zbGljZSgwLCBTVUdHRVNUSU9OU19MSU1JVCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRMaW1pdEluZm8oaXRlbXM6IGFueVtdIHwgdW5kZWZpbmVkKTogc3RyaW5nIHtcbiAgcmV0dXJuIGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCA+PSBTVUdHRVNUSU9OU19MSU1JVCA/IGAsIGxpbWl0ZWQgdG8gdGhlIGZpcnN0ICR7U1VHR0VTVElPTlNfTElNSVR9IHJlY2VpdmVkIGl0ZW1zYCA6ICcnO1xufVxuXG4vLyBOT1RFOiB0aGUgZm9sbG93aW5nIDIgZXhwb3J0ZWQgZnVuY3Rpb25zIGFyZSB2ZXJ5IHNpbWlsYXIgdG8gdGhlIHByb21ldGhldXMqRXNjYXBlXG4vLyBmdW5jdGlvbnMgaW4gZGF0YXNvdXJjZS50cywgYnV0IHRoZXkgYXJlIG5vdCBleGFjdGx5IHRoZSBzYW1lIGFsZ29yaXRobSwgYW5kIHdlIGZvdW5kXG4vLyBubyB3YXkgdG8gcmV1c2Ugb25lIGluIHRoZSBhbm90aGVyIG9yIHZpY2UgdmVyc2EuXG5cbi8vIFByb21ldGhldXMgcmVndWxhci1leHByZXNzaW9ucyB1c2UgdGhlIFJFMiBzeW50YXggKGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvcmUyL3dpa2kvU3ludGF4KSxcbi8vIHNvIGV2ZXJ5IGNoYXJhY3RlciB0aGF0IG1hdGNoZXMgc29tZXRoaW5nIGluIHRoYXQgbGlzdCBoYXMgdG8gYmUgZXNjYXBlZC5cbi8vIHRoZSBsaXN0IG9mIG1ldGFjaGFyYWN0ZXJzIGlzOiAqKz8oKXxcXC5bXXt9XiRcbi8vIHdlIG1ha2UgYSBqYXZhc2NyaXB0IHJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IG1hdGNoZXMgdGhvc2UgY2hhcmFjdGVyczpcbmNvbnN0IFJFMl9NRVRBQ0hBUkFDVEVSUyA9IC9bKis/KCl8XFxcXC5cXFtcXF17fV4kXS9nO1xuZnVuY3Rpb24gZXNjYXBlUHJvbWV0aGV1c1JlZ2V4cCh2YWx1ZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoUkUyX01FVEFDSEFSQUNURVJTLCAnXFxcXCQmJyk7XG59XG5cbi8vIGJhc2VkIG9uIHRoZSBvcGVubWV0cmljcy1kb2N1bWVudGF0aW9uLCB0aGUgMyBzeW1ib2xzIHdlIGhhdmUgdG8gaGFuZGxlIGFyZTpcbi8vIC0gXFxuIC4uLiB0aGUgbmV3bGluZSBjaGFyYWN0ZXJcbi8vIC0gXFwgIC4uLiB0aGUgYmFja3NsYXNoIGNoYXJhY3RlclxuLy8gLSBcIiAgLi4uIHRoZSBkb3VibGUtcXVvdGUgY2hhcmFjdGVyXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlTGFiZWxWYWx1ZUluRXhhY3RTZWxlY3RvcihsYWJlbFZhbHVlOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gbGFiZWxWYWx1ZS5yZXBsYWNlKC9cXFxcL2csICdcXFxcXFxcXCcpLnJlcGxhY2UoL1xcbi9nLCAnXFxcXG4nKS5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVMYWJlbFZhbHVlSW5SZWdleFNlbGVjdG9yKGxhYmVsVmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBlc2NhcGVMYWJlbFZhbHVlSW5FeGFjdFNlbGVjdG9yKGVzY2FwZVByb21ldGhldXNSZWdleHAobGFiZWxWYWx1ZSkpO1xufVxuXG5jb25zdCBGcm9tUHJvbUxpa2VNYXA6IFJlY29yZDxzdHJpbmcsIEFic3RyYWN0TGFiZWxPcGVyYXRvcj4gPSB7XG4gICc9JzogQWJzdHJhY3RMYWJlbE9wZXJhdG9yLkVxdWFsLFxuICAnIT0nOiBBYnN0cmFjdExhYmVsT3BlcmF0b3IuTm90RXF1YWwsXG4gICc9fic6IEFic3RyYWN0TGFiZWxPcGVyYXRvci5FcXVhbFJlZ0V4LFxuICAnIX4nOiBBYnN0cmFjdExhYmVsT3BlcmF0b3IuTm90RXF1YWxSZWdFeCxcbn07XG5jb25zdCBUb1Byb21MaWtlTWFwOiBSZWNvcmQ8QWJzdHJhY3RMYWJlbE9wZXJhdG9yLCBzdHJpbmc+ID0gaW52ZXJ0KEZyb21Qcm9tTGlrZU1hcCkgYXMgUmVjb3JkPFxuICBBYnN0cmFjdExhYmVsT3BlcmF0b3IsXG4gIHN0cmluZ1xuPjtcblxuZXhwb3J0IGZ1bmN0aW9uIHRvUHJvbUxpa2VFeHByKGxhYmVsQmFzZWRRdWVyeTogQWJzdHJhY3RRdWVyeSk6IHN0cmluZyB7XG4gIGNvbnN0IGV4cHIgPSBsYWJlbEJhc2VkUXVlcnkubGFiZWxNYXRjaGVyc1xuICAgIC5tYXAoKHNlbGVjdG9yOiBBYnN0cmFjdExhYmVsTWF0Y2hlcikgPT4ge1xuICAgICAgY29uc3Qgb3BlcmF0b3IgPSBUb1Byb21MaWtlTWFwW3NlbGVjdG9yLm9wZXJhdG9yXTtcbiAgICAgIGlmIChvcGVyYXRvcikge1xuICAgICAgICByZXR1cm4gYCR7c2VsZWN0b3IubmFtZX0ke29wZXJhdG9yfVwiJHtzZWxlY3Rvci52YWx1ZX1cImA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgfSlcbiAgICAuZmlsdGVyKChlOiBzdHJpbmcpID0+IGUgIT09ICcnKVxuICAgIC5qb2luKCcsICcpO1xuXG4gIHJldHVybiBleHByID8gYHske2V4cHJ9fWAgOiAnJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvUHJvbUxpa2VRdWVyeShsYWJlbEJhc2VkUXVlcnk6IEFic3RyYWN0UXVlcnkpOiBQcm9tTGlrZVF1ZXJ5IHtcbiAgcmV0dXJuIHtcbiAgICByZWZJZDogbGFiZWxCYXNlZFF1ZXJ5LnJlZklkLFxuICAgIGV4cHI6IHRvUHJvbUxpa2VFeHByKGxhYmVsQmFzZWRRdWVyeSksXG4gICAgcmFuZ2U6IHRydWUsXG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvbUxpa2VRdWVyeSBleHRlbmRzIERhdGFRdWVyeSB7XG4gIGV4cHI6IHN0cmluZztcbiAgcmFuZ2U6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0TGFiZWxNYXRjaGVycyh0b2tlbnM6IEFycmF5PHN0cmluZyB8IFRva2VuPik6IEFic3RyYWN0TGFiZWxNYXRjaGVyW10ge1xuICBjb25zdCBsYWJlbE1hdGNoZXJzOiBBYnN0cmFjdExhYmVsTWF0Y2hlcltdID0gW107XG5cbiAgZm9yIChsZXQgcHJvcCBpbiB0b2tlbnMpIHtcbiAgICBpZiAodG9rZW5zW3Byb3BdIGluc3RhbmNlb2YgVG9rZW4pIHtcbiAgICAgIGxldCB0b2tlbjogVG9rZW4gPSB0b2tlbnNbcHJvcF0gYXMgVG9rZW47XG4gICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2NvbnRleHQtbGFiZWxzJykge1xuICAgICAgICBsZXQgbGFiZWxLZXkgPSAnJztcbiAgICAgICAgbGV0IGxhYmVsVmFsdWUgPSAnJztcbiAgICAgICAgbGV0IGxhYmVsT3BlcmF0b3IgPSAnJztcbiAgICAgICAgbGV0IGNvbnRlbnRUb2tlbnM6IGFueVtdID0gdG9rZW4uY29udGVudCBhcyBhbnlbXTtcbiAgICAgICAgZm9yIChsZXQgY3VycmVudFRva2VuIGluIGNvbnRlbnRUb2tlbnMpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnRUb2tlbnNbY3VycmVudFRva2VuXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50U3RyOiBzdHJpbmc7XG4gICAgICAgICAgICBjdXJyZW50U3RyID0gY29udGVudFRva2Vuc1tjdXJyZW50VG9rZW5dIGFzIHN0cmluZztcbiAgICAgICAgICAgIGlmIChjdXJyZW50U3RyID09PSAnPScgfHwgY3VycmVudFN0ciA9PT0gJyE9JyB8fCBjdXJyZW50U3RyID09PSAnPX4nIHx8IGN1cnJlbnRTdHIgPT09ICchficpIHtcbiAgICAgICAgICAgICAgbGFiZWxPcGVyYXRvciA9IGN1cnJlbnRTdHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChjb250ZW50VG9rZW5zW2N1cnJlbnRUb2tlbl0gaW5zdGFuY2VvZiBUb2tlbikge1xuICAgICAgICAgICAgc3dpdGNoIChjb250ZW50VG9rZW5zW2N1cnJlbnRUb2tlbl0udHlwZSkge1xuICAgICAgICAgICAgICBjYXNlICdsYWJlbC1rZXknOlxuICAgICAgICAgICAgICAgIGxhYmVsS2V5ID0gY29udGVudFRva2Vuc1tjdXJyZW50VG9rZW5dLmNvbnRlbnQgYXMgc3RyaW5nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdsYWJlbC12YWx1ZSc6XG4gICAgICAgICAgICAgICAgbGFiZWxWYWx1ZSA9IGNvbnRlbnRUb2tlbnNbY3VycmVudFRva2VuXS5jb250ZW50IGFzIHN0cmluZztcbiAgICAgICAgICAgICAgICBsYWJlbFZhbHVlID0gbGFiZWxWYWx1ZS5zdWJzdHJpbmcoMSwgbGFiZWxWYWx1ZS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsYWJlbENvbXBhcmF0b3IgPSBGcm9tUHJvbUxpa2VNYXBbbGFiZWxPcGVyYXRvcl07XG4gICAgICAgICAgICAgICAgaWYgKGxhYmVsQ29tcGFyYXRvcikge1xuICAgICAgICAgICAgICAgICAgbGFiZWxNYXRjaGVycy5wdXNoKHsgbmFtZTogbGFiZWxLZXksIG9wZXJhdG9yOiBsYWJlbENvbXBhcmF0b3IsIHZhbHVlOiBsYWJlbFZhbHVlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGFiZWxNYXRjaGVycztcbn1cbiIsImltcG9ydCB7IGNoYWluLCBtYXAgYXMgX21hcCwgdW5pcSB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBsYXN0VmFsdWVGcm9tIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7IE1ldHJpY0ZpbmRWYWx1ZSwgVGltZVJhbmdlIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBnZXRUaW1lU3J2IH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2Rhc2hib2FyZC9zZXJ2aWNlcy9UaW1lU3J2JztcblxuaW1wb3J0IHsgUHJvbWV0aGV1c0RhdGFzb3VyY2UgfSBmcm9tICcuL2RhdGFzb3VyY2UnO1xuaW1wb3J0IHsgUHJvbVF1ZXJ5UmVxdWVzdCB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcm9tZXRoZXVzTWV0cmljRmluZFF1ZXJ5IHtcbiAgcmFuZ2U6IFRpbWVSYW5nZTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGRhdGFzb3VyY2U6IFByb21ldGhldXNEYXRhc291cmNlLCBwcml2YXRlIHF1ZXJ5OiBzdHJpbmcpIHtcbiAgICB0aGlzLmRhdGFzb3VyY2UgPSBkYXRhc291cmNlO1xuICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgICB0aGlzLnJhbmdlID0gZ2V0VGltZVNydigpLnRpbWVSYW5nZSgpO1xuICB9XG5cbiAgcHJvY2VzcygpOiBQcm9taXNlPE1ldHJpY0ZpbmRWYWx1ZVtdPiB7XG4gICAgY29uc3QgbGFiZWxOYW1lc1JlZ2V4ID0gL15sYWJlbF9uYW1lc1xcKFxcKVxccyokLztcbiAgICBjb25zdCBsYWJlbFZhbHVlc1JlZ2V4ID0gL15sYWJlbF92YWx1ZXNcXCgoPzooLispLFxccyopPyhbYS16QS1aX11bYS16QS1aMC05X10qKVxcKVxccyokLztcbiAgICBjb25zdCBtZXRyaWNOYW1lc1JlZ2V4ID0gL15tZXRyaWNzXFwoKC4rKVxcKVxccyokLztcbiAgICBjb25zdCBxdWVyeVJlc3VsdFJlZ2V4ID0gL15xdWVyeV9yZXN1bHRcXCgoLispXFwpXFxzKiQvO1xuICAgIGNvbnN0IGxhYmVsTmFtZXNRdWVyeSA9IHRoaXMucXVlcnkubWF0Y2gobGFiZWxOYW1lc1JlZ2V4KTtcbiAgICBpZiAobGFiZWxOYW1lc1F1ZXJ5KSB7XG4gICAgICByZXR1cm4gdGhpcy5sYWJlbE5hbWVzUXVlcnkoKTtcbiAgICB9XG5cbiAgICBjb25zdCBsYWJlbFZhbHVlc1F1ZXJ5ID0gdGhpcy5xdWVyeS5tYXRjaChsYWJlbFZhbHVlc1JlZ2V4KTtcbiAgICBpZiAobGFiZWxWYWx1ZXNRdWVyeSkge1xuICAgICAgaWYgKGxhYmVsVmFsdWVzUXVlcnlbMV0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFiZWxWYWx1ZXNRdWVyeShsYWJlbFZhbHVlc1F1ZXJ5WzJdLCBsYWJlbFZhbHVlc1F1ZXJ5WzFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhYmVsVmFsdWVzUXVlcnkobGFiZWxWYWx1ZXNRdWVyeVsyXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbWV0cmljTmFtZXNRdWVyeSA9IHRoaXMucXVlcnkubWF0Y2gobWV0cmljTmFtZXNSZWdleCk7XG4gICAgaWYgKG1ldHJpY05hbWVzUXVlcnkpIHtcbiAgICAgIHJldHVybiB0aGlzLm1ldHJpY05hbWVRdWVyeShtZXRyaWNOYW1lc1F1ZXJ5WzFdKTtcbiAgICB9XG5cbiAgICBjb25zdCBxdWVyeVJlc3VsdFF1ZXJ5ID0gdGhpcy5xdWVyeS5tYXRjaChxdWVyeVJlc3VsdFJlZ2V4KTtcbiAgICBpZiAocXVlcnlSZXN1bHRRdWVyeSkge1xuICAgICAgcmV0dXJuIGxhc3RWYWx1ZUZyb20odGhpcy5xdWVyeVJlc3VsdFF1ZXJ5KHF1ZXJ5UmVzdWx0UXVlcnlbMV0pKTtcbiAgICB9XG5cbiAgICAvLyBpZiBxdWVyeSBjb250YWlucyBmdWxsIG1ldHJpYyBuYW1lLCByZXR1cm4gbWV0cmljIG5hbWUgYW5kIGxhYmVsIGxpc3RcbiAgICByZXR1cm4gdGhpcy5tZXRyaWNOYW1lQW5kTGFiZWxzUXVlcnkodGhpcy5xdWVyeSk7XG4gIH1cblxuICBsYWJlbE5hbWVzUXVlcnkoKSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLmRhdGFzb3VyY2UuZ2V0UHJvbWV0aGV1c1RpbWUodGhpcy5yYW5nZS5mcm9tLCBmYWxzZSk7XG4gICAgY29uc3QgZW5kID0gdGhpcy5kYXRhc291cmNlLmdldFByb21ldGhldXNUaW1lKHRoaXMucmFuZ2UudG8sIHRydWUpO1xuICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgIHN0YXJ0OiBzdGFydC50b1N0cmluZygpLFxuICAgICAgZW5kOiBlbmQudG9TdHJpbmcoKSxcbiAgICB9O1xuXG4gICAgY29uc3QgdXJsID0gYC9hcGkvdjEvbGFiZWxzYDtcblxuICAgIHJldHVybiB0aGlzLmRhdGFzb3VyY2UubWV0YWRhdGFSZXF1ZXN0KHVybCwgcGFyYW1zKS50aGVuKChyZXN1bHQ6IGFueSkgPT4ge1xuICAgICAgcmV0dXJuIF9tYXAocmVzdWx0LmRhdGEuZGF0YSwgKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiB7IHRleHQ6IHZhbHVlIH07XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGxhYmVsVmFsdWVzUXVlcnkobGFiZWw6IHN0cmluZywgbWV0cmljPzogc3RyaW5nKSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLmRhdGFzb3VyY2UuZ2V0UHJvbWV0aGV1c1RpbWUodGhpcy5yYW5nZS5mcm9tLCBmYWxzZSk7XG4gICAgY29uc3QgZW5kID0gdGhpcy5kYXRhc291cmNlLmdldFByb21ldGhldXNUaW1lKHRoaXMucmFuZ2UudG8sIHRydWUpO1xuXG4gICAgbGV0IHVybDogc3RyaW5nO1xuXG4gICAgaWYgKCFtZXRyaWMpIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LnRvU3RyaW5nKCksXG4gICAgICAgIGVuZDogZW5kLnRvU3RyaW5nKCksXG4gICAgICB9O1xuICAgICAgLy8gcmV0dXJuIGxhYmVsIHZhbHVlcyBnbG9iYWxseVxuICAgICAgdXJsID0gYC9hcGkvdjEvbGFiZWwvJHtsYWJlbH0vdmFsdWVzYDtcblxuICAgICAgcmV0dXJuIHRoaXMuZGF0YXNvdXJjZS5tZXRhZGF0YVJlcXVlc3QodXJsLCBwYXJhbXMpLnRoZW4oKHJlc3VsdDogYW55KSA9PiB7XG4gICAgICAgIHJldHVybiBfbWFwKHJlc3VsdC5kYXRhLmRhdGEsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgIHJldHVybiB7IHRleHQ6IHZhbHVlIH07XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgJ21hdGNoW10nOiBtZXRyaWMsXG4gICAgICAgIHN0YXJ0OiBzdGFydC50b1N0cmluZygpLFxuICAgICAgICBlbmQ6IGVuZC50b1N0cmluZygpLFxuICAgICAgfTtcbiAgICAgIHVybCA9IGAvYXBpL3YxL3Nlcmllc2A7XG5cbiAgICAgIHJldHVybiB0aGlzLmRhdGFzb3VyY2UubWV0YWRhdGFSZXF1ZXN0KHVybCwgcGFyYW1zKS50aGVuKChyZXN1bHQ6IGFueSkgPT4ge1xuICAgICAgICBjb25zdCBfbGFiZWxzID0gX21hcChyZXN1bHQuZGF0YS5kYXRhLCAobWV0cmljKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIG1ldHJpY1tsYWJlbF0gfHwgJyc7XG4gICAgICAgIH0pLmZpbHRlcigobGFiZWwpID0+IHtcbiAgICAgICAgICByZXR1cm4gbGFiZWwgIT09ICcnO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdW5pcShfbGFiZWxzKS5tYXAoKG1ldHJpYykgPT4ge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0ZXh0OiBtZXRyaWMsXG4gICAgICAgICAgICBleHBhbmRhYmxlOiB0cnVlLFxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgbWV0cmljTmFtZVF1ZXJ5KG1ldHJpY0ZpbHRlclBhdHRlcm46IHN0cmluZykge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5kYXRhc291cmNlLmdldFByb21ldGhldXNUaW1lKHRoaXMucmFuZ2UuZnJvbSwgZmFsc2UpO1xuICAgIGNvbnN0IGVuZCA9IHRoaXMuZGF0YXNvdXJjZS5nZXRQcm9tZXRoZXVzVGltZSh0aGlzLnJhbmdlLnRvLCB0cnVlKTtcbiAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICBzdGFydDogc3RhcnQudG9TdHJpbmcoKSxcbiAgICAgIGVuZDogZW5kLnRvU3RyaW5nKCksXG4gICAgfTtcbiAgICBjb25zdCB1cmwgPSBgL2FwaS92MS9sYWJlbC9fX25hbWVfXy92YWx1ZXNgO1xuXG4gICAgcmV0dXJuIHRoaXMuZGF0YXNvdXJjZS5tZXRhZGF0YVJlcXVlc3QodXJsLCBwYXJhbXMpLnRoZW4oKHJlc3VsdDogYW55KSA9PiB7XG4gICAgICByZXR1cm4gY2hhaW4ocmVzdWx0LmRhdGEuZGF0YSlcbiAgICAgICAgLmZpbHRlcigobWV0cmljTmFtZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHIgPSBuZXcgUmVnRXhwKG1ldHJpY0ZpbHRlclBhdHRlcm4pO1xuICAgICAgICAgIHJldHVybiByLnRlc3QobWV0cmljTmFtZSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5tYXAoKG1hdGNoZWRNZXRyaWNOYW1lKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRleHQ6IG1hdGNoZWRNZXRyaWNOYW1lLFxuICAgICAgICAgICAgZXhwYW5kYWJsZTogdHJ1ZSxcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgICAudmFsdWUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIHF1ZXJ5UmVzdWx0UXVlcnkocXVlcnk6IHN0cmluZykge1xuICAgIGNvbnN0IGVuZCA9IHRoaXMuZGF0YXNvdXJjZS5nZXRQcm9tZXRoZXVzVGltZSh0aGlzLnJhbmdlLnRvLCB0cnVlKTtcbiAgICBjb25zdCBpbnN0YW50UXVlcnk6IFByb21RdWVyeVJlcXVlc3QgPSB7IGV4cHI6IHF1ZXJ5IH0gYXMgUHJvbVF1ZXJ5UmVxdWVzdDtcbiAgICByZXR1cm4gdGhpcy5kYXRhc291cmNlLnBlcmZvcm1JbnN0YW50UXVlcnkoaW5zdGFudFF1ZXJ5LCBlbmQpLnBpcGUoXG4gICAgICBtYXAoKHJlc3VsdCkgPT4ge1xuICAgICAgICByZXR1cm4gX21hcChyZXN1bHQuZGF0YS5kYXRhLnJlc3VsdCwgKG1ldHJpY0RhdGEpID0+IHtcbiAgICAgICAgICBsZXQgdGV4dCA9IG1ldHJpY0RhdGEubWV0cmljLl9fbmFtZV9fIHx8ICcnO1xuICAgICAgICAgIGRlbGV0ZSBtZXRyaWNEYXRhLm1ldHJpYy5fX25hbWVfXztcbiAgICAgICAgICB0ZXh0ICs9XG4gICAgICAgICAgICAneycgK1xuICAgICAgICAgICAgX21hcChtZXRyaWNEYXRhLm1ldHJpYywgKHYsIGspID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGsgKyAnPVwiJyArIHYgKyAnXCInO1xuICAgICAgICAgICAgfSkuam9pbignLCcpICtcbiAgICAgICAgICAgICd9JztcbiAgICAgICAgICB0ZXh0ICs9ICcgJyArIG1ldHJpY0RhdGEudmFsdWVbMV0gKyAnICcgKyBtZXRyaWNEYXRhLnZhbHVlWzBdICogMTAwMDtcblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgICAgZXhwYW5kYWJsZTogdHJ1ZSxcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIG1ldHJpY05hbWVBbmRMYWJlbHNRdWVyeShxdWVyeTogc3RyaW5nKTogUHJvbWlzZTxNZXRyaWNGaW5kVmFsdWVbXT4ge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5kYXRhc291cmNlLmdldFByb21ldGhldXNUaW1lKHRoaXMucmFuZ2UuZnJvbSwgZmFsc2UpO1xuICAgIGNvbnN0IGVuZCA9IHRoaXMuZGF0YXNvdXJjZS5nZXRQcm9tZXRoZXVzVGltZSh0aGlzLnJhbmdlLnRvLCB0cnVlKTtcbiAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAnbWF0Y2hbXSc6IHF1ZXJ5LFxuICAgICAgc3RhcnQ6IHN0YXJ0LnRvU3RyaW5nKCksXG4gICAgICBlbmQ6IGVuZC50b1N0cmluZygpLFxuICAgIH07XG5cbiAgICBjb25zdCB1cmwgPSBgL2FwaS92MS9zZXJpZXNgO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHRoaXMuZGF0YXNvdXJjZS5tZXRhZGF0YVJlcXVlc3QodXJsLCBwYXJhbXMpLnRoZW4oKHJlc3VsdDogYW55KSA9PiB7XG4gICAgICByZXR1cm4gX21hcChyZXN1bHQuZGF0YS5kYXRhLCAobWV0cmljOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9KSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdGV4dDogc2VsZi5kYXRhc291cmNlLmdldE9yaWdpbmFsTWV0cmljTmFtZShtZXRyaWMpLFxuICAgICAgICAgIGV4cGFuZGFibGU6IHRydWUsXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgR3JhbW1hciB9IGZyb20gJ3ByaXNtanMnO1xuXG5pbXBvcnQgeyBDb21wbGV0aW9uSXRlbSB9IGZyb20gJ0BncmFmYW5hL3VpJztcblxuLy8gV2hlbiBjaGFuZ2luZyBSQVRFX1JBTkdFUywgY2hlY2sgaWYgTG9raS9Mb2dRTCByYW5nZXMgc2hvdWxkIGJlIGNoYW5nZWQgdG9vXG4vLyBAc2VlIHB1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvbGFuZ3VhZ2VfcHJvdmlkZXIudHNcbmV4cG9ydCBjb25zdCBSQVRFX1JBTkdFUzogQ29tcGxldGlvbkl0ZW1bXSA9IFtcbiAgeyBsYWJlbDogJyRfX2ludGVydmFsJywgc29ydFZhbHVlOiAnJF9faW50ZXJ2YWwnIH0sXG4gIHsgbGFiZWw6ICckX19yYXRlX2ludGVydmFsJywgc29ydFZhbHVlOiAnJF9fcmF0ZV9pbnRlcnZhbCcgfSxcbiAgeyBsYWJlbDogJyRfX3JhbmdlJywgc29ydFZhbHVlOiAnJF9fcmFuZ2UnIH0sXG4gIHsgbGFiZWw6ICcxbScsIHNvcnRWYWx1ZTogJzAwOjAxOjAwJyB9LFxuICB7IGxhYmVsOiAnNW0nLCBzb3J0VmFsdWU6ICcwMDowNTowMCcgfSxcbiAgeyBsYWJlbDogJzEwbScsIHNvcnRWYWx1ZTogJzAwOjEwOjAwJyB9LFxuICB7IGxhYmVsOiAnMzBtJywgc29ydFZhbHVlOiAnMDA6MzA6MDAnIH0sXG4gIHsgbGFiZWw6ICcxaCcsIHNvcnRWYWx1ZTogJzAxOjAwOjAwJyB9LFxuICB7IGxhYmVsOiAnMWQnLCBzb3J0VmFsdWU6ICcyNDowMDowMCcgfSxcbl07XG5cbmV4cG9ydCBjb25zdCBPUEVSQVRPUlMgPSBbJ2J5JywgJ2dyb3VwX2xlZnQnLCAnZ3JvdXBfcmlnaHQnLCAnaWdub3JpbmcnLCAnb24nLCAnb2Zmc2V0JywgJ3dpdGhvdXQnXTtcbmV4cG9ydCBjb25zdCBMT0dJQ0FMX09QRVJBVE9SUyA9IFsnb3InLCAnYW5kJywgJ3VubGVzcyddO1xuXG5jb25zdCBUUklHT05PTUVUUklDX0ZVTkNUSU9OUzogQ29tcGxldGlvbkl0ZW1bXSA9IFtcbiAge1xuICAgIGxhYmVsOiAnYWNvcycsXG4gICAgaW5zZXJ0VGV4dDogJ2Fjb3MnLFxuICAgIGRldGFpbDogJ2Fjb3ModiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdjYWxjdWxhdGVzIHRoZSBhcmNjb3NpbmUgb2YgYWxsIGVsZW1lbnRzIGluIHYnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdhY29zaCcsXG4gICAgaW5zZXJ0VGV4dDogJ2Fjb3NoJyxcbiAgICBkZXRhaWw6ICdhY29zaCh2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ2NhbGN1bGF0ZXMgdGhlIGludmVyc2UgaHlwZXJib2xpYyBjb3NpbmUgb2YgYWxsIGVsZW1lbnRzIGluIHYnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdhc2luJyxcbiAgICBpbnNlcnRUZXh0OiAnYXNpbicsXG4gICAgZGV0YWlsOiAnYXNpbih2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ2NhbGN1bGF0ZXMgdGhlIGFyY3NpbmUgb2YgYWxsIGVsZW1lbnRzIGluIHYnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdhc2luaCcsXG4gICAgaW5zZXJ0VGV4dDogJ2FzaW5oJyxcbiAgICBkZXRhaWw6ICdhc2luaCh2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ2NhbGN1bGF0ZXMgdGhlIGludmVyc2UgaHlwZXJib2xpYyBzaW5lIG9mIGFsbCBlbGVtZW50cyBpbiB2JyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnYXRhbicsXG4gICAgaW5zZXJ0VGV4dDogJ2F0YW4nLFxuICAgIGRldGFpbDogJ2F0YW4odiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdjYWxjdWxhdGVzIHRoZSBhcmN0YW5nZW50IG9mIGFsbCBlbGVtZW50cyBpbiB2JyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnYXRhbmgnLFxuICAgIGluc2VydFRleHQ6ICdhdGFuaCcsXG4gICAgZGV0YWlsOiAnYXRhbmgodiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdjYWxjdWxhdGVzIHRoZSBpbnZlcnNlIGh5cGVyYm9saWMgdGFuZ2VudCBvZiBhbGwgZWxlbWVudHMgaW4gdicsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ2NvcycsXG4gICAgaW5zZXJ0VGV4dDogJ2NvcycsXG4gICAgZGV0YWlsOiAnY29zKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnY2FsY3VsYXRlcyB0aGUgY29zaW5lIG9mIGFsbCBlbGVtZW50cyBpbiB2JyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnY29zaCcsXG4gICAgaW5zZXJ0VGV4dDogJ2Nvc2gnLFxuICAgIGRldGFpbDogJ2Nvc2godiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdjYWxjdWxhdGVzIHRoZSBoeXBlcmJvbGljIGNvc2luZSBvZiBhbGwgZWxlbWVudHMgaW4gdicsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ3NpbicsXG4gICAgaW5zZXJ0VGV4dDogJ3NpbicsXG4gICAgZGV0YWlsOiAnc2luKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnY2FsY3VsYXRlcyB0aGUgc2luZSBvZiBhbGwgZWxlbWVudHMgaW4gdicsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ3NpbmgnLFxuICAgIGluc2VydFRleHQ6ICdzaW5oJyxcbiAgICBkZXRhaWw6ICdzaW5oKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnY2FsY3VsYXRlcyB0aGUgaHlwZXJib2xpYyBzaW5lIG9mIGFsbCBlbGVtZW50cyBpbiB2JyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAndGFuJyxcbiAgICBpbnNlcnRUZXh0OiAndGFuJyxcbiAgICBkZXRhaWw6ICd0YW4odiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdjYWxjdWxhdGVzIHRoZSB0YW5nZW50IG9mIGFsbCBlbGVtZW50cyBpbiB2JyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAndGFuaCcsXG4gICAgaW5zZXJ0VGV4dDogJ3RhbmgnLFxuICAgIGRldGFpbDogJ3RhbmgodiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdjYWxjdWxhdGVzIHRoZSBoeXBlcmJvbGljIHRhbmdlbnQgb2YgYWxsIGVsZW1lbnRzIGluIHYnLFxuICB9LFxuXTtcblxuY29uc3QgQUdHUkVHQVRJT05fT1BFUkFUT1JTOiBDb21wbGV0aW9uSXRlbVtdID0gW1xuICB7XG4gICAgbGFiZWw6ICdzdW0nLFxuICAgIGluc2VydFRleHQ6ICdzdW0nLFxuICAgIGRvY3VtZW50YXRpb246ICdDYWxjdWxhdGUgc3VtIG92ZXIgZGltZW5zaW9ucycsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ21pbicsXG4gICAgaW5zZXJ0VGV4dDogJ21pbicsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1NlbGVjdCBtaW5pbXVtIG92ZXIgZGltZW5zaW9ucycsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ21heCcsXG4gICAgaW5zZXJ0VGV4dDogJ21heCcsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1NlbGVjdCBtYXhpbXVtIG92ZXIgZGltZW5zaW9ucycsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ2F2ZycsXG4gICAgaW5zZXJ0VGV4dDogJ2F2ZycsXG4gICAgZG9jdW1lbnRhdGlvbjogJ0NhbGN1bGF0ZSB0aGUgYXZlcmFnZSBvdmVyIGRpbWVuc2lvbnMnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdncm91cCcsXG4gICAgaW5zZXJ0VGV4dDogJ2dyb3VwJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnQWxsIHZhbHVlcyBpbiB0aGUgcmVzdWx0aW5nIHZlY3RvciBhcmUgMScsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ3N0ZGRldicsXG4gICAgaW5zZXJ0VGV4dDogJ3N0ZGRldicsXG4gICAgZG9jdW1lbnRhdGlvbjogJ0NhbGN1bGF0ZSBwb3B1bGF0aW9uIHN0YW5kYXJkIGRldmlhdGlvbiBvdmVyIGRpbWVuc2lvbnMnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdzdGR2YXInLFxuICAgIGluc2VydFRleHQ6ICdzdGR2YXInLFxuICAgIGRvY3VtZW50YXRpb246ICdDYWxjdWxhdGUgcG9wdWxhdGlvbiBzdGFuZGFyZCB2YXJpYW5jZSBvdmVyIGRpbWVuc2lvbnMnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdjb3VudCcsXG4gICAgaW5zZXJ0VGV4dDogJ2NvdW50JyxcbiAgICBkb2N1bWVudGF0aW9uOiAnQ291bnQgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSB2ZWN0b3InLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdjb3VudF92YWx1ZXMnLFxuICAgIGluc2VydFRleHQ6ICdjb3VudF92YWx1ZXMnLFxuICAgIGRvY3VtZW50YXRpb246ICdDb3VudCBudW1iZXIgb2YgZWxlbWVudHMgd2l0aCB0aGUgc2FtZSB2YWx1ZScsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ2JvdHRvbWsnLFxuICAgIGluc2VydFRleHQ6ICdib3R0b21rJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnU21hbGxlc3QgayBlbGVtZW50cyBieSBzYW1wbGUgdmFsdWUnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICd0b3BrJyxcbiAgICBpbnNlcnRUZXh0OiAndG9waycsXG4gICAgZG9jdW1lbnRhdGlvbjogJ0xhcmdlc3QgayBlbGVtZW50cyBieSBzYW1wbGUgdmFsdWUnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdxdWFudGlsZScsXG4gICAgaW5zZXJ0VGV4dDogJ3F1YW50aWxlJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnQ2FsY3VsYXRlIM+GLXF1YW50aWxlICgwIOKJpCDPhiDiiaQgMSkgb3ZlciBkaW1lbnNpb25zJyxcbiAgfSxcbl07XG5cbmV4cG9ydCBjb25zdCBGVU5DVElPTlMgPSBbXG4gIC4uLkFHR1JFR0FUSU9OX09QRVJBVE9SUyxcbiAgLi4uVFJJR09OT01FVFJJQ19GVU5DVElPTlMsXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnYWJzJyxcbiAgICBsYWJlbDogJ2FicycsXG4gICAgZGV0YWlsOiAnYWJzKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnUmV0dXJucyB0aGUgaW5wdXQgdmVjdG9yIHdpdGggYWxsIHNhbXBsZSB2YWx1ZXMgY29udmVydGVkIHRvIHRoZWlyIGFic29sdXRlIHZhbHVlLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnYWJzZW50JyxcbiAgICBsYWJlbDogJ2Fic2VudCcsXG4gICAgZGV0YWlsOiAnYWJzZW50KHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ1JldHVybnMgYW4gZW1wdHkgdmVjdG9yIGlmIHRoZSB2ZWN0b3IgcGFzc2VkIHRvIGl0IGhhcyBhbnkgZWxlbWVudHMgYW5kIGEgMS1lbGVtZW50IHZlY3RvciB3aXRoIHRoZSB2YWx1ZSAxIGlmIHRoZSB2ZWN0b3IgcGFzc2VkIHRvIGl0IGhhcyBubyBlbGVtZW50cy4gVGhpcyBpcyB1c2VmdWwgZm9yIGFsZXJ0aW5nIG9uIHdoZW4gbm8gdGltZSBzZXJpZXMgZXhpc3QgZm9yIGEgZ2l2ZW4gbWV0cmljIG5hbWUgYW5kIGxhYmVsIGNvbWJpbmF0aW9uLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnYWJzZW50X292ZXJfdGltZScsXG4gICAgbGFiZWw6ICdhYnNlbnRfb3Zlcl90aW1lJyxcbiAgICBkZXRhaWw6ICdhYnNlbnQodiByYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ1JldHVybnMgYW4gZW1wdHkgdmVjdG9yIGlmIHRoZSByYW5nZSB2ZWN0b3IgcGFzc2VkIHRvIGl0IGhhcyBhbnkgZWxlbWVudHMgYW5kIGEgMS1lbGVtZW50IHZlY3RvciB3aXRoIHRoZSB2YWx1ZSAxIGlmIHRoZSByYW5nZSB2ZWN0b3IgcGFzc2VkIHRvIGl0IGhhcyBubyBlbGVtZW50cy4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2NlaWwnLFxuICAgIGxhYmVsOiAnY2VpbCcsXG4gICAgZGV0YWlsOiAnY2VpbCh2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1JvdW5kcyB0aGUgc2FtcGxlIHZhbHVlcyBvZiBhbGwgZWxlbWVudHMgaW4gYHZgIHVwIHRvIHRoZSBuZWFyZXN0IGludGVnZXIuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdjaGFuZ2VzJyxcbiAgICBsYWJlbDogJ2NoYW5nZXMnLFxuICAgIGRldGFpbDogJ2NoYW5nZXModiByYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ0ZvciBlYWNoIGlucHV0IHRpbWUgc2VyaWVzLCBgY2hhbmdlcyh2IHJhbmdlLXZlY3RvcilgIHJldHVybnMgdGhlIG51bWJlciBvZiB0aW1lcyBpdHMgdmFsdWUgaGFzIGNoYW5nZWQgd2l0aGluIHRoZSBwcm92aWRlZCB0aW1lIHJhbmdlIGFzIGFuIGluc3RhbnQgdmVjdG9yLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnY2xhbXAnLFxuICAgIGxhYmVsOiAnY2xhbXAnLFxuICAgIGRldGFpbDogJ2NsYW1wKHYgaW5zdGFudC12ZWN0b3IsIG1pbiBzY2FsYXIsIG1heCBzY2FsYXIpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ0NsYW1wcyB0aGUgc2FtcGxlIHZhbHVlcyBvZiBhbGwgZWxlbWVudHMgaW4gYHZgIHRvIGhhdmUgYSBsb3dlciBsaW1pdCBvZiBgbWluYCBhbmQgYW4gdXBwZXIgbGltaXQgb2YgYG1heGAuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdjbGFtcF9tYXgnLFxuICAgIGxhYmVsOiAnY2xhbXBfbWF4JyxcbiAgICBkZXRhaWw6ICdjbGFtcF9tYXgodiBpbnN0YW50LXZlY3RvciwgbWF4IHNjYWxhciknLFxuICAgIGRvY3VtZW50YXRpb246ICdDbGFtcHMgdGhlIHNhbXBsZSB2YWx1ZXMgb2YgYWxsIGVsZW1lbnRzIGluIGB2YCB0byBoYXZlIGFuIHVwcGVyIGxpbWl0IG9mIGBtYXhgLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnY2xhbXBfbWluJyxcbiAgICBsYWJlbDogJ2NsYW1wX21pbicsXG4gICAgZGV0YWlsOiAnY2xhbXBfbWluKHYgaW5zdGFudC12ZWN0b3IsIG1pbiBzY2FsYXIpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnQ2xhbXBzIHRoZSBzYW1wbGUgdmFsdWVzIG9mIGFsbCBlbGVtZW50cyBpbiBgdmAgdG8gaGF2ZSBhIGxvd2VyIGxpbWl0IG9mIGBtaW5gLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnY291bnRfc2NhbGFyJyxcbiAgICBsYWJlbDogJ2NvdW50X3NjYWxhcicsXG4gICAgZGV0YWlsOiAnY291bnRfc2NhbGFyKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ1JldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiBhIHRpbWUgc2VyaWVzIHZlY3RvciBhcyBhIHNjYWxhci4gVGhpcyBpcyBpbiBjb250cmFzdCB0byB0aGUgYGNvdW50KClgIGFnZ3JlZ2F0aW9uIG9wZXJhdG9yLCB3aGljaCBhbHdheXMgcmV0dXJucyBhIHZlY3RvciAoYW4gZW1wdHkgb25lIGlmIHRoZSBpbnB1dCB2ZWN0b3IgaXMgZW1wdHkpIGFuZCBhbGxvd3MgZ3JvdXBpbmcgYnkgbGFiZWxzIHZpYSBhIGBieWAgY2xhdXNlLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnZGVnJyxcbiAgICBsYWJlbDogJ2RlZycsXG4gICAgZGV0YWlsOiAnZGVnKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnQ29udmVydHMgcmFkaWFucyB0byBkZWdyZWVzIGZvciBhbGwgZWxlbWVudHMgaW4gdicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnZGF5X29mX21vbnRoJyxcbiAgICBsYWJlbDogJ2RheV9vZl9tb250aCcsXG4gICAgZGV0YWlsOiAnZGF5X29mX21vbnRoKHY9dmVjdG9yKHRpbWUoKSkgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnUmV0dXJucyB0aGUgZGF5IG9mIHRoZSBtb250aCBmb3IgZWFjaCBvZiB0aGUgZ2l2ZW4gdGltZXMgaW4gVVRDLiBSZXR1cm5lZCB2YWx1ZXMgYXJlIGZyb20gMSB0byAzMS4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2RheV9vZl93ZWVrJyxcbiAgICBsYWJlbDogJ2RheV9vZl93ZWVrJyxcbiAgICBkZXRhaWw6ICdkYXlfb2Zfd2Vlayh2PXZlY3Rvcih0aW1lKCkpIGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdSZXR1cm5zIHRoZSBkYXkgb2YgdGhlIHdlZWsgZm9yIGVhY2ggb2YgdGhlIGdpdmVuIHRpbWVzIGluIFVUQy4gUmV0dXJuZWQgdmFsdWVzIGFyZSBmcm9tIDAgdG8gNiwgd2hlcmUgMCBtZWFucyBTdW5kYXkgZXRjLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnZGF5c19pbl9tb250aCcsXG4gICAgbGFiZWw6ICdkYXlzX2luX21vbnRoJyxcbiAgICBkZXRhaWw6ICdkYXlzX2luX21vbnRoKHY9dmVjdG9yKHRpbWUoKSkgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ1JldHVybnMgbnVtYmVyIG9mIGRheXMgaW4gdGhlIG1vbnRoIGZvciBlYWNoIG9mIHRoZSBnaXZlbiB0aW1lcyBpbiBVVEMuIFJldHVybmVkIHZhbHVlcyBhcmUgZnJvbSAyOCB0byAzMS4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2RlbHRhJyxcbiAgICBsYWJlbDogJ2RlbHRhJyxcbiAgICBkZXRhaWw6ICdkZWx0YSh2IHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnQ2FsY3VsYXRlcyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBmaXJzdCBhbmQgbGFzdCB2YWx1ZSBvZiBlYWNoIHRpbWUgc2VyaWVzIGVsZW1lbnQgaW4gYSByYW5nZSB2ZWN0b3IgYHZgLCByZXR1cm5pbmcgYW4gaW5zdGFudCB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gZGVsdGFzIGFuZCBlcXVpdmFsZW50IGxhYmVscy4gVGhlIGRlbHRhIGlzIGV4dHJhcG9sYXRlZCB0byBjb3ZlciB0aGUgZnVsbCB0aW1lIHJhbmdlIGFzIHNwZWNpZmllZCBpbiB0aGUgcmFuZ2UgdmVjdG9yIHNlbGVjdG9yLCBzbyB0aGF0IGl0IGlzIHBvc3NpYmxlIHRvIGdldCBhIG5vbi1pbnRlZ2VyIHJlc3VsdCBldmVuIGlmIHRoZSBzYW1wbGUgdmFsdWVzIGFyZSBhbGwgaW50ZWdlcnMuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdkZXJpdicsXG4gICAgbGFiZWw6ICdkZXJpdicsXG4gICAgZGV0YWlsOiAnZGVyaXYodiByYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ0NhbGN1bGF0ZXMgdGhlIHBlci1zZWNvbmQgZGVyaXZhdGl2ZSBvZiB0aGUgdGltZSBzZXJpZXMgaW4gYSByYW5nZSB2ZWN0b3IgYHZgLCB1c2luZyBzaW1wbGUgbGluZWFyIHJlZ3Jlc3Npb24uJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdkcm9wX2NvbW1vbl9sYWJlbHMnLFxuICAgIGxhYmVsOiAnZHJvcF9jb21tb25fbGFiZWxzJyxcbiAgICBkZXRhaWw6ICdkcm9wX2NvbW1vbl9sYWJlbHMoaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnRHJvcHMgYWxsIGxhYmVscyB0aGF0IGhhdmUgdGhlIHNhbWUgbmFtZSBhbmQgdmFsdWUgYWNyb3NzIGFsbCBzZXJpZXMgaW4gdGhlIGlucHV0IHZlY3Rvci4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2V4cCcsXG4gICAgbGFiZWw6ICdleHAnLFxuICAgIGRldGFpbDogJ2V4cCh2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdDYWxjdWxhdGVzIHRoZSBleHBvbmVudGlhbCBmdW5jdGlvbiBmb3IgYWxsIGVsZW1lbnRzIGluIGB2YC5cXG5TcGVjaWFsIGNhc2VzIGFyZTpcXG4qIGBFeHAoK0luZikgPSArSW5mYCBcXG4qIGBFeHAoTmFOKSA9IE5hTmAnLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2Zsb29yJyxcbiAgICBsYWJlbDogJ2Zsb29yJyxcbiAgICBkZXRhaWw6ICdmbG9vcih2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1JvdW5kcyB0aGUgc2FtcGxlIHZhbHVlcyBvZiBhbGwgZWxlbWVudHMgaW4gYHZgIGRvd24gdG8gdGhlIG5lYXJlc3QgaW50ZWdlci4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2hpc3RvZ3JhbV9xdWFudGlsZScsXG4gICAgbGFiZWw6ICdoaXN0b2dyYW1fcXVhbnRpbGUnLFxuICAgIGRldGFpbDogJ2hpc3RvZ3JhbV9xdWFudGlsZSjPhiBmbG9hdCwgYiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnQ2FsY3VsYXRlcyB0aGUgz4YtcXVhbnRpbGUgKDAg4omkIM+GIOKJpCAxKSBmcm9tIHRoZSBidWNrZXRzIGBiYCBvZiBhIGhpc3RvZ3JhbS4gVGhlIHNhbXBsZXMgaW4gYGJgIGFyZSB0aGUgY291bnRzIG9mIG9ic2VydmF0aW9ucyBpbiBlYWNoIGJ1Y2tldC4gRWFjaCBzYW1wbGUgbXVzdCBoYXZlIGEgbGFiZWwgYGxlYCB3aGVyZSB0aGUgbGFiZWwgdmFsdWUgZGVub3RlcyB0aGUgaW5jbHVzaXZlIHVwcGVyIGJvdW5kIG9mIHRoZSBidWNrZXQuIChTYW1wbGVzIHdpdGhvdXQgc3VjaCBhIGxhYmVsIGFyZSBzaWxlbnRseSBpZ25vcmVkLikgVGhlIGhpc3RvZ3JhbSBtZXRyaWMgdHlwZSBhdXRvbWF0aWNhbGx5IHByb3ZpZGVzIHRpbWUgc2VyaWVzIHdpdGggdGhlIGBfYnVja2V0YCBzdWZmaXggYW5kIHRoZSBhcHByb3ByaWF0ZSBsYWJlbHMuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdob2x0X3dpbnRlcnMnLFxuICAgIGxhYmVsOiAnaG9sdF93aW50ZXJzJyxcbiAgICBkZXRhaWw6ICdob2x0X3dpbnRlcnModiByYW5nZS12ZWN0b3IsIHNmIHNjYWxhciwgdGYgc2NhbGFyKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdQcm9kdWNlcyBhIHNtb290aGVkIHZhbHVlIGZvciB0aW1lIHNlcmllcyBiYXNlZCBvbiB0aGUgcmFuZ2UgaW4gYHZgLiBUaGUgbG93ZXIgdGhlIHNtb290aGluZyBmYWN0b3IgYHNmYCwgdGhlIG1vcmUgaW1wb3J0YW5jZSBpcyBnaXZlbiB0byBvbGQgZGF0YS4gVGhlIGhpZ2hlciB0aGUgdHJlbmQgZmFjdG9yIGB0ZmAsIHRoZSBtb3JlIHRyZW5kcyBpbiB0aGUgZGF0YSBpcyBjb25zaWRlcmVkLiBCb3RoIGBzZmAgYW5kIGB0ZmAgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdob3VyJyxcbiAgICBsYWJlbDogJ2hvdXInLFxuICAgIGRldGFpbDogJ2hvdXIodj12ZWN0b3IodGltZSgpKSBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdSZXR1cm5zIHRoZSBob3VyIG9mIHRoZSBkYXkgZm9yIGVhY2ggb2YgdGhlIGdpdmVuIHRpbWVzIGluIFVUQy4gUmV0dXJuZWQgdmFsdWVzIGFyZSBmcm9tIDAgdG8gMjMuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdpZGVsdGEnLFxuICAgIGxhYmVsOiAnaWRlbHRhJyxcbiAgICBkZXRhaWw6ICdpZGVsdGEodiByYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ0NhbGN1bGF0ZXMgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgbGFzdCB0d28gc2FtcGxlcyBpbiB0aGUgcmFuZ2UgdmVjdG9yIGB2YCwgcmV0dXJuaW5nIGFuIGluc3RhbnQgdmVjdG9yIHdpdGggdGhlIGdpdmVuIGRlbHRhcyBhbmQgZXF1aXZhbGVudCBsYWJlbHMuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdpbmNyZWFzZScsXG4gICAgbGFiZWw6ICdpbmNyZWFzZScsXG4gICAgZGV0YWlsOiAnaW5jcmVhc2UodiByYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ0NhbGN1bGF0ZXMgdGhlIGluY3JlYXNlIGluIHRoZSB0aW1lIHNlcmllcyBpbiB0aGUgcmFuZ2UgdmVjdG9yLiBCcmVha3MgaW4gbW9ub3RvbmljaXR5IChzdWNoIGFzIGNvdW50ZXIgcmVzZXRzIGR1ZSB0byB0YXJnZXQgcmVzdGFydHMpIGFyZSBhdXRvbWF0aWNhbGx5IGFkanVzdGVkIGZvci4gVGhlIGluY3JlYXNlIGlzIGV4dHJhcG9sYXRlZCB0byBjb3ZlciB0aGUgZnVsbCB0aW1lIHJhbmdlIGFzIHNwZWNpZmllZCBpbiB0aGUgcmFuZ2UgdmVjdG9yIHNlbGVjdG9yLCBzbyB0aGF0IGl0IGlzIHBvc3NpYmxlIHRvIGdldCBhIG5vbi1pbnRlZ2VyIHJlc3VsdCBldmVuIGlmIGEgY291bnRlciBpbmNyZWFzZXMgb25seSBieSBpbnRlZ2VyIGluY3JlbWVudHMuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdpcmF0ZScsXG4gICAgbGFiZWw6ICdpcmF0ZScsXG4gICAgZGV0YWlsOiAnaXJhdGUodiByYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ0NhbGN1bGF0ZXMgdGhlIHBlci1zZWNvbmQgaW5zdGFudCByYXRlIG9mIGluY3JlYXNlIG9mIHRoZSB0aW1lIHNlcmllcyBpbiB0aGUgcmFuZ2UgdmVjdG9yLiBUaGlzIGlzIGJhc2VkIG9uIHRoZSBsYXN0IHR3byBkYXRhIHBvaW50cy4gQnJlYWtzIGluIG1vbm90b25pY2l0eSAoc3VjaCBhcyBjb3VudGVyIHJlc2V0cyBkdWUgdG8gdGFyZ2V0IHJlc3RhcnRzKSBhcmUgYXV0b21hdGljYWxseSBhZGp1c3RlZCBmb3IuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdsYWJlbF9qb2luJyxcbiAgICBsYWJlbDogJ2xhYmVsX2pvaW4nLFxuICAgIGRldGFpbDpcbiAgICAgICdsYWJlbF9qb2luKHYgaW5zdGFudC12ZWN0b3IsIGRzdF9sYWJlbCBzdHJpbmcsIHNlcGFyYXRvciBzdHJpbmcsIHNyY19sYWJlbF8xIHN0cmluZywgc3JjX2xhYmVsXzIgc3RyaW5nLCAuLi4pJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ0ZvciBlYWNoIHRpbWVzZXJpZXMgaW4gYHZgLCBqb2lucyBhbGwgdGhlIHZhbHVlcyBvZiBhbGwgdGhlIGBzcmNfbGFiZWxzYCB1c2luZyBgc2VwYXJhdG9yYCBhbmQgcmV0dXJucyB0aGUgdGltZXNlcmllcyB3aXRoIHRoZSBsYWJlbCBgZHN0X2xhYmVsYCBjb250YWluaW5nIHRoZSBqb2luZWQgdmFsdWUuIFRoZXJlIGNhbiBiZSBhbnkgbnVtYmVyIG9mIGBzcmNfbGFiZWxzYCBpbiB0aGlzIGZ1bmN0aW9uLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnbGFiZWxfcmVwbGFjZScsXG4gICAgbGFiZWw6ICdsYWJlbF9yZXBsYWNlJyxcbiAgICBkZXRhaWw6ICdsYWJlbF9yZXBsYWNlKHYgaW5zdGFudC12ZWN0b3IsIGRzdF9sYWJlbCBzdHJpbmcsIHJlcGxhY2VtZW50IHN0cmluZywgc3JjX2xhYmVsIHN0cmluZywgcmVnZXggc3RyaW5nKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgIFwiRm9yIGVhY2ggdGltZXNlcmllcyBpbiBgdmAsIGBsYWJlbF9yZXBsYWNlKHYgaW5zdGFudC12ZWN0b3IsIGRzdF9sYWJlbCBzdHJpbmcsIHJlcGxhY2VtZW50IHN0cmluZywgc3JjX2xhYmVsIHN0cmluZywgcmVnZXggc3RyaW5nKWAgIG1hdGNoZXMgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBgcmVnZXhgIGFnYWluc3QgdGhlIGxhYmVsIGBzcmNfbGFiZWxgLiAgSWYgaXQgbWF0Y2hlcywgdGhlbiB0aGUgdGltZXNlcmllcyBpcyByZXR1cm5lZCB3aXRoIHRoZSBsYWJlbCBgZHN0X2xhYmVsYCByZXBsYWNlZCBieSB0aGUgZXhwYW5zaW9uIG9mIGByZXBsYWNlbWVudGAuIGAkMWAgaXMgcmVwbGFjZWQgd2l0aCB0aGUgZmlyc3QgbWF0Y2hpbmcgc3ViZ3JvdXAsIGAkMmAgd2l0aCB0aGUgc2Vjb25kIGV0Yy4gSWYgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBkb2Vzbid0IG1hdGNoIHRoZW4gdGhlIHRpbWVzZXJpZXMgaXMgcmV0dXJuZWQgdW5jaGFuZ2VkLlwiLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2xuJyxcbiAgICBsYWJlbDogJ2xuJyxcbiAgICBkZXRhaWw6ICdsbih2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdDYWxjdWxhdGVzIHRoZSBuYXR1cmFsIGxvZ2FyaXRobSBmb3IgYWxsIGVsZW1lbnRzIGluIGB2YC5cXG5TcGVjaWFsIGNhc2VzIGFyZTpcXG4gKiBgbG4oK0luZikgPSArSW5mYFxcbiAqIGBsbigwKSA9IC1JbmZgXFxuICogYGxuKHggPCAwKSA9IE5hTmBcXG4gKiBgbG4oTmFOKSA9IE5hTmAnLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2xvZzInLFxuICAgIGxhYmVsOiAnbG9nMicsXG4gICAgZGV0YWlsOiAnbG9nMih2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdDYWxjdWxhdGVzIHRoZSBiaW5hcnkgbG9nYXJpdGhtIGZvciBhbGwgZWxlbWVudHMgaW4gYHZgLiBUaGUgc3BlY2lhbCBjYXNlcyBhcmUgZXF1aXZhbGVudCB0byB0aG9zZSBpbiBgbG5gLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnbG9nMTAnLFxuICAgIGxhYmVsOiAnbG9nMTAnLFxuICAgIGRldGFpbDogJ2xvZzEwKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ0NhbGN1bGF0ZXMgdGhlIGRlY2ltYWwgbG9nYXJpdGhtIGZvciBhbGwgZWxlbWVudHMgaW4gYHZgLiBUaGUgc3BlY2lhbCBjYXNlcyBhcmUgZXF1aXZhbGVudCB0byB0aG9zZSBpbiBgbG5gLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnbWludXRlJyxcbiAgICBsYWJlbDogJ21pbnV0ZScsXG4gICAgZGV0YWlsOiAnbWludXRlKHY9dmVjdG9yKHRpbWUoKSkgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ1JldHVybnMgdGhlIG1pbnV0ZSBvZiB0aGUgaG91ciBmb3IgZWFjaCBvZiB0aGUgZ2l2ZW4gdGltZXMgaW4gVVRDLiBSZXR1cm5lZCB2YWx1ZXMgYXJlIGZyb20gMCB0byA1OS4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ21vbnRoJyxcbiAgICBsYWJlbDogJ21vbnRoJyxcbiAgICBkZXRhaWw6ICdtb250aCh2PXZlY3Rvcih0aW1lKCkpIGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdSZXR1cm5zIHRoZSBtb250aCBvZiB0aGUgeWVhciBmb3IgZWFjaCBvZiB0aGUgZ2l2ZW4gdGltZXMgaW4gVVRDLiBSZXR1cm5lZCB2YWx1ZXMgYXJlIGZyb20gMSB0byAxMiwgd2hlcmUgMSBtZWFucyBKYW51YXJ5IGV0Yy4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3BpJyxcbiAgICBsYWJlbDogJ3BpJyxcbiAgICBkZXRhaWw6ICdwaSgpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnUmV0dXJucyBwaScsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAncHJlZGljdF9saW5lYXInLFxuICAgIGxhYmVsOiAncHJlZGljdF9saW5lYXInLFxuICAgIGRldGFpbDogJ3ByZWRpY3RfbGluZWFyKHYgcmFuZ2UtdmVjdG9yLCB0IHNjYWxhciknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnUHJlZGljdHMgdGhlIHZhbHVlIG9mIHRpbWUgc2VyaWVzIGB0YCBzZWNvbmRzIGZyb20gbm93LCBiYXNlZCBvbiB0aGUgcmFuZ2UgdmVjdG9yIGB2YCwgdXNpbmcgc2ltcGxlIGxpbmVhciByZWdyZXNzaW9uLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAncmFkJyxcbiAgICBsYWJlbDogJ3JhZCcsXG4gICAgZGV0YWlsOiAncmFkKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnQ29udmVydHMgZGVncmVlcyB0byByYWRpYW5zIGZvciBhbGwgZWxlbWVudHMgaW4gdicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAncmF0ZScsXG4gICAgbGFiZWw6ICdyYXRlJyxcbiAgICBkZXRhaWw6ICdyYXRlKHYgcmFuZ2UtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgIFwiQ2FsY3VsYXRlcyB0aGUgcGVyLXNlY29uZCBhdmVyYWdlIHJhdGUgb2YgaW5jcmVhc2Ugb2YgdGhlIHRpbWUgc2VyaWVzIGluIHRoZSByYW5nZSB2ZWN0b3IuIEJyZWFrcyBpbiBtb25vdG9uaWNpdHkgKHN1Y2ggYXMgY291bnRlciByZXNldHMgZHVlIHRvIHRhcmdldCByZXN0YXJ0cykgYXJlIGF1dG9tYXRpY2FsbHkgYWRqdXN0ZWQgZm9yLiBBbHNvLCB0aGUgY2FsY3VsYXRpb24gZXh0cmFwb2xhdGVzIHRvIHRoZSBlbmRzIG9mIHRoZSB0aW1lIHJhbmdlLCBhbGxvd2luZyBmb3IgbWlzc2VkIHNjcmFwZXMgb3IgaW1wZXJmZWN0IGFsaWdubWVudCBvZiBzY3JhcGUgY3ljbGVzIHdpdGggdGhlIHJhbmdlJ3MgdGltZSBwZXJpb2QuXCIsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAncmVzZXRzJyxcbiAgICBsYWJlbDogJ3Jlc2V0cycsXG4gICAgZGV0YWlsOiAncmVzZXRzKHYgcmFuZ2UtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdGb3IgZWFjaCBpbnB1dCB0aW1lIHNlcmllcywgYHJlc2V0cyh2IHJhbmdlLXZlY3RvcilgIHJldHVybnMgdGhlIG51bWJlciBvZiBjb3VudGVyIHJlc2V0cyB3aXRoaW4gdGhlIHByb3ZpZGVkIHRpbWUgcmFuZ2UgYXMgYW4gaW5zdGFudCB2ZWN0b3IuIEFueSBkZWNyZWFzZSBpbiB0aGUgdmFsdWUgYmV0d2VlbiB0d28gY29uc2VjdXRpdmUgc2FtcGxlcyBpcyBpbnRlcnByZXRlZCBhcyBhIGNvdW50ZXIgcmVzZXQuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdyb3VuZCcsXG4gICAgbGFiZWw6ICdyb3VuZCcsXG4gICAgZGV0YWlsOiAncm91bmQodiBpbnN0YW50LXZlY3RvciwgdG9fbmVhcmVzdD0xIHNjYWxhciknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnUm91bmRzIHRoZSBzYW1wbGUgdmFsdWVzIG9mIGFsbCBlbGVtZW50cyBpbiBgdmAgdG8gdGhlIG5lYXJlc3QgaW50ZWdlci4gVGllcyBhcmUgcmVzb2x2ZWQgYnkgcm91bmRpbmcgdXAuIFRoZSBvcHRpb25hbCBgdG9fbmVhcmVzdGAgYXJndW1lbnQgYWxsb3dzIHNwZWNpZnlpbmcgdGhlIG5lYXJlc3QgbXVsdGlwbGUgdG8gd2hpY2ggdGhlIHNhbXBsZSB2YWx1ZXMgc2hvdWxkIGJlIHJvdW5kZWQuIFRoaXMgbXVsdGlwbGUgbWF5IGFsc28gYmUgYSBmcmFjdGlvbi4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3NjYWxhcicsXG4gICAgbGFiZWw6ICdzY2FsYXInLFxuICAgIGRldGFpbDogJ3NjYWxhcih2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdHaXZlbiBhIHNpbmdsZS1lbGVtZW50IGlucHV0IHZlY3RvciwgYHNjYWxhcih2IGluc3RhbnQtdmVjdG9yKWAgcmV0dXJucyB0aGUgc2FtcGxlIHZhbHVlIG9mIHRoYXQgc2luZ2xlIGVsZW1lbnQgYXMgYSBzY2FsYXIuIElmIHRoZSBpbnB1dCB2ZWN0b3IgZG9lcyBub3QgaGF2ZSBleGFjdGx5IG9uZSBlbGVtZW50LCBgc2NhbGFyYCB3aWxsIHJldHVybiBgTmFOYC4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3NnbicsXG4gICAgbGFiZWw6ICdzZ24nLFxuICAgIGRldGFpbDogJ3Nnbih2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdSZXR1cm5zIGEgdmVjdG9yIHdpdGggYWxsIHNhbXBsZSB2YWx1ZXMgY29udmVydGVkIHRvIHRoZWlyIHNpZ24sIGRlZmluZWQgYXMgdGhpczogMSBpZiB2IGlzIHBvc2l0aXZlLCAtMSBpZiB2IGlzIG5lZ2F0aXZlIGFuZCAwIGlmIHYgaXMgZXF1YWwgdG8gemVyby4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3NvcnQnLFxuICAgIGxhYmVsOiAnc29ydCcsXG4gICAgZGV0YWlsOiAnc29ydCh2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1JldHVybnMgdmVjdG9yIGVsZW1lbnRzIHNvcnRlZCBieSB0aGVpciBzYW1wbGUgdmFsdWVzLCBpbiBhc2NlbmRpbmcgb3JkZXIuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdzb3J0X2Rlc2MnLFxuICAgIGxhYmVsOiAnc29ydF9kZXNjJyxcbiAgICBkZXRhaWw6ICdzb3J0X2Rlc2ModiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdSZXR1cm5zIHZlY3RvciBlbGVtZW50cyBzb3J0ZWQgYnkgdGhlaXIgc2FtcGxlIHZhbHVlcywgaW4gZGVzY2VuZGluZyBvcmRlci4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3NxcnQnLFxuICAgIGxhYmVsOiAnc3FydCcsXG4gICAgZGV0YWlsOiAnc3FydCh2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ0NhbGN1bGF0ZXMgdGhlIHNxdWFyZSByb290IG9mIGFsbCBlbGVtZW50cyBpbiBgdmAuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICd0aW1lJyxcbiAgICBsYWJlbDogJ3RpbWUnLFxuICAgIGRldGFpbDogJ3RpbWUoKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdSZXR1cm5zIHRoZSBudW1iZXIgb2Ygc2Vjb25kcyBzaW5jZSBKYW51YXJ5IDEsIDE5NzAgVVRDLiBOb3RlIHRoYXQgdGhpcyBkb2VzIG5vdCBhY3R1YWxseSByZXR1cm4gdGhlIGN1cnJlbnQgdGltZSwgYnV0IHRoZSB0aW1lIGF0IHdoaWNoIHRoZSBleHByZXNzaW9uIGlzIHRvIGJlIGV2YWx1YXRlZC4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3RpbWVzdGFtcCcsXG4gICAgbGFiZWw6ICd0aW1lc3RhbXAnLFxuICAgIGRldGFpbDogJ3RpbWVzdGFtcCh2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdSZXR1cm5zIHRoZSB0aW1lc3RhbXAgb2YgZWFjaCBvZiB0aGUgc2FtcGxlcyBvZiB0aGUgZ2l2ZW4gdmVjdG9yIGFzIHRoZSBudW1iZXIgb2Ygc2Vjb25kcyBzaW5jZSBKYW51YXJ5IDEsIDE5NzAgVVRDLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAndmVjdG9yJyxcbiAgICBsYWJlbDogJ3ZlY3RvcicsXG4gICAgZGV0YWlsOiAndmVjdG9yKHMgc2NhbGFyKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1JldHVybnMgdGhlIHNjYWxhciBgc2AgYXMgYSB2ZWN0b3Igd2l0aCBubyBsYWJlbHMuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICd5ZWFyJyxcbiAgICBsYWJlbDogJ3llYXInLFxuICAgIGRldGFpbDogJ3llYXIodj12ZWN0b3IodGltZSgpKSBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdSZXR1cm5zIHRoZSB5ZWFyIGZvciBlYWNoIG9mIHRoZSBnaXZlbiB0aW1lcyBpbiBVVEMuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdhdmdfb3Zlcl90aW1lJyxcbiAgICBsYWJlbDogJ2F2Z19vdmVyX3RpbWUnLFxuICAgIGRldGFpbDogJ2F2Z19vdmVyX3RpbWUocmFuZ2UtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1RoZSBhdmVyYWdlIHZhbHVlIG9mIGFsbCBwb2ludHMgaW4gdGhlIHNwZWNpZmllZCBpbnRlcnZhbC4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ21pbl9vdmVyX3RpbWUnLFxuICAgIGxhYmVsOiAnbWluX292ZXJfdGltZScsXG4gICAgZGV0YWlsOiAnbWluX292ZXJfdGltZShyYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnVGhlIG1pbmltdW0gdmFsdWUgb2YgYWxsIHBvaW50cyBpbiB0aGUgc3BlY2lmaWVkIGludGVydmFsLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnbWF4X292ZXJfdGltZScsXG4gICAgbGFiZWw6ICdtYXhfb3Zlcl90aW1lJyxcbiAgICBkZXRhaWw6ICdtYXhfb3Zlcl90aW1lKHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdUaGUgbWF4aW11bSB2YWx1ZSBvZiBhbGwgcG9pbnRzIGluIHRoZSBzcGVjaWZpZWQgaW50ZXJ2YWwuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdzdW1fb3Zlcl90aW1lJyxcbiAgICBsYWJlbDogJ3N1bV9vdmVyX3RpbWUnLFxuICAgIGRldGFpbDogJ3N1bV9vdmVyX3RpbWUocmFuZ2UtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1RoZSBzdW0gb2YgYWxsIHZhbHVlcyBpbiB0aGUgc3BlY2lmaWVkIGludGVydmFsLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnY291bnRfb3Zlcl90aW1lJyxcbiAgICBsYWJlbDogJ2NvdW50X292ZXJfdGltZScsXG4gICAgZGV0YWlsOiAnY291bnRfb3Zlcl90aW1lKHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdUaGUgY291bnQgb2YgYWxsIHZhbHVlcyBpbiB0aGUgc3BlY2lmaWVkIGludGVydmFsLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAncXVhbnRpbGVfb3Zlcl90aW1lJyxcbiAgICBsYWJlbDogJ3F1YW50aWxlX292ZXJfdGltZScsXG4gICAgZGV0YWlsOiAncXVhbnRpbGVfb3Zlcl90aW1lKHNjYWxhciwgcmFuZ2UtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1RoZSDPhi1xdWFudGlsZSAoMCDiiaQgz4Yg4omkIDEpIG9mIHRoZSB2YWx1ZXMgaW4gdGhlIHNwZWNpZmllZCBpbnRlcnZhbC4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3N0ZGRldl9vdmVyX3RpbWUnLFxuICAgIGxhYmVsOiAnc3RkZGV2X292ZXJfdGltZScsXG4gICAgZGV0YWlsOiAnc3RkZGV2X292ZXJfdGltZShyYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnVGhlIHBvcHVsYXRpb24gc3RhbmRhcmQgZGV2aWF0aW9uIG9mIHRoZSB2YWx1ZXMgaW4gdGhlIHNwZWNpZmllZCBpbnRlcnZhbC4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3N0ZHZhcl9vdmVyX3RpbWUnLFxuICAgIGxhYmVsOiAnc3RkdmFyX292ZXJfdGltZScsXG4gICAgZGV0YWlsOiAnc3RkdmFyX292ZXJfdGltZShyYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnVGhlIHBvcHVsYXRpb24gc3RhbmRhcmQgdmFyaWFuY2Ugb2YgdGhlIHZhbHVlcyBpbiB0aGUgc3BlY2lmaWVkIGludGVydmFsLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnbGFzdF9vdmVyX3RpbWUnLFxuICAgIGxhYmVsOiAnbGFzdF9vdmVyX3RpbWUnLFxuICAgIGRldGFpbDogJ2xhc3Rfb3Zlcl90aW1lKHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdUaGUgbW9zdCByZWNlbnQgcG9pbnQgdmFsdWUgaW4gc3BlY2lmaWVkIGludGVydmFsLicsXG4gIH0sXG5dO1xuXG5leHBvcnQgY29uc3QgUFJPTV9LRVlXT1JEUyA9IEZVTkNUSU9OUy5tYXAoKGtleXdvcmQpID0+IGtleXdvcmQubGFiZWwpO1xuXG5leHBvcnQgY29uc3QgcHJvbXFsR3JhbW1hcjogR3JhbW1hciA9IHtcbiAgY29tbWVudDoge1xuICAgIHBhdHRlcm46IC8jLiovLFxuICB9LFxuICAnY29udGV4dC1hZ2dyZWdhdGlvbic6IHtcbiAgICBwYXR0ZXJuOiAvKChieXx3aXRob3V0KVxccyopXFwoW14pXSpcXCkvLCAvLyBieSAoKVxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgaW5zaWRlOiB7XG4gICAgICAnbGFiZWwta2V5Jzoge1xuICAgICAgICBwYXR0ZXJuOiAvW14oKSxcXHNdW14sKV0qW14pLFxcc10qLyxcbiAgICAgICAgYWxpYXM6ICdhdHRyLW5hbWUnLFxuICAgICAgfSxcbiAgICAgIHB1bmN0dWF0aW9uOiAvWygpXS8sXG4gICAgfSxcbiAgfSxcbiAgJ2NvbnRleHQtbGFiZWxzJzoge1xuICAgIHBhdHRlcm46IC9cXHtbXn1dKig/PX0/KS8sXG4gICAgZ3JlZWR5OiB0cnVlLFxuICAgIGluc2lkZToge1xuICAgICAgY29tbWVudDoge1xuICAgICAgICBwYXR0ZXJuOiAvIy4qLyxcbiAgICAgIH0sXG4gICAgICAnbGFiZWwta2V5Jzoge1xuICAgICAgICBwYXR0ZXJuOiAvW2Etel9dXFx3Kig/PVxccyooPXwhPXw9fnwhfikpLyxcbiAgICAgICAgYWxpYXM6ICdhdHRyLW5hbWUnLFxuICAgICAgICBncmVlZHk6IHRydWUsXG4gICAgICB9LFxuICAgICAgJ2xhYmVsLXZhbHVlJzoge1xuICAgICAgICBwYXR0ZXJuOiAvXCIoPzpcXFxcLnxbXlxcXFxcIl0pKlwiLyxcbiAgICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgICBhbGlhczogJ2F0dHItdmFsdWUnLFxuICAgICAgfSxcbiAgICAgIHB1bmN0dWF0aW9uOiAvW3tdLyxcbiAgICB9LFxuICB9LFxuICBmdW5jdGlvbjogbmV3IFJlZ0V4cChgXFxcXGIoPzoke0ZVTkNUSU9OUy5tYXAoKGYpID0+IGYubGFiZWwpLmpvaW4oJ3wnKX0pKD89XFxcXHMqXFxcXCgpYCwgJ2knKSxcbiAgJ2NvbnRleHQtcmFuZ2UnOiBbXG4gICAge1xuICAgICAgcGF0dGVybjogL1xcW1teXFxdXSooPz1dKS8sIC8vIFsxbV1cbiAgICAgIGluc2lkZToge1xuICAgICAgICAncmFuZ2UtZHVyYXRpb24nOiB7XG4gICAgICAgICAgcGF0dGVybjogL1xcYlxcZCtbc21oZHd5XVxcYi9pLFxuICAgICAgICAgIGFsaWFzOiAnbnVtYmVyJyxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICBwYXR0ZXJuOiAvKG9mZnNldFxccyspXFx3Ky8sIC8vIG9mZnNldCAxbVxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAncmFuZ2UtZHVyYXRpb24nOiB7XG4gICAgICAgICAgcGF0dGVybjogL1xcYlxcZCtbc21oZHd5XVxcYi9pLFxuICAgICAgICAgIGFsaWFzOiAnbnVtYmVyJyxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSxcbiAgXSxcbiAgaWRMaXN0OiB7XG4gICAgcGF0dGVybjogL1xcZCsoXFx8XFxkKykrLyxcbiAgICBhbGlhczogJ251bWJlcicsXG4gIH0sXG4gIG51bWJlcjogL1xcYi0/XFxkKygoXFwuXFxkKik/KFtlRV1bKy1dP1xcZCspPyk/XFxiLyxcbiAgb3BlcmF0b3I6IG5ldyBSZWdFeHAoYC9bLSsqLz0lXn5dfCYmP3xcXFxcfD9cXFxcfHwhPT98PCg/Oj0+P3w8fD4pP3w+Wz49XT98XFxcXGIoPzoke09QRVJBVE9SUy5qb2luKCd8Jyl9KVxcXFxiYCwgJ2knKSxcbiAgcHVuY3R1YXRpb246IC9be307KClgLC5dLyxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHByb21xbEdyYW1tYXI7XG4iLCJpbXBvcnQgeyBzaXplIH0gZnJvbSAnbG9kYXNoJztcblxuaW1wb3J0IHsgUXVlcnlIaW50LCBRdWVyeUZpeCB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuXG5pbXBvcnQgeyBQcm9tZXRoZXVzRGF0YXNvdXJjZSB9IGZyb20gJy4vZGF0YXNvdXJjZSc7XG5cbi8qKlxuICogTnVtYmVyIG9mIHRpbWUgc2VyaWVzIHJlc3VsdHMgbmVlZGVkIGJlZm9yZSBzdGFydGluZyB0byBzdWdnZXN0IHN1bSBhZ2dyZWdhdGlvbiBoaW50c1xuICovXG5leHBvcnQgY29uc3QgU1VNX0hJTlRfVEhSRVNIT0xEX0NPVU5UID0gMjA7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRRdWVyeUhpbnRzKHF1ZXJ5OiBzdHJpbmcsIHNlcmllcz86IGFueVtdLCBkYXRhc291cmNlPzogUHJvbWV0aGV1c0RhdGFzb3VyY2UpOiBRdWVyeUhpbnRbXSB7XG4gIGNvbnN0IGhpbnRzID0gW107XG5cbiAgLy8gLi4uX2J1Y2tldCBtZXRyaWMgbmVlZHMgYSBoaXN0b2dyYW1fcXVhbnRpbGUoKVxuICBjb25zdCBoaXN0b2dyYW1NZXRyaWMgPSBxdWVyeS50cmltKCkubWF0Y2goL15cXHcrX2J1Y2tldCR8XlxcdytfYnVja2V0ey4qfSQvKTtcbiAgaWYgKGhpc3RvZ3JhbU1ldHJpYykge1xuICAgIGNvbnN0IGxhYmVsID0gJ1NlbGVjdGVkIG1ldHJpYyBoYXMgYnVja2V0cy4nO1xuICAgIGhpbnRzLnB1c2goe1xuICAgICAgdHlwZTogJ0hJU1RPR1JBTV9RVUFOVElMRScsXG4gICAgICBsYWJlbCxcbiAgICAgIGZpeDoge1xuICAgICAgICBsYWJlbDogJ0NvbnNpZGVyIGNhbGN1bGF0aW5nIGFnZ3JlZ2F0ZWQgcXVhbnRpbGUgYnkgYWRkaW5nIGhpc3RvZ3JhbV9xdWFudGlsZSgpLicsXG4gICAgICAgIGFjdGlvbjoge1xuICAgICAgICAgIHR5cGU6ICdBRERfSElTVE9HUkFNX1FVQU5USUxFJyxcbiAgICAgICAgICBxdWVyeSxcbiAgICAgICAgfSxcbiAgICAgIH0gYXMgUXVlcnlGaXgsXG4gICAgfSk7XG4gIH1cblxuICAvLyBDaGVjayBmb3IgbmVlZCBvZiByYXRlKClcbiAgaWYgKHF1ZXJ5LmluZGV4T2YoJ3JhdGUoJykgPT09IC0xICYmIHF1ZXJ5LmluZGV4T2YoJ2luY3JlYXNlKCcpID09PSAtMSkge1xuICAgIC8vIFVzZSBtZXRyaWMgbWV0YWRhdGEgZm9yIGV4YWN0IHR5cGVzXG4gICAgY29uc3QgbmFtZU1hdGNoID0gcXVlcnkubWF0Y2goL1xcYihcXHcrXyh0b3RhbHxzdW18Y291bnQpKVxcYi8pO1xuICAgIGxldCBjb3VudGVyTmFtZU1ldHJpYyA9IG5hbWVNYXRjaCA/IG5hbWVNYXRjaFsxXSA6ICcnO1xuICAgIGNvbnN0IG1ldHJpY3NNZXRhZGF0YSA9IGRhdGFzb3VyY2U/Lmxhbmd1YWdlUHJvdmlkZXI/Lm1ldHJpY3NNZXRhZGF0YSA/PyB7fTtcbiAgICBjb25zdCBtZXRyaWNNZXRhZGF0YUtleXMgPSBPYmplY3Qua2V5cyhtZXRyaWNzTWV0YWRhdGEpO1xuICAgIGxldCBjZXJ0YWluID0gZmFsc2U7XG5cbiAgICBpZiAobWV0cmljTWV0YWRhdGFLZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvdW50ZXJOYW1lTWV0cmljID1cbiAgICAgICAgbWV0cmljTWV0YWRhdGFLZXlzLmZpbmQoKG1ldHJpY05hbWUpID0+IHtcbiAgICAgICAgICAvLyBPbmx5IGNvbnNpZGVyaW5nIGZpcnN0IHR5cGUgaW5mb3JtYXRpb24sIGNvdWxkIGJlIG5vbi1kZXRlcm1pbmlzdGljXG4gICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBtZXRyaWNzTWV0YWRhdGFbbWV0cmljTmFtZV07XG4gICAgICAgICAgaWYgKG1ldGFkYXRhLnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ2NvdW50ZXInKSB7XG4gICAgICAgICAgICBjb25zdCBtZXRyaWNSZWdleCA9IG5ldyBSZWdFeHAoYFxcXFxiJHttZXRyaWNOYW1lfVxcXFxiYCk7XG4gICAgICAgICAgICBpZiAocXVlcnkubWF0Y2gobWV0cmljUmVnZXgpKSB7XG4gICAgICAgICAgICAgIGNlcnRhaW4gPSB0cnVlO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KSA/PyAnJztcbiAgICB9XG5cbiAgICBpZiAoY291bnRlck5hbWVNZXRyaWMpIHtcbiAgICAgIC8vIEZpeGFibGVRdWVyeSBjb25zaXN0cyBvZiBtZXRyaWMgbmFtZSBhbmQgb3B0aW9uYWxseSBsYWJlbC12YWx1ZSBwYWlycy4gV2UgYXJlIG5vdCBvZmZlcmluZyBmaXggZm9yIGNvbXBsZXggcXVlcmllcyB5ZXQuXG4gICAgICBjb25zdCBmaXhhYmxlUXVlcnkgPSBxdWVyeS50cmltKCkubWF0Y2goL15cXHcrJHxeXFx3K3suKn0kLyk7XG4gICAgICBjb25zdCB2ZXJiID0gY2VydGFpbiA/ICdpcycgOiAnbG9va3MgbGlrZSc7XG4gICAgICBsZXQgbGFiZWwgPSBgU2VsZWN0ZWQgbWV0cmljICR7dmVyYn0gYSBjb3VudGVyLmA7XG4gICAgICBsZXQgZml4OiBRdWVyeUZpeCB8IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGZpeGFibGVRdWVyeSkge1xuICAgICAgICBmaXggPSB7XG4gICAgICAgICAgbGFiZWw6ICdDb25zaWRlciBjYWxjdWxhdGluZyByYXRlIG9mIGNvdW50ZXIgYnkgYWRkaW5nIHJhdGUoKS4nLFxuICAgICAgICAgIGFjdGlvbjoge1xuICAgICAgICAgICAgdHlwZTogJ0FERF9SQVRFJyxcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYWJlbCA9IGAke2xhYmVsfSBDb25zaWRlciBjYWxjdWxhdGluZyByYXRlIG9mIGNvdW50ZXIgYnkgYWRkaW5nIHJhdGUoKS5gO1xuICAgICAgfVxuXG4gICAgICBoaW50cy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ0FQUExZX1JBVEUnLFxuICAgICAgICBsYWJlbCxcbiAgICAgICAgZml4LFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIHJlY29yZGluZyBydWxlcyBleHBhbnNpb25cbiAgaWYgKGRhdGFzb3VyY2UgJiYgZGF0YXNvdXJjZS5ydWxlTWFwcGluZ3MpIHtcbiAgICBjb25zdCBtYXBwaW5nID0gZGF0YXNvdXJjZS5ydWxlTWFwcGluZ3M7XG4gICAgY29uc3QgbWFwcGluZ0ZvclF1ZXJ5ID0gT2JqZWN0LmtleXMobWFwcGluZykucmVkdWNlKChhY2MsIHJ1bGVOYW1lKSA9PiB7XG4gICAgICBpZiAocXVlcnkuc2VhcmNoKHJ1bGVOYW1lKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uYWNjLFxuICAgICAgICAgIFtydWxlTmFtZV06IG1hcHBpbmdbcnVsZU5hbWVdLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gICAgaWYgKHNpemUobWFwcGluZ0ZvclF1ZXJ5KSA+IDApIHtcbiAgICAgIGNvbnN0IGxhYmVsID0gJ1F1ZXJ5IGNvbnRhaW5zIHJlY29yZGluZyBydWxlcy4nO1xuICAgICAgaGludHMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdFWFBBTkRfUlVMRVMnLFxuICAgICAgICBsYWJlbCxcbiAgICAgICAgZml4OiB7XG4gICAgICAgICAgbGFiZWw6ICdFeHBhbmQgcnVsZXMnLFxuICAgICAgICAgIGFjdGlvbjoge1xuICAgICAgICAgICAgdHlwZTogJ0VYUEFORF9SVUxFUycsXG4gICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgIG1hcHBpbmc6IG1hcHBpbmdGb3JRdWVyeSxcbiAgICAgICAgICB9LFxuICAgICAgICB9IGFzIGFueSBhcyBRdWVyeUZpeCxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzZXJpZXMgJiYgc2VyaWVzLmxlbmd0aCA+PSBTVU1fSElOVF9USFJFU0hPTERfQ09VTlQpIHtcbiAgICBjb25zdCBzaW1wbGVNZXRyaWMgPSBxdWVyeS50cmltKCkubWF0Y2goL15cXHcrJC8pO1xuICAgIGlmIChzaW1wbGVNZXRyaWMpIHtcbiAgICAgIGhpbnRzLnB1c2goe1xuICAgICAgICB0eXBlOiAnQUREX1NVTScsXG4gICAgICAgIGxhYmVsOiAnTWFueSB0aW1lIHNlcmllcyByZXN1bHRzIHJldHVybmVkLicsXG4gICAgICAgIGZpeDoge1xuICAgICAgICAgIGxhYmVsOiAnQ29uc2lkZXIgYWdncmVnYXRpbmcgd2l0aCBzdW0oKS4nLFxuICAgICAgICAgIGFjdGlvbjoge1xuICAgICAgICAgICAgdHlwZTogJ0FERF9TVU0nLFxuICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICAgICAgcHJldmVudFN1Ym1pdDogdHJ1ZSxcbiAgICAgICAgICB9LFxuICAgICAgICB9IGFzIFF1ZXJ5Rml4LFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGhpbnRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW5pdEhpbnRzKGRhdGFzb3VyY2U6IFByb21ldGhldXNEYXRhc291cmNlKTogUXVlcnlIaW50W10ge1xuICBjb25zdCBoaW50cyA9IFtdO1xuICAvLyBIaW50IGlmIHVzaW5nIExva2kgYXMgUHJvbWV0aGV1cyBkYXRhIHNvdXJjZVxuICBpZiAoZGF0YXNvdXJjZS5kaXJlY3RVcmwuaW5jbHVkZXMoJy9sb2tpJykgJiYgIWRhdGFzb3VyY2UubGFuZ3VhZ2VQcm92aWRlci5tZXRyaWNzLmxlbmd0aCkge1xuICAgIGhpbnRzLnB1c2goe1xuICAgICAgbGFiZWw6IGBVc2luZyBMb2tpIGFzIGEgUHJvbWV0aGV1cyBkYXRhIHNvdXJjZSBpcyBubyBsb25nZXIgc3VwcG9ydGVkLiBZb3UgbXVzdCB1c2UgdGhlIExva2kgZGF0YSBzb3VyY2UgZm9yIHlvdXIgTG9raSBpbnN0YW5jZS5gLFxuICAgICAgdHlwZTogJ0lORk8nLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gSGludCBmb3IgYmlnIGRpc2FibGVkIGxvb2t1cHNcbiAgaWYgKGRhdGFzb3VyY2UubG9va3Vwc0Rpc2FibGVkKSB7XG4gICAgaGludHMucHVzaCh7XG4gICAgICBsYWJlbDogYExhYmVscyBhbmQgbWV0cmljcyBsb29rdXAgd2FzIGRpc2FibGVkIGluIGRhdGEgc291cmNlIHNldHRpbmdzLmAsXG4gICAgICB0eXBlOiAnSU5GTycsXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gaGludHM7XG59XG4iLCJpbXBvcnQgeyBGVU5DVElPTlMgfSBmcm9tICcuLi9wcm9tcWwnO1xuXG5pbXBvcnQgeyBnZXRBZ2dyZWdhdGlvbk9wZXJhdGlvbnMgfSBmcm9tICcuL2FnZ3JlZ2F0aW9ucyc7XG5pbXBvcnQgeyBnZXRPcGVyYXRpb25EZWZpbml0aW9ucyB9IGZyb20gJy4vb3BlcmF0aW9ucyc7XG5pbXBvcnQgeyBMb2tpQW5kUHJvbVF1ZXJ5TW9kZWxsZXJCYXNlIH0gZnJvbSAnLi9zaGFyZWQvTG9raUFuZFByb21RdWVyeU1vZGVsbGVyQmFzZSc7XG5pbXBvcnQgeyBQcm9tUXVlcnlQYXR0ZXJuLCBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeSB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgUHJvbVF1ZXJ5TW9kZWxsZXIgZXh0ZW5kcyBMb2tpQW5kUHJvbVF1ZXJ5TW9kZWxsZXJCYXNlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKCkgPT4ge1xuICAgICAgY29uc3QgYWxsT3BlcmF0aW9ucyA9IFsuLi5nZXRPcGVyYXRpb25EZWZpbml0aW9ucygpLCAuLi5nZXRBZ2dyZWdhdGlvbk9wZXJhdGlvbnMoKV07XG4gICAgICBmb3IgKGNvbnN0IG9wIG9mIGFsbE9wZXJhdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZnVuYyA9IEZVTkNUSU9OUy5maW5kKCh4KSA9PiB4Lmluc2VydFRleHQgPT09IG9wLmlkKTtcbiAgICAgICAgaWYgKGZ1bmMpIHtcbiAgICAgICAgICBvcC5kb2N1bWVudGF0aW9uID0gZnVuYy5kb2N1bWVudGF0aW9uO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYWxsT3BlcmF0aW9ucztcbiAgICB9KTtcblxuICAgIHRoaXMuc2V0T3BlcmF0aW9uQ2F0ZWdvcmllcyhbXG4gICAgICBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5BZ2dyZWdhdGlvbnMsXG4gICAgICBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5SYW5nZUZ1bmN0aW9ucyxcbiAgICAgIFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkZ1bmN0aW9ucyxcbiAgICAgIFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkJpbmFyeU9wcyxcbiAgICAgIFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlRyaWdvbm9tZXRyaWMsXG4gICAgICBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5UaW1lLFxuICAgIF0pO1xuICB9XG5cbiAgZ2V0UXVlcnlQYXR0ZXJucygpOiBQcm9tUXVlcnlQYXR0ZXJuW10ge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdSYXRlIHRoZW4gc3VtJyxcbiAgICAgICAgb3BlcmF0aW9uczogW1xuICAgICAgICAgIHsgaWQ6ICdyYXRlJywgcGFyYW1zOiBbJyRfX3JhdGVfaW50ZXJ2YWwnXSB9LFxuICAgICAgICAgIHsgaWQ6ICdzdW0nLCBwYXJhbXM6IFtdIH0sXG4gICAgICAgIF0sXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAnUmF0ZSB0aGVuIHN1bSBieShsYWJlbCkgdGhlbiBhdmcnLFxuICAgICAgICBvcGVyYXRpb25zOiBbXG4gICAgICAgICAgeyBpZDogJ3JhdGUnLCBwYXJhbXM6IFsnJF9fcmF0ZV9pbnRlcnZhbCddIH0sXG4gICAgICAgICAgeyBpZDogJ19fc3VtX2J5JywgcGFyYW1zOiBbJyddIH0sXG4gICAgICAgICAgeyBpZDogJ2F2ZycsIHBhcmFtczogW10gfSxcbiAgICAgICAgXSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdIaXN0b2dyYW0gcXVhbnRpbGUgb24gcmF0ZScsXG4gICAgICAgIG9wZXJhdGlvbnM6IFtcbiAgICAgICAgICB7IGlkOiAncmF0ZScsIHBhcmFtczogWyckX19yYXRlX2ludGVydmFsJ10gfSxcbiAgICAgICAgICB7IGlkOiAnX19zdW1fYnknLCBwYXJhbXM6IFsnbGUnXSB9LFxuICAgICAgICAgIHsgaWQ6ICdoaXN0b2dyYW1fcXVhbnRpbGUnLCBwYXJhbXM6IFswLjk1XSB9LFxuICAgICAgICBdLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ0hpc3RvZ3JhbSBxdWFudGlsZSBvbiBpbmNyZWFzZSAnLFxuICAgICAgICBvcGVyYXRpb25zOiBbXG4gICAgICAgICAgeyBpZDogJ2luY3JlYXNlJywgcGFyYW1zOiBbJyRfX3JhdGVfaW50ZXJ2YWwnXSB9LFxuICAgICAgICAgIHsgaWQ6ICdfX21heF9ieScsIHBhcmFtczogWydsZSddIH0sXG4gICAgICAgICAgeyBpZDogJ2hpc3RvZ3JhbV9xdWFudGlsZScsIHBhcmFtczogWzAuOTVdIH0sXG4gICAgICAgIF0sXG4gICAgICB9LFxuICAgIF07XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHByb21RdWVyeU1vZGVsbGVyID0gbmV3IFByb21RdWVyeU1vZGVsbGVyKCk7XG4iLCJpbXBvcnQgeyBhZGRPcGVyYXRpb25XaXRoUmFuZ2VWZWN0b3IgfSBmcm9tICcuL29wZXJhdGlvbnMnO1xuaW1wb3J0IHtcbiAgY3JlYXRlQWdncmVnYXRpb25PcGVyYXRpb24sXG4gIGNyZWF0ZUFnZ3JlZ2F0aW9uT3BlcmF0aW9uV2l0aFBhcmFtLFxuICBnZXRQcm9tQW5kTG9raU9wZXJhdGlvbkRpc3BsYXlOYW1lLFxuICBnZXRSYW5nZVZlY3RvclBhcmFtRGVmLFxufSBmcm9tICcuL3NoYXJlZC9vcGVyYXRpb25VdGlscyc7XG5pbXBvcnQgeyBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sIFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiB9IGZyb20gJy4vc2hhcmVkL3R5cGVzJztcbmltcG9ydCB7IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LCBQcm9tT3BlcmF0aW9uSWQgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEFnZ3JlZ2F0aW9uT3BlcmF0aW9ucygpOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWZbXSB7XG4gIHJldHVybiBbXG4gICAgLi4uY3JlYXRlQWdncmVnYXRpb25PcGVyYXRpb24oUHJvbU9wZXJhdGlvbklkLlN1bSksXG4gICAgLi4uY3JlYXRlQWdncmVnYXRpb25PcGVyYXRpb24oUHJvbU9wZXJhdGlvbklkLkF2ZyksXG4gICAgLi4uY3JlYXRlQWdncmVnYXRpb25PcGVyYXRpb24oUHJvbU9wZXJhdGlvbklkLk1pbiksXG4gICAgLi4uY3JlYXRlQWdncmVnYXRpb25PcGVyYXRpb24oUHJvbU9wZXJhdGlvbklkLk1heCksXG4gICAgLi4uY3JlYXRlQWdncmVnYXRpb25PcGVyYXRpb24oUHJvbU9wZXJhdGlvbklkLkNvdW50KSxcbiAgICAuLi5jcmVhdGVBZ2dyZWdhdGlvbk9wZXJhdGlvbldpdGhQYXJhbShQcm9tT3BlcmF0aW9uSWQuVG9wSywge1xuICAgICAgcGFyYW1zOiBbeyBuYW1lOiAnSy12YWx1ZScsIHR5cGU6ICdudW1iZXInIH1dLFxuICAgICAgZGVmYXVsdFBhcmFtczogWzVdLFxuICAgIH0pLFxuICAgIC4uLmNyZWF0ZUFnZ3JlZ2F0aW9uT3BlcmF0aW9uV2l0aFBhcmFtKFByb21PcGVyYXRpb25JZC5Cb3R0b21LLCB7XG4gICAgICBwYXJhbXM6IFt7IG5hbWU6ICdLLXZhbHVlJywgdHlwZTogJ251bWJlcicgfV0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbNV0sXG4gICAgfSksXG4gICAgLi4uY3JlYXRlQWdncmVnYXRpb25PcGVyYXRpb25XaXRoUGFyYW0oUHJvbU9wZXJhdGlvbklkLkNvdW50VmFsdWVzLCB7XG4gICAgICBwYXJhbXM6IFt7IG5hbWU6ICdJZGVudGlmaWVyJywgdHlwZTogJ3N0cmluZycgfV0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbJ2NvdW50J10sXG4gICAgfSksXG4gICAgY3JlYXRlQWdncmVnYXRpb25PdmVyVGltZShQcm9tT3BlcmF0aW9uSWQuU3VtT3ZlclRpbWUpLFxuICAgIGNyZWF0ZUFnZ3JlZ2F0aW9uT3ZlclRpbWUoUHJvbU9wZXJhdGlvbklkLkF2Z092ZXJUaW1lKSxcbiAgICBjcmVhdGVBZ2dyZWdhdGlvbk92ZXJUaW1lKFByb21PcGVyYXRpb25JZC5NaW5PdmVyVGltZSksXG4gICAgY3JlYXRlQWdncmVnYXRpb25PdmVyVGltZShQcm9tT3BlcmF0aW9uSWQuTWF4T3ZlclRpbWUpLFxuICAgIGNyZWF0ZUFnZ3JlZ2F0aW9uT3ZlclRpbWUoUHJvbU9wZXJhdGlvbklkLkNvdW50T3ZlclRpbWUpLFxuICAgIGNyZWF0ZUFnZ3JlZ2F0aW9uT3ZlclRpbWUoUHJvbU9wZXJhdGlvbklkLkxhc3RPdmVyVGltZSksXG4gICAgY3JlYXRlQWdncmVnYXRpb25PdmVyVGltZShQcm9tT3BlcmF0aW9uSWQuUHJlc2VudE92ZXJUaW1lKSxcbiAgICBjcmVhdGVBZ2dyZWdhdGlvbk92ZXJUaW1lKFByb21PcGVyYXRpb25JZC5BYnNlbnRPdmVyVGltZSksXG4gICAgY3JlYXRlQWdncmVnYXRpb25PdmVyVGltZShQcm9tT3BlcmF0aW9uSWQuU3RkZGV2T3ZlclRpbWUpLFxuICBdO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBZ2dyZWdhdGlvbk92ZXJUaW1lKG5hbWU6IHN0cmluZyk6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiB7XG4gIHJldHVybiB7XG4gICAgaWQ6IG5hbWUsXG4gICAgbmFtZTogZ2V0UHJvbUFuZExva2lPcGVyYXRpb25EaXNwbGF5TmFtZShuYW1lKSxcbiAgICBwYXJhbXM6IFtnZXRSYW5nZVZlY3RvclBhcmFtRGVmKCldLFxuICAgIGRlZmF1bHRQYXJhbXM6IFsnJF9faW50ZXJ2YWwnXSxcbiAgICBhbHRlcm5hdGl2ZXNLZXk6ICdvdmVydGltZSBmdW5jdGlvbicsXG4gICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlJhbmdlRnVuY3Rpb25zLFxuICAgIHJlbmRlcmVyOiBvcGVyYXRpb25XaXRoUmFuZ2VWZWN0b3JSZW5kZXJlcixcbiAgICBhZGRPcGVyYXRpb25IYW5kbGVyOiBhZGRPcGVyYXRpb25XaXRoUmFuZ2VWZWN0b3IsXG4gIH07XG59XG5cbmZ1bmN0aW9uIG9wZXJhdGlvbldpdGhSYW5nZVZlY3RvclJlbmRlcmVyKFxuICBtb2RlbDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLFxuICBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZixcbiAgaW5uZXJFeHByOiBzdHJpbmdcbikge1xuICBsZXQgcmFuZ2VWZWN0b3IgPSAobW9kZWwucGFyYW1zID8/IFtdKVswXSA/PyAnJF9faW50ZXJ2YWwnO1xuICByZXR1cm4gYCR7ZGVmLmlkfSgke2lubmVyRXhwcn1bJHtyYW5nZVZlY3Rvcn1dKWA7XG59XG4iLCJpbXBvcnQgeyBkZWZhdWx0QWRkT3BlcmF0aW9uSGFuZGxlciB9IGZyb20gJy4vc2hhcmVkL29wZXJhdGlvblV0aWxzJztcbmltcG9ydCB7IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiwgUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLCBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbURlZiB9IGZyb20gJy4vc2hhcmVkL3R5cGVzJztcbmltcG9ydCB7IFByb21PcGVyYXRpb25JZCwgUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGNvbnN0IGJpbmFyeVNjYWxhckRlZnMgPSBbXG4gIHtcbiAgICBpZDogUHJvbU9wZXJhdGlvbklkLkFkZGl0aW9uLFxuICAgIG5hbWU6ICdBZGQgc2NhbGFyJyxcbiAgICBzaWduOiAnKycsXG4gIH0sXG4gIHtcbiAgICBpZDogUHJvbU9wZXJhdGlvbklkLlN1YnRyYWN0aW9uLFxuICAgIG5hbWU6ICdTdWJ0cmFjdCBzY2FsYXInLFxuICAgIHNpZ246ICctJyxcbiAgfSxcbiAge1xuICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuTXVsdGlwbHlCeSxcbiAgICBuYW1lOiAnTXVsdGlwbHkgYnkgc2NhbGFyJyxcbiAgICBzaWduOiAnKicsXG4gIH0sXG4gIHtcbiAgICBpZDogUHJvbU9wZXJhdGlvbklkLkRpdmlkZUJ5LFxuICAgIG5hbWU6ICdEaXZpZGUgYnkgc2NhbGFyJyxcbiAgICBzaWduOiAnLycsXG4gIH0sXG4gIHtcbiAgICBpZDogUHJvbU9wZXJhdGlvbklkLk1vZHVsbyxcbiAgICBuYW1lOiAnTW9kdWxvIGJ5IHNjYWxhcicsXG4gICAgc2lnbjogJyUnLFxuICB9LFxuICB7XG4gICAgaWQ6IFByb21PcGVyYXRpb25JZC5FeHBvbmVudCxcbiAgICBuYW1lOiAnRXhwb25lbnQnLFxuICAgIHNpZ246ICdeJyxcbiAgfSxcbiAge1xuICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuRXF1YWxUbyxcbiAgICBuYW1lOiAnRXF1YWwgdG8nLFxuICAgIHNpZ246ICc9PScsXG4gICAgY29tcGFyaXNvbjogdHJ1ZSxcbiAgfSxcbiAge1xuICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuTm90RXF1YWxUbyxcbiAgICBuYW1lOiAnTm90IGVxdWFsIHRvJyxcbiAgICBzaWduOiAnIT0nLFxuICAgIGNvbXBhcmlzb246IHRydWUsXG4gIH0sXG4gIHtcbiAgICBpZDogUHJvbU9wZXJhdGlvbklkLkdyZWF0ZXJUaGFuLFxuICAgIG5hbWU6ICdHcmVhdGVyIHRoYW4nLFxuICAgIHNpZ246ICc+JyxcbiAgICBjb21wYXJpc29uOiB0cnVlLFxuICB9LFxuICB7XG4gICAgaWQ6IFByb21PcGVyYXRpb25JZC5MZXNzVGhhbixcbiAgICBuYW1lOiAnTGVzcyB0aGFuJyxcbiAgICBzaWduOiAnPCcsXG4gICAgY29tcGFyaXNvbjogdHJ1ZSxcbiAgfSxcbiAge1xuICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuR3JlYXRlck9yRXF1YWwsXG4gICAgbmFtZTogJ0dyZWF0ZXIgb3IgZXF1YWwgdG8nLFxuICAgIHNpZ246ICc+PScsXG4gICAgY29tcGFyaXNvbjogdHJ1ZSxcbiAgfSxcbiAge1xuICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuTGVzc09yRXF1YWwsXG4gICAgbmFtZTogJ0xlc3Mgb3IgZXF1YWwgdG8nLFxuICAgIHNpZ246ICc8PScsXG4gICAgY29tcGFyaXNvbjogdHJ1ZSxcbiAgfSxcbl07XG5cbmV4cG9ydCBjb25zdCBiaW5hcnlTY2FsYXJPcGVyYXRvclRvT3BlcmF0b3JOYW1lID0gYmluYXJ5U2NhbGFyRGVmcy5yZWR1Y2UoKGFjYywgZGVmKSA9PiB7XG4gIGFjY1tkZWYuc2lnbl0gPSB7XG4gICAgaWQ6IGRlZi5pZCxcbiAgICBjb21wYXJpc29uOiBkZWYuY29tcGFyaXNvbixcbiAgfTtcbiAgcmV0dXJuIGFjYztcbn0sIHt9IGFzIFJlY29yZDxzdHJpbmcsIHsgaWQ6IHN0cmluZzsgY29tcGFyaXNvbj86IGJvb2xlYW4gfT4pO1xuXG4vLyBOb3Qgc3VyZSBhYm91dCB0aGlzIG9uZS4gSXQgY291bGQgYWxzbyBiZSBhIG1vcmUgZ2VuZXJpYyAnU2ltcGxlIG1hdGggb3BlcmF0aW9uJyB3aGVyZSB1c2VyIHNwZWNpZmllc1xuLy8gYm90aCB0aGUgb3BlcmF0b3IgYW5kIHRoZSBvcGVyYW5kIGluIGEgc2luZ2xlIGlucHV0XG5leHBvcnQgY29uc3QgYmluYXJ5U2NhbGFyT3BlcmF0aW9uczogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmW10gPSBiaW5hcnlTY2FsYXJEZWZzLm1hcCgob3BEZWYpID0+IHtcbiAgY29uc3QgcGFyYW1zOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbURlZltdID0gW3sgbmFtZTogJ1ZhbHVlJywgdHlwZTogJ251bWJlcicgfV07XG4gIGNvbnN0IGRlZmF1bHRQYXJhbXM6IGFueVtdID0gWzJdO1xuICBpZiAob3BEZWYuY29tcGFyaXNvbikge1xuICAgIHBhcmFtcy5wdXNoKHtcbiAgICAgIG5hbWU6ICdCb29sJyxcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnSWYgY2hlY2tlZCBjb21wYXJpc29uIHdpbGwgcmV0dXJuIDAgb3IgMSBmb3IgdGhlIHZhbHVlIHJhdGhlciB0aGFuIGZpbHRlcmluZy4nLFxuICAgIH0pO1xuICAgIGRlZmF1bHRQYXJhbXMucHVzaChmYWxzZSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGlkOiBvcERlZi5pZCxcbiAgICBuYW1lOiBvcERlZi5uYW1lLFxuICAgIHBhcmFtcyxcbiAgICBkZWZhdWx0UGFyYW1zLFxuICAgIGFsdGVybmF0aXZlc0tleTogJ2JpbmFyeSBzY2FsYXIgb3BlcmF0aW9ucycsXG4gICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkJpbmFyeU9wcyxcbiAgICByZW5kZXJlcjogZ2V0U2ltcGxlQmluYXJ5UmVuZGVyZXIob3BEZWYuc2lnbiksXG4gICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogZGVmYXVsdEFkZE9wZXJhdGlvbkhhbmRsZXIsXG4gIH07XG59KTtcblxuZnVuY3Rpb24gZ2V0U2ltcGxlQmluYXJ5UmVuZGVyZXIob3BlcmF0b3I6IHN0cmluZykge1xuICByZXR1cm4gZnVuY3Rpb24gYmluYXJ5UmVuZGVyZXIobW9kZWw6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiwgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsIGlubmVyRXhwcjogc3RyaW5nKSB7XG4gICAgbGV0IHBhcmFtID0gbW9kZWwucGFyYW1zWzBdO1xuICAgIGxldCBib29sID0gJyc7XG4gICAgaWYgKG1vZGVsLnBhcmFtcy5sZW5ndGggPT09IDIpIHtcbiAgICAgIGJvb2wgPSBtb2RlbC5wYXJhbXNbMV0gPyAnIGJvb2wnIDogJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGAke2lubmVyRXhwcn0gJHtvcGVyYXRvcn0ke2Jvb2x9ICR7cGFyYW19YDtcbiAgfTtcbn1cbiIsImltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgRGF0YVNvdXJjZUFwaSwgU2VsZWN0YWJsZVZhbHVlLCB0b09wdGlvbiB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgU2VsZWN0IH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5pbXBvcnQgeyBQcm9tZXRoZXVzRGF0YXNvdXJjZSB9IGZyb20gJy4uLy4uL2RhdGFzb3VyY2UnO1xuaW1wb3J0IHsgcHJvbVF1ZXJ5TW9kZWxsZXIgfSBmcm9tICcuLi9Qcm9tUXVlcnlNb2RlbGxlcic7XG5pbXBvcnQgeyBnZXRPcGVyYXRpb25QYXJhbUlkIH0gZnJvbSAnLi4vc2hhcmVkL29wZXJhdGlvblV0aWxzJztcbmltcG9ydCB7IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyLCBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbUVkaXRvclByb3BzIH0gZnJvbSAnLi4vc2hhcmVkL3R5cGVzJztcbmltcG9ydCB7IFByb21WaXN1YWxRdWVyeSB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGZ1bmN0aW9uIExhYmVsUGFyYW1FZGl0b3Ioe1xuICBvbkNoYW5nZSxcbiAgaW5kZXgsXG4gIG9wZXJhdGlvbkluZGV4LFxuICB2YWx1ZSxcbiAgcXVlcnksXG4gIGRhdGFzb3VyY2UsXG59OiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbUVkaXRvclByb3BzKSB7XG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gdXNlU3RhdGU8e1xuICAgIG9wdGlvbnM/OiBBcnJheTxTZWxlY3RhYmxlVmFsdWU8YW55Pj47XG4gICAgaXNMb2FkaW5nPzogYm9vbGVhbjtcbiAgfT4oe30pO1xuXG4gIHJldHVybiAoXG4gICAgPFNlbGVjdFxuICAgICAgaW5wdXRJZD17Z2V0T3BlcmF0aW9uUGFyYW1JZChvcGVyYXRpb25JbmRleCwgaW5kZXgpfVxuICAgICAgYXV0b0ZvY3VzPXt2YWx1ZSA9PT0gJycgPyB0cnVlIDogdW5kZWZpbmVkfVxuICAgICAgb3Blbk1lbnVPbkZvY3VzXG4gICAgICBvbk9wZW5NZW51PXthc3luYyAoKSA9PiB7XG4gICAgICAgIHNldFN0YXRlKHsgaXNMb2FkaW5nOiB0cnVlIH0pO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gYXdhaXQgbG9hZEdyb3VwQnlMYWJlbHMocXVlcnksIGRhdGFzb3VyY2UpO1xuICAgICAgICBzZXRTdGF0ZSh7IG9wdGlvbnMsIGlzTG9hZGluZzogdW5kZWZpbmVkIH0pO1xuICAgICAgfX1cbiAgICAgIGlzTG9hZGluZz17c3RhdGUuaXNMb2FkaW5nfVxuICAgICAgYWxsb3dDdXN0b21WYWx1ZVxuICAgICAgbm9PcHRpb25zTWVzc2FnZT1cIk5vIGxhYmVscyBmb3VuZFwiXG4gICAgICBsb2FkaW5nTWVzc2FnZT1cIkxvYWRpbmcgbGFiZWxzXCJcbiAgICAgIG9wdGlvbnM9e3N0YXRlLm9wdGlvbnN9XG4gICAgICB2YWx1ZT17dG9PcHRpb24odmFsdWUgYXMgc3RyaW5nKX1cbiAgICAgIG9uQ2hhbmdlPXsodmFsdWUpID0+IG9uQ2hhbmdlKGluZGV4LCB2YWx1ZS52YWx1ZSEpfVxuICAgIC8+XG4gICk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGxvYWRHcm91cEJ5TGFiZWxzKFxuICBxdWVyeTogUHJvbVZpc3VhbFF1ZXJ5LFxuICBkYXRhc291cmNlOiBEYXRhU291cmNlQXBpXG4pOiBQcm9taXNlPEFycmF5PFNlbGVjdGFibGVWYWx1ZTxhbnk+Pj4ge1xuICBsZXQgbGFiZWxzOiBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcltdID0gcXVlcnkubGFiZWxzO1xuXG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBieSBib3RoIFByb21ldGhldXMgYW5kIExva2kgYW5kIHRoaXMgdGhlIG9ubHkgZGlmZmVyZW5jZVxuICBpZiAoZGF0YXNvdXJjZSBpbnN0YW5jZW9mIFByb21ldGhldXNEYXRhc291cmNlKSB7XG4gICAgbGFiZWxzID0gW3sgbGFiZWw6ICdfX25hbWVfXycsIG9wOiAnPScsIHZhbHVlOiBxdWVyeS5tZXRyaWMgfSwgLi4ucXVlcnkubGFiZWxzXTtcbiAgfVxuXG4gIGNvbnN0IGV4cHIgPSBwcm9tUXVlcnlNb2RlbGxlci5yZW5kZXJMYWJlbHMobGFiZWxzKTtcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZGF0YXNvdXJjZS5sYW5ndWFnZVByb3ZpZGVyLmZldGNoU2VyaWVzTGFiZWxzKGV4cHIpO1xuXG4gIHJldHVybiBPYmplY3Qua2V5cyhyZXN1bHQpLm1hcCgoeCkgPT4gKHtcbiAgICBsYWJlbDogeCxcbiAgICB2YWx1ZTogeCxcbiAgfSkpO1xufVxuIiwiaW1wb3J0IHsgYmluYXJ5U2NhbGFyT3BlcmF0aW9ucyB9IGZyb20gJy4vYmluYXJ5U2NhbGFyT3BlcmF0aW9ucyc7XG5pbXBvcnQgeyBMYWJlbFBhcmFtRWRpdG9yIH0gZnJvbSAnLi9jb21wb25lbnRzL0xhYmVsUGFyYW1FZGl0b3InO1xuaW1wb3J0IHtcbiAgZGVmYXVsdEFkZE9wZXJhdGlvbkhhbmRsZXIsXG4gIGZ1bmN0aW9uUmVuZGVyZXJMZWZ0LFxuICBmdW5jdGlvblJlbmRlcmVyUmlnaHQsXG4gIGdldFByb21BbmRMb2tpT3BlcmF0aW9uRGlzcGxheU5hbWUsXG4gIGdldFJhbmdlVmVjdG9yUGFyYW1EZWYsXG4gIHJhbmdlUmVuZGVyZXJMZWZ0V2l0aFBhcmFtcyxcbiAgcmFuZ2VSZW5kZXJlclJpZ2h0V2l0aFBhcmFtcyxcbn0gZnJvbSAnLi9zaGFyZWQvb3BlcmF0aW9uVXRpbHMnO1xuaW1wb3J0IHtcbiAgUXVlcnlCdWlsZGVyT3BlcmF0aW9uLFxuICBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsXG4gIFF1ZXJ5V2l0aE9wZXJhdGlvbnMsXG4gIFZpc3VhbFF1ZXJ5TW9kZWxsZXIsXG59IGZyb20gJy4vc2hhcmVkL3R5cGVzJztcbmltcG9ydCB7IFByb21PcGVyYXRpb25JZCwgUHJvbVZpc3VhbFF1ZXJ5LCBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeSB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0T3BlcmF0aW9uRGVmaW5pdGlvbnMoKTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmW10ge1xuICBjb25zdCBsaXN0OiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWZbXSA9IFtcbiAgICB7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLkhpc3RvZ3JhbVF1YW50aWxlLFxuICAgICAgbmFtZTogJ0hpc3RvZ3JhbSBxdWFudGlsZScsXG4gICAgICBwYXJhbXM6IFt7IG5hbWU6ICdRdWFudGlsZScsIHR5cGU6ICdudW1iZXInLCBvcHRpb25zOiBbMC45OSwgMC45NSwgMC45LCAwLjc1LCAwLjUsIDAuMjVdIH1dLFxuICAgICAgZGVmYXVsdFBhcmFtczogWzAuOV0sXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuRnVuY3Rpb25zLFxuICAgICAgcmVuZGVyZXI6IGZ1bmN0aW9uUmVuZGVyZXJMZWZ0LFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogZGVmYXVsdEFkZE9wZXJhdGlvbkhhbmRsZXIsXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLkxhYmVsUmVwbGFjZSxcbiAgICAgIG5hbWU6ICdMYWJlbCByZXBsYWNlJyxcbiAgICAgIHBhcmFtczogW1xuICAgICAgICB7IG5hbWU6ICdEZXN0aW5hdGlvbiBsYWJlbCcsIHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICAgIHsgbmFtZTogJ1JlcGxhY2VtZW50JywgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgeyBuYW1lOiAnU291cmNlIGxhYmVsJywgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgeyBuYW1lOiAnUmVnZXgnLCB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgXSxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5GdW5jdGlvbnMsXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbJycsICckMScsICcnLCAnKC4qKSddLFxuICAgICAgcmVuZGVyZXI6IGZ1bmN0aW9uUmVuZGVyZXJSaWdodCxcbiAgICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGRlZmF1bHRBZGRPcGVyYXRpb25IYW5kbGVyLFxuICAgIH0sXG4gICAge1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5MbixcbiAgICAgIG5hbWU6ICdMbicsXG4gICAgICBwYXJhbXM6IFtdLFxuICAgICAgZGVmYXVsdFBhcmFtczogW10sXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuRnVuY3Rpb25zLFxuICAgICAgcmVuZGVyZXI6IGZ1bmN0aW9uUmVuZGVyZXJMZWZ0LFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogZGVmYXVsdEFkZE9wZXJhdGlvbkhhbmRsZXIsXG4gICAgfSxcbiAgICBjcmVhdGVSYW5nZUZ1bmN0aW9uKFByb21PcGVyYXRpb25JZC5DaGFuZ2VzKSxcbiAgICBjcmVhdGVSYW5nZUZ1bmN0aW9uKFByb21PcGVyYXRpb25JZC5SYXRlLCB0cnVlKSxcbiAgICBjcmVhdGVSYW5nZUZ1bmN0aW9uKFByb21PcGVyYXRpb25JZC5JcmF0ZSksXG4gICAgY3JlYXRlUmFuZ2VGdW5jdGlvbihQcm9tT3BlcmF0aW9uSWQuSW5jcmVhc2UsIHRydWUpLFxuICAgIGNyZWF0ZVJhbmdlRnVuY3Rpb24oUHJvbU9wZXJhdGlvbklkLklkZWx0YSksXG4gICAgY3JlYXRlUmFuZ2VGdW5jdGlvbihQcm9tT3BlcmF0aW9uSWQuRGVsdGEpLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuSG9sdFdpbnRlcnMsXG4gICAgICBwYXJhbXM6IFtcbiAgICAgICAgZ2V0UmFuZ2VWZWN0b3JQYXJhbURlZigpLFxuICAgICAgICB7IG5hbWU6ICdTbW9vdGhpbmcgRmFjdG9yJywgdHlwZTogJ251bWJlcicgfSxcbiAgICAgICAgeyBuYW1lOiAnVHJlbmQgRmFjdG9yJywgdHlwZTogJ251bWJlcicgfSxcbiAgICAgIF0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbJyRfX2ludGVydmFsJywgMC41LCAwLjVdLFxuICAgICAgYWx0ZXJuYXRpdmVzS2V5OiAncmFuZ2UgZnVuY3Rpb24nLFxuICAgICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlJhbmdlRnVuY3Rpb25zLFxuICAgICAgcmVuZGVyZXI6IHJhbmdlUmVuZGVyZXJSaWdodFdpdGhQYXJhbXMsXG4gICAgICBhZGRPcGVyYXRpb25IYW5kbGVyOiBhZGRPcGVyYXRpb25XaXRoUmFuZ2VWZWN0b3IsXG4gICAgICBjaGFuZ2VUeXBlSGFuZGxlcjogb3BlcmF0aW9uVHlwZUNoYW5nZWRIYW5kbGVyRm9yUmFuZ2VGdW5jdGlvbixcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLlByZWRpY3RMaW5lYXIsXG4gICAgICBwYXJhbXM6IFtnZXRSYW5nZVZlY3RvclBhcmFtRGVmKCksIHsgbmFtZTogJ1NlY29uZHMgZnJvbSBub3cnLCB0eXBlOiAnbnVtYmVyJyB9XSxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFsnJF9faW50ZXJ2YWwnLCA2MF0sXG4gICAgICBhbHRlcm5hdGl2ZXNLZXk6ICdyYW5nZSBmdW5jdGlvbicsXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuUmFuZ2VGdW5jdGlvbnMsXG4gICAgICByZW5kZXJlcjogcmFuZ2VSZW5kZXJlclJpZ2h0V2l0aFBhcmFtcyxcbiAgICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGFkZE9wZXJhdGlvbldpdGhSYW5nZVZlY3RvcixcbiAgICAgIGNoYW5nZVR5cGVIYW5kbGVyOiBvcGVyYXRpb25UeXBlQ2hhbmdlZEhhbmRsZXJGb3JSYW5nZUZ1bmN0aW9uLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuUXVhbnRpbGVPdmVyVGltZSxcbiAgICAgIHBhcmFtczogW2dldFJhbmdlVmVjdG9yUGFyYW1EZWYoKSwgeyBuYW1lOiAnUXVhbnRpbGUnLCB0eXBlOiAnbnVtYmVyJyB9XSxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFsnJF9faW50ZXJ2YWwnLCAwLjVdLFxuICAgICAgYWx0ZXJuYXRpdmVzS2V5OiAnb3ZlcnRpbWUgZnVuY3Rpb24nLFxuICAgICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlJhbmdlRnVuY3Rpb25zLFxuICAgICAgcmVuZGVyZXI6IHJhbmdlUmVuZGVyZXJMZWZ0V2l0aFBhcmFtcyxcbiAgICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGFkZE9wZXJhdGlvbldpdGhSYW5nZVZlY3RvcixcbiAgICAgIGNoYW5nZVR5cGVIYW5kbGVyOiBvcGVyYXRpb25UeXBlQ2hhbmdlZEhhbmRsZXJGb3JSYW5nZUZ1bmN0aW9uLFxuICAgIH0pLFxuICAgIC4uLmJpbmFyeVNjYWxhck9wZXJhdGlvbnMsXG4gICAge1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5OZXN0ZWRRdWVyeSxcbiAgICAgIG5hbWU6ICdCaW5hcnkgb3BlcmF0aW9uIHdpdGggcXVlcnknLFxuICAgICAgcGFyYW1zOiBbXSxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFtdLFxuICAgICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkJpbmFyeU9wcyxcbiAgICAgIHJlbmRlcmVyOiAobW9kZWwsIGRlZiwgaW5uZXJFeHByKSA9PiBpbm5lckV4cHIsXG4gICAgICBhZGRPcGVyYXRpb25IYW5kbGVyOiBhZGROZXN0ZWRRdWVyeUhhbmRsZXIsXG4gICAgfSxcbiAgICBjcmVhdGVGdW5jdGlvbih7IGlkOiBQcm9tT3BlcmF0aW9uSWQuQWJzZW50IH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuQWNvcyxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5Ucmlnb25vbWV0cmljLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuQWNvc2gsXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuVHJpZ29ub21ldHJpYyxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLkFzaW4sXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuVHJpZ29ub21ldHJpYyxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLkFzaW5oLFxuICAgICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlRyaWdvbm9tZXRyaWMsXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5BdGFuLFxuICAgICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlRyaWdvbm9tZXRyaWMsXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5BdGFuaCxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5Ucmlnb25vbWV0cmljLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHsgaWQ6IFByb21PcGVyYXRpb25JZC5DZWlsIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuQ2xhbXAsXG4gICAgICBuYW1lOiAnQ2xhbXAnLFxuICAgICAgcGFyYW1zOiBbXG4gICAgICAgIHsgbmFtZTogJ01pbmltdW0gU2NhbGFyJywgdHlwZTogJ251bWJlcicgfSxcbiAgICAgICAgeyBuYW1lOiAnTWF4aW11bSBTY2FsYXInLCB0eXBlOiAnbnVtYmVyJyB9LFxuICAgICAgXSxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFsxLCAxXSxcbiAgICB9KSxcblxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuQ2xhbXBNYXgsXG4gICAgICBwYXJhbXM6IFt7IG5hbWU6ICdNYXhpbXVtIFNjYWxhcicsIHR5cGU6ICdudW1iZXInIH1dLFxuICAgICAgZGVmYXVsdFBhcmFtczogWzFdLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuQ2xhbXBNaW4sXG4gICAgICBwYXJhbXM6IFt7IG5hbWU6ICdNaW5pbXVtIFNjYWxhcicsIHR5cGU6ICdudW1iZXInIH1dLFxuICAgICAgZGVmYXVsdFBhcmFtczogWzFdLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuQ29zLFxuICAgICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlRyaWdvbm9tZXRyaWMsXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5Db3NoLFxuICAgICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlRyaWdvbm9tZXRyaWMsXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5EYXlPZk1vbnRoLFxuICAgICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlRpbWUsXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5EYXlPZldlZWssXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuVGltZSxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLkRheXNJbk1vbnRoLFxuICAgICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlRpbWUsXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLkRlZyB9KSxcbiAgICBjcmVhdGVSYW5nZUZ1bmN0aW9uKFByb21PcGVyYXRpb25JZC5EZXJpdiksXG4gICAgLy9cbiAgICBjcmVhdGVGdW5jdGlvbih7IGlkOiBQcm9tT3BlcmF0aW9uSWQuRXhwIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHsgaWQ6IFByb21PcGVyYXRpb25JZC5GbG9vciB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7IGlkOiBQcm9tT3BlcmF0aW9uSWQuR3JvdXAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLkhvdXIgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5MYWJlbEpvaW4sXG4gICAgICBwYXJhbXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdEZXN0aW5hdGlvbiBMYWJlbCcsXG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgZWRpdG9yOiBMYWJlbFBhcmFtRWRpdG9yLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ1NlcGFyYXRvcicsXG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnU291cmNlIExhYmVsJyxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICByZXN0UGFyYW06IHRydWUsXG4gICAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgICAgZWRpdG9yOiBMYWJlbFBhcmFtRWRpdG9yLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFsnJywgJywnLCAnJ10sXG4gICAgICByZW5kZXJlcjogbGFiZWxKb2luUmVuZGVyZXIsXG4gICAgICBhZGRPcGVyYXRpb25IYW5kbGVyOiBsYWJlbEpvaW5BZGRPcGVyYXRpb25IYW5kbGVyLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHsgaWQ6IFByb21PcGVyYXRpb25JZC5Mb2cxMCB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7IGlkOiBQcm9tT3BlcmF0aW9uSWQuTG9nMiB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7IGlkOiBQcm9tT3BlcmF0aW9uSWQuTWludXRlIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHsgaWQ6IFByb21PcGVyYXRpb25JZC5Nb250aCB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLlBpLFxuICAgICAgcmVuZGVyZXI6IChtb2RlbCkgPT4gYCR7bW9kZWwuaWR9KClgLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuUXVhbnRpbGUsXG4gICAgICBwYXJhbXM6IFt7IG5hbWU6ICdWYWx1ZScsIHR5cGU6ICdudW1iZXInIH1dLFxuICAgICAgZGVmYXVsdFBhcmFtczogWzFdLFxuICAgICAgcmVuZGVyZXI6IGZ1bmN0aW9uUmVuZGVyZXJMZWZ0LFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHsgaWQ6IFByb21PcGVyYXRpb25JZC5SYWQgfSksXG4gICAgY3JlYXRlUmFuZ2VGdW5jdGlvbihQcm9tT3BlcmF0aW9uSWQuUmVzZXRzKSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLlJvdW5kLFxuICAgICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkZ1bmN0aW9ucyxcbiAgICAgIHBhcmFtczogW3sgbmFtZTogJ1RvIE5lYXJlc3QnLCB0eXBlOiAnbnVtYmVyJyB9XSxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFsxXSxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7IGlkOiBQcm9tT3BlcmF0aW9uSWQuU2NhbGFyIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHsgaWQ6IFByb21PcGVyYXRpb25JZC5TZ24gfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLlNpbiwgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlRyaWdvbm9tZXRyaWMgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5TaW5oLFxuICAgICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlRyaWdvbm9tZXRyaWMsXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLlNvcnQgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLlNvcnREZXNjIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHsgaWQ6IFByb21PcGVyYXRpb25JZC5TcXJ0IH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHsgaWQ6IFByb21PcGVyYXRpb25JZC5TdGRkZXYgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5UYW4sXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuVHJpZ29ub21ldHJpYyxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLlRhbmgsXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuVHJpZ29ub21ldHJpYyxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLlRpbWUsXG4gICAgICByZW5kZXJlcjogKG1vZGVsKSA9PiBgJHttb2RlbC5pZH0oKWAsXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLlRpbWVzdGFtcCB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLlZlY3RvcixcbiAgICAgIHBhcmFtczogW3sgbmFtZTogJ1ZhbHVlJywgdHlwZTogJ251bWJlcicgfV0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbMV0sXG4gICAgICByZW5kZXJlcjogKG1vZGVsKSA9PiBgJHttb2RlbC5pZH0oJHttb2RlbC5wYXJhbXNbMF19KWAsXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLlllYXIgfSksXG4gIF07XG5cbiAgcmV0dXJuIGxpc3Q7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGdW5jdGlvbihkZWZpbml0aW9uOiBQYXJ0aWFsPFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZj4pOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYge1xuICByZXR1cm4ge1xuICAgIC4uLmRlZmluaXRpb24sXG4gICAgaWQ6IGRlZmluaXRpb24uaWQhLFxuICAgIG5hbWU6IGRlZmluaXRpb24ubmFtZSA/PyBnZXRQcm9tQW5kTG9raU9wZXJhdGlvbkRpc3BsYXlOYW1lKGRlZmluaXRpb24uaWQhKSxcbiAgICBwYXJhbXM6IGRlZmluaXRpb24ucGFyYW1zID8/IFtdLFxuICAgIGRlZmF1bHRQYXJhbXM6IGRlZmluaXRpb24uZGVmYXVsdFBhcmFtcyA/PyBbXSxcbiAgICBjYXRlZ29yeTogZGVmaW5pdGlvbi5jYXRlZ29yeSA/PyBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5GdW5jdGlvbnMsXG4gICAgcmVuZGVyZXI6IGRlZmluaXRpb24ucmVuZGVyZXIgPz8gKGRlZmluaXRpb24ucGFyYW1zID8gZnVuY3Rpb25SZW5kZXJlclJpZ2h0IDogZnVuY3Rpb25SZW5kZXJlckxlZnQpLFxuICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGRlZmluaXRpb24uYWRkT3BlcmF0aW9uSGFuZGxlciA/PyBkZWZhdWx0QWRkT3BlcmF0aW9uSGFuZGxlcixcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJhbmdlRnVuY3Rpb24obmFtZTogc3RyaW5nLCB3aXRoUmF0ZUludGVydmFsID0gZmFsc2UpOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYge1xuICByZXR1cm4ge1xuICAgIGlkOiBuYW1lLFxuICAgIG5hbWU6IGdldFByb21BbmRMb2tpT3BlcmF0aW9uRGlzcGxheU5hbWUobmFtZSksXG4gICAgcGFyYW1zOiBbZ2V0UmFuZ2VWZWN0b3JQYXJhbURlZih3aXRoUmF0ZUludGVydmFsKV0sXG4gICAgZGVmYXVsdFBhcmFtczogW3dpdGhSYXRlSW50ZXJ2YWwgPyAnJF9fcmF0ZV9pbnRlcnZhbCcgOiAnJF9faW50ZXJ2YWwnXSxcbiAgICBhbHRlcm5hdGl2ZXNLZXk6ICdyYW5nZSBmdW5jdGlvbicsXG4gICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlJhbmdlRnVuY3Rpb25zLFxuICAgIHJlbmRlcmVyOiBvcGVyYXRpb25XaXRoUmFuZ2VWZWN0b3JSZW5kZXJlcixcbiAgICBhZGRPcGVyYXRpb25IYW5kbGVyOiBhZGRPcGVyYXRpb25XaXRoUmFuZ2VWZWN0b3IsXG4gICAgY2hhbmdlVHlwZUhhbmRsZXI6IG9wZXJhdGlvblR5cGVDaGFuZ2VkSGFuZGxlckZvclJhbmdlRnVuY3Rpb24sXG4gIH07XG59XG5cbmZ1bmN0aW9uIG9wZXJhdGlvblR5cGVDaGFuZ2VkSGFuZGxlckZvclJhbmdlRnVuY3Rpb24oXG4gIG9wZXJhdGlvbjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLFxuICBuZXdEZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZlxuKSB7XG4gIC8vIHZhbGlkYXRlIGN1cnJlbnQgcGFyYW1ldGVyXG4gIGlmIChvcGVyYXRpb24ucGFyYW1zWzBdID09PSAnJF9fcmF0ZV9pbnRlcnZhbCcgJiYgbmV3RGVmLmRlZmF1bHRQYXJhbXNbMF0gIT09ICckX19yYXRlX2ludGVydmFsJykge1xuICAgIG9wZXJhdGlvbi5wYXJhbXMgPSBuZXdEZWYuZGVmYXVsdFBhcmFtcztcbiAgfSBlbHNlIGlmIChvcGVyYXRpb24ucGFyYW1zWzBdID09PSAnJF9faW50ZXJ2YWwnICYmIG5ld0RlZi5kZWZhdWx0UGFyYW1zWzBdICE9PSAnJF9faW50ZXJ2YWwnKSB7XG4gICAgb3BlcmF0aW9uLnBhcmFtcyA9IG5ld0RlZi5kZWZhdWx0UGFyYW1zO1xuICB9XG5cbiAgcmV0dXJuIG9wZXJhdGlvbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9wZXJhdGlvbldpdGhSYW5nZVZlY3RvclJlbmRlcmVyKFxuICBtb2RlbDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLFxuICBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZixcbiAgaW5uZXJFeHByOiBzdHJpbmdcbikge1xuICBsZXQgcmFuZ2VWZWN0b3IgPSAobW9kZWwucGFyYW1zID8/IFtdKVswXSA/PyAnNW0nO1xuICByZXR1cm4gYCR7ZGVmLmlkfSgke2lubmVyRXhwcn1bJHtyYW5nZVZlY3Rvcn1dKWA7XG59XG5cbi8qKlxuICogU2luY2UgdGhlcmUgY2FuIG9ubHkgYmUgb25lIG9wZXJhdGlvbiB3aXRoIHJhbmdlIHZlY3RvciB0aGlzIHdpbGwgcmVwbGFjZSB0aGUgY3VycmVudCBvbmUgKGlmIG9uZSB3YXMgYWRkZWQgKVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkT3BlcmF0aW9uV2l0aFJhbmdlVmVjdG9yKFxuICBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZixcbiAgcXVlcnk6IFByb21WaXN1YWxRdWVyeSxcbiAgbW9kZWxsZXI6IFZpc3VhbFF1ZXJ5TW9kZWxsZXJcbikge1xuICBjb25zdCBuZXdPcGVyYXRpb246IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiA9IHtcbiAgICBpZDogZGVmLmlkLFxuICAgIHBhcmFtczogZGVmLmRlZmF1bHRQYXJhbXMsXG4gIH07XG5cbiAgaWYgKHF1ZXJ5Lm9wZXJhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgIC8vIElmIG9wZXJhdGlvbiBleGlzdHMgaXQgaGFzIHRvIGJlIGluIHRoZSByZWdpc3RyeSBzbyBubyBwb2ludCB0byBjaGVjayBpZiBpdCB3YXMgZm91bmRcbiAgICBjb25zdCBmaXJzdE9wID0gbW9kZWxsZXIuZ2V0T3BlcmF0aW9uRGVmKHF1ZXJ5Lm9wZXJhdGlvbnNbMF0uaWQpITtcblxuICAgIGlmIChmaXJzdE9wLmFkZE9wZXJhdGlvbkhhbmRsZXIgPT09IGFkZE9wZXJhdGlvbldpdGhSYW5nZVZlY3Rvcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucXVlcnksXG4gICAgICAgIG9wZXJhdGlvbnM6IFtuZXdPcGVyYXRpb24sIC4uLnF1ZXJ5Lm9wZXJhdGlvbnMuc2xpY2UoMSldLFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC4uLnF1ZXJ5LFxuICAgIG9wZXJhdGlvbnM6IFtuZXdPcGVyYXRpb24sIC4uLnF1ZXJ5Lm9wZXJhdGlvbnNdLFxuICB9O1xufVxuXG5mdW5jdGlvbiBhZGROZXN0ZWRRdWVyeUhhbmRsZXIoZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsIHF1ZXJ5OiBQcm9tVmlzdWFsUXVlcnkpOiBQcm9tVmlzdWFsUXVlcnkge1xuICByZXR1cm4ge1xuICAgIC4uLnF1ZXJ5LFxuICAgIGJpbmFyeVF1ZXJpZXM6IFtcbiAgICAgIC4uLihxdWVyeS5iaW5hcnlRdWVyaWVzID8/IFtdKSxcbiAgICAgIHtcbiAgICAgICAgb3BlcmF0b3I6ICcvJyxcbiAgICAgICAgcXVlcnksXG4gICAgICB9LFxuICAgIF0sXG4gIH07XG59XG5cbmZ1bmN0aW9uIGxhYmVsSm9pblJlbmRlcmVyKG1vZGVsOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLCBpbm5lckV4cHI6IHN0cmluZykge1xuICBpZiAodHlwZW9mIG1vZGVsLnBhcmFtc1sxXSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyAnVGhlIHNlcGFyYXRvciBtdXN0IGJlIGEgc3RyaW5nJztcbiAgfVxuICBjb25zdCBzZXBhcmF0b3IgPSBgXCIke21vZGVsLnBhcmFtc1sxXX1cImA7XG4gIHJldHVybiBgJHttb2RlbC5pZH0oJHtpbm5lckV4cHJ9LCBcIiR7bW9kZWwucGFyYW1zWzBdfVwiLCAke3NlcGFyYXRvcn0sIFwiJHttb2RlbC5wYXJhbXMuc2xpY2UoMikuam9pbihzZXBhcmF0b3IpfVwiKWA7XG59XG5cbmZ1bmN0aW9uIGxhYmVsSm9pbkFkZE9wZXJhdGlvbkhhbmRsZXI8VCBleHRlbmRzIFF1ZXJ5V2l0aE9wZXJhdGlvbnM+KGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLCBxdWVyeTogVCkge1xuICBjb25zdCBuZXdPcGVyYXRpb246IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiA9IHtcbiAgICBpZDogZGVmLmlkLFxuICAgIHBhcmFtczogZGVmLmRlZmF1bHRQYXJhbXMsXG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5xdWVyeSxcbiAgICBvcGVyYXRpb25zOiBbLi4ucXVlcnkub3BlcmF0aW9ucywgbmV3T3BlcmF0aW9uXSxcbiAgfTtcbn1cbiIsImltcG9ydCB7IFN5bnRheE5vZGUgfSBmcm9tICdAbGV6ZXIvY29tbW9uJztcbmltcG9ydCB7IHBhcnNlciB9IGZyb20gJ2xlemVyLXByb21xbCc7XG5cbmltcG9ydCB7IGJpbmFyeVNjYWxhck9wZXJhdG9yVG9PcGVyYXRvck5hbWUgfSBmcm9tICcuL2JpbmFyeVNjYWxhck9wZXJhdGlvbnMnO1xuaW1wb3J0IHtcbiAgRXJyb3JOYW1lLFxuICBnZXRBbGxCeVR5cGUsXG4gIGdldExlZnRNb3N0Q2hpbGQsXG4gIGdldFN0cmluZyxcbiAgbWFrZUJpbk9wLFxuICBtYWtlRXJyb3IsXG4gIHJlcGxhY2VWYXJpYWJsZXMsXG59IGZyb20gJy4vc2hhcmVkL3BhcnNpbmdVdGlscyc7XG5pbXBvcnQgeyBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlciwgUXVlcnlCdWlsZGVyT3BlcmF0aW9uIH0gZnJvbSAnLi9zaGFyZWQvdHlwZXMnO1xuaW1wb3J0IHsgUHJvbVZpc3VhbFF1ZXJ5LCBQcm9tVmlzdWFsUXVlcnlCaW5hcnkgfSBmcm9tICcuL3R5cGVzJztcblxuLyoqXG4gKiBQYXJzZXMgYSBQcm9tUUwgcXVlcnkgaW50byBhIHZpc3VhbCBxdWVyeSBtb2RlbC5cbiAqXG4gKiBJdCB0cmF2ZXJzZXMgdGhlIHRyZWUgYW5kIHVzZXMgc29ydCBvZiBzdGF0ZSBtYWNoaW5lIHRvIHVwZGF0ZSB0aGUgcXVlcnkgbW9kZWwuIFRoZSBxdWVyeSBtb2RlbCBpcyBtb2RpZmllZFxuICogZHVyaW5nIHRoZSB0cmF2ZXJzYWwgYW5kIHNlbnQgdG8gZWFjaCBoYW5kbGVyIGFzIGNvbnRleHQuXG4gKlxuICogQHBhcmFtIGV4cHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkVmlzdWFsUXVlcnlGcm9tU3RyaW5nKGV4cHI6IHN0cmluZyk6IENvbnRleHQge1xuICBjb25zdCByZXBsYWNlZEV4cHIgPSByZXBsYWNlVmFyaWFibGVzKGV4cHIpO1xuICBjb25zdCB0cmVlID0gcGFyc2VyLnBhcnNlKHJlcGxhY2VkRXhwcik7XG4gIGNvbnN0IG5vZGUgPSB0cmVlLnRvcE5vZGU7XG5cbiAgLy8gVGhpcyB3aWxsIGJlIG1vZGlmaWVkIGluIHRoZSBoYW5kbGVycy5cbiAgY29uc3QgdmlzUXVlcnk6IFByb21WaXN1YWxRdWVyeSA9IHtcbiAgICBtZXRyaWM6ICcnLFxuICAgIGxhYmVsczogW10sXG4gICAgb3BlcmF0aW9uczogW10sXG4gIH07XG4gIGNvbnN0IGNvbnRleHQ6IENvbnRleHQgPSB7XG4gICAgcXVlcnk6IHZpc1F1ZXJ5LFxuICAgIGVycm9yczogW10sXG4gIH07XG5cbiAgdHJ5IHtcbiAgICBoYW5kbGVFeHByZXNzaW9uKHJlcGxhY2VkRXhwciwgbm9kZSwgY29udGV4dCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIE5vdCBpZGVhbCB0byBsb2cgaXQgaGVyZSwgYnV0IG90aGVyd2lzZSB3ZSB3b3VsZCBsb3NlIHRoZSBzdGFjayB0cmFjZS5cbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgY29udGV4dC5lcnJvcnMucHVzaCh7XG4gICAgICB0ZXh0OiBlcnIubWVzc2FnZSxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIElmIHdlIGhhdmUgZW1wdHkgcXVlcnksIHdlIHdhbnQgdG8gcmVzZXQgZXJyb3JzXG4gIGlmIChpc0VtcHR5UXVlcnkoY29udGV4dC5xdWVyeSkpIHtcbiAgICBjb250ZXh0LmVycm9ycyA9IFtdO1xuICB9XG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5pbnRlcmZhY2UgUGFyc2luZ0Vycm9yIHtcbiAgdGV4dDogc3RyaW5nO1xuICBmcm9tPzogbnVtYmVyO1xuICB0bz86IG51bWJlcjtcbiAgcGFyZW50VHlwZT86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIENvbnRleHQge1xuICBxdWVyeTogUHJvbVZpc3VhbFF1ZXJ5O1xuICBlcnJvcnM6IFBhcnNpbmdFcnJvcltdO1xufVxuXG4vKipcbiAqIEhhbmRsZXIgZm9yIGRlZmF1bHQgc3RhdGUuIEl0IHdpbGwgdHJhdmVyc2UgdGhlIHRyZWUgYW5kIGNhbGwgdGhlIGFwcHJvcHJpYXRlIGhhbmRsZXIgZm9yIGVhY2ggbm9kZS4gVGhlIG5vZGVcbiAqIGhhbmRsZWQgaGVyZSBkb2VzIG5vdCBuZWNlc3NhcmlseSBuZWVkIHRvIGJlIG9mIHR5cGUgPT0gRXhwci5cbiAqIEBwYXJhbSBleHByXG4gKiBAcGFyYW0gbm9kZVxuICogQHBhcmFtIGNvbnRleHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZUV4cHJlc3Npb24oZXhwcjogc3RyaW5nLCBub2RlOiBTeW50YXhOb2RlLCBjb250ZXh0OiBDb250ZXh0KSB7XG4gIGNvbnN0IHZpc1F1ZXJ5ID0gY29udGV4dC5xdWVyeTtcbiAgc3dpdGNoIChub2RlLm5hbWUpIHtcbiAgICBjYXNlICdNZXRyaWNJZGVudGlmaWVyJzoge1xuICAgICAgLy8gRXhwZWN0YXRpb24gaXMgdGhhdCB0aGVyZSBpcyBvbmx5IG9uZSBvZiB0aG9zZSBwZXIgcXVlcnkuXG4gICAgICB2aXNRdWVyeS5tZXRyaWMgPSBnZXRTdHJpbmcoZXhwciwgbm9kZSk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICdMYWJlbE1hdGNoZXInOiB7XG4gICAgICAvLyBTYW1lIGFzIE1ldHJpY0lkZW50aWZpZXIgc2hvdWxkIGJlIGp1c3Qgb25lIHBlciBxdWVyeS5cbiAgICAgIHZpc1F1ZXJ5LmxhYmVscy5wdXNoKGdldExhYmVsKGV4cHIsIG5vZGUpKTtcbiAgICAgIGNvbnN0IGVyciA9IG5vZGUuZ2V0Q2hpbGQoRXJyb3JOYW1lKTtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgY29udGV4dC5lcnJvcnMucHVzaChtYWtlRXJyb3IoZXhwciwgZXJyKSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICdGdW5jdGlvbkNhbGwnOiB7XG4gICAgICBoYW5kbGVGdW5jdGlvbihleHByLCBub2RlLCBjb250ZXh0KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgJ0FnZ3JlZ2F0ZUV4cHInOiB7XG4gICAgICBoYW5kbGVBZ2dyZWdhdGlvbihleHByLCBub2RlLCBjb250ZXh0KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgJ0JpbmFyeUV4cHInOiB7XG4gICAgICBoYW5kbGVCaW5hcnkoZXhwciwgbm9kZSwgY29udGV4dCk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlIEVycm9yTmFtZToge1xuICAgICAgaWYgKGlzSW50ZXJ2YWxWYXJpYWJsZUVycm9yKG5vZGUpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29udGV4dC5lcnJvcnMucHVzaChtYWtlRXJyb3IoZXhwciwgbm9kZSkpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZGVmYXVsdDoge1xuICAgICAgaWYgKG5vZGUubmFtZSA9PT0gJ1BhcmVuRXhwcicpIHtcbiAgICAgICAgLy8gV2UgZG9uJ3Qgc3VwcG9ydCBwYXJlbnRoZXNpcyBpbiB0aGUgcXVlcnkgdG8gZ3JvdXAgZXhwcmVzc2lvbnMuIFdlIGp1c3QgcmVwb3J0IGVycm9yIGJ1dCBnbyBvbiB3aXRoIHRoZVxuICAgICAgICAvLyBwYXJzaW5nLlxuICAgICAgICBjb250ZXh0LmVycm9ycy5wdXNoKG1ha2VFcnJvcihleHByLCBub2RlKSk7XG4gICAgICB9XG4gICAgICAvLyBBbnkgb3RoZXIgbm9kZXMgd2UganVzdCBpZ25vcmUgYW5kIGdvIHRvIGl0J3MgY2hpbGRyZW4uIFRoaXMgc2hvdWxkIGJlIGZpbmUgYXMgdGhlcmUgYXJlIGxvdCdzIG9mIHdyYXBwZXJcbiAgICAgIC8vIG5vZGVzIHRoYXQgY2FuIGJlIHNraXBwZWQuXG4gICAgICAvLyBUT0RPOiB0aGVyZSBhcmUgcHJvYmFibHkgY2FzZXMgd2hlcmUgd2Ugd2lsbCBqdXN0IHNraXAgbm9kZXMgd2UgZG9uJ3Qgc3VwcG9ydCBhbmQgd2Ugc2hvdWxkIGJlIGFibGUgdG9cbiAgICAgIC8vICBkZXRlY3QgdGhvc2UgYW5kIHJlcG9ydCBiYWNrLlxuICAgICAgbGV0IGNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgIGhhbmRsZUV4cHJlc3Npb24oZXhwciwgY2hpbGQsIGNvbnRleHQpO1xuICAgICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc0ludGVydmFsVmFyaWFibGVFcnJvcihub2RlOiBTeW50YXhOb2RlKSB7XG4gIHJldHVybiBub2RlLnByZXZTaWJsaW5nPy5uYW1lID09PSAnRXhwcicgJiYgbm9kZS5wcmV2U2libGluZz8uZmlyc3RDaGlsZD8ubmFtZSA9PT0gJ1ZlY3RvclNlbGVjdG9yJztcbn1cblxuZnVuY3Rpb24gZ2V0TGFiZWwoZXhwcjogc3RyaW5nLCBub2RlOiBTeW50YXhOb2RlKTogUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXIge1xuICBjb25zdCBsYWJlbCA9IGdldFN0cmluZyhleHByLCBub2RlLmdldENoaWxkKCdMYWJlbE5hbWUnKSk7XG4gIGNvbnN0IG9wID0gZ2V0U3RyaW5nKGV4cHIsIG5vZGUuZ2V0Q2hpbGQoJ01hdGNoT3AnKSk7XG4gIGNvbnN0IHZhbHVlID0gZ2V0U3RyaW5nKGV4cHIsIG5vZGUuZ2V0Q2hpbGQoJ1N0cmluZ0xpdGVyYWwnKSkucmVwbGFjZSgvXCIvZywgJycpO1xuICByZXR1cm4ge1xuICAgIGxhYmVsLFxuICAgIG9wLFxuICAgIHZhbHVlLFxuICB9O1xufVxuXG5jb25zdCByYW5nZUZ1bmN0aW9ucyA9IFsnY2hhbmdlcycsICdyYXRlJywgJ2lyYXRlJywgJ2luY3JlYXNlJywgJ2RlbHRhJ107XG4vKipcbiAqIEhhbmRsZSBmdW5jdGlvbiBjYWxsIHdoaWNoIGlzIHVzdWFsbHkgYW5kIGlkZW50aWZpZXIgYW5kIGl0cyBib2R5ID4gYXJndW1lbnRzLlxuICogQHBhcmFtIGV4cHJcbiAqIEBwYXJhbSBub2RlXG4gKiBAcGFyYW0gY29udGV4dFxuICovXG5mdW5jdGlvbiBoYW5kbGVGdW5jdGlvbihleHByOiBzdHJpbmcsIG5vZGU6IFN5bnRheE5vZGUsIGNvbnRleHQ6IENvbnRleHQpIHtcbiAgY29uc3QgdmlzUXVlcnkgPSBjb250ZXh0LnF1ZXJ5O1xuICBjb25zdCBuYW1lTm9kZSA9IG5vZGUuZ2V0Q2hpbGQoJ0Z1bmN0aW9uSWRlbnRpZmllcicpO1xuICBjb25zdCBmdW5jTmFtZSA9IGdldFN0cmluZyhleHByLCBuYW1lTm9kZSk7XG5cbiAgY29uc3QgYm9keSA9IG5vZGUuZ2V0Q2hpbGQoJ0Z1bmN0aW9uQ2FsbEJvZHknKTtcbiAgY29uc3QgY2FsbEFyZ3MgPSBib2R5IS5nZXRDaGlsZCgnRnVuY3Rpb25DYWxsQXJncycpO1xuICBjb25zdCBwYXJhbXMgPSBbXTtcbiAgbGV0IGludGVydmFsID0gJyc7XG5cbiAgLy8gVGhpcyBpcyBhIGJpdCBvZiBhIHNob3J0Y3V0IHRvIGdldCB0aGUgaW50ZXJ2YWwgYXJndW1lbnQuIFJlYXNvbnMgYXJlXG4gIC8vIC0gaW50ZXJ2YWwgaXMgbm90IHBhcnQgb2YgdGhlIGZ1bmN0aW9uIGFyZ3MgcGVyIHByb21RTCBncmFtbWFyIGJ1dCB3ZSBtb2RlbCBpdCBhcyBhcmd1bWVudCBmb3IgdGhlIGZ1bmN0aW9uIGluXG4gIC8vICAgdGhlIHF1ZXJ5IG1vZGVsLlxuICAvLyAtIGl0IGlzIGVhc2llciB0byBoYW5kbGUgdGVtcGxhdGUgdmFyaWFibGVzIHRoaXMgd2F5IGFzIHRlbXBsYXRlIHZhcmlhYmxlIGlzIGFuIGVycm9yIGZvciB0aGUgcGFyc2VyXG4gIGlmIChyYW5nZUZ1bmN0aW9ucy5pbmNsdWRlcyhmdW5jTmFtZSkgfHwgZnVuY05hbWUuZW5kc1dpdGgoJ19vdmVyX3RpbWUnKSkge1xuICAgIGxldCBtYXRjaCA9IGdldFN0cmluZyhleHByLCBub2RlKS5tYXRjaCgvXFxbKC4rKVxcXS8pO1xuICAgIGlmIChtYXRjaD8uWzFdKSB7XG4gICAgICBpbnRlcnZhbCA9IG1hdGNoWzFdO1xuICAgICAgcGFyYW1zLnB1c2gobWF0Y2hbMV0pO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG9wID0geyBpZDogZnVuY05hbWUsIHBhcmFtcyB9O1xuICAvLyBXZSB1bnNoaWZ0IG9wZXJhdGlvbnMgdG8ga2VlcCB0aGUgbW9yZSBuYXR1cmFsIG9yZGVyIHRoYXQgd2Ugd2FudCB0byBoYXZlIGluIHRoZSB2aXN1YWwgcXVlcnkgZWRpdG9yLlxuICB2aXNRdWVyeS5vcGVyYXRpb25zLnVuc2hpZnQob3ApO1xuXG4gIGlmIChjYWxsQXJncykge1xuICAgIGlmIChnZXRTdHJpbmcoZXhwciwgY2FsbEFyZ3MpID09PSBpbnRlcnZhbCArICddJykge1xuICAgICAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZSB3aGVyZSB3ZSBoYXZlIGEgZnVuY3Rpb24gd2l0aCBhIHNpbmdsZSBhcmd1bWVudCBhbmQgaXQgaXMgdGhlIGludGVydmFsLlxuICAgICAgLy8gVGhpcyBoYXBwZW5zIHdoZW4geW91IHN0YXJ0IGFkZGluZyBvcGVyYXRpb25zIGluIHF1ZXJ5IGJ1aWxkZXIgYW5kIGRpZCBub3Qgc2V0IGEgbWV0cmljIHlldC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdXBkYXRlRnVuY3Rpb25BcmdzKGV4cHIsIGNhbGxBcmdzLCBjb250ZXh0LCBvcCk7XG4gIH1cbn1cblxuLyoqXG4gKiBIYW5kbGUgYWdncmVnYXRpb24gYXMgdGhleSBhcmUgZGlzdGluY3QgdHlwZSBmcm9tIG90aGVyIGZ1bmN0aW9ucy5cbiAqIEBwYXJhbSBleHByXG4gKiBAcGFyYW0gbm9kZVxuICogQHBhcmFtIGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gaGFuZGxlQWdncmVnYXRpb24oZXhwcjogc3RyaW5nLCBub2RlOiBTeW50YXhOb2RlLCBjb250ZXh0OiBDb250ZXh0KSB7XG4gIGNvbnN0IHZpc1F1ZXJ5ID0gY29udGV4dC5xdWVyeTtcbiAgY29uc3QgbmFtZU5vZGUgPSBub2RlLmdldENoaWxkKCdBZ2dyZWdhdGVPcCcpO1xuICBsZXQgZnVuY05hbWUgPSBnZXRTdHJpbmcoZXhwciwgbmFtZU5vZGUpO1xuXG4gIGNvbnN0IG1vZGlmaWVyID0gbm9kZS5nZXRDaGlsZCgnQWdncmVnYXRlTW9kaWZpZXInKTtcbiAgY29uc3QgbGFiZWxzID0gW107XG5cbiAgaWYgKG1vZGlmaWVyKSB7XG4gICAgY29uc3QgYnlNb2RpZmllciA9IG1vZGlmaWVyLmdldENoaWxkKGBCeWApO1xuICAgIGlmIChieU1vZGlmaWVyICYmIGZ1bmNOYW1lKSB7XG4gICAgICBmdW5jTmFtZSA9IGBfXyR7ZnVuY05hbWV9X2J5YDtcbiAgICB9XG5cbiAgICBjb25zdCB3aXRob3V0TW9kaWZpZXIgPSBtb2RpZmllci5nZXRDaGlsZChgV2l0aG91dGApO1xuICAgIGlmICh3aXRob3V0TW9kaWZpZXIpIHtcbiAgICAgIGZ1bmNOYW1lID0gYF9fJHtmdW5jTmFtZX1fd2l0aG91dGA7XG4gICAgfVxuXG4gICAgbGFiZWxzLnB1c2goLi4uZ2V0QWxsQnlUeXBlKGV4cHIsIG1vZGlmaWVyLCAnR3JvdXBpbmdMYWJlbCcpKTtcbiAgfVxuXG4gIGNvbnN0IGJvZHkgPSBub2RlLmdldENoaWxkKCdGdW5jdGlvbkNhbGxCb2R5Jyk7XG4gIGNvbnN0IGNhbGxBcmdzID0gYm9keSEuZ2V0Q2hpbGQoJ0Z1bmN0aW9uQ2FsbEFyZ3MnKTtcblxuICBjb25zdCBvcDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uID0geyBpZDogZnVuY05hbWUsIHBhcmFtczogW10gfTtcbiAgdmlzUXVlcnkub3BlcmF0aW9ucy51bnNoaWZ0KG9wKTtcbiAgdXBkYXRlRnVuY3Rpb25BcmdzKGV4cHIsIGNhbGxBcmdzLCBjb250ZXh0LCBvcCk7XG4gIC8vIFdlIGFkZCBsYWJlbHMgYWZ0ZXIgcGFyYW1zIGluIHRoZSB2aXN1YWwgcXVlcnkgZWRpdG9yLlxuICBvcC5wYXJhbXMucHVzaCguLi5sYWJlbHMpO1xufVxuXG4vKipcbiAqIEhhbmRsZSAocHJvYmFibHkpIGFsbCB0eXBlcyBvZiBhcmd1bWVudHMgdGhhdCBmdW5jdGlvbiBvciBhZ2dyZWdhdGlvbiBjYW4gaGF2ZS5cbiAqXG4gKiAgRnVuY3Rpb25DYWxsQXJncyBhcmUgbmVzdGVkIGJpdCB3ZWlyZGx5IGJhc2ljYWxseSBpdHMgW2ZpcnN0QXJnLCAuLi5yZXN0XSB3aGVyZSByZXN0IGlzIGFnYWluIEZ1bmN0aW9uQ2FsbEFyZ3Mgc29cbiAqICB3ZSBjYW5ub3QganVzdCBnZXQgYWxsIHRoZSBjaGlsZHJlbiBhbmQgaXRlcmF0ZSB0aGVtIGFzIGFyZ3VtZW50cyB3ZSBoYXZlIHRvIGFnYWluIHJlY3Vyc2l2ZWx5IHRyYXZlcnNlIHRocm91Z2hcbiAqICB0aGVtLlxuICpcbiAqIEBwYXJhbSBleHByXG4gKiBAcGFyYW0gbm9kZVxuICogQHBhcmFtIGNvbnRleHRcbiAqIEBwYXJhbSBvcCAtIFdlIG5lZWQgdGhlIG9wZXJhdGlvbiB0byBhZGQgdGhlIHBhcmFtcyB0byBhcyBhbiBhZGRpdGlvbmFsIGNvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZUZ1bmN0aW9uQXJncyhleHByOiBzdHJpbmcsIG5vZGU6IFN5bnRheE5vZGUgfCBudWxsLCBjb250ZXh0OiBDb250ZXh0LCBvcDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uKSB7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBzd2l0Y2ggKG5vZGUubmFtZSkge1xuICAgIC8vIEluIGNhc2Ugd2UgaGF2ZSBhbiBleHByZXNzaW9uIHdlIGRvbid0IGtub3cgd2hhdCBraW5kIHNvIHdlIGhhdmUgdG8gbG9vayBhdCB0aGUgY2hpbGQgYXMgaXQgY2FuIGJlIGFueXRoaW5nLlxuICAgIGNhc2UgJ0V4cHInOlxuICAgIC8vIEZ1bmN0aW9uQ2FsbEFyZ3MgYXJlIG5lc3RlZCBiaXQgd2VpcmRseSBhcyBtZW50aW9uZWQgc28gd2UgaGF2ZSB0byBnbyBvbmUgZGVlcGVyIGluIHRoaXMgY2FzZS5cbiAgICBjYXNlICdGdW5jdGlvbkNhbGxBcmdzJzoge1xuICAgICAgbGV0IGNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgIHVwZGF0ZUZ1bmN0aW9uQXJncyhleHByLCBjaGlsZCwgY29udGV4dCwgb3ApO1xuICAgICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSAnTnVtYmVyTGl0ZXJhbCc6IHtcbiAgICAgIG9wLnBhcmFtcy5wdXNoKHBhcnNlRmxvYXQoZ2V0U3RyaW5nKGV4cHIsIG5vZGUpKSk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICdTdHJpbmdMaXRlcmFsJzoge1xuICAgICAgb3AucGFyYW1zLnB1c2goZ2V0U3RyaW5nKGV4cHIsIG5vZGUpLnJlcGxhY2UoL1wiL2csICcnKSk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBkZWZhdWx0OiB7XG4gICAgICAvLyBNZWFucyB3ZSBnZXQgdG8gc29tZXRoaW5nIHRoYXQgZG9lcyBub3Qgc2VlbSBsaWtlIHNpbXBsZSBmdW5jdGlvbiBhcmcgYW5kIGlzIHByb2JhYmx5IG5lc3RlZCBxdWVyeSBzbyBqdW1wXG4gICAgICAvLyBiYWNrIHRvIG1haW4gY29udGV4dFxuICAgICAgaGFuZGxlRXhwcmVzc2lvbihleHByLCBub2RlLCBjb250ZXh0KTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSaWdodCBub3cgYmluYXJ5IGV4cHJlc3Npb25zIGNhbiBiZSByZXByZXNlbnRlZCBpbiAyIHdheSBpbiB2aXN1YWwgcXVlcnkuIEFzIGFkZGl0aW9uYWwgb3BlcmF0aW9uIGluIGNhc2UgaXQgaXNcbiAqIGp1c3Qgb3BlcmF0aW9uIHdpdGggc2NhbGFyIG9yIGl0IGNyZWF0ZXMgYSBiaW5hcnlRdWVyeSB3aGVuIGl0J3MgMiBxdWVyaWVzLlxuICogQHBhcmFtIGV4cHJcbiAqIEBwYXJhbSBub2RlXG4gKiBAcGFyYW0gY29udGV4dFxuICovXG5mdW5jdGlvbiBoYW5kbGVCaW5hcnkoZXhwcjogc3RyaW5nLCBub2RlOiBTeW50YXhOb2RlLCBjb250ZXh0OiBDb250ZXh0KSB7XG4gIGNvbnN0IHZpc1F1ZXJ5ID0gY29udGV4dC5xdWVyeTtcbiAgY29uc3QgbGVmdCA9IG5vZGUuZmlyc3RDaGlsZCE7XG4gIGNvbnN0IG9wID0gZ2V0U3RyaW5nKGV4cHIsIGxlZnQubmV4dFNpYmxpbmcpO1xuICBjb25zdCBiaW5Nb2RpZmllciA9IGdldEJpbmFyeU1vZGlmaWVyKGV4cHIsIG5vZGUuZ2V0Q2hpbGQoJ0Jpbk1vZGlmaWVycycpKTtcblxuICBjb25zdCByaWdodCA9IG5vZGUubGFzdENoaWxkITtcblxuICBjb25zdCBvcERlZiA9IGJpbmFyeVNjYWxhck9wZXJhdG9yVG9PcGVyYXRvck5hbWVbb3BdO1xuXG4gIGNvbnN0IGxlZnROdW1iZXIgPSBsZWZ0LmdldENoaWxkKCdOdW1iZXJMaXRlcmFsJyk7XG4gIGNvbnN0IHJpZ2h0TnVtYmVyID0gcmlnaHQuZ2V0Q2hpbGQoJ051bWJlckxpdGVyYWwnKTtcblxuICBjb25zdCByaWdodEJpbmFyeSA9IHJpZ2h0LmdldENoaWxkKCdCaW5hcnlFeHByJyk7XG5cbiAgaWYgKGxlZnROdW1iZXIpIHtcbiAgICAvLyBUT0RPOiB0aGlzIHNob3VsZCBiZSBhbHJlYWR5IGhhbmRsZWQgaW4gY2FzZSBwYXJlbnQgaXMgYmluYXJ5IGV4cHJlc3Npb24gYXMgaXQgaGFzIHRvIGJlIGFkZGVkIHRvIHBhcmVudFxuICAgIC8vICBpZiBxdWVyeSBzdGFydHMgd2l0aCBhIG51bWJlciB0aGF0IGlzbid0IGhhbmRsZWQgbm93LlxuICB9IGVsc2Uge1xuICAgIC8vIElmIHRoaXMgaXMgYmluYXJ5IHdlIGRvbid0IHJlYWxseSBrbm93IGlmIHRoZXJlIGlzIGEgcXVlcnkgb3IganVzdCBjaGFpbmVkIHNjYWxhcnMuIFNvXG4gICAgLy8gd2UgaGF2ZSB0byB0cmF2ZXJzZSBhIGJpdCBkZWVwZXIgdG8ga25vd1xuICAgIGhhbmRsZUV4cHJlc3Npb24oZXhwciwgbGVmdCwgY29udGV4dCk7XG4gIH1cblxuICBpZiAocmlnaHROdW1iZXIpIHtcbiAgICB2aXNRdWVyeS5vcGVyYXRpb25zLnB1c2gobWFrZUJpbk9wKG9wRGVmLCBleHByLCByaWdodCwgISFiaW5Nb2RpZmllcj8uaXNCb29sKSk7XG4gIH0gZWxzZSBpZiAocmlnaHRCaW5hcnkpIHtcbiAgICAvLyBEdWUgdG8gdGhlIHdheSBiaW5hcnkgb3BzIGFyZSBwYXJzZWQgd2UgY2FuIGdldCBhIGJpbmFyeSBvcGVyYXRpb24gb24gdGhlIHJpZ2h0IHRoYXQgc3RhcnRzIHdpdGggYSBudW1iZXIgd2hpY2hcbiAgICAvLyBpcyBhIGZhY3RvciBmb3IgYSBjdXJyZW50IGJpbmFyeSBvcGVyYXRpb24uIFNvIHdlIGhhdmUgdG8gYWRkIGl0IGFzIGFuIG9wZXJhdGlvbiBub3cuXG4gICAgY29uc3QgbGVmdE1vc3RDaGlsZCA9IGdldExlZnRNb3N0Q2hpbGQocmlnaHQpO1xuICAgIGlmIChsZWZ0TW9zdENoaWxkPy5uYW1lID09PSAnTnVtYmVyTGl0ZXJhbCcpIHtcbiAgICAgIHZpc1F1ZXJ5Lm9wZXJhdGlvbnMucHVzaChtYWtlQmluT3Aob3BEZWYsIGV4cHIsIGxlZnRNb3N0Q2hpbGQsICEhYmluTW9kaWZpZXI/LmlzQm9vbCkpO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGFkZGVkIHRoZSBmaXJzdCBudW1iZXIgbGl0ZXJhbCBhcyBvcGVyYXRpb24gaGVyZSB3ZSBzdGlsbCBjYW4gY29udGludWUgYW5kIGhhbmRsZSB0aGUgcmVzdCBhcyB0aGUgZmlyc3RcbiAgICAvLyBudW1iZXIgd2lsbCBiZSBqdXN0IHNraXBwZWQuXG4gICAgaGFuZGxlRXhwcmVzc2lvbihleHByLCByaWdodCwgY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgdmlzUXVlcnkuYmluYXJ5UXVlcmllcyA9IHZpc1F1ZXJ5LmJpbmFyeVF1ZXJpZXMgfHwgW107XG4gICAgY29uc3QgYmluUXVlcnk6IFByb21WaXN1YWxRdWVyeUJpbmFyeSA9IHtcbiAgICAgIG9wZXJhdG9yOiBvcCxcbiAgICAgIHF1ZXJ5OiB7XG4gICAgICAgIG1ldHJpYzogJycsXG4gICAgICAgIGxhYmVsczogW10sXG4gICAgICAgIG9wZXJhdGlvbnM6IFtdLFxuICAgICAgfSxcbiAgICB9O1xuICAgIGlmIChiaW5Nb2RpZmllcj8uaXNNYXRjaGVyKSB7XG4gICAgICBiaW5RdWVyeS52ZWN0b3JNYXRjaGVzVHlwZSA9IGJpbk1vZGlmaWVyLm1hdGNoVHlwZTtcbiAgICAgIGJpblF1ZXJ5LnZlY3Rvck1hdGNoZXMgPSBiaW5Nb2RpZmllci5tYXRjaGVzO1xuICAgIH1cbiAgICB2aXNRdWVyeS5iaW5hcnlRdWVyaWVzLnB1c2goYmluUXVlcnkpO1xuICAgIGhhbmRsZUV4cHJlc3Npb24oZXhwciwgcmlnaHQsIHtcbiAgICAgIHF1ZXJ5OiBiaW5RdWVyeS5xdWVyeSxcbiAgICAgIGVycm9yczogY29udGV4dC5lcnJvcnMsXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QmluYXJ5TW9kaWZpZXIoXG4gIGV4cHI6IHN0cmluZyxcbiAgbm9kZTogU3ludGF4Tm9kZSB8IG51bGxcbik6XG4gIHwgeyBpc0Jvb2w6IHRydWU7IGlzTWF0Y2hlcjogZmFsc2UgfVxuICB8IHsgaXNCb29sOiBmYWxzZTsgaXNNYXRjaGVyOiB0cnVlOyBtYXRjaGVzOiBzdHJpbmc7IG1hdGNoVHlwZTogJ2lnbm9yaW5nJyB8ICdvbicgfVxuICB8IHVuZGVmaW5lZCB7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKG5vZGUuZ2V0Q2hpbGQoJ0Jvb2wnKSkge1xuICAgIHJldHVybiB7IGlzQm9vbDogdHJ1ZSwgaXNNYXRjaGVyOiBmYWxzZSB9O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG1hdGNoZXIgPSBub2RlLmdldENoaWxkKCdPbk9ySWdub3JpbmcnKTtcbiAgICBpZiAoIW1hdGNoZXIpIHtcbiAgICAgIC8vIE5vdCBzdXJlIHdoYXQgdGhpcyBjb3VsZCBiZSwgbWF5YmUgc2hvdWxkIGJlIGFuIGVycm9yLlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgbGFiZWxzID0gZ2V0U3RyaW5nKGV4cHIsIG1hdGNoZXIuZ2V0Q2hpbGQoJ0dyb3VwaW5nTGFiZWxzJyk/LmdldENoaWxkKCdHcm91cGluZ0xhYmVsTGlzdCcpKTtcbiAgICByZXR1cm4ge1xuICAgICAgaXNNYXRjaGVyOiB0cnVlLFxuICAgICAgaXNCb29sOiBmYWxzZSxcbiAgICAgIG1hdGNoZXM6IGxhYmVscyxcbiAgICAgIG1hdGNoVHlwZTogbWF0Y2hlci5nZXRDaGlsZCgnT24nKSA/ICdvbicgOiAnaWdub3JpbmcnLFxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNFbXB0eVF1ZXJ5KHF1ZXJ5OiBQcm9tVmlzdWFsUXVlcnkpIHtcbiAgaWYgKHF1ZXJ5LmxhYmVscy5sZW5ndGggPT09IDAgJiYgcXVlcnkub3BlcmF0aW9ucy5sZW5ndGggPT09IDAgJiYgIXF1ZXJ5Lm1ldHJpYykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbiIsImltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IElucHV0LCBtZWFzdXJlVGV4dCB9IGZyb20gJ0BncmFmYW5hL3VpJztcbmltcG9ydCB7IFByb3BzIGFzIElucHV0UHJvcHMgfSBmcm9tICdAZ3JhZmFuYS91aS9zcmMvY29tcG9uZW50cy9JbnB1dC9JbnB1dCc7XG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIGV4dGVuZHMgSW5wdXRQcm9wcyB7XG4gIC8qKiBTZXRzIHRoZSBtaW4td2lkdGggdG8gYSBtdWx0aXBsZSBvZiA4cHguIERlZmF1bHQgdmFsdWUgaXMgMTAqL1xuICBtaW5XaWR0aD86IG51bWJlcjtcbiAgLyoqIFNldHMgdGhlIG1heC13aWR0aCB0byBhIG11bHRpcGxlIG9mIDhweC4qL1xuICBtYXhXaWR0aD86IG51bWJlcjtcbiAgLyoqIG9uQ2hhbmdlIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBydW4gb24gb25CbHVyIGFuZCBvbktleVByZXNzIHdpdGggZW50ZXIqL1xuICBvbkNvbW1pdENoYW5nZT86IChldmVudDogUmVhY3QuRm9ybUV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB2b2lkO1xufVxuXG5leHBvcnQgY29uc3QgQXV0b1NpemVJbnB1dCA9IFJlYWN0LmZvcndhcmRSZWY8SFRNTElucHV0RWxlbWVudCwgUHJvcHM+KChwcm9wcywgcmVmKSA9PiB7XG4gIGNvbnN0IHsgZGVmYXVsdFZhbHVlID0gJycsIG1pbldpZHRoID0gMTAsIG1heFdpZHRoLCBvbkNvbW1pdENoYW5nZSwgb25LZXlEb3duLCBvbkJsdXIsIC4uLnJlc3RQcm9wcyB9ID0gcHJvcHM7XG4gIGNvbnN0IFt2YWx1ZSwgc2V0VmFsdWVdID0gUmVhY3QudXNlU3RhdGUoZGVmYXVsdFZhbHVlKTtcbiAgY29uc3QgW2lucHV0V2lkdGgsIHNldElucHV0V2lkdGhdID0gUmVhY3QudXNlU3RhdGUobWluV2lkdGgpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2V0SW5wdXRXaWR0aChnZXRXaWR0aEZvcih2YWx1ZS50b1N0cmluZygpLCBtaW5XaWR0aCwgbWF4V2lkdGgpKTtcbiAgfSwgW3ZhbHVlLCBtYXhXaWR0aCwgbWluV2lkdGhdKTtcblxuICByZXR1cm4gKFxuICAgIDxJbnB1dFxuICAgICAgey4uLnJlc3RQcm9wc31cbiAgICAgIHJlZj17cmVmfVxuICAgICAgdmFsdWU9e3ZhbHVlLnRvU3RyaW5nKCl9XG4gICAgICBvbkNoYW5nZT17KGV2ZW50KSA9PiB7XG4gICAgICAgIHNldFZhbHVlKGV2ZW50LmN1cnJlbnRUYXJnZXQudmFsdWUpO1xuICAgICAgfX1cbiAgICAgIHdpZHRoPXtpbnB1dFdpZHRofVxuICAgICAgb25CbHVyPXsoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKG9uQ29tbWl0Q2hhbmdlKSB7XG4gICAgICAgICAgb25Db21taXRDaGFuZ2UoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkJsdXIpIHtcbiAgICAgICAgICBvbkJsdXIoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9fVxuICAgICAgb25LZXlEb3duPXsoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0VudGVyJyAmJiBvbkNvbW1pdENoYW5nZSkge1xuICAgICAgICAgIG9uQ29tbWl0Q2hhbmdlKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25LZXlEb3duKSB7XG4gICAgICAgICAgb25LZXlEb3duKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfX1cbiAgICAgIGRhdGEtdGVzdGlkPXsnYXV0b3NpemUtaW5wdXQnfVxuICAgIC8+XG4gICk7XG59KTtcblxuZnVuY3Rpb24gZ2V0V2lkdGhGb3IodmFsdWU6IHN0cmluZywgbWluV2lkdGg6IG51bWJlciwgbWF4V2lkdGg6IG51bWJlciB8IHVuZGVmaW5lZCk6IG51bWJlciB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gbWluV2lkdGg7XG4gIH1cblxuICBjb25zdCBleHRyYVNwYWNlID0gMztcbiAgY29uc3QgcmVhbFdpZHRoID0gbWVhc3VyZVRleHQodmFsdWUudG9TdHJpbmcoKSwgMTQpLndpZHRoIC8gOCArIGV4dHJhU3BhY2U7XG5cbiAgaWYgKG1pbldpZHRoICYmIHJlYWxXaWR0aCA8IG1pbldpZHRoKSB7XG4gICAgcmV0dXJuIG1pbldpZHRoO1xuICB9XG5cbiAgaWYgKG1heFdpZHRoICYmIHJlYWxXaWR0aCA+IG1heFdpZHRoKSB7XG4gICAgcmV0dXJuIHJlYWxXaWR0aDtcbiAgfVxuXG4gIHJldHVybiByZWFsV2lkdGg7XG59XG5cbkF1dG9TaXplSW5wdXQuZGlzcGxheU5hbWUgPSAnQXV0b1NpemVJbnB1dCc7XG4iLCJpbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IFNlbGVjdGFibGVWYWx1ZSwgdG9PcHRpb24gfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IEFjY2Vzc29yeUJ1dHRvbiwgSW5wdXRHcm91cCB9IGZyb20gJ0BncmFmYW5hL2V4cGVyaW1lbnRhbCc7XG5pbXBvcnQgeyBTZWxlY3QgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5cbmltcG9ydCB7IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICBkZWZhdWx0T3A6IHN0cmluZztcbiAgaXRlbTogUGFydGlhbDxRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcj47XG4gIG9uQ2hhbmdlOiAodmFsdWU6IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyKSA9PiB2b2lkO1xuICBvbkdldExhYmVsTmFtZXM6IChmb3JMYWJlbDogUGFydGlhbDxRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcj4pID0+IFByb21pc2U8U2VsZWN0YWJsZVZhbHVlW10+O1xuICBvbkdldExhYmVsVmFsdWVzOiAoZm9yTGFiZWw6IFBhcnRpYWw8UXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXI+KSA9PiBQcm9taXNlPFNlbGVjdGFibGVWYWx1ZVtdPjtcbiAgb25EZWxldGU6ICgpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBMYWJlbEZpbHRlckl0ZW0oeyBpdGVtLCBkZWZhdWx0T3AsIG9uQ2hhbmdlLCBvbkRlbGV0ZSwgb25HZXRMYWJlbE5hbWVzLCBvbkdldExhYmVsVmFsdWVzIH06IFByb3BzKSB7XG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gdXNlU3RhdGU8e1xuICAgIGxhYmVsTmFtZXM/OiBTZWxlY3RhYmxlVmFsdWVbXTtcbiAgICBsYWJlbFZhbHVlcz86IFNlbGVjdGFibGVWYWx1ZVtdO1xuICAgIGlzTG9hZGluZ0xhYmVsTmFtZXM/OiBib29sZWFuO1xuICAgIGlzTG9hZGluZ0xhYmVsVmFsdWVzPzogYm9vbGVhbjtcbiAgfT4oe30pO1xuXG4gIGNvbnN0IGlzTXVsdGlTZWxlY3QgPSAoKSA9PiB7XG4gICAgcmV0dXJuIGl0ZW0ub3AgPT09IG9wZXJhdG9yc1swXS5sYWJlbDtcbiAgfTtcblxuICBjb25zdCBnZXRTZWxlY3RPcHRpb25zRnJvbVN0cmluZyA9IChpdGVtPzogc3RyaW5nKTogc3RyaW5nW10gPT4ge1xuICAgIGlmIChpdGVtKSB7XG4gICAgICBpZiAoaXRlbS5pbmRleE9mKCd8JykgPiAwKSB7XG4gICAgICAgIHJldHVybiBpdGVtLnNwbGl0KCd8Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW2l0ZW1dO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH07XG5cbiAgY29uc3QgZ2V0T3B0aW9ucyA9ICgpOiBTZWxlY3RhYmxlVmFsdWVbXSA9PiB7XG4gICAgcmV0dXJuIFsuLi5nZXRTZWxlY3RPcHRpb25zRnJvbVN0cmluZyhpdGVtPy52YWx1ZSkubWFwKHRvT3B0aW9uKSwgLi4uKHN0YXRlLmxhYmVsVmFsdWVzID8/IFtdKV07XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGRhdGEtdGVzdGlkPVwicHJvbWV0aGV1cy1kaW1lbnNpb25zLWZpbHRlci1pdGVtXCI+XG4gICAgICA8SW5wdXRHcm91cD5cbiAgICAgICAgPFNlbGVjdFxuICAgICAgICAgIGlucHV0SWQ9XCJwcm9tZXRoZXVzLWRpbWVuc2lvbnMtZmlsdGVyLWl0ZW0ta2V5XCJcbiAgICAgICAgICB3aWR0aD1cImF1dG9cIlxuICAgICAgICAgIHZhbHVlPXtpdGVtLmxhYmVsID8gdG9PcHRpb24oaXRlbS5sYWJlbCkgOiBudWxsfVxuICAgICAgICAgIGFsbG93Q3VzdG9tVmFsdWVcbiAgICAgICAgICBvbk9wZW5NZW51PXthc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBzZXRTdGF0ZSh7IGlzTG9hZGluZ0xhYmVsTmFtZXM6IHRydWUgfSk7XG4gICAgICAgICAgICBjb25zdCBsYWJlbE5hbWVzID0gYXdhaXQgb25HZXRMYWJlbE5hbWVzKGl0ZW0pO1xuICAgICAgICAgICAgc2V0U3RhdGUoeyBsYWJlbE5hbWVzLCBpc0xvYWRpbmdMYWJlbE5hbWVzOiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgfX1cbiAgICAgICAgICBpc0xvYWRpbmc9e3N0YXRlLmlzTG9hZGluZ0xhYmVsTmFtZXN9XG4gICAgICAgICAgb3B0aW9ucz17c3RhdGUubGFiZWxOYW1lc31cbiAgICAgICAgICBvbkNoYW5nZT17KGNoYW5nZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGNoYW5nZS5sYWJlbCkge1xuICAgICAgICAgICAgICBvbkNoYW5nZSh7XG4gICAgICAgICAgICAgICAgLi4uaXRlbSxcbiAgICAgICAgICAgICAgICBvcDogaXRlbS5vcCA/PyBkZWZhdWx0T3AsXG4gICAgICAgICAgICAgICAgbGFiZWw6IGNoYW5nZS5sYWJlbCxcbiAgICAgICAgICAgICAgfSBhcyBhbnkgYXMgUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH19XG4gICAgICAgIC8+XG5cbiAgICAgICAgPFNlbGVjdFxuICAgICAgICAgIHZhbHVlPXt0b09wdGlvbihpdGVtLm9wID8/IGRlZmF1bHRPcCl9XG4gICAgICAgICAgb3B0aW9ucz17b3BlcmF0b3JzfVxuICAgICAgICAgIHdpZHRoPVwiYXV0b1wiXG4gICAgICAgICAgb25DaGFuZ2U9eyhjaGFuZ2UpID0+IHtcbiAgICAgICAgICAgIGlmIChjaGFuZ2UudmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBvbkNoYW5nZSh7IC4uLml0ZW0sIG9wOiBjaGFuZ2UudmFsdWUgfSBhcyBhbnkgYXMgUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH19XG4gICAgICAgIC8+XG5cbiAgICAgICAgPFNlbGVjdFxuICAgICAgICAgIGlucHV0SWQ9XCJwcm9tZXRoZXVzLWRpbWVuc2lvbnMtZmlsdGVyLWl0ZW0tdmFsdWVcIlxuICAgICAgICAgIHdpZHRoPVwiYXV0b1wiXG4gICAgICAgICAgdmFsdWU9e1xuICAgICAgICAgICAgaXNNdWx0aVNlbGVjdCgpXG4gICAgICAgICAgICAgID8gZ2V0U2VsZWN0T3B0aW9uc0Zyb21TdHJpbmcoaXRlbT8udmFsdWUpLm1hcCh0b09wdGlvbilcbiAgICAgICAgICAgICAgOiBnZXRTZWxlY3RPcHRpb25zRnJvbVN0cmluZyhpdGVtPy52YWx1ZSkubWFwKHRvT3B0aW9uKVswXVxuICAgICAgICAgIH1cbiAgICAgICAgICBhbGxvd0N1c3RvbVZhbHVlXG4gICAgICAgICAgb25PcGVuTWVudT17YXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgc2V0U3RhdGUoeyBpc0xvYWRpbmdMYWJlbFZhbHVlczogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsVmFsdWVzID0gYXdhaXQgb25HZXRMYWJlbFZhbHVlcyhpdGVtKTtcbiAgICAgICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgIGxhYmVsVmFsdWVzLFxuICAgICAgICAgICAgICBpc0xvYWRpbmdMYWJlbFZhbHVlczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfX1cbiAgICAgICAgICBpc011bHRpPXtpc011bHRpU2VsZWN0KCl9XG4gICAgICAgICAgaXNMb2FkaW5nPXtzdGF0ZS5pc0xvYWRpbmdMYWJlbFZhbHVlc31cbiAgICAgICAgICBvcHRpb25zPXtnZXRPcHRpb25zKCl9XG4gICAgICAgICAgb25DaGFuZ2U9eyhjaGFuZ2UpID0+IHtcbiAgICAgICAgICAgIGlmIChjaGFuZ2UudmFsdWUpIHtcbiAgICAgICAgICAgICAgb25DaGFuZ2UoeyAuLi5pdGVtLCB2YWx1ZTogY2hhbmdlLnZhbHVlLCBvcDogaXRlbS5vcCA/PyBkZWZhdWx0T3AgfSBhcyBhbnkgYXMgUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IGNoYW5nZVxuICAgICAgICAgICAgICAgIC5tYXAoKGNoYW5nZTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY2hhbmdlLmxhYmVsO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmpvaW4oJ3wnKTtcbiAgICAgICAgICAgICAgb25DaGFuZ2UoeyAuLi5pdGVtLCB2YWx1ZTogY2hhbmdlcywgb3A6IGl0ZW0ub3AgPz8gZGVmYXVsdE9wIH0gYXMgYW55IGFzIFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9fVxuICAgICAgICAvPlxuICAgICAgICA8QWNjZXNzb3J5QnV0dG9uIGFyaWEtbGFiZWw9XCJyZW1vdmVcIiBpY29uPVwidGltZXNcIiB2YXJpYW50PVwic2Vjb25kYXJ5XCIgb25DbGljaz17b25EZWxldGV9IC8+XG4gICAgICA8L0lucHV0R3JvdXA+XG4gICAgPC9kaXY+XG4gICk7XG59XG5cbmNvbnN0IG9wZXJhdG9ycyA9IFtcbiAgeyBsYWJlbDogJz1+JywgdmFsdWU6ICc9ficgfSxcbiAgeyBsYWJlbDogJz0nLCB2YWx1ZTogJz0nIH0sXG4gIHsgbGFiZWw6ICchPScsIHZhbHVlOiAnIT0nIH0sXG4gIHsgbGFiZWw6ICchficsIHZhbHVlOiAnIX4nIH0sXG5dO1xuIiwiaW1wb3J0IHsgaXNFcXVhbCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgU2VsZWN0YWJsZVZhbHVlIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBFZGl0b3JGaWVsZEdyb3VwLCBFZGl0b3JMaXN0LCBFZGl0b3JGaWVsZCB9IGZyb20gJ0BncmFmYW5hL2V4cGVyaW1lbnRhbCc7XG5cbmltcG9ydCB7IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyIH0gZnJvbSAnLi4vc2hhcmVkL3R5cGVzJztcblxuaW1wb3J0IHsgTGFiZWxGaWx0ZXJJdGVtIH0gZnJvbSAnLi9MYWJlbEZpbHRlckl0ZW0nO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgbGFiZWxzRmlsdGVyczogUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXJbXTtcbiAgb25DaGFuZ2U6IChsYWJlbEZpbHRlcnM6IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyW10pID0+IHZvaWQ7XG4gIG9uR2V0TGFiZWxOYW1lczogKGZvckxhYmVsOiBQYXJ0aWFsPFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyPikgPT4gUHJvbWlzZTxTZWxlY3RhYmxlVmFsdWVbXT47XG4gIG9uR2V0TGFiZWxWYWx1ZXM6IChmb3JMYWJlbDogUGFydGlhbDxRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcj4pID0+IFByb21pc2U8U2VsZWN0YWJsZVZhbHVlW10+O1xuICBlcnJvcj86IHN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIExhYmVsRmlsdGVycyh7IGxhYmVsc0ZpbHRlcnMsIG9uQ2hhbmdlLCBvbkdldExhYmVsTmFtZXMsIG9uR2V0TGFiZWxWYWx1ZXMsIGVycm9yIH06IFByb3BzKSB7XG4gIGNvbnN0IGRlZmF1bHRPcCA9ICc9JztcbiAgY29uc3QgW2l0ZW1zLCBzZXRJdGVtc10gPSB1c2VTdGF0ZTxBcnJheTxQYXJ0aWFsPFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyPj4+KFt7IG9wOiBkZWZhdWx0T3AgfV0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGxhYmVsc0ZpbHRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgc2V0SXRlbXMobGFiZWxzRmlsdGVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldEl0ZW1zKFt7IG9wOiBkZWZhdWx0T3AgfV0pO1xuICAgIH1cbiAgfSwgW2xhYmVsc0ZpbHRlcnNdKTtcblxuICBjb25zdCBvbkxhYmVsc0NoYW5nZSA9IChuZXdJdGVtczogQXJyYXk8UGFydGlhbDxRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcj4+KSA9PiB7XG4gICAgc2V0SXRlbXMobmV3SXRlbXMpO1xuXG4gICAgLy8gRXh0cmFjdCBmdWxsIGxhYmVsIGZpbHRlcnMgd2l0aCBib3RoIGxhYmVsICYgdmFsdWVcbiAgICBjb25zdCBuZXdMYWJlbHMgPSBuZXdJdGVtcy5maWx0ZXIoKHgpID0+IHgubGFiZWwgIT0gbnVsbCAmJiB4LnZhbHVlICE9IG51bGwpO1xuICAgIGlmICghaXNFcXVhbChuZXdMYWJlbHMsIGxhYmVsc0ZpbHRlcnMpKSB7XG4gICAgICBvbkNoYW5nZShuZXdMYWJlbHMgYXMgUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXJbXSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPEVkaXRvckZpZWxkR3JvdXA+XG4gICAgICA8RWRpdG9yRmllbGQgbGFiZWw9XCJMYWJlbHNcIiBlcnJvcj17ZXJyb3J9IGludmFsaWQ9eyEhZXJyb3J9PlxuICAgICAgICA8RWRpdG9yTGlzdFxuICAgICAgICAgIGl0ZW1zPXtpdGVtc31cbiAgICAgICAgICBvbkNoYW5nZT17b25MYWJlbHNDaGFuZ2V9XG4gICAgICAgICAgcmVuZGVySXRlbT17KGl0ZW0sIG9uQ2hhbmdlSXRlbSwgb25EZWxldGUpID0+IChcbiAgICAgICAgICAgIDxMYWJlbEZpbHRlckl0ZW1cbiAgICAgICAgICAgICAgaXRlbT17aXRlbX1cbiAgICAgICAgICAgICAgZGVmYXVsdE9wPXtkZWZhdWx0T3B9XG4gICAgICAgICAgICAgIG9uQ2hhbmdlPXtvbkNoYW5nZUl0ZW19XG4gICAgICAgICAgICAgIG9uRGVsZXRlPXtvbkRlbGV0ZX1cbiAgICAgICAgICAgICAgb25HZXRMYWJlbE5hbWVzPXtvbkdldExhYmVsTmFtZXN9XG4gICAgICAgICAgICAgIG9uR2V0TGFiZWxWYWx1ZXM9e29uR2V0TGFiZWxWYWx1ZXN9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICl9XG4gICAgICAgIC8+XG4gICAgICA8L0VkaXRvckZpZWxkPlxuICAgIDwvRWRpdG9yRmllbGRHcm91cD5cbiAgKTtcbn1cbiIsImltcG9ydCB7IFJlZ2lzdHJ5IH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5cbmltcG9ydCB7IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlciwgUXVlcnlCdWlsZGVyT3BlcmF0aW9uLCBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsIFZpc3VhbFF1ZXJ5TW9kZWxsZXIgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBWaXN1YWxRdWVyeUJpbmFyeTxUPiB7XG4gIG9wZXJhdG9yOiBzdHJpbmc7XG4gIHZlY3Rvck1hdGNoZXNUeXBlPzogJ29uJyB8ICdpZ25vcmluZyc7XG4gIHZlY3Rvck1hdGNoZXM/OiBzdHJpbmc7XG4gIHF1ZXJ5OiBUO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb21Mb2tpVmlzdWFsUXVlcnkge1xuICBtZXRyaWM/OiBzdHJpbmc7XG4gIGxhYmVsczogUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXJbXTtcbiAgb3BlcmF0aW9uczogUXVlcnlCdWlsZGVyT3BlcmF0aW9uW107XG4gIGJpbmFyeVF1ZXJpZXM/OiBBcnJheTxWaXN1YWxRdWVyeUJpbmFyeTxQcm9tTG9raVZpc3VhbFF1ZXJ5Pj47XG59XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBMb2tpQW5kUHJvbVF1ZXJ5TW9kZWxsZXJCYXNlIGltcGxlbWVudHMgVmlzdWFsUXVlcnlNb2RlbGxlciB7XG4gIHByb3RlY3RlZCBvcGVyYXRpb25zUmVnaXN0eTogUmVnaXN0cnk8UXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmPjtcbiAgcHJpdmF0ZSBjYXRlZ29yaWVzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKGdldE9wZXJhdGlvbnM6ICgpID0+IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZltdKSB7XG4gICAgdGhpcy5vcGVyYXRpb25zUmVnaXN0eSA9IG5ldyBSZWdpc3RyeTxRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWY+KGdldE9wZXJhdGlvbnMpO1xuICB9XG5cbiAgcHJvdGVjdGVkIHNldE9wZXJhdGlvbkNhdGVnb3JpZXMoY2F0ZWdvcmllczogc3RyaW5nW10pIHtcbiAgICB0aGlzLmNhdGVnb3JpZXMgPSBjYXRlZ29yaWVzO1xuICB9XG5cbiAgZ2V0T3BlcmF0aW9uc0ZvckNhdGVnb3J5KGNhdGVnb3J5OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5vcGVyYXRpb25zUmVnaXN0eS5saXN0KCkuZmlsdGVyKChvcCkgPT4gb3AuY2F0ZWdvcnkgPT09IGNhdGVnb3J5ICYmICFvcC5oaWRlRnJvbUxpc3QpO1xuICB9XG5cbiAgZ2V0QWx0ZXJuYXRpdmVPcGVyYXRpb25zKGtleTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMub3BlcmF0aW9uc1JlZ2lzdHkubGlzdCgpLmZpbHRlcigob3ApID0+IG9wLmFsdGVybmF0aXZlc0tleSA9PT0ga2V5KTtcbiAgfVxuXG4gIGdldENhdGVnb3JpZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2F0ZWdvcmllcztcbiAgfVxuXG4gIGdldE9wZXJhdGlvbkRlZihpZDogc3RyaW5nKTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5vcGVyYXRpb25zUmVnaXN0eS5nZXRJZkV4aXN0cyhpZCk7XG4gIH1cblxuICByZW5kZXJPcGVyYXRpb25zKHF1ZXJ5U3RyaW5nOiBzdHJpbmcsIG9wZXJhdGlvbnM6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbltdKSB7XG4gICAgZm9yIChjb25zdCBvcGVyYXRpb24gb2Ygb3BlcmF0aW9ucykge1xuICAgICAgY29uc3QgZGVmID0gdGhpcy5vcGVyYXRpb25zUmVnaXN0eS5nZXRJZkV4aXN0cyhvcGVyYXRpb24uaWQpO1xuICAgICAgaWYgKCFkZWYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBvcGVyYXRpb24gJHtvcGVyYXRpb24uaWR9IGluIHRoZSByZWdpc3RyeWApO1xuICAgICAgfVxuICAgICAgcXVlcnlTdHJpbmcgPSBkZWYucmVuZGVyZXIob3BlcmF0aW9uLCBkZWYsIHF1ZXJ5U3RyaW5nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcXVlcnlTdHJpbmc7XG4gIH1cblxuICByZW5kZXJCaW5hcnlRdWVyaWVzKHF1ZXJ5U3RyaW5nOiBzdHJpbmcsIGJpbmFyeVF1ZXJpZXM/OiBBcnJheTxWaXN1YWxRdWVyeUJpbmFyeTxQcm9tTG9raVZpc3VhbFF1ZXJ5Pj4pIHtcbiAgICBpZiAoYmluYXJ5UXVlcmllcykge1xuICAgICAgZm9yIChjb25zdCBiaW5RdWVyeSBvZiBiaW5hcnlRdWVyaWVzKSB7XG4gICAgICAgIHF1ZXJ5U3RyaW5nID0gYCR7dGhpcy5yZW5kZXJCaW5hcnlRdWVyeShxdWVyeVN0cmluZywgYmluUXVlcnkpfWA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBxdWVyeVN0cmluZztcbiAgfVxuXG4gIHByaXZhdGUgcmVuZGVyQmluYXJ5UXVlcnkobGVmdE9wZXJhbmQ6IHN0cmluZywgYmluYXJ5UXVlcnk6IFZpc3VhbFF1ZXJ5QmluYXJ5PFByb21Mb2tpVmlzdWFsUXVlcnk+KSB7XG4gICAgbGV0IHJlc3VsdCA9IGxlZnRPcGVyYW5kICsgYCAke2JpbmFyeVF1ZXJ5Lm9wZXJhdG9yfSBgO1xuXG4gICAgaWYgKGJpbmFyeVF1ZXJ5LnZlY3Rvck1hdGNoZXMpIHtcbiAgICAgIHJlc3VsdCArPSBgJHtiaW5hcnlRdWVyeS52ZWN0b3JNYXRjaGVzVHlwZX0oJHtiaW5hcnlRdWVyeS52ZWN0b3JNYXRjaGVzfSkgYDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0ICsgdGhpcy5yZW5kZXJRdWVyeShiaW5hcnlRdWVyeS5xdWVyeSwgdHJ1ZSk7XG4gIH1cblxuICByZW5kZXJMYWJlbHMobGFiZWxzOiBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcltdKSB7XG4gICAgaWYgKGxhYmVscy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBsZXQgZXhwciA9ICd7JztcbiAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiBsYWJlbHMpIHtcbiAgICAgIGlmIChleHByICE9PSAneycpIHtcbiAgICAgICAgZXhwciArPSAnLCAnO1xuICAgICAgfVxuXG4gICAgICBleHByICs9IGAke2ZpbHRlci5sYWJlbH0ke2ZpbHRlci5vcH1cIiR7ZmlsdGVyLnZhbHVlfVwiYDtcbiAgICB9XG5cbiAgICByZXR1cm4gZXhwciArIGB9YDtcbiAgfVxuXG4gIHJlbmRlclF1ZXJ5KHF1ZXJ5OiBQcm9tTG9raVZpc3VhbFF1ZXJ5LCBuZXN0ZWQ/OiBib29sZWFuKSB7XG4gICAgbGV0IHF1ZXJ5U3RyaW5nID0gYCR7cXVlcnkubWV0cmljID8/ICcnfSR7dGhpcy5yZW5kZXJMYWJlbHMocXVlcnkubGFiZWxzKX1gO1xuICAgIHF1ZXJ5U3RyaW5nID0gdGhpcy5yZW5kZXJPcGVyYXRpb25zKHF1ZXJ5U3RyaW5nLCBxdWVyeS5vcGVyYXRpb25zKTtcblxuICAgIGlmICghbmVzdGVkICYmIHRoaXMuaGFzQmluYXJ5T3AocXVlcnkpICYmIEJvb2xlYW4ocXVlcnkuYmluYXJ5UXVlcmllcz8ubGVuZ3RoKSkge1xuICAgICAgcXVlcnlTdHJpbmcgPSBgKCR7cXVlcnlTdHJpbmd9KWA7XG4gICAgfVxuXG4gICAgcXVlcnlTdHJpbmcgPSB0aGlzLnJlbmRlckJpbmFyeVF1ZXJpZXMocXVlcnlTdHJpbmcsIHF1ZXJ5LmJpbmFyeVF1ZXJpZXMpO1xuXG4gICAgaWYgKG5lc3RlZCAmJiAodGhpcy5oYXNCaW5hcnlPcChxdWVyeSkgfHwgQm9vbGVhbihxdWVyeS5iaW5hcnlRdWVyaWVzPy5sZW5ndGgpKSkge1xuICAgICAgcXVlcnlTdHJpbmcgPSBgKCR7cXVlcnlTdHJpbmd9KWA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHF1ZXJ5U3RyaW5nO1xuICB9XG5cbiAgaGFzQmluYXJ5T3AocXVlcnk6IFByb21Mb2tpVmlzdWFsUXVlcnkpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKFxuICAgICAgcXVlcnkub3BlcmF0aW9ucy5maW5kKChvcCkgPT4ge1xuICAgICAgICBjb25zdCBkZWYgPSB0aGlzLmdldE9wZXJhdGlvbkRlZihvcC5pZCk7XG4gICAgICAgIHJldHVybiBkZWY/LmNhdGVnb3J5ID09PSBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5CaW5hcnlPcHM7XG4gICAgICB9KSAhPT0gdW5kZWZpbmVkXG4gICAgKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgY3NzLCBjeCB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IERyYWdnYWJsZSB9IGZyb20gJ3JlYWN0LWJlYXV0aWZ1bC1kbmQnO1xuXG5pbXBvcnQgeyBEYXRhU291cmNlQXBpLCBHcmFmYW5hVGhlbWUyIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBTdGFjayB9IGZyb20gJ0BncmFmYW5hL2V4cGVyaW1lbnRhbCc7XG5pbXBvcnQgeyBCdXR0b24sIEljb24sIFRvb2x0aXAsIHVzZVN0eWxlczIgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5cbmltcG9ydCB7XG4gIFZpc3VhbFF1ZXJ5TW9kZWxsZXIsXG4gIFF1ZXJ5QnVpbGRlck9wZXJhdGlvbixcbiAgUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1WYWx1ZSxcbiAgUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLFxuICBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbURlZixcbn0gZnJvbSAnLi4vc2hhcmVkL3R5cGVzJztcblxuaW1wb3J0IHsgT3BlcmF0aW9uSGVhZGVyIH0gZnJvbSAnLi9PcGVyYXRpb25IZWFkZXInO1xuaW1wb3J0IHsgZ2V0T3BlcmF0aW9uUGFyYW1FZGl0b3IgfSBmcm9tICcuL09wZXJhdGlvblBhcmFtRWRpdG9yJztcbmltcG9ydCB7IGdldE9wZXJhdGlvblBhcmFtSWQgfSBmcm9tICcuL29wZXJhdGlvblV0aWxzJztcblxuZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gIG9wZXJhdGlvbjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uO1xuICBpbmRleDogbnVtYmVyO1xuICBxdWVyeTogYW55O1xuICBkYXRhc291cmNlOiBEYXRhU291cmNlQXBpO1xuICBxdWVyeU1vZGVsbGVyOiBWaXN1YWxRdWVyeU1vZGVsbGVyO1xuICBvbkNoYW5nZTogKGluZGV4OiBudW1iZXIsIHVwZGF0ZTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uKSA9PiB2b2lkO1xuICBvblJlbW92ZTogKGluZGV4OiBudW1iZXIpID0+IHZvaWQ7XG4gIG9uUnVuUXVlcnk6ICgpID0+IHZvaWQ7XG4gIGhpZ2hsaWdodD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBPcGVyYXRpb25FZGl0b3Ioe1xuICBvcGVyYXRpb24sXG4gIGluZGV4LFxuICBvblJlbW92ZSxcbiAgb25DaGFuZ2UsXG4gIG9uUnVuUXVlcnksXG4gIHF1ZXJ5TW9kZWxsZXIsXG4gIHF1ZXJ5LFxuICBkYXRhc291cmNlLFxuICBoaWdobGlnaHQsXG59OiBQcm9wcykge1xuICBjb25zdCBzdHlsZXMgPSB1c2VTdHlsZXMyKGdldFN0eWxlcyk7XG4gIGNvbnN0IGRlZiA9IHF1ZXJ5TW9kZWxsZXIuZ2V0T3BlcmF0aW9uRGVmKG9wZXJhdGlvbi5pZCk7XG4gIGNvbnN0IHNob3VsZEhpZ2hsaWdodCA9IHVzZUhpZ2hsaWdodChoaWdobGlnaHQpO1xuXG4gIGlmICghZGVmKSB7XG4gICAgcmV0dXJuIDxzcGFuPk9wZXJhdGlvbiB7b3BlcmF0aW9uLmlkfSBub3QgZm91bmQ8L3NwYW4+O1xuICB9XG5cbiAgY29uc3Qgb25QYXJhbVZhbHVlQ2hhbmdlZCA9IChwYXJhbUlkeDogbnVtYmVyLCB2YWx1ZTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1WYWx1ZSkgPT4ge1xuICAgIGNvbnN0IHVwZGF0ZTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uID0geyAuLi5vcGVyYXRpb24sIHBhcmFtczogWy4uLm9wZXJhdGlvbi5wYXJhbXNdIH07XG4gICAgdXBkYXRlLnBhcmFtc1twYXJhbUlkeF0gPSB2YWx1ZTtcbiAgICBjYWxsUGFyYW1DaGFuZ2VkVGhlbk9uQ2hhbmdlKGRlZiwgdXBkYXRlLCBpbmRleCwgcGFyYW1JZHgsIG9uQ2hhbmdlKTtcbiAgfTtcblxuICBjb25zdCBvbkFkZFJlc3RQYXJhbSA9ICgpID0+IHtcbiAgICBjb25zdCB1cGRhdGU6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiA9IHsgLi4ub3BlcmF0aW9uLCBwYXJhbXM6IFsuLi5vcGVyYXRpb24ucGFyYW1zLCAnJ10gfTtcbiAgICBjYWxsUGFyYW1DaGFuZ2VkVGhlbk9uQ2hhbmdlKGRlZiwgdXBkYXRlLCBpbmRleCwgb3BlcmF0aW9uLnBhcmFtcy5sZW5ndGgsIG9uQ2hhbmdlKTtcbiAgfTtcblxuICBjb25zdCBvblJlbW92ZVJlc3RQYXJhbSA9IChwYXJhbUlkeDogbnVtYmVyKSA9PiB7XG4gICAgY29uc3QgdXBkYXRlOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24gPSB7XG4gICAgICAuLi5vcGVyYXRpb24sXG4gICAgICBwYXJhbXM6IFsuLi5vcGVyYXRpb24ucGFyYW1zLnNsaWNlKDAsIHBhcmFtSWR4KSwgLi4ub3BlcmF0aW9uLnBhcmFtcy5zbGljZShwYXJhbUlkeCArIDEpXSxcbiAgICB9O1xuICAgIGNhbGxQYXJhbUNoYW5nZWRUaGVuT25DaGFuZ2UoZGVmLCB1cGRhdGUsIGluZGV4LCBwYXJhbUlkeCwgb25DaGFuZ2UpO1xuICB9O1xuXG4gIGNvbnN0IG9wZXJhdGlvbkVsZW1lbnRzOiBSZWFjdC5SZWFjdE5vZGVbXSA9IFtdO1xuXG4gIGZvciAobGV0IHBhcmFtSW5kZXggPSAwOyBwYXJhbUluZGV4IDwgb3BlcmF0aW9uLnBhcmFtcy5sZW5ndGg7IHBhcmFtSW5kZXgrKykge1xuICAgIGNvbnN0IHBhcmFtRGVmID0gZGVmLnBhcmFtc1tNYXRoLm1pbihkZWYucGFyYW1zLmxlbmd0aCAtIDEsIHBhcmFtSW5kZXgpXTtcbiAgICBjb25zdCBFZGl0b3IgPSBnZXRPcGVyYXRpb25QYXJhbUVkaXRvcihwYXJhbURlZik7XG5cbiAgICBvcGVyYXRpb25FbGVtZW50cy5wdXNoKFxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5wYXJhbVJvd30ga2V5PXtgJHtwYXJhbUluZGV4fS0xYH0+XG4gICAgICAgIHshcGFyYW1EZWYuaGlkZU5hbWUgJiYgKFxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMucGFyYW1OYW1lfT5cbiAgICAgICAgICAgIDxsYWJlbCBodG1sRm9yPXtnZXRPcGVyYXRpb25QYXJhbUlkKGluZGV4LCBwYXJhbUluZGV4KX0+e3BhcmFtRGVmLm5hbWV9PC9sYWJlbD5cbiAgICAgICAgICAgIHtwYXJhbURlZi5kZXNjcmlwdGlvbiAmJiAoXG4gICAgICAgICAgICAgIDxUb29sdGlwIHBsYWNlbWVudD1cInRvcFwiIGNvbnRlbnQ9e3BhcmFtRGVmLmRlc2NyaXB0aW9ufSB0aGVtZT1cImluZm9cIj5cbiAgICAgICAgICAgICAgICA8SWNvbiBuYW1lPVwiaW5mby1jaXJjbGVcIiBzaXplPVwic21cIiBjbGFzc05hbWU9e3N0eWxlcy5pbmZvSWNvbn0gLz5cbiAgICAgICAgICAgICAgPC9Ub29sdGlwPlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKX1cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5wYXJhbVZhbHVlfT5cbiAgICAgICAgICA8U3RhY2sgZ2FwPXswLjV9IGRpcmVjdGlvbj1cInJvd1wiIGFsaWduSXRlbXM9XCJjZW50ZXJcIiB3cmFwPXtmYWxzZX0+XG4gICAgICAgICAgICA8RWRpdG9yXG4gICAgICAgICAgICAgIGluZGV4PXtwYXJhbUluZGV4fVxuICAgICAgICAgICAgICBwYXJhbURlZj17cGFyYW1EZWZ9XG4gICAgICAgICAgICAgIHZhbHVlPXtvcGVyYXRpb24ucGFyYW1zW3BhcmFtSW5kZXhdfVxuICAgICAgICAgICAgICBvcGVyYXRpb249e29wZXJhdGlvbn1cbiAgICAgICAgICAgICAgb3BlcmF0aW9uSW5kZXg9e2luZGV4fVxuICAgICAgICAgICAgICBvbkNoYW5nZT17b25QYXJhbVZhbHVlQ2hhbmdlZH1cbiAgICAgICAgICAgICAgb25SdW5RdWVyeT17b25SdW5RdWVyeX1cbiAgICAgICAgICAgICAgcXVlcnk9e3F1ZXJ5fVxuICAgICAgICAgICAgICBkYXRhc291cmNlPXtkYXRhc291cmNlfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIHtwYXJhbURlZi5yZXN0UGFyYW0gJiYgKG9wZXJhdGlvbi5wYXJhbXMubGVuZ3RoID4gZGVmLnBhcmFtcy5sZW5ndGggfHwgcGFyYW1EZWYub3B0aW9uYWwpICYmIChcbiAgICAgICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgICAgIGRhdGEtdGVzdGlkPXtgb3BlcmF0aW9ucy4ke2luZGV4fS5yZW1vdmUtcmVzdC1wYXJhbWB9XG4gICAgICAgICAgICAgICAgc2l6ZT1cInNtXCJcbiAgICAgICAgICAgICAgICBmaWxsPVwidGV4dFwiXG4gICAgICAgICAgICAgICAgaWNvbj1cInRpbWVzXCJcbiAgICAgICAgICAgICAgICB2YXJpYW50PVwic2Vjb25kYXJ5XCJcbiAgICAgICAgICAgICAgICB0aXRsZT17YFJlbW92ZSAke3BhcmFtRGVmLm5hbWV9YH1cbiAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBvblJlbW92ZVJlc3RQYXJhbShwYXJhbUluZGV4KX1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICl9XG4gICAgICAgICAgPC9TdGFjaz5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgLy8gSGFuZGxlIGFkZGluZyBidXR0b24gZm9yIHJlc3QgcGFyYW1zXG4gIGxldCByZXN0UGFyYW06IFJlYWN0LlJlYWN0Tm9kZSB8IHVuZGVmaW5lZDtcbiAgaWYgKGRlZi5wYXJhbXMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGxhc3RQYXJhbURlZiA9IGRlZi5wYXJhbXNbZGVmLnBhcmFtcy5sZW5ndGggLSAxXTtcbiAgICBpZiAobGFzdFBhcmFtRGVmLnJlc3RQYXJhbSkge1xuICAgICAgcmVzdFBhcmFtID0gcmVuZGVyQWRkUmVzdFBhcmFtQnV0dG9uKGxhc3RQYXJhbURlZiwgb25BZGRSZXN0UGFyYW0sIGluZGV4LCBvcGVyYXRpb24ucGFyYW1zLmxlbmd0aCwgc3R5bGVzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxEcmFnZ2FibGUgZHJhZ2dhYmxlSWQ9e2BvcGVyYXRpb24tJHtpbmRleH1gfSBpbmRleD17aW5kZXh9PlxuICAgICAgeyhwcm92aWRlZCkgPT4gKFxuICAgICAgICA8ZGl2XG4gICAgICAgICAgY2xhc3NOYW1lPXtjeChzdHlsZXMuY2FyZCwgc2hvdWxkSGlnaGxpZ2h0ICYmIHN0eWxlcy5jYXJkSGlnaGxpZ2h0KX1cbiAgICAgICAgICByZWY9e3Byb3ZpZGVkLmlubmVyUmVmfVxuICAgICAgICAgIHsuLi5wcm92aWRlZC5kcmFnZ2FibGVQcm9wc31cbiAgICAgICAgICBkYXRhLXRlc3RpZD17YG9wZXJhdGlvbnMuJHtpbmRleH0ud3JhcHBlcmB9XG4gICAgICAgID5cbiAgICAgICAgICA8T3BlcmF0aW9uSGVhZGVyXG4gICAgICAgICAgICBvcGVyYXRpb249e29wZXJhdGlvbn1cbiAgICAgICAgICAgIGRyYWdIYW5kbGVQcm9wcz17cHJvdmlkZWQuZHJhZ0hhbmRsZVByb3BzfVxuICAgICAgICAgICAgZGVmPXtkZWZ9XG4gICAgICAgICAgICBpbmRleD17aW5kZXh9XG4gICAgICAgICAgICBvbkNoYW5nZT17b25DaGFuZ2V9XG4gICAgICAgICAgICBvblJlbW92ZT17b25SZW1vdmV9XG4gICAgICAgICAgICBxdWVyeU1vZGVsbGVyPXtxdWVyeU1vZGVsbGVyfVxuICAgICAgICAgIC8+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5ib2R5fT57b3BlcmF0aW9uRWxlbWVudHN9PC9kaXY+XG4gICAgICAgICAge3Jlc3RQYXJhbX1cbiAgICAgICAgICB7aW5kZXggPCBxdWVyeS5vcGVyYXRpb25zLmxlbmd0aCAtIDEgJiYgKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5hcnJvd30+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuYXJyb3dMaW5lfSAvPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmFycm93QXJyb3d9IC8+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICApfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG4gICAgPC9EcmFnZ2FibGU+XG4gICk7XG59XG5cbi8qKlxuICogV2hlbiBoaWdobGlnaHQgaXMgc3dpdGNoZWQgb24gbWFrZXMgc3VyZSBpdCBpcyBzd2l0Y2hlZCBvZiByaWdodCBhd2F5LCBzbyB3ZSBqdXN0IGZsYXNoIHRoZSBoaWdobGlnaHQgYW5kIHRoZW4gZmFkZVxuICogb3V0LlxuICogQHBhcmFtIGhpZ2hsaWdodFxuICovXG5mdW5jdGlvbiB1c2VIaWdobGlnaHQoaGlnaGxpZ2h0PzogYm9vbGVhbikge1xuICBjb25zdCBba2VlcEhpZ2hsaWdodCwgc2V0S2VlcEhpZ2hsaWdodF0gPSB1c2VTdGF0ZSh0cnVlKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgdDogYW55O1xuICAgIGlmIChoaWdobGlnaHQpIHtcbiAgICAgIHQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgc2V0S2VlcEhpZ2hsaWdodChmYWxzZSk7XG4gICAgICB9LCAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0S2VlcEhpZ2hsaWdodCh0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KHQpO1xuICB9LCBbaGlnaGxpZ2h0XSk7XG5cbiAgcmV0dXJuIGtlZXBIaWdobGlnaHQgJiYgaGlnaGxpZ2h0O1xufVxuXG5mdW5jdGlvbiByZW5kZXJBZGRSZXN0UGFyYW1CdXR0b24oXG4gIHBhcmFtRGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbURlZixcbiAgb25BZGRSZXN0UGFyYW06ICgpID0+IHZvaWQsXG4gIG9wZXJhdGlvbkluZGV4OiBudW1iZXIsXG4gIHBhcmFtSW5kZXg6IG51bWJlcixcbiAgc3R5bGVzOiBPcGVyYXRpb25FZGl0b3JTdHlsZXNcbikge1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMucmVzdFBhcmFtfSBrZXk9e2Ake3BhcmFtSW5kZXh9LTJgfT5cbiAgICAgIDxCdXR0b25cbiAgICAgICAgc2l6ZT1cInNtXCJcbiAgICAgICAgaWNvbj1cInBsdXNcIlxuICAgICAgICB0aXRsZT17YEFkZCAke3BhcmFtRGVmLm5hbWV9YH1cbiAgICAgICAgdmFyaWFudD1cInNlY29uZGFyeVwiXG4gICAgICAgIG9uQ2xpY2s9e29uQWRkUmVzdFBhcmFtfVxuICAgICAgICBkYXRhLXRlc3RpZD17YG9wZXJhdGlvbnMuJHtvcGVyYXRpb25JbmRleH0uYWRkLXJlc3QtcGFyYW1gfVxuICAgICAgPlxuICAgICAgICB7cGFyYW1EZWYubmFtZX1cbiAgICAgIDwvQnV0dG9uPlxuICAgIDwvZGl2PlxuICApO1xufVxuXG5mdW5jdGlvbiBjYWxsUGFyYW1DaGFuZ2VkVGhlbk9uQ2hhbmdlKFxuICBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZixcbiAgb3BlcmF0aW9uOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sXG4gIG9wZXJhdGlvbkluZGV4OiBudW1iZXIsXG4gIHBhcmFtSW5kZXg6IG51bWJlcixcbiAgb25DaGFuZ2U6IChpbmRleDogbnVtYmVyLCB1cGRhdGU6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbikgPT4gdm9pZFxuKSB7XG4gIGlmIChkZWYucGFyYW1DaGFuZ2VkSGFuZGxlcikge1xuICAgIG9uQ2hhbmdlKG9wZXJhdGlvbkluZGV4LCBkZWYucGFyYW1DaGFuZ2VkSGFuZGxlcihwYXJhbUluZGV4LCBvcGVyYXRpb24sIGRlZikpO1xuICB9IGVsc2Uge1xuICAgIG9uQ2hhbmdlKG9wZXJhdGlvbkluZGV4LCBvcGVyYXRpb24pO1xuICB9XG59XG5cbmNvbnN0IGdldFN0eWxlcyA9ICh0aGVtZTogR3JhZmFuYVRoZW1lMikgPT4ge1xuICByZXR1cm4ge1xuICAgIGNhcmQ6IGNzcyh7XG4gICAgICBiYWNrZ3JvdW5kOiB0aGVtZS5jb2xvcnMuYmFja2dyb3VuZC5wcmltYXJ5LFxuICAgICAgYm9yZGVyOiBgMXB4IHNvbGlkICR7dGhlbWUuY29sb3JzLmJvcmRlci5tZWRpdW19YCxcbiAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nLFxuICAgICAgY3Vyc29yOiAnZ3JhYicsXG4gICAgICBib3JkZXJSYWRpdXM6IHRoZW1lLnNoYXBlLmJvcmRlclJhZGl1cygxKSxcbiAgICAgIG1hcmdpbkJvdHRvbTogdGhlbWUuc3BhY2luZygxKSxcbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgdHJhbnNpdGlvbjogJ2FsbCAxcyBlYXNlLWluIDBzJyxcbiAgICB9KSxcbiAgICBjYXJkSGlnaGxpZ2h0OiBjc3Moe1xuICAgICAgYm94U2hhZG93OiBgMHB4IDBweCA0cHggMHB4ICR7dGhlbWUuY29sb3JzLnByaW1hcnkuYm9yZGVyfWAsXG4gICAgICBib3JkZXI6IGAxcHggc29saWQgJHt0aGVtZS5jb2xvcnMucHJpbWFyeS5ib3JkZXJ9YCxcbiAgICB9KSxcbiAgICBpbmZvSWNvbjogY3NzKHtcbiAgICAgIG1hcmdpbkxlZnQ6IHRoZW1lLnNwYWNpbmcoMC41KSxcbiAgICAgIGNvbG9yOiB0aGVtZS5jb2xvcnMudGV4dC5zZWNvbmRhcnksXG4gICAgICAnOmhvdmVyJzoge1xuICAgICAgICBjb2xvcjogdGhlbWUuY29sb3JzLnRleHQucHJpbWFyeSxcbiAgICAgIH0sXG4gICAgfSksXG4gICAgYm9keTogY3NzKHtcbiAgICAgIG1hcmdpbjogdGhlbWUuc3BhY2luZygxLCAxLCAwLjUsIDEpLFxuICAgICAgZGlzcGxheTogJ3RhYmxlJyxcbiAgICB9KSxcbiAgICBwYXJhbVJvdzogY3NzKHtcbiAgICAgIGxhYmVsOiAncGFyYW1Sb3cnLFxuICAgICAgZGlzcGxheTogJ3RhYmxlLXJvdycsXG4gICAgICB2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJyxcbiAgICB9KSxcbiAgICBwYXJhbU5hbWU6IGNzcyh7XG4gICAgICBkaXNwbGF5OiAndGFibGUtY2VsbCcsXG4gICAgICBwYWRkaW5nOiB0aGVtZS5zcGFjaW5nKDAsIDEsIDAsIDApLFxuICAgICAgZm9udFNpemU6IHRoZW1lLnR5cG9ncmFwaHkuYm9keVNtYWxsLmZvbnRTaXplLFxuICAgICAgZm9udFdlaWdodDogdGhlbWUudHlwb2dyYXBoeS5mb250V2VpZ2h0TWVkaXVtLFxuICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZScsXG4gICAgICBoZWlnaHQ6ICczMnB4JyxcbiAgICB9KSxcbiAgICBwYXJhbVZhbHVlOiBjc3Moe1xuICAgICAgbGFiZWw6ICdwYXJhbVZhbHVlJyxcbiAgICAgIGRpc3BsYXk6ICd0YWJsZS1jZWxsJyxcbiAgICAgIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICAgIH0pLFxuICAgIHJlc3RQYXJhbTogY3NzKHtcbiAgICAgIHBhZGRpbmc6IHRoZW1lLnNwYWNpbmcoMCwgMSwgMSwgMSksXG4gICAgfSksXG4gICAgYXJyb3c6IGNzcyh7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIHRvcDogJzAnLFxuICAgICAgcmlnaHQ6ICctMThweCcsXG4gICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgfSksXG4gICAgYXJyb3dMaW5lOiBjc3Moe1xuICAgICAgaGVpZ2h0OiAnMnB4JyxcbiAgICAgIHdpZHRoOiAnOHB4JyxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogdGhlbWUuY29sb3JzLmJvcmRlci5zdHJvbmcsXG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgIHRvcDogJzE0cHgnLFxuICAgIH0pLFxuICAgIGFycm93QXJyb3c6IGNzcyh7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMCxcbiAgICAgIGJvcmRlclRvcDogYDVweCBzb2xpZCB0cmFuc3BhcmVudGAsXG4gICAgICBib3JkZXJCb3R0b206IGA1cHggc29saWQgdHJhbnNwYXJlbnRgLFxuICAgICAgYm9yZGVyTGVmdDogYDdweCBzb2xpZCAke3RoZW1lLmNvbG9ycy5ib3JkZXIuc3Ryb25nfWAsXG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgIHRvcDogJzEwcHgnLFxuICAgIH0pLFxuICB9O1xufTtcblxudHlwZSBPcGVyYXRpb25FZGl0b3JTdHlsZXMgPSBSZXR1cm5UeXBlPHR5cGVvZiBnZXRTdHlsZXM+O1xuIiwiaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IEdyYWZhbmFUaGVtZTIsIHJlbmRlck1hcmtkb3duIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyB1c2VTdHlsZXMyIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgdGl0bGU6IHN0cmluZztcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIG1hcmtkb3duPzogc3RyaW5nO1xuICBzdGVwTnVtYmVyOiBudW1iZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBPcGVyYXRpb25FeHBsYWluZWRCb3goeyB0aXRsZSwgc3RlcE51bWJlciwgbWFya2Rvd24sIGNoaWxkcmVuIH06IFByb3BzKSB7XG4gIGNvbnN0IHN0eWxlcyA9IHVzZVN0eWxlczIoZ2V0U3R5bGVzKTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuYm94fT5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuc3RlcE51bWJlcn0+e3N0ZXBOdW1iZXJ9PC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmJveElubmVyfT5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5oZWFkZXJ9PlxuICAgICAgICAgIDxzcGFuPnt0aXRsZX08L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmJvZHl9PlxuICAgICAgICAgIHttYXJrZG93biAmJiA8ZGl2IGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXt7IF9faHRtbDogcmVuZGVyTWFya2Rvd24obWFya2Rvd24pIH19PjwvZGl2Pn1cbiAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59XG5cbmNvbnN0IGdldFN0eWxlcyA9ICh0aGVtZTogR3JhZmFuYVRoZW1lMikgPT4ge1xuICByZXR1cm4ge1xuICAgIGJveDogY3NzKHtcbiAgICAgIGJhY2tncm91bmQ6IHRoZW1lLmNvbG9ycy5iYWNrZ3JvdW5kLnNlY29uZGFyeSxcbiAgICAgIHBhZGRpbmc6IHRoZW1lLnNwYWNpbmcoMSksXG4gICAgICBib3JkZXJSYWRpdXM6IHRoZW1lLnNoYXBlLmJvcmRlclJhZGl1cygpLFxuICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICBtYXJnaW5Cb3R0b206IHRoZW1lLnNwYWNpbmcoMC41KSxcbiAgICB9KSxcbiAgICBib3hJbm5lcjogY3NzKHtcbiAgICAgIG1hcmdpbkxlZnQ6IHRoZW1lLnNwYWNpbmcoNCksXG4gICAgfSksXG4gICAgc3RlcE51bWJlcjogY3NzKHtcbiAgICAgIGZvbnRXZWlnaHQ6IHRoZW1lLnR5cG9ncmFwaHkuZm9udFdlaWdodE1lZGl1bSxcbiAgICAgIGJhY2tncm91bmQ6IHRoZW1lLmNvbG9ycy5zZWNvbmRhcnkubWFpbixcbiAgICAgIHdpZHRoOiAnMjBweCcsXG4gICAgICBoZWlnaHQ6ICcyMHB4JyxcbiAgICAgIGJvcmRlclJhZGl1czogJzUwJScsXG4gICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJyxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgdG9wOiAnMTBweCcsXG4gICAgICBsZWZ0OiAnMTFweCcsXG4gICAgICBmb250U2l6ZTogdGhlbWUudHlwb2dyYXBoeS5ib2R5U21hbGwuZm9udFNpemUsXG4gICAgfSksXG4gICAgaGVhZGVyOiBjc3Moe1xuICAgICAgcGFkZGluZ0JvdHRvbTogdGhlbWUuc3BhY2luZygwLjUpLFxuICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICBmb250RmFtaWx5OiB0aGVtZS50eXBvZ3JhcGh5LmZvbnRGYW1pbHlNb25vc3BhY2UsXG4gICAgfSksXG4gICAgYm9keTogY3NzKHtcbiAgICAgIGNvbG9yOiB0aGVtZS5jb2xvcnMudGV4dC5zZWNvbmRhcnksXG4gICAgICAncDpsYXN0LWNoaWxkJzoge1xuICAgICAgICBtYXJnaW46IDAsXG4gICAgICB9LFxuICAgICAgYToge1xuICAgICAgICBjb2xvcjogdGhlbWUuY29sb3JzLnRleHQubGluayxcbiAgICAgICAgdGV4dERlY29yYXRpb246ICd1bmRlcmxpbmUnLFxuICAgICAgfSxcbiAgICB9KSxcbiAgfTtcbn07XG4iLCJpbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBHcmFmYW5hVGhlbWUyLCBTZWxlY3RhYmxlVmFsdWUgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IEZsZXhJdGVtIH0gZnJvbSAnQGdyYWZhbmEvZXhwZXJpbWVudGFsJztcbmltcG9ydCB7IEJ1dHRvbiwgU2VsZWN0LCB1c2VTdHlsZXMyIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5pbXBvcnQgeyBPcGVyYXRpb25JbmZvQnV0dG9uIH0gZnJvbSAnLi9PcGVyYXRpb25JbmZvQnV0dG9uJztcbmltcG9ydCB7IFZpc3VhbFF1ZXJ5TW9kZWxsZXIsIFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiwgUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICBvcGVyYXRpb246IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbjtcbiAgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWY7XG4gIGluZGV4OiBudW1iZXI7XG4gIHF1ZXJ5TW9kZWxsZXI6IFZpc3VhbFF1ZXJ5TW9kZWxsZXI7XG4gIGRyYWdIYW5kbGVQcm9wczogYW55O1xuICBvbkNoYW5nZTogKGluZGV4OiBudW1iZXIsIHVwZGF0ZTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uKSA9PiB2b2lkO1xuICBvblJlbW92ZTogKGluZGV4OiBudW1iZXIpID0+IHZvaWQ7XG59XG5cbmludGVyZmFjZSBTdGF0ZSB7XG4gIGlzT3Blbj86IGJvb2xlYW47XG4gIGFsdGVybmF0aXZlcz86IEFycmF5PFNlbGVjdGFibGVWYWx1ZTxRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWY+Pjtcbn1cblxuZXhwb3J0IGNvbnN0IE9wZXJhdGlvbkhlYWRlciA9IFJlYWN0Lm1lbW88UHJvcHM+KFxuICAoeyBvcGVyYXRpb24sIGRlZiwgaW5kZXgsIG9uQ2hhbmdlLCBvblJlbW92ZSwgcXVlcnlNb2RlbGxlciwgZHJhZ0hhbmRsZVByb3BzIH0pID0+IHtcbiAgICBjb25zdCBzdHlsZXMgPSB1c2VTdHlsZXMyKGdldFN0eWxlcyk7XG4gICAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSB1c2VTdGF0ZTxTdGF0ZT4oe30pO1xuXG4gICAgY29uc3Qgb25Ub2dnbGVTd2l0Y2hlciA9ICgpID0+IHtcbiAgICAgIGlmIChzdGF0ZS5pc09wZW4pIHtcbiAgICAgICAgc2V0U3RhdGUoeyAuLi5zdGF0ZSwgaXNPcGVuOiBmYWxzZSB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGFsdGVybmF0aXZlcyA9IHF1ZXJ5TW9kZWxsZXJcbiAgICAgICAgICAuZ2V0QWx0ZXJuYXRpdmVPcGVyYXRpb25zKGRlZi5hbHRlcm5hdGl2ZXNLZXkhKVxuICAgICAgICAgIC5tYXAoKGFsdCkgPT4gKHsgbGFiZWw6IGFsdC5uYW1lLCB2YWx1ZTogYWx0IH0pKTtcbiAgICAgICAgc2V0U3RhdGUoeyBpc09wZW46IHRydWUsIGFsdGVybmF0aXZlcyB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuaGVhZGVyfT5cbiAgICAgICAgeyFzdGF0ZS5pc09wZW4gJiYgKFxuICAgICAgICAgIDw+XG4gICAgICAgICAgICA8ZGl2IHsuLi5kcmFnSGFuZGxlUHJvcHN9PntkZWYubmFtZSA/PyBkZWYuaWR9PC9kaXY+XG4gICAgICAgICAgICA8RmxleEl0ZW0gZ3Jvdz17MX0gLz5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtzdHlsZXMub3BlcmF0aW9uSGVhZGVyQnV0dG9uc30gb3BlcmF0aW9uLWhlYWRlci1zaG93LW9uLWhvdmVyYH0+XG4gICAgICAgICAgICAgIDxCdXR0b25cbiAgICAgICAgICAgICAgICBpY29uPVwiYW5nbGUtZG93blwiXG4gICAgICAgICAgICAgICAgc2l6ZT1cInNtXCJcbiAgICAgICAgICAgICAgICBvbkNsaWNrPXtvblRvZ2dsZVN3aXRjaGVyfVxuICAgICAgICAgICAgICAgIGZpbGw9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICB2YXJpYW50PVwic2Vjb25kYXJ5XCJcbiAgICAgICAgICAgICAgICB0aXRsZT1cIkNsaWNrIHRvIHZpZXcgYWx0ZXJuYXRpdmUgb3BlcmF0aW9uc1wiXG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIDxPcGVyYXRpb25JbmZvQnV0dG9uIGRlZj17ZGVmfSBvcGVyYXRpb249e29wZXJhdGlvbn0gLz5cbiAgICAgICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgICAgIGljb249XCJ0aW1lc1wiXG4gICAgICAgICAgICAgICAgc2l6ZT1cInNtXCJcbiAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBvblJlbW92ZShpbmRleCl9XG4gICAgICAgICAgICAgICAgZmlsbD1cInRleHRcIlxuICAgICAgICAgICAgICAgIHZhcmlhbnQ9XCJzZWNvbmRhcnlcIlxuICAgICAgICAgICAgICAgIHRpdGxlPVwiUmVtb3ZlIG9wZXJhdGlvblwiXG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8Lz5cbiAgICAgICAgKX1cbiAgICAgICAge3N0YXRlLmlzT3BlbiAmJiAoXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5zZWxlY3RXcmFwcGVyfT5cbiAgICAgICAgICAgIDxTZWxlY3RcbiAgICAgICAgICAgICAgYXV0b0ZvY3VzXG4gICAgICAgICAgICAgIG9wZW5NZW51T25Gb2N1c1xuICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIlJlcGxhY2Ugd2l0aFwiXG4gICAgICAgICAgICAgIG9wdGlvbnM9e3N0YXRlLmFsdGVybmF0aXZlc31cbiAgICAgICAgICAgICAgaXNPcGVuPXt0cnVlfVxuICAgICAgICAgICAgICBvbkNsb3NlTWVudT17b25Ub2dnbGVTd2l0Y2hlcn1cbiAgICAgICAgICAgICAgb25DaGFuZ2U9eyh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgLy8gT3BlcmF0aW9uIHNob3VsZCBleGlzdCBpZiBpdCBpcyBzZWxlY3RhYmxlXG4gICAgICAgICAgICAgICAgICBjb25zdCBuZXdEZWYgPSBxdWVyeU1vZGVsbGVyLmdldE9wZXJhdGlvbkRlZih2YWx1ZS52YWx1ZS5pZCkhO1xuICAgICAgICAgICAgICAgICAgbGV0IGNoYW5nZWRPcCA9IHsgLi4ub3BlcmF0aW9uLCBpZDogdmFsdWUudmFsdWUuaWQgfTtcbiAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlKGluZGV4LCBkZWYuY2hhbmdlVHlwZUhhbmRsZXIgPyBkZWYuY2hhbmdlVHlwZUhhbmRsZXIoY2hhbmdlZE9wLCBuZXdEZWYpIDogY2hhbmdlZE9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApfVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuKTtcblxuT3BlcmF0aW9uSGVhZGVyLmRpc3BsYXlOYW1lID0gJ09wZXJhdGlvbkhlYWRlcic7XG5cbmNvbnN0IGdldFN0eWxlcyA9ICh0aGVtZTogR3JhZmFuYVRoZW1lMikgPT4ge1xuICByZXR1cm4ge1xuICAgIGhlYWRlcjogY3NzKHtcbiAgICAgIGJvcmRlckJvdHRvbTogYDFweCBzb2xpZCAke3RoZW1lLmNvbG9ycy5ib3JkZXIubWVkaXVtfWAsXG4gICAgICBwYWRkaW5nOiB0aGVtZS5zcGFjaW5nKDAuNSwgMC41LCAwLjUsIDEpLFxuICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAnJjpob3ZlciAub3BlcmF0aW9uLWhlYWRlci1zaG93LW9uLWhvdmVyJzogY3NzKHtcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgIH0pLFxuICAgIH0pLFxuICAgIG9wZXJhdGlvbkhlYWRlckJ1dHRvbnM6IGNzcyh7XG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgdHJhbnNpdGlvbjogdGhlbWUudHJhbnNpdGlvbnMuY3JlYXRlKFsnb3BhY2l0eSddLCB7XG4gICAgICAgIGR1cmF0aW9uOiB0aGVtZS50cmFuc2l0aW9ucy5kdXJhdGlvbi5zaG9ydCxcbiAgICAgIH0pLFxuICAgIH0pLFxuICAgIHNlbGVjdFdyYXBwZXI6IGNzcyh7XG4gICAgICBwYWRkaW5nUmlnaHQ6IHRoZW1lLnNwYWNpbmcoMiksXG4gICAgfSksXG4gIH07XG59O1xuIiwiaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVBvcHBlclRvb2x0aXAgfSBmcm9tICdyZWFjdC1wb3BwZXItdG9vbHRpcCc7XG5cbmltcG9ydCB7IEdyYWZhbmFUaGVtZTIsIHJlbmRlck1hcmtkb3duIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBGbGV4SXRlbSB9IGZyb20gJ0BncmFmYW5hL2V4cGVyaW1lbnRhbCc7XG5pbXBvcnQgeyBCdXR0b24sIFBvcnRhbCwgdXNlU3R5bGVzMiB9IGZyb20gJ0BncmFmYW5hL3VpJztcblxuaW1wb3J0IHsgUXVlcnlCdWlsZGVyT3BlcmF0aW9uLCBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gIG9wZXJhdGlvbjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uO1xuICBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZjtcbn1cblxuZXhwb3J0IGNvbnN0IE9wZXJhdGlvbkluZm9CdXR0b24gPSBSZWFjdC5tZW1vPFByb3BzPigoeyBkZWYsIG9wZXJhdGlvbiB9KSA9PiB7XG4gIGNvbnN0IHN0eWxlcyA9IHVzZVN0eWxlczIoZ2V0U3R5bGVzKTtcbiAgY29uc3QgW3Nob3csIHNldFNob3ddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCB7IGdldFRvb2x0aXBQcm9wcywgc2V0VG9vbHRpcFJlZiwgc2V0VHJpZ2dlclJlZiwgdmlzaWJsZSB9ID0gdXNlUG9wcGVyVG9vbHRpcCh7XG4gICAgcGxhY2VtZW50OiAndG9wJyxcbiAgICB2aXNpYmxlOiBzaG93LFxuICAgIG9mZnNldDogWzAsIDE2XSxcbiAgICBvblZpc2libGVDaGFuZ2U6IHNldFNob3csXG4gICAgaW50ZXJhY3RpdmU6IHRydWUsXG4gICAgdHJpZ2dlcjogWydjbGljayddLFxuICB9KTtcblxuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8QnV0dG9uXG4gICAgICAgIHRpdGxlPVwiQ2xpY2sgdG8gc2hvdyBkZXNjcmlwdGlvblwiXG4gICAgICAgIHJlZj17c2V0VHJpZ2dlclJlZn1cbiAgICAgICAgaWNvbj1cImluZm8tY2lyY2xlXCJcbiAgICAgICAgc2l6ZT1cInNtXCJcbiAgICAgICAgdmFyaWFudD1cInNlY29uZGFyeVwiXG4gICAgICAgIGZpbGw9XCJ0ZXh0XCJcbiAgICAgIC8+XG4gICAgICB7dmlzaWJsZSAmJiAoXG4gICAgICAgIDxQb3J0YWw+XG4gICAgICAgICAgPGRpdiByZWY9e3NldFRvb2x0aXBSZWZ9IHsuLi5nZXRUb29sdGlwUHJvcHMoKX0gY2xhc3NOYW1lPXtzdHlsZXMuZG9jQm94fT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuZG9jQm94SGVhZGVyfT5cbiAgICAgICAgICAgICAgPHNwYW4+e2RlZi5yZW5kZXJlcihvcGVyYXRpb24sIGRlZiwgJzxleHByPicpfTwvc3Bhbj5cbiAgICAgICAgICAgICAgPEZsZXhJdGVtIGdyb3c9ezF9IC8+XG4gICAgICAgICAgICAgIDxCdXR0b25cbiAgICAgICAgICAgICAgICBpY29uPVwidGltZXNcIlxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldFNob3coZmFsc2UpfVxuICAgICAgICAgICAgICAgIGZpbGw9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICB2YXJpYW50PVwic2Vjb25kYXJ5XCJcbiAgICAgICAgICAgICAgICB0aXRsZT1cIlJlbW92ZSBvcGVyYXRpb25cIlxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLmRvY0JveEJvZHl9XG4gICAgICAgICAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXt7IF9faHRtbDogZ2V0T3BlcmF0aW9uRG9jcyhkZWYsIG9wZXJhdGlvbikgfX1cbiAgICAgICAgICAgID48L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9Qb3J0YWw+XG4gICAgICApfVxuICAgIDwvPlxuICApO1xufSk7XG5cbk9wZXJhdGlvbkluZm9CdXR0b24uZGlzcGxheU5hbWUgPSAnT3BlcmF0aW9uRG9jcyc7XG5cbmNvbnN0IGdldFN0eWxlcyA9ICh0aGVtZTogR3JhZmFuYVRoZW1lMikgPT4ge1xuICByZXR1cm4ge1xuICAgIGRvY0JveDogY3NzKHtcbiAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgIGJhY2tncm91bmQ6IHRoZW1lLmNvbG9ycy5iYWNrZ3JvdW5kLnByaW1hcnksXG4gICAgICBib3JkZXI6IGAxcHggc29saWQgJHt0aGVtZS5jb2xvcnMuYm9yZGVyLnN0cm9uZ31gLFxuICAgICAgYm94U2hhZG93OiB0aGVtZS5zaGFkb3dzLnozLFxuICAgICAgbWF4V2lkdGg6ICc2MDBweCcsXG4gICAgICBwYWRkaW5nOiB0aGVtZS5zcGFjaW5nKDEpLFxuICAgICAgYm9yZGVyUmFkaXVzOiB0aGVtZS5zaGFwZS5ib3JkZXJSYWRpdXMoKSxcbiAgICAgIHpJbmRleDogdGhlbWUuekluZGV4LnRvb2x0aXAsXG4gICAgfSksXG4gICAgZG9jQm94SGVhZGVyOiBjc3Moe1xuICAgICAgZm9udFNpemU6IHRoZW1lLnR5cG9ncmFwaHkuaDUuZm9udFNpemUsXG4gICAgICBmb250RmFtaWx5OiB0aGVtZS50eXBvZ3JhcGh5LmZvbnRGYW1pbHlNb25vc3BhY2UsXG4gICAgICBwYWRkaW5nQm90dG9tOiB0aGVtZS5zcGFjaW5nKDEpLFxuICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgfSksXG4gICAgZG9jQm94Qm9keTogY3NzKHtcbiAgICAgIC8vIFRoZSBtYXJrZG93biBwYXJhZ3JhcGggaGFzIGEgbWFyZ2luQm90dG9tIHRoaXMgcmVtb3ZlcyBpdFxuICAgICAgbWFyZ2luQm90dG9tOiB0aGVtZS5zcGFjaW5nKC0xKSxcbiAgICAgIGNvbG9yOiB0aGVtZS5jb2xvcnMudGV4dC5zZWNvbmRhcnksXG4gICAgfSksXG4gICAgc2lnbmF0dXJlOiBjc3Moe1xuICAgICAgZm9udFNpemU6IHRoZW1lLnR5cG9ncmFwaHkuYm9keVNtYWxsLmZvbnRTaXplLFxuICAgICAgZm9udEZhbWlseTogdGhlbWUudHlwb2dyYXBoeS5mb250RmFtaWx5TW9ub3NwYWNlLFxuICAgIH0pLFxuICAgIGRyb3Bkb3duOiBjc3Moe1xuICAgICAgb3BhY2l0eTogMCxcbiAgICAgIGNvbG9yOiB0aGVtZS5jb2xvcnMudGV4dC5zZWNvbmRhcnksXG4gICAgfSksXG4gIH07XG59O1xuZnVuY3Rpb24gZ2V0T3BlcmF0aW9uRG9jcyhkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiwgb3A6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbik6IHN0cmluZyB7XG4gIHJldHVybiByZW5kZXJNYXJrZG93bihkZWYuZXhwbGFpbkhhbmRsZXIgPyBkZWYuZXhwbGFpbkhhbmRsZXIob3AsIGRlZikgOiBkZWYuZG9jdW1lbnRhdGlvbiA/PyAnbm8gZG9jcycpO1xufVxuIiwiaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IERyYWdEcm9wQ29udGV4dCwgRHJvcHBhYmxlLCBEcm9wUmVzdWx0IH0gZnJvbSAncmVhY3QtYmVhdXRpZnVsLWRuZCc7XG5pbXBvcnQgeyB1c2VNb3VudGVkU3RhdGUsIHVzZVByZXZpb3VzIH0gZnJvbSAncmVhY3QtdXNlJztcblxuaW1wb3J0IHsgRGF0YVNvdXJjZUFwaSwgR3JhZmFuYVRoZW1lMiB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgU3RhY2sgfSBmcm9tICdAZ3JhZmFuYS9leHBlcmltZW50YWwnO1xuaW1wb3J0IHsgQnV0dG9uLCBDYXNjYWRlciwgQ2FzY2FkZXJPcHRpb24sIHVzZVN0eWxlczIgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5cbmltcG9ydCB7IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiwgUXVlcnlXaXRoT3BlcmF0aW9ucywgVmlzdWFsUXVlcnlNb2RlbGxlciB9IGZyb20gJy4uL3NoYXJlZC90eXBlcyc7XG5cbmltcG9ydCB7IE9wZXJhdGlvbkVkaXRvciB9IGZyb20gJy4vT3BlcmF0aW9uRWRpdG9yJztcblxuZXhwb3J0IGludGVyZmFjZSBQcm9wczxUIGV4dGVuZHMgUXVlcnlXaXRoT3BlcmF0aW9ucz4ge1xuICBxdWVyeTogVDtcbiAgZGF0YXNvdXJjZTogRGF0YVNvdXJjZUFwaTtcbiAgb25DaGFuZ2U6IChxdWVyeTogVCkgPT4gdm9pZDtcbiAgb25SdW5RdWVyeTogKCkgPT4gdm9pZDtcbiAgcXVlcnlNb2RlbGxlcjogVmlzdWFsUXVlcnlNb2RlbGxlcjtcbiAgZXhwbGFpbk1vZGU/OiBib29sZWFuO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gT3BlcmF0aW9uTGlzdDxUIGV4dGVuZHMgUXVlcnlXaXRoT3BlcmF0aW9ucz4oe1xuICBxdWVyeSxcbiAgZGF0YXNvdXJjZSxcbiAgcXVlcnlNb2RlbGxlcixcbiAgb25DaGFuZ2UsXG4gIG9uUnVuUXVlcnksXG59OiBQcm9wczxUPikge1xuICBjb25zdCBzdHlsZXMgPSB1c2VTdHlsZXMyKGdldFN0eWxlcyk7XG4gIGNvbnN0IHsgb3BlcmF0aW9ucyB9ID0gcXVlcnk7XG5cbiAgY29uc3Qgb3BzVG9IaWdobGlnaHQgPSB1c2VPcGVyYXRpb25zSGlnaGxpZ2h0KG9wZXJhdGlvbnMpO1xuXG4gIGNvbnN0IFtjYXNjYWRlck9wZW4sIHNldENhc2NhZGVyT3Blbl0gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgY29uc3Qgb25PcGVyYXRpb25DaGFuZ2UgPSAoaW5kZXg6IG51bWJlciwgdXBkYXRlOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24pID0+IHtcbiAgICBjb25zdCB1cGRhdGVkTGlzdCA9IFsuLi5vcGVyYXRpb25zXTtcbiAgICB1cGRhdGVkTGlzdC5zcGxpY2UoaW5kZXgsIDEsIHVwZGF0ZSk7XG4gICAgb25DaGFuZ2UoeyAuLi5xdWVyeSwgb3BlcmF0aW9uczogdXBkYXRlZExpc3QgfSk7XG4gIH07XG5cbiAgY29uc3Qgb25SZW1vdmUgPSAoaW5kZXg6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IHVwZGF0ZWRMaXN0ID0gWy4uLm9wZXJhdGlvbnMuc2xpY2UoMCwgaW5kZXgpLCAuLi5vcGVyYXRpb25zLnNsaWNlKGluZGV4ICsgMSldO1xuICAgIG9uQ2hhbmdlKHsgLi4ucXVlcnksIG9wZXJhdGlvbnM6IHVwZGF0ZWRMaXN0IH0pO1xuICB9O1xuXG4gIGNvbnN0IGFkZE9wdGlvbnM6IENhc2NhZGVyT3B0aW9uW10gPSBxdWVyeU1vZGVsbGVyLmdldENhdGVnb3JpZXMoKS5tYXAoKGNhdGVnb3J5KSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBjYXRlZ29yeSxcbiAgICAgIGxhYmVsOiBjYXRlZ29yeSxcbiAgICAgIGl0ZW1zOiBxdWVyeU1vZGVsbGVyLmdldE9wZXJhdGlvbnNGb3JDYXRlZ29yeShjYXRlZ29yeSkubWFwKChvcGVyYXRpb24pID0+ICh7XG4gICAgICAgIHZhbHVlOiBvcGVyYXRpb24uaWQsXG4gICAgICAgIGxhYmVsOiBvcGVyYXRpb24ubmFtZSxcbiAgICAgICAgaXNMZWFmOiB0cnVlLFxuICAgICAgfSkpLFxuICAgIH07XG4gIH0pO1xuXG4gIGNvbnN0IG9uQWRkT3BlcmF0aW9uID0gKHZhbHVlOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCBvcGVyYXRpb25EZWYgPSBxdWVyeU1vZGVsbGVyLmdldE9wZXJhdGlvbkRlZih2YWx1ZSk7XG4gICAgaWYgKCFvcGVyYXRpb25EZWYpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgb25DaGFuZ2Uob3BlcmF0aW9uRGVmLmFkZE9wZXJhdGlvbkhhbmRsZXIob3BlcmF0aW9uRGVmLCBxdWVyeSwgcXVlcnlNb2RlbGxlcikpO1xuICAgIHNldENhc2NhZGVyT3BlbihmYWxzZSk7XG4gIH07XG5cbiAgY29uc3Qgb25EcmFnRW5kID0gKHJlc3VsdDogRHJvcFJlc3VsdCkgPT4ge1xuICAgIGlmICghcmVzdWx0LmRlc3RpbmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgdXBkYXRlZExpc3QgPSBbLi4ub3BlcmF0aW9uc107XG4gICAgY29uc3QgZWxlbWVudCA9IHVwZGF0ZWRMaXN0W3Jlc3VsdC5zb3VyY2UuaW5kZXhdO1xuICAgIHVwZGF0ZWRMaXN0LnNwbGljZShyZXN1bHQuc291cmNlLmluZGV4LCAxKTtcbiAgICB1cGRhdGVkTGlzdC5zcGxpY2UocmVzdWx0LmRlc3RpbmF0aW9uLmluZGV4LCAwLCBlbGVtZW50KTtcbiAgICBvbkNoYW5nZSh7IC4uLnF1ZXJ5LCBvcGVyYXRpb25zOiB1cGRhdGVkTGlzdCB9KTtcbiAgfTtcblxuICBjb25zdCBvbkNhc2NhZGVyQmx1ciA9ICgpID0+IHtcbiAgICBzZXRDYXNjYWRlck9wZW4oZmFsc2UpO1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPFN0YWNrIGdhcD17MX0gZGlyZWN0aW9uPVwiY29sdW1uXCI+XG4gICAgICA8U3RhY2sgZ2FwPXsxfT5cbiAgICAgICAge29wZXJhdGlvbnMubGVuZ3RoID4gMCAmJiAoXG4gICAgICAgICAgPERyYWdEcm9wQ29udGV4dCBvbkRyYWdFbmQ9e29uRHJhZ0VuZH0+XG4gICAgICAgICAgICA8RHJvcHBhYmxlIGRyb3BwYWJsZUlkPVwic29ydGFibGUtZmllbGQtbWFwcGluZ3NcIiBkaXJlY3Rpb249XCJob3Jpem9udGFsXCI+XG4gICAgICAgICAgICAgIHsocHJvdmlkZWQpID0+IChcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLm9wZXJhdGlvbkxpc3R9IHJlZj17cHJvdmlkZWQuaW5uZXJSZWZ9IHsuLi5wcm92aWRlZC5kcm9wcGFibGVQcm9wc30+XG4gICAgICAgICAgICAgICAgICB7b3BlcmF0aW9ucy5tYXAoKG9wLCBpbmRleCkgPT4gKFxuICAgICAgICAgICAgICAgICAgICA8T3BlcmF0aW9uRWRpdG9yXG4gICAgICAgICAgICAgICAgICAgICAga2V5PXtvcC5pZCArIGluZGV4fVxuICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5TW9kZWxsZXI9e3F1ZXJ5TW9kZWxsZXJ9XG4gICAgICAgICAgICAgICAgICAgICAgaW5kZXg9e2luZGV4fVxuICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbj17b3B9XG4gICAgICAgICAgICAgICAgICAgICAgcXVlcnk9e3F1ZXJ5fVxuICAgICAgICAgICAgICAgICAgICAgIGRhdGFzb3VyY2U9e2RhdGFzb3VyY2V9XG4gICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e29uT3BlcmF0aW9uQ2hhbmdlfVxuICAgICAgICAgICAgICAgICAgICAgIG9uUmVtb3ZlPXtvblJlbW92ZX1cbiAgICAgICAgICAgICAgICAgICAgICBvblJ1blF1ZXJ5PXtvblJ1blF1ZXJ5fVxuICAgICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodD17b3BzVG9IaWdobGlnaHRbaW5kZXhdfVxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICAgICAgICB7cHJvdmlkZWQucGxhY2Vob2xkZXJ9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICl9XG4gICAgICAgICAgICA8L0Ryb3BwYWJsZT5cbiAgICAgICAgICA8L0RyYWdEcm9wQ29udGV4dD5cbiAgICAgICAgKX1cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5hZGRCdXR0b259PlxuICAgICAgICAgIHtjYXNjYWRlck9wZW4gPyAoXG4gICAgICAgICAgICA8Q2FzY2FkZXJcbiAgICAgICAgICAgICAgb3B0aW9ucz17YWRkT3B0aW9uc31cbiAgICAgICAgICAgICAgb25TZWxlY3Q9e29uQWRkT3BlcmF0aW9ufVxuICAgICAgICAgICAgICBvbkJsdXI9e29uQ2FzY2FkZXJCbHVyfVxuICAgICAgICAgICAgICBhdXRvRm9jdXM9e3RydWV9XG4gICAgICAgICAgICAgIGFsd2F5c09wZW49e3RydWV9XG4gICAgICAgICAgICAgIGhpZGVBY3RpdmVMZXZlbExhYmVsPXt0cnVlfVxuICAgICAgICAgICAgICBwbGFjZWhvbGRlcj17J1NlYXJjaCd9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICA8QnV0dG9uIGljb249eydwbHVzJ30gdmFyaWFudD17J3NlY29uZGFyeSd9IG9uQ2xpY2s9eygpID0+IHNldENhc2NhZGVyT3Blbih0cnVlKX0gdGl0bGU9eydBZGQgb3BlcmF0aW9uJ30+XG4gICAgICAgICAgICAgIE9wZXJhdGlvbnNcbiAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9TdGFjaz5cbiAgICA8L1N0YWNrPlxuICApO1xufVxuXG4vKipcbiAqIFJldHVybnMgaW5kZXhlcyBvZiBvcGVyYXRpb25zIHRoYXQgc2hvdWxkIGJlIGhpZ2hsaWdodGVkLiBXZSBjaGVjayB0aGUgZGlmZiBvZiBvcGVyYXRpb25zIGFkZGVkIGJ1dCBhdCB0aGUgc2FtZSB0aW1lXG4gKiB3ZSB3YW50IHRvIGhpZ2hsaWdodCBvcGVyYXRpb25zIG9ubHkgYWZ0ZXIgdGhlIGluaXRpYWwgcmVuZGVyLCBzbyB3ZSBjaGVjayBmb3IgbW91bnRlZCBzdGF0ZSBhbmQgY2FsY3VsYXRlIHRoZSBkaWZmXG4gKiBvbmx5IGFmdGVyLlxuICogQHBhcmFtIG9wZXJhdGlvbnNcbiAqL1xuZnVuY3Rpb24gdXNlT3BlcmF0aW9uc0hpZ2hsaWdodChvcGVyYXRpb25zOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25bXSkge1xuICBjb25zdCBpc01vdW50ZWQgPSB1c2VNb3VudGVkU3RhdGUoKTtcbiAgY29uc3QgcHJldk9wZXJhdGlvbnMgPSB1c2VQcmV2aW91cyhvcGVyYXRpb25zKTtcblxuICBpZiAoIWlzTW91bnRlZCgpKSB7XG4gICAgcmV0dXJuIG9wZXJhdGlvbnMubWFwKCgpID0+IGZhbHNlKTtcbiAgfVxuXG4gIGlmICghcHJldk9wZXJhdGlvbnMpIHtcbiAgICByZXR1cm4gb3BlcmF0aW9ucy5tYXAoKCkgPT4gdHJ1ZSk7XG4gIH1cblxuICBsZXQgbmV3T3BzOiBib29sZWFuW10gPSBbXTtcblxuICBpZiAocHJldk9wZXJhdGlvbnMubGVuZ3RoIC0gMSA9PT0gb3BlcmF0aW9ucy5sZW5ndGggJiYgb3BlcmF0aW9ucy5ldmVyeSgob3ApID0+IHByZXZPcGVyYXRpb25zLmluY2x1ZGVzKG9wKSkpIHtcbiAgICAvLyBJbiBjYXNlIHdlIHJlbW92ZSBvbmUgb3AgYW5kIGRvZXMgbm90IGNoYW5nZSBhbnkgb3BzIHRoZW4gZG9uJ3QgaGlnaGxpZ2h0IGFueXRoaW5nLlxuICAgIHJldHVybiBvcGVyYXRpb25zLm1hcCgoKSA9PiBmYWxzZSk7XG4gIH1cbiAgaWYgKHByZXZPcGVyYXRpb25zLmxlbmd0aCArIDEgPT09IG9wZXJhdGlvbnMubGVuZ3RoICYmIHByZXZPcGVyYXRpb25zLmV2ZXJ5KChvcCkgPT4gb3BlcmF0aW9ucy5pbmNsdWRlcyhvcCkpKSB7XG4gICAgLy8gSWYgd2UgYWRkIGEgc2luZ2xlIG9wIGp1c3QgZmluZCBpdCBhbmQgaGlnaGxpZ2h0IGp1c3QgdGhhdC5cbiAgICBjb25zdCBuZXdPcCA9IG9wZXJhdGlvbnMuZmluZCgob3ApID0+ICFwcmV2T3BlcmF0aW9ucy5pbmNsdWRlcyhvcCkpO1xuICAgIG5ld09wcyA9IG9wZXJhdGlvbnMubWFwKChvcCkgPT4ge1xuICAgICAgcmV0dXJuIG9wID09PSBuZXdPcDtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBEZWZhdWx0IGRpZmYgb2YgYWxsIG9wcy5cbiAgICBuZXdPcHMgPSBvcGVyYXRpb25zLm1hcCgob3AsIGluZGV4KSA9PiB7XG4gICAgICByZXR1cm4gIWlzU2FtZU9wKG9wLmlkLCBwcmV2T3BlcmF0aW9uc1tpbmRleF0/LmlkKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbmV3T3BzO1xufVxuXG5mdW5jdGlvbiBpc1NhbWVPcChvcDE/OiBzdHJpbmcsIG9wMj86IHN0cmluZykge1xuICByZXR1cm4gb3AxID09PSBvcDIgfHwgYF9fJHtvcDF9X2J5YCA9PT0gb3AyIHx8IG9wMSA9PT0gYF9fJHtvcDJ9X2J5YDtcbn1cblxuY29uc3QgZ2V0U3R5bGVzID0gKHRoZW1lOiBHcmFmYW5hVGhlbWUyKSA9PiB7XG4gIHJldHVybiB7XG4gICAgaGVhZGluZzogY3NzKHtcbiAgICAgIGxhYmVsOiAnaGVhZGluZycsXG4gICAgICBmb250U2l6ZTogMTIsXG4gICAgICBmb250V2VpZ2h0OiB0aGVtZS50eXBvZ3JhcGh5LmZvbnRXZWlnaHRNZWRpdW0sXG4gICAgICBtYXJnaW5Cb3R0b206IDAsXG4gICAgfSksXG4gICAgb3BlcmF0aW9uTGlzdDogY3NzKHtcbiAgICAgIGxhYmVsOiAnb3BlcmF0aW9uTGlzdCcsXG4gICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICBmbGV4V3JhcDogJ3dyYXAnLFxuICAgICAgZ2FwOiB0aGVtZS5zcGFjaW5nKDIpLFxuICAgIH0pLFxuICAgIGFkZEJ1dHRvbjogY3NzKHtcbiAgICAgIGxhYmVsOiAnYWRkQnV0dG9uJyxcbiAgICAgIHdpZHRoOiAxMjYsXG4gICAgICBwYWRkaW5nQm90dG9tOiB0aGVtZS5zcGFjaW5nKDEpLFxuICAgIH0pLFxuICB9O1xufTtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IE9wZXJhdGlvbkV4cGxhaW5lZEJveCB9IGZyb20gJy4vT3BlcmF0aW9uRXhwbGFpbmVkQm94JztcbmltcG9ydCB7IFF1ZXJ5V2l0aE9wZXJhdGlvbnMsIFZpc3VhbFF1ZXJ5TW9kZWxsZXIgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBQcm9wczxUIGV4dGVuZHMgUXVlcnlXaXRoT3BlcmF0aW9ucz4ge1xuICBxdWVyeTogVDtcbiAgcXVlcnlNb2RlbGxlcjogVmlzdWFsUXVlcnlNb2RlbGxlcjtcbiAgZXhwbGFpbk1vZGU/OiBib29sZWFuO1xuICBzdGVwTnVtYmVyOiBudW1iZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBPcGVyYXRpb25MaXN0RXhwbGFpbmVkPFQgZXh0ZW5kcyBRdWVyeVdpdGhPcGVyYXRpb25zPih7IHF1ZXJ5LCBxdWVyeU1vZGVsbGVyLCBzdGVwTnVtYmVyIH06IFByb3BzPFQ+KSB7XG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIHtxdWVyeS5vcGVyYXRpb25zLm1hcCgob3AsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGRlZiA9IHF1ZXJ5TW9kZWxsZXIuZ2V0T3BlcmF0aW9uRGVmKG9wLmlkKTtcbiAgICAgICAgaWYgKCFkZWYpIHtcbiAgICAgICAgICByZXR1cm4gYE9wZXJhdGlvbiAke29wLmlkfSBub3QgZm91bmRgO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpdGxlID0gZGVmLnJlbmRlcmVyKG9wLCBkZWYsICc8ZXhwcj4nKTtcbiAgICAgICAgY29uc3QgYm9keSA9IGRlZi5leHBsYWluSGFuZGxlciA/IGRlZi5leHBsYWluSGFuZGxlcihvcCwgZGVmKSA6IGRlZi5kb2N1bWVudGF0aW9uID8/ICdubyBkb2NzJztcblxuICAgICAgICByZXR1cm4gPE9wZXJhdGlvbkV4cGxhaW5lZEJveCBzdGVwTnVtYmVyPXtpbmRleCArIHN0ZXBOdW1iZXJ9IGtleT17aW5kZXh9IHRpdGxlPXt0aXRsZX0gbWFya2Rvd249e2JvZHl9IC8+O1xuICAgICAgfSl9XG4gICAgPC8+XG4gICk7XG59XG4iLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50VHlwZSB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgU2VsZWN0YWJsZVZhbHVlLCB0b09wdGlvbiB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgQ2hlY2tib3gsIFNlbGVjdCB9IGZyb20gJ0BncmFmYW5hL3VpJztcblxuaW1wb3J0IHsgUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1EZWYsIFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRWRpdG9yUHJvcHMgfSBmcm9tICcuLi9zaGFyZWQvdHlwZXMnO1xuXG5pbXBvcnQgeyBBdXRvU2l6ZUlucHV0IH0gZnJvbSAnLi9BdXRvU2l6ZUlucHV0JztcbmltcG9ydCB7IGdldE9wZXJhdGlvblBhcmFtSWQgfSBmcm9tICcuL29wZXJhdGlvblV0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldE9wZXJhdGlvblBhcmFtRWRpdG9yKFxuICBwYXJhbURlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1EZWZcbik6IENvbXBvbmVudFR5cGU8UXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1FZGl0b3JQcm9wcz4ge1xuICBpZiAocGFyYW1EZWYuZWRpdG9yKSB7XG4gICAgcmV0dXJuIHBhcmFtRGVmLmVkaXRvcjtcbiAgfVxuXG4gIGlmIChwYXJhbURlZi5vcHRpb25zKSB7XG4gICAgcmV0dXJuIFNlbGVjdElucHV0UGFyYW1FZGl0b3I7XG4gIH1cblxuICBzd2l0Y2ggKHBhcmFtRGVmLnR5cGUpIHtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiBCb29sSW5wdXRQYXJhbUVkaXRvcjtcbiAgICBjYXNlICdudW1iZXInOlxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBTaW1wbGVJbnB1dFBhcmFtRWRpdG9yO1xuICB9XG59XG5cbmZ1bmN0aW9uIFNpbXBsZUlucHV0UGFyYW1FZGl0b3IocHJvcHM6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRWRpdG9yUHJvcHMpIHtcbiAgcmV0dXJuIChcbiAgICA8QXV0b1NpemVJbnB1dFxuICAgICAgaWQ9e2dldE9wZXJhdGlvblBhcmFtSWQocHJvcHMub3BlcmF0aW9uSW5kZXgsIHByb3BzLmluZGV4KX1cbiAgICAgIGRlZmF1bHRWYWx1ZT17cHJvcHMudmFsdWU/LnRvU3RyaW5nKCl9XG4gICAgICBtaW5XaWR0aD17cHJvcHMucGFyYW1EZWYubWluV2lkdGh9XG4gICAgICBwbGFjZWhvbGRlcj17cHJvcHMucGFyYW1EZWYucGxhY2Vob2xkZXJ9XG4gICAgICB0aXRsZT17cHJvcHMucGFyYW1EZWYuZGVzY3JpcHRpb259XG4gICAgICBvbkNvbW1pdENoYW5nZT17KGV2dCkgPT4ge1xuICAgICAgICBwcm9wcy5vbkNoYW5nZShwcm9wcy5pbmRleCwgZXZ0LmN1cnJlbnRUYXJnZXQudmFsdWUpO1xuICAgICAgfX1cbiAgICAvPlxuICApO1xufVxuXG5mdW5jdGlvbiBCb29sSW5wdXRQYXJhbUVkaXRvcihwcm9wczogUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1FZGl0b3JQcm9wcykge1xuICByZXR1cm4gKFxuICAgIDxDaGVja2JveFxuICAgICAgaWQ9e2dldE9wZXJhdGlvblBhcmFtSWQocHJvcHMub3BlcmF0aW9uSW5kZXgsIHByb3BzLmluZGV4KX1cbiAgICAgIHZhbHVlPXtwcm9wcy52YWx1ZSBhcyBib29sZWFufVxuICAgICAgb25DaGFuZ2U9eyhldnQpID0+IHByb3BzLm9uQ2hhbmdlKHByb3BzLmluZGV4LCBldnQuY3VycmVudFRhcmdldC5jaGVja2VkKX1cbiAgICAvPlxuICApO1xufVxuXG5mdW5jdGlvbiBTZWxlY3RJbnB1dFBhcmFtRWRpdG9yKHtcbiAgcGFyYW1EZWYsXG4gIHZhbHVlLFxuICBpbmRleCxcbiAgb3BlcmF0aW9uSW5kZXgsXG4gIG9uQ2hhbmdlLFxufTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1FZGl0b3JQcm9wcykge1xuICBsZXQgc2VsZWN0T3B0aW9ucyA9IHBhcmFtRGVmLm9wdGlvbnMgYXMgQXJyYXk8U2VsZWN0YWJsZVZhbHVlPGFueT4+O1xuXG4gIGlmICghc2VsZWN0T3B0aW9uc1swXT8ubGFiZWwpIHtcbiAgICBzZWxlY3RPcHRpb25zID0gcGFyYW1EZWYub3B0aW9ucyEubWFwKChvcHRpb24pID0+ICh7XG4gICAgICBsYWJlbDogb3B0aW9uLnRvU3RyaW5nKCksXG4gICAgICB2YWx1ZTogb3B0aW9uIGFzIHN0cmluZyxcbiAgICB9KSk7XG4gIH1cblxuICBsZXQgdmFsdWVPcHRpb24gPSBzZWxlY3RPcHRpb25zLmZpbmQoKHgpID0+IHgudmFsdWUgPT09IHZhbHVlKSA/PyB0b09wdGlvbih2YWx1ZSBhcyBzdHJpbmcpO1xuXG4gIHJldHVybiAoXG4gICAgPFNlbGVjdFxuICAgICAgaWQ9e2dldE9wZXJhdGlvblBhcmFtSWQob3BlcmF0aW9uSW5kZXgsIGluZGV4KX1cbiAgICAgIHZhbHVlPXt2YWx1ZU9wdGlvbn1cbiAgICAgIG9wdGlvbnM9e3NlbGVjdE9wdGlvbnN9XG4gICAgICBwbGFjZWhvbGRlcj17cGFyYW1EZWYucGxhY2Vob2xkZXJ9XG4gICAgICBhbGxvd0N1c3RvbVZhbHVlPXt0cnVlfVxuICAgICAgb25DaGFuZ2U9eyh2YWx1ZSkgPT4gb25DaGFuZ2UoaW5kZXgsIHZhbHVlLnZhbHVlISl9XG4gICAgLz5cbiAgKTtcbn1cbiIsImltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBHcmFmYW5hVGhlbWUyIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBTdGFjayB9IGZyb20gJ0BncmFmYW5hL2V4cGVyaW1lbnRhbCc7XG5pbXBvcnQgeyB1c2VTdHlsZXMyIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5pbnRlcmZhY2UgUHJvcHMge1xuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gT3BlcmF0aW9uc0VkaXRvclJvdyh7IGNoaWxkcmVuIH06IFByb3BzKSB7XG4gIGNvbnN0IHN0eWxlcyA9IHVzZVN0eWxlczIoZ2V0U3R5bGVzKTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMucm9vdH0+XG4gICAgICA8U3RhY2sgZ2FwPXsxfT57Y2hpbGRyZW59PC9TdGFjaz5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuY29uc3QgZ2V0U3R5bGVzID0gKHRoZW1lOiBHcmFmYW5hVGhlbWUyKSA9PiB7XG4gIHJldHVybiB7XG4gICAgcm9vdDogY3NzKHtcbiAgICAgIHBhZGRpbmc6IHRoZW1lLnNwYWNpbmcoMSwgMSwgMCwgMSksXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoZW1lLmNvbG9ycy5iYWNrZ3JvdW5kLnNlY29uZGFyeSxcbiAgICAgIGJvcmRlclJhZGl1czogdGhlbWUuc2hhcGUuYm9yZGVyUmFkaXVzKDEpLFxuICAgIH0pLFxuICB9O1xufTtcbiIsImltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBSYWRpb0J1dHRvbkdyb3VwLCBUYWcgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5cbmltcG9ydCB7IFF1ZXJ5RWRpdG9yTW9kZSB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgbW9kZTogUXVlcnlFZGl0b3JNb2RlO1xuICBvbkNoYW5nZTogKG1vZGU6IFF1ZXJ5RWRpdG9yTW9kZSkgPT4gdm9pZDtcbn1cblxuY29uc3QgZWRpdG9yTW9kZXMgPSBbXG4gIHsgbGFiZWw6ICdFeHBsYWluJywgdmFsdWU6IFF1ZXJ5RWRpdG9yTW9kZS5FeHBsYWluIH0sXG4gIHtcbiAgICBsYWJlbDogJ0J1aWxkZXInLFxuICAgIHZhbHVlOiBRdWVyeUVkaXRvck1vZGUuQnVpbGRlcixcbiAgICBjb21wb25lbnQ6ICgpID0+IChcbiAgICAgIDxUYWdcbiAgICAgICAgY2xhc3NOYW1lPXtjc3Moe1xuICAgICAgICAgIGZvbnRTaXplOiAxMCxcbiAgICAgICAgICBwYWRkaW5nOiAnMXB4IDVweCcsXG4gICAgICAgICAgdmVydGljYWxBbGlnbjogJ3RleHQtYm90dG9tJyxcbiAgICAgICAgfSl9XG4gICAgICAgIG5hbWU9eydCZXRhJ31cbiAgICAgICAgY29sb3JJbmRleD17MX1cbiAgICAgIC8+XG4gICAgKSxcbiAgfSxcbiAgeyBsYWJlbDogJ0NvZGUnLCB2YWx1ZTogUXVlcnlFZGl0b3JNb2RlLkNvZGUgfSxcbl07XG5cbmV4cG9ydCBmdW5jdGlvbiBRdWVyeUVkaXRvck1vZGVUb2dnbGUoeyBtb2RlLCBvbkNoYW5nZSB9OiBQcm9wcykge1xuICByZXR1cm4gKFxuICAgIDxkaXYgZGF0YS10ZXN0aWQ9eydRdWVyeUVkaXRvck1vZGVUb2dnbGUnfT5cbiAgICAgIDxSYWRpb0J1dHRvbkdyb3VwIG9wdGlvbnM9e2VkaXRvck1vZGVzfSBzaXplPVwic21cIiB2YWx1ZT17bW9kZX0gb25DaGFuZ2U9e29uQ2hhbmdlfSAvPlxuICAgIDwvZGl2PlxuICApO1xufVxuIiwiaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCB7IHVuaXF1ZUlkIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBSZWFjdCwgeyBIVE1MUHJvcHMsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgR3JhZmFuYVRoZW1lMiB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgU3RhY2sgfSBmcm9tICdAZ3JhZmFuYS9leHBlcmltZW50YWwnO1xuaW1wb3J0IHsgU3dpdGNoLCB1c2VTdHlsZXMyIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIGV4dGVuZHMgT21pdDxIVE1MUHJvcHM8SFRNTElucHV0RWxlbWVudD4sICd2YWx1ZScgfCAncmVmJz4ge1xuICB2YWx1ZT86IGJvb2xlYW47XG4gIGxhYmVsOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBRdWVyeUhlYWRlclN3aXRjaCh7IGxhYmVsLCAuLi5pbnB1dFByb3BzIH06IFByb3BzKSB7XG4gIGNvbnN0IGRhc2hlZExhYmVsID0gbGFiZWwucmVwbGFjZSgnICcsICctJyk7XG4gIGNvbnN0IHN3aXRjaElkUmVmID0gdXNlUmVmKHVuaXF1ZUlkKGBzd2l0Y2gtJHtkYXNoZWRMYWJlbH1gKSk7XG4gIGNvbnN0IHN0eWxlcyA9IHVzZVN0eWxlczIoZ2V0U3R5bGVzKTtcblxuICByZXR1cm4gKFxuICAgIDxTdGFjayBnYXA9ezF9PlxuICAgICAgPGxhYmVsIGh0bWxGb3I9e3N3aXRjaElkUmVmLmN1cnJlbnR9IGNsYXNzTmFtZT17c3R5bGVzLnN3aXRjaExhYmVsfT5cbiAgICAgICAge2xhYmVsfVxuICAgICAgPC9sYWJlbD5cbiAgICAgIDxTd2l0Y2ggey4uLmlucHV0UHJvcHN9IGlkPXtzd2l0Y2hJZFJlZi5jdXJyZW50fSAvPlxuICAgIDwvU3RhY2s+XG4gICk7XG59XG5cbmNvbnN0IGdldFN0eWxlcyA9ICh0aGVtZTogR3JhZmFuYVRoZW1lMikgPT4ge1xuICByZXR1cm4ge1xuICAgIHN3aXRjaExhYmVsOiBjc3Moe1xuICAgICAgY29sb3I6IHRoZW1lLmNvbG9ycy50ZXh0LnNlY29uZGFyeSxcbiAgICAgIGN1cnNvcjogJ3BvaW50ZXInLFxuICAgICAgZm9udFNpemU6IHRoZW1lLnR5cG9ncmFwaHkuYm9keVNtYWxsLmZvbnRTaXplLFxuICAgICAgJyY6aG92ZXInOiB7XG4gICAgICAgIGNvbG9yOiB0aGVtZS5jb2xvcnMudGV4dC5wcmltYXJ5LFxuICAgICAgfSxcbiAgICB9KSxcbiAgfTtcbn07XG4iLCJpbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVRvZ2dsZSB9IGZyb20gJ3JlYWN0LXVzZSc7XG5cbmltcG9ydCB7IEdyYWZhbmFUaGVtZTIgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IFN0YWNrIH0gZnJvbSAnQGdyYWZhbmEvZXhwZXJpbWVudGFsJztcbmltcG9ydCB7IEljb24sIHVzZVN0eWxlczIgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICB0aXRsZTogc3RyaW5nO1xuICBjb2xsYXBzZWRJbmZvOiBzdHJpbmdbXTtcbiAgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFF1ZXJ5T3B0aW9uR3JvdXAoeyB0aXRsZSwgY2hpbGRyZW4sIGNvbGxhcHNlZEluZm8gfTogUHJvcHMpIHtcbiAgY29uc3QgW2lzT3BlbiwgdG9nZ2xlT3Blbl0gPSB1c2VUb2dnbGUoZmFsc2UpO1xuICBjb25zdCBzdHlsZXMgPSB1c2VTdHlsZXMyKGdldFN0eWxlcyk7XG5cbiAgcmV0dXJuIChcbiAgICA8U3RhY2sgZ2FwPXswfSBkaXJlY3Rpb249XCJjb2x1bW5cIj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuaGVhZGVyfSBvbkNsaWNrPXt0b2dnbGVPcGVufSB0aXRsZT1cIkNsaWNrIHRvIGVkaXQgb3B0aW9uc1wiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnRvZ2dsZX0+XG4gICAgICAgICAgPEljb24gbmFtZT17aXNPcGVuID8gJ2FuZ2xlLWRvd24nIDogJ2FuZ2xlLXJpZ2h0J30gLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxoNiBjbGFzc05hbWU9e3N0eWxlcy50aXRsZX0+e3RpdGxlfTwvaDY+XG4gICAgICAgIHshaXNPcGVuICYmIChcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmRlc2NyaXB0aW9ufT5cbiAgICAgICAgICAgIHtjb2xsYXBzZWRJbmZvLm1hcCgoeCwgaSkgPT4gKFxuICAgICAgICAgICAgICA8c3BhbiBrZXk9e2l9Pnt4fTwvc3Bhbj5cbiAgICAgICAgICAgICkpfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApfVxuICAgICAgPC9kaXY+XG4gICAgICB7aXNPcGVuICYmIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuYm9keX0+e2NoaWxkcmVufTwvZGl2Pn1cbiAgICA8L1N0YWNrPlxuICApO1xufVxuXG5jb25zdCBnZXRTdHlsZXMgPSAodGhlbWU6IEdyYWZhbmFUaGVtZTIpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBzd2l0Y2hMYWJlbDogY3NzKHtcbiAgICAgIGNvbG9yOiB0aGVtZS5jb2xvcnMudGV4dC5zZWNvbmRhcnksXG4gICAgICBjdXJzb3I6ICdwb2ludGVyJyxcbiAgICAgIGZvbnRTaXplOiB0aGVtZS50eXBvZ3JhcGh5LmJvZHlTbWFsbC5mb250U2l6ZSxcbiAgICAgICcmOmhvdmVyJzoge1xuICAgICAgICBjb2xvcjogdGhlbWUuY29sb3JzLnRleHQucHJpbWFyeSxcbiAgICAgIH0sXG4gICAgfSksXG4gICAgaGVhZGVyOiBjc3Moe1xuICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgY3Vyc29yOiAncG9pbnRlcicsXG4gICAgICBhbGlnbkl0ZW1zOiAnYmFzZWxpbmUnLFxuICAgICAgY29sb3I6IHRoZW1lLmNvbG9ycy50ZXh0LnByaW1hcnksXG4gICAgICAnJjpob3Zlcic6IHtcbiAgICAgICAgYmFja2dyb3VuZDogdGhlbWUuY29sb3JzLmVtcGhhc2l6ZSh0aGVtZS5jb2xvcnMuYmFja2dyb3VuZC5wcmltYXJ5LCAwLjAzKSxcbiAgICAgIH0sXG4gICAgfSksXG4gICAgdGl0bGU6IGNzcyh7XG4gICAgICBmbGV4R3JvdzogMSxcbiAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgIGZvbnRTaXplOiB0aGVtZS50eXBvZ3JhcGh5LmJvZHlTbWFsbC5mb250U2l6ZSxcbiAgICAgIGZvbnRXZWlnaHQ6IHRoZW1lLnR5cG9ncmFwaHkuZm9udFdlaWdodE1lZGl1bSxcbiAgICAgIG1hcmdpbjogMCxcbiAgICB9KSxcbiAgICBkZXNjcmlwdGlvbjogY3NzKHtcbiAgICAgIGNvbG9yOiB0aGVtZS5jb2xvcnMudGV4dC5zZWNvbmRhcnksXG4gICAgICBmb250U2l6ZTogdGhlbWUudHlwb2dyYXBoeS5ib2R5U21hbGwuZm9udFNpemUsXG4gICAgICBwYWRkaW5nTGVmdDogdGhlbWUuc3BhY2luZygyKSxcbiAgICAgIGdhcDogdGhlbWUuc3BhY2luZygyKSxcbiAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICB9KSxcbiAgICBib2R5OiBjc3Moe1xuICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgcGFkZGluZ1RvcDogdGhlbWUuc3BhY2luZygyKSxcbiAgICAgIGdhcDogdGhlbWUuc3BhY2luZygyKSxcbiAgICAgIGZsZXhXcmFwOiAnd3JhcCcsXG4gICAgfSksXG4gICAgdG9nZ2xlOiBjc3Moe1xuICAgICAgY29sb3I6IHRoZW1lLmNvbG9ycy50ZXh0LnNlY29uZGFyeSxcbiAgICAgIG1hcmdpblJpZ2h0OiBgJHt0aGVtZS5zcGFjaW5nKDEpfWAsXG4gICAgfSksXG4gIH07XG59O1xuIiwiaW1wb3J0IHsgY2FwaXRhbGl6ZSB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgcGx1cmFsaXplIGZyb20gJ3BsdXJhbGl6ZSc7XG5cbmltcG9ydCB7IFNlbGVjdGFibGVWYWx1ZSB9IGZyb20gJ0BncmFmYW5hL2RhdGEvc3JjJztcblxuaW1wb3J0IHsgTGFiZWxQYXJhbUVkaXRvciB9IGZyb20gJy4uL2NvbXBvbmVudHMvTGFiZWxQYXJhbUVkaXRvcic7XG5pbXBvcnQgeyBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeSB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtcbiAgUXVlcnlCdWlsZGVyT3BlcmF0aW9uLFxuICBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsXG4gIFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmLFxuICBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbVZhbHVlLFxuICBRdWVyeVdpdGhPcGVyYXRpb25zLFxufSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGZ1bmN0aW9uUmVuZGVyZXJMZWZ0KG1vZGVsOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLCBpbm5lckV4cHI6IHN0cmluZykge1xuICBjb25zdCBwYXJhbXMgPSByZW5kZXJQYXJhbXMobW9kZWwsIGRlZiwgaW5uZXJFeHByKTtcbiAgY29uc3Qgc3RyID0gbW9kZWwuaWQgKyAnKCc7XG5cbiAgaWYgKGlubmVyRXhwcikge1xuICAgIHBhcmFtcy5wdXNoKGlubmVyRXhwcik7XG4gIH1cblxuICByZXR1cm4gc3RyICsgcGFyYW1zLmpvaW4oJywgJykgKyAnKSc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmdW5jdGlvblJlbmRlcmVyUmlnaHQobW9kZWw6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiwgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsIGlubmVyRXhwcjogc3RyaW5nKSB7XG4gIGNvbnN0IHBhcmFtcyA9IHJlbmRlclBhcmFtcyhtb2RlbCwgZGVmLCBpbm5lckV4cHIpO1xuICBjb25zdCBzdHIgPSBtb2RlbC5pZCArICcoJztcblxuICBpZiAoaW5uZXJFeHByKSB7XG4gICAgcGFyYW1zLnVuc2hpZnQoaW5uZXJFeHByKTtcbiAgfVxuXG4gIHJldHVybiBzdHIgKyBwYXJhbXMuam9pbignLCAnKSArICcpJztcbn1cblxuZnVuY3Rpb24gcmFuZ2VSZW5kZXJlcldpdGhQYXJhbXMoXG4gIG1vZGVsOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sXG4gIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLFxuICBpbm5lckV4cHI6IHN0cmluZyxcbiAgcmVuZGVyTGVmdDogYm9vbGVhblxuKSB7XG4gIGlmIChkZWYucGFyYW1zLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBgQ2Fubm90IHJlbmRlciBhIGZ1bmN0aW9uIHdpdGggcGFyYW1zIG9mIGxlbmd0aCBbJHtkZWYucGFyYW1zLmxlbmd0aH1dYDtcbiAgfVxuXG4gIGxldCByYW5nZVZlY3RvciA9IChtb2RlbC5wYXJhbXMgPz8gW10pWzBdID8/ICc1bSc7XG5cbiAgLy8gTmV4dCBmcmFtZSB0aGUgcmVtYWluaW5nIHBhcmFtZXRlcnMsIGJ1dCBnZXQgcmlkIG9mIHRoZSBmaXJzdCBvbmUgYmVjYXVzZSBpdCdzIHVzZWQgdG8gbW92ZSB0aGVcbiAgLy8gaW5zdGFudCB2ZWN0b3IgaW50byBhIHJhbmdlIHZlY3Rvci5cbiAgY29uc3QgcGFyYW1zID0gcmVuZGVyUGFyYW1zKFxuICAgIHtcbiAgICAgIC4uLm1vZGVsLFxuICAgICAgcGFyYW1zOiBtb2RlbC5wYXJhbXMuc2xpY2UoMSksXG4gICAgfSxcbiAgICB7XG4gICAgICAuLi5kZWYsXG4gICAgICBwYXJhbXM6IGRlZi5wYXJhbXMuc2xpY2UoMSksXG4gICAgICBkZWZhdWx0UGFyYW1zOiBkZWYuZGVmYXVsdFBhcmFtcy5zbGljZSgxKSxcbiAgICB9LFxuICAgIGlubmVyRXhwclxuICApO1xuXG4gIGNvbnN0IHN0ciA9IG1vZGVsLmlkICsgJygnO1xuXG4gIC8vIERlcGVuZGluZyBvbiB0aGUgcmVuZGVyTGVmdCB2YXJpYWJsZSwgcmVuZGVyIHBhcmFtZXRlcnMgdG8gdGhlIGxlZnQgb3IgcmlnaHRcbiAgLy8gcmVuZGVyTGVmdCA9PT0gdHJ1ZSAocmVuZGVyTGVmdCkgPT4gKHBhcmFtMSwgcGFyYW0yLCByYW5nZVZlY3RvclsuLi5dKVxuICAvLyByZW5kZXJMZWZ0ID09PSBmYWxzZSAocmVuZGVyUmlnaHQpID0+IChyYW5nZVZlY3RvclsuLi5dLCBwYXJhbTEsIHBhcmFtMilcbiAgaWYgKGlubmVyRXhwcikge1xuICAgIHJlbmRlckxlZnQgPyBwYXJhbXMucHVzaChgJHtpbm5lckV4cHJ9WyR7cmFuZ2VWZWN0b3J9XWApIDogcGFyYW1zLnVuc2hpZnQoYCR7aW5uZXJFeHByfVske3JhbmdlVmVjdG9yfV1gKTtcbiAgfVxuXG4gIC8vIHN0aWNrIGV2ZXJ5dGhpbmcgdG9nZXRoZXJcbiAgcmV0dXJuIHN0ciArIHBhcmFtcy5qb2luKCcsICcpICsgJyknO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmFuZ2VSZW5kZXJlclJpZ2h0V2l0aFBhcmFtcyhcbiAgbW9kZWw6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbixcbiAgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsXG4gIGlubmVyRXhwcjogc3RyaW5nXG4pIHtcbiAgcmV0dXJuIHJhbmdlUmVuZGVyZXJXaXRoUGFyYW1zKG1vZGVsLCBkZWYsIGlubmVyRXhwciwgZmFsc2UpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmFuZ2VSZW5kZXJlckxlZnRXaXRoUGFyYW1zKFxuICBtb2RlbDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLFxuICBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZixcbiAgaW5uZXJFeHByOiBzdHJpbmdcbikge1xuICByZXR1cm4gcmFuZ2VSZW5kZXJlcldpdGhQYXJhbXMobW9kZWwsIGRlZiwgaW5uZXJFeHByLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyUGFyYW1zKG1vZGVsOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLCBpbm5lckV4cHI6IHN0cmluZykge1xuICByZXR1cm4gKG1vZGVsLnBhcmFtcyA/PyBbXSkubWFwKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBwYXJhbURlZiA9IGRlZi5wYXJhbXNbaW5kZXhdO1xuICAgIGlmIChwYXJhbURlZi50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuICdcIicgKyB2YWx1ZSArICdcIic7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRBZGRPcGVyYXRpb25IYW5kbGVyPFQgZXh0ZW5kcyBRdWVyeVdpdGhPcGVyYXRpb25zPihkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiwgcXVlcnk6IFQpIHtcbiAgY29uc3QgbmV3T3BlcmF0aW9uOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24gPSB7XG4gICAgaWQ6IGRlZi5pZCxcbiAgICBwYXJhbXM6IGRlZi5kZWZhdWx0UGFyYW1zLFxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgLi4ucXVlcnksXG4gICAgb3BlcmF0aW9uczogWy4uLnF1ZXJ5Lm9wZXJhdGlvbnMsIG5ld09wZXJhdGlvbl0sXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQcm9tQW5kTG9raU9wZXJhdGlvbkRpc3BsYXlOYW1lKGZ1bmNOYW1lOiBzdHJpbmcpIHtcbiAgcmV0dXJuIGNhcGl0YWxpemUoZnVuY05hbWUucmVwbGFjZSgvXy9nLCAnICcpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE9wZXJhdGlvblBhcmFtSWQob3BlcmF0aW9uSW5kZXg6IG51bWJlciwgcGFyYW1JbmRleDogbnVtYmVyKSB7XG4gIHJldHVybiBgb3BlcmF0aW9ucy4ke29wZXJhdGlvbkluZGV4fS5wYXJhbS4ke3BhcmFtSW5kZXh9YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJhbmdlVmVjdG9yUGFyYW1EZWYod2l0aFJhdGVJbnRlcnZhbCA9IGZhbHNlKTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1EZWYge1xuICBjb25zdCBwYXJhbTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1EZWYgPSB7XG4gICAgbmFtZTogJ1JhbmdlJyxcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICBvcHRpb25zOiBbXG4gICAgICB7XG4gICAgICAgIGxhYmVsOiAnJF9faW50ZXJ2YWwnLFxuICAgICAgICB2YWx1ZTogJyRfX2ludGVydmFsJyxcbiAgICAgICAgLy8gdG9vbHRpcDogJ0R5bmFtaWMgaW50ZXJ2YWwgYmFzZWQgb24gbWF4IGRhdGEgcG9pbnRzLCBzY3JhcGUgYW5kIG1pbiBpbnRlcnZhbCcsXG4gICAgICB9LFxuICAgICAgeyBsYWJlbDogJzFtJywgdmFsdWU6ICcxbScgfSxcbiAgICAgIHsgbGFiZWw6ICc1bScsIHZhbHVlOiAnNW0nIH0sXG4gICAgICB7IGxhYmVsOiAnMTBtJywgdmFsdWU6ICcxMG0nIH0sXG4gICAgICB7IGxhYmVsOiAnMWgnLCB2YWx1ZTogJzFoJyB9LFxuICAgICAgeyBsYWJlbDogJzI0aCcsIHZhbHVlOiAnMjRoJyB9LFxuICAgIF0sXG4gIH07XG5cbiAgaWYgKHdpdGhSYXRlSW50ZXJ2YWwpIHtcbiAgICAocGFyYW0ub3B0aW9ucyBhcyBBcnJheTxTZWxlY3RhYmxlVmFsdWU8c3RyaW5nPj4pLnVuc2hpZnQoe1xuICAgICAgbGFiZWw6ICckX19yYXRlX2ludGVydmFsJyxcbiAgICAgIHZhbHVlOiAnJF9fcmF0ZV9pbnRlcnZhbCcsXG4gICAgICAvLyB0b29sdGlwOiAnQWx3YXlzIGFib3ZlIDR4IHNjcmFwZSBpbnRlcnZhbCcsXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gcGFyYW07XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBzaGFyZWQgYmV0d2VlbiBQcm9tZXRoZXVzIGFuZCBMb2tpIHZhcmlhbnRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBZ2dyZWdhdGlvbk9wZXJhdGlvbjxUIGV4dGVuZHMgUXVlcnlXaXRoT3BlcmF0aW9ucz4oXG4gIG5hbWU6IHN0cmluZyxcbiAgb3ZlcnJpZGVzOiBQYXJ0aWFsPFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZj4gPSB7fVxuKTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmW10ge1xuICBjb25zdCBvcGVyYXRpb25zOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWZbXSA9IFtcbiAgICB7XG4gICAgICBpZDogbmFtZSxcbiAgICAgIG5hbWU6IGdldFByb21BbmRMb2tpT3BlcmF0aW9uRGlzcGxheU5hbWUobmFtZSksXG4gICAgICBwYXJhbXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdCeSBsYWJlbCcsXG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgcmVzdFBhcmFtOiB0cnVlLFxuICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFtdLFxuICAgICAgYWx0ZXJuYXRpdmVzS2V5OiAncGxhaW4gYWdncmVnYXRpb25zJyxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5BZ2dyZWdhdGlvbnMsXG4gICAgICByZW5kZXJlcjogZnVuY3Rpb25SZW5kZXJlckxlZnQsXG4gICAgICBwYXJhbUNoYW5nZWRIYW5kbGVyOiBnZXRPbkxhYmVsQWRkZWRIYW5kbGVyKGBfXyR7bmFtZX1fYnlgKSxcbiAgICAgIGV4cGxhaW5IYW5kbGVyOiBnZXRBZ2dyZWdhdGlvbkV4cGxhaW5lcihuYW1lLCAnJyksXG4gICAgICBhZGRPcGVyYXRpb25IYW5kbGVyOiBkZWZhdWx0QWRkT3BlcmF0aW9uSGFuZGxlcixcbiAgICAgIC4uLm92ZXJyaWRlcyxcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiBgX18ke25hbWV9X2J5YCxcbiAgICAgIG5hbWU6IGAke2dldFByb21BbmRMb2tpT3BlcmF0aW9uRGlzcGxheU5hbWUobmFtZSl9IGJ5YCxcbiAgICAgIHBhcmFtczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ0xhYmVsJyxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICByZXN0UGFyYW06IHRydWUsXG4gICAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgICAgZWRpdG9yOiBMYWJlbFBhcmFtRWRpdG9yLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFsnJ10sXG4gICAgICBhbHRlcm5hdGl2ZXNLZXk6ICdhZ2dyZWdhdGlvbnMgYnknLFxuICAgICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkFnZ3JlZ2F0aW9ucyxcbiAgICAgIHJlbmRlcmVyOiBnZXRBZ2dyZWdhdGlvbkJ5UmVuZGVyZXIobmFtZSksXG4gICAgICBwYXJhbUNoYW5nZWRIYW5kbGVyOiBnZXRMYXN0TGFiZWxSZW1vdmVkSGFuZGxlcihuYW1lKSxcbiAgICAgIGV4cGxhaW5IYW5kbGVyOiBnZXRBZ2dyZWdhdGlvbkV4cGxhaW5lcihuYW1lLCAnYnknKSxcbiAgICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGRlZmF1bHRBZGRPcGVyYXRpb25IYW5kbGVyLFxuICAgICAgaGlkZUZyb21MaXN0OiB0cnVlLFxuICAgICAgLi4ub3ZlcnJpZGVzLFxuICAgIH0sXG4gICAge1xuICAgICAgaWQ6IGBfXyR7bmFtZX1fd2l0aG91dGAsXG4gICAgICBuYW1lOiBgJHtnZXRQcm9tQW5kTG9raU9wZXJhdGlvbkRpc3BsYXlOYW1lKG5hbWUpfSB3aXRob3V0YCxcbiAgICAgIHBhcmFtczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ0xhYmVsJyxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICByZXN0UGFyYW06IHRydWUsXG4gICAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgICAgZWRpdG9yOiBMYWJlbFBhcmFtRWRpdG9yLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFsnJ10sXG4gICAgICBhbHRlcm5hdGl2ZXNLZXk6ICdhZ2dyZWdhdGlvbnMgYnknLFxuICAgICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkFnZ3JlZ2F0aW9ucyxcbiAgICAgIHJlbmRlcmVyOiBnZXRBZ2dyZWdhdGlvbldpdGhvdXRSZW5kZXJlcihuYW1lKSxcbiAgICAgIHBhcmFtQ2hhbmdlZEhhbmRsZXI6IGdldExhc3RMYWJlbFJlbW92ZWRIYW5kbGVyKG5hbWUpLFxuICAgICAgZXhwbGFpbkhhbmRsZXI6IGdldEFnZ3JlZ2F0aW9uRXhwbGFpbmVyKG5hbWUsICd3aXRob3V0JyksXG4gICAgICBhZGRPcGVyYXRpb25IYW5kbGVyOiBkZWZhdWx0QWRkT3BlcmF0aW9uSGFuZGxlcixcbiAgICAgIGhpZGVGcm9tTGlzdDogdHJ1ZSxcbiAgICAgIC4uLm92ZXJyaWRlcyxcbiAgICB9LFxuICBdO1xuXG4gIHJldHVybiBvcGVyYXRpb25zO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQWdncmVnYXRpb25PcGVyYXRpb25XaXRoUGFyYW0oXG4gIG5hbWU6IHN0cmluZyxcbiAgcGFyYW1zRGVmOiB7IHBhcmFtczogUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1EZWZbXTsgZGVmYXVsdFBhcmFtczogUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1WYWx1ZVtdIH0sXG4gIG92ZXJyaWRlczogUGFydGlhbDxRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWY+ID0ge31cbik6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZltdIHtcbiAgY29uc3Qgb3BlcmF0aW9ucyA9IGNyZWF0ZUFnZ3JlZ2F0aW9uT3BlcmF0aW9uKG5hbWUsIG92ZXJyaWRlcyk7XG4gIG9wZXJhdGlvbnNbMF0ucGFyYW1zLnVuc2hpZnQoLi4ucGFyYW1zRGVmLnBhcmFtcyk7XG4gIG9wZXJhdGlvbnNbMV0ucGFyYW1zLnVuc2hpZnQoLi4ucGFyYW1zRGVmLnBhcmFtcyk7XG4gIG9wZXJhdGlvbnNbMl0ucGFyYW1zLnVuc2hpZnQoLi4ucGFyYW1zRGVmLnBhcmFtcyk7XG4gIG9wZXJhdGlvbnNbMF0uZGVmYXVsdFBhcmFtcyA9IHBhcmFtc0RlZi5kZWZhdWx0UGFyYW1zO1xuICBvcGVyYXRpb25zWzFdLmRlZmF1bHRQYXJhbXMgPSBbLi4ucGFyYW1zRGVmLmRlZmF1bHRQYXJhbXMsICcnXTtcbiAgb3BlcmF0aW9uc1syXS5kZWZhdWx0UGFyYW1zID0gWy4uLnBhcmFtc0RlZi5kZWZhdWx0UGFyYW1zLCAnJ107XG4gIG9wZXJhdGlvbnNbMV0ucmVuZGVyZXIgPSBnZXRBZ2dyZWdhdGlvbkJ5UmVuZGVyZXJXaXRoUGFyYW1ldGVyKG5hbWUpO1xuICBvcGVyYXRpb25zWzJdLnJlbmRlcmVyID0gZ2V0QWdncmVnYXRpb25CeVJlbmRlcmVyV2l0aFBhcmFtZXRlcihuYW1lKTtcbiAgcmV0dXJuIG9wZXJhdGlvbnM7XG59XG5cbmZ1bmN0aW9uIGdldEFnZ3JlZ2F0aW9uQnlSZW5kZXJlcihhZ2dyZWdhdGlvbjogc3RyaW5nKSB7XG4gIHJldHVybiBmdW5jdGlvbiBhZ2dyZWdhdGlvblJlbmRlcmVyKG1vZGVsOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLCBpbm5lckV4cHI6IHN0cmluZykge1xuICAgIHJldHVybiBgJHthZ2dyZWdhdGlvbn0gYnkoJHttb2RlbC5wYXJhbXMuam9pbignLCAnKX0pICgke2lubmVyRXhwcn0pYDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0QWdncmVnYXRpb25XaXRob3V0UmVuZGVyZXIoYWdncmVnYXRpb246IHN0cmluZykge1xuICByZXR1cm4gZnVuY3Rpb24gYWdncmVnYXRpb25SZW5kZXJlcihtb2RlbDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLCBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiwgaW5uZXJFeHByOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gYCR7YWdncmVnYXRpb259IHdpdGhvdXQoJHttb2RlbC5wYXJhbXMuam9pbignLCAnKX0pICgke2lubmVyRXhwcn0pYDtcbiAgfTtcbn1cblxuLyoqXG4gKiBWZXJ5IHNpbXBsZSBwb2MgaW1wbGVtZW50YXRpb24sIG5lZWRzIHRvIGJlIG1vZGlmaWVkIHRvIHN1cHBvcnQgYWxsIGFnZ3JlZ2F0aW9uIG9wZXJhdG9yc1xuICovXG5mdW5jdGlvbiBnZXRBZ2dyZWdhdGlvbkV4cGxhaW5lcihhZ2dyZWdhdGlvbk5hbWU6IHN0cmluZywgbW9kZTogJ2J5JyB8ICd3aXRob3V0JyB8ICcnKSB7XG4gIHJldHVybiBmdW5jdGlvbiBhZ2dyZWdhdGlvbkV4cGxhaW5lcihtb2RlbDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uKSB7XG4gICAgY29uc3QgbGFiZWxzID0gbW9kZWwucGFyYW1zLm1hcCgobGFiZWwpID0+IGBcXGAke2xhYmVsfVxcYGApLmpvaW4oJyBhbmQgJyk7XG4gICAgY29uc3QgbGFiZWxXb3JkID0gcGx1cmFsaXplKCdsYWJlbCcsIG1vZGVsLnBhcmFtcy5sZW5ndGgpO1xuXG4gICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICBjYXNlICdieSc6XG4gICAgICAgIHJldHVybiBgQ2FsY3VsYXRlcyAke2FnZ3JlZ2F0aW9uTmFtZX0gb3ZlciBkaW1lbnNpb25zIHdoaWxlIHByZXNlcnZpbmcgJHtsYWJlbFdvcmR9ICR7bGFiZWxzfS5gO1xuICAgICAgY2FzZSAnd2l0aG91dCc6XG4gICAgICAgIHJldHVybiBgQ2FsY3VsYXRlcyAke2FnZ3JlZ2F0aW9uTmFtZX0gb3ZlciB0aGUgZGltZW5zaW9ucyAke2xhYmVsc30uIEFsbCBvdGhlciBsYWJlbHMgYXJlIHByZXNlcnZlZC5gO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGBDYWxjdWxhdGVzICR7YWdncmVnYXRpb25OYW1lfSBvdmVyIHRoZSBkaW1lbnNpb25zLmA7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRBZ2dyZWdhdGlvbkJ5UmVuZGVyZXJXaXRoUGFyYW1ldGVyKGFnZ3JlZ2F0aW9uOiBzdHJpbmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGFnZ3JlZ2F0aW9uUmVuZGVyZXIobW9kZWw6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiwgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsIGlubmVyRXhwcjogc3RyaW5nKSB7XG4gICAgZnVuY3Rpb24gbWFwVHlwZShwOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbVZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHAgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBgXFxcIiR7cH1cXFwiYDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBjb25zdCBwYXJhbXMgPSBtb2RlbC5wYXJhbXMuc2xpY2UoMCwgLTEpO1xuICAgIGNvbnN0IHJlc3RQYXJhbXMgPSBtb2RlbC5wYXJhbXMuc2xpY2UoMSk7XG4gICAgcmV0dXJuIGAke2FnZ3JlZ2F0aW9ufSBieSgke3Jlc3RQYXJhbXMuam9pbignLCAnKX0pICgke3BhcmFtcy5tYXAobWFwVHlwZSkuam9pbignLCAnKX0sICR7aW5uZXJFeHByfSlgO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCB0cmFuc2Zvcm0gb3BlcmF0aW9ucyB3aXRob3V0IGxhYmVscyB0byB0aGVpciBwbGFuIGFnZ3JlZ2F0aW9uIG9wZXJhdGlvblxuICovXG5mdW5jdGlvbiBnZXRMYXN0TGFiZWxSZW1vdmVkSGFuZGxlcihjaGFuZ2VUb09wZXJhdGlvbklkOiBzdHJpbmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIG9uUGFyYW1DaGFuZ2VkKGluZGV4OiBudW1iZXIsIG9wOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmKSB7XG4gICAgLy8gSWYgZGVmaW5pdGlvbiBoYXMgbW9yZSBwYXJhbXMgdGhlbiBpcyBkZWZpbmVkIHRoZXJlIGFyZSBubyBvcHRpb25hbCByZXN0IHBhcmFtcyBhbnltb3JlLlxuICAgIC8vIFdlIHRoZW4gdHJhbnNmb3JtIHRoaXMgb3BlcmF0aW9uIGludG8gYSBkaWZmZXJlbnQgb25lXG4gICAgaWYgKG9wLnBhcmFtcy5sZW5ndGggPCBkZWYucGFyYW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ub3AsXG4gICAgICAgIGlkOiBjaGFuZ2VUb09wZXJhdGlvbklkLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3A7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldE9uTGFiZWxBZGRlZEhhbmRsZXIoY2hhbmdlVG9PcGVyYXRpb25JZDogc3RyaW5nKSB7XG4gIHJldHVybiBmdW5jdGlvbiBvblBhcmFtQ2hhbmdlZChpbmRleDogbnVtYmVyLCBvcDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLCBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZikge1xuICAgIC8vIENoZWNrIGlmIHdlIGFjdHVhbGx5IGhhdmUgdGhlIGxhYmVsIHBhcmFtLiBBcyBpdCdzIG9wdGlvbmFsIHRoZSBhZ2dyZWdhdGlvbiBjYW4gaGF2ZSBvbmUgbGVzcywgd2hpY2ggaXMgdGhlXG4gICAgLy8gY2FzZSBvZiBqdXN0IHNpbXBsZSBhZ2dyZWdhdGlvbiB3aXRob3V0IGxhYmVsLiBXaGVuIHVzZXIgYWRkcyB0aGUgbGFiZWwgaXQgbm93IGhhcyB0aGUgc2FtZSBudW1iZXIgb2YgcGFyYW1zXG4gICAgLy8gYXMgaXQncyBkZWZpbml0aW9uLCBhbmQgbm93IHdlIGNhbiBjaGFuZ2UgaXQgdG8gaXQncyBgX2J5YCB2YXJpYW50LlxuICAgIGlmIChvcC5wYXJhbXMubGVuZ3RoID09PSBkZWYucGFyYW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ub3AsXG4gICAgICAgIGlkOiBjaGFuZ2VUb09wZXJhdGlvbklkLFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG9wO1xuICB9O1xufVxuIiwiaW1wb3J0IHsgU3ludGF4Tm9kZSwgVHJlZUN1cnNvciB9IGZyb20gJ0BsZXplci9jb21tb24nO1xuXG5pbXBvcnQgeyBRdWVyeUJ1aWxkZXJPcGVyYXRpb24gfSBmcm9tICcuL3R5cGVzJztcblxuLy8gVGhpcyBpcyB1c2VkIGZvciBlcnJvciB0eXBlIGZvciBzb21lIHJlYXNvblxuZXhwb3J0IGNvbnN0IEVycm9yTmFtZSA9ICfimqAnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGVmdE1vc3RDaGlsZChjdXI6IFN5bnRheE5vZGUpOiBTeW50YXhOb2RlIHtcbiAgcmV0dXJuIGN1ci5maXJzdENoaWxkID8gZ2V0TGVmdE1vc3RDaGlsZChjdXIuZmlyc3RDaGlsZCkgOiBjdXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlRXJyb3IoZXhwcjogc3RyaW5nLCBub2RlOiBTeW50YXhOb2RlKSB7XG4gIHJldHVybiB7XG4gICAgdGV4dDogZ2V0U3RyaW5nKGV4cHIsIG5vZGUpLFxuICAgIC8vIFRPRE86IHRoaXMgYXJlIHBvc2l0aW9ucyBpbiB0aGUgc3RyaW5nIHdpdGggdGhlIHJlcGxhY2VkIHZhcmlhYmxlcy4gTWVhbnMgaXQgY2Fubm90IGJlIHVzZWQgdG8gc2hvdyBleGFjdFxuICAgIC8vICBwbGFjZW1lbnQgb2YgdGhlIGVycm9yIGZvciB0aGUgdXNlci4gV2UgbmVlZCBzb21lIHRyYW5zbGF0aW9uIHRhYmxlIHRvIHBvc2l0aW9ucyBiZWZvcmUgdGhlIHZhcmlhYmxlXG4gICAgLy8gIHJlcGxhY2UuXG4gICAgZnJvbTogbm9kZS5mcm9tLFxuICAgIHRvOiBub2RlLnRvLFxuICAgIHBhcmVudFR5cGU6IG5vZGUucGFyZW50Py5uYW1lLFxuICB9O1xufVxuXG4vLyBUYWtlbiBmcm9tIHRlbXBsYXRlX3NydiwgYnV0IGNvcGllZCBzbyB0byBub3QgbWVzcyB3aXRoIHRoZSByZWdleC5pbmRleCB3aGljaCBpcyBtYW5pcHVsYXRlZCBpbiB0aGUgc2VydmljZVxuLypcbiAqIFRoaXMgcmVnZXggbWF0Y2hlcyAzIHR5cGVzIG9mIHZhcmlhYmxlIHJlZmVyZW5jZSB3aXRoIGFuIG9wdGlvbmFsIGZvcm1hdCBzcGVjaWZpZXJcbiAqIFxcJChcXHcrKSAgICAgICAgICAgICAgICAgICAgICAgICAgJHZhcjFcbiAqIFxcW1xcWyhbXFxzXFxTXSs/KSg/OjooXFx3KykpP1xcXVxcXSAgICBbW3ZhcjJdXSBvciBbW3ZhcjI6Zm10Ml1dXG4gKiBcXCR7KFxcdyspKD86OihcXHcrKSk/fSAgICAgICAgICAgICAke3ZhcjN9IG9yICR7dmFyMzpmbXQzfVxuICovXG5jb25zdCB2YXJpYWJsZVJlZ2V4ID0gL1xcJChcXHcrKXxcXFtcXFsoW1xcc1xcU10rPykoPzo6KFxcdyspKT9cXF1cXF18XFwkeyhcXHcrKSg/OlxcLihbXjpeXFx9XSspKT8oPzo6KFteXFx9XSspKT99L2c7XG5cbi8qKlxuICogQXMgdmFyaWFibGVzIHdpdGggJCBhcmUgY3JlYXRpbmcgcGFyc2luZyBlcnJvcnMsIHdlIGZpcnN0IHJlcGxhY2UgdGhlbSB3aXRoIG1hZ2ljIHN0cmluZyB0aGF0IGlzIHBhcnNhYmxlIGFuZCBhdFxuICogdGhlIHNhbWUgdGltZSB3ZSBjYW4gZ2V0IHRoZSB2YXJpYWJsZSBhbmQgaXQncyBmb3JtYXQgYmFjayBmcm9tIGl0LlxuICogQHBhcmFtIGV4cHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlcGxhY2VWYXJpYWJsZXMoZXhwcjogc3RyaW5nKSB7XG4gIHJldHVybiBleHByLnJlcGxhY2UodmFyaWFibGVSZWdleCwgKG1hdGNoLCB2YXIxLCB2YXIyLCBmbXQyLCB2YXIzLCBmaWVsZFBhdGgsIGZtdDMpID0+IHtcbiAgICBjb25zdCBmbXQgPSBmbXQyIHx8IGZtdDM7XG4gICAgbGV0IHZhcmlhYmxlID0gdmFyMTtcbiAgICBsZXQgdmFyVHlwZSA9ICcwJztcblxuICAgIGlmICh2YXIyKSB7XG4gICAgICB2YXJpYWJsZSA9IHZhcjI7XG4gICAgICB2YXJUeXBlID0gJzEnO1xuICAgIH1cblxuICAgIGlmICh2YXIzKSB7XG4gICAgICB2YXJpYWJsZSA9IHZhcjM7XG4gICAgICB2YXJUeXBlID0gJzInO1xuICAgIH1cblxuICAgIHJldHVybiBgX19WXyR7dmFyVHlwZX1fX2AgKyB2YXJpYWJsZSArICdfX1ZfXycgKyAoZm10ID8gJ19fRl9fJyArIGZtdCArICdfX0ZfXycgOiAnJyk7XG4gIH0pO1xufVxuXG5jb25zdCB2YXJUeXBlRnVuYyA9IFtcbiAgKHY6IHN0cmluZywgZj86IHN0cmluZykgPT4gYFxcJCR7dn1gLFxuICAodjogc3RyaW5nLCBmPzogc3RyaW5nKSA9PiBgW1ske3Z9JHtmID8gYDoke2Z9YCA6ICcnfV1dYCxcbiAgKHY6IHN0cmluZywgZj86IHN0cmluZykgPT4gYFxcJFxceyR7dn0ke2YgPyBgOiR7Zn1gIDogJyd9XFx9YCxcbl07XG5cbi8qKlxuICogR2V0IGJhY2sgdGhlIHRleHQgd2l0aCB2YXJpYWJsZXMgaW4gdGhlaXIgb3JpZ2luYWwgZm9ybWF0LlxuICogQHBhcmFtIGV4cHJcbiAqL1xuZnVuY3Rpb24gcmV0dXJuVmFyaWFibGVzKGV4cHI6IHN0cmluZykge1xuICByZXR1cm4gZXhwci5yZXBsYWNlKC9fX1ZfKFxcZClfXyguKz8pX19WX18oPzpfX0ZfXyhcXHcrKV9fRl9fKT8vZywgKG1hdGNoLCB0eXBlLCB2LCBmKSA9PiB7XG4gICAgcmV0dXJuIHZhclR5cGVGdW5jW3BhcnNlSW50KHR5cGUsIDEwKV0odiwgZik7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCB0aGUgYWN0dWFsIHN0cmluZyBvZiB0aGUgZXhwcmVzc2lvbi4gVGhhdCBpcyBub3Qgc3RvcmVkIGluIHRoZSB0cmVlIHNvIHdlIGhhdmUgdG8gZ2V0IHRoZSBpbmRleGVzIGZyb20gdGhlIG5vZGVcbiAqIGFuZCB0aGVuIGJhc2VkIG9uIHRoYXQgZ2V0IGl0IGZyb20gdGhlIGV4cHJlc3Npb24uXG4gKiBAcGFyYW0gZXhwclxuICogQHBhcmFtIG5vZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFN0cmluZyhleHByOiBzdHJpbmcsIG5vZGU6IFN5bnRheE5vZGUgfCBUcmVlQ3Vyc29yIHwgbnVsbCB8IHVuZGVmaW5lZCkge1xuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgcmV0dXJuIHJldHVyblZhcmlhYmxlcyhleHByLnN1YnN0cmluZyhub2RlLmZyb20sIG5vZGUudG8pKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgc2ltcGxlIHNjYWxhciBiaW5hcnkgb3Agb2JqZWN0LlxuICogQHBhcmFtIG9wRGVmIC0gZGVmaW5pdGlvbiBvZiB0aGUgb3AgdG8gYmUgY3JlYXRlZFxuICogQHBhcmFtIGV4cHJcbiAqIEBwYXJhbSBudW1iZXJOb2RlIC0gdGhlIG5vZGUgZm9yIHRoZSBzY2FsYXJcbiAqIEBwYXJhbSBoYXNCb29sIC0gd2hldGhlciBvcGVyYXRpb24gaGFzIGEgYm9vbCBtb2RpZmllci4gSXMgdXNlZCBvbmx5IGZvciBvcHMgZm9yIHdoaWNoIGl0IG1ha2VzIHNlbnNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZUJpbk9wKFxuICBvcERlZjogeyBpZDogc3RyaW5nOyBjb21wYXJpc29uPzogYm9vbGVhbiB9LFxuICBleHByOiBzdHJpbmcsXG4gIG51bWJlck5vZGU6IFN5bnRheE5vZGUsXG4gIGhhc0Jvb2w6IGJvb2xlYW5cbik6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiB7XG4gIGNvbnN0IHBhcmFtczogYW55W10gPSBbcGFyc2VGbG9hdChnZXRTdHJpbmcoZXhwciwgbnVtYmVyTm9kZSkpXTtcbiAgaWYgKG9wRGVmLmNvbXBhcmlzb24pIHtcbiAgICBwYXJhbXMucHVzaChoYXNCb29sKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGlkOiBvcERlZi5pZCxcbiAgICBwYXJhbXMsXG4gIH07XG59XG5cbi8qKlxuICogR2V0IGFsbCBub2RlcyB3aXRoIHR5cGUgaW4gdGhlIHRyZWUuIFRoaXMgdHJhdmVyc2VzIHRoZSB0cmVlIHNvIGl0IGlzIHNhZmUgb25seSB3aGVuIHlvdSBrbm93IHRoZXJlIHNob3VsZG4ndCBiZVxuICogdG9vIG11Y2ggbmVzdGluZyBidXQgeW91IGp1c3Qgd2FudCB0byBza2lwIHNvbWUgb2YgdGhlIHdyYXBwZXJzLiBGb3IgZXhhbXBsZSBnZXR0aW5nIGZ1bmN0aW9uIGFyZ3MgdGhpcyB3YXkgd291bGRcbiAqIG5vdCBiZSBzYWZlIGlzIGl0IHdvdWxkIGFsc28gZmluZCBhcmd1bWVudHMgb2YgbmVzdGVkIGZ1bmN0aW9ucy5cbiAqIEBwYXJhbSBleHByXG4gKiBAcGFyYW0gY3VyXG4gKiBAcGFyYW0gdHlwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxsQnlUeXBlKGV4cHI6IHN0cmluZywgY3VyOiBTeW50YXhOb2RlLCB0eXBlOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gIGlmIChjdXIubmFtZSA9PT0gdHlwZSkge1xuICAgIHJldHVybiBbZ2V0U3RyaW5nKGV4cHIsIGN1cildO1xuICB9XG4gIGNvbnN0IHZhbHVlczogc3RyaW5nW10gPSBbXTtcbiAgbGV0IHBvcyA9IDA7XG4gIGxldCBjaGlsZCA9IGN1ci5jaGlsZEFmdGVyKHBvcyk7XG4gIHdoaWxlIChjaGlsZCkge1xuICAgIHZhbHVlcy5wdXNoKC4uLmdldEFsbEJ5VHlwZShleHByLCBjaGlsZCwgdHlwZSkpO1xuICAgIHBvcyA9IGNoaWxkLnRvO1xuICAgIGNoaWxkID0gY3VyLmNoaWxkQWZ0ZXIocG9zKTtcbiAgfVxuICByZXR1cm4gdmFsdWVzO1xufVxuXG4vLyBEZWJ1Z2dpbmcgZnVuY3Rpb24gZm9yIGNvbnZlbmllbmNlLiBHaXZlcyB5b3UgbmljZSBvdXRwdXQgc2ltaWxhciB0byBsaW51eCB0cmVlIHV0aWwuXG4vLyBAdHMtaWdub3JlXG5leHBvcnQgZnVuY3Rpb24gbG9nKGV4cHI6IHN0cmluZywgY3VyPzogU3ludGF4Tm9kZSkge1xuICBpZiAoIWN1cikge1xuICAgIGNvbnNvbGUubG9nKCc8ZW1wdHk+Jyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGpzb24gPSB0b0pzb24oZXhwciwgY3VyKTtcbiAgY29uc3QgdGV4dCA9IGpzb25Ub1RleHQoanNvbik7XG5cbiAgaWYgKCF0ZXh0KSB7XG4gICAgY29uc29sZS5sb2coJzxlbXB0eT4nKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc29sZS5sb2codGV4dCk7XG59XG5cbmZ1bmN0aW9uIHRvSnNvbihleHByOiBzdHJpbmcsIGN1cjogU3ludGF4Tm9kZSkge1xuICBjb25zdCB0cmVlSnNvbjogYW55ID0ge307XG4gIGNvbnN0IG5hbWUgPSBub2RlVG9TdHJpbmcoZXhwciwgY3VyKTtcbiAgY29uc3QgY2hpbGRyZW4gPSBbXTtcblxuICBsZXQgcG9zID0gMDtcbiAgbGV0IGNoaWxkID0gY3VyLmNoaWxkQWZ0ZXIocG9zKTtcbiAgd2hpbGUgKGNoaWxkKSB7XG4gICAgY2hpbGRyZW4ucHVzaCh0b0pzb24oZXhwciwgY2hpbGQpKTtcbiAgICBwb3MgPSBjaGlsZC50bztcbiAgICBjaGlsZCA9IGN1ci5jaGlsZEFmdGVyKHBvcyk7XG4gIH1cblxuICB0cmVlSnNvbi5uYW1lID0gbmFtZTtcbiAgdHJlZUpzb24uY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgcmV0dXJuIHRyZWVKc29uO1xufVxuXG50eXBlIEpzb25Ob2RlID0ge1xuICBuYW1lOiBzdHJpbmc7XG4gIGNoaWxkcmVuOiBKc29uTm9kZVtdO1xufTtcblxuZnVuY3Rpb24ganNvblRvVGV4dChcbiAgbm9kZTogSnNvbk5vZGUsXG4gIGNvbnRleHQ6IHsgbGFzdENoaWxkOiBib29sZWFuOyBpbmRlbnQ6IHN0cmluZyB9ID0ge1xuICAgIGxhc3RDaGlsZDogdHJ1ZSxcbiAgICBpbmRlbnQ6ICcnLFxuICB9XG4pIHtcbiAgY29uc3QgbmFtZSA9IG5vZGUubmFtZTtcbiAgY29uc3QgeyBsYXN0Q2hpbGQsIGluZGVudCB9ID0gY29udGV4dDtcbiAgY29uc3QgbmV3SW5kZW50ID0gaW5kZW50ICE9PSAnJyA/IGluZGVudCArIChsYXN0Q2hpbGQgPyAn4pSU4pSAJyA6ICfilJzilIAnKSA6ICcnO1xuICBsZXQgdGV4dCA9IG5ld0luZGVudCArIG5hbWU7XG5cbiAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICBjaGlsZHJlbi5mb3JFYWNoKChjaGlsZDogYW55LCBpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgY29uc3QgaXNMYXN0Q2hpbGQgPSBpbmRleCA9PT0gY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICB0ZXh0ICs9XG4gICAgICAnXFxuJyArXG4gICAgICBqc29uVG9UZXh0KGNoaWxkLCB7XG4gICAgICAgIGxhc3RDaGlsZDogaXNMYXN0Q2hpbGQsXG4gICAgICAgIGluZGVudDogaW5kZW50ICsgKGxhc3RDaGlsZCA/ICcgICcgOiAn4pSCICcpLFxuICAgICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiB0ZXh0O1xufVxuXG5mdW5jdGlvbiBub2RlVG9TdHJpbmcoZXhwcjogc3RyaW5nLCBub2RlOiBTeW50YXhOb2RlKSB7XG4gIHJldHVybiBub2RlLm5hbWUgKyAnOiAnICsgZ2V0U3RyaW5nKGV4cHIsIG5vZGUpO1xufVxuIiwiLyoqXG4gKiBTaGFyZWQgdHlwZXMgdGhhdCBjYW4gYmUgcmV1c2VkIGJ5IExva2kgYW5kIG90aGVyIGRhdGEgc291cmNlc1xuICovXG5cbmltcG9ydCB7IENvbXBvbmVudFR5cGUgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IERhdGFTb3VyY2VBcGksIFJlZ2lzdHJ5SXRlbSwgU2VsZWN0YWJsZVZhbHVlIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXIge1xuICBsYWJlbDogc3RyaW5nO1xuICBvcDogc3RyaW5nO1xuICB2YWx1ZTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiB7XG4gIGlkOiBzdHJpbmc7XG4gIHBhcmFtczogUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1WYWx1ZVtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXJ5V2l0aE9wZXJhdGlvbnMge1xuICBvcGVyYXRpb25zOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25bXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWY8VCA9IGFueT4gZXh0ZW5kcyBSZWdpc3RyeUl0ZW0ge1xuICBkb2N1bWVudGF0aW9uPzogc3RyaW5nO1xuICBwYXJhbXM6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmW107XG4gIGRlZmF1bHRQYXJhbXM6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtVmFsdWVbXTtcbiAgY2F0ZWdvcnk6IHN0cmluZztcbiAgaGlkZUZyb21MaXN0PzogYm9vbGVhbjtcbiAgYWx0ZXJuYXRpdmVzS2V5Pzogc3RyaW5nO1xuICAvKiogQ2FuIGJlIHVzZWQgdG8gY29udHJvbCBvcGVyYXRpb24gcGxhY2VtZW50IHdoZW4gYWRkaW5nIGEgbmV3IG9wZXJhdGlvbnMsIGxvd2VyIGFyZSBwbGFjZWQgZmlyc3QgKi9cbiAgb3JkZXJSYW5rPzogbnVtYmVyO1xuICByZW5kZXJlcjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uUmVuZGVyZXI7XG4gIGFkZE9wZXJhdGlvbkhhbmRsZXI6IFF1ZXJ5QnVpbGRlckFkZE9wZXJhdGlvbkhhbmRsZXI8VD47XG4gIHBhcmFtQ2hhbmdlZEhhbmRsZXI/OiBRdWVyeUJ1aWxkZXJPblBhcmFtQ2hhbmdlZEhhbmRsZXI7XG4gIGV4cGxhaW5IYW5kbGVyPzogUXVlcnlCdWlsZGVyRXhwbGFpbk9wZXJhdGlvbkhhbmRsZXI7XG4gIGNoYW5nZVR5cGVIYW5kbGVyPzogKG9wOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sIG5ld0RlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmPFQ+KSA9PiBRdWVyeUJ1aWxkZXJPcGVyYXRpb247XG59XG5cbmV4cG9ydCB0eXBlIFF1ZXJ5QnVpbGRlckFkZE9wZXJhdGlvbkhhbmRsZXI8VD4gPSAoXG4gIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLFxuICBxdWVyeTogVCxcbiAgbW9kZWxsZXI6IFZpc3VhbFF1ZXJ5TW9kZWxsZXJcbikgPT4gVDtcblxuZXhwb3J0IHR5cGUgUXVlcnlCdWlsZGVyRXhwbGFpbk9wZXJhdGlvbkhhbmRsZXIgPSAob3A6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiwgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYpID0+IHN0cmluZztcblxuZXhwb3J0IHR5cGUgUXVlcnlCdWlsZGVyT25QYXJhbUNoYW5nZWRIYW5kbGVyID0gKFxuICBpbmRleDogbnVtYmVyLFxuICBvcGVyYXRpb246IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbixcbiAgb3BlcmF0aW9uRGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWZcbikgPT4gUXVlcnlCdWlsZGVyT3BlcmF0aW9uO1xuXG5leHBvcnQgdHlwZSBRdWVyeUJ1aWxkZXJPcGVyYXRpb25SZW5kZXJlciA9IChcbiAgbW9kZWw6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbixcbiAgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsXG4gIGlubmVyRXhwcjogc3RyaW5nXG4pID0+IHN0cmluZztcblxuZXhwb3J0IHR5cGUgUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1WYWx1ZSA9IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW47XG5cbmV4cG9ydCBpbnRlcmZhY2UgUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1EZWYge1xuICBuYW1lOiBzdHJpbmc7XG4gIHR5cGU6ICdzdHJpbmcnIHwgJ251bWJlcicgfCAnYm9vbGVhbic7XG4gIG9wdGlvbnM/OiBzdHJpbmdbXSB8IG51bWJlcltdIHwgQXJyYXk8U2VsZWN0YWJsZVZhbHVlPHN0cmluZz4+O1xuICBoaWRlTmFtZT86IGJvb2xlYW47XG4gIHJlc3RQYXJhbT86IGJvb2xlYW47XG4gIG9wdGlvbmFsPzogYm9vbGVhbjtcbiAgcGxhY2Vob2xkZXI/OiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICBtaW5XaWR0aD86IG51bWJlcjtcbiAgZWRpdG9yPzogQ29tcG9uZW50VHlwZTxRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbUVkaXRvclByb3BzPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBRdWVyeUJ1aWxkZXJPcGVyYXRpb25FZGl0b3JQcm9wcyB7XG4gIG9wZXJhdGlvbjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uO1xuICBpbmRleDogbnVtYmVyO1xuICBxdWVyeTogYW55O1xuICBkYXRhc291cmNlOiBEYXRhU291cmNlQXBpO1xuICBxdWVyeU1vZGVsbGVyOiBWaXN1YWxRdWVyeU1vZGVsbGVyO1xuICBvbkNoYW5nZTogKGluZGV4OiBudW1iZXIsIHVwZGF0ZTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uKSA9PiB2b2lkO1xuICBvblJlbW92ZTogKGluZGV4OiBudW1iZXIpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1FZGl0b3JQcm9wcyB7XG4gIHZhbHVlPzogUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1WYWx1ZTtcbiAgcGFyYW1EZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmO1xuICAvKiogUGFyYW1ldGVyIGluZGV4ICovXG4gIGluZGV4OiBudW1iZXI7XG4gIG9wZXJhdGlvbjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uO1xuICBvcGVyYXRpb25JbmRleDogbnVtYmVyO1xuICBxdWVyeTogYW55O1xuICBkYXRhc291cmNlOiBEYXRhU291cmNlQXBpO1xuICBvbkNoYW5nZTogKGluZGV4OiBudW1iZXIsIHZhbHVlOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbVZhbHVlKSA9PiB2b2lkO1xuICBvblJ1blF1ZXJ5OiAoKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgZW51bSBRdWVyeUVkaXRvck1vZGUge1xuICBDb2RlID0gJ2NvZGUnLFxuICBCdWlsZGVyID0gJ2J1aWxkZXInLFxuICBFeHBsYWluID0gJ2V4cGxhaW4nLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZpc3VhbFF1ZXJ5TW9kZWxsZXIge1xuICBnZXRPcGVyYXRpb25zRm9yQ2F0ZWdvcnkoY2F0ZWdvcnk6IHN0cmluZyk6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZltdO1xuICBnZXRBbHRlcm5hdGl2ZU9wZXJhdGlvbnMoa2V5OiBzdHJpbmcpOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWZbXTtcbiAgZ2V0Q2F0ZWdvcmllcygpOiBzdHJpbmdbXTtcbiAgZ2V0T3BlcmF0aW9uRGVmKGlkOiBzdHJpbmcpOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYgfCB1bmRlZmluZWQ7XG59XG4iLCJpbXBvcnQgeyBWaXN1YWxRdWVyeUJpbmFyeSB9IGZyb20gJy4vc2hhcmVkL0xva2lBbmRQcm9tUXVlcnlNb2RlbGxlckJhc2UnO1xuaW1wb3J0IHsgUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXIsIFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiB9IGZyb20gJy4vc2hhcmVkL3R5cGVzJztcblxuLyoqXG4gKiBWaXN1YWwgcXVlcnkgbW9kZWxcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQcm9tVmlzdWFsUXVlcnkge1xuICBtZXRyaWM6IHN0cmluZztcbiAgbGFiZWxzOiBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcltdO1xuICBvcGVyYXRpb25zOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25bXTtcbiAgYmluYXJ5UXVlcmllcz86IFByb21WaXN1YWxRdWVyeUJpbmFyeVtdO1xufVxuXG5leHBvcnQgdHlwZSBQcm9tVmlzdWFsUXVlcnlCaW5hcnkgPSBWaXN1YWxRdWVyeUJpbmFyeTxQcm9tVmlzdWFsUXVlcnk+O1xuXG5leHBvcnQgZW51bSBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeSB7XG4gIEFnZ3JlZ2F0aW9ucyA9ICdBZ2dyZWdhdGlvbnMnLFxuICBSYW5nZUZ1bmN0aW9ucyA9ICdSYW5nZSBmdW5jdGlvbnMnLFxuICBGdW5jdGlvbnMgPSAnRnVuY3Rpb25zJyxcbiAgQmluYXJ5T3BzID0gJ0JpbmFyeSBvcGVyYXRpb25zJyxcbiAgVHJpZ29ub21ldHJpYyA9ICdUcmlnb25vbWV0cmljJyxcbiAgVGltZSA9ICdUaW1lIEZ1bmN0aW9ucycsXG59XG5cbmV4cG9ydCBlbnVtIFByb21PcGVyYXRpb25JZCB7XG4gIEFicyA9ICdhYnMnLFxuICBBYnNlbnQgPSAnYWJzZW50JyxcbiAgQWJzZW50T3ZlclRpbWUgPSAnYWJzZW50X292ZXJfdGltZScsXG4gIEFjb3MgPSAnYWNvcycsXG4gIEFjb3NoID0gJ2Fjb3NoJyxcbiAgQXNpbiA9ICdhc2luJyxcbiAgQXNpbmggPSAnYXNpbmgnLFxuICBBdGFuID0gJ2F0YW4nLFxuICBBdGFuaCA9ICdhdGFuaCcsXG4gIEF2ZyA9ICdhdmcnLFxuICBBdmdPdmVyVGltZSA9ICdhdmdfb3Zlcl90aW1lJyxcbiAgQm90dG9tSyA9ICdib3R0b21rJyxcbiAgQ2VpbCA9ICdjZWlsJyxcbiAgQ2hhbmdlcyA9ICdjaGFuZ2VzJyxcbiAgQ2xhbXAgPSAnY2xhbXAnLFxuICBDbGFtcE1heCA9ICdjbGFtcF9tYXgnLFxuICBDbGFtcE1pbiA9ICdjbGFtcF9taW4nLFxuICBDb3MgPSAnY29zJyxcbiAgQ29zaCA9ICdjb3NoJyxcbiAgQ291bnQgPSAnY291bnQnLFxuICBDb3VudE92ZXJUaW1lID0gJ2NvdW50X292ZXJfdGltZScsXG4gIENvdW50U2NhbGFyID0gJ2NvdW50X3NjYWxhcicsXG4gIENvdW50VmFsdWVzID0gJ2NvdW50X3ZhbHVlcycsXG4gIERheU9mTW9udGggPSAnZGF5X29mX21vbnRoJyxcbiAgRGF5T2ZXZWVrID0gJ2RheV9vZl93ZWVrJyxcbiAgRGF5c0luTW9udGggPSAnZGF5c19pbl9tb250aCcsXG4gIERlZyA9ICdkZWcnLFxuICBEZWx0YSA9ICdkZWx0YScsXG4gIERlcml2ID0gJ2Rlcml2JyxcbiAgRHJvcENvbW1vbkxhYmVscyA9ICdkcm9wX2NvbW1vbl9sYWJlbHMnLFxuICBFeHAgPSAnZXhwJyxcbiAgRmxvb3IgPSAnZmxvb3InLFxuICBHcm91cCA9ICdncm91cCcsXG4gIEhpc3RvZ3JhbVF1YW50aWxlID0gJ2hpc3RvZ3JhbV9xdWFudGlsZScsXG4gIEhvbHRXaW50ZXJzID0gJ2hvbHRfd2ludGVycycsXG4gIEhvdXIgPSAnaG91cicsXG4gIElkZWx0YSA9ICdpZGVsdGEnLFxuICBJbmNyZWFzZSA9ICdpbmNyZWFzZScsXG4gIElyYXRlID0gJ2lyYXRlJyxcbiAgTGFiZWxKb2luID0gJ2xhYmVsX2pvaW4nLFxuICBMYWJlbFJlcGxhY2UgPSAnbGFiZWxfcmVwbGFjZScsXG4gIExhc3QgPSAnbGFzdCcsXG4gIExhc3RPdmVyVGltZSA9ICdsYXN0X292ZXJfdGltZScsXG4gIExuID0gJ2xuJyxcbiAgTG9nMTAgPSAnbG9nMTAnLFxuICBMb2cyID0gJ2xvZzInLFxuICBNYXggPSAnbWF4JyxcbiAgTWF4T3ZlclRpbWUgPSAnbWF4X292ZXJfdGltZScsXG4gIE1pbiA9ICdtaW4nLFxuICBNaW5PdmVyVGltZSA9ICdtaW5fb3Zlcl90aW1lJyxcbiAgTWludXRlID0gJ21pbnV0ZScsXG4gIE1vbnRoID0gJ21vbnRoJyxcbiAgUGkgPSAncGknLFxuICBQcmVkaWN0TGluZWFyID0gJ3ByZWRpY3RfbGluZWFyJyxcbiAgUHJlc2VudCA9ICdwcmVzZW50JyxcbiAgUHJlc2VudE92ZXJUaW1lID0gJ3ByZXNlbnRfb3Zlcl90aW1lJyxcbiAgUXVhbnRpbGUgPSAncXVhbnRpbGUnLFxuICBRdWFudGlsZU92ZXJUaW1lID0gJ3F1YW50aWxlX292ZXJfdGltZScsXG4gIFJhZCA9ICdyYWQnLFxuICBSYXRlID0gJ3JhdGUnLFxuICBSZXNldHMgPSAncmVzZXRzJyxcbiAgUm91bmQgPSAncm91bmQnLFxuICBTY2FsYXIgPSAnc2NhbGFyJyxcbiAgU2duID0gJ3NnbicsXG4gIFNpbiA9ICdzaW4nLFxuICBTaW5oID0gJ3NpbmgnLFxuICBTb3J0ID0gJ3NvcnQnLFxuICBTb3J0RGVzYyA9ICdzb3J0X2Rlc2MnLFxuICBTcXJ0ID0gJ3NxcnQnLFxuICBTdGRkZXYgPSAnc3RkZGV2JyxcbiAgU3RkZGV2T3ZlclRpbWUgPSAnc3RkZGV2X292ZXJfdGltZScsXG4gIFN1bSA9ICdzdW0nLFxuICBTdW1PdmVyVGltZSA9ICdzdW1fb3Zlcl90aW1lJyxcbiAgVGFuID0gJ3RhbicsXG4gIFRhbmggPSAndGFuaCcsXG4gIFRpbWUgPSAndGltZScsXG4gIFRpbWVzdGFtcCA9ICd0aW1lc3RhbXAnLFxuICBUb3BLID0gJ3RvcGsnLFxuICBWZWN0b3IgPSAndmVjdG9yJyxcbiAgWWVhciA9ICd5ZWFyJyxcbiAgLy8gQmluYXJ5IG9wc1xuICBBZGRpdGlvbiA9ICdfX2FkZGl0aW9uJyxcbiAgU3VidHJhY3Rpb24gPSAnX19zdWJ0cmFjdGlvbicsXG4gIE11bHRpcGx5QnkgPSAnX19tdWx0aXBseV9ieScsXG4gIERpdmlkZUJ5ID0gJ19fZGl2aWRlX2J5JyxcbiAgTW9kdWxvID0gJ19fbW9kdWxvJyxcbiAgRXhwb25lbnQgPSAnX19leHBvbmVudCcsXG4gIE5lc3RlZFF1ZXJ5ID0gJ19fbmVzdGVkX3F1ZXJ5JyxcbiAgRXF1YWxUbyA9ICdfX2VxdWFsX3RvJyxcbiAgTm90RXF1YWxUbyA9ICdfX25vdF9lcXVhbF90bycsXG4gIEdyZWF0ZXJUaGFuID0gJ19fZ3JlYXRlcl90aGFuJyxcbiAgTGVzc1RoYW4gPSAnX19sZXNzX3RoYW4nLFxuICBHcmVhdGVyT3JFcXVhbCA9ICdfX2dyZWF0ZXJfb3JfZXF1YWwnLFxuICBMZXNzT3JFcXVhbCA9ICdfX2xlc3Nfb3JfZXF1YWwnLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb21RdWVyeVBhdHRlcm4ge1xuICBuYW1lOiBzdHJpbmc7XG4gIG9wZXJhdGlvbnM6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbltdO1xufVxuIiwiaW1wb3J0IHsgZGVzY2VuZGluZywgZGV2aWF0aW9uIH0gZnJvbSAnZDMnO1xuaW1wb3J0IHsgcGFydGl0aW9uLCBncm91cEJ5IH0gZnJvbSAnbG9kYXNoJztcblxuaW1wb3J0IHtcbiAgQXJyYXlEYXRhRnJhbWUsXG4gIEFycmF5VmVjdG9yLFxuICBEYXRhRnJhbWUsXG4gIERhdGFMaW5rLFxuICBEYXRhVG9waWMsXG4gIEZpZWxkLFxuICBGaWVsZFR5cGUsXG4gIGZvcm1hdExhYmVscyxcbiAgZ2V0RGlzcGxheVByb2Nlc3NvcixcbiAgTGFiZWxzLFxuICBNdXRhYmxlRmllbGQsXG4gIFNjb3BlZFZhcnMsXG4gIFRJTUVfU0VSSUVTX1RJTUVfRklFTERfTkFNRSxcbiAgVElNRV9TRVJJRVNfVkFMVUVfRklFTERfTkFNRSxcbiAgRGF0YVF1ZXJ5UmVzcG9uc2UsXG4gIERhdGFRdWVyeVJlcXVlc3QsXG4gIFByZWZlcnJlZFZpc3VhbGlzYXRpb25UeXBlLFxuICBDb3JlQXBwLFxuICBEYXRhRnJhbWVUeXBlLFxufSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IEZldGNoUmVzcG9uc2UsIGdldERhdGFTb3VyY2VTcnYsIGdldFRlbXBsYXRlU3J2IH0gZnJvbSAnQGdyYWZhbmEvcnVudGltZSc7XG5cbmltcG9ydCB7IHJlbmRlckxlZ2VuZEZvcm1hdCB9IGZyb20gJy4vbGVnZW5kJztcbmltcG9ydCB7XG4gIEV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uLFxuICBpc0V4ZW1wbGFyRGF0YSxcbiAgaXNNYXRyaXhEYXRhLFxuICBNYXRyaXhPclZlY3RvclJlc3VsdCxcbiAgUHJvbURhdGFTdWNjZXNzUmVzcG9uc2UsXG4gIFByb21NZXRyaWMsXG4gIFByb21RdWVyeSxcbiAgUHJvbVF1ZXJ5UmVxdWVzdCxcbiAgUHJvbVZhbHVlLFxuICBUcmFuc2Zvcm1PcHRpb25zLFxufSBmcm9tICcuL3R5cGVzJztcblxuLy8gaGFuZGxlcyBjYXNlLWluc2Vuc2l0aXZlIEluZiwgK0luZiwgLUluZiAod2l0aCBvcHRpb25hbCBcImluaXR5XCIgc3VmZml4KVxuY29uc3QgSU5GSU5JVFlfU0FNUExFX1JFR0VYID0gL15bKy1dP2luZig/OmluaXR5KT8kL2k7XG5cbmludGVyZmFjZSBUaW1lQW5kVmFsdWUge1xuICBbVElNRV9TRVJJRVNfVElNRV9GSUVMRF9OQU1FXTogbnVtYmVyO1xuICBbVElNRV9TRVJJRVNfVkFMVUVfRklFTERfTkFNRV06IG51bWJlcjtcbn1cblxuY29uc3QgaXNUYWJsZVJlc3VsdCA9IChkYXRhRnJhbWU6IERhdGFGcmFtZSwgb3B0aW9uczogRGF0YVF1ZXJ5UmVxdWVzdDxQcm9tUXVlcnk+KTogYm9vbGVhbiA9PiB7XG4gIC8vIFdlIHdhbnQgdG8gcHJvY2VzcyB2ZWN0b3IgYW5kIHNjYWxhciByZXN1bHRzIGluIEV4cGxvcmUgYXMgdGFibGVcbiAgaWYgKFxuICAgIG9wdGlvbnMuYXBwID09PSBDb3JlQXBwLkV4cGxvcmUgJiZcbiAgICAoZGF0YUZyYW1lLm1ldGE/LmN1c3RvbT8ucmVzdWx0VHlwZSA9PT0gJ3ZlY3RvcicgfHwgZGF0YUZyYW1lLm1ldGE/LmN1c3RvbT8ucmVzdWx0VHlwZSA9PT0gJ3NjYWxhcicpXG4gICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gV2Ugd2FudCB0byBwcm9jZXNzIGFsbCBkYXRhRnJhbWVzIHdpdGggdGFyZ2V0LmZvcm1hdCA9PT0gJ3RhYmxlJyBhcyB0YWJsZVxuICBjb25zdCB0YXJnZXQgPSBvcHRpb25zLnRhcmdldHMuZmluZCgodGFyZ2V0KSA9PiB0YXJnZXQucmVmSWQgPT09IGRhdGFGcmFtZS5yZWZJZCk7XG4gIHJldHVybiB0YXJnZXQ/LmZvcm1hdCA9PT0gJ3RhYmxlJztcbn07XG5cbmNvbnN0IGlzSGVhdG1hcFJlc3VsdCA9IChkYXRhRnJhbWU6IERhdGFGcmFtZSwgb3B0aW9uczogRGF0YVF1ZXJ5UmVxdWVzdDxQcm9tUXVlcnk+KTogYm9vbGVhbiA9PiB7XG4gIGNvbnN0IHRhcmdldCA9IG9wdGlvbnMudGFyZ2V0cy5maW5kKCh0YXJnZXQpID0+IHRhcmdldC5yZWZJZCA9PT0gZGF0YUZyYW1lLnJlZklkKTtcbiAgcmV0dXJuIHRhcmdldD8uZm9ybWF0ID09PSAnaGVhdG1hcCc7XG59O1xuXG4vLyBWMiByZXN1bHQgdHJhc25mb3JtZXIgdXNlZCB0byB0cmFuc2Zvcm0gcXVlcnkgcmVzdWx0cyBmcm9tIHF1ZXJpZXMgdGhhdCB3ZXJlIHJ1biB0cm91Z2ggcHJvbWV0aGV1cyBiYWNrZW5kXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtVjIoXG4gIHJlc3BvbnNlOiBEYXRhUXVlcnlSZXNwb25zZSxcbiAgcmVxdWVzdDogRGF0YVF1ZXJ5UmVxdWVzdDxQcm9tUXVlcnk+LFxuICBvcHRpb25zOiB7IGV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9ucz86IEV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uW10gfVxuKSB7XG4gIGNvbnN0IFt0YWJsZUZyYW1lcywgZnJhbWVzV2l0aG91dFRhYmxlXSA9IHBhcnRpdGlvbjxEYXRhRnJhbWU+KHJlc3BvbnNlLmRhdGEsIChkZikgPT4gaXNUYWJsZVJlc3VsdChkZiwgcmVxdWVzdCkpO1xuICBjb25zdCBwcm9jZXNzZWRUYWJsZUZyYW1lcyA9IHRyYW5zZm9ybURGVG9UYWJsZSh0YWJsZUZyYW1lcyk7XG5cbiAgY29uc3QgW2V4ZW1wbGFyRnJhbWVzLCBmcmFtZXNXaXRob3V0VGFibGVBbmRFeGVtcGxhcnNdID0gcGFydGl0aW9uPERhdGFGcmFtZT4oXG4gICAgZnJhbWVzV2l0aG91dFRhYmxlLFxuICAgIChkZikgPT4gZGYubWV0YT8uY3VzdG9tPy5yZXN1bHRUeXBlID09PSAnZXhlbXBsYXInXG4gICk7XG5cbiAgLy8gRVhFTVBMQVIgRlJBTUVTOiBXZSBlbnJpY2ggZXhlbXBsYXIgZnJhbWVzIHdpdGggZGF0YSBsaW5rcyBhbmQgYWRkIGRhdGFUb3BpYyBtZXRhIGluZm9cbiAgY29uc3QgeyBleGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbnM6IGRlc3RpbmF0aW9ucyB9ID0gb3B0aW9ucztcbiAgY29uc3QgcHJvY2Vzc2VkRXhlbXBsYXJGcmFtZXMgPSBleGVtcGxhckZyYW1lcy5tYXAoKGRhdGFGcmFtZSkgPT4ge1xuICAgIGlmIChkZXN0aW5hdGlvbnM/Lmxlbmd0aCkge1xuICAgICAgZm9yIChjb25zdCBleGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbiBvZiBkZXN0aW5hdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdHJhY2VJREZpZWxkID0gZGF0YUZyYW1lLmZpZWxkcy5maW5kKChmaWVsZCkgPT4gZmllbGQubmFtZSA9PT0gZXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb24ubmFtZSk7XG4gICAgICAgIGlmICh0cmFjZUlERmllbGQpIHtcbiAgICAgICAgICBjb25zdCBsaW5rcyA9IGdldERhdGFMaW5rcyhleGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbik7XG4gICAgICAgICAgdHJhY2VJREZpZWxkLmNvbmZpZy5saW5rcyA9IHRyYWNlSURGaWVsZC5jb25maWcubGlua3M/Lmxlbmd0aFxuICAgICAgICAgICAgPyBbLi4udHJhY2VJREZpZWxkLmNvbmZpZy5saW5rcywgLi4ubGlua3NdXG4gICAgICAgICAgICA6IGxpbmtzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgLi4uZGF0YUZyYW1lLCBtZXRhOiB7IC4uLmRhdGFGcmFtZS5tZXRhLCBkYXRhVG9waWM6IERhdGFUb3BpYy5Bbm5vdGF0aW9ucyB9IH07XG4gIH0pO1xuXG4gIGNvbnN0IFtoZWF0bWFwUmVzdWx0cywgZnJhbWVzV2l0aG91dFRhYmxlSGVhdG1hcHNBbmRFeGVtcGxhcnNdID0gcGFydGl0aW9uPERhdGFGcmFtZT4oXG4gICAgZnJhbWVzV2l0aG91dFRhYmxlQW5kRXhlbXBsYXJzLFxuICAgIChkZikgPT4gaXNIZWF0bWFwUmVzdWx0KGRmLCByZXF1ZXN0KVxuICApO1xuXG4gIGNvbnN0IHByb2Nlc3NlZEhlYXRtYXBGcmFtZXMgPSBtZXJnZUhlYXRtYXBGcmFtZXMoXG4gICAgdHJhbnNmb3JtVG9IaXN0b2dyYW1PdmVyVGltZShoZWF0bWFwUmVzdWx0cy5zb3J0KHNvcnRTZXJpZXNCeUxhYmVsKSlcbiAgKTtcblxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaXMgcHJvY2Vzc2VkIGFzIHRpbWVfc2VyaWVzIHJlc3VsdCBhbmQgZ3JhcGggcHJlZmVycmVkVmlzdWFsaXNhdGlvblR5cGVcbiAgY29uc3Qgb3RoZXJGcmFtZXMgPSBmcmFtZXNXaXRob3V0VGFibGVIZWF0bWFwc0FuZEV4ZW1wbGFycy5tYXAoKGRhdGFGcmFtZSkgPT4ge1xuICAgIGNvbnN0IGRmID0ge1xuICAgICAgLi4uZGF0YUZyYW1lLFxuICAgICAgbWV0YToge1xuICAgICAgICAuLi5kYXRhRnJhbWUubWV0YSxcbiAgICAgICAgcHJlZmVycmVkVmlzdWFsaXNhdGlvblR5cGU6ICdncmFwaCcsXG4gICAgICB9LFxuICAgIH0gYXMgRGF0YUZyYW1lO1xuICAgIHJldHVybiBkZjtcbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5yZXNwb25zZSxcbiAgICBkYXRhOiBbLi4ub3RoZXJGcmFtZXMsIC4uLnByb2Nlc3NlZFRhYmxlRnJhbWVzLCAuLi5wcm9jZXNzZWRIZWF0bWFwRnJhbWVzLCAuLi5wcm9jZXNzZWRFeGVtcGxhckZyYW1lc10sXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1ERlRvVGFibGUoZGZzOiBEYXRhRnJhbWVbXSk6IERhdGFGcmFtZVtdIHtcbiAgLy8gSWYgbm8gZGF0YUZyYW1lcyBvciBpZiAxIGRhdGFGcmFtZXMgd2l0aCBubyB2YWx1ZXMsIHJldHVybiBvcmlnaW5hbCBkYXRhRnJhbWVcbiAgaWYgKGRmcy5sZW5ndGggPT09IDAgfHwgKGRmcy5sZW5ndGggPT09IDEgJiYgZGZzWzBdLmxlbmd0aCA9PT0gMCkpIHtcbiAgICByZXR1cm4gZGZzO1xuICB9XG5cbiAgLy8gR3JvdXAgcmVzdWx0cyBieSByZWZJZCBhbmQgcHJvY2VzcyBkYXRhRnJhbWVzIHdpdGggdGhlIHNhbWUgcmVmSWQgYXMgMSBkYXRhRnJhbWVcbiAgY29uc3QgZGF0YUZyYW1lc0J5UmVmSWQgPSBncm91cEJ5KGRmcywgJ3JlZklkJyk7XG4gIGNvbnN0IHJlZklkcyA9IE9iamVjdC5rZXlzKGRhdGFGcmFtZXNCeVJlZklkKTtcblxuICBjb25zdCBmcmFtZXMgPSByZWZJZHMubWFwKChyZWZJZCkgPT4ge1xuICAgIC8vIENyZWF0ZSB0aW1lRmllbGQsIHZhbHVlRmllbGQgYW5kIGxhYmVsRmllbGRzXG4gICAgY29uc3QgdmFsdWVUZXh0ID0gZ2V0VmFsdWVUZXh0KHJlZklkcy5sZW5ndGgsIHJlZklkKTtcbiAgICBjb25zdCB2YWx1ZUZpZWxkID0gZ2V0VmFsdWVGaWVsZCh7IGRhdGE6IFtdLCB2YWx1ZU5hbWU6IHZhbHVlVGV4dCB9KTtcbiAgICBjb25zdCB0aW1lRmllbGQgPSBnZXRUaW1lRmllbGQoW10pO1xuICAgIGNvbnN0IGxhYmVsRmllbGRzOiBNdXRhYmxlRmllbGRbXSA9IFtdO1xuXG4gICAgLy8gRmlsbCBsYWJlbHNGaWVsZHMgd2l0aCBsYWJlbHMgZnJvbSBkYXRhRnJhbWVzXG4gICAgZGF0YUZyYW1lc0J5UmVmSWRbcmVmSWRdLmZvckVhY2goKGRmKSA9PiB7XG4gICAgICBjb25zdCBmcmFtZVZhbHVlRmllbGQgPSBkZi5maWVsZHNbMV07XG4gICAgICBjb25zdCBwcm9tTGFiZWxzID0gZnJhbWVWYWx1ZUZpZWxkLmxhYmVscyA/PyB7fTtcblxuICAgICAgT2JqZWN0LmtleXMocHJvbUxhYmVscylcbiAgICAgICAgLnNvcnQoKVxuICAgICAgICAuZm9yRWFjaCgobGFiZWwpID0+IHtcbiAgICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGxhYmVsIGluIGxhYmVsRmllbGRzLCBhZGQgaXRcbiAgICAgICAgICBpZiAoIWxhYmVsRmllbGRzLnNvbWUoKGwpID0+IGwubmFtZSA9PT0gbGFiZWwpKSB7XG4gICAgICAgICAgICBjb25zdCBudW1iZXJGaWVsZCA9IGxhYmVsID09PSAnbGUnO1xuICAgICAgICAgICAgbGFiZWxGaWVsZHMucHVzaCh7XG4gICAgICAgICAgICAgIG5hbWU6IGxhYmVsLFxuICAgICAgICAgICAgICBjb25maWc6IHsgZmlsdGVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICAgICAgICB0eXBlOiBudW1iZXJGaWVsZCA/IEZpZWxkVHlwZS5udW1iZXIgOiBGaWVsZFR5cGUuc3RyaW5nLFxuICAgICAgICAgICAgICB2YWx1ZXM6IG5ldyBBcnJheVZlY3RvcigpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIEZpbGwgdmFsdWVGaWVsZCwgdGltZUZpZWxkIGFuZCBsYWJlbEZpZWxkcyB3aXRoIHZhbHVlc1xuICAgIGRhdGFGcmFtZXNCeVJlZklkW3JlZklkXS5mb3JFYWNoKChkZikgPT4ge1xuICAgICAgZGYuZmllbGRzWzBdLnZhbHVlcy50b0FycmF5KCkuZm9yRWFjaCgodmFsdWUpID0+IHRpbWVGaWVsZC52YWx1ZXMuYWRkKHZhbHVlKSk7XG4gICAgICBkZi5maWVsZHNbMV0udmFsdWVzLnRvQXJyYXkoKS5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgICB2YWx1ZUZpZWxkLnZhbHVlcy5hZGQocGFyc2VTYW1wbGVWYWx1ZSh2YWx1ZSkpO1xuICAgICAgICBjb25zdCBsYWJlbHNGb3JGaWVsZCA9IGRmLmZpZWxkc1sxXS5sYWJlbHMgPz8ge307XG4gICAgICAgIGxhYmVsRmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiBmaWVsZC52YWx1ZXMuYWRkKGdldExhYmVsVmFsdWUobGFiZWxzRm9yRmllbGQsIGZpZWxkLm5hbWUpKSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGZpZWxkcyA9IFt0aW1lRmllbGQsIC4uLmxhYmVsRmllbGRzLCB2YWx1ZUZpZWxkXTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVmSWQsXG4gICAgICBmaWVsZHMsXG4gICAgICBtZXRhOiB7IC4uLmRmc1swXS5tZXRhLCBwcmVmZXJyZWRWaXN1YWxpc2F0aW9uVHlwZTogJ3RhYmxlJyBhcyBQcmVmZXJyZWRWaXN1YWxpc2F0aW9uVHlwZSB9LFxuICAgICAgbGVuZ3RoOiB0aW1lRmllbGQudmFsdWVzLmxlbmd0aCxcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIGZyYW1lcztcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVUZXh0KHJlc3BvbnNlTGVuZ3RoOiBudW1iZXIsIHJlZklkID0gJycpIHtcbiAgcmV0dXJuIHJlc3BvbnNlTGVuZ3RoID4gMSA/IGBWYWx1ZSAjJHtyZWZJZH1gIDogJ1ZhbHVlJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybShcbiAgcmVzcG9uc2U6IEZldGNoUmVzcG9uc2U8UHJvbURhdGFTdWNjZXNzUmVzcG9uc2U+LFxuICB0cmFuc2Zvcm1PcHRpb25zOiB7XG4gICAgcXVlcnk6IFByb21RdWVyeVJlcXVlc3Q7XG4gICAgZXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb25zPzogRXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb25bXTtcbiAgICB0YXJnZXQ6IFByb21RdWVyeTtcbiAgICByZXNwb25zZUxpc3RMZW5ndGg6IG51bWJlcjtcbiAgICBzY29wZWRWYXJzPzogU2NvcGVkVmFycztcbiAgfVxuKSB7XG4gIC8vIENyZWF0ZSBvcHRpb25zIG9iamVjdCBmcm9tIHRyYW5zZm9ybU9wdGlvbnNcbiAgY29uc3Qgb3B0aW9uczogVHJhbnNmb3JtT3B0aW9ucyA9IHtcbiAgICBmb3JtYXQ6IHRyYW5zZm9ybU9wdGlvbnMudGFyZ2V0LmZvcm1hdCxcbiAgICBzdGVwOiB0cmFuc2Zvcm1PcHRpb25zLnF1ZXJ5LnN0ZXAsXG4gICAgbGVnZW5kRm9ybWF0OiB0cmFuc2Zvcm1PcHRpb25zLnRhcmdldC5sZWdlbmRGb3JtYXQsXG4gICAgc3RhcnQ6IHRyYW5zZm9ybU9wdGlvbnMucXVlcnkuc3RhcnQsXG4gICAgZW5kOiB0cmFuc2Zvcm1PcHRpb25zLnF1ZXJ5LmVuZCxcbiAgICBxdWVyeTogdHJhbnNmb3JtT3B0aW9ucy5xdWVyeS5leHByLFxuICAgIHJlc3BvbnNlTGlzdExlbmd0aDogdHJhbnNmb3JtT3B0aW9ucy5yZXNwb25zZUxpc3RMZW5ndGgsXG4gICAgc2NvcGVkVmFyczogdHJhbnNmb3JtT3B0aW9ucy5zY29wZWRWYXJzLFxuICAgIHJlZklkOiB0cmFuc2Zvcm1PcHRpb25zLnRhcmdldC5yZWZJZCxcbiAgICB2YWx1ZVdpdGhSZWZJZDogdHJhbnNmb3JtT3B0aW9ucy50YXJnZXQudmFsdWVXaXRoUmVmSWQsXG4gICAgbWV0YToge1xuICAgICAgLy8gRml4IGZvciBzaG93aW5nIG9mIFByb21ldGhldXMgcmVzdWx0cyBpbiBFeHBsb3JlIHRhYmxlXG4gICAgICBwcmVmZXJyZWRWaXN1YWxpc2F0aW9uVHlwZTogdHJhbnNmb3JtT3B0aW9ucy5xdWVyeS5pbnN0YW50ID8gJ3RhYmxlJyA6ICdncmFwaCcsXG4gICAgfSxcbiAgfTtcbiAgY29uc3QgcHJvbWV0aGV1c1Jlc3VsdCA9IHJlc3BvbnNlLmRhdGEuZGF0YTtcblxuICBpZiAoaXNFeGVtcGxhckRhdGEocHJvbWV0aGV1c1Jlc3VsdCkpIHtcbiAgICBjb25zdCBldmVudHM6IFRpbWVBbmRWYWx1ZVtdID0gW107XG4gICAgcHJvbWV0aGV1c1Jlc3VsdC5mb3JFYWNoKChleGVtcGxhckRhdGEpID0+IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBleGVtcGxhckRhdGEuZXhlbXBsYXJzLm1hcCgoZXhlbXBsYXIpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBbVElNRV9TRVJJRVNfVElNRV9GSUVMRF9OQU1FXTogZXhlbXBsYXIudGltZXN0YW1wICogMTAwMCxcbiAgICAgICAgICBbVElNRV9TRVJJRVNfVkFMVUVfRklFTERfTkFNRV06IGV4ZW1wbGFyLnZhbHVlLFxuICAgICAgICAgIC4uLmV4ZW1wbGFyLmxhYmVscyxcbiAgICAgICAgICAuLi5leGVtcGxhckRhdGEuc2VyaWVzTGFiZWxzLFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICBldmVudHMucHVzaCguLi5kYXRhKTtcbiAgICB9KTtcblxuICAgIC8vIEdyb3VwaW5nIGV4ZW1wbGFycyBieSBzdGVwXG4gICAgY29uc3Qgc2FtcGxlZEV4ZW1wbGFycyA9IHNhbXBsZUV4ZW1wbGFycyhldmVudHMsIG9wdGlvbnMpO1xuXG4gICAgY29uc3QgZGF0YUZyYW1lID0gbmV3IEFycmF5RGF0YUZyYW1lKHNhbXBsZWRFeGVtcGxhcnMpO1xuICAgIGRhdGFGcmFtZS5tZXRhID0geyBkYXRhVG9waWM6IERhdGFUb3BpYy5Bbm5vdGF0aW9ucyB9O1xuXG4gICAgLy8gQWRkIGRhdGEgbGlua3MgaWYgY29uZmlndXJlZFxuICAgIGlmICh0cmFuc2Zvcm1PcHRpb25zLmV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9ucz8ubGVuZ3RoKSB7XG4gICAgICBmb3IgKGNvbnN0IGV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uIG9mIHRyYW5zZm9ybU9wdGlvbnMuZXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb25zKSB7XG4gICAgICAgIGNvbnN0IHRyYWNlSURGaWVsZCA9IGRhdGFGcmFtZS5maWVsZHMuZmluZCgoZmllbGQpID0+IGZpZWxkLm5hbWUgPT09IGV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uLm5hbWUpO1xuICAgICAgICBpZiAodHJhY2VJREZpZWxkKSB7XG4gICAgICAgICAgY29uc3QgbGlua3MgPSBnZXREYXRhTGlua3MoZXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb24pO1xuICAgICAgICAgIHRyYWNlSURGaWVsZC5jb25maWcubGlua3MgPSB0cmFjZUlERmllbGQuY29uZmlnLmxpbmtzPy5sZW5ndGhcbiAgICAgICAgICAgID8gWy4uLnRyYWNlSURGaWVsZC5jb25maWcubGlua3MsIC4uLmxpbmtzXVxuICAgICAgICAgICAgOiBsaW5rcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW2RhdGFGcmFtZV07XG4gIH1cblxuICBpZiAoIXByb21ldGhldXNSZXN1bHQ/LnJlc3VsdCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIC8vIFJldHVybiBlYXJseSBpZiByZXN1bHQgdHlwZSBpcyBzY2FsYXJcbiAgaWYgKHByb21ldGhldXNSZXN1bHQucmVzdWx0VHlwZSA9PT0gJ3NjYWxhcicpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICBtZXRhOiBvcHRpb25zLm1ldGEsXG4gICAgICAgIHJlZklkOiBvcHRpb25zLnJlZklkLFxuICAgICAgICBsZW5ndGg6IDEsXG4gICAgICAgIGZpZWxkczogW2dldFRpbWVGaWVsZChbcHJvbWV0aGV1c1Jlc3VsdC5yZXN1bHRdKSwgZ2V0VmFsdWVGaWVsZCh7IGRhdGE6IFtwcm9tZXRoZXVzUmVzdWx0LnJlc3VsdF0gfSldLFxuICAgICAgfSxcbiAgICBdO1xuICB9XG5cbiAgLy8gUmV0dXJuIGVhcmx5IGFnYWluIGlmIHRoZSBmb3JtYXQgaXMgdGFibGUsIHRoaXMgbmVlZHMgc3BlY2lhbCB0cmFuc2Zvcm1hdGlvbi5cbiAgaWYgKG9wdGlvbnMuZm9ybWF0ID09PSAndGFibGUnKSB7XG4gICAgY29uc3QgdGFibGVEYXRhID0gdHJhbnNmb3JtTWV0cmljRGF0YVRvVGFibGUocHJvbWV0aGV1c1Jlc3VsdC5yZXN1bHQsIG9wdGlvbnMpO1xuICAgIHJldHVybiBbdGFibGVEYXRhXTtcbiAgfVxuXG4gIC8vIFByb2Nlc3MgbWF0cml4IGFuZCB2ZWN0b3IgcmVzdWx0cyB0byBEYXRhRnJhbWVcbiAgY29uc3QgZGF0YUZyYW1lOiBEYXRhRnJhbWVbXSA9IFtdO1xuICBwcm9tZXRoZXVzUmVzdWx0LnJlc3VsdC5mb3JFYWNoKChkYXRhOiBNYXRyaXhPclZlY3RvclJlc3VsdCkgPT4gZGF0YUZyYW1lLnB1c2godHJhbnNmb3JtVG9EYXRhRnJhbWUoZGF0YSwgb3B0aW9ucykpKTtcblxuICAvLyBXaGVuIGZvcm1hdCBpcyBoZWF0bWFwIHVzZSB0aGUgYWxyZWFkeSBjcmVhdGVkIGRhdGEgZnJhbWVzIGFuZCB0cmFuc2Zvcm0gaXQgbW9yZVxuICBpZiAob3B0aW9ucy5mb3JtYXQgPT09ICdoZWF0bWFwJykge1xuICAgIHJldHVybiBtZXJnZUhlYXRtYXBGcmFtZXModHJhbnNmb3JtVG9IaXN0b2dyYW1PdmVyVGltZShkYXRhRnJhbWUuc29ydChzb3J0U2VyaWVzQnlMYWJlbCkpKTtcbiAgfVxuXG4gIC8vIFJldHVybiBtYXRyaXggb3IgdmVjdG9yIHJlc3VsdCBhcyBEYXRhRnJhbWVbXVxuICByZXR1cm4gZGF0YUZyYW1lO1xufVxuXG5mdW5jdGlvbiBnZXREYXRhTGlua3Mob3B0aW9uczogRXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb24pOiBEYXRhTGlua1tdIHtcbiAgY29uc3QgZGF0YUxpbmtzOiBEYXRhTGlua1tdID0gW107XG5cbiAgaWYgKG9wdGlvbnMuZGF0YXNvdXJjZVVpZCkge1xuICAgIGNvbnN0IGRhdGFTb3VyY2VTcnYgPSBnZXREYXRhU291cmNlU3J2KCk7XG4gICAgY29uc3QgZHNTZXR0aW5ncyA9IGRhdGFTb3VyY2VTcnYuZ2V0SW5zdGFuY2VTZXR0aW5ncyhvcHRpb25zLmRhdGFzb3VyY2VVaWQpO1xuXG4gICAgZGF0YUxpbmtzLnB1c2goe1xuICAgICAgdGl0bGU6IG9wdGlvbnMudXJsRGlzcGxheUxhYmVsIHx8IGBRdWVyeSB3aXRoICR7ZHNTZXR0aW5ncz8ubmFtZX1gLFxuICAgICAgdXJsOiAnJyxcbiAgICAgIGludGVybmFsOiB7XG4gICAgICAgIHF1ZXJ5OiB7IHF1ZXJ5OiAnJHtfX3ZhbHVlLnJhd30nLCBxdWVyeVR5cGU6ICd0cmFjZUlkJyB9LFxuICAgICAgICBkYXRhc291cmNlVWlkOiBvcHRpb25zLmRhdGFzb3VyY2VVaWQsXG4gICAgICAgIGRhdGFzb3VyY2VOYW1lOiBkc1NldHRpbmdzPy5uYW1lID8/ICdEYXRhIHNvdXJjZSBub3QgZm91bmQnLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLnVybCkge1xuICAgIGRhdGFMaW5rcy5wdXNoKHtcbiAgICAgIHRpdGxlOiBvcHRpb25zLnVybERpc3BsYXlMYWJlbCB8fCBgR28gdG8gJHtvcHRpb25zLnVybH1gLFxuICAgICAgdXJsOiBvcHRpb25zLnVybCxcbiAgICAgIHRhcmdldEJsYW5rOiB0cnVlLFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBkYXRhTGlua3M7XG59XG5cbi8qKlxuICogUmVkdWNlIHRoZSBkZW5zaXR5IG9mIHRoZSBleGVtcGxhcnMgYnkgbWFraW5nIHN1cmUgdGhhdCB0aGUgaGlnaGVzdCB2YWx1ZSBleGVtcGxhciBpcyBpbmNsdWRlZFxuICogYW5kIHRoZW4gb25seSB0aGUgb25lcyB0aGF0IGFyZSAyIHRpbWVzIHRoZSBzdGFuZGFyZCBkZXZpYXRpb24gb2YgdGhlIGFsbCB0aGUgdmFsdWVzLlxuICogVGhpcyBtYWtlcyBzdXJlIG5vdCB0byBzaG93IHRvbyBtYW55IGRvdHMgbmVhciBlYWNoIG90aGVyLlxuICovXG5mdW5jdGlvbiBzYW1wbGVFeGVtcGxhcnMoZXZlbnRzOiBUaW1lQW5kVmFsdWVbXSwgb3B0aW9uczogVHJhbnNmb3JtT3B0aW9ucykge1xuICBjb25zdCBzdGVwID0gb3B0aW9ucy5zdGVwIHx8IDE1O1xuICBjb25zdCBidWNrZXRlZEV4ZW1wbGFyczogeyBbdHM6IHN0cmluZ106IFRpbWVBbmRWYWx1ZVtdIH0gPSB7fTtcbiAgY29uc3QgdmFsdWVzOiBudW1iZXJbXSA9IFtdO1xuICBmb3IgKGNvbnN0IGV4ZW1wbGFyIG9mIGV2ZW50cykge1xuICAgIC8vIEFsaWduIGV4ZW1wbGFyIHRpbWVzdGFtcCB0byBuZWFyZXN0IHN0ZXAgc2Vjb25kXG4gICAgY29uc3QgYWxpZ25lZFRzID0gU3RyaW5nKE1hdGguZmxvb3IoZXhlbXBsYXJbVElNRV9TRVJJRVNfVElNRV9GSUVMRF9OQU1FXSAvIDEwMDAgLyBzdGVwKSAqIHN0ZXAgKiAxMDAwKTtcbiAgICBpZiAoIWJ1Y2tldGVkRXhlbXBsYXJzW2FsaWduZWRUc10pIHtcbiAgICAgIC8vIE5ldyBidWNrZXQgZm91bmRcbiAgICAgIGJ1Y2tldGVkRXhlbXBsYXJzW2FsaWduZWRUc10gPSBbXTtcbiAgICB9XG4gICAgYnVja2V0ZWRFeGVtcGxhcnNbYWxpZ25lZFRzXS5wdXNoKGV4ZW1wbGFyKTtcbiAgICB2YWx1ZXMucHVzaChleGVtcGxhcltUSU1FX1NFUklFU19WQUxVRV9GSUVMRF9OQU1FXSk7XG4gIH1cblxuICAvLyBHZXR0aW5nIGV4ZW1wbGFycyBmcm9tIGVhY2ggYnVja2V0XG4gIGNvbnN0IHN0YW5kYXJkRGV2aWF0aW9uID0gZGV2aWF0aW9uKHZhbHVlcyk7XG4gIGNvbnN0IHNhbXBsZWRCdWNrZXRzID0gT2JqZWN0LmtleXMoYnVja2V0ZWRFeGVtcGxhcnMpLnNvcnQoKTtcbiAgY29uc3Qgc2FtcGxlZEV4ZW1wbGFycyA9IFtdO1xuICBmb3IgKGNvbnN0IHRzIG9mIHNhbXBsZWRCdWNrZXRzKSB7XG4gICAgY29uc3QgZXhlbXBsYXJzSW5CdWNrZXQgPSBidWNrZXRlZEV4ZW1wbGFyc1t0c107XG4gICAgaWYgKGV4ZW1wbGFyc0luQnVja2V0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgc2FtcGxlZEV4ZW1wbGFycy5wdXNoKGV4ZW1wbGFyc0luQnVja2V0WzBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2hvb3NlIHdoaWNoIHZhbHVlcyB0byBzYW1wbGVcbiAgICAgIGNvbnN0IGJ1Y2tldFZhbHVlcyA9IGV4ZW1wbGFyc0luQnVja2V0Lm1hcCgoZXgpID0+IGV4W1RJTUVfU0VSSUVTX1ZBTFVFX0ZJRUxEX05BTUVdKS5zb3J0KGRlc2NlbmRpbmcpO1xuICAgICAgY29uc3Qgc2FtcGxlZEJ1Y2tldFZhbHVlcyA9IGJ1Y2tldFZhbHVlcy5yZWR1Y2UoKGFjYzogbnVtYmVyW10sIGN1cnIpID0+IHtcbiAgICAgICAgaWYgKGFjYy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAvLyBGaXJzdCB2YWx1ZSBpcyBtYXggYW5kIGlzIGFsd2F5cyBhZGRlZFxuICAgICAgICAgIGFjYy5wdXNoKGN1cnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoZW4gdGFrZSB2YWx1ZXMgb25seSB3aGVuIGF0IGxlYXN0IDIgc3RhbmRhcmQgZGV2aWF0aW9uIGRpc3RhbmNlIHRvIHByZXZpb3VzbHkgdGFrZW4gdmFsdWVcbiAgICAgICAgICBjb25zdCBwcmV2ID0gYWNjW2FjYy5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpZiAoc3RhbmRhcmREZXZpYXRpb24gJiYgcHJldiAtIGN1cnIgPj0gMiAqIHN0YW5kYXJkRGV2aWF0aW9uKSB7XG4gICAgICAgICAgICBhY2MucHVzaChjdXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sIFtdKTtcbiAgICAgIC8vIEZpbmQgdGhlIGV4ZW1wbGFycyBmb3IgdGhlIHNhbXBsZWQgdmFsdWVzXG4gICAgICBzYW1wbGVkRXhlbXBsYXJzLnB1c2goXG4gICAgICAgIC4uLnNhbXBsZWRCdWNrZXRWYWx1ZXMubWFwKFxuICAgICAgICAgICh2YWx1ZSkgPT4gZXhlbXBsYXJzSW5CdWNrZXQuZmluZCgoZXgpID0+IGV4W1RJTUVfU0VSSUVTX1ZBTFVFX0ZJRUxEX05BTUVdID09PSB2YWx1ZSkhXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzYW1wbGVkRXhlbXBsYXJzO1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgbWF0cml4IGFuZCB2ZWN0b3IgcmVzdWx0IGZyb20gUHJvbWV0aGV1cyByZXN1bHQgdG8gRGF0YUZyYW1lXG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybVRvRGF0YUZyYW1lKGRhdGE6IE1hdHJpeE9yVmVjdG9yUmVzdWx0LCBvcHRpb25zOiBUcmFuc2Zvcm1PcHRpb25zKTogRGF0YUZyYW1lIHtcbiAgY29uc3QgeyBuYW1lLCBsYWJlbHMgfSA9IGNyZWF0ZUxhYmVsSW5mbyhkYXRhLm1ldHJpYywgb3B0aW9ucyk7XG5cbiAgY29uc3QgZmllbGRzOiBGaWVsZFtdID0gW107XG5cbiAgaWYgKGlzTWF0cml4RGF0YShkYXRhKSkge1xuICAgIGNvbnN0IHN0ZXBNcyA9IG9wdGlvbnMuc3RlcCA/IG9wdGlvbnMuc3RlcCAqIDEwMDAgOiBOYU47XG4gICAgbGV0IGJhc2VUaW1lc3RhbXAgPSBvcHRpb25zLnN0YXJ0ICogMTAwMDtcbiAgICBjb25zdCBkcHM6IFByb21WYWx1ZVtdID0gW107XG5cbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGRhdGEudmFsdWVzKSB7XG4gICAgICBsZXQgZHBWYWx1ZTogbnVtYmVyIHwgbnVsbCA9IHBhcnNlU2FtcGxlVmFsdWUodmFsdWVbMV0pO1xuXG4gICAgICBpZiAoaXNOYU4oZHBWYWx1ZSkpIHtcbiAgICAgICAgZHBWYWx1ZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IHZhbHVlWzBdICogMTAwMDtcbiAgICAgIGZvciAobGV0IHQgPSBiYXNlVGltZXN0YW1wOyB0IDwgdGltZXN0YW1wOyB0ICs9IHN0ZXBNcykge1xuICAgICAgICBkcHMucHVzaChbdCwgbnVsbF0pO1xuICAgICAgfVxuICAgICAgYmFzZVRpbWVzdGFtcCA9IHRpbWVzdGFtcCArIHN0ZXBNcztcbiAgICAgIGRwcy5wdXNoKFt0aW1lc3RhbXAsIGRwVmFsdWVdKTtcbiAgICB9XG5cbiAgICBjb25zdCBlbmRUaW1lc3RhbXAgPSBvcHRpb25zLmVuZCAqIDEwMDA7XG4gICAgZm9yIChsZXQgdCA9IGJhc2VUaW1lc3RhbXA7IHQgPD0gZW5kVGltZXN0YW1wOyB0ICs9IHN0ZXBNcykge1xuICAgICAgZHBzLnB1c2goW3QsIG51bGxdKTtcbiAgICB9XG4gICAgZmllbGRzLnB1c2goZ2V0VGltZUZpZWxkKGRwcywgdHJ1ZSkpO1xuICAgIGZpZWxkcy5wdXNoKGdldFZhbHVlRmllbGQoeyBkYXRhOiBkcHMsIHBhcnNlVmFsdWU6IGZhbHNlLCBsYWJlbHMsIGRpc3BsYXlOYW1lRnJvbURTOiBuYW1lIH0pKTtcbiAgfSBlbHNlIHtcbiAgICBmaWVsZHMucHVzaChnZXRUaW1lRmllbGQoW2RhdGEudmFsdWVdKSk7XG4gICAgZmllbGRzLnB1c2goZ2V0VmFsdWVGaWVsZCh7IGRhdGE6IFtkYXRhLnZhbHVlXSwgbGFiZWxzLCBkaXNwbGF5TmFtZUZyb21EUzogbmFtZSB9KSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1ldGE6IG9wdGlvbnMubWV0YSxcbiAgICByZWZJZDogb3B0aW9ucy5yZWZJZCxcbiAgICBsZW5ndGg6IGZpZWxkc1swXS52YWx1ZXMubGVuZ3RoLFxuICAgIGZpZWxkcyxcbiAgICBuYW1lLFxuICB9O1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1NZXRyaWNEYXRhVG9UYWJsZShtZDogTWF0cml4T3JWZWN0b3JSZXN1bHRbXSwgb3B0aW9uczogVHJhbnNmb3JtT3B0aW9ucyk6IERhdGFGcmFtZSB7XG4gIGlmICghbWQgfHwgbWQubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1ldGE6IG9wdGlvbnMubWV0YSxcbiAgICAgIHJlZklkOiBvcHRpb25zLnJlZklkLFxuICAgICAgbGVuZ3RoOiAwLFxuICAgICAgZmllbGRzOiBbXSxcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgdmFsdWVUZXh0ID0gb3B0aW9ucy5yZXNwb25zZUxpc3RMZW5ndGggPiAxIHx8IG9wdGlvbnMudmFsdWVXaXRoUmVmSWQgPyBgVmFsdWUgIyR7b3B0aW9ucy5yZWZJZH1gIDogJ1ZhbHVlJztcblxuICBjb25zdCB0aW1lRmllbGQgPSBnZXRUaW1lRmllbGQoW10pO1xuICBjb25zdCBtZXRyaWNGaWVsZHMgPSBPYmplY3Qua2V5cyhtZC5yZWR1Y2UoKGFjYywgc2VyaWVzKSA9PiAoeyAuLi5hY2MsIC4uLnNlcmllcy5tZXRyaWMgfSksIHt9KSlcbiAgICAuc29ydCgpXG4gICAgLm1hcCgobGFiZWwpID0+IHtcbiAgICAgIC8vIExhYmVscyBoYXZlIHN0cmluZyBmaWVsZCB0eXBlLCBvdGhlcndpc2UgdGFibGUgdHJpZXMgdG8gZmlndXJlIG91dCB0aGUgdHlwZSB3aGljaCBjYW4gcmVzdWx0IGluIHVuZXhwZWN0ZWQgcmVzdWx0c1xuICAgICAgLy8gT25seSBcImxlXCIgbGFiZWwgaGFzIGEgbnVtYmVyIGZpZWxkIHR5cGVcbiAgICAgIGNvbnN0IG51bWJlckZpZWxkID0gbGFiZWwgPT09ICdsZSc7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBsYWJlbCxcbiAgICAgICAgY29uZmlnOiB7IGZpbHRlcmFibGU6IHRydWUgfSxcbiAgICAgICAgdHlwZTogbnVtYmVyRmllbGQgPyBGaWVsZFR5cGUubnVtYmVyIDogRmllbGRUeXBlLnN0cmluZyxcbiAgICAgICAgdmFsdWVzOiBuZXcgQXJyYXlWZWN0b3IoKSxcbiAgICAgIH07XG4gICAgfSk7XG4gIGNvbnN0IHZhbHVlRmllbGQgPSBnZXRWYWx1ZUZpZWxkKHsgZGF0YTogW10sIHZhbHVlTmFtZTogdmFsdWVUZXh0IH0pO1xuXG4gIG1kLmZvckVhY2goKGQpID0+IHtcbiAgICBpZiAoaXNNYXRyaXhEYXRhKGQpKSB7XG4gICAgICBkLnZhbHVlcy5mb3JFYWNoKCh2YWwpID0+IHtcbiAgICAgICAgdGltZUZpZWxkLnZhbHVlcy5hZGQodmFsWzBdICogMTAwMCk7XG4gICAgICAgIG1ldHJpY0ZpZWxkcy5mb3JFYWNoKChtZXRyaWNGaWVsZCkgPT4gbWV0cmljRmllbGQudmFsdWVzLmFkZChnZXRMYWJlbFZhbHVlKGQubWV0cmljLCBtZXRyaWNGaWVsZC5uYW1lKSkpO1xuICAgICAgICB2YWx1ZUZpZWxkLnZhbHVlcy5hZGQocGFyc2VTYW1wbGVWYWx1ZSh2YWxbMV0pKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aW1lRmllbGQudmFsdWVzLmFkZChkLnZhbHVlWzBdICogMTAwMCk7XG4gICAgICBtZXRyaWNGaWVsZHMuZm9yRWFjaCgobWV0cmljRmllbGQpID0+IG1ldHJpY0ZpZWxkLnZhbHVlcy5hZGQoZ2V0TGFiZWxWYWx1ZShkLm1ldHJpYywgbWV0cmljRmllbGQubmFtZSkpKTtcbiAgICAgIHZhbHVlRmllbGQudmFsdWVzLmFkZChwYXJzZVNhbXBsZVZhbHVlKGQudmFsdWVbMV0pKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgbWV0YTogb3B0aW9ucy5tZXRhLFxuICAgIHJlZklkOiBvcHRpb25zLnJlZklkLFxuICAgIGxlbmd0aDogdGltZUZpZWxkLnZhbHVlcy5sZW5ndGgsXG4gICAgZmllbGRzOiBbdGltZUZpZWxkLCAuLi5tZXRyaWNGaWVsZHMsIHZhbHVlRmllbGRdLFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRMYWJlbFZhbHVlKG1ldHJpYzogUHJvbU1ldHJpYywgbGFiZWw6IHN0cmluZyk6IHN0cmluZyB8IG51bWJlciB7XG4gIGlmIChtZXRyaWMuaGFzT3duUHJvcGVydHkobGFiZWwpKSB7XG4gICAgaWYgKGxhYmVsID09PSAnbGUnKSB7XG4gICAgICByZXR1cm4gcGFyc2VTYW1wbGVWYWx1ZShtZXRyaWNbbGFiZWxdKTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldHJpY1tsYWJlbF07XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBnZXRUaW1lRmllbGQoZGF0YTogUHJvbVZhbHVlW10sIGlzTXMgPSBmYWxzZSk6IE11dGFibGVGaWVsZCB7XG4gIHJldHVybiB7XG4gICAgbmFtZTogVElNRV9TRVJJRVNfVElNRV9GSUVMRF9OQU1FLFxuICAgIHR5cGU6IEZpZWxkVHlwZS50aW1lLFxuICAgIGNvbmZpZzoge30sXG4gICAgdmFsdWVzOiBuZXcgQXJyYXlWZWN0b3I8bnVtYmVyPihkYXRhLm1hcCgodmFsKSA9PiAoaXNNcyA/IHZhbFswXSA6IHZhbFswXSAqIDEwMDApKSksXG4gIH07XG59XG50eXBlIFZhbHVlRmllbGRPcHRpb25zID0ge1xuICBkYXRhOiBQcm9tVmFsdWVbXTtcbiAgdmFsdWVOYW1lPzogc3RyaW5nO1xuICBwYXJzZVZhbHVlPzogYm9vbGVhbjtcbiAgbGFiZWxzPzogTGFiZWxzO1xuICBkaXNwbGF5TmFtZUZyb21EUz86IHN0cmluZztcbn07XG5cbmZ1bmN0aW9uIGdldFZhbHVlRmllbGQoe1xuICBkYXRhLFxuICB2YWx1ZU5hbWUgPSBUSU1FX1NFUklFU19WQUxVRV9GSUVMRF9OQU1FLFxuICBwYXJzZVZhbHVlID0gdHJ1ZSxcbiAgbGFiZWxzLFxuICBkaXNwbGF5TmFtZUZyb21EUyxcbn06IFZhbHVlRmllbGRPcHRpb25zKTogTXV0YWJsZUZpZWxkIHtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiB2YWx1ZU5hbWUsXG4gICAgdHlwZTogRmllbGRUeXBlLm51bWJlcixcbiAgICBkaXNwbGF5OiBnZXREaXNwbGF5UHJvY2Vzc29yKCksXG4gICAgY29uZmlnOiB7XG4gICAgICBkaXNwbGF5TmFtZUZyb21EUyxcbiAgICB9LFxuICAgIGxhYmVscyxcbiAgICB2YWx1ZXM6IG5ldyBBcnJheVZlY3RvcjxudW1iZXIgfCBudWxsPihkYXRhLm1hcCgodmFsKSA9PiAocGFyc2VWYWx1ZSA/IHBhcnNlU2FtcGxlVmFsdWUodmFsWzFdKSA6IHZhbFsxXSkpKSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGFiZWxJbmZvKGxhYmVsczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSwgb3B0aW9uczogVHJhbnNmb3JtT3B0aW9ucykge1xuICBpZiAob3B0aW9ucz8ubGVnZW5kRm9ybWF0KSB7XG4gICAgY29uc3QgdGl0bGUgPSByZW5kZXJMZWdlbmRGb3JtYXQoZ2V0VGVtcGxhdGVTcnYoKS5yZXBsYWNlKG9wdGlvbnMubGVnZW5kRm9ybWF0LCBvcHRpb25zPy5zY29wZWRWYXJzKSwgbGFiZWxzKTtcbiAgICByZXR1cm4geyBuYW1lOiB0aXRsZSwgbGFiZWxzIH07XG4gIH1cblxuICBjb25zdCB7IF9fbmFtZV9fLCAuLi5sYWJlbHNXaXRob3V0TmFtZSB9ID0gbGFiZWxzO1xuICBjb25zdCBsYWJlbFBhcnQgPSBmb3JtYXRMYWJlbHMobGFiZWxzV2l0aG91dE5hbWUpO1xuICBsZXQgdGl0bGUgPSBgJHtfX25hbWVfXyA/PyAnJ30ke2xhYmVsUGFydH1gO1xuXG4gIGlmICghdGl0bGUpIHtcbiAgICB0aXRsZSA9IG9wdGlvbnMucXVlcnk7XG4gIH1cblxuICByZXR1cm4geyBuYW1lOiB0aXRsZSwgbGFiZWxzOiBsYWJlbHNXaXRob3V0TmFtZSB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0T3JpZ2luYWxNZXRyaWNOYW1lKGxhYmVsRGF0YTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSkge1xuICBjb25zdCBtZXRyaWNOYW1lID0gbGFiZWxEYXRhLl9fbmFtZV9fIHx8ICcnO1xuICBkZWxldGUgbGFiZWxEYXRhLl9fbmFtZV9fO1xuICBjb25zdCBsYWJlbFBhcnQgPSBPYmplY3QuZW50cmllcyhsYWJlbERhdGEpXG4gICAgLm1hcCgobGFiZWwpID0+IGAke2xhYmVsWzBdfT1cIiR7bGFiZWxbMV19XCJgKVxuICAgIC5qb2luKCcsJyk7XG4gIHJldHVybiBgJHttZXRyaWNOYW1lfXske2xhYmVsUGFydH19YDtcbn1cblxuZnVuY3Rpb24gbWVyZ2VIZWF0bWFwRnJhbWVzKGZyYW1lczogRGF0YUZyYW1lW10pOiBEYXRhRnJhbWVbXSB7XG4gIGlmIChmcmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgY29uc3QgdGltZUZpZWxkID0gZnJhbWVzWzBdLmZpZWxkcy5maW5kKChmaWVsZCkgPT4gZmllbGQudHlwZSA9PT0gRmllbGRUeXBlLnRpbWUpITtcbiAgY29uc3QgY291bnRGaWVsZHMgPSBmcmFtZXMubWFwKChmcmFtZSkgPT4ge1xuICAgIGxldCBmaWVsZCA9IGZyYW1lLmZpZWxkcy5maW5kKChmaWVsZCkgPT4gZmllbGQudHlwZSA9PT0gRmllbGRUeXBlLm51bWJlcikhO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmZpZWxkLFxuICAgICAgbmFtZTogZmllbGQuY29uZmlnLmRpc3BsYXlOYW1lRnJvbURTISxcbiAgICB9O1xuICB9KTtcblxuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIC4uLmZyYW1lc1swXSxcbiAgICAgIG1ldGE6IHtcbiAgICAgICAgLi4uZnJhbWVzWzBdLm1ldGEsXG4gICAgICAgIHR5cGU6IERhdGFGcmFtZVR5cGUuSGVhdG1hcEJ1Y2tldHMsXG4gICAgICB9LFxuICAgICAgZmllbGRzOiBbdGltZUZpZWxkISwgLi4uY291bnRGaWVsZHNdLFxuICAgIH0sXG4gIF07XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVRvSGlzdG9ncmFtT3ZlclRpbWUoc2VyaWVzTGlzdDogRGF0YUZyYW1lW10pIHtcbiAgLyogICAgICB0MSA9IHRpbWVzdGFtcDEsIHQyID0gdGltZXN0YW1wMiBldGMuXG4gICAgICAgICAgICB0MSAgdDIgIHQzICAgICAgICAgIHQxICB0MiAgdDNcbiAgICBsZTEwICAgIDEwICAxMCAgMCAgICAgPT4gICAgMTAgIDEwICAwXG4gICAgbGUyMCAgICAyMCAgMTAgIDMwICAgID0+ICAgIDEwICAwICAgMzBcbiAgICBsZTMwICAgIDMwICAxMCAgMzUgICAgPT4gICAgMTAgIDAgICA1XG4gICAgKi9cbiAgZm9yIChsZXQgaSA9IHNlcmllc0xpc3QubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuICAgIGNvbnN0IHRvcFNlcmllcyA9IHNlcmllc0xpc3RbaV0uZmllbGRzLmZpbmQoKHMpID0+IHMubmFtZSA9PT0gVElNRV9TRVJJRVNfVkFMVUVfRklFTERfTkFNRSk7XG4gICAgY29uc3QgYm90dG9tU2VyaWVzID0gc2VyaWVzTGlzdFtpIC0gMV0uZmllbGRzLmZpbmQoKHMpID0+IHMubmFtZSA9PT0gVElNRV9TRVJJRVNfVkFMVUVfRklFTERfTkFNRSk7XG4gICAgaWYgKCF0b3BTZXJpZXMgfHwgIWJvdHRvbVNlcmllcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9tZXRoZXVzIGhlYXRtYXAgdHJhbnNmb3JtIGVycm9yOiBkYXRhIHNob3VsZCBiZSBhIHRpbWUgc2VyaWVzJyk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB0b3BTZXJpZXMudmFsdWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICBjb25zdCBib3R0b21Qb2ludCA9IGJvdHRvbVNlcmllcy52YWx1ZXMuZ2V0KGopIHx8IFswXTtcbiAgICAgIHRvcFNlcmllcy52YWx1ZXMudG9BcnJheSgpW2pdIC09IGJvdHRvbVBvaW50O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZXJpZXNMaXN0O1xufVxuXG5mdW5jdGlvbiBzb3J0U2VyaWVzQnlMYWJlbChzMTogRGF0YUZyYW1lLCBzMjogRGF0YUZyYW1lKTogbnVtYmVyIHtcbiAgbGV0IGxlMSwgbGUyO1xuXG4gIHRyeSB7XG4gICAgLy8gZmFpbCBpZiBub3QgaW50ZWdlci4gbWlnaHQgaGFwcGVuIHdpdGggYmFkIHF1ZXJpZXNcbiAgICBsZTEgPSBwYXJzZVNhbXBsZVZhbHVlKHMxLm5hbWUgPz8gJycpO1xuICAgIGxlMiA9IHBhcnNlU2FtcGxlVmFsdWUoczIubmFtZSA/PyAnJyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGlmIChsZTEgPiBsZTIpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIGlmIChsZTEgPCBsZTIpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU2FtcGxlVmFsdWUodmFsdWU6IHN0cmluZyk6IG51bWJlciB7XG4gIGlmIChJTkZJTklUWV9TQU1QTEVfUkVHRVgudGVzdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWVbMF0gPT09ICctJyA/IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgfVxuICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSk7XG59XG4iLCJpbXBvcnQgeyBEYXRhUXVlcnksIERhdGFTb3VyY2VKc29uRGF0YSwgUXVlcnlSZXN1bHRNZXRhLCBTY29wZWRWYXJzIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5cbmltcG9ydCB7IFF1ZXJ5RWRpdG9yTW9kZSB9IGZyb20gJy4vcXVlcnlidWlsZGVyL3NoYXJlZC90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvbVF1ZXJ5IGV4dGVuZHMgRGF0YVF1ZXJ5IHtcbiAgZXhwcjogc3RyaW5nO1xuICBmb3JtYXQ/OiBzdHJpbmc7XG4gIGluc3RhbnQ/OiBib29sZWFuO1xuICByYW5nZT86IGJvb2xlYW47XG4gIGV4ZW1wbGFyPzogYm9vbGVhbjtcbiAgaGludGluZz86IGJvb2xlYW47XG4gIGludGVydmFsPzogc3RyaW5nO1xuICBpbnRlcnZhbEZhY3Rvcj86IG51bWJlcjtcbiAgLy8gVGltZXpvbmUgb2Zmc2V0IHRvIGFsaWduIHN0YXJ0ICYgZW5kIHRpbWUgb24gYmFja2VuZFxuICB1dGNPZmZzZXRTZWM/OiBudW1iZXI7XG4gIGxlZ2VuZEZvcm1hdD86IHN0cmluZztcbiAgdmFsdWVXaXRoUmVmSWQ/OiBib29sZWFuO1xuICByZXF1ZXN0SWQ/OiBzdHJpbmc7XG4gIHNob3dpbmdHcmFwaD86IGJvb2xlYW47XG4gIHNob3dpbmdUYWJsZT86IGJvb2xlYW47XG4gIC8qKiBDb2RlLCBCdWlsZGVyIG9yIEV4cGxhaW4gKi9cbiAgZWRpdG9yTW9kZT86IFF1ZXJ5RWRpdG9yTW9kZTtcbiAgLyoqIENvbnRyb2xzIGlmIHRoZSByYXcgcXVlcnkgdGV4dCBpcyBzaG93biAqL1xuICByYXdRdWVyeT86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvbU9wdGlvbnMgZXh0ZW5kcyBEYXRhU291cmNlSnNvbkRhdGEge1xuICB0aW1lSW50ZXJ2YWw/OiBzdHJpbmc7XG4gIHF1ZXJ5VGltZW91dD86IHN0cmluZztcbiAgaHR0cE1ldGhvZD86IHN0cmluZztcbiAgZGlyZWN0VXJsPzogc3RyaW5nO1xuICBjdXN0b21RdWVyeVBhcmFtZXRlcnM/OiBzdHJpbmc7XG4gIGRpc2FibGVNZXRyaWNzTG9va3VwPzogYm9vbGVhbjtcbiAgZXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb25zPzogRXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb25bXTtcbn1cblxuZXhwb3J0IGVudW0gUHJvbVF1ZXJ5VHlwZSB7XG4gIHRpbWVTZXJpZXNRdWVyeSA9ICd0aW1lU2VyaWVzUXVlcnknLFxufVxuXG5leHBvcnQgdHlwZSBFeGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbiA9IHtcbiAgbmFtZTogc3RyaW5nO1xuICB1cmw/OiBzdHJpbmc7XG4gIHVybERpc3BsYXlMYWJlbD86IHN0cmluZztcbiAgZGF0YXNvdXJjZVVpZD86IHN0cmluZztcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvbVF1ZXJ5UmVxdWVzdCBleHRlbmRzIFByb21RdWVyeSB7XG4gIHN0ZXA/OiBudW1iZXI7XG4gIHJlcXVlc3RJZD86IHN0cmluZztcbiAgc3RhcnQ6IG51bWJlcjtcbiAgZW5kOiBudW1iZXI7XG4gIGhlYWRlcnM/OiBhbnk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvbU1ldHJpY3NNZXRhZGF0YUl0ZW0ge1xuICB0eXBlOiBzdHJpbmc7XG4gIGhlbHA6IHN0cmluZztcbiAgdW5pdD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9tTWV0cmljc01ldGFkYXRhIHtcbiAgW21ldHJpYzogc3RyaW5nXTogUHJvbU1ldHJpY3NNZXRhZGF0YUl0ZW07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvbURhdGFTdWNjZXNzUmVzcG9uc2U8VCA9IFByb21EYXRhPiB7XG4gIHN0YXR1czogJ3N1Y2Nlc3MnO1xuICBkYXRhOiBUO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb21EYXRhRXJyb3JSZXNwb25zZTxUID0gUHJvbURhdGE+IHtcbiAgc3RhdHVzOiAnZXJyb3InO1xuICBlcnJvclR5cGU6IHN0cmluZztcbiAgZXJyb3I6IHN0cmluZztcbiAgZGF0YTogVDtcbn1cblxuZXhwb3J0IHR5cGUgUHJvbURhdGEgPSBQcm9tTWF0cml4RGF0YSB8IFByb21WZWN0b3JEYXRhIHwgUHJvbVNjYWxhckRhdGEgfCBQcm9tRXhlbXBsYXJEYXRhW107XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGFiZWxzIHtcbiAgW2luZGV4OiBzdHJpbmddOiBhbnk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXhlbXBsYXIge1xuICBsYWJlbHM6IExhYmVscztcbiAgdmFsdWU6IG51bWJlcjtcbiAgdGltZXN0YW1wOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvbUV4ZW1wbGFyRGF0YSB7XG4gIHNlcmllc0xhYmVsczogUHJvbU1ldHJpYztcbiAgZXhlbXBsYXJzOiBFeGVtcGxhcltdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb21WZWN0b3JEYXRhIHtcbiAgcmVzdWx0VHlwZTogJ3ZlY3Rvcic7XG4gIHJlc3VsdDogQXJyYXk8e1xuICAgIG1ldHJpYzogUHJvbU1ldHJpYztcbiAgICB2YWx1ZTogUHJvbVZhbHVlO1xuICB9Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9tTWF0cml4RGF0YSB7XG4gIHJlc3VsdFR5cGU6ICdtYXRyaXgnO1xuICByZXN1bHQ6IEFycmF5PHtcbiAgICBtZXRyaWM6IFByb21NZXRyaWM7XG4gICAgdmFsdWVzOiBQcm9tVmFsdWVbXTtcbiAgfT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvbVNjYWxhckRhdGEge1xuICByZXN1bHRUeXBlOiAnc2NhbGFyJztcbiAgcmVzdWx0OiBQcm9tVmFsdWU7XG59XG5cbmV4cG9ydCB0eXBlIFByb21WYWx1ZSA9IFtudW1iZXIsIGFueV07XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvbU1ldHJpYyB7XG4gIF9fbmFtZV9fPzogc3RyaW5nO1xuICBbaW5kZXg6IHN0cmluZ106IGFueTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTWF0cml4RGF0YShyZXN1bHQ6IE1hdHJpeE9yVmVjdG9yUmVzdWx0KTogcmVzdWx0IGlzIFByb21NYXRyaXhEYXRhWydyZXN1bHQnXVswXSB7XG4gIHJldHVybiAndmFsdWVzJyBpbiByZXN1bHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0V4ZW1wbGFyRGF0YShyZXN1bHQ6IFByb21EYXRhKTogcmVzdWx0IGlzIFByb21FeGVtcGxhckRhdGFbXSB7XG4gIGlmIChyZXN1bHQgPT0gbnVsbCB8fCAhQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiByZXN1bHQubGVuZ3RoID8gJ2V4ZW1wbGFycycgaW4gcmVzdWx0WzBdIDogZmFsc2U7XG59XG5cbmV4cG9ydCB0eXBlIE1hdHJpeE9yVmVjdG9yUmVzdWx0ID0gUHJvbU1hdHJpeERhdGFbJ3Jlc3VsdCddWzBdIHwgUHJvbVZlY3RvckRhdGFbJ3Jlc3VsdCddWzBdO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zZm9ybU9wdGlvbnMge1xuICBmb3JtYXQ/OiBzdHJpbmc7XG4gIHN0ZXA/OiBudW1iZXI7XG4gIGxlZ2VuZEZvcm1hdD86IHN0cmluZztcbiAgc3RhcnQ6IG51bWJlcjtcbiAgZW5kOiBudW1iZXI7XG4gIHF1ZXJ5OiBzdHJpbmc7XG4gIHJlc3BvbnNlTGlzdExlbmd0aDogbnVtYmVyO1xuICBzY29wZWRWYXJzPzogU2NvcGVkVmFycztcbiAgcmVmSWQ6IHN0cmluZztcbiAgdmFsdWVXaXRoUmVmSWQ/OiBib29sZWFuO1xuICBtZXRhOiBRdWVyeVJlc3VsdE1ldGE7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvbUxhYmVsUXVlcnlSZXNwb25zZSB7XG4gIGRhdGE6IHtcbiAgICBzdGF0dXM6IHN0cmluZztcbiAgICBkYXRhOiBzdHJpbmdbXTtcbiAgfTtcbiAgY2FuY2VsbGVkPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBBdXRvID0gcXVlcnkubGVnZW5kRm9ybWF0ID09ICdfX2F1dG8nXG4gKiBWZXJib3NlID0gcXVlcnkubGVnZW5kRm9ybWF0ID09IG51bGwvdW5kZWZpbmVkLycnXG4gKiBDdXN0b20gcXVlcnkubGVnZW5kRm9ybWF0Lmxlbmd0aCA+IDAgJiYgcXVlcnkubGVnZW5kRm9ybWF0ICE9PSAnX19hdXRvJ1xuICovXG5leHBvcnQgZW51bSBMZWdlbmRGb3JtYXRNb2RlIHtcbiAgQXV0byA9ICdfX2F1dG8nLFxuICBWZXJib3NlID0gJ19fdmVyYm9zZScsXG4gIEN1c3RvbSA9ICdfX2N1c3RvbScsXG59XG4iLCJpbXBvcnQgeyBmcm9tLCBPYnNlcnZhYmxlLCBvZiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQge1xuICBEYXRhUXVlcnlSZXF1ZXN0LFxuICBEYXRhUXVlcnlSZXNwb25zZSxcbiAgcmFuZ2VVdGlsLFxuICBTdGFuZGFyZFZhcmlhYmxlUXVlcnksXG4gIFN0YW5kYXJkVmFyaWFibGVTdXBwb3J0LFxufSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IGdldFRlbXBsYXRlU3J2LCBUZW1wbGF0ZVNydiB9IGZyb20gJ0BncmFmYW5hL3J1bnRpbWUnO1xuXG5pbXBvcnQgeyBnZXRUaW1lU3J2LCBUaW1lU3J2IH0gZnJvbSAnLi4vLi4vLi4vZmVhdHVyZXMvZGFzaGJvYXJkL3NlcnZpY2VzL1RpbWVTcnYnO1xuXG5pbXBvcnQgeyBQcm9tZXRoZXVzRGF0YXNvdXJjZSB9IGZyb20gJy4vZGF0YXNvdXJjZSc7XG5pbXBvcnQgUHJvbWV0aGV1c01ldHJpY0ZpbmRRdWVyeSBmcm9tICcuL21ldHJpY19maW5kX3F1ZXJ5JztcbmltcG9ydCB7IFByb21RdWVyeSB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgUHJvbWV0aGV1c1ZhcmlhYmxlU3VwcG9ydCBleHRlbmRzIFN0YW5kYXJkVmFyaWFibGVTdXBwb3J0PFByb21ldGhldXNEYXRhc291cmNlPiB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZGF0YXNvdXJjZTogUHJvbWV0aGV1c0RhdGFzb3VyY2UsXG4gICAgcHJpdmF0ZSByZWFkb25seSB0ZW1wbGF0ZVNydjogVGVtcGxhdGVTcnYgPSBnZXRUZW1wbGF0ZVNydigpLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgdGltZVNydjogVGltZVNydiA9IGdldFRpbWVTcnYoKVxuICApIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucXVlcnkgPSB0aGlzLnF1ZXJ5LmJpbmQodGhpcyk7XG4gIH1cblxuICBxdWVyeShyZXF1ZXN0OiBEYXRhUXVlcnlSZXF1ZXN0PFByb21RdWVyeT4pOiBPYnNlcnZhYmxlPERhdGFRdWVyeVJlc3BvbnNlPiB7XG4gICAgY29uc3QgcXVlcnkgPSByZXF1ZXN0LnRhcmdldHNbMF0uZXhwcjtcbiAgICBpZiAoIXF1ZXJ5KSB7XG4gICAgICByZXR1cm4gb2YoeyBkYXRhOiBbXSB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBzY29wZWRWYXJzID0ge1xuICAgICAgLi4ucmVxdWVzdC5zY29wZWRWYXJzLFxuICAgICAgX19pbnRlcnZhbDogeyB0ZXh0OiB0aGlzLmRhdGFzb3VyY2UuaW50ZXJ2YWwsIHZhbHVlOiB0aGlzLmRhdGFzb3VyY2UuaW50ZXJ2YWwgfSxcbiAgICAgIF9faW50ZXJ2YWxfbXM6IHtcbiAgICAgICAgdGV4dDogcmFuZ2VVdGlsLmludGVydmFsVG9Ncyh0aGlzLmRhdGFzb3VyY2UuaW50ZXJ2YWwpLFxuICAgICAgICB2YWx1ZTogcmFuZ2VVdGlsLmludGVydmFsVG9Ncyh0aGlzLmRhdGFzb3VyY2UuaW50ZXJ2YWwpLFxuICAgICAgfSxcbiAgICAgIC4uLnRoaXMuZGF0YXNvdXJjZS5nZXRSYW5nZVNjb3BlZFZhcnModGhpcy50aW1lU3J2LnRpbWVSYW5nZSgpKSxcbiAgICB9O1xuXG4gICAgY29uc3QgaW50ZXJwb2xhdGVkID0gdGhpcy50ZW1wbGF0ZVNydi5yZXBsYWNlKHF1ZXJ5LCBzY29wZWRWYXJzLCB0aGlzLmRhdGFzb3VyY2UuaW50ZXJwb2xhdGVRdWVyeUV4cHIpO1xuICAgIGNvbnN0IG1ldHJpY0ZpbmRRdWVyeSA9IG5ldyBQcm9tZXRoZXVzTWV0cmljRmluZFF1ZXJ5KHRoaXMuZGF0YXNvdXJjZSwgaW50ZXJwb2xhdGVkKTtcbiAgICBjb25zdCBtZXRyaWNGaW5kU3RyZWFtID0gZnJvbShtZXRyaWNGaW5kUXVlcnkucHJvY2VzcygpKTtcblxuICAgIHJldHVybiBtZXRyaWNGaW5kU3RyZWFtLnBpcGUobWFwKChyZXN1bHRzKSA9PiAoeyBkYXRhOiByZXN1bHRzIH0pKSk7XG4gIH1cblxuICB0b0RhdGFRdWVyeShxdWVyeTogU3RhbmRhcmRWYXJpYWJsZVF1ZXJ5KTogUHJvbVF1ZXJ5IHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVmSWQ6ICdQcm9tZXRoZXVzRGF0YXNvdXJjZS1WYXJpYWJsZVF1ZXJ5JyxcbiAgICAgIGV4cHI6IHF1ZXJ5LnF1ZXJ5LFxuICAgIH07XG4gIH1cbn1cbiIsImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXNlUHJldmlvdXMoc3RhdGUpIHtcbiAgICB2YXIgcmVmID0gdXNlUmVmKCk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSBzdGF0ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVmLmN1cnJlbnQ7XG59XG4iLCJpbXBvcnQgeyB1c2VSZWR1Y2VyIH0gZnJvbSAncmVhY3QnO1xudmFyIHRvZ2dsZVJlZHVjZXIgPSBmdW5jdGlvbiAoc3RhdGUsIG5leHRWYWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgbmV4dFZhbHVlID09PSAnYm9vbGVhbicgPyBuZXh0VmFsdWUgOiAhc3RhdGU7XG59O1xudmFyIHVzZVRvZ2dsZSA9IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICByZXR1cm4gdXNlUmVkdWNlcih0b2dnbGVSZWR1Y2VyLCBpbml0aWFsVmFsdWUpO1xufTtcbmV4cG9ydCBkZWZhdWx0IHVzZVRvZ2dsZTtcbiIsImNvbnN0IHBlcmYgPSB0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICdvYmplY3QnICYmIHBlcmZvcm1hbmNlICYmXG4gIHR5cGVvZiBwZXJmb3JtYW5jZS5ub3cgPT09ICdmdW5jdGlvbicgPyBwZXJmb3JtYW5jZSA6IERhdGVcblxuY29uc3QgaGFzQWJvcnRDb250cm9sbGVyID0gdHlwZW9mIEFib3J0Q29udHJvbGxlciA9PT0gJ2Z1bmN0aW9uJ1xuXG4vLyBtaW5pbWFsIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IHBvbHlmaWxsXG4vLyB0aGlzIGRvZXNuJ3QgaGF2ZSBuZWFybHkgYWxsIHRoZSBjaGVja3MgYW5kIHdoYXRub3QgdGhhdFxuLy8gYWN0dWFsIEFib3J0Q29udHJvbGxlci9TaWduYWwgaGFzLCBidXQgaXQncyBlbm91Z2ggZm9yXG4vLyBvdXIgcHVycG9zZXMsIGFuZCBpZiB1c2VkIHByb3Blcmx5LCBiZWhhdmVzIHRoZSBzYW1lLlxuY29uc3QgQUMgPSBoYXNBYm9ydENvbnRyb2xsZXIgPyBBYm9ydENvbnRyb2xsZXIgOiBPYmplY3QuYXNzaWduKFxuICBjbGFzcyBBYm9ydENvbnRyb2xsZXIge1xuICAgIGNvbnN0cnVjdG9yICgpIHsgdGhpcy5zaWduYWwgPSBuZXcgQUMuQWJvcnRTaWduYWwgfVxuICAgIGFib3J0ICgpIHtcbiAgICAgIHRoaXMuc2lnbmFsLmRpc3BhdGNoRXZlbnQoJ2Fib3J0JylcbiAgICB9XG4gIH0sXG4gIHtcbiAgICBBYm9ydFNpZ25hbDogY2xhc3MgQWJvcnRTaWduYWwge1xuICAgICAgY29uc3RydWN0b3IgKCkge1xuICAgICAgICB0aGlzLmFib3J0ZWQgPSBmYWxzZVxuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSBbXVxuICAgICAgfVxuICAgICAgZGlzcGF0Y2hFdmVudCAodHlwZSkge1xuICAgICAgICBpZiAodHlwZSA9PT0gJ2Fib3J0Jykge1xuICAgICAgICAgIHRoaXMuYWJvcnRlZCA9IHRydWVcbiAgICAgICAgICBjb25zdCBlID0geyB0eXBlLCB0YXJnZXQ6IHRoaXMgfVxuICAgICAgICAgIHRoaXMub25hYm9ydChlKVxuICAgICAgICAgIHRoaXMuX2xpc3RlbmVycy5mb3JFYWNoKGYgPT4gZihlKSwgdGhpcylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb25hYm9ydCAoKSB7fVxuICAgICAgYWRkRXZlbnRMaXN0ZW5lciAoZXYsIGZuKSB7XG4gICAgICAgIGlmIChldiA9PT0gJ2Fib3J0Jykge1xuICAgICAgICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKGZuKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyIChldiwgZm4pIHtcbiAgICAgICAgaWYgKGV2ID09PSAnYWJvcnQnKSB7XG4gICAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzLmZpbHRlcihmID0+IGYgIT09IGZuKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4pXG5cbmNvbnN0IHdhcm5lZCA9IG5ldyBTZXQoKVxuY29uc3QgZGVwcmVjYXRlZE9wdGlvbiA9IChvcHQsIGluc3RlYWQpID0+IHtcbiAgY29uc3QgY29kZSA9IGBMUlVfQ0FDSEVfT1BUSU9OXyR7b3B0fWBcbiAgaWYgKHNob3VsZFdhcm4oY29kZSkpIHtcbiAgICB3YXJuKGNvZGUsIGAke29wdH0gb3B0aW9uYCwgYG9wdGlvbnMuJHtpbnN0ZWFkfWAsIExSVUNhY2hlKVxuICB9XG59XG5jb25zdCBkZXByZWNhdGVkTWV0aG9kID0gKG1ldGhvZCwgaW5zdGVhZCkgPT4ge1xuICBjb25zdCBjb2RlID0gYExSVV9DQUNIRV9NRVRIT0RfJHttZXRob2R9YFxuICBpZiAoc2hvdWxkV2Fybihjb2RlKSkge1xuICAgIGNvbnN0IHsgcHJvdG90eXBlIH0gPSBMUlVDYWNoZVxuICAgIGNvbnN0IHsgZ2V0IH0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvdHlwZSwgbWV0aG9kKVxuICAgIHdhcm4oY29kZSwgYCR7bWV0aG9kfSBtZXRob2RgLCBgY2FjaGUuJHtpbnN0ZWFkfSgpYCwgZ2V0KVxuICB9XG59XG5jb25zdCBkZXByZWNhdGVkUHJvcGVydHkgPSAoZmllbGQsIGluc3RlYWQpID0+IHtcbiAgY29uc3QgY29kZSA9IGBMUlVfQ0FDSEVfUFJPUEVSVFlfJHtmaWVsZH1gXG4gIGlmIChzaG91bGRXYXJuKGNvZGUpKSB7XG4gICAgY29uc3QgeyBwcm90b3R5cGUgfSA9IExSVUNhY2hlXG4gICAgY29uc3QgeyBnZXQgfSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG90eXBlLCBmaWVsZClcbiAgICB3YXJuKGNvZGUsIGAke2ZpZWxkfSBwcm9wZXJ0eWAsIGBjYWNoZS4ke2luc3RlYWR9YCwgZ2V0KVxuICB9XG59XG5cbmNvbnN0IGVtaXRXYXJuaW5nID0gKC4uLmEpID0+IHtcbiAgdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmXG4gICAgcHJvY2VzcyAmJlxuICAgIHR5cGVvZiBwcm9jZXNzLmVtaXRXYXJuaW5nID09PSAnZnVuY3Rpb24nXG4gID8gcHJvY2Vzcy5lbWl0V2FybmluZyguLi5hKVxuICA6IGNvbnNvbGUuZXJyb3IoLi4uYSlcbn1cblxuY29uc3Qgc2hvdWxkV2FybiA9IGNvZGUgPT4gIXdhcm5lZC5oYXMoY29kZSlcblxuY29uc3Qgd2FybiA9IChjb2RlLCB3aGF0LCBpbnN0ZWFkLCBmbikgPT4ge1xuICB3YXJuZWQuYWRkKGNvZGUpXG4gIGNvbnN0IG1zZyA9IGBUaGUgJHt3aGF0fSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlICR7aW5zdGVhZH0gaW5zdGVhZC5gXG4gIGVtaXRXYXJuaW5nKG1zZywgJ0RlcHJlY2F0aW9uV2FybmluZycsIGNvZGUsIGZuKVxufVxuXG5jb25zdCBpc1Bvc0ludCA9IG4gPT4gbiAmJiBuID09PSBNYXRoLmZsb29yKG4pICYmIG4gPiAwICYmIGlzRmluaXRlKG4pXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gVGhpcyBpcyBhIGxpdHRsZSBiaXQgcmlkaWN1bG91cywgdGJoLlxuICogVGhlIG1heGltdW0gYXJyYXkgbGVuZ3RoIGlzIDJeMzItMSBvciB0aGVyZWFib3V0cyBvbiBtb3N0IEpTIGltcGxzLlxuICogQW5kIHdlbGwgYmVmb3JlIHRoYXQgcG9pbnQsIHlvdSdyZSBjYWNoaW5nIHRoZSBlbnRpcmUgd29ybGQsIEkgbWVhbixcbiAqIHRoYXQncyB+MzJHQiBvZiBqdXN0IGludGVnZXJzIGZvciB0aGUgbmV4dC9wcmV2IGxpbmtzLCBwbHVzIHdoYXRldmVyXG4gKiBlbHNlIHRvIGhvbGQgdGhhdCBtYW55IGtleXMgYW5kIHZhbHVlcy4gIEp1c3QgZmlsbGluZyB0aGUgbWVtb3J5IHdpdGhcbiAqIHplcm9lcyBhdCBpbml0IHRpbWUgaXMgYnJ1dGFsIHdoZW4geW91IGdldCB0aGF0IGJpZy5cbiAqIEJ1dCB3aHkgbm90IGJlIGNvbXBsZXRlP1xuICogTWF5YmUgaW4gdGhlIGZ1dHVyZSwgdGhlc2UgbGltaXRzIHdpbGwgaGF2ZSBleHBhbmRlZC4gKi9cbmNvbnN0IGdldFVpbnRBcnJheSA9IG1heCA9PiAhaXNQb3NJbnQobWF4KSA/IG51bGxcbjogbWF4IDw9IE1hdGgucG93KDIsIDgpID8gVWludDhBcnJheVxuOiBtYXggPD0gTWF0aC5wb3coMiwgMTYpID8gVWludDE2QXJyYXlcbjogbWF4IDw9IE1hdGgucG93KDIsIDMyKSA/IFVpbnQzMkFycmF5XG46IG1heCA8PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiA/IFplcm9BcnJheVxuOiBudWxsXG5cbmNsYXNzIFplcm9BcnJheSBleHRlbmRzIEFycmF5IHtcbiAgY29uc3RydWN0b3IgKHNpemUpIHtcbiAgICBzdXBlcihzaXplKVxuICAgIHRoaXMuZmlsbCgwKVxuICB9XG59XG5cbmNsYXNzIFN0YWNrIHtcbiAgY29uc3RydWN0b3IgKG1heCkge1xuICAgIGlmIChtYXggPT09IDApIHtcbiAgICAgIHJldHVybiBbXVxuICAgIH1cbiAgICBjb25zdCBVaW50QXJyYXkgPSBnZXRVaW50QXJyYXkobWF4KVxuICAgIHRoaXMuaGVhcCA9IG5ldyBVaW50QXJyYXkobWF4KVxuICAgIHRoaXMubGVuZ3RoID0gMFxuICB9XG4gIHB1c2ggKG4pIHtcbiAgICB0aGlzLmhlYXBbdGhpcy5sZW5ndGgrK10gPSBuXG4gIH1cbiAgcG9wICgpIHtcbiAgICByZXR1cm4gdGhpcy5oZWFwWy0tdGhpcy5sZW5ndGhdXG4gIH1cbn1cblxuY2xhc3MgTFJVQ2FjaGUge1xuICBjb25zdHJ1Y3RvciAob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgbWF4ID0gMCxcbiAgICAgIHR0bCxcbiAgICAgIHR0bFJlc29sdXRpb24gPSAxLFxuICAgICAgdHRsQXV0b3B1cmdlLFxuICAgICAgdXBkYXRlQWdlT25HZXQsXG4gICAgICB1cGRhdGVBZ2VPbkhhcyxcbiAgICAgIGFsbG93U3RhbGUsXG4gICAgICBkaXNwb3NlLFxuICAgICAgZGlzcG9zZUFmdGVyLFxuICAgICAgbm9EaXNwb3NlT25TZXQsXG4gICAgICBub1VwZGF0ZVRUTCxcbiAgICAgIG1heFNpemUgPSAwLFxuICAgICAgc2l6ZUNhbGN1bGF0aW9uLFxuICAgICAgZmV0Y2hNZXRob2QsXG4gICAgfSA9IG9wdGlvbnNcblxuICAgIC8vIGRlcHJlY2F0ZWQgb3B0aW9ucywgZG9uJ3QgdHJpZ2dlciBhIHdhcm5pbmcgZm9yIGdldHRpbmcgdGhlbSBpZlxuICAgIC8vIHRoZSB0aGluZyBiZWluZyBwYXNzZWQgaW4gaXMgYW5vdGhlciBMUlVDYWNoZSB3ZSdyZSBjb3B5aW5nLlxuICAgIGNvbnN0IHtcbiAgICAgIGxlbmd0aCxcbiAgICAgIG1heEFnZSxcbiAgICAgIHN0YWxlLFxuICAgIH0gPSBvcHRpb25zIGluc3RhbmNlb2YgTFJVQ2FjaGUgPyB7fSA6IG9wdGlvbnNcblxuICAgIGlmIChtYXggIT09IDAgJiYgIWlzUG9zSW50KG1heCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heCBvcHRpb24gbXVzdCBiZSBhIG5vbm5lZ2F0aXZlIGludGVnZXInKVxuICAgIH1cblxuICAgIGNvbnN0IFVpbnRBcnJheSA9IG1heCA/IGdldFVpbnRBcnJheShtYXgpIDogQXJyYXlcbiAgICBpZiAoIVVpbnRBcnJheSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG1heCB2YWx1ZTogJyArIG1heClcbiAgICB9XG5cbiAgICB0aGlzLm1heCA9IG1heFxuICAgIHRoaXMubWF4U2l6ZSA9IG1heFNpemVcbiAgICB0aGlzLnNpemVDYWxjdWxhdGlvbiA9IHNpemVDYWxjdWxhdGlvbiB8fCBsZW5ndGhcbiAgICBpZiAodGhpcy5zaXplQ2FsY3VsYXRpb24pIHtcbiAgICAgIGlmICghdGhpcy5tYXhTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Nhbm5vdCBzZXQgc2l6ZUNhbGN1bGF0aW9uIHdpdGhvdXQgc2V0dGluZyBtYXhTaXplJylcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5zaXplQ2FsY3VsYXRpb24gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2l6ZUNhbGN1bGF0aW9uIHNldCB0byBub24tZnVuY3Rpb24nKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZmV0Y2hNZXRob2QgPSBmZXRjaE1ldGhvZCB8fCBudWxsXG4gICAgaWYgKHRoaXMuZmV0Y2hNZXRob2QgJiYgdHlwZW9mIHRoaXMuZmV0Y2hNZXRob2QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ZldGNoTWV0aG9kIG11c3QgYmUgYSBmdW5jdGlvbiBpZiBzcGVjaWZpZWQnKVxuICAgIH1cblxuICAgIHRoaXMua2V5TWFwID0gbmV3IE1hcCgpXG4gICAgdGhpcy5rZXlMaXN0ID0gbmV3IEFycmF5KG1heCkuZmlsbChudWxsKVxuICAgIHRoaXMudmFsTGlzdCA9IG5ldyBBcnJheShtYXgpLmZpbGwobnVsbClcbiAgICB0aGlzLm5leHQgPSBuZXcgVWludEFycmF5KG1heClcbiAgICB0aGlzLnByZXYgPSBuZXcgVWludEFycmF5KG1heClcbiAgICB0aGlzLmhlYWQgPSAwXG4gICAgdGhpcy50YWlsID0gMFxuICAgIHRoaXMuZnJlZSA9IG5ldyBTdGFjayhtYXgpXG4gICAgdGhpcy5pbml0aWFsRmlsbCA9IDFcbiAgICB0aGlzLnNpemUgPSAwXG5cbiAgICBpZiAodHlwZW9mIGRpc3Bvc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuZGlzcG9zZSA9IGRpc3Bvc2VcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkaXNwb3NlQWZ0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuZGlzcG9zZUFmdGVyID0gZGlzcG9zZUFmdGVyXG4gICAgICB0aGlzLmRpc3Bvc2VkID0gW11cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXNwb3NlQWZ0ZXIgPSBudWxsXG4gICAgICB0aGlzLmRpc3Bvc2VkID0gbnVsbFxuICAgIH1cbiAgICB0aGlzLm5vRGlzcG9zZU9uU2V0ID0gISFub0Rpc3Bvc2VPblNldFxuICAgIHRoaXMubm9VcGRhdGVUVEwgPSAhIW5vVXBkYXRlVFRMXG5cbiAgICBpZiAodGhpcy5tYXhTaXplICE9PSAwKSB7XG4gICAgICBpZiAoIWlzUG9zSW50KHRoaXMubWF4U2l6ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4U2l6ZSBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBpZiBzcGVjaWZpZWQnKVxuICAgICAgfVxuICAgICAgdGhpcy5pbml0aWFsaXplU2l6ZVRyYWNraW5nKClcbiAgICB9XG5cbiAgICB0aGlzLmFsbG93U3RhbGUgPSAhIWFsbG93U3RhbGUgfHwgISFzdGFsZVxuICAgIHRoaXMudXBkYXRlQWdlT25HZXQgPSAhIXVwZGF0ZUFnZU9uR2V0XG4gICAgdGhpcy51cGRhdGVBZ2VPbkhhcyA9ICEhdXBkYXRlQWdlT25IYXNcbiAgICB0aGlzLnR0bFJlc29sdXRpb24gPSBpc1Bvc0ludCh0dGxSZXNvbHV0aW9uKSB8fCB0dGxSZXNvbHV0aW9uID09PSAwXG4gICAgICA/IHR0bFJlc29sdXRpb24gOiAxXG4gICAgdGhpcy50dGxBdXRvcHVyZ2UgPSAhIXR0bEF1dG9wdXJnZVxuICAgIHRoaXMudHRsID0gdHRsIHx8IG1heEFnZSB8fCAwXG4gICAgaWYgKHRoaXMudHRsKSB7XG4gICAgICBpZiAoIWlzUG9zSW50KHRoaXMudHRsKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0dGwgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgaWYgc3BlY2lmaWVkJylcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5pdGlhbGl6ZVRUTFRyYWNraW5nKClcbiAgICB9XG5cbiAgICAvLyBkbyBub3QgYWxsb3cgY29tcGxldGVseSB1bmJvdW5kZWQgY2FjaGVzXG4gICAgaWYgKHRoaXMubWF4ID09PSAwICYmIHRoaXMudHRsID09PSAwICYmIHRoaXMubWF4U2l6ZSA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXQgbGVhc3Qgb25lIG9mIG1heCwgbWF4U2l6ZSwgb3IgdHRsIGlzIHJlcXVpcmVkJylcbiAgICB9XG4gICAgaWYgKCF0aGlzLnR0bEF1dG9wdXJnZSAmJiAhdGhpcy5tYXggJiYgIXRoaXMubWF4U2l6ZSkge1xuICAgICAgY29uc3QgY29kZSA9ICdMUlVfQ0FDSEVfVU5CT1VOREVEJ1xuICAgICAgaWYgKHNob3VsZFdhcm4oY29kZSkpIHtcbiAgICAgICAgd2FybmVkLmFkZChjb2RlKVxuICAgICAgICBjb25zdCBtc2cgPSAnVFRMIGNhY2hpbmcgd2l0aG91dCB0dGxBdXRvcHVyZ2UsIG1heCwgb3IgbWF4U2l6ZSBjYW4gJyArXG4gICAgICAgICAgJ3Jlc3VsdCBpbiB1bmJvdW5kZWQgbWVtb3J5IGNvbnN1bXB0aW9uLidcbiAgICAgICAgZW1pdFdhcm5pbmcobXNnLCAnVW5ib3VuZGVkQ2FjaGVXYXJuaW5nJywgY29kZSwgTFJVQ2FjaGUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0YWxlKSB7XG4gICAgICBkZXByZWNhdGVkT3B0aW9uKCdzdGFsZScsICdhbGxvd1N0YWxlJylcbiAgICB9XG4gICAgaWYgKG1heEFnZSkge1xuICAgICAgZGVwcmVjYXRlZE9wdGlvbignbWF4QWdlJywgJ3R0bCcpXG4gICAgfVxuICAgIGlmIChsZW5ndGgpIHtcbiAgICAgIGRlcHJlY2F0ZWRPcHRpb24oJ2xlbmd0aCcsICdzaXplQ2FsY3VsYXRpb24nKVxuICAgIH1cbiAgfVxuXG4gIGdldFJlbWFpbmluZ1RUTCAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzKGtleSwgeyB1cGRhdGVBZ2VPbkhhczogZmFsc2UgfSkgPyBJbmZpbml0eSA6IDBcbiAgfVxuXG4gIGluaXRpYWxpemVUVExUcmFja2luZyAoKSB7XG4gICAgdGhpcy50dGxzID0gbmV3IFplcm9BcnJheSh0aGlzLm1heClcbiAgICB0aGlzLnN0YXJ0cyA9IG5ldyBaZXJvQXJyYXkodGhpcy5tYXgpXG5cbiAgICB0aGlzLnNldEl0ZW1UVEwgPSAoaW5kZXgsIHR0bCkgPT4ge1xuICAgICAgdGhpcy5zdGFydHNbaW5kZXhdID0gdHRsICE9PSAwID8gcGVyZi5ub3coKSA6IDBcbiAgICAgIHRoaXMudHRsc1tpbmRleF0gPSB0dGxcbiAgICAgIGlmICh0dGwgIT09IDAgJiYgdGhpcy50dGxBdXRvcHVyZ2UpIHtcbiAgICAgICAgY29uc3QgdCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmlzU3RhbGUoaW5kZXgpKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGV0ZSh0aGlzLmtleUxpc3RbaW5kZXhdKVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgdHRsICsgMSlcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgLSB1bnJlZigpIG5vdCBzdXBwb3J0ZWQgb24gYWxsIHBsYXRmb3JtcyAqL1xuICAgICAgICBpZiAodC51bnJlZikge1xuICAgICAgICAgIHQudW5yZWYoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVJdGVtQWdlID0gKGluZGV4KSA9PiB7XG4gICAgICB0aGlzLnN0YXJ0c1tpbmRleF0gPSB0aGlzLnR0bHNbaW5kZXhdICE9PSAwID8gcGVyZi5ub3coKSA6IDBcbiAgICB9XG5cbiAgICAvLyBkZWJvdW5jZSBjYWxscyB0byBwZXJmLm5vdygpIHRvIDFzIHNvIHdlJ3JlIG5vdCBoaXR0aW5nXG4gICAgLy8gdGhhdCBjb3N0bHkgY2FsbCByZXBlYXRlZGx5LlxuICAgIGxldCBjYWNoZWROb3cgPSAwXG4gICAgY29uc3QgZ2V0Tm93ID0gKCkgPT4ge1xuICAgICAgY29uc3QgbiA9IHBlcmYubm93KClcbiAgICAgIGlmICh0aGlzLnR0bFJlc29sdXRpb24gPiAwKSB7XG4gICAgICAgIGNhY2hlZE5vdyA9IG5cbiAgICAgICAgY29uc3QgdCA9IHNldFRpbWVvdXQoKCkgPT4gY2FjaGVkTm93ID0gMCwgdGhpcy50dGxSZXNvbHV0aW9uKVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAtIG5vdCBhdmFpbGFibGUgb24gYWxsIHBsYXRmb3JtcyAqL1xuICAgICAgICBpZiAodC51bnJlZikge1xuICAgICAgICAgIHQudW5yZWYoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gblxuICAgIH1cblxuICAgIHRoaXMuZ2V0UmVtYWluaW5nVFRMID0gKGtleSkgPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmtleU1hcC5nZXQoa2V5KVxuICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDBcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnR0bHNbaW5kZXhdID09PSAwIHx8IHRoaXMuc3RhcnRzW2luZGV4XSA9PT0gMCA/IEluZmluaXR5XG4gICAgICAgIDogKCh0aGlzLnN0YXJ0c1tpbmRleF0gKyB0aGlzLnR0bHNbaW5kZXhdKSAtIChjYWNoZWROb3cgfHwgZ2V0Tm93KCkpKVxuICAgIH1cblxuICAgIHRoaXMuaXNTdGFsZSA9IChpbmRleCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMudHRsc1tpbmRleF0gIT09IDAgJiYgdGhpcy5zdGFydHNbaW5kZXhdICE9PSAwICYmXG4gICAgICAgICgoY2FjaGVkTm93IHx8IGdldE5vdygpKSAtIHRoaXMuc3RhcnRzW2luZGV4XSA+IHRoaXMudHRsc1tpbmRleF0pXG4gICAgfVxuICB9XG4gIHVwZGF0ZUl0ZW1BZ2UgKGluZGV4KSB7fVxuICBzZXRJdGVtVFRMIChpbmRleCwgdHRsKSB7fVxuICBpc1N0YWxlIChpbmRleCkgeyByZXR1cm4gZmFsc2UgfVxuXG4gIGluaXRpYWxpemVTaXplVHJhY2tpbmcgKCkge1xuICAgIHRoaXMuY2FsY3VsYXRlZFNpemUgPSAwXG4gICAgdGhpcy5zaXplcyA9IG5ldyBaZXJvQXJyYXkodGhpcy5tYXgpXG4gICAgdGhpcy5yZW1vdmVJdGVtU2l6ZSA9IGluZGV4ID0+IHRoaXMuY2FsY3VsYXRlZFNpemUgLT0gdGhpcy5zaXplc1tpbmRleF1cbiAgICB0aGlzLnJlcXVpcmVTaXplID0gKGssIHYsIHNpemUsIHNpemVDYWxjdWxhdGlvbikgPT4ge1xuICAgICAgaWYgKCFpc1Bvc0ludChzaXplKSkge1xuICAgICAgICBpZiAoc2l6ZUNhbGN1bGF0aW9uKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBzaXplQ2FsY3VsYXRpb24gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpemVDYWxjdWxhdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb24nKVxuICAgICAgICAgIH1cbiAgICAgICAgICBzaXplID0gc2l6ZUNhbGN1bGF0aW9uKHYsIGspXG4gICAgICAgICAgaWYgKCFpc1Bvc0ludChzaXplKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2l6ZUNhbGN1bGF0aW9uIHJldHVybiBpbnZhbGlkIChleHBlY3QgcG9zaXRpdmUgaW50ZWdlciknKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHNpemUgdmFsdWUgKG11c3QgYmUgcG9zaXRpdmUgaW50ZWdlciknKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2l6ZVxuICAgIH1cbiAgICB0aGlzLmFkZEl0ZW1TaXplID0gKGluZGV4LCB2LCBrLCBzaXplKSA9PiB7XG4gICAgICB0aGlzLnNpemVzW2luZGV4XSA9IHNpemVcbiAgICAgIGNvbnN0IG1heFNpemUgPSB0aGlzLm1heFNpemUgLSB0aGlzLnNpemVzW2luZGV4XVxuICAgICAgd2hpbGUgKHRoaXMuY2FsY3VsYXRlZFNpemUgPiBtYXhTaXplKSB7XG4gICAgICAgIHRoaXMuZXZpY3QodHJ1ZSlcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FsY3VsYXRlZFNpemUgKz0gdGhpcy5zaXplc1tpbmRleF1cbiAgICB9XG4gIH1cbiAgcmVtb3ZlSXRlbVNpemUgKGluZGV4KSB7fVxuICBhZGRJdGVtU2l6ZSAoaW5kZXgsIHYsIGssIHNpemUpIHt9XG4gIHJlcXVpcmVTaXplIChrLCB2LCBzaXplLCBzaXplQ2FsY3VsYXRpb24pIHtcbiAgICBpZiAoc2l6ZSB8fCBzaXplQ2FsY3VsYXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Nhbm5vdCBzZXQgc2l6ZSB3aXRob3V0IHNldHRpbmcgbWF4U2l6ZSBvbiBjYWNoZScpXG4gICAgfVxuICB9XG5cbiAgKmluZGV4ZXMgKHsgYWxsb3dTdGFsZSA9IHRoaXMuYWxsb3dTdGFsZSB9ID0ge30pIHtcbiAgICBpZiAodGhpcy5zaXplKSB7XG4gICAgICBmb3IgKGxldCBpID0gdGhpcy50YWlsOyB0cnVlOyApIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWRJbmRleChpKSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsbG93U3RhbGUgfHwgIXRoaXMuaXNTdGFsZShpKSkge1xuICAgICAgICAgIHlpZWxkIGlcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA9PT0gdGhpcy5oZWFkKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpID0gdGhpcy5wcmV2W2ldXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAqcmluZGV4ZXMgKHsgYWxsb3dTdGFsZSA9IHRoaXMuYWxsb3dTdGFsZSB9ID0ge30pIHtcbiAgICBpZiAodGhpcy5zaXplKSB7XG4gICAgICBmb3IgKGxldCBpID0gdGhpcy5oZWFkOyB0cnVlOyApIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWRJbmRleChpKSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsbG93U3RhbGUgfHwgIXRoaXMuaXNTdGFsZShpKSkge1xuICAgICAgICAgIHlpZWxkIGlcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA9PT0gdGhpcy50YWlsKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpID0gdGhpcy5uZXh0W2ldXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpc1ZhbGlkSW5kZXggKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMua2V5TWFwLmdldCh0aGlzLmtleUxpc3RbaW5kZXhdKSA9PT0gaW5kZXhcbiAgfVxuXG4gICplbnRyaWVzICgpIHtcbiAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy5pbmRleGVzKCkpIHtcbiAgICAgIHlpZWxkIFt0aGlzLmtleUxpc3RbaV0sIHRoaXMudmFsTGlzdFtpXV1cbiAgICB9XG4gIH1cbiAgKnJlbnRyaWVzICgpIHtcbiAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy5yaW5kZXhlcygpKSB7XG4gICAgICB5aWVsZCBbdGhpcy5rZXlMaXN0W2ldLCB0aGlzLnZhbExpc3RbaV1dXG4gICAgfVxuICB9XG5cbiAgKmtleXMgKCkge1xuICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLmluZGV4ZXMoKSkge1xuICAgICAgeWllbGQgdGhpcy5rZXlMaXN0W2ldXG4gICAgfVxuICB9XG4gICpya2V5cyAoKSB7XG4gICAgZm9yIChjb25zdCBpIG9mIHRoaXMucmluZGV4ZXMoKSkge1xuICAgICAgeWllbGQgdGhpcy5rZXlMaXN0W2ldXG4gICAgfVxuICB9XG5cbiAgKnZhbHVlcyAoKSB7XG4gICAgZm9yIChjb25zdCBpIG9mIHRoaXMuaW5kZXhlcygpKSB7XG4gICAgICB5aWVsZCB0aGlzLnZhbExpc3RbaV1cbiAgICB9XG4gIH1cbiAgKnJ2YWx1ZXMgKCkge1xuICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLnJpbmRleGVzKCkpIHtcbiAgICAgIHlpZWxkIHRoaXMudmFsTGlzdFtpXVxuICAgIH1cbiAgfVxuXG4gIFtTeW1ib2wuaXRlcmF0b3JdICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbnRyaWVzKClcbiAgfVxuXG4gIGZpbmQgKGZuLCBnZXRPcHRpb25zID0ge30pIHtcbiAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy5pbmRleGVzKCkpIHtcbiAgICAgIGlmIChmbih0aGlzLnZhbExpc3RbaV0sIHRoaXMua2V5TGlzdFtpXSwgdGhpcykpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMua2V5TGlzdFtpXSwgZ2V0T3B0aW9ucylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3JFYWNoIChmbiwgdGhpc3AgPSB0aGlzKSB7XG4gICAgZm9yIChjb25zdCBpIG9mIHRoaXMuaW5kZXhlcygpKSB7XG4gICAgICBmbi5jYWxsKHRoaXNwLCB0aGlzLnZhbExpc3RbaV0sIHRoaXMua2V5TGlzdFtpXSwgdGhpcylcbiAgICB9XG4gIH1cblxuICByZm9yRWFjaCAoZm4sIHRoaXNwID0gdGhpcykge1xuICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLnJpbmRleGVzKCkpIHtcbiAgICAgIGZuLmNhbGwodGhpc3AsIHRoaXMudmFsTGlzdFtpXSwgdGhpcy5rZXlMaXN0W2ldLCB0aGlzKVxuICAgIH1cbiAgfVxuXG4gIGdldCBwcnVuZSAoKSB7XG4gICAgZGVwcmVjYXRlZE1ldGhvZCgncHJ1bmUnLCAncHVyZ2VTdGFsZScpXG4gICAgcmV0dXJuIHRoaXMucHVyZ2VTdGFsZVxuICB9XG5cbiAgcHVyZ2VTdGFsZSAoKSB7XG4gICAgbGV0IGRlbGV0ZWQgPSBmYWxzZVxuICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLnJpbmRleGVzKHsgYWxsb3dTdGFsZTogdHJ1ZSB9KSkge1xuICAgICAgaWYgKHRoaXMuaXNTdGFsZShpKSkge1xuICAgICAgICB0aGlzLmRlbGV0ZSh0aGlzLmtleUxpc3RbaV0pXG4gICAgICAgIGRlbGV0ZWQgPSB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZWxldGVkXG4gIH1cblxuICBkdW1wICgpIHtcbiAgICBjb25zdCBhcnIgPSBbXVxuICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLmluZGV4ZXMoKSkge1xuICAgICAgY29uc3Qga2V5ID0gdGhpcy5rZXlMaXN0W2ldXG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMudmFsTGlzdFtpXVxuICAgICAgY29uc3QgZW50cnkgPSB7IHZhbHVlIH1cbiAgICAgIGlmICh0aGlzLnR0bHMpIHtcbiAgICAgICAgZW50cnkudHRsID0gdGhpcy50dGxzW2ldXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zaXplcykge1xuICAgICAgICBlbnRyeS5zaXplID0gdGhpcy5zaXplc1tpXVxuICAgICAgfVxuICAgICAgYXJyLnVuc2hpZnQoW2tleSwgZW50cnldKVxuICAgIH1cbiAgICByZXR1cm4gYXJyXG4gIH1cblxuICBsb2FkIChhcnIpIHtcbiAgICB0aGlzLmNsZWFyKClcbiAgICBmb3IgKGNvbnN0IFtrZXksIGVudHJ5XSBvZiBhcnIpIHtcbiAgICAgIHRoaXMuc2V0KGtleSwgZW50cnkudmFsdWUsIGVudHJ5KVxuICAgIH1cbiAgfVxuXG4gIGRpc3Bvc2UgKHYsIGssIHJlYXNvbikge31cblxuICBzZXQgKGssIHYsIHtcbiAgICB0dGwgPSB0aGlzLnR0bCxcbiAgICBub0Rpc3Bvc2VPblNldCA9IHRoaXMubm9EaXNwb3NlT25TZXQsXG4gICAgc2l6ZSA9IDAsXG4gICAgc2l6ZUNhbGN1bGF0aW9uID0gdGhpcy5zaXplQ2FsY3VsYXRpb24sXG4gICAgbm9VcGRhdGVUVEwgPSB0aGlzLm5vVXBkYXRlVFRMLFxuICB9ID0ge30pIHtcbiAgICBzaXplID0gdGhpcy5yZXF1aXJlU2l6ZShrLCB2LCBzaXplLCBzaXplQ2FsY3VsYXRpb24pXG4gICAgbGV0IGluZGV4ID0gdGhpcy5zaXplID09PSAwID8gdW5kZWZpbmVkIDogdGhpcy5rZXlNYXAuZ2V0KGspXG4gICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGFkZGl0aW9uXG4gICAgICBpbmRleCA9IHRoaXMubmV3SW5kZXgoKVxuICAgICAgdGhpcy5rZXlMaXN0W2luZGV4XSA9IGtcbiAgICAgIHRoaXMudmFsTGlzdFtpbmRleF0gPSB2XG4gICAgICB0aGlzLmtleU1hcC5zZXQoaywgaW5kZXgpXG4gICAgICB0aGlzLm5leHRbdGhpcy50YWlsXSA9IGluZGV4XG4gICAgICB0aGlzLnByZXZbaW5kZXhdID0gdGhpcy50YWlsXG4gICAgICB0aGlzLnRhaWwgPSBpbmRleFxuICAgICAgdGhpcy5zaXplICsrXG4gICAgICB0aGlzLmFkZEl0ZW1TaXplKGluZGV4LCB2LCBrLCBzaXplKVxuICAgICAgbm9VcGRhdGVUVEwgPSBmYWxzZVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1cGRhdGVcbiAgICAgIGNvbnN0IG9sZFZhbCA9IHRoaXMudmFsTGlzdFtpbmRleF1cbiAgICAgIGlmICh2ICE9PSBvbGRWYWwpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNCYWNrZ3JvdW5kRmV0Y2gob2xkVmFsKSkge1xuICAgICAgICAgIG9sZFZhbC5fX2Fib3J0Q29udHJvbGxlci5hYm9ydCgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFub0Rpc3Bvc2VPblNldCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlKG9sZFZhbCwgaywgJ3NldCcpXG4gICAgICAgICAgICBpZiAodGhpcy5kaXNwb3NlQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlZC5wdXNoKFtvbGRWYWwsIGssICdzZXQnXSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVJdGVtU2l6ZShpbmRleClcbiAgICAgICAgdGhpcy52YWxMaXN0W2luZGV4XSA9IHZcbiAgICAgICAgdGhpcy5hZGRJdGVtU2l6ZShpbmRleCwgdiwgaywgc2l6ZSlcbiAgICAgIH1cbiAgICAgIHRoaXMubW92ZVRvVGFpbChpbmRleClcbiAgICB9XG4gICAgaWYgKHR0bCAhPT0gMCAmJiB0aGlzLnR0bCA9PT0gMCAmJiAhdGhpcy50dGxzKSB7XG4gICAgICB0aGlzLmluaXRpYWxpemVUVExUcmFja2luZygpXG4gICAgfVxuICAgIGlmICghbm9VcGRhdGVUVEwpIHtcbiAgICAgIHRoaXMuc2V0SXRlbVRUTChpbmRleCwgdHRsKVxuICAgIH1cbiAgICBpZiAodGhpcy5kaXNwb3NlQWZ0ZXIpIHtcbiAgICAgIHdoaWxlICh0aGlzLmRpc3Bvc2VkLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmRpc3Bvc2VBZnRlciguLi50aGlzLmRpc3Bvc2VkLnNoaWZ0KCkpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBuZXdJbmRleCAoKSB7XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMudGFpbFxuICAgIH1cbiAgICBpZiAodGhpcy5zaXplID09PSB0aGlzLm1heCAmJiB0aGlzLm1heCAhPT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuZXZpY3QoZmFsc2UpXG4gICAgfVxuICAgIGlmICh0aGlzLmZyZWUubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5mcmVlLnBvcCgpXG4gICAgfVxuICAgIC8vIGluaXRpYWwgZmlsbCwganVzdCBrZWVwIHdyaXRpbmcgZG93biB0aGUgbGlzdFxuICAgIHJldHVybiB0aGlzLmluaXRpYWxGaWxsKytcbiAgfVxuXG4gIHBvcCAoKSB7XG4gICAgaWYgKHRoaXMuc2l6ZSkge1xuICAgICAgY29uc3QgdmFsID0gdGhpcy52YWxMaXN0W3RoaXMuaGVhZF1cbiAgICAgIHRoaXMuZXZpY3QodHJ1ZSlcbiAgICAgIHJldHVybiB2YWxcbiAgICB9XG4gIH1cblxuICBldmljdCAoZnJlZSkge1xuICAgIGNvbnN0IGhlYWQgPSB0aGlzLmhlYWRcbiAgICBjb25zdCBrID0gdGhpcy5rZXlMaXN0W2hlYWRdXG4gICAgY29uc3QgdiA9IHRoaXMudmFsTGlzdFtoZWFkXVxuICAgIGlmICh0aGlzLmlzQmFja2dyb3VuZEZldGNoKHYpKSB7XG4gICAgICB2Ll9fYWJvcnRDb250cm9sbGVyLmFib3J0KClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXNwb3NlKHYsIGssICdldmljdCcpXG4gICAgICBpZiAodGhpcy5kaXNwb3NlQWZ0ZXIpIHtcbiAgICAgICAgdGhpcy5kaXNwb3NlZC5wdXNoKFt2LCBrLCAnZXZpY3QnXSlcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5yZW1vdmVJdGVtU2l6ZShoZWFkKVxuICAgIC8vIGlmIHdlIGFyZW4ndCBhYm91dCB0byB1c2UgdGhlIGluZGV4LCB0aGVuIG51bGwgdGhlc2Ugb3V0XG4gICAgaWYgKGZyZWUpIHtcbiAgICAgIHRoaXMua2V5TGlzdFtoZWFkXSA9IG51bGxcbiAgICAgIHRoaXMudmFsTGlzdFtoZWFkXSA9IG51bGxcbiAgICAgIHRoaXMuZnJlZS5wdXNoKGhlYWQpXG4gICAgfVxuICAgIHRoaXMuaGVhZCA9IHRoaXMubmV4dFtoZWFkXVxuICAgIHRoaXMua2V5TWFwLmRlbGV0ZShrKVxuICAgIHRoaXMuc2l6ZSAtLVxuICAgIHJldHVybiBoZWFkXG4gIH1cblxuICBoYXMgKGssIHsgdXBkYXRlQWdlT25IYXMgPSB0aGlzLnVwZGF0ZUFnZU9uSGFzIH0gPSB7fSkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5rZXlNYXAuZ2V0KGspXG4gICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICghdGhpcy5pc1N0YWxlKGluZGV4KSkge1xuICAgICAgICBpZiAodXBkYXRlQWdlT25IYXMpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUl0ZW1BZ2UoaW5kZXgpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBsaWtlIGdldCgpLCBidXQgd2l0aG91dCBhbnkgTFJVIHVwZGF0aW5nIG9yIFRUTCBleHBpcmF0aW9uXG4gIHBlZWsgKGssIHsgYWxsb3dTdGFsZSA9IHRoaXMuYWxsb3dTdGFsZSB9ID0ge30pIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMua2V5TWFwLmdldChrKVxuICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkICYmIChhbGxvd1N0YWxlIHx8ICF0aGlzLmlzU3RhbGUoaW5kZXgpKSkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsTGlzdFtpbmRleF1cbiAgICB9XG4gIH1cblxuICBiYWNrZ3JvdW5kRmV0Y2ggKGssIGluZGV4LCBvcHRpb25zKSB7XG4gICAgY29uc3QgdiA9IGluZGV4ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiB0aGlzLnZhbExpc3RbaW5kZXhdXG4gICAgaWYgKHRoaXMuaXNCYWNrZ3JvdW5kRmV0Y2godikpIHtcbiAgICAgIHJldHVybiB2XG4gICAgfVxuICAgIGNvbnN0IGFjID0gbmV3IEFDKClcbiAgICBjb25zdCBmZXRjaE9wdHMgPSB7XG4gICAgICBzaWduYWw6IGFjLnNpZ25hbCxcbiAgICAgIG9wdGlvbnMsXG4gICAgfVxuICAgIGNvbnN0IHAgPSBQcm9taXNlLnJlc29sdmUodGhpcy5mZXRjaE1ldGhvZChrLCB2LCBmZXRjaE9wdHMpKS50aGVuKHYgPT4ge1xuICAgICAgaWYgKCFhYy5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICB0aGlzLnNldChrLCB2LCBmZXRjaE9wdHMub3B0aW9ucylcbiAgICAgIH1cbiAgICAgIHJldHVybiB2XG4gICAgfSlcbiAgICBwLl9fYWJvcnRDb250cm9sbGVyID0gYWNcbiAgICBwLl9fc3RhbGVXaGlsZUZldGNoaW5nID0gdlxuICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnNldChrLCBwLCBmZXRjaE9wdHMub3B0aW9ucylcbiAgICAgIGluZGV4ID0gdGhpcy5rZXlNYXAuZ2V0KGspXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudmFsTGlzdFtpbmRleF0gPSBwXG4gICAgfVxuICAgIHJldHVybiBwXG4gIH1cblxuICBpc0JhY2tncm91bmRGZXRjaCAocCkge1xuICAgIHJldHVybiBwICYmIHR5cGVvZiBwID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcC50aGVuID09PSAnZnVuY3Rpb24nICYmXG4gICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocCwgJ19fc3RhbGVXaGlsZUZldGNoaW5nJylcbiAgfVxuXG4gIC8vIHRoaXMgdGFrZXMgdGhlIHVuaW9uIG9mIGdldCgpIGFuZCBzZXQoKSBvcHRzLCBiZWNhdXNlIGl0IGRvZXMgYm90aFxuICBhc3luYyBmZXRjaCAoaywge1xuICAgIGFsbG93U3RhbGUgPSB0aGlzLmFsbG93U3RhbGUsXG4gICAgdXBkYXRlQWdlT25HZXQgPSB0aGlzLnVwZGF0ZUFnZU9uR2V0LFxuICAgIHR0bCA9IHRoaXMudHRsLFxuICAgIG5vRGlzcG9zZU9uU2V0ID0gdGhpcy5ub0Rpc3Bvc2VPblNldCxcbiAgICBzaXplID0gMCxcbiAgICBzaXplQ2FsY3VsYXRpb24gPSB0aGlzLnNpemVDYWxjdWxhdGlvbixcbiAgICBub1VwZGF0ZVRUTCA9IHRoaXMubm9VcGRhdGVUVEwsXG4gIH0gPSB7fSkge1xuICAgIGlmICghdGhpcy5mZXRjaE1ldGhvZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KGssIHthbGxvd1N0YWxlLCB1cGRhdGVBZ2VPbkdldH0pXG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIGFsbG93U3RhbGUsXG4gICAgICB1cGRhdGVBZ2VPbkdldCxcbiAgICAgIHR0bCxcbiAgICAgIG5vRGlzcG9zZU9uU2V0LFxuICAgICAgc2l6ZSxcbiAgICAgIHNpemVDYWxjdWxhdGlvbixcbiAgICAgIG5vVXBkYXRlVFRMLFxuICAgIH1cblxuICAgIGxldCBpbmRleCA9IHRoaXMua2V5TWFwLmdldChrKVxuICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5iYWNrZ3JvdW5kRmV0Y2goaywgaW5kZXgsIG9wdGlvbnMpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGluIGNhY2hlLCBtYXliZSBhbHJlYWR5IGZldGNoaW5nXG4gICAgICBjb25zdCB2ID0gdGhpcy52YWxMaXN0W2luZGV4XVxuICAgICAgaWYgKHRoaXMuaXNCYWNrZ3JvdW5kRmV0Y2godikpIHtcbiAgICAgICAgcmV0dXJuIGFsbG93U3RhbGUgJiYgdi5fX3N0YWxlV2hpbGVGZXRjaGluZyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyB2Ll9fc3RhbGVXaGlsZUZldGNoaW5nIDogdlxuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuaXNTdGFsZShpbmRleCkpIHtcbiAgICAgICAgdGhpcy5tb3ZlVG9UYWlsKGluZGV4KVxuICAgICAgICBpZiAodXBkYXRlQWdlT25HZXQpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUl0ZW1BZ2UoaW5kZXgpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZcbiAgICAgIH1cblxuICAgICAgLy8gb2ssIGl0IGlzIHN0YWxlLCBhbmQgbm90IGFscmVhZHkgZmV0Y2hpbmdcbiAgICAgIC8vIHJlZnJlc2ggdGhlIGNhY2hlLlxuICAgICAgY29uc3QgcCA9IHRoaXMuYmFja2dyb3VuZEZldGNoKGssIGluZGV4LCBvcHRpb25zKVxuICAgICAgcmV0dXJuIGFsbG93U3RhbGUgJiYgcC5fX3N0YWxlV2hpbGVGZXRjaGluZyAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gcC5fX3N0YWxlV2hpbGVGZXRjaGluZyA6IHBcbiAgICB9XG4gIH1cblxuICBnZXQgKGssIHtcbiAgICBhbGxvd1N0YWxlID0gdGhpcy5hbGxvd1N0YWxlLFxuICAgIHVwZGF0ZUFnZU9uR2V0ID0gdGhpcy51cGRhdGVBZ2VPbkdldCxcbiAgfSA9IHt9KSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmtleU1hcC5nZXQoaylcbiAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnZhbExpc3RbaW5kZXhdXG4gICAgICBjb25zdCBmZXRjaGluZyA9IHRoaXMuaXNCYWNrZ3JvdW5kRmV0Y2godmFsdWUpXG4gICAgICBpZiAodGhpcy5pc1N0YWxlKGluZGV4KSkge1xuICAgICAgICAvLyBkZWxldGUgb25seSBpZiBub3QgYW4gaW4tZmxpZ2h0IGJhY2tncm91bmQgZmV0Y2hcbiAgICAgICAgaWYgKCFmZXRjaGluZykge1xuICAgICAgICAgIHRoaXMuZGVsZXRlKGspXG4gICAgICAgICAgcmV0dXJuIGFsbG93U3RhbGUgPyB2YWx1ZSA6IHVuZGVmaW5lZFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBhbGxvd1N0YWxlID8gdmFsdWUuX19zdGFsZVdoaWxlRmV0Y2hpbmcgOiB1bmRlZmluZWRcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgd2UncmUgY3VycmVudGx5IGZldGNoaW5nIGl0LCB3ZSBkb24ndCBhY3R1YWxseSBoYXZlIGl0IHlldFxuICAgICAgICAvLyBpdCdzIG5vdCBzdGFsZSwgd2hpY2ggbWVhbnMgdGhpcyBpc24ndCBhIHN0YWxlV2hpbGVSZWZldGNoaW5nLFxuICAgICAgICAvLyBzbyB3ZSBqdXN0IHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYgKGZldGNoaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICB9XG4gICAgICAgIHRoaXMubW92ZVRvVGFpbChpbmRleClcbiAgICAgICAgaWYgKHVwZGF0ZUFnZU9uR2V0KSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVJdGVtQWdlKGluZGV4KVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3QgKHAsIG4pIHtcbiAgICB0aGlzLnByZXZbbl0gPSBwXG4gICAgdGhpcy5uZXh0W3BdID0gblxuICB9XG5cbiAgbW92ZVRvVGFpbCAoaW5kZXgpIHtcbiAgICAvLyBpZiB0YWlsIGFscmVhZHksIG5vdGhpbmcgdG8gZG9cbiAgICAvLyBpZiBoZWFkLCBtb3ZlIGhlYWQgdG8gbmV4dFtpbmRleF1cbiAgICAvLyBlbHNlXG4gICAgLy8gICBtb3ZlIG5leHRbcHJldltpbmRleF1dIHRvIG5leHRbaW5kZXhdIChoZWFkIGhhcyBubyBwcmV2KVxuICAgIC8vICAgbW92ZSBwcmV2W25leHRbaW5kZXhdXSB0byBwcmV2W2luZGV4XVxuICAgIC8vIHByZXZbaW5kZXhdID0gdGFpbFxuICAgIC8vIG5leHRbdGFpbF0gPSBpbmRleFxuICAgIC8vIHRhaWwgPSBpbmRleFxuICAgIGlmIChpbmRleCAhPT0gdGhpcy50YWlsKSB7XG4gICAgICBpZiAoaW5kZXggPT09IHRoaXMuaGVhZCkge1xuICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLm5leHRbaW5kZXhdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbm5lY3QodGhpcy5wcmV2W2luZGV4XSwgdGhpcy5uZXh0W2luZGV4XSlcbiAgICAgIH1cbiAgICAgIHRoaXMuY29ubmVjdCh0aGlzLnRhaWwsIGluZGV4KVxuICAgICAgdGhpcy50YWlsID0gaW5kZXhcbiAgICB9XG4gIH1cblxuICBnZXQgZGVsICgpIHtcbiAgICBkZXByZWNhdGVkTWV0aG9kKCdkZWwnLCAnZGVsZXRlJylcbiAgICByZXR1cm4gdGhpcy5kZWxldGVcbiAgfVxuXG4gIGRlbGV0ZSAoaykge1xuICAgIGxldCBkZWxldGVkID0gZmFsc2VcbiAgICBpZiAodGhpcy5zaXplICE9PSAwKSB7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMua2V5TWFwLmdldChrKVxuICAgICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVsZXRlZCA9IHRydWVcbiAgICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMSkge1xuICAgICAgICAgIHRoaXMuY2xlYXIoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVtb3ZlSXRlbVNpemUoaW5kZXgpXG4gICAgICAgICAgY29uc3QgdiA9IHRoaXMudmFsTGlzdFtpbmRleF1cbiAgICAgICAgICBpZiAodGhpcy5pc0JhY2tncm91bmRGZXRjaCh2KSkge1xuICAgICAgICAgICAgdi5fX2Fib3J0Q29udHJvbGxlci5hYm9ydCgpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZSh2LCBrLCAnZGVsZXRlJylcbiAgICAgICAgICAgIGlmICh0aGlzLmRpc3Bvc2VBZnRlcikge1xuICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2VkLnB1c2goW3YsIGssICdkZWxldGUnXSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5rZXlNYXAuZGVsZXRlKGspXG4gICAgICAgICAgdGhpcy5rZXlMaXN0W2luZGV4XSA9IG51bGxcbiAgICAgICAgICB0aGlzLnZhbExpc3RbaW5kZXhdID0gbnVsbFxuICAgICAgICAgIGlmIChpbmRleCA9PT0gdGhpcy50YWlsKSB7XG4gICAgICAgICAgICB0aGlzLnRhaWwgPSB0aGlzLnByZXZbaW5kZXhdXG4gICAgICAgICAgfSBlbHNlIGlmIChpbmRleCA9PT0gdGhpcy5oZWFkKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLm5leHRbaW5kZXhdXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubmV4dFt0aGlzLnByZXZbaW5kZXhdXSA9IHRoaXMubmV4dFtpbmRleF1cbiAgICAgICAgICAgIHRoaXMucHJldlt0aGlzLm5leHRbaW5kZXhdXSA9IHRoaXMucHJldltpbmRleF1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zaXplIC0tXG4gICAgICAgICAgdGhpcy5mcmVlLnB1c2goaW5kZXgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuZGlzcG9zZWQpIHtcbiAgICAgIHdoaWxlICh0aGlzLmRpc3Bvc2VkLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmRpc3Bvc2VBZnRlciguLi50aGlzLmRpc3Bvc2VkLnNoaWZ0KCkpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZWxldGVkXG4gIH1cblxuICBjbGVhciAoKSB7XG4gICAgZm9yIChjb25zdCBpbmRleCBvZiB0aGlzLnJpbmRleGVzKHsgYWxsb3dTdGFsZTogdHJ1ZSB9KSkge1xuICAgICAgY29uc3QgdiA9IHRoaXMudmFsTGlzdFtpbmRleF1cbiAgICAgIGlmICh0aGlzLmlzQmFja2dyb3VuZEZldGNoKHYpKSB7XG4gICAgICAgIHYuX19hYm9ydENvbnRyb2xsZXIuYWJvcnQoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgayA9IHRoaXMua2V5TGlzdFtpbmRleF1cbiAgICAgICAgdGhpcy5kaXNwb3NlKHYsIGssICdkZWxldGUnKVxuICAgICAgICBpZiAodGhpcy5kaXNwb3NlQWZ0ZXIpIHtcbiAgICAgICAgICB0aGlzLmRpc3Bvc2VkLnB1c2goW3YsIGssICdkZWxldGUnXSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMua2V5TWFwLmNsZWFyKClcbiAgICB0aGlzLnZhbExpc3QuZmlsbChudWxsKVxuICAgIHRoaXMua2V5TGlzdC5maWxsKG51bGwpXG4gICAgaWYgKHRoaXMudHRscykge1xuICAgICAgdGhpcy50dGxzLmZpbGwoMClcbiAgICAgIHRoaXMuc3RhcnRzLmZpbGwoMClcbiAgICB9XG4gICAgaWYgKHRoaXMuc2l6ZXMpIHtcbiAgICAgIHRoaXMuc2l6ZXMuZmlsbCgwKVxuICAgIH1cbiAgICB0aGlzLmhlYWQgPSAwXG4gICAgdGhpcy50YWlsID0gMFxuICAgIHRoaXMuaW5pdGlhbEZpbGwgPSAxXG4gICAgdGhpcy5mcmVlLmxlbmd0aCA9IDBcbiAgICB0aGlzLmNhbGN1bGF0ZWRTaXplID0gMFxuICAgIHRoaXMuc2l6ZSA9IDBcbiAgICBpZiAodGhpcy5kaXNwb3NlZCkge1xuICAgICAgd2hpbGUgKHRoaXMuZGlzcG9zZWQubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuZGlzcG9zZUFmdGVyKC4uLnRoaXMuZGlzcG9zZWQuc2hpZnQoKSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXQgcmVzZXQgKCkge1xuICAgIGRlcHJlY2F0ZWRNZXRob2QoJ3Jlc2V0JywgJ2NsZWFyJylcbiAgICByZXR1cm4gdGhpcy5jbGVhclxuICB9XG5cbiAgZ2V0IGxlbmd0aCAoKSB7XG4gICAgZGVwcmVjYXRlZFByb3BlcnR5KCdsZW5ndGgnLCAnc2l6ZScpXG4gICAgcmV0dXJuIHRoaXMuc2l6ZVxuICB9XG5cbiAgc3RhdGljIGdldCBBYm9ydENvbnRyb2xsZXIgKCkge1xuICAgIHJldHVybiBBQ1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTFJVQ2FjaGVcbiIsImltcG9ydCB7IF9fYXNzaWduLCBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IFN1YmplY3QsIEFub255bW91c1N1YmplY3QgfSBmcm9tICcuLi8uLi9TdWJqZWN0JztcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi8uLi9TdWJzY3JpYmVyJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJy4uLy4uL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBSZXBsYXlTdWJqZWN0IH0gZnJvbSAnLi4vLi4vUmVwbGF5U3ViamVjdCc7XG52YXIgREVGQVVMVF9XRUJTT0NLRVRfQ09ORklHID0ge1xuICAgIHVybDogJycsXG4gICAgZGVzZXJpYWxpemVyOiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gSlNPTi5wYXJzZShlLmRhdGEpOyB9LFxuICAgIHNlcmlhbGl6ZXI6IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpOyB9LFxufTtcbnZhciBXRUJTT0NLRVRTVUJKRUNUX0lOVkFMSURfRVJST1JfT0JKRUNUID0gJ1dlYlNvY2tldFN1YmplY3QuZXJyb3IgbXVzdCBiZSBjYWxsZWQgd2l0aCBhbiBvYmplY3Qgd2l0aCBhbiBlcnJvciBjb2RlLCBhbmQgYW4gb3B0aW9uYWwgcmVhc29uOiB7IGNvZGU6IG51bWJlciwgcmVhc29uOiBzdHJpbmcgfSc7XG52YXIgV2ViU29ja2V0U3ViamVjdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFdlYlNvY2tldFN1YmplY3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gV2ViU29ja2V0U3ViamVjdCh1cmxDb25maWdPclNvdXJjZSwgZGVzdGluYXRpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3NvY2tldCA9IG51bGw7XG4gICAgICAgIGlmICh1cmxDb25maWdPclNvdXJjZSBpbnN0YW5jZW9mIE9ic2VydmFibGUpIHtcbiAgICAgICAgICAgIF90aGlzLmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb247XG4gICAgICAgICAgICBfdGhpcy5zb3VyY2UgPSB1cmxDb25maWdPclNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjb25maWcgPSAoX3RoaXMuX2NvbmZpZyA9IF9fYXNzaWduKHt9LCBERUZBVUxUX1dFQlNPQ0tFVF9DT05GSUcpKTtcbiAgICAgICAgICAgIF90aGlzLl9vdXRwdXQgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB1cmxDb25maWdPclNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb25maWcudXJsID0gdXJsQ29uZmlnT3JTb3VyY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdXJsQ29uZmlnT3JTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVybENvbmZpZ09yU291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ1trZXldID0gdXJsQ29uZmlnT3JTb3VyY2Vba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY29uZmlnLldlYlNvY2tldEN0b3IgJiYgV2ViU29ja2V0KSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLldlYlNvY2tldEN0b3IgPSBXZWJTb2NrZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghY29uZmlnLldlYlNvY2tldEN0b3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIFdlYlNvY2tldCBjb25zdHJ1Y3RvciBjYW4gYmUgZm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmRlc3RpbmF0aW9uID0gbmV3IFJlcGxheVN1YmplY3QoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFdlYlNvY2tldFN1YmplY3QucHJvdG90eXBlLmxpZnQgPSBmdW5jdGlvbiAob3BlcmF0b3IpIHtcbiAgICAgICAgdmFyIHNvY2sgPSBuZXcgV2ViU29ja2V0U3ViamVjdCh0aGlzLl9jb25maWcsIHRoaXMuZGVzdGluYXRpb24pO1xuICAgICAgICBzb2NrLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgIHNvY2suc291cmNlID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHNvY2s7XG4gICAgfTtcbiAgICBXZWJTb2NrZXRTdWJqZWN0LnByb3RvdHlwZS5fcmVzZXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fc29ja2V0ID0gbnVsbDtcbiAgICAgICAgaWYgKCF0aGlzLnNvdXJjZSkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBSZXBsYXlTdWJqZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb3V0cHV0ID0gbmV3IFN1YmplY3QoKTtcbiAgICB9O1xuICAgIFdlYlNvY2tldFN1YmplY3QucHJvdG90eXBlLm11bHRpcGxleCA9IGZ1bmN0aW9uIChzdWJNc2csIHVuc3ViTXNnLCBtZXNzYWdlRmlsdGVyKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzZWxmLm5leHQoc3ViTXNnKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gc2VsZi5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZUZpbHRlcih4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIG9ic2VydmVyLmVycm9yKGVycik7IH0sXG4gICAgICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9ic2VydmVyLmNvbXBsZXRlKCk7IH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5uZXh0KHVuc3ViTXNnKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBXZWJTb2NrZXRTdWJqZWN0LnByb3RvdHlwZS5fY29ubmVjdFNvY2tldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5fY29uZmlnLCBXZWJTb2NrZXRDdG9yID0gX2EuV2ViU29ja2V0Q3RvciwgcHJvdG9jb2wgPSBfYS5wcm90b2NvbCwgdXJsID0gX2EudXJsLCBiaW5hcnlUeXBlID0gX2EuYmluYXJ5VHlwZTtcbiAgICAgICAgdmFyIG9ic2VydmVyID0gdGhpcy5fb3V0cHV0O1xuICAgICAgICB2YXIgc29ja2V0ID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNvY2tldCA9IHByb3RvY29sID8gbmV3IFdlYlNvY2tldEN0b3IodXJsLCBwcm90b2NvbCkgOiBuZXcgV2ViU29ja2V0Q3Rvcih1cmwpO1xuICAgICAgICAgICAgdGhpcy5fc29ja2V0ID0gc29ja2V0O1xuICAgICAgICAgICAgaWYgKGJpbmFyeVR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zb2NrZXQuYmluYXJ5VHlwZSA9IGJpbmFyeVR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9zb2NrZXQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHNvY2tldCAmJiBzb2NrZXQucmVhZHlTdGF0ZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc29ja2V0Lm9ub3BlbiA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgIHZhciBfc29ja2V0ID0gX3RoaXMuX3NvY2tldDtcbiAgICAgICAgICAgIGlmICghX3NvY2tldCkge1xuICAgICAgICAgICAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9yZXNldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG9wZW5PYnNlcnZlciA9IF90aGlzLl9jb25maWcub3Blbk9ic2VydmVyO1xuICAgICAgICAgICAgaWYgKG9wZW5PYnNlcnZlcikge1xuICAgICAgICAgICAgICAgIG9wZW5PYnNlcnZlci5uZXh0KGV2dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcXVldWUgPSBfdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgICAgIF90aGlzLmRlc3RpbmF0aW9uID0gU3Vic2NyaWJlci5jcmVhdGUoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc29ja2V0LnJlYWR5U3RhdGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZXJpYWxpemVyID0gX3RoaXMuX2NvbmZpZy5zZXJpYWxpemVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0LnNlbmQoc2VyaWFsaXplcih4KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmRlc3RpbmF0aW9uLmVycm9yKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIHZhciBjbG9zaW5nT2JzZXJ2ZXIgPSBfdGhpcy5fY29uZmlnLmNsb3NpbmdPYnNlcnZlcjtcbiAgICAgICAgICAgICAgICBpZiAoY2xvc2luZ09ic2VydmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3NpbmdPYnNlcnZlci5uZXh0KHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlcnIgJiYgZXJyLmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LmNsb3NlKGVyci5jb2RlLCBlcnIucmVhc29uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKG5ldyBUeXBlRXJyb3IoV0VCU09DS0VUU1VCSkVDVF9JTlZBTElEX0VSUk9SX09CSkVDVCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5fcmVzZXRTdGF0ZSgpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBjbG9zaW5nT2JzZXJ2ZXIgPSBfdGhpcy5fY29uZmlnLmNsb3NpbmdPYnNlcnZlcjtcbiAgICAgICAgICAgICAgICBpZiAoY2xvc2luZ09ic2VydmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3NpbmdPYnNlcnZlci5uZXh0KHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9yZXNldFN0YXRlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChxdWV1ZSAmJiBxdWV1ZSBpbnN0YW5jZW9mIFJlcGxheVN1YmplY3QpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24uYWRkKHF1ZXVlLnN1YnNjcmliZShfdGhpcy5kZXN0aW5hdGlvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBzb2NrZXQub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBfdGhpcy5fcmVzZXRTdGF0ZSgpO1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgICAgIH07XG4gICAgICAgIHNvY2tldC5vbmNsb3NlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmIChzb2NrZXQgPT09IF90aGlzLl9zb2NrZXQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcmVzZXRTdGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNsb3NlT2JzZXJ2ZXIgPSBfdGhpcy5fY29uZmlnLmNsb3NlT2JzZXJ2ZXI7XG4gICAgICAgICAgICBpZiAoY2xvc2VPYnNlcnZlcikge1xuICAgICAgICAgICAgICAgIGNsb3NlT2JzZXJ2ZXIubmV4dChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlLndhc0NsZWFuKSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBzb2NrZXQub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlc2VyaWFsaXplciA9IF90aGlzLl9jb25maWcuZGVzZXJpYWxpemVyO1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoZGVzZXJpYWxpemVyKGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgV2ViU29ja2V0U3ViamVjdC5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9zb2NrZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3RTb2NrZXQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vdXRwdXQuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICBzdWJzY3JpYmVyLmFkZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3NvY2tldCA9IF90aGlzLl9zb2NrZXQ7XG4gICAgICAgICAgICBpZiAoX3RoaXMuX291dHB1dC5vYnNlcnZlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9zb2NrZXQgJiYgKF9zb2NrZXQucmVhZHlTdGF0ZSA9PT0gMSB8fCBfc29ja2V0LnJlYWR5U3RhdGUgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIF9zb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuX3Jlc2V0U3RhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVyO1xuICAgIH07XG4gICAgV2ViU29ja2V0U3ViamVjdC5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfc29ja2V0ID0gdGhpcy5fc29ja2V0O1xuICAgICAgICBpZiAoX3NvY2tldCAmJiAoX3NvY2tldC5yZWFkeVN0YXRlID09PSAxIHx8IF9zb2NrZXQucmVhZHlTdGF0ZSA9PT0gMCkpIHtcbiAgICAgICAgICAgIF9zb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXNldFN0YXRlKCk7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudW5zdWJzY3JpYmUuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBXZWJTb2NrZXRTdWJqZWN0O1xufShBbm9ueW1vdXNTdWJqZWN0KSk7XG5leHBvcnQgeyBXZWJTb2NrZXRTdWJqZWN0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1XZWJTb2NrZXRTdWJqZWN0LmpzLm1hcCIsImltcG9ydCB7IFdlYlNvY2tldFN1YmplY3QgfSBmcm9tICcuL1dlYlNvY2tldFN1YmplY3QnO1xuZXhwb3J0IGZ1bmN0aW9uIHdlYlNvY2tldCh1cmxDb25maWdPclNvdXJjZSkge1xuICAgIHJldHVybiBuZXcgV2ViU29ja2V0U3ViamVjdCh1cmxDb25maWdPclNvdXJjZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWJTb2NrZXQuanMubWFwIiwiaW1wb3J0IHZhbGlkYXRlIGZyb20gJy4vdmFsaWRhdGUuanMnO1xuXG5mdW5jdGlvbiBwYXJzZSh1dWlkKSB7XG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0ludmFsaWQgVVVJRCcpO1xuICB9XG5cbiAgdmFyIHY7XG4gIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxNik7IC8vIFBhcnNlICMjIyMjIyMjLS4uLi4tLi4uLi0uLi4uLS4uLi4uLi4uLi4uLlxuXG4gIGFyclswXSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgwLCA4KSwgMTYpKSA+Pj4gMjQ7XG4gIGFyclsxXSA9IHYgPj4+IDE2ICYgMHhmZjtcbiAgYXJyWzJdID0gdiA+Pj4gOCAmIDB4ZmY7XG4gIGFyclszXSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0jIyMjLS4uLi4tLi4uLi0uLi4uLi4uLi4uLi5cblxuICBhcnJbNF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoOSwgMTMpLCAxNikpID4+PiA4O1xuICBhcnJbNV0gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tLi4uLi0jIyMjLS4uLi4tLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzZdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDE0LCAxOCksIDE2KSkgPj4+IDg7XG4gIGFycls3XSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0uLi4uLS4uLi4tIyMjIy0uLi4uLi4uLi4uLi5cblxuICBhcnJbOF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMTksIDIzKSwgMTYpKSA+Pj4gODtcbiAgYXJyWzldID0gdiAmIDB4ZmY7IC8vIFBhcnNlIC4uLi4uLi4uLS4uLi4tLi4uLi0uLi4uLSMjIyMjIyMjIyMjI1xuICAvLyAoVXNlIFwiL1wiIHRvIGF2b2lkIDMyLWJpdCB0cnVuY2F0aW9uIHdoZW4gYml0LXNoaWZ0aW5nIGhpZ2gtb3JkZXIgYnl0ZXMpXG5cbiAgYXJyWzEwXSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgyNCwgMzYpLCAxNikpIC8gMHgxMDAwMDAwMDAwMCAmIDB4ZmY7XG4gIGFyclsxMV0gPSB2IC8gMHgxMDAwMDAwMDAgJiAweGZmO1xuICBhcnJbMTJdID0gdiA+Pj4gMjQgJiAweGZmO1xuICBhcnJbMTNdID0gdiA+Pj4gMTYgJiAweGZmO1xuICBhcnJbMTRdID0gdiA+Pj4gOCAmIDB4ZmY7XG4gIGFyclsxNV0gPSB2ICYgMHhmZjtcbiAgcmV0dXJuIGFycjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcGFyc2U7IiwiLy8gQWRhcHRlZCBmcm9tIENocmlzIFZlbmVzcycgU0hBMSBjb2RlIGF0XG4vLyBodHRwOi8vd3d3Lm1vdmFibGUtdHlwZS5jby51ay9zY3JpcHRzL3NoYTEuaHRtbFxuZnVuY3Rpb24gZihzLCB4LCB5LCB6KSB7XG4gIHN3aXRjaCAocykge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiB4ICYgeSBeIH54ICYgejtcblxuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiB4IF4geSBeIHo7XG5cbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4geCAmIHkgXiB4ICYgeiBeIHkgJiB6O1xuXG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIHggXiB5IF4gejtcbiAgfVxufVxuXG5mdW5jdGlvbiBST1RMKHgsIG4pIHtcbiAgcmV0dXJuIHggPDwgbiB8IHggPj4+IDMyIC0gbjtcbn1cblxuZnVuY3Rpb24gc2hhMShieXRlcykge1xuICB2YXIgSyA9IFsweDVhODI3OTk5LCAweDZlZDllYmExLCAweDhmMWJiY2RjLCAweGNhNjJjMWQ2XTtcbiAgdmFyIEggPSBbMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSwgMHg5OGJhZGNmZSwgMHgxMDMyNTQ3NiwgMHhjM2QyZTFmMF07XG5cbiAgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgbXNnID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGJ5dGVzKSk7IC8vIFVURjggZXNjYXBlXG5cbiAgICBieXRlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyArK2kpIHtcbiAgICAgIGJ5dGVzLnB1c2gobXNnLmNoYXJDb2RlQXQoaSkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShieXRlcykpIHtcbiAgICAvLyBDb252ZXJ0IEFycmF5LWxpa2UgdG8gQXJyYXlcbiAgICBieXRlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGJ5dGVzKTtcbiAgfVxuXG4gIGJ5dGVzLnB1c2goMHg4MCk7XG4gIHZhciBsID0gYnl0ZXMubGVuZ3RoIC8gNCArIDI7XG4gIHZhciBOID0gTWF0aC5jZWlsKGwgLyAxNik7XG4gIHZhciBNID0gbmV3IEFycmF5KE4pO1xuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBOOyArK19pKSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50MzJBcnJheSgxNik7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IDE2OyArK2opIHtcbiAgICAgIGFycltqXSA9IGJ5dGVzW19pICogNjQgKyBqICogNF0gPDwgMjQgfCBieXRlc1tfaSAqIDY0ICsgaiAqIDQgKyAxXSA8PCAxNiB8IGJ5dGVzW19pICogNjQgKyBqICogNCArIDJdIDw8IDggfCBieXRlc1tfaSAqIDY0ICsgaiAqIDQgKyAzXTtcbiAgICB9XG5cbiAgICBNW19pXSA9IGFycjtcbiAgfVxuXG4gIE1bTiAtIDFdWzE0XSA9IChieXRlcy5sZW5ndGggLSAxKSAqIDggLyBNYXRoLnBvdygyLCAzMik7XG4gIE1bTiAtIDFdWzE0XSA9IE1hdGguZmxvb3IoTVtOIC0gMV1bMTRdKTtcbiAgTVtOIC0gMV1bMTVdID0gKGJ5dGVzLmxlbmd0aCAtIDEpICogOCAmIDB4ZmZmZmZmZmY7XG5cbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgTjsgKytfaTIpIHtcbiAgICB2YXIgVyA9IG5ldyBVaW50MzJBcnJheSg4MCk7XG5cbiAgICBmb3IgKHZhciB0ID0gMDsgdCA8IDE2OyArK3QpIHtcbiAgICAgIFdbdF0gPSBNW19pMl1bdF07XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX3QgPSAxNjsgX3QgPCA4MDsgKytfdCkge1xuICAgICAgV1tfdF0gPSBST1RMKFdbX3QgLSAzXSBeIFdbX3QgLSA4XSBeIFdbX3QgLSAxNF0gXiBXW190IC0gMTZdLCAxKTtcbiAgICB9XG5cbiAgICB2YXIgYSA9IEhbMF07XG4gICAgdmFyIGIgPSBIWzFdO1xuICAgIHZhciBjID0gSFsyXTtcbiAgICB2YXIgZCA9IEhbM107XG4gICAgdmFyIGUgPSBIWzRdO1xuXG4gICAgZm9yICh2YXIgX3QyID0gMDsgX3QyIDwgODA7ICsrX3QyKSB7XG4gICAgICB2YXIgcyA9IE1hdGguZmxvb3IoX3QyIC8gMjApO1xuICAgICAgdmFyIFQgPSBST1RMKGEsIDUpICsgZihzLCBiLCBjLCBkKSArIGUgKyBLW3NdICsgV1tfdDJdID4+PiAwO1xuICAgICAgZSA9IGQ7XG4gICAgICBkID0gYztcbiAgICAgIGMgPSBST1RMKGIsIDMwKSA+Pj4gMDtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IFQ7XG4gICAgfVxuXG4gICAgSFswXSA9IEhbMF0gKyBhID4+PiAwO1xuICAgIEhbMV0gPSBIWzFdICsgYiA+Pj4gMDtcbiAgICBIWzJdID0gSFsyXSArIGMgPj4+IDA7XG4gICAgSFszXSA9IEhbM10gKyBkID4+PiAwO1xuICAgIEhbNF0gPSBIWzRdICsgZSA+Pj4gMDtcbiAgfVxuXG4gIHJldHVybiBbSFswXSA+PiAyNCAmIDB4ZmYsIEhbMF0gPj4gMTYgJiAweGZmLCBIWzBdID4+IDggJiAweGZmLCBIWzBdICYgMHhmZiwgSFsxXSA+PiAyNCAmIDB4ZmYsIEhbMV0gPj4gMTYgJiAweGZmLCBIWzFdID4+IDggJiAweGZmLCBIWzFdICYgMHhmZiwgSFsyXSA+PiAyNCAmIDB4ZmYsIEhbMl0gPj4gMTYgJiAweGZmLCBIWzJdID4+IDggJiAweGZmLCBIWzJdICYgMHhmZiwgSFszXSA+PiAyNCAmIDB4ZmYsIEhbM10gPj4gMTYgJiAweGZmLCBIWzNdID4+IDggJiAweGZmLCBIWzNdICYgMHhmZiwgSFs0XSA+PiAyNCAmIDB4ZmYsIEhbNF0gPj4gMTYgJiAweGZmLCBIWzRdID4+IDggJiAweGZmLCBIWzRdICYgMHhmZl07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNoYTE7IiwiaW1wb3J0IHN0cmluZ2lmeSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5pbXBvcnQgcGFyc2UgZnJvbSAnLi9wYXJzZS5qcyc7XG5cbmZ1bmN0aW9uIHN0cmluZ1RvQnl0ZXMoc3RyKSB7XG4gIHN0ciA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKTsgLy8gVVRGOCBlc2NhcGVcblxuICB2YXIgYnl0ZXMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGJ5dGVzLnB1c2goc3RyLmNoYXJDb2RlQXQoaSkpO1xuICB9XG5cbiAgcmV0dXJuIGJ5dGVzO1xufVxuXG5leHBvcnQgdmFyIEROUyA9ICc2YmE3YjgxMC05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzgnO1xuZXhwb3J0IHZhciBVUkwgPSAnNmJhN2I4MTEtOWRhZC0xMWQxLTgwYjQtMDBjMDRmZDQzMGM4JztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChuYW1lLCB2ZXJzaW9uLCBoYXNoZnVuYykge1xuICBmdW5jdGlvbiBnZW5lcmF0ZVVVSUQodmFsdWUsIG5hbWVzcGFjZSwgYnVmLCBvZmZzZXQpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSBzdHJpbmdUb0J5dGVzKHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5hbWVzcGFjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWVzcGFjZSA9IHBhcnNlKG5hbWVzcGFjZSk7XG4gICAgfVxuXG4gICAgaWYgKG5hbWVzcGFjZS5sZW5ndGggIT09IDE2KSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ05hbWVzcGFjZSBtdXN0IGJlIGFycmF5LWxpa2UgKDE2IGl0ZXJhYmxlIGludGVnZXIgdmFsdWVzLCAwLTI1NSknKTtcbiAgICB9IC8vIENvbXB1dGUgaGFzaCBvZiBuYW1lc3BhY2UgYW5kIHZhbHVlLCBQZXIgNC4zXG4gICAgLy8gRnV0dXJlOiBVc2Ugc3ByZWFkIHN5bnRheCB3aGVuIHN1cHBvcnRlZCBvbiBhbGwgcGxhdGZvcm1zLCBlLmcuIGBieXRlcyA9XG4gICAgLy8gaGFzaGZ1bmMoWy4uLm5hbWVzcGFjZSwgLi4uIHZhbHVlXSlgXG5cblxuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KDE2ICsgdmFsdWUubGVuZ3RoKTtcbiAgICBieXRlcy5zZXQobmFtZXNwYWNlKTtcbiAgICBieXRlcy5zZXQodmFsdWUsIG5hbWVzcGFjZS5sZW5ndGgpO1xuICAgIGJ5dGVzID0gaGFzaGZ1bmMoYnl0ZXMpO1xuICAgIGJ5dGVzWzZdID0gYnl0ZXNbNl0gJiAweDBmIHwgdmVyc2lvbjtcbiAgICBieXRlc1s4XSA9IGJ5dGVzWzhdICYgMHgzZiB8IDB4ODA7XG5cbiAgICBpZiAoYnVmKSB7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IGJ5dGVzW2ldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnVmO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmdpZnkoYnl0ZXMpO1xuICB9IC8vIEZ1bmN0aW9uI25hbWUgaXMgbm90IHNldHRhYmxlIG9uIHNvbWUgcGxhdGZvcm1zICgjMjcwKVxuXG5cbiAgdHJ5IHtcbiAgICBnZW5lcmF0ZVVVSUQubmFtZSA9IG5hbWU7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICB9IGNhdGNoIChlcnIpIHt9IC8vIEZvciBDb21tb25KUyBkZWZhdWx0IGV4cG9ydCBzdXBwb3J0XG5cblxuICBnZW5lcmF0ZVVVSUQuRE5TID0gRE5TO1xuICBnZW5lcmF0ZVVVSUQuVVJMID0gVVJMO1xuICByZXR1cm4gZ2VuZXJhdGVVVUlEO1xufSIsImltcG9ydCB2MzUgZnJvbSAnLi92MzUuanMnO1xuaW1wb3J0IHNoYTEgZnJvbSAnLi9zaGExLmpzJztcbnZhciB2NSA9IHYzNSgndjUnLCAweDUwLCBzaGExKTtcbmV4cG9ydCBkZWZhdWx0IHY1OyIsImltcG9ydCB7IExSUGFyc2VyIH0gZnJvbSAnQGxlemVyL2xyJztcblxuLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQgYnkgbGV6ZXItZ2VuZXJhdG9yLiBZb3UgcHJvYmFibHkgc2hvdWxkbid0IGVkaXQgaXQuXG5jb25zdCBKc29uJDEgPSAxLFxuICBMb2dmbXQkMSA9IDIsXG4gIFVucGFjayQxID0gMyxcbiAgUGF0dGVybiQxID0gNCxcbiAgUmVnZXhwJDEgPSA1LFxuICBVbndyYXAkMSA9IDYsXG4gIElwJDEgPSA3LFxuICBMYWJlbEZvcm1hdCQxID0gOCxcbiAgTGluZUZvcm1hdCQxID0gOSxcbiAgTGFiZWxSZXBsYWNlJDEgPSAxMCxcbiAgT2Zmc2V0JDEgPSAxMSxcbiAgQm9vbCQxID0gMTIsXG4gIE9uJDEgPSAxMyxcbiAgSWdub3JpbmckMSA9IDE0LFxuICBHcm91cExlZnQkMSA9IDE1LFxuICBHcm91cFJpZ2h0JDEgPSAxNixcbiAgQnl0ZXNDb252JDEgPSAxNyxcbiAgRHVyYXRpb25Db252JDEgPSAxOCxcbiAgRHVyYXRpb25TZWNvbmRzQ29udiQxID0gMTksXG4gIEJ5JDEgPSAyMCxcbiAgV2l0aG91dCQxID0gMjEsXG4gIEFuZCQxID0gMjIsXG4gIE9yJDEgPSAyMyxcbiAgVW5sZXNzJDEgPSAyNCxcbiAgU3VtJDEgPSAyNSxcbiAgQXZnJDEgPSAyNixcbiAgQ291bnQkMSA9IDI3LFxuICBNYXgkMSA9IDI4LFxuICBNaW4kMSA9IDI5LFxuICBTdGRkZXYkMSA9IDMwLFxuICBTdGR2YXIkMSA9IDMxLFxuICBCb3R0b21rJDEgPSAzMixcbiAgVG9wayQxID0gMzM7XG5cbmNvbnN0IGtleXdvcmRUb2tlbnMgPSB7XG4gICAganNvbjogSnNvbiQxLFxuICAgIGxvZ2ZtdCA6IExvZ2ZtdCQxLFxuICAgIHVucGFjazogVW5wYWNrJDEsXG4gICAgcGF0dGVybiA6IFBhdHRlcm4kMSxcbiAgICByZWdleHAgOiBSZWdleHAkMSxcbiAgICBpcCA6IElwJDEsXG4gICAgbGFiZWxfZm9ybWF0IDogTGFiZWxGb3JtYXQkMSxcbiAgICBsaW5lX2Zvcm1hdCA6IExpbmVGb3JtYXQkMSxcbiAgICBsYWJlbF9yZXBsYWNlOiBMYWJlbFJlcGxhY2UkMSxcbiAgICBvZmZzZXQ6IE9mZnNldCQxLFxuICAgIGJvb2w6IEJvb2wkMSxcbiAgICBvbjogT24kMSxcbiAgICBpZ25vcmluZzogSWdub3JpbmckMSxcbiAgICBncm91cF9sZWZ0OiBHcm91cExlZnQkMSxcbiAgICBncm91cF9yaWdodDogR3JvdXBSaWdodCQxLFxuICAgIHVud3JhcDogVW53cmFwJDEsXG4gICAgYnl0ZXM6IEJ5dGVzQ29udiQxLFxuICAgIGR1cmF0aW9uOiBEdXJhdGlvbkNvbnYkMSxcbiAgICBkdXJhdGlvbl9zZWNvbmRzOiBEdXJhdGlvblNlY29uZHNDb252JDFcbn07XG5cbmNvbnN0IHNwZWNpYWxpemVJZGVudGlmaWVyID0gKHZhbHVlLCBzdGFjaykgPT4ge1xuICAgIHJldHVybiBrZXl3b3JkVG9rZW5zW3ZhbHVlLnRvTG93ZXJDYXNlKCldIHx8IC0xO1xufTtcblxuXG5jb25zdCBjb250ZXh0dWFsS2V5d29yZFRva2VucyA9IHtcbiAgICBieTogQnkkMSxcbiAgICB3aXRob3V0OiBXaXRob3V0JDEsXG4gICAgYW5kOiBBbmQkMSxcbiAgICBvcjogT3IkMSxcbiAgICB1bmxlc3M6IFVubGVzcyQxLFxuICAgIHN1bTogU3VtJDEsXG4gICAgYXZnOiBBdmckMSxcbiAgICBjb3VudDogQ291bnQkMSxcbiAgICBtYXg6IE1heCQxLFxuICAgIG1pbjogTWluJDEsXG4gICAgc3RkZGV2OiBTdGRkZXYkMSxcbiAgICBzdGR2YXI6IFN0ZHZhciQxLFxuICAgIGJvdHRvbWs6IEJvdHRvbWskMSxcbiAgICB0b3BrOiBUb3BrJDFcbn07XG5cbmNvbnN0IGV4dGVuZElkZW50aWZpZXIgPSAodmFsdWUsIHN0YWNrKSA9PiB7XG4gICAgcmV0dXJuIGNvbnRleHR1YWxLZXl3b3JkVG9rZW5zW3ZhbHVlLnRvTG93ZXJDYXNlKCldIHx8IC0xO1xufTtcblxuLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQgYnkgbGV6ZXItZ2VuZXJhdG9yLiBZb3UgcHJvYmFibHkgc2hvdWxkbid0IGVkaXQgaXQuXG5jb25zdCBzcGVjX0lkZW50aWZpZXIgPSB7X19wcm90b19fOm51bGwsY291bnRfb3Zlcl90aW1lOjI1NSwgcmF0ZToyNTcsIGJ5dGVzX292ZXJfdGltZToyNTksIGJ5dGVzX3JhdGU6MjYxLCBhdmdfb3Zlcl90aW1lOjI2Mywgc3VtX292ZXJfdGltZToyNjUsIG1pbl9vdmVyX3RpbWU6MjY3LCBtYXhfb3Zlcl90aW1lOjI2OSwgc3RkZGV2X292ZXJfdGltZToyNzEsIHN0ZHZhcl9vdmVyX3RpbWU6MjczLCBxdWFudGlsZV9vdmVyX3RpbWU6Mjc1LCBmaXJzdF9vdmVyX3RpbWU6Mjc3LCBsYXN0X292ZXJfdGltZToyNzksIGFic2VudF9vdmVyX3RpbWU6MjgxfTtcbmNvbnN0IHBhcnNlciA9IExSUGFyc2VyLmRlc2VyaWFsaXplKHtcbiAgdmVyc2lvbjogMTMsXG4gIHN0YXRlczogXCJAak9ZUVBPT08jVlFQTycjRFNPJGZRUE8nI0RST1lRUE8nI0RST09RTycjRU8nI0VPTyRzUVBPJyNEfU9PUU8nI0VnJyNFZ08keFFQTycjRWZRJVRRUE9PT09RTycjRXUnI0V1TyZVUVBPJyNFdU8mWlFQTycjRXZPT1FPJyNEfCcjRHxPT1FPJyNEUScjRFFPT1FPJyNFUCcjRVBPT1FPJyNFUScjRVFPT1FPJyNFUicjRVJPT1FPJyNFUycjRVNPT1FPJyNFVCcjRVRPT1FPJyNFVScjRVVPT1FPJyNFVicjRVZPT1FPJyNFVycjRVdPT1FPJyNFWCcjRVhPT1FPJyNFWScjRVlPT1FPJyNFWicjRVpPT1FPJyNFWycjRVtPT1FPJyNFXScjRV1PT1FPJyNFXicjRV5PJmBRUE8nI0RVT09RTycjRFQnI0RUTyZuUVBPLDU5bk9PUU8nI0RhJyNEYU8mdlFQTycjRGBPJ09RUE8nI0RfT09RTycjRF4nI0ReTyhsUVBPJyNEXk9PUU8nI0RdJyNEXU8qaFFQTyw1OW1PK3ZRUE8sNTltTyt9UVBPLDU6aE8sVVFQTyw1OmlPLGFRUE8nI0VkTy5gUVBPLDU7UU8uZ1FQTyw1O1FPLmxRUE8sNTtTTy5sUVBPLDU7U08ubFFQTyw1O1NPLmxRUE8sNTtTTy5sUVBPLDU7U08ubFFQTyw1O1NPT1FPLDU7YSw1O2FPWVFQTyw1O2JPMHJRUE8sNTlwTzB3UVBPMUcvWU9PUU8xRy9ZMUcvWU9PUU8nI0RkJyNEZE9PUU8sNTl6LDU5ek8xUFFQTyw1OXpPT1FPLDU5eSw1OXlPMVVRUE8nI0RVTzFzUVBPJyNEZk9PUU8nI0RmJyNEZk8zZFFQTycjRGZPM2lRUE8nI0RtT09RTycjRGwnI0RsT09RTycjRGonI0RqTylSUVBPJyNEak80UVFQTyw1OXhPNW5RUE8nI0R4TzVzUVBPJyNEeU9PUU8sNTl4LDU5eE9PUU8sNTl3LDU5d09PUU8xRy9YMUcvWE9PUU8xRzBTMUcwU081eFFQTycjRV9PLFhRUE8nI0VfTzZhUVBPMUcwVE82ZlFQTzFHMFRPNmtRUE8sNTtPTzZzUVBPMUcwbE84T1FQTzFHMGxPOFZRUE8xRzBsTzheUVBPJyNFak86YFFQTycjRWlPOmpRUE8nI0VpT1lRUE8xRzBuT1lRUE8xRzBuT1lRUE8xRzBuT1lRUE8xRzBuT1lRUE8xRzBuT1lRUE8xRzBuTzp0UVBPMUcwfE9PUU8xRy9bMUcvW09PUU8xRy9aMUcvWk9PUU83KyR0NyskdE86e1FQTzFHL2ZPO1FRUE8sNTlwTztXUVBPLDU6YE87YFFQTycjRGlPO2VRUE8nI0RoT09RTyw1OlIsNTpST09RTyw1OlEsNTpRTz1SUVBPLDU6WE89V1FQTyw1OlVPKVJRUE8sNTpVTylSUVBPLDU6VU9PUU8sNTpkLDU6ZE89ZlFQTycjRHtPT1FPJyNEeicjRHpPPWtRUE8sNTplTz9YUVBPJyNEXk81eFFQTyw1OnlPP2BRUE8nI0VgTz9lUVBPJyNFYk9AT1FQTyw1OnlPNltRUE8sNTp5T0BZUVBPLDU6eU9AYVFQTyw1OnlPQGZRUE83KyVvTyxYUVBPNyslb09PUU8nI0VlJyNFZU9BdlFQTzFHMGpPT1FPMUcwajFHMGpPQk9RUE83KyZXT1lRUE83KyZXT0NgUVBPNysmV09DZ1FQTzcrJldPQ25RUU8nI0VrT09RTyw1O1UsNTtVT0VwUVBPLDU7VE9Fd1FQTyw1O1RPR1lRUE83KyZZT0dhUVBPNysmWU9PUU83KyZZNysmWU9HblFQTzcrJllPR3VRUE83KyZZT0h6UVBPNysmWU9JW1FQTzcrJmhPSWFRUE83KyVRT0lmUVBPMUcvcU9PUU8xRy96MUcvek9PUU8xRy98MUcvfE9Ja1FQTyw1OlRPSXBRUE8sNTpTT09RTzFHL3MxRy9zT09RTzFHL3AxRy9wT0l1UVBPMUcvcE9LY1FQTyw1OmdPNXNRUE8sNTpmT0trUVBPLDU6fE9LeVFQTzFHMGVPNltRUE8xRzBlT0xSUVBPLDU6ek8pUlFQTyw1OnxPTFdRUE8xRzBlT0xfUVBPJyNFYU9MV1FQTzFHMGVPT1FPMUcwZTFHMGVPTGRRUE8xRzBlTzZbUVBPMUcwZU9Ma1FQTzFHMGVPT1FPPDxJWjw8SVpPTHNRUE88PElaT0x4UVBPLDU7UE9PUU83KyZVNysmVU9PUU88PElyPDxJck9MfVFQTzw8SXJPWVFQTzw8SXJPT1FPJyNFbScjRW1PTVVRUE8sNTtWT09RTycjRWwnI0VsT09RTyw1O1YsNTtWT09RTzFHMG8xRzBvT01eUVBPMUcwb08hIFpRUE88PEpTT09RTzw8SGw8PEhsTyEgYFFQTzcrJV1PT1FPMUcvbzFHL29PT1FPMUcvbjFHL25PT1FPMUcwUjFHMFJPT1FPMUcwUTFHMFFPT1FPJyNFYycjRWNPT1FPMUcwaDFHMGhPISBlUVBPMUcwaE9PUU83KyZQNysmUE9PUU8xRzBmMUcwZk8hIGpRUE8xRzBoT09RTyw1OnssNTp7TyEge1FQTzcrJlBPNltRUE83KyZQTyEhU1FQTzcrJlBPISFiUVBPQU4+dU9PUU8xRzBrMUcwa08hI3JRUE9BTj9eTyElU1FQT0FOP15PISVaUVFPMUcwcU9PUU8xRzBxMUcwcU9PUU83KyZaNysmWk8hJWNRUE9BTj9uTyElaFFQTzw8SHdPISVtUVBPNysmU09PUU88PElrPDxJa08hJXJRUE88PElrTyElelFQTzw8SWtPISZWUVBPJyNFYk9PUU9HMjRhRzI0YU9PUU9HMjR4RzI0eE9PUU8xRzByMUcwck9PUU83KyZdNysmXU8hJltRUE9HMjVZT09RT0FOPmNBTj5jTyEmYVFQTzw8SW5PT1FPQU4/VkFOP1ZPISZmUVBPTEQqdE9PUU9BTj9ZQU4/WU9PUU8sNTplLDU6ZU8hJmtRUE8hJCdOYE8hJnBRUE8hKTlDek8hJnVRUE8hLks5Zk9PUU8hNC8vUSE0Ly9RTzVzUVBPJyNEeU8hJnpRUE8nI0ReTyEnbFFQTyw1OW1PISd2UVBPJyNEUk9ZUVBPMUcwbk9ZUVBPMUcwbk9ZUVBPMUcwbk9ZUVBPMUcwbk9ZUVBPMUcwbk9ZUVBPMUcwbk8ubFFQTyw1O1NPLmxRUE8sNTtTTy5sUVBPLDU7U08ubFFQTyw1O1NPLmxRUE8sNTtTTy5sUVBPLDU7U08hKVJRUE83KyZZTyEpWVFQTzcrJllPISlnUVBPNysmWU8hKm9RUE83KyZZTyEqdlFQTzcrJllPISluUVBPJyNFaFwiLFxuICBzdGF0ZURhdGE6IFwiIStUfk8jbU9Tck9Tfk9ZWk9pVU9qVU9rVU9sVU9tVU9uVU9vVU9wVU9xVU8ha1hPI2NZTyNkWU8jblBPI3FSTyNzXk8jdF9PI3VgTyN2YU8jd2JPI3hjTyN5ZE8jemVPI3tmTyN8Z08jfWhPJE9pTyRQak8kUWtPfk95bE9+T3xvTyFPb08hVW9PIVZvT2Z1WGd1WGh1WCFidVghZHVYIWV1WCFmdVghZ3VYI2N1WCNkdVgjZXVYI2Z1WCNndVgjaHVYfk8hWHNPI2t1WCNydVh+UCNbTyNxeE9+T2R5T2V5TyNxek9+T2Z9T2d8T2h9T3whUk8hYiFSTyFkIVJPIWUhUk8hZiFSTyFnIVJPI2MhT08jZCFPTyNlIVBPI2YhUE8jZyFQTyNoIVFPfk8hayFTT35PI3EhVE9+T3ohVU98IVVPfSFVTyFPIVVPfk8jbyFWTyNwIVdPfk9WIVhPeyFZT35PfG9PIU9vTyFVb08hVm9PZiFSWGchUlhoIVJYIVghUlghYiFSWCFkIVJYIWUhUlghZiFSWCFnIVJYI2MhUlgjZCFSWCNlIVJYI2YhUlgjZyFSWCNoIVJYI2shUlgjciFSWFUhUlgkUiFSWCNvIVJYfk9QIV5PUSFfT1IhX09TIWBPVCFgT1chZ09YIWZPYiFhT3khXU8jcSFkT35PfG9PIU9vTyFVb08hVm9PZnVhZ3VhaHVhIWJ1YSFkdWEhZXVhIWZ1YSFndWEjY3VhI2R1YSNldWEjZnVhI2d1YSNodWF+TyFYc08ja3VhI3J1YX5QKV5PZnRYZ3RYaHRYfHRYIWJ0WCFkdFghZXRYIWZ0WCFndFgjY3RYI2R0WCNldFgjZnRYI2d0WCNodFh+TyNyIWpPflAqdU8jciFrT35QKnVPIWshb08jblBPI3EhbU9+TyNxIXBPfk9ZWk9pVU9qVU9rVU9sVU9tVU9uVU9vVU9wVU9xVU8jY1lPI2RZTyNuUE8jcVJPI3NeTyN0X08jdWBPI3ZhTyN3Yk8jeGNPI3lkTyN6ZU8je2ZPI3xnTyN9aE8kT2lPJFBqTyRRa09+TyFrIXJPflAsZk8jcSFzT35PWyF2T10hdE9eIXRPWSNdUGkjXVBqI11QayNdUGwjXVBtI11QbiNdUG8jXVBwI11QcSNdUCFrI11QI2MjXVAjZCNdUCNuI11QI3EjXVAjcyNdUCN0I11QI3UjXVAjdiNdUCN3I11QI3gjXVAjeSNdUCN6I11QI3sjXVAjfCNdUCN9I11QJE8jXVAkUCNdUCRRI11Qfk97I09Pfk95bE8jcCNRT35PI3EjUk9+T3ojU098I1NPfSFVTyFPIVVPIWIjVE8hZCNUTyFlI1RPIWYjVE8hZyNUT35PeSNVT2YhWVhnIVlYaCFZWHwhWVghTyFZWCFVIVlYIVYhWVghWCFZWCFiIVlYIWQhWVghZSFZWCFmIVlYIWchWVgjYyFZWCNkIVlYI2UhWVgjZiFZWCNnIVlYI2ghWVgjayFZWCNyIVlYVSFZWCRSIVlYI28hWVh+T3sjWE9+T3ojWU98I1lPIWIjWU8hZCNZTyFlI1lPIWYjWU8hZyNZT35PZiNbT2cjXU8jbyNbT2ghUWF8IVFhIU8hUWEhVSFRYSFWIVFhIVghUWEhYiFRYSFkIVFhIWUhUWEhZiFRYSFnIVFhI2MhUWEjZCFRYSNlIVFhI2YhUWEjZyFRYSNoIVFhI2shUWEjciFRYVUhUWEkUiFRYX5PeyNeT35PeSNfT35PVSNlT3xvTyFPb08hVW9PIVZvTyFYI2JPJFIjZE9+TyNyI2pPfk8jbyNrT35PeSNsTyNyI25Pfk8jciNvT35QKnVPZiNpWGcjaVhoI2lYfCNpWCFiI2lYIWQjaVghZSNpWCFmI2lYIWcjaVgjYyNpWCNkI2lYI2UjaVgjZiNpWCNnI2lYI2gjaVgjciNpWH5PI28jcE9+UDZ6TyFrI3JPflAsZk8jcSNzT35PWSNdWGkjXVhqI11YayNdWGwjXVhtI11YbiNdWG8jXVhwI11YcSNdWCFrI11YI2MjXVgjZCNdWCNuI11YI3EjXVgjcyNdWCN0I11YI3UjXVgjdiNdWCN3I11YI3gjXVgjeSNdWCN6I11YI3sjXVgjfCNdWCN9I11YJE8jXVgkUCNdWCRRI11Yfk9fI3VPYCN1T35QOGNPXSF0T14hdE9+UDhjTyNvI31PflAqdU97JE9Pfk9WJFBPeyNPTyFpJFFPIWskUk9+T3okU09+TyNvJFRPZiFbWGchW1hoIVtYfCFbWCFPIVtYIVUhW1ghViFbWCFYIVtYIWIhW1ghZCFbWCFlIVtYIWYhW1ghZyFbWCNjIVtYI2QhW1gjZSFbWCNmIVtYI2chW1gjaCFbWCNrIVtYI3IhW1hVIVtYJFIhW1h+TyFjJFVPfk9mI1tPZyNdTyNvI1tPI3IkVk9+T3okWE9+TyNvJFlPZiFtYWchbWFoIW1hfCFtYSFPIW1hIVUhbWEhViFtYSFYIW1hIWIhbWEhZCFtYSFlIW1hIWYhbWEhZyFtYSNjIW1hI2QhbWEjZSFtYSNmIW1hI2chbWEjaCFtYSNrIW1hI3IhbWFVIW1hJFIhbWF+T1UkWk9+UChsTyFjJF5Pfk8hWCRfT35PVSNlT3xvTyFPb08hVW9PIVZvTyFYI2JPfk9aJGFPI3IjUmF+UD9qTyNyJGVPflA1eE8jciRjT35PZHlPZXlPZiFxcWchcXFoIXFxfCFxcSFiIXFxIWQhcXEhZSFxcSFmIXFxIWchcXEjYyFxcSNkIXFxI2UhcXEjZiFxcSNnIXFxI2ghcXEjayFxcSNyIXFxI28hcXF+TyNvJGlPI3Ikak9+T2R5T2V5T2YjWXFnI1lxaCNZcXwjWXEhYiNZcSFkI1lxIWUjWXEhZiNZcSFnI1lxI2MjWXEjZCNZcSNlI1lxI2YjWXEjZyNZcSNoI1lxI2sjWXEjciNZcSNvI1lxfk8jciRrT35QKnVPI28kbU9+UDZ6TyNiJG5PI3IkcU9+T1kjXWFpI11haiNdYWsjXWFsI11hbSNdYW4jXWFvI11hcCNdYXEjXWEhayNdYSNjI11hI2QjXWEjbiNdYSNzI11hI3QjXWEjdSNdYSN2I11hI3cjXWEjeCNdYSN5I11hI3ojXWEjeyNdYSN8I11hI30jXWEkTyNdYSRQI11hJFEjXWF+TyNxI3NPflBDdk9fJHNPYCRzTyNxI11hflBDdk9mfU9ofU98IVJPIWIhUk8hZCFSTyFlIVJPIWYhUk8hZyFSTyNjIU9PI2QhT08jZSNbcSNmI1txI2cjW3EjaCNbcSNrI1txI3IjW3F+T2cjW3F+UEZVT2YjW3FnI1txaCNbcX5QRltPZ3xPflBGVU8jayNbcSNyI1txflAlVE9mI1txZyNbcWgjW3F8I1txIWIjW3EhZCNbcSFlI1txIWYjW3EhZyNbcSNlI1txI2YjW3EjZyNbcSNoI1txfk8jYyFPTyNkIU9PI2sjW3EjciNbcX5QSFBPeyR0T35PI3IkdU9+TyNxJHZPfk97JHdPfk95I1VPfk9mI1tPI28jW09nIV5paCFeaXwhXmkhTyFeaSFVIV5pIVYhXmkhWCFeaSFiIV5pIWQhXmkhZSFeaSFmIV5pIWchXmkjYyFeaSNkIV5pI2UhXmkjZiFeaSNnIV5pI2ghXmkjayFeaSNyIV5pVSFeaSRSIV5pfk95JHlPeyR5T35PYSR7T2Ike09jJHtPeSR8T35PWiRhTyNyI1Jpfk8kUyVQT35PI3IjUml+UD9qTyFjJVJPfk8jciVUT35QNXhPI3IlVE8kUiNkT35PI3IlVk9+T3klV09+TyNyJVhPflAqdU8jbyVaTyNyJVtPfk8jcSNzT1kjXWlpI11paiNdaWsjXWlsI11pbSNdaW4jXWlvI11pcCNdaXEjXWkhayNdaSNjI11pI2QjXWkjbiNdaSNzI11pI3QjXWkjdSNdaSN2I11pI3cjXWkjeCNdaSN5I11pI3ojXWkjeyNdaSN8I11pI30jXWkkTyNdaSRQI11pJFEjXWl+TyNvJV5Pfk97JV9Pfk8jcSVgT35PZiNbT2cjXU8jbyNbTyRSI1VpI3IjVWl+TyNyI1JxflA/ak9VI2VPWiVjTyFYJWRPI3IjUnF+T2R5T2V5T2YhcSFSZyFxIVJoIXEhUnwhcSFSIWIhcSFSIWQhcSFSIWUhcSFSIWYhcSFSIWchcSFSI2MhcSFSI2QhcSFSI2UhcSFSI2YhcSFSI2chcSFSI2ghcSFSI2shcSFSI3IhcSFSI28hcSFSfk9keU9leU9mI1khUmcjWSFSaCNZIVJ8I1khUiFiI1khUiFkI1khUiFlI1khUiFmI1khUiFnI1khUiNjI1khUiNkI1khUiNlI1khUiNmI1khUiNnI1khUiNoI1khUiNrI1khUiNyI1khUiNvI1khUn5PI3IlZk9+UCp1TyNiJG5PI3IlaE9+T3slaU9+TyNyJWpPfk95JWtPfk9aJGFPI3IjUnl+T1UjZU8hWCVkTyFjJVJPfk9VJFpPfk8jbyVtT35PI3Ilbk9+T3slcE9+TyNvJXFPfk97JXJPfk8jciVzT35PUCFeT1EhX09SIV9PUyFgT1QhYE9XJXRPWCFmT2IhYU95IV1PI3EhZE9+TyFYJXVPI291YX5QKV5PIVgldU8jb3VYflAjW09mJlBPaCZQT3wmVE8hYiZUTyFkJlRPIWUmVE8hZiZUTyFnJlRPI2MmUU8jZCZRTyNlI1txI2YjW3EjZyNbcSNoI1txI28jW3F+T2cjW3F+UCEoUU9mI1txZyNbcWgjW3F+UCEoV09nJk9PflAhKFFPZiZQT2cmT09oJlBPfCZUTyFiJlRPIWQmVE8hZSZUTyFmJlRPIWcmVE8jYyZRTyNkJlFPI2UmUk8jZiZSTyNnJlJPI2gmU09+TyNvI1txflAhKW5PI2MmUU8jZCZRTyNvI1txflBIUE9cIixcbiAgZ290bzogXCIvWSNrUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQI2wkayVTJXIldVBQUFBQUCZVJmgmeCdXJ2lQUCd4UCd7J3soUShUKFoobChsKHVQUFBQUFAodVAobFAneyd7KU8pVSldKk8qZSp6Knoqeip6Knoqeip6Knoqeip6Knoqeip6KnorYStqK30sWixzLHYtVipPLVkqTy1vLmUudi9QL1NQUFBQUFBQKk8qT1tXT1J6IXMjcCRtUSN3IXdRI3gheFMjeSF5JXpRI3ohelEjeyF7USN8IXxRJlUleFEmViV5USZXJXtRJlglfFEmWSV9UiZaIVR0XU96IVQhcyF3IXgheSF6IXshfCNwJG0leCV5JXoleyV8JX1SdlJqUU9SeiFUIXMhdyF4IXkheiF7IXwjcCRtUyFseCNrUSNoIW1dJXcleCV5JXoleyV8JX1SblBRbVBeIWNzIWQjWyNdI2IkXyV1UiNQIVZRdVFRI2MhbFEkYCNmUSRkI2hRJVMkYlIldiV3W3RRIWwjZiNoJGIld10haXUjYyRgJGQlUyV2aXJRdSFsI2MjZiNoJGAkYiRkJVMldiV3aHFRdSFsI2MjZiNoJGAkYiRkJVMldiV3UiFbcWtwUXF1IWwjYyNmI2gkYCRiJGQlUyV2JXdSIVpwViFocyNiJXVSI1chXlEjViFeUiR4JFRVIWVzI2IldVEjWiFkUSRWI1tRJFcjXVIlUSRfXyFjcyFkI1sjXSNiJF8ldV8hYnMhZCNbI10jYiRfJXVRI2EhZ1IlbyV0UyNgIWcldFIkeiRZal1PIXcheCF5IXoheyF8JXgleSV6JXslfCV9UXdSUSFxelEhfSFUUSNxIXNRJGwjcFIlWSRtd1tPUnohVCFzIXcheCF5IXoheyF8I3AkbSV4JXkleiV7JXwlfXdUT1J6IVQhcyF3IXgheSF6IXshfCNwJG0leCV5JXoleyV8JX13U09SeiFUIXMhdyF4IXkheiF7IXwjcCRtJXgleSV6JXslfCV9USFueFEjaSFtUiRoI2tTI2YhbCNoVyRbI2MjZyRkJGZRJU8kXVElVSRlUiViJVRRJGIjZlElTyRbUSVhJVVSJWwlYlEjZyFsUyRdI2MkZFEkYyNmUSRmI2hTJU8kYCRiUyVhJVMlVVIlbCVjUiR9JFpRe1ZRJGcjalEkayNvUSVlJVZSJWYlWFIjbSFwd1ZPUnohVCFzIXcheCF5IXoheyF8I3AkbSV4JXkleiV7JXwlfVEhd3xRIXh9USF5IU9RIXohUFEheyFRUSF8IVJRJXgmT1EleSZQUSV6JlFRJXsmUlElfCZTUiV9JlRoIXV8fSFPIVAhUSFSJk8mUCZRJlImUyZUUiN2IXZRI3QhdFEkciN1UiVdJHNSJG8jc1EkcCNzUiVnJVpcIixcbiAgbm9kZU5hbWVzOiBcIuKaoCBKc29uIExvZ2ZtdCBVbnBhY2sgUGF0dGVybiBSZWdleHAgVW53cmFwIElwIExhYmVsRm9ybWF0IExpbmVGb3JtYXQgTGFiZWxSZXBsYWNlIE9mZnNldCBCb29sIE9uIElnbm9yaW5nIEdyb3VwTGVmdCBHcm91cFJpZ2h0IEJ5dGVzQ29udiBEdXJhdGlvbkNvbnYgRHVyYXRpb25TZWNvbmRzQ29udiBCeSBXaXRob3V0IEFuZCBPciBVbmxlc3MgU3VtIEF2ZyBDb3VudCBNYXggTWluIFN0ZGRldiBTdGR2YXIgQm90dG9tayBUb3BrIExpbmVDb21tZW50IExvZ1FMIEV4cHIgTG9nRXhwciBTZWxlY3RvciBNYXRjaGVycyBNYXRjaGVyIElkZW50aWZpZXIgRXEgU3RyaW5nIE5lcSBSZSBOcmUgUGlwZWxpbmVFeHByIFBpcGVsaW5lU3RhZ2UgTGluZUZpbHRlcnMgTGluZUZpbHRlciBGaWx0ZXIgUGlwZUV4YWN0IFBpcGVNYXRjaCBGaWx0ZXJPcCBQaXBlIExhYmVsUGFyc2VyIEpzb25FeHByZXNzaW9uUGFyc2VyIEpzb25FeHByZXNzaW9uTGlzdCBKc29uRXhwcmVzc2lvbiBMYWJlbEZpbHRlciBJcExhYmVsRmlsdGVyIFVuaXRGaWx0ZXIgRHVyYXRpb25GaWx0ZXIgR3RyIER1cmF0aW9uIEd0ZSBMc3MgTHRlIEVxbCBCeXRlc0ZpbHRlciBCeXRlcyBOdW1iZXJGaWx0ZXIgTnVtYmVyIExpbmVGb3JtYXRFeHByIExhYmVsRm9ybWF0RXhwciBMYWJlbHNGb3JtYXQgTGFiZWxGb3JtYXRNYXRjaGVyIE1ldHJpY0V4cHIgUmFuZ2VBZ2dyZWdhdGlvbkV4cHIgUmFuZ2VPcCBDb3VudE92ZXJUaW1lIFJhdGUgQnl0ZXNPdmVyVGltZSBCeXRlc1JhdGUgQXZnT3ZlclRpbWUgU3VtT3ZlclRpbWUgTWluT3ZlclRpbWUgTWF4T3ZlclRpbWUgU3RkZGV2T3ZlclRpbWUgU3RkdmFyT3ZlclRpbWUgUXVhbnRpbGVPdmVyVGltZSBGaXJzdE92ZXJUaW1lIExhc3RPdmVyVGltZSBBYnNlbnRPdmVyVGltZSBMb2dSYW5nZUV4cHIgUmFuZ2UgT2Zmc2V0RXhwciBVbndyYXBFeHByIENvbnZPcCBHcm91cGluZyBMYWJlbHMgVmVjdG9yQWdncmVnYXRpb25FeHByIFZlY3Rvck9wIEJpbk9wRXhwciBCaW5PcE1vZGlmaWVyIE9uT3JJZ25vcmluZ01vZGlmaWVyIEdyb3VwaW5nTGFiZWxzIEdyb3VwaW5nTGFiZWxMaXN0IEdyb3VwaW5nTGFiZWwgTGFiZWxOYW1lIEFkZCBTdWIgTXVsIERpdiBNb2QgUG93IExpdGVyYWxFeHByIExhYmVsUmVwbGFjZUV4cHJcIixcbiAgbWF4VGVybTogMTQyLFxuICBza2lwcGVkTm9kZXM6IFswLDM0XSxcbiAgcmVwZWF0Tm9kZUNvdW50OiAwLFxuICB0b2tlbkRhdGE6IFwiM3t+UndYXiNscHEjbHFyJGFycyR0c3QlaHV2JXN3eCV4eHkmZ3l6Jmx6eyZxe3wmdnx9Jnt9IU8nUSFPIVAnViFQIVEoViFRIVIoWyFSIVspciFbIV0wciFeIV8xVyFfIWAxZSFgIWExeiFjIX0yWCF9I08ybyNQI1EydCNRI1IyeSNSI1MyWCNTI1QzTyNUI28yWCNvI3AzWyNwI3EzYSNxI3IzdiN5I3ojbCRmJGcjbCNCWSNCWiNsJElTJElfI2wkSXwkSk8jbCRKVCRKVSNsJEtWJEtXI2wmRlUmRlYjbH4jcVkjbX5YXiNscHEjbCN5I3ojbCRmJGcjbCNCWSNCWiNsJElTJElfI2wkSXwkSk8jbCRKVCRKVSNsJEtWJEtXI2wmRlUmRlYjbH4kZFEhXyFgJGojciNzJG9+JG9PfH5+JHRPIU9+fiR5VXt+T1kkdFpyJHRycyVdcyNPJHQjTyNQJWIjUH4kdH4lYk97fn4lZVBPfiR0fiVtUXJ+T1klaFp+JWh+JXhPI2d+fiV9VXt+T1kleFp3JXh3eCVdeCNPJXgjTyNQJmEjUH4leH4mZFBPfiV4fiZsTyNxfn4mcU8jcn5+JnZPI2V+fiZ7TyNjfn4nUU8jb35+J1ZPI2R+fidZUCFRIVsnXX4nYlIha34hUSFbJ10hZyFoJ2sjWCNZJ2t+J25Se3wnd30hTyd3IVEhWyd9fid6UCFRIVsnfX4oU1Aha34hUSFbJ31+KFtPI2Z+fihhZSFrfiFPIVAnXSFRIVspciFnIWgrViFpIWordCFtIW4rdCFvIXArdCFyIXMrdCF2IXcrdCNVI1YraSNXI1grfSNYI1kuUCNaI1suYyNbI10sZiNfI2AuYyNhI2IubCNkI2UuYyNnI2gtbiNoI2kuYyNrI2wufSNsI20wVyNtI24vaX4pd2Qha34hTyFQJ10hUSFbKXIhZyFoK1YhaSFqK3QhbSFuK3QhbyFwK3QhciFzK3QhdiF3K3QjVSNWK2kjVyNYK30jWCNZLlAjWiNbLmMjWyNdLGYjXyNgLmMjYSNiLmwjZCNlLmMjZyNoLW4jaCNpLmMjayNsLn0jbSNuL2l+K1lUe3wnd30hTyd3IVEhWyd9IWQhZStpI10jXitufituTyFpfn4rcVAjVSNWK2l+K3dRIWQhZStpI10jXitufixTUCFjfiFRIVssVn4sWVMhUSFbLFYjWyNdLGYjYSNiLHojZyNoLW5+LGtQIWN+IVEhWyxufixxUiFRIVssbiNhI2IseiNnI2gtbn4tUFEhY34hUSFbLVYjZyNoLWl+LVlSIVEhWy1WI2EjYi1jI2cjaC1ufi1mUCNnI2gtaX4tbk8hY35+LXNQIWN+IVEhWy12fi15USFRIVstdiNhI2ItY34uU1R7fCd3fSFPJ3chUSFbJ30jVSNWK2kjXSNeK25+LmZRI1UjVitpI10jXitufi5xUyFjfiFRIVstViNVI1YraSNdI14rbiNnI2gtaX4vU1AhY34hUSFbL1Z+L1lUIVEhWy9WI1cjWCt9I1sjXSxmI2EjYix6I2cjaC1ufi9uUCFjfiFRIVsvcX4vdFUhUSFbL3EjVyNYK30jWyNdLGYjYSNiLHojZyNoLW4jayNsLn1+MFpSIVEhWzBkIWMhaTBkI1QjWjBkfjBpUiFrfiFRIVswZCFjIWkwZCNUI1owZFAwd1R5UCFRIVswciFbIV0wciFjIX0wciNSI1MwciNUI28wcn4xXVAhZX4hXyFgMWB+MWVPIWZ+fjFqUXp+IV8hYDFwI3IjczF1fjF1TyFnfn4xek99fn4yUFAhYn4hXyFgMlN+MlhPIWR+UjJgVHlQI2JRIVEhWzJYIVshXTByIWMhfTJYI1IjUzJYI1QjbzJYfjJ0TyRSfn4yeU8kU35+M09PI2h+fjNSUk8jUzNPI1MjVCVdI1R+M09+M2FPI25+fjNmUSFYfiFfIWAzbCNyI3MzcX4zcU8hVX5+M3ZPIVZ+fjN7TyNwflwiLFxuICB0b2tlbml6ZXJzOiBbMCwgMV0sXG4gIHRvcFJ1bGVzOiB7XCJMb2dRTFwiOlswLDM1XX0sXG4gIHNwZWNpYWxpemVkOiBbe3Rlcm06IDQxLCBnZXQ6ICh2YWx1ZSwgc3RhY2spID0+IChzcGVjaWFsaXplSWRlbnRpZmllcih2YWx1ZSkgPDwgMSl9LHt0ZXJtOiA0MSwgZ2V0OiAodmFsdWUsIHN0YWNrKSA9PiAoZXh0ZW5kSWRlbnRpZmllcih2YWx1ZSkgPDwgMSkgfCAxfSx7dGVybTogNDEsIGdldDogdmFsdWUgPT4gc3BlY19JZGVudGlmaWVyW3ZhbHVlXSB8fCAtMX1dLFxuICB0b2tlblByZWM6IDBcbn0pO1xuLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQgYnkgbGV6ZXItZ2VuZXJhdG9yLiBZb3UgcHJvYmFibHkgc2hvdWxkbid0IGVkaXQgaXQuXG5jb25zdCBKc29uID0gMSxcbiAgTG9nZm10ID0gMixcbiAgVW5wYWNrID0gMyxcbiAgUGF0dGVybiA9IDQsXG4gIFJlZ2V4cCA9IDUsXG4gIFVud3JhcCA9IDYsXG4gIElwID0gNyxcbiAgTGFiZWxGb3JtYXQgPSA4LFxuICBMaW5lRm9ybWF0ID0gOSxcbiAgTGFiZWxSZXBsYWNlID0gMTAsXG4gIE9mZnNldCA9IDExLFxuICBCb29sID0gMTIsXG4gIE9uID0gMTMsXG4gIElnbm9yaW5nID0gMTQsXG4gIEdyb3VwTGVmdCA9IDE1LFxuICBHcm91cFJpZ2h0ID0gMTYsXG4gIEJ5dGVzQ29udiA9IDE3LFxuICBEdXJhdGlvbkNvbnYgPSAxOCxcbiAgRHVyYXRpb25TZWNvbmRzQ29udiA9IDE5LFxuICBCeSA9IDIwLFxuICBXaXRob3V0ID0gMjEsXG4gIEFuZCA9IDIyLFxuICBPciA9IDIzLFxuICBVbmxlc3MgPSAyNCxcbiAgU3VtID0gMjUsXG4gIEF2ZyA9IDI2LFxuICBDb3VudCA9IDI3LFxuICBNYXggPSAyOCxcbiAgTWluID0gMjksXG4gIFN0ZGRldiA9IDMwLFxuICBTdGR2YXIgPSAzMSxcbiAgQm90dG9tayA9IDMyLFxuICBUb3BrID0gMzMsXG4gIExpbmVDb21tZW50ID0gMzQsXG4gIExvZ1FMID0gMzUsXG4gIEV4cHIgPSAzNixcbiAgTG9nRXhwciA9IDM3LFxuICBTZWxlY3RvciA9IDM4LFxuICBNYXRjaGVycyA9IDM5LFxuICBNYXRjaGVyID0gNDAsXG4gIElkZW50aWZpZXIgPSA0MSxcbiAgRXEgPSA0MixcbiAgU3RyaW5nID0gNDMsXG4gIE5lcSA9IDQ0LFxuICBSZSA9IDQ1LFxuICBOcmUgPSA0NixcbiAgUGlwZWxpbmVFeHByID0gNDcsXG4gIFBpcGVsaW5lU3RhZ2UgPSA0OCxcbiAgTGluZUZpbHRlcnMgPSA0OSxcbiAgTGluZUZpbHRlciA9IDUwLFxuICBGaWx0ZXIgPSA1MSxcbiAgUGlwZUV4YWN0ID0gNTIsXG4gIFBpcGVNYXRjaCA9IDUzLFxuICBGaWx0ZXJPcCA9IDU0LFxuICBQaXBlID0gNTUsXG4gIExhYmVsUGFyc2VyID0gNTYsXG4gIEpzb25FeHByZXNzaW9uUGFyc2VyID0gNTcsXG4gIEpzb25FeHByZXNzaW9uTGlzdCA9IDU4LFxuICBKc29uRXhwcmVzc2lvbiA9IDU5LFxuICBMYWJlbEZpbHRlciA9IDYwLFxuICBJcExhYmVsRmlsdGVyID0gNjEsXG4gIFVuaXRGaWx0ZXIgPSA2MixcbiAgRHVyYXRpb25GaWx0ZXIgPSA2MyxcbiAgR3RyID0gNjQsXG4gIER1cmF0aW9uID0gNjUsXG4gIEd0ZSA9IDY2LFxuICBMc3MgPSA2NyxcbiAgTHRlID0gNjgsXG4gIEVxbCA9IDY5LFxuICBCeXRlc0ZpbHRlciA9IDcwLFxuICBCeXRlcyA9IDcxLFxuICBOdW1iZXJGaWx0ZXIgPSA3MixcbiAgTnVtYmVyID0gNzMsXG4gIExpbmVGb3JtYXRFeHByID0gNzQsXG4gIExhYmVsRm9ybWF0RXhwciA9IDc1LFxuICBMYWJlbHNGb3JtYXQgPSA3NixcbiAgTGFiZWxGb3JtYXRNYXRjaGVyID0gNzcsXG4gIE1ldHJpY0V4cHIgPSA3OCxcbiAgUmFuZ2VBZ2dyZWdhdGlvbkV4cHIgPSA3OSxcbiAgUmFuZ2VPcCA9IDgwLFxuICBDb3VudE92ZXJUaW1lID0gODEsXG4gIFJhdGUgPSA4MixcbiAgQnl0ZXNPdmVyVGltZSA9IDgzLFxuICBCeXRlc1JhdGUgPSA4NCxcbiAgQXZnT3ZlclRpbWUgPSA4NSxcbiAgU3VtT3ZlclRpbWUgPSA4NixcbiAgTWluT3ZlclRpbWUgPSA4NyxcbiAgTWF4T3ZlclRpbWUgPSA4OCxcbiAgU3RkZGV2T3ZlclRpbWUgPSA4OSxcbiAgU3RkdmFyT3ZlclRpbWUgPSA5MCxcbiAgUXVhbnRpbGVPdmVyVGltZSA9IDkxLFxuICBGaXJzdE92ZXJUaW1lID0gOTIsXG4gIExhc3RPdmVyVGltZSA9IDkzLFxuICBBYnNlbnRPdmVyVGltZSA9IDk0LFxuICBMb2dSYW5nZUV4cHIgPSA5NSxcbiAgUmFuZ2UgPSA5NixcbiAgT2Zmc2V0RXhwciA9IDk3LFxuICBVbndyYXBFeHByID0gOTgsXG4gIENvbnZPcCA9IDk5LFxuICBHcm91cGluZyA9IDEwMCxcbiAgTGFiZWxzID0gMTAxLFxuICBWZWN0b3JBZ2dyZWdhdGlvbkV4cHIgPSAxMDIsXG4gIFZlY3Rvck9wID0gMTAzLFxuICBCaW5PcEV4cHIgPSAxMDQsXG4gIEJpbk9wTW9kaWZpZXIgPSAxMDUsXG4gIE9uT3JJZ25vcmluZ01vZGlmaWVyID0gMTA2LFxuICBHcm91cGluZ0xhYmVscyA9IDEwNyxcbiAgR3JvdXBpbmdMYWJlbExpc3QgPSAxMDgsXG4gIEdyb3VwaW5nTGFiZWwgPSAxMDksXG4gIExhYmVsTmFtZSA9IDExMCxcbiAgQWRkID0gMTExLFxuICBTdWIgPSAxMTIsXG4gIE11bCA9IDExMyxcbiAgRGl2ID0gMTE0LFxuICBNb2QgPSAxMTUsXG4gIFBvdyA9IDExNixcbiAgTGl0ZXJhbEV4cHIgPSAxMTcsXG4gIExhYmVsUmVwbGFjZUV4cHIgPSAxMTg7XG5cbmV4cG9ydCB7IEFic2VudE92ZXJUaW1lLCBBZGQsIEFuZCwgQXZnLCBBdmdPdmVyVGltZSwgQmluT3BFeHByLCBCaW5PcE1vZGlmaWVyLCBCb29sLCBCb3R0b21rLCBCeSwgQnl0ZXMsIEJ5dGVzQ29udiwgQnl0ZXNGaWx0ZXIsIEJ5dGVzT3ZlclRpbWUsIEJ5dGVzUmF0ZSwgQ29udk9wLCBDb3VudCwgQ291bnRPdmVyVGltZSwgRGl2LCBEdXJhdGlvbiwgRHVyYXRpb25Db252LCBEdXJhdGlvbkZpbHRlciwgRHVyYXRpb25TZWNvbmRzQ29udiwgRXEsIEVxbCwgRXhwciwgRmlsdGVyLCBGaWx0ZXJPcCwgRmlyc3RPdmVyVGltZSwgR3JvdXBMZWZ0LCBHcm91cFJpZ2h0LCBHcm91cGluZywgR3JvdXBpbmdMYWJlbCwgR3JvdXBpbmdMYWJlbExpc3QsIEdyb3VwaW5nTGFiZWxzLCBHdGUsIEd0ciwgSWRlbnRpZmllciwgSWdub3JpbmcsIElwLCBJcExhYmVsRmlsdGVyLCBKc29uLCBKc29uRXhwcmVzc2lvbiwgSnNvbkV4cHJlc3Npb25MaXN0LCBKc29uRXhwcmVzc2lvblBhcnNlciwgTGFiZWxGaWx0ZXIsIExhYmVsRm9ybWF0LCBMYWJlbEZvcm1hdEV4cHIsIExhYmVsRm9ybWF0TWF0Y2hlciwgTGFiZWxOYW1lLCBMYWJlbFBhcnNlciwgTGFiZWxSZXBsYWNlLCBMYWJlbFJlcGxhY2VFeHByLCBMYWJlbHMsIExhYmVsc0Zvcm1hdCwgTGFzdE92ZXJUaW1lLCBMaW5lQ29tbWVudCwgTGluZUZpbHRlciwgTGluZUZpbHRlcnMsIExpbmVGb3JtYXQsIExpbmVGb3JtYXRFeHByLCBMaXRlcmFsRXhwciwgTG9nRXhwciwgTG9nUUwsIExvZ1JhbmdlRXhwciwgTG9nZm10LCBMc3MsIEx0ZSwgTWF0Y2hlciwgTWF0Y2hlcnMsIE1heCwgTWF4T3ZlclRpbWUsIE1ldHJpY0V4cHIsIE1pbiwgTWluT3ZlclRpbWUsIE1vZCwgTXVsLCBOZXEsIE5yZSwgTnVtYmVyLCBOdW1iZXJGaWx0ZXIsIE9mZnNldCwgT2Zmc2V0RXhwciwgT24sIE9uT3JJZ25vcmluZ01vZGlmaWVyLCBPciwgUGF0dGVybiwgUGlwZSwgUGlwZUV4YWN0LCBQaXBlTWF0Y2gsIFBpcGVsaW5lRXhwciwgUGlwZWxpbmVTdGFnZSwgUG93LCBRdWFudGlsZU92ZXJUaW1lLCBSYW5nZSwgUmFuZ2VBZ2dyZWdhdGlvbkV4cHIsIFJhbmdlT3AsIFJhdGUsIFJlLCBSZWdleHAsIFNlbGVjdG9yLCBTdGRkZXYsIFN0ZGRldk92ZXJUaW1lLCBTdGR2YXIsIFN0ZHZhck92ZXJUaW1lLCBTdHJpbmcsIFN1YiwgU3VtLCBTdW1PdmVyVGltZSwgVG9waywgVW5pdEZpbHRlciwgVW5sZXNzLCBVbnBhY2ssIFVud3JhcCwgVW53cmFwRXhwciwgVmVjdG9yQWdncmVnYXRpb25FeHByLCBWZWN0b3JPcCwgV2l0aG91dCwgcGFyc2VyIH07XG4iLCJpbXBvcnQgeyBMUlBhcnNlciB9IGZyb20gJ0BsZXplci9scic7XG5cbi8vIFRoaXMgZmlsZSB3YXMgZ2VuZXJhdGVkIGJ5IGxlemVyLWdlbmVyYXRvci4gWW91IHByb2JhYmx5IHNob3VsZG4ndCBlZGl0IGl0LlxuY29uc3QgXG4gIGluZiA9IDE0NixcbiAgbmFuID0gMTQ3LFxuICBCb29sID0gMSxcbiAgSWdub3JpbmcgPSAyLFxuICBPbiA9IDMsXG4gIEdyb3VwTGVmdCA9IDQsXG4gIEdyb3VwUmlnaHQgPSA1LFxuICBPZmZzZXQgPSA2LFxuICBBdGFuMiA9IDcsXG4gIEF2ZyA9IDgsXG4gIEJvdHRvbWsgPSA5LFxuICBDb3VudCA9IDEwLFxuICBDb3VudFZhbHVlcyA9IDExLFxuICBHcm91cCA9IDEyLFxuICBNYXggPSAxMyxcbiAgTWluID0gMTQsXG4gIFF1YW50aWxlID0gMTUsXG4gIFN0ZGRldiA9IDE2LFxuICBTdGR2YXIgPSAxNyxcbiAgU3VtID0gMTgsXG4gIFRvcGsgPSAxOSxcbiAgQnkgPSAyMCxcbiAgV2l0aG91dCA9IDIxLFxuICBBbmQgPSAyMixcbiAgT3IgPSAyMyxcbiAgVW5sZXNzID0gMjQsXG4gIFN0YXJ0ID0gMjUsXG4gIEVuZCA9IDI2O1xuXG4vLyBDb3B5cmlnaHQgMjAyMSBUaGUgUHJvbWV0aGV1cyBBdXRob3JzXG5cbmNvbnN0IGtleXdvcmRUb2tlbnMgPSB7XG4gICAgaW5mOiBpbmYsXG4gICAgbmFuOiBuYW4sXG4gICAgYm9vbDogQm9vbCxcbiAgICBpZ25vcmluZzogSWdub3JpbmcsXG4gICAgb246IE9uLFxuICAgIGdyb3VwX2xlZnQ6IEdyb3VwTGVmdCxcbiAgICBncm91cF9yaWdodDogR3JvdXBSaWdodCxcbiAgICBvZmZzZXQ6IE9mZnNldCxcbn07XG5cbmNvbnN0IHNwZWNpYWxpemVJZGVudGlmaWVyID0gKHZhbHVlLCBzdGFjaykgPT4ge1xuICAgIHJldHVybiBrZXl3b3JkVG9rZW5zW3ZhbHVlLnRvTG93ZXJDYXNlKCldIHx8IC0xO1xufTtcblxuY29uc3QgY29udGV4dHVhbEtleXdvcmRUb2tlbnMgPSB7XG4gICAgYXZnOiBBdmcsXG4gICAgYXRhbjI6IEF0YW4yLFxuICAgIGJvdHRvbWs6IEJvdHRvbWssXG4gICAgY291bnQ6IENvdW50LFxuICAgIGNvdW50X3ZhbHVlczogQ291bnRWYWx1ZXMsXG4gICAgZ3JvdXA6IEdyb3VwLFxuICAgIG1heDogTWF4LFxuICAgIG1pbjogTWluLFxuICAgIHF1YW50aWxlOiBRdWFudGlsZSxcbiAgICBzdGRkZXY6IFN0ZGRldixcbiAgICBzdGR2YXI6IFN0ZHZhcixcbiAgICBzdW06IFN1bSxcbiAgICB0b3BrOiBUb3BrLFxuICAgIGJ5OiBCeSxcbiAgICB3aXRob3V0OiBXaXRob3V0LFxuICAgIGFuZDogQW5kLFxuICAgIG9yOiBPcixcbiAgICB1bmxlc3M6IFVubGVzcyxcbiAgICBzdGFydDogU3RhcnQsXG4gICAgZW5kOiBFbmQsXG59O1xuXG5jb25zdCBleHRlbmRJZGVudGlmaWVyID0gKHZhbHVlLCBzdGFjaykgPT4ge1xuICAgIHJldHVybiBjb250ZXh0dWFsS2V5d29yZFRva2Vuc1t2YWx1ZS50b0xvd2VyQ2FzZSgpXSB8fCAtMTtcbn07XG5cbi8vIFRoaXMgZmlsZSB3YXMgZ2VuZXJhdGVkIGJ5IGxlemVyLWdlbmVyYXRvci4gWW91IHByb2JhYmx5IHNob3VsZG4ndCBlZGl0IGl0LlxuY29uc3Qgc3BlY19JZGVudGlmaWVyID0ge19fcHJvdG9fXzpudWxsLGFic2VudF9vdmVyX3RpbWU6MzA3LCBhYnNlbnQ6MzA5LCBhYnM6MzExLCBhY29zOjMxMywgYWNvc2g6MzE1LCBhc2luOjMxNywgYXNpbmg6MzE5LCBhdGFuOjMyMSwgYXRhbmg6MzIzLCBhdmdfb3Zlcl90aW1lOjMyNSwgY2VpbDozMjcsIGNoYW5nZXM6MzI5LCBjbGFtcDozMzEsIGNsYW1wX21heDozMzMsIGNsYW1wX21pbjozMzUsIGNvczozMzcsIGNvc2g6MzM5LCBjb3VudF9vdmVyX3RpbWU6MzQxLCBkYXlzX2luX21vbnRoOjM0MywgZGF5X29mX21vbnRoOjM0NSwgZGF5X29mX3dlZWs6MzQ3LCBkZWc6MzQ5LCBkZWx0YTozNTEsIGRlcml2OjM1MywgZXhwOjM1NSwgZmxvb3I6MzU3LCBoaXN0b2dyYW1fcXVhbnRpbGU6MzU5LCBob2x0X3dpbnRlcnM6MzYxLCBob3VyOjM2MywgaWRlbHRhOjM2NSwgaW5jcmVhc2U6MzY3LCBpcmF0ZTozNjksIGxhYmVsX3JlcGxhY2U6MzcxLCBsYWJlbF9qb2luOjM3MywgbGFzdF9vdmVyX3RpbWU6Mzc1LCBsbjozNzcsIGxvZzEwOjM3OSwgbG9nMjozODEsIG1heF9vdmVyX3RpbWU6MzgzLCBtaW5fb3Zlcl90aW1lOjM4NSwgbWludXRlOjM4NywgbW9udGg6Mzg5LCBwaTozOTEsIHByZWRpY3RfbGluZWFyOjM5MywgcHJlc2VudF9vdmVyX3RpbWU6Mzk1LCBxdWFudGlsZV9vdmVyX3RpbWU6Mzk3LCByYWQ6Mzk5LCByYXRlOjQwMSwgcmVzZXRzOjQwMywgcm91bmQ6NDA1LCBzY2FsYXI6NDA3LCBzZ246NDA5LCBzaW46NDExLCBzaW5oOjQxMywgc29ydDo0MTUsIHNvcnRfZGVzYzo0MTcsIHNxcnQ6NDE5LCBzdGRkZXZfb3Zlcl90aW1lOjQyMSwgc3RkdmFyX292ZXJfdGltZTo0MjMsIHN1bV9vdmVyX3RpbWU6NDI1LCB0YW46NDI3LCB0YW5oOjQyOSwgdGltZXN0YW1wOjQzMSwgdGltZTo0MzMsIHZlY3Rvcjo0MzUsIHllYXI6NDM3fTtcbmNvbnN0IHBhcnNlciA9IExSUGFyc2VyLmRlc2VyaWFsaXplKHtcbiAgdmVyc2lvbjogMTMsXG4gIHN0YXRlczogXCI2W09ZUVBPT08me1FQT09PT1FPJyNDeycjQ3tPJ1FRUE8nI0N6USddUVFPT09PUU8nI0RlJyNEZU8nV1FQTycjRGRPT1FPJyNFfScjRX1PKGpRUE8nI0ZUT1lRUE8nI0ZQT1lRUE8nI0ZTT09RTycjRlYnI0ZWTy5mUVNPJyNGV08ublFRTycjRlVPT1FPJyNGVScjRlVPT1FPJyNDeScjQ3lPT1FPJyNEZicjRGZPT1FPJyNEaCcjRGhPT1FPJyNEaScjRGlPT1FPJyNEaicjRGpPT1FPJyNEaycjRGtPT1FPJyNEbCcjRGxPT1FPJyNEbScjRG1PT1FPJyNEbicjRG5PT1FPJyNEbycjRG9PT1FPJyNEcCcjRHBPT1FPJyNEcScjRHFPT1FPJyNEcicjRHJPT1FPJyNEcycjRHNPT1FPJyNEdCcjRHRPT1FPJyNEdScjRHVPT1FPJyNEdicjRHZPT1FPJyNEdycjRHdPT1FPJyNEeCcjRHhPT1FPJyNEeScjRHlPT1FPJyNEeicjRHpPT1FPJyNEeycjRHtPT1FPJyNEfCcjRHxPT1FPJyNEfScjRH1PT1FPJyNFTycjRU9PT1FPJyNFUCcjRVBPT1FPJyNFUScjRVFPT1FPJyNFUicjRVJPT1FPJyNFUycjRVNPT1FPJyNFVCcjRVRPT1FPJyNFVScjRVVPT1FPJyNFVicjRVZPT1FPJyNFVycjRVdPT1FPJyNFWCcjRVhPT1FPJyNFWScjRVlPT1FPJyNFWicjRVpPT1FPJyNFWycjRVtPT1FPJyNFXScjRV1PT1FPJyNFXicjRV5PT1FPJyNFXycjRV9PT1FPJyNFYCcjRWBPT1FPJyNFYScjRWFPT1FPJyNFYicjRWJPT1FPJyNFYycjRWNPT1FPJyNFZCcjRWRPT1FPJyNFZScjRWVPT1FPJyNFZicjRWZPT1FPJyNFZycjRWdPT1FPJyNFaCcjRWhPT1FPJyNFaScjRWlPT1FPJyNFaicjRWpPT1FPJyNFaycjRWtPT1FPJyNFbCcjRWxPT1FPJyNFbScjRW1PT1FPJyNFbicjRW5PT1FPJyNFbycjRW9PT1FPJyNFcCcjRXBPT1FPJyNFcScjRXFPT1FPJyNFcicjRXJPT1FPJyNFcycjRXNPT1FPJyNFdCcjRXRPT1FPJyNFdScjRXVPT1FPJyNFdicjRXZPT1FPJyNFdycjRXdPT1FPJyNFeCcjRXhPT1FPJyNFeScjRXlPT1FPJyNFeicjRXpRT1FQT09PMFhRUE8nI0N8TzBeUVBPJyNEUk8nV1FQTyw1OWZPMGVRUU8sNTlmTzJSUVBPLDU5b08yUlFQTyw1OW9PMlJRUE8sNTlvTzJSUVBPLDU5b08yUlFQTyw1OW9PN31RUU8sNTtnTzhTUVFPLDU7ak84W1FQTyw1O3lPT1FPLDU6Tyw1Ok9PT1FPLDU7aSw1O2lPOHNRUU8sNTtrTzh6UVFPLDU7bk86YlFQTycjRllPOnBRUE8sNTtyT09RTycjRlgnI0ZYT09RTyw1O3IsNTtyT09RTyw1O3AsNTtwTzp4UVNPJyNDfU9PUU8sNTloLDU5aE87UVFQTyw1OW1PO1lRUU8nI0RTT09RTyw1OW0sNTltT09RTzFHL1ExRy9RTzBYUVBPJyNEV09BVlFQTycjRFZPQWFRUE8nI0RWT1lRUE8xRy9aT1lRUE8xRy9aT1lRUE8xRy9aT1lRUE8xRy9aT1lRUE8xRy9aT0FrUVNPMUcxUk9PUU8xRzFVMUcxVU9Bc1FRTzFHMVVPQXhRUE8nI0V9T09RTycjRmEnI0ZhT09RTzFHMWUxRzFlT0JUUVBPMUcxZU9PUU8xRzFWMUcxVk9PUU8nI0ZaJyNGWk9CWVFQTyw1O3RPQl9RU08xRzFeT09RTzFHMV4xRzFeT09RTycjRFAnI0RQT0JnUVBPLDU5aU9PUU8nI0RPJyNET09PUU8sNTlpLDU5aU9ZUVBPLDU5bk9PUU8xRy9YMUcvWE9PUU8sNTlyLDU5ck9IX1FQTyw1OXFPSGZRUE8sNTlxT0l9UVFPNyskdU9KX1FRTzcrJHVPS3NRUU83KyR1T0xaUVFPNyskdU9NclFRTzcrJHVPT1FPNysmbTcrJm1PTl1RUU83KyZzT09RTzcrJnA3KyZwT05lUVBPNysnUE9PUU8xRzFgMUcxYE9PUU8xRzFfMUcxX09PUU83KyZ4NysmeE9OalFTTzFHL1RPT1FPMUcvVDFHL1RPTnJRUU8xRy9ZT09RTzFHL10xRy9dT058UVBPMUcvXU9PUU88PEpfPDxKX08hJm9RUE88PEpfT09RTzw8Sms8PEprT09RTzFHL1UxRy9VT09RTzcrJG83KyRvT09RTzcrJHc3KyR3T09RT0FOP3lBTj95XCIsXG4gIHN0YXRlRGF0YTogXCIhJnR+TyRaT1NrT1N+T1dRT1hRT1lRT1pRT1tRT11RT15RT19RT2BRT2FRT2JRT2NRTyFaWk8jdF9PJFdWTyRYVk8kW1hPJF9gTyRgYU8kYWJPJGJjTyRjZE8kZGVPJGVmTyRmZ08kZ2hPJGhpTyRpak8kamtPJGtsTyRsbU8kbW5PJG5vTyRvcE8kcHFPJHFyTyRyc08kc3RPJHR1TyR1dk8kdndPJHd4TyR4eU8keXpPJHp7TyR7fE8kfH1PJH0hT08lTyFQTyVQIVFPJVEhUk8lUiFTTyVTIVRPJVQhVU8lVSFWTyVWIVdPJVchWE8lWCFZTyVZIVpPJVohW08lWyFdTyVdIV5PJV4hX08lXyFgTyVgIWFPJWEhYk8lYiFjTyVjIWRPJWQhZU8lZSFmTyVmIWdPJWchaE8laCFpTyVpIWpPJWoha08layFsTyVsIW1PJW0hbk8lbiFvTyVvIXBPJXAhcU8lcSFyTyVyIXNPJXVXTyV2V08ld1ZPJXlbT35PIVpaT35PZCF1T2UhdU8kWyF2T35PVSNQT1YheU9mIXxPZyF9T2ghfE94IXlPeyF5T3wheU99IXlPIU8hek8hUCF6TyFRIXtPIVIhe08hUyF7TyFUIXtPIVUhe08hViF7TyRTI1FPJXMjT09+TyRXI1NPJFgjU08ldyNTT1cjd1hYI3dYWSN3WFojd1hbI3dYXSN3WF4jd1hfI3dYYCN3WGEjd1hiI3dYYyN3WCFaI3dYI3Qjd1gkVyN3WCRYI3dYJFsjd1gkXyN3WCRgI3dYJGEjd1gkYiN3WCRjI3dYJGQjd1gkZSN3WCRmI3dYJGcjd1gkaCN3WCRpI3dYJGojd1gkayN3WCRsI3dYJG0jd1gkbiN3WCRvI3dYJHAjd1gkcSN3WCRyI3dYJHMjd1gkdCN3WCR1I3dYJHYjd1gkdyN3WCR4I3dYJHkjd1gkeiN3WCR7I3dYJHwjd1gkfSN3WCVPI3dYJVAjd1glUSN3WCVSI3dYJVMjd1glVCN3WCVVI3dYJVYjd1glVyN3WCVYI3dYJVkjd1glWiN3WCVbI3dYJV0jd1glXiN3WCVfI3dYJWAjd1glYSN3WCViI3dYJWMjd1glZCN3WCVlI3dYJWYjd1glZyN3WCVoI3dYJWkjd1glaiN3WCVrI3dYJWwjd1glbSN3WCVuI3dYJW8jd1glcCN3WCVxI3dYJXIjd1gldSN3WCV2I3dYJXcjd1gleSN3WH5PdCNWTyV6I1lPfk8leVtPVSN4WFYjeFhmI3hYZyN4WGgjeFh4I3hYeyN4WHwjeFh9I3hYIU8jeFghUCN4WCFRI3hYIVIjeFghUyN4WCFUI3hYIVUjeFghViN4WCRTI3hYJFYjeFglcyN4WCReI3hYJF0jeFh+TyRbI1tPfk8kXiNgT35QWU9kIXVPZSF1T1VuYVZuYWZuYWduYWhuYXhuYXtuYXxuYX1uYSFPbmEhUG5hIVFuYSFSbmEhU25hIVRuYSFVbmEhVm5hJFNuYSRWbmElc25hJF5uYSRdbmF+T1AjZE9RI2JPUiNiT1d5UFh5UFl5UFp5UFt5UF15UF55UF95UGB5UGF5UGJ5UGN5UCFaeVAjdHlQJFd5UCRYeVAkW3lQJF95UCRgeVAkYXlQJGJ5UCRjeVAkZHlQJGV5UCRmeVAkZ3lQJGh5UCRpeVAkanlQJGt5UCRseVAkbXlQJG55UCRveVAkcHlQJHF5UCRyeVAkc3lQJHR5UCR1eVAkdnlQJHd5UCR4eVAkeXlQJHp5UCR7eVAkfHlQJH15UCVPeVAlUHlQJVF5UCVSeVAlU3lQJVR5UCVVeVAlVnlQJVd5UCVYeVAlWXlQJVp5UCVbeVAlXXlQJV55UCVfeVAlYHlQJWF5UCVieVAlY3lQJWR5UCVleVAlZnlQJWd5UCVoeVAlaXlQJWp5UCVreVAlbHlQJW15UCVueVAlb3lQJXB5UCVxeVAlcnlQJXV5UCV2eVAld3lQJXl5UH5PI3Ajak9+TyFQI2xPI3Aja09+T2kjbk9qI25PJFdWTyRYVk8ldSNtTyV2I21PJXdWT35PJF4jcU9+UCddT3gheU9VI3ZhViN2YWYjdmFnI3ZhaCN2YXsjdmF8I3ZhfSN2YSFPI3ZhIVAjdmEhUSN2YSFSI3ZhIVMjdmEhVCN2YSFVI3ZhIVYjdmEkUyN2YSRWI3ZhJXMjdmEkXiN2YSRdI3Zhfk8hViNyTyRPI3JPJFAjck8kUSNyT35PJF0jdE8leiN1T35PdCN2TyReI3lPfk8kXSN6TyReI3tPfk8kXXZYJF52WH5QJ11PV3lYWHlYWXlYWnlYW3lYXXlYXnlYX3lYYHlYYXlYYnlYY3lYIVp5WCN0eVgkV3lYJFh5WCRbeVgkX3lYJGB5WCRheVgkYnlYJGN5WCRkeVgkZXlYJGZ5WCRneVgkaHlYJGl5WCRqeVgka3lYJGx5WCRteVgkbnlYJG95WCRweVgkcXlYJHJ5WCRzeVgkdHlYJHV5WCR2eVgkd3lYJHh5WCR5eVgkenlYJHt5WCR8eVgkfXlYJU95WCVQeVglUXlYJVJ5WCVTeVglVHlYJVV5WCVWeVglV3lYJVh5WCVZeVglWnlYJVt5WCVdeVglXnlYJV95WCVgeVglYXlYJWJ5WCVjeVglZHlYJWV5WCVmeVglZ3lYJWh5WCVpeVglanlYJWt5WCVseVglbXlYJW55WCVveVglcHlYJXF5WCVyeVgldXlYJXZ5WCV3eVgleXlYfk9TI31PVCN9T35QO2RPUSNiT1IjYk9+UDtkTyV0JFVPJXgkVk9+TyNwJFdPfk8kVyNTTyRYI1NPJXcjU09+TyRbJFhPfk8jdCRZT35PdCNWTyV6JFtPfk8kXSRdTyReJF5Pfk9XeWFYeWFZeWFaeWFbeWFdeWFeeWFfeWFgeWFheWFieWFjeWEhWnlhI3R5YSRXeWEkWHlhJF95YSRgeWEkYXlhJGJ5YSRjeWEkZHlhJGV5YSRmeWEkZ3lhJGh5YSRpeWEkanlhJGt5YSRseWEkbXlhJG55YSRveWEkcHlhJHF5YSRyeWEkc3lhJHR5YSR1eWEkdnlhJHd5YSR4eWEkeXlhJHp5YSR7eWEkfHlhJH15YSVPeWElUHlhJVF5YSVSeWElU3lhJVR5YSVVeWElVnlhJVd5YSVYeWElWXlhJVp5YSVbeWElXXlhJV55YSVfeWElYHlhJWF5YSVieWElY3lhJWR5YSVleWElZnlhJWd5YSVoeWElaXlhJWp5YSVreWElbHlhJW15YSVueWElb3lhJXB5YSVxeWElcnlhJXV5YSV2eWEld3lhJXl5YX5PJFsjW09+UEJvT1MkYU9UJGFPJFt5YX5QQm9PeCF5T1V3cWZ3cWd3cWh3cSFPd3EhUHdxIVF3cSFSd3EhU3dxIVR3cSFVd3EhVndxJFN3cSRWd3Elc3dxJF53cSRdd3F+T1Z3cXt3cXx3cX13cX5QSHNPViF5T3sheU98IXlPfSF5T35QSHNPViF5T3gheU97IXlPfCF5T30heU8hTyF6TyFQIXpPVXdxZndxZ3dxaHdxJFN3cSRWd3Elc3dxJF53cSRdd3F+TyFRd3EhUndxIVN3cSFUd3EhVXdxIVZ3cX5QSm9PIVEhe08hUiF7TyFTIXtPIVQhe08hVSF7TyFWIXtPflBKb09WIXlPZiF8T2ghfE94IXlPeyF5T3wheU99IXlPIU8hek8hUCF6TyFRIXtPIVIhe08hUyF7TyFUIXtPIVUhe08hViF7T35PVXdxZ3dxJFN3cSRWd3Elc3dxJF53cSRdd3F+UExxTyNwJGNPJXQkYk9+TyReJGRPfk90I3ZPJF4kZk9+TyRddmkkXnZpflAnXU8kWyNbT1d5aVh5aVl5aVp5aVt5aV15aV55aV95aWB5aWF5aWJ5aWN5aSFaeWkjdHlpJFd5aSRYeWkkX3lpJGB5aSRheWkkYnlpJGN5aSRkeWkkZXlpJGZ5aSRneWkkaHlpJGl5aSRqeWkka3lpJGx5aSRteWkkbnlpJG95aSRweWkkcXlpJHJ5aSRzeWkkdHlpJHV5aSR2eWkkd3lpJHh5aSR5eWkkenlpJHt5aSR8eWkkfXlpJU95aSVQeWklUXlpJVJ5aSVTeWklVHlpJVV5aSVWeWklV3lpJVh5aSVZeWklWnlpJVt5aSVdeWklXnlpJV95aSVgeWklYXlpJWJ5aSVjeWklZHlpJWV5aSVmeWklZ3lpJWh5aSVpeWklanlpJWt5aSVseWklbXlpJW55aSVveWklcHlpJXF5aSVyeWkldXlpJXZ5aSV3eWkleXlpfk8ldCRoT35PXCIsXG4gIGdvdG86IFwiKHUkVVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQJFYkdSVSJV8lZSVxJXRQJXomVCR1UCZXJmdQUFBQUFBQUFBQUCR1JnEmfVAmfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9JHVQJ1okdSR1UCR1JHUnaiR1J3YoVihmKGkob1BQUCR1UChyUVNPUSNUWFEjVVlRI18hdlEkUCNlUSRRI2ZRJFIjZ1EkUyNoUSRUI2lSJF8jemVfT1hZIXYjZSNmI2cjaCNpI3plUk9YWSF2I2UjZiNnI2gjaSN6USF3UlIjYSF4USNdIXVRI3wjYlEkYCN9UiRnJGFSI3cjW1EjeCNbUiRlJF1RIXhSUSNSVVIjYSF3UiNeIXZRI2UheVEjZiF6USNnIXtRI2ghfFIjaSF9WSNjIXkheiF7IXwhfVIkTyNkZVVPWFkhdiNlI2YjZyNoI2kjemVUT1hZIXYjZSNmI2cjaCNpI3pkX09YWSF2I2UjZiNnI2gjaSN6UiNvI1FlWU9YWSF2I2UjZiNnI2gjaSN6ZF1PWFkhdiNlI2YjZyNoI2kjelIhdFBkXk9YWSF2I2UjZiNnI2gjaSN6UiNaXVIjV1tRI1hbUiRaI3RSI3MjVlIjcCNRXCIsXG4gIG5vZGVOYW1lczogXCLimqAgQm9vbCBJZ25vcmluZyBPbiBHcm91cExlZnQgR3JvdXBSaWdodCBPZmZzZXQgQXRhbjIgQXZnIEJvdHRvbWsgQ291bnQgQ291bnRWYWx1ZXMgR3JvdXAgTWF4IE1pbiBRdWFudGlsZSBTdGRkZXYgU3RkdmFyIFN1bSBUb3BrIEJ5IFdpdGhvdXQgQW5kIE9yIFVubGVzcyBTdGFydCBFbmQgTGluZUNvbW1lbnQgUHJvbVFMIEV4cHIgQWdncmVnYXRlRXhwciBBZ2dyZWdhdGVPcCBBZ2dyZWdhdGVNb2RpZmllciBHcm91cGluZ0xhYmVscyBHcm91cGluZ0xhYmVsTGlzdCBHcm91cGluZ0xhYmVsIExhYmVsTmFtZSBGdW5jdGlvbkNhbGxCb2R5IEZ1bmN0aW9uQ2FsbEFyZ3MgQmluYXJ5RXhwciBQb3cgQmluTW9kaWZpZXJzIE9uT3JJZ25vcmluZyBNdWwgRGl2IE1vZCBBZGQgU3ViIEVxbCBHdGUgR3RyIEx0ZSBMc3MgTmVxIEZ1bmN0aW9uQ2FsbCBGdW5jdGlvbklkZW50aWZpZXIgQWJzZW50T3ZlclRpbWUgSWRlbnRpZmllciBBYnNlbnQgQWJzIEFjb3MgQWNvc2ggQXNpbiBBc2luaCBBdGFuIEF0YW5oIEF2Z092ZXJUaW1lIENlaWwgQ2hhbmdlcyBDbGFtcCBDbGFtcE1heCBDbGFtcE1pbiBDb3MgQ29zaCBDb3VudE92ZXJUaW1lIERheXNJbk1vbnRoIERheU9mTW9udGggRGF5T2ZXZWVrIERlZyBEZWx0YSBEZXJpdiBFeHAgRmxvb3IgSGlzdG9ncmFtUXVhbnRpbGUgSG9sdFdpbnRlcnMgSG91ciBJZGVsdGEgSW5jcmVhc2UgSXJhdGUgTGFiZWxSZXBsYWNlIExhYmVsSm9pbiBMYXN0T3ZlclRpbWUgTG4gTG9nMTAgTG9nMiBNYXhPdmVyVGltZSBNaW5PdmVyVGltZSBNaW51dGUgTW9udGggUGkgUHJlZGljdExpbmVhciBQcmVzZW50T3ZlclRpbWUgUXVhbnRpbGVPdmVyVGltZSBSYWQgUmF0ZSBSZXNldHMgUm91bmQgU2NhbGFyIFNnbiBTaW4gU2luaCBTb3J0IFNvcnREZXNjIFNxcnQgU3RkZGV2T3ZlclRpbWUgU3RkdmFyT3ZlclRpbWUgU3VtT3ZlclRpbWUgVGFuIFRhbmggVGltZXN0YW1wIFRpbWUgVmVjdG9yIFllYXIgTWF0cml4U2VsZWN0b3IgRHVyYXRpb24gTnVtYmVyTGl0ZXJhbCBPZmZzZXRFeHByIFBhcmVuRXhwciBTdHJpbmdMaXRlcmFsIFN1YnF1ZXJ5RXhwciBVbmFyeUV4cHIgVW5hcnlPcCBWZWN0b3JTZWxlY3RvciBNZXRyaWNJZGVudGlmaWVyIExhYmVsTWF0Y2hlcnMgTGFiZWxNYXRjaExpc3QgTGFiZWxNYXRjaGVyIE1hdGNoT3AgRXFsU2luZ2xlIEVxbFJlZ2V4IE5lcVJlZ2V4IFN0ZXBJbnZhcmlhbnRFeHByIEF0IEF0TW9kaWZpZXJQcmVwcm9jZXNzb3JzIE1ldHJpY05hbWVcIixcbiAgbWF4VGVybTogMjI2LFxuICBza2lwcGVkTm9kZXM6IFswLDI3XSxcbiAgcmVwZWF0Tm9kZUNvdW50OiAwLFxuICB0b2tlbkRhdGE6IFwiMVJ+UndYXiNscHEjbHFyJGFycyR0c3QlaHV2JXN3eCV4eHkmZ3l6Jmx6eyZxe3wmdnx9Jn19IU8nUyFPIVAnWiFQIVEoWiFRIVIoYCFSIVspVyFbIV0tciFeIV8ubiFfIWAueyFgIWEvYiFiIWMvbyFjIX0vdCF9I08wWyNQI1EwYSNRI1IwZiNSI1MvdCNTI1QwayNUI28vdCNvI3AwdyNxI3IwfCN5I3ojbCRmJGcjbCNCWSNCWiNsJElTJElfI2wkSXwkSk8jbCRKVCRKVSNsJEtWJEtXI2wmRlUmRlYjbH4jcVkkWn5YXiNscHEjbCN5I3ojbCRmJGcjbCNCWSNCWiNsJElTJElfI2wkSXwkSk8jbCRKVCRKVSNsJEtWJEtXI2wmRlUmRlYjbH4kZFEhXyFgJGojciNzJG9+JG9PIVZ+fiR0TyRRfn4keVUjdH5PWSR0WnIkdHJzJV1zI08kdCNPI1AlYiNQfiR0fiViTyN0fn4lZVBPfiR0fiVtUWt+T1klaFp+JWh+JXhPfX5+JX1VI3R+T1kleFp3JXh3eCVdeCNPJXgjTyNQJmEjUH4leH4mZFBPfiV4fiZsTyRbfn4mcU8kXn5+JnZPe35SJn1PJXZQIU9RfidTTyRdflInWk8ldVAhUFFQJ15QIVEhWydhUCdmUiV3UCFRIVsnYSFnIWgnbyNYI1knb1AnclJ7fCd7fSFPJ3shUSFbKFJQKE9QIVEhWyhSUChXUCV3UCFRIVsoUn4oYE98flIoZVold1AhTyFQJ2EhUSFbKVchZyFoJ28jVyNYKXsjWCNZJ28jWyNdKmQjYSNiKngjZyNoK2wjayNsK30jbCNtLVcjbSNuLGlSKV1ZJXdQIU8hUCdhIVEhWylXIWchaCdvI1cjWCl7I1gjWSdvI1sjXSpkI2EjYip4I2cjaCtsI2sjbCt9I20jbixpUSpRUCNwUSFRIVsqVFEqV1MhUSFbKlQjWyNdKmQjYSNiKngjZyNoK2xRKmlQI3BRIVEhWypsUSpvUiFRIVsqbCNhI2IqeCNnI2grbFEqfVEjcFEhUSFbK1QjZyNoK2dRK1dSIVEhWytUI2EjYithI2cjaCtsUStkUCNnI2grZ1ErbE8jcFFRK3FQI3BRIVEhWyt0USt3USFRIVsrdCNhI2IrYVEsU1AjcFEhUSFbLFZRLFlUIVEhWyxWI1cjWCl7I1sjXSpkI2EjYip4I2cjaCtsUSxuUCNwUSFRIVsscVEsdFUhUSFbLHEjVyNYKXsjWyNdKmQjYSNiKngjZyNoK2wjayNsK31QLVpSIVEhWy1kIWMhaS1kI1QjWi1kUC1pUiV3UCFRIVstZCFjIWktZCNUI1otZFYteVQleFMhWlIhUSFbLlkhWyFdLlkhYyF9LlkjUiNTLlkjVCNvLllSLl9UIVpSIVEhWy5ZIVshXS5ZIWMhfS5ZI1IjUy5ZI1Qjby5Zfi5zUCFVfiFfIWAudn4ue08hVH5+L1FRJE9QIV8hYC9XI3Ijcy9dUS9dTyFRUX4vYk8kUH5+L2dQIVN+IV8hYC9qfi9vTyFSfn4vdE8kU35WL3tUIVpSdFMhUSFbL3QhWyFdLlkhYyF9L3QjUiNTL3QjVCNvL3R+MGFPJXN+fjBmTyV0fn4wa094fn4wblJPI1MwayNTI1QlXSNUfjBrfjB8TyV5fn4xUk8len5cIixcbiAgdG9rZW5pemVyczogWzAsIDEsIDJdLFxuICB0b3BSdWxlczoge1wiUHJvbVFMXCI6WzAsMjhdLFwiTWV0cmljTmFtZVwiOlsxLDE0NF19LFxuICBzcGVjaWFsaXplZDogW3t0ZXJtOiA1NywgZ2V0OiAodmFsdWUsIHN0YWNrKSA9PiAoc3BlY2lhbGl6ZUlkZW50aWZpZXIodmFsdWUpIDw8IDEpfSx7dGVybTogNTcsIGdldDogKHZhbHVlLCBzdGFjaykgPT4gKGV4dGVuZElkZW50aWZpZXIodmFsdWUpIDw8IDEpIHwgMX0se3Rlcm06IDU3LCBnZXQ6IHZhbHVlID0+IHNwZWNfSWRlbnRpZmllclt2YWx1ZV0gfHwgLTF9XSxcbiAgdG9rZW5QcmVjOiAwXG59KTtcbi8vIFRoaXMgZmlsZSB3YXMgZ2VuZXJhdGVkIGJ5IGxlemVyLWdlbmVyYXRvci4gWW91IHByb2JhYmx5IHNob3VsZG4ndCBlZGl0IGl0LlxuY29uc3QgXG4gIGluZiQxID0gMTQ2LFxuICBuYW4kMSA9IDE0NyxcbiAgQm9vbCQxID0gMSxcbiAgSWdub3JpbmckMSA9IDIsXG4gIE9uJDEgPSAzLFxuICBHcm91cExlZnQkMSA9IDQsXG4gIEdyb3VwUmlnaHQkMSA9IDUsXG4gIE9mZnNldCQxID0gNixcbiAgQXRhbjIkMSA9IDcsXG4gIEF2ZyQxID0gOCxcbiAgQm90dG9tayQxID0gOSxcbiAgQ291bnQkMSA9IDEwLFxuICBDb3VudFZhbHVlcyQxID0gMTEsXG4gIEdyb3VwJDEgPSAxMixcbiAgTWF4JDEgPSAxMyxcbiAgTWluJDEgPSAxNCxcbiAgUXVhbnRpbGUkMSA9IDE1LFxuICBTdGRkZXYkMSA9IDE2LFxuICBTdGR2YXIkMSA9IDE3LFxuICBTdW0kMSA9IDE4LFxuICBUb3BrJDEgPSAxOSxcbiAgQnkkMSA9IDIwLFxuICBXaXRob3V0JDEgPSAyMSxcbiAgQW5kJDEgPSAyMixcbiAgT3IkMSA9IDIzLFxuICBVbmxlc3MkMSA9IDI0LFxuICBTdGFydCQxID0gMjUsXG4gIEVuZCQxID0gMjYsXG4gIExpbmVDb21tZW50ID0gMjcsXG4gIFByb21RTCA9IDI4LFxuICBFeHByID0gMjksXG4gIEFnZ3JlZ2F0ZUV4cHIgPSAzMCxcbiAgQWdncmVnYXRlT3AgPSAzMSxcbiAgQWdncmVnYXRlTW9kaWZpZXIgPSAzMixcbiAgR3JvdXBpbmdMYWJlbHMgPSAzMyxcbiAgR3JvdXBpbmdMYWJlbExpc3QgPSAzNCxcbiAgR3JvdXBpbmdMYWJlbCA9IDM1LFxuICBMYWJlbE5hbWUgPSAzNixcbiAgRnVuY3Rpb25DYWxsQm9keSA9IDM3LFxuICBGdW5jdGlvbkNhbGxBcmdzID0gMzgsXG4gIEJpbmFyeUV4cHIgPSAzOSxcbiAgUG93ID0gNDAsXG4gIEJpbk1vZGlmaWVycyA9IDQxLFxuICBPbk9ySWdub3JpbmcgPSA0MixcbiAgTXVsID0gNDMsXG4gIERpdiA9IDQ0LFxuICBNb2QgPSA0NSxcbiAgQWRkID0gNDYsXG4gIFN1YiA9IDQ3LFxuICBFcWwgPSA0OCxcbiAgR3RlID0gNDksXG4gIEd0ciA9IDUwLFxuICBMdGUgPSA1MSxcbiAgTHNzID0gNTIsXG4gIE5lcSA9IDUzLFxuICBGdW5jdGlvbkNhbGwgPSA1NCxcbiAgRnVuY3Rpb25JZGVudGlmaWVyID0gNTUsXG4gIEFic2VudE92ZXJUaW1lID0gNTYsXG4gIElkZW50aWZpZXIgPSA1NyxcbiAgQWJzZW50ID0gNTgsXG4gIEFicyA9IDU5LFxuICBBY29zID0gNjAsXG4gIEFjb3NoID0gNjEsXG4gIEFzaW4gPSA2MixcbiAgQXNpbmggPSA2MyxcbiAgQXRhbiA9IDY0LFxuICBBdGFuaCA9IDY1LFxuICBBdmdPdmVyVGltZSA9IDY2LFxuICBDZWlsID0gNjcsXG4gIENoYW5nZXMgPSA2OCxcbiAgQ2xhbXAgPSA2OSxcbiAgQ2xhbXBNYXggPSA3MCxcbiAgQ2xhbXBNaW4gPSA3MSxcbiAgQ29zID0gNzIsXG4gIENvc2ggPSA3MyxcbiAgQ291bnRPdmVyVGltZSA9IDc0LFxuICBEYXlzSW5Nb250aCA9IDc1LFxuICBEYXlPZk1vbnRoID0gNzYsXG4gIERheU9mV2VlayA9IDc3LFxuICBEZWcgPSA3OCxcbiAgRGVsdGEgPSA3OSxcbiAgRGVyaXYgPSA4MCxcbiAgRXhwID0gODEsXG4gIEZsb29yID0gODIsXG4gIEhpc3RvZ3JhbVF1YW50aWxlID0gODMsXG4gIEhvbHRXaW50ZXJzID0gODQsXG4gIEhvdXIgPSA4NSxcbiAgSWRlbHRhID0gODYsXG4gIEluY3JlYXNlID0gODcsXG4gIElyYXRlID0gODgsXG4gIExhYmVsUmVwbGFjZSA9IDg5LFxuICBMYWJlbEpvaW4gPSA5MCxcbiAgTGFzdE92ZXJUaW1lID0gOTEsXG4gIExuID0gOTIsXG4gIExvZzEwID0gOTMsXG4gIExvZzIgPSA5NCxcbiAgTWF4T3ZlclRpbWUgPSA5NSxcbiAgTWluT3ZlclRpbWUgPSA5NixcbiAgTWludXRlID0gOTcsXG4gIE1vbnRoID0gOTgsXG4gIFBpID0gOTksXG4gIFByZWRpY3RMaW5lYXIgPSAxMDAsXG4gIFByZXNlbnRPdmVyVGltZSA9IDEwMSxcbiAgUXVhbnRpbGVPdmVyVGltZSA9IDEwMixcbiAgUmFkID0gMTAzLFxuICBSYXRlID0gMTA0LFxuICBSZXNldHMgPSAxMDUsXG4gIFJvdW5kID0gMTA2LFxuICBTY2FsYXIgPSAxMDcsXG4gIFNnbiA9IDEwOCxcbiAgU2luID0gMTA5LFxuICBTaW5oID0gMTEwLFxuICBTb3J0ID0gMTExLFxuICBTb3J0RGVzYyA9IDExMixcbiAgU3FydCA9IDExMyxcbiAgU3RkZGV2T3ZlclRpbWUgPSAxMTQsXG4gIFN0ZHZhck92ZXJUaW1lID0gMTE1LFxuICBTdW1PdmVyVGltZSA9IDExNixcbiAgVGFuID0gMTE3LFxuICBUYW5oID0gMTE4LFxuICBUaW1lc3RhbXAgPSAxMTksXG4gIFRpbWUgPSAxMjAsXG4gIFZlY3RvciA9IDEyMSxcbiAgWWVhciA9IDEyMixcbiAgTWF0cml4U2VsZWN0b3IgPSAxMjMsXG4gIER1cmF0aW9uID0gMTI0LFxuICBOdW1iZXJMaXRlcmFsID0gMTI1LFxuICBPZmZzZXRFeHByID0gMTI2LFxuICBQYXJlbkV4cHIgPSAxMjcsXG4gIFN0cmluZ0xpdGVyYWwgPSAxMjgsXG4gIFN1YnF1ZXJ5RXhwciA9IDEyOSxcbiAgVW5hcnlFeHByID0gMTMwLFxuICBVbmFyeU9wID0gMTMxLFxuICBWZWN0b3JTZWxlY3RvciA9IDEzMixcbiAgTWV0cmljSWRlbnRpZmllciA9IDEzMyxcbiAgTGFiZWxNYXRjaGVycyA9IDEzNCxcbiAgTGFiZWxNYXRjaExpc3QgPSAxMzUsXG4gIExhYmVsTWF0Y2hlciA9IDEzNixcbiAgTWF0Y2hPcCA9IDEzNyxcbiAgRXFsU2luZ2xlID0gMTM4LFxuICBFcWxSZWdleCA9IDEzOSxcbiAgTmVxUmVnZXggPSAxNDAsXG4gIFN0ZXBJbnZhcmlhbnRFeHByID0gMTQxLFxuICBBdCA9IDE0MixcbiAgQXRNb2RpZmllclByZXByb2Nlc3NvcnMgPSAxNDMsXG4gIE1ldHJpY05hbWUgPSAxNDQ7XG5cbmV4cG9ydCB7IEFicywgQWJzZW50LCBBYnNlbnRPdmVyVGltZSwgQWNvcywgQWNvc2gsIEFkZCwgQWdncmVnYXRlRXhwciwgQWdncmVnYXRlTW9kaWZpZXIsIEFnZ3JlZ2F0ZU9wLCBBbmQkMSBhcyBBbmQsIEFzaW4sIEFzaW5oLCBBdCwgQXRNb2RpZmllclByZXByb2Nlc3NvcnMsIEF0YW4sIEF0YW4yJDEgYXMgQXRhbjIsIEF0YW5oLCBBdmckMSBhcyBBdmcsIEF2Z092ZXJUaW1lLCBCaW5Nb2RpZmllcnMsIEJpbmFyeUV4cHIsIEJvb2wkMSBhcyBCb29sLCBCb3R0b21rJDEgYXMgQm90dG9taywgQnkkMSBhcyBCeSwgQ2VpbCwgQ2hhbmdlcywgQ2xhbXAsIENsYW1wTWF4LCBDbGFtcE1pbiwgQ29zLCBDb3NoLCBDb3VudCQxIGFzIENvdW50LCBDb3VudE92ZXJUaW1lLCBDb3VudFZhbHVlcyQxIGFzIENvdW50VmFsdWVzLCBEYXlPZk1vbnRoLCBEYXlPZldlZWssIERheXNJbk1vbnRoLCBEZWcsIERlbHRhLCBEZXJpdiwgRGl2LCBEdXJhdGlvbiwgRW5kJDEgYXMgRW5kLCBFcWwsIEVxbFJlZ2V4LCBFcWxTaW5nbGUsIEV4cCwgRXhwciwgRmxvb3IsIEZ1bmN0aW9uQ2FsbCwgRnVuY3Rpb25DYWxsQXJncywgRnVuY3Rpb25DYWxsQm9keSwgRnVuY3Rpb25JZGVudGlmaWVyLCBHcm91cCQxIGFzIEdyb3VwLCBHcm91cExlZnQkMSBhcyBHcm91cExlZnQsIEdyb3VwUmlnaHQkMSBhcyBHcm91cFJpZ2h0LCBHcm91cGluZ0xhYmVsLCBHcm91cGluZ0xhYmVsTGlzdCwgR3JvdXBpbmdMYWJlbHMsIEd0ZSwgR3RyLCBIaXN0b2dyYW1RdWFudGlsZSwgSG9sdFdpbnRlcnMsIEhvdXIsIElkZWx0YSwgSWRlbnRpZmllciwgSWdub3JpbmckMSBhcyBJZ25vcmluZywgSW5jcmVhc2UsIElyYXRlLCBMYWJlbEpvaW4sIExhYmVsTWF0Y2hMaXN0LCBMYWJlbE1hdGNoZXIsIExhYmVsTWF0Y2hlcnMsIExhYmVsTmFtZSwgTGFiZWxSZXBsYWNlLCBMYXN0T3ZlclRpbWUsIExpbmVDb21tZW50LCBMbiwgTG9nMTAsIExvZzIsIExzcywgTHRlLCBNYXRjaE9wLCBNYXRyaXhTZWxlY3RvciwgTWF4JDEgYXMgTWF4LCBNYXhPdmVyVGltZSwgTWV0cmljSWRlbnRpZmllciwgTWV0cmljTmFtZSwgTWluJDEgYXMgTWluLCBNaW5PdmVyVGltZSwgTWludXRlLCBNb2QsIE1vbnRoLCBNdWwsIE5lcSwgTmVxUmVnZXgsIE51bWJlckxpdGVyYWwsIE9mZnNldCQxIGFzIE9mZnNldCwgT2Zmc2V0RXhwciwgT24kMSBhcyBPbiwgT25Pcklnbm9yaW5nLCBPciQxIGFzIE9yLCBQYXJlbkV4cHIsIFBpLCBQb3csIFByZWRpY3RMaW5lYXIsIFByZXNlbnRPdmVyVGltZSwgUHJvbVFMLCBRdWFudGlsZSQxIGFzIFF1YW50aWxlLCBRdWFudGlsZU92ZXJUaW1lLCBSYWQsIFJhdGUsIFJlc2V0cywgUm91bmQsIFNjYWxhciwgU2duLCBTaW4sIFNpbmgsIFNvcnQsIFNvcnREZXNjLCBTcXJ0LCBTdGFydCQxIGFzIFN0YXJ0LCBTdGRkZXYkMSBhcyBTdGRkZXYsIFN0ZGRldk92ZXJUaW1lLCBTdGR2YXIkMSBhcyBTdGR2YXIsIFN0ZHZhck92ZXJUaW1lLCBTdGVwSW52YXJpYW50RXhwciwgU3RyaW5nTGl0ZXJhbCwgU3ViLCBTdWJxdWVyeUV4cHIsIFN1bSQxIGFzIFN1bSwgU3VtT3ZlclRpbWUsIFRhbiwgVGFuaCwgVGltZSwgVGltZXN0YW1wLCBUb3BrJDEgYXMgVG9waywgVW5hcnlFeHByLCBVbmFyeU9wLCBVbmxlc3MkMSBhcyBVbmxlc3MsIFZlY3RvciwgVmVjdG9yU2VsZWN0b3IsIFdpdGhvdXQkMSBhcyBXaXRob3V0LCBZZWFyLCBpbmYkMSBhcyBpbmYsIG5hbiQxIGFzIG5hbiwgcGFyc2VyIH07XG4iLCIvLyBGSVhNRSBwcm9maWxlIGFkZGluZyBhIHBlci1UcmVlIFRyZWVOb2RlIGNhY2hlLCB2YWxpZGF0aW5nIGl0IGJ5XG4vLyBwYXJlbnQgcG9pbnRlclxuLy8vIFRoZSBkZWZhdWx0IG1heGltdW0gbGVuZ3RoIG9mIGEgYFRyZWVCdWZmZXJgIG5vZGUgKDEwMjQpLlxuY29uc3QgRGVmYXVsdEJ1ZmZlckxlbmd0aCA9IDEwMjQ7XG5sZXQgbmV4dFByb3BJRCA9IDA7XG5jbGFzcyBSYW5nZSB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbn1cbi8vLyBFYWNoIFtub2RlIHR5cGVdKCNjb21tb24uTm9kZVR5cGUpIG9yIFtpbmRpdmlkdWFsIHRyZWVdKCNjb21tb24uVHJlZSlcbi8vLyBjYW4gaGF2ZSBtZXRhZGF0YSBhc3NvY2lhdGVkIHdpdGggaXQgaW4gcHJvcHMuIEluc3RhbmNlcyBvZiB0aGlzXG4vLy8gY2xhc3MgcmVwcmVzZW50IHByb3AgbmFtZXMuXG5jbGFzcyBOb2RlUHJvcCB7XG4gICAgLy8vIENyZWF0ZSBhIG5ldyBub2RlIHByb3AgdHlwZS5cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgICAgICB0aGlzLmlkID0gbmV4dFByb3BJRCsrO1xuICAgICAgICB0aGlzLnBlck5vZGUgPSAhIWNvbmZpZy5wZXJOb2RlO1xuICAgICAgICB0aGlzLmRlc2VyaWFsaXplID0gY29uZmlnLmRlc2VyaWFsaXplIHx8ICgoKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIG5vZGUgdHlwZSBkb2Vzbid0IGRlZmluZSBhIGRlc2VyaWFsaXplIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8vIFRoaXMgaXMgbWVhbnQgdG8gYmUgdXNlZCB3aXRoXG4gICAgLy8vIFtgTm9kZVNldC5leHRlbmRgXSgjY29tbW9uLk5vZGVTZXQuZXh0ZW5kKSBvclxuICAgIC8vLyBbYExSUGFyc2VyLmNvbmZpZ3VyZWBdKCNsci5QYXJzZXJDb25maWcucHJvcHMpIHRvIGNvbXB1dGVcbiAgICAvLy8gcHJvcCB2YWx1ZXMgZm9yIGVhY2ggbm9kZSB0eXBlIGluIHRoZSBzZXQuIFRha2VzIGEgW21hdGNoXG4gICAgLy8vIG9iamVjdF0oI2NvbW1vbi5Ob2RlVHlwZV5tYXRjaCkgb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHVuZGVmaW5lZFxuICAgIC8vLyBpZiB0aGUgbm9kZSB0eXBlIGRvZXNuJ3QgZ2V0IHRoaXMgcHJvcCwgYW5kIHRoZSBwcm9wJ3MgdmFsdWUgaWZcbiAgICAvLy8gaXQgZG9lcy5cbiAgICBhZGQobWF0Y2gpIHtcbiAgICAgICAgaWYgKHRoaXMucGVyTm9kZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuJ3QgYWRkIHBlci1ub2RlIHByb3BzIHRvIG5vZGUgdHlwZXNcIik7XG4gICAgICAgIGlmICh0eXBlb2YgbWF0Y2ggIT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgbWF0Y2ggPSBOb2RlVHlwZS5tYXRjaChtYXRjaCk7XG4gICAgICAgIHJldHVybiAodHlwZSkgPT4ge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG1hdGNoKHR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IFt0aGlzLCByZXN1bHRdO1xuICAgICAgICB9O1xuICAgIH1cbn1cbi8vLyBQcm9wIHRoYXQgaXMgdXNlZCB0byBkZXNjcmliZSBtYXRjaGluZyBkZWxpbWl0ZXJzLiBGb3Igb3BlbmluZ1xuLy8vIGRlbGltaXRlcnMsIHRoaXMgaG9sZHMgYW4gYXJyYXkgb2Ygbm9kZSBuYW1lcyAod3JpdHRlbiBhcyBhXG4vLy8gc3BhY2Utc2VwYXJhdGVkIHN0cmluZyB3aGVuIGRlY2xhcmluZyB0aGlzIHByb3AgaW4gYSBncmFtbWFyKVxuLy8vIGZvciB0aGUgbm9kZSB0eXBlcyBvZiBjbG9zaW5nIGRlbGltaXRlcnMgdGhhdCBtYXRjaCBpdC5cbk5vZGVQcm9wLmNsb3NlZEJ5ID0gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6IHN0ciA9PiBzdHIuc3BsaXQoXCIgXCIpIH0pO1xuLy8vIFRoZSBpbnZlcnNlIG9mIFtgY2xvc2VkQnlgXSgjY29tbW9uLk5vZGVQcm9wXmNsb3NlZEJ5KS4gVGhpcyBpc1xuLy8vIGF0dGFjaGVkIHRvIGNsb3NpbmcgZGVsaW1pdGVycywgaG9sZGluZyBhbiBhcnJheSBvZiBub2RlIG5hbWVzXG4vLy8gb2YgdHlwZXMgb2YgbWF0Y2hpbmcgb3BlbmluZyBkZWxpbWl0ZXJzLlxuTm9kZVByb3Aub3BlbmVkQnkgPSBuZXcgTm9kZVByb3AoeyBkZXNlcmlhbGl6ZTogc3RyID0+IHN0ci5zcGxpdChcIiBcIikgfSk7XG4vLy8gVXNlZCB0byBhc3NpZ24gbm9kZSB0eXBlcyB0byBncm91cHMgKGZvciBleGFtcGxlLCBhbGwgbm9kZVxuLy8vIHR5cGVzIHRoYXQgcmVwcmVzZW50IGFuIGV4cHJlc3Npb24gY291bGQgYmUgdGFnZ2VkIHdpdGggYW5cbi8vLyBgXCJFeHByZXNzaW9uXCJgIGdyb3VwKS5cbk5vZGVQcm9wLmdyb3VwID0gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6IHN0ciA9PiBzdHIuc3BsaXQoXCIgXCIpIH0pO1xuLy8vIFRoZSBoYXNoIG9mIHRoZSBbY29udGV4dF0oI2xyLkNvbnRleHRUcmFja2VyLmNvbnN0cnVjdG9yKVxuLy8vIHRoYXQgdGhlIG5vZGUgd2FzIHBhcnNlZCBpbiwgaWYgYW55LiBVc2VkIHRvIGxpbWl0IHJldXNlIG9mXG4vLy8gY29udGV4dHVhbCBub2Rlcy5cbk5vZGVQcm9wLmNvbnRleHRIYXNoID0gbmV3IE5vZGVQcm9wKHsgcGVyTm9kZTogdHJ1ZSB9KTtcbi8vLyBUaGUgZGlzdGFuY2UgYmV5b25kIHRoZSBlbmQgb2YgdGhlIG5vZGUgdGhhdCB0aGUgdG9rZW5pemVyXG4vLy8gbG9va2VkIGFoZWFkIGZvciBhbnkgb2YgdGhlIHRva2VucyBpbnNpZGUgdGhlIG5vZGUuIChUaGUgTFJcbi8vLyBwYXJzZXIgb25seSBzdG9yZXMgdGhpcyB3aGVuIGl0IGlzIGxhcmdlciB0aGFuIDI1LCBmb3Jcbi8vLyBlZmZpY2llbmN5IHJlYXNvbnMuKVxuTm9kZVByb3AubG9va0FoZWFkID0gbmV3IE5vZGVQcm9wKHsgcGVyTm9kZTogdHJ1ZSB9KTtcbi8vLyBUaGlzIHBlci1ub2RlIHByb3AgaXMgdXNlZCB0byByZXBsYWNlIGEgZ2l2ZW4gbm9kZSwgb3IgcGFydCBvZiBhXG4vLy8gbm9kZSwgd2l0aCBhbm90aGVyIHRyZWUuIFRoaXMgaXMgdXNlZnVsIHRvIGluY2x1ZGUgdHJlZXMgZnJvbVxuLy8vIGRpZmZlcmVudCBsYW5ndWFnZXMuXG5Ob2RlUHJvcC5tb3VudGVkID0gbmV3IE5vZGVQcm9wKHsgcGVyTm9kZTogdHJ1ZSB9KTtcbi8vLyBBIG1vdW50ZWQgdHJlZSwgd2hpY2ggY2FuIGJlIFtzdG9yZWRdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgb25cbi8vLyBhIHRyZWUgbm9kZSB0byBpbmRpY2F0ZSB0aGF0IHBhcnRzIG9mIGl0cyBjb250ZW50IGFyZVxuLy8vIHJlcHJlc2VudGVkIGJ5IGFub3RoZXIgdHJlZS5cbmNsYXNzIE1vdW50ZWRUcmVlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIGlubmVyIHRyZWUuXG4gICAgdHJlZSwgXG4gICAgLy8vIElmIHRoaXMgaXMgbnVsbCwgdGhpcyB0cmVlIHJlcGxhY2VzIHRoZSBlbnRpcmUgbm9kZSAoaXQgd2lsbFxuICAgIC8vLyBiZSBpbmNsdWRlZCBpbiB0aGUgcmVndWxhciBpdGVyYXRpb24gaW5zdGVhZCBvZiBpdHMgaG9zdFxuICAgIC8vLyBub2RlKS4gSWYgbm90LCBvbmx5IHRoZSBnaXZlbiByYW5nZXMgYXJlIGNvbnNpZGVyZWQgdG8gYmVcbiAgICAvLy8gY292ZXJlZCBieSB0aGlzIHRyZWUuIFRoaXMgaXMgdXNlZCBmb3IgdHJlZXMgdGhhdCBhcmUgbWl4ZWQgaW5cbiAgICAvLy8gYSB3YXkgdGhhdCBpc24ndCBzdHJpY3RseSBoaWVyYXJjaGljYWwuIFN1Y2ggbW91bnRlZCB0cmVlcyBhcmVcbiAgICAvLy8gb25seSBlbnRlcmVkIGJ5IFtgcmVzb2x2ZUlubmVyYF0oI2NvbW1vbi5UcmVlLnJlc29sdmVJbm5lcilcbiAgICAvLy8gYW5kIFtgZW50ZXJgXSgjY29tbW9uLlN5bnRheE5vZGUuZW50ZXIpLlxuICAgIG92ZXJsYXksIFxuICAgIC8vLyBUaGUgcGFyc2VyIHVzZWQgdG8gY3JlYXRlIHRoaXMgc3VidHJlZS5cbiAgICBwYXJzZXIpIHtcbiAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgdGhpcy5vdmVybGF5ID0gb3ZlcmxheTtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgfVxufVxuY29uc3Qgbm9Qcm9wcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vLy8gRWFjaCBub2RlIGluIGEgc3ludGF4IHRyZWUgaGFzIGEgbm9kZSB0eXBlIGFzc29jaWF0ZWQgd2l0aCBpdC5cbmNsYXNzIE5vZGVUeXBlIHtcbiAgICAvLy8gQGludGVybmFsXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIFRoZSBuYW1lIG9mIHRoZSBub2RlIHR5cGUuIE5vdCBuZWNlc3NhcmlseSB1bmlxdWUsIGJ1dCBpZiB0aGVcbiAgICAvLy8gZ3JhbW1hciB3YXMgd3JpdHRlbiBwcm9wZXJseSwgZGlmZmVyZW50IG5vZGUgdHlwZXMgd2l0aCB0aGVcbiAgICAvLy8gc2FtZSBuYW1lIHdpdGhpbiBhIG5vZGUgc2V0IHNob3VsZCBwbGF5IHRoZSBzYW1lIHNlbWFudGljXG4gICAgLy8vIHJvbGUuXG4gICAgbmFtZSwgXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHByb3BzLCBcbiAgICAvLy8gVGhlIGlkIG9mIHRoaXMgbm9kZSBpbiBpdHMgc2V0LiBDb3JyZXNwb25kcyB0byB0aGUgdGVybSBpZHNcbiAgICAvLy8gdXNlZCBpbiB0aGUgcGFyc2VyLlxuICAgIGlkLCBcbiAgICAvLy8gQGludGVybmFsXG4gICAgZmxhZ3MgPSAwKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgfVxuICAgIHN0YXRpYyBkZWZpbmUoc3BlYykge1xuICAgICAgICBsZXQgcHJvcHMgPSBzcGVjLnByb3BzICYmIHNwZWMucHJvcHMubGVuZ3RoID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IG5vUHJvcHM7XG4gICAgICAgIGxldCBmbGFncyA9IChzcGVjLnRvcCA/IDEgLyogVG9wICovIDogMCkgfCAoc3BlYy5za2lwcGVkID8gMiAvKiBTa2lwcGVkICovIDogMCkgfFxuICAgICAgICAgICAgKHNwZWMuZXJyb3IgPyA0IC8qIEVycm9yICovIDogMCkgfCAoc3BlYy5uYW1lID09IG51bGwgPyA4IC8qIEFub255bW91cyAqLyA6IDApO1xuICAgICAgICBsZXQgdHlwZSA9IG5ldyBOb2RlVHlwZShzcGVjLm5hbWUgfHwgXCJcIiwgcHJvcHMsIHNwZWMuaWQsIGZsYWdzKTtcbiAgICAgICAgaWYgKHNwZWMucHJvcHMpXG4gICAgICAgICAgICBmb3IgKGxldCBzcmMgb2Ygc3BlYy5wcm9wcykge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzcmMpKVxuICAgICAgICAgICAgICAgICAgICBzcmMgPSBzcmModHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKHNyYykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3JjWzBdLnBlck5vZGUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNhbid0IHN0b3JlIGEgcGVyLW5vZGUgcHJvcCBvbiBhIG5vZGUgdHlwZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNbc3JjWzBdLmlkXSA9IHNyY1sxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgICAvLy8gUmV0cmlldmVzIGEgbm9kZSBwcm9wIGZvciB0aGlzIHR5cGUuIFdpbGwgcmV0dXJuIGB1bmRlZmluZWRgIGlmXG4gICAgLy8vIHRoZSBwcm9wIGlzbid0IHByZXNlbnQgb24gdGhpcyBub2RlLlxuICAgIHByb3AocHJvcCkgeyByZXR1cm4gdGhpcy5wcm9wc1twcm9wLmlkXTsgfVxuICAgIC8vLyBUcnVlIHdoZW4gdGhpcyBpcyB0aGUgdG9wIG5vZGUgb2YgYSBncmFtbWFyLlxuICAgIGdldCBpc1RvcCgpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgMSAvKiBUb3AgKi8pID4gMDsgfVxuICAgIC8vLyBUcnVlIHdoZW4gdGhpcyBub2RlIGlzIHByb2R1Y2VkIGJ5IGEgc2tpcCBydWxlLlxuICAgIGdldCBpc1NraXBwZWQoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDIgLyogU2tpcHBlZCAqLykgPiAwOyB9XG4gICAgLy8vIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgaXMgYW4gZXJyb3Igbm9kZS5cbiAgICBnZXQgaXNFcnJvcigpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgNCAvKiBFcnJvciAqLykgPiAwOyB9XG4gICAgLy8vIFdoZW4gdHJ1ZSwgdGhpcyBub2RlIHR5cGUgZG9lc24ndCBjb3JyZXNwb25kIHRvIGEgdXNlci1kZWNsYXJlZFxuICAgIC8vLyBuYW1lZCBub2RlLCBmb3IgZXhhbXBsZSBiZWNhdXNlIGl0IGlzIHVzZWQgdG8gY2FjaGUgcmVwZXRpdGlvbi5cbiAgICBnZXQgaXNBbm9ueW1vdXMoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDggLyogQW5vbnltb3VzICovKSA+IDA7IH1cbiAgICAvLy8gUmV0dXJucyB0cnVlIHdoZW4gdGhpcyBub2RlJ3MgbmFtZSBvciBvbmUgb2YgaXRzXG4gICAgLy8vIFtncm91cHNdKCNjb21tb24uTm9kZVByb3BeZ3JvdXApIG1hdGNoZXMgdGhlIGdpdmVuIHN0cmluZy5cbiAgICBpcyhuYW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKHRoaXMubmFtZSA9PSBuYW1lKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgbGV0IGdyb3VwID0gdGhpcy5wcm9wKE5vZGVQcm9wLmdyb3VwKTtcbiAgICAgICAgICAgIHJldHVybiBncm91cCA/IGdyb3VwLmluZGV4T2YobmFtZSkgPiAtMSA6IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmlkID09IG5hbWU7XG4gICAgfVxuICAgIC8vLyBDcmVhdGUgYSBmdW5jdGlvbiBmcm9tIG5vZGUgdHlwZXMgdG8gYXJiaXRyYXJ5IHZhbHVlcyBieVxuICAgIC8vLyBzcGVjaWZ5aW5nIGFuIG9iamVjdCB3aG9zZSBwcm9wZXJ0eSBuYW1lcyBhcmUgbm9kZSBvclxuICAgIC8vLyBbZ3JvdXBdKCNjb21tb24uTm9kZVByb3BeZ3JvdXApIG5hbWVzLiBPZnRlbiB1c2VmdWwgd2l0aFxuICAgIC8vLyBbYE5vZGVQcm9wLmFkZGBdKCNjb21tb24uTm9kZVByb3AuYWRkKS4gWW91IGNhbiBwdXQgbXVsdGlwbGVcbiAgICAvLy8gbmFtZXMsIHNlcGFyYXRlZCBieSBzcGFjZXMsIGluIGEgc2luZ2xlIHByb3BlcnR5IG5hbWUgdG8gbWFwXG4gICAgLy8vIG11bHRpcGxlIG5vZGUgbmFtZXMgdG8gYSBzaW5nbGUgdmFsdWUuXG4gICAgc3RhdGljIG1hdGNoKG1hcCkge1xuICAgICAgICBsZXQgZGlyZWN0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBtYXApXG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lIG9mIHByb3Auc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgICAgIGRpcmVjdFtuYW1lXSA9IG1hcFtwcm9wXTtcbiAgICAgICAgcmV0dXJuIChub2RlKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBncm91cHMgPSBub2RlLnByb3AoTm9kZVByb3AuZ3JvdXApLCBpID0gLTE7IGkgPCAoZ3JvdXBzID8gZ3JvdXBzLmxlbmd0aCA6IDApOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBkaXJlY3RbaSA8IDAgPyBub2RlLm5hbWUgOiBncm91cHNbaV1dO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbi8vLyBBbiBlbXB0eSBkdW1teSBub2RlIHR5cGUgdG8gdXNlIHdoZW4gbm8gYWN0dWFsIHR5cGUgaXMgYXZhaWxhYmxlLlxuTm9kZVR5cGUubm9uZSA9IG5ldyBOb2RlVHlwZShcIlwiLCBPYmplY3QuY3JlYXRlKG51bGwpLCAwLCA4IC8qIEFub255bW91cyAqLyk7XG4vLy8gQSBub2RlIHNldCBob2xkcyBhIGNvbGxlY3Rpb24gb2Ygbm9kZSB0eXBlcy4gSXQgaXMgdXNlZCB0b1xuLy8vIGNvbXBhY3RseSByZXByZXNlbnQgdHJlZXMgYnkgc3RvcmluZyB0aGVpciB0eXBlIGlkcywgcmF0aGVyIHRoYW4gYVxuLy8vIGZ1bGwgcG9pbnRlciB0byB0aGUgdHlwZSBvYmplY3QsIGluIGEgbnVtZXJpYyBhcnJheS4gRWFjaCBwYXJzZXJcbi8vLyBbaGFzXSgjbHIuTFJQYXJzZXIubm9kZVNldCkgYSBub2RlIHNldCwgYW5kIFt0cmVlXG4vLy8gYnVmZmVyc10oI2NvbW1vbi5UcmVlQnVmZmVyKSBjYW4gb25seSBzdG9yZSBjb2xsZWN0aW9ucyBvZiBub2Rlc1xuLy8vIGZyb20gdGhlIHNhbWUgc2V0LiBBIHNldCBjYW4gaGF2ZSBhIG1heGltdW0gb2YgMioqMTYgKDY1NTM2KSBub2RlXG4vLy8gdHlwZXMgaW4gaXQsIHNvIHRoYXQgdGhlIGlkcyBmaXQgaW50byAxNi1iaXQgdHlwZWQgYXJyYXkgc2xvdHMuXG5jbGFzcyBOb2RlU2V0IHtcbiAgICAvLy8gQ3JlYXRlIGEgc2V0IHdpdGggdGhlIGdpdmVuIHR5cGVzLiBUaGUgYGlkYCBwcm9wZXJ0eSBvZiBlYWNoXG4gICAgLy8vIHR5cGUgc2hvdWxkIGNvcnJlc3BvbmQgdG8gaXRzIHBvc2l0aW9uIHdpdGhpbiB0aGUgYXJyYXkuXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIFRoZSBub2RlIHR5cGVzIGluIHRoaXMgc2V0LCBieSBpZC5cbiAgICB0eXBlcykge1xuICAgICAgICB0aGlzLnR5cGVzID0gdHlwZXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAodHlwZXNbaV0uaWQgIT0gaSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vZGUgdHlwZSBpZHMgc2hvdWxkIGNvcnJlc3BvbmQgdG8gYXJyYXkgcG9zaXRpb25zIHdoZW4gY3JlYXRpbmcgYSBub2RlIHNldFwiKTtcbiAgICB9XG4gICAgLy8vIENyZWF0ZSBhIGNvcHkgb2YgdGhpcyBzZXQgd2l0aCBzb21lIG5vZGUgcHJvcGVydGllcyBhZGRlZC4gVGhlXG4gICAgLy8vIGFyZ3VtZW50cyB0byB0aGlzIG1ldGhvZCBzaG91bGQgYmUgY3JlYXRlZCB3aXRoXG4gICAgLy8vIFtgTm9kZVByb3AuYWRkYF0oI2NvbW1vbi5Ob2RlUHJvcC5hZGQpLlxuICAgIGV4dGVuZCguLi5wcm9wcykge1xuICAgICAgICBsZXQgbmV3VHlwZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgdHlwZSBvZiB0aGlzLnR5cGVzKSB7XG4gICAgICAgICAgICBsZXQgbmV3UHJvcHMgPSBudWxsO1xuICAgICAgICAgICAgZm9yIChsZXQgc291cmNlIG9mIHByb3BzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGFkZCA9IHNvdXJjZSh0eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoYWRkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmV3UHJvcHMpXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIHR5cGUucHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICBuZXdQcm9wc1thZGRbMF0uaWRdID0gYWRkWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld1R5cGVzLnB1c2gobmV3UHJvcHMgPyBuZXcgTm9kZVR5cGUodHlwZS5uYW1lLCBuZXdQcm9wcywgdHlwZS5pZCwgdHlwZS5mbGFncykgOiB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE5vZGVTZXQobmV3VHlwZXMpO1xuICAgIH1cbn1cbmNvbnN0IENhY2hlZE5vZGUgPSBuZXcgV2Vha01hcCgpLCBDYWNoZWRJbm5lck5vZGUgPSBuZXcgV2Vha01hcCgpO1xuLy8vIEEgcGllY2Ugb2Ygc3ludGF4IHRyZWUuIFRoZXJlIGFyZSB0d28gd2F5cyB0byBhcHByb2FjaCB0aGVzZVxuLy8vIHRyZWVzOiB0aGUgd2F5IHRoZXkgYXJlIGFjdHVhbGx5IHN0b3JlZCBpbiBtZW1vcnksIGFuZCB0aGVcbi8vLyBjb252ZW5pZW50IHdheS5cbi8vL1xuLy8vIFN5bnRheCB0cmVlcyBhcmUgc3RvcmVkIGFzIGEgdHJlZSBvZiBgVHJlZWAgYW5kIGBUcmVlQnVmZmVyYFxuLy8vIG9iamVjdHMuIEJ5IHBhY2tpbmcgZGV0YWlsIGluZm9ybWF0aW9uIGludG8gYFRyZWVCdWZmZXJgIGxlYWZcbi8vLyBub2RlcywgdGhlIHJlcHJlc2VudGF0aW9uIGlzIG1hZGUgYSBsb3QgbW9yZSBtZW1vcnktZWZmaWNpZW50LlxuLy8vXG4vLy8gSG93ZXZlciwgd2hlbiB5b3Ugd2FudCB0byBhY3R1YWxseSB3b3JrIHdpdGggdHJlZSBub2RlcywgdGhpc1xuLy8vIHJlcHJlc2VudGF0aW9uIGlzIHZlcnkgYXdrd2FyZCwgc28gbW9zdCBjbGllbnQgY29kZSB3aWxsIHdhbnQgdG9cbi8vLyB1c2UgdGhlIFtgVHJlZUN1cnNvcmBdKCNjb21tb24uVHJlZUN1cnNvcikgb3Jcbi8vLyBbYFN5bnRheE5vZGVgXSgjY29tbW9uLlN5bnRheE5vZGUpIGludGVyZmFjZSBpbnN0ZWFkLCB3aGljaCBwcm92aWRlc1xuLy8vIGEgdmlldyBvbiBzb21lIHBhcnQgb2YgdGhpcyBkYXRhIHN0cnVjdHVyZSwgYW5kIGNhbiBiZSB1c2VkIHRvXG4vLy8gbW92ZSBhcm91bmQgdG8gYWRqYWNlbnQgbm9kZXMuXG5jbGFzcyBUcmVlIHtcbiAgICAvLy8gQ29uc3RydWN0IGEgbmV3IHRyZWUuIFNlZSBhbHNvIFtgVHJlZS5idWlsZGBdKCNjb21tb24uVHJlZV5idWlsZCkuXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIFRoZSB0eXBlIG9mIHRoZSB0b3Agbm9kZS5cbiAgICB0eXBlLCBcbiAgICAvLy8gVGhpcyBub2RlJ3MgY2hpbGQgbm9kZXMuXG4gICAgY2hpbGRyZW4sIFxuICAgIC8vLyBUaGUgcG9zaXRpb25zIChvZmZzZXRzIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGlzIHRyZWUpIG9mXG4gICAgLy8vIHRoZSBjaGlsZHJlbi5cbiAgICBwb3NpdGlvbnMsIFxuICAgIC8vLyBUaGUgdG90YWwgbGVuZ3RoIG9mIHRoaXMgdHJlZVxuICAgIGxlbmd0aCwgXG4gICAgLy8vIFBlci1ub2RlIFtub2RlIHByb3BzXSgjY29tbW9uLk5vZGVQcm9wKSB0byBhc3NvY2lhdGUgd2l0aCB0aGlzIG5vZGUuXG4gICAgcHJvcHMpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLnBvc2l0aW9ucyA9IHBvc2l0aW9ucztcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIC8vLyBAaW50ZXJuYWxcbiAgICAgICAgdGhpcy5wcm9wcyA9IG51bGw7XG4gICAgICAgIGlmIChwcm9wcyAmJiBwcm9wcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgZm9yIChsZXQgW3Byb3AsIHZhbHVlXSBvZiBwcm9wcylcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzW3R5cGVvZiBwcm9wID09IFwibnVtYmVyXCIgPyBwcm9wIDogcHJvcC5pZF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBtb3VudGVkID0gdGhpcy5wcm9wKE5vZGVQcm9wLm1vdW50ZWQpO1xuICAgICAgICBpZiAobW91bnRlZCAmJiAhbW91bnRlZC5vdmVybGF5KVxuICAgICAgICAgICAgcmV0dXJuIG1vdW50ZWQudHJlZS50b1N0cmluZygpO1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBjaCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBsZXQgc3RyID0gY2gudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChzdHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuICs9IFwiLFwiO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuICs9IHN0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIXRoaXMudHlwZS5uYW1lID8gY2hpbGRyZW4gOlxuICAgICAgICAgICAgKC9cXFcvLnRlc3QodGhpcy50eXBlLm5hbWUpICYmICF0aGlzLnR5cGUuaXNFcnJvciA/IEpTT04uc3RyaW5naWZ5KHRoaXMudHlwZS5uYW1lKSA6IHRoaXMudHlwZS5uYW1lKSArXG4gICAgICAgICAgICAgICAgKGNoaWxkcmVuLmxlbmd0aCA/IFwiKFwiICsgY2hpbGRyZW4gKyBcIilcIiA6IFwiXCIpO1xuICAgIH1cbiAgICAvLy8gR2V0IGEgW3RyZWUgY3Vyc29yXSgjY29tbW9uLlRyZWVDdXJzb3IpIHJvb3RlZCBhdCB0aGlzIHRyZWUuIFdoZW5cbiAgICAvLy8gYHBvc2AgaXMgZ2l2ZW4sIHRoZSBjdXJzb3IgaXMgW21vdmVkXSgjY29tbW9uLlRyZWVDdXJzb3IubW92ZVRvKVxuICAgIC8vLyB0byB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIHNpZGUuXG4gICAgY3Vyc29yKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgbGV0IHNjb3BlID0gKHBvcyAhPSBudWxsICYmIENhY2hlZE5vZGUuZ2V0KHRoaXMpKSB8fCB0aGlzLnRvcE5vZGU7XG4gICAgICAgIGxldCBjdXJzb3IgPSBuZXcgVHJlZUN1cnNvcihzY29wZSk7XG4gICAgICAgIGlmIChwb3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgY3Vyc29yLm1vdmVUbyhwb3MsIHNpZGUpO1xuICAgICAgICAgICAgQ2FjaGVkTm9kZS5zZXQodGhpcywgY3Vyc29yLl90cmVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3Vyc29yO1xuICAgIH1cbiAgICAvLy8gR2V0IGEgW3RyZWUgY3Vyc29yXSgjY29tbW9uLlRyZWVDdXJzb3IpIHRoYXQsIHVubGlrZSByZWd1bGFyXG4gICAgLy8vIGN1cnNvcnMsIGRvZXNuJ3Qgc2tpcCB0aHJvdWdoXG4gICAgLy8vIFthbm9ueW1vdXNdKCNjb21tb24uTm9kZVR5cGUuaXNBbm9ueW1vdXMpIG5vZGVzIGFuZCBkb2Vzbid0XG4gICAgLy8vIGF1dG9tYXRpY2FsbHkgZW50ZXIgbW91bnRlZCBub2Rlcy5cbiAgICBmdWxsQ3Vyc29yKCkge1xuICAgICAgICByZXR1cm4gbmV3IFRyZWVDdXJzb3IodGhpcy50b3BOb2RlLCAxIC8qIEZ1bGwgKi8pO1xuICAgIH1cbiAgICAvLy8gR2V0IGEgW3N5bnRheCBub2RlXSgjY29tbW9uLlN5bnRheE5vZGUpIG9iamVjdCBmb3IgdGhlIHRvcCBvZiB0aGVcbiAgICAvLy8gdHJlZS5cbiAgICBnZXQgdG9wTm9kZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlTm9kZSh0aGlzLCAwLCAwLCBudWxsKTtcbiAgICB9XG4gICAgLy8vIEdldCB0aGUgW3N5bnRheCBub2RlXSgjY29tbW9uLlN5bnRheE5vZGUpIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAvLy8gSWYgYHNpZGVgIGlzIC0xLCB0aGlzIHdpbGwgbW92ZSBpbnRvIG5vZGVzIHRoYXQgZW5kIGF0IHRoZVxuICAgIC8vLyBwb3NpdGlvbi4gSWYgMSwgaXQnbGwgbW92ZSBpbnRvIG5vZGVzIHRoYXQgc3RhcnQgYXQgdGhlXG4gICAgLy8vIHBvc2l0aW9uLiBXaXRoIDAsIGl0J2xsIG9ubHkgZW50ZXIgbm9kZXMgdGhhdCBjb3ZlciB0aGUgcG9zaXRpb25cbiAgICAvLy8gZnJvbSBib3RoIHNpZGVzLlxuICAgIHJlc29sdmUocG9zLCBzaWRlID0gMCkge1xuICAgICAgICBsZXQgbm9kZSA9IHJlc29sdmVOb2RlKENhY2hlZE5vZGUuZ2V0KHRoaXMpIHx8IHRoaXMudG9wTm9kZSwgcG9zLCBzaWRlLCBmYWxzZSk7XG4gICAgICAgIENhY2hlZE5vZGUuc2V0KHRoaXMsIG5vZGUpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgLy8vIExpa2UgW2ByZXNvbHZlYF0oI2NvbW1vbi5UcmVlLnJlc29sdmUpLCBidXQgd2lsbCBlbnRlclxuICAgIC8vLyBbb3ZlcmxhaWRdKCNjb21tb24uTW91bnRlZFRyZWUub3ZlcmxheSkgbm9kZXMsIHByb2R1Y2luZyBhIHN5bnRheCBub2RlXG4gICAgLy8vIHBvaW50aW5nIGludG8gdGhlIGlubmVybW9zdCBvdmVybGFpZCB0cmVlIGF0IHRoZSBnaXZlbiBwb3NpdGlvblxuICAgIC8vLyAod2l0aCBwYXJlbnQgbGlua3MgZ29pbmcgdGhyb3VnaCBhbGwgcGFyZW50IHN0cnVjdHVyZSwgaW5jbHVkaW5nXG4gICAgLy8vIHRoZSBob3N0IHRyZWVzKS5cbiAgICByZXNvbHZlSW5uZXIocG9zLCBzaWRlID0gMCkge1xuICAgICAgICBsZXQgbm9kZSA9IHJlc29sdmVOb2RlKENhY2hlZElubmVyTm9kZS5nZXQodGhpcykgfHwgdGhpcy50b3BOb2RlLCBwb3MsIHNpZGUsIHRydWUpO1xuICAgICAgICBDYWNoZWRJbm5lck5vZGUuc2V0KHRoaXMsIG5vZGUpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgLy8vIEl0ZXJhdGUgb3ZlciB0aGUgdHJlZSBhbmQgaXRzIGNoaWxkcmVuLCBjYWxsaW5nIGBlbnRlcmAgZm9yIGFueVxuICAgIC8vLyBub2RlIHRoYXQgdG91Y2hlcyB0aGUgYGZyb21gL2B0b2AgcmVnaW9uIChpZiBnaXZlbikgYmVmb3JlXG4gICAgLy8vIHJ1bm5pbmcgb3ZlciBzdWNoIGEgbm9kZSdzIGNoaWxkcmVuLCBhbmQgYGxlYXZlYCAoaWYgZ2l2ZW4pIHdoZW5cbiAgICAvLy8gbGVhdmluZyB0aGUgbm9kZS4gV2hlbiBgZW50ZXJgIHJldHVybnMgYGZhbHNlYCwgdGhhdCBub2RlIHdpbGxcbiAgICAvLy8gbm90IGhhdmUgaXRzIGNoaWxkcmVuIGl0ZXJhdGVkIG92ZXIgKG9yIGBsZWF2ZWAgY2FsbGVkKS5cbiAgICBpdGVyYXRlKHNwZWMpIHtcbiAgICAgICAgbGV0IHsgZW50ZXIsIGxlYXZlLCBmcm9tID0gMCwgdG8gPSB0aGlzLmxlbmd0aCB9ID0gc3BlYztcbiAgICAgICAgZm9yIChsZXQgYyA9IHRoaXMuY3Vyc29yKCksIGdldCA9ICgpID0+IGMubm9kZTs7KSB7XG4gICAgICAgICAgICBsZXQgbXVzdExlYXZlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoYy5mcm9tIDw9IHRvICYmIGMudG8gPj0gZnJvbSAmJiAoYy50eXBlLmlzQW5vbnltb3VzIHx8IGVudGVyKGMudHlwZSwgYy5mcm9tLCBjLnRvLCBnZXQpICE9PSBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoYy5maXJzdENoaWxkKCkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmICghYy50eXBlLmlzQW5vbnltb3VzKVxuICAgICAgICAgICAgICAgICAgICBtdXN0TGVhdmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmIChtdXN0TGVhdmUgJiYgbGVhdmUpXG4gICAgICAgICAgICAgICAgICAgIGxlYXZlKGMudHlwZSwgYy5mcm9tLCBjLnRvLCBnZXQpO1xuICAgICAgICAgICAgICAgIG11c3RMZWF2ZSA9IGMudHlwZS5pc0Fub255bW91cztcbiAgICAgICAgICAgICAgICBpZiAoYy5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoIWMucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBtdXN0TGVhdmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vLyBHZXQgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBbbm9kZSBwcm9wXSgjY29tbW9uLk5vZGVQcm9wKSBmb3IgdGhpc1xuICAgIC8vLyBub2RlLiBXb3JrcyB3aXRoIGJvdGggcGVyLW5vZGUgYW5kIHBlci10eXBlIHByb3BzLlxuICAgIHByb3AocHJvcCkge1xuICAgICAgICByZXR1cm4gIXByb3AucGVyTm9kZSA/IHRoaXMudHlwZS5wcm9wKHByb3ApIDogdGhpcy5wcm9wcyA/IHRoaXMucHJvcHNbcHJvcC5pZF0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vLyBSZXR1cm5zIHRoZSBub2RlJ3MgW3Blci1ub2RlIHByb3BzXSgjY29tbW9uLk5vZGVQcm9wLnBlck5vZGUpIGluIGFcbiAgICAvLy8gZm9ybWF0IHRoYXQgY2FuIGJlIHBhc3NlZCB0byB0aGUgW2BUcmVlYF0oI2NvbW1vbi5UcmVlKVxuICAgIC8vLyBjb25zdHJ1Y3Rvci5cbiAgICBnZXQgcHJvcFZhbHVlcygpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAodGhpcy5wcm9wcylcbiAgICAgICAgICAgIGZvciAobGV0IGlkIGluIHRoaXMucHJvcHMpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goWytpZCwgdGhpcy5wcm9wc1tpZF1dKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8vIEJhbGFuY2UgdGhlIGRpcmVjdCBjaGlsZHJlbiBvZiB0aGlzIHRyZWUsIHByb2R1Y2luZyBhIGNvcHkgb2ZcbiAgICAvLy8gd2hpY2ggbWF5IGhhdmUgY2hpbGRyZW4gZ3JvdXBlZCBpbnRvIHN1YnRyZWVzIHdpdGggdHlwZVxuICAgIC8vLyBbYE5vZGVUeXBlLm5vbmVgXSgjY29tbW9uLk5vZGVUeXBlXm5vbmUpLlxuICAgIGJhbGFuY2UoY29uZmlnID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4ubGVuZ3RoIDw9IDggLyogQnJhbmNoRmFjdG9yICovID8gdGhpcyA6XG4gICAgICAgICAgICBiYWxhbmNlUmFuZ2UoTm9kZVR5cGUubm9uZSwgdGhpcy5jaGlsZHJlbiwgdGhpcy5wb3NpdGlvbnMsIDAsIHRoaXMuY2hpbGRyZW4ubGVuZ3RoLCAwLCB0aGlzLmxlbmd0aCwgKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCkgPT4gbmV3IFRyZWUodGhpcy50eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgsIHRoaXMucHJvcFZhbHVlcyksIGNvbmZpZy5tYWtlVHJlZSB8fCAoKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCkgPT4gbmV3IFRyZWUoTm9kZVR5cGUubm9uZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKSkpO1xuICAgIH1cbiAgICAvLy8gQnVpbGQgYSB0cmVlIGZyb20gYSBwb3N0Zml4LW9yZGVyZWQgYnVmZmVyIG9mIG5vZGUgaW5mb3JtYXRpb24sXG4gICAgLy8vIG9yIGEgY3Vyc29yIG92ZXIgc3VjaCBhIGJ1ZmZlci5cbiAgICBzdGF0aWMgYnVpbGQoZGF0YSkgeyByZXR1cm4gYnVpbGRUcmVlKGRhdGEpOyB9XG59XG4vLy8gVGhlIGVtcHR5IHRyZWVcblRyZWUuZW1wdHkgPSBuZXcgVHJlZShOb2RlVHlwZS5ub25lLCBbXSwgW10sIDApO1xuY2xhc3MgRmxhdEJ1ZmZlckN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoYnVmZmVyLCBpbmRleCkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIH1cbiAgICBnZXQgaWQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gNF07IH1cbiAgICBnZXQgc3RhcnQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gM107IH1cbiAgICBnZXQgZW5kKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDJdOyB9XG4gICAgZ2V0IHNpemUoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMV07IH1cbiAgICBnZXQgcG9zKCkgeyByZXR1cm4gdGhpcy5pbmRleDsgfVxuICAgIG5leHQoKSB7IHRoaXMuaW5kZXggLT0gNDsgfVxuICAgIGZvcmsoKSB7IHJldHVybiBuZXcgRmxhdEJ1ZmZlckN1cnNvcih0aGlzLmJ1ZmZlciwgdGhpcy5pbmRleCk7IH1cbn1cbi8vLyBUcmVlIGJ1ZmZlcnMgY29udGFpbiAodHlwZSwgc3RhcnQsIGVuZCwgZW5kSW5kZXgpIHF1YWRzIGZvciBlYWNoXG4vLy8gbm9kZS4gSW4gc3VjaCBhIGJ1ZmZlciwgbm9kZXMgYXJlIHN0b3JlZCBpbiBwcmVmaXggb3JkZXIgKHBhcmVudHNcbi8vLyBiZWZvcmUgY2hpbGRyZW4sIHdpdGggdGhlIGVuZEluZGV4IG9mIHRoZSBwYXJlbnQgaW5kaWNhdGluZyB3aGljaFxuLy8vIGNoaWxkcmVuIGJlbG9uZyB0byBpdClcbmNsYXNzIFRyZWVCdWZmZXIge1xuICAgIC8vLyBDcmVhdGUgYSB0cmVlIGJ1ZmZlci5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIGJ1ZmZlcidzIGNvbnRlbnQuXG4gICAgYnVmZmVyLCBcbiAgICAvLy8gVGhlIHRvdGFsIGxlbmd0aCBvZiB0aGUgZ3JvdXAgb2Ygbm9kZXMgaW4gdGhlIGJ1ZmZlci5cbiAgICBsZW5ndGgsIFxuICAgIC8vLyBUaGUgbm9kZSBzZXQgdXNlZCBpbiB0aGlzIGJ1ZmZlci5cbiAgICBzZXQpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLnNldCA9IHNldDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGdldCB0eXBlKCkgeyByZXR1cm4gTm9kZVR5cGUubm9uZTsgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5idWZmZXIubGVuZ3RoOykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5jaGlsZFN0cmluZyhpbmRleCkpO1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmJ1ZmZlcltpbmRleCArIDNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIixcIik7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjaGlsZFN0cmluZyhpbmRleCkge1xuICAgICAgICBsZXQgaWQgPSB0aGlzLmJ1ZmZlcltpbmRleF0sIGVuZEluZGV4ID0gdGhpcy5idWZmZXJbaW5kZXggKyAzXTtcbiAgICAgICAgbGV0IHR5cGUgPSB0aGlzLnNldC50eXBlc1tpZF0sIHJlc3VsdCA9IHR5cGUubmFtZTtcbiAgICAgICAgaWYgKC9cXFcvLnRlc3QocmVzdWx0KSAmJiAhdHlwZS5pc0Vycm9yKVxuICAgICAgICAgICAgcmVzdWx0ID0gSlNPTi5zdHJpbmdpZnkocmVzdWx0KTtcbiAgICAgICAgaW5kZXggKz0gNDtcbiAgICAgICAgaWYgKGVuZEluZGV4ID09IGluZGV4KVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gW107XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGVuZEluZGV4KSB7XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRTdHJpbmcoaW5kZXgpKTtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5idWZmZXJbaW5kZXggKyAzXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0ICsgXCIoXCIgKyBjaGlsZHJlbi5qb2luKFwiLFwiKSArIFwiKVwiO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgZmluZENoaWxkKHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBkaXIsIHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMsIHBpY2sgPSAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgIT0gZW5kSW5kZXg7IGkgPSBidWZmZXJbaSArIDNdKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2tTaWRlKHNpZGUsIHBvcywgYnVmZmVyW2kgKyAxXSwgYnVmZmVyW2kgKyAyXSkpIHtcbiAgICAgICAgICAgICAgICBwaWNrID0gaTtcbiAgICAgICAgICAgICAgICBpZiAoZGlyID4gMClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBpY2s7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzbGljZShzdGFydEksIGVuZEksIGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBiID0gdGhpcy5idWZmZXI7XG4gICAgICAgIGxldCBjb3B5ID0gbmV3IFVpbnQxNkFycmF5KGVuZEkgLSBzdGFydEkpO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJLCBqID0gMDsgaSA8IGVuZEk7KSB7XG4gICAgICAgICAgICBjb3B5W2orK10gPSBiW2krK107XG4gICAgICAgICAgICBjb3B5W2orK10gPSBiW2krK10gLSBmcm9tO1xuICAgICAgICAgICAgY29weVtqKytdID0gYltpKytdIC0gZnJvbTtcbiAgICAgICAgICAgIGNvcHlbaisrXSA9IGJbaSsrXSAtIHN0YXJ0STtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRyZWVCdWZmZXIoY29weSwgdG8gLSBmcm9tLCB0aGlzLnNldCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tTaWRlKHNpZGUsIHBvcywgZnJvbSwgdG8pIHtcbiAgICBzd2l0Y2ggKHNpZGUpIHtcbiAgICAgICAgY2FzZSAtMiAvKiBCZWZvcmUgKi86IHJldHVybiBmcm9tIDwgcG9zO1xuICAgICAgICBjYXNlIC0xIC8qIEF0T3JCZWZvcmUgKi86IHJldHVybiB0byA+PSBwb3MgJiYgZnJvbSA8IHBvcztcbiAgICAgICAgY2FzZSAwIC8qIEFyb3VuZCAqLzogcmV0dXJuIGZyb20gPCBwb3MgJiYgdG8gPiBwb3M7XG4gICAgICAgIGNhc2UgMSAvKiBBdE9yQWZ0ZXIgKi86IHJldHVybiBmcm9tIDw9IHBvcyAmJiB0byA+IHBvcztcbiAgICAgICAgY2FzZSAyIC8qIEFmdGVyICovOiByZXR1cm4gdG8gPiBwb3M7XG4gICAgICAgIGNhc2UgNCAvKiBEb250Q2FyZSAqLzogcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZnVuY3Rpb24gZW50ZXJVbmZpbmlzaGVkTm9kZXNCZWZvcmUobm9kZSwgcG9zKSB7XG4gICAgbGV0IHNjYW4gPSBub2RlLmNoaWxkQmVmb3JlKHBvcyk7XG4gICAgd2hpbGUgKHNjYW4pIHtcbiAgICAgICAgbGV0IGxhc3QgPSBzY2FuLmxhc3RDaGlsZDtcbiAgICAgICAgaWYgKCFsYXN0IHx8IGxhc3QudG8gIT0gc2Nhbi50bylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAobGFzdC50eXBlLmlzRXJyb3IgJiYgbGFzdC5mcm9tID09IGxhc3QudG8pIHtcbiAgICAgICAgICAgIG5vZGUgPSBzY2FuO1xuICAgICAgICAgICAgc2NhbiA9IGxhc3QucHJldlNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzY2FuID0gbGFzdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVOb2RlKG5vZGUsIHBvcywgc2lkZSwgb3ZlcmxheXMpIHtcbiAgICB2YXIgX2E7XG4gICAgLy8gTW92ZSB1cCB0byBhIG5vZGUgdGhhdCBhY3R1YWxseSBob2xkcyB0aGUgcG9zaXRpb24sIGlmIHBvc3NpYmxlXG4gICAgd2hpbGUgKG5vZGUuZnJvbSA9PSBub2RlLnRvIHx8XG4gICAgICAgIChzaWRlIDwgMSA/IG5vZGUuZnJvbSA+PSBwb3MgOiBub2RlLmZyb20gPiBwb3MpIHx8XG4gICAgICAgIChzaWRlID4gLTEgPyBub2RlLnRvIDw9IHBvcyA6IG5vZGUudG8gPCBwb3MpKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSAhb3ZlcmxheXMgJiYgbm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlICYmIG5vZGUuaW5kZXggPCAwID8gbnVsbCA6IG5vZGUucGFyZW50O1xuICAgICAgICBpZiAoIXBhcmVudClcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBub2RlID0gcGFyZW50O1xuICAgIH1cbiAgICAvLyBNdXN0IGdvIHVwIG91dCBvZiBvdmVybGF5cyB3aGVuIHRob3NlIGRvIG5vdCBvdmVybGFwIHdpdGggcG9zXG4gICAgaWYgKG92ZXJsYXlzKVxuICAgICAgICBmb3IgKGxldCBzY2FuID0gbm9kZSwgcGFyZW50ID0gc2Nhbi5wYXJlbnQ7IHBhcmVudDsgc2NhbiA9IHBhcmVudCwgcGFyZW50ID0gc2Nhbi5wYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChzY2FuIGluc3RhbmNlb2YgVHJlZU5vZGUgJiYgc2Nhbi5pbmRleCA8IDAgJiYgKChfYSA9IHBhcmVudC5lbnRlcihwb3MsIHNpZGUsIHRydWUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZnJvbSkgIT0gc2Nhbi5mcm9tKVxuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGxldCBpbm5lciA9IG5vZGUuZW50ZXIocG9zLCBzaWRlLCBvdmVybGF5cyk7XG4gICAgICAgIGlmICghaW5uZXIpXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgbm9kZSA9IGlubmVyO1xuICAgIH1cbn1cbmNsYXNzIFRyZWVOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBfZnJvbSwgXG4gICAgLy8gSW5kZXggaW4gcGFyZW50IG5vZGUsIHNldCB0byAtMSBpZiB0aGUgbm9kZSBpcyBub3QgYSBkaXJlY3QgY2hpbGQgb2YgX3BhcmVudC5ub2RlIChvdmVybGF5KVxuICAgIGluZGV4LCBfcGFyZW50KSB7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMuX2Zyb20gPSBfZnJvbTtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBfcGFyZW50O1xuICAgIH1cbiAgICBnZXQgdHlwZSgpIHsgcmV0dXJuIHRoaXMubm9kZS50eXBlOyB9XG4gICAgZ2V0IG5hbWUoKSB7IHJldHVybiB0aGlzLm5vZGUudHlwZS5uYW1lOyB9XG4gICAgZ2V0IGZyb20oKSB7IHJldHVybiB0aGlzLl9mcm9tOyB9XG4gICAgZ2V0IHRvKCkgeyByZXR1cm4gdGhpcy5fZnJvbSArIHRoaXMubm9kZS5sZW5ndGg7IH1cbiAgICBuZXh0Q2hpbGQoaSwgZGlyLCBwb3MsIHNpZGUsIG1vZGUgPSAwKSB7XG4gICAgICAgIGZvciAobGV0IHBhcmVudCA9IHRoaXM7Oykge1xuICAgICAgICAgICAgZm9yIChsZXQgeyBjaGlsZHJlbiwgcG9zaXRpb25zIH0gPSBwYXJlbnQubm9kZSwgZSA9IGRpciA+IDAgPyBjaGlsZHJlbi5sZW5ndGggOiAtMTsgaSAhPSBlOyBpICs9IGRpcikge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gY2hpbGRyZW5baV0sIHN0YXJ0ID0gcG9zaXRpb25zW2ldICsgcGFyZW50Ll9mcm9tO1xuICAgICAgICAgICAgICAgIGlmICghY2hlY2tTaWRlKHNpZGUsIHBvcywgc3RhcnQsIHN0YXJ0ICsgbmV4dC5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCBpbnN0YW5jZW9mIFRyZWVCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGUgJiAyIC8qIE5vRW50ZXJCdWZmZXIgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gbmV4dC5maW5kQ2hpbGQoMCwgbmV4dC5idWZmZXIubGVuZ3RoLCBkaXIsIHBvcyAtIHN0YXJ0LCBzaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlck5vZGUobmV3IEJ1ZmZlckNvbnRleHQocGFyZW50LCBuZXh0LCBpLCBzdGFydCksIG51bGwsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKG1vZGUgJiAxIC8qIEZ1bGwgKi8pIHx8ICghbmV4dC50eXBlLmlzQW5vbnltb3VzIHx8IGhhc0NoaWxkKG5leHQpKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbW91bnRlZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobW9kZSAmIDEgLyogRnVsbCAqLykgJiYgbmV4dC5wcm9wcyAmJiAobW91bnRlZCA9IG5leHQucHJvcChOb2RlUHJvcC5tb3VudGVkKSkgJiYgIW1vdW50ZWQub3ZlcmxheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHJlZU5vZGUobW91bnRlZC50cmVlLCBzdGFydCwgaSwgcGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlubmVyID0gbmV3IFRyZWVOb2RlKG5leHQsIHN0YXJ0LCBpLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG1vZGUgJiAxIC8qIEZ1bGwgKi8pIHx8ICFpbm5lci50eXBlLmlzQW5vbnltb3VzID8gaW5uZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogaW5uZXIubmV4dENoaWxkKGRpciA8IDAgPyBuZXh0LmNoaWxkcmVuLmxlbmd0aCAtIDEgOiAwLCBkaXIsIHBvcywgc2lkZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChtb2RlICYgMSAvKiBGdWxsICovKSB8fCAhcGFyZW50LnR5cGUuaXNBbm9ueW1vdXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpZiAocGFyZW50LmluZGV4ID49IDApXG4gICAgICAgICAgICAgICAgaSA9IHBhcmVudC5pbmRleCArIGRpcjtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBpID0gZGlyIDwgMCA/IC0xIDogcGFyZW50Ll9wYXJlbnQubm9kZS5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQuX3BhcmVudDtcbiAgICAgICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBmaXJzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQoMCwgMSwgMCwgNCAvKiBEb250Q2FyZSAqLyk7IH1cbiAgICBnZXQgbGFzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQodGhpcy5ub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDEsIC0xLCAwLCA0IC8qIERvbnRDYXJlICovKTsgfVxuICAgIGNoaWxkQWZ0ZXIocG9zKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCgwLCAxLCBwb3MsIDIgLyogQWZ0ZXIgKi8pOyB9XG4gICAgY2hpbGRCZWZvcmUocG9zKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCh0aGlzLm5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMSwgLTEsIHBvcywgLTIgLyogQmVmb3JlICovKTsgfVxuICAgIGVudGVyKHBvcywgc2lkZSwgb3ZlcmxheXMgPSB0cnVlLCBidWZmZXJzID0gdHJ1ZSkge1xuICAgICAgICBsZXQgbW91bnRlZDtcbiAgICAgICAgaWYgKG92ZXJsYXlzICYmIChtb3VudGVkID0gdGhpcy5ub2RlLnByb3AoTm9kZVByb3AubW91bnRlZCkpICYmIG1vdW50ZWQub3ZlcmxheSkge1xuICAgICAgICAgICAgbGV0IHJQb3MgPSBwb3MgLSB0aGlzLmZyb207XG4gICAgICAgICAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2YgbW91bnRlZC5vdmVybGF5KSB7XG4gICAgICAgICAgICAgICAgaWYgKChzaWRlID4gMCA/IGZyb20gPD0gclBvcyA6IGZyb20gPCByUG9zKSAmJlxuICAgICAgICAgICAgICAgICAgICAoc2lkZSA8IDAgPyB0byA+PSByUG9zIDogdG8gPiByUG9zKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUcmVlTm9kZShtb3VudGVkLnRyZWUsIG1vdW50ZWQub3ZlcmxheVswXS5mcm9tICsgdGhpcy5mcm9tLCAtMSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dENoaWxkKDAsIDEsIHBvcywgc2lkZSwgYnVmZmVycyA/IDAgOiAyIC8qIE5vRW50ZXJCdWZmZXIgKi8pO1xuICAgIH1cbiAgICBuZXh0U2lnbmlmaWNhbnRQYXJlbnQoKSB7XG4gICAgICAgIGxldCB2YWwgPSB0aGlzO1xuICAgICAgICB3aGlsZSAodmFsLnR5cGUuaXNBbm9ueW1vdXMgJiYgdmFsLl9wYXJlbnQpXG4gICAgICAgICAgICB2YWwgPSB2YWwuX3BhcmVudDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5uZXh0U2lnbmlmaWNhbnRQYXJlbnQoKSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBuZXh0U2libGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCAmJiB0aGlzLmluZGV4ID49IDAgPyB0aGlzLl9wYXJlbnQubmV4dENoaWxkKHRoaXMuaW5kZXggKyAxLCAxLCAwLCA0IC8qIERvbnRDYXJlICovKSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBwcmV2U2libGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCAmJiB0aGlzLmluZGV4ID49IDAgPyB0aGlzLl9wYXJlbnQubmV4dENoaWxkKHRoaXMuaW5kZXggLSAxLCAtMSwgMCwgNCAvKiBEb250Q2FyZSAqLykgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgY3Vyc29yKCkgeyByZXR1cm4gbmV3IFRyZWVDdXJzb3IodGhpcyk7IH1cbiAgICBnZXQgdHJlZSgpIHsgcmV0dXJuIHRoaXMubm9kZTsgfVxuICAgIHRvVHJlZSgpIHsgcmV0dXJuIHRoaXMubm9kZTsgfVxuICAgIHJlc29sdmUocG9zLCBzaWRlID0gMCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZU5vZGUodGhpcywgcG9zLCBzaWRlLCBmYWxzZSk7XG4gICAgfVxuICAgIHJlc29sdmVJbm5lcihwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlTm9kZSh0aGlzLCBwb3MsIHNpZGUsIHRydWUpO1xuICAgIH1cbiAgICBlbnRlclVuZmluaXNoZWROb2Rlc0JlZm9yZShwb3MpIHsgcmV0dXJuIGVudGVyVW5maW5pc2hlZE5vZGVzQmVmb3JlKHRoaXMsIHBvcyk7IH1cbiAgICBnZXRDaGlsZCh0eXBlLCBiZWZvcmUgPSBudWxsLCBhZnRlciA9IG51bGwpIHtcbiAgICAgICAgbGV0IHIgPSBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICAgICAgcmV0dXJuIHIubGVuZ3RoID8gclswXSA6IG51bGw7XG4gICAgfVxuICAgIGdldENoaWxkcmVuKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZ2V0Q2hpbGRyZW4odGhpcywgdHlwZSwgYmVmb3JlLCBhZnRlcik7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIHRoaXMubm9kZS50b1N0cmluZygpOyB9XG59XG5mdW5jdGlvbiBnZXRDaGlsZHJlbihub2RlLCB0eXBlLCBiZWZvcmUsIGFmdGVyKSB7XG4gICAgbGV0IGN1ciA9IG5vZGUuY3Vyc29yLCByZXN1bHQgPSBbXTtcbiAgICBpZiAoIWN1ci5maXJzdENoaWxkKCkpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKGJlZm9yZSAhPSBudWxsKVxuICAgICAgICB3aGlsZSAoIWN1ci50eXBlLmlzKGJlZm9yZSkpXG4gICAgICAgICAgICBpZiAoIWN1ci5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAoYWZ0ZXIgIT0gbnVsbCAmJiBjdXIudHlwZS5pcyhhZnRlcikpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBpZiAoY3VyLnR5cGUuaXModHlwZSkpXG4gICAgICAgICAgICByZXN1bHQucHVzaChjdXIubm9kZSk7XG4gICAgICAgIGlmICghY3VyLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICByZXR1cm4gYWZ0ZXIgPT0gbnVsbCA/IHJlc3VsdCA6IFtdO1xuICAgIH1cbn1cbmNsYXNzIEJ1ZmZlckNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgYnVmZmVyLCBpbmRleCwgc3RhcnQpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICB9XG59XG5jbGFzcyBCdWZmZXJOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBfcGFyZW50LCBpbmRleCkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBfcGFyZW50O1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMudHlwZSA9IGNvbnRleHQuYnVmZmVyLnNldC50eXBlc1tjb250ZXh0LmJ1ZmZlci5idWZmZXJbaW5kZXhdXTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7IHJldHVybiB0aGlzLnR5cGUubmFtZTsgfVxuICAgIGdldCBmcm9tKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0LnN0YXJ0ICsgdGhpcy5jb250ZXh0LmJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDFdOyB9XG4gICAgZ2V0IHRvKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0LnN0YXJ0ICsgdGhpcy5jb250ZXh0LmJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDJdOyB9XG4gICAgY2hpbGQoZGlyLCBwb3MsIHNpZGUpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBpbmRleCA9IGJ1ZmZlci5maW5kQ2hpbGQodGhpcy5pbmRleCArIDQsIGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdLCBkaXIsIHBvcyAtIHRoaXMuY29udGV4dC5zdGFydCwgc2lkZSk7XG4gICAgICAgIHJldHVybiBpbmRleCA8IDAgPyBudWxsIDogbmV3IEJ1ZmZlck5vZGUodGhpcy5jb250ZXh0LCB0aGlzLCBpbmRleCk7XG4gICAgfVxuICAgIGdldCBmaXJzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5jaGlsZCgxLCAwLCA0IC8qIERvbnRDYXJlICovKTsgfVxuICAgIGdldCBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNoaWxkKC0xLCAwLCA0IC8qIERvbnRDYXJlICovKTsgfVxuICAgIGNoaWxkQWZ0ZXIocG9zKSB7IHJldHVybiB0aGlzLmNoaWxkKDEsIHBvcywgMiAvKiBBZnRlciAqLyk7IH1cbiAgICBjaGlsZEJlZm9yZShwb3MpIHsgcmV0dXJuIHRoaXMuY2hpbGQoLTEsIHBvcywgLTIgLyogQmVmb3JlICovKTsgfVxuICAgIGVudGVyKHBvcywgc2lkZSwgb3ZlcmxheXMsIGJ1ZmZlcnMgPSB0cnVlKSB7XG4gICAgICAgIGlmICghYnVmZmVycylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGluZGV4ID0gYnVmZmVyLmZpbmRDaGlsZCh0aGlzLmluZGV4ICsgNCwgYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM10sIHNpZGUgPiAwID8gMSA6IC0xLCBwb3MgLSB0aGlzLmNvbnRleHQuc3RhcnQsIHNpZGUpO1xuICAgICAgICByZXR1cm4gaW5kZXggPCAwID8gbnVsbCA6IG5ldyBCdWZmZXJOb2RlKHRoaXMuY29udGV4dCwgdGhpcywgaW5kZXgpO1xuICAgIH1cbiAgICBnZXQgcGFyZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50IHx8IHRoaXMuY29udGV4dC5wYXJlbnQubmV4dFNpZ25pZmljYW50UGFyZW50KCk7XG4gICAgfVxuICAgIGV4dGVybmFsU2libGluZyhkaXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/IG51bGwgOiB0aGlzLmNvbnRleHQucGFyZW50Lm5leHRDaGlsZCh0aGlzLmNvbnRleHQuaW5kZXggKyBkaXIsIGRpciwgMCwgNCAvKiBEb250Q2FyZSAqLyk7XG4gICAgfVxuICAgIGdldCBuZXh0U2libGluZygpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBhZnRlciA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICBpZiAoYWZ0ZXIgPCAodGhpcy5fcGFyZW50ID8gYnVmZmVyLmJ1ZmZlclt0aGlzLl9wYXJlbnQuaW5kZXggKyAzXSA6IGJ1ZmZlci5idWZmZXIubGVuZ3RoKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMuX3BhcmVudCwgYWZ0ZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5leHRlcm5hbFNpYmxpbmcoMSk7XG4gICAgfVxuICAgIGdldCBwcmV2U2libGluZygpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBwYXJlbnRTdGFydCA9IHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5pbmRleCArIDQgOiAwO1xuICAgICAgICBpZiAodGhpcy5pbmRleCA9PSBwYXJlbnRTdGFydClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4dGVybmFsU2libGluZygtMSk7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMuX3BhcmVudCwgYnVmZmVyLmZpbmRDaGlsZChwYXJlbnRTdGFydCwgdGhpcy5pbmRleCwgLTEsIDAsIDQgLyogRG9udENhcmUgKi8pKTtcbiAgICB9XG4gICAgZ2V0IGN1cnNvcigpIHsgcmV0dXJuIG5ldyBUcmVlQ3Vyc29yKHRoaXMpOyB9XG4gICAgZ2V0IHRyZWUoKSB7IHJldHVybiBudWxsOyB9XG4gICAgdG9UcmVlKCkge1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBbXSwgcG9zaXRpb25zID0gW107XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgc3RhcnRJID0gdGhpcy5pbmRleCArIDQsIGVuZEkgPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXTtcbiAgICAgICAgaWYgKGVuZEkgPiBzdGFydEkpIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgMV0sIHRvID0gYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgMl07XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGJ1ZmZlci5zbGljZShzdGFydEksIGVuZEksIGZyb20sIHRvKSk7XG4gICAgICAgICAgICBwb3NpdGlvbnMucHVzaCgwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRyZWUodGhpcy50eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCB0aGlzLnRvIC0gdGhpcy5mcm9tKTtcbiAgICB9XG4gICAgcmVzb2x2ZShwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlTm9kZSh0aGlzLCBwb3MsIHNpZGUsIGZhbHNlKTtcbiAgICB9XG4gICAgcmVzb2x2ZUlubmVyKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVOb2RlKHRoaXMsIHBvcywgc2lkZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGVudGVyVW5maW5pc2hlZE5vZGVzQmVmb3JlKHBvcykgeyByZXR1cm4gZW50ZXJVbmZpbmlzaGVkTm9kZXNCZWZvcmUodGhpcywgcG9zKTsgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5idWZmZXIuY2hpbGRTdHJpbmcodGhpcy5pbmRleCk7IH1cbiAgICBnZXRDaGlsZCh0eXBlLCBiZWZvcmUgPSBudWxsLCBhZnRlciA9IG51bGwpIHtcbiAgICAgICAgbGV0IHIgPSBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICAgICAgcmV0dXJuIHIubGVuZ3RoID8gclswXSA6IG51bGw7XG4gICAgfVxuICAgIGdldENoaWxkcmVuKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZ2V0Q2hpbGRyZW4odGhpcywgdHlwZSwgYmVmb3JlLCBhZnRlcik7XG4gICAgfVxufVxuLy8vIEEgdHJlZSBjdXJzb3Igb2JqZWN0IGZvY3VzZXMgb24gYSBnaXZlbiBub2RlIGluIGEgc3ludGF4IHRyZWUsIGFuZFxuLy8vIGFsbG93cyB5b3UgdG8gbW92ZSB0byBhZGphY2VudCBub2Rlcy5cbmNsYXNzIFRyZWVDdXJzb3Ige1xuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBcbiAgICAvLy8gQGludGVybmFsXG4gICAgbW9kZSA9IDApIHtcbiAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YWNrID0gW107XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLmJ1ZmZlck5vZGUgPSBudWxsO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLnlpZWxkTm9kZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RyZWUgPSBub2RlLmNvbnRleHQucGFyZW50O1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBub2RlLmNvbnRleHQ7XG4gICAgICAgICAgICBmb3IgKGxldCBuID0gbm9kZS5fcGFyZW50OyBuOyBuID0gbi5fcGFyZW50KVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sudW5zaGlmdChuLmluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICB0aGlzLnlpZWxkQnVmKG5vZGUuaW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vLyBTaG9ydGhhbmQgZm9yIGAudHlwZS5uYW1lYC5cbiAgICBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMudHlwZS5uYW1lOyB9XG4gICAgeWllbGROb2RlKG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLl90cmVlID0gbm9kZTtcbiAgICAgICAgdGhpcy50eXBlID0gbm9kZS50eXBlO1xuICAgICAgICB0aGlzLmZyb20gPSBub2RlLmZyb207XG4gICAgICAgIHRoaXMudG8gPSBub2RlLnRvO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgeWllbGRCdWYoaW5kZXgsIHR5cGUpIHtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICBsZXQgeyBzdGFydCwgYnVmZmVyIH0gPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZSB8fCBidWZmZXIuc2V0LnR5cGVzW2J1ZmZlci5idWZmZXJbaW5kZXhdXTtcbiAgICAgICAgdGhpcy5mcm9tID0gc3RhcnQgKyBidWZmZXIuYnVmZmVyW2luZGV4ICsgMV07XG4gICAgICAgIHRoaXMudG8gPSBzdGFydCArIGJ1ZmZlci5idWZmZXJbaW5kZXggKyAyXTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHlpZWxkKG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZE5vZGUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWZmZXIgPSBub2RlLmNvbnRleHQ7XG4gICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKG5vZGUuaW5kZXgsIG5vZGUudHlwZSk7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyID8gdGhpcy5idWZmZXIuYnVmZmVyLmNoaWxkU3RyaW5nKHRoaXMuaW5kZXgpIDogdGhpcy5fdHJlZS50b1N0cmluZygpO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgZW50ZXJDaGlsZChkaXIsIHBvcywgc2lkZSkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGQodGhpcy5fdHJlZS5uZXh0Q2hpbGQoZGlyIDwgMCA/IHRoaXMuX3RyZWUubm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxIDogMCwgZGlyLCBwb3MsIHNpZGUsIHRoaXMubW9kZSkpO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuYnVmZmVyO1xuICAgICAgICBsZXQgaW5kZXggPSBidWZmZXIuZmluZENoaWxkKHRoaXMuaW5kZXggKyA0LCBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXSwgZGlyLCBwb3MgLSB0aGlzLmJ1ZmZlci5zdGFydCwgc2lkZSk7XG4gICAgICAgIGlmIChpbmRleCA8IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLmluZGV4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYoaW5kZXgpO1xuICAgIH1cbiAgICAvLy8gTW92ZSB0aGUgY3Vyc29yIHRvIHRoaXMgbm9kZSdzIGZpcnN0IGNoaWxkLiBXaGVuIHRoaXMgcmV0dXJuc1xuICAgIC8vLyBmYWxzZSwgdGhlIG5vZGUgaGFzIG5vIGNoaWxkLCBhbmQgdGhlIGN1cnNvciBoYXMgbm90IGJlZW4gbW92ZWQuXG4gICAgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgxLCAwLCA0IC8qIERvbnRDYXJlICovKTsgfVxuICAgIC8vLyBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhpcyBub2RlJ3MgbGFzdCBjaGlsZC5cbiAgICBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmVudGVyQ2hpbGQoLTEsIDAsIDQgLyogRG9udENhcmUgKi8pOyB9XG4gICAgLy8vIE1vdmUgdGhlIGN1cnNvciB0byB0aGUgZmlyc3QgY2hpbGQgdGhhdCBlbmRzIGFmdGVyIGBwb3NgLlxuICAgIGNoaWxkQWZ0ZXIocG9zKSB7IHJldHVybiB0aGlzLmVudGVyQ2hpbGQoMSwgcG9zLCAyIC8qIEFmdGVyICovKTsgfVxuICAgIC8vLyBNb3ZlIHRvIHRoZSBsYXN0IGNoaWxkIHRoYXQgc3RhcnRzIGJlZm9yZSBgcG9zYC5cbiAgICBjaGlsZEJlZm9yZShwb3MpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgtMSwgcG9zLCAtMiAvKiBCZWZvcmUgKi8pOyB9XG4gICAgLy8vIE1vdmUgdGhlIGN1cnNvciB0byB0aGUgY2hpbGQgYXJvdW5kIGBwb3NgLiBJZiBzaWRlIGlzIC0xIHRoZVxuICAgIC8vLyBjaGlsZCBtYXkgZW5kIGF0IHRoYXQgcG9zaXRpb24sIHdoZW4gMSBpdCBtYXkgc3RhcnQgdGhlcmUuIFRoaXNcbiAgICAvLy8gd2lsbCBhbHNvIGVudGVyIFtvdmVybGFpZF0oI2NvbW1vbi5Nb3VudGVkVHJlZS5vdmVybGF5KVxuICAgIC8vLyBbbW91bnRlZF0oI2NvbW1vbi5Ob2RlUHJvcF5tb3VudGVkKSB0cmVlcyB1bmxlc3MgYG92ZXJsYXlzYCBpc1xuICAgIC8vLyBzZXQgdG8gZmFsc2UuXG4gICAgZW50ZXIocG9zLCBzaWRlLCBvdmVybGF5cyA9IHRydWUsIGJ1ZmZlcnMgPSB0cnVlKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZCh0aGlzLl90cmVlLmVudGVyKHBvcywgc2lkZSwgb3ZlcmxheXMgJiYgISh0aGlzLm1vZGUgJiAxIC8qIEZ1bGwgKi8pLCBidWZmZXJzKSk7XG4gICAgICAgIHJldHVybiBidWZmZXJzID8gdGhpcy5lbnRlckNoaWxkKDEsIHBvcywgc2lkZSkgOiBmYWxzZTtcbiAgICB9XG4gICAgLy8vIE1vdmUgdG8gdGhlIG5vZGUncyBwYXJlbnQgbm9kZSwgaWYgdGhpcyBpc24ndCB0aGUgdG9wIG5vZGUuXG4gICAgcGFyZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGROb2RlKCh0aGlzLm1vZGUgJiAxIC8qIEZ1bGwgKi8pID8gdGhpcy5fdHJlZS5fcGFyZW50IDogdGhpcy5fdHJlZS5wYXJlbnQpO1xuICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZEJ1Zih0aGlzLnN0YWNrLnBvcCgpKTtcbiAgICAgICAgbGV0IHBhcmVudCA9ICh0aGlzLm1vZGUgJiAxIC8qIEZ1bGwgKi8pID8gdGhpcy5idWZmZXIucGFyZW50IDogdGhpcy5idWZmZXIucGFyZW50Lm5leHRTaWduaWZpY2FudFBhcmVudCgpO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLnlpZWxkTm9kZShwYXJlbnQpO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgc2libGluZyhkaXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5fdHJlZS5fcGFyZW50ID8gZmFsc2VcbiAgICAgICAgICAgICAgICA6IHRoaXMueWllbGQodGhpcy5fdHJlZS5pbmRleCA8IDAgPyBudWxsXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5fdHJlZS5fcGFyZW50Lm5leHRDaGlsZCh0aGlzLl90cmVlLmluZGV4ICsgZGlyLCBkaXIsIDAsIDQgLyogRG9udENhcmUgKi8sIHRoaXMubW9kZSkpO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuYnVmZmVyLCBkID0gdGhpcy5zdGFjay5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoZGlyIDwgMCkge1xuICAgICAgICAgICAgbGV0IHBhcmVudFN0YXJ0ID0gZCA8IDAgPyAwIDogdGhpcy5zdGFja1tkXSArIDQ7XG4gICAgICAgICAgICBpZiAodGhpcy5pbmRleCAhPSBwYXJlbnRTdGFydClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZEJ1ZihidWZmZXIuZmluZENoaWxkKHBhcmVudFN0YXJ0LCB0aGlzLmluZGV4LCAtMSwgMCwgNCAvKiBEb250Q2FyZSAqLykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGFmdGVyID0gYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM107XG4gICAgICAgICAgICBpZiAoYWZ0ZXIgPCAoZCA8IDAgPyBidWZmZXIuYnVmZmVyLmxlbmd0aCA6IGJ1ZmZlci5idWZmZXJbdGhpcy5zdGFja1tkXSArIDNdKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZEJ1ZihhZnRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGQgPCAwID8gdGhpcy55aWVsZCh0aGlzLmJ1ZmZlci5wYXJlbnQubmV4dENoaWxkKHRoaXMuYnVmZmVyLmluZGV4ICsgZGlyLCBkaXIsIDAsIDQgLyogRG9udENhcmUgKi8sIHRoaXMubW9kZSkpIDogZmFsc2U7XG4gICAgfVxuICAgIC8vLyBNb3ZlIHRvIHRoaXMgbm9kZSdzIG5leHQgc2libGluZywgaWYgYW55LlxuICAgIG5leHRTaWJsaW5nKCkgeyByZXR1cm4gdGhpcy5zaWJsaW5nKDEpOyB9XG4gICAgLy8vIE1vdmUgdG8gdGhpcyBub2RlJ3MgcHJldmlvdXMgc2libGluZywgaWYgYW55LlxuICAgIHByZXZTaWJsaW5nKCkgeyByZXR1cm4gdGhpcy5zaWJsaW5nKC0xKTsgfVxuICAgIGF0TGFzdE5vZGUoZGlyKSB7XG4gICAgICAgIGxldCBpbmRleCwgcGFyZW50LCB7IGJ1ZmZlciB9ID0gdGhpcztcbiAgICAgICAgaWYgKGJ1ZmZlcikge1xuICAgICAgICAgICAgaWYgKGRpciA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmRleCA8IGJ1ZmZlci5idWZmZXIuYnVmZmVyLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmluZGV4OyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXIuYnVmZmVyLmJ1ZmZlcltpICsgM10gPCB0aGlzLmluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKHsgaW5kZXgsIHBhcmVudCB9ID0gYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICh7IGluZGV4LCBfcGFyZW50OiBwYXJlbnQgfSA9IHRoaXMuX3RyZWUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOyBwYXJlbnQ7IHsgaW5kZXgsIF9wYXJlbnQ6IHBhcmVudCB9ID0gcGFyZW50KSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSlcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gaW5kZXggKyBkaXIsIGUgPSBkaXIgPCAwID8gLTEgOiBwYXJlbnQubm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgIT0gZTsgaSArPSBkaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gcGFyZW50Lm5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgICAgIGlmICgodGhpcy5tb2RlICYgMSAvKiBGdWxsICovKSB8fCBjaGlsZCBpbnN0YW5jZW9mIFRyZWVCdWZmZXIgfHwgIWNoaWxkLnR5cGUuaXNBbm9ueW1vdXMgfHwgaGFzQ2hpbGQoY2hpbGQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbW92ZShkaXIsIGVudGVyKSB7XG4gICAgICAgIGlmIChlbnRlciAmJiB0aGlzLmVudGVyQ2hpbGQoZGlyLCAwLCA0IC8qIERvbnRDYXJlICovKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zaWJsaW5nKGRpcikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5hdExhc3ROb2RlKGRpcikgfHwgIXRoaXMucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vLyBNb3ZlIHRvIHRoZSBuZXh0IG5vZGUgaW4gYVxuICAgIC8vLyBbcHJlLW9yZGVyXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UcmVlX3RyYXZlcnNhbCNQcmUtb3JkZXJfKE5MUikpXG4gICAgLy8vIHRyYXZlcnNhbCwgZ29pbmcgZnJvbSBhIG5vZGUgdG8gaXRzIGZpcnN0IGNoaWxkIG9yLCBpZiB0aGVcbiAgICAvLy8gY3VycmVudCBub2RlIGlzIGVtcHR5IG9yIGBlbnRlcmAgaXMgZmFsc2UsIGl0cyBuZXh0IHNpYmxpbmcgb3JcbiAgICAvLy8gdGhlIG5leHQgc2libGluZyBvZiB0aGUgZmlyc3QgcGFyZW50IG5vZGUgdGhhdCBoYXMgb25lLlxuICAgIG5leHQoZW50ZXIgPSB0cnVlKSB7IHJldHVybiB0aGlzLm1vdmUoMSwgZW50ZXIpOyB9XG4gICAgLy8vIE1vdmUgdG8gdGhlIG5leHQgbm9kZSBpbiBhIGxhc3QtdG8tZmlyc3QgcHJlLW9yZGVyIHRyYXZlcmFsLiBBXG4gICAgLy8vIG5vZGUgaXMgZm9sbG93ZWQgYnkgaXRzIGxhc3QgY2hpbGQgb3IsIGlmIGl0IGhhcyBub25lLCBpdHNcbiAgICAvLy8gcHJldmlvdXMgc2libGluZyBvciB0aGUgcHJldmlvdXMgc2libGluZyBvZiB0aGUgZmlyc3QgcGFyZW50XG4gICAgLy8vIG5vZGUgdGhhdCBoYXMgb25lLlxuICAgIHByZXYoZW50ZXIgPSB0cnVlKSB7IHJldHVybiB0aGlzLm1vdmUoLTEsIGVudGVyKTsgfVxuICAgIC8vLyBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGlubmVybW9zdCBub2RlIHRoYXQgY292ZXJzIGBwb3NgLiBJZlxuICAgIC8vLyBgc2lkZWAgaXMgLTEsIGl0IHdpbGwgZW50ZXIgbm9kZXMgdGhhdCBlbmQgYXQgYHBvc2AuIElmIGl0IGlzIDEsXG4gICAgLy8vIGl0IHdpbGwgZW50ZXIgbm9kZXMgdGhhdCBzdGFydCBhdCBgcG9zYC5cbiAgICBtb3ZlVG8ocG9zLCBzaWRlID0gMCkge1xuICAgICAgICAvLyBNb3ZlIHVwIHRvIGEgbm9kZSB0aGF0IGFjdHVhbGx5IGhvbGRzIHRoZSBwb3NpdGlvbiwgaWYgcG9zc2libGVcbiAgICAgICAgd2hpbGUgKHRoaXMuZnJvbSA9PSB0aGlzLnRvIHx8XG4gICAgICAgICAgICAoc2lkZSA8IDEgPyB0aGlzLmZyb20gPj0gcG9zIDogdGhpcy5mcm9tID4gcG9zKSB8fFxuICAgICAgICAgICAgKHNpZGUgPiAtMSA/IHRoaXMudG8gPD0gcG9zIDogdGhpcy50byA8IHBvcykpXG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFRoZW4gc2NhbiBkb3duIGludG8gY2hpbGQgbm9kZXMgYXMgZmFyIGFzIHBvc3NpYmxlXG4gICAgICAgIHdoaWxlICh0aGlzLmVudGVyQ2hpbGQoMSwgcG9zLCBzaWRlKSkgeyB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLy8gR2V0IGEgW3N5bnRheCBub2RlXSgjY29tbW9uLlN5bnRheE5vZGUpIGF0IHRoZSBjdXJzb3IncyBjdXJyZW50XG4gICAgLy8vIHBvc2l0aW9uLlxuICAgIGdldCBub2RlKCkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyZWU7XG4gICAgICAgIGxldCBjYWNoZSA9IHRoaXMuYnVmZmVyTm9kZSwgcmVzdWx0ID0gbnVsbCwgZGVwdGggPSAwO1xuICAgICAgICBpZiAoY2FjaGUgJiYgY2FjaGUuY29udGV4dCA9PSB0aGlzLmJ1ZmZlcikge1xuICAgICAgICAgICAgc2NhbjogZm9yIChsZXQgaW5kZXggPSB0aGlzLmluZGV4LCBkID0gdGhpcy5zdGFjay5sZW5ndGg7IGQgPj0gMDspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjID0gY2FjaGU7IGM7IGMgPSBjLl9wYXJlbnQpXG4gICAgICAgICAgICAgICAgICAgIGlmIChjLmluZGV4ID09IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT0gdGhpcy5pbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGM7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXB0aCA9IGQgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgc2NhbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5zdGFja1stLWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSBkZXB0aDsgaSA8IHRoaXMuc3RhY2subGVuZ3RoOyBpKyspXG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgQnVmZmVyTm9kZSh0aGlzLmJ1ZmZlciwgcmVzdWx0LCB0aGlzLnN0YWNrW2ldKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyTm9kZSA9IG5ldyBCdWZmZXJOb2RlKHRoaXMuYnVmZmVyLCByZXN1bHQsIHRoaXMuaW5kZXgpO1xuICAgIH1cbiAgICAvLy8gR2V0IHRoZSBbdHJlZV0oI2NvbW1vbi5UcmVlKSB0aGF0IHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgbm9kZSwgaWZcbiAgICAvLy8gYW55LiBXaWxsIHJldHVybiBudWxsIHdoZW4gdGhlIG5vZGUgaXMgaW4gYSBbdHJlZVxuICAgIC8vLyBidWZmZXJdKCNjb21tb24uVHJlZUJ1ZmZlcikuXG4gICAgZ2V0IHRyZWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlciA/IG51bGwgOiB0aGlzLl90cmVlLm5vZGU7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFzQ2hpbGQodHJlZSkge1xuICAgIHJldHVybiB0cmVlLmNoaWxkcmVuLnNvbWUoY2ggPT4gY2ggaW5zdGFuY2VvZiBUcmVlQnVmZmVyIHx8ICFjaC50eXBlLmlzQW5vbnltb3VzIHx8IGhhc0NoaWxkKGNoKSk7XG59XG5mdW5jdGlvbiBidWlsZFRyZWUoZGF0YSkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgeyBidWZmZXIsIG5vZGVTZXQsIG1heEJ1ZmZlckxlbmd0aCA9IERlZmF1bHRCdWZmZXJMZW5ndGgsIHJldXNlZCA9IFtdLCBtaW5SZXBlYXRUeXBlID0gbm9kZVNldC50eXBlcy5sZW5ndGggfSA9IGRhdGE7XG4gICAgbGV0IGN1cnNvciA9IEFycmF5LmlzQXJyYXkoYnVmZmVyKSA/IG5ldyBGbGF0QnVmZmVyQ3Vyc29yKGJ1ZmZlciwgYnVmZmVyLmxlbmd0aCkgOiBidWZmZXI7XG4gICAgbGV0IHR5cGVzID0gbm9kZVNldC50eXBlcztcbiAgICBsZXQgY29udGV4dEhhc2ggPSAwLCBsb29rQWhlYWQgPSAwO1xuICAgIGZ1bmN0aW9uIHRha2VOb2RlKHBhcmVudFN0YXJ0LCBtaW5Qb3MsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGluUmVwZWF0KSB7XG4gICAgICAgIGxldCB7IGlkLCBzdGFydCwgZW5kLCBzaXplIH0gPSBjdXJzb3I7XG4gICAgICAgIGxldCBsb29rQWhlYWRBdFN0YXJ0ID0gbG9va0FoZWFkO1xuICAgICAgICB3aGlsZSAoc2l6ZSA8IDApIHtcbiAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoc2l6ZSA9PSAtMSAvKiBSZXVzZSAqLykge1xuICAgICAgICAgICAgICAgIGxldCBub2RlID0gcmV1c2VkW2lkXTtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKHN0YXJ0IC0gcGFyZW50U3RhcnQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNpemUgPT0gLTMgLyogQ29udGV4dENoYW5nZSAqLykgeyAvLyBDb250ZXh0IGNoYW5nZVxuICAgICAgICAgICAgICAgIGNvbnRleHRIYXNoID0gaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2l6ZSA9PSAtNCAvKiBMb29rQWhlYWQgKi8pIHtcbiAgICAgICAgICAgICAgICBsb29rQWhlYWQgPSBpZDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVW5yZWNvZ25pemVkIHJlY29yZCBzaXplOiAke3NpemV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHR5cGUgPSB0eXBlc1tpZF0sIG5vZGUsIGJ1ZmZlcjtcbiAgICAgICAgbGV0IHN0YXJ0UG9zID0gc3RhcnQgLSBwYXJlbnRTdGFydDtcbiAgICAgICAgaWYgKGVuZCAtIHN0YXJ0IDw9IG1heEJ1ZmZlckxlbmd0aCAmJiAoYnVmZmVyID0gZmluZEJ1ZmZlclNpemUoY3Vyc29yLnBvcyAtIG1pblBvcywgaW5SZXBlYXQpKSkge1xuICAgICAgICAgICAgLy8gU21hbGwgZW5vdWdoIGZvciBhIGJ1ZmZlciwgYW5kIG5vIHJldXNlZCBub2RlcyBpbnNpZGVcbiAgICAgICAgICAgIGxldCBkYXRhID0gbmV3IFVpbnQxNkFycmF5KGJ1ZmZlci5zaXplIC0gYnVmZmVyLnNraXApO1xuICAgICAgICAgICAgbGV0IGVuZFBvcyA9IGN1cnNvci5wb3MgLSBidWZmZXIuc2l6ZSwgaW5kZXggPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJzb3IucG9zID4gZW5kUG9zKVxuICAgICAgICAgICAgICAgIGluZGV4ID0gY29weVRvQnVmZmVyKGJ1ZmZlci5zdGFydCwgZGF0YSwgaW5kZXgpO1xuICAgICAgICAgICAgbm9kZSA9IG5ldyBUcmVlQnVmZmVyKGRhdGEsIGVuZCAtIGJ1ZmZlci5zdGFydCwgbm9kZVNldCk7XG4gICAgICAgICAgICBzdGFydFBvcyA9IGJ1ZmZlci5zdGFydCAtIHBhcmVudFN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBNYWtlIGl0IGEgbm9kZVxuICAgICAgICAgICAgbGV0IGVuZFBvcyA9IGN1cnNvci5wb3MgLSBzaXplO1xuICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgIGxldCBsb2NhbENoaWxkcmVuID0gW10sIGxvY2FsUG9zaXRpb25zID0gW107XG4gICAgICAgICAgICBsZXQgbG9jYWxJblJlcGVhdCA9IGlkID49IG1pblJlcGVhdFR5cGUgPyBpZCA6IC0xO1xuICAgICAgICAgICAgbGV0IGxhc3RHcm91cCA9IDAsIGxhc3RFbmQgPSBlbmQ7XG4gICAgICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IGVuZFBvcykge1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbEluUmVwZWF0ID49IDAgJiYgY3Vyc29yLmlkID09IGxvY2FsSW5SZXBlYXQgJiYgY3Vyc29yLnNpemUgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3Vyc29yLmVuZCA8PSBsYXN0RW5kIC0gbWF4QnVmZmVyTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWtlUmVwZWF0TGVhZihsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgc3RhcnQsIGxhc3RHcm91cCwgY3Vyc29yLmVuZCwgbGFzdEVuZCwgbG9jYWxJblJlcGVhdCwgbG9va0FoZWFkQXRTdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0R3JvdXAgPSBsb2NhbENoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RFbmQgPSBjdXJzb3IuZW5kO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YWtlTm9kZShzdGFydCwgZW5kUG9zLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgbG9jYWxJblJlcGVhdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxvY2FsSW5SZXBlYXQgPj0gMCAmJiBsYXN0R3JvdXAgPiAwICYmIGxhc3RHcm91cCA8IGxvY2FsQ2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIG1ha2VSZXBlYXRMZWFmKGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBzdGFydCwgbGFzdEdyb3VwLCBzdGFydCwgbGFzdEVuZCwgbG9jYWxJblJlcGVhdCwgbG9va0FoZWFkQXRTdGFydCk7XG4gICAgICAgICAgICBsb2NhbENoaWxkcmVuLnJldmVyc2UoKTtcbiAgICAgICAgICAgIGxvY2FsUG9zaXRpb25zLnJldmVyc2UoKTtcbiAgICAgICAgICAgIGlmIChsb2NhbEluUmVwZWF0ID4gLTEgJiYgbGFzdEdyb3VwID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBtYWtlID0gbWFrZUJhbGFuY2VkKHR5cGUpO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBiYWxhbmNlUmFuZ2UodHlwZSwgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIDAsIGxvY2FsQ2hpbGRyZW4ubGVuZ3RoLCAwLCBlbmQgLSBzdGFydCwgbWFrZSwgbWFrZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbWFrZVRyZWUodHlwZSwgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIGVuZCAtIHN0YXJ0LCBsb29rQWhlYWRBdFN0YXJ0IC0gZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaChzdGFydFBvcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VCYWxhbmNlZCh0eXBlKSB7XG4gICAgICAgIHJldHVybiAoY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKSA9PiB7XG4gICAgICAgICAgICBsZXQgbG9va0FoZWFkID0gMCwgbGFzdEkgPSBjaGlsZHJlbi5sZW5ndGggLSAxLCBsYXN0LCBsb29rQWhlYWRQcm9wO1xuICAgICAgICAgICAgaWYgKGxhc3RJID49IDAgJiYgKGxhc3QgPSBjaGlsZHJlbltsYXN0SV0pIGluc3RhbmNlb2YgVHJlZSkge1xuICAgICAgICAgICAgICAgIGlmICghbGFzdEkgJiYgbGFzdC50eXBlID09IHR5cGUgJiYgbGFzdC5sZW5ndGggPT0gbGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFzdDtcbiAgICAgICAgICAgICAgICBpZiAobG9va0FoZWFkUHJvcCA9IGxhc3QucHJvcChOb2RlUHJvcC5sb29rQWhlYWQpKVxuICAgICAgICAgICAgICAgICAgICBsb29rQWhlYWQgPSBwb3NpdGlvbnNbbGFzdEldICsgbGFzdC5sZW5ndGggKyBsb29rQWhlYWRQcm9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1ha2VUcmVlKHR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCwgbG9va0FoZWFkKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZVJlcGVhdExlYWYoY2hpbGRyZW4sIHBvc2l0aW9ucywgYmFzZSwgaSwgZnJvbSwgdG8sIHR5cGUsIGxvb2tBaGVhZCkge1xuICAgICAgICBsZXQgbG9jYWxDaGlsZHJlbiA9IFtdLCBsb2NhbFBvc2l0aW9ucyA9IFtdO1xuICAgICAgICB3aGlsZSAoY2hpbGRyZW4ubGVuZ3RoID4gaSkge1xuICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5wdXNoKGNoaWxkcmVuLnBvcCgpKTtcbiAgICAgICAgICAgIGxvY2FsUG9zaXRpb25zLnB1c2gocG9zaXRpb25zLnBvcCgpICsgYmFzZSAtIGZyb20pO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkcmVuLnB1c2gobWFrZVRyZWUobm9kZVNldC50eXBlc1t0eXBlXSwgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIHRvIC0gZnJvbSwgbG9va0FoZWFkIC0gdG8pKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goZnJvbSAtIGJhc2UpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlVHJlZSh0eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgsIGxvb2tBaGVhZCA9IDAsIHByb3BzKSB7XG4gICAgICAgIGlmIChjb250ZXh0SGFzaCkge1xuICAgICAgICAgICAgbGV0IHBhaXIgPSBbTm9kZVByb3AuY29udGV4dEhhc2gsIGNvbnRleHRIYXNoXTtcbiAgICAgICAgICAgIHByb3BzID0gcHJvcHMgPyBbcGFpcl0uY29uY2F0KHByb3BzKSA6IFtwYWlyXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9va0FoZWFkID4gMjUpIHtcbiAgICAgICAgICAgIGxldCBwYWlyID0gW05vZGVQcm9wLmxvb2tBaGVhZCwgbG9va0FoZWFkXTtcbiAgICAgICAgICAgIHByb3BzID0gcHJvcHMgPyBbcGFpcl0uY29uY2F0KHByb3BzKSA6IFtwYWlyXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRyZWUodHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoLCBwcm9wcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRCdWZmZXJTaXplKG1heFNpemUsIGluUmVwZWF0KSB7XG4gICAgICAgIC8vIFNjYW4gdGhyb3VnaCB0aGUgYnVmZmVyIHRvIGZpbmQgcHJldmlvdXMgc2libGluZ3MgdGhhdCBmaXRcbiAgICAgICAgLy8gdG9nZXRoZXIgaW4gYSBUcmVlQnVmZmVyLCBhbmQgZG9uJ3QgY29udGFpbiBhbnkgcmV1c2VkIG5vZGVzXG4gICAgICAgIC8vICh3aGljaCBjYW4ndCBiZSBzdG9yZWQgaW4gYSBidWZmZXIpLlxuICAgICAgICAvLyBJZiBgaW5SZXBlYXRgIGlzID4gLTEsIGlnbm9yZSBub2RlIGJvdW5kYXJpZXMgb2YgdGhhdCB0eXBlIGZvclxuICAgICAgICAvLyBuZXN0aW5nLCBidXQgbWFrZSBzdXJlIHRoZSBlbmQgZmFsbHMgZWl0aGVyIGF0IHRoZSBzdGFydFxuICAgICAgICAvLyAoYG1heFNpemVgKSBvciBiZWZvcmUgc3VjaCBhIG5vZGUuXG4gICAgICAgIGxldCBmb3JrID0gY3Vyc29yLmZvcmsoKTtcbiAgICAgICAgbGV0IHNpemUgPSAwLCBzdGFydCA9IDAsIHNraXAgPSAwLCBtaW5TdGFydCA9IGZvcmsuZW5kIC0gbWF4QnVmZmVyTGVuZ3RoO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyBzaXplOiAwLCBzdGFydDogMCwgc2tpcDogMCB9O1xuICAgICAgICBzY2FuOiBmb3IgKGxldCBtaW5Qb3MgPSBmb3JrLnBvcyAtIG1heFNpemU7IGZvcmsucG9zID4gbWluUG9zOykge1xuICAgICAgICAgICAgbGV0IG5vZGVTaXplID0gZm9yay5zaXplO1xuICAgICAgICAgICAgLy8gUHJldGVuZCBuZXN0ZWQgcmVwZWF0IG5vZGVzIG9mIHRoZSBzYW1lIHR5cGUgZG9uJ3QgZXhpc3RcbiAgICAgICAgICAgIGlmIChmb3JrLmlkID09IGluUmVwZWF0ICYmIG5vZGVTaXplID49IDApIHtcbiAgICAgICAgICAgICAgICAvLyBFeGNlcHQgdGhhdCB3ZSBzdG9yZSB0aGUgY3VycmVudCBzdGF0ZSBhcyBhIHZhbGlkIHJldHVyblxuICAgICAgICAgICAgICAgIC8vIHZhbHVlLlxuICAgICAgICAgICAgICAgIHJlc3VsdC5zaXplID0gc2l6ZTtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgICAgICByZXN1bHQuc2tpcCA9IHNraXA7XG4gICAgICAgICAgICAgICAgc2tpcCArPSA0O1xuICAgICAgICAgICAgICAgIHNpemUgKz0gNDtcbiAgICAgICAgICAgICAgICBmb3JrLm5leHQoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzdGFydFBvcyA9IGZvcmsucG9zIC0gbm9kZVNpemU7XG4gICAgICAgICAgICBpZiAobm9kZVNpemUgPCAwIHx8IHN0YXJ0UG9zIDwgbWluUG9zIHx8IGZvcmsuc3RhcnQgPCBtaW5TdGFydClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCBsb2NhbFNraXBwZWQgPSBmb3JrLmlkID49IG1pblJlcGVhdFR5cGUgPyA0IDogMDtcbiAgICAgICAgICAgIGxldCBub2RlU3RhcnQgPSBmb3JrLnN0YXJ0O1xuICAgICAgICAgICAgZm9yay5uZXh0KCk7XG4gICAgICAgICAgICB3aGlsZSAoZm9yay5wb3MgPiBzdGFydFBvcykge1xuICAgICAgICAgICAgICAgIGlmIChmb3JrLnNpemUgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3JrLnNpemUgPT0gLTMgLyogQ29udGV4dENoYW5nZSAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU2tpcHBlZCArPSA0O1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBzY2FuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JrLmlkID49IG1pblJlcGVhdFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTa2lwcGVkICs9IDQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvcmsubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnQgPSBub2RlU3RhcnQ7XG4gICAgICAgICAgICBzaXplICs9IG5vZGVTaXplO1xuICAgICAgICAgICAgc2tpcCArPSBsb2NhbFNraXBwZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluUmVwZWF0IDwgMCB8fCBzaXplID09IG1heFNpemUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zaXplID0gc2l6ZTtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgcmVzdWx0LnNraXAgPSBza2lwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuc2l6ZSA+IDQgPyByZXN1bHQgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvcHlUb0J1ZmZlcihidWZmZXJTdGFydCwgYnVmZmVyLCBpbmRleCkge1xuICAgICAgICBsZXQgeyBpZCwgc3RhcnQsIGVuZCwgc2l6ZSB9ID0gY3Vyc29yO1xuICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICBpZiAoc2l6ZSA+PSAwICYmIGlkIDwgbWluUmVwZWF0VHlwZSkge1xuICAgICAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIGlmIChzaXplID4gNCkge1xuICAgICAgICAgICAgICAgIGxldCBlbmRQb3MgPSBjdXJzb3IucG9zIC0gKHNpemUgLSA0KTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IGVuZFBvcylcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBjb3B5VG9CdWZmZXIoYnVmZmVyU3RhcnQsIGJ1ZmZlciwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gc3RhcnRJbmRleDtcbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IGVuZCAtIGJ1ZmZlclN0YXJ0O1xuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gc3RhcnQgLSBidWZmZXJTdGFydDtcbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNpemUgPT0gLTMgLyogQ29udGV4dENoYW5nZSAqLykge1xuICAgICAgICAgICAgY29udGV4dEhhc2ggPSBpZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzaXplID09IC00IC8qIExvb2tBaGVhZCAqLykge1xuICAgICAgICAgICAgbG9va0FoZWFkID0gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgICBsZXQgY2hpbGRyZW4gPSBbXSwgcG9zaXRpb25zID0gW107XG4gICAgd2hpbGUgKGN1cnNvci5wb3MgPiAwKVxuICAgICAgICB0YWtlTm9kZShkYXRhLnN0YXJ0IHx8IDAsIGRhdGEuYnVmZmVyU3RhcnQgfHwgMCwgY2hpbGRyZW4sIHBvc2l0aW9ucywgLTEpO1xuICAgIGxldCBsZW5ndGggPSAoX2EgPSBkYXRhLmxlbmd0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKGNoaWxkcmVuLmxlbmd0aCA/IHBvc2l0aW9uc1swXSArIGNoaWxkcmVuWzBdLmxlbmd0aCA6IDApO1xuICAgIHJldHVybiBuZXcgVHJlZSh0eXBlc1tkYXRhLnRvcElEXSwgY2hpbGRyZW4ucmV2ZXJzZSgpLCBwb3NpdGlvbnMucmV2ZXJzZSgpLCBsZW5ndGgpO1xufVxuY29uc3Qgbm9kZVNpemVDYWNoZSA9IG5ldyBXZWFrTWFwO1xuZnVuY3Rpb24gbm9kZVNpemUoYmFsYW5jZVR5cGUsIG5vZGUpIHtcbiAgICBpZiAoIWJhbGFuY2VUeXBlLmlzQW5vbnltb3VzIHx8IG5vZGUgaW5zdGFuY2VvZiBUcmVlQnVmZmVyIHx8IG5vZGUudHlwZSAhPSBiYWxhbmNlVHlwZSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgbGV0IHNpemUgPSBub2RlU2l6ZUNhY2hlLmdldChub2RlKTtcbiAgICBpZiAoc2l6ZSA9PSBudWxsKSB7XG4gICAgICAgIHNpemUgPSAxO1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPSBiYWxhbmNlVHlwZSB8fCAhKGNoaWxkIGluc3RhbmNlb2YgVHJlZSkpIHtcbiAgICAgICAgICAgICAgICBzaXplID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNpemUgKz0gbm9kZVNpemUoYmFsYW5jZVR5cGUsIGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlU2l6ZUNhY2hlLnNldChub2RlLCBzaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpemU7XG59XG5mdW5jdGlvbiBiYWxhbmNlUmFuZ2UoXG4vLyBUaGUgdHlwZSB0aGUgYmFsYW5jZWQgdHJlZSdzIGlubmVyIG5vZGVzLlxuYmFsYW5jZVR5cGUsIFxuLy8gVGhlIGRpcmVjdCBjaGlsZHJlbiBhbmQgdGhlaXIgcG9zaXRpb25zXG5jaGlsZHJlbiwgcG9zaXRpb25zLCBcbi8vIFRoZSBpbmRleCByYW5nZSBpbiBjaGlsZHJlbi9wb3NpdGlvbnMgdG8gdXNlXG5mcm9tLCB0bywgXG4vLyBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIG5vZGVzLCByZWxhdGl2ZSB0byB0aGVpciBwYXJlbnQuXG5zdGFydCwgXG4vLyBMZW5ndGggb2YgdGhlIG91dGVyIG5vZGVcbmxlbmd0aCwgXG4vLyBGdW5jdGlvbiB0byBidWlsZCB0aGUgdG9wIG5vZGUgb2YgdGhlIGJhbGFuY2VkIHRyZWVcbm1rVG9wLCBcbi8vIEZ1bmN0aW9uIHRvIGJ1aWxkIGludGVybmFsIG5vZGVzIGZvciB0aGUgYmFsYW5jZWQgdHJlZVxubWtUcmVlKSB7XG4gICAgbGV0IHRvdGFsID0gMDtcbiAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOyBpKyspXG4gICAgICAgIHRvdGFsICs9IG5vZGVTaXplKGJhbGFuY2VUeXBlLCBjaGlsZHJlbltpXSk7XG4gICAgbGV0IG1heENoaWxkID0gTWF0aC5jZWlsKCh0b3RhbCAqIDEuNSkgLyA4IC8qIEJyYW5jaEZhY3RvciAqLyk7XG4gICAgbGV0IGxvY2FsQ2hpbGRyZW4gPSBbXSwgbG9jYWxQb3NpdGlvbnMgPSBbXTtcbiAgICBmdW5jdGlvbiBkaXZpZGUoY2hpbGRyZW4sIHBvc2l0aW9ucywgZnJvbSwgdG8sIG9mZnNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOykge1xuICAgICAgICAgICAgbGV0IGdyb3VwRnJvbSA9IGksIGdyb3VwU3RhcnQgPSBwb3NpdGlvbnNbaV0sIGdyb3VwU2l6ZSA9IG5vZGVTaXplKGJhbGFuY2VUeXBlLCBjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dFNpemUgPSBub2RlU2l6ZShiYWxhbmNlVHlwZSwgY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgICAgIGlmIChncm91cFNpemUgKyBuZXh0U2l6ZSA+PSBtYXhDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZ3JvdXBTaXplICs9IG5leHRTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPT0gZ3JvdXBGcm9tICsgMSkge1xuICAgICAgICAgICAgICAgIGlmIChncm91cFNpemUgPiBtYXhDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb25seSA9IGNoaWxkcmVuW2dyb3VwRnJvbV07IC8vIE9ubHkgdHJlZXMgY2FuIGhhdmUgYSBzaXplID4gMVxuICAgICAgICAgICAgICAgICAgICBkaXZpZGUob25seS5jaGlsZHJlbiwgb25seS5wb3NpdGlvbnMsIDAsIG9ubHkuY2hpbGRyZW4ubGVuZ3RoLCBwb3NpdGlvbnNbZ3JvdXBGcm9tXSArIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2NhbENoaWxkcmVuLnB1c2goY2hpbGRyZW5bZ3JvdXBGcm9tXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbGVuZ3RoID0gcG9zaXRpb25zW2kgLSAxXSArIGNoaWxkcmVuW2kgLSAxXS5sZW5ndGggLSBncm91cFN0YXJ0O1xuICAgICAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaChiYWxhbmNlUmFuZ2UoYmFsYW5jZVR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGdyb3VwRnJvbSwgaSwgZ3JvdXBTdGFydCwgbGVuZ3RoLCBudWxsLCBta1RyZWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvY2FsUG9zaXRpb25zLnB1c2goZ3JvdXBTdGFydCArIG9mZnNldCAtIHN0YXJ0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXZpZGUoY2hpbGRyZW4sIHBvc2l0aW9ucywgZnJvbSwgdG8sIDApO1xuICAgIHJldHVybiAobWtUb3AgfHwgbWtUcmVlKShsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgbGVuZ3RoKTtcbn1cblxuLy8vIFRyZWUgZnJhZ21lbnRzIGFyZSB1c2VkIGR1cmluZyBbaW5jcmVtZW50YWxcbi8vLyBwYXJzaW5nXSgjY29tbW9uLlBhcnNlci5zdGFydFBhcnNlKSB0byB0cmFjayBwYXJ0cyBvZiBvbGQgdHJlZXNcbi8vLyB0aGF0IGNhbiBiZSByZXVzZWQgaW4gYSBuZXcgcGFyc2UuIEFuIGFycmF5IG9mIGZyYWdtZW50cyBpcyB1c2VkXG4vLy8gdG8gdHJhY2sgcmVnaW9ucyBvZiBhbiBvbGQgdHJlZSB3aG9zZSBub2RlcyBtaWdodCBiZSByZXVzZWQgaW4gbmV3XG4vLy8gcGFyc2VzLiBVc2UgdGhlIHN0YXRpY1xuLy8vIFtgYXBwbHlDaGFuZ2VzYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnReYXBwbHlDaGFuZ2VzKSBtZXRob2QgdG9cbi8vLyB1cGRhdGUgZnJhZ21lbnRzIGZvciBkb2N1bWVudCBjaGFuZ2VzLlxuY2xhc3MgVHJlZUZyYWdtZW50IHtcbiAgICAvLy8gQ29uc3RydWN0IGEgdHJlZSBmcmFnbWVudC5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIHN0YXJ0IG9mIHRoZSB1bmNoYW5nZWQgcmFuZ2UgcG9pbnRlZCB0byBieSB0aGlzIGZyYWdtZW50LlxuICAgIC8vLyBUaGlzIHJlZmVycyB0byBhbiBvZmZzZXQgaW4gdGhlIF91cGRhdGVkXyBkb2N1bWVudCAoYXMgb3Bwb3NlZFxuICAgIC8vLyB0byB0aGUgb3JpZ2luYWwgdHJlZSkuXG4gICAgZnJvbSwgXG4gICAgLy8vIFRoZSBlbmQgb2YgdGhlIHVuY2hhbmdlZCByYW5nZS5cbiAgICB0bywgXG4gICAgLy8vIFRoZSB0cmVlIHRoYXQgdGhpcyBmcmFnbWVudCBpcyBiYXNlZCBvbi5cbiAgICB0cmVlLCBcbiAgICAvLy8gVGhlIG9mZnNldCBiZXR3ZWVuIHRoZSBmcmFnbWVudCdzIHRyZWUgYW5kIHRoZSBkb2N1bWVudCB0aGF0XG4gICAgLy8vIHRoaXMgZnJhZ21lbnQgY2FuIGJlIHVzZWQgYWdhaW5zdC4gQWRkIHRoaXMgd2hlbiBnb2luZyBmcm9tXG4gICAgLy8vIGRvY3VtZW50IHRvIHRyZWUgcG9zaXRpb25zLCBzdWJ0cmFjdCBpdCB0byBnbyBmcm9tIHRyZWUgdG9cbiAgICAvLy8gZG9jdW1lbnQgcG9zaXRpb25zLlxuICAgIG9mZnNldCwgb3BlblN0YXJ0ID0gZmFsc2UsIG9wZW5FbmQgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLm9wZW4gPSAob3BlblN0YXJ0ID8gMSAvKiBTdGFydCAqLyA6IDApIHwgKG9wZW5FbmQgPyAyIC8qIEVuZCAqLyA6IDApO1xuICAgIH1cbiAgICAvLy8gV2hldGhlciB0aGUgc3RhcnQgb2YgdGhlIGZyYWdtZW50IHJlcHJlc2VudHMgdGhlIHN0YXJ0IG9mIGFcbiAgICAvLy8gcGFyc2UsIG9yIHRoZSBlbmQgb2YgYSBjaGFuZ2UuIChJbiB0aGUgc2Vjb25kIGNhc2UsIGl0IG1heSBub3RcbiAgICAvLy8gYmUgc2FmZSB0byByZXVzZSBzb21lIG5vZGVzIGF0IHRoZSBzdGFydCwgZGVwZW5kaW5nIG9uIHRoZVxuICAgIC8vLyBwYXJzaW5nIGFsZ29yaXRobS4pXG4gICAgZ2V0IG9wZW5TdGFydCgpIHsgcmV0dXJuICh0aGlzLm9wZW4gJiAxIC8qIFN0YXJ0ICovKSA+IDA7IH1cbiAgICAvLy8gV2hldGhlciB0aGUgZW5kIG9mIHRoZSBmcmFnbWVudCByZXByZXNlbnRzIHRoZSBlbmQgb2YgYVxuICAgIC8vLyBmdWxsLWRvY3VtZW50IHBhcnNlLCBvciB0aGUgc3RhcnQgb2YgYSBjaGFuZ2UuXG4gICAgZ2V0IG9wZW5FbmQoKSB7IHJldHVybiAodGhpcy5vcGVuICYgMiAvKiBFbmQgKi8pID4gMDsgfVxuICAgIC8vLyBDcmVhdGUgYSBzZXQgb2YgZnJhZ21lbnRzIGZyb20gYSBmcmVzaGx5IHBhcnNlZCB0cmVlLCBvciB1cGRhdGVcbiAgICAvLy8gYW4gZXhpc3Rpbmcgc2V0IG9mIGZyYWdtZW50cyBieSByZXBsYWNpbmcgdGhlIG9uZXMgdGhhdCBvdmVybGFwXG4gICAgLy8vIHdpdGggYSB0cmVlIHdpdGggY29udGVudCBmcm9tIHRoZSBuZXcgdHJlZS4gV2hlbiBgcGFydGlhbGAgaXNcbiAgICAvLy8gdHJ1ZSwgdGhlIHBhcnNlIGlzIHRyZWF0ZWQgYXMgaW5jb21wbGV0ZSwgYW5kIHRoZSByZXN1bHRpbmdcbiAgICAvLy8gZnJhZ21lbnQgaGFzIFtgb3BlbkVuZGBdKCNjb21tb24uVHJlZUZyYWdtZW50Lm9wZW5FbmQpIHNldCB0b1xuICAgIC8vLyB0cnVlLlxuICAgIHN0YXRpYyBhZGRUcmVlKHRyZWUsIGZyYWdtZW50cyA9IFtdLCBwYXJ0aWFsID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtuZXcgVHJlZUZyYWdtZW50KDAsIHRyZWUubGVuZ3RoLCB0cmVlLCAwLCBmYWxzZSwgcGFydGlhbCldO1xuICAgICAgICBmb3IgKGxldCBmIG9mIGZyYWdtZW50cylcbiAgICAgICAgICAgIGlmIChmLnRvID4gdHJlZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vLyBBcHBseSBhIHNldCBvZiBlZGl0cyB0byBhbiBhcnJheSBvZiBmcmFnbWVudHMsIHJlbW92aW5nIG9yXG4gICAgLy8vIHNwbGl0dGluZyBmcmFnbWVudHMgYXMgbmVjZXNzYXJ5IHRvIHJlbW92ZSBlZGl0ZWQgcmFuZ2VzLCBhbmRcbiAgICAvLy8gYWRqdXN0aW5nIG9mZnNldHMgZm9yIGZyYWdtZW50cyB0aGF0IG1vdmVkLlxuICAgIHN0YXRpYyBhcHBseUNoYW5nZXMoZnJhZ21lbnRzLCBjaGFuZ2VzLCBtaW5HYXAgPSAxMjgpIHtcbiAgICAgICAgaWYgKCFjaGFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudHM7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IGZJID0gMSwgbmV4dEYgPSBmcmFnbWVudHMubGVuZ3RoID8gZnJhZ21lbnRzWzBdIDogbnVsbDtcbiAgICAgICAgZm9yIChsZXQgY0kgPSAwLCBwb3MgPSAwLCBvZmYgPSAwOzsgY0krKykge1xuICAgICAgICAgICAgbGV0IG5leHRDID0gY0kgPCBjaGFuZ2VzLmxlbmd0aCA/IGNoYW5nZXNbY0ldIDogbnVsbDtcbiAgICAgICAgICAgIGxldCBuZXh0UG9zID0gbmV4dEMgPyBuZXh0Qy5mcm9tQSA6IDFlOTtcbiAgICAgICAgICAgIGlmIChuZXh0UG9zIC0gcG9zID49IG1pbkdhcClcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV4dEYgJiYgbmV4dEYuZnJvbSA8IG5leHRQb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1dCA9IG5leHRGO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zID49IGN1dC5mcm9tIHx8IG5leHRQb3MgPD0gY3V0LnRvIHx8IG9mZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZGcm9tID0gTWF0aC5tYXgoY3V0LmZyb20sIHBvcykgLSBvZmYsIGZUbyA9IE1hdGgubWluKGN1dC50bywgbmV4dFBvcykgLSBvZmY7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXQgPSBmRnJvbSA+PSBmVG8gPyBudWxsIDogbmV3IFRyZWVGcmFnbWVudChmRnJvbSwgZlRvLCBjdXQudHJlZSwgY3V0Lm9mZnNldCArIG9mZiwgY0kgPiAwLCAhIW5leHRDKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY3V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY3V0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRGLnRvID4gbmV4dFBvcylcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBuZXh0RiA9IGZJIDwgZnJhZ21lbnRzLmxlbmd0aCA/IGZyYWdtZW50c1tmSSsrXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFuZXh0QylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHBvcyA9IG5leHRDLnRvQTtcbiAgICAgICAgICAgIG9mZiA9IG5leHRDLnRvQSAtIG5leHRDLnRvQjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8vLyBBIHN1cGVyY2xhc3MgdGhhdCBwYXJzZXJzIHNob3VsZCBleHRlbmQuXG5jbGFzcyBQYXJzZXIge1xuICAgIC8vLyBTdGFydCBhIHBhcnNlLCByZXR1cm5pbmcgYSBbcGFydGlhbCBwYXJzZV0oI2NvbW1vbi5QYXJ0aWFsUGFyc2UpXG4gICAgLy8vIG9iamVjdC4gW2BmcmFnbWVudHNgXSgjY29tbW9uLlRyZWVGcmFnbWVudCkgY2FuIGJlIHBhc3NlZCBpbiB0b1xuICAgIC8vLyBtYWtlIHRoZSBwYXJzZSBpbmNyZW1lbnRhbC5cbiAgICAvLy9cbiAgICAvLy8gQnkgZGVmYXVsdCwgdGhlIGVudGlyZSBpbnB1dCBpcyBwYXJzZWQuIFlvdSBjYW4gcGFzcyBgcmFuZ2VzYCxcbiAgICAvLy8gd2hpY2ggc2hvdWxkIGJlIGEgc29ydGVkIGFycmF5IG9mIG5vbi1lbXB0eSwgbm9uLW92ZXJsYXBwaW5nXG4gICAgLy8vIHJhbmdlcywgdG8gcGFyc2Ugb25seSB0aG9zZSByYW5nZXMuIFRoZSB0cmVlIHJldHVybmVkIGluIHRoYXRcbiAgICAvLy8gY2FzZSB3aWxsIHN0YXJ0IGF0IGByYW5nZXNbMF0uZnJvbWAuXG4gICAgc3RhcnRQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgaW5wdXQgPSBuZXcgU3RyaW5nSW5wdXQoaW5wdXQpO1xuICAgICAgICByYW5nZXMgPSAhcmFuZ2VzID8gW25ldyBSYW5nZSgwLCBpbnB1dC5sZW5ndGgpXSA6IHJhbmdlcy5sZW5ndGggPyByYW5nZXMubWFwKHIgPT4gbmV3IFJhbmdlKHIuZnJvbSwgci50bykpIDogW25ldyBSYW5nZSgwLCAwKV07XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVBhcnNlKGlucHV0LCBmcmFnbWVudHMgfHwgW10sIHJhbmdlcyk7XG4gICAgfVxuICAgIC8vLyBSdW4gYSBmdWxsIHBhcnNlLCByZXR1cm5pbmcgdGhlIHJlc3VsdGluZyB0cmVlLlxuICAgIHBhcnNlKGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICBsZXQgcGFyc2UgPSB0aGlzLnN0YXJ0UGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGRvbmUgPSBwYXJzZS5hZHZhbmNlKCk7XG4gICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9uZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFN0cmluZ0lucHV0IHtcbiAgICBjb25zdHJ1Y3RvcihzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLnN0cmluZy5sZW5ndGg7IH1cbiAgICBjaHVuayhmcm9tKSB7IHJldHVybiB0aGlzLnN0cmluZy5zbGljZShmcm9tKTsgfVxuICAgIGdldCBsaW5lQ2h1bmtzKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICByZWFkKGZyb20sIHRvKSB7IHJldHVybiB0aGlzLnN0cmluZy5zbGljZShmcm9tLCB0byk7IH1cbn1cblxuLy8vIENyZWF0ZSBhIHBhcnNlIHdyYXBwZXIgdGhhdCwgYWZ0ZXIgdGhlIGlubmVyIHBhcnNlIGNvbXBsZXRlcyxcbi8vLyBzY2FucyBpdHMgdHJlZSBmb3IgbWl4ZWQgbGFuZ3VhZ2UgcmVnaW9ucyB3aXRoIHRoZSBgbmVzdGBcbi8vLyBmdW5jdGlvbiwgcnVucyB0aGUgcmVzdWx0aW5nIFtpbm5lciBwYXJzZXNdKCNjb21tb24uTmVzdGVkUGFyc2UpLFxuLy8vIGFuZCB0aGVuIFttb3VudHNdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgdGhlaXIgcmVzdWx0cyBvbnRvIHRoZVxuLy8vIHRyZWUuXG4vLy9cbi8vLyBUaGUgbmVzdGluZyBmdW5jdGlvbiBpcyBwYXNzZWQgYSBjdXJzb3IgdG8gcHJvdmlkZSBjb250ZXh0IGZvciBhXG4vLy8gbm9kZSwgYnV0IF9zaG91bGQgbm90XyBtb3ZlIHRoYXQgY3Vyc29yLCBvbmx5IGluc3BlY3QgaXRzXG4vLy8gcHJvcGVydGllcyBhbmQgb3B0aW9uYWxseSBhY2Nlc3MgaXRzXG4vLy8gW25vZGUgb2JqZWN0XSgjY29tbW9uLlRyZWVDdXJzb3Iubm9kZSkuXG5mdW5jdGlvbiBwYXJzZU1peGVkKG5lc3QpIHtcbiAgICByZXR1cm4gKHBhcnNlLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpID0+IG5ldyBNaXhlZFBhcnNlKHBhcnNlLCBuZXN0LCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xufVxuY2xhc3MgSW5uZXJQYXJzZSB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBwYXJzZSwgb3ZlcmxheSwgdGFyZ2V0LCByYW5nZXMpIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMucGFyc2UgPSBwYXJzZTtcbiAgICAgICAgdGhpcy5vdmVybGF5ID0gb3ZlcmxheTtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgIH1cbn1cbmNsYXNzIEFjdGl2ZU92ZXJsYXkge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgcHJlZGljYXRlLCBtb3VudHMsIGluZGV4LCBzdGFydCwgdGFyZ2V0LCBwcmV2KSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgdGhpcy5tb3VudHMgPSBtb3VudHM7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5wcmV2ID0gcHJldjtcbiAgICAgICAgdGhpcy5kZXB0aCA9IDA7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gW107XG4gICAgfVxufVxuY29uc3Qgc3RvcHBlZElubmVyID0gbmV3IE5vZGVQcm9wKHsgcGVyTm9kZTogdHJ1ZSB9KTtcbmNsYXNzIE1peGVkUGFyc2Uge1xuICAgIGNvbnN0cnVjdG9yKGJhc2UsIG5lc3QsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICB0aGlzLm5lc3QgPSBuZXN0O1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgdGhpcy5pbm5lciA9IFtdO1xuICAgICAgICB0aGlzLmlubmVyRG9uZSA9IDA7XG4gICAgICAgIHRoaXMuYmFzZVRyZWUgPSBudWxsO1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IG51bGw7XG4gICAgICAgIHRoaXMuYmFzZVBhcnNlID0gYmFzZTtcbiAgICB9XG4gICAgYWR2YW5jZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuYmFzZVBhcnNlKSB7XG4gICAgICAgICAgICBsZXQgZG9uZSA9IHRoaXMuYmFzZVBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIGlmICghZG9uZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuYmFzZVBhcnNlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuYmFzZVRyZWUgPSBkb25lO1xuICAgICAgICAgICAgdGhpcy5zdGFydElubmVyKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5zdG9wcGVkQXQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpbm5lciBvZiB0aGlzLmlubmVyKVxuICAgICAgICAgICAgICAgICAgICBpbm5lci5wYXJzZS5zdG9wQXQodGhpcy5zdG9wcGVkQXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlubmVyRG9uZSA9PSB0aGlzLmlubmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuYmFzZVRyZWU7XG4gICAgICAgICAgICBpZiAodGhpcy5zdG9wcGVkQXQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgVHJlZShyZXN1bHQudHlwZSwgcmVzdWx0LmNoaWxkcmVuLCByZXN1bHQucG9zaXRpb25zLCByZXN1bHQubGVuZ3RoLCByZXN1bHQucHJvcFZhbHVlcy5jb25jYXQoW1tzdG9wcGVkSW5uZXIsIHRoaXMuc3RvcHBlZEF0XV0pKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlubmVyID0gdGhpcy5pbm5lclt0aGlzLmlubmVyRG9uZV0sIGRvbmUgPSBpbm5lci5wYXJzZS5hZHZhbmNlKCk7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICB0aGlzLmlubmVyRG9uZSsrO1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHNvbWV3aGF0IGRvZGd5IGJ1dCBzdXBlciBoZWxwZnVsIGhhY2sgd2hlcmUgd2VcbiAgICAgICAgICAgIC8vIHBhdGNoIHVwIG5vZGVzIGNyZWF0ZWQgYnkgdGhlIGlubmVyIHBhcnNlIChhbmQgdGh1c1xuICAgICAgICAgICAgLy8gcHJlc3VtYWJseSBub3QgYWxpYXNlZCBhbnl3aGVyZSBlbHNlKSB0byBob2xkIHRoZSBpbmZvcm1hdGlvblxuICAgICAgICAgICAgLy8gYWJvdXQgdGhlIGlubmVyIHBhcnNlLlxuICAgICAgICAgICAgbGV0IHByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCBpbm5lci50YXJnZXQucHJvcHMpO1xuICAgICAgICAgICAgcHJvcHNbTm9kZVByb3AubW91bnRlZC5pZF0gPSBuZXcgTW91bnRlZFRyZWUoZG9uZSwgaW5uZXIub3ZlcmxheSwgaW5uZXIucGFyc2VyKTtcbiAgICAgICAgICAgIGlubmVyLnRhcmdldC5wcm9wcyA9IHByb3BzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBnZXQgcGFyc2VkUG9zKCkge1xuICAgICAgICBpZiAodGhpcy5iYXNlUGFyc2UpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMuaW5wdXQubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbm5lckRvbmU7IGkgPCB0aGlzLmlubmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbm5lcltpXS5yYW5nZXNbMF0uZnJvbSA8IHBvcylcbiAgICAgICAgICAgICAgICBwb3MgPSBNYXRoLm1pbihwb3MsIHRoaXMuaW5uZXJbaV0ucGFyc2UucGFyc2VkUG9zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICBzdG9wQXQocG9zKSB7XG4gICAgICAgIHRoaXMuc3RvcHBlZEF0ID0gcG9zO1xuICAgICAgICBpZiAodGhpcy5iYXNlUGFyc2UpXG4gICAgICAgICAgICB0aGlzLmJhc2VQYXJzZS5zdG9wQXQocG9zKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuaW5uZXJEb25lOyBpIDwgdGhpcy5pbm5lci5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICB0aGlzLmlubmVyW2ldLnBhcnNlLnN0b3BBdChwb3MpO1xuICAgIH1cbiAgICBzdGFydElubmVyKCkge1xuICAgICAgICBsZXQgZnJhZ21lbnRDdXJzb3IgPSBuZXcgRnJhZ21lbnRDdXJzb3IodGhpcy5mcmFnbWVudHMpO1xuICAgICAgICBsZXQgb3ZlcmxheSA9IG51bGw7XG4gICAgICAgIGxldCBjb3ZlcmVkID0gbnVsbDtcbiAgICAgICAgbGV0IGN1cnNvciA9IG5ldyBUcmVlQ3Vyc29yKG5ldyBUcmVlTm9kZSh0aGlzLmJhc2VUcmVlLCB0aGlzLnJhbmdlc1swXS5mcm9tLCAwLCBudWxsKSwgMSAvKiBGdWxsICovKTtcbiAgICAgICAgc2NhbjogZm9yIChsZXQgbmVzdCwgaXNDb3ZlcmVkOyB0aGlzLnN0b3BwZWRBdCA9PSBudWxsIHx8IGN1cnNvci5mcm9tIDwgdGhpcy5zdG9wcGVkQXQ7KSB7XG4gICAgICAgICAgICBsZXQgZW50ZXIgPSB0cnVlLCByYW5nZTtcbiAgICAgICAgICAgIGlmIChmcmFnbWVudEN1cnNvci5oYXNOb2RlKGN1cnNvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWF0Y2ggPSBvdmVybGF5Lm1vdW50cy5maW5kKG0gPT4gbS5mcmFnLmZyb20gPD0gY3Vyc29yLmZyb20gJiYgbS5mcmFnLnRvID49IGN1cnNvci50byAmJiBtLm1vdW50Lm92ZXJsYXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCByIG9mIG1hdGNoLm1vdW50Lm92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHIuZnJvbSArIG1hdGNoLnBvcywgdG8gPSByLnRvICsgbWF0Y2gucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcm9tID49IGN1cnNvci5mcm9tICYmIHRvIDw9IGN1cnNvci50byAmJiAhb3ZlcmxheS5yYW5nZXMuc29tZShyID0+IHIuZnJvbSA8IHRvICYmIHIudG8gPiBmcm9tKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5yYW5nZXMucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbnRlciA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY292ZXJlZCAmJiAoaXNDb3ZlcmVkID0gY2hlY2tDb3Zlcihjb3ZlcmVkLnJhbmdlcywgY3Vyc29yLmZyb20sIGN1cnNvci50bykpKSB7XG4gICAgICAgICAgICAgICAgZW50ZXIgPSBpc0NvdmVyZWQgIT0gMiAvKiBGdWxsICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWN1cnNvci50eXBlLmlzQW5vbnltb3VzICYmIGN1cnNvci5mcm9tIDwgY3Vyc29yLnRvICYmIChuZXN0ID0gdGhpcy5uZXN0KGN1cnNvciwgdGhpcy5pbnB1dCkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IudHJlZSlcbiAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWxpemUoY3Vyc29yKTtcbiAgICAgICAgICAgICAgICBsZXQgb2xkTW91bnRzID0gZnJhZ21lbnRDdXJzb3IuZmluZE1vdW50cyhjdXJzb3IuZnJvbSwgbmVzdC5wYXJzZXIpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbmVzdC5vdmVybGF5ID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBvdmVybGF5ID0gbmV3IEFjdGl2ZU92ZXJsYXkobmVzdC5wYXJzZXIsIG5lc3Qub3ZlcmxheSwgb2xkTW91bnRzLCB0aGlzLmlubmVyLmxlbmd0aCwgY3Vyc29yLmZyb20sIGN1cnNvci50cmVlLCBvdmVybGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByYW5nZXMgPSBwdW5jaFJhbmdlcyh0aGlzLnJhbmdlcywgbmVzdC5vdmVybGF5IHx8IFtuZXcgUmFuZ2UoY3Vyc29yLmZyb20sIGN1cnNvci50byldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlubmVyLnB1c2gobmV3IElubmVyUGFyc2UobmVzdC5wYXJzZXIsIG5lc3QucGFyc2VyLnN0YXJ0UGFyc2UodGhpcy5pbnB1dCwgZW50ZXJGcmFnbWVudHMob2xkTW91bnRzLCByYW5nZXMpLCByYW5nZXMpLCBuZXN0Lm92ZXJsYXkgPyBuZXN0Lm92ZXJsYXkubWFwKHIgPT4gbmV3IFJhbmdlKHIuZnJvbSAtIGN1cnNvci5mcm9tLCByLnRvIC0gY3Vyc29yLmZyb20pKSA6IG51bGwsIGN1cnNvci50cmVlLCByYW5nZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXN0Lm92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgY292ZXJlZCA9IHsgcmFuZ2VzLCBkZXB0aDogMCwgcHJldjogY292ZXJlZCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG92ZXJsYXkgJiYgKHJhbmdlID0gb3ZlcmxheS5wcmVkaWNhdGUoY3Vyc29yKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0gbmV3IFJhbmdlKGN1cnNvci5mcm9tLCBjdXJzb3IudG8pO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5mcm9tIDwgcmFuZ2UudG8pXG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXkucmFuZ2VzLnB1c2gocmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVudGVyICYmIGN1cnNvci5maXJzdENoaWxkKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSlcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5kZXB0aCsrO1xuICAgICAgICAgICAgICAgIGlmIChjb3ZlcmVkKVxuICAgICAgICAgICAgICAgICAgICBjb3ZlcmVkLmRlcHRoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJzb3IubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnNvci5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHNjYW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdmVybGF5ICYmICEtLW92ZXJsYXkuZGVwdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByYW5nZXMgPSBwdW5jaFJhbmdlcyh0aGlzLnJhbmdlcywgb3ZlcmxheS5yYW5nZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbm5lci5zcGxpY2Uob3ZlcmxheS5pbmRleCwgMCwgbmV3IElubmVyUGFyc2Uob3ZlcmxheS5wYXJzZXIsIG92ZXJsYXkucGFyc2VyLnN0YXJ0UGFyc2UodGhpcy5pbnB1dCwgZW50ZXJGcmFnbWVudHMob3ZlcmxheS5tb3VudHMsIHJhbmdlcyksIHJhbmdlcyksIG92ZXJsYXkucmFuZ2VzLm1hcChyID0+IG5ldyBSYW5nZShyLmZyb20gLSBvdmVybGF5LnN0YXJ0LCByLnRvIC0gb3ZlcmxheS5zdGFydCkpLCBvdmVybGF5LnRhcmdldCwgcmFuZ2VzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGF5ID0gb3ZlcmxheS5wcmV2O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3ZlcmVkICYmICEtLWNvdmVyZWQuZGVwdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3ZlcmVkID0gY292ZXJlZC5wcmV2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrQ292ZXIoY292ZXJlZCwgZnJvbSwgdG8pIHtcbiAgICBmb3IgKGxldCByYW5nZSBvZiBjb3ZlcmVkKSB7XG4gICAgICAgIGlmIChyYW5nZS5mcm9tID49IHRvKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChyYW5nZS50byA+IGZyb20pXG4gICAgICAgICAgICByZXR1cm4gcmFuZ2UuZnJvbSA8PSBmcm9tICYmIHJhbmdlLnRvID49IHRvID8gMiAvKiBGdWxsICovIDogMSAvKiBQYXJ0aWFsICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBOb25lICovO1xufVxuLy8gVGFrZSBhIHBpZWNlIG9mIGJ1ZmZlciBhbmQgY29udmVydCBpdCBpbnRvIGEgc3RhbmQtYWxvbmVcbi8vIFRyZWVCdWZmZXIuXG5mdW5jdGlvbiBzbGljZUJ1ZihidWYsIHN0YXJ0SSwgZW5kSSwgbm9kZXMsIHBvc2l0aW9ucywgb2ZmKSB7XG4gICAgaWYgKHN0YXJ0SSA8IGVuZEkpIHtcbiAgICAgICAgbGV0IGZyb20gPSBidWYuYnVmZmVyW3N0YXJ0SSArIDFdLCB0byA9IGJ1Zi5idWZmZXJbZW5kSSAtIDJdO1xuICAgICAgICBub2Rlcy5wdXNoKGJ1Zi5zbGljZShzdGFydEksIGVuZEksIGZyb20sIHRvKSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKGZyb20gLSBvZmYpO1xuICAgIH1cbn1cbi8vIFRoaXMgZnVuY3Rpb24gdGFrZXMgYSBub2RlIHRoYXQncyBpbiBhIGJ1ZmZlciwgYW5kIGNvbnZlcnRzIGl0LCBhbmRcbi8vIGl0cyBwYXJlbnQgYnVmZmVyIG5vZGVzLCBpbnRvIGEgVHJlZS4gVGhpcyBpcyBhZ2FpbiBhY3Rpbmcgb24gdGhlXG4vLyBhc3N1bXB0aW9uIHRoYXQgdGhlIHRyZWVzIGFuZCBidWZmZXJzIGhhdmUgYmVlbiBjb25zdHJ1Y3RlZCBieSB0aGVcbi8vIHBhcnNlIHRoYXQgd2FzIHJhbiB2aWEgdGhlIG1peCBwYXJzZXIsIGFuZCB0aHVzIGFyZW4ndCBzaGFyZWQgd2l0aFxuLy8gYW55IG90aGVyIGNvZGUsIG1ha2luZyB2aW9sYXRpb25zIG9mIHRoZSBpbW11dGFiaWxpdHkgc2FmZS5cbmZ1bmN0aW9uIG1hdGVyaWFsaXplKGN1cnNvcikge1xuICAgIGxldCB7IG5vZGUgfSA9IGN1cnNvciwgZGVwdGggPSAwO1xuICAgIC8vIFNjYW4gdXAgdG8gdGhlIG5lYXJlc3QgdHJlZVxuICAgIGRvIHtcbiAgICAgICAgY3Vyc29yLnBhcmVudCgpO1xuICAgICAgICBkZXB0aCsrO1xuICAgIH0gd2hpbGUgKCFjdXJzb3IudHJlZSk7XG4gICAgLy8gRmluZCB0aGUgaW5kZXggb2YgdGhlIGJ1ZmZlciBpbiB0aGF0IHRyZWVcbiAgICBsZXQgaSA9IDAsIGJhc2UgPSBjdXJzb3IudHJlZSwgb2ZmID0gMDtcbiAgICBmb3IgKDs7IGkrKykge1xuICAgICAgICBvZmYgPSBiYXNlLnBvc2l0aW9uc1tpXSArIGN1cnNvci5mcm9tO1xuICAgICAgICBpZiAob2ZmIDw9IG5vZGUuZnJvbSAmJiBvZmYgKyBiYXNlLmNoaWxkcmVuW2ldLmxlbmd0aCA+PSBub2RlLnRvKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxldCBidWYgPSBiYXNlLmNoaWxkcmVuW2ldLCBiID0gYnVmLmJ1ZmZlcjtcbiAgICAvLyBTcGxpdCBhIGxldmVsIGluIHRoZSBidWZmZXIsIHB1dHRpbmcgdGhlIG5vZGVzIGJlZm9yZSBhbmQgYWZ0ZXJcbiAgICAvLyB0aGUgY2hpbGQgdGhhdCBjb250YWlucyBgbm9kZWAgaW50byBuZXcgYnVmZmVycy5cbiAgICBmdW5jdGlvbiBzcGxpdChzdGFydEksIGVuZEksIHR5cGUsIGlubmVyT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgICAgbGV0IGkgPSBzdGFydEk7XG4gICAgICAgIHdoaWxlIChiW2kgKyAyXSArIG9mZiA8PSBub2RlLmZyb20pXG4gICAgICAgICAgICBpID0gYltpICsgM107XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdLCBwb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgc2xpY2VCdWYoYnVmLCBzdGFydEksIGksIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGlubmVyT2Zmc2V0KTtcbiAgICAgICAgbGV0IGZyb20gPSBiW2kgKyAxXSwgdG8gPSBiW2kgKyAyXTtcbiAgICAgICAgbGV0IGlzVGFyZ2V0ID0gZnJvbSArIG9mZiA9PSBub2RlLmZyb20gJiYgdG8gKyBvZmYgPT0gbm9kZS50byAmJiBiW2ldID09IG5vZGUudHlwZS5pZDtcbiAgICAgICAgY2hpbGRyZW4ucHVzaChpc1RhcmdldCA/IG5vZGUudG9UcmVlKCkgOiBzcGxpdChpICsgNCwgYltpICsgM10sIGJ1Zi5zZXQudHlwZXNbYltpXV0sIGZyb20sIHRvIC0gZnJvbSkpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaChmcm9tIC0gaW5uZXJPZmZzZXQpO1xuICAgICAgICBzbGljZUJ1ZihidWYsIGJbaSArIDNdLCBlbmRJLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBpbm5lck9mZnNldCk7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZSh0eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpO1xuICAgIH1cbiAgICBiYXNlLmNoaWxkcmVuW2ldID0gc3BsaXQoMCwgYi5sZW5ndGgsIE5vZGVUeXBlLm5vbmUsIDAsIGJ1Zi5sZW5ndGgpO1xuICAgIC8vIE1vdmUgdGhlIGN1cnNvciBiYWNrIHRvIHRoZSB0YXJnZXQgbm9kZVxuICAgIGZvciAobGV0IGQgPSAwOyBkIDw9IGRlcHRoOyBkKyspXG4gICAgICAgIGN1cnNvci5jaGlsZEFmdGVyKG5vZGUuZnJvbSk7XG59XG5jbGFzcyBTdHJ1Y3R1cmVDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKHJvb3QsIG9mZnNldCkge1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gcm9vdC5mdWxsQ3Vyc29yKCk7XG4gICAgfVxuICAgIC8vIE1vdmUgdG8gdGhlIGZpcnN0IG5vZGUgKGluIHByZS1vcmRlcikgdGhhdCBzdGFydHMgYXQgb3IgYWZ0ZXIgYHBvc2AuXG4gICAgbW92ZVRvKHBvcykge1xuICAgICAgICBsZXQgeyBjdXJzb3IgfSA9IHRoaXMsIHAgPSBwb3MgLSB0aGlzLm9mZnNldDtcbiAgICAgICAgd2hpbGUgKCF0aGlzLmRvbmUgJiYgY3Vyc29yLmZyb20gPCBwKSB7XG4gICAgICAgICAgICBpZiAoY3Vyc29yLnRvID49IHBvcyAmJiBjdXJzb3IuZW50ZXIocCwgMSwgZmFsc2UsIGZhbHNlKSkgO1xuICAgICAgICAgICAgZWxzZSBpZiAoIWN1cnNvci5uZXh0KGZhbHNlKSlcbiAgICAgICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhc05vZGUoY3Vyc29yKSB7XG4gICAgICAgIHRoaXMubW92ZVRvKGN1cnNvci5mcm9tKTtcbiAgICAgICAgaWYgKCF0aGlzLmRvbmUgJiYgdGhpcy5jdXJzb3IuZnJvbSArIHRoaXMub2Zmc2V0ID09IGN1cnNvci5mcm9tICYmIHRoaXMuY3Vyc29yLnRyZWUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHRyZWUgPSB0aGlzLmN1cnNvci50cmVlOzspIHtcbiAgICAgICAgICAgICAgICBpZiAodHJlZSA9PSBjdXJzb3IudHJlZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHRyZWUuY2hpbGRyZW4ubGVuZ3RoICYmIHRyZWUucG9zaXRpb25zWzBdID09IDAgJiYgdHJlZS5jaGlsZHJlblswXSBpbnN0YW5jZW9mIFRyZWUpXG4gICAgICAgICAgICAgICAgICAgIHRyZWUgPSB0cmVlLmNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmNsYXNzIEZyYWdtZW50Q3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcbiAgICAgICAgdGhpcy5jdXJUbyA9IDA7XG4gICAgICAgIHRoaXMuZnJhZ0kgPSAwO1xuICAgICAgICBpZiAoZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gdGhpcy5jdXJGcmFnID0gZnJhZ21lbnRzWzBdO1xuICAgICAgICAgICAgdGhpcy5jdXJUbyA9IChfYSA9IGZpcnN0LnRyZWUucHJvcChzdG9wcGVkSW5uZXIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmaXJzdC50bztcbiAgICAgICAgICAgIHRoaXMuaW5uZXIgPSBuZXcgU3RydWN0dXJlQ3Vyc29yKGZpcnN0LnRyZWUsIC1maXJzdC5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJGcmFnID0gdGhpcy5pbm5lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFzTm9kZShub2RlKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmN1ckZyYWcgJiYgbm9kZS5mcm9tID49IHRoaXMuY3VyVG8pXG4gICAgICAgICAgICB0aGlzLm5leHRGcmFnKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmN1ckZyYWcgJiYgdGhpcy5jdXJGcmFnLmZyb20gPD0gbm9kZS5mcm9tICYmIHRoaXMuY3VyVG8gPj0gbm9kZS50byAmJiB0aGlzLmlubmVyLmhhc05vZGUobm9kZSk7XG4gICAgfVxuICAgIG5leHRGcmFnKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuZnJhZ0krKztcbiAgICAgICAgaWYgKHRoaXMuZnJhZ0kgPT0gdGhpcy5mcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmN1ckZyYWcgPSB0aGlzLmlubmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBmcmFnID0gdGhpcy5jdXJGcmFnID0gdGhpcy5mcmFnbWVudHNbdGhpcy5mcmFnSV07XG4gICAgICAgICAgICB0aGlzLmN1clRvID0gKF9hID0gZnJhZy50cmVlLnByb3Aoc3RvcHBlZElubmVyKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZnJhZy50bztcbiAgICAgICAgICAgIHRoaXMuaW5uZXIgPSBuZXcgU3RydWN0dXJlQ3Vyc29yKGZyYWcudHJlZSwgLWZyYWcub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5kTW91bnRzKHBvcywgcGFyc2VyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAodGhpcy5pbm5lcikge1xuICAgICAgICAgICAgdGhpcy5pbm5lci5jdXJzb3IubW92ZVRvKHBvcywgMSk7XG4gICAgICAgICAgICBmb3IgKGxldCBwb3MgPSB0aGlzLmlubmVyLmN1cnNvci5ub2RlOyBwb3M7IHBvcyA9IHBvcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbW91bnQgPSAoX2EgPSBwb3MudHJlZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByb3AoTm9kZVByb3AubW91bnRlZCk7XG4gICAgICAgICAgICAgICAgaWYgKG1vdW50ICYmIG1vdW50LnBhcnNlciA9PSBwYXJzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuZnJhZ0k7IGkgPCB0aGlzLmZyYWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZyYWcgPSB0aGlzLmZyYWdtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFnLmZyb20gPj0gcG9zLnRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWcudHJlZSA9PSB0aGlzLmN1ckZyYWcudHJlZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvczogcG9zLmZyb20gLSBmcmFnLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW91bnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHB1bmNoUmFuZ2VzKG91dGVyLCByYW5nZXMpIHtcbiAgICBsZXQgY29weSA9IG51bGwsIGN1cnJlbnQgPSByYW5nZXM7XG4gICAgZm9yIChsZXQgaSA9IDEsIGogPSAwOyBpIDwgb3V0ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGdhcEZyb20gPSBvdXRlcltpIC0gMV0udG8sIGdhcFRvID0gb3V0ZXJbaV0uZnJvbTtcbiAgICAgICAgZm9yICg7IGogPCBjdXJyZW50Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBsZXQgciA9IGN1cnJlbnRbal07XG4gICAgICAgICAgICBpZiAoci5mcm9tID49IGdhcFRvKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHIudG8gPD0gZ2FwRnJvbSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICghY29weSlcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY29weSA9IHJhbmdlcy5zbGljZSgpO1xuICAgICAgICAgICAgaWYgKHIuZnJvbSA8IGdhcEZyb20pIHtcbiAgICAgICAgICAgICAgICBjb3B5W2pdID0gbmV3IFJhbmdlKHIuZnJvbSwgZ2FwRnJvbSk7XG4gICAgICAgICAgICAgICAgaWYgKHIudG8gPiBnYXBUbylcbiAgICAgICAgICAgICAgICAgICAgY29weS5zcGxpY2UoaiArIDEsIDAsIG5ldyBSYW5nZShnYXBUbywgci50bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoci50byA+IGdhcFRvKSB7XG4gICAgICAgICAgICAgICAgY29weVtqLS1dID0gbmV3IFJhbmdlKGdhcFRvLCByLnRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvcHkuc3BsaWNlKGotLSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG59XG5mdW5jdGlvbiBmaW5kQ292ZXJDaGFuZ2VzKGEsIGIsIGZyb20sIHRvKSB7XG4gICAgbGV0IGlBID0gMCwgaUIgPSAwLCBpbkEgPSBmYWxzZSwgaW5CID0gZmFsc2UsIHBvcyA9IC0xZTk7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgbGV0IG5leHRBID0gaUEgPT0gYS5sZW5ndGggPyAxZTkgOiBpbkEgPyBhW2lBXS50byA6IGFbaUFdLmZyb207XG4gICAgICAgIGxldCBuZXh0QiA9IGlCID09IGIubGVuZ3RoID8gMWU5IDogaW5CID8gYltpQl0udG8gOiBiW2lCXS5mcm9tO1xuICAgICAgICBpZiAoaW5BICE9IGluQikge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgocG9zLCBmcm9tKSwgZW5kID0gTWF0aC5taW4obmV4dEEsIG5leHRCLCB0byk7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPCBlbmQpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFJhbmdlKHN0YXJ0LCBlbmQpKTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgPSBNYXRoLm1pbihuZXh0QSwgbmV4dEIpO1xuICAgICAgICBpZiAocG9zID09IDFlOSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAobmV4dEEgPT0gcG9zKSB7XG4gICAgICAgICAgICBpZiAoIWluQSlcbiAgICAgICAgICAgICAgICBpbkEgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5BID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaUErKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dEIgPT0gcG9zKSB7XG4gICAgICAgICAgICBpZiAoIWluQilcbiAgICAgICAgICAgICAgICBpbkIgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5CID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaUIrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gR2l2ZW4gYSBudW1iZXIgb2YgZnJhZ21lbnRzIGZvciB0aGUgb3V0ZXIgdHJlZSwgYW5kIGEgc2V0IG9mIHJhbmdlc1xuLy8gdG8gcGFyc2UsIGZpbmQgZnJhZ21lbnRzIGZvciBpbm5lciB0cmVlcyBtb3VudGVkIGFyb3VuZCB0aG9zZVxuLy8gcmFuZ2VzLCBpZiBhbnkuXG5mdW5jdGlvbiBlbnRlckZyYWdtZW50cyhtb3VudHMsIHJhbmdlcykge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCB7IHBvcywgbW91bnQsIGZyYWcgfSBvZiBtb3VudHMpIHtcbiAgICAgICAgbGV0IHN0YXJ0UG9zID0gcG9zICsgKG1vdW50Lm92ZXJsYXkgPyBtb3VudC5vdmVybGF5WzBdLmZyb20gOiAwKSwgZW5kUG9zID0gc3RhcnRQb3MgKyBtb3VudC50cmVlLmxlbmd0aDtcbiAgICAgICAgbGV0IGZyb20gPSBNYXRoLm1heChmcmFnLmZyb20sIHN0YXJ0UG9zKSwgdG8gPSBNYXRoLm1pbihmcmFnLnRvLCBlbmRQb3MpO1xuICAgICAgICBpZiAobW91bnQub3ZlcmxheSkge1xuICAgICAgICAgICAgbGV0IG92ZXJsYXkgPSBtb3VudC5vdmVybGF5Lm1hcChyID0+IG5ldyBSYW5nZShyLmZyb20gKyBwb3MsIHIudG8gKyBwb3MpKTtcbiAgICAgICAgICAgIGxldCBjaGFuZ2VzID0gZmluZENvdmVyQ2hhbmdlcyhyYW5nZXMsIG92ZXJsYXksIGZyb20sIHRvKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSBmcm9tOzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxhc3QgPSBpID09IGNoYW5nZXMubGVuZ3RoLCBlbmQgPSBsYXN0ID8gdG8gOiBjaGFuZ2VzW2ldLmZyb207XG4gICAgICAgICAgICAgICAgaWYgKGVuZCA+IHBvcylcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFRyZWVGcmFnbWVudChwb3MsIGVuZCwgbW91bnQudHJlZSwgLXN0YXJ0UG9zLCBmcmFnLmZyb20gPj0gcG9zLCBmcmFnLnRvIDw9IGVuZCkpO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0KVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBwb3MgPSBjaGFuZ2VzW2ldLnRvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFRyZWVGcmFnbWVudChmcm9tLCB0bywgbW91bnQudHJlZSwgLXN0YXJ0UG9zLCBmcmFnLmZyb20gPj0gc3RhcnRQb3MsIGZyYWcudG8gPD0gZW5kUG9zKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IHsgRGVmYXVsdEJ1ZmZlckxlbmd0aCwgTW91bnRlZFRyZWUsIE5vZGVQcm9wLCBOb2RlU2V0LCBOb2RlVHlwZSwgUGFyc2VyLCBUcmVlLCBUcmVlQnVmZmVyLCBUcmVlQ3Vyc29yLCBUcmVlRnJhZ21lbnQsIHBhcnNlTWl4ZWQgfTtcbiIsImltcG9ydCB7IFBhcnNlciwgTm9kZVNldCwgTm9kZVR5cGUsIERlZmF1bHRCdWZmZXJMZW5ndGgsIE5vZGVQcm9wLCBUcmVlIH0gZnJvbSAnQGxlemVyL2NvbW1vbic7XG5cbi8vLyBBIHBhcnNlIHN0YWNrLiBUaGVzZSBhcmUgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBwYXJzZXIgdG8gdHJhY2tcbi8vLyBwYXJzaW5nIHByb2dyZXNzLiBUaGV5IGFsc28gcHJvdmlkZSBzb21lIHByb3BlcnRpZXMgYW5kIG1ldGhvZHNcbi8vLyB0aGF0IGV4dGVybmFsIGNvZGUgc3VjaCBhcyBhIHRva2VuaXplciBjYW4gdXNlIHRvIGdldCBpbmZvcm1hdGlvblxuLy8vIGFib3V0IHRoZSBwYXJzZSBzdGF0ZS5cbmNsYXNzIFN0YWNrIHtcbiAgICAvLy8gQGludGVybmFsXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIFRoZSBwYXJzZSB0aGF0IHRoaXMgc3RhY2sgaXMgcGFydCBvZiBAaW50ZXJuYWxcbiAgICBwLCBcbiAgICAvLy8gSG9sZHMgc3RhdGUsIGlucHV0IHBvcywgYnVmZmVyIGluZGV4IHRyaXBsZXRzIGZvciBhbGwgYnV0IHRoZVxuICAgIC8vLyB0b3Agc3RhdGUgQGludGVybmFsXG4gICAgc3RhY2ssIFxuICAgIC8vLyBUaGUgY3VycmVudCBwYXJzZSBzdGF0ZSBAaW50ZXJuYWxcbiAgICBzdGF0ZSwgXG4gICAgLy8gVGhlIHBvc2l0aW9uIGF0IHdoaWNoIHRoZSBuZXh0IHJlZHVjZSBzaG91bGQgdGFrZSBwbGFjZS4gVGhpc1xuICAgIC8vIGNhbiBiZSBsZXNzIHRoYW4gYHRoaXMucG9zYCB3aGVuIHNraXBwZWQgZXhwcmVzc2lvbnMgaGF2ZSBiZWVuXG4gICAgLy8gYWRkZWQgdG8gdGhlIHN0YWNrICh3aGljaCBzaG91bGQgYmUgbW92ZWQgb3V0c2lkZSBvZiB0aGUgbmV4dFxuICAgIC8vIHJlZHVjdGlvbilcbiAgICAvLy8gQGludGVybmFsXG4gICAgcmVkdWNlUG9zLCBcbiAgICAvLy8gVGhlIGlucHV0IHBvc2l0aW9uIHVwIHRvIHdoaWNoIHRoaXMgc3RhY2sgaGFzIHBhcnNlZC5cbiAgICBwb3MsIFxuICAgIC8vLyBUaGUgZHluYW1pYyBzY29yZSBvZiB0aGUgc3RhY2ssIGluY2x1ZGluZyBkeW5hbWljIHByZWNlZGVuY2VcbiAgICAvLy8gYW5kIGVycm9yLXJlY292ZXJ5IHBlbmFsdGllc1xuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzY29yZSwgXG4gICAgLy8gVGhlIG91dHB1dCBidWZmZXIuIEhvbGRzICh0eXBlLCBzdGFydCwgZW5kLCBzaXplKSBxdWFkc1xuICAgIC8vIHJlcHJlc2VudGluZyBub2RlcyBjcmVhdGVkIGJ5IHRoZSBwYXJzZXIsIHdoZXJlIGBzaXplYCBpc1xuICAgIC8vIGFtb3VudCBvZiBidWZmZXIgYXJyYXkgZW50cmllcyBjb3ZlcmVkIGJ5IHRoaXMgbm9kZS5cbiAgICAvLy8gQGludGVybmFsXG4gICAgYnVmZmVyLCBcbiAgICAvLyBUaGUgYmFzZSBvZmZzZXQgb2YgdGhlIGJ1ZmZlci4gV2hlbiBzdGFja3MgYXJlIHNwbGl0LCB0aGUgc3BsaXRcbiAgICAvLyBpbnN0YW5jZSBzaGFyZWQgdGhlIGJ1ZmZlciBoaXN0b3J5IHdpdGggaXRzIHBhcmVudCB1cCB0b1xuICAgIC8vIGBidWZmZXJCYXNlYCwgd2hpY2ggaXMgdGhlIGFic29sdXRlIG9mZnNldCAoaW5jbHVkaW5nIHRoZVxuICAgIC8vIG9mZnNldCBvZiBwcmV2aW91cyBzcGxpdHMpIGludG8gdGhlIGJ1ZmZlciBhdCB3aGljaCB0aGlzIHN0YWNrXG4gICAgLy8gc3RhcnRzIHdyaXRpbmcuXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGJ1ZmZlckJhc2UsIFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjdXJDb250ZXh0LCBcbiAgICAvLy8gQGludGVybmFsXG4gICAgbG9va0FoZWFkID0gMCwgXG4gICAgLy8gQSBwYXJlbnQgc3RhY2sgZnJvbSB3aGljaCB0aGlzIHdhcyBzcGxpdCBvZmYsIGlmIGFueS4gVGhpcyBpc1xuICAgIC8vIHNldCB1cCBzbyB0aGF0IGl0IGFsd2F5cyBwb2ludHMgdG8gYSBzdGFjayB0aGF0IGhhcyBzb21lXG4gICAgLy8gYWRkaXRpb25hbCBidWZmZXIgY29udGVudCwgbmV2ZXIgdG8gYSBzdGFjayB3aXRoIGFuIGVxdWFsXG4gICAgLy8gYGJ1ZmZlckJhc2VgLlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBwYXJlbnQpIHtcbiAgICAgICAgdGhpcy5wID0gcDtcbiAgICAgICAgdGhpcy5zdGFjayA9IHN0YWNrO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMucmVkdWNlUG9zID0gcmVkdWNlUG9zO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5zY29yZSA9IHNjb3JlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5idWZmZXJCYXNlID0gYnVmZmVyQmFzZTtcbiAgICAgICAgdGhpcy5jdXJDb250ZXh0ID0gY3VyQ29udGV4dDtcbiAgICAgICAgdGhpcy5sb29rQWhlYWQgPSBsb29rQWhlYWQ7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgWyR7dGhpcy5zdGFjay5maWx0ZXIoKF8sIGkpID0+IGkgJSAzID09IDApLmNvbmNhdCh0aGlzLnN0YXRlKX1dQCR7dGhpcy5wb3N9JHt0aGlzLnNjb3JlID8gXCIhXCIgKyB0aGlzLnNjb3JlIDogXCJcIn1gO1xuICAgIH1cbiAgICAvLyBTdGFydCBhbiBlbXB0eSBzdGFja1xuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzdGF0aWMgc3RhcnQocCwgc3RhdGUsIHBvcyA9IDApIHtcbiAgICAgICAgbGV0IGN4ID0gcC5wYXJzZXIuY29udGV4dDtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFjayhwLCBbXSwgc3RhdGUsIHBvcywgcG9zLCAwLCBbXSwgMCwgY3ggPyBuZXcgU3RhY2tDb250ZXh0KGN4LCBjeC5zdGFydCkgOiBudWxsLCAwLCBudWxsKTtcbiAgICB9XG4gICAgLy8vIFRoZSBzdGFjaydzIGN1cnJlbnQgW2NvbnRleHRdKCNsci5Db250ZXh0VHJhY2tlcikgdmFsdWUsIGlmXG4gICAgLy8vIGFueS4gSXRzIHR5cGUgd2lsbCBkZXBlbmQgb24gdGhlIGNvbnRleHQgdHJhY2tlcidzIHR5cGVcbiAgICAvLy8gcGFyYW1ldGVyLCBvciBpdCB3aWxsIGJlIGBudWxsYCBpZiB0aGVyZSBpcyBubyBjb250ZXh0XG4gICAgLy8vIHRyYWNrZXIuXG4gICAgZ2V0IGNvbnRleHQoKSB7IHJldHVybiB0aGlzLmN1ckNvbnRleHQgPyB0aGlzLmN1ckNvbnRleHQuY29udGV4dCA6IG51bGw7IH1cbiAgICAvLyBQdXNoIGEgc3RhdGUgb250byB0aGUgc3RhY2ssIHRyYWNraW5nIGl0cyBzdGFydCBwb3NpdGlvbiBhcyB3ZWxsXG4gICAgLy8gYXMgdGhlIGJ1ZmZlciBiYXNlIGF0IHRoYXQgcG9pbnQuXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHB1c2hTdGF0ZShzdGF0ZSwgc3RhcnQpIHtcbiAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMuc3RhdGUsIHN0YXJ0LCB0aGlzLmJ1ZmZlckJhc2UgKyB0aGlzLmJ1ZmZlci5sZW5ndGgpO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgfVxuICAgIC8vIEFwcGx5IGEgcmVkdWNlIGFjdGlvblxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICByZWR1Y2UoYWN0aW9uKSB7XG4gICAgICAgIGxldCBkZXB0aCA9IGFjdGlvbiA+PiAxOSAvKiBSZWR1Y2VEZXB0aFNoaWZ0ICovLCB0eXBlID0gYWN0aW9uICYgNjU1MzUgLyogVmFsdWVNYXNrICovO1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHRoaXMucDtcbiAgICAgICAgbGV0IGRQcmVjID0gcGFyc2VyLmR5bmFtaWNQcmVjZWRlbmNlKHR5cGUpO1xuICAgICAgICBpZiAoZFByZWMpXG4gICAgICAgICAgICB0aGlzLnNjb3JlICs9IGRQcmVjO1xuICAgICAgICBpZiAoZGVwdGggPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5wdXNoU3RhdGUocGFyc2VyLmdldEdvdG8odGhpcy5zdGF0ZSwgdHlwZSwgdHJ1ZSksIHRoaXMucmVkdWNlUG9zKTtcbiAgICAgICAgICAgIC8vIFplcm8tZGVwdGggcmVkdWN0aW9ucyBhcmUgYSBzcGVjaWFsIGNhc2XigJR0aGV5IGFkZCBzdHVmZiB0b1xuICAgICAgICAgICAgLy8gdGhlIHN0YWNrIHdpdGhvdXQgcG9wcGluZyBhbnl0aGluZyBvZmYuXG4gICAgICAgICAgICBpZiAodHlwZSA8IHBhcnNlci5taW5SZXBlYXRUZXJtKVxuICAgICAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKHR5cGUsIHRoaXMucmVkdWNlUG9zLCB0aGlzLnJlZHVjZVBvcywgNCwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnJlZHVjZUNvbnRleHQodHlwZSwgdGhpcy5yZWR1Y2VQb3MpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmQgdGhlIGJhc2UgaW5kZXggaW50byBgdGhpcy5zdGFja2AsIGNvbnRlbnQgYWZ0ZXIgd2hpY2ggd2lsbFxuICAgICAgICAvLyBiZSBkcm9wcGVkLiBOb3RlIHRoYXQgd2l0aCBgU3RheUZsYWdgIHJlZHVjdGlvbnMgd2UgbmVlZCB0b1xuICAgICAgICAvLyBjb25zdW1lIHR3byBleHRyYSBmcmFtZXMgKHRoZSBkdW1teSBwYXJlbnQgbm9kZSBmb3IgdGhlIHNraXBwZWRcbiAgICAgICAgLy8gZXhwcmVzc2lvbiBhbmQgdGhlIHN0YXRlIHRoYXQgd2UnbGwgYmUgc3RheWluZyBpbiwgd2hpY2ggc2hvdWxkXG4gICAgICAgIC8vIGJlIG1vdmVkIHRvIGB0aGlzLnN0YXRlYCkuXG4gICAgICAgIGxldCBiYXNlID0gdGhpcy5zdGFjay5sZW5ndGggLSAoKGRlcHRoIC0gMSkgKiAzKSAtIChhY3Rpb24gJiAyNjIxNDQgLyogU3RheUZsYWcgKi8gPyA2IDogMCk7XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMuc3RhY2tbYmFzZSAtIDJdO1xuICAgICAgICBsZXQgYnVmZmVyQmFzZSA9IHRoaXMuc3RhY2tbYmFzZSAtIDFdLCBjb3VudCA9IHRoaXMuYnVmZmVyQmFzZSArIHRoaXMuYnVmZmVyLmxlbmd0aCAtIGJ1ZmZlckJhc2U7XG4gICAgICAgIC8vIFN0b3JlIG5vcm1hbCB0ZXJtcyBvciBgUiAtPiBSIFJgIHJlcGVhdCByZWR1Y3Rpb25zXG4gICAgICAgIGlmICh0eXBlIDwgcGFyc2VyLm1pblJlcGVhdFRlcm0gfHwgKGFjdGlvbiAmIDEzMTA3MiAvKiBSZXBlYXRGbGFnICovKSkge1xuICAgICAgICAgICAgbGV0IHBvcyA9IHBhcnNlci5zdGF0ZUZsYWcodGhpcy5zdGF0ZSwgMSAvKiBTa2lwcGVkICovKSA/IHRoaXMucG9zIDogdGhpcy5yZWR1Y2VQb3M7XG4gICAgICAgICAgICB0aGlzLnN0b3JlTm9kZSh0eXBlLCBzdGFydCwgcG9zLCBjb3VudCArIDQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhY3Rpb24gJiAyNjIxNDQgLyogU3RheUZsYWcgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnN0YWNrW2Jhc2VdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGJhc2VTdGF0ZUlEID0gdGhpcy5zdGFja1tiYXNlIC0gM107XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gcGFyc2VyLmdldEdvdG8oYmFzZVN0YXRlSUQsIHR5cGUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLnN0YWNrLmxlbmd0aCA+IGJhc2UpXG4gICAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICB0aGlzLnJlZHVjZUNvbnRleHQodHlwZSwgc3RhcnQpO1xuICAgIH1cbiAgICAvLyBTaGlmdCBhIHZhbHVlIGludG8gdGhlIGJ1ZmZlclxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzdG9yZU5vZGUodGVybSwgc3RhcnQsIGVuZCwgc2l6ZSA9IDQsIGlzUmVkdWNlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRlcm0gPT0gMCAvKiBFcnIgKi8pIHsgLy8gVHJ5IHRvIG9taXQvbWVyZ2UgYWRqYWNlbnQgZXJyb3Igbm9kZXNcbiAgICAgICAgICAgIGxldCBjdXIgPSB0aGlzLCB0b3AgPSB0aGlzLmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodG9wID09IDAgJiYgY3VyLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHRvcCA9IGN1ci5idWZmZXJCYXNlIC0gY3VyLnBhcmVudC5idWZmZXJCYXNlO1xuICAgICAgICAgICAgICAgIGN1ciA9IGN1ci5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9wID4gMCAmJiBjdXIuYnVmZmVyW3RvcCAtIDRdID09IDAgLyogRXJyICovICYmIGN1ci5idWZmZXJbdG9wIC0gMV0gPiAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCA9PSBlbmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoY3VyLmJ1ZmZlclt0b3AgLSAyXSA+PSBzdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBjdXIuYnVmZmVyW3RvcCAtIDJdID0gZW5kO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaXNSZWR1Y2UgfHwgdGhpcy5wb3MgPT0gZW5kKSB7IC8vIFNpbXBsZSBjYXNlLCBqdXN0IGFwcGVuZFxuICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaCh0ZXJtLCBzdGFydCwgZW5kLCBzaXplKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gVGhlcmUgbWF5IGJlIHNraXBwZWQgbm9kZXMgdGhhdCBoYXZlIHRvIGJlIG1vdmVkIGZvcndhcmRcbiAgICAgICAgICAgIGxldCBpbmRleCA9IHRoaXMuYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IDAgJiYgdGhpcy5idWZmZXJbaW5kZXggLSA0XSAhPSAwIC8qIEVyciAqLylcbiAgICAgICAgICAgICAgICB3aGlsZSAoaW5kZXggPiAwICYmIHRoaXMuYnVmZmVyW2luZGV4IC0gMl0gPiBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSB0aGlzIHJlY29yZCBmb3J3YXJkXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4XSA9IHRoaXMuYnVmZmVyW2luZGV4IC0gNF07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgMV0gPSB0aGlzLmJ1ZmZlcltpbmRleCAtIDNdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDJdID0gdGhpcy5idWZmZXJbaW5kZXggLSAyXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAzXSA9IHRoaXMuYnVmZmVyW2luZGV4IC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGluZGV4IC09IDQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaXplID4gNClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemUgLT0gNDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleF0gPSB0ZXJtO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAxXSA9IHN0YXJ0O1xuICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAyXSA9IGVuZDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgM10gPSBzaXplO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEFwcGx5IGEgc2hpZnQgYWN0aW9uXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHNoaWZ0KGFjdGlvbiwgbmV4dCwgbmV4dEVuZCkge1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnBvcztcbiAgICAgICAgaWYgKGFjdGlvbiAmIDEzMTA3MiAvKiBHb3RvRmxhZyAqLykge1xuICAgICAgICAgICAgdGhpcy5wdXNoU3RhdGUoYWN0aW9uICYgNjU1MzUgLyogVmFsdWVNYXNrICovLCB0aGlzLnBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGFjdGlvbiAmIDI2MjE0NCAvKiBTdGF5RmxhZyAqLykgPT0gMCkgeyAvLyBSZWd1bGFyIHNoaWZ0XG4gICAgICAgICAgICBsZXQgbmV4dFN0YXRlID0gYWN0aW9uLCB7IHBhcnNlciB9ID0gdGhpcy5wO1xuICAgICAgICAgICAgaWYgKG5leHRFbmQgPiB0aGlzLnBvcyB8fCBuZXh0IDw9IHBhcnNlci5tYXhOb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSBuZXh0RW5kO1xuICAgICAgICAgICAgICAgIGlmICghcGFyc2VyLnN0YXRlRmxhZyhuZXh0U3RhdGUsIDEgLyogU2tpcHBlZCAqLykpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVkdWNlUG9zID0gbmV4dEVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHVzaFN0YXRlKG5leHRTdGF0ZSwgc3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5zaGlmdENvbnRleHQobmV4dCwgc3RhcnQpO1xuICAgICAgICAgICAgaWYgKG5leHQgPD0gcGFyc2VyLm1heE5vZGUpXG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaChuZXh0LCBzdGFydCwgbmV4dEVuZCwgNCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIFNoaWZ0LWFuZC1zdGF5LCB3aGljaCBtZWFucyB0aGlzIGlzIGEgc2tpcHBlZCB0b2tlblxuICAgICAgICAgICAgdGhpcy5wb3MgPSBuZXh0RW5kO1xuICAgICAgICAgICAgdGhpcy5zaGlmdENvbnRleHQobmV4dCwgc3RhcnQpO1xuICAgICAgICAgICAgaWYgKG5leHQgPD0gdGhpcy5wLnBhcnNlci5tYXhOb2RlKVxuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2gobmV4dCwgc3RhcnQsIG5leHRFbmQsIDQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEFwcGx5IGFuIGFjdGlvblxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBhcHBseShhY3Rpb24sIG5leHQsIG5leHRFbmQpIHtcbiAgICAgICAgaWYgKGFjdGlvbiAmIDY1NTM2IC8qIFJlZHVjZUZsYWcgKi8pXG4gICAgICAgICAgICB0aGlzLnJlZHVjZShhY3Rpb24pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnNoaWZ0KGFjdGlvbiwgbmV4dCwgbmV4dEVuZCk7XG4gICAgfVxuICAgIC8vIEFkZCBhIHByZWJ1aWx0IChyZXVzZWQpIG5vZGUgaW50byB0aGUgYnVmZmVyLlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB1c2VOb2RlKHZhbHVlLCBuZXh0KSB7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMucC5yZXVzZWQubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCB0aGlzLnAucmV1c2VkW2luZGV4XSAhPSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5wLnJldXNlZC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIHRoaXMucmVkdWNlUG9zID0gdGhpcy5wb3MgPSBzdGFydCArIHZhbHVlLmxlbmd0aDtcbiAgICAgICAgdGhpcy5wdXNoU3RhdGUobmV4dCwgc3RhcnQpO1xuICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKGluZGV4LCBzdGFydCwgdGhpcy5yZWR1Y2VQb3MsIC0xIC8qIHNpemUgPT0gLTEgbWVhbnMgdGhpcyBpcyBhIHJldXNlZCB2YWx1ZSAqLyk7XG4gICAgICAgIGlmICh0aGlzLmN1ckNvbnRleHQpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbnRleHQodGhpcy5jdXJDb250ZXh0LnRyYWNrZXIucmV1c2UodGhpcy5jdXJDb250ZXh0LmNvbnRleHQsIHZhbHVlLCB0aGlzLCB0aGlzLnAuc3RyZWFtLnJlc2V0KHRoaXMucG9zIC0gdmFsdWUubGVuZ3RoKSkpO1xuICAgIH1cbiAgICAvLyBTcGxpdCB0aGUgc3RhY2suIER1ZSB0byB0aGUgYnVmZmVyIHNoYXJpbmcgYW5kIHRoZSBmYWN0XG4gICAgLy8gdGhhdCBgdGhpcy5zdGFja2AgdGVuZHMgdG8gc3RheSBxdWl0ZSBzaGFsbG93LCB0aGlzIGlzbid0IHZlcnlcbiAgICAvLyBleHBlbnNpdmUuXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHNwbGl0KCkge1xuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcztcbiAgICAgICAgbGV0IG9mZiA9IHBhcmVudC5idWZmZXIubGVuZ3RoO1xuICAgICAgICAvLyBCZWNhdXNlIHRoZSB0b3Agb2YgdGhlIGJ1ZmZlciAoYWZ0ZXIgdGhpcy5wb3MpIG1heSBiZSBtdXRhdGVkXG4gICAgICAgIC8vIHRvIHJlb3JkZXIgcmVkdWN0aW9ucyBhbmQgc2tpcHBlZCB0b2tlbnMsIGFuZCBzaGFyZWQgYnVmZmVyc1xuICAgICAgICAvLyBzaG91bGQgYmUgaW1tdXRhYmxlLCB0aGlzIGNvcGllcyBhbnkgb3V0c3RhbmRpbmcgc2tpcHBlZCB0b2tlbnNcbiAgICAgICAgLy8gdG8gdGhlIG5ldyBidWZmZXIsIGFuZCBwdXRzIHRoZSBiYXNlIHBvaW50ZXIgYmVmb3JlIHRoZW0uXG4gICAgICAgIHdoaWxlIChvZmYgPiAwICYmIHBhcmVudC5idWZmZXJbb2ZmIC0gMl0gPiBwYXJlbnQucmVkdWNlUG9zKVxuICAgICAgICAgICAgb2ZmIC09IDQ7XG4gICAgICAgIGxldCBidWZmZXIgPSBwYXJlbnQuYnVmZmVyLnNsaWNlKG9mZiksIGJhc2UgPSBwYXJlbnQuYnVmZmVyQmFzZSArIG9mZjtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHBhcmVudCBwb2ludHMgdG8gYW4gYWN0dWFsIHBhcmVudCB3aXRoIGNvbnRlbnQsIGlmIHRoZXJlIGlzIHN1Y2ggYSBwYXJlbnQuXG4gICAgICAgIHdoaWxlIChwYXJlbnQgJiYgYmFzZSA9PSBwYXJlbnQuYnVmZmVyQmFzZSlcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgIHJldHVybiBuZXcgU3RhY2sodGhpcy5wLCB0aGlzLnN0YWNrLnNsaWNlKCksIHRoaXMuc3RhdGUsIHRoaXMucmVkdWNlUG9zLCB0aGlzLnBvcywgdGhpcy5zY29yZSwgYnVmZmVyLCBiYXNlLCB0aGlzLmN1ckNvbnRleHQsIHRoaXMubG9va0FoZWFkLCBwYXJlbnQpO1xuICAgIH1cbiAgICAvLyBUcnkgdG8gcmVjb3ZlciBmcm9tIGFuIGVycm9yIGJ5ICdkZWxldGluZycgKGlnbm9yaW5nKSBvbmUgdG9rZW4uXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHJlY292ZXJCeURlbGV0ZShuZXh0LCBuZXh0RW5kKSB7XG4gICAgICAgIGxldCBpc05vZGUgPSBuZXh0IDw9IHRoaXMucC5wYXJzZXIubWF4Tm9kZTtcbiAgICAgICAgaWYgKGlzTm9kZSlcbiAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKG5leHQsIHRoaXMucG9zLCBuZXh0RW5kLCA0KTtcbiAgICAgICAgdGhpcy5zdG9yZU5vZGUoMCAvKiBFcnIgKi8sIHRoaXMucG9zLCBuZXh0RW5kLCBpc05vZGUgPyA4IDogNCk7XG4gICAgICAgIHRoaXMucG9zID0gdGhpcy5yZWR1Y2VQb3MgPSBuZXh0RW5kO1xuICAgICAgICB0aGlzLnNjb3JlIC09IDE5MCAvKiBEZWxldGUgKi87XG4gICAgfVxuICAgIC8vLyBDaGVjayBpZiB0aGUgZ2l2ZW4gdGVybSB3b3VsZCBiZSBhYmxlIHRvIGJlIHNoaWZ0ZWQgKG9wdGlvbmFsbHlcbiAgICAvLy8gYWZ0ZXIgc29tZSByZWR1Y3Rpb25zKSBvbiB0aGlzIHN0YWNrLiBUaGlzIGNhbiBiZSB1c2VmdWwgZm9yXG4gICAgLy8vIGV4dGVybmFsIHRva2VuaXplcnMgdGhhdCB3YW50IHRvIG1ha2Ugc3VyZSB0aGV5IG9ubHkgcHJvdmlkZSBhXG4gICAgLy8vIGdpdmVuIHRva2VuIHdoZW4gaXQgYXBwbGllcy5cbiAgICBjYW5TaGlmdCh0ZXJtKSB7XG4gICAgICAgIGZvciAobGV0IHNpbSA9IG5ldyBTaW11bGF0ZWRTdGFjayh0aGlzKTs7KSB7XG4gICAgICAgICAgICBsZXQgYWN0aW9uID0gdGhpcy5wLnBhcnNlci5zdGF0ZVNsb3Qoc2ltLnN0YXRlLCA0IC8qIERlZmF1bHRSZWR1Y2UgKi8pIHx8IHRoaXMucC5wYXJzZXIuaGFzQWN0aW9uKHNpbS5zdGF0ZSwgdGVybSk7XG4gICAgICAgICAgICBpZiAoKGFjdGlvbiAmIDY1NTM2IC8qIFJlZHVjZUZsYWcgKi8pID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAoYWN0aW9uID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgc2ltLnJlZHVjZShhY3Rpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEFwcGx5IHVwIHRvIFJlY292ZXIuTWF4TmV4dCByZWNvdmVyeSBhY3Rpb25zIHRoYXQgY29uY2VwdHVhbGx5XG4gICAgLy8gaW5zZXJ0cyBzb21lIG1pc3NpbmcgdG9rZW4gb3IgcnVsZS5cbiAgICAvLy8gQGludGVybmFsXG4gICAgcmVjb3ZlckJ5SW5zZXJ0KG5leHQpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoID49IDMwMCAvKiBNYXhJbnNlcnRTdGFja0RlcHRoICovKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBsZXQgbmV4dFN0YXRlcyA9IHRoaXMucC5wYXJzZXIubmV4dFN0YXRlcyh0aGlzLnN0YXRlKTtcbiAgICAgICAgaWYgKG5leHRTdGF0ZXMubGVuZ3RoID4gNCAvKiBNYXhOZXh0ICovIDw8IDEgfHwgdGhpcy5zdGFjay5sZW5ndGggPj0gMTIwIC8qIERhbXBlbkluc2VydFN0YWNrRGVwdGggKi8pIHtcbiAgICAgICAgICAgIGxldCBiZXN0ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgczsgaSA8IG5leHRTdGF0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHMgPSBuZXh0U3RhdGVzW2kgKyAxXSkgIT0gdGhpcy5zdGF0ZSAmJiB0aGlzLnAucGFyc2VyLmhhc0FjdGlvbihzLCBuZXh0KSlcbiAgICAgICAgICAgICAgICAgICAgYmVzdC5wdXNoKG5leHRTdGF0ZXNbaV0sIHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoIDwgMTIwIC8qIERhbXBlbkluc2VydFN0YWNrRGVwdGggKi8pXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGJlc3QubGVuZ3RoIDwgNCAvKiBNYXhOZXh0ICovIDw8IDEgJiYgaSA8IG5leHRTdGF0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHMgPSBuZXh0U3RhdGVzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFiZXN0LnNvbWUoKHYsIGkpID0+IChpICYgMSkgJiYgdiA9PSBzKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3QucHVzaChuZXh0U3RhdGVzW2ldLCBzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0U3RhdGVzID0gYmVzdDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV4dFN0YXRlcy5sZW5ndGggJiYgcmVzdWx0Lmxlbmd0aCA8IDQgLyogTWF4TmV4dCAqLzsgaSArPSAyKSB7XG4gICAgICAgICAgICBsZXQgcyA9IG5leHRTdGF0ZXNbaSArIDFdO1xuICAgICAgICAgICAgaWYgKHMgPT0gdGhpcy5zdGF0ZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCBzdGFjayA9IHRoaXMuc3BsaXQoKTtcbiAgICAgICAgICAgIHN0YWNrLnN0b3JlTm9kZSgwIC8qIEVyciAqLywgc3RhY2sucG9zLCBzdGFjay5wb3MsIDQsIHRydWUpO1xuICAgICAgICAgICAgc3RhY2sucHVzaFN0YXRlKHMsIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHN0YWNrLnNoaWZ0Q29udGV4dChuZXh0U3RhdGVzW2ldLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICBzdGFjay5zY29yZSAtPSAyMDAgLyogSW5zZXJ0ICovO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIEZvcmNlIGEgcmVkdWNlLCBpZiBwb3NzaWJsZS4gUmV0dXJuIGZhbHNlIGlmIHRoYXQgY2FuJ3RcbiAgICAvLyBiZSBkb25lLlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBmb3JjZVJlZHVjZSgpIHtcbiAgICAgICAgbGV0IHJlZHVjZSA9IHRoaXMucC5wYXJzZXIuc3RhdGVTbG90KHRoaXMuc3RhdGUsIDUgLyogRm9yY2VkUmVkdWNlICovKTtcbiAgICAgICAgaWYgKChyZWR1Y2UgJiA2NTUzNiAvKiBSZWR1Y2VGbGFnICovKSA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHRoaXMucDtcbiAgICAgICAgaWYgKCFwYXJzZXIudmFsaWRBY3Rpb24odGhpcy5zdGF0ZSwgcmVkdWNlKSkge1xuICAgICAgICAgICAgbGV0IGRlcHRoID0gcmVkdWNlID4+IDE5IC8qIFJlZHVjZURlcHRoU2hpZnQgKi8sIHRlcm0gPSByZWR1Y2UgJiA2NTUzNSAvKiBWYWx1ZU1hc2sgKi87XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gdGhpcy5zdGFjay5sZW5ndGggLSBkZXB0aCAqIDM7XG4gICAgICAgICAgICBpZiAodGFyZ2V0IDwgMCB8fCBwYXJzZXIuZ2V0R290byh0aGlzLnN0YWNrW3RhcmdldF0sIHRlcm0sIGZhbHNlKSA8IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUoMCAvKiBFcnIgKi8sIHRoaXMucmVkdWNlUG9zLCB0aGlzLnJlZHVjZVBvcywgNCwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnNjb3JlIC09IDEwMCAvKiBSZWR1Y2UgKi87XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWR1Y2UocmVkdWNlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBmb3JjZUFsbCgpIHtcbiAgICAgICAgd2hpbGUgKCF0aGlzLnAucGFyc2VyLnN0YXRlRmxhZyh0aGlzLnN0YXRlLCAyIC8qIEFjY2VwdGluZyAqLykpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5mb3JjZVJlZHVjZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUoMCAvKiBFcnIgKi8sIHRoaXMucG9zLCB0aGlzLnBvcywgNCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vLyBDaGVjayB3aGV0aGVyIHRoaXMgc3RhdGUgaGFzIG5vIGZ1cnRoZXIgYWN0aW9ucyAoYXNzdW1lZCB0byBiZSBhIGRpcmVjdCBkZXNjZW5kYW50IG9mIHRoZVxuICAgIC8vLyB0b3Agc3RhdGUsIHNpbmNlIGFueSBvdGhlciBzdGF0ZXMgbXVzdCBiZSBhYmxlIHRvIGNvbnRpbnVlXG4gICAgLy8vIHNvbWVob3cpLiBAaW50ZXJuYWxcbiAgICBnZXQgZGVhZEVuZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoICE9IDMpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCB7IHBhcnNlciB9ID0gdGhpcy5wO1xuICAgICAgICByZXR1cm4gcGFyc2VyLmRhdGFbcGFyc2VyLnN0YXRlU2xvdCh0aGlzLnN0YXRlLCAxIC8qIEFjdGlvbnMgKi8pXSA9PSA2NTUzNSAvKiBFbmQgKi8gJiZcbiAgICAgICAgICAgICFwYXJzZXIuc3RhdGVTbG90KHRoaXMuc3RhdGUsIDQgLyogRGVmYXVsdFJlZHVjZSAqLyk7XG4gICAgfVxuICAgIC8vLyBSZXN0YXJ0IHRoZSBzdGFjayAocHV0IGl0IGJhY2sgaW4gaXRzIHN0YXJ0IHN0YXRlKS4gT25seSBzYWZlXG4gICAgLy8vIHdoZW4gdGhpcy5zdGFjay5sZW5ndGggPT0gMyAoc3RhdGUgaXMgZGlyZWN0bHkgYmVsb3cgdGhlIHRvcFxuICAgIC8vLyBzdGF0ZSkuIEBpbnRlcm5hbFxuICAgIHJlc3RhcnQoKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnN0YWNrWzBdO1xuICAgICAgICB0aGlzLnN0YWNrLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzYW1lU3RhdGUob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT0gb3RoZXIuc3RhdGUgfHwgdGhpcy5zdGFjay5sZW5ndGggIT0gb3RoZXIuc3RhY2subGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3RhY2subGVuZ3RoOyBpICs9IDMpXG4gICAgICAgICAgICBpZiAodGhpcy5zdGFja1tpXSAhPSBvdGhlci5zdGFja1tpXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLy8gR2V0IHRoZSBwYXJzZXIgdXNlZCBieSB0aGlzIHN0YWNrLlxuICAgIGdldCBwYXJzZXIoKSB7IHJldHVybiB0aGlzLnAucGFyc2VyOyB9XG4gICAgLy8vIFRlc3Qgd2hldGhlciBhIGdpdmVuIGRpYWxlY3QgKGJ5IG51bWVyaWMgSUQsIGFzIGV4cG9ydGVkIGZyb21cbiAgICAvLy8gdGhlIHRlcm1zIGZpbGUpIGlzIGVuYWJsZWQuXG4gICAgZGlhbGVjdEVuYWJsZWQoZGlhbGVjdElEKSB7IHJldHVybiB0aGlzLnAucGFyc2VyLmRpYWxlY3QuZmxhZ3NbZGlhbGVjdElEXTsgfVxuICAgIHNoaWZ0Q29udGV4dCh0ZXJtLCBzdGFydCkge1xuICAgICAgICBpZiAodGhpcy5jdXJDb250ZXh0KVxuICAgICAgICAgICAgdGhpcy51cGRhdGVDb250ZXh0KHRoaXMuY3VyQ29udGV4dC50cmFja2VyLnNoaWZ0KHRoaXMuY3VyQ29udGV4dC5jb250ZXh0LCB0ZXJtLCB0aGlzLCB0aGlzLnAuc3RyZWFtLnJlc2V0KHN0YXJ0KSkpO1xuICAgIH1cbiAgICByZWR1Y2VDb250ZXh0KHRlcm0sIHN0YXJ0KSB7XG4gICAgICAgIGlmICh0aGlzLmN1ckNvbnRleHQpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbnRleHQodGhpcy5jdXJDb250ZXh0LnRyYWNrZXIucmVkdWNlKHRoaXMuY3VyQ29udGV4dC5jb250ZXh0LCB0ZXJtLCB0aGlzLCB0aGlzLnAuc3RyZWFtLnJlc2V0KHN0YXJ0KSkpO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgZW1pdENvbnRleHQoKSB7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5idWZmZXIubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGxhc3QgPCAwIHx8IHRoaXMuYnVmZmVyW2xhc3RdICE9IC0zKVxuICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaCh0aGlzLmN1ckNvbnRleHQuaGFzaCwgdGhpcy5yZWR1Y2VQb3MsIHRoaXMucmVkdWNlUG9zLCAtMyk7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBlbWl0TG9va0FoZWFkKCkge1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMuYnVmZmVyLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChsYXN0IDwgMCB8fCB0aGlzLmJ1ZmZlcltsYXN0XSAhPSAtNClcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2godGhpcy5sb29rQWhlYWQsIHRoaXMucmVkdWNlUG9zLCB0aGlzLnJlZHVjZVBvcywgLTQpO1xuICAgIH1cbiAgICB1cGRhdGVDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgIT0gdGhpcy5jdXJDb250ZXh0LmNvbnRleHQpIHtcbiAgICAgICAgICAgIGxldCBuZXdDeCA9IG5ldyBTdGFja0NvbnRleHQodGhpcy5jdXJDb250ZXh0LnRyYWNrZXIsIGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKG5ld0N4Lmhhc2ggIT0gdGhpcy5jdXJDb250ZXh0Lmhhc2gpXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0Q29udGV4dCgpO1xuICAgICAgICAgICAgdGhpcy5jdXJDb250ZXh0ID0gbmV3Q3g7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHNldExvb2tBaGVhZChsb29rQWhlYWQpIHtcbiAgICAgICAgaWYgKGxvb2tBaGVhZCA+IHRoaXMubG9va0FoZWFkKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXRMb29rQWhlYWQoKTtcbiAgICAgICAgICAgIHRoaXMubG9va0FoZWFkID0gbG9va0FoZWFkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VyQ29udGV4dCAmJiB0aGlzLmN1ckNvbnRleHQudHJhY2tlci5zdHJpY3QpXG4gICAgICAgICAgICB0aGlzLmVtaXRDb250ZXh0KCk7XG4gICAgICAgIGlmICh0aGlzLmxvb2tBaGVhZCA+IDApXG4gICAgICAgICAgICB0aGlzLmVtaXRMb29rQWhlYWQoKTtcbiAgICB9XG59XG5jbGFzcyBTdGFja0NvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKHRyYWNrZXIsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy50cmFja2VyID0gdHJhY2tlcjtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5oYXNoID0gdHJhY2tlci5zdHJpY3QgPyB0cmFja2VyLmhhc2goY29udGV4dCkgOiAwO1xuICAgIH1cbn1cbnZhciBSZWNvdmVyO1xuKGZ1bmN0aW9uIChSZWNvdmVyKSB7XG4gICAgUmVjb3ZlcltSZWNvdmVyW1wiSW5zZXJ0XCJdID0gMjAwXSA9IFwiSW5zZXJ0XCI7XG4gICAgUmVjb3ZlcltSZWNvdmVyW1wiRGVsZXRlXCJdID0gMTkwXSA9IFwiRGVsZXRlXCI7XG4gICAgUmVjb3ZlcltSZWNvdmVyW1wiUmVkdWNlXCJdID0gMTAwXSA9IFwiUmVkdWNlXCI7XG4gICAgUmVjb3ZlcltSZWNvdmVyW1wiTWF4TmV4dFwiXSA9IDRdID0gXCJNYXhOZXh0XCI7XG4gICAgUmVjb3ZlcltSZWNvdmVyW1wiTWF4SW5zZXJ0U3RhY2tEZXB0aFwiXSA9IDMwMF0gPSBcIk1heEluc2VydFN0YWNrRGVwdGhcIjtcbiAgICBSZWNvdmVyW1JlY292ZXJbXCJEYW1wZW5JbnNlcnRTdGFja0RlcHRoXCJdID0gMTIwXSA9IFwiRGFtcGVuSW5zZXJ0U3RhY2tEZXB0aFwiO1xufSkoUmVjb3ZlciB8fCAoUmVjb3ZlciA9IHt9KSk7XG4vLyBVc2VkIHRvIGNoZWFwbHkgcnVuIHNvbWUgcmVkdWN0aW9ucyB0byBzY2FuIGFoZWFkIHdpdGhvdXQgbXV0YXRpbmdcbi8vIGFuIGVudGlyZSBzdGFja1xuY2xhc3MgU2ltdWxhdGVkU3RhY2sge1xuICAgIGNvbnN0cnVjdG9yKHN0YXJ0KSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXJ0LnN0YXRlO1xuICAgICAgICB0aGlzLnN0YWNrID0gc3RhcnQuc3RhY2s7XG4gICAgICAgIHRoaXMuYmFzZSA9IHRoaXMuc3RhY2subGVuZ3RoO1xuICAgIH1cbiAgICByZWR1Y2UoYWN0aW9uKSB7XG4gICAgICAgIGxldCB0ZXJtID0gYWN0aW9uICYgNjU1MzUgLyogVmFsdWVNYXNrICovLCBkZXB0aCA9IGFjdGlvbiA+PiAxOSAvKiBSZWR1Y2VEZXB0aFNoaWZ0ICovO1xuICAgICAgICBpZiAoZGVwdGggPT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhY2sgPT0gdGhpcy5zdGFydC5zdGFjaylcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrID0gdGhpcy5zdGFjay5zbGljZSgpO1xuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMuc3RhdGUsIDAsIDApO1xuICAgICAgICAgICAgdGhpcy5iYXNlICs9IDM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UgLT0gKGRlcHRoIC0gMSkgKiAzO1xuICAgICAgICB9XG4gICAgICAgIGxldCBnb3RvID0gdGhpcy5zdGFydC5wLnBhcnNlci5nZXRHb3RvKHRoaXMuc3RhY2tbdGhpcy5iYXNlIC0gM10sIHRlcm0sIHRydWUpO1xuICAgICAgICB0aGlzLnN0YXRlID0gZ290bztcbiAgICB9XG59XG4vLyBUaGlzIGlzIGdpdmVuIHRvIGBUcmVlLmJ1aWxkYCB0byBidWlsZCBhIGJ1ZmZlciwgYW5kIGVuY2Fwc3VsYXRlc1xuLy8gdGhlIHBhcmVudC1zdGFjay13YWxraW5nIG5lY2Vzc2FyeSB0byByZWFkIHRoZSBub2Rlcy5cbmNsYXNzIFN0YWNrQnVmZmVyQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihzdGFjaywgcG9zLCBpbmRleCkge1xuICAgICAgICB0aGlzLnN0YWNrID0gc3RhY2s7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gc3RhY2suYnVmZmVyO1xuICAgICAgICBpZiAodGhpcy5pbmRleCA9PSAwKVxuICAgICAgICAgICAgdGhpcy5tYXliZU5leHQoKTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShzdGFjaywgcG9zID0gc3RhY2suYnVmZmVyQmFzZSArIHN0YWNrLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFja0J1ZmZlckN1cnNvcihzdGFjaywgcG9zLCBwb3MgLSBzdGFjay5idWZmZXJCYXNlKTtcbiAgICB9XG4gICAgbWF5YmVOZXh0KCkge1xuICAgICAgICBsZXQgbmV4dCA9IHRoaXMuc3RhY2sucGFyZW50O1xuICAgICAgICBpZiAobmV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy5zdGFjay5idWZmZXJCYXNlIC0gbmV4dC5idWZmZXJCYXNlO1xuICAgICAgICAgICAgdGhpcy5zdGFjayA9IG5leHQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5leHQuYnVmZmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBpZCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSA0XTsgfVxuICAgIGdldCBzdGFydCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAzXTsgfVxuICAgIGdldCBlbmQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMl07IH1cbiAgICBnZXQgc2l6ZSgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAxXTsgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIHRoaXMuaW5kZXggLT0gNDtcbiAgICAgICAgdGhpcy5wb3MgLT0gNDtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPT0gMClcbiAgICAgICAgICAgIHRoaXMubWF5YmVOZXh0KCk7XG4gICAgfVxuICAgIGZvcmsoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RhY2tCdWZmZXJDdXJzb3IodGhpcy5zdGFjaywgdGhpcy5wb3MsIHRoaXMuaW5kZXgpO1xuICAgIH1cbn1cblxuY2xhc3MgQ2FjaGVkVG9rZW4ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gLTE7XG4gICAgICAgIHRoaXMudmFsdWUgPSAtMTtcbiAgICAgICAgdGhpcy5lbmQgPSAtMTtcbiAgICAgICAgdGhpcy5leHRlbmRlZCA9IC0xO1xuICAgICAgICB0aGlzLmxvb2tBaGVhZCA9IDA7XG4gICAgICAgIHRoaXMubWFzayA9IDA7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IDA7XG4gICAgfVxufVxuY29uc3QgbnVsbFRva2VuID0gbmV3IENhY2hlZFRva2VuO1xuLy8vIFtUb2tlbml6ZXJzXSgjbHIuRXh0ZXJuYWxUb2tlbml6ZXIpIGludGVyYWN0IHdpdGggdGhlIGlucHV0XG4vLy8gdGhyb3VnaCB0aGlzIGludGVyZmFjZS4gSXQgcHJlc2VudHMgdGhlIGlucHV0IGFzIGEgc3RyZWFtIG9mXG4vLy8gY2hhcmFjdGVycywgdHJhY2tpbmcgbG9va2FoZWFkIGFuZCBoaWRpbmcgdGhlIGNvbXBsZXhpdHkgb2Zcbi8vLyBbcmFuZ2VzXSgjY29tbW9uLlBhcnNlci5wYXJzZV5yYW5nZXMpIGZyb20gdG9rZW5pemVyIGNvZGUuXG5jbGFzcyBJbnB1dFN0cmVhbSB7XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBpbnB1dCwgXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHJhbmdlcykge1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICAvLy8gQGludGVybmFsXG4gICAgICAgIHRoaXMuY2h1bmsgPSBcIlwiO1xuICAgICAgICAvLy8gQGludGVybmFsXG4gICAgICAgIHRoaXMuY2h1bmtPZmYgPSAwO1xuICAgICAgICAvLy8gQmFja3VwIGNodW5rXG4gICAgICAgIHRoaXMuY2h1bmsyID0gXCJcIjtcbiAgICAgICAgdGhpcy5jaHVuazJQb3MgPSAwO1xuICAgICAgICAvLy8gVGhlIGNoYXJhY3RlciBjb2RlIG9mIHRoZSBuZXh0IGNvZGUgdW5pdCBpbiB0aGUgaW5wdXQsIG9yIC0xXG4gICAgICAgIC8vLyB3aGVuIHRoZSBzdHJlYW0gaXMgYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQuXG4gICAgICAgIHRoaXMubmV4dCA9IC0xO1xuICAgICAgICAvLy8gQGludGVybmFsXG4gICAgICAgIHRoaXMudG9rZW4gPSBudWxsVG9rZW47XG4gICAgICAgIHRoaXMucmFuZ2VJbmRleCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gdGhpcy5jaHVua1BvcyA9IHJhbmdlc1swXS5mcm9tO1xuICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2VzWzBdO1xuICAgICAgICB0aGlzLmVuZCA9IHJhbmdlc1tyYW5nZXMubGVuZ3RoIC0gMV0udG87XG4gICAgICAgIHRoaXMucmVhZE5leHQoKTtcbiAgICB9XG4gICAgcmVzb2x2ZU9mZnNldChvZmZzZXQsIGFzc29jKSB7XG4gICAgICAgIGxldCByYW5nZSA9IHRoaXMucmFuZ2UsIGluZGV4ID0gdGhpcy5yYW5nZUluZGV4O1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5wb3MgKyBvZmZzZXQ7XG4gICAgICAgIHdoaWxlIChwb3MgPCByYW5nZS5mcm9tKSB7XG4gICAgICAgICAgICBpZiAoIWluZGV4KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLnJhbmdlc1stLWluZGV4XTtcbiAgICAgICAgICAgIHBvcyAtPSByYW5nZS5mcm9tIC0gbmV4dC50bztcbiAgICAgICAgICAgIHJhbmdlID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoYXNzb2MgPCAwID8gcG9zID4gcmFuZ2UudG8gOiBwb3MgPj0gcmFuZ2UudG8pIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSB0aGlzLnJhbmdlcy5sZW5ndGggLSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLnJhbmdlc1srK2luZGV4XTtcbiAgICAgICAgICAgIHBvcyArPSBuZXh0LmZyb20gLSByYW5nZS50bztcbiAgICAgICAgICAgIHJhbmdlID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICAvLy8gTG9vayBhdCBhIGNvZGUgdW5pdCBuZWFyIHRoZSBzdHJlYW0gcG9zaXRpb24uIGAucGVlaygwKWAgZXF1YWxzXG4gICAgLy8vIGAubmV4dGAsIGAucGVlaygtMSlgIGdpdmVzIHlvdSB0aGUgcHJldmlvdXMgY2hhcmFjdGVyLCBhbmQgc29cbiAgICAvLy8gb24uXG4gICAgLy8vXG4gICAgLy8vIE5vdGUgdGhhdCBsb29raW5nIGFyb3VuZCBkdXJpbmcgdG9rZW5pemluZyBjcmVhdGVzIGRlcGVuZGVuY2llc1xuICAgIC8vLyBvbiBwb3RlbnRpYWxseSBmYXItYXdheSBjb250ZW50LCB3aGljaCBtYXkgcmVkdWNlIHRoZVxuICAgIC8vLyBlZmZlY3RpdmVuZXNzIGluY3JlbWVudGFsIHBhcnNpbmfigJR3aGVuIGxvb2tpbmcgZm9yd2FyZOKAlG9yIGV2ZW5cbiAgICAvLy8gY2F1c2UgaW52YWxpZCByZXBhcnNlcyB3aGVuIGxvb2tpbmcgYmFja3dhcmQgbW9yZSB0aGFuIDI1IGNvZGVcbiAgICAvLy8gdW5pdHMsIHNpbmNlIHRoZSBsaWJyYXJ5IGRvZXMgbm90IHRyYWNrIGxvb2tiZWhpbmQuXG4gICAgcGVlayhvZmZzZXQpIHtcbiAgICAgICAgbGV0IGlkeCA9IHRoaXMuY2h1bmtPZmYgKyBvZmZzZXQsIHBvcywgcmVzdWx0O1xuICAgICAgICBpZiAoaWR4ID49IDAgJiYgaWR4IDwgdGhpcy5jaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgIHBvcyA9IHRoaXMucG9zICsgb2Zmc2V0O1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jaHVuay5jaGFyQ29kZUF0KGlkeCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgcmVzb2x2ZWQgPSB0aGlzLnJlc29sdmVPZmZzZXQob2Zmc2V0LCAxKTtcbiAgICAgICAgICAgIGlmIChyZXNvbHZlZCA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIHBvcyA9IHJlc29sdmVkO1xuICAgICAgICAgICAgaWYgKHBvcyA+PSB0aGlzLmNodW5rMlBvcyAmJiBwb3MgPCB0aGlzLmNodW5rMlBvcyArIHRoaXMuY2h1bmsyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY2h1bmsyLmNoYXJDb2RlQXQocG9zIC0gdGhpcy5jaHVuazJQb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSB0aGlzLnJhbmdlSW5kZXgsIHJhbmdlID0gdGhpcy5yYW5nZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAocmFuZ2UudG8gPD0gcG9zKVxuICAgICAgICAgICAgICAgICAgICByYW5nZSA9IHRoaXMucmFuZ2VzWysraV07XG4gICAgICAgICAgICAgICAgdGhpcy5jaHVuazIgPSB0aGlzLmlucHV0LmNodW5rKHRoaXMuY2h1bmsyUG9zID0gcG9zKTtcbiAgICAgICAgICAgICAgICBpZiAocG9zICsgdGhpcy5jaHVuazIubGVuZ3RoID4gcmFuZ2UudG8pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2h1bmsyID0gdGhpcy5jaHVuazIuc2xpY2UoMCwgcmFuZ2UudG8gLSBwb3MpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY2h1bmsyLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyA+PSB0aGlzLnRva2VuLmxvb2tBaGVhZClcbiAgICAgICAgICAgIHRoaXMudG9rZW4ubG9va0FoZWFkID0gcG9zICsgMTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8vIEFjY2VwdCBhIHRva2VuLiBCeSBkZWZhdWx0LCB0aGUgZW5kIG9mIHRoZSB0b2tlbiBpcyBzZXQgdG8gdGhlXG4gICAgLy8vIGN1cnJlbnQgc3RyZWFtIHBvc2l0aW9uLCBidXQgeW91IGNhbiBwYXNzIGFuIG9mZnNldCAocmVsYXRpdmUgdG9cbiAgICAvLy8gdGhlIHN0cmVhbSBwb3NpdGlvbikgdG8gY2hhbmdlIHRoYXQuXG4gICAgYWNjZXB0VG9rZW4odG9rZW4sIGVuZE9mZnNldCA9IDApIHtcbiAgICAgICAgbGV0IGVuZCA9IGVuZE9mZnNldCA/IHRoaXMucmVzb2x2ZU9mZnNldChlbmRPZmZzZXQsIC0xKSA6IHRoaXMucG9zO1xuICAgICAgICBpZiAoZW5kID09IG51bGwgfHwgZW5kIDwgdGhpcy50b2tlbi5zdGFydClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVG9rZW4gZW5kIG91dCBvZiBib3VuZHNcIik7XG4gICAgICAgIHRoaXMudG9rZW4udmFsdWUgPSB0b2tlbjtcbiAgICAgICAgdGhpcy50b2tlbi5lbmQgPSBlbmQ7XG4gICAgfVxuICAgIGdldENodW5rKCkge1xuICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5jaHVuazJQb3MgJiYgdGhpcy5wb3MgPCB0aGlzLmNodW5rMlBvcyArIHRoaXMuY2h1bmsyLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHsgY2h1bmssIGNodW5rUG9zIH0gPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5jaHVuayA9IHRoaXMuY2h1bmsyO1xuICAgICAgICAgICAgdGhpcy5jaHVua1BvcyA9IHRoaXMuY2h1bmsyUG9zO1xuICAgICAgICAgICAgdGhpcy5jaHVuazIgPSBjaHVuaztcbiAgICAgICAgICAgIHRoaXMuY2h1bmsyUG9zID0gY2h1bmtQb3M7XG4gICAgICAgICAgICB0aGlzLmNodW5rT2ZmID0gdGhpcy5wb3MgLSB0aGlzLmNodW5rUG9zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaHVuazIgPSB0aGlzLmNodW5rO1xuICAgICAgICAgICAgdGhpcy5jaHVuazJQb3MgPSB0aGlzLmNodW5rUG9zO1xuICAgICAgICAgICAgbGV0IG5leHRDaHVuayA9IHRoaXMuaW5wdXQuY2h1bmsodGhpcy5wb3MpO1xuICAgICAgICAgICAgbGV0IGVuZCA9IHRoaXMucG9zICsgbmV4dENodW5rLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuY2h1bmsgPSBlbmQgPiB0aGlzLnJhbmdlLnRvID8gbmV4dENodW5rLnNsaWNlKDAsIHRoaXMucmFuZ2UudG8gLSB0aGlzLnBvcykgOiBuZXh0Q2h1bms7XG4gICAgICAgICAgICB0aGlzLmNodW5rUG9zID0gdGhpcy5wb3M7XG4gICAgICAgICAgICB0aGlzLmNodW5rT2ZmID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWFkTmV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2h1bmtPZmYgPj0gdGhpcy5jaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0Q2h1bmsoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNodW5rT2ZmID09IHRoaXMuY2h1bmsubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHQgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0ID0gdGhpcy5jaHVuay5jaGFyQ29kZUF0KHRoaXMuY2h1bmtPZmYpO1xuICAgIH1cbiAgICAvLy8gTW92ZSB0aGUgc3RyZWFtIGZvcndhcmQgTiAoZGVmYXVsdHMgdG8gMSkgY29kZSB1bml0cy4gUmV0dXJuc1xuICAgIC8vLyB0aGUgbmV3IHZhbHVlIG9mIFtgbmV4dGBdKCNsci5JbnB1dFN0cmVhbS5uZXh0KS5cbiAgICBhZHZhbmNlKG4gPSAxKSB7XG4gICAgICAgIHRoaXMuY2h1bmtPZmYgKz0gbjtcbiAgICAgICAgd2hpbGUgKHRoaXMucG9zICsgbiA+PSB0aGlzLnJhbmdlLnRvKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yYW5nZUluZGV4ID09IHRoaXMucmFuZ2VzLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0RG9uZSgpO1xuICAgICAgICAgICAgbiAtPSB0aGlzLnJhbmdlLnRvIC0gdGhpcy5wb3M7XG4gICAgICAgICAgICB0aGlzLnJhbmdlID0gdGhpcy5yYW5nZXNbKyt0aGlzLnJhbmdlSW5kZXhdO1xuICAgICAgICAgICAgdGhpcy5wb3MgPSB0aGlzLnJhbmdlLmZyb207XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3MgKz0gbjtcbiAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMudG9rZW4ubG9va0FoZWFkKVxuICAgICAgICAgICAgdGhpcy50b2tlbi5sb29rQWhlYWQgPSB0aGlzLnBvcyArIDE7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWROZXh0KCk7XG4gICAgfVxuICAgIHNldERvbmUoKSB7XG4gICAgICAgIHRoaXMucG9zID0gdGhpcy5jaHVua1BvcyA9IHRoaXMuZW5kO1xuICAgICAgICB0aGlzLnJhbmdlID0gdGhpcy5yYW5nZXNbdGhpcy5yYW5nZUluZGV4ID0gdGhpcy5yYW5nZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIHRoaXMuY2h1bmsgPSBcIlwiO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0ID0gLTE7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICByZXNldChwb3MsIHRva2VuKSB7XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgdG9rZW4uc3RhcnQgPSBwb3M7XG4gICAgICAgICAgICB0b2tlbi5sb29rQWhlYWQgPSBwb3MgKyAxO1xuICAgICAgICAgICAgdG9rZW4udmFsdWUgPSB0b2tlbi5leHRlbmRlZCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50b2tlbiA9IG51bGxUb2tlbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wb3MgIT0gcG9zKSB7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgICAgIGlmIChwb3MgPT0gdGhpcy5lbmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldERvbmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChwb3MgPCB0aGlzLnJhbmdlLmZyb20pXG4gICAgICAgICAgICAgICAgdGhpcy5yYW5nZSA9IHRoaXMucmFuZ2VzWy0tdGhpcy5yYW5nZUluZGV4XTtcbiAgICAgICAgICAgIHdoaWxlIChwb3MgPj0gdGhpcy5yYW5nZS50bylcbiAgICAgICAgICAgICAgICB0aGlzLnJhbmdlID0gdGhpcy5yYW5nZXNbKyt0aGlzLnJhbmdlSW5kZXhdO1xuICAgICAgICAgICAgaWYgKHBvcyA+PSB0aGlzLmNodW5rUG9zICYmIHBvcyA8IHRoaXMuY2h1bmtQb3MgKyB0aGlzLmNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2h1bmtPZmYgPSBwb3MgLSB0aGlzLmNodW5rUG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaHVuayA9IFwiXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5jaHVua09mZiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlYWROZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICByZWFkKGZyb20sIHRvKSB7XG4gICAgICAgIGlmIChmcm9tID49IHRoaXMuY2h1bmtQb3MgJiYgdG8gPD0gdGhpcy5jaHVua1BvcyArIHRoaXMuY2h1bmsubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2h1bmsuc2xpY2UoZnJvbSAtIHRoaXMuY2h1bmtQb3MsIHRvIC0gdGhpcy5jaHVua1Bvcyk7XG4gICAgICAgIGlmIChmcm9tID49IHRoaXMuY2h1bmsyUG9zICYmIHRvIDw9IHRoaXMuY2h1bmsyUG9zICsgdGhpcy5jaHVuazIubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2h1bmsyLnNsaWNlKGZyb20gLSB0aGlzLmNodW5rMlBvcywgdG8gLSB0aGlzLmNodW5rMlBvcyk7XG4gICAgICAgIGlmIChmcm9tID49IHRoaXMucmFuZ2UuZnJvbSAmJiB0byA8PSB0aGlzLnJhbmdlLnRvKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXQucmVhZChmcm9tLCB0byk7XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCByIG9mIHRoaXMucmFuZ2VzKSB7XG4gICAgICAgICAgICBpZiAoci5mcm9tID49IHRvKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHIudG8gPiBmcm9tKVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLmlucHV0LnJlYWQoTWF0aC5tYXgoci5mcm9tLCBmcm9tKSwgTWF0aC5taW4oci50bywgdG8pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8vLyBAaW50ZXJuYWxcbmNsYXNzIFRva2VuR3JvdXAge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEsIGlkKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICB9XG4gICAgdG9rZW4oaW5wdXQsIHN0YWNrKSB7IHJlYWRUb2tlbih0aGlzLmRhdGEsIGlucHV0LCBzdGFjaywgdGhpcy5pZCk7IH1cbn1cblRva2VuR3JvdXAucHJvdG90eXBlLmNvbnRleHR1YWwgPSBUb2tlbkdyb3VwLnByb3RvdHlwZS5mYWxsYmFjayA9IFRva2VuR3JvdXAucHJvdG90eXBlLmV4dGVuZCA9IGZhbHNlO1xuLy8vIGBAZXh0ZXJuYWwgdG9rZW5zYCBkZWNsYXJhdGlvbnMgaW4gdGhlIGdyYW1tYXIgc2hvdWxkIHJlc29sdmUgdG9cbi8vLyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuY2xhc3MgRXh0ZXJuYWxUb2tlbml6ZXIge1xuICAgIC8vLyBDcmVhdGUgYSB0b2tlbml6ZXIuIFRoZSBmaXJzdCBhcmd1bWVudCBpcyB0aGUgZnVuY3Rpb24gdGhhdCxcbiAgICAvLy8gZ2l2ZW4gYW4gaW5wdXQgc3RyZWFtLCBzY2FucyBmb3IgdGhlIHR5cGVzIG9mIHRva2VucyBpdFxuICAgIC8vLyByZWNvZ25pemVzIGF0IHRoZSBzdHJlYW0ncyBwb3NpdGlvbiwgYW5kIGNhbGxzXG4gICAgLy8vIFtgYWNjZXB0VG9rZW5gXSgjbHIuSW5wdXRTdHJlYW0uYWNjZXB0VG9rZW4pIHdoZW4gaXQgZmluZHNcbiAgICAvLy8gb25lLlxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB0b2tlbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5jb250ZXh0dWFsID0gISFvcHRpb25zLmNvbnRleHR1YWw7XG4gICAgICAgIHRoaXMuZmFsbGJhY2sgPSAhIW9wdGlvbnMuZmFsbGJhY2s7XG4gICAgICAgIHRoaXMuZXh0ZW5kID0gISFvcHRpb25zLmV4dGVuZDtcbiAgICB9XG59XG4vLyBUb2tlbml6ZXIgZGF0YSBpcyBzdG9yZWQgYSBiaWcgdWludDE2IGFycmF5IGNvbnRhaW5pbmcsIGZvciBlYWNoXG4vLyBzdGF0ZTpcbi8vXG4vLyAgLSBBIGdyb3VwIGJpdG1hc2ssIGluZGljYXRpbmcgd2hhdCB0b2tlbiBncm91cHMgYXJlIHJlYWNoYWJsZSBmcm9tXG4vLyAgICB0aGlzIHN0YXRlLCBzbyB0aGF0IHBhdGhzIHRoYXQgY2FuIG9ubHkgbGVhZCB0byB0b2tlbnMgbm90IGluXG4vLyAgICBhbnkgb2YgdGhlIGN1cnJlbnQgZ3JvdXBzIGNhbiBiZSBjdXQgb2ZmIGVhcmx5LlxuLy9cbi8vICAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgZW5kIG9mIHRoZSBzdGF0ZSdzIHNlcXVlbmNlIG9mIGFjY2VwdGluZ1xuLy8gICAgdG9rZW5zXG4vL1xuLy8gIC0gVGhlIG51bWJlciBvZiBvdXRnb2luZyBlZGdlcyBmb3IgdGhlIHN0YXRlXG4vL1xuLy8gIC0gVGhlIGFjY2VwdGluZyB0b2tlbnMsIGFzICh0b2tlbiBpZCwgZ3JvdXAgbWFzaykgcGFpcnNcbi8vXG4vLyAgLSBUaGUgb3V0Z29pbmcgZWRnZXMsIGFzIChzdGFydCBjaGFyYWN0ZXIsIGVuZCBjaGFyYWN0ZXIsIHN0YXRlXG4vLyAgICBpbmRleCkgdHJpcGxlcywgd2l0aCBlbmQgY2hhcmFjdGVyIGJlaW5nIGV4Y2x1c2l2ZVxuLy9cbi8vIFRoaXMgZnVuY3Rpb24gaW50ZXJwcmV0cyB0aGF0IGRhdGEsIHJ1bm5pbmcgdGhyb3VnaCBhIHN0cmVhbSBhc1xuLy8gbG9uZyBhcyBuZXcgc3RhdGVzIHdpdGggdGhlIGEgbWF0Y2hpbmcgZ3JvdXAgbWFzayBjYW4gYmUgcmVhY2hlZCxcbi8vIGFuZCB1cGRhdGluZyBgdG9rZW5gIHdoZW4gaXQgbWF0Y2hlcyBhIHRva2VuLlxuZnVuY3Rpb24gcmVhZFRva2VuKGRhdGEsIGlucHV0LCBzdGFjaywgZ3JvdXApIHtcbiAgICBsZXQgc3RhdGUgPSAwLCBncm91cE1hc2sgPSAxIDw8IGdyb3VwLCB7IHBhcnNlciB9ID0gc3RhY2sucCwgeyBkaWFsZWN0IH0gPSBwYXJzZXI7XG4gICAgc2NhbjogZm9yICg7Oykge1xuICAgICAgICBpZiAoKGdyb3VwTWFzayAmIGRhdGFbc3RhdGVdKSA9PSAwKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGxldCBhY2NFbmQgPSBkYXRhW3N0YXRlICsgMV07XG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhpcyBzdGF0ZSBjYW4gbGVhZCB0byBhIHRva2VuIGluIHRoZSBjdXJyZW50IGdyb3VwXG4gICAgICAgIC8vIEFjY2VwdCB0b2tlbnMgaW4gdGhpcyBzdGF0ZSwgcG9zc2libHkgb3ZlcndyaXRpbmdcbiAgICAgICAgLy8gbG93ZXItcHJlY2VkZW5jZSAvIHNob3J0ZXIgdG9rZW5zXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGF0ZSArIDM7IGkgPCBhY2NFbmQ7IGkgKz0gMilcbiAgICAgICAgICAgIGlmICgoZGF0YVtpICsgMV0gJiBncm91cE1hc2spID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCB0ZXJtID0gZGF0YVtpXTtcbiAgICAgICAgICAgICAgICBpZiAoZGlhbGVjdC5hbGxvd3ModGVybSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKGlucHV0LnRva2VuLnZhbHVlID09IC0xIHx8IGlucHV0LnRva2VuLnZhbHVlID09IHRlcm0gfHwgcGFyc2VyLm92ZXJyaWRlcyh0ZXJtLCBpbnB1dC50b2tlbi52YWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0LmFjY2VwdFRva2VuKHRlcm0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIC8vIERvIGEgYmluYXJ5IHNlYXJjaCBvbiB0aGUgc3RhdGUncyBlZGdlc1xuICAgICAgICBmb3IgKGxldCBuZXh0ID0gaW5wdXQubmV4dCwgbG93ID0gMCwgaGlnaCA9IGRhdGFbc3RhdGUgKyAyXTsgbG93IDwgaGlnaDspIHtcbiAgICAgICAgICAgIGxldCBtaWQgPSAobG93ICsgaGlnaCkgPj4gMTtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IGFjY0VuZCArIG1pZCArIChtaWQgPDwgMSk7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IGRhdGFbaW5kZXhdLCB0byA9IGRhdGFbaW5kZXggKyAxXTtcbiAgICAgICAgICAgIGlmIChuZXh0IDwgZnJvbSlcbiAgICAgICAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICAgICAgZWxzZSBpZiAobmV4dCA+PSB0bylcbiAgICAgICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBkYXRhW2luZGV4ICsgMl07XG4gICAgICAgICAgICAgICAgaW5wdXQuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlIHNjYW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxufVxuXG4vLyBTZWUgbGV6ZXItZ2VuZXJhdG9yL3NyYy9lbmNvZGUudHMgZm9yIGNvbW1lbnRzIGFib3V0IHRoZSBlbmNvZGluZ1xuLy8gdXNlZCBoZXJlXG5mdW5jdGlvbiBkZWNvZGVBcnJheShpbnB1dCwgVHlwZSA9IFVpbnQxNkFycmF5KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCAhPSBcInN0cmluZ1wiKVxuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgbGV0IGFycmF5ID0gbnVsbDtcbiAgICBmb3IgKGxldCBwb3MgPSAwLCBvdXQgPSAwOyBwb3MgPCBpbnB1dC5sZW5ndGg7KSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IDA7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdChwb3MrKyksIHN0b3AgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChuZXh0ID09IDEyNiAvKiBCaWdWYWxDb2RlICovKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSA2NTUzNSAvKiBCaWdWYWwgKi87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dCA+PSA5MiAvKiBHYXAyICovKVxuICAgICAgICAgICAgICAgIG5leHQtLTtcbiAgICAgICAgICAgIGlmIChuZXh0ID49IDM0IC8qIEdhcDEgKi8pXG4gICAgICAgICAgICAgICAgbmV4dC0tO1xuICAgICAgICAgICAgbGV0IGRpZ2l0ID0gbmV4dCAtIDMyIC8qIFN0YXJ0ICovO1xuICAgICAgICAgICAgaWYgKGRpZ2l0ID49IDQ2IC8qIEJhc2UgKi8pIHtcbiAgICAgICAgICAgICAgICBkaWdpdCAtPSA0NiAvKiBCYXNlICovO1xuICAgICAgICAgICAgICAgIHN0b3AgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgKz0gZGlnaXQ7XG4gICAgICAgICAgICBpZiAoc3RvcClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHZhbHVlICo9IDQ2IC8qIEJhc2UgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFycmF5KVxuICAgICAgICAgICAgYXJyYXlbb3V0KytdID0gdmFsdWU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGFycmF5ID0gbmV3IFR5cGUodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5cbi8vIEZJWE1FIGZpbmQgc29tZSB3YXkgdG8gcmVkdWNlIHJlY292ZXJ5IHdvcmsgZG9uZSB3aGVuIHRoZSBpbnB1dFxuLy8gZG9lc24ndCBtYXRjaCB0aGUgZ3JhbW1hciBhdCBhbGwuXG4vLyBFbnZpcm9ubWVudCB2YXJpYWJsZSB1c2VkIHRvIGNvbnRyb2wgY29uc29sZSBvdXRwdXRcbmNvbnN0IHZlcmJvc2UgPSB0eXBlb2YgcHJvY2VzcyAhPSBcInVuZGVmaW5lZFwiICYmIC9cXGJwYXJzZVxcYi8udGVzdChwcm9jZXNzLmVudi5MT0cpO1xubGV0IHN0YWNrSURzID0gbnVsbDtcbnZhciBTYWZldHk7XG4oZnVuY3Rpb24gKFNhZmV0eSkge1xuICAgIFNhZmV0eVtTYWZldHlbXCJNYXJnaW5cIl0gPSAyNV0gPSBcIk1hcmdpblwiO1xufSkoU2FmZXR5IHx8IChTYWZldHkgPSB7fSkpO1xuZnVuY3Rpb24gY3V0QXQodHJlZSwgcG9zLCBzaWRlKSB7XG4gICAgbGV0IGN1cnNvciA9IHRyZWUuZnVsbEN1cnNvcigpO1xuICAgIGN1cnNvci5tb3ZlVG8ocG9zKTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmICghKHNpZGUgPCAwID8gY3Vyc29yLmNoaWxkQmVmb3JlKHBvcykgOiBjdXJzb3IuY2hpbGRBZnRlcihwb3MpKSlcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBpZiAoKHNpZGUgPCAwID8gY3Vyc29yLnRvIDwgcG9zIDogY3Vyc29yLmZyb20gPiBwb3MpICYmICFjdXJzb3IudHlwZS5pc0Vycm9yKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lkZSA8IDAgPyBNYXRoLm1heCgwLCBNYXRoLm1pbihjdXJzb3IudG8gLSAxLCBwb3MgLSAyNSAvKiBNYXJnaW4gKi8pKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBNYXRoLm1pbih0cmVlLmxlbmd0aCwgTWF0aC5tYXgoY3Vyc29yLmZyb20gKyAxLCBwb3MgKyAyNSAvKiBNYXJnaW4gKi8pKTtcbiAgICAgICAgICAgICAgICBpZiAoc2lkZSA8IDAgPyBjdXJzb3IucHJldlNpYmxpbmcoKSA6IGN1cnNvci5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnNvci5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZGUgPCAwID8gMCA6IHRyZWUubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIEZyYWdtZW50Q3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudHMsIG5vZGVTZXQpIHtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHM7XG4gICAgICAgIHRoaXMubm9kZVNldCA9IG5vZGVTZXQ7XG4gICAgICAgIHRoaXMuaSA9IDA7XG4gICAgICAgIHRoaXMuZnJhZ21lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLnNhZmVGcm9tID0gLTE7XG4gICAgICAgIHRoaXMuc2FmZVRvID0gLTE7XG4gICAgICAgIHRoaXMudHJlZXMgPSBbXTtcbiAgICAgICAgdGhpcy5zdGFydCA9IFtdO1xuICAgICAgICB0aGlzLmluZGV4ID0gW107XG4gICAgICAgIHRoaXMubmV4dEZyYWdtZW50KCk7XG4gICAgfVxuICAgIG5leHRGcmFnbWVudCgpIHtcbiAgICAgICAgbGV0IGZyID0gdGhpcy5mcmFnbWVudCA9IHRoaXMuaSA9PSB0aGlzLmZyYWdtZW50cy5sZW5ndGggPyBudWxsIDogdGhpcy5mcmFnbWVudHNbdGhpcy5pKytdO1xuICAgICAgICBpZiAoZnIpIHtcbiAgICAgICAgICAgIHRoaXMuc2FmZUZyb20gPSBmci5vcGVuU3RhcnQgPyBjdXRBdChmci50cmVlLCBmci5mcm9tICsgZnIub2Zmc2V0LCAxKSAtIGZyLm9mZnNldCA6IGZyLmZyb207XG4gICAgICAgICAgICB0aGlzLnNhZmVUbyA9IGZyLm9wZW5FbmQgPyBjdXRBdChmci50cmVlLCBmci50byArIGZyLm9mZnNldCwgLTEpIC0gZnIub2Zmc2V0IDogZnIudG87XG4gICAgICAgICAgICB3aGlsZSAodGhpcy50cmVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyZWVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleC5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJlZXMucHVzaChmci50cmVlKTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQucHVzaCgtZnIub2Zmc2V0KTtcbiAgICAgICAgICAgIHRoaXMuaW5kZXgucHVzaCgwKTtcbiAgICAgICAgICAgIHRoaXMubmV4dFN0YXJ0ID0gdGhpcy5zYWZlRnJvbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubmV4dFN0YXJ0ID0gMWU5O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGBwb3NgIG11c3QgYmUgPj0gYW55IHByZXZpb3VzbHkgZ2l2ZW4gYHBvc2AgZm9yIHRoaXMgY3Vyc29yXG4gICAgbm9kZUF0KHBvcykge1xuICAgICAgICBpZiAocG9zIDwgdGhpcy5uZXh0U3RhcnQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgd2hpbGUgKHRoaXMuZnJhZ21lbnQgJiYgdGhpcy5zYWZlVG8gPD0gcG9zKVxuICAgICAgICAgICAgdGhpcy5uZXh0RnJhZ21lbnQoKTtcbiAgICAgICAgaWYgKCF0aGlzLmZyYWdtZW50KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBsYXN0ID0gdGhpcy50cmVlcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgaWYgKGxhc3QgPCAwKSB7IC8vIEVuZCBvZiB0cmVlXG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0RnJhZ21lbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0b3AgPSB0aGlzLnRyZWVzW2xhc3RdLCBpbmRleCA9IHRoaXMuaW5kZXhbbGFzdF07XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gdG9wLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJlZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydC5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4LnBvcCgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG5leHQgPSB0b3AuY2hpbGRyZW5baW5kZXhdO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5zdGFydFtsYXN0XSArIHRvcC5wb3NpdGlvbnNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0U3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgVHJlZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCA9PSBwb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0IDwgdGhpcy5zYWZlRnJvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZW5kID0gc3RhcnQgKyBuZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZCA8PSB0aGlzLnNhZmVUbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxvb2tBaGVhZCA9IG5leHQucHJvcChOb2RlUHJvcC5sb29rQWhlYWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsb29rQWhlYWQgfHwgZW5kICsgbG9va0FoZWFkIDwgdGhpcy5mcmFnbWVudC50bylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4W2xhc3RdKys7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ICsgbmV4dC5sZW5ndGggPj0gTWF0aC5tYXgodGhpcy5zYWZlRnJvbSwgcG9zKSkgeyAvLyBFbnRlciB0aGlzIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmVlcy5wdXNoKG5leHQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0LnB1c2goc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4LnB1c2goMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleFtsYXN0XSsrO1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dFN0YXJ0ID0gc3RhcnQgKyBuZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFRva2VuQ2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgc3RyZWFtKSB7XG4gICAgICAgIHRoaXMuc3RyZWFtID0gc3RyZWFtO1xuICAgICAgICB0aGlzLnRva2VucyA9IFtdO1xuICAgICAgICB0aGlzLm1haW5Ub2tlbiA9IG51bGw7XG4gICAgICAgIHRoaXMuYWN0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLnRva2VucyA9IHBhcnNlci50b2tlbml6ZXJzLm1hcChfID0+IG5ldyBDYWNoZWRUb2tlbik7XG4gICAgfVxuICAgIGdldEFjdGlvbnMoc3RhY2spIHtcbiAgICAgICAgbGV0IGFjdGlvbkluZGV4ID0gMDtcbiAgICAgICAgbGV0IG1haW4gPSBudWxsO1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHN0YWNrLnAsIHsgdG9rZW5pemVycyB9ID0gcGFyc2VyO1xuICAgICAgICBsZXQgbWFzayA9IHBhcnNlci5zdGF0ZVNsb3Qoc3RhY2suc3RhdGUsIDMgLyogVG9rZW5pemVyTWFzayAqLyk7XG4gICAgICAgIGxldCBjb250ZXh0ID0gc3RhY2suY3VyQ29udGV4dCA/IHN0YWNrLmN1ckNvbnRleHQuaGFzaCA6IDA7XG4gICAgICAgIGxldCBsb29rQWhlYWQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2VuaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICgoKDEgPDwgaSkgJiBtYXNrKSA9PSAwKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IHRva2VuaXplciA9IHRva2VuaXplcnNbaV0sIHRva2VuID0gdGhpcy50b2tlbnNbaV07XG4gICAgICAgICAgICBpZiAobWFpbiAmJiAhdG9rZW5pemVyLmZhbGxiYWNrKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHRva2VuaXplci5jb250ZXh0dWFsIHx8IHRva2VuLnN0YXJ0ICE9IHN0YWNrLnBvcyB8fCB0b2tlbi5tYXNrICE9IG1hc2sgfHwgdG9rZW4uY29udGV4dCAhPSBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDYWNoZWRUb2tlbih0b2tlbiwgdG9rZW5pemVyLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgdG9rZW4ubWFzayA9IG1hc2s7XG4gICAgICAgICAgICAgICAgdG9rZW4uY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9rZW4ubG9va0FoZWFkID4gdG9rZW4uZW5kICsgMjUgLyogTWFyZ2luICovKVxuICAgICAgICAgICAgICAgIGxvb2tBaGVhZCA9IE1hdGgubWF4KHRva2VuLmxvb2tBaGVhZCwgbG9va0FoZWFkKTtcbiAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSAhPSAwIC8qIEVyciAqLykge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydEluZGV4ID0gYWN0aW9uSW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLmV4dGVuZGVkID4gLTEpXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkluZGV4ID0gdGhpcy5hZGRBY3Rpb25zKHN0YWNrLCB0b2tlbi5leHRlbmRlZCwgdG9rZW4uZW5kLCBhY3Rpb25JbmRleCk7XG4gICAgICAgICAgICAgICAgYWN0aW9uSW5kZXggPSB0aGlzLmFkZEFjdGlvbnMoc3RhY2ssIHRva2VuLnZhbHVlLCB0b2tlbi5lbmQsIGFjdGlvbkluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoIXRva2VuaXplci5leHRlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uSW5kZXggPiBzdGFydEluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLmFjdGlvbnMubGVuZ3RoID4gYWN0aW9uSW5kZXgpXG4gICAgICAgICAgICB0aGlzLmFjdGlvbnMucG9wKCk7XG4gICAgICAgIGlmIChsb29rQWhlYWQpXG4gICAgICAgICAgICBzdGFjay5zZXRMb29rQWhlYWQobG9va0FoZWFkKTtcbiAgICAgICAgaWYgKCFtYWluICYmIHN0YWNrLnBvcyA9PSB0aGlzLnN0cmVhbS5lbmQpIHtcbiAgICAgICAgICAgIG1haW4gPSBuZXcgQ2FjaGVkVG9rZW47XG4gICAgICAgICAgICBtYWluLnZhbHVlID0gc3RhY2sucC5wYXJzZXIuZW9mVGVybTtcbiAgICAgICAgICAgIG1haW4uc3RhcnQgPSBtYWluLmVuZCA9IHN0YWNrLnBvcztcbiAgICAgICAgICAgIGFjdGlvbkluZGV4ID0gdGhpcy5hZGRBY3Rpb25zKHN0YWNrLCBtYWluLnZhbHVlLCBtYWluLmVuZCwgYWN0aW9uSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFpblRva2VuID0gbWFpbjtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aW9ucztcbiAgICB9XG4gICAgZ2V0TWFpblRva2VuKHN0YWNrKSB7XG4gICAgICAgIGlmICh0aGlzLm1haW5Ub2tlbilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1haW5Ub2tlbjtcbiAgICAgICAgbGV0IG1haW4gPSBuZXcgQ2FjaGVkVG9rZW4sIHsgcG9zLCBwIH0gPSBzdGFjaztcbiAgICAgICAgbWFpbi5zdGFydCA9IHBvcztcbiAgICAgICAgbWFpbi5lbmQgPSBNYXRoLm1pbihwb3MgKyAxLCBwLnN0cmVhbS5lbmQpO1xuICAgICAgICBtYWluLnZhbHVlID0gcG9zID09IHAuc3RyZWFtLmVuZCA/IHAucGFyc2VyLmVvZlRlcm0gOiAwIC8qIEVyciAqLztcbiAgICAgICAgcmV0dXJuIG1haW47XG4gICAgfVxuICAgIHVwZGF0ZUNhY2hlZFRva2VuKHRva2VuLCB0b2tlbml6ZXIsIHN0YWNrKSB7XG4gICAgICAgIHRva2VuaXplci50b2tlbih0aGlzLnN0cmVhbS5yZXNldChzdGFjay5wb3MsIHRva2VuKSwgc3RhY2spO1xuICAgICAgICBpZiAodG9rZW4udmFsdWUgPiAtMSkge1xuICAgICAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSBzdGFjay5wO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZXIuc3BlY2lhbGl6ZWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlci5zcGVjaWFsaXplZFtpXSA9PSB0b2tlbi52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gcGFyc2VyLnNwZWNpYWxpemVyc1tpXSh0aGlzLnN0cmVhbS5yZWFkKHRva2VuLnN0YXJ0LCB0b2tlbi5lbmQpLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPj0gMCAmJiBzdGFjay5wLnBhcnNlci5kaWFsZWN0LmFsbG93cyhyZXN1bHQgPj4gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocmVzdWx0ICYgMSkgPT0gMCAvKiBTcGVjaWFsaXplICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLnZhbHVlID0gcmVzdWx0ID4+IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4uZXh0ZW5kZWQgPSByZXN1bHQgPj4gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdG9rZW4udmFsdWUgPSAwIC8qIEVyciAqLztcbiAgICAgICAgICAgIHRva2VuLmVuZCA9IE1hdGgubWluKHN0YWNrLnAuc3RyZWFtLmVuZCwgc3RhY2sucG9zICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHV0QWN0aW9uKGFjdGlvbiwgdG9rZW4sIGVuZCwgaW5kZXgpIHtcbiAgICAgICAgLy8gRG9uJ3QgYWRkIGR1cGxpY2F0ZSBhY3Rpb25zXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXg7IGkgKz0gMylcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGlvbnNbaV0gPT0gYWN0aW9uKVxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgdGhpcy5hY3Rpb25zW2luZGV4KytdID0gYWN0aW9uO1xuICAgICAgICB0aGlzLmFjdGlvbnNbaW5kZXgrK10gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5hY3Rpb25zW2luZGV4KytdID0gZW5kO1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICAgIGFkZEFjdGlvbnMoc3RhY2ssIHRva2VuLCBlbmQsIGluZGV4KSB7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSBzdGFjaywgeyBwYXJzZXIgfSA9IHN0YWNrLnAsIHsgZGF0YSB9ID0gcGFyc2VyO1xuICAgICAgICBmb3IgKGxldCBzZXQgPSAwOyBzZXQgPCAyOyBzZXQrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHBhcnNlci5zdGF0ZVNsb3Qoc3RhdGUsIHNldCA/IDIgLyogU2tpcCAqLyA6IDEgLyogQWN0aW9ucyAqLyk7OyBpICs9IDMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVtpXSA9PSA2NTUzNSAvKiBFbmQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFbaSArIDFdID09IDEgLyogTmV4dCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IHBhaXIoZGF0YSwgaSArIDIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09IDAgJiYgZGF0YVtpICsgMV0gPT0gMiAvKiBPdGhlciAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMucHV0QWN0aW9uKHBhaXIoZGF0YSwgaSArIDIpLCB0b2tlbiwgZW5kLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGF0YVtpXSA9PSB0b2tlbilcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLnB1dEFjdGlvbihwYWlyKGRhdGEsIGkgKyAxKSwgdG9rZW4sIGVuZCwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG59XG52YXIgUmVjO1xuKGZ1bmN0aW9uIChSZWMpIHtcbiAgICBSZWNbUmVjW1wiRGlzdGFuY2VcIl0gPSA1XSA9IFwiRGlzdGFuY2VcIjtcbiAgICBSZWNbUmVjW1wiTWF4UmVtYWluaW5nUGVyU3RlcFwiXSA9IDNdID0gXCJNYXhSZW1haW5pbmdQZXJTdGVwXCI7XG4gICAgLy8gV2hlbiB0d28gc3RhY2tzIGhhdmUgYmVlbiBydW5uaW5nIGluZGVwZW5kZW50bHkgbG9uZyBlbm91Z2ggdG9cbiAgICAvLyBhZGQgdGhpcyBtYW55IGVsZW1lbnRzIHRvIHRoZWlyIGJ1ZmZlcnMsIHBydW5lIG9uZS5cbiAgICBSZWNbUmVjW1wiTWluQnVmZmVyTGVuZ3RoUHJ1bmVcIl0gPSA1MDBdID0gXCJNaW5CdWZmZXJMZW5ndGhQcnVuZVwiO1xuICAgIFJlY1tSZWNbXCJGb3JjZVJlZHVjZUxpbWl0XCJdID0gMTBdID0gXCJGb3JjZVJlZHVjZUxpbWl0XCI7XG4gICAgLy8gT25jZSBhIHN0YWNrIHJlYWNoZXMgdGhpcyBkZXB0aCAoaW4gLnN0YWNrLmxlbmd0aCkgZm9yY2UtcmVkdWNlXG4gICAgLy8gaXQgYmFjayB0byBDdXRUbyB0byBhdm9pZCBjcmVhdGluZyB0cmVlcyB0aGF0IG92ZXJmbG93IHRoZSBzdGFja1xuICAgIC8vIG9uIHJlY3Vyc2l2ZSB0cmF2ZXJzYWwuXG4gICAgUmVjW1JlY1tcIkN1dERlcHRoXCJdID0gMTUwMDBdID0gXCJDdXREZXB0aFwiO1xuICAgIFJlY1tSZWNbXCJDdXRUb1wiXSA9IDkwMDBdID0gXCJDdXRUb1wiO1xufSkoUmVjIHx8IChSZWMgPSB7fSkpO1xuY2xhc3MgUGFyc2Uge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICB0aGlzLnJlY292ZXJpbmcgPSAwO1xuICAgICAgICB0aGlzLm5leHRTdGFja0lEID0gMHgyNjU0OyAvLyDimZQsIOKZlSwg4pmWLCDimZcsIOKZmCwg4pmZLCDimaAsIOKZoSwg4pmiLCDimaMsIOKZpCwg4pmlLCDimaYsIOKZp1xuICAgICAgICB0aGlzLm1pblN0YWNrUG9zID0gMDtcbiAgICAgICAgdGhpcy5yZXVzZWQgPSBbXTtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBudWxsO1xuICAgICAgICB0aGlzLnN0cmVhbSA9IG5ldyBJbnB1dFN0cmVhbShpbnB1dCwgcmFuZ2VzKTtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBuZXcgVG9rZW5DYWNoZShwYXJzZXIsIHRoaXMuc3RyZWFtKTtcbiAgICAgICAgdGhpcy50b3BUZXJtID0gcGFyc2VyLnRvcFsxXTtcbiAgICAgICAgbGV0IHsgZnJvbSB9ID0gcmFuZ2VzWzBdO1xuICAgICAgICB0aGlzLnN0YWNrcyA9IFtTdGFjay5zdGFydCh0aGlzLCBwYXJzZXIudG9wWzBdLCBmcm9tKV07XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzLmxlbmd0aCAmJiB0aGlzLnN0cmVhbS5lbmQgLSBmcm9tID4gcGFyc2VyLmJ1ZmZlckxlbmd0aCAqIDRcbiAgICAgICAgICAgID8gbmV3IEZyYWdtZW50Q3Vyc29yKGZyYWdtZW50cywgcGFyc2VyLm5vZGVTZXQpIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IHBhcnNlZFBvcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluU3RhY2tQb3M7XG4gICAgfVxuICAgIC8vIE1vdmUgdGhlIHBhcnNlciBmb3J3YXJkLiBUaGlzIHdpbGwgcHJvY2VzcyBhbGwgcGFyc2Ugc3RhY2tzIGF0XG4gICAgLy8gYHRoaXMucG9zYCBhbmQgdHJ5IHRvIGFkdmFuY2UgdGhlbSB0byBhIGZ1cnRoZXIgcG9zaXRpb24uIElmIG5vXG4gICAgLy8gc3RhY2sgZm9yIHN1Y2ggYSBwb3NpdGlvbiBpcyBmb3VuZCwgaXQnbGwgc3RhcnQgZXJyb3ItcmVjb3ZlcnkuXG4gICAgLy9cbiAgICAvLyBXaGVuIHRoZSBwYXJzZSBpcyBmaW5pc2hlZCwgdGhpcyB3aWxsIHJldHVybiBhIHN5bnRheCB0cmVlLiBXaGVuXG4gICAgLy8gbm90LCBpdCByZXR1cm5zIGBudWxsYC5cbiAgICBhZHZhbmNlKCkge1xuICAgICAgICBsZXQgc3RhY2tzID0gdGhpcy5zdGFja3MsIHBvcyA9IHRoaXMubWluU3RhY2tQb3M7XG4gICAgICAgIC8vIFRoaXMgd2lsbCBob2xkIHN0YWNrcyBiZXlvbmQgYHBvc2AuXG4gICAgICAgIGxldCBuZXdTdGFja3MgPSB0aGlzLnN0YWNrcyA9IFtdO1xuICAgICAgICBsZXQgc3RvcHBlZCwgc3RvcHBlZFRva2VucztcbiAgICAgICAgLy8gS2VlcCBhZHZhbmNpbmcgYW55IHN0YWNrcyBhdCBgcG9zYCB1bnRpbCB0aGV5IGVpdGhlciBtb3ZlXG4gICAgICAgIC8vIGZvcndhcmQgb3IgY2FuJ3QgYmUgYWR2YW5jZWQuIEdhdGhlciBzdGFja3MgdGhhdCBjYW4ndCBiZVxuICAgICAgICAvLyBhZHZhbmNlZCBmdXJ0aGVyIGluIGBzdG9wcGVkYC5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdGFjayA9IHN0YWNrc1tpXTtcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRva2Vucy5tYWluVG9rZW4gPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChzdGFjay5wb3MgPiBwb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhY2tzLnB1c2goc3RhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmFkdmFuY2VTdGFjayhzdGFjaywgbmV3U3RhY2tzLCBzdGFja3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wcGVkID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wcGVkVG9rZW5zID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RvcHBlZC5wdXNoKHN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRvayA9IHRoaXMudG9rZW5zLmdldE1haW5Ub2tlbihzdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIHN0b3BwZWRUb2tlbnMucHVzaCh0b2sudmFsdWUsIHRvay5lbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5ld1N0YWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBmaW5pc2hlZCA9IHN0b3BwZWQgJiYgZmluZEZpbmlzaGVkKHN0b3BwZWQpO1xuICAgICAgICAgICAgaWYgKGZpbmlzaGVkKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YWNrVG9UcmVlKGZpbmlzaGVkKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcnNlci5zdHJpY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSAmJiBzdG9wcGVkKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlN0dWNrIHdpdGggdG9rZW4gXCIgKyAodGhpcy50b2tlbnMubWFpblRva2VuID8gdGhpcy5wYXJzZXIuZ2V0TmFtZSh0aGlzLnRva2Vucy5tYWluVG9rZW4udmFsdWUpIDogXCJub25lXCIpKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJObyBwYXJzZSBhdCBcIiArIHBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVjb3ZlcmluZylcbiAgICAgICAgICAgICAgICB0aGlzLnJlY292ZXJpbmcgPSA1IC8qIERpc3RhbmNlICovO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlY292ZXJpbmcgJiYgc3RvcHBlZCkge1xuICAgICAgICAgICAgbGV0IGZpbmlzaGVkID0gdGhpcy5zdG9wcGVkQXQgIT0gbnVsbCAmJiBzdG9wcGVkWzBdLnBvcyA+IHRoaXMuc3RvcHBlZEF0ID8gc3RvcHBlZFswXVxuICAgICAgICAgICAgICAgIDogdGhpcy5ydW5SZWNvdmVyeShzdG9wcGVkLCBzdG9wcGVkVG9rZW5zLCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgaWYgKGZpbmlzaGVkKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YWNrVG9UcmVlKGZpbmlzaGVkLmZvcmNlQWxsKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlY292ZXJpbmcpIHtcbiAgICAgICAgICAgIGxldCBtYXhSZW1haW5pbmcgPSB0aGlzLnJlY292ZXJpbmcgPT0gMSA/IDEgOiB0aGlzLnJlY292ZXJpbmcgKiAzIC8qIE1heFJlbWFpbmluZ1BlclN0ZXAgKi87XG4gICAgICAgICAgICBpZiAobmV3U3RhY2tzLmxlbmd0aCA+IG1heFJlbWFpbmluZykge1xuICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5zb3J0KChhLCBiKSA9PiBiLnNjb3JlIC0gYS5zY29yZSk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5ld1N0YWNrcy5sZW5ndGggPiBtYXhSZW1haW5pbmcpXG4gICAgICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdTdGFja3Muc29tZShzID0+IHMucmVkdWNlUG9zID4gcG9zKSlcbiAgICAgICAgICAgICAgICB0aGlzLnJlY292ZXJpbmctLTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuZXdTdGFja3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgLy8gUHJ1bmUgc3RhY2tzIHRoYXQgYXJlIGluIHRoZSBzYW1lIHN0YXRlLCBvciB0aGF0IGhhdmUgYmVlblxuICAgICAgICAgICAgLy8gcnVubmluZyB3aXRob3V0IHNwbGl0dGluZyBmb3IgYSB3aGlsZSwgdG8gYXZvaWQgZ2V0dGluZyBzdHVja1xuICAgICAgICAgICAgLy8gd2l0aCBtdWx0aXBsZSBzdWNjZXNzZnVsIHN0YWNrcyBydW5uaW5nIGVuZGxlc3NseSBvbi5cbiAgICAgICAgICAgIG91dGVyOiBmb3IgKGxldCBpID0gMDsgaSA8IG5ld1N0YWNrcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhY2sgPSBuZXdTdGFja3NbaV07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgbmV3U3RhY2tzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvdGhlciA9IG5ld1N0YWNrc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLnNhbWVTdGF0ZShvdGhlcikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLmJ1ZmZlci5sZW5ndGggPiA1MDAgLyogTWluQnVmZmVyTGVuZ3RoUHJ1bmUgKi8gJiYgb3RoZXIuYnVmZmVyLmxlbmd0aCA+IDUwMCAvKiBNaW5CdWZmZXJMZW5ndGhQcnVuZSAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgoc3RhY2suc2NvcmUgLSBvdGhlci5zY29yZSkgfHwgKHN0YWNrLmJ1ZmZlci5sZW5ndGggLSBvdGhlci5idWZmZXIubGVuZ3RoKSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3RhY2tzLnNwbGljZShqLS0sIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3RhY2tzLnNwbGljZShpLS0sIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubWluU3RhY2tQb3MgPSBuZXdTdGFja3NbMF0ucG9zO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG5ld1N0YWNrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChuZXdTdGFja3NbaV0ucG9zIDwgdGhpcy5taW5TdGFja1BvcylcbiAgICAgICAgICAgICAgICB0aGlzLm1pblN0YWNrUG9zID0gbmV3U3RhY2tzW2ldLnBvcztcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHN0b3BBdChwb3MpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RvcHBlZEF0ICE9IG51bGwgJiYgdGhpcy5zdG9wcGVkQXQgPCBwb3MpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNhbid0IG1vdmUgc3RvcHBlZEF0IGZvcndhcmRcIik7XG4gICAgICAgIHRoaXMuc3RvcHBlZEF0ID0gcG9zO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIGFuIHVwZGF0ZWQgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gc3RhY2ssIG9yIG51bGwgaWYgdGhlXG4gICAgLy8gc3RhY2sgY2FuJ3QgYWR2YW5jZSBub3JtYWxseS4gV2hlbiBgc3BsaXRgIGFuZCBgc3RhY2tzYCBhcmVcbiAgICAvLyBnaXZlbiwgc3RhY2tzIHNwbGl0IG9mZiBieSBhbWJpZ3VvdXMgb3BlcmF0aW9ucyB3aWxsIGJlIHB1c2hlZCB0b1xuICAgIC8vIGBzcGxpdGAsIG9yIGFkZGVkIHRvIGBzdGFja3NgIGlmIHRoZXkgbW92ZSBgcG9zYCBmb3J3YXJkLlxuICAgIGFkdmFuY2VTdGFjayhzdGFjaywgc3RhY2tzLCBzcGxpdCkge1xuICAgICAgICBsZXQgc3RhcnQgPSBzdGFjay5wb3MsIHsgcGFyc2VyIH0gPSB0aGlzO1xuICAgICAgICBsZXQgYmFzZSA9IHZlcmJvc2UgPyB0aGlzLnN0YWNrSUQoc3RhY2spICsgXCIgLT4gXCIgOiBcIlwiO1xuICAgICAgICBpZiAodGhpcy5zdG9wcGVkQXQgIT0gbnVsbCAmJiBzdGFydCA+IHRoaXMuc3RvcHBlZEF0KVxuICAgICAgICAgICAgcmV0dXJuIHN0YWNrLmZvcmNlUmVkdWNlKCkgPyBzdGFjayA6IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmZyYWdtZW50cykge1xuICAgICAgICAgICAgbGV0IHN0cmljdEN4ID0gc3RhY2suY3VyQ29udGV4dCAmJiBzdGFjay5jdXJDb250ZXh0LnRyYWNrZXIuc3RyaWN0LCBjeEhhc2ggPSBzdHJpY3RDeCA/IHN0YWNrLmN1ckNvbnRleHQuaGFzaCA6IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBjYWNoZWQgPSB0aGlzLmZyYWdtZW50cy5ub2RlQXQoc3RhcnQpOyBjYWNoZWQ7KSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hdGNoID0gdGhpcy5wYXJzZXIubm9kZVNldC50eXBlc1tjYWNoZWQudHlwZS5pZF0gPT0gY2FjaGVkLnR5cGUgPyBwYXJzZXIuZ2V0R290byhzdGFjay5zdGF0ZSwgY2FjaGVkLnR5cGUuaWQpIDogLTE7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoID4gLTEgJiYgY2FjaGVkLmxlbmd0aCAmJiAoIXN0cmljdEN4IHx8IChjYWNoZWQucHJvcChOb2RlUHJvcC5jb250ZXh0SGFzaCkgfHwgMCkgPT0gY3hIYXNoKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGFjay51c2VOb2RlKGNhY2hlZCwgbWF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoc3RhY2spICsgYCAodmlhIHJldXNlIG9mICR7cGFyc2VyLmdldE5hbWUoY2FjaGVkLnR5cGUuaWQpfSlgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghKGNhY2hlZCBpbnN0YW5jZW9mIFRyZWUpIHx8IGNhY2hlZC5jaGlsZHJlbi5sZW5ndGggPT0gMCB8fCBjYWNoZWQucG9zaXRpb25zWzBdID4gMClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgbGV0IGlubmVyID0gY2FjaGVkLmNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgICAgIGlmIChpbm5lciBpbnN0YW5jZW9mIFRyZWUgJiYgY2FjaGVkLnBvc2l0aW9uc1swXSA9PSAwKVxuICAgICAgICAgICAgICAgICAgICBjYWNoZWQgPSBpbm5lcjtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBkZWZhdWx0UmVkdWNlID0gcGFyc2VyLnN0YXRlU2xvdChzdGFjay5zdGF0ZSwgNCAvKiBEZWZhdWx0UmVkdWNlICovKTtcbiAgICAgICAgaWYgKGRlZmF1bHRSZWR1Y2UgPiAwKSB7XG4gICAgICAgICAgICBzdGFjay5yZWR1Y2UoZGVmYXVsdFJlZHVjZSk7XG4gICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKHN0YWNrKSArIGAgKHZpYSBhbHdheXMtcmVkdWNlICR7cGFyc2VyLmdldE5hbWUoZGVmYXVsdFJlZHVjZSAmIDY1NTM1IC8qIFZhbHVlTWFzayAqLyl9KWApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YWNrLnN0YWNrLmxlbmd0aCA+PSAxNTAwMCAvKiBDdXREZXB0aCAqLykge1xuICAgICAgICAgICAgd2hpbGUgKHN0YWNrLnN0YWNrLmxlbmd0aCA+IDkwMDAgLyogQ3V0VG8gKi8gJiYgc3RhY2suZm9yY2VSZWR1Y2UoKSkgeyB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFjdGlvbnMgPSB0aGlzLnRva2Vucy5nZXRBY3Rpb25zKHN0YWNrKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY3Rpb25zLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBhY3Rpb24gPSBhY3Rpb25zW2krK10sIHRlcm0gPSBhY3Rpb25zW2krK10sIGVuZCA9IGFjdGlvbnNbaSsrXTtcbiAgICAgICAgICAgIGxldCBsYXN0ID0gaSA9PSBhY3Rpb25zLmxlbmd0aCB8fCAhc3BsaXQ7XG4gICAgICAgICAgICBsZXQgbG9jYWxTdGFjayA9IGxhc3QgPyBzdGFjayA6IHN0YWNrLnNwbGl0KCk7XG4gICAgICAgICAgICBsb2NhbFN0YWNrLmFwcGx5KGFjdGlvbiwgdGVybSwgZW5kKTtcbiAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQobG9jYWxTdGFjaykgKyBgICh2aWEgJHsoYWN0aW9uICYgNjU1MzYgLyogUmVkdWNlRmxhZyAqLykgPT0gMCA/IFwic2hpZnRcIlxuICAgICAgICAgICAgICAgICAgICA6IGByZWR1Y2Ugb2YgJHtwYXJzZXIuZ2V0TmFtZShhY3Rpb24gJiA2NTUzNSAvKiBWYWx1ZU1hc2sgKi8pfWB9IGZvciAke3BhcnNlci5nZXROYW1lKHRlcm0pfSBAICR7c3RhcnR9JHtsb2NhbFN0YWNrID09IHN0YWNrID8gXCJcIiA6IFwiLCBzcGxpdFwifSlgKTtcbiAgICAgICAgICAgIGlmIChsYXN0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAobG9jYWxTdGFjay5wb3MgPiBzdGFydClcbiAgICAgICAgICAgICAgICBzdGFja3MucHVzaChsb2NhbFN0YWNrKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzcGxpdC5wdXNoKGxvY2FsU3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gQWR2YW5jZSBhIGdpdmVuIHN0YWNrIGZvcndhcmQgYXMgZmFyIGFzIGl0IHdpbGwgZ28uIFJldHVybnMgdGhlXG4gICAgLy8gKHBvc3NpYmx5IHVwZGF0ZWQpIHN0YWNrIGlmIGl0IGdvdCBzdHVjaywgb3IgbnVsbCBpZiBpdCBtb3ZlZFxuICAgIC8vIGZvcndhcmQgYW5kIHdhcyBnaXZlbiB0byBgcHVzaFN0YWNrRGVkdXBgLlxuICAgIGFkdmFuY2VGdWxseShzdGFjaywgbmV3U3RhY2tzKSB7XG4gICAgICAgIGxldCBwb3MgPSBzdGFjay5wb3M7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5hZHZhbmNlU3RhY2soc3RhY2ssIG51bGwsIG51bGwpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzdGFjay5wb3MgPiBwb3MpIHtcbiAgICAgICAgICAgICAgICBwdXNoU3RhY2tEZWR1cChzdGFjaywgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBydW5SZWNvdmVyeShzdGFja3MsIHRva2VucywgbmV3U3RhY2tzKSB7XG4gICAgICAgIGxldCBmaW5pc2hlZCA9IG51bGwsIHJlc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHN0YWNrID0gc3RhY2tzW2ldLCB0b2tlbiA9IHRva2Vuc1tpIDw8IDFdLCB0b2tlbkVuZCA9IHRva2Vuc1soaSA8PCAxKSArIDFdO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSB2ZXJib3NlID8gdGhpcy5zdGFja0lEKHN0YWNrKSArIFwiIC0+IFwiIDogXCJcIjtcbiAgICAgICAgICAgIGlmIChzdGFjay5kZWFkRW5kKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3RhcnRlZClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgcmVzdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGFjay5yZXN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoc3RhY2spICsgXCIgKHJlc3RhcnRlZClcIik7XG4gICAgICAgICAgICAgICAgbGV0IGRvbmUgPSB0aGlzLmFkdmFuY2VGdWxseShzdGFjaywgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZm9yY2UgPSBzdGFjay5zcGxpdCgpLCBmb3JjZUJhc2UgPSBiYXNlO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGZvcmNlLmZvcmNlUmVkdWNlKCkgJiYgaiA8IDEwIC8qIEZvcmNlUmVkdWNlTGltaXQgKi87IGorKykge1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhmb3JjZUJhc2UgKyB0aGlzLnN0YWNrSUQoZm9yY2UpICsgXCIgKHZpYSBmb3JjZS1yZWR1Y2UpXCIpO1xuICAgICAgICAgICAgICAgIGxldCBkb25lID0gdGhpcy5hZHZhbmNlRnVsbHkoZm9yY2UsIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBmb3JjZUJhc2UgPSB0aGlzLnN0YWNrSUQoZm9yY2UpICsgXCIgLT4gXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpbnNlcnQgb2Ygc3RhY2sucmVjb3ZlckJ5SW5zZXJ0KHRva2VuKSkge1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKGluc2VydCkgKyBcIiAodmlhIHJlY292ZXItaW5zZXJ0KVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2VGdWxseShpbnNlcnQsIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zdHJlYW0uZW5kID4gc3RhY2sucG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuRW5kID09IHN0YWNrLnBvcykge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbkVuZCsrO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IDAgLyogRXJyICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGFjay5yZWNvdmVyQnlEZWxldGUodG9rZW4sIHRva2VuRW5kKTtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChzdGFjaykgKyBgICh2aWEgcmVjb3Zlci1kZWxldGUgJHt0aGlzLnBhcnNlci5nZXROYW1lKHRva2VuKX0pYCk7XG4gICAgICAgICAgICAgICAgcHVzaFN0YWNrRGVkdXAoc3RhY2ssIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghZmluaXNoZWQgfHwgZmluaXNoZWQuc2NvcmUgPCBzdGFjay5zY29yZSkge1xuICAgICAgICAgICAgICAgIGZpbmlzaGVkID0gc3RhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbmlzaGVkO1xuICAgIH1cbiAgICAvLyBDb252ZXJ0IHRoZSBzdGFjaydzIGJ1ZmZlciB0byBhIHN5bnRheCB0cmVlLlxuICAgIHN0YWNrVG9UcmVlKHN0YWNrKSB7XG4gICAgICAgIHN0YWNrLmNsb3NlKCk7XG4gICAgICAgIHJldHVybiBUcmVlLmJ1aWxkKHsgYnVmZmVyOiBTdGFja0J1ZmZlckN1cnNvci5jcmVhdGUoc3RhY2spLFxuICAgICAgICAgICAgbm9kZVNldDogdGhpcy5wYXJzZXIubm9kZVNldCxcbiAgICAgICAgICAgIHRvcElEOiB0aGlzLnRvcFRlcm0sXG4gICAgICAgICAgICBtYXhCdWZmZXJMZW5ndGg6IHRoaXMucGFyc2VyLmJ1ZmZlckxlbmd0aCxcbiAgICAgICAgICAgIHJldXNlZDogdGhpcy5yZXVzZWQsXG4gICAgICAgICAgICBzdGFydDogdGhpcy5yYW5nZXNbMF0uZnJvbSxcbiAgICAgICAgICAgIGxlbmd0aDogc3RhY2sucG9zIC0gdGhpcy5yYW5nZXNbMF0uZnJvbSxcbiAgICAgICAgICAgIG1pblJlcGVhdFR5cGU6IHRoaXMucGFyc2VyLm1pblJlcGVhdFRlcm0gfSk7XG4gICAgfVxuICAgIHN0YWNrSUQoc3RhY2spIHtcbiAgICAgICAgbGV0IGlkID0gKHN0YWNrSURzIHx8IChzdGFja0lEcyA9IG5ldyBXZWFrTWFwKSkuZ2V0KHN0YWNrKTtcbiAgICAgICAgaWYgKCFpZClcbiAgICAgICAgICAgIHN0YWNrSURzLnNldChzdGFjaywgaWQgPSBTdHJpbmcuZnJvbUNvZGVQb2ludCh0aGlzLm5leHRTdGFja0lEKyspKTtcbiAgICAgICAgcmV0dXJuIGlkICsgc3RhY2s7XG4gICAgfVxufVxuZnVuY3Rpb24gcHVzaFN0YWNrRGVkdXAoc3RhY2ssIG5ld1N0YWNrcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3U3RhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBvdGhlciA9IG5ld1N0YWNrc1tpXTtcbiAgICAgICAgaWYgKG90aGVyLnBvcyA9PSBzdGFjay5wb3MgJiYgb3RoZXIuc2FtZVN0YXRlKHN0YWNrKSkge1xuICAgICAgICAgICAgaWYgKG5ld1N0YWNrc1tpXS5zY29yZSA8IHN0YWNrLnNjb3JlKVxuICAgICAgICAgICAgICAgIG5ld1N0YWNrc1tpXSA9IHN0YWNrO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5ld1N0YWNrcy5wdXNoKHN0YWNrKTtcbn1cbmNsYXNzIERpYWxlY3Qge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgZmxhZ3MsIGRpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICB9XG4gICAgYWxsb3dzKHRlcm0pIHsgcmV0dXJuICF0aGlzLmRpc2FibGVkIHx8IHRoaXMuZGlzYWJsZWRbdGVybV0gPT0gMDsgfVxufVxuY29uc3QgaWQgPSB4ID0+IHg7XG4vLy8gQ29udGV4dCB0cmFja2VycyBhcmUgdXNlZCB0byB0cmFjayBzdGF0ZWZ1bCBjb250ZXh0IChzdWNoIGFzXG4vLy8gaW5kZW50YXRpb24gaW4gdGhlIFB5dGhvbiBncmFtbWFyLCBvciBwYXJlbnQgZWxlbWVudHMgaW4gdGhlIFhNTFxuLy8vIGdyYW1tYXIpIG5lZWRlZCBieSBleHRlcm5hbCB0b2tlbml6ZXJzLiBZb3UgZGVjbGFyZSB0aGVtIGluIGFcbi8vLyBncmFtbWFyIGZpbGUgYXMgYEBjb250ZXh0IGV4cG9ydE5hbWUgZnJvbSBcIm1vZHVsZVwiYC5cbi8vL1xuLy8vIENvbnRleHQgdmFsdWVzIHNob3VsZCBiZSBpbW11dGFibGUsIGFuZCBjYW4gYmUgdXBkYXRlZCAocmVwbGFjZWQpXG4vLy8gb24gc2hpZnQgb3IgcmVkdWNlIGFjdGlvbnMuXG4vLy9cbi8vLyBUaGUgZXhwb3J0IHVzZWQgaW4gYSBgQGNvbnRleHRgIGRlY2xhcmF0aW9uIHNob3VsZCBiZSBvZiB0aGlzXG4vLy8gdHlwZS5cbmNsYXNzIENvbnRleHRUcmFja2VyIHtcbiAgICAvLy8gRGVmaW5lIGEgY29udGV4dCB0cmFja2VyLlxuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHNwZWMuc3RhcnQ7XG4gICAgICAgIHRoaXMuc2hpZnQgPSBzcGVjLnNoaWZ0IHx8IGlkO1xuICAgICAgICB0aGlzLnJlZHVjZSA9IHNwZWMucmVkdWNlIHx8IGlkO1xuICAgICAgICB0aGlzLnJldXNlID0gc3BlYy5yZXVzZSB8fCBpZDtcbiAgICAgICAgdGhpcy5oYXNoID0gc3BlYy5oYXNoIHx8ICgoKSA9PiAwKTtcbiAgICAgICAgdGhpcy5zdHJpY3QgPSBzcGVjLnN0cmljdCAhPT0gZmFsc2U7XG4gICAgfVxufVxuLy8vIEEgcGFyc2VyIGhvbGRzIHRoZSBwYXJzZSB0YWJsZXMgZm9yIGEgZ2l2ZW4gZ3JhbW1hciwgYXMgZ2VuZXJhdGVkXG4vLy8gYnkgYGxlemVyLWdlbmVyYXRvcmAuXG5jbGFzcyBMUlBhcnNlciBleHRlbmRzIFBhcnNlciB7XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8vIEBpbnRlcm5hbFxuICAgICAgICB0aGlzLndyYXBwZXJzID0gW107XG4gICAgICAgIGlmIChzcGVjLnZlcnNpb24gIT0gMTMgLyogVmVyc2lvbiAqLylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBQYXJzZXIgdmVyc2lvbiAoJHtzcGVjLnZlcnNpb259KSBkb2Vzbid0IG1hdGNoIHJ1bnRpbWUgdmVyc2lvbiAoJHsxMyAvKiBWZXJzaW9uICovfSlgKTtcbiAgICAgICAgbGV0IG5vZGVOYW1lcyA9IHNwZWMubm9kZU5hbWVzLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgdGhpcy5taW5SZXBlYXRUZXJtID0gbm9kZU5hbWVzLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGVjLnJlcGVhdE5vZGVDb3VudDsgaSsrKVxuICAgICAgICAgICAgbm9kZU5hbWVzLnB1c2goXCJcIik7XG4gICAgICAgIGxldCB0b3BUZXJtcyA9IE9iamVjdC5rZXlzKHNwZWMudG9wUnVsZXMpLm1hcChyID0+IHNwZWMudG9wUnVsZXNbcl1bMV0pO1xuICAgICAgICBsZXQgbm9kZVByb3BzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZU5hbWVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgbm9kZVByb3BzLnB1c2goW10pO1xuICAgICAgICBmdW5jdGlvbiBzZXRQcm9wKG5vZGVJRCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgICAgIG5vZGVQcm9wc1tub2RlSURdLnB1c2goW3Byb3AsIHByb3AuZGVzZXJpYWxpemUoU3RyaW5nKHZhbHVlKSldKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3BlYy5ub2RlUHJvcHMpXG4gICAgICAgICAgICBmb3IgKGxldCBwcm9wU3BlYyBvZiBzcGVjLm5vZGVQcm9wcykge1xuICAgICAgICAgICAgICAgIGxldCBwcm9wID0gcHJvcFNwZWNbMF07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwcm9wU3BlYy5sZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gcHJvcFNwZWNbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0UHJvcChuZXh0LCBwcm9wLCBwcm9wU3BlY1tpKytdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHByb3BTcGVjW2kgKyAtbmV4dF07XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gLW5leHQ7IGogPiAwOyBqLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0UHJvcChwcm9wU3BlY1tpKytdLCBwcm9wLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIHRoaXMubm9kZVNldCA9IG5ldyBOb2RlU2V0KG5vZGVOYW1lcy5tYXAoKG5hbWUsIGkpID0+IE5vZGVUeXBlLmRlZmluZSh7XG4gICAgICAgICAgICBuYW1lOiBpID49IHRoaXMubWluUmVwZWF0VGVybSA/IHVuZGVmaW5lZCA6IG5hbWUsXG4gICAgICAgICAgICBpZDogaSxcbiAgICAgICAgICAgIHByb3BzOiBub2RlUHJvcHNbaV0sXG4gICAgICAgICAgICB0b3A6IHRvcFRlcm1zLmluZGV4T2YoaSkgPiAtMSxcbiAgICAgICAgICAgIGVycm9yOiBpID09IDAsXG4gICAgICAgICAgICBza2lwcGVkOiBzcGVjLnNraXBwZWROb2RlcyAmJiBzcGVjLnNraXBwZWROb2Rlcy5pbmRleE9mKGkpID4gLTFcbiAgICAgICAgfSkpKTtcbiAgICAgICAgdGhpcy5zdHJpY3QgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5idWZmZXJMZW5ndGggPSBEZWZhdWx0QnVmZmVyTGVuZ3RoO1xuICAgICAgICBsZXQgdG9rZW5BcnJheSA9IGRlY29kZUFycmF5KHNwZWMudG9rZW5EYXRhKTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gc3BlYy5jb250ZXh0O1xuICAgICAgICB0aGlzLnNwZWNpYWxpemVkID0gbmV3IFVpbnQxNkFycmF5KHNwZWMuc3BlY2lhbGl6ZWQgPyBzcGVjLnNwZWNpYWxpemVkLmxlbmd0aCA6IDApO1xuICAgICAgICB0aGlzLnNwZWNpYWxpemVycyA9IFtdO1xuICAgICAgICBpZiAoc3BlYy5zcGVjaWFsaXplZClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3BlYy5zcGVjaWFsaXplZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3BlY2lhbGl6ZWRbaV0gPSBzcGVjLnNwZWNpYWxpemVkW2ldLnRlcm07XG4gICAgICAgICAgICAgICAgdGhpcy5zcGVjaWFsaXplcnNbaV0gPSBzcGVjLnNwZWNpYWxpemVkW2ldLmdldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZXMgPSBkZWNvZGVBcnJheShzcGVjLnN0YXRlcywgVWludDMyQXJyYXkpO1xuICAgICAgICB0aGlzLmRhdGEgPSBkZWNvZGVBcnJheShzcGVjLnN0YXRlRGF0YSk7XG4gICAgICAgIHRoaXMuZ290byA9IGRlY29kZUFycmF5KHNwZWMuZ290byk7XG4gICAgICAgIHRoaXMubWF4VGVybSA9IHNwZWMubWF4VGVybTtcbiAgICAgICAgdGhpcy50b2tlbml6ZXJzID0gc3BlYy50b2tlbml6ZXJzLm1hcCh2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIiA/IG5ldyBUb2tlbkdyb3VwKHRva2VuQXJyYXksIHZhbHVlKSA6IHZhbHVlKTtcbiAgICAgICAgdGhpcy50b3BSdWxlcyA9IHNwZWMudG9wUnVsZXM7XG4gICAgICAgIHRoaXMuZGlhbGVjdHMgPSBzcGVjLmRpYWxlY3RzIHx8IHt9O1xuICAgICAgICB0aGlzLmR5bmFtaWNQcmVjZWRlbmNlcyA9IHNwZWMuZHluYW1pY1ByZWNlZGVuY2VzIHx8IG51bGw7XG4gICAgICAgIHRoaXMudG9rZW5QcmVjVGFibGUgPSBzcGVjLnRva2VuUHJlYztcbiAgICAgICAgdGhpcy50ZXJtTmFtZXMgPSBzcGVjLnRlcm1OYW1lcyB8fCBudWxsO1xuICAgICAgICB0aGlzLm1heE5vZGUgPSB0aGlzLm5vZGVTZXQudHlwZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgdGhpcy5kaWFsZWN0ID0gdGhpcy5wYXJzZURpYWxlY3QoKTtcbiAgICAgICAgdGhpcy50b3AgPSB0aGlzLnRvcFJ1bGVzW09iamVjdC5rZXlzKHRoaXMudG9wUnVsZXMpWzBdXTtcbiAgICB9XG4gICAgY3JlYXRlUGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIGxldCBwYXJzZSA9IG5ldyBQYXJzZSh0aGlzLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xuICAgICAgICBmb3IgKGxldCB3IG9mIHRoaXMud3JhcHBlcnMpXG4gICAgICAgICAgICBwYXJzZSA9IHcocGFyc2UsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcyk7XG4gICAgICAgIHJldHVybiBwYXJzZTtcbiAgICB9XG4gICAgLy8vIEdldCBhIGdvdG8gdGFibGUgZW50cnkgQGludGVybmFsXG4gICAgZ2V0R290byhzdGF0ZSwgdGVybSwgbG9vc2UgPSBmYWxzZSkge1xuICAgICAgICBsZXQgdGFibGUgPSB0aGlzLmdvdG87XG4gICAgICAgIGlmICh0ZXJtID49IHRhYmxlWzBdKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSB0YWJsZVt0ZXJtICsgMV07Oykge1xuICAgICAgICAgICAgbGV0IGdyb3VwVGFnID0gdGFibGVbcG9zKytdLCBsYXN0ID0gZ3JvdXBUYWcgJiAxO1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IHRhYmxlW3BvcysrXTtcbiAgICAgICAgICAgIGlmIChsYXN0ICYmIGxvb3NlKVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgICBmb3IgKGxldCBlbmQgPSBwb3MgKyAoZ3JvdXBUYWcgPj4gMSk7IHBvcyA8IGVuZDsgcG9zKyspXG4gICAgICAgICAgICAgICAgaWYgKHRhYmxlW3Bvc10gPT0gc3RhdGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgICBpZiAobGFzdClcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIENoZWNrIGlmIHRoaXMgc3RhdGUgaGFzIGFuIGFjdGlvbiBmb3IgYSBnaXZlbiB0ZXJtaW5hbCBAaW50ZXJuYWxcbiAgICBoYXNBY3Rpb24oc3RhdGUsIHRlcm1pbmFsKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICBmb3IgKGxldCBzZXQgPSAwOyBzZXQgPCAyOyBzZXQrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc3RhdGVTbG90KHN0YXRlLCBzZXQgPyAyIC8qIFNraXAgKi8gOiAxIC8qIEFjdGlvbnMgKi8pLCBuZXh0OzsgaSArPSAzKSB7XG4gICAgICAgICAgICAgICAgaWYgKChuZXh0ID0gZGF0YVtpXSkgPT0gNjU1MzUgLyogRW5kICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhW2kgKyAxXSA9PSAxIC8qIE5leHQgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gZGF0YVtpID0gcGFpcihkYXRhLCBpICsgMildO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkYXRhW2kgKyAxXSA9PSAyIC8qIE90aGVyICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhaXIoZGF0YSwgaSArIDIpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgPT0gdGVybWluYWwgfHwgbmV4dCA9PSAwIC8qIEVyciAqLylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhaXIoZGF0YSwgaSArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgc3RhdGVTbG90KHN0YXRlLCBzbG90KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlc1soc3RhdGUgKiA2IC8qIFNpemUgKi8pICsgc2xvdF07XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzdGF0ZUZsYWcoc3RhdGUsIGZsYWcpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnN0YXRlU2xvdChzdGF0ZSwgMCAvKiBGbGFncyAqLykgJiBmbGFnKSA+IDA7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB2YWxpZEFjdGlvbihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgICAgIGlmIChhY3Rpb24gPT0gdGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIDQgLyogRGVmYXVsdFJlZHVjZSAqLykpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc3RhdGVTbG90KHN0YXRlLCAxIC8qIEFjdGlvbnMgKi8pOzsgaSArPSAzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhW2ldID09IDY1NTM1IC8qIEVuZCAqLykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbaSArIDFdID09IDEgLyogTmV4dCAqLylcbiAgICAgICAgICAgICAgICAgICAgaSA9IHBhaXIodGhpcy5kYXRhLCBpICsgMik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWN0aW9uID09IHBhaXIodGhpcy5kYXRhLCBpICsgMSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIEdldCB0aGUgc3RhdGVzIHRoYXQgY2FuIGZvbGxvdyB0aGlzIG9uZSB0aHJvdWdoIHNoaWZ0IGFjdGlvbnMgb3JcbiAgICAvLy8gZ290byBqdW1wcy4gQGludGVybmFsXG4gICAgbmV4dFN0YXRlcyhzdGF0ZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnN0YXRlU2xvdChzdGF0ZSwgMSAvKiBBY3Rpb25zICovKTs7IGkgKz0gMykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVtpXSA9PSA2NTUzNSAvKiBFbmQgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kYXRhW2kgKyAxXSA9PSAxIC8qIE5leHQgKi8pXG4gICAgICAgICAgICAgICAgICAgIGkgPSBwYWlyKHRoaXMuZGF0YSwgaSArIDIpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHRoaXMuZGF0YVtpICsgMl0gJiAoNjU1MzYgLyogUmVkdWNlRmxhZyAqLyA+PiAxNikpID09IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmRhdGFbaSArIDFdO1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0LnNvbWUoKHYsIGkpID0+IChpICYgMSkgJiYgdiA9PSB2YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZGF0YVtpXSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBvdmVycmlkZXModG9rZW4sIHByZXYpIHtcbiAgICAgICAgbGV0IGlQcmV2ID0gZmluZE9mZnNldCh0aGlzLmRhdGEsIHRoaXMudG9rZW5QcmVjVGFibGUsIHByZXYpO1xuICAgICAgICByZXR1cm4gaVByZXYgPCAwIHx8IGZpbmRPZmZzZXQodGhpcy5kYXRhLCB0aGlzLnRva2VuUHJlY1RhYmxlLCB0b2tlbikgPCBpUHJldjtcbiAgICB9XG4gICAgLy8vIENvbmZpZ3VyZSB0aGUgcGFyc2VyLiBSZXR1cm5zIGEgbmV3IHBhcnNlciBpbnN0YW5jZSB0aGF0IGhhcyB0aGVcbiAgICAvLy8gZ2l2ZW4gc2V0dGluZ3MgbW9kaWZpZWQuIFNldHRpbmdzIG5vdCBwcm92aWRlZCBpbiBgY29uZmlnYCBhcmVcbiAgICAvLy8ga2VwdCBmcm9tIHRoZSBvcmlnaW5hbCBwYXJzZXIuXG4gICAgY29uZmlndXJlKGNvbmZpZykge1xuICAgICAgICAvLyBIaWRlb3VzIHJlZmxlY3Rpb24tYmFzZWQga2x1ZGdlIHRvIG1ha2UgaXQgZWFzeSB0byBjcmVhdGUgYVxuICAgICAgICAvLyBzbGlnaHRseSBtb2RpZmllZCBjb3B5IG9mIGEgcGFyc2VyLlxuICAgICAgICBsZXQgY29weSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShMUlBhcnNlci5wcm90b3R5cGUpLCB0aGlzKTtcbiAgICAgICAgaWYgKGNvbmZpZy5wcm9wcylcbiAgICAgICAgICAgIGNvcHkubm9kZVNldCA9IHRoaXMubm9kZVNldC5leHRlbmQoLi4uY29uZmlnLnByb3BzKTtcbiAgICAgICAgaWYgKGNvbmZpZy50b3ApIHtcbiAgICAgICAgICAgIGxldCBpbmZvID0gdGhpcy50b3BSdWxlc1tjb25maWcudG9wXTtcbiAgICAgICAgICAgIGlmICghaW5mbylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCB0b3AgcnVsZSBuYW1lICR7Y29uZmlnLnRvcH1gKTtcbiAgICAgICAgICAgIGNvcHkudG9wID0gaW5mbztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLnRva2VuaXplcnMpXG4gICAgICAgICAgICBjb3B5LnRva2VuaXplcnMgPSB0aGlzLnRva2VuaXplcnMubWFwKHQgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGNvbmZpZy50b2tlbml6ZXJzLmZpbmQociA9PiByLmZyb20gPT0gdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kID8gZm91bmQudG8gOiB0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGlmIChjb25maWcuY29udGV4dFRyYWNrZXIpXG4gICAgICAgICAgICBjb3B5LmNvbnRleHQgPSBjb25maWcuY29udGV4dFRyYWNrZXI7XG4gICAgICAgIGlmIChjb25maWcuZGlhbGVjdClcbiAgICAgICAgICAgIGNvcHkuZGlhbGVjdCA9IHRoaXMucGFyc2VEaWFsZWN0KGNvbmZpZy5kaWFsZWN0KTtcbiAgICAgICAgaWYgKGNvbmZpZy5zdHJpY3QgIT0gbnVsbClcbiAgICAgICAgICAgIGNvcHkuc3RyaWN0ID0gY29uZmlnLnN0cmljdDtcbiAgICAgICAgaWYgKGNvbmZpZy53cmFwKVxuICAgICAgICAgICAgY29weS53cmFwcGVycyA9IGNvcHkud3JhcHBlcnMuY29uY2F0KGNvbmZpZy53cmFwKTtcbiAgICAgICAgaWYgKGNvbmZpZy5idWZmZXJMZW5ndGggIT0gbnVsbClcbiAgICAgICAgICAgIGNvcHkuYnVmZmVyTGVuZ3RoID0gY29uZmlnLmJ1ZmZlckxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuICAgIC8vLyBSZXR1cm5zIHRoZSBuYW1lIGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuIHRlcm0uIFRoaXMgd2lsbCBvbmx5XG4gICAgLy8vIHdvcmsgZm9yIGFsbCB0ZXJtcyB3aGVuIHRoZSBwYXJzZXIgd2FzIGdlbmVyYXRlZCB3aXRoIHRoZVxuICAgIC8vLyBgLS1uYW1lc2Agb3B0aW9uLiBCeSBkZWZhdWx0LCBvbmx5IHRoZSBuYW1lcyBvZiB0YWdnZWQgdGVybXMgYXJlXG4gICAgLy8vIHN0b3JlZC5cbiAgICBnZXROYW1lKHRlcm0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGVybU5hbWVzID8gdGhpcy50ZXJtTmFtZXNbdGVybV0gOiBTdHJpbmcodGVybSA8PSB0aGlzLm1heE5vZGUgJiYgdGhpcy5ub2RlU2V0LnR5cGVzW3Rlcm1dLm5hbWUgfHwgdGVybSk7XG4gICAgfVxuICAgIC8vLyBUaGUgZW9mIHRlcm0gaWQgaXMgYWx3YXlzIGFsbG9jYXRlZCBkaXJlY3RseSBhZnRlciB0aGUgbm9kZVxuICAgIC8vLyB0eXBlcy4gQGludGVybmFsXG4gICAgZ2V0IGVvZlRlcm0oKSB7IHJldHVybiB0aGlzLm1heE5vZGUgKyAxOyB9XG4gICAgLy8vIFRoZSB0eXBlIG9mIHRvcCBub2RlIHByb2R1Y2VkIGJ5IHRoZSBwYXJzZXIuXG4gICAgZ2V0IHRvcE5vZGUoKSB7IHJldHVybiB0aGlzLm5vZGVTZXQudHlwZXNbdGhpcy50b3BbMV1dOyB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGR5bmFtaWNQcmVjZWRlbmNlKHRlcm0pIHtcbiAgICAgICAgbGV0IHByZWMgPSB0aGlzLmR5bmFtaWNQcmVjZWRlbmNlcztcbiAgICAgICAgcmV0dXJuIHByZWMgPT0gbnVsbCA/IDAgOiBwcmVjW3Rlcm1dIHx8IDA7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBwYXJzZURpYWxlY3QoZGlhbGVjdCkge1xuICAgICAgICBsZXQgdmFsdWVzID0gT2JqZWN0LmtleXModGhpcy5kaWFsZWN0cyksIGZsYWdzID0gdmFsdWVzLm1hcCgoKSA9PiBmYWxzZSk7XG4gICAgICAgIGlmIChkaWFsZWN0KVxuICAgICAgICAgICAgZm9yIChsZXQgcGFydCBvZiBkaWFsZWN0LnNwbGl0KFwiIFwiKSkge1xuICAgICAgICAgICAgICAgIGxldCBpZCA9IHZhbHVlcy5pbmRleE9mKHBhcnQpO1xuICAgICAgICAgICAgICAgIGlmIChpZCA+PSAwKVxuICAgICAgICAgICAgICAgICAgICBmbGFnc1tpZF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICBsZXQgZGlzYWJsZWQgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghZmxhZ3NbaV0pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gdGhpcy5kaWFsZWN0c1t2YWx1ZXNbaV1dLCBpZDsgKGlkID0gdGhpcy5kYXRhW2orK10pICE9IDY1NTM1IC8qIEVuZCAqLzspXG4gICAgICAgICAgICAgICAgICAgIChkaXNhYmxlZCB8fCAoZGlzYWJsZWQgPSBuZXcgVWludDhBcnJheSh0aGlzLm1heFRlcm0gKyAxKSkpW2lkXSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRGlhbGVjdChkaWFsZWN0LCBmbGFncywgZGlzYWJsZWQpO1xuICAgIH1cbiAgICAvLy8gKHVzZWQgYnkgdGhlIG91dHB1dCBvZiB0aGUgcGFyc2VyIGdlbmVyYXRvcikgQGludGVybmFsXG4gICAgc3RhdGljIGRlc2VyaWFsaXplKHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMUlBhcnNlcihzcGVjKTtcbiAgICB9XG59XG5mdW5jdGlvbiBwYWlyKGRhdGEsIG9mZikgeyByZXR1cm4gZGF0YVtvZmZdIHwgKGRhdGFbb2ZmICsgMV0gPDwgMTYpOyB9XG5mdW5jdGlvbiBmaW5kT2Zmc2V0KGRhdGEsIHN0YXJ0LCB0ZXJtKSB7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0LCBuZXh0OyAobmV4dCA9IGRhdGFbaV0pICE9IDY1NTM1IC8qIEVuZCAqLzsgaSsrKVxuICAgICAgICBpZiAobmV4dCA9PSB0ZXJtKVxuICAgICAgICAgICAgcmV0dXJuIGkgLSBzdGFydDtcbiAgICByZXR1cm4gLTE7XG59XG5mdW5jdGlvbiBmaW5kRmluaXNoZWQoc3RhY2tzKSB7XG4gICAgbGV0IGJlc3QgPSBudWxsO1xuICAgIGZvciAobGV0IHN0YWNrIG9mIHN0YWNrcykge1xuICAgICAgICBsZXQgc3RvcHBlZCA9IHN0YWNrLnAuc3RvcHBlZEF0O1xuICAgICAgICBpZiAoKHN0YWNrLnBvcyA9PSBzdGFjay5wLnN0cmVhbS5lbmQgfHwgc3RvcHBlZCAhPSBudWxsICYmIHN0YWNrLnBvcyA+IHN0b3BwZWQpICYmXG4gICAgICAgICAgICBzdGFjay5wLnBhcnNlci5zdGF0ZUZsYWcoc3RhY2suc3RhdGUsIDIgLyogQWNjZXB0aW5nICovKSAmJlxuICAgICAgICAgICAgKCFiZXN0IHx8IGJlc3Quc2NvcmUgPCBzdGFjay5zY29yZSkpXG4gICAgICAgICAgICBiZXN0ID0gc3RhY2s7XG4gICAgfVxuICAgIHJldHVybiBiZXN0O1xufVxuXG5leHBvcnQgeyBDb250ZXh0VHJhY2tlciwgRXh0ZXJuYWxUb2tlbml6ZXIsIElucHV0U3RyZWFtLCBMUlBhcnNlciwgU3RhY2sgfTtcbiJdLCJuYW1lcyI6WyJMb2tpQW5ub3RhdGlvbnNRdWVyeUN0cmwiLCJjb25zdHJ1Y3RvciIsIiRzY29wZSIsImFubm90YXRpb24iLCJjdHJsIiwidGFyZ2V0Iiwib25RdWVyeUNoYW5nZSIsImJpbmQiLCJxdWVyeSIsImV4cHIiLCJtYXhMaW5lcyIsImluc3RhbnQiLCJjaGFpbiIsImlzRXF1YWwiLCJQUk9NX0tFWVdPUkRTIiwiT1BFUkFUT1JTIiwiTE9HSUNBTF9PUEVSQVRPUlMiLCJMT0tJX0tFWVdPUkRTIiwiYnVpbHRJbldvcmRzIiwibWV0cmljc0FuZEtleXdvcmRzUmVnZXhwIiwiYWRkTGFiZWxUb1F1ZXJ5Iiwia2V5IiwidmFsdWUiLCJvcGVyYXRvciIsImhhc05vTWV0cmljcyIsIkVycm9yIiwidHJhbnNmb3JtZWRWYWx1ZSIsIkluZmluaXR5IiwidG9TdHJpbmciLCJwcmV2aW91c1dvcmQiLCJyZXBsYWNlIiwibWF0Y2giLCJ3b3JkIiwib2Zmc2V0IiwiaXNNZXRyaWMiLCJpc1dvcmRNZXRyaWMiLCJzZWxlY3RvclJlZ2V4cCIsInBhcnRzIiwibGFzdEluZGV4Iiwic3VmZml4IiwiZXhlYyIsInByZWZpeCIsInNsaWNlIiwiaW5kZXgiLCJsZW5ndGgiLCJzdGFydHNXaXRoIiwicHVzaCIsInNlbGVjdG9yIiwic2VsZWN0b3JXaXRoTGFiZWwiLCJhZGRMYWJlbFRvU2VsZWN0b3IiLCJqb2luIiwibGFiZWxSZWdleHAiLCJsYWJlbEtleSIsImxhYmVsVmFsdWUiLCJsYWJlbE9wZXJhdG9yIiwicGFyc2VkTGFiZWxzIiwib3BlcmF0b3JGb3JMYWJlbEtleSIsImZvcm1hdHRlZCIsInVuaXFXaXRoIiwiY29tcGFjdCIsInNvcnRCeSIsIm1hcCIsImlzUG9zaXRpb25JbnNpZGVDaGFycyIsInRleHQiLCJwb3NpdGlvbiIsIm9wZW5DaGFyIiwiY2xvc2VDaGFyIiwibmV4dFNlbGVjdG9yU3RhcnQiLCJpbmRleE9mIiwibmV4dFNlbGVjdG9yRW5kIiwiaW5zaWRlU2VsZWN0b3IiLCJwcmV2aW91c1dvcmRJc0tleVdvcmQiLCJpc0NvbG9uQm91bmRlZCIsImVuZHNXaXRoIiwic3RhcnRzV2l0aFF1b3RlIiwiaXNUZW1wbGF0ZVZhcmlhYmxlIiwiaXNUaW1lVW5pdCIsImluY2x1ZGVzIiwiQm9vbGVhbiIsIk51bWJlciIsImlzRGF0YUZyYW1lIiwiRmllbGRUeXBlIiwiZ2V0RGVyaXZlZEZpZWxkcyIsIm1ha2VUYWJsZUZyYW1lcyIsImZvcm1hdFF1ZXJ5IiwiZ2V0SGlnaGxpZ2h0ZXJFeHByZXNzaW9uc0Zyb21RdWVyeSIsIkxva2lRdWVyeVR5cGUiLCJpc01ldHJpY0ZyYW1lIiwiZnJhbWUiLCJmaWVsZHMiLCJldmVyeSIsImZpZWxkIiwidHlwZSIsInRpbWUiLCJudW1iZXIiLCJzZXRGcmFtZU1ldGEiLCJtZXRhIiwib2xkTWV0YSIsInJlc3QiLCJuZXdNZXRhIiwicHJvY2Vzc1N0cmVhbUZyYW1lIiwiZGVyaXZlZEZpZWxkQ29uZmlncyIsInByZWZlcnJlZFZpc3VhbGlzYXRpb25UeXBlIiwibGltaXQiLCJzZWFyY2hXb3JkcyIsInVuZGVmaW5lZCIsImN1c3RvbSIsImxva2lRdWVyeVN0YXRLZXkiLCJuZXdGcmFtZSIsImRlcml2ZWRGaWVsZHMiLCJwcm9jZXNzU3RyZWFtc0ZyYW1lcyIsImZyYW1lcyIsInF1ZXJ5TWFwIiwicmVmSWQiLCJnZXQiLCJwcm9jZXNzTWV0cmljSW5zdGFudEZyYW1lcyIsInByb2Nlc3NNZXRyaWNSYW5nZUZyYW1lcyIsImdyb3VwRnJhbWVzIiwic3RyZWFtc0ZyYW1lcyIsIm1ldHJpY0luc3RhbnRGcmFtZXMiLCJtZXRyaWNSYW5nZUZyYW1lcyIsImZvckVhY2giLCJpc0luc3RhbnRGcmFtZSIsInF1ZXJ5VHlwZSIsIkluc3RhbnQiLCJ0cmFuc2Zvcm1CYWNrZW5kUmVzdWx0IiwicmVzcG9uc2UiLCJxdWVyaWVzIiwiZGF0YSIsImRhdGFGcmFtZXMiLCJkIiwiTWFwIiwic2h1ZmZsZSIsIlJlYWN0IiwiUHVyZUNvbXBvbmVudCIsIkRFRkFVTFRfRVhBTVBMRVMiLCJQUkVGRVJSRURfTEFCRUxTIiwiRVhBTVBMRVNfTElNSVQiLCJMT0dRTF9FWEFNUExFUyIsInRpdGxlIiwiZXhwcmVzc2lvbiIsImxhYmVsIiwiTG9raUNoZWF0U2hlZXQiLCJ1c2VyRXhhbXBsZXMiLCJwcm92aWRlciIsInByb3BzIiwiZGF0YXNvdXJjZSIsImxhbmd1YWdlUHJvdmlkZXIiLCJzdGFydGVkIiwibGFiZWxzIiwiZ2V0TGFiZWxLZXlzIiwicHJlZmVycmVkTGFiZWwiLCJmaW5kIiwibCIsInZhbHVlcyIsImdldExhYmVsVmFsdWVzIiwic2V0U3RhdGUiLCJzY2hlZHVsZVVzZXJMYWJlbENoZWNraW5nIiwiY29tcG9uZW50RGlkTW91bnQiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsImNsZWFyVGltZW91dCIsInVzZXJMYWJlbFRpbWVyIiwic2V0VGltZW91dCIsImNoZWNrVXNlckxhYmVscyIsInJlbmRlckV4cHJlc3Npb24iLCJvbkNsaWNrRXhhbXBsZSIsImUiLCJyZW5kZXIiLCJzdGF0ZSIsImhhc1VzZXJFeGFtcGxlcyIsImV4YW1wbGUiLCJpdGVtIiwibWVtbyIsIkxva2lPcHRpb25GaWVsZHMiLCJMb2tpUXVlcnlGaWVsZCIsIkxva2lFeHBsb3JlUXVlcnlFZGl0b3IiLCJoaXN0b3J5Iiwib25DaGFuZ2UiLCJvblJ1blF1ZXJ5IiwicmFuZ2UiLCJ0ZXN0SWRzIiwiZWRpdG9yIiwicmVzb2x1dGlvbiIsImRpc3BsYXlOYW1lIiwiY3NzIiwiY3giLCJGaXhlZFNpemVMaXN0IiwiQnV0dG9uIiwiSG9yaXpvbnRhbEdyb3VwIiwiSW5wdXQiLCJMYWJlbCIsIkxvYWRpbmdQbGFjZWhvbGRlciIsIndpdGhUaGVtZTIiLCJCcm93c2VyTGFiZWwiLCJMb2tpTGFiZWwiLCJmdXp6eU1hdGNoIiwiZXNjYXBlTGFiZWxWYWx1ZUluRXhhY3RTZWxlY3RvciIsImVzY2FwZUxhYmVsVmFsdWVJblJlZ2V4U2VsZWN0b3IiLCJNQVhfTEFCRUxfQ09VTlQiLCJNQVhfVkFMVUVfQ09VTlQiLCJNQVhfQVVUT19TRUxFQ1QiLCJFTVBUWV9TRUxFQ1RPUiIsImJ1aWxkU2VsZWN0b3IiLCJzZWxlY3RlZExhYmVscyIsInNlbGVjdGVkIiwic2VsZWN0ZWRWYWx1ZXMiLCJmaWx0ZXIiLCJuYW1lIiwiZmFjZXRMYWJlbHMiLCJwb3NzaWJsZUxhYmVscyIsImxhc3RGYWNldHRlZCIsInBvc3NpYmxlVmFsdWVzIiwiZXhpc3RpbmdWYWx1ZXMiLCJTZXQiLCJoYXMiLCJsb2FkaW5nIiwiZmFjZXRzIiwiaGlkZGVuIiwiZ2V0U3R5bGVzIiwidGhlbWUiLCJ3cmFwcGVyIiwiY29sb3JzIiwiYmFja2dyb3VuZCIsInNlY29uZGFyeSIsInNwYWNpbmciLCJsaXN0Iiwic2VjdGlvbiIsInR5cG9ncmFwaHkiLCJmb250RmFtaWx5TW9ub3NwYWNlIiwic3RhdHVzIiwic3RhdHVzU2hvd2luZyIsImVycm9yIiwibWFpbiIsInZhbHVlTGlzdCIsInZhbHVlTGlzdFdyYXBwZXIiLCJib3JkZXIiLCJtZWRpdW0iLCJ2YWx1ZUxpc3RBcmVhIiwidmFsdWVUaXRsZSIsInZhbGlkYXRpb25TdGF0dXMiLCJtYXhDb250cmFzdCIsIlVudGhlbWVkTG9raUxhYmVsQnJvd3NlciIsIkNvbXBvbmVudCIsInNlYXJjaFRlcm0iLCJldmVudCIsImRlbGV0ZUxhc3RVc2VkTGFiZWxzIiwibmV4dFZhbHVlIiwidXBkYXRlTGFiZWxTdGF0ZSIsImRvRmFjZXR0aW5nRm9yTGFiZWwiLCJ2IiwiZG9GYWNldHRpbmciLCJ2YWxpZGF0ZVNlbGVjdG9yIiwiZmV0Y2hWYWx1ZXMiLCJmZXRjaFNlcmllcyIsInVwZGF0ZWRGaWVsZHMiLCJjYiIsImF1dG9TZWxlY3QiLCJsYXN0VXNlZExhYmVscyIsInN0YXJ0IiwidGhlbiIsInJhd0xhYmVscyIsImkiLCJhcnIiLCJzdG9yZUxhc3RVc2VkTGFiZWxzIiwicmF3VmFsdWVzIiwiY29uc29sZSIsImZldGNoU2VyaWVzTGFiZWxzIiwiT2JqZWN0Iiwia2V5cyIsInN0cmVhbXMiLCJzdHlsZXMiLCJlbXB0eSIsInNlYXJjaFJlc3VsdHMiLCJoaWdobGlnaHRQYXJ0cyIsImZ1enp5TWF0Y2hSZXN1bHQiLCJ0b0xvd2VyQ2FzZSIsImZvdW5kIiwicmFuZ2VzIiwib3JkZXIiLCJkaXN0YW5jZSIsIm9uQ2xpY2tMYWJlbCIsIm9uQ2hhbmdlU2VhcmNoIiwic3R5bGUiLCJvbkNsaWNrVmFsdWUiLCJvbkNsaWNrUnVuTG9nc1F1ZXJ5Iiwib25DbGlja1J1bk1ldHJpY3NRdWVyeSIsIm9uQ2xpY2tWYWxpZGF0ZSIsIm9uQ2xpY2tDbGVhciIsIkxva2lMYWJlbEJyb3dzZXIiLCJjb25maWciLCJJbmxpbmVGb3JtTGFiZWwiLCJSYWRpb0J1dHRvbkdyb3VwIiwiSW5saW5lRmllbGQiLCJTZWxlY3QiLCJxdWVyeVR5cGVPcHRpb25zIiwiUmFuZ2UiLCJkZXNjcmlwdGlvbiIsImZlYXR1cmVUb2dnbGVzIiwibG9raUxpdmUiLCJTdHJlYW0iLCJERUZBVUxUX1JFU09MVVRJT04iLCJSRVNPTFVUSU9OX09QVElPTlMiLCJjb25jYXQiLCJsaW5lTGltaXRWYWx1ZSIsInJ1bk9uQmx1ciIsIm9uQ2hhbmdlUXVlcnlMaW1pdCIsIm5leHRRdWVyeSIsInByZXByb2Nlc3NNYXhMaW5lcyIsIm9uUXVlcnlUeXBlQ2hhbmdlIiwib25NYXhMaW5lc0NoYW5nZSIsImN1cnJlbnRUYXJnZXQiLCJvblJldHVybktleURvd24iLCJvblJlc29sdXRpb25DaGFuZ2UiLCJvcHRpb24iLCJOYU4iLCJpc05hTiIsIkxva2lRdWVyeUVkaXRvciIsIm9uTGVnZW5kQ2hhbmdlIiwibGVnZW5kRm9ybWF0IiwibGVnZW5kRmllbGQiLCJDb3JlQXBwIiwiTG9raVF1ZXJ5RWRpdG9yU2VsZWN0b3IiLCJMb2tpUXVlcnlFZGl0b3JGb3JBbGVydGluZyIsIkxva2lRdWVyeUVkaXRvckJ5QXBwIiwiYXBwIiwiQ2xvdWRBbGVydGluZyIsIkV4cGxvcmUiLCJsb2tpUXVlcnlCdWlsZGVyIiwibGFuZ3VhZ2VzIiwicHJpc21MYW5ndWFnZXMiLCJTbGF0ZVByaXNtIiwiUXVlcnlGaWVsZCIsIkJyYWNlc1BsdWdpbiIsIkRPTVV0aWwiLCJJY29uIiwiTG9jYWxTdG9yYWdlVmFsdWVQcm92aWRlciIsImVzY2FwZUxhYmVsVmFsdWVJblNlbGVjdG9yIiwic2hvdWxkUmVmcmVzaExhYmVscyIsIkxBU1RfVVNFRF9MQUJFTFNfS0VZIiwiZ2V0Q2hvb3NlclRleHQiLCJoYXNTeW50YXgiLCJoYXNMb2dMYWJlbHMiLCJ3aWxsQXBwbHlTdWdnZXN0aW9uIiwic3VnZ2VzdGlvbiIsInR5cGVhaGVhZENvbnRleHQiLCJ0eXBlYWhlYWRUZXh0IiwibmV4dENoYXIiLCJnZXROZXh0Q2hhcmFjdGVyIiwic3VnZ2VzdGlvbk1vZGlmaWVkIiwib25DaGFuZ2VRdWVyeSIsImxhYmVsQnJvd3NlclZpc2libGUiLCJvdmVycmlkZSIsInR5cGVhaGVhZCIsInN1Z2dlc3Rpb25zIiwibG9raUxhbmd1YWdlUHJvdmlkZXIiLCJ3cmFwcGVyQ2xhc3NlcyIsInJlc3VsdCIsInByb3ZpZGVDb21wbGV0aW9uSXRlbXMiLCJsYWJlbHNMb2FkZWQiLCJwbHVnaW5zIiwib25seUluIiwibm9kZSIsIm9iamVjdCIsImdldFN5bnRheCIsImxvZ3FsIiwiX2lzTW91bnRlZCIsImNvbXBvbmVudERpZFVwZGF0ZSIsInByZXZQcm9wcyIsInJlZnJlc2hMYWJlbHMiLCJmZXRjaExhYmVscyIsIkV4dHJhRmllbGRFbGVtZW50IiwicGxhY2Vob2xkZXIiLCJjbGVhblRleHQiLCJjaG9vc2VyVGV4dCIsImJ1dHRvbkRpc2FibGVkIiwib25MYXN0VXNlZExhYmVsc1NhdmUiLCJvbkxhc3RVc2VkTGFiZWxzRGVsZXRlIiwib25DbGlja0Nob29zZXJCdXR0b24iLCJvblR5cGVhaGVhZCIsIm9uQmx1ciIsIm9uQ2hhbmdlTGFiZWxCcm93c2VyIiwiQWxlcnRpbmdTZXR0aW5ncyIsIkRhdGFTb3VyY2VIdHRwU2V0dGluZ3MiLCJnZXRBbGxBbGVydG1hbmFnZXJEYXRhU291cmNlcyIsIkRlcml2ZWRGaWVsZHMiLCJNYXhMaW5lc0ZpZWxkIiwibWFrZUpzb25VcGRhdGVyIiwib3B0aW9ucyIsImpzb25EYXRhIiwic2V0TWF4TGluZXMiLCJzZXREZXJpdmVkRmllbGRzIiwiQ29uZmlnRWRpdG9yIiwib25PcHRpb25zQ2hhbmdlIiwiYWxlcnRtYW5hZ2VycyIsInVzZVN0YXRlIiwiQXJyYXlWZWN0b3IiLCJMZWdhY3lGb3JtcyIsImdldEZpZWxkTGlua3NGb3JFeHBsb3JlIiwiRm9ybUZpZWxkIiwiRGVidWdTZWN0aW9uIiwiY2xhc3NOYW1lIiwiZGVidWdUZXh0Iiwic2V0RGVidWdUZXh0IiwiZGVidWdGaWVsZHMiLCJtYWtlRGVidWdGaWVsZHMiLCJEZWJ1Z0ZpZWxkcyIsIm1lc3NhZ2UiLCJocmVmIiwibWF0Y2hlclJlZ2V4IiwidGVzdE1hdGNoIiwibGluayIsInVybCIsInN0cmluZyIsImxpbmtzIiwicm93SW5kZXgiLCJ1c2VFZmZlY3QiLCJ1c2VQcmV2aW91cyIsIkRhdGFTb3VyY2VQaWNrZXIiLCJEYXRhTGlua0lucHV0Iiwic3R5bGVzRmFjdG9yeSIsIlN3aXRjaCIsInJvdyIsIm5hbWVGaWVsZCIsInJlZ2V4RmllbGQiLCJ1cmxGaWVsZCIsInVybERpc3BsYXlMYWJlbEZpZWxkIiwiRGVyaXZlZEZpZWxkIiwib25EZWxldGUiLCJzaG93SW50ZXJuYWxMaW5rIiwic2V0U2hvd0ludGVybmFsTGluayIsImRhdGFzb3VyY2VVaWQiLCJwcmV2aW91c1VpZCIsImhhbmRsZUNoYW5nZSIsInByZXZlbnREZWZhdWx0IiwibmV3VmFsdWUiLCJ1cmxEaXNwbGF5TGFiZWwiLCJkcyIsInVpZCIsIlZhcmlhYmxlT3JpZ2luIiwiRGF0YUxpbmtCdWlsdEluVmFycyIsInVzZVRoZW1lMiIsImluZm9UZXh0IiwiZGVyaXZlZEZpZWxkIiwic2hvd0RlYnVnIiwic2V0U2hvd0RlYnVnIiwibmV3RmllbGQiLCJuZXdEZXJpdmVkRmllbGRzIiwic3BsaWNlIiwidmFsdWVSYXciLCJkb2N1bWVudGF0aW9uIiwib3JpZ2luIiwiVmFsdWUiLCJjbG9uZURlZXAiLCJpc0VtcHR5IiwibG9kYXNoTWFwIiwiUHJpc20iLCJsYXN0VmFsdWVGcm9tIiwibWVyZ2UiLCJvZiIsInRocm93RXJyb3IiLCJjYXRjaEVycm9yIiwic3dpdGNoTWFwIiwiRGF0YUZyYW1lVmlldyIsImRhdGVNYXRoIiwiRmllbGRDYWNoZSIsImdldExvZ0xldmVsRnJvbUtleSIsIkxvYWRpbmdTdGF0ZSIsIkxvZ0xldmVsIiwicmFuZ2VVdGlsIiwidG9VdGMiLCJnZXRCYWNrZW5kU3J2IiwiRGF0YVNvdXJjZVdpdGhCYWNrZW5kIiwicXVlcnlMb2dzVm9sdW1lIiwiY29udmVydFRvV2ViU29ja2V0VXJsIiwiZ2V0VGltZVNydiIsImdldFRlbXBsYXRlU3J2Iiwic2VyaWFsaXplUGFyYW1zIiwicmVuZGVyTGVnZW5kRm9ybWF0IiwiTGFuZ3VhZ2VQcm92aWRlciIsIkxpdmVTdHJlYW1zIiwiYWRkUGFyc2VkTGFiZWxUb1F1ZXJ5IiwiZ2V0Tm9ybWFsaXplZExva2lRdWVyeSIsInF1ZXJ5SGFzUGlwZVBhcnNlciIsImxva2lSZXN1bHRzVG9UYWJsZU1vZGVsIiwibG9raVN0cmVhbXNUb0RhdGFGcmFtZXMiLCJwcm9jZXNzUmFuZ2VRdWVyeVJlc3BvbnNlIiwic29ydERhdGFGcmFtZUJ5VGltZSIsImRvTG9raUNoYW5uZWxTdHJlYW0iLCJzeW50YXgiLCJMb2tpUXVlcnlEaXJlY3Rpb24iLCJMb2tpUmVzdWx0VHlwZSIsIkRFRkFVTFRfTUFYX0xJTkVTIiwiTE9LSV9FTkRQT0lOVCIsIk5TX0lOX01TIiwiUkFOR0VfUVVFUllfRU5EUE9JTlQiLCJJTlNUQU5UX1FVRVJZX0VORFBPSU5UIiwiREVGQVVMVF9RVUVSWV9QQVJBTVMiLCJtYWtlUmVxdWVzdCIsInJlcXVlc3RJZCIsImludGVydmFsSW5mbyIsImNhbGN1bGF0ZUludGVydmFsIiwidGFyZ2V0cyIsImludGVydmFsIiwiaW50ZXJ2YWxNcyIsInNjb3BlZFZhcnMiLCJ0aW1lem9uZSIsInN0YXJ0VGltZSIsIkRhdGUiLCJub3ciLCJMb2tpRGF0YXNvdXJjZSIsImluc3RhbmNlU2V0dGluZ3MiLCJ0ZW1wbGF0ZVNydiIsInRpbWVTcnYiLCJyZXNwb25zZUxpc3RMZW5ndGgiLCJ0aW1lTnMiLCJnZXRUaW1lIiwidG8iLCJxdWVyeUxpbWl0IiwiaXNNZXRyaWNzUXVlcnkiLCJtYXhEYXRhUG9pbnRzIiwiTWF0aCIsIm1pbiIsImRpcmVjdGlvbiIsIkZvcndhcmQiLCJfcmVxdWVzdCIsInBpcGUiLCJyZXN1bHRUeXBlIiwiZXJyIiwicHJvY2Vzc0Vycm9yIiwibGl2ZVN0cmVhbWluZyIsInJ1bkxpdmVRdWVyeSIsImNyZWF0ZVJhbmdlUXVlcnkiLCJoZWFkZXJzIiwidm9sdW1lUXVlcnkiLCJsaXZlVGFyZ2V0IiwiY3JlYXRlTGl2ZVRhcmdldCIsImdldFN0cmVhbSIsIlN0cmVhbWluZyIsInJlYXNvbiIsInByZXBhcmVMb2dSb3dDb250ZXh0UXVlcnlUYXJnZXQiLCJwcm9jZXNzRGF0YUZyYW1lIiwiY2FjaGUiLCJ0aW1lc3RhbXBGaWVsZCIsImdldEZpcnN0RmllbGRPZlR5cGUiLCJsaW5lRmllbGQiLCJpZEZpZWxkIiwiZ2V0RmllbGRCeU5hbWUiLCJwcm9jZXNzUmVzdWx0cyIsInByb2Nlc3NlZEZyYW1lcyIsInN0YXR1c1RleHQiLCJyZXMiLCJjb250ZXh0VGltZUJ1ZmZlciIsInF1ZXJ5RGlyZWN0aW9uIiwiQmFja3dhcmQiLCJmaWVsZENhY2hlIiwiZGF0YUZyYW1lIiwidHNGaWVsZCIsInRzVmFsdWUiLCJ0aW1lc3RhbXAiLCJmcm9tIiwidGltZUVwb2NoTXMiLCJyYXciLCJzZXR0aW5nc0RhdGEiLCJwYXJzZUludCIsImFwaVVybCIsImJhc2VVcmwiLCJwYXJhbXMiLCJ3aXRoQ3JlZGVudGlhbHMiLCJiYXNpY0F1dGgiLCJBdXRob3JpemF0aW9uIiwicmVxIiwiZmV0Y2giLCJnZXRMb2dzVm9sdW1lRGF0YVByb3ZpZGVyIiwicmVxdWVzdCIsImlzTG9nc1ZvbHVtZUF2YWlsYWJsZSIsInNvbWUiLCJsb2dzVm9sdW1lUmVxdWVzdCIsImV4dHJhY3RMZXZlbCIsInN1YlF1ZXJpZXMiLCJnZXRSYW5nZVNjb3BlZFZhcnMiLCJsb2tpQmFja2VuZE1vZGUiLCJmaXhlZFJlcXVlc3QiLCJydW5MaXZlUXVlcnlUaHJvdWdoQmFja2VuZCIsImZpbHRlcmVkVGFyZ2V0cyIsImhpZGUiLCJhZGRBZEhvY0ZpbHRlcnMiLCJpbnRlcnBvbGF0ZVF1ZXJ5RXhwciIsInJ1bkluc3RhbnRRdWVyeSIsInJhbmdlUmF3IiwicnVuUmFuZ2VRdWVyeSIsIkRvbmUiLCJsb2dzUXVlcmllcyIsInN0YXJ0TnMiLCJlbmROcyIsInJhbmdlTXMiLCJjZWlsIiwiYWRqdXN0ZWRJbnRlcnZhbCIsImFkanVzdEludGVydmFsIiwic3RlcCIsImVuZCIsInNpemUiLCJ0aW1lUmFuZ2UiLCJtc1JhbmdlIiwiZGlmZiIsInNSYW5nZSIsInJvdW5kIiwiX19yYW5nZV9tcyIsIl9fcmFuZ2VfcyIsIl9fcmFuZ2UiLCJpbnRlcnBvbGF0ZVZhcmlhYmxlc0luUXVlcmllcyIsImV4cGFuZGVkUXVlcmllcyIsImdldFJlZiIsImdldFF1ZXJ5RGlzcGxheVRleHQiLCJnZXRUaW1lUmFuZ2VQYXJhbXMiLCJ2YWx1ZU9mIiwiaW1wb3J0RnJvbUFic3RyYWN0UXVlcmllcyIsImFic3RyYWN0UXVlcmllcyIsImV4aXN0aW5nS2V5cyIsImxhYmVsS2V5cyIsImFic3RyYWN0UXVlcnkiLCJsYWJlbE1hdGNoZXJzIiwibGFiZWxNYXRjaGVyIiwiaW1wb3J0RnJvbUFic3RyYWN0UXVlcnkiLCJleHBvcnRUb0Fic3RyYWN0UXVlcmllcyIsImV4cG9ydFRvQWJzdHJhY3RRdWVyeSIsIm1ldGFkYXRhUmVxdWVzdCIsImdldFJlc291cmNlIiwibWV0cmljRmluZFF1ZXJ5IiwiUHJvbWlzZSIsInJlc29sdmUiLCJpbnRlcnBvbGF0ZWQiLCJwcm9jZXNzTWV0cmljRmluZFF1ZXJ5IiwibGFiZWxOYW1lc1JlZ2V4IiwibGFiZWxWYWx1ZXNSZWdleCIsImxhYmVsTmFtZXMiLCJsYWJlbE5hbWVzUXVlcnkiLCJsYWJlbFZhbHVlcyIsImxhYmVsVmFsdWVzU2VyaWVzUXVlcnkiLCJsYWJlbFZhbHVlc1F1ZXJ5IiwidGltZVBhcmFtcyIsInN0cmVhbSIsImFkZCIsIkFycmF5IiwiZ2V0VGFnS2V5cyIsImdldFRhZ1ZhbHVlcyIsInZhcmlhYmxlIiwibXVsdGkiLCJpbmNsdWRlQWxsIiwibG9raVJlZ3VsYXJFc2NhcGUiLCJsb2tpU3BlY2lhbFJlZ2V4RXNjYXBlIiwiZXNjYXBlZFZhbHVlcyIsIm1vZGlmeVF1ZXJ5IiwiYWN0aW9uIiwiZGF0ZSIsInJvdW5kVXAiLCJwYXJzZSIsInRlc3REYXRhc291cmNlIiwibm93TXMiLCJpbmZvIiwiaW5mb0luUGFyZW50aGVzZXMiLCJhbm5vdGF0aW9uUXVlcnkiLCJ0YWdLZXlzIiwidGl0bGVGb3JtYXQiLCJ0ZXh0Rm9ybWF0IiwiaWQiLCJEYXNoYm9hcmQiLCJhbm5vdGF0aW9ucyIsInNwbGl0S2V5cyIsInNwbGl0IiwidmlldyIsIm1heWJlRHVwbGljYXRlZFRhZ3MiLCJlbnRyaWVzIiwidmFsIiwidHJpbSIsInRhZ3MiLCJ0cyIsImxpbmUiLCJzaG93Q29udGV4dFRvZ2dsZSIsImR5bmFtaWNJbnRlcnZhbCIsInNhZmVJbnRlcnZhbCIsIm1heCIsInF1ZXJ5RXhwciIsImFkaG9jRmlsdGVycyIsImdldEFkaG9jRmlsdGVycyIsInJlZHVjZSIsImFjYyIsIm5vdFBhcnNlZExhYmVsT3ZlcnJpZGUiLCJlc2NhcGVkVmFsdWUiLCJmaWx0ZXJRdWVyeSIsImFwcGx5VGVtcGxhdGVWYXJpYWJsZXMiLCJpbnRlcnBvbGF0ZVN0cmluZyIsImdldFZhcmlhYmxlcyIsInRva2VucyIsInRva2VuaXplIiwidCIsInZhbHVlRmllbGQiLCJnZXRMb2dMZXZlbEZyb21MYWJlbHMiLCJ1bmtub3duIiwibGV2ZWxMYWJlbCIsImxhYmVsTmFtZSIsImdyb3VwQnkiLCJnZXREYXRhU291cmNlU3J2IiwiZGVyaXZlZEZpZWxkc0dyb3VwZWQiLCJuZXdGaWVsZHMiLCJmaWVsZEZyb21EZXJpdmVkRmllbGRDb25maWciLCJmIiwidG9BcnJheSIsImxvZ01hdGNoIiwiZGF0YVNvdXJjZVNydiIsImRhdGFMaW5rcyIsImRlcml2ZWRGaWVsZENvbmZpZyIsImRzU2V0dGluZ3MiLCJnZXRJbnN0YW5jZVNldHRpbmdzIiwiaW50ZXJuYWwiLCJkYXRhc291cmNlTmFtZSIsImRpZmZlcmVuY2UiLCJMUlUiLCJkYXRlVGltZSIsImV4dHJhY3RMYWJlbE1hdGNoZXJzIiwicGFyc2VTZWxlY3RvciIsInByb2Nlc3NMYWJlbHMiLCJ0b1Byb21MaWtlRXhwciIsIkZVTkNUSU9OUyIsIlBJUEVfUEFSU0VSUyIsIlBJUEVfT1BFUkFUT1JTIiwiREVGQVVMVF9LRVlTIiwiSElTVE9SWV9JVEVNX0NPVU5UIiwiSElTVE9SWV9DT1VOVF9DVVRPRkYiLCJSQVRFX1JBTkdFUyIsInNvcnRWYWx1ZSIsIkxBQkVMX1JFRlJFU0hfSU5URVJWQUwiLCJ3cmFwTGFiZWwiLCJmaWx0ZXJUZXh0IiwiYWRkSGlzdG9yeU1ldGFkYXRhIiwiY3V0b2ZmVHMiLCJoaXN0b3J5Rm9ySXRlbSIsImgiLCJoaW50IiwicmVjZW50IiwibGFzdFF1ZXJpZWQiLCJmcm9tTm93IiwiTG9raUxhbmd1YWdlUHJvdmlkZXIiLCJpbml0aWFsVmFsdWVzIiwicyIsInN0YXJ0VGFzayIsImNvbnRleHQiLCJnZXRFbXB0eUNvbXBsZXRpb25JdGVtcyIsImdldFRlcm1Db21wbGV0aW9uSXRlbXMiLCJwcmVmaXhNYXRjaCIsIml0ZW1zIiwia2luZCIsImludGVycG9sYXRlZE1hdGNoIiwiY2FjaGVLZXkiLCJnZW5lcmF0ZUNhY2hlS2V5Iiwic2VyaWVzQ2FjaGUiLCJzZXQiLCJsYWJlbEZldGNoVHMiLCJhc3NpZ24iLCJpbnB1dCIsImVtcHR5UmVzdWx0IiwiZG9jdW1lbnQiLCJzZWxlY3RlZExpbmVzIiwiZ2V0VGV4dHNBdFJhbmdlIiwic2VsZWN0aW9uIiwiY3VycmVudExpbmUiLCJmaXJzdCIsImdldFRleHQiLCJuZXh0Q2hhcmFjdGVyIiwiYW5jaG9yIiwidG9rZW5SZWNvZ25pemVkIiwicHJlZml4VW5yZWNvZ25pemVkIiwibm9TdWZmaXgiLCJzYWZlUHJlZml4Iiwib3BlcmF0b3JzUGF0dGVybiIsImlzTmV4dE9wZXJhbmQiLCJnZXRSYW5nZUNvbXBsZXRpb25JdGVtcyIsImdldExhYmVsQ29tcGxldGlvbkl0ZW1zIiwiZ2V0UGlwZUNvbXBsZXRpb25JdGVtIiwiZ2V0QmVnaW5uaW5nQ29tcGxldGlvbkl0ZW1zIiwiaGlzdG9yeUl0ZW1zIiwidW5pcSIsInRha2UiLCJza2lwU29ydCIsImFuY2hvckJsb2NrIiwiY3Vyc29yT2Zmc2V0IiwiaXNWYWx1ZVN0YXJ0IiwicGFyc2VkU2VsZWN0b3IiLCJhbGxMYWJlbHMiLCJsYWJlbFZhbHVlc0ZvcktleSIsImdldFNlcmllc0xhYmVscyIsIndhcm4iLCJwb3NzaWJsZUtleXMiLCJuZXdJdGVtcyIsIm5ld1N1Z2dlc3Rpb24iLCJsYWJlbEJhc2VkUXVlcnkiLCJsb2tpUXVlcnkiLCJsb29rdXBzRGlzYWJsZWQiLCJpc0FycmF5Iiwic29ydCIsInJlZnJlc2hMb2dMYWJlbHMiLCJmb3JjZVJlZnJlc2giLCJwYXJhbSIsInJvdW5kVGltZSIsIm5hbm9zIiwiZmxvb3IiLCJmZXRjaExhYmVsVmFsdWVzIiwiaW50ZXJwb2xhdGVkS2V5IiwicmFuZ2VQYXJhbXMiLCJsYWJlbHNDYWNoZSIsInJvdW5kTXNUb01pbiIsIm1pbGxpc2Vjb25kcyIsInJvdW5kU2VjVG9NaW4iLCJzZWNvbmRzIiwicHJldlJhbmdlIiwic2FtZU1pbnV0ZUZyb20iLCJzYW1lTWludXRlVG8iLCJSRTJfTUVUQUNIQVJBQ1RFUlMiLCJlc2NhcGVMb2tpUmVnZXhwIiwiaXNSZWdleFNlbGVjdG9yIiwidGltZXIiLCJmaW5hbGl6ZSIsInJldHJ5V2hlbiIsIm1lcmdlTWFwIiwid2ViU29ja2V0IiwicGFyc2VMYWJlbHMiLCJDaXJjdWxhckRhdGFGcmFtZSIsImFwcGVuZFJlc3BvbnNlVG9CdWZmZXJlZERhdGEiLCJyZXRyeUludGVydmFsIiwiY2FwYWNpdHkiLCJhZGRGaWVsZCIsIm90aGVyIiwiYXR0ZW1wdHMiLCJyZXRyeUF0dGVtcHQiLCJjb2RlIiwiaW5zdGFudE1ldHJpY0ZyYW1lcyIsImZyYW1lc1dpdGhSZWZJZCIsImZyYW1lc0J5UmVmSWQiLCJtYWtlVGFibGVGcmFtZSIsInRhYmxlVGltZUZpZWxkIiwidGFibGVWYWx1ZUZpZWxkIiwiYWxsTGFiZWxOYW1lcyIsImZsYXQiLCJzb3J0ZWRMYWJlbE5hbWVzIiwibGFiZWxGaWVsZHMiLCJmaWx0ZXJhYmxlIiwidGltZUZpZWxkIiwidGltZUFycmF5IiwidmFsdWVBcnJheSIsIngiLCJEYXRhU291cmNlUGx1Z2luIiwicGx1Z2luIiwic2V0UXVlcnlFZGl0b3IiLCJzZXRDb25maWdFZGl0b3IiLCJzZXRRdWVyeUVkaXRvckhlbHAiLCJzZXRBbm5vdGF0aW9uUXVlcnlDdHJsIiwiZXNjYXBlUmVnRXhwIiwicmVzdWx0cyIsImZpbHRlclN0YXJ0Iiwic2VhcmNoIiwiZmlsdGVyT3BlcmF0b3IiLCJza2lwIiwiZmlsdGVyRW5kIiwiZmlsdGVyVGVybSIsInF1b3RlZFRlcm0iLCJiYWNrdGlja2VkVGVybSIsInRlcm0iLCJ1bndyYXBwZWRGaWx0ZXJUZXJtIiwicmVnZXhPcGVyYXRvciIsInBhcnNlcnMiLCJwYXJzZXIiLCJyZWdleHAiLCJSZWdFeHAiLCJ0ZXN0IiwiTG9raUFuZFByb21RdWVyeU1vZGVsbGVyQmFzZSIsImdldE9wZXJhdGlvbkRlZmluaXRpb25zIiwiTG9raU9wZXJhdGlvbklkIiwiTG9raVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkiLCJMb2tpUXVlcnlNb2RlbGxlciIsInNldE9wZXJhdGlvbkNhdGVnb3JpZXMiLCJBZ2dyZWdhdGlvbnMiLCJSYW5nZUZ1bmN0aW9ucyIsIkZvcm1hdHMiLCJCaW5hcnlPcHMiLCJMYWJlbEZpbHRlcnMiLCJMaW5lRmlsdGVycyIsInJlbmRlckxhYmVscyIsImdldFF1ZXJ5UGF0dGVybnMiLCJvcGVyYXRpb25zIiwiTGluZU1hdGNoZXNSZWdleCIsIkxvZ2ZtdCIsIkxhYmVsRmlsdGVyTm9FcnJvcnMiLCJMYWJlbEZpbHRlciIsIlVud3JhcCIsIlN1bU92ZXJUaW1lIiwiU3VtIiwibG9raVF1ZXJ5TW9kZWxsZXIiLCJkZWZhdWx0QWRkT3BlcmF0aW9uSGFuZGxlciIsImJpbmFyeVNjYWxhckRlZnMiLCJBZGRpdGlvbiIsInNpZ24iLCJTdWJ0cmFjdGlvbiIsIk11bHRpcGx5QnkiLCJEaXZpZGVCeSIsIk1vZHVsbyIsIkV4cG9uZW50IiwiRXF1YWxUbyIsImNvbXBhcmlzb24iLCJOb3RFcXVhbFRvIiwiR3JlYXRlclRoYW4iLCJMZXNzVGhhbiIsIkdyZWF0ZXJPckVxdWFsIiwiTGVzc09yRXF1YWwiLCJiaW5hcnlTY2FsYXJPcGVyYXRpb25zIiwib3BEZWYiLCJkZWZhdWx0UGFyYW1zIiwidW5zaGlmdCIsImFsdGVybmF0aXZlc0tleSIsImNhdGVnb3J5IiwicmVuZGVyZXIiLCJnZXRTaW1wbGVCaW5hcnlSZW5kZXJlciIsImFkZE9wZXJhdGlvbkhhbmRsZXIiLCJiaW5hcnlSZW5kZXJlciIsIm1vZGVsIiwiZGVmIiwiaW5uZXJFeHByIiwiYm9vbCIsInVzZU1lbW8iLCJFZGl0b3JSb3ciLCJPcGVyYXRpb25MaXN0IiwiT3BlcmF0aW9uc0VkaXRvclJvdyIsIk5lc3RlZFF1ZXJ5TGlzdCIsIkxva2lRdWVyeUJ1aWxkZXIiLCJuZXN0ZWQiLCJvbkNoYW5nZUxhYmVscyIsIndpdGhUZW1wbGF0ZVZhcmlhYmxlT3B0aW9ucyIsIm9wdGlvbnNQcm9taXNlIiwib25HZXRMYWJlbE5hbWVzIiwiZm9yTGFiZWwiLCJsYWJlbHNUb0NvbnNpZGVyIiwic2VyaWVzIiwib25HZXRMYWJlbFZhbHVlcyIsIm9wIiwibGFiZWxGaWx0ZXJFcnJvciIsIkxpbmVDb250YWlucyIsImJpbmFyeVF1ZXJpZXMiLCJjcmVhdGVTbGljZSIsInVzZVJlZHVjZXIiLCJidWlsZFZpc3VhbFF1ZXJ5RnJvbVN0cmluZyIsIlF1ZXJ5UHJldmlldyIsIkxva2lRdWVyeUJ1aWxkZXJDb250YWluZXIiLCJkaXNwYXRjaCIsInN0YXRlU2xpY2UiLCJyZWR1Y2VyIiwidmlzUXVlcnkiLCJleHByQ2hhbmdlZCIsIm9uVmlzUXVlcnlDaGFuZ2UiLCJyZW5kZXJRdWVyeSIsInZpc3VhbFF1ZXJ5Q2hhbmdlIiwicmF3UXVlcnkiLCJpbml0aWFsU3RhdGUiLCJyZWR1Y2VycyIsInBheWxvYWQiLCJwYXJzZVJlc3VsdCIsImFjdGlvbnMiLCJTdGFjayIsIk9wZXJhdGlvbkV4cGxhaW5lZEJveCIsIk9wZXJhdGlvbkxpc3RFeHBsYWluZWQiLCJMb2tpUXVlcnlCdWlsZGVyRXhwbGFpbmVkIiwiRWRpdG9yRmllbGQiLCJBdXRvU2l6ZUlucHV0IiwiUXVlcnlPcHRpb25Hcm91cCIsIkxva2lRdWVyeUJ1aWxkZXJPcHRpb25zIiwib25MZWdlbmRGb3JtYXRDaGFuZ2VkIiwiZXZ0IiwibmV3TWF4TGluZXMiLCJzaG93TWF4TGluZXMiLCJnZXRDb2xsYXBzZWRJbmZvIiwicXVlcnlUeXBlTGFiZWwiLCJyZXNvbHV0aW9uTGFiZWwiLCJ1c2VTdHlsZXMyIiwiTG9raVF1ZXJ5Q29kZUVkaXRvciIsInVzZUNhbGxiYWNrIiwiRWRpdG9ySGVhZGVyIiwiRWRpdG9yUm93cyIsIkZsZXhJdGVtIiwiSW5saW5lU2VsZWN0IiwiU3BhY2UiLCJDb25maXJtTW9kYWwiLCJRdWVyeUVkaXRvck1vZGVUb2dnbGUiLCJRdWVyeUhlYWRlclN3aXRjaCIsIlF1ZXJ5RWRpdG9yTW9kZSIsImNoYW5nZUVkaXRvck1vZGUiLCJnZXRRdWVyeVdpdGhEZWZhdWx0cyIsInBhcnNlTW9kYWxPcGVuIiwic2V0UGFyc2VNb2RhbE9wZW4iLCJkYXRhSXNTdGFsZSIsInNldERhdGFJc1N0YWxlIiwib25FZGl0b3JNb2RlQ2hhbmdlIiwibmV3RWRpdG9yTW9kZSIsIkJ1aWxkZXIiLCJlcnJvcnMiLCJvbkNoYW5nZUludGVybmFsIiwib25RdWVyeVByZXZpZXdDaGFuZ2UiLCJpc0VuYWJsZWQiLCJjaGVja2VkIiwiZWRpdG9yTW9kZSIsIkNvZGUiLCJMb2FkaW5nIiwiRXhwbGFpbiIsInRvT3B0aW9uIiwiSWNvbkJ1dHRvbiIsIk5lc3RlZFF1ZXJ5IiwibmVzdGVkUXVlcnkiLCJvblJlbW92ZSIsImNhcmQiLCJoZWFkZXIiLCJvcGVyYXRvcnMiLCJ2ZWN0b3JNYXRjaFdyYXBwZXIiLCJ2ZWN0b3JNYXRjaGVzVHlwZSIsInZlY3Rvck1hdGNoSW5wdXQiLCJ2ZWN0b3JNYXRjaGVzIiwiYm9keSIsInVwZGF0ZSIsImRpc3BsYXkiLCJmbGV4RGlyZWN0aW9uIiwiZ2FwIiwicGFkZGluZyIsImFsaWduSXRlbXMiLCJ3aGl0ZVNwYWNlIiwicGFkZGluZ0xlZnQiLCJtYXJnaW5MZWZ0IiwibmVzdGVkUXVlcmllcyIsIm9uTmVzdGVkUXVlcnlVcGRhdGUiLCJ1cGRhdGVkTGlzdCIsIkVkaXRvckZpZWxkR3JvdXAiLCJsb2tpR3JhbW1hciIsImhpZ2hsaWdodGVkIiwiaGlnaGxpZ2h0IiwiZWRpdG9yRmllbGQiLCJfX2h0bWwiLCJmb250RmFtaWx5IiwiZm9udFNpemUiLCJib2R5U21hbGwiLCJjcmVhdGVBZ2dyZWdhdGlvbk9wZXJhdGlvbiIsImNyZWF0ZUFnZ3JlZ2F0aW9uT3BlcmF0aW9uV2l0aFBhcmFtIiwiZ2V0UHJvbUFuZExva2lPcGVyYXRpb25EaXNwbGF5TmFtZSIsIkxva2lPcGVyYXRpb25PcmRlciIsImFnZ3JlZ2F0aW9ucyIsIk1pbiIsIk1heCIsIkF2ZyIsIlN0ZGRldiIsIlN0ZHZhciIsIkNvdW50IiwiZmxhdE1hcCIsIm9wSWQiLCJhZGRMb2tpT3BlcmF0aW9uIiwib3JkZXJSYW5rIiwiTGFzdCIsImFnZ3JlZ2F0aW9uc1dpdGhQYXJhbSIsIlRvcEsiLCJCb3R0b21LIiwiY3JlYXRlUmFuZ2VPcGVyYXRpb24iLCJSYXRlIiwiQ291bnRPdmVyVGltZSIsIkJ5dGVzUmF0ZSIsIkJ5dGVzT3ZlclRpbWUiLCJBYnNlbnRPdmVyVGltZSIsIkF2Z092ZXJUaW1lIiwiTWF4T3ZlclRpbWUiLCJNaW5PdmVyVGltZSIsIkZpcnN0T3ZlclRpbWUiLCJMYXN0T3ZlclRpbWUiLCJTdGR2YXJPdmVyVGltZSIsIlN0ZGRldk92ZXJUaW1lIiwiUXVhbnRpbGVPdmVyVGltZSIsIkpzb24iLCJMaW5lRm9ybWF0cyIsInBpcGVsaW5lUmVuZGVyZXIiLCJleHBsYWluSGFuZGxlciIsIlJlZ2V4cCIsImhpZGVOYW1lIiwibWluV2lkdGgiLCJQYXR0ZXJuIiwiVW5wYWNrIiwiTGluZUZvcm1hdCIsIkxhYmVsRm9ybWF0IiwiZ2V0TGluZUZpbHRlclJlbmRlcmVyIiwiTGluZUNvbnRhaW5zTm90IiwiTGluZU1hdGNoZXNSZWdleE5vdCIsImxhYmVsRmlsdGVyUmVuZGVyZXIiLCJOb0Vycm9ycyIsIlN0cmluZyIsImFkZE5lc3RlZFF1ZXJ5SGFuZGxlciIsImdldFJhbmdlVmVjdG9yUGFyYW1EZWYiLCJvcGVyYXRpb25XaXRoUmFuZ2VWZWN0b3JSZW5kZXJlciIsIm9wZXJhdGlvbldpdGhSYW5nZVZlY3RvclJlbmRlcmVyQW5kUGFyYW0iLCJSYW5nZVZlY3RvckZ1bmN0aW9uIiwib3BEb2NzIiwiaW5zZXJ0VGV4dCIsInJhbmdlVmVjdG9yIiwib3BlcmF0aW9uIiwibGluZUZpbHRlclJlbmRlcmVyIiwiaXNSYW5nZVZlY3RvckZ1bmN0aW9uIiwiZ2V0SW5kZXhPZk9yTGFzdCIsInF1ZXJ5TW9kZWxsZXIiLCJjb25kaXRpb24iLCJmaW5kSW5kZXgiLCJnZXRPcGVyYXRpb25EZWYiLCJtb2RlbGxlciIsIm5ld09wZXJhdGlvbiIsImV4aXN0aW5nUmFuZ2VWZWN0b3JGdW5jdGlvbiIsIkZ1bmN0aW9ucyIsInBsYWNlVG9JbnNlcnQiLCJFcnJvck5hbWUiLCJnZXRBbGxCeVR5cGUiLCJnZXRMZWZ0TW9zdENoaWxkIiwiZ2V0U3RyaW5nIiwibWFrZUJpbk9wIiwibWFrZUVycm9yIiwicmVwbGFjZVZhcmlhYmxlcyIsInJlcGxhY2VkRXhwciIsInRyZWUiLCJ0b3BOb2RlIiwiaGFuZGxlRXhwcmVzc2lvbiIsImlzRW1wdHlRdWVyeSIsImdldExhYmVsIiwiZ2V0Q2hpbGQiLCJnZXRMaW5lRmlsdGVyIiwiY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IiLCJnZXRMYWJlbFBhcnNlciIsImdldExhYmVsRmlsdGVyIiwiZ2V0TGluZUZvcm1hdCIsImdldExhYmVsRm9ybWF0IiwiZ2V0VW53cmFwIiwiaGFuZGxlUmFuZ2VBZ2dyZWdhdGlvbiIsImhhbmRsZVZlY3RvckFnZ3JlZ2F0aW9uIiwiaGFuZGxlQmluYXJ5IiwiaXNJbnRlcnZhbFZhcmlhYmxlRXJyb3IiLCJjaGlsZCIsImZpcnN0Q2hpbGQiLCJuZXh0U2libGluZyIsImxhYmVsTm9kZSIsImlwTGluZUZpbHRlciIsIm1hcEZpbHRlciIsImZpbHRlckV4cHIiLCJoYW5kbGVRdW90ZXMiLCJwYXJzZXJOb2RlIiwidmFsdWVTdHJpbmciLCJpZGVudGlmaWVyIiwibmFtZU5vZGUiLCJmdW5jTmFtZSIsImxvZ0V4cHIiLCJncm91cGluZyIsImJ5TW9kaWZpZXIiLCJ3aXRob3V0TW9kaWZpZXIiLCJtZXRyaWNFeHByIiwib3BlcmF0b3JUb09wTmFtZSIsImxlZnQiLCJiaW5Nb2RpZmllciIsImdldEJpbmFyeU1vZGlmaWVyIiwicmlnaHQiLCJsYXN0Q2hpbGQiLCJsZWZ0TnVtYmVyIiwiZ2V0TGFzdENoaWxkV2l0aFNlbGVjdG9yIiwicmlnaHROdW1iZXIiLCJyaWdodEJpbmFyeSIsImlzQm9vbCIsImxlZnRNb3N0Q2hpbGQiLCJiaW5RdWVyeSIsImlzTWF0Y2hlciIsIm1hdGNoVHlwZSIsIm1hdGNoZXMiLCJtYXRjaGVyIiwicGFyZW50IiwiY2hpbGRyZW4iLCJzdG9yZSIsInF1ZXJ5RWRpdG9yTW9kZURlZmF1bHRMb2NhbFN0b3JhZ2VLZXkiLCJnZXREZWZhdWx0RWRpdG9yTW9kZSIsImNhcGl0YWxpemUiLCJ2NSIsInV1aWR2NSIsImZpbmRVbmlxdWVMYWJlbHMiLCJ0b0RhdGFGcmFtZSIsIlRhYmxlTW9kZWwiLCJVVUlEX05BTUVTUEFDRSIsImxva2lTdHJlYW1zVG9SYXdEYXRhRnJhbWUiLCJ0aW1lcyIsInRpbWVzTnMiLCJsaW5lcyIsInVpZHMiLCJ1c2VkVWlkcyIsInN0cmVhbUxhYmVscyIsImxhYmVsc1N0cmluZyIsInRvSVNPU3RyaW5nIiwiY3JlYXRlVWlkIiwiY29uc3RydWN0RGF0YUZyYW1lIiwiYmFzZUxhYmVscyIsImxhYmVsc0ZpZWxkIiwidHNOc0ZpZWxkIiwidW5pcXVlIiwiYWxsTGFiZWxzU3RyaW5nIiwibmV3Q291bnQiLCJsb2tpTWF0cml4VG9UaW1lU2VyaWVzIiwibWF0cml4UmVzdWx0IiwiY3JlYXRlTWV0cmljTGFiZWwiLCJtZXRyaWMiLCJkYXRhcG9pbnRzIiwibG9raVBvaW50c1RvVGltZXNlcmllc1BvaW50cyIsInBhcnNlUHJvbWV0aGV1c0Zvcm1hdFNhbXBsZVZhbHVlIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJORUdBVElWRV9JTkZJTklUWSIsInBhcnNlRmxvYXQiLCJkYXRhcG9pbnRWYWx1ZSIsImxva2lSZXN1bHRzIiwicmVzdWx0Q291bnQiLCJtZXRyaWNMYWJlbHMiLCJjdXIiLCJzb3J0ZWRMYWJlbHMiLCJ0YWJsZSIsImNvbHVtbnMiLCJuZXdTZXJpZXMiLCJyb3dzIiwiYSIsImIiLCJsYWJlbERhdGEiLCJnZXRPcmlnaW5hbE1ldHJpY05hbWUiLCJsYWJlbFBhcnQiLCJkZWNhbWVsaXplIiwibSIsImxva2lTdGF0c1RvTWV0YVN0YXQiLCJzdGF0cyIsInVuaXQiLCJlbmhhbmNlRGF0YUZyYW1lIiwicmFuZ2VRdWVyeVJlc3BvbnNlVG9UaW1lU2VyaWVzIiwidHJhbnNmb3JtZXJPcHRpb25zIiwiVmVjdG9yIiwidmVjUmVzdWx0IiwiTWF0cml4IiwicmFuZ2VRdWVyeVJlc3BvbnNlVG9EYXRhRnJhbWVzIiwiU29ydGVkVmVjdG9yIiwibWFrZUluZGV4IiwiZGlyIiwiZmllbGRWYWx1ZXMiLCJpc0FzYyIsInZhbEEiLCJ2YWxCIiwiZGVmZXIiLCJMaXZlQ2hhbm5lbFNjb3BlIiwiZ2V0R3JhZmFuYUxpdmVTcnYiLCJTdHJlYW1pbmdEYXRhRnJhbWUiLCJnZXRMaXZlU3RyZWFtS2V5Iiwic3RyIiwiSlNPTiIsInN0cmluZ2lmeSIsIm1zZ1VpbnQ4IiwiVGV4dEVuY29kZXIiLCJlbmNvZGUiLCJoYXNoQnVmZmVyIiwiY3J5cHRvIiwic3VidGxlIiwiZGlnZXN0IiwiaGFzaEFycmF5IiwiVWludDhBcnJheSIsInBhZFN0YXJ0IiwibWF4RGVsdGEiLCJtYXhMZW5ndGgiLCJ1cGRhdGVGcmFtZSIsIm1zZyIsInAiLCJmcm9tRGF0YUZyYW1lSlNPTiIsImRpc3BsYXlOYW1lRm9ybWF0Iiwic2NvcGUiLCJEYXRhU291cmNlIiwibmFtZXNwYWNlIiwicGF0aCIsIkFHR1JFR0FUSU9OX09QRVJBVE9SUyIsIm1vdmUiLCJkZXRhaWwiLCJSQU5HRV9WRUNfRlVOQ1RJT05TIiwia2V5d29yZCIsImNvbW1lbnQiLCJwYXR0ZXJuIiwibG9va2JlaGluZCIsImluc2lkZSIsImFsaWFzIiwicHVuY3R1YXRpb24iLCJncmVlZHkiLCJmdW5jdGlvbiIsInF1b3RlIiwiYmFja3RpY2tzIiwiUHJvbVF1ZXJ5TW9kZWxsZXIiLCJ2ZWN0b3JTZWxlY3RvclBvc2l0aW9ucyIsImdldFZlY3RvclNlbGVjdG9yUG9zaXRpb25zIiwidG9MYWJlbEZpbHRlciIsImFkZEZpbHRlciIsInBvc2l0aW9ucyIsIml0ZXJhdGUiLCJlbnRlciIsInN1YnN0cmluZyIsIm5ld1F1ZXJ5IiwicHJldiIsImlzTGFzdCIsImxhYmVsRXhpc3RzIiwibmV3TGFiZWxzIiwiZGVmYXVsdHMiLCJmb3JrSm9pbiIsInRhcCIsInRvRGF0YVF1ZXJ5UmVzcG9uc2UiLCJCYWRnZSIsIlRvb2x0aXAiLCJzYWZlU3RyaW5naWZ5VmFsdWUiLCJmZXRjaERhdGFTb3VyY2VCdWlsZEluZm8iLCJQcm9tQXBwbGljYXRpb24iLCJQcm9tZXRoZXVzTGFuZ3VhZ2VQcm92aWRlciIsImV4cGFuZFJlY29yZGluZ1J1bGVzIiwiUHJvbWV0aGV1c01ldHJpY0ZpbmRRdWVyeSIsImdldEluaXRIaW50cyIsImdldFF1ZXJ5SGludHMiLCJ0cmFuc2Zvcm0iLCJ0cmFuc2Zvcm1WMiIsIlByb21RdWVyeVR5cGUiLCJQcm9tZXRoZXVzVmFyaWFibGVTdXBwb3J0IiwiQU5OT1RBVElPTl9RVUVSWV9TVEVQX0RFRkFVTFQiLCJHRVRfQU5EX1BPU1RfTUVUQURBVEFfRU5EUE9JTlRTIiwiUHJvbWV0aGV1c0RhdGFzb3VyY2UiLCJsb2FkUnVsZXMiLCJleGVtcGxhcnNBdmFpbGFibGUiLCJhcmVFeGVtcGxhcnNBdmFpbGFibGUiLCJhY3RpdmVUYXJnZXRzIiwiY2xvbmVkVGFyZ2V0cyIsInBhbmVsSWQiLCJtZXRyaWNOYW1lIiwiaGlzdG9ncmFtTWV0cmljcyIsImluc3RhbnRUYXJnZXQiLCJmb3JtYXQiLCJ2YWx1ZVdpdGhSZWZJZCIsInJhbmdlVGFyZ2V0IiwiZXhlbXBsYXIiLCJhY3RpdmVUYXJnZXQiLCJleGVtcGxhclRhcmdldCIsImNyZWF0ZVF1ZXJ5IiwiaW50ZXJ2YWxUb1NlY29uZHMiLCJ0YWdLZXlzQXJyYXkiLCJldmVudExpc3QiLCJ0aW1lVmFsdWVUdXBsZSIsImlkeCIsInRpbWVTdGFtcFZhbHVlIiwidmFsdWVWYWx1ZSIsInVzZVZhbHVlRm9yVGltZSIsImFjdGl2ZVZhbHVlcyIsImFjdGl2ZVZhbHVlc1RpbWVzdGFtcHMiLCJsYXRlc3RFdmVudCIsInRpbWVFbmQiLCJzdWJUeXBlIiwiUHJvbWV0aGV1cyIsInJ1bGVyRW5hYmxlZCIsImVkaXRvclNyYyIsImFjY2VzcyIsInRpbWVJbnRlcnZhbCIsInF1ZXJ5VGltZW91dCIsImh0dHBNZXRob2QiLCJkaXJlY3RVcmwiLCJleGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbnMiLCJydWxlTWFwcGluZ3MiLCJkaXNhYmxlTWV0cmljc0xvb2t1cCIsImN1c3RvbVF1ZXJ5UGFyYW1ldGVycyIsIlVSTFNlYXJjaFBhcmFtcyIsInZhcmlhYmxlcyIsIl9hZGRUcmFjaW5nSGVhZGVycyIsImh0dHBPcHRpb25zIiwicHJveHlNb2RlIiwiZGFzaGJvYXJkSWQiLCJvdmVycmlkZXMiLCJtZXRob2QiLCJrIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiZW5kcG9pbnQiLCJoaWRlRnJvbUluc3BlY3RvciIsInByb21ldGhldXNSZWd1bGFyRXNjYXBlIiwicHJvbWV0aGV1c1NwZWNpYWxSZWdleEVzY2FwZSIsInRhcmdldENvbnRhaW5zVGVtcGxhdGUiLCJjb250YWluc1RlbXBsYXRlIiwic2hvdWxkUnVuRXhlbXBsYXJRdWVyeSIsImN1cnJlbnRUYXJnZXRJZHgiLCJwcm9jZXNzVGFyZ2V0VjIiLCJwcm9jZXNzZWRUYXJnZXQiLCJ0aW1lU2VyaWVzUXVlcnkiLCJ1dGNPZmZzZXRTZWMiLCJ1dGNPZmZzZXQiLCJnZXRQcm9tZXRoZXVzVGltZSIsInByZXBhcmVUYXJnZXRzIiwiZXhwbG9yZVF1ZXJ5IiwicGFuZWxzUXVlcnkiLCJydW5uaW5nUXVlcmllc0NvdW50IiwiZmlsdGVyQW5kTWFwUmVzcG9uc2UiLCJjYW5jZWxsZWQiLCJydW5RdWVyeSIsIm9ic2VydmFibGVzIiwiY3VycmVudCIsInBlcmZvcm1JbnN0YW50UXVlcnkiLCJnZXRFeGVtcGxhcnMiLCJwZXJmb3JtVGltZVNlcmllc1F1ZXJ5IiwiaGludGluZyIsIm1pbkludGVydmFsIiwic2NyYXBlSW50ZXJ2YWwiLCJpbnRlcnZhbEZhY3RvciIsImdldFJhdGVJbnRlcnZhbFNjb3BlZFZhcmlhYmxlIiwiX19pbnRlcnZhbCIsIl9faW50ZXJ2YWxfbXMiLCJlbmhhbmNlRXhwcldpdGhBZEhvY0ZpbHRlcnMiLCJhZGp1c3RlZCIsImFsaWduUmFuZ2UiLCJyYXRlSW50ZXJ2YWwiLCJfX3JhdGVfaW50ZXJ2YWwiLCJoYW5kbGVFcnJvcnMiLCJpbnRlcnZhbFRvTXMiLCJwcm9jZXNzIiwicXVlcnlNb2RlbCIsInJzcCIsInByb2Nlc3NBbm5vdGF0aW9uUmVzcG9uc2UiLCJnZXRTdWJ0aXRsZSIsImJ1aWxkSW5mbyIsImdldEJ1aWxkSW5mbyIsImdldEJ1aWxkSW5mb01lc3NhZ2UiLCJzZXJpZXNMYWJlbHMiLCJhbGwiLCJ1bmlxdWVMYWJlbHMiLCJlbmFibGVkIiwiZGlzYWJsZWQiLCJ1bnN1cHBvcnRlZCIsIkxPR09TIiwiQ29ydGV4IiwiTWltaXIiLCJDT0xPUlMiLCJhcHBsaWNhdGlvblN1YlR5cGUiLCJ3aWR0aCIsImhlaWdodCIsInZlcnRpY2FsQWxpZ24iLCJhcHBsaWNhdGlvbiIsImdyaWRUZW1wbGF0ZUNvbHVtbnMiLCJyb3dHYXAiLCJjb2x1bW5HYXAiLCJtYXJnaW5Ub3AiLCJmZWF0dXJlcyIsInJ1bGVyQXBpRW5hYmxlZCIsImRldGFpbHMiLCJ2ZXJib3NlTWVzc2FnZSIsImNhdGNoIiwiZXhwYW5kZWRRdWVyeSIsImdyb3VwcyIsImV4dHJhY3RSdWxlTWFwcGluZ0Zyb21Hcm91cHMiLCJsb2ciLCJtYXBwaW5nIiwiZmluYWxRdWVyeSIsImFsaWduZWRFbmQiLCJhbGlnbmVkU3RhcnQiLCJncm91cCIsInJ1bGVzIiwicnVsZSIsIm9uY2UiLCJBYnN0cmFjdExhYmVsT3BlcmF0b3IiLCJTZWFyY2hGdW5jdGlvblR5cGUiLCJhZGRMaW1pdEluZm8iLCJmaXhTdW1tYXJpZXNNZXRhZGF0YSIsInByb2Nlc3NIaXN0b2dyYW1NZXRyaWNzIiwidG9Qcm9tTGlrZVF1ZXJ5IiwiUHJvbXFsU3ludGF4IiwiU1VHR0VTVElPTlNfTElNSVQiLCJzZXRGdW5jdGlvbktpbmQiLCJjb3VudCIsImFkZE1ldHJpY3NNZXRhZGF0YSIsIm1ldGFkYXRhIiwiZ2V0TWV0YWRhdGFTdHJpbmciLCJoZWxwIiwidG9VcHBlckNhc2UiLCJQUkVGSVhfREVMSU1JVEVSX1JFR0VYIiwiUHJvbVFsTGFuZ3VhZ2VQcm92aWRlciIsImRlZmF1bHRWYWx1ZSIsIm1ldHJpY3MiLCJsb2FkTWV0cmljc01ldGFkYXRhIiwiZ2V0QWdncmVnYXRpb25Db21wbGV0aW9uSXRlbXMiLCJzZWFyY2hGdW5jdGlvblR5cGUiLCJQcmVmaXgiLCJtZXRyaWNzTWV0YWRhdGEiLCJGdXp6eSIsInF1ZXJ5T2Zmc2V0IiwicXVlcnlUZXh0IiwiZ2V0QmxvY2tzIiwiYmxvY2siLCJibG9ja1RleHQiLCJvcGVuUGFyZW5zQWdncmVnYXRpb25JbmRleCIsImxhc3RJbmRleE9mIiwib3BlblBhcmVuc1NlbGVjdG9ySW5kZXgiLCJjbG9zZVBhcmVuc1NlbGVjdG9ySW5kZXgiLCJjbG9zZVBhcmVuc0FnZ3JlZ2F0aW9uSW5kZXgiLCJzZWxlY3RvclN0cmluZyIsImdldFNlcmllcyIsImxpbWl0SW5mbyIsInN1YnN0ciIsImlzVmFsdWVFbmQiLCJpc1ByZVZhbHVlIiwiaXNWYWx1ZUVtcHR5IiwiaGFzVmFsdWVQcmVmaXgiLCJjb250YWluc01ldHJpYyIsIndpdGhOYW1lIiwiaW50ZXJwb2xhdGVkTmFtZSIsInVybFBhcmFtcyIsImNhY2hlUGFyYW1zIiwibGFzdCIsInBvcCIsInRyaW1MZWZ0IiwicHJvbVF1ZXJ5IiwibmFtZUxhYmVsVmFsdWUiLCJnZXROYW1lTGFiZWxWYWx1ZSIsIkVxdWFsIiwiZmV0Y2hEZWZhdWx0U2VyaWVzIiwicHJvcCIsImludmVydCIsIlRva2VuIiwicmVzdWx0U2V0IiwiaXNIaXN0b2dyYW1WYWx1ZSIsInZhbHVlU2V0IiwiX19uYW1lX18iLCJsaW1pdFN1Z2dlc3Rpb25zIiwicHJlZml4T3BlbiIsInByZWZpeENsb3NlIiwic3VmZml4Q2xvc2VJbmRleCIsInN1ZmZpeENsb3NlIiwic3VmZml4T3BlbkluZGV4Iiwic3VmZml4T3BlbiIsImxhYmVsT2Zmc2V0IiwidmFsdWVTdGFydCIsInZhbHVlRW5kIiwibWV0cmljUHJlZml4IiwibWV0cmljTWF0Y2giLCJjbGVhblNlbGVjdG9yIiwicnVsZU5hbWVzIiwicnVsZXNSZWdleCIsInByZSIsInBvc3QiLCJxdWVyeUFycmF5IiwiaW52YWxpZExhYmVsc1JlZ2V4IiwiY29ycmVjdGx5RXhwYW5kZWRRdWVyeUFycmF5IiwiYWRkTGFiZWxzVG9FeHByZXNzaW9uIiwiaW52YWxpZExhYmVsc1JlZ2V4cCIsImluZGV4T2ZSZWdleE1hdGNoIiwiZXhwckJlZm9yZVJlZ2V4TWF0Y2giLCJleHByQWZ0ZXJSZWdleE1hdGNoIiwiYXJyYXlPZkxhYmVsT2JqZWN0cyIsIm9iaiIsImJhc2VNZXRhZGF0YSIsInN1bW1hcnlNZXRhZGF0YSIsInN5bnRoZXRpY01ldGFkYXRhIiwiZXNjYXBlUHJvbWV0aGV1c1JlZ2V4cCIsIkZyb21Qcm9tTGlrZU1hcCIsIk5vdEVxdWFsIiwiRXF1YWxSZWdFeCIsIk5vdEVxdWFsUmVnRXgiLCJUb1Byb21MaWtlTWFwIiwidG9rZW4iLCJjb250ZW50VG9rZW5zIiwiY29udGVudCIsImN1cnJlbnRUb2tlbiIsImN1cnJlbnRTdHIiLCJsYWJlbENvbXBhcmF0b3IiLCJfbWFwIiwibWV0cmljTmFtZXNSZWdleCIsInF1ZXJ5UmVzdWx0UmVnZXgiLCJtZXRyaWNOYW1lc1F1ZXJ5IiwibWV0cmljTmFtZVF1ZXJ5IiwicXVlcnlSZXN1bHRRdWVyeSIsIm1ldHJpY05hbWVBbmRMYWJlbHNRdWVyeSIsIl9sYWJlbHMiLCJleHBhbmRhYmxlIiwibWV0cmljRmlsdGVyUGF0dGVybiIsInIiLCJtYXRjaGVkTWV0cmljTmFtZSIsImluc3RhbnRRdWVyeSIsIm1ldHJpY0RhdGEiLCJzZWxmIiwiVFJJR09OT01FVFJJQ19GVU5DVElPTlMiLCJwcm9tcWxHcmFtbWFyIiwiaWRMaXN0IiwiU1VNX0hJTlRfVEhSRVNIT0xEX0NPVU5UIiwiaGludHMiLCJoaXN0b2dyYW1NZXRyaWMiLCJmaXgiLCJuYW1lTWF0Y2giLCJjb3VudGVyTmFtZU1ldHJpYyIsIm1ldHJpY01ldGFkYXRhS2V5cyIsImNlcnRhaW4iLCJtZXRyaWNSZWdleCIsImZpeGFibGVRdWVyeSIsInZlcmIiLCJtYXBwaW5nRm9yUXVlcnkiLCJydWxlTmFtZSIsInNpbXBsZU1ldHJpYyIsInByZXZlbnRTdWJtaXQiLCJnZXRBZ2dyZWdhdGlvbk9wZXJhdGlvbnMiLCJQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeSIsImFsbE9wZXJhdGlvbnMiLCJmdW5jIiwiVHJpZ29ub21ldHJpYyIsIlRpbWUiLCJwcm9tUXVlcnlNb2RlbGxlciIsImFkZE9wZXJhdGlvbldpdGhSYW5nZVZlY3RvciIsIlByb21PcGVyYXRpb25JZCIsIkNvdW50VmFsdWVzIiwiY3JlYXRlQWdncmVnYXRpb25PdmVyVGltZSIsIlByZXNlbnRPdmVyVGltZSIsImJpbmFyeVNjYWxhck9wZXJhdG9yVG9PcGVyYXRvck5hbWUiLCJnZXRPcGVyYXRpb25QYXJhbUlkIiwiTGFiZWxQYXJhbUVkaXRvciIsIm9wZXJhdGlvbkluZGV4IiwiaXNMb2FkaW5nIiwibG9hZEdyb3VwQnlMYWJlbHMiLCJmdW5jdGlvblJlbmRlcmVyTGVmdCIsImZ1bmN0aW9uUmVuZGVyZXJSaWdodCIsInJhbmdlUmVuZGVyZXJMZWZ0V2l0aFBhcmFtcyIsInJhbmdlUmVuZGVyZXJSaWdodFdpdGhQYXJhbXMiLCJIaXN0b2dyYW1RdWFudGlsZSIsIkxhYmVsUmVwbGFjZSIsIkxuIiwiY3JlYXRlUmFuZ2VGdW5jdGlvbiIsIkNoYW5nZXMiLCJJcmF0ZSIsIkluY3JlYXNlIiwiSWRlbHRhIiwiRGVsdGEiLCJjcmVhdGVGdW5jdGlvbiIsIkhvbHRXaW50ZXJzIiwiY2hhbmdlVHlwZUhhbmRsZXIiLCJvcGVyYXRpb25UeXBlQ2hhbmdlZEhhbmRsZXJGb3JSYW5nZUZ1bmN0aW9uIiwiUHJlZGljdExpbmVhciIsIkFic2VudCIsIkFjb3MiLCJBY29zaCIsIkFzaW4iLCJBc2luaCIsIkF0YW4iLCJBdGFuaCIsIkNlaWwiLCJDbGFtcCIsIkNsYW1wTWF4IiwiQ2xhbXBNaW4iLCJDb3MiLCJDb3NoIiwiRGF5T2ZNb250aCIsIkRheU9mV2VlayIsIkRheXNJbk1vbnRoIiwiRGVnIiwiRGVyaXYiLCJFeHAiLCJGbG9vciIsIkdyb3VwIiwiSG91ciIsIkxhYmVsSm9pbiIsInJlc3RQYXJhbSIsIm9wdGlvbmFsIiwibGFiZWxKb2luUmVuZGVyZXIiLCJsYWJlbEpvaW5BZGRPcGVyYXRpb25IYW5kbGVyIiwiTG9nMTAiLCJMb2cyIiwiTWludXRlIiwiTW9udGgiLCJQaSIsIlF1YW50aWxlIiwiUmFkIiwiUmVzZXRzIiwiUm91bmQiLCJTY2FsYXIiLCJTZ24iLCJTaW4iLCJTaW5oIiwiU29ydCIsIlNvcnREZXNjIiwiU3FydCIsIlRhbiIsIlRhbmgiLCJUaW1lc3RhbXAiLCJZZWFyIiwiZGVmaW5pdGlvbiIsIndpdGhSYXRlSW50ZXJ2YWwiLCJuZXdEZWYiLCJmaXJzdE9wIiwic2VwYXJhdG9yIiwiaGFuZGxlRnVuY3Rpb24iLCJoYW5kbGVBZ2dyZWdhdGlvbiIsInByZXZTaWJsaW5nIiwicmFuZ2VGdW5jdGlvbnMiLCJjYWxsQXJncyIsInVwZGF0ZUZ1bmN0aW9uQXJncyIsIm1vZGlmaWVyIiwibWVhc3VyZVRleHQiLCJmb3J3YXJkUmVmIiwicmVmIiwibWF4V2lkdGgiLCJvbkNvbW1pdENoYW5nZSIsIm9uS2V5RG93biIsInJlc3RQcm9wcyIsInNldFZhbHVlIiwiaW5wdXRXaWR0aCIsInNldElucHV0V2lkdGgiLCJnZXRXaWR0aEZvciIsImV4dHJhU3BhY2UiLCJyZWFsV2lkdGgiLCJBY2Nlc3NvcnlCdXR0b24iLCJJbnB1dEdyb3VwIiwiTGFiZWxGaWx0ZXJJdGVtIiwiZGVmYXVsdE9wIiwiaXNNdWx0aVNlbGVjdCIsImdldFNlbGVjdE9wdGlvbnNGcm9tU3RyaW5nIiwiZ2V0T3B0aW9ucyIsImlzTG9hZGluZ0xhYmVsTmFtZXMiLCJjaGFuZ2UiLCJpc0xvYWRpbmdMYWJlbFZhbHVlcyIsImNoYW5nZXMiLCJFZGl0b3JMaXN0IiwibGFiZWxzRmlsdGVycyIsInNldEl0ZW1zIiwib25MYWJlbHNDaGFuZ2UiLCJvbkNoYW5nZUl0ZW0iLCJSZWdpc3RyeSIsImdldE9wZXJhdGlvbnMiLCJvcGVyYXRpb25zUmVnaXN0eSIsImNhdGVnb3JpZXMiLCJnZXRPcGVyYXRpb25zRm9yQ2F0ZWdvcnkiLCJoaWRlRnJvbUxpc3QiLCJnZXRBbHRlcm5hdGl2ZU9wZXJhdGlvbnMiLCJnZXRDYXRlZ29yaWVzIiwiZ2V0SWZFeGlzdHMiLCJyZW5kZXJPcGVyYXRpb25zIiwicXVlcnlTdHJpbmciLCJyZW5kZXJCaW5hcnlRdWVyaWVzIiwicmVuZGVyQmluYXJ5UXVlcnkiLCJsZWZ0T3BlcmFuZCIsImJpbmFyeVF1ZXJ5IiwiaGFzQmluYXJ5T3AiLCJEcmFnZ2FibGUiLCJPcGVyYXRpb25IZWFkZXIiLCJnZXRPcGVyYXRpb25QYXJhbUVkaXRvciIsIk9wZXJhdGlvbkVkaXRvciIsInNob3VsZEhpZ2hsaWdodCIsInVzZUhpZ2hsaWdodCIsIm9uUGFyYW1WYWx1ZUNoYW5nZWQiLCJwYXJhbUlkeCIsImNhbGxQYXJhbUNoYW5nZWRUaGVuT25DaGFuZ2UiLCJvbkFkZFJlc3RQYXJhbSIsIm9uUmVtb3ZlUmVzdFBhcmFtIiwib3BlcmF0aW9uRWxlbWVudHMiLCJwYXJhbUluZGV4IiwicGFyYW1EZWYiLCJFZGl0b3IiLCJwYXJhbVJvdyIsInBhcmFtTmFtZSIsImluZm9JY29uIiwicGFyYW1WYWx1ZSIsImxhc3RQYXJhbURlZiIsInJlbmRlckFkZFJlc3RQYXJhbUJ1dHRvbiIsInByb3ZpZGVkIiwiY2FyZEhpZ2hsaWdodCIsImlubmVyUmVmIiwiZHJhZ2dhYmxlUHJvcHMiLCJkcmFnSGFuZGxlUHJvcHMiLCJhcnJvdyIsImFycm93TGluZSIsImFycm93QXJyb3ciLCJrZWVwSGlnaGxpZ2h0Iiwic2V0S2VlcEhpZ2hsaWdodCIsInBhcmFtQ2hhbmdlZEhhbmRsZXIiLCJwcmltYXJ5IiwiY3Vyc29yIiwiYm9yZGVyUmFkaXVzIiwic2hhcGUiLCJtYXJnaW5Cb3R0b20iLCJ0cmFuc2l0aW9uIiwiYm94U2hhZG93IiwiY29sb3IiLCJtYXJnaW4iLCJmb250V2VpZ2h0IiwiZm9udFdlaWdodE1lZGl1bSIsInRvcCIsImJhY2tncm91bmRDb2xvciIsInN0cm9uZyIsImJvcmRlclRvcCIsImJvcmRlckJvdHRvbSIsImJvcmRlckxlZnQiLCJyZW5kZXJNYXJrZG93biIsInN0ZXBOdW1iZXIiLCJtYXJrZG93biIsImJveCIsImJveElubmVyIiwianVzdGlmeUNvbnRlbnQiLCJwYWRkaW5nQm90dG9tIiwidGV4dERlY29yYXRpb24iLCJPcGVyYXRpb25JbmZvQnV0dG9uIiwib25Ub2dnbGVTd2l0Y2hlciIsImlzT3BlbiIsImFsdGVybmF0aXZlcyIsImFsdCIsIm9wZXJhdGlvbkhlYWRlckJ1dHRvbnMiLCJzZWxlY3RXcmFwcGVyIiwiY2hhbmdlZE9wIiwib3BhY2l0eSIsInRyYW5zaXRpb25zIiwiY3JlYXRlIiwiZHVyYXRpb24iLCJzaG9ydCIsInBhZGRpbmdSaWdodCIsInVzZVBvcHBlclRvb2x0aXAiLCJQb3J0YWwiLCJzaG93Iiwic2V0U2hvdyIsImdldFRvb2x0aXBQcm9wcyIsInNldFRvb2x0aXBSZWYiLCJzZXRUcmlnZ2VyUmVmIiwidmlzaWJsZSIsInBsYWNlbWVudCIsIm9uVmlzaWJsZUNoYW5nZSIsImludGVyYWN0aXZlIiwidHJpZ2dlciIsImRvY0JveCIsImRvY0JveEhlYWRlciIsImRvY0JveEJvZHkiLCJnZXRPcGVyYXRpb25Eb2NzIiwib3ZlcmZsb3ciLCJzaGFkb3dzIiwiejMiLCJ6SW5kZXgiLCJ0b29sdGlwIiwiaDUiLCJzaWduYXR1cmUiLCJkcm9wZG93biIsIkRyYWdEcm9wQ29udGV4dCIsIkRyb3BwYWJsZSIsInVzZU1vdW50ZWRTdGF0ZSIsIkNhc2NhZGVyIiwib3BzVG9IaWdobGlnaHQiLCJ1c2VPcGVyYXRpb25zSGlnaGxpZ2h0IiwiY2FzY2FkZXJPcGVuIiwic2V0Q2FzY2FkZXJPcGVuIiwib25PcGVyYXRpb25DaGFuZ2UiLCJhZGRPcHRpb25zIiwiaXNMZWFmIiwib25BZGRPcGVyYXRpb24iLCJvcGVyYXRpb25EZWYiLCJvbkRyYWdFbmQiLCJkZXN0aW5hdGlvbiIsImVsZW1lbnQiLCJzb3VyY2UiLCJvbkNhc2NhZGVyQmx1ciIsIm9wZXJhdGlvbkxpc3QiLCJkcm9wcGFibGVQcm9wcyIsImFkZEJ1dHRvbiIsImlzTW91bnRlZCIsInByZXZPcGVyYXRpb25zIiwibmV3T3BzIiwibmV3T3AiLCJpc1NhbWVPcCIsIm9wMSIsIm9wMiIsImhlYWRpbmciLCJmbGV4V3JhcCIsIkNoZWNrYm94IiwiU2VsZWN0SW5wdXRQYXJhbUVkaXRvciIsIkJvb2xJbnB1dFBhcmFtRWRpdG9yIiwiU2ltcGxlSW5wdXRQYXJhbUVkaXRvciIsInNlbGVjdE9wdGlvbnMiLCJ2YWx1ZU9wdGlvbiIsInJvb3QiLCJUYWciLCJlZGl0b3JNb2RlcyIsImNvbXBvbmVudCIsIm1vZGUiLCJ1bmlxdWVJZCIsInVzZVJlZiIsImlucHV0UHJvcHMiLCJkYXNoZWRMYWJlbCIsInN3aXRjaElkUmVmIiwic3dpdGNoTGFiZWwiLCJ1c2VUb2dnbGUiLCJjb2xsYXBzZWRJbmZvIiwidG9nZ2xlT3BlbiIsInRvZ2dsZSIsImVtcGhhc2l6ZSIsImZsZXhHcm93IiwicGFkZGluZ1RvcCIsIm1hcmdpblJpZ2h0IiwicGx1cmFsaXplIiwicmVuZGVyUGFyYW1zIiwicmFuZ2VSZW5kZXJlcldpdGhQYXJhbXMiLCJyZW5kZXJMZWZ0IiwiZ2V0T25MYWJlbEFkZGVkSGFuZGxlciIsImdldEFnZ3JlZ2F0aW9uRXhwbGFpbmVyIiwiZ2V0QWdncmVnYXRpb25CeVJlbmRlcmVyIiwiZ2V0TGFzdExhYmVsUmVtb3ZlZEhhbmRsZXIiLCJnZXRBZ2dyZWdhdGlvbldpdGhvdXRSZW5kZXJlciIsInBhcmFtc0RlZiIsImdldEFnZ3JlZ2F0aW9uQnlSZW5kZXJlcldpdGhQYXJhbWV0ZXIiLCJhZ2dyZWdhdGlvbiIsImFnZ3JlZ2F0aW9uUmVuZGVyZXIiLCJhZ2dyZWdhdGlvbk5hbWUiLCJhZ2dyZWdhdGlvbkV4cGxhaW5lciIsImxhYmVsV29yZCIsIm1hcFR5cGUiLCJyZXN0UGFyYW1zIiwiY2hhbmdlVG9PcGVyYXRpb25JZCIsIm9uUGFyYW1DaGFuZ2VkIiwicGFyZW50VHlwZSIsInZhcmlhYmxlUmVnZXgiLCJ2YXIxIiwidmFyMiIsImZtdDIiLCJ2YXIzIiwiZmllbGRQYXRoIiwiZm10MyIsImZtdCIsInZhclR5cGUiLCJ2YXJUeXBlRnVuYyIsInJldHVyblZhcmlhYmxlcyIsIm51bWJlck5vZGUiLCJoYXNCb29sIiwicG9zIiwiY2hpbGRBZnRlciIsImpzb24iLCJ0b0pzb24iLCJqc29uVG9UZXh0IiwidHJlZUpzb24iLCJub2RlVG9TdHJpbmciLCJpbmRlbnQiLCJuZXdJbmRlbnQiLCJpc0xhc3RDaGlsZCIsImRlc2NlbmRpbmciLCJkZXZpYXRpb24iLCJwYXJ0aXRpb24iLCJBcnJheURhdGFGcmFtZSIsIkRhdGFUb3BpYyIsImZvcm1hdExhYmVscyIsImdldERpc3BsYXlQcm9jZXNzb3IiLCJUSU1FX1NFUklFU19USU1FX0ZJRUxEX05BTUUiLCJUSU1FX1NFUklFU19WQUxVRV9GSUVMRF9OQU1FIiwiRGF0YUZyYW1lVHlwZSIsImlzRXhlbXBsYXJEYXRhIiwiaXNNYXRyaXhEYXRhIiwiSU5GSU5JVFlfU0FNUExFX1JFR0VYIiwiaXNUYWJsZVJlc3VsdCIsImlzSGVhdG1hcFJlc3VsdCIsInRhYmxlRnJhbWVzIiwiZnJhbWVzV2l0aG91dFRhYmxlIiwiZGYiLCJwcm9jZXNzZWRUYWJsZUZyYW1lcyIsInRyYW5zZm9ybURGVG9UYWJsZSIsImV4ZW1wbGFyRnJhbWVzIiwiZnJhbWVzV2l0aG91dFRhYmxlQW5kRXhlbXBsYXJzIiwiZGVzdGluYXRpb25zIiwicHJvY2Vzc2VkRXhlbXBsYXJGcmFtZXMiLCJleGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbiIsInRyYWNlSURGaWVsZCIsImdldERhdGFMaW5rcyIsImRhdGFUb3BpYyIsIkFubm90YXRpb25zIiwiaGVhdG1hcFJlc3VsdHMiLCJmcmFtZXNXaXRob3V0VGFibGVIZWF0bWFwc0FuZEV4ZW1wbGFycyIsInByb2Nlc3NlZEhlYXRtYXBGcmFtZXMiLCJtZXJnZUhlYXRtYXBGcmFtZXMiLCJ0cmFuc2Zvcm1Ub0hpc3RvZ3JhbU92ZXJUaW1lIiwic29ydFNlcmllc0J5TGFiZWwiLCJvdGhlckZyYW1lcyIsImRmcyIsImRhdGFGcmFtZXNCeVJlZklkIiwicmVmSWRzIiwidmFsdWVUZXh0IiwiZ2V0VmFsdWVUZXh0IiwiZ2V0VmFsdWVGaWVsZCIsInZhbHVlTmFtZSIsImdldFRpbWVGaWVsZCIsImZyYW1lVmFsdWVGaWVsZCIsInByb21MYWJlbHMiLCJudW1iZXJGaWVsZCIsInBhcnNlU2FtcGxlVmFsdWUiLCJsYWJlbHNGb3JGaWVsZCIsImdldExhYmVsVmFsdWUiLCJyZXNwb25zZUxlbmd0aCIsInRyYW5zZm9ybU9wdGlvbnMiLCJwcm9tZXRoZXVzUmVzdWx0IiwiZXZlbnRzIiwiZXhlbXBsYXJEYXRhIiwiZXhlbXBsYXJzIiwic2FtcGxlZEV4ZW1wbGFycyIsInNhbXBsZUV4ZW1wbGFycyIsInRhYmxlRGF0YSIsInRyYW5zZm9ybU1ldHJpY0RhdGFUb1RhYmxlIiwidHJhbnNmb3JtVG9EYXRhRnJhbWUiLCJ0YXJnZXRCbGFuayIsImJ1Y2tldGVkRXhlbXBsYXJzIiwiYWxpZ25lZFRzIiwic3RhbmRhcmREZXZpYXRpb24iLCJzYW1wbGVkQnVja2V0cyIsImV4ZW1wbGFyc0luQnVja2V0IiwiYnVja2V0VmFsdWVzIiwiZXgiLCJzYW1wbGVkQnVja2V0VmFsdWVzIiwiY3VyciIsImNyZWF0ZUxhYmVsSW5mbyIsInN0ZXBNcyIsImJhc2VUaW1lc3RhbXAiLCJkcHMiLCJkcFZhbHVlIiwiZW5kVGltZXN0YW1wIiwicGFyc2VWYWx1ZSIsImRpc3BsYXlOYW1lRnJvbURTIiwibWQiLCJtZXRyaWNGaWVsZHMiLCJtZXRyaWNGaWVsZCIsImhhc093blByb3BlcnR5IiwiaXNNcyIsImxhYmVsc1dpdGhvdXROYW1lIiwiY291bnRGaWVsZHMiLCJIZWF0bWFwQnVja2V0cyIsInNlcmllc0xpc3QiLCJ0b3BTZXJpZXMiLCJib3R0b21TZXJpZXMiLCJqIiwiYm90dG9tUG9pbnQiLCJzMSIsInMyIiwibGUxIiwibGUyIiwiTGVnZW5kRm9ybWF0TW9kZSIsIlN0YW5kYXJkVmFyaWFibGVTdXBwb3J0IiwibWV0cmljRmluZFN0cmVhbSIsInRvRGF0YVF1ZXJ5Il0sInNvdXJjZVJvb3QiOiIifQ==