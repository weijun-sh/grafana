(self["webpackChunkgrafana"] = self["webpackChunkgrafana"] || []).push([["visjs-network"],{

/***/ "./.yarn/cache/visjs-network-npm-4.25.0-2e90efaeed-40bfcbbf2b.zip/node_modules/visjs-network/dist/vis.js":
/***/ (function(module) {

/**
 * vis.js
 * https://github.com/almende/vis
 *
 * A dynamic, browser-based visualization library.
 *
 * @version 4.25.0
 * @date    2018-09-20
 *
 * @license
 * Copyright (C) 2011-2017 Almende B.V, http://almende.com
 *
 * Vis.js is dual licensed under both
 *
 * * The Apache 2.0 License
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * and
 *
 * * The MIT License
 *   http://opensource.org/licenses/MIT
 *
 * Vis.js may be distributed under either license.
 */

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __nested_webpack_require_1040__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_1040__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nested_webpack_require_1040__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__nested_webpack_require_1040__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__nested_webpack_require_1040__.d = function(exports, name, getter) {
/******/ 		if(!__nested_webpack_require_1040__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__nested_webpack_require_1040__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__nested_webpack_require_1040__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__nested_webpack_require_1040__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__nested_webpack_require_1040__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_1040__(__nested_webpack_require_1040__.s = 85);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

/***/ }),
/* 1 */
/***/ (function(module, exports, __nested_webpack_require_3604__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __nested_webpack_require_3604__(130);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

/***/ }),
/* 2 */
/***/ (function(module, exports, __nested_webpack_require_4566__) {

"use strict";


var _getIterator2 = __nested_webpack_require_4566__(58);

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _create = __nested_webpack_require_4566__(31);

var _create2 = _interopRequireDefault(_create);

var _keys = __nested_webpack_require_4566__(9);

var _keys2 = _interopRequireDefault(_keys);

var _typeof2 = __nested_webpack_require_4566__(7);

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

// utility functions

// first check if moment.js is already loaded in the browser window, if so,
// use this instance. Else, load via commonjs.

var moment = __nested_webpack_require_4566__(71);
var uuid = __nested_webpack_require_4566__(119);

/**
 * Test whether given object is a number
 * @param {*} object
 * @return {Boolean} isNumber
 */
exports.isNumber = function (object) {
  return object instanceof Number || typeof object == 'number';
};

/**
 * Remove everything in the DOM object
 * @param {Element} DOMobject
 */
exports.recursiveDOMDelete = function (DOMobject) {
  if (DOMobject) {
    while (DOMobject.hasChildNodes() === true) {
      exports.recursiveDOMDelete(DOMobject.firstChild);
      DOMobject.removeChild(DOMobject.firstChild);
    }
  }
};

/**
 * Test whether given object is a string
 * @param {*} object
 * @return {Boolean} isString
 */
exports.isString = function (object) {
  return object instanceof String || typeof object == 'string';
};

/**
 * Test whether given object is a Date, or a String containing a Date
 * @param {Date | String} object
 * @return {Boolean} isDate
 */
exports.isDate = function (object) {
  if (object instanceof Date) {
    return true;
  } else if (exports.isString(object)) {
    // test whether this string contains a date
    var match = ASPDateRegex.exec(object);
    if (match) {
      return true;
    } else if (!isNaN(Date.parse(object))) {
      return true;
    }
  }

  return false;
};

/**
 * Create a UUID
 * @return {string} uuid
 */
exports.randomUUID = function () {
  return uuid.v4();
};

/**
 * Copy property from b to a if property present in a.
 * If property in b explicitly set to null, delete it if `allowDeletion` set.
 *
 * Internal helper routine, should not be exported. Not added to `exports` for that reason.
 *
 * @param {object} a  target object
 * @param {object} b  source object
 * @param {string} prop  name of property to copy to a
 * @param {boolean} allowDeletion  if true, delete property in a if explicitly set to null in b
 * @private
 */
function copyOrDelete(a, b, prop, allowDeletion) {
  var doDeletion = false;
  if (allowDeletion === true) {
    doDeletion = b[prop] === null && a[prop] !== undefined;
  }

  if (doDeletion) {
    delete a[prop];
  } else {
    a[prop] = b[prop]; // Remember, this is a reference copy!
  }
}

/**
 * Fill an object with a possibly partially defined other object.
 *
 * Only copies values for the properties already present in a.
 * That means an object is not created on a property if only the b object has it.
 *
 * @param {object} a
 * @param {object} b
 * @param {boolean} [allowDeletion=false]  if true, delete properties in a that are explicitly set to null in b
 */
exports.fillIfDefined = function (a, b) {
  var allowDeletion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  // NOTE: iteration of properties of a
  // NOTE: prototype properties iterated over as well
  for (var prop in a) {
    if (b[prop] !== undefined) {
      if (b[prop] === null || (0, _typeof3['default'])(b[prop]) !== 'object') {
        // Note: typeof null === 'object'
        copyOrDelete(a, b, prop, allowDeletion);
      } else {
        if ((0, _typeof3['default'])(a[prop]) === 'object') {
          exports.fillIfDefined(a[prop], b[prop], allowDeletion);
        }
      }
    }
  }
};

/**
 * Extend object a with the properties of object b or a series of objects
 * Only properties with defined values are copied
 * @param {Object} a
 * @param {...Object} b
 * @return {Object} a
 */
exports.extend = function (a /* b */) {
  // eslint-disable-line no-unused-vars
  for (var i = 1; i < arguments.length; i++) {
    var other = arguments[i];
    for (var prop in other) {
      if (other.hasOwnProperty(prop)) {
        a[prop] = other[prop];
      }
    }
  }
  return a;
};

/**
 * Extend object a with selected properties of object b or a series of objects
 * Only properties with defined values are copied
 * @param {Array.<string>} props
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 */
exports.selectiveExtend = function (props, a /* b */) {
  // eslint-disable-line no-unused-vars
  if (!Array.isArray(props)) {
    throw new Error('Array with property names expected as first argument');
  }

  for (var i = 2; i < arguments.length; i++) {
    var other = arguments[i];

    for (var p = 0; p < props.length; p++) {
      var prop = props[p];
      if (other && other.hasOwnProperty(prop)) {
        a[prop] = other[prop];
      }
    }
  }
  return a;
};

/**
 * Extend object a with selected properties of object b.
 * Only properties with defined values are copied.
 *
 * **Note:** Previous version of this routine implied that multiple source objects
 *           could be used; however, the implementation was **wrong**.
 *           Since multiple (>1) sources weren't used anywhere in the `vis.js` code,
 *           this has been removed
 *
 * @param {Array.<string>} props names of first-level properties to copy over
 * @param {object} a  target object
 * @param {object} b  source object
 * @param {boolean} [allowDeletion=false]  if true, delete property in a if explicitly set to null in b
 * @returns {Object} a
 */
exports.selectiveDeepExtend = function (props, a, b) {
  var allowDeletion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  // TODO: add support for Arrays to deepExtend
  if (Array.isArray(b)) {
    throw new TypeError('Arrays are not supported by deepExtend');
  }

  for (var p = 0; p < props.length; p++) {
    var prop = props[p];
    if (b.hasOwnProperty(prop)) {
      if (b[prop] && b[prop].constructor === Object) {
        if (a[prop] === undefined) {
          a[prop] = {};
        }
        if (a[prop].constructor === Object) {
          exports.deepExtend(a[prop], b[prop], false, allowDeletion);
        } else {
          copyOrDelete(a, b, prop, allowDeletion);
        }
      } else if (Array.isArray(b[prop])) {
        throw new TypeError('Arrays are not supported by deepExtend');
      } else {
        copyOrDelete(a, b, prop, allowDeletion);
      }
    }
  }
  return a;
};

/**
 * Extend object `a` with properties of object `b`, ignoring properties which are explicitly
 * specified to be excluded.
 *
 * The properties of `b` are considered for copying.
 * Properties which are themselves objects are are also extended.
 * Only properties with defined values are copied
 *
 * @param {Array.<string>} propsToExclude  names of properties which should *not* be copied
 * @param {Object}                      a  object to extend
 * @param {Object}                      b  object to take properties from for extension
 * @param {boolean} [allowDeletion=false]  if true, delete properties in a that are explicitly set to null in b
 * @return {Object} a
 */
exports.selectiveNotDeepExtend = function (propsToExclude, a, b) {
  var allowDeletion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  // TODO: add support for Arrays to deepExtend
  // NOTE: array properties have an else-below; apparently, there is a problem here.
  if (Array.isArray(b)) {
    throw new TypeError('Arrays are not supported by deepExtend');
  }

  for (var prop in b) {
    if (!b.hasOwnProperty(prop)) continue; // Handle local properties only
    if (propsToExclude.indexOf(prop) !== -1) continue; // In exclusion list, skip

    if (b[prop] && b[prop].constructor === Object) {
      if (a[prop] === undefined) {
        a[prop] = {};
      }
      if (a[prop].constructor === Object) {
        exports.deepExtend(a[prop], b[prop]); // NOTE: allowDeletion not propagated!
      } else {
        copyOrDelete(a, b, prop, allowDeletion);
      }
    } else if (Array.isArray(b[prop])) {
      a[prop] = [];
      for (var i = 0; i < b[prop].length; i++) {
        a[prop].push(b[prop][i]);
      }
    } else {
      copyOrDelete(a, b, prop, allowDeletion);
    }
  }

  return a;
};

/**
 * Deep extend an object a with the properties of object b
 *
 * @param {Object} a
 * @param {Object} b
 * @param {boolean} [protoExtend=false]  If true, the prototype values will also be extended.
 *                          (ie. the options objects that inherit from others will also get the inherited options)
 * @param {boolean} [allowDeletion=false] If true, the values of fields that are null will be deleted
 * @returns {Object}
 */
exports.deepExtend = function (a, b) {
  var protoExtend = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var allowDeletion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  for (var prop in b) {
    if (b.hasOwnProperty(prop) || protoExtend === true) {
      if (b[prop] && b[prop].constructor === Object) {
        if (a[prop] === undefined) {
          a[prop] = {};
        }
        if (a[prop].constructor === Object) {
          exports.deepExtend(a[prop], b[prop], protoExtend); // NOTE: allowDeletion not propagated!
        } else {
          copyOrDelete(a, b, prop, allowDeletion);
        }
      } else if (Array.isArray(b[prop])) {
        a[prop] = [];
        for (var i = 0; i < b[prop].length; i++) {
          a[prop].push(b[prop][i]);
        }
      } else {
        copyOrDelete(a, b, prop, allowDeletion);
      }
    }
  }
  return a;
};

/**
 * Test whether all elements in two arrays are equal.
 * @param {Array} a
 * @param {Array} b
 * @return {boolean} Returns true if both arrays have the same length and same
 *                   elements.
 */
exports.equalArray = function (a, b) {
  if (a.length != b.length) return false;

  for (var i = 0, len = a.length; i < len; i++) {
    if (a[i] != b[i]) return false;
  }

  return true;
};

/**
 * Convert an object to another type
 * @param {boolean | number | string | Date | Moment | Null | undefined} object
 * @param {string | undefined} type   Name of the type. Available types:
 *                                    'Boolean', 'Number', 'String',
 *                                    'Date', 'Moment', ISODate', 'ASPDate'.
 * @return {*} object
 * @throws Error
 */
exports.convert = function (object, type) {
  var match;

  if (object === undefined) {
    return undefined;
  }
  if (object === null) {
    return null;
  }

  if (!type) {
    return object;
  }
  if (!(typeof type === 'string') && !(type instanceof String)) {
    throw new Error('Type must be a string');
  }

  //noinspection FallthroughInSwitchStatementJS
  switch (type) {
    case 'boolean':
    case 'Boolean':
      return Boolean(object);

    case 'number':
    case 'Number':
      if (exports.isString(object) && !isNaN(Date.parse(object))) {
        return moment(object).valueOf();
      } else {
        return Number(object.valueOf());
      }
    case 'string':
    case 'String':
      return String(object);

    case 'Date':
      if (exports.isNumber(object)) {
        return new Date(object);
      }
      if (object instanceof Date) {
        return new Date(object.valueOf());
      } else if (moment.isMoment(object)) {
        return new Date(object.valueOf());
      }
      if (exports.isString(object)) {
        match = ASPDateRegex.exec(object);
        if (match) {
          // object is an ASP date
          return new Date(Number(match[1])); // parse number
        } else {
          return moment(new Date(object)).toDate(); // parse string
        }
      } else {
        throw new Error('Cannot convert object of type ' + exports.getType(object) + ' to type Date');
      }

    case 'Moment':
      if (exports.isNumber(object)) {
        return moment(object);
      }
      if (object instanceof Date) {
        return moment(object.valueOf());
      } else if (moment.isMoment(object)) {
        return moment(object);
      }
      if (exports.isString(object)) {
        match = ASPDateRegex.exec(object);
        if (match) {
          // object is an ASP date
          return moment(Number(match[1])); // parse number
        } else {
          return moment(object); // parse string
        }
      } else {
        throw new Error('Cannot convert object of type ' + exports.getType(object) + ' to type Date');
      }

    case 'ISODate':
      if (exports.isNumber(object)) {
        return new Date(object);
      } else if (object instanceof Date) {
        return object.toISOString();
      } else if (moment.isMoment(object)) {
        return object.toDate().toISOString();
      } else if (exports.isString(object)) {
        match = ASPDateRegex.exec(object);
        if (match) {
          // object is an ASP date
          return new Date(Number(match[1])).toISOString(); // parse number
        } else {
          return moment(object).format(); // ISO 8601
        }
      } else {
        throw new Error('Cannot convert object of type ' + exports.getType(object) + ' to type ISODate');
      }

    case 'ASPDate':
      if (exports.isNumber(object)) {
        return '/Date(' + object + ')/';
      } else if (object instanceof Date) {
        return '/Date(' + object.valueOf() + ')/';
      } else if (exports.isString(object)) {
        match = ASPDateRegex.exec(object);
        var value;
        if (match) {
          // object is an ASP date
          value = new Date(Number(match[1])).valueOf(); // parse number
        } else {
          value = new Date(object).valueOf(); // parse string
        }
        return '/Date(' + value + ')/';
      } else {
        throw new Error('Cannot convert object of type ' + exports.getType(object) + ' to type ASPDate');
      }

    default:
      throw new Error('Unknown type "' + type + '"');
  }
};

// parse ASP.Net Date pattern,
// for example '/Date(1198908717056)/' or '/Date(1198908717056-0700)/'
// code from http://momentjs.com/
var ASPDateRegex = /^\/?Date\((\-?\d+)/i;

/**
 * Get the type of an object, for example exports.getType([]) returns 'Array'
 * @param {*} object
 * @return {string} type
 */
exports.getType = function (object) {
  var type = typeof object === 'undefined' ? 'undefined' : (0, _typeof3['default'])(object);

  if (type == 'object') {
    if (object === null) {
      return 'null';
    }
    if (object instanceof Boolean) {
      return 'Boolean';
    }
    if (object instanceof Number) {
      return 'Number';
    }
    if (object instanceof String) {
      return 'String';
    }
    if (Array.isArray(object)) {
      return 'Array';
    }
    if (object instanceof Date) {
      return 'Date';
    }
    return 'Object';
  } else if (type == 'number') {
    return 'Number';
  } else if (type == 'boolean') {
    return 'Boolean';
  } else if (type == 'string') {
    return 'String';
  } else if (type === undefined) {
    return 'undefined';
  }

  return type;
};

/**
 * Used to extend an array and copy it. This is used to propagate paths recursively.
 *
 * @param {Array} arr
 * @param {*} newValue
 * @returns {Array}
 */
exports.copyAndExtendArray = function (arr, newValue) {
  var newArr = [];
  for (var i = 0; i < arr.length; i++) {
    newArr.push(arr[i]);
  }
  newArr.push(newValue);
  return newArr;
};

/**
 * Used to extend an array and copy it. This is used to propagate paths recursively.
 *
 * @param {Array} arr
 * @returns {Array}
 */
exports.copyArray = function (arr) {
  var newArr = [];
  for (var i = 0; i < arr.length; i++) {
    newArr.push(arr[i]);
  }
  return newArr;
};

/**
 * Retrieve the absolute left value of a DOM element
 * @param {Element} elem        A dom element, for example a div
 * @return {number} left        The absolute left position of this element
 *                              in the browser page.
 */
exports.getAbsoluteLeft = function (elem) {
  return elem.getBoundingClientRect().left;
};

exports.getAbsoluteRight = function (elem) {
  return elem.getBoundingClientRect().right;
};

/**
 * Retrieve the absolute top value of a DOM element
 * @param {Element} elem        A dom element, for example a div
 * @return {number} top        The absolute top position of this element
 *                              in the browser page.
 */
exports.getAbsoluteTop = function (elem) {
  return elem.getBoundingClientRect().top;
};

/**
 * add a className to the given elements style
 * @param {Element} elem
 * @param {string} classNames
 */
exports.addClassName = function (elem, classNames) {
  var classes = elem.className.split(' ');
  var newClasses = classNames.split(' ');
  classes = classes.concat(newClasses.filter(function (className) {
    return classes.indexOf(className) < 0;
  }));
  elem.className = classes.join(' ');
};

/**
 * add a className to the given elements style
 * @param {Element} elem
 * @param {string} classNames
 */
exports.removeClassName = function (elem, classNames) {
  var classes = elem.className.split(' ');
  var oldClasses = classNames.split(' ');
  classes = classes.filter(function (className) {
    return oldClasses.indexOf(className) < 0;
  });
  elem.className = classes.join(' ');
};

/**
 * For each method for both arrays and objects.
 * In case of an array, the built-in Array.forEach() is applied. (**No, it's not!**)
 * In case of an Object, the method loops over all properties of the object.
 * @param {Object | Array} object   An Object or Array
 * @param {function} callback       Callback method, called for each item in
 *                                  the object or array with three parameters:
 *                                  callback(value, index, object)
 */
exports.forEach = function (object, callback) {
  var i, len;
  if (Array.isArray(object)) {
    // array
    for (i = 0, len = object.length; i < len; i++) {
      callback(object[i], i, object);
    }
  } else {
    // object
    for (i in object) {
      if (object.hasOwnProperty(i)) {
        callback(object[i], i, object);
      }
    }
  }
};

/**
 * Convert an object into an array: all objects properties are put into the
 * array. The resulting array is unordered.
 * @param {Object} object
 * @returns {Array} array
 */
exports.toArray = function (object) {
  var array = [];

  for (var prop in object) {
    if (object.hasOwnProperty(prop)) array.push(object[prop]);
  }

  return array;
};

/**
 * Update a property in an object
 * @param {Object} object
 * @param {string} key
 * @param {*} value
 * @return {Boolean} changed
 */
exports.updateProperty = function (object, key, value) {
  if (object[key] !== value) {
    object[key] = value;
    return true;
  } else {
    return false;
  }
};

/**
 * Throttle the given function to be only executed once per animation frame
 * @param {function} fn
 * @returns {function} Returns the throttled function
 */
exports.throttle = function (fn) {
  var scheduled = false;

  return function throttled() {
    if (!scheduled) {
      scheduled = true;
      requestAnimationFrame(function () {
        scheduled = false;
        fn();
      });
    }
  };
};

/**
 * Add and event listener. Works for all browsers
 * @param {Element}     element    An html element
 * @param {string}      action     The action, for example "click",
 *                                 without the prefix "on"
 * @param {function}    listener   The callback function to be executed
 * @param {boolean}     [useCapture]
 */
exports.addEventListener = function (element, action, listener, useCapture) {
  if (element.addEventListener) {
    if (useCapture === undefined) useCapture = false;

    if (action === 'mousewheel' && navigator.userAgent.indexOf('Firefox') >= 0) {
      action = 'DOMMouseScroll'; // For Firefox
    }

    element.addEventListener(action, listener, useCapture);
  } else {
    element.attachEvent('on' + action, listener); // IE browsers
  }
};

/**
 * Remove an event listener from an element
 * @param {Element}     element         An html dom element
 * @param {string}      action          The name of the event, for example "mousedown"
 * @param {function}    listener        The listener function
 * @param {boolean}     [useCapture]
 */
exports.removeEventListener = function (element, action, listener, useCapture) {
  if (element.removeEventListener) {
    // non-IE browsers
    if (useCapture === undefined) useCapture = false;

    if (action === 'mousewheel' && navigator.userAgent.indexOf('Firefox') >= 0) {
      action = 'DOMMouseScroll'; // For Firefox
    }

    element.removeEventListener(action, listener, useCapture);
  } else {
    // IE browsers
    element.detachEvent('on' + action, listener);
  }
};

/**
 * Cancels the event if it is cancelable, without stopping further propagation of the event.
 * @param {Event} event
 */
exports.preventDefault = function (event) {
  if (!event) event = window.event;

  if (event.preventDefault) {
    event.preventDefault(); // non-IE browsers
  } else {
    event.returnValue = false; // IE browsers
  }
};

/**
 * Get HTML element which is the target of the event
 * @param {Event} event
 * @return {Element} target element
 */
exports.getTarget = function (event) {
  // code from http://www.quirksmode.org/js/events_properties.html
  if (!event) {
    event = window.event;
  }

  var target;

  if (event.target) {
    target = event.target;
  } else if (event.srcElement) {
    target = event.srcElement;
  }

  if (target.nodeType != undefined && target.nodeType == 3) {
    // defeat Safari bug
    target = target.parentNode;
  }

  return target;
};

/**
 * Check if given element contains given parent somewhere in the DOM tree
 * @param {Element} element
 * @param {Element} parent
 * @returns {boolean}
 */
exports.hasParent = function (element, parent) {
  var e = element;

  while (e) {
    if (e === parent) {
      return true;
    }
    e = e.parentNode;
  }

  return false;
};

exports.option = {};

/**
 * Convert a value into a boolean
 * @param {Boolean | function | undefined} value
 * @param {boolean} [defaultValue]
 * @returns {Boolean} bool
 */
exports.option.asBoolean = function (value, defaultValue) {
  if (typeof value == 'function') {
    value = value();
  }

  if (value != null) {
    return value != false;
  }

  return defaultValue || null;
};

/**
 * Convert a value into a number
 * @param {Boolean | function | undefined} value
 * @param {number} [defaultValue]
 * @returns {number} number
 */
exports.option.asNumber = function (value, defaultValue) {
  if (typeof value == 'function') {
    value = value();
  }

  if (value != null) {
    return Number(value) || defaultValue || null;
  }

  return defaultValue || null;
};

/**
 * Convert a value into a string
 * @param {string | function | undefined} value
 * @param {string} [defaultValue]
 * @returns {String} str
 */
exports.option.asString = function (value, defaultValue) {
  if (typeof value == 'function') {
    value = value();
  }

  if (value != null) {
    return String(value);
  }

  return defaultValue || null;
};

/**
 * Convert a size or location into a string with pixels or a percentage
 * @param {string | number | function | undefined} value
 * @param {string} [defaultValue]
 * @returns {String} size
 */
exports.option.asSize = function (value, defaultValue) {
  if (typeof value == 'function') {
    value = value();
  }

  if (exports.isString(value)) {
    return value;
  } else if (exports.isNumber(value)) {
    return value + 'px';
  } else {
    return defaultValue || null;
  }
};

/**
 * Convert a value into a DOM element
 * @param {HTMLElement | function | undefined} value
 * @param {HTMLElement} [defaultValue]
 * @returns {HTMLElement | null} dom
 */
exports.option.asElement = function (value, defaultValue) {
  if (typeof value == 'function') {
    value = value();
  }

  return value || defaultValue || null;
};

/**
 * http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
 *
 * @param {string} hex
 * @returns {{r: *, g: *, b: *}} | 255 range
 */
exports.hexToRGB = function (hex) {
  // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
  var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
  hex = hex.replace(shorthandRegex, function (m, r, g, b) {
    return r + r + g + g + b + b;
  });
  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? {
    r: parseInt(result[1], 16),
    g: parseInt(result[2], 16),
    b: parseInt(result[3], 16)
  } : null;
};

/**
 * This function takes color in hex format or rgb() or rgba() format and overrides the opacity. Returns rgba() string.
 * @param {string} color
 * @param {number} opacity
 * @returns {String}
 */
exports.overrideOpacity = function (color, opacity) {
  var rgb;
  if (color.indexOf('rgba') != -1) {
    return color;
  } else if (color.indexOf('rgb') != -1) {
    rgb = color.substr(color.indexOf('(') + 1).replace(')', '').split(',');
    return 'rgba(' + rgb[0] + ',' + rgb[1] + ',' + rgb[2] + ',' + opacity + ')';
  } else {
    rgb = exports.hexToRGB(color);
    if (rgb == null) {
      return color;
    } else {
      return 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + opacity + ')';
    }
  }
};

/**
 *
 * @param {number} red     0 -- 255
 * @param {number} green   0 -- 255
 * @param {number} blue    0 -- 255
 * @returns {String}
 * @constructor
 */
exports.RGBToHex = function (red, green, blue) {
  return '#' + ((1 << 24) + (red << 16) + (green << 8) + blue).toString(16).slice(1);
};

/**
 * Parse a color property into an object with border, background, and
 * highlight colors
 * @param {Object | String} color
 * @return {Object} colorObject
 */
exports.parseColor = function (color) {
  var c;
  if (exports.isString(color) === true) {
    if (exports.isValidRGB(color) === true) {
      var rgb = color.substr(4).substr(0, color.length - 5).split(',').map(function (value) {
        return parseInt(value);
      });
      color = exports.RGBToHex(rgb[0], rgb[1], rgb[2]);
    }
    if (exports.isValidHex(color) === true) {
      var hsv = exports.hexToHSV(color);
      var lighterColorHSV = {
        h: hsv.h,
        s: hsv.s * 0.8,
        v: Math.min(1, hsv.v * 1.02)
      };
      var darkerColorHSV = {
        h: hsv.h,
        s: Math.min(1, hsv.s * 1.25),
        v: hsv.v * 0.8
      };
      var darkerColorHex = exports.HSVToHex(darkerColorHSV.h, darkerColorHSV.s, darkerColorHSV.v);
      var lighterColorHex = exports.HSVToHex(lighterColorHSV.h, lighterColorHSV.s, lighterColorHSV.v);
      c = {
        background: color,
        border: darkerColorHex,
        highlight: {
          background: lighterColorHex,
          border: darkerColorHex
        },
        hover: {
          background: lighterColorHex,
          border: darkerColorHex
        }
      };
    } else {
      c = {
        background: color,
        border: color,
        highlight: {
          background: color,
          border: color
        },
        hover: {
          background: color,
          border: color
        }
      };
    }
  } else {
    c = {};
    c.background = color.background || undefined;
    c.border = color.border || undefined;

    if (exports.isString(color.highlight)) {
      c.highlight = {
        border: color.highlight,
        background: color.highlight
      };
    } else {
      c.highlight = {};
      c.highlight.background = color.highlight && color.highlight.background || undefined;
      c.highlight.border = color.highlight && color.highlight.border || undefined;
    }

    if (exports.isString(color.hover)) {
      c.hover = {
        border: color.hover,
        background: color.hover
      };
    } else {
      c.hover = {};
      c.hover.background = color.hover && color.hover.background || undefined;
      c.hover.border = color.hover && color.hover.border || undefined;
    }
  }

  return c;
};

/**
 * http://www.javascripter.net/faq/rgb2hsv.htm
 *
 * @param {number} red
 * @param {number} green
 * @param {number} blue
 * @returns {{h: number, s: number, v: number}}
 * @constructor
 */
exports.RGBToHSV = function (red, green, blue) {
  red = red / 255;
  green = green / 255;
  blue = blue / 255;
  var minRGB = Math.min(red, Math.min(green, blue));
  var maxRGB = Math.max(red, Math.max(green, blue));

  // Black-gray-white
  if (minRGB == maxRGB) {
    return { h: 0, s: 0, v: minRGB };
  }

  // Colors other than black-gray-white:
  var d = red == minRGB ? green - blue : blue == minRGB ? red - green : blue - red;
  var h = red == minRGB ? 3 : blue == minRGB ? 1 : 5;
  var hue = 60 * (h - d / (maxRGB - minRGB)) / 360;
  var saturation = (maxRGB - minRGB) / maxRGB;
  var value = maxRGB;
  return { h: hue, s: saturation, v: value };
};

var cssUtil = {
  // split a string with css styles into an object with key/values
  split: function split(cssText) {
    var styles = {};

    cssText.split(';').forEach(function (style) {
      if (style.trim() != '') {
        var parts = style.split(':');
        var key = parts[0].trim();
        var value = parts[1].trim();
        styles[key] = value;
      }
    });

    return styles;
  },

  // build a css text string from an object with key/values
  join: function join(styles) {
    return (0, _keys2['default'])(styles).map(function (key) {
      return key + ': ' + styles[key];
    }).join('; ');
  }

  /**
   * Append a string with css styles to an element
   * @param {Element} element
   * @param {string} cssText
   */
};exports.addCssText = function (element, cssText) {
  var currentStyles = cssUtil.split(element.style.cssText);
  var newStyles = cssUtil.split(cssText);
  var styles = exports.extend(currentStyles, newStyles);

  element.style.cssText = cssUtil.join(styles);
};

/**
 * Remove a string with css styles from an element
 * @param {Element} element
 * @param {string} cssText
 */
exports.removeCssText = function (element, cssText) {
  var styles = cssUtil.split(element.style.cssText);
  var removeStyles = cssUtil.split(cssText);

  for (var key in removeStyles) {
    if (removeStyles.hasOwnProperty(key)) {
      delete styles[key];
    }
  }

  element.style.cssText = cssUtil.join(styles);
};

/**
 * https://gist.github.com/mjijackson/5311256
 * @param {number} h
 * @param {number} s
 * @param {number} v
 * @returns {{r: number, g: number, b: number}}
 * @constructor
 */
exports.HSVToRGB = function (h, s, v) {
  var r, g, b;

  var i = Math.floor(h * 6);
  var f = h * 6 - i;
  var p = v * (1 - s);
  var q = v * (1 - f * s);
  var t = v * (1 - (1 - f) * s);

  switch (i % 6) {
    case 0:
      ;r = v, g = t, b = p;
      break;
    case 1:
      ;r = q, g = v, b = p;
      break;
    case 2:
      ;r = p, g = v, b = t;
      break;
    case 3:
      ;r = p, g = q, b = v;
      break;
    case 4:
      ;r = t, g = p, b = v;
      break;
    case 5:
      ;r = v, g = p, b = q;
      break;
  }

  return {
    r: Math.floor(r * 255),
    g: Math.floor(g * 255),
    b: Math.floor(b * 255)
  };
};

exports.HSVToHex = function (h, s, v) {
  var rgb = exports.HSVToRGB(h, s, v);
  return exports.RGBToHex(rgb.r, rgb.g, rgb.b);
};

exports.hexToHSV = function (hex) {
  var rgb = exports.hexToRGB(hex);
  return exports.RGBToHSV(rgb.r, rgb.g, rgb.b);
};

exports.isValidHex = function (hex) {
  var isOk = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(hex);
  return isOk;
};

exports.isValidRGB = function (rgb) {
  rgb = rgb.replace(' ', '');
  var isOk = /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/i.test(rgb);
  return isOk;
};
exports.isValidRGBA = function (rgba) {
  rgba = rgba.replace(' ', '');
  var isOk = /rgba\((\d{1,3}),(\d{1,3}),(\d{1,3}),(.{1,3})\)/i.test(rgba);
  return isOk;
};

/**
 * This recursively redirects the prototype of JSON objects to the referenceObject
 * This is used for default options.
 *
 * @param {Array.<string>} fields
 * @param {Object} referenceObject
 * @returns {*}
 */
exports.selectiveBridgeObject = function (fields, referenceObject) {
  if (referenceObject !== null && (typeof referenceObject === 'undefined' ? 'undefined' : (0, _typeof3['default'])(referenceObject)) === 'object') {
    // !!! typeof null === 'object'
    var objectTo = (0, _create2['default'])(referenceObject);
    for (var i = 0; i < fields.length; i++) {
      if (referenceObject.hasOwnProperty(fields[i])) {
        if ((0, _typeof3['default'])(referenceObject[fields[i]]) == 'object') {
          objectTo[fields[i]] = exports.bridgeObject(referenceObject[fields[i]]);
        }
      }
    }
    return objectTo;
  } else {
    return null;
  }
};

/**
 * This recursively redirects the prototype of JSON objects to the referenceObject
 * This is used for default options.
 *
 * @param {Object} referenceObject
 * @returns {*}
 */
exports.bridgeObject = function (referenceObject) {
  if (referenceObject !== null && (typeof referenceObject === 'undefined' ? 'undefined' : (0, _typeof3['default'])(referenceObject)) === 'object') {
    // !!! typeof null === 'object'
    var objectTo = (0, _create2['default'])(referenceObject);
    if (referenceObject instanceof Element) {
      // Avoid bridging DOM objects
      objectTo = referenceObject;
    } else {
      objectTo = (0, _create2['default'])(referenceObject);
      for (var i in referenceObject) {
        if (referenceObject.hasOwnProperty(i)) {
          if ((0, _typeof3['default'])(referenceObject[i]) == 'object') {
            objectTo[i] = exports.bridgeObject(referenceObject[i]);
          }
        }
      }
    }
    return objectTo;
  } else {
    return null;
  }
};

/**
 * This method provides a stable sort implementation, very fast for presorted data
 *
 * @param {Array} a the array
 * @param {function} compare an order comparator
 * @returns {Array}
 */
exports.insertSort = function (a, compare) {
  for (var i = 0; i < a.length; i++) {
    var k = a[i];
    for (var j = i; j > 0 && compare(k, a[j - 1]) < 0; j--) {
      a[j] = a[j - 1];
    }
    a[j] = k;
  }
  return a;
};

/**
 * This is used to set the options of subobjects in the options object.
 *
 * A requirement of these subobjects is that they have an 'enabled' element
 * which is optional for the user but mandatory for the program.
 *
 * The added value here of the merge is that option 'enabled' is set as required.
 *
 *
 * @param {object} mergeTarget   | either this.options or the options used for the groups.
 * @param {object} options       | options
 * @param {string} option        | option key in the options argument
 * @param {object} globalOptions | global options, passed in to determine value of option 'enabled'
 */
exports.mergeOptions = function (mergeTarget, options, option) {
  var globalOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  // Local helpers
  var isPresent = function isPresent(obj) {
    return obj !== null && obj !== undefined;
  };

  var isObject = function isObject(obj) {
    return obj !== null && (typeof obj === 'undefined' ? 'undefined' : (0, _typeof3['default'])(obj)) === 'object';
  };

  // https://stackoverflow.com/a/34491287/1223531
  var isEmpty = function isEmpty(obj) {
    for (var x in obj) {
      if (obj.hasOwnProperty(x)) return false;
    }
    return true;
  };

  // Guards
  if (!isObject(mergeTarget)) {
    throw new Error('Parameter mergeTarget must be an object');
  }

  if (!isObject(options)) {
    throw new Error('Parameter options must be an object');
  }

  if (!isPresent(option)) {
    throw new Error('Parameter option must have a value');
  }

  if (!isObject(globalOptions)) {
    throw new Error('Parameter globalOptions must be an object');
  }

  //
  // Actual merge routine, separated from main logic
  // Only a single level of options is merged. Deeper levels are ref'd. This may actually be an issue.
  //
  var doMerge = function doMerge(target, options, option) {
    if (!isObject(target[option])) {
      target[option] = {};
    }

    var src = options[option];
    var dst = target[option];
    for (var prop in src) {
      if (src.hasOwnProperty(prop)) {
        dst[prop] = src[prop];
      }
    }
  };

  // Local initialization
  var srcOption = options[option];
  var globalPassed = isObject(globalOptions) && !isEmpty(globalOptions);
  var globalOption = globalPassed ? globalOptions[option] : undefined;
  var globalEnabled = globalOption ? globalOption.enabled : undefined;

  /////////////////////////////////////////
  // Main routine
  /////////////////////////////////////////
  if (srcOption === undefined) {
    return; // Nothing to do
  }

  if (typeof srcOption === 'boolean') {
    if (!isObject(mergeTarget[option])) {
      mergeTarget[option] = {};
    }

    mergeTarget[option].enabled = srcOption;
    return;
  }

  if (srcOption === null && !isObject(mergeTarget[option])) {
    // If possible, explicit copy from globals
    if (isPresent(globalOption)) {
      mergeTarget[option] = (0, _create2['default'])(globalOption);
    } else {
      return; // Nothing to do
    }
  }

  if (!isObject(srcOption)) {
    return;
  }

  //
  // Ensure that 'enabled' is properly set. It is required internally
  // Note that the value from options will always overwrite the existing value
  //
  var enabled = true; // default value

  if (srcOption.enabled !== undefined) {
    enabled = srcOption.enabled;
  } else {
    // Take from globals, if present
    if (globalEnabled !== undefined) {
      enabled = globalOption.enabled;
    }
  }

  doMerge(mergeTarget, options, option);
  mergeTarget[option].enabled = enabled;
};

/**
 * This function does a binary search for a visible item in a sorted list. If we find a visible item, the code that uses
 * this function will then iterate in both directions over this sorted list to find all visible items.
 *
 * @param {Item[]} orderedItems       | Items ordered by start
 * @param {function} comparator       | -1 is lower, 0 is equal, 1 is higher
 * @param {string} field
 * @param {string} field2
 * @returns {number}
 * @private
 */
exports.binarySearchCustom = function (orderedItems, comparator, field, field2) {
  var maxIterations = 10000;
  var iteration = 0;
  var low = 0;
  var high = orderedItems.length - 1;

  while (low <= high && iteration < maxIterations) {
    var middle = Math.floor((low + high) / 2);

    var item = orderedItems[middle];
    var value = field2 === undefined ? item[field] : item[field][field2];

    var searchResult = comparator(value);
    if (searchResult == 0) {
      // jihaa, found a visible item!
      return middle;
    } else if (searchResult == -1) {
      // it is too small --> increase low
      low = middle + 1;
    } else {
      // it is too big --> decrease high
      high = middle - 1;
    }

    iteration++;
  }

  return -1;
};

/**
 * This function does a binary search for a specific value in a sorted array. If it does not exist but is in between of
 * two values, we return either the one before or the one after, depending on user input
 * If it is found, we return the index, else -1.
 *
 * @param {Array} orderedItems
 * @param {{start: number, end: number}} target
 * @param {string} field
 * @param {string} sidePreference   'before' or 'after'
 * @param {function} comparator an optional comparator, returning -1,0,1 for <,==,>.
 * @returns {number}
 * @private
 */
exports.binarySearchValue = function (orderedItems, target, field, sidePreference, comparator) {
  var maxIterations = 10000;
  var iteration = 0;
  var low = 0;
  var high = orderedItems.length - 1;
  var prevValue, value, nextValue, middle;

  comparator = comparator != undefined ? comparator : function (a, b) {
    return a == b ? 0 : a < b ? -1 : 1;
  };

  while (low <= high && iteration < maxIterations) {
    // get a new guess
    middle = Math.floor(0.5 * (high + low));
    prevValue = orderedItems[Math.max(0, middle - 1)][field];
    value = orderedItems[middle][field];
    nextValue = orderedItems[Math.min(orderedItems.length - 1, middle + 1)][field];

    if (comparator(value, target) == 0) {
      // we found the target
      return middle;
    } else if (comparator(prevValue, target) < 0 && comparator(value, target) > 0) {
      // target is in between of the previous and the current
      return sidePreference == 'before' ? Math.max(0, middle - 1) : middle;
    } else if (comparator(value, target) < 0 && comparator(nextValue, target) > 0) {
      // target is in between of the current and the next
      return sidePreference == 'before' ? middle : Math.min(orderedItems.length - 1, middle + 1);
    } else {
      // didnt find the target, we need to change our boundaries.
      if (comparator(value, target) < 0) {
        // it is too small --> increase low
        low = middle + 1;
      } else {
        // it is too big --> decrease high
        high = middle - 1;
      }
    }
    iteration++;
  }

  // didnt find anything. Return -1.
  return -1;
};

/*
 * Easing Functions - inspired from http://gizma.com/easing/
 * only considering the t value for the range [0, 1] => [0, 1]
 * https://gist.github.com/gre/1650294
 */
exports.easingFunctions = {
  // no easing, no acceleration
  linear: function linear(t) {
    return t;
  },
  // accelerating from zero velocity
  easeInQuad: function easeInQuad(t) {
    return t * t;
  },
  // decelerating to zero velocity
  easeOutQuad: function easeOutQuad(t) {
    return t * (2 - t);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function easeInOutQuad(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  },
  // accelerating from zero velocity
  easeInCubic: function easeInCubic(t) {
    return t * t * t;
  },
  // decelerating to zero velocity
  easeOutCubic: function easeOutCubic(t) {
    return --t * t * t + 1;
  },
  // acceleration until halfway, then deceleration
  easeInOutCubic: function easeInOutCubic(t) {
    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  },
  // accelerating from zero velocity
  easeInQuart: function easeInQuart(t) {
    return t * t * t * t;
  },
  // decelerating to zero velocity
  easeOutQuart: function easeOutQuart(t) {
    return 1 - --t * t * t * t;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function easeInOutQuart(t) {
    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
  },
  // accelerating from zero velocity
  easeInQuint: function easeInQuint(t) {
    return t * t * t * t * t;
  },
  // decelerating to zero velocity
  easeOutQuint: function easeOutQuint(t) {
    return 1 + --t * t * t * t * t;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuint: function easeInOutQuint(t) {
    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
  }
};

exports.getScrollBarWidth = function () {
  var inner = document.createElement('p');
  inner.style.width = '100%';
  inner.style.height = '200px';

  var outer = document.createElement('div');
  outer.style.position = 'absolute';
  outer.style.top = '0px';
  outer.style.left = '0px';
  outer.style.visibility = 'hidden';
  outer.style.width = '200px';
  outer.style.height = '150px';
  outer.style.overflow = 'hidden';
  outer.appendChild(inner);

  document.body.appendChild(outer);
  var w1 = inner.offsetWidth;
  outer.style.overflow = 'scroll';
  var w2 = inner.offsetWidth;
  if (w1 == w2) w2 = outer.clientWidth;

  document.body.removeChild(outer);

  return w1 - w2;
};

exports.topMost = function (pile, accessors) {
  var candidate = void 0;
  if (!Array.isArray(accessors)) {
    accessors = [accessors];
  }
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = (0, _getIterator3['default'])(pile), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var member = _step.value;

      if (member) {
        candidate = member[accessors[0]];
        for (var i = 1; i < accessors.length; i++) {
          if (candidate) {
            candidate = candidate[accessors[i]];
          }
        }
        if (typeof candidate != 'undefined') {
          break;
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator['return']) {
        _iterator['return']();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return candidate;
};

/***/ }),
/* 3 */
/***/ (function(module, exports, __nested_webpack_require_49405__) {

module.exports = { "default": __nested_webpack_require_49405__(145), __esModule: true };

/***/ }),
/* 4 */
/***/ (function(module, exports, __nested_webpack_require_49557__) {

"use strict";


exports.__esModule = true;

var _typeof2 = __nested_webpack_require_49557__(7);

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
};

/***/ }),
/* 5 */
/***/ (function(module, exports, __nested_webpack_require_50171__) {

"use strict";


exports.__esModule = true;

var _setPrototypeOf = __nested_webpack_require_50171__(147);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __nested_webpack_require_50171__(31);

var _create2 = _interopRequireDefault(_create);

var _typeof2 = __nested_webpack_require_50171__(7);

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
  }

  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
};

/***/ }),
/* 6 */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.5.7' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),
/* 7 */
/***/ (function(module, exports, __nested_webpack_require_51498__) {

"use strict";


exports.__esModule = true;

var _iterator = __nested_webpack_require_51498__(104);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __nested_webpack_require_51498__(106);

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};

/***/ }),
/* 8 */
/***/ (function(module, exports, __nested_webpack_require_52628__) {

var store = __nested_webpack_require_52628__(44)('wks');
var uid = __nested_webpack_require_52628__(29);
var Symbol = __nested_webpack_require_52628__(10).Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),
/* 9 */
/***/ (function(module, exports, __nested_webpack_require_53075__) {

module.exports = { "default": __nested_webpack_require_53075__(102), __esModule: true };

/***/ }),
/* 10 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),
/* 11 */
/***/ (function(module, exports, __nested_webpack_require_53654__) {

var global = __nested_webpack_require_53654__(10);
var core = __nested_webpack_require_53654__(6);
var ctx = __nested_webpack_require_53654__(61);
var hide = __nested_webpack_require_53654__(19);
var has = __nested_webpack_require_53654__(14);
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),
/* 12 */
/***/ (function(module, exports, __nested_webpack_require_56105__) {

var anObject = __nested_webpack_require_56105__(20);
var IE8_DOM_DEFINE = __nested_webpack_require_56105__(62);
var toPrimitive = __nested_webpack_require_56105__(40);
var dP = Object.defineProperty;

exports.f = __nested_webpack_require_56105__(13) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),
/* 13 */
/***/ (function(module, exports, __nested_webpack_require_56773__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__nested_webpack_require_56773__(22)(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 14 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),
/* 15 */
/***/ (function(module, exports, __nested_webpack_require_57216__) {

"use strict";


exports.__esModule = true;

var _isIterable2 = __nested_webpack_require_57216__(136);

var _isIterable3 = _interopRequireDefault(_isIterable2);

var _getIterator2 = __nested_webpack_require_57216__(58);

var _getIterator3 = _interopRequireDefault(_getIterator2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if ((0, _isIterable3.default)(Object(arr))) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

/***/ }),
/* 16 */
/***/ (function(module, exports, __nested_webpack_require_58479__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = __nested_webpack_require_58479__(7);

var _typeof3 = _interopRequireDefault(_typeof2);

var _classCallCheck2 = __nested_webpack_require_58479__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_58479__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * The Base class for all Nodes.
 */
var NodeBase = function () {
  /**
   * @param {Object} options
   * @param {Object} body
   * @param {Label} labelModule
   */
  function NodeBase(options, body, labelModule) {
    (0, _classCallCheck3['default'])(this, NodeBase);

    this.body = body;
    this.labelModule = labelModule;
    this.setOptions(options);
    this.top = undefined;
    this.left = undefined;
    this.height = undefined;
    this.width = undefined;
    this.radius = undefined;
    this.margin = undefined;
    this.refreshNeeded = true;
    this.boundingBox = { top: 0, left: 0, right: 0, bottom: 0 };
  }

  /**
   *
   * @param {Object} options
   */


  (0, _createClass3['default'])(NodeBase, [{
    key: 'setOptions',
    value: function setOptions(options) {
      this.options = options;
    }

    /**
     *
     * @param {Label} labelModule
     * @private
     */

  }, {
    key: '_setMargins',
    value: function _setMargins(labelModule) {
      this.margin = {};
      if (this.options.margin) {
        if ((0, _typeof3['default'])(this.options.margin) == 'object') {
          this.margin.top = this.options.margin.top;
          this.margin.right = this.options.margin.right;
          this.margin.bottom = this.options.margin.bottom;
          this.margin.left = this.options.margin.left;
        } else {
          this.margin.top = this.options.margin;
          this.margin.right = this.options.margin;
          this.margin.bottom = this.options.margin;
          this.margin.left = this.options.margin;
        }
      }
      labelModule.adjustSizes(this.margin);
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     * @private
     */

  }, {
    key: '_distanceToBorder',
    value: function _distanceToBorder(ctx, angle) {
      var borderWidth = this.options.borderWidth;
      this.resize(ctx);
      return Math.min(Math.abs(this.width / 2 / Math.cos(angle)), Math.abs(this.height / 2 / Math.sin(angle))) + borderWidth;
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */

  }, {
    key: 'enableShadow',
    value: function enableShadow(ctx, values) {
      if (values.shadow) {
        ctx.shadowColor = values.shadowColor;
        ctx.shadowBlur = values.shadowSize;
        ctx.shadowOffsetX = values.shadowX;
        ctx.shadowOffsetY = values.shadowY;
      }
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */

  }, {
    key: 'disableShadow',
    value: function disableShadow(ctx, values) {
      if (values.shadow) {
        ctx.shadowColor = 'rgba(0,0,0,0)';
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
      }
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */

  }, {
    key: 'enableBorderDashes',
    value: function enableBorderDashes(ctx, values) {
      if (values.borderDashes !== false) {
        if (ctx.setLineDash !== undefined) {
          var dashes = values.borderDashes;
          if (dashes === true) {
            dashes = [5, 15];
          }
          ctx.setLineDash(dashes);
        } else {
          console.warn('setLineDash is not supported in this browser. The dashed borders cannot be used.');
          this.options.shapeProperties.borderDashes = false;
          values.borderDashes = false;
        }
      }
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */

  }, {
    key: 'disableBorderDashes',
    value: function disableBorderDashes(ctx, values) {
      if (values.borderDashes !== false) {
        if (ctx.setLineDash !== undefined) {
          ctx.setLineDash([0]);
        } else {
          console.warn('setLineDash is not supported in this browser. The dashed borders cannot be used.');
          this.options.shapeProperties.borderDashes = false;
          values.borderDashes = false;
        }
      }
    }

    /**
     * Determine if the shape of a node needs to be recalculated.
     *
     * @param {boolean} selected
     * @param {boolean} hover
     * @returns {boolean}
     * @protected
     */

  }, {
    key: 'needsRefresh',
    value: function needsRefresh(selected, hover) {
      if (this.refreshNeeded === true) {
        // This is probably not the best location to reset this member.
        // However, in the current logic, it is the most convenient one.
        this.refreshNeeded = false;
        return true;
      }

      return this.width === undefined || this.labelModule.differentState(selected, hover);
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */

  }, {
    key: 'initContextForDraw',
    value: function initContextForDraw(ctx, values) {
      var borderWidth = values.borderWidth / this.body.view.scale;

      ctx.lineWidth = Math.min(this.width, borderWidth);
      ctx.strokeStyle = values.borderColor;
      ctx.fillStyle = values.color;
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */

  }, {
    key: 'performStroke',
    value: function performStroke(ctx, values) {
      var borderWidth = values.borderWidth / this.body.view.scale;

      //draw dashed border if enabled, save and restore is required for firefox not to crash on unix.
      ctx.save();
      // if borders are zero width, they will be drawn with width 1 by default. This prevents that
      if (borderWidth > 0) {
        this.enableBorderDashes(ctx, values);
        //draw the border
        ctx.stroke();
        //disable dashed border for other elements
        this.disableBorderDashes(ctx, values);
      }
      ctx.restore();
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */

  }, {
    key: 'performFill',
    value: function performFill(ctx, values) {
      // draw shadow if enabled
      this.enableShadow(ctx, values);
      // draw the background
      ctx.fill();
      // disable shadows for other elements.
      this.disableShadow(ctx, values);

      this.performStroke(ctx, values);
    }

    /**
     *
     * @param {number} margin
     * @private
     */

  }, {
    key: '_addBoundingBoxMargin',
    value: function _addBoundingBoxMargin(margin) {
      this.boundingBox.left -= margin;
      this.boundingBox.top -= margin;
      this.boundingBox.bottom += margin;
      this.boundingBox.right += margin;
    }

    /**
     * Actual implementation of this method call.
     *
     * Doing it like this makes it easier to override
     * in the child classes.
     *
     * @param {number} x width
     * @param {number} y height
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     * @private
     */

  }, {
    key: '_updateBoundingBox',
    value: function _updateBoundingBox(x, y, ctx, selected, hover) {
      if (ctx !== undefined) {
        this.resize(ctx, selected, hover);
      }

      this.left = x - this.width / 2;
      this.top = y - this.height / 2;

      this.boundingBox.left = this.left;
      this.boundingBox.top = this.top;
      this.boundingBox.bottom = this.top + this.height;
      this.boundingBox.right = this.left + this.width;
    }

    /**
     * Default implementation of this method call.
     * This acts as a stub which can be overridden.
     *
     * @param {number} x width
     * @param {number} y height
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     */

  }, {
    key: 'updateBoundingBox',
    value: function updateBoundingBox(x, y, ctx, selected, hover) {
      this._updateBoundingBox(x, y, ctx, selected, hover);
    }

    /**
     * Determine the dimensions to use for nodes with an internal label
     *
     * Currently, these are: Circle, Ellipse, Database, Box
     * The other nodes have external labels, and will not call this method
     *
     * If there is no label, decent default values are supplied.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} [selected]
     * @param {boolean} [hover]
     * @returns {{width:number, height:number}}
     */

  }, {
    key: 'getDimensionsFromLabel',
    value: function getDimensionsFromLabel(ctx, selected, hover) {
      // NOTE: previously 'textSize' was not put in 'this' for Ellipse
      // TODO: examine the consequences.
      this.textSize = this.labelModule.getTextSize(ctx, selected, hover);
      var width = this.textSize.width;
      var height = this.textSize.height;

      var DEFAULT_SIZE = 14;
      if (width === 0) {
        // This happens when there is no label text set
        width = DEFAULT_SIZE; // use a decent default
        height = DEFAULT_SIZE; // if width zero, then height also always zero
      }

      return { width: width, height: height };
    }
  }]);
  return NodeBase;
}();

exports['default'] = NodeBase;

/***/ }),
/* 17 */
/***/ (function(module, exports, __nested_webpack_require_68154__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = __nested_webpack_require_68154__(3);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __nested_webpack_require_68154__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_68154__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __nested_webpack_require_68154__(4);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __nested_webpack_require_68154__(5);

var _inherits3 = _interopRequireDefault(_inherits2);

var _NodeBase2 = __nested_webpack_require_68154__(16);

var _NodeBase3 = _interopRequireDefault(_NodeBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * Base class for constructing Node/Cluster Shapes.
 *
 * @extends NodeBase
 */
var ShapeBase = function (_NodeBase) {
  (0, _inherits3['default'])(ShapeBase, _NodeBase);

  /**
   * @param {Object} options
   * @param {Object} body
   * @param {Label} labelModule
   */
  function ShapeBase(options, body, labelModule) {
    (0, _classCallCheck3['default'])(this, ShapeBase);
    return (0, _possibleConstructorReturn3['default'])(this, (ShapeBase.__proto__ || (0, _getPrototypeOf2['default'])(ShapeBase)).call(this, options, body, labelModule));
  }

  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {boolean} [selected]
   * @param {boolean} [hover]
   * @param {Object} [values={size: this.options.size}]
   */


  (0, _createClass3['default'])(ShapeBase, [{
    key: 'resize',
    value: function resize(ctx) {
      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;
      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;
      var values = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : { size: this.options.size };

      if (this.needsRefresh(selected, hover)) {
        this.labelModule.getTextSize(ctx, selected, hover);
        var size = 2 * values.size;
        this.width = size;
        this.height = size;
        this.radius = 0.5 * this.width;
      }
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {string} shape
     * @param {number} sizeMultiplier - Unused! TODO: Remove next major release
     * @param {number} x
     * @param {number} y
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     * @private
     */

  }, {
    key: '_drawShape',
    value: function _drawShape(ctx, shape, sizeMultiplier, x, y, selected, hover, values) {
      this.resize(ctx, selected, hover, values);
      this.left = x - this.width / 2;
      this.top = y - this.height / 2;

      this.initContextForDraw(ctx, values);
      ctx[shape](x, y, values.size);
      this.performFill(ctx, values);

      if (this.options.icon !== undefined) {
        if (this.options.icon.code !== undefined) {
          ctx.font = (selected ? 'bold ' : '') + this.height / 2 + 'px ' + (this.options.icon.face || 'FontAwesome');
          ctx.fillStyle = this.options.icon.color || 'black';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(this.options.icon.code, x, y);
        }
      }

      if (this.options.label !== undefined) {
        // Need to call following here in order to ensure value for `this.labelModule.size.height`
        this.labelModule.calculateLabelSize(ctx, selected, hover, x, y, 'hanging');
        var yLabel = y + 0.5 * this.height + 0.5 * this.labelModule.size.height;
        this.labelModule.draw(ctx, x, yLabel, selected, hover, 'hanging');
      }

      this.updateBoundingBox(x, y);
    }

    /**
     *
     * @param {number} x
     * @param {number} y
     */

  }, {
    key: 'updateBoundingBox',
    value: function updateBoundingBox(x, y) {
      this.boundingBox.top = y - this.options.size;
      this.boundingBox.left = x - this.options.size;
      this.boundingBox.right = x + this.options.size;
      this.boundingBox.bottom = y + this.options.size;

      if (this.options.label !== undefined && this.labelModule.size.width > 0) {
        this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
        this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
        this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelModule.size.height);
      }
    }
  }]);
  return ShapeBase;
}(_NodeBase3['default']);

exports['default'] = ShapeBase;

/***/ }),
/* 18 */
/***/ (function(module, exports, __nested_webpack_require_72961__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __nested_webpack_require_72961__(59);
var defined = __nested_webpack_require_72961__(39);
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),
/* 19 */
/***/ (function(module, exports, __nested_webpack_require_73260__) {

var dP = __nested_webpack_require_73260__(12);
var createDesc = __nested_webpack_require_73260__(28);
module.exports = __nested_webpack_require_73260__(13) ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),
/* 20 */
/***/ (function(module, exports, __nested_webpack_require_73618__) {

var isObject = __nested_webpack_require_73618__(21);
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),
/* 21 */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),
/* 22 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),
/* 23 */
/***/ (function(module, exports, __nested_webpack_require_74178__) {

module.exports = { "default": __nested_webpack_require_74178__(123), __esModule: true };

/***/ }),
/* 24 */
/***/ (function(module, exports, __nested_webpack_require_74331__) {

"use strict";


/**
 * Setup a mock hammer.js object, for unit testing.
 *
 * Inspiration: https://github.com/uber/deck.gl/pull/658
 *
 * @returns {{on: noop, off: noop, destroy: noop, emit: noop, get: get}}
 */
function hammerMock() {
  var noop = function noop() {};

  return {
    on: noop,
    off: noop,
    destroy: noop,
    emit: noop,

    //eslint-disable-next-line no-unused-vars
    get: function get(m) {
      return {
        set: noop
      };
    }
  };
}

if (typeof window !== 'undefined') {
  var propagating = __nested_webpack_require_74331__(127);
  var Hammer = window['Hammer'] || __nested_webpack_require_74331__(128);
  module.exports = propagating(Hammer, {
    preventDefault: 'mouse'
  });
} else {
  module.exports = function () {
    // hammer.js is only available in a browser, not in node.js. Replacing it with a mock object.
    return hammerMock();
  };
}

/***/ }),
/* 25 */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),
/* 26 */
/***/ (function(module, exports, __nested_webpack_require_75352__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __nested_webpack_require_75352__(65);
var enumBugKeys = __nested_webpack_require_75352__(45);

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),
/* 27 */
/***/ (function(module, exports) {

module.exports = true;


/***/ }),
/* 28 */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),
/* 29 */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),
/* 30 */
/***/ (function(module, exports, __nested_webpack_require_76166__) {

// 7.1.13 ToObject(argument)
var defined = __nested_webpack_require_76166__(39);
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),
/* 31 */
/***/ (function(module, exports, __nested_webpack_require_76378__) {

module.exports = { "default": __nested_webpack_require_76378__(100), __esModule: true };

/***/ }),
/* 32 */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),
/* 33 */
/***/ (function(module, exports, __nested_webpack_require_76625__) {

"use strict";


var _stringify = __nested_webpack_require_76625__(23);

var _stringify2 = _interopRequireDefault(_stringify);

var _typeof2 = __nested_webpack_require_76625__(7);

var _typeof3 = _interopRequireDefault(_typeof2);

var _keys = __nested_webpack_require_76625__(9);

var _keys2 = _interopRequireDefault(_keys);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var util = __nested_webpack_require_76625__(2);
var Queue = __nested_webpack_require_76625__(72);

/**
 * DataSet
 * // TODO: add a DataSet constructor DataSet(data, options)
 *
 * Usage:
 *     var dataSet = new DataSet({
 *         fieldId: '_id',
 *         type: {
 *             // ...
 *         }
 *     });
 *
 *     dataSet.add(item);
 *     dataSet.add(data);
 *     dataSet.update(item);
 *     dataSet.update(data);
 *     dataSet.remove(id);
 *     dataSet.remove(ids);
 *     var data = dataSet.get();
 *     var data = dataSet.get(id);
 *     var data = dataSet.get(ids);
 *     var data = dataSet.get(ids, options, data);
 *     dataSet.clear();
 *
 * A data set can:
 * - add/remove/update data
 * - gives triggers upon changes in the data
 * - can  import/export data in various data formats
 *
 * @param {Array} [data]    Optional array with initial data
 * @param {Object} [options]   Available options:
 *                             {string} fieldId Field name of the id in the
 *                                              items, 'id' by default.
 *                             {Object.<string, string} type
 *                                              A map with field names as key,
 *                                              and the field type as value.
 *                             {Object} queue   Queue changes to the DataSet,
 *                                              flush them all at once.
 *                                              Queue options:
 *                                              - {number} delay  Delay in ms, null by default
 *                                              - {number} max    Maximum number of entries in the queue, Infinity by default
 * @constructor DataSet
 */
function DataSet(data, options) {
  // correctly read optional arguments
  if (data && !Array.isArray(data)) {
    options = data;
    data = null;
  }

  this._options = options || {};
  this._data = {}; // map with data indexed by id
  this.length = 0; // number of items in the DataSet
  this._fieldId = this._options.fieldId || 'id'; // name of the field containing id
  this._type = {}; // internal field types (NOTE: this can differ from this._options.type)

  // all variants of a Date are internally stored as Date, so we can convert
  // from everything to everything (also from ISODate to Number for example)
  if (this._options.type) {
    var fields = (0, _keys2['default'])(this._options.type);
    for (var i = 0, len = fields.length; i < len; i++) {
      var field = fields[i];
      var value = this._options.type[field];
      if (value == 'Date' || value == 'ISODate' || value == 'ASPDate') {
        this._type[field] = 'Date';
      } else {
        this._type[field] = value;
      }
    }
  }

  this._subscribers = {}; // event subscribers

  // add initial data when provided
  if (data) {
    this.add(data);
  }

  this.setOptions(options);
}

/**
 * @param {Object} options   Available options:
 *                             {Object} queue   Queue changes to the DataSet,
 *                                              flush them all at once.
 *                                              Queue options:
 *                                              - {number} delay  Delay in ms, null by default
 *                                              - {number} max    Maximum number of entries in the queue, Infinity by default
 */
DataSet.prototype.setOptions = function (options) {
  if (options && options.queue !== undefined) {
    if (options.queue === false) {
      // delete queue if loaded
      if (this._queue) {
        this._queue.destroy();
        delete this._queue;
      }
    } else {
      // create queue and update its options
      if (!this._queue) {
        this._queue = Queue.extend(this, {
          replace: ['add', 'update', 'remove']
        });
      }

      if ((0, _typeof3['default'])(options.queue) === 'object') {
        this._queue.setOptions(options.queue);
      }
    }
  }
};

/**
 * Subscribe to an event, add an event listener
 * @param {string} event        Event name. Available events: 'add', 'update',
 *                              'remove'
 * @param {function} callback   Callback method. Called with three parameters:
 *                                  {string} event
 *                                  {Object | null} params
 *                                  {string | number} senderId
 */
DataSet.prototype.on = function (event, callback) {
  var subscribers = this._subscribers[event];
  if (!subscribers) {
    subscribers = [];
    this._subscribers[event] = subscribers;
  }

  subscribers.push({
    callback: callback
  });
};

/**
 * Unsubscribe from an event, remove an event listener
 * @param {string} event
 * @param {function} callback
 */
DataSet.prototype.off = function (event, callback) {
  var subscribers = this._subscribers[event];
  if (subscribers) {
    this._subscribers[event] = subscribers.filter(function (listener) {
      return listener.callback != callback;
    });
  }
};

/**
 * Trigger an event
 * @param {string} event
 * @param {Object | null} params
 * @param {string} [senderId]       Optional id of the sender.
 * @private
 */
DataSet.prototype._trigger = function (event, params, senderId) {
  if (event == '*') {
    throw new Error('Cannot trigger event *');
  }

  var subscribers = [];
  if (event in this._subscribers) {
    subscribers = subscribers.concat(this._subscribers[event]);
  }
  if ('*' in this._subscribers) {
    subscribers = subscribers.concat(this._subscribers['*']);
  }

  for (var i = 0, len = subscribers.length; i < len; i++) {
    var subscriber = subscribers[i];
    if (subscriber.callback) {
      subscriber.callback(event, params, senderId || null);
    }
  }
};

/**
 * Add data.
 * Adding an item will fail when there already is an item with the same id.
 * @param {Object | Array} data
 * @param {string} [senderId] Optional sender id
 * @return {Array.<string|number>} addedIds      Array with the ids of the added items
 */
DataSet.prototype.add = function (data, senderId) {
  var addedIds = [],
      id,
      me = this;

  if (Array.isArray(data)) {
    // Array
    for (var i = 0, len = data.length; i < len; i++) {
      id = me._addItem(data[i]);
      addedIds.push(id);
    }
  } else if (data && (typeof data === 'undefined' ? 'undefined' : (0, _typeof3['default'])(data)) === 'object') {
    // Single item
    id = me._addItem(data);
    addedIds.push(id);
  } else {
    throw new Error('Unknown dataType');
  }

  if (addedIds.length) {
    this._trigger('add', { items: addedIds }, senderId);
  }

  return addedIds;
};

/**
 * Update existing items. When an item does not exist, it will be created
 * @param {Object | Array} data
 * @param {string} [senderId] Optional sender id
 * @return {Array.<string|number>} updatedIds     The ids of the added or updated items
 * @throws {Error} Unknown Datatype
 */
DataSet.prototype.update = function (data, senderId) {
  var addedIds = [];
  var updatedIds = [];
  var oldData = [];
  var updatedData = [];
  var me = this;
  var fieldId = me._fieldId;

  var addOrUpdate = function addOrUpdate(item) {
    var id = item[fieldId];
    if (me._data[id]) {
      var oldItem = util.extend({}, me._data[id]);
      // update item
      id = me._updateItem(item);
      updatedIds.push(id);
      updatedData.push(item);
      oldData.push(oldItem);
    } else {
      // add new item
      id = me._addItem(item);
      addedIds.push(id);
    }
  };

  if (Array.isArray(data)) {
    // Array
    for (var i = 0, len = data.length; i < len; i++) {
      if (data[i] && (0, _typeof3['default'])(data[i]) === 'object') {
        addOrUpdate(data[i]);
      } else {
        console.warn('Ignoring input item, which is not an object at index ' + i);
      }
    }
  } else if (data && (typeof data === 'undefined' ? 'undefined' : (0, _typeof3['default'])(data)) === 'object') {
    // Single item
    addOrUpdate(data);
  } else {
    throw new Error('Unknown dataType');
  }

  if (addedIds.length) {
    this._trigger('add', { items: addedIds }, senderId);
  }
  if (updatedIds.length) {
    var props = { items: updatedIds, oldData: oldData, data: updatedData
      // TODO: remove deprecated property 'data' some day
      //Object.defineProperty(props, 'data', {
      //  'get': (function() {
      //    console.warn('Property data is deprecated. Use DataSet.get(ids) to retrieve the new data, use the oldData property on this object to get the old data');
      //    return updatedData;
      //  }).bind(this)
      //});
    };this._trigger('update', props, senderId);
  }

  return addedIds.concat(updatedIds);
};

// prettier-ignore
/**
 * Get a data item or multiple items.
 *
 * Usage:
 *
 *     get()
 *     get(options: Object)
 *
 *     get(id: number | string)
 *     get(id: number | string, options: Object)
 *
 *     get(ids: number[] | string[])
 *     get(ids: number[] | string[], options: Object)
 *
 * Where:
 *
 * {number | string} id         The id of an item
 * {number[] | string{}} ids    An array with ids of items
 * {Object} options             An Object with options. Available options:
 * {string} [returnType]        Type of data to be returned.
 *                              Can be 'Array' (default) or 'Object'.
 * {Object.<string, string>} [type]
 * {string[]} [fields]          field names to be returned
 * {function} [filter]          filter items
 * {string | function} [order]  Order the items by a field name or custom sort function.
 * @param {Array} args
 * @returns {DataSet}
 * @throws Error
 */
DataSet.prototype.get = function (args) {
  // eslint-disable-line no-unused-vars
  var me = this;

  // parse the arguments
  var id, ids, options;
  var firstType = util.getType(arguments[0]);
  if (firstType == 'String' || firstType == 'Number') {
    // get(id [, options])
    id = arguments[0];
    options = arguments[1];
  } else if (firstType == 'Array') {
    // get(ids [, options])
    ids = arguments[0];
    options = arguments[1];
  } else {
    // get([, options])
    options = arguments[0];
  }

  // determine the return type
  var returnType;
  if (options && options.returnType) {
    var allowedValues = ['Array', 'Object'];
    returnType = allowedValues.indexOf(options.returnType) == -1 ? 'Array' : options.returnType;
  } else {
    returnType = 'Array';
  }

  // build options
  var type = options && options.type || this._options.type;
  var filter = options && options.filter;
  var items = [],
      item,
      itemIds,
      itemId,
      i,
      len;

  // convert items
  if (id != undefined) {
    // return a single item
    item = me._getItem(id, type);
    if (item && filter && !filter(item)) {
      item = null;
    }
  } else if (ids != undefined) {
    // return a subset of items
    for (i = 0, len = ids.length; i < len; i++) {
      item = me._getItem(ids[i], type);
      if (!filter || filter(item)) {
        items.push(item);
      }
    }
  } else {
    // return all items
    itemIds = (0, _keys2['default'])(this._data);
    for (i = 0, len = itemIds.length; i < len; i++) {
      itemId = itemIds[i];
      item = me._getItem(itemId, type);
      if (!filter || filter(item)) {
        items.push(item);
      }
    }
  }

  // order the results
  if (options && options.order && id == undefined) {
    this._sort(items, options.order);
  }

  // filter fields of the items
  if (options && options.fields) {
    var fields = options.fields;
    if (id != undefined) {
      item = this._filterFields(item, fields);
    } else {
      for (i = 0, len = items.length; i < len; i++) {
        items[i] = this._filterFields(items[i], fields);
      }
    }
  }

  // return the results
  if (returnType == 'Object') {
    var result = {},
        resultant;
    for (i = 0, len = items.length; i < len; i++) {
      resultant = items[i];
      result[resultant.id] = resultant;
    }
    return result;
  } else {
    if (id != undefined) {
      // a single item
      return item;
    } else {
      // just return our array
      return items;
    }
  }
};

/**
 * Get ids of all items or from a filtered set of items.
 * @param {Object} [options]    An Object with options. Available options:
 *                              {function} [filter] filter items
 *                              {string | function} [order] Order the items by
 *                                  a field name or custom sort function.
 * @return {Array.<string|number>} ids
 */
DataSet.prototype.getIds = function (options) {
  var data = this._data,
      filter = options && options.filter,
      order = options && options.order,
      type = options && options.type || this._options.type,
      itemIds = (0, _keys2['default'])(data),
      i,
      len,
      id,
      item,
      items,
      ids = [];

  if (filter) {
    // get filtered items
    if (order) {
      // create ordered list
      items = [];
      for (i = 0, len = itemIds.length; i < len; i++) {
        id = itemIds[i];
        item = this._getItem(id, type);
        if (filter(item)) {
          items.push(item);
        }
      }

      this._sort(items, order);

      for (i = 0, len = items.length; i < len; i++) {
        ids.push(items[i][this._fieldId]);
      }
    } else {
      // create unordered list
      for (i = 0, len = itemIds.length; i < len; i++) {
        id = itemIds[i];
        item = this._getItem(id, type);
        if (filter(item)) {
          ids.push(item[this._fieldId]);
        }
      }
    }
  } else {
    // get all items
    if (order) {
      // create an ordered list
      items = [];
      for (i = 0, len = itemIds.length; i < len; i++) {
        id = itemIds[i];
        items.push(data[id]);
      }

      this._sort(items, order);

      for (i = 0, len = items.length; i < len; i++) {
        ids.push(items[i][this._fieldId]);
      }
    } else {
      // create unordered list
      for (i = 0, len = itemIds.length; i < len; i++) {
        id = itemIds[i];
        item = data[id];
        ids.push(item[this._fieldId]);
      }
    }
  }

  return ids;
};

/**
 * Returns the DataSet itself. Is overwritten for example by the DataView,
 * which returns the DataSet it is connected to instead.
 * @returns {DataSet}
 */
DataSet.prototype.getDataSet = function () {
  return this;
};

/**
 * Execute a callback function for every item in the dataset.
 * @param {function} callback
 * @param {Object} [options]    Available options:
 *                              {Object.<string, string>} [type]
 *                              {string[]} [fields] filter fields
 *                              {function} [filter] filter items
 *                              {string | function} [order] Order the items by
 *                                  a field name or custom sort function.
 */
DataSet.prototype.forEach = function (callback, options) {
  var filter = options && options.filter,
      type = options && options.type || this._options.type,
      data = this._data,
      itemIds = (0, _keys2['default'])(data),
      i,
      len,
      item,
      id;

  if (options && options.order) {
    // execute forEach on ordered list
    var items = this.get(options);

    for (i = 0, len = items.length; i < len; i++) {
      item = items[i];
      id = item[this._fieldId];
      callback(item, id);
    }
  } else {
    // unordered
    for (i = 0, len = itemIds.length; i < len; i++) {
      id = itemIds[i];
      item = this._getItem(id, type);
      if (!filter || filter(item)) {
        callback(item, id);
      }
    }
  }
};

/**
 * Map every item in the dataset.
 * @param {function} callback
 * @param {Object} [options]    Available options:
 *                              {Object.<string, string>} [type]
 *                              {string[]} [fields] filter fields
 *                              {function} [filter] filter items
 *                              {string | function} [order] Order the items by
 *                                  a field name or custom sort function.
 * @return {Object[]} mappedItems
 */
DataSet.prototype.map = function (callback, options) {
  var filter = options && options.filter,
      type = options && options.type || this._options.type,
      mappedItems = [],
      data = this._data,
      itemIds = (0, _keys2['default'])(data),
      i,
      len,
      id,
      item;

  // convert and filter items
  for (i = 0, len = itemIds.length; i < len; i++) {
    id = itemIds[i];
    item = this._getItem(id, type);
    if (!filter || filter(item)) {
      mappedItems.push(callback(item, id));
    }
  }

  // order items
  if (options && options.order) {
    this._sort(mappedItems, options.order);
  }

  return mappedItems;
};

/**
 * Filter the fields of an item
 * @param {Object | null} item
 * @param {string[]} fields     Field names
 * @return {Object | null} filteredItem or null if no item is provided
 * @private
 */
DataSet.prototype._filterFields = function (item, fields) {
  if (!item) {
    // item is null
    return item;
  }

  var filteredItem = {},
      itemFields = (0, _keys2['default'])(item),
      len = itemFields.length,
      i,
      field;

  if (Array.isArray(fields)) {
    for (i = 0; i < len; i++) {
      field = itemFields[i];
      if (fields.indexOf(field) != -1) {
        filteredItem[field] = item[field];
      }
    }
  } else {
    for (i = 0; i < len; i++) {
      field = itemFields[i];
      if (fields.hasOwnProperty(field)) {
        filteredItem[fields[field]] = item[field];
      }
    }
  }

  return filteredItem;
};

/**
 * Sort the provided array with items
 * @param {Object[]} items
 * @param {string | function} order      A field name or custom sort function.
 * @private
 */
DataSet.prototype._sort = function (items, order) {
  if (util.isString(order)) {
    // order by provided field name
    var name = order; // field name
    items.sort(function (a, b) {
      var av = a[name];
      var bv = b[name];
      return av > bv ? 1 : av < bv ? -1 : 0;
    });
  } else if (typeof order === 'function') {
    // order by sort function
    items.sort(order);
  }
  // TODO: extend order by an Object {field:string, direction:string}
  //       where direction can be 'asc' or 'desc'
  else {
      throw new TypeError('Order must be a function or a string');
    }
};

/**
 * Remove an object by pointer or by id
 * @param {string | number | Object | Array.<string|number>} id Object or id, or an array with
 *                                              objects or ids to be removed
 * @param {string} [senderId] Optional sender id
 * @return {Array.<string|number>} removedIds
 */
DataSet.prototype.remove = function (id, senderId) {
  var removedIds = [],
      removedItems = [],
      ids = [],
      i,
      len,
      itemId,
      item;

  // force everything to be an array for simplicity
  ids = Array.isArray(id) ? id : [id];

  for (i = 0, len = ids.length; i < len; i++) {
    item = this._remove(ids[i]);
    if (item) {
      itemId = item[this._fieldId];
      if (itemId != undefined) {
        removedIds.push(itemId);
        removedItems.push(item);
      }
    }
  }

  if (removedIds.length) {
    this._trigger('remove', { items: removedIds, oldData: removedItems }, senderId);
  }

  return removedIds;
};

/**
 * Remove an item by its id
 * @param {number | string | Object} id   id or item
 * @returns {number | string | null} id
 * @private
 */
DataSet.prototype._remove = function (id) {
  var item, ident;

  // confirm the id to use based on the args type
  if (util.isNumber(id) || util.isString(id)) {
    ident = id;
  } else if (id && (typeof id === 'undefined' ? 'undefined' : (0, _typeof3['default'])(id)) === 'object') {
    ident = id[this._fieldId]; // look for the identifier field using _fieldId
  }

  // do the remove if the item is found
  if (ident !== undefined && this._data[ident]) {
    item = this._data[ident];
    delete this._data[ident];
    this.length--;
    return item;
  }
  return null;
};

/**
 * Clear the data
 * @param {string} [senderId] Optional sender id
 * @return {Array.<string|number>} removedIds    The ids of all removed items
 */
DataSet.prototype.clear = function (senderId) {
  var i, len;
  var ids = (0, _keys2['default'])(this._data);
  var items = [];

  for (i = 0, len = ids.length; i < len; i++) {
    items.push(this._data[ids[i]]);
  }

  this._data = {};
  this.length = 0;

  this._trigger('remove', { items: ids, oldData: items }, senderId);

  return ids;
};

/**
 * Find the item with maximum value of a specified field
 * @param {string} field
 * @return {Object | null} item  Item containing max value, or null if no items
 */
DataSet.prototype.max = function (field) {
  var data = this._data,
      itemIds = (0, _keys2['default'])(data),
      max = null,
      maxField = null,
      i,
      len;

  for (i = 0, len = itemIds.length; i < len; i++) {
    var id = itemIds[i];
    var item = data[id];
    var itemField = item[field];
    if (itemField != null && (!max || itemField > maxField)) {
      max = item;
      maxField = itemField;
    }
  }

  return max;
};

/**
 * Find the item with minimum value of a specified field
 * @param {string} field
 * @return {Object | null} item  Item containing max value, or null if no items
 */
DataSet.prototype.min = function (field) {
  var data = this._data,
      itemIds = (0, _keys2['default'])(data),
      min = null,
      minField = null,
      i,
      len;

  for (i = 0, len = itemIds.length; i < len; i++) {
    var id = itemIds[i];
    var item = data[id];
    var itemField = item[field];
    if (itemField != null && (!min || itemField < minField)) {
      min = item;
      minField = itemField;
    }
  }

  return min;
};

/**
 * Find all distinct values of a specified field
 * @param {string} field
 * @return {Array} values  Array containing all distinct values. If data items
 *                         do not contain the specified field are ignored.
 *                         The returned array is unordered.
 */
DataSet.prototype.distinct = function (field) {
  var data = this._data;
  var itemIds = (0, _keys2['default'])(data);
  var values = [];
  var fieldType = this._options.type && this._options.type[field] || null;
  var count = 0;
  var i, j, len;

  for (i = 0, len = itemIds.length; i < len; i++) {
    var id = itemIds[i];
    var item = data[id];
    var value = item[field];
    var exists = false;
    for (j = 0; j < count; j++) {
      if (values[j] == value) {
        exists = true;
        break;
      }
    }
    if (!exists && value !== undefined) {
      values[count] = value;
      count++;
    }
  }

  if (fieldType) {
    for (i = 0, len = values.length; i < len; i++) {
      values[i] = util.convert(values[i], fieldType);
    }
  }

  return values;
};

/**
 * Add a single item. Will fail when an item with the same id already exists.
 * @param {Object} item
 * @return {string} id
 * @private
 */
DataSet.prototype._addItem = function (item) {
  var id = item[this._fieldId];

  if (id != undefined) {
    // check whether this id is already taken
    if (this._data[id]) {
      // item already exists
      throw new Error('Cannot add item: item with id ' + id + ' already exists');
    }
  } else {
    // generate an id
    id = util.randomUUID();
    item[this._fieldId] = id;
  }

  var d = {},
      fields = (0, _keys2['default'])(item),
      i,
      len;
  for (i = 0, len = fields.length; i < len; i++) {
    var field = fields[i];
    var fieldType = this._type[field]; // type may be undefined
    d[field] = util.convert(item[field], fieldType);
  }
  this._data[id] = d;
  this.length++;

  return id;
};

/**
 * Get an item. Fields can be converted to a specific type
 * @param {string} id
 * @param {Object.<string, string>} [types]  field types to convert
 * @return {Object | null} item
 * @private
 */
DataSet.prototype._getItem = function (id, types) {
  var field, value, i, len;

  // get the item from the dataset
  var raw = this._data[id];
  if (!raw) {
    return null;
  }

  // convert the items field types
  var converted = {},
      fields = (0, _keys2['default'])(raw);

  if (types) {
    for (i = 0, len = fields.length; i < len; i++) {
      field = fields[i];
      value = raw[field];
      converted[field] = util.convert(value, types[field]);
    }
  } else {
    // no field types specified, no converting needed
    for (i = 0, len = fields.length; i < len; i++) {
      field = fields[i];
      value = raw[field];
      converted[field] = value;
    }
  }

  if (!converted[this._fieldId]) {
    converted[this._fieldId] = raw.id;
  }

  return converted;
};

/**
 * Update a single item: merge with existing item.
 * Will fail when the item has no id, or when there does not exist an item
 * with the same id.
 * @param {Object} item
 * @return {string} id
 * @private
 */
DataSet.prototype._updateItem = function (item) {
  var id = item[this._fieldId];
  if (id == undefined) {
    throw new Error('Cannot update item: item has no id (item: ' + (0, _stringify2['default'])(item) + ')');
  }
  var d = this._data[id];
  if (!d) {
    // item doesn't exist
    throw new Error('Cannot update item: no item with id ' + id + ' found');
  }

  // merge with current item
  var fields = (0, _keys2['default'])(item);
  for (var i = 0, len = fields.length; i < len; i++) {
    var field = fields[i];
    var fieldType = this._type[field]; // type may be undefined
    d[field] = util.convert(item[field], fieldType);
  }

  return id;
};

module.exports = DataSet;

/***/ }),
/* 34 */
/***/ (function(module, exports, __nested_webpack_require_102692__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __nested_webpack_require_102692__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_102692__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var util = __nested_webpack_require_102692__(2);

var Label = __nested_webpack_require_102692__(77)['default'];
var ComponentUtil = __nested_webpack_require_102692__(35)['default'];
var Box = __nested_webpack_require_102692__(144)['default'];
var Circle = __nested_webpack_require_102692__(151)['default'];
var CircularImage = __nested_webpack_require_102692__(152)['default'];
var Database = __nested_webpack_require_102692__(153)['default'];
var Diamond = __nested_webpack_require_102692__(154)['default'];
var Dot = __nested_webpack_require_102692__(155)['default'];
var Ellipse = __nested_webpack_require_102692__(156)['default'];
var Icon = __nested_webpack_require_102692__(157)['default'];
var Image = __nested_webpack_require_102692__(158)['default'];
var Square = __nested_webpack_require_102692__(159)['default'];
var Hexagon = __nested_webpack_require_102692__(160)['default'];
var Star = __nested_webpack_require_102692__(161)['default'];
var Text = __nested_webpack_require_102692__(162)['default'];
var Triangle = __nested_webpack_require_102692__(163)['default'];
var TriangleDown = __nested_webpack_require_102692__(164)['default'];

var _require = __nested_webpack_require_102692__(54),
    printStyle = _require.printStyle;

/**
 * A node. A node can be connected to other nodes via one or multiple edges.
 */


var Node = function () {
  /**
   *
   * @param {object} options An object containing options for the node. All
   *                            options are optional, except for the id.
   *                              {number} id     Id of the node. Required
   *                              {string} label  Text label for the node
   *                              {number} x      Horizontal position of the node
   *                              {number} y      Vertical position of the node
   *                              {string} shape  Node shape
   *                              {string} image  An image url
   *                              {string} title  A title text, can be HTML
   *                              {anytype} group A group name or number
   *
   * @param {Object} body               Shared state of current network instance
   * @param {Network.Images} imagelist  A list with images. Only needed when the node has an image
   * @param {Groups} grouplist          A list with groups. Needed for retrieving group options
   * @param {Object} globalOptions      Current global node options; these serve as defaults for the node instance
   * @param {Object} defaultOptions     Global default options for nodes; note that this is also the prototype
   *                                    for parameter `globalOptions`.
   */
  function Node(options, body, imagelist, grouplist, globalOptions, defaultOptions) {
    (0, _classCallCheck3['default'])(this, Node);

    this.options = util.bridgeObject(globalOptions);
    this.globalOptions = globalOptions;
    this.defaultOptions = defaultOptions;
    this.body = body;

    this.edges = []; // all edges connected to this node

    // set defaults for the options
    this.id = undefined;
    this.imagelist = imagelist;
    this.grouplist = grouplist;

    // state options
    this.x = undefined;
    this.y = undefined;
    this.baseSize = this.options.size;
    this.baseFontSize = this.options.font.size;
    this.predefinedPosition = false; // used to check if initial fit should just take the range or approximate
    this.selected = false;
    this.hover = false;

    this.labelModule = new Label(this.body, this.options, false /* Not edge label */
    );
    this.setOptions(options);
  }

  /**
   * Attach a edge to the node
   * @param {Edge} edge
   */


  (0, _createClass3['default'])(Node, [{
    key: 'attachEdge',
    value: function attachEdge(edge) {
      if (this.edges.indexOf(edge) === -1) {
        this.edges.push(edge);
      }
    }

    /**
     * Detach a edge from the node
     *
     * @param {Edge} edge
     */

  }, {
    key: 'detachEdge',
    value: function detachEdge(edge) {
      var index = this.edges.indexOf(edge);
      if (index != -1) {
        this.edges.splice(index, 1);
      }
    }

    /**
     * Set or overwrite options for the node
     *
     * @param {Object} options an object with options
     * @returns {null|boolean}
     */

  }, {
    key: 'setOptions',
    value: function setOptions(options) {
      var currentShape = this.options.shape;
      if (!options) {
        return; // Note that the return value will be 'undefined'! This is OK.
      }

      // basic options
      if (options.id !== undefined) {
        this.id = options.id;
      }

      if (this.id === undefined) {
        throw new Error('Node must have an id');
      }

      Node.checkMass(options, this.id);

      // set these options locally
      // clear x and y positions
      if (options.x !== undefined) {
        if (options.x === null) {
          this.x = undefined;
          this.predefinedPosition = false;
        } else {
          this.x = parseInt(options.x);
          this.predefinedPosition = true;
        }
      }
      if (options.y !== undefined) {
        if (options.y === null) {
          this.y = undefined;
          this.predefinedPosition = false;
        } else {
          this.y = parseInt(options.y);
          this.predefinedPosition = true;
        }
      }
      if (options.size !== undefined) {
        this.baseSize = options.size;
      }
      if (options.value !== undefined) {
        options.value = parseFloat(options.value);
      }

      // this transforms all shorthands into fully defined options
      Node.parseOptions(this.options, options, true, this.globalOptions, this.grouplist);

      var pile = [options, this.options, this.defaultOptions];
      this.chooser = ComponentUtil.choosify('node', pile);

      this._load_images();
      this.updateLabelModule(options);
      this.updateShape(currentShape);

      return options.hidden !== undefined || options.physics !== undefined;
    }

    /**
     * Load the images from the options, for the nodes that need them.
     *
     * Images are always loaded, even if they are not used in the current shape.
     * The user may switch to an image shape later on.
     *
     * @private
     */

  }, {
    key: '_load_images',
    value: function _load_images() {
      if (this.options.shape === 'circularImage' || this.options.shape === 'image') {
        if (this.options.image === undefined) {
          throw new Error("Option image must be defined for node type '" + this.options.shape + "'");
        }
      }

      if (this.options.image === undefined) {
        return;
      }

      if (this.imagelist === undefined) {
        throw new Error('Internal Error: No images provided');
      }

      if (typeof this.options.image === 'string') {
        this.imageObj = this.imagelist.load(this.options.image, this.options.brokenImage, this.id);
      } else {
        if (this.options.image.unselected === undefined) {
          throw new Error('No unselected image provided');
        }

        this.imageObj = this.imagelist.load(this.options.image.unselected, this.options.brokenImage, this.id);

        if (this.options.image.selected !== undefined) {
          this.imageObjAlt = this.imagelist.load(this.options.image.selected, this.options.brokenImage, this.id);
        } else {
          this.imageObjAlt = undefined;
        }
      }
    }

    /**
     * Copy group option values into the node options.
     *
     * The group options override the global node options, so the copy of group options
     *  must happen *after* the global node options have been set.
     *
     * This method must also be called also if the global node options have changed and the group options did not.
     *
     * @param {Object} parentOptions
     * @param {Object} newOptions  new values for the options, currently only passed in for check
     * @param {Object} groupList
     */

  }, {
    key: 'getFormattingValues',


    /**
     *
     * @returns {{color: *, borderWidth: *, borderColor: *, size: *, borderDashes: (boolean|Array|allOptions.nodes.shapeProperties.borderDashes|{boolean, array}), borderRadius: (number|allOptions.nodes.shapeProperties.borderRadius|{number}|Array), shadow: *, shadowColor: *, shadowSize: *, shadowX: *, shadowY: *}}
     */
    value: function getFormattingValues() {
      var values = {
        color: this.options.color.background,
        borderWidth: this.options.borderWidth,
        borderColor: this.options.color.border,
        size: this.options.size,
        borderDashes: this.options.shapeProperties.borderDashes,
        borderRadius: this.options.shapeProperties.borderRadius,
        shadow: this.options.shadow.enabled,
        shadowColor: this.options.shadow.color,
        shadowSize: this.options.shadow.size,
        shadowX: this.options.shadow.x,
        shadowY: this.options.shadow.y
      };
      if (this.selected || this.hover) {
        if (this.chooser === true) {
          if (this.selected) {
            values.borderWidth *= 2;
            values.color = this.options.color.highlight.background;
            values.borderColor = this.options.color.highlight.border;
            values.shadow = this.options.shadow.enabled;
          } else if (this.hover) {
            values.color = this.options.color.hover.background;
            values.borderColor = this.options.color.hover.border;
            values.shadow = this.options.shadow.enabled;
          }
        } else if (typeof this.chooser === 'function') {
          this.chooser(values, this.options.id, this.selected, this.hover);
          if (values.shadow === false) {
            if (values.shadowColor !== this.options.shadow.color || values.shadowSize !== this.options.shadow.size || values.shadowX !== this.options.shadow.x || values.shadowY !== this.options.shadow.y) {
              values.shadow = true;
            }
          }
        }
      } else {
        values.shadow = this.options.shadow.enabled;
      }
      return values;
    }

    /**
     *
     * @param {Object} options
     */

  }, {
    key: 'updateLabelModule',
    value: function updateLabelModule(options) {
      if (this.options.label === undefined || this.options.label === null) {
        this.options.label = '';
      }

      Node.updateGroupOptions(this.options, options, this.grouplist);

      //
      // Note:The prototype chain for this.options is:
      //
      // this.options ->    NodesHandler.options    -> NodesHandler.defaultOptions
      //                 (also: this.globalOptions)
      //
      // Note that the prototypes are mentioned explicitly in the pile list below;
      // WE DON'T WANT THE ORDER OF THE PROTOTYPES!!!! At least, not for font handling of labels.
      // This is a good indication that the prototype usage of options is deficient.
      //
      var currentGroup = this.grouplist.get(this.options.group, false);
      var pile = [options, // new options
      this.options, // current node options, see comment above for prototype
      currentGroup, // group options, if any
      this.globalOptions, // Currently set global node options
      this.defaultOptions // Default global node options
      ];
      this.labelModule.update(this.options, pile);

      if (this.labelModule.baseSize !== undefined) {
        this.baseFontSize = this.labelModule.baseSize;
      }
    }

    /**
     *
     * @param {string} currentShape
     */

  }, {
    key: 'updateShape',
    value: function updateShape(currentShape) {
      if (currentShape === this.options.shape && this.shape) {
        this.shape.setOptions(this.options, this.imageObj, this.imageObjAlt);
      } else {
        // choose draw method depending on the shape
        switch (this.options.shape) {
          case 'box':
            this.shape = new Box(this.options, this.body, this.labelModule);
            break;
          case 'circle':
            this.shape = new Circle(this.options, this.body, this.labelModule);
            break;
          case 'circularImage':
            this.shape = new CircularImage(this.options, this.body, this.labelModule, this.imageObj, this.imageObjAlt);
            break;
          case 'database':
            this.shape = new Database(this.options, this.body, this.labelModule);
            break;
          case 'diamond':
            this.shape = new Diamond(this.options, this.body, this.labelModule);
            break;
          case 'dot':
            this.shape = new Dot(this.options, this.body, this.labelModule);
            break;
          case 'ellipse':
            this.shape = new Ellipse(this.options, this.body, this.labelModule);
            break;
          case 'icon':
            this.shape = new Icon(this.options, this.body, this.labelModule);
            break;
          case 'image':
            this.shape = new Image(this.options, this.body, this.labelModule, this.imageObj, this.imageObjAlt);
            break;
          case 'square':
            this.shape = new Square(this.options, this.body, this.labelModule);
            break;
          case 'hexagon':
            this.shape = new Hexagon(this.options, this.body, this.labelModule);
            break;
          case 'star':
            this.shape = new Star(this.options, this.body, this.labelModule);
            break;
          case 'text':
            this.shape = new Text(this.options, this.body, this.labelModule);
            break;
          case 'triangle':
            this.shape = new Triangle(this.options, this.body, this.labelModule);
            break;
          case 'triangleDown':
            this.shape = new TriangleDown(this.options, this.body, this.labelModule);
            break;
          default:
            this.shape = new Ellipse(this.options, this.body, this.labelModule);
            break;
        }
      }
      this.needsRefresh();
    }

    /**
     * select this node
     */

  }, {
    key: 'select',
    value: function select() {
      this.selected = true;
      this.needsRefresh();
    }

    /**
     * unselect this node
     */

  }, {
    key: 'unselect',
    value: function unselect() {
      this.selected = false;
      this.needsRefresh();
    }

    /**
     * Reset the calculated size of the node, forces it to recalculate its size
     */

  }, {
    key: 'needsRefresh',
    value: function needsRefresh() {
      this.shape.refreshNeeded = true;
    }

    /**
     * get the title of this node.
     * @return {string} title    The title of the node, or undefined when no title
     *                           has been set.
     */

  }, {
    key: 'getTitle',
    value: function getTitle() {
      return this.options.title;
    }

    /**
     * Calculate the distance to the border of the Node
     * @param {CanvasRenderingContext2D}   ctx
     * @param {number} angle        Angle in radians
     * @returns {number} distance   Distance to the border in pixels
     */

  }, {
    key: 'distanceToBorder',
    value: function distanceToBorder(ctx, angle) {
      return this.shape.distanceToBorder(ctx, angle);
    }

    /**
     * Check if this node has a fixed x and y position
     * @return {boolean}      true if fixed, false if not
     */

  }, {
    key: 'isFixed',
    value: function isFixed() {
      return this.options.fixed.x && this.options.fixed.y;
    }

    /**
     * check if this node is selecte
     * @return {boolean} selected   True if node is selected, else false
     */

  }, {
    key: 'isSelected',
    value: function isSelected() {
      return this.selected;
    }

    /**
     * Retrieve the value of the node. Can be undefined
     * @return {number} value
     */

  }, {
    key: 'getValue',
    value: function getValue() {
      return this.options.value;
    }

    /**
     * Get the current dimensions of the label
     *
     * @return {rect}
     */

  }, {
    key: 'getLabelSize',
    value: function getLabelSize() {
      return this.labelModule.size();
    }

    /**
     * Adjust the value range of the node. The node will adjust it's size
     * based on its value.
     * @param {number} min
     * @param {number} max
     * @param {number} total
     */

  }, {
    key: 'setValueRange',
    value: function setValueRange(min, max, total) {
      if (this.options.value !== undefined) {
        var scale = this.options.scaling.customScalingFunction(min, max, total, this.options.value);
        var sizeDiff = this.options.scaling.max - this.options.scaling.min;
        if (this.options.scaling.label.enabled === true) {
          var fontDiff = this.options.scaling.label.max - this.options.scaling.label.min;
          this.options.font.size = this.options.scaling.label.min + scale * fontDiff;
        }
        this.options.size = this.options.scaling.min + scale * sizeDiff;
      } else {
        this.options.size = this.baseSize;
        this.options.font.size = this.baseFontSize;
      }

      this.updateLabelModule();
    }

    /**
     * Draw this node in the given canvas
     * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
     * @param {CanvasRenderingContext2D}   ctx
     */

  }, {
    key: 'draw',
    value: function draw(ctx) {
      var values = this.getFormattingValues();
      this.shape.draw(ctx, this.x, this.y, this.selected, this.hover, values);
    }

    /**
     * Update the bounding box of the shape
     * @param {CanvasRenderingContext2D}   ctx
     */

  }, {
    key: 'updateBoundingBox',
    value: function updateBoundingBox(ctx) {
      this.shape.updateBoundingBox(this.x, this.y, ctx);
    }

    /**
     * Recalculate the size of this node in the given canvas
     * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
     * @param {CanvasRenderingContext2D}   ctx
     */

  }, {
    key: 'resize',
    value: function resize(ctx) {
      var values = this.getFormattingValues();
      this.shape.resize(ctx, this.selected, this.hover, values);
    }

    /**
     * Determine all visual elements of this node instance, in which the given
     * point falls within the bounding shape.
     *
     * @param {point} point
     * @returns {Array.<nodeClickItem|nodeLabelClickItem>} list with the items which are on the point
     */

  }, {
    key: 'getItemsOnPoint',
    value: function getItemsOnPoint(point) {
      var ret = [];

      if (this.labelModule.visible()) {
        if (ComponentUtil.pointInRect(this.labelModule.getSize(), point)) {
          ret.push({ nodeId: this.id, labelId: 0 });
        }
      }

      if (ComponentUtil.pointInRect(this.shape.boundingBox, point)) {
        ret.push({ nodeId: this.id });
      }

      return ret;
    }

    /**
     * Check if this object is overlapping with the provided object
     * @param {Object} obj   an object with parameters left, top, right, bottom
     * @return {boolean}     True if location is located on node
     */

  }, {
    key: 'isOverlappingWith',
    value: function isOverlappingWith(obj) {
      return this.shape.left < obj.right && this.shape.left + this.shape.width > obj.left && this.shape.top < obj.bottom && this.shape.top + this.shape.height > obj.top;
    }

    /**
     * Check if this object is overlapping with the provided object
     * @param {Object} obj   an object with parameters left, top, right, bottom
     * @return {boolean}     True if location is located on node
     */

  }, {
    key: 'isBoundingBoxOverlappingWith',
    value: function isBoundingBoxOverlappingWith(obj) {
      return this.shape.boundingBox.left < obj.right && this.shape.boundingBox.right > obj.left && this.shape.boundingBox.top < obj.bottom && this.shape.boundingBox.bottom > obj.top;
    }

    /**
     * Check valid values for mass
     *
     * The mass may not be negative or zero. If it is, reset to 1
     *
     * @param {object} options
     * @param {Node.id} id
     * @static
     */

  }], [{
    key: 'updateGroupOptions',
    value: function updateGroupOptions(parentOptions, newOptions, groupList) {
      if (groupList === undefined) return; // No groups, nothing to do

      var group = parentOptions.group;

      // paranoia: the selected group is already merged into node options, check.
      if (newOptions !== undefined && newOptions.group !== undefined && group !== newOptions.group) {
        throw new Error("updateGroupOptions: group values in options don't match.");
      }

      var hasGroup = typeof group === 'number' || typeof group === 'string' && group != '';
      if (!hasGroup) return; // current node has no group, no need to merge

      var groupObj = groupList.get(group);

      // Skip merging of group font options into parent; these are required to be distinct for labels
      // Also skip mergin of color IF it is already defined in the node itself. This is to avoid the color of the
      // group overriding the color set at the node level
      // TODO: It might not be a good idea either to merge the rest of the options, investigate this.
      var skipProperties = ['font'];
      if (newOptions !== undefined && newOptions.color !== undefined && newOptions.color != null) skipProperties.push('color');
      util.selectiveNotDeepExtend(skipProperties, parentOptions, groupObj);

      // the color object needs to be completely defined.
      // Since groups can partially overwrite the colors, we parse it again, just in case.
      parentOptions.color = util.parseColor(parentOptions.color);
    }

    /**
     * This process all possible shorthands in the new options and makes sure that the parentOptions are fully defined.
     * Static so it can also be used by the handler.
     *
     * @param {Object} parentOptions
     * @param {Object} newOptions
     * @param {boolean} [allowDeletion=false]
     * @param {Object} [globalOptions={}]
     * @param {Object} [groupList]
     * @static
     */

  }, {
    key: 'parseOptions',
    value: function parseOptions(parentOptions, newOptions) {
      var allowDeletion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var globalOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var groupList = arguments[4];

      var fields = ['color', 'fixed', 'shadow'];
      util.selectiveNotDeepExtend(fields, parentOptions, newOptions, allowDeletion);

      Node.checkMass(newOptions);

      // merge the shadow options into the parent.
      util.mergeOptions(parentOptions, newOptions, 'shadow', globalOptions);

      // individual shape newOptions
      if (newOptions.color !== undefined && newOptions.color !== null) {
        var parsedColor = util.parseColor(newOptions.color);
        util.fillIfDefined(parentOptions.color, parsedColor);
      } else if (allowDeletion === true && newOptions.color === null) {
        parentOptions.color = util.bridgeObject(globalOptions.color); // set the object back to the global options
      }

      // handle the fixed options
      if (newOptions.fixed !== undefined && newOptions.fixed !== null) {
        if (typeof newOptions.fixed === 'boolean') {
          parentOptions.fixed.x = newOptions.fixed;
          parentOptions.fixed.y = newOptions.fixed;
        } else {
          if (newOptions.fixed.x !== undefined && typeof newOptions.fixed.x === 'boolean') {
            parentOptions.fixed.x = newOptions.fixed.x;
          }
          if (newOptions.fixed.y !== undefined && typeof newOptions.fixed.y === 'boolean') {
            parentOptions.fixed.y = newOptions.fixed.y;
          }
        }
      }

      if (allowDeletion === true && newOptions.font === null) {
        parentOptions.font = util.bridgeObject(globalOptions.font); // set the object back to the global options
      }

      Node.updateGroupOptions(parentOptions, newOptions, groupList);

      // handle the scaling options, specifically the label part
      if (newOptions.scaling !== undefined) {
        util.mergeOptions(parentOptions.scaling, newOptions.scaling, 'label', globalOptions.scaling);
      }
    }
  }, {
    key: 'checkMass',
    value: function checkMass(options, id) {
      if (options.mass !== undefined && options.mass <= 0) {
        var strId = '';
        if (id !== undefined) {
          strId = ' in node id: ' + id;
        }
        console.log('%cNegative or zero mass disallowed' + strId + ', setting mass to 1.', printStyle);
        options.mass = 1;
      }
    }
  }]);
  return Node;
}();

exports['default'] = Node;

/***/ }),
/* 35 */
/***/ (function(module, exports, __nested_webpack_require_127443__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = __nested_webpack_require_127443__(7);

var _typeof3 = _interopRequireDefault(_typeof2);

var _classCallCheck2 = __nested_webpack_require_127443__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_127443__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var util = __nested_webpack_require_127443__(2);

/**
 * Helper functions for components
 * @class
 */

var ComponentUtil = function () {
  function ComponentUtil() {
    (0, _classCallCheck3['default'])(this, ComponentUtil);
  }

  (0, _createClass3['default'])(ComponentUtil, null, [{
    key: 'choosify',

    /**
     * Determine values to use for (sub)options of 'chosen'.
     *
     * This option is either a boolean or an object whose values should be examined further.
     * The relevant structures are:
     *
     * - chosen: <boolean value>
     * - chosen: { subOption: <boolean or function> }
     *
     * Where subOption is 'node', 'edge' or 'label'.
     *
     * The intention of this method appears to be to set a specific priority to the options;
     * Since most properties are either bridged or merged into the local options objects, there
     * is not much point in handling them separately.
     * TODO: examine if 'most' in previous sentence can be replaced with 'all'. In that case, we
     *       should be able to get rid of this method.
     *
     * @param {string}  subOption  option within object 'chosen' to consider; either 'node', 'edge' or 'label'
     * @param {Object}  pile       array of options objects to consider
     *
     * @return {boolean|function}  value for passed subOption of 'chosen' to use
     */
    value: function choosify(subOption, pile) {
      // allowed values for subOption
      var allowed = ['node', 'edge', 'label'];
      var value = true;

      var chosen = util.topMost(pile, 'chosen');
      if (typeof chosen === 'boolean') {
        value = chosen;
      } else if ((typeof chosen === 'undefined' ? 'undefined' : (0, _typeof3['default'])(chosen)) === 'object') {
        if (allowed.indexOf(subOption) === -1) {
          throw new Error("choosify: subOption '" + subOption + "' should be one of " + "'" + allowed.join("', '") + "'");
        }

        var chosenEdge = util.topMost(pile, ['chosen', subOption]);
        if (typeof chosenEdge === 'boolean' || typeof chosenEdge === 'function') {
          value = chosenEdge;
        }
      }

      return value;
    }

    /**
     * Check if the point falls within the given rectangle.
     *
     * @param {rect} rect
     * @param {point} point
     * @param {rotationPoint} [rotationPoint] if specified, the rotation that applies to the rectangle.
     * @returns {boolean}  true if point within rectangle, false otherwise
     * @static
     */

  }, {
    key: 'pointInRect',
    value: function pointInRect(rect, point, rotationPoint) {
      if (rect.width <= 0 || rect.height <= 0) {
        return false; // early out
      }

      if (rotationPoint !== undefined) {
        // Rotate the point the same amount as the rectangle
        var tmp = {
          x: point.x - rotationPoint.x,
          y: point.y - rotationPoint.y
        };

        if (rotationPoint.angle !== 0) {
          // In order to get the coordinates the same, you need to
          // rotate in the reverse direction
          var angle = -rotationPoint.angle;

          var tmp2 = {
            x: Math.cos(angle) * tmp.x - Math.sin(angle) * tmp.y,
            y: Math.sin(angle) * tmp.x + Math.cos(angle) * tmp.y
          };
          point = tmp2;
        } else {
          point = tmp;
        }

        // Note that if a rotation is specified, the rectangle coordinates
        // are **not* the full canvas coordinates. They are relative to the
        // rotationPoint. Hence, the point coordinates need not be translated
        // back in this case.
      }

      var right = rect.x + rect.width;
      var bottom = rect.y + rect.width;

      return rect.left < point.x && right > point.x && rect.top < point.y && bottom > point.y;
    }

    /**
     * Check if given value is acceptable as a label text.
     *
     * @param {*} text value to check; can be anything at this point
     * @returns {boolean} true if valid label value, false otherwise
     */

  }, {
    key: 'isValidLabel',
    value: function isValidLabel(text) {
      // Note that this is quite strict: types that *might* be converted to string are disallowed
      return typeof text === 'string' && text !== '';
    }
  }]);
  return ComponentUtil;
}();

exports['default'] = ComponentUtil;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Register a touch event, taking place before a gesture
 * @param {Hammer} hammer       A hammer instance
 * @param {function} callback   Callback, called as callback(event)
 */
exports.onTouch = function (hammer, callback) {
  callback.inputHandler = function (event) {
    if (event.isFirst) {
      callback(event);
    }
  };

  hammer.on('hammer.input', callback.inputHandler);
};

/**
 * Register a release event, taking place after a gesture
 * @param {Hammer} hammer       A hammer instance
 * @param {function} callback   Callback, called as callback(event)
 * @returns {*}
 */
exports.onRelease = function (hammer, callback) {
  callback.inputHandler = function (event) {
    if (event.isFinal) {
      callback(event);
    }
  };

  return hammer.on('hammer.input', callback.inputHandler);
};

/**
 * Unregister a touch event, taking place before a gesture
 * @param {Hammer} hammer       A hammer instance
 * @param {function} callback   Callback, called as callback(event)
 */
exports.offTouch = function (hammer, callback) {
  hammer.off('hammer.input', callback.inputHandler);
};

/**
 * Unregister a release event, taking place before a gesture
 * @param {Hammer} hammer       A hammer instance
 * @param {function} callback   Callback, called as callback(event)
 */
exports.offRelease = exports.offTouch;

/**
 * Hack the PinchRecognizer such that it doesn't prevent default behavior
 * for vertical panning.
 *
 * Yeah ... this is quite a hack ... see https://github.com/hammerjs/hammer.js/issues/932
 *
 * @param {Hammer.Pinch} pinchRecognizer
 * @return {Hammer.Pinch} returns the pinchRecognizer
 */
exports.disablePreventDefaultVertically = function (pinchRecognizer) {
  var TOUCH_ACTION_PAN_Y = 'pan-y';

  pinchRecognizer.getTouchAction = function () {
    // default method returns [TOUCH_ACTION_NONE]
    return [TOUCH_ACTION_PAN_Y];
  };

  return pinchRecognizer;
};

/***/ }),
/* 37 */
/***/ (function(module, exports, __nested_webpack_require_134288__) {

__nested_webpack_require_134288__(87);
var global = __nested_webpack_require_134288__(10);
var hide = __nested_webpack_require_134288__(19);
var Iterators = __nested_webpack_require_134288__(25);
var TO_STRING_TAG = __nested_webpack_require_134288__(8)('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}


/***/ }),
/* 38 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),
/* 39 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),
/* 40 */
/***/ (function(module, exports, __nested_webpack_require_135722__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __nested_webpack_require_135722__(21);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),
/* 41 */
/***/ (function(module, exports, __nested_webpack_require_136455__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __nested_webpack_require_136455__(20);
var dPs = __nested_webpack_require_136455__(92);
var enumBugKeys = __nested_webpack_require_136455__(45);
var IE_PROTO = __nested_webpack_require_136455__(43)('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __nested_webpack_require_136455__(63)('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __nested_webpack_require_136455__(96).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),
/* 42 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),
/* 43 */
/***/ (function(module, exports, __nested_webpack_require_138254__) {

var shared = __nested_webpack_require_138254__(44)('keys');
var uid = __nested_webpack_require_138254__(29);
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),
/* 44 */
/***/ (function(module, exports, __nested_webpack_require_138500__) {

var core = __nested_webpack_require_138500__(6);
var global = __nested_webpack_require_138500__(10);
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __nested_webpack_require_138500__(27) ? 'pure' : 'global',
  copyright: ' 2018 Denis Pushkarev (zloirock.ru)'
});


/***/ }),
/* 45 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),
/* 46 */
/***/ (function(module, exports, __nested_webpack_require_139231__) {

var def = __nested_webpack_require_139231__(12).f;
var has = __nested_webpack_require_139231__(14);
var TAG = __nested_webpack_require_139231__(8)('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),
/* 47 */
/***/ (function(module, exports, __nested_webpack_require_139582__) {

"use strict";

var $at = __nested_webpack_require_139582__(97)(true);

// 21.1.3.27 String.prototype[@@iterator]()
__nested_webpack_require_139582__(60)(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),
/* 48 */
/***/ (function(module, exports, __nested_webpack_require_140190__) {

exports.f = __nested_webpack_require_140190__(8);


/***/ }),
/* 49 */
/***/ (function(module, exports, __nested_webpack_require_140304__) {

var global = __nested_webpack_require_140304__(10);
var core = __nested_webpack_require_140304__(6);
var LIBRARY = __nested_webpack_require_140304__(27);
var wksExt = __nested_webpack_require_140304__(48);
var defineProperty = __nested_webpack_require_140304__(12).f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};


/***/ }),
/* 50 */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),
/* 51 */
/***/ (function(module, exports, __nested_webpack_require_140909__) {

"use strict";


var _keys = __nested_webpack_require_140909__(9);

var _keys2 = _interopRequireDefault(_keys);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var util = __nested_webpack_require_140909__(2);
var DataSet = __nested_webpack_require_140909__(33);

/**
 * DataView
 *
 * a dataview offers a filtered view on a dataset or an other dataview.
 *
 * @param {DataSet | DataView} data
 * @param {Object} [options]   Available options: see method get
 *
 * @constructor DataView
 */
function DataView(data, options) {
  this._data = null;
  this._ids = {}; // ids of the items currently in memory (just contains a boolean true)
  this.length = 0; // number of items in the DataView
  this._options = options || {};
  this._fieldId = 'id'; // name of the field containing id
  this._subscribers = {}; // event subscribers

  var me = this;
  this.listener = function () {
    me._onEvent.apply(me, arguments);
  };

  this.setData(data);
}

// TODO: implement a function .config() to dynamically update things like configured filter
// and trigger changes accordingly

/**
 * Set a data source for the view
 * @param {DataSet | DataView} data
 */
DataView.prototype.setData = function (data) {
  var ids, id, i, len, items;

  if (this._data) {
    // unsubscribe from current dataset
    if (this._data.off) {
      this._data.off('*', this.listener);
    }

    // trigger a remove of all items in memory
    ids = this._data.getIds({ filter: this._options && this._options.filter });
    items = [];

    for (i = 0, len = ids.length; i < len; i++) {
      items.push(this._data._data[ids[i]]);
    }

    this._ids = {};
    this.length = 0;
    this._trigger('remove', { items: ids, oldData: items });
  }

  this._data = data;

  if (this._data) {
    // update fieldId
    this._fieldId = this._options.fieldId || this._data && this._data.options && this._data.options.fieldId || 'id';

    // trigger an add of all added items
    ids = this._data.getIds({ filter: this._options && this._options.filter });
    for (i = 0, len = ids.length; i < len; i++) {
      id = ids[i];
      this._ids[id] = true;
    }
    this.length = ids.length;
    this._trigger('add', { items: ids });

    // subscribe to new dataset
    if (this._data.on) {
      this._data.on('*', this.listener);
    }
  }
};

/**
 * Refresh the DataView. Useful when the DataView has a filter function
 * containing a variable parameter.
 */
DataView.prototype.refresh = function () {
  var id, i, len;
  var ids = this._data.getIds({
    filter: this._options && this._options.filter
  }),
      oldIds = (0, _keys2['default'])(this._ids),
      newIds = {},
      addedIds = [],
      removedIds = [],
      removedItems = [];

  // check for additions
  for (i = 0, len = ids.length; i < len; i++) {
    id = ids[i];
    newIds[id] = true;
    if (!this._ids[id]) {
      addedIds.push(id);
      this._ids[id] = true;
    }
  }

  // check for removals
  for (i = 0, len = oldIds.length; i < len; i++) {
    id = oldIds[i];
    if (!newIds[id]) {
      removedIds.push(id);
      removedItems.push(this._data._data[id]);
      delete this._ids[id];
    }
  }

  this.length += addedIds.length - removedIds.length;

  // trigger events
  if (addedIds.length) {
    this._trigger('add', { items: addedIds });
  }
  if (removedIds.length) {
    this._trigger('remove', { items: removedIds, oldData: removedItems });
  }
};

// prettier-ignore
/**
 * Get data from the data view
 *
 * Usage:
 *
 *     get()
 *     get(options: Object)
 *     get(options: Object, data: Array | DataTable)
 *
 *     get(id: Number)
 *     get(id: Number, options: Object)
 *     get(id: Number, options: Object, data: Array | DataTable)
 *
 *     get(ids: Number[])
 *     get(ids: Number[], options: Object)
 *     get(ids: Number[], options: Object, data: Array | DataTable)
 *
 * Where:
 *
 * {number | string} id         The id of an item
 * {number[] | string{}} ids    An array with ids of items
 * {Object} options             An Object with options. Available options:
 *                              {string} [type] Type of data to be returned. Can
 *                                              be 'DataTable' or 'Array' (default)
 *                              {Object.<string, string>} [convert]
 *                              {string[]} [fields] field names to be returned
 *                              {function} [filter] filter items
 *                              {string | function} [order] Order the items by
 *                                  a field name or custom sort function.
 * {Array | DataTable} [data]   If provided, items will be appended to this
 *                              array or table. Required in case of Google
 *                              DataTable.
 * @param {Array} args
 * @return {DataSet|DataView}
 */
DataView.prototype.get = function (args) {
  // eslint-disable-line no-unused-vars
  var me = this;

  // parse the arguments
  var ids, options, data;
  var firstType = util.getType(arguments[0]);
  if (firstType == 'String' || firstType == 'Number' || firstType == 'Array') {
    // get(id(s) [, options] [, data])
    ids = arguments[0]; // can be a single id or an array with ids
    options = arguments[1];
    data = arguments[2];
  } else {
    // get([, options] [, data])
    options = arguments[0];
    data = arguments[1];
  }

  // extend the options with the default options and provided options
  var viewOptions = util.extend({}, this._options, options);

  // create a combined filter method when needed
  if (this._options.filter && options && options.filter) {
    viewOptions.filter = function (item) {
      return me._options.filter(item) && options.filter(item);
    };
  }

  // build up the call to the linked data set
  var getArguments = [];
  if (ids != undefined) {
    getArguments.push(ids);
  }
  getArguments.push(viewOptions);
  getArguments.push(data);

  return this._data && this._data.get.apply(this._data, getArguments);
};

/**
 * Get ids of all items or from a filtered set of items.
 * @param {Object} [options]    An Object with options. Available options:
 *                              {function} [filter] filter items
 *                              {string | function} [order] Order the items by
 *                                  a field name or custom sort function.
 * @return {Array.<string|number>} ids
 */
DataView.prototype.getIds = function (options) {
  var ids;

  if (this._data) {
    var defaultFilter = this._options.filter;
    var filter;

    if (options && options.filter) {
      if (defaultFilter) {
        filter = function filter(item) {
          return defaultFilter(item) && options.filter(item);
        };
      } else {
        filter = options.filter;
      }
    } else {
      filter = defaultFilter;
    }

    ids = this._data.getIds({
      filter: filter,
      order: options && options.order
    });
  } else {
    ids = [];
  }

  return ids;
};

/**
 * Map every item in the dataset.
 * @param {function} callback
 * @param {Object} [options]    Available options:
 *                              {Object.<string, string>} [type]
 *                              {string[]} [fields] filter fields
 *                              {function} [filter] filter items
 *                              {string | function} [order] Order the items by
 *                                  a field name or custom sort function.
 * @return {Object[]} mappedItems
 */
DataView.prototype.map = function (callback, options) {
  var mappedItems = [];
  if (this._data) {
    var defaultFilter = this._options.filter;
    var filter;

    if (options && options.filter) {
      if (defaultFilter) {
        filter = function filter(item) {
          return defaultFilter(item) && options.filter(item);
        };
      } else {
        filter = options.filter;
      }
    } else {
      filter = defaultFilter;
    }

    mappedItems = this._data.map(callback, {
      filter: filter,
      order: options && options.order
    });
  } else {
    mappedItems = [];
  }

  return mappedItems;
};

/**
 * Get the DataSet to which this DataView is connected. In case there is a chain
 * of multiple DataViews, the root DataSet of this chain is returned.
 * @return {DataSet} dataSet
 */
DataView.prototype.getDataSet = function () {
  var dataSet = this;
  while (dataSet instanceof DataView) {
    dataSet = dataSet._data;
  }
  return dataSet || null;
};

/**
 * Event listener. Will propagate all events from the connected data set to
 * the subscribers of the DataView, but will filter the items and only trigger
 * when there are changes in the filtered data set.
 * @param {string} event
 * @param {Object | null} params
 * @param {string} senderId
 * @private
 */
DataView.prototype._onEvent = function (event, params, senderId) {
  var i, len, id, item;
  var ids = params && params.items;
  var addedIds = [],
      updatedIds = [],
      removedIds = [],
      oldItems = [],
      updatedItems = [],
      removedItems = [];

  if (ids && this._data) {
    switch (event) {
      case 'add':
        // filter the ids of the added items
        for (i = 0, len = ids.length; i < len; i++) {
          id = ids[i];
          item = this.get(id);
          if (item) {
            this._ids[id] = true;
            addedIds.push(id);
          }
        }

        break;

      case 'update':
        // determine the event from the views viewpoint: an updated
        // item can be added, updated, or removed from this view.
        for (i = 0, len = ids.length; i < len; i++) {
          id = ids[i];
          item = this.get(id);

          if (item) {
            if (this._ids[id]) {
              updatedIds.push(id);
              updatedItems.push(params.data[i]);
              oldItems.push(params.oldData[i]);
            } else {
              this._ids[id] = true;
              addedIds.push(id);
            }
          } else {
            if (this._ids[id]) {
              delete this._ids[id];
              removedIds.push(id);
              removedItems.push(params.oldData[i]);
            } else {
              // nothing interesting for me :-(
            }
          }
        }

        break;

      case 'remove':
        // filter the ids of the removed items
        for (i = 0, len = ids.length; i < len; i++) {
          id = ids[i];
          if (this._ids[id]) {
            delete this._ids[id];
            removedIds.push(id);
            removedItems.push(params.oldData[i]);
          }
        }

        break;
    }

    this.length += addedIds.length - removedIds.length;

    if (addedIds.length) {
      this._trigger('add', { items: addedIds }, senderId);
    }
    if (updatedIds.length) {
      this._trigger('update', { items: updatedIds, oldData: oldItems, data: updatedItems }, senderId);
    }
    if (removedIds.length) {
      this._trigger('remove', { items: removedIds, oldData: removedItems }, senderId);
    }
  }
};

// copy subscription functionality from DataSet
DataView.prototype.on = DataSet.prototype.on;
DataView.prototype.off = DataSet.prototype.off;
DataView.prototype._trigger = DataSet.prototype._trigger;

// TODO: make these functions deprecated (replaced with `on` and `off` since version 0.5)
DataView.prototype.subscribe = DataView.prototype.on;
DataView.prototype.unsubscribe = DataView.prototype.off;

module.exports = DataView;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
/**
 * Created by Alex on 11/6/2014.
 */

// https://github.com/umdjs/umd/blob/master/returnExports.js#L40-L60
// if the module has no dependencies, the above pattern can be simplified to
(function (root, factory) {
  if (true) {
    // AMD. Register as an anonymous module.
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
}(this, function () {

  function keycharm(options) {
    var preventDefault = options && options.preventDefault || false;

    var container = options && options.container || window;

    var _exportFunctions = {};
    var _bound = {keydown:{}, keyup:{}};
    var _keys = {};
    var i;

    // a - z
    for (i = 97; i <= 122; i++) {_keys[String.fromCharCode(i)] = {code:65 + (i - 97), shift: false};}
    // A - Z
    for (i = 65; i <= 90; i++) {_keys[String.fromCharCode(i)] = {code:i, shift: true};}
    // 0 - 9
    for (i = 0;  i <= 9;   i++) {_keys['' + i] = {code:48 + i, shift: false};}
    // F1 - F12
    for (i = 1;  i <= 12;   i++) {_keys['F' + i] = {code:111 + i, shift: false};}
    // num0 - num9
    for (i = 0;  i <= 9;   i++) {_keys['num' + i] = {code:96 + i, shift: false};}

    // numpad misc
    _keys['num*'] = {code:106, shift: false};
    _keys['num+'] = {code:107, shift: false};
    _keys['num-'] = {code:109, shift: false};
    _keys['num/'] = {code:111, shift: false};
    _keys['num.'] = {code:110, shift: false};
    // arrows
    _keys['left']  = {code:37, shift: false};
    _keys['up']    = {code:38, shift: false};
    _keys['right'] = {code:39, shift: false};
    _keys['down']  = {code:40, shift: false};
    // extra keys
    _keys['space'] = {code:32, shift: false};
    _keys['enter'] = {code:13, shift: false};
    _keys['shift'] = {code:16, shift: undefined};
    _keys['esc']   = {code:27, shift: false};
    _keys['backspace'] = {code:8, shift: false};
    _keys['tab']       = {code:9, shift: false};
    _keys['ctrl']      = {code:17, shift: false};
    _keys['alt']       = {code:18, shift: false};
    _keys['delete']    = {code:46, shift: false};
    _keys['pageup']    = {code:33, shift: false};
    _keys['pagedown']  = {code:34, shift: false};
    // symbols
    _keys['=']     = {code:187, shift: false};
    _keys['-']     = {code:189, shift: false};
    _keys[']']     = {code:221, shift: false};
    _keys['[']     = {code:219, shift: false};



    var down = function(event) {handleEvent(event,'keydown');};
    var up = function(event) {handleEvent(event,'keyup');};

    // handle the actualy bound key with the event
    var handleEvent = function(event,type) {
      if (_bound[type][event.keyCode] !== undefined) {
        var bound = _bound[type][event.keyCode];
        for (var i = 0; i < bound.length; i++) {
          if (bound[i].shift === undefined) {
            bound[i].fn(event);
          }
          else if (bound[i].shift == true && event.shiftKey == true) {
            bound[i].fn(event);
          }
          else if (bound[i].shift == false && event.shiftKey == false) {
            bound[i].fn(event);
          }
        }

        if (preventDefault == true) {
          event.preventDefault();
        }
      }
    };

    // bind a key to a callback
    _exportFunctions.bind = function(key, callback, type) {
      if (type === undefined) {
        type = 'keydown';
      }
      if (_keys[key] === undefined) {
        throw new Error("unsupported key: " + key);
      }
      if (_bound[type][_keys[key].code] === undefined) {
        _bound[type][_keys[key].code] = [];
      }
      _bound[type][_keys[key].code].push({fn:callback, shift:_keys[key].shift});
    };


    // bind all keys to a call back (demo purposes)
    _exportFunctions.bindAll = function(callback, type) {
      if (type === undefined) {
        type = 'keydown';
      }
      for (var key in _keys) {
        if (_keys.hasOwnProperty(key)) {
          _exportFunctions.bind(key,callback,type);
        }
      }
    };

    // get the key label from an event
    _exportFunctions.getKey = function(event) {
      for (var key in _keys) {
        if (_keys.hasOwnProperty(key)) {
          if (event.shiftKey == true && _keys[key].shift == true && event.keyCode == _keys[key].code) {
            return key;
          }
          else if (event.shiftKey == false && _keys[key].shift == false && event.keyCode == _keys[key].code) {
            return key;
          }
          else if (event.keyCode == _keys[key].code && key == 'shift') {
            return key;
          }
        }
      }
      return "unknown key, currently not supported";
    };

    // unbind either a specific callback from a key or all of them (by leaving callback undefined)
    _exportFunctions.unbind = function(key, callback, type) {
      if (type === undefined) {
        type = 'keydown';
      }
      if (_keys[key] === undefined) {
        throw new Error("unsupported key: " + key);
      }
      if (callback !== undefined) {
        var newBindings = [];
        var bound = _bound[type][_keys[key].code];
        if (bound !== undefined) {
          for (var i = 0; i < bound.length; i++) {
            if (!(bound[i].fn == callback && bound[i].shift == _keys[key].shift)) {
              newBindings.push(_bound[type][_keys[key].code][i]);
            }
          }
        }
        _bound[type][_keys[key].code] = newBindings;
      }
      else {
        _bound[type][_keys[key].code] = [];
      }
    };

    // reset all bound variables.
    _exportFunctions.reset = function() {
      _bound = {keydown:{}, keyup:{}};
    };

    // unbind all listeners and reset all variables.
    _exportFunctions.destroy = function() {
      _bound = {keydown:{}, keyup:{}};
      container.removeEventListener('keydown', down, true);
      container.removeEventListener('keyup', up, true);
    };

    // create listeners.
    container.addEventListener('keydown',down,true);
    container.addEventListener('keyup',up,true);

    // return the public functions.
    return _exportFunctions;
  }

  return keycharm;
}));




/***/ }),
/* 53 */
/***/ (function(module, exports, __nested_webpack_require_159436__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = __nested_webpack_require_159436__(3);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __nested_webpack_require_159436__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_159436__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __nested_webpack_require_159436__(4);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __nested_webpack_require_159436__(5);

var _inherits3 = _interopRequireDefault(_inherits2);

var _NodeBase2 = __nested_webpack_require_159436__(16);

var _NodeBase3 = _interopRequireDefault(_NodeBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * NOTE: This is a bad base class
 *
 * Child classes are:
 *
 *   Image       - uses *only* image methods
 *   Circle      - uses *only* _drawRawCircle
 *   CircleImage - uses all
 *
 * TODO: Refactor, move _drawRawCircle to different module, derive Circle from NodeBase
 *       Rename this to ImageBase
 *       Consolidate common code in Image and CircleImage to base class
 *
 * @extends NodeBase
 */
var CircleImageBase = function (_NodeBase) {
  (0, _inherits3['default'])(CircleImageBase, _NodeBase);

  /**
   * @param {Object} options
   * @param {Object} body
   * @param {Label} labelModule
   */
  function CircleImageBase(options, body, labelModule) {
    (0, _classCallCheck3['default'])(this, CircleImageBase);

    var _this = (0, _possibleConstructorReturn3['default'])(this, (CircleImageBase.__proto__ || (0, _getPrototypeOf2['default'])(CircleImageBase)).call(this, options, body, labelModule));

    _this.labelOffset = 0;
    _this.selected = false;
    return _this;
  }

  /**
   *
   * @param {Object} options
   * @param {Object} [imageObj]
   * @param {Object} [imageObjAlt]
   */


  (0, _createClass3['default'])(CircleImageBase, [{
    key: 'setOptions',
    value: function setOptions(options, imageObj, imageObjAlt) {
      this.options = options;

      if (!(imageObj === undefined && imageObjAlt === undefined)) {
        this.setImages(imageObj, imageObjAlt);
      }
    }

    /**
     * Set the images for this node.
     *
     * The images can be updated after the initial setting of options;
     * therefore, this method needs to be reentrant.
     *
     * For correct working in error cases, it is necessary to properly set
     * field 'nodes.brokenImage' in the options.
     *
     * @param {Image} imageObj  required; main image to show for this node
     * @param {Image|undefined} imageObjAlt optional; image to show when node is selected
     */

  }, {
    key: 'setImages',
    value: function setImages(imageObj, imageObjAlt) {
      if (imageObjAlt && this.selected) {
        this.imageObj = imageObjAlt;
        this.imageObjAlt = imageObj;
      } else {
        this.imageObj = imageObj;
        this.imageObjAlt = imageObjAlt;
      }
    }

    /**
     * Set selection and switch between the base and the selected image.
     *
     * Do the switch only if imageObjAlt exists.
     *
     * @param {boolean} selected value of new selected state for current node
     */

  }, {
    key: 'switchImages',
    value: function switchImages(selected) {
      var selection_changed = selected && !this.selected || !selected && this.selected;
      this.selected = selected; // Remember new selection

      if (this.imageObjAlt !== undefined && selection_changed) {
        var imageTmp = this.imageObj;
        this.imageObj = this.imageObjAlt;
        this.imageObjAlt = imageTmp;
      }
    }

    /**
     * Adjust the node dimensions for a loaded image.
     *
     * Pre: this.imageObj is valid
     */

  }, {
    key: '_resizeImage',
    value: function _resizeImage() {
      var width, height;

      if (this.options.shapeProperties.useImageSize === false) {
        // Use the size property
        var ratio_width = 1;
        var ratio_height = 1;

        // Only calculate the proper ratio if both width and height not zero
        if (this.imageObj.width && this.imageObj.height) {
          if (this.imageObj.width > this.imageObj.height) {
            ratio_width = this.imageObj.width / this.imageObj.height;
          } else {
            ratio_height = this.imageObj.height / this.imageObj.width;
          }
        }

        width = this.options.size * 2 * ratio_width;
        height = this.options.size * 2 * ratio_height;
      } else {
        // Use the image size
        width = this.imageObj.width;
        height = this.imageObj.height;
      }

      this.width = width;
      this.height = height;
      this.radius = 0.5 * this.width;
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {ArrowOptions} values
     * @private
     */

  }, {
    key: '_drawRawCircle',
    value: function _drawRawCircle(ctx, x, y, values) {
      this.initContextForDraw(ctx, values);
      ctx.circle(x, y, values.size);
      this.performFill(ctx, values);
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     * @private
     */

  }, {
    key: '_drawImageAtPosition',
    value: function _drawImageAtPosition(ctx, values) {
      if (this.imageObj.width != 0) {
        // draw the image
        ctx.globalAlpha = 1.0;

        // draw shadow if enabled
        this.enableShadow(ctx, values);

        var factor = 1;
        if (this.options.shapeProperties.interpolation === true) {
          factor = this.imageObj.width / this.width / this.body.view.scale;
        }

        this.imageObj.drawImageAtPosition(ctx, factor, this.left, this.top, this.width, this.height);

        // disable shadows for other elements.
        this.disableShadow(ctx, values);
      }
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @private
     */

  }, {
    key: '_drawImageLabel',
    value: function _drawImageLabel(ctx, x, y, selected, hover) {
      var yLabel;
      var offset = 0;

      if (this.height !== undefined) {
        offset = this.height * 0.5;
        var labelDimensions = this.labelModule.getTextSize(ctx, selected, hover);
        if (labelDimensions.lineCount >= 1) {
          offset += labelDimensions.height / 2;
        }
      }

      yLabel = y + offset;

      if (this.options.label) {
        this.labelOffset = offset;
      }
      this.labelModule.draw(ctx, x, yLabel, selected, hover, 'hanging');
    }
  }]);
  return CircleImageBase;
}(_NodeBase3['default']);

exports['default'] = CircleImageBase;

/***/ }),
/* 54 */
/***/ (function(module, exports, __nested_webpack_require_166380__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.printStyle = undefined;

var _stringify = __nested_webpack_require_166380__(23);

var _stringify2 = _interopRequireDefault(_stringify);

var _typeof2 = __nested_webpack_require_166380__(7);

var _typeof3 = _interopRequireDefault(_typeof2);

var _keys = __nested_webpack_require_166380__(9);

var _keys2 = _interopRequireDefault(_keys);

var _classCallCheck2 = __nested_webpack_require_166380__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_166380__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var util = __nested_webpack_require_166380__(2);

var errorFound = false;
var allOptions = void 0;
var printStyle = 'background: #FFeeee; color: #dd0000';
/**
 *  Used to validate options.
 */

var Validator = function () {
  /**
   * @ignore
   */
  function Validator() {
    (0, _classCallCheck3['default'])(this, Validator);
  }

  /**
   * Main function to be called
   * @param {Object} options
   * @param {Object} referenceOptions
   * @param {Object} subObject
   * @returns {boolean}
   * @static
   */


  (0, _createClass3['default'])(Validator, null, [{
    key: 'validate',
    value: function validate(options, referenceOptions, subObject) {
      errorFound = false;
      allOptions = referenceOptions;
      var usedOptions = referenceOptions;
      if (subObject !== undefined) {
        usedOptions = referenceOptions[subObject];
      }
      Validator.parse(options, usedOptions, []);
      return errorFound;
    }

    /**
     * Will traverse an object recursively and check every value
     * @param {Object} options
     * @param {Object} referenceOptions
     * @param {array} path    | where to look for the actual option
     * @static
     */

  }, {
    key: 'parse',
    value: function parse(options, referenceOptions, path) {
      for (var option in options) {
        if (options.hasOwnProperty(option)) {
          Validator.check(option, options, referenceOptions, path);
        }
      }
    }

    /**
     * Check every value. If the value is an object, call the parse function on that object.
     * @param {string} option
     * @param {Object} options
     * @param {Object} referenceOptions
     * @param {array} path    | where to look for the actual option
     * @static
     */

  }, {
    key: 'check',
    value: function check(option, options, referenceOptions, path) {
      if (referenceOptions[option] === undefined && referenceOptions.__any__ === undefined) {
        Validator.getSuggestion(option, referenceOptions, path);
        return;
      }

      var referenceOption = option;
      var is_object = true;

      if (referenceOptions[option] === undefined && referenceOptions.__any__ !== undefined) {
        // NOTE: This only triggers if the __any__ is in the top level of the options object.
        //       THAT'S A REALLY BAD PLACE TO ALLOW IT!!!!
        // TODO: Examine if needed, remove if possible

        // __any__ is a wildcard. Any value is accepted and will be further analysed by reference.
        referenceOption = '__any__';

        // if the any-subgroup is not a predefined object in the configurator,
        // we do not look deeper into the object.
        is_object = Validator.getType(options[option]) === 'object';
      } else {
        // Since all options in the reference are objects, we can check whether
        // they are supposed to be the object to look for the __type__ field.
        // if this is an object, we check if the correct type has been supplied to account for shorthand options.
      }

      var refOptionObj = referenceOptions[referenceOption];
      if (is_object && refOptionObj.__type__ !== undefined) {
        refOptionObj = refOptionObj.__type__;
      }

      Validator.checkFields(option, options, referenceOptions, referenceOption, refOptionObj, path);
    }

    /**
     *
     * @param {string}  option           | the option property
     * @param {Object}  options          | The supplied options object
     * @param {Object}  referenceOptions | The reference options containing all options and their allowed formats
     * @param {string}  referenceOption  | Usually this is the same as option, except when handling an __any__ tag.
     * @param {string}  refOptionObj     | This is the type object from the reference options
     * @param {Array}   path             | where in the object is the option
     * @static
     */

  }, {
    key: 'checkFields',
    value: function checkFields(option, options, referenceOptions, referenceOption, refOptionObj, path) {
      var log = function log(message) {
        console.log('%c' + message + Validator.printLocation(path, option), printStyle);
      };

      var optionType = Validator.getType(options[option]);
      var refOptionType = refOptionObj[optionType];

      if (refOptionType !== undefined) {
        // if the type is correct, we check if it is supposed to be one of a few select values
        if (Validator.getType(refOptionType) === 'array' && refOptionType.indexOf(options[option]) === -1) {
          log('Invalid option detected in "' + option + '".' + ' Allowed values are:' + Validator.print(refOptionType) + ' not "' + options[option] + '". ');
          errorFound = true;
        } else if (optionType === 'object' && referenceOption !== '__any__') {
          path = util.copyAndExtendArray(path, option);
          Validator.parse(options[option], referenceOptions[referenceOption], path);
        }
      } else if (refOptionObj['any'] === undefined) {
        // type of the field is incorrect and the field cannot be any
        log('Invalid type received for "' + option + '". Expected: ' + Validator.print((0, _keys2['default'])(refOptionObj)) + '. Received [' + optionType + '] "' + options[option] + '"');
        errorFound = true;
      }
    }

    /**
     *
     * @param {Object|boolean|number|string|Array.<number>|Date|Node|Moment|undefined|null} object
     * @returns {string}
     * @static
     */

  }, {
    key: 'getType',
    value: function getType(object) {
      var type = typeof object === 'undefined' ? 'undefined' : (0, _typeof3['default'])(object);

      if (type === 'object') {
        if (object === null) {
          return 'null';
        }
        if (object instanceof Boolean) {
          return 'boolean';
        }
        if (object instanceof Number) {
          return 'number';
        }
        if (object instanceof String) {
          return 'string';
        }
        if (Array.isArray(object)) {
          return 'array';
        }
        if (object instanceof Date) {
          return 'date';
        }
        if (object.nodeType !== undefined) {
          return 'dom';
        }
        if (object._isAMomentObject === true) {
          return 'moment';
        }
        return 'object';
      } else if (type === 'number') {
        return 'number';
      } else if (type === 'boolean') {
        return 'boolean';
      } else if (type === 'string') {
        return 'string';
      } else if (type === undefined) {
        return 'undefined';
      }
      return type;
    }

    /**
     * @param {string} option
     * @param {Object} options
     * @param {Array.<string>} path
     * @static
     */

  }, {
    key: 'getSuggestion',
    value: function getSuggestion(option, options, path) {
      var localSearch = Validator.findInOptions(option, options, path, false);
      var globalSearch = Validator.findInOptions(option, allOptions, [], true);

      var localSearchThreshold = 8;
      var globalSearchThreshold = 4;

      var msg = void 0;
      if (localSearch.indexMatch !== undefined) {
        msg = ' in ' + Validator.printLocation(localSearch.path, option, '') + 'Perhaps it was incomplete? Did you mean: "' + localSearch.indexMatch + '"?\n\n';
      } else if (globalSearch.distance <= globalSearchThreshold && localSearch.distance > globalSearch.distance) {
        msg = ' in ' + Validator.printLocation(localSearch.path, option, '') + 'Perhaps it was misplaced? Matching option found at: ' + Validator.printLocation(globalSearch.path, globalSearch.closestMatch, '');
      } else if (localSearch.distance <= localSearchThreshold) {
        msg = '. Did you mean "' + localSearch.closestMatch + '"?' + Validator.printLocation(localSearch.path, option);
      } else {
        msg = '. Did you mean one of these: ' + Validator.print((0, _keys2['default'])(options)) + Validator.printLocation(path, option);
      }

      console.log('%cUnknown option detected: "' + option + '"' + msg, printStyle);
      errorFound = true;
    }

    /**
     * traverse the options in search for a match.
     * @param {string} option
     * @param {Object} options
     * @param {Array} path    | where to look for the actual option
     * @param {boolean} [recursive=false]
     * @returns {{closestMatch: string, path: Array, distance: number}}
     * @static
     */

  }, {
    key: 'findInOptions',
    value: function findInOptions(option, options, path) {
      var recursive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      var min = 1e9;
      var closestMatch = '';
      var closestMatchPath = [];
      var lowerCaseOption = option.toLowerCase();
      var indexMatch = undefined;
      // eslint-disable-next-line guard-for-in
      for (var op in options) {
        var distance = void 0;
        if (options[op].__type__ !== undefined && recursive === true) {
          var result = Validator.findInOptions(option, options[op], util.copyAndExtendArray(path, op));
          if (min > result.distance) {
            closestMatch = result.closestMatch;
            closestMatchPath = result.path;
            min = result.distance;
            indexMatch = result.indexMatch;
          }
        } else {
          if (op.toLowerCase().indexOf(lowerCaseOption) !== -1) {
            indexMatch = op;
          }
          distance = Validator.levenshteinDistance(option, op);
          if (min > distance) {
            closestMatch = op;
            closestMatchPath = util.copyArray(path);
            min = distance;
          }
        }
      }
      return {
        closestMatch: closestMatch,
        path: closestMatchPath,
        distance: min,
        indexMatch: indexMatch
      };
    }

    /**
     * @param {Array.<string>} path
     * @param {Object} option
     * @param {string} prefix
     * @returns {String}
     * @static
     */

  }, {
    key: 'printLocation',
    value: function printLocation(path, option) {
      var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'Problem value found at: \n';

      var str = '\n\n' + prefix + 'options = {\n';
      for (var i = 0; i < path.length; i++) {
        for (var j = 0; j < i + 1; j++) {
          str += '  ';
        }
        str += path[i] + ': {\n';
      }
      for (var _j = 0; _j < path.length + 1; _j++) {
        str += '  ';
      }
      str += option + '\n';
      for (var _i = 0; _i < path.length + 1; _i++) {
        for (var _j2 = 0; _j2 < path.length - _i; _j2++) {
          str += '  ';
        }
        str += '}\n';
      }
      return str + '\n\n';
    }

    /**
     * @param {Object} options
     * @returns {String}
     * @static
     */

  }, {
    key: 'print',
    value: function print(options) {
      return (0, _stringify2['default'])(options).replace(/(\")|(\[)|(\])|(,"__type__")/g, '').replace(/(\,)/g, ', ');
    }

    /**
     *  Compute the edit distance between the two given strings
     * http://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance#JavaScript
     *
     * Copyright (c) 2011 Andrei Mackenzie
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     *
     * @param {string} a
     * @param {string} b
     * @returns {Array.<Array.<number>>}}
     * @static
     */

  }, {
    key: 'levenshteinDistance',
    value: function levenshteinDistance(a, b) {
      if (a.length === 0) return b.length;
      if (b.length === 0) return a.length;

      var matrix = [];

      // increment along the first column of each row
      var i;
      for (i = 0; i <= b.length; i++) {
        matrix[i] = [i];
      }

      // increment each column in the first row
      var j;
      for (j = 0; j <= a.length; j++) {
        matrix[0][j] = j;
      }

      // Fill in the rest of the matrix
      for (i = 1; i <= b.length; i++) {
        for (j = 1; j <= a.length; j++) {
          if (b.charAt(i - 1) == a.charAt(j - 1)) {
            matrix[i][j] = matrix[i - 1][j - 1];
          } else {
            matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, // substitution
            Math.min(matrix[i][j - 1] + 1, // insertion
            matrix[i - 1][j] + 1)); // deletion
          }
        }
      }

      return matrix[b.length][a.length];
    }
  }]);
  return Validator;
}();

exports['default'] = Validator;
exports.printStyle = printStyle;

/***/ }),
/* 55 */
/***/ (function(module, exports, __nested_webpack_require_180531__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringify = __nested_webpack_require_180531__(23);

var _stringify2 = _interopRequireDefault(_stringify);

var _typeof2 = __nested_webpack_require_180531__(7);

var _typeof3 = _interopRequireDefault(_typeof2);

var _create = __nested_webpack_require_180531__(31);

var _create2 = _interopRequireDefault(_create);

var _classCallCheck2 = __nested_webpack_require_180531__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_180531__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var util = __nested_webpack_require_180531__(2);
var Label = __nested_webpack_require_180531__(77)['default'];
var ComponentUtil = __nested_webpack_require_180531__(35)['default'];
var CubicBezierEdge = __nested_webpack_require_180531__(166)['default'];
var BezierEdgeDynamic = __nested_webpack_require_180531__(168)['default'];
var BezierEdgeStatic = __nested_webpack_require_180531__(169)['default'];
var StraightEdge = __nested_webpack_require_180531__(170)['default'];

/**
 * An edge connects two nodes and has a specific direction.
 */

var Edge = function () {
  /**
   * @param {Object} options        values specific to this edge, must contain at least 'from' and 'to'
   * @param {Object} body           shared state from Network instance
   * @param {Object} globalOptions  options from the EdgesHandler instance
   * @param {Object} defaultOptions default options from the EdgeHandler instance. Value and reference are constant
   */
  function Edge(options, body, globalOptions, defaultOptions) {
    (0, _classCallCheck3['default'])(this, Edge);

    if (body === undefined) {
      throw new Error('No body provided');
    }

    // Since globalOptions is constant in values as well as reference,
    // Following needs to be done only once.

    this.options = util.bridgeObject(globalOptions);
    this.globalOptions = globalOptions;
    this.defaultOptions = defaultOptions;
    this.body = body;

    // initialize variables
    this.id = undefined;
    this.fromId = undefined;
    this.toId = undefined;
    this.selected = false;
    this.hover = false;
    this.labelDirty = true;

    this.baseWidth = this.options.width;
    this.baseFontSize = this.options.font.size;

    this.from = undefined; // a node
    this.to = undefined; // a node

    this.edgeType = undefined;

    this.connected = false;

    this.labelModule = new Label(this.body, this.options, true /* It's an edge label */
    );
    this.setOptions(options);
  }

  /**
   * Set or overwrite options for the edge
   * @param {Object} options  an object with options
   * @returns {null|boolean} null if no options, boolean if date changed
   */


  (0, _createClass3['default'])(Edge, [{
    key: 'setOptions',
    value: function setOptions(options) {
      if (!options) {
        return;
      }

      Edge.parseOptions(this.options, options, true, this.globalOptions);

      if (options.id !== undefined) {
        this.id = options.id;
      }
      if (options.from !== undefined) {
        this.fromId = options.from;
      }
      if (options.to !== undefined) {
        this.toId = options.to;
      }
      if (options.title !== undefined) {
        this.title = options.title;
      }
      if (options.value !== undefined) {
        options.value = parseFloat(options.value);
      }

      var pile = [options, this.options, this.defaultOptions];
      this.chooser = ComponentUtil.choosify('edge', pile);

      // update label Module
      this.updateLabelModule(options);

      var dataChanged = this.updateEdgeType();

      // if anything has been updates, reset the selection width and the hover width
      this._setInteractionWidths();

      // A node is connected when it has a from and to node that both exist in the network.body.nodes.
      this.connect();

      if (options.hidden !== undefined || options.physics !== undefined) {
        dataChanged = true;
      }

      return dataChanged;
    }

    /**
     *
     * @param {Object} parentOptions
     * @param {Object} newOptions
     * @param {boolean} [allowDeletion=false]
     * @param {Object} [globalOptions={}]
     * @param {boolean} [copyFromGlobals=false]
     */

  }, {
    key: 'getFormattingValues',


    /**
     *
     * @returns {ArrowOptions}
     */
    value: function getFormattingValues() {
      var toArrow = this.options.arrows.to === true || this.options.arrows.to.enabled === true;
      var fromArrow = this.options.arrows.from === true || this.options.arrows.from.enabled === true;
      var middleArrow = this.options.arrows.middle === true || this.options.arrows.middle.enabled === true;
      var inheritsColor = this.options.color.inherit;
      var values = {
        toArrow: toArrow,
        toArrowScale: this.options.arrows.to.scaleFactor,
        toArrowType: this.options.arrows.to.type,
        middleArrow: middleArrow,
        middleArrowScale: this.options.arrows.middle.scaleFactor,
        middleArrowType: this.options.arrows.middle.type,
        fromArrow: fromArrow,
        fromArrowScale: this.options.arrows.from.scaleFactor,
        fromArrowType: this.options.arrows.from.type,
        arrowStrikethrough: this.options.arrowStrikethrough,
        color: inheritsColor ? undefined : this.options.color.color,
        inheritsColor: inheritsColor,
        opacity: this.options.color.opacity,
        hidden: this.options.hidden,
        length: this.options.length,
        shadow: this.options.shadow.enabled,
        shadowColor: this.options.shadow.color,
        shadowSize: this.options.shadow.size,
        shadowX: this.options.shadow.x,
        shadowY: this.options.shadow.y,
        dashes: this.options.dashes,
        width: this.options.width,
        background: this.options.background.enabled,
        backgroundColor: this.options.background.color,
        backgroundSize: this.options.background.size,
        backgroundDashes: this.options.background.dashes
      };
      if (this.selected || this.hover) {
        if (this.chooser === true) {
          if (this.selected) {
            var selectedWidth = this.options.selectionWidth;
            if (typeof selectedWidth === 'function') {
              values.width = selectedWidth(values.width);
            } else if (typeof selectedWidth === 'number') {
              values.width += selectedWidth;
            }
            values.width = Math.max(values.width, 0.3 / this.body.view.scale);
            values.color = this.options.color.highlight;
            values.shadow = this.options.shadow.enabled;
          } else if (this.hover) {
            var hoverWidth = this.options.hoverWidth;
            if (typeof hoverWidth === 'function') {
              values.width = hoverWidth(values.width);
            } else if (typeof hoverWidth === 'number') {
              values.width += hoverWidth;
            }
            values.width = Math.max(values.width, 0.3 / this.body.view.scale);
            values.color = this.options.color.hover;
            values.shadow = this.options.shadow.enabled;
          }
        } else if (typeof this.chooser === 'function') {
          this.chooser(values, this.options.id, this.selected, this.hover);
          if (values.color !== undefined) {
            values.inheritsColor = false;
          }
          if (values.shadow === false) {
            if (values.shadowColor !== this.options.shadow.color || values.shadowSize !== this.options.shadow.size || values.shadowX !== this.options.shadow.x || values.shadowY !== this.options.shadow.y) {
              values.shadow = true;
            }
          }
        }
      } else {
        values.shadow = this.options.shadow.enabled;
        values.width = Math.max(values.width, 0.3 / this.body.view.scale);
      }
      return values;
    }

    /**
     * update the options in the label module
     *
     * @param {Object} options
     */

  }, {
    key: 'updateLabelModule',
    value: function updateLabelModule(options) {
      var pile = [options, this.options, this.globalOptions, // Currently set global edge options
      this.defaultOptions];

      this.labelModule.update(this.options, pile);

      if (this.labelModule.baseSize !== undefined) {
        this.baseFontSize = this.labelModule.baseSize;
      }
    }

    /**
     * update the edge type, set the options
     * @returns {boolean}
     */

  }, {
    key: 'updateEdgeType',
    value: function updateEdgeType() {
      var smooth = this.options.smooth;
      var dataChanged = false;
      var changeInType = true;
      if (this.edgeType !== undefined) {
        if (this.edgeType instanceof BezierEdgeDynamic && smooth.enabled === true && smooth.type === 'dynamic' || this.edgeType instanceof CubicBezierEdge && smooth.enabled === true && smooth.type === 'cubicBezier' || this.edgeType instanceof BezierEdgeStatic && smooth.enabled === true && smooth.type !== 'dynamic' && smooth.type !== 'cubicBezier' || this.edgeType instanceof StraightEdge && smooth.type.enabled === false) {
          changeInType = false;
        }
        if (changeInType === true) {
          dataChanged = this.cleanup();
        }
      }
      if (changeInType === true) {
        if (smooth.enabled === true) {
          if (smooth.type === 'dynamic') {
            dataChanged = true;
            this.edgeType = new BezierEdgeDynamic(this.options, this.body, this.labelModule);
          } else if (smooth.type === 'cubicBezier') {
            this.edgeType = new CubicBezierEdge(this.options, this.body, this.labelModule);
          } else {
            this.edgeType = new BezierEdgeStatic(this.options, this.body, this.labelModule);
          }
        } else {
          this.edgeType = new StraightEdge(this.options, this.body, this.labelModule);
        }
      } else {
        // if nothing changes, we just set the options.
        this.edgeType.setOptions(this.options);
      }
      return dataChanged;
    }

    /**
     * Connect an edge to its nodes
     */

  }, {
    key: 'connect',
    value: function connect() {
      this.disconnect();

      this.from = this.body.nodes[this.fromId] || undefined;
      this.to = this.body.nodes[this.toId] || undefined;
      this.connected = this.from !== undefined && this.to !== undefined;

      if (this.connected === true) {
        this.from.attachEdge(this);
        this.to.attachEdge(this);
      } else {
        if (this.from) {
          this.from.detachEdge(this);
        }
        if (this.to) {
          this.to.detachEdge(this);
        }
      }

      this.edgeType.connect();
    }

    /**
     * Disconnect an edge from its nodes
     */

  }, {
    key: 'disconnect',
    value: function disconnect() {
      if (this.from) {
        this.from.detachEdge(this);
        this.from = undefined;
      }
      if (this.to) {
        this.to.detachEdge(this);
        this.to = undefined;
      }

      this.connected = false;
    }

    /**
     * get the title of this edge.
     * @return {string} title    The title of the edge, or undefined when no title
     *                           has been set.
     */

  }, {
    key: 'getTitle',
    value: function getTitle() {
      return this.title;
    }

    /**
     * check if this node is selecte
     * @return {boolean} selected   True if node is selected, else false
     */

  }, {
    key: 'isSelected',
    value: function isSelected() {
      return this.selected;
    }

    /**
     * Retrieve the value of the edge. Can be undefined
     * @return {number} value
     */

  }, {
    key: 'getValue',
    value: function getValue() {
      return this.options.value;
    }

    /**
     * Adjust the value range of the edge. The edge will adjust it's width
     * based on its value.
     * @param {number} min
     * @param {number} max
     * @param {number} total
     */

  }, {
    key: 'setValueRange',
    value: function setValueRange(min, max, total) {
      if (this.options.value !== undefined) {
        var scale = this.options.scaling.customScalingFunction(min, max, total, this.options.value);
        var widthDiff = this.options.scaling.max - this.options.scaling.min;
        if (this.options.scaling.label.enabled === true) {
          var fontDiff = this.options.scaling.label.max - this.options.scaling.label.min;
          this.options.font.size = this.options.scaling.label.min + scale * fontDiff;
        }
        this.options.width = this.options.scaling.min + scale * widthDiff;
      } else {
        this.options.width = this.baseWidth;
        this.options.font.size = this.baseFontSize;
      }

      this._setInteractionWidths();
      this.updateLabelModule();
    }

    /**
     *
     * @private
     */

  }, {
    key: '_setInteractionWidths',
    value: function _setInteractionWidths() {
      if (typeof this.options.hoverWidth === 'function') {
        this.edgeType.hoverWidth = this.options.hoverWidth(this.options.width);
      } else {
        this.edgeType.hoverWidth = this.options.hoverWidth + this.options.width;
      }
      if (typeof this.options.selectionWidth === 'function') {
        this.edgeType.selectionWidth = this.options.selectionWidth(this.options.width);
      } else {
        this.edgeType.selectionWidth = this.options.selectionWidth + this.options.width;
      }
    }

    /**
     * Redraw a edge
     * Draw this edge in the given canvas
     * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
     * @param {CanvasRenderingContext2D}   ctx
     */

  }, {
    key: 'draw',
    value: function draw(ctx) {
      var values = this.getFormattingValues();
      if (values.hidden) {
        return;
      }

      // get the via node from the edge type
      var viaNode = this.edgeType.getViaNode();
      var arrowData = {};

      // restore edge targets to defaults
      this.edgeType.fromPoint = this.edgeType.from;
      this.edgeType.toPoint = this.edgeType.to;

      // from and to arrows give a different end point for edges. we set them here
      if (values.fromArrow) {
        arrowData.from = this.edgeType.getArrowData(ctx, 'from', viaNode, this.selected, this.hover, values);
        if (values.arrowStrikethrough === false) this.edgeType.fromPoint = arrowData.from.core;
      }
      if (values.toArrow) {
        arrowData.to = this.edgeType.getArrowData(ctx, 'to', viaNode, this.selected, this.hover, values);
        if (values.arrowStrikethrough === false) this.edgeType.toPoint = arrowData.to.core;
      }

      // the middle arrow depends on the line, which can depend on the to and from arrows so we do this one lastly.
      if (values.middleArrow) {
        arrowData.middle = this.edgeType.getArrowData(ctx, 'middle', viaNode, this.selected, this.hover, values);
      }

      // draw everything
      this.edgeType.drawLine(ctx, values, this.selected, this.hover, viaNode);
      this.drawArrows(ctx, arrowData, values);
      this.drawLabel(ctx, viaNode);
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {Object} arrowData
     * @param {ArrowOptions} values
     */

  }, {
    key: 'drawArrows',
    value: function drawArrows(ctx, arrowData, values) {
      if (values.fromArrow) {
        this.edgeType.drawArrowHead(ctx, values, this.selected, this.hover, arrowData.from);
      }
      if (values.middleArrow) {
        this.edgeType.drawArrowHead(ctx, values, this.selected, this.hover, arrowData.middle);
      }
      if (values.toArrow) {
        this.edgeType.drawArrowHead(ctx, values, this.selected, this.hover, arrowData.to);
      }
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {Node} viaNode
     */

  }, {
    key: 'drawLabel',
    value: function drawLabel(ctx, viaNode) {
      if (this.options.label !== undefined) {
        // set style
        var node1 = this.from;
        var node2 = this.to;

        if (this.labelModule.differentState(this.selected, this.hover)) {
          this.labelModule.getTextSize(ctx, this.selected, this.hover);
        }

        if (node1.id != node2.id) {
          this.labelModule.pointToSelf = false;
          var point = this.edgeType.getPoint(0.5, viaNode);
          ctx.save();

          var rotationPoint = this._getRotation(ctx);
          if (rotationPoint.angle != 0) {
            ctx.translate(rotationPoint.x, rotationPoint.y);
            ctx.rotate(rotationPoint.angle);
          }

          // draw the label
          this.labelModule.draw(ctx, point.x, point.y, this.selected, this.hover);

          /*
          // Useful debug code: draw a border around the label
          // This should **not** be enabled in production!
          var size = this.labelModule.getSize();; // ;; intentional so lint catches it
          ctx.strokeStyle = "#ff0000";
          ctx.strokeRect(size.left, size.top, size.width, size.height);
          // End  debug code
          */

          ctx.restore();
        } else {
          // Ignore the orientations.
          this.labelModule.pointToSelf = true;
          var x, y;
          var radius = this.options.selfReferenceSize;
          if (node1.shape.width > node1.shape.height) {
            x = node1.x + node1.shape.width * 0.5;
            y = node1.y - radius;
          } else {
            x = node1.x + radius;
            y = node1.y - node1.shape.height * 0.5;
          }
          point = this._pointOnCircle(x, y, radius, 0.125);
          this.labelModule.draw(ctx, point.x, point.y, this.selected, this.hover);
        }
      }
    }

    /**
     * Determine all visual elements of this edge instance, in which the given
     * point falls within the bounding shape.
     *
     * @param {point} point
     * @returns {Array.<edgeClickItem|edgeLabelClickItem>} list with the items which are on the point
     */

  }, {
    key: 'getItemsOnPoint',
    value: function getItemsOnPoint(point) {
      var ret = [];

      if (this.labelModule.visible()) {
        var rotationPoint = this._getRotation();
        if (ComponentUtil.pointInRect(this.labelModule.getSize(), point, rotationPoint)) {
          ret.push({ edgeId: this.id, labelId: 0 });
        }
      }

      var obj = {
        left: point.x,
        top: point.y
      };

      if (this.isOverlappingWith(obj)) {
        ret.push({ edgeId: this.id });
      }

      return ret;
    }

    /**
     * Check if this object is overlapping with the provided object
     * @param {Object} obj   an object with parameters left, top
     * @return {boolean}     True if location is located on the edge
     */

  }, {
    key: 'isOverlappingWith',
    value: function isOverlappingWith(obj) {
      if (this.connected) {
        var distMax = 10;
        var xFrom = this.from.x;
        var yFrom = this.from.y;
        var xTo = this.to.x;
        var yTo = this.to.y;
        var xObj = obj.left;
        var yObj = obj.top;

        var dist = this.edgeType.getDistanceToEdge(xFrom, yFrom, xTo, yTo, xObj, yObj);

        return dist < distMax;
      } else {
        return false;
      }
    }

    /**
     * Determine the rotation point, if any.
     *
     * @param {CanvasRenderingContext2D} [ctx] if passed, do a recalculation of the label size
     * @returns {rotationPoint} the point to rotate around and the angle in radians to rotate
     * @private
     */

  }, {
    key: '_getRotation',
    value: function _getRotation(ctx) {
      var viaNode = this.edgeType.getViaNode();
      var point = this.edgeType.getPoint(0.5, viaNode);

      if (ctx !== undefined) {
        this.labelModule.calculateLabelSize(ctx, this.selected, this.hover, point.x, point.y);
      }

      var ret = {
        x: point.x,
        y: this.labelModule.size.yLine,
        angle: 0
      };

      if (!this.labelModule.visible()) {
        return ret; // Don't even bother doing the atan2, there's nothing to draw
      }

      if (this.options.font.align === 'horizontal') {
        return ret; // No need to calculate angle
      }

      var dy = this.from.y - this.to.y;
      var dx = this.from.x - this.to.x;
      var angle = Math.atan2(dy, dx); // radians

      // rotate so that label is readable
      if (angle < -1 && dx < 0 || angle > 0 && dx < 0) {
        angle += Math.PI;
      }
      ret.angle = angle;

      return ret;
    }

    /**
     * Get a point on a circle
     * @param {number} x
     * @param {number} y
     * @param {number} radius
     * @param {number} percentage Value between 0 (line start) and 1 (line end)
     * @return {Object} point
     * @private
     */

  }, {
    key: '_pointOnCircle',
    value: function _pointOnCircle(x, y, radius, percentage) {
      var angle = percentage * 2 * Math.PI;
      return {
        x: x + radius * Math.cos(angle),
        y: y - radius * Math.sin(angle)
      };
    }

    /**
     * Sets selected state to true
     */

  }, {
    key: 'select',
    value: function select() {
      this.selected = true;
    }

    /**
     * Sets selected state to false
     */

  }, {
    key: 'unselect',
    value: function unselect() {
      this.selected = false;
    }

    /**
     * cleans all required things on delete
     * @returns {*}
     */

  }, {
    key: 'cleanup',
    value: function cleanup() {
      return this.edgeType.cleanup();
    }

    /**
     * Remove edge from the list and perform necessary cleanup.
     */

  }, {
    key: 'remove',
    value: function remove() {
      this.cleanup();
      this.disconnect();
      delete this.body.edges[this.id];
    }

    /**
     * Check if both connecting nodes exist
     * @returns {boolean}
     */

  }, {
    key: 'endPointsValid',
    value: function endPointsValid() {
      return this.body.nodes[this.fromId] !== undefined && this.body.nodes[this.toId] !== undefined;
    }
  }], [{
    key: 'parseOptions',
    value: function parseOptions(parentOptions, newOptions) {
      var allowDeletion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var globalOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var copyFromGlobals = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

      var fields = ['arrowStrikethrough', 'id', 'from', 'hidden', 'hoverWidth', 'labelHighlightBold', 'length', 'line', 'opacity', 'physics', 'scaling', 'selectionWidth', 'selfReferenceSize', 'to', 'title', 'value', 'width', 'font', 'chosen', 'widthConstraint'];

      // only deep extend the items in the field array. These do not have shorthand.
      util.selectiveDeepExtend(fields, parentOptions, newOptions, allowDeletion);

      // Only copy label if it's a legal value.
      if (ComponentUtil.isValidLabel(newOptions.label)) {
        parentOptions.label = newOptions.label;
      } else {
        parentOptions.label = undefined;
      }

      util.mergeOptions(parentOptions, newOptions, 'smooth', globalOptions);
      util.mergeOptions(parentOptions, newOptions, 'shadow', globalOptions);
      util.mergeOptions(parentOptions, newOptions, 'background', globalOptions);

      if (newOptions.dashes !== undefined && newOptions.dashes !== null) {
        parentOptions.dashes = newOptions.dashes;
      } else if (allowDeletion === true && newOptions.dashes === null) {
        parentOptions.dashes = (0, _create2['default'])(globalOptions.dashes); // this sets the pointer of the option back to the global option.
      }

      // set the scaling newOptions
      if (newOptions.scaling !== undefined && newOptions.scaling !== null) {
        if (newOptions.scaling.min !== undefined) {
          parentOptions.scaling.min = newOptions.scaling.min;
        }
        if (newOptions.scaling.max !== undefined) {
          parentOptions.scaling.max = newOptions.scaling.max;
        }
        util.mergeOptions(parentOptions.scaling, newOptions.scaling, 'label', globalOptions.scaling);
      } else if (allowDeletion === true && newOptions.scaling === null) {
        parentOptions.scaling = (0, _create2['default'])(globalOptions.scaling); // this sets the pointer of the option back to the global option.
      }

      // handle multiple input cases for arrows
      if (newOptions.arrows !== undefined && newOptions.arrows !== null) {
        if (typeof newOptions.arrows === 'string') {
          var arrows = newOptions.arrows.toLowerCase();
          parentOptions.arrows.to.enabled = arrows.indexOf('to') != -1;
          parentOptions.arrows.middle.enabled = arrows.indexOf('middle') != -1;
          parentOptions.arrows.from.enabled = arrows.indexOf('from') != -1;
        } else if ((0, _typeof3['default'])(newOptions.arrows) === 'object') {
          util.mergeOptions(parentOptions.arrows, newOptions.arrows, 'to', globalOptions.arrows);
          util.mergeOptions(parentOptions.arrows, newOptions.arrows, 'middle', globalOptions.arrows);
          util.mergeOptions(parentOptions.arrows, newOptions.arrows, 'from', globalOptions.arrows);
        } else {
          throw new Error('The arrow newOptions can only be an object or a string. Refer to the documentation. You used:' + (0, _stringify2['default'])(newOptions.arrows));
        }
      } else if (allowDeletion === true && newOptions.arrows === null) {
        parentOptions.arrows = (0, _create2['default'])(globalOptions.arrows); // this sets the pointer of the option back to the global option.
      }

      // handle multiple input cases for color
      if (newOptions.color !== undefined && newOptions.color !== null) {
        var fromColor = newOptions.color;
        var toColor = parentOptions.color;

        // If passed, fill in values from default options - required in the case of no prototype bridging
        if (copyFromGlobals) {
          util.deepExtend(toColor, globalOptions.color, false, allowDeletion);
        } else {
          // Clear local properties - need to do it like this in order to retain prototype bridges
          for (var i in toColor) {
            if (toColor.hasOwnProperty(i)) {
              delete toColor[i];
            }
          }
        }

        if (util.isString(toColor)) {
          toColor.color = toColor;
          toColor.highlight = toColor;
          toColor.hover = toColor;
          toColor.inherit = false;
          if (fromColor.opacity === undefined) {
            toColor.opacity = 1.0; // set default
          }
        } else {
          var colorsDefined = false;
          if (fromColor.color !== undefined) {
            toColor.color = fromColor.color;
            colorsDefined = true;
          }
          if (fromColor.highlight !== undefined) {
            toColor.highlight = fromColor.highlight;
            colorsDefined = true;
          }
          if (fromColor.hover !== undefined) {
            toColor.hover = fromColor.hover;
            colorsDefined = true;
          }
          if (fromColor.inherit !== undefined) {
            toColor.inherit = fromColor.inherit;
          }
          if (fromColor.opacity !== undefined) {
            toColor.opacity = Math.min(1, Math.max(0, fromColor.opacity));
          }

          if (colorsDefined === true) {
            toColor.inherit = false;
          } else {
            if (toColor.inherit === undefined) {
              toColor.inherit = 'from'; // Set default
            }
          }
        }
      } else if (allowDeletion === true && newOptions.color === null) {
        parentOptions.color = util.bridgeObject(globalOptions.color); // set the object back to the global options
      }

      if (allowDeletion === true && newOptions.font === null) {
        parentOptions.font = util.bridgeObject(globalOptions.font); // set the object back to the global options
      }
    }
  }]);
  return Edge;
}();

exports['default'] = Edge;

/***/ }),
/* 56 */
/***/ (function(module, exports, __nested_webpack_require_208434__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = __nested_webpack_require_208434__(3);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __nested_webpack_require_208434__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_208434__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __nested_webpack_require_208434__(4);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __nested_webpack_require_208434__(5);

var _inherits3 = _interopRequireDefault(_inherits2);

var _EdgeBase2 = __nested_webpack_require_208434__(79);

var _EdgeBase3 = _interopRequireDefault(_EdgeBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * The Base Class for all Bezier edges. Bezier curves are used to model smooth
 * gradual curves in paths between nodes.
 *
 * @extends EdgeBase
 */
var BezierEdgeBase = function (_EdgeBase) {
  (0, _inherits3['default'])(BezierEdgeBase, _EdgeBase);

  /**
   * @param {Object} options
   * @param {Object} body
   * @param {Label} labelModule
   */
  function BezierEdgeBase(options, body, labelModule) {
    (0, _classCallCheck3['default'])(this, BezierEdgeBase);
    return (0, _possibleConstructorReturn3['default'])(this, (BezierEdgeBase.__proto__ || (0, _getPrototypeOf2['default'])(BezierEdgeBase)).call(this, options, body, labelModule));
  }

  /**
   * This function uses binary search to look for the point where the bezier curve crosses the border of the node.
   *
   * @param {Node} nearNode
   * @param {CanvasRenderingContext2D} ctx
   * @param {Node} viaNode
   * @returns {*}
   * @private
   */


  (0, _createClass3['default'])(BezierEdgeBase, [{
    key: '_findBorderPositionBezier',
    value: function _findBorderPositionBezier(nearNode, ctx) {
      var viaNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._getViaCoordinates();

      var maxIterations = 10;
      var iteration = 0;
      var low = 0;
      var high = 1;
      var pos, angle, distanceToBorder, distanceToPoint, difference;
      var threshold = 0.2;
      var node = this.to;
      var from = false;
      if (nearNode.id === this.from.id) {
        node = this.from;
        from = true;
      }

      while (low <= high && iteration < maxIterations) {
        var middle = (low + high) * 0.5;

        pos = this.getPoint(middle, viaNode);
        angle = Math.atan2(node.y - pos.y, node.x - pos.x);
        distanceToBorder = node.distanceToBorder(ctx, angle);
        distanceToPoint = Math.sqrt(Math.pow(pos.x - node.x, 2) + Math.pow(pos.y - node.y, 2));
        difference = distanceToBorder - distanceToPoint;
        if (Math.abs(difference) < threshold) {
          break; // found
        } else if (difference < 0) {
          // distance to nodes is larger than distance to border --> t needs to be bigger if we're looking at the to node.
          if (from === false) {
            low = middle;
          } else {
            high = middle;
          }
        } else {
          if (from === false) {
            high = middle;
          } else {
            low = middle;
          }
        }

        iteration++;
      }
      pos.t = middle;

      return pos;
    }

    /**
     * Calculate the distance between a point (x3,y3) and a line segment from
     * (x1,y1) to (x2,y2).
     * http://stackoverflow.com/questions/849211/shortest-distancae-between-a-point-and-a-line-segment
     * @param {number} x1 from x
     * @param {number} y1 from y
     * @param {number} x2 to x
     * @param {number} y2 to y
     * @param {number} x3 point to check x
     * @param {number} y3 point to check y
     * @param {Node} via
     * @returns {number}
     * @private
     */

  }, {
    key: '_getDistanceToBezierEdge',
    value: function _getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, via) {
      // x3,y3 is the point
      var minDistance = 1e9;
      var distance = void 0;
      var i = void 0,
          t = void 0,
          x = void 0,
          y = void 0;
      var lastX = x1;
      var lastY = y1;
      for (i = 1; i < 10; i++) {
        t = 0.1 * i;
        x = Math.pow(1 - t, 2) * x1 + 2 * t * (1 - t) * via.x + Math.pow(t, 2) * x2;
        y = Math.pow(1 - t, 2) * y1 + 2 * t * (1 - t) * via.y + Math.pow(t, 2) * y2;
        if (i > 0) {
          distance = this._getDistanceToLine(lastX, lastY, x, y, x3, y3);
          minDistance = distance < minDistance ? distance : minDistance;
        }
        lastX = x;
        lastY = y;
      }

      return minDistance;
    }

    /**
     * Draw a bezier curve between two nodes
     *
     * The method accepts zero, one or two control points.
     * Passing zero control points just draws a straight line
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {Object}           values   | options for shadow drawing
     * @param {Object|undefined} viaNode1 | first control point for curve drawing
     * @param {Object|undefined} viaNode2 | second control point for curve drawing
     *
     * @protected
     */

  }, {
    key: '_bezierCurve',
    value: function _bezierCurve(ctx, values, viaNode1, viaNode2) {
      var hasNode1 = viaNode1 !== undefined && viaNode1.x !== undefined;
      var hasNode2 = viaNode2 !== undefined && viaNode2.x !== undefined;

      ctx.beginPath();
      ctx.moveTo(this.fromPoint.x, this.fromPoint.y);

      if (hasNode1 && hasNode2) {
        ctx.bezierCurveTo(viaNode1.x, viaNode1.y, viaNode2.x, viaNode2.y, this.toPoint.x, this.toPoint.y);
      } else if (hasNode1) {
        ctx.quadraticCurveTo(viaNode1.x, viaNode1.y, this.toPoint.x, this.toPoint.y);
      } else {
        // fallback to normal straight edge
        ctx.lineTo(this.toPoint.x, this.toPoint.y);
      }
      // draw a background
      this.drawBackground(ctx, values);

      // draw shadow if enabled
      this.enableShadow(ctx, values);
      ctx.stroke();
      this.disableShadow(ctx, values);
    }

    /**
     *
     * @returns {*|{x, y}|{x: undefined, y: undefined}}
     */

  }, {
    key: 'getViaNode',
    value: function getViaNode() {
      return this._getViaCoordinates();
    }
  }]);
  return BezierEdgeBase;
}(_EdgeBase3['default']);

exports['default'] = BezierEdgeBase;

/***/ }),
/* 57 */
/***/ (function(module, exports, __nested_webpack_require_214899__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __nested_webpack_require_214899__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_214899__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var util = __nested_webpack_require_214899__(2);

/**
 * Utility Class
 */

var NetworkUtil = function () {
  /**
   * @ignore
   */
  function NetworkUtil() {
    (0, _classCallCheck3['default'])(this, NetworkUtil);
  }

  /**
   * Find the center position of the network considering the bounding boxes
   *
   * @param {Array.<Node>} allNodes
   * @param {Array.<Node>} [specificNodes=[]]
   * @returns {{minX: number, maxX: number, minY: number, maxY: number}}
   * @static
   */


  (0, _createClass3['default'])(NetworkUtil, null, [{
    key: 'getRange',
    value: function getRange(allNodes) {
      var specificNodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      var minY = 1e9,
          maxY = -1e9,
          minX = 1e9,
          maxX = -1e9,
          node;
      if (specificNodes.length > 0) {
        for (var i = 0; i < specificNodes.length; i++) {
          node = allNodes[specificNodes[i]];
          if (minX > node.shape.boundingBox.left) {
            minX = node.shape.boundingBox.left;
          }
          if (maxX < node.shape.boundingBox.right) {
            maxX = node.shape.boundingBox.right;
          }
          if (minY > node.shape.boundingBox.top) {
            minY = node.shape.boundingBox.top;
          } // top is negative, bottom is positive
          if (maxY < node.shape.boundingBox.bottom) {
            maxY = node.shape.boundingBox.bottom;
          } // top is negative, bottom is positive
        }
      }

      if (minX === 1e9 && maxX === -1e9 && minY === 1e9 && maxY === -1e9) {
        ;minY = 0, maxY = 0, minX = 0, maxX = 0;
      }
      return { minX: minX, maxX: maxX, minY: minY, maxY: maxY };
    }

    /**
     * Find the center position of the network
     *
     * @param {Array.<Node>} allNodes
     * @param {Array.<Node>} [specificNodes=[]]
     * @returns {{minX: number, maxX: number, minY: number, maxY: number}}
     * @static
     */

  }, {
    key: 'getRangeCore',
    value: function getRangeCore(allNodes) {
      var specificNodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      var minY = 1e9,
          maxY = -1e9,
          minX = 1e9,
          maxX = -1e9,
          node;
      if (specificNodes.length > 0) {
        for (var i = 0; i < specificNodes.length; i++) {
          node = allNodes[specificNodes[i]];
          if (minX > node.x) {
            minX = node.x;
          }
          if (maxX < node.x) {
            maxX = node.x;
          }
          if (minY > node.y) {
            minY = node.y;
          } // top is negative, bottom is positive
          if (maxY < node.y) {
            maxY = node.y;
          } // top is negative, bottom is positive
        }
      }

      if (minX === 1e9 && maxX === -1e9 && minY === 1e9 && maxY === -1e9) {
        ;minY = 0, maxY = 0, minX = 0, maxX = 0;
      }
      return { minX: minX, maxX: maxX, minY: minY, maxY: maxY };
    }

    /**
     * @param {object} range = {minX: minX, maxX: maxX, minY: minY, maxY: maxY};
     * @returns {{x: number, y: number}}
     * @static
     */

  }, {
    key: 'findCenter',
    value: function findCenter(range) {
      return {
        x: 0.5 * (range.maxX + range.minX),
        y: 0.5 * (range.maxY + range.minY)
      };
    }

    /**
     * This returns a clone of the options or options of the edge or node to be used for construction of new edges or check functions for new nodes.
     * @param {vis.Item} item
     * @param {'node'|undefined} type
     * @returns {{}}
     * @static
     */

  }, {
    key: 'cloneOptions',
    value: function cloneOptions(item, type) {
      var clonedOptions = {};
      if (type === undefined || type === 'node') {
        util.deepExtend(clonedOptions, item.options, true);
        clonedOptions.x = item.x;
        clonedOptions.y = item.y;
        clonedOptions.amountOfConnections = item.edges.length;
      } else {
        util.deepExtend(clonedOptions, item.options, true);
      }
      return clonedOptions;
    }
  }]);
  return NetworkUtil;
}();

exports['default'] = NetworkUtil;

/***/ }),
/* 58 */
/***/ (function(module, exports, __nested_webpack_require_219462__) {

module.exports = { "default": __nested_webpack_require_219462__(86), __esModule: true };

/***/ }),
/* 59 */
/***/ (function(module, exports, __nested_webpack_require_219614__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __nested_webpack_require_219614__(38);
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),
/* 60 */
/***/ (function(module, exports, __nested_webpack_require_219987__) {

"use strict";

var LIBRARY = __nested_webpack_require_219987__(27);
var $export = __nested_webpack_require_219987__(11);
var redefine = __nested_webpack_require_219987__(64);
var hide = __nested_webpack_require_219987__(19);
var Iterators = __nested_webpack_require_219987__(25);
var $iterCreate = __nested_webpack_require_219987__(91);
var setToStringTag = __nested_webpack_require_219987__(46);
var getPrototypeOf = __nested_webpack_require_219987__(66);
var ITERATOR = __nested_webpack_require_219987__(8)('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),
/* 61 */
/***/ (function(module, exports, __nested_webpack_require_222850__) {

// optional / simple context binding
var aFunction = __nested_webpack_require_222850__(90);
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),
/* 62 */
/***/ (function(module, exports, __nested_webpack_require_223447__) {

module.exports = !__nested_webpack_require_223447__(13) && !__nested_webpack_require_223447__(22)(function () {
  return Object.defineProperty(__nested_webpack_require_223447__(63)('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 63 */
/***/ (function(module, exports, __nested_webpack_require_223725__) {

var isObject = __nested_webpack_require_223725__(21);
var document = __nested_webpack_require_223725__(10).document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),
/* 64 */
/***/ (function(module, exports, __nested_webpack_require_224095__) {

module.exports = __nested_webpack_require_224095__(19);


/***/ }),
/* 65 */
/***/ (function(module, exports, __nested_webpack_require_224215__) {

var has = __nested_webpack_require_224215__(14);
var toIObject = __nested_webpack_require_224215__(18);
var arrayIndexOf = __nested_webpack_require_224215__(93)(false);
var IE_PROTO = __nested_webpack_require_224215__(43)('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),
/* 66 */
/***/ (function(module, exports, __nested_webpack_require_224829__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __nested_webpack_require_224829__(14);
var toObject = __nested_webpack_require_224829__(30);
var IE_PROTO = __nested_webpack_require_224829__(43)('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),
/* 67 */
/***/ (function(module, exports, __nested_webpack_require_225405__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __nested_webpack_require_225405__(38);
var TAG = __nested_webpack_require_225405__(8)('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),
/* 68 */
/***/ (function(module, exports, __nested_webpack_require_226212__) {

// most Object methods by ES6 should accept primitives
var $export = __nested_webpack_require_226212__(11);
var core = __nested_webpack_require_226212__(6);
var fails = __nested_webpack_require_226212__(22);
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};


/***/ }),
/* 69 */
/***/ (function(module, exports, __nested_webpack_require_226671__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __nested_webpack_require_226671__(65);
var hiddenKeys = __nested_webpack_require_226671__(45).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),
/* 70 */
/***/ (function(module, exports, __nested_webpack_require_227022__) {

var pIE = __nested_webpack_require_227022__(32);
var createDesc = __nested_webpack_require_227022__(28);
var toIObject = __nested_webpack_require_227022__(18);
var toPrimitive = __nested_webpack_require_227022__(40);
var has = __nested_webpack_require_227022__(14);
var IE8_DOM_DEFINE = __nested_webpack_require_227022__(62);
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __nested_webpack_require_227022__(13) ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),
/* 71 */
/***/ (function(module, exports, __nested_webpack_require_227667__) {

"use strict";


// first check if moment.js is already loaded in the browser window, if so,
// use this instance. Else, load via commonjs.
module.exports = typeof window !== 'undefined' && window['moment'] || __nested_webpack_require_227667__(116);

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A queue
 * @param {Object} options
 *            Available options:
 *            - delay: number    When provided, the queue will be flushed
 *                               automatically after an inactivity of this delay
 *                               in milliseconds.
 *                               Default value is null.
 *            - max: number      When the queue exceeds the given maximum number
 *                               of entries, the queue is flushed automatically.
 *                               Default value of max is Infinity.
 * @constructor Queue
 */
function Queue(options) {
  // options
  this.delay = null;
  this.max = Infinity;

  // properties
  this._queue = [];
  this._timeout = null;
  this._extended = null;

  this.setOptions(options);
}

/**
 * Update the configuration of the queue
 * @param {Object} options
 *            Available options:
 *            - delay: number    When provided, the queue will be flushed
 *                               automatically after an inactivity of this delay
 *                               in milliseconds.
 *                               Default value is null.
 *            - max: number      When the queue exceeds the given maximum number
 *                               of entries, the queue is flushed automatically.
 *                               Default value of max is Infinity.
 */
Queue.prototype.setOptions = function (options) {
  if (options && typeof options.delay !== 'undefined') {
    this.delay = options.delay;
  }
  if (options && typeof options.max !== 'undefined') {
    this.max = options.max;
  }

  this._flushIfNeeded();
};

/**
 * Extend an object with queuing functionality.
 * The object will be extended with a function flush, and the methods provided
 * in options.replace will be replaced with queued ones.
 * @param {Object} object
 * @param {Object} options
 *            Available options:
 *            - replace: Array.<string>
 *                               A list with method names of the methods
 *                               on the object to be replaced with queued ones.
 *            - delay: number    When provided, the queue will be flushed
 *                               automatically after an inactivity of this delay
 *                               in milliseconds.
 *                               Default value is null.
 *            - max: number      When the queue exceeds the given maximum number
 *                               of entries, the queue is flushed automatically.
 *                               Default value of max is Infinity.
 * @return {Queue} Returns the created queue
 */
Queue.extend = function (object, options) {
  var queue = new Queue(options);

  if (object.flush !== undefined) {
    throw new Error('Target object already has a property flush');
  }
  object.flush = function () {
    queue.flush();
  };

  var methods = [{
    name: 'flush',
    original: undefined
  }];

  if (options && options.replace) {
    for (var i = 0; i < options.replace.length; i++) {
      var name = options.replace[i];
      methods.push({
        name: name,
        original: object[name]
      });
      queue.replace(object, name);
    }
  }

  queue._extended = {
    object: object,
    methods: methods
  };

  return queue;
};

/**
 * Destroy the queue. The queue will first flush all queued actions, and in
 * case it has extended an object, will restore the original object.
 */
Queue.prototype.destroy = function () {
  this.flush();

  if (this._extended) {
    var object = this._extended.object;
    var methods = this._extended.methods;
    for (var i = 0; i < methods.length; i++) {
      var method = methods[i];
      if (method.original) {
        object[method.name] = method.original;
      } else {
        delete object[method.name];
      }
    }
    this._extended = null;
  }
};

/**
 * Replace a method on an object with a queued version
 * @param {Object} object   Object having the method
 * @param {string} method   The method name
 */
Queue.prototype.replace = function (object, method) {
  var me = this;
  var original = object[method];
  if (!original) {
    throw new Error('Method ' + method + ' undefined');
  }

  object[method] = function () {
    // create an Array with the arguments
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args[i] = arguments[i];
    }

    // add this call to the queue
    me.queue({
      args: args,
      fn: original,
      context: this
    });
  };
};

/**
 * Queue a call
 * @param {function | {fn: function, args: Array} | {fn: function, args: Array, context: Object}} entry
 */
Queue.prototype.queue = function (entry) {
  if (typeof entry === 'function') {
    this._queue.push({ fn: entry });
  } else {
    this._queue.push(entry);
  }

  this._flushIfNeeded();
};

/**
 * Check whether the queue needs to be flushed
 * @private
 */
Queue.prototype._flushIfNeeded = function () {
  // flush when the maximum is exceeded.
  if (this._queue.length > this.max) {
    this.flush();
  }

  // flush after a period of inactivity when a delay is configured
  clearTimeout(this._timeout);
  if (this.queue.length > 0 && typeof this.delay === 'number') {
    var me = this;
    this._timeout = setTimeout(function () {
      me.flush();
    }, this.delay);
  }
};

/**
 * Flush all queued calls
 */
Queue.prototype.flush = function () {
  while (this._queue.length > 0) {
    var entry = this._queue.shift();
    entry.fn.apply(entry.context || entry.fn, entry.args || []);
  }
};

module.exports = Queue;

/***/ }),
/* 73 */
/***/ (function(module, exports) {


/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks[event] = this._callbacks[event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  var self = this;
  this._callbacks = this._callbacks || {};

  function on() {
    self.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks[event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks[event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks[event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};


/***/ }),
/* 74 */
/***/ (function(module, exports, __nested_webpack_require_236714__) {

"use strict";


var _create = __nested_webpack_require_236714__(31);

var _create2 = _interopRequireDefault(_create);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * Parse a text source containing data in DOT language into a JSON object.
 * The object contains two lists: one with nodes and one with edges.
 *
 * DOT language reference: http://www.graphviz.org/doc/info/lang.html
 *
 * DOT language attributes: http://graphviz.org/content/attrs
 *
 * @param {string} data     Text containing a graph in DOT-notation
 * @return {Object} graph   An object containing two parameters:
 *                          {Object[]} nodes
 *                          {Object[]} edges
 *
 * -------------------------------------------
 * TODO
 * ====
 *
 * For label handling, this is an incomplete implementation. From docs (quote #3015):
 *
 * > the escape sequences "\n", "\l" and "\r" divide the label into lines, centered,
 * > left-justified, and right-justified, respectively.
 *
 * Source: http://www.graphviz.org/content/attrs#kescString
 *
 * > As another aid for readability, dot allows double-quoted strings to span multiple physical
 * > lines using the standard C convention of a backslash immediately preceding a newline
 * > character
 * > In addition, double-quoted strings can be concatenated using a '+' operator.
 * > As HTML strings can contain newline characters, which are used solely for formatting,
 * > the language does not allow escaped newlines or concatenation operators to be used
 * > within them.
 *
 * - Currently, only '\\n' is handled
 * - Note that text explicitly says 'labels'; the dot parser currently handles escape
 *   sequences in **all** strings.
 */
function parseDOT(data) {
  dot = data;
  return parseGraph();
}

// mapping of attributes from DOT (the keys) to vis.js (the values)
var NODE_ATTR_MAPPING = {
  fontsize: 'font.size',
  fontcolor: 'font.color',
  labelfontcolor: 'font.color',
  fontname: 'font.face',
  color: ['color.border', 'color.background'],
  fillcolor: 'color.background',
  tooltip: 'title',
  labeltooltip: 'title'
};
var EDGE_ATTR_MAPPING = (0, _create2['default'])(NODE_ATTR_MAPPING);
EDGE_ATTR_MAPPING.color = 'color.color';
EDGE_ATTR_MAPPING.style = 'dashes';

// token types enumeration
var TOKENTYPE = {
  NULL: 0,
  DELIMITER: 1,
  IDENTIFIER: 2,
  UNKNOWN: 3

  // map with all delimiters
};var DELIMITERS = {
  '{': true,
  '}': true,
  '[': true,
  ']': true,
  ';': true,
  '=': true,
  ',': true,

  '->': true,
  '--': true
};

var dot = ''; // current dot file
var index = 0; // current index in dot file
var c = ''; // current token character in expr
var token = ''; // current token
var tokenType = TOKENTYPE.NULL; // type of the token

/**
 * Get the first character from the dot file.
 * The character is stored into the char c. If the end of the dot file is
 * reached, the function puts an empty string in c.
 */
function first() {
  index = 0;
  c = dot.charAt(0);
}

/**
 * Get the next character from the dot file.
 * The character is stored into the char c. If the end of the dot file is
 * reached, the function puts an empty string in c.
 */
function next() {
  index++;
  c = dot.charAt(index);
}

/**
 * Preview the next character from the dot file.
 * @return {string} cNext
 */
function nextPreview() {
  return dot.charAt(index + 1);
}

var regexAlphaNumeric = /[a-zA-Z_0-9.:#]/;
/**
 * Test whether given character is alphabetic or numeric
 * @param {string} c
 * @return {Boolean} isAlphaNumeric
 */
function isAlphaNumeric(c) {
  return regexAlphaNumeric.test(c);
}

/**
 * Merge all options of object b into object b
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 */
function merge(a, b) {
  if (!a) {
    a = {};
  }

  if (b) {
    for (var name in b) {
      if (b.hasOwnProperty(name)) {
        a[name] = b[name];
      }
    }
  }
  return a;
}

/**
 * Set a value in an object, where the provided parameter name can be a
 * path with nested parameters. For example:
 *
 *     var obj = {a: 2};
 *     setValue(obj, 'b.c', 3);     // obj = {a: 2, b: {c: 3}}
 *
 * @param {Object} obj
 * @param {string} path  A parameter name or dot-separated parameter path,
 *                      like "color.highlight.border".
 * @param {*} value
 */
function setValue(obj, path, value) {
  var keys = path.split('.');
  var o = obj;
  while (keys.length) {
    var key = keys.shift();
    if (keys.length) {
      // this isn't the end point
      if (!o[key]) {
        o[key] = {};
      }
      o = o[key];
    } else {
      // this is the end point
      o[key] = value;
    }
  }
}

/**
 * Add a node to a graph object. If there is already a node with
 * the same id, their attributes will be merged.
 * @param {Object} graph
 * @param {Object} node
 */
function addNode(graph, node) {
  var i, len;
  var current = null;

  // find root graph (in case of subgraph)
  var graphs = [graph]; // list with all graphs from current graph to root graph
  var root = graph;
  while (root.parent) {
    graphs.push(root.parent);
    root = root.parent;
  }

  // find existing node (at root level) by its id
  if (root.nodes) {
    for (i = 0, len = root.nodes.length; i < len; i++) {
      if (node.id === root.nodes[i].id) {
        current = root.nodes[i];
        break;
      }
    }
  }

  if (!current) {
    // this is a new node
    current = {
      id: node.id
    };
    if (graph.node) {
      // clone default attributes
      current.attr = merge(current.attr, graph.node);
    }
  }

  // add node to this (sub)graph and all its parent graphs
  for (i = graphs.length - 1; i >= 0; i--) {
    var g = graphs[i];

    if (!g.nodes) {
      g.nodes = [];
    }
    if (g.nodes.indexOf(current) === -1) {
      g.nodes.push(current);
    }
  }

  // merge attributes
  if (node.attr) {
    current.attr = merge(current.attr, node.attr);
  }
}

/**
 * Add an edge to a graph object
 * @param {Object} graph
 * @param {Object} edge
 */
function addEdge(graph, edge) {
  if (!graph.edges) {
    graph.edges = [];
  }
  graph.edges.push(edge);
  if (graph.edge) {
    var attr = merge({}, graph.edge); // clone default attributes
    edge.attr = merge(attr, edge.attr); // merge attributes
  }
}

/**
 * Create an edge to a graph object
 * @param {Object} graph
 * @param {string | number | Object} from
 * @param {string | number | Object} to
 * @param {string} type
 * @param {Object | null} attr
 * @return {Object} edge
 */
function createEdge(graph, from, to, type, attr) {
  var edge = {
    from: from,
    to: to,
    type: type
  };

  if (graph.edge) {
    edge.attr = merge({}, graph.edge); // clone default attributes
  }
  edge.attr = merge(edge.attr || {}, attr); // merge attributes

  // Move arrows attribute from attr to edge temporally created in
  // parseAttributeList().
  if (attr != null) {
    if (attr.hasOwnProperty('arrows')) {
      edge['arrows'] = { to: { enabled: true, type: attr.arrows.type } };
      attr['arrows'] = null;
    }
  }
  return edge;
}

/**
 * Get next token in the current dot file.
 * The token and token type are available as token and tokenType
 */
function getToken() {
  tokenType = TOKENTYPE.NULL;
  token = '';

  // skip over whitespaces
  while (c === ' ' || c === '\t' || c === '\n' || c === '\r') {
    // space, tab, enter
    next();
  }

  do {
    var isComment = false;

    // skip comment
    if (c === '#') {
      // find the previous non-space character
      var i = index - 1;
      while (dot.charAt(i) === ' ' || dot.charAt(i) === '\t') {
        i--;
      }
      if (dot.charAt(i) === '\n' || dot.charAt(i) === '') {
        // the # is at the start of a line, this is indeed a line comment
        while (c != '' && c != '\n') {
          next();
        }
        isComment = true;
      }
    }
    if (c === '/' && nextPreview() === '/') {
      // skip line comment
      while (c != '' && c != '\n') {
        next();
      }
      isComment = true;
    }
    if (c === '/' && nextPreview() === '*') {
      // skip block comment
      while (c != '') {
        if (c === '*' && nextPreview() === '/') {
          // end of block comment found. skip these last two characters
          next();
          next();
          break;
        } else {
          next();
        }
      }
      isComment = true;
    }

    // skip over whitespaces
    while (c === ' ' || c === '\t' || c === '\n' || c === '\r') {
      // space, tab, enter
      next();
    }
  } while (isComment);

  // check for end of dot file
  if (c === '') {
    // token is still empty
    tokenType = TOKENTYPE.DELIMITER;
    return;
  }

  // check for delimiters consisting of 2 characters
  var c2 = c + nextPreview();
  if (DELIMITERS[c2]) {
    tokenType = TOKENTYPE.DELIMITER;
    token = c2;
    next();
    next();
    return;
  }

  // check for delimiters consisting of 1 character
  if (DELIMITERS[c]) {
    tokenType = TOKENTYPE.DELIMITER;
    token = c;
    next();
    return;
  }

  // check for an identifier (number or string)
  // TODO: more precise parsing of numbers/strings (and the port separator ':')
  if (isAlphaNumeric(c) || c === '-') {
    token += c;
    next();

    while (isAlphaNumeric(c)) {
      token += c;
      next();
    }
    if (token === 'false') {
      token = false; // convert to boolean
    } else if (token === 'true') {
      token = true; // convert to boolean
    } else if (!isNaN(Number(token))) {
      token = Number(token); // convert to number
    }
    tokenType = TOKENTYPE.IDENTIFIER;
    return;
  }

  // check for a string enclosed by double quotes
  if (c === '"') {
    next();
    while (c != '' && (c != '"' || c === '"' && nextPreview() === '"')) {
      if (c === '"') {
        // skip the escape character
        token += c;
        next();
      } else if (c === '\\' && nextPreview() === 'n') {
        // Honor a newline escape sequence
        token += '\n';
        next();
      } else {
        token += c;
      }
      next();
    }
    if (c != '"') {
      throw newSyntaxError('End of string " expected');
    }
    next();
    tokenType = TOKENTYPE.IDENTIFIER;
    return;
  }

  // something unknown is found, wrong characters, a syntax error
  tokenType = TOKENTYPE.UNKNOWN;
  while (c != '') {
    token += c;
    next();
  }
  throw new SyntaxError('Syntax error in part "' + chop(token, 30) + '"');
}

/**
 * Parse a graph.
 * @returns {Object} graph
 */
function parseGraph() {
  var graph = {};

  first();
  getToken();

  // optional strict keyword
  if (token === 'strict') {
    graph.strict = true;
    getToken();
  }

  // graph or digraph keyword
  if (token === 'graph' || token === 'digraph') {
    graph.type = token;
    getToken();
  }

  // optional graph id
  if (tokenType === TOKENTYPE.IDENTIFIER) {
    graph.id = token;
    getToken();
  }

  // open angle bracket
  if (token != '{') {
    throw newSyntaxError('Angle bracket { expected');
  }
  getToken();

  // statements
  parseStatements(graph);

  // close angle bracket
  if (token != '}') {
    throw newSyntaxError('Angle bracket } expected');
  }
  getToken();

  // end of file
  if (token !== '') {
    throw newSyntaxError('End of file expected');
  }
  getToken();

  // remove temporary default options
  delete graph.node;
  delete graph.edge;
  delete graph.graph;

  return graph;
}

/**
 * Parse a list with statements.
 * @param {Object} graph
 */
function parseStatements(graph) {
  while (token !== '' && token != '}') {
    parseStatement(graph);
    if (token === ';') {
      getToken();
    }
  }
}

/**
 * Parse a single statement. Can be a an attribute statement, node
 * statement, a series of node statements and edge statements, or a
 * parameter.
 * @param {Object} graph
 */
function parseStatement(graph) {
  // parse subgraph
  var subgraph = parseSubgraph(graph);
  if (subgraph) {
    // edge statements
    parseEdge(graph, subgraph);

    return;
  }

  // parse an attribute statement
  var attr = parseAttributeStatement(graph);
  if (attr) {
    return;
  }

  // parse node
  if (tokenType != TOKENTYPE.IDENTIFIER) {
    throw newSyntaxError('Identifier expected');
  }
  var id = token; // id can be a string or a number
  getToken();

  if (token === '=') {
    // id statement
    getToken();
    if (tokenType != TOKENTYPE.IDENTIFIER) {
      throw newSyntaxError('Identifier expected');
    }
    graph[id] = token;
    getToken();
    // TODO: implement comma separated list with "a_list: ID=ID [','] [a_list] "
  } else {
    parseNodeStatement(graph, id);
  }
}

/**
 * Parse a subgraph
 * @param {Object} graph    parent graph object
 * @return {Object | null} subgraph
 */
function parseSubgraph(graph) {
  var subgraph = null;

  // optional subgraph keyword
  if (token === 'subgraph') {
    subgraph = {};
    subgraph.type = 'subgraph';
    getToken();

    // optional graph id
    if (tokenType === TOKENTYPE.IDENTIFIER) {
      subgraph.id = token;
      getToken();
    }
  }

  // open angle bracket
  if (token === '{') {
    getToken();

    if (!subgraph) {
      subgraph = {};
    }
    subgraph.parent = graph;
    subgraph.node = graph.node;
    subgraph.edge = graph.edge;
    subgraph.graph = graph.graph;

    // statements
    parseStatements(subgraph);

    // close angle bracket
    if (token != '}') {
      throw newSyntaxError('Angle bracket } expected');
    }
    getToken();

    // remove temporary default options
    delete subgraph.node;
    delete subgraph.edge;
    delete subgraph.graph;
    delete subgraph.parent;

    // register at the parent graph
    if (!graph.subgraphs) {
      graph.subgraphs = [];
    }
    graph.subgraphs.push(subgraph);
  }

  return subgraph;
}

/**
 * parse an attribute statement like "node [shape=circle fontSize=16]".
 * Available keywords are 'node', 'edge', 'graph'.
 * The previous list with default attributes will be replaced
 * @param {Object} graph
 * @returns {String | null} keyword Returns the name of the parsed attribute
 *                                  (node, edge, graph), or null if nothing
 *                                  is parsed.
 */
function parseAttributeStatement(graph) {
  // attribute statements
  if (token === 'node') {
    getToken();

    // node attributes
    graph.node = parseAttributeList();
    return 'node';
  } else if (token === 'edge') {
    getToken();

    // edge attributes
    graph.edge = parseAttributeList();
    return 'edge';
  } else if (token === 'graph') {
    getToken();

    // graph attributes
    graph.graph = parseAttributeList();
    return 'graph';
  }

  return null;
}

/**
 * parse a node statement
 * @param {Object} graph
 * @param {string | number} id
 */
function parseNodeStatement(graph, id) {
  // node statement
  var node = {
    id: id
  };
  var attr = parseAttributeList();
  if (attr) {
    node.attr = attr;
  }
  addNode(graph, node);

  // edge statements
  parseEdge(graph, id);
}

/**
 * Parse an edge or a series of edges
 * @param {Object} graph
 * @param {string | number} from        Id of the from node
 */
function parseEdge(graph, from) {
  while (token === '->' || token === '--') {
    var to;
    var type = token;
    getToken();

    var subgraph = parseSubgraph(graph);
    if (subgraph) {
      to = subgraph;
    } else {
      if (tokenType != TOKENTYPE.IDENTIFIER) {
        throw newSyntaxError('Identifier or subgraph expected');
      }
      to = token;
      addNode(graph, {
        id: to
      });
      getToken();
    }

    // parse edge attributes
    var attr = parseAttributeList();

    // create edge
    var edge = createEdge(graph, from, to, type, attr);
    addEdge(graph, edge);

    from = to;
  }
}

/**
 * As explained in [1], graphviz has limitations for combination of
 * arrow[head|tail] and dir. If attribute list includes 'dir',
 * following cases just be supported.
 *   1. both or none + arrowhead, arrowtail
 *   2. forward + arrowhead (arrowtail is not affedted)
 *   3. back + arrowtail (arrowhead is not affected)
 * [1] https://www.graphviz.org/doc/info/attrs.html#h:undir_note
 *
 * This function is called from parseAttributeList() to parse 'dir'
 * attribute with given 'attr_names' and 'attr_list'.
 * @param {Object} attr_names  Array of attribute names
 * @param {Object} attr_list  Array of objects of attribute set
 * @return {Object} attr_list  Updated attr_list
 */
function parseDirAttribute(attr_names, attr_list) {
  var i;
  if (attr_names.includes('dir')) {
    var idx = {}; // get index of 'arrows' and 'dir'
    idx.arrows = {};
    for (i = 0; i < attr_list.length; i++) {
      if (attr_list[i].name === 'arrows') {
        if (attr_list[i].value.to != null) {
          idx.arrows.to = i;
        } else if (attr_list[i].value.from != null) {
          idx.arrows.from = i;
        } else {
          throw newSyntaxError('Invalid value of arrows');
        }
      } else if (attr_list[i].name === 'dir') {
        idx.dir = i;
      }
    }

    // first, add default arrow shape if it is not assigned to avoid error
    var dir_type = attr_list[idx.dir].value;
    if (!attr_names.includes('arrows')) {
      if (dir_type === 'both') {
        attr_list.push({
          attr: attr_list[idx.dir].attr,
          name: 'arrows',
          value: { to: { enabled: true } }
        });
        idx.arrows.to = attr_list.length - 1;
        attr_list.push({
          attr: attr_list[idx.dir].attr,
          name: 'arrows',
          value: { from: { enabled: true } }
        });
        idx.arrows.from = attr_list.length - 1;
      } else if (dir_type === 'forward') {
        attr_list.push({
          attr: attr_list[idx.dir].attr,
          name: 'arrows',
          value: { to: { enabled: true } }
        });
        idx.arrows.to = attr_list.length - 1;
      } else if (dir_type === 'back') {
        attr_list.push({
          attr: attr_list[idx.dir].attr,
          name: 'arrows',
          value: { from: { enabled: true } }
        });
        idx.arrows.from = attr_list.length - 1;
      } else if (dir_type === 'none') {
        attr_list.push({
          attr: attr_list[idx.dir].attr,
          name: 'arrows',
          value: ''
        });
        idx.arrows.to = attr_list.length - 1;
      } else {
        throw newSyntaxError('Invalid dir type "' + dir_type + '"');
      }
    }

    var from_type;
    var to_type;
    // update 'arrows' attribute from 'dir'.
    if (dir_type === 'both') {
      // both of shapes of 'from' and 'to' are given
      if (idx.arrows.to && idx.arrows.from) {
        to_type = attr_list[idx.arrows.to].value.to.type;
        from_type = attr_list[idx.arrows.from].value.from.type;
        attr_list[idx.arrows.to] = {
          attr: attr_list[idx.arrows.to].attr,
          name: attr_list[idx.arrows.to].name,
          value: {
            to: { enabled: true, type: to_type },
            from: { enabled: true, type: from_type }
          }
        };
        attr_list.splice(idx.arrows.from, 1);

        // shape of 'to' is assigned and use default to 'from'
      } else if (idx.arrows.to) {
        to_type = attr_list[idx.arrows.to].value.to.type;
        from_type = 'arrow';
        attr_list[idx.arrows.to] = {
          attr: attr_list[idx.arrows.to].attr,
          name: attr_list[idx.arrows.to].name,
          value: {
            to: { enabled: true, type: to_type },
            from: { enabled: true, type: from_type }
          }

          // only shape of 'from' is assigned and use default for 'to'
        };
      } else if (idx.arrows.from) {
        to_type = 'arrow';
        from_type = attr_list[idx.arrows.from].value.from.type;
        attr_list[idx.arrows.from] = {
          attr: attr_list[idx.arrows.from].attr,
          name: attr_list[idx.arrows.from].name,
          value: {
            to: { enabled: true, type: to_type },
            from: { enabled: true, type: from_type }
          }
        };
      }
    } else if (dir_type === 'back') {
      // given both of shapes, but use only 'from'
      if (idx.arrows.to && idx.arrows.from) {
        to_type = '';
        from_type = attr_list[idx.arrows.from].value.from.type;
        attr_list[idx.arrows.from] = {
          attr: attr_list[idx.arrows.from].attr,
          name: attr_list[idx.arrows.from].name,
          value: {
            to: { enabled: true, type: to_type },
            from: { enabled: true, type: from_type }
          }

          // given shape of 'to', but does not use it
        };
      } else if (idx.arrows.to) {
        to_type = '';
        from_type = 'arrow';
        idx.arrows.from = idx.arrows.to;
        attr_list[idx.arrows.from] = {
          attr: attr_list[idx.arrows.from].attr,
          name: attr_list[idx.arrows.from].name,
          value: {
            to: { enabled: true, type: to_type },
            from: { enabled: true, type: from_type }
          }

          // assign given 'from' shape
        };
      } else if (idx.arrows.from) {
        to_type = '';
        from_type = attr_list[idx.arrows.from].value.from.type;
        attr_list[idx.arrows.to] = {
          attr: attr_list[idx.arrows.from].attr,
          name: attr_list[idx.arrows.from].name,
          value: {
            to: { enabled: true, type: to_type },
            from: { enabled: true, type: from_type }
          }
        };
      }

      attr_list[idx.arrows.from] = {
        attr: attr_list[idx.arrows.from].attr,
        name: attr_list[idx.arrows.from].name,
        value: {
          from: {
            enabled: true,
            type: attr_list[idx.arrows.from].value.from.type
          }
        }
      };
    } else if (dir_type === 'none') {
      var idx_arrow;
      if (idx.arrows.to) {
        idx_arrow = idx.arrows.to;
      } else {
        idx_arrow = idx.arrows.from;
      }

      attr_list[idx_arrow] = {
        attr: attr_list[idx_arrow].attr,
        name: attr_list[idx_arrow].name,
        value: ''
      };
    } else if (dir_type === 'forward') {
      // given both of shapes, but use only 'to'
      if (idx.arrows.to && idx.arrows.from) {
        to_type = attr_list[idx.arrows.to].value.to.type;
        from_type = '';
        attr_list[idx.arrows.to] = {
          attr: attr_list[idx.arrows.to].attr,
          name: attr_list[idx.arrows.to].name,
          value: {
            to: { enabled: true, type: to_type },
            from: { enabled: true, type: from_type }
          }

          // assign given 'to' shape
        };
      } else if (idx.arrows.to) {
        to_type = attr_list[idx.arrows.to].value.to.type;
        from_type = '';
        attr_list[idx.arrows.to] = {
          attr: attr_list[idx.arrows.to].attr,
          name: attr_list[idx.arrows.to].name,
          value: {
            to: { enabled: true, type: to_type },
            from: { enabled: true, type: from_type }
          }

          // given shape of 'from', but does not use it
        };
      } else if (idx.arrows.from) {
        to_type = 'arrow';
        from_type = '';
        idx.arrows.to = idx.arrows.from;
        attr_list[idx.arrows.to] = {
          attr: attr_list[idx.arrows.to].attr,
          name: attr_list[idx.arrows.to].name,
          value: {
            to: { enabled: true, type: to_type },
            from: { enabled: true, type: from_type }
          }
        };
      }

      attr_list[idx.arrows.to] = {
        attr: attr_list[idx.arrows.to].attr,
        name: attr_list[idx.arrows.to].name,
        value: {
          to: {
            enabled: true,
            type: attr_list[idx.arrows.to].value.to.type
          }
        }
      };
    } else {
      throw newSyntaxError('Invalid dir type "' + dir_type + '"');
    }

    // remove 'dir' attribute no need anymore
    attr_list.splice(idx.dir, 1);
  }
  return attr_list;
}

/**
 * Parse a set with attributes,
 * for example [label="1.000", shape=solid]
 * @return {Object | null} attr
 */
function parseAttributeList() {
  var i;
  var attr = null;

  // edge styles of dot and vis
  var edgeStyles = {
    dashed: true,
    solid: false,
    dotted: [1, 5]

    /**
     * Define arrow types.
     * vis currently supports types defined in 'arrowTypes'.
     * Details of arrow shapes are described in
     * http://www.graphviz.org/content/arrow-shapes
     */
  };var arrowTypes = {
    dot: 'circle',
    box: 'box',
    crow: 'crow',
    curve: 'curve',
    icurve: 'inv_curve',
    normal: 'triangle',
    inv: 'inv_triangle',
    diamond: 'diamond',
    tee: 'bar',
    vee: 'vee'

    /**
     * 'attr_list' contains attributes for checking if some of them are affected
     * later. For instance, both of 'arrowhead' and 'dir' (edge style defined
     * in DOT) make changes to 'arrows' attribute in vis.
     */
  };var attr_list = new Array();
  var attr_names = new Array(); // used for checking the case.

  // parse attributes
  while (token === '[') {
    getToken();
    attr = {};
    while (token !== '' && token != ']') {
      if (tokenType != TOKENTYPE.IDENTIFIER) {
        throw newSyntaxError('Attribute name expected');
      }
      var name = token;

      getToken();
      if (token != '=') {
        throw newSyntaxError('Equal sign = expected');
      }
      getToken();

      if (tokenType != TOKENTYPE.IDENTIFIER) {
        throw newSyntaxError('Attribute value expected');
      }
      var value = token;

      // convert from dot style to vis
      if (name === 'style') {
        value = edgeStyles[value];
      }

      var arrowType;
      if (name === 'arrowhead') {
        arrowType = arrowTypes[value];
        name = 'arrows';
        value = { to: { enabled: true, type: arrowType } };
      }

      if (name === 'arrowtail') {
        arrowType = arrowTypes[value];
        name = 'arrows';
        value = { from: { enabled: true, type: arrowType } };
      }

      attr_list.push({ attr: attr, name: name, value: value });
      attr_names.push(name);

      getToken();
      if (token == ',') {
        getToken();
      }
    }

    if (token != ']') {
      throw newSyntaxError('Bracket ] expected');
    }
    getToken();
  }

  attr_list = parseDirAttribute(attr_names, attr_list);

  // parse 'penwidth'
  var nof_attr_list;
  if (attr_names.includes('penwidth')) {
    var tmp_attr_list = [];

    nof_attr_list = attr_list.length;
    for (i = 0; i < nof_attr_list; i++) {
      // exclude 'width' from attr_list if 'penwidth' exists
      if (attr_list[i].name !== 'width') {
        if (attr_list[i].name === 'penwidth') {
          attr_list[i].name = 'width';
        }
        tmp_attr_list.push(attr_list[i]);
      }
    }
    attr_list = tmp_attr_list;
  }

  nof_attr_list = attr_list.length;
  for (i = 0; i < nof_attr_list; i++) {
    setValue(attr_list[i].attr, attr_list[i].name, attr_list[i].value);
  }

  return attr;
}

/**
 * Create a syntax error with extra information on current token and index.
 * @param {string} message
 * @returns {SyntaxError} err
 */
function newSyntaxError(message) {
  return new SyntaxError(message + ', got "' + chop(token, 30) + '" (char ' + index + ')');
}

/**
 * Chop off text after a maximum length
 * @param {string} text
 * @param {number} maxLength
 * @returns {String}
 */
function chop(text, maxLength) {
  return text.length <= maxLength ? text : text.substr(0, 27) + '...';
}

/**
 * Execute a function fn for each pair of elements in two arrays
 * @param {Array | *} array1
 * @param {Array | *} array2
 * @param {function} fn
 */
function forEach2(array1, array2, fn) {
  if (Array.isArray(array1)) {
    array1.forEach(function (elem1) {
      if (Array.isArray(array2)) {
        array2.forEach(function (elem2) {
          fn(elem1, elem2);
        });
      } else {
        fn(elem1, array2);
      }
    });
  } else {
    if (Array.isArray(array2)) {
      array2.forEach(function (elem2) {
        fn(array1, elem2);
      });
    } else {
      fn(array1, array2);
    }
  }
}

/**
 * Set a nested property on an object
 * When nested objects are missing, they will be created.
 * For example setProp({}, 'font.color', 'red') will return {font: {color: 'red'}}
 * @param {Object} object
 * @param {string} path   A dot separated string like 'font.color'
 * @param {*} value       Value for the property
 * @return {Object} Returns the original object, allows for chaining.
 */
function setProp(object, path, value) {
  var names = path.split('.');
  var prop = names.pop();

  // traverse over the nested objects
  var obj = object;
  for (var i = 0; i < names.length; i++) {
    var name = names[i];
    if (!(name in obj)) {
      obj[name] = {};
    }
    obj = obj[name];
  }

  // set the property value
  obj[prop] = value;

  return object;
}

/**
 * Convert an object with DOT attributes to their vis.js equivalents.
 * @param {Object} attr     Object with DOT attributes
 * @param {Object} mapping
 * @return {Object}         Returns an object with vis.js attributes
 */
function convertAttr(attr, mapping) {
  var converted = {};

  for (var prop in attr) {
    if (attr.hasOwnProperty(prop)) {
      var visProp = mapping[prop];
      if (Array.isArray(visProp)) {
        visProp.forEach(function (visPropI) {
          setProp(converted, visPropI, attr[prop]);
        });
      } else if (typeof visProp === 'string') {
        setProp(converted, visProp, attr[prop]);
      } else {
        setProp(converted, prop, attr[prop]);
      }
    }
  }

  return converted;
}

/**
 * Convert a string containing a graph in DOT language into a map containing
 * with nodes and edges in the format of graph.
 * @param {string} data         Text containing a graph in DOT-notation
 * @return {Object} graphData
 */
function DOTToGraph(data) {
  // parse the DOT file
  var dotData = parseDOT(data);
  var graphData = {
    nodes: [],
    edges: [],
    options: {}

    // copy the nodes
  };if (dotData.nodes) {
    dotData.nodes.forEach(function (dotNode) {
      var graphNode = {
        id: dotNode.id,
        label: String(dotNode.label || dotNode.id)
      };
      merge(graphNode, convertAttr(dotNode.attr, NODE_ATTR_MAPPING));
      if (graphNode.image) {
        graphNode.shape = 'image';
      }
      graphData.nodes.push(graphNode);
    });
  }

  // copy the edges
  if (dotData.edges) {
    /**
     * Convert an edge in DOT format to an edge with VisGraph format
     * @param {Object} dotEdge
     * @returns {Object} graphEdge
     */
    var convertEdge = function convertEdge(dotEdge) {
      var graphEdge = {
        from: dotEdge.from,
        to: dotEdge.to
      };
      merge(graphEdge, convertAttr(dotEdge.attr, EDGE_ATTR_MAPPING));

      // Add arrows attribute to default styled arrow.
      // The reason why default style is not added in parseAttributeList() is
      // because only default is cleared before here.
      if (graphEdge.arrows == null && dotEdge.type === '->') {
        graphEdge.arrows = 'to';
      }

      return graphEdge;
    };

    dotData.edges.forEach(function (dotEdge) {
      var from, to;
      if (dotEdge.from instanceof Object) {
        from = dotEdge.from.nodes;
      } else {
        from = {
          id: dotEdge.from
        };
      }

      if (dotEdge.to instanceof Object) {
        to = dotEdge.to.nodes;
      } else {
        to = {
          id: dotEdge.to
        };
      }

      if (dotEdge.from instanceof Object && dotEdge.from.edges) {
        dotEdge.from.edges.forEach(function (subEdge) {
          var graphEdge = convertEdge(subEdge);
          graphData.edges.push(graphEdge);
        });
      }

      forEach2(from, to, function (from, to) {
        var subEdge = createEdge(graphData, from.id, to.id, dotEdge.type, dotEdge.attr);
        var graphEdge = convertEdge(subEdge);
        graphData.edges.push(graphEdge);
      });

      if (dotEdge.to instanceof Object && dotEdge.to.edges) {
        dotEdge.to.edges.forEach(function (subEdge) {
          var graphEdge = convertEdge(subEdge);
          graphData.edges.push(graphEdge);
        });
      }
    });
  }

  // copy the options
  if (dotData.attr) {
    graphData.options = dotData.attr;
  }

  return graphData;
}

// exports
exports.parseDOT = parseDOT;
exports.DOTToGraph = DOTToGraph;

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 *
 * @param {json} gephiJSON
 * @param {obj} optionsObj
 * @returns {{nodes: Array, edges: Array}}
 */
function parseGephi(gephiJSON, optionsObj) {
  var edges = [];
  var nodes = [];
  var options = {
    edges: {
      inheritColor: false
    },
    nodes: {
      fixed: false,
      parseColor: false
    }
  };

  if (optionsObj !== undefined) {
    if (optionsObj.fixed !== undefined) {
      options.nodes.fixed = optionsObj.fixed;
    }
    if (optionsObj.parseColor !== undefined) {
      options.nodes.parseColor = optionsObj.parseColor;
    }
    if (optionsObj.inheritColor !== undefined) {
      options.edges.inheritColor = optionsObj.inheritColor;
    }
  }

  var gEdges = gephiJSON.edges;
  var gNodes = gephiJSON.nodes;
  for (var i = 0; i < gEdges.length; i++) {
    var edge = {};
    var gEdge = gEdges[i];
    edge['id'] = gEdge.id;
    edge['from'] = gEdge.source;
    edge['to'] = gEdge.target;
    edge['attributes'] = gEdge.attributes;
    edge['label'] = gEdge.label;
    edge['title'] = gEdge.attributes !== undefined ? gEdge.attributes.title : undefined;
    if (gEdge['type'] === 'Directed') {
      edge['arrows'] = 'to';
    }
    //    edge['value'] = gEdge.attributes !== undefined ? gEdge.attributes.Weight : undefined;
    //    edge['width'] = edge['value'] !== undefined ? undefined : edgegEdge.size;
    if (gEdge.color && options.inheritColor === false) {
      edge['color'] = gEdge.color;
    }
    edges.push(edge);
  }

  for (var j = 0; j < gNodes.length; j++) {
    var node = {};
    var gNode = gNodes[j];
    node['id'] = gNode.id;
    node['attributes'] = gNode.attributes;
    node['x'] = gNode.x;
    node['y'] = gNode.y;
    node['label'] = gNode.label;
    node['title'] = gNode.attributes !== undefined ? gNode.attributes.title : gNode.title;
    if (options.nodes.parseColor === true) {
      node['color'] = gNode.color;
    } else {
      node['color'] = gNode.color !== undefined ? {
        background: gNode.color,
        border: gNode.color,
        highlight: { background: gNode.color, border: gNode.color },
        hover: { background: gNode.color, border: gNode.color }
      } : undefined;
    }
    node['size'] = gNode.size;
    node['fixed'] = options.nodes.fixed && gNode.x !== undefined && gNode.y !== undefined;
    nodes.push(node);
  }

  return { nodes: nodes, edges: edges };
}

exports.parseGephi = parseGephi;

/***/ }),
/* 76 */
/***/ (function(module, exports, __nested_webpack_require_271567__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __nested_webpack_require_271567__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_271567__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

var _CachedImage = __nested_webpack_require_271567__(133);

var _CachedImage2 = _interopRequireDefault(_CachedImage);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * This callback is a callback that accepts an Image.
 * @callback ImageCallback
 * @param {Image} image
 */

/**
 * This class loads images and keeps them stored.
 *
 * @param {ImageCallback} callback
 */
var Images = function () {
  /**
   * @param {ImageCallback} callback
   */
  function Images(callback) {
    (0, _classCallCheck3['default'])(this, Images);

    this.images = {};
    this.imageBroken = {};
    this.callback = callback;
  }

  /**
   * @param {string} url                      The original Url that failed to load, if the broken image is successfully loaded it will be added to the cache using this Url as the key so that subsequent requests for this Url will return the broken image
   * @param {string} brokenUrl                Url the broken image to try and load
   * @param {Image} imageToLoadBrokenUrlOn   The image object
   */


  (0, _createClass3['default'])(Images, [{
    key: '_tryloadBrokenUrl',
    value: function _tryloadBrokenUrl(url, brokenUrl, imageToLoadBrokenUrlOn) {
      //If these parameters aren't specified then exit the function because nothing constructive can be done
      if (url === undefined || imageToLoadBrokenUrlOn === undefined) return;
      if (brokenUrl === undefined) {
        console.warn('No broken url image defined');
        return;
      }

      //Clear the old subscription to the error event and put a new in place that only handle errors in loading the brokenImageUrl
      imageToLoadBrokenUrlOn.onerror = function () {
        console.error('Could not load brokenImage:', brokenUrl);
        // cache item will contain empty image, this should be OK for default
      };

      //Set the source of the image to the brokenUrl, this is actually what kicks off the loading of the broken image
      imageToLoadBrokenUrlOn.image.src = brokenUrl;
    }

    /**
     *
     * @param {vis.Image} imageToRedrawWith
     * @private
     */

  }, {
    key: '_redrawWithImage',
    value: function _redrawWithImage(imageToRedrawWith) {
      if (this.callback) {
        this.callback(imageToRedrawWith);
      }
    }

    /**
     * @param {string} url          Url of the image
     * @param {string} brokenUrl    Url of an image to use if the url image is not found
     * @return {Image} img          The image object
     */

  }, {
    key: 'load',
    value: function load(url, brokenUrl) {
      var _this = this;

      //Try and get the image from the cache, if successful then return the cached image
      var cachedImage = this.images[url];
      if (cachedImage) return cachedImage;

      //Create a new image
      var img = new _CachedImage2['default']();

      // Need to add to cache here, otherwise final return will spawn different copies of the same image,
      // Also, there will be multiple loads of the same image.
      this.images[url] = img;

      //Subscribe to the event that is raised if the image loads successfully
      img.image.onload = function () {
        // Properly init the cached item and then request a redraw
        _this._fixImageCoordinates(img.image);
        img.init();
        _this._redrawWithImage(img);
      };

      //Subscribe to the event that is raised if the image fails to load
      img.image.onerror = function () {
        console.error('Could not load image:', url);
        //Try and load the image specified by the brokenUrl using
        _this._tryloadBrokenUrl(url, brokenUrl, img);
      };

      //Set the source of the image to the url, this is what actually kicks off the loading of the image
      img.image.src = url;

      //Return the new image
      return img;
    }

    /**
     * IE11 fix -- thanks dponch!
     *
     * Local helper function
     * @param {vis.Image} imageToCache
     * @private
     */

  }, {
    key: '_fixImageCoordinates',
    value: function _fixImageCoordinates(imageToCache) {
      if (imageToCache.width === 0) {
        document.body.appendChild(imageToCache);
        imageToCache.width = imageToCache.offsetWidth;
        imageToCache.height = imageToCache.offsetHeight;
        document.body.removeChild(imageToCache);
      }
    }
  }]);
  return Images;
}();

exports['default'] = Images;

/***/ }),
/* 77 */
/***/ (function(module, exports, __nested_webpack_require_276340__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray2 = __nested_webpack_require_276340__(15);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _typeof2 = __nested_webpack_require_276340__(7);

var _typeof3 = _interopRequireDefault(_typeof2);

var _classCallCheck2 = __nested_webpack_require_276340__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_276340__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var util = __nested_webpack_require_276340__(2);
var ComponentUtil = __nested_webpack_require_276340__(35)['default'];
var LabelSplitter = __nested_webpack_require_276340__(139)['default'];

/**
 * List of special styles for multi-fonts
 * @private
 */
var multiFontStyle = ['bold', 'ital', 'boldital', 'mono'];

/**
 * A Label to be used for Nodes or Edges.
 */

var Label = function () {
  /**
   * @param {Object} body
   * @param {Object} options
   * @param {boolean} [edgelabel=false]
   */
  function Label(body, options) {
    var edgelabel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    (0, _classCallCheck3['default'])(this, Label);

    this.body = body;
    this.pointToSelf = false;
    this.baseSize = undefined;
    this.fontOptions = {}; // instance variable containing the *instance-local* font options
    this.setOptions(options);
    this.size = { top: 0, left: 0, width: 0, height: 0, yLine: 0 };
    this.isEdgeLabel = edgelabel;
  }

  /**
   * @param {Object} options the options of the parent Node-instance
   */


  (0, _createClass3['default'])(Label, [{
    key: 'setOptions',
    value: function setOptions(options) {
      this.elementOptions = options; // Reference to the options of the parent Node-instance

      this.initFontOptions(options.font);

      if (ComponentUtil.isValidLabel(options.label)) {
        this.labelDirty = true;
      } else {
        // Bad label! Change the option value to prevent bad stuff happening
        options.label = '';
      }

      if (options.font !== undefined && options.font !== null) {
        // font options can be deleted at various levels
        if (typeof options.font === 'string') {
          this.baseSize = this.fontOptions.size;
        } else if ((0, _typeof3['default'])(options.font) === 'object') {
          var size = options.font.size;

          if (size !== undefined) {
            this.baseSize = size;
          }
        }
      }
    }

    /**
     * Init the font Options structure.
     *
     * Member fontOptions serves as an accumulator for the current font options.
     * As such, it needs to be completely separated from the node options.
     *
     * @param {Object} newFontOptions the new font options to process
     * @private
     */

  }, {
    key: 'initFontOptions',
    value: function initFontOptions(newFontOptions) {
      var _this = this;

      // Prepare the multi-font option objects.
      // These will be filled in propagateFonts(), if required
      util.forEach(multiFontStyle, function (style) {
        _this.fontOptions[style] = {};
      });

      // Handle shorthand option, if present
      if (Label.parseFontString(this.fontOptions, newFontOptions)) {
        this.fontOptions.vadjust = 0;
        return;
      }

      // Copy over the non-multifont options, if specified
      util.forEach(newFontOptions, function (prop, n) {
        if (prop !== undefined && prop !== null && (typeof prop === 'undefined' ? 'undefined' : (0, _typeof3['default'])(prop)) !== 'object') {
          _this.fontOptions[n] = prop;
        }
      });
    }

    /**
     * If in-variable is a string, parse it as a font specifier.
     *
     * Note that following is not done here and have to be done after the call:
     * - No number conversion (size)
     * - Not all font options are set (vadjust, mod)
     *
     * @param {Object} outOptions  out-parameter, object in which to store the parse results (if any)
     * @param {Object} inOptions  font options to parse
     * @return {boolean} true if font parsed as string, false otherwise
     * @static
     */

  }, {
    key: 'constrain',


    /**
     * Set the width and height constraints based on 'nearest' value
     *
     * @param {Array} pile array of option objects to consider
     * @returns {object} the actual constraint values to use
     * @private
     */
    value: function constrain(pile) {
      // NOTE: constrainWidth and  constrainHeight never set!
      // NOTE: for edge labels, only 'maxWdt' set
      // Node labels can set all the fields
      var fontOptions = {
        constrainWidth: false,
        maxWdt: -1,
        minWdt: -1,
        constrainHeight: false,
        minHgt: -1,
        valign: 'middle'
      };

      var widthConstraint = util.topMost(pile, 'widthConstraint');
      if (typeof widthConstraint === 'number') {
        fontOptions.maxWdt = Number(widthConstraint);
        fontOptions.minWdt = Number(widthConstraint);
      } else if ((typeof widthConstraint === 'undefined' ? 'undefined' : (0, _typeof3['default'])(widthConstraint)) === 'object') {
        var widthConstraintMaximum = util.topMost(pile, ['widthConstraint', 'maximum']);
        if (typeof widthConstraintMaximum === 'number') {
          fontOptions.maxWdt = Number(widthConstraintMaximum);
        }
        var widthConstraintMinimum = util.topMost(pile, ['widthConstraint', 'minimum']);
        if (typeof widthConstraintMinimum === 'number') {
          fontOptions.minWdt = Number(widthConstraintMinimum);
        }
      }

      var heightConstraint = util.topMost(pile, 'heightConstraint');
      if (typeof heightConstraint === 'number') {
        fontOptions.minHgt = Number(heightConstraint);
      } else if ((typeof heightConstraint === 'undefined' ? 'undefined' : (0, _typeof3['default'])(heightConstraint)) === 'object') {
        var heightConstraintMinimum = util.topMost(pile, ['heightConstraint', 'minimum']);
        if (typeof heightConstraintMinimum === 'number') {
          fontOptions.minHgt = Number(heightConstraintMinimum);
        }
        var heightConstraintValign = util.topMost(pile, ['heightConstraint', 'valign']);
        if (typeof heightConstraintValign === 'string') {
          if (heightConstraintValign === 'top' || heightConstraintValign === 'bottom') {
            fontOptions.valign = heightConstraintValign;
          }
        }
      }

      return fontOptions;
    }

    /**
     * Set options and update internal state
     *
     * @param {Object} options  options to set
     * @param {Array}  pile     array of option objects to consider for option 'chosen'
     */

  }, {
    key: 'update',
    value: function update(options, pile) {
      this.setOptions(options, true);
      this.propagateFonts(pile);
      util.deepExtend(this.fontOptions, this.constrain(pile));
      this.fontOptions.chooser = ComponentUtil.choosify('label', pile);
    }

    /**
     * When margins are set in an element, adjust sizes is called to remove them
     * from the width/height constraints. This must be done prior to label sizing.
     *
     * @param {{top: number, right: number, bottom: number, left: number}} margins
     */

  }, {
    key: 'adjustSizes',
    value: function adjustSizes(margins) {
      var widthBias = margins ? margins.right + margins.left : 0;
      if (this.fontOptions.constrainWidth) {
        this.fontOptions.maxWdt -= widthBias;
        this.fontOptions.minWdt -= widthBias;
      }
      var heightBias = margins ? margins.top + margins.bottom : 0;
      if (this.fontOptions.constrainHeight) {
        this.fontOptions.minHgt -= heightBias;
      }
    }

    /////////////////////////////////////////////////////////
    // Methods for handling options piles
    // Eventually, these will be moved to a separate class
    /////////////////////////////////////////////////////////

    /**
     * Add the font members of the passed list of option objects to the pile.
     *
     * @param {Pile} dstPile  pile of option objects add to
     * @param {Pile} srcPile  pile of option objects to take font options from
     * @private
     */

  }, {
    key: 'addFontOptionsToPile',
    value: function addFontOptionsToPile(dstPile, srcPile) {
      for (var i = 0; i < srcPile.length; ++i) {
        this.addFontToPile(dstPile, srcPile[i]);
      }
    }

    /**
     * Add given font option object to the list of objects (the 'pile') to consider for determining
     * multi-font option values.
     *
     * @param {Pile} pile  pile of option objects to use
     * @param {object} options  instance to add to pile
     * @private
     */

  }, {
    key: 'addFontToPile',
    value: function addFontToPile(pile, options) {
      if (options === undefined) return;
      if (options.font === undefined || options.font === null) return;

      var item = options.font;
      pile.push(item);
    }

    /**
     * Collect all own-property values from the font pile that aren't multi-font option objectss.
     *
     * @param {Pile} pile  pile of option objects to use
     * @returns {object} object with all current own basic font properties
     * @private
     */

  }, {
    key: 'getBasicOptions',
    value: function getBasicOptions(pile) {
      var ret = {};

      // Scans the whole pile to get all options present
      for (var n = 0; n < pile.length; ++n) {
        var fontOptions = pile[n];

        // Convert shorthand if necessary
        var tmpShorthand = {};
        if (Label.parseFontString(tmpShorthand, fontOptions)) {
          fontOptions = tmpShorthand;
        }

        util.forEach(fontOptions, function (opt, name) {
          if (opt === undefined) return; // multi-font option need not be present
          if (ret.hasOwnProperty(name)) return; // Keep first value we encounter

          if (multiFontStyle.indexOf(name) !== -1) {
            // Skip multi-font properties but we do need the structure
            ret[name] = {};
          } else {
            ret[name] = opt;
          }
        });
      }

      return ret;
    }

    /**
     * Return the value for given option for the given multi-font.
     *
     * All available option objects are trawled in the set order to construct the option values.
     *
     * ---------------------------------------------------------------------
     * ## Traversal of pile for multi-fonts
     *
     * The determination of multi-font option values is a special case, because any values not
     * present in the multi-font options should by definition be taken from the main font options,
     * i.e. from the current 'parent' object of the multi-font option.
     *
     * ### Search order for multi-fonts
     *
     * 'bold' used as example:
     *
     *   - search in option group 'bold' in local properties
     *   - search in main font option group in local properties
     *
     * ---------------------------------------------------------------------
     *
     * @param {Pile} pile  pile of option objects to use
     * @param {MultiFontStyle} multiName sub path for the multi-font
     * @param {string} option  the option to search for, for the given multi-font
     * @returns {string|number} the value for the given option
     * @private
     */

  }, {
    key: 'getFontOption',
    value: function getFontOption(pile, multiName, option) {
      var multiFont = void 0;

      // Search multi font in local properties
      for (var n = 0; n < pile.length; ++n) {
        var fontOptions = pile[n];

        if (fontOptions.hasOwnProperty(multiName)) {
          multiFont = fontOptions[multiName];
          if (multiFont === undefined || multiFont === null) continue;

          // Convert shorthand if necessary
          // TODO: inefficient to do this conversion every time; find a better way.
          var tmpShorthand = {};
          if (Label.parseFontString(tmpShorthand, multiFont)) {
            multiFont = tmpShorthand;
          }

          if (multiFont.hasOwnProperty(option)) {
            return multiFont[option];
          }
        }
      }

      // Option is not mentioned in the multi font options; take it from the parent font options.
      // These have already been converted with getBasicOptions(), so use the converted values.
      if (this.fontOptions.hasOwnProperty(option)) {
        return this.fontOptions[option];
      }

      // A value **must** be found; you should never get here.
      throw new Error("Did not find value for multi-font for property: '" + option + "'");
    }

    /**
     * Return all options values for the given multi-font.
     *
     * All available option objects are trawled in the set order to construct the option values.
     *
     * @param {Pile} pile  pile of option objects to use
     * @param {MultiFontStyle} multiName sub path for the mod-font
     * @returns {MultiFontOptions}
     * @private
     */

  }, {
    key: 'getFontOptions',
    value: function getFontOptions(pile, multiName) {
      var result = {};
      var optionNames = ['color', 'size', 'face', 'mod', 'vadjust']; // List of allowed options per multi-font

      for (var i = 0; i < optionNames.length; ++i) {
        var mod = optionNames[i];
        result[mod] = this.getFontOption(pile, multiName, mod);
      }

      return result;
    }

    /////////////////////////////////////////////////////////
    // End methods for handling options piles
    /////////////////////////////////////////////////////////

    /**
     * Collapse the font options for the multi-font to single objects, from
     * the chain of option objects passed (the 'pile').
     *
     * @param {Pile} pile  sequence of option objects to consider.
     *                     First item in list assumed to be the newly set options.
     */

  }, {
    key: 'propagateFonts',
    value: function propagateFonts(pile) {
      var _this2 = this;

      var fontPile = []; // sequence of font objects to consider, order important

      // Note that this.elementOptions is not used here.
      this.addFontOptionsToPile(fontPile, pile);
      this.fontOptions = this.getBasicOptions(fontPile);

      // We set multifont values even if multi === false, for consistency (things break otherwise)

      var _loop = function _loop(i) {
        var mod = multiFontStyle[i];
        var modOptions = _this2.fontOptions[mod];
        var tmpMultiFontOptions = _this2.getFontOptions(fontPile, mod);

        // Copy over found values
        util.forEach(tmpMultiFontOptions, function (option, n) {
          modOptions[n] = option;
        });

        modOptions.size = Number(modOptions.size);
        modOptions.vadjust = Number(modOptions.vadjust);
      };

      for (var i = 0; i < multiFontStyle.length; ++i) {
        _loop(i);
      }
    }

    /**
     * Main function. This is called from anything that wants to draw a label.
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x
     * @param {number} y
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {string} [baseline='middle']
     */

  }, {
    key: 'draw',
    value: function draw(ctx, x, y, selected, hover) {
      var baseline = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'middle';

      // if no label, return
      if (this.elementOptions.label === undefined) return;

      // check if we have to render the label
      var viewFontSize = this.fontOptions.size * this.body.view.scale;
      if (this.elementOptions.label && viewFontSize < this.elementOptions.scaling.label.drawThreshold - 1) return;

      // This ensures that there will not be HUGE letters on screen
      // by setting an upper limit on the visible text size (regardless of zoomLevel)
      if (viewFontSize >= this.elementOptions.scaling.label.maxVisible) {
        viewFontSize = Number(this.elementOptions.scaling.label.maxVisible) / this.body.view.scale;
      }

      // update the size cache if required
      this.calculateLabelSize(ctx, selected, hover, x, y, baseline);
      this._drawBackground(ctx);
      this._drawText(ctx, x, this.size.yLine, baseline, viewFontSize);
    }

    /**
     * Draws the label background
     * @param {CanvasRenderingContext2D} ctx
     * @private
     */

  }, {
    key: '_drawBackground',
    value: function _drawBackground(ctx) {
      if (this.fontOptions.background !== undefined && this.fontOptions.background !== 'none') {
        ctx.fillStyle = this.fontOptions.background;
        var size = this.getSize();
        ctx.fillRect(size.left, size.top, size.width, size.height);
      }
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x
     * @param {number} y
     * @param {string} [baseline='middle']
     * @param {number} viewFontSize
     * @private
     */

  }, {
    key: '_drawText',
    value: function _drawText(ctx, x, y) {
      var baseline = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'middle';
      var viewFontSize = arguments[4];

      ;
      var _setAlignment2 = this._setAlignment(ctx, x, y, baseline);

      var _setAlignment3 = (0, _slicedToArray3['default'])(_setAlignment2, 2);

      x = _setAlignment3[0];
      y = _setAlignment3[1];


      ctx.textAlign = 'left';
      x = x - this.size.width / 2; // Shift label 1/2-distance to the left
      if (this.fontOptions.valign && this.size.height > this.size.labelHeight) {
        if (this.fontOptions.valign === 'top') {
          y -= (this.size.height - this.size.labelHeight) / 2;
        }
        if (this.fontOptions.valign === 'bottom') {
          y += (this.size.height - this.size.labelHeight) / 2;
        }
      }

      // draw the text
      for (var i = 0; i < this.lineCount; i++) {
        var line = this.lines[i];
        if (line && line.blocks) {
          var width = 0;
          if (this.isEdgeLabel || this.fontOptions.align === 'center') {
            width += (this.size.width - line.width) / 2;
          } else if (this.fontOptions.align === 'right') {
            width += this.size.width - line.width;
          }
          for (var j = 0; j < line.blocks.length; j++) {
            var block = line.blocks[j];
            ctx.font = block.font;

            var _getColor2 = this._getColor(block.color, viewFontSize, block.strokeColor),
                _getColor3 = (0, _slicedToArray3['default'])(_getColor2, 2),
                fontColor = _getColor3[0],
                strokeColor = _getColor3[1];

            if (block.strokeWidth > 0) {
              ctx.lineWidth = block.strokeWidth;
              ctx.strokeStyle = strokeColor;
              ctx.lineJoin = 'round';
            }
            ctx.fillStyle = fontColor;

            if (block.strokeWidth > 0) {
              ctx.strokeText(block.text, x + width, y + block.vadjust);
            }
            ctx.fillText(block.text, x + width, y + block.vadjust);
            width += block.width;
          }
          y += line.height;
        }
      }
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x
     * @param {number} y
     * @param {string} baseline
     * @returns {Array.<number>}
     * @private
     */

  }, {
    key: '_setAlignment',
    value: function _setAlignment(ctx, x, y, baseline) {
      // check for label alignment (for edges)
      // TODO: make alignment for nodes
      if (this.isEdgeLabel && this.fontOptions.align !== 'horizontal' && this.pointToSelf === false) {
        x = 0;
        y = 0;

        var lineMargin = 2;
        if (this.fontOptions.align === 'top') {
          ctx.textBaseline = 'alphabetic';
          y -= 2 * lineMargin; // distance from edge, required because we use alphabetic. Alphabetic has less difference between browsers
        } else if (this.fontOptions.align === 'bottom') {
          ctx.textBaseline = 'hanging';
          y += 2 * lineMargin; // distance from edge, required because we use hanging. Hanging has less difference between browsers
        } else {
          ctx.textBaseline = 'middle';
        }
      } else {
        ctx.textBaseline = baseline;
      }
      return [x, y];
    }

    /**
     * fade in when relative scale is between threshold and threshold - 1.
     * If the relative scale would be smaller than threshold -1 the draw function would have returned before coming here.
     *
     * @param {string} color  The font color to use
     * @param {number} viewFontSize
     * @param {string} initialStrokeColor
     * @returns {Array.<string>} An array containing the font color and stroke color
     * @private
     */

  }, {
    key: '_getColor',
    value: function _getColor(color, viewFontSize, initialStrokeColor) {
      var fontColor = color || '#000000';
      var strokeColor = initialStrokeColor || '#ffffff';
      if (viewFontSize <= this.elementOptions.scaling.label.drawThreshold) {
        var opacity = Math.max(0, Math.min(1, 1 - (this.elementOptions.scaling.label.drawThreshold - viewFontSize)));
        fontColor = util.overrideOpacity(fontColor, opacity);
        strokeColor = util.overrideOpacity(strokeColor, opacity);
      }
      return [fontColor, strokeColor];
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     * @returns {{width: number, height: number}}
     */

  }, {
    key: 'getTextSize',
    value: function getTextSize(ctx) {
      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      this._processLabel(ctx, selected, hover);
      return {
        width: this.size.width,
        height: this.size.height,
        lineCount: this.lineCount
      };
    }

    /**
     * Get the current dimensions of the label
     *
     * @return {rect}
     */

  }, {
    key: 'getSize',
    value: function getSize() {
      var lineMargin = 2;
      var x = this.size.left; // default values which might be overridden below
      var y = this.size.top - 0.5 * lineMargin; // idem

      if (this.isEdgeLabel) {
        var x2 = -this.size.width * 0.5;

        switch (this.fontOptions.align) {
          case 'middle':
            x = x2;
            y = -this.size.height * 0.5;
            break;
          case 'top':
            x = x2;
            y = -(this.size.height + lineMargin);
            break;
          case 'bottom':
            x = x2;
            y = lineMargin;
            break;
        }
      }

      var ret = {
        left: x,
        top: y,
        width: this.size.width,
        height: this.size.height
      };

      return ret;
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {number} [x=0]
     * @param {number} [y=0]
     * @param {'middle'|'hanging'} [baseline='middle']
     */

  }, {
    key: 'calculateLabelSize',
    value: function calculateLabelSize(ctx, selected, hover) {
      var x = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var y = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var baseline = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'middle';

      this._processLabel(ctx, selected, hover);
      this.size.left = x - this.size.width * 0.5;
      this.size.top = y - this.size.height * 0.5;
      this.size.yLine = y + (1 - this.lineCount) * 0.5 * this.fontOptions.size;
      if (baseline === 'hanging') {
        this.size.top += 0.5 * this.fontOptions.size;
        this.size.top += 4; // distance from node, required because we use hanging. Hanging has less difference between browsers
        this.size.yLine += 4; // distance from node
      }
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {string} mod
     * @returns {{color, size, face, mod, vadjust, strokeWidth: *, strokeColor: (*|string|allOptions.edges.font.strokeColor|{string}|allOptions.nodes.font.strokeColor|Array)}}
     */

  }, {
    key: 'getFormattingValues',
    value: function getFormattingValues(ctx, selected, hover, mod) {
      var getValue = function getValue(fontOptions, mod, option) {
        if (mod === 'normal') {
          if (option === 'mod') return '';
          return fontOptions[option];
        }

        if (fontOptions[mod][option] !== undefined) {
          // Grumbl leaving out test on undefined equals false for ""
          return fontOptions[mod][option];
        } else {
          // Take from parent font option
          return fontOptions[option];
        }
      };

      var values = {
        color: getValue(this.fontOptions, mod, 'color'),
        size: getValue(this.fontOptions, mod, 'size'),
        face: getValue(this.fontOptions, mod, 'face'),
        mod: getValue(this.fontOptions, mod, 'mod'),
        vadjust: getValue(this.fontOptions, mod, 'vadjust'),
        strokeWidth: this.fontOptions.strokeWidth,
        strokeColor: this.fontOptions.strokeColor
      };
      if (selected || hover) {
        if (mod === 'normal' && this.fontOptions.chooser === true && this.elementOptions.labelHighlightBold) {
          values.mod = 'bold';
        } else {
          if (typeof this.fontOptions.chooser === 'function') {
            this.fontOptions.chooser(values, this.elementOptions.id, selected, hover);
          }
        }
      }

      var fontString = '';
      if (values.mod !== undefined && values.mod !== '') {
        // safeguard for undefined - this happened
        fontString += values.mod + ' ';
      }
      fontString += values.size + 'px ' + values.face;

      ctx.font = fontString.replace(/"/g, '');
      values.font = ctx.font;
      values.height = values.size;
      return values;
    }

    /**
     *
     * @param {boolean} selected
     * @param {boolean} hover
     * @returns {boolean}
     */

  }, {
    key: 'differentState',
    value: function differentState(selected, hover) {
      return selected !== this.selectedState || hover !== this.hoverState;
    }

    /**
     * This explodes the passed text into lines and determines the width, height and number of lines.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {string} inText  the text to explode
     * @returns {{width, height, lines}|*}
     * @private
     */

  }, {
    key: '_processLabelText',
    value: function _processLabelText(ctx, selected, hover, inText) {
      var splitter = new LabelSplitter(ctx, this, selected, hover);
      return splitter.process(inText);
    }

    /**
     * This explodes the label string into lines and sets the width, height and number of lines.
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     * @private
     */

  }, {
    key: '_processLabel',
    value: function _processLabel(ctx, selected, hover) {
      if (this.labelDirty === false && !this.differentState(selected, hover)) return;

      var state = this._processLabelText(ctx, selected, hover, this.elementOptions.label);

      if (this.fontOptions.minWdt > 0 && state.width < this.fontOptions.minWdt) {
        state.width = this.fontOptions.minWdt;
      }

      this.size.labelHeight = state.height;
      if (this.fontOptions.minHgt > 0 && state.height < this.fontOptions.minHgt) {
        state.height = this.fontOptions.minHgt;
      }

      this.lines = state.lines;
      this.lineCount = state.lines.length;
      this.size.width = state.width;
      this.size.height = state.height;
      this.selectedState = selected;
      this.hoverState = hover;

      this.labelDirty = false;
    }

    /**
     * Check if this label is visible
     *
     * @return {boolean} true if this label will be show, false otherwise
     */

  }, {
    key: 'visible',
    value: function visible() {
      if (this.size.width === 0 || this.size.height === 0 || this.elementOptions.label === undefined) {
        return false; // nothing to display
      }

      var viewFontSize = this.fontOptions.size * this.body.view.scale;
      if (viewFontSize < this.elementOptions.scaling.label.drawThreshold - 1) {
        return false; // Too small or too far away to show
      }

      return true;
    }
  }], [{
    key: 'parseFontString',
    value: function parseFontString(outOptions, inOptions) {
      if (!inOptions || typeof inOptions !== 'string') return false;

      var newOptionsArray = inOptions.split(' ');

      outOptions.size = newOptionsArray[0].replace('px', '');
      outOptions.face = newOptionsArray[1];
      outOptions.color = newOptionsArray[2];

      return true;
    }
  }]);
  return Label;
}();

exports['default'] = Label;

/***/ }),
/* 78 */
/***/ (function(module, exports, __nested_webpack_require_305424__) {

module.exports = { "default": __nested_webpack_require_305424__(141), __esModule: true };

/***/ }),
/* 79 */
/***/ (function(module, exports, __nested_webpack_require_305577__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray2 = __nested_webpack_require_305577__(15);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _classCallCheck2 = __nested_webpack_require_305577__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_305577__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var util = __nested_webpack_require_305577__(2);
var EndPoints = __nested_webpack_require_305577__(80)['default'];

/**
 * The Base Class for all edges.
 *
 */

var EdgeBase = function () {
  /**
   * @param {Object} options
   * @param {Object} body
   * @param {Label} labelModule
   */
  function EdgeBase(options, body, labelModule) {
    (0, _classCallCheck3['default'])(this, EdgeBase);

    this.body = body;
    this.labelModule = labelModule;
    this.options = {};
    this.setOptions(options);
    this.colorDirty = true;
    this.color = {};
    this.selectionWidth = 2;
    this.hoverWidth = 1.5;
    this.fromPoint = this.from;
    this.toPoint = this.to;
  }

  /**
   * Connects a node to itself
   */


  (0, _createClass3['default'])(EdgeBase, [{
    key: 'connect',
    value: function connect() {
      this.from = this.body.nodes[this.options.from];
      this.to = this.body.nodes[this.options.to];
    }

    /**
     *
     * @returns {boolean} always false
     */

  }, {
    key: 'cleanup',
    value: function cleanup() {
      return false;
    }

    /**
     *
     * @param {Object} options
     */

  }, {
    key: 'setOptions',
    value: function setOptions(options) {
      this.options = options;
      this.from = this.body.nodes[this.options.from];
      this.to = this.body.nodes[this.options.to];
      this.id = this.options.id;
    }

    /**
     * Redraw a edge as a line
     * Draw this edge in the given canvas
     * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
     *
     * @param {CanvasRenderingContext2D}   ctx
     * @param {Array} values
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {Node} viaNode
     * @private
     */

  }, {
    key: 'drawLine',
    value: function drawLine(ctx, values, selected, hover, viaNode) {
      // set style
      ctx.strokeStyle = this.getColor(ctx, values, selected, hover);
      ctx.lineWidth = values.width;

      if (values.dashes !== false) {
        this._drawDashedLine(ctx, values, viaNode);
      } else {
        this._drawLine(ctx, values, viaNode);
      }
    }

    /**
     *
     * @param {CanvasRenderingContext2D}   ctx
     * @param {Array} values
     * @param {Node} viaNode
     * @param {{x: number, y: number}} [fromPoint]
     * @param {{x: number, y: number}} [toPoint]
     * @private
     */

  }, {
    key: '_drawLine',
    value: function _drawLine(ctx, values, viaNode, fromPoint, toPoint) {
      if (this.from != this.to) {
        // draw line
        this._line(ctx, values, viaNode, fromPoint, toPoint);
      } else {
        var _getCircleData2 = this._getCircleData(ctx),
            _getCircleData3 = (0, _slicedToArray3['default'])(_getCircleData2, 3),
            x = _getCircleData3[0],
            y = _getCircleData3[1],
            radius = _getCircleData3[2];

        this._circle(ctx, values, x, y, radius);
      }
    }

    // prettier-ignore
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {Array} values
     * @param {Node} viaNode
     * @param {{x: number, y: number}} [fromPoint]  TODO: Remove in next major release
     * @param {{x: number, y: number}} [toPoint]    TODO: Remove in next major release
     * @private
     */

  }, {
    key: '_drawDashedLine',
    value: function _drawDashedLine(ctx, values, viaNode, fromPoint, toPoint) {
      // eslint-disable-line no-unused-vars
      ctx.lineCap = 'round';
      var pattern = [5, 5];
      if (Array.isArray(values.dashes) === true) {
        pattern = values.dashes;
      }

      // only firefox and chrome support this method, else we use the legacy one.
      if (ctx.setLineDash !== undefined) {
        ctx.save();

        // set dash settings for chrome or firefox
        ctx.setLineDash(pattern);
        ctx.lineDashOffset = 0;

        // draw the line
        if (this.from != this.to) {
          // draw line
          this._line(ctx, values, viaNode);
        } else {
          var _getCircleData4 = this._getCircleData(ctx),
              _getCircleData5 = (0, _slicedToArray3['default'])(_getCircleData4, 3),
              x = _getCircleData5[0],
              y = _getCircleData5[1],
              radius = _getCircleData5[2];

          this._circle(ctx, values, x, y, radius);
        }

        // restore the dash settings.
        ctx.setLineDash([0]);
        ctx.lineDashOffset = 0;
        ctx.restore();
      } else {
        // unsupporting smooth lines
        if (this.from != this.to) {
          // draw line
          ctx.dashedLine(this.from.x, this.from.y, this.to.x, this.to.y, pattern);
        } else {
          var _getCircleData6 = this._getCircleData(ctx),
              _getCircleData7 = (0, _slicedToArray3['default'])(_getCircleData6, 3),
              _x = _getCircleData7[0],
              _y = _getCircleData7[1],
              _radius = _getCircleData7[2];

          this._circle(ctx, values, _x, _y, _radius);
        }
        // draw shadow if enabled
        this.enableShadow(ctx, values);

        ctx.stroke();

        // disable shadows for other elements.
        this.disableShadow(ctx, values);
      }
    }

    /**
     *
     * @param {Node} nearNode
     * @param {CanvasRenderingContext2D} ctx
     * @param {Object} options
     * @returns {{x: number, y: number}}
     */

  }, {
    key: 'findBorderPosition',
    value: function findBorderPosition(nearNode, ctx, options) {
      if (this.from != this.to) {
        return this._findBorderPosition(nearNode, ctx, options);
      } else {
        return this._findBorderPositionCircle(nearNode, ctx, options);
      }
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @returns {{from: ({x: number, y: number, t: number}|*), to: ({x: number, y: number, t: number}|*)}}
     */

  }, {
    key: 'findBorderPositions',
    value: function findBorderPositions(ctx) {
      var from = {};
      var to = {};
      if (this.from != this.to) {
        from = this._findBorderPosition(this.from, ctx);
        to = this._findBorderPosition(this.to, ctx);
      } else {
        var _getCircleData$slice = this._getCircleData(ctx).slice(0, 2),
            _getCircleData$slice2 = (0, _slicedToArray3['default'])(_getCircleData$slice, 2),
            x = _getCircleData$slice2[0],
            y = _getCircleData$slice2[1];

        from = this._findBorderPositionCircle(this.from, ctx, {
          x: x,
          y: y,
          low: 0.25,
          high: 0.6,
          direction: -1
        });
        to = this._findBorderPositionCircle(this.from, ctx, {
          x: x,
          y: y,
          low: 0.6,
          high: 0.8,
          direction: 1
        });
      }
      return { from: from, to: to };
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @returns {Array.<number>} x, y, radius
     * @private
     */

  }, {
    key: '_getCircleData',
    value: function _getCircleData(ctx) {
      var x = void 0,
          y = void 0;
      var node = this.from;
      var radius = this.options.selfReferenceSize;

      if (ctx !== undefined) {
        if (node.shape.width === undefined) {
          node.shape.resize(ctx);
        }
      }

      // get circle coordinates
      if (node.shape.width > node.shape.height) {
        x = node.x + node.shape.width * 0.5;
        y = node.y - radius;
      } else {
        x = node.x + radius;
        y = node.y - node.shape.height * 0.5;
      }
      return [x, y, radius];
    }

    /**
     * Get a point on a circle
     * @param {number} x
     * @param {number} y
     * @param {number} radius
     * @param {number} percentage - Value between 0 (line start) and 1 (line end)
     * @return {Object} point
     * @private
     */

  }, {
    key: '_pointOnCircle',
    value: function _pointOnCircle(x, y, radius, percentage) {
      var angle = percentage * 2 * Math.PI;
      return {
        x: x + radius * Math.cos(angle),
        y: y - radius * Math.sin(angle)
      };
    }

    /**
     * This function uses binary search to look for the point where the circle crosses the border of the node.
     * @param {Node} node
     * @param {CanvasRenderingContext2D} ctx
     * @param {Object} options
     * @returns {*}
     * @private
     */

  }, {
    key: '_findBorderPositionCircle',
    value: function _findBorderPositionCircle(node, ctx, options) {
      var x = options.x;
      var y = options.y;
      var low = options.low;
      var high = options.high;
      var direction = options.direction;

      var maxIterations = 10;
      var iteration = 0;
      var radius = this.options.selfReferenceSize;
      var pos = void 0,
          angle = void 0,
          distanceToBorder = void 0,
          distanceToPoint = void 0,
          difference = void 0;
      var threshold = 0.05;
      var middle = (low + high) * 0.5;

      while (low <= high && iteration < maxIterations) {
        middle = (low + high) * 0.5;

        pos = this._pointOnCircle(x, y, radius, middle);
        angle = Math.atan2(node.y - pos.y, node.x - pos.x);
        distanceToBorder = node.distanceToBorder(ctx, angle);
        distanceToPoint = Math.sqrt(Math.pow(pos.x - node.x, 2) + Math.pow(pos.y - node.y, 2));
        difference = distanceToBorder - distanceToPoint;
        if (Math.abs(difference) < threshold) {
          break; // found
        } else if (difference > 0) {
          // distance to nodes is larger than distance to border --> t needs to be bigger if we're looking at the to node.
          if (direction > 0) {
            low = middle;
          } else {
            high = middle;
          }
        } else {
          if (direction > 0) {
            high = middle;
          } else {
            low = middle;
          }
        }
        iteration++;
      }
      pos.t = middle;

      return pos;
    }

    /**
     * Get the line width of the edge. Depends on width and whether one of the
     * connected nodes is selected.
     * @param {boolean} selected
     * @param {boolean} hover
     * @returns {number} width
     * @private
     */

  }, {
    key: 'getLineWidth',
    value: function getLineWidth(selected, hover) {
      if (selected === true) {
        return Math.max(this.selectionWidth, 0.3 / this.body.view.scale);
      } else {
        if (hover === true) {
          return Math.max(this.hoverWidth, 0.3 / this.body.view.scale);
        } else {
          return Math.max(this.options.width, 0.3 / this.body.view.scale);
        }
      }
    }

    // prettier-ignore
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     * @param {boolean} selected - Unused
     * @param {boolean} hover - Unused
     * @returns {string}
     */

  }, {
    key: 'getColor',
    value: function getColor(ctx, values, selected, hover) {
      // eslint-disable-line no-unused-vars
      if (values.inheritsColor !== false) {
        // when this is a loop edge, just use the 'from' method
        if (values.inheritsColor === 'both' && this.from.id !== this.to.id) {
          var grd = ctx.createLinearGradient(this.from.x, this.from.y, this.to.x, this.to.y);
          var fromColor = void 0,
              toColor = void 0;
          fromColor = this.from.options.color.highlight.border;
          toColor = this.to.options.color.highlight.border;

          if (this.from.selected === false && this.to.selected === false) {
            fromColor = util.overrideOpacity(this.from.options.color.border, values.opacity);
            toColor = util.overrideOpacity(this.to.options.color.border, values.opacity);
          } else if (this.from.selected === true && this.to.selected === false) {
            toColor = this.to.options.color.border;
          } else if (this.from.selected === false && this.to.selected === true) {
            fromColor = this.from.options.color.border;
          }
          grd.addColorStop(0, fromColor);
          grd.addColorStop(1, toColor);

          // -------------------- this returns -------------------- //
          return grd;
        }

        if (values.inheritsColor === 'to') {
          return util.overrideOpacity(this.to.options.color.border, values.opacity);
        } else {
          // "from"
          return util.overrideOpacity(this.from.options.color.border, values.opacity);
        }
      } else {
        return util.overrideOpacity(values.color, values.opacity);
      }
    }

    /**
     * Draw a line from a node to itself, a circle
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {Array} values
     * @param {number} x
     * @param {number} y
     * @param {number} radius
     * @private
     */

  }, {
    key: '_circle',
    value: function _circle(ctx, values, x, y, radius) {
      // draw shadow if enabled
      this.enableShadow(ctx, values);

      // draw a circle
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, 2 * Math.PI, false);
      ctx.stroke();

      // disable shadows for other elements.
      this.disableShadow(ctx, values);
    }

    // prettier-ignore
    /**
     * Calculate the distance between a point (x3,y3) and a line segment from (x1,y1) to (x2,y2).
     * (x3,y3) is the point.
     *
     * http://stackoverflow.com/questions/849211/shortest-distancae-between-a-point-and-a-line-segment
     *
     * @param {number} x1
     * @param {number} y1
     * @param {number} x2
     * @param {number} y2
     * @param {number} x3
     * @param {number} y3
     * @param {Node} via
     * @param {Array} values
     * @returns {number}
     */

  }, {
    key: 'getDistanceToEdge',
    value: function getDistanceToEdge(x1, y1, x2, y2, x3, y3, via, values) {
      // eslint-disable-line no-unused-vars
      var returnValue = 0;
      if (this.from != this.to) {
        returnValue = this._getDistanceToEdge(x1, y1, x2, y2, x3, y3, via);
      } else {
        var _getCircleData8 = this._getCircleData(undefined),
            _getCircleData9 = (0, _slicedToArray3['default'])(_getCircleData8, 3),
            x = _getCircleData9[0],
            y = _getCircleData9[1],
            radius = _getCircleData9[2];

        var dx = x - x3;
        var dy = y - y3;
        returnValue = Math.abs(Math.sqrt(dx * dx + dy * dy) - radius);
      }

      return returnValue;
    }

    /**
     *
     * @param {number} x1
     * @param {number} y1
     * @param {number} x2
     * @param {number} y2
     * @param {number} x3
     * @param {number} y3
     * @returns {number}
     * @private
     */

  }, {
    key: '_getDistanceToLine',
    value: function _getDistanceToLine(x1, y1, x2, y2, x3, y3) {
      var px = x2 - x1;
      var py = y2 - y1;
      var something = px * px + py * py;
      var u = ((x3 - x1) * px + (y3 - y1) * py) / something;

      if (u > 1) {
        u = 1;
      } else if (u < 0) {
        u = 0;
      }

      var x = x1 + u * px;
      var y = y1 + u * py;
      var dx = x - x3;
      var dy = y - y3;

      //# Note: If the actual distance does not matter,
      //# if you only want to compare what this function
      //# returns to other results of this function, you
      //# can just return the squared distance instead
      //# (i.e. remove the sqrt) to gain a little performance

      return Math.sqrt(dx * dx + dy * dy);
    }

    /**
     * @param {CanvasRenderingContext2D} ctx
     * @param {string} position
     * @param {Node} viaNode
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {Array} values
     * @returns {{point: *, core: {x: number, y: number}, angle: *, length: number, type: *}}
     */

  }, {
    key: 'getArrowData',
    value: function getArrowData(ctx, position, viaNode, selected, hover, values) {
      // set lets
      var angle = void 0;
      var arrowPoint = void 0;
      var node1 = void 0;
      var node2 = void 0;
      var guideOffset = void 0;
      var scaleFactor = void 0;
      var type = void 0;
      var lineWidth = values.width;

      if (position === 'from') {
        node1 = this.from;
        node2 = this.to;
        guideOffset = 0.1;
        scaleFactor = values.fromArrowScale;
        type = values.fromArrowType;
      } else if (position === 'to') {
        node1 = this.to;
        node2 = this.from;
        guideOffset = -0.1;
        scaleFactor = values.toArrowScale;
        type = values.toArrowType;
      } else {
        node1 = this.to;
        node2 = this.from;
        scaleFactor = values.middleArrowScale;
        type = values.middleArrowType;
      }

      // if not connected to itself
      if (node1 != node2) {
        if (position !== 'middle') {
          // draw arrow head
          if (this.options.smooth.enabled === true) {
            arrowPoint = this.findBorderPosition(node1, ctx, { via: viaNode });
            var guidePos = this.getPoint(Math.max(0.0, Math.min(1.0, arrowPoint.t + guideOffset)), viaNode);
            angle = Math.atan2(arrowPoint.y - guidePos.y, arrowPoint.x - guidePos.x);
          } else {
            angle = Math.atan2(node1.y - node2.y, node1.x - node2.x);
            arrowPoint = this.findBorderPosition(node1, ctx);
          }
        } else {
          angle = Math.atan2(node1.y - node2.y, node1.x - node2.x);
          arrowPoint = this.getPoint(0.5, viaNode); // this is 0.6 to account for the size of the arrow.
        }
      } else {
        // draw circle
        var _getCircleData10 = this._getCircleData(ctx),
            _getCircleData11 = (0, _slicedToArray3['default'])(_getCircleData10, 3),
            x = _getCircleData11[0],
            y = _getCircleData11[1],
            radius = _getCircleData11[2];

        if (position === 'from') {
          arrowPoint = this.findBorderPosition(this.from, ctx, {
            x: x,
            y: y,
            low: 0.25,
            high: 0.6,
            direction: -1
          });
          angle = arrowPoint.t * -2 * Math.PI + 1.5 * Math.PI + 0.1 * Math.PI;
        } else if (position === 'to') {
          arrowPoint = this.findBorderPosition(this.from, ctx, {
            x: x,
            y: y,
            low: 0.6,
            high: 1.0,
            direction: 1
          });
          angle = arrowPoint.t * -2 * Math.PI + 1.5 * Math.PI - 1.1 * Math.PI;
        } else {
          arrowPoint = this._pointOnCircle(x, y, radius, 0.175);
          angle = 3.9269908169872414; // === 0.175 * -2 * Math.PI + 1.5 * Math.PI + 0.1 * Math.PI;
        }
      }

      if (position === 'middle' && scaleFactor < 0) lineWidth *= -1; // reversed middle arrow
      var length = 15 * scaleFactor + 3 * lineWidth; // 3* lineWidth is the width of the edge.

      var xi = arrowPoint.x - length * 0.9 * Math.cos(angle);
      var yi = arrowPoint.y - length * 0.9 * Math.sin(angle);
      var arrowCore = { x: xi, y: yi };

      return {
        point: arrowPoint,
        core: arrowCore,
        angle: angle,
        length: length,
        type: type
      };
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {Object} arrowData
     */

  }, {
    key: 'drawArrowHead',
    value: function drawArrowHead(ctx, values, selected, hover, arrowData) {
      // set style
      ctx.strokeStyle = this.getColor(ctx, values, selected, hover);
      ctx.fillStyle = ctx.strokeStyle;
      ctx.lineWidth = values.width;

      EndPoints.draw(ctx, arrowData);

      // draw shadow if enabled
      this.enableShadow(ctx, values);
      ctx.fill();
      // disable shadows for other elements.
      this.disableShadow(ctx, values);
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */

  }, {
    key: 'enableShadow',
    value: function enableShadow(ctx, values) {
      if (values.shadow === true) {
        ctx.shadowColor = values.shadowColor;
        ctx.shadowBlur = values.shadowSize;
        ctx.shadowOffsetX = values.shadowX;
        ctx.shadowOffsetY = values.shadowY;
      }
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */

  }, {
    key: 'disableShadow',
    value: function disableShadow(ctx, values) {
      if (values.shadow === true) {
        ctx.shadowColor = 'rgba(0,0,0,0)';
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
      }
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {{toArrow: boolean, toArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), toArrowType: *, middleArrow: boolean, middleArrowScale: (number|allOptions.edges.arrows.middle.scaleFactor|{number}|Array), middleArrowType: (allOptions.edges.arrows.middle.type|{string}|string|*), fromArrow: boolean, fromArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), fromArrowType: *, arrowStrikethrough: (*|boolean|allOptions.edges.arrowStrikethrough|{boolean}), color: undefined, inheritsColor: (string|string|string|allOptions.edges.color.inherit|{string, boolean}|Array|*), opacity: *, hidden: *, length: *, shadow: *, shadowColor: *, shadowSize: *, shadowX: *, shadowY: *, dashes: (*|boolean|Array|allOptions.edges.dashes|{boolean, array}), width: *}} values
     */

  }, {
    key: 'drawBackground',
    value: function drawBackground(ctx, values) {
      if (values.background !== false) {
        var attrs = ['strokeStyle', 'lineWidth', 'dashes'];
        var origCtxAttr = {};
        // save original line attrs
        attrs.forEach(function (attrname) {
          origCtxAttr[attrname] = ctx[attrname];
        });

        ctx.strokeStyle = values.backgroundColor;
        ctx.lineWidth = values.backgroundSize;
        this.setStrokeDashed(ctx, values.backgroundDashes);

        ctx.stroke();

        // restore original line attrs
        attrs.forEach(function (attrname) {
          ctx[attrname] = origCtxAttr[attrname];
        });
        this.setStrokeDashed(ctx, values.dashes);
      }
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean|Array} dashes
     */

  }, {
    key: 'setStrokeDashed',
    value: function setStrokeDashed(ctx, dashes) {
      if (dashes !== false) {
        if (ctx.setLineDash !== undefined) {
          var pattern = [5, 5];
          if (Array.isArray(dashes) === true) {
            pattern = dashes;
          }
          ctx.setLineDash(pattern);
        } else {
          console.warn('setLineDash is not supported in this browser. The dashed stroke cannot be used.');
        }
      } else {
        if (ctx.setLineDash !== undefined) {
          ctx.setLineDash([]);
        } else {
          console.warn('setLineDash is not supported in this browser. The dashed stroke cannot be used.');
        }
      }
    }
  }]);
  return EdgeBase;
}();

exports['default'] = EdgeBase;

/***/ }),
/* 80 */
/***/ (function(module, exports, __nested_webpack_require_329252__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = __nested_webpack_require_329252__(3);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _possibleConstructorReturn2 = __nested_webpack_require_329252__(4);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __nested_webpack_require_329252__(5);

var _inherits3 = _interopRequireDefault(_inherits2);

var _classCallCheck2 = __nested_webpack_require_329252__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_329252__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/** ============================================================================
 * Location of all the endpoint drawing routines.
 *
 * Every endpoint has its own drawing routine, which contains an endpoint definition.
 *
 * The endpoint definitions must have the following properies:
 *
 * - (0,0) is the connection point to the node it attaches to
 * - The endpoints are orientated to the positive x-direction
 * - The length of the endpoint is at most 1
 *
 * As long as the endpoint classes remain simple and not too numerous, they will
 * be contained within this module.
 * All classes here except `EndPoints` should be considered as private to this module.
 *
 * -----------------------------------------------------------------------------
 * ### Further Actions
 *
 * After adding a new endpoint here, you also need to do the following things:
 *
 * - Add the new endpoint name to `network/options.js` in array `endPoints`.
 * - Add the new endpoint name to the documentation.
 *   Scan for 'arrows.to.type` and add it to the description.
 * - Add the endpoint to the examples. At the very least, add it to example
 *   `edgeStyles/arrowTypes`.
 * ============================================================================= */

/**
 * Common methods for endpoints
 *
 * @class
 */
var EndPoint = function () {
  function EndPoint() {
    (0, _classCallCheck3['default'])(this, EndPoint);
  }

  (0, _createClass3['default'])(EndPoint, null, [{
    key: 'transform',

    /**
     * Apply transformation on points for display.
     *
     * The following is done:
     * - rotate by the specified angle
     * - multiply the (normalized) coordinates by the passed length
     * - offset by the target coordinates
     *
     * @param {Array<Point>} points
     * @param {ArrowData} arrowData
     * @static
     */
    value: function transform(points, arrowData) {
      if (!(points instanceof Array)) {
        points = [points];
      }

      var x = arrowData.point.x;
      var y = arrowData.point.y;
      var angle = arrowData.angle;
      var length = arrowData.length;

      for (var i = 0; i < points.length; ++i) {
        var p = points[i];
        var xt = p.x * Math.cos(angle) - p.y * Math.sin(angle);
        var yt = p.x * Math.sin(angle) + p.y * Math.cos(angle);

        p.x = x + length * xt;
        p.y = y + length * yt;
      }
    }

    /**
     * Draw a closed path using the given real coordinates.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {Array.<Point>} points
     * @static
     */

  }, {
    key: 'drawPath',
    value: function drawPath(ctx, points) {
      ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y);
      for (var i = 1; i < points.length; ++i) {
        ctx.lineTo(points[i].x, points[i].y);
      }
      ctx.closePath();
    }
  }]);
  return EndPoint;
}();

/**
 * Drawing methods for the arrow endpoint.
 * @extends EndPoint
 */


var Arrow = function (_EndPoint) {
  (0, _inherits3['default'])(Arrow, _EndPoint);

  function Arrow() {
    (0, _classCallCheck3['default'])(this, Arrow);
    return (0, _possibleConstructorReturn3['default'])(this, (Arrow.__proto__ || (0, _getPrototypeOf2['default'])(Arrow)).apply(this, arguments));
  }

  (0, _createClass3['default'])(Arrow, null, [{
    key: 'draw',

    /**
     * Draw this shape at the end of a line.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowData} arrowData
     * @static
     */
    value: function draw(ctx, arrowData) {
      // Normalized points of closed path, in the order that they should be drawn.
      // (0, 0) is the attachment point, and the point around which should be rotated
      var points = [{ x: 0, y: 0 }, { x: -1, y: 0.3 }, { x: -0.9, y: 0 }, { x: -1, y: -0.3 }];

      EndPoint.transform(points, arrowData);
      EndPoint.drawPath(ctx, points);
    }
  }]);
  return Arrow;
}(EndPoint);

/**
 * Drawing methods for the crow endpoint.
 * @extends EndPoint
 */


var Crow = function () {
  function Crow() {
    (0, _classCallCheck3['default'])(this, Crow);
  }

  (0, _createClass3['default'])(Crow, null, [{
    key: 'draw',

    /**
     * Draw this shape at the end of a line.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowData} arrowData
     * @static
     */
    value: function draw(ctx, arrowData) {
      // Normalized points of closed path, in the order that they should be drawn.
      // (0, 0) is the attachment point, and the point around which should be rotated
      var points = [{ x: -1, y: 0 }, { x: 0, y: 0.3 }, { x: -0.4, y: 0 }, { x: 0, y: -0.3 }];

      EndPoint.transform(points, arrowData);
      EndPoint.drawPath(ctx, points);
    }
  }]);
  return Crow;
}();

/**
 * Drawing methods for the curve endpoint.
 * @extends EndPoint
 */


var Curve = function () {
  function Curve() {
    (0, _classCallCheck3['default'])(this, Curve);
  }

  (0, _createClass3['default'])(Curve, null, [{
    key: 'draw',

    /**
     * Draw this shape at the end of a line.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowData} arrowData
     * @static
     */
    value: function draw(ctx, arrowData) {
      // Normalized points of closed path, in the order that they should be drawn.
      // (0, 0) is the attachment point, and the point around which should be rotated
      var point = { x: -0.4, y: 0 };
      EndPoint.transform(point, arrowData);

      // Update endpoint style for drawing transparent arc.
      ctx.strokeStyle = ctx.fillStyle;
      ctx.fillStyle = 'rgba(0, 0, 0, 0)';

      // Define curve endpoint as semicircle.
      var pi = Math.PI;
      var start_angle = arrowData.angle - pi / 2;
      var end_angle = arrowData.angle + pi / 2;
      ctx.beginPath();
      ctx.arc(point.x, point.y, arrowData.length * 0.4, start_angle, end_angle, false);
      ctx.stroke();
    }
  }]);
  return Curve;
}();

/**
 * Drawing methods for the inverted curve endpoint.
 * @extends EndPoint
 */


var InvertedCurve = function () {
  function InvertedCurve() {
    (0, _classCallCheck3['default'])(this, InvertedCurve);
  }

  (0, _createClass3['default'])(InvertedCurve, null, [{
    key: 'draw',

    /**
     * Draw this shape at the end of a line.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowData} arrowData
     * @static
     */
    value: function draw(ctx, arrowData) {
      // Normalized points of closed path, in the order that they should be drawn.
      // (0, 0) is the attachment point, and the point around which should be rotated
      var point = { x: -0.3, y: 0 };
      EndPoint.transform(point, arrowData);

      // Update endpoint style for drawing transparent arc.
      ctx.strokeStyle = ctx.fillStyle;
      ctx.fillStyle = 'rgba(0, 0, 0, 0)';

      // Define inverted curve endpoint as semicircle.
      var pi = Math.PI;
      var start_angle = arrowData.angle + pi / 2;
      var end_angle = arrowData.angle + 3 * pi / 2;
      ctx.beginPath();
      ctx.arc(point.x, point.y, arrowData.length * 0.4, start_angle, end_angle, false);
      ctx.stroke();
    }
  }]);
  return InvertedCurve;
}();

/**
 * Drawing methods for the trinagle endpoint.
 * @extends EndPoint
 */


var Triangle = function () {
  function Triangle() {
    (0, _classCallCheck3['default'])(this, Triangle);
  }

  (0, _createClass3['default'])(Triangle, null, [{
    key: 'draw',

    /**
     * Draw this shape at the end of a line.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowData} arrowData
     * @static
     */
    value: function draw(ctx, arrowData) {
      // Normalized points of closed path, in the order that they should be drawn.
      // (0, 0) is the attachment point, and the point around which should be rotated
      var points = [{ x: 0.02, y: 0 }, { x: -1, y: 0.3 }, { x: -1, y: -0.3 }];

      EndPoint.transform(points, arrowData);
      EndPoint.drawPath(ctx, points);
    }
  }]);
  return Triangle;
}();

/**
 * Drawing methods for the inverted trinagle endpoint.
 * @extends EndPoint
 */


var InvertedTriangle = function () {
  function InvertedTriangle() {
    (0, _classCallCheck3['default'])(this, InvertedTriangle);
  }

  (0, _createClass3['default'])(InvertedTriangle, null, [{
    key: 'draw',

    /**
     * Draw this shape at the end of a line.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowData} arrowData
     * @static
     */
    value: function draw(ctx, arrowData) {
      // Normalized points of closed path, in the order that they should be drawn.
      // (0, 0) is the attachment point, and the point around which should be rotated
      var points = [{ x: 0, y: 0.3 }, { x: 0, y: -0.3 }, { x: -1, y: 0 }];

      EndPoint.transform(points, arrowData);
      EndPoint.drawPath(ctx, points);
    }
  }]);
  return InvertedTriangle;
}();

/**
 * Drawing methods for the circle endpoint.
 */


var Circle = function () {
  function Circle() {
    (0, _classCallCheck3['default'])(this, Circle);
  }

  (0, _createClass3['default'])(Circle, null, [{
    key: 'draw',

    /**
     * Draw this shape at the end of a line.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowData} arrowData
     * @static
     */
    value: function draw(ctx, arrowData) {
      var point = { x: -0.4, y: 0 };

      EndPoint.transform(point, arrowData);
      ctx.circle(point.x, point.y, arrowData.length * 0.4);
    }
  }]);
  return Circle;
}();

/**
 * Drawing methods for the bar endpoint.
 */


var Bar = function () {
  function Bar() {
    (0, _classCallCheck3['default'])(this, Bar);
  }

  (0, _createClass3['default'])(Bar, null, [{
    key: 'draw',

    /**
     * Draw this shape at the end of a line.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowData} arrowData
     * @static
     */
    value: function draw(ctx, arrowData) {
      /*
      var points = [
        {x:0, y:0.5},
        {x:0, y:-0.5}
      ];
       EndPoint.transform(points, arrowData);
      ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y);
      ctx.lineTo(points[1].x, points[1].y);
      ctx.stroke();
      */

      var points = [{ x: 0, y: 0.5 }, { x: 0, y: -0.5 }, { x: -0.15, y: -0.5 }, { x: -0.15, y: 0.5 }];

      EndPoint.transform(points, arrowData);
      EndPoint.drawPath(ctx, points);
    }
  }]);
  return Bar;
}();

/**
 * Drawing methods for the box endpoint.
 */


var Box = function () {
  function Box() {
    (0, _classCallCheck3['default'])(this, Box);
  }

  (0, _createClass3['default'])(Box, null, [{
    key: 'draw',

    /**
     * Draw this shape at the end of a line.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowData} arrowData
     * @static
     */
    value: function draw(ctx, arrowData) {
      var points = [{ x: 0, y: 0.3 }, { x: 0, y: -0.3 }, { x: -0.6, y: -0.3 }, { x: -0.6, y: 0.3 }];

      EndPoint.transform(points, arrowData);
      EndPoint.drawPath(ctx, points);
    }
  }]);
  return Box;
}();

/**
 * Drawing methods for the diamond endpoint.
 */


var Diamond = function () {
  function Diamond() {
    (0, _classCallCheck3['default'])(this, Diamond);
  }

  (0, _createClass3['default'])(Diamond, null, [{
    key: 'draw',

    /**
     * Draw this shape at the end of a line.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowData} arrowData
     * @static
     */
    value: function draw(ctx, arrowData) {
      var points = [{ x: 0, y: 0 }, { x: -0.5, y: -0.3 }, { x: -1, y: 0 }, { x: -0.5, y: 0.3 }];

      EndPoint.transform(points, arrowData);
      EndPoint.drawPath(ctx, points);
    }
  }]);
  return Diamond;
}();

/**
 * Drawing methods for the vee endpoint.
 * @extends EndPoint
 */


var Vee = function () {
  function Vee() {
    (0, _classCallCheck3['default'])(this, Vee);
  }

  (0, _createClass3['default'])(Vee, null, [{
    key: 'draw',

    /**
     * Draw this shape at the end of a line.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowData} arrowData
     * @static
     */
    value: function draw(ctx, arrowData) {
      // Normalized points of closed path, in the order that they should be drawn.
      // (0, 0) is the attachment point, and the point around which should be rotated
      var points = [{ x: -1, y: 0.3 }, { x: -0.5, y: 0 }, { x: -1, y: -0.3 }, { x: 0, y: 0 }];

      EndPoint.transform(points, arrowData);
      EndPoint.drawPath(ctx, points);
    }
  }]);
  return Vee;
}();

/**
 * Drawing methods for the endpoints.
 */


var EndPoints = function () {
  function EndPoints() {
    (0, _classCallCheck3['default'])(this, EndPoints);
  }

  (0, _createClass3['default'])(EndPoints, null, [{
    key: 'draw',

    /**
     * Draw an endpoint
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowData} arrowData
     * @static
     */
    value: function draw(ctx, arrowData) {
      var type;
      if (arrowData.type) {
        type = arrowData.type.toLowerCase();
      }

      switch (type) {
        case 'circle':
          Circle.draw(ctx, arrowData);
          break;
        case 'box':
          Box.draw(ctx, arrowData);
          break;
        case 'crow':
          Crow.draw(ctx, arrowData);
          break;
        case 'curve':
          Curve.draw(ctx, arrowData);
          break;
        case 'diamond':
          Diamond.draw(ctx, arrowData);
          break;
        case 'inv_curve':
          InvertedCurve.draw(ctx, arrowData);
          break;
        case 'triangle':
          Triangle.draw(ctx, arrowData);
          break;
        case 'inv_triangle':
          InvertedTriangle.draw(ctx, arrowData);
          break;
        case 'bar':
          Bar.draw(ctx, arrowData);
          break;
        case 'vee':
          Vee.draw(ctx, arrowData);
          break;
        case 'arrow': // fall-through
        default:
          Arrow.draw(ctx, arrowData);
      }
    }
  }]);
  return EndPoints;
}();

exports['default'] = EndPoints;

/***/ }),
/* 81 */
/***/ (function(module, exports, __nested_webpack_require_344088__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __nested_webpack_require_344088__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_344088__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * Barnes Hut Solver
 */
var BarnesHutSolver = function () {
  /**
   * @param {Object} body
   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody
   * @param {Object} options
   */
  function BarnesHutSolver(body, physicsBody, options) {
    (0, _classCallCheck3['default'])(this, BarnesHutSolver);

    this.body = body;
    this.physicsBody = physicsBody;
    this.barnesHutTree;
    this.setOptions(options);
    this.randomSeed = 5;

    // debug: show grid
    // this.body.emitter.on("afterDrawing", (ctx) => {this._debug(ctx,'#ff0000')})
  }

  /**
   *
   * @param {Object} options
   */


  (0, _createClass3['default'])(BarnesHutSolver, [{
    key: 'setOptions',
    value: function setOptions(options) {
      this.options = options;
      this.thetaInversed = 1 / this.options.theta;

      // if 1 then min distance = 0.5, if 0.5 then min distance = 0.5 + 0.5*node.shape.radius
      this.overlapAvoidanceFactor = 1 - Math.max(0, Math.min(1, this.options.avoidOverlap));
    }

    /**
     *
     * @returns {number} random integer
     */

  }, {
    key: 'seededRandom',
    value: function seededRandom() {
      var x = Math.sin(this.randomSeed++) * 10000;
      return x - Math.floor(x);
    }

    /**
     * This function calculates the forces the nodes apply on each other based on a gravitational model.
     * The Barnes Hut method is used to speed up this N-body simulation.
     *
     * @private
     */

  }, {
    key: 'solve',
    value: function solve() {
      if (this.options.gravitationalConstant !== 0 && this.physicsBody.physicsNodeIndices.length > 0) {
        var node = void 0;
        var nodes = this.body.nodes;
        var nodeIndices = this.physicsBody.physicsNodeIndices;
        var nodeCount = nodeIndices.length;

        // create the tree
        var barnesHutTree = this._formBarnesHutTree(nodes, nodeIndices);

        // for debugging
        this.barnesHutTree = barnesHutTree;

        // place the nodes one by one recursively
        for (var i = 0; i < nodeCount; i++) {
          node = nodes[nodeIndices[i]];
          if (node.options.mass > 0) {
            // starting with root is irrelevant, it never passes the BarnesHutSolver condition
            this._getForceContributions(barnesHutTree.root, node);
          }
        }
      }
    }

    /**
     * @param {Object} parentBranch
     * @param {Node} node
     * @private
     */

  }, {
    key: '_getForceContributions',
    value: function _getForceContributions(parentBranch, node) {
      this._getForceContribution(parentBranch.children.NW, node);
      this._getForceContribution(parentBranch.children.NE, node);
      this._getForceContribution(parentBranch.children.SW, node);
      this._getForceContribution(parentBranch.children.SE, node);
    }

    /**
     * This function traverses the barnesHutTree. It checks when it can approximate distant nodes with their center of mass.
     * If a region contains a single node, we check if it is not itself, then we apply the force.
     *
     * @param {Object} parentBranch
     * @param {Node} node
     * @private
     */

  }, {
    key: '_getForceContribution',
    value: function _getForceContribution(parentBranch, node) {
      // we get no force contribution from an empty region
      if (parentBranch.childrenCount > 0) {
        var dx = void 0,
            dy = void 0,
            distance = void 0;

        // get the distance from the center of mass to the node.
        dx = parentBranch.centerOfMass.x - node.x;
        dy = parentBranch.centerOfMass.y - node.y;
        distance = Math.sqrt(dx * dx + dy * dy);

        // BarnesHutSolver condition
        // original condition : s/d < theta = passed  ===  d/s > 1/theta = passed
        // calcSize = 1/s --> d * 1/s > 1/theta = passed
        if (distance * parentBranch.calcSize > this.thetaInversed) {
          this._calculateForces(distance, dx, dy, node, parentBranch);
        } else {
          // Did not pass the condition, go into children if available
          if (parentBranch.childrenCount === 4) {
            this._getForceContributions(parentBranch, node);
          } else {
            // parentBranch must have only one node, if it was empty we wouldnt be here
            if (parentBranch.children.data.id != node.id) {
              // if it is not self
              this._calculateForces(distance, dx, dy, node, parentBranch);
            }
          }
        }
      }
    }

    /**
     * Calculate the forces based on the distance.
     *
     * @param {number} distance
     * @param {number} dx
     * @param {number} dy
     * @param {Node} node
     * @param {Object} parentBranch
     * @private
     */

  }, {
    key: '_calculateForces',
    value: function _calculateForces(distance, dx, dy, node, parentBranch) {
      if (distance === 0) {
        distance = 0.1;
        dx = distance;
      }

      if (this.overlapAvoidanceFactor < 1 && node.shape.radius) {
        distance = Math.max(0.1 + this.overlapAvoidanceFactor * node.shape.radius, distance - node.shape.radius);
      }

      // the dividing by the distance cubed instead of squared allows us to get the fx and fy components without sines and cosines
      // it is shorthand for gravityforce with distance squared and fx = dx/distance * gravityForce
      var gravityForce = this.options.gravitationalConstant * parentBranch.mass * node.options.mass / Math.pow(distance, 3);
      var fx = dx * gravityForce;
      var fy = dy * gravityForce;

      this.physicsBody.forces[node.id].x += fx;
      this.physicsBody.forces[node.id].y += fy;
    }

    /**
     * This function constructs the barnesHut tree recursively. It creates the root, splits it and starts placing the nodes.
     *
     * @param {Array.<Node>} nodes
     * @param {Array.<number>} nodeIndices
     * @returns {{root: {centerOfMass: {x: number, y: number}, mass: number, range: {minX: number, maxX: number, minY: number, maxY: number}, size: number, calcSize: number, children: {data: null}, maxWidth: number, level: number, childrenCount: number}}} BarnesHutTree
     * @private
     */

  }, {
    key: '_formBarnesHutTree',
    value: function _formBarnesHutTree(nodes, nodeIndices) {
      var node = void 0;
      var nodeCount = nodeIndices.length;

      var minX = nodes[nodeIndices[0]].x;
      var minY = nodes[nodeIndices[0]].y;
      var maxX = nodes[nodeIndices[0]].x;
      var maxY = nodes[nodeIndices[0]].y;

      // get the range of the nodes
      for (var i = 1; i < nodeCount; i++) {
        var _node = nodes[nodeIndices[i]];
        var x = _node.x;
        var y = _node.y;
        if (_node.options.mass > 0) {
          if (x < minX) {
            minX = x;
          }
          if (x > maxX) {
            maxX = x;
          }
          if (y < minY) {
            minY = y;
          }
          if (y > maxY) {
            maxY = y;
          }
        }
      }
      // make the range a square
      var sizeDiff = Math.abs(maxX - minX) - Math.abs(maxY - minY); // difference between X and Y
      if (sizeDiff > 0) {
        minY -= 0.5 * sizeDiff;
        maxY += 0.5 * sizeDiff;
      } // xSize > ySize
      else {
          minX += 0.5 * sizeDiff;
          maxX -= 0.5 * sizeDiff;
        } // xSize < ySize

      var minimumTreeSize = 1e-5;
      var rootSize = Math.max(minimumTreeSize, Math.abs(maxX - minX));
      var halfRootSize = 0.5 * rootSize;
      var centerX = 0.5 * (minX + maxX),
          centerY = 0.5 * (minY + maxY);

      // construct the barnesHutTree
      var barnesHutTree = {
        root: {
          centerOfMass: { x: 0, y: 0 },
          mass: 0,
          range: {
            minX: centerX - halfRootSize,
            maxX: centerX + halfRootSize,
            minY: centerY - halfRootSize,
            maxY: centerY + halfRootSize
          },
          size: rootSize,
          calcSize: 1 / rootSize,
          children: { data: null },
          maxWidth: 0,
          level: 0,
          childrenCount: 4
        }
      };
      this._splitBranch(barnesHutTree.root);

      // place the nodes one by one recursively
      for (var _i = 0; _i < nodeCount; _i++) {
        node = nodes[nodeIndices[_i]];
        if (node.options.mass > 0) {
          this._placeInTree(barnesHutTree.root, node);
        }
      }

      // make global
      return barnesHutTree;
    }

    /**
     * this updates the mass of a branch. this is increased by adding a node.
     *
     * @param {Object} parentBranch
     * @param {Node} node
     * @private
     */

  }, {
    key: '_updateBranchMass',
    value: function _updateBranchMass(parentBranch, node) {
      var centerOfMass = parentBranch.centerOfMass;
      var totalMass = parentBranch.mass + node.options.mass;
      var totalMassInv = 1 / totalMass;

      centerOfMass.x = centerOfMass.x * parentBranch.mass + node.x * node.options.mass;
      centerOfMass.x *= totalMassInv;

      centerOfMass.y = centerOfMass.y * parentBranch.mass + node.y * node.options.mass;
      centerOfMass.y *= totalMassInv;

      parentBranch.mass = totalMass;
      var biggestSize = Math.max(Math.max(node.height, node.radius), node.width);
      parentBranch.maxWidth = parentBranch.maxWidth < biggestSize ? biggestSize : parentBranch.maxWidth;
    }

    /**
     * determine in which branch the node will be placed.
     *
     * @param {Object} parentBranch
     * @param {Node} node
     * @param {boolean} skipMassUpdate
     * @private
     */

  }, {
    key: '_placeInTree',
    value: function _placeInTree(parentBranch, node, skipMassUpdate) {
      if (skipMassUpdate != true || skipMassUpdate === undefined) {
        // update the mass of the branch.
        this._updateBranchMass(parentBranch, node);
      }

      var range = parentBranch.children.NW.range;
      var region = void 0;
      if (range.maxX > node.x) {
        // in NW or SW
        if (range.maxY > node.y) {
          region = 'NW';
        } else {
          region = 'SW';
        }
      } else {
        // in NE or SE
        if (range.maxY > node.y) {
          region = 'NE';
        } else {
          region = 'SE';
        }
      }

      this._placeInRegion(parentBranch, node, region);
    }

    /**
     * actually place the node in a region (or branch)
     *
     * @param {Object} parentBranch
     * @param {Node} node
     * @param {'NW'| 'NE' | 'SW' | 'SE'} region
     * @private
     */

  }, {
    key: '_placeInRegion',
    value: function _placeInRegion(parentBranch, node, region) {
      var children = parentBranch.children[region];

      switch (children.childrenCount) {
        case 0:
          // place node here
          children.children.data = node;
          children.childrenCount = 1;
          this._updateBranchMass(children, node);
          break;
        case 1:
          // convert into children
          // if there are two nodes exactly overlapping (on init, on opening of cluster etc.)
          // we move one node a little bit and we do not put it in the tree.
          if (children.children.data.x === node.x && children.children.data.y === node.y) {
            node.x += this.seededRandom();
            node.y += this.seededRandom();
          } else {
            this._splitBranch(children);
            this._placeInTree(children, node);
          }
          break;
        case 4:
          // place in branch
          this._placeInTree(children, node);
          break;
      }
    }

    /**
     * this function splits a branch into 4 sub branches. If the branch contained a node, we place it in the subbranch
     * after the split is complete.
     *
     * @param {Object} parentBranch
     * @private
     */

  }, {
    key: '_splitBranch',
    value: function _splitBranch(parentBranch) {
      // if the branch is shaded with a node, replace the node in the new subset.
      var containedNode = null;
      if (parentBranch.childrenCount === 1) {
        containedNode = parentBranch.children.data;
        parentBranch.mass = 0;
        parentBranch.centerOfMass.x = 0;
        parentBranch.centerOfMass.y = 0;
      }
      parentBranch.childrenCount = 4;
      parentBranch.children.data = null;
      this._insertRegion(parentBranch, 'NW');
      this._insertRegion(parentBranch, 'NE');
      this._insertRegion(parentBranch, 'SW');
      this._insertRegion(parentBranch, 'SE');

      if (containedNode != null) {
        this._placeInTree(parentBranch, containedNode);
      }
    }

    /**
     * This function subdivides the region into four new segments.
     * Specifically, this inserts a single new segment.
     * It fills the children section of the parentBranch
     *
     * @param {Object} parentBranch
     * @param {'NW'| 'NE' | 'SW' | 'SE'} region
     * @private
     */

  }, {
    key: '_insertRegion',
    value: function _insertRegion(parentBranch, region) {
      var minX = void 0,
          maxX = void 0,
          minY = void 0,
          maxY = void 0;
      var childSize = 0.5 * parentBranch.size;
      switch (region) {
        case 'NW':
          minX = parentBranch.range.minX;
          maxX = parentBranch.range.minX + childSize;
          minY = parentBranch.range.minY;
          maxY = parentBranch.range.minY + childSize;
          break;
        case 'NE':
          minX = parentBranch.range.minX + childSize;
          maxX = parentBranch.range.maxX;
          minY = parentBranch.range.minY;
          maxY = parentBranch.range.minY + childSize;
          break;
        case 'SW':
          minX = parentBranch.range.minX;
          maxX = parentBranch.range.minX + childSize;
          minY = parentBranch.range.minY + childSize;
          maxY = parentBranch.range.maxY;
          break;
        case 'SE':
          minX = parentBranch.range.minX + childSize;
          maxX = parentBranch.range.maxX;
          minY = parentBranch.range.minY + childSize;
          maxY = parentBranch.range.maxY;
          break;
      }

      parentBranch.children[region] = {
        centerOfMass: { x: 0, y: 0 },
        mass: 0,
        range: { minX: minX, maxX: maxX, minY: minY, maxY: maxY },
        size: 0.5 * parentBranch.size,
        calcSize: 2 * parentBranch.calcSize,
        children: { data: null },
        maxWidth: 0,
        level: parentBranch.level + 1,
        childrenCount: 0
      };
    }

    //---------------------------  DEBUGGING BELOW  ---------------------------//

    /**
     * This function is for debugging purposed, it draws the tree.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {string} color
     * @private
     */

  }, {
    key: '_debug',
    value: function _debug(ctx, color) {
      if (this.barnesHutTree !== undefined) {
        ctx.lineWidth = 1;

        this._drawBranch(this.barnesHutTree.root, ctx, color);
      }
    }

    /**
     * This function is for debugging purposes. It draws the branches recursively.
     *
     * @param {Object} branch
     * @param {CanvasRenderingContext2D} ctx
     * @param {string} color
     * @private
     */

  }, {
    key: '_drawBranch',
    value: function _drawBranch(branch, ctx, color) {
      if (color === undefined) {
        color = '#FF0000';
      }

      if (branch.childrenCount === 4) {
        this._drawBranch(branch.children.NW, ctx);
        this._drawBranch(branch.children.NE, ctx);
        this._drawBranch(branch.children.SE, ctx);
        this._drawBranch(branch.children.SW, ctx);
      }
      ctx.strokeStyle = color;
      ctx.beginPath();
      ctx.moveTo(branch.range.minX, branch.range.minY);
      ctx.lineTo(branch.range.maxX, branch.range.minY);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(branch.range.maxX, branch.range.minY);
      ctx.lineTo(branch.range.maxX, branch.range.maxY);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(branch.range.maxX, branch.range.maxY);
      ctx.lineTo(branch.range.minX, branch.range.maxY);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(branch.range.minX, branch.range.maxY);
      ctx.lineTo(branch.range.minX, branch.range.minY);
      ctx.stroke();

      /*
       if (branch.mass > 0) {
       ctx.circle(branch.centerOfMass.x, branch.centerOfMass.y, 3*branch.mass);
       ctx.stroke();
       }
       */
    }
  }]);
  return BarnesHutSolver;
}();

exports['default'] = BarnesHutSolver;

/***/ }),
/* 82 */
/***/ (function(module, exports, __nested_webpack_require_361002__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __nested_webpack_require_361002__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_361002__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * Central Gravity Solver
 */
var CentralGravitySolver = function () {
  /**
   * @param {Object} body
   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody
   * @param {Object} options
   */
  function CentralGravitySolver(body, physicsBody, options) {
    (0, _classCallCheck3["default"])(this, CentralGravitySolver);

    this.body = body;
    this.physicsBody = physicsBody;
    this.setOptions(options);
  }

  /**
   *
   * @param {Object} options
   */


  (0, _createClass3["default"])(CentralGravitySolver, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.options = options;
    }

    /**
     * Calculates forces for each node
     */

  }, {
    key: "solve",
    value: function solve() {
      var dx = void 0,
          dy = void 0,
          distance = void 0,
          node = void 0;
      var nodes = this.body.nodes;
      var nodeIndices = this.physicsBody.physicsNodeIndices;
      var forces = this.physicsBody.forces;

      for (var i = 0; i < nodeIndices.length; i++) {
        var nodeId = nodeIndices[i];
        node = nodes[nodeId];
        dx = -node.x;
        dy = -node.y;
        distance = Math.sqrt(dx * dx + dy * dy);

        this._calculateForces(distance, dx, dy, forces, node);
      }
    }

    /**
     * Calculate the forces based on the distance.
     * @param {number} distance
     * @param {number} dx
     * @param {number} dy
     * @param {Object<Node.id, vis.Node>} forces
     * @param {Node} node
     * @private
     */

  }, {
    key: "_calculateForces",
    value: function _calculateForces(distance, dx, dy, forces, node) {
      var gravityForce = distance === 0 ? 0 : this.options.centralGravity / distance;
      forces[node.id].x = dx * gravityForce;
      forces[node.id].y = dy * gravityForce;
    }
  }]);
  return CentralGravitySolver;
}();

exports["default"] = CentralGravitySolver;

/***/ }),
/* 83 */
/***/ (function(module, exports, __nested_webpack_require_363422__) {

module.exports = __nested_webpack_require_363422__(188);

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * This object contains all possible options. It will check if the types are correct, if required if the option is one
 * of the allowed values.
 *
 * __any__ means that the name of the property does not matter.
 * __type__ is a required field for all objects and contains the allowed types of all objects
 */
var string = 'string';
var bool = 'boolean';
var number = 'number';
var array = 'array';
var object = 'object'; // should only be in a __type__ property
var dom = 'dom';
var any = 'any';

// List of endpoints
var endPoints = ['arrow', 'circle', 'bar'];

var allOptions = {
  configure: {
    enabled: { boolean: bool },
    filter: { boolean: bool, string: string, array: array, 'function': 'function' },
    container: { dom: dom },
    showButton: { boolean: bool },
    __type__: { object: object, boolean: bool, string: string, array: array, 'function': 'function' }
  },
  edges: {
    arrows: {
      to: {
        enabled: { boolean: bool },
        scaleFactor: { number: number },
        type: { string: endPoints },
        __type__: { object: object, boolean: bool }
      },
      middle: {
        enabled: { boolean: bool },
        scaleFactor: { number: number },
        type: { string: endPoints },
        __type__: { object: object, boolean: bool }
      },
      from: {
        enabled: { boolean: bool },
        scaleFactor: { number: number },
        type: { string: endPoints },
        __type__: { object: object, boolean: bool }
      },
      __type__: { string: ['from', 'to', 'middle'], object: object }
    },
    arrowStrikethrough: { boolean: bool },
    background: {
      enabled: { boolean: bool },
      color: { string: string },
      size: { number: number },
      dashes: { boolean: bool, array: array },
      __type__: { object: object, boolean: bool }
    },
    chosen: {
      label: { boolean: bool, 'function': 'function' },
      edge: { boolean: bool, 'function': 'function' },
      __type__: { object: object, boolean: bool }
    },
    color: {
      color: { string: string },
      highlight: { string: string },
      hover: { string: string },
      inherit: { string: ['from', 'to', 'both'], boolean: bool },
      opacity: { number: number },
      __type__: { object: object, string: string }
    },
    dashes: { boolean: bool, array: array },
    font: {
      color: { string: string },
      size: { number: number }, // px
      face: { string: string },
      background: { string: string },
      strokeWidth: { number: number }, // px
      strokeColor: { string: string },
      align: { string: ['horizontal', 'top', 'middle', 'bottom'] },
      vadjust: { number: number },
      multi: { boolean: bool, string: string },
      bold: {
        color: { string: string },
        size: { number: number }, // px
        face: { string: string },
        mod: { string: string },
        vadjust: { number: number },
        __type__: { object: object, string: string }
      },
      boldital: {
        color: { string: string },
        size: { number: number }, // px
        face: { string: string },
        mod: { string: string },
        vadjust: { number: number },
        __type__: { object: object, string: string }
      },
      ital: {
        color: { string: string },
        size: { number: number }, // px
        face: { string: string },
        mod: { string: string },
        vadjust: { number: number },
        __type__: { object: object, string: string }
      },
      mono: {
        color: { string: string },
        size: { number: number }, // px
        face: { string: string },
        mod: { string: string },
        vadjust: { number: number },
        __type__: { object: object, string: string }
      },
      __type__: { object: object, string: string }
    },
    hidden: { boolean: bool },
    hoverWidth: { 'function': 'function', number: number },
    label: { string: string, undefined: 'undefined' },
    labelHighlightBold: { boolean: bool },
    length: { number: number, undefined: 'undefined' },
    physics: { boolean: bool },
    scaling: {
      min: { number: number },
      max: { number: number },
      label: {
        enabled: { boolean: bool },
        min: { number: number },
        max: { number: number },
        maxVisible: { number: number },
        drawThreshold: { number: number },
        __type__: { object: object, boolean: bool }
      },
      customScalingFunction: { 'function': 'function' },
      __type__: { object: object }
    },
    selectionWidth: { 'function': 'function', number: number },
    selfReferenceSize: { number: number },
    shadow: {
      enabled: { boolean: bool },
      color: { string: string },
      size: { number: number },
      x: { number: number },
      y: { number: number },
      __type__: { object: object, boolean: bool }
    },
    smooth: {
      enabled: { boolean: bool },
      type: {
        string: ['dynamic', 'continuous', 'discrete', 'diagonalCross', 'straightCross', 'horizontal', 'vertical', 'curvedCW', 'curvedCCW', 'cubicBezier']
      },
      roundness: { number: number },
      forceDirection: {
        string: ['horizontal', 'vertical', 'none'],
        boolean: bool
      },
      __type__: { object: object, boolean: bool }
    },
    title: { string: string, undefined: 'undefined' },
    width: { number: number },
    widthConstraint: {
      maximum: { number: number },
      __type__: { object: object, boolean: bool, number: number }
    },
    value: { number: number, undefined: 'undefined' },
    __type__: { object: object }
  },
  groups: {
    useDefaultGroups: { boolean: bool },
    __any__: 'get from nodes, will be overwritten below',
    __type__: { object: object }
  },
  interaction: {
    dragNodes: { boolean: bool },
    dragView: { boolean: bool },
    hideEdgesOnDrag: { boolean: bool },
    hideEdgesOnZoom: { boolean: bool },
    hideNodesOnDrag: { boolean: bool },
    hover: { boolean: bool },
    keyboard: {
      enabled: { boolean: bool },
      speed: {
        x: { number: number },
        y: { number: number },
        zoom: { number: number },
        __type__: { object: object }
      },
      bindToWindow: { boolean: bool },
      __type__: { object: object, boolean: bool }
    },
    multiselect: { boolean: bool },
    navigationButtons: { boolean: bool },
    selectable: { boolean: bool },
    selectConnectedEdges: { boolean: bool },
    hoverConnectedEdges: { boolean: bool },
    tooltipDelay: { number: number },
    zoomView: { boolean: bool },
    zoomSpeed: { number: number },
    __type__: { object: object }
  },
  layout: {
    randomSeed: { undefined: 'undefined', number: number },
    improvedLayout: { boolean: bool },
    hierarchical: {
      enabled: { boolean: bool },
      levelSeparation: { number: number },
      nodeSpacing: { number: number },
      treeSpacing: { number: number },
      blockShifting: { boolean: bool },
      edgeMinimization: { boolean: bool },
      parentCentralization: { boolean: bool },
      direction: { string: ['UD', 'DU', 'LR', 'RL'] }, // UD, DU, LR, RL
      sortMethod: { string: ['hubsize', 'directed'] }, // hubsize, directed
      __type__: { object: object, boolean: bool }
    },
    __type__: { object: object }
  },
  manipulation: {
    enabled: { boolean: bool },
    initiallyActive: { boolean: bool },
    addNode: { boolean: bool, 'function': 'function' },
    addEdge: { boolean: bool, 'function': 'function' },
    editNode: { 'function': 'function' },
    editEdge: {
      editWithoutDrag: { 'function': 'function' },
      __type__: { object: object, boolean: bool, 'function': 'function' }
    },
    deleteNode: { boolean: bool, 'function': 'function' },
    deleteEdge: { boolean: bool, 'function': 'function' },
    controlNodeStyle: 'get from nodes, will be overwritten below',
    __type__: { object: object, boolean: bool }
  },
  nodes: {
    borderWidth: { number: number },
    borderWidthSelected: { number: number, undefined: 'undefined' },
    brokenImage: { string: string, undefined: 'undefined' },
    chosen: {
      label: { boolean: bool, 'function': 'function' },
      node: { boolean: bool, 'function': 'function' },
      __type__: { object: object, boolean: bool }
    },
    color: {
      border: { string: string },
      background: { string: string },
      highlight: {
        border: { string: string },
        background: { string: string },
        __type__: { object: object, string: string }
      },
      hover: {
        border: { string: string },
        background: { string: string },
        __type__: { object: object, string: string }
      },
      __type__: { object: object, string: string }
    },
    fixed: {
      x: { boolean: bool },
      y: { boolean: bool },
      __type__: { object: object, boolean: bool }
    },
    font: {
      align: { string: string },
      color: { string: string },
      size: { number: number }, // px
      face: { string: string },
      background: { string: string },
      strokeWidth: { number: number }, // px
      strokeColor: { string: string },
      vadjust: { number: number },
      multi: { boolean: bool, string: string },
      bold: {
        color: { string: string },
        size: { number: number }, // px
        face: { string: string },
        mod: { string: string },
        vadjust: { number: number },
        __type__: { object: object, string: string }
      },
      boldital: {
        color: { string: string },
        size: { number: number }, // px
        face: { string: string },
        mod: { string: string },
        vadjust: { number: number },
        __type__: { object: object, string: string }
      },
      ital: {
        color: { string: string },
        size: { number: number }, // px
        face: { string: string },
        mod: { string: string },
        vadjust: { number: number },
        __type__: { object: object, string: string }
      },
      mono: {
        color: { string: string },
        size: { number: number }, // px
        face: { string: string },
        mod: { string: string },
        vadjust: { number: number },
        __type__: { object: object, string: string }
      },
      __type__: { object: object, string: string }
    },
    group: { string: string, number: number, undefined: 'undefined' },
    heightConstraint: {
      minimum: { number: number },
      valign: { string: string },
      __type__: { object: object, boolean: bool, number: number }
    },
    hidden: { boolean: bool },
    icon: {
      face: { string: string },
      code: { string: string }, //'\uf007',
      size: { number: number }, //50,
      color: { string: string },
      __type__: { object: object }
    },
    id: { string: string, number: number },
    image: {
      selected: { string: string, undefined: 'undefined' }, // --> URL
      unselected: { string: string, undefined: 'undefined' }, // --> URL
      __type__: { object: object, string: string }
    },
    label: { string: string, undefined: 'undefined' },
    labelHighlightBold: { boolean: bool },
    level: { number: number, undefined: 'undefined' },
    margin: {
      top: { number: number },
      right: { number: number },
      bottom: { number: number },
      left: { number: number },
      __type__: { object: object, number: number }
    },
    mass: { number: number },
    physics: { boolean: bool },
    scaling: {
      min: { number: number },
      max: { number: number },
      label: {
        enabled: { boolean: bool },
        min: { number: number },
        max: { number: number },
        maxVisible: { number: number },
        drawThreshold: { number: number },
        __type__: { object: object, boolean: bool }
      },
      customScalingFunction: { 'function': 'function' },
      __type__: { object: object }
    },
    shadow: {
      enabled: { boolean: bool },
      color: { string: string },
      size: { number: number },
      x: { number: number },
      y: { number: number },
      __type__: { object: object, boolean: bool }
    },
    shape: {
      string: ['ellipse', 'circle', 'database', 'box', 'text', 'image', 'circularImage', 'diamond', 'dot', 'star', 'triangle', 'triangleDown', 'square', 'icon', 'hexagon']
    },
    shapeProperties: {
      borderDashes: { boolean: bool, array: array },
      borderRadius: { number: number },
      interpolation: { boolean: bool },
      useImageSize: { boolean: bool },
      useBorderWithImage: { boolean: bool },
      __type__: { object: object }
    },
    size: { number: number },
    title: { string: string, dom: dom, undefined: 'undefined' },
    value: { number: number, undefined: 'undefined' },
    widthConstraint: {
      minimum: { number: number },
      maximum: { number: number },
      __type__: { object: object, boolean: bool, number: number }
    },
    x: { number: number },
    y: { number: number },
    __type__: { object: object }
  },
  physics: {
    enabled: { boolean: bool },
    barnesHut: {
      gravitationalConstant: { number: number },
      centralGravity: { number: number },
      springLength: { number: number },
      springConstant: { number: number },
      damping: { number: number },
      avoidOverlap: { number: number },
      __type__: { object: object }
    },
    forceAtlas2Based: {
      gravitationalConstant: { number: number },
      centralGravity: { number: number },
      springLength: { number: number },
      springConstant: { number: number },
      damping: { number: number },
      avoidOverlap: { number: number },
      __type__: { object: object }
    },
    repulsion: {
      centralGravity: { number: number },
      springLength: { number: number },
      springConstant: { number: number },
      nodeDistance: { number: number },
      damping: { number: number },
      __type__: { object: object }
    },
    hierarchicalRepulsion: {
      centralGravity: { number: number },
      springLength: { number: number },
      springConstant: { number: number },
      nodeDistance: { number: number },
      damping: { number: number },
      __type__: { object: object }
    },
    maxVelocity: { number: number },
    minVelocity: { number: number }, // px/s
    solver: {
      string: ['barnesHut', 'repulsion', 'hierarchicalRepulsion', 'forceAtlas2Based']
    },
    stabilization: {
      enabled: { boolean: bool },
      iterations: { number: number }, // maximum number of iteration to stabilize
      updateInterval: { number: number },
      onlyDynamicEdges: { boolean: bool },
      fit: { boolean: bool },
      __type__: { object: object, boolean: bool }
    },
    timestep: { number: number },
    adaptiveTimestep: { boolean: bool },
    __type__: { object: object, boolean: bool }
  },

  //globals :
  autoResize: { boolean: bool },
  clickToUse: { boolean: bool },
  locale: { string: string },
  locales: {
    __any__: { any: any },
    __type__: { object: object }
  },
  height: { string: string },
  width: { string: string },
  __type__: { object: object }
};

allOptions.groups.__any__ = allOptions.nodes;
allOptions.manipulation.controlNodeStyle = allOptions.nodes;

var configureOptions = {
  nodes: {
    borderWidth: [1, 0, 10, 1],
    borderWidthSelected: [2, 0, 10, 1],
    color: {
      border: ['color', '#2B7CE9'],
      background: ['color', '#97C2FC'],
      highlight: {
        border: ['color', '#2B7CE9'],
        background: ['color', '#D2E5FF']
      },
      hover: {
        border: ['color', '#2B7CE9'],
        background: ['color', '#D2E5FF']
      }
    },
    fixed: {
      x: false,
      y: false
    },
    font: {
      color: ['color', '#343434'],
      size: [14, 0, 100, 1], // px
      face: ['arial', 'verdana', 'tahoma'],
      background: ['color', 'none'],
      strokeWidth: [0, 0, 50, 1], // px
      strokeColor: ['color', '#ffffff']
    },
    //group: 'string',
    hidden: false,
    labelHighlightBold: true,
    //icon: {
    //  face: 'string',  //'FontAwesome',
    //  code: 'string',  //'\uf007',
    //  size: [50, 0, 200, 1],  //50,
    //  color: ['color','#2B7CE9']   //'#aa00ff'
    //},
    //image: 'string', // --> URL
    physics: true,
    scaling: {
      min: [10, 0, 200, 1],
      max: [30, 0, 200, 1],
      label: {
        enabled: false,
        min: [14, 0, 200, 1],
        max: [30, 0, 200, 1],
        maxVisible: [30, 0, 200, 1],
        drawThreshold: [5, 0, 20, 1]
      }
    },
    shadow: {
      enabled: false,
      color: 'rgba(0,0,0,0.5)',
      size: [10, 0, 20, 1],
      x: [5, -30, 30, 1],
      y: [5, -30, 30, 1]
    },
    shape: ['ellipse', 'box', 'circle', 'database', 'diamond', 'dot', 'square', 'star', 'text', 'triangle', 'triangleDown', 'hexagon'],
    shapeProperties: {
      borderDashes: false,
      borderRadius: [6, 0, 20, 1],
      interpolation: true,
      useImageSize: false
    },
    size: [25, 0, 200, 1]
  },
  edges: {
    arrows: {
      to: { enabled: false, scaleFactor: [1, 0, 3, 0.05], type: 'arrow' },
      middle: { enabled: false, scaleFactor: [1, 0, 3, 0.05], type: 'arrow' },
      from: { enabled: false, scaleFactor: [1, 0, 3, 0.05], type: 'arrow' }
    },
    arrowStrikethrough: true,
    color: {
      color: ['color', '#848484'],
      highlight: ['color', '#848484'],
      hover: ['color', '#848484'],
      inherit: ['from', 'to', 'both', true, false],
      opacity: [1, 0, 1, 0.05]
    },
    dashes: false,
    font: {
      color: ['color', '#343434'],
      size: [14, 0, 100, 1], // px
      face: ['arial', 'verdana', 'tahoma'],
      background: ['color', 'none'],
      strokeWidth: [2, 0, 50, 1], // px
      strokeColor: ['color', '#ffffff'],
      align: ['horizontal', 'top', 'middle', 'bottom']
    },
    hidden: false,
    hoverWidth: [1.5, 0, 5, 0.1],
    labelHighlightBold: true,
    physics: true,
    scaling: {
      min: [1, 0, 100, 1],
      max: [15, 0, 100, 1],
      label: {
        enabled: true,
        min: [14, 0, 200, 1],
        max: [30, 0, 200, 1],
        maxVisible: [30, 0, 200, 1],
        drawThreshold: [5, 0, 20, 1]
      }
    },
    selectionWidth: [1.5, 0, 5, 0.1],
    selfReferenceSize: [20, 0, 200, 1],
    shadow: {
      enabled: false,
      color: 'rgba(0,0,0,0.5)',
      size: [10, 0, 20, 1],
      x: [5, -30, 30, 1],
      y: [5, -30, 30, 1]
    },
    smooth: {
      enabled: true,
      type: ['dynamic', 'continuous', 'discrete', 'diagonalCross', 'straightCross', 'horizontal', 'vertical', 'curvedCW', 'curvedCCW', 'cubicBezier'],
      forceDirection: ['horizontal', 'vertical', 'none'],
      roundness: [0.5, 0, 1, 0.05]
    },
    width: [1, 0, 30, 1]
  },
  layout: {
    //randomSeed: [0, 0, 500, 1],
    //improvedLayout: true,
    hierarchical: {
      enabled: false,
      levelSeparation: [150, 20, 500, 5],
      nodeSpacing: [100, 20, 500, 5],
      treeSpacing: [200, 20, 500, 5],
      blockShifting: true,
      edgeMinimization: true,
      parentCentralization: true,
      direction: ['UD', 'DU', 'LR', 'RL'], // UD, DU, LR, RL
      sortMethod: ['hubsize', 'directed'] // hubsize, directed
    }
  },
  interaction: {
    dragNodes: true,
    dragView: true,
    hideEdgesOnDrag: false,
    hideEdgesOnZoom: false,
    hideNodesOnDrag: false,
    hover: false,
    keyboard: {
      enabled: false,
      speed: {
        x: [10, 0, 40, 1],
        y: [10, 0, 40, 1],
        zoom: [0.02, 0, 0.1, 0.005]
      },
      bindToWindow: true
    },
    multiselect: false,
    navigationButtons: false,
    selectable: true,
    selectConnectedEdges: true,
    hoverConnectedEdges: true,
    tooltipDelay: [300, 0, 1000, 25],
    zoomView: true,
    zoomSpeed: 1
  },
  manipulation: {
    enabled: false,
    initiallyActive: false
  },
  physics: {
    enabled: true,
    barnesHut: {
      //theta: [0.5, 0.1, 1, 0.05],
      gravitationalConstant: [-2000, -30000, 0, 50],
      centralGravity: [0.3, 0, 10, 0.05],
      springLength: [95, 0, 500, 5],
      springConstant: [0.04, 0, 1.2, 0.005],
      damping: [0.09, 0, 1, 0.01],
      avoidOverlap: [0, 0, 1, 0.01]
    },
    forceAtlas2Based: {
      //theta: [0.5, 0.1, 1, 0.05],
      gravitationalConstant: [-50, -500, 0, 1],
      centralGravity: [0.01, 0, 1, 0.005],
      springLength: [95, 0, 500, 5],
      springConstant: [0.08, 0, 1.2, 0.005],
      damping: [0.4, 0, 1, 0.01],
      avoidOverlap: [0, 0, 1, 0.01]
    },
    repulsion: {
      centralGravity: [0.2, 0, 10, 0.05],
      springLength: [200, 0, 500, 5],
      springConstant: [0.05, 0, 1.2, 0.005],
      nodeDistance: [100, 0, 500, 5],
      damping: [0.09, 0, 1, 0.01]
    },
    hierarchicalRepulsion: {
      centralGravity: [0.2, 0, 10, 0.05],
      springLength: [100, 0, 500, 5],
      springConstant: [0.01, 0, 1.2, 0.005],
      nodeDistance: [120, 0, 500, 5],
      damping: [0.09, 0, 1, 0.01]
    },
    maxVelocity: [50, 0, 150, 1],
    minVelocity: [0.1, 0.01, 0.5, 0.01],
    solver: ['barnesHut', 'forceAtlas2Based', 'repulsion', 'hierarchicalRepulsion'],
    timestep: [0.5, 0.01, 1, 0.01]
    //adaptiveTimestep: true
  }
};

exports.allOptions = allOptions;
exports.configureOptions = configureOptions;

/***/ }),
/* 85 */
/***/ (function(module, exports, __nested_webpack_require_384874__) {

"use strict";


var util = __nested_webpack_require_384874__(2);

// Network
util.extend(exports, __nested_webpack_require_384874__(121));

/***/ }),
/* 86 */
/***/ (function(module, exports, __nested_webpack_require_385062__) {

__nested_webpack_require_385062__(37);
__nested_webpack_require_385062__(47);
module.exports = __nested_webpack_require_385062__(98);


/***/ }),
/* 87 */
/***/ (function(module, exports, __nested_webpack_require_385232__) {

"use strict";

var addToUnscopables = __nested_webpack_require_385232__(88);
var step = __nested_webpack_require_385232__(89);
var Iterators = __nested_webpack_require_385232__(25);
var toIObject = __nested_webpack_require_385232__(18);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __nested_webpack_require_385232__(60)(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),
/* 88 */
/***/ (function(module, exports) {

module.exports = function () { /* empty */ };


/***/ }),
/* 89 */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),
/* 90 */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),
/* 91 */
/***/ (function(module, exports, __nested_webpack_require_386843__) {

"use strict";

var create = __nested_webpack_require_386843__(41);
var descriptor = __nested_webpack_require_386843__(28);
var setToStringTag = __nested_webpack_require_386843__(46);
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__nested_webpack_require_386843__(19)(IteratorPrototype, __nested_webpack_require_386843__(8)('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),
/* 92 */
/***/ (function(module, exports, __nested_webpack_require_387442__) {

var dP = __nested_webpack_require_387442__(12);
var anObject = __nested_webpack_require_387442__(20);
var getKeys = __nested_webpack_require_387442__(26);

module.exports = __nested_webpack_require_387442__(13) ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),
/* 93 */
/***/ (function(module, exports, __nested_webpack_require_387920__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __nested_webpack_require_387920__(18);
var toLength = __nested_webpack_require_387920__(94);
var toAbsoluteIndex = __nested_webpack_require_387920__(95);
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),
/* 94 */
/***/ (function(module, exports, __nested_webpack_require_388913__) {

// 7.1.15 ToLength
var toInteger = __nested_webpack_require_388913__(42);
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),
/* 95 */
/***/ (function(module, exports, __nested_webpack_require_389205__) {

var toInteger = __nested_webpack_require_389205__(42);
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),
/* 96 */
/***/ (function(module, exports, __nested_webpack_require_389505__) {

var document = __nested_webpack_require_389505__(10).document;
module.exports = document && document.documentElement;


/***/ }),
/* 97 */
/***/ (function(module, exports, __nested_webpack_require_389687__) {

var toInteger = __nested_webpack_require_389687__(42);
var defined = __nested_webpack_require_389687__(39);
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),
/* 98 */
/***/ (function(module, exports, __nested_webpack_require_390386__) {

var anObject = __nested_webpack_require_390386__(20);
var get = __nested_webpack_require_390386__(99);
module.exports = __nested_webpack_require_390386__(6).getIterator = function (it) {
  var iterFn = get(it);
  if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');
  return anObject(iterFn.call(it));
};


/***/ }),
/* 99 */
/***/ (function(module, exports, __nested_webpack_require_390750__) {

var classof = __nested_webpack_require_390750__(67);
var ITERATOR = __nested_webpack_require_390750__(8)('iterator');
var Iterators = __nested_webpack_require_390750__(25);
module.exports = __nested_webpack_require_390750__(6).getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),
/* 100 */
/***/ (function(module, exports, __nested_webpack_require_391137__) {

__nested_webpack_require_391137__(101);
var $Object = __nested_webpack_require_391137__(6).Object;
module.exports = function create(P, D) {
  return $Object.create(P, D);
};


/***/ }),
/* 101 */
/***/ (function(module, exports, __nested_webpack_require_391362__) {

var $export = __nested_webpack_require_391362__(11);
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: __nested_webpack_require_391362__(41) });


/***/ }),
/* 102 */
/***/ (function(module, exports, __nested_webpack_require_391602__) {

__nested_webpack_require_391602__(103);
module.exports = __nested_webpack_require_391602__(6).Object.keys;


/***/ }),
/* 103 */
/***/ (function(module, exports, __nested_webpack_require_391760__) {

// 19.1.2.14 Object.keys(O)
var toObject = __nested_webpack_require_391760__(30);
var $keys = __nested_webpack_require_391760__(26);

__nested_webpack_require_391760__(68)('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});


/***/ }),
/* 104 */
/***/ (function(module, exports, __nested_webpack_require_392061__) {

module.exports = { "default": __nested_webpack_require_392061__(105), __esModule: true };

/***/ }),
/* 105 */
/***/ (function(module, exports, __nested_webpack_require_392215__) {

__nested_webpack_require_392215__(47);
__nested_webpack_require_392215__(37);
module.exports = __nested_webpack_require_392215__(48).f('iterator');


/***/ }),
/* 106 */
/***/ (function(module, exports, __nested_webpack_require_392400__) {

module.exports = { "default": __nested_webpack_require_392400__(107), __esModule: true };

/***/ }),
/* 107 */
/***/ (function(module, exports, __nested_webpack_require_392554__) {

__nested_webpack_require_392554__(108);
__nested_webpack_require_392554__(113);
__nested_webpack_require_392554__(114);
__nested_webpack_require_392554__(115);
module.exports = __nested_webpack_require_392554__(6).Symbol;


/***/ }),
/* 108 */
/***/ (function(module, exports, __nested_webpack_require_392785__) {

"use strict";

// ECMAScript 6 symbols shim
var global = __nested_webpack_require_392785__(10);
var has = __nested_webpack_require_392785__(14);
var DESCRIPTORS = __nested_webpack_require_392785__(13);
var $export = __nested_webpack_require_392785__(11);
var redefine = __nested_webpack_require_392785__(64);
var META = __nested_webpack_require_392785__(109).KEY;
var $fails = __nested_webpack_require_392785__(22);
var shared = __nested_webpack_require_392785__(44);
var setToStringTag = __nested_webpack_require_392785__(46);
var uid = __nested_webpack_require_392785__(29);
var wks = __nested_webpack_require_392785__(8);
var wksExt = __nested_webpack_require_392785__(48);
var wksDefine = __nested_webpack_require_392785__(49);
var enumKeys = __nested_webpack_require_392785__(110);
var isArray = __nested_webpack_require_392785__(111);
var anObject = __nested_webpack_require_392785__(20);
var isObject = __nested_webpack_require_392785__(21);
var toIObject = __nested_webpack_require_392785__(18);
var toPrimitive = __nested_webpack_require_392785__(40);
var createDesc = __nested_webpack_require_392785__(28);
var _create = __nested_webpack_require_392785__(41);
var gOPNExt = __nested_webpack_require_392785__(112);
var $GOPD = __nested_webpack_require_392785__(70);
var $DP = __nested_webpack_require_392785__(12);
var $keys = __nested_webpack_require_392785__(26);
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __nested_webpack_require_392785__(69).f = gOPNExt.f = $getOwnPropertyNames;
  __nested_webpack_require_392785__(32).f = $propertyIsEnumerable;
  __nested_webpack_require_392785__(50).f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__nested_webpack_require_392785__(27)) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __nested_webpack_require_392785__(19)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);


/***/ }),
/* 109 */
/***/ (function(module, exports, __nested_webpack_require_401728__) {

var META = __nested_webpack_require_401728__(29)('meta');
var isObject = __nested_webpack_require_401728__(21);
var has = __nested_webpack_require_401728__(14);
var setDesc = __nested_webpack_require_401728__(12).f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__nested_webpack_require_401728__(22)(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),
/* 110 */
/***/ (function(module, exports, __nested_webpack_require_403381__) {

// all enumerable object keys, includes symbols
var getKeys = __nested_webpack_require_403381__(26);
var gOPS = __nested_webpack_require_403381__(50);
var pIE = __nested_webpack_require_403381__(32);
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};


/***/ }),
/* 111 */
/***/ (function(module, exports, __nested_webpack_require_403924__) {

// 7.2.2 IsArray(argument)
var cof = __nested_webpack_require_403924__(38);
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),
/* 112 */
/***/ (function(module, exports, __nested_webpack_require_404156__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __nested_webpack_require_404156__(18);
var gOPN = __nested_webpack_require_404156__(69).f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),
/* 113 */
/***/ (function(module, exports) {



/***/ }),
/* 114 */
/***/ (function(module, exports, __nested_webpack_require_404894__) {

__nested_webpack_require_404894__(49)('asyncIterator');


/***/ }),
/* 115 */
/***/ (function(module, exports, __nested_webpack_require_405015__) {

__nested_webpack_require_405015__(49)('observable');


/***/ }),
/* 116 */
/***/ (function(module, exports, __nested_webpack_require_405133__) {

/* WEBPACK VAR INJECTION */(function(module) {var require;//! moment.js

;(function (global, factory) {
      true ? module.exports = factory() :
    0
}(this, (function () { 'use strict';

    var hookCallback;

    function hooks () {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }

    function isObject(input) {
        // IE8 will treat undefined and null as object if it wasn't for
        // input != null
        return input != null && Object.prototype.toString.call(input) === '[object Object]';
    }

    function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
            return (Object.getOwnPropertyNames(obj).length === 0);
        } else {
            var k;
            for (k in obj) {
                if (obj.hasOwnProperty(k)) {
                    return false;
                }
            }
            return true;
        }
    }

    function isUndefined(input) {
        return input === void 0;
    }

    function isNumber(input) {
        return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
    }

    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function createUTC (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty           : false,
            unusedTokens    : [],
            unusedInput     : [],
            overflow        : -2,
            charsLeftOver   : 0,
            nullInput       : false,
            invalidMonth    : null,
            invalidFormat   : false,
            userInvalidated : false,
            iso             : false,
            parsedDateParts : [],
            meridiem        : null,
            rfc2822         : false,
            weekdayMismatch : false
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this);
            var len = t.length >>> 0;

            for (var i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }

            return false;
        };
    }

    function isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            var parsedParts = some.call(flags.parsedDateParts, function (i) {
                return i != null;
            });
            var isNowValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.weekdayMismatch &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated &&
                (!flags.meridiem || (flags.meridiem && parsedParts));

            if (m._strict) {
                isNowValid = isNowValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }

            if (Object.isFrozen == null || !Object.isFrozen(m)) {
                m._isValid = isNowValid;
            }
            else {
                return isNowValid;
            }
        }
        return m._isValid;
    }

    function createInvalid (flags) {
        var m = createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        }
        else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i = 0; i < momentProperties.length; i++) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
            this._d = new Date(NaN);
        }
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment (obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }

    function absFloor (number) {
        if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false &&
                (typeof console !==  'undefined') && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                var args = [];
                var arg;
                for (var i = 0; i < arguments.length; i++) {
                    arg = '';
                    if (typeof arguments[i] === 'object') {
                        arg += '\n[' + i + '] ';
                        for (var key in arguments[0]) {
                            arg += key + ': ' + arguments[0][key] + ', ';
                        }
                        arg = arg.slice(0, -2); // Remove trailing comma and space
                    } else {
                        arg = arguments[i];
                    }
                    args.push(arg);
                }
                warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;

    function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    function set (config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (isFunction(prop)) {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
        // TODO: Remove "ordinalParse" fallback in next major release.
        this._dayOfMonthOrdinalParseLenient = new RegExp(
            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                '|' + (/\d{1,2}/).source);
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) &&
                    !hasOwnProp(childConfig, prop) &&
                    isObject(parentConfig[prop])) {
                // make sure changes to properties don't modify parent config
                res[prop] = extend({}, res[prop]);
            }
        }
        return res;
    }

    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }

    var keys;

    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i, res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }

    var defaultCalendar = {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    };

    function calendar (key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS  : 'h:mm:ss A',
        LT   : 'h:mm A',
        L    : 'MM/DD/YYYY',
        LL   : 'MMMM D, YYYY',
        LLL  : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat (key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
        });

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate () {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

    function ordinal (number) {
        return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
        future : 'in %s',
        past   : '%s ago',
        s  : 'a few seconds',
        ss : '%d seconds',
        m  : 'a minute',
        mm : '%d minutes',
        h  : 'an hour',
        hh : '%d hours',
        d  : 'a day',
        dd : '%d days',
        M  : 'a month',
        MM : '%d months',
        y  : 'a year',
        yy : '%d years'
    };

    function relativeTime (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (isFunction(output)) ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias (unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
        var units = [];
        for (var u in unitsObj) {
            units.push({unit: u, priority: priorities[u]});
        }
        units.sort(function (a, b) {
            return a.priority - b.priority;
        });
        return units;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '', i;
            for (i = 0; i < length; i++) {
                output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1         = /\d/;            //       0 - 9
    var match2         = /\d\d/;          //      00 - 99
    var match3         = /\d{3}/;         //     000 - 999
    var match4         = /\d{4}/;         //    0000 - 9999
    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2      = /\d\d?/;         //       0 - 99
    var match3to4      = /\d\d\d\d?/;     //     999 - 9999
    var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
    var match1to3      = /\d{1,3}/;       //       0 - 999
    var match1to4      = /\d{1,4}/;       //       0 - 9999
    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

    var matchUnsigned  = /\d+/;           //       0 - inf
    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months
    var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;

    var regexes = {};

    function addRegexToken (token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken (token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }));
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken (token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (isNumber(callback)) {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken (token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8;

    // FORMATTING

    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? '' + y : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY',   4],       0, 'year');
    addFormatToken(0, ['YYYYY',  5],       0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PRIORITIES

    addUnitPriority('year', 1);

    // PARSING

    addRegexToken('Y',      matchSigned);
    addRegexToken('YY',     match1to2, match2);
    addRegexToken('YYYY',   match1to4, match4);
    addRegexToken('YYYYY',  match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear () {
        return isLeapYear(this.year());
    }

    function makeGetSet (unit, keepTime) {
        return function (value) {
            if (value != null) {
                set$1(this, unit, value);
                hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get(this, unit);
            }
        };
    }

    function get (mom, unit) {
        return mom.isValid() ?
            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }

    function set$1 (mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
            if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
            }
            else {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
            }
        }
    }

    // MOMENTS

    function stringGet (units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }


    function stringSet (units, value) {
        if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units);
            for (var i = 0; i < prioritized.length; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    function mod(n, x) {
        return ((n % x) + x) % x;
    }

    var indexOf;

    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }

    function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
            return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PRIORITY

    addUnitPriority('month', 8);

    // PARSING

    addRegexToken('M',    match1to2);
    addRegexToken('MM',   match1to2, match2);
    addRegexToken('MMM',  function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths (m, format) {
        if (!m) {
            return isArray(this._months) ? this._months :
                this._months['standalone'];
        }
        return isArray(this._months) ? this._months[m.month()] :
            this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort (m, format) {
        if (!m) {
            return isArray(this._monthsShort) ? this._monthsShort :
                this._monthsShort['standalone'];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    function handleStrictParse(monthName, format, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeMonthsParse (monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth (mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
            // No op
            return mom;
        }

        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (!isNumber(value)) {
                    return mom;
                }
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth (value) {
        if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
        } else {
            return get(this, 'Month');
        }
    }

    function getDaysInMonth () {
        return daysInMonth(this.year(), this.month());
    }

    var defaultMonthsShortRegex = matchWord;
    function monthsShortRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ?
                this._monthsShortStrictRegex : this._monthsShortRegex;
        }
    }

    var defaultMonthsRegex = matchWord;
    function monthsRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ?
                this._monthsStrictRegex : this._monthsRegex;
        }
    }

    function computeMonthsParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    }

    function createDate (y, m, d, h, M, s, ms) {
        // can't just apply() to create a date:
        // https://stackoverflow.com/q/181348
        var date = new Date(y, m, d, h, M, s, ms);

        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
            date.setFullYear(y);
        }
        return date;
    }

    function createUTCDate (y) {
        var date = new Date(Date.UTC.apply(null, arguments));

        // the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear, resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek, resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5);

    // PARSING

    addRegexToken('w',  match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W',  match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // LOCALES

    function localeWeek (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    };

    function localeFirstDayOfWeek () {
        return this._week.dow;
    }

    function localeFirstDayOfYear () {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek (input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek (input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PRIORITY
    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11);

    // PARSING

    addRegexToken('d',    match1to2);
    addRegexToken('e',    match1to2);
    addRegexToken('E',    match1to2);
    addRegexToken('dd',   function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd',   function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd',   function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }

    // LOCALES

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays (m, format) {
        if (!m) {
            return isArray(this._weekdays) ? this._weekdays :
                this._weekdays['standalone'];
        }
        return isArray(this._weekdays) ? this._weekdays[m.day()] :
            this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort (m) {
        return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin (m) {
        return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }

    function handleStrictParse$1(weekdayName, format, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i < 7; ++i) {
                mom = createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeWeekdaysParse (weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
            }
            if (!this._weekdaysParse[i]) {
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }

        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.

        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }

    var defaultWeekdaysRegex = matchWord;
    function weekdaysRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ?
                this._weekdaysStrictRegex : this._weekdaysRegex;
        }
    }

    var defaultWeekdaysShortRegex = matchWord;
    function weekdaysShortRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ?
                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
    }

    var defaultWeekdaysMinRegex = matchWord;
    function weekdaysMinRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ?
                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
    }


    function computeWeekdaysParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, 1]).day(i);
            minp = this.weekdaysMin(mom, '');
            shortp = this.weekdaysShort(mom, '');
            longp = this.weekdays(mom, '');
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 7; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    function kFormat() {
        return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);

    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    function meridiem (token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PRIORITY
    addUnitPriority('hour', 13);

    // PARSING

    function matchMeridiem (isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a',  matchMeridiem);
    addRegexToken('A',  matchMeridiem);
    addRegexToken('H',  match1to2);
    addRegexToken('h',  match1to2);
    addRegexToken('k',  match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['k', 'kk'], function (input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM (input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour they want. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,

        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,

        week: defaultLocaleWeek,

        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,

        meridiemParse: defaultLocaleMeridiemParse
    };

    // internal storage for locale config files
    var locales = {};
    var localeFamilies = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return globalLocale;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && (typeof module !== 'undefined') &&
                module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                var aliasedRequire = require;
                !(function webpackMissingModule() { var e = new Error("Cannot find module \"./locale\""); e.code = 'MODULE_NOT_FOUND'; throw e; }());
                getSetGlobalLocale(oldLocale);
            } catch (e) {}
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function getSetGlobalLocale (key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
            else {
                if ((typeof console !==  'undefined') && console.warn) {
                    //warn user if arguments are passed but the locale could not be set
                    console.warn('Locale ' + key +  ' not found. Did you forget to load it?');
                }
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale (name, config) {
        if (config !== null) {
            var locale, parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple('defineLocaleOverride',
                        'use moment.updateLocale(localeName, config) to change ' +
                        'an existing locale. moment.defineLocale(localeName, ' +
                        'config) should only be used for creating a new locale ' +
                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    locale = loadLocale(config.parentLocale);
                    if (locale != null) {
                        parentConfig = locale._config;
                    } else {
                        if (!localeFamilies[config.parentLocale]) {
                            localeFamilies[config.parentLocale] = [];
                        }
                        localeFamilies[config.parentLocale].push({
                            name: name,
                            config: config
                        });
                        return null;
                    }
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));

            if (localeFamilies[name]) {
                localeFamilies[name].forEach(function (x) {
                    defineLocale(x.name, x.config);
                });
            }

            // backwards compat for now: also set the locale
            // make sure we set the locale AFTER all child locales have been
            // created, so we won't end up with the child locale set.
            getSetGlobalLocale(name);


            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    function updateLocale(name, config) {
        if (config != null) {
            var locale, tmpLocale, parentConfig = baseConfig;
            // MERGE
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
                parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            locale = new Locale(config);
            locale.parentLocale = locales[name];
            locales[name] = locale;

            // backwards compat for now: also set the locale
            getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }

    // returns locale data
    function getLocale (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    function listLocales() {
        return keys(locales);
    }

    function checkOverflow (m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray (config) {
        var i, date, input = [], currentDate, expectedWeekday, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();

        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }

        // check for mismatching day of week
        if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
            getParsingFlags(config).weekdayMismatch = true;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            var curWeek = weekOfYear(createLocal(), dow, doy);

            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

            // Default to current week.
            week = defaults(w.w, curWeek.week);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
        ['YYYY-DDD', /\d{4}-\d{3}/],
        ['YYYY-MM', /\d{4}-\d\d/, false],
        ['YYYYYYMMDD', /[+-]\d{10}/],
        ['YYYYMMDD', /\d{8}/],
        // YYYYMM is NOT allowed by the standard
        ['GGGG[W]WWE', /\d{4}W\d{3}/],
        ['GGGG[W]WW', /\d{4}W\d{2}/, false],
        ['YYYYDDD', /\d{7}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
        ['HH:mm:ss', /\d\d:\d\d:\d\d/],
        ['HH:mm', /\d\d:\d\d/],
        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
        ['HHmmss', /\d\d\d\d\d\d/],
        ['HHmm', /\d\d\d\d/],
        ['HH', /\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime, dateFormat, timeFormat, tzFormat;

        if (match) {
            getParsingFlags(config).iso = true;

            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10)
        ];

        if (secondStr) {
            result.push(parseInt(secondStr, 10));
        }

        return result;
    }

    function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
            return 2000 + year;
        } else if (year <= 999) {
            return 1900 + year;
        }
        return year;
    }

    function preprocessRFC2822(s) {
        // Remove comments and folding whitespace and replace multiple-spaces with a single space
        return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    }

    function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
            // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
            if (weekdayProvided !== weekdayActual) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return false;
            }
        }
        return true;
    }

    var obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
    };

    function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
            return obsOffsets[obsOffset];
        } else if (militaryOffset) {
            // the only allowed military tz is Z
            return 0;
        } else {
            var hm = parseInt(numOffset, 10);
            var m = hm % 100, h = (hm - m) / 100;
            return h * 60 + m;
        }
    }

    // date and time from ref 2822 format
    function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i));
        if (match) {
            var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
            if (!checkWeekday(match[1], parsedArray, config)) {
                return;
            }

            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);

            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

            getParsingFlags(config).rfc2822 = true;
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        configFromRFC2822(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        // Final attempt, use Input Fallback
        hooks.createFromInputFallback(config);
    }

    hooks.createFromInputFallback = deprecate(
        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
        'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
        'discouraged and will be removed in an upcoming major release. Please refer to ' +
        'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    // constant that refers to the ISO standard
    hooks.ISO_8601 = function () {};

    // constant that refers to the RFC 2822 form
    hooks.RFC_2822 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
        }
        if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            // console.log('token', token, 'parsedInput', parsedInput,
            //         'regex', getParseRegexForToken(token, config));
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                }
                else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (config._a[HOUR] <= 12 &&
            getParsingFlags(config).bigHour === true &&
            config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap (locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
            return obj && parseInt(obj, 10);
        });

        configFromArray(config);
    }

    function createFromConfig (config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig (config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return createInvalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
            config._d = input;
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        }  else {
            configFromInput(config);
        }

        if (!isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
            config._d = new Date(hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (isObject(input)) {
            configFromObject(config);
        } else if (isNumber(input)) {
            // from milliseconds
            config._d = new Date(input);
        } else {
            hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC (input, format, locale, strict, isUTC) {
        var c = {};

        if (locale === true || locale === false) {
            strict = locale;
            locale = undefined;
        }

        if ((isObject(input) && isObjectEmpty(input)) ||
                (isArray(input) && input.length === 0)) {
            input = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function createLocal (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
        'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other < this ? this : other;
            } else {
                return createInvalid();
            }
        }
    );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other > this ? this : other;
            } else {
                return createInvalid();
            }
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function () {
        return Date.now ? Date.now() : +(new Date());
    };

    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

    function isDurationValid(m) {
        for (var key in m) {
            if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
                return false;
            }
        }

        var unitHasDecimal = false;
        for (var i = 0; i < ordering.length; ++i) {
            if (m[ordering[i]]) {
                if (unitHasDecimal) {
                    return false; // only allow non-integers for smallest unit
                }
                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                    unitHasDecimal = true;
                }
            }
        }

        return true;
    }

    function isValid$1() {
        return this._isValid;
    }

    function createInvalid$1() {
        return createDuration(NaN);
    }

    function Duration (duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        this._isValid = isDurationValid(normalizedInput);

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible to translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = getLocale();

        this._bubble();
    }

    function isDuration (obj) {
        return obj instanceof Duration;
    }

    function absRound (number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }

    // FORMATTING

    function offset (token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z',  matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = (string || '').match(matcher);

        if (matches === null) {
            return null;
        }

        var chunk   = matches[matches.length - 1] || [];
        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return minutes === 0 ?
          0 :
          parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            hooks.updateOffset(res, false);
            return res;
        } else {
            return createLocal(input).local();
        }
    }

    function getDateOffset (m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset (input, keepLocalTime, keepMinutes) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
                if (input === null) {
                    return this;
                }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    addSubtract(this, createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone (input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal (keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset () {
        if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
                this.utcOffset(tZone);
            }
            else {
                this.utcOffset(0, true);
            }
        }
        return this;
    }

    function hasAlignedHourOffset (input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime () {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted () {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted = this.isValid() &&
                compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal () {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset () {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc () {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    // and further modified to allow for strings containing both week and day
    var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

    function createDuration (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms : input._milliseconds,
                d  : input._days,
                M  : input._months
            };
        } else if (isNumber(input)) {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y  : 0,
                d  : toInt(match[DATE])                         * sign,
                h  : toInt(match[HOUR])                         * sign,
                m  : toInt(match[MINUTE])                       * sign,
                s  : toInt(match[SECOND])                       * sign,
                ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
            };
        } else if (!!(match = isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : (match[1] === '+') ? 1 : 1;
            duration = {
                y : parseIso(match[2], sign),
                M : parseIso(match[3], sign),
                w : parseIso(match[4], sign),
                d : parseIso(match[5], sign),
                h : parseIso(match[6], sign),
                m : parseIso(match[7], sign),
                s : parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;

    function parseIso (inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {milliseconds: 0, months: 0};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return {milliseconds: 0, months: 0};
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
                'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
        };
    }

    function addSubtract (mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (months) {
            setMonth(mom, get(mom, 'Month') + months * isAdding);
        }
        if (days) {
            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
        }
        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (updateOffset) {
            hooks.updateOffset(mom, days || months);
        }
    }

    var add      = createAdder(1, 'add');
    var subtract = createAdder(-1, 'subtract');

    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';
    }

    function calendar$1 (time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = hooks.calendarFormat(this, sod) || 'sameElse';

        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
    }

    function clone () {
        return new Moment(this);
    }

    function isAfter (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }

    function isBefore (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }

    function isBetween (from, to, units, inclusivity) {
        inclusivity = inclusivity || '()';
        return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
            (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
    }

    function isSame (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units || 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
    }

    function isSameOrAfter (input, units) {
        return this.isSame(input, units) || this.isAfter(input,units);
    }

    function isSameOrBefore (input, units) {
        return this.isSame(input, units) || this.isBefore(input,units);
    }

    function diff (input, units, asFloat) {
        var that,
            zoneDelta,
            output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        switch (units) {
            case 'year': output = monthDiff(this, that) / 12; break;
            case 'month': output = monthDiff(this, that); break;
            case 'quarter': output = monthDiff(this, that) / 3; break;
            case 'second': output = (this - that) / 1e3; break; // 1000
            case 'minute': output = (this - that) / 6e4; break; // 1000 * 60
            case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60
            case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst
            case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst
            default: output = this - that;
        }

        return asFloat ? output : absFloor(output);
    }

    function monthDiff (a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
    }

    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function toISOString(keepOffset) {
        if (!this.isValid()) {
            return null;
        }
        var utc = keepOffset !== true;
        var m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
        }
        if (isFunction(Date.prototype.toISOString)) {
            // native implementation is ~50x faster, use it when we can
            if (utc) {
                return this.toDate().toISOString();
            } else {
                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
            }
        }
        return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
    }

    /**
     * Return a human readable representation of a moment that can
     * also be evaluated to get a new moment which is the same
     *
     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
     */
    function inspect () {
        if (!this.isValid()) {
            return 'moment.invalid(/* ' + this._i + ' */)';
        }
        var func = 'moment';
        var zone = '';
        if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
            zone = 'Z';
        }
        var prefix = '[' + func + '("]';
        var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
        var datetime = '-MM-DD[T]HH:mm:ss.SSS';
        var suffix = zone + '[")]';

        return this.format(prefix + year + datetime + suffix);
    }

    function format (inputString) {
        if (!inputString) {
            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }

    function from (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 createLocal(time).isValid())) {
            return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow (withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
    }

    function to (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 createLocal(time).isValid())) {
            return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow (withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale (key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData () {
        return this._locale;
    }

    function startOf (units) {
        units = normalizeUnits(units);
        // the following switch intentionally omits break keywords
        // to utilize falling through the cases.
        switch (units) {
            case 'year':
                this.month(0);
                /* falls through */
            case 'quarter':
            case 'month':
                this.date(1);
                /* falls through */
            case 'week':
            case 'isoWeek':
            case 'day':
            case 'date':
                this.hours(0);
                /* falls through */
            case 'hour':
                this.minutes(0);
                /* falls through */
            case 'minute':
                this.seconds(0);
                /* falls through */
            case 'second':
                this.milliseconds(0);
        }

        // weeks are a special case
        if (units === 'week') {
            this.weekday(0);
        }
        if (units === 'isoWeek') {
            this.isoWeekday(1);
        }

        // quarters are also special
        if (units === 'quarter') {
            this.month(Math.floor(this.month() / 3) * 3);
        }

        return this;
    }

    function endOf (units) {
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond') {
            return this;
        }

        // 'date' is an alias for 'day', so it should be considered as such.
        if (units === 'date') {
            units = 'day';
        }

        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
    }

    function valueOf () {
        return this._d.valueOf() - ((this._offset || 0) * 60000);
    }

    function unix () {
        return Math.floor(this.valueOf() / 1000);
    }

    function toDate () {
        return new Date(this.valueOf());
    }

    function toArray () {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject () {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }

    function toJSON () {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    function isValid$2 () {
        return isValid(this);
    }

    function parsingFlags () {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt () {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        };
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken (token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg',     'weekYear');
    addWeekYearFormatToken('ggggg',    'weekYear');
    addWeekYearFormatToken('GGGG',  'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1);


    // PARSING

    addRegexToken('G',      matchSigned);
    addRegexToken('g',      matchSigned);
    addRegexToken('GG',     match1to2, match2);
    addRegexToken('gg',     match1to2, match2);
    addRegexToken('GGGG',   match1to4, match4);
    addRegexToken('gggg',   match1to4, match4);
    addRegexToken('GGGGG',  match1to6, match6);
    addRegexToken('ggggg',  match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input,
                this.week(),
                this.weekday(),
                this.localeData()._week.dow,
                this.localeData()._week.doy);
    }

    function getSetISOWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }

    function getISOWeeksInYear () {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear () {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PRIORITY

    addUnitPriority('quarter', 7);

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter (input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PRIORITY
    addUnitPriority('date', 9);

    // PARSING

    addRegexToken('D',  match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        // TODO: Remove "ordinalParse" fallback in next major release.
        return isStrict ?
          (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
          locale._dayOfMonthOrdinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PRIORITY
    addUnitPriority('dayOfYear', 4);

    // PARSING

    addRegexToken('DDD',  match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PRIORITY

    addUnitPriority('minute', 14);

    // PARSING

    addRegexToken('m',  match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PRIORITY

    addUnitPriority('second', 15);

    // PARSING

    addRegexToken('s',  match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });


    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PRIORITY

    addUnitPriority('millisecond', 16);

    // PARSING

    addRegexToken('S',    match1to3, match1);
    addRegexToken('SS',   match1to3, match2);
    addRegexToken('SSS',  match1to3, match3);

    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z',  0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr () {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName () {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var proto = Moment.prototype;

    proto.add               = add;
    proto.calendar          = calendar$1;
    proto.clone             = clone;
    proto.diff              = diff;
    proto.endOf             = endOf;
    proto.format            = format;
    proto.from              = from;
    proto.fromNow           = fromNow;
    proto.to                = to;
    proto.toNow             = toNow;
    proto.get               = stringGet;
    proto.invalidAt         = invalidAt;
    proto.isAfter           = isAfter;
    proto.isBefore          = isBefore;
    proto.isBetween         = isBetween;
    proto.isSame            = isSame;
    proto.isSameOrAfter     = isSameOrAfter;
    proto.isSameOrBefore    = isSameOrBefore;
    proto.isValid           = isValid$2;
    proto.lang              = lang;
    proto.locale            = locale;
    proto.localeData        = localeData;
    proto.max               = prototypeMax;
    proto.min               = prototypeMin;
    proto.parsingFlags      = parsingFlags;
    proto.set               = stringSet;
    proto.startOf           = startOf;
    proto.subtract          = subtract;
    proto.toArray           = toArray;
    proto.toObject          = toObject;
    proto.toDate            = toDate;
    proto.toISOString       = toISOString;
    proto.inspect           = inspect;
    proto.toJSON            = toJSON;
    proto.toString          = toString;
    proto.unix              = unix;
    proto.valueOf           = valueOf;
    proto.creationData      = creationData;
    proto.year       = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear    = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month       = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week           = proto.weeks        = getSetWeek;
    proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
    proto.weeksInYear    = getWeeksInYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.date       = getSetDayOfMonth;
    proto.day        = proto.days             = getSetDayOfWeek;
    proto.weekday    = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear  = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset            = getSetOffset;
    proto.utc                  = setOffsetToUTC;
    proto.local                = setOffsetToLocal;
    proto.parseZone            = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST                = isDaylightSavingTime;
    proto.isLocal              = isLocal;
    proto.isUtcOffset          = isUtcOffset;
    proto.isUtc                = isUtc;
    proto.isUTC                = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
    proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

    function createUnix (input) {
        return createLocal(input * 1000);
    }

    function createInZone () {
        return createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat (string) {
        return string;
    }

    var proto$1 = Locale.prototype;

    proto$1.calendar        = calendar;
    proto$1.longDateFormat  = longDateFormat;
    proto$1.invalidDate     = invalidDate;
    proto$1.ordinal         = ordinal;
    proto$1.preparse        = preParsePostFormat;
    proto$1.postformat      = preParsePostFormat;
    proto$1.relativeTime    = relativeTime;
    proto$1.pastFuture      = pastFuture;
    proto$1.set             = set;

    proto$1.months            =        localeMonths;
    proto$1.monthsShort       =        localeMonthsShort;
    proto$1.monthsParse       =        localeMonthsParse;
    proto$1.monthsRegex       = monthsRegex;
    proto$1.monthsShortRegex  = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;

    proto$1.weekdays       =        localeWeekdays;
    proto$1.weekdaysMin    =        localeWeekdaysMin;
    proto$1.weekdaysShort  =        localeWeekdaysShort;
    proto$1.weekdaysParse  =        localeWeekdaysParse;

    proto$1.weekdaysRegex       =        weekdaysRegex;
    proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
    proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;

    function get$1 (format, index, field, setter) {
        var locale = getLocale();
        var utc = createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function listMonthsImpl (format, index, field) {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return get$1(format, index, field, 'month');
        }

        var i;
        var out = [];
        for (i = 0; i < 12; i++) {
            out[i] = get$1(format, i, field, 'month');
        }
        return out;
    }

    // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)
    function listWeekdaysImpl (localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        }

        var locale = getLocale(),
            shift = localeSorted ? locale._week.dow : 0;

        if (index != null) {
            return get$1(format, (index + shift) % 7, field, 'day');
        }

        var i;
        var out = [];
        for (i = 0; i < 7; i++) {
            out[i] = get$1(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }

    function listMonths (format, index) {
        return listMonthsImpl(format, index, 'months');
    }

    function listMonthsShort (format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }

    function listWeekdays (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function listWeekdaysShort (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function listWeekdaysMin (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    getSetGlobalLocale('en', {
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports

    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

    var mathAbs = Math.abs;

    function abs () {
        var data           = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days         = mathAbs(this._days);
        this._months       = mathAbs(this._months);

        data.milliseconds  = mathAbs(data.milliseconds);
        data.seconds       = mathAbs(data.seconds);
        data.minutes       = mathAbs(data.minutes);
        data.hours         = mathAbs(data.hours);
        data.months        = mathAbs(data.months);
        data.years         = mathAbs(data.years);

        return this;
    }

    function addSubtract$1 (duration, input, value, direction) {
        var other = createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days         += direction * other._days;
        duration._months       += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function add$1 (input, value) {
        return addSubtract$1(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function subtract$1 (input, value) {
        return addSubtract$1(this, input, value, -1);
    }

    function absCeil (number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble () {
        var milliseconds = this._milliseconds;
        var days         = this._days;
        var months       = this._months;
        var data         = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds           = absFloor(milliseconds / 1000);
        data.seconds      = seconds % 60;

        minutes           = absFloor(seconds / 60);
        data.minutes      = minutes % 60;

        hours             = absFloor(minutes / 60);
        data.hours        = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days   = days;
        data.months = months;
        data.years  = years;

        return this;
    }

    function daysToMonths (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }

    function monthsToDays (months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }

    function as (units) {
        if (!this.isValid()) {
            return NaN;
        }
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'year') {
            days   = this._days   + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            return units === 'month' ? months : months / 12;
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week'   : return days / 7     + milliseconds / 6048e5;
                case 'day'    : return days         + milliseconds / 864e5;
                case 'hour'   : return days * 24    + milliseconds / 36e5;
                case 'minute' : return days * 1440  + milliseconds / 6e4;
                case 'second' : return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function valueOf$1 () {
        if (!this.isValid()) {
            return NaN;
        }
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs (alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds      = makeAs('s');
    var asMinutes      = makeAs('m');
    var asHours        = makeAs('h');
    var asDays         = makeAs('d');
    var asWeeks        = makeAs('w');
    var asMonths       = makeAs('M');
    var asYears        = makeAs('y');

    function clone$1 () {
        return createDuration(this);
    }

    function get$2 (units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + 's']() : NaN;
    }

    function makeGetter(name) {
        return function () {
            return this.isValid() ? this._data[name] : NaN;
        };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds      = makeGetter('seconds');
    var minutes      = makeGetter('minutes');
    var hours        = makeGetter('hours');
    var days         = makeGetter('days');
    var months       = makeGetter('months');
    var years        = makeGetter('years');

    function weeks () {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        ss: 44,         // a few seconds to seconds
        s : 45,         // seconds to minute
        m : 45,         // minutes to hour
        h : 22,         // hours to day
        d : 26,         // days to month
        M : 11          // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
        var duration = createDuration(posNegDuration).abs();
        var seconds  = round(duration.as('s'));
        var minutes  = round(duration.as('m'));
        var hours    = round(duration.as('h'));
        var days     = round(duration.as('d'));
        var months   = round(duration.as('M'));
        var years    = round(duration.as('y'));

        var a = seconds <= thresholds.ss && ['s', seconds]  ||
                seconds < thresholds.s   && ['ss', seconds] ||
                minutes <= 1             && ['m']           ||
                minutes < thresholds.m   && ['mm', minutes] ||
                hours   <= 1             && ['h']           ||
                hours   < thresholds.h   && ['hh', hours]   ||
                days    <= 1             && ['d']           ||
                days    < thresholds.d   && ['dd', days]    ||
                months  <= 1             && ['M']           ||
                months  < thresholds.M   && ['MM', months]  ||
                years   <= 1             && ['y']           || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set the rounding function for relative time strings
    function getSetRelativeTimeRounding (roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof(roundingFunction) === 'function') {
            round = roundingFunction;
            return true;
        }
        return false;
    }

    // This function allows you to set a threshold for relative time strings
    function getSetRelativeTimeThreshold (threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === 's') {
            thresholds.ss = limit - 1;
        }
        return true;
    }

    function humanize (withSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var locale = this.localeData();
        var output = relativeTime$1(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var abs$1 = Math.abs;

    function sign(x) {
        return ((x > 0) - (x < 0)) || +x;
    }

    function toISOString$1() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var seconds = abs$1(this._milliseconds) / 1000;
        var days         = abs$1(this._days);
        var months       = abs$1(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes           = absFloor(seconds / 60);
        hours             = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years  = absFloor(months / 12);
        months %= 12;


        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        var totalSign = total < 0 ? '-' : '';
        var ymSign = sign(this._months) !== sign(total) ? '-' : '';
        var daysSign = sign(this._days) !== sign(total) ? '-' : '';
        var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

        return totalSign + 'P' +
            (Y ? ymSign + Y + 'Y' : '') +
            (M ? ymSign + M + 'M' : '') +
            (D ? daysSign + D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? hmsSign + h + 'H' : '') +
            (m ? hmsSign + m + 'M' : '') +
            (s ? hmsSign + s + 'S' : '');
    }

    var proto$2 = Duration.prototype;

    proto$2.isValid        = isValid$1;
    proto$2.abs            = abs;
    proto$2.add            = add$1;
    proto$2.subtract       = subtract$1;
    proto$2.as             = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds      = asSeconds;
    proto$2.asMinutes      = asMinutes;
    proto$2.asHours        = asHours;
    proto$2.asDays         = asDays;
    proto$2.asWeeks        = asWeeks;
    proto$2.asMonths       = asMonths;
    proto$2.asYears        = asYears;
    proto$2.valueOf        = valueOf$1;
    proto$2._bubble        = bubble;
    proto$2.clone          = clone$1;
    proto$2.get            = get$2;
    proto$2.milliseconds   = milliseconds;
    proto$2.seconds        = seconds;
    proto$2.minutes        = minutes;
    proto$2.hours          = hours;
    proto$2.days           = days;
    proto$2.weeks          = weeks;
    proto$2.months         = months;
    proto$2.years          = years;
    proto$2.humanize       = humanize;
    proto$2.toISOString    = toISOString$1;
    proto$2.toString       = toISOString$1;
    proto$2.toJSON         = toISOString$1;
    proto$2.locale         = locale;
    proto$2.localeData     = localeData;

    proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
    proto$2.lang = lang;

    // Side effect imports

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports


    hooks.version = '2.22.2';

    setHookCallback(createLocal);

    hooks.fn                    = proto;
    hooks.min                   = min;
    hooks.max                   = max;
    hooks.now                   = now;
    hooks.utc                   = createUTC;
    hooks.unix                  = createUnix;
    hooks.months                = listMonths;
    hooks.isDate                = isDate;
    hooks.locale                = getSetGlobalLocale;
    hooks.invalid               = createInvalid;
    hooks.duration              = createDuration;
    hooks.isMoment              = isMoment;
    hooks.weekdays              = listWeekdays;
    hooks.parseZone             = createInZone;
    hooks.localeData            = getLocale;
    hooks.isDuration            = isDuration;
    hooks.monthsShort           = listMonthsShort;
    hooks.weekdaysMin           = listWeekdaysMin;
    hooks.defineLocale          = defineLocale;
    hooks.updateLocale          = updateLocale;
    hooks.locales               = listLocales;
    hooks.weekdaysShort         = listWeekdaysShort;
    hooks.normalizeUnits        = normalizeUnits;
    hooks.relativeTimeRounding  = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat        = getCalendarFormat;
    hooks.prototype             = proto;

    // currently HTML5 input type only supports 24-hour formats
    hooks.HTML5_FMT = {
        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type="datetime-local" step="0.001" />
        DATE: 'YYYY-MM-DD',                             // <input type="date" />
        TIME: 'HH:mm',                                  // <input type="time" />
        TIME_SECONDS: 'HH:mm:ss',                       // <input type="time" step="1" />
        TIME_MS: 'HH:mm:ss.SSS',                        // <input type="time" step="0.001" />
        WEEK: 'YYYY-[W]WW',                             // <input type="week" />
        MONTH: 'YYYY-MM'                                // <input type="month" />
    };

    return hooks;

})));

/* WEBPACK VAR INJECTION */}.call(exports, __nested_webpack_require_405133__(117)(module)))

/***/ }),
/* 117 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 118 */
/***/ (function(module, exports) {

function webpackEmptyContext(req) {
	throw new Error("Cannot find module '" + req + "'.");
}
webpackEmptyContext.keys = function() { return []; };
webpackEmptyContext.resolve = webpackEmptyContext;
module.exports = webpackEmptyContext;
webpackEmptyContext.id = 118;

/***/ }),
/* 119 */
/***/ (function(module, exports, __nested_webpack_require_553149__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

/* eslint-disable require-jsdoc */

var _rng;

var globalVar = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : null;

if (globalVar && globalVar.crypto && crypto.getRandomValues) {
  // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
  // Moderately fast, high quality
  var _rnds8 = new Uint8Array(16);
  _rng = function whatwgRNG() {
    crypto.getRandomValues(_rnds8);
    return _rnds8;
  };
}

if (!_rng) {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var _rnds = new Array(16);
  _rng = function _rng() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return _rnds;
  };
}

//     uuid.js
//
//     Copyright (c) 2010-2012 Robert Kieffer
//     MIT License - http://opensource.org/licenses/mit-license.php

// Unique ID creation requires a high quality random # generator.  We feature
// detect to determine the best RNG source, normalizing to a function that
// returns 128-bits of randomness, since that's what's usually required

//var _rng = require('./rng');

// Maps for number <-> hex string conversion
var _byteToHex = [];
var _hexToByte = {};
for (var i = 0; i < 256; i++) {
  _byteToHex[i] = (i + 0x100).toString(16).substr(1);
  _hexToByte[_byteToHex[i]] = i;
}

// **`parse()` - Parse a UUID into it's component bytes**
function parse(s, buf, offset) {
  var i = buf && offset || 0,
      ii = 0;

  buf = buf || [];
  s.toLowerCase().replace(/[0-9a-f]{2}/g, function (oct) {
    if (ii < 16) {
      // Don't overflow!
      buf[i + ii++] = _hexToByte[oct];
    }
  });

  // Zero out remaining bytes if string was short
  while (ii < 16) {
    buf[i + ii++] = 0;
  }

  return buf;
}

// **`unparse()` - Convert UUID byte array (ala parse()) into a string**
function unparse(buf, offset) {
  var i = offset || 0,
      bth = _byteToHex;
  return bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]];
}

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

// random #'s we need to init node and clockseq
var _seedBytes = _rng();

// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
var _nodeId = [_seedBytes[0] | 0x01, _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]];

// Per 4.2.2, randomize (14 bit) clockseq
var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

// Previous uuid creation time
var _lastMSecs = 0,
    _lastNSecs = 0;

// See https://github.com/broofa/node-uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};

  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  var node = options.node || _nodeId;
  for (var n = 0; n < 6; n++) {
    b[i + n] = node[n];
  }

  return buf ? buf : unparse(b);
}

// **`v4()` - Generate random UUID**

// See https://github.com/broofa/node-uuid for API details
function v4(options, buf, offset) {
  // Deprecated - 'format' argument, as supported in v1.2
  var i = buf && offset || 0;

  if (typeof options == 'string') {
    buf = options == 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || _rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ii++) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || unparse(rnds);
}

// Export public API
var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;
uuid.parse = parse;
uuid.unparse = unparse;

module.exports = uuid;
/* WEBPACK VAR INJECTION */}.call(exports, __nested_webpack_require_553149__(120)))

/***/ }),
/* 120 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 121 */
/***/ (function(module, exports, __nested_webpack_require_559973__) {

"use strict";


// utils
exports.util = __nested_webpack_require_559973__(2);
exports.DOMutil = __nested_webpack_require_559973__(122);

// data
exports.DataSet = __nested_webpack_require_559973__(33);
exports.DataView = __nested_webpack_require_559973__(51);
exports.Queue = __nested_webpack_require_559973__(72);

// Network
exports.Network = __nested_webpack_require_559973__(124);
exports.network = {
  Images: __nested_webpack_require_559973__(76),
  dotparser: __nested_webpack_require_559973__(74),
  gephiParser: __nested_webpack_require_559973__(75),
  allOptions: __nested_webpack_require_559973__(84)
};
exports.network.convertDot = function (input) {
  return exports.network.dotparser.DOTToGraph(input);
};
exports.network.convertGephi = function (input, options) {
  return exports.network.gephiParser.parseGephi(input, options);
};

// bundled external libraries
exports.moment = __nested_webpack_require_559973__(71);
exports.Hammer = __nested_webpack_require_559973__(24);
exports.keycharm = __nested_webpack_require_559973__(52);

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// DOM utility methods

/**
 * this prepares the JSON container for allocating SVG elements
 * @param {Object} JSONcontainer
 * @private
 */
exports.prepareElements = function (JSONcontainer) {
  // cleanup the redundant svgElements;
  for (var elementType in JSONcontainer) {
    if (JSONcontainer.hasOwnProperty(elementType)) {
      JSONcontainer[elementType].redundant = JSONcontainer[elementType].used;
      JSONcontainer[elementType].used = [];
    }
  }
};

/**
 * this cleans up all the unused SVG elements. By asking for the parentNode, we only need to supply the JSON container from
 * which to remove the redundant elements.
 *
 * @param {Object} JSONcontainer
 * @private
 */
exports.cleanupElements = function (JSONcontainer) {
  // cleanup the redundant svgElements;
  for (var elementType in JSONcontainer) {
    if (JSONcontainer.hasOwnProperty(elementType)) {
      if (JSONcontainer[elementType].redundant) {
        for (var i = 0; i < JSONcontainer[elementType].redundant.length; i++) {
          JSONcontainer[elementType].redundant[i].parentNode.removeChild(JSONcontainer[elementType].redundant[i]);
        }
        JSONcontainer[elementType].redundant = [];
      }
    }
  }
};

/**
 * Ensures that all elements are removed first up so they can be recreated cleanly
 * @param {Object} JSONcontainer
 */
exports.resetElements = function (JSONcontainer) {
  exports.prepareElements(JSONcontainer);
  exports.cleanupElements(JSONcontainer);
  exports.prepareElements(JSONcontainer);
};

/**
 * Allocate or generate an SVG element if needed. Store a reference to it in the JSON container and draw it in the svgContainer
 * the JSON container and the SVG container have to be supplied so other svg containers (like the legend) can use this.
 *
 * @param {string} elementType
 * @param {Object} JSONcontainer
 * @param {Object} svgContainer
 * @returns {Element}
 * @private
 */
exports.getSVGElement = function (elementType, JSONcontainer, svgContainer) {
  var element;
  // allocate SVG element, if it doesnt yet exist, create one.
  if (JSONcontainer.hasOwnProperty(elementType)) {
    // this element has been created before
    // check if there is an redundant element
    if (JSONcontainer[elementType].redundant.length > 0) {
      element = JSONcontainer[elementType].redundant[0];
      JSONcontainer[elementType].redundant.shift();
    } else {
      // create a new element and add it to the SVG
      element = document.createElementNS('http://www.w3.org/2000/svg', elementType);
      svgContainer.appendChild(element);
    }
  } else {
    // create a new element and add it to the SVG, also create a new object in the svgElements to keep track of it.
    element = document.createElementNS('http://www.w3.org/2000/svg', elementType);
    JSONcontainer[elementType] = { used: [], redundant: [] };
    svgContainer.appendChild(element);
  }
  JSONcontainer[elementType].used.push(element);
  return element;
};

/**
 * Allocate or generate an SVG element if needed. Store a reference to it in the JSON container and draw it in the svgContainer
 * the JSON container and the SVG container have to be supplied so other svg containers (like the legend) can use this.
 *
 * @param {string} elementType
 * @param {Object} JSONcontainer
 * @param {Element} DOMContainer
 * @param {Element} insertBefore
 * @returns {*}
 */
exports.getDOMElement = function (elementType, JSONcontainer, DOMContainer, insertBefore) {
  var element;
  // allocate DOM element, if it doesnt yet exist, create one.
  if (JSONcontainer.hasOwnProperty(elementType)) {
    // this element has been created before
    // check if there is an redundant element
    if (JSONcontainer[elementType].redundant.length > 0) {
      element = JSONcontainer[elementType].redundant[0];
      JSONcontainer[elementType].redundant.shift();
    } else {
      // create a new element and add it to the SVG
      element = document.createElement(elementType);
      if (insertBefore !== undefined) {
        DOMContainer.insertBefore(element, insertBefore);
      } else {
        DOMContainer.appendChild(element);
      }
    }
  } else {
    // create a new element and add it to the SVG, also create a new object in the svgElements to keep track of it.
    element = document.createElement(elementType);
    JSONcontainer[elementType] = { used: [], redundant: [] };
    if (insertBefore !== undefined) {
      DOMContainer.insertBefore(element, insertBefore);
    } else {
      DOMContainer.appendChild(element);
    }
  }
  JSONcontainer[elementType].used.push(element);
  return element;
};

/**
 * Draw a point object. This is a separate function because it can also be called by the legend.
 * The reason the JSONcontainer and the target SVG svgContainer have to be supplied is so the legend can use these functions
 * as well.
 *
 * @param {number} x
 * @param {number} y
 * @param {Object} groupTemplate: A template containing the necessary information to draw the datapoint e.g., {style: 'circle', size: 5, className: 'className' }
 * @param {Object} JSONcontainer
 * @param {Object} svgContainer
 * @param {Object} labelObj
 * @returns {vis.PointItem}
 */
exports.drawPoint = function (x, y, groupTemplate, JSONcontainer, svgContainer, labelObj) {
  var point;
  if (groupTemplate.style == 'circle') {
    point = exports.getSVGElement('circle', JSONcontainer, svgContainer);
    point.setAttributeNS(null, 'cx', x);
    point.setAttributeNS(null, 'cy', y);
    point.setAttributeNS(null, 'r', 0.5 * groupTemplate.size);
  } else {
    point = exports.getSVGElement('rect', JSONcontainer, svgContainer);
    point.setAttributeNS(null, 'x', x - 0.5 * groupTemplate.size);
    point.setAttributeNS(null, 'y', y - 0.5 * groupTemplate.size);
    point.setAttributeNS(null, 'width', groupTemplate.size);
    point.setAttributeNS(null, 'height', groupTemplate.size);
  }

  if (groupTemplate.styles !== undefined) {
    point.setAttributeNS(null, 'style', groupTemplate.styles);
  }
  point.setAttributeNS(null, 'class', groupTemplate.className + ' vis-point');
  //handle label

  if (labelObj) {
    var label = exports.getSVGElement('text', JSONcontainer, svgContainer);
    if (labelObj.xOffset) {
      x = x + labelObj.xOffset;
    }

    if (labelObj.yOffset) {
      y = y + labelObj.yOffset;
    }
    if (labelObj.content) {
      label.textContent = labelObj.content;
    }

    if (labelObj.className) {
      label.setAttributeNS(null, 'class', labelObj.className + ' vis-label');
    }
    label.setAttributeNS(null, 'x', x);
    label.setAttributeNS(null, 'y', y);
  }

  return point;
};

/**
 * draw a bar SVG element centered on the X coordinate
 *
 * @param {number} x
 * @param {number} y
 * @param {number} width
 * @param {number} height
 * @param {string} className
 * @param {Object} JSONcontainer
 * @param {Object} svgContainer
 * @param {string} style
 */
exports.drawBar = function (x, y, width, height, className, JSONcontainer, svgContainer, style) {
  if (height != 0) {
    if (height < 0) {
      height *= -1;
      y -= height;
    }
    var rect = exports.getSVGElement('rect', JSONcontainer, svgContainer);
    rect.setAttributeNS(null, 'x', x - 0.5 * width);
    rect.setAttributeNS(null, 'y', y);
    rect.setAttributeNS(null, 'width', width);
    rect.setAttributeNS(null, 'height', height);
    rect.setAttributeNS(null, 'class', className);
    if (style) {
      rect.setAttributeNS(null, 'style', style);
    }
  }
};

/***/ }),
/* 123 */
/***/ (function(module, exports, __nested_webpack_require_568470__) {

var core = __nested_webpack_require_568470__(6);
var $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify });
module.exports = function stringify(it) { // eslint-disable-line no-unused-vars
  return $JSON.stringify.apply($JSON, arguments);
};


/***/ }),
/* 124 */
/***/ (function(module, exports, __nested_webpack_require_568787__) {

"use strict";


// Load custom shapes into CanvasRenderingContext2D
__nested_webpack_require_568787__(125);

var Emitter = __nested_webpack_require_568787__(73);
var util = __nested_webpack_require_568787__(2);
var dotparser = __nested_webpack_require_568787__(74);
var gephiParser = __nested_webpack_require_568787__(75);
var Activator = __nested_webpack_require_568787__(126);
var locales = __nested_webpack_require_568787__(129);

var Images = __nested_webpack_require_568787__(76)['default'];
var Groups = __nested_webpack_require_568787__(134)['default'];
var NodesHandler = __nested_webpack_require_568787__(135)['default'];
var EdgesHandler = __nested_webpack_require_568787__(165)['default'];
var PhysicsEngine = __nested_webpack_require_568787__(171)['default'];
var ClusterEngine = __nested_webpack_require_568787__(178)['default'];
var CanvasRenderer = __nested_webpack_require_568787__(180)['default'];
var Canvas = __nested_webpack_require_568787__(181)['default'];
var View = __nested_webpack_require_568787__(182)['default'];
var InteractionHandler = __nested_webpack_require_568787__(183)['default'];
var SelectionHandler = __nested_webpack_require_568787__(186)['default'];
var LayoutEngine = __nested_webpack_require_568787__(187)['default'];
var ManipulationSystem = __nested_webpack_require_568787__(190)['default'];
var Configurator = __nested_webpack_require_568787__(191)['default'];
var Validator = __nested_webpack_require_568787__(54)['default'];

var _require = __nested_webpack_require_568787__(54),
    printStyle = _require.printStyle;

var _require2 = __nested_webpack_require_568787__(84),
    allOptions = _require2.allOptions,
    configureOptions = _require2.configureOptions;

var KamadaKawai = __nested_webpack_require_568787__(193)['default'];

/**
 * Create a network visualization, displaying nodes and edges.
 *
 * @param {Element} container   The DOM element in which the Network will
 *                                  be created. Normally a div element.
 * @param {Object} data         An object containing parameters
 *                              {Array} nodes
 *                              {Array} edges
 * @param {Object} options      Options
 * @constructor Network
 */
function Network(container, data, options) {
  var _this = this;

  if (!(this instanceof Network)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  // set constant values
  this.options = {};
  this.defaultOptions = {
    locale: 'en',
    locales: locales,
    clickToUse: false
  };
  util.extend(this.options, this.defaultOptions);

  /**
   * Containers for nodes and edges.
   *
   * 'edges' and 'nodes' contain the full definitions of all the network elements.
   * 'nodeIndices' and 'edgeIndices' contain the id's of the active elements.
   *
   * The distinction is important, because a defined node need not be active, i.e.
   * visible on the canvas. This happens in particular when clusters are defined, in
   * that case there will be nodes and edges not displayed.
   * The bottom line is that all code with actions related to visibility, *must* use
   * 'nodeIndices' and 'edgeIndices', not 'nodes' and 'edges' directly.
   */
  this.body = {
    container: container,

    // See comment above for following fields
    nodes: {},
    nodeIndices: [],
    edges: {},
    edgeIndices: [],

    emitter: {
      on: this.on.bind(this),
      off: this.off.bind(this),
      emit: this.emit.bind(this),
      once: this.once.bind(this)
    },
    eventListeners: {
      onTap: function onTap() {},
      onTouch: function onTouch() {},
      onDoubleTap: function onDoubleTap() {},
      onHold: function onHold() {},
      onDragStart: function onDragStart() {},
      onDrag: function onDrag() {},
      onDragEnd: function onDragEnd() {},
      onMouseWheel: function onMouseWheel() {},
      onPinch: function onPinch() {},
      onMouseMove: function onMouseMove() {},
      onRelease: function onRelease() {},
      onContext: function onContext() {}
    },
    data: {
      nodes: null, // A DataSet or DataView
      edges: null // A DataSet or DataView
    },
    functions: {
      createNode: function createNode() {},
      createEdge: function createEdge() {},
      getPointer: function getPointer() {}
    },
    modules: {},
    view: {
      scale: 1,
      translation: { x: 0, y: 0 }
    }

    // bind the event listeners
  };this.bindEventListeners();

  // setting up all modules
  this.images = new Images(function () {
    return _this.body.emitter.emit('_requestRedraw');
  }); // object with images
  this.groups = new Groups(); // object with groups
  this.canvas = new Canvas(this.body); // DOM handler
  this.selectionHandler = new SelectionHandler(this.body, this.canvas); // Selection handler
  this.interactionHandler = new InteractionHandler(this.body, this.canvas, this.selectionHandler); // Interaction handler handles all the hammer bindings (that are bound by canvas), key
  this.view = new View(this.body, this.canvas); // camera handler, does animations and zooms
  this.renderer = new CanvasRenderer(this.body, this.canvas); // renderer, starts renderloop, has events that modules can hook into
  this.physics = new PhysicsEngine(this.body); // physics engine, does all the simulations
  this.layoutEngine = new LayoutEngine(this.body); // layout engine for inital layout and hierarchical layout
  this.clustering = new ClusterEngine(this.body); // clustering api
  this.manipulation = new ManipulationSystem(this.body, this.canvas, this.selectionHandler); // data manipulation system

  this.nodesHandler = new NodesHandler(this.body, this.images, this.groups, this.layoutEngine); // Handle adding, deleting and updating of nodes as well as global options
  this.edgesHandler = new EdgesHandler(this.body, this.images, this.groups); // Handle adding, deleting and updating of edges as well as global options

  this.body.modules['kamadaKawai'] = new KamadaKawai(this.body, 150, 0.05); // Layouting algorithm.
  this.body.modules['clustering'] = this.clustering;

  // create the DOM elements
  this.canvas._create();

  // apply options
  this.setOptions(options);

  // load data (the disable start variable will be the same as the enabled clustering)
  this.setData(data);
}

// Extend Network with an Emitter mixin
Emitter(Network.prototype);

/**
 * Set options
 * @param {Object} options
 */
Network.prototype.setOptions = function (options) {
  var _this2 = this;

  if (options === null) {
    options = undefined; // This ensures that options handling doesn't crash in the handling
  }

  if (options !== undefined) {
    var errorFound = Validator.validate(options, allOptions);
    if (errorFound === true) {
      console.log('%cErrors have been found in the supplied options object.', printStyle);
    }

    // copy the global fields over
    var fields = ['locale', 'locales', 'clickToUse'];
    util.selectiveDeepExtend(fields, this.options, options);

    // the hierarchical system can adapt the edges and the physics to it's own options because not all combinations work with the hierarichical system.
    options = this.layoutEngine.setOptions(options.layout, options);

    this.canvas.setOptions(options); // options for canvas are in globals

    // pass the options to the modules
    this.groups.setOptions(options.groups);
    this.nodesHandler.setOptions(options.nodes);
    this.edgesHandler.setOptions(options.edges);
    this.physics.setOptions(options.physics);
    this.manipulation.setOptions(options.manipulation, options, this.options); // manipulation uses the locales in the globals

    this.interactionHandler.setOptions(options.interaction);
    this.renderer.setOptions(options.interaction); // options for rendering are in interaction
    this.selectionHandler.setOptions(options.interaction); // options for selection are in interaction

    // reload the settings of the nodes to apply changes in groups that are not referenced by pointer.
    if (options.groups !== undefined) {
      this.body.emitter.emit('refreshNodes');
    }
    // these two do not have options at the moment, here for completeness
    //this.view.setOptions(options.view);
    //this.clustering.setOptions(options.clustering);

    if ('configure' in options) {
      if (!this.configurator) {
        this.configurator = new Configurator(this, this.body.container, configureOptions, this.canvas.pixelRatio);
      }

      this.configurator.setOptions(options.configure);
    }

    // if the configuration system is enabled, copy all options and put them into the config system
    if (this.configurator && this.configurator.options.enabled === true) {
      var networkOptions = {
        nodes: {},
        edges: {},
        layout: {},
        interaction: {},
        manipulation: {},
        physics: {},
        global: {}
      };
      util.deepExtend(networkOptions.nodes, this.nodesHandler.options);
      util.deepExtend(networkOptions.edges, this.edgesHandler.options);
      util.deepExtend(networkOptions.layout, this.layoutEngine.options);
      // load the selectionHandler and render default options in to the interaction group
      util.deepExtend(networkOptions.interaction, this.selectionHandler.options);
      util.deepExtend(networkOptions.interaction, this.renderer.options);

      util.deepExtend(networkOptions.interaction, this.interactionHandler.options);
      util.deepExtend(networkOptions.manipulation, this.manipulation.options);
      util.deepExtend(networkOptions.physics, this.physics.options);

      // load globals into the global object
      util.deepExtend(networkOptions.global, this.canvas.options);
      util.deepExtend(networkOptions.global, this.options);

      this.configurator.setModuleOptions(networkOptions);
    }

    // handle network global options
    if (options.clickToUse !== undefined) {
      if (options.clickToUse === true) {
        if (this.activator === undefined) {
          this.activator = new Activator(this.canvas.frame);
          this.activator.on('change', function () {
            _this2.body.emitter.emit('activate');
          });
        }
      } else {
        if (this.activator !== undefined) {
          this.activator.destroy();
          delete this.activator;
        }
        this.body.emitter.emit('activate');
      }
    } else {
      this.body.emitter.emit('activate');
    }

    this.canvas.setSize();
    // start the physics simulation. Can be safely called multiple times.
    this.body.emitter.emit('startSimulation');
  }
};

/**
 * Update the visible nodes and edges list with the most recent node state.
 *
 * Visible nodes are stored in this.body.nodeIndices.
 * Visible edges are stored in this.body.edgeIndices.
 * A node or edges is visible if it is not hidden or clustered.
 *
 * @private
 */
Network.prototype._updateVisibleIndices = function () {
  var nodes = this.body.nodes;
  var edges = this.body.edges;
  this.body.nodeIndices = [];
  this.body.edgeIndices = [];

  for (var nodeId in nodes) {
    if (nodes.hasOwnProperty(nodeId)) {
      if (!this.clustering._isClusteredNode(nodeId) && nodes[nodeId].options.hidden === false) {
        this.body.nodeIndices.push(nodes[nodeId].id);
      }
    }
  }

  for (var edgeId in edges) {
    if (edges.hasOwnProperty(edgeId)) {
      var edge = edges[edgeId];

      // It can happen that this is executed *after* a node edge has been removed,
      // but *before* the edge itself has been removed. Taking this into account.
      var fromNode = nodes[edge.fromId];
      var toNode = nodes[edge.toId];
      var edgeNodesPresent = fromNode !== undefined && toNode !== undefined;

      var isVisible = !this.clustering._isClusteredEdge(edgeId) && edge.options.hidden === false && edgeNodesPresent && fromNode.options.hidden === false && // Also hidden if any of its connecting nodes are hidden
      toNode.options.hidden === false; // idem

      if (isVisible) {
        this.body.edgeIndices.push(edge.id);
      }
    }
  }
};

/**
 * Bind all events
 */
Network.prototype.bindEventListeners = function () {
  var _this3 = this;

  // This event will trigger a rebuilding of the cache everything.
  // Used when nodes or edges have been added or removed.
  this.body.emitter.on('_dataChanged', function () {
    _this3.edgesHandler._updateState();
    _this3.body.emitter.emit('_dataUpdated');
  });

  // this is called when options of EXISTING nodes or edges have changed.
  this.body.emitter.on('_dataUpdated', function () {
    // Order important in following block
    _this3.clustering._updateState();
    _this3._updateVisibleIndices();

    _this3._updateValueRange(_this3.body.nodes);
    _this3._updateValueRange(_this3.body.edges);
    // start simulation (can be called safely, even if already running)
    _this3.body.emitter.emit('startSimulation');
    _this3.body.emitter.emit('_requestRedraw');
  });
};

/**
 * Set nodes and edges, and optionally options as well.
 *
 * @param {Object} data              Object containing parameters:
 *                                   {Array | DataSet | DataView} [nodes] Array with nodes
 *                                   {Array | DataSet | DataView} [edges] Array with edges
 *                                   {String} [dot] String containing data in DOT format
 *                                   {String} [gephi] String containing data in gephi JSON format
 *                                   {Options} [options] Object with options
 */
Network.prototype.setData = function (data) {
  // reset the physics engine.
  this.body.emitter.emit('resetPhysics');
  this.body.emitter.emit('_resetData');

  // unselect all to ensure no selections from old data are carried over.
  this.selectionHandler.unselectAll();

  if (data && data.dot && (data.nodes || data.edges)) {
    throw new SyntaxError('Data must contain either parameter "dot" or ' + ' parameter pair "nodes" and "edges", but not both.');
  }

  // set options
  this.setOptions(data && data.options);
  // set all data
  if (data && data.dot) {
    console.log('The dot property has been deprecated. Please use the static convertDot method to convert DOT into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertDot(dotString);');
    // parse DOT file
    var dotData = dotparser.DOTToGraph(data.dot);
    this.setData(dotData);
    return;
  } else if (data && data.gephi) {
    // parse DOT file
    console.log('The gephi property has been deprecated. Please use the static convertGephi method to convert gephi into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertGephi(gephiJson);');
    var gephiData = gephiParser.parseGephi(data.gephi);
    this.setData(gephiData);
    return;
  } else {
    this.nodesHandler.setData(data && data.nodes, true);
    this.edgesHandler.setData(data && data.edges, true);
  }

  // emit change in data
  this.body.emitter.emit('_dataChanged');

  // emit data loaded
  this.body.emitter.emit('_dataLoaded');

  // find a stable position or start animating to a stable position
  this.body.emitter.emit('initPhysics');
};

/**
 * Cleans up all bindings of the network, removing it fully from the memory IF the variable is set to null after calling this function.
 * var network = new vis.Network(..);
 * network.destroy();
 * network = null;
 */
Network.prototype.destroy = function () {
  this.body.emitter.emit('destroy');
  // clear events
  this.body.emitter.off();
  this.off();

  // delete modules
  delete this.groups;
  delete this.canvas;
  delete this.selectionHandler;
  delete this.interactionHandler;
  delete this.view;
  delete this.renderer;
  delete this.physics;
  delete this.layoutEngine;
  delete this.clustering;
  delete this.manipulation;
  delete this.nodesHandler;
  delete this.edgesHandler;
  delete this.configurator;
  delete this.images;

  for (var nodeId in this.body.nodes) {
    if (!this.body.nodes.hasOwnProperty(nodeId)) continue;
    delete this.body.nodes[nodeId];
  }

  for (var edgeId in this.body.edges) {
    if (!this.body.edges.hasOwnProperty(edgeId)) continue;
    delete this.body.edges[edgeId];
  }

  // remove the container and everything inside it recursively
  util.recursiveDOMDelete(this.body.container);
};

/**
 * Update the values of all object in the given array according to the current
 * value range of the objects in the array.
 * @param {Object} obj    An object containing a set of Edges or Nodes
 *                        The objects must have a method getValue() and
 *                        setValueRange(min, max).
 * @private
 */
Network.prototype._updateValueRange = function (obj) {
  var id;

  // determine the range of the objects
  var valueMin = undefined;
  var valueMax = undefined;
  var valueTotal = 0;
  for (id in obj) {
    if (obj.hasOwnProperty(id)) {
      var value = obj[id].getValue();
      if (value !== undefined) {
        valueMin = valueMin === undefined ? value : Math.min(value, valueMin);
        valueMax = valueMax === undefined ? value : Math.max(value, valueMax);
        valueTotal += value;
      }
    }
  }

  // adjust the range of all objects
  if (valueMin !== undefined && valueMax !== undefined) {
    for (id in obj) {
      if (obj.hasOwnProperty(id)) {
        obj[id].setValueRange(valueMin, valueMax, valueTotal);
      }
    }
  }
};

/**
 * Returns true when the Network is active.
 * @returns {boolean}
 */
Network.prototype.isActive = function () {
  return !this.activator || this.activator.active;
};

Network.prototype.setSize = function () {
  return this.canvas.setSize.apply(this.canvas, arguments);
};
Network.prototype.canvasToDOM = function () {
  return this.canvas.canvasToDOM.apply(this.canvas, arguments);
};
Network.prototype.DOMtoCanvas = function () {
  return this.canvas.DOMtoCanvas.apply(this.canvas, arguments);
};

/**
 * Nodes can be in clusters. Clusters can also be in clusters. This function returns and array of
 * nodeIds showing where the node is.
 *
 * If any nodeId in the chain, especially the first passed in as a parameter, is not present in
 * the current nodes list, an empty array is returned.
 *
 * Example:
 * cluster 'A' contains cluster 'B',
 * cluster 'B' contains cluster 'C',
 * cluster 'C' contains node 'fred'.
 * `jsnetwork.clustering.findNode('fred')` will return `['A','B','C','fred']`.
 *
 * @param {string|number} nodeId
 * @returns {Array}
 */
Network.prototype.findNode = function () {
  return this.clustering.findNode.apply(this.clustering, arguments);
};

Network.prototype.isCluster = function () {
  return this.clustering.isCluster.apply(this.clustering, arguments);
};
Network.prototype.openCluster = function () {
  return this.clustering.openCluster.apply(this.clustering, arguments);
};
Network.prototype.cluster = function () {
  return this.clustering.cluster.apply(this.clustering, arguments);
};
Network.prototype.getNodesInCluster = function () {
  return this.clustering.getNodesInCluster.apply(this.clustering, arguments);
};
Network.prototype.clusterByConnection = function () {
  return this.clustering.clusterByConnection.apply(this.clustering, arguments);
};
Network.prototype.clusterByHubsize = function () {
  return this.clustering.clusterByHubsize.apply(this.clustering, arguments);
};

/**
 * This method will cluster all nodes with 1 edge with their respective connected node.
 * The options object is explained in full <a data-scroll="" data-options="{ &quot;easing&quot;: &quot;easeInCubic&quot; }" href="#optionsObject">below</a>.
 *
 * @param {object} [options]
 * @returns {undefined}
 */
Network.prototype.clusterOutliers = function () {
  return this.clustering.clusterOutliers.apply(this.clustering, arguments);
};

Network.prototype.getSeed = function () {
  return this.layoutEngine.getSeed.apply(this.layoutEngine, arguments);
};
Network.prototype.enableEditMode = function () {
  return this.manipulation.enableEditMode.apply(this.manipulation, arguments);
};
Network.prototype.disableEditMode = function () {
  return this.manipulation.disableEditMode.apply(this.manipulation, arguments);
};
Network.prototype.addNodeMode = function () {
  return this.manipulation.addNodeMode.apply(this.manipulation, arguments);
};
Network.prototype.editNode = function () {
  return this.manipulation.editNode.apply(this.manipulation, arguments);
};
Network.prototype.editNodeMode = function () {
  console.log('Deprecated: Please use editNode instead of editNodeMode.');
  return this.manipulation.editNode.apply(this.manipulation, arguments);
};
Network.prototype.addEdgeMode = function () {
  return this.manipulation.addEdgeMode.apply(this.manipulation, arguments);
};
Network.prototype.editEdgeMode = function () {
  return this.manipulation.editEdgeMode.apply(this.manipulation, arguments);
};
Network.prototype.deleteSelected = function () {
  return this.manipulation.deleteSelected.apply(this.manipulation, arguments);
};
Network.prototype.getPositions = function () {
  return this.nodesHandler.getPositions.apply(this.nodesHandler, arguments);
};
Network.prototype.storePositions = function () {
  return this.nodesHandler.storePositions.apply(this.nodesHandler, arguments);
};
Network.prototype.moveNode = function () {
  return this.nodesHandler.moveNode.apply(this.nodesHandler, arguments);
};
Network.prototype.getBoundingBox = function () {
  return this.nodesHandler.getBoundingBox.apply(this.nodesHandler, arguments);
};
Network.prototype.getConnectedNodes = function (objectId) {
  if (this.body.nodes[objectId] !== undefined) {
    return this.nodesHandler.getConnectedNodes.apply(this.nodesHandler, arguments);
  } else {
    return this.edgesHandler.getConnectedNodes.apply(this.edgesHandler, arguments);
  }
};
Network.prototype.getConnectedEdges = function () {
  return this.nodesHandler.getConnectedEdges.apply(this.nodesHandler, arguments);
};
Network.prototype.startSimulation = function () {
  return this.physics.startSimulation.apply(this.physics, arguments);
};
Network.prototype.stopSimulation = function () {
  return this.physics.stopSimulation.apply(this.physics, arguments);
};
Network.prototype.stabilize = function () {
  return this.physics.stabilize.apply(this.physics, arguments);
};
Network.prototype.getSelection = function () {
  return this.selectionHandler.getSelection.apply(this.selectionHandler, arguments);
};
Network.prototype.setSelection = function () {
  return this.selectionHandler.setSelection.apply(this.selectionHandler, arguments);
};
Network.prototype.getSelectedNodes = function () {
  return this.selectionHandler.getSelectedNodes.apply(this.selectionHandler, arguments);
};
Network.prototype.getSelectedEdges = function () {
  return this.selectionHandler.getSelectedEdges.apply(this.selectionHandler, arguments);
};
Network.prototype.getNodeAt = function () {
  var node = this.selectionHandler.getNodeAt.apply(this.selectionHandler, arguments);
  if (node !== undefined && node.id !== undefined) {
    return node.id;
  }
  return node;
};
Network.prototype.getEdgeAt = function () {
  var edge = this.selectionHandler.getEdgeAt.apply(this.selectionHandler, arguments);
  if (edge !== undefined && edge.id !== undefined) {
    return edge.id;
  }
  return edge;
};
Network.prototype.selectNodes = function () {
  return this.selectionHandler.selectNodes.apply(this.selectionHandler, arguments);
};
Network.prototype.selectEdges = function () {
  return this.selectionHandler.selectEdges.apply(this.selectionHandler, arguments);
};
Network.prototype.unselectAll = function () {
  this.selectionHandler.unselectAll.apply(this.selectionHandler, arguments);
  this.redraw();
};
Network.prototype.redraw = function () {
  return this.renderer.redraw.apply(this.renderer, arguments);
};
Network.prototype.getScale = function () {
  return this.view.getScale.apply(this.view, arguments);
};
Network.prototype.getViewPosition = function () {
  return this.view.getViewPosition.apply(this.view, arguments);
};
Network.prototype.fit = function () {
  return this.view.fit.apply(this.view, arguments);
};
Network.prototype.moveTo = function () {
  return this.view.moveTo.apply(this.view, arguments);
};
Network.prototype.focus = function () {
  return this.view.focus.apply(this.view, arguments);
};
Network.prototype.releaseNode = function () {
  return this.view.releaseNode.apply(this.view, arguments);
};
Network.prototype.getOptionsFromConfigurator = function () {
  var options = {};
  if (this.configurator) {
    options = this.configurator.getOptions.apply(this.configurator);
  }
  return options;
};

module.exports = Network;

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Canvas shapes used by Network
 */
if (typeof CanvasRenderingContext2D !== 'undefined') {
  /**
   * Draw a circle shape
   *
   * @param {number} x
   * @param {number} y
   * @param {number} r
   */
  CanvasRenderingContext2D.prototype.circle = function (x, y, r) {
    this.beginPath();
    this.arc(x, y, r, 0, 2 * Math.PI, false);
    this.closePath();
  };

  /**
   * Draw a square shape
   * @param {number} x horizontal center
   * @param {number} y vertical center
   * @param {number} r   size, width and height of the square
   */
  CanvasRenderingContext2D.prototype.square = function (x, y, r) {
    this.beginPath();
    this.rect(x - r, y - r, r * 2, r * 2);
    this.closePath();
  };

  /**
   * Draw a triangle shape
   * @param {number} x horizontal center
   * @param {number} y vertical center
   * @param {number} r   radius, half the length of the sides of the triangle
   */
  CanvasRenderingContext2D.prototype.triangle = function (x, y, r) {
    // http://en.wikipedia.org/wiki/Equilateral_triangle
    this.beginPath();

    // the change in radius and the offset is here to center the shape
    r *= 1.15;
    y += 0.275 * r;

    var s = r * 2;
    var s2 = s / 2;
    var ir = Math.sqrt(3) / 6 * s; // radius of inner circle
    var h = Math.sqrt(s * s - s2 * s2); // height

    this.moveTo(x, y - (h - ir));
    this.lineTo(x + s2, y + ir);
    this.lineTo(x - s2, y + ir);
    this.lineTo(x, y - (h - ir));
    this.closePath();
  };

  /**
   * Draw a triangle shape in downward orientation
   * @param {number} x horizontal center
   * @param {number} y vertical center
   * @param {number} r radius
   */
  CanvasRenderingContext2D.prototype.triangleDown = function (x, y, r) {
    // http://en.wikipedia.org/wiki/Equilateral_triangle
    this.beginPath();

    // the change in radius and the offset is here to center the shape
    r *= 1.15;
    y -= 0.275 * r;

    var s = r * 2;
    var s2 = s / 2;
    var ir = Math.sqrt(3) / 6 * s; // radius of inner circle
    var h = Math.sqrt(s * s - s2 * s2); // height

    this.moveTo(x, y + (h - ir));
    this.lineTo(x + s2, y - ir);
    this.lineTo(x - s2, y - ir);
    this.lineTo(x, y + (h - ir));
    this.closePath();
  };

  /**
   * Draw a star shape, a star with 5 points
   * @param {number} x horizontal center
   * @param {number} y vertical center
   * @param {number} r   radius, half the length of the sides of the triangle
   */
  CanvasRenderingContext2D.prototype.star = function (x, y, r) {
    // http://www.html5canvastutorials.com/labs/html5-canvas-star-spinner/
    this.beginPath();

    // the change in radius and the offset is here to center the shape
    r *= 0.82;
    y += 0.1 * r;

    for (var n = 0; n < 10; n++) {
      var radius = n % 2 === 0 ? r * 1.3 : r * 0.5;
      this.lineTo(x + radius * Math.sin(n * 2 * Math.PI / 10), y - radius * Math.cos(n * 2 * Math.PI / 10));
    }

    this.closePath();
  };

  /**
   * Draw a Diamond shape
   * @param {number} x horizontal center
   * @param {number} y vertical center
   * @param {number} r   radius, half the length of the sides of the triangle
   */
  CanvasRenderingContext2D.prototype.diamond = function (x, y, r) {
    // http://www.html5canvastutorials.com/labs/html5-canvas-star-spinner/
    this.beginPath();

    this.lineTo(x, y + r);
    this.lineTo(x + r, y);
    this.lineTo(x, y - r);
    this.lineTo(x - r, y);

    this.closePath();
  };

  /**
   * http://stackoverflow.com/questions/1255512/how-to-draw-a-rounded-rectangle-on-html-canvas
   *
   * @param {number} x
   * @param {number} y
   * @param {number} w
   * @param {number} h
   * @param {number} r
   */
  CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
    var r2d = Math.PI / 180;
    if (w - 2 * r < 0) {
      r = w / 2;
    } //ensure that the radius isn't too large for x
    if (h - 2 * r < 0) {
      r = h / 2;
    } //ensure that the radius isn't too large for y
    this.beginPath();
    this.moveTo(x + r, y);
    this.lineTo(x + w - r, y);
    this.arc(x + w - r, y + r, r, r2d * 270, r2d * 360, false);
    this.lineTo(x + w, y + h - r);
    this.arc(x + w - r, y + h - r, r, 0, r2d * 90, false);
    this.lineTo(x + r, y + h);
    this.arc(x + r, y + h - r, r, r2d * 90, r2d * 180, false);
    this.lineTo(x, y + r);
    this.arc(x + r, y + r, r, r2d * 180, r2d * 270, false);
    this.closePath();
  };

  /**
   * http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas
   *
   * Postfix '_vis' added to discern it from standard method ellipse().
   *
   * @param {number} x
   * @param {number} y
   * @param {number} w
   * @param {number} h
   */
  CanvasRenderingContext2D.prototype.ellipse_vis = function (x, y, w, h) {
    var kappa = 0.5522848,
        ox = w / 2 * kappa,
        // control point offset horizontal
    oy = h / 2 * kappa,
        // control point offset vertical
    xe = x + w,
        // x-end
    ye = y + h,
        // y-end
    xm = x + w / 2,
        // x-middle
    ym = y + h / 2; // y-middle

    this.beginPath();
    this.moveTo(x, ym);
    this.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
    this.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
    this.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
    this.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
    this.closePath();
  };

  /**
   * http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas
   *
   * @param {number} x
   * @param {number} y
   * @param {number} w
   * @param {number} h
   */
  CanvasRenderingContext2D.prototype.database = function (x, y, w, h) {
    var f = 1 / 3;
    var wEllipse = w;
    var hEllipse = h * f;

    var kappa = 0.5522848,
        ox = wEllipse / 2 * kappa,
        // control point offset horizontal
    oy = hEllipse / 2 * kappa,
        // control point offset vertical
    xe = x + wEllipse,
        // x-end
    ye = y + hEllipse,
        // y-end
    xm = x + wEllipse / 2,
        // x-middle
    ym = y + hEllipse / 2,
        // y-middle
    ymb = y + (h - hEllipse / 2),
        // y-midlle, bottom ellipse
    yeb = y + h; // y-end, bottom ellipse

    this.beginPath();
    this.moveTo(xe, ym);

    this.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
    this.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);

    this.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
    this.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);

    this.lineTo(xe, ymb);

    this.bezierCurveTo(xe, ymb + oy, xm + ox, yeb, xm, yeb);
    this.bezierCurveTo(xm - ox, yeb, x, ymb + oy, x, ymb);

    this.lineTo(x, ym);
  };

  /**
   * Sets up the dashedLine functionality for drawing
   * Original code came from http://stackoverflow.com/questions/4576724/dotted-stroke-in-canvas
   * @author David Jordan
   * @date 2012-08-08
   *
   * @param {number} x
   * @param {number} y
   * @param {number} x2
   * @param {number} y2
   * @param {string} pattern
   */
  CanvasRenderingContext2D.prototype.dashedLine = function (x, y, x2, y2, pattern) {
    this.beginPath();
    this.moveTo(x, y);

    var patternLength = pattern.length;
    var dx = x2 - x;
    var dy = y2 - y;
    var slope = dy / dx;
    var distRemaining = Math.sqrt(dx * dx + dy * dy);
    var patternIndex = 0;
    var draw = true;
    var xStep = 0;
    var dashLength = pattern[0];

    while (distRemaining >= 0.1) {
      dashLength = pattern[patternIndex++ % patternLength];
      if (dashLength > distRemaining) {
        dashLength = distRemaining;
      }

      xStep = Math.sqrt(dashLength * dashLength / (1 + slope * slope));
      xStep = dx < 0 ? -xStep : xStep;
      x += xStep;
      y += slope * xStep;

      if (draw === true) {
        this.lineTo(x, y);
      } else {
        this.moveTo(x, y);
      }

      distRemaining -= dashLength;
      draw = !draw;
    }
  };

  /**
   * Draw a Hexagon shape with 6 sides
   * @param {Number} x horizontal center
   * @param {Number} y vertical center
   * @param {Number} r   radius
   */
  CanvasRenderingContext2D.prototype.hexagon = function (x, y, r) {
    this.beginPath();
    var sides = 6;
    var a = Math.PI * 2 / sides;
    this.moveTo(x + r, y);
    for (var i = 1; i < sides; i++) {
      this.lineTo(x + r * Math.cos(a * i), y + r * Math.sin(a * i));
    }
    this.closePath();
  };
}

/***/ }),
/* 126 */
/***/ (function(module, exports, __nested_webpack_require_601667__) {

"use strict";


var keycharm = __nested_webpack_require_601667__(52);
var Emitter = __nested_webpack_require_601667__(73);
var Hammer = __nested_webpack_require_601667__(24);
var util = __nested_webpack_require_601667__(2);

/**
 * Turn an element into an clickToUse element.
 * When not active, the element has a transparent overlay. When the overlay is
 * clicked, the mode is changed to active.
 * When active, the element is displayed with a blue border around it, and
 * the interactive contents of the element can be used. When clicked outside
 * the element, the elements mode is changed to inactive.
 * @param {Element} container
 * @constructor Activator
 */
function Activator(container) {
  this.active = false;

  this.dom = {
    container: container
  };

  this.dom.overlay = document.createElement('div');
  this.dom.overlay.className = 'vis-overlay';

  this.dom.container.appendChild(this.dom.overlay);

  this.hammer = Hammer(this.dom.overlay);
  this.hammer.on('tap', this._onTapOverlay.bind(this));

  // block all touch events (except tap)
  var me = this;
  var events = ['tap', 'doubletap', 'press', 'pinch', 'pan', 'panstart', 'panmove', 'panend'];
  events.forEach(function (event) {
    me.hammer.on(event, function (event) {
      event.stopPropagation();
    });
  });

  // attach a click event to the window, in order to deactivate when clicking outside the timeline
  if (document && document.body) {
    this.onClick = function (event) {
      if (!_hasParent(event.target, container)) {
        me.deactivate();
      }
    };
    document.body.addEventListener('click', this.onClick);
  }

  if (this.keycharm !== undefined) {
    this.keycharm.destroy();
  }
  this.keycharm = keycharm();

  // keycharm listener only bounded when active)
  this.escListener = this.deactivate.bind(this);
}

// turn into an event emitter
Emitter(Activator.prototype);

// The currently active activator
Activator.current = null;

/**
 * Destroy the activator. Cleans up all created DOM and event listeners
 */
Activator.prototype.destroy = function () {
  this.deactivate();

  // remove dom
  this.dom.overlay.parentNode.removeChild(this.dom.overlay);

  // remove global event listener
  if (this.onClick) {
    document.body.removeEventListener('click', this.onClick);
  }
  // remove keycharm
  if (this.keycharm !== undefined) {
    this.keycharm.destroy();
  }
  this.keycharm = null;
  // cleanup hammer instances
  this.hammer.destroy();
  this.hammer = null;
  // FIXME: cleaning up hammer instances doesn't work (Timeline not removed from memory)
};

/**
 * Activate the element
 * Overlay is hidden, element is decorated with a blue shadow border
 */
Activator.prototype.activate = function () {
  // we allow only one active activator at a time
  if (Activator.current) {
    Activator.current.deactivate();
  }
  Activator.current = this;

  this.active = true;
  this.dom.overlay.style.display = 'none';
  util.addClassName(this.dom.container, 'vis-active');

  this.emit('change');
  this.emit('activate');

  // ugly hack: bind ESC after emitting the events, as the Network rebinds all
  // keyboard events on a 'change' event
  this.keycharm.bind('esc', this.escListener);
};

/**
 * Deactivate the element
 * Overlay is displayed on top of the element
 */
Activator.prototype.deactivate = function () {
  this.active = false;
  this.dom.overlay.style.display = '';
  util.removeClassName(this.dom.container, 'vis-active');
  this.keycharm.unbind('esc', this.escListener);

  this.emit('change');
  this.emit('deactivate');
};

/**
 * Handle a tap event: activate the container
 * @param {Event}  event   The event
 * @private
 */
Activator.prototype._onTapOverlay = function (event) {
  // activate the container
  this.activate();
  event.stopPropagation();
};

/**
 * Test whether the element has the requested parent element somewhere in
 * its chain of parent nodes.
 * @param {HTMLElement} element
 * @param {HTMLElement} parent
 * @returns {boolean} Returns true when the parent is found somewhere in the
 *                    chain of parent nodes.
 * @private
 */
function _hasParent(element, parent) {
  while (element) {
    if (element === parent) {
      return true;
    }
    element = element.parentNode;
  }
  return false;
}

module.exports = Activator;

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

(function (factory) {
  if (true) {
    // AMD. Register as an anonymous module.
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
}(function () {
  var _firstTarget = null; // singleton, will contain the target element where the touch event started

  /**
   * Extend an Hammer.js instance with event propagation.
   *
   * Features:
   * - Events emitted by hammer will propagate in order from child to parent
   *   elements.
   * - Events are extended with a function `event.stopPropagation()` to stop
   *   propagation to parent elements.
   * - An option `preventDefault` to stop all default browser behavior.
   *
   * Usage:
   *   var hammer = propagatingHammer(new Hammer(element));
   *   var hammer = propagatingHammer(new Hammer(element), {preventDefault: true});
   *
   * @param {Hammer.Manager} hammer   An hammer instance.
   * @param {Object} [options]        Available options:
   *                                  - `preventDefault: true | false | 'mouse' | 'touch' | 'pen'`.
   *                                    Enforce preventing the default browser behavior.
   *                                    Cannot be set to `false`.
   * @return {Hammer.Manager} Returns the same hammer instance with extended
   *                          functionality
   */
  return function propagating(hammer, options) {
    var _options = options || {
      preventDefault: false
    };

    if (hammer.Manager) {
      // This looks like the Hammer constructor.
      // Overload the constructors with our own.
      var Hammer = hammer;

      var PropagatingHammer = function(element, options) {
        var o = Object.create(_options);
        if (options) Hammer.assign(o, options);
        return propagating(new Hammer(element, o), o);
      };
      Hammer.assign(PropagatingHammer, Hammer);

      PropagatingHammer.Manager = function (element, options) {
        var o = Object.create(_options);
        if (options) Hammer.assign(o, options);
        return propagating(new Hammer.Manager(element, o), o);
      };

      return PropagatingHammer;
    }

    // create a wrapper object which will override the functions
    // `on`, `off`, `destroy`, and `emit` of the hammer instance
    var wrapper = Object.create(hammer);

    // attach to DOM element
    var element = hammer.element;

    if(!element.hammer) element.hammer = [];
    element.hammer.push(wrapper);

    // register an event to catch the start of a gesture and store the
    // target in a singleton
    hammer.on('hammer.input', function (event) {
      if (_options.preventDefault === true || (_options.preventDefault === event.pointerType)) {
        event.preventDefault();
      }
      if (event.isFirst) {
        _firstTarget = event.target;
      }
    });

    /** @type {Object.<String, Array.<function>>} */
    wrapper._handlers = {};

    /**
     * Register a handler for one or multiple events
     * @param {String} events    A space separated string with events
     * @param {function} handler A callback function, called as handler(event)
     * @returns {Hammer.Manager} Returns the hammer instance
     */
    wrapper.on = function (events, handler) {
      // register the handler
      split(events).forEach(function (event) {
        var _handlers = wrapper._handlers[event];
        if (!_handlers) {
          wrapper._handlers[event] = _handlers = [];

          // register the static, propagated handler
          hammer.on(event, propagatedHandler);
        }
        _handlers.push(handler);
      });

      return wrapper;
    };

    /**
     * Unregister a handler for one or multiple events
     * @param {String} events      A space separated string with events
     * @param {function} [handler] Optional. The registered handler. If not
     *                             provided, all handlers for given events
     *                             are removed.
     * @returns {Hammer.Manager}   Returns the hammer instance
     */
    wrapper.off = function (events, handler) {
      // unregister the handler
      split(events).forEach(function (event) {
        var _handlers = wrapper._handlers[event];
        if (_handlers) {
          _handlers = handler ? _handlers.filter(function (h) {
            return h !== handler;
          }) : [];

          if (_handlers.length > 0) {
            wrapper._handlers[event] = _handlers;
          }
          else {
            // remove static, propagated handler
            hammer.off(event, propagatedHandler);
            delete wrapper._handlers[event];
          }
        }
      });

      return wrapper;
    };

    /**
     * Emit to the event listeners
     * @param {string} eventType
     * @param {Event} event
     */
    wrapper.emit = function(eventType, event) {
      _firstTarget = event.target;
      hammer.emit(eventType, event);
    };

    wrapper.destroy = function () {
      // Detach from DOM element
      var hammers = hammer.element.hammer;
      var idx = hammers.indexOf(wrapper);
      if(idx !== -1) hammers.splice(idx,1);
      if(!hammers.length) delete hammer.element.hammer;

      // clear all handlers
      wrapper._handlers = {};

      // call original hammer destroy
      hammer.destroy();
    };

    // split a string with space separated words
    function split(events) {
      return events.match(/[^ ]+/g);
    }

    /**
     * A static event handler, applying event propagation.
     * @param {Object} event
     */
    function propagatedHandler(event) {
      // let only a single hammer instance handle this event
      if (event.type !== 'hammer.input') {
        // it is possible that the same srcEvent is used with multiple hammer events,
        // we keep track on which events are handled in an object _handled
        if (!event.srcEvent._handled) {
          event.srcEvent._handled = {};
        }

        if (event.srcEvent._handled[event.type]) {
          return;
        }
        else {
          event.srcEvent._handled[event.type] = true;
        }
      }

      // attach a stopPropagation function to the event
      var stopped = false;
      event.stopPropagation = function () {
        stopped = true;
      };

      //wrap the srcEvent's stopPropagation to also stop hammer propagation:
      var srcStop = event.srcEvent.stopPropagation.bind(event.srcEvent);
      if(typeof srcStop == "function") {
        event.srcEvent.stopPropagation = function(){
          srcStop();
          event.stopPropagation();
        }
      }

      // attach firstTarget property to the event
      event.firstTarget = _firstTarget;

      // propagate over all elements (until stopped)
      var elem = _firstTarget;
      while (elem && !stopped) {
        var elemHammer = elem.hammer;
        if(elemHammer){
          var _handlers;
          for(var k = 0; k < elemHammer.length; k++){
            _handlers = elemHammer[k]._handlers[event.type];
            if(_handlers) for (var i = 0; i < _handlers.length && !stopped; i++) {
              _handlers[i](event);
            }
          }
        }
        elem = elem.parentNode;
      }
    }

    return wrapper;
  };
}));


/***/ }),
/* 128 */
/***/ (function(module, exports, __nested_webpack_require_613978__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
(function(window, document, exportName, undefined) {
  'use strict';

var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
var TEST_ELEMENT = document.createElement('div');

var TYPE_FUNCTION = 'function';

var round = Math.round;
var abs = Math.abs;
var now = Date.now;

/**
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */
function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
}

/**
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */
function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
        each(arg, context[fn], context);
        return true;
    }
    return false;
}

/**
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */
function each(obj, iterator, context) {
    var i;

    if (!obj) {
        return;
    }

    if (obj.forEach) {
        obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
        i = 0;
        while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
        }
    } else {
        for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
        }
    }
}

/**
 * wrap a method with a deprecation warning and stack trace
 * @param {Function} method
 * @param {String} name
 * @param {String} message
 * @returns {Function} A new function wrapping the supplied method.
 */
function deprecate(method, name, message) {
    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
    return function() {
        var e = new Error('get-stack-trace');
        var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

        var log = window.console && (window.console.warn || window.console.log);
        if (log) {
            log.call(window.console, deprecationMessage, stack);
        }
        return method.apply(this, arguments);
    };
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} target
 * @param {...Object} objects_to_assign
 * @returns {Object} target
 */
var assign;
if (typeof Object.assign !== 'function') {
    assign = function assign(target) {
        if (target === undefined || target === null) {
            throw new TypeError('Cannot convert undefined or null to object');
        }

        var output = Object(target);
        for (var index = 1; index < arguments.length; index++) {
            var source = arguments[index];
            if (source !== undefined && source !== null) {
                for (var nextKey in source) {
                    if (source.hasOwnProperty(nextKey)) {
                        output[nextKey] = source[nextKey];
                    }
                }
            }
        }
        return output;
    };
} else {
    assign = Object.assign;
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge=false]
 * @returns {Object} dest
 */
var extend = deprecate(function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;
    while (i < keys.length) {
        if (!merge || (merge && dest[keys[i]] === undefined)) {
            dest[keys[i]] = src[keys[i]];
        }
        i++;
    }
    return dest;
}, 'extend', 'Use `assign`.');

/**
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */
var merge = deprecate(function merge(dest, src) {
    return extend(dest, src, true);
}, 'merge', 'Use `assign`.');

/**
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */
function inherit(child, base, properties) {
    var baseP = base.prototype,
        childP;

    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;

    if (properties) {
        assign(childP, properties);
    }
}

/**
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
function bindFn(fn, context) {
    return function boundFn() {
        return fn.apply(context, arguments);
    };
}

/**
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */
function boolOrFn(val, args) {
    if (typeof val == TYPE_FUNCTION) {
        return val.apply(args ? args[0] || undefined : undefined, args);
    }
    return val;
}

/**
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */
function ifUndefined(val1, val2) {
    return (val1 === undefined) ? val2 : val1;
}

/**
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function addEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.addEventListener(type, handler, false);
    });
}

/**
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function removeEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.removeEventListener(type, handler, false);
    });
}

/**
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */
function hasParent(node, parent) {
    while (node) {
        if (node == parent) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
}

/**
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */
function inStr(str, find) {
    return str.indexOf(find) > -1;
}

/**
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */
function splitStr(str) {
    return str.trim().split(/\s+/g);
}

/**
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */
function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
        return src.indexOf(find);
    } else {
        var i = 0;
        while (i < src.length) {
            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                return i;
            }
            i++;
        }
        return -1;
    }
}

/**
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */
function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
}

/**
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */
function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;

    while (i < src.length) {
        var val = key ? src[i][key] : src[i];
        if (inArray(values, val) < 0) {
            results.push(src[i]);
        }
        values[i] = val;
        i++;
    }

    if (sort) {
        if (!key) {
            results = results.sort();
        } else {
            results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
            });
        }
    }

    return results;
}

/**
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */
function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);

    var i = 0;
    while (i < VENDOR_PREFIXES.length) {
        prefix = VENDOR_PREFIXES[i];
        prop = (prefix) ? prefix + camelProp : property;

        if (prop in obj) {
            return prop;
        }
        i++;
    }
    return undefined;
}

/**
 * get a unique id
 * @returns {number} uniqueId
 */
var _uniqueId = 1;
function uniqueId() {
    return _uniqueId++;
}

/**
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */
function getWindowForElement(element) {
    var doc = element.ownerDocument || element;
    return (doc.defaultView || doc.parentWindow || window);
}

var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

var SUPPORT_TOUCH = ('ontouchstart' in window);
var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

var INPUT_TYPE_TOUCH = 'touch';
var INPUT_TYPE_PEN = 'pen';
var INPUT_TYPE_MOUSE = 'mouse';
var INPUT_TYPE_KINECT = 'kinect';

var COMPUTE_INTERVAL = 25;

var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;

var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;

var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

var PROPS_XY = ['x', 'y'];
var PROPS_CLIENT_XY = ['clientX', 'clientY'];

/**
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */
function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;

    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.
    this.domHandler = function(ev) {
        if (boolOrFn(manager.options.enable, [manager])) {
            self.handler(ev);
        }
    };

    this.init();

}

Input.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function() { },

    /**
     * bind the events
     */
    init: function() {
        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },

    /**
     * unbind the events
     */
    destroy: function() {
        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
};

/**
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */
function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;

    if (inputClass) {
        Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
        Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
        Type = TouchInput;
    } else if (!SUPPORT_TOUCH) {
        Type = MouseInput;
    } else {
        Type = TouchMouseInput;
    }
    return new (Type)(manager, inputHandler);
}

/**
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */
function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;

    if (isFirst) {
        manager.session = {};
    }

    // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'
    input.eventType = eventType;

    // compute scale, rotation etc
    computeInputData(manager, input);

    // emit secret event
    manager.emit('hammer.input', input);

    manager.recognize(input);
    manager.session.prevInput = input;
}

/**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */
function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length;

    // store the first input to calculate the distance and direction
    if (!session.firstInput) {
        session.firstInput = simpleCloneInputData(input);
    }

    // to compute scale and rotation we need to store the multiple touches
    if (pointersLength > 1 && !session.firstMultiple) {
        session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
        session.firstMultiple = false;
    }

    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;

    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);

    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
    input.overallVelocityX = overallVelocity.x;
    input.overallVelocityY = overallVelocity.y;
    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;

    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);

    computeIntervalInputData(session, input);

    // find the correct target
    var target = manager.element;
    if (hasParent(input.srcEvent.target, target)) {
        target = input.srcEvent.target;
    }
    input.target = target;
}

function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};

    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
        prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
        };

        offset = session.offsetDelta = {
            x: center.x,
            y: center.y
        };
    }

    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
}

/**
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */
function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
        deltaTime = input.timeStamp - last.timeStamp,
        velocity, velocityX, velocityY, direction;

    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
        var deltaX = input.deltaX - last.deltaX;
        var deltaY = input.deltaY - last.deltaY;

        var v = getVelocity(deltaTime, deltaX, deltaY);
        velocityX = v.x;
        velocityY = v.y;
        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
        direction = getDirection(deltaX, deltaY);

        session.lastInterval = input;
    } else {
        // use latest velocity info if it doesn't overtake a minimum period
        velocity = last.velocity;
        velocityX = last.velocityX;
        velocityY = last.velocityY;
        direction = last.direction;
    }

    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
}

/**
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */
function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;
    while (i < input.pointers.length) {
        pointers[i] = {
            clientX: round(input.pointers[i].clientX),
            clientY: round(input.pointers[i].clientY)
        };
        i++;
    }

    return {
        timeStamp: now(),
        pointers: pointers,
        center: getCenter(pointers),
        deltaX: input.deltaX,
        deltaY: input.deltaY
    };
}

/**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */
function getCenter(pointers) {
    var pointersLength = pointers.length;

    // no need to loop when only one touch
    if (pointersLength === 1) {
        return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
        };
    }

    var x = 0, y = 0, i = 0;
    while (i < pointersLength) {
        x += pointers[i].clientX;
        y += pointers[i].clientY;
        i++;
    }

    return {
        x: round(x / pointersLength),
        y: round(y / pointersLength)
    };
}

/**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */
function getVelocity(deltaTime, x, y) {
    return {
        x: x / deltaTime || 0,
        y: y / deltaTime || 0
    };
}

/**
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */
function getDirection(x, y) {
    if (x === y) {
        return DIRECTION_NONE;
    }

    if (abs(x) >= abs(y)) {
        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
}

/**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */
function getDistance(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];

    return Math.sqrt((x * x) + (y * y));
}

/**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */
function getAngle(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
}

/**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */
function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
}

/**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */
function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}

var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
};

var MOUSE_ELEMENT_EVENTS = 'mousedown';
var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

/**
 * Mouse events input
 * @constructor
 * @extends Input
 */
function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;

    this.pressed = false; // mousedown state

    Input.apply(this, arguments);
}

inherit(MouseInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function MEhandler(ev) {
        var eventType = MOUSE_INPUT_MAP[ev.type];

        // on start we want to have the left mouse button down
        if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
        }

        if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
        }

        // mouse must be down
        if (!this.pressed) {
            return;
        }

        if (eventType & INPUT_END) {
            this.pressed = false;
        }

        this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
        });
    }
});

var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
};

// in IE10 the pointer types is defined as an enum
var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
};

var POINTER_ELEMENT_EVENTS = 'pointerdown';
var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

// IE10 has prefixed support, and case-sensitive
if (window.MSPointerEvent && !window.PointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
}

/**
 * Pointer events input
 * @constructor
 * @extends Input
 */
function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;

    Input.apply(this, arguments);

    this.store = (this.manager.session.pointerEvents = []);
}

inherit(PointerEventInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function PEhandler(ev) {
        var store = this.store;
        var removePointer = false;

        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

        // get index of the event in the store
        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

        // start and mouse must be down
        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
            }
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
        }

        // it not found, so the pointer hasn't been down (so it's probably a hover)
        if (storeIndex < 0) {
            return;
        }

        // update the event in the store
        store[storeIndex] = ev;

        this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType: pointerType,
            srcEvent: ev
        });

        if (removePointer) {
            // remove from the store
            store.splice(storeIndex, 1);
        }
    }
});

var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Touch events input
 * @constructor
 * @extends Input
 */
function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;

    Input.apply(this, arguments);
}

inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

        // should we handle the touch events?
        if (type === INPUT_START) {
            this.started = true;
        }

        if (!this.started) {
            return;
        }

        var touches = normalizeSingleTouches.call(this, ev, type);

        // when done, reset the started state
        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);

    if (type & (INPUT_END | INPUT_CANCEL)) {
        all = uniqueArray(all.concat(changed), 'identifier', true);
    }

    return [all, changed];
}

var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */
function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};

    Input.apply(this, arguments);
}

inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
        var type = TOUCH_INPUT_MAP[ev.type];
        var touches = getTouches.call(this, ev, type);
        if (!touches) {
            return;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds;

    // when there is only one touch, the process can be simplified
    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
        targetIds[allTouches[0].identifier] = true;
        return [allTouches, allTouches];
    }

    var i,
        targetTouches,
        changedTouches = toArray(ev.changedTouches),
        changedTargetTouches = [],
        target = this.target;

    // get target touches from touches
    targetTouches = allTouches.filter(function(touch) {
        return hasParent(touch.target, target);
    });

    // collect touches
    if (type === INPUT_START) {
        i = 0;
        while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
        }
    }

    // filter changed touches to only contain touches that exist in the collected target ids
    i = 0;
    while (i < changedTouches.length) {
        if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
        }

        // cleanup removed touches
        if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
        }
        i++;
    }

    if (!changedTargetTouches.length) {
        return;
    }

    return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
        changedTargetTouches
    ];
}

/**
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */

var DEDUP_TIMEOUT = 2500;
var DEDUP_DISTANCE = 25;

function TouchMouseInput() {
    Input.apply(this, arguments);

    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);

    this.primaryTouch = null;
    this.lastTouches = [];
}

inherit(TouchMouseInput, Input, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function TMEhandler(manager, inputEvent, inputData) {
        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
            return;
        }

        // when we're in a touch event, record touches to  de-dupe synthetic mouse event
        if (isTouch) {
            recordTouches.call(this, inputEvent, inputData);
        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
            return;
        }

        this.callback(manager, inputEvent, inputData);
    },

    /**
     * remove the event listeners
     */
    destroy: function destroy() {
        this.touch.destroy();
        this.mouse.destroy();
    }
});

function recordTouches(eventType, eventData) {
    if (eventType & INPUT_START) {
        this.primaryTouch = eventData.changedPointers[0].identifier;
        setLastTouch.call(this, eventData);
    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
        setLastTouch.call(this, eventData);
    }
}

function setLastTouch(eventData) {
    var touch = eventData.changedPointers[0];

    if (touch.identifier === this.primaryTouch) {
        var lastTouch = {x: touch.clientX, y: touch.clientY};
        this.lastTouches.push(lastTouch);
        var lts = this.lastTouches;
        var removeLastTouch = function() {
            var i = lts.indexOf(lastTouch);
            if (i > -1) {
                lts.splice(i, 1);
            }
        };
        setTimeout(removeLastTouch, DEDUP_TIMEOUT);
    }
}

function isSyntheticEvent(eventData) {
    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
    for (var i = 0; i < this.lastTouches.length; i++) {
        var t = this.lastTouches[i];
        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
            return true;
        }
    }
    return false;
}

var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

// magical touchAction value
var TOUCH_ACTION_COMPUTE = 'compute';
var TOUCH_ACTION_AUTO = 'auto';
var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
var TOUCH_ACTION_NONE = 'none';
var TOUCH_ACTION_PAN_X = 'pan-x';
var TOUCH_ACTION_PAN_Y = 'pan-y';
var TOUCH_ACTION_MAP = getTouchActionProps();

/**
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */
function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
}

TouchAction.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function(value) {
        // find out the touch-action by the event handlers
        if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
        }

        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
        }
        this.actions = value.toLowerCase().trim();
    },

    /**
     * just re-set the touchAction value
     */
    update: function() {
        this.set(this.manager.options.touchAction);
    },

    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function() {
        var actions = [];
        each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
            }
        });
        return cleanTouchActions(actions.join(' '));
    },

    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function(input) {
        var srcEvent = input.srcEvent;
        var direction = input.offsetDirection;

        // if the touch action did prevented once this session
        if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
        }

        var actions = this.actions;
        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

        if (hasNone) {
            //do not prevent defaults if this is a tap gesture

            var isTapPointer = input.pointers.length === 1;
            var isTapMovement = input.distance < 2;
            var isTapTouchTime = input.deltaTime < 250;

            if (isTapPointer && isTapMovement && isTapTouchTime) {
                return;
            }
        }

        if (hasPanX && hasPanY) {
            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
            return;
        }

        if (hasNone ||
            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
            (hasPanX && direction & DIRECTION_VERTICAL)) {
            return this.preventSrc(srcEvent);
        }
    },

    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function(srcEvent) {
        this.manager.session.prevented = true;
        srcEvent.preventDefault();
    }
};

/**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */
function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
        return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

    // if both pan-x and pan-y are set (different recognizers
    // for different directions, e.g. horizontal pan but vertical swipe?)
    // we need none (as otherwise with pan-x pan-y combined none of these
    // recognizers will work, since the browser would handle all panning
    if (hasPanX && hasPanY) {
        return TOUCH_ACTION_NONE;
    }

    // pan-x OR pan-y
    if (hasPanX || hasPanY) {
        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    }

    // manipulation
    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
        return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
}

function getTouchActionProps() {
    if (!NATIVE_TOUCH_ACTION) {
        return false;
    }
    var touchMap = {};
    var cssSupports = window.CSS && window.CSS.supports;
    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {

        // If css.supports is not supported but there is native touch-action assume it supports
        // all values. This is the case for IE 10 and 11.
        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
    });
    return touchMap;
}

/**
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */
var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;

/**
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */
function Recognizer(options) {
    this.options = assign({}, this.defaults, options || {});

    this.id = uniqueId();

    this.manager = null;

    // default is enable true
    this.options.enable = ifUndefined(this.options.enable, true);

    this.state = STATE_POSSIBLE;

    this.simultaneous = {};
    this.requireFail = [];
}

Recognizer.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},

    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function(options) {
        assign(this.options, options);

        // also update the touchAction, in case something changed about the directions/enabled state
        this.manager && this.manager.touchAction.update();
        return this;
    },

    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
            return this;
        }

        var simultaneous = this.simultaneous;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
        }
        return this;
    },

    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        delete this.simultaneous[otherRecognizer.id];
        return this;
    },

    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
            return this;
        }

        var requireFail = this.requireFail;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
        }
        return this;
    },

    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        var index = inArray(this.requireFail, otherRecognizer);
        if (index > -1) {
            this.requireFail.splice(index, 1);
        }
        return this;
    },

    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function() {
        return this.requireFail.length > 0;
    },

    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function(otherRecognizer) {
        return !!this.simultaneous[otherRecognizer.id];
    },

    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function(input) {
        var self = this;
        var state = this.state;

        function emit(event) {
            self.manager.emit(event, input);
        }

        // 'panstart' and 'panmove'
        if (state < STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }

        emit(self.options.event); // simple 'eventName' events

        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)
            emit(input.additionalEvent);
        }

        // panend and pancancel
        if (state >= STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }
    },

    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function(input) {
        if (this.canEmit()) {
            return this.emit(input);
        }
        // it's failing anyway
        this.state = STATE_FAILED;
    },

    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function() {
        var i = 0;
        while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
            }
            i++;
        }
        return true;
    },

    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        // make a new copy of the inputData
        // so we can change the inputData without messing up the other recognizers
        var inputDataClone = assign({}, inputData);

        // is is enabled and allow recognizing?
        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
        }

        // reset when we've reached the end
        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
        }

        this.state = this.process(inputDataClone);

        // the recognizer has recognized a gesture
        // so trigger an event
        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
        }
    },

    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function(inputData) { }, // jshint ignore:line

    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function() { },

    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function() { }
};

/**
 * get a usable string, used as event postfix
 * @param {Const} state
 * @returns {String} state
 */
function stateStr(state) {
    if (state & STATE_CANCELLED) {
        return 'cancel';
    } else if (state & STATE_ENDED) {
        return 'end';
    } else if (state & STATE_CHANGED) {
        return 'move';
    } else if (state & STATE_BEGAN) {
        return 'start';
    }
    return '';
}

/**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */
function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
        return 'down';
    } else if (direction == DIRECTION_UP) {
        return 'up';
    } else if (direction == DIRECTION_LEFT) {
        return 'left';
    } else if (direction == DIRECTION_RIGHT) {
        return 'right';
    }
    return '';
}

/**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */
function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;
    if (manager) {
        return manager.get(otherRecognizer);
    }
    return otherRecognizer;
}

/**
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */
function AttrRecognizer() {
    Recognizer.apply(this, arguments);
}

inherit(AttrRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
    },

    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function(input) {
        var optionPointers = this.options.pointers;
        return optionPointers === 0 || input.pointers.length === optionPointers;
    },

    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function(input) {
        var state = this.state;
        var eventType = input.eventType;

        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
        var isValid = this.attrTest(input);

        // on cancel input and we've recognized before, return STATE_CANCELLED
        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
        } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
                return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
        }
        return STATE_FAILED;
    }
});

/**
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);

    this.pX = null;
    this.pY = null;
}

inherit(PanRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
        event: 'pan',
        threshold: 10,
        pointers: 1,
        direction: DIRECTION_ALL
    },

    getTouchAction: function() {
        var direction = this.options.direction;
        var actions = [];
        if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
        }
        if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
        }
        return actions;
    },

    directionTest: function(input) {
        var options = this.options;
        var hasMoved = true;
        var distance = input.distance;
        var direction = input.direction;
        var x = input.deltaX;
        var y = input.deltaY;

        // lock to axis?
        if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x != this.pX;
                distance = Math.abs(input.deltaX);
            } else {
                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y != this.pY;
                distance = Math.abs(input.deltaY);
            }
        }
        input.direction = direction;
        return hasMoved && distance > options.threshold && direction & options.direction;
    },

    attrTest: function(input) {
        return AttrRecognizer.prototype.attrTest.call(this, input) &&
            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
    },

    emit: function(input) {

        this.pX = input.deltaX;
        this.pY = input.deltaY;

        var direction = directionStr(input.direction);

        if (direction) {
            input.additionalEvent = this.options.event + direction;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */
function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(PinchRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'pinch',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },

    emit: function(input) {
        if (input.scale !== 1) {
            var inOut = input.scale < 1 ? 'in' : 'out';
            input.additionalEvent = this.options.event + inOut;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */
function PressRecognizer() {
    Recognizer.apply(this, arguments);

    this._timer = null;
    this._input = null;
}

inherit(PressRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
        event: 'press',
        pointers: 1,
        time: 251, // minimal time of the pointer to be pressed
        threshold: 9 // a minimal movement is ok, but keep it low
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_AUTO];
    },

    process: function(input) {
        var options = this.options;
        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTime = input.deltaTime > options.time;

        this._input = input;

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
            this.reset();
        } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
            }, options.time, this);
        } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
        }
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function(input) {
        if (this.state !== STATE_RECOGNIZED) {
            return;
        }

        if (input && (input.eventType & INPUT_END)) {
            this.manager.emit(this.options.event + 'up', input);
        } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */
function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(RotateRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
        event: 'rotate',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
});

/**
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(SwipeRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
        event: 'swipe',
        threshold: 10,
        velocity: 0.3,
        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
        pointers: 1
    },

    getTouchAction: function() {
        return PanRecognizer.prototype.getTouchAction.call(this);
    },

    attrTest: function(input) {
        var direction = this.options.direction;
        var velocity;

        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.overallVelocity;
        } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.overallVelocityX;
        } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.overallVelocityY;
        }

        return this._super.attrTest.call(this, input) &&
            direction & input.offsetDirection &&
            input.distance > this.options.threshold &&
            input.maxPointers == this.options.pointers &&
            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },

    emit: function(input) {
        var direction = directionStr(input.offsetDirection);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this.manager.emit(this.options.event, input);
    }
});

/**
 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */
function TapRecognizer() {
    Recognizer.apply(this, arguments);

    // previous time and center,
    // used for tap counting
    this.pTime = false;
    this.pCenter = false;

    this._timer = null;
    this._input = null;
    this.count = 0;
}

inherit(TapRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'tap',
        pointers: 1,
        taps: 1,
        interval: 300, // max time between the multi-tap taps
        time: 250, // max time of the pointer to be down (like finger on the screen)
        threshold: 9, // a minimal movement is ok, but keep it low
        posThreshold: 10 // a multi-tap can be a bit off the initial position
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_MANIPULATION];
    },

    process: function(input) {
        var options = this.options;

        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTouchTime = input.deltaTime < options.time;

        this.reset();

        if ((input.eventType & INPUT_START) && (this.count === 0)) {
            return this.failTimeout();
        }

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
                return this.failTimeout();
            }

            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

            this.pTime = input.timeStamp;
            this.pCenter = input.center;

            if (!validMultiTap || !validInterval) {
                this.count = 1;
            } else {
                this.count += 1;
            }

            this._input = input;

            // if tap count matches we have recognized it,
            // else it has began recognizing...
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
                // no failing requirements, immediately trigger the tap event
                // or wait as long as the multitap interval to trigger
                if (!this.hasRequireFailures()) {
                    return STATE_RECOGNIZED;
                } else {
                    this._timer = setTimeoutContext(function() {
                        this.state = STATE_RECOGNIZED;
                        this.tryEmit();
                    }, options.interval, this);
                    return STATE_BEGAN;
                }
            }
        }
        return STATE_FAILED;
    },

    failTimeout: function() {
        this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
        }, this.options.interval, this);
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function() {
        if (this.state == STATE_RECOGNIZED) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Simple way to create a manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Hammer(element, options) {
    options = options || {};
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
}

/**
 * @const {string}
 */
Hammer.VERSION = '2.0.7';

/**
 * default settings
 * @namespace
 */
Hammer.defaults = {
    /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,

    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,

    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,

    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,

    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,

    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [RotateRecognizer, {enable: false}],
        [PinchRecognizer, {enable: false}, ['rotate']],
        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],
        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],
        [TapRecognizer],
        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],
        [PressRecognizer]
    ],

    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: 'none',

        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: 'none',

        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: 'none',

        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: 'none',

        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: 'none',

        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: 'rgba(0,0,0,0)'
    }
};

var STOP = 1;
var FORCED_STOP = 2;

/**
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Manager(element, options) {
    this.options = assign({}, Hammer.defaults, options || {});

    this.options.inputTarget = this.options.inputTarget || element;

    this.handlers = {};
    this.session = {};
    this.recognizers = [];
    this.oldCssProps = {};

    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);

    toggleCssProps(this, true);

    each(this.options.recognizers, function(item) {
        var recognizer = this.add(new (item[0])(item[1]));
        item[2] && recognizer.recognizeWith(item[2]);
        item[3] && recognizer.requireFailure(item[3]);
    }, this);
}

Manager.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function(options) {
        assign(this.options, options);

        // Options that need a little more setup
        if (options.touchAction) {
            this.touchAction.update();
        }
        if (options.inputTarget) {
            // Clean up existing event listeners and reinitialize
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
        }
        return this;
    },

    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function(force) {
        this.session.stopped = force ? FORCED_STOP : STOP;
    },

    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        var session = this.session;
        if (session.stopped) {
            return;
        }

        // run the touch-action polyfill
        this.touchAction.preventDefaults(inputData);

        var recognizer;
        var recognizers = this.recognizers;

        // this holds the recognizer that is being recognized.
        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
        // if no recognizer is detecting a thing, it is set to `null`
        var curRecognizer = session.curRecognizer;

        // reset when the last recognizer is recognized
        // or when we're in a new session
        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
            curRecognizer = session.curRecognizer = null;
        }

        var i = 0;
        while (i < recognizers.length) {
            recognizer = recognizers[i];

            // find out if we are allowed try to recognize the input for this one.
            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
            //      that is being recognized.
            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
            //      this can be setup with the `recognizeWith()` method on the recognizer.
            if (session.stopped !== FORCED_STOP && ( // 1
                    !curRecognizer || recognizer == curRecognizer || // 2
                    recognizer.canRecognizeWith(curRecognizer))) { // 3
                recognizer.recognize(inputData);
            } else {
                recognizer.reset();
            }

            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
            // current active recognizer. but only if we don't already have an active recognizer
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
        }
    },

    /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function(recognizer) {
        if (recognizer instanceof Recognizer) {
            return recognizer;
        }

        var recognizers = this.recognizers;
        for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
                return recognizers[i];
            }
        }
        return null;
    },

    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function(recognizer) {
        if (invokeArrayArg(recognizer, 'add', this)) {
            return this;
        }

        // remove existing
        var existing = this.get(recognizer.options.event);
        if (existing) {
            this.remove(existing);
        }

        this.recognizers.push(recognizer);
        recognizer.manager = this;

        this.touchAction.update();
        return recognizer;
    },

    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function(recognizer) {
        if (invokeArrayArg(recognizer, 'remove', this)) {
            return this;
        }

        recognizer = this.get(recognizer);

        // let's make sure this recognizer exists
        if (recognizer) {
            var recognizers = this.recognizers;
            var index = inArray(recognizers, recognizer);

            if (index !== -1) {
                recognizers.splice(index, 1);
                this.touchAction.update();
            }
        }

        return this;
    },

    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function(events, handler) {
        if (events === undefined) {
            return;
        }
        if (handler === undefined) {
            return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
        });
        return this;
    },

    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function(events, handler) {
        if (events === undefined) {
            return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            if (!handler) {
                delete handlers[event];
            } else {
                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
            }
        });
        return this;
    },

    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function(event, data) {
        // we also want to trigger dom events
        if (this.options.domEvents) {
            triggerDomEvent(event, data);
        }

        // no handlers, so skip it all
        var handlers = this.handlers[event] && this.handlers[event].slice();
        if (!handlers || !handlers.length) {
            return;
        }

        data.type = event;
        data.preventDefault = function() {
            data.srcEvent.preventDefault();
        };

        var i = 0;
        while (i < handlers.length) {
            handlers[i](data);
            i++;
        }
    },

    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function() {
        this.element && toggleCssProps(this, false);

        this.handlers = {};
        this.session = {};
        this.input.destroy();
        this.element = null;
    }
};

/**
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */
function toggleCssProps(manager, add) {
    var element = manager.element;
    if (!element.style) {
        return;
    }
    var prop;
    each(manager.options.cssProps, function(value, name) {
        prop = prefixed(element.style, name);
        if (add) {
            manager.oldCssProps[prop] = element.style[prop];
            element.style[prop] = value;
        } else {
            element.style[prop] = manager.oldCssProps[prop] || '';
        }
    });
    if (!add) {
        manager.oldCssProps = {};
    }
}

/**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */
function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
}

assign(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,

    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,

    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,

    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,

    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,

    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,

    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    assign: assign,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
});

// this prevents errors when Hammer is loaded in the presence of an AMD
//  style loader but by script tag, not by the loader.
var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line
freeGlobal.Hammer = Hammer;

if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
        return Hammer;
    }).call(exports, __nested_webpack_require_613978__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {}

})(window, document, 'Hammer');


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// English
exports['en'] = {
  edit: 'Edit',
  del: 'Delete selected',
  back: 'Back',
  addNode: 'Add Node',
  addEdge: 'Add Edge',
  editNode: 'Edit Node',
  editEdge: 'Edit Edge',
  addDescription: 'Click in an empty space to place a new node.',
  edgeDescription: 'Click on a node and drag the edge to another node to connect them.',
  editEdgeDescription: 'Click on the control points and drag them to a node to connect to it.',
  createEdgeError: 'Cannot link edges to a cluster.',
  deleteClusterError: 'Clusters cannot be deleted.',
  editClusterError: 'Clusters cannot be edited.'
};
exports['en_EN'] = exports['en'];
exports['en_US'] = exports['en'];

// German
exports['de'] = {
  edit: 'Editieren',
  del: 'L\xF6sche Auswahl',
  back: 'Zur\xFCck',
  addNode: 'Knoten hinzuf\xFCgen',
  addEdge: 'Kante hinzuf\xFCgen',
  editNode: 'Knoten editieren',
  editEdge: 'Kante editieren',
  addDescription: 'Klicke auf eine freie Stelle, um einen neuen Knoten zu plazieren.',
  edgeDescription: 'Klicke auf einen Knoten und ziehe die Kante zu einem anderen Knoten, um diese zu verbinden.',
  editEdgeDescription: 'Klicke auf die Verbindungspunkte und ziehe diese auf einen Knoten, um sie zu verbinden.',
  createEdgeError: 'Es ist nicht m\xF6glich, Kanten mit Clustern zu verbinden.',
  deleteClusterError: 'Cluster k\xF6nnen nicht gel\xF6scht werden.',
  editClusterError: 'Cluster k\xF6nnen nicht editiert werden.'
};
exports['de_DE'] = exports['de'];

// Spanish
exports['es'] = {
  edit: 'Editar',
  del: 'Eliminar selecci\xF3n',
  back: '\xC1tras',
  addNode: 'A\xF1adir nodo',
  addEdge: 'A\xF1adir arista',
  editNode: 'Editar nodo',
  editEdge: 'Editar arista',
  addDescription: 'Haga clic en un lugar vac\xEDo para colocar un nuevo nodo.',
  edgeDescription: 'Haga clic en un nodo y arrastre la arista hacia otro nodo para conectarlos.',
  editEdgeDescription: 'Haga clic en un punto de control y arrastrelo a un nodo para conectarlo.',
  createEdgeError: 'No se puede conectar una arista a un grupo.',
  deleteClusterError: 'No es posible eliminar grupos.',
  editClusterError: 'No es posible editar grupos.'
};
exports['es_ES'] = exports['es'];

//Italiano
exports['it'] = {
  edit: 'Modifica',
  del: 'Cancella la selezione',
  back: 'Indietro',
  addNode: 'Aggiungi un nodo',
  addEdge: 'Aggiungi un vertice',
  editNode: 'Modifica il nodo',
  editEdge: 'Modifica il vertice',
  addDescription: 'Clicca per aggiungere un nuovo nodo',
  edgeDescription: 'Clicca su un nodo e trascinalo ad un altro nodo per connetterli.',
  editEdgeDescription: 'Clicca sui Punti di controllo e trascinali ad un nodo per connetterli.',
  createEdgeError: 'Non si possono collegare vertici ad un cluster',
  deleteClusterError: 'I cluster non possono essere cancellati',
  editClusterError: 'I clusters non possono essere modificati.'
};
exports['it_IT'] = exports['it'];

// Dutch
exports['nl'] = {
  edit: 'Wijzigen',
  del: 'Selectie verwijderen',
  back: 'Terug',
  addNode: 'Node toevoegen',
  addEdge: 'Link toevoegen',
  editNode: 'Node wijzigen',
  editEdge: 'Link wijzigen',
  addDescription: 'Klik op een leeg gebied om een nieuwe node te maken.',
  edgeDescription: 'Klik op een node en sleep de link naar een andere node om ze te verbinden.',
  editEdgeDescription: 'Klik op de verbindingspunten en sleep ze naar een node om daarmee te verbinden.',
  createEdgeError: 'Kan geen link maken naar een cluster.',
  deleteClusterError: 'Clusters kunnen niet worden verwijderd.',
  editClusterError: 'Clusters kunnen niet worden aangepast.'
};
exports['nl_NL'] = exports['nl'];
exports['nl_BE'] = exports['nl'];

// Portuguese Brazil
exports['pt-br'] = {
  edit: 'Editar',
  del: 'Remover selecionado',
  back: 'Voltar',
  addNode: 'Adicionar n',
  addEdge: 'Adicionar aresta',
  editNode: 'Editar n',
  editEdge: 'Editar aresta',
  addDescription: 'Clique em um espao em branco para adicionar um novo n',
  edgeDescription: 'Clique em um n e arraste a aresta at outro n para conect-los',
  editEdgeDescription: 'Clique nos pontos de controle e os arraste para um n para conect-los',
  createEdgeError: 'No foi possvel linkar arestas a um cluster.',
  deleteClusterError: 'Clusters no puderam ser removidos.',
  editClusterError: 'Clusters no puderam ser editados.'
};
exports['pt-BR'] = exports['pt-br'];
exports['pt_BR'] = exports['pt-br'];
exports['pt_br'] = exports['pt-br'];

// Russian
exports['ru'] = {
  edit: '',
  del: ' ',
  back: '',
  addNode: ' ',
  addEdge: ' ',
  editNode: ' ',
  editEdge: ' ',
  addDescription: '   ,    .',
  edgeDescription: '        ,   .',
  editEdgeDescription: '        ,    .',
  createEdgeError: '    .',
  deleteClusterError: '    ',
  editClusterError: '   .'
};
exports['ru_RU'] = exports['ru'];

// Chinese
exports['cn'] = {
  edit: '',
  del: '',
  back: '',
  addNode: '',
  addEdge: '',
  editNode: '',
  editEdge: '',
  addDescription: '',
  edgeDescription: '',
  editEdgeDescription: '',
  createEdgeError: '',
  deleteClusterError: '',
  editClusterError: ''
};
exports['zh_CN'] = exports['cn'];

// Ukrainian
exports['uk'] = {
  edit: '',
  del: ' ',
  back: '',
  addNode: ' ',
  addEdge: ' ',
  editNode: ' ',
  editEdge: ' ',
  addDescription: 'K   ,    .',
  edgeDescription: "        ,   '.",
  editEdgeDescription: '        ,    .',
  createEdgeError: "  '   .",
  deleteClusterError: '    .',
  editClusterError: '   .'
};
exports['uk_UA'] = exports['uk'];

// French
exports['fr'] = {
  edit: 'Editer',
  del: 'Effacer la selection',
  back: 'Retour',
  addNode: 'Ajouter un noeud',
  addEdge: 'Ajouter un lien',
  editNode: 'Editer le noeud',
  editEdge: 'Editer le lien',
  addDescription: 'Cliquez dans un endroit vide pour placer un noeud.',
  edgeDescription: 'Cliquez sur un noeud et glissez le lien vers un autre noeud pour les connecter.',
  editEdgeDescription: 'Cliquez sur les points de contrle et glissez-les pour connecter un noeud.',
  createEdgeError: 'Impossible de crer un lien vers un cluster.',
  deleteClusterError: 'Les clusters ne peuvent pas tre ffacs.',
  editClusterError: 'Les clusters ne peuvent pas tre dites.'
};
exports['fr_FR'] = exports['fr'];

/***/ }),
/* 130 */
/***/ (function(module, exports, __nested_webpack_require_695069__) {

module.exports = { "default": __nested_webpack_require_695069__(131), __esModule: true };

/***/ }),
/* 131 */
/***/ (function(module, exports, __nested_webpack_require_695223__) {

__nested_webpack_require_695223__(132);
var $Object = __nested_webpack_require_695223__(6).Object;
module.exports = function defineProperty(it, key, desc) {
  return $Object.defineProperty(it, key, desc);
};


/***/ }),
/* 132 */
/***/ (function(module, exports, __nested_webpack_require_695482__) {

var $export = __nested_webpack_require_695482__(11);
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__nested_webpack_require_695482__(13), 'Object', { defineProperty: __nested_webpack_require_695482__(12).f });


/***/ }),
/* 133 */
/***/ (function(module, exports, __nested_webpack_require_695779__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __nested_webpack_require_695779__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_695779__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * Associates a canvas to a given image, containing a number of renderings
 * of the image at various sizes.
 *
 * This technique is known as 'mipmapping'.
 *
 * NOTE: Images can also be of type 'data:svg+xml`. This code also works
 *       for svg, but the mipmapping may not be necessary.
 *
 * @param {Image} image
 */
var CachedImage = function () {
  /**
   * @ignore
   */
  function CachedImage() {
    (0, _classCallCheck3['default'])(this, CachedImage);

    // eslint-disable-line no-unused-vars
    this.NUM_ITERATIONS = 4; // Number of items in the coordinates array

    this.image = new Image();
    this.canvas = document.createElement('canvas');
  }

  /**
   * Called when the image has been successfully loaded.
   */


  (0, _createClass3['default'])(CachedImage, [{
    key: 'init',
    value: function init() {
      if (this.initialized()) return;

      this.src = this.image.src; // For same interface with Image
      var w = this.image.width;
      var h = this.image.height;

      // Ease external access
      this.width = w;
      this.height = h;

      var h2 = Math.floor(h / 2);
      var h4 = Math.floor(h / 4);
      var h8 = Math.floor(h / 8);
      var h16 = Math.floor(h / 16);

      var w2 = Math.floor(w / 2);
      var w4 = Math.floor(w / 4);
      var w8 = Math.floor(w / 8);
      var w16 = Math.floor(w / 16);

      // Make canvas as small as possible
      this.canvas.width = 3 * w4;
      this.canvas.height = h2;

      // Coordinates and sizes of images contained in the canvas
      // Values per row:  [top x, left y, width, height]

      this.coordinates = [[0, 0, w2, h2], [w2, 0, w4, h4], [w2, h4, w8, h8], [5 * w8, h4, w16, h16]];

      this._fillMipMap();
    }

    /**
     * @return {Boolean} true if init() has been called, false otherwise.
     */

  }, {
    key: 'initialized',
    value: function initialized() {
      return this.coordinates !== undefined;
    }

    /**
     * Redraw main image in various sizes to the context.
     *
     * The rationale behind this is to reduce artefacts due to interpolation
     * at differing zoom levels.
     *
     * Source: http://stackoverflow.com/q/18761404/1223531
     *
     * This methods takes the resizing out of the drawing loop, in order to
     * reduce performance overhead.
     *
     * TODO: The code assumes that a 2D context can always be gotten. This is
     *       not necessarily true! OTOH, if not true then usage of this class
     *       is senseless.
     *
     * @private
     */

  }, {
    key: '_fillMipMap',
    value: function _fillMipMap() {
      var ctx = this.canvas.getContext('2d');

      // First zoom-level comes from the image
      var to = this.coordinates[0];
      ctx.drawImage(this.image, to[0], to[1], to[2], to[3]);

      // The rest are copy actions internal to the canvas/context
      for (var iterations = 1; iterations < this.NUM_ITERATIONS; iterations++) {
        var from = this.coordinates[iterations - 1];
        var _to = this.coordinates[iterations];

        ctx.drawImage(this.canvas, from[0], from[1], from[2], from[3], _to[0], _to[1], _to[2], _to[3]);
      }
    }

    /**
     * Draw the image, using the mipmap if necessary.
     *
     * MipMap is only used if param factor > 2; otherwise, original bitmap
     * is resized. This is also used to skip mipmap usage, e.g. by setting factor = 1
     *
     * Credits to 'Alex de Mulder' for original implementation.
     *
     * @param {CanvasRenderingContext2D} ctx  context on which to draw zoomed image
     * @param {Float} factor scale factor at which to draw
     * @param {number} left
     * @param {number} top
     * @param {number} width
     * @param {number} height
     */

  }, {
    key: 'drawImageAtPosition',
    value: function drawImageAtPosition(ctx, factor, left, top, width, height) {
      if (!this.initialized()) return; //can't draw image yet not intialized

      if (factor > 2) {
        // Determine which zoomed image to use
        factor *= 0.5;
        var iterations = 0;
        while (factor > 2 && iterations < this.NUM_ITERATIONS) {
          factor *= 0.5;
          iterations += 1;
        }

        if (iterations >= this.NUM_ITERATIONS) {
          iterations = this.NUM_ITERATIONS - 1;
        }
        //console.log("iterations: " + iterations);

        var from = this.coordinates[iterations];
        ctx.drawImage(this.canvas, from[0], from[1], from[2], from[3], left, top, width, height);
      } else {
        // Draw image directly
        ctx.drawImage(this.image, left, top, width, height);
      }
    }
  }]);
  return CachedImage;
}();

exports['default'] = CachedImage;

/***/ }),
/* 134 */
/***/ (function(module, exports, __nested_webpack_require_700931__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __nested_webpack_require_700931__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_700931__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var util = __nested_webpack_require_700931__(2);

/**
 * This class can store groups and options specific for groups.
 */

var Groups = function () {
  /**
   * @ignore
   */
  function Groups() {
    (0, _classCallCheck3['default'])(this, Groups);

    this.clear();
    this.defaultIndex = 0;
    this.groupsArray = [];
    this.groupIndex = 0;

    this.defaultGroups = [{
      border: '#2B7CE9',
      background: '#97C2FC',
      highlight: { border: '#2B7CE9', background: '#D2E5FF' },
      hover: { border: '#2B7CE9', background: '#D2E5FF' }
    }, // 0: blue
    {
      border: '#FFA500',
      background: '#FFFF00',
      highlight: { border: '#FFA500', background: '#FFFFA3' },
      hover: { border: '#FFA500', background: '#FFFFA3' }
    }, // 1: yellow
    {
      border: '#FA0A10',
      background: '#FB7E81',
      highlight: { border: '#FA0A10', background: '#FFAFB1' },
      hover: { border: '#FA0A10', background: '#FFAFB1' }
    }, // 2: red
    {
      border: '#41A906',
      background: '#7BE141',
      highlight: { border: '#41A906', background: '#A1EC76' },
      hover: { border: '#41A906', background: '#A1EC76' }
    }, // 3: green
    {
      border: '#E129F0',
      background: '#EB7DF4',
      highlight: { border: '#E129F0', background: '#F0B3F5' },
      hover: { border: '#E129F0', background: '#F0B3F5' }
    }, // 4: magenta
    {
      border: '#7C29F0',
      background: '#AD85E4',
      highlight: { border: '#7C29F0', background: '#D3BDF0' },
      hover: { border: '#7C29F0', background: '#D3BDF0' }
    }, // 5: purple
    {
      border: '#C37F00',
      background: '#FFA807',
      highlight: { border: '#C37F00', background: '#FFCA66' },
      hover: { border: '#C37F00', background: '#FFCA66' }
    }, // 6: orange
    {
      border: '#4220FB',
      background: '#6E6EFD',
      highlight: { border: '#4220FB', background: '#9B9BFD' },
      hover: { border: '#4220FB', background: '#9B9BFD' }
    }, // 7: darkblue
    {
      border: '#FD5A77',
      background: '#FFC0CB',
      highlight: { border: '#FD5A77', background: '#FFD1D9' },
      hover: { border: '#FD5A77', background: '#FFD1D9' }
    }, // 8: pink
    {
      border: '#4AD63A',
      background: '#C2FABC',
      highlight: { border: '#4AD63A', background: '#E6FFE3' },
      hover: { border: '#4AD63A', background: '#E6FFE3' }
    }, // 9: mint

    {
      border: '#990000',
      background: '#EE0000',
      highlight: { border: '#BB0000', background: '#FF3333' },
      hover: { border: '#BB0000', background: '#FF3333' }
    }, // 10:bright red

    {
      border: '#FF6000',
      background: '#FF6000',
      highlight: { border: '#FF6000', background: '#FF6000' },
      hover: { border: '#FF6000', background: '#FF6000' }
    }, // 12: real orange
    {
      border: '#97C2FC',
      background: '#2B7CE9',
      highlight: { border: '#D2E5FF', background: '#2B7CE9' },
      hover: { border: '#D2E5FF', background: '#2B7CE9' }
    }, // 13: blue
    {
      border: '#399605',
      background: '#255C03',
      highlight: { border: '#399605', background: '#255C03' },
      hover: { border: '#399605', background: '#255C03' }
    }, // 14: green
    {
      border: '#B70054',
      background: '#FF007E',
      highlight: { border: '#B70054', background: '#FF007E' },
      hover: { border: '#B70054', background: '#FF007E' }
    }, // 15: magenta
    {
      border: '#AD85E4',
      background: '#7C29F0',
      highlight: { border: '#D3BDF0', background: '#7C29F0' },
      hover: { border: '#D3BDF0', background: '#7C29F0' }
    }, // 16: purple
    {
      border: '#4557FA',
      background: '#000EA1',
      highlight: { border: '#6E6EFD', background: '#000EA1' },
      hover: { border: '#6E6EFD', background: '#000EA1' }
    }, // 17: darkblue
    {
      border: '#FFC0CB',
      background: '#FD5A77',
      highlight: { border: '#FFD1D9', background: '#FD5A77' },
      hover: { border: '#FFD1D9', background: '#FD5A77' }
    }, // 18: pink
    {
      border: '#C2FABC',
      background: '#74D66A',
      highlight: { border: '#E6FFE3', background: '#74D66A' },
      hover: { border: '#E6FFE3', background: '#74D66A' }
    }, // 19: mint

    {
      border: '#EE0000',
      background: '#990000',
      highlight: { border: '#FF3333', background: '#BB0000' },
      hover: { border: '#FF3333', background: '#BB0000' } // 20:bright red
    }];

    this.options = {};
    this.defaultOptions = {
      useDefaultGroups: true
    };
    util.extend(this.options, this.defaultOptions);
  }

  /**
   *
   * @param {Object} options
   */


  (0, _createClass3['default'])(Groups, [{
    key: 'setOptions',
    value: function setOptions(options) {
      var optionFields = ['useDefaultGroups'];

      if (options !== undefined) {
        for (var groupName in options) {
          if (options.hasOwnProperty(groupName)) {
            if (optionFields.indexOf(groupName) === -1) {
              var group = options[groupName];
              this.add(groupName, group);
            }
          }
        }
      }
    }

    /**
     * Clear all groups
     */

  }, {
    key: 'clear',
    value: function clear() {
      this.groups = {};
      this.groupsArray = [];
    }

    /**
     * Get group options of a groupname.
     * If groupname is not found, a new group may be created.
     *
     * @param {*}       groupname     Can be a number, string, Date, etc.
     * @param {boolean} [shouldCreate=true] If true, create a new group
     * @return {Object} The found or created group
     */

  }, {
    key: 'get',
    value: function get(groupname) {
      var shouldCreate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      var group = this.groups[groupname];

      if (group === undefined && shouldCreate) {
        if (this.options.useDefaultGroups === false && this.groupsArray.length > 0) {
          // create new group
          var index = this.groupIndex % this.groupsArray.length;
          this.groupIndex++;
          group = {};
          group.color = this.groups[this.groupsArray[index]];
          this.groups[groupname] = group;
        } else {
          // create new group
          var _index = this.defaultIndex % this.defaultGroups.length;
          this.defaultIndex++;
          group = {};
          group.color = this.defaultGroups[_index];
          this.groups[groupname] = group;
        }
      }

      return group;
    }

    /**
     * Add a custom group style
     * @param {string} groupName
     * @param {Object} style       An object containing borderColor,
     *                             backgroundColor, etc.
     * @return {Object} group      The created group object
     */

  }, {
    key: 'add',
    value: function add(groupName, style) {
      this.groups[groupName] = style;
      this.groupsArray.push(groupName);
      return style;
    }
  }]);
  return Groups;
}();

exports['default'] = Groups;

/***/ }),
/* 135 */
/***/ (function(module, exports, __nested_webpack_require_708348__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __nested_webpack_require_708348__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_708348__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var util = __nested_webpack_require_708348__(2);
var DataSet = __nested_webpack_require_708348__(33);
var DataView = __nested_webpack_require_708348__(51);
var Node = __nested_webpack_require_708348__(34)['default'];

/**
 * Handler for Nodes
 */

var NodesHandler = function () {
  /**
   * @param {Object} body
   * @param {Images} images
   * @param {Array.<Group>} groups
   * @param {LayoutEngine} layoutEngine
   */
  function NodesHandler(body, images, groups, layoutEngine) {
    var _this = this;

    (0, _classCallCheck3['default'])(this, NodesHandler);

    this.body = body;
    this.images = images;
    this.groups = groups;
    this.layoutEngine = layoutEngine;

    // create the node API in the body container
    this.body.functions.createNode = this.create.bind(this);

    this.nodesListeners = {
      add: function add(event, params) {
        _this.add(params.items);
      },
      update: function update(event, params) {
        _this.update(params.items, params.data, params.oldData);
      },
      remove: function remove(event, params) {
        _this.remove(params.items);
      }
    };

    this.defaultOptions = {
      borderWidth: 1,
      borderWidthSelected: 2,
      brokenImage: undefined,
      color: {
        border: '#2B7CE9',
        background: '#97C2FC',
        highlight: {
          border: '#2B7CE9',
          background: '#D2E5FF'
        },
        hover: {
          border: '#2B7CE9',
          background: '#D2E5FF'
        }
      },
      fixed: {
        x: false,
        y: false
      },
      font: {
        color: '#343434',
        size: 14, // px
        face: 'arial',
        background: 'none',
        strokeWidth: 0, // px
        strokeColor: '#ffffff',
        align: 'center',
        vadjust: 0,
        multi: false,
        bold: {
          mod: 'bold'
        },
        boldital: {
          mod: 'bold italic'
        },
        ital: {
          mod: 'italic'
        },
        mono: {
          mod: '',
          size: 15, // px
          face: 'monospace',
          vadjust: 2
        }
      },
      group: undefined,
      hidden: false,
      icon: {
        face: 'FontAwesome', //'FontAwesome',
        code: undefined, //'\uf007',
        size: 50, //50,
        color: '#2B7CE9' //'#aa00ff'
      },
      image: undefined, // --> URL
      label: undefined,
      labelHighlightBold: true,
      level: undefined,
      margin: {
        top: 5,
        right: 5,
        bottom: 5,
        left: 5
      },
      mass: 1,
      physics: true,
      scaling: {
        min: 10,
        max: 30,
        label: {
          enabled: false,
          min: 14,
          max: 30,
          maxVisible: 30,
          drawThreshold: 5
        },
        customScalingFunction: function customScalingFunction(min, max, total, value) {
          if (max === min) {
            return 0.5;
          } else {
            var scale = 1 / (max - min);
            return Math.max(0, (value - min) * scale);
          }
        }
      },
      shadow: {
        enabled: false,
        color: 'rgba(0,0,0,0.5)',
        size: 10,
        x: 5,
        y: 5
      },
      shape: 'ellipse',
      shapeProperties: {
        borderDashes: false, // only for borders
        borderRadius: 6, // only for box shape
        interpolation: true, // only for image and circularImage shapes
        useImageSize: false, // only for image and circularImage shapes
        useBorderWithImage: false // only for image shape
      },
      size: 25,
      title: undefined,
      value: undefined,
      x: undefined,
      y: undefined

      // Protect from idiocy
    };if (this.defaultOptions.mass <= 0) {
      throw 'Internal error: mass in defaultOptions of NodesHandler may not be zero or negative';
    }

    this.options = util.bridgeObject(this.defaultOptions);

    this.bindEventListeners();
  }

  /**
   * Binds event listeners
   */


  (0, _createClass3['default'])(NodesHandler, [{
    key: 'bindEventListeners',
    value: function bindEventListeners() {
      var _this2 = this;

      // refresh the nodes. Used when reverting from hierarchical layout
      this.body.emitter.on('refreshNodes', this.refresh.bind(this));
      this.body.emitter.on('refresh', this.refresh.bind(this));
      this.body.emitter.on('destroy', function () {
        util.forEach(_this2.nodesListeners, function (callback, event) {
          if (_this2.body.data.nodes) _this2.body.data.nodes.off(event, callback);
        });
        delete _this2.body.functions.createNode;
        delete _this2.nodesListeners.add;
        delete _this2.nodesListeners.update;
        delete _this2.nodesListeners.remove;
        delete _this2.nodesListeners;
      });
    }

    /**
     *
     * @param {Object} options
     */

  }, {
    key: 'setOptions',
    value: function setOptions(options) {
      if (options !== undefined) {
        Node.parseOptions(this.options, options);

        // update the shape in all nodes
        if (options.shape !== undefined) {
          for (var nodeId in this.body.nodes) {
            if (this.body.nodes.hasOwnProperty(nodeId)) {
              this.body.nodes[nodeId].updateShape();
            }
          }
        }

        // update the font in all nodes
        if (options.font !== undefined) {
          for (var _nodeId in this.body.nodes) {
            if (this.body.nodes.hasOwnProperty(_nodeId)) {
              this.body.nodes[_nodeId].updateLabelModule();
              this.body.nodes[_nodeId].needsRefresh();
            }
          }
        }

        // update the shape size in all nodes
        if (options.size !== undefined) {
          for (var _nodeId2 in this.body.nodes) {
            if (this.body.nodes.hasOwnProperty(_nodeId2)) {
              this.body.nodes[_nodeId2].needsRefresh();
            }
          }
        }

        // update the state of the variables if needed
        if (options.hidden !== undefined || options.physics !== undefined) {
          this.body.emitter.emit('_dataChanged');
        }
      }
    }

    /**
     * Set a data set with nodes for the network
     * @param {Array | DataSet | DataView} nodes         The data containing the nodes.
     * @param {boolean} [doNotEmit=false]
     * @private
     */

  }, {
    key: 'setData',
    value: function setData(nodes) {
      var doNotEmit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var oldNodesData = this.body.data.nodes;

      if (nodes instanceof DataSet || nodes instanceof DataView) {
        this.body.data.nodes = nodes;
      } else if (Array.isArray(nodes)) {
        this.body.data.nodes = new DataSet();
        this.body.data.nodes.add(nodes);
      } else if (!nodes) {
        this.body.data.nodes = new DataSet();
      } else {
        throw new TypeError('Array or DataSet expected');
      }

      if (oldNodesData) {
        // unsubscribe from old dataset
        util.forEach(this.nodesListeners, function (callback, event) {
          oldNodesData.off(event, callback);
        });
      }

      // remove drawn nodes
      this.body.nodes = {};

      if (this.body.data.nodes) {
        // subscribe to new dataset
        var me = this;
        util.forEach(this.nodesListeners, function (callback, event) {
          me.body.data.nodes.on(event, callback);
        });

        // draw all new nodes
        var ids = this.body.data.nodes.getIds();
        this.add(ids, true);
      }

      if (doNotEmit === false) {
        this.body.emitter.emit('_dataChanged');
      }
    }

    /**
     * Add nodes
     * @param {number[] | string[]} ids
     * @param {boolean} [doNotEmit=false]
     * @private
     */

  }, {
    key: 'add',
    value: function add(ids) {
      var doNotEmit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var id = void 0;
      var newNodes = [];
      for (var i = 0; i < ids.length; i++) {
        id = ids[i];
        var properties = this.body.data.nodes.get(id);
        var node = this.create(properties);
        newNodes.push(node);
        this.body.nodes[id] = node; // note: this may replace an existing node
      }

      this.layoutEngine.positionInitially(newNodes);

      if (doNotEmit === false) {
        this.body.emitter.emit('_dataChanged');
      }
    }

    /**
     * Update existing nodes, or create them when not yet existing
     * @param {number[] | string[]} ids id's of changed nodes
     * @param {Array} changedData array with changed data
     * @param {Array|undefined} oldData optional; array with previous data
     * @private
     */

  }, {
    key: 'update',
    value: function update(ids, changedData, oldData) {
      var nodes = this.body.nodes;
      var dataChanged = false;
      for (var i = 0; i < ids.length; i++) {
        var id = ids[i];
        var node = nodes[id];
        var data = changedData[i];
        if (node !== undefined) {
          // update node
          if (node.setOptions(data)) {
            dataChanged = true;
          }
        } else {
          dataChanged = true;
          // create node
          node = this.create(data);
          nodes[id] = node;
        }
      }

      if (!dataChanged && oldData !== undefined) {
        // Check for any changes which should trigger a layout recalculation
        // For now, this is just 'level' for hierarchical layout
        // Assumption: old and new data arranged in same order; at time of writing, this holds.
        dataChanged = changedData.some(function (newValue, index) {
          var oldValue = oldData[index];
          return oldValue && oldValue.level !== newValue.level;
        });
      }

      if (dataChanged === true) {
        this.body.emitter.emit('_dataChanged');
      } else {
        this.body.emitter.emit('_dataUpdated');
      }
    }

    /**
     * Remove existing nodes. If nodes do not exist, the method will just ignore it.
     * @param {number[] | string[]} ids
     * @private
     */

  }, {
    key: 'remove',
    value: function remove(ids) {
      var nodes = this.body.nodes;

      for (var i = 0; i < ids.length; i++) {
        var id = ids[i];
        delete nodes[id];
      }

      this.body.emitter.emit('_dataChanged');
    }

    /**
     * create a node
     * @param {Object} properties
     * @param {class} [constructorClass=Node.default]
     * @returns {*}
     */

  }, {
    key: 'create',
    value: function create(properties) {
      var constructorClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Node;

      return new constructorClass(properties, this.body, this.images, this.groups, this.options, this.defaultOptions);
    }

    /**
     *
     * @param {boolean} [clearPositions=false]
     */

  }, {
    key: 'refresh',
    value: function refresh() {
      var _this3 = this;

      var clearPositions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      util.forEach(this.body.nodes, function (node, nodeId) {
        var data = _this3.body.data.nodes.get(nodeId);
        if (data !== undefined) {
          if (clearPositions === true) {
            node.setOptions({ x: null, y: null });
          }
          node.setOptions({ fixed: false });
          node.setOptions(data);
        }
      });
    }

    /**
     * Returns the positions of the nodes.
     * @param {Array.<Node.id>|String} [ids]  --> optional, can be array of nodeIds, can be string
     * @returns {{}}
     */

  }, {
    key: 'getPositions',
    value: function getPositions(ids) {
      var dataArray = {};
      if (ids !== undefined) {
        if (Array.isArray(ids) === true) {
          for (var i = 0; i < ids.length; i++) {
            if (this.body.nodes[ids[i]] !== undefined) {
              var node = this.body.nodes[ids[i]];
              dataArray[ids[i]] = { x: Math.round(node.x), y: Math.round(node.y) };
            }
          }
        } else {
          if (this.body.nodes[ids] !== undefined) {
            var _node = this.body.nodes[ids];
            dataArray[ids] = { x: Math.round(_node.x), y: Math.round(_node.y) };
          }
        }
      } else {
        for (var _i = 0; _i < this.body.nodeIndices.length; _i++) {
          var _node2 = this.body.nodes[this.body.nodeIndices[_i]];
          dataArray[this.body.nodeIndices[_i]] = {
            x: Math.round(_node2.x),
            y: Math.round(_node2.y)
          };
        }
      }
      return dataArray;
    }

    /**
     * Load the XY positions of the nodes into the dataset.
     */

  }, {
    key: 'storePositions',
    value: function storePositions() {
      // todo: add support for clusters and hierarchical.
      var dataArray = [];
      var dataset = this.body.data.nodes.getDataSet();

      for (var nodeId in dataset._data) {
        if (dataset._data.hasOwnProperty(nodeId)) {
          var node = this.body.nodes[nodeId];
          if (dataset._data[nodeId].x != Math.round(node.x) || dataset._data[nodeId].y != Math.round(node.y)) {
            dataArray.push({
              id: node.id,
              x: Math.round(node.x),
              y: Math.round(node.y)
            });
          }
        }
      }
      dataset.update(dataArray);
    }

    /**
     * get the bounding box of a node.
     * @param {Node.id} nodeId
     * @returns {j|*}
     */

  }, {
    key: 'getBoundingBox',
    value: function getBoundingBox(nodeId) {
      if (this.body.nodes[nodeId] !== undefined) {
        return this.body.nodes[nodeId].shape.boundingBox;
      }
    }

    /**
     * Get the Ids of nodes connected to this node.
     * @param {Node.id} nodeId
     * @param {'to'|'from'|undefined} direction values 'from' and 'to' select respectively parent and child nodes only.
     *                                          Any other value returns both parent and child nodes.
     * @returns {Array}
     */

  }, {
    key: 'getConnectedNodes',
    value: function getConnectedNodes(nodeId, direction) {
      var nodeList = [];
      if (this.body.nodes[nodeId] !== undefined) {
        var node = this.body.nodes[nodeId];
        var nodeObj = {}; // used to quickly check if node already exists
        for (var i = 0; i < node.edges.length; i++) {
          var edge = node.edges[i];
          if (direction !== 'to' && edge.toId == node.id) {
            // these are double equals since ids can be numeric or string
            if (nodeObj[edge.fromId] === undefined) {
              nodeList.push(edge.fromId);
              nodeObj[edge.fromId] = true;
            }
          } else if (direction !== 'from' && edge.fromId == node.id) {
            // these are double equals since ids can be numeric or string
            if (nodeObj[edge.toId] === undefined) {
              nodeList.push(edge.toId);
              nodeObj[edge.toId] = true;
            }
          }
        }
      }
      return nodeList;
    }

    /**
     * Get the ids of the edges connected to this node.
     * @param {Node.id} nodeId
     * @returns {*}
     */

  }, {
    key: 'getConnectedEdges',
    value: function getConnectedEdges(nodeId) {
      var edgeList = [];
      if (this.body.nodes[nodeId] !== undefined) {
        var node = this.body.nodes[nodeId];
        for (var i = 0; i < node.edges.length; i++) {
          edgeList.push(node.edges[i].id);
        }
      } else {
        console.log('NodeId provided for getConnectedEdges does not exist. Provided: ', nodeId);
      }
      return edgeList;
    }

    /**
     * Move a node.
     *
     * @param {Node.id} nodeId
     * @param {number} x
     * @param {number} y
     */

  }, {
    key: 'moveNode',
    value: function moveNode(nodeId, x, y) {
      var _this4 = this;

      if (this.body.nodes[nodeId] !== undefined) {
        this.body.nodes[nodeId].x = Number(x);
        this.body.nodes[nodeId].y = Number(y);
        setTimeout(function () {
          _this4.body.emitter.emit('startSimulation');
        }, 0);
      } else {
        console.log('Node id supplied to moveNode does not exist. Provided: ', nodeId);
      }
    }
  }]);
  return NodesHandler;
}();

exports['default'] = NodesHandler;

/***/ }),
/* 136 */
/***/ (function(module, exports, __nested_webpack_require_724960__) {

module.exports = { "default": __nested_webpack_require_724960__(137), __esModule: true };

/***/ }),
/* 137 */
/***/ (function(module, exports, __nested_webpack_require_725114__) {

__nested_webpack_require_725114__(37);
__nested_webpack_require_725114__(47);
module.exports = __nested_webpack_require_725114__(138);


/***/ }),
/* 138 */
/***/ (function(module, exports, __nested_webpack_require_725286__) {

var classof = __nested_webpack_require_725286__(67);
var ITERATOR = __nested_webpack_require_725286__(8)('iterator');
var Iterators = __nested_webpack_require_725286__(25);
module.exports = __nested_webpack_require_725286__(6).isIterable = function (it) {
  var O = Object(it);
  return O[ITERATOR] !== undefined
    || '@@iterator' in O
    // eslint-disable-next-line no-prototype-builtins
    || Iterators.hasOwnProperty(classof(O));
};


/***/ }),
/* 139 */
/***/ (function(module, exports, __nested_webpack_require_725749__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray2 = __nested_webpack_require_725749__(15);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _classCallCheck2 = __nested_webpack_require_725749__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_725749__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var LabelAccumulator = __nested_webpack_require_725749__(140)['default'];
var ComponentUtil = __nested_webpack_require_725749__(35)['default'];

// Hash of prepared regexp's for tags
var tagPattern = {
  // HTML
  '<b>': /<b>/,
  '<i>': /<i>/,
  '<code>': /<code>/,
  '</b>': /<\/b>/,
  '</i>': /<\/i>/,
  '</code>': /<\/code>/,
  // Markdown
  '*': /\*/, // bold
  _: /\_/, // ital
  '`': /`/, // mono
  afterBold: /[^\*]/,
  afterItal: /[^_]/,
  afterMono: /[^`]/

  /**
   * Internal helper class for parsing the markup tags for HTML and Markdown.
   *
   * NOTE: Sequences of tabs and spaces are reduced to single space.
   *       Scan usage of `this.spacing` within method
   */
};
var MarkupAccumulator = function () {
  /**
   * Create an instance
   *
   * @param {string} text  text to parse for markup
   */
  function MarkupAccumulator(text) {
    (0, _classCallCheck3['default'])(this, MarkupAccumulator);

    this.text = text;
    this.bold = false;
    this.ital = false;
    this.mono = false;
    this.spacing = false;
    this.position = 0;
    this.buffer = '';
    this.modStack = [];

    this.blocks = [];
  }

  /**
   * Return the mod label currently on the top of the stack
   *
   * @returns {string}  label of topmost mod
   * @private
   */


  (0, _createClass3['default'])(MarkupAccumulator, [{
    key: 'mod',
    value: function mod() {
      return this.modStack.length === 0 ? 'normal' : this.modStack[0];
    }

    /**
     * Return the mod label currently active
     *
     * @returns {string}  label of active mod
     * @private
     */

  }, {
    key: 'modName',
    value: function modName() {
      if (this.modStack.length === 0) return 'normal';else if (this.modStack[0] === 'mono') return 'mono';else {
        if (this.bold && this.ital) {
          return 'boldital';
        } else if (this.bold) {
          return 'bold';
        } else if (this.ital) {
          return 'ital';
        }
      }
    }

    /**
     * @private
     */

  }, {
    key: 'emitBlock',
    value: function emitBlock() {
      if (this.spacing) {
        this.add(' ');
        this.spacing = false;
      }
      if (this.buffer.length > 0) {
        this.blocks.push({ text: this.buffer, mod: this.modName() });
        this.buffer = '';
      }
    }

    /**
     * Output text to buffer
     *
     * @param {string} text  text to add
     * @private
     */

  }, {
    key: 'add',
    value: function add(text) {
      if (text === ' ') {
        this.spacing = true;
      }
      if (this.spacing) {
        this.buffer += ' ';
        this.spacing = false;
      }
      if (text != ' ') {
        this.buffer += text;
      }
    }

    /**
     * Handle parsing of whitespace
     *
     * @param {string} ch  the character to check
     * @returns {boolean} true if the character was processed as whitespace, false otherwise
     */

  }, {
    key: 'parseWS',
    value: function parseWS(ch) {
      if (/[ \t]/.test(ch)) {
        if (!this.mono) {
          this.spacing = true;
        } else {
          this.add(ch);
        }
        return true;
      }

      return false;
    }

    /**
     * @param {string} tagName  label for block type to set
     * @private
     */

  }, {
    key: 'setTag',
    value: function setTag(tagName) {
      this.emitBlock();
      this[tagName] = true;
      this.modStack.unshift(tagName);
    }

    /**
     * @param {string} tagName  label for block type to unset
     * @private
     */

  }, {
    key: 'unsetTag',
    value: function unsetTag(tagName) {
      this.emitBlock();
      this[tagName] = false;
      this.modStack.shift();
    }

    /**
     * @param {string} tagName label for block type we are currently processing
     * @param {string|RegExp} tag string to match in text
     * @returns {boolean} true if the tag was processed, false otherwise
     */

  }, {
    key: 'parseStartTag',
    value: function parseStartTag(tagName, tag) {
      // Note: if 'mono' passed as tagName, there is a double check here. This is OK
      if (!this.mono && !this[tagName] && this.match(tag)) {
        this.setTag(tagName);
        return true;
      }

      return false;
    }

    /**
     * @param {string|RegExp} tag
     * @param {number} [advance=true] if set, advance current position in text
     * @returns {boolean} true if match at given position, false otherwise
     * @private
     */

  }, {
    key: 'match',
    value: function match(tag) {
      var advance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      var _prepareRegExp = this.prepareRegExp(tag),
          _prepareRegExp2 = (0, _slicedToArray3['default'])(_prepareRegExp, 2),
          regExp = _prepareRegExp2[0],
          length = _prepareRegExp2[1];

      var matched = regExp.test(this.text.substr(this.position, length));

      if (matched && advance) {
        this.position += length - 1;
      }

      return matched;
    }

    /**
     * @param {string} tagName label for block type we are currently processing
     * @param {string|RegExp} tag string to match in text
     * @param {RegExp} [nextTag] regular expression to match for characters *following* the current tag
     * @returns {boolean} true if the tag was processed, false otherwise
     */

  }, {
    key: 'parseEndTag',
    value: function parseEndTag(tagName, tag, nextTag) {
      var checkTag = this.mod() === tagName;
      if (tagName === 'mono') {
        // special handling for 'mono'
        checkTag = checkTag && this.mono;
      } else {
        checkTag = checkTag && !this.mono;
      }

      if (checkTag && this.match(tag)) {
        if (nextTag !== undefined) {
          // Purpose of the following match is to prevent a direct unset/set of a given tag
          // E.g. '*bold **still bold*' => '*bold still bold*'
          if (this.position === this.text.length - 1 || this.match(nextTag, false)) {
            this.unsetTag(tagName);
          }
        } else {
          this.unsetTag(tagName);
        }

        return true;
      }

      return false;
    }

    /**
     * @param {string|RegExp} tag  string to match in text
     * @param {value} value  string to replace tag with, if found at current position
     * @returns {boolean} true if the tag was processed, false otherwise
     */

  }, {
    key: 'replace',
    value: function replace(tag, value) {
      if (this.match(tag)) {
        this.add(value);
        this.position += length - 1;
        return true;
      }

      return false;
    }

    /**
     * Create a regular expression for the tag if it isn't already one.
     *
     * The return value is an array `[RegExp, number]`, with exactly two value, where:
     *  - RegExp is the regular expression to use
     *  - number is the lenth of the input string to match
     *
     * @param {string|RegExp} tag  string to match in text
     * @returns {Array}  regular expression to use and length of input string to match
     * @private
     */

  }, {
    key: 'prepareRegExp',
    value: function prepareRegExp(tag) {
      var length = void 0;
      var regExp = void 0;
      if (tag instanceof RegExp) {
        regExp = tag;
        length = 1; // ASSUMPTION: regexp only tests one character
      } else {
        // use prepared regexp if present
        var prepared = tagPattern[tag];
        if (prepared !== undefined) {
          regExp = prepared;
        } else {
          regExp = new RegExp(tag);
        }

        length = tag.length;
      }

      return [regExp, length];
    }
  }]);
  return MarkupAccumulator;
}();

/**
 * Helper class for Label which explodes the label text into lines and blocks within lines
 *
 * @private
 */


var LabelSplitter = function () {
  /**
   * @param {CanvasRenderingContext2D} ctx Canvas rendering context
   * @param {Label} parent reference to the Label instance using current instance
   * @param {boolean} selected
   * @param {boolean} hover
   */
  function LabelSplitter(ctx, parent, selected, hover) {
    var _this = this;

    (0, _classCallCheck3['default'])(this, LabelSplitter);

    this.ctx = ctx;
    this.parent = parent;

    /**
     * Callback to determine text width; passed to LabelAccumulator instance
     *
     * @param  {String} text string to determine width of
     * @param  {String} mod  font type to use for this text
     * @return {Object} { width, values} width in pixels and font attributes
     */
    var textWidth = function textWidth(text, mod) {
      if (text === undefined) return 0;

      // TODO: This can be done more efficiently with caching
      var values = _this.parent.getFormattingValues(ctx, selected, hover, mod);

      var width = 0;
      if (text !== '') {
        // NOTE: The following may actually be *incorrect* for the mod fonts!
        //       This returns the size with a regular font, bold etc. may
        //       have different sizes.
        var measure = _this.ctx.measureText(text);
        width = measure.width;
      }

      return { width: width, values: values };
    };

    this.lines = new LabelAccumulator(textWidth);
  }

  /**
   * Split passed text of a label into lines and blocks.
   *
   * # NOTE
   *
   * The handling of spacing is option dependent:
   *
   * - if `font.multi : false`, all spaces are retained
   * - if `font.multi : true`, every sequence of spaces is compressed to a single space
   *
   * This might not be the best way to do it, but this is as it has been working till now.
   * In order not to break existing functionality, for the time being this behaviour will
   * be retained in any code changes.
   *
   * @param {string} text  text to split
   * @returns {Array<line>}
   */


  (0, _createClass3['default'])(LabelSplitter, [{
    key: 'process',
    value: function process(text) {
      if (!ComponentUtil.isValidLabel(text)) {
        return this.lines.finalize();
      }

      var font = this.parent.fontOptions;

      // Normalize the end-of-line's to a single representation - order important
      text = text.replace(/\r\n/g, '\n'); // Dos EOL's
      text = text.replace(/\r/g, '\n'); // Mac EOL's

      // Note that at this point, there can be no \r's in the text.
      // This is used later on splitStringIntoLines() to split multifont texts.

      var nlLines = String(text).split('\n');
      var lineCount = nlLines.length;

      if (font.multi) {
        // Multi-font case: styling tags active
        for (var i = 0; i < lineCount; i++) {
          var blocks = this.splitBlocks(nlLines[i], font.multi);
          // Post: Sequences of tabs and spaces are reduced to single space

          if (blocks === undefined) continue;

          if (blocks.length === 0) {
            this.lines.newLine('');
            continue;
          }

          if (font.maxWdt > 0) {
            // widthConstraint.maximum defined
            //console.log('Running widthConstraint multi, max: ' + this.fontOptions.maxWdt);
            for (var j = 0; j < blocks.length; j++) {
              var mod = blocks[j].mod;
              var _text = blocks[j].text;
              this.splitStringIntoLines(_text, mod, true);
            }
          } else {
            // widthConstraint.maximum NOT defined
            for (var _j = 0; _j < blocks.length; _j++) {
              var _mod = blocks[_j].mod;
              var _text2 = blocks[_j].text;
              this.lines.append(_text2, _mod);
            }
          }

          this.lines.newLine();
        }
      } else {
        // Single-font case
        if (font.maxWdt > 0) {
          // widthConstraint.maximum defined
          // console.log('Running widthConstraint normal, max: ' + this.fontOptions.maxWdt);
          for (var _i = 0; _i < lineCount; _i++) {
            this.splitStringIntoLines(nlLines[_i]);
          }
        } else {
          // widthConstraint.maximum NOT defined
          for (var _i2 = 0; _i2 < lineCount; _i2++) {
            this.lines.newLine(nlLines[_i2]);
          }
        }
      }

      return this.lines.finalize();
    }

    /**
     * normalize the markup system
     *
     * @param {boolean|'md'|'markdown'|'html'} markupSystem
     * @returns {string}
     */

  }, {
    key: 'decodeMarkupSystem',
    value: function decodeMarkupSystem(markupSystem) {
      var system = 'none';
      if (markupSystem === 'markdown' || markupSystem === 'md') {
        system = 'markdown';
      } else if (markupSystem === true || markupSystem === 'html') {
        system = 'html';
      }
      return system;
    }

    /**
     *
     * @param {string} text
     * @returns {Array}
     */

  }, {
    key: 'splitHtmlBlocks',
    value: function splitHtmlBlocks(text) {
      var s = new MarkupAccumulator(text);

      var parseEntities = function parseEntities(ch) {
        if (/&/.test(ch)) {
          var parsed = s.replace(s.text, '&lt;', '<') || s.replace(s.text, '&amp;', '&');

          if (!parsed) {
            s.add('&');
          }

          return true;
        }

        return false;
      };

      while (s.position < s.text.length) {
        var ch = s.text.charAt(s.position);

        var parsed = s.parseWS(ch) || /</.test(ch) && (s.parseStartTag('bold', '<b>') || s.parseStartTag('ital', '<i>') || s.parseStartTag('mono', '<code>') || s.parseEndTag('bold', '</b>') || s.parseEndTag('ital', '</i>') || s.parseEndTag('mono', '</code>')) || parseEntities(ch);

        if (!parsed) {
          s.add(ch);
        }
        s.position++;
      }
      s.emitBlock();
      return s.blocks;
    }

    /**
     *
     * @param {string} text
     * @returns {Array}
     */

  }, {
    key: 'splitMarkdownBlocks',
    value: function splitMarkdownBlocks(text) {
      var _this2 = this;

      var s = new MarkupAccumulator(text);
      var beginable = true;

      var parseOverride = function parseOverride(ch) {
        if (/\\/.test(ch)) {
          if (s.position < _this2.text.length + 1) {
            s.position++;
            ch = _this2.text.charAt(s.position);
            if (/ \t/.test(ch)) {
              s.spacing = true;
            } else {
              s.add(ch);
              beginable = false;
            }
          }

          return true;
        }

        return false;
      };

      while (s.position < s.text.length) {
        var ch = s.text.charAt(s.position);

        var parsed = s.parseWS(ch) || parseOverride(ch) || (beginable || s.spacing) && (s.parseStartTag('bold', '*') || s.parseStartTag('ital', '_') || s.parseStartTag('mono', '`')) || s.parseEndTag('bold', '*', 'afterBold') || s.parseEndTag('ital', '_', 'afterItal') || s.parseEndTag('mono', '`', 'afterMono');

        if (!parsed) {
          s.add(ch);
          beginable = false;
        }
        s.position++;
      }
      s.emitBlock();
      return s.blocks;
    }

    /**
     * Explodes a piece of text into single-font blocks using a given markup
     *
     * @param {string} text
     * @param {boolean|'md'|'markdown'|'html'} markupSystem
     * @returns {Array.<{text: string, mod: string}>}
     * @private
     */

  }, {
    key: 'splitBlocks',
    value: function splitBlocks(text, markupSystem) {
      var system = this.decodeMarkupSystem(markupSystem);
      if (system === 'none') {
        return [{
          text: text,
          mod: 'normal'
        }];
      } else if (system === 'markdown') {
        return this.splitMarkdownBlocks(text);
      } else if (system === 'html') {
        return this.splitHtmlBlocks(text);
      }
    }

    /**
     * @param {string} text
     * @returns {boolean} true if text length over the current max with
     * @private
     */

  }, {
    key: 'overMaxWidth',
    value: function overMaxWidth(text) {
      var width = this.ctx.measureText(text).width;
      return this.lines.curWidth() + width > this.parent.fontOptions.maxWdt;
    }

    /**
     * Determine the longest part of the sentence which still fits in the
     * current max width.
     *
     * @param {Array} words  Array of strings signifying a text lines
     * @return {number}      index of first item in string making string go over max
     * @private
     */

  }, {
    key: 'getLongestFit',
    value: function getLongestFit(words) {
      var text = '';
      var w = 0;

      while (w < words.length) {
        var pre = text === '' ? '' : ' ';
        var newText = text + pre + words[w];

        if (this.overMaxWidth(newText)) break;
        text = newText;
        w++;
      }

      return w;
    }

    /**
     * Determine the longest part of the string which still fits in the
     * current max width.
     *
     * @param {Array} words Array of strings signifying a text lines
     * @return {number} index of first item in string making string go over max
     */

  }, {
    key: 'getLongestFitWord',
    value: function getLongestFitWord(words) {
      var w = 0;

      while (w < words.length) {
        if (this.overMaxWidth(words.slice(0, w))) break;
        w++;
      }

      return w;
    }

    /**
     * Split the passed text into lines, according to width constraint (if any).
     *
     * The method assumes that the input string is a single line, i.e. without lines break.
     *
     * This method retains spaces, if still present (case `font.multi: false`).
     * A space which falls on an internal line break, will be replaced by a newline.
     * There is no special handling of tabs; these go along with the flow.
     *
     * @param {string} str
     * @param {string} [mod='normal']
     * @param {boolean} [appendLast=false]
     * @private
     */

  }, {
    key: 'splitStringIntoLines',
    value: function splitStringIntoLines(str) {
      var mod = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'normal';
      var appendLast = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      // Still-present spaces are relevant, retain them
      str = str.replace(/^( +)/g, '$1\r');
      str = str.replace(/([^\r][^ ]*)( +)/g, '$1\r$2\r');
      var words = str.split('\r');

      while (words.length > 0) {
        var w = this.getLongestFit(words);

        if (w === 0) {
          // Special case: the first word is already larger than the max width.
          var word = words[0];

          // Break the word to the largest part that fits the line
          var x = this.getLongestFitWord(word);
          this.lines.newLine(word.slice(0, x), mod);

          // Adjust the word, so that the rest will be done next iteration
          words[0] = word.slice(x);
        } else {
          // skip any space that is replaced by a newline
          var newW = w;
          if (words[w - 1] === ' ') {
            w--;
          } else if (words[newW] === ' ') {
            newW++;
          }

          var text = words.slice(0, w).join('');

          if (w == words.length && appendLast) {
            this.lines.append(text, mod);
          } else {
            this.lines.newLine(text, mod);
          }

          // Adjust the word, so that the rest will be done next iteration
          words = words.slice(newW);
        }
      }
    }
  }]);
  return LabelSplitter;
}();

exports['default'] = LabelSplitter;

/***/ }),
/* 140 */
/***/ (function(module, exports, __nested_webpack_require_745539__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = __nested_webpack_require_745539__(78);

var _assign2 = _interopRequireDefault(_assign);

var _classCallCheck2 = __nested_webpack_require_745539__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_745539__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * Callback to determine text dimensions, using the parent label settings.
 * @callback MeasureText
 * @param {text} text
 * @param {text} mod
 * @return {Object} { width, values} width in pixels and font attributes
 */

/**
 * Helper class for Label which collects results of splitting labels into lines and blocks.
 *
 * @private
 */
var LabelAccumulator = function () {
  /**
   * @param {MeasureText} measureText
   */
  function LabelAccumulator(measureText) {
    (0, _classCallCheck3['default'])(this, LabelAccumulator);

    this.measureText = measureText;
    this.current = 0;
    this.width = 0;
    this.height = 0;
    this.lines = [];
  }

  /**
   * Append given text to the given line.
   *
   * @param {number}  l    index of line to add to
   * @param {string}  text string to append to line
   * @param {'bold'|'ital'|'boldital'|'mono'|'normal'} [mod='normal']
   * @private
   */


  (0, _createClass3['default'])(LabelAccumulator, [{
    key: '_add',
    value: function _add(l, text) {
      var mod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'normal';

      if (this.lines[l] === undefined) {
        this.lines[l] = {
          width: 0,
          height: 0,
          blocks: []
        };
      }

      // We still need to set a block for undefined and empty texts, hence return at this point
      // This is necessary because we don't know at this point if we're at the
      // start of an empty line or not.
      // To compensate, empty blocks are removed in `finalize()`.
      //
      // Empty strings should still have a height
      var tmpText = text;
      if (text === undefined || text === '') tmpText = ' ';

      // Determine width and get the font properties
      var result = this.measureText(tmpText, mod);
      var block = (0, _assign2['default'])({}, result.values);
      block.text = text;
      block.width = result.width;
      block.mod = mod;

      if (text === undefined || text === '') {
        block.width = 0;
      }

      this.lines[l].blocks.push(block);

      // Update the line width. We need this for determining if a string goes over max width
      this.lines[l].width += block.width;
    }

    /**
     * Returns the width in pixels of the current line.
     *
     * @returns {number}
     */

  }, {
    key: 'curWidth',
    value: function curWidth() {
      var line = this.lines[this.current];
      if (line === undefined) return 0;

      return line.width;
    }

    /**
     * Add text in block to current line
     *
     * @param {string} text
     * @param {'bold'|'ital'|'boldital'|'mono'|'normal'} [mod='normal']
     */

  }, {
    key: 'append',
    value: function append(text) {
      var mod = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'normal';

      this._add(this.current, text, mod);
    }

    /**
     * Add text in block to current line and start a new line
     *
     * @param {string} text
     * @param {'bold'|'ital'|'boldital'|'mono'|'normal'} [mod='normal']
     */

  }, {
    key: 'newLine',
    value: function newLine(text) {
      var mod = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'normal';

      this._add(this.current, text, mod);
      this.current++;
    }

    /**
     * Determine and set the heights of all the lines currently contained in this instance
     *
     * Note that width has already been set.
     *
     * @private
     */

  }, {
    key: 'determineLineHeights',
    value: function determineLineHeights() {
      for (var k = 0; k < this.lines.length; k++) {
        var line = this.lines[k];

        // Looking for max height of blocks in line
        var height = 0;

        if (line.blocks !== undefined) {
          // Can happen if text contains e.g. '\n '
          for (var l = 0; l < line.blocks.length; l++) {
            var block = line.blocks[l];

            if (height < block.height) {
              height = block.height;
            }
          }
        }

        line.height = height;
      }
    }

    /**
     * Determine the full size of the label text, as determined by current lines and blocks
     *
     * @private
     */

  }, {
    key: 'determineLabelSize',
    value: function determineLabelSize() {
      var width = 0;
      var height = 0;
      for (var k = 0; k < this.lines.length; k++) {
        var line = this.lines[k];

        if (line.width > width) {
          width = line.width;
        }
        height += line.height;
      }

      this.width = width;
      this.height = height;
    }

    /**
     * Remove all empty blocks and empty lines we don't need
     *
     * This must be done after the width/height determination,
     * so that these are set properly for processing here.
     *
     * @returns {Array<Line>} Lines with empty blocks (and some empty lines) removed
     * @private
     */

  }, {
    key: 'removeEmptyBlocks',
    value: function removeEmptyBlocks() {
      var tmpLines = [];
      for (var k = 0; k < this.lines.length; k++) {
        var line = this.lines[k];

        // Note: an empty line in between text has width zero but is still relevant to layout.
        // So we can't use width for testing empty line here
        if (line.blocks.length === 0) continue;

        // Discard final empty line always
        if (k === this.lines.length - 1) {
          if (line.width === 0) continue;
        }

        var tmpLine = {};
        (0, _assign2['default'])(tmpLine, line);
        tmpLine.blocks = [];

        var firstEmptyBlock = void 0;
        var tmpBlocks = [];
        for (var l = 0; l < line.blocks.length; l++) {
          var block = line.blocks[l];
          if (block.width !== 0) {
            tmpBlocks.push(block);
          } else {
            if (firstEmptyBlock === undefined) {
              firstEmptyBlock = block;
            }
          }
        }

        // Ensure that there is *some* text present
        if (tmpBlocks.length === 0 && firstEmptyBlock !== undefined) {
          tmpBlocks.push(firstEmptyBlock);
        }

        tmpLine.blocks = tmpBlocks;

        tmpLines.push(tmpLine);
      }

      return tmpLines;
    }

    /**
     * Set the sizes for all lines and the whole thing.
     *
     * @returns {{width: (number|*), height: (number|*), lines: Array}}
     */

  }, {
    key: 'finalize',
    value: function finalize() {
      //console.log(JSON.stringify(this.lines, null, 2));

      this.determineLineHeights();
      this.determineLabelSize();
      var tmpLines = this.removeEmptyBlocks();

      // Return a simple hash object for further processing.
      return {
        width: this.width,
        height: this.height,
        lines: tmpLines
      };
    }
  }]);
  return LabelAccumulator;
}();

exports['default'] = LabelAccumulator;

/***/ }),
/* 141 */
/***/ (function(module, exports, __nested_webpack_require_752922__) {

__nested_webpack_require_752922__(142);
module.exports = __nested_webpack_require_752922__(6).Object.assign;


/***/ }),
/* 142 */
/***/ (function(module, exports, __nested_webpack_require_753082__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __nested_webpack_require_753082__(11);

$export($export.S + $export.F, 'Object', { assign: __nested_webpack_require_753082__(143) });


/***/ }),
/* 143 */
/***/ (function(module, exports, __nested_webpack_require_753323__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = __nested_webpack_require_753323__(26);
var gOPS = __nested_webpack_require_753323__(50);
var pIE = __nested_webpack_require_753323__(32);
var toObject = __nested_webpack_require_753323__(30);
var IObject = __nested_webpack_require_753323__(59);
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __nested_webpack_require_753323__(22)(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;


/***/ }),
/* 144 */
/***/ (function(module, exports, __nested_webpack_require_754599__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = __nested_webpack_require_754599__(3);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __nested_webpack_require_754599__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_754599__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __nested_webpack_require_754599__(4);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __nested_webpack_require_754599__(5);

var _inherits3 = _interopRequireDefault(_inherits2);

var _NodeBase2 = __nested_webpack_require_754599__(16);

var _NodeBase3 = _interopRequireDefault(_NodeBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * A Box Node/Cluster shape.
 *
 * @extends NodeBase
 */
var Box = function (_NodeBase) {
  (0, _inherits3['default'])(Box, _NodeBase);

  /**
   * @param {Object} options
   * @param {Object} body
   * @param {Label} labelModule
   */
  function Box(options, body, labelModule) {
    (0, _classCallCheck3['default'])(this, Box);

    var _this = (0, _possibleConstructorReturn3['default'])(this, (Box.__proto__ || (0, _getPrototypeOf2['default'])(Box)).call(this, options, body, labelModule));

    _this._setMargins(labelModule);
    return _this;
  }

  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {boolean} [selected]
   * @param {boolean} [hover]
   */


  (0, _createClass3['default'])(Box, [{
    key: 'resize',
    value: function resize(ctx) {
      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;
      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;

      if (this.needsRefresh(selected, hover)) {
        var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);

        this.width = dimensions.width + this.margin.right + this.margin.left;
        this.height = dimensions.height + this.margin.top + this.margin.bottom;
        this.radius = this.width / 2;
      }
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     */

  }, {
    key: 'draw',
    value: function draw(ctx, x, y, selected, hover, values) {
      this.resize(ctx, selected, hover);
      this.left = x - this.width / 2;
      this.top = y - this.height / 2;

      this.initContextForDraw(ctx, values);
      ctx.roundRect(this.left, this.top, this.width, this.height, values.borderRadius);
      this.performFill(ctx, values);

      this.updateBoundingBox(x, y, ctx, selected, hover);
      this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, selected, hover);
    }

    /**
     *
     * @param {number} x width
     * @param {number} y height
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     */

  }, {
    key: 'updateBoundingBox',
    value: function updateBoundingBox(x, y, ctx, selected, hover) {
      this._updateBoundingBox(x, y, ctx, selected, hover);

      var borderRadius = this.options.shapeProperties.borderRadius; // only effective for box
      this._addBoundingBoxMargin(borderRadius);
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: 'distanceToBorder',
    value: function distanceToBorder(ctx, angle) {
      this.resize(ctx);
      var borderWidth = this.options.borderWidth;

      return Math.min(Math.abs(this.width / 2 / Math.cos(angle)), Math.abs(this.height / 2 / Math.sin(angle))) + borderWidth;
    }
  }]);
  return Box;
}(_NodeBase3['default']);

exports['default'] = Box;

/***/ }),
/* 145 */
/***/ (function(module, exports, __nested_webpack_require_758678__) {

__nested_webpack_require_758678__(146);
module.exports = __nested_webpack_require_758678__(6).Object.getPrototypeOf;


/***/ }),
/* 146 */
/***/ (function(module, exports, __nested_webpack_require_758846__) {

// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = __nested_webpack_require_758846__(30);
var $getPrototypeOf = __nested_webpack_require_758846__(66);

__nested_webpack_require_758846__(68)('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});


/***/ }),
/* 147 */
/***/ (function(module, exports, __nested_webpack_require_759196__) {

module.exports = { "default": __nested_webpack_require_759196__(148), __esModule: true };

/***/ }),
/* 148 */
/***/ (function(module, exports, __nested_webpack_require_759350__) {

__nested_webpack_require_759350__(149);
module.exports = __nested_webpack_require_759350__(6).Object.setPrototypeOf;


/***/ }),
/* 149 */
/***/ (function(module, exports, __nested_webpack_require_759518__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __nested_webpack_require_759518__(11);
$export($export.S, 'Object', { setPrototypeOf: __nested_webpack_require_759518__(150).set });


/***/ }),
/* 150 */
/***/ (function(module, exports, __nested_webpack_require_759761__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __nested_webpack_require_759761__(21);
var anObject = __nested_webpack_require_759761__(20);
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = __nested_webpack_require_759761__(61)(Function.call, __nested_webpack_require_759761__(70).f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};


/***/ }),
/* 151 */
/***/ (function(module, exports, __nested_webpack_require_760750__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = __nested_webpack_require_760750__(3);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __nested_webpack_require_760750__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_760750__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __nested_webpack_require_760750__(4);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __nested_webpack_require_760750__(5);

var _inherits3 = _interopRequireDefault(_inherits2);

var _CircleImageBase2 = __nested_webpack_require_760750__(53);

var _CircleImageBase3 = _interopRequireDefault(_CircleImageBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * A Circle Node/Cluster shape.
 *
 * @extends CircleImageBase
 */
var Circle = function (_CircleImageBase) {
  (0, _inherits3['default'])(Circle, _CircleImageBase);

  /**
   * @param {Object} options
   * @param {Object} body
   * @param {Label} labelModule
   */
  function Circle(options, body, labelModule) {
    (0, _classCallCheck3['default'])(this, Circle);

    var _this = (0, _possibleConstructorReturn3['default'])(this, (Circle.__proto__ || (0, _getPrototypeOf2['default'])(Circle)).call(this, options, body, labelModule));

    _this._setMargins(labelModule);
    return _this;
  }

  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {boolean} [selected]
   * @param {boolean} [hover]
   */


  (0, _createClass3['default'])(Circle, [{
    key: 'resize',
    value: function resize(ctx) {
      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;
      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;

      if (this.needsRefresh(selected, hover)) {
        var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);

        var diameter = Math.max(dimensions.width + this.margin.right + this.margin.left, dimensions.height + this.margin.top + this.margin.bottom);

        this.options.size = diameter / 2; // NOTE: this size field only set here, not in Ellipse, Database, Box
        this.width = diameter;
        this.height = diameter;
        this.radius = this.width / 2;
      }
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     */

  }, {
    key: 'draw',
    value: function draw(ctx, x, y, selected, hover, values) {
      this.resize(ctx, selected, hover);
      this.left = x - this.width / 2;
      this.top = y - this.height / 2;

      this._drawRawCircle(ctx, x, y, values);

      this.updateBoundingBox(x, y);
      this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, y, selected, hover);
    }

    /**
     *
     * @param {number} x width
     * @param {number} y height
     */

  }, {
    key: 'updateBoundingBox',
    value: function updateBoundingBox(x, y) {
      this.boundingBox.top = y - this.options.size;
      this.boundingBox.left = x - this.options.size;
      this.boundingBox.right = x + this.options.size;
      this.boundingBox.bottom = y + this.options.size;
    }

    // prettier-ignore
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle - Unused
     * @returns {number}
     */

  }, {
    key: 'distanceToBorder',
    value: function distanceToBorder(ctx, angle) {
      // eslint-disable-line no-unused-vars
      this.resize(ctx);
      return this.width * 0.5;
    }
  }]);
  return Circle;
}(_CircleImageBase3['default']);

exports['default'] = Circle;

/***/ }),
/* 152 */
/***/ (function(module, exports, __nested_webpack_require_764689__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = __nested_webpack_require_764689__(3);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __nested_webpack_require_764689__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_764689__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __nested_webpack_require_764689__(4);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __nested_webpack_require_764689__(5);

var _inherits3 = _interopRequireDefault(_inherits2);

var _CircleImageBase2 = __nested_webpack_require_764689__(53);

var _CircleImageBase3 = _interopRequireDefault(_CircleImageBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * A CircularImage Node/Cluster shape.
 *
 * @extends CircleImageBase
 */
var CircularImage = function (_CircleImageBase) {
  (0, _inherits3['default'])(CircularImage, _CircleImageBase);

  /**
   * @param {Object} options
   * @param {Object} body
   * @param {Label} labelModule
   * @param {Image} imageObj
   * @param {Image} imageObjAlt
   */
  function CircularImage(options, body, labelModule, imageObj, imageObjAlt) {
    (0, _classCallCheck3['default'])(this, CircularImage);

    var _this = (0, _possibleConstructorReturn3['default'])(this, (CircularImage.__proto__ || (0, _getPrototypeOf2['default'])(CircularImage)).call(this, options, body, labelModule));

    _this.setImages(imageObj, imageObjAlt);
    return _this;
  }

  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {boolean} [selected]
   * @param {boolean} [hover]
   */


  (0, _createClass3['default'])(CircularImage, [{
    key: 'resize',
    value: function resize(ctx) {
      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;
      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;

      var imageAbsent = this.imageObj.src === undefined || this.imageObj.width === undefined || this.imageObj.height === undefined;

      if (imageAbsent) {
        var diameter = this.options.size * 2;
        this.width = diameter;
        this.height = diameter;
        this.radius = 0.5 * this.width;
        return;
      }

      // At this point, an image is present, i.e. this.imageObj is valid.
      if (this.needsRefresh(selected, hover)) {
        this._resizeImage();
      }
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     */

  }, {
    key: 'draw',
    value: function draw(ctx, x, y, selected, hover, values) {
      this.switchImages(selected);
      this.resize();
      this.left = x - this.width / 2;
      this.top = y - this.height / 2;

      // draw the background circle. IMPORTANT: the stroke in this method is used by the clip method below.
      this._drawRawCircle(ctx, x, y, values);

      // now we draw in the circle, we save so we can revert the clip operation after drawing.
      ctx.save();
      // clip is used to use the stroke in drawRawCircle as an area that we can draw in.
      ctx.clip();
      // draw the image
      this._drawImageAtPosition(ctx, values);
      // restore so we can again draw on the full canvas
      ctx.restore();

      this._drawImageLabel(ctx, x, y, selected, hover);

      this.updateBoundingBox(x, y);
    }

    // TODO: compare with Circle.updateBoundingBox(), consolidate? More stuff is happening here
    /**
     *
     * @param {number} x width
     * @param {number} y height
     */

  }, {
    key: 'updateBoundingBox',
    value: function updateBoundingBox(x, y) {
      this.boundingBox.top = y - this.options.size;
      this.boundingBox.left = x - this.options.size;
      this.boundingBox.right = x + this.options.size;
      this.boundingBox.bottom = y + this.options.size;

      // TODO: compare with Image.updateBoundingBox(), consolidate?
      this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
      this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
      this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelOffset);
    }

    // prettier-ignore
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle - Unused
     * @returns {number}
     */

  }, {
    key: 'distanceToBorder',
    value: function distanceToBorder(ctx, angle) {
      // eslint-disable-line no-unused-vars
      this.resize(ctx);
      return this.width * 0.5;
    }
  }]);
  return CircularImage;
}(_CircleImageBase3['default']);

exports['default'] = CircularImage;

/***/ }),
/* 153 */
/***/ (function(module, exports, __nested_webpack_require_769715__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = __nested_webpack_require_769715__(3);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __nested_webpack_require_769715__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_769715__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __nested_webpack_require_769715__(4);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __nested_webpack_require_769715__(5);

var _inherits3 = _interopRequireDefault(_inherits2);

var _NodeBase2 = __nested_webpack_require_769715__(16);

var _NodeBase3 = _interopRequireDefault(_NodeBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * A Database Node/Cluster shape.
 *
 * @extends NodeBase
 */
var Database = function (_NodeBase) {
  (0, _inherits3['default'])(Database, _NodeBase);

  /**
   * @param {Object} options
   * @param {Object} body
   * @param {Label} labelModule
   */
  function Database(options, body, labelModule) {
    (0, _classCallCheck3['default'])(this, Database);

    var _this = (0, _possibleConstructorReturn3['default'])(this, (Database.__proto__ || (0, _getPrototypeOf2['default'])(Database)).call(this, options, body, labelModule));

    _this._setMargins(labelModule);
    return _this;
  }

  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {boolean} selected
   * @param {boolean} hover
   */


  (0, _createClass3['default'])(Database, [{
    key: 'resize',
    value: function resize(ctx, selected, hover) {
      if (this.needsRefresh(selected, hover)) {
        var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);
        var size = dimensions.width + this.margin.right + this.margin.left;

        this.width = size;
        this.height = size;
        this.radius = this.width / 2;
      }
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     */

  }, {
    key: 'draw',
    value: function draw(ctx, x, y, selected, hover, values) {
      this.resize(ctx, selected, hover);
      this.left = x - this.width / 2;
      this.top = y - this.height / 2;

      this.initContextForDraw(ctx, values);
      ctx.database(x - this.width / 2, y - this.height / 2, this.width, this.height);
      this.performFill(ctx, values);

      this.updateBoundingBox(x, y, ctx, selected, hover);
      this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, selected, hover);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: 'distanceToBorder',
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);
  return Database;
}(_NodeBase3['default']);

exports['default'] = Database;

/***/ }),
/* 154 */
/***/ (function(module, exports, __nested_webpack_require_772963__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = __nested_webpack_require_772963__(3);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __nested_webpack_require_772963__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_772963__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __nested_webpack_require_772963__(4);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __nested_webpack_require_772963__(5);

var _inherits3 = _interopRequireDefault(_inherits2);

var _ShapeBase2 = __nested_webpack_require_772963__(17);

var _ShapeBase3 = _interopRequireDefault(_ShapeBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * A Diamond Node/Cluster shape.
 *
 * @extends ShapeBase
 */
var Diamond = function (_ShapeBase) {
  (0, _inherits3['default'])(Diamond, _ShapeBase);

  /**
   * @param {Object} options
   * @param {Object} body
   * @param {Label} labelModule
   */
  function Diamond(options, body, labelModule) {
    (0, _classCallCheck3['default'])(this, Diamond);
    return (0, _possibleConstructorReturn3['default'])(this, (Diamond.__proto__ || (0, _getPrototypeOf2['default'])(Diamond)).call(this, options, body, labelModule));
  }

  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {number} x width
   * @param {number} y height
   * @param {boolean} selected
   * @param {boolean} hover
   * @param {ArrowOptions} values
   */


  (0, _createClass3['default'])(Diamond, [{
    key: 'draw',
    value: function draw(ctx, x, y, selected, hover, values) {
      this._drawShape(ctx, 'diamond', 4, x, y, selected, hover, values);
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: 'distanceToBorder',
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);
  return Diamond;
}(_ShapeBase3['default']);

exports['default'] = Diamond;

/***/ }),
/* 155 */
/***/ (function(module, exports, __nested_webpack_require_775191__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = __nested_webpack_require_775191__(3);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __nested_webpack_require_775191__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_775191__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __nested_webpack_require_775191__(4);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __nested_webpack_require_775191__(5);

var _inherits3 = _interopRequireDefault(_inherits2);

var _ShapeBase2 = __nested_webpack_require_775191__(17);

var _ShapeBase3 = _interopRequireDefault(_ShapeBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * A Dot Node/Cluster shape.
 *
 * @extends ShapeBase
 */
var Dot = function (_ShapeBase) {
  (0, _inherits3['default'])(Dot, _ShapeBase);

  /**
   * @param {Object} options
   * @param {Object} body
   * @param {Label} labelModule
   */
  function Dot(options, body, labelModule) {
    (0, _classCallCheck3['default'])(this, Dot);
    return (0, _possibleConstructorReturn3['default'])(this, (Dot.__proto__ || (0, _getPrototypeOf2['default'])(Dot)).call(this, options, body, labelModule));
  }

  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {number} x width
   * @param {number} y height
   * @param {boolean} selected
   * @param {boolean} hover
   * @param {ArrowOptions} values
   */


  (0, _createClass3['default'])(Dot, [{
    key: 'draw',
    value: function draw(ctx, x, y, selected, hover, values) {
      this._drawShape(ctx, 'circle', 2, x, y, selected, hover, values);
    }

    // prettier-ignore
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: 'distanceToBorder',
    value: function distanceToBorder(ctx, angle) {
      // eslint-disable-line no-unused-vars
      this.resize(ctx);
      return this.options.size;
    }
  }]);
  return Dot;
}(_ShapeBase3['default']);

exports['default'] = Dot;

/***/ }),
/* 156 */
/***/ (function(module, exports, __nested_webpack_require_777452__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = __nested_webpack_require_777452__(3);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __nested_webpack_require_777452__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_777452__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __nested_webpack_require_777452__(4);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __nested_webpack_require_777452__(5);

var _inherits3 = _interopRequireDefault(_inherits2);

var _NodeBase2 = __nested_webpack_require_777452__(16);

var _NodeBase3 = _interopRequireDefault(_NodeBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * Am Ellipse Node/Cluster shape.
 *
 * @extends NodeBase
 */
var Ellipse = function (_NodeBase) {
  (0, _inherits3['default'])(Ellipse, _NodeBase);

  /**
   * @param {Object} options
   * @param {Object} body
   * @param {Label} labelModule
   */
  function Ellipse(options, body, labelModule) {
    (0, _classCallCheck3['default'])(this, Ellipse);
    return (0, _possibleConstructorReturn3['default'])(this, (Ellipse.__proto__ || (0, _getPrototypeOf2['default'])(Ellipse)).call(this, options, body, labelModule));
  }

  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {boolean} [selected]
   * @param {boolean} [hover]
   */


  (0, _createClass3['default'])(Ellipse, [{
    key: 'resize',
    value: function resize(ctx) {
      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;
      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;

      if (this.needsRefresh(selected, hover)) {
        var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);

        this.height = dimensions.height * 2;
        this.width = dimensions.width + dimensions.height;
        this.radius = 0.5 * this.width;
      }
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     */

  }, {
    key: 'draw',
    value: function draw(ctx, x, y, selected, hover, values) {
      this.resize(ctx, selected, hover);
      this.left = x - this.width * 0.5;
      this.top = y - this.height * 0.5;

      this.initContextForDraw(ctx, values);
      ctx.ellipse_vis(this.left, this.top, this.width, this.height);
      this.performFill(ctx, values);

      this.updateBoundingBox(x, y, ctx, selected, hover);
      this.labelModule.draw(ctx, x, y, selected, hover);
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: 'distanceToBorder',
    value: function distanceToBorder(ctx, angle) {
      this.resize(ctx);
      var a = this.width * 0.5;
      var b = this.height * 0.5;
      var w = Math.sin(angle) * a;
      var h = Math.cos(angle) * b;
      return a * b / Math.sqrt(w * w + h * h);
    }
  }]);
  return Ellipse;
}(_NodeBase3['default']);

exports['default'] = Ellipse;

/***/ }),
/* 157 */
/***/ (function(module, exports, __nested_webpack_require_780835__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = __nested_webpack_require_780835__(3);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __nested_webpack_require_780835__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_780835__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __nested_webpack_require_780835__(4);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __nested_webpack_require_780835__(5);

var _inherits3 = _interopRequireDefault(_inherits2);

var _NodeBase2 = __nested_webpack_require_780835__(16);

var _NodeBase3 = _interopRequireDefault(_NodeBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * An icon replacement for the default Node shape.
 *
 * @extends NodeBase
 */
var Icon = function (_NodeBase) {
  (0, _inherits3['default'])(Icon, _NodeBase);

  /**
   * @param {Object} options
   * @param {Object} body
   * @param {Label} labelModule
   */
  function Icon(options, body, labelModule) {
    (0, _classCallCheck3['default'])(this, Icon);

    var _this = (0, _possibleConstructorReturn3['default'])(this, (Icon.__proto__ || (0, _getPrototypeOf2['default'])(Icon)).call(this, options, body, labelModule));

    _this._setMargins(labelModule);
    return _this;
  }

  /**
   *
   * @param {CanvasRenderingContext2D} ctx - Unused.
   * @param {boolean} [selected]
   * @param {boolean} [hover]
   */


  (0, _createClass3['default'])(Icon, [{
    key: 'resize',
    value: function resize(ctx, selected, hover) {
      if (this.needsRefresh(selected, hover)) {
        this.iconSize = {
          width: Number(this.options.icon.size),
          height: Number(this.options.icon.size)
        };
        this.width = this.iconSize.width + this.margin.right + this.margin.left;
        this.height = this.iconSize.height + this.margin.top + this.margin.bottom;
        this.radius = 0.5 * this.width;
      }
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     */

  }, {
    key: 'draw',
    value: function draw(ctx, x, y, selected, hover, values) {
      this.resize(ctx, selected, hover);
      this.options.icon.size = this.options.icon.size || 50;

      this.left = x - this.width / 2;
      this.top = y - this.height / 2;
      this._icon(ctx, x, y, selected, hover, values);

      if (this.options.label !== undefined) {
        var iconTextSpacing = 5;
        this.labelModule.draw(ctx, this.left + this.iconSize.width / 2 + this.margin.left, y + this.height / 2 + iconTextSpacing, selected);
      }

      this.updateBoundingBox(x, y);
    }

    /**
     *
     * @param {number} x
     * @param {number} y
     */

  }, {
    key: 'updateBoundingBox',
    value: function updateBoundingBox(x, y) {
      this.boundingBox.top = y - this.options.icon.size * 0.5;
      this.boundingBox.left = x - this.options.icon.size * 0.5;
      this.boundingBox.right = x + this.options.icon.size * 0.5;
      this.boundingBox.bottom = y + this.options.icon.size * 0.5;

      if (this.options.label !== undefined && this.labelModule.size.width > 0) {
        var iconTextSpacing = 5;
        this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
        this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
        this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelModule.size.height + iconTextSpacing);
      }
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover - Unused
     * @param {ArrowOptions} values
     */

  }, {
    key: '_icon',
    value: function _icon(ctx, x, y, selected, hover, values) {
      var iconSize = Number(this.options.icon.size);

      if (this.options.icon.code !== undefined) {
        ctx.font = (selected ? 'bold ' : '') + iconSize + 'px ' + this.options.icon.face;

        // draw icon
        ctx.fillStyle = this.options.icon.color || 'black';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        // draw shadow if enabled
        this.enableShadow(ctx, values);
        ctx.fillText(this.options.icon.code, x, y);

        // disable shadows for other elements.
        this.disableShadow(ctx, values);
      } else {
        console.error('When using the icon shape, you need to define the code in the icon options object. This can be done per node or globally.');
      }
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: 'distanceToBorder',
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);
  return Icon;
}(_NodeBase3['default']);

exports['default'] = Icon;

/***/ }),
/* 158 */
/***/ (function(module, exports, __nested_webpack_require_786141__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = __nested_webpack_require_786141__(3);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __nested_webpack_require_786141__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_786141__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __nested_webpack_require_786141__(4);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __nested_webpack_require_786141__(5);

var _inherits3 = _interopRequireDefault(_inherits2);

var _CircleImageBase2 = __nested_webpack_require_786141__(53);

var _CircleImageBase3 = _interopRequireDefault(_CircleImageBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * An image-based replacement for the default Node shape.
 *
 * @extends CircleImageBase
 */
var Image = function (_CircleImageBase) {
  (0, _inherits3['default'])(Image, _CircleImageBase);

  /**
   * @param {Object} options
   * @param {Object} body
   * @param {Label} labelModule
   * @param {Image} imageObj
   * @param {Image} imageObjAlt
   */
  function Image(options, body, labelModule, imageObj, imageObjAlt) {
    (0, _classCallCheck3['default'])(this, Image);

    var _this = (0, _possibleConstructorReturn3['default'])(this, (Image.__proto__ || (0, _getPrototypeOf2['default'])(Image)).call(this, options, body, labelModule));

    _this.setImages(imageObj, imageObjAlt);
    return _this;
  }

  /**
   *
   * @param {CanvasRenderingContext2D} ctx - Unused.
   * @param {boolean} [selected]
   * @param {boolean} [hover]
   */


  (0, _createClass3['default'])(Image, [{
    key: 'resize',
    value: function resize(ctx) {
      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;
      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;

      var imageAbsent = this.imageObj.src === undefined || this.imageObj.width === undefined || this.imageObj.height === undefined;

      if (imageAbsent) {
        var side = this.options.size * 2;
        this.width = side;
        this.height = side;
        return;
      }

      if (this.needsRefresh(selected, hover)) {
        this._resizeImage();
      }
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     */

  }, {
    key: 'draw',
    value: function draw(ctx, x, y, selected, hover, values) {
      this.switchImages(selected);
      this.resize();
      this.left = x - this.width / 2;
      this.top = y - this.height / 2;

      if (this.options.shapeProperties.useBorderWithImage === true) {
        var neutralborderWidth = this.options.borderWidth;
        var selectionLineWidth = this.options.borderWidthSelected || 2 * this.options.borderWidth;
        var borderWidth = (selected ? selectionLineWidth : neutralborderWidth) / this.body.view.scale;
        ctx.lineWidth = Math.min(this.width, borderWidth);

        ctx.beginPath();

        // setup the line properties.
        ctx.strokeStyle = selected ? this.options.color.highlight.border : hover ? this.options.color.hover.border : this.options.color.border;

        // set a fillstyle
        ctx.fillStyle = selected ? this.options.color.highlight.background : hover ? this.options.color.hover.background : this.options.color.background;

        // draw a rectangle to form the border around. This rectangle is filled so the opacity of a picture (in future vis releases?) can be used to tint the image
        ctx.rect(this.left - 0.5 * ctx.lineWidth, this.top - 0.5 * ctx.lineWidth, this.width + ctx.lineWidth, this.height + ctx.lineWidth);
        ctx.fill();

        this.performStroke(ctx, values);

        ctx.closePath();
      }

      this._drawImageAtPosition(ctx, values);

      this._drawImageLabel(ctx, x, y, selected, hover);

      this.updateBoundingBox(x, y);
    }

    /**
     *
     * @param {number} x
     * @param {number} y
     */

  }, {
    key: 'updateBoundingBox',
    value: function updateBoundingBox(x, y) {
      this.resize();
      this._updateBoundingBox(x, y);

      if (this.options.label !== undefined && this.labelModule.size.width > 0) {
        this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
        this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
        this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelOffset);
      }
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: 'distanceToBorder',
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);
  return Image;
}(_CircleImageBase3['default']);

exports['default'] = Image;

/***/ }),
/* 159 */
/***/ (function(module, exports, __nested_webpack_require_791384__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = __nested_webpack_require_791384__(3);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __nested_webpack_require_791384__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_791384__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __nested_webpack_require_791384__(4);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __nested_webpack_require_791384__(5);

var _inherits3 = _interopRequireDefault(_inherits2);

var _ShapeBase2 = __nested_webpack_require_791384__(17);

var _ShapeBase3 = _interopRequireDefault(_ShapeBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * A Square Node/Cluster shape.
 *
 * @extends ShapeBase
 */
var Square = function (_ShapeBase) {
  (0, _inherits3['default'])(Square, _ShapeBase);

  /**
   * @param {Object} options
   * @param {Object} body
   * @param {Label} labelModule
   */
  function Square(options, body, labelModule) {
    (0, _classCallCheck3['default'])(this, Square);
    return (0, _possibleConstructorReturn3['default'])(this, (Square.__proto__ || (0, _getPrototypeOf2['default'])(Square)).call(this, options, body, labelModule));
  }

  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {number} x width
   * @param {number} y height
   * @param {boolean} selected
   * @param {boolean} hover
   * @param {ArrowOptions} values
   */


  (0, _createClass3['default'])(Square, [{
    key: 'draw',
    value: function draw(ctx, x, y, selected, hover, values) {
      this._drawShape(ctx, 'square', 2, x, y, selected, hover, values);
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: 'distanceToBorder',
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);
  return Square;
}(_ShapeBase3['default']);

exports['default'] = Square;

/***/ }),
/* 160 */
/***/ (function(module, exports, __nested_webpack_require_793601__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = __nested_webpack_require_793601__(3);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __nested_webpack_require_793601__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_793601__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __nested_webpack_require_793601__(4);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __nested_webpack_require_793601__(5);

var _inherits3 = _interopRequireDefault(_inherits2);

var _ShapeBase2 = __nested_webpack_require_793601__(17);

var _ShapeBase3 = _interopRequireDefault(_ShapeBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * A Hexagon Node/Cluster shape.
 *
 * @extends ShapeBase
 */
var Hexagon = function (_ShapeBase) {
  (0, _inherits3['default'])(Hexagon, _ShapeBase);

  /**
   * @param {Object} options
   * @param {Object} body
   * @param {Label} labelModule
   */
  function Hexagon(options, body, labelModule) {
    (0, _classCallCheck3['default'])(this, Hexagon);
    return (0, _possibleConstructorReturn3['default'])(this, (Hexagon.__proto__ || (0, _getPrototypeOf2['default'])(Hexagon)).call(this, options, body, labelModule));
  }

  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {number} x width
   * @param {number} y height
   * @param {boolean} selected
   * @param {boolean} hover
   * @param {ArrowOptions} values
   */


  (0, _createClass3['default'])(Hexagon, [{
    key: 'draw',
    value: function draw(ctx, x, y, selected, hover, values) {
      this._drawShape(ctx, 'hexagon', 4, x, y, selected, hover, values);
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: 'distanceToBorder',
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);
  return Hexagon;
}(_ShapeBase3['default']);

exports['default'] = Hexagon;

/***/ }),
/* 161 */
/***/ (function(module, exports, __nested_webpack_require_795829__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = __nested_webpack_require_795829__(3);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __nested_webpack_require_795829__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_795829__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __nested_webpack_require_795829__(4);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __nested_webpack_require_795829__(5);

var _inherits3 = _interopRequireDefault(_inherits2);

var _ShapeBase2 = __nested_webpack_require_795829__(17);

var _ShapeBase3 = _interopRequireDefault(_ShapeBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * A Star Node/Cluster shape.
 *
 * @extends ShapeBase
 */
var Star = function (_ShapeBase) {
  (0, _inherits3['default'])(Star, _ShapeBase);

  /**
   * @param {Object} options
   * @param {Object} body
   * @param {Label} labelModule
   */
  function Star(options, body, labelModule) {
    (0, _classCallCheck3['default'])(this, Star);
    return (0, _possibleConstructorReturn3['default'])(this, (Star.__proto__ || (0, _getPrototypeOf2['default'])(Star)).call(this, options, body, labelModule));
  }

  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {number} x width
   * @param {number} y height
   * @param {boolean} selected
   * @param {boolean} hover
   * @param {ArrowOptions} values
   */


  (0, _createClass3['default'])(Star, [{
    key: 'draw',
    value: function draw(ctx, x, y, selected, hover, values) {
      this._drawShape(ctx, 'star', 4, x, y, selected, hover, values);
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: 'distanceToBorder',
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);
  return Star;
}(_ShapeBase3['default']);

exports['default'] = Star;

/***/ }),
/* 162 */
/***/ (function(module, exports, __nested_webpack_require_798024__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = __nested_webpack_require_798024__(3);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __nested_webpack_require_798024__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_798024__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __nested_webpack_require_798024__(4);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __nested_webpack_require_798024__(5);

var _inherits3 = _interopRequireDefault(_inherits2);

var _NodeBase2 = __nested_webpack_require_798024__(16);

var _NodeBase3 = _interopRequireDefault(_NodeBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * A text-based replacement for the default Node shape.
 *
 * @extends NodeBase
 */
var Text = function (_NodeBase) {
  (0, _inherits3['default'])(Text, _NodeBase);

  /**
   * @param {Object} options
   * @param {Object} body
   * @param {Label} labelModule
   */
  function Text(options, body, labelModule) {
    (0, _classCallCheck3['default'])(this, Text);

    var _this = (0, _possibleConstructorReturn3['default'])(this, (Text.__proto__ || (0, _getPrototypeOf2['default'])(Text)).call(this, options, body, labelModule));

    _this._setMargins(labelModule);
    return _this;
  }

  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {boolean} selected
   * @param {boolean} hover
   */


  (0, _createClass3['default'])(Text, [{
    key: 'resize',
    value: function resize(ctx, selected, hover) {
      if (this.needsRefresh(selected, hover)) {
        this.textSize = this.labelModule.getTextSize(ctx, selected, hover);
        this.width = this.textSize.width + this.margin.right + this.margin.left;
        this.height = this.textSize.height + this.margin.top + this.margin.bottom;
        this.radius = 0.5 * this.width;
      }
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     */

  }, {
    key: 'draw',
    value: function draw(ctx, x, y, selected, hover, values) {
      this.resize(ctx, selected, hover);
      this.left = x - this.width / 2;
      this.top = y - this.height / 2;

      // draw shadow if enabled
      this.enableShadow(ctx, values);
      this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, selected, hover);

      // disable shadows for other elements.
      this.disableShadow(ctx, values);

      this.updateBoundingBox(x, y, ctx, selected, hover);
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: 'distanceToBorder',
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);
  return Text;
}(_NodeBase3['default']);

exports['default'] = Text;

/***/ }),
/* 163 */
/***/ (function(module, exports, __nested_webpack_require_801281__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = __nested_webpack_require_801281__(3);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __nested_webpack_require_801281__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_801281__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __nested_webpack_require_801281__(4);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __nested_webpack_require_801281__(5);

var _inherits3 = _interopRequireDefault(_inherits2);

var _ShapeBase2 = __nested_webpack_require_801281__(17);

var _ShapeBase3 = _interopRequireDefault(_ShapeBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * A Triangle Node/Cluster shape.
 *
 * @extends ShapeBase
 */
var Triangle = function (_ShapeBase) {
  (0, _inherits3['default'])(Triangle, _ShapeBase);

  /**
   * @param {Object} options
   * @param {Object} body
   * @param {Label} labelModule
   */
  function Triangle(options, body, labelModule) {
    (0, _classCallCheck3['default'])(this, Triangle);
    return (0, _possibleConstructorReturn3['default'])(this, (Triangle.__proto__ || (0, _getPrototypeOf2['default'])(Triangle)).call(this, options, body, labelModule));
  }

  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {number} x
   * @param {number} y
   * @param {boolean} selected
   * @param {boolean} hover
   * @param {ArrowOptions} values
   */


  (0, _createClass3['default'])(Triangle, [{
    key: 'draw',
    value: function draw(ctx, x, y, selected, hover, values) {
      this._drawShape(ctx, 'triangle', 3, x, y, selected, hover, values);
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: 'distanceToBorder',
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);
  return Triangle;
}(_ShapeBase3['default']);

exports['default'] = Triangle;

/***/ }),
/* 164 */
/***/ (function(module, exports, __nested_webpack_require_803507__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = __nested_webpack_require_803507__(3);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __nested_webpack_require_803507__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_803507__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __nested_webpack_require_803507__(4);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __nested_webpack_require_803507__(5);

var _inherits3 = _interopRequireDefault(_inherits2);

var _ShapeBase2 = __nested_webpack_require_803507__(17);

var _ShapeBase3 = _interopRequireDefault(_ShapeBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * A downward facing Triangle Node/Cluster shape.
 *
 * @extends ShapeBase
 */
var TriangleDown = function (_ShapeBase) {
  (0, _inherits3['default'])(TriangleDown, _ShapeBase);

  /**
   * @param {Object} options
   * @param {Object} body
   * @param {Label} labelModule
   */
  function TriangleDown(options, body, labelModule) {
    (0, _classCallCheck3['default'])(this, TriangleDown);
    return (0, _possibleConstructorReturn3['default'])(this, (TriangleDown.__proto__ || (0, _getPrototypeOf2['default'])(TriangleDown)).call(this, options, body, labelModule));
  }

  /**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {number} x
   * @param {number} y
   * @param {boolean} selected
   * @param {boolean} hover
   * @param {ArrowOptions} values
   */


  (0, _createClass3['default'])(TriangleDown, [{
    key: 'draw',
    value: function draw(ctx, x, y, selected, hover, values) {
      this._drawShape(ctx, 'triangleDown', 3, x, y, selected, hover, values);
    }

    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */

  }, {
    key: 'distanceToBorder',
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);
  return TriangleDown;
}(_ShapeBase3['default']);

exports['default'] = TriangleDown;

/***/ }),
/* 165 */
/***/ (function(module, exports, __nested_webpack_require_805789__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __nested_webpack_require_805789__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_805789__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var util = __nested_webpack_require_805789__(2);
var DataSet = __nested_webpack_require_805789__(33);
var DataView = __nested_webpack_require_805789__(51);
var Edge = __nested_webpack_require_805789__(55)['default'];

/**
 * Handler for Edges
 */

var EdgesHandler = function () {
  /**
   * @param {Object} body
   * @param {Array.<Image>} images
   * @param {Array.<Group>} groups
   */
  function EdgesHandler(body, images, groups) {
    var _this = this;

    (0, _classCallCheck3['default'])(this, EdgesHandler);

    this.body = body;
    this.images = images;
    this.groups = groups;

    // create the edge API in the body container
    this.body.functions.createEdge = this.create.bind(this);

    this.edgesListeners = {
      add: function add(event, params) {
        _this.add(params.items);
      },
      update: function update(event, params) {
        _this.update(params.items);
      },
      remove: function remove(event, params) {
        _this.remove(params.items);
      }
    };

    this.options = {};
    this.defaultOptions = {
      arrows: {
        to: { enabled: false, scaleFactor: 1, type: 'arrow' }, // boolean / {arrowScaleFactor:1} / {enabled: false, arrowScaleFactor:1}
        middle: { enabled: false, scaleFactor: 1, type: 'arrow' },
        from: { enabled: false, scaleFactor: 1, type: 'arrow' }
      },
      arrowStrikethrough: true,
      color: {
        color: '#848484',
        highlight: '#848484',
        hover: '#848484',
        inherit: 'from',
        opacity: 1.0
      },
      dashes: false,
      font: {
        color: '#343434',
        size: 14, // px
        face: 'arial',
        background: 'none',
        strokeWidth: 2, // px
        strokeColor: '#ffffff',
        align: 'horizontal',
        multi: false,
        vadjust: 0,
        bold: {
          mod: 'bold'
        },
        boldital: {
          mod: 'bold italic'
        },
        ital: {
          mod: 'italic'
        },
        mono: {
          mod: '',
          size: 15, // px
          face: 'courier new',
          vadjust: 2
        }
      },
      hidden: false,
      hoverWidth: 1.5,
      label: undefined,
      labelHighlightBold: true,
      length: undefined,
      physics: true,
      scaling: {
        min: 1,
        max: 15,
        label: {
          enabled: true,
          min: 14,
          max: 30,
          maxVisible: 30,
          drawThreshold: 5
        },
        customScalingFunction: function customScalingFunction(min, max, total, value) {
          if (max === min) {
            return 0.5;
          } else {
            var scale = 1 / (max - min);
            return Math.max(0, (value - min) * scale);
          }
        }
      },
      selectionWidth: 1.5,
      selfReferenceSize: 20,
      shadow: {
        enabled: false,
        color: 'rgba(0,0,0,0.5)',
        size: 10,
        x: 5,
        y: 5
      },
      background: {
        enabled: false,
        color: 'rgba(111,111,111,1)',
        size: 10,
        dashes: false
      },
      smooth: {
        enabled: true,
        type: 'dynamic',
        forceDirection: 'none',
        roundness: 0.5
      },
      title: undefined,
      width: 1,
      value: undefined
    };

    util.deepExtend(this.options, this.defaultOptions);

    this.bindEventListeners();
  }

  /**
   * Binds event listeners
   */


  (0, _createClass3['default'])(EdgesHandler, [{
    key: 'bindEventListeners',
    value: function bindEventListeners() {
      var _this2 = this;

      // this allows external modules to force all dynamic curves to turn static.
      this.body.emitter.on('_forceDisableDynamicCurves', function (type) {
        var emit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        if (type === 'dynamic') {
          type = 'continuous';
        }
        var dataChanged = false;
        for (var edgeId in _this2.body.edges) {
          if (_this2.body.edges.hasOwnProperty(edgeId)) {
            var edge = _this2.body.edges[edgeId];
            var edgeData = _this2.body.data.edges._data[edgeId];

            // only forcibly remove the smooth curve if the data has been set of the edge has the smooth curves defined.
            // this is because a change in the global would not affect these curves.
            if (edgeData !== undefined) {
              var smoothOptions = edgeData.smooth;
              if (smoothOptions !== undefined) {
                if (smoothOptions.enabled === true && smoothOptions.type === 'dynamic') {
                  if (type === undefined) {
                    edge.setOptions({ smooth: false });
                  } else {
                    edge.setOptions({ smooth: { type: type } });
                  }
                  dataChanged = true;
                }
              }
            }
          }
        }
        if (emit === true && dataChanged === true) {
          _this2.body.emitter.emit('_dataChanged');
        }
      });

      // this is called when options of EXISTING nodes or edges have changed.
      //
      // NOTE: Not true, called when options have NOT changed, for both existing as well as new nodes.
      //       See update() for logic.
      // TODO: Verify and examine the consequences of this. It might still trigger when
      //       non-option fields have changed, but then reconnecting edges is still useless.
      //       Alternatively, it might also be called when edges are removed.
      //
      this.body.emitter.on('_dataUpdated', function () {
        _this2.reconnectEdges();
      });

      // refresh the edges. Used when reverting from hierarchical layout
      this.body.emitter.on('refreshEdges', this.refresh.bind(this));
      this.body.emitter.on('refresh', this.refresh.bind(this));
      this.body.emitter.on('destroy', function () {
        util.forEach(_this2.edgesListeners, function (callback, event) {
          if (_this2.body.data.edges) _this2.body.data.edges.off(event, callback);
        });
        delete _this2.body.functions.createEdge;
        delete _this2.edgesListeners.add;
        delete _this2.edgesListeners.update;
        delete _this2.edgesListeners.remove;
        delete _this2.edgesListeners;
      });
    }

    /**
     *
     * @param {Object} options
     */

  }, {
    key: 'setOptions',
    value: function setOptions(options) {
      if (options !== undefined) {
        // use the parser from the Edge class to fill in all shorthand notations
        Edge.parseOptions(this.options, options, true, this.defaultOptions, true);

        // update smooth settings in all edges
        var dataChanged = false;
        if (options.smooth !== undefined) {
          for (var edgeId in this.body.edges) {
            if (this.body.edges.hasOwnProperty(edgeId)) {
              dataChanged = this.body.edges[edgeId].updateEdgeType() || dataChanged;
            }
          }
        }

        // update fonts in all edges
        if (options.font !== undefined) {
          for (var _edgeId in this.body.edges) {
            if (this.body.edges.hasOwnProperty(_edgeId)) {
              this.body.edges[_edgeId].updateLabelModule();
            }
          }
        }

        // update the state of the variables if needed
        if (options.hidden !== undefined || options.physics !== undefined || dataChanged === true) {
          this.body.emitter.emit('_dataChanged');
        }
      }
    }

    /**
     * Load edges by reading the data table
     * @param {Array | DataSet | DataView} edges    The data containing the edges.
     * @param {boolean} [doNotEmit=false]
     * @private
     */

  }, {
    key: 'setData',
    value: function setData(edges) {
      var _this3 = this;

      var doNotEmit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var oldEdgesData = this.body.data.edges;

      if (edges instanceof DataSet || edges instanceof DataView) {
        this.body.data.edges = edges;
      } else if (Array.isArray(edges)) {
        this.body.data.edges = new DataSet();
        this.body.data.edges.add(edges);
      } else if (!edges) {
        this.body.data.edges = new DataSet();
      } else {
        throw new TypeError('Array or DataSet expected');
      }

      // TODO: is this null or undefined or false?
      if (oldEdgesData) {
        // unsubscribe from old dataset
        util.forEach(this.edgesListeners, function (callback, event) {
          oldEdgesData.off(event, callback);
        });
      }

      // remove drawn edges
      this.body.edges = {};

      // TODO: is this null or undefined or false?
      if (this.body.data.edges) {
        // subscribe to new dataset
        util.forEach(this.edgesListeners, function (callback, event) {
          _this3.body.data.edges.on(event, callback);
        });

        // draw all new nodes
        var ids = this.body.data.edges.getIds();
        this.add(ids, true);
      }

      this.body.emitter.emit('_adjustEdgesForHierarchicalLayout');
      if (doNotEmit === false) {
        this.body.emitter.emit('_dataChanged');
      }
    }

    /**
     * Add edges
     * @param {number[] | string[]} ids
     * @param {boolean} [doNotEmit=false]
     * @private
     */

  }, {
    key: 'add',
    value: function add(ids) {
      var doNotEmit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var edges = this.body.edges;
      var edgesData = this.body.data.edges;

      for (var i = 0; i < ids.length; i++) {
        var id = ids[i];

        var oldEdge = edges[id];
        if (oldEdge) {
          oldEdge.disconnect();
        }

        var data = edgesData.get(id, { showInternalIds: true });
        edges[id] = this.create(data);
      }

      this.body.emitter.emit('_adjustEdgesForHierarchicalLayout');

      if (doNotEmit === false) {
        this.body.emitter.emit('_dataChanged');
      }
    }

    /**
     * Update existing edges, or create them when not yet existing
     * @param {number[] | string[]} ids
     * @private
     */

  }, {
    key: 'update',
    value: function update(ids) {
      var edges = this.body.edges;
      var edgesData = this.body.data.edges;
      var dataChanged = false;
      for (var i = 0; i < ids.length; i++) {
        var id = ids[i];
        var data = edgesData.get(id);
        var edge = edges[id];
        if (edge !== undefined) {
          // update edge
          edge.disconnect();
          dataChanged = edge.setOptions(data) || dataChanged; // if a support node is added, data can be changed.
          edge.connect();
        } else {
          // create edge
          this.body.edges[id] = this.create(data);
          dataChanged = true;
        }
      }

      if (dataChanged === true) {
        this.body.emitter.emit('_adjustEdgesForHierarchicalLayout');
        this.body.emitter.emit('_dataChanged');
      } else {
        this.body.emitter.emit('_dataUpdated');
      }
    }

    /**
     * Remove existing edges. Non existing ids will be ignored
     * @param {number[] | string[]} ids
     * @param {boolean} [emit=true]
     * @private
     */

  }, {
    key: 'remove',
    value: function remove(ids) {
      var emit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (ids.length === 0) return; // early out

      var edges = this.body.edges;
      util.forEach(ids, function (id) {
        var edge = edges[id];
        if (edge !== undefined) {
          edge.remove();
        }
      });

      if (emit) {
        this.body.emitter.emit('_dataChanged');
      }
    }

    /**
     * Refreshes Edge Handler
     */

  }, {
    key: 'refresh',
    value: function refresh() {
      var _this4 = this;

      util.forEach(this.body.edges, function (edge, edgeId) {
        var data = _this4.body.data.edges._data[edgeId];
        if (data !== undefined) {
          edge.setOptions(data);
        }
      });
    }

    /**
     *
     * @param {Object} properties
     * @returns {Edge}
     */

  }, {
    key: 'create',
    value: function create(properties) {
      return new Edge(properties, this.body, this.options, this.defaultOptions);
    }

    /**
     * Reconnect all edges
     * @private
     */

  }, {
    key: 'reconnectEdges',
    value: function reconnectEdges() {
      var id;
      var nodes = this.body.nodes;
      var edges = this.body.edges;

      for (id in nodes) {
        if (nodes.hasOwnProperty(id)) {
          nodes[id].edges = [];
        }
      }

      for (id in edges) {
        if (edges.hasOwnProperty(id)) {
          var edge = edges[id];
          edge.from = null;
          edge.to = null;
          edge.connect();
        }
      }
    }

    /**
     *
     * @param {Edge.id} edgeId
     * @returns {Array}
     */

  }, {
    key: 'getConnectedNodes',
    value: function getConnectedNodes(edgeId) {
      var nodeList = [];
      if (this.body.edges[edgeId] !== undefined) {
        var edge = this.body.edges[edgeId];
        if (edge.fromId !== undefined) {
          nodeList.push(edge.fromId);
        }
        if (edge.toId !== undefined) {
          nodeList.push(edge.toId);
        }
      }
      return nodeList;
    }

    /**
     * There is no direct relation between the nodes and the edges DataSet,
     * so the right place to do call this is in the handler for event `_dataUpdated`.
     */

  }, {
    key: '_updateState',
    value: function _updateState() {
      this._addMissingEdges();
      this._removeInvalidEdges();
    }

    /**
     * Scan for missing nodes and remove corresponding edges, if any.
     * @private
     */

  }, {
    key: '_removeInvalidEdges',
    value: function _removeInvalidEdges() {
      var _this5 = this;

      var edgesToDelete = [];

      util.forEach(this.body.edges, function (edge, id) {
        var toNode = _this5.body.nodes[edge.toId];
        var fromNode = _this5.body.nodes[edge.fromId];

        // Skip clustering edges here, let the Clustering module handle those
        if (toNode !== undefined && toNode.isCluster === true || fromNode !== undefined && fromNode.isCluster === true) {
          return;
        }

        if (toNode === undefined || fromNode === undefined) {
          edgesToDelete.push(id);
        }
      });

      this.remove(edgesToDelete, false);
    }

    /**
     * add all edges from dataset that are not in the cached state
     * @private
     */

  }, {
    key: '_addMissingEdges',
    value: function _addMissingEdges() {
      var edgesData = this.body.data.edges;
      if (edgesData === undefined || edgesData === null) {
        return; // No edges DataSet yet; can happen on startup
      }

      var edges = this.body.edges;
      var addIds = [];

      edgesData.forEach(function (edgeData, edgeId) {
        var edge = edges[edgeId];
        if (edge === undefined) {
          addIds.push(edgeId);
        }
      });

      this.add(addIds, true);
    }
  }]);
  return EdgesHandler;
}();

exports['default'] = EdgesHandler;

/***/ }),
/* 166 */
/***/ (function(module, exports, __nested_webpack_require_821252__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray2 = __nested_webpack_require_821252__(15);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _getPrototypeOf = __nested_webpack_require_821252__(3);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __nested_webpack_require_821252__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_821252__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __nested_webpack_require_821252__(4);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __nested_webpack_require_821252__(5);

var _inherits3 = _interopRequireDefault(_inherits2);

var _CubicBezierEdgeBase2 = __nested_webpack_require_821252__(167);

var _CubicBezierEdgeBase3 = _interopRequireDefault(_CubicBezierEdgeBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * A Cubic Bezier Edge. Bezier curves are used to model smooth gradual
 * curves in paths between nodes.
 *
 * @extends CubicBezierEdgeBase
 */
var CubicBezierEdge = function (_CubicBezierEdgeBase) {
  (0, _inherits3['default'])(CubicBezierEdge, _CubicBezierEdgeBase);

  /**
   * @param {Object} options
   * @param {Object} body
   * @param {Label} labelModule
   */
  function CubicBezierEdge(options, body, labelModule) {
    (0, _classCallCheck3['default'])(this, CubicBezierEdge);
    return (0, _possibleConstructorReturn3['default'])(this, (CubicBezierEdge.__proto__ || (0, _getPrototypeOf2['default'])(CubicBezierEdge)).call(this, options, body, labelModule));
  }

  /**
   * Draw a line between two nodes
   * @param {CanvasRenderingContext2D} ctx
   * @param {ArrowOptions} values
   * @param {Array.<Node>} viaNodes
   * @private
   */


  (0, _createClass3['default'])(CubicBezierEdge, [{
    key: '_line',
    value: function _line(ctx, values, viaNodes) {
      // get the coordinates of the support points.
      var via1 = viaNodes[0];
      var via2 = viaNodes[1];
      this._bezierCurve(ctx, values, via1, via2);
    }

    /**
     *
     * @returns {Array.<{x: number, y: number}>}
     * @private
     */

  }, {
    key: '_getViaCoordinates',
    value: function _getViaCoordinates() {
      var dx = this.from.x - this.to.x;
      var dy = this.from.y - this.to.y;

      var x1 = void 0,
          y1 = void 0,
          x2 = void 0,
          y2 = void 0;
      var roundness = this.options.smooth.roundness;

      // horizontal if x > y or if direction is forced or if direction is horizontal
      if ((Math.abs(dx) > Math.abs(dy) || this.options.smooth.forceDirection === true || this.options.smooth.forceDirection === 'horizontal') && this.options.smooth.forceDirection !== 'vertical') {
        y1 = this.from.y;
        y2 = this.to.y;
        x1 = this.from.x - roundness * dx;
        x2 = this.to.x + roundness * dx;
      } else {
        y1 = this.from.y - roundness * dy;
        y2 = this.to.y + roundness * dy;
        x1 = this.from.x;
        x2 = this.to.x;
      }

      return [{ x: x1, y: y1 }, { x: x2, y: y2 }];
    }

    /**
     *
     * @returns {Array.<{x: number, y: number}>}
     */

  }, {
    key: 'getViaNode',
    value: function getViaNode() {
      return this._getViaCoordinates();
    }

    /**
     *
     * @param {Node} nearNode
     * @param {CanvasRenderingContext2D} ctx
     * @returns {{x: number, y: number, t: number}}
     * @private
     */

  }, {
    key: '_findBorderPosition',
    value: function _findBorderPosition(nearNode, ctx) {
      return this._findBorderPositionBezier(nearNode, ctx);
    }

    /**
     *
     * @param {number} x1
     * @param {number} y1
     * @param {number} x2
     * @param {number} y2
     * @param {number} x3
     * @param {number} y3
     * @param {Node} via1
     * @param {Node} via2
     * @returns {number}
     * @private
     */

  }, {
    key: '_getDistanceToEdge',
    value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
      var _ref = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : this._getViaCoordinates(),
          _ref2 = (0, _slicedToArray3['default'])(_ref, 2),
          via1 = _ref2[0],
          via2 = _ref2[1];

      // x3,y3 is the point
      return this._getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, via1, via2);
    }

    /**
     * Combined function of pointOnLine and pointOnBezier. This gives the coordinates of a point on the line at a certain percentage of the way
     * @param {number} percentage
     * @param {{x: number, y: number}} [via1=this._getViaCoordinates()[0]]
     * @param {{x: number, y: number}} [via2=this._getViaCoordinates()[1]]
     * @returns {{x: number, y: number}}
     * @private
     */

  }, {
    key: 'getPoint',
    value: function getPoint(percentage) {
      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._getViaCoordinates(),
          _ref4 = (0, _slicedToArray3['default'])(_ref3, 2),
          via1 = _ref4[0],
          via2 = _ref4[1];

      var t = percentage;
      var vec = [];
      vec[0] = Math.pow(1 - t, 3);
      vec[1] = 3 * t * Math.pow(1 - t, 2);
      vec[2] = 3 * Math.pow(t, 2) * (1 - t);
      vec[3] = Math.pow(t, 3);
      var x = vec[0] * this.fromPoint.x + vec[1] * via1.x + vec[2] * via2.x + vec[3] * this.toPoint.x;
      var y = vec[0] * this.fromPoint.y + vec[1] * via1.y + vec[2] * via2.y + vec[3] * this.toPoint.y;

      return { x: x, y: y };
    }
  }]);
  return CubicBezierEdge;
}(_CubicBezierEdgeBase3['default']);

exports['default'] = CubicBezierEdge;

/***/ }),
/* 167 */
/***/ (function(module, exports, __nested_webpack_require_826989__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = __nested_webpack_require_826989__(3);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __nested_webpack_require_826989__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_826989__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __nested_webpack_require_826989__(4);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __nested_webpack_require_826989__(5);

var _inherits3 = _interopRequireDefault(_inherits2);

var _BezierEdgeBase2 = __nested_webpack_require_826989__(56);

var _BezierEdgeBase3 = _interopRequireDefault(_BezierEdgeBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * A Base Class for all Cubic Bezier Edges. Bezier curves are used to model
 * smooth gradual curves in paths between nodes.
 *
 * @extends BezierEdgeBase
 */
var CubicBezierEdgeBase = function (_BezierEdgeBase) {
  (0, _inherits3['default'])(CubicBezierEdgeBase, _BezierEdgeBase);

  /**
   * @param {Object} options
   * @param {Object} body
   * @param {Label} labelModule
   */
  function CubicBezierEdgeBase(options, body, labelModule) {
    (0, _classCallCheck3['default'])(this, CubicBezierEdgeBase);
    return (0, _possibleConstructorReturn3['default'])(this, (CubicBezierEdgeBase.__proto__ || (0, _getPrototypeOf2['default'])(CubicBezierEdgeBase)).call(this, options, body, labelModule));
  }

  /**
   * Calculate the distance between a point (x3,y3) and a line segment from
   * (x1,y1) to (x2,y2).
   * http://stackoverflow.com/questions/849211/shortest-distancae-between-a-point-and-a-line-segment
   * https://en.wikipedia.org/wiki/B%C3%A9zier_curve
   * @param {number} x1 from x
   * @param {number} y1 from y
   * @param {number} x2 to x
   * @param {number} y2 to y
   * @param {number} x3 point to check x
   * @param {number} y3 point to check y
   * @param {Node} via1
   * @param {Node} via2
   * @returns {number}
   * @private
   */


  (0, _createClass3['default'])(CubicBezierEdgeBase, [{
    key: '_getDistanceToBezierEdge',
    value: function _getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, via1, via2) {
      // x3,y3 is the point
      var minDistance = 1e9;
      var distance = void 0;
      var i = void 0,
          t = void 0,
          x = void 0,
          y = void 0;
      var lastX = x1;
      var lastY = y1;
      var vec = [0, 0, 0, 0];
      for (i = 1; i < 10; i++) {
        t = 0.1 * i;
        vec[0] = Math.pow(1 - t, 3);
        vec[1] = 3 * t * Math.pow(1 - t, 2);
        vec[2] = 3 * Math.pow(t, 2) * (1 - t);
        vec[3] = Math.pow(t, 3);
        x = vec[0] * x1 + vec[1] * via1.x + vec[2] * via2.x + vec[3] * x2;
        y = vec[0] * y1 + vec[1] * via1.y + vec[2] * via2.y + vec[3] * y2;
        if (i > 0) {
          distance = this._getDistanceToLine(lastX, lastY, x, y, x3, y3);
          minDistance = distance < minDistance ? distance : minDistance;
        }
        lastX = x;
        lastY = y;
      }

      return minDistance;
    }
  }]);
  return CubicBezierEdgeBase;
}(_BezierEdgeBase3['default']);

exports['default'] = CubicBezierEdgeBase;

/***/ }),
/* 168 */
/***/ (function(module, exports, __nested_webpack_require_830360__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray2 = __nested_webpack_require_830360__(15);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _getPrototypeOf = __nested_webpack_require_830360__(3);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __nested_webpack_require_830360__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_830360__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __nested_webpack_require_830360__(4);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __nested_webpack_require_830360__(5);

var _inherits3 = _interopRequireDefault(_inherits2);

var _BezierEdgeBase2 = __nested_webpack_require_830360__(56);

var _BezierEdgeBase3 = _interopRequireDefault(_BezierEdgeBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * A Dynamic Bezier Edge. Bezier curves are used to model smooth gradual
 * curves in paths between nodes. The Dynamic piece refers to how the curve
 * reacts to physics changes.
 *
 * @extends BezierEdgeBase
 */
var BezierEdgeDynamic = function (_BezierEdgeBase) {
  (0, _inherits3['default'])(BezierEdgeDynamic, _BezierEdgeBase);

  /**
   * @param {Object} options
   * @param {Object} body
   * @param {Label} labelModule
   */
  function BezierEdgeDynamic(options, body, labelModule) {
    (0, _classCallCheck3['default'])(this, BezierEdgeDynamic);

    // --> this calls the setOptions below
    var _this = (0, _possibleConstructorReturn3['default'])(this, (BezierEdgeDynamic.__proto__ || (0, _getPrototypeOf2['default'])(BezierEdgeDynamic)).call(this, options, body, labelModule));
    //this.via = undefined; // Here for completeness but not allowed to defined before super() is invoked.


    _this._boundFunction = function () {
      _this.positionBezierNode();
    };
    _this.body.emitter.on('_repositionBezierNodes', _this._boundFunction);
    return _this;
  }

  /**
   *
   * @param {Object} options
   */


  (0, _createClass3['default'])(BezierEdgeDynamic, [{
    key: 'setOptions',
    value: function setOptions(options) {
      // check if the physics has changed.
      var physicsChange = false;
      if (this.options.physics !== options.physics) {
        physicsChange = true;
      }

      // set the options and the to and from nodes
      this.options = options;
      this.id = this.options.id;
      this.from = this.body.nodes[this.options.from];
      this.to = this.body.nodes[this.options.to];

      // setup the support node and connect
      this.setupSupportNode();
      this.connect();

      // when we change the physics state of the edge, we reposition the support node.
      if (physicsChange === true) {
        this.via.setOptions({ physics: this.options.physics });
        this.positionBezierNode();
      }
    }

    /**
     * Connects an edge to node(s)
     */

  }, {
    key: 'connect',
    value: function connect() {
      this.from = this.body.nodes[this.options.from];
      this.to = this.body.nodes[this.options.to];
      if (this.from === undefined || this.to === undefined || this.options.physics === false) {
        this.via.setOptions({ physics: false });
      } else {
        // fix weird behaviour where a self referencing node has physics enabled
        if (this.from.id === this.to.id) {
          this.via.setOptions({ physics: false });
        } else {
          this.via.setOptions({ physics: true });
        }
      }
    }

    /**
     * remove the support nodes
     * @returns {boolean}
     */

  }, {
    key: 'cleanup',
    value: function cleanup() {
      this.body.emitter.off('_repositionBezierNodes', this._boundFunction);
      if (this.via !== undefined) {
        delete this.body.nodes[this.via.id];
        this.via = undefined;
        return true;
      }
      return false;
    }

    /**
     * Bezier curves require an anchor point to calculate the smooth flow. These points are nodes. These nodes are invisible but
     * are used for the force calculation.
     *
     * The changed data is not called, if needed, it is returned by the main edge constructor.
     * @private
     */

  }, {
    key: 'setupSupportNode',
    value: function setupSupportNode() {
      if (this.via === undefined) {
        var nodeId = 'edgeId:' + this.id;
        var node = this.body.functions.createNode({
          id: nodeId,
          shape: 'circle',
          physics: true,
          hidden: true
        });
        this.body.nodes[nodeId] = node;
        this.via = node;
        this.via.parentEdgeId = this.id;
        this.positionBezierNode();
      }
    }

    /**
     * Positions bezier node
     */

  }, {
    key: 'positionBezierNode',
    value: function positionBezierNode() {
      if (this.via !== undefined && this.from !== undefined && this.to !== undefined) {
        this.via.x = 0.5 * (this.from.x + this.to.x);
        this.via.y = 0.5 * (this.from.y + this.to.y);
      } else if (this.via !== undefined) {
        this.via.x = 0;
        this.via.y = 0;
      }
    }

    /**
     * Draw a line between two nodes
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     * @param {Node} viaNode
     * @private
     */

  }, {
    key: '_line',
    value: function _line(ctx, values, viaNode) {
      this._bezierCurve(ctx, values, viaNode);
    }

    /**
     *
     * @returns {Node|undefined|*|{index, line, column}}
     */

  }, {
    key: 'getViaNode',
    value: function getViaNode() {
      return this.via;
    }

    /**
     * Combined function of pointOnLine and pointOnBezier. This gives the coordinates of a point on the line at a certain percentage of the way
     *
     * @param {number} percentage
     * @param {Node} viaNode
     * @returns {{x: number, y: number}}
     * @private
     */

  }, {
    key: 'getPoint',
    value: function getPoint(percentage) {
      var viaNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.via;

      var t = percentage;
      var x = void 0,
          y = void 0;
      if (this.from === this.to) {
        var _getCircleData = this._getCircleData(this.from),
            _getCircleData2 = (0, _slicedToArray3['default'])(_getCircleData, 3),
            cx = _getCircleData2[0],
            cy = _getCircleData2[1],
            cr = _getCircleData2[2];

        var a = 2 * Math.PI * (1 - t);
        x = cx + cr * Math.sin(a);
        y = cy + cr - cr * (1 - Math.cos(a));
      } else {
        x = Math.pow(1 - t, 2) * this.fromPoint.x + 2 * t * (1 - t) * viaNode.x + Math.pow(t, 2) * this.toPoint.x;
        y = Math.pow(1 - t, 2) * this.fromPoint.y + 2 * t * (1 - t) * viaNode.y + Math.pow(t, 2) * this.toPoint.y;
      }

      return { x: x, y: y };
    }

    /**
     *
     * @param {Node} nearNode
     * @param {CanvasRenderingContext2D} ctx
     * @returns {*}
     * @private
     */

  }, {
    key: '_findBorderPosition',
    value: function _findBorderPosition(nearNode, ctx) {
      return this._findBorderPositionBezier(nearNode, ctx, this.via);
    }

    /**
     *
     * @param {number} x1
     * @param {number} y1
     * @param {number} x2
     * @param {number} y2
     * @param {number} x3
     * @param {number} y3
     * @returns {number}
     * @private
     */

  }, {
    key: '_getDistanceToEdge',
    value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
      // x3,y3 is the point
      return this._getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, this.via);
    }
  }]);
  return BezierEdgeDynamic;
}(_BezierEdgeBase3['default']);

exports['default'] = BezierEdgeDynamic;

/***/ }),
/* 169 */
/***/ (function(module, exports, __nested_webpack_require_838185__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = __nested_webpack_require_838185__(3);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __nested_webpack_require_838185__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_838185__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __nested_webpack_require_838185__(4);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __nested_webpack_require_838185__(5);

var _inherits3 = _interopRequireDefault(_inherits2);

var _BezierEdgeBase2 = __nested_webpack_require_838185__(56);

var _BezierEdgeBase3 = _interopRequireDefault(_BezierEdgeBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * A Static Bezier Edge. Bezier curves are used to model smooth gradual
 * curves in paths between nodes.
 *
 * @extends BezierEdgeBase
 */
var BezierEdgeStatic = function (_BezierEdgeBase) {
  (0, _inherits3['default'])(BezierEdgeStatic, _BezierEdgeBase);

  /**
   * @param {Object} options
   * @param {Object} body
   * @param {Label} labelModule
   */
  function BezierEdgeStatic(options, body, labelModule) {
    (0, _classCallCheck3['default'])(this, BezierEdgeStatic);
    return (0, _possibleConstructorReturn3['default'])(this, (BezierEdgeStatic.__proto__ || (0, _getPrototypeOf2['default'])(BezierEdgeStatic)).call(this, options, body, labelModule));
  }

  /**
   * Draw a line between two nodes
   * @param {CanvasRenderingContext2D} ctx
   * @param {ArrowOptions} values
   * @param {Node} viaNode
   * @private
   */


  (0, _createClass3['default'])(BezierEdgeStatic, [{
    key: '_line',
    value: function _line(ctx, values, viaNode) {
      this._bezierCurve(ctx, values, viaNode);
    }

    /**
     *
     * @returns {Array.<{x: number, y: number}>}
     */

  }, {
    key: 'getViaNode',
    value: function getViaNode() {
      return this._getViaCoordinates();
    }

    /**
     * We do not use the to and fromPoints here to make the via nodes the same as edges without arrows.
     * @returns {{x: undefined, y: undefined}}
     * @private
     */

  }, {
    key: '_getViaCoordinates',
    value: function _getViaCoordinates() {
      // Assumption: x/y coordinates in from/to always defined
      var xVia = undefined;
      var yVia = undefined;
      var factor = this.options.smooth.roundness;
      var type = this.options.smooth.type;
      var dx = Math.abs(this.from.x - this.to.x);
      var dy = Math.abs(this.from.y - this.to.y);
      if (type === 'discrete' || type === 'diagonalCross') {
        var stepX = void 0;
        var stepY = void 0;

        if (dx <= dy) {
          stepX = stepY = factor * dy;
        } else {
          stepX = stepY = factor * dx;
        }

        if (this.from.x > this.to.x) stepX = -stepX;
        if (this.from.y >= this.to.y) stepY = -stepY;

        xVia = this.from.x + stepX;
        yVia = this.from.y + stepY;

        if (type === 'discrete') {
          if (dx <= dy) {
            xVia = dx < factor * dy ? this.from.x : xVia;
          } else {
            yVia = dy < factor * dx ? this.from.y : yVia;
          }
        }
      } else if (type === 'straightCross') {
        var _stepX = (1 - factor) * dx;
        var _stepY = (1 - factor) * dy;

        if (dx <= dy) {
          // up - down
          _stepX = 0;
          if (this.from.y < this.to.y) _stepY = -_stepY;
        } else {
          // left - right
          if (this.from.x < this.to.x) _stepX = -_stepX;
          _stepY = 0;
        }
        xVia = this.to.x + _stepX;
        yVia = this.to.y + _stepY;
      } else if (type === 'horizontal') {
        var _stepX2 = (1 - factor) * dx;
        if (this.from.x < this.to.x) _stepX2 = -_stepX2;
        xVia = this.to.x + _stepX2;
        yVia = this.from.y;
      } else if (type === 'vertical') {
        var _stepY2 = (1 - factor) * dy;
        if (this.from.y < this.to.y) _stepY2 = -_stepY2;
        xVia = this.from.x;
        yVia = this.to.y + _stepY2;
      } else if (type === 'curvedCW') {
        dx = this.to.x - this.from.x;
        dy = this.from.y - this.to.y;
        var radius = Math.sqrt(dx * dx + dy * dy);
        var pi = Math.PI;

        var originalAngle = Math.atan2(dy, dx);
        var myAngle = (originalAngle + (factor * 0.5 + 0.5) * pi) % (2 * pi);

        xVia = this.from.x + (factor * 0.5 + 0.5) * radius * Math.sin(myAngle);
        yVia = this.from.y + (factor * 0.5 + 0.5) * radius * Math.cos(myAngle);
      } else if (type === 'curvedCCW') {
        dx = this.to.x - this.from.x;
        dy = this.from.y - this.to.y;
        var _radius = Math.sqrt(dx * dx + dy * dy);
        var _pi = Math.PI;

        var _originalAngle = Math.atan2(dy, dx);
        var _myAngle = (_originalAngle + (-factor * 0.5 + 0.5) * _pi) % (2 * _pi);

        xVia = this.from.x + (factor * 0.5 + 0.5) * _radius * Math.sin(_myAngle);
        yVia = this.from.y + (factor * 0.5 + 0.5) * _radius * Math.cos(_myAngle);
      } else {
        // continuous
        var _stepX3 = void 0;
        var _stepY3 = void 0;

        if (dx <= dy) {
          _stepX3 = _stepY3 = factor * dy;
        } else {
          _stepX3 = _stepY3 = factor * dx;
        }

        if (this.from.x > this.to.x) _stepX3 = -_stepX3;
        if (this.from.y >= this.to.y) _stepY3 = -_stepY3;

        xVia = this.from.x + _stepX3;
        yVia = this.from.y + _stepY3;

        if (dx <= dy) {
          if (this.from.x <= this.to.x) {
            xVia = this.to.x < xVia ? this.to.x : xVia;
          } else {
            xVia = this.to.x > xVia ? this.to.x : xVia;
          }
        } else {
          if (this.from.y >= this.to.y) {
            yVia = this.to.y > yVia ? this.to.y : yVia;
          } else {
            yVia = this.to.y < yVia ? this.to.y : yVia;
          }
        }
      }
      return { x: xVia, y: yVia };
    }

    /**
     *
     * @param {Node} nearNode
     * @param {CanvasRenderingContext2D} ctx
     * @param {Object} options
     * @returns {*}
     * @private
     */

  }, {
    key: '_findBorderPosition',
    value: function _findBorderPosition(nearNode, ctx) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      return this._findBorderPositionBezier(nearNode, ctx, options.via);
    }

    /**
     *
     * @param {number} x1
     * @param {number} y1
     * @param {number} x2
     * @param {number} y2
     * @param {number} x3
     * @param {number} y3
     * @param {Node} viaNode
     * @returns {number}
     * @private
     */

  }, {
    key: '_getDistanceToEdge',
    value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
      var viaNode = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : this._getViaCoordinates();

      // x3,y3 is the point
      return this._getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, viaNode);
    }

    /**
     * Combined function of pointOnLine and pointOnBezier. This gives the coordinates of a point on the line at a certain percentage of the way
     * @param {number} percentage
     * @param {Node} viaNode
     * @returns {{x: number, y: number}}
     * @private
     */

  }, {
    key: 'getPoint',
    value: function getPoint(percentage) {
      var viaNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._getViaCoordinates();

      var t = percentage;
      var x = Math.pow(1 - t, 2) * this.fromPoint.x + 2 * t * (1 - t) * viaNode.x + Math.pow(t, 2) * this.toPoint.x;
      var y = Math.pow(1 - t, 2) * this.fromPoint.y + 2 * t * (1 - t) * viaNode.y + Math.pow(t, 2) * this.toPoint.y;

      return { x: x, y: y };
    }
  }]);
  return BezierEdgeStatic;
}(_BezierEdgeBase3['default']);

exports['default'] = BezierEdgeStatic;

/***/ }),
/* 170 */
/***/ (function(module, exports, __nested_webpack_require_846176__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = __nested_webpack_require_846176__(3);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __nested_webpack_require_846176__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_846176__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __nested_webpack_require_846176__(4);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __nested_webpack_require_846176__(5);

var _inherits3 = _interopRequireDefault(_inherits2);

var _EdgeBase2 = __nested_webpack_require_846176__(79);

var _EdgeBase3 = _interopRequireDefault(_EdgeBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * A Straight Edge.
 *
 * @extends EdgeBase
 */
var StraightEdge = function (_EdgeBase) {
  (0, _inherits3['default'])(StraightEdge, _EdgeBase);

  /**
   * @param {Object} options
   * @param {Object} body
   * @param {Label} labelModule
   */
  function StraightEdge(options, body, labelModule) {
    (0, _classCallCheck3['default'])(this, StraightEdge);
    return (0, _possibleConstructorReturn3['default'])(this, (StraightEdge.__proto__ || (0, _getPrototypeOf2['default'])(StraightEdge)).call(this, options, body, labelModule));
  }

  /**
   * Draw a line between two nodes
   * @param {CanvasRenderingContext2D} ctx
   * @param {ArrowOptions} values
   * @private
   */


  (0, _createClass3['default'])(StraightEdge, [{
    key: '_line',
    value: function _line(ctx, values) {
      // draw a straight line
      ctx.beginPath();
      ctx.moveTo(this.fromPoint.x, this.fromPoint.y);
      ctx.lineTo(this.toPoint.x, this.toPoint.y);
      // draw shadow if enabled
      this.enableShadow(ctx, values);
      ctx.stroke();
      this.disableShadow(ctx, values);
    }

    /**
     *
     * @returns {undefined}
     */

  }, {
    key: 'getViaNode',
    value: function getViaNode() {
      return undefined;
    }

    /**
     * Combined function of pointOnLine and pointOnBezier. This gives the coordinates of a point on the line at a certain percentage of the way
     *
     * @param {number} percentage
     * @returns {{x: number, y: number}}
     * @private
     */

  }, {
    key: 'getPoint',
    value: function getPoint(percentage) {
      return {
        x: (1 - percentage) * this.fromPoint.x + percentage * this.toPoint.x,
        y: (1 - percentage) * this.fromPoint.y + percentage * this.toPoint.y
      };
    }

    /**
     *
     * @param {Node} nearNode
     * @param {CanvasRenderingContext2D} ctx
     * @returns {{x: number, y: number}}
     * @private
     */

  }, {
    key: '_findBorderPosition',
    value: function _findBorderPosition(nearNode, ctx) {
      var node1 = this.to;
      var node2 = this.from;
      if (nearNode.id === this.from.id) {
        node1 = this.from;
        node2 = this.to;
      }

      var angle = Math.atan2(node1.y - node2.y, node1.x - node2.x);
      var dx = node1.x - node2.x;
      var dy = node1.y - node2.y;
      var edgeSegmentLength = Math.sqrt(dx * dx + dy * dy);
      var toBorderDist = nearNode.distanceToBorder(ctx, angle);
      var toBorderPoint = (edgeSegmentLength - toBorderDist) / edgeSegmentLength;

      var borderPos = {};
      borderPos.x = (1 - toBorderPoint) * node2.x + toBorderPoint * node1.x;
      borderPos.y = (1 - toBorderPoint) * node2.y + toBorderPoint * node1.y;

      return borderPos;
    }

    /**
     *
     * @param {number} x1
     * @param {number} y1
     * @param {number} x2
     * @param {number} y2
     * @param {number} x3
     * @param {number} y3
     * @returns {number}
     * @private
     */

  }, {
    key: '_getDistanceToEdge',
    value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
      // x3,y3 is the point
      return this._getDistanceToLine(x1, y1, x2, y2, x3, y3);
    }
  }]);
  return StraightEdge;
}(_EdgeBase3['default']);

exports['default'] = StraightEdge;

/***/ }),
/* 171 */
/***/ (function(module, exports, __nested_webpack_require_850332__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __nested_webpack_require_850332__(9);

var _keys2 = _interopRequireDefault(_keys);

var _classCallCheck2 = __nested_webpack_require_850332__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_850332__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var BarnesHutSolver = __nested_webpack_require_850332__(81)['default'];
var Repulsion = __nested_webpack_require_850332__(172)['default'];
var HierarchicalRepulsion = __nested_webpack_require_850332__(173)['default'];
var SpringSolver = __nested_webpack_require_850332__(174)['default'];
var HierarchicalSpringSolver = __nested_webpack_require_850332__(175)['default'];
var CentralGravitySolver = __nested_webpack_require_850332__(82)['default'];
var ForceAtlas2BasedRepulsionSolver = __nested_webpack_require_850332__(176)['default'];
var ForceAtlas2BasedCentralGravitySolver = __nested_webpack_require_850332__(177)['default'];
var util = __nested_webpack_require_850332__(2);
var EndPoints = __nested_webpack_require_850332__(80)['default']; // for debugging with _drawForces()

/**
 * The physics engine
 */

var PhysicsEngine = function () {
  /**
   * @param {Object} body
   */
  function PhysicsEngine(body) {
    (0, _classCallCheck3['default'])(this, PhysicsEngine);

    this.body = body;
    this.physicsBody = {
      physicsNodeIndices: [],
      physicsEdgeIndices: [],
      forces: {},
      velocities: {}
    };

    this.physicsEnabled = true;
    this.simulationInterval = 1000 / 60;
    this.requiresTimeout = true;
    this.previousStates = {};
    this.referenceState = {};
    this.freezeCache = {};
    this.renderTimer = undefined;

    // parameters for the adaptive timestep
    this.adaptiveTimestep = false;
    this.adaptiveTimestepEnabled = false;
    this.adaptiveCounter = 0;
    this.adaptiveInterval = 3;

    this.stabilized = false;
    this.startedStabilization = false;
    this.stabilizationIterations = 0;
    this.ready = false; // will be set to true if the stabilize

    // default options
    this.options = {};
    this.defaultOptions = {
      enabled: true,
      barnesHut: {
        theta: 0.5,
        gravitationalConstant: -2000,
        centralGravity: 0.3,
        springLength: 95,
        springConstant: 0.04,
        damping: 0.09,
        avoidOverlap: 0
      },
      forceAtlas2Based: {
        theta: 0.5,
        gravitationalConstant: -50,
        centralGravity: 0.01,
        springConstant: 0.08,
        springLength: 100,
        damping: 0.4,
        avoidOverlap: 0
      },
      repulsion: {
        centralGravity: 0.2,
        springLength: 200,
        springConstant: 0.05,
        nodeDistance: 100,
        damping: 0.09,
        avoidOverlap: 0
      },
      hierarchicalRepulsion: {
        centralGravity: 0.0,
        springLength: 100,
        springConstant: 0.01,
        nodeDistance: 120,
        damping: 0.09
      },
      maxVelocity: 50,
      minVelocity: 0.75, // px/s
      solver: 'barnesHut',
      stabilization: {
        enabled: true,
        iterations: 1000, // maximum number of iteration to stabilize
        updateInterval: 50,
        onlyDynamicEdges: false,
        fit: true
      },
      timestep: 0.5,
      adaptiveTimestep: true
    };
    util.extend(this.options, this.defaultOptions);
    this.timestep = 0.5;
    this.layoutFailed = false;

    this.bindEventListeners();
  }

  /**
   * Binds event listeners
   */


  (0, _createClass3['default'])(PhysicsEngine, [{
    key: 'bindEventListeners',
    value: function bindEventListeners() {
      var _this = this;

      this.body.emitter.on('initPhysics', function () {
        _this.initPhysics();
      });
      this.body.emitter.on('_layoutFailed', function () {
        _this.layoutFailed = true;
      });
      this.body.emitter.on('resetPhysics', function () {
        _this.stopSimulation();
        _this.ready = false;
      });
      this.body.emitter.on('disablePhysics', function () {
        _this.physicsEnabled = false;
        _this.stopSimulation();
      });
      this.body.emitter.on('restorePhysics', function () {
        _this.setOptions(_this.options);
        if (_this.ready === true) {
          _this.startSimulation();
        }
      });
      this.body.emitter.on('startSimulation', function () {
        if (_this.ready === true) {
          _this.startSimulation();
        }
      });
      this.body.emitter.on('stopSimulation', function () {
        _this.stopSimulation();
      });
      this.body.emitter.on('destroy', function () {
        _this.stopSimulation(false);
        _this.body.emitter.off();
      });
      this.body.emitter.on('_dataChanged', function () {
        // Nodes and/or edges have been added or removed, update shortcut lists.
        _this.updatePhysicsData();
      });

      // debug: show forces
      // this.body.emitter.on("afterDrawing", (ctx) => {this._drawForces(ctx);});
    }

    /**
     * set the physics options
     * @param {Object} options
     */

  }, {
    key: 'setOptions',
    value: function setOptions(options) {
      if (options !== undefined) {
        if (options === false) {
          this.options.enabled = false;
          this.physicsEnabled = false;
          this.stopSimulation();
        } else if (options === true) {
          this.options.enabled = true;
          this.physicsEnabled = true;
          this.startSimulation();
        } else {
          this.physicsEnabled = true;
          util.selectiveNotDeepExtend(['stabilization'], this.options, options);
          util.mergeOptions(this.options, options, 'stabilization');

          if (options.enabled === undefined) {
            this.options.enabled = true;
          }

          if (this.options.enabled === false) {
            this.physicsEnabled = false;
            this.stopSimulation();
          }

          // set the timestep
          this.timestep = this.options.timestep;
        }
      }
      this.init();
    }

    /**
     * configure the engine.
     */

  }, {
    key: 'init',
    value: function init() {
      var options;
      if (this.options.solver === 'forceAtlas2Based') {
        options = this.options.forceAtlas2Based;
        this.nodesSolver = new ForceAtlas2BasedRepulsionSolver(this.body, this.physicsBody, options);
        this.edgesSolver = new SpringSolver(this.body, this.physicsBody, options);
        this.gravitySolver = new ForceAtlas2BasedCentralGravitySolver(this.body, this.physicsBody, options);
      } else if (this.options.solver === 'repulsion') {
        options = this.options.repulsion;
        this.nodesSolver = new Repulsion(this.body, this.physicsBody, options);
        this.edgesSolver = new SpringSolver(this.body, this.physicsBody, options);
        this.gravitySolver = new CentralGravitySolver(this.body, this.physicsBody, options);
      } else if (this.options.solver === 'hierarchicalRepulsion') {
        options = this.options.hierarchicalRepulsion;
        this.nodesSolver = new HierarchicalRepulsion(this.body, this.physicsBody, options);
        this.edgesSolver = new HierarchicalSpringSolver(this.body, this.physicsBody, options);
        this.gravitySolver = new CentralGravitySolver(this.body, this.physicsBody, options);
      } else {
        // barnesHut
        options = this.options.barnesHut;
        this.nodesSolver = new BarnesHutSolver(this.body, this.physicsBody, options);
        this.edgesSolver = new SpringSolver(this.body, this.physicsBody, options);
        this.gravitySolver = new CentralGravitySolver(this.body, this.physicsBody, options);
      }

      this.modelOptions = options;
    }

    /**
     * initialize the engine
     */

  }, {
    key: 'initPhysics',
    value: function initPhysics() {
      if (this.physicsEnabled === true && this.options.enabled === true) {
        if (this.options.stabilization.enabled === true) {
          this.stabilize();
        } else {
          this.stabilized = false;
          this.ready = true;
          this.body.emitter.emit('fit', {}, this.layoutFailed); // if the layout failed, we use the approximation for the zoom
          this.startSimulation();
        }
      } else {
        this.ready = true;
        this.body.emitter.emit('fit');
      }
    }

    /**
     * Start the simulation
     */

  }, {
    key: 'startSimulation',
    value: function startSimulation() {
      if (this.physicsEnabled === true && this.options.enabled === true) {
        this.stabilized = false;

        // when visible, adaptivity is disabled.
        this.adaptiveTimestep = false;

        // this sets the width of all nodes initially which could be required for the avoidOverlap
        this.body.emitter.emit('_resizeNodes');
        if (this.viewFunction === undefined) {
          this.viewFunction = this.simulationStep.bind(this);
          this.body.emitter.on('initRedraw', this.viewFunction);
          this.body.emitter.emit('_startRendering');
        }
      } else {
        this.body.emitter.emit('_redraw');
      }
    }

    /**
     * Stop the simulation, force stabilization.
     * @param {boolean} [emit=true]
     */

  }, {
    key: 'stopSimulation',
    value: function stopSimulation() {
      var emit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      this.stabilized = true;
      if (emit === true) {
        this._emitStabilized();
      }
      if (this.viewFunction !== undefined) {
        this.body.emitter.off('initRedraw', this.viewFunction);
        this.viewFunction = undefined;
        if (emit === true) {
          this.body.emitter.emit('_stopRendering');
        }
      }
    }

    /**
     * The viewFunction inserts this step into each render loop. It calls the physics tick and handles the cleanup at stabilized.
     *
     */

  }, {
    key: 'simulationStep',
    value: function simulationStep() {
      // check if the physics have settled
      var startTime = Date.now();
      this.physicsTick();
      var physicsTime = Date.now() - startTime;

      // run double speed if it is a little graph
      if ((physicsTime < 0.4 * this.simulationInterval || this.runDoubleSpeed === true) && this.stabilized === false) {
        this.physicsTick();

        // this makes sure there is no jitter. The decision is taken once to run it at double speed.
        this.runDoubleSpeed = true;
      }

      if (this.stabilized === true) {
        this.stopSimulation();
      }
    }

    /**
     * trigger the stabilized event.
     *
     * @param {number} [amountOfIterations=this.stabilizationIterations]
     * @private
     */

  }, {
    key: '_emitStabilized',
    value: function _emitStabilized() {
      var _this2 = this;

      var amountOfIterations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.stabilizationIterations;

      if (this.stabilizationIterations > 1 || this.startedStabilization === true) {
        setTimeout(function () {
          _this2.body.emitter.emit('stabilized', { iterations: amountOfIterations });
          _this2.startedStabilization = false;
          _this2.stabilizationIterations = 0;
        }, 0);
      }
    }

    /**
     * Calculate the forces for one physics iteration and move the nodes.
     * @private
     */

  }, {
    key: 'physicsStep',
    value: function physicsStep() {
      this.gravitySolver.solve();
      this.nodesSolver.solve();
      this.edgesSolver.solve();
      this.moveNodes();
    }

    /**
     * Make dynamic adjustments to the timestep, based on current state.
     *
     * Helper function for physicsTick().
     * @private
     */

  }, {
    key: 'adjustTimeStep',
    value: function adjustTimeStep() {
      var factor = 1.2; // Factor for increasing the timestep on success.

      // we compare the two steps. if it is acceptable we double the step.
      if (this._evaluateStepQuality() === true) {
        this.timestep = factor * this.timestep;
      } else {
        // if not, we decrease the step to a minimum of the options timestep.
        // if the decreased timestep is smaller than the options step, we do not reset the counter
        // we assume that the options timestep is stable enough.
        if (this.timestep / factor < this.options.timestep) {
          this.timestep = this.options.timestep;
        } else {
          // if the timestep was larger than 2 times the option one we check the adaptivity again to ensure
          // that large instabilities do not form.
          this.adaptiveCounter = -1; // check again next iteration
          this.timestep = Math.max(this.options.timestep, this.timestep / factor);
        }
      }
    }

    /**
     * A single simulation step (or 'tick') in the physics simulation
     *
     * @private
     */

  }, {
    key: 'physicsTick',
    value: function physicsTick() {
      this._startStabilizing(); // this ensures that there is no start event when the network is already stable.
      if (this.stabilized === true) return;

      // adaptivity means the timestep adapts to the situation, only applicable for stabilization
      if (this.adaptiveTimestep === true && this.adaptiveTimestepEnabled === true) {
        // timestep remains stable for "interval" iterations.
        var doAdaptive = this.adaptiveCounter % this.adaptiveInterval === 0;

        if (doAdaptive) {
          // first the big step and revert.
          this.timestep = 2 * this.timestep;
          this.physicsStep();
          this.revert(); // saves the reference state

          // now the normal step. Since this is the last step, it is the more stable one and we will take this.
          this.timestep = 0.5 * this.timestep;

          // since it's half the step, we do it twice.
          this.physicsStep();
          this.physicsStep();

          this.adjustTimeStep();
        } else {
          this.physicsStep(); // normal step, keeping timestep constant
        }

        this.adaptiveCounter += 1;
      } else {
        // case for the static timestep, we reset it to the one in options and take a normal step.
        this.timestep = this.options.timestep;
        this.physicsStep();
      }

      if (this.stabilized === true) this.revert();
      this.stabilizationIterations++;
    }

    /**
     * Nodes and edges can have the physics toggles on or off. A collection of indices is created here so we can skip the check all the time.
     *
     * @private
     */

  }, {
    key: 'updatePhysicsData',
    value: function updatePhysicsData() {
      this.physicsBody.forces = {};
      this.physicsBody.physicsNodeIndices = [];
      this.physicsBody.physicsEdgeIndices = [];
      var nodes = this.body.nodes;
      var edges = this.body.edges;

      // get node indices for physics
      for (var nodeId in nodes) {
        if (nodes.hasOwnProperty(nodeId)) {
          if (nodes[nodeId].options.physics === true) {
            this.physicsBody.physicsNodeIndices.push(nodes[nodeId].id);
          }
        }
      }

      // get edge indices for physics
      for (var edgeId in edges) {
        if (edges.hasOwnProperty(edgeId)) {
          if (edges[edgeId].options.physics === true) {
            this.physicsBody.physicsEdgeIndices.push(edges[edgeId].id);
          }
        }
      }

      // get the velocity and the forces vector
      for (var i = 0; i < this.physicsBody.physicsNodeIndices.length; i++) {
        var _nodeId = this.physicsBody.physicsNodeIndices[i];
        this.physicsBody.forces[_nodeId] = { x: 0, y: 0

          // forces can be reset because they are recalculated. Velocities have to persist.
        };if (this.physicsBody.velocities[_nodeId] === undefined) {
          this.physicsBody.velocities[_nodeId] = { x: 0, y: 0 };
        }
      }

      // clean deleted nodes from the velocity vector
      for (var _nodeId2 in this.physicsBody.velocities) {
        if (nodes[_nodeId2] === undefined) {
          delete this.physicsBody.velocities[_nodeId2];
        }
      }
    }

    /**
     * Revert the simulation one step. This is done so after stabilization, every new start of the simulation will also say stabilized.
     */

  }, {
    key: 'revert',
    value: function revert() {
      var nodeIds = (0, _keys2['default'])(this.previousStates);
      var nodes = this.body.nodes;
      var velocities = this.physicsBody.velocities;
      this.referenceState = {};

      for (var i = 0; i < nodeIds.length; i++) {
        var nodeId = nodeIds[i];
        if (nodes[nodeId] !== undefined) {
          if (nodes[nodeId].options.physics === true) {
            this.referenceState[nodeId] = {
              positions: { x: nodes[nodeId].x, y: nodes[nodeId].y }
            };
            velocities[nodeId].x = this.previousStates[nodeId].vx;
            velocities[nodeId].y = this.previousStates[nodeId].vy;
            nodes[nodeId].x = this.previousStates[nodeId].x;
            nodes[nodeId].y = this.previousStates[nodeId].y;
          }
        } else {
          delete this.previousStates[nodeId];
        }
      }
    }

    /**
     * This compares the reference state to the current state
     *
     * @returns {boolean}
     * @private
     */

  }, {
    key: '_evaluateStepQuality',
    value: function _evaluateStepQuality() {
      var dx = void 0,
          dy = void 0,
          dpos = void 0;
      var nodes = this.body.nodes;
      var reference = this.referenceState;
      var posThreshold = 0.3;

      for (var nodeId in this.referenceState) {
        if (this.referenceState.hasOwnProperty(nodeId) && nodes[nodeId] !== undefined) {
          dx = nodes[nodeId].x - reference[nodeId].positions.x;
          dy = nodes[nodeId].y - reference[nodeId].positions.y;

          dpos = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));

          if (dpos > posThreshold) {
            return false;
          }
        }
      }
      return true;
    }

    /**
     * move the nodes one timestep and check if they are stabilized
     */

  }, {
    key: 'moveNodes',
    value: function moveNodes() {
      var nodeIndices = this.physicsBody.physicsNodeIndices;
      var maxNodeVelocity = 0;
      var averageNodeVelocity = 0;

      // the velocity threshold (energy in the system) for the adaptivity toggle
      var velocityAdaptiveThreshold = 5;

      for (var i = 0; i < nodeIndices.length; i++) {
        var nodeId = nodeIndices[i];
        var nodeVelocity = this._performStep(nodeId);
        // stabilized is true if stabilized is true and velocity is smaller than vmin --> all nodes must be stabilized
        maxNodeVelocity = Math.max(maxNodeVelocity, nodeVelocity);
        averageNodeVelocity += nodeVelocity;
      }

      // evaluating the stabilized and adaptiveTimestepEnabled conditions
      this.adaptiveTimestepEnabled = averageNodeVelocity / nodeIndices.length < velocityAdaptiveThreshold;
      this.stabilized = maxNodeVelocity < this.options.minVelocity;
    }

    /**
     * Calculate new velocity for a coordinate direction
     *
     * @param {number} v  velocity for current coordinate
     * @param {number} f  regular force for current coordinate
     * @param {number} m  mass of current node
     * @returns {number} new velocity for current coordinate
     * @private
     */

  }, {
    key: 'calculateComponentVelocity',
    value: function calculateComponentVelocity(v, f, m) {
      var df = this.modelOptions.damping * v; // damping force
      var a = (f - df) / m; // acceleration

      v += a * this.timestep;

      // Put a limit on the velocities if it is really high
      var maxV = this.options.maxVelocity || 1e9;
      if (Math.abs(v) > maxV) {
        v = v > 0 ? maxV : -maxV;
      }

      return v;
    }

    /**
     * Perform the actual step
     *
     * @param {Node.id} nodeId
     * @returns {number} the new velocity of given node
     * @private
     */

  }, {
    key: '_performStep',
    value: function _performStep(nodeId) {
      var node = this.body.nodes[nodeId];
      var force = this.physicsBody.forces[nodeId];
      var velocity = this.physicsBody.velocities[nodeId];

      // store the state so we can revert
      this.previousStates[nodeId] = {
        x: node.x,
        y: node.y,
        vx: velocity.x,
        vy: velocity.y
      };

      if (node.options.fixed.x === false) {
        velocity.x = this.calculateComponentVelocity(velocity.x, force.x, node.options.mass);
        node.x += velocity.x * this.timestep;
      } else {
        force.x = 0;
        velocity.x = 0;
      }

      if (node.options.fixed.y === false) {
        velocity.y = this.calculateComponentVelocity(velocity.y, force.y, node.options.mass);
        node.y += velocity.y * this.timestep;
      } else {
        force.y = 0;
        velocity.y = 0;
      }

      var totalVelocity = Math.sqrt(Math.pow(velocity.x, 2) + Math.pow(velocity.y, 2));
      return totalVelocity;
    }

    /**
     * When initializing and stabilizing, we can freeze nodes with a predefined position.
     * This greatly speeds up stabilization because only the supportnodes for the smoothCurves have to settle.
     *
     * @private
     */

  }, {
    key: '_freezeNodes',
    value: function _freezeNodes() {
      var nodes = this.body.nodes;
      for (var id in nodes) {
        if (nodes.hasOwnProperty(id)) {
          if (nodes[id].x && nodes[id].y) {
            var fixed = nodes[id].options.fixed;
            this.freezeCache[id] = { x: fixed.x, y: fixed.y };
            fixed.x = true;
            fixed.y = true;
          }
        }
      }
    }

    /**
     * Unfreezes the nodes that have been frozen by _freezeDefinedNodes.
     *
     * @private
     */

  }, {
    key: '_restoreFrozenNodes',
    value: function _restoreFrozenNodes() {
      var nodes = this.body.nodes;
      for (var id in nodes) {
        if (nodes.hasOwnProperty(id)) {
          if (this.freezeCache[id] !== undefined) {
            nodes[id].options.fixed.x = this.freezeCache[id].x;
            nodes[id].options.fixed.y = this.freezeCache[id].y;
          }
        }
      }
      this.freezeCache = {};
    }

    /**
     * Find a stable position for all nodes
     *
     * @param {number} [iterations=this.options.stabilization.iterations]
     */

  }, {
    key: 'stabilize',
    value: function stabilize() {
      var _this3 = this;

      var iterations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options.stabilization.iterations;

      if (typeof iterations !== 'number') {
        iterations = this.options.stabilization.iterations;
        console.log('The stabilize method needs a numeric amount of iterations. Switching to default: ', iterations);
      }

      if (this.physicsBody.physicsNodeIndices.length === 0) {
        this.ready = true;
        return;
      }

      // enable adaptive timesteps
      this.adaptiveTimestep =  true && this.options.adaptiveTimestep;

      // this sets the width of all nodes initially which could be required for the avoidOverlap
      this.body.emitter.emit('_resizeNodes');

      this.stopSimulation(); // stop the render loop
      this.stabilized = false;

      // block redraw requests
      this.body.emitter.emit('_blockRedraw');
      this.targetIterations = iterations;

      // start the stabilization
      if (this.options.stabilization.onlyDynamicEdges === true) {
        this._freezeNodes();
      }
      this.stabilizationIterations = 0;

      setTimeout(function () {
        return _this3._stabilizationBatch();
      }, 0);
    }

    /**
     * If not already stabilizing, start it and emit a start event.
     *
     * @returns {boolean} true if stabilization started with this call
     * @private
     */

  }, {
    key: '_startStabilizing',
    value: function _startStabilizing() {
      if (this.startedStabilization === true) return false;

      this.body.emitter.emit('startStabilizing');
      this.startedStabilization = true;
      return true;
    }

    /**
     * One batch of stabilization
     * @private
     */

  }, {
    key: '_stabilizationBatch',
    value: function _stabilizationBatch() {
      var _this4 = this;

      var running = function running() {
        return _this4.stabilized === false && _this4.stabilizationIterations < _this4.targetIterations;
      };

      var sendProgress = function sendProgress() {
        _this4.body.emitter.emit('stabilizationProgress', {
          iterations: _this4.stabilizationIterations,
          total: _this4.targetIterations
        });
      };

      if (this._startStabilizing()) {
        sendProgress(); // Ensure that there is at least one start event.
      }

      var count = 0;
      while (running() && count < this.options.stabilization.updateInterval) {
        this.physicsTick();
        count++;
      }

      sendProgress();

      if (running()) {
        setTimeout(this._stabilizationBatch.bind(this), 0);
      } else {
        this._finalizeStabilization();
      }
    }

    /**
     * Wrap up the stabilization, fit and emit the events.
     * @private
     */

  }, {
    key: '_finalizeStabilization',
    value: function _finalizeStabilization() {
      this.body.emitter.emit('_allowRedraw');
      if (this.options.stabilization.fit === true) {
        this.body.emitter.emit('fit');
      }

      if (this.options.stabilization.onlyDynamicEdges === true) {
        this._restoreFrozenNodes();
      }

      this.body.emitter.emit('stabilizationIterationsDone');
      this.body.emitter.emit('_requestRedraw');

      if (this.stabilized === true) {
        this._emitStabilized();
      } else {
        this.startSimulation();
      }

      this.ready = true;
    }

    //---------------------------  DEBUGGING BELOW  ---------------------------//

    /**
     * Debug function that display arrows for the forces currently active in the network.
     *
     * Use this when debugging only.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @private
     */

  }, {
    key: '_drawForces',
    value: function _drawForces(ctx) {
      for (var i = 0; i < this.physicsBody.physicsNodeIndices.length; i++) {
        var index = this.physicsBody.physicsNodeIndices[i];
        var node = this.body.nodes[index];
        var force = this.physicsBody.forces[index];
        var factor = 20;
        var colorFactor = 0.03;
        var forceSize = Math.sqrt(Math.pow(force.x, 2) + Math.pow(force.x, 2));

        var size = Math.min(Math.max(5, forceSize), 15);
        var arrowSize = 3 * size;

        var color = util.HSVToHex((180 - Math.min(1, Math.max(0, colorFactor * forceSize)) * 180) / 360, 1, 1);

        var point = {
          x: node.x + factor * force.x,
          y: node.y + factor * force.y
        };

        ctx.lineWidth = size;
        ctx.strokeStyle = color;
        ctx.beginPath();
        ctx.moveTo(node.x, node.y);
        ctx.lineTo(point.x, point.y);
        ctx.stroke();

        var angle = Math.atan2(force.y, force.x);
        ctx.fillStyle = color;
        EndPoints.draw(ctx, {
          type: 'arrow',
          point: point,
          angle: angle,
          length: arrowSize
        });
        ctx.fill();
      }
    }
  }]);
  return PhysicsEngine;
}();

exports['default'] = PhysicsEngine;

/***/ }),
/* 172 */
/***/ (function(module, exports, __nested_webpack_require_877742__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __nested_webpack_require_877742__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_877742__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * Repulsion Solver
 */
var RepulsionSolver = function () {
  /**
   * @param {Object} body
   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody
   * @param {Object} options
   */
  function RepulsionSolver(body, physicsBody, options) {
    (0, _classCallCheck3["default"])(this, RepulsionSolver);

    this.body = body;
    this.physicsBody = physicsBody;
    this.setOptions(options);
  }

  /**
   *
   * @param {Object} options
   */


  (0, _createClass3["default"])(RepulsionSolver, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.options = options;
    }

    /**
     * Calculate the forces the nodes apply on each other based on a repulsion field.
     * This field is linearly approximated.
     *
     * @private
     */

  }, {
    key: "solve",
    value: function solve() {
      var dx, dy, distance, fx, fy, repulsingForce, node1, node2;

      var nodes = this.body.nodes;
      var nodeIndices = this.physicsBody.physicsNodeIndices;
      var forces = this.physicsBody.forces;

      // repulsing forces between nodes
      var nodeDistance = this.options.nodeDistance;

      // approximation constants
      var a = -2 / 3 / nodeDistance;
      var b = 4 / 3;

      // we loop from i over all but the last entree in the array
      // j loops from i+1 to the last. This way we do not double count any of the indices, nor i === j
      for (var i = 0; i < nodeIndices.length - 1; i++) {
        node1 = nodes[nodeIndices[i]];
        for (var j = i + 1; j < nodeIndices.length; j++) {
          node2 = nodes[nodeIndices[j]];

          dx = node2.x - node1.x;
          dy = node2.y - node1.y;
          distance = Math.sqrt(dx * dx + dy * dy);

          // same condition as BarnesHutSolver, making sure nodes are never 100% overlapping.
          if (distance === 0) {
            distance = 0.1 * Math.random();
            dx = distance;
          }

          if (distance < 2 * nodeDistance) {
            if (distance < 0.5 * nodeDistance) {
              repulsingForce = 1.0;
            } else {
              repulsingForce = a * distance + b; // linear approx of  1 / (1 + Math.exp((distance / nodeDistance - 1) * steepness))
            }
            repulsingForce = repulsingForce / distance;

            fx = dx * repulsingForce;
            fy = dy * repulsingForce;

            forces[node1.id].x -= fx;
            forces[node1.id].y -= fy;
            forces[node2.id].x += fx;
            forces[node2.id].y += fy;
          }
        }
      }
    }
  }]);
  return RepulsionSolver;
}();

exports["default"] = RepulsionSolver;

/***/ }),
/* 173 */
/***/ (function(module, exports, __nested_webpack_require_880884__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __nested_webpack_require_880884__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_880884__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * Hierarchical Repulsion Solver
 */
var HierarchicalRepulsionSolver = function () {
  /**
   * @param {Object} body
   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody
   * @param {Object} options
   */
  function HierarchicalRepulsionSolver(body, physicsBody, options) {
    (0, _classCallCheck3["default"])(this, HierarchicalRepulsionSolver);

    this.body = body;
    this.physicsBody = physicsBody;
    this.setOptions(options);
  }

  /**
   *
   * @param {Object} options
   */


  (0, _createClass3["default"])(HierarchicalRepulsionSolver, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.options = options;
    }

    /**
     * Calculate the forces the nodes apply on each other based on a repulsion field.
     * This field is linearly approximated.
     *
     * @private
     */

  }, {
    key: "solve",
    value: function solve() {
      var dx, dy, distance, fx, fy, repulsingForce, node1, node2, i, j;

      var nodes = this.body.nodes;
      var nodeIndices = this.physicsBody.physicsNodeIndices;
      var forces = this.physicsBody.forces;

      // repulsing forces between nodes
      var nodeDistance = this.options.nodeDistance;

      // we loop from i over all but the last entree in the array
      // j loops from i+1 to the last. This way we do not double count any of the indices, nor i === j
      for (i = 0; i < nodeIndices.length - 1; i++) {
        node1 = nodes[nodeIndices[i]];
        for (j = i + 1; j < nodeIndices.length; j++) {
          node2 = nodes[nodeIndices[j]];

          // nodes only affect nodes on their level
          if (node1.level === node2.level) {
            dx = node2.x - node1.x;
            dy = node2.y - node1.y;
            distance = Math.sqrt(dx * dx + dy * dy);

            var steepness = 0.05;
            if (distance < nodeDistance) {
              repulsingForce = -Math.pow(steepness * distance, 2) + Math.pow(steepness * nodeDistance, 2);
            } else {
              repulsingForce = 0;
            }
            // normalize force with
            if (distance === 0) {
              distance = 0.01;
            } else {
              repulsingForce = repulsingForce / distance;
            }
            fx = dx * repulsingForce;
            fy = dy * repulsingForce;

            forces[node1.id].x -= fx;
            forces[node1.id].y -= fy;
            forces[node2.id].x += fx;
            forces[node2.id].y += fy;
          }
        }
      }
    }
  }]);
  return HierarchicalRepulsionSolver;
}();

exports["default"] = HierarchicalRepulsionSolver;

/***/ }),
/* 174 */
/***/ (function(module, exports, __nested_webpack_require_884003__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __nested_webpack_require_884003__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_884003__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * Spring Solver
 */
var SpringSolver = function () {
  /**
   * @param {Object} body
   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody
   * @param {Object} options
   */
  function SpringSolver(body, physicsBody, options) {
    (0, _classCallCheck3["default"])(this, SpringSolver);

    this.body = body;
    this.physicsBody = physicsBody;
    this.setOptions(options);
  }

  /**
   *
   * @param {Object} options
   */


  (0, _createClass3["default"])(SpringSolver, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.options = options;
    }

    /**
     * This function calculates the springforces on the nodes, accounting for the support nodes.
     *
     * @private
     */

  }, {
    key: "solve",
    value: function solve() {
      var edgeLength = void 0,
          edge = void 0;
      var edgeIndices = this.physicsBody.physicsEdgeIndices;
      var edges = this.body.edges;
      var node1 = void 0,
          node2 = void 0,
          node3 = void 0;

      // forces caused by the edges, modelled as springs
      for (var i = 0; i < edgeIndices.length; i++) {
        edge = edges[edgeIndices[i]];
        if (edge.connected === true && edge.toId !== edge.fromId) {
          // only calculate forces if nodes are in the same sector
          if (this.body.nodes[edge.toId] !== undefined && this.body.nodes[edge.fromId] !== undefined) {
            if (edge.edgeType.via !== undefined) {
              edgeLength = edge.options.length === undefined ? this.options.springLength : edge.options.length;
              node1 = edge.to;
              node2 = edge.edgeType.via;
              node3 = edge.from;

              this._calculateSpringForce(node1, node2, 0.5 * edgeLength);
              this._calculateSpringForce(node2, node3, 0.5 * edgeLength);
            } else {
              // the * 1.5 is here so the edge looks as large as a smooth edge. It does not initially because the smooth edges use
              // the support nodes which exert a repulsive force on the to and from nodes, making the edge appear larger.
              edgeLength = edge.options.length === undefined ? this.options.springLength * 1.5 : edge.options.length;
              this._calculateSpringForce(edge.from, edge.to, edgeLength);
            }
          }
        }
      }
    }

    /**
     * This is the code actually performing the calculation for the function above.
     *
     * @param {Node} node1
     * @param {Node} node2
     * @param {number} edgeLength
     * @private
     */

  }, {
    key: "_calculateSpringForce",
    value: function _calculateSpringForce(node1, node2, edgeLength) {
      var dx = node1.x - node2.x;
      var dy = node1.y - node2.y;
      var distance = Math.max(Math.sqrt(dx * dx + dy * dy), 0.01);

      // the 1/distance is so the fx and fy can be calculated without sine or cosine.
      var springForce = this.options.springConstant * (edgeLength - distance) / distance;

      var fx = dx * springForce;
      var fy = dy * springForce;

      // handle the case where one node is not part of the physcis
      if (this.physicsBody.forces[node1.id] !== undefined) {
        this.physicsBody.forces[node1.id].x += fx;
        this.physicsBody.forces[node1.id].y += fy;
      }

      if (this.physicsBody.forces[node2.id] !== undefined) {
        this.physicsBody.forces[node2.id].x -= fx;
        this.physicsBody.forces[node2.id].y -= fy;
      }
    }
  }]);
  return SpringSolver;
}();

exports["default"] = SpringSolver;

/***/ }),
/* 175 */
/***/ (function(module, exports, __nested_webpack_require_888054__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __nested_webpack_require_888054__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_888054__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * Hierarchical Spring Solver
 */
var HierarchicalSpringSolver = function () {
  /**
   * @param {Object} body
   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody
   * @param {Object} options
   */
  function HierarchicalSpringSolver(body, physicsBody, options) {
    (0, _classCallCheck3["default"])(this, HierarchicalSpringSolver);

    this.body = body;
    this.physicsBody = physicsBody;
    this.setOptions(options);
  }

  /**
   *
   * @param {Object} options
   */


  (0, _createClass3["default"])(HierarchicalSpringSolver, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.options = options;
    }

    /**
     * This function calculates the springforces on the nodes, accounting for the support nodes.
     *
     * @private
     */

  }, {
    key: "solve",
    value: function solve() {
      var edgeLength, edge;
      var dx, dy, fx, fy, springForce, distance;
      var edges = this.body.edges;
      var factor = 0.5;

      var edgeIndices = this.physicsBody.physicsEdgeIndices;
      var nodeIndices = this.physicsBody.physicsNodeIndices;
      var forces = this.physicsBody.forces;

      // initialize the spring force counters
      for (var i = 0; i < nodeIndices.length; i++) {
        var nodeId = nodeIndices[i];
        forces[nodeId].springFx = 0;
        forces[nodeId].springFy = 0;
      }

      // forces caused by the edges, modelled as springs
      for (var _i = 0; _i < edgeIndices.length; _i++) {
        edge = edges[edgeIndices[_i]];
        if (edge.connected === true) {
          edgeLength = edge.options.length === undefined ? this.options.springLength : edge.options.length;

          dx = edge.from.x - edge.to.x;
          dy = edge.from.y - edge.to.y;
          distance = Math.sqrt(dx * dx + dy * dy);
          distance = distance === 0 ? 0.01 : distance;

          // the 1/distance is so the fx and fy can be calculated without sine or cosine.
          springForce = this.options.springConstant * (edgeLength - distance) / distance;

          fx = dx * springForce;
          fy = dy * springForce;

          if (edge.to.level != edge.from.level) {
            if (forces[edge.toId] !== undefined) {
              forces[edge.toId].springFx -= fx;
              forces[edge.toId].springFy -= fy;
            }
            if (forces[edge.fromId] !== undefined) {
              forces[edge.fromId].springFx += fx;
              forces[edge.fromId].springFy += fy;
            }
          } else {
            if (forces[edge.toId] !== undefined) {
              forces[edge.toId].x -= factor * fx;
              forces[edge.toId].y -= factor * fy;
            }
            if (forces[edge.fromId] !== undefined) {
              forces[edge.fromId].x += factor * fx;
              forces[edge.fromId].y += factor * fy;
            }
          }
        }
      }

      // normalize spring forces
      springForce = 1;
      var springFx, springFy;
      for (var _i2 = 0; _i2 < nodeIndices.length; _i2++) {
        var _nodeId = nodeIndices[_i2];
        springFx = Math.min(springForce, Math.max(-springForce, forces[_nodeId].springFx));
        springFy = Math.min(springForce, Math.max(-springForce, forces[_nodeId].springFy));

        forces[_nodeId].x += springFx;
        forces[_nodeId].y += springFy;
      }

      // retain energy balance
      var totalFx = 0;
      var totalFy = 0;
      for (var _i3 = 0; _i3 < nodeIndices.length; _i3++) {
        var _nodeId2 = nodeIndices[_i3];
        totalFx += forces[_nodeId2].x;
        totalFy += forces[_nodeId2].y;
      }
      var correctionFx = totalFx / nodeIndices.length;
      var correctionFy = totalFy / nodeIndices.length;

      for (var _i4 = 0; _i4 < nodeIndices.length; _i4++) {
        var _nodeId3 = nodeIndices[_i4];
        forces[_nodeId3].x -= correctionFx;
        forces[_nodeId3].y -= correctionFy;
      }
    }
  }]);
  return HierarchicalSpringSolver;
}();

exports["default"] = HierarchicalSpringSolver;

/***/ }),
/* 176 */
/***/ (function(module, exports, __nested_webpack_require_892574__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = __nested_webpack_require_892574__(3);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __nested_webpack_require_892574__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_892574__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __nested_webpack_require_892574__(4);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __nested_webpack_require_892574__(5);

var _inherits3 = _interopRequireDefault(_inherits2);

var _BarnesHutSolver2 = __nested_webpack_require_892574__(81);

var _BarnesHutSolver3 = _interopRequireDefault(_BarnesHutSolver2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * @extends BarnesHutSolver
 */
var ForceAtlas2BasedRepulsionSolver = function (_BarnesHutSolver) {
  (0, _inherits3['default'])(ForceAtlas2BasedRepulsionSolver, _BarnesHutSolver);

  /**
   * @param {Object} body
   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody
   * @param {Object} options
   */
  function ForceAtlas2BasedRepulsionSolver(body, physicsBody, options) {
    (0, _classCallCheck3['default'])(this, ForceAtlas2BasedRepulsionSolver);
    return (0, _possibleConstructorReturn3['default'])(this, (ForceAtlas2BasedRepulsionSolver.__proto__ || (0, _getPrototypeOf2['default'])(ForceAtlas2BasedRepulsionSolver)).call(this, body, physicsBody, options));
  }

  /**
   * Calculate the forces based on the distance.
   *
   * @param {number} distance
   * @param {number} dx
   * @param {number} dy
   * @param {Node} node
   * @param {Object} parentBranch
   * @private
   */


  (0, _createClass3['default'])(ForceAtlas2BasedRepulsionSolver, [{
    key: '_calculateForces',
    value: function _calculateForces(distance, dx, dy, node, parentBranch) {
      if (distance === 0) {
        distance = 0.1 * Math.random();
        dx = distance;
      }

      if (this.overlapAvoidanceFactor < 1 && node.shape.radius) {
        distance = Math.max(0.1 + this.overlapAvoidanceFactor * node.shape.radius, distance - node.shape.radius);
      }

      var degree = node.edges.length + 1;
      // the dividing by the distance cubed instead of squared allows us to get the fx and fy components without sines and cosines
      // it is shorthand for gravityforce with distance squared and fx = dx/distance * gravityForce
      var gravityForce = this.options.gravitationalConstant * parentBranch.mass * node.options.mass * degree / Math.pow(distance, 2);
      var fx = dx * gravityForce;
      var fy = dy * gravityForce;

      this.physicsBody.forces[node.id].x += fx;
      this.physicsBody.forces[node.id].y += fy;
    }
  }]);
  return ForceAtlas2BasedRepulsionSolver;
}(_BarnesHutSolver3['default']);

exports['default'] = ForceAtlas2BasedRepulsionSolver;

/***/ }),
/* 177 */
/***/ (function(module, exports, __nested_webpack_require_895653__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = __nested_webpack_require_895653__(3);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __nested_webpack_require_895653__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_895653__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __nested_webpack_require_895653__(4);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __nested_webpack_require_895653__(5);

var _inherits3 = _interopRequireDefault(_inherits2);

var _CentralGravitySolver2 = __nested_webpack_require_895653__(82);

var _CentralGravitySolver3 = _interopRequireDefault(_CentralGravitySolver2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * @extends CentralGravitySolver
 */
var ForceAtlas2BasedCentralGravitySolver = function (_CentralGravitySolver) {
  (0, _inherits3['default'])(ForceAtlas2BasedCentralGravitySolver, _CentralGravitySolver);

  /**
   * @param {Object} body
   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody
   * @param {Object} options
   */
  function ForceAtlas2BasedCentralGravitySolver(body, physicsBody, options) {
    (0, _classCallCheck3['default'])(this, ForceAtlas2BasedCentralGravitySolver);
    return (0, _possibleConstructorReturn3['default'])(this, (ForceAtlas2BasedCentralGravitySolver.__proto__ || (0, _getPrototypeOf2['default'])(ForceAtlas2BasedCentralGravitySolver)).call(this, body, physicsBody, options));
  }

  /**
   * Calculate the forces based on the distance.
   *
   * @param {number} distance
   * @param {number} dx
   * @param {number} dy
   * @param {Object<Node.id, Node>} forces
   * @param {Node} node
   * @private
   */


  (0, _createClass3['default'])(ForceAtlas2BasedCentralGravitySolver, [{
    key: '_calculateForces',
    value: function _calculateForces(distance, dx, dy, forces, node) {
      if (distance > 0) {
        var degree = node.edges.length + 1;
        var gravityForce = this.options.centralGravity * degree * node.options.mass;
        forces[node.id].x = dx * gravityForce;
        forces[node.id].y = dy * gravityForce;
      }
    }
  }]);
  return ForceAtlas2BasedCentralGravitySolver;
}(_CentralGravitySolver3['default']);

exports['default'] = ForceAtlas2BasedCentralGravitySolver;

/***/ }),
/* 178 */
/***/ (function(module, exports, __nested_webpack_require_898211__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __nested_webpack_require_898211__(9);

var _keys2 = _interopRequireDefault(_keys);

var _typeof2 = __nested_webpack_require_898211__(7);

var _typeof3 = _interopRequireDefault(_typeof2);

var _classCallCheck2 = __nested_webpack_require_898211__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_898211__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/* ===========================================================================

# TODO

- `edgeReplacedById` not cleaned up yet on cluster edge removal
- allowSingleNodeCluster could be a global option as well; currently needs to always
  be passed to clustering methods

----------------------------------------------

# State Model for Clustering

The total state for clustering is non-trivial. It is useful to have a model
available as to how it works. The following documents the relevant state items.


## Network State

The following `network`-members are relevant to clustering:

- `body.nodes`       - all nodes actively participating in the network
- `body.edges`       - same for edges
- `body.nodeIndices` - id's of nodes that are visible at a given moment
- `body.edgeIndices` - same for edges

This includes:

- helper nodes for dragging in `manipulation`
- helper nodes for edge type `dynamic`
- cluster nodes and edges
- there may be more than this.

A node/edge may be missing in the `Indices` member if:

- it is a helper node
- the node or edge state has option `hidden` set
- It is not visible due to clustering


## Clustering State

For the hashes, the id's of the nodes/edges are used as key.

Member `network.clustering` contains the following items:

- `clusteredNodes` - hash with values: { clusterId: <id of cluster>, node: <node instance>}
- `clusteredEdges` - hash with values: restore information for given edge


Due to nesting of clusters, these members can contain cluster nodes and edges as well.

The important thing to note here, is that the clustered nodes and edges also
appear in the members of the cluster nodes. For data update, it is therefore 
important to scan these lists as well as the cluster nodes.


### Cluster Node

A cluster node has the following extra fields:

- `isCluster : true` - indication that this is a cluster node
- `containedNodes`   - hash of nodes contained in this cluster
- `containedEdges`   - same for edges
- `edges`            - array of cluster edges for this node 


**NOTE:**

- `containedEdges` can also contain edges which are not clustered; e.g. an edge
   connecting two nodes in the same cluster.


### Cluster Edge

These are the items in the `edges` member of a clustered node. They have the
following relevant members:

- 'clusteringEdgeReplacingIds` - array of id's of edges replaced by this edge

Note that it's possible to nest clusters, so that `clusteringEdgeReplacingIds`
can contain edge id's of other clusters.


### Clustered Edge

This is any edge contained by a cluster edge. It gets the following additional
member:

- `edgeReplacedById` - id of the cluster edge in which current edge is clustered


   =========================================================================== */
var util = __nested_webpack_require_898211__(2);
var NetworkUtil = __nested_webpack_require_898211__(57)['default'];
var Cluster = __nested_webpack_require_898211__(179)['default'];
var Edge = __nested_webpack_require_898211__(55)['default']; // Only needed for check on type!
var Node = __nested_webpack_require_898211__(34)['default']; // Only needed for check on type!

/**
 * The clustering engine
 */

var ClusterEngine = function () {
  /**
   * @param {Object} body
   */
  function ClusterEngine(body) {
    var _this = this;

    (0, _classCallCheck3['default'])(this, ClusterEngine);

    this.body = body;
    this.clusteredNodes = {}; // key: node id, value: { clusterId: <id of cluster>, node: <node instance>}
    this.clusteredEdges = {}; // key: edge id, value: restore information for given edge

    this.options = {};
    this.defaultOptions = {};
    util.extend(this.options, this.defaultOptions);

    this.body.emitter.on('_resetData', function () {
      _this.clusteredNodes = {};
      _this.clusteredEdges = {};
    });
  }

  /**
   *
   * @param {number} hubsize
   * @param {Object} options
   */


  (0, _createClass3['default'])(ClusterEngine, [{
    key: 'clusterByHubsize',
    value: function clusterByHubsize(hubsize, options) {
      if (hubsize === undefined) {
        hubsize = this._getHubSize();
      } else if ((typeof hubsize === 'undefined' ? 'undefined' : (0, _typeof3['default'])(hubsize)) === 'object') {
        options = this._checkOptions(hubsize);
        hubsize = this._getHubSize();
      }

      var nodesToCluster = [];
      for (var i = 0; i < this.body.nodeIndices.length; i++) {
        var node = this.body.nodes[this.body.nodeIndices[i]];
        if (node.edges.length >= hubsize) {
          nodesToCluster.push(node.id);
        }
      }

      for (var _i = 0; _i < nodesToCluster.length; _i++) {
        this.clusterByConnection(nodesToCluster[_i], options, true);
      }

      this.body.emitter.emit('_dataChanged');
    }

    /**
     * loop over all nodes, check if they adhere to the condition and cluster if needed.
     * @param {Object} options
     * @param {boolean} [refreshData=true]
     */

  }, {
    key: 'cluster',
    value: function cluster() {
      var _this2 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var refreshData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (options.joinCondition === undefined) {
        throw new Error('Cannot call clusterByNodeData without a joinCondition function in the options.');
      }

      // check if the options object is fine, append if needed
      options = this._checkOptions(options);

      var childNodesObj = {};
      var childEdgesObj = {};

      // collect the nodes that will be in the cluster
      util.forEach(this.body.nodes, function (node, nodeId) {
        if (node.options && options.joinCondition(node.options) === true) {
          childNodesObj[nodeId] = node;

          // collect the edges that will be in the cluster
          util.forEach(node.edges, function (edge) {
            if (_this2.clusteredEdges[edge.id] === undefined) {
              childEdgesObj[edge.id] = edge;
            }
          });
        }
      });

      this._cluster(childNodesObj, childEdgesObj, options, refreshData);
    }

    /**
     * Cluster all nodes in the network that have only X edges
     * @param {number} edgeCount
     * @param {Object} options
     * @param {boolean} [refreshData=true]
     */

  }, {
    key: 'clusterByEdgeCount',
    value: function clusterByEdgeCount(edgeCount, options) {
      var _this3 = this;

      var refreshData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      options = this._checkOptions(options);
      var clusters = [];
      var usedNodes = {};
      var edge = void 0,
          edges = void 0,
          relevantEdgeCount = void 0;
      // collect the nodes that will be in the cluster

      var _loop = function _loop(i) {
        var childNodesObj = {};
        var childEdgesObj = {};
        var nodeId = _this3.body.nodeIndices[i];
        var node = _this3.body.nodes[nodeId];

        // if this node is already used in another cluster this session, we do not have to re-evaluate it.
        if (usedNodes[nodeId] === undefined) {
          relevantEdgeCount = 0;
          edges = [];
          for (var j = 0; j < node.edges.length; j++) {
            edge = node.edges[j];
            if (_this3.clusteredEdges[edge.id] === undefined) {
              if (edge.toId !== edge.fromId) {
                relevantEdgeCount++;
              }
              edges.push(edge);
            }
          }

          // this node qualifies, we collect its neighbours to start the clustering process.
          if (relevantEdgeCount === edgeCount) {
            checkJoinCondition = function checkJoinCondition(node) {
              if (options.joinCondition === undefined || options.joinCondition === null) {
                return true;
              }

              var clonedOptions = NetworkUtil.cloneOptions(node);
              return options.joinCondition(clonedOptions);
            };

            var gatheringSuccessful = true;
            for (var _j = 0; _j < edges.length; _j++) {
              edge = edges[_j];
              var childNodeId = _this3._getConnectedId(edge, nodeId);
              // add the nodes to the list by the join condition.
              if (checkJoinCondition(node)) {
                childEdgesObj[edge.id] = edge;
                childNodesObj[nodeId] = node;
                childNodesObj[childNodeId] = _this3.body.nodes[childNodeId];
                usedNodes[nodeId] = true;
              } else {
                // this node does not qualify after all.
                gatheringSuccessful = false;
                break;
              }
            }

            // add to the cluster queue
            if ((0, _keys2['default'])(childNodesObj).length > 0 && (0, _keys2['default'])(childEdgesObj).length > 0 && gatheringSuccessful === true) {
              /**
               * Search for cluster data that contains any of the node id's
               * @returns {Boolean} true if no joinCondition, otherwise return value of joinCondition
               */
              findClusterData = function findClusterData() {
                for (var n = 0; n < clusters.length; ++n) {
                  // Search for a cluster containing any of the node id's
                  for (var m in childNodesObj) {
                    if (clusters[n].nodes[m] !== undefined) {
                      return clusters[n];
                    }
                  }
                }

                return undefined;
              };

              // If any of the found nodes is part of a cluster found in this method,
              // add the current values to that cluster


              foundCluster = findClusterData();

              if (foundCluster !== undefined) {
                // Add nodes to found cluster if not present
                for (var m in childNodesObj) {
                  if (foundCluster.nodes[m] === undefined) {
                    foundCluster.nodes[m] = childNodesObj[m];
                  }
                }

                // Add edges to found cluster, if not present
                for (var _m in childEdgesObj) {
                  if (foundCluster.edges[_m] === undefined) {
                    foundCluster.edges[_m] = childEdgesObj[_m];
                  }
                }
              } else {
                // Create a new cluster group
                clusters.push({ nodes: childNodesObj, edges: childEdgesObj });
              }
            }
          }
        }
      };

      for (var i = 0; i < this.body.nodeIndices.length; i++) {
        var checkJoinCondition;
        var findClusterData;
        var foundCluster;

        _loop(i);
      }

      for (var i = 0; i < clusters.length; i++) {
        this._cluster(clusters[i].nodes, clusters[i].edges, options, false);
      }

      if (refreshData === true) {
        this.body.emitter.emit('_dataChanged');
      }
    }

    /**
     * Cluster all nodes in the network that have only 1 edge
     * @param {Object} options
     * @param {boolean} [refreshData=true]
     */

  }, {
    key: 'clusterOutliers',
    value: function clusterOutliers(options) {
      var refreshData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      this.clusterByEdgeCount(1, options, refreshData);
    }

    /**
     * Cluster all nodes in the network that have only 2 edge
     * @param {Object} options
     * @param {boolean} [refreshData=true]
     */

  }, {
    key: 'clusterBridges',
    value: function clusterBridges(options) {
      var refreshData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      this.clusterByEdgeCount(2, options, refreshData);
    }

    /**
     * suck all connected nodes of a node into the node.
     * @param {Node.id} nodeId
     * @param {Object} options
     * @param {boolean} [refreshData=true]
     */

  }, {
    key: 'clusterByConnection',
    value: function clusterByConnection(nodeId, options) {
      var refreshData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      // kill conditions
      if (nodeId === undefined) {
        throw new Error('No nodeId supplied to clusterByConnection!');
      }
      if (this.body.nodes[nodeId] === undefined) {
        throw new Error('The nodeId given to clusterByConnection does not exist!');
      }

      var node = this.body.nodes[nodeId];
      options = this._checkOptions(options, node);
      if (options.clusterNodeProperties.x === undefined) {
        options.clusterNodeProperties.x = node.x;
      }
      if (options.clusterNodeProperties.y === undefined) {
        options.clusterNodeProperties.y = node.y;
      }
      if (options.clusterNodeProperties.fixed === undefined) {
        options.clusterNodeProperties.fixed = {};
        options.clusterNodeProperties.fixed.x = node.options.fixed.x;
        options.clusterNodeProperties.fixed.y = node.options.fixed.y;
      }

      var childNodesObj = {};
      var childEdgesObj = {};
      var parentNodeId = node.id;
      var parentClonedOptions = NetworkUtil.cloneOptions(node);
      childNodesObj[parentNodeId] = node;

      // collect the nodes that will be in the cluster
      for (var i = 0; i < node.edges.length; i++) {
        var edge = node.edges[i];
        if (this.clusteredEdges[edge.id] === undefined) {
          var childNodeId = this._getConnectedId(edge, parentNodeId);

          // if the child node is not in a cluster
          if (this.clusteredNodes[childNodeId] === undefined) {
            if (childNodeId !== parentNodeId) {
              if (options.joinCondition === undefined) {
                childEdgesObj[edge.id] = edge;
                childNodesObj[childNodeId] = this.body.nodes[childNodeId];
              } else {
                // clone the options and insert some additional parameters that could be interesting.
                var childClonedOptions = NetworkUtil.cloneOptions(this.body.nodes[childNodeId]);
                if (options.joinCondition(parentClonedOptions, childClonedOptions) === true) {
                  childEdgesObj[edge.id] = edge;
                  childNodesObj[childNodeId] = this.body.nodes[childNodeId];
                }
              }
            } else {
              // swallow the edge if it is self-referencing.
              childEdgesObj[edge.id] = edge;
            }
          }
        }
      }
      var childNodeIDs = (0, _keys2['default'])(childNodesObj).map(function (childNode) {
        return childNodesObj[childNode].id;
      });

      for (childNode in childNodesObj) {
        if (!childNodesObj.hasOwnProperty(childNode)) continue;

        var childNode = childNodesObj[childNode];
        for (var y = 0; y < childNode.edges.length; y++) {
          var childEdge = childNode.edges[y];
          if (childNodeIDs.indexOf(this._getConnectedId(childEdge, childNode.id)) > -1) {
            childEdgesObj[childEdge.id] = childEdge;
          }
        }
      }
      this._cluster(childNodesObj, childEdgesObj, options, refreshData);
    }

    /**
     * This function creates the edges that will be attached to the cluster
     * It looks for edges that are connected to the nodes from the "outside' of the cluster.
     *
     * @param {{Node.id: vis.Node}} childNodesObj
     * @param {{vis.Edge.id: vis.Edge}} childEdgesObj
     * @param {Object} clusterNodeProperties
     * @param {Object} clusterEdgeProperties
     * @private
     */

  }, {
    key: '_createClusterEdges',
    value: function _createClusterEdges(childNodesObj, childEdgesObj, clusterNodeProperties, clusterEdgeProperties) {
      var edge = void 0,
          childNodeId = void 0,
          childNode = void 0,
          toId = void 0,
          fromId = void 0,
          otherNodeId = void 0;

      // loop over all child nodes and their edges to find edges going out of the cluster
      // these edges will be replaced by clusterEdges.
      var childKeys = (0, _keys2['default'])(childNodesObj);
      var createEdges = [];
      for (var i = 0; i < childKeys.length; i++) {
        childNodeId = childKeys[i];
        childNode = childNodesObj[childNodeId];

        // construct new edges from the cluster to others
        for (var j = 0; j < childNode.edges.length; j++) {
          edge = childNode.edges[j];
          // we only handle edges that are visible to the system, not the disabled ones from the clustering process.
          if (this.clusteredEdges[edge.id] === undefined) {
            // self-referencing edges will be added to the "hidden" list
            if (edge.toId == edge.fromId) {
              childEdgesObj[edge.id] = edge;
            } else {
              // set up the from and to.
              if (edge.toId == childNodeId) {
                // this is a double equals because ints and strings can be interchanged here.
                toId = clusterNodeProperties.id;
                fromId = edge.fromId;
                otherNodeId = fromId;
              } else {
                toId = edge.toId;
                fromId = clusterNodeProperties.id;
                otherNodeId = toId;
              }
            }

            // Only edges from the cluster outwards are being replaced.
            if (childNodesObj[otherNodeId] === undefined) {
              createEdges.push({ edge: edge, fromId: fromId, toId: toId });
            }
          }
        }
      }

      //
      // Here we actually create the replacement edges.
      //
      // We could not do this in the loop above as the creation process
      // would add an edge to the edges array we are iterating over.
      //
      // NOTE: a clustered edge can have multiple base edges!
      //
      var newEdges = [];

      /**
       * Find a cluster edge which matches the given created edge.
       * @param {vis.Edge} createdEdge
       * @returns {vis.Edge}
       */
      var getNewEdge = function getNewEdge(createdEdge) {
        for (var _j2 = 0; _j2 < newEdges.length; _j2++) {
          var newEdge = newEdges[_j2];

          // We replace both to and from edges with a single cluster edge
          var matchToDirection = createdEdge.fromId === newEdge.fromId && createdEdge.toId === newEdge.toId;
          var matchFromDirection = createdEdge.fromId === newEdge.toId && createdEdge.toId === newEdge.fromId;

          if (matchToDirection || matchFromDirection) {
            return newEdge;
          }
        }

        return null;
      };

      for (var _j3 = 0; _j3 < createEdges.length; _j3++) {
        var createdEdge = createEdges[_j3];
        var _edge = createdEdge.edge;
        var newEdge = getNewEdge(createdEdge);

        if (newEdge === null) {
          // Create a clustered edge for this connection
          newEdge = this._createClusteredEdge(createdEdge.fromId, createdEdge.toId, _edge, clusterEdgeProperties);

          newEdges.push(newEdge);
        } else {
          newEdge.clusteringEdgeReplacingIds.push(_edge.id);
        }

        // also reference the new edge in the old edge
        this.body.edges[_edge.id].edgeReplacedById = newEdge.id;

        // hide the replaced edge
        this._backupEdgeOptions(_edge);
        _edge.setOptions({ physics: false });
      }
    }

    /**
     * This function checks the options that can be supplied to the different cluster functions
     * for certain fields and inserts defaults if needed
     * @param {Object} options
     * @returns {*}
     * @private
     */

  }, {
    key: '_checkOptions',
    value: function _checkOptions() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (options.clusterEdgeProperties === undefined) {
        options.clusterEdgeProperties = {};
      }
      if (options.clusterNodeProperties === undefined) {
        options.clusterNodeProperties = {};
      }

      return options;
    }

    /**
     *
     * @param {Object}    childNodesObj         | object with node objects, id as keys, same as childNodes except it also contains a source node
     * @param {Object}    childEdgesObj         | object with edge objects, id as keys
     * @param {Array}     options               | object with {clusterNodeProperties, clusterEdgeProperties, processProperties}
     * @param {boolean}   refreshData | when true, do not wrap up
     * @private
     */

  }, {
    key: '_cluster',
    value: function _cluster(childNodesObj, childEdgesObj, options) {
      var refreshData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

      // Remove nodes which are already clustered
      var tmpNodesToRemove = [];
      for (var _nodeId in childNodesObj) {
        if (childNodesObj.hasOwnProperty(_nodeId)) {
          if (this.clusteredNodes[_nodeId] !== undefined) {
            tmpNodesToRemove.push(_nodeId);
          }
        }
      }

      for (var n = 0; n < tmpNodesToRemove.length; ++n) {
        delete childNodesObj[tmpNodesToRemove[n]];
      }

      // kill condition: no nodes don't bother
      if ((0, _keys2['default'])(childNodesObj).length == 0) {
        return;
      }

      // allow clusters of 1 if options allow
      if ((0, _keys2['default'])(childNodesObj).length == 1 && options.clusterNodeProperties.allowSingleNodeCluster != true) {
        return;
      }

      var clusterNodeProperties = util.deepExtend({}, options.clusterNodeProperties);

      // construct the clusterNodeProperties
      if (options.processProperties !== undefined) {
        // get the childNode options
        var childNodesOptions = [];
        for (var _nodeId2 in childNodesObj) {
          if (childNodesObj.hasOwnProperty(_nodeId2)) {
            var clonedOptions = NetworkUtil.cloneOptions(childNodesObj[_nodeId2]);
            childNodesOptions.push(clonedOptions);
          }
        }

        // get cluster properties based on childNodes
        var childEdgesOptions = [];
        for (var edgeId in childEdgesObj) {
          if (childEdgesObj.hasOwnProperty(edgeId)) {
            // these cluster edges will be removed on creation of the cluster.
            if (edgeId.substr(0, 12) !== 'clusterEdge:') {
              var _clonedOptions = NetworkUtil.cloneOptions(childEdgesObj[edgeId], 'edge');
              childEdgesOptions.push(_clonedOptions);
            }
          }
        }

        clusterNodeProperties = options.processProperties(clusterNodeProperties, childNodesOptions, childEdgesOptions);
        if (!clusterNodeProperties) {
          throw new Error('The processProperties function does not return properties!');
        }
      }

      // check if we have an unique id;
      if (clusterNodeProperties.id === undefined) {
        clusterNodeProperties.id = 'cluster:' + util.randomUUID();
      }
      var clusterId = clusterNodeProperties.id;

      if (clusterNodeProperties.label === undefined) {
        clusterNodeProperties.label = 'cluster';
      }

      // give the clusterNode a position if it does not have one.
      var pos = undefined;
      if (clusterNodeProperties.x === undefined) {
        pos = this._getClusterPosition(childNodesObj);
        clusterNodeProperties.x = pos.x;
      }
      if (clusterNodeProperties.y === undefined) {
        if (pos === undefined) {
          pos = this._getClusterPosition(childNodesObj);
        }
        clusterNodeProperties.y = pos.y;
      }

      // force the ID to remain the same
      clusterNodeProperties.id = clusterId;

      // create the cluster Node
      // Note that allowSingleNodeCluster, if present, is stored in the options as well
      var clusterNode = this.body.functions.createNode(clusterNodeProperties, Cluster);
      clusterNode.containedNodes = childNodesObj;
      clusterNode.containedEdges = childEdgesObj;
      // cache a copy from the cluster edge properties if we have to reconnect others later on
      clusterNode.clusterEdgeProperties = options.clusterEdgeProperties;

      // finally put the cluster node into global
      this.body.nodes[clusterNodeProperties.id] = clusterNode;

      this._clusterEdges(childNodesObj, childEdgesObj, clusterNodeProperties, options.clusterEdgeProperties);

      // set ID to undefined so no duplicates arise
      clusterNodeProperties.id = undefined;

      // wrap up
      if (refreshData === true) {
        this.body.emitter.emit('_dataChanged');
      }
    }

    /**
     *
     * @param {Edge} edge
     * @private
     */

  }, {
    key: '_backupEdgeOptions',
    value: function _backupEdgeOptions(edge) {
      if (this.clusteredEdges[edge.id] === undefined) {
        this.clusteredEdges[edge.id] = { physics: edge.options.physics };
      }
    }

    /**
     *
     * @param {Edge} edge
     * @private
     */

  }, {
    key: '_restoreEdge',
    value: function _restoreEdge(edge) {
      var originalOptions = this.clusteredEdges[edge.id];
      if (originalOptions !== undefined) {
        edge.setOptions({ physics: originalOptions.physics });
        delete this.clusteredEdges[edge.id];
      }
    }

    /**
     * Check if a node is a cluster.
     * @param {Node.id} nodeId
     * @returns {*}
     */

  }, {
    key: 'isCluster',
    value: function isCluster(nodeId) {
      if (this.body.nodes[nodeId] !== undefined) {
        return this.body.nodes[nodeId].isCluster === true;
      } else {
        console.log('Node does not exist.');
        return false;
      }
    }

    /**
     * get the position of the cluster node based on what's inside
     * @param {object} childNodesObj    | object with node objects, id as keys
     * @returns {{x: number, y: number}}
     * @private
     */

  }, {
    key: '_getClusterPosition',
    value: function _getClusterPosition(childNodesObj) {
      var childKeys = (0, _keys2['default'])(childNodesObj);
      var minX = childNodesObj[childKeys[0]].x;
      var maxX = childNodesObj[childKeys[0]].x;
      var minY = childNodesObj[childKeys[0]].y;
      var maxY = childNodesObj[childKeys[0]].y;
      var node = void 0;
      for (var i = 1; i < childKeys.length; i++) {
        node = childNodesObj[childKeys[i]];
        minX = node.x < minX ? node.x : minX;
        maxX = node.x > maxX ? node.x : maxX;
        minY = node.y < minY ? node.y : minY;
        maxY = node.y > maxY ? node.y : maxY;
      }

      return { x: 0.5 * (minX + maxX), y: 0.5 * (minY + maxY) };
    }

    /**
     * Open a cluster by calling this function.
     * @param {vis.Edge.id}  clusterNodeId | the ID of the cluster node
     * @param {Object} options
     * @param {boolean} refreshData | wrap up afterwards if not true
     */

  }, {
    key: 'openCluster',
    value: function openCluster(clusterNodeId, options) {
      var refreshData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      // kill conditions
      if (clusterNodeId === undefined) {
        throw new Error('No clusterNodeId supplied to openCluster.');
      }

      var clusterNode = this.body.nodes[clusterNodeId];

      if (clusterNode === undefined) {
        throw new Error('The clusterNodeId supplied to openCluster does not exist.');
      }
      if (clusterNode.isCluster !== true || clusterNode.containedNodes === undefined || clusterNode.containedEdges === undefined) {
        throw new Error('The node:' + clusterNodeId + ' is not a valid cluster.');
      }

      // Check if current cluster is clustered itself
      var stack = this.findNode(clusterNodeId);
      var parentIndex = stack.indexOf(clusterNodeId) - 1;
      if (parentIndex >= 0) {
        // Current cluster is clustered; transfer contained nodes and edges to parent
        var parentClusterNodeId = stack[parentIndex];
        var parentClusterNode = this.body.nodes[parentClusterNodeId];

        // clustering.clusteredNodes and clustering.clusteredEdges remain unchanged
        parentClusterNode._openChildCluster(clusterNodeId);

        // All components of child cluster node have been transferred. It can die now.
        delete this.body.nodes[clusterNodeId];
        if (refreshData === true) {
          this.body.emitter.emit('_dataChanged');
        }

        return;
      }

      // main body
      var containedNodes = clusterNode.containedNodes;
      var containedEdges = clusterNode.containedEdges;

      // allow the user to position the nodes after release.
      if (options !== undefined && options.releaseFunction !== undefined && typeof options.releaseFunction === 'function') {
        var positions = {};
        var clusterPosition = { x: clusterNode.x, y: clusterNode.y };
        for (var _nodeId3 in containedNodes) {
          if (containedNodes.hasOwnProperty(_nodeId3)) {
            var containedNode = this.body.nodes[_nodeId3];
            positions[_nodeId3] = { x: containedNode.x, y: containedNode.y };
          }
        }
        var newPositions = options.releaseFunction(clusterPosition, positions);

        for (var _nodeId4 in containedNodes) {
          if (containedNodes.hasOwnProperty(_nodeId4)) {
            var _containedNode = this.body.nodes[_nodeId4];
            if (newPositions[_nodeId4] !== undefined) {
              _containedNode.x = newPositions[_nodeId4].x === undefined ? clusterNode.x : newPositions[_nodeId4].x;
              _containedNode.y = newPositions[_nodeId4].y === undefined ? clusterNode.y : newPositions[_nodeId4].y;
            }
          }
        }
      } else {
        // copy the position from the cluster
        util.forEach(containedNodes, function (containedNode) {
          // inherit position
          if (containedNode.options.fixed.x === false) {
            containedNode.x = clusterNode.x;
          }
          if (containedNode.options.fixed.y === false) {
            containedNode.y = clusterNode.y;
          }
        });
      }

      // release nodes
      for (var _nodeId5 in containedNodes) {
        if (containedNodes.hasOwnProperty(_nodeId5)) {
          var _containedNode2 = this.body.nodes[_nodeId5];

          // inherit speed
          _containedNode2.vx = clusterNode.vx;
          _containedNode2.vy = clusterNode.vy;

          _containedNode2.setOptions({ physics: true });

          delete this.clusteredNodes[_nodeId5];
        }
      }

      // copy the clusterNode edges because we cannot iterate over an object that we add or remove from.
      var edgesToBeDeleted = [];
      for (var i = 0; i < clusterNode.edges.length; i++) {
        edgesToBeDeleted.push(clusterNode.edges[i]);
      }

      // actually handling the deleting.
      for (var _i2 = 0; _i2 < edgesToBeDeleted.length; _i2++) {
        var edge = edgesToBeDeleted[_i2];
        var otherNodeId = this._getConnectedId(edge, clusterNodeId);
        var otherNode = this.clusteredNodes[otherNodeId];

        for (var j = 0; j < edge.clusteringEdgeReplacingIds.length; j++) {
          var transferId = edge.clusteringEdgeReplacingIds[j];
          var transferEdge = this.body.edges[transferId];
          if (transferEdge === undefined) continue;

          // if the other node is in another cluster, we transfer ownership of this edge to the other cluster
          if (otherNode !== undefined) {
            // transfer ownership:
            var otherCluster = this.body.nodes[otherNode.clusterId];
            otherCluster.containedEdges[transferEdge.id] = transferEdge;

            // delete local reference
            delete containedEdges[transferEdge.id];

            // get to and from
            var fromId = transferEdge.fromId;
            var toId = transferEdge.toId;
            if (transferEdge.toId == otherNodeId) {
              toId = otherNode.clusterId;
            } else {
              fromId = otherNode.clusterId;
            }

            // create new cluster edge from the otherCluster
            this._createClusteredEdge(fromId, toId, transferEdge, otherCluster.clusterEdgeProperties, { hidden: false, physics: true });
          } else {
            this._restoreEdge(transferEdge);
          }
        }

        edge.remove();
      }

      // handle the releasing of the edges
      for (var edgeId in containedEdges) {
        if (containedEdges.hasOwnProperty(edgeId)) {
          this._restoreEdge(containedEdges[edgeId]);
        }
      }

      // remove clusterNode
      delete this.body.nodes[clusterNodeId];

      if (refreshData === true) {
        this.body.emitter.emit('_dataChanged');
      }
    }

    /**
     *
     * @param {Cluster.id} clusterId
     * @returns {Array.<Node.id>}
     */

  }, {
    key: 'getNodesInCluster',
    value: function getNodesInCluster(clusterId) {
      var nodesArray = [];
      if (this.isCluster(clusterId) === true) {
        var containedNodes = this.body.nodes[clusterId].containedNodes;
        for (var _nodeId6 in containedNodes) {
          if (containedNodes.hasOwnProperty(_nodeId6)) {
            nodesArray.push(this.body.nodes[_nodeId6].id);
          }
        }
      }

      return nodesArray;
    }

    /**
     * Get the stack clusterId's that a certain node resides in. cluster A -> cluster B -> cluster C -> node
     *
     * If a node can't be found in the chain, return an empty array.
     *
     * @param {string|number} nodeId
     * @returns {Array}
     */

  }, {
    key: 'findNode',
    value: function findNode(nodeId) {
      var stack = [];
      var max = 100;
      var counter = 0;
      var node = void 0;

      while (this.clusteredNodes[nodeId] !== undefined && counter < max) {
        node = this.body.nodes[nodeId];
        if (node === undefined) return [];
        stack.push(node.id);

        nodeId = this.clusteredNodes[nodeId].clusterId;
        counter++;
      }

      node = this.body.nodes[nodeId];
      if (node === undefined) return [];
      stack.push(node.id);

      stack.reverse();
      return stack;
    }

    /**
     * Using a clustered nodeId, update with the new options
     * @param {vis.Edge.id} clusteredNodeId
     * @param {object} newOptions
     */

  }, {
    key: 'updateClusteredNode',
    value: function updateClusteredNode(clusteredNodeId, newOptions) {
      if (clusteredNodeId === undefined) {
        throw new Error('No clusteredNodeId supplied to updateClusteredNode.');
      }
      if (newOptions === undefined) {
        throw new Error('No newOptions supplied to updateClusteredNode.');
      }
      if (this.body.nodes[clusteredNodeId] === undefined) {
        throw new Error('The clusteredNodeId supplied to updateClusteredNode does not exist.');
      }

      this.body.nodes[clusteredNodeId].setOptions(newOptions);
      this.body.emitter.emit('_dataChanged');
    }

    /**
     * Using a base edgeId, update all related clustered edges with the new options
     * @param {vis.Edge.id} startEdgeId
     * @param {object} newOptions
     */

  }, {
    key: 'updateEdge',
    value: function updateEdge(startEdgeId, newOptions) {
      if (startEdgeId === undefined) {
        throw new Error('No startEdgeId supplied to updateEdge.');
      }
      if (newOptions === undefined) {
        throw new Error('No newOptions supplied to updateEdge.');
      }
      if (this.body.edges[startEdgeId] === undefined) {
        throw new Error('The startEdgeId supplied to updateEdge does not exist.');
      }

      var allEdgeIds = this.getClusteredEdges(startEdgeId);
      for (var i = 0; i < allEdgeIds.length; i++) {
        var edge = this.body.edges[allEdgeIds[i]];
        edge.setOptions(newOptions);
      }
      this.body.emitter.emit('_dataChanged');
    }

    /**
     * Get a stack of clusterEdgeId's (+base edgeid) that a base edge is the same as. cluster edge C -> cluster edge B -> cluster edge A -> base edge(edgeId)
     * @param {vis.Edge.id} edgeId
     * @returns {Array.<vis.Edge.id>}
     */

  }, {
    key: 'getClusteredEdges',
    value: function getClusteredEdges(edgeId) {
      var stack = [];
      var max = 100;
      var counter = 0;

      while (edgeId !== undefined && this.body.edges[edgeId] !== undefined && counter < max) {
        stack.push(this.body.edges[edgeId].id);
        edgeId = this.body.edges[edgeId].edgeReplacedById;
        counter++;
      }
      stack.reverse();
      return stack;
    }

    /**
     * Get the base edge id of clusterEdgeId. cluster edge (clusteredEdgeId) -> cluster edge B -> cluster edge C -> base edge
     * @param {vis.Edge.id} clusteredEdgeId
     * @returns {vis.Edge.id} baseEdgeId
     *
     * TODO: deprecate in 5.0.0. Method getBaseEdges() is the correct one to use.
     */

  }, {
    key: 'getBaseEdge',
    value: function getBaseEdge(clusteredEdgeId) {
      // Just kludge this by returning the first base edge id found
      return this.getBaseEdges(clusteredEdgeId)[0];
    }

    /**
     * Get all regular edges for this clustered edge id.
     *
     * @param {vis.Edge.id} clusteredEdgeId
     * @returns {Array.<vis.Edge.id>} all baseEdgeId's under this clustered edge
     */

  }, {
    key: 'getBaseEdges',
    value: function getBaseEdges(clusteredEdgeId) {
      var IdsToHandle = [clusteredEdgeId];
      var doneIds = [];
      var foundIds = [];
      var max = 100;
      var counter = 0;

      while (IdsToHandle.length > 0 && counter < max) {
        var nextId = IdsToHandle.pop();
        if (nextId === undefined) continue; // Paranoia here and onwards
        var nextEdge = this.body.edges[nextId];
        if (nextEdge === undefined) continue;
        counter++;

        var replacingIds = nextEdge.clusteringEdgeReplacingIds;
        if (replacingIds === undefined) {
          // nextId is a base id
          foundIds.push(nextId);
        } else {
          // Another cluster edge, unravel this one as well
          for (var i = 0; i < replacingIds.length; ++i) {
            var replacingId = replacingIds[i];

            // Don't add if already handled
            // TODO: never triggers; find a test-case which does
            if (IdsToHandle.indexOf(replacingIds) !== -1 || doneIds.indexOf(replacingIds) !== -1) {
              continue;
            }

            IdsToHandle.push(replacingId);
          }
        }

        doneIds.push(nextId);
      }

      return foundIds;
    }

    /**
     * Get the Id the node is connected to
     * @param {vis.Edge} edge
     * @param {Node.id} nodeId
     * @returns {*}
     * @private
     */

  }, {
    key: '_getConnectedId',
    value: function _getConnectedId(edge, nodeId) {
      if (edge.toId != nodeId) {
        return edge.toId;
      } else if (edge.fromId != nodeId) {
        return edge.fromId;
      } else {
        return edge.fromId;
      }
    }

    /**
     * We determine how many connections denote an important hub.
     * We take the mean + 2*std as the important hub size. (Assuming a normal distribution of data, ~2.2%)
     *
     * @returns {number}
     * @private
     */

  }, {
    key: '_getHubSize',
    value: function _getHubSize() {
      var average = 0;
      var averageSquared = 0;
      var hubCounter = 0;
      var largestHub = 0;

      for (var i = 0; i < this.body.nodeIndices.length; i++) {
        var _node = this.body.nodes[this.body.nodeIndices[i]];
        if (_node.edges.length > largestHub) {
          largestHub = _node.edges.length;
        }
        average += _node.edges.length;
        averageSquared += Math.pow(_node.edges.length, 2);
        hubCounter += 1;
      }
      average = average / hubCounter;
      averageSquared = averageSquared / hubCounter;

      var variance = averageSquared - Math.pow(average, 2);
      var standardDeviation = Math.sqrt(variance);

      var hubThreshold = Math.floor(average + 2 * standardDeviation);

      // always have at least one to cluster
      if (hubThreshold > largestHub) {
        hubThreshold = largestHub;
      }

      return hubThreshold;
    }

    /**
     * Create an edge for the cluster representation.
     *
     * @param {Node.id} fromId
     * @param {Node.id} toId
     * @param {vis.Edge} baseEdge
     * @param {Object} clusterEdgeProperties
     * @param {Object} extraOptions
     * @returns {Edge} newly created clustered edge
     * @private
     */

  }, {
    key: '_createClusteredEdge',
    value: function _createClusteredEdge(fromId, toId, baseEdge, clusterEdgeProperties, extraOptions) {
      // copy the options of the edge we will replace
      var clonedOptions = NetworkUtil.cloneOptions(baseEdge, 'edge');
      // make sure the properties of clusterEdges are superimposed on it
      util.deepExtend(clonedOptions, clusterEdgeProperties);

      // set up the edge
      clonedOptions.from = fromId;
      clonedOptions.to = toId;
      clonedOptions.id = 'clusterEdge:' + util.randomUUID();

      // apply the edge specific options to it if specified
      if (extraOptions !== undefined) {
        util.deepExtend(clonedOptions, extraOptions);
      }

      var newEdge = this.body.functions.createEdge(clonedOptions);
      newEdge.clusteringEdgeReplacingIds = [baseEdge.id];
      newEdge.connect();

      // Register the new edge
      this.body.edges[newEdge.id] = newEdge;

      return newEdge;
    }

    /**
     * Add the passed child nodes and edges to the given cluster node.
     *
     * @param {Object|Node} childNodes  hash of nodes or single node to add in cluster
     * @param {Object|Edge} childEdges  hash of edges or single edge to take into account when clustering
     * @param {Node} clusterNode  cluster node to add nodes and edges to
     * @param {Object} [clusterEdgeProperties]
     * @private
     */

  }, {
    key: '_clusterEdges',
    value: function _clusterEdges(childNodes, childEdges, clusterNode, clusterEdgeProperties) {
      if (childEdges instanceof Edge) {
        var edge = childEdges;
        var obj = {};
        obj[edge.id] = edge;
        childEdges = obj;
      }

      if (childNodes instanceof Node) {
        var _node2 = childNodes;
        var _obj = {};
        _obj[_node2.id] = _node2;
        childNodes = _obj;
      }

      if (clusterNode === undefined || clusterNode === null) {
        throw new Error('_clusterEdges: parameter clusterNode required');
      }

      if (clusterEdgeProperties === undefined) {
        // Take the required properties from the cluster node
        clusterEdgeProperties = clusterNode.clusterEdgeProperties;
      }

      // create the new edges that will connect to the cluster.
      // All self-referencing edges will be added to childEdges here.
      this._createClusterEdges(childNodes, childEdges, clusterNode, clusterEdgeProperties);

      // disable the childEdges
      for (var edgeId in childEdges) {
        if (childEdges.hasOwnProperty(edgeId)) {
          if (this.body.edges[edgeId] !== undefined) {
            var _edge2 = this.body.edges[edgeId];
            // cache the options before changing
            this._backupEdgeOptions(_edge2);
            // disable physics and hide the edge
            _edge2.setOptions({ physics: false });
          }
        }
      }

      // disable the childNodes
      for (var _nodeId7 in childNodes) {
        if (childNodes.hasOwnProperty(_nodeId7)) {
          this.clusteredNodes[_nodeId7] = {
            clusterId: clusterNode.id,
            node: this.body.nodes[_nodeId7]
          };
          this.body.nodes[_nodeId7].setOptions({ physics: false });
        }
      }
    }

    /**
     * Determine in which cluster given nodeId resides.
     *
     * If not in cluster, return undefined.
     *
     * NOTE: If you know a cleaner way to do this, please enlighten me (wimrijnders).
     *
     * @param {Node.id} nodeId
     * @returns {Node|undefined} Node instance for cluster, if present
     * @private
     */

  }, {
    key: '_getClusterNodeForNode',
    value: function _getClusterNodeForNode(nodeId) {
      if (nodeId === undefined) return undefined;
      var clusteredNode = this.clusteredNodes[nodeId];

      // NOTE: If no cluster info found, it should actually be an error
      if (clusteredNode === undefined) return undefined;
      var clusterId = clusteredNode.clusterId;
      if (clusterId === undefined) return undefined;

      return this.body.nodes[clusterId];
    }

    /**
     * Internal helper function for conditionally removing items in array
     *
     * Done like this because Array.filter() is not fully supported by all IE's.
     *
     * @param {Array} arr
     * @param {function} callback
     * @returns {Array}
     * @private
     */

  }, {
    key: '_filter',
    value: function _filter(arr, callback) {
      var ret = [];

      util.forEach(arr, function (item) {
        if (callback(item)) {
          ret.push(item);
        }
      });

      return ret;
    }

    /**
     * Scan all edges for changes in clustering and adjust this if necessary.
     *
     * Call this (internally) after there has been a change in node or edge data.
     *
     * Pre: States of this.body.nodes and this.body.edges consistent
     * Pre: this.clusteredNodes and this.clusteredEdge consistent with containedNodes and containedEdges
     *      of cluster nodes.
     */

  }, {
    key: '_updateState',
    value: function _updateState() {
      var _this4 = this;

      var nodeId = void 0;
      var deletedNodeIds = [];
      var deletedEdgeIds = {};

      /**
       * Utility function to iterate over clustering nodes only
       *
       * @param {Function} callback  function to call for each cluster node
       */
      var eachClusterNode = function eachClusterNode(callback) {
        util.forEach(_this4.body.nodes, function (node) {
          if (node.isCluster === true) {
            callback(node);
          }
        });
      };

      //
      // Remove deleted regular nodes from clustering
      //

      // Determine the deleted nodes
      for (nodeId in this.clusteredNodes) {
        if (!this.clusteredNodes.hasOwnProperty(nodeId)) continue;
        var _node3 = this.body.nodes[nodeId];

        if (_node3 === undefined) {
          deletedNodeIds.push(nodeId);
        }
      }

      // Remove nodes from cluster nodes
      eachClusterNode(function (clusterNode) {
        for (var n = 0; n < deletedNodeIds.length; n++) {
          delete clusterNode.containedNodes[deletedNodeIds[n]];
        }
      });

      // Remove nodes from cluster list
      for (var n = 0; n < deletedNodeIds.length; n++) {
        delete this.clusteredNodes[deletedNodeIds[n]];
      }

      //
      // Remove deleted edges from clustering
      //

      // Add the deleted clustered edges to the list
      util.forEach(this.clusteredEdges, function (edgeId) {
        var edge = _this4.body.edges[edgeId];
        if (edge === undefined || !edge.endPointsValid()) {
          deletedEdgeIds[edgeId] = edgeId;
        }
      });

      // Cluster nodes can also contain edges which are not clustered,
      // i.e. nodes 1-2 within cluster with an edge in between.
      // So the cluster nodes also need to be scanned for invalid edges
      eachClusterNode(function (clusterNode) {
        util.forEach(clusterNode.containedEdges, function (edge, edgeId) {
          if (!edge.endPointsValid() && !deletedEdgeIds[edgeId]) {
            deletedEdgeIds[edgeId] = edgeId;
          }
        });
      });

      // Also scan for cluster edges which need to be removed in the active list.
      // Regular edges have been removed beforehand, so this only picks up the cluster edges.
      util.forEach(this.body.edges, function (edge, edgeId) {
        // Explicitly scan the contained edges for validity
        var isValid = true;
        var replacedIds = edge.clusteringEdgeReplacingIds;
        if (replacedIds !== undefined) {
          var numValid = 0;

          util.forEach(replacedIds, function (containedEdgeId) {
            var containedEdge = _this4.body.edges[containedEdgeId];

            if (containedEdge !== undefined && containedEdge.endPointsValid()) {
              numValid += 1;
            }
          });

          isValid = numValid > 0;
        }

        if (!edge.endPointsValid() || !isValid) {
          deletedEdgeIds[edgeId] = edgeId;
        }
      });

      // Remove edges from cluster nodes
      eachClusterNode(function (clusterNode) {
        util.forEach(deletedEdgeIds, function (deletedEdgeId) {
          delete clusterNode.containedEdges[deletedEdgeId];

          util.forEach(clusterNode.edges, function (edge, m) {
            if (edge.id === deletedEdgeId) {
              clusterNode.edges[m] = null; // Don't want to directly delete here, because in the loop
              return;
            }

            edge.clusteringEdgeReplacingIds = _this4._filter(edge.clusteringEdgeReplacingIds, function (id) {
              return !deletedEdgeIds[id];
            });
          });

          // Clean up the nulls
          clusterNode.edges = _this4._filter(clusterNode.edges, function (item) {
            return item !== null;
          });
        });
      });

      // Remove from cluster list
      util.forEach(deletedEdgeIds, function (edgeId) {
        delete _this4.clusteredEdges[edgeId];
      });

      // Remove cluster edges from active list (this.body.edges).
      // deletedEdgeIds still contains id of regular edges, but these should all
      // be gone when you reach here.
      util.forEach(deletedEdgeIds, function (edgeId) {
        delete _this4.body.edges[edgeId];
      });

      //
      // Check changed cluster state of edges
      //

      // Iterating over keys here, because edges may be removed in the loop
      var ids = (0, _keys2['default'])(this.body.edges);
      util.forEach(ids, function (edgeId) {
        var edge = _this4.body.edges[edgeId];

        var shouldBeClustered = _this4._isClusteredNode(edge.fromId) || _this4._isClusteredNode(edge.toId);
        if (shouldBeClustered === _this4._isClusteredEdge(edge.id)) {
          return; // all is well
        }

        if (shouldBeClustered) {
          // add edge to clustering
          var clusterFrom = _this4._getClusterNodeForNode(edge.fromId);
          if (clusterFrom !== undefined) {
            _this4._clusterEdges(_this4.body.nodes[edge.fromId], edge, clusterFrom);
          }

          var clusterTo = _this4._getClusterNodeForNode(edge.toId);
          if (clusterTo !== undefined) {
            _this4._clusterEdges(_this4.body.nodes[edge.toId], edge, clusterTo);
          }

          // TODO: check that it works for both edges clustered
          //       (This might be paranoia)
        } else {
          // This should not be happening, the state should
          // be properly updated at this point.
          //
          // If it *is* reached during normal operation, then we have to implement
          // undo clustering for this edge here.
          throw new Error('remove edge from clustering not implemented!');
        }
      });

      // Clusters may be nested to any level. Keep on opening until nothing to open
      var changed = false;
      var continueLoop = true;

      var _loop2 = function _loop2() {
        var clustersToOpen = [];

        // Determine the id's of clusters that need opening
        eachClusterNode(function (clusterNode) {
          var numNodes = (0, _keys2['default'])(clusterNode.containedNodes).length;
          var allowSingle = clusterNode.options.allowSingleNodeCluster === true;
          if (allowSingle && numNodes < 1 || !allowSingle && numNodes < 2) {
            clustersToOpen.push(clusterNode.id);
          }
        });

        // Open them
        for (var _n = 0; _n < clustersToOpen.length; ++_n) {
          _this4.openCluster(clustersToOpen[_n], {}, false /* Don't refresh, we're in an refresh/update already */
          );
        }

        continueLoop = clustersToOpen.length > 0;
        changed = changed || continueLoop;
      };

      while (continueLoop) {
        _loop2();
      }

      if (changed) {
        this._updateState(); // Redo this method (recursion possible! should be safe)
      }
    }

    /**
     * Determine if node with given id is part of a cluster.
     *
     * @param {Node.id} nodeId
     * @return {boolean} true if part of a cluster.
     */

  }, {
    key: '_isClusteredNode',
    value: function _isClusteredNode(nodeId) {
      return this.clusteredNodes[nodeId] !== undefined;
    }

    /**
     * Determine if edge with given id is not visible due to clustering.
     *
     * An edge is considered clustered if:
     * - it is directly replaced by a clustering edge
     * - any of its connecting nodes is in a cluster
     *
     * @param {vis.Edge.id} edgeId
     * @return {boolean} true if part of a cluster.
     */

  }, {
    key: '_isClusteredEdge',
    value: function _isClusteredEdge(edgeId) {
      return this.clusteredEdges[edgeId] !== undefined;
    }
  }]);
  return ClusterEngine;
}();

exports['default'] = ClusterEngine;

/***/ }),
/* 179 */
/***/ (function(module, exports, __nested_webpack_require_951802__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = __nested_webpack_require_951802__(3);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __nested_webpack_require_951802__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_951802__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __nested_webpack_require_951802__(4);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __nested_webpack_require_951802__(5);

var _inherits3 = _interopRequireDefault(_inherits2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var util = __nested_webpack_require_951802__(2);
var Node = __nested_webpack_require_951802__(34)['default'];

/**
 * A Cluster is a special Node that allows a group of Nodes positioned closely together
 * to be represented by a single Cluster Node.
 *
 * @extends Node
 */

var Cluster = function (_Node) {
  (0, _inherits3['default'])(Cluster, _Node);

  /**
   * @param {Object} options
   * @param {Object} body
   * @param {Array.<HTMLImageElement>}imagelist
   * @param {Array} grouplist
   * @param {Object} globalOptions
   * @param {Object} defaultOptions     Global default options for nodes
   */
  function Cluster(options, body, imagelist, grouplist, globalOptions, defaultOptions) {
    (0, _classCallCheck3['default'])(this, Cluster);

    var _this = (0, _possibleConstructorReturn3['default'])(this, (Cluster.__proto__ || (0, _getPrototypeOf2['default'])(Cluster)).call(this, options, body, imagelist, grouplist, globalOptions, defaultOptions));

    _this.isCluster = true;
    _this.containedNodes = {};
    _this.containedEdges = {};
    return _this;
  }

  /**
   * Transfer child cluster data to current and disconnect the child cluster.
   *
   * Please consult the header comment in 'Clustering.js' for the fields set here.
   *
   * @param {string|number} childClusterId  id of child cluster to open
   */


  (0, _createClass3['default'])(Cluster, [{
    key: '_openChildCluster',
    value: function _openChildCluster(childClusterId) {
      var _this2 = this;

      var childCluster = this.body.nodes[childClusterId];
      if (this.containedNodes[childClusterId] === undefined) {
        throw new Error('node with id: ' + childClusterId + ' not in current cluster');
      }
      if (!childCluster.isCluster) {
        throw new Error('node with id: ' + childClusterId + ' is not a cluster');
      }

      // Disconnect child cluster from current cluster
      delete this.containedNodes[childClusterId];
      util.forEach(childCluster.edges, function (edge) {
        delete _this2.containedEdges[edge.id];
      });

      // Transfer nodes and edges
      util.forEach(childCluster.containedNodes, function (node, nodeId) {
        _this2.containedNodes[nodeId] = node;
      });
      childCluster.containedNodes = {};

      util.forEach(childCluster.containedEdges, function (edge, edgeId) {
        _this2.containedEdges[edgeId] = edge;
      });
      childCluster.containedEdges = {};

      // Transfer edges within cluster edges which are clustered
      util.forEach(childCluster.edges, function (clusterEdge) {
        util.forEach(_this2.edges, function (parentClusterEdge) {
          // Assumption: a clustered edge can only be present in a single clustering edge
          // Not tested here
          var index = parentClusterEdge.clusteringEdgeReplacingIds.indexOf(clusterEdge.id);
          if (index === -1) return;

          util.forEach(clusterEdge.clusteringEdgeReplacingIds, function (srcId) {
            parentClusterEdge.clusteringEdgeReplacingIds.push(srcId);

            // Maintain correct bookkeeping for transferred edge
            _this2.body.edges[srcId].edgeReplacedById = parentClusterEdge.id;
          });

          // Remove cluster edge from parent cluster edge
          parentClusterEdge.clusteringEdgeReplacingIds.splice(index, 1);
        });
      });
      childCluster.edges = [];
    }
  }]);
  return Cluster;
}(Node);

exports['default'] = Cluster;

/***/ }),
/* 180 */
/***/ (function(module, exports, __nested_webpack_require_956047__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __nested_webpack_require_956047__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_956047__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * Initializes window.requestAnimationFrame() to a usable form.
 *
 * Specifically, set up this method for the case of running on node.js with jsdom enabled.
 *
 * NOTES:
 *
 * * On node.js, when calling this directly outside of this class, `window` is not defined.
 *   This happens even if jsdom is used.
 * * For node.js + jsdom, `window` is available at the moment the constructor is called.
 *   For this reason, the called is placed within the constructor.
 * * Even then, `window.requestAnimationFrame()` is not defined, so it still needs to be added.
 * * During unit testing, it happens that the window object is reset during execution, causing
 *   a runtime error due to missing `requestAnimationFrame()`. This needs to be compensated for,
 *   see `_requestNextFrame()`.
 * * Since this is a global object, it may affect other modules besides `Network`. With normal
 *   usage, this does not cause any problems. During unit testing, errors may occur. These have
 *   been compensated for, see comment block in _requestNextFrame().
 *
 * @private
 */
function _initRequestAnimationFrame() {
  var func;

  if (window !== undefined) {
    func = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
  }

  if (func === undefined) {
    // window or method not present, setting mock requestAnimationFrame
    window.requestAnimationFrame = function (callback) {
      //console.log("Called mock requestAnimationFrame");
      callback();
    };
  } else {
    window.requestAnimationFrame = func;
  }
}

var util = __nested_webpack_require_956047__(2);

/**
 * The canvas renderer
 */

var CanvasRenderer = function () {
  /**
   * @param {Object} body
   * @param {Canvas} canvas
   */
  function CanvasRenderer(body, canvas) {
    (0, _classCallCheck3['default'])(this, CanvasRenderer);

    _initRequestAnimationFrame();
    this.body = body;
    this.canvas = canvas;

    this.redrawRequested = false;
    this.renderTimer = undefined;
    this.requiresTimeout = true;
    this.renderingActive = false;
    this.renderRequests = 0;
    this.allowRedraw = true;

    this.dragging = false;
    this.zooming = false;
    this.options = {};
    this.defaultOptions = {
      hideEdgesOnDrag: false,
      hideEdgesOnZoom: false,
      hideNodesOnDrag: false
    };
    util.extend(this.options, this.defaultOptions);

    this._determineBrowserMethod();
    this.bindEventListeners();
  }

  /**
   * Binds event listeners
   */


  (0, _createClass3['default'])(CanvasRenderer, [{
    key: 'bindEventListeners',
    value: function bindEventListeners() {
      var _this = this;

      this.body.emitter.on('dragStart', function () {
        _this.dragging = true;
      });
      this.body.emitter.on('dragEnd', function () {
        _this.dragging = false;
      });
      this.body.emitter.on('zoom', function () {
        _this.zooming = true;
        window.clearTimeout(_this.zoomTimeoutId);
        _this.zoomTimeoutId = window.setTimeout(function () {
          _this.zooming = false;
          _this._requestRedraw.bind(_this)();
        }, 250);
      });
      this.body.emitter.on('_resizeNodes', function () {
        _this._resizeNodes();
      });
      this.body.emitter.on('_redraw', function () {
        if (_this.renderingActive === false) {
          _this._redraw();
        }
      });
      this.body.emitter.on('_blockRedraw', function () {
        _this.allowRedraw = false;
      });
      this.body.emitter.on('_allowRedraw', function () {
        _this.allowRedraw = true;
        _this.redrawRequested = false;
      });
      this.body.emitter.on('_requestRedraw', this._requestRedraw.bind(this));
      this.body.emitter.on('_startRendering', function () {
        _this.renderRequests += 1;
        _this.renderingActive = true;
        _this._startRendering();
      });
      this.body.emitter.on('_stopRendering', function () {
        _this.renderRequests -= 1;
        _this.renderingActive = _this.renderRequests > 0;
        _this.renderTimer = undefined;
      });
      this.body.emitter.on('destroy', function () {
        _this.renderRequests = 0;
        _this.allowRedraw = false;
        _this.renderingActive = false;
        if (_this.requiresTimeout === true) {
          clearTimeout(_this.renderTimer);
        } else {
          window.cancelAnimationFrame(_this.renderTimer);
        }
        _this.body.emitter.off();
      });
    }

    /**
     *
     * @param {Object} options
     */

  }, {
    key: 'setOptions',
    value: function setOptions(options) {
      if (options !== undefined) {
        var fields = ['hideEdgesOnDrag', 'hideEdgesOnZoom', 'hideNodesOnDrag'];
        util.selectiveDeepExtend(fields, this.options, options);
      }
    }

    /**
     * Prepare the drawing of the next frame.
     *
     * Calls the callback when the next frame can or will be drawn.
     *
     * @param {function} callback
     * @param {number} delay - timeout case only, wait this number of milliseconds
     * @returns {function|undefined}
     * @private
     */

  }, {
    key: '_requestNextFrame',
    value: function _requestNextFrame(callback, delay) {
      // During unit testing, it happens that the mock window object is reset while
      // the next frame is still pending. Then, either 'window' is not present, or
      // 'requestAnimationFrame()' is not present because it is not defined on the
      // mock window object.
      //
      // As a consequence, unrelated unit tests may appear to fail, even if the problem
      // described happens in the current unit test.
      //
      // This is not something that will happen in normal operation, but we still need
      // to take it into account.
      //
      if (typeof window === 'undefined') return; // Doing `if (window === undefined)` does not work here!

      var timer = void 0;

      var myWindow = window; // Grab a reference to reduce the possibility that 'window' is reset
      // while running this method.

      if (this.requiresTimeout === true) {
        // wait given number of milliseconds and perform the animation step function
        timer = myWindow.setTimeout(callback, delay);
      } else {
        if (myWindow.requestAnimationFrame) {
          timer = myWindow.requestAnimationFrame(callback);
        }
      }

      return timer;
    }

    /**
     *
     * @private
     */

  }, {
    key: '_startRendering',
    value: function _startRendering() {
      if (this.renderingActive === true) {
        if (this.renderTimer === undefined) {
          this.renderTimer = this._requestNextFrame(this._renderStep.bind(this), this.simulationInterval);
        }
      }
    }

    /**
     *
     * @private
     */

  }, {
    key: '_renderStep',
    value: function _renderStep() {
      if (this.renderingActive === true) {
        // reset the renderTimer so a new scheduled animation step can be set
        this.renderTimer = undefined;

        if (this.requiresTimeout === true) {
          // this schedules a new simulation step
          this._startRendering();
        }

        this._redraw();

        if (this.requiresTimeout === false) {
          // this schedules a new simulation step
          this._startRendering();
        }
      }
    }

    /**
     * Redraw the network with the current data
     * chart will be resized too.
     */

  }, {
    key: 'redraw',
    value: function redraw() {
      this.body.emitter.emit('setSize');
      this._redraw();
    }

    /**
     * Redraw the network with the current data
     * @private
     */

  }, {
    key: '_requestRedraw',
    value: function _requestRedraw() {
      var _this2 = this;

      if (this.redrawRequested !== true && this.renderingActive === false && this.allowRedraw === true) {
        this.redrawRequested = true;
        this._requestNextFrame(function () {
          _this2._redraw(false);
        }, 0);
      }
    }

    /**
     * Redraw the network with the current data
     * @param {boolean} [hidden=false] | Used to get the first estimate of the node sizes.
     *                                   Only the nodes are drawn after which they are quickly drawn over.
     * @private
     */

  }, {
    key: '_redraw',
    value: function _redraw() {
      var hidden = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.allowRedraw === true) {
        this.body.emitter.emit('initRedraw');

        this.redrawRequested = false;

        // when the container div was hidden, this fixes it back up!
        if (this.canvas.frame.canvas.width === 0 || this.canvas.frame.canvas.height === 0) {
          this.canvas.setSize();
        }

        this.canvas.setTransform();

        var ctx = this.canvas.getContext();

        // clear the canvas
        var w = this.canvas.frame.canvas.clientWidth;
        var h = this.canvas.frame.canvas.clientHeight;
        ctx.clearRect(0, 0, w, h);

        // if the div is hidden, we stop the redraw here for performance.
        if (this.canvas.frame.clientWidth === 0) {
          return;
        }

        // set scaling and translation
        ctx.save();
        ctx.translate(this.body.view.translation.x, this.body.view.translation.y);
        ctx.scale(this.body.view.scale, this.body.view.scale);

        ctx.beginPath();
        this.body.emitter.emit('beforeDrawing', ctx);
        ctx.closePath();

        if (hidden === false) {
          if ((this.dragging === false || this.dragging === true && this.options.hideEdgesOnDrag === false) && (this.zooming === false || this.zooming === true && this.options.hideEdgesOnZoom === false)) {
            this._drawEdges(ctx);
          }
        }

        if (this.dragging === false || this.dragging === true && this.options.hideNodesOnDrag === false) {
          this._drawNodes(ctx, hidden);
        }

        ctx.beginPath();
        this.body.emitter.emit('afterDrawing', ctx);
        ctx.closePath();

        // restore original scaling and translation
        ctx.restore();
        if (hidden === true) {
          ctx.clearRect(0, 0, w, h);
        }
      }
    }

    /**
     * Redraw all nodes
     *
     * @param {CanvasRenderingContext2D}   ctx
     * @param {boolean} [alwaysShow]
     * @private
     */

  }, {
    key: '_resizeNodes',
    value: function _resizeNodes() {
      this.canvas.setTransform();
      var ctx = this.canvas.getContext();
      ctx.save();
      ctx.translate(this.body.view.translation.x, this.body.view.translation.y);
      ctx.scale(this.body.view.scale, this.body.view.scale);

      var nodes = this.body.nodes;
      var node = void 0;

      // resize all nodes
      for (var nodeId in nodes) {
        if (nodes.hasOwnProperty(nodeId)) {
          node = nodes[nodeId];
          node.resize(ctx);
          node.updateBoundingBox(ctx, node.selected);
        }
      }

      // restore original scaling and translation
      ctx.restore();
    }

    /**
     * Redraw all nodes
     *
     * @param {CanvasRenderingContext2D} ctx  2D context of a HTML canvas
     * @param {boolean} [alwaysShow]
     * @private
     */

  }, {
    key: '_drawNodes',
    value: function _drawNodes(ctx) {
      var alwaysShow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var nodes = this.body.nodes;
      var nodeIndices = this.body.nodeIndices;
      var node = void 0;
      var selected = [];
      var margin = 20;
      var topLeft = this.canvas.DOMtoCanvas({ x: -margin, y: -margin });
      var bottomRight = this.canvas.DOMtoCanvas({
        x: this.canvas.frame.canvas.clientWidth + margin,
        y: this.canvas.frame.canvas.clientHeight + margin
      });
      var viewableArea = {
        top: topLeft.y,
        left: topLeft.x,
        bottom: bottomRight.y,
        right: bottomRight.x

        // draw unselected nodes;
      };for (var i = 0; i < nodeIndices.length; i++) {
        node = nodes[nodeIndices[i]];
        // set selected nodes aside
        if (node.isSelected()) {
          selected.push(nodeIndices[i]);
        } else {
          if (alwaysShow === true) {
            node.draw(ctx);
          } else if (node.isBoundingBoxOverlappingWith(viewableArea) === true) {
            node.draw(ctx);
          } else {
            node.updateBoundingBox(ctx, node.selected);
          }
        }
      }

      // draw the selected nodes on top
      for (var _i = 0; _i < selected.length; _i++) {
        node = nodes[selected[_i]];
        node.draw(ctx);
      }
    }

    /**
     * Redraw all edges
     * @param {CanvasRenderingContext2D} ctx  2D context of a HTML canvas
     * @private
     */

  }, {
    key: '_drawEdges',
    value: function _drawEdges(ctx) {
      var edges = this.body.edges;
      var edgeIndices = this.body.edgeIndices;
      var edge = void 0;

      for (var i = 0; i < edgeIndices.length; i++) {
        edge = edges[edgeIndices[i]];
        if (edge.connected === true) {
          edge.draw(ctx);
        }
      }
    }

    /**
     * Determine if the browser requires a setTimeout or a requestAnimationFrame. This was required because
     * some implementations (safari and IE9) did not support requestAnimationFrame
     * @private
     */

  }, {
    key: '_determineBrowserMethod',
    value: function _determineBrowserMethod() {
      if (typeof window !== 'undefined') {
        var browserType = navigator.userAgent.toLowerCase();
        this.requiresTimeout = false;
        if (browserType.indexOf('msie 9.0') != -1) {
          // IE 9
          this.requiresTimeout = true;
        } else if (browserType.indexOf('safari') != -1) {
          // safari
          if (browserType.indexOf('chrome') <= -1) {
            this.requiresTimeout = true;
          }
        }
      } else {
        this.requiresTimeout = true;
      }
    }
  }]);
  return CanvasRenderer;
}();

exports['default'] = CanvasRenderer;

/***/ }),
/* 181 */
/***/ (function(module, exports, __nested_webpack_require_970513__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __nested_webpack_require_970513__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_970513__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var Hammer = __nested_webpack_require_970513__(24);
var hammerUtil = __nested_webpack_require_970513__(36);

var util = __nested_webpack_require_970513__(2);

/**
 * Create the main frame for the Network.
 * This function is executed once when a Network object is created. The frame
 * contains a canvas, and this canvas contains all objects like the axis and
 * nodes.
 */

var Canvas = function () {
  /**
   * @param {Object} body
   */
  function Canvas(body) {
    (0, _classCallCheck3['default'])(this, Canvas);

    this.body = body;
    this.pixelRatio = 1;
    this.resizeTimer = undefined;
    this.resizeFunction = this._onResize.bind(this);
    this.cameraState = {};
    this.initialized = false;
    this.canvasViewCenter = {};

    this.options = {};
    this.defaultOptions = {
      autoResize: true,
      height: '100%',
      width: '100%'
    };
    util.extend(this.options, this.defaultOptions);

    this.bindEventListeners();
  }

  /**
   * Binds event listeners
   */


  (0, _createClass3['default'])(Canvas, [{
    key: 'bindEventListeners',
    value: function bindEventListeners() {
      var _this = this;

      // bind the events
      this.body.emitter.once('resize', function (obj) {
        if (obj.width !== 0) {
          _this.body.view.translation.x = obj.width * 0.5;
        }
        if (obj.height !== 0) {
          _this.body.view.translation.y = obj.height * 0.5;
        }
      });
      this.body.emitter.on('setSize', this.setSize.bind(this));
      this.body.emitter.on('destroy', function () {
        _this.hammerFrame.destroy();
        _this.hammer.destroy();
        _this._cleanUp();
      });
    }

    /**
     * @param {Object} options
     */

  }, {
    key: 'setOptions',
    value: function setOptions(options) {
      var _this2 = this;

      if (options !== undefined) {
        var fields = ['width', 'height', 'autoResize'];
        util.selectiveDeepExtend(fields, this.options, options);
      }

      if (this.options.autoResize === true) {
        // automatically adapt to a changing size of the browser.
        this._cleanUp();
        this.resizeTimer = setInterval(function () {
          var changed = _this2.setSize();
          if (changed === true) {
            _this2.body.emitter.emit('_requestRedraw');
          }
        }, 1000);
        this.resizeFunction = this._onResize.bind(this);
        util.addEventListener(window, 'resize', this.resizeFunction);
      }
    }

    /**
     * @private
     */

  }, {
    key: '_cleanUp',
    value: function _cleanUp() {
      // automatically adapt to a changing size of the browser.
      if (this.resizeTimer !== undefined) {
        clearInterval(this.resizeTimer);
      }
      util.removeEventListener(window, 'resize', this.resizeFunction);
      this.resizeFunction = undefined;
    }

    /**
     * @private
     */

  }, {
    key: '_onResize',
    value: function _onResize() {
      this.setSize();
      this.body.emitter.emit('_redraw');
    }

    /**
     * Get and store the cameraState
     *
     * @param {number} [pixelRatio=this.pixelRatio]
     * @private
     */

  }, {
    key: '_getCameraState',
    value: function _getCameraState() {
      var pixelRatio = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.pixelRatio;

      if (this.initialized === true) {
        this.cameraState.previousWidth = this.frame.canvas.width / pixelRatio;
        this.cameraState.previousHeight = this.frame.canvas.height / pixelRatio;
        this.cameraState.scale = this.body.view.scale;
        this.cameraState.position = this.DOMtoCanvas({
          x: 0.5 * this.frame.canvas.width / pixelRatio,
          y: 0.5 * this.frame.canvas.height / pixelRatio
        });
      }
    }

    /**
     * Set the cameraState
     * @private
     */

  }, {
    key: '_setCameraState',
    value: function _setCameraState() {
      if (this.cameraState.scale !== undefined && this.frame.canvas.clientWidth !== 0 && this.frame.canvas.clientHeight !== 0 && this.pixelRatio !== 0 && this.cameraState.previousWidth > 0) {
        var widthRatio = this.frame.canvas.width / this.pixelRatio / this.cameraState.previousWidth;
        var heightRatio = this.frame.canvas.height / this.pixelRatio / this.cameraState.previousHeight;
        var newScale = this.cameraState.scale;

        if (widthRatio != 1 && heightRatio != 1) {
          newScale = this.cameraState.scale * 0.5 * (widthRatio + heightRatio);
        } else if (widthRatio != 1) {
          newScale = this.cameraState.scale * widthRatio;
        } else if (heightRatio != 1) {
          newScale = this.cameraState.scale * heightRatio;
        }

        this.body.view.scale = newScale;
        // this comes from the view module.
        var currentViewCenter = this.DOMtoCanvas({
          x: 0.5 * this.frame.canvas.clientWidth,
          y: 0.5 * this.frame.canvas.clientHeight
        });

        var distanceFromCenter = {
          // offset from view, distance view has to change by these x and y to center the node
          x: currentViewCenter.x - this.cameraState.position.x,
          y: currentViewCenter.y - this.cameraState.position.y
        };
        this.body.view.translation.x += distanceFromCenter.x * this.body.view.scale;
        this.body.view.translation.y += distanceFromCenter.y * this.body.view.scale;
      }
    }

    /**
     *
     * @param {number|string} value
     * @returns {string}
     * @private
     */

  }, {
    key: '_prepareValue',
    value: function _prepareValue(value) {
      if (typeof value === 'number') {
        return value + 'px';
      } else if (typeof value === 'string') {
        if (value.indexOf('%') !== -1 || value.indexOf('px') !== -1) {
          return value;
        } else if (value.indexOf('%') === -1) {
          return value + 'px';
        }
      }
      throw new Error('Could not use the value supplied for width or height:' + value);
    }

    /**
     * Create the HTML
     */

  }, {
    key: '_create',
    value: function _create() {
      // remove all elements from the container element.
      while (this.body.container.hasChildNodes()) {
        this.body.container.removeChild(this.body.container.firstChild);
      }

      this.frame = document.createElement('div');
      this.frame.className = 'vis-network';
      this.frame.style.position = 'relative';
      this.frame.style.overflow = 'hidden';
      this.frame.tabIndex = 900; // tab index is required for keycharm to bind keystrokes to the div instead of the window

      //////////////////////////////////////////////////////////////////

      this.frame.canvas = document.createElement('canvas');
      this.frame.canvas.style.position = 'relative';
      this.frame.appendChild(this.frame.canvas);

      if (!this.frame.canvas.getContext) {
        var noCanvas = document.createElement('DIV');
        noCanvas.style.color = 'red';
        noCanvas.style.fontWeight = 'bold';
        noCanvas.style.padding = '10px';
        noCanvas.innerHTML = 'Error: your browser does not support HTML canvas';
        this.frame.canvas.appendChild(noCanvas);
      } else {
        this._setPixelRatio();
        this.setTransform();
      }

      // add the frame to the container element
      this.body.container.appendChild(this.frame);

      this.body.view.scale = 1;
      this.body.view.translation = {
        x: 0.5 * this.frame.canvas.clientWidth,
        y: 0.5 * this.frame.canvas.clientHeight
      };

      this._bindHammer();
    }

    /**
     * This function binds hammer, it can be repeated over and over due to the uniqueness check.
     * @private
     */

  }, {
    key: '_bindHammer',
    value: function _bindHammer() {
      var _this3 = this;

      if (this.hammer !== undefined) {
        this.hammer.destroy();
      }
      this.drag = {};
      this.pinch = {};

      // init hammer
      this.hammer = new Hammer(this.frame.canvas);
      this.hammer.get('pinch').set({ enable: true });
      // enable to get better response, todo: test on mobile.
      this.hammer.get('pan').set({ threshold: 5, direction: Hammer.DIRECTION_ALL });

      hammerUtil.onTouch(this.hammer, function (event) {
        _this3.body.eventListeners.onTouch(event);
      });
      this.hammer.on('tap', function (event) {
        _this3.body.eventListeners.onTap(event);
      });
      this.hammer.on('doubletap', function (event) {
        _this3.body.eventListeners.onDoubleTap(event);
      });
      this.hammer.on('press', function (event) {
        _this3.body.eventListeners.onHold(event);
      });
      this.hammer.on('panstart', function (event) {
        _this3.body.eventListeners.onDragStart(event);
      });
      this.hammer.on('panmove', function (event) {
        _this3.body.eventListeners.onDrag(event);
      });
      this.hammer.on('panend', function (event) {
        _this3.body.eventListeners.onDragEnd(event);
      });
      this.hammer.on('pinch', function (event) {
        _this3.body.eventListeners.onPinch(event);
      });

      // TODO: neatly cleanup these handlers when re-creating the Canvas, IF these are done with hammer, event.stopPropagation will not work?
      this.frame.canvas.addEventListener('mousewheel', function (event) {
        _this3.body.eventListeners.onMouseWheel(event);
      });
      this.frame.canvas.addEventListener('DOMMouseScroll', function (event) {
        _this3.body.eventListeners.onMouseWheel(event);
      });

      this.frame.canvas.addEventListener('mousemove', function (event) {
        _this3.body.eventListeners.onMouseMove(event);
      });
      this.frame.canvas.addEventListener('contextmenu', function (event) {
        _this3.body.eventListeners.onContext(event);
      });

      this.hammerFrame = new Hammer(this.frame);
      hammerUtil.onRelease(this.hammerFrame, function (event) {
        _this3.body.eventListeners.onRelease(event);
      });
    }

    /**
     * Set a new size for the network
     * @param {string} width   Width in pixels or percentage (for example '800px'
     *                         or '50%')
     * @param {string} height  Height in pixels or percentage  (for example '400px'
     *                         or '30%')
     * @returns {boolean}
     */

  }, {
    key: 'setSize',
    value: function setSize() {
      var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options.width;
      var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.options.height;

      width = this._prepareValue(width);
      height = this._prepareValue(height);

      var emitEvent = false;
      var oldWidth = this.frame.canvas.width;
      var oldHeight = this.frame.canvas.height;

      // update the pixel ratio
      //
      // NOTE: Comment in following is rather inconsistent; this is the ONLY place in the code
      //       where it is assumed that the pixel ratio could change at runtime.
      //       The only way I can think of this happening is a rotating screen or tablet; but then
      //       there should be a mechanism for reloading the data (TODO: check if this is present).
      //
      //       If the assumption is true (i.e. pixel ratio can change at runtime), then *all* usage
      //       of pixel ratio must be overhauled for this.
      //
      //       For the time being, I will humor the assumption here, and in the rest of the code assume it is
      //       constant.
      var previousRatio = this.pixelRatio; // we cache this because the camera state storage needs the old value
      this._setPixelRatio();

      if (width != this.options.width || height != this.options.height || this.frame.style.width != width || this.frame.style.height != height) {
        this._getCameraState(previousRatio);

        this.frame.style.width = width;
        this.frame.style.height = height;

        this.frame.canvas.style.width = '100%';
        this.frame.canvas.style.height = '100%';

        this.frame.canvas.width = Math.round(this.frame.canvas.clientWidth * this.pixelRatio);
        this.frame.canvas.height = Math.round(this.frame.canvas.clientHeight * this.pixelRatio);

        this.options.width = width;
        this.options.height = height;

        this.canvasViewCenter = {
          x: 0.5 * this.frame.clientWidth,
          y: 0.5 * this.frame.clientHeight
        };

        emitEvent = true;
      } else {
        // this would adapt the width of the canvas to the width from 100% if and only if
        // there is a change.

        var newWidth = Math.round(this.frame.canvas.clientWidth * this.pixelRatio);
        var newHeight = Math.round(this.frame.canvas.clientHeight * this.pixelRatio);

        // store the camera if there is a change in size.
        if (this.frame.canvas.width !== newWidth || this.frame.canvas.height !== newHeight) {
          this._getCameraState(previousRatio);
        }

        if (this.frame.canvas.width !== newWidth) {
          this.frame.canvas.width = newWidth;
          emitEvent = true;
        }
        if (this.frame.canvas.height !== newHeight) {
          this.frame.canvas.height = newHeight;
          emitEvent = true;
        }
      }

      if (emitEvent === true) {
        this.body.emitter.emit('resize', {
          width: Math.round(this.frame.canvas.width / this.pixelRatio),
          height: Math.round(this.frame.canvas.height / this.pixelRatio),
          oldWidth: Math.round(oldWidth / this.pixelRatio),
          oldHeight: Math.round(oldHeight / this.pixelRatio)
        });

        // restore the camera on change.
        this._setCameraState();
      }

      // set initialized so the get and set camera will work from now on.
      this.initialized = true;
      return emitEvent;
    }

    /**
     *
     * @returns {CanvasRenderingContext2D}
     */

  }, {
    key: 'getContext',
    value: function getContext() {
      return this.frame.canvas.getContext('2d');
    }

    /**
     * Determine the pixel ratio for various browsers.
     *
     * @returns {number}
     * @private
     */

  }, {
    key: '_determinePixelRatio',
    value: function _determinePixelRatio() {
      var ctx = this.getContext();
      if (ctx === undefined) {
        throw new Error('Could not get canvax context');
      }

      var numerator = 1;
      if (typeof window !== 'undefined') {
        // (window !== undefined) doesn't work here!
        // Protection during unit tests, where 'window' can be missing
        numerator = window.devicePixelRatio || 1;
      }

      var denominator = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;

      return numerator / denominator;
    }

    /**
     * Lazy determination of pixel ratio.
     *
     * @private
     */

  }, {
    key: '_setPixelRatio',
    value: function _setPixelRatio() {
      this.pixelRatio = this._determinePixelRatio();
    }

    /**
     * Set the transform in the contained context, based on its pixelRatio
     */

  }, {
    key: 'setTransform',
    value: function setTransform() {
      var ctx = this.getContext();
      if (ctx === undefined) {
        throw new Error('Could not get canvax context');
      }

      ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
    }

    /**
     * Convert the X coordinate in DOM-space (coordinate point in browser relative to the container div) to
     * the X coordinate in canvas-space (the simulation sandbox, which the camera looks upon)
     * @param {number} x
     * @returns {number}
     * @private
     */

  }, {
    key: '_XconvertDOMtoCanvas',
    value: function _XconvertDOMtoCanvas(x) {
      return (x - this.body.view.translation.x) / this.body.view.scale;
    }

    /**
     * Convert the X coordinate in canvas-space (the simulation sandbox, which the camera looks upon) to
     * the X coordinate in DOM-space (coordinate point in browser relative to the container div)
     * @param {number} x
     * @returns {number}
     * @private
     */

  }, {
    key: '_XconvertCanvasToDOM',
    value: function _XconvertCanvasToDOM(x) {
      return x * this.body.view.scale + this.body.view.translation.x;
    }

    /**
     * Convert the Y coordinate in DOM-space (coordinate point in browser relative to the container div) to
     * the Y coordinate in canvas-space (the simulation sandbox, which the camera looks upon)
     * @param {number} y
     * @returns {number}
     * @private
     */

  }, {
    key: '_YconvertDOMtoCanvas',
    value: function _YconvertDOMtoCanvas(y) {
      return (y - this.body.view.translation.y) / this.body.view.scale;
    }

    /**
     * Convert the Y coordinate in canvas-space (the simulation sandbox, which the camera looks upon) to
     * the Y coordinate in DOM-space (coordinate point in browser relative to the container div)
     * @param {number} y
     * @returns {number}
     * @private
     */

  }, {
    key: '_YconvertCanvasToDOM',
    value: function _YconvertCanvasToDOM(y) {
      return y * this.body.view.scale + this.body.view.translation.y;
    }

    /**
     * @param {point} pos
     * @returns {point}
     */

  }, {
    key: 'canvasToDOM',
    value: function canvasToDOM(pos) {
      return {
        x: this._XconvertCanvasToDOM(pos.x),
        y: this._YconvertCanvasToDOM(pos.y)
      };
    }

    /**
     *
     * @param {point} pos
     * @returns {point}
     */

  }, {
    key: 'DOMtoCanvas',
    value: function DOMtoCanvas(pos) {
      return {
        x: this._XconvertDOMtoCanvas(pos.x),
        y: this._YconvertDOMtoCanvas(pos.y)
      };
    }
  }]);
  return Canvas;
}();

exports['default'] = Canvas;

/***/ }),
/* 182 */
/***/ (function(module, exports, __nested_webpack_require_988723__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = __nested_webpack_require_988723__(78);

var _assign2 = _interopRequireDefault(_assign);

var _classCallCheck2 = __nested_webpack_require_988723__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_988723__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var util = __nested_webpack_require_988723__(2);

var NetworkUtil = __nested_webpack_require_988723__(57)['default'];

/**
 * The view
 */

var View = function () {
  /**
   * @param {Object} body
   * @param {Canvas} canvas
   */
  function View(body, canvas) {
    var _this = this;

    (0, _classCallCheck3['default'])(this, View);

    this.body = body;
    this.canvas = canvas;

    this.animationSpeed = 1 / this.renderRefreshRate;
    this.animationEasingFunction = 'easeInOutQuint';
    this.easingTime = 0;
    this.sourceScale = 0;
    this.targetScale = 0;
    this.sourceTranslation = 0;
    this.targetTranslation = 0;
    this.lockedOnNodeId = undefined;
    this.lockedOnNodeOffset = undefined;
    this.touchTime = 0;

    this.viewFunction = undefined;

    this.body.emitter.on('fit', this.fit.bind(this));
    this.body.emitter.on('animationFinished', function () {
      _this.body.emitter.emit('_stopRendering');
    });
    this.body.emitter.on('unlockNode', this.releaseNode.bind(this));
  }

  /**
   *
   * @param {Object} [options={}]
   */


  (0, _createClass3['default'])(View, [{
    key: 'setOptions',
    value: function setOptions() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.options = options;
    }

    /**
     * This function zooms out to fit all data on screen based on amount of nodes
     * @param {Object} [options={{nodes=Array}}]
     * @param {boolean} [initialZoom=false]  | zoom based on fitted formula or range, true = fitted, default = false;
     */

  }, {
    key: 'fit',
    value: function fit() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { nodes: [] };
      var initialZoom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var range = void 0;
      var zoomLevel = void 0;
      options = (0, _assign2['default'])({}, options);
      if (options.nodes === undefined || options.nodes.length === 0) {
        options.nodes = this.body.nodeIndices;
      }

      if (initialZoom === true) {
        // check if more than half of the nodes have a predefined position. If so, we use the range, not the approximation.
        var positionDefined = 0;
        for (var nodeId in this.body.nodes) {
          if (this.body.nodes.hasOwnProperty(nodeId)) {
            var node = this.body.nodes[nodeId];
            if (node.predefinedPosition === true) {
              positionDefined += 1;
            }
          }
        }
        if (positionDefined > 0.5 * this.body.nodeIndices.length) {
          this.fit(options, false);
          return;
        }

        range = NetworkUtil.getRange(this.body.nodes, options.nodes);

        var numberOfNodes = this.body.nodeIndices.length;
        zoomLevel = 12.662 / (numberOfNodes + 7.4147) + 0.0964822; // this is obtained from fitting a dataset from 5 points with scale levels that looked good.

        // correct for larger canvasses.
        var factor = Math.min(this.canvas.frame.canvas.clientWidth / 600, this.canvas.frame.canvas.clientHeight / 600);
        zoomLevel *= factor;
      } else {
        this.body.emitter.emit('_resizeNodes');
        range = NetworkUtil.getRange(this.body.nodes, options.nodes);

        var xDistance = Math.abs(range.maxX - range.minX) * 1.1;
        var yDistance = Math.abs(range.maxY - range.minY) * 1.1;

        var xZoomLevel = this.canvas.frame.canvas.clientWidth / xDistance;
        var yZoomLevel = this.canvas.frame.canvas.clientHeight / yDistance;

        zoomLevel = xZoomLevel <= yZoomLevel ? xZoomLevel : yZoomLevel;
      }

      if (zoomLevel > 1.0) {
        zoomLevel = 1.0;
      } else if (zoomLevel === 0) {
        zoomLevel = 1.0;
      }

      var center = NetworkUtil.findCenter(range);
      var animationOptions = {
        position: center,
        scale: zoomLevel,
        animation: options.animation
      };
      this.moveTo(animationOptions);
    }

    // animation

    /**
     * Center a node in view.
     *
     * @param {number} nodeId
     * @param {number} [options]
     */

  }, {
    key: 'focus',
    value: function focus(nodeId) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this.body.nodes[nodeId] !== undefined) {
        var nodePosition = {
          x: this.body.nodes[nodeId].x,
          y: this.body.nodes[nodeId].y
        };
        options.position = nodePosition;
        options.lockedOnNode = nodeId;

        this.moveTo(options);
      } else {
        console.log('Node: ' + nodeId + ' cannot be found.');
      }
    }

    /**
     *
     * @param {Object} options  |  options.offset   = {x:number, y:number}   // offset from the center in DOM pixels
     *                          |  options.scale    = number                 // scale to move to
     *                          |  options.position = {x:number, y:number}   // position to move to
     *                          |  options.animation = {duration:number, easingFunction:String} || Boolean   // position to move to
     */

  }, {
    key: 'moveTo',
    value: function moveTo(options) {
      if (options === undefined) {
        options = {};
        return;
      }
      if (options.offset === undefined) {
        options.offset = { x: 0, y: 0 };
      }
      if (options.offset.x === undefined) {
        options.offset.x = 0;
      }
      if (options.offset.y === undefined) {
        options.offset.y = 0;
      }
      if (options.scale === undefined) {
        options.scale = this.body.view.scale;
      }
      if (options.position === undefined) {
        options.position = this.getViewPosition();
      }
      if (options.animation === undefined) {
        options.animation = { duration: 0 };
      }
      if (options.animation === false) {
        options.animation = { duration: 0 };
      }
      if (options.animation === true) {
        options.animation = {};
      }
      if (options.animation.duration === undefined) {
        options.animation.duration = 1000;
      } // default duration
      if (options.animation.easingFunction === undefined) {
        options.animation.easingFunction = 'easeInOutQuad';
      } // default easing function

      this.animateView(options);
    }

    /**
     *
     * @param {Object} options  |  options.offset   = {x:number, y:number}   // offset from the center in DOM pixels
     *                          |  options.time     = number                 // animation time in milliseconds
     *                          |  options.scale    = number                 // scale to animate to
     *                          |  options.position = {x:number, y:number}   // position to animate to
     *                          |  options.easingFunction = String           // linear, easeInQuad, easeOutQuad, easeInOutQuad,
     *                                                                       // easeInCubic, easeOutCubic, easeInOutCubic,
     *                                                                       // easeInQuart, easeOutQuart, easeInOutQuart,
     *                                                                       // easeInQuint, easeOutQuint, easeInOutQuint
     */

  }, {
    key: 'animateView',
    value: function animateView(options) {
      if (options === undefined) {
        return;
      }
      this.animationEasingFunction = options.animation.easingFunction;
      // release if something focussed on the node
      this.releaseNode();
      if (options.locked === true) {
        this.lockedOnNodeId = options.lockedOnNode;
        this.lockedOnNodeOffset = options.offset;
      }

      // forcefully complete the old animation if it was still running
      if (this.easingTime != 0) {
        this._transitionRedraw(true); // by setting easingtime to 1, we finish the animation.
      }

      this.sourceScale = this.body.view.scale;
      this.sourceTranslation = this.body.view.translation;
      this.targetScale = options.scale;

      // set the scale so the viewCenter is based on the correct zoom level. This is overridden in the transitionRedraw
      // but at least then we'll have the target transition
      this.body.view.scale = this.targetScale;
      var viewCenter = this.canvas.DOMtoCanvas({
        x: 0.5 * this.canvas.frame.canvas.clientWidth,
        y: 0.5 * this.canvas.frame.canvas.clientHeight
      });

      var distanceFromCenter = {
        // offset from view, distance view has to change by these x and y to center the node
        x: viewCenter.x - options.position.x,
        y: viewCenter.y - options.position.y
      };
      this.targetTranslation = {
        x: this.sourceTranslation.x + distanceFromCenter.x * this.targetScale + options.offset.x,
        y: this.sourceTranslation.y + distanceFromCenter.y * this.targetScale + options.offset.y

        // if the time is set to 0, don't do an animation
      };if (options.animation.duration === 0) {
        if (this.lockedOnNodeId != undefined) {
          this.viewFunction = this._lockedRedraw.bind(this);
          this.body.emitter.on('initRedraw', this.viewFunction);
        } else {
          this.body.view.scale = this.targetScale;
          this.body.view.translation = this.targetTranslation;
          this.body.emitter.emit('_requestRedraw');
        }
      } else {
        this.animationSpeed = 1 / (60 * options.animation.duration * 0.001) || 1 / 60; // 60 for 60 seconds, 0.001 for milli's
        this.animationEasingFunction = options.animation.easingFunction;

        this.viewFunction = this._transitionRedraw.bind(this);
        this.body.emitter.on('initRedraw', this.viewFunction);
        this.body.emitter.emit('_startRendering');
      }
    }

    /**
     * used to animate smoothly by hijacking the redraw function.
     * @private
     */

  }, {
    key: '_lockedRedraw',
    value: function _lockedRedraw() {
      var nodePosition = {
        x: this.body.nodes[this.lockedOnNodeId].x,
        y: this.body.nodes[this.lockedOnNodeId].y
      };
      var viewCenter = this.canvas.DOMtoCanvas({
        x: 0.5 * this.canvas.frame.canvas.clientWidth,
        y: 0.5 * this.canvas.frame.canvas.clientHeight
      });
      var distanceFromCenter = {
        // offset from view, distance view has to change by these x and y to center the node
        x: viewCenter.x - nodePosition.x,
        y: viewCenter.y - nodePosition.y
      };
      var sourceTranslation = this.body.view.translation;
      var targetTranslation = {
        x: sourceTranslation.x + distanceFromCenter.x * this.body.view.scale + this.lockedOnNodeOffset.x,
        y: sourceTranslation.y + distanceFromCenter.y * this.body.view.scale + this.lockedOnNodeOffset.y
      };

      this.body.view.translation = targetTranslation;
    }

    /**
     * Resets state of a locked on Node
     */

  }, {
    key: 'releaseNode',
    value: function releaseNode() {
      if (this.lockedOnNodeId !== undefined && this.viewFunction !== undefined) {
        this.body.emitter.off('initRedraw', this.viewFunction);
        this.lockedOnNodeId = undefined;
        this.lockedOnNodeOffset = undefined;
      }
    }

    /**
     * @param {boolean} [finished=false]
     * @private
     */

  }, {
    key: '_transitionRedraw',
    value: function _transitionRedraw() {
      var finished = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      this.easingTime += this.animationSpeed;
      this.easingTime = finished === true ? 1.0 : this.easingTime;

      var progress = util.easingFunctions[this.animationEasingFunction](this.easingTime);

      this.body.view.scale = this.sourceScale + (this.targetScale - this.sourceScale) * progress;
      this.body.view.translation = {
        x: this.sourceTranslation.x + (this.targetTranslation.x - this.sourceTranslation.x) * progress,
        y: this.sourceTranslation.y + (this.targetTranslation.y - this.sourceTranslation.y) * progress

        // cleanup
      };if (this.easingTime >= 1.0) {
        this.body.emitter.off('initRedraw', this.viewFunction);
        this.easingTime = 0;
        if (this.lockedOnNodeId != undefined) {
          this.viewFunction = this._lockedRedraw.bind(this);
          this.body.emitter.on('initRedraw', this.viewFunction);
        }
        this.body.emitter.emit('animationFinished');
      }
    }

    /**
     *
     * @returns {number}
     */

  }, {
    key: 'getScale',
    value: function getScale() {
      return this.body.view.scale;
    }

    /**
     *
     * @returns {{x: number, y: number}}
     */

  }, {
    key: 'getViewPosition',
    value: function getViewPosition() {
      return this.canvas.DOMtoCanvas({
        x: 0.5 * this.canvas.frame.canvas.clientWidth,
        y: 0.5 * this.canvas.frame.canvas.clientHeight
      });
    }
  }]);
  return View;
}();

exports['default'] = View;

/***/ }),
/* 183 */
/***/ (function(module, exports, __nested_webpack_require_1002183__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __nested_webpack_require_1002183__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_1002183__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var util = __nested_webpack_require_1002183__(2);
var NavigationHandler = __nested_webpack_require_1002183__(184)['default'];
var Popup = __nested_webpack_require_1002183__(185)['default'];

/**
 * Handler for interactions
 */

var InteractionHandler = function () {
  /**
   * @param {Object} body
   * @param {Canvas} canvas
   * @param {SelectionHandler} selectionHandler
   */
  function InteractionHandler(body, canvas, selectionHandler) {
    (0, _classCallCheck3['default'])(this, InteractionHandler);

    this.body = body;
    this.canvas = canvas;
    this.selectionHandler = selectionHandler;
    this.navigationHandler = new NavigationHandler(body, canvas);

    // bind the events from hammer to functions in this object
    this.body.eventListeners.onTap = this.onTap.bind(this);
    this.body.eventListeners.onTouch = this.onTouch.bind(this);
    this.body.eventListeners.onDoubleTap = this.onDoubleTap.bind(this);
    this.body.eventListeners.onHold = this.onHold.bind(this);
    this.body.eventListeners.onDragStart = this.onDragStart.bind(this);
    this.body.eventListeners.onDrag = this.onDrag.bind(this);
    this.body.eventListeners.onDragEnd = this.onDragEnd.bind(this);
    this.body.eventListeners.onMouseWheel = this.onMouseWheel.bind(this);
    this.body.eventListeners.onPinch = this.onPinch.bind(this);
    this.body.eventListeners.onMouseMove = this.onMouseMove.bind(this);
    this.body.eventListeners.onRelease = this.onRelease.bind(this);
    this.body.eventListeners.onContext = this.onContext.bind(this);

    this.touchTime = 0;
    this.drag = {};
    this.pinch = {};
    this.popup = undefined;
    this.popupObj = undefined;
    this.popupTimer = undefined;

    this.body.functions.getPointer = this.getPointer.bind(this);

    this.options = {};
    this.defaultOptions = {
      dragNodes: true,
      dragView: true,
      hover: false,
      keyboard: {
        enabled: false,
        speed: { x: 10, y: 10, zoom: 0.02 },
        bindToWindow: true
      },
      navigationButtons: false,
      tooltipDelay: 300,
      zoomView: true,
      zoomSpeed: 1
    };
    util.extend(this.options, this.defaultOptions);

    this.bindEventListeners();
  }

  /**
   * Binds event listeners
   */


  (0, _createClass3['default'])(InteractionHandler, [{
    key: 'bindEventListeners',
    value: function bindEventListeners() {
      var _this = this;

      this.body.emitter.on('destroy', function () {
        clearTimeout(_this.popupTimer);
        delete _this.body.functions.getPointer;
      });
    }

    /**
     *
     * @param {Object} options
     */

  }, {
    key: 'setOptions',
    value: function setOptions(options) {
      if (options !== undefined) {
        // extend all but the values in fields
        var fields = ['hideEdgesOnDrag', 'hideEdgesOnZoom', 'hideNodesOnDrag', 'keyboard', 'multiselect', 'selectable', 'selectConnectedEdges'];
        util.selectiveNotDeepExtend(fields, this.options, options);

        // merge the keyboard options in.
        util.mergeOptions(this.options, options, 'keyboard');

        if (options.tooltip) {
          util.extend(this.options.tooltip, options.tooltip);
          if (options.tooltip.color) {
            this.options.tooltip.color = util.parseColor(options.tooltip.color);
          }
        }
      }

      this.navigationHandler.setOptions(this.options);
    }

    /**
     * Get the pointer location from a touch location
     * @param {{x: number, y: number}} touch
     * @return {{x: number, y: number}} pointer
     * @private
     */

  }, {
    key: 'getPointer',
    value: function getPointer(touch) {
      return {
        x: touch.x - util.getAbsoluteLeft(this.canvas.frame.canvas),
        y: touch.y - util.getAbsoluteTop(this.canvas.frame.canvas)
      };
    }

    /**
     * On start of a touch gesture, store the pointer
     * @param {Event}  event   The event
     * @private
     */

  }, {
    key: 'onTouch',
    value: function onTouch(event) {
      if (new Date().valueOf() - this.touchTime > 50) {
        this.drag.pointer = this.getPointer(event.center);
        this.drag.pinched = false;
        this.pinch.scale = this.body.view.scale;
        // to avoid double fireing of this event because we have two hammer instances. (on canvas and on frame)
        this.touchTime = new Date().valueOf();
      }
    }

    /**
     * handle tap/click event: select/unselect a node
     * @param {Event} event
     * @private
     */

  }, {
    key: 'onTap',
    value: function onTap(event) {
      var pointer = this.getPointer(event.center);
      var multiselect = this.selectionHandler.options.multiselect && (event.changedPointers[0].ctrlKey || event.changedPointers[0].metaKey);

      this.checkSelectionChanges(pointer, event, multiselect);
      this.selectionHandler._generateClickEvent('click', event, pointer);
    }

    /**
     * handle doubletap event
     * @param {Event} event
     * @private
     */

  }, {
    key: 'onDoubleTap',
    value: function onDoubleTap(event) {
      var pointer = this.getPointer(event.center);
      this.selectionHandler._generateClickEvent('doubleClick', event, pointer);
    }

    /**
     * handle long tap event: multi select nodes
     * @param {Event} event
     * @private
     */

  }, {
    key: 'onHold',
    value: function onHold(event) {
      var pointer = this.getPointer(event.center);
      var multiselect = this.selectionHandler.options.multiselect;

      this.checkSelectionChanges(pointer, event, multiselect);

      this.selectionHandler._generateClickEvent('click', event, pointer);
      this.selectionHandler._generateClickEvent('hold', event, pointer);
    }

    /**
     * handle the release of the screen
     *
     * @param {Event} event
     * @private
     */

  }, {
    key: 'onRelease',
    value: function onRelease(event) {
      if (new Date().valueOf() - this.touchTime > 10) {
        var pointer = this.getPointer(event.center);
        this.selectionHandler._generateClickEvent('release', event, pointer);
        // to avoid double fireing of this event because we have two hammer instances. (on canvas and on frame)
        this.touchTime = new Date().valueOf();
      }
    }

    /**
     *
     * @param {Event} event
     */

  }, {
    key: 'onContext',
    value: function onContext(event) {
      var pointer = this.getPointer({ x: event.clientX, y: event.clientY });
      this.selectionHandler._generateClickEvent('oncontext', event, pointer);
    }

    /**
     * Select and deselect nodes depending current selection change.
     *
     * For changing nodes, select/deselect events are fired.
     *
     * NOTE: For a given edge, if one connecting node is deselected and with the same
     *       click the other node is selected, no events for the edge will fire.
     *       It was selected and it will remain selected.
     *
     * TODO: This is all SelectionHandler calls; the method should be moved to there.
     *
     * @param {{x: number, y: number}} pointer
     * @param {Event} event
     * @param {boolean} [add=false]
     */

  }, {
    key: 'checkSelectionChanges',
    value: function checkSelectionChanges(pointer, event) {
      var add = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var previousSelection = this.selectionHandler.getSelection();
      var selected = false;
      if (add === true) {
        selected = this.selectionHandler.selectAdditionalOnPoint(pointer);
      } else {
        selected = this.selectionHandler.selectOnPoint(pointer);
      }
      var currentSelection = this.selectionHandler.getSelection();

      // See NOTE in method comment for the reason to do it like this
      var deselectedItems = this._determineDifference(previousSelection, currentSelection);
      var selectedItems = this._determineDifference(currentSelection, previousSelection);

      if (deselectedItems.edges.length > 0) {
        this.selectionHandler._generateClickEvent('deselectEdge', event, pointer, previousSelection);
        selected = true;
      }

      if (deselectedItems.nodes.length > 0) {
        this.selectionHandler._generateClickEvent('deselectNode', event, pointer, previousSelection);
        selected = true;
      }

      if (selectedItems.nodes.length > 0) {
        this.selectionHandler._generateClickEvent('selectNode', event, pointer);
        selected = true;
      }

      if (selectedItems.edges.length > 0) {
        this.selectionHandler._generateClickEvent('selectEdge', event, pointer);
        selected = true;
      }

      // fire the select event if anything has been selected or deselected
      if (selected === true) {
        // select or unselect
        this.selectionHandler._generateClickEvent('select', event, pointer);
      }
    }

    /**
     * Remove all node and edge id's from the first set that are present in the second one.
     *
     * @param {{nodes: Array.<Node>, edges: Array.<vis.Edge>}} firstSet
     * @param {{nodes: Array.<Node>, edges: Array.<vis.Edge>}} secondSet
     * @returns {{nodes: Array.<Node>, edges: Array.<vis.Edge>}}
     * @private
     */

  }, {
    key: '_determineDifference',
    value: function _determineDifference(firstSet, secondSet) {
      var arrayDiff = function arrayDiff(firstArr, secondArr) {
        var result = [];

        for (var i = 0; i < firstArr.length; i++) {
          var value = firstArr[i];
          if (secondArr.indexOf(value) === -1) {
            result.push(value);
          }
        }

        return result;
      };

      return {
        nodes: arrayDiff(firstSet.nodes, secondSet.nodes),
        edges: arrayDiff(firstSet.edges, secondSet.edges)
      };
    }

    /**
     * This function is called by onDragStart.
     * It is separated out because we can then overload it for the datamanipulation system.
     *
     * @param {Event} event
     * @private
     */

  }, {
    key: 'onDragStart',
    value: function onDragStart(event) {
      //in case the touch event was triggered on an external div, do the initial touch now.
      if (this.drag.pointer === undefined) {
        this.onTouch(event);
      }

      // note: drag.pointer is set in onTouch to get the initial touch location
      var node = this.selectionHandler.getNodeAt(this.drag.pointer);

      this.drag.dragging = true;
      this.drag.selection = [];
      this.drag.translation = util.extend({}, this.body.view.translation); // copy the object
      this.drag.nodeId = undefined;

      if (node !== undefined && this.options.dragNodes === true) {
        this.drag.nodeId = node.id;
        // select the clicked node if not yet selected
        if (node.isSelected() === false) {
          this.selectionHandler.unselectAll();
          this.selectionHandler.selectObject(node);
        }

        // after select to contain the node
        this.selectionHandler._generateClickEvent('dragStart', event, this.drag.pointer);

        var selection = this.selectionHandler.selectionObj.nodes;
        // create an array with the selected nodes and their original location and status
        for (var nodeId in selection) {
          if (selection.hasOwnProperty(nodeId)) {
            var object = selection[nodeId];
            var s = {
              id: object.id,
              node: object,

              // store original x, y, xFixed and yFixed, make the node temporarily Fixed
              x: object.x,
              y: object.y,
              xFixed: object.options.fixed.x,
              yFixed: object.options.fixed.y
            };

            object.options.fixed.x = true;
            object.options.fixed.y = true;

            this.drag.selection.push(s);
          }
        }
      } else {
        // fallback if no node is selected and thus the view is dragged.
        this.selectionHandler._generateClickEvent('dragStart', event, this.drag.pointer, undefined, true);
      }
    }

    /**
     * handle drag event
     * @param {Event} event
     * @private
     */

  }, {
    key: 'onDrag',
    value: function onDrag(event) {
      var _this2 = this;

      if (this.drag.pinched === true) {
        return;
      }

      // remove the focus on node if it is focussed on by the focusOnNode
      this.body.emitter.emit('unlockNode');

      var pointer = this.getPointer(event.center);

      var selection = this.drag.selection;
      if (selection && selection.length && this.options.dragNodes === true) {
        this.selectionHandler._generateClickEvent('dragging', event, pointer);

        // calculate delta's and new location
        var deltaX = pointer.x - this.drag.pointer.x;
        var deltaY = pointer.y - this.drag.pointer.y;

        // update position of all selected nodes
        selection.forEach(function (selection) {
          var node = selection.node;
          // only move the node if it was not fixed initially
          if (selection.xFixed === false) {
            node.x = _this2.canvas._XconvertDOMtoCanvas(_this2.canvas._XconvertCanvasToDOM(selection.x) + deltaX);
          }
          // only move the node if it was not fixed initially
          if (selection.yFixed === false) {
            node.y = _this2.canvas._YconvertDOMtoCanvas(_this2.canvas._YconvertCanvasToDOM(selection.y) + deltaY);
          }
        });

        // start the simulation of the physics
        this.body.emitter.emit('startSimulation');
      } else {
        // move the network
        if (this.options.dragView === true) {
          this.selectionHandler._generateClickEvent('dragging', event, pointer, undefined, true);

          // if the drag was not started properly because the click started outside the network div, start it now.
          if (this.drag.pointer === undefined) {
            this.onDragStart(event);
            return;
          }
          var diffX = pointer.x - this.drag.pointer.x;
          var diffY = pointer.y - this.drag.pointer.y;

          this.body.view.translation = {
            x: this.drag.translation.x + diffX,
            y: this.drag.translation.y + diffY
          };
          this.body.emitter.emit('_requestRedraw');
        }
      }
    }

    /**
     * handle drag start event
     * @param {Event} event
     * @private
     */

  }, {
    key: 'onDragEnd',
    value: function onDragEnd(event) {
      this.drag.dragging = false;
      var selection = this.drag.selection;
      if (selection && selection.length) {
        selection.forEach(function (s) {
          // restore original xFixed and yFixed
          s.node.options.fixed.x = s.xFixed;
          s.node.options.fixed.y = s.yFixed;
        });
        this.selectionHandler._generateClickEvent('dragEnd', event, this.getPointer(event.center));
        this.body.emitter.emit('startSimulation');
      } else {
        this.selectionHandler._generateClickEvent('dragEnd', event, this.getPointer(event.center), undefined, true);
        this.body.emitter.emit('_requestRedraw');
      }
    }

    /**
     * Handle pinch event
     * @param {Event}  event   The event
     * @private
     */

  }, {
    key: 'onPinch',
    value: function onPinch(event) {
      var pointer = this.getPointer(event.center);

      this.drag.pinched = true;
      if (this.pinch['scale'] === undefined) {
        this.pinch.scale = 1;
      }

      // TODO: enabled moving while pinching?
      var scale = this.pinch.scale * event.scale;
      this.zoom(scale, pointer);
    }

    /**
     * Zoom the network in or out
     * @param {number} scale a number around 1, and between 0.01 and 10
     * @param {{x: number, y: number}} pointer    Position on screen
     * @private
     */

  }, {
    key: 'zoom',
    value: function zoom(scale, pointer) {
      if (this.options.zoomView === true) {
        var scaleOld = this.body.view.scale;
        if (scale < 0.00001) {
          scale = 0.00001;
        }
        if (scale > 10) {
          scale = 10;
        }

        var preScaleDragPointer = undefined;
        if (this.drag !== undefined) {
          if (this.drag.dragging === true) {
            preScaleDragPointer = this.canvas.DOMtoCanvas(this.drag.pointer);
          }
        }
        // + this.canvas.frame.canvas.clientHeight / 2
        var translation = this.body.view.translation;

        var scaleFrac = scale / scaleOld;
        var tx = (1 - scaleFrac) * pointer.x + translation.x * scaleFrac;
        var ty = (1 - scaleFrac) * pointer.y + translation.y * scaleFrac;

        this.body.view.scale = scale;
        this.body.view.translation = { x: tx, y: ty };

        if (preScaleDragPointer != undefined) {
          var postScaleDragPointer = this.canvas.canvasToDOM(preScaleDragPointer);
          this.drag.pointer.x = postScaleDragPointer.x;
          this.drag.pointer.y = postScaleDragPointer.y;
        }

        this.body.emitter.emit('_requestRedraw');

        if (scaleOld < scale) {
          this.body.emitter.emit('zoom', {
            direction: '+',
            scale: this.body.view.scale,
            pointer: pointer
          });
        } else {
          this.body.emitter.emit('zoom', {
            direction: '-',
            scale: this.body.view.scale,
            pointer: pointer
          });
        }
      }
    }

    /**
     * Event handler for mouse wheel event, used to zoom the timeline
     * See http://adomas.org/javascript-mouse-wheel/
     *     https://github.com/EightMedia/hammer.js/issues/256
     * @param {MouseEvent}  event
     * @private
     */

  }, {
    key: 'onMouseWheel',
    value: function onMouseWheel(event) {
      if (this.options.zoomView === true) {
        // retrieve delta
        var delta = 0;
        if (event.wheelDelta) {
          /* IE/Opera. */
          delta = event.wheelDelta / 120;
        } else if (event.detail) {
          /* Mozilla case. */
          // In Mozilla, sign of delta is different than in IE.
          // Also, delta is multiple of 3.
          delta = -event.detail / 3;
        }

        // If delta is nonzero, handle it.
        // Basically, delta is now positive if wheel was scrolled up,
        // and negative, if wheel was scrolled down.
        if (delta !== 0) {
          // calculate the new scale
          var scale = this.body.view.scale;
          var zoom = delta * (this.options.zoomSpeed / 10);
          if (delta < 0) {
            zoom = zoom / (1 - zoom);
          }
          scale *= 1 + zoom;

          // calculate the pointer location
          var pointer = this.getPointer({ x: event.clientX, y: event.clientY });

          // apply the new scale
          this.zoom(scale, pointer);
        }

        // Prevent default actions caused by mouse wheel.
        event.preventDefault();
      }
    }

    /**
     * Mouse move handler for checking whether the title moves over a node with a title.
     * @param  {Event} event
     * @private
     */

  }, {
    key: 'onMouseMove',
    value: function onMouseMove(event) {
      var _this3 = this;

      var pointer = this.getPointer({ x: event.clientX, y: event.clientY });
      var popupVisible = false;

      // check if the previously selected node is still selected
      if (this.popup !== undefined) {
        if (this.popup.hidden === false) {
          this._checkHidePopup(pointer);
        }

        // if the popup was not hidden above
        if (this.popup.hidden === false) {
          popupVisible = true;
          this.popup.setPosition(pointer.x + 3, pointer.y - 5);
          this.popup.show();
        }
      }

      // if we bind the keyboard to the div, we have to highlight it to use it. This highlights it on mouse over.
      if (this.options.keyboard.bindToWindow === false && this.options.keyboard.enabled === true) {
        this.canvas.frame.focus();
      }

      // start a timeout that will check if the mouse is positioned above an element
      if (popupVisible === false) {
        if (this.popupTimer !== undefined) {
          clearInterval(this.popupTimer); // stop any running calculationTimer
          this.popupTimer = undefined;
        }
        if (!this.drag.dragging) {
          this.popupTimer = setTimeout(function () {
            return _this3._checkShowPopup(pointer);
          }, this.options.tooltipDelay);
        }
      }

      // adding hover highlights
      if (this.options.hover === true) {
        this.selectionHandler.hoverObject(event, pointer);
      }
    }

    /**
     * Check if there is an element on the given position in the network
     * (a node or edge). If so, and if this element has a title,
     * show a popup window with its title.
     *
     * @param {{x:number, y:number}} pointer
     * @private
     */

  }, {
    key: '_checkShowPopup',
    value: function _checkShowPopup(pointer) {
      var x = this.canvas._XconvertDOMtoCanvas(pointer.x);
      var y = this.canvas._YconvertDOMtoCanvas(pointer.y);
      var pointerObj = {
        left: x,
        top: y,
        right: x,
        bottom: y
      };

      var previousPopupObjId = this.popupObj === undefined ? undefined : this.popupObj.id;
      var nodeUnderCursor = false;
      var popupType = 'node';

      // check if a node is under the cursor.
      if (this.popupObj === undefined) {
        // search the nodes for overlap, select the top one in case of multiple nodes
        var nodeIndices = this.body.nodeIndices;
        var nodes = this.body.nodes;
        var node = void 0;
        var overlappingNodes = [];
        for (var i = 0; i < nodeIndices.length; i++) {
          node = nodes[nodeIndices[i]];
          if (node.isOverlappingWith(pointerObj) === true) {
            nodeUnderCursor = true;
            if (node.getTitle() !== undefined) {
              overlappingNodes.push(nodeIndices[i]);
            }
          }
        }

        if (overlappingNodes.length > 0) {
          // if there are overlapping nodes, select the last one, this is the one which is drawn on top of the others
          this.popupObj = nodes[overlappingNodes[overlappingNodes.length - 1]];
          // if you hover over a node, the title of the edge is not supposed to be shown.
          nodeUnderCursor = true;
        }
      }

      if (this.popupObj === undefined && nodeUnderCursor === false) {
        // search the edges for overlap
        var edgeIndices = this.body.edgeIndices;
        var edges = this.body.edges;
        var edge = void 0;
        var overlappingEdges = [];
        for (var _i = 0; _i < edgeIndices.length; _i++) {
          edge = edges[edgeIndices[_i]];
          if (edge.isOverlappingWith(pointerObj) === true) {
            if (edge.connected === true && edge.getTitle() !== undefined) {
              overlappingEdges.push(edgeIndices[_i]);
            }
          }
        }

        if (overlappingEdges.length > 0) {
          this.popupObj = edges[overlappingEdges[overlappingEdges.length - 1]];
          popupType = 'edge';
        }
      }

      if (this.popupObj !== undefined) {
        // show popup message window
        if (this.popupObj.id !== previousPopupObjId) {
          if (this.popup === undefined) {
            this.popup = new Popup(this.canvas.frame);
          }

          this.popup.popupTargetType = popupType;
          this.popup.popupTargetId = this.popupObj.id;

          // adjust a small offset such that the mouse cursor is located in the
          // bottom left location of the popup, and you can easily move over the
          // popup area
          this.popup.setPosition(pointer.x + 3, pointer.y - 5);
          this.popup.setText(this.popupObj.getTitle());
          this.popup.show();
          this.body.emitter.emit('showPopup', this.popupObj.id);
        }
      } else {
        if (this.popup !== undefined) {
          this.popup.hide();
          this.body.emitter.emit('hidePopup');
        }
      }
    }

    /**
     * Check if the popup must be hidden, which is the case when the mouse is no
     * longer hovering on the object
     * @param {{x:number, y:number}} pointer
     * @private
     */

  }, {
    key: '_checkHidePopup',
    value: function _checkHidePopup(pointer) {
      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);

      var stillOnObj = false;
      if (this.popup.popupTargetType === 'node') {
        if (this.body.nodes[this.popup.popupTargetId] !== undefined) {
          stillOnObj = this.body.nodes[this.popup.popupTargetId].isOverlappingWith(pointerObj);

          // if the mouse is still one the node, we have to check if it is not also on one that is drawn on top of it.
          // we initially only check stillOnObj because this is much faster.
          if (stillOnObj === true) {
            var overNode = this.selectionHandler.getNodeAt(pointer);
            stillOnObj = overNode === undefined ? false : overNode.id === this.popup.popupTargetId;
          }
        }
      } else {
        if (this.selectionHandler.getNodeAt(pointer) === undefined) {
          if (this.body.edges[this.popup.popupTargetId] !== undefined) {
            stillOnObj = this.body.edges[this.popup.popupTargetId].isOverlappingWith(pointerObj);
          }
        }
      }

      if (stillOnObj === false) {
        this.popupObj = undefined;
        this.popup.hide();
        this.body.emitter.emit('hidePopup');
      }
    }
  }]);
  return InteractionHandler;
}();

exports['default'] = InteractionHandler;

/***/ }),
/* 184 */
/***/ (function(module, exports, __nested_webpack_require_1028063__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __nested_webpack_require_1028063__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_1028063__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var Hammer = __nested_webpack_require_1028063__(24);
var hammerUtil = __nested_webpack_require_1028063__(36);
var keycharm = __nested_webpack_require_1028063__(52);

/**
 * Navigation Handler
 */

var NavigationHandler = function () {
  /**
   * @param {Object} body
   * @param {Canvas} canvas
   */
  function NavigationHandler(body, canvas) {
    var _this = this;

    (0, _classCallCheck3['default'])(this, NavigationHandler);

    this.body = body;
    this.canvas = canvas;

    this.iconsCreated = false;
    this.navigationHammers = [];
    this.boundFunctions = {};
    this.touchTime = 0;
    this.activated = false;

    this.body.emitter.on('activate', function () {
      _this.activated = true;
      _this.configureKeyboardBindings();
    });
    this.body.emitter.on('deactivate', function () {
      _this.activated = false;
      _this.configureKeyboardBindings();
    });
    this.body.emitter.on('destroy', function () {
      if (_this.keycharm !== undefined) {
        _this.keycharm.destroy();
      }
    });

    this.options = {};
  }

  /**
   *
   * @param {Object} options
   */


  (0, _createClass3['default'])(NavigationHandler, [{
    key: 'setOptions',
    value: function setOptions(options) {
      if (options !== undefined) {
        this.options = options;
        this.create();
      }
    }

    /**
     * Creates or refreshes navigation and sets key bindings
     */

  }, {
    key: 'create',
    value: function create() {
      if (this.options.navigationButtons === true) {
        if (this.iconsCreated === false) {
          this.loadNavigationElements();
        }
      } else if (this.iconsCreated === true) {
        this.cleanNavigation();
      }

      this.configureKeyboardBindings();
    }

    /**
     * Cleans up previous navigation items
     */

  }, {
    key: 'cleanNavigation',
    value: function cleanNavigation() {
      // clean hammer bindings
      if (this.navigationHammers.length != 0) {
        for (var i = 0; i < this.navigationHammers.length; i++) {
          this.navigationHammers[i].destroy();
        }
        this.navigationHammers = [];
      }

      // clean up previous navigation items
      if (this.navigationDOM && this.navigationDOM['wrapper'] && this.navigationDOM['wrapper'].parentNode) {
        this.navigationDOM['wrapper'].parentNode.removeChild(this.navigationDOM['wrapper']);
      }

      this.iconsCreated = false;
    }

    /**
     * Creation of the navigation controls nodes. They are drawn over the rest of the nodes and are not affected by scale and translation
     * they have a triggerFunction which is called on click. If the position of the navigation controls is dependent
     * on this.frame.canvas.clientWidth or this.frame.canvas.clientHeight, we flag horizontalAlignLeft and verticalAlignTop false.
     * This means that the location will be corrected by the _relocateNavigation function on a size change of the canvas.
     *
     * @private
     */

  }, {
    key: 'loadNavigationElements',
    value: function loadNavigationElements() {
      var _this2 = this;

      this.cleanNavigation();

      this.navigationDOM = {};
      var navigationDivs = ['up', 'down', 'left', 'right', 'zoomIn', 'zoomOut', 'zoomExtends'];
      var navigationDivActions = ['_moveUp', '_moveDown', '_moveLeft', '_moveRight', '_zoomIn', '_zoomOut', '_fit'];

      this.navigationDOM['wrapper'] = document.createElement('div');
      this.navigationDOM['wrapper'].className = 'vis-navigation';
      this.canvas.frame.appendChild(this.navigationDOM['wrapper']);

      for (var i = 0; i < navigationDivs.length; i++) {
        this.navigationDOM[navigationDivs[i]] = document.createElement('div');
        this.navigationDOM[navigationDivs[i]].className = 'vis-button vis-' + navigationDivs[i];
        this.navigationDOM['wrapper'].appendChild(this.navigationDOM[navigationDivs[i]]);

        var hammer = new Hammer(this.navigationDOM[navigationDivs[i]]);
        if (navigationDivActions[i] === '_fit') {
          hammerUtil.onTouch(hammer, this._fit.bind(this));
        } else {
          hammerUtil.onTouch(hammer, this.bindToRedraw.bind(this, navigationDivActions[i]));
        }

        this.navigationHammers.push(hammer);
      }

      // use a hammer for the release so we do not require the one used in the rest of the network
      // the one the rest uses can be overloaded by the manipulation system.
      var hammerFrame = new Hammer(this.canvas.frame);
      hammerUtil.onRelease(hammerFrame, function () {
        _this2._stopMovement();
      });
      this.navigationHammers.push(hammerFrame);

      this.iconsCreated = true;
    }

    /**
     *
     * @param {string} action
     */

  }, {
    key: 'bindToRedraw',
    value: function bindToRedraw(action) {
      if (this.boundFunctions[action] === undefined) {
        this.boundFunctions[action] = this[action].bind(this);
        this.body.emitter.on('initRedraw', this.boundFunctions[action]);
        this.body.emitter.emit('_startRendering');
      }
    }

    /**
     *
     * @param {string} action
     */

  }, {
    key: 'unbindFromRedraw',
    value: function unbindFromRedraw(action) {
      if (this.boundFunctions[action] !== undefined) {
        this.body.emitter.off('initRedraw', this.boundFunctions[action]);
        this.body.emitter.emit('_stopRendering');
        delete this.boundFunctions[action];
      }
    }

    /**
     * this stops all movement induced by the navigation buttons
     *
     * @private
     */

  }, {
    key: '_fit',
    value: function _fit() {
      if (new Date().valueOf() - this.touchTime > 700) {
        // TODO: fix ugly hack to avoid hammer's double fireing of event (because we use release?)
        this.body.emitter.emit('fit', { duration: 700 });
        this.touchTime = new Date().valueOf();
      }
    }

    /**
     * this stops all movement induced by the navigation buttons
     *
     * @private
     */

  }, {
    key: '_stopMovement',
    value: function _stopMovement() {
      for (var boundAction in this.boundFunctions) {
        if (this.boundFunctions.hasOwnProperty(boundAction)) {
          this.body.emitter.off('initRedraw', this.boundFunctions[boundAction]);
          this.body.emitter.emit('_stopRendering');
        }
      }
      this.boundFunctions = {};
    }
    /**
     *
     * @private
     */

  }, {
    key: '_moveUp',
    value: function _moveUp() {
      this.body.view.translation.y += this.options.keyboard.speed.y;
    }
    /**
     *
     * @private
     */

  }, {
    key: '_moveDown',
    value: function _moveDown() {
      this.body.view.translation.y -= this.options.keyboard.speed.y;
    }
    /**
     *
     * @private
     */

  }, {
    key: '_moveLeft',
    value: function _moveLeft() {
      this.body.view.translation.x += this.options.keyboard.speed.x;
    }
    /**
     *
     * @private
     */

  }, {
    key: '_moveRight',
    value: function _moveRight() {
      this.body.view.translation.x -= this.options.keyboard.speed.x;
    }
    /**
     *
     * @private
     */

  }, {
    key: '_zoomIn',
    value: function _zoomIn() {
      var scaleOld = this.body.view.scale;
      var scale = this.body.view.scale * (1 + this.options.keyboard.speed.zoom);
      var translation = this.body.view.translation;
      var scaleFrac = scale / scaleOld;
      var tx = (1 - scaleFrac) * this.canvas.canvasViewCenter.x + translation.x * scaleFrac;
      var ty = (1 - scaleFrac) * this.canvas.canvasViewCenter.y + translation.y * scaleFrac;

      this.body.view.scale = scale;
      this.body.view.translation = { x: tx, y: ty };
      this.body.emitter.emit('zoom', {
        direction: '+',
        scale: this.body.view.scale,
        pointer: null
      });
    }

    /**
     *
     * @private
     */

  }, {
    key: '_zoomOut',
    value: function _zoomOut() {
      var scaleOld = this.body.view.scale;
      var scale = this.body.view.scale / (1 + this.options.keyboard.speed.zoom);
      var translation = this.body.view.translation;
      var scaleFrac = scale / scaleOld;
      var tx = (1 - scaleFrac) * this.canvas.canvasViewCenter.x + translation.x * scaleFrac;
      var ty = (1 - scaleFrac) * this.canvas.canvasViewCenter.y + translation.y * scaleFrac;

      this.body.view.scale = scale;
      this.body.view.translation = { x: tx, y: ty };
      this.body.emitter.emit('zoom', {
        direction: '-',
        scale: this.body.view.scale,
        pointer: null
      });
    }

    /**
     * bind all keys using keycharm.
     */

  }, {
    key: 'configureKeyboardBindings',
    value: function configureKeyboardBindings() {
      var _this3 = this;

      if (this.keycharm !== undefined) {
        this.keycharm.destroy();
      }

      if (this.options.keyboard.enabled === true) {
        if (this.options.keyboard.bindToWindow === true) {
          this.keycharm = keycharm({ container: window, preventDefault: true });
        } else {
          this.keycharm = keycharm({
            container: this.canvas.frame,
            preventDefault: true
          });
        }

        this.keycharm.reset();

        if (this.activated === true) {
          this.keycharm.bind('up', function () {
            _this3.bindToRedraw('_moveUp');
          }, 'keydown');
          this.keycharm.bind('down', function () {
            _this3.bindToRedraw('_moveDown');
          }, 'keydown');
          this.keycharm.bind('left', function () {
            _this3.bindToRedraw('_moveLeft');
          }, 'keydown');
          this.keycharm.bind('right', function () {
            _this3.bindToRedraw('_moveRight');
          }, 'keydown');
          this.keycharm.bind('=', function () {
            _this3.bindToRedraw('_zoomIn');
          }, 'keydown');
          this.keycharm.bind('num+', function () {
            _this3.bindToRedraw('_zoomIn');
          }, 'keydown');
          this.keycharm.bind('num-', function () {
            _this3.bindToRedraw('_zoomOut');
          }, 'keydown');
          this.keycharm.bind('-', function () {
            _this3.bindToRedraw('_zoomOut');
          }, 'keydown');
          this.keycharm.bind('[', function () {
            _this3.bindToRedraw('_zoomOut');
          }, 'keydown');
          this.keycharm.bind(']', function () {
            _this3.bindToRedraw('_zoomIn');
          }, 'keydown');
          this.keycharm.bind('pageup', function () {
            _this3.bindToRedraw('_zoomIn');
          }, 'keydown');
          this.keycharm.bind('pagedown', function () {
            _this3.bindToRedraw('_zoomOut');
          }, 'keydown');

          this.keycharm.bind('up', function () {
            _this3.unbindFromRedraw('_moveUp');
          }, 'keyup');
          this.keycharm.bind('down', function () {
            _this3.unbindFromRedraw('_moveDown');
          }, 'keyup');
          this.keycharm.bind('left', function () {
            _this3.unbindFromRedraw('_moveLeft');
          }, 'keyup');
          this.keycharm.bind('right', function () {
            _this3.unbindFromRedraw('_moveRight');
          }, 'keyup');
          this.keycharm.bind('=', function () {
            _this3.unbindFromRedraw('_zoomIn');
          }, 'keyup');
          this.keycharm.bind('num+', function () {
            _this3.unbindFromRedraw('_zoomIn');
          }, 'keyup');
          this.keycharm.bind('num-', function () {
            _this3.unbindFromRedraw('_zoomOut');
          }, 'keyup');
          this.keycharm.bind('-', function () {
            _this3.unbindFromRedraw('_zoomOut');
          }, 'keyup');
          this.keycharm.bind('[', function () {
            _this3.unbindFromRedraw('_zoomOut');
          }, 'keyup');
          this.keycharm.bind(']', function () {
            _this3.unbindFromRedraw('_zoomIn');
          }, 'keyup');
          this.keycharm.bind('pageup', function () {
            _this3.unbindFromRedraw('_zoomIn');
          }, 'keyup');
          this.keycharm.bind('pagedown', function () {
            _this3.unbindFromRedraw('_zoomOut');
          }, 'keyup');
        }
      }
    }
  }]);
  return NavigationHandler;
}();

exports['default'] = NavigationHandler;

/***/ }),
/* 185 */
/***/ (function(module, exports, __nested_webpack_require_1040705__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __nested_webpack_require_1040705__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_1040705__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * Popup is a class to create a popup window with some text
 */
var Popup = function () {
  /**
   * @param {Element} container       The container object.
   * @param {string}  overflowMethod  How the popup should act to overflowing ('flip' or 'cap')
   */
  function Popup(container, overflowMethod) {
    (0, _classCallCheck3['default'])(this, Popup);

    this.container = container;
    this.overflowMethod = overflowMethod || 'cap';

    this.x = 0;
    this.y = 0;
    this.padding = 5;
    this.hidden = false;

    // create the frame
    this.frame = document.createElement('div');
    this.frame.className = 'vis-tooltip';
    this.container.appendChild(this.frame);
  }

  /**
   * @param {number} x   Horizontal position of the popup window
   * @param {number} y   Vertical position of the popup window
   */


  (0, _createClass3['default'])(Popup, [{
    key: 'setPosition',
    value: function setPosition(x, y) {
      this.x = parseInt(x);
      this.y = parseInt(y);
    }

    /**
     * Set the content for the popup window. This can be HTML code or text.
     * @param {string | Element} content
     */

  }, {
    key: 'setText',
    value: function setText(content) {
      if (content instanceof Element) {
        this.frame.innerHTML = '';
        this.frame.appendChild(content);
      } else {
        this.frame.innerHTML = content; // string containing text or HTML
      }
    }

    /**
     * Show the popup window
     * @param {boolean} [doShow]    Show or hide the window
     */

  }, {
    key: 'show',
    value: function show(doShow) {
      if (doShow === undefined) {
        doShow = true;
      }

      if (doShow === true) {
        var height = this.frame.clientHeight;
        var width = this.frame.clientWidth;
        var maxHeight = this.frame.parentNode.clientHeight;
        var maxWidth = this.frame.parentNode.clientWidth;

        var left = 0,
            top = 0;

        if (this.overflowMethod == 'flip') {
          var isLeft = false,
              isTop = true; // Where around the position it's located

          if (this.y - height < this.padding) {
            isTop = false;
          }

          if (this.x + width > maxWidth - this.padding) {
            isLeft = true;
          }

          if (isLeft) {
            left = this.x - width;
          } else {
            left = this.x;
          }

          if (isTop) {
            top = this.y - height;
          } else {
            top = this.y;
          }
        } else {
          top = this.y - height;
          if (top + height + this.padding > maxHeight) {
            top = maxHeight - height - this.padding;
          }
          if (top < this.padding) {
            top = this.padding;
          }

          left = this.x;
          if (left + width + this.padding > maxWidth) {
            left = maxWidth - width - this.padding;
          }
          if (left < this.padding) {
            left = this.padding;
          }
        }

        this.frame.style.left = left + 'px';
        this.frame.style.top = top + 'px';
        this.frame.style.visibility = 'visible';
        this.hidden = false;
      } else {
        this.hide();
      }
    }

    /**
     * Hide the popup window
     */

  }, {
    key: 'hide',
    value: function hide() {
      this.hidden = true;
      this.frame.style.left = '0';
      this.frame.style.top = '0';
      this.frame.style.visibility = 'hidden';
    }

    /**
     * Remove the popup window
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      this.frame.parentNode.removeChild(this.frame); // Remove element from DOM
    }
  }]);
  return Popup;
}();

exports['default'] = Popup;

/***/ }),
/* 186 */
/***/ (function(module, exports, __nested_webpack_require_1044884__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __nested_webpack_require_1044884__(9);

var _keys2 = _interopRequireDefault(_keys);

var _classCallCheck2 = __nested_webpack_require_1044884__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_1044884__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var Node = __nested_webpack_require_1044884__(34)['default'];
var Edge = __nested_webpack_require_1044884__(55)['default'];

var util = __nested_webpack_require_1044884__(2);

/**
 * The handler for selections
 */

var SelectionHandler = function () {
  /**
   * @param {Object} body
   * @param {Canvas} canvas
   */
  function SelectionHandler(body, canvas) {
    var _this = this;

    (0, _classCallCheck3['default'])(this, SelectionHandler);

    this.body = body;
    this.canvas = canvas;
    this.selectionObj = { nodes: [], edges: [] };
    this.hoverObj = { nodes: {}, edges: {} };

    this.options = {};
    this.defaultOptions = {
      multiselect: false,
      selectable: true,
      selectConnectedEdges: true,
      hoverConnectedEdges: true
    };
    util.extend(this.options, this.defaultOptions);

    this.body.emitter.on('_dataChanged', function () {
      _this.updateSelection();
    });
  }

  /**
   *
   * @param {Object} [options]
   */


  (0, _createClass3['default'])(SelectionHandler, [{
    key: 'setOptions',
    value: function setOptions(options) {
      if (options !== undefined) {
        var fields = ['multiselect', 'hoverConnectedEdges', 'selectable', 'selectConnectedEdges'];
        util.selectiveDeepExtend(fields, this.options, options);
      }
    }

    /**
     * handles the selection part of the tap;
     *
     * @param {{x: number, y: number}} pointer
     * @returns {boolean}
     */

  }, {
    key: 'selectOnPoint',
    value: function selectOnPoint(pointer) {
      var selected = false;
      if (this.options.selectable === true) {
        var obj = this.getNodeAt(pointer) || this.getEdgeAt(pointer);

        // unselect after getting the objects in order to restore width and height.
        this.unselectAll();

        if (obj !== undefined) {
          selected = this.selectObject(obj);
        }
        this.body.emitter.emit('_requestRedraw');
      }
      return selected;
    }

    /**
     *
     * @param {{x: number, y: number}} pointer
     * @returns {boolean}
     */

  }, {
    key: 'selectAdditionalOnPoint',
    value: function selectAdditionalOnPoint(pointer) {
      var selectionChanged = false;
      if (this.options.selectable === true) {
        var obj = this.getNodeAt(pointer) || this.getEdgeAt(pointer);

        if (obj !== undefined) {
          selectionChanged = true;
          if (obj.isSelected() === true) {
            this.deselectObject(obj);
          } else {
            this.selectObject(obj);
          }

          this.body.emitter.emit('_requestRedraw');
        }
      }
      return selectionChanged;
    }

    /**
     * Create an object containing the standard fields for an event.
     *
     * @param {Event} event
     * @param {{x: number, y: number}} pointer Object with the x and y screen coordinates of the mouse
     * @returns {{}}
     * @private
     */

  }, {
    key: '_initBaseEvent',
    value: function _initBaseEvent(event, pointer) {
      var properties = {};

      properties['pointer'] = {
        DOM: { x: pointer.x, y: pointer.y },
        canvas: this.canvas.DOMtoCanvas(pointer)
      };
      properties['event'] = event;

      return properties;
    }

    /**
     * Generate an event which the user can catch.
     *
     * This adds some extra data to the event with respect to cursor position and
     * selected nodes and edges.
     *
     * @param {string} eventType                          Name of event to send
     * @param {Event}  event
     * @param {{x: number, y: number}} pointer            Object with the x and y screen coordinates of the mouse
     * @param {Object|undefined} oldSelection             If present, selection state before event occured
     * @param {boolean|undefined} [emptySelection=false]  Indicate if selection data should be passed
     */

  }, {
    key: '_generateClickEvent',
    value: function _generateClickEvent(eventType, event, pointer, oldSelection) {
      var emptySelection = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

      var properties = this._initBaseEvent(event, pointer);

      if (emptySelection === true) {
        properties.nodes = [];
        properties.edges = [];
      } else {
        var tmp = this.getSelection();
        properties.nodes = tmp.nodes;
        properties.edges = tmp.edges;
      }

      if (oldSelection !== undefined) {
        properties['previousSelection'] = oldSelection;
      }

      if (eventType == 'click') {
        // For the time being, restrict this functionality to
        // just the click event.
        properties.items = this.getClickedItems(pointer);
      }

      if (event.controlEdge !== undefined) {
        properties.controlEdge = event.controlEdge;
      }

      this.body.emitter.emit(eventType, properties);
    }

    /**
     *
     * @param {Object} obj
     * @param {boolean} [highlightEdges=this.options.selectConnectedEdges]
     * @returns {boolean}
     */

  }, {
    key: 'selectObject',
    value: function selectObject(obj) {
      var highlightEdges = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.options.selectConnectedEdges;

      if (obj !== undefined) {
        if (obj instanceof Node) {
          if (highlightEdges === true) {
            this._selectConnectedEdges(obj);
          }
        }
        obj.select();
        this._addToSelection(obj);
        return true;
      }
      return false;
    }

    /**
     *
     * @param {Object} obj
     */

  }, {
    key: 'deselectObject',
    value: function deselectObject(obj) {
      if (obj.isSelected() === true) {
        obj.selected = false;
        this._removeFromSelection(obj);
      }
    }

    /**
     * retrieve all nodes overlapping with given object
     * @param {Object} object  An object with parameters left, top, right, bottom
     * @return {number[]}   An array with id's of the overlapping nodes
     * @private
     */

  }, {
    key: '_getAllNodesOverlappingWith',
    value: function _getAllNodesOverlappingWith(object) {
      var overlappingNodes = [];
      var nodes = this.body.nodes;
      for (var i = 0; i < this.body.nodeIndices.length; i++) {
        var nodeId = this.body.nodeIndices[i];
        if (nodes[nodeId].isOverlappingWith(object)) {
          overlappingNodes.push(nodeId);
        }
      }
      return overlappingNodes;
    }

    /**
     * Return a position object in canvasspace from a single point in screenspace
     *
     * @param {{x: number, y: number}} pointer
     * @returns {{left: number, top: number, right: number, bottom: number}}
     * @private
     */

  }, {
    key: '_pointerToPositionObject',
    value: function _pointerToPositionObject(pointer) {
      var canvasPos = this.canvas.DOMtoCanvas(pointer);
      return {
        left: canvasPos.x - 1,
        top: canvasPos.y + 1,
        right: canvasPos.x + 1,
        bottom: canvasPos.y - 1
      };
    }

    /**
     * Get the top node at the passed point (like a click)
     *
     * @param {{x: number, y: number}} pointer
     * @param {boolean} [returnNode=true]
     * @return {Node | undefined} node
     */

  }, {
    key: 'getNodeAt',
    value: function getNodeAt(pointer) {
      var returnNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      // we first check if this is an navigation controls element
      var positionObject = this._pointerToPositionObject(pointer);
      var overlappingNodes = this._getAllNodesOverlappingWith(positionObject);
      // if there are overlapping nodes, select the last one, this is the
      // one which is drawn on top of the others
      if (overlappingNodes.length > 0) {
        if (returnNode === true) {
          return this.body.nodes[overlappingNodes[overlappingNodes.length - 1]];
        } else {
          return overlappingNodes[overlappingNodes.length - 1];
        }
      } else {
        return undefined;
      }
    }

    /**
     * retrieve all edges overlapping with given object, selector is around center
     * @param {Object} object  An object with parameters left, top, right, bottom
     * @param {number[]} overlappingEdges An array with id's of the overlapping nodes
     * @private
     */

  }, {
    key: '_getEdgesOverlappingWith',
    value: function _getEdgesOverlappingWith(object, overlappingEdges) {
      var edges = this.body.edges;
      for (var i = 0; i < this.body.edgeIndices.length; i++) {
        var edgeId = this.body.edgeIndices[i];
        if (edges[edgeId].isOverlappingWith(object)) {
          overlappingEdges.push(edgeId);
        }
      }
    }

    /**
     * retrieve all nodes overlapping with given object
     * @param {Object} object  An object with parameters left, top, right, bottom
     * @return {number[]}   An array with id's of the overlapping nodes
     * @private
     */

  }, {
    key: '_getAllEdgesOverlappingWith',
    value: function _getAllEdgesOverlappingWith(object) {
      var overlappingEdges = [];
      this._getEdgesOverlappingWith(object, overlappingEdges);
      return overlappingEdges;
    }

    /**
     * Get the edges nearest to the passed point (like a click)
     *
     * @param {{x: number, y: number}} pointer
     * @param {boolean} [returnEdge=true]
     * @return {Edge | undefined} node
     */

  }, {
    key: 'getEdgeAt',
    value: function getEdgeAt(pointer) {
      var returnEdge = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      // Iterate over edges, pick closest within 10
      var canvasPos = this.canvas.DOMtoCanvas(pointer);
      var mindist = 10;
      var overlappingEdge = null;
      var edges = this.body.edges;
      for (var i = 0; i < this.body.edgeIndices.length; i++) {
        var edgeId = this.body.edgeIndices[i];
        var edge = edges[edgeId];
        if (edge.connected) {
          var xFrom = edge.from.x;
          var yFrom = edge.from.y;
          var xTo = edge.to.x;
          var yTo = edge.to.y;
          var dist = edge.edgeType.getDistanceToEdge(xFrom, yFrom, xTo, yTo, canvasPos.x, canvasPos.y);
          if (dist < mindist) {
            overlappingEdge = edgeId;
            mindist = dist;
          }
        }
      }
      if (overlappingEdge !== null) {
        if (returnEdge === true) {
          return this.body.edges[overlappingEdge];
        } else {
          return overlappingEdge;
        }
      } else {
        return undefined;
      }
    }

    /**
     * Add object to the selection array.
     *
     * @param {Object} obj
     * @private
     */

  }, {
    key: '_addToSelection',
    value: function _addToSelection(obj) {
      if (obj instanceof Node) {
        this.selectionObj.nodes[obj.id] = obj;
      } else {
        this.selectionObj.edges[obj.id] = obj;
      }
    }

    /**
     * Add object to the selection array.
     *
     * @param {Object} obj
     * @private
     */

  }, {
    key: '_addToHover',
    value: function _addToHover(obj) {
      if (obj instanceof Node) {
        this.hoverObj.nodes[obj.id] = obj;
      } else {
        this.hoverObj.edges[obj.id] = obj;
      }
    }

    /**
     * Remove a single option from selection.
     *
     * @param {Object} obj
     * @private
     */

  }, {
    key: '_removeFromSelection',
    value: function _removeFromSelection(obj) {
      if (obj instanceof Node) {
        delete this.selectionObj.nodes[obj.id];
        this._unselectConnectedEdges(obj);
      } else {
        delete this.selectionObj.edges[obj.id];
      }
    }

    /**
     * Unselect all. The selectionObj is useful for this.
     */

  }, {
    key: 'unselectAll',
    value: function unselectAll() {
      for (var nodeId in this.selectionObj.nodes) {
        if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
          this.selectionObj.nodes[nodeId].unselect();
        }
      }
      for (var edgeId in this.selectionObj.edges) {
        if (this.selectionObj.edges.hasOwnProperty(edgeId)) {
          this.selectionObj.edges[edgeId].unselect();
        }
      }

      this.selectionObj = { nodes: {}, edges: {} };
    }

    /**
     * return the number of selected nodes
     *
     * @returns {number}
     * @private
     */

  }, {
    key: '_getSelectedNodeCount',
    value: function _getSelectedNodeCount() {
      var count = 0;
      for (var nodeId in this.selectionObj.nodes) {
        if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
          count += 1;
        }
      }
      return count;
    }

    /**
     * return the selected node
     *
     * @returns {number}
     * @private
     */

  }, {
    key: '_getSelectedNode',
    value: function _getSelectedNode() {
      for (var nodeId in this.selectionObj.nodes) {
        if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
          return this.selectionObj.nodes[nodeId];
        }
      }
      return undefined;
    }

    /**
     * return the selected edge
     *
     * @returns {number}
     * @private
     */

  }, {
    key: '_getSelectedEdge',
    value: function _getSelectedEdge() {
      for (var edgeId in this.selectionObj.edges) {
        if (this.selectionObj.edges.hasOwnProperty(edgeId)) {
          return this.selectionObj.edges[edgeId];
        }
      }
      return undefined;
    }

    /**
     * return the number of selected edges
     *
     * @returns {number}
     * @private
     */

  }, {
    key: '_getSelectedEdgeCount',
    value: function _getSelectedEdgeCount() {
      var count = 0;
      for (var edgeId in this.selectionObj.edges) {
        if (this.selectionObj.edges.hasOwnProperty(edgeId)) {
          count += 1;
        }
      }
      return count;
    }

    /**
     * return the number of selected objects.
     *
     * @returns {number}
     * @private
     */

  }, {
    key: '_getSelectedObjectCount',
    value: function _getSelectedObjectCount() {
      var count = 0;
      for (var nodeId in this.selectionObj.nodes) {
        if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
          count += 1;
        }
      }
      for (var edgeId in this.selectionObj.edges) {
        if (this.selectionObj.edges.hasOwnProperty(edgeId)) {
          count += 1;
        }
      }
      return count;
    }

    /**
     * Check if anything is selected
     *
     * @returns {boolean}
     * @private
     */

  }, {
    key: '_selectionIsEmpty',
    value: function _selectionIsEmpty() {
      for (var nodeId in this.selectionObj.nodes) {
        if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
          return false;
        }
      }
      for (var edgeId in this.selectionObj.edges) {
        if (this.selectionObj.edges.hasOwnProperty(edgeId)) {
          return false;
        }
      }
      return true;
    }

    /**
     * check if one of the selected nodes is a cluster.
     *
     * @returns {boolean}
     * @private
     */

  }, {
    key: '_clusterInSelection',
    value: function _clusterInSelection() {
      for (var nodeId in this.selectionObj.nodes) {
        if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
          if (this.selectionObj.nodes[nodeId].clusterSize > 1) {
            return true;
          }
        }
      }
      return false;
    }

    /**
     * select the edges connected to the node that is being selected
     *
     * @param {Node} node
     * @private
     */

  }, {
    key: '_selectConnectedEdges',
    value: function _selectConnectedEdges(node) {
      for (var i = 0; i < node.edges.length; i++) {
        var edge = node.edges[i];
        edge.select();
        this._addToSelection(edge);
      }
    }

    /**
     * select the edges connected to the node that is being selected
     *
     * @param {Node} node
     * @private
     */

  }, {
    key: '_hoverConnectedEdges',
    value: function _hoverConnectedEdges(node) {
      for (var i = 0; i < node.edges.length; i++) {
        var edge = node.edges[i];
        edge.hover = true;
        this._addToHover(edge);
      }
    }

    /**
     * unselect the edges connected to the node that is being selected
     *
     * @param {Node} node
     * @private
     */

  }, {
    key: '_unselectConnectedEdges',
    value: function _unselectConnectedEdges(node) {
      for (var i = 0; i < node.edges.length; i++) {
        var edge = node.edges[i];
        edge.unselect();
        this._removeFromSelection(edge);
      }
    }

    /**
     * Remove the highlight from a node or edge, in response to mouse movement
     *
     * @param {Event}  event
     * @param {{x: number, y: number}} pointer object with the x and y screen coordinates of the mouse
     * @param {Node|vis.Edge} object
     * @private
     */

  }, {
    key: 'emitBlurEvent',
    value: function emitBlurEvent(event, pointer, object) {
      var properties = this._initBaseEvent(event, pointer);

      if (object.hover === true) {
        object.hover = false;
        if (object instanceof Node) {
          properties.node = object.id;
          this.body.emitter.emit('blurNode', properties);
        } else {
          properties.edge = object.id;
          this.body.emitter.emit('blurEdge', properties);
        }
      }
    }

    /**
     * Create the highlight for a node or edge, in response to mouse movement
     *
     * @param {Event}  event
     * @param {{x: number, y: number}} pointer object with the x and y screen coordinates of the mouse
     * @param {Node|vis.Edge} object
     * @returns {boolean} hoverChanged
     * @private
     */

  }, {
    key: 'emitHoverEvent',
    value: function emitHoverEvent(event, pointer, object) {
      var properties = this._initBaseEvent(event, pointer);
      var hoverChanged = false;

      if (object.hover === false) {
        object.hover = true;
        this._addToHover(object);
        hoverChanged = true;
        if (object instanceof Node) {
          properties.node = object.id;
          this.body.emitter.emit('hoverNode', properties);
        } else {
          properties.edge = object.id;
          this.body.emitter.emit('hoverEdge', properties);
        }
      }

      return hoverChanged;
    }

    /**
     * Perform actions in response to a mouse movement.
     *
     * @param {Event}  event
     * @param {{x: number, y: number}} pointer | object with the x and y screen coordinates of the mouse
     */

  }, {
    key: 'hoverObject',
    value: function hoverObject(event, pointer) {
      var object = this.getNodeAt(pointer);
      if (object === undefined) {
        object = this.getEdgeAt(pointer);
      }

      var hoverChanged = false;
      // remove all node hover highlights
      for (var nodeId in this.hoverObj.nodes) {
        if (this.hoverObj.nodes.hasOwnProperty(nodeId)) {
          if (object === undefined || object instanceof Node && object.id != nodeId || object instanceof Edge) {
            this.emitBlurEvent(event, pointer, this.hoverObj.nodes[nodeId]);
            delete this.hoverObj.nodes[nodeId];
            hoverChanged = true;
          }
        }
      }

      // removing all edge hover highlights
      for (var edgeId in this.hoverObj.edges) {
        if (this.hoverObj.edges.hasOwnProperty(edgeId)) {
          // if the hover has been changed here it means that the node has been hovered over or off
          // we then do not use the emitBlurEvent method here.
          if (hoverChanged === true) {
            this.hoverObj.edges[edgeId].hover = false;
            delete this.hoverObj.edges[edgeId];
          }
          // if the blur remains the same and the object is undefined (mouse off) or another
          // edge has been hovered, or another node has been hovered we blur the edge.
          else if (object === undefined || object instanceof Edge && object.id != edgeId || object instanceof Node && !object.hover) {
              this.emitBlurEvent(event, pointer, this.hoverObj.edges[edgeId]);
              delete this.hoverObj.edges[edgeId];
              hoverChanged = true;
            }
        }
      }

      if (object !== undefined) {
        var hoveredEdgesCount = (0, _keys2['default'])(this.hoverObj.edges).length;
        var hoveredNodesCount = (0, _keys2['default'])(this.hoverObj.nodes).length;
        var newOnlyHoveredEdge = object instanceof Edge && hoveredEdgesCount === 0 && hoveredNodesCount === 0;

        if (hoverChanged || newOnlyHoveredEdge) {
          hoverChanged = this.emitHoverEvent(event, pointer, object);
        }

        if (object instanceof Node && this.options.hoverConnectedEdges === true) {
          this._hoverConnectedEdges(object);
        }
      }

      if (hoverChanged === true) {
        this.body.emitter.emit('_requestRedraw');
      }
    }

    /**
     *
     * retrieve the currently selected objects
     * @return {{nodes: Array.<string>, edges: Array.<string>}} selection
     */

  }, {
    key: 'getSelection',
    value: function getSelection() {
      var nodeIds = this.getSelectedNodes();
      var edgeIds = this.getSelectedEdges();
      return { nodes: nodeIds, edges: edgeIds };
    }

    /**
     *
     * retrieve the currently selected nodes
     * @return {string[]} selection    An array with the ids of the
     *                                            selected nodes.
     */

  }, {
    key: 'getSelectedNodes',
    value: function getSelectedNodes() {
      var idArray = [];
      if (this.options.selectable === true) {
        for (var nodeId in this.selectionObj.nodes) {
          if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
            idArray.push(this.selectionObj.nodes[nodeId].id);
          }
        }
      }
      return idArray;
    }

    /**
     *
     * retrieve the currently selected edges
     * @return {Array} selection    An array with the ids of the
     *                                            selected nodes.
     */

  }, {
    key: 'getSelectedEdges',
    value: function getSelectedEdges() {
      var idArray = [];
      if (this.options.selectable === true) {
        for (var edgeId in this.selectionObj.edges) {
          if (this.selectionObj.edges.hasOwnProperty(edgeId)) {
            idArray.push(this.selectionObj.edges[edgeId].id);
          }
        }
      }
      return idArray;
    }

    /**
     * Updates the current selection
     * @param {{nodes: Array.<string>, edges: Array.<string>}} selection
     * @param {Object} options                                 Options
     */

  }, {
    key: 'setSelection',
    value: function setSelection(selection) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var i = void 0,
          id = void 0;

      if (!selection || !selection.nodes && !selection.edges) throw 'Selection must be an object with nodes and/or edges properties';
      // first unselect any selected node, if option is true or undefined
      if (options.unselectAll || options.unselectAll === undefined) {
        this.unselectAll();
      }
      if (selection.nodes) {
        for (i = 0; i < selection.nodes.length; i++) {
          id = selection.nodes[i];

          var node = this.body.nodes[id];
          if (!node) {
            throw new RangeError('Node with id "' + id + '" not found');
          }
          // don't select edges with it
          this.selectObject(node, options.highlightEdges);
        }
      }

      if (selection.edges) {
        for (i = 0; i < selection.edges.length; i++) {
          id = selection.edges[i];

          var edge = this.body.edges[id];
          if (!edge) {
            throw new RangeError('Edge with id "' + id + '" not found');
          }
          this.selectObject(edge);
        }
      }
      this.body.emitter.emit('_requestRedraw');
    }

    /**
     * select zero or more nodes with the option to highlight edges
     * @param {number[] | string[]} selection     An array with the ids of the
     *                                            selected nodes.
     * @param {boolean} [highlightEdges]
     */

  }, {
    key: 'selectNodes',
    value: function selectNodes(selection) {
      var highlightEdges = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (!selection || selection.length === undefined) throw 'Selection must be an array with ids';

      this.setSelection({ nodes: selection }, { highlightEdges: highlightEdges });
    }

    /**
     * select zero or more edges
     * @param {number[] | string[]} selection     An array with the ids of the
     *                                            selected nodes.
     */

  }, {
    key: 'selectEdges',
    value: function selectEdges(selection) {
      if (!selection || selection.length === undefined) throw 'Selection must be an array with ids';

      this.setSelection({ edges: selection });
    }

    /**
     * Validate the selection: remove ids of nodes which no longer exist
     * @private
     */

  }, {
    key: 'updateSelection',
    value: function updateSelection() {
      for (var nodeId in this.selectionObj.nodes) {
        if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
          if (!this.body.nodes.hasOwnProperty(nodeId)) {
            delete this.selectionObj.nodes[nodeId];
          }
        }
      }
      for (var edgeId in this.selectionObj.edges) {
        if (this.selectionObj.edges.hasOwnProperty(edgeId)) {
          if (!this.body.edges.hasOwnProperty(edgeId)) {
            delete this.selectionObj.edges[edgeId];
          }
        }
      }
    }

    /**
     * Determine all the visual elements clicked which are on the given point.
     *
     * All elements are returned; this includes nodes, edges and their labels.
     * The order returned is from highest to lowest, i.e. element 0 of the return
     * value is the topmost item clicked on.
     *
     * The return value consists of an array of the following possible elements:
     *
     * - `{nodeId:number}`             - node with given id clicked on
     * - `{nodeId:number, labelId:0}`  - label of node with given id clicked on
     * - `{edgeId:number}`             - edge with given id clicked on
     * - `{edge:number, labelId:0}`    - label of edge with given id clicked on
     *
     * ## NOTES
     *
     * - Currently, there is only one label associated with a node or an edge,
     *   but this is expected to change somewhere in the future.
     * - Since there is no z-indexing yet, it is not really possible to set the nodes and
     *   edges in the correct order. For the time being, nodes come first.
     *
     * @param {point} pointer  mouse position in screen coordinates
     * @returns {Array.<nodeClickItem|nodeLabelClickItem|edgeClickItem|edgeLabelClickItem>}
     * @private
     */

  }, {
    key: 'getClickedItems',
    value: function getClickedItems(pointer) {
      var point = this.canvas.DOMtoCanvas(pointer);
      var items = [];

      // Note reverse order; we want the topmost clicked items to be first in the array
      // Also note that selected nodes are disregarded here; these normally display on top
      var nodeIndices = this.body.nodeIndices;
      var nodes = this.body.nodes;
      for (var i = nodeIndices.length - 1; i >= 0; i--) {
        var node = nodes[nodeIndices[i]];
        var ret = node.getItemsOnPoint(point);
        items.push.apply(items, ret); // Append the return value to the running list.
      }

      var edgeIndices = this.body.edgeIndices;
      var edges = this.body.edges;
      for (var _i = edgeIndices.length - 1; _i >= 0; _i--) {
        var edge = edges[edgeIndices[_i]];
        var _ret = edge.getItemsOnPoint(point);
        items.push.apply(items, _ret); // Append the return value to the running list.
      }

      return items;
    }
  }]);
  return SelectionHandler;
}();

exports['default'] = SelectionHandler;

/***/ }),
/* 187 */
/***/ (function(module, exports, __nested_webpack_require_1073236__) {

"use strict";
/**
 * There's a mix-up with terms in the code. Following are the formal definitions:
 *
 *   tree   - a strict hierarchical network, i.e. every node has at most one parent
 *   forest - a collection of trees. These distinct trees are thus not connected.
 *
 * So:
 * - in a network that is not a tree, there exist nodes with multiple parents.
 * - a network consisting of unconnected sub-networks, of which at least one
 *   is not a tree, is not a forest.
 *
 * In the code, the definitions are:
 *
 *   tree   - any disconnected sub-network, strict hierarchical or not.
 *   forest - a bunch of these sub-networks
 *
 * The difference between tree and not-tree is important in the code, notably within
 * to the block-shifting algorithm. The algorithm assumes formal trees and fails
 * for not-trees, often in a spectacular manner (search for 'exploding network' in the issues).
 *
 * In order to distinguish the definitions in the following code, the adjective 'formal' is
 * used. If 'formal' is absent, you must assume the non-formal definition.
 *
 * ----------------------------------------------------------------------------------
 * NOTES
 * =====
 *
 * A hierarchical layout is a different thing from a hierarchical network.
 * The layout is a way to arrange the nodes in the view; this can be done
 * on non-hierarchical networks as well. The converse is also possible.
 */


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray2 = __nested_webpack_require_1073236__(15);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _typeof2 = __nested_webpack_require_1073236__(7);

var _typeof3 = _interopRequireDefault(_typeof2);

var _keys = __nested_webpack_require_1073236__(9);

var _keys2 = _interopRequireDefault(_keys);

var _classCallCheck2 = __nested_webpack_require_1073236__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_1073236__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var TimSort = __nested_webpack_require_1073236__(83);
var util = __nested_webpack_require_1073236__(2);
var NetworkUtil = __nested_webpack_require_1073236__(57)['default'];

var _require = __nested_webpack_require_1073236__(189),
    HorizontalStrategy = _require.HorizontalStrategy,
    VerticalStrategy = _require.VerticalStrategy;

/**
 * Container for derived data on current network, relating to hierarchy.
 *
 * @private
 */


var HierarchicalStatus = function () {
  /**
   * @ignore
   */
  function HierarchicalStatus() {
    (0, _classCallCheck3['default'])(this, HierarchicalStatus);

    this.childrenReference = {}; // child id's per node id
    this.parentReference = {}; // parent id's per node id
    this.trees = {}; // tree id per node id; i.e. to which tree does given node id belong

    this.distributionOrdering = {}; // The nodes per level, in the display order
    this.levels = {}; // hierarchy level per node id
    this.distributionIndex = {}; // The position of the node in the level sorting order, per node id.

    this.isTree = false; // True if current network is a formal tree
    this.treeIndex = -1; // Highest tree id in current network.
  }

  /**
   * Add the relation between given nodes to the current state.
   *
   * @param {Node.id} parentNodeId
   * @param {Node.id} childNodeId
   */


  (0, _createClass3['default'])(HierarchicalStatus, [{
    key: 'addRelation',
    value: function addRelation(parentNodeId, childNodeId) {
      if (this.childrenReference[parentNodeId] === undefined) {
        this.childrenReference[parentNodeId] = [];
      }
      this.childrenReference[parentNodeId].push(childNodeId);

      if (this.parentReference[childNodeId] === undefined) {
        this.parentReference[childNodeId] = [];
      }
      this.parentReference[childNodeId].push(parentNodeId);
    }

    /**
     * Check if the current state is for a formal tree or formal forest.
     *
     * This is the case if every node has at most one parent.
     *
     * Pre: parentReference init'ed properly for current network
     */

  }, {
    key: 'checkIfTree',
    value: function checkIfTree() {
      for (var i in this.parentReference) {
        if (this.parentReference[i].length > 1) {
          this.isTree = false;
          return;
        }
      }

      this.isTree = true;
    }

    /**
     * Return the number of separate trees in the current network.
     * @returns {number}
     */

  }, {
    key: 'numTrees',
    value: function numTrees() {
      return this.treeIndex + 1; // This assumes the indexes are assigned consecitively
    }

    /**
     * Assign a tree id to a node
     * @param {Node} node
     * @param {string|number} treeId
     */

  }, {
    key: 'setTreeIndex',
    value: function setTreeIndex(node, treeId) {
      if (treeId === undefined) return; // Don't bother

      if (this.trees[node.id] === undefined) {
        this.trees[node.id] = treeId;
        this.treeIndex = Math.max(treeId, this.treeIndex);
      }
    }

    /**
     * Ensure level for given id is defined.
     *
     * Sets level to zero for given node id if not already present
     *
     * @param {Node.id} nodeId
     */

  }, {
    key: 'ensureLevel',
    value: function ensureLevel(nodeId) {
      if (this.levels[nodeId] === undefined) {
        this.levels[nodeId] = 0;
      }
    }

    /**
     * get the maximum level of a branch.
     *
     * TODO: Never entered; find a test case to test this!
     * @param {Node.id} nodeId
     * @returns {number}
     */

  }, {
    key: 'getMaxLevel',
    value: function getMaxLevel(nodeId) {
      var _this = this;

      var accumulator = {};

      var _getMaxLevel = function _getMaxLevel(nodeId) {
        if (accumulator[nodeId] !== undefined) {
          return accumulator[nodeId];
        }
        var level = _this.levels[nodeId];
        if (_this.childrenReference[nodeId]) {
          var children = _this.childrenReference[nodeId];
          if (children.length > 0) {
            for (var i = 0; i < children.length; i++) {
              level = Math.max(level, _getMaxLevel(children[i]));
            }
          }
        }
        accumulator[nodeId] = level;
        return level;
      };

      return _getMaxLevel(nodeId);
    }

    /**
     *
     * @param {Node} nodeA
     * @param {Node} nodeB
     */

  }, {
    key: 'levelDownstream',
    value: function levelDownstream(nodeA, nodeB) {
      if (this.levels[nodeB.id] === undefined) {
        // set initial level
        if (this.levels[nodeA.id] === undefined) {
          this.levels[nodeA.id] = 0;
        }
        // set level
        this.levels[nodeB.id] = this.levels[nodeA.id] + 1;
      }
    }

    /**
     * Small util method to set the minimum levels of the nodes to zero.
     *
     * @param {Array.<Node>} nodes
     */

  }, {
    key: 'setMinLevelToZero',
    value: function setMinLevelToZero(nodes) {
      var minLevel = 1e9;
      // get the minimum level
      for (var nodeId in nodes) {
        if (nodes.hasOwnProperty(nodeId)) {
          if (this.levels[nodeId] !== undefined) {
            minLevel = Math.min(this.levels[nodeId], minLevel);
          }
        }
      }

      // subtract the minimum from the set so we have a range starting from 0
      for (var _nodeId in nodes) {
        if (nodes.hasOwnProperty(_nodeId)) {
          if (this.levels[_nodeId] !== undefined) {
            this.levels[_nodeId] -= minLevel;
          }
        }
      }
    }

    /**
     * Get the min and max xy-coordinates of a given tree
     *
     * @param {Array.<Node>} nodes
     * @param {number} index
     * @returns {{min_x: number, max_x: number, min_y: number, max_y: number}}
     */

  }, {
    key: 'getTreeSize',
    value: function getTreeSize(nodes, index) {
      var min_x = 1e9;
      var max_x = -1e9;
      var min_y = 1e9;
      var max_y = -1e9;

      for (var nodeId in this.trees) {
        if (this.trees.hasOwnProperty(nodeId)) {
          if (this.trees[nodeId] === index) {
            var node = nodes[nodeId];
            min_x = Math.min(node.x, min_x);
            max_x = Math.max(node.x, max_x);
            min_y = Math.min(node.y, min_y);
            max_y = Math.max(node.y, max_y);
          }
        }
      }

      return {
        min_x: min_x,
        max_x: max_x,
        min_y: min_y,
        max_y: max_y
      };
    }

    /**
     * Check if two nodes have the same parent(s)
     *
     * @param {Node} node1
     * @param {Node} node2
     * @return {boolean} true if the two nodes have a same ancestor node, false otherwise
     */

  }, {
    key: 'hasSameParent',
    value: function hasSameParent(node1, node2) {
      var parents1 = this.parentReference[node1.id];
      var parents2 = this.parentReference[node2.id];
      if (parents1 === undefined || parents2 === undefined) {
        return false;
      }

      for (var i = 0; i < parents1.length; i++) {
        for (var j = 0; j < parents2.length; j++) {
          if (parents1[i] == parents2[j]) {
            return true;
          }
        }
      }
      return false;
    }

    /**
     * Check if two nodes are in the same tree.
     *
     * @param {Node} node1
     * @param {Node} node2
     * @return {Boolean} true if this is so, false otherwise
     */

  }, {
    key: 'inSameSubNetwork',
    value: function inSameSubNetwork(node1, node2) {
      return this.trees[node1.id] === this.trees[node2.id];
    }

    /**
     * Get a list of the distinct levels in the current network
     *
     * @returns {Array}
     */

  }, {
    key: 'getLevels',
    value: function getLevels() {
      return (0, _keys2['default'])(this.distributionOrdering);
    }

    /**
     * Add a node to the ordering per level
     *
     * @param {Node} node
     * @param {number} level
     */

  }, {
    key: 'addToOrdering',
    value: function addToOrdering(node, level) {
      if (this.distributionOrdering[level] === undefined) {
        this.distributionOrdering[level] = [];
      }

      var isPresent = false;
      var curLevel = this.distributionOrdering[level];
      for (var n in curLevel) {
        //if (curLevel[n].id === node.id) {
        if (curLevel[n] === node) {
          isPresent = true;
          break;
        }
      }

      if (!isPresent) {
        this.distributionOrdering[level].push(node);
        this.distributionIndex[node.id] = this.distributionOrdering[level].length - 1;
      }
    }
  }]);
  return HierarchicalStatus;
}();

/**
 * The Layout Engine
 */


var LayoutEngine = function () {
  /**
   * @param {Object} body
   */
  function LayoutEngine(body) {
    (0, _classCallCheck3['default'])(this, LayoutEngine);

    this.body = body;

    this.initialRandomSeed = Math.round(Math.random() * 1000000);
    this.randomSeed = this.initialRandomSeed;
    this.setPhysics = false;
    this.options = {};
    this.optionsBackup = { physics: {} };

    this.defaultOptions = {
      randomSeed: undefined,
      improvedLayout: true,
      hierarchical: {
        enabled: false,
        levelSeparation: 150,
        nodeSpacing: 100,
        treeSpacing: 200,
        blockShifting: true,
        edgeMinimization: true,
        parentCentralization: true,
        direction: 'UD', // UD, DU, LR, RL
        sortMethod: 'hubsize' // hubsize, directed
      }
    };
    util.extend(this.options, this.defaultOptions);
    this.bindEventListeners();
  }

  /**
   * Binds event listeners
   */


  (0, _createClass3['default'])(LayoutEngine, [{
    key: 'bindEventListeners',
    value: function bindEventListeners() {
      var _this2 = this;

      this.body.emitter.on('_dataChanged', function () {
        _this2.setupHierarchicalLayout();
      });
      this.body.emitter.on('_dataLoaded', function () {
        _this2.layoutNetwork();
      });
      this.body.emitter.on('_resetHierarchicalLayout', function () {
        _this2.setupHierarchicalLayout();
      });
      this.body.emitter.on('_adjustEdgesForHierarchicalLayout', function () {
        if (_this2.options.hierarchical.enabled !== true) {
          return;
        }
        // get the type of static smooth curve in case it is required
        var type = _this2.direction.curveType();

        // force all edges into static smooth curves.
        _this2.body.emitter.emit('_forceDisableDynamicCurves', type, false);
      });
    }

    /**
     *
     * @param {Object} options
     * @param {Object} allOptions
     * @returns {Object}
     */

  }, {
    key: 'setOptions',
    value: function setOptions(options, allOptions) {
      if (options !== undefined) {
        var hierarchical = this.options.hierarchical;
        var prevHierarchicalState = hierarchical.enabled;
        util.selectiveDeepExtend(['randomSeed', 'improvedLayout'], this.options, options);
        util.mergeOptions(this.options, options, 'hierarchical');
        if (options.randomSeed !== undefined) {
          this.initialRandomSeed = options.randomSeed;
        }

        if (hierarchical.enabled === true) {
          if (prevHierarchicalState === true) {
            // refresh the overridden options for nodes and edges.
            this.body.emitter.emit('refresh', true);
          }

          // make sure the level separation is the right way up
          if (hierarchical.direction === 'RL' || hierarchical.direction === 'DU') {
            if (hierarchical.levelSeparation > 0) {
              hierarchical.levelSeparation *= -1;
            }
          } else {
            if (hierarchical.levelSeparation < 0) {
              hierarchical.levelSeparation *= -1;
            }
          }

          this.setDirectionStrategy();

          this.body.emitter.emit('_resetHierarchicalLayout');
          // because the hierarchical system needs it's own physics and smooth curve settings,
          // we adapt the other options if needed.
          return this.adaptAllOptionsForHierarchicalLayout(allOptions);
        } else {
          if (prevHierarchicalState === true) {
            // refresh the overridden options for nodes and edges.
            this.body.emitter.emit('refresh');
            return util.deepExtend(allOptions, this.optionsBackup);
          }
        }
      }
      return allOptions;
    }

    /**
     *
     * @param {Object} allOptions
     * @returns {Object}
     */

  }, {
    key: 'adaptAllOptionsForHierarchicalLayout',
    value: function adaptAllOptionsForHierarchicalLayout(allOptions) {
      if (this.options.hierarchical.enabled === true) {
        var backupPhysics = this.optionsBackup.physics;

        // set the physics
        if (allOptions.physics === undefined || allOptions.physics === true) {
          allOptions.physics = {
            enabled: backupPhysics.enabled === undefined ? true : backupPhysics.enabled,
            solver: 'hierarchicalRepulsion'
          };
          backupPhysics.enabled = backupPhysics.enabled === undefined ? true : backupPhysics.enabled;
          backupPhysics.solver = backupPhysics.solver || 'barnesHut';
        } else if ((0, _typeof3['default'])(allOptions.physics) === 'object') {
          backupPhysics.enabled = allOptions.physics.enabled === undefined ? true : allOptions.physics.enabled;
          backupPhysics.solver = allOptions.physics.solver || 'barnesHut';
          allOptions.physics.solver = 'hierarchicalRepulsion';
        } else if (allOptions.physics !== false) {
          backupPhysics.solver = 'barnesHut';
          allOptions.physics = { solver: 'hierarchicalRepulsion' };
        }

        // get the type of static smooth curve in case it is required
        var type = this.direction.curveType();

        // disable smooth curves if nothing is defined. If smooth curves have been turned on,
        // turn them into static smooth curves.
        if (allOptions.edges === undefined) {
          this.optionsBackup.edges = {
            smooth: { enabled: true, type: 'dynamic' }
          };
          allOptions.edges = { smooth: false };
        } else if (allOptions.edges.smooth === undefined) {
          this.optionsBackup.edges = {
            smooth: { enabled: true, type: 'dynamic' }
          };
          allOptions.edges.smooth = false;
        } else {
          if (typeof allOptions.edges.smooth === 'boolean') {
            this.optionsBackup.edges = { smooth: allOptions.edges.smooth };
            allOptions.edges.smooth = {
              enabled: allOptions.edges.smooth,
              type: type
            };
          } else {
            var smooth = allOptions.edges.smooth;

            // allow custom types except for dynamic
            if (smooth.type !== undefined && smooth.type !== 'dynamic') {
              type = smooth.type;
            }

            // TODO: this is options merging; see if the standard routines can be used here.
            this.optionsBackup.edges = {
              smooth: smooth.enabled === undefined ? true : smooth.enabled,
              type: smooth.type === undefined ? 'dynamic' : smooth.type,
              roundness: smooth.roundness === undefined ? 0.5 : smooth.roundness,
              forceDirection: smooth.forceDirection === undefined ? false : smooth.forceDirection

              // NOTE: Copying an object to self; this is basically setting defaults for undefined variables
            };allOptions.edges.smooth = {
              enabled: smooth.enabled === undefined ? true : smooth.enabled,
              type: type,
              roundness: smooth.roundness === undefined ? 0.5 : smooth.roundness,
              forceDirection: smooth.forceDirection === undefined ? false : smooth.forceDirection
            };
          }
        }

        // Force all edges into static smooth curves.
        // Only applies to edges that do not use the global options for smooth.
        this.body.emitter.emit('_forceDisableDynamicCurves', type);
      }

      return allOptions;
    }

    /**
     *
     * @returns {number}
     */

  }, {
    key: 'seededRandom',
    value: function seededRandom() {
      var x = Math.sin(this.randomSeed++) * 10000;
      return x - Math.floor(x);
    }

    /**
     *
     * @param {Array.<Node>} nodesArray
     */

  }, {
    key: 'positionInitially',
    value: function positionInitially(nodesArray) {
      if (this.options.hierarchical.enabled !== true) {
        this.randomSeed = this.initialRandomSeed;
        var radius = nodesArray.length + 50;
        for (var i = 0; i < nodesArray.length; i++) {
          var node = nodesArray[i];
          var angle = 2 * Math.PI * this.seededRandom();
          if (node.x === undefined) {
            node.x = radius * Math.cos(angle);
          }
          if (node.y === undefined) {
            node.y = radius * Math.sin(angle);
          }
        }
      }
    }

    /**
     * Use Kamada Kawai to position nodes. This is quite a heavy algorithm so if there are a lot of nodes we
     * cluster them first to reduce the amount.
     */

  }, {
    key: 'layoutNetwork',
    value: function layoutNetwork() {
      if (this.options.hierarchical.enabled !== true && this.options.improvedLayout === true) {
        var indices = this.body.nodeIndices;

        // first check if we should Kamada Kawai to layout. The threshold is if less than half of the visible
        // nodes have predefined positions we use this.
        var positionDefined = 0;
        for (var i = 0; i < indices.length; i++) {
          var node = this.body.nodes[indices[i]];
          if (node.predefinedPosition === true) {
            positionDefined += 1;
          }
        }

        // if less than half of the nodes have a predefined position we continue
        if (positionDefined < 0.5 * indices.length) {
          var MAX_LEVELS = 10;
          var level = 0;
          var clusterThreshold = 150; // TODO add this to options

          //
          // Define the options for the hidden cluster nodes
          // These options don't propagate outside the clustering phase.
          //
          // Some options are explicitly disabled, because they may be set in group or default node options.
          // The clusters are never displayed, so most explicit settings here serve as performance optimizations.
          //
          // The explicit setting of 'shape' is to avoid `shape: 'image'`; images are not passed to the hidden
          // cluster nodes, leading to an exception on creation.
          //
          // All settings here are performance related, except when noted otherwise.
          //
          var clusterOptions = {
            clusterNodeProperties: {
              shape: 'ellipse', // Bugfix: avoid type 'image', no images supplied
              label: '', // avoid label handling
              group: '', // avoid group handling
              font: { multi: false // avoid font propagation
              } },
            clusterEdgeProperties: {
              label: '', // avoid label handling
              font: { multi: false }, // avoid font propagation
              smooth: {
                enabled: false // avoid drawing penalty for complex edges
              }
            }

            // if there are a lot of nodes, we cluster before we run the algorithm.
            // NOTE: this part fails to find clusters for large scale-free networks, which should
            //       be easily clusterable.
            // TODO: examine why this is so
          };if (indices.length > clusterThreshold) {
            var startLength = indices.length;
            while (indices.length > clusterThreshold && level <= MAX_LEVELS) {
              //console.time("clustering")
              level += 1;
              var before = indices.length;
              // if there are many nodes we do a hubsize cluster
              if (level % 3 === 0) {
                this.body.modules.clustering.clusterBridges(clusterOptions);
              } else {
                this.body.modules.clustering.clusterOutliers(clusterOptions);
              }
              var after = indices.length;
              if (before == after && level % 3 !== 0) {
                this._declusterAll();
                this.body.emitter.emit('_layoutFailed');
                console.info('This network could not be positioned by this version of the improved layout algorithm.' + ' Please disable improvedLayout for better performance.');
                return;
              }
              //console.timeEnd("clustering")
              //console.log(before,level,after);
            }
            // increase the size of the edges
            this.body.modules.kamadaKawai.setOptions({
              springLength: Math.max(150, 2 * startLength)
            });
          }
          if (level > MAX_LEVELS) {
            console.info("The clustering didn't succeed within the amount of interations allowed," + ' progressing with partial result.');
          }

          // position the system for these nodes and edges
          this.body.modules.kamadaKawai.solve(indices, this.body.edgeIndices, true);

          // shift to center point
          this._shiftToCenter();

          // perturb the nodes a little bit to force the physics to kick in
          var offset = 70;
          for (var _i = 0; _i < indices.length; _i++) {
            // Only perturb the nodes that aren't fixed
            var _node = this.body.nodes[indices[_i]];
            if (_node.predefinedPosition === false) {
              _node.x += (0.5 - this.seededRandom()) * offset;
              _node.y += (0.5 - this.seededRandom()) * offset;
            }
          }

          // uncluster all clusters
          this._declusterAll();

          // reposition all bezier nodes.
          this.body.emitter.emit('_repositionBezierNodes');
        }
      }
    }

    /**
     * Move all the nodes towards to the center so gravitational pull wil not move the nodes away from view
     * @private
     */

  }, {
    key: '_shiftToCenter',
    value: function _shiftToCenter() {
      var range = NetworkUtil.getRangeCore(this.body.nodes, this.body.nodeIndices);
      var center = NetworkUtil.findCenter(range);
      for (var i = 0; i < this.body.nodeIndices.length; i++) {
        var node = this.body.nodes[this.body.nodeIndices[i]];
        node.x -= center.x;
        node.y -= center.y;
      }
    }

    /**
     * Expands all clusters
     * @private
     */

  }, {
    key: '_declusterAll',
    value: function _declusterAll() {
      var clustersPresent = true;
      while (clustersPresent === true) {
        clustersPresent = false;
        for (var i = 0; i < this.body.nodeIndices.length; i++) {
          if (this.body.nodes[this.body.nodeIndices[i]].isCluster === true) {
            clustersPresent = true;
            this.body.modules.clustering.openCluster(this.body.nodeIndices[i], {}, false);
          }
        }
        if (clustersPresent === true) {
          this.body.emitter.emit('_dataChanged');
        }
      }
    }

    /**
     *
     * @returns {number|*}
     */

  }, {
    key: 'getSeed',
    value: function getSeed() {
      return this.initialRandomSeed;
    }

    /**
     * This is the main function to layout the nodes in a hierarchical way.
     * It checks if the node details are supplied correctly
     *
     * @private
     */

  }, {
    key: 'setupHierarchicalLayout',
    value: function setupHierarchicalLayout() {
      if (this.options.hierarchical.enabled === true && this.body.nodeIndices.length > 0) {
        // get the size of the largest hubs and check if the user has defined a level for a node.
        var node = void 0,
            nodeId = void 0;
        var definedLevel = false;
        var undefinedLevel = false;
        this.lastNodeOnLevel = {};
        this.hierarchical = new HierarchicalStatus();

        for (nodeId in this.body.nodes) {
          if (this.body.nodes.hasOwnProperty(nodeId)) {
            node = this.body.nodes[nodeId];
            if (node.options.level !== undefined) {
              definedLevel = true;
              this.hierarchical.levels[nodeId] = node.options.level;
            } else {
              undefinedLevel = true;
            }
          }
        }

        // if the user defined some levels but not all, alert and run without hierarchical layout
        if (undefinedLevel === true && definedLevel === true) {
          throw new Error('To use the hierarchical layout, nodes require either no predefined levels' + ' or levels have to be defined for all nodes.');
        } else {
          // define levels if undefined by the users. Based on hubsize.
          if (undefinedLevel === true) {
            var sortMethod = this.options.hierarchical.sortMethod;
            if (sortMethod === 'hubsize') {
              this._determineLevelsByHubsize();
            } else if (sortMethod === 'directed') {
              this._determineLevelsDirected();
            } else if (sortMethod === 'custom') {
              this._determineLevelsCustomCallback();
            }
          }

          // fallback for cases where there are nodes but no edges
          for (var _nodeId2 in this.body.nodes) {
            if (this.body.nodes.hasOwnProperty(_nodeId2)) {
              this.hierarchical.ensureLevel(_nodeId2);
            }
          }
          // check the distribution of the nodes per level.
          var distribution = this._getDistribution();

          // get the parent children relations.
          this._generateMap();

          // place the nodes on the canvas.
          this._placeNodesByHierarchy(distribution);

          // condense the whitespace.
          this._condenseHierarchy();

          // shift to center so gravity does not have to do much
          this._shiftToCenter();
        }
      }
    }

    /**
     * @private
     */

  }, {
    key: '_condenseHierarchy',
    value: function _condenseHierarchy() {
      var _this3 = this;

      // Global var in this scope to define when the movement has stopped.
      var stillShifting = false;
      var branches = {};
      // first we have some methods to help shifting trees around.
      // the main method to shift the trees
      var shiftTrees = function shiftTrees() {
        var treeSizes = getTreeSizes();
        var shiftBy = 0;
        for (var i = 0; i < treeSizes.length - 1; i++) {
          var diff = treeSizes[i].max - treeSizes[i + 1].min;
          shiftBy += diff + _this3.options.hierarchical.treeSpacing;
          shiftTree(i + 1, shiftBy);
        }
      };

      // shift a single tree by an offset
      var shiftTree = function shiftTree(index, offset) {
        var trees = _this3.hierarchical.trees;

        for (var nodeId in trees) {
          if (trees.hasOwnProperty(nodeId)) {
            if (trees[nodeId] === index) {
              _this3.direction.shift(nodeId, offset);
            }
          }
        }
      };

      // get the width of all trees
      var getTreeSizes = function getTreeSizes() {
        var treeWidths = [];
        for (var i = 0; i < _this3.hierarchical.numTrees(); i++) {
          treeWidths.push(_this3.direction.getTreeSize(i));
        }
        return treeWidths;
      };

      // get a map of all nodes in this branch
      var getBranchNodes = function getBranchNodes(source, map) {
        if (map[source.id]) {
          return;
        }
        map[source.id] = true;
        if (_this3.hierarchical.childrenReference[source.id]) {
          var children = _this3.hierarchical.childrenReference[source.id];
          if (children.length > 0) {
            for (var i = 0; i < children.length; i++) {
              getBranchNodes(_this3.body.nodes[children[i]], map);
            }
          }
        }
      };

      // get a min max width as well as the maximum movement space it has on either sides
      // we use min max terminology because width and height can interchange depending on the direction of the layout
      var getBranchBoundary = function getBranchBoundary(branchMap) {
        var maxLevel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e9;

        var minSpace = 1e9;
        var maxSpace = 1e9;
        var min = 1e9;
        var max = -1e9;
        for (var branchNode in branchMap) {
          if (branchMap.hasOwnProperty(branchNode)) {
            var node = _this3.body.nodes[branchNode];
            var level = _this3.hierarchical.levels[node.id];
            var position = _this3.direction.getPosition(node);

            // get the space around the node.

            var _getSpaceAroundNode2 = _this3._getSpaceAroundNode(node, branchMap),
                _getSpaceAroundNode3 = (0, _slicedToArray3['default'])(_getSpaceAroundNode2, 2),
                minSpaceNode = _getSpaceAroundNode3[0],
                maxSpaceNode = _getSpaceAroundNode3[1];

            minSpace = Math.min(minSpaceNode, minSpace);
            maxSpace = Math.min(maxSpaceNode, maxSpace);

            // the width is only relevant for the levels two nodes have in common. This is why we filter on this.
            if (level <= maxLevel) {
              min = Math.min(position, min);
              max = Math.max(position, max);
            }
          }
        }

        return [min, max, minSpace, maxSpace];
      };

      // check what the maximum level is these nodes have in common.
      var getCollisionLevel = function getCollisionLevel(node1, node2) {
        var maxLevel1 = _this3.hierarchical.getMaxLevel(node1.id);
        var maxLevel2 = _this3.hierarchical.getMaxLevel(node2.id);
        return Math.min(maxLevel1, maxLevel2);
      };

      /**
       * Condense elements. These can be nodes or branches depending on the callback.
       *
       * @param {function} callback
       * @param {Array.<number>} levels
       * @param {*} centerParents
       */
      var shiftElementsCloser = function shiftElementsCloser(callback, levels, centerParents) {
        var hier = _this3.hierarchical;

        for (var i = 0; i < levels.length; i++) {
          var level = levels[i];
          var levelNodes = hier.distributionOrdering[level];
          if (levelNodes.length > 1) {
            for (var j = 0; j < levelNodes.length - 1; j++) {
              var node1 = levelNodes[j];
              var node2 = levelNodes[j + 1];

              // NOTE: logic maintained as it was; if nodes have same ancestor,
              //       then of course they are in the same sub-network.
              if (hier.hasSameParent(node1, node2) && hier.inSameSubNetwork(node1, node2)) {
                callback(node1, node2, centerParents);
              }
            }
          }
        }
      };

      // callback for shifting branches
      var branchShiftCallback = function branchShiftCallback(node1, node2) {
        var centerParent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        //window.CALLBACKS.push(() => {
        var pos1 = _this3.direction.getPosition(node1);
        var pos2 = _this3.direction.getPosition(node2);
        var diffAbs = Math.abs(pos2 - pos1);
        var nodeSpacing = _this3.options.hierarchical.nodeSpacing;
        //console.log("NOW CHECKING:", node1.id, node2.id, diffAbs);
        if (diffAbs > nodeSpacing) {
          var branchNodes1 = {};
          var branchNodes2 = {};

          getBranchNodes(node1, branchNodes1);
          getBranchNodes(node2, branchNodes2);

          // check the largest distance between the branches
          var maxLevel = getCollisionLevel(node1, node2);
          var branchNodeBoundary1 = getBranchBoundary(branchNodes1, maxLevel);
          var branchNodeBoundary2 = getBranchBoundary(branchNodes2, maxLevel);
          var max1 = branchNodeBoundary1[1];
          var min2 = branchNodeBoundary2[0];
          var minSpace2 = branchNodeBoundary2[2];

          //console.log(node1.id, getBranchBoundary(branchNodes1, maxLevel), node2.id,
          //            getBranchBoundary(branchNodes2, maxLevel), maxLevel);
          var diffBranch = Math.abs(max1 - min2);
          if (diffBranch > nodeSpacing) {
            var offset = max1 - min2 + nodeSpacing;
            if (offset < -minSpace2 + nodeSpacing) {
              offset = -minSpace2 + nodeSpacing;
              //console.log("RESETTING OFFSET", max1 - min2 + this.options.hierarchical.nodeSpacing, -minSpace2, offset);
            }
            if (offset < 0) {
              //console.log("SHIFTING", node2.id, offset);
              _this3._shiftBlock(node2.id, offset);
              stillShifting = true;

              if (centerParent === true) _this3._centerParent(node2);
            }
          }
        }
        //this.body.emitter.emit("_redraw");})
      };

      var minimizeEdgeLength = function minimizeEdgeLength(iterations, node) {
        //window.CALLBACKS.push(() => {
        //  console.log("ts",node.id);
        var nodeId = node.id;
        var allEdges = node.edges;
        var nodeLevel = _this3.hierarchical.levels[node.id];

        // gather constants
        var C2 = _this3.options.hierarchical.levelSeparation * _this3.options.hierarchical.levelSeparation;
        var referenceNodes = {};
        var aboveEdges = [];
        for (var i = 0; i < allEdges.length; i++) {
          var edge = allEdges[i];
          if (edge.toId != edge.fromId) {
            var otherNode = edge.toId == nodeId ? edge.from : edge.to;
            referenceNodes[allEdges[i].id] = otherNode;
            if (_this3.hierarchical.levels[otherNode.id] < nodeLevel) {
              aboveEdges.push(edge);
            }
          }
        }

        // differentiated sum of lengths based on only moving one node over one axis
        var getFx = function getFx(point, edges) {
          var sum = 0;
          for (var _i2 = 0; _i2 < edges.length; _i2++) {
            if (referenceNodes[edges[_i2].id] !== undefined) {
              var a = _this3.direction.getPosition(referenceNodes[edges[_i2].id]) - point;
              sum += a / Math.sqrt(a * a + C2);
            }
          }
          return sum;
        };

        // doubly differentiated sum of lengths based on only moving one node over one axis
        var getDFx = function getDFx(point, edges) {
          var sum = 0;
          for (var _i3 = 0; _i3 < edges.length; _i3++) {
            if (referenceNodes[edges[_i3].id] !== undefined) {
              var a = _this3.direction.getPosition(referenceNodes[edges[_i3].id]) - point;
              sum -= C2 * Math.pow(a * a + C2, -1.5);
            }
          }
          return sum;
        };

        var getGuess = function getGuess(iterations, edges) {
          var guess = _this3.direction.getPosition(node);
          // Newton's method for optimization
          var guessMap = {};
          for (var _i4 = 0; _i4 < iterations; _i4++) {
            var fx = getFx(guess, edges);
            var dfx = getDFx(guess, edges);

            // we limit the movement to avoid instability.
            var limit = 40;
            var ratio = Math.max(-limit, Math.min(limit, Math.round(fx / dfx)));
            guess = guess - ratio;
            // reduce duplicates
            if (guessMap[guess] !== undefined) {
              break;
            }
            guessMap[guess] = _i4;
          }
          return guess;
        };

        var moveBranch = function moveBranch(guess) {
          // position node if there is space
          var nodePosition = _this3.direction.getPosition(node);

          // check movable area of the branch
          if (branches[node.id] === undefined) {
            var branchNodes = {};
            getBranchNodes(node, branchNodes);
            branches[node.id] = branchNodes;
          }
          var branchBoundary = getBranchBoundary(branches[node.id]);
          var minSpaceBranch = branchBoundary[2];
          var maxSpaceBranch = branchBoundary[3];

          var diff = guess - nodePosition;

          // check if we are allowed to move the node:
          var branchOffset = 0;
          if (diff > 0) {
            branchOffset = Math.min(diff, maxSpaceBranch - _this3.options.hierarchical.nodeSpacing);
          } else if (diff < 0) {
            branchOffset = -Math.min(-diff, minSpaceBranch - _this3.options.hierarchical.nodeSpacing);
          }

          if (branchOffset != 0) {
            //console.log("moving branch:",branchOffset, maxSpaceBranch, minSpaceBranch)
            _this3._shiftBlock(node.id, branchOffset);
            //this.body.emitter.emit("_redraw");
            stillShifting = true;
          }
        };

        var moveNode = function moveNode(guess) {
          var nodePosition = _this3.direction.getPosition(node);

          // position node if there is space

          var _getSpaceAroundNode4 = _this3._getSpaceAroundNode(node),
              _getSpaceAroundNode5 = (0, _slicedToArray3['default'])(_getSpaceAroundNode4, 2),
              minSpace = _getSpaceAroundNode5[0],
              maxSpace = _getSpaceAroundNode5[1];

          var diff = guess - nodePosition;
          // check if we are allowed to move the node:
          var newPosition = nodePosition;
          if (diff > 0) {
            newPosition = Math.min(nodePosition + (maxSpace - _this3.options.hierarchical.nodeSpacing), guess);
          } else if (diff < 0) {
            newPosition = Math.max(nodePosition - (minSpace - _this3.options.hierarchical.nodeSpacing), guess);
          }

          if (newPosition !== nodePosition) {
            //console.log("moving Node:",diff, minSpace, maxSpace);
            _this3.direction.setPosition(node, newPosition);
            //this.body.emitter.emit("_redraw");
            stillShifting = true;
          }
        };

        var guess = getGuess(iterations, aboveEdges);
        moveBranch(guess);
        guess = getGuess(iterations, allEdges);
        moveNode(guess);
        //})
      };

      // method to remove whitespace between branches. Because we do bottom up, we can center the parents.
      var minimizeEdgeLengthBottomUp = function minimizeEdgeLengthBottomUp(iterations) {
        var levels = _this3.hierarchical.getLevels();
        levels = levels.reverse();
        for (var i = 0; i < iterations; i++) {
          stillShifting = false;
          for (var j = 0; j < levels.length; j++) {
            var level = levels[j];
            var levelNodes = _this3.hierarchical.distributionOrdering[level];
            for (var k = 0; k < levelNodes.length; k++) {
              minimizeEdgeLength(1000, levelNodes[k]);
            }
          }
          if (stillShifting !== true) {
            //console.log("FINISHED minimizeEdgeLengthBottomUp IN " + i);
            break;
          }
        }
      };

      // method to remove whitespace between branches. Because we do bottom up, we can center the parents.
      var shiftBranchesCloserBottomUp = function shiftBranchesCloserBottomUp(iterations) {
        var levels = _this3.hierarchical.getLevels();
        levels = levels.reverse();
        for (var i = 0; i < iterations; i++) {
          stillShifting = false;
          shiftElementsCloser(branchShiftCallback, levels, true);
          if (stillShifting !== true) {
            //console.log("FINISHED shiftBranchesCloserBottomUp IN " + (i+1));
            break;
          }
        }
      };

      // center all parents
      var centerAllParents = function centerAllParents() {
        for (var nodeId in _this3.body.nodes) {
          if (_this3.body.nodes.hasOwnProperty(nodeId)) _this3._centerParent(_this3.body.nodes[nodeId]);
        }
      };

      // center all parents
      var centerAllParentsBottomUp = function centerAllParentsBottomUp() {
        var levels = _this3.hierarchical.getLevels();
        levels = levels.reverse();
        for (var i = 0; i < levels.length; i++) {
          var level = levels[i];
          var levelNodes = _this3.hierarchical.distributionOrdering[level];
          for (var j = 0; j < levelNodes.length; j++) {
            _this3._centerParent(levelNodes[j]);
          }
        }
      };

      // the actual work is done here.
      if (this.options.hierarchical.blockShifting === true) {
        shiftBranchesCloserBottomUp(5);
        centerAllParents();
      }

      // minimize edge length
      if (this.options.hierarchical.edgeMinimization === true) {
        minimizeEdgeLengthBottomUp(20);
      }

      if (this.options.hierarchical.parentCentralization === true) {
        centerAllParentsBottomUp();
      }

      shiftTrees();
    }

    /**
     * This gives the space around the node. IF a map is supplied, it will only check against nodes NOT in the map.
     * This is used to only get the distances to nodes outside of a branch.
     * @param {Node} node
     * @param {{Node.id: vis.Node}} map
     * @returns {number[]}
     * @private
     */

  }, {
    key: '_getSpaceAroundNode',
    value: function _getSpaceAroundNode(node, map) {
      var useMap = true;
      if (map === undefined) {
        useMap = false;
      }
      var level = this.hierarchical.levels[node.id];
      if (level !== undefined) {
        var index = this.hierarchical.distributionIndex[node.id];
        var position = this.direction.getPosition(node);
        var ordering = this.hierarchical.distributionOrdering[level];
        var minSpace = 1e9;
        var maxSpace = 1e9;
        if (index !== 0) {
          var prevNode = ordering[index - 1];
          if (useMap === true && map[prevNode.id] === undefined || useMap === false) {
            var prevPos = this.direction.getPosition(prevNode);
            minSpace = position - prevPos;
          }
        }

        if (index != ordering.length - 1) {
          var nextNode = ordering[index + 1];
          if (useMap === true && map[nextNode.id] === undefined || useMap === false) {
            var nextPos = this.direction.getPosition(nextNode);
            maxSpace = Math.min(maxSpace, nextPos - position);
          }
        }

        return [minSpace, maxSpace];
      } else {
        return [0, 0];
      }
    }

    /**
     * We use this method to center a parent node and check if it does not cross other nodes when it does.
     * @param {Node} node
     * @private
     */

  }, {
    key: '_centerParent',
    value: function _centerParent(node) {
      if (this.hierarchical.parentReference[node.id]) {
        var parents = this.hierarchical.parentReference[node.id];
        for (var i = 0; i < parents.length; i++) {
          var parentId = parents[i];
          var parentNode = this.body.nodes[parentId];
          var children = this.hierarchical.childrenReference[parentId];

          if (children !== undefined) {
            // get the range of the children
            var newPosition = this._getCenterPosition(children);

            var position = this.direction.getPosition(parentNode);

            var _getSpaceAroundNode6 = this._getSpaceAroundNode(parentNode),
                _getSpaceAroundNode7 = (0, _slicedToArray3['default'])(_getSpaceAroundNode6, 2),
                minSpace = _getSpaceAroundNode7[0],
                maxSpace = _getSpaceAroundNode7[1];

            var diff = position - newPosition;
            if (diff < 0 && Math.abs(diff) < maxSpace - this.options.hierarchical.nodeSpacing || diff > 0 && Math.abs(diff) < minSpace - this.options.hierarchical.nodeSpacing) {
              this.direction.setPosition(parentNode, newPosition);
            }
          }
        }
      }
    }

    /**
     * This function places the nodes on the canvas based on the hierarchial distribution.
     *
     * @param {Object} distribution | obtained by the function this._getDistribution()
     * @private
     */

  }, {
    key: '_placeNodesByHierarchy',
    value: function _placeNodesByHierarchy(distribution) {
      this.positionedNodes = {};
      // start placing all the level 0 nodes first. Then recursively position their branches.
      for (var level in distribution) {
        if (distribution.hasOwnProperty(level)) {
          // sort nodes in level by position:
          var nodeArray = (0, _keys2['default'])(distribution[level]);
          nodeArray = this._indexArrayToNodes(nodeArray);
          this.direction.sort(nodeArray);
          var handledNodeCount = 0;

          for (var i = 0; i < nodeArray.length; i++) {
            var node = nodeArray[i];
            if (this.positionedNodes[node.id] === undefined) {
              var spacing = this.options.hierarchical.nodeSpacing;
              var pos = spacing * handledNodeCount;
              // We get the X or Y values we need and store them in pos and previousPos.
              // The get and set make sure we get X or Y
              if (handledNodeCount > 0) {
                pos = this.direction.getPosition(nodeArray[i - 1]) + spacing;
              }
              this.direction.setPosition(node, pos, level);
              this._validatePositionAndContinue(node, level, pos);

              handledNodeCount++;
            }
          }
        }
      }
    }

    /**
     * This is a recursively called function to enumerate the branches from the largest hubs and place the nodes
     * on a X position that ensures there will be no overlap.
     *
     * @param {Node.id} parentId
     * @param {number} parentLevel
     * @private
     */

  }, {
    key: '_placeBranchNodes',
    value: function _placeBranchNodes(parentId, parentLevel) {
      var childRef = this.hierarchical.childrenReference[parentId];

      // if this is not a parent, cancel the placing. This can happen with multiple parents to one child.
      if (childRef === undefined) {
        return;
      }

      // get a list of childNodes
      var childNodes = [];
      for (var i = 0; i < childRef.length; i++) {
        childNodes.push(this.body.nodes[childRef[i]]);
      }

      // use the positions to order the nodes.
      this.direction.sort(childNodes);

      // position the childNodes
      for (var _i5 = 0; _i5 < childNodes.length; _i5++) {
        var childNode = childNodes[_i5];
        var childNodeLevel = this.hierarchical.levels[childNode.id];
        // check if the child node is below the parent node and if it has already been positioned.
        if (childNodeLevel > parentLevel && this.positionedNodes[childNode.id] === undefined) {
          // get the amount of space required for this node. If parent the width is based on the amount of children.
          var spacing = this.options.hierarchical.nodeSpacing;
          var pos = void 0;

          // we get the X or Y values we need and store them in pos and previousPos.
          // The get and set make sure we get X or Y
          if (_i5 === 0) {
            pos = this.direction.getPosition(this.body.nodes[parentId]);
          } else {
            pos = this.direction.getPosition(childNodes[_i5 - 1]) + spacing;
          }
          this.direction.setPosition(childNode, pos, childNodeLevel);
          this._validatePositionAndContinue(childNode, childNodeLevel, pos);
        } else {
          return;
        }
      }

      // center the parent nodes.
      var center = this._getCenterPosition(childNodes);
      this.direction.setPosition(this.body.nodes[parentId], center, parentLevel);
    }

    /**
     * This method checks for overlap and if required shifts the branch. It also keeps records of positioned nodes.
     * Finally it will call _placeBranchNodes to place the branch nodes.
     * @param {Node} node
     * @param {number} level
     * @param {number} pos
     * @private
     */

  }, {
    key: '_validatePositionAndContinue',
    value: function _validatePositionAndContinue(node, level, pos) {
      // This method only works for formal trees and formal forests
      // Early exit if this is not the case
      if (!this.hierarchical.isTree) return;

      // if overlap has been detected, we shift the branch
      if (this.lastNodeOnLevel[level] !== undefined) {
        var previousPos = this.direction.getPosition(this.body.nodes[this.lastNodeOnLevel[level]]);
        if (pos - previousPos < this.options.hierarchical.nodeSpacing) {
          var diff = previousPos + this.options.hierarchical.nodeSpacing - pos;
          var sharedParent = this._findCommonParent(this.lastNodeOnLevel[level], node.id);
          this._shiftBlock(sharedParent.withChild, diff);
        }
      }

      this.lastNodeOnLevel[level] = node.id; // store change in position.
      this.positionedNodes[node.id] = true;
      this._placeBranchNodes(node.id, level);
    }

    /**
     * Receives an array with node indices and returns an array with the actual node references.
     * Used for sorting based on node properties.
     * @param {Array.<Node.id>} idArray
     * @returns {Array.<Node>}
     */

  }, {
    key: '_indexArrayToNodes',
    value: function _indexArrayToNodes(idArray) {
      var array = [];
      for (var i = 0; i < idArray.length; i++) {
        array.push(this.body.nodes[idArray[i]]);
      }
      return array;
    }

    /**
     * This function get the distribution of levels based on hubsize
     *
     * @returns {Object}
     * @private
     */

  }, {
    key: '_getDistribution',
    value: function _getDistribution() {
      var distribution = {};
      var nodeId = void 0,
          node = void 0;

      // we fix Y because the hierarchy is vertical,
      // we fix X so we do not give a node an x position for a second time.
      // the fix of X is removed after the x value has been set.
      for (nodeId in this.body.nodes) {
        if (this.body.nodes.hasOwnProperty(nodeId)) {
          node = this.body.nodes[nodeId];
          var level = this.hierarchical.levels[nodeId] === undefined ? 0 : this.hierarchical.levels[nodeId];
          this.direction.fix(node, level);
          if (distribution[level] === undefined) {
            distribution[level] = {};
          }
          distribution[level][nodeId] = node;
        }
      }
      return distribution;
    }

    /**
     * Return the active (i.e. visible) edges for this node
     *
     * @param {Node} node
     * @returns {Array.<vis.Edge>} Array of edge instances
     * @private
     */

  }, {
    key: '_getActiveEdges',
    value: function _getActiveEdges(node) {
      var _this4 = this;

      var result = [];

      util.forEach(node.edges, function (edge) {
        if (_this4.body.edgeIndices.indexOf(edge.id) !== -1) {
          result.push(edge);
        }
      });

      return result;
    }

    /**
     * Get the hubsizes for all active nodes.
     *
     * @returns {number}
     * @private
     */

  }, {
    key: '_getHubSizes',
    value: function _getHubSizes() {
      var _this5 = this;

      var hubSizes = {};
      var nodeIds = this.body.nodeIndices;

      util.forEach(nodeIds, function (nodeId) {
        var node = _this5.body.nodes[nodeId];
        var hubSize = _this5._getActiveEdges(node).length;
        hubSizes[hubSize] = true;
      });

      // Make an array of the size sorted descending
      var result = [];
      util.forEach(hubSizes, function (size) {
        result.push(Number(size));
      });

      TimSort.sort(result, function (a, b) {
        return b - a;
      });

      return result;
    }

    /**
     * this function allocates nodes in levels based on the recursive branching from the largest hubs.
     *
     * @private
     */

  }, {
    key: '_determineLevelsByHubsize',
    value: function _determineLevelsByHubsize() {
      var _this6 = this;

      var levelDownstream = function levelDownstream(nodeA, nodeB) {
        _this6.hierarchical.levelDownstream(nodeA, nodeB);
      };

      var hubSizes = this._getHubSizes();

      var _loop = function _loop(i) {
        var hubSize = hubSizes[i];
        if (hubSize === 0) return 'break';

        util.forEach(_this6.body.nodeIndices, function (nodeId) {
          var node = _this6.body.nodes[nodeId];

          if (hubSize === _this6._getActiveEdges(node).length) {
            _this6._crawlNetwork(levelDownstream, nodeId);
          }
        });
      };

      for (var i = 0; i < hubSizes.length; ++i) {
        var _ret = _loop(i);

        if (_ret === 'break') break;
      }
    }

    /**
     * TODO: release feature
     * TODO: Determine if this feature is needed at all
     *
     * @private
     */

  }, {
    key: '_determineLevelsCustomCallback',
    value: function _determineLevelsCustomCallback() {
      var _this7 = this;

      var minLevel = 100000;

      // TODO: this should come from options.
      // eslint-disable-next-line no-unused-vars
      var customCallback = function customCallback(nodeA, nodeB, edge) {};

      // TODO: perhaps move to HierarchicalStatus.
      //       But I currently don't see the point, this method is not used.
      var levelByDirection = function levelByDirection(nodeA, nodeB, edge) {
        var levelA = _this7.hierarchical.levels[nodeA.id];
        // set initial level
        if (levelA === undefined) {
          levelA = _this7.hierarchical.levels[nodeA.id] = minLevel;
        }

        var diff = customCallback(NetworkUtil.cloneOptions(nodeA, 'node'), NetworkUtil.cloneOptions(nodeB, 'node'), NetworkUtil.cloneOptions(edge, 'edge'));

        _this7.hierarchical.levels[nodeB.id] = levelA + diff;
      };

      this._crawlNetwork(levelByDirection);
      this.hierarchical.setMinLevelToZero(this.body.nodes);
    }

    /**
     * Allocate nodes in levels based on the direction of the edges.
     *
     * @private
     */

  }, {
    key: '_determineLevelsDirected',
    value: function _determineLevelsDirected() {
      var _this8 = this;

      var minLevel = 10000;

      /**
       * Check if there is an edge going the opposite direction for given edge
       *
       * @param {Edge} edge  edge to check
       * @returns {boolean} true if there's another edge going into the opposite direction
       */
      var isBidirectional = function isBidirectional(edge) {
        util.forEach(_this8.body.edges, function (otherEdge) {
          if (otherEdge.toId === edge.fromId && otherEdge.fromId === edge.toId) {
            return true;
          }
        });

        return false;
      };

      var levelByDirection = function levelByDirection(nodeA, nodeB, edge) {
        var levelA = _this8.hierarchical.levels[nodeA.id];
        var levelB = _this8.hierarchical.levels[nodeB.id];

        if (isBidirectional(edge) && levelA !== undefined && levelB !== undefined) {
          // Don't redo the level determination if already done in this case.
          return;
        }

        // set initial level
        if (levelA === undefined) {
          levelA = _this8.hierarchical.levels[nodeA.id] = minLevel;
        }
        if (edge.toId == nodeB.id) {
          _this8.hierarchical.levels[nodeB.id] = levelA + 1;
        } else {
          _this8.hierarchical.levels[nodeB.id] = levelA - 1;
        }
      };

      this._crawlNetwork(levelByDirection);
      this.hierarchical.setMinLevelToZero(this.body.nodes);
    }

    /**
     * Update the bookkeeping of parent and child.
     * @private
     */

  }, {
    key: '_generateMap',
    value: function _generateMap() {
      var _this9 = this;

      var fillInRelations = function fillInRelations(parentNode, childNode) {
        if (_this9.hierarchical.levels[childNode.id] > _this9.hierarchical.levels[parentNode.id]) {
          _this9.hierarchical.addRelation(parentNode.id, childNode.id);
        }
      };

      this._crawlNetwork(fillInRelations);
      this.hierarchical.checkIfTree();
    }

    /**
     * Crawl over the entire network and use a callback on each node couple that is connected to each other.
     * @param {function} [callback=function(){}]          | will receive nodeA, nodeB and the connecting edge. A and B are distinct.
     * @param {Node.id} startingNodeId
     * @private
     */

  }, {
    key: '_crawlNetwork',
    value: function _crawlNetwork() {
      var _this10 = this;

      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};
      var startingNodeId = arguments[1];

      var progress = {};

      var crawler = function crawler(node, tree) {
        if (progress[node.id] === undefined) {
          _this10.hierarchical.setTreeIndex(node, tree);

          progress[node.id] = true;
          var childNode = void 0;
          var edges = _this10._getActiveEdges(node);
          for (var i = 0; i < edges.length; i++) {
            var edge = edges[i];
            if (edge.connected === true) {
              if (edge.toId == node.id) {
                // Not '===' because id's can be string and numeric
                childNode = edge.from;
              } else {
                childNode = edge.to;
              }

              if (node.id != childNode.id) {
                // Not '!==' because id's can be string and numeric
                callback(node, childNode, edge);
                crawler(childNode, tree);
              }
            }
          }
        }
      };

      if (startingNodeId === undefined) {
        // Crawl over all nodes
        var treeIndex = 0; // Serves to pass a unique id for the current distinct tree

        for (var i = 0; i < this.body.nodeIndices.length; i++) {
          var nodeId = this.body.nodeIndices[i];

          if (progress[nodeId] === undefined) {
            var node = this.body.nodes[nodeId];
            crawler(node, treeIndex);
            treeIndex += 1;
          }
        }
      } else {
        // Crawl from the given starting node
        var _node2 = this.body.nodes[startingNodeId];
        if (_node2 === undefined) {
          console.error('Node not found:', startingNodeId);
          return;
        }
        crawler(_node2);
      }
    }

    /**
     * Shift a branch a certain distance
     * @param {Node.id} parentId
     * @param {number} diff
     * @private
     */

  }, {
    key: '_shiftBlock',
    value: function _shiftBlock(parentId, diff) {
      var _this11 = this;

      var progress = {};
      var shifter = function shifter(parentId) {
        if (progress[parentId]) {
          return;
        }
        progress[parentId] = true;
        _this11.direction.shift(parentId, diff);

        var childRef = _this11.hierarchical.childrenReference[parentId];
        if (childRef !== undefined) {
          for (var i = 0; i < childRef.length; i++) {
            shifter(childRef[i]);
          }
        }
      };
      shifter(parentId);
    }

    /**
     * Find a common parent between branches.
     * @param {Node.id} childA
     * @param {Node.id} childB
     * @returns {{foundParent, withChild}}
     * @private
     */

  }, {
    key: '_findCommonParent',
    value: function _findCommonParent(childA, childB) {
      var _this12 = this;

      var parents = {};
      var iterateParents = function iterateParents(parents, child) {
        var parentRef = _this12.hierarchical.parentReference[child];
        if (parentRef !== undefined) {
          for (var i = 0; i < parentRef.length; i++) {
            var parent = parentRef[i];
            parents[parent] = true;
            iterateParents(parents, parent);
          }
        }
      };
      var findParent = function findParent(parents, child) {
        var parentRef = _this12.hierarchical.parentReference[child];
        if (parentRef !== undefined) {
          for (var i = 0; i < parentRef.length; i++) {
            var parent = parentRef[i];
            if (parents[parent] !== undefined) {
              return { foundParent: parent, withChild: child };
            }
            var branch = findParent(parents, parent);
            if (branch.foundParent !== null) {
              return branch;
            }
          }
        }
        return { foundParent: null, withChild: child };
      };

      iterateParents(parents, childA);
      return findParent(parents, childB);
    }

    /**
     * Set the strategy pattern for handling the coordinates given the current direction.
     *
     * The individual instances contain all the operations and data specific to a layout direction.
     *
     * @param {Node} node
     * @param {{x: number, y: number}} position
     * @param {number} level
     * @param {boolean} [doNotUpdate=false]
     * @private
     */

  }, {
    key: 'setDirectionStrategy',
    value: function setDirectionStrategy() {
      var isVertical = this.options.hierarchical.direction === 'UD' || this.options.hierarchical.direction === 'DU';

      if (isVertical) {
        this.direction = new VerticalStrategy(this);
      } else {
        this.direction = new HorizontalStrategy(this);
      }
    }

    /**
     * Determine the center position of a branch from the passed list of child nodes
     *
     * This takes into account the positions of all the child nodes.
     * @param {Array.<Node|vis.Node.id>} childNodes  Array of either child nodes or node id's
     * @return {number}
     * @private
     */

  }, {
    key: '_getCenterPosition',
    value: function _getCenterPosition(childNodes) {
      var minPos = 1e9;
      var maxPos = -1e9;

      for (var i = 0; i < childNodes.length; i++) {
        var childNode = void 0;
        if (childNodes[i].id !== undefined) {
          childNode = childNodes[i];
        } else {
          var childNodeId = childNodes[i];
          childNode = this.body.nodes[childNodeId];
        }

        var position = this.direction.getPosition(childNode);
        minPos = Math.min(minPos, position);
        maxPos = Math.max(maxPos, position);
      }

      return 0.5 * (minPos + maxPos);
    }
  }]);
  return LayoutEngine;
}();

exports['default'] = LayoutEngine;

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/****
 * The MIT License
 *
 * Copyright (c) 2015 Marco Ziccardi
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 ****/
(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (exports) {
  'use strict';

  exports.__esModule = true;
  exports.sort = sort;

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }

  var DEFAULT_MIN_MERGE = 32;

  var DEFAULT_MIN_GALLOPING = 7;

  var DEFAULT_TMP_STORAGE_LENGTH = 256;

  var POWERS_OF_TEN = [1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9];

  function log10(x) {
    if (x < 1e5) {
      if (x < 1e2) {
        return x < 1e1 ? 0 : 1;
      }

      if (x < 1e4) {
        return x < 1e3 ? 2 : 3;
      }

      return 4;
    }

    if (x < 1e7) {
      return x < 1e6 ? 5 : 6;
    }

    if (x < 1e9) {
      return x < 1e8 ? 7 : 8;
    }

    return 9;
  }

  function alphabeticalCompare(a, b) {
    if (a === b) {
      return 0;
    }

    if (~ ~a === a && ~ ~b === b) {
      if (a === 0 || b === 0) {
        return a < b ? -1 : 1;
      }

      if (a < 0 || b < 0) {
        if (b >= 0) {
          return -1;
        }

        if (a >= 0) {
          return 1;
        }

        a = -a;
        b = -b;
      }

      var al = log10(a);
      var bl = log10(b);

      var t = 0;

      if (al < bl) {
        a *= POWERS_OF_TEN[bl - al - 1];
        b /= 10;
        t = -1;
      } else if (al > bl) {
        b *= POWERS_OF_TEN[al - bl - 1];
        a /= 10;
        t = 1;
      }

      if (a === b) {
        return t;
      }

      return a < b ? -1 : 1;
    }

    var aStr = String(a);
    var bStr = String(b);

    if (aStr === bStr) {
      return 0;
    }

    return aStr < bStr ? -1 : 1;
  }

  function minRunLength(n) {
    var r = 0;

    while (n >= DEFAULT_MIN_MERGE) {
      r |= n & 1;
      n >>= 1;
    }

    return n + r;
  }

  function makeAscendingRun(array, lo, hi, compare) {
    var runHi = lo + 1;

    if (runHi === hi) {
      return 1;
    }

    if (compare(array[runHi++], array[lo]) < 0) {
      while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {
        runHi++;
      }

      reverseRun(array, lo, runHi);
    } else {
      while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {
        runHi++;
      }
    }

    return runHi - lo;
  }

  function reverseRun(array, lo, hi) {
    hi--;

    while (lo < hi) {
      var t = array[lo];
      array[lo++] = array[hi];
      array[hi--] = t;
    }
  }

  function binaryInsertionSort(array, lo, hi, start, compare) {
    if (start === lo) {
      start++;
    }

    for (; start < hi; start++) {
      var pivot = array[start];

      var left = lo;
      var right = start;

      while (left < right) {
        var mid = left + right >>> 1;

        if (compare(pivot, array[mid]) < 0) {
          right = mid;
        } else {
          left = mid + 1;
        }
      }

      var n = start - left;

      switch (n) {
        case 3:
          array[left + 3] = array[left + 2];

        case 2:
          array[left + 2] = array[left + 1];

        case 1:
          array[left + 1] = array[left];
          break;
        default:
          while (n > 0) {
            array[left + n] = array[left + n - 1];
            n--;
          }
      }

      array[left] = pivot;
    }
  }

  function gallopLeft(value, array, start, length, hint, compare) {
    var lastOffset = 0;
    var maxOffset = 0;
    var offset = 1;

    if (compare(value, array[start + hint]) > 0) {
      maxOffset = length - hint;

      while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {
        lastOffset = offset;
        offset = (offset << 1) + 1;

        if (offset <= 0) {
          offset = maxOffset;
        }
      }

      if (offset > maxOffset) {
        offset = maxOffset;
      }

      lastOffset += hint;
      offset += hint;
    } else {
      maxOffset = hint + 1;
      while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {
        lastOffset = offset;
        offset = (offset << 1) + 1;

        if (offset <= 0) {
          offset = maxOffset;
        }
      }
      if (offset > maxOffset) {
        offset = maxOffset;
      }

      var tmp = lastOffset;
      lastOffset = hint - offset;
      offset = hint - tmp;
    }

    lastOffset++;
    while (lastOffset < offset) {
      var m = lastOffset + (offset - lastOffset >>> 1);

      if (compare(value, array[start + m]) > 0) {
        lastOffset = m + 1;
      } else {
        offset = m;
      }
    }
    return offset;
  }

  function gallopRight(value, array, start, length, hint, compare) {
    var lastOffset = 0;
    var maxOffset = 0;
    var offset = 1;

    if (compare(value, array[start + hint]) < 0) {
      maxOffset = hint + 1;

      while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {
        lastOffset = offset;
        offset = (offset << 1) + 1;

        if (offset <= 0) {
          offset = maxOffset;
        }
      }

      if (offset > maxOffset) {
        offset = maxOffset;
      }

      var tmp = lastOffset;
      lastOffset = hint - offset;
      offset = hint - tmp;
    } else {
      maxOffset = length - hint;

      while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {
        lastOffset = offset;
        offset = (offset << 1) + 1;

        if (offset <= 0) {
          offset = maxOffset;
        }
      }

      if (offset > maxOffset) {
        offset = maxOffset;
      }

      lastOffset += hint;
      offset += hint;
    }

    lastOffset++;

    while (lastOffset < offset) {
      var m = lastOffset + (offset - lastOffset >>> 1);

      if (compare(value, array[start + m]) < 0) {
        offset = m;
      } else {
        lastOffset = m + 1;
      }
    }

    return offset;
  }

  var TimSort = (function () {
    function TimSort(array, compare) {
      _classCallCheck(this, TimSort);

      this.array = null;
      this.compare = null;
      this.minGallop = DEFAULT_MIN_GALLOPING;
      this.length = 0;
      this.tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;
      this.stackLength = 0;
      this.runStart = null;
      this.runLength = null;
      this.stackSize = 0;

      this.array = array;
      this.compare = compare;

      this.length = array.length;

      if (this.length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {
        this.tmpStorageLength = this.length >>> 1;
      }

      this.tmp = new Array(this.tmpStorageLength);

      this.stackLength = this.length < 120 ? 5 : this.length < 1542 ? 10 : this.length < 119151 ? 19 : 40;

      this.runStart = new Array(this.stackLength);
      this.runLength = new Array(this.stackLength);
    }

    TimSort.prototype.pushRun = function pushRun(runStart, runLength) {
      this.runStart[this.stackSize] = runStart;
      this.runLength[this.stackSize] = runLength;
      this.stackSize += 1;
    };

    TimSort.prototype.mergeRuns = function mergeRuns() {
      while (this.stackSize > 1) {
        var n = this.stackSize - 2;

        if (n >= 1 && this.runLength[n - 1] <= this.runLength[n] + this.runLength[n + 1] || n >= 2 && this.runLength[n - 2] <= this.runLength[n] + this.runLength[n - 1]) {

          if (this.runLength[n - 1] < this.runLength[n + 1]) {
            n--;
          }
        } else if (this.runLength[n] > this.runLength[n + 1]) {
          break;
        }
        this.mergeAt(n);
      }
    };

    TimSort.prototype.forceMergeRuns = function forceMergeRuns() {
      while (this.stackSize > 1) {
        var n = this.stackSize - 2;

        if (n > 0 && this.runLength[n - 1] < this.runLength[n + 1]) {
          n--;
        }

        this.mergeAt(n);
      }
    };

    TimSort.prototype.mergeAt = function mergeAt(i) {
      var compare = this.compare;
      var array = this.array;

      var start1 = this.runStart[i];
      var length1 = this.runLength[i];
      var start2 = this.runStart[i + 1];
      var length2 = this.runLength[i + 1];

      this.runLength[i] = length1 + length2;

      if (i === this.stackSize - 3) {
        this.runStart[i + 1] = this.runStart[i + 2];
        this.runLength[i + 1] = this.runLength[i + 2];
      }

      this.stackSize--;

      var k = gallopRight(array[start2], array, start1, length1, 0, compare);
      start1 += k;
      length1 -= k;

      if (length1 === 0) {
        return;
      }

      length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);

      if (length2 === 0) {
        return;
      }

      if (length1 <= length2) {
        this.mergeLow(start1, length1, start2, length2);
      } else {
        this.mergeHigh(start1, length1, start2, length2);
      }
    };

    TimSort.prototype.mergeLow = function mergeLow(start1, length1, start2, length2) {

      var compare = this.compare;
      var array = this.array;
      var tmp = this.tmp;
      var i = 0;

      for (i = 0; i < length1; i++) {
        tmp[i] = array[start1 + i];
      }

      var cursor1 = 0;
      var cursor2 = start2;
      var dest = start1;

      array[dest++] = array[cursor2++];

      if (--length2 === 0) {
        for (i = 0; i < length1; i++) {
          array[dest + i] = tmp[cursor1 + i];
        }
        return;
      }

      if (length1 === 1) {
        for (i = 0; i < length2; i++) {
          array[dest + i] = array[cursor2 + i];
        }
        array[dest + length2] = tmp[cursor1];
        return;
      }

      var minGallop = this.minGallop;

      while (true) {
        var count1 = 0;
        var count2 = 0;
        var exit = false;

        do {
          if (compare(array[cursor2], tmp[cursor1]) < 0) {
            array[dest++] = array[cursor2++];
            count2++;
            count1 = 0;

            if (--length2 === 0) {
              exit = true;
              break;
            }
          } else {
            array[dest++] = tmp[cursor1++];
            count1++;
            count2 = 0;
            if (--length1 === 1) {
              exit = true;
              break;
            }
          }
        } while ((count1 | count2) < minGallop);

        if (exit) {
          break;
        }

        do {
          count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);

          if (count1 !== 0) {
            for (i = 0; i < count1; i++) {
              array[dest + i] = tmp[cursor1 + i];
            }

            dest += count1;
            cursor1 += count1;
            length1 -= count1;
            if (length1 <= 1) {
              exit = true;
              break;
            }
          }

          array[dest++] = array[cursor2++];

          if (--length2 === 0) {
            exit = true;
            break;
          }

          count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);

          if (count2 !== 0) {
            for (i = 0; i < count2; i++) {
              array[dest + i] = array[cursor2 + i];
            }

            dest += count2;
            cursor2 += count2;
            length2 -= count2;

            if (length2 === 0) {
              exit = true;
              break;
            }
          }
          array[dest++] = tmp[cursor1++];

          if (--length1 === 1) {
            exit = true;
            break;
          }

          minGallop--;
        } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);

        if (exit) {
          break;
        }

        if (minGallop < 0) {
          minGallop = 0;
        }

        minGallop += 2;
      }

      this.minGallop = minGallop;

      if (minGallop < 1) {
        this.minGallop = 1;
      }

      if (length1 === 1) {
        for (i = 0; i < length2; i++) {
          array[dest + i] = array[cursor2 + i];
        }
        array[dest + length2] = tmp[cursor1];
      } else if (length1 === 0) {
        throw new Error('mergeLow preconditions were not respected');
      } else {
        for (i = 0; i < length1; i++) {
          array[dest + i] = tmp[cursor1 + i];
        }
      }
    };

    TimSort.prototype.mergeHigh = function mergeHigh(start1, length1, start2, length2) {
      var compare = this.compare;
      var array = this.array;
      var tmp = this.tmp;
      var i = 0;

      for (i = 0; i < length2; i++) {
        tmp[i] = array[start2 + i];
      }

      var cursor1 = start1 + length1 - 1;
      var cursor2 = length2 - 1;
      var dest = start2 + length2 - 1;
      var customCursor = 0;
      var customDest = 0;

      array[dest--] = array[cursor1--];

      if (--length1 === 0) {
        customCursor = dest - (length2 - 1);

        for (i = 0; i < length2; i++) {
          array[customCursor + i] = tmp[i];
        }

        return;
      }

      if (length2 === 1) {
        dest -= length1;
        cursor1 -= length1;
        customDest = dest + 1;
        customCursor = cursor1 + 1;

        for (i = length1 - 1; i >= 0; i--) {
          array[customDest + i] = array[customCursor + i];
        }

        array[dest] = tmp[cursor2];
        return;
      }

      var minGallop = this.minGallop;

      while (true) {
        var count1 = 0;
        var count2 = 0;
        var exit = false;

        do {
          if (compare(tmp[cursor2], array[cursor1]) < 0) {
            array[dest--] = array[cursor1--];
            count1++;
            count2 = 0;
            if (--length1 === 0) {
              exit = true;
              break;
            }
          } else {
            array[dest--] = tmp[cursor2--];
            count2++;
            count1 = 0;
            if (--length2 === 1) {
              exit = true;
              break;
            }
          }
        } while ((count1 | count2) < minGallop);

        if (exit) {
          break;
        }

        do {
          count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);

          if (count1 !== 0) {
            dest -= count1;
            cursor1 -= count1;
            length1 -= count1;
            customDest = dest + 1;
            customCursor = cursor1 + 1;

            for (i = count1 - 1; i >= 0; i--) {
              array[customDest + i] = array[customCursor + i];
            }

            if (length1 === 0) {
              exit = true;
              break;
            }
          }

          array[dest--] = tmp[cursor2--];

          if (--length2 === 1) {
            exit = true;
            break;
          }

          count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);

          if (count2 !== 0) {
            dest -= count2;
            cursor2 -= count2;
            length2 -= count2;
            customDest = dest + 1;
            customCursor = cursor2 + 1;

            for (i = 0; i < count2; i++) {
              array[customDest + i] = tmp[customCursor + i];
            }

            if (length2 <= 1) {
              exit = true;
              break;
            }
          }

          array[dest--] = array[cursor1--];

          if (--length1 === 0) {
            exit = true;
            break;
          }

          minGallop--;
        } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);

        if (exit) {
          break;
        }

        if (minGallop < 0) {
          minGallop = 0;
        }

        minGallop += 2;
      }

      this.minGallop = minGallop;

      if (minGallop < 1) {
        this.minGallop = 1;
      }

      if (length2 === 1) {
        dest -= length1;
        cursor1 -= length1;
        customDest = dest + 1;
        customCursor = cursor1 + 1;

        for (i = length1 - 1; i >= 0; i--) {
          array[customDest + i] = array[customCursor + i];
        }

        array[dest] = tmp[cursor2];
      } else if (length2 === 0) {
        throw new Error('mergeHigh preconditions were not respected');
      } else {
        customCursor = dest - (length2 - 1);
        for (i = 0; i < length2; i++) {
          array[customCursor + i] = tmp[i];
        }
      }
    };

    return TimSort;
  })();

  function sort(array, compare, lo, hi) {
    if (!Array.isArray(array)) {
      throw new TypeError('Can only sort arrays');
    }

    if (!compare) {
      compare = alphabeticalCompare;
    } else if (typeof compare !== 'function') {
      hi = lo;
      lo = compare;
      compare = alphabeticalCompare;
    }

    if (!lo) {
      lo = 0;
    }
    if (!hi) {
      hi = array.length;
    }

    var remaining = hi - lo;

    if (remaining < 2) {
      return;
    }

    var runLength = 0;

    if (remaining < DEFAULT_MIN_MERGE) {
      runLength = makeAscendingRun(array, lo, hi, compare);
      binaryInsertionSort(array, lo, hi, lo + runLength, compare);
      return;
    }

    var ts = new TimSort(array, compare);

    var minRun = minRunLength(remaining);

    do {
      runLength = makeAscendingRun(array, lo, hi, compare);
      if (runLength < minRun) {
        var force = remaining;
        if (force > minRun) {
          force = minRun;
        }

        binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);
        runLength = force;
      }

      ts.pushRun(lo, runLength);
      ts.mergeRuns();

      remaining -= runLength;
      lo += runLength;
    } while (remaining !== 0);

    ts.forceMergeRuns();
  }
});


/***/ }),
/* 189 */
/***/ (function(module, exports, __nested_webpack_require_1156316__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VerticalStrategy = exports.HorizontalStrategy = undefined;

var _getPrototypeOf = __nested_webpack_require_1156316__(3);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _possibleConstructorReturn2 = __nested_webpack_require_1156316__(4);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __nested_webpack_require_1156316__(5);

var _inherits3 = _interopRequireDefault(_inherits2);

var _classCallCheck2 = __nested_webpack_require_1156316__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_1156316__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * Helper classes for LayoutEngine.
 *
 * Strategy pattern for usage of direction methods for hierarchical layouts.
 */
var TimSort = __nested_webpack_require_1156316__(83);

/**
 * Interface definition for direction strategy classes.
 *
 * This class describes the interface for the Strategy
 * pattern classes used to differentiate horizontal and vertical
 * direction of hierarchical results.
 *
 * For a given direction, one coordinate will be 'fixed', meaning that it is
 * determined by level.
 * The other coordinate is 'unfixed', meaning that the nodes on a given level
 * can still move along that coordinate. So:
 *
 * - `vertical` layout: `x` unfixed, `y` fixed per level
 * - `horizontal` layout: `x` fixed per level, `y` unfixed
 *
 * The local methods are stubs and should be regarded as abstract.
 * Derived classes **must** implement all the methods themselves.
 *
 * @private
 */

var DirectionInterface = function () {
  function DirectionInterface() {
    (0, _classCallCheck3['default'])(this, DirectionInterface);
  }

  (0, _createClass3['default'])(DirectionInterface, [{
    key: 'abstract',

    /** @ignore **/
    value: function abstract() {
      throw new Error("Can't instantiate abstract class!");
    }

    /**
     * This is a dummy call which is used to suppress the jsdoc errors of type:
     *
     *   "'param' is assigned a value but never used"
     *
     * @ignore
     **/

  }, {
    key: 'fake_use',
    value: function fake_use() {}
    // Do nothing special


    /**
     * Type to use to translate dynamic curves to, in the case of hierarchical layout.
     * Dynamic curves do not work for these.
     *
     * The value should be perpendicular to the actual direction of the layout.
     *
     * @return {string} Direction, either 'vertical' or 'horizontal'
     */

  }, {
    key: 'curveType',
    value: function curveType() {
      return this.abstract();
    }

    /**
     * Return the value of the coordinate that is not fixed for this direction.
     *
     * @param {Node} node The node to read
     * @return {number} Value of the unfixed coordinate
     */

  }, {
    key: 'getPosition',
    value: function getPosition(node) {
      this.fake_use(node);
      return this.abstract();
    }

    /**
     * Set the value of the coordinate that is not fixed for this direction.
     *
     * @param {Node} node The node to adjust
     * @param {number} position
     * @param {number} [level] if specified, the hierarchy level that this node should be fixed to
     */

  }, {
    key: 'setPosition',
    value: function setPosition(node, position) {
      var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

      this.fake_use(node, position, level);
      this.abstract();
    }

    /**
     * Get the width of a tree.
     *
     * A `tree` here is a subset of nodes within the network which are not connected to other nodes,
     * only among themselves. In essence, it is a sub-network.
     *
     * @param {number} index The index number of a tree
     * @return {number} the width of a tree in the view coordinates
     */

  }, {
    key: 'getTreeSize',
    value: function getTreeSize(index) {
      this.fake_use(index);
      return this.abstract();
    }

    /**
     * Sort array of nodes on the unfixed coordinates.
     *
     * **Note:** chrome has non-stable sorting implementation, which
     * has a tendency to change the order of the array items,
     * even if the custom sort function returns 0.
     *
     * For this reason, an external sort implementation is used,
     * which has the added benefit of being faster than the standard
     * platforms implementation. This has been verified on `node.js`,
     * `firefox` and `chrome` (all linux).
     *
     * @param {Array.<Node>} nodeArray array of nodes to sort
     */

  }, {
    key: 'sort',
    value: function sort(nodeArray) {
      this.fake_use(nodeArray);
      this.abstract();
    }

    /**
     * Assign the fixed coordinate of the node to the given level
     *
     * @param {Node} node The node to adjust
     * @param {number} level The level to fix to
     */

  }, {
    key: 'fix',
    value: function fix(node, level) {
      this.fake_use(node, level);
      this.abstract();
    }

    /**
     * Add an offset to the unfixed coordinate of the given node.
     *
     * @param {NodeId} nodeId Id of the node to adjust
     * @param {number} diff Offset to add to the unfixed coordinate
     */

  }, {
    key: 'shift',
    value: function shift(nodeId, diff) {
      this.fake_use(nodeId, diff);
      this.abstract();
    }
  }]);
  return DirectionInterface;
}();

/**
 * Vertical Strategy
 *
 * Coordinate `y` is fixed on levels, coordinate `x` is unfixed.
 *
 * @extends DirectionInterface
 * @private
 */


var VerticalStrategy = function (_DirectionInterface) {
  (0, _inherits3['default'])(VerticalStrategy, _DirectionInterface);

  /**
   * Constructor
   *
   * @param {Object} layout reference to the parent LayoutEngine instance.
   */
  function VerticalStrategy(layout) {
    (0, _classCallCheck3['default'])(this, VerticalStrategy);

    var _this = (0, _possibleConstructorReturn3['default'])(this, (VerticalStrategy.__proto__ || (0, _getPrototypeOf2['default'])(VerticalStrategy)).call(this));

    _this.layout = layout;
    return _this;
  }

  /** @inheritdoc */


  (0, _createClass3['default'])(VerticalStrategy, [{
    key: 'curveType',
    value: function curveType() {
      return 'horizontal';
    }

    /** @inheritdoc */

  }, {
    key: 'getPosition',
    value: function getPosition(node) {
      return node.x;
    }

    /** @inheritdoc */

  }, {
    key: 'setPosition',
    value: function setPosition(node, position) {
      var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

      if (level !== undefined) {
        this.layout.hierarchical.addToOrdering(node, level);
      }
      node.x = position;
    }

    /** @inheritdoc */

  }, {
    key: 'getTreeSize',
    value: function getTreeSize(index) {
      var res = this.layout.hierarchical.getTreeSize(this.layout.body.nodes, index);
      return { min: res.min_x, max: res.max_x };
    }

    /** @inheritdoc */

  }, {
    key: 'sort',
    value: function sort(nodeArray) {
      TimSort.sort(nodeArray, function (a, b) {
        return a.x - b.x;
      });
    }

    /** @inheritdoc */

  }, {
    key: 'fix',
    value: function fix(node, level) {
      node.y = this.layout.options.hierarchical.levelSeparation * level;
      node.options.fixed.y = true;
    }

    /** @inheritdoc */

  }, {
    key: 'shift',
    value: function shift(nodeId, diff) {
      this.layout.body.nodes[nodeId].x += diff;
    }
  }]);
  return VerticalStrategy;
}(DirectionInterface);

/**
 * Horizontal Strategy
 *
 * Coordinate `x` is fixed on levels, coordinate `y` is unfixed.
 *
 * @extends DirectionInterface
 * @private
 */


var HorizontalStrategy = function (_DirectionInterface2) {
  (0, _inherits3['default'])(HorizontalStrategy, _DirectionInterface2);

  /**
   * Constructor
   *
   * @param {Object} layout reference to the parent LayoutEngine instance.
   */
  function HorizontalStrategy(layout) {
    (0, _classCallCheck3['default'])(this, HorizontalStrategy);

    var _this2 = (0, _possibleConstructorReturn3['default'])(this, (HorizontalStrategy.__proto__ || (0, _getPrototypeOf2['default'])(HorizontalStrategy)).call(this));

    _this2.layout = layout;
    return _this2;
  }

  /** @inheritdoc */


  (0, _createClass3['default'])(HorizontalStrategy, [{
    key: 'curveType',
    value: function curveType() {
      return 'vertical';
    }

    /** @inheritdoc */

  }, {
    key: 'getPosition',
    value: function getPosition(node) {
      return node.y;
    }

    /** @inheritdoc */

  }, {
    key: 'setPosition',
    value: function setPosition(node, position) {
      var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

      if (level !== undefined) {
        this.layout.hierarchical.addToOrdering(node, level);
      }
      node.y = position;
    }

    /** @inheritdoc */

  }, {
    key: 'getTreeSize',
    value: function getTreeSize(index) {
      var res = this.layout.hierarchical.getTreeSize(this.layout.body.nodes, index);
      return { min: res.min_y, max: res.max_y };
    }

    /** @inheritdoc */

  }, {
    key: 'sort',
    value: function sort(nodeArray) {
      TimSort.sort(nodeArray, function (a, b) {
        return a.y - b.y;
      });
    }

    /** @inheritdoc */

  }, {
    key: 'fix',
    value: function fix(node, level) {
      node.x = this.layout.options.hierarchical.levelSeparation * level;
      node.options.fixed.x = true;
    }

    /** @inheritdoc */

  }, {
    key: 'shift',
    value: function shift(nodeId, diff) {
      this.layout.body.nodes[nodeId].y += diff;
    }
  }]);
  return HorizontalStrategy;
}(DirectionInterface);

exports.HorizontalStrategy = HorizontalStrategy;
exports.VerticalStrategy = VerticalStrategy;

/***/ }),
/* 190 */
/***/ (function(module, exports, __nested_webpack_require_1166276__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __nested_webpack_require_1166276__(9);

var _keys2 = _interopRequireDefault(_keys);

var _stringify = __nested_webpack_require_1166276__(23);

var _stringify2 = _interopRequireDefault(_stringify);

var _typeof2 = __nested_webpack_require_1166276__(7);

var _typeof3 = _interopRequireDefault(_typeof2);

var _classCallCheck2 = __nested_webpack_require_1166276__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_1166276__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var util = __nested_webpack_require_1166276__(2);
var Hammer = __nested_webpack_require_1166276__(24);
var hammerUtil = __nested_webpack_require_1166276__(36);

/**
 * Clears the toolbar div element of children
 *
 * @private
 */

var ManipulationSystem = function () {
  /**
   * @param {Object} body
   * @param {Canvas} canvas
   * @param {SelectionHandler} selectionHandler
   */
  function ManipulationSystem(body, canvas, selectionHandler) {
    var _this = this;

    (0, _classCallCheck3['default'])(this, ManipulationSystem);

    this.body = body;
    this.canvas = canvas;
    this.selectionHandler = selectionHandler;

    this.editMode = false;
    this.manipulationDiv = undefined;
    this.editModeDiv = undefined;
    this.closeDiv = undefined;

    this.manipulationHammers = [];
    this.temporaryUIFunctions = {};
    this.temporaryEventFunctions = [];

    this.touchTime = 0;
    this.temporaryIds = { nodes: [], edges: [] };
    this.guiEnabled = false;
    this.inMode = false;
    this.selectedControlNode = undefined;

    this.options = {};
    this.defaultOptions = {
      enabled: false,
      initiallyActive: false,
      addNode: true,
      addEdge: true,
      editNode: undefined,
      editEdge: true,
      deleteNode: true,
      deleteEdge: true,
      controlNodeStyle: {
        shape: 'dot',
        size: 6,
        color: {
          background: '#ff0000',
          border: '#3c3c3c',
          highlight: { background: '#07f968', border: '#3c3c3c' }
        },
        borderWidth: 2,
        borderWidthSelected: 2
      }
    };
    util.extend(this.options, this.defaultOptions);

    this.body.emitter.on('destroy', function () {
      _this._clean();
    });
    this.body.emitter.on('_dataChanged', this._restore.bind(this));
    this.body.emitter.on('_resetData', this._restore.bind(this));
  }

  /**
   * If something changes in the data during editing, switch back to the initial datamanipulation state and close all edit modes.
   * @private
   */


  (0, _createClass3['default'])(ManipulationSystem, [{
    key: '_restore',
    value: function _restore() {
      if (this.inMode !== false) {
        if (this.options.initiallyActive === true) {
          this.enableEditMode();
        } else {
          this.disableEditMode();
        }
      }
    }

    /**
     * Set the Options
     *
     * @param {Object} options
     * @param {Object} allOptions
     * @param {Object} globalOptions
     */

  }, {
    key: 'setOptions',
    value: function setOptions(options, allOptions, globalOptions) {
      if (allOptions !== undefined) {
        if (allOptions.locale !== undefined) {
          this.options.locale = allOptions.locale;
        } else {
          this.options.locale = globalOptions.locale;
        }
        if (allOptions.locales !== undefined) {
          this.options.locales = allOptions.locales;
        } else {
          this.options.locales = globalOptions.locales;
        }
      }

      if (options !== undefined) {
        if (typeof options === 'boolean') {
          this.options.enabled = options;
        } else {
          this.options.enabled = true;
          util.deepExtend(this.options, options);
        }
        if (this.options.initiallyActive === true) {
          this.editMode = true;
        }
        this._setup();
      }
    }

    /**
     * Enable or disable edit-mode. Draws the DOM required and cleans up after itself.
     *
     * @private
     */

  }, {
    key: 'toggleEditMode',
    value: function toggleEditMode() {
      if (this.editMode === true) {
        this.disableEditMode();
      } else {
        this.enableEditMode();
      }
    }

    /**
     * Enables Edit Mode
     */

  }, {
    key: 'enableEditMode',
    value: function enableEditMode() {
      this.editMode = true;

      this._clean();
      if (this.guiEnabled === true) {
        this.manipulationDiv.style.display = 'block';
        this.closeDiv.style.display = 'block';
        this.editModeDiv.style.display = 'none';
        this.showManipulatorToolbar();
      }
    }

    /**
     * Disables Edit Mode
     */

  }, {
    key: 'disableEditMode',
    value: function disableEditMode() {
      this.editMode = false;

      this._clean();
      if (this.guiEnabled === true) {
        this.manipulationDiv.style.display = 'none';
        this.closeDiv.style.display = 'none';
        this.editModeDiv.style.display = 'block';
        this._createEditButton();
      }
    }

    /**
     * Creates the main toolbar. Removes functions bound to the select event. Binds all the buttons of the toolbar.
     *
     * @private
     */

  }, {
    key: 'showManipulatorToolbar',
    value: function showManipulatorToolbar() {
      // restore the state of any bound functions or events, remove control nodes, restore physics
      this._clean();

      // reset global variables
      this.manipulationDOM = {};

      // if the gui is enabled, draw all elements.
      if (this.guiEnabled === true) {
        // a _restore will hide these menus
        this.editMode = true;
        this.manipulationDiv.style.display = 'block';
        this.closeDiv.style.display = 'block';

        var selectedNodeCount = this.selectionHandler._getSelectedNodeCount();
        var selectedEdgeCount = this.selectionHandler._getSelectedEdgeCount();
        var selectedTotalCount = selectedNodeCount + selectedEdgeCount;
        var locale = this.options.locales[this.options.locale];
        var needSeperator = false;

        if (this.options.addNode !== false) {
          this._createAddNodeButton(locale);
          needSeperator = true;
        }
        if (this.options.addEdge !== false) {
          if (needSeperator === true) {
            this._createSeperator(1);
          } else {
            needSeperator = true;
          }
          this._createAddEdgeButton(locale);
        }

        if (selectedNodeCount === 1 && typeof this.options.editNode === 'function') {
          if (needSeperator === true) {
            this._createSeperator(2);
          } else {
            needSeperator = true;
          }
          this._createEditNodeButton(locale);
        } else if (selectedEdgeCount === 1 && selectedNodeCount === 0 && this.options.editEdge !== false) {
          if (needSeperator === true) {
            this._createSeperator(3);
          } else {
            needSeperator = true;
          }
          this._createEditEdgeButton(locale);
        }

        // remove buttons
        if (selectedTotalCount !== 0) {
          if (selectedNodeCount > 0 && this.options.deleteNode !== false) {
            if (needSeperator === true) {
              this._createSeperator(4);
            }
            this._createDeleteButton(locale);
          } else if (selectedNodeCount === 0 && this.options.deleteEdge !== false) {
            if (needSeperator === true) {
              this._createSeperator(4);
            }
            this._createDeleteButton(locale);
          }
        }

        // bind the close button
        this._bindHammerToDiv(this.closeDiv, this.toggleEditMode.bind(this));

        // refresh this bar based on what has been selected
        this._temporaryBindEvent('select', this.showManipulatorToolbar.bind(this));
      }

      // redraw to show any possible changes
      this.body.emitter.emit('_redraw');
    }

    /**
     * Create the toolbar for adding Nodes
     */

  }, {
    key: 'addNodeMode',
    value: function addNodeMode() {
      // when using the gui, enable edit mode if it wasnt already.
      if (this.editMode !== true) {
        this.enableEditMode();
      }

      // restore the state of any bound functions or events, remove control nodes, restore physics
      this._clean();

      this.inMode = 'addNode';
      if (this.guiEnabled === true) {
        var locale = this.options.locales[this.options.locale];
        this.manipulationDOM = {};
        this._createBackButton(locale);
        this._createSeperator();
        this._createDescription(locale['addDescription'] || this.options.locales['en']['addDescription']);

        // bind the close button
        this._bindHammerToDiv(this.closeDiv, this.toggleEditMode.bind(this));
      }

      this._temporaryBindEvent('click', this._performAddNode.bind(this));
    }

    /**
     * call the bound function to handle the editing of the node. The node has to be selected.
     */

  }, {
    key: 'editNode',
    value: function editNode() {
      var _this2 = this;

      // when using the gui, enable edit mode if it wasnt already.
      if (this.editMode !== true) {
        this.enableEditMode();
      }

      // restore the state of any bound functions or events, remove control nodes, restore physics
      this._clean();
      var node = this.selectionHandler._getSelectedNode();
      if (node !== undefined) {
        this.inMode = 'editNode';
        if (typeof this.options.editNode === 'function') {
          if (node.isCluster !== true) {
            var data = util.deepExtend({}, node.options, false);
            data.x = node.x;
            data.y = node.y;

            if (this.options.editNode.length === 2) {
              this.options.editNode(data, function (finalizedData) {
                if (finalizedData !== null && finalizedData !== undefined && _this2.inMode === 'editNode') {
                  // if for whatever reason the mode has changes (due to dataset change) disregard the callback) {
                  _this2.body.data.nodes.getDataSet().update(finalizedData);
                }
                _this2.showManipulatorToolbar();
              });
            } else {
              throw new Error('The function for edit does not support two arguments (data, callback)');
            }
          } else {
            alert(this.options.locales[this.options.locale]['editClusterError'] || this.options.locales['en']['editClusterError']);
          }
        } else {
          throw new Error('No function has been configured to handle the editing of nodes.');
        }
      } else {
        this.showManipulatorToolbar();
      }
    }

    /**
     * create the toolbar to connect nodes
     */

  }, {
    key: 'addEdgeMode',
    value: function addEdgeMode() {
      // when using the gui, enable edit mode if it wasnt already.
      if (this.editMode !== true) {
        this.enableEditMode();
      }

      // restore the state of any bound functions or events, remove control nodes, restore physics
      this._clean();

      this.inMode = 'addEdge';
      if (this.guiEnabled === true) {
        var locale = this.options.locales[this.options.locale];
        this.manipulationDOM = {};
        this._createBackButton(locale);
        this._createSeperator();
        this._createDescription(locale['edgeDescription'] || this.options.locales['en']['edgeDescription']);

        // bind the close button
        this._bindHammerToDiv(this.closeDiv, this.toggleEditMode.bind(this));
      }

      // temporarily overload functions
      this._temporaryBindUI('onTouch', this._handleConnect.bind(this));
      this._temporaryBindUI('onDragEnd', this._finishConnect.bind(this));
      this._temporaryBindUI('onDrag', this._dragControlNode.bind(this));
      this._temporaryBindUI('onRelease', this._finishConnect.bind(this));
      this._temporaryBindUI('onDragStart', this._dragStartEdge.bind(this));
      this._temporaryBindUI('onHold', function () {});
    }

    /**
     * create the toolbar to edit edges
     */

  }, {
    key: 'editEdgeMode',
    value: function editEdgeMode() {
      // when using the gui, enable edit mode if it wasn't already.
      if (this.editMode !== true) {
        this.enableEditMode();
      }

      // restore the state of any bound functions or events, remove control nodes, restore physics
      this._clean();

      this.inMode = 'editEdge';
      if ((0, _typeof3['default'])(this.options.editEdge) === 'object' && typeof this.options.editEdge.editWithoutDrag === 'function') {
        this.edgeBeingEditedId = this.selectionHandler.getSelectedEdges()[0];
        if (this.edgeBeingEditedId !== undefined) {
          var edge = this.body.edges[this.edgeBeingEditedId];
          this._performEditEdge(edge.from, edge.to);
          return;
        }
      }
      if (this.guiEnabled === true) {
        var locale = this.options.locales[this.options.locale];
        this.manipulationDOM = {};
        this._createBackButton(locale);
        this._createSeperator();
        this._createDescription(locale['editEdgeDescription'] || this.options.locales['en']['editEdgeDescription']);

        // bind the close button
        this._bindHammerToDiv(this.closeDiv, this.toggleEditMode.bind(this));
      }

      this.edgeBeingEditedId = this.selectionHandler.getSelectedEdges()[0];
      if (this.edgeBeingEditedId !== undefined) {
        var _edge = this.body.edges[this.edgeBeingEditedId];

        // create control nodes
        var controlNodeFrom = this._getNewTargetNode(_edge.from.x, _edge.from.y);
        var controlNodeTo = this._getNewTargetNode(_edge.to.x, _edge.to.y);

        this.temporaryIds.nodes.push(controlNodeFrom.id);
        this.temporaryIds.nodes.push(controlNodeTo.id);

        this.body.nodes[controlNodeFrom.id] = controlNodeFrom;
        this.body.nodeIndices.push(controlNodeFrom.id);
        this.body.nodes[controlNodeTo.id] = controlNodeTo;
        this.body.nodeIndices.push(controlNodeTo.id);

        // temporarily overload UI functions, cleaned up automatically because of _temporaryBindUI
        this._temporaryBindUI('onTouch', this._controlNodeTouch.bind(this)); // used to get the position
        this._temporaryBindUI('onTap', function () {}); // disabled
        this._temporaryBindUI('onHold', function () {}); // disabled
        this._temporaryBindUI('onDragStart', this._controlNodeDragStart.bind(this)); // used to select control node
        this._temporaryBindUI('onDrag', this._controlNodeDrag.bind(this)); // used to drag control node
        this._temporaryBindUI('onDragEnd', this._controlNodeDragEnd.bind(this)); // used to connect or revert control nodes
        this._temporaryBindUI('onMouseMove', function () {}); // disabled

        // create function to position control nodes correctly on movement
        // automatically cleaned up because we use the temporary bind
        this._temporaryBindEvent('beforeDrawing', function (ctx) {
          var positions = _edge.edgeType.findBorderPositions(ctx);
          if (controlNodeFrom.selected === false) {
            controlNodeFrom.x = positions.from.x;
            controlNodeFrom.y = positions.from.y;
          }
          if (controlNodeTo.selected === false) {
            controlNodeTo.x = positions.to.x;
            controlNodeTo.y = positions.to.y;
          }
        });

        this.body.emitter.emit('_redraw');
      } else {
        this.showManipulatorToolbar();
      }
    }

    /**
     * delete everything in the selection
     */

  }, {
    key: 'deleteSelected',
    value: function deleteSelected() {
      var _this3 = this;

      // when using the gui, enable edit mode if it wasnt already.
      if (this.editMode !== true) {
        this.enableEditMode();
      }

      // restore the state of any bound functions or events, remove control nodes, restore physics
      this._clean();

      this.inMode = 'delete';
      var selectedNodes = this.selectionHandler.getSelectedNodes();
      var selectedEdges = this.selectionHandler.getSelectedEdges();
      var deleteFunction = undefined;
      if (selectedNodes.length > 0) {
        for (var i = 0; i < selectedNodes.length; i++) {
          if (this.body.nodes[selectedNodes[i]].isCluster === true) {
            alert(this.options.locales[this.options.locale]['deleteClusterError'] || this.options.locales['en']['deleteClusterError']);
            return;
          }
        }

        if (typeof this.options.deleteNode === 'function') {
          deleteFunction = this.options.deleteNode;
        }
      } else if (selectedEdges.length > 0) {
        if (typeof this.options.deleteEdge === 'function') {
          deleteFunction = this.options.deleteEdge;
        }
      }

      if (typeof deleteFunction === 'function') {
        var data = { nodes: selectedNodes, edges: selectedEdges };
        if (deleteFunction.length === 2) {
          deleteFunction(data, function (finalizedData) {
            if (finalizedData !== null && finalizedData !== undefined && _this3.inMode === 'delete') {
              // if for whatever reason the mode has changes (due to dataset change) disregard the callback) {
              _this3.body.data.edges.getDataSet().remove(finalizedData.edges);
              _this3.body.data.nodes.getDataSet().remove(finalizedData.nodes);
              _this3.body.emitter.emit('startSimulation');
              _this3.showManipulatorToolbar();
            } else {
              _this3.body.emitter.emit('startSimulation');
              _this3.showManipulatorToolbar();
            }
          });
        } else {
          throw new Error('The function for delete does not support two arguments (data, callback)');
        }
      } else {
        this.body.data.edges.getDataSet().remove(selectedEdges);
        this.body.data.nodes.getDataSet().remove(selectedNodes);
        this.body.emitter.emit('startSimulation');
        this.showManipulatorToolbar();
      }
    }

    //********************************************** PRIVATE ***************************************//

    /**
     * draw or remove the DOM
     * @private
     */

  }, {
    key: '_setup',
    value: function _setup() {
      if (this.options.enabled === true) {
        // Enable the GUI
        this.guiEnabled = true;

        this._createWrappers();
        if (this.editMode === false) {
          this._createEditButton();
        } else {
          this.showManipulatorToolbar();
        }
      } else {
        this._removeManipulationDOM();

        // disable the gui
        this.guiEnabled = false;
      }
    }

    /**
     * create the div overlays that contain the DOM
     * @private
     */

  }, {
    key: '_createWrappers',
    value: function _createWrappers() {
      // load the manipulator HTML elements. All styling done in css.
      if (this.manipulationDiv === undefined) {
        this.manipulationDiv = document.createElement('div');
        this.manipulationDiv.className = 'vis-manipulation';
        if (this.editMode === true) {
          this.manipulationDiv.style.display = 'block';
        } else {
          this.manipulationDiv.style.display = 'none';
        }
        this.canvas.frame.appendChild(this.manipulationDiv);
      }

      // container for the edit button.
      if (this.editModeDiv === undefined) {
        this.editModeDiv = document.createElement('div');
        this.editModeDiv.className = 'vis-edit-mode';
        if (this.editMode === true) {
          this.editModeDiv.style.display = 'none';
        } else {
          this.editModeDiv.style.display = 'block';
        }
        this.canvas.frame.appendChild(this.editModeDiv);
      }

      // container for the close div button
      if (this.closeDiv === undefined) {
        this.closeDiv = document.createElement('div');
        this.closeDiv.className = 'vis-close';
        this.closeDiv.style.display = this.manipulationDiv.style.display;
        this.canvas.frame.appendChild(this.closeDiv);
      }
    }

    /**
     * generate a new target node. Used for creating new edges and editing edges
     *
     * @param {number} x
     * @param {number} y
     * @returns {Node}
     * @private
     */

  }, {
    key: '_getNewTargetNode',
    value: function _getNewTargetNode(x, y) {
      var controlNodeStyle = util.deepExtend({}, this.options.controlNodeStyle);

      controlNodeStyle.id = 'targetNode' + util.randomUUID();
      controlNodeStyle.hidden = false;
      controlNodeStyle.physics = false;
      controlNodeStyle.x = x;
      controlNodeStyle.y = y;

      // we have to define the bounding box in order for the nodes to be drawn immediately
      var node = this.body.functions.createNode(controlNodeStyle);
      node.shape.boundingBox = { left: x, right: x, top: y, bottom: y };

      return node;
    }

    /**
     * Create the edit button
     */

  }, {
    key: '_createEditButton',
    value: function _createEditButton() {
      // restore everything to it's original state (if applicable)
      this._clean();

      // reset the manipulationDOM
      this.manipulationDOM = {};

      // empty the editModeDiv
      util.recursiveDOMDelete(this.editModeDiv);

      // create the contents for the editMode button
      var locale = this.options.locales[this.options.locale];
      var button = this._createButton('editMode', 'vis-button vis-edit vis-edit-mode', locale['edit'] || this.options.locales['en']['edit']);
      this.editModeDiv.appendChild(button);

      // bind a hammer listener to the button, calling the function toggleEditMode.
      this._bindHammerToDiv(button, this.toggleEditMode.bind(this));
    }

    /**
     * this function cleans up after everything this module does. Temporary elements, functions and events are removed, physics restored, hammers removed.
     * @private
     */

  }, {
    key: '_clean',
    value: function _clean() {
      // not in mode
      this.inMode = false;

      // _clean the divs
      if (this.guiEnabled === true) {
        util.recursiveDOMDelete(this.editModeDiv);
        util.recursiveDOMDelete(this.manipulationDiv);

        // removes all the bindings and overloads
        this._cleanManipulatorHammers();
      }

      // remove temporary nodes and edges
      this._cleanupTemporaryNodesAndEdges();

      // restore overloaded UI functions
      this._unbindTemporaryUIs();

      // remove the temporaryEventFunctions
      this._unbindTemporaryEvents();

      // restore the physics if required
      this.body.emitter.emit('restorePhysics');
    }

    /**
     * Each dom element has it's own hammer. They are stored in this.manipulationHammers. This cleans them up.
     * @private
     */

  }, {
    key: '_cleanManipulatorHammers',
    value: function _cleanManipulatorHammers() {
      // _clean hammer bindings
      if (this.manipulationHammers.length != 0) {
        for (var i = 0; i < this.manipulationHammers.length; i++) {
          this.manipulationHammers[i].destroy();
        }
        this.manipulationHammers = [];
      }
    }

    /**
     * Remove all DOM elements created by this module.
     * @private
     */

  }, {
    key: '_removeManipulationDOM',
    value: function _removeManipulationDOM() {
      // removes all the bindings and overloads
      this._clean();

      // empty the manipulation divs
      util.recursiveDOMDelete(this.manipulationDiv);
      util.recursiveDOMDelete(this.editModeDiv);
      util.recursiveDOMDelete(this.closeDiv);

      // remove the manipulation divs
      if (this.manipulationDiv) {
        this.canvas.frame.removeChild(this.manipulationDiv);
      }
      if (this.editModeDiv) {
        this.canvas.frame.removeChild(this.editModeDiv);
      }
      if (this.closeDiv) {
        this.canvas.frame.removeChild(this.closeDiv);
      }

      // set the references to undefined
      this.manipulationDiv = undefined;
      this.editModeDiv = undefined;
      this.closeDiv = undefined;
    }

    /**
     * create a seperator line. the index is to differentiate in the manipulation dom
     * @param {number} [index=1]
     * @private
     */

  }, {
    key: '_createSeperator',
    value: function _createSeperator() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

      this.manipulationDOM['seperatorLineDiv' + index] = document.createElement('div');
      this.manipulationDOM['seperatorLineDiv' + index].className = 'vis-separator-line';
      this.manipulationDiv.appendChild(this.manipulationDOM['seperatorLineDiv' + index]);
    }

    // ----------------------    DOM functions for buttons    --------------------------//

    /**
     *
     * @param {Locale} locale
     * @private
     */

  }, {
    key: '_createAddNodeButton',
    value: function _createAddNodeButton(locale) {
      var button = this._createButton('addNode', 'vis-button vis-add', locale['addNode'] || this.options.locales['en']['addNode']);
      this.manipulationDiv.appendChild(button);
      this._bindHammerToDiv(button, this.addNodeMode.bind(this));
    }

    /**
     *
     * @param {Locale} locale
     * @private
     */

  }, {
    key: '_createAddEdgeButton',
    value: function _createAddEdgeButton(locale) {
      var button = this._createButton('addEdge', 'vis-button vis-connect', locale['addEdge'] || this.options.locales['en']['addEdge']);
      this.manipulationDiv.appendChild(button);
      this._bindHammerToDiv(button, this.addEdgeMode.bind(this));
    }

    /**
     *
     * @param {Locale} locale
     * @private
     */

  }, {
    key: '_createEditNodeButton',
    value: function _createEditNodeButton(locale) {
      var button = this._createButton('editNode', 'vis-button vis-edit', locale['editNode'] || this.options.locales['en']['editNode']);
      this.manipulationDiv.appendChild(button);
      this._bindHammerToDiv(button, this.editNode.bind(this));
    }

    /**
     *
     * @param {Locale} locale
     * @private
     */

  }, {
    key: '_createEditEdgeButton',
    value: function _createEditEdgeButton(locale) {
      var button = this._createButton('editEdge', 'vis-button vis-edit', locale['editEdge'] || this.options.locales['en']['editEdge']);
      this.manipulationDiv.appendChild(button);
      this._bindHammerToDiv(button, this.editEdgeMode.bind(this));
    }

    /**
     *
     * @param {Locale} locale
     * @private
     */

  }, {
    key: '_createDeleteButton',
    value: function _createDeleteButton(locale) {
      var deleteBtnClass;
      if (this.options.rtl) {
        deleteBtnClass = 'vis-button vis-delete-rtl';
      } else {
        deleteBtnClass = 'vis-button vis-delete';
      }
      var button = this._createButton('delete', deleteBtnClass, locale['del'] || this.options.locales['en']['del']);
      this.manipulationDiv.appendChild(button);
      this._bindHammerToDiv(button, this.deleteSelected.bind(this));
    }

    /**
     *
     * @param {Locale} locale
     * @private
     */

  }, {
    key: '_createBackButton',
    value: function _createBackButton(locale) {
      var button = this._createButton('back', 'vis-button vis-back', locale['back'] || this.options.locales['en']['back']);
      this.manipulationDiv.appendChild(button);
      this._bindHammerToDiv(button, this.showManipulatorToolbar.bind(this));
    }

    /**
     *
     * @param {number|string} id
     * @param {string} className
     * @param {label} label
     * @param {string} labelClassName
     * @returns {HTMLElement}
     * @private
     */

  }, {
    key: '_createButton',
    value: function _createButton(id, className, label) {
      var labelClassName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'vis-label';

      this.manipulationDOM[id + 'Div'] = document.createElement('div');
      this.manipulationDOM[id + 'Div'].className = className;
      this.manipulationDOM[id + 'Label'] = document.createElement('div');
      this.manipulationDOM[id + 'Label'].className = labelClassName;
      this.manipulationDOM[id + 'Label'].innerHTML = label;
      this.manipulationDOM[id + 'Div'].appendChild(this.manipulationDOM[id + 'Label']);
      return this.manipulationDOM[id + 'Div'];
    }

    /**
     *
     * @param {Label} label
     * @private
     */

  }, {
    key: '_createDescription',
    value: function _createDescription(label) {
      this.manipulationDiv.appendChild(this._createButton('description', 'vis-button vis-none', label));
    }

    // -------------------------- End of DOM functions for buttons ------------------------------//

    /**
     * this binds an event until cleanup by the clean functions.
     * @param {Event}  event   The event
     * @param {function} newFunction
     * @private
     */

  }, {
    key: '_temporaryBindEvent',
    value: function _temporaryBindEvent(event, newFunction) {
      this.temporaryEventFunctions.push({
        event: event,
        boundFunction: newFunction
      });
      this.body.emitter.on(event, newFunction);
    }

    /**
     * this overrides an UI function until cleanup by the clean function
     * @param {string} UIfunctionName
     * @param {function} newFunction
     * @private
     */

  }, {
    key: '_temporaryBindUI',
    value: function _temporaryBindUI(UIfunctionName, newFunction) {
      if (this.body.eventListeners[UIfunctionName] !== undefined) {
        this.temporaryUIFunctions[UIfunctionName] = this.body.eventListeners[UIfunctionName];
        this.body.eventListeners[UIfunctionName] = newFunction;
      } else {
        throw new Error('This UI function does not exist. Typo? You tried: ' + UIfunctionName + ' possible are: ' + (0, _stringify2['default'])((0, _keys2['default'])(this.body.eventListeners)));
      }
    }

    /**
     * Restore the overridden UI functions to their original state.
     *
     * @private
     */

  }, {
    key: '_unbindTemporaryUIs',
    value: function _unbindTemporaryUIs() {
      for (var functionName in this.temporaryUIFunctions) {
        if (this.temporaryUIFunctions.hasOwnProperty(functionName)) {
          this.body.eventListeners[functionName] = this.temporaryUIFunctions[functionName];
          delete this.temporaryUIFunctions[functionName];
        }
      }
      this.temporaryUIFunctions = {};
    }

    /**
     * Unbind the events created by _temporaryBindEvent
     * @private
     */

  }, {
    key: '_unbindTemporaryEvents',
    value: function _unbindTemporaryEvents() {
      for (var i = 0; i < this.temporaryEventFunctions.length; i++) {
        var eventName = this.temporaryEventFunctions[i].event;
        var boundFunction = this.temporaryEventFunctions[i].boundFunction;
        this.body.emitter.off(eventName, boundFunction);
      }
      this.temporaryEventFunctions = [];
    }

    /**
     * Bind an hammer instance to a DOM element.
     *
     * @param {Element} domElement
     * @param {function} boundFunction
     */

  }, {
    key: '_bindHammerToDiv',
    value: function _bindHammerToDiv(domElement, boundFunction) {
      var hammer = new Hammer(domElement, {});
      hammerUtil.onTouch(hammer, boundFunction);
      this.manipulationHammers.push(hammer);
    }

    /**
     * Neatly clean up temporary edges and nodes
     * @private
     */

  }, {
    key: '_cleanupTemporaryNodesAndEdges',
    value: function _cleanupTemporaryNodesAndEdges() {
      // _clean temporary edges
      for (var i = 0; i < this.temporaryIds.edges.length; i++) {
        this.body.edges[this.temporaryIds.edges[i]].disconnect();
        delete this.body.edges[this.temporaryIds.edges[i]];
        var indexTempEdge = this.body.edgeIndices.indexOf(this.temporaryIds.edges[i]);
        if (indexTempEdge !== -1) {
          this.body.edgeIndices.splice(indexTempEdge, 1);
        }
      }

      // _clean temporary nodes
      for (var _i = 0; _i < this.temporaryIds.nodes.length; _i++) {
        delete this.body.nodes[this.temporaryIds.nodes[_i]];
        var indexTempNode = this.body.nodeIndices.indexOf(this.temporaryIds.nodes[_i]);
        if (indexTempNode !== -1) {
          this.body.nodeIndices.splice(indexTempNode, 1);
        }
      }

      this.temporaryIds = { nodes: [], edges: [] };
    }

    // ------------------------------------------ EDIT EDGE FUNCTIONS -----------------------------------------//

    /**
     * the touch is used to get the position of the initial click
     * @param {Event}  event   The event
     * @private
     */

  }, {
    key: '_controlNodeTouch',
    value: function _controlNodeTouch(event) {
      this.selectionHandler.unselectAll();
      this.lastTouch = this.body.functions.getPointer(event.center);
      this.lastTouch.translation = util.extend({}, this.body.view.translation); // copy the object
    }

    /**
     * the drag start is used to mark one of the control nodes as selected.
     * @param {Event}  event   The event
     * @private
     */

  }, {
    key: '_controlNodeDragStart',
    value: function _controlNodeDragStart() /* event */{
      // eslint-disable-line no-unused-vars
      var pointer = this.lastTouch;
      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);
      var from = this.body.nodes[this.temporaryIds.nodes[0]];
      var to = this.body.nodes[this.temporaryIds.nodes[1]];
      var edge = this.body.edges[this.edgeBeingEditedId];
      this.selectedControlNode = undefined;

      var fromSelect = from.isOverlappingWith(pointerObj);
      var toSelect = to.isOverlappingWith(pointerObj);

      if (fromSelect === true) {
        this.selectedControlNode = from;
        edge.edgeType.from = from;
      } else if (toSelect === true) {
        this.selectedControlNode = to;
        edge.edgeType.to = to;
      }

      // we use the selection to find the node that is being dragged. We explicitly select it here.
      if (this.selectedControlNode !== undefined) {
        this.selectionHandler.selectObject(this.selectedControlNode);
      }

      this.body.emitter.emit('_redraw');
    }

    /**
     * dragging the control nodes or the canvas
     * @param {Event}  event   The event
     * @private
     */

  }, {
    key: '_controlNodeDrag',
    value: function _controlNodeDrag(event) {
      this.body.emitter.emit('disablePhysics');
      var pointer = this.body.functions.getPointer(event.center);
      var pos = this.canvas.DOMtoCanvas(pointer);
      if (this.selectedControlNode !== undefined) {
        this.selectedControlNode.x = pos.x;
        this.selectedControlNode.y = pos.y;
      } else {
        // if the drag was not started properly because the click started outside the network div, start it now.
        var diffX = pointer.x - this.lastTouch.x;
        var diffY = pointer.y - this.lastTouch.y;
        this.body.view.translation = {
          x: this.lastTouch.translation.x + diffX,
          y: this.lastTouch.translation.y + diffY
        };
      }
      this.body.emitter.emit('_redraw');
    }

    /**
     * connecting or restoring the control nodes.
     * @param {Event}  event   The event
     * @private
     */

  }, {
    key: '_controlNodeDragEnd',
    value: function _controlNodeDragEnd(event) {
      var pointer = this.body.functions.getPointer(event.center);
      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);
      var edge = this.body.edges[this.edgeBeingEditedId];
      // if the node that was dragged is not a control node, return
      if (this.selectedControlNode === undefined) {
        return;
      }

      // we use the selection to find the node that is being dragged. We explicitly DEselect the control node here.
      this.selectionHandler.unselectAll();
      var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);
      var node = undefined;
      for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {
        if (overlappingNodeIds[i] !== this.selectedControlNode.id) {
          node = this.body.nodes[overlappingNodeIds[i]];
          break;
        }
      }
      // perform the connection
      if (node !== undefined && this.selectedControlNode !== undefined) {
        if (node.isCluster === true) {
          alert(this.options.locales[this.options.locale]['createEdgeError'] || this.options.locales['en']['createEdgeError']);
        } else {
          var from = this.body.nodes[this.temporaryIds.nodes[0]];
          if (this.selectedControlNode.id === from.id) {
            this._performEditEdge(node.id, edge.to.id);
          } else {
            this._performEditEdge(edge.from.id, node.id);
          }
        }
      } else {
        edge.updateEdgeType();
        this.body.emitter.emit('restorePhysics');
      }

      this.body.emitter.emit('_redraw');
    }

    // ------------------------------------ END OF EDIT EDGE FUNCTIONS -----------------------------------------//

    // ------------------------------------------- ADD EDGE FUNCTIONS -----------------------------------------//
    /**
     * the function bound to the selection event. It checks if you want to connect a cluster and changes the description
     * to walk the user through the process.
     *
     * @param {Event} event
     * @private
     */

  }, {
    key: '_handleConnect',
    value: function _handleConnect(event) {
      // check to avoid double fireing of this function.
      if (new Date().valueOf() - this.touchTime > 100) {
        this.lastTouch = this.body.functions.getPointer(event.center);
        this.lastTouch.translation = util.extend({}, this.body.view.translation); // copy the object

        var pointer = this.lastTouch;
        var node = this.selectionHandler.getNodeAt(pointer);

        if (node !== undefined) {
          if (node.isCluster === true) {
            alert(this.options.locales[this.options.locale]['createEdgeError'] || this.options.locales['en']['createEdgeError']);
          } else {
            // create a node the temporary line can look at
            var targetNode = this._getNewTargetNode(node.x, node.y);
            this.body.nodes[targetNode.id] = targetNode;
            this.body.nodeIndices.push(targetNode.id);

            // create a temporary edge
            var connectionEdge = this.body.functions.createEdge({
              id: 'connectionEdge' + util.randomUUID(),
              from: node.id,
              to: targetNode.id,
              physics: false,
              smooth: {
                enabled: true,
                type: 'continuous',
                roundness: 0.5
              }
            });
            this.body.edges[connectionEdge.id] = connectionEdge;
            this.body.edgeIndices.push(connectionEdge.id);

            this.temporaryIds.nodes.push(targetNode.id);
            this.temporaryIds.edges.push(connectionEdge.id);
          }
        }
        this.touchTime = new Date().valueOf();
      }
    }

    /**
     *
     * @param {Event} event
     * @private
     */

  }, {
    key: '_dragControlNode',
    value: function _dragControlNode(event) {
      var pointer = this.body.functions.getPointer(event.center);

      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);
      // remember the edge id
      var connectFromId = undefined;
      if (this.temporaryIds.edges[0] !== undefined) {
        connectFromId = this.body.edges[this.temporaryIds.edges[0]].fromId;
      }
      // get the overlapping node but NOT the temporary node;
      var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);
      var node = undefined;
      for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {
        // if the node id is NOT a temporary node, accept the node.
        if (this.temporaryIds.nodes.indexOf(overlappingNodeIds[i]) === -1) {
          node = this.body.nodes[overlappingNodeIds[i]];
          break;
        }
      }

      event.controlEdge = { from: connectFromId, to: node ? node.id : undefined };
      this.selectionHandler._generateClickEvent('controlNodeDragging', event, pointer);

      if (this.temporaryIds.nodes[0] !== undefined) {
        var targetNode = this.body.nodes[this.temporaryIds.nodes[0]]; // there is only one temp node in the add edge mode.
        targetNode.x = this.canvas._XconvertDOMtoCanvas(pointer.x);
        targetNode.y = this.canvas._YconvertDOMtoCanvas(pointer.y);
        this.body.emitter.emit('_redraw');
      } else {
        var diffX = pointer.x - this.lastTouch.x;
        var diffY = pointer.y - this.lastTouch.y;
        this.body.view.translation = {
          x: this.lastTouch.translation.x + diffX,
          y: this.lastTouch.translation.y + diffY
        };
      }
    }

    /**
     * Connect the new edge to the target if one exists, otherwise remove temp line
     * @param {Event}  event   The event
     * @private
     */

  }, {
    key: '_finishConnect',
    value: function _finishConnect(event) {
      var pointer = this.body.functions.getPointer(event.center);
      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);

      // remember the edge id
      var connectFromId = undefined;
      if (this.temporaryIds.edges[0] !== undefined) {
        connectFromId = this.body.edges[this.temporaryIds.edges[0]].fromId;
      }

      // get the overlapping node but NOT the temporary node;
      var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);
      var node = undefined;
      for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {
        // if the node id is NOT a temporary node, accept the node.
        if (this.temporaryIds.nodes.indexOf(overlappingNodeIds[i]) === -1) {
          node = this.body.nodes[overlappingNodeIds[i]];
          break;
        }
      }

      // clean temporary nodes and edges.
      this._cleanupTemporaryNodesAndEdges();

      // perform the connection
      if (node !== undefined) {
        if (node.isCluster === true) {
          alert(this.options.locales[this.options.locale]['createEdgeError'] || this.options.locales['en']['createEdgeError']);
        } else {
          if (this.body.nodes[connectFromId] !== undefined && this.body.nodes[node.id] !== undefined) {
            this._performAddEdge(connectFromId, node.id);
          }
        }
      }

      event.controlEdge = { from: connectFromId, to: node ? node.id : undefined };
      this.selectionHandler._generateClickEvent('controlNodeDragEnd', event, pointer);

      // No need to do _generateclickevent('dragEnd') here, the regular dragEnd event fires.
      this.body.emitter.emit('_redraw');
    }

    /**
     *
     * @param {Event} event
     * @private
     */

  }, {
    key: '_dragStartEdge',
    value: function _dragStartEdge(event) {
      var pointer = this.lastTouch;
      this.selectionHandler._generateClickEvent('dragStart', event, pointer, undefined, true);
    }

    // --------------------------------------- END OF ADD EDGE FUNCTIONS -------------------------------------//

    // ------------------------------ Performing all the actual data manipulation ------------------------//

    /**
     * Adds a node on the specified location
     *
     * @param {Object} clickData
     * @private
     */

  }, {
    key: '_performAddNode',
    value: function _performAddNode(clickData) {
      var _this4 = this;

      var defaultData = {
        id: util.randomUUID(),
        x: clickData.pointer.canvas.x,
        y: clickData.pointer.canvas.y,
        label: 'new'
      };

      if (typeof this.options.addNode === 'function') {
        if (this.options.addNode.length === 2) {
          this.options.addNode(defaultData, function (finalizedData) {
            if (finalizedData !== null && finalizedData !== undefined && _this4.inMode === 'addNode') {
              // if for whatever reason the mode has changes (due to dataset change) disregard the callback
              _this4.body.data.nodes.getDataSet().add(finalizedData);
            }
            _this4.showManipulatorToolbar();
          });
        } else {
          this.showManipulatorToolbar();
          throw new Error('The function for add does not support two arguments (data,callback)');
        }
      } else {
        this.body.data.nodes.getDataSet().add(defaultData);
        this.showManipulatorToolbar();
      }
    }

    /**
     * connect two nodes with a new edge.
     *
     * @param {Node.id} sourceNodeId
     * @param {Node.id} targetNodeId
     * @private
     */

  }, {
    key: '_performAddEdge',
    value: function _performAddEdge(sourceNodeId, targetNodeId) {
      var _this5 = this;

      var defaultData = { from: sourceNodeId, to: targetNodeId };
      if (typeof this.options.addEdge === 'function') {
        if (this.options.addEdge.length === 2) {
          this.options.addEdge(defaultData, function (finalizedData) {
            if (finalizedData !== null && finalizedData !== undefined && _this5.inMode === 'addEdge') {
              // if for whatever reason the mode has changes (due to dataset change) disregard the callback
              _this5.body.data.edges.getDataSet().add(finalizedData);
              _this5.selectionHandler.unselectAll();
              _this5.showManipulatorToolbar();
            }
          });
        } else {
          throw new Error('The function for connect does not support two arguments (data,callback)');
        }
      } else {
        this.body.data.edges.getDataSet().add(defaultData);
        this.selectionHandler.unselectAll();
        this.showManipulatorToolbar();
      }
    }

    /**
     * connect two nodes with a new edge.
     *
     * @param {Node.id} sourceNodeId
     * @param {Node.id} targetNodeId
     * @private
     */

  }, {
    key: '_performEditEdge',
    value: function _performEditEdge(sourceNodeId, targetNodeId) {
      var _this6 = this;

      var defaultData = {
        id: this.edgeBeingEditedId,
        from: sourceNodeId,
        to: targetNodeId,
        label: this.body.data.edges._data[this.edgeBeingEditedId].label
      };
      var eeFunct = this.options.editEdge;
      if ((typeof eeFunct === 'undefined' ? 'undefined' : (0, _typeof3['default'])(eeFunct)) === 'object') {
        eeFunct = eeFunct.editWithoutDrag;
      }
      if (typeof eeFunct === 'function') {
        if (eeFunct.length === 2) {
          eeFunct(defaultData, function (finalizedData) {
            if (finalizedData === null || finalizedData === undefined || _this6.inMode !== 'editEdge') {
              // if for whatever reason the mode has changes (due to dataset change) disregard the callback) {
              _this6.body.edges[defaultData.id].updateEdgeType();
              _this6.body.emitter.emit('_redraw');
              _this6.showManipulatorToolbar();
            } else {
              _this6.body.data.edges.getDataSet().update(finalizedData);
              _this6.selectionHandler.unselectAll();
              _this6.showManipulatorToolbar();
            }
          });
        } else {
          throw new Error('The function for edit does not support two arguments (data, callback)');
        }
      } else {
        this.body.data.edges.getDataSet().update(defaultData);
        this.selectionHandler.unselectAll();
        this.showManipulatorToolbar();
      }
    }
  }]);
  return ManipulationSystem;
}();

exports['default'] = ManipulationSystem;

/***/ }),
/* 191 */
/***/ (function(module, exports, __nested_webpack_require_1213829__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringify = __nested_webpack_require_1213829__(23);

var _stringify2 = _interopRequireDefault(_stringify);

var _typeof2 = __nested_webpack_require_1213829__(7);

var _typeof3 = _interopRequireDefault(_typeof2);

var _classCallCheck2 = __nested_webpack_require_1213829__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_1213829__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var util = __nested_webpack_require_1213829__(2);

var ColorPicker = __nested_webpack_require_1213829__(192)['default'];

/**
 * The way this works is for all properties of this.possible options, you can supply the property name in any form to list the options.
 * Boolean options are recognised as Boolean
 * Number options should be written as array: [default value, min value, max value, stepsize]
 * Colors should be written as array: ['color', '#ffffff']
 * Strings with should be written as array: [option1, option2, option3, ..]
 *
 * The options are matched with their counterparts in each of the modules and the values used in the configuration are
 */

var Configurator = function () {
  /**
   * @param {Object} parentModule        | the location where parentModule.setOptions() can be called
   * @param {Object} defaultContainer    | the default container of the module
   * @param {Object} configureOptions    | the fully configured and predefined options set found in allOptions.js
   * @param {number} pixelRatio          | canvas pixel ratio
   */
  function Configurator(parentModule, defaultContainer, configureOptions) {
    var pixelRatio = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    (0, _classCallCheck3['default'])(this, Configurator);

    this.parent = parentModule;
    this.changedOptions = [];
    this.container = defaultContainer;
    this.allowCreation = false;

    this.options = {};
    this.initialized = false;
    this.popupCounter = 0;
    this.defaultOptions = {
      enabled: false,
      filter: true,
      container: undefined,
      showButton: true
    };
    util.extend(this.options, this.defaultOptions);

    this.configureOptions = configureOptions;
    this.moduleOptions = {};
    this.domElements = [];
    this.popupDiv = {};
    this.popupLimit = 5;
    this.popupHistory = {};
    this.colorPicker = new ColorPicker(pixelRatio);
    this.wrapper = undefined;
  }

  /**
   * refresh all options.
   * Because all modules parse their options by themselves, we just use their options. We copy them here.
   *
   * @param {Object} options
   */


  (0, _createClass3['default'])(Configurator, [{
    key: 'setOptions',
    value: function setOptions(options) {
      if (options !== undefined) {
        // reset the popup history because the indices may have been changed.
        this.popupHistory = {};
        this._removePopup();

        var enabled = true;
        if (typeof options === 'string') {
          this.options.filter = options;
        } else if (options instanceof Array) {
          this.options.filter = options.join();
        } else if ((typeof options === 'undefined' ? 'undefined' : (0, _typeof3['default'])(options)) === 'object') {
          if (options == null) {
            throw new TypeError('options cannot be null');
          }
          if (options.container !== undefined) {
            this.options.container = options.container;
          }
          if (options.filter !== undefined) {
            this.options.filter = options.filter;
          }
          if (options.showButton !== undefined) {
            this.options.showButton = options.showButton;
          }
          if (options.enabled !== undefined) {
            enabled = options.enabled;
          }
        } else if (typeof options === 'boolean') {
          this.options.filter = true;
          enabled = options;
        } else if (typeof options === 'function') {
          this.options.filter = options;
          enabled = true;
        }
        if (this.options.filter === false) {
          enabled = false;
        }

        this.options.enabled = enabled;
      }
      this._clean();
    }

    /**
     *
     * @param {Object} moduleOptions
     */

  }, {
    key: 'setModuleOptions',
    value: function setModuleOptions(moduleOptions) {
      this.moduleOptions = moduleOptions;
      if (this.options.enabled === true) {
        this._clean();
        if (this.options.container !== undefined) {
          this.container = this.options.container;
        }
        this._create();
      }
    }

    /**
     * Create all DOM elements
     * @private
     */

  }, {
    key: '_create',
    value: function _create() {
      this._clean();
      this.changedOptions = [];

      var filter = this.options.filter;
      var counter = 0;
      var show = false;
      for (var option in this.configureOptions) {
        if (this.configureOptions.hasOwnProperty(option)) {
          this.allowCreation = false;
          show = false;
          if (typeof filter === 'function') {
            show = filter(option, []);
            show = show || this._handleObject(this.configureOptions[option], [option], true);
          } else if (filter === true || filter.indexOf(option) !== -1) {
            show = true;
          }

          if (show !== false) {
            this.allowCreation = true;

            // linebreak between categories
            if (counter > 0) {
              this._makeItem([]);
            }
            // a header for the category
            this._makeHeader(option);

            // get the sub options
            this._handleObject(this.configureOptions[option], [option]);
          }
          counter++;
        }
      }
      this._makeButton();
      this._push();
      //~ this.colorPicker.insertTo(this.container);
    }

    /**
     * draw all DOM elements on the screen
     * @private
     */

  }, {
    key: '_push',
    value: function _push() {
      this.wrapper = document.createElement('div');
      this.wrapper.className = 'vis-configuration-wrapper';
      this.container.appendChild(this.wrapper);
      for (var i = 0; i < this.domElements.length; i++) {
        this.wrapper.appendChild(this.domElements[i]);
      }

      this._showPopupIfNeeded();
    }

    /**
     * delete all DOM elements
     * @private
     */

  }, {
    key: '_clean',
    value: function _clean() {
      for (var i = 0; i < this.domElements.length; i++) {
        this.wrapper.removeChild(this.domElements[i]);
      }

      if (this.wrapper !== undefined) {
        this.container.removeChild(this.wrapper);
        this.wrapper = undefined;
      }
      this.domElements = [];

      this._removePopup();
    }

    /**
     * get the value from the actualOptions if it exists
     * @param {array} path    | where to look for the actual option
     * @returns {*}
     * @private
     */

  }, {
    key: '_getValue',
    value: function _getValue(path) {
      var base = this.moduleOptions;
      for (var i = 0; i < path.length; i++) {
        if (base[path[i]] !== undefined) {
          base = base[path[i]];
        } else {
          base = undefined;
          break;
        }
      }
      return base;
    }

    /**
     * all option elements are wrapped in an item
     * @param {Array} path    | where to look for the actual option
     * @param {Array.<Element>} domElements
     * @returns {number}
     * @private
     */

  }, {
    key: '_makeItem',
    value: function _makeItem(path) {
      if (this.allowCreation === true) {
        var item = document.createElement('div');
        item.className = 'vis-configuration vis-config-item vis-config-s' + path.length;

        for (var _len = arguments.length, domElements = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          domElements[_key - 1] = arguments[_key];
        }

        domElements.forEach(function (element) {
          item.appendChild(element);
        });
        this.domElements.push(item);
        return this.domElements.length;
      }
      return 0;
    }

    /**
     * header for major subjects
     * @param {string} name
     * @private
     */

  }, {
    key: '_makeHeader',
    value: function _makeHeader(name) {
      var div = document.createElement('div');
      div.className = 'vis-configuration vis-config-header';
      div.innerHTML = name;
      this._makeItem([], div);
    }

    /**
     * make a label, if it is an object label, it gets different styling.
     * @param {string} name
     * @param {array} path    | where to look for the actual option
     * @param {string} objectLabel
     * @returns {HTMLElement}
     * @private
     */

  }, {
    key: '_makeLabel',
    value: function _makeLabel(name, path) {
      var objectLabel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var div = document.createElement('div');
      div.className = 'vis-configuration vis-config-label vis-config-s' + path.length;
      if (objectLabel === true) {
        div.innerHTML = '<i><b>' + name + ':</b></i>';
      } else {
        div.innerHTML = name + ':';
      }
      return div;
    }

    /**
     * make a dropdown list for multiple possible string optoins
     * @param {Array.<number>} arr
     * @param {number} value
     * @param {array} path    | where to look for the actual option
     * @private
     */

  }, {
    key: '_makeDropdown',
    value: function _makeDropdown(arr, value, path) {
      var select = document.createElement('select');
      select.className = 'vis-configuration vis-config-select';
      var selectedValue = 0;
      if (value !== undefined) {
        if (arr.indexOf(value) !== -1) {
          selectedValue = arr.indexOf(value);
        }
      }

      for (var i = 0; i < arr.length; i++) {
        var option = document.createElement('option');
        option.value = arr[i];
        if (i === selectedValue) {
          option.selected = 'selected';
        }
        option.innerHTML = arr[i];
        select.appendChild(option);
      }

      var me = this;
      select.onchange = function () {
        me._update(this.value, path);
      };

      var label = this._makeLabel(path[path.length - 1], path);
      this._makeItem(path, label, select);
    }

    /**
     * make a range object for numeric options
     * @param {Array.<number>} arr
     * @param {number} value
     * @param {array} path    | where to look for the actual option
     * @private
     */

  }, {
    key: '_makeRange',
    value: function _makeRange(arr, value, path) {
      var defaultValue = arr[0];
      var min = arr[1];
      var max = arr[2];
      var step = arr[3];
      var range = document.createElement('input');
      range.className = 'vis-configuration vis-config-range';
      try {
        range.type = 'range'; // not supported on IE9
        range.min = min;
        range.max = max;
      } catch (err) {}
      // TODO: Add some error handling and remove this lint exception
      // eslint-disable-line no-empty
      range.step = step;

      // set up the popup settings in case they are needed.
      var popupString = '';
      var popupValue = 0;

      if (value !== undefined) {
        var factor = 1.2;
        if (value < 0 && value * factor < min) {
          range.min = Math.ceil(value * factor);
          popupValue = range.min;
          popupString = 'range increased';
        } else if (value / factor < min) {
          range.min = Math.ceil(value / factor);
          popupValue = range.min;
          popupString = 'range increased';
        }
        if (value * factor > max && max !== 1) {
          range.max = Math.ceil(value * factor);
          popupValue = range.max;
          popupString = 'range increased';
        }
        range.value = value;
      } else {
        range.value = defaultValue;
      }

      var input = document.createElement('input');
      input.className = 'vis-configuration vis-config-rangeinput';
      input.value = range.value;

      var me = this;
      range.onchange = function () {
        input.value = this.value;
        me._update(Number(this.value), path);
      };
      range.oninput = function () {
        input.value = this.value;
      };

      var label = this._makeLabel(path[path.length - 1], path);
      var itemIndex = this._makeItem(path, label, range, input);

      // if a popup is needed AND it has not been shown for this value, show it.
      if (popupString !== '' && this.popupHistory[itemIndex] !== popupValue) {
        this.popupHistory[itemIndex] = popupValue;
        this._setupPopup(popupString, itemIndex);
      }
    }

    /**
     * make a button object
     * @private
     */

  }, {
    key: '_makeButton',
    value: function _makeButton() {
      var _this = this;

      if (this.options.showButton === true) {
        var generateButton = document.createElement('div');
        generateButton.className = 'vis-configuration vis-config-button';
        generateButton.innerHTML = 'generate options';
        generateButton.onclick = function () {
          _this._printOptions();
        };
        generateButton.onmouseover = function () {
          generateButton.className = 'vis-configuration vis-config-button hover';
        };
        generateButton.onmouseout = function () {
          generateButton.className = 'vis-configuration vis-config-button';
        };

        this.optionsContainer = document.createElement('div');
        this.optionsContainer.className = 'vis-configuration vis-config-option-container';

        this.domElements.push(this.optionsContainer);
        this.domElements.push(generateButton);
      }
    }

    /**
     * prepare the popup
     * @param {string} string
     * @param {number} index
     * @private
     */

  }, {
    key: '_setupPopup',
    value: function _setupPopup(string, index) {
      var _this2 = this;

      if (this.initialized === true && this.allowCreation === true && this.popupCounter < this.popupLimit) {
        var div = document.createElement('div');
        div.id = 'vis-configuration-popup';
        div.className = 'vis-configuration-popup';
        div.innerHTML = string;
        div.onclick = function () {
          _this2._removePopup();
        };
        this.popupCounter += 1;
        this.popupDiv = { html: div, index: index };
      }
    }

    /**
     * remove the popup from the dom
     * @private
     */

  }, {
    key: '_removePopup',
    value: function _removePopup() {
      if (this.popupDiv.html !== undefined) {
        this.popupDiv.html.parentNode.removeChild(this.popupDiv.html);
        clearTimeout(this.popupDiv.hideTimeout);
        clearTimeout(this.popupDiv.deleteTimeout);
        this.popupDiv = {};
      }
    }

    /**
     * Show the popup if it is needed.
     * @private
     */

  }, {
    key: '_showPopupIfNeeded',
    value: function _showPopupIfNeeded() {
      var _this3 = this;

      if (this.popupDiv.html !== undefined) {
        var correspondingElement = this.domElements[this.popupDiv.index];
        var rect = correspondingElement.getBoundingClientRect();
        this.popupDiv.html.style.left = rect.left + 'px';
        this.popupDiv.html.style.top = rect.top - 30 + 'px'; // 30 is the height;
        document.body.appendChild(this.popupDiv.html);
        this.popupDiv.hideTimeout = setTimeout(function () {
          _this3.popupDiv.html.style.opacity = 0;
        }, 1500);
        this.popupDiv.deleteTimeout = setTimeout(function () {
          _this3._removePopup();
        }, 1800);
      }
    }

    /**
     * make a checkbox for boolean options.
     * @param {number} defaultValue
     * @param {number} value
     * @param {array} path    | where to look for the actual option
     * @private
     */

  }, {
    key: '_makeCheckbox',
    value: function _makeCheckbox(defaultValue, value, path) {
      var checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.className = 'vis-configuration vis-config-checkbox';
      checkbox.checked = defaultValue;
      if (value !== undefined) {
        checkbox.checked = value;
        if (value !== defaultValue) {
          if ((typeof defaultValue === 'undefined' ? 'undefined' : (0, _typeof3['default'])(defaultValue)) === 'object') {
            if (value !== defaultValue.enabled) {
              this.changedOptions.push({ path: path, value: value });
            }
          } else {
            this.changedOptions.push({ path: path, value: value });
          }
        }
      }

      var me = this;
      checkbox.onchange = function () {
        me._update(this.checked, path);
      };

      var label = this._makeLabel(path[path.length - 1], path);
      this._makeItem(path, label, checkbox);
    }

    /**
     * make a text input field for string options.
     * @param {number} defaultValue
     * @param {number} value
     * @param {array} path    | where to look for the actual option
     * @private
     */

  }, {
    key: '_makeTextInput',
    value: function _makeTextInput(defaultValue, value, path) {
      var checkbox = document.createElement('input');
      checkbox.type = 'text';
      checkbox.className = 'vis-configuration vis-config-text';
      checkbox.value = value;
      if (value !== defaultValue) {
        this.changedOptions.push({ path: path, value: value });
      }

      var me = this;
      checkbox.onchange = function () {
        me._update(this.value, path);
      };

      var label = this._makeLabel(path[path.length - 1], path);
      this._makeItem(path, label, checkbox);
    }

    /**
     * make a color field with a color picker for color fields
     * @param {Array.<number>} arr
     * @param {number} value
     * @param {array} path    | where to look for the actual option
     * @private
     */

  }, {
    key: '_makeColorField',
    value: function _makeColorField(arr, value, path) {
      var _this4 = this;

      var defaultColor = arr[1];
      var div = document.createElement('div');
      value = value === undefined ? defaultColor : value;

      if (value !== 'none') {
        div.className = 'vis-configuration vis-config-colorBlock';
        div.style.backgroundColor = value;
      } else {
        div.className = 'vis-configuration vis-config-colorBlock none';
      }

      value = value === undefined ? defaultColor : value;
      div.onclick = function () {
        _this4._showColorPicker(value, div, path);
      };

      var label = this._makeLabel(path[path.length - 1], path);
      this._makeItem(path, label, div);
    }

    /**
     * used by the color buttons to call the color picker.
     * @param {number} value
     * @param {HTMLElement} div
     * @param {array} path    | where to look for the actual option
     * @private
     */

  }, {
    key: '_showColorPicker',
    value: function _showColorPicker(value, div, path) {
      var _this5 = this;

      // clear the callback from this div
      div.onclick = function () {};

      this.colorPicker.insertTo(div);
      this.colorPicker.show();

      this.colorPicker.setColor(value);
      this.colorPicker.setUpdateCallback(function (color) {
        var colorString = 'rgba(' + color.r + ',' + color.g + ',' + color.b + ',' + color.a + ')';
        div.style.backgroundColor = colorString;
        _this5._update(colorString, path);
      });

      // on close of the colorpicker, restore the callback.
      this.colorPicker.setCloseCallback(function () {
        div.onclick = function () {
          _this5._showColorPicker(value, div, path);
        };
      });
    }

    /**
     * parse an object and draw the correct items
     * @param {Object} obj
     * @param {array} [path=[]]    | where to look for the actual option
     * @param {boolean} [checkOnly=false]
     * @returns {boolean}
     * @private
     */

  }, {
    key: '_handleObject',
    value: function _handleObject(obj) {
      var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var checkOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var show = false;
      var filter = this.options.filter;
      var visibleInSet = false;
      for (var subObj in obj) {
        if (obj.hasOwnProperty(subObj)) {
          show = true;
          var item = obj[subObj];
          var newPath = util.copyAndExtendArray(path, subObj);
          if (typeof filter === 'function') {
            show = filter(subObj, path);

            // if needed we must go deeper into the object.
            if (show === false) {
              if (!(item instanceof Array) && typeof item !== 'string' && typeof item !== 'boolean' && item instanceof Object) {
                this.allowCreation = false;
                show = this._handleObject(item, newPath, true);
                this.allowCreation = checkOnly === false;
              }
            }
          }

          if (show !== false) {
            visibleInSet = true;
            var value = this._getValue(newPath);

            if (item instanceof Array) {
              this._handleArray(item, value, newPath);
            } else if (typeof item === 'string') {
              this._makeTextInput(item, value, newPath);
            } else if (typeof item === 'boolean') {
              this._makeCheckbox(item, value, newPath);
            } else if (item instanceof Object) {
              // collapse the physics options that are not enabled
              var draw = true;
              if (path.indexOf('physics') !== -1) {
                if (this.moduleOptions.physics.solver !== subObj) {
                  draw = false;
                }
              }

              if (draw === true) {
                // initially collapse options with an disabled enabled option.
                if (item.enabled !== undefined) {
                  var enabledPath = util.copyAndExtendArray(newPath, 'enabled');
                  var enabledValue = this._getValue(enabledPath);
                  if (enabledValue === true) {
                    var label = this._makeLabel(subObj, newPath, true);
                    this._makeItem(newPath, label);
                    visibleInSet = this._handleObject(item, newPath) || visibleInSet;
                  } else {
                    this._makeCheckbox(item, enabledValue, newPath);
                  }
                } else {
                  var _label = this._makeLabel(subObj, newPath, true);
                  this._makeItem(newPath, _label);
                  visibleInSet = this._handleObject(item, newPath) || visibleInSet;
                }
              }
            } else {
              console.error('dont know how to handle', item, subObj, newPath);
            }
          }
        }
      }
      return visibleInSet;
    }

    /**
     * handle the array type of option
     * @param {Array.<number>} arr
     * @param {number} value
     * @param {array} path    | where to look for the actual option
     * @private
     */

  }, {
    key: '_handleArray',
    value: function _handleArray(arr, value, path) {
      if (typeof arr[0] === 'string' && arr[0] === 'color') {
        this._makeColorField(arr, value, path);
        if (arr[1] !== value) {
          this.changedOptions.push({ path: path, value: value });
        }
      } else if (typeof arr[0] === 'string') {
        this._makeDropdown(arr, value, path);
        if (arr[0] !== value) {
          this.changedOptions.push({ path: path, value: value });
        }
      } else if (typeof arr[0] === 'number') {
        this._makeRange(arr, value, path);
        if (arr[0] !== value) {
          this.changedOptions.push({ path: path, value: Number(value) });
        }
      }
    }

    /**
     * called to update the network with the new settings.
     * @param {number} value
     * @param {array} path    | where to look for the actual option
     * @private
     */

  }, {
    key: '_update',
    value: function _update(value, path) {
      var options = this._constructOptions(value, path);

      if (this.parent.body && this.parent.body.emitter && this.parent.body.emitter.emit) {
        this.parent.body.emitter.emit('configChange', options);
      }
      this.initialized = true;
      this.parent.setOptions(options);
    }

    /**
     *
     * @param {string|Boolean} value
     * @param {Array.<string>} path
     * @param {{}} optionsObj
     * @returns {{}}
     * @private
     */

  }, {
    key: '_constructOptions',
    value: function _constructOptions(value, path) {
      var optionsObj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      var pointer = optionsObj;

      // when dropdown boxes can be string or boolean, we typecast it into correct types
      value = value === 'true' ? true : value;
      value = value === 'false' ? false : value;

      for (var i = 0; i < path.length; i++) {
        if (path[i] !== 'global') {
          if (pointer[path[i]] === undefined) {
            pointer[path[i]] = {};
          }
          if (i !== path.length - 1) {
            pointer = pointer[path[i]];
          } else {
            pointer[path[i]] = value;
          }
        }
      }
      return optionsObj;
    }

    /**
     * @private
     */

  }, {
    key: '_printOptions',
    value: function _printOptions() {
      var options = this.getOptions();
      this.optionsContainer.innerHTML = '<pre>var options = ' + (0, _stringify2['default'])(options, null, 2) + '</pre>';
    }

    /**
     *
     * @returns {{}} options
     */

  }, {
    key: 'getOptions',
    value: function getOptions() {
      var options = {};
      for (var i = 0; i < this.changedOptions.length; i++) {
        this._constructOptions(this.changedOptions[i].value, this.changedOptions[i].path, options);
      }
      return options;
    }
  }]);
  return Configurator;
}();

exports['default'] = Configurator;

/***/ }),
/* 192 */
/***/ (function(module, exports, __nested_webpack_require_1239979__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringify = __nested_webpack_require_1239979__(23);

var _stringify2 = _interopRequireDefault(_stringify);

var _classCallCheck2 = __nested_webpack_require_1239979__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_1239979__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var Hammer = __nested_webpack_require_1239979__(24);
var hammerUtil = __nested_webpack_require_1239979__(36);
var util = __nested_webpack_require_1239979__(2);

var htmlColors = {
  black: '#000000',
  navy: '#000080',
  darkblue: '#00008B',
  mediumblue: '#0000CD',
  blue: '#0000FF',
  darkgreen: '#006400',
  green: '#008000',
  teal: '#008080',
  darkcyan: '#008B8B',
  deepskyblue: '#00BFFF',
  darkturquoise: '#00CED1',
  mediumspringgreen: '#00FA9A',
  lime: '#00FF00',
  springgreen: '#00FF7F',
  aqua: '#00FFFF',
  cyan: '#00FFFF',
  midnightblue: '#191970',
  dodgerblue: '#1E90FF',
  lightseagreen: '#20B2AA',
  forestgreen: '#228B22',
  seagreen: '#2E8B57',
  darkslategray: '#2F4F4F',
  limegreen: '#32CD32',
  mediumseagreen: '#3CB371',
  turquoise: '#40E0D0',
  royalblue: '#4169E1',
  steelblue: '#4682B4',
  darkslateblue: '#483D8B',
  mediumturquoise: '#48D1CC',
  indigo: '#4B0082',
  darkolivegreen: '#556B2F',
  cadetblue: '#5F9EA0',
  cornflowerblue: '#6495ED',
  mediumaquamarine: '#66CDAA',
  dimgray: '#696969',
  slateblue: '#6A5ACD',
  olivedrab: '#6B8E23',
  slategray: '#708090',
  lightslategray: '#778899',
  mediumslateblue: '#7B68EE',
  lawngreen: '#7CFC00',
  chartreuse: '#7FFF00',
  aquamarine: '#7FFFD4',
  maroon: '#800000',
  purple: '#800080',
  olive: '#808000',
  gray: '#808080',
  skyblue: '#87CEEB',
  lightskyblue: '#87CEFA',
  blueviolet: '#8A2BE2',
  darkred: '#8B0000',
  darkmagenta: '#8B008B',
  saddlebrown: '#8B4513',
  darkseagreen: '#8FBC8F',
  lightgreen: '#90EE90',
  mediumpurple: '#9370D8',
  darkviolet: '#9400D3',
  palegreen: '#98FB98',
  darkorchid: '#9932CC',
  yellowgreen: '#9ACD32',
  sienna: '#A0522D',
  brown: '#A52A2A',
  darkgray: '#A9A9A9',
  lightblue: '#ADD8E6',
  greenyellow: '#ADFF2F',
  paleturquoise: '#AFEEEE',
  lightsteelblue: '#B0C4DE',
  powderblue: '#B0E0E6',
  firebrick: '#B22222',
  darkgoldenrod: '#B8860B',
  mediumorchid: '#BA55D3',
  rosybrown: '#BC8F8F',
  darkkhaki: '#BDB76B',
  silver: '#C0C0C0',
  mediumvioletred: '#C71585',
  indianred: '#CD5C5C',
  peru: '#CD853F',
  chocolate: '#D2691E',
  tan: '#D2B48C',
  lightgrey: '#D3D3D3',
  palevioletred: '#D87093',
  thistle: '#D8BFD8',
  orchid: '#DA70D6',
  goldenrod: '#DAA520',
  crimson: '#DC143C',
  gainsboro: '#DCDCDC',
  plum: '#DDA0DD',
  burlywood: '#DEB887',
  lightcyan: '#E0FFFF',
  lavender: '#E6E6FA',
  darksalmon: '#E9967A',
  violet: '#EE82EE',
  palegoldenrod: '#EEE8AA',
  lightcoral: '#F08080',
  khaki: '#F0E68C',
  aliceblue: '#F0F8FF',
  honeydew: '#F0FFF0',
  azure: '#F0FFFF',
  sandybrown: '#F4A460',
  wheat: '#F5DEB3',
  beige: '#F5F5DC',
  whitesmoke: '#F5F5F5',
  mintcream: '#F5FFFA',
  ghostwhite: '#F8F8FF',
  salmon: '#FA8072',
  antiquewhite: '#FAEBD7',
  linen: '#FAF0E6',
  lightgoldenrodyellow: '#FAFAD2',
  oldlace: '#FDF5E6',
  red: '#FF0000',
  fuchsia: '#FF00FF',
  magenta: '#FF00FF',
  deeppink: '#FF1493',
  orangered: '#FF4500',
  tomato: '#FF6347',
  hotpink: '#FF69B4',
  coral: '#FF7F50',
  darkorange: '#FF8C00',
  lightsalmon: '#FFA07A',
  orange: '#FFA500',
  lightpink: '#FFB6C1',
  pink: '#FFC0CB',
  gold: '#FFD700',
  peachpuff: '#FFDAB9',
  navajowhite: '#FFDEAD',
  moccasin: '#FFE4B5',
  bisque: '#FFE4C4',
  mistyrose: '#FFE4E1',
  blanchedalmond: '#FFEBCD',
  papayawhip: '#FFEFD5',
  lavenderblush: '#FFF0F5',
  seashell: '#FFF5EE',
  cornsilk: '#FFF8DC',
  lemonchiffon: '#FFFACD',
  floralwhite: '#FFFAF0',
  snow: '#FFFAFA',
  yellow: '#FFFF00',
  lightyellow: '#FFFFE0',
  ivory: '#FFFFF0',
  white: '#FFFFFF'

  /**
   * @param {number} [pixelRatio=1]
   */
};
var ColorPicker = function () {
  /**
   * @param {number} [pixelRatio=1]
   */
  function ColorPicker() {
    var pixelRatio = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    (0, _classCallCheck3['default'])(this, ColorPicker);

    this.pixelRatio = pixelRatio;
    this.generated = false;
    this.centerCoordinates = { x: 289 / 2, y: 289 / 2 };
    this.r = 289 * 0.49;
    this.color = { r: 255, g: 255, b: 255, a: 1.0 };
    this.hueCircle = undefined;
    this.initialColor = { r: 255, g: 255, b: 255, a: 1.0 };
    this.previousColor = undefined;
    this.applied = false;

    // bound by
    this.updateCallback = function () {};
    this.closeCallback = function () {};

    // create all DOM elements
    this._create();
  }

  /**
   * this inserts the colorPicker into a div from the DOM
   * @param {Element} container
   */


  (0, _createClass3['default'])(ColorPicker, [{
    key: 'insertTo',
    value: function insertTo(container) {
      if (this.hammer !== undefined) {
        this.hammer.destroy();
        this.hammer = undefined;
      }
      this.container = container;
      this.container.appendChild(this.frame);
      this._bindHammer();

      this._setSize();
    }

    /**
     * the callback is executed on apply and save. Bind it to the application
     * @param {function} callback
     */

  }, {
    key: 'setUpdateCallback',
    value: function setUpdateCallback(callback) {
      if (typeof callback === 'function') {
        this.updateCallback = callback;
      } else {
        throw new Error('Function attempted to set as colorPicker update callback is not a function.');
      }
    }

    /**
     * the callback is executed on apply and save. Bind it to the application
     * @param {function} callback
     */

  }, {
    key: 'setCloseCallback',
    value: function setCloseCallback(callback) {
      if (typeof callback === 'function') {
        this.closeCallback = callback;
      } else {
        throw new Error('Function attempted to set as colorPicker closing callback is not a function.');
      }
    }

    /**
     *
     * @param {string} color
     * @returns {String}
     * @private
     */

  }, {
    key: '_isColorString',
    value: function _isColorString(color) {
      if (typeof color === 'string') {
        return htmlColors[color];
      }
    }

    /**
     * Set the color of the colorPicker
     * Supported formats:
     * 'red'                   --> HTML color string
     * '#ffffff'               --> hex string
     * 'rgb(255,255,255)'      --> rgb string
     * 'rgba(255,255,255,1.0)' --> rgba string
     * {r:255,g:255,b:255}     --> rgb object
     * {r:255,g:255,b:255,a:1.0} --> rgba object
     * @param {string|Object} color
     * @param {boolean} [setInitial=true]
     */

  }, {
    key: 'setColor',
    value: function setColor(color) {
      var setInitial = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (color === 'none') {
        return;
      }

      var rgba = void 0;

      // if a html color shorthand is used, convert to hex
      var htmlColor = this._isColorString(color);
      if (htmlColor !== undefined) {
        color = htmlColor;
      }

      // check format
      if (util.isString(color) === true) {
        if (util.isValidRGB(color) === true) {
          var rgbaArray = color.substr(4).substr(0, color.length - 5).split(',');
          rgba = { r: rgbaArray[0], g: rgbaArray[1], b: rgbaArray[2], a: 1.0 };
        } else if (util.isValidRGBA(color) === true) {
          var _rgbaArray = color.substr(5).substr(0, color.length - 6).split(',');
          rgba = {
            r: _rgbaArray[0],
            g: _rgbaArray[1],
            b: _rgbaArray[2],
            a: _rgbaArray[3]
          };
        } else if (util.isValidHex(color) === true) {
          var rgbObj = util.hexToRGB(color);
          rgba = { r: rgbObj.r, g: rgbObj.g, b: rgbObj.b, a: 1.0 };
        }
      } else {
        if (color instanceof Object) {
          if (color.r !== undefined && color.g !== undefined && color.b !== undefined) {
            var alpha = color.a !== undefined ? color.a : '1.0';
            rgba = { r: color.r, g: color.g, b: color.b, a: alpha };
          }
        }
      }

      // set color
      if (rgba === undefined) {
        throw new Error('Unknown color passed to the colorPicker. Supported are strings: rgb, hex, rgba. Object: rgb ({r:r,g:g,b:b,[a:a]}). Supplied: ' + (0, _stringify2['default'])(color));
      } else {
        this._setColor(rgba, setInitial);
      }
    }

    /**
     * this shows the color picker.
     * The hue circle is constructed once and stored.
     */

  }, {
    key: 'show',
    value: function show() {
      if (this.closeCallback !== undefined) {
        this.closeCallback();
        this.closeCallback = undefined;
      }

      this.applied = false;
      this.frame.style.display = 'block';
      this._generateHueCircle();
    }

    // ------------------------------------------ PRIVATE ----------------------------- //

    /**
     * Hide the picker. Is called by the cancel button.
     * Optional boolean to store the previous color for easy access later on.
     * @param {boolean} [storePrevious=true]
     * @private
     */

  }, {
    key: '_hide',
    value: function _hide() {
      var _this = this;

      var storePrevious = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      // store the previous color for next time;
      if (storePrevious === true) {
        this.previousColor = util.extend({}, this.color);
      }

      if (this.applied === true) {
        this.updateCallback(this.initialColor);
      }

      this.frame.style.display = 'none';

      // call the closing callback, restoring the onclick method.
      // this is in a setTimeout because it will trigger the show again before the click is done.
      setTimeout(function () {
        if (_this.closeCallback !== undefined) {
          _this.closeCallback();
          _this.closeCallback = undefined;
        }
      }, 0);
    }

    /**
     * bound to the save button. Saves and hides.
     * @private
     */

  }, {
    key: '_save',
    value: function _save() {
      this.updateCallback(this.color);
      this.applied = false;
      this._hide();
    }

    /**
     * Bound to apply button. Saves but does not close. Is undone by the cancel button.
     * @private
     */

  }, {
    key: '_apply',
    value: function _apply() {
      this.applied = true;
      this.updateCallback(this.color);
      this._updatePicker(this.color);
    }

    /**
     * load the color from the previous session.
     * @private
     */

  }, {
    key: '_loadLast',
    value: function _loadLast() {
      if (this.previousColor !== undefined) {
        this.setColor(this.previousColor, false);
      } else {
        alert('There is no last color to load...');
      }
    }

    /**
     * set the color, place the picker
     * @param {Object} rgba
     * @param {boolean} [setInitial=true]
     * @private
     */

  }, {
    key: '_setColor',
    value: function _setColor(rgba) {
      var setInitial = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      // store the initial color
      if (setInitial === true) {
        this.initialColor = util.extend({}, rgba);
      }

      this.color = rgba;
      var hsv = util.RGBToHSV(rgba.r, rgba.g, rgba.b);

      var angleConvert = 2 * Math.PI;
      var radius = this.r * hsv.s;
      var x = this.centerCoordinates.x + radius * Math.sin(angleConvert * hsv.h);
      var y = this.centerCoordinates.y + radius * Math.cos(angleConvert * hsv.h);

      this.colorPickerSelector.style.left = x - 0.5 * this.colorPickerSelector.clientWidth + 'px';
      this.colorPickerSelector.style.top = y - 0.5 * this.colorPickerSelector.clientHeight + 'px';

      this._updatePicker(rgba);
    }

    /**
     * bound to opacity control
     * @param {number} value
     * @private
     */

  }, {
    key: '_setOpacity',
    value: function _setOpacity(value) {
      this.color.a = value / 100;
      this._updatePicker(this.color);
    }

    /**
     * bound to brightness control
     * @param {number} value
     * @private
     */

  }, {
    key: '_setBrightness',
    value: function _setBrightness(value) {
      var hsv = util.RGBToHSV(this.color.r, this.color.g, this.color.b);
      hsv.v = value / 100;
      var rgba = util.HSVToRGB(hsv.h, hsv.s, hsv.v);
      rgba['a'] = this.color.a;
      this.color = rgba;
      this._updatePicker();
    }

    /**
     * update the color picker. A black circle overlays the hue circle to mimic the brightness decreasing.
     * @param {Object} rgba
     * @private
     */

  }, {
    key: '_updatePicker',
    value: function _updatePicker() {
      var rgba = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.color;

      var hsv = util.RGBToHSV(rgba.r, rgba.g, rgba.b);
      var ctx = this.colorPickerCanvas.getContext('2d');
      if (this.pixelRation === undefined) {
        this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
      }
      ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);

      // clear the canvas
      var w = this.colorPickerCanvas.clientWidth;
      var h = this.colorPickerCanvas.clientHeight;
      ctx.clearRect(0, 0, w, h);

      ctx.putImageData(this.hueCircle, 0, 0);
      ctx.fillStyle = 'rgba(0,0,0,' + (1 - hsv.v) + ')';
      ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);
      ctx.fill();

      this.brightnessRange.value = 100 * hsv.v;
      this.opacityRange.value = 100 * rgba.a;

      this.initialColorDiv.style.backgroundColor = 'rgba(' + this.initialColor.r + ',' + this.initialColor.g + ',' + this.initialColor.b + ',' + this.initialColor.a + ')';
      this.newColorDiv.style.backgroundColor = 'rgba(' + this.color.r + ',' + this.color.g + ',' + this.color.b + ',' + this.color.a + ')';
    }

    /**
     * used by create to set the size of the canvas.
     * @private
     */

  }, {
    key: '_setSize',
    value: function _setSize() {
      this.colorPickerCanvas.style.width = '100%';
      this.colorPickerCanvas.style.height = '100%';

      this.colorPickerCanvas.width = 289 * this.pixelRatio;
      this.colorPickerCanvas.height = 289 * this.pixelRatio;
    }

    /**
     * create all dom elements
     * TODO: cleanup, lots of similar dom elements
     * @private
     */

  }, {
    key: '_create',
    value: function _create() {
      this.frame = document.createElement('div');
      this.frame.className = 'vis-color-picker';

      this.colorPickerDiv = document.createElement('div');
      this.colorPickerSelector = document.createElement('div');
      this.colorPickerSelector.className = 'vis-selector';
      this.colorPickerDiv.appendChild(this.colorPickerSelector);

      this.colorPickerCanvas = document.createElement('canvas');
      this.colorPickerDiv.appendChild(this.colorPickerCanvas);

      if (!this.colorPickerCanvas.getContext) {
        var noCanvas = document.createElement('DIV');
        noCanvas.style.color = 'red';
        noCanvas.style.fontWeight = 'bold';
        noCanvas.style.padding = '10px';
        noCanvas.innerHTML = 'Error: your browser does not support HTML canvas';
        this.colorPickerCanvas.appendChild(noCanvas);
      } else {
        var ctx = this.colorPickerCanvas.getContext('2d');
        this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
        this.colorPickerCanvas.getContext('2d').setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
      }

      this.colorPickerDiv.className = 'vis-color';

      this.opacityDiv = document.createElement('div');
      this.opacityDiv.className = 'vis-opacity';

      this.brightnessDiv = document.createElement('div');
      this.brightnessDiv.className = 'vis-brightness';

      this.arrowDiv = document.createElement('div');
      this.arrowDiv.className = 'vis-arrow';

      this.opacityRange = document.createElement('input');
      try {
        this.opacityRange.type = 'range'; // Not supported on IE9
        this.opacityRange.min = '0';
        this.opacityRange.max = '100';
      } catch (err) {}
      // TODO: Add some error handling and remove this lint exception
      // eslint-disable-line no-empty
      this.opacityRange.value = '100';
      this.opacityRange.className = 'vis-range';

      this.brightnessRange = document.createElement('input');
      try {
        this.brightnessRange.type = 'range'; // Not supported on IE9
        this.brightnessRange.min = '0';
        this.brightnessRange.max = '100';
      } catch (err) {}
      // TODO: Add some error handling and remove this lint exception
      // eslint-disable-line no-empty
      this.brightnessRange.value = '100';
      this.brightnessRange.className = 'vis-range';

      this.opacityDiv.appendChild(this.opacityRange);
      this.brightnessDiv.appendChild(this.brightnessRange);

      var me = this;
      this.opacityRange.onchange = function () {
        me._setOpacity(this.value);
      };
      this.opacityRange.oninput = function () {
        me._setOpacity(this.value);
      };
      this.brightnessRange.onchange = function () {
        me._setBrightness(this.value);
      };
      this.brightnessRange.oninput = function () {
        me._setBrightness(this.value);
      };

      this.brightnessLabel = document.createElement('div');
      this.brightnessLabel.className = 'vis-label vis-brightness';
      this.brightnessLabel.innerHTML = 'brightness:';

      this.opacityLabel = document.createElement('div');
      this.opacityLabel.className = 'vis-label vis-opacity';
      this.opacityLabel.innerHTML = 'opacity:';

      this.newColorDiv = document.createElement('div');
      this.newColorDiv.className = 'vis-new-color';
      this.newColorDiv.innerHTML = 'new';

      this.initialColorDiv = document.createElement('div');
      this.initialColorDiv.className = 'vis-initial-color';
      this.initialColorDiv.innerHTML = 'initial';

      this.cancelButton = document.createElement('div');
      this.cancelButton.className = 'vis-button vis-cancel';
      this.cancelButton.innerHTML = 'cancel';
      this.cancelButton.onclick = this._hide.bind(this, false);

      this.applyButton = document.createElement('div');
      this.applyButton.className = 'vis-button vis-apply';
      this.applyButton.innerHTML = 'apply';
      this.applyButton.onclick = this._apply.bind(this);

      this.saveButton = document.createElement('div');
      this.saveButton.className = 'vis-button vis-save';
      this.saveButton.innerHTML = 'save';
      this.saveButton.onclick = this._save.bind(this);

      this.loadButton = document.createElement('div');
      this.loadButton.className = 'vis-button vis-load';
      this.loadButton.innerHTML = 'load last';
      this.loadButton.onclick = this._loadLast.bind(this);

      this.frame.appendChild(this.colorPickerDiv);
      this.frame.appendChild(this.arrowDiv);
      this.frame.appendChild(this.brightnessLabel);
      this.frame.appendChild(this.brightnessDiv);
      this.frame.appendChild(this.opacityLabel);
      this.frame.appendChild(this.opacityDiv);
      this.frame.appendChild(this.newColorDiv);
      this.frame.appendChild(this.initialColorDiv);

      this.frame.appendChild(this.cancelButton);
      this.frame.appendChild(this.applyButton);
      this.frame.appendChild(this.saveButton);
      this.frame.appendChild(this.loadButton);
    }

    /**
     * bind hammer to the color picker
     * @private
     */

  }, {
    key: '_bindHammer',
    value: function _bindHammer() {
      var _this2 = this;

      this.drag = {};
      this.pinch = {};
      this.hammer = new Hammer(this.colorPickerCanvas);
      this.hammer.get('pinch').set({ enable: true });

      hammerUtil.onTouch(this.hammer, function (event) {
        _this2._moveSelector(event);
      });
      this.hammer.on('tap', function (event) {
        _this2._moveSelector(event);
      });
      this.hammer.on('panstart', function (event) {
        _this2._moveSelector(event);
      });
      this.hammer.on('panmove', function (event) {
        _this2._moveSelector(event);
      });
      this.hammer.on('panend', function (event) {
        _this2._moveSelector(event);
      });
    }

    /**
     * generate the hue circle. This is relatively heavy (200ms) and is done only once on the first time it is shown.
     * @private
     */

  }, {
    key: '_generateHueCircle',
    value: function _generateHueCircle() {
      if (this.generated === false) {
        var ctx = this.colorPickerCanvas.getContext('2d');
        if (this.pixelRation === undefined) {
          this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
        }
        ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);

        // clear the canvas
        var w = this.colorPickerCanvas.clientWidth;
        var h = this.colorPickerCanvas.clientHeight;
        ctx.clearRect(0, 0, w, h);

        // draw hue circle
        var x = void 0,
            y = void 0,
            hue = void 0,
            sat = void 0;
        this.centerCoordinates = { x: w * 0.5, y: h * 0.5 };
        this.r = 0.49 * w;
        var angleConvert = 2 * Math.PI / 360;
        var hfac = 1 / 360;
        var sfac = 1 / this.r;
        var rgb = void 0;
        for (hue = 0; hue < 360; hue++) {
          for (sat = 0; sat < this.r; sat++) {
            x = this.centerCoordinates.x + sat * Math.sin(angleConvert * hue);
            y = this.centerCoordinates.y + sat * Math.cos(angleConvert * hue);
            rgb = util.HSVToRGB(hue * hfac, sat * sfac, 1);
            ctx.fillStyle = 'rgb(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ')';
            ctx.fillRect(x - 0.5, y - 0.5, 2, 2);
          }
        }
        ctx.strokeStyle = 'rgba(0,0,0,1)';
        ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);
        ctx.stroke();

        this.hueCircle = ctx.getImageData(0, 0, w, h);
      }
      this.generated = true;
    }

    /**
     * move the selector. This is called by hammer functions.
     *
     * @param {Event}  event   The event
     * @private
     */

  }, {
    key: '_moveSelector',
    value: function _moveSelector(event) {
      var rect = this.colorPickerDiv.getBoundingClientRect();
      var left = event.center.x - rect.left;
      var top = event.center.y - rect.top;

      var centerY = 0.5 * this.colorPickerDiv.clientHeight;
      var centerX = 0.5 * this.colorPickerDiv.clientWidth;

      var x = left - centerX;
      var y = top - centerY;

      var angle = Math.atan2(x, y);
      var radius = 0.98 * Math.min(Math.sqrt(x * x + y * y), centerX);

      var newTop = Math.cos(angle) * radius + centerY;
      var newLeft = Math.sin(angle) * radius + centerX;

      this.colorPickerSelector.style.top = newTop - 0.5 * this.colorPickerSelector.clientHeight + 'px';
      this.colorPickerSelector.style.left = newLeft - 0.5 * this.colorPickerSelector.clientWidth + 'px';

      // set color
      var h = angle / (2 * Math.PI);
      h = h < 0 ? h + 1 : h;
      var s = radius / this.r;
      var hsv = util.RGBToHSV(this.color.r, this.color.g, this.color.b);
      hsv.h = h;
      hsv.s = s;
      var rgba = util.HSVToRGB(hsv.h, hsv.s, hsv.v);
      rgba['a'] = this.color.a;
      this.color = rgba;

      // update previews
      this.initialColorDiv.style.backgroundColor = 'rgba(' + this.initialColor.r + ',' + this.initialColor.g + ',' + this.initialColor.b + ',' + this.initialColor.a + ')';
      this.newColorDiv.style.backgroundColor = 'rgba(' + this.color.r + ',' + this.color.g + ',' + this.color.b + ',' + this.color.a + ')';
    }
  }]);
  return ColorPicker;
}();

exports['default'] = ColorPicker;

/***/ }),
/* 193 */
/***/ (function(module, exports, __nested_webpack_require_1264437__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray2 = __nested_webpack_require_1264437__(15);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _classCallCheck2 = __nested_webpack_require_1264437__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_1264437__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

var _FloydWarshall = __nested_webpack_require_1264437__(194);

var _FloydWarshall2 = _interopRequireDefault(_FloydWarshall);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * KamadaKawai positions the nodes initially based on
 *
 * "AN ALGORITHM FOR DRAWING GENERAL UNDIRECTED GRAPHS"
 * -- Tomihisa KAMADA and Satoru KAWAI in 1989
 *
 * Possible optimizations in the distance calculation can be implemented.
 */
var KamadaKawai = function () {
  /**
   * @param {Object} body
   * @param {number} edgeLength
   * @param {number} edgeStrength
   */
  function KamadaKawai(body, edgeLength, edgeStrength) {
    (0, _classCallCheck3['default'])(this, KamadaKawai);

    this.body = body;
    this.springLength = edgeLength;
    this.springConstant = edgeStrength;
    this.distanceSolver = new _FloydWarshall2['default']();
  }

  /**
   * Not sure if needed but can be used to update the spring length and spring constant
   * @param {Object} options
   */


  (0, _createClass3['default'])(KamadaKawai, [{
    key: 'setOptions',
    value: function setOptions(options) {
      if (options) {
        if (options.springLength) {
          this.springLength = options.springLength;
        }
        if (options.springConstant) {
          this.springConstant = options.springConstant;
        }
      }
    }

    /**
     * Position the system
     * @param {Array.<Node>} nodesArray
     * @param {Array.<vis.Edge>} edgesArray
     * @param {boolean} [ignoreClusters=false]
     */

  }, {
    key: 'solve',
    value: function solve(nodesArray, edgesArray) {
      var ignoreClusters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      // get distance matrix
      var D_matrix = this.distanceSolver.getDistances(this.body, nodesArray, edgesArray); // distance matrix

      // get the L Matrix
      this._createL_matrix(D_matrix);

      // get the K Matrix
      this._createK_matrix(D_matrix);

      // initial E Matrix
      this._createE_matrix();

      // calculate positions
      var threshold = 0.01;
      var innerThreshold = 1;
      var iterations = 0;
      var maxIterations = Math.max(1000, Math.min(10 * this.body.nodeIndices.length, 6000));
      var maxInnerIterations = 5;

      var maxEnergy = 1e9;
      var highE_nodeId = 0,
          dE_dx = 0,
          dE_dy = 0,
          delta_m = 0,
          subIterations = 0;

      while (maxEnergy > threshold && iterations < maxIterations) {
        iterations += 1;
        var _getHighestEnergyNode2 = this._getHighestEnergyNode(ignoreClusters);

        var _getHighestEnergyNode3 = (0, _slicedToArray3['default'])(_getHighestEnergyNode2, 4);

        highE_nodeId = _getHighestEnergyNode3[0];
        maxEnergy = _getHighestEnergyNode3[1];
        dE_dx = _getHighestEnergyNode3[2];
        dE_dy = _getHighestEnergyNode3[3];

        delta_m = maxEnergy;
        subIterations = 0;
        while (delta_m > innerThreshold && subIterations < maxInnerIterations) {
          subIterations += 1;
          this._moveNode(highE_nodeId, dE_dx, dE_dy);
          var _getEnergy2 = this._getEnergy(highE_nodeId);

          var _getEnergy3 = (0, _slicedToArray3['default'])(_getEnergy2, 3);

          delta_m = _getEnergy3[0];
          dE_dx = _getEnergy3[1];
          dE_dy = _getEnergy3[2];
        }
      }
    }

    /**
     * get the node with the highest energy
     * @param {boolean} ignoreClusters
     * @returns {number[]}
     * @private
     */

  }, {
    key: '_getHighestEnergyNode',
    value: function _getHighestEnergyNode(ignoreClusters) {
      var nodesArray = this.body.nodeIndices;
      var nodes = this.body.nodes;
      var maxEnergy = 0;
      var maxEnergyNodeId = nodesArray[0];
      var dE_dx_max = 0,
          dE_dy_max = 0;

      for (var nodeIdx = 0; nodeIdx < nodesArray.length; nodeIdx++) {
        var m = nodesArray[nodeIdx];
        // by not evaluating nodes with predefined positions we should only move nodes that have no positions.
        if (nodes[m].predefinedPosition === false || nodes[m].isCluster === true && ignoreClusters === true || nodes[m].options.fixed.x === true || nodes[m].options.fixed.y === true) {
          var _getEnergy4 = this._getEnergy(m),
              _getEnergy5 = (0, _slicedToArray3['default'])(_getEnergy4, 3),
              delta_m = _getEnergy5[0],
              dE_dx = _getEnergy5[1],
              dE_dy = _getEnergy5[2];

          if (maxEnergy < delta_m) {
            maxEnergy = delta_m;
            maxEnergyNodeId = m;
            dE_dx_max = dE_dx;
            dE_dy_max = dE_dy;
          }
        }
      }

      return [maxEnergyNodeId, maxEnergy, dE_dx_max, dE_dy_max];
    }

    /**
     * calculate the energy of a single node
     * @param {Node.id} m
     * @returns {number[]}
     * @private
     */

  }, {
    key: '_getEnergy',
    value: function _getEnergy(m) {
      var _E_sums$m = (0, _slicedToArray3['default'])(this.E_sums[m], 2),
          dE_dx = _E_sums$m[0],
          dE_dy = _E_sums$m[1];

      var delta_m = Math.sqrt(Math.pow(dE_dx, 2) + Math.pow(dE_dy, 2));
      return [delta_m, dE_dx, dE_dy];
    }

    /**
     * move the node based on it's energy
     * the dx and dy are calculated from the linear system proposed by Kamada and Kawai
     * @param {number} m
     * @param {number} dE_dx
     * @param {number} dE_dy
     * @private
     */

  }, {
    key: '_moveNode',
    value: function _moveNode(m, dE_dx, dE_dy) {
      var nodesArray = this.body.nodeIndices;
      var nodes = this.body.nodes;
      var d2E_dx2 = 0;
      var d2E_dxdy = 0;
      var d2E_dy2 = 0;

      var x_m = nodes[m].x;
      var y_m = nodes[m].y;
      var km = this.K_matrix[m];
      var lm = this.L_matrix[m];

      for (var iIdx = 0; iIdx < nodesArray.length; iIdx++) {
        var i = nodesArray[iIdx];
        if (i !== m) {
          var x_i = nodes[i].x;
          var y_i = nodes[i].y;
          var kmat = km[i];
          var lmat = lm[i];
          var denominator = 1.0 / Math.pow(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2), 1.5);
          d2E_dx2 += kmat * (1 - lmat * Math.pow(y_m - y_i, 2) * denominator);
          d2E_dxdy += kmat * (lmat * (x_m - x_i) * (y_m - y_i) * denominator);
          d2E_dy2 += kmat * (1 - lmat * Math.pow(x_m - x_i, 2) * denominator);
        }
      }
      // make the variable names easier to make the solving of the linear system easier to read
      var A = d2E_dx2,
          B = d2E_dxdy,
          C = dE_dx,
          D = d2E_dy2,
          E = dE_dy;

      // solve the linear system for dx and dy
      var dy = (C / A + E / B) / (B / A - D / B);
      var dx = -(B * dy + C) / A;

      // move the node
      nodes[m].x += dx;
      nodes[m].y += dy;

      // Recalculate E_matrix (should be incremental)
      this._updateE_matrix(m);
    }

    /**
     * Create the L matrix: edge length times shortest path
     * @param {Object} D_matrix
     * @private
     */

  }, {
    key: '_createL_matrix',
    value: function _createL_matrix(D_matrix) {
      var nodesArray = this.body.nodeIndices;
      var edgeLength = this.springLength;

      this.L_matrix = [];
      for (var i = 0; i < nodesArray.length; i++) {
        this.L_matrix[nodesArray[i]] = {};
        for (var j = 0; j < nodesArray.length; j++) {
          this.L_matrix[nodesArray[i]][nodesArray[j]] = edgeLength * D_matrix[nodesArray[i]][nodesArray[j]];
        }
      }
    }

    /**
     * Create the K matrix: spring constants times shortest path
     * @param {Object} D_matrix
     * @private
     */

  }, {
    key: '_createK_matrix',
    value: function _createK_matrix(D_matrix) {
      var nodesArray = this.body.nodeIndices;
      var edgeStrength = this.springConstant;

      this.K_matrix = [];
      for (var i = 0; i < nodesArray.length; i++) {
        this.K_matrix[nodesArray[i]] = {};
        for (var j = 0; j < nodesArray.length; j++) {
          this.K_matrix[nodesArray[i]][nodesArray[j]] = edgeStrength * Math.pow(D_matrix[nodesArray[i]][nodesArray[j]], -2);
        }
      }
    }

    /**
     *  Create matrix with all energies between nodes
     *  @private
     */

  }, {
    key: '_createE_matrix',
    value: function _createE_matrix() {
      var nodesArray = this.body.nodeIndices;
      var nodes = this.body.nodes;
      this.E_matrix = {};
      this.E_sums = {};
      for (var mIdx = 0; mIdx < nodesArray.length; mIdx++) {
        this.E_matrix[nodesArray[mIdx]] = [];
      }
      for (var _mIdx = 0; _mIdx < nodesArray.length; _mIdx++) {
        var m = nodesArray[_mIdx];
        var x_m = nodes[m].x;
        var y_m = nodes[m].y;
        var dE_dx = 0;
        var dE_dy = 0;
        for (var iIdx = _mIdx; iIdx < nodesArray.length; iIdx++) {
          var i = nodesArray[iIdx];
          if (i !== m) {
            var x_i = nodes[i].x;
            var y_i = nodes[i].y;
            var denominator = 1.0 / Math.sqrt(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2));
            this.E_matrix[m][iIdx] = [this.K_matrix[m][i] * (x_m - x_i - this.L_matrix[m][i] * (x_m - x_i) * denominator), this.K_matrix[m][i] * (y_m - y_i - this.L_matrix[m][i] * (y_m - y_i) * denominator)];
            this.E_matrix[i][_mIdx] = this.E_matrix[m][iIdx];
            dE_dx += this.E_matrix[m][iIdx][0];
            dE_dy += this.E_matrix[m][iIdx][1];
          }
        }
        //Store sum
        this.E_sums[m] = [dE_dx, dE_dy];
      }
    }

    /**
     * Update method, just doing single column (rows are auto-updated) (update all sums)
     *
     * @param {number} m
     * @private
     */

  }, {
    key: '_updateE_matrix',
    value: function _updateE_matrix(m) {
      var nodesArray = this.body.nodeIndices;
      var nodes = this.body.nodes;
      var colm = this.E_matrix[m];
      var kcolm = this.K_matrix[m];
      var lcolm = this.L_matrix[m];
      var x_m = nodes[m].x;
      var y_m = nodes[m].y;
      var dE_dx = 0;
      var dE_dy = 0;
      for (var iIdx = 0; iIdx < nodesArray.length; iIdx++) {
        var i = nodesArray[iIdx];
        if (i !== m) {
          //Keep old energy value for sum modification below
          var cell = colm[iIdx];
          var oldDx = cell[0];
          var oldDy = cell[1];

          //Calc new energy:
          var x_i = nodes[i].x;
          var y_i = nodes[i].y;
          var denominator = 1.0 / Math.sqrt(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2));
          var dx = kcolm[i] * (x_m - x_i - lcolm[i] * (x_m - x_i) * denominator);
          var dy = kcolm[i] * (y_m - y_i - lcolm[i] * (y_m - y_i) * denominator);
          colm[iIdx] = [dx, dy];
          dE_dx += dx;
          dE_dy += dy;

          //add new energy to sum of each column
          var sum = this.E_sums[i];
          sum[0] += dx - oldDx;
          sum[1] += dy - oldDy;
        }
      }
      //Store sum at -1 index
      this.E_sums[m] = [dE_dx, dE_dy];
    }
  }]);
  return KamadaKawai;
}(); // distance finding algorithm


exports['default'] = KamadaKawai;

/***/ }),
/* 194 */
/***/ (function(module, exports, __nested_webpack_require_1275973__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __nested_webpack_require_1275973__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __nested_webpack_require_1275973__(1);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 *  The FloydWarshall algorithm is an algorithm for finding shortest paths in
 *  a weighted graph with positive or negative edge weights (but with no negative
 *  cycles). - https://en.wikipedia.org/wiki/FloydWarshall_algorithm
 */
var FloydWarshall = function () {
  /**
   * @ignore
   */
  function FloydWarshall() {
    (0, _classCallCheck3["default"])(this, FloydWarshall);
  }

  /**
   *
   * @param {Object} body
   * @param {Array.<Node>} nodesArray
   * @param {Array.<Edge>} edgesArray
   * @returns {{}}
   */


  (0, _createClass3["default"])(FloydWarshall, [{
    key: "getDistances",
    value: function getDistances(body, nodesArray, edgesArray) {
      var D_matrix = {};
      var edges = body.edges;

      // prepare matrix with large numbers
      for (var i = 0; i < nodesArray.length; i++) {
        var node = nodesArray[i];
        var cell = {};
        D_matrix[node] = cell;
        for (var j = 0; j < nodesArray.length; j++) {
          cell[nodesArray[j]] = i == j ? 0 : 1e9;
        }
      }

      // put the weights for the edges in. This assumes unidirectionality.
      for (var _i = 0; _i < edgesArray.length; _i++) {
        var edge = edges[edgesArray[_i]];
        // edge has to be connected if it counts to the distances. If it is connected to inner clusters it will crash so we also check if it is in the D_matrix
        if (edge.connected === true && D_matrix[edge.fromId] !== undefined && D_matrix[edge.toId] !== undefined) {
          D_matrix[edge.fromId][edge.toId] = 1;
          D_matrix[edge.toId][edge.fromId] = 1;
        }
      }

      var nodeCount = nodesArray.length;

      // Adapted FloydWarshall based on unidirectionality to greatly reduce complexity.
      for (var k = 0; k < nodeCount; k++) {
        var knode = nodesArray[k];
        var kcolm = D_matrix[knode];
        for (var _i2 = 0; _i2 < nodeCount - 1; _i2++) {
          var inode = nodesArray[_i2];
          var icolm = D_matrix[inode];
          for (var _j = _i2 + 1; _j < nodeCount; _j++) {
            var jnode = nodesArray[_j];
            var jcolm = D_matrix[jnode];

            var val = Math.min(icolm[jnode], icolm[knode] + kcolm[jnode]);
            icolm[jnode] = val;
            jcolm[inode] = val;
          }
        }
      }

      return D_matrix;
    }
  }]);
  return FloydWarshall;
}();

exports["default"] = FloydWarshall;

/***/ })
/******/ ]);
});
//# sourceMappingURL=vis.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCOztBQUVBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBLGtCQUFrQiwrSEFBK0gsZUFBZSx3RUFBd0UsT0FBTztBQUMvTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLDZCQUE2QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxzQkFBc0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hELHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLElBQUk7QUFDL0I7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsSUFBSTs7QUFFaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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OztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixPQUFPO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHNEQUFzRCw2QkFBNkIsVUFBVTtBQUNqSjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwrQkFBK0I7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkMsRUFBRSxJQUFJLEVBQUU7QUFDbkQsd0NBQXdDLEVBQUUsSUFBSSxFQUFFOztBQUVoRDs7QUFFQTtBQUNBLGlDQUFpQyxFQUFFO0FBQ25DLDJCQUEyQixFQUFFO0FBQzdCLDZCQUE2QixFQUFFO0FBQy9CLDJCQUEyQixFQUFFO0FBQzdCLHlCQUF5QixFQUFFLElBQUksRUFBRTtBQUNqQyx3QkFBd0IsRUFBRTtBQUMxQiwrQkFBK0IsR0FBRztBQUNsQyx5QkFBeUIsRUFBRTtBQUMzQjtBQUNBLDJCQUEyQixFQUFFLElBQUksRUFBRTtBQUNuQywwQkFBMEIsRUFBRSxJQUFJLEVBQUU7QUFDbEMsd0JBQXdCLEVBQUU7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUE4RCxJQUFJLDBEQUEwRCxJQUFJLHFFQUFxRSxFQUFFOztBQUV2TTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGtDQUFrQyxnQkFBZ0I7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNEJBQTRCO0FBQ3RDO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGNBQWM7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSw4REFBOEQ7QUFDOUQsMERBQTBEO0FBQzFELGdFQUFnRTtBQUNoRSx5REFBeUQsT0FBTztBQUNoRSx5REFBeUQsT0FBTztBQUNoRSx3REFBd0QsT0FBTztBQUMvRCxvRUFBb0UsT0FBTztBQUMzRSxzRUFBc0UsT0FBTztBQUM3RTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxxQkFBcUI7QUFDeEQsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMscUJBQXFCO0FBQ3hELFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsbUJBQW1CO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRCw0QkFBNEIsZUFBZSxpQ0FBbUI7O0FBRTlELE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxFQUFFO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsVUFBVTtBQUNyQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRLElBQUk7QUFDdkIsV0FBVyxRQUFRLElBQUk7QUFDdkIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLFVBQVU7QUFDVixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLENBQUM7O0FBRUQ7QUFDQSxVQUFVO0FBQ1YsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLDZCQUE2QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixHQUFHO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsNEJBQTRCO0FBQzNDLGVBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSx3REFBd0QsdUJBQXVCO0FBQy9FOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSwwQ0FBMEMsc0JBQXNCO0FBQ2hFO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtREFBbUQsZ0NBQWdDO0FBQ25GO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGdEQUFnRDtBQUN0RTtBQUNBLDZDQUE2Qzs7QUFFN0M7QUFDQSxVQUFVO0FBQ1YsbURBQW1EO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDhDQUE4QztBQUM5Qyw0QkFBNEI7O0FBRTVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLEtBQUk7O0FBRWxDO0FBQ0E7O0FBRUEsNkJBQTZCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekM7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHNCQUFzQixnREFBZ0Q7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQ7OztBQUdBO0FBQ0E7QUFDQSxDQUFDOztBQUVELHVCQUF1QixpQ0FBbUI7O0FBRTFDOztBQUVBLG9CQUFvQixpQ0FBbUI7O0FBRXZDOztBQUVBLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxnRUFBZ0UsbUJBQW1CO0FBQ2pHLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQiw0QkFBNEI7QUFDbEQ7QUFDQSw0QkFBNEIsd0JBQXdCO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxpREFBaUQ7QUFDakQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEOztBQUVBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBEOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCx1QkFBdUIsaUNBQW1COztBQUUxQzs7QUFFQSxvQkFBb0IsaUNBQW1COztBQUV2Qzs7QUFFQSx1Q0FBdUMsdUNBQXVDOztBQUU5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsZ0VBQWdFLG1CQUFtQjtBQUNqRyxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQiw0QkFBNEI7QUFDOUM7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQ7OztBQUdBO0FBQ0E7QUFDQSxDQUFDOztBQUVELHVCQUF1QixpQ0FBbUI7O0FBRTFDOztBQUVBLG9CQUFvQixpQ0FBbUI7O0FBRXZDOztBQUVBLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxnRUFBZ0UsbUJBQW1CO0FBQ2pHLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0Isd0JBQXdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEOztBQUVBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBEOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCx1QkFBdUIsaUNBQW1COztBQUUxQzs7QUFFQSxvQkFBb0IsaUNBQW1COztBQUV2Qzs7QUFFQSx1Q0FBdUMsdUNBQXVDOztBQUU5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsZ0VBQWdFLG1CQUFtQjtBQUNqRyxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIseUJBQXlCO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQ7OztBQUdBO0FBQ0E7QUFDQSxDQUFDOztBQUVELHNCQUFzQixpQ0FBbUI7O0FBRXpDOztBQUVBLHVCQUF1QixpQ0FBbUI7O0FBRTFDOztBQUVBLG9CQUFvQixpQ0FBbUI7O0FBRXZDOztBQUVBLGtDQUFrQyxpQ0FBbUI7O0FBRXJEOztBQUVBLGlCQUFpQixpQ0FBbUI7O0FBRXBDOztBQUVBLHdCQUF3QixpQ0FBbUI7O0FBRTNDOztBQUVBLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxnRUFBZ0UsbUJBQW1CO0FBQ2pHLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsTUFBTTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEOztBQUVBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBEOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxzQkFBc0IsaUNBQW1COztBQUV6Qzs7QUFFQSx1QkFBdUIsaUNBQW1COztBQUUxQzs7QUFFQSxvQkFBb0IsaUNBQW1COztBQUV2Qzs7QUFFQSxrQ0FBa0MsaUNBQW1COztBQUVyRDs7QUFFQSxpQkFBaUIsaUNBQW1COztBQUVwQzs7QUFFQSw2QkFBNkIsaUNBQW1COztBQUVoRDs7QUFFQSx1Q0FBdUMsdUNBQXVDOztBQUU5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsZ0VBQWdFLG1CQUFtQjtBQUNqRyxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLHVCQUF1QjtBQUNwQyxhQUFhLE1BQU07QUFDbkI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEOztBQUVBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBEOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxZQUFZLGlDQUFtQjs7QUFFL0I7O0FBRUEsZUFBZSxpQ0FBbUI7O0FBRWxDOztBQUVBLHVCQUF1QixpQ0FBbUI7O0FBRTFDOztBQUVBLG9CQUFvQixpQ0FBbUI7O0FBRXZDOztBQUVBLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFOztBQUVBOztBQUVBO0FBQ0EsMkRBQTJEO0FBQzNEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUEseUNBQXlDO0FBQ3pDOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQSxtRUFBbUU7QUFDbkU7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQSxXQUFXLGlDQUFtQjtBQUM5QixrQkFBa0IsaUNBQW1CO0FBQ3JDLGNBQWMsaUNBQW1CO0FBQ2pDLFdBQVcsaUNBQW1CLGlCQUFpQjtBQUMvQyxXQUFXLGlDQUFtQixpQkFBaUI7O0FBRS9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDhCQUE4QiwwQkFBMEI7QUFDeEQsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixrQ0FBa0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsNEJBQTRCO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdUJBQXVCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixtQkFBbUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBLGdDQUFnQyxxQkFBcUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxnQ0FBZ0MsNENBQTRDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLGtDQUFrQztBQUN4RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsNEJBQTRCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDLGdCQUFnQix3QkFBd0I7QUFDeEMsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLDRCQUE0QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQyx3Q0FBd0M7QUFDekU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsVUFBVTtBQUMzQixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLDBCQUEwQix1QkFBdUI7QUFDakQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQjtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsZUFBZSxXQUFXO0FBQzFCLGVBQWUsV0FBVyxxQ0FBcUM7QUFDL0QsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLDZCQUE2QjtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9EQUFvRDs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrQ0FBa0M7QUFDNUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsaUJBQWlCO0FBQ2pCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsZUFBZTs7QUFFdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsOEJBQThCO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsK0JBQStCO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsNENBQTRDO0FBQ3BFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0Esd0dBQXdHLDhCQUE4QjtBQUN0SSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUI7QUFDakI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGlCQUFpQjtBQUNqQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxRQUFRO0FBQ3ZCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsUUFBUTtBQUN2Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGlCQUFpQjtBQUNqQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixpQkFBaUIscUJBQXFCO0FBQ3RDOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDBCQUEwQix5QkFBeUI7QUFDbkQ7O0FBRUE7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLGtDQUFrQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCLGVBQWUsTUFBTTtBQUNyQixlQUFlLFFBQVE7QUFDdkI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdCQUFnQjtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZ0JBQWdCO0FBQ2pFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFVBQVU7QUFDekIsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLDJCQUEyQjtBQUNuRDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLHlCQUF5Qiw0QkFBNEI7QUFDckQsbURBQW1EO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixnQkFBZ0IsU0FBUztBQUN6Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZ0JBQWdCLFNBQVM7QUFDekI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRDs7O0FBR0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsc0JBQXNCLGlDQUFtQjs7QUFFekM7O0FBRUEsdUJBQXVCLGlDQUFtQjs7QUFFMUM7O0FBRUEsb0JBQW9CLGlDQUFtQjs7QUFFdkM7O0FBRUEsa0NBQWtDLGlDQUFtQjs7QUFFckQ7O0FBRUEsaUJBQWlCLGlDQUFtQjs7QUFFcEM7O0FBRUEsdUNBQXVDLHVDQUF1Qzs7QUFFOUUsV0FBVyxpQ0FBbUI7QUFDOUIsV0FBVyxpQ0FBbUI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLHlCQUF5QjtBQUN0QyxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRDs7O0FBR0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsdUJBQXVCLGlDQUFtQjs7QUFFMUM7O0FBRUEsb0JBQW9CLGlDQUFtQjs7QUFFdkM7O0FBRUEsdUNBQXVDLHVDQUF1Qzs7QUFFOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLGlDQUFtQjs7QUFFOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7O0FBRWpEOztBQUVBLDZCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNEJBQTRCO0FBQzNDLGVBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDLGVBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx3QkFBd0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGdCQUFnQix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQ7OztBQUdBO0FBQ0E7QUFDQSxDQUFDOztBQUVELHVCQUF1QixpQ0FBbUI7O0FBRTFDOztBQUVBLG9CQUFvQixpQ0FBbUI7O0FBRXZDOztBQUVBLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFLGFBQWEsaUNBQW1CO0FBQ2hDLGlCQUFpQixpQ0FBbUI7O0FBRXBDLFdBQVcsaUNBQW1COztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDOztBQUVqQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDLGNBQWM7QUFDbkQ7QUFDQSxtQ0FBbUMsK0NBQStDOztBQUVsRjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0EsMEZBQTBGO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRDs7O0FBR0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsY0FBYyxpQ0FBbUI7O0FBRWpDOztBQUVBLHVCQUF1QixpQ0FBbUI7O0FBRTFDOztBQUVBLG9CQUFvQixpQ0FBbUI7O0FBRXZDOztBQUVBLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFLFdBQVcsaUNBQW1COztBQUU5QixrQkFBa0IsaUNBQW1COztBQUVyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUSxXQUFXO0FBQ2hDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVEsV0FBVyxhQUFhO0FBQy9DLGVBQWUsU0FBUztBQUN4Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDBGQUEwRjtBQUMxRjs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxtRUFBbUU7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUSxnQ0FBZ0Msc0JBQXNCO0FBQzdFO0FBQ0EsdURBQXVELHNCQUFzQjtBQUM3RSx3REFBd0Qsd0NBQXdDO0FBQ2hHOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUSxnQ0FBZ0Msc0JBQXNCO0FBQzdFO0FBQ0E7QUFDQSx1REFBdUQsc0JBQXNCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHVGQUF1RjtBQUN2Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEOztBQUVBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxrQ0FBbUI7O0FBRXBEOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCx1QkFBdUIsa0NBQW1COztBQUUxQzs7QUFFQSxvQkFBb0Isa0NBQW1COztBQUV2Qzs7QUFFQSx1Q0FBdUMsdUNBQXVDOztBQUU5RSxXQUFXLGtDQUFtQjtBQUM5Qix3QkFBd0Isa0NBQW1CO0FBQzNDLFlBQVksa0NBQW1COztBQUUvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwwQkFBMEI7QUFDM0M7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLHVCQUF1QjtBQUN2QyxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHNDQUFzQyxvQ0FBb0M7QUFDMUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0NBQStDO0FBQy9ELGdCQUFnQiwrQ0FBK0M7QUFDL0Qsa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QywrQkFBK0I7QUFDM0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLG9DQUFvQzs7QUFFOUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLG9DQUFvQztBQUMxRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHlCQUF5QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEOztBQUVBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxrQ0FBbUI7O0FBRXBEOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCx1QkFBdUIsa0NBQW1COztBQUUxQzs7QUFFQSxvQkFBb0Isa0NBQW1COztBQUV2Qzs7QUFFQSx1Q0FBdUMsdUNBQXVDOztBQUU5RSxhQUFhLGtDQUFtQjtBQUNoQyxpQkFBaUIsa0NBQW1CO0FBQ3BDLGVBQWUsa0NBQW1COztBQUVsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUNBQW1DO0FBQzNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLDJCQUEyQjtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGVBQWU7QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUMseUNBQXlDO0FBQzlFLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFJO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLEtBQUssWUFRTjtBQUNILENBQUM7QUFDRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxZQUFZO0FBQ3ZCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLFFBQVE7QUFDdkI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsa0NBQW1COztBQUVwRDs7O0FBR0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsWUFBWSxrQ0FBbUI7O0FBRS9COztBQUVBLGlCQUFpQixrQ0FBbUI7O0FBRXBDOztBQUVBLGVBQWUsa0NBQW1COztBQUVsQzs7QUFFQSx1QkFBdUIsa0NBQW1COztBQUUxQzs7QUFFQSxvQkFBb0Isa0NBQW1COztBQUV2Qzs7QUFFQSx1Q0FBdUMsdUNBQXVDOztBQUU5RSxXQUFXLGtDQUFtQjtBQUM5QixhQUFhLGtDQUFtQjtBQUNoQyxpQkFBaUIsa0NBQW1COztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZF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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQSwwQkFBMEIscUJBQXFCO0FBQy9DO0FBQ0E7QUFDQSxpQ0FBaUMsZ0JBQWdCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEOztBQUVBLE9BQU87QUFDUDtBQUNBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9jYWNoZS92aXNqcy1uZXR3b3JrLW5wbS00LjI1LjAtMmU5MGVmYWVlZC00MGJmY2JiZjJiLnppcC9ub2RlX21vZHVsZXMvdmlzanMtbmV0d29yay9kaXN0L3Zpcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIHZpcy5qc1xuICogaHR0cHM6Ly9naXRodWIuY29tL2FsbWVuZGUvdmlzXG4gKlxuICogQSBkeW5hbWljLCBicm93c2VyLWJhc2VkIHZpc3VhbGl6YXRpb24gbGlicmFyeS5cbiAqXG4gKiBAdmVyc2lvbiA0LjI1LjBcbiAqIEBkYXRlICAgIDIwMTgtMDktMjBcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChDKSAyMDExLTIwMTcgQWxtZW5kZSBCLlYsIGh0dHA6Ly9hbG1lbmRlLmNvbVxuICpcbiAqIFZpcy5qcyBpcyBkdWFsIGxpY2Vuc2VkIHVuZGVyIGJvdGhcbiAqXG4gKiAqIFRoZSBBcGFjaGUgMi4wIExpY2Vuc2VcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogYW5kXG4gKlxuICogKiBUaGUgTUlUIExpY2Vuc2VcbiAqICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICpcbiAqIFZpcy5qcyBtYXkgYmUgZGlzdHJpYnV0ZWQgdW5kZXIgZWl0aGVyIGxpY2Vuc2UuXG4gKi9cblxuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1widmlzXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcInZpc1wiXSA9IGZhY3RvcnkoKTtcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4vKioqKioqLyBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4vKioqKioqLyBcdFx0XHRcdGdldDogZ2V0dGVyXG4vKioqKioqLyBcdFx0XHR9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gODUpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzMCk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVmaW5lUHJvcGVydHkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0oKTtcblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfZ2V0SXRlcmF0b3IyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OCk7XG5cbnZhciBfZ2V0SXRlcmF0b3IzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0SXRlcmF0b3IyKTtcblxudmFyIF9jcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKTtcblxudmFyIF9jcmVhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlKTtcblxudmFyIF9rZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxudmFyIF9rZXlzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2tleXMpO1xuXG52YXIgX3R5cGVvZjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG52YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vLyB1dGlsaXR5IGZ1bmN0aW9uc1xuXG4vLyBmaXJzdCBjaGVjayBpZiBtb21lbnQuanMgaXMgYWxyZWFkeSBsb2FkZWQgaW4gdGhlIGJyb3dzZXIgd2luZG93LCBpZiBzbyxcbi8vIHVzZSB0aGlzIGluc3RhbmNlLiBFbHNlLCBsb2FkIHZpYSBjb21tb25qcy5cblxudmFyIG1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNzEpO1xudmFyIHV1aWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExOSk7XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIGdpdmVuIG9iamVjdCBpcyBhIG51bWJlclxuICogQHBhcmFtIHsqfSBvYmplY3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGlzTnVtYmVyXG4gKi9cbmV4cG9ydHMuaXNOdW1iZXIgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBOdW1iZXIgfHwgdHlwZW9mIG9iamVjdCA9PSAnbnVtYmVyJztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGV2ZXJ5dGhpbmcgaW4gdGhlIERPTSBvYmplY3RcbiAqIEBwYXJhbSB7RWxlbWVudH0gRE9Nb2JqZWN0XG4gKi9cbmV4cG9ydHMucmVjdXJzaXZlRE9NRGVsZXRlID0gZnVuY3Rpb24gKERPTW9iamVjdCkge1xuICBpZiAoRE9Nb2JqZWN0KSB7XG4gICAgd2hpbGUgKERPTW9iamVjdC5oYXNDaGlsZE5vZGVzKCkgPT09IHRydWUpIHtcbiAgICAgIGV4cG9ydHMucmVjdXJzaXZlRE9NRGVsZXRlKERPTW9iamVjdC5maXJzdENoaWxkKTtcbiAgICAgIERPTW9iamVjdC5yZW1vdmVDaGlsZChET01vYmplY3QuZmlyc3RDaGlsZCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFRlc3Qgd2hldGhlciBnaXZlbiBvYmplY3QgaXMgYSBzdHJpbmdcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0XG4gKiBAcmV0dXJuIHtCb29sZWFufSBpc1N0cmluZ1xuICovXG5leHBvcnRzLmlzU3RyaW5nID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgU3RyaW5nIHx8IHR5cGVvZiBvYmplY3QgPT0gJ3N0cmluZyc7XG59O1xuXG4vKipcbiAqIFRlc3Qgd2hldGhlciBnaXZlbiBvYmplY3QgaXMgYSBEYXRlLCBvciBhIFN0cmluZyBjb250YWluaW5nIGEgRGF0ZVxuICogQHBhcmFtIHtEYXRlIHwgU3RyaW5nfSBvYmplY3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGlzRGF0ZVxuICovXG5leHBvcnRzLmlzRGF0ZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChleHBvcnRzLmlzU3RyaW5nKG9iamVjdCkpIHtcbiAgICAvLyB0ZXN0IHdoZXRoZXIgdGhpcyBzdHJpbmcgY29udGFpbnMgYSBkYXRlXG4gICAgdmFyIG1hdGNoID0gQVNQRGF0ZVJlZ2V4LmV4ZWMob2JqZWN0KTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIWlzTmFOKERhdGUucGFyc2Uob2JqZWN0KSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgVVVJRFxuICogQHJldHVybiB7c3RyaW5nfSB1dWlkXG4gKi9cbmV4cG9ydHMucmFuZG9tVVVJRCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHV1aWQudjQoKTtcbn07XG5cbi8qKlxuICogQ29weSBwcm9wZXJ0eSBmcm9tIGIgdG8gYSBpZiBwcm9wZXJ0eSBwcmVzZW50IGluIGEuXG4gKiBJZiBwcm9wZXJ0eSBpbiBiIGV4cGxpY2l0bHkgc2V0IHRvIG51bGwsIGRlbGV0ZSBpdCBpZiBgYWxsb3dEZWxldGlvbmAgc2V0LlxuICpcbiAqIEludGVybmFsIGhlbHBlciByb3V0aW5lLCBzaG91bGQgbm90IGJlIGV4cG9ydGVkLiBOb3QgYWRkZWQgdG8gYGV4cG9ydHNgIGZvciB0aGF0IHJlYXNvbi5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYSAgdGFyZ2V0IG9iamVjdFxuICogQHBhcmFtIHtvYmplY3R9IGIgIHNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wICBuYW1lIG9mIHByb3BlcnR5IHRvIGNvcHkgdG8gYVxuICogQHBhcmFtIHtib29sZWFufSBhbGxvd0RlbGV0aW9uICBpZiB0cnVlLCBkZWxldGUgcHJvcGVydHkgaW4gYSBpZiBleHBsaWNpdGx5IHNldCB0byBudWxsIGluIGJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvcHlPckRlbGV0ZShhLCBiLCBwcm9wLCBhbGxvd0RlbGV0aW9uKSB7XG4gIHZhciBkb0RlbGV0aW9uID0gZmFsc2U7XG4gIGlmIChhbGxvd0RlbGV0aW9uID09PSB0cnVlKSB7XG4gICAgZG9EZWxldGlvbiA9IGJbcHJvcF0gPT09IG51bGwgJiYgYVtwcm9wXSAhPT0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKGRvRGVsZXRpb24pIHtcbiAgICBkZWxldGUgYVtwcm9wXTtcbiAgfSBlbHNlIHtcbiAgICBhW3Byb3BdID0gYltwcm9wXTsgLy8gUmVtZW1iZXIsIHRoaXMgaXMgYSByZWZlcmVuY2UgY29weSFcbiAgfVxufVxuXG4vKipcbiAqIEZpbGwgYW4gb2JqZWN0IHdpdGggYSBwb3NzaWJseSBwYXJ0aWFsbHkgZGVmaW5lZCBvdGhlciBvYmplY3QuXG4gKlxuICogT25seSBjb3BpZXMgdmFsdWVzIGZvciB0aGUgcHJvcGVydGllcyBhbHJlYWR5IHByZXNlbnQgaW4gYS5cbiAqIFRoYXQgbWVhbnMgYW4gb2JqZWN0IGlzIG5vdCBjcmVhdGVkIG9uIGEgcHJvcGVydHkgaWYgb25seSB0aGUgYiBvYmplY3QgaGFzIGl0LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhXG4gKiBAcGFyYW0ge29iamVjdH0gYlxuICogQHBhcmFtIHtib29sZWFufSBbYWxsb3dEZWxldGlvbj1mYWxzZV0gIGlmIHRydWUsIGRlbGV0ZSBwcm9wZXJ0aWVzIGluIGEgdGhhdCBhcmUgZXhwbGljaXRseSBzZXQgdG8gbnVsbCBpbiBiXG4gKi9cbmV4cG9ydHMuZmlsbElmRGVmaW5lZCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIHZhciBhbGxvd0RlbGV0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICAvLyBOT1RFOiBpdGVyYXRpb24gb2YgcHJvcGVydGllcyBvZiBhXG4gIC8vIE5PVEU6IHByb3RvdHlwZSBwcm9wZXJ0aWVzIGl0ZXJhdGVkIG92ZXIgYXMgd2VsbFxuICBmb3IgKHZhciBwcm9wIGluIGEpIHtcbiAgICBpZiAoYltwcm9wXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoYltwcm9wXSA9PT0gbnVsbCB8fCAoMCwgX3R5cGVvZjNbJ2RlZmF1bHQnXSkoYltwcm9wXSkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIE5vdGU6IHR5cGVvZiBudWxsID09PSAnb2JqZWN0J1xuICAgICAgICBjb3B5T3JEZWxldGUoYSwgYiwgcHJvcCwgYWxsb3dEZWxldGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoKDAsIF90eXBlb2YzWydkZWZhdWx0J10pKGFbcHJvcF0pID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGV4cG9ydHMuZmlsbElmRGVmaW5lZChhW3Byb3BdLCBiW3Byb3BdLCBhbGxvd0RlbGV0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBFeHRlbmQgb2JqZWN0IGEgd2l0aCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYiBvciBhIHNlcmllcyBvZiBvYmplY3RzXG4gKiBPbmx5IHByb3BlcnRpZXMgd2l0aCBkZWZpbmVkIHZhbHVlcyBhcmUgY29waWVkXG4gKiBAcGFyYW0ge09iamVjdH0gYVxuICogQHBhcmFtIHsuLi5PYmplY3R9IGJcbiAqIEByZXR1cm4ge09iamVjdH0gYVxuICovXG5leHBvcnRzLmV4dGVuZCA9IGZ1bmN0aW9uIChhIC8qIGIgKi8pIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBvdGhlciA9IGFyZ3VtZW50c1tpXTtcbiAgICBmb3IgKHZhciBwcm9wIGluIG90aGVyKSB7XG4gICAgICBpZiAob3RoZXIuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgYVtwcm9wXSA9IG90aGVyW3Byb3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYTtcbn07XG5cbi8qKlxuICogRXh0ZW5kIG9iamVjdCBhIHdpdGggc2VsZWN0ZWQgcHJvcGVydGllcyBvZiBvYmplY3QgYiBvciBhIHNlcmllcyBvZiBvYmplY3RzXG4gKiBPbmx5IHByb3BlcnRpZXMgd2l0aCBkZWZpbmVkIHZhbHVlcyBhcmUgY29waWVkXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBwcm9wc1xuICogQHBhcmFtIHtPYmplY3R9IGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBiXG4gKiBAcmV0dXJuIHtPYmplY3R9IGFcbiAqL1xuZXhwb3J0cy5zZWxlY3RpdmVFeHRlbmQgPSBmdW5jdGlvbiAocHJvcHMsIGEgLyogYiAqLykge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIGlmICghQXJyYXkuaXNBcnJheShwcm9wcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FycmF5IHdpdGggcHJvcGVydHkgbmFtZXMgZXhwZWN0ZWQgYXMgZmlyc3QgYXJndW1lbnQnKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG90aGVyID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIgcCA9IDA7IHAgPCBwcm9wcy5sZW5ndGg7IHArKykge1xuICAgICAgdmFyIHByb3AgPSBwcm9wc1twXTtcbiAgICAgIGlmIChvdGhlciAmJiBvdGhlci5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICBhW3Byb3BdID0gb3RoZXJbcHJvcF07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBhO1xufTtcblxuLyoqXG4gKiBFeHRlbmQgb2JqZWN0IGEgd2l0aCBzZWxlY3RlZCBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiLlxuICogT25seSBwcm9wZXJ0aWVzIHdpdGggZGVmaW5lZCB2YWx1ZXMgYXJlIGNvcGllZC5cbiAqXG4gKiAqKk5vdGU6KiogUHJldmlvdXMgdmVyc2lvbiBvZiB0aGlzIHJvdXRpbmUgaW1wbGllZCB0aGF0IG11bHRpcGxlIHNvdXJjZSBvYmplY3RzXG4gKiAgICAgICAgICAgY291bGQgYmUgdXNlZDsgaG93ZXZlciwgdGhlIGltcGxlbWVudGF0aW9uIHdhcyAqKndyb25nKiouXG4gKiAgICAgICAgICAgU2luY2UgbXVsdGlwbGUgKD4xKSBzb3VyY2VzIHdlcmVuJ3QgdXNlZCBhbnl3aGVyZSBpbiB0aGUgYHZpcy5qc2AgY29kZSxcbiAqICAgICAgICAgICB0aGlzIGhhcyBiZWVuIHJlbW92ZWRcbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBwcm9wcyBuYW1lcyBvZiBmaXJzdC1sZXZlbCBwcm9wZXJ0aWVzIHRvIGNvcHkgb3ZlclxuICogQHBhcmFtIHtvYmplY3R9IGEgIHRhcmdldCBvYmplY3RcbiAqIEBwYXJhbSB7b2JqZWN0fSBiICBzb3VyY2Ugb2JqZWN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthbGxvd0RlbGV0aW9uPWZhbHNlXSAgaWYgdHJ1ZSwgZGVsZXRlIHByb3BlcnR5IGluIGEgaWYgZXhwbGljaXRseSBzZXQgdG8gbnVsbCBpbiBiXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBhXG4gKi9cbmV4cG9ydHMuc2VsZWN0aXZlRGVlcEV4dGVuZCA9IGZ1bmN0aW9uIChwcm9wcywgYSwgYikge1xuICB2YXIgYWxsb3dEZWxldGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG5cbiAgLy8gVE9ETzogYWRkIHN1cHBvcnQgZm9yIEFycmF5cyB0byBkZWVwRXh0ZW5kXG4gIGlmIChBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXlzIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IGRlZXBFeHRlbmQnKTtcbiAgfVxuXG4gIGZvciAodmFyIHAgPSAwOyBwIDwgcHJvcHMubGVuZ3RoOyBwKyspIHtcbiAgICB2YXIgcHJvcCA9IHByb3BzW3BdO1xuICAgIGlmIChiLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICBpZiAoYltwcm9wXSAmJiBiW3Byb3BdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgaWYgKGFbcHJvcF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGFbcHJvcF0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYVtwcm9wXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgICAgZXhwb3J0cy5kZWVwRXh0ZW5kKGFbcHJvcF0sIGJbcHJvcF0sIGZhbHNlLCBhbGxvd0RlbGV0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb3B5T3JEZWxldGUoYSwgYiwgcHJvcCwgYWxsb3dEZWxldGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShiW3Byb3BdKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgZGVlcEV4dGVuZCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29weU9yRGVsZXRlKGEsIGIsIHByb3AsIGFsbG93RGVsZXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYTtcbn07XG5cbi8qKlxuICogRXh0ZW5kIG9iamVjdCBgYWAgd2l0aCBwcm9wZXJ0aWVzIG9mIG9iamVjdCBgYmAsIGlnbm9yaW5nIHByb3BlcnRpZXMgd2hpY2ggYXJlIGV4cGxpY2l0bHlcbiAqIHNwZWNpZmllZCB0byBiZSBleGNsdWRlZC5cbiAqXG4gKiBUaGUgcHJvcGVydGllcyBvZiBgYmAgYXJlIGNvbnNpZGVyZWQgZm9yIGNvcHlpbmcuXG4gKiBQcm9wZXJ0aWVzIHdoaWNoIGFyZSB0aGVtc2VsdmVzIG9iamVjdHMgYXJlIGFyZSBhbHNvIGV4dGVuZGVkLlxuICogT25seSBwcm9wZXJ0aWVzIHdpdGggZGVmaW5lZCB2YWx1ZXMgYXJlIGNvcGllZFxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IHByb3BzVG9FeGNsdWRlICBuYW1lcyBvZiBwcm9wZXJ0aWVzIHdoaWNoIHNob3VsZCAqbm90KiBiZSBjb3BpZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICBhICBvYmplY3QgdG8gZXh0ZW5kXG4gKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAgYiAgb2JqZWN0IHRvIHRha2UgcHJvcGVydGllcyBmcm9tIGZvciBleHRlbnNpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FsbG93RGVsZXRpb249ZmFsc2VdICBpZiB0cnVlLCBkZWxldGUgcHJvcGVydGllcyBpbiBhIHRoYXQgYXJlIGV4cGxpY2l0bHkgc2V0IHRvIG51bGwgaW4gYlxuICogQHJldHVybiB7T2JqZWN0fSBhXG4gKi9cbmV4cG9ydHMuc2VsZWN0aXZlTm90RGVlcEV4dGVuZCA9IGZ1bmN0aW9uIChwcm9wc1RvRXhjbHVkZSwgYSwgYikge1xuICB2YXIgYWxsb3dEZWxldGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG5cbiAgLy8gVE9ETzogYWRkIHN1cHBvcnQgZm9yIEFycmF5cyB0byBkZWVwRXh0ZW5kXG4gIC8vIE5PVEU6IGFycmF5IHByb3BlcnRpZXMgaGF2ZSBhbiBlbHNlLWJlbG93OyBhcHBhcmVudGx5LCB0aGVyZSBpcyBhIHByb2JsZW0gaGVyZS5cbiAgaWYgKEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgZGVlcEV4dGVuZCcpO1xuICB9XG5cbiAgZm9yICh2YXIgcHJvcCBpbiBiKSB7XG4gICAgaWYgKCFiLmhhc093blByb3BlcnR5KHByb3ApKSBjb250aW51ZTsgLy8gSGFuZGxlIGxvY2FsIHByb3BlcnRpZXMgb25seVxuICAgIGlmIChwcm9wc1RvRXhjbHVkZS5pbmRleE9mKHByb3ApICE9PSAtMSkgY29udGludWU7IC8vIEluIGV4Y2x1c2lvbiBsaXN0LCBza2lwXG5cbiAgICBpZiAoYltwcm9wXSAmJiBiW3Byb3BdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgIGlmIChhW3Byb3BdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYVtwcm9wXSA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKGFbcHJvcF0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICBleHBvcnRzLmRlZXBFeHRlbmQoYVtwcm9wXSwgYltwcm9wXSk7IC8vIE5PVEU6IGFsbG93RGVsZXRpb24gbm90IHByb3BhZ2F0ZWQhXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb3B5T3JEZWxldGUoYSwgYiwgcHJvcCwgYWxsb3dEZWxldGlvbik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGJbcHJvcF0pKSB7XG4gICAgICBhW3Byb3BdID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJbcHJvcF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYVtwcm9wXS5wdXNoKGJbcHJvcF1baV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb3B5T3JEZWxldGUoYSwgYiwgcHJvcCwgYWxsb3dEZWxldGlvbik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGE7XG59O1xuXG4vKipcbiAqIERlZXAgZXh0ZW5kIGFuIG9iamVjdCBhIHdpdGggdGhlIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYVxuICogQHBhcmFtIHtPYmplY3R9IGJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3RvRXh0ZW5kPWZhbHNlXSAgSWYgdHJ1ZSwgdGhlIHByb3RvdHlwZSB2YWx1ZXMgd2lsbCBhbHNvIGJlIGV4dGVuZGVkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIChpZS4gdGhlIG9wdGlvbnMgb2JqZWN0cyB0aGF0IGluaGVyaXQgZnJvbSBvdGhlcnMgd2lsbCBhbHNvIGdldCB0aGUgaW5oZXJpdGVkIG9wdGlvbnMpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthbGxvd0RlbGV0aW9uPWZhbHNlXSBJZiB0cnVlLCB0aGUgdmFsdWVzIG9mIGZpZWxkcyB0aGF0IGFyZSBudWxsIHdpbGwgYmUgZGVsZXRlZFxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZXhwb3J0cy5kZWVwRXh0ZW5kID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgdmFyIHByb3RvRXh0ZW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgdmFyIGFsbG93RGVsZXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuXG4gIGZvciAodmFyIHByb3AgaW4gYikge1xuICAgIGlmIChiLmhhc093blByb3BlcnR5KHByb3ApIHx8IHByb3RvRXh0ZW5kID09PSB0cnVlKSB7XG4gICAgICBpZiAoYltwcm9wXSAmJiBiW3Byb3BdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgaWYgKGFbcHJvcF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGFbcHJvcF0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYVtwcm9wXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgICAgZXhwb3J0cy5kZWVwRXh0ZW5kKGFbcHJvcF0sIGJbcHJvcF0sIHByb3RvRXh0ZW5kKTsgLy8gTk9URTogYWxsb3dEZWxldGlvbiBub3QgcHJvcGFnYXRlZCFcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb3B5T3JEZWxldGUoYSwgYiwgcHJvcCwgYWxsb3dEZWxldGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShiW3Byb3BdKSkge1xuICAgICAgICBhW3Byb3BdID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYltwcm9wXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFbcHJvcF0ucHVzaChiW3Byb3BdW2ldKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29weU9yRGVsZXRlKGEsIGIsIHByb3AsIGFsbG93RGVsZXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYTtcbn07XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIGFsbCBlbGVtZW50cyBpbiB0d28gYXJyYXlzIGFyZSBlcXVhbC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFcbiAqIEBwYXJhbSB7QXJyYXl9IGJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBib3RoIGFycmF5cyBoYXZlIHRoZSBzYW1lIGxlbmd0aCBhbmQgc2FtZVxuICogICAgICAgICAgICAgICAgICAgZWxlbWVudHMuXG4gKi9cbmV4cG9ydHMuZXF1YWxBcnJheSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGFbaV0gIT0gYltpXSkgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYW4gb2JqZWN0IHRvIGFub3RoZXIgdHlwZVxuICogQHBhcmFtIHtib29sZWFuIHwgbnVtYmVyIHwgc3RyaW5nIHwgRGF0ZSB8IE1vbWVudCB8IE51bGwgfCB1bmRlZmluZWR9IG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IHR5cGUgICBOYW1lIG9mIHRoZSB0eXBlLiBBdmFpbGFibGUgdHlwZXM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdCb29sZWFuJywgJ051bWJlcicsICdTdHJpbmcnLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnRGF0ZScsICdNb21lbnQnLCBJU09EYXRlJywgJ0FTUERhdGUnLlxuICogQHJldHVybiB7Kn0gb2JqZWN0XG4gKiBAdGhyb3dzIEVycm9yXG4gKi9cbmV4cG9ydHMuY29udmVydCA9IGZ1bmN0aW9uIChvYmplY3QsIHR5cGUpIHtcbiAgdmFyIG1hdGNoO1xuXG4gIGlmIChvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKG9iamVjdCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKCF0eXBlKSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuICBpZiAoISh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpICYmICEodHlwZSBpbnN0YW5jZW9mIFN0cmluZykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1R5cGUgbXVzdCBiZSBhIHN0cmluZycpO1xuICB9XG5cbiAgLy9ub2luc3BlY3Rpb24gRmFsbHRocm91Z2hJblN3aXRjaFN0YXRlbWVudEpTXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgIGNhc2UgJ0Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIEJvb2xlYW4ob2JqZWN0KTtcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgIGlmIChleHBvcnRzLmlzU3RyaW5nKG9iamVjdCkgJiYgIWlzTmFOKERhdGUucGFyc2Uob2JqZWN0KSkpIHtcbiAgICAgICAgcmV0dXJuIG1vbWVudChvYmplY3QpLnZhbHVlT2YoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIob2JqZWN0LnZhbHVlT2YoKSk7XG4gICAgICB9XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICBjYXNlICdTdHJpbmcnOlxuICAgICAgcmV0dXJuIFN0cmluZyhvYmplY3QpO1xuXG4gICAgY2FzZSAnRGF0ZSc6XG4gICAgICBpZiAoZXhwb3J0cy5pc051bWJlcihvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShvYmplY3QpO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG9iamVjdC52YWx1ZU9mKCkpO1xuICAgICAgfSBlbHNlIGlmIChtb21lbnQuaXNNb21lbnQob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUob2JqZWN0LnZhbHVlT2YoKSk7XG4gICAgICB9XG4gICAgICBpZiAoZXhwb3J0cy5pc1N0cmluZyhvYmplY3QpKSB7XG4gICAgICAgIG1hdGNoID0gQVNQRGF0ZVJlZ2V4LmV4ZWMob2JqZWN0KTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgLy8gb2JqZWN0IGlzIGFuIEFTUCBkYXRlXG4gICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKE51bWJlcihtYXRjaFsxXSkpOyAvLyBwYXJzZSBudW1iZXJcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbW9tZW50KG5ldyBEYXRlKG9iamVjdCkpLnRvRGF0ZSgpOyAvLyBwYXJzZSBzdHJpbmdcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29udmVydCBvYmplY3Qgb2YgdHlwZSAnICsgZXhwb3J0cy5nZXRUeXBlKG9iamVjdCkgKyAnIHRvIHR5cGUgRGF0ZScpO1xuICAgICAgfVxuXG4gICAgY2FzZSAnTW9tZW50JzpcbiAgICAgIGlmIChleHBvcnRzLmlzTnVtYmVyKG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG1vbWVudChvYmplY3QpO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIG1vbWVudChvYmplY3QudmFsdWVPZigpKTtcbiAgICAgIH0gZWxzZSBpZiAobW9tZW50LmlzTW9tZW50KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG1vbWVudChvYmplY3QpO1xuICAgICAgfVxuICAgICAgaWYgKGV4cG9ydHMuaXNTdHJpbmcob2JqZWN0KSkge1xuICAgICAgICBtYXRjaCA9IEFTUERhdGVSZWdleC5leGVjKG9iamVjdCk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIC8vIG9iamVjdCBpcyBhbiBBU1AgZGF0ZVxuICAgICAgICAgIHJldHVybiBtb21lbnQoTnVtYmVyKG1hdGNoWzFdKSk7IC8vIHBhcnNlIG51bWJlclxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBtb21lbnQob2JqZWN0KTsgLy8gcGFyc2Ugc3RyaW5nXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnZlcnQgb2JqZWN0IG9mIHR5cGUgJyArIGV4cG9ydHMuZ2V0VHlwZShvYmplY3QpICsgJyB0byB0eXBlIERhdGUnKTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ0lTT0RhdGUnOlxuICAgICAgaWYgKGV4cG9ydHMuaXNOdW1iZXIob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUob2JqZWN0KTtcbiAgICAgIH0gZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0LnRvSVNPU3RyaW5nKCk7XG4gICAgICB9IGVsc2UgaWYgKG1vbWVudC5pc01vbWVudChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBvYmplY3QudG9EYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSBpZiAoZXhwb3J0cy5pc1N0cmluZyhvYmplY3QpKSB7XG4gICAgICAgIG1hdGNoID0gQVNQRGF0ZVJlZ2V4LmV4ZWMob2JqZWN0KTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgLy8gb2JqZWN0IGlzIGFuIEFTUCBkYXRlXG4gICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKE51bWJlcihtYXRjaFsxXSkpLnRvSVNPU3RyaW5nKCk7IC8vIHBhcnNlIG51bWJlclxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBtb21lbnQob2JqZWN0KS5mb3JtYXQoKTsgLy8gSVNPIDg2MDFcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29udmVydCBvYmplY3Qgb2YgdHlwZSAnICsgZXhwb3J0cy5nZXRUeXBlKG9iamVjdCkgKyAnIHRvIHR5cGUgSVNPRGF0ZScpO1xuICAgICAgfVxuXG4gICAgY2FzZSAnQVNQRGF0ZSc6XG4gICAgICBpZiAoZXhwb3J0cy5pc051bWJlcihvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiAnL0RhdGUoJyArIG9iamVjdCArICcpLyc7XG4gICAgICB9IGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuICcvRGF0ZSgnICsgb2JqZWN0LnZhbHVlT2YoKSArICcpLyc7XG4gICAgICB9IGVsc2UgaWYgKGV4cG9ydHMuaXNTdHJpbmcob2JqZWN0KSkge1xuICAgICAgICBtYXRjaCA9IEFTUERhdGVSZWdleC5leGVjKG9iamVjdCk7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgLy8gb2JqZWN0IGlzIGFuIEFTUCBkYXRlXG4gICAgICAgICAgdmFsdWUgPSBuZXcgRGF0ZShOdW1iZXIobWF0Y2hbMV0pKS52YWx1ZU9mKCk7IC8vIHBhcnNlIG51bWJlclxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUob2JqZWN0KS52YWx1ZU9mKCk7IC8vIHBhcnNlIHN0cmluZ1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnL0RhdGUoJyArIHZhbHVlICsgJykvJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnZlcnQgb2JqZWN0IG9mIHR5cGUgJyArIGV4cG9ydHMuZ2V0VHlwZShvYmplY3QpICsgJyB0byB0eXBlIEFTUERhdGUnKTtcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdHlwZSBcIicgKyB0eXBlICsgJ1wiJyk7XG4gIH1cbn07XG5cbi8vIHBhcnNlIEFTUC5OZXQgRGF0ZSBwYXR0ZXJuLFxuLy8gZm9yIGV4YW1wbGUgJy9EYXRlKDExOTg5MDg3MTcwNTYpLycgb3IgJy9EYXRlKDExOTg5MDg3MTcwNTYtMDcwMCkvJ1xuLy8gY29kZSBmcm9tIGh0dHA6Ly9tb21lbnRqcy5jb20vXG52YXIgQVNQRGF0ZVJlZ2V4ID0gL15cXC8/RGF0ZVxcKChcXC0/XFxkKykvaTtcblxuLyoqXG4gKiBHZXQgdGhlIHR5cGUgb2YgYW4gb2JqZWN0LCBmb3IgZXhhbXBsZSBleHBvcnRzLmdldFR5cGUoW10pIHJldHVybnMgJ0FycmF5J1xuICogQHBhcmFtIHsqfSBvYmplY3RcbiAqIEByZXR1cm4ge3N0cmluZ30gdHlwZVxuICovXG5leHBvcnRzLmdldFR5cGUgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIG9iamVjdCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6ICgwLCBfdHlwZW9mM1snZGVmYXVsdCddKShvYmplY3QpO1xuXG4gIGlmICh0eXBlID09ICdvYmplY3QnKSB7XG4gICAgaWYgKG9iamVjdCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEJvb2xlYW4pIHtcbiAgICAgIHJldHVybiAnQm9vbGVhbic7XG4gICAgfVxuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBOdW1iZXIpIHtcbiAgICAgIHJldHVybiAnTnVtYmVyJztcbiAgICB9XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgcmV0dXJuICdTdHJpbmcnO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICByZXR1cm4gJ0FycmF5JztcbiAgICB9XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJldHVybiAnRGF0ZSc7XG4gICAgfVxuICAgIHJldHVybiAnT2JqZWN0JztcbiAgfSBlbHNlIGlmICh0eXBlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuICdOdW1iZXInO1xuICB9IGVsc2UgaWYgKHR5cGUgPT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuICdCb29sZWFuJztcbiAgfSBlbHNlIGlmICh0eXBlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuICdTdHJpbmcnO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgfVxuXG4gIHJldHVybiB0eXBlO1xufTtcblxuLyoqXG4gKiBVc2VkIHRvIGV4dGVuZCBhbiBhcnJheSBhbmQgY29weSBpdC4gVGhpcyBpcyB1c2VkIHRvIHByb3BhZ2F0ZSBwYXRocyByZWN1cnNpdmVseS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAqIEBwYXJhbSB7Kn0gbmV3VmFsdWVcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZXhwb3J0cy5jb3B5QW5kRXh0ZW5kQXJyYXkgPSBmdW5jdGlvbiAoYXJyLCBuZXdWYWx1ZSkge1xuICB2YXIgbmV3QXJyID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgbmV3QXJyLnB1c2goYXJyW2ldKTtcbiAgfVxuICBuZXdBcnIucHVzaChuZXdWYWx1ZSk7XG4gIHJldHVybiBuZXdBcnI7XG59O1xuXG4vKipcbiAqIFVzZWQgdG8gZXh0ZW5kIGFuIGFycmF5IGFuZCBjb3B5IGl0LiBUaGlzIGlzIHVzZWQgdG8gcHJvcGFnYXRlIHBhdGhzIHJlY3Vyc2l2ZWx5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICogQHJldHVybnMge0FycmF5fVxuICovXG5leHBvcnRzLmNvcHlBcnJheSA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgdmFyIG5ld0FyciA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIG5ld0Fyci5wdXNoKGFycltpXSk7XG4gIH1cbiAgcmV0dXJuIG5ld0Fycjtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGFic29sdXRlIGxlZnQgdmFsdWUgb2YgYSBET00gZWxlbWVudFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtICAgICAgICBBIGRvbSBlbGVtZW50LCBmb3IgZXhhbXBsZSBhIGRpdlxuICogQHJldHVybiB7bnVtYmVyfSBsZWZ0ICAgICAgICBUaGUgYWJzb2x1dGUgbGVmdCBwb3NpdGlvbiBvZiB0aGlzIGVsZW1lbnRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gdGhlIGJyb3dzZXIgcGFnZS5cbiAqL1xuZXhwb3J0cy5nZXRBYnNvbHV0ZUxlZnQgPSBmdW5jdGlvbiAoZWxlbSkge1xuICByZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xufTtcblxuZXhwb3J0cy5nZXRBYnNvbHV0ZVJpZ2h0ID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgcmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkucmlnaHQ7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBhYnNvbHV0ZSB0b3AgdmFsdWUgb2YgYSBET00gZWxlbWVudFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtICAgICAgICBBIGRvbSBlbGVtZW50LCBmb3IgZXhhbXBsZSBhIGRpdlxuICogQHJldHVybiB7bnVtYmVyfSB0b3AgICAgICAgIFRoZSBhYnNvbHV0ZSB0b3AgcG9zaXRpb24gb2YgdGhpcyBlbGVtZW50XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIHRoZSBicm93c2VyIHBhZ2UuXG4gKi9cbmV4cG9ydHMuZ2V0QWJzb2x1dGVUb3AgPSBmdW5jdGlvbiAoZWxlbSkge1xuICByZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG59O1xuXG4vKipcbiAqIGFkZCBhIGNsYXNzTmFtZSB0byB0aGUgZ2l2ZW4gZWxlbWVudHMgc3R5bGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbVxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZXNcbiAqL1xuZXhwb3J0cy5hZGRDbGFzc05hbWUgPSBmdW5jdGlvbiAoZWxlbSwgY2xhc3NOYW1lcykge1xuICB2YXIgY2xhc3NlcyA9IGVsZW0uY2xhc3NOYW1lLnNwbGl0KCcgJyk7XG4gIHZhciBuZXdDbGFzc2VzID0gY2xhc3NOYW1lcy5zcGxpdCgnICcpO1xuICBjbGFzc2VzID0gY2xhc3Nlcy5jb25jYXQobmV3Q2xhc3Nlcy5maWx0ZXIoZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgIHJldHVybiBjbGFzc2VzLmluZGV4T2YoY2xhc3NOYW1lKSA8IDA7XG4gIH0pKTtcbiAgZWxlbS5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oJyAnKTtcbn07XG5cbi8qKlxuICogYWRkIGEgY2xhc3NOYW1lIHRvIHRoZSBnaXZlbiBlbGVtZW50cyBzdHlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtXG4gKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lc1xuICovXG5leHBvcnRzLnJlbW92ZUNsYXNzTmFtZSA9IGZ1bmN0aW9uIChlbGVtLCBjbGFzc05hbWVzKSB7XG4gIHZhciBjbGFzc2VzID0gZWxlbS5jbGFzc05hbWUuc3BsaXQoJyAnKTtcbiAgdmFyIG9sZENsYXNzZXMgPSBjbGFzc05hbWVzLnNwbGl0KCcgJyk7XG4gIGNsYXNzZXMgPSBjbGFzc2VzLmZpbHRlcihmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgcmV0dXJuIG9sZENsYXNzZXMuaW5kZXhPZihjbGFzc05hbWUpIDwgMDtcbiAgfSk7XG4gIGVsZW0uY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKCcgJyk7XG59O1xuXG4vKipcbiAqIEZvciBlYWNoIG1ldGhvZCBmb3IgYm90aCBhcnJheXMgYW5kIG9iamVjdHMuXG4gKiBJbiBjYXNlIG9mIGFuIGFycmF5LCB0aGUgYnVpbHQtaW4gQXJyYXkuZm9yRWFjaCgpIGlzIGFwcGxpZWQuICgqKk5vLCBpdCdzIG5vdCEqKilcbiAqIEluIGNhc2Ugb2YgYW4gT2JqZWN0LCB0aGUgbWV0aG9kIGxvb3BzIG92ZXIgYWxsIHByb3BlcnRpZXMgb2YgdGhlIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0IHwgQXJyYXl9IG9iamVjdCAgIEFuIE9iamVjdCBvciBBcnJheVxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgICAgICAgQ2FsbGJhY2sgbWV0aG9kLCBjYWxsZWQgZm9yIGVhY2ggaXRlbSBpblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG9iamVjdCBvciBhcnJheSB3aXRoIHRocmVlIHBhcmFtZXRlcnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIG9iamVjdClcbiAqL1xuZXhwb3J0cy5mb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgdmFyIGksIGxlbjtcbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgIC8vIGFycmF5XG4gICAgZm9yIChpID0gMCwgbGVuID0gb2JqZWN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjYWxsYmFjayhvYmplY3RbaV0sIGksIG9iamVjdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIG9iamVjdFxuICAgIGZvciAoaSBpbiBvYmplY3QpIHtcbiAgICAgIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgY2FsbGJhY2sob2JqZWN0W2ldLCBpLCBvYmplY3QpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDb252ZXJ0IGFuIG9iamVjdCBpbnRvIGFuIGFycmF5OiBhbGwgb2JqZWN0cyBwcm9wZXJ0aWVzIGFyZSBwdXQgaW50byB0aGVcbiAqIGFycmF5LiBUaGUgcmVzdWx0aW5nIGFycmF5IGlzIHVub3JkZXJlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm5zIHtBcnJheX0gYXJyYXlcbiAqL1xuZXhwb3J0cy50b0FycmF5ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICB2YXIgYXJyYXkgPSBbXTtcblxuICBmb3IgKHZhciBwcm9wIGluIG9iamVjdCkge1xuICAgIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkocHJvcCkpIGFycmF5LnB1c2gob2JqZWN0W3Byb3BdKTtcbiAgfVxuXG4gIHJldHVybiBhcnJheTtcbn07XG5cbi8qKlxuICogVXBkYXRlIGEgcHJvcGVydHkgaW4gYW4gb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufSBjaGFuZ2VkXG4gKi9cbmV4cG9ydHMudXBkYXRlUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmIChvYmplY3Rba2V5XSAhPT0gdmFsdWUpIHtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBUaHJvdHRsZSB0aGUgZ2l2ZW4gZnVuY3Rpb24gdG8gYmUgb25seSBleGVjdXRlZCBvbmNlIHBlciBhbmltYXRpb24gZnJhbWVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259IFJldHVybnMgdGhlIHRocm90dGxlZCBmdW5jdGlvblxuICovXG5leHBvcnRzLnRocm90dGxlID0gZnVuY3Rpb24gKGZuKSB7XG4gIHZhciBzY2hlZHVsZWQgPSBmYWxzZTtcblxuICByZXR1cm4gZnVuY3Rpb24gdGhyb3R0bGVkKCkge1xuICAgIGlmICghc2NoZWR1bGVkKSB7XG4gICAgICBzY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgIGZuKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIEFkZCBhbmQgZXZlbnQgbGlzdGVuZXIuIFdvcmtzIGZvciBhbGwgYnJvd3NlcnNcbiAqIEBwYXJhbSB7RWxlbWVudH0gICAgIGVsZW1lbnQgICAgQW4gaHRtbCBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gICAgICBhY3Rpb24gICAgIFRoZSBhY3Rpb24sIGZvciBleGFtcGxlIFwiY2xpY2tcIixcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aG91dCB0aGUgcHJlZml4IFwib25cIlxuICogQHBhcmFtIHtmdW5jdGlvbn0gICAgbGlzdGVuZXIgICBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgIFt1c2VDYXB0dXJlXVxuICovXG5leHBvcnRzLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgYWN0aW9uLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xuICBpZiAoZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgaWYgKHVzZUNhcHR1cmUgPT09IHVuZGVmaW5lZCkgdXNlQ2FwdHVyZSA9IGZhbHNlO1xuXG4gICAgaWYgKGFjdGlvbiA9PT0gJ21vdXNld2hlZWwnICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveCcpID49IDApIHtcbiAgICAgIGFjdGlvbiA9ICdET01Nb3VzZVNjcm9sbCc7IC8vIEZvciBGaXJlZm94XG4gICAgfVxuXG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGFjdGlvbiwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xuICB9IGVsc2Uge1xuICAgIGVsZW1lbnQuYXR0YWNoRXZlbnQoJ29uJyArIGFjdGlvbiwgbGlzdGVuZXIpOyAvLyBJRSBicm93c2Vyc1xuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBldmVudCBsaXN0ZW5lciBmcm9tIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudH0gICAgIGVsZW1lbnQgICAgICAgICBBbiBodG1sIGRvbSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gICAgICBhY3Rpb24gICAgICAgICAgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LCBmb3IgZXhhbXBsZSBcIm1vdXNlZG93blwiXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSAgICBsaXN0ZW5lciAgICAgICAgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59ICAgICBbdXNlQ2FwdHVyZV1cbiAqL1xuZXhwb3J0cy5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIGFjdGlvbiwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpIHtcbiAgaWYgKGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgIC8vIG5vbi1JRSBicm93c2Vyc1xuICAgIGlmICh1c2VDYXB0dXJlID09PSB1bmRlZmluZWQpIHVzZUNhcHR1cmUgPSBmYWxzZTtcblxuICAgIGlmIChhY3Rpb24gPT09ICdtb3VzZXdoZWVsJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA+PSAwKSB7XG4gICAgICBhY3Rpb24gPSAnRE9NTW91c2VTY3JvbGwnOyAvLyBGb3IgRmlyZWZveFxuICAgIH1cblxuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihhY3Rpb24sIGxpc3RlbmVyLCB1c2VDYXB0dXJlKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJRSBicm93c2Vyc1xuICAgIGVsZW1lbnQuZGV0YWNoRXZlbnQoJ29uJyArIGFjdGlvbiwgbGlzdGVuZXIpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbmNlbHMgdGhlIGV2ZW50IGlmIGl0IGlzIGNhbmNlbGFibGUsIHdpdGhvdXQgc3RvcHBpbmcgZnVydGhlciBwcm9wYWdhdGlvbiBvZiB0aGUgZXZlbnQuXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICovXG5leHBvcnRzLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIGlmICghZXZlbnQpIGV2ZW50ID0gd2luZG93LmV2ZW50O1xuXG4gIGlmIChldmVudC5wcmV2ZW50RGVmYXVsdCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIG5vbi1JRSBicm93c2Vyc1xuICB9IGVsc2Uge1xuICAgIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7IC8vIElFIGJyb3dzZXJzXG4gIH1cbn07XG5cbi8qKlxuICogR2V0IEhUTUwgZWxlbWVudCB3aGljaCBpcyB0aGUgdGFyZ2V0IG9mIHRoZSBldmVudFxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEByZXR1cm4ge0VsZW1lbnR9IHRhcmdldCBlbGVtZW50XG4gKi9cbmV4cG9ydHMuZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIC8vIGNvZGUgZnJvbSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2pzL2V2ZW50c19wcm9wZXJ0aWVzLmh0bWxcbiAgaWYgKCFldmVudCkge1xuICAgIGV2ZW50ID0gd2luZG93LmV2ZW50O1xuICB9XG5cbiAgdmFyIHRhcmdldDtcblxuICBpZiAoZXZlbnQudGFyZ2V0KSB7XG4gICAgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICB9IGVsc2UgaWYgKGV2ZW50LnNyY0VsZW1lbnQpIHtcbiAgICB0YXJnZXQgPSBldmVudC5zcmNFbGVtZW50O1xuICB9XG5cbiAgaWYgKHRhcmdldC5ub2RlVHlwZSAhPSB1bmRlZmluZWQgJiYgdGFyZ2V0Lm5vZGVUeXBlID09IDMpIHtcbiAgICAvLyBkZWZlYXQgU2FmYXJpIGJ1Z1xuICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgZ2l2ZW4gZWxlbWVudCBjb250YWlucyBnaXZlbiBwYXJlbnQgc29tZXdoZXJlIGluIHRoZSBET00gdHJlZVxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR9IHBhcmVudFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaGFzUGFyZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIHBhcmVudCkge1xuICB2YXIgZSA9IGVsZW1lbnQ7XG5cbiAgd2hpbGUgKGUpIHtcbiAgICBpZiAoZSA9PT0gcGFyZW50KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZSA9IGUucGFyZW50Tm9kZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmV4cG9ydHMub3B0aW9uID0ge307XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIGludG8gYSBib29sZWFuXG4gKiBAcGFyYW0ge0Jvb2xlYW4gfCBmdW5jdGlvbiB8IHVuZGVmaW5lZH0gdmFsdWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RlZmF1bHRWYWx1ZV1cbiAqIEByZXR1cm5zIHtCb29sZWFufSBib29sXG4gKi9cbmV4cG9ydHMub3B0aW9uLmFzQm9vbGVhbiA9IGZ1bmN0aW9uICh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhbHVlID0gdmFsdWUoKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRWYWx1ZSB8fCBudWxsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgaW50byBhIG51bWJlclxuICogQHBhcmFtIHtCb29sZWFuIHwgZnVuY3Rpb24gfCB1bmRlZmluZWR9IHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gW2RlZmF1bHRWYWx1ZV1cbiAqIEByZXR1cm5zIHtudW1iZXJ9IG51bWJlclxuICovXG5leHBvcnRzLm9wdGlvbi5hc051bWJlciA9IGZ1bmN0aW9uICh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhbHVlID0gdmFsdWUoKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIE51bWJlcih2YWx1ZSkgfHwgZGVmYXVsdFZhbHVlIHx8IG51bGw7XG4gIH1cblxuICByZXR1cm4gZGVmYXVsdFZhbHVlIHx8IG51bGw7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSBpbnRvIGEgc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZyB8IGZ1bmN0aW9uIHwgdW5kZWZpbmVkfSB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IFtkZWZhdWx0VmFsdWVdXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJcbiAqL1xuZXhwb3J0cy5vcHRpb24uYXNTdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICB2YWx1ZSA9IHZhbHVlKCk7XG4gIH1cblxuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRWYWx1ZSB8fCBudWxsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgc2l6ZSBvciBsb2NhdGlvbiBpbnRvIGEgc3RyaW5nIHdpdGggcGl4ZWxzIG9yIGEgcGVyY2VudGFnZVxuICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXIgfCBmdW5jdGlvbiB8IHVuZGVmaW5lZH0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZGVmYXVsdFZhbHVlXVxuICogQHJldHVybnMge1N0cmluZ30gc2l6ZVxuICovXG5leHBvcnRzLm9wdGlvbi5hc1NpemUgPSBmdW5jdGlvbiAodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICB2YWx1ZSA9IHZhbHVlKCk7XG4gIH1cblxuICBpZiAoZXhwb3J0cy5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0gZWxzZSBpZiAoZXhwb3J0cy5pc051bWJlcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUgKyAncHgnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBkZWZhdWx0VmFsdWUgfHwgbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgaW50byBhIERPTSBlbGVtZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgZnVuY3Rpb24gfCB1bmRlZmluZWR9IHZhbHVlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBbZGVmYXVsdFZhbHVlXVxuICogQHJldHVybnMge0hUTUxFbGVtZW50IHwgbnVsbH0gZG9tXG4gKi9cbmV4cG9ydHMub3B0aW9uLmFzRWxlbWVudCA9IGZ1bmN0aW9uICh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhbHVlID0gdmFsdWUoKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZSB8fCBkZWZhdWx0VmFsdWUgfHwgbnVsbDtcbn07XG5cbi8qKlxuICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81NjIzODM4L3JnYi10by1oZXgtYW5kLWhleC10by1yZ2JcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaGV4XG4gKiBAcmV0dXJucyB7e3I6ICosIGc6ICosIGI6ICp9fSB8IDI1NSByYW5nZVxuICovXG5leHBvcnRzLmhleFRvUkdCID0gZnVuY3Rpb24gKGhleCkge1xuICAvLyBFeHBhbmQgc2hvcnRoYW5kIGZvcm0gKGUuZy4gXCIwM0ZcIikgdG8gZnVsbCBmb3JtIChlLmcuIFwiMDAzM0ZGXCIpXG4gIHZhciBzaG9ydGhhbmRSZWdleCA9IC9eIz8oW2EtZlxcZF0pKFthLWZcXGRdKShbYS1mXFxkXSkkL2k7XG4gIGhleCA9IGhleC5yZXBsYWNlKHNob3J0aGFuZFJlZ2V4LCBmdW5jdGlvbiAobSwgciwgZywgYikge1xuICAgIHJldHVybiByICsgciArIGcgKyBnICsgYiArIGI7XG4gIH0pO1xuICB2YXIgcmVzdWx0ID0gL14jPyhbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KSQvaS5leGVjKGhleCk7XG4gIHJldHVybiByZXN1bHQgPyB7XG4gICAgcjogcGFyc2VJbnQocmVzdWx0WzFdLCAxNiksXG4gICAgZzogcGFyc2VJbnQocmVzdWx0WzJdLCAxNiksXG4gICAgYjogcGFyc2VJbnQocmVzdWx0WzNdLCAxNilcbiAgfSA6IG51bGw7XG59O1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgY29sb3IgaW4gaGV4IGZvcm1hdCBvciByZ2IoKSBvciByZ2JhKCkgZm9ybWF0IGFuZCBvdmVycmlkZXMgdGhlIG9wYWNpdHkuIFJldHVybnMgcmdiYSgpIHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICogQHBhcmFtIHtudW1iZXJ9IG9wYWNpdHlcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbmV4cG9ydHMub3ZlcnJpZGVPcGFjaXR5ID0gZnVuY3Rpb24gKGNvbG9yLCBvcGFjaXR5KSB7XG4gIHZhciByZ2I7XG4gIGlmIChjb2xvci5pbmRleE9mKCdyZ2JhJykgIT0gLTEpIHtcbiAgICByZXR1cm4gY29sb3I7XG4gIH0gZWxzZSBpZiAoY29sb3IuaW5kZXhPZigncmdiJykgIT0gLTEpIHtcbiAgICByZ2IgPSBjb2xvci5zdWJzdHIoY29sb3IuaW5kZXhPZignKCcpICsgMSkucmVwbGFjZSgnKScsICcnKS5zcGxpdCgnLCcpO1xuICAgIHJldHVybiAncmdiYSgnICsgcmdiWzBdICsgJywnICsgcmdiWzFdICsgJywnICsgcmdiWzJdICsgJywnICsgb3BhY2l0eSArICcpJztcbiAgfSBlbHNlIHtcbiAgICByZ2IgPSBleHBvcnRzLmhleFRvUkdCKGNvbG9yKTtcbiAgICBpZiAocmdiID09IG51bGwpIHtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICdyZ2JhKCcgKyByZ2IuciArICcsJyArIHJnYi5nICsgJywnICsgcmdiLmIgKyAnLCcgKyBvcGFjaXR5ICsgJyknO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHJlZCAgICAgMCAtLSAyNTVcbiAqIEBwYXJhbSB7bnVtYmVyfSBncmVlbiAgIDAgLS0gMjU1XG4gKiBAcGFyYW0ge251bWJlcn0gYmx1ZSAgICAwIC0tIDI1NVxuICogQHJldHVybnMge1N0cmluZ31cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnRzLlJHQlRvSGV4ID0gZnVuY3Rpb24gKHJlZCwgZ3JlZW4sIGJsdWUpIHtcbiAgcmV0dXJuICcjJyArICgoMSA8PCAyNCkgKyAocmVkIDw8IDE2KSArIChncmVlbiA8PCA4KSArIGJsdWUpLnRvU3RyaW5nKDE2KS5zbGljZSgxKTtcbn07XG5cbi8qKlxuICogUGFyc2UgYSBjb2xvciBwcm9wZXJ0eSBpbnRvIGFuIG9iamVjdCB3aXRoIGJvcmRlciwgYmFja2dyb3VuZCwgYW5kXG4gKiBoaWdobGlnaHQgY29sb3JzXG4gKiBAcGFyYW0ge09iamVjdCB8IFN0cmluZ30gY29sb3JcbiAqIEByZXR1cm4ge09iamVjdH0gY29sb3JPYmplY3RcbiAqL1xuZXhwb3J0cy5wYXJzZUNvbG9yID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gIHZhciBjO1xuICBpZiAoZXhwb3J0cy5pc1N0cmluZyhjb2xvcikgPT09IHRydWUpIHtcbiAgICBpZiAoZXhwb3J0cy5pc1ZhbGlkUkdCKGNvbG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgdmFyIHJnYiA9IGNvbG9yLnN1YnN0cig0KS5zdWJzdHIoMCwgY29sb3IubGVuZ3RoIC0gNSkuc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIGNvbG9yID0gZXhwb3J0cy5SR0JUb0hleChyZ2JbMF0sIHJnYlsxXSwgcmdiWzJdKTtcbiAgICB9XG4gICAgaWYgKGV4cG9ydHMuaXNWYWxpZEhleChjb2xvcikgPT09IHRydWUpIHtcbiAgICAgIHZhciBoc3YgPSBleHBvcnRzLmhleFRvSFNWKGNvbG9yKTtcbiAgICAgIHZhciBsaWdodGVyQ29sb3JIU1YgPSB7XG4gICAgICAgIGg6IGhzdi5oLFxuICAgICAgICBzOiBoc3YucyAqIDAuOCxcbiAgICAgICAgdjogTWF0aC5taW4oMSwgaHN2LnYgKiAxLjAyKVxuICAgICAgfTtcbiAgICAgIHZhciBkYXJrZXJDb2xvckhTViA9IHtcbiAgICAgICAgaDogaHN2LmgsXG4gICAgICAgIHM6IE1hdGgubWluKDEsIGhzdi5zICogMS4yNSksXG4gICAgICAgIHY6IGhzdi52ICogMC44XG4gICAgICB9O1xuICAgICAgdmFyIGRhcmtlckNvbG9ySGV4ID0gZXhwb3J0cy5IU1ZUb0hleChkYXJrZXJDb2xvckhTVi5oLCBkYXJrZXJDb2xvckhTVi5zLCBkYXJrZXJDb2xvckhTVi52KTtcbiAgICAgIHZhciBsaWdodGVyQ29sb3JIZXggPSBleHBvcnRzLkhTVlRvSGV4KGxpZ2h0ZXJDb2xvckhTVi5oLCBsaWdodGVyQ29sb3JIU1YucywgbGlnaHRlckNvbG9ySFNWLnYpO1xuICAgICAgYyA9IHtcbiAgICAgICAgYmFja2dyb3VuZDogY29sb3IsXG4gICAgICAgIGJvcmRlcjogZGFya2VyQ29sb3JIZXgsXG4gICAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICAgIGJhY2tncm91bmQ6IGxpZ2h0ZXJDb2xvckhleCxcbiAgICAgICAgICBib3JkZXI6IGRhcmtlckNvbG9ySGV4XG4gICAgICAgIH0sXG4gICAgICAgIGhvdmVyOiB7XG4gICAgICAgICAgYmFja2dyb3VuZDogbGlnaHRlckNvbG9ySGV4LFxuICAgICAgICAgIGJvcmRlcjogZGFya2VyQ29sb3JIZXhcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgYyA9IHtcbiAgICAgICAgYmFja2dyb3VuZDogY29sb3IsXG4gICAgICAgIGJvcmRlcjogY29sb3IsXG4gICAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICAgIGJhY2tncm91bmQ6IGNvbG9yLFxuICAgICAgICAgIGJvcmRlcjogY29sb3JcbiAgICAgICAgfSxcbiAgICAgICAgaG92ZXI6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBjb2xvcixcbiAgICAgICAgICBib3JkZXI6IGNvbG9yXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGMgPSB7fTtcbiAgICBjLmJhY2tncm91bmQgPSBjb2xvci5iYWNrZ3JvdW5kIHx8IHVuZGVmaW5lZDtcbiAgICBjLmJvcmRlciA9IGNvbG9yLmJvcmRlciB8fCB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZXhwb3J0cy5pc1N0cmluZyhjb2xvci5oaWdobGlnaHQpKSB7XG4gICAgICBjLmhpZ2hsaWdodCA9IHtcbiAgICAgICAgYm9yZGVyOiBjb2xvci5oaWdobGlnaHQsXG4gICAgICAgIGJhY2tncm91bmQ6IGNvbG9yLmhpZ2hsaWdodFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgYy5oaWdobGlnaHQgPSB7fTtcbiAgICAgIGMuaGlnaGxpZ2h0LmJhY2tncm91bmQgPSBjb2xvci5oaWdobGlnaHQgJiYgY29sb3IuaGlnaGxpZ2h0LmJhY2tncm91bmQgfHwgdW5kZWZpbmVkO1xuICAgICAgYy5oaWdobGlnaHQuYm9yZGVyID0gY29sb3IuaGlnaGxpZ2h0ICYmIGNvbG9yLmhpZ2hsaWdodC5ib3JkZXIgfHwgdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChleHBvcnRzLmlzU3RyaW5nKGNvbG9yLmhvdmVyKSkge1xuICAgICAgYy5ob3ZlciA9IHtcbiAgICAgICAgYm9yZGVyOiBjb2xvci5ob3ZlcixcbiAgICAgICAgYmFja2dyb3VuZDogY29sb3IuaG92ZXJcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGMuaG92ZXIgPSB7fTtcbiAgICAgIGMuaG92ZXIuYmFja2dyb3VuZCA9IGNvbG9yLmhvdmVyICYmIGNvbG9yLmhvdmVyLmJhY2tncm91bmQgfHwgdW5kZWZpbmVkO1xuICAgICAgYy5ob3Zlci5ib3JkZXIgPSBjb2xvci5ob3ZlciAmJiBjb2xvci5ob3Zlci5ib3JkZXIgfHwgdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjO1xufTtcblxuLyoqXG4gKiBodHRwOi8vd3d3LmphdmFzY3JpcHRlci5uZXQvZmFxL3JnYjJoc3YuaHRtXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHJlZFxuICogQHBhcmFtIHtudW1iZXJ9IGdyZWVuXG4gKiBAcGFyYW0ge251bWJlcn0gYmx1ZVxuICogQHJldHVybnMge3toOiBudW1iZXIsIHM6IG51bWJlciwgdjogbnVtYmVyfX1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnRzLlJHQlRvSFNWID0gZnVuY3Rpb24gKHJlZCwgZ3JlZW4sIGJsdWUpIHtcbiAgcmVkID0gcmVkIC8gMjU1O1xuICBncmVlbiA9IGdyZWVuIC8gMjU1O1xuICBibHVlID0gYmx1ZSAvIDI1NTtcbiAgdmFyIG1pblJHQiA9IE1hdGgubWluKHJlZCwgTWF0aC5taW4oZ3JlZW4sIGJsdWUpKTtcbiAgdmFyIG1heFJHQiA9IE1hdGgubWF4KHJlZCwgTWF0aC5tYXgoZ3JlZW4sIGJsdWUpKTtcblxuICAvLyBCbGFjay1ncmF5LXdoaXRlXG4gIGlmIChtaW5SR0IgPT0gbWF4UkdCKSB7XG4gICAgcmV0dXJuIHsgaDogMCwgczogMCwgdjogbWluUkdCIH07XG4gIH1cblxuICAvLyBDb2xvcnMgb3RoZXIgdGhhbiBibGFjay1ncmF5LXdoaXRlOlxuICB2YXIgZCA9IHJlZCA9PSBtaW5SR0IgPyBncmVlbiAtIGJsdWUgOiBibHVlID09IG1pblJHQiA/IHJlZCAtIGdyZWVuIDogYmx1ZSAtIHJlZDtcbiAgdmFyIGggPSByZWQgPT0gbWluUkdCID8gMyA6IGJsdWUgPT0gbWluUkdCID8gMSA6IDU7XG4gIHZhciBodWUgPSA2MCAqIChoIC0gZCAvIChtYXhSR0IgLSBtaW5SR0IpKSAvIDM2MDtcbiAgdmFyIHNhdHVyYXRpb24gPSAobWF4UkdCIC0gbWluUkdCKSAvIG1heFJHQjtcbiAgdmFyIHZhbHVlID0gbWF4UkdCO1xuICByZXR1cm4geyBoOiBodWUsIHM6IHNhdHVyYXRpb24sIHY6IHZhbHVlIH07XG59O1xuXG52YXIgY3NzVXRpbCA9IHtcbiAgLy8gc3BsaXQgYSBzdHJpbmcgd2l0aCBjc3Mgc3R5bGVzIGludG8gYW4gb2JqZWN0IHdpdGgga2V5L3ZhbHVlc1xuICBzcGxpdDogZnVuY3Rpb24gc3BsaXQoY3NzVGV4dCkge1xuICAgIHZhciBzdHlsZXMgPSB7fTtcblxuICAgIGNzc1RleHQuc3BsaXQoJzsnKS5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgaWYgKHN0eWxlLnRyaW0oKSAhPSAnJykge1xuICAgICAgICB2YXIgcGFydHMgPSBzdHlsZS5zcGxpdCgnOicpO1xuICAgICAgICB2YXIga2V5ID0gcGFydHNbMF0udHJpbSgpO1xuICAgICAgICB2YXIgdmFsdWUgPSBwYXJ0c1sxXS50cmltKCk7XG4gICAgICAgIHN0eWxlc1trZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc3R5bGVzO1xuICB9LFxuXG4gIC8vIGJ1aWxkIGEgY3NzIHRleHQgc3RyaW5nIGZyb20gYW4gb2JqZWN0IHdpdGgga2V5L3ZhbHVlc1xuICBqb2luOiBmdW5jdGlvbiBqb2luKHN0eWxlcykge1xuICAgIHJldHVybiAoMCwgX2tleXMyWydkZWZhdWx0J10pKHN0eWxlcykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBrZXkgKyAnOiAnICsgc3R5bGVzW2tleV07XG4gICAgfSkuam9pbignOyAnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBlbmQgYSBzdHJpbmcgd2l0aCBjc3Mgc3R5bGVzIHRvIGFuIGVsZW1lbnRcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjc3NUZXh0XG4gICAqL1xufTtleHBvcnRzLmFkZENzc1RleHQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY3NzVGV4dCkge1xuICB2YXIgY3VycmVudFN0eWxlcyA9IGNzc1V0aWwuc3BsaXQoZWxlbWVudC5zdHlsZS5jc3NUZXh0KTtcbiAgdmFyIG5ld1N0eWxlcyA9IGNzc1V0aWwuc3BsaXQoY3NzVGV4dCk7XG4gIHZhciBzdHlsZXMgPSBleHBvcnRzLmV4dGVuZChjdXJyZW50U3R5bGVzLCBuZXdTdHlsZXMpO1xuXG4gIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IGNzc1V0aWwuam9pbihzdHlsZXMpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYSBzdHJpbmcgd2l0aCBjc3Mgc3R5bGVzIGZyb20gYW4gZWxlbWVudFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gY3NzVGV4dFxuICovXG5leHBvcnRzLnJlbW92ZUNzc1RleHQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY3NzVGV4dCkge1xuICB2YXIgc3R5bGVzID0gY3NzVXRpbC5zcGxpdChlbGVtZW50LnN0eWxlLmNzc1RleHQpO1xuICB2YXIgcmVtb3ZlU3R5bGVzID0gY3NzVXRpbC5zcGxpdChjc3NUZXh0KTtcblxuICBmb3IgKHZhciBrZXkgaW4gcmVtb3ZlU3R5bGVzKSB7XG4gICAgaWYgKHJlbW92ZVN0eWxlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBkZWxldGUgc3R5bGVzW2tleV07XG4gICAgfVxuICB9XG5cbiAgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gY3NzVXRpbC5qb2luKHN0eWxlcyk7XG59O1xuXG4vKipcbiAqIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL21qaWphY2tzb24vNTMxMTI1NlxuICogQHBhcmFtIHtudW1iZXJ9IGhcbiAqIEBwYXJhbSB7bnVtYmVyfSBzXG4gKiBAcGFyYW0ge251bWJlcn0gdlxuICogQHJldHVybnMge3tyOiBudW1iZXIsIGc6IG51bWJlciwgYjogbnVtYmVyfX1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnRzLkhTVlRvUkdCID0gZnVuY3Rpb24gKGgsIHMsIHYpIHtcbiAgdmFyIHIsIGcsIGI7XG5cbiAgdmFyIGkgPSBNYXRoLmZsb29yKGggKiA2KTtcbiAgdmFyIGYgPSBoICogNiAtIGk7XG4gIHZhciBwID0gdiAqICgxIC0gcyk7XG4gIHZhciBxID0gdiAqICgxIC0gZiAqIHMpO1xuICB2YXIgdCA9IHYgKiAoMSAtICgxIC0gZikgKiBzKTtcblxuICBzd2l0Y2ggKGkgJSA2KSB7XG4gICAgY2FzZSAwOlxuICAgICAgO3IgPSB2LCBnID0gdCwgYiA9IHA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICA7ciA9IHEsIGcgPSB2LCBiID0gcDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjpcbiAgICAgIDtyID0gcCwgZyA9IHYsIGIgPSB0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOlxuICAgICAgO3IgPSBwLCBnID0gcSwgYiA9IHY7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDQ6XG4gICAgICA7ciA9IHQsIGcgPSBwLCBiID0gdjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNTpcbiAgICAgIDtyID0gdiwgZyA9IHAsIGIgPSBxO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHI6IE1hdGguZmxvb3IociAqIDI1NSksXG4gICAgZzogTWF0aC5mbG9vcihnICogMjU1KSxcbiAgICBiOiBNYXRoLmZsb29yKGIgKiAyNTUpXG4gIH07XG59O1xuXG5leHBvcnRzLkhTVlRvSGV4ID0gZnVuY3Rpb24gKGgsIHMsIHYpIHtcbiAgdmFyIHJnYiA9IGV4cG9ydHMuSFNWVG9SR0IoaCwgcywgdik7XG4gIHJldHVybiBleHBvcnRzLlJHQlRvSGV4KHJnYi5yLCByZ2IuZywgcmdiLmIpO1xufTtcblxuZXhwb3J0cy5oZXhUb0hTViA9IGZ1bmN0aW9uIChoZXgpIHtcbiAgdmFyIHJnYiA9IGV4cG9ydHMuaGV4VG9SR0IoaGV4KTtcbiAgcmV0dXJuIGV4cG9ydHMuUkdCVG9IU1YocmdiLnIsIHJnYi5nLCByZ2IuYik7XG59O1xuXG5leHBvcnRzLmlzVmFsaWRIZXggPSBmdW5jdGlvbiAoaGV4KSB7XG4gIHZhciBpc09rID0gLyheI1swLTlBLUZdezZ9JCl8KF4jWzAtOUEtRl17M30kKS9pLnRlc3QoaGV4KTtcbiAgcmV0dXJuIGlzT2s7XG59O1xuXG5leHBvcnRzLmlzVmFsaWRSR0IgPSBmdW5jdGlvbiAocmdiKSB7XG4gIHJnYiA9IHJnYi5yZXBsYWNlKCcgJywgJycpO1xuICB2YXIgaXNPayA9IC9yZ2JcXCgoXFxkezEsM30pLChcXGR7MSwzfSksKFxcZHsxLDN9KVxcKS9pLnRlc3QocmdiKTtcbiAgcmV0dXJuIGlzT2s7XG59O1xuZXhwb3J0cy5pc1ZhbGlkUkdCQSA9IGZ1bmN0aW9uIChyZ2JhKSB7XG4gIHJnYmEgPSByZ2JhLnJlcGxhY2UoJyAnLCAnJyk7XG4gIHZhciBpc09rID0gL3JnYmFcXCgoXFxkezEsM30pLChcXGR7MSwzfSksKFxcZHsxLDN9KSwoLnsxLDN9KVxcKS9pLnRlc3QocmdiYSk7XG4gIHJldHVybiBpc09rO1xufTtcblxuLyoqXG4gKiBUaGlzIHJlY3Vyc2l2ZWx5IHJlZGlyZWN0cyB0aGUgcHJvdG90eXBlIG9mIEpTT04gb2JqZWN0cyB0byB0aGUgcmVmZXJlbmNlT2JqZWN0XG4gKiBUaGlzIGlzIHVzZWQgZm9yIGRlZmF1bHQgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBmaWVsZHNcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWZlcmVuY2VPYmplY3RcbiAqIEByZXR1cm5zIHsqfVxuICovXG5leHBvcnRzLnNlbGVjdGl2ZUJyaWRnZU9iamVjdCA9IGZ1bmN0aW9uIChmaWVsZHMsIHJlZmVyZW5jZU9iamVjdCkge1xuICBpZiAocmVmZXJlbmNlT2JqZWN0ICE9PSBudWxsICYmICh0eXBlb2YgcmVmZXJlbmNlT2JqZWN0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogKDAsIF90eXBlb2YzWydkZWZhdWx0J10pKHJlZmVyZW5jZU9iamVjdCkpID09PSAnb2JqZWN0Jykge1xuICAgIC8vICEhISB0eXBlb2YgbnVsbCA9PT0gJ29iamVjdCdcbiAgICB2YXIgb2JqZWN0VG8gPSAoMCwgX2NyZWF0ZTJbJ2RlZmF1bHQnXSkocmVmZXJlbmNlT2JqZWN0KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlZmVyZW5jZU9iamVjdC5oYXNPd25Qcm9wZXJ0eShmaWVsZHNbaV0pKSB7XG4gICAgICAgIGlmICgoMCwgX3R5cGVvZjNbJ2RlZmF1bHQnXSkocmVmZXJlbmNlT2JqZWN0W2ZpZWxkc1tpXV0pID09ICdvYmplY3QnKSB7XG4gICAgICAgICAgb2JqZWN0VG9bZmllbGRzW2ldXSA9IGV4cG9ydHMuYnJpZGdlT2JqZWN0KHJlZmVyZW5jZU9iamVjdFtmaWVsZHNbaV1dKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0VG87XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogVGhpcyByZWN1cnNpdmVseSByZWRpcmVjdHMgdGhlIHByb3RvdHlwZSBvZiBKU09OIG9iamVjdHMgdG8gdGhlIHJlZmVyZW5jZU9iamVjdFxuICogVGhpcyBpcyB1c2VkIGZvciBkZWZhdWx0IG9wdGlvbnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHJlZmVyZW5jZU9iamVjdFxuICogQHJldHVybnMgeyp9XG4gKi9cbmV4cG9ydHMuYnJpZGdlT2JqZWN0ID0gZnVuY3Rpb24gKHJlZmVyZW5jZU9iamVjdCkge1xuICBpZiAocmVmZXJlbmNlT2JqZWN0ICE9PSBudWxsICYmICh0eXBlb2YgcmVmZXJlbmNlT2JqZWN0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogKDAsIF90eXBlb2YzWydkZWZhdWx0J10pKHJlZmVyZW5jZU9iamVjdCkpID09PSAnb2JqZWN0Jykge1xuICAgIC8vICEhISB0eXBlb2YgbnVsbCA9PT0gJ29iamVjdCdcbiAgICB2YXIgb2JqZWN0VG8gPSAoMCwgX2NyZWF0ZTJbJ2RlZmF1bHQnXSkocmVmZXJlbmNlT2JqZWN0KTtcbiAgICBpZiAocmVmZXJlbmNlT2JqZWN0IGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgLy8gQXZvaWQgYnJpZGdpbmcgRE9NIG9iamVjdHNcbiAgICAgIG9iamVjdFRvID0gcmVmZXJlbmNlT2JqZWN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmplY3RUbyA9ICgwLCBfY3JlYXRlMlsnZGVmYXVsdCddKShyZWZlcmVuY2VPYmplY3QpO1xuICAgICAgZm9yICh2YXIgaSBpbiByZWZlcmVuY2VPYmplY3QpIHtcbiAgICAgICAgaWYgKHJlZmVyZW5jZU9iamVjdC5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgIGlmICgoMCwgX3R5cGVvZjNbJ2RlZmF1bHQnXSkocmVmZXJlbmNlT2JqZWN0W2ldKSA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgb2JqZWN0VG9baV0gPSBleHBvcnRzLmJyaWRnZU9iamVjdChyZWZlcmVuY2VPYmplY3RbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0VG87XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcHJvdmlkZXMgYSBzdGFibGUgc29ydCBpbXBsZW1lbnRhdGlvbiwgdmVyeSBmYXN0IGZvciBwcmVzb3J0ZWQgZGF0YVxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wYXJlIGFuIG9yZGVyIGNvbXBhcmF0b3JcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZXhwb3J0cy5pbnNlcnRTb3J0ID0gZnVuY3Rpb24gKGEsIGNvbXBhcmUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGsgPSBhW2ldO1xuICAgIGZvciAodmFyIGogPSBpOyBqID4gMCAmJiBjb21wYXJlKGssIGFbaiAtIDFdKSA8IDA7IGotLSkge1xuICAgICAgYVtqXSA9IGFbaiAtIDFdO1xuICAgIH1cbiAgICBhW2pdID0gaztcbiAgfVxuICByZXR1cm4gYTtcbn07XG5cbi8qKlxuICogVGhpcyBpcyB1c2VkIHRvIHNldCB0aGUgb3B0aW9ucyBvZiBzdWJvYmplY3RzIGluIHRoZSBvcHRpb25zIG9iamVjdC5cbiAqXG4gKiBBIHJlcXVpcmVtZW50IG9mIHRoZXNlIHN1Ym9iamVjdHMgaXMgdGhhdCB0aGV5IGhhdmUgYW4gJ2VuYWJsZWQnIGVsZW1lbnRcbiAqIHdoaWNoIGlzIG9wdGlvbmFsIGZvciB0aGUgdXNlciBidXQgbWFuZGF0b3J5IGZvciB0aGUgcHJvZ3JhbS5cbiAqXG4gKiBUaGUgYWRkZWQgdmFsdWUgaGVyZSBvZiB0aGUgbWVyZ2UgaXMgdGhhdCBvcHRpb24gJ2VuYWJsZWQnIGlzIHNldCBhcyByZXF1aXJlZC5cbiAqXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG1lcmdlVGFyZ2V0ICAgfCBlaXRoZXIgdGhpcy5vcHRpb25zIG9yIHRoZSBvcHRpb25zIHVzZWQgZm9yIHRoZSBncm91cHMuXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAgICAgICB8IG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb24gICAgICAgIHwgb3B0aW9uIGtleSBpbiB0aGUgb3B0aW9ucyBhcmd1bWVudFxuICogQHBhcmFtIHtvYmplY3R9IGdsb2JhbE9wdGlvbnMgfCBnbG9iYWwgb3B0aW9ucywgcGFzc2VkIGluIHRvIGRldGVybWluZSB2YWx1ZSBvZiBvcHRpb24gJ2VuYWJsZWQnXG4gKi9cbmV4cG9ydHMubWVyZ2VPcHRpb25zID0gZnVuY3Rpb24gKG1lcmdlVGFyZ2V0LCBvcHRpb25zLCBvcHRpb24pIHtcbiAgdmFyIGdsb2JhbE9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuXG4gIC8vIExvY2FsIGhlbHBlcnNcbiAgdmFyIGlzUHJlc2VudCA9IGZ1bmN0aW9uIGlzUHJlc2VudChvYmopIHtcbiAgICByZXR1cm4gb2JqICE9PSBudWxsICYmIG9iaiAhPT0gdW5kZWZpbmVkO1xuICB9O1xuXG4gIHZhciBpc09iamVjdCA9IGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICAgIHJldHVybiBvYmogIT09IG51bGwgJiYgKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiAoMCwgX3R5cGVvZjNbJ2RlZmF1bHQnXSkob2JqKSkgPT09ICdvYmplY3QnO1xuICB9O1xuXG4gIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zNDQ5MTI4Ny8xMjIzNTMxXG4gIHZhciBpc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eShvYmopIHtcbiAgICBmb3IgKHZhciB4IGluIG9iaikge1xuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eSh4KSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBHdWFyZHNcbiAgaWYgKCFpc09iamVjdChtZXJnZVRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcmFtZXRlciBtZXJnZVRhcmdldCBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICB9XG5cbiAgaWYgKCFpc09iamVjdChvcHRpb25zKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGFyYW1ldGVyIG9wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgfVxuXG4gIGlmICghaXNQcmVzZW50KG9wdGlvbikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcmFtZXRlciBvcHRpb24gbXVzdCBoYXZlIGEgdmFsdWUnKTtcbiAgfVxuXG4gIGlmICghaXNPYmplY3QoZ2xvYmFsT3B0aW9ucykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcmFtZXRlciBnbG9iYWxPcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gIH1cblxuICAvL1xuICAvLyBBY3R1YWwgbWVyZ2Ugcm91dGluZSwgc2VwYXJhdGVkIGZyb20gbWFpbiBsb2dpY1xuICAvLyBPbmx5IGEgc2luZ2xlIGxldmVsIG9mIG9wdGlvbnMgaXMgbWVyZ2VkLiBEZWVwZXIgbGV2ZWxzIGFyZSByZWYnZC4gVGhpcyBtYXkgYWN0dWFsbHkgYmUgYW4gaXNzdWUuXG4gIC8vXG4gIHZhciBkb01lcmdlID0gZnVuY3Rpb24gZG9NZXJnZSh0YXJnZXQsIG9wdGlvbnMsIG9wdGlvbikge1xuICAgIGlmICghaXNPYmplY3QodGFyZ2V0W29wdGlvbl0pKSB7XG4gICAgICB0YXJnZXRbb3B0aW9uXSA9IHt9O1xuICAgIH1cblxuICAgIHZhciBzcmMgPSBvcHRpb25zW29wdGlvbl07XG4gICAgdmFyIGRzdCA9IHRhcmdldFtvcHRpb25dO1xuICAgIGZvciAodmFyIHByb3AgaW4gc3JjKSB7XG4gICAgICBpZiAoc3JjLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgIGRzdFtwcm9wXSA9IHNyY1twcm9wXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gTG9jYWwgaW5pdGlhbGl6YXRpb25cbiAgdmFyIHNyY09wdGlvbiA9IG9wdGlvbnNbb3B0aW9uXTtcbiAgdmFyIGdsb2JhbFBhc3NlZCA9IGlzT2JqZWN0KGdsb2JhbE9wdGlvbnMpICYmICFpc0VtcHR5KGdsb2JhbE9wdGlvbnMpO1xuICB2YXIgZ2xvYmFsT3B0aW9uID0gZ2xvYmFsUGFzc2VkID8gZ2xvYmFsT3B0aW9uc1tvcHRpb25dIDogdW5kZWZpbmVkO1xuICB2YXIgZ2xvYmFsRW5hYmxlZCA9IGdsb2JhbE9wdGlvbiA/IGdsb2JhbE9wdGlvbi5lbmFibGVkIDogdW5kZWZpbmVkO1xuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIE1haW4gcm91dGluZVxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICBpZiAoc3JjT3B0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm47IC8vIE5vdGhpbmcgdG8gZG9cbiAgfVxuXG4gIGlmICh0eXBlb2Ygc3JjT3B0aW9uID09PSAnYm9vbGVhbicpIHtcbiAgICBpZiAoIWlzT2JqZWN0KG1lcmdlVGFyZ2V0W29wdGlvbl0pKSB7XG4gICAgICBtZXJnZVRhcmdldFtvcHRpb25dID0ge307XG4gICAgfVxuXG4gICAgbWVyZ2VUYXJnZXRbb3B0aW9uXS5lbmFibGVkID0gc3JjT3B0aW9uO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChzcmNPcHRpb24gPT09IG51bGwgJiYgIWlzT2JqZWN0KG1lcmdlVGFyZ2V0W29wdGlvbl0pKSB7XG4gICAgLy8gSWYgcG9zc2libGUsIGV4cGxpY2l0IGNvcHkgZnJvbSBnbG9iYWxzXG4gICAgaWYgKGlzUHJlc2VudChnbG9iYWxPcHRpb24pKSB7XG4gICAgICBtZXJnZVRhcmdldFtvcHRpb25dID0gKDAsIF9jcmVhdGUyWydkZWZhdWx0J10pKGdsb2JhbE9wdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjsgLy8gTm90aGluZyB0byBkb1xuICAgIH1cbiAgfVxuXG4gIGlmICghaXNPYmplY3Qoc3JjT3B0aW9uKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vXG4gIC8vIEVuc3VyZSB0aGF0ICdlbmFibGVkJyBpcyBwcm9wZXJseSBzZXQuIEl0IGlzIHJlcXVpcmVkIGludGVybmFsbHlcbiAgLy8gTm90ZSB0aGF0IHRoZSB2YWx1ZSBmcm9tIG9wdGlvbnMgd2lsbCBhbHdheXMgb3ZlcndyaXRlIHRoZSBleGlzdGluZyB2YWx1ZVxuICAvL1xuICB2YXIgZW5hYmxlZCA9IHRydWU7IC8vIGRlZmF1bHQgdmFsdWVcblxuICBpZiAoc3JjT3B0aW9uLmVuYWJsZWQgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuYWJsZWQgPSBzcmNPcHRpb24uZW5hYmxlZDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUYWtlIGZyb20gZ2xvYmFscywgaWYgcHJlc2VudFxuICAgIGlmIChnbG9iYWxFbmFibGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGVuYWJsZWQgPSBnbG9iYWxPcHRpb24uZW5hYmxlZDtcbiAgICB9XG4gIH1cblxuICBkb01lcmdlKG1lcmdlVGFyZ2V0LCBvcHRpb25zLCBvcHRpb24pO1xuICBtZXJnZVRhcmdldFtvcHRpb25dLmVuYWJsZWQgPSBlbmFibGVkO1xufTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgYSBiaW5hcnkgc2VhcmNoIGZvciBhIHZpc2libGUgaXRlbSBpbiBhIHNvcnRlZCBsaXN0LiBJZiB3ZSBmaW5kIGEgdmlzaWJsZSBpdGVtLCB0aGUgY29kZSB0aGF0IHVzZXNcbiAqIHRoaXMgZnVuY3Rpb24gd2lsbCB0aGVuIGl0ZXJhdGUgaW4gYm90aCBkaXJlY3Rpb25zIG92ZXIgdGhpcyBzb3J0ZWQgbGlzdCB0byBmaW5kIGFsbCB2aXNpYmxlIGl0ZW1zLlxuICpcbiAqIEBwYXJhbSB7SXRlbVtdfSBvcmRlcmVkSXRlbXMgICAgICAgfCBJdGVtcyBvcmRlcmVkIGJ5IHN0YXJ0XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wYXJhdG9yICAgICAgIHwgLTEgaXMgbG93ZXIsIDAgaXMgZXF1YWwsIDEgaXMgaGlnaGVyXG4gKiBAcGFyYW0ge3N0cmluZ30gZmllbGRcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZDJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmJpbmFyeVNlYXJjaEN1c3RvbSA9IGZ1bmN0aW9uIChvcmRlcmVkSXRlbXMsIGNvbXBhcmF0b3IsIGZpZWxkLCBmaWVsZDIpIHtcbiAgdmFyIG1heEl0ZXJhdGlvbnMgPSAxMDAwMDtcbiAgdmFyIGl0ZXJhdGlvbiA9IDA7XG4gIHZhciBsb3cgPSAwO1xuICB2YXIgaGlnaCA9IG9yZGVyZWRJdGVtcy5sZW5ndGggLSAxO1xuXG4gIHdoaWxlIChsb3cgPD0gaGlnaCAmJiBpdGVyYXRpb24gPCBtYXhJdGVyYXRpb25zKSB7XG4gICAgdmFyIG1pZGRsZSA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG5cbiAgICB2YXIgaXRlbSA9IG9yZGVyZWRJdGVtc1ttaWRkbGVdO1xuICAgIHZhciB2YWx1ZSA9IGZpZWxkMiA9PT0gdW5kZWZpbmVkID8gaXRlbVtmaWVsZF0gOiBpdGVtW2ZpZWxkXVtmaWVsZDJdO1xuXG4gICAgdmFyIHNlYXJjaFJlc3VsdCA9IGNvbXBhcmF0b3IodmFsdWUpO1xuICAgIGlmIChzZWFyY2hSZXN1bHQgPT0gMCkge1xuICAgICAgLy8gamloYWEsIGZvdW5kIGEgdmlzaWJsZSBpdGVtIVxuICAgICAgcmV0dXJuIG1pZGRsZTtcbiAgICB9IGVsc2UgaWYgKHNlYXJjaFJlc3VsdCA9PSAtMSkge1xuICAgICAgLy8gaXQgaXMgdG9vIHNtYWxsIC0tPiBpbmNyZWFzZSBsb3dcbiAgICAgIGxvdyA9IG1pZGRsZSArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGl0IGlzIHRvbyBiaWcgLS0+IGRlY3JlYXNlIGhpZ2hcbiAgICAgIGhpZ2ggPSBtaWRkbGUgLSAxO1xuICAgIH1cblxuICAgIGl0ZXJhdGlvbisrO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgYSBiaW5hcnkgc2VhcmNoIGZvciBhIHNwZWNpZmljIHZhbHVlIGluIGEgc29ydGVkIGFycmF5LiBJZiBpdCBkb2VzIG5vdCBleGlzdCBidXQgaXMgaW4gYmV0d2VlbiBvZlxuICogdHdvIHZhbHVlcywgd2UgcmV0dXJuIGVpdGhlciB0aGUgb25lIGJlZm9yZSBvciB0aGUgb25lIGFmdGVyLCBkZXBlbmRpbmcgb24gdXNlciBpbnB1dFxuICogSWYgaXQgaXMgZm91bmQsIHdlIHJldHVybiB0aGUgaW5kZXgsIGVsc2UgLTEuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gb3JkZXJlZEl0ZW1zXG4gKiBAcGFyYW0ge3tzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcn19IHRhcmdldFxuICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkXG4gKiBAcGFyYW0ge3N0cmluZ30gc2lkZVByZWZlcmVuY2UgICAnYmVmb3JlJyBvciAnYWZ0ZXInXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wYXJhdG9yIGFuIG9wdGlvbmFsIGNvbXBhcmF0b3IsIHJldHVybmluZyAtMSwwLDEgZm9yIDwsPT0sPi5cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmJpbmFyeVNlYXJjaFZhbHVlID0gZnVuY3Rpb24gKG9yZGVyZWRJdGVtcywgdGFyZ2V0LCBmaWVsZCwgc2lkZVByZWZlcmVuY2UsIGNvbXBhcmF0b3IpIHtcbiAgdmFyIG1heEl0ZXJhdGlvbnMgPSAxMDAwMDtcbiAgdmFyIGl0ZXJhdGlvbiA9IDA7XG4gIHZhciBsb3cgPSAwO1xuICB2YXIgaGlnaCA9IG9yZGVyZWRJdGVtcy5sZW5ndGggLSAxO1xuICB2YXIgcHJldlZhbHVlLCB2YWx1ZSwgbmV4dFZhbHVlLCBtaWRkbGU7XG5cbiAgY29tcGFyYXRvciA9IGNvbXBhcmF0b3IgIT0gdW5kZWZpbmVkID8gY29tcGFyYXRvciA6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEgPT0gYiA/IDAgOiBhIDwgYiA/IC0xIDogMTtcbiAgfTtcblxuICB3aGlsZSAobG93IDw9IGhpZ2ggJiYgaXRlcmF0aW9uIDwgbWF4SXRlcmF0aW9ucykge1xuICAgIC8vIGdldCBhIG5ldyBndWVzc1xuICAgIG1pZGRsZSA9IE1hdGguZmxvb3IoMC41ICogKGhpZ2ggKyBsb3cpKTtcbiAgICBwcmV2VmFsdWUgPSBvcmRlcmVkSXRlbXNbTWF0aC5tYXgoMCwgbWlkZGxlIC0gMSldW2ZpZWxkXTtcbiAgICB2YWx1ZSA9IG9yZGVyZWRJdGVtc1ttaWRkbGVdW2ZpZWxkXTtcbiAgICBuZXh0VmFsdWUgPSBvcmRlcmVkSXRlbXNbTWF0aC5taW4ob3JkZXJlZEl0ZW1zLmxlbmd0aCAtIDEsIG1pZGRsZSArIDEpXVtmaWVsZF07XG5cbiAgICBpZiAoY29tcGFyYXRvcih2YWx1ZSwgdGFyZ2V0KSA9PSAwKSB7XG4gICAgICAvLyB3ZSBmb3VuZCB0aGUgdGFyZ2V0XG4gICAgICByZXR1cm4gbWlkZGxlO1xuICAgIH0gZWxzZSBpZiAoY29tcGFyYXRvcihwcmV2VmFsdWUsIHRhcmdldCkgPCAwICYmIGNvbXBhcmF0b3IodmFsdWUsIHRhcmdldCkgPiAwKSB7XG4gICAgICAvLyB0YXJnZXQgaXMgaW4gYmV0d2VlbiBvZiB0aGUgcHJldmlvdXMgYW5kIHRoZSBjdXJyZW50XG4gICAgICByZXR1cm4gc2lkZVByZWZlcmVuY2UgPT0gJ2JlZm9yZScgPyBNYXRoLm1heCgwLCBtaWRkbGUgLSAxKSA6IG1pZGRsZTtcbiAgICB9IGVsc2UgaWYgKGNvbXBhcmF0b3IodmFsdWUsIHRhcmdldCkgPCAwICYmIGNvbXBhcmF0b3IobmV4dFZhbHVlLCB0YXJnZXQpID4gMCkge1xuICAgICAgLy8gdGFyZ2V0IGlzIGluIGJldHdlZW4gb2YgdGhlIGN1cnJlbnQgYW5kIHRoZSBuZXh0XG4gICAgICByZXR1cm4gc2lkZVByZWZlcmVuY2UgPT0gJ2JlZm9yZScgPyBtaWRkbGUgOiBNYXRoLm1pbihvcmRlcmVkSXRlbXMubGVuZ3RoIC0gMSwgbWlkZGxlICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGRpZG50IGZpbmQgdGhlIHRhcmdldCwgd2UgbmVlZCB0byBjaGFuZ2Ugb3VyIGJvdW5kYXJpZXMuXG4gICAgICBpZiAoY29tcGFyYXRvcih2YWx1ZSwgdGFyZ2V0KSA8IDApIHtcbiAgICAgICAgLy8gaXQgaXMgdG9vIHNtYWxsIC0tPiBpbmNyZWFzZSBsb3dcbiAgICAgICAgbG93ID0gbWlkZGxlICsgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGl0IGlzIHRvbyBiaWcgLS0+IGRlY3JlYXNlIGhpZ2hcbiAgICAgICAgaGlnaCA9IG1pZGRsZSAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIGl0ZXJhdGlvbisrO1xuICB9XG5cbiAgLy8gZGlkbnQgZmluZCBhbnl0aGluZy4gUmV0dXJuIC0xLlxuICByZXR1cm4gLTE7XG59O1xuXG4vKlxuICogRWFzaW5nIEZ1bmN0aW9ucyAtIGluc3BpcmVkIGZyb20gaHR0cDovL2dpem1hLmNvbS9lYXNpbmcvXG4gKiBvbmx5IGNvbnNpZGVyaW5nIHRoZSB0IHZhbHVlIGZvciB0aGUgcmFuZ2UgWzAsIDFdID0+IFswLCAxXVxuICogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZ3JlLzE2NTAyOTRcbiAqL1xuZXhwb3J0cy5lYXNpbmdGdW5jdGlvbnMgPSB7XG4gIC8vIG5vIGVhc2luZywgbm8gYWNjZWxlcmF0aW9uXG4gIGxpbmVhcjogZnVuY3Rpb24gbGluZWFyKHQpIHtcbiAgICByZXR1cm4gdDtcbiAgfSxcbiAgLy8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxuICBlYXNlSW5RdWFkOiBmdW5jdGlvbiBlYXNlSW5RdWFkKHQpIHtcbiAgICByZXR1cm4gdCAqIHQ7XG4gIH0sXG4gIC8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG4gIGVhc2VPdXRRdWFkOiBmdW5jdGlvbiBlYXNlT3V0UXVhZCh0KSB7XG4gICAgcmV0dXJuIHQgKiAoMiAtIHQpO1xuICB9LFxuICAvLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cbiAgZWFzZUluT3V0UXVhZDogZnVuY3Rpb24gZWFzZUluT3V0UXVhZCh0KSB7XG4gICAgcmV0dXJuIHQgPCAwLjUgPyAyICogdCAqIHQgOiAtMSArICg0IC0gMiAqIHQpICogdDtcbiAgfSxcbiAgLy8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxuICBlYXNlSW5DdWJpYzogZnVuY3Rpb24gZWFzZUluQ3ViaWModCkge1xuICAgIHJldHVybiB0ICogdCAqIHQ7XG4gIH0sXG4gIC8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG4gIGVhc2VPdXRDdWJpYzogZnVuY3Rpb24gZWFzZU91dEN1YmljKHQpIHtcbiAgICByZXR1cm4gLS10ICogdCAqIHQgKyAxO1xuICB9LFxuICAvLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cbiAgZWFzZUluT3V0Q3ViaWM6IGZ1bmN0aW9uIGVhc2VJbk91dEN1YmljKHQpIHtcbiAgICByZXR1cm4gdCA8IDAuNSA/IDQgKiB0ICogdCAqIHQgOiAodCAtIDEpICogKDIgKiB0IC0gMikgKiAoMiAqIHQgLSAyKSArIDE7XG4gIH0sXG4gIC8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcbiAgZWFzZUluUXVhcnQ6IGZ1bmN0aW9uIGVhc2VJblF1YXJ0KHQpIHtcbiAgICByZXR1cm4gdCAqIHQgKiB0ICogdDtcbiAgfSxcbiAgLy8gZGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcbiAgZWFzZU91dFF1YXJ0OiBmdW5jdGlvbiBlYXNlT3V0UXVhcnQodCkge1xuICAgIHJldHVybiAxIC0gLS10ICogdCAqIHQgKiB0O1xuICB9LFxuICAvLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cbiAgZWFzZUluT3V0UXVhcnQ6IGZ1bmN0aW9uIGVhc2VJbk91dFF1YXJ0KHQpIHtcbiAgICByZXR1cm4gdCA8IDAuNSA/IDggKiB0ICogdCAqIHQgKiB0IDogMSAtIDggKiAtLXQgKiB0ICogdCAqIHQ7XG4gIH0sXG4gIC8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcbiAgZWFzZUluUXVpbnQ6IGZ1bmN0aW9uIGVhc2VJblF1aW50KHQpIHtcbiAgICByZXR1cm4gdCAqIHQgKiB0ICogdCAqIHQ7XG4gIH0sXG4gIC8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG4gIGVhc2VPdXRRdWludDogZnVuY3Rpb24gZWFzZU91dFF1aW50KHQpIHtcbiAgICByZXR1cm4gMSArIC0tdCAqIHQgKiB0ICogdCAqIHQ7XG4gIH0sXG4gIC8vIGFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxuICBlYXNlSW5PdXRRdWludDogZnVuY3Rpb24gZWFzZUluT3V0UXVpbnQodCkge1xuICAgIHJldHVybiB0IDwgMC41ID8gMTYgKiB0ICogdCAqIHQgKiB0ICogdCA6IDEgKyAxNiAqIC0tdCAqIHQgKiB0ICogdCAqIHQ7XG4gIH1cbn07XG5cbmV4cG9ydHMuZ2V0U2Nyb2xsQmFyV2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpbm5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcbiAgaW5uZXIuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gIGlubmVyLnN0eWxlLmhlaWdodCA9ICcyMDBweCc7XG5cbiAgdmFyIG91dGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIG91dGVyLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgb3V0ZXIuc3R5bGUudG9wID0gJzBweCc7XG4gIG91dGVyLnN0eWxlLmxlZnQgPSAnMHB4JztcbiAgb3V0ZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICBvdXRlci5zdHlsZS53aWR0aCA9ICcyMDBweCc7XG4gIG91dGVyLnN0eWxlLmhlaWdodCA9ICcxNTBweCc7XG4gIG91dGVyLnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gIG91dGVyLmFwcGVuZENoaWxkKGlubmVyKTtcblxuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG91dGVyKTtcbiAgdmFyIHcxID0gaW5uZXIub2Zmc2V0V2lkdGg7XG4gIG91dGVyLnN0eWxlLm92ZXJmbG93ID0gJ3Njcm9sbCc7XG4gIHZhciB3MiA9IGlubmVyLm9mZnNldFdpZHRoO1xuICBpZiAodzEgPT0gdzIpIHcyID0gb3V0ZXIuY2xpZW50V2lkdGg7XG5cbiAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChvdXRlcik7XG5cbiAgcmV0dXJuIHcxIC0gdzI7XG59O1xuXG5leHBvcnRzLnRvcE1vc3QgPSBmdW5jdGlvbiAocGlsZSwgYWNjZXNzb3JzKSB7XG4gIHZhciBjYW5kaWRhdGUgPSB2b2lkIDA7XG4gIGlmICghQXJyYXkuaXNBcnJheShhY2Nlc3NvcnMpKSB7XG4gICAgYWNjZXNzb3JzID0gW2FjY2Vzc29yc107XG4gIH1cbiAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gKDAsIF9nZXRJdGVyYXRvcjNbJ2RlZmF1bHQnXSkocGlsZSksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgIHZhciBtZW1iZXIgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgaWYgKG1lbWJlcikge1xuICAgICAgICBjYW5kaWRhdGUgPSBtZW1iZXJbYWNjZXNzb3JzWzBdXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhY2Nlc3NvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoY2FuZGlkYXRlKSB7XG4gICAgICAgICAgICBjYW5kaWRhdGUgPSBjYW5kaWRhdGVbYWNjZXNzb3JzW2ldXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjYW5kaWRhdGUgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yWydyZXR1cm4nXSkge1xuICAgICAgICBfaXRlcmF0b3JbJ3JldHVybiddKCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2FuZGlkYXRlO1xufTtcblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogX193ZWJwYWNrX3JlcXVpcmVfXygxNDUpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3R5cGVvZjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG52YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHNlbGYsIGNhbGwpIHtcbiAgaWYgKCFzZWxmKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGwgJiYgKCh0eXBlb2YgY2FsbCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkoY2FsbCkpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7XG59O1xuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9zZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oMTQ3KTtcblxudmFyIF9zZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSk7XG5cbnZhciBfY3JlYXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZSk7XG5cbnZhciBfdHlwZW9mMiA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbnZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgKHR5cGVvZiBzdXBlckNsYXNzID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShzdXBlckNsYXNzKSkpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gKDAsIF9jcmVhdGUyLmRlZmF1bHQpKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2YyLmRlZmF1bHQgPyAoMCwgX3NldFByb3RvdHlwZU9mMi5kZWZhdWx0KShzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufTtcblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7IHZlcnNpb246ICcyLjUuNycgfTtcbmlmICh0eXBlb2YgX19lID09ICdudW1iZXInKSBfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfaXRlcmF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwNCk7XG5cbnZhciBfaXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXRlcmF0b3IpO1xuXG52YXIgX3N5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTA2KTtcblxudmFyIF9zeW1ib2wyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ltYm9sKTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBfaXRlcmF0b3IyLmRlZmF1bHQgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfc3ltYm9sMi5kZWZhdWx0ICYmIG9iaiAhPT0gX3N5bWJvbDIuZGVmYXVsdC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBfdHlwZW9mKF9pdGVyYXRvcjIuZGVmYXVsdCkgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqKTtcbn0gOiBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IF9zeW1ib2wyLmRlZmF1bHQgJiYgb2JqICE9PSBfc3ltYm9sMi5kZWZhdWx0LnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqKTtcbn07XG5cbi8qKiovIH0pLFxuLyogOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgc3RvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KSgnd2tzJyk7XG52YXIgdWlkID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSk7XG52YXIgU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCkuU3ltYm9sO1xudmFyIFVTRV9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09ICdmdW5jdGlvbic7XG5cbnZhciAkZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG4gICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07XG5cbiRleHBvcnRzLnN0b3JlID0gc3RvcmU7XG5cblxuLyoqKi8gfSksXG4vKiA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogX193ZWJwYWNrX3JlcXVpcmVfXygxMDIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cbi8qKiovIH0pLFxuLyogMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYgKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpIF9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xudmFyIGNvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xudmFyIGN0eCA9IF9fd2VicGFja19yZXF1aXJlX18oNjEpO1xudmFyIGhpZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbiAodHlwZSwgbmFtZSwgc291cmNlKSB7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GO1xuICB2YXIgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuRztcbiAgdmFyIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlM7XG4gIHZhciBJU19QUk9UTyA9IHR5cGUgJiAkZXhwb3J0LlA7XG4gIHZhciBJU19CSU5EID0gdHlwZSAmICRleHBvcnQuQjtcbiAgdmFyIElTX1dSQVAgPSB0eXBlICYgJGV4cG9ydC5XO1xuICB2YXIgZXhwb3J0cyA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pO1xuICB2YXIgZXhwUHJvdG8gPSBleHBvcnRzW1BST1RPVFlQRV07XG4gIHZhciB0YXJnZXQgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdO1xuICB2YXIga2V5LCBvd24sIG91dDtcbiAgaWYgKElTX0dMT0JBTCkgc291cmNlID0gbmFtZTtcbiAgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICBpZiAob3duICYmIGhhcyhleHBvcnRzLCBrZXkpKSBjb250aW51ZTtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IG93biA/IHRhcmdldFtrZXldIDogc291cmNlW2tleV07XG4gICAgLy8gcHJldmVudCBnbG9iYWwgcG9sbHV0aW9uIGZvciBuYW1lc3BhY2VzXG4gICAgZXhwb3J0c1trZXldID0gSVNfR0xPQkFMICYmIHR5cGVvZiB0YXJnZXRba2V5XSAhPSAnZnVuY3Rpb24nID8gc291cmNlW2tleV1cbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIDogSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpXG4gICAgLy8gd3JhcCBnbG9iYWwgY29uc3RydWN0b3JzIGZvciBwcmV2ZW50IGNoYW5nZSB0aGVtIGluIGxpYnJhcnlcbiAgICA6IElTX1dSQVAgJiYgdGFyZ2V0W2tleV0gPT0gb3V0ID8gKGZ1bmN0aW9uIChDKSB7XG4gICAgICB2YXIgRiA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgQykge1xuICAgICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IEMoKTtcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBDKGEpO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IEMoYSwgYik7XG4gICAgICAgICAgfSByZXR1cm4gbmV3IEMoYSwgYiwgYyk7XG4gICAgICAgIH0gcmV0dXJuIEMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgICBGW1BST1RPVFlQRV0gPSBDW1BST1RPVFlQRV07XG4gICAgICByZXR1cm4gRjtcbiAgICAvLyBtYWtlIHN0YXRpYyB2ZXJzaW9ucyBmb3IgcHJvdG90eXBlIG1ldGhvZHNcbiAgICB9KShvdXQpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLm1ldGhvZHMuJU5BTUUlXG4gICAgaWYgKElTX1BST1RPKSB7XG4gICAgICAoZXhwb3J0cy52aXJ0dWFsIHx8IChleHBvcnRzLnZpcnR1YWwgPSB7fSkpW2tleV0gPSBvdXQ7XG4gICAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUucHJvdG90eXBlLiVOQU1FJVxuICAgICAgaWYgKHR5cGUgJiAkZXhwb3J0LlIgJiYgZXhwUHJvdG8gJiYgIWV4cFByb3RvW2tleV0pIGhpZGUoZXhwUHJvdG8sIGtleSwgb3V0KTtcbiAgICB9XG4gIH1cbn07XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7XG5cblxuLyoqKi8gfSksXG4vKiAxMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcbnZhciBJRThfRE9NX0RFRklORSA9IF9fd2VicGFja19yZXF1aXJlX18oNjIpO1xudmFyIHRvUHJpbWl0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MCk7XG52YXIgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG5cblxuLyoqKi8gfSksXG4vKiAxNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9pc0l0ZXJhYmxlMiA9IF9fd2VicGFja19yZXF1aXJlX18oMTM2KTtcblxudmFyIF9pc0l0ZXJhYmxlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzSXRlcmFibGUyKTtcblxudmFyIF9nZXRJdGVyYXRvcjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU4KTtcblxudmFyIF9nZXRJdGVyYXRvcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRJdGVyYXRvcjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7XG4gICAgdmFyIF9hcnIgPSBbXTtcbiAgICB2YXIgX24gPSB0cnVlO1xuICAgIHZhciBfZCA9IGZhbHNlO1xuICAgIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKHZhciBfaSA9ICgwLCBfZ2V0SXRlcmF0b3IzLmRlZmF1bHQpKGFyciksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2QgPSB0cnVlO1xuICAgICAgX2UgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfYXJyO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICByZXR1cm4gYXJyO1xuICAgIH0gZWxzZSBpZiAoKDAsIF9pc0l0ZXJhYmxlMy5kZWZhdWx0KShPYmplY3QoYXJyKSkpIHtcbiAgICAgIHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xuICAgIH1cbiAgfTtcbn0oKTtcblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG52YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbi8qKlxuICogVGhlIEJhc2UgY2xhc3MgZm9yIGFsbCBOb2Rlcy5cbiAqL1xudmFyIE5vZGVCYXNlID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICovXG4gIGZ1bmN0aW9uIE5vZGVCYXNlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgTm9kZUJhc2UpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLmxhYmVsTW9kdWxlID0gbGFiZWxNb2R1bGU7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIHRoaXMudG9wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGVmdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWFyZ2luID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmVmcmVzaE5lZWRlZCA9IHRydWU7XG4gICAgdGhpcy5ib3VuZGluZ0JveCA9IHsgdG9wOiAwLCBsZWZ0OiAwLCByaWdodDogMCwgYm90dG9tOiAwIH07XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzM1snZGVmYXVsdCddKShOb2RlQmFzZSwgW3tcbiAgICBrZXk6ICdzZXRPcHRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfc2V0TWFyZ2lucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRNYXJnaW5zKGxhYmVsTW9kdWxlKSB7XG4gICAgICB0aGlzLm1hcmdpbiA9IHt9O1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5tYXJnaW4pIHtcbiAgICAgICAgaWYgKCgwLCBfdHlwZW9mM1snZGVmYXVsdCddKSh0aGlzLm9wdGlvbnMubWFyZ2luKSA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHRoaXMubWFyZ2luLnRvcCA9IHRoaXMub3B0aW9ucy5tYXJnaW4udG9wO1xuICAgICAgICAgIHRoaXMubWFyZ2luLnJpZ2h0ID0gdGhpcy5vcHRpb25zLm1hcmdpbi5yaWdodDtcbiAgICAgICAgICB0aGlzLm1hcmdpbi5ib3R0b20gPSB0aGlzLm9wdGlvbnMubWFyZ2luLmJvdHRvbTtcbiAgICAgICAgICB0aGlzLm1hcmdpbi5sZWZ0ID0gdGhpcy5vcHRpb25zLm1hcmdpbi5sZWZ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubWFyZ2luLnRvcCA9IHRoaXMub3B0aW9ucy5tYXJnaW47XG4gICAgICAgICAgdGhpcy5tYXJnaW4ucmlnaHQgPSB0aGlzLm9wdGlvbnMubWFyZ2luO1xuICAgICAgICAgIHRoaXMubWFyZ2luLmJvdHRvbSA9IHRoaXMub3B0aW9ucy5tYXJnaW47XG4gICAgICAgICAgdGhpcy5tYXJnaW4ubGVmdCA9IHRoaXMub3B0aW9ucy5tYXJnaW47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxhYmVsTW9kdWxlLmFkanVzdFNpemVzKHRoaXMubWFyZ2luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19kaXN0YW5jZVRvQm9yZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgdmFyIGJvcmRlcldpZHRoID0gdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoO1xuICAgICAgdGhpcy5yZXNpemUoY3R4KTtcbiAgICAgIHJldHVybiBNYXRoLm1pbihNYXRoLmFicyh0aGlzLndpZHRoIC8gMiAvIE1hdGguY29zKGFuZ2xlKSksIE1hdGguYWJzKHRoaXMuaGVpZ2h0IC8gMiAvIE1hdGguc2luKGFuZ2xlKSkpICsgYm9yZGVyV2lkdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdlbmFibGVTaGFkb3cnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGVTaGFkb3coY3R4LCB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZXMuc2hhZG93KSB7XG4gICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IHZhbHVlcy5zaGFkb3dDb2xvcjtcbiAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSB2YWx1ZXMuc2hhZG93U2l6ZTtcbiAgICAgICAgY3R4LnNoYWRvd09mZnNldFggPSB2YWx1ZXMuc2hhZG93WDtcbiAgICAgICAgY3R4LnNoYWRvd09mZnNldFkgPSB2YWx1ZXMuc2hhZG93WTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Rpc2FibGVTaGFkb3cnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlU2hhZG93KGN0eCwgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWVzLnNoYWRvdykge1xuICAgICAgICBjdHguc2hhZG93Q29sb3IgPSAncmdiYSgwLDAsMCwwKSc7XG4gICAgICAgIGN0eC5zaGFkb3dCbHVyID0gMDtcbiAgICAgICAgY3R4LnNoYWRvd09mZnNldFggPSAwO1xuICAgICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdlbmFibGVCb3JkZXJEYXNoZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGVCb3JkZXJEYXNoZXMoY3R4LCB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZXMuYm9yZGVyRGFzaGVzICE9PSBmYWxzZSkge1xuICAgICAgICBpZiAoY3R4LnNldExpbmVEYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgZGFzaGVzID0gdmFsdWVzLmJvcmRlckRhc2hlcztcbiAgICAgICAgICBpZiAoZGFzaGVzID09PSB0cnVlKSB7XG4gICAgICAgICAgICBkYXNoZXMgPSBbNSwgMTVdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdHguc2V0TGluZURhc2goZGFzaGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ3NldExpbmVEYXNoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyLiBUaGUgZGFzaGVkIGJvcmRlcnMgY2Fubm90IGJlIHVzZWQuJyk7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5ib3JkZXJEYXNoZXMgPSBmYWxzZTtcbiAgICAgICAgICB2YWx1ZXMuYm9yZGVyRGFzaGVzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Rpc2FibGVCb3JkZXJEYXNoZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlQm9yZGVyRGFzaGVzKGN0eCwgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWVzLmJvcmRlckRhc2hlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGN0eC5zZXRMaW5lRGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY3R4LnNldExpbmVEYXNoKFswXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdzZXRMaW5lRGFzaCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3Nlci4gVGhlIGRhc2hlZCBib3JkZXJzIGNhbm5vdCBiZSB1c2VkLicpO1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMuYm9yZGVyRGFzaGVzID0gZmFsc2U7XG4gICAgICAgICAgdmFsdWVzLmJvcmRlckRhc2hlcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIGlmIHRoZSBzaGFwZSBvZiBhIG5vZGUgbmVlZHMgdG8gYmUgcmVjYWxjdWxhdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ25lZWRzUmVmcmVzaCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5lZWRzUmVmcmVzaChzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgIGlmICh0aGlzLnJlZnJlc2hOZWVkZWQgPT09IHRydWUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBwcm9iYWJseSBub3QgdGhlIGJlc3QgbG9jYXRpb24gdG8gcmVzZXQgdGhpcyBtZW1iZXIuXG4gICAgICAgIC8vIEhvd2V2ZXIsIGluIHRoZSBjdXJyZW50IGxvZ2ljLCBpdCBpcyB0aGUgbW9zdCBjb252ZW5pZW50IG9uZS5cbiAgICAgICAgdGhpcy5yZWZyZXNoTmVlZGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy53aWR0aCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMubGFiZWxNb2R1bGUuZGlmZmVyZW50U3RhdGUoc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2luaXRDb250ZXh0Rm9yRHJhdycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRDb250ZXh0Rm9yRHJhdyhjdHgsIHZhbHVlcykge1xuICAgICAgdmFyIGJvcmRlcldpZHRoID0gdmFsdWVzLmJvcmRlcldpZHRoIC8gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG5cbiAgICAgIGN0eC5saW5lV2lkdGggPSBNYXRoLm1pbih0aGlzLndpZHRoLCBib3JkZXJXaWR0aCk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB2YWx1ZXMuYm9yZGVyQ29sb3I7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdmFsdWVzLmNvbG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncGVyZm9ybVN0cm9rZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBlcmZvcm1TdHJva2UoY3R4LCB2YWx1ZXMpIHtcbiAgICAgIHZhciBib3JkZXJXaWR0aCA9IHZhbHVlcy5ib3JkZXJXaWR0aCAvIHRoaXMuYm9keS52aWV3LnNjYWxlO1xuXG4gICAgICAvL2RyYXcgZGFzaGVkIGJvcmRlciBpZiBlbmFibGVkLCBzYXZlIGFuZCByZXN0b3JlIGlzIHJlcXVpcmVkIGZvciBmaXJlZm94IG5vdCB0byBjcmFzaCBvbiB1bml4LlxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIC8vIGlmIGJvcmRlcnMgYXJlIHplcm8gd2lkdGgsIHRoZXkgd2lsbCBiZSBkcmF3biB3aXRoIHdpZHRoIDEgYnkgZGVmYXVsdC4gVGhpcyBwcmV2ZW50cyB0aGF0XG4gICAgICBpZiAoYm9yZGVyV2lkdGggPiAwKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlQm9yZGVyRGFzaGVzKGN0eCwgdmFsdWVzKTtcbiAgICAgICAgLy9kcmF3IHRoZSBib3JkZXJcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAvL2Rpc2FibGUgZGFzaGVkIGJvcmRlciBmb3Igb3RoZXIgZWxlbWVudHNcbiAgICAgICAgdGhpcy5kaXNhYmxlQm9yZGVyRGFzaGVzKGN0eCwgdmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwZXJmb3JtRmlsbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBlcmZvcm1GaWxsKGN0eCwgdmFsdWVzKSB7XG4gICAgICAvLyBkcmF3IHNoYWRvdyBpZiBlbmFibGVkXG4gICAgICB0aGlzLmVuYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7XG4gICAgICAvLyBkcmF3IHRoZSBiYWNrZ3JvdW5kXG4gICAgICBjdHguZmlsbCgpO1xuICAgICAgLy8gZGlzYWJsZSBzaGFkb3dzIGZvciBvdGhlciBlbGVtZW50cy5cbiAgICAgIHRoaXMuZGlzYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7XG5cbiAgICAgIHRoaXMucGVyZm9ybVN0cm9rZShjdHgsIHZhbHVlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWFyZ2luXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2FkZEJvdW5kaW5nQm94TWFyZ2luJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZEJvdW5kaW5nQm94TWFyZ2luKG1hcmdpbikge1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0IC09IG1hcmdpbjtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gudG9wIC09IG1hcmdpbjtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tICs9IG1hcmdpbjtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgKz0gbWFyZ2luO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFjdHVhbCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZCBjYWxsLlxuICAgICAqXG4gICAgICogRG9pbmcgaXQgbGlrZSB0aGlzIG1ha2VzIGl0IGVhc2llciB0byBvdmVycmlkZVxuICAgICAqIGluIHRoZSBjaGlsZCBjbGFzc2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfdXBkYXRlQm91bmRpbmdCb3gnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlQm91bmRpbmdCb3goeCwgeSwgY3R4LCBzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgIGlmIChjdHggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnJlc2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGVmdCA9IHggLSB0aGlzLndpZHRoIC8gMjtcbiAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0IC8gMjtcblxuICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0ID0gdGhpcy5sZWZ0O1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC50b3AgPSB0aGlzLnRvcDtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0gdGhpcy50b3AgKyB0aGlzLmhlaWdodDtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSB0aGlzLmxlZnQgKyB0aGlzLndpZHRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2QgY2FsbC5cbiAgICAgKiBUaGlzIGFjdHMgYXMgYSBzdHViIHdoaWNoIGNhbiBiZSBvdmVycmlkZGVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlQm91bmRpbmdCb3gnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVCb3VuZGluZ0JveCh4LCB5LCBjdHgsIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgdGhpcy5fdXBkYXRlQm91bmRpbmdCb3goeCwgeSwgY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB0aGUgZGltZW5zaW9ucyB0byB1c2UgZm9yIG5vZGVzIHdpdGggYW4gaW50ZXJuYWwgbGFiZWxcbiAgICAgKlxuICAgICAqIEN1cnJlbnRseSwgdGhlc2UgYXJlOiBDaXJjbGUsIEVsbGlwc2UsIERhdGFiYXNlLCBCb3hcbiAgICAgKiBUaGUgb3RoZXIgbm9kZXMgaGF2ZSBleHRlcm5hbCBsYWJlbHMsIGFuZCB3aWxsIG5vdCBjYWxsIHRoaXMgbWV0aG9kXG4gICAgICpcbiAgICAgKiBJZiB0aGVyZSBpcyBubyBsYWJlbCwgZGVjZW50IGRlZmF1bHQgdmFsdWVzIGFyZSBzdXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzZWxlY3RlZF1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtob3Zlcl1cbiAgICAgKiBAcmV0dXJucyB7e3dpZHRoOm51bWJlciwgaGVpZ2h0Om51bWJlcn19XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldERpbWVuc2lvbnNGcm9tTGFiZWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREaW1lbnNpb25zRnJvbUxhYmVsKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICAvLyBOT1RFOiBwcmV2aW91c2x5ICd0ZXh0U2l6ZScgd2FzIG5vdCBwdXQgaW4gJ3RoaXMnIGZvciBFbGxpcHNlXG4gICAgICAvLyBUT0RPOiBleGFtaW5lIHRoZSBjb25zZXF1ZW5jZXMuXG4gICAgICB0aGlzLnRleHRTaXplID0gdGhpcy5sYWJlbE1vZHVsZS5nZXRUZXh0U2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICB2YXIgd2lkdGggPSB0aGlzLnRleHRTaXplLndpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IHRoaXMudGV4dFNpemUuaGVpZ2h0O1xuXG4gICAgICB2YXIgREVGQVVMVF9TSVpFID0gMTQ7XG4gICAgICBpZiAod2lkdGggPT09IDApIHtcbiAgICAgICAgLy8gVGhpcyBoYXBwZW5zIHdoZW4gdGhlcmUgaXMgbm8gbGFiZWwgdGV4dCBzZXRcbiAgICAgICAgd2lkdGggPSBERUZBVUxUX1NJWkU7IC8vIHVzZSBhIGRlY2VudCBkZWZhdWx0XG4gICAgICAgIGhlaWdodCA9IERFRkFVTFRfU0laRTsgLy8gaWYgd2lkdGggemVybywgdGhlbiBoZWlnaHQgYWxzbyBhbHdheXMgemVyb1xuICAgICAgfVxuXG4gICAgICByZXR1cm4geyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBOb2RlQmFzZTtcbn0oKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gTm9kZUJhc2U7XG5cbi8qKiovIH0pLFxuLyogMTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9nZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxudmFyIF9Ob2RlQmFzZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcblxudmFyIF9Ob2RlQmFzZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Ob2RlQmFzZTIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgY29uc3RydWN0aW5nIE5vZGUvQ2x1c3RlciBTaGFwZXMuXG4gKlxuICogQGV4dGVuZHMgTm9kZUJhc2VcbiAqL1xudmFyIFNoYXBlQmFzZSA9IGZ1bmN0aW9uIChfTm9kZUJhc2UpIHtcbiAgKDAsIF9pbmhlcml0czNbJ2RlZmF1bHQnXSkoU2hhcGVCYXNlLCBfTm9kZUJhc2UpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gU2hhcGVCYXNlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgU2hhcGVCYXNlKTtcbiAgICByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuM1snZGVmYXVsdCddKSh0aGlzLCAoU2hhcGVCYXNlLl9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMlsnZGVmYXVsdCddKShTaGFwZUJhc2UpKS5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzZWxlY3RlZF1cbiAgICogQHBhcmFtIHtib29sZWFufSBbaG92ZXJdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbdmFsdWVzPXtzaXplOiB0aGlzLm9wdGlvbnMuc2l6ZX1dXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoU2hhcGVCYXNlLCBbe1xuICAgIGtleTogJ3Jlc2l6ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShjdHgpIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5zZWxlY3RlZDtcbiAgICAgIHZhciBob3ZlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdGhpcy5ob3ZlcjtcbiAgICAgIHZhciB2YWx1ZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHsgc2l6ZTogdGhpcy5vcHRpb25zLnNpemUgfTtcblxuICAgICAgaWYgKHRoaXMubmVlZHNSZWZyZXNoKHNlbGVjdGVkLCBob3ZlcikpIHtcbiAgICAgICAgdGhpcy5sYWJlbE1vZHVsZS5nZXRUZXh0U2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICAgIHZhciBzaXplID0gMiAqIHZhbHVlcy5zaXplO1xuICAgICAgICB0aGlzLndpZHRoID0gc2l6ZTtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBzaXplO1xuICAgICAgICB0aGlzLnJhZGl1cyA9IDAuNSAqIHRoaXMud2lkdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNoYXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemVNdWx0aXBsaWVyIC0gVW51c2VkISBUT0RPOiBSZW1vdmUgbmV4dCBtYWpvciByZWxlYXNlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19kcmF3U2hhcGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd1NoYXBlKGN0eCwgc2hhcGUsIHNpemVNdWx0aXBsaWVyLCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgdGhpcy5yZXNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcyk7XG4gICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAvIDI7XG4gICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAvIDI7XG5cbiAgICAgIHRoaXMuaW5pdENvbnRleHRGb3JEcmF3KGN0eCwgdmFsdWVzKTtcbiAgICAgIGN0eFtzaGFwZV0oeCwgeSwgdmFsdWVzLnNpemUpO1xuICAgICAgdGhpcy5wZXJmb3JtRmlsbChjdHgsIHZhbHVlcyk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaWNvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaWNvbi5jb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjdHguZm9udCA9IChzZWxlY3RlZCA/ICdib2xkICcgOiAnJykgKyB0aGlzLmhlaWdodCAvIDIgKyAncHggJyArICh0aGlzLm9wdGlvbnMuaWNvbi5mYWNlIHx8ICdGb250QXdlc29tZScpO1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLm9wdGlvbnMuaWNvbi5jb2xvciB8fCAnYmxhY2snO1xuICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgICAgY3R4LmZpbGxUZXh0KHRoaXMub3B0aW9ucy5pY29uLmNvZGUsIHgsIHkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubGFiZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBOZWVkIHRvIGNhbGwgZm9sbG93aW5nIGhlcmUgaW4gb3JkZXIgdG8gZW5zdXJlIHZhbHVlIGZvciBgdGhpcy5sYWJlbE1vZHVsZS5zaXplLmhlaWdodGBcbiAgICAgICAgdGhpcy5sYWJlbE1vZHVsZS5jYWxjdWxhdGVMYWJlbFNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIsIHgsIHksICdoYW5naW5nJyk7XG4gICAgICAgIHZhciB5TGFiZWwgPSB5ICsgMC41ICogdGhpcy5oZWlnaHQgKyAwLjUgKiB0aGlzLmxhYmVsTW9kdWxlLnNpemUuaGVpZ2h0O1xuICAgICAgICB0aGlzLmxhYmVsTW9kdWxlLmRyYXcoY3R4LCB4LCB5TGFiZWwsIHNlbGVjdGVkLCBob3ZlciwgJ2hhbmdpbmcnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ0JveCh4LCB5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlQm91bmRpbmdCb3gnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVCb3VuZGluZ0JveCh4LCB5KSB7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LnRvcCA9IHkgLSB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gubGVmdCA9IHggLSB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSB4ICsgdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSA9IHkgKyB0aGlzLm9wdGlvbnMuc2l6ZTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sYWJlbCAhPT0gdW5kZWZpbmVkICYmIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS53aWR0aCA+IDApIHtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0ID0gTWF0aC5taW4odGhpcy5ib3VuZGluZ0JveC5sZWZ0LCB0aGlzLmxhYmVsTW9kdWxlLnNpemUubGVmdCk7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSBNYXRoLm1heCh0aGlzLmJvdW5kaW5nQm94LnJpZ2h0LCB0aGlzLmxhYmVsTW9kdWxlLnNpemUubGVmdCArIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS53aWR0aCk7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0gTWF0aC5tYXgodGhpcy5ib3VuZGluZ0JveC5ib3R0b20sIHRoaXMuYm91bmRpbmdCb3guYm90dG9tICsgdGhpcy5sYWJlbE1vZHVsZS5zaXplLmhlaWdodCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBTaGFwZUJhc2U7XG59KF9Ob2RlQmFzZTNbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFNoYXBlQmFzZTtcblxuLyoqKi8gfSksXG4vKiAxOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OSk7XG52YXIgZGVmaW5lZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDE5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBkUCA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xudmFyIGNyZWF0ZURlc2MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMykgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDIxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxubW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyMyksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuLyoqKi8gfSksXG4vKiAyNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKipcbiAqIFNldHVwIGEgbW9jayBoYW1tZXIuanMgb2JqZWN0LCBmb3IgdW5pdCB0ZXN0aW5nLlxuICpcbiAqIEluc3BpcmF0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vdWJlci9kZWNrLmdsL3B1bGwvNjU4XG4gKlxuICogQHJldHVybnMge3tvbjogbm9vcCwgb2ZmOiBub29wLCBkZXN0cm95OiBub29wLCBlbWl0OiBub29wLCBnZXQ6IGdldH19XG4gKi9cbmZ1bmN0aW9uIGhhbW1lck1vY2soKSB7XG4gIHZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xuXG4gIHJldHVybiB7XG4gICAgb246IG5vb3AsXG4gICAgb2ZmOiBub29wLFxuICAgIGRlc3Ryb3k6IG5vb3AsXG4gICAgZW1pdDogbm9vcCxcblxuICAgIC8vZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQobSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2V0OiBub29wXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIHZhciBwcm9wYWdhdGluZyA9IF9fd2VicGFja19yZXF1aXJlX18oMTI3KTtcbiAgdmFyIEhhbW1lciA9IHdpbmRvd1snSGFtbWVyJ10gfHwgX193ZWJwYWNrX3JlcXVpcmVfXygxMjgpO1xuICBtb2R1bGUuZXhwb3J0cyA9IHByb3BhZ2F0aW5nKEhhbW1lciwge1xuICAgIHByZXZlbnREZWZhdWx0OiAnbW91c2UnXG4gIH0pO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gaGFtbWVyLmpzIGlzIG9ubHkgYXZhaWxhYmxlIGluIGEgYnJvd3Nlciwgbm90IGluIG5vZGUuanMuIFJlcGxhY2luZyBpdCB3aXRoIGEgbW9jayBvYmplY3QuXG4gICAgcmV0dXJuIGhhbW1lck1vY2soKTtcbiAgfTtcbn1cblxuLyoqKi8gfSksXG4vKiAyNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5cbi8qKiovIH0pLFxuLyogMjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgJGtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1KTtcbnZhciBlbnVtQnVnS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oNDUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDI3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gdHJ1ZTtcblxuXG4vKioqLyB9KSxcbi8qIDI4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAyOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG52YXIgaWQgPSAwO1xudmFyIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDMwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAzMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IF9fd2VicGFja19yZXF1aXJlX18oMTAwKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG4vKioqLyB9KSxcbi8qIDMyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5cbi8qKiovIH0pLFxuLyogMzMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9zdHJpbmdpZnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcblxudmFyIF9zdHJpbmdpZnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RyaW5naWZ5KTtcblxudmFyIF90eXBlb2YyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxudmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mMik7XG5cbnZhciBfa2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBfa2V5czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9rZXlzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgUXVldWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyKTtcblxuLyoqXG4gKiBEYXRhU2V0XG4gKiAvLyBUT0RPOiBhZGQgYSBEYXRhU2V0IGNvbnN0cnVjdG9yIERhdGFTZXQoZGF0YSwgb3B0aW9ucylcbiAqXG4gKiBVc2FnZTpcbiAqICAgICB2YXIgZGF0YVNldCA9IG5ldyBEYXRhU2V0KHtcbiAqICAgICAgICAgZmllbGRJZDogJ19pZCcsXG4gKiAgICAgICAgIHR5cGU6IHtcbiAqICAgICAgICAgICAgIC8vIC4uLlxuICogICAgICAgICB9XG4gKiAgICAgfSk7XG4gKlxuICogICAgIGRhdGFTZXQuYWRkKGl0ZW0pO1xuICogICAgIGRhdGFTZXQuYWRkKGRhdGEpO1xuICogICAgIGRhdGFTZXQudXBkYXRlKGl0ZW0pO1xuICogICAgIGRhdGFTZXQudXBkYXRlKGRhdGEpO1xuICogICAgIGRhdGFTZXQucmVtb3ZlKGlkKTtcbiAqICAgICBkYXRhU2V0LnJlbW92ZShpZHMpO1xuICogICAgIHZhciBkYXRhID0gZGF0YVNldC5nZXQoKTtcbiAqICAgICB2YXIgZGF0YSA9IGRhdGFTZXQuZ2V0KGlkKTtcbiAqICAgICB2YXIgZGF0YSA9IGRhdGFTZXQuZ2V0KGlkcyk7XG4gKiAgICAgdmFyIGRhdGEgPSBkYXRhU2V0LmdldChpZHMsIG9wdGlvbnMsIGRhdGEpO1xuICogICAgIGRhdGFTZXQuY2xlYXIoKTtcbiAqXG4gKiBBIGRhdGEgc2V0IGNhbjpcbiAqIC0gYWRkL3JlbW92ZS91cGRhdGUgZGF0YVxuICogLSBnaXZlcyB0cmlnZ2VycyB1cG9uIGNoYW5nZXMgaW4gdGhlIGRhdGFcbiAqIC0gY2FuICBpbXBvcnQvZXhwb3J0IGRhdGEgaW4gdmFyaW91cyBkYXRhIGZvcm1hdHNcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBbZGF0YV0gICAgT3B0aW9uYWwgYXJyYXkgd2l0aCBpbml0aWFsIGRhdGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICBBdmFpbGFibGUgb3B0aW9uczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nfSBmaWVsZElkIEZpZWxkIG5hbWUgb2YgdGhlIGlkIGluIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXMsICdpZCcgYnkgZGVmYXVsdC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0LjxzdHJpbmcsIHN0cmluZ30gdHlwZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQSBtYXAgd2l0aCBmaWVsZCBuYW1lcyBhcyBrZXksXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgdGhlIGZpZWxkIHR5cGUgYXMgdmFsdWUuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAge09iamVjdH0gcXVldWUgICBRdWV1ZSBjaGFuZ2VzIHRvIHRoZSBEYXRhU2V0LFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmx1c2ggdGhlbSBhbGwgYXQgb25jZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFF1ZXVlIG9wdGlvbnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHtudW1iZXJ9IGRlbGF5ICBEZWxheSBpbiBtcywgbnVsbCBieSBkZWZhdWx0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHtudW1iZXJ9IG1heCAgICBNYXhpbXVtIG51bWJlciBvZiBlbnRyaWVzIGluIHRoZSBxdWV1ZSwgSW5maW5pdHkgYnkgZGVmYXVsdFxuICogQGNvbnN0cnVjdG9yIERhdGFTZXRcbiAqL1xuZnVuY3Rpb24gRGF0YVNldChkYXRhLCBvcHRpb25zKSB7XG4gIC8vIGNvcnJlY3RseSByZWFkIG9wdGlvbmFsIGFyZ3VtZW50c1xuICBpZiAoZGF0YSAmJiAhQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgIG9wdGlvbnMgPSBkYXRhO1xuICAgIGRhdGEgPSBudWxsO1xuICB9XG5cbiAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMuX2RhdGEgPSB7fTsgLy8gbWFwIHdpdGggZGF0YSBpbmRleGVkIGJ5IGlkXG4gIHRoaXMubGVuZ3RoID0gMDsgLy8gbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBEYXRhU2V0XG4gIHRoaXMuX2ZpZWxkSWQgPSB0aGlzLl9vcHRpb25zLmZpZWxkSWQgfHwgJ2lkJzsgLy8gbmFtZSBvZiB0aGUgZmllbGQgY29udGFpbmluZyBpZFxuICB0aGlzLl90eXBlID0ge307IC8vIGludGVybmFsIGZpZWxkIHR5cGVzIChOT1RFOiB0aGlzIGNhbiBkaWZmZXIgZnJvbSB0aGlzLl9vcHRpb25zLnR5cGUpXG5cbiAgLy8gYWxsIHZhcmlhbnRzIG9mIGEgRGF0ZSBhcmUgaW50ZXJuYWxseSBzdG9yZWQgYXMgRGF0ZSwgc28gd2UgY2FuIGNvbnZlcnRcbiAgLy8gZnJvbSBldmVyeXRoaW5nIHRvIGV2ZXJ5dGhpbmcgKGFsc28gZnJvbSBJU09EYXRlIHRvIE51bWJlciBmb3IgZXhhbXBsZSlcbiAgaWYgKHRoaXMuX29wdGlvbnMudHlwZSkge1xuICAgIHZhciBmaWVsZHMgPSAoMCwgX2tleXMyWydkZWZhdWx0J10pKHRoaXMuX29wdGlvbnMudHlwZSk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGZpZWxkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGZpZWxkID0gZmllbGRzW2ldO1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy5fb3B0aW9ucy50eXBlW2ZpZWxkXTtcbiAgICAgIGlmICh2YWx1ZSA9PSAnRGF0ZScgfHwgdmFsdWUgPT0gJ0lTT0RhdGUnIHx8IHZhbHVlID09ICdBU1BEYXRlJykge1xuICAgICAgICB0aGlzLl90eXBlW2ZpZWxkXSA9ICdEYXRlJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3R5cGVbZmllbGRdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fc3Vic2NyaWJlcnMgPSB7fTsgLy8gZXZlbnQgc3Vic2NyaWJlcnNcblxuICAvLyBhZGQgaW5pdGlhbCBkYXRhIHdoZW4gcHJvdmlkZWRcbiAgaWYgKGRhdGEpIHtcbiAgICB0aGlzLmFkZChkYXRhKTtcbiAgfVxuXG4gIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAgIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtPYmplY3R9IHF1ZXVlICAgUXVldWUgY2hhbmdlcyB0byB0aGUgRGF0YVNldCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsdXNoIHRoZW0gYWxsIGF0IG9uY2UuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBRdWV1ZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSB7bnVtYmVyfSBkZWxheSAgRGVsYXkgaW4gbXMsIG51bGwgYnkgZGVmYXVsdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSB7bnVtYmVyfSBtYXggICAgTWF4aW11bSBudW1iZXIgb2YgZW50cmllcyBpbiB0aGUgcXVldWUsIEluZmluaXR5IGJ5IGRlZmF1bHRcbiAqL1xuRGF0YVNldC5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucXVldWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChvcHRpb25zLnF1ZXVlID09PSBmYWxzZSkge1xuICAgICAgLy8gZGVsZXRlIHF1ZXVlIGlmIGxvYWRlZFxuICAgICAgaWYgKHRoaXMuX3F1ZXVlKSB7XG4gICAgICAgIHRoaXMuX3F1ZXVlLmRlc3Ryb3koKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3F1ZXVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjcmVhdGUgcXVldWUgYW5kIHVwZGF0ZSBpdHMgb3B0aW9uc1xuICAgICAgaWYgKCF0aGlzLl9xdWV1ZSkge1xuICAgICAgICB0aGlzLl9xdWV1ZSA9IFF1ZXVlLmV4dGVuZCh0aGlzLCB7XG4gICAgICAgICAgcmVwbGFjZTogWydhZGQnLCAndXBkYXRlJywgJ3JlbW92ZSddXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoKDAsIF90eXBlb2YzWydkZWZhdWx0J10pKG9wdGlvbnMucXVldWUpID09PSAnb2JqZWN0Jykge1xuICAgICAgICB0aGlzLl9xdWV1ZS5zZXRPcHRpb25zKG9wdGlvbnMucXVldWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBTdWJzY3JpYmUgdG8gYW4gZXZlbnQsIGFkZCBhbiBldmVudCBsaXN0ZW5lclxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50ICAgICAgICBFdmVudCBuYW1lLiBBdmFpbGFibGUgZXZlbnRzOiAnYWRkJywgJ3VwZGF0ZScsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdyZW1vdmUnXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAgIENhbGxiYWNrIG1ldGhvZC4gQ2FsbGVkIHdpdGggdGhyZWUgcGFyYW1ldGVyczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzdHJpbmd9IGV2ZW50XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0IHwgbnVsbH0gcGFyYW1zXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nIHwgbnVtYmVyfSBzZW5kZXJJZFxuICovXG5EYXRhU2V0LnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudCwgY2FsbGJhY2spIHtcbiAgdmFyIHN1YnNjcmliZXJzID0gdGhpcy5fc3Vic2NyaWJlcnNbZXZlbnRdO1xuICBpZiAoIXN1YnNjcmliZXJzKSB7XG4gICAgc3Vic2NyaWJlcnMgPSBbXTtcbiAgICB0aGlzLl9zdWJzY3JpYmVyc1tldmVudF0gPSBzdWJzY3JpYmVycztcbiAgfVxuXG4gIHN1YnNjcmliZXJzLnB1c2goe1xuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbi8qKlxuICogVW5zdWJzY3JpYmUgZnJvbSBhbiBldmVudCwgcmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIChldmVudCwgY2FsbGJhY2spIHtcbiAgdmFyIHN1YnNjcmliZXJzID0gdGhpcy5fc3Vic2NyaWJlcnNbZXZlbnRdO1xuICBpZiAoc3Vic2NyaWJlcnMpIHtcbiAgICB0aGlzLl9zdWJzY3JpYmVyc1tldmVudF0gPSBzdWJzY3JpYmVycy5maWx0ZXIoZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gbGlzdGVuZXIuY2FsbGJhY2sgIT0gY2FsbGJhY2s7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogVHJpZ2dlciBhbiBldmVudFxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge09iamVjdCB8IG51bGx9IHBhcmFtc1xuICogQHBhcmFtIHtzdHJpbmd9IFtzZW5kZXJJZF0gICAgICAgT3B0aW9uYWwgaWQgb2YgdGhlIHNlbmRlci5cbiAqIEBwcml2YXRlXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLl90cmlnZ2VyID0gZnVuY3Rpb24gKGV2ZW50LCBwYXJhbXMsIHNlbmRlcklkKSB7XG4gIGlmIChldmVudCA9PSAnKicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB0cmlnZ2VyIGV2ZW50IConKTtcbiAgfVxuXG4gIHZhciBzdWJzY3JpYmVycyA9IFtdO1xuICBpZiAoZXZlbnQgaW4gdGhpcy5fc3Vic2NyaWJlcnMpIHtcbiAgICBzdWJzY3JpYmVycyA9IHN1YnNjcmliZXJzLmNvbmNhdCh0aGlzLl9zdWJzY3JpYmVyc1tldmVudF0pO1xuICB9XG4gIGlmICgnKicgaW4gdGhpcy5fc3Vic2NyaWJlcnMpIHtcbiAgICBzdWJzY3JpYmVycyA9IHN1YnNjcmliZXJzLmNvbmNhdCh0aGlzLl9zdWJzY3JpYmVyc1snKiddKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdWJzY3JpYmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBzdWJzY3JpYmVyID0gc3Vic2NyaWJlcnNbaV07XG4gICAgaWYgKHN1YnNjcmliZXIuY2FsbGJhY2spIHtcbiAgICAgIHN1YnNjcmliZXIuY2FsbGJhY2soZXZlbnQsIHBhcmFtcywgc2VuZGVySWQgfHwgbnVsbCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEFkZCBkYXRhLlxuICogQWRkaW5nIGFuIGl0ZW0gd2lsbCBmYWlsIHdoZW4gdGhlcmUgYWxyZWFkeSBpcyBhbiBpdGVtIHdpdGggdGhlIHNhbWUgaWQuXG4gKiBAcGFyYW0ge09iamVjdCB8IEFycmF5fSBkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gW3NlbmRlcklkXSBPcHRpb25hbCBzZW5kZXIgaWRcbiAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmd8bnVtYmVyPn0gYWRkZWRJZHMgICAgICBBcnJheSB3aXRoIHRoZSBpZHMgb2YgdGhlIGFkZGVkIGl0ZW1zXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChkYXRhLCBzZW5kZXJJZCkge1xuICB2YXIgYWRkZWRJZHMgPSBbXSxcbiAgICAgIGlkLFxuICAgICAgbWUgPSB0aGlzO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgLy8gQXJyYXlcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWQgPSBtZS5fYWRkSXRlbShkYXRhW2ldKTtcbiAgICAgIGFkZGVkSWRzLnB1c2goaWQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChkYXRhICYmICh0eXBlb2YgZGF0YSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6ICgwLCBfdHlwZW9mM1snZGVmYXVsdCddKShkYXRhKSkgPT09ICdvYmplY3QnKSB7XG4gICAgLy8gU2luZ2xlIGl0ZW1cbiAgICBpZCA9IG1lLl9hZGRJdGVtKGRhdGEpO1xuICAgIGFkZGVkSWRzLnB1c2goaWQpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBkYXRhVHlwZScpO1xuICB9XG5cbiAgaWYgKGFkZGVkSWRzLmxlbmd0aCkge1xuICAgIHRoaXMuX3RyaWdnZXIoJ2FkZCcsIHsgaXRlbXM6IGFkZGVkSWRzIH0sIHNlbmRlcklkKTtcbiAgfVxuXG4gIHJldHVybiBhZGRlZElkcztcbn07XG5cbi8qKlxuICogVXBkYXRlIGV4aXN0aW5nIGl0ZW1zLiBXaGVuIGFuIGl0ZW0gZG9lcyBub3QgZXhpc3QsIGl0IHdpbGwgYmUgY3JlYXRlZFxuICogQHBhcmFtIHtPYmplY3QgfCBBcnJheX0gZGF0YVxuICogQHBhcmFtIHtzdHJpbmd9IFtzZW5kZXJJZF0gT3B0aW9uYWwgc2VuZGVyIGlkXG4gKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nfG51bWJlcj59IHVwZGF0ZWRJZHMgICAgIFRoZSBpZHMgb2YgdGhlIGFkZGVkIG9yIHVwZGF0ZWQgaXRlbXNcbiAqIEB0aHJvd3Mge0Vycm9yfSBVbmtub3duIERhdGF0eXBlXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBzZW5kZXJJZCkge1xuICB2YXIgYWRkZWRJZHMgPSBbXTtcbiAgdmFyIHVwZGF0ZWRJZHMgPSBbXTtcbiAgdmFyIG9sZERhdGEgPSBbXTtcbiAgdmFyIHVwZGF0ZWREYXRhID0gW107XG4gIHZhciBtZSA9IHRoaXM7XG4gIHZhciBmaWVsZElkID0gbWUuX2ZpZWxkSWQ7XG5cbiAgdmFyIGFkZE9yVXBkYXRlID0gZnVuY3Rpb24gYWRkT3JVcGRhdGUoaXRlbSkge1xuICAgIHZhciBpZCA9IGl0ZW1bZmllbGRJZF07XG4gICAgaWYgKG1lLl9kYXRhW2lkXSkge1xuICAgICAgdmFyIG9sZEl0ZW0gPSB1dGlsLmV4dGVuZCh7fSwgbWUuX2RhdGFbaWRdKTtcbiAgICAgIC8vIHVwZGF0ZSBpdGVtXG4gICAgICBpZCA9IG1lLl91cGRhdGVJdGVtKGl0ZW0pO1xuICAgICAgdXBkYXRlZElkcy5wdXNoKGlkKTtcbiAgICAgIHVwZGF0ZWREYXRhLnB1c2goaXRlbSk7XG4gICAgICBvbGREYXRhLnB1c2gob2xkSXRlbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGFkZCBuZXcgaXRlbVxuICAgICAgaWQgPSBtZS5fYWRkSXRlbShpdGVtKTtcbiAgICAgIGFkZGVkSWRzLnB1c2goaWQpO1xuICAgIH1cbiAgfTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgIC8vIEFycmF5XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChkYXRhW2ldICYmICgwLCBfdHlwZW9mM1snZGVmYXVsdCddKShkYXRhW2ldKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYWRkT3JVcGRhdGUoZGF0YVtpXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0lnbm9yaW5nIGlucHV0IGl0ZW0sIHdoaWNoIGlzIG5vdCBhbiBvYmplY3QgYXQgaW5kZXggJyArIGkpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChkYXRhICYmICh0eXBlb2YgZGF0YSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6ICgwLCBfdHlwZW9mM1snZGVmYXVsdCddKShkYXRhKSkgPT09ICdvYmplY3QnKSB7XG4gICAgLy8gU2luZ2xlIGl0ZW1cbiAgICBhZGRPclVwZGF0ZShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZGF0YVR5cGUnKTtcbiAgfVxuXG4gIGlmIChhZGRlZElkcy5sZW5ndGgpIHtcbiAgICB0aGlzLl90cmlnZ2VyKCdhZGQnLCB7IGl0ZW1zOiBhZGRlZElkcyB9LCBzZW5kZXJJZCk7XG4gIH1cbiAgaWYgKHVwZGF0ZWRJZHMubGVuZ3RoKSB7XG4gICAgdmFyIHByb3BzID0geyBpdGVtczogdXBkYXRlZElkcywgb2xkRGF0YTogb2xkRGF0YSwgZGF0YTogdXBkYXRlZERhdGFcbiAgICAgIC8vIFRPRE86IHJlbW92ZSBkZXByZWNhdGVkIHByb3BlcnR5ICdkYXRhJyBzb21lIGRheVxuICAgICAgLy9PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdkYXRhJywge1xuICAgICAgLy8gICdnZXQnOiAoZnVuY3Rpb24oKSB7XG4gICAgICAvLyAgICBjb25zb2xlLndhcm4oJ1Byb3BlcnR5IGRhdGEgaXMgZGVwcmVjYXRlZC4gVXNlIERhdGFTZXQuZ2V0KGlkcykgdG8gcmV0cmlldmUgdGhlIG5ldyBkYXRhLCB1c2UgdGhlIG9sZERhdGEgcHJvcGVydHkgb24gdGhpcyBvYmplY3QgdG8gZ2V0IHRoZSBvbGQgZGF0YScpO1xuICAgICAgLy8gICAgcmV0dXJuIHVwZGF0ZWREYXRhO1xuICAgICAgLy8gIH0pLmJpbmQodGhpcylcbiAgICAgIC8vfSk7XG4gICAgfTt0aGlzLl90cmlnZ2VyKCd1cGRhdGUnLCBwcm9wcywgc2VuZGVySWQpO1xuICB9XG5cbiAgcmV0dXJuIGFkZGVkSWRzLmNvbmNhdCh1cGRhdGVkSWRzKTtcbn07XG5cbi8vIHByZXR0aWVyLWlnbm9yZVxuLyoqXG4gKiBHZXQgYSBkYXRhIGl0ZW0gb3IgbXVsdGlwbGUgaXRlbXMuXG4gKlxuICogVXNhZ2U6XG4gKlxuICogICAgIGdldCgpXG4gKiAgICAgZ2V0KG9wdGlvbnM6IE9iamVjdClcbiAqXG4gKiAgICAgZ2V0KGlkOiBudW1iZXIgfCBzdHJpbmcpXG4gKiAgICAgZ2V0KGlkOiBudW1iZXIgfCBzdHJpbmcsIG9wdGlvbnM6IE9iamVjdClcbiAqXG4gKiAgICAgZ2V0KGlkczogbnVtYmVyW10gfCBzdHJpbmdbXSlcbiAqICAgICBnZXQoaWRzOiBudW1iZXJbXSB8IHN0cmluZ1tdLCBvcHRpb25zOiBPYmplY3QpXG4gKlxuICogV2hlcmU6XG4gKlxuICoge251bWJlciB8IHN0cmluZ30gaWQgICAgICAgICBUaGUgaWQgb2YgYW4gaXRlbVxuICoge251bWJlcltdIHwgc3RyaW5ne319IGlkcyAgICBBbiBhcnJheSB3aXRoIGlkcyBvZiBpdGVtc1xuICoge09iamVjdH0gb3B0aW9ucyAgICAgICAgICAgICBBbiBPYmplY3Qgd2l0aCBvcHRpb25zLiBBdmFpbGFibGUgb3B0aW9uczpcbiAqIHtzdHJpbmd9IFtyZXR1cm5UeXBlXSAgICAgICAgVHlwZSBvZiBkYXRhIHRvIGJlIHJldHVybmVkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDYW4gYmUgJ0FycmF5JyAoZGVmYXVsdCkgb3IgJ09iamVjdCcuXG4gKiB7T2JqZWN0LjxzdHJpbmcsIHN0cmluZz59IFt0eXBlXVxuICoge3N0cmluZ1tdfSBbZmllbGRzXSAgICAgICAgICBmaWVsZCBuYW1lcyB0byBiZSByZXR1cm5lZFxuICoge2Z1bmN0aW9ufSBbZmlsdGVyXSAgICAgICAgICBmaWx0ZXIgaXRlbXNcbiAqIHtzdHJpbmcgfCBmdW5jdGlvbn0gW29yZGVyXSAgT3JkZXIgdGhlIGl0ZW1zIGJ5IGEgZmllbGQgbmFtZSBvciBjdXN0b20gc29ydCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3NcbiAqIEByZXR1cm5zIHtEYXRhU2V0fVxuICogQHRocm93cyBFcnJvclxuICovXG5EYXRhU2V0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoYXJncykge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBtZSA9IHRoaXM7XG5cbiAgLy8gcGFyc2UgdGhlIGFyZ3VtZW50c1xuICB2YXIgaWQsIGlkcywgb3B0aW9ucztcbiAgdmFyIGZpcnN0VHlwZSA9IHV0aWwuZ2V0VHlwZShhcmd1bWVudHNbMF0pO1xuICBpZiAoZmlyc3RUeXBlID09ICdTdHJpbmcnIHx8IGZpcnN0VHlwZSA9PSAnTnVtYmVyJykge1xuICAgIC8vIGdldChpZCBbLCBvcHRpb25zXSlcbiAgICBpZCA9IGFyZ3VtZW50c1swXTtcbiAgICBvcHRpb25zID0gYXJndW1lbnRzWzFdO1xuICB9IGVsc2UgaWYgKGZpcnN0VHlwZSA9PSAnQXJyYXknKSB7XG4gICAgLy8gZ2V0KGlkcyBbLCBvcHRpb25zXSlcbiAgICBpZHMgPSBhcmd1bWVudHNbMF07XG4gICAgb3B0aW9ucyA9IGFyZ3VtZW50c1sxXTtcbiAgfSBlbHNlIHtcbiAgICAvLyBnZXQoWywgb3B0aW9uc10pXG4gICAgb3B0aW9ucyA9IGFyZ3VtZW50c1swXTtcbiAgfVxuXG4gIC8vIGRldGVybWluZSB0aGUgcmV0dXJuIHR5cGVcbiAgdmFyIHJldHVyblR5cGU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmV0dXJuVHlwZSkge1xuICAgIHZhciBhbGxvd2VkVmFsdWVzID0gWydBcnJheScsICdPYmplY3QnXTtcbiAgICByZXR1cm5UeXBlID0gYWxsb3dlZFZhbHVlcy5pbmRleE9mKG9wdGlvbnMucmV0dXJuVHlwZSkgPT0gLTEgPyAnQXJyYXknIDogb3B0aW9ucy5yZXR1cm5UeXBlO1xuICB9IGVsc2Uge1xuICAgIHJldHVyblR5cGUgPSAnQXJyYXknO1xuICB9XG5cbiAgLy8gYnVpbGQgb3B0aW9uc1xuICB2YXIgdHlwZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy50eXBlIHx8IHRoaXMuX29wdGlvbnMudHlwZTtcbiAgdmFyIGZpbHRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5maWx0ZXI7XG4gIHZhciBpdGVtcyA9IFtdLFxuICAgICAgaXRlbSxcbiAgICAgIGl0ZW1JZHMsXG4gICAgICBpdGVtSWQsXG4gICAgICBpLFxuICAgICAgbGVuO1xuXG4gIC8vIGNvbnZlcnQgaXRlbXNcbiAgaWYgKGlkICE9IHVuZGVmaW5lZCkge1xuICAgIC8vIHJldHVybiBhIHNpbmdsZSBpdGVtXG4gICAgaXRlbSA9IG1lLl9nZXRJdGVtKGlkLCB0eXBlKTtcbiAgICBpZiAoaXRlbSAmJiBmaWx0ZXIgJiYgIWZpbHRlcihpdGVtKSkge1xuICAgICAgaXRlbSA9IG51bGw7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlkcyAhPSB1bmRlZmluZWQpIHtcbiAgICAvLyByZXR1cm4gYSBzdWJzZXQgb2YgaXRlbXNcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBpZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGl0ZW0gPSBtZS5fZ2V0SXRlbShpZHNbaV0sIHR5cGUpO1xuICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKGl0ZW0pKSB7XG4gICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIHJldHVybiBhbGwgaXRlbXNcbiAgICBpdGVtSWRzID0gKDAsIF9rZXlzMlsnZGVmYXVsdCddKSh0aGlzLl9kYXRhKTtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtSWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpdGVtSWQgPSBpdGVtSWRzW2ldO1xuICAgICAgaXRlbSA9IG1lLl9nZXRJdGVtKGl0ZW1JZCwgdHlwZSk7XG4gICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoaXRlbSkpIHtcbiAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBvcmRlciB0aGUgcmVzdWx0c1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm9yZGVyICYmIGlkID09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuX3NvcnQoaXRlbXMsIG9wdGlvbnMub3JkZXIpO1xuICB9XG5cbiAgLy8gZmlsdGVyIGZpZWxkcyBvZiB0aGUgaXRlbXNcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5maWVsZHMpIHtcbiAgICB2YXIgZmllbGRzID0gb3B0aW9ucy5maWVsZHM7XG4gICAgaWYgKGlkICE9IHVuZGVmaW5lZCkge1xuICAgICAgaXRlbSA9IHRoaXMuX2ZpbHRlckZpZWxkcyhpdGVtLCBmaWVsZHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpdGVtc1tpXSA9IHRoaXMuX2ZpbHRlckZpZWxkcyhpdGVtc1tpXSwgZmllbGRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyByZXR1cm4gdGhlIHJlc3VsdHNcbiAgaWYgKHJldHVyblR5cGUgPT0gJ09iamVjdCcpIHtcbiAgICB2YXIgcmVzdWx0ID0ge30sXG4gICAgICAgIHJlc3VsdGFudDtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgcmVzdWx0YW50ID0gaXRlbXNbaV07XG4gICAgICByZXN1bHRbcmVzdWx0YW50LmlkXSA9IHJlc3VsdGFudDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBlbHNlIHtcbiAgICBpZiAoaWQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBhIHNpbmdsZSBpdGVtXG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8ganVzdCByZXR1cm4gb3VyIGFycmF5XG4gICAgICByZXR1cm4gaXRlbXM7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEdldCBpZHMgb2YgYWxsIGl0ZW1zIG9yIGZyb20gYSBmaWx0ZXJlZCBzZXQgb2YgaXRlbXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgIEFuIE9iamVjdCB3aXRoIG9wdGlvbnMuIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ZnVuY3Rpb259IFtmaWx0ZXJdIGZpbHRlciBpdGVtc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nIHwgZnVuY3Rpb259IFtvcmRlcl0gT3JkZXIgdGhlIGl0ZW1zIGJ5XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIGZpZWxkIG5hbWUgb3IgY3VzdG9tIHNvcnQgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nfG51bWJlcj59IGlkc1xuICovXG5EYXRhU2V0LnByb3RvdHlwZS5nZXRJZHMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgZGF0YSA9IHRoaXMuX2RhdGEsXG4gICAgICBmaWx0ZXIgPSBvcHRpb25zICYmIG9wdGlvbnMuZmlsdGVyLFxuICAgICAgb3JkZXIgPSBvcHRpb25zICYmIG9wdGlvbnMub3JkZXIsXG4gICAgICB0eXBlID0gb3B0aW9ucyAmJiBvcHRpb25zLnR5cGUgfHwgdGhpcy5fb3B0aW9ucy50eXBlLFxuICAgICAgaXRlbUlkcyA9ICgwLCBfa2V5czJbJ2RlZmF1bHQnXSkoZGF0YSksXG4gICAgICBpLFxuICAgICAgbGVuLFxuICAgICAgaWQsXG4gICAgICBpdGVtLFxuICAgICAgaXRlbXMsXG4gICAgICBpZHMgPSBbXTtcblxuICBpZiAoZmlsdGVyKSB7XG4gICAgLy8gZ2V0IGZpbHRlcmVkIGl0ZW1zXG4gICAgaWYgKG9yZGVyKSB7XG4gICAgICAvLyBjcmVhdGUgb3JkZXJlZCBsaXN0XG4gICAgICBpdGVtcyA9IFtdO1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gaXRlbUlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZCA9IGl0ZW1JZHNbaV07XG4gICAgICAgIGl0ZW0gPSB0aGlzLl9nZXRJdGVtKGlkLCB0eXBlKTtcbiAgICAgICAgaWYgKGZpbHRlcihpdGVtKSkge1xuICAgICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fc29ydChpdGVtcywgb3JkZXIpO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZHMucHVzaChpdGVtc1tpXVt0aGlzLl9maWVsZElkXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNyZWF0ZSB1bm9yZGVyZWQgbGlzdFxuICAgICAgZm9yIChpID0gMCwgbGVuID0gaXRlbUlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZCA9IGl0ZW1JZHNbaV07XG4gICAgICAgIGl0ZW0gPSB0aGlzLl9nZXRJdGVtKGlkLCB0eXBlKTtcbiAgICAgICAgaWYgKGZpbHRlcihpdGVtKSkge1xuICAgICAgICAgIGlkcy5wdXNoKGl0ZW1bdGhpcy5fZmllbGRJZF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGdldCBhbGwgaXRlbXNcbiAgICBpZiAob3JkZXIpIHtcbiAgICAgIC8vIGNyZWF0ZSBhbiBvcmRlcmVkIGxpc3RcbiAgICAgIGl0ZW1zID0gW107XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtSWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlkID0gaXRlbUlkc1tpXTtcbiAgICAgICAgaXRlbXMucHVzaChkYXRhW2lkXSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3NvcnQoaXRlbXMsIG9yZGVyKTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWRzLnB1c2goaXRlbXNbaV1bdGhpcy5fZmllbGRJZF0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjcmVhdGUgdW5vcmRlcmVkIGxpc3RcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1JZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWQgPSBpdGVtSWRzW2ldO1xuICAgICAgICBpdGVtID0gZGF0YVtpZF07XG4gICAgICAgIGlkcy5wdXNoKGl0ZW1bdGhpcy5fZmllbGRJZF0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpZHM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIERhdGFTZXQgaXRzZWxmLiBJcyBvdmVyd3JpdHRlbiBmb3IgZXhhbXBsZSBieSB0aGUgRGF0YVZpZXcsXG4gKiB3aGljaCByZXR1cm5zIHRoZSBEYXRhU2V0IGl0IGlzIGNvbm5lY3RlZCB0byBpbnN0ZWFkLlxuICogQHJldHVybnMge0RhdGFTZXR9XG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLmdldERhdGFTZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlIGEgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIGV2ZXJ5IGl0ZW0gaW4gdGhlIGRhdGFzZXQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICBBdmFpbGFibGUgb3B0aW9uczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge09iamVjdC48c3RyaW5nLCBzdHJpbmc+fSBbdHlwZV1cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3N0cmluZ1tdfSBbZmllbGRzXSBmaWx0ZXIgZmllbGRzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtmdW5jdGlvbn0gW2ZpbHRlcl0gZmlsdGVyIGl0ZW1zXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzdHJpbmcgfCBmdW5jdGlvbn0gW29yZGVyXSBPcmRlciB0aGUgaXRlbXMgYnlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgZmllbGQgbmFtZSBvciBjdXN0b20gc29ydCBmdW5jdGlvbi5cbiAqL1xuRGF0YVNldC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgb3B0aW9ucykge1xuICB2YXIgZmlsdGVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmZpbHRlcixcbiAgICAgIHR5cGUgPSBvcHRpb25zICYmIG9wdGlvbnMudHlwZSB8fCB0aGlzLl9vcHRpb25zLnR5cGUsXG4gICAgICBkYXRhID0gdGhpcy5fZGF0YSxcbiAgICAgIGl0ZW1JZHMgPSAoMCwgX2tleXMyWydkZWZhdWx0J10pKGRhdGEpLFxuICAgICAgaSxcbiAgICAgIGxlbixcbiAgICAgIGl0ZW0sXG4gICAgICBpZDtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm9yZGVyKSB7XG4gICAgLy8gZXhlY3V0ZSBmb3JFYWNoIG9uIG9yZGVyZWQgbGlzdFxuICAgIHZhciBpdGVtcyA9IHRoaXMuZ2V0KG9wdGlvbnMpO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgIGlkID0gaXRlbVt0aGlzLl9maWVsZElkXTtcbiAgICAgIGNhbGxiYWNrKGl0ZW0sIGlkKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gdW5vcmRlcmVkXG4gICAgZm9yIChpID0gMCwgbGVuID0gaXRlbUlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWQgPSBpdGVtSWRzW2ldO1xuICAgICAgaXRlbSA9IHRoaXMuX2dldEl0ZW0oaWQsIHR5cGUpO1xuICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKGl0ZW0pKSB7XG4gICAgICAgIGNhbGxiYWNrKGl0ZW0sIGlkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogTWFwIGV2ZXJ5IGl0ZW0gaW4gdGhlIGRhdGFzZXQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICBBdmFpbGFibGUgb3B0aW9uczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge09iamVjdC48c3RyaW5nLCBzdHJpbmc+fSBbdHlwZV1cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3N0cmluZ1tdfSBbZmllbGRzXSBmaWx0ZXIgZmllbGRzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtmdW5jdGlvbn0gW2ZpbHRlcl0gZmlsdGVyIGl0ZW1zXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzdHJpbmcgfCBmdW5jdGlvbn0gW29yZGVyXSBPcmRlciB0aGUgaXRlbXMgYnlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgZmllbGQgbmFtZSBvciBjdXN0b20gc29ydCBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge09iamVjdFtdfSBtYXBwZWRJdGVtc1xuICovXG5EYXRhU2V0LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgdmFyIGZpbHRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5maWx0ZXIsXG4gICAgICB0eXBlID0gb3B0aW9ucyAmJiBvcHRpb25zLnR5cGUgfHwgdGhpcy5fb3B0aW9ucy50eXBlLFxuICAgICAgbWFwcGVkSXRlbXMgPSBbXSxcbiAgICAgIGRhdGEgPSB0aGlzLl9kYXRhLFxuICAgICAgaXRlbUlkcyA9ICgwLCBfa2V5czJbJ2RlZmF1bHQnXSkoZGF0YSksXG4gICAgICBpLFxuICAgICAgbGVuLFxuICAgICAgaWQsXG4gICAgICBpdGVtO1xuXG4gIC8vIGNvbnZlcnQgYW5kIGZpbHRlciBpdGVtc1xuICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtSWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWQgPSBpdGVtSWRzW2ldO1xuICAgIGl0ZW0gPSB0aGlzLl9nZXRJdGVtKGlkLCB0eXBlKTtcbiAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoaXRlbSkpIHtcbiAgICAgIG1hcHBlZEl0ZW1zLnB1c2goY2FsbGJhY2soaXRlbSwgaWQpKTtcbiAgICB9XG4gIH1cblxuICAvLyBvcmRlciBpdGVtc1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm9yZGVyKSB7XG4gICAgdGhpcy5fc29ydChtYXBwZWRJdGVtcywgb3B0aW9ucy5vcmRlcik7XG4gIH1cblxuICByZXR1cm4gbWFwcGVkSXRlbXM7XG59O1xuXG4vKipcbiAqIEZpbHRlciB0aGUgZmllbGRzIG9mIGFuIGl0ZW1cbiAqIEBwYXJhbSB7T2JqZWN0IHwgbnVsbH0gaXRlbVxuICogQHBhcmFtIHtzdHJpbmdbXX0gZmllbGRzICAgICBGaWVsZCBuYW1lc1xuICogQHJldHVybiB7T2JqZWN0IHwgbnVsbH0gZmlsdGVyZWRJdGVtIG9yIG51bGwgaWYgbm8gaXRlbSBpcyBwcm92aWRlZFxuICogQHByaXZhdGVcbiAqL1xuRGF0YVNldC5wcm90b3R5cGUuX2ZpbHRlckZpZWxkcyA9IGZ1bmN0aW9uIChpdGVtLCBmaWVsZHMpIHtcbiAgaWYgKCFpdGVtKSB7XG4gICAgLy8gaXRlbSBpcyBudWxsXG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cblxuICB2YXIgZmlsdGVyZWRJdGVtID0ge30sXG4gICAgICBpdGVtRmllbGRzID0gKDAsIF9rZXlzMlsnZGVmYXVsdCddKShpdGVtKSxcbiAgICAgIGxlbiA9IGl0ZW1GaWVsZHMubGVuZ3RoLFxuICAgICAgaSxcbiAgICAgIGZpZWxkO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGZpZWxkcykpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGZpZWxkID0gaXRlbUZpZWxkc1tpXTtcbiAgICAgIGlmIChmaWVsZHMuaW5kZXhPZihmaWVsZCkgIT0gLTEpIHtcbiAgICAgICAgZmlsdGVyZWRJdGVtW2ZpZWxkXSA9IGl0ZW1bZmllbGRdO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGZpZWxkID0gaXRlbUZpZWxkc1tpXTtcbiAgICAgIGlmIChmaWVsZHMuaGFzT3duUHJvcGVydHkoZmllbGQpKSB7XG4gICAgICAgIGZpbHRlcmVkSXRlbVtmaWVsZHNbZmllbGRdXSA9IGl0ZW1bZmllbGRdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmaWx0ZXJlZEl0ZW07XG59O1xuXG4vKipcbiAqIFNvcnQgdGhlIHByb3ZpZGVkIGFycmF5IHdpdGggaXRlbXNcbiAqIEBwYXJhbSB7T2JqZWN0W119IGl0ZW1zXG4gKiBAcGFyYW0ge3N0cmluZyB8IGZ1bmN0aW9ufSBvcmRlciAgICAgIEEgZmllbGQgbmFtZSBvciBjdXN0b20gc29ydCBmdW5jdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLl9zb3J0ID0gZnVuY3Rpb24gKGl0ZW1zLCBvcmRlcikge1xuICBpZiAodXRpbC5pc1N0cmluZyhvcmRlcikpIHtcbiAgICAvLyBvcmRlciBieSBwcm92aWRlZCBmaWVsZCBuYW1lXG4gICAgdmFyIG5hbWUgPSBvcmRlcjsgLy8gZmllbGQgbmFtZVxuICAgIGl0ZW1zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHZhciBhdiA9IGFbbmFtZV07XG4gICAgICB2YXIgYnYgPSBiW25hbWVdO1xuICAgICAgcmV0dXJuIGF2ID4gYnYgPyAxIDogYXYgPCBidiA/IC0xIDogMDtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3JkZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBvcmRlciBieSBzb3J0IGZ1bmN0aW9uXG4gICAgaXRlbXMuc29ydChvcmRlcik7XG4gIH1cbiAgLy8gVE9ETzogZXh0ZW5kIG9yZGVyIGJ5IGFuIE9iamVjdCB7ZmllbGQ6c3RyaW5nLCBkaXJlY3Rpb246c3RyaW5nfVxuICAvLyAgICAgICB3aGVyZSBkaXJlY3Rpb24gY2FuIGJlICdhc2MnIG9yICdkZXNjJ1xuICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09yZGVyIG11c3QgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZycpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIG9iamVjdCBieSBwb2ludGVyIG9yIGJ5IGlkXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlciB8IE9iamVjdCB8IEFycmF5LjxzdHJpbmd8bnVtYmVyPn0gaWQgT2JqZWN0IG9yIGlkLCBvciBhbiBhcnJheSB3aXRoXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RzIG9yIGlkcyB0byBiZSByZW1vdmVkXG4gKiBAcGFyYW0ge3N0cmluZ30gW3NlbmRlcklkXSBPcHRpb25hbCBzZW5kZXIgaWRcbiAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmd8bnVtYmVyPn0gcmVtb3ZlZElkc1xuICovXG5EYXRhU2V0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoaWQsIHNlbmRlcklkKSB7XG4gIHZhciByZW1vdmVkSWRzID0gW10sXG4gICAgICByZW1vdmVkSXRlbXMgPSBbXSxcbiAgICAgIGlkcyA9IFtdLFxuICAgICAgaSxcbiAgICAgIGxlbixcbiAgICAgIGl0ZW1JZCxcbiAgICAgIGl0ZW07XG5cbiAgLy8gZm9yY2UgZXZlcnl0aGluZyB0byBiZSBhbiBhcnJheSBmb3Igc2ltcGxpY2l0eVxuICBpZHMgPSBBcnJheS5pc0FycmF5KGlkKSA/IGlkIDogW2lkXTtcblxuICBmb3IgKGkgPSAwLCBsZW4gPSBpZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpdGVtID0gdGhpcy5fcmVtb3ZlKGlkc1tpXSk7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIGl0ZW1JZCA9IGl0ZW1bdGhpcy5fZmllbGRJZF07XG4gICAgICBpZiAoaXRlbUlkICE9IHVuZGVmaW5lZCkge1xuICAgICAgICByZW1vdmVkSWRzLnB1c2goaXRlbUlkKTtcbiAgICAgICAgcmVtb3ZlZEl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHJlbW92ZWRJZHMubGVuZ3RoKSB7XG4gICAgdGhpcy5fdHJpZ2dlcigncmVtb3ZlJywgeyBpdGVtczogcmVtb3ZlZElkcywgb2xkRGF0YTogcmVtb3ZlZEl0ZW1zIH0sIHNlbmRlcklkKTtcbiAgfVxuXG4gIHJldHVybiByZW1vdmVkSWRzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaXRlbSBieSBpdHMgaWRcbiAqIEBwYXJhbSB7bnVtYmVyIHwgc3RyaW5nIHwgT2JqZWN0fSBpZCAgIGlkIG9yIGl0ZW1cbiAqIEByZXR1cm5zIHtudW1iZXIgfCBzdHJpbmcgfCBudWxsfSBpZFxuICogQHByaXZhdGVcbiAqL1xuRGF0YVNldC5wcm90b3R5cGUuX3JlbW92ZSA9IGZ1bmN0aW9uIChpZCkge1xuICB2YXIgaXRlbSwgaWRlbnQ7XG5cbiAgLy8gY29uZmlybSB0aGUgaWQgdG8gdXNlIGJhc2VkIG9uIHRoZSBhcmdzIHR5cGVcbiAgaWYgKHV0aWwuaXNOdW1iZXIoaWQpIHx8IHV0aWwuaXNTdHJpbmcoaWQpKSB7XG4gICAgaWRlbnQgPSBpZDtcbiAgfSBlbHNlIGlmIChpZCAmJiAodHlwZW9mIGlkID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogKDAsIF90eXBlb2YzWydkZWZhdWx0J10pKGlkKSkgPT09ICdvYmplY3QnKSB7XG4gICAgaWRlbnQgPSBpZFt0aGlzLl9maWVsZElkXTsgLy8gbG9vayBmb3IgdGhlIGlkZW50aWZpZXIgZmllbGQgdXNpbmcgX2ZpZWxkSWRcbiAgfVxuXG4gIC8vIGRvIHRoZSByZW1vdmUgaWYgdGhlIGl0ZW0gaXMgZm91bmRcbiAgaWYgKGlkZW50ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fZGF0YVtpZGVudF0pIHtcbiAgICBpdGVtID0gdGhpcy5fZGF0YVtpZGVudF07XG4gICAgZGVsZXRlIHRoaXMuX2RhdGFbaWRlbnRdO1xuICAgIHRoaXMubGVuZ3RoLS07XG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIENsZWFyIHRoZSBkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gW3NlbmRlcklkXSBPcHRpb25hbCBzZW5kZXIgaWRcbiAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmd8bnVtYmVyPn0gcmVtb3ZlZElkcyAgICBUaGUgaWRzIG9mIGFsbCByZW1vdmVkIGl0ZW1zXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKHNlbmRlcklkKSB7XG4gIHZhciBpLCBsZW47XG4gIHZhciBpZHMgPSAoMCwgX2tleXMyWydkZWZhdWx0J10pKHRoaXMuX2RhdGEpO1xuICB2YXIgaXRlbXMgPSBbXTtcblxuICBmb3IgKGkgPSAwLCBsZW4gPSBpZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpdGVtcy5wdXNoKHRoaXMuX2RhdGFbaWRzW2ldXSk7XG4gIH1cblxuICB0aGlzLl9kYXRhID0ge307XG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICB0aGlzLl90cmlnZ2VyKCdyZW1vdmUnLCB7IGl0ZW1zOiBpZHMsIG9sZERhdGE6IGl0ZW1zIH0sIHNlbmRlcklkKTtcblxuICByZXR1cm4gaWRzO1xufTtcblxuLyoqXG4gKiBGaW5kIHRoZSBpdGVtIHdpdGggbWF4aW11bSB2YWx1ZSBvZiBhIHNwZWNpZmllZCBmaWVsZFxuICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkXG4gKiBAcmV0dXJuIHtPYmplY3QgfCBudWxsfSBpdGVtICBJdGVtIGNvbnRhaW5pbmcgbWF4IHZhbHVlLCBvciBudWxsIGlmIG5vIGl0ZW1zXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uIChmaWVsZCkge1xuICB2YXIgZGF0YSA9IHRoaXMuX2RhdGEsXG4gICAgICBpdGVtSWRzID0gKDAsIF9rZXlzMlsnZGVmYXVsdCddKShkYXRhKSxcbiAgICAgIG1heCA9IG51bGwsXG4gICAgICBtYXhGaWVsZCA9IG51bGwsXG4gICAgICBpLFxuICAgICAgbGVuO1xuXG4gIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1JZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgaWQgPSBpdGVtSWRzW2ldO1xuICAgIHZhciBpdGVtID0gZGF0YVtpZF07XG4gICAgdmFyIGl0ZW1GaWVsZCA9IGl0ZW1bZmllbGRdO1xuICAgIGlmIChpdGVtRmllbGQgIT0gbnVsbCAmJiAoIW1heCB8fCBpdGVtRmllbGQgPiBtYXhGaWVsZCkpIHtcbiAgICAgIG1heCA9IGl0ZW07XG4gICAgICBtYXhGaWVsZCA9IGl0ZW1GaWVsZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF4O1xufTtcblxuLyoqXG4gKiBGaW5kIHRoZSBpdGVtIHdpdGggbWluaW11bSB2YWx1ZSBvZiBhIHNwZWNpZmllZCBmaWVsZFxuICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkXG4gKiBAcmV0dXJuIHtPYmplY3QgfCBudWxsfSBpdGVtICBJdGVtIGNvbnRhaW5pbmcgbWF4IHZhbHVlLCBvciBudWxsIGlmIG5vIGl0ZW1zXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uIChmaWVsZCkge1xuICB2YXIgZGF0YSA9IHRoaXMuX2RhdGEsXG4gICAgICBpdGVtSWRzID0gKDAsIF9rZXlzMlsnZGVmYXVsdCddKShkYXRhKSxcbiAgICAgIG1pbiA9IG51bGwsXG4gICAgICBtaW5GaWVsZCA9IG51bGwsXG4gICAgICBpLFxuICAgICAgbGVuO1xuXG4gIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1JZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgaWQgPSBpdGVtSWRzW2ldO1xuICAgIHZhciBpdGVtID0gZGF0YVtpZF07XG4gICAgdmFyIGl0ZW1GaWVsZCA9IGl0ZW1bZmllbGRdO1xuICAgIGlmIChpdGVtRmllbGQgIT0gbnVsbCAmJiAoIW1pbiB8fCBpdGVtRmllbGQgPCBtaW5GaWVsZCkpIHtcbiAgICAgIG1pbiA9IGl0ZW07XG4gICAgICBtaW5GaWVsZCA9IGl0ZW1GaWVsZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWluO1xufTtcblxuLyoqXG4gKiBGaW5kIGFsbCBkaXN0aW5jdCB2YWx1ZXMgb2YgYSBzcGVjaWZpZWQgZmllbGRcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7QXJyYXl9IHZhbHVlcyAgQXJyYXkgY29udGFpbmluZyBhbGwgZGlzdGluY3QgdmFsdWVzLiBJZiBkYXRhIGl0ZW1zXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICBkbyBub3QgY29udGFpbiB0aGUgc3BlY2lmaWVkIGZpZWxkIGFyZSBpZ25vcmVkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgVGhlIHJldHVybmVkIGFycmF5IGlzIHVub3JkZXJlZC5cbiAqL1xuRGF0YVNldC5wcm90b3R5cGUuZGlzdGluY3QgPSBmdW5jdGlvbiAoZmllbGQpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuICB2YXIgaXRlbUlkcyA9ICgwLCBfa2V5czJbJ2RlZmF1bHQnXSkoZGF0YSk7XG4gIHZhciB2YWx1ZXMgPSBbXTtcbiAgdmFyIGZpZWxkVHlwZSA9IHRoaXMuX29wdGlvbnMudHlwZSAmJiB0aGlzLl9vcHRpb25zLnR5cGVbZmllbGRdIHx8IG51bGw7XG4gIHZhciBjb3VudCA9IDA7XG4gIHZhciBpLCBqLCBsZW47XG5cbiAgZm9yIChpID0gMCwgbGVuID0gaXRlbUlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBpZCA9IGl0ZW1JZHNbaV07XG4gICAgdmFyIGl0ZW0gPSBkYXRhW2lkXTtcbiAgICB2YXIgdmFsdWUgPSBpdGVtW2ZpZWxkXTtcbiAgICB2YXIgZXhpc3RzID0gZmFsc2U7XG4gICAgZm9yIChqID0gMDsgaiA8IGNvdW50OyBqKyspIHtcbiAgICAgIGlmICh2YWx1ZXNbal0gPT0gdmFsdWUpIHtcbiAgICAgICAgZXhpc3RzID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZXhpc3RzICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbHVlc1tjb3VudF0gPSB2YWx1ZTtcbiAgICAgIGNvdW50Kys7XG4gICAgfVxuICB9XG5cbiAgaWYgKGZpZWxkVHlwZSkge1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IHZhbHVlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFsdWVzW2ldID0gdXRpbC5jb252ZXJ0KHZhbHVlc1tpXSwgZmllbGRUeXBlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsdWVzO1xufTtcblxuLyoqXG4gKiBBZGQgYSBzaW5nbGUgaXRlbS4gV2lsbCBmYWlsIHdoZW4gYW4gaXRlbSB3aXRoIHRoZSBzYW1lIGlkIGFscmVhZHkgZXhpc3RzLlxuICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cbiAqIEByZXR1cm4ge3N0cmluZ30gaWRcbiAqIEBwcml2YXRlXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLl9hZGRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgdmFyIGlkID0gaXRlbVt0aGlzLl9maWVsZElkXTtcblxuICBpZiAoaWQgIT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gY2hlY2sgd2hldGhlciB0aGlzIGlkIGlzIGFscmVhZHkgdGFrZW5cbiAgICBpZiAodGhpcy5fZGF0YVtpZF0pIHtcbiAgICAgIC8vIGl0ZW0gYWxyZWFkeSBleGlzdHNcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFkZCBpdGVtOiBpdGVtIHdpdGggaWQgJyArIGlkICsgJyBhbHJlYWR5IGV4aXN0cycpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBnZW5lcmF0ZSBhbiBpZFxuICAgIGlkID0gdXRpbC5yYW5kb21VVUlEKCk7XG4gICAgaXRlbVt0aGlzLl9maWVsZElkXSA9IGlkO1xuICB9XG5cbiAgdmFyIGQgPSB7fSxcbiAgICAgIGZpZWxkcyA9ICgwLCBfa2V5czJbJ2RlZmF1bHQnXSkoaXRlbSksXG4gICAgICBpLFxuICAgICAgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBmaWVsZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgZmllbGQgPSBmaWVsZHNbaV07XG4gICAgdmFyIGZpZWxkVHlwZSA9IHRoaXMuX3R5cGVbZmllbGRdOyAvLyB0eXBlIG1heSBiZSB1bmRlZmluZWRcbiAgICBkW2ZpZWxkXSA9IHV0aWwuY29udmVydChpdGVtW2ZpZWxkXSwgZmllbGRUeXBlKTtcbiAgfVxuICB0aGlzLl9kYXRhW2lkXSA9IGQ7XG4gIHRoaXMubGVuZ3RoKys7XG5cbiAgcmV0dXJuIGlkO1xufTtcblxuLyoqXG4gKiBHZXQgYW4gaXRlbS4gRmllbGRzIGNhbiBiZSBjb252ZXJ0ZWQgdG8gYSBzcGVjaWZpYyB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIHN0cmluZz59IFt0eXBlc10gIGZpZWxkIHR5cGVzIHRvIGNvbnZlcnRcbiAqIEByZXR1cm4ge09iamVjdCB8IG51bGx9IGl0ZW1cbiAqIEBwcml2YXRlXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLl9nZXRJdGVtID0gZnVuY3Rpb24gKGlkLCB0eXBlcykge1xuICB2YXIgZmllbGQsIHZhbHVlLCBpLCBsZW47XG5cbiAgLy8gZ2V0IHRoZSBpdGVtIGZyb20gdGhlIGRhdGFzZXRcbiAgdmFyIHJhdyA9IHRoaXMuX2RhdGFbaWRdO1xuICBpZiAoIXJhdykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gY29udmVydCB0aGUgaXRlbXMgZmllbGQgdHlwZXNcbiAgdmFyIGNvbnZlcnRlZCA9IHt9LFxuICAgICAgZmllbGRzID0gKDAsIF9rZXlzMlsnZGVmYXVsdCddKShyYXcpO1xuXG4gIGlmICh0eXBlcykge1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IGZpZWxkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgZmllbGQgPSBmaWVsZHNbaV07XG4gICAgICB2YWx1ZSA9IHJhd1tmaWVsZF07XG4gICAgICBjb252ZXJ0ZWRbZmllbGRdID0gdXRpbC5jb252ZXJ0KHZhbHVlLCB0eXBlc1tmaWVsZF0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBubyBmaWVsZCB0eXBlcyBzcGVjaWZpZWQsIG5vIGNvbnZlcnRpbmcgbmVlZGVkXG4gICAgZm9yIChpID0gMCwgbGVuID0gZmllbGRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBmaWVsZCA9IGZpZWxkc1tpXTtcbiAgICAgIHZhbHVlID0gcmF3W2ZpZWxkXTtcbiAgICAgIGNvbnZlcnRlZFtmaWVsZF0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbnZlcnRlZFt0aGlzLl9maWVsZElkXSkge1xuICAgIGNvbnZlcnRlZFt0aGlzLl9maWVsZElkXSA9IHJhdy5pZDtcbiAgfVxuXG4gIHJldHVybiBjb252ZXJ0ZWQ7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBhIHNpbmdsZSBpdGVtOiBtZXJnZSB3aXRoIGV4aXN0aW5nIGl0ZW0uXG4gKiBXaWxsIGZhaWwgd2hlbiB0aGUgaXRlbSBoYXMgbm8gaWQsIG9yIHdoZW4gdGhlcmUgZG9lcyBub3QgZXhpc3QgYW4gaXRlbVxuICogd2l0aCB0aGUgc2FtZSBpZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGlkXG4gKiBAcHJpdmF0ZVxuICovXG5EYXRhU2V0LnByb3RvdHlwZS5fdXBkYXRlSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIHZhciBpZCA9IGl0ZW1bdGhpcy5fZmllbGRJZF07XG4gIGlmIChpZCA9PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1cGRhdGUgaXRlbTogaXRlbSBoYXMgbm8gaWQgKGl0ZW06ICcgKyAoMCwgX3N0cmluZ2lmeTJbJ2RlZmF1bHQnXSkoaXRlbSkgKyAnKScpO1xuICB9XG4gIHZhciBkID0gdGhpcy5fZGF0YVtpZF07XG4gIGlmICghZCkge1xuICAgIC8vIGl0ZW0gZG9lc24ndCBleGlzdFxuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVwZGF0ZSBpdGVtOiBubyBpdGVtIHdpdGggaWQgJyArIGlkICsgJyBmb3VuZCcpO1xuICB9XG5cbiAgLy8gbWVyZ2Ugd2l0aCBjdXJyZW50IGl0ZW1cbiAgdmFyIGZpZWxkcyA9ICgwLCBfa2V5czJbJ2RlZmF1bHQnXSkoaXRlbSk7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBmaWVsZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgZmllbGQgPSBmaWVsZHNbaV07XG4gICAgdmFyIGZpZWxkVHlwZSA9IHRoaXMuX3R5cGVbZmllbGRdOyAvLyB0eXBlIG1heSBiZSB1bmRlZmluZWRcbiAgICBkW2ZpZWxkXSA9IHV0aWwuY29udmVydChpdGVtW2ZpZWxkXSwgZmllbGRUeXBlKTtcbiAgfVxuXG4gIHJldHVybiBpZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVNldDtcblxuLyoqKi8gfSksXG4vKiAzNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgTGFiZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc3KVsnZGVmYXVsdCddO1xudmFyIENvbXBvbmVudFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KVsnZGVmYXVsdCddO1xudmFyIEJveCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQ0KVsnZGVmYXVsdCddO1xudmFyIENpcmNsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTUxKVsnZGVmYXVsdCddO1xudmFyIENpcmN1bGFySW1hZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1MilbJ2RlZmF1bHQnXTtcbnZhciBEYXRhYmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTUzKVsnZGVmYXVsdCddO1xudmFyIERpYW1vbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1NClbJ2RlZmF1bHQnXTtcbnZhciBEb3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1NSlbJ2RlZmF1bHQnXTtcbnZhciBFbGxpcHNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTYpWydkZWZhdWx0J107XG52YXIgSWNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTU3KVsnZGVmYXVsdCddO1xudmFyIEltYWdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTgpWydkZWZhdWx0J107XG52YXIgU3F1YXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTkpWydkZWZhdWx0J107XG52YXIgSGV4YWdvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTYwKVsnZGVmYXVsdCddO1xudmFyIFN0YXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2MSlbJ2RlZmF1bHQnXTtcbnZhciBUZXh0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjIpWydkZWZhdWx0J107XG52YXIgVHJpYW5nbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2MylbJ2RlZmF1bHQnXTtcbnZhciBUcmlhbmdsZURvd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2NClbJ2RlZmF1bHQnXTtcblxudmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NCksXG4gICAgcHJpbnRTdHlsZSA9IF9yZXF1aXJlLnByaW50U3R5bGU7XG5cbi8qKlxuICogQSBub2RlLiBBIG5vZGUgY2FuIGJlIGNvbm5lY3RlZCB0byBvdGhlciBub2RlcyB2aWEgb25lIG9yIG11bHRpcGxlIGVkZ2VzLlxuICovXG5cblxudmFyIE5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBBbiBvYmplY3QgY29udGFpbmluZyBvcHRpb25zIGZvciB0aGUgbm9kZS4gQWxsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgYXJlIG9wdGlvbmFsLCBleGNlcHQgZm9yIHRoZSBpZC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bnVtYmVyfSBpZCAgICAgSWQgb2YgdGhlIG5vZGUuIFJlcXVpcmVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3N0cmluZ30gbGFiZWwgIFRleHQgbGFiZWwgZm9yIHRoZSBub2RlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge251bWJlcn0geCAgICAgIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIG5vZGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bnVtYmVyfSB5ICAgICAgVmVydGljYWwgcG9zaXRpb24gb2YgdGhlIG5vZGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nfSBzaGFwZSAgTm9kZSBzaGFwZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzdHJpbmd9IGltYWdlICBBbiBpbWFnZSB1cmxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nfSB0aXRsZSAgQSB0aXRsZSB0ZXh0LCBjYW4gYmUgSFRNTFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHthbnl0eXBlfSBncm91cCBBIGdyb3VwIG5hbWUgb3IgbnVtYmVyXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5ICAgICAgICAgICAgICAgU2hhcmVkIHN0YXRlIG9mIGN1cnJlbnQgbmV0d29yayBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge05ldHdvcmsuSW1hZ2VzfSBpbWFnZWxpc3QgIEEgbGlzdCB3aXRoIGltYWdlcy4gT25seSBuZWVkZWQgd2hlbiB0aGUgbm9kZSBoYXMgYW4gaW1hZ2VcbiAgICogQHBhcmFtIHtHcm91cHN9IGdyb3VwbGlzdCAgICAgICAgICBBIGxpc3Qgd2l0aCBncm91cHMuIE5lZWRlZCBmb3IgcmV0cmlldmluZyBncm91cCBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBnbG9iYWxPcHRpb25zICAgICAgQ3VycmVudCBnbG9iYWwgbm9kZSBvcHRpb25zOyB0aGVzZSBzZXJ2ZSBhcyBkZWZhdWx0cyBmb3IgdGhlIG5vZGUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRPcHRpb25zICAgICBHbG9iYWwgZGVmYXVsdCBvcHRpb25zIGZvciBub2Rlczsgbm90ZSB0aGF0IHRoaXMgaXMgYWxzbyB0aGUgcHJvdG90eXBlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIHBhcmFtZXRlciBgZ2xvYmFsT3B0aW9uc2AuXG4gICAqL1xuICBmdW5jdGlvbiBOb2RlKG9wdGlvbnMsIGJvZHksIGltYWdlbGlzdCwgZ3JvdXBsaXN0LCBnbG9iYWxPcHRpb25zLCBkZWZhdWx0T3B0aW9ucykge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIE5vZGUpO1xuXG4gICAgdGhpcy5vcHRpb25zID0gdXRpbC5icmlkZ2VPYmplY3QoZ2xvYmFsT3B0aW9ucyk7XG4gICAgdGhpcy5nbG9iYWxPcHRpb25zID0gZ2xvYmFsT3B0aW9ucztcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG4gICAgdGhpcy5ib2R5ID0gYm9keTtcblxuICAgIHRoaXMuZWRnZXMgPSBbXTsgLy8gYWxsIGVkZ2VzIGNvbm5lY3RlZCB0byB0aGlzIG5vZGVcblxuICAgIC8vIHNldCBkZWZhdWx0cyBmb3IgdGhlIG9wdGlvbnNcbiAgICB0aGlzLmlkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaW1hZ2VsaXN0ID0gaW1hZ2VsaXN0O1xuICAgIHRoaXMuZ3JvdXBsaXN0ID0gZ3JvdXBsaXN0O1xuXG4gICAgLy8gc3RhdGUgb3B0aW9uc1xuICAgIHRoaXMueCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5iYXNlU2l6ZSA9IHRoaXMub3B0aW9ucy5zaXplO1xuICAgIHRoaXMuYmFzZUZvbnRTaXplID0gdGhpcy5vcHRpb25zLmZvbnQuc2l6ZTtcbiAgICB0aGlzLnByZWRlZmluZWRQb3NpdGlvbiA9IGZhbHNlOyAvLyB1c2VkIHRvIGNoZWNrIGlmIGluaXRpYWwgZml0IHNob3VsZCBqdXN0IHRha2UgdGhlIHJhbmdlIG9yIGFwcHJveGltYXRlXG4gICAgdGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuaG92ZXIgPSBmYWxzZTtcblxuICAgIHRoaXMubGFiZWxNb2R1bGUgPSBuZXcgTGFiZWwodGhpcy5ib2R5LCB0aGlzLm9wdGlvbnMsIGZhbHNlIC8qIE5vdCBlZGdlIGxhYmVsICovXG4gICAgKTtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQXR0YWNoIGEgZWRnZSB0byB0aGUgbm9kZVxuICAgKiBAcGFyYW0ge0VkZ2V9IGVkZ2VcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzM1snZGVmYXVsdCddKShOb2RlLCBbe1xuICAgIGtleTogJ2F0dGFjaEVkZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRhY2hFZGdlKGVkZ2UpIHtcbiAgICAgIGlmICh0aGlzLmVkZ2VzLmluZGV4T2YoZWRnZSkgPT09IC0xKSB7XG4gICAgICAgIHRoaXMuZWRnZXMucHVzaChlZGdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRhY2ggYSBlZGdlIGZyb20gdGhlIG5vZGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWRnZX0gZWRnZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkZXRhY2hFZGdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGV0YWNoRWRnZShlZGdlKSB7XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLmVkZ2VzLmluZGV4T2YoZWRnZSk7XG4gICAgICBpZiAoaW5kZXggIT0gLTEpIHtcbiAgICAgICAgdGhpcy5lZGdlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBvciBvdmVyd3JpdGUgb3B0aW9ucyBmb3IgdGhlIG5vZGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIGFuIG9iamVjdCB3aXRoIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7bnVsbHxib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRPcHRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB2YXIgY3VycmVudFNoYXBlID0gdGhpcy5vcHRpb25zLnNoYXBlO1xuICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIHJldHVybjsgLy8gTm90ZSB0aGF0IHRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSAndW5kZWZpbmVkJyEgVGhpcyBpcyBPSy5cbiAgICAgIH1cblxuICAgICAgLy8gYmFzaWMgb3B0aW9uc1xuICAgICAgaWYgKG9wdGlvbnMuaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmlkID0gb3B0aW9ucy5pZDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vZGUgbXVzdCBoYXZlIGFuIGlkJyk7XG4gICAgICB9XG5cbiAgICAgIE5vZGUuY2hlY2tNYXNzKG9wdGlvbnMsIHRoaXMuaWQpO1xuXG4gICAgICAvLyBzZXQgdGhlc2Ugb3B0aW9ucyBsb2NhbGx5XG4gICAgICAvLyBjbGVhciB4IGFuZCB5IHBvc2l0aW9uc1xuICAgICAgaWYgKG9wdGlvbnMueCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnggPT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgdGhpcy5wcmVkZWZpbmVkUG9zaXRpb24gPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnggPSBwYXJzZUludChvcHRpb25zLngpO1xuICAgICAgICAgIHRoaXMucHJlZGVmaW5lZFBvc2l0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMueSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnkgPT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgdGhpcy5wcmVkZWZpbmVkUG9zaXRpb24gPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnkgPSBwYXJzZUludChvcHRpb25zLnkpO1xuICAgICAgICAgIHRoaXMucHJlZGVmaW5lZFBvc2l0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuYmFzZVNpemUgPSBvcHRpb25zLnNpemU7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMudmFsdWUgPSBwYXJzZUZsb2F0KG9wdGlvbnMudmFsdWUpO1xuICAgICAgfVxuXG4gICAgICAvLyB0aGlzIHRyYW5zZm9ybXMgYWxsIHNob3J0aGFuZHMgaW50byBmdWxseSBkZWZpbmVkIG9wdGlvbnNcbiAgICAgIE5vZGUucGFyc2VPcHRpb25zKHRoaXMub3B0aW9ucywgb3B0aW9ucywgdHJ1ZSwgdGhpcy5nbG9iYWxPcHRpb25zLCB0aGlzLmdyb3VwbGlzdCk7XG5cbiAgICAgIHZhciBwaWxlID0gW29wdGlvbnMsIHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9uc107XG4gICAgICB0aGlzLmNob29zZXIgPSBDb21wb25lbnRVdGlsLmNob29zaWZ5KCdub2RlJywgcGlsZSk7XG5cbiAgICAgIHRoaXMuX2xvYWRfaW1hZ2VzKCk7XG4gICAgICB0aGlzLnVwZGF0ZUxhYmVsTW9kdWxlKG9wdGlvbnMpO1xuICAgICAgdGhpcy51cGRhdGVTaGFwZShjdXJyZW50U2hhcGUpO1xuXG4gICAgICByZXR1cm4gb3B0aW9ucy5oaWRkZW4gIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnBoeXNpY3MgIT09IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkIHRoZSBpbWFnZXMgZnJvbSB0aGUgb3B0aW9ucywgZm9yIHRoZSBub2RlcyB0aGF0IG5lZWQgdGhlbS5cbiAgICAgKlxuICAgICAqIEltYWdlcyBhcmUgYWx3YXlzIGxvYWRlZCwgZXZlbiBpZiB0aGV5IGFyZSBub3QgdXNlZCBpbiB0aGUgY3VycmVudCBzaGFwZS5cbiAgICAgKiBUaGUgdXNlciBtYXkgc3dpdGNoIHRvIGFuIGltYWdlIHNoYXBlIGxhdGVyIG9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2xvYWRfaW1hZ2VzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2xvYWRfaW1hZ2VzKCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaGFwZSA9PT0gJ2NpcmN1bGFySW1hZ2UnIHx8IHRoaXMub3B0aW9ucy5zaGFwZSA9PT0gJ2ltYWdlJykge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmltYWdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPcHRpb24gaW1hZ2UgbXVzdCBiZSBkZWZpbmVkIGZvciBub2RlIHR5cGUgJ1wiICsgdGhpcy5vcHRpb25zLnNoYXBlICsgXCInXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW1hZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmltYWdlbGlzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW50ZXJuYWwgRXJyb3I6IE5vIGltYWdlcyBwcm92aWRlZCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5pbWFnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5pbWFnZU9iaiA9IHRoaXMuaW1hZ2VsaXN0LmxvYWQodGhpcy5vcHRpb25zLmltYWdlLCB0aGlzLm9wdGlvbnMuYnJva2VuSW1hZ2UsIHRoaXMuaWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbWFnZS51bnNlbGVjdGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHVuc2VsZWN0ZWQgaW1hZ2UgcHJvdmlkZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW1hZ2VPYmogPSB0aGlzLmltYWdlbGlzdC5sb2FkKHRoaXMub3B0aW9ucy5pbWFnZS51bnNlbGVjdGVkLCB0aGlzLm9wdGlvbnMuYnJva2VuSW1hZ2UsIHRoaXMuaWQpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW1hZ2Uuc2VsZWN0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuaW1hZ2VPYmpBbHQgPSB0aGlzLmltYWdlbGlzdC5sb2FkKHRoaXMub3B0aW9ucy5pbWFnZS5zZWxlY3RlZCwgdGhpcy5vcHRpb25zLmJyb2tlbkltYWdlLCB0aGlzLmlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmltYWdlT2JqQWx0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29weSBncm91cCBvcHRpb24gdmFsdWVzIGludG8gdGhlIG5vZGUgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIFRoZSBncm91cCBvcHRpb25zIG92ZXJyaWRlIHRoZSBnbG9iYWwgbm9kZSBvcHRpb25zLCBzbyB0aGUgY29weSBvZiBncm91cCBvcHRpb25zXG4gICAgICogIG11c3QgaGFwcGVuICphZnRlciogdGhlIGdsb2JhbCBub2RlIG9wdGlvbnMgaGF2ZSBiZWVuIHNldC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG11c3QgYWxzbyBiZSBjYWxsZWQgYWxzbyBpZiB0aGUgZ2xvYmFsIG5vZGUgb3B0aW9ucyBoYXZlIGNoYW5nZWQgYW5kIHRoZSBncm91cCBvcHRpb25zIGRpZCBub3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyZW50T3B0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdPcHRpb25zICBuZXcgdmFsdWVzIGZvciB0aGUgb3B0aW9ucywgY3VycmVudGx5IG9ubHkgcGFzc2VkIGluIGZvciBjaGVja1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBncm91cExpc3RcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0Rm9ybWF0dGluZ1ZhbHVlcycsXG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybnMge3tjb2xvcjogKiwgYm9yZGVyV2lkdGg6ICosIGJvcmRlckNvbG9yOiAqLCBzaXplOiAqLCBib3JkZXJEYXNoZXM6IChib29sZWFufEFycmF5fGFsbE9wdGlvbnMubm9kZXMuc2hhcGVQcm9wZXJ0aWVzLmJvcmRlckRhc2hlc3x7Ym9vbGVhbiwgYXJyYXl9KSwgYm9yZGVyUmFkaXVzOiAobnVtYmVyfGFsbE9wdGlvbnMubm9kZXMuc2hhcGVQcm9wZXJ0aWVzLmJvcmRlclJhZGl1c3x7bnVtYmVyfXxBcnJheSksIHNoYWRvdzogKiwgc2hhZG93Q29sb3I6ICosIHNoYWRvd1NpemU6ICosIHNoYWRvd1g6ICosIHNoYWRvd1k6ICp9fVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGb3JtYXR0aW5nVmFsdWVzKCkge1xuICAgICAgdmFyIHZhbHVlcyA9IHtcbiAgICAgICAgY29sb3I6IHRoaXMub3B0aW9ucy5jb2xvci5iYWNrZ3JvdW5kLFxuICAgICAgICBib3JkZXJXaWR0aDogdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoLFxuICAgICAgICBib3JkZXJDb2xvcjogdGhpcy5vcHRpb25zLmNvbG9yLmJvcmRlcixcbiAgICAgICAgc2l6ZTogdGhpcy5vcHRpb25zLnNpemUsXG4gICAgICAgIGJvcmRlckRhc2hlczogdGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5ib3JkZXJEYXNoZXMsXG4gICAgICAgIGJvcmRlclJhZGl1czogdGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5ib3JkZXJSYWRpdXMsXG4gICAgICAgIHNoYWRvdzogdGhpcy5vcHRpb25zLnNoYWRvdy5lbmFibGVkLFxuICAgICAgICBzaGFkb3dDb2xvcjogdGhpcy5vcHRpb25zLnNoYWRvdy5jb2xvcixcbiAgICAgICAgc2hhZG93U2l6ZTogdGhpcy5vcHRpb25zLnNoYWRvdy5zaXplLFxuICAgICAgICBzaGFkb3dYOiB0aGlzLm9wdGlvbnMuc2hhZG93LngsXG4gICAgICAgIHNoYWRvd1k6IHRoaXMub3B0aW9ucy5zaGFkb3cueVxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkIHx8IHRoaXMuaG92ZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hvb3NlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICB2YWx1ZXMuYm9yZGVyV2lkdGggKj0gMjtcbiAgICAgICAgICAgIHZhbHVlcy5jb2xvciA9IHRoaXMub3B0aW9ucy5jb2xvci5oaWdobGlnaHQuYmFja2dyb3VuZDtcbiAgICAgICAgICAgIHZhbHVlcy5ib3JkZXJDb2xvciA9IHRoaXMub3B0aW9ucy5jb2xvci5oaWdobGlnaHQuYm9yZGVyO1xuICAgICAgICAgICAgdmFsdWVzLnNoYWRvdyA9IHRoaXMub3B0aW9ucy5zaGFkb3cuZW5hYmxlZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaG92ZXIpIHtcbiAgICAgICAgICAgIHZhbHVlcy5jb2xvciA9IHRoaXMub3B0aW9ucy5jb2xvci5ob3Zlci5iYWNrZ3JvdW5kO1xuICAgICAgICAgICAgdmFsdWVzLmJvcmRlckNvbG9yID0gdGhpcy5vcHRpb25zLmNvbG9yLmhvdmVyLmJvcmRlcjtcbiAgICAgICAgICAgIHZhbHVlcy5zaGFkb3cgPSB0aGlzLm9wdGlvbnMuc2hhZG93LmVuYWJsZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLmNob29zZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzLmNob29zZXIodmFsdWVzLCB0aGlzLm9wdGlvbnMuaWQsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIpO1xuICAgICAgICAgIGlmICh2YWx1ZXMuc2hhZG93ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlcy5zaGFkb3dDb2xvciAhPT0gdGhpcy5vcHRpb25zLnNoYWRvdy5jb2xvciB8fCB2YWx1ZXMuc2hhZG93U2l6ZSAhPT0gdGhpcy5vcHRpb25zLnNoYWRvdy5zaXplIHx8IHZhbHVlcy5zaGFkb3dYICE9PSB0aGlzLm9wdGlvbnMuc2hhZG93LnggfHwgdmFsdWVzLnNoYWRvd1kgIT09IHRoaXMub3B0aW9ucy5zaGFkb3cueSkge1xuICAgICAgICAgICAgICB2YWx1ZXMuc2hhZG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlcy5zaGFkb3cgPSB0aGlzLm9wdGlvbnMuc2hhZG93LmVuYWJsZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlTGFiZWxNb2R1bGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVMYWJlbE1vZHVsZShvcHRpb25zKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxhYmVsID09PSB1bmRlZmluZWQgfHwgdGhpcy5vcHRpb25zLmxhYmVsID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5sYWJlbCA9ICcnO1xuICAgICAgfVxuXG4gICAgICBOb2RlLnVwZGF0ZUdyb3VwT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMsIHRoaXMuZ3JvdXBsaXN0KTtcblxuICAgICAgLy9cbiAgICAgIC8vIE5vdGU6VGhlIHByb3RvdHlwZSBjaGFpbiBmb3IgdGhpcy5vcHRpb25zIGlzOlxuICAgICAgLy9cbiAgICAgIC8vIHRoaXMub3B0aW9ucyAtPiAgICBOb2Rlc0hhbmRsZXIub3B0aW9ucyAgICAtPiBOb2Rlc0hhbmRsZXIuZGVmYXVsdE9wdGlvbnNcbiAgICAgIC8vICAgICAgICAgICAgICAgICAoYWxzbzogdGhpcy5nbG9iYWxPcHRpb25zKVxuICAgICAgLy9cbiAgICAgIC8vIE5vdGUgdGhhdCB0aGUgcHJvdG90eXBlcyBhcmUgbWVudGlvbmVkIGV4cGxpY2l0bHkgaW4gdGhlIHBpbGUgbGlzdCBiZWxvdztcbiAgICAgIC8vIFdFIERPTidUIFdBTlQgVEhFIE9SREVSIE9GIFRIRSBQUk9UT1RZUEVTISEhISBBdCBsZWFzdCwgbm90IGZvciBmb250IGhhbmRsaW5nIG9mIGxhYmVscy5cbiAgICAgIC8vIFRoaXMgaXMgYSBnb29kIGluZGljYXRpb24gdGhhdCB0aGUgcHJvdG90eXBlIHVzYWdlIG9mIG9wdGlvbnMgaXMgZGVmaWNpZW50LlxuICAgICAgLy9cbiAgICAgIHZhciBjdXJyZW50R3JvdXAgPSB0aGlzLmdyb3VwbGlzdC5nZXQodGhpcy5vcHRpb25zLmdyb3VwLCBmYWxzZSk7XG4gICAgICB2YXIgcGlsZSA9IFtvcHRpb25zLCAvLyBuZXcgb3B0aW9uc1xuICAgICAgdGhpcy5vcHRpb25zLCAvLyBjdXJyZW50IG5vZGUgb3B0aW9ucywgc2VlIGNvbW1lbnQgYWJvdmUgZm9yIHByb3RvdHlwZVxuICAgICAgY3VycmVudEdyb3VwLCAvLyBncm91cCBvcHRpb25zLCBpZiBhbnlcbiAgICAgIHRoaXMuZ2xvYmFsT3B0aW9ucywgLy8gQ3VycmVudGx5IHNldCBnbG9iYWwgbm9kZSBvcHRpb25zXG4gICAgICB0aGlzLmRlZmF1bHRPcHRpb25zIC8vIERlZmF1bHQgZ2xvYmFsIG5vZGUgb3B0aW9uc1xuICAgICAgXTtcbiAgICAgIHRoaXMubGFiZWxNb2R1bGUudXBkYXRlKHRoaXMub3B0aW9ucywgcGlsZSk7XG5cbiAgICAgIGlmICh0aGlzLmxhYmVsTW9kdWxlLmJhc2VTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5iYXNlRm9udFNpemUgPSB0aGlzLmxhYmVsTW9kdWxlLmJhc2VTaXplO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGN1cnJlbnRTaGFwZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVTaGFwZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVNoYXBlKGN1cnJlbnRTaGFwZSkge1xuICAgICAgaWYgKGN1cnJlbnRTaGFwZSA9PT0gdGhpcy5vcHRpb25zLnNoYXBlICYmIHRoaXMuc2hhcGUpIHtcbiAgICAgICAgdGhpcy5zaGFwZS5zZXRPcHRpb25zKHRoaXMub3B0aW9ucywgdGhpcy5pbWFnZU9iaiwgdGhpcy5pbWFnZU9iakFsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjaG9vc2UgZHJhdyBtZXRob2QgZGVwZW5kaW5nIG9uIHRoZSBzaGFwZVxuICAgICAgICBzd2l0Y2ggKHRoaXMub3B0aW9ucy5zaGFwZSkge1xuICAgICAgICAgIGNhc2UgJ2JveCc6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IEJveCh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdjaXJjbGUnOlxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBDaXJjbGUodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnY2lyY3VsYXJJbWFnZSc6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IENpcmN1bGFySW1hZ2UodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUsIHRoaXMuaW1hZ2VPYmosIHRoaXMuaW1hZ2VPYmpBbHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZGF0YWJhc2UnOlxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBEYXRhYmFzZSh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdkaWFtb25kJzpcbiAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgRGlhbW9uZCh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdkb3QnOlxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBEb3QodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZWxsaXBzZSc6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IEVsbGlwc2UodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnaWNvbic6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IEljb24odGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBJbWFnZSh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSwgdGhpcy5pbWFnZU9iaiwgdGhpcy5pbWFnZU9iakFsdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdzcXVhcmUnOlxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBTcXVhcmUodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnaGV4YWdvbic6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IEhleGFnb24odGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc3Rhcic6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IFN0YXIodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IFRleHQodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndHJpYW5nbGUnOlxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBUcmlhbmdsZSh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd0cmlhbmdsZURvd24nOlxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBUcmlhbmdsZURvd24odGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgRWxsaXBzZSh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5uZWVkc1JlZnJlc2goKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZWxlY3QgdGhpcyBub2RlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NlbGVjdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdCgpIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5uZWVkc1JlZnJlc2goKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB1bnNlbGVjdCB0aGlzIG5vZGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndW5zZWxlY3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnNlbGVjdCgpIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMubmVlZHNSZWZyZXNoKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIGNhbGN1bGF0ZWQgc2l6ZSBvZiB0aGUgbm9kZSwgZm9yY2VzIGl0IHRvIHJlY2FsY3VsYXRlIGl0cyBzaXplXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ25lZWRzUmVmcmVzaCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5lZWRzUmVmcmVzaCgpIHtcbiAgICAgIHRoaXMuc2hhcGUucmVmcmVzaE5lZWRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSB0aXRsZSBvZiB0aGlzIG5vZGUuXG4gICAgICogQHJldHVybiB7c3RyaW5nfSB0aXRsZSAgICBUaGUgdGl0bGUgb2YgdGhlIG5vZGUsIG9yIHVuZGVmaW5lZCB3aGVuIG5vIHRpdGxlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBoYXMgYmVlbiBzZXQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldFRpdGxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGl0bGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnRpdGxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgdG8gdGhlIGJvcmRlciBvZiB0aGUgTm9kZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAgIGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSAgICAgICAgQW5nbGUgaW4gcmFkaWFuc1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IGRpc3RhbmNlICAgRGlzdGFuY2UgdG8gdGhlIGJvcmRlciBpbiBwaXhlbHNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZGlzdGFuY2VUb0JvcmRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2hhcGUuZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGlzIG5vZGUgaGFzIGEgZml4ZWQgeCBhbmQgeSBwb3NpdGlvblxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59ICAgICAgdHJ1ZSBpZiBmaXhlZCwgZmFsc2UgaWYgbm90XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2lzRml4ZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0ZpeGVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5maXhlZC54ICYmIHRoaXMub3B0aW9ucy5maXhlZC55O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNoZWNrIGlmIHRoaXMgbm9kZSBpcyBzZWxlY3RlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gc2VsZWN0ZWQgICBUcnVlIGlmIG5vZGUgaXMgc2VsZWN0ZWQsIGVsc2UgZmFsc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaXNTZWxlY3RlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzU2VsZWN0ZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgdmFsdWUgb2YgdGhlIG5vZGUuIENhbiBiZSB1bmRlZmluZWRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IHZhbHVlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldFZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBkaW1lbnNpb25zIG9mIHRoZSBsYWJlbFxuICAgICAqXG4gICAgICogQHJldHVybiB7cmVjdH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0TGFiZWxTaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGFiZWxTaXplKCkge1xuICAgICAgcmV0dXJuIHRoaXMubGFiZWxNb2R1bGUuc2l6ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkanVzdCB0aGUgdmFsdWUgcmFuZ2Ugb2YgdGhlIG5vZGUuIFRoZSBub2RlIHdpbGwgYWRqdXN0IGl0J3Mgc2l6ZVxuICAgICAqIGJhc2VkIG9uIGl0cyB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b3RhbFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRWYWx1ZVJhbmdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VmFsdWVSYW5nZShtaW4sIG1heCwgdG90YWwpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLm9wdGlvbnMuc2NhbGluZy5jdXN0b21TY2FsaW5nRnVuY3Rpb24obWluLCBtYXgsIHRvdGFsLCB0aGlzLm9wdGlvbnMudmFsdWUpO1xuICAgICAgICB2YXIgc2l6ZURpZmYgPSB0aGlzLm9wdGlvbnMuc2NhbGluZy5tYXggLSB0aGlzLm9wdGlvbnMuc2NhbGluZy5taW47XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2NhbGluZy5sYWJlbC5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIGZvbnREaWZmID0gdGhpcy5vcHRpb25zLnNjYWxpbmcubGFiZWwubWF4IC0gdGhpcy5vcHRpb25zLnNjYWxpbmcubGFiZWwubWluO1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5mb250LnNpemUgPSB0aGlzLm9wdGlvbnMuc2NhbGluZy5sYWJlbC5taW4gKyBzY2FsZSAqIGZvbnREaWZmO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9ucy5zaXplID0gdGhpcy5vcHRpb25zLnNjYWxpbmcubWluICsgc2NhbGUgKiBzaXplRGlmZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5zaXplID0gdGhpcy5iYXNlU2l6ZTtcbiAgICAgICAgdGhpcy5vcHRpb25zLmZvbnQuc2l6ZSA9IHRoaXMuYmFzZUZvbnRTaXplO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZUxhYmVsTW9kdWxlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhdyB0aGlzIG5vZGUgaW4gdGhlIGdpdmVuIGNhbnZhc1xuICAgICAqIFRoZSAyZCBjb250ZXh0IG9mIGEgSFRNTCBjYW52YXMgY2FuIGJlIHJldHJpZXZlZCBieSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAgIGN0eFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkcmF3JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLmdldEZvcm1hdHRpbmdWYWx1ZXMoKTtcbiAgICAgIHRoaXMuc2hhcGUuZHJhdyhjdHgsIHRoaXMueCwgdGhpcy55LCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyLCB2YWx1ZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBzaGFwZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAgIGN0eFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVCb3VuZGluZ0JveCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kaW5nQm94KGN0eCkge1xuICAgICAgdGhpcy5zaGFwZS51cGRhdGVCb3VuZGluZ0JveCh0aGlzLngsIHRoaXMueSwgY3R4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWNhbGN1bGF0ZSB0aGUgc2l6ZSBvZiB0aGlzIG5vZGUgaW4gdGhlIGdpdmVuIGNhbnZhc1xuICAgICAqIFRoZSAyZCBjb250ZXh0IG9mIGEgSFRNTCBjYW52YXMgY2FuIGJlIHJldHJpZXZlZCBieSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAgIGN0eFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZXNpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoY3R4KSB7XG4gICAgICB2YXIgdmFsdWVzID0gdGhpcy5nZXRGb3JtYXR0aW5nVmFsdWVzKCk7XG4gICAgICB0aGlzLnNoYXBlLnJlc2l6ZShjdHgsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIsIHZhbHVlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIGFsbCB2aXN1YWwgZWxlbWVudHMgb2YgdGhpcyBub2RlIGluc3RhbmNlLCBpbiB3aGljaCB0aGUgZ2l2ZW5cbiAgICAgKiBwb2ludCBmYWxscyB3aXRoaW4gdGhlIGJvdW5kaW5nIHNoYXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtwb2ludH0gcG9pbnRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG5vZGVDbGlja0l0ZW18bm9kZUxhYmVsQ2xpY2tJdGVtPn0gbGlzdCB3aXRoIHRoZSBpdGVtcyB3aGljaCBhcmUgb24gdGhlIHBvaW50XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldEl0ZW1zT25Qb2ludCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEl0ZW1zT25Qb2ludChwb2ludCkge1xuICAgICAgdmFyIHJldCA9IFtdO1xuXG4gICAgICBpZiAodGhpcy5sYWJlbE1vZHVsZS52aXNpYmxlKCkpIHtcbiAgICAgICAgaWYgKENvbXBvbmVudFV0aWwucG9pbnRJblJlY3QodGhpcy5sYWJlbE1vZHVsZS5nZXRTaXplKCksIHBvaW50KSkge1xuICAgICAgICAgIHJldC5wdXNoKHsgbm9kZUlkOiB0aGlzLmlkLCBsYWJlbElkOiAwIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChDb21wb25lbnRVdGlsLnBvaW50SW5SZWN0KHRoaXMuc2hhcGUuYm91bmRpbmdCb3gsIHBvaW50KSkge1xuICAgICAgICByZXQucHVzaCh7IG5vZGVJZDogdGhpcy5pZCB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGlzIG9iamVjdCBpcyBvdmVybGFwcGluZyB3aXRoIHRoZSBwcm92aWRlZCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqICAgYW4gb2JqZWN0IHdpdGggcGFyYW1ldGVycyBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b21cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSAgICAgVHJ1ZSBpZiBsb2NhdGlvbiBpcyBsb2NhdGVkIG9uIG5vZGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaXNPdmVybGFwcGluZ1dpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc092ZXJsYXBwaW5nV2l0aChvYmopIHtcbiAgICAgIHJldHVybiB0aGlzLnNoYXBlLmxlZnQgPCBvYmoucmlnaHQgJiYgdGhpcy5zaGFwZS5sZWZ0ICsgdGhpcy5zaGFwZS53aWR0aCA+IG9iai5sZWZ0ICYmIHRoaXMuc2hhcGUudG9wIDwgb2JqLmJvdHRvbSAmJiB0aGlzLnNoYXBlLnRvcCArIHRoaXMuc2hhcGUuaGVpZ2h0ID4gb2JqLnRvcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGlzIG9iamVjdCBpcyBvdmVybGFwcGluZyB3aXRoIHRoZSBwcm92aWRlZCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqICAgYW4gb2JqZWN0IHdpdGggcGFyYW1ldGVycyBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b21cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSAgICAgVHJ1ZSBpZiBsb2NhdGlvbiBpcyBsb2NhdGVkIG9uIG5vZGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaXNCb3VuZGluZ0JveE92ZXJsYXBwaW5nV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzQm91bmRpbmdCb3hPdmVybGFwcGluZ1dpdGgob2JqKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaGFwZS5ib3VuZGluZ0JveC5sZWZ0IDwgb2JqLnJpZ2h0ICYmIHRoaXMuc2hhcGUuYm91bmRpbmdCb3gucmlnaHQgPiBvYmoubGVmdCAmJiB0aGlzLnNoYXBlLmJvdW5kaW5nQm94LnRvcCA8IG9iai5ib3R0b20gJiYgdGhpcy5zaGFwZS5ib3VuZGluZ0JveC5ib3R0b20gPiBvYmoudG9wO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIHZhbGlkIHZhbHVlcyBmb3IgbWFzc1xuICAgICAqXG4gICAgICogVGhlIG1hc3MgbWF5IG5vdCBiZSBuZWdhdGl2ZSBvciB6ZXJvLiBJZiBpdCBpcywgcmVzZXQgdG8gMVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IGlkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuXG4gIH1dLCBbe1xuICAgIGtleTogJ3VwZGF0ZUdyb3VwT3B0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUdyb3VwT3B0aW9ucyhwYXJlbnRPcHRpb25zLCBuZXdPcHRpb25zLCBncm91cExpc3QpIHtcbiAgICAgIGlmIChncm91cExpc3QgPT09IHVuZGVmaW5lZCkgcmV0dXJuOyAvLyBObyBncm91cHMsIG5vdGhpbmcgdG8gZG9cblxuICAgICAgdmFyIGdyb3VwID0gcGFyZW50T3B0aW9ucy5ncm91cDtcblxuICAgICAgLy8gcGFyYW5vaWE6IHRoZSBzZWxlY3RlZCBncm91cCBpcyBhbHJlYWR5IG1lcmdlZCBpbnRvIG5vZGUgb3B0aW9ucywgY2hlY2suXG4gICAgICBpZiAobmV3T3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIG5ld09wdGlvbnMuZ3JvdXAgIT09IHVuZGVmaW5lZCAmJiBncm91cCAhPT0gbmV3T3B0aW9ucy5ncm91cCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1cGRhdGVHcm91cE9wdGlvbnM6IGdyb3VwIHZhbHVlcyBpbiBvcHRpb25zIGRvbid0IG1hdGNoLlwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGhhc0dyb3VwID0gdHlwZW9mIGdyb3VwID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgZ3JvdXAgPT09ICdzdHJpbmcnICYmIGdyb3VwICE9ICcnO1xuICAgICAgaWYgKCFoYXNHcm91cCkgcmV0dXJuOyAvLyBjdXJyZW50IG5vZGUgaGFzIG5vIGdyb3VwLCBubyBuZWVkIHRvIG1lcmdlXG5cbiAgICAgIHZhciBncm91cE9iaiA9IGdyb3VwTGlzdC5nZXQoZ3JvdXApO1xuXG4gICAgICAvLyBTa2lwIG1lcmdpbmcgb2YgZ3JvdXAgZm9udCBvcHRpb25zIGludG8gcGFyZW50OyB0aGVzZSBhcmUgcmVxdWlyZWQgdG8gYmUgZGlzdGluY3QgZm9yIGxhYmVsc1xuICAgICAgLy8gQWxzbyBza2lwIG1lcmdpbiBvZiBjb2xvciBJRiBpdCBpcyBhbHJlYWR5IGRlZmluZWQgaW4gdGhlIG5vZGUgaXRzZWxmLiBUaGlzIGlzIHRvIGF2b2lkIHRoZSBjb2xvciBvZiB0aGVcbiAgICAgIC8vIGdyb3VwIG92ZXJyaWRpbmcgdGhlIGNvbG9yIHNldCBhdCB0aGUgbm9kZSBsZXZlbFxuICAgICAgLy8gVE9ETzogSXQgbWlnaHQgbm90IGJlIGEgZ29vZCBpZGVhIGVpdGhlciB0byBtZXJnZSB0aGUgcmVzdCBvZiB0aGUgb3B0aW9ucywgaW52ZXN0aWdhdGUgdGhpcy5cbiAgICAgIHZhciBza2lwUHJvcGVydGllcyA9IFsnZm9udCddO1xuICAgICAgaWYgKG5ld09wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBuZXdPcHRpb25zLmNvbG9yICE9PSB1bmRlZmluZWQgJiYgbmV3T3B0aW9ucy5jb2xvciAhPSBudWxsKSBza2lwUHJvcGVydGllcy5wdXNoKCdjb2xvcicpO1xuICAgICAgdXRpbC5zZWxlY3RpdmVOb3REZWVwRXh0ZW5kKHNraXBQcm9wZXJ0aWVzLCBwYXJlbnRPcHRpb25zLCBncm91cE9iaik7XG5cbiAgICAgIC8vIHRoZSBjb2xvciBvYmplY3QgbmVlZHMgdG8gYmUgY29tcGxldGVseSBkZWZpbmVkLlxuICAgICAgLy8gU2luY2UgZ3JvdXBzIGNhbiBwYXJ0aWFsbHkgb3ZlcndyaXRlIHRoZSBjb2xvcnMsIHdlIHBhcnNlIGl0IGFnYWluLCBqdXN0IGluIGNhc2UuXG4gICAgICBwYXJlbnRPcHRpb25zLmNvbG9yID0gdXRpbC5wYXJzZUNvbG9yKHBhcmVudE9wdGlvbnMuY29sb3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgcHJvY2VzcyBhbGwgcG9zc2libGUgc2hvcnRoYW5kcyBpbiB0aGUgbmV3IG9wdGlvbnMgYW5kIG1ha2VzIHN1cmUgdGhhdCB0aGUgcGFyZW50T3B0aW9ucyBhcmUgZnVsbHkgZGVmaW5lZC5cbiAgICAgKiBTdGF0aWMgc28gaXQgY2FuIGFsc28gYmUgdXNlZCBieSB0aGUgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnRPcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5ld09wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthbGxvd0RlbGV0aW9uPWZhbHNlXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZ2xvYmFsT3B0aW9ucz17fV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2dyb3VwTGlzdF1cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3BhcnNlT3B0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlT3B0aW9ucyhwYXJlbnRPcHRpb25zLCBuZXdPcHRpb25zKSB7XG4gICAgICB2YXIgYWxsb3dEZWxldGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgICB2YXIgZ2xvYmFsT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gICAgICB2YXIgZ3JvdXBMaXN0ID0gYXJndW1lbnRzWzRdO1xuXG4gICAgICB2YXIgZmllbGRzID0gWydjb2xvcicsICdmaXhlZCcsICdzaGFkb3cnXTtcbiAgICAgIHV0aWwuc2VsZWN0aXZlTm90RGVlcEV4dGVuZChmaWVsZHMsIHBhcmVudE9wdGlvbnMsIG5ld09wdGlvbnMsIGFsbG93RGVsZXRpb24pO1xuXG4gICAgICBOb2RlLmNoZWNrTWFzcyhuZXdPcHRpb25zKTtcblxuICAgICAgLy8gbWVyZ2UgdGhlIHNoYWRvdyBvcHRpb25zIGludG8gdGhlIHBhcmVudC5cbiAgICAgIHV0aWwubWVyZ2VPcHRpb25zKHBhcmVudE9wdGlvbnMsIG5ld09wdGlvbnMsICdzaGFkb3cnLCBnbG9iYWxPcHRpb25zKTtcblxuICAgICAgLy8gaW5kaXZpZHVhbCBzaGFwZSBuZXdPcHRpb25zXG4gICAgICBpZiAobmV3T3B0aW9ucy5jb2xvciAhPT0gdW5kZWZpbmVkICYmIG5ld09wdGlvbnMuY29sb3IgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHBhcnNlZENvbG9yID0gdXRpbC5wYXJzZUNvbG9yKG5ld09wdGlvbnMuY29sb3IpO1xuICAgICAgICB1dGlsLmZpbGxJZkRlZmluZWQocGFyZW50T3B0aW9ucy5jb2xvciwgcGFyc2VkQ29sb3IpO1xuICAgICAgfSBlbHNlIGlmIChhbGxvd0RlbGV0aW9uID09PSB0cnVlICYmIG5ld09wdGlvbnMuY29sb3IgPT09IG51bGwpIHtcbiAgICAgICAgcGFyZW50T3B0aW9ucy5jb2xvciA9IHV0aWwuYnJpZGdlT2JqZWN0KGdsb2JhbE9wdGlvbnMuY29sb3IpOyAvLyBzZXQgdGhlIG9iamVjdCBiYWNrIHRvIHRoZSBnbG9iYWwgb3B0aW9uc1xuICAgICAgfVxuXG4gICAgICAvLyBoYW5kbGUgdGhlIGZpeGVkIG9wdGlvbnNcbiAgICAgIGlmIChuZXdPcHRpb25zLmZpeGVkICE9PSB1bmRlZmluZWQgJiYgbmV3T3B0aW9ucy5maXhlZCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIG5ld09wdGlvbnMuZml4ZWQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgIHBhcmVudE9wdGlvbnMuZml4ZWQueCA9IG5ld09wdGlvbnMuZml4ZWQ7XG4gICAgICAgICAgcGFyZW50T3B0aW9ucy5maXhlZC55ID0gbmV3T3B0aW9ucy5maXhlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobmV3T3B0aW9ucy5maXhlZC54ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG5ld09wdGlvbnMuZml4ZWQueCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBwYXJlbnRPcHRpb25zLmZpeGVkLnggPSBuZXdPcHRpb25zLmZpeGVkLng7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZXdPcHRpb25zLmZpeGVkLnkgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgbmV3T3B0aW9ucy5maXhlZC55ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHBhcmVudE9wdGlvbnMuZml4ZWQueSA9IG5ld09wdGlvbnMuZml4ZWQueTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGFsbG93RGVsZXRpb24gPT09IHRydWUgJiYgbmV3T3B0aW9ucy5mb250ID09PSBudWxsKSB7XG4gICAgICAgIHBhcmVudE9wdGlvbnMuZm9udCA9IHV0aWwuYnJpZGdlT2JqZWN0KGdsb2JhbE9wdGlvbnMuZm9udCk7IC8vIHNldCB0aGUgb2JqZWN0IGJhY2sgdG8gdGhlIGdsb2JhbCBvcHRpb25zXG4gICAgICB9XG5cbiAgICAgIE5vZGUudXBkYXRlR3JvdXBPcHRpb25zKHBhcmVudE9wdGlvbnMsIG5ld09wdGlvbnMsIGdyb3VwTGlzdCk7XG5cbiAgICAgIC8vIGhhbmRsZSB0aGUgc2NhbGluZyBvcHRpb25zLCBzcGVjaWZpY2FsbHkgdGhlIGxhYmVsIHBhcnRcbiAgICAgIGlmIChuZXdPcHRpb25zLnNjYWxpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1dGlsLm1lcmdlT3B0aW9ucyhwYXJlbnRPcHRpb25zLnNjYWxpbmcsIG5ld09wdGlvbnMuc2NhbGluZywgJ2xhYmVsJywgZ2xvYmFsT3B0aW9ucy5zY2FsaW5nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjaGVja01hc3MnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja01hc3Mob3B0aW9ucywgaWQpIHtcbiAgICAgIGlmIChvcHRpb25zLm1hc3MgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLm1hc3MgPD0gMCkge1xuICAgICAgICB2YXIgc3RySWQgPSAnJztcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzdHJJZCA9ICcgaW4gbm9kZSBpZDogJyArIGlkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKCclY05lZ2F0aXZlIG9yIHplcm8gbWFzcyBkaXNhbGxvd2VkJyArIHN0cklkICsgJywgc2V0dGluZyBtYXNzIHRvIDEuJywgcHJpbnRTdHlsZSk7XG4gICAgICAgIG9wdGlvbnMubWFzcyA9IDE7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBOb2RlO1xufSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBOb2RlO1xuXG4vKioqLyB9KSxcbi8qIDM1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mMiA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbnZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIGNvbXBvbmVudHNcbiAqIEBjbGFzc1xuICovXG5cbnZhciBDb21wb25lbnRVdGlsID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb21wb25lbnRVdGlsKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIENvbXBvbmVudFV0aWwpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoQ29tcG9uZW50VXRpbCwgbnVsbCwgW3tcbiAgICBrZXk6ICdjaG9vc2lmeScsXG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgdmFsdWVzIHRvIHVzZSBmb3IgKHN1YilvcHRpb25zIG9mICdjaG9zZW4nLlxuICAgICAqXG4gICAgICogVGhpcyBvcHRpb24gaXMgZWl0aGVyIGEgYm9vbGVhbiBvciBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIHNob3VsZCBiZSBleGFtaW5lZCBmdXJ0aGVyLlxuICAgICAqIFRoZSByZWxldmFudCBzdHJ1Y3R1cmVzIGFyZTpcbiAgICAgKlxuICAgICAqIC0gY2hvc2VuOiA8Ym9vbGVhbiB2YWx1ZT5cbiAgICAgKiAtIGNob3NlbjogeyBzdWJPcHRpb246IDxib29sZWFuIG9yIGZ1bmN0aW9uPiB9XG4gICAgICpcbiAgICAgKiBXaGVyZSBzdWJPcHRpb24gaXMgJ25vZGUnLCAnZWRnZScgb3IgJ2xhYmVsJy5cbiAgICAgKlxuICAgICAqIFRoZSBpbnRlbnRpb24gb2YgdGhpcyBtZXRob2QgYXBwZWFycyB0byBiZSB0byBzZXQgYSBzcGVjaWZpYyBwcmlvcml0eSB0byB0aGUgb3B0aW9ucztcbiAgICAgKiBTaW5jZSBtb3N0IHByb3BlcnRpZXMgYXJlIGVpdGhlciBicmlkZ2VkIG9yIG1lcmdlZCBpbnRvIHRoZSBsb2NhbCBvcHRpb25zIG9iamVjdHMsIHRoZXJlXG4gICAgICogaXMgbm90IG11Y2ggcG9pbnQgaW4gaGFuZGxpbmcgdGhlbSBzZXBhcmF0ZWx5LlxuICAgICAqIFRPRE86IGV4YW1pbmUgaWYgJ21vc3QnIGluIHByZXZpb3VzIHNlbnRlbmNlIGNhbiBiZSByZXBsYWNlZCB3aXRoICdhbGwnLiBJbiB0aGF0IGNhc2UsIHdlXG4gICAgICogICAgICAgc2hvdWxkIGJlIGFibGUgdG8gZ2V0IHJpZCBvZiB0aGlzIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgc3ViT3B0aW9uICBvcHRpb24gd2l0aGluIG9iamVjdCAnY2hvc2VuJyB0byBjb25zaWRlcjsgZWl0aGVyICdub2RlJywgJ2VkZ2UnIG9yICdsYWJlbCdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gIHBpbGUgICAgICAgYXJyYXkgb2Ygb3B0aW9ucyBvYmplY3RzIHRvIGNvbnNpZGVyXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufGZ1bmN0aW9ufSAgdmFsdWUgZm9yIHBhc3NlZCBzdWJPcHRpb24gb2YgJ2Nob3NlbicgdG8gdXNlXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNob29zaWZ5KHN1Yk9wdGlvbiwgcGlsZSkge1xuICAgICAgLy8gYWxsb3dlZCB2YWx1ZXMgZm9yIHN1Yk9wdGlvblxuICAgICAgdmFyIGFsbG93ZWQgPSBbJ25vZGUnLCAnZWRnZScsICdsYWJlbCddO1xuICAgICAgdmFyIHZhbHVlID0gdHJ1ZTtcblxuICAgICAgdmFyIGNob3NlbiA9IHV0aWwudG9wTW9zdChwaWxlLCAnY2hvc2VuJyk7XG4gICAgICBpZiAodHlwZW9mIGNob3NlbiA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHZhbHVlID0gY2hvc2VuO1xuICAgICAgfSBlbHNlIGlmICgodHlwZW9mIGNob3NlbiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6ICgwLCBfdHlwZW9mM1snZGVmYXVsdCddKShjaG9zZW4pKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKGFsbG93ZWQuaW5kZXhPZihzdWJPcHRpb24pID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNob29zaWZ5OiBzdWJPcHRpb24gJ1wiICsgc3ViT3B0aW9uICsgXCInIHNob3VsZCBiZSBvbmUgb2YgXCIgKyBcIidcIiArIGFsbG93ZWQuam9pbihcIicsICdcIikgKyBcIidcIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2hvc2VuRWRnZSA9IHV0aWwudG9wTW9zdChwaWxlLCBbJ2Nob3NlbicsIHN1Yk9wdGlvbl0pO1xuICAgICAgICBpZiAodHlwZW9mIGNob3NlbkVkZ2UgPT09ICdib29sZWFuJyB8fCB0eXBlb2YgY2hvc2VuRWRnZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhbHVlID0gY2hvc2VuRWRnZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIHBvaW50IGZhbGxzIHdpdGhpbiB0aGUgZ2l2ZW4gcmVjdGFuZ2xlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtyZWN0fSByZWN0XG4gICAgICogQHBhcmFtIHtwb2ludH0gcG9pbnRcbiAgICAgKiBAcGFyYW0ge3JvdGF0aW9uUG9pbnR9IFtyb3RhdGlvblBvaW50XSBpZiBzcGVjaWZpZWQsIHRoZSByb3RhdGlvbiB0aGF0IGFwcGxpZXMgdG8gdGhlIHJlY3RhbmdsZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gIHRydWUgaWYgcG9pbnQgd2l0aGluIHJlY3RhbmdsZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwb2ludEluUmVjdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvaW50SW5SZWN0KHJlY3QsIHBvaW50LCByb3RhdGlvblBvaW50KSB7XG4gICAgICBpZiAocmVjdC53aWR0aCA8PSAwIHx8IHJlY3QuaGVpZ2h0IDw9IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBlYXJseSBvdXRcbiAgICAgIH1cblxuICAgICAgaWYgKHJvdGF0aW9uUG9pbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBSb3RhdGUgdGhlIHBvaW50IHRoZSBzYW1lIGFtb3VudCBhcyB0aGUgcmVjdGFuZ2xlXG4gICAgICAgIHZhciB0bXAgPSB7XG4gICAgICAgICAgeDogcG9pbnQueCAtIHJvdGF0aW9uUG9pbnQueCxcbiAgICAgICAgICB5OiBwb2ludC55IC0gcm90YXRpb25Qb2ludC55XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHJvdGF0aW9uUG9pbnQuYW5nbGUgIT09IDApIHtcbiAgICAgICAgICAvLyBJbiBvcmRlciB0byBnZXQgdGhlIGNvb3JkaW5hdGVzIHRoZSBzYW1lLCB5b3UgbmVlZCB0b1xuICAgICAgICAgIC8vIHJvdGF0ZSBpbiB0aGUgcmV2ZXJzZSBkaXJlY3Rpb25cbiAgICAgICAgICB2YXIgYW5nbGUgPSAtcm90YXRpb25Qb2ludC5hbmdsZTtcblxuICAgICAgICAgIHZhciB0bXAyID0ge1xuICAgICAgICAgICAgeDogTWF0aC5jb3MoYW5nbGUpICogdG1wLnggLSBNYXRoLnNpbihhbmdsZSkgKiB0bXAueSxcbiAgICAgICAgICAgIHk6IE1hdGguc2luKGFuZ2xlKSAqIHRtcC54ICsgTWF0aC5jb3MoYW5nbGUpICogdG1wLnlcbiAgICAgICAgICB9O1xuICAgICAgICAgIHBvaW50ID0gdG1wMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwb2ludCA9IHRtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vdGUgdGhhdCBpZiBhIHJvdGF0aW9uIGlzIHNwZWNpZmllZCwgdGhlIHJlY3RhbmdsZSBjb29yZGluYXRlc1xuICAgICAgICAvLyBhcmUgKipub3QqIHRoZSBmdWxsIGNhbnZhcyBjb29yZGluYXRlcy4gVGhleSBhcmUgcmVsYXRpdmUgdG8gdGhlXG4gICAgICAgIC8vIHJvdGF0aW9uUG9pbnQuIEhlbmNlLCB0aGUgcG9pbnQgY29vcmRpbmF0ZXMgbmVlZCBub3QgYmUgdHJhbnNsYXRlZFxuICAgICAgICAvLyBiYWNrIGluIHRoaXMgY2FzZS5cbiAgICAgIH1cblxuICAgICAgdmFyIHJpZ2h0ID0gcmVjdC54ICsgcmVjdC53aWR0aDtcbiAgICAgIHZhciBib3R0b20gPSByZWN0LnkgKyByZWN0LndpZHRoO1xuXG4gICAgICByZXR1cm4gcmVjdC5sZWZ0IDwgcG9pbnQueCAmJiByaWdodCA+IHBvaW50LnggJiYgcmVjdC50b3AgPCBwb2ludC55ICYmIGJvdHRvbSA+IHBvaW50Lnk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgZ2l2ZW4gdmFsdWUgaXMgYWNjZXB0YWJsZSBhcyBhIGxhYmVsIHRleHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHRleHQgdmFsdWUgdG8gY2hlY2s7IGNhbiBiZSBhbnl0aGluZyBhdCB0aGlzIHBvaW50XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdmFsaWQgbGFiZWwgdmFsdWUsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdpc1ZhbGlkTGFiZWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1ZhbGlkTGFiZWwodGV4dCkge1xuICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgaXMgcXVpdGUgc3RyaWN0OiB0eXBlcyB0aGF0ICptaWdodCogYmUgY29udmVydGVkIHRvIHN0cmluZyBhcmUgZGlzYWxsb3dlZFxuICAgICAgcmV0dXJuIHR5cGVvZiB0ZXh0ID09PSAnc3RyaW5nJyAmJiB0ZXh0ICE9PSAnJztcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENvbXBvbmVudFV0aWw7XG59KCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IENvbXBvbmVudFV0aWw7XG5cbi8qKiovIH0pLFxuLyogMzYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyoqXG4gKiBSZWdpc3RlciBhIHRvdWNoIGV2ZW50LCB0YWtpbmcgcGxhY2UgYmVmb3JlIGEgZ2VzdHVyZVxuICogQHBhcmFtIHtIYW1tZXJ9IGhhbW1lciAgICAgICBBIGhhbW1lciBpbnN0YW5jZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgICBDYWxsYmFjaywgY2FsbGVkIGFzIGNhbGxiYWNrKGV2ZW50KVxuICovXG5leHBvcnRzLm9uVG91Y2ggPSBmdW5jdGlvbiAoaGFtbWVyLCBjYWxsYmFjaykge1xuICBjYWxsYmFjay5pbnB1dEhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuaXNGaXJzdCkge1xuICAgICAgY2FsbGJhY2soZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICBoYW1tZXIub24oJ2hhbW1lci5pbnB1dCcsIGNhbGxiYWNrLmlucHV0SGFuZGxlcik7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgcmVsZWFzZSBldmVudCwgdGFraW5nIHBsYWNlIGFmdGVyIGEgZ2VzdHVyZVxuICogQHBhcmFtIHtIYW1tZXJ9IGhhbW1lciAgICAgICBBIGhhbW1lciBpbnN0YW5jZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgICBDYWxsYmFjaywgY2FsbGVkIGFzIGNhbGxiYWNrKGV2ZW50KVxuICogQHJldHVybnMgeyp9XG4gKi9cbmV4cG9ydHMub25SZWxlYXNlID0gZnVuY3Rpb24gKGhhbW1lciwgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2suaW5wdXRIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmlzRmluYWwpIHtcbiAgICAgIGNhbGxiYWNrKGV2ZW50KTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGhhbW1lci5vbignaGFtbWVyLmlucHV0JywgY2FsbGJhY2suaW5wdXRIYW5kbGVyKTtcbn07XG5cbi8qKlxuICogVW5yZWdpc3RlciBhIHRvdWNoIGV2ZW50LCB0YWtpbmcgcGxhY2UgYmVmb3JlIGEgZ2VzdHVyZVxuICogQHBhcmFtIHtIYW1tZXJ9IGhhbW1lciAgICAgICBBIGhhbW1lciBpbnN0YW5jZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgICBDYWxsYmFjaywgY2FsbGVkIGFzIGNhbGxiYWNrKGV2ZW50KVxuICovXG5leHBvcnRzLm9mZlRvdWNoID0gZnVuY3Rpb24gKGhhbW1lciwgY2FsbGJhY2spIHtcbiAgaGFtbWVyLm9mZignaGFtbWVyLmlucHV0JywgY2FsbGJhY2suaW5wdXRIYW5kbGVyKTtcbn07XG5cbi8qKlxuICogVW5yZWdpc3RlciBhIHJlbGVhc2UgZXZlbnQsIHRha2luZyBwbGFjZSBiZWZvcmUgYSBnZXN0dXJlXG4gKiBAcGFyYW0ge0hhbW1lcn0gaGFtbWVyICAgICAgIEEgaGFtbWVyIGluc3RhbmNlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAgIENhbGxiYWNrLCBjYWxsZWQgYXMgY2FsbGJhY2soZXZlbnQpXG4gKi9cbmV4cG9ydHMub2ZmUmVsZWFzZSA9IGV4cG9ydHMub2ZmVG91Y2g7XG5cbi8qKlxuICogSGFjayB0aGUgUGluY2hSZWNvZ25pemVyIHN1Y2ggdGhhdCBpdCBkb2Vzbid0IHByZXZlbnQgZGVmYXVsdCBiZWhhdmlvclxuICogZm9yIHZlcnRpY2FsIHBhbm5pbmcuXG4gKlxuICogWWVhaCAuLi4gdGhpcyBpcyBxdWl0ZSBhIGhhY2sgLi4uIHNlZSBodHRwczovL2dpdGh1Yi5jb20vaGFtbWVyanMvaGFtbWVyLmpzL2lzc3Vlcy85MzJcbiAqXG4gKiBAcGFyYW0ge0hhbW1lci5QaW5jaH0gcGluY2hSZWNvZ25pemVyXG4gKiBAcmV0dXJuIHtIYW1tZXIuUGluY2h9IHJldHVybnMgdGhlIHBpbmNoUmVjb2duaXplclxuICovXG5leHBvcnRzLmRpc2FibGVQcmV2ZW50RGVmYXVsdFZlcnRpY2FsbHkgPSBmdW5jdGlvbiAocGluY2hSZWNvZ25pemVyKSB7XG4gIHZhciBUT1VDSF9BQ1RJT05fUEFOX1kgPSAncGFuLXknO1xuXG4gIHBpbmNoUmVjb2duaXplci5nZXRUb3VjaEFjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBkZWZhdWx0IG1ldGhvZCByZXR1cm5zIFtUT1VDSF9BQ1RJT05fTk9ORV1cbiAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9QQU5fWV07XG4gIH07XG5cbiAgcmV0dXJuIHBpbmNoUmVjb2duaXplcjtcbn07XG5cbi8qKiovIH0pLFxuLyogMzcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuX193ZWJwYWNrX3JlcXVpcmVfXyg4Nyk7XG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG52YXIgaGlkZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xudmFyIEl0ZXJhdG9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpO1xudmFyIFRPX1NUUklOR19UQUcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpKCd0b1N0cmluZ1RhZycpO1xuXG52YXIgRE9NSXRlcmFibGVzID0gKCdDU1NSdWxlTGlzdCxDU1NTdHlsZURlY2xhcmF0aW9uLENTU1ZhbHVlTGlzdCxDbGllbnRSZWN0TGlzdCxET01SZWN0TGlzdCxET01TdHJpbmdMaXN0LCcgK1xuICAnRE9NVG9rZW5MaXN0LERhdGFUcmFuc2Zlckl0ZW1MaXN0LEZpbGVMaXN0LEhUTUxBbGxDb2xsZWN0aW9uLEhUTUxDb2xsZWN0aW9uLEhUTUxGb3JtRWxlbWVudCxIVE1MU2VsZWN0RWxlbWVudCwnICtcbiAgJ01lZGlhTGlzdCxNaW1lVHlwZUFycmF5LE5hbWVkTm9kZU1hcCxOb2RlTGlzdCxQYWludFJlcXVlc3RMaXN0LFBsdWdpbixQbHVnaW5BcnJheSxTVkdMZW5ndGhMaXN0LFNWR051bWJlckxpc3QsJyArXG4gICdTVkdQYXRoU2VnTGlzdCxTVkdQb2ludExpc3QsU1ZHU3RyaW5nTGlzdCxTVkdUcmFuc2Zvcm1MaXN0LFNvdXJjZUJ1ZmZlckxpc3QsU3R5bGVTaGVldExpc3QsVGV4dFRyYWNrQ3VlTGlzdCwnICtcbiAgJ1RleHRUcmFja0xpc3QsVG91Y2hMaXN0Jykuc3BsaXQoJywnKTtcblxuZm9yICh2YXIgaSA9IDA7IGkgPCBET01JdGVyYWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgdmFyIE5BTUUgPSBET01JdGVyYWJsZXNbaV07XG4gIHZhciBDb2xsZWN0aW9uID0gZ2xvYmFsW05BTUVdO1xuICB2YXIgcHJvdG8gPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlO1xuICBpZiAocHJvdG8gJiYgIXByb3RvW1RPX1NUUklOR19UQUddKSBoaWRlKHByb3RvLCBUT19TVFJJTkdfVEFHLCBOQU1FKTtcbiAgSXRlcmF0b3JzW05BTUVdID0gSXRlcmF0b3JzLkFycmF5O1xufVxuXG5cbi8qKiovIH0pLFxuLyogMzggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMzkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDQwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBTKSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICghUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDQxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG52YXIgZFBzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Mik7XG52YXIgZW51bUJ1Z0tleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1KTtcbnZhciBJRV9QUk9UTyA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpKCdJRV9QUk9UTycpO1xudmFyIEVtcHR5ID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjMpKCdpZnJhbWUnKTtcbiAgdmFyIGkgPSBlbnVtQnVnS2V5cy5sZW5ndGg7XG4gIHZhciBsdCA9ICc8JztcbiAgdmFyIGd0ID0gJz4nO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDk2KS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZSAoaS0tKSBkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHkoKTtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiA0MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDQzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBzaGFyZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KSgna2V5cycpO1xudmFyIHVpZCA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBzaGFyZWRba2V5XSB8fCAoc2hhcmVkW2tleV0gPSB1aWQoa2V5KSk7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogNDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGNvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KTtcbn0pKCd2ZXJzaW9ucycsIFtdKS5wdXNoKHtcbiAgdmVyc2lvbjogY29yZS52ZXJzaW9uLFxuICBtb2RlOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KSA/ICdwdXJlJyA6ICdnbG9iYWwnLFxuICBjb3B5cmlnaHQ6ICfCqSAyMDE4IERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpJ1xufSk7XG5cblxuLyoqKi8gfSksXG4vKiA0NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcblxuXG4vKioqLyB9KSxcbi8qIDQ2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBkZWYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKS5mO1xudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xudmFyIFRBRyA9IF9fd2VicGFja19yZXF1aXJlX18oOCkoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCB0YWcsIHN0YXQpIHtcbiAgaWYgKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpIGRlZihpdCwgVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZyB9KTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiA0NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyICRhdCA9IF9fd2VicGFja19yZXF1aXJlX18oOTcpKHRydWUpO1xuXG4vLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDYwKShTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbiAoaXRlcmF0ZWQpIHtcbiAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuLy8gMjEuMS41LjIuMSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBpbmRleCA9IHRoaXMuX2k7XG4gIHZhciBwb2ludDtcbiAgaWYgKGluZGV4ID49IE8ubGVuZ3RoKSByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIHBvaW50ID0gJGF0KE8sIGluZGV4KTtcbiAgdGhpcy5faSArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiB7IHZhbHVlOiBwb2ludCwgZG9uZTogZmFsc2UgfTtcbn0pO1xuXG5cbi8qKiovIH0pLFxuLyogNDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXhwb3J0cy5mID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxuXG4vKioqLyB9KSxcbi8qIDQ5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcbnZhciBjb3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbnZhciBMSUJSQVJZID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XG52YXIgd2tzRXh0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OCk7XG52YXIgZGVmaW5lUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKS5mO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgJFN5bWJvbCA9IGNvcmUuU3ltYm9sIHx8IChjb3JlLlN5bWJvbCA9IExJQlJBUlkgPyB7fSA6IGdsb2JhbC5TeW1ib2wgfHwge30pO1xuICBpZiAobmFtZS5jaGFyQXQoMCkgIT0gJ18nICYmICEobmFtZSBpbiAkU3ltYm9sKSkgZGVmaW5lUHJvcGVydHkoJFN5bWJvbCwgbmFtZSwgeyB2YWx1ZTogd2tzRXh0LmYobmFtZSkgfSk7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogNTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuXG4vKioqLyB9KSxcbi8qIDUxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfa2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBfa2V5czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9rZXlzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgRGF0YVNldCA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xuXG4vKipcbiAqIERhdGFWaWV3XG4gKlxuICogYSBkYXRhdmlldyBvZmZlcnMgYSBmaWx0ZXJlZCB2aWV3IG9uIGEgZGF0YXNldCBvciBhbiBvdGhlciBkYXRhdmlldy5cbiAqXG4gKiBAcGFyYW0ge0RhdGFTZXQgfCBEYXRhVmlld30gZGF0YVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgIEF2YWlsYWJsZSBvcHRpb25zOiBzZWUgbWV0aG9kIGdldFxuICpcbiAqIEBjb25zdHJ1Y3RvciBEYXRhVmlld1xuICovXG5mdW5jdGlvbiBEYXRhVmlldyhkYXRhLCBvcHRpb25zKSB7XG4gIHRoaXMuX2RhdGEgPSBudWxsO1xuICB0aGlzLl9pZHMgPSB7fTsgLy8gaWRzIG9mIHRoZSBpdGVtcyBjdXJyZW50bHkgaW4gbWVtb3J5IChqdXN0IGNvbnRhaW5zIGEgYm9vbGVhbiB0cnVlKVxuICB0aGlzLmxlbmd0aCA9IDA7IC8vIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgRGF0YVZpZXdcbiAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMuX2ZpZWxkSWQgPSAnaWQnOyAvLyBuYW1lIG9mIHRoZSBmaWVsZCBjb250YWluaW5nIGlkXG4gIHRoaXMuX3N1YnNjcmliZXJzID0ge307IC8vIGV2ZW50IHN1YnNjcmliZXJzXG5cbiAgdmFyIG1lID0gdGhpcztcbiAgdGhpcy5saXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICBtZS5fb25FdmVudC5hcHBseShtZSwgYXJndW1lbnRzKTtcbiAgfTtcblxuICB0aGlzLnNldERhdGEoZGF0YSk7XG59XG5cbi8vIFRPRE86IGltcGxlbWVudCBhIGZ1bmN0aW9uIC5jb25maWcoKSB0byBkeW5hbWljYWxseSB1cGRhdGUgdGhpbmdzIGxpa2UgY29uZmlndXJlZCBmaWx0ZXJcbi8vIGFuZCB0cmlnZ2VyIGNoYW5nZXMgYWNjb3JkaW5nbHlcblxuLyoqXG4gKiBTZXQgYSBkYXRhIHNvdXJjZSBmb3IgdGhlIHZpZXdcbiAqIEBwYXJhbSB7RGF0YVNldCB8IERhdGFWaWV3fSBkYXRhXG4gKi9cbkRhdGFWaWV3LnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdmFyIGlkcywgaWQsIGksIGxlbiwgaXRlbXM7XG5cbiAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICAvLyB1bnN1YnNjcmliZSBmcm9tIGN1cnJlbnQgZGF0YXNldFxuICAgIGlmICh0aGlzLl9kYXRhLm9mZikge1xuICAgICAgdGhpcy5fZGF0YS5vZmYoJyonLCB0aGlzLmxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyB0cmlnZ2VyIGEgcmVtb3ZlIG9mIGFsbCBpdGVtcyBpbiBtZW1vcnlcbiAgICBpZHMgPSB0aGlzLl9kYXRhLmdldElkcyh7IGZpbHRlcjogdGhpcy5fb3B0aW9ucyAmJiB0aGlzLl9vcHRpb25zLmZpbHRlciB9KTtcbiAgICBpdGVtcyA9IFtdO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gaWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpdGVtcy5wdXNoKHRoaXMuX2RhdGEuX2RhdGFbaWRzW2ldXSk7XG4gICAgfVxuXG4gICAgdGhpcy5faWRzID0ge307XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX3RyaWdnZXIoJ3JlbW92ZScsIHsgaXRlbXM6IGlkcywgb2xkRGF0YTogaXRlbXMgfSk7XG4gIH1cblxuICB0aGlzLl9kYXRhID0gZGF0YTtcblxuICBpZiAodGhpcy5fZGF0YSkge1xuICAgIC8vIHVwZGF0ZSBmaWVsZElkXG4gICAgdGhpcy5fZmllbGRJZCA9IHRoaXMuX29wdGlvbnMuZmllbGRJZCB8fCB0aGlzLl9kYXRhICYmIHRoaXMuX2RhdGEub3B0aW9ucyAmJiB0aGlzLl9kYXRhLm9wdGlvbnMuZmllbGRJZCB8fCAnaWQnO1xuXG4gICAgLy8gdHJpZ2dlciBhbiBhZGQgb2YgYWxsIGFkZGVkIGl0ZW1zXG4gICAgaWRzID0gdGhpcy5fZGF0YS5nZXRJZHMoeyBmaWx0ZXI6IHRoaXMuX29wdGlvbnMgJiYgdGhpcy5fb3B0aW9ucy5maWx0ZXIgfSk7XG4gICAgZm9yIChpID0gMCwgbGVuID0gaWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZCA9IGlkc1tpXTtcbiAgICAgIHRoaXMuX2lkc1tpZF0gPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLmxlbmd0aCA9IGlkcy5sZW5ndGg7XG4gICAgdGhpcy5fdHJpZ2dlcignYWRkJywgeyBpdGVtczogaWRzIH0pO1xuXG4gICAgLy8gc3Vic2NyaWJlIHRvIG5ldyBkYXRhc2V0XG4gICAgaWYgKHRoaXMuX2RhdGEub24pIHtcbiAgICAgIHRoaXMuX2RhdGEub24oJyonLCB0aGlzLmxpc3RlbmVyKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUmVmcmVzaCB0aGUgRGF0YVZpZXcuIFVzZWZ1bCB3aGVuIHRoZSBEYXRhVmlldyBoYXMgYSBmaWx0ZXIgZnVuY3Rpb25cbiAqIGNvbnRhaW5pbmcgYSB2YXJpYWJsZSBwYXJhbWV0ZXIuXG4gKi9cbkRhdGFWaWV3LnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaWQsIGksIGxlbjtcbiAgdmFyIGlkcyA9IHRoaXMuX2RhdGEuZ2V0SWRzKHtcbiAgICBmaWx0ZXI6IHRoaXMuX29wdGlvbnMgJiYgdGhpcy5fb3B0aW9ucy5maWx0ZXJcbiAgfSksXG4gICAgICBvbGRJZHMgPSAoMCwgX2tleXMyWydkZWZhdWx0J10pKHRoaXMuX2lkcyksXG4gICAgICBuZXdJZHMgPSB7fSxcbiAgICAgIGFkZGVkSWRzID0gW10sXG4gICAgICByZW1vdmVkSWRzID0gW10sXG4gICAgICByZW1vdmVkSXRlbXMgPSBbXTtcblxuICAvLyBjaGVjayBmb3IgYWRkaXRpb25zXG4gIGZvciAoaSA9IDAsIGxlbiA9IGlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlkID0gaWRzW2ldO1xuICAgIG5ld0lkc1tpZF0gPSB0cnVlO1xuICAgIGlmICghdGhpcy5faWRzW2lkXSkge1xuICAgICAgYWRkZWRJZHMucHVzaChpZCk7XG4gICAgICB0aGlzLl9pZHNbaWRdID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBjaGVjayBmb3IgcmVtb3ZhbHNcbiAgZm9yIChpID0gMCwgbGVuID0gb2xkSWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWQgPSBvbGRJZHNbaV07XG4gICAgaWYgKCFuZXdJZHNbaWRdKSB7XG4gICAgICByZW1vdmVkSWRzLnB1c2goaWQpO1xuICAgICAgcmVtb3ZlZEl0ZW1zLnB1c2godGhpcy5fZGF0YS5fZGF0YVtpZF0pO1xuICAgICAgZGVsZXRlIHRoaXMuX2lkc1tpZF07XG4gICAgfVxuICB9XG5cbiAgdGhpcy5sZW5ndGggKz0gYWRkZWRJZHMubGVuZ3RoIC0gcmVtb3ZlZElkcy5sZW5ndGg7XG5cbiAgLy8gdHJpZ2dlciBldmVudHNcbiAgaWYgKGFkZGVkSWRzLmxlbmd0aCkge1xuICAgIHRoaXMuX3RyaWdnZXIoJ2FkZCcsIHsgaXRlbXM6IGFkZGVkSWRzIH0pO1xuICB9XG4gIGlmIChyZW1vdmVkSWRzLmxlbmd0aCkge1xuICAgIHRoaXMuX3RyaWdnZXIoJ3JlbW92ZScsIHsgaXRlbXM6IHJlbW92ZWRJZHMsIG9sZERhdGE6IHJlbW92ZWRJdGVtcyB9KTtcbiAgfVxufTtcblxuLy8gcHJldHRpZXItaWdub3JlXG4vKipcbiAqIEdldCBkYXRhIGZyb20gdGhlIGRhdGEgdmlld1xuICpcbiAqIFVzYWdlOlxuICpcbiAqICAgICBnZXQoKVxuICogICAgIGdldChvcHRpb25zOiBPYmplY3QpXG4gKiAgICAgZ2V0KG9wdGlvbnM6IE9iamVjdCwgZGF0YTogQXJyYXkgfCBEYXRhVGFibGUpXG4gKlxuICogICAgIGdldChpZDogTnVtYmVyKVxuICogICAgIGdldChpZDogTnVtYmVyLCBvcHRpb25zOiBPYmplY3QpXG4gKiAgICAgZ2V0KGlkOiBOdW1iZXIsIG9wdGlvbnM6IE9iamVjdCwgZGF0YTogQXJyYXkgfCBEYXRhVGFibGUpXG4gKlxuICogICAgIGdldChpZHM6IE51bWJlcltdKVxuICogICAgIGdldChpZHM6IE51bWJlcltdLCBvcHRpb25zOiBPYmplY3QpXG4gKiAgICAgZ2V0KGlkczogTnVtYmVyW10sIG9wdGlvbnM6IE9iamVjdCwgZGF0YTogQXJyYXkgfCBEYXRhVGFibGUpXG4gKlxuICogV2hlcmU6XG4gKlxuICoge251bWJlciB8IHN0cmluZ30gaWQgICAgICAgICBUaGUgaWQgb2YgYW4gaXRlbVxuICoge251bWJlcltdIHwgc3RyaW5ne319IGlkcyAgICBBbiBhcnJheSB3aXRoIGlkcyBvZiBpdGVtc1xuICoge09iamVjdH0gb3B0aW9ucyAgICAgICAgICAgICBBbiBPYmplY3Qgd2l0aCBvcHRpb25zLiBBdmFpbGFibGUgb3B0aW9uczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3N0cmluZ30gW3R5cGVdIFR5cGUgb2YgZGF0YSB0byBiZSByZXR1cm5lZC4gQ2FuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZSAnRGF0YVRhYmxlJyBvciAnQXJyYXknIChkZWZhdWx0KVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0LjxzdHJpbmcsIHN0cmluZz59IFtjb252ZXJ0XVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nW119IFtmaWVsZHNdIGZpZWxkIG5hbWVzIHRvIGJlIHJldHVybmVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtmdW5jdGlvbn0gW2ZpbHRlcl0gZmlsdGVyIGl0ZW1zXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzdHJpbmcgfCBmdW5jdGlvbn0gW29yZGVyXSBPcmRlciB0aGUgaXRlbXMgYnlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgZmllbGQgbmFtZSBvciBjdXN0b20gc29ydCBmdW5jdGlvbi5cbiAqIHtBcnJheSB8IERhdGFUYWJsZX0gW2RhdGFdICAgSWYgcHJvdmlkZWQsIGl0ZW1zIHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhpc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheSBvciB0YWJsZS4gUmVxdWlyZWQgaW4gY2FzZSBvZiBHb29nbGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGF0YVRhYmxlLlxuICogQHBhcmFtIHtBcnJheX0gYXJnc1xuICogQHJldHVybiB7RGF0YVNldHxEYXRhVmlld31cbiAqL1xuRGF0YVZpZXcucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIG1lID0gdGhpcztcblxuICAvLyBwYXJzZSB0aGUgYXJndW1lbnRzXG4gIHZhciBpZHMsIG9wdGlvbnMsIGRhdGE7XG4gIHZhciBmaXJzdFR5cGUgPSB1dGlsLmdldFR5cGUoYXJndW1lbnRzWzBdKTtcbiAgaWYgKGZpcnN0VHlwZSA9PSAnU3RyaW5nJyB8fCBmaXJzdFR5cGUgPT0gJ051bWJlcicgfHwgZmlyc3RUeXBlID09ICdBcnJheScpIHtcbiAgICAvLyBnZXQoaWQocykgWywgb3B0aW9uc10gWywgZGF0YV0pXG4gICAgaWRzID0gYXJndW1lbnRzWzBdOyAvLyBjYW4gYmUgYSBzaW5nbGUgaWQgb3IgYW4gYXJyYXkgd2l0aCBpZHNcbiAgICBvcHRpb25zID0gYXJndW1lbnRzWzFdO1xuICAgIGRhdGEgPSBhcmd1bWVudHNbMl07XG4gIH0gZWxzZSB7XG4gICAgLy8gZ2V0KFssIG9wdGlvbnNdIFssIGRhdGFdKVxuICAgIG9wdGlvbnMgPSBhcmd1bWVudHNbMF07XG4gICAgZGF0YSA9IGFyZ3VtZW50c1sxXTtcbiAgfVxuXG4gIC8vIGV4dGVuZCB0aGUgb3B0aW9ucyB3aXRoIHRoZSBkZWZhdWx0IG9wdGlvbnMgYW5kIHByb3ZpZGVkIG9wdGlvbnNcbiAgdmFyIHZpZXdPcHRpb25zID0gdXRpbC5leHRlbmQoe30sIHRoaXMuX29wdGlvbnMsIG9wdGlvbnMpO1xuXG4gIC8vIGNyZWF0ZSBhIGNvbWJpbmVkIGZpbHRlciBtZXRob2Qgd2hlbiBuZWVkZWRcbiAgaWYgKHRoaXMuX29wdGlvbnMuZmlsdGVyICYmIG9wdGlvbnMgJiYgb3B0aW9ucy5maWx0ZXIpIHtcbiAgICB2aWV3T3B0aW9ucy5maWx0ZXIgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIG1lLl9vcHRpb25zLmZpbHRlcihpdGVtKSAmJiBvcHRpb25zLmZpbHRlcihpdGVtKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gYnVpbGQgdXAgdGhlIGNhbGwgdG8gdGhlIGxpbmtlZCBkYXRhIHNldFxuICB2YXIgZ2V0QXJndW1lbnRzID0gW107XG4gIGlmIChpZHMgIT0gdW5kZWZpbmVkKSB7XG4gICAgZ2V0QXJndW1lbnRzLnB1c2goaWRzKTtcbiAgfVxuICBnZXRBcmd1bWVudHMucHVzaCh2aWV3T3B0aW9ucyk7XG4gIGdldEFyZ3VtZW50cy5wdXNoKGRhdGEpO1xuXG4gIHJldHVybiB0aGlzLl9kYXRhICYmIHRoaXMuX2RhdGEuZ2V0LmFwcGx5KHRoaXMuX2RhdGEsIGdldEFyZ3VtZW50cyk7XG59O1xuXG4vKipcbiAqIEdldCBpZHMgb2YgYWxsIGl0ZW1zIG9yIGZyb20gYSBmaWx0ZXJlZCBzZXQgb2YgaXRlbXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgIEFuIE9iamVjdCB3aXRoIG9wdGlvbnMuIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ZnVuY3Rpb259IFtmaWx0ZXJdIGZpbHRlciBpdGVtc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nIHwgZnVuY3Rpb259IFtvcmRlcl0gT3JkZXIgdGhlIGl0ZW1zIGJ5XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIGZpZWxkIG5hbWUgb3IgY3VzdG9tIHNvcnQgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nfG51bWJlcj59IGlkc1xuICovXG5EYXRhVmlldy5wcm90b3R5cGUuZ2V0SWRzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIGlkcztcblxuICBpZiAodGhpcy5fZGF0YSkge1xuICAgIHZhciBkZWZhdWx0RmlsdGVyID0gdGhpcy5fb3B0aW9ucy5maWx0ZXI7XG4gICAgdmFyIGZpbHRlcjtcblxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZmlsdGVyKSB7XG4gICAgICBpZiAoZGVmYXVsdEZpbHRlcikge1xuICAgICAgICBmaWx0ZXIgPSBmdW5jdGlvbiBmaWx0ZXIoaXRlbSkge1xuICAgICAgICAgIHJldHVybiBkZWZhdWx0RmlsdGVyKGl0ZW0pICYmIG9wdGlvbnMuZmlsdGVyKGl0ZW0pO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbHRlciA9IGRlZmF1bHRGaWx0ZXI7XG4gICAgfVxuXG4gICAgaWRzID0gdGhpcy5fZGF0YS5nZXRJZHMoe1xuICAgICAgZmlsdGVyOiBmaWx0ZXIsXG4gICAgICBvcmRlcjogb3B0aW9ucyAmJiBvcHRpb25zLm9yZGVyXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWRzID0gW107XG4gIH1cblxuICByZXR1cm4gaWRzO1xufTtcblxuLyoqXG4gKiBNYXAgZXZlcnkgaXRlbSBpbiB0aGUgZGF0YXNldC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0LjxzdHJpbmcsIHN0cmluZz59IFt0eXBlXVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nW119IFtmaWVsZHNdIGZpbHRlciBmaWVsZHNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2Z1bmN0aW9ufSBbZmlsdGVyXSBmaWx0ZXIgaXRlbXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3N0cmluZyB8IGZ1bmN0aW9ufSBbb3JkZXJdIE9yZGVyIHRoZSBpdGVtcyBieVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBmaWVsZCBuYW1lIG9yIGN1c3RvbSBzb3J0IGZ1bmN0aW9uLlxuICogQHJldHVybiB7T2JqZWN0W119IG1hcHBlZEl0ZW1zXG4gKi9cbkRhdGFWaWV3LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgdmFyIG1hcHBlZEl0ZW1zID0gW107XG4gIGlmICh0aGlzLl9kYXRhKSB7XG4gICAgdmFyIGRlZmF1bHRGaWx0ZXIgPSB0aGlzLl9vcHRpb25zLmZpbHRlcjtcbiAgICB2YXIgZmlsdGVyO1xuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5maWx0ZXIpIHtcbiAgICAgIGlmIChkZWZhdWx0RmlsdGVyKSB7XG4gICAgICAgIGZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlcihpdGVtKSB7XG4gICAgICAgICAgcmV0dXJuIGRlZmF1bHRGaWx0ZXIoaXRlbSkgJiYgb3B0aW9ucy5maWx0ZXIoaXRlbSk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaWx0ZXIgPSBvcHRpb25zLmZpbHRlcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZmlsdGVyID0gZGVmYXVsdEZpbHRlcjtcbiAgICB9XG5cbiAgICBtYXBwZWRJdGVtcyA9IHRoaXMuX2RhdGEubWFwKGNhbGxiYWNrLCB7XG4gICAgICBmaWx0ZXI6IGZpbHRlcixcbiAgICAgIG9yZGVyOiBvcHRpb25zICYmIG9wdGlvbnMub3JkZXJcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBtYXBwZWRJdGVtcyA9IFtdO1xuICB9XG5cbiAgcmV0dXJuIG1hcHBlZEl0ZW1zO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIERhdGFTZXQgdG8gd2hpY2ggdGhpcyBEYXRhVmlldyBpcyBjb25uZWN0ZWQuIEluIGNhc2UgdGhlcmUgaXMgYSBjaGFpblxuICogb2YgbXVsdGlwbGUgRGF0YVZpZXdzLCB0aGUgcm9vdCBEYXRhU2V0IG9mIHRoaXMgY2hhaW4gaXMgcmV0dXJuZWQuXG4gKiBAcmV0dXJuIHtEYXRhU2V0fSBkYXRhU2V0XG4gKi9cbkRhdGFWaWV3LnByb3RvdHlwZS5nZXREYXRhU2V0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZGF0YVNldCA9IHRoaXM7XG4gIHdoaWxlIChkYXRhU2V0IGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICBkYXRhU2V0ID0gZGF0YVNldC5fZGF0YTtcbiAgfVxuICByZXR1cm4gZGF0YVNldCB8fCBudWxsO1xufTtcblxuLyoqXG4gKiBFdmVudCBsaXN0ZW5lci4gV2lsbCBwcm9wYWdhdGUgYWxsIGV2ZW50cyBmcm9tIHRoZSBjb25uZWN0ZWQgZGF0YSBzZXQgdG9cbiAqIHRoZSBzdWJzY3JpYmVycyBvZiB0aGUgRGF0YVZpZXcsIGJ1dCB3aWxsIGZpbHRlciB0aGUgaXRlbXMgYW5kIG9ubHkgdHJpZ2dlclxuICogd2hlbiB0aGVyZSBhcmUgY2hhbmdlcyBpbiB0aGUgZmlsdGVyZWQgZGF0YSBzZXQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7T2JqZWN0IHwgbnVsbH0gcGFyYW1zXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VuZGVySWRcbiAqIEBwcml2YXRlXG4gKi9cbkRhdGFWaWV3LnByb3RvdHlwZS5fb25FdmVudCA9IGZ1bmN0aW9uIChldmVudCwgcGFyYW1zLCBzZW5kZXJJZCkge1xuICB2YXIgaSwgbGVuLCBpZCwgaXRlbTtcbiAgdmFyIGlkcyA9IHBhcmFtcyAmJiBwYXJhbXMuaXRlbXM7XG4gIHZhciBhZGRlZElkcyA9IFtdLFxuICAgICAgdXBkYXRlZElkcyA9IFtdLFxuICAgICAgcmVtb3ZlZElkcyA9IFtdLFxuICAgICAgb2xkSXRlbXMgPSBbXSxcbiAgICAgIHVwZGF0ZWRJdGVtcyA9IFtdLFxuICAgICAgcmVtb3ZlZEl0ZW1zID0gW107XG5cbiAgaWYgKGlkcyAmJiB0aGlzLl9kYXRhKSB7XG4gICAgc3dpdGNoIChldmVudCkge1xuICAgICAgY2FzZSAnYWRkJzpcbiAgICAgICAgLy8gZmlsdGVyIHRoZSBpZHMgb2YgdGhlIGFkZGVkIGl0ZW1zXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlkID0gaWRzW2ldO1xuICAgICAgICAgIGl0ZW0gPSB0aGlzLmdldChpZCk7XG4gICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMuX2lkc1tpZF0gPSB0cnVlO1xuICAgICAgICAgICAgYWRkZWRJZHMucHVzaChpZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3VwZGF0ZSc6XG4gICAgICAgIC8vIGRldGVybWluZSB0aGUgZXZlbnQgZnJvbSB0aGUgdmlld3Mgdmlld3BvaW50OiBhbiB1cGRhdGVkXG4gICAgICAgIC8vIGl0ZW0gY2FuIGJlIGFkZGVkLCB1cGRhdGVkLCBvciByZW1vdmVkIGZyb20gdGhpcyB2aWV3LlxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZCA9IGlkc1tpXTtcbiAgICAgICAgICBpdGVtID0gdGhpcy5nZXQoaWQpO1xuXG4gICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pZHNbaWRdKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZWRJZHMucHVzaChpZCk7XG4gICAgICAgICAgICAgIHVwZGF0ZWRJdGVtcy5wdXNoKHBhcmFtcy5kYXRhW2ldKTtcbiAgICAgICAgICAgICAgb2xkSXRlbXMucHVzaChwYXJhbXMub2xkRGF0YVtpXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9pZHNbaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYWRkZWRJZHMucHVzaChpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pZHNbaWRdKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9pZHNbaWRdO1xuICAgICAgICAgICAgICByZW1vdmVkSWRzLnB1c2goaWQpO1xuICAgICAgICAgICAgICByZW1vdmVkSXRlbXMucHVzaChwYXJhbXMub2xkRGF0YVtpXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBub3RoaW5nIGludGVyZXN0aW5nIGZvciBtZSA6LShcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncmVtb3ZlJzpcbiAgICAgICAgLy8gZmlsdGVyIHRoZSBpZHMgb2YgdGhlIHJlbW92ZWQgaXRlbXNcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gaWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWQgPSBpZHNbaV07XG4gICAgICAgICAgaWYgKHRoaXMuX2lkc1tpZF0pIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9pZHNbaWRdO1xuICAgICAgICAgICAgcmVtb3ZlZElkcy5wdXNoKGlkKTtcbiAgICAgICAgICAgIHJlbW92ZWRJdGVtcy5wdXNoKHBhcmFtcy5vbGREYXRhW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCArPSBhZGRlZElkcy5sZW5ndGggLSByZW1vdmVkSWRzLmxlbmd0aDtcblxuICAgIGlmIChhZGRlZElkcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3RyaWdnZXIoJ2FkZCcsIHsgaXRlbXM6IGFkZGVkSWRzIH0sIHNlbmRlcklkKTtcbiAgICB9XG4gICAgaWYgKHVwZGF0ZWRJZHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl90cmlnZ2VyKCd1cGRhdGUnLCB7IGl0ZW1zOiB1cGRhdGVkSWRzLCBvbGREYXRhOiBvbGRJdGVtcywgZGF0YTogdXBkYXRlZEl0ZW1zIH0sIHNlbmRlcklkKTtcbiAgICB9XG4gICAgaWYgKHJlbW92ZWRJZHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl90cmlnZ2VyKCdyZW1vdmUnLCB7IGl0ZW1zOiByZW1vdmVkSWRzLCBvbGREYXRhOiByZW1vdmVkSXRlbXMgfSwgc2VuZGVySWQpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gY29weSBzdWJzY3JpcHRpb24gZnVuY3Rpb25hbGl0eSBmcm9tIERhdGFTZXRcbkRhdGFWaWV3LnByb3RvdHlwZS5vbiA9IERhdGFTZXQucHJvdG90eXBlLm9uO1xuRGF0YVZpZXcucHJvdG90eXBlLm9mZiA9IERhdGFTZXQucHJvdG90eXBlLm9mZjtcbkRhdGFWaWV3LnByb3RvdHlwZS5fdHJpZ2dlciA9IERhdGFTZXQucHJvdG90eXBlLl90cmlnZ2VyO1xuXG4vLyBUT0RPOiBtYWtlIHRoZXNlIGZ1bmN0aW9ucyBkZXByZWNhdGVkIChyZXBsYWNlZCB3aXRoIGBvbmAgYW5kIGBvZmZgIHNpbmNlIHZlcnNpb24gMC41KVxuRGF0YVZpZXcucHJvdG90eXBlLnN1YnNjcmliZSA9IERhdGFWaWV3LnByb3RvdHlwZS5vbjtcbkRhdGFWaWV3LnByb3RvdHlwZS51bnN1YnNjcmliZSA9IERhdGFWaWV3LnByb3RvdHlwZS5vZmY7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVZpZXc7XG5cbi8qKiovIH0pLFxuLyogNTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXztcclxuLyoqXHJcbiAqIENyZWF0ZWQgYnkgQWxleCBvbiAxMS82LzIwMTQuXHJcbiAqL1xyXG5cclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3VtZGpzL3VtZC9ibG9iL21hc3Rlci9yZXR1cm5FeHBvcnRzLmpzI0w0MC1MNjBcclxuLy8gaWYgdGhlIG1vZHVsZSBoYXMgbm8gZGVwZW5kZW5jaWVzLCB0aGUgYWJvdmUgcGF0dGVybiBjYW4gYmUgc2ltcGxpZmllZCB0b1xyXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcclxuICBpZiAodHJ1ZSkge1xyXG4gICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxyXG4gICAgIShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW10sIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9IChmYWN0b3J5KSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/XG5cdFx0XHRcdChfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18uYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXykpIDogX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAvLyBOb2RlLiBEb2VzIG5vdCB3b3JrIHdpdGggc3RyaWN0IENvbW1vbkpTLCBidXRcclxuICAgIC8vIG9ubHkgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxyXG4gICAgLy8gbGlrZSBOb2RlLlxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIEJyb3dzZXIgZ2xvYmFscyAocm9vdCBpcyB3aW5kb3cpXHJcbiAgICByb290LmtleWNoYXJtID0gZmFjdG9yeSgpO1xyXG4gIH1cclxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XHJcblxyXG4gIGZ1bmN0aW9uIGtleWNoYXJtKG9wdGlvbnMpIHtcclxuICAgIHZhciBwcmV2ZW50RGVmYXVsdCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5wcmV2ZW50RGVmYXVsdCB8fCBmYWxzZTtcclxuXHJcbiAgICB2YXIgY29udGFpbmVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvbnRhaW5lciB8fCB3aW5kb3c7XHJcblxyXG4gICAgdmFyIF9leHBvcnRGdW5jdGlvbnMgPSB7fTtcclxuICAgIHZhciBfYm91bmQgPSB7a2V5ZG93bjp7fSwga2V5dXA6e319O1xyXG4gICAgdmFyIF9rZXlzID0ge307XHJcbiAgICB2YXIgaTtcclxuXHJcbiAgICAvLyBhIC0gelxyXG4gICAgZm9yIChpID0gOTc7IGkgPD0gMTIyOyBpKyspIHtfa2V5c1tTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IHtjb2RlOjY1ICsgKGkgLSA5NyksIHNoaWZ0OiBmYWxzZX07fVxyXG4gICAgLy8gQSAtIFpcclxuICAgIGZvciAoaSA9IDY1OyBpIDw9IDkwOyBpKyspIHtfa2V5c1tTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IHtjb2RlOmksIHNoaWZ0OiB0cnVlfTt9XHJcbiAgICAvLyAwIC0gOVxyXG4gICAgZm9yIChpID0gMDsgIGkgPD0gOTsgICBpKyspIHtfa2V5c1snJyArIGldID0ge2NvZGU6NDggKyBpLCBzaGlmdDogZmFsc2V9O31cclxuICAgIC8vIEYxIC0gRjEyXHJcbiAgICBmb3IgKGkgPSAxOyAgaSA8PSAxMjsgICBpKyspIHtfa2V5c1snRicgKyBpXSA9IHtjb2RlOjExMSArIGksIHNoaWZ0OiBmYWxzZX07fVxyXG4gICAgLy8gbnVtMCAtIG51bTlcclxuICAgIGZvciAoaSA9IDA7ICBpIDw9IDk7ICAgaSsrKSB7X2tleXNbJ251bScgKyBpXSA9IHtjb2RlOjk2ICsgaSwgc2hpZnQ6IGZhbHNlfTt9XHJcblxyXG4gICAgLy8gbnVtcGFkIG1pc2NcclxuICAgIF9rZXlzWydudW0qJ10gPSB7Y29kZToxMDYsIHNoaWZ0OiBmYWxzZX07XHJcbiAgICBfa2V5c1snbnVtKyddID0ge2NvZGU6MTA3LCBzaGlmdDogZmFsc2V9O1xyXG4gICAgX2tleXNbJ251bS0nXSA9IHtjb2RlOjEwOSwgc2hpZnQ6IGZhbHNlfTtcclxuICAgIF9rZXlzWydudW0vJ10gPSB7Y29kZToxMTEsIHNoaWZ0OiBmYWxzZX07XHJcbiAgICBfa2V5c1snbnVtLiddID0ge2NvZGU6MTEwLCBzaGlmdDogZmFsc2V9O1xyXG4gICAgLy8gYXJyb3dzXHJcbiAgICBfa2V5c1snbGVmdCddICA9IHtjb2RlOjM3LCBzaGlmdDogZmFsc2V9O1xyXG4gICAgX2tleXNbJ3VwJ10gICAgPSB7Y29kZTozOCwgc2hpZnQ6IGZhbHNlfTtcclxuICAgIF9rZXlzWydyaWdodCddID0ge2NvZGU6MzksIHNoaWZ0OiBmYWxzZX07XHJcbiAgICBfa2V5c1snZG93biddICA9IHtjb2RlOjQwLCBzaGlmdDogZmFsc2V9O1xyXG4gICAgLy8gZXh0cmEga2V5c1xyXG4gICAgX2tleXNbJ3NwYWNlJ10gPSB7Y29kZTozMiwgc2hpZnQ6IGZhbHNlfTtcclxuICAgIF9rZXlzWydlbnRlciddID0ge2NvZGU6MTMsIHNoaWZ0OiBmYWxzZX07XHJcbiAgICBfa2V5c1snc2hpZnQnXSA9IHtjb2RlOjE2LCBzaGlmdDogdW5kZWZpbmVkfTtcclxuICAgIF9rZXlzWydlc2MnXSAgID0ge2NvZGU6MjcsIHNoaWZ0OiBmYWxzZX07XHJcbiAgICBfa2V5c1snYmFja3NwYWNlJ10gPSB7Y29kZTo4LCBzaGlmdDogZmFsc2V9O1xyXG4gICAgX2tleXNbJ3RhYiddICAgICAgID0ge2NvZGU6OSwgc2hpZnQ6IGZhbHNlfTtcclxuICAgIF9rZXlzWydjdHJsJ10gICAgICA9IHtjb2RlOjE3LCBzaGlmdDogZmFsc2V9O1xyXG4gICAgX2tleXNbJ2FsdCddICAgICAgID0ge2NvZGU6MTgsIHNoaWZ0OiBmYWxzZX07XHJcbiAgICBfa2V5c1snZGVsZXRlJ10gICAgPSB7Y29kZTo0Niwgc2hpZnQ6IGZhbHNlfTtcclxuICAgIF9rZXlzWydwYWdldXAnXSAgICA9IHtjb2RlOjMzLCBzaGlmdDogZmFsc2V9O1xyXG4gICAgX2tleXNbJ3BhZ2Vkb3duJ10gID0ge2NvZGU6MzQsIHNoaWZ0OiBmYWxzZX07XHJcbiAgICAvLyBzeW1ib2xzXHJcbiAgICBfa2V5c1snPSddICAgICA9IHtjb2RlOjE4Nywgc2hpZnQ6IGZhbHNlfTtcclxuICAgIF9rZXlzWyctJ10gICAgID0ge2NvZGU6MTg5LCBzaGlmdDogZmFsc2V9O1xyXG4gICAgX2tleXNbJ10nXSAgICAgPSB7Y29kZToyMjEsIHNoaWZ0OiBmYWxzZX07XHJcbiAgICBfa2V5c1snWyddICAgICA9IHtjb2RlOjIxOSwgc2hpZnQ6IGZhbHNlfTtcclxuXHJcblxyXG5cclxuICAgIHZhciBkb3duID0gZnVuY3Rpb24oZXZlbnQpIHtoYW5kbGVFdmVudChldmVudCwna2V5ZG93bicpO307XHJcbiAgICB2YXIgdXAgPSBmdW5jdGlvbihldmVudCkge2hhbmRsZUV2ZW50KGV2ZW50LCdrZXl1cCcpO307XHJcblxyXG4gICAgLy8gaGFuZGxlIHRoZSBhY3R1YWx5IGJvdW5kIGtleSB3aXRoIHRoZSBldmVudFxyXG4gICAgdmFyIGhhbmRsZUV2ZW50ID0gZnVuY3Rpb24oZXZlbnQsdHlwZSkge1xyXG4gICAgICBpZiAoX2JvdW5kW3R5cGVdW2V2ZW50LmtleUNvZGVdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB2YXIgYm91bmQgPSBfYm91bmRbdHlwZV1bZXZlbnQua2V5Q29kZV07XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgaWYgKGJvdW5kW2ldLnNoaWZ0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgYm91bmRbaV0uZm4oZXZlbnQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSBpZiAoYm91bmRbaV0uc2hpZnQgPT0gdHJ1ZSAmJiBldmVudC5zaGlmdEtleSA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIGJvdW5kW2ldLmZuKGV2ZW50KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2UgaWYgKGJvdW5kW2ldLnNoaWZ0ID09IGZhbHNlICYmIGV2ZW50LnNoaWZ0S2V5ID09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGJvdW5kW2ldLmZuKGV2ZW50KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwcmV2ZW50RGVmYXVsdCA9PSB0cnVlKSB7XHJcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBiaW5kIGEga2V5IHRvIGEgY2FsbGJhY2tcclxuICAgIF9leHBvcnRGdW5jdGlvbnMuYmluZCA9IGZ1bmN0aW9uKGtleSwgY2FsbGJhY2ssIHR5cGUpIHtcclxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHR5cGUgPSAna2V5ZG93bic7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKF9rZXlzW2tleV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGtleTogXCIgKyBrZXkpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChfYm91bmRbdHlwZV1bX2tleXNba2V5XS5jb2RlXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgX2JvdW5kW3R5cGVdW19rZXlzW2tleV0uY29kZV0gPSBbXTtcclxuICAgICAgfVxyXG4gICAgICBfYm91bmRbdHlwZV1bX2tleXNba2V5XS5jb2RlXS5wdXNoKHtmbjpjYWxsYmFjaywgc2hpZnQ6X2tleXNba2V5XS5zaGlmdH0pO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLy8gYmluZCBhbGwga2V5cyB0byBhIGNhbGwgYmFjayAoZGVtbyBwdXJwb3NlcylcclxuICAgIF9leHBvcnRGdW5jdGlvbnMuYmluZEFsbCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCB0eXBlKSB7XHJcbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB0eXBlID0gJ2tleWRvd24nO1xyXG4gICAgICB9XHJcbiAgICAgIGZvciAodmFyIGtleSBpbiBfa2V5cykge1xyXG4gICAgICAgIGlmIChfa2V5cy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICBfZXhwb3J0RnVuY3Rpb25zLmJpbmQoa2V5LGNhbGxiYWNrLHR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBnZXQgdGhlIGtleSBsYWJlbCBmcm9tIGFuIGV2ZW50XHJcbiAgICBfZXhwb3J0RnVuY3Rpb25zLmdldEtleSA9IGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgIGZvciAodmFyIGtleSBpbiBfa2V5cykge1xyXG4gICAgICAgIGlmIChfa2V5cy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICBpZiAoZXZlbnQuc2hpZnRLZXkgPT0gdHJ1ZSAmJiBfa2V5c1trZXldLnNoaWZ0ID09IHRydWUgJiYgZXZlbnQua2V5Q29kZSA9PSBfa2V5c1trZXldLmNvZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGtleTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LnNoaWZ0S2V5ID09IGZhbHNlICYmIF9rZXlzW2tleV0uc2hpZnQgPT0gZmFsc2UgJiYgZXZlbnQua2V5Q29kZSA9PSBfa2V5c1trZXldLmNvZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGtleTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gX2tleXNba2V5XS5jb2RlICYmIGtleSA9PSAnc2hpZnQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBrZXk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBcInVua25vd24ga2V5LCBjdXJyZW50bHkgbm90IHN1cHBvcnRlZFwiO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyB1bmJpbmQgZWl0aGVyIGEgc3BlY2lmaWMgY2FsbGJhY2sgZnJvbSBhIGtleSBvciBhbGwgb2YgdGhlbSAoYnkgbGVhdmluZyBjYWxsYmFjayB1bmRlZmluZWQpXHJcbiAgICBfZXhwb3J0RnVuY3Rpb25zLnVuYmluZCA9IGZ1bmN0aW9uKGtleSwgY2FsbGJhY2ssIHR5cGUpIHtcclxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHR5cGUgPSAna2V5ZG93bic7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKF9rZXlzW2tleV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGtleTogXCIgKyBrZXkpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChjYWxsYmFjayAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdmFyIG5ld0JpbmRpbmdzID0gW107XHJcbiAgICAgICAgdmFyIGJvdW5kID0gX2JvdW5kW3R5cGVdW19rZXlzW2tleV0uY29kZV07XHJcbiAgICAgICAgaWYgKGJvdW5kICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKCEoYm91bmRbaV0uZm4gPT0gY2FsbGJhY2sgJiYgYm91bmRbaV0uc2hpZnQgPT0gX2tleXNba2V5XS5zaGlmdCkpIHtcclxuICAgICAgICAgICAgICBuZXdCaW5kaW5ncy5wdXNoKF9ib3VuZFt0eXBlXVtfa2V5c1trZXldLmNvZGVdW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBfYm91bmRbdHlwZV1bX2tleXNba2V5XS5jb2RlXSA9IG5ld0JpbmRpbmdzO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIF9ib3VuZFt0eXBlXVtfa2V5c1trZXldLmNvZGVdID0gW107XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gcmVzZXQgYWxsIGJvdW5kIHZhcmlhYmxlcy5cclxuICAgIF9leHBvcnRGdW5jdGlvbnMucmVzZXQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgX2JvdW5kID0ge2tleWRvd246e30sIGtleXVwOnt9fTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gdW5iaW5kIGFsbCBsaXN0ZW5lcnMgYW5kIHJlc2V0IGFsbCB2YXJpYWJsZXMuXHJcbiAgICBfZXhwb3J0RnVuY3Rpb25zLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcclxuICAgICAgX2JvdW5kID0ge2tleWRvd246e30sIGtleXVwOnt9fTtcclxuICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBkb3duLCB0cnVlKTtcclxuICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdXAsIHRydWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBjcmVhdGUgbGlzdGVuZXJzLlxyXG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLGRvd24sdHJ1ZSk7XHJcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLHVwLHRydWUpO1xyXG5cclxuICAgIC8vIHJldHVybiB0aGUgcHVibGljIGZ1bmN0aW9ucy5cclxuICAgIHJldHVybiBfZXhwb3J0RnVuY3Rpb25zO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGtleWNoYXJtO1xyXG59KSk7XHJcblxyXG5cclxuXG5cbi8qKiovIH0pLFxuLyogNTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9nZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxudmFyIF9Ob2RlQmFzZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcblxudmFyIF9Ob2RlQmFzZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Ob2RlQmFzZTIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbi8qKlxuICogTk9URTogVGhpcyBpcyBhIGJhZCBiYXNlIGNsYXNzXG4gKlxuICogQ2hpbGQgY2xhc3NlcyBhcmU6XG4gKlxuICogICBJbWFnZSAgICAgICAtIHVzZXMgKm9ubHkqIGltYWdlIG1ldGhvZHNcbiAqICAgQ2lyY2xlICAgICAgLSB1c2VzICpvbmx5KiBfZHJhd1Jhd0NpcmNsZVxuICogICBDaXJjbGVJbWFnZSAtIHVzZXMgYWxsXG4gKlxuICogVE9ETzogUmVmYWN0b3IsIG1vdmUgX2RyYXdSYXdDaXJjbGUgdG8gZGlmZmVyZW50IG1vZHVsZSwgZGVyaXZlIENpcmNsZSBmcm9tIE5vZGVCYXNlXG4gKiAgICAgICBSZW5hbWUgdGhpcyB0byBJbWFnZUJhc2VcbiAqICAgICAgIENvbnNvbGlkYXRlIGNvbW1vbiBjb2RlIGluIEltYWdlIGFuZCBDaXJjbGVJbWFnZSB0byBiYXNlIGNsYXNzXG4gKlxuICogQGV4dGVuZHMgTm9kZUJhc2VcbiAqL1xudmFyIENpcmNsZUltYWdlQmFzZSA9IGZ1bmN0aW9uIChfTm9kZUJhc2UpIHtcbiAgKDAsIF9pbmhlcml0czNbJ2RlZmF1bHQnXSkoQ2lyY2xlSW1hZ2VCYXNlLCBfTm9kZUJhc2UpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gQ2lyY2xlSW1hZ2VCYXNlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgQ2lyY2xlSW1hZ2VCYXNlKTtcblxuICAgIHZhciBfdGhpcyA9ICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjNbJ2RlZmF1bHQnXSkodGhpcywgKENpcmNsZUltYWdlQmFzZS5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjJbJ2RlZmF1bHQnXSkoQ2lyY2xlSW1hZ2VCYXNlKSkuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuXG4gICAgX3RoaXMubGFiZWxPZmZzZXQgPSAwO1xuICAgIF90aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbaW1hZ2VPYmpdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbaW1hZ2VPYmpBbHRdXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoQ2lyY2xlSW1hZ2VCYXNlLCBbe1xuICAgIGtleTogJ3NldE9wdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMsIGltYWdlT2JqLCBpbWFnZU9iakFsdCkge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgICAgaWYgKCEoaW1hZ2VPYmogPT09IHVuZGVmaW5lZCAmJiBpbWFnZU9iakFsdCA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICB0aGlzLnNldEltYWdlcyhpbWFnZU9iaiwgaW1hZ2VPYmpBbHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgaW1hZ2VzIGZvciB0aGlzIG5vZGUuXG4gICAgICpcbiAgICAgKiBUaGUgaW1hZ2VzIGNhbiBiZSB1cGRhdGVkIGFmdGVyIHRoZSBpbml0aWFsIHNldHRpbmcgb2Ygb3B0aW9ucztcbiAgICAgKiB0aGVyZWZvcmUsIHRoaXMgbWV0aG9kIG5lZWRzIHRvIGJlIHJlZW50cmFudC5cbiAgICAgKlxuICAgICAqIEZvciBjb3JyZWN0IHdvcmtpbmcgaW4gZXJyb3IgY2FzZXMsIGl0IGlzIG5lY2Vzc2FyeSB0byBwcm9wZXJseSBzZXRcbiAgICAgKiBmaWVsZCAnbm9kZXMuYnJva2VuSW1hZ2UnIGluIHRoZSBvcHRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJbWFnZX0gaW1hZ2VPYmogIHJlcXVpcmVkOyBtYWluIGltYWdlIHRvIHNob3cgZm9yIHRoaXMgbm9kZVxuICAgICAqIEBwYXJhbSB7SW1hZ2V8dW5kZWZpbmVkfSBpbWFnZU9iakFsdCBvcHRpb25hbDsgaW1hZ2UgdG8gc2hvdyB3aGVuIG5vZGUgaXMgc2VsZWN0ZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0SW1hZ2VzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0SW1hZ2VzKGltYWdlT2JqLCBpbWFnZU9iakFsdCkge1xuICAgICAgaWYgKGltYWdlT2JqQWx0ICYmIHRoaXMuc2VsZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5pbWFnZU9iaiA9IGltYWdlT2JqQWx0O1xuICAgICAgICB0aGlzLmltYWdlT2JqQWx0ID0gaW1hZ2VPYmo7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmltYWdlT2JqID0gaW1hZ2VPYmo7XG4gICAgICAgIHRoaXMuaW1hZ2VPYmpBbHQgPSBpbWFnZU9iakFsdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgc2VsZWN0aW9uIGFuZCBzd2l0Y2ggYmV0d2VlbiB0aGUgYmFzZSBhbmQgdGhlIHNlbGVjdGVkIGltYWdlLlxuICAgICAqXG4gICAgICogRG8gdGhlIHN3aXRjaCBvbmx5IGlmIGltYWdlT2JqQWx0IGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWQgdmFsdWUgb2YgbmV3IHNlbGVjdGVkIHN0YXRlIGZvciBjdXJyZW50IG5vZGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc3dpdGNoSW1hZ2VzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3dpdGNoSW1hZ2VzKHNlbGVjdGVkKSB7XG4gICAgICB2YXIgc2VsZWN0aW9uX2NoYW5nZWQgPSBzZWxlY3RlZCAmJiAhdGhpcy5zZWxlY3RlZCB8fCAhc2VsZWN0ZWQgJiYgdGhpcy5zZWxlY3RlZDtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSBzZWxlY3RlZDsgLy8gUmVtZW1iZXIgbmV3IHNlbGVjdGlvblxuXG4gICAgICBpZiAodGhpcy5pbWFnZU9iakFsdCAhPT0gdW5kZWZpbmVkICYmIHNlbGVjdGlvbl9jaGFuZ2VkKSB7XG4gICAgICAgIHZhciBpbWFnZVRtcCA9IHRoaXMuaW1hZ2VPYmo7XG4gICAgICAgIHRoaXMuaW1hZ2VPYmogPSB0aGlzLmltYWdlT2JqQWx0O1xuICAgICAgICB0aGlzLmltYWdlT2JqQWx0ID0gaW1hZ2VUbXA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRqdXN0IHRoZSBub2RlIGRpbWVuc2lvbnMgZm9yIGEgbG9hZGVkIGltYWdlLlxuICAgICAqXG4gICAgICogUHJlOiB0aGlzLmltYWdlT2JqIGlzIHZhbGlkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19yZXNpemVJbWFnZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXNpemVJbWFnZSgpIHtcbiAgICAgIHZhciB3aWR0aCwgaGVpZ2h0O1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy51c2VJbWFnZVNpemUgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIFVzZSB0aGUgc2l6ZSBwcm9wZXJ0eVxuICAgICAgICB2YXIgcmF0aW9fd2lkdGggPSAxO1xuICAgICAgICB2YXIgcmF0aW9faGVpZ2h0ID0gMTtcblxuICAgICAgICAvLyBPbmx5IGNhbGN1bGF0ZSB0aGUgcHJvcGVyIHJhdGlvIGlmIGJvdGggd2lkdGggYW5kIGhlaWdodCBub3QgemVyb1xuICAgICAgICBpZiAodGhpcy5pbWFnZU9iai53aWR0aCAmJiB0aGlzLmltYWdlT2JqLmhlaWdodCkge1xuICAgICAgICAgIGlmICh0aGlzLmltYWdlT2JqLndpZHRoID4gdGhpcy5pbWFnZU9iai5oZWlnaHQpIHtcbiAgICAgICAgICAgIHJhdGlvX3dpZHRoID0gdGhpcy5pbWFnZU9iai53aWR0aCAvIHRoaXMuaW1hZ2VPYmouaGVpZ2h0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByYXRpb19oZWlnaHQgPSB0aGlzLmltYWdlT2JqLmhlaWdodCAvIHRoaXMuaW1hZ2VPYmoud2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgd2lkdGggPSB0aGlzLm9wdGlvbnMuc2l6ZSAqIDIgKiByYXRpb193aWR0aDtcbiAgICAgICAgaGVpZ2h0ID0gdGhpcy5vcHRpb25zLnNpemUgKiAyICogcmF0aW9faGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVXNlIHRoZSBpbWFnZSBzaXplXG4gICAgICAgIHdpZHRoID0gdGhpcy5pbWFnZU9iai53aWR0aDtcbiAgICAgICAgaGVpZ2h0ID0gdGhpcy5pbWFnZU9iai5oZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgdGhpcy5yYWRpdXMgPSAwLjUgKiB0aGlzLndpZHRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19kcmF3UmF3Q2lyY2xlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdSYXdDaXJjbGUoY3R4LCB4LCB5LCB2YWx1ZXMpIHtcbiAgICAgIHRoaXMuaW5pdENvbnRleHRGb3JEcmF3KGN0eCwgdmFsdWVzKTtcbiAgICAgIGN0eC5jaXJjbGUoeCwgeSwgdmFsdWVzLnNpemUpO1xuICAgICAgdGhpcy5wZXJmb3JtRmlsbChjdHgsIHZhbHVlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19kcmF3SW1hZ2VBdFBvc2l0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdJbWFnZUF0UG9zaXRpb24oY3R4LCB2YWx1ZXMpIHtcbiAgICAgIGlmICh0aGlzLmltYWdlT2JqLndpZHRoICE9IDApIHtcbiAgICAgICAgLy8gZHJhdyB0aGUgaW1hZ2VcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMS4wO1xuXG4gICAgICAgIC8vIGRyYXcgc2hhZG93IGlmIGVuYWJsZWRcbiAgICAgICAgdGhpcy5lbmFibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuXG4gICAgICAgIHZhciBmYWN0b3IgPSAxO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5pbnRlcnBvbGF0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgZmFjdG9yID0gdGhpcy5pbWFnZU9iai53aWR0aCAvIHRoaXMud2lkdGggLyB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW1hZ2VPYmouZHJhd0ltYWdlQXRQb3NpdGlvbihjdHgsIGZhY3RvciwgdGhpcy5sZWZ0LCB0aGlzLnRvcCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXG4gICAgICAgIC8vIGRpc2FibGUgc2hhZG93cyBmb3Igb3RoZXIgZWxlbWVudHMuXG4gICAgICAgIHRoaXMuZGlzYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19kcmF3SW1hZ2VMYWJlbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3SW1hZ2VMYWJlbChjdHgsIHgsIHksIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgdmFyIHlMYWJlbDtcbiAgICAgIHZhciBvZmZzZXQgPSAwO1xuXG4gICAgICBpZiAodGhpcy5oZWlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvZmZzZXQgPSB0aGlzLmhlaWdodCAqIDAuNTtcbiAgICAgICAgdmFyIGxhYmVsRGltZW5zaW9ucyA9IHRoaXMubGFiZWxNb2R1bGUuZ2V0VGV4dFNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgICBpZiAobGFiZWxEaW1lbnNpb25zLmxpbmVDb3VudCA+PSAxKSB7XG4gICAgICAgICAgb2Zmc2V0ICs9IGxhYmVsRGltZW5zaW9ucy5oZWlnaHQgLyAyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHlMYWJlbCA9IHkgKyBvZmZzZXQ7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubGFiZWwpIHtcbiAgICAgICAgdGhpcy5sYWJlbE9mZnNldCA9IG9mZnNldDtcbiAgICAgIH1cbiAgICAgIHRoaXMubGFiZWxNb2R1bGUuZHJhdyhjdHgsIHgsIHlMYWJlbCwgc2VsZWN0ZWQsIGhvdmVyLCAnaGFuZ2luZycpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ2lyY2xlSW1hZ2VCYXNlO1xufShfTm9kZUJhc2UzWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBDaXJjbGVJbWFnZUJhc2U7XG5cbi8qKiovIH0pLFxuLyogNTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucHJpbnRTdHlsZSA9IHVuZGVmaW5lZDtcblxudmFyIF9zdHJpbmdpZnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcblxudmFyIF9zdHJpbmdpZnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RyaW5naWZ5KTtcblxudmFyIF90eXBlb2YyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxudmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mMik7XG5cbnZhciBfa2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBfa2V5czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9rZXlzKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIGVycm9yRm91bmQgPSBmYWxzZTtcbnZhciBhbGxPcHRpb25zID0gdm9pZCAwO1xudmFyIHByaW50U3R5bGUgPSAnYmFja2dyb3VuZDogI0ZGZWVlZTsgY29sb3I6ICNkZDAwMDAnO1xuLyoqXG4gKiAgVXNlZCB0byB2YWxpZGF0ZSBvcHRpb25zLlxuICovXG5cbnZhciBWYWxpZGF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBmdW5jdGlvbiBWYWxpZGF0b3IoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgVmFsaWRhdG9yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWluIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gcmVmZXJlbmNlT3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gc3ViT2JqZWN0XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKiBAc3RhdGljXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoVmFsaWRhdG9yLCBudWxsLCBbe1xuICAgIGtleTogJ3ZhbGlkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGUob3B0aW9ucywgcmVmZXJlbmNlT3B0aW9ucywgc3ViT2JqZWN0KSB7XG4gICAgICBlcnJvckZvdW5kID0gZmFsc2U7XG4gICAgICBhbGxPcHRpb25zID0gcmVmZXJlbmNlT3B0aW9ucztcbiAgICAgIHZhciB1c2VkT3B0aW9ucyA9IHJlZmVyZW5jZU9wdGlvbnM7XG4gICAgICBpZiAoc3ViT2JqZWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXNlZE9wdGlvbnMgPSByZWZlcmVuY2VPcHRpb25zW3N1Yk9iamVjdF07XG4gICAgICB9XG4gICAgICBWYWxpZGF0b3IucGFyc2Uob3B0aW9ucywgdXNlZE9wdGlvbnMsIFtdKTtcbiAgICAgIHJldHVybiBlcnJvckZvdW5kO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdpbGwgdHJhdmVyc2UgYW4gb2JqZWN0IHJlY3Vyc2l2ZWx5IGFuZCBjaGVjayBldmVyeSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlZmVyZW5jZU9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBwYXRoICAgIHwgd2hlcmUgdG8gbG9vayBmb3IgdGhlIGFjdHVhbCBvcHRpb25cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3BhcnNlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2Uob3B0aW9ucywgcmVmZXJlbmNlT3B0aW9ucywgcGF0aCkge1xuICAgICAgZm9yICh2YXIgb3B0aW9uIGluIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkob3B0aW9uKSkge1xuICAgICAgICAgIFZhbGlkYXRvci5jaGVjayhvcHRpb24sIG9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbnMsIHBhdGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgZXZlcnkgdmFsdWUuIElmIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3QsIGNhbGwgdGhlIHBhcnNlIGZ1bmN0aW9uIG9uIHRoYXQgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWZlcmVuY2VPcHRpb25zXG4gICAgICogQHBhcmFtIHthcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdjaGVjaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrKG9wdGlvbiwgb3B0aW9ucywgcmVmZXJlbmNlT3B0aW9ucywgcGF0aCkge1xuICAgICAgaWYgKHJlZmVyZW5jZU9wdGlvbnNbb3B0aW9uXSA9PT0gdW5kZWZpbmVkICYmIHJlZmVyZW5jZU9wdGlvbnMuX19hbnlfXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIFZhbGlkYXRvci5nZXRTdWdnZXN0aW9uKG9wdGlvbiwgcmVmZXJlbmNlT3B0aW9ucywgcGF0aCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZmVyZW5jZU9wdGlvbiA9IG9wdGlvbjtcbiAgICAgIHZhciBpc19vYmplY3QgPSB0cnVlO1xuXG4gICAgICBpZiAocmVmZXJlbmNlT3B0aW9uc1tvcHRpb25dID09PSB1bmRlZmluZWQgJiYgcmVmZXJlbmNlT3B0aW9ucy5fX2FueV9fICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTk9URTogVGhpcyBvbmx5IHRyaWdnZXJzIGlmIHRoZSBfX2FueV9fIGlzIGluIHRoZSB0b3AgbGV2ZWwgb2YgdGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAgICAvLyAgICAgICBUSEFUJ1MgQSBSRUFMTFkgQkFEIFBMQUNFIFRPIEFMTE9XIElUISEhIVxuICAgICAgICAvLyBUT0RPOiBFeGFtaW5lIGlmIG5lZWRlZCwgcmVtb3ZlIGlmIHBvc3NpYmxlXG5cbiAgICAgICAgLy8gX19hbnlfXyBpcyBhIHdpbGRjYXJkLiBBbnkgdmFsdWUgaXMgYWNjZXB0ZWQgYW5kIHdpbGwgYmUgZnVydGhlciBhbmFseXNlZCBieSByZWZlcmVuY2UuXG4gICAgICAgIHJlZmVyZW5jZU9wdGlvbiA9ICdfX2FueV9fJztcblxuICAgICAgICAvLyBpZiB0aGUgYW55LXN1Ymdyb3VwIGlzIG5vdCBhIHByZWRlZmluZWQgb2JqZWN0IGluIHRoZSBjb25maWd1cmF0b3IsXG4gICAgICAgIC8vIHdlIGRvIG5vdCBsb29rIGRlZXBlciBpbnRvIHRoZSBvYmplY3QuXG4gICAgICAgIGlzX29iamVjdCA9IFZhbGlkYXRvci5nZXRUeXBlKG9wdGlvbnNbb3B0aW9uXSkgPT09ICdvYmplY3QnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2luY2UgYWxsIG9wdGlvbnMgaW4gdGhlIHJlZmVyZW5jZSBhcmUgb2JqZWN0cywgd2UgY2FuIGNoZWNrIHdoZXRoZXJcbiAgICAgICAgLy8gdGhleSBhcmUgc3VwcG9zZWQgdG8gYmUgdGhlIG9iamVjdCB0byBsb29rIGZvciB0aGUgX190eXBlX18gZmllbGQuXG4gICAgICAgIC8vIGlmIHRoaXMgaXMgYW4gb2JqZWN0LCB3ZSBjaGVjayBpZiB0aGUgY29ycmVjdCB0eXBlIGhhcyBiZWVuIHN1cHBsaWVkIHRvIGFjY291bnQgZm9yIHNob3J0aGFuZCBvcHRpb25zLlxuICAgICAgfVxuXG4gICAgICB2YXIgcmVmT3B0aW9uT2JqID0gcmVmZXJlbmNlT3B0aW9uc1tyZWZlcmVuY2VPcHRpb25dO1xuICAgICAgaWYgKGlzX29iamVjdCAmJiByZWZPcHRpb25PYmouX190eXBlX18gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZWZPcHRpb25PYmogPSByZWZPcHRpb25PYmouX190eXBlX187XG4gICAgICB9XG5cbiAgICAgIFZhbGlkYXRvci5jaGVja0ZpZWxkcyhvcHRpb24sIG9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbiwgcmVmT3B0aW9uT2JqLCBwYXRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgb3B0aW9uICAgICAgICAgICB8IHRoZSBvcHRpb24gcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gIG9wdGlvbnMgICAgICAgICAgfCBUaGUgc3VwcGxpZWQgb3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gIHJlZmVyZW5jZU9wdGlvbnMgfCBUaGUgcmVmZXJlbmNlIG9wdGlvbnMgY29udGFpbmluZyBhbGwgb3B0aW9ucyBhbmQgdGhlaXIgYWxsb3dlZCBmb3JtYXRzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9ICByZWZlcmVuY2VPcHRpb24gIHwgVXN1YWxseSB0aGlzIGlzIHRoZSBzYW1lIGFzIG9wdGlvbiwgZXhjZXB0IHdoZW4gaGFuZGxpbmcgYW4gX19hbnlfXyB0YWcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9ICByZWZPcHRpb25PYmogICAgIHwgVGhpcyBpcyB0aGUgdHlwZSBvYmplY3QgZnJvbSB0aGUgcmVmZXJlbmNlIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgIHBhdGggICAgICAgICAgICAgfCB3aGVyZSBpbiB0aGUgb2JqZWN0IGlzIHRoZSBvcHRpb25cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2NoZWNrRmllbGRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tGaWVsZHMob3B0aW9uLCBvcHRpb25zLCByZWZlcmVuY2VPcHRpb25zLCByZWZlcmVuY2VPcHRpb24sIHJlZk9wdGlvbk9iaiwgcGF0aCkge1xuICAgICAgdmFyIGxvZyA9IGZ1bmN0aW9uIGxvZyhtZXNzYWdlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCclYycgKyBtZXNzYWdlICsgVmFsaWRhdG9yLnByaW50TG9jYXRpb24ocGF0aCwgb3B0aW9uKSwgcHJpbnRTdHlsZSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgb3B0aW9uVHlwZSA9IFZhbGlkYXRvci5nZXRUeXBlKG9wdGlvbnNbb3B0aW9uXSk7XG4gICAgICB2YXIgcmVmT3B0aW9uVHlwZSA9IHJlZk9wdGlvbk9ialtvcHRpb25UeXBlXTtcblxuICAgICAgaWYgKHJlZk9wdGlvblR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBpZiB0aGUgdHlwZSBpcyBjb3JyZWN0LCB3ZSBjaGVjayBpZiBpdCBpcyBzdXBwb3NlZCB0byBiZSBvbmUgb2YgYSBmZXcgc2VsZWN0IHZhbHVlc1xuICAgICAgICBpZiAoVmFsaWRhdG9yLmdldFR5cGUocmVmT3B0aW9uVHlwZSkgPT09ICdhcnJheScgJiYgcmVmT3B0aW9uVHlwZS5pbmRleE9mKG9wdGlvbnNbb3B0aW9uXSkgPT09IC0xKSB7XG4gICAgICAgICAgbG9nKCdJbnZhbGlkIG9wdGlvbiBkZXRlY3RlZCBpbiBcIicgKyBvcHRpb24gKyAnXCIuJyArICcgQWxsb3dlZCB2YWx1ZXMgYXJlOicgKyBWYWxpZGF0b3IucHJpbnQocmVmT3B0aW9uVHlwZSkgKyAnIG5vdCBcIicgKyBvcHRpb25zW29wdGlvbl0gKyAnXCIuICcpO1xuICAgICAgICAgIGVycm9yRm91bmQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvblR5cGUgPT09ICdvYmplY3QnICYmIHJlZmVyZW5jZU9wdGlvbiAhPT0gJ19fYW55X18nKSB7XG4gICAgICAgICAgcGF0aCA9IHV0aWwuY29weUFuZEV4dGVuZEFycmF5KHBhdGgsIG9wdGlvbik7XG4gICAgICAgICAgVmFsaWRhdG9yLnBhcnNlKG9wdGlvbnNbb3B0aW9uXSwgcmVmZXJlbmNlT3B0aW9uc1tyZWZlcmVuY2VPcHRpb25dLCBwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyZWZPcHRpb25PYmpbJ2FueSddID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gdHlwZSBvZiB0aGUgZmllbGQgaXMgaW5jb3JyZWN0IGFuZCB0aGUgZmllbGQgY2Fubm90IGJlIGFueVxuICAgICAgICBsb2coJ0ludmFsaWQgdHlwZSByZWNlaXZlZCBmb3IgXCInICsgb3B0aW9uICsgJ1wiLiBFeHBlY3RlZDogJyArIFZhbGlkYXRvci5wcmludCgoMCwgX2tleXMyWydkZWZhdWx0J10pKHJlZk9wdGlvbk9iaikpICsgJy4gUmVjZWl2ZWQgWycgKyBvcHRpb25UeXBlICsgJ10gXCInICsgb3B0aW9uc1tvcHRpb25dICsgJ1wiJyk7XG4gICAgICAgIGVycm9yRm91bmQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R8Ym9vbGVhbnxudW1iZXJ8c3RyaW5nfEFycmF5LjxudW1iZXI+fERhdGV8Tm9kZXxNb21lbnR8dW5kZWZpbmVkfG51bGx9IG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRUeXBlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VHlwZShvYmplY3QpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIG9iamVjdCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6ICgwLCBfdHlwZW9mM1snZGVmYXVsdCddKShvYmplY3QpO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKG9iamVjdCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEJvb2xlYW4pIHtcbiAgICAgICAgICByZXR1cm4gJ2Jvb2xlYW4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBOdW1iZXIpIHtcbiAgICAgICAgICByZXR1cm4gJ251bWJlcic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICAgIHJldHVybiAnc3RyaW5nJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3Qubm9kZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiAnZG9tJztcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0Ll9pc0FNb21lbnRPYmplY3QgPT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm4gJ21vbWVudCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdvYmplY3QnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gJ251bWJlcic7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gJ2Jvb2xlYW4nO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gJ3N0cmluZyc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBwYXRoXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRTdWdnZXN0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3VnZ2VzdGlvbihvcHRpb24sIG9wdGlvbnMsIHBhdGgpIHtcbiAgICAgIHZhciBsb2NhbFNlYXJjaCA9IFZhbGlkYXRvci5maW5kSW5PcHRpb25zKG9wdGlvbiwgb3B0aW9ucywgcGF0aCwgZmFsc2UpO1xuICAgICAgdmFyIGdsb2JhbFNlYXJjaCA9IFZhbGlkYXRvci5maW5kSW5PcHRpb25zKG9wdGlvbiwgYWxsT3B0aW9ucywgW10sIHRydWUpO1xuXG4gICAgICB2YXIgbG9jYWxTZWFyY2hUaHJlc2hvbGQgPSA4O1xuICAgICAgdmFyIGdsb2JhbFNlYXJjaFRocmVzaG9sZCA9IDQ7XG5cbiAgICAgIHZhciBtc2cgPSB2b2lkIDA7XG4gICAgICBpZiAobG9jYWxTZWFyY2guaW5kZXhNYXRjaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1zZyA9ICcgaW4gJyArIFZhbGlkYXRvci5wcmludExvY2F0aW9uKGxvY2FsU2VhcmNoLnBhdGgsIG9wdGlvbiwgJycpICsgJ1BlcmhhcHMgaXQgd2FzIGluY29tcGxldGU/IERpZCB5b3UgbWVhbjogXCInICsgbG9jYWxTZWFyY2guaW5kZXhNYXRjaCArICdcIj9cXG5cXG4nO1xuICAgICAgfSBlbHNlIGlmIChnbG9iYWxTZWFyY2guZGlzdGFuY2UgPD0gZ2xvYmFsU2VhcmNoVGhyZXNob2xkICYmIGxvY2FsU2VhcmNoLmRpc3RhbmNlID4gZ2xvYmFsU2VhcmNoLmRpc3RhbmNlKSB7XG4gICAgICAgIG1zZyA9ICcgaW4gJyArIFZhbGlkYXRvci5wcmludExvY2F0aW9uKGxvY2FsU2VhcmNoLnBhdGgsIG9wdGlvbiwgJycpICsgJ1BlcmhhcHMgaXQgd2FzIG1pc3BsYWNlZD8gTWF0Y2hpbmcgb3B0aW9uIGZvdW5kIGF0OiAnICsgVmFsaWRhdG9yLnByaW50TG9jYXRpb24oZ2xvYmFsU2VhcmNoLnBhdGgsIGdsb2JhbFNlYXJjaC5jbG9zZXN0TWF0Y2gsICcnKTtcbiAgICAgIH0gZWxzZSBpZiAobG9jYWxTZWFyY2guZGlzdGFuY2UgPD0gbG9jYWxTZWFyY2hUaHJlc2hvbGQpIHtcbiAgICAgICAgbXNnID0gJy4gRGlkIHlvdSBtZWFuIFwiJyArIGxvY2FsU2VhcmNoLmNsb3Nlc3RNYXRjaCArICdcIj8nICsgVmFsaWRhdG9yLnByaW50TG9jYXRpb24obG9jYWxTZWFyY2gucGF0aCwgb3B0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1zZyA9ICcuIERpZCB5b3UgbWVhbiBvbmUgb2YgdGhlc2U6ICcgKyBWYWxpZGF0b3IucHJpbnQoKDAsIF9rZXlzMlsnZGVmYXVsdCddKShvcHRpb25zKSkgKyBWYWxpZGF0b3IucHJpbnRMb2NhdGlvbihwYXRoLCBvcHRpb24pO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZygnJWNVbmtub3duIG9wdGlvbiBkZXRlY3RlZDogXCInICsgb3B0aW9uICsgJ1wiJyArIG1zZywgcHJpbnRTdHlsZSk7XG4gICAgICBlcnJvckZvdW5kID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0cmF2ZXJzZSB0aGUgb3B0aW9ucyBpbiBzZWFyY2ggZm9yIGEgbWF0Y2guXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmVjdXJzaXZlPWZhbHNlXVxuICAgICAqIEByZXR1cm5zIHt7Y2xvc2VzdE1hdGNoOiBzdHJpbmcsIHBhdGg6IEFycmF5LCBkaXN0YW5jZTogbnVtYmVyfX1cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2ZpbmRJbk9wdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kSW5PcHRpb25zKG9wdGlvbiwgb3B0aW9ucywgcGF0aCkge1xuICAgICAgdmFyIHJlY3Vyc2l2ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG5cbiAgICAgIHZhciBtaW4gPSAxZTk7XG4gICAgICB2YXIgY2xvc2VzdE1hdGNoID0gJyc7XG4gICAgICB2YXIgY2xvc2VzdE1hdGNoUGF0aCA9IFtdO1xuICAgICAgdmFyIGxvd2VyQ2FzZU9wdGlvbiA9IG9wdGlvbi50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIGluZGV4TWF0Y2ggPSB1bmRlZmluZWQ7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ3VhcmQtZm9yLWluXG4gICAgICBmb3IgKHZhciBvcCBpbiBvcHRpb25zKSB7XG4gICAgICAgIHZhciBkaXN0YW5jZSA9IHZvaWQgMDtcbiAgICAgICAgaWYgKG9wdGlvbnNbb3BdLl9fdHlwZV9fICE9PSB1bmRlZmluZWQgJiYgcmVjdXJzaXZlID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IFZhbGlkYXRvci5maW5kSW5PcHRpb25zKG9wdGlvbiwgb3B0aW9uc1tvcF0sIHV0aWwuY29weUFuZEV4dGVuZEFycmF5KHBhdGgsIG9wKSk7XG4gICAgICAgICAgaWYgKG1pbiA+IHJlc3VsdC5kaXN0YW5jZSkge1xuICAgICAgICAgICAgY2xvc2VzdE1hdGNoID0gcmVzdWx0LmNsb3Nlc3RNYXRjaDtcbiAgICAgICAgICAgIGNsb3Nlc3RNYXRjaFBhdGggPSByZXN1bHQucGF0aDtcbiAgICAgICAgICAgIG1pbiA9IHJlc3VsdC5kaXN0YW5jZTtcbiAgICAgICAgICAgIGluZGV4TWF0Y2ggPSByZXN1bHQuaW5kZXhNYXRjaDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG9wLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihsb3dlckNhc2VPcHRpb24pICE9PSAtMSkge1xuICAgICAgICAgICAgaW5kZXhNYXRjaCA9IG9wO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkaXN0YW5jZSA9IFZhbGlkYXRvci5sZXZlbnNodGVpbkRpc3RhbmNlKG9wdGlvbiwgb3ApO1xuICAgICAgICAgIGlmIChtaW4gPiBkaXN0YW5jZSkge1xuICAgICAgICAgICAgY2xvc2VzdE1hdGNoID0gb3A7XG4gICAgICAgICAgICBjbG9zZXN0TWF0Y2hQYXRoID0gdXRpbC5jb3B5QXJyYXkocGF0aCk7XG4gICAgICAgICAgICBtaW4gPSBkaXN0YW5jZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNsb3Nlc3RNYXRjaDogY2xvc2VzdE1hdGNoLFxuICAgICAgICBwYXRoOiBjbG9zZXN0TWF0Y2hQYXRoLFxuICAgICAgICBkaXN0YW5jZTogbWluLFxuICAgICAgICBpbmRleE1hdGNoOiBpbmRleE1hdGNoXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IHBhdGhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwcmludExvY2F0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJpbnRMb2NhdGlvbihwYXRoLCBvcHRpb24pIHtcbiAgICAgIHZhciBwcmVmaXggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICdQcm9ibGVtIHZhbHVlIGZvdW5kIGF0OiBcXG4nO1xuXG4gICAgICB2YXIgc3RyID0gJ1xcblxcbicgKyBwcmVmaXggKyAnb3B0aW9ucyA9IHtcXG4nO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaSArIDE7IGorKykge1xuICAgICAgICAgIHN0ciArPSAnICAnO1xuICAgICAgICB9XG4gICAgICAgIHN0ciArPSBwYXRoW2ldICsgJzoge1xcbic7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgcGF0aC5sZW5ndGggKyAxOyBfaisrKSB7XG4gICAgICAgIHN0ciArPSAnICAnO1xuICAgICAgfVxuICAgICAgc3RyICs9IG9wdGlvbiArICdcXG4nO1xuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHBhdGgubGVuZ3RoICsgMTsgX2krKykge1xuICAgICAgICBmb3IgKHZhciBfajIgPSAwOyBfajIgPCBwYXRoLmxlbmd0aCAtIF9pOyBfajIrKykge1xuICAgICAgICAgIHN0ciArPSAnICAnO1xuICAgICAgICB9XG4gICAgICAgIHN0ciArPSAnfVxcbic7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyICsgJ1xcblxcbic7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJpbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmludChvcHRpb25zKSB7XG4gICAgICByZXR1cm4gKDAsIF9zdHJpbmdpZnkyWydkZWZhdWx0J10pKG9wdGlvbnMpLnJlcGxhY2UoLyhcXFwiKXwoXFxbKXwoXFxdKXwoLFwiX190eXBlX19cIikvZywgJycpLnJlcGxhY2UoLyhcXCwpL2csICcsICcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBDb21wdXRlIHRoZSBlZGl0IGRpc3RhbmNlIGJldHdlZW4gdGhlIHR3byBnaXZlbiBzdHJpbmdzXG4gICAgICogaHR0cDovL2VuLndpa2lib29rcy5vcmcvd2lraS9BbGdvcml0aG1fSW1wbGVtZW50YXRpb24vU3RyaW5ncy9MZXZlbnNodGVpbl9kaXN0YW5jZSNKYXZhU2NyaXB0XG4gICAgICpcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMTEgQW5kcmVpIE1hY2tlbnppZVxuICAgICAqXG4gICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgKlxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICAgICAqXG4gICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiXG4gICAgICogQHJldHVybnMge0FycmF5LjxBcnJheS48bnVtYmVyPj59fVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbGV2ZW5zaHRlaW5EaXN0YW5jZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxldmVuc2h0ZWluRGlzdGFuY2UoYSwgYikge1xuICAgICAgaWYgKGEubGVuZ3RoID09PSAwKSByZXR1cm4gYi5sZW5ndGg7XG4gICAgICBpZiAoYi5sZW5ndGggPT09IDApIHJldHVybiBhLmxlbmd0aDtcblxuICAgICAgdmFyIG1hdHJpeCA9IFtdO1xuXG4gICAgICAvLyBpbmNyZW1lbnQgYWxvbmcgdGhlIGZpcnN0IGNvbHVtbiBvZiBlYWNoIHJvd1xuICAgICAgdmFyIGk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDw9IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWF0cml4W2ldID0gW2ldO1xuICAgICAgfVxuXG4gICAgICAvLyBpbmNyZW1lbnQgZWFjaCBjb2x1bW4gaW4gdGhlIGZpcnN0IHJvd1xuICAgICAgdmFyIGo7XG4gICAgICBmb3IgKGogPSAwOyBqIDw9IGEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgbWF0cml4WzBdW2pdID0gajtcbiAgICAgIH1cblxuICAgICAgLy8gRmlsbCBpbiB0aGUgcmVzdCBvZiB0aGUgbWF0cml4XG4gICAgICBmb3IgKGkgPSAxOyBpIDw9IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yIChqID0gMTsgaiA8PSBhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgaWYgKGIuY2hhckF0KGkgLSAxKSA9PSBhLmNoYXJBdChqIC0gMSkpIHtcbiAgICAgICAgICAgIG1hdHJpeFtpXVtqXSA9IG1hdHJpeFtpIC0gMV1baiAtIDFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXRyaXhbaV1bal0gPSBNYXRoLm1pbihtYXRyaXhbaSAtIDFdW2ogLSAxXSArIDEsIC8vIHN1YnN0aXR1dGlvblxuICAgICAgICAgICAgTWF0aC5taW4obWF0cml4W2ldW2ogLSAxXSArIDEsIC8vIGluc2VydGlvblxuICAgICAgICAgICAgbWF0cml4W2kgLSAxXVtqXSArIDEpKTsgLy8gZGVsZXRpb25cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hdHJpeFtiLmxlbmd0aF1bYS5sZW5ndGhdO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVmFsaWRhdG9yO1xufSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBWYWxpZGF0b3I7XG5leHBvcnRzLnByaW50U3R5bGUgPSBwcmludFN0eWxlO1xuXG4vKioqLyB9KSxcbi8qIDU1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfc3RyaW5naWZ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG5cbnZhciBfc3RyaW5naWZ5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N0cmluZ2lmeSk7XG5cbnZhciBfdHlwZW9mMiA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbnZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXG52YXIgX2NyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xuXG52YXIgX2NyZWF0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGUpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xudmFyIExhYmVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NylbJ2RlZmF1bHQnXTtcbnZhciBDb21wb25lbnRVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSlbJ2RlZmF1bHQnXTtcbnZhciBDdWJpY0JlemllckVkZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2NilbJ2RlZmF1bHQnXTtcbnZhciBCZXppZXJFZGdlRHluYW1pYyA9IF9fd2VicGFja19yZXF1aXJlX18oMTY4KVsnZGVmYXVsdCddO1xudmFyIEJlemllckVkZ2VTdGF0aWMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2OSlbJ2RlZmF1bHQnXTtcbnZhciBTdHJhaWdodEVkZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3MClbJ2RlZmF1bHQnXTtcblxuLyoqXG4gKiBBbiBlZGdlIGNvbm5lY3RzIHR3byBub2RlcyBhbmQgaGFzIGEgc3BlY2lmaWMgZGlyZWN0aW9uLlxuICovXG5cbnZhciBFZGdlID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgICAgICAgIHZhbHVlcyBzcGVjaWZpYyB0byB0aGlzIGVkZ2UsIG11c3QgY29udGFpbiBhdCBsZWFzdCAnZnJvbScgYW5kICd0bydcbiAgICogQHBhcmFtIHtPYmplY3R9IGJvZHkgICAgICAgICAgIHNoYXJlZCBzdGF0ZSBmcm9tIE5ldHdvcmsgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGdsb2JhbE9wdGlvbnMgIG9wdGlvbnMgZnJvbSB0aGUgRWRnZXNIYW5kbGVyIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0T3B0aW9ucyBkZWZhdWx0IG9wdGlvbnMgZnJvbSB0aGUgRWRnZUhhbmRsZXIgaW5zdGFuY2UuIFZhbHVlIGFuZCByZWZlcmVuY2UgYXJlIGNvbnN0YW50XG4gICAqL1xuICBmdW5jdGlvbiBFZGdlKG9wdGlvbnMsIGJvZHksIGdsb2JhbE9wdGlvbnMsIGRlZmF1bHRPcHRpb25zKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgRWRnZSk7XG5cbiAgICBpZiAoYm9keSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGJvZHkgcHJvdmlkZWQnKTtcbiAgICB9XG5cbiAgICAvLyBTaW5jZSBnbG9iYWxPcHRpb25zIGlzIGNvbnN0YW50IGluIHZhbHVlcyBhcyB3ZWxsIGFzIHJlZmVyZW5jZSxcbiAgICAvLyBGb2xsb3dpbmcgbmVlZHMgdG8gYmUgZG9uZSBvbmx5IG9uY2UuXG5cbiAgICB0aGlzLm9wdGlvbnMgPSB1dGlsLmJyaWRnZU9iamVjdChnbG9iYWxPcHRpb25zKTtcbiAgICB0aGlzLmdsb2JhbE9wdGlvbnMgPSBnbG9iYWxPcHRpb25zO1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuXG4gICAgLy8gaW5pdGlhbGl6ZSB2YXJpYWJsZXNcbiAgICB0aGlzLmlkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZnJvbUlkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudG9JZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5ob3ZlciA9IGZhbHNlO1xuICAgIHRoaXMubGFiZWxEaXJ0eSA9IHRydWU7XG5cbiAgICB0aGlzLmJhc2VXaWR0aCA9IHRoaXMub3B0aW9ucy53aWR0aDtcbiAgICB0aGlzLmJhc2VGb250U2l6ZSA9IHRoaXMub3B0aW9ucy5mb250LnNpemU7XG5cbiAgICB0aGlzLmZyb20gPSB1bmRlZmluZWQ7IC8vIGEgbm9kZVxuICAgIHRoaXMudG8gPSB1bmRlZmluZWQ7IC8vIGEgbm9kZVxuXG4gICAgdGhpcy5lZGdlVHlwZSA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG5cbiAgICB0aGlzLmxhYmVsTW9kdWxlID0gbmV3IExhYmVsKHRoaXMuYm9keSwgdGhpcy5vcHRpb25zLCB0cnVlIC8qIEl0J3MgYW4gZWRnZSBsYWJlbCAqL1xuICAgICk7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBvciBvdmVyd3JpdGUgb3B0aW9ucyBmb3IgdGhlIGVkZ2VcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgIGFuIG9iamVjdCB3aXRoIG9wdGlvbnNcbiAgICogQHJldHVybnMge251bGx8Ym9vbGVhbn0gbnVsbCBpZiBubyBvcHRpb25zLCBib29sZWFuIGlmIGRhdGUgY2hhbmdlZFxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKEVkZ2UsIFt7XG4gICAga2V5OiAnc2V0T3B0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgRWRnZS5wYXJzZU9wdGlvbnModGhpcy5vcHRpb25zLCBvcHRpb25zLCB0cnVlLCB0aGlzLmdsb2JhbE9wdGlvbnMpO1xuXG4gICAgICBpZiAob3B0aW9ucy5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuaWQgPSBvcHRpb25zLmlkO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuZnJvbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZnJvbUlkID0gb3B0aW9ucy5mcm9tO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMudG8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnRvSWQgPSBvcHRpb25zLnRvO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMudGl0bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnRpdGxlID0gb3B0aW9ucy50aXRsZTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy52YWx1ZSA9IHBhcnNlRmxvYXQob3B0aW9ucy52YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwaWxlID0gW29wdGlvbnMsIHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9uc107XG4gICAgICB0aGlzLmNob29zZXIgPSBDb21wb25lbnRVdGlsLmNob29zaWZ5KCdlZGdlJywgcGlsZSk7XG5cbiAgICAgIC8vIHVwZGF0ZSBsYWJlbCBNb2R1bGVcbiAgICAgIHRoaXMudXBkYXRlTGFiZWxNb2R1bGUob3B0aW9ucyk7XG5cbiAgICAgIHZhciBkYXRhQ2hhbmdlZCA9IHRoaXMudXBkYXRlRWRnZVR5cGUoKTtcblxuICAgICAgLy8gaWYgYW55dGhpbmcgaGFzIGJlZW4gdXBkYXRlcywgcmVzZXQgdGhlIHNlbGVjdGlvbiB3aWR0aCBhbmQgdGhlIGhvdmVyIHdpZHRoXG4gICAgICB0aGlzLl9zZXRJbnRlcmFjdGlvbldpZHRocygpO1xuXG4gICAgICAvLyBBIG5vZGUgaXMgY29ubmVjdGVkIHdoZW4gaXQgaGFzIGEgZnJvbSBhbmQgdG8gbm9kZSB0aGF0IGJvdGggZXhpc3QgaW4gdGhlIG5ldHdvcmsuYm9keS5ub2Rlcy5cbiAgICAgIHRoaXMuY29ubmVjdCgpO1xuXG4gICAgICBpZiAob3B0aW9ucy5oaWRkZW4gIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnBoeXNpY3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkYXRhQ2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhQ2hhbmdlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnRPcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5ld09wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthbGxvd0RlbGV0aW9uPWZhbHNlXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZ2xvYmFsT3B0aW9ucz17fV1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjb3B5RnJvbUdsb2JhbHM9ZmFsc2VdXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldEZvcm1hdHRpbmdWYWx1ZXMnLFxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBcnJvd09wdGlvbnN9XG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZvcm1hdHRpbmdWYWx1ZXMoKSB7XG4gICAgICB2YXIgdG9BcnJvdyA9IHRoaXMub3B0aW9ucy5hcnJvd3MudG8gPT09IHRydWUgfHwgdGhpcy5vcHRpb25zLmFycm93cy50by5lbmFibGVkID09PSB0cnVlO1xuICAgICAgdmFyIGZyb21BcnJvdyA9IHRoaXMub3B0aW9ucy5hcnJvd3MuZnJvbSA9PT0gdHJ1ZSB8fCB0aGlzLm9wdGlvbnMuYXJyb3dzLmZyb20uZW5hYmxlZCA9PT0gdHJ1ZTtcbiAgICAgIHZhciBtaWRkbGVBcnJvdyA9IHRoaXMub3B0aW9ucy5hcnJvd3MubWlkZGxlID09PSB0cnVlIHx8IHRoaXMub3B0aW9ucy5hcnJvd3MubWlkZGxlLmVuYWJsZWQgPT09IHRydWU7XG4gICAgICB2YXIgaW5oZXJpdHNDb2xvciA9IHRoaXMub3B0aW9ucy5jb2xvci5pbmhlcml0O1xuICAgICAgdmFyIHZhbHVlcyA9IHtcbiAgICAgICAgdG9BcnJvdzogdG9BcnJvdyxcbiAgICAgICAgdG9BcnJvd1NjYWxlOiB0aGlzLm9wdGlvbnMuYXJyb3dzLnRvLnNjYWxlRmFjdG9yLFxuICAgICAgICB0b0Fycm93VHlwZTogdGhpcy5vcHRpb25zLmFycm93cy50by50eXBlLFxuICAgICAgICBtaWRkbGVBcnJvdzogbWlkZGxlQXJyb3csXG4gICAgICAgIG1pZGRsZUFycm93U2NhbGU6IHRoaXMub3B0aW9ucy5hcnJvd3MubWlkZGxlLnNjYWxlRmFjdG9yLFxuICAgICAgICBtaWRkbGVBcnJvd1R5cGU6IHRoaXMub3B0aW9ucy5hcnJvd3MubWlkZGxlLnR5cGUsXG4gICAgICAgIGZyb21BcnJvdzogZnJvbUFycm93LFxuICAgICAgICBmcm9tQXJyb3dTY2FsZTogdGhpcy5vcHRpb25zLmFycm93cy5mcm9tLnNjYWxlRmFjdG9yLFxuICAgICAgICBmcm9tQXJyb3dUeXBlOiB0aGlzLm9wdGlvbnMuYXJyb3dzLmZyb20udHlwZSxcbiAgICAgICAgYXJyb3dTdHJpa2V0aHJvdWdoOiB0aGlzLm9wdGlvbnMuYXJyb3dTdHJpa2V0aHJvdWdoLFxuICAgICAgICBjb2xvcjogaW5oZXJpdHNDb2xvciA/IHVuZGVmaW5lZCA6IHRoaXMub3B0aW9ucy5jb2xvci5jb2xvcixcbiAgICAgICAgaW5oZXJpdHNDb2xvcjogaW5oZXJpdHNDb2xvcixcbiAgICAgICAgb3BhY2l0eTogdGhpcy5vcHRpb25zLmNvbG9yLm9wYWNpdHksXG4gICAgICAgIGhpZGRlbjogdGhpcy5vcHRpb25zLmhpZGRlbixcbiAgICAgICAgbGVuZ3RoOiB0aGlzLm9wdGlvbnMubGVuZ3RoLFxuICAgICAgICBzaGFkb3c6IHRoaXMub3B0aW9ucy5zaGFkb3cuZW5hYmxlZCxcbiAgICAgICAgc2hhZG93Q29sb3I6IHRoaXMub3B0aW9ucy5zaGFkb3cuY29sb3IsXG4gICAgICAgIHNoYWRvd1NpemU6IHRoaXMub3B0aW9ucy5zaGFkb3cuc2l6ZSxcbiAgICAgICAgc2hhZG93WDogdGhpcy5vcHRpb25zLnNoYWRvdy54LFxuICAgICAgICBzaGFkb3dZOiB0aGlzLm9wdGlvbnMuc2hhZG93LnksXG4gICAgICAgIGRhc2hlczogdGhpcy5vcHRpb25zLmRhc2hlcyxcbiAgICAgICAgd2lkdGg6IHRoaXMub3B0aW9ucy53aWR0aCxcbiAgICAgICAgYmFja2dyb3VuZDogdGhpcy5vcHRpb25zLmJhY2tncm91bmQuZW5hYmxlZCxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGlzLm9wdGlvbnMuYmFja2dyb3VuZC5jb2xvcixcbiAgICAgICAgYmFja2dyb3VuZFNpemU6IHRoaXMub3B0aW9ucy5iYWNrZ3JvdW5kLnNpemUsXG4gICAgICAgIGJhY2tncm91bmREYXNoZXM6IHRoaXMub3B0aW9ucy5iYWNrZ3JvdW5kLmRhc2hlc1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkIHx8IHRoaXMuaG92ZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hvb3NlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWRXaWR0aCA9IHRoaXMub3B0aW9ucy5zZWxlY3Rpb25XaWR0aDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0ZWRXaWR0aCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICB2YWx1ZXMud2lkdGggPSBzZWxlY3RlZFdpZHRoKHZhbHVlcy53aWR0aCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxlY3RlZFdpZHRoID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICB2YWx1ZXMud2lkdGggKz0gc2VsZWN0ZWRXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlcy53aWR0aCA9IE1hdGgubWF4KHZhbHVlcy53aWR0aCwgMC4zIC8gdGhpcy5ib2R5LnZpZXcuc2NhbGUpO1xuICAgICAgICAgICAgdmFsdWVzLmNvbG9yID0gdGhpcy5vcHRpb25zLmNvbG9yLmhpZ2hsaWdodDtcbiAgICAgICAgICAgIHZhbHVlcy5zaGFkb3cgPSB0aGlzLm9wdGlvbnMuc2hhZG93LmVuYWJsZWQ7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmhvdmVyKSB7XG4gICAgICAgICAgICB2YXIgaG92ZXJXaWR0aCA9IHRoaXMub3B0aW9ucy5ob3ZlcldpZHRoO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBob3ZlcldpZHRoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHZhbHVlcy53aWR0aCA9IGhvdmVyV2lkdGgodmFsdWVzLndpZHRoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGhvdmVyV2lkdGggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgIHZhbHVlcy53aWR0aCArPSBob3ZlcldpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWVzLndpZHRoID0gTWF0aC5tYXgodmFsdWVzLndpZHRoLCAwLjMgLyB0aGlzLmJvZHkudmlldy5zY2FsZSk7XG4gICAgICAgICAgICB2YWx1ZXMuY29sb3IgPSB0aGlzLm9wdGlvbnMuY29sb3IuaG92ZXI7XG4gICAgICAgICAgICB2YWx1ZXMuc2hhZG93ID0gdGhpcy5vcHRpb25zLnNoYWRvdy5lbmFibGVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5jaG9vc2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhpcy5jaG9vc2VyKHZhbHVlcywgdGhpcy5vcHRpb25zLmlkLCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyKTtcbiAgICAgICAgICBpZiAodmFsdWVzLmNvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbHVlcy5pbmhlcml0c0NvbG9yID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZXMuc2hhZG93ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlcy5zaGFkb3dDb2xvciAhPT0gdGhpcy5vcHRpb25zLnNoYWRvdy5jb2xvciB8fCB2YWx1ZXMuc2hhZG93U2l6ZSAhPT0gdGhpcy5vcHRpb25zLnNoYWRvdy5zaXplIHx8IHZhbHVlcy5zaGFkb3dYICE9PSB0aGlzLm9wdGlvbnMuc2hhZG93LnggfHwgdmFsdWVzLnNoYWRvd1kgIT09IHRoaXMub3B0aW9ucy5zaGFkb3cueSkge1xuICAgICAgICAgICAgICB2YWx1ZXMuc2hhZG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlcy5zaGFkb3cgPSB0aGlzLm9wdGlvbnMuc2hhZG93LmVuYWJsZWQ7XG4gICAgICAgIHZhbHVlcy53aWR0aCA9IE1hdGgubWF4KHZhbHVlcy53aWR0aCwgMC4zIC8gdGhpcy5ib2R5LnZpZXcuc2NhbGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB1cGRhdGUgdGhlIG9wdGlvbnMgaW4gdGhlIGxhYmVsIG1vZHVsZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlTGFiZWxNb2R1bGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVMYWJlbE1vZHVsZShvcHRpb25zKSB7XG4gICAgICB2YXIgcGlsZSA9IFtvcHRpb25zLCB0aGlzLm9wdGlvbnMsIHRoaXMuZ2xvYmFsT3B0aW9ucywgLy8gQ3VycmVudGx5IHNldCBnbG9iYWwgZWRnZSBvcHRpb25zXG4gICAgICB0aGlzLmRlZmF1bHRPcHRpb25zXTtcblxuICAgICAgdGhpcy5sYWJlbE1vZHVsZS51cGRhdGUodGhpcy5vcHRpb25zLCBwaWxlKTtcblxuICAgICAgaWYgKHRoaXMubGFiZWxNb2R1bGUuYmFzZVNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmJhc2VGb250U2l6ZSA9IHRoaXMubGFiZWxNb2R1bGUuYmFzZVNpemU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdXBkYXRlIHRoZSBlZGdlIHR5cGUsIHNldCB0aGUgb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVFZGdlVHlwZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUVkZ2VUeXBlKCkge1xuICAgICAgdmFyIHNtb290aCA9IHRoaXMub3B0aW9ucy5zbW9vdGg7XG4gICAgICB2YXIgZGF0YUNoYW5nZWQgPSBmYWxzZTtcbiAgICAgIHZhciBjaGFuZ2VJblR5cGUgPSB0cnVlO1xuICAgICAgaWYgKHRoaXMuZWRnZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodGhpcy5lZGdlVHlwZSBpbnN0YW5jZW9mIEJlemllckVkZ2VEeW5hbWljICYmIHNtb290aC5lbmFibGVkID09PSB0cnVlICYmIHNtb290aC50eXBlID09PSAnZHluYW1pYycgfHwgdGhpcy5lZGdlVHlwZSBpbnN0YW5jZW9mIEN1YmljQmV6aWVyRWRnZSAmJiBzbW9vdGguZW5hYmxlZCA9PT0gdHJ1ZSAmJiBzbW9vdGgudHlwZSA9PT0gJ2N1YmljQmV6aWVyJyB8fCB0aGlzLmVkZ2VUeXBlIGluc3RhbmNlb2YgQmV6aWVyRWRnZVN0YXRpYyAmJiBzbW9vdGguZW5hYmxlZCA9PT0gdHJ1ZSAmJiBzbW9vdGgudHlwZSAhPT0gJ2R5bmFtaWMnICYmIHNtb290aC50eXBlICE9PSAnY3ViaWNCZXppZXInIHx8IHRoaXMuZWRnZVR5cGUgaW5zdGFuY2VvZiBTdHJhaWdodEVkZ2UgJiYgc21vb3RoLnR5cGUuZW5hYmxlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBjaGFuZ2VJblR5cGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlSW5UeXBlID09PSB0cnVlKSB7XG4gICAgICAgICAgZGF0YUNoYW5nZWQgPSB0aGlzLmNsZWFudXAoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNoYW5nZUluVHlwZSA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAoc21vb3RoLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICBpZiAoc21vb3RoLnR5cGUgPT09ICdkeW5hbWljJykge1xuICAgICAgICAgICAgZGF0YUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5lZGdlVHlwZSA9IG5ldyBCZXppZXJFZGdlRHluYW1pYyh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzbW9vdGgudHlwZSA9PT0gJ2N1YmljQmV6aWVyJykge1xuICAgICAgICAgICAgdGhpcy5lZGdlVHlwZSA9IG5ldyBDdWJpY0JlemllckVkZ2UodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVkZ2VUeXBlID0gbmV3IEJlemllckVkZ2VTdGF0aWModGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmVkZ2VUeXBlID0gbmV3IFN0cmFpZ2h0RWRnZSh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIG5vdGhpbmcgY2hhbmdlcywgd2UganVzdCBzZXQgdGhlIG9wdGlvbnMuXG4gICAgICAgIHRoaXMuZWRnZVR5cGUuc2V0T3B0aW9ucyh0aGlzLm9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFDaGFuZ2VkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbm5lY3QgYW4gZWRnZSB0byBpdHMgbm9kZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY29ubmVjdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbm5lY3QoKSB7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcblxuICAgICAgdGhpcy5mcm9tID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMuZnJvbUlkXSB8fCB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnRvID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMudG9JZF0gfHwgdW5kZWZpbmVkO1xuICAgICAgdGhpcy5jb25uZWN0ZWQgPSB0aGlzLmZyb20gIT09IHVuZGVmaW5lZCAmJiB0aGlzLnRvICE9PSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICh0aGlzLmNvbm5lY3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmZyb20uYXR0YWNoRWRnZSh0aGlzKTtcbiAgICAgICAgdGhpcy50by5hdHRhY2hFZGdlKHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuZnJvbSkge1xuICAgICAgICAgIHRoaXMuZnJvbS5kZXRhY2hFZGdlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRvKSB7XG4gICAgICAgICAgdGhpcy50by5kZXRhY2hFZGdlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWRnZVR5cGUuY29ubmVjdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpc2Nvbm5lY3QgYW4gZWRnZSBmcm9tIGl0cyBub2Rlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkaXNjb25uZWN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzY29ubmVjdCgpIHtcbiAgICAgIGlmICh0aGlzLmZyb20pIHtcbiAgICAgICAgdGhpcy5mcm9tLmRldGFjaEVkZ2UodGhpcyk7XG4gICAgICAgIHRoaXMuZnJvbSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnRvKSB7XG4gICAgICAgIHRoaXMudG8uZGV0YWNoRWRnZSh0aGlzKTtcbiAgICAgICAgdGhpcy50byA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIHRpdGxlIG9mIHRoaXMgZWRnZS5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRpdGxlICAgIFRoZSB0aXRsZSBvZiB0aGUgZWRnZSwgb3IgdW5kZWZpbmVkIHdoZW4gbm8gdGl0bGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhcyBiZWVuIHNldC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0VGl0bGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUaXRsZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRpdGxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNoZWNrIGlmIHRoaXMgbm9kZSBpcyBzZWxlY3RlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gc2VsZWN0ZWQgICBUcnVlIGlmIG5vZGUgaXMgc2VsZWN0ZWQsIGVsc2UgZmFsc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaXNTZWxlY3RlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzU2VsZWN0ZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgdmFsdWUgb2YgdGhlIGVkZ2UuIENhbiBiZSB1bmRlZmluZWRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IHZhbHVlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldFZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkanVzdCB0aGUgdmFsdWUgcmFuZ2Ugb2YgdGhlIGVkZ2UuIFRoZSBlZGdlIHdpbGwgYWRqdXN0IGl0J3Mgd2lkdGhcbiAgICAgKiBiYXNlZCBvbiBpdHMgdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG90YWxcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0VmFsdWVSYW5nZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFZhbHVlUmFuZ2UobWluLCBtYXgsIHRvdGFsKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5vcHRpb25zLnNjYWxpbmcuY3VzdG9tU2NhbGluZ0Z1bmN0aW9uKG1pbiwgbWF4LCB0b3RhbCwgdGhpcy5vcHRpb25zLnZhbHVlKTtcbiAgICAgICAgdmFyIHdpZHRoRGlmZiA9IHRoaXMub3B0aW9ucy5zY2FsaW5nLm1heCAtIHRoaXMub3B0aW9ucy5zY2FsaW5nLm1pbjtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zY2FsaW5nLmxhYmVsLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICB2YXIgZm9udERpZmYgPSB0aGlzLm9wdGlvbnMuc2NhbGluZy5sYWJlbC5tYXggLSB0aGlzLm9wdGlvbnMuc2NhbGluZy5sYWJlbC5taW47XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmZvbnQuc2l6ZSA9IHRoaXMub3B0aW9ucy5zY2FsaW5nLmxhYmVsLm1pbiArIHNjYWxlICogZm9udERpZmY7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zLndpZHRoID0gdGhpcy5vcHRpb25zLnNjYWxpbmcubWluICsgc2NhbGUgKiB3aWR0aERpZmY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9wdGlvbnMud2lkdGggPSB0aGlzLmJhc2VXaWR0aDtcbiAgICAgICAgdGhpcy5vcHRpb25zLmZvbnQuc2l6ZSA9IHRoaXMuYmFzZUZvbnRTaXplO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9zZXRJbnRlcmFjdGlvbldpZHRocygpO1xuICAgICAgdGhpcy51cGRhdGVMYWJlbE1vZHVsZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3NldEludGVyYWN0aW9uV2lkdGhzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldEludGVyYWN0aW9uV2lkdGhzKCkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuaG92ZXJXaWR0aCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLmVkZ2VUeXBlLmhvdmVyV2lkdGggPSB0aGlzLm9wdGlvbnMuaG92ZXJXaWR0aCh0aGlzLm9wdGlvbnMud2lkdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lZGdlVHlwZS5ob3ZlcldpZHRoID0gdGhpcy5vcHRpb25zLmhvdmVyV2lkdGggKyB0aGlzLm9wdGlvbnMud2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5zZWxlY3Rpb25XaWR0aCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLmVkZ2VUeXBlLnNlbGVjdGlvbldpZHRoID0gdGhpcy5vcHRpb25zLnNlbGVjdGlvbldpZHRoKHRoaXMub3B0aW9ucy53aWR0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVkZ2VUeXBlLnNlbGVjdGlvbldpZHRoID0gdGhpcy5vcHRpb25zLnNlbGVjdGlvbldpZHRoICsgdGhpcy5vcHRpb25zLndpZHRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZHJhdyBhIGVkZ2VcbiAgICAgKiBEcmF3IHRoaXMgZWRnZSBpbiB0aGUgZ2l2ZW4gY2FudmFzXG4gICAgICogVGhlIDJkIGNvbnRleHQgb2YgYSBIVE1MIGNhbnZhcyBjYW4gYmUgcmV0cmlldmVkIGJ5IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICAgY3R4XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RyYXcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCkge1xuICAgICAgdmFyIHZhbHVlcyA9IHRoaXMuZ2V0Rm9ybWF0dGluZ1ZhbHVlcygpO1xuICAgICAgaWYgKHZhbHVlcy5oaWRkZW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBnZXQgdGhlIHZpYSBub2RlIGZyb20gdGhlIGVkZ2UgdHlwZVxuICAgICAgdmFyIHZpYU5vZGUgPSB0aGlzLmVkZ2VUeXBlLmdldFZpYU5vZGUoKTtcbiAgICAgIHZhciBhcnJvd0RhdGEgPSB7fTtcblxuICAgICAgLy8gcmVzdG9yZSBlZGdlIHRhcmdldHMgdG8gZGVmYXVsdHNcbiAgICAgIHRoaXMuZWRnZVR5cGUuZnJvbVBvaW50ID0gdGhpcy5lZGdlVHlwZS5mcm9tO1xuICAgICAgdGhpcy5lZGdlVHlwZS50b1BvaW50ID0gdGhpcy5lZGdlVHlwZS50bztcblxuICAgICAgLy8gZnJvbSBhbmQgdG8gYXJyb3dzIGdpdmUgYSBkaWZmZXJlbnQgZW5kIHBvaW50IGZvciBlZGdlcy4gd2Ugc2V0IHRoZW0gaGVyZVxuICAgICAgaWYgKHZhbHVlcy5mcm9tQXJyb3cpIHtcbiAgICAgICAgYXJyb3dEYXRhLmZyb20gPSB0aGlzLmVkZ2VUeXBlLmdldEFycm93RGF0YShjdHgsICdmcm9tJywgdmlhTm9kZSwgdGhpcy5zZWxlY3RlZCwgdGhpcy5ob3ZlciwgdmFsdWVzKTtcbiAgICAgICAgaWYgKHZhbHVlcy5hcnJvd1N0cmlrZXRocm91Z2ggPT09IGZhbHNlKSB0aGlzLmVkZ2VUeXBlLmZyb21Qb2ludCA9IGFycm93RGF0YS5mcm9tLmNvcmU7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWVzLnRvQXJyb3cpIHtcbiAgICAgICAgYXJyb3dEYXRhLnRvID0gdGhpcy5lZGdlVHlwZS5nZXRBcnJvd0RhdGEoY3R4LCAndG8nLCB2aWFOb2RlLCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyLCB2YWx1ZXMpO1xuICAgICAgICBpZiAodmFsdWVzLmFycm93U3RyaWtldGhyb3VnaCA9PT0gZmFsc2UpIHRoaXMuZWRnZVR5cGUudG9Qb2ludCA9IGFycm93RGF0YS50by5jb3JlO1xuICAgICAgfVxuXG4gICAgICAvLyB0aGUgbWlkZGxlIGFycm93IGRlcGVuZHMgb24gdGhlIGxpbmUsIHdoaWNoIGNhbiBkZXBlbmQgb24gdGhlIHRvIGFuZCBmcm9tIGFycm93cyBzbyB3ZSBkbyB0aGlzIG9uZSBsYXN0bHkuXG4gICAgICBpZiAodmFsdWVzLm1pZGRsZUFycm93KSB7XG4gICAgICAgIGFycm93RGF0YS5taWRkbGUgPSB0aGlzLmVkZ2VUeXBlLmdldEFycm93RGF0YShjdHgsICdtaWRkbGUnLCB2aWFOb2RlLCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyLCB2YWx1ZXMpO1xuICAgICAgfVxuXG4gICAgICAvLyBkcmF3IGV2ZXJ5dGhpbmdcbiAgICAgIHRoaXMuZWRnZVR5cGUuZHJhd0xpbmUoY3R4LCB2YWx1ZXMsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIsIHZpYU5vZGUpO1xuICAgICAgdGhpcy5kcmF3QXJyb3dzKGN0eCwgYXJyb3dEYXRhLCB2YWx1ZXMpO1xuICAgICAgdGhpcy5kcmF3TGFiZWwoY3R4LCB2aWFOb2RlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJyb3dEYXRhXG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkcmF3QXJyb3dzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0Fycm93cyhjdHgsIGFycm93RGF0YSwgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWVzLmZyb21BcnJvdykge1xuICAgICAgICB0aGlzLmVkZ2VUeXBlLmRyYXdBcnJvd0hlYWQoY3R4LCB2YWx1ZXMsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIsIGFycm93RGF0YS5mcm9tKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZXMubWlkZGxlQXJyb3cpIHtcbiAgICAgICAgdGhpcy5lZGdlVHlwZS5kcmF3QXJyb3dIZWFkKGN0eCwgdmFsdWVzLCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyLCBhcnJvd0RhdGEubWlkZGxlKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZXMudG9BcnJvdykge1xuICAgICAgICB0aGlzLmVkZ2VUeXBlLmRyYXdBcnJvd0hlYWQoY3R4LCB2YWx1ZXMsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIsIGFycm93RGF0YS50byk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtOb2RlfSB2aWFOb2RlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RyYXdMYWJlbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdMYWJlbChjdHgsIHZpYU5vZGUpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubGFiZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBzZXQgc3R5bGVcbiAgICAgICAgdmFyIG5vZGUxID0gdGhpcy5mcm9tO1xuICAgICAgICB2YXIgbm9kZTIgPSB0aGlzLnRvO1xuXG4gICAgICAgIGlmICh0aGlzLmxhYmVsTW9kdWxlLmRpZmZlcmVudFN0YXRlKHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIpKSB7XG4gICAgICAgICAgdGhpcy5sYWJlbE1vZHVsZS5nZXRUZXh0U2l6ZShjdHgsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vZGUxLmlkICE9IG5vZGUyLmlkKSB7XG4gICAgICAgICAgdGhpcy5sYWJlbE1vZHVsZS5wb2ludFRvU2VsZiA9IGZhbHNlO1xuICAgICAgICAgIHZhciBwb2ludCA9IHRoaXMuZWRnZVR5cGUuZ2V0UG9pbnQoMC41LCB2aWFOb2RlKTtcbiAgICAgICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICAgICAgdmFyIHJvdGF0aW9uUG9pbnQgPSB0aGlzLl9nZXRSb3RhdGlvbihjdHgpO1xuICAgICAgICAgIGlmIChyb3RhdGlvblBvaW50LmFuZ2xlICE9IDApIHtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUocm90YXRpb25Qb2ludC54LCByb3RhdGlvblBvaW50LnkpO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZShyb3RhdGlvblBvaW50LmFuZ2xlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBkcmF3IHRoZSBsYWJlbFxuICAgICAgICAgIHRoaXMubGFiZWxNb2R1bGUuZHJhdyhjdHgsIHBvaW50LngsIHBvaW50LnksIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIpO1xuXG4gICAgICAgICAgLypcbiAgICAgICAgICAvLyBVc2VmdWwgZGVidWcgY29kZTogZHJhdyBhIGJvcmRlciBhcm91bmQgdGhlIGxhYmVsXG4gICAgICAgICAgLy8gVGhpcyBzaG91bGQgKipub3QqKiBiZSBlbmFibGVkIGluIHByb2R1Y3Rpb24hXG4gICAgICAgICAgdmFyIHNpemUgPSB0aGlzLmxhYmVsTW9kdWxlLmdldFNpemUoKTs7IC8vIDs7IGludGVudGlvbmFsIHNvIGxpbnQgY2F0Y2hlcyBpdFxuICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IFwiI2ZmMDAwMFwiO1xuICAgICAgICAgIGN0eC5zdHJva2VSZWN0KHNpemUubGVmdCwgc2l6ZS50b3AsIHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcbiAgICAgICAgICAvLyBFbmQgIGRlYnVnIGNvZGVcbiAgICAgICAgICAqL1xuXG4gICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJZ25vcmUgdGhlIG9yaWVudGF0aW9ucy5cbiAgICAgICAgICB0aGlzLmxhYmVsTW9kdWxlLnBvaW50VG9TZWxmID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgeCwgeTtcbiAgICAgICAgICB2YXIgcmFkaXVzID0gdGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2VTaXplO1xuICAgICAgICAgIGlmIChub2RlMS5zaGFwZS53aWR0aCA+IG5vZGUxLnNoYXBlLmhlaWdodCkge1xuICAgICAgICAgICAgeCA9IG5vZGUxLnggKyBub2RlMS5zaGFwZS53aWR0aCAqIDAuNTtcbiAgICAgICAgICAgIHkgPSBub2RlMS55IC0gcmFkaXVzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4ID0gbm9kZTEueCArIHJhZGl1cztcbiAgICAgICAgICAgIHkgPSBub2RlMS55IC0gbm9kZTEuc2hhcGUuaGVpZ2h0ICogMC41O1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb2ludCA9IHRoaXMuX3BvaW50T25DaXJjbGUoeCwgeSwgcmFkaXVzLCAwLjEyNSk7XG4gICAgICAgICAgdGhpcy5sYWJlbE1vZHVsZS5kcmF3KGN0eCwgcG9pbnQueCwgcG9pbnQueSwgdGhpcy5zZWxlY3RlZCwgdGhpcy5ob3Zlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgYWxsIHZpc3VhbCBlbGVtZW50cyBvZiB0aGlzIGVkZ2UgaW5zdGFuY2UsIGluIHdoaWNoIHRoZSBnaXZlblxuICAgICAqIHBvaW50IGZhbGxzIHdpdGhpbiB0aGUgYm91bmRpbmcgc2hhcGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3BvaW50fSBwb2ludFxuICAgICAqIEByZXR1cm5zIHtBcnJheS48ZWRnZUNsaWNrSXRlbXxlZGdlTGFiZWxDbGlja0l0ZW0+fSBsaXN0IHdpdGggdGhlIGl0ZW1zIHdoaWNoIGFyZSBvbiB0aGUgcG9pbnRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0SXRlbXNPblBvaW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SXRlbXNPblBvaW50KHBvaW50KSB7XG4gICAgICB2YXIgcmV0ID0gW107XG5cbiAgICAgIGlmICh0aGlzLmxhYmVsTW9kdWxlLnZpc2libGUoKSkge1xuICAgICAgICB2YXIgcm90YXRpb25Qb2ludCA9IHRoaXMuX2dldFJvdGF0aW9uKCk7XG4gICAgICAgIGlmIChDb21wb25lbnRVdGlsLnBvaW50SW5SZWN0KHRoaXMubGFiZWxNb2R1bGUuZ2V0U2l6ZSgpLCBwb2ludCwgcm90YXRpb25Qb2ludCkpIHtcbiAgICAgICAgICByZXQucHVzaCh7IGVkZ2VJZDogdGhpcy5pZCwgbGFiZWxJZDogMCB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgb2JqID0ge1xuICAgICAgICBsZWZ0OiBwb2ludC54LFxuICAgICAgICB0b3A6IHBvaW50LnlcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLmlzT3ZlcmxhcHBpbmdXaXRoKG9iaikpIHtcbiAgICAgICAgcmV0LnB1c2goeyBlZGdlSWQ6IHRoaXMuaWQgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhpcyBvYmplY3QgaXMgb3ZlcmxhcHBpbmcgd2l0aCB0aGUgcHJvdmlkZWQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAgIGFuIG9iamVjdCB3aXRoIHBhcmFtZXRlcnMgbGVmdCwgdG9wXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gICAgIFRydWUgaWYgbG9jYXRpb24gaXMgbG9jYXRlZCBvbiB0aGUgZWRnZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdpc092ZXJsYXBwaW5nV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzT3ZlcmxhcHBpbmdXaXRoKG9iaikge1xuICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgIHZhciBkaXN0TWF4ID0gMTA7XG4gICAgICAgIHZhciB4RnJvbSA9IHRoaXMuZnJvbS54O1xuICAgICAgICB2YXIgeUZyb20gPSB0aGlzLmZyb20ueTtcbiAgICAgICAgdmFyIHhUbyA9IHRoaXMudG8ueDtcbiAgICAgICAgdmFyIHlUbyA9IHRoaXMudG8ueTtcbiAgICAgICAgdmFyIHhPYmogPSBvYmoubGVmdDtcbiAgICAgICAgdmFyIHlPYmogPSBvYmoudG9wO1xuXG4gICAgICAgIHZhciBkaXN0ID0gdGhpcy5lZGdlVHlwZS5nZXREaXN0YW5jZVRvRWRnZSh4RnJvbSwgeUZyb20sIHhUbywgeVRvLCB4T2JqLCB5T2JqKTtcblxuICAgICAgICByZXR1cm4gZGlzdCA8IGRpc3RNYXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHRoZSByb3RhdGlvbiBwb2ludCwgaWYgYW55LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IFtjdHhdIGlmIHBhc3NlZCwgZG8gYSByZWNhbGN1bGF0aW9uIG9mIHRoZSBsYWJlbCBzaXplXG4gICAgICogQHJldHVybnMge3JvdGF0aW9uUG9pbnR9IHRoZSBwb2ludCB0byByb3RhdGUgYXJvdW5kIGFuZCB0aGUgYW5nbGUgaW4gcmFkaWFucyB0byByb3RhdGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZ2V0Um90YXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Um90YXRpb24oY3R4KSB7XG4gICAgICB2YXIgdmlhTm9kZSA9IHRoaXMuZWRnZVR5cGUuZ2V0VmlhTm9kZSgpO1xuICAgICAgdmFyIHBvaW50ID0gdGhpcy5lZGdlVHlwZS5nZXRQb2ludCgwLjUsIHZpYU5vZGUpO1xuXG4gICAgICBpZiAoY3R4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5sYWJlbE1vZHVsZS5jYWxjdWxhdGVMYWJlbFNpemUoY3R4LCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyLCBwb2ludC54LCBwb2ludC55KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgeDogcG9pbnQueCxcbiAgICAgICAgeTogdGhpcy5sYWJlbE1vZHVsZS5zaXplLnlMaW5lLFxuICAgICAgICBhbmdsZTogMFxuICAgICAgfTtcblxuICAgICAgaWYgKCF0aGlzLmxhYmVsTW9kdWxlLnZpc2libGUoKSkge1xuICAgICAgICByZXR1cm4gcmV0OyAvLyBEb24ndCBldmVuIGJvdGhlciBkb2luZyB0aGUgYXRhbjIsIHRoZXJlJ3Mgbm90aGluZyB0byBkcmF3XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZm9udC5hbGlnbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgIHJldHVybiByZXQ7IC8vIE5vIG5lZWQgdG8gY2FsY3VsYXRlIGFuZ2xlXG4gICAgICB9XG5cbiAgICAgIHZhciBkeSA9IHRoaXMuZnJvbS55IC0gdGhpcy50by55O1xuICAgICAgdmFyIGR4ID0gdGhpcy5mcm9tLnggLSB0aGlzLnRvLng7XG4gICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKGR5LCBkeCk7IC8vIHJhZGlhbnNcblxuICAgICAgLy8gcm90YXRlIHNvIHRoYXQgbGFiZWwgaXMgcmVhZGFibGVcbiAgICAgIGlmIChhbmdsZSA8IC0xICYmIGR4IDwgMCB8fCBhbmdsZSA+IDAgJiYgZHggPCAwKSB7XG4gICAgICAgIGFuZ2xlICs9IE1hdGguUEk7XG4gICAgICB9XG4gICAgICByZXQuYW5nbGUgPSBhbmdsZTtcblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBwb2ludCBvbiBhIGNpcmNsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBlcmNlbnRhZ2UgVmFsdWUgYmV0d2VlbiAwIChsaW5lIHN0YXJ0KSBhbmQgMSAobGluZSBlbmQpXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBwb2ludFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19wb2ludE9uQ2lyY2xlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BvaW50T25DaXJjbGUoeCwgeSwgcmFkaXVzLCBwZXJjZW50YWdlKSB7XG4gICAgICB2YXIgYW5nbGUgPSBwZXJjZW50YWdlICogMiAqIE1hdGguUEk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4ICsgcmFkaXVzICogTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICB5OiB5IC0gcmFkaXVzICogTWF0aC5zaW4oYW5nbGUpXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgc2VsZWN0ZWQgc3RhdGUgdG8gdHJ1ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZWxlY3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3QoKSB7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHNlbGVjdGVkIHN0YXRlIHRvIGZhbHNlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Vuc2VsZWN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5zZWxlY3QoKSB7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY2xlYW5zIGFsbCByZXF1aXJlZCB0aGluZ3Mgb24gZGVsZXRlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2NsZWFudXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWRnZVR5cGUuY2xlYW51cCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBlZGdlIGZyb20gdGhlIGxpc3QgYW5kIHBlcmZvcm0gbmVjZXNzYXJ5IGNsZWFudXAuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3JlbW92ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICBkZWxldGUgdGhpcy5ib2R5LmVkZ2VzW3RoaXMuaWRdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGJvdGggY29ubmVjdGluZyBub2RlcyBleGlzdFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdlbmRQb2ludHNWYWxpZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuZFBvaW50c1ZhbGlkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYm9keS5ub2Rlc1t0aGlzLmZyb21JZF0gIT09IHVuZGVmaW5lZCAmJiB0aGlzLmJvZHkubm9kZXNbdGhpcy50b0lkXSAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiAncGFyc2VPcHRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VPcHRpb25zKHBhcmVudE9wdGlvbnMsIG5ld09wdGlvbnMpIHtcbiAgICAgIHZhciBhbGxvd0RlbGV0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICAgIHZhciBnbG9iYWxPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgICAgIHZhciBjb3B5RnJvbUdsb2JhbHMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IGZhbHNlO1xuXG4gICAgICB2YXIgZmllbGRzID0gWydhcnJvd1N0cmlrZXRocm91Z2gnLCAnaWQnLCAnZnJvbScsICdoaWRkZW4nLCAnaG92ZXJXaWR0aCcsICdsYWJlbEhpZ2hsaWdodEJvbGQnLCAnbGVuZ3RoJywgJ2xpbmUnLCAnb3BhY2l0eScsICdwaHlzaWNzJywgJ3NjYWxpbmcnLCAnc2VsZWN0aW9uV2lkdGgnLCAnc2VsZlJlZmVyZW5jZVNpemUnLCAndG8nLCAndGl0bGUnLCAndmFsdWUnLCAnd2lkdGgnLCAnZm9udCcsICdjaG9zZW4nLCAnd2lkdGhDb25zdHJhaW50J107XG5cbiAgICAgIC8vIG9ubHkgZGVlcCBleHRlbmQgdGhlIGl0ZW1zIGluIHRoZSBmaWVsZCBhcnJheS4gVGhlc2UgZG8gbm90IGhhdmUgc2hvcnRoYW5kLlxuICAgICAgdXRpbC5zZWxlY3RpdmVEZWVwRXh0ZW5kKGZpZWxkcywgcGFyZW50T3B0aW9ucywgbmV3T3B0aW9ucywgYWxsb3dEZWxldGlvbik7XG5cbiAgICAgIC8vIE9ubHkgY29weSBsYWJlbCBpZiBpdCdzIGEgbGVnYWwgdmFsdWUuXG4gICAgICBpZiAoQ29tcG9uZW50VXRpbC5pc1ZhbGlkTGFiZWwobmV3T3B0aW9ucy5sYWJlbCkpIHtcbiAgICAgICAgcGFyZW50T3B0aW9ucy5sYWJlbCA9IG5ld09wdGlvbnMubGFiZWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnRPcHRpb25zLmxhYmVsID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICB1dGlsLm1lcmdlT3B0aW9ucyhwYXJlbnRPcHRpb25zLCBuZXdPcHRpb25zLCAnc21vb3RoJywgZ2xvYmFsT3B0aW9ucyk7XG4gICAgICB1dGlsLm1lcmdlT3B0aW9ucyhwYXJlbnRPcHRpb25zLCBuZXdPcHRpb25zLCAnc2hhZG93JywgZ2xvYmFsT3B0aW9ucyk7XG4gICAgICB1dGlsLm1lcmdlT3B0aW9ucyhwYXJlbnRPcHRpb25zLCBuZXdPcHRpb25zLCAnYmFja2dyb3VuZCcsIGdsb2JhbE9wdGlvbnMpO1xuXG4gICAgICBpZiAobmV3T3B0aW9ucy5kYXNoZXMgIT09IHVuZGVmaW5lZCAmJiBuZXdPcHRpb25zLmRhc2hlcyAhPT0gbnVsbCkge1xuICAgICAgICBwYXJlbnRPcHRpb25zLmRhc2hlcyA9IG5ld09wdGlvbnMuZGFzaGVzO1xuICAgICAgfSBlbHNlIGlmIChhbGxvd0RlbGV0aW9uID09PSB0cnVlICYmIG5ld09wdGlvbnMuZGFzaGVzID09PSBudWxsKSB7XG4gICAgICAgIHBhcmVudE9wdGlvbnMuZGFzaGVzID0gKDAsIF9jcmVhdGUyWydkZWZhdWx0J10pKGdsb2JhbE9wdGlvbnMuZGFzaGVzKTsgLy8gdGhpcyBzZXRzIHRoZSBwb2ludGVyIG9mIHRoZSBvcHRpb24gYmFjayB0byB0aGUgZ2xvYmFsIG9wdGlvbi5cbiAgICAgIH1cblxuICAgICAgLy8gc2V0IHRoZSBzY2FsaW5nIG5ld09wdGlvbnNcbiAgICAgIGlmIChuZXdPcHRpb25zLnNjYWxpbmcgIT09IHVuZGVmaW5lZCAmJiBuZXdPcHRpb25zLnNjYWxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5ld09wdGlvbnMuc2NhbGluZy5taW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHBhcmVudE9wdGlvbnMuc2NhbGluZy5taW4gPSBuZXdPcHRpb25zLnNjYWxpbmcubWluO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdPcHRpb25zLnNjYWxpbmcubWF4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwYXJlbnRPcHRpb25zLnNjYWxpbmcubWF4ID0gbmV3T3B0aW9ucy5zY2FsaW5nLm1heDtcbiAgICAgICAgfVxuICAgICAgICB1dGlsLm1lcmdlT3B0aW9ucyhwYXJlbnRPcHRpb25zLnNjYWxpbmcsIG5ld09wdGlvbnMuc2NhbGluZywgJ2xhYmVsJywgZ2xvYmFsT3B0aW9ucy5zY2FsaW5nKTtcbiAgICAgIH0gZWxzZSBpZiAoYWxsb3dEZWxldGlvbiA9PT0gdHJ1ZSAmJiBuZXdPcHRpb25zLnNjYWxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgcGFyZW50T3B0aW9ucy5zY2FsaW5nID0gKDAsIF9jcmVhdGUyWydkZWZhdWx0J10pKGdsb2JhbE9wdGlvbnMuc2NhbGluZyk7IC8vIHRoaXMgc2V0cyB0aGUgcG9pbnRlciBvZiB0aGUgb3B0aW9uIGJhY2sgdG8gdGhlIGdsb2JhbCBvcHRpb24uXG4gICAgICB9XG5cbiAgICAgIC8vIGhhbmRsZSBtdWx0aXBsZSBpbnB1dCBjYXNlcyBmb3IgYXJyb3dzXG4gICAgICBpZiAobmV3T3B0aW9ucy5hcnJvd3MgIT09IHVuZGVmaW5lZCAmJiBuZXdPcHRpb25zLmFycm93cyAhPT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIG5ld09wdGlvbnMuYXJyb3dzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHZhciBhcnJvd3MgPSBuZXdPcHRpb25zLmFycm93cy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIHBhcmVudE9wdGlvbnMuYXJyb3dzLnRvLmVuYWJsZWQgPSBhcnJvd3MuaW5kZXhPZigndG8nKSAhPSAtMTtcbiAgICAgICAgICBwYXJlbnRPcHRpb25zLmFycm93cy5taWRkbGUuZW5hYmxlZCA9IGFycm93cy5pbmRleE9mKCdtaWRkbGUnKSAhPSAtMTtcbiAgICAgICAgICBwYXJlbnRPcHRpb25zLmFycm93cy5mcm9tLmVuYWJsZWQgPSBhcnJvd3MuaW5kZXhPZignZnJvbScpICE9IC0xO1xuICAgICAgICB9IGVsc2UgaWYgKCgwLCBfdHlwZW9mM1snZGVmYXVsdCddKShuZXdPcHRpb25zLmFycm93cykgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdXRpbC5tZXJnZU9wdGlvbnMocGFyZW50T3B0aW9ucy5hcnJvd3MsIG5ld09wdGlvbnMuYXJyb3dzLCAndG8nLCBnbG9iYWxPcHRpb25zLmFycm93cyk7XG4gICAgICAgICAgdXRpbC5tZXJnZU9wdGlvbnMocGFyZW50T3B0aW9ucy5hcnJvd3MsIG5ld09wdGlvbnMuYXJyb3dzLCAnbWlkZGxlJywgZ2xvYmFsT3B0aW9ucy5hcnJvd3MpO1xuICAgICAgICAgIHV0aWwubWVyZ2VPcHRpb25zKHBhcmVudE9wdGlvbnMuYXJyb3dzLCBuZXdPcHRpb25zLmFycm93cywgJ2Zyb20nLCBnbG9iYWxPcHRpb25zLmFycm93cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYXJyb3cgbmV3T3B0aW9ucyBjYW4gb25seSBiZSBhbiBvYmplY3Qgb3IgYSBzdHJpbmcuIFJlZmVyIHRvIHRoZSBkb2N1bWVudGF0aW9uLiBZb3UgdXNlZDonICsgKDAsIF9zdHJpbmdpZnkyWydkZWZhdWx0J10pKG5ld09wdGlvbnMuYXJyb3dzKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYWxsb3dEZWxldGlvbiA9PT0gdHJ1ZSAmJiBuZXdPcHRpb25zLmFycm93cyA9PT0gbnVsbCkge1xuICAgICAgICBwYXJlbnRPcHRpb25zLmFycm93cyA9ICgwLCBfY3JlYXRlMlsnZGVmYXVsdCddKShnbG9iYWxPcHRpb25zLmFycm93cyk7IC8vIHRoaXMgc2V0cyB0aGUgcG9pbnRlciBvZiB0aGUgb3B0aW9uIGJhY2sgdG8gdGhlIGdsb2JhbCBvcHRpb24uXG4gICAgICB9XG5cbiAgICAgIC8vIGhhbmRsZSBtdWx0aXBsZSBpbnB1dCBjYXNlcyBmb3IgY29sb3JcbiAgICAgIGlmIChuZXdPcHRpb25zLmNvbG9yICE9PSB1bmRlZmluZWQgJiYgbmV3T3B0aW9ucy5jb2xvciAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgZnJvbUNvbG9yID0gbmV3T3B0aW9ucy5jb2xvcjtcbiAgICAgICAgdmFyIHRvQ29sb3IgPSBwYXJlbnRPcHRpb25zLmNvbG9yO1xuXG4gICAgICAgIC8vIElmIHBhc3NlZCwgZmlsbCBpbiB2YWx1ZXMgZnJvbSBkZWZhdWx0IG9wdGlvbnMgLSByZXF1aXJlZCBpbiB0aGUgY2FzZSBvZiBubyBwcm90b3R5cGUgYnJpZGdpbmdcbiAgICAgICAgaWYgKGNvcHlGcm9tR2xvYmFscykge1xuICAgICAgICAgIHV0aWwuZGVlcEV4dGVuZCh0b0NvbG9yLCBnbG9iYWxPcHRpb25zLmNvbG9yLCBmYWxzZSwgYWxsb3dEZWxldGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQ2xlYXIgbG9jYWwgcHJvcGVydGllcyAtIG5lZWQgdG8gZG8gaXQgbGlrZSB0aGlzIGluIG9yZGVyIHRvIHJldGFpbiBwcm90b3R5cGUgYnJpZGdlc1xuICAgICAgICAgIGZvciAodmFyIGkgaW4gdG9Db2xvcikge1xuICAgICAgICAgICAgaWYgKHRvQ29sb3IuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIHRvQ29sb3JbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHV0aWwuaXNTdHJpbmcodG9Db2xvcikpIHtcbiAgICAgICAgICB0b0NvbG9yLmNvbG9yID0gdG9Db2xvcjtcbiAgICAgICAgICB0b0NvbG9yLmhpZ2hsaWdodCA9IHRvQ29sb3I7XG4gICAgICAgICAgdG9Db2xvci5ob3ZlciA9IHRvQ29sb3I7XG4gICAgICAgICAgdG9Db2xvci5pbmhlcml0ID0gZmFsc2U7XG4gICAgICAgICAgaWYgKGZyb21Db2xvci5vcGFjaXR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRvQ29sb3Iub3BhY2l0eSA9IDEuMDsgLy8gc2V0IGRlZmF1bHRcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNvbG9yc0RlZmluZWQgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoZnJvbUNvbG9yLmNvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRvQ29sb3IuY29sb3IgPSBmcm9tQ29sb3IuY29sb3I7XG4gICAgICAgICAgICBjb2xvcnNEZWZpbmVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZyb21Db2xvci5oaWdobGlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdG9Db2xvci5oaWdobGlnaHQgPSBmcm9tQ29sb3IuaGlnaGxpZ2h0O1xuICAgICAgICAgICAgY29sb3JzRGVmaW5lZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmcm9tQ29sb3IuaG92ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdG9Db2xvci5ob3ZlciA9IGZyb21Db2xvci5ob3ZlcjtcbiAgICAgICAgICAgIGNvbG9yc0RlZmluZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZnJvbUNvbG9yLmluaGVyaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdG9Db2xvci5pbmhlcml0ID0gZnJvbUNvbG9yLmluaGVyaXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmcm9tQ29sb3Iub3BhY2l0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0b0NvbG9yLm9wYWNpdHkgPSBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBmcm9tQ29sb3Iub3BhY2l0eSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjb2xvcnNEZWZpbmVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0b0NvbG9yLmluaGVyaXQgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRvQ29sb3IuaW5oZXJpdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHRvQ29sb3IuaW5oZXJpdCA9ICdmcm9tJzsgLy8gU2V0IGRlZmF1bHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYWxsb3dEZWxldGlvbiA9PT0gdHJ1ZSAmJiBuZXdPcHRpb25zLmNvbG9yID09PSBudWxsKSB7XG4gICAgICAgIHBhcmVudE9wdGlvbnMuY29sb3IgPSB1dGlsLmJyaWRnZU9iamVjdChnbG9iYWxPcHRpb25zLmNvbG9yKTsgLy8gc2V0IHRoZSBvYmplY3QgYmFjayB0byB0aGUgZ2xvYmFsIG9wdGlvbnNcbiAgICAgIH1cblxuICAgICAgaWYgKGFsbG93RGVsZXRpb24gPT09IHRydWUgJiYgbmV3T3B0aW9ucy5mb250ID09PSBudWxsKSB7XG4gICAgICAgIHBhcmVudE9wdGlvbnMuZm9udCA9IHV0aWwuYnJpZGdlT2JqZWN0KGdsb2JhbE9wdGlvbnMuZm9udCk7IC8vIHNldCB0aGUgb2JqZWN0IGJhY2sgdG8gdGhlIGdsb2JhbCBvcHRpb25zXG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBFZGdlO1xufSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBFZGdlO1xuXG4vKioqLyB9KSxcbi8qIDU2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxudmFyIF9pbmhlcml0czIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cbnZhciBfRWRnZUJhc2UyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OSk7XG5cbnZhciBfRWRnZUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRWRnZUJhc2UyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vKipcbiAqIFRoZSBCYXNlIENsYXNzIGZvciBhbGwgQmV6aWVyIGVkZ2VzLiBCZXppZXIgY3VydmVzIGFyZSB1c2VkIHRvIG1vZGVsIHNtb290aFxuICogZ3JhZHVhbCBjdXJ2ZXMgaW4gcGF0aHMgYmV0d2VlbiBub2Rlcy5cbiAqXG4gKiBAZXh0ZW5kcyBFZGdlQmFzZVxuICovXG52YXIgQmV6aWVyRWRnZUJhc2UgPSBmdW5jdGlvbiAoX0VkZ2VCYXNlKSB7XG4gICgwLCBfaW5oZXJpdHMzWydkZWZhdWx0J10pKEJlemllckVkZ2VCYXNlLCBfRWRnZUJhc2UpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gQmV6aWVyRWRnZUJhc2Uob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrM1snZGVmYXVsdCddKSh0aGlzLCBCZXppZXJFZGdlQmFzZSk7XG4gICAgcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjNbJ2RlZmF1bHQnXSkodGhpcywgKEJlemllckVkZ2VCYXNlLl9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMlsnZGVmYXVsdCddKShCZXppZXJFZGdlQmFzZSkpLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHVzZXMgYmluYXJ5IHNlYXJjaCB0byBsb29rIGZvciB0aGUgcG9pbnQgd2hlcmUgdGhlIGJlemllciBjdXJ2ZSBjcm9zc2VzIHRoZSBib3JkZXIgb2YgdGhlIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gbmVhck5vZGVcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcGFyYW0ge05vZGV9IHZpYU5vZGVcbiAgICogQHJldHVybnMgeyp9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoQmV6aWVyRWRnZUJhc2UsIFt7XG4gICAga2V5OiAnX2ZpbmRCb3JkZXJQb3NpdGlvbkJlemllcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kQm9yZGVyUG9zaXRpb25CZXppZXIobmVhck5vZGUsIGN0eCkge1xuICAgICAgdmFyIHZpYU5vZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKCk7XG5cbiAgICAgIHZhciBtYXhJdGVyYXRpb25zID0gMTA7XG4gICAgICB2YXIgaXRlcmF0aW9uID0gMDtcbiAgICAgIHZhciBsb3cgPSAwO1xuICAgICAgdmFyIGhpZ2ggPSAxO1xuICAgICAgdmFyIHBvcywgYW5nbGUsIGRpc3RhbmNlVG9Cb3JkZXIsIGRpc3RhbmNlVG9Qb2ludCwgZGlmZmVyZW5jZTtcbiAgICAgIHZhciB0aHJlc2hvbGQgPSAwLjI7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMudG87XG4gICAgICB2YXIgZnJvbSA9IGZhbHNlO1xuICAgICAgaWYgKG5lYXJOb2RlLmlkID09PSB0aGlzLmZyb20uaWQpIHtcbiAgICAgICAgbm9kZSA9IHRoaXMuZnJvbTtcbiAgICAgICAgZnJvbSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChsb3cgPD0gaGlnaCAmJiBpdGVyYXRpb24gPCBtYXhJdGVyYXRpb25zKSB7XG4gICAgICAgIHZhciBtaWRkbGUgPSAobG93ICsgaGlnaCkgKiAwLjU7XG5cbiAgICAgICAgcG9zID0gdGhpcy5nZXRQb2ludChtaWRkbGUsIHZpYU5vZGUpO1xuICAgICAgICBhbmdsZSA9IE1hdGguYXRhbjIobm9kZS55IC0gcG9zLnksIG5vZGUueCAtIHBvcy54KTtcbiAgICAgICAgZGlzdGFuY2VUb0JvcmRlciA9IG5vZGUuZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICAgICAgZGlzdGFuY2VUb1BvaW50ID0gTWF0aC5zcXJ0KE1hdGgucG93KHBvcy54IC0gbm9kZS54LCAyKSArIE1hdGgucG93KHBvcy55IC0gbm9kZS55LCAyKSk7XG4gICAgICAgIGRpZmZlcmVuY2UgPSBkaXN0YW5jZVRvQm9yZGVyIC0gZGlzdGFuY2VUb1BvaW50O1xuICAgICAgICBpZiAoTWF0aC5hYnMoZGlmZmVyZW5jZSkgPCB0aHJlc2hvbGQpIHtcbiAgICAgICAgICBicmVhazsgLy8gZm91bmRcbiAgICAgICAgfSBlbHNlIGlmIChkaWZmZXJlbmNlIDwgMCkge1xuICAgICAgICAgIC8vIGRpc3RhbmNlIHRvIG5vZGVzIGlzIGxhcmdlciB0aGFuIGRpc3RhbmNlIHRvIGJvcmRlciAtLT4gdCBuZWVkcyB0byBiZSBiaWdnZXIgaWYgd2UncmUgbG9va2luZyBhdCB0aGUgdG8gbm9kZS5cbiAgICAgICAgICBpZiAoZnJvbSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGxvdyA9IG1pZGRsZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGlnaCA9IG1pZGRsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGZyb20gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBoaWdoID0gbWlkZGxlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb3cgPSBtaWRkbGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaXRlcmF0aW9uKys7XG4gICAgICB9XG4gICAgICBwb3MudCA9IG1pZGRsZTtcblxuICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGJldHdlZW4gYSBwb2ludCAoeDMseTMpIGFuZCBhIGxpbmUgc2VnbWVudCBmcm9tXG4gICAgICogKHgxLHkxKSB0byAoeDIseTIpLlxuICAgICAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODQ5MjExL3Nob3J0ZXN0LWRpc3RhbmNhZS1iZXR3ZWVuLWEtcG9pbnQtYW5kLWEtbGluZS1zZWdtZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgxIGZyb20geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MSBmcm9tIHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDIgdG8geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MiB0byB5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgzIHBvaW50IHRvIGNoZWNrIHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTMgcG9pbnQgdG8gY2hlY2sgeVxuICAgICAqIEBwYXJhbSB7Tm9kZX0gdmlhXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZ2V0RGlzdGFuY2VUb0JlemllckVkZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGlzdGFuY2VUb0JlemllckVkZ2UoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgdmlhKSB7XG4gICAgICAvLyB4Myx5MyBpcyB0aGUgcG9pbnRcbiAgICAgIHZhciBtaW5EaXN0YW5jZSA9IDFlOTtcbiAgICAgIHZhciBkaXN0YW5jZSA9IHZvaWQgMDtcbiAgICAgIHZhciBpID0gdm9pZCAwLFxuICAgICAgICAgIHQgPSB2b2lkIDAsXG4gICAgICAgICAgeCA9IHZvaWQgMCxcbiAgICAgICAgICB5ID0gdm9pZCAwO1xuICAgICAgdmFyIGxhc3RYID0geDE7XG4gICAgICB2YXIgbGFzdFkgPSB5MTtcbiAgICAgIGZvciAoaSA9IDE7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgIHQgPSAwLjEgKiBpO1xuICAgICAgICB4ID0gTWF0aC5wb3coMSAtIHQsIDIpICogeDEgKyAyICogdCAqICgxIC0gdCkgKiB2aWEueCArIE1hdGgucG93KHQsIDIpICogeDI7XG4gICAgICAgIHkgPSBNYXRoLnBvdygxIC0gdCwgMikgKiB5MSArIDIgKiB0ICogKDEgLSB0KSAqIHZpYS55ICsgTWF0aC5wb3codCwgMikgKiB5MjtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgZGlzdGFuY2UgPSB0aGlzLl9nZXREaXN0YW5jZVRvTGluZShsYXN0WCwgbGFzdFksIHgsIHksIHgzLCB5Myk7XG4gICAgICAgICAgbWluRGlzdGFuY2UgPSBkaXN0YW5jZSA8IG1pbkRpc3RhbmNlID8gZGlzdGFuY2UgOiBtaW5EaXN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0WCA9IHg7XG4gICAgICAgIGxhc3RZID0geTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1pbkRpc3RhbmNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyYXcgYSBiZXppZXIgY3VydmUgYmV0d2VlbiB0d28gbm9kZXNcbiAgICAgKlxuICAgICAqIFRoZSBtZXRob2QgYWNjZXB0cyB6ZXJvLCBvbmUgb3IgdHdvIGNvbnRyb2wgcG9pbnRzLlxuICAgICAqIFBhc3NpbmcgemVybyBjb250cm9sIHBvaW50cyBqdXN0IGRyYXdzIGEgc3RyYWlnaHQgbGluZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgdmFsdWVzICAgfCBvcHRpb25zIGZvciBzaGFkb3cgZHJhd2luZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fHVuZGVmaW5lZH0gdmlhTm9kZTEgfCBmaXJzdCBjb250cm9sIHBvaW50IGZvciBjdXJ2ZSBkcmF3aW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R8dW5kZWZpbmVkfSB2aWFOb2RlMiB8IHNlY29uZCBjb250cm9sIHBvaW50IGZvciBjdXJ2ZSBkcmF3aW5nXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19iZXppZXJDdXJ2ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9iZXppZXJDdXJ2ZShjdHgsIHZhbHVlcywgdmlhTm9kZTEsIHZpYU5vZGUyKSB7XG4gICAgICB2YXIgaGFzTm9kZTEgPSB2aWFOb2RlMSAhPT0gdW5kZWZpbmVkICYmIHZpYU5vZGUxLnggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBoYXNOb2RlMiA9IHZpYU5vZGUyICE9PSB1bmRlZmluZWQgJiYgdmlhTm9kZTIueCAhPT0gdW5kZWZpbmVkO1xuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKHRoaXMuZnJvbVBvaW50LngsIHRoaXMuZnJvbVBvaW50LnkpO1xuXG4gICAgICBpZiAoaGFzTm9kZTEgJiYgaGFzTm9kZTIpIHtcbiAgICAgICAgY3R4LmJlemllckN1cnZlVG8odmlhTm9kZTEueCwgdmlhTm9kZTEueSwgdmlhTm9kZTIueCwgdmlhTm9kZTIueSwgdGhpcy50b1BvaW50LngsIHRoaXMudG9Qb2ludC55KTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzTm9kZTEpIHtcbiAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8odmlhTm9kZTEueCwgdmlhTm9kZTEueSwgdGhpcy50b1BvaW50LngsIHRoaXMudG9Qb2ludC55KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGZhbGxiYWNrIHRvIG5vcm1hbCBzdHJhaWdodCBlZGdlXG4gICAgICAgIGN0eC5saW5lVG8odGhpcy50b1BvaW50LngsIHRoaXMudG9Qb2ludC55KTtcbiAgICAgIH1cbiAgICAgIC8vIGRyYXcgYSBiYWNrZ3JvdW5kXG4gICAgICB0aGlzLmRyYXdCYWNrZ3JvdW5kKGN0eCwgdmFsdWVzKTtcblxuICAgICAgLy8gZHJhdyBzaGFkb3cgaWYgZW5hYmxlZFxuICAgICAgdGhpcy5lbmFibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHsqfHt4LCB5fXx7eDogdW5kZWZpbmVkLCB5OiB1bmRlZmluZWR9fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRWaWFOb2RlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmlhTm9kZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRWaWFDb29yZGluYXRlcygpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQmV6aWVyRWRnZUJhc2U7XG59KF9FZGdlQmFzZTNbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEJlemllckVkZ2VCYXNlO1xuXG4vKioqLyB9KSxcbi8qIDU3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbi8qKlxuICogVXRpbGl0eSBDbGFzc1xuICovXG5cbnZhciBOZXR3b3JrVXRpbCA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGZ1bmN0aW9uIE5ldHdvcmtVdGlsKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIE5ldHdvcmtVdGlsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSBjZW50ZXIgcG9zaXRpb24gb2YgdGhlIG5ldHdvcmsgY29uc2lkZXJpbmcgdGhlIGJvdW5kaW5nIGJveGVzXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXkuPE5vZGU+fSBhbGxOb2Rlc1xuICAgKiBAcGFyYW0ge0FycmF5LjxOb2RlPn0gW3NwZWNpZmljTm9kZXM9W11dXG4gICAqIEByZXR1cm5zIHt7bWluWDogbnVtYmVyLCBtYXhYOiBudW1iZXIsIG1pblk6IG51bWJlciwgbWF4WTogbnVtYmVyfX1cbiAgICogQHN0YXRpY1xuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKE5ldHdvcmtVdGlsLCBudWxsLCBbe1xuICAgIGtleTogJ2dldFJhbmdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmFuZ2UoYWxsTm9kZXMpIHtcbiAgICAgIHZhciBzcGVjaWZpY05vZGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcblxuICAgICAgdmFyIG1pblkgPSAxZTksXG4gICAgICAgICAgbWF4WSA9IC0xZTksXG4gICAgICAgICAgbWluWCA9IDFlOSxcbiAgICAgICAgICBtYXhYID0gLTFlOSxcbiAgICAgICAgICBub2RlO1xuICAgICAgaWYgKHNwZWNpZmljTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwZWNpZmljTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBub2RlID0gYWxsTm9kZXNbc3BlY2lmaWNOb2Rlc1tpXV07XG4gICAgICAgICAgaWYgKG1pblggPiBub2RlLnNoYXBlLmJvdW5kaW5nQm94LmxlZnQpIHtcbiAgICAgICAgICAgIG1pblggPSBub2RlLnNoYXBlLmJvdW5kaW5nQm94LmxlZnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtYXhYIDwgbm9kZS5zaGFwZS5ib3VuZGluZ0JveC5yaWdodCkge1xuICAgICAgICAgICAgbWF4WCA9IG5vZGUuc2hhcGUuYm91bmRpbmdCb3gucmlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtaW5ZID4gbm9kZS5zaGFwZS5ib3VuZGluZ0JveC50b3ApIHtcbiAgICAgICAgICAgIG1pblkgPSBub2RlLnNoYXBlLmJvdW5kaW5nQm94LnRvcDtcbiAgICAgICAgICB9IC8vIHRvcCBpcyBuZWdhdGl2ZSwgYm90dG9tIGlzIHBvc2l0aXZlXG4gICAgICAgICAgaWYgKG1heFkgPCBub2RlLnNoYXBlLmJvdW5kaW5nQm94LmJvdHRvbSkge1xuICAgICAgICAgICAgbWF4WSA9IG5vZGUuc2hhcGUuYm91bmRpbmdCb3guYm90dG9tO1xuICAgICAgICAgIH0gLy8gdG9wIGlzIG5lZ2F0aXZlLCBib3R0b20gaXMgcG9zaXRpdmVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobWluWCA9PT0gMWU5ICYmIG1heFggPT09IC0xZTkgJiYgbWluWSA9PT0gMWU5ICYmIG1heFkgPT09IC0xZTkpIHtcbiAgICAgICAgO21pblkgPSAwLCBtYXhZID0gMCwgbWluWCA9IDAsIG1heFggPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgbWluWDogbWluWCwgbWF4WDogbWF4WCwgbWluWTogbWluWSwgbWF4WTogbWF4WSB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIGNlbnRlciBwb3NpdGlvbiBvZiB0aGUgbmV0d29ya1xuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48Tm9kZT59IGFsbE5vZGVzXG4gICAgICogQHBhcmFtIHtBcnJheS48Tm9kZT59IFtzcGVjaWZpY05vZGVzPVtdXVxuICAgICAqIEByZXR1cm5zIHt7bWluWDogbnVtYmVyLCBtYXhYOiBudW1iZXIsIG1pblk6IG51bWJlciwgbWF4WTogbnVtYmVyfX1cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldFJhbmdlQ29yZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJhbmdlQ29yZShhbGxOb2Rlcykge1xuICAgICAgdmFyIHNwZWNpZmljTm9kZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuXG4gICAgICB2YXIgbWluWSA9IDFlOSxcbiAgICAgICAgICBtYXhZID0gLTFlOSxcbiAgICAgICAgICBtaW5YID0gMWU5LFxuICAgICAgICAgIG1heFggPSAtMWU5LFxuICAgICAgICAgIG5vZGU7XG4gICAgICBpZiAoc3BlY2lmaWNOb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BlY2lmaWNOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG5vZGUgPSBhbGxOb2Rlc1tzcGVjaWZpY05vZGVzW2ldXTtcbiAgICAgICAgICBpZiAobWluWCA+IG5vZGUueCkge1xuICAgICAgICAgICAgbWluWCA9IG5vZGUueDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1heFggPCBub2RlLngpIHtcbiAgICAgICAgICAgIG1heFggPSBub2RlLng7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtaW5ZID4gbm9kZS55KSB7XG4gICAgICAgICAgICBtaW5ZID0gbm9kZS55O1xuICAgICAgICAgIH0gLy8gdG9wIGlzIG5lZ2F0aXZlLCBib3R0b20gaXMgcG9zaXRpdmVcbiAgICAgICAgICBpZiAobWF4WSA8IG5vZGUueSkge1xuICAgICAgICAgICAgbWF4WSA9IG5vZGUueTtcbiAgICAgICAgICB9IC8vIHRvcCBpcyBuZWdhdGl2ZSwgYm90dG9tIGlzIHBvc2l0aXZlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG1pblggPT09IDFlOSAmJiBtYXhYID09PSAtMWU5ICYmIG1pblkgPT09IDFlOSAmJiBtYXhZID09PSAtMWU5KSB7XG4gICAgICAgIDttaW5ZID0gMCwgbWF4WSA9IDAsIG1pblggPSAwLCBtYXhYID0gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IG1pblg6IG1pblgsIG1heFg6IG1heFgsIG1pblk6IG1pblksIG1heFk6IG1heFkgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcmFuZ2UgPSB7bWluWDogbWluWCwgbWF4WDogbWF4WCwgbWluWTogbWluWSwgbWF4WTogbWF4WX07XG4gICAgICogQHJldHVybnMge3t4OiBudW1iZXIsIHk6IG51bWJlcn19XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdmaW5kQ2VudGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZENlbnRlcihyYW5nZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogMC41ICogKHJhbmdlLm1heFggKyByYW5nZS5taW5YKSxcbiAgICAgICAgeTogMC41ICogKHJhbmdlLm1heFkgKyByYW5nZS5taW5ZKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIHJldHVybnMgYSBjbG9uZSBvZiB0aGUgb3B0aW9ucyBvciBvcHRpb25zIG9mIHRoZSBlZGdlIG9yIG5vZGUgdG8gYmUgdXNlZCBmb3IgY29uc3RydWN0aW9uIG9mIG5ldyBlZGdlcyBvciBjaGVjayBmdW5jdGlvbnMgZm9yIG5ldyBub2Rlcy5cbiAgICAgKiBAcGFyYW0ge3Zpcy5JdGVtfSBpdGVtXG4gICAgICogQHBhcmFtIHsnbm9kZSd8dW5kZWZpbmVkfSB0eXBlXG4gICAgICogQHJldHVybnMge3t9fVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY2xvbmVPcHRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmVPcHRpb25zKGl0ZW0sIHR5cGUpIHtcbiAgICAgIHZhciBjbG9uZWRPcHRpb25zID0ge307XG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09ICdub2RlJykge1xuICAgICAgICB1dGlsLmRlZXBFeHRlbmQoY2xvbmVkT3B0aW9ucywgaXRlbS5vcHRpb25zLCB0cnVlKTtcbiAgICAgICAgY2xvbmVkT3B0aW9ucy54ID0gaXRlbS54O1xuICAgICAgICBjbG9uZWRPcHRpb25zLnkgPSBpdGVtLnk7XG4gICAgICAgIGNsb25lZE9wdGlvbnMuYW1vdW50T2ZDb25uZWN0aW9ucyA9IGl0ZW0uZWRnZXMubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXRpbC5kZWVwRXh0ZW5kKGNsb25lZE9wdGlvbnMsIGl0ZW0ub3B0aW9ucywgdHJ1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2xvbmVkT3B0aW9ucztcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE5ldHdvcmtVdGlsO1xufSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBOZXR3b3JrVXRpbDtcblxuLyoqKi8gfSksXG4vKiA1OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IF9fd2VicGFja19yZXF1aXJlX18oODYpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cbi8qKiovIH0pLFxuLyogNTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDYwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgTElCUkFSWSA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpO1xudmFyICRleHBvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcbnZhciByZWRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjQpO1xudmFyIGhpZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcbnZhciBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcbnZhciAkaXRlckNyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTEpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nik7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY2KTtcbnZhciBJVEVSQVRPUiA9IF9fd2VicGFja19yZXF1aXJlX18oOCkoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1kgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSk7IC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbnZhciBGRl9JVEVSQVRPUiA9ICdAQGl0ZXJhdG9yJztcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbiAoa2luZCkge1xuICAgIGlmICghQlVHR1kgJiYga2luZCBpbiBwcm90bykgcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVM7XG4gIHZhciBWQUxVRVNfQlVHID0gZmFsc2U7XG4gIHZhciBwcm90byA9IEJhc2UucHJvdG90eXBlO1xuICB2YXIgJG5hdGl2ZSA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXTtcbiAgdmFyICRkZWZhdWx0ID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVCk7XG4gIHZhciAkZW50cmllcyA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWQ7XG4gIHZhciAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZTtcbiAgdmFyIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYgKCRhbnlOYXRpdmUpIHtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSgpKSk7XG4gICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZiAoIUxJQlJBUlkgJiYgdHlwZW9mIEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXSAhPSAnZnVuY3Rpb24nKSBoaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUykge1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZiAoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpIHtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddID0gcmV0dXJuVGhpcztcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoa2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIGlmICghKGtleSBpbiBwcm90bykpIHJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG5cblxuLyoqKi8gfSksXG4vKiA2MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkwKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCB0aGF0LCBsZW5ndGgpIHtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYgKHRoYXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZuO1xuICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoLyogLi4uYXJncyAqLykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDYyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gIV9fd2VicGFja19yZXF1aXJlX18oMTMpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX3JlcXVpcmVfXyg2MykoJ2RpdicpLCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuXG5cbi8qKiovIH0pLFxuLyogNjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG52YXIgZG9jdW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKS5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiA2NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXG5cbi8qKiovIH0pLFxuLyogNjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xudmFyIHRvSU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xudmFyIGFycmF5SW5kZXhPZiA9IF9fd2VicGFja19yZXF1aXJlX18oOTMpKGZhbHNlKTtcbnZhciBJRV9QUk9UTyA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JT2JqZWN0KG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSBpZiAoa2V5ICE9IElFX1BST1RPKSBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDY2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG52YXIgdG9PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKTtcbnZhciBJRV9QUk9UTyA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpKCdJRV9QUk9UTycpO1xudmFyIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKE8pIHtcbiAgTyA9IHRvT2JqZWN0KE8pO1xuICBpZiAoaGFzKE8sIElFX1BST1RPKSkgcmV0dXJuIE9bSUVfUFJPVE9dO1xuICBpZiAodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDtcbn07XG5cblxuLyoqKi8gfSksXG4vKiA2NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpO1xudmFyIFRBRyA9IF9fd2VicGFja19yZXF1aXJlX18oOCkoJ3RvU3RyaW5nVGFnJyk7XG4vLyBFUzMgd3JvbmcgaGVyZVxudmFyIEFSRyA9IGNvZihmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgVCwgQjtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKFQgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRBRykpID09ICdzdHJpbmcnID8gVFxuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQVJHID8gY29mKE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKEIgPSBjb2YoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiBCO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDY4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIG1vc3QgT2JqZWN0IG1ldGhvZHMgYnkgRVM2IHNob3VsZCBhY2NlcHQgcHJpbWl0aXZlc1xudmFyICRleHBvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcbnZhciBjb3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBleGVjKSB7XG4gIHZhciBmbiA9IChjb3JlLk9iamVjdCB8fCB7fSlbS0VZXSB8fCBPYmplY3RbS0VZXTtcbiAgdmFyIGV4cCA9IHt9O1xuICBleHBbS0VZXSA9IGV4ZWMoZm4pO1xuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHsgZm4oMSk7IH0pLCAnT2JqZWN0JywgZXhwKTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiA2OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyAxOS4xLjIuNyAvIDE1LjIuMy40IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG52YXIgJGtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1KTtcbnZhciBoaWRkZW5LZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NSkuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICByZXR1cm4gJGtleXMoTywgaGlkZGVuS2V5cyk7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogNzAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHBJRSA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIGNyZWF0ZURlc2MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcbnZhciB0b0lPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcbnZhciB0b1ByaW1pdGl2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDApO1xudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xudmFyIElFOF9ET01fREVGSU5FID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Mik7XG52YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbmV4cG9ydHMuZiA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpID8gZ09QRCA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIE8gPSB0b0lPYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBnT1BEKE8sIFApO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKGhhcyhPLCBQKSkgcmV0dXJuIGNyZWF0ZURlc2MoIXBJRS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDcxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGZpcnN0IGNoZWNrIGlmIG1vbWVudC5qcyBpcyBhbHJlYWR5IGxvYWRlZCBpbiB0aGUgYnJvd3NlciB3aW5kb3csIGlmIHNvLFxuLy8gdXNlIHRoaXMgaW5zdGFuY2UuIEVsc2UsIGxvYWQgdmlhIGNvbW1vbmpzLlxubW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3dbJ21vbWVudCddIHx8IF9fd2VicGFja19yZXF1aXJlX18oMTE2KTtcblxuLyoqKi8gfSksXG4vKiA3MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKipcbiAqIEEgcXVldWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgICAgICAgICAgIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAtIGRlbGF5OiBudW1iZXIgICAgV2hlbiBwcm92aWRlZCwgdGhlIHF1ZXVlIHdpbGwgYmUgZmx1c2hlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0b21hdGljYWxseSBhZnRlciBhbiBpbmFjdGl2aXR5IG9mIHRoaXMgZGVsYXlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIG1pbGxpc2Vjb25kcy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgdmFsdWUgaXMgbnVsbC5cbiAqICAgICAgICAgICAgLSBtYXg6IG51bWJlciAgICAgIFdoZW4gdGhlIHF1ZXVlIGV4Y2VlZHMgdGhlIGdpdmVuIG1heGltdW0gbnVtYmVyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiBlbnRyaWVzLCB0aGUgcXVldWUgaXMgZmx1c2hlZCBhdXRvbWF0aWNhbGx5LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCB2YWx1ZSBvZiBtYXggaXMgSW5maW5pdHkuXG4gKiBAY29uc3RydWN0b3IgUXVldWVcbiAqL1xuZnVuY3Rpb24gUXVldWUob3B0aW9ucykge1xuICAvLyBvcHRpb25zXG4gIHRoaXMuZGVsYXkgPSBudWxsO1xuICB0aGlzLm1heCA9IEluZmluaXR5O1xuXG4gIC8vIHByb3BlcnRpZXNcbiAgdGhpcy5fcXVldWUgPSBbXTtcbiAgdGhpcy5fdGltZW91dCA9IG51bGw7XG4gIHRoaXMuX2V4dGVuZGVkID0gbnVsbDtcblxuICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG59XG5cbi8qKlxuICogVXBkYXRlIHRoZSBjb25maWd1cmF0aW9uIG9mIHRoZSBxdWV1ZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgICAgICAgICAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gKiAgICAgICAgICAgIC0gZGVsYXk6IG51bWJlciAgICBXaGVuIHByb3ZpZGVkLCB0aGUgcXVldWUgd2lsbCBiZSBmbHVzaGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRvbWF0aWNhbGx5IGFmdGVyIGFuIGluYWN0aXZpdHkgb2YgdGhpcyBkZWxheVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gbWlsbGlzZWNvbmRzLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCB2YWx1ZSBpcyBudWxsLlxuICogICAgICAgICAgICAtIG1heDogbnVtYmVyICAgICAgV2hlbiB0aGUgcXVldWUgZXhjZWVkcyB0aGUgZ2l2ZW4gbWF4aW11bSBudW1iZXJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIGVudHJpZXMsIHRoZSBxdWV1ZSBpcyBmbHVzaGVkIGF1dG9tYXRpY2FsbHkuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IHZhbHVlIG9mIG1heCBpcyBJbmZpbml0eS5cbiAqL1xuUXVldWUucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5kZWxheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLmRlbGF5ID0gb3B0aW9ucy5kZWxheTtcbiAgfVxuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy5tYXggPSBvcHRpb25zLm1heDtcbiAgfVxuXG4gIHRoaXMuX2ZsdXNoSWZOZWVkZWQoKTtcbn07XG5cbi8qKlxuICogRXh0ZW5kIGFuIG9iamVjdCB3aXRoIHF1ZXVpbmcgZnVuY3Rpb25hbGl0eS5cbiAqIFRoZSBvYmplY3Qgd2lsbCBiZSBleHRlbmRlZCB3aXRoIGEgZnVuY3Rpb24gZmx1c2gsIGFuZCB0aGUgbWV0aG9kcyBwcm92aWRlZFxuICogaW4gb3B0aW9ucy5yZXBsYWNlIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBxdWV1ZWQgb25lcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgICAgICAgICAgIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAtIHJlcGxhY2U6IEFycmF5LjxzdHJpbmc+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBIGxpc3Qgd2l0aCBtZXRob2QgbmFtZXMgb2YgdGhlIG1ldGhvZHNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uIHRoZSBvYmplY3QgdG8gYmUgcmVwbGFjZWQgd2l0aCBxdWV1ZWQgb25lcy5cbiAqICAgICAgICAgICAgLSBkZWxheTogbnVtYmVyICAgIFdoZW4gcHJvdmlkZWQsIHRoZSBxdWV1ZSB3aWxsIGJlIGZsdXNoZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9tYXRpY2FsbHkgYWZ0ZXIgYW4gaW5hY3Rpdml0eSBvZiB0aGlzIGRlbGF5XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiBtaWxsaXNlY29uZHMuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IHZhbHVlIGlzIG51bGwuXG4gKiAgICAgICAgICAgIC0gbWF4OiBudW1iZXIgICAgICBXaGVuIHRoZSBxdWV1ZSBleGNlZWRzIHRoZSBnaXZlbiBtYXhpbXVtIG51bWJlclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgZW50cmllcywgdGhlIHF1ZXVlIGlzIGZsdXNoZWQgYXV0b21hdGljYWxseS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgdmFsdWUgb2YgbWF4IGlzIEluZmluaXR5LlxuICogQHJldHVybiB7UXVldWV9IFJldHVybnMgdGhlIGNyZWF0ZWQgcXVldWVcbiAqL1xuUXVldWUuZXh0ZW5kID0gZnVuY3Rpb24gKG9iamVjdCwgb3B0aW9ucykge1xuICB2YXIgcXVldWUgPSBuZXcgUXVldWUob3B0aW9ucyk7XG5cbiAgaWYgKG9iamVjdC5mbHVzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUYXJnZXQgb2JqZWN0IGFscmVhZHkgaGFzIGEgcHJvcGVydHkgZmx1c2gnKTtcbiAgfVxuICBvYmplY3QuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgcXVldWUuZmx1c2goKTtcbiAgfTtcblxuICB2YXIgbWV0aG9kcyA9IFt7XG4gICAgbmFtZTogJ2ZsdXNoJyxcbiAgICBvcmlnaW5hbDogdW5kZWZpbmVkXG4gIH1dO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVwbGFjZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5yZXBsYWNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IG9wdGlvbnMucmVwbGFjZVtpXTtcbiAgICAgIG1ldGhvZHMucHVzaCh7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIG9yaWdpbmFsOiBvYmplY3RbbmFtZV1cbiAgICAgIH0pO1xuICAgICAgcXVldWUucmVwbGFjZShvYmplY3QsIG5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIHF1ZXVlLl9leHRlbmRlZCA9IHtcbiAgICBvYmplY3Q6IG9iamVjdCxcbiAgICBtZXRob2RzOiBtZXRob2RzXG4gIH07XG5cbiAgcmV0dXJuIHF1ZXVlO1xufTtcblxuLyoqXG4gKiBEZXN0cm95IHRoZSBxdWV1ZS4gVGhlIHF1ZXVlIHdpbGwgZmlyc3QgZmx1c2ggYWxsIHF1ZXVlZCBhY3Rpb25zLCBhbmQgaW5cbiAqIGNhc2UgaXQgaGFzIGV4dGVuZGVkIGFuIG9iamVjdCwgd2lsbCByZXN0b3JlIHRoZSBvcmlnaW5hbCBvYmplY3QuXG4gKi9cblF1ZXVlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmZsdXNoKCk7XG5cbiAgaWYgKHRoaXMuX2V4dGVuZGVkKSB7XG4gICAgdmFyIG9iamVjdCA9IHRoaXMuX2V4dGVuZGVkLm9iamVjdDtcbiAgICB2YXIgbWV0aG9kcyA9IHRoaXMuX2V4dGVuZGVkLm1ldGhvZHM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbWV0aG9kID0gbWV0aG9kc1tpXTtcbiAgICAgIGlmIChtZXRob2Qub3JpZ2luYWwpIHtcbiAgICAgICAgb2JqZWN0W21ldGhvZC5uYW1lXSA9IG1ldGhvZC5vcmlnaW5hbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSBvYmplY3RbbWV0aG9kLm5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9leHRlbmRlZCA9IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogUmVwbGFjZSBhIG1ldGhvZCBvbiBhbiBvYmplY3Qgd2l0aCBhIHF1ZXVlZCB2ZXJzaW9uXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0ICAgT2JqZWN0IGhhdmluZyB0aGUgbWV0aG9kXG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kICAgVGhlIG1ldGhvZCBuYW1lXG4gKi9cblF1ZXVlLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gKG9iamVjdCwgbWV0aG9kKSB7XG4gIHZhciBtZSA9IHRoaXM7XG4gIHZhciBvcmlnaW5hbCA9IG9iamVjdFttZXRob2RdO1xuICBpZiAoIW9yaWdpbmFsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2QgJyArIG1ldGhvZCArICcgdW5kZWZpbmVkJyk7XG4gIH1cblxuICBvYmplY3RbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBjcmVhdGUgYW4gQXJyYXkgd2l0aCB0aGUgYXJndW1lbnRzXG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICAvLyBhZGQgdGhpcyBjYWxsIHRvIHRoZSBxdWV1ZVxuICAgIG1lLnF1ZXVlKHtcbiAgICAgIGFyZ3M6IGFyZ3MsXG4gICAgICBmbjogb3JpZ2luYWwsXG4gICAgICBjb250ZXh0OiB0aGlzXG4gICAgfSk7XG4gIH07XG59O1xuXG4vKipcbiAqIFF1ZXVlIGEgY2FsbFxuICogQHBhcmFtIHtmdW5jdGlvbiB8IHtmbjogZnVuY3Rpb24sIGFyZ3M6IEFycmF5fSB8IHtmbjogZnVuY3Rpb24sIGFyZ3M6IEFycmF5LCBjb250ZXh0OiBPYmplY3R9fSBlbnRyeVxuICovXG5RdWV1ZS5wcm90b3R5cGUucXVldWUgPSBmdW5jdGlvbiAoZW50cnkpIHtcbiAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuX3F1ZXVlLnB1c2goeyBmbjogZW50cnkgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fcXVldWUucHVzaChlbnRyeSk7XG4gIH1cblxuICB0aGlzLl9mbHVzaElmTmVlZGVkKCk7XG59O1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIHF1ZXVlIG5lZWRzIHRvIGJlIGZsdXNoZWRcbiAqIEBwcml2YXRlXG4gKi9cblF1ZXVlLnByb3RvdHlwZS5fZmx1c2hJZk5lZWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gZmx1c2ggd2hlbiB0aGUgbWF4aW11bSBpcyBleGNlZWRlZC5cbiAgaWYgKHRoaXMuX3F1ZXVlLmxlbmd0aCA+IHRoaXMubWF4KSB7XG4gICAgdGhpcy5mbHVzaCgpO1xuICB9XG5cbiAgLy8gZmx1c2ggYWZ0ZXIgYSBwZXJpb2Qgb2YgaW5hY3Rpdml0eSB3aGVuIGEgZGVsYXkgaXMgY29uZmlndXJlZFxuICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XG4gIGlmICh0aGlzLnF1ZXVlLmxlbmd0aCA+IDAgJiYgdHlwZW9mIHRoaXMuZGVsYXkgPT09ICdudW1iZXInKSB7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBtZS5mbHVzaCgpO1xuICAgIH0sIHRoaXMuZGVsYXkpO1xuICB9XG59O1xuXG4vKipcbiAqIEZsdXNoIGFsbCBxdWV1ZWQgY2FsbHNcbiAqL1xuUXVldWUucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICB3aGlsZSAodGhpcy5fcXVldWUubGVuZ3RoID4gMCkge1xuICAgIHZhciBlbnRyeSA9IHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG4gICAgZW50cnkuZm4uYXBwbHkoZW50cnkuY29udGV4dCB8fCBlbnRyeS5mbiwgZW50cnkuYXJncyB8fCBbXSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUXVldWU7XG5cbi8qKiovIH0pLFxuLyogNzMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXG4vKipcbiAqIEV4cG9zZSBgRW1pdHRlcmAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRW1pdHRlcihvYmopIHtcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XG59O1xuXG4vKipcbiAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG4gIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xuICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub24gPVxuRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgKHRoaXMuX2NhbGxiYWNrc1tldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdIHx8IFtdKVxuICAgIC5wdXNoKGZuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cbiAgZnVuY3Rpb24gb24oKSB7XG4gICAgc2VsZi5vZmYoZXZlbnQsIG9uKTtcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgb24uZm4gPSBmbjtcbiAgdGhpcy5vbihldmVudCwgb24pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblxuICAvLyBhbGxcbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG4gIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpcztcblxuICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXG4gIHZhciBjYjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICBjYiA9IGNhbGxiYWNrc1tpXTtcbiAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge01peGVkfSAuLi5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcblxuICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1tldmVudF0gfHwgW107XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogNzQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9jcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKTtcblxudmFyIF9jcmVhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vKipcbiAqIFBhcnNlIGEgdGV4dCBzb3VyY2UgY29udGFpbmluZyBkYXRhIGluIERPVCBsYW5ndWFnZSBpbnRvIGEgSlNPTiBvYmplY3QuXG4gKiBUaGUgb2JqZWN0IGNvbnRhaW5zIHR3byBsaXN0czogb25lIHdpdGggbm9kZXMgYW5kIG9uZSB3aXRoIGVkZ2VzLlxuICpcbiAqIERPVCBsYW5ndWFnZSByZWZlcmVuY2U6IGh0dHA6Ly93d3cuZ3JhcGh2aXoub3JnL2RvYy9pbmZvL2xhbmcuaHRtbFxuICpcbiAqIERPVCBsYW5ndWFnZSBhdHRyaWJ1dGVzOiBodHRwOi8vZ3JhcGh2aXoub3JnL2NvbnRlbnQvYXR0cnNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YSAgICAgVGV4dCBjb250YWluaW5nIGEgZ3JhcGggaW4gRE9ULW5vdGF0aW9uXG4gKiBAcmV0dXJuIHtPYmplY3R9IGdyYXBoICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdHdvIHBhcmFtZXRlcnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAge09iamVjdFtdfSBub2Rlc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIHtPYmplY3RbXX0gZWRnZXNcbiAqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBUT0RPXG4gKiA9PT09XG4gKlxuICogRm9yIGxhYmVsIGhhbmRsaW5nLCB0aGlzIGlzIGFuIGluY29tcGxldGUgaW1wbGVtZW50YXRpb24uIEZyb20gZG9jcyAocXVvdGUgIzMwMTUpOlxuICpcbiAqID4gdGhlIGVzY2FwZSBzZXF1ZW5jZXMgXCJcXG5cIiwgXCJcXGxcIiBhbmQgXCJcXHJcIiBkaXZpZGUgdGhlIGxhYmVsIGludG8gbGluZXMsIGNlbnRlcmVkLFxuICogPiBsZWZ0LWp1c3RpZmllZCwgYW5kIHJpZ2h0LWp1c3RpZmllZCwgcmVzcGVjdGl2ZWx5LlxuICpcbiAqIFNvdXJjZTogaHR0cDovL3d3dy5ncmFwaHZpei5vcmcvY29udGVudC9hdHRycyNrZXNjU3RyaW5nXG4gKlxuICogPiBBcyBhbm90aGVyIGFpZCBmb3IgcmVhZGFiaWxpdHksIGRvdCBhbGxvd3MgZG91YmxlLXF1b3RlZCBzdHJpbmdzIHRvIHNwYW4gbXVsdGlwbGUgcGh5c2ljYWxcbiAqID4gbGluZXMgdXNpbmcgdGhlIHN0YW5kYXJkIEMgY29udmVudGlvbiBvZiBhIGJhY2tzbGFzaCBpbW1lZGlhdGVseSBwcmVjZWRpbmcgYSBuZXdsaW5lXG4gKiA+IGNoYXJhY3RlclxuICogPiBJbiBhZGRpdGlvbiwgZG91YmxlLXF1b3RlZCBzdHJpbmdzIGNhbiBiZSBjb25jYXRlbmF0ZWQgdXNpbmcgYSAnKycgb3BlcmF0b3IuXG4gKiA+IEFzIEhUTUwgc3RyaW5ncyBjYW4gY29udGFpbiBuZXdsaW5lIGNoYXJhY3RlcnMsIHdoaWNoIGFyZSB1c2VkIHNvbGVseSBmb3IgZm9ybWF0dGluZyxcbiAqID4gdGhlIGxhbmd1YWdlIGRvZXMgbm90IGFsbG93IGVzY2FwZWQgbmV3bGluZXMgb3IgY29uY2F0ZW5hdGlvbiBvcGVyYXRvcnMgdG8gYmUgdXNlZFxuICogPiB3aXRoaW4gdGhlbS5cbiAqXG4gKiAtIEN1cnJlbnRseSwgb25seSAnXFxcXG4nIGlzIGhhbmRsZWRcbiAqIC0gTm90ZSB0aGF0IHRleHQgZXhwbGljaXRseSBzYXlzICdsYWJlbHMnOyB0aGUgZG90IHBhcnNlciBjdXJyZW50bHkgaGFuZGxlcyBlc2NhcGVcbiAqICAgc2VxdWVuY2VzIGluICoqYWxsKiogc3RyaW5ncy5cbiAqL1xuZnVuY3Rpb24gcGFyc2VET1QoZGF0YSkge1xuICBkb3QgPSBkYXRhO1xuICByZXR1cm4gcGFyc2VHcmFwaCgpO1xufVxuXG4vLyBtYXBwaW5nIG9mIGF0dHJpYnV0ZXMgZnJvbSBET1QgKHRoZSBrZXlzKSB0byB2aXMuanMgKHRoZSB2YWx1ZXMpXG52YXIgTk9ERV9BVFRSX01BUFBJTkcgPSB7XG4gIGZvbnRzaXplOiAnZm9udC5zaXplJyxcbiAgZm9udGNvbG9yOiAnZm9udC5jb2xvcicsXG4gIGxhYmVsZm9udGNvbG9yOiAnZm9udC5jb2xvcicsXG4gIGZvbnRuYW1lOiAnZm9udC5mYWNlJyxcbiAgY29sb3I6IFsnY29sb3IuYm9yZGVyJywgJ2NvbG9yLmJhY2tncm91bmQnXSxcbiAgZmlsbGNvbG9yOiAnY29sb3IuYmFja2dyb3VuZCcsXG4gIHRvb2x0aXA6ICd0aXRsZScsXG4gIGxhYmVsdG9vbHRpcDogJ3RpdGxlJ1xufTtcbnZhciBFREdFX0FUVFJfTUFQUElORyA9ICgwLCBfY3JlYXRlMlsnZGVmYXVsdCddKShOT0RFX0FUVFJfTUFQUElORyk7XG5FREdFX0FUVFJfTUFQUElORy5jb2xvciA9ICdjb2xvci5jb2xvcic7XG5FREdFX0FUVFJfTUFQUElORy5zdHlsZSA9ICdkYXNoZXMnO1xuXG4vLyB0b2tlbiB0eXBlcyBlbnVtZXJhdGlvblxudmFyIFRPS0VOVFlQRSA9IHtcbiAgTlVMTDogMCxcbiAgREVMSU1JVEVSOiAxLFxuICBJREVOVElGSUVSOiAyLFxuICBVTktOT1dOOiAzXG5cbiAgLy8gbWFwIHdpdGggYWxsIGRlbGltaXRlcnNcbn07dmFyIERFTElNSVRFUlMgPSB7XG4gICd7JzogdHJ1ZSxcbiAgJ30nOiB0cnVlLFxuICAnWyc6IHRydWUsXG4gICddJzogdHJ1ZSxcbiAgJzsnOiB0cnVlLFxuICAnPSc6IHRydWUsXG4gICcsJzogdHJ1ZSxcblxuICAnLT4nOiB0cnVlLFxuICAnLS0nOiB0cnVlXG59O1xuXG52YXIgZG90ID0gJyc7IC8vIGN1cnJlbnQgZG90IGZpbGVcbnZhciBpbmRleCA9IDA7IC8vIGN1cnJlbnQgaW5kZXggaW4gZG90IGZpbGVcbnZhciBjID0gJyc7IC8vIGN1cnJlbnQgdG9rZW4gY2hhcmFjdGVyIGluIGV4cHJcbnZhciB0b2tlbiA9ICcnOyAvLyBjdXJyZW50IHRva2VuXG52YXIgdG9rZW5UeXBlID0gVE9LRU5UWVBFLk5VTEw7IC8vIHR5cGUgb2YgdGhlIHRva2VuXG5cbi8qKlxuICogR2V0IHRoZSBmaXJzdCBjaGFyYWN0ZXIgZnJvbSB0aGUgZG90IGZpbGUuXG4gKiBUaGUgY2hhcmFjdGVyIGlzIHN0b3JlZCBpbnRvIHRoZSBjaGFyIGMuIElmIHRoZSBlbmQgb2YgdGhlIGRvdCBmaWxlIGlzXG4gKiByZWFjaGVkLCB0aGUgZnVuY3Rpb24gcHV0cyBhbiBlbXB0eSBzdHJpbmcgaW4gYy5cbiAqL1xuZnVuY3Rpb24gZmlyc3QoKSB7XG4gIGluZGV4ID0gMDtcbiAgYyA9IGRvdC5jaGFyQXQoMCk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBuZXh0IGNoYXJhY3RlciBmcm9tIHRoZSBkb3QgZmlsZS5cbiAqIFRoZSBjaGFyYWN0ZXIgaXMgc3RvcmVkIGludG8gdGhlIGNoYXIgYy4gSWYgdGhlIGVuZCBvZiB0aGUgZG90IGZpbGUgaXNcbiAqIHJlYWNoZWQsIHRoZSBmdW5jdGlvbiBwdXRzIGFuIGVtcHR5IHN0cmluZyBpbiBjLlxuICovXG5mdW5jdGlvbiBuZXh0KCkge1xuICBpbmRleCsrO1xuICBjID0gZG90LmNoYXJBdChpbmRleCk7XG59XG5cbi8qKlxuICogUHJldmlldyB0aGUgbmV4dCBjaGFyYWN0ZXIgZnJvbSB0aGUgZG90IGZpbGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGNOZXh0XG4gKi9cbmZ1bmN0aW9uIG5leHRQcmV2aWV3KCkge1xuICByZXR1cm4gZG90LmNoYXJBdChpbmRleCArIDEpO1xufVxuXG52YXIgcmVnZXhBbHBoYU51bWVyaWMgPSAvW2EtekEtWl8wLTkuOiNdLztcbi8qKlxuICogVGVzdCB3aGV0aGVyIGdpdmVuIGNoYXJhY3RlciBpcyBhbHBoYWJldGljIG9yIG51bWVyaWNcbiAqIEBwYXJhbSB7c3RyaW5nfSBjXG4gKiBAcmV0dXJuIHtCb29sZWFufSBpc0FscGhhTnVtZXJpY1xuICovXG5mdW5jdGlvbiBpc0FscGhhTnVtZXJpYyhjKSB7XG4gIHJldHVybiByZWdleEFscGhhTnVtZXJpYy50ZXN0KGMpO1xufVxuXG4vKipcbiAqIE1lcmdlIGFsbCBvcHRpb25zIG9mIG9iamVjdCBiIGludG8gb2JqZWN0IGJcbiAqIEBwYXJhbSB7T2JqZWN0fSBhXG4gKiBAcGFyYW0ge09iamVjdH0gYlxuICogQHJldHVybiB7T2JqZWN0fSBhXG4gKi9cbmZ1bmN0aW9uIG1lcmdlKGEsIGIpIHtcbiAgaWYgKCFhKSB7XG4gICAgYSA9IHt9O1xuICB9XG5cbiAgaWYgKGIpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIGIpIHtcbiAgICAgIGlmIChiLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGFbbmFtZV0gPSBiW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYTtcbn1cblxuLyoqXG4gKiBTZXQgYSB2YWx1ZSBpbiBhbiBvYmplY3QsIHdoZXJlIHRoZSBwcm92aWRlZCBwYXJhbWV0ZXIgbmFtZSBjYW4gYmUgYVxuICogcGF0aCB3aXRoIG5lc3RlZCBwYXJhbWV0ZXJzLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgICAgdmFyIG9iaiA9IHthOiAyfTtcbiAqICAgICBzZXRWYWx1ZShvYmosICdiLmMnLCAzKTsgICAgIC8vIG9iaiA9IHthOiAyLCBiOiB7YzogM319XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggIEEgcGFyYW1ldGVyIG5hbWUgb3IgZG90LXNlcGFyYXRlZCBwYXJhbWV0ZXIgcGF0aCxcbiAqICAgICAgICAgICAgICAgICAgICAgIGxpa2UgXCJjb2xvci5oaWdobGlnaHQuYm9yZGVyXCIuXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHNldFZhbHVlKG9iaiwgcGF0aCwgdmFsdWUpIHtcbiAgdmFyIGtleXMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHZhciBvID0gb2JqO1xuICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICB2YXIga2V5ID0ga2V5cy5zaGlmdCgpO1xuICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgLy8gdGhpcyBpc24ndCB0aGUgZW5kIHBvaW50XG4gICAgICBpZiAoIW9ba2V5XSkge1xuICAgICAgICBvW2tleV0gPSB7fTtcbiAgICAgIH1cbiAgICAgIG8gPSBvW2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRoaXMgaXMgdGhlIGVuZCBwb2ludFxuICAgICAgb1trZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWRkIGEgbm9kZSB0byBhIGdyYXBoIG9iamVjdC4gSWYgdGhlcmUgaXMgYWxyZWFkeSBhIG5vZGUgd2l0aFxuICogdGhlIHNhbWUgaWQsIHRoZWlyIGF0dHJpYnV0ZXMgd2lsbCBiZSBtZXJnZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gZ3JhcGhcbiAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXG4gKi9cbmZ1bmN0aW9uIGFkZE5vZGUoZ3JhcGgsIG5vZGUpIHtcbiAgdmFyIGksIGxlbjtcbiAgdmFyIGN1cnJlbnQgPSBudWxsO1xuXG4gIC8vIGZpbmQgcm9vdCBncmFwaCAoaW4gY2FzZSBvZiBzdWJncmFwaClcbiAgdmFyIGdyYXBocyA9IFtncmFwaF07IC8vIGxpc3Qgd2l0aCBhbGwgZ3JhcGhzIGZyb20gY3VycmVudCBncmFwaCB0byByb290IGdyYXBoXG4gIHZhciByb290ID0gZ3JhcGg7XG4gIHdoaWxlIChyb290LnBhcmVudCkge1xuICAgIGdyYXBocy5wdXNoKHJvb3QucGFyZW50KTtcbiAgICByb290ID0gcm9vdC5wYXJlbnQ7XG4gIH1cblxuICAvLyBmaW5kIGV4aXN0aW5nIG5vZGUgKGF0IHJvb3QgbGV2ZWwpIGJ5IGl0cyBpZFxuICBpZiAocm9vdC5ub2Rlcykge1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IHJvb3Qubm9kZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChub2RlLmlkID09PSByb290Lm5vZGVzW2ldLmlkKSB7XG4gICAgICAgIGN1cnJlbnQgPSByb290Lm5vZGVzW2ldO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIWN1cnJlbnQpIHtcbiAgICAvLyB0aGlzIGlzIGEgbmV3IG5vZGVcbiAgICBjdXJyZW50ID0ge1xuICAgICAgaWQ6IG5vZGUuaWRcbiAgICB9O1xuICAgIGlmIChncmFwaC5ub2RlKSB7XG4gICAgICAvLyBjbG9uZSBkZWZhdWx0IGF0dHJpYnV0ZXNcbiAgICAgIGN1cnJlbnQuYXR0ciA9IG1lcmdlKGN1cnJlbnQuYXR0ciwgZ3JhcGgubm9kZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gYWRkIG5vZGUgdG8gdGhpcyAoc3ViKWdyYXBoIGFuZCBhbGwgaXRzIHBhcmVudCBncmFwaHNcbiAgZm9yIChpID0gZ3JhcGhzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGcgPSBncmFwaHNbaV07XG5cbiAgICBpZiAoIWcubm9kZXMpIHtcbiAgICAgIGcubm9kZXMgPSBbXTtcbiAgICB9XG4gICAgaWYgKGcubm9kZXMuaW5kZXhPZihjdXJyZW50KSA9PT0gLTEpIHtcbiAgICAgIGcubm9kZXMucHVzaChjdXJyZW50KTtcbiAgICB9XG4gIH1cblxuICAvLyBtZXJnZSBhdHRyaWJ1dGVzXG4gIGlmIChub2RlLmF0dHIpIHtcbiAgICBjdXJyZW50LmF0dHIgPSBtZXJnZShjdXJyZW50LmF0dHIsIG5vZGUuYXR0cik7XG4gIH1cbn1cblxuLyoqXG4gKiBBZGQgYW4gZWRnZSB0byBhIGdyYXBoIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IGdyYXBoXG4gKiBAcGFyYW0ge09iamVjdH0gZWRnZVxuICovXG5mdW5jdGlvbiBhZGRFZGdlKGdyYXBoLCBlZGdlKSB7XG4gIGlmICghZ3JhcGguZWRnZXMpIHtcbiAgICBncmFwaC5lZGdlcyA9IFtdO1xuICB9XG4gIGdyYXBoLmVkZ2VzLnB1c2goZWRnZSk7XG4gIGlmIChncmFwaC5lZGdlKSB7XG4gICAgdmFyIGF0dHIgPSBtZXJnZSh7fSwgZ3JhcGguZWRnZSk7IC8vIGNsb25lIGRlZmF1bHQgYXR0cmlidXRlc1xuICAgIGVkZ2UuYXR0ciA9IG1lcmdlKGF0dHIsIGVkZ2UuYXR0cik7IC8vIG1lcmdlIGF0dHJpYnV0ZXNcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBlZGdlIHRvIGEgZ3JhcGggb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gZ3JhcGhcbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyIHwgT2JqZWN0fSBmcm9tXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlciB8IE9iamVjdH0gdG9cbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge09iamVjdCB8IG51bGx9IGF0dHJcbiAqIEByZXR1cm4ge09iamVjdH0gZWRnZVxuICovXG5mdW5jdGlvbiBjcmVhdGVFZGdlKGdyYXBoLCBmcm9tLCB0bywgdHlwZSwgYXR0cikge1xuICB2YXIgZWRnZSA9IHtcbiAgICBmcm9tOiBmcm9tLFxuICAgIHRvOiB0byxcbiAgICB0eXBlOiB0eXBlXG4gIH07XG5cbiAgaWYgKGdyYXBoLmVkZ2UpIHtcbiAgICBlZGdlLmF0dHIgPSBtZXJnZSh7fSwgZ3JhcGguZWRnZSk7IC8vIGNsb25lIGRlZmF1bHQgYXR0cmlidXRlc1xuICB9XG4gIGVkZ2UuYXR0ciA9IG1lcmdlKGVkZ2UuYXR0ciB8fCB7fSwgYXR0cik7IC8vIG1lcmdlIGF0dHJpYnV0ZXNcblxuICAvLyBNb3ZlIGFycm93cyBhdHRyaWJ1dGUgZnJvbSBhdHRyIHRvIGVkZ2UgdGVtcG9yYWxseSBjcmVhdGVkIGluXG4gIC8vIHBhcnNlQXR0cmlidXRlTGlzdCgpLlxuICBpZiAoYXR0ciAhPSBudWxsKSB7XG4gICAgaWYgKGF0dHIuaGFzT3duUHJvcGVydHkoJ2Fycm93cycpKSB7XG4gICAgICBlZGdlWydhcnJvd3MnXSA9IHsgdG86IHsgZW5hYmxlZDogdHJ1ZSwgdHlwZTogYXR0ci5hcnJvd3MudHlwZSB9IH07XG4gICAgICBhdHRyWydhcnJvd3MnXSA9IG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBlZGdlO1xufVxuXG4vKipcbiAqIEdldCBuZXh0IHRva2VuIGluIHRoZSBjdXJyZW50IGRvdCBmaWxlLlxuICogVGhlIHRva2VuIGFuZCB0b2tlbiB0eXBlIGFyZSBhdmFpbGFibGUgYXMgdG9rZW4gYW5kIHRva2VuVHlwZVxuICovXG5mdW5jdGlvbiBnZXRUb2tlbigpIHtcbiAgdG9rZW5UeXBlID0gVE9LRU5UWVBFLk5VTEw7XG4gIHRva2VuID0gJyc7XG5cbiAgLy8gc2tpcCBvdmVyIHdoaXRlc3BhY2VzXG4gIHdoaWxlIChjID09PSAnICcgfHwgYyA9PT0gJ1xcdCcgfHwgYyA9PT0gJ1xcbicgfHwgYyA9PT0gJ1xccicpIHtcbiAgICAvLyBzcGFjZSwgdGFiLCBlbnRlclxuICAgIG5leHQoKTtcbiAgfVxuXG4gIGRvIHtcbiAgICB2YXIgaXNDb21tZW50ID0gZmFsc2U7XG5cbiAgICAvLyBza2lwIGNvbW1lbnRcbiAgICBpZiAoYyA9PT0gJyMnKSB7XG4gICAgICAvLyBmaW5kIHRoZSBwcmV2aW91cyBub24tc3BhY2UgY2hhcmFjdGVyXG4gICAgICB2YXIgaSA9IGluZGV4IC0gMTtcbiAgICAgIHdoaWxlIChkb3QuY2hhckF0KGkpID09PSAnICcgfHwgZG90LmNoYXJBdChpKSA9PT0gJ1xcdCcpIHtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgICAgaWYgKGRvdC5jaGFyQXQoaSkgPT09ICdcXG4nIHx8IGRvdC5jaGFyQXQoaSkgPT09ICcnKSB7XG4gICAgICAgIC8vIHRoZSAjIGlzIGF0IHRoZSBzdGFydCBvZiBhIGxpbmUsIHRoaXMgaXMgaW5kZWVkIGEgbGluZSBjb21tZW50XG4gICAgICAgIHdoaWxlIChjICE9ICcnICYmIGMgIT0gJ1xcbicpIHtcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaXNDb21tZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGMgPT09ICcvJyAmJiBuZXh0UHJldmlldygpID09PSAnLycpIHtcbiAgICAgIC8vIHNraXAgbGluZSBjb21tZW50XG4gICAgICB3aGlsZSAoYyAhPSAnJyAmJiBjICE9ICdcXG4nKSB7XG4gICAgICAgIG5leHQoKTtcbiAgICAgIH1cbiAgICAgIGlzQ29tbWVudCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChjID09PSAnLycgJiYgbmV4dFByZXZpZXcoKSA9PT0gJyonKSB7XG4gICAgICAvLyBza2lwIGJsb2NrIGNvbW1lbnRcbiAgICAgIHdoaWxlIChjICE9ICcnKSB7XG4gICAgICAgIGlmIChjID09PSAnKicgJiYgbmV4dFByZXZpZXcoKSA9PT0gJy8nKSB7XG4gICAgICAgICAgLy8gZW5kIG9mIGJsb2NrIGNvbW1lbnQgZm91bmQuIHNraXAgdGhlc2UgbGFzdCB0d28gY2hhcmFjdGVyc1xuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpc0NvbW1lbnQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIHNraXAgb3ZlciB3aGl0ZXNwYWNlc1xuICAgIHdoaWxlIChjID09PSAnICcgfHwgYyA9PT0gJ1xcdCcgfHwgYyA9PT0gJ1xcbicgfHwgYyA9PT0gJ1xccicpIHtcbiAgICAgIC8vIHNwYWNlLCB0YWIsIGVudGVyXG4gICAgICBuZXh0KCk7XG4gICAgfVxuICB9IHdoaWxlIChpc0NvbW1lbnQpO1xuXG4gIC8vIGNoZWNrIGZvciBlbmQgb2YgZG90IGZpbGVcbiAgaWYgKGMgPT09ICcnKSB7XG4gICAgLy8gdG9rZW4gaXMgc3RpbGwgZW1wdHlcbiAgICB0b2tlblR5cGUgPSBUT0tFTlRZUEUuREVMSU1JVEVSO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGNoZWNrIGZvciBkZWxpbWl0ZXJzIGNvbnNpc3Rpbmcgb2YgMiBjaGFyYWN0ZXJzXG4gIHZhciBjMiA9IGMgKyBuZXh0UHJldmlldygpO1xuICBpZiAoREVMSU1JVEVSU1tjMl0pIHtcbiAgICB0b2tlblR5cGUgPSBUT0tFTlRZUEUuREVMSU1JVEVSO1xuICAgIHRva2VuID0gYzI7XG4gICAgbmV4dCgpO1xuICAgIG5leHQoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBjaGVjayBmb3IgZGVsaW1pdGVycyBjb25zaXN0aW5nIG9mIDEgY2hhcmFjdGVyXG4gIGlmIChERUxJTUlURVJTW2NdKSB7XG4gICAgdG9rZW5UeXBlID0gVE9LRU5UWVBFLkRFTElNSVRFUjtcbiAgICB0b2tlbiA9IGM7XG4gICAgbmV4dCgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGNoZWNrIGZvciBhbiBpZGVudGlmaWVyIChudW1iZXIgb3Igc3RyaW5nKVxuICAvLyBUT0RPOiBtb3JlIHByZWNpc2UgcGFyc2luZyBvZiBudW1iZXJzL3N0cmluZ3MgKGFuZCB0aGUgcG9ydCBzZXBhcmF0b3IgJzonKVxuICBpZiAoaXNBbHBoYU51bWVyaWMoYykgfHwgYyA9PT0gJy0nKSB7XG4gICAgdG9rZW4gKz0gYztcbiAgICBuZXh0KCk7XG5cbiAgICB3aGlsZSAoaXNBbHBoYU51bWVyaWMoYykpIHtcbiAgICAgIHRva2VuICs9IGM7XG4gICAgICBuZXh0KCk7XG4gICAgfVxuICAgIGlmICh0b2tlbiA9PT0gJ2ZhbHNlJykge1xuICAgICAgdG9rZW4gPSBmYWxzZTsgLy8gY29udmVydCB0byBib29sZWFuXG4gICAgfSBlbHNlIGlmICh0b2tlbiA9PT0gJ3RydWUnKSB7XG4gICAgICB0b2tlbiA9IHRydWU7IC8vIGNvbnZlcnQgdG8gYm9vbGVhblxuICAgIH0gZWxzZSBpZiAoIWlzTmFOKE51bWJlcih0b2tlbikpKSB7XG4gICAgICB0b2tlbiA9IE51bWJlcih0b2tlbik7IC8vIGNvbnZlcnQgdG8gbnVtYmVyXG4gICAgfVxuICAgIHRva2VuVHlwZSA9IFRPS0VOVFlQRS5JREVOVElGSUVSO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGNoZWNrIGZvciBhIHN0cmluZyBlbmNsb3NlZCBieSBkb3VibGUgcXVvdGVzXG4gIGlmIChjID09PSAnXCInKSB7XG4gICAgbmV4dCgpO1xuICAgIHdoaWxlIChjICE9ICcnICYmIChjICE9ICdcIicgfHwgYyA9PT0gJ1wiJyAmJiBuZXh0UHJldmlldygpID09PSAnXCInKSkge1xuICAgICAgaWYgKGMgPT09ICdcIicpIHtcbiAgICAgICAgLy8gc2tpcCB0aGUgZXNjYXBlIGNoYXJhY3RlclxuICAgICAgICB0b2tlbiArPSBjO1xuICAgICAgICBuZXh0KCk7XG4gICAgICB9IGVsc2UgaWYgKGMgPT09ICdcXFxcJyAmJiBuZXh0UHJldmlldygpID09PSAnbicpIHtcbiAgICAgICAgLy8gSG9ub3IgYSBuZXdsaW5lIGVzY2FwZSBzZXF1ZW5jZVxuICAgICAgICB0b2tlbiArPSAnXFxuJztcbiAgICAgICAgbmV4dCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9rZW4gKz0gYztcbiAgICAgIH1cbiAgICAgIG5leHQoKTtcbiAgICB9XG4gICAgaWYgKGMgIT0gJ1wiJykge1xuICAgICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoJ0VuZCBvZiBzdHJpbmcgXCIgZXhwZWN0ZWQnKTtcbiAgICB9XG4gICAgbmV4dCgpO1xuICAgIHRva2VuVHlwZSA9IFRPS0VOVFlQRS5JREVOVElGSUVSO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHNvbWV0aGluZyB1bmtub3duIGlzIGZvdW5kLCB3cm9uZyBjaGFyYWN0ZXJzLCBhIHN5bnRheCBlcnJvclxuICB0b2tlblR5cGUgPSBUT0tFTlRZUEUuVU5LTk9XTjtcbiAgd2hpbGUgKGMgIT0gJycpIHtcbiAgICB0b2tlbiArPSBjO1xuICAgIG5leHQoKTtcbiAgfVxuICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1N5bnRheCBlcnJvciBpbiBwYXJ0IFwiJyArIGNob3AodG9rZW4sIDMwKSArICdcIicpO1xufVxuXG4vKipcbiAqIFBhcnNlIGEgZ3JhcGguXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBncmFwaFxuICovXG5mdW5jdGlvbiBwYXJzZUdyYXBoKCkge1xuICB2YXIgZ3JhcGggPSB7fTtcblxuICBmaXJzdCgpO1xuICBnZXRUb2tlbigpO1xuXG4gIC8vIG9wdGlvbmFsIHN0cmljdCBrZXl3b3JkXG4gIGlmICh0b2tlbiA9PT0gJ3N0cmljdCcpIHtcbiAgICBncmFwaC5zdHJpY3QgPSB0cnVlO1xuICAgIGdldFRva2VuKCk7XG4gIH1cblxuICAvLyBncmFwaCBvciBkaWdyYXBoIGtleXdvcmRcbiAgaWYgKHRva2VuID09PSAnZ3JhcGgnIHx8IHRva2VuID09PSAnZGlncmFwaCcpIHtcbiAgICBncmFwaC50eXBlID0gdG9rZW47XG4gICAgZ2V0VG9rZW4oKTtcbiAgfVxuXG4gIC8vIG9wdGlvbmFsIGdyYXBoIGlkXG4gIGlmICh0b2tlblR5cGUgPT09IFRPS0VOVFlQRS5JREVOVElGSUVSKSB7XG4gICAgZ3JhcGguaWQgPSB0b2tlbjtcbiAgICBnZXRUb2tlbigpO1xuICB9XG5cbiAgLy8gb3BlbiBhbmdsZSBicmFja2V0XG4gIGlmICh0b2tlbiAhPSAneycpIHtcbiAgICB0aHJvdyBuZXdTeW50YXhFcnJvcignQW5nbGUgYnJhY2tldCB7IGV4cGVjdGVkJyk7XG4gIH1cbiAgZ2V0VG9rZW4oKTtcblxuICAvLyBzdGF0ZW1lbnRzXG4gIHBhcnNlU3RhdGVtZW50cyhncmFwaCk7XG5cbiAgLy8gY2xvc2UgYW5nbGUgYnJhY2tldFxuICBpZiAodG9rZW4gIT0gJ30nKSB7XG4gICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoJ0FuZ2xlIGJyYWNrZXQgfSBleHBlY3RlZCcpO1xuICB9XG4gIGdldFRva2VuKCk7XG5cbiAgLy8gZW5kIG9mIGZpbGVcbiAgaWYgKHRva2VuICE9PSAnJykge1xuICAgIHRocm93IG5ld1N5bnRheEVycm9yKCdFbmQgb2YgZmlsZSBleHBlY3RlZCcpO1xuICB9XG4gIGdldFRva2VuKCk7XG5cbiAgLy8gcmVtb3ZlIHRlbXBvcmFyeSBkZWZhdWx0IG9wdGlvbnNcbiAgZGVsZXRlIGdyYXBoLm5vZGU7XG4gIGRlbGV0ZSBncmFwaC5lZGdlO1xuICBkZWxldGUgZ3JhcGguZ3JhcGg7XG5cbiAgcmV0dXJuIGdyYXBoO1xufVxuXG4vKipcbiAqIFBhcnNlIGEgbGlzdCB3aXRoIHN0YXRlbWVudHMuXG4gKiBAcGFyYW0ge09iamVjdH0gZ3JhcGhcbiAqL1xuZnVuY3Rpb24gcGFyc2VTdGF0ZW1lbnRzKGdyYXBoKSB7XG4gIHdoaWxlICh0b2tlbiAhPT0gJycgJiYgdG9rZW4gIT0gJ30nKSB7XG4gICAgcGFyc2VTdGF0ZW1lbnQoZ3JhcGgpO1xuICAgIGlmICh0b2tlbiA9PT0gJzsnKSB7XG4gICAgICBnZXRUb2tlbigpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGEgc2luZ2xlIHN0YXRlbWVudC4gQ2FuIGJlIGEgYW4gYXR0cmlidXRlIHN0YXRlbWVudCwgbm9kZVxuICogc3RhdGVtZW50LCBhIHNlcmllcyBvZiBub2RlIHN0YXRlbWVudHMgYW5kIGVkZ2Ugc3RhdGVtZW50cywgb3IgYVxuICogcGFyYW1ldGVyLlxuICogQHBhcmFtIHtPYmplY3R9IGdyYXBoXG4gKi9cbmZ1bmN0aW9uIHBhcnNlU3RhdGVtZW50KGdyYXBoKSB7XG4gIC8vIHBhcnNlIHN1YmdyYXBoXG4gIHZhciBzdWJncmFwaCA9IHBhcnNlU3ViZ3JhcGgoZ3JhcGgpO1xuICBpZiAoc3ViZ3JhcGgpIHtcbiAgICAvLyBlZGdlIHN0YXRlbWVudHNcbiAgICBwYXJzZUVkZ2UoZ3JhcGgsIHN1YmdyYXBoKTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHBhcnNlIGFuIGF0dHJpYnV0ZSBzdGF0ZW1lbnRcbiAgdmFyIGF0dHIgPSBwYXJzZUF0dHJpYnV0ZVN0YXRlbWVudChncmFwaCk7XG4gIGlmIChhdHRyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gcGFyc2Ugbm9kZVxuICBpZiAodG9rZW5UeXBlICE9IFRPS0VOVFlQRS5JREVOVElGSUVSKSB7XG4gICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoJ0lkZW50aWZpZXIgZXhwZWN0ZWQnKTtcbiAgfVxuICB2YXIgaWQgPSB0b2tlbjsgLy8gaWQgY2FuIGJlIGEgc3RyaW5nIG9yIGEgbnVtYmVyXG4gIGdldFRva2VuKCk7XG5cbiAgaWYgKHRva2VuID09PSAnPScpIHtcbiAgICAvLyBpZCBzdGF0ZW1lbnRcbiAgICBnZXRUb2tlbigpO1xuICAgIGlmICh0b2tlblR5cGUgIT0gVE9LRU5UWVBFLklERU5USUZJRVIpIHtcbiAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKCdJZGVudGlmaWVyIGV4cGVjdGVkJyk7XG4gICAgfVxuICAgIGdyYXBoW2lkXSA9IHRva2VuO1xuICAgIGdldFRva2VuKCk7XG4gICAgLy8gVE9ETzogaW1wbGVtZW50IGNvbW1hIHNlcGFyYXRlZCBsaXN0IHdpdGggXCJhX2xpc3Q6IElEPUlEIFsnLCddIFthX2xpc3RdIFwiXG4gIH0gZWxzZSB7XG4gICAgcGFyc2VOb2RlU3RhdGVtZW50KGdyYXBoLCBpZCk7XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhIHN1YmdyYXBoXG4gKiBAcGFyYW0ge09iamVjdH0gZ3JhcGggICAgcGFyZW50IGdyYXBoIG9iamVjdFxuICogQHJldHVybiB7T2JqZWN0IHwgbnVsbH0gc3ViZ3JhcGhcbiAqL1xuZnVuY3Rpb24gcGFyc2VTdWJncmFwaChncmFwaCkge1xuICB2YXIgc3ViZ3JhcGggPSBudWxsO1xuXG4gIC8vIG9wdGlvbmFsIHN1YmdyYXBoIGtleXdvcmRcbiAgaWYgKHRva2VuID09PSAnc3ViZ3JhcGgnKSB7XG4gICAgc3ViZ3JhcGggPSB7fTtcbiAgICBzdWJncmFwaC50eXBlID0gJ3N1YmdyYXBoJztcbiAgICBnZXRUb2tlbigpO1xuXG4gICAgLy8gb3B0aW9uYWwgZ3JhcGggaWRcbiAgICBpZiAodG9rZW5UeXBlID09PSBUT0tFTlRZUEUuSURFTlRJRklFUikge1xuICAgICAgc3ViZ3JhcGguaWQgPSB0b2tlbjtcbiAgICAgIGdldFRva2VuKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gb3BlbiBhbmdsZSBicmFja2V0XG4gIGlmICh0b2tlbiA9PT0gJ3snKSB7XG4gICAgZ2V0VG9rZW4oKTtcblxuICAgIGlmICghc3ViZ3JhcGgpIHtcbiAgICAgIHN1YmdyYXBoID0ge307XG4gICAgfVxuICAgIHN1YmdyYXBoLnBhcmVudCA9IGdyYXBoO1xuICAgIHN1YmdyYXBoLm5vZGUgPSBncmFwaC5ub2RlO1xuICAgIHN1YmdyYXBoLmVkZ2UgPSBncmFwaC5lZGdlO1xuICAgIHN1YmdyYXBoLmdyYXBoID0gZ3JhcGguZ3JhcGg7XG5cbiAgICAvLyBzdGF0ZW1lbnRzXG4gICAgcGFyc2VTdGF0ZW1lbnRzKHN1YmdyYXBoKTtcblxuICAgIC8vIGNsb3NlIGFuZ2xlIGJyYWNrZXRcbiAgICBpZiAodG9rZW4gIT0gJ30nKSB7XG4gICAgICB0aHJvdyBuZXdTeW50YXhFcnJvcignQW5nbGUgYnJhY2tldCB9IGV4cGVjdGVkJyk7XG4gICAgfVxuICAgIGdldFRva2VuKCk7XG5cbiAgICAvLyByZW1vdmUgdGVtcG9yYXJ5IGRlZmF1bHQgb3B0aW9uc1xuICAgIGRlbGV0ZSBzdWJncmFwaC5ub2RlO1xuICAgIGRlbGV0ZSBzdWJncmFwaC5lZGdlO1xuICAgIGRlbGV0ZSBzdWJncmFwaC5ncmFwaDtcbiAgICBkZWxldGUgc3ViZ3JhcGgucGFyZW50O1xuXG4gICAgLy8gcmVnaXN0ZXIgYXQgdGhlIHBhcmVudCBncmFwaFxuICAgIGlmICghZ3JhcGguc3ViZ3JhcGhzKSB7XG4gICAgICBncmFwaC5zdWJncmFwaHMgPSBbXTtcbiAgICB9XG4gICAgZ3JhcGguc3ViZ3JhcGhzLnB1c2goc3ViZ3JhcGgpO1xuICB9XG5cbiAgcmV0dXJuIHN1YmdyYXBoO1xufVxuXG4vKipcbiAqIHBhcnNlIGFuIGF0dHJpYnV0ZSBzdGF0ZW1lbnQgbGlrZSBcIm5vZGUgW3NoYXBlPWNpcmNsZSBmb250U2l6ZT0xNl1cIi5cbiAqIEF2YWlsYWJsZSBrZXl3b3JkcyBhcmUgJ25vZGUnLCAnZWRnZScsICdncmFwaCcuXG4gKiBUaGUgcHJldmlvdXMgbGlzdCB3aXRoIGRlZmF1bHQgYXR0cmlidXRlcyB3aWxsIGJlIHJlcGxhY2VkXG4gKiBAcGFyYW0ge09iamVjdH0gZ3JhcGhcbiAqIEByZXR1cm5zIHtTdHJpbmcgfCBudWxsfSBrZXl3b3JkIFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIHBhcnNlZCBhdHRyaWJ1dGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChub2RlLCBlZGdlLCBncmFwaCksIG9yIG51bGwgaWYgbm90aGluZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgcGFyc2VkLlxuICovXG5mdW5jdGlvbiBwYXJzZUF0dHJpYnV0ZVN0YXRlbWVudChncmFwaCkge1xuICAvLyBhdHRyaWJ1dGUgc3RhdGVtZW50c1xuICBpZiAodG9rZW4gPT09ICdub2RlJykge1xuICAgIGdldFRva2VuKCk7XG5cbiAgICAvLyBub2RlIGF0dHJpYnV0ZXNcbiAgICBncmFwaC5ub2RlID0gcGFyc2VBdHRyaWJ1dGVMaXN0KCk7XG4gICAgcmV0dXJuICdub2RlJztcbiAgfSBlbHNlIGlmICh0b2tlbiA9PT0gJ2VkZ2UnKSB7XG4gICAgZ2V0VG9rZW4oKTtcblxuICAgIC8vIGVkZ2UgYXR0cmlidXRlc1xuICAgIGdyYXBoLmVkZ2UgPSBwYXJzZUF0dHJpYnV0ZUxpc3QoKTtcbiAgICByZXR1cm4gJ2VkZ2UnO1xuICB9IGVsc2UgaWYgKHRva2VuID09PSAnZ3JhcGgnKSB7XG4gICAgZ2V0VG9rZW4oKTtcblxuICAgIC8vIGdyYXBoIGF0dHJpYnV0ZXNcbiAgICBncmFwaC5ncmFwaCA9IHBhcnNlQXR0cmlidXRlTGlzdCgpO1xuICAgIHJldHVybiAnZ3JhcGgnO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogcGFyc2UgYSBub2RlIHN0YXRlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IGdyYXBoXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcn0gaWRcbiAqL1xuZnVuY3Rpb24gcGFyc2VOb2RlU3RhdGVtZW50KGdyYXBoLCBpZCkge1xuICAvLyBub2RlIHN0YXRlbWVudFxuICB2YXIgbm9kZSA9IHtcbiAgICBpZDogaWRcbiAgfTtcbiAgdmFyIGF0dHIgPSBwYXJzZUF0dHJpYnV0ZUxpc3QoKTtcbiAgaWYgKGF0dHIpIHtcbiAgICBub2RlLmF0dHIgPSBhdHRyO1xuICB9XG4gIGFkZE5vZGUoZ3JhcGgsIG5vZGUpO1xuXG4gIC8vIGVkZ2Ugc3RhdGVtZW50c1xuICBwYXJzZUVkZ2UoZ3JhcGgsIGlkKTtcbn1cblxuLyoqXG4gKiBQYXJzZSBhbiBlZGdlIG9yIGEgc2VyaWVzIG9mIGVkZ2VzXG4gKiBAcGFyYW0ge09iamVjdH0gZ3JhcGhcbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSBmcm9tICAgICAgICBJZCBvZiB0aGUgZnJvbSBub2RlXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRWRnZShncmFwaCwgZnJvbSkge1xuICB3aGlsZSAodG9rZW4gPT09ICctPicgfHwgdG9rZW4gPT09ICctLScpIHtcbiAgICB2YXIgdG87XG4gICAgdmFyIHR5cGUgPSB0b2tlbjtcbiAgICBnZXRUb2tlbigpO1xuXG4gICAgdmFyIHN1YmdyYXBoID0gcGFyc2VTdWJncmFwaChncmFwaCk7XG4gICAgaWYgKHN1YmdyYXBoKSB7XG4gICAgICB0byA9IHN1YmdyYXBoO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodG9rZW5UeXBlICE9IFRPS0VOVFlQRS5JREVOVElGSUVSKSB7XG4gICAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKCdJZGVudGlmaWVyIG9yIHN1YmdyYXBoIGV4cGVjdGVkJyk7XG4gICAgICB9XG4gICAgICB0byA9IHRva2VuO1xuICAgICAgYWRkTm9kZShncmFwaCwge1xuICAgICAgICBpZDogdG9cbiAgICAgIH0pO1xuICAgICAgZ2V0VG9rZW4oKTtcbiAgICB9XG5cbiAgICAvLyBwYXJzZSBlZGdlIGF0dHJpYnV0ZXNcbiAgICB2YXIgYXR0ciA9IHBhcnNlQXR0cmlidXRlTGlzdCgpO1xuXG4gICAgLy8gY3JlYXRlIGVkZ2VcbiAgICB2YXIgZWRnZSA9IGNyZWF0ZUVkZ2UoZ3JhcGgsIGZyb20sIHRvLCB0eXBlLCBhdHRyKTtcbiAgICBhZGRFZGdlKGdyYXBoLCBlZGdlKTtcblxuICAgIGZyb20gPSB0bztcbiAgfVxufVxuXG4vKipcbiAqIEFzIGV4cGxhaW5lZCBpbiBbMV0sIGdyYXBodml6IGhhcyBsaW1pdGF0aW9ucyBmb3IgY29tYmluYXRpb24gb2ZcbiAqIGFycm93W2hlYWR8dGFpbF0gYW5kIGRpci4gSWYgYXR0cmlidXRlIGxpc3QgaW5jbHVkZXMgJ2RpcicsXG4gKiBmb2xsb3dpbmcgY2FzZXMganVzdCBiZSBzdXBwb3J0ZWQuXG4gKiAgIDEuIGJvdGggb3Igbm9uZSArIGFycm93aGVhZCwgYXJyb3d0YWlsXG4gKiAgIDIuIGZvcndhcmQgKyBhcnJvd2hlYWQgKGFycm93dGFpbCBpcyBub3QgYWZmZWR0ZWQpXG4gKiAgIDMuIGJhY2sgKyBhcnJvd3RhaWwgKGFycm93aGVhZCBpcyBub3QgYWZmZWN0ZWQpXG4gKiBbMV0gaHR0cHM6Ly93d3cuZ3JhcGh2aXoub3JnL2RvYy9pbmZvL2F0dHJzLmh0bWwjaDp1bmRpcl9ub3RlXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgZnJvbSBwYXJzZUF0dHJpYnV0ZUxpc3QoKSB0byBwYXJzZSAnZGlyJ1xuICogYXR0cmlidXRlIHdpdGggZ2l2ZW4gJ2F0dHJfbmFtZXMnIGFuZCAnYXR0cl9saXN0Jy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyX25hbWVzICBBcnJheSBvZiBhdHRyaWJ1dGUgbmFtZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyX2xpc3QgIEFycmF5IG9mIG9iamVjdHMgb2YgYXR0cmlidXRlIHNldFxuICogQHJldHVybiB7T2JqZWN0fSBhdHRyX2xpc3QgIFVwZGF0ZWQgYXR0cl9saXN0XG4gKi9cbmZ1bmN0aW9uIHBhcnNlRGlyQXR0cmlidXRlKGF0dHJfbmFtZXMsIGF0dHJfbGlzdCkge1xuICB2YXIgaTtcbiAgaWYgKGF0dHJfbmFtZXMuaW5jbHVkZXMoJ2RpcicpKSB7XG4gICAgdmFyIGlkeCA9IHt9OyAvLyBnZXQgaW5kZXggb2YgJ2Fycm93cycgYW5kICdkaXInXG4gICAgaWR4LmFycm93cyA9IHt9O1xuICAgIGZvciAoaSA9IDA7IGkgPCBhdHRyX2xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhdHRyX2xpc3RbaV0ubmFtZSA9PT0gJ2Fycm93cycpIHtcbiAgICAgICAgaWYgKGF0dHJfbGlzdFtpXS52YWx1ZS50byAhPSBudWxsKSB7XG4gICAgICAgICAgaWR4LmFycm93cy50byA9IGk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXR0cl9saXN0W2ldLnZhbHVlLmZyb20gIT0gbnVsbCkge1xuICAgICAgICAgIGlkeC5hcnJvd3MuZnJvbSA9IGk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoJ0ludmFsaWQgdmFsdWUgb2YgYXJyb3dzJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYXR0cl9saXN0W2ldLm5hbWUgPT09ICdkaXInKSB7XG4gICAgICAgIGlkeC5kaXIgPSBpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZpcnN0LCBhZGQgZGVmYXVsdCBhcnJvdyBzaGFwZSBpZiBpdCBpcyBub3QgYXNzaWduZWQgdG8gYXZvaWQgZXJyb3JcbiAgICB2YXIgZGlyX3R5cGUgPSBhdHRyX2xpc3RbaWR4LmRpcl0udmFsdWU7XG4gICAgaWYgKCFhdHRyX25hbWVzLmluY2x1ZGVzKCdhcnJvd3MnKSkge1xuICAgICAgaWYgKGRpcl90eXBlID09PSAnYm90aCcpIHtcbiAgICAgICAgYXR0cl9saXN0LnB1c2goe1xuICAgICAgICAgIGF0dHI6IGF0dHJfbGlzdFtpZHguZGlyXS5hdHRyLFxuICAgICAgICAgIG5hbWU6ICdhcnJvd3MnLFxuICAgICAgICAgIHZhbHVlOiB7IHRvOiB7IGVuYWJsZWQ6IHRydWUgfSB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZHguYXJyb3dzLnRvID0gYXR0cl9saXN0Lmxlbmd0aCAtIDE7XG4gICAgICAgIGF0dHJfbGlzdC5wdXNoKHtcbiAgICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmRpcl0uYXR0cixcbiAgICAgICAgICBuYW1lOiAnYXJyb3dzJyxcbiAgICAgICAgICB2YWx1ZTogeyBmcm9tOiB7IGVuYWJsZWQ6IHRydWUgfSB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZHguYXJyb3dzLmZyb20gPSBhdHRyX2xpc3QubGVuZ3RoIC0gMTtcbiAgICAgIH0gZWxzZSBpZiAoZGlyX3R5cGUgPT09ICdmb3J3YXJkJykge1xuICAgICAgICBhdHRyX2xpc3QucHVzaCh7XG4gICAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5kaXJdLmF0dHIsXG4gICAgICAgICAgbmFtZTogJ2Fycm93cycsXG4gICAgICAgICAgdmFsdWU6IHsgdG86IHsgZW5hYmxlZDogdHJ1ZSB9IH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlkeC5hcnJvd3MudG8gPSBhdHRyX2xpc3QubGVuZ3RoIC0gMTtcbiAgICAgIH0gZWxzZSBpZiAoZGlyX3R5cGUgPT09ICdiYWNrJykge1xuICAgICAgICBhdHRyX2xpc3QucHVzaCh7XG4gICAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5kaXJdLmF0dHIsXG4gICAgICAgICAgbmFtZTogJ2Fycm93cycsXG4gICAgICAgICAgdmFsdWU6IHsgZnJvbTogeyBlbmFibGVkOiB0cnVlIH0gfVxuICAgICAgICB9KTtcbiAgICAgICAgaWR4LmFycm93cy5mcm9tID0gYXR0cl9saXN0Lmxlbmd0aCAtIDE7XG4gICAgICB9IGVsc2UgaWYgKGRpcl90eXBlID09PSAnbm9uZScpIHtcbiAgICAgICAgYXR0cl9saXN0LnB1c2goe1xuICAgICAgICAgIGF0dHI6IGF0dHJfbGlzdFtpZHguZGlyXS5hdHRyLFxuICAgICAgICAgIG5hbWU6ICdhcnJvd3MnLFxuICAgICAgICAgIHZhbHVlOiAnJ1xuICAgICAgICB9KTtcbiAgICAgICAgaWR4LmFycm93cy50byA9IGF0dHJfbGlzdC5sZW5ndGggLSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoJ0ludmFsaWQgZGlyIHR5cGUgXCInICsgZGlyX3R5cGUgKyAnXCInKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZnJvbV90eXBlO1xuICAgIHZhciB0b190eXBlO1xuICAgIC8vIHVwZGF0ZSAnYXJyb3dzJyBhdHRyaWJ1dGUgZnJvbSAnZGlyJy5cbiAgICBpZiAoZGlyX3R5cGUgPT09ICdib3RoJykge1xuICAgICAgLy8gYm90aCBvZiBzaGFwZXMgb2YgJ2Zyb20nIGFuZCAndG8nIGFyZSBnaXZlblxuICAgICAgaWYgKGlkeC5hcnJvd3MudG8gJiYgaWR4LmFycm93cy5mcm9tKSB7XG4gICAgICAgIHRvX3R5cGUgPSBhdHRyX2xpc3RbaWR4LmFycm93cy50b10udmFsdWUudG8udHlwZTtcbiAgICAgICAgZnJvbV90eXBlID0gYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0udmFsdWUuZnJvbS50eXBlO1xuICAgICAgICBhdHRyX2xpc3RbaWR4LmFycm93cy50b10gPSB7XG4gICAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLmF0dHIsXG4gICAgICAgICAgbmFtZTogYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLm5hbWUsXG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHRvOiB7IGVuYWJsZWQ6IHRydWUsIHR5cGU6IHRvX3R5cGUgfSxcbiAgICAgICAgICAgIGZyb206IHsgZW5hYmxlZDogdHJ1ZSwgdHlwZTogZnJvbV90eXBlIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGF0dHJfbGlzdC5zcGxpY2UoaWR4LmFycm93cy5mcm9tLCAxKTtcblxuICAgICAgICAvLyBzaGFwZSBvZiAndG8nIGlzIGFzc2lnbmVkIGFuZCB1c2UgZGVmYXVsdCB0byAnZnJvbSdcbiAgICAgIH0gZWxzZSBpZiAoaWR4LmFycm93cy50bykge1xuICAgICAgICB0b190eXBlID0gYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLnZhbHVlLnRvLnR5cGU7XG4gICAgICAgIGZyb21fdHlwZSA9ICdhcnJvdyc7XG4gICAgICAgIGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXSA9IHtcbiAgICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmFycm93cy50b10uYXR0cixcbiAgICAgICAgICBuYW1lOiBhdHRyX2xpc3RbaWR4LmFycm93cy50b10ubmFtZSxcbiAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgdG86IHsgZW5hYmxlZDogdHJ1ZSwgdHlwZTogdG9fdHlwZSB9LFxuICAgICAgICAgICAgZnJvbTogeyBlbmFibGVkOiB0cnVlLCB0eXBlOiBmcm9tX3R5cGUgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIG9ubHkgc2hhcGUgb2YgJ2Zyb20nIGlzIGFzc2lnbmVkIGFuZCB1c2UgZGVmYXVsdCBmb3IgJ3RvJ1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChpZHguYXJyb3dzLmZyb20pIHtcbiAgICAgICAgdG9fdHlwZSA9ICdhcnJvdyc7XG4gICAgICAgIGZyb21fdHlwZSA9IGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dLnZhbHVlLmZyb20udHlwZTtcbiAgICAgICAgYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0gPSB7XG4gICAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0uYXR0cixcbiAgICAgICAgICBuYW1lOiBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS5uYW1lLFxuICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB0bzogeyBlbmFibGVkOiB0cnVlLCB0eXBlOiB0b190eXBlIH0sXG4gICAgICAgICAgICBmcm9tOiB7IGVuYWJsZWQ6IHRydWUsIHR5cGU6IGZyb21fdHlwZSB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGlyX3R5cGUgPT09ICdiYWNrJykge1xuICAgICAgLy8gZ2l2ZW4gYm90aCBvZiBzaGFwZXMsIGJ1dCB1c2Ugb25seSAnZnJvbSdcbiAgICAgIGlmIChpZHguYXJyb3dzLnRvICYmIGlkeC5hcnJvd3MuZnJvbSkge1xuICAgICAgICB0b190eXBlID0gJyc7XG4gICAgICAgIGZyb21fdHlwZSA9IGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dLnZhbHVlLmZyb20udHlwZTtcbiAgICAgICAgYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0gPSB7XG4gICAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0uYXR0cixcbiAgICAgICAgICBuYW1lOiBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS5uYW1lLFxuICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB0bzogeyBlbmFibGVkOiB0cnVlLCB0eXBlOiB0b190eXBlIH0sXG4gICAgICAgICAgICBmcm9tOiB7IGVuYWJsZWQ6IHRydWUsIHR5cGU6IGZyb21fdHlwZSB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZ2l2ZW4gc2hhcGUgb2YgJ3RvJywgYnV0IGRvZXMgbm90IHVzZSBpdFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChpZHguYXJyb3dzLnRvKSB7XG4gICAgICAgIHRvX3R5cGUgPSAnJztcbiAgICAgICAgZnJvbV90eXBlID0gJ2Fycm93JztcbiAgICAgICAgaWR4LmFycm93cy5mcm9tID0gaWR4LmFycm93cy50bztcbiAgICAgICAgYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0gPSB7XG4gICAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0uYXR0cixcbiAgICAgICAgICBuYW1lOiBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS5uYW1lLFxuICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB0bzogeyBlbmFibGVkOiB0cnVlLCB0eXBlOiB0b190eXBlIH0sXG4gICAgICAgICAgICBmcm9tOiB7IGVuYWJsZWQ6IHRydWUsIHR5cGU6IGZyb21fdHlwZSB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gYXNzaWduIGdpdmVuICdmcm9tJyBzaGFwZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChpZHguYXJyb3dzLmZyb20pIHtcbiAgICAgICAgdG9fdHlwZSA9ICcnO1xuICAgICAgICBmcm9tX3R5cGUgPSBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS52YWx1ZS5mcm9tLnR5cGU7XG4gICAgICAgIGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXSA9IHtcbiAgICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS5hdHRyLFxuICAgICAgICAgIG5hbWU6IGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dLm5hbWUsXG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHRvOiB7IGVuYWJsZWQ6IHRydWUsIHR5cGU6IHRvX3R5cGUgfSxcbiAgICAgICAgICAgIGZyb206IHsgZW5hYmxlZDogdHJ1ZSwgdHlwZTogZnJvbV90eXBlIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dID0ge1xuICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS5hdHRyLFxuICAgICAgICBuYW1lOiBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS5uYW1lLFxuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIGZyb206IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICB0eXBlOiBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS52YWx1ZS5mcm9tLnR5cGVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChkaXJfdHlwZSA9PT0gJ25vbmUnKSB7XG4gICAgICB2YXIgaWR4X2Fycm93O1xuICAgICAgaWYgKGlkeC5hcnJvd3MudG8pIHtcbiAgICAgICAgaWR4X2Fycm93ID0gaWR4LmFycm93cy50bztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlkeF9hcnJvdyA9IGlkeC5hcnJvd3MuZnJvbTtcbiAgICAgIH1cblxuICAgICAgYXR0cl9saXN0W2lkeF9hcnJvd10gPSB7XG4gICAgICAgIGF0dHI6IGF0dHJfbGlzdFtpZHhfYXJyb3ddLmF0dHIsXG4gICAgICAgIG5hbWU6IGF0dHJfbGlzdFtpZHhfYXJyb3ddLm5hbWUsXG4gICAgICAgIHZhbHVlOiAnJ1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGRpcl90eXBlID09PSAnZm9yd2FyZCcpIHtcbiAgICAgIC8vIGdpdmVuIGJvdGggb2Ygc2hhcGVzLCBidXQgdXNlIG9ubHkgJ3RvJ1xuICAgICAgaWYgKGlkeC5hcnJvd3MudG8gJiYgaWR4LmFycm93cy5mcm9tKSB7XG4gICAgICAgIHRvX3R5cGUgPSBhdHRyX2xpc3RbaWR4LmFycm93cy50b10udmFsdWUudG8udHlwZTtcbiAgICAgICAgZnJvbV90eXBlID0gJyc7XG4gICAgICAgIGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXSA9IHtcbiAgICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmFycm93cy50b10uYXR0cixcbiAgICAgICAgICBuYW1lOiBhdHRyX2xpc3RbaWR4LmFycm93cy50b10ubmFtZSxcbiAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgdG86IHsgZW5hYmxlZDogdHJ1ZSwgdHlwZTogdG9fdHlwZSB9LFxuICAgICAgICAgICAgZnJvbTogeyBlbmFibGVkOiB0cnVlLCB0eXBlOiBmcm9tX3R5cGUgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGFzc2lnbiBnaXZlbiAndG8nIHNoYXBlXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGlkeC5hcnJvd3MudG8pIHtcbiAgICAgICAgdG9fdHlwZSA9IGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXS52YWx1ZS50by50eXBlO1xuICAgICAgICBmcm9tX3R5cGUgPSAnJztcbiAgICAgICAgYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dID0ge1xuICAgICAgICAgIGF0dHI6IGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXS5hdHRyLFxuICAgICAgICAgIG5hbWU6IGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXS5uYW1lLFxuICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB0bzogeyBlbmFibGVkOiB0cnVlLCB0eXBlOiB0b190eXBlIH0sXG4gICAgICAgICAgICBmcm9tOiB7IGVuYWJsZWQ6IHRydWUsIHR5cGU6IGZyb21fdHlwZSB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZ2l2ZW4gc2hhcGUgb2YgJ2Zyb20nLCBidXQgZG9lcyBub3QgdXNlIGl0XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGlkeC5hcnJvd3MuZnJvbSkge1xuICAgICAgICB0b190eXBlID0gJ2Fycm93JztcbiAgICAgICAgZnJvbV90eXBlID0gJyc7XG4gICAgICAgIGlkeC5hcnJvd3MudG8gPSBpZHguYXJyb3dzLmZyb207XG4gICAgICAgIGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXSA9IHtcbiAgICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmFycm93cy50b10uYXR0cixcbiAgICAgICAgICBuYW1lOiBhdHRyX2xpc3RbaWR4LmFycm93cy50b10ubmFtZSxcbiAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgdG86IHsgZW5hYmxlZDogdHJ1ZSwgdHlwZTogdG9fdHlwZSB9LFxuICAgICAgICAgICAgZnJvbTogeyBlbmFibGVkOiB0cnVlLCB0eXBlOiBmcm9tX3R5cGUgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dID0ge1xuICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmFycm93cy50b10uYXR0cixcbiAgICAgICAgbmFtZTogYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLm5hbWUsXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgdG86IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICB0eXBlOiBhdHRyX2xpc3RbaWR4LmFycm93cy50b10udmFsdWUudG8udHlwZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoJ0ludmFsaWQgZGlyIHR5cGUgXCInICsgZGlyX3R5cGUgKyAnXCInKTtcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgJ2RpcicgYXR0cmlidXRlIG5vIG5lZWQgYW55bW9yZVxuICAgIGF0dHJfbGlzdC5zcGxpY2UoaWR4LmRpciwgMSk7XG4gIH1cbiAgcmV0dXJuIGF0dHJfbGlzdDtcbn1cblxuLyoqXG4gKiBQYXJzZSBhIHNldCB3aXRoIGF0dHJpYnV0ZXMsXG4gKiBmb3IgZXhhbXBsZSBbbGFiZWw9XCIxLjAwMFwiLCBzaGFwZT1zb2xpZF1cbiAqIEByZXR1cm4ge09iamVjdCB8IG51bGx9IGF0dHJcbiAqL1xuZnVuY3Rpb24gcGFyc2VBdHRyaWJ1dGVMaXN0KCkge1xuICB2YXIgaTtcbiAgdmFyIGF0dHIgPSBudWxsO1xuXG4gIC8vIGVkZ2Ugc3R5bGVzIG9mIGRvdCBhbmQgdmlzXG4gIHZhciBlZGdlU3R5bGVzID0ge1xuICAgIGRhc2hlZDogdHJ1ZSxcbiAgICBzb2xpZDogZmFsc2UsXG4gICAgZG90dGVkOiBbMSwgNV1cblxuICAgIC8qKlxuICAgICAqIERlZmluZSBhcnJvdyB0eXBlcy5cbiAgICAgKiB2aXMgY3VycmVudGx5IHN1cHBvcnRzIHR5cGVzIGRlZmluZWQgaW4gJ2Fycm93VHlwZXMnLlxuICAgICAqIERldGFpbHMgb2YgYXJyb3cgc2hhcGVzIGFyZSBkZXNjcmliZWQgaW5cbiAgICAgKiBodHRwOi8vd3d3LmdyYXBodml6Lm9yZy9jb250ZW50L2Fycm93LXNoYXBlc1xuICAgICAqL1xuICB9O3ZhciBhcnJvd1R5cGVzID0ge1xuICAgIGRvdDogJ2NpcmNsZScsXG4gICAgYm94OiAnYm94JyxcbiAgICBjcm93OiAnY3JvdycsXG4gICAgY3VydmU6ICdjdXJ2ZScsXG4gICAgaWN1cnZlOiAnaW52X2N1cnZlJyxcbiAgICBub3JtYWw6ICd0cmlhbmdsZScsXG4gICAgaW52OiAnaW52X3RyaWFuZ2xlJyxcbiAgICBkaWFtb25kOiAnZGlhbW9uZCcsXG4gICAgdGVlOiAnYmFyJyxcbiAgICB2ZWU6ICd2ZWUnXG5cbiAgICAvKipcbiAgICAgKiAnYXR0cl9saXN0JyBjb250YWlucyBhdHRyaWJ1dGVzIGZvciBjaGVja2luZyBpZiBzb21lIG9mIHRoZW0gYXJlIGFmZmVjdGVkXG4gICAgICogbGF0ZXIuIEZvciBpbnN0YW5jZSwgYm90aCBvZiAnYXJyb3doZWFkJyBhbmQgJ2RpcicgKGVkZ2Ugc3R5bGUgZGVmaW5lZFxuICAgICAqIGluIERPVCkgbWFrZSBjaGFuZ2VzIHRvICdhcnJvd3MnIGF0dHJpYnV0ZSBpbiB2aXMuXG4gICAgICovXG4gIH07dmFyIGF0dHJfbGlzdCA9IG5ldyBBcnJheSgpO1xuICB2YXIgYXR0cl9uYW1lcyA9IG5ldyBBcnJheSgpOyAvLyB1c2VkIGZvciBjaGVja2luZyB0aGUgY2FzZS5cblxuICAvLyBwYXJzZSBhdHRyaWJ1dGVzXG4gIHdoaWxlICh0b2tlbiA9PT0gJ1snKSB7XG4gICAgZ2V0VG9rZW4oKTtcbiAgICBhdHRyID0ge307XG4gICAgd2hpbGUgKHRva2VuICE9PSAnJyAmJiB0b2tlbiAhPSAnXScpIHtcbiAgICAgIGlmICh0b2tlblR5cGUgIT0gVE9LRU5UWVBFLklERU5USUZJRVIpIHtcbiAgICAgICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoJ0F0dHJpYnV0ZSBuYW1lIGV4cGVjdGVkJyk7XG4gICAgICB9XG4gICAgICB2YXIgbmFtZSA9IHRva2VuO1xuXG4gICAgICBnZXRUb2tlbigpO1xuICAgICAgaWYgKHRva2VuICE9ICc9Jykge1xuICAgICAgICB0aHJvdyBuZXdTeW50YXhFcnJvcignRXF1YWwgc2lnbiA9IGV4cGVjdGVkJyk7XG4gICAgICB9XG4gICAgICBnZXRUb2tlbigpO1xuXG4gICAgICBpZiAodG9rZW5UeXBlICE9IFRPS0VOVFlQRS5JREVOVElGSUVSKSB7XG4gICAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKCdBdHRyaWJ1dGUgdmFsdWUgZXhwZWN0ZWQnKTtcbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZSA9IHRva2VuO1xuXG4gICAgICAvLyBjb252ZXJ0IGZyb20gZG90IHN0eWxlIHRvIHZpc1xuICAgICAgaWYgKG5hbWUgPT09ICdzdHlsZScpIHtcbiAgICAgICAgdmFsdWUgPSBlZGdlU3R5bGVzW3ZhbHVlXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFycm93VHlwZTtcbiAgICAgIGlmIChuYW1lID09PSAnYXJyb3doZWFkJykge1xuICAgICAgICBhcnJvd1R5cGUgPSBhcnJvd1R5cGVzW3ZhbHVlXTtcbiAgICAgICAgbmFtZSA9ICdhcnJvd3MnO1xuICAgICAgICB2YWx1ZSA9IHsgdG86IHsgZW5hYmxlZDogdHJ1ZSwgdHlwZTogYXJyb3dUeXBlIH0gfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5hbWUgPT09ICdhcnJvd3RhaWwnKSB7XG4gICAgICAgIGFycm93VHlwZSA9IGFycm93VHlwZXNbdmFsdWVdO1xuICAgICAgICBuYW1lID0gJ2Fycm93cyc7XG4gICAgICAgIHZhbHVlID0geyBmcm9tOiB7IGVuYWJsZWQ6IHRydWUsIHR5cGU6IGFycm93VHlwZSB9IH07XG4gICAgICB9XG5cbiAgICAgIGF0dHJfbGlzdC5wdXNoKHsgYXR0cjogYXR0ciwgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH0pO1xuICAgICAgYXR0cl9uYW1lcy5wdXNoKG5hbWUpO1xuXG4gICAgICBnZXRUb2tlbigpO1xuICAgICAgaWYgKHRva2VuID09ICcsJykge1xuICAgICAgICBnZXRUb2tlbigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0b2tlbiAhPSAnXScpIHtcbiAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKCdCcmFja2V0IF0gZXhwZWN0ZWQnKTtcbiAgICB9XG4gICAgZ2V0VG9rZW4oKTtcbiAgfVxuXG4gIGF0dHJfbGlzdCA9IHBhcnNlRGlyQXR0cmlidXRlKGF0dHJfbmFtZXMsIGF0dHJfbGlzdCk7XG5cbiAgLy8gcGFyc2UgJ3BlbndpZHRoJ1xuICB2YXIgbm9mX2F0dHJfbGlzdDtcbiAgaWYgKGF0dHJfbmFtZXMuaW5jbHVkZXMoJ3BlbndpZHRoJykpIHtcbiAgICB2YXIgdG1wX2F0dHJfbGlzdCA9IFtdO1xuXG4gICAgbm9mX2F0dHJfbGlzdCA9IGF0dHJfbGlzdC5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IG5vZl9hdHRyX2xpc3Q7IGkrKykge1xuICAgICAgLy8gZXhjbHVkZSAnd2lkdGgnIGZyb20gYXR0cl9saXN0IGlmICdwZW53aWR0aCcgZXhpc3RzXG4gICAgICBpZiAoYXR0cl9saXN0W2ldLm5hbWUgIT09ICd3aWR0aCcpIHtcbiAgICAgICAgaWYgKGF0dHJfbGlzdFtpXS5uYW1lID09PSAncGVud2lkdGgnKSB7XG4gICAgICAgICAgYXR0cl9saXN0W2ldLm5hbWUgPSAnd2lkdGgnO1xuICAgICAgICB9XG4gICAgICAgIHRtcF9hdHRyX2xpc3QucHVzaChhdHRyX2xpc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBhdHRyX2xpc3QgPSB0bXBfYXR0cl9saXN0O1xuICB9XG5cbiAgbm9mX2F0dHJfbGlzdCA9IGF0dHJfbGlzdC5sZW5ndGg7XG4gIGZvciAoaSA9IDA7IGkgPCBub2ZfYXR0cl9saXN0OyBpKyspIHtcbiAgICBzZXRWYWx1ZShhdHRyX2xpc3RbaV0uYXR0ciwgYXR0cl9saXN0W2ldLm5hbWUsIGF0dHJfbGlzdFtpXS52YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gYXR0cjtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBzeW50YXggZXJyb3Igd2l0aCBleHRyYSBpbmZvcm1hdGlvbiBvbiBjdXJyZW50IHRva2VuIGFuZCBpbmRleC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7U3ludGF4RXJyb3J9IGVyclxuICovXG5mdW5jdGlvbiBuZXdTeW50YXhFcnJvcihtZXNzYWdlKSB7XG4gIHJldHVybiBuZXcgU3ludGF4RXJyb3IobWVzc2FnZSArICcsIGdvdCBcIicgKyBjaG9wKHRva2VuLCAzMCkgKyAnXCIgKGNoYXIgJyArIGluZGV4ICsgJyknKTtcbn1cblxuLyoqXG4gKiBDaG9wIG9mZiB0ZXh0IGFmdGVyIGEgbWF4aW11bSBsZW5ndGhcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge251bWJlcn0gbWF4TGVuZ3RoXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBjaG9wKHRleHQsIG1heExlbmd0aCkge1xuICByZXR1cm4gdGV4dC5sZW5ndGggPD0gbWF4TGVuZ3RoID8gdGV4dCA6IHRleHQuc3Vic3RyKDAsIDI3KSArICcuLi4nO1xufVxuXG4vKipcbiAqIEV4ZWN1dGUgYSBmdW5jdGlvbiBmbiBmb3IgZWFjaCBwYWlyIG9mIGVsZW1lbnRzIGluIHR3byBhcnJheXNcbiAqIEBwYXJhbSB7QXJyYXkgfCAqfSBhcnJheTFcbiAqIEBwYXJhbSB7QXJyYXkgfCAqfSBhcnJheTJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2gyKGFycmF5MSwgYXJyYXkyLCBmbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnJheTEpKSB7XG4gICAgYXJyYXkxLmZvckVhY2goZnVuY3Rpb24gKGVsZW0xKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhcnJheTIpKSB7XG4gICAgICAgIGFycmF5Mi5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtMikge1xuICAgICAgICAgIGZuKGVsZW0xLCBlbGVtMik7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm4oZWxlbTEsIGFycmF5Mik7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXkyKSkge1xuICAgICAgYXJyYXkyLmZvckVhY2goZnVuY3Rpb24gKGVsZW0yKSB7XG4gICAgICAgIGZuKGFycmF5MSwgZWxlbTIpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZuKGFycmF5MSwgYXJyYXkyKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBTZXQgYSBuZXN0ZWQgcHJvcGVydHkgb24gYW4gb2JqZWN0XG4gKiBXaGVuIG5lc3RlZCBvYmplY3RzIGFyZSBtaXNzaW5nLCB0aGV5IHdpbGwgYmUgY3JlYXRlZC5cbiAqIEZvciBleGFtcGxlIHNldFByb3Aoe30sICdmb250LmNvbG9yJywgJ3JlZCcpIHdpbGwgcmV0dXJuIHtmb250OiB7Y29sb3I6ICdyZWQnfX1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoICAgQSBkb3Qgc2VwYXJhdGVkIHN0cmluZyBsaWtlICdmb250LmNvbG9yJ1xuICogQHBhcmFtIHsqfSB2YWx1ZSAgICAgICBWYWx1ZSBmb3IgdGhlIHByb3BlcnR5XG4gKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIG9yaWdpbmFsIG9iamVjdCwgYWxsb3dzIGZvciBjaGFpbmluZy5cbiAqL1xuZnVuY3Rpb24gc2V0UHJvcChvYmplY3QsIHBhdGgsIHZhbHVlKSB7XG4gIHZhciBuYW1lcyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgdmFyIHByb3AgPSBuYW1lcy5wb3AoKTtcblxuICAvLyB0cmF2ZXJzZSBvdmVyIHRoZSBuZXN0ZWQgb2JqZWN0c1xuICB2YXIgb2JqID0gb2JqZWN0O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5hbWUgPSBuYW1lc1tpXTtcbiAgICBpZiAoIShuYW1lIGluIG9iaikpIHtcbiAgICAgIG9ialtuYW1lXSA9IHt9O1xuICAgIH1cbiAgICBvYmogPSBvYmpbbmFtZV07XG4gIH1cblxuICAvLyBzZXQgdGhlIHByb3BlcnR5IHZhbHVlXG4gIG9ialtwcm9wXSA9IHZhbHVlO1xuXG4gIHJldHVybiBvYmplY3Q7XG59XG5cbi8qKlxuICogQ29udmVydCBhbiBvYmplY3Qgd2l0aCBET1QgYXR0cmlidXRlcyB0byB0aGVpciB2aXMuanMgZXF1aXZhbGVudHMuXG4gKiBAcGFyYW0ge09iamVjdH0gYXR0ciAgICAgT2JqZWN0IHdpdGggRE9UIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXBwaW5nXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB2aXMuanMgYXR0cmlidXRlc1xuICovXG5mdW5jdGlvbiBjb252ZXJ0QXR0cihhdHRyLCBtYXBwaW5nKSB7XG4gIHZhciBjb252ZXJ0ZWQgPSB7fTtcblxuICBmb3IgKHZhciBwcm9wIGluIGF0dHIpIHtcbiAgICBpZiAoYXR0ci5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgdmFyIHZpc1Byb3AgPSBtYXBwaW5nW3Byb3BdO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmlzUHJvcCkpIHtcbiAgICAgICAgdmlzUHJvcC5mb3JFYWNoKGZ1bmN0aW9uICh2aXNQcm9wSSkge1xuICAgICAgICAgIHNldFByb3AoY29udmVydGVkLCB2aXNQcm9wSSwgYXR0cltwcm9wXSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmlzUHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgc2V0UHJvcChjb252ZXJ0ZWQsIHZpc1Byb3AsIGF0dHJbcHJvcF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0UHJvcChjb252ZXJ0ZWQsIHByb3AsIGF0dHJbcHJvcF0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb252ZXJ0ZWQ7XG59XG5cbi8qKlxuICogQ29udmVydCBhIHN0cmluZyBjb250YWluaW5nIGEgZ3JhcGggaW4gRE9UIGxhbmd1YWdlIGludG8gYSBtYXAgY29udGFpbmluZ1xuICogd2l0aCBub2RlcyBhbmQgZWRnZXMgaW4gdGhlIGZvcm1hdCBvZiBncmFwaC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhICAgICAgICAgVGV4dCBjb250YWluaW5nIGEgZ3JhcGggaW4gRE9ULW5vdGF0aW9uXG4gKiBAcmV0dXJuIHtPYmplY3R9IGdyYXBoRGF0YVxuICovXG5mdW5jdGlvbiBET1RUb0dyYXBoKGRhdGEpIHtcbiAgLy8gcGFyc2UgdGhlIERPVCBmaWxlXG4gIHZhciBkb3REYXRhID0gcGFyc2VET1QoZGF0YSk7XG4gIHZhciBncmFwaERhdGEgPSB7XG4gICAgbm9kZXM6IFtdLFxuICAgIGVkZ2VzOiBbXSxcbiAgICBvcHRpb25zOiB7fVxuXG4gICAgLy8gY29weSB0aGUgbm9kZXNcbiAgfTtpZiAoZG90RGF0YS5ub2Rlcykge1xuICAgIGRvdERhdGEubm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoZG90Tm9kZSkge1xuICAgICAgdmFyIGdyYXBoTm9kZSA9IHtcbiAgICAgICAgaWQ6IGRvdE5vZGUuaWQsXG4gICAgICAgIGxhYmVsOiBTdHJpbmcoZG90Tm9kZS5sYWJlbCB8fCBkb3ROb2RlLmlkKVxuICAgICAgfTtcbiAgICAgIG1lcmdlKGdyYXBoTm9kZSwgY29udmVydEF0dHIoZG90Tm9kZS5hdHRyLCBOT0RFX0FUVFJfTUFQUElORykpO1xuICAgICAgaWYgKGdyYXBoTm9kZS5pbWFnZSkge1xuICAgICAgICBncmFwaE5vZGUuc2hhcGUgPSAnaW1hZ2UnO1xuICAgICAgfVxuICAgICAgZ3JhcGhEYXRhLm5vZGVzLnB1c2goZ3JhcGhOb2RlKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIGNvcHkgdGhlIGVkZ2VzXG4gIGlmIChkb3REYXRhLmVkZ2VzKSB7XG4gICAgLyoqXG4gICAgICogQ29udmVydCBhbiBlZGdlIGluIERPVCBmb3JtYXQgdG8gYW4gZWRnZSB3aXRoIFZpc0dyYXBoIGZvcm1hdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkb3RFZGdlXG4gICAgICogQHJldHVybnMge09iamVjdH0gZ3JhcGhFZGdlXG4gICAgICovXG4gICAgdmFyIGNvbnZlcnRFZGdlID0gZnVuY3Rpb24gY29udmVydEVkZ2UoZG90RWRnZSkge1xuICAgICAgdmFyIGdyYXBoRWRnZSA9IHtcbiAgICAgICAgZnJvbTogZG90RWRnZS5mcm9tLFxuICAgICAgICB0bzogZG90RWRnZS50b1xuICAgICAgfTtcbiAgICAgIG1lcmdlKGdyYXBoRWRnZSwgY29udmVydEF0dHIoZG90RWRnZS5hdHRyLCBFREdFX0FUVFJfTUFQUElORykpO1xuXG4gICAgICAvLyBBZGQgYXJyb3dzIGF0dHJpYnV0ZSB0byBkZWZhdWx0IHN0eWxlZCBhcnJvdy5cbiAgICAgIC8vIFRoZSByZWFzb24gd2h5IGRlZmF1bHQgc3R5bGUgaXMgbm90IGFkZGVkIGluIHBhcnNlQXR0cmlidXRlTGlzdCgpIGlzXG4gICAgICAvLyBiZWNhdXNlIG9ubHkgZGVmYXVsdCBpcyBjbGVhcmVkIGJlZm9yZSBoZXJlLlxuICAgICAgaWYgKGdyYXBoRWRnZS5hcnJvd3MgPT0gbnVsbCAmJiBkb3RFZGdlLnR5cGUgPT09ICctPicpIHtcbiAgICAgICAgZ3JhcGhFZGdlLmFycm93cyA9ICd0byc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBncmFwaEVkZ2U7XG4gICAgfTtcblxuICAgIGRvdERhdGEuZWRnZXMuZm9yRWFjaChmdW5jdGlvbiAoZG90RWRnZSkge1xuICAgICAgdmFyIGZyb20sIHRvO1xuICAgICAgaWYgKGRvdEVkZ2UuZnJvbSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICBmcm9tID0gZG90RWRnZS5mcm9tLm5vZGVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnJvbSA9IHtcbiAgICAgICAgICBpZDogZG90RWRnZS5mcm9tXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChkb3RFZGdlLnRvIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgIHRvID0gZG90RWRnZS50by5ub2RlcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvID0ge1xuICAgICAgICAgIGlkOiBkb3RFZGdlLnRvXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChkb3RFZGdlLmZyb20gaW5zdGFuY2VvZiBPYmplY3QgJiYgZG90RWRnZS5mcm9tLmVkZ2VzKSB7XG4gICAgICAgIGRvdEVkZ2UuZnJvbS5lZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJFZGdlKSB7XG4gICAgICAgICAgdmFyIGdyYXBoRWRnZSA9IGNvbnZlcnRFZGdlKHN1YkVkZ2UpO1xuICAgICAgICAgIGdyYXBoRGF0YS5lZGdlcy5wdXNoKGdyYXBoRWRnZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmb3JFYWNoMihmcm9tLCB0bywgZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gICAgICAgIHZhciBzdWJFZGdlID0gY3JlYXRlRWRnZShncmFwaERhdGEsIGZyb20uaWQsIHRvLmlkLCBkb3RFZGdlLnR5cGUsIGRvdEVkZ2UuYXR0cik7XG4gICAgICAgIHZhciBncmFwaEVkZ2UgPSBjb252ZXJ0RWRnZShzdWJFZGdlKTtcbiAgICAgICAgZ3JhcGhEYXRhLmVkZ2VzLnB1c2goZ3JhcGhFZGdlKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZG90RWRnZS50byBpbnN0YW5jZW9mIE9iamVjdCAmJiBkb3RFZGdlLnRvLmVkZ2VzKSB7XG4gICAgICAgIGRvdEVkZ2UudG8uZWRnZXMuZm9yRWFjaChmdW5jdGlvbiAoc3ViRWRnZSkge1xuICAgICAgICAgIHZhciBncmFwaEVkZ2UgPSBjb252ZXJ0RWRnZShzdWJFZGdlKTtcbiAgICAgICAgICBncmFwaERhdGEuZWRnZXMucHVzaChncmFwaEVkZ2UpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIGNvcHkgdGhlIG9wdGlvbnNcbiAgaWYgKGRvdERhdGEuYXR0cikge1xuICAgIGdyYXBoRGF0YS5vcHRpb25zID0gZG90RGF0YS5hdHRyO1xuICB9XG5cbiAgcmV0dXJuIGdyYXBoRGF0YTtcbn1cblxuLy8gZXhwb3J0c1xuZXhwb3J0cy5wYXJzZURPVCA9IHBhcnNlRE9UO1xuZXhwb3J0cy5ET1RUb0dyYXBoID0gRE9UVG9HcmFwaDtcblxuLyoqKi8gfSksXG4vKiA3NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge2pzb259IGdlcGhpSlNPTlxuICogQHBhcmFtIHtvYmp9IG9wdGlvbnNPYmpcbiAqIEByZXR1cm5zIHt7bm9kZXM6IEFycmF5LCBlZGdlczogQXJyYXl9fVxuICovXG5mdW5jdGlvbiBwYXJzZUdlcGhpKGdlcGhpSlNPTiwgb3B0aW9uc09iaikge1xuICB2YXIgZWRnZXMgPSBbXTtcbiAgdmFyIG5vZGVzID0gW107XG4gIHZhciBvcHRpb25zID0ge1xuICAgIGVkZ2VzOiB7XG4gICAgICBpbmhlcml0Q29sb3I6IGZhbHNlXG4gICAgfSxcbiAgICBub2Rlczoge1xuICAgICAgZml4ZWQ6IGZhbHNlLFxuICAgICAgcGFyc2VDb2xvcjogZmFsc2VcbiAgICB9XG4gIH07XG5cbiAgaWYgKG9wdGlvbnNPYmogIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChvcHRpb25zT2JqLmZpeGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMubm9kZXMuZml4ZWQgPSBvcHRpb25zT2JqLmZpeGVkO1xuICAgIH1cbiAgICBpZiAob3B0aW9uc09iai5wYXJzZUNvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMubm9kZXMucGFyc2VDb2xvciA9IG9wdGlvbnNPYmoucGFyc2VDb2xvcjtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnNPYmouaW5oZXJpdENvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMuZWRnZXMuaW5oZXJpdENvbG9yID0gb3B0aW9uc09iai5pbmhlcml0Q29sb3I7XG4gICAgfVxuICB9XG5cbiAgdmFyIGdFZGdlcyA9IGdlcGhpSlNPTi5lZGdlcztcbiAgdmFyIGdOb2RlcyA9IGdlcGhpSlNPTi5ub2RlcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBnRWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWRnZSA9IHt9O1xuICAgIHZhciBnRWRnZSA9IGdFZGdlc1tpXTtcbiAgICBlZGdlWydpZCddID0gZ0VkZ2UuaWQ7XG4gICAgZWRnZVsnZnJvbSddID0gZ0VkZ2Uuc291cmNlO1xuICAgIGVkZ2VbJ3RvJ10gPSBnRWRnZS50YXJnZXQ7XG4gICAgZWRnZVsnYXR0cmlidXRlcyddID0gZ0VkZ2UuYXR0cmlidXRlcztcbiAgICBlZGdlWydsYWJlbCddID0gZ0VkZ2UubGFiZWw7XG4gICAgZWRnZVsndGl0bGUnXSA9IGdFZGdlLmF0dHJpYnV0ZXMgIT09IHVuZGVmaW5lZCA/IGdFZGdlLmF0dHJpYnV0ZXMudGl0bGUgOiB1bmRlZmluZWQ7XG4gICAgaWYgKGdFZGdlWyd0eXBlJ10gPT09ICdEaXJlY3RlZCcpIHtcbiAgICAgIGVkZ2VbJ2Fycm93cyddID0gJ3RvJztcbiAgICB9XG4gICAgLy8gICAgZWRnZVsndmFsdWUnXSA9IGdFZGdlLmF0dHJpYnV0ZXMgIT09IHVuZGVmaW5lZCA/IGdFZGdlLmF0dHJpYnV0ZXMuV2VpZ2h0IDogdW5kZWZpbmVkO1xuICAgIC8vICAgIGVkZ2VbJ3dpZHRoJ10gPSBlZGdlWyd2YWx1ZSddICE9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBlZGdlZ0VkZ2Uuc2l6ZTtcbiAgICBpZiAoZ0VkZ2UuY29sb3IgJiYgb3B0aW9ucy5pbmhlcml0Q29sb3IgPT09IGZhbHNlKSB7XG4gICAgICBlZGdlWydjb2xvciddID0gZ0VkZ2UuY29sb3I7XG4gICAgfVxuICAgIGVkZ2VzLnB1c2goZWRnZSk7XG4gIH1cblxuICBmb3IgKHZhciBqID0gMDsgaiA8IGdOb2Rlcy5sZW5ndGg7IGorKykge1xuICAgIHZhciBub2RlID0ge307XG4gICAgdmFyIGdOb2RlID0gZ05vZGVzW2pdO1xuICAgIG5vZGVbJ2lkJ10gPSBnTm9kZS5pZDtcbiAgICBub2RlWydhdHRyaWJ1dGVzJ10gPSBnTm9kZS5hdHRyaWJ1dGVzO1xuICAgIG5vZGVbJ3gnXSA9IGdOb2RlLng7XG4gICAgbm9kZVsneSddID0gZ05vZGUueTtcbiAgICBub2RlWydsYWJlbCddID0gZ05vZGUubGFiZWw7XG4gICAgbm9kZVsndGl0bGUnXSA9IGdOb2RlLmF0dHJpYnV0ZXMgIT09IHVuZGVmaW5lZCA/IGdOb2RlLmF0dHJpYnV0ZXMudGl0bGUgOiBnTm9kZS50aXRsZTtcbiAgICBpZiAob3B0aW9ucy5ub2Rlcy5wYXJzZUNvbG9yID09PSB0cnVlKSB7XG4gICAgICBub2RlWydjb2xvciddID0gZ05vZGUuY29sb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGVbJ2NvbG9yJ10gPSBnTm9kZS5jb2xvciAhPT0gdW5kZWZpbmVkID8ge1xuICAgICAgICBiYWNrZ3JvdW5kOiBnTm9kZS5jb2xvcixcbiAgICAgICAgYm9yZGVyOiBnTm9kZS5jb2xvcixcbiAgICAgICAgaGlnaGxpZ2h0OiB7IGJhY2tncm91bmQ6IGdOb2RlLmNvbG9yLCBib3JkZXI6IGdOb2RlLmNvbG9yIH0sXG4gICAgICAgIGhvdmVyOiB7IGJhY2tncm91bmQ6IGdOb2RlLmNvbG9yLCBib3JkZXI6IGdOb2RlLmNvbG9yIH1cbiAgICAgIH0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIG5vZGVbJ3NpemUnXSA9IGdOb2RlLnNpemU7XG4gICAgbm9kZVsnZml4ZWQnXSA9IG9wdGlvbnMubm9kZXMuZml4ZWQgJiYgZ05vZGUueCAhPT0gdW5kZWZpbmVkICYmIGdOb2RlLnkgIT09IHVuZGVmaW5lZDtcbiAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIHsgbm9kZXM6IG5vZGVzLCBlZGdlczogZWRnZXMgfTtcbn1cblxuZXhwb3J0cy5wYXJzZUdlcGhpID0gcGFyc2VHZXBoaTtcblxuLyoqKi8gfSksXG4vKiA3NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfQ2FjaGVkSW1hZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzMyk7XG5cbnZhciBfQ2FjaGVkSW1hZ2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2FjaGVkSW1hZ2UpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbi8qKlxuICogVGhpcyBjYWxsYmFjayBpcyBhIGNhbGxiYWNrIHRoYXQgYWNjZXB0cyBhbiBJbWFnZS5cbiAqIEBjYWxsYmFjayBJbWFnZUNhbGxiYWNrXG4gKiBAcGFyYW0ge0ltYWdlfSBpbWFnZVxuICovXG5cbi8qKlxuICogVGhpcyBjbGFzcyBsb2FkcyBpbWFnZXMgYW5kIGtlZXBzIHRoZW0gc3RvcmVkLlxuICpcbiAqIEBwYXJhbSB7SW1hZ2VDYWxsYmFja30gY2FsbGJhY2tcbiAqL1xudmFyIEltYWdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SW1hZ2VDYWxsYmFja30gY2FsbGJhY2tcbiAgICovXG4gIGZ1bmN0aW9uIEltYWdlcyhjYWxsYmFjaykge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIEltYWdlcyk7XG5cbiAgICB0aGlzLmltYWdlcyA9IHt9O1xuICAgIHRoaXMuaW1hZ2VCcm9rZW4gPSB7fTtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAgICAgICAgICAgICAgICAgICAgICBUaGUgb3JpZ2luYWwgVXJsIHRoYXQgZmFpbGVkIHRvIGxvYWQsIGlmIHRoZSBicm9rZW4gaW1hZ2UgaXMgc3VjY2Vzc2Z1bGx5IGxvYWRlZCBpdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBjYWNoZSB1c2luZyB0aGlzIFVybCBhcyB0aGUga2V5IHNvIHRoYXQgc3Vic2VxdWVudCByZXF1ZXN0cyBmb3IgdGhpcyBVcmwgd2lsbCByZXR1cm4gdGhlIGJyb2tlbiBpbWFnZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gYnJva2VuVXJsICAgICAgICAgICAgICAgIFVybCB0aGUgYnJva2VuIGltYWdlIHRvIHRyeSBhbmQgbG9hZFxuICAgKiBAcGFyYW0ge0ltYWdlfSBpbWFnZVRvTG9hZEJyb2tlblVybE9uICAgVGhlIGltYWdlIG9iamVjdFxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKEltYWdlcywgW3tcbiAgICBrZXk6ICdfdHJ5bG9hZEJyb2tlblVybCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90cnlsb2FkQnJva2VuVXJsKHVybCwgYnJva2VuVXJsLCBpbWFnZVRvTG9hZEJyb2tlblVybE9uKSB7XG4gICAgICAvL0lmIHRoZXNlIHBhcmFtZXRlcnMgYXJlbid0IHNwZWNpZmllZCB0aGVuIGV4aXQgdGhlIGZ1bmN0aW9uIGJlY2F1c2Ugbm90aGluZyBjb25zdHJ1Y3RpdmUgY2FuIGJlIGRvbmVcbiAgICAgIGlmICh1cmwgPT09IHVuZGVmaW5lZCB8fCBpbWFnZVRvTG9hZEJyb2tlblVybE9uID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICAgIGlmIChicm9rZW5VcmwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ05vIGJyb2tlbiB1cmwgaW1hZ2UgZGVmaW5lZCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vQ2xlYXIgdGhlIG9sZCBzdWJzY3JpcHRpb24gdG8gdGhlIGVycm9yIGV2ZW50IGFuZCBwdXQgYSBuZXcgaW4gcGxhY2UgdGhhdCBvbmx5IGhhbmRsZSBlcnJvcnMgaW4gbG9hZGluZyB0aGUgYnJva2VuSW1hZ2VVcmxcbiAgICAgIGltYWdlVG9Mb2FkQnJva2VuVXJsT24ub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignQ291bGQgbm90IGxvYWQgYnJva2VuSW1hZ2U6JywgYnJva2VuVXJsKTtcbiAgICAgICAgLy8gY2FjaGUgaXRlbSB3aWxsIGNvbnRhaW4gZW1wdHkgaW1hZ2UsIHRoaXMgc2hvdWxkIGJlIE9LIGZvciBkZWZhdWx0XG4gICAgICB9O1xuXG4gICAgICAvL1NldCB0aGUgc291cmNlIG9mIHRoZSBpbWFnZSB0byB0aGUgYnJva2VuVXJsLCB0aGlzIGlzIGFjdHVhbGx5IHdoYXQga2lja3Mgb2ZmIHRoZSBsb2FkaW5nIG9mIHRoZSBicm9rZW4gaW1hZ2VcbiAgICAgIGltYWdlVG9Mb2FkQnJva2VuVXJsT24uaW1hZ2Uuc3JjID0gYnJva2VuVXJsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHt2aXMuSW1hZ2V9IGltYWdlVG9SZWRyYXdXaXRoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3JlZHJhd1dpdGhJbWFnZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWRyYXdXaXRoSW1hZ2UoaW1hZ2VUb1JlZHJhd1dpdGgpIHtcbiAgICAgIGlmICh0aGlzLmNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2soaW1hZ2VUb1JlZHJhd1dpdGgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgICAgICAgICAgVXJsIG9mIHRoZSBpbWFnZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBicm9rZW5VcmwgICAgVXJsIG9mIGFuIGltYWdlIHRvIHVzZSBpZiB0aGUgdXJsIGltYWdlIGlzIG5vdCBmb3VuZFxuICAgICAqIEByZXR1cm4ge0ltYWdlfSBpbWcgICAgICAgICAgVGhlIGltYWdlIG9iamVjdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdsb2FkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZCh1cmwsIGJyb2tlblVybCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgLy9UcnkgYW5kIGdldCB0aGUgaW1hZ2UgZnJvbSB0aGUgY2FjaGUsIGlmIHN1Y2Nlc3NmdWwgdGhlbiByZXR1cm4gdGhlIGNhY2hlZCBpbWFnZVxuICAgICAgdmFyIGNhY2hlZEltYWdlID0gdGhpcy5pbWFnZXNbdXJsXTtcbiAgICAgIGlmIChjYWNoZWRJbWFnZSkgcmV0dXJuIGNhY2hlZEltYWdlO1xuXG4gICAgICAvL0NyZWF0ZSBhIG5ldyBpbWFnZVxuICAgICAgdmFyIGltZyA9IG5ldyBfQ2FjaGVkSW1hZ2UyWydkZWZhdWx0J10oKTtcblxuICAgICAgLy8gTmVlZCB0byBhZGQgdG8gY2FjaGUgaGVyZSwgb3RoZXJ3aXNlIGZpbmFsIHJldHVybiB3aWxsIHNwYXduIGRpZmZlcmVudCBjb3BpZXMgb2YgdGhlIHNhbWUgaW1hZ2UsXG4gICAgICAvLyBBbHNvLCB0aGVyZSB3aWxsIGJlIG11bHRpcGxlIGxvYWRzIG9mIHRoZSBzYW1lIGltYWdlLlxuICAgICAgdGhpcy5pbWFnZXNbdXJsXSA9IGltZztcblxuICAgICAgLy9TdWJzY3JpYmUgdG8gdGhlIGV2ZW50IHRoYXQgaXMgcmFpc2VkIGlmIHRoZSBpbWFnZSBsb2FkcyBzdWNjZXNzZnVsbHlcbiAgICAgIGltZy5pbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFByb3Blcmx5IGluaXQgdGhlIGNhY2hlZCBpdGVtIGFuZCB0aGVuIHJlcXVlc3QgYSByZWRyYXdcbiAgICAgICAgX3RoaXMuX2ZpeEltYWdlQ29vcmRpbmF0ZXMoaW1nLmltYWdlKTtcbiAgICAgICAgaW1nLmluaXQoKTtcbiAgICAgICAgX3RoaXMuX3JlZHJhd1dpdGhJbWFnZShpbWcpO1xuICAgICAgfTtcblxuICAgICAgLy9TdWJzY3JpYmUgdG8gdGhlIGV2ZW50IHRoYXQgaXMgcmFpc2VkIGlmIHRoZSBpbWFnZSBmYWlscyB0byBsb2FkXG4gICAgICBpbWcuaW1hZ2Uub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignQ291bGQgbm90IGxvYWQgaW1hZ2U6JywgdXJsKTtcbiAgICAgICAgLy9UcnkgYW5kIGxvYWQgdGhlIGltYWdlIHNwZWNpZmllZCBieSB0aGUgYnJva2VuVXJsIHVzaW5nXG4gICAgICAgIF90aGlzLl90cnlsb2FkQnJva2VuVXJsKHVybCwgYnJva2VuVXJsLCBpbWcpO1xuICAgICAgfTtcblxuICAgICAgLy9TZXQgdGhlIHNvdXJjZSBvZiB0aGUgaW1hZ2UgdG8gdGhlIHVybCwgdGhpcyBpcyB3aGF0IGFjdHVhbGx5IGtpY2tzIG9mZiB0aGUgbG9hZGluZyBvZiB0aGUgaW1hZ2VcbiAgICAgIGltZy5pbWFnZS5zcmMgPSB1cmw7XG5cbiAgICAgIC8vUmV0dXJuIHRoZSBuZXcgaW1hZ2VcbiAgICAgIHJldHVybiBpbWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSUUxMSBmaXggLS0gdGhhbmtzIGRwb25jaCFcbiAgICAgKlxuICAgICAqIExvY2FsIGhlbHBlciBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7dmlzLkltYWdlfSBpbWFnZVRvQ2FjaGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZml4SW1hZ2VDb29yZGluYXRlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maXhJbWFnZUNvb3JkaW5hdGVzKGltYWdlVG9DYWNoZSkge1xuICAgICAgaWYgKGltYWdlVG9DYWNoZS53aWR0aCA9PT0gMCkge1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGltYWdlVG9DYWNoZSk7XG4gICAgICAgIGltYWdlVG9DYWNoZS53aWR0aCA9IGltYWdlVG9DYWNoZS5vZmZzZXRXaWR0aDtcbiAgICAgICAgaW1hZ2VUb0NhY2hlLmhlaWdodCA9IGltYWdlVG9DYWNoZS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaW1hZ2VUb0NhY2hlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEltYWdlcztcbn0oKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gSW1hZ2VzO1xuXG4vKioqLyB9KSxcbi8qIDc3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfc2xpY2VkVG9BcnJheTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblxudmFyIF9zbGljZWRUb0FycmF5MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NsaWNlZFRvQXJyYXkyKTtcblxudmFyIF90eXBlb2YyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxudmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mMik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgQ29tcG9uZW50VXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpWydkZWZhdWx0J107XG52YXIgTGFiZWxTcGxpdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTM5KVsnZGVmYXVsdCddO1xuXG4vKipcbiAqIExpc3Qgb2Ygc3BlY2lhbCBzdHlsZXMgZm9yIG11bHRpLWZvbnRzXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgbXVsdGlGb250U3R5bGUgPSBbJ2JvbGQnLCAnaXRhbCcsICdib2xkaXRhbCcsICdtb25vJ107XG5cbi8qKlxuICogQSBMYWJlbCB0byBiZSB1c2VkIGZvciBOb2RlcyBvciBFZGdlcy5cbiAqL1xuXG52YXIgTGFiZWwgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtlZGdlbGFiZWw9ZmFsc2VdXG4gICAqL1xuICBmdW5jdGlvbiBMYWJlbChib2R5LCBvcHRpb25zKSB7XG4gICAgdmFyIGVkZ2VsYWJlbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgTGFiZWwpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLnBvaW50VG9TZWxmID0gZmFsc2U7XG4gICAgdGhpcy5iYXNlU2l6ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZvbnRPcHRpb25zID0ge307IC8vIGluc3RhbmNlIHZhcmlhYmxlIGNvbnRhaW5pbmcgdGhlICppbnN0YW5jZS1sb2NhbCogZm9udCBvcHRpb25zXG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIHRoaXMuc2l6ZSA9IHsgdG9wOiAwLCBsZWZ0OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwLCB5TGluZTogMCB9O1xuICAgIHRoaXMuaXNFZGdlTGFiZWwgPSBlZGdlbGFiZWw7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdGhlIG9wdGlvbnMgb2YgdGhlIHBhcmVudCBOb2RlLWluc3RhbmNlXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoTGFiZWwsIFt7XG4gICAga2V5OiAnc2V0T3B0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdGhpcy5lbGVtZW50T3B0aW9ucyA9IG9wdGlvbnM7IC8vIFJlZmVyZW5jZSB0byB0aGUgb3B0aW9ucyBvZiB0aGUgcGFyZW50IE5vZGUtaW5zdGFuY2VcblxuICAgICAgdGhpcy5pbml0Rm9udE9wdGlvbnMob3B0aW9ucy5mb250KTtcblxuICAgICAgaWYgKENvbXBvbmVudFV0aWwuaXNWYWxpZExhYmVsKG9wdGlvbnMubGFiZWwpKSB7XG4gICAgICAgIHRoaXMubGFiZWxEaXJ0eSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBCYWQgbGFiZWwhIENoYW5nZSB0aGUgb3B0aW9uIHZhbHVlIHRvIHByZXZlbnQgYmFkIHN0dWZmIGhhcHBlbmluZ1xuICAgICAgICBvcHRpb25zLmxhYmVsID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmZvbnQgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmZvbnQgIT09IG51bGwpIHtcbiAgICAgICAgLy8gZm9udCBvcHRpb25zIGNhbiBiZSBkZWxldGVkIGF0IHZhcmlvdXMgbGV2ZWxzXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mb250ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuYmFzZVNpemUgPSB0aGlzLmZvbnRPcHRpb25zLnNpemU7XG4gICAgICAgIH0gZWxzZSBpZiAoKDAsIF90eXBlb2YzWydkZWZhdWx0J10pKG9wdGlvbnMuZm9udCkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdmFyIHNpemUgPSBvcHRpb25zLmZvbnQuc2l6ZTtcblxuICAgICAgICAgIGlmIChzaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZVNpemUgPSBzaXplO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXQgdGhlIGZvbnQgT3B0aW9ucyBzdHJ1Y3R1cmUuXG4gICAgICpcbiAgICAgKiBNZW1iZXIgZm9udE9wdGlvbnMgc2VydmVzIGFzIGFuIGFjY3VtdWxhdG9yIGZvciB0aGUgY3VycmVudCBmb250IG9wdGlvbnMuXG4gICAgICogQXMgc3VjaCwgaXQgbmVlZHMgdG8gYmUgY29tcGxldGVseSBzZXBhcmF0ZWQgZnJvbSB0aGUgbm9kZSBvcHRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5ld0ZvbnRPcHRpb25zIHRoZSBuZXcgZm9udCBvcHRpb25zIHRvIHByb2Nlc3NcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdpbml0Rm9udE9wdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0Rm9udE9wdGlvbnMobmV3Rm9udE9wdGlvbnMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIC8vIFByZXBhcmUgdGhlIG11bHRpLWZvbnQgb3B0aW9uIG9iamVjdHMuXG4gICAgICAvLyBUaGVzZSB3aWxsIGJlIGZpbGxlZCBpbiBwcm9wYWdhdGVGb250cygpLCBpZiByZXF1aXJlZFxuICAgICAgdXRpbC5mb3JFYWNoKG11bHRpRm9udFN0eWxlLCBmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICAgICAgX3RoaXMuZm9udE9wdGlvbnNbc3R5bGVdID0ge307XG4gICAgICB9KTtcblxuICAgICAgLy8gSGFuZGxlIHNob3J0aGFuZCBvcHRpb24sIGlmIHByZXNlbnRcbiAgICAgIGlmIChMYWJlbC5wYXJzZUZvbnRTdHJpbmcodGhpcy5mb250T3B0aW9ucywgbmV3Rm9udE9wdGlvbnMpKSB7XG4gICAgICAgIHRoaXMuZm9udE9wdGlvbnMudmFkanVzdCA9IDA7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQ29weSBvdmVyIHRoZSBub24tbXVsdGlmb250IG9wdGlvbnMsIGlmIHNwZWNpZmllZFxuICAgICAgdXRpbC5mb3JFYWNoKG5ld0ZvbnRPcHRpb25zLCBmdW5jdGlvbiAocHJvcCwgbikge1xuICAgICAgICBpZiAocHJvcCAhPT0gdW5kZWZpbmVkICYmIHByb3AgIT09IG51bGwgJiYgKHR5cGVvZiBwcm9wID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogKDAsIF90eXBlb2YzWydkZWZhdWx0J10pKHByb3ApKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBfdGhpcy5mb250T3B0aW9uc1tuXSA9IHByb3A7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIGluLXZhcmlhYmxlIGlzIGEgc3RyaW5nLCBwYXJzZSBpdCBhcyBhIGZvbnQgc3BlY2lmaWVyLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IGZvbGxvd2luZyBpcyBub3QgZG9uZSBoZXJlIGFuZCBoYXZlIHRvIGJlIGRvbmUgYWZ0ZXIgdGhlIGNhbGw6XG4gICAgICogLSBObyBudW1iZXIgY29udmVyc2lvbiAoc2l6ZSlcbiAgICAgKiAtIE5vdCBhbGwgZm9udCBvcHRpb25zIGFyZSBzZXQgKHZhZGp1c3QsIG1vZClcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdXRPcHRpb25zICBvdXQtcGFyYW1ldGVyLCBvYmplY3QgaW4gd2hpY2ggdG8gc3RvcmUgdGhlIHBhcnNlIHJlc3VsdHMgKGlmIGFueSlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5PcHRpb25zICBmb250IG9wdGlvbnMgdG8gcGFyc2VcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIGZvbnQgcGFyc2VkIGFzIHN0cmluZywgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdjb25zdHJhaW4nLFxuXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHdpZHRoIGFuZCBoZWlnaHQgY29uc3RyYWludHMgYmFzZWQgb24gJ25lYXJlc3QnIHZhbHVlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwaWxlIGFycmF5IG9mIG9wdGlvbiBvYmplY3RzIHRvIGNvbnNpZGVyXG4gICAgICogQHJldHVybnMge29iamVjdH0gdGhlIGFjdHVhbCBjb25zdHJhaW50IHZhbHVlcyB0byB1c2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25zdHJhaW4ocGlsZSkge1xuICAgICAgLy8gTk9URTogY29uc3RyYWluV2lkdGggYW5kICBjb25zdHJhaW5IZWlnaHQgbmV2ZXIgc2V0IVxuICAgICAgLy8gTk9URTogZm9yIGVkZ2UgbGFiZWxzLCBvbmx5ICdtYXhXZHQnIHNldFxuICAgICAgLy8gTm9kZSBsYWJlbHMgY2FuIHNldCBhbGwgdGhlIGZpZWxkc1xuICAgICAgdmFyIGZvbnRPcHRpb25zID0ge1xuICAgICAgICBjb25zdHJhaW5XaWR0aDogZmFsc2UsXG4gICAgICAgIG1heFdkdDogLTEsXG4gICAgICAgIG1pbldkdDogLTEsXG4gICAgICAgIGNvbnN0cmFpbkhlaWdodDogZmFsc2UsXG4gICAgICAgIG1pbkhndDogLTEsXG4gICAgICAgIHZhbGlnbjogJ21pZGRsZSdcbiAgICAgIH07XG5cbiAgICAgIHZhciB3aWR0aENvbnN0cmFpbnQgPSB1dGlsLnRvcE1vc3QocGlsZSwgJ3dpZHRoQ29uc3RyYWludCcpO1xuICAgICAgaWYgKHR5cGVvZiB3aWR0aENvbnN0cmFpbnQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGZvbnRPcHRpb25zLm1heFdkdCA9IE51bWJlcih3aWR0aENvbnN0cmFpbnQpO1xuICAgICAgICBmb250T3B0aW9ucy5taW5XZHQgPSBOdW1iZXIod2lkdGhDb25zdHJhaW50KTtcbiAgICAgIH0gZWxzZSBpZiAoKHR5cGVvZiB3aWR0aENvbnN0cmFpbnQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiAoMCwgX3R5cGVvZjNbJ2RlZmF1bHQnXSkod2lkdGhDb25zdHJhaW50KSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHZhciB3aWR0aENvbnN0cmFpbnRNYXhpbXVtID0gdXRpbC50b3BNb3N0KHBpbGUsIFsnd2lkdGhDb25zdHJhaW50JywgJ21heGltdW0nXSk7XG4gICAgICAgIGlmICh0eXBlb2Ygd2lkdGhDb25zdHJhaW50TWF4aW11bSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBmb250T3B0aW9ucy5tYXhXZHQgPSBOdW1iZXIod2lkdGhDb25zdHJhaW50TWF4aW11bSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdpZHRoQ29uc3RyYWludE1pbmltdW0gPSB1dGlsLnRvcE1vc3QocGlsZSwgWyd3aWR0aENvbnN0cmFpbnQnLCAnbWluaW11bSddKTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aWR0aENvbnN0cmFpbnRNaW5pbXVtID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGZvbnRPcHRpb25zLm1pbldkdCA9IE51bWJlcih3aWR0aENvbnN0cmFpbnRNaW5pbXVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaGVpZ2h0Q29uc3RyYWludCA9IHV0aWwudG9wTW9zdChwaWxlLCAnaGVpZ2h0Q29uc3RyYWludCcpO1xuICAgICAgaWYgKHR5cGVvZiBoZWlnaHRDb25zdHJhaW50ID09PSAnbnVtYmVyJykge1xuICAgICAgICBmb250T3B0aW9ucy5taW5IZ3QgPSBOdW1iZXIoaGVpZ2h0Q29uc3RyYWludCk7XG4gICAgICB9IGVsc2UgaWYgKCh0eXBlb2YgaGVpZ2h0Q29uc3RyYWludCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6ICgwLCBfdHlwZW9mM1snZGVmYXVsdCddKShoZWlnaHRDb25zdHJhaW50KSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHZhciBoZWlnaHRDb25zdHJhaW50TWluaW11bSA9IHV0aWwudG9wTW9zdChwaWxlLCBbJ2hlaWdodENvbnN0cmFpbnQnLCAnbWluaW11bSddKTtcbiAgICAgICAgaWYgKHR5cGVvZiBoZWlnaHRDb25zdHJhaW50TWluaW11bSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBmb250T3B0aW9ucy5taW5IZ3QgPSBOdW1iZXIoaGVpZ2h0Q29uc3RyYWludE1pbmltdW0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoZWlnaHRDb25zdHJhaW50VmFsaWduID0gdXRpbC50b3BNb3N0KHBpbGUsIFsnaGVpZ2h0Q29uc3RyYWludCcsICd2YWxpZ24nXSk7XG4gICAgICAgIGlmICh0eXBlb2YgaGVpZ2h0Q29uc3RyYWludFZhbGlnbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpZiAoaGVpZ2h0Q29uc3RyYWludFZhbGlnbiA9PT0gJ3RvcCcgfHwgaGVpZ2h0Q29uc3RyYWludFZhbGlnbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgIGZvbnRPcHRpb25zLnZhbGlnbiA9IGhlaWdodENvbnN0cmFpbnRWYWxpZ247XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmb250T3B0aW9ucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgb3B0aW9ucyBhbmQgdXBkYXRlIGludGVybmFsIHN0YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAgb3B0aW9ucyB0byBzZXRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgcGlsZSAgICAgYXJyYXkgb2Ygb3B0aW9uIG9iamVjdHMgdG8gY29uc2lkZXIgZm9yIG9wdGlvbiAnY2hvc2VuJ1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUob3B0aW9ucywgcGlsZSkge1xuICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMsIHRydWUpO1xuICAgICAgdGhpcy5wcm9wYWdhdGVGb250cyhwaWxlKTtcbiAgICAgIHV0aWwuZGVlcEV4dGVuZCh0aGlzLmZvbnRPcHRpb25zLCB0aGlzLmNvbnN0cmFpbihwaWxlKSk7XG4gICAgICB0aGlzLmZvbnRPcHRpb25zLmNob29zZXIgPSBDb21wb25lbnRVdGlsLmNob29zaWZ5KCdsYWJlbCcsIHBpbGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZW4gbWFyZ2lucyBhcmUgc2V0IGluIGFuIGVsZW1lbnQsIGFkanVzdCBzaXplcyBpcyBjYWxsZWQgdG8gcmVtb3ZlIHRoZW1cbiAgICAgKiBmcm9tIHRoZSB3aWR0aC9oZWlnaHQgY29uc3RyYWludHMuIFRoaXMgbXVzdCBiZSBkb25lIHByaW9yIHRvIGxhYmVsIHNpemluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e3RvcDogbnVtYmVyLCByaWdodDogbnVtYmVyLCBib3R0b206IG51bWJlciwgbGVmdDogbnVtYmVyfX0gbWFyZ2luc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhZGp1c3RTaXplcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkanVzdFNpemVzKG1hcmdpbnMpIHtcbiAgICAgIHZhciB3aWR0aEJpYXMgPSBtYXJnaW5zID8gbWFyZ2lucy5yaWdodCArIG1hcmdpbnMubGVmdCA6IDA7XG4gICAgICBpZiAodGhpcy5mb250T3B0aW9ucy5jb25zdHJhaW5XaWR0aCkge1xuICAgICAgICB0aGlzLmZvbnRPcHRpb25zLm1heFdkdCAtPSB3aWR0aEJpYXM7XG4gICAgICAgIHRoaXMuZm9udE9wdGlvbnMubWluV2R0IC09IHdpZHRoQmlhcztcbiAgICAgIH1cbiAgICAgIHZhciBoZWlnaHRCaWFzID0gbWFyZ2lucyA/IG1hcmdpbnMudG9wICsgbWFyZ2lucy5ib3R0b20gOiAwO1xuICAgICAgaWYgKHRoaXMuZm9udE9wdGlvbnMuY29uc3RyYWluSGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuZm9udE9wdGlvbnMubWluSGd0IC09IGhlaWdodEJpYXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gTWV0aG9kcyBmb3IgaGFuZGxpbmcgb3B0aW9ucyBwaWxlc1xuICAgIC8vIEV2ZW50dWFsbHksIHRoZXNlIHdpbGwgYmUgbW92ZWQgdG8gYSBzZXBhcmF0ZSBjbGFzc1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgLyoqXG4gICAgICogQWRkIHRoZSBmb250IG1lbWJlcnMgb2YgdGhlIHBhc3NlZCBsaXN0IG9mIG9wdGlvbiBvYmplY3RzIHRvIHRoZSBwaWxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQaWxlfSBkc3RQaWxlICBwaWxlIG9mIG9wdGlvbiBvYmplY3RzIGFkZCB0b1xuICAgICAqIEBwYXJhbSB7UGlsZX0gc3JjUGlsZSAgcGlsZSBvZiBvcHRpb24gb2JqZWN0cyB0byB0YWtlIGZvbnQgb3B0aW9ucyBmcm9tXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYWRkRm9udE9wdGlvbnNUb1BpbGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRGb250T3B0aW9uc1RvUGlsZShkc3RQaWxlLCBzcmNQaWxlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNyY1BpbGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdGhpcy5hZGRGb250VG9QaWxlKGRzdFBpbGUsIHNyY1BpbGVbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBnaXZlbiBmb250IG9wdGlvbiBvYmplY3QgdG8gdGhlIGxpc3Qgb2Ygb2JqZWN0cyAodGhlICdwaWxlJykgdG8gY29uc2lkZXIgZm9yIGRldGVybWluaW5nXG4gICAgICogbXVsdGktZm9udCBvcHRpb24gdmFsdWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQaWxlfSBwaWxlICBwaWxlIG9mIG9wdGlvbiBvYmplY3RzIHRvIHVzZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zICBpbnN0YW5jZSB0byBhZGQgdG8gcGlsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2FkZEZvbnRUb1BpbGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRGb250VG9QaWxlKHBpbGUsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICAgIGlmIChvcHRpb25zLmZvbnQgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmZvbnQgPT09IG51bGwpIHJldHVybjtcblxuICAgICAgdmFyIGl0ZW0gPSBvcHRpb25zLmZvbnQ7XG4gICAgICBwaWxlLnB1c2goaXRlbSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29sbGVjdCBhbGwgb3duLXByb3BlcnR5IHZhbHVlcyBmcm9tIHRoZSBmb250IHBpbGUgdGhhdCBhcmVuJ3QgbXVsdGktZm9udCBvcHRpb24gb2JqZWN0c3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BpbGV9IHBpbGUgIHBpbGUgb2Ygb3B0aW9uIG9iamVjdHMgdG8gdXNlXG4gICAgICogQHJldHVybnMge29iamVjdH0gb2JqZWN0IHdpdGggYWxsIGN1cnJlbnQgb3duIGJhc2ljIGZvbnQgcHJvcGVydGllc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldEJhc2ljT3B0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJhc2ljT3B0aW9ucyhwaWxlKSB7XG4gICAgICB2YXIgcmV0ID0ge307XG5cbiAgICAgIC8vIFNjYW5zIHRoZSB3aG9sZSBwaWxlIHRvIGdldCBhbGwgb3B0aW9ucyBwcmVzZW50XG4gICAgICBmb3IgKHZhciBuID0gMDsgbiA8IHBpbGUubGVuZ3RoOyArK24pIHtcbiAgICAgICAgdmFyIGZvbnRPcHRpb25zID0gcGlsZVtuXTtcblxuICAgICAgICAvLyBDb252ZXJ0IHNob3J0aGFuZCBpZiBuZWNlc3NhcnlcbiAgICAgICAgdmFyIHRtcFNob3J0aGFuZCA9IHt9O1xuICAgICAgICBpZiAoTGFiZWwucGFyc2VGb250U3RyaW5nKHRtcFNob3J0aGFuZCwgZm9udE9wdGlvbnMpKSB7XG4gICAgICAgICAgZm9udE9wdGlvbnMgPSB0bXBTaG9ydGhhbmQ7XG4gICAgICAgIH1cblxuICAgICAgICB1dGlsLmZvckVhY2goZm9udE9wdGlvbnMsIGZ1bmN0aW9uIChvcHQsIG5hbWUpIHtcbiAgICAgICAgICBpZiAob3B0ID09PSB1bmRlZmluZWQpIHJldHVybjsgLy8gbXVsdGktZm9udCBvcHRpb24gbmVlZCBub3QgYmUgcHJlc2VudFxuICAgICAgICAgIGlmIChyZXQuaGFzT3duUHJvcGVydHkobmFtZSkpIHJldHVybjsgLy8gS2VlcCBmaXJzdCB2YWx1ZSB3ZSBlbmNvdW50ZXJcblxuICAgICAgICAgIGlmIChtdWx0aUZvbnRTdHlsZS5pbmRleE9mKG5hbWUpICE9PSAtMSkge1xuICAgICAgICAgICAgLy8gU2tpcCBtdWx0aS1mb250IHByb3BlcnRpZXMgYnV0IHdlIGRvIG5lZWQgdGhlIHN0cnVjdHVyZVxuICAgICAgICAgICAgcmV0W25hbWVdID0ge307XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldFtuYW1lXSA9IG9wdDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgdmFsdWUgZm9yIGdpdmVuIG9wdGlvbiBmb3IgdGhlIGdpdmVuIG11bHRpLWZvbnQuXG4gICAgICpcbiAgICAgKiBBbGwgYXZhaWxhYmxlIG9wdGlvbiBvYmplY3RzIGFyZSB0cmF3bGVkIGluIHRoZSBzZXQgb3JkZXIgdG8gY29uc3RydWN0IHRoZSBvcHRpb24gdmFsdWVzLlxuICAgICAqXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICogIyMgVHJhdmVyc2FsIG9mIHBpbGUgZm9yIG11bHRpLWZvbnRzXG4gICAgICpcbiAgICAgKiBUaGUgZGV0ZXJtaW5hdGlvbiBvZiBtdWx0aS1mb250IG9wdGlvbiB2YWx1ZXMgaXMgYSBzcGVjaWFsIGNhc2UsIGJlY2F1c2UgYW55IHZhbHVlcyBub3RcbiAgICAgKiBwcmVzZW50IGluIHRoZSBtdWx0aS1mb250IG9wdGlvbnMgc2hvdWxkIGJ5IGRlZmluaXRpb24gYmUgdGFrZW4gZnJvbSB0aGUgbWFpbiBmb250IG9wdGlvbnMsXG4gICAgICogaS5lLiBmcm9tIHRoZSBjdXJyZW50ICdwYXJlbnQnIG9iamVjdCBvZiB0aGUgbXVsdGktZm9udCBvcHRpb24uXG4gICAgICpcbiAgICAgKiAjIyMgU2VhcmNoIG9yZGVyIGZvciBtdWx0aS1mb250c1xuICAgICAqXG4gICAgICogJ2JvbGQnIHVzZWQgYXMgZXhhbXBsZTpcbiAgICAgKlxuICAgICAqICAgLSBzZWFyY2ggaW4gb3B0aW9uIGdyb3VwICdib2xkJyBpbiBsb2NhbCBwcm9wZXJ0aWVzXG4gICAgICogICAtIHNlYXJjaCBpbiBtYWluIGZvbnQgb3B0aW9uIGdyb3VwIGluIGxvY2FsIHByb3BlcnRpZXNcbiAgICAgKlxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQaWxlfSBwaWxlICBwaWxlIG9mIG9wdGlvbiBvYmplY3RzIHRvIHVzZVxuICAgICAqIEBwYXJhbSB7TXVsdGlGb250U3R5bGV9IG11bHRpTmFtZSBzdWIgcGF0aCBmb3IgdGhlIG11bHRpLWZvbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uICB0aGUgb3B0aW9uIHRvIHNlYXJjaCBmb3IsIGZvciB0aGUgZ2l2ZW4gbXVsdGktZm9udFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVtYmVyfSB0aGUgdmFsdWUgZm9yIHRoZSBnaXZlbiBvcHRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRGb250T3B0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Rm9udE9wdGlvbihwaWxlLCBtdWx0aU5hbWUsIG9wdGlvbikge1xuICAgICAgdmFyIG11bHRpRm9udCA9IHZvaWQgMDtcblxuICAgICAgLy8gU2VhcmNoIG11bHRpIGZvbnQgaW4gbG9jYWwgcHJvcGVydGllc1xuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBwaWxlLmxlbmd0aDsgKytuKSB7XG4gICAgICAgIHZhciBmb250T3B0aW9ucyA9IHBpbGVbbl07XG5cbiAgICAgICAgaWYgKGZvbnRPcHRpb25zLmhhc093blByb3BlcnR5KG11bHRpTmFtZSkpIHtcbiAgICAgICAgICBtdWx0aUZvbnQgPSBmb250T3B0aW9uc1ttdWx0aU5hbWVdO1xuICAgICAgICAgIGlmIChtdWx0aUZvbnQgPT09IHVuZGVmaW5lZCB8fCBtdWx0aUZvbnQgPT09IG51bGwpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgLy8gQ29udmVydCBzaG9ydGhhbmQgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgLy8gVE9ETzogaW5lZmZpY2llbnQgdG8gZG8gdGhpcyBjb252ZXJzaW9uIGV2ZXJ5IHRpbWU7IGZpbmQgYSBiZXR0ZXIgd2F5LlxuICAgICAgICAgIHZhciB0bXBTaG9ydGhhbmQgPSB7fTtcbiAgICAgICAgICBpZiAoTGFiZWwucGFyc2VGb250U3RyaW5nKHRtcFNob3J0aGFuZCwgbXVsdGlGb250KSkge1xuICAgICAgICAgICAgbXVsdGlGb250ID0gdG1wU2hvcnRoYW5kO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtdWx0aUZvbnQuaGFzT3duUHJvcGVydHkob3B0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIG11bHRpRm9udFtvcHRpb25dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBPcHRpb24gaXMgbm90IG1lbnRpb25lZCBpbiB0aGUgbXVsdGkgZm9udCBvcHRpb25zOyB0YWtlIGl0IGZyb20gdGhlIHBhcmVudCBmb250IG9wdGlvbnMuXG4gICAgICAvLyBUaGVzZSBoYXZlIGFscmVhZHkgYmVlbiBjb252ZXJ0ZWQgd2l0aCBnZXRCYXNpY09wdGlvbnMoKSwgc28gdXNlIHRoZSBjb252ZXJ0ZWQgdmFsdWVzLlxuICAgICAgaWYgKHRoaXMuZm9udE9wdGlvbnMuaGFzT3duUHJvcGVydHkob3B0aW9uKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mb250T3B0aW9uc1tvcHRpb25dO1xuICAgICAgfVxuXG4gICAgICAvLyBBIHZhbHVlICoqbXVzdCoqIGJlIGZvdW5kOyB5b3Ugc2hvdWxkIG5ldmVyIGdldCBoZXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlkIG5vdCBmaW5kIHZhbHVlIGZvciBtdWx0aS1mb250IGZvciBwcm9wZXJ0eTogJ1wiICsgb3B0aW9uICsgXCInXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbGwgb3B0aW9ucyB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBtdWx0aS1mb250LlxuICAgICAqXG4gICAgICogQWxsIGF2YWlsYWJsZSBvcHRpb24gb2JqZWN0cyBhcmUgdHJhd2xlZCBpbiB0aGUgc2V0IG9yZGVyIHRvIGNvbnN0cnVjdCB0aGUgb3B0aW9uIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGlsZX0gcGlsZSAgcGlsZSBvZiBvcHRpb24gb2JqZWN0cyB0byB1c2VcbiAgICAgKiBAcGFyYW0ge011bHRpRm9udFN0eWxlfSBtdWx0aU5hbWUgc3ViIHBhdGggZm9yIHRoZSBtb2QtZm9udFxuICAgICAqIEByZXR1cm5zIHtNdWx0aUZvbnRPcHRpb25zfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldEZvbnRPcHRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Rm9udE9wdGlvbnMocGlsZSwgbXVsdGlOYW1lKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICB2YXIgb3B0aW9uTmFtZXMgPSBbJ2NvbG9yJywgJ3NpemUnLCAnZmFjZScsICdtb2QnLCAndmFkanVzdCddOyAvLyBMaXN0IG9mIGFsbG93ZWQgb3B0aW9ucyBwZXIgbXVsdGktZm9udFxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbk5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBtb2QgPSBvcHRpb25OYW1lc1tpXTtcbiAgICAgICAgcmVzdWx0W21vZF0gPSB0aGlzLmdldEZvbnRPcHRpb24ocGlsZSwgbXVsdGlOYW1lLCBtb2QpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEVuZCBtZXRob2RzIGZvciBoYW5kbGluZyBvcHRpb25zIHBpbGVzXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAvKipcbiAgICAgKiBDb2xsYXBzZSB0aGUgZm9udCBvcHRpb25zIGZvciB0aGUgbXVsdGktZm9udCB0byBzaW5nbGUgb2JqZWN0cywgZnJvbVxuICAgICAqIHRoZSBjaGFpbiBvZiBvcHRpb24gb2JqZWN0cyBwYXNzZWQgKHRoZSAncGlsZScpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQaWxlfSBwaWxlICBzZXF1ZW5jZSBvZiBvcHRpb24gb2JqZWN0cyB0byBjb25zaWRlci5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIEZpcnN0IGl0ZW0gaW4gbGlzdCBhc3N1bWVkIHRvIGJlIHRoZSBuZXdseSBzZXQgb3B0aW9ucy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJvcGFnYXRlRm9udHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9wYWdhdGVGb250cyhwaWxlKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGZvbnRQaWxlID0gW107IC8vIHNlcXVlbmNlIG9mIGZvbnQgb2JqZWN0cyB0byBjb25zaWRlciwgb3JkZXIgaW1wb3J0YW50XG5cbiAgICAgIC8vIE5vdGUgdGhhdCB0aGlzLmVsZW1lbnRPcHRpb25zIGlzIG5vdCB1c2VkIGhlcmUuXG4gICAgICB0aGlzLmFkZEZvbnRPcHRpb25zVG9QaWxlKGZvbnRQaWxlLCBwaWxlKTtcbiAgICAgIHRoaXMuZm9udE9wdGlvbnMgPSB0aGlzLmdldEJhc2ljT3B0aW9ucyhmb250UGlsZSk7XG5cbiAgICAgIC8vIFdlIHNldCBtdWx0aWZvbnQgdmFsdWVzIGV2ZW4gaWYgbXVsdGkgPT09IGZhbHNlLCBmb3IgY29uc2lzdGVuY3kgKHRoaW5ncyBicmVhayBvdGhlcndpc2UpXG5cbiAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGkpIHtcbiAgICAgICAgdmFyIG1vZCA9IG11bHRpRm9udFN0eWxlW2ldO1xuICAgICAgICB2YXIgbW9kT3B0aW9ucyA9IF90aGlzMi5mb250T3B0aW9uc1ttb2RdO1xuICAgICAgICB2YXIgdG1wTXVsdGlGb250T3B0aW9ucyA9IF90aGlzMi5nZXRGb250T3B0aW9ucyhmb250UGlsZSwgbW9kKTtcblxuICAgICAgICAvLyBDb3B5IG92ZXIgZm91bmQgdmFsdWVzXG4gICAgICAgIHV0aWwuZm9yRWFjaCh0bXBNdWx0aUZvbnRPcHRpb25zLCBmdW5jdGlvbiAob3B0aW9uLCBuKSB7XG4gICAgICAgICAgbW9kT3B0aW9uc1tuXSA9IG9wdGlvbjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbW9kT3B0aW9ucy5zaXplID0gTnVtYmVyKG1vZE9wdGlvbnMuc2l6ZSk7XG4gICAgICAgIG1vZE9wdGlvbnMudmFkanVzdCA9IE51bWJlcihtb2RPcHRpb25zLnZhZGp1c3QpO1xuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtdWx0aUZvbnRTdHlsZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBfbG9vcChpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYWluIGZ1bmN0aW9uLiBUaGlzIGlzIGNhbGxlZCBmcm9tIGFueXRoaW5nIHRoYXQgd2FudHMgdG8gZHJhdyBhIGxhYmVsLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2Jhc2VsaW5lPSdtaWRkbGUnXVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkcmF3JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgdmFyIGJhc2VsaW5lID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiAnbWlkZGxlJztcblxuICAgICAgLy8gaWYgbm8gbGFiZWwsIHJldHVyblxuICAgICAgaWYgKHRoaXMuZWxlbWVudE9wdGlvbnMubGFiZWwgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgICAvLyBjaGVjayBpZiB3ZSBoYXZlIHRvIHJlbmRlciB0aGUgbGFiZWxcbiAgICAgIHZhciB2aWV3Rm9udFNpemUgPSB0aGlzLmZvbnRPcHRpb25zLnNpemUgKiB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgIGlmICh0aGlzLmVsZW1lbnRPcHRpb25zLmxhYmVsICYmIHZpZXdGb250U2l6ZSA8IHRoaXMuZWxlbWVudE9wdGlvbnMuc2NhbGluZy5sYWJlbC5kcmF3VGhyZXNob2xkIC0gMSkgcmV0dXJuO1xuXG4gICAgICAvLyBUaGlzIGVuc3VyZXMgdGhhdCB0aGVyZSB3aWxsIG5vdCBiZSBIVUdFIGxldHRlcnMgb24gc2NyZWVuXG4gICAgICAvLyBieSBzZXR0aW5nIGFuIHVwcGVyIGxpbWl0IG9uIHRoZSB2aXNpYmxlIHRleHQgc2l6ZSAocmVnYXJkbGVzcyBvZiB6b29tTGV2ZWwpXG4gICAgICBpZiAodmlld0ZvbnRTaXplID49IHRoaXMuZWxlbWVudE9wdGlvbnMuc2NhbGluZy5sYWJlbC5tYXhWaXNpYmxlKSB7XG4gICAgICAgIHZpZXdGb250U2l6ZSA9IE51bWJlcih0aGlzLmVsZW1lbnRPcHRpb25zLnNjYWxpbmcubGFiZWwubWF4VmlzaWJsZSkgLyB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgIH1cblxuICAgICAgLy8gdXBkYXRlIHRoZSBzaXplIGNhY2hlIGlmIHJlcXVpcmVkXG4gICAgICB0aGlzLmNhbGN1bGF0ZUxhYmVsU2l6ZShjdHgsIHNlbGVjdGVkLCBob3ZlciwgeCwgeSwgYmFzZWxpbmUpO1xuICAgICAgdGhpcy5fZHJhd0JhY2tncm91bmQoY3R4KTtcbiAgICAgIHRoaXMuX2RyYXdUZXh0KGN0eCwgeCwgdGhpcy5zaXplLnlMaW5lLCBiYXNlbGluZSwgdmlld0ZvbnRTaXplKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgbGFiZWwgYmFja2dyb3VuZFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZHJhd0JhY2tncm91bmQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd0JhY2tncm91bmQoY3R4KSB7XG4gICAgICBpZiAodGhpcy5mb250T3B0aW9ucy5iYWNrZ3JvdW5kICE9PSB1bmRlZmluZWQgJiYgdGhpcy5mb250T3B0aW9ucy5iYWNrZ3JvdW5kICE9PSAnbm9uZScpIHtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuZm9udE9wdGlvbnMuYmFja2dyb3VuZDtcbiAgICAgICAgdmFyIHNpemUgPSB0aGlzLmdldFNpemUoKTtcbiAgICAgICAgY3R4LmZpbGxSZWN0KHNpemUubGVmdCwgc2l6ZS50b3AsIHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtiYXNlbGluZT0nbWlkZGxlJ11cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmlld0ZvbnRTaXplXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2RyYXdUZXh0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdUZXh0KGN0eCwgeCwgeSkge1xuICAgICAgdmFyIGJhc2VsaW5lID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAnbWlkZGxlJztcbiAgICAgIHZhciB2aWV3Rm9udFNpemUgPSBhcmd1bWVudHNbNF07XG5cbiAgICAgIDtcbiAgICAgIHZhciBfc2V0QWxpZ25tZW50MiA9IHRoaXMuX3NldEFsaWdubWVudChjdHgsIHgsIHksIGJhc2VsaW5lKTtcblxuICAgICAgdmFyIF9zZXRBbGlnbm1lbnQzID0gKDAsIF9zbGljZWRUb0FycmF5M1snZGVmYXVsdCddKShfc2V0QWxpZ25tZW50MiwgMik7XG5cbiAgICAgIHggPSBfc2V0QWxpZ25tZW50M1swXTtcbiAgICAgIHkgPSBfc2V0QWxpZ25tZW50M1sxXTtcblxuXG4gICAgICBjdHgudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgeCA9IHggLSB0aGlzLnNpemUud2lkdGggLyAyOyAvLyBTaGlmdCBsYWJlbCAxLzItZGlzdGFuY2UgdG8gdGhlIGxlZnRcbiAgICAgIGlmICh0aGlzLmZvbnRPcHRpb25zLnZhbGlnbiAmJiB0aGlzLnNpemUuaGVpZ2h0ID4gdGhpcy5zaXplLmxhYmVsSGVpZ2h0KSB7XG4gICAgICAgIGlmICh0aGlzLmZvbnRPcHRpb25zLnZhbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICB5IC09ICh0aGlzLnNpemUuaGVpZ2h0IC0gdGhpcy5zaXplLmxhYmVsSGVpZ2h0KSAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZm9udE9wdGlvbnMudmFsaWduID09PSAnYm90dG9tJykge1xuICAgICAgICAgIHkgKz0gKHRoaXMuc2l6ZS5oZWlnaHQgLSB0aGlzLnNpemUubGFiZWxIZWlnaHQpIC8gMjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBkcmF3IHRoZSB0ZXh0XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGluZUNvdW50OyBpKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmxpbmVzW2ldO1xuICAgICAgICBpZiAobGluZSAmJiBsaW5lLmJsb2Nrcykge1xuICAgICAgICAgIHZhciB3aWR0aCA9IDA7XG4gICAgICAgICAgaWYgKHRoaXMuaXNFZGdlTGFiZWwgfHwgdGhpcy5mb250T3B0aW9ucy5hbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIHdpZHRoICs9ICh0aGlzLnNpemUud2lkdGggLSBsaW5lLndpZHRoKSAvIDI7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmZvbnRPcHRpb25zLmFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICB3aWR0aCArPSB0aGlzLnNpemUud2lkdGggLSBsaW5lLndpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxpbmUuYmxvY2tzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgYmxvY2sgPSBsaW5lLmJsb2Nrc1tqXTtcbiAgICAgICAgICAgIGN0eC5mb250ID0gYmxvY2suZm9udDtcblxuICAgICAgICAgICAgdmFyIF9nZXRDb2xvcjIgPSB0aGlzLl9nZXRDb2xvcihibG9jay5jb2xvciwgdmlld0ZvbnRTaXplLCBibG9jay5zdHJva2VDb2xvciksXG4gICAgICAgICAgICAgICAgX2dldENvbG9yMyA9ICgwLCBfc2xpY2VkVG9BcnJheTNbJ2RlZmF1bHQnXSkoX2dldENvbG9yMiwgMiksXG4gICAgICAgICAgICAgICAgZm9udENvbG9yID0gX2dldENvbG9yM1swXSxcbiAgICAgICAgICAgICAgICBzdHJva2VDb2xvciA9IF9nZXRDb2xvcjNbMV07XG5cbiAgICAgICAgICAgIGlmIChibG9jay5zdHJva2VXaWR0aCA+IDApIHtcbiAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGJsb2NrLnN0cm9rZVdpZHRoO1xuICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2VDb2xvcjtcbiAgICAgICAgICAgICAgY3R4LmxpbmVKb2luID0gJ3JvdW5kJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBmb250Q29sb3I7XG5cbiAgICAgICAgICAgIGlmIChibG9jay5zdHJva2VXaWR0aCA+IDApIHtcbiAgICAgICAgICAgICAgY3R4LnN0cm9rZVRleHQoYmxvY2sudGV4dCwgeCArIHdpZHRoLCB5ICsgYmxvY2sudmFkanVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguZmlsbFRleHQoYmxvY2sudGV4dCwgeCArIHdpZHRoLCB5ICsgYmxvY2sudmFkanVzdCk7XG4gICAgICAgICAgICB3aWR0aCArPSBibG9jay53aWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgeSArPSBsaW5lLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmFzZWxpbmVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3NldEFsaWdubWVudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRBbGlnbm1lbnQoY3R4LCB4LCB5LCBiYXNlbGluZSkge1xuICAgICAgLy8gY2hlY2sgZm9yIGxhYmVsIGFsaWdubWVudCAoZm9yIGVkZ2VzKVxuICAgICAgLy8gVE9ETzogbWFrZSBhbGlnbm1lbnQgZm9yIG5vZGVzXG4gICAgICBpZiAodGhpcy5pc0VkZ2VMYWJlbCAmJiB0aGlzLmZvbnRPcHRpb25zLmFsaWduICE9PSAnaG9yaXpvbnRhbCcgJiYgdGhpcy5wb2ludFRvU2VsZiA9PT0gZmFsc2UpIHtcbiAgICAgICAgeCA9IDA7XG4gICAgICAgIHkgPSAwO1xuXG4gICAgICAgIHZhciBsaW5lTWFyZ2luID0gMjtcbiAgICAgICAgaWYgKHRoaXMuZm9udE9wdGlvbnMuYWxpZ24gPT09ICd0b3AnKSB7XG4gICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdhbHBoYWJldGljJztcbiAgICAgICAgICB5IC09IDIgKiBsaW5lTWFyZ2luOyAvLyBkaXN0YW5jZSBmcm9tIGVkZ2UsIHJlcXVpcmVkIGJlY2F1c2Ugd2UgdXNlIGFscGhhYmV0aWMuIEFscGhhYmV0aWMgaGFzIGxlc3MgZGlmZmVyZW5jZSBiZXR3ZWVuIGJyb3dzZXJzXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5mb250T3B0aW9ucy5hbGlnbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ2hhbmdpbmcnO1xuICAgICAgICAgIHkgKz0gMiAqIGxpbmVNYXJnaW47IC8vIGRpc3RhbmNlIGZyb20gZWRnZSwgcmVxdWlyZWQgYmVjYXVzZSB3ZSB1c2UgaGFuZ2luZy4gSGFuZ2luZyBoYXMgbGVzcyBkaWZmZXJlbmNlIGJldHdlZW4gYnJvd3NlcnNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBiYXNlbGluZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbeCwgeV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZmFkZSBpbiB3aGVuIHJlbGF0aXZlIHNjYWxlIGlzIGJldHdlZW4gdGhyZXNob2xkIGFuZCB0aHJlc2hvbGQgLSAxLlxuICAgICAqIElmIHRoZSByZWxhdGl2ZSBzY2FsZSB3b3VsZCBiZSBzbWFsbGVyIHRoYW4gdGhyZXNob2xkIC0xIHRoZSBkcmF3IGZ1bmN0aW9uIHdvdWxkIGhhdmUgcmV0dXJuZWQgYmVmb3JlIGNvbWluZyBoZXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yICBUaGUgZm9udCBjb2xvciB0byB1c2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmlld0ZvbnRTaXplXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGluaXRpYWxTdHJva2VDb2xvclxuICAgICAqIEByZXR1cm5zIHtBcnJheS48c3RyaW5nPn0gQW4gYXJyYXkgY29udGFpbmluZyB0aGUgZm9udCBjb2xvciBhbmQgc3Ryb2tlIGNvbG9yXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2dldENvbG9yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldENvbG9yKGNvbG9yLCB2aWV3Rm9udFNpemUsIGluaXRpYWxTdHJva2VDb2xvcikge1xuICAgICAgdmFyIGZvbnRDb2xvciA9IGNvbG9yIHx8ICcjMDAwMDAwJztcbiAgICAgIHZhciBzdHJva2VDb2xvciA9IGluaXRpYWxTdHJva2VDb2xvciB8fCAnI2ZmZmZmZic7XG4gICAgICBpZiAodmlld0ZvbnRTaXplIDw9IHRoaXMuZWxlbWVudE9wdGlvbnMuc2NhbGluZy5sYWJlbC5kcmF3VGhyZXNob2xkKSB7XG4gICAgICAgIHZhciBvcGFjaXR5ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgMSAtICh0aGlzLmVsZW1lbnRPcHRpb25zLnNjYWxpbmcubGFiZWwuZHJhd1RocmVzaG9sZCAtIHZpZXdGb250U2l6ZSkpKTtcbiAgICAgICAgZm9udENvbG9yID0gdXRpbC5vdmVycmlkZU9wYWNpdHkoZm9udENvbG9yLCBvcGFjaXR5KTtcbiAgICAgICAgc3Ryb2tlQ29sb3IgPSB1dGlsLm92ZXJyaWRlT3BhY2l0eShzdHJva2VDb2xvciwgb3BhY2l0eSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW2ZvbnRDb2xvciwgc3Ryb2tlQ29sb3JdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHJldHVybnMge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldFRleHRTaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGV4dFNpemUoY3R4KSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgdmFyIGhvdmVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICAgICAgdGhpcy5fcHJvY2Vzc0xhYmVsKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiB0aGlzLnNpemUud2lkdGgsXG4gICAgICAgIGhlaWdodDogdGhpcy5zaXplLmhlaWdodCxcbiAgICAgICAgbGluZUNvdW50OiB0aGlzLmxpbmVDb3VudFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgZGltZW5zaW9ucyBvZiB0aGUgbGFiZWxcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3JlY3R9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldFNpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTaXplKCkge1xuICAgICAgdmFyIGxpbmVNYXJnaW4gPSAyO1xuICAgICAgdmFyIHggPSB0aGlzLnNpemUubGVmdDsgLy8gZGVmYXVsdCB2YWx1ZXMgd2hpY2ggbWlnaHQgYmUgb3ZlcnJpZGRlbiBiZWxvd1xuICAgICAgdmFyIHkgPSB0aGlzLnNpemUudG9wIC0gMC41ICogbGluZU1hcmdpbjsgLy8gaWRlbVxuXG4gICAgICBpZiAodGhpcy5pc0VkZ2VMYWJlbCkge1xuICAgICAgICB2YXIgeDIgPSAtdGhpcy5zaXplLndpZHRoICogMC41O1xuXG4gICAgICAgIHN3aXRjaCAodGhpcy5mb250T3B0aW9ucy5hbGlnbikge1xuICAgICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgICB4ID0geDI7XG4gICAgICAgICAgICB5ID0gLXRoaXMuc2l6ZS5oZWlnaHQgKiAwLjU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgeCA9IHgyO1xuICAgICAgICAgICAgeSA9IC0odGhpcy5zaXplLmhlaWdodCArIGxpbmVNYXJnaW4pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgIHggPSB4MjtcbiAgICAgICAgICAgIHkgPSBsaW5lTWFyZ2luO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgbGVmdDogeCxcbiAgICAgICAgdG9wOiB5LFxuICAgICAgICB3aWR0aDogdGhpcy5zaXplLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuc2l6ZS5oZWlnaHRcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3g9MF1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3k9MF1cbiAgICAgKiBAcGFyYW0geydtaWRkbGUnfCdoYW5naW5nJ30gW2Jhc2VsaW5lPSdtaWRkbGUnXVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdjYWxjdWxhdGVMYWJlbFNpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVMYWJlbFNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgIHZhciB4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAwO1xuICAgICAgdmFyIHkgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IDA7XG4gICAgICB2YXIgYmFzZWxpbmUgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6ICdtaWRkbGUnO1xuXG4gICAgICB0aGlzLl9wcm9jZXNzTGFiZWwoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgdGhpcy5zaXplLmxlZnQgPSB4IC0gdGhpcy5zaXplLndpZHRoICogMC41O1xuICAgICAgdGhpcy5zaXplLnRvcCA9IHkgLSB0aGlzLnNpemUuaGVpZ2h0ICogMC41O1xuICAgICAgdGhpcy5zaXplLnlMaW5lID0geSArICgxIC0gdGhpcy5saW5lQ291bnQpICogMC41ICogdGhpcy5mb250T3B0aW9ucy5zaXplO1xuICAgICAgaWYgKGJhc2VsaW5lID09PSAnaGFuZ2luZycpIHtcbiAgICAgICAgdGhpcy5zaXplLnRvcCArPSAwLjUgKiB0aGlzLmZvbnRPcHRpb25zLnNpemU7XG4gICAgICAgIHRoaXMuc2l6ZS50b3AgKz0gNDsgLy8gZGlzdGFuY2UgZnJvbSBub2RlLCByZXF1aXJlZCBiZWNhdXNlIHdlIHVzZSBoYW5naW5nLiBIYW5naW5nIGhhcyBsZXNzIGRpZmZlcmVuY2UgYmV0d2VlbiBicm93c2Vyc1xuICAgICAgICB0aGlzLnNpemUueUxpbmUgKz0gNDsgLy8gZGlzdGFuY2UgZnJvbSBub2RlXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kXG4gICAgICogQHJldHVybnMge3tjb2xvciwgc2l6ZSwgZmFjZSwgbW9kLCB2YWRqdXN0LCBzdHJva2VXaWR0aDogKiwgc3Ryb2tlQ29sb3I6ICgqfHN0cmluZ3xhbGxPcHRpb25zLmVkZ2VzLmZvbnQuc3Ryb2tlQ29sb3J8e3N0cmluZ318YWxsT3B0aW9ucy5ub2Rlcy5mb250LnN0cm9rZUNvbG9yfEFycmF5KX19XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldEZvcm1hdHRpbmdWYWx1ZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGb3JtYXR0aW5nVmFsdWVzKGN0eCwgc2VsZWN0ZWQsIGhvdmVyLCBtb2QpIHtcbiAgICAgIHZhciBnZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlKGZvbnRPcHRpb25zLCBtb2QsIG9wdGlvbikge1xuICAgICAgICBpZiAobW9kID09PSAnbm9ybWFsJykge1xuICAgICAgICAgIGlmIChvcHRpb24gPT09ICdtb2QnKSByZXR1cm4gJyc7XG4gICAgICAgICAgcmV0dXJuIGZvbnRPcHRpb25zW29wdGlvbl07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm9udE9wdGlvbnNbbW9kXVtvcHRpb25dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBHcnVtYmwgbGVhdmluZyBvdXQgdGVzdCBvbiB1bmRlZmluZWQgZXF1YWxzIGZhbHNlIGZvciBcIlwiXG4gICAgICAgICAgcmV0dXJuIGZvbnRPcHRpb25zW21vZF1bb3B0aW9uXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUYWtlIGZyb20gcGFyZW50IGZvbnQgb3B0aW9uXG4gICAgICAgICAgcmV0dXJuIGZvbnRPcHRpb25zW29wdGlvbl07XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciB2YWx1ZXMgPSB7XG4gICAgICAgIGNvbG9yOiBnZXRWYWx1ZSh0aGlzLmZvbnRPcHRpb25zLCBtb2QsICdjb2xvcicpLFxuICAgICAgICBzaXplOiBnZXRWYWx1ZSh0aGlzLmZvbnRPcHRpb25zLCBtb2QsICdzaXplJyksXG4gICAgICAgIGZhY2U6IGdldFZhbHVlKHRoaXMuZm9udE9wdGlvbnMsIG1vZCwgJ2ZhY2UnKSxcbiAgICAgICAgbW9kOiBnZXRWYWx1ZSh0aGlzLmZvbnRPcHRpb25zLCBtb2QsICdtb2QnKSxcbiAgICAgICAgdmFkanVzdDogZ2V0VmFsdWUodGhpcy5mb250T3B0aW9ucywgbW9kLCAndmFkanVzdCcpLFxuICAgICAgICBzdHJva2VXaWR0aDogdGhpcy5mb250T3B0aW9ucy5zdHJva2VXaWR0aCxcbiAgICAgICAgc3Ryb2tlQ29sb3I6IHRoaXMuZm9udE9wdGlvbnMuc3Ryb2tlQ29sb3JcbiAgICAgIH07XG4gICAgICBpZiAoc2VsZWN0ZWQgfHwgaG92ZXIpIHtcbiAgICAgICAgaWYgKG1vZCA9PT0gJ25vcm1hbCcgJiYgdGhpcy5mb250T3B0aW9ucy5jaG9vc2VyID09PSB0cnVlICYmIHRoaXMuZWxlbWVudE9wdGlvbnMubGFiZWxIaWdobGlnaHRCb2xkKSB7XG4gICAgICAgICAgdmFsdWVzLm1vZCA9ICdib2xkJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuZm9udE9wdGlvbnMuY2hvb3NlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5mb250T3B0aW9ucy5jaG9vc2VyKHZhbHVlcywgdGhpcy5lbGVtZW50T3B0aW9ucy5pZCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGZvbnRTdHJpbmcgPSAnJztcbiAgICAgIGlmICh2YWx1ZXMubW9kICE9PSB1bmRlZmluZWQgJiYgdmFsdWVzLm1vZCAhPT0gJycpIHtcbiAgICAgICAgLy8gc2FmZWd1YXJkIGZvciB1bmRlZmluZWQgLSB0aGlzIGhhcHBlbmVkXG4gICAgICAgIGZvbnRTdHJpbmcgKz0gdmFsdWVzLm1vZCArICcgJztcbiAgICAgIH1cbiAgICAgIGZvbnRTdHJpbmcgKz0gdmFsdWVzLnNpemUgKyAncHggJyArIHZhbHVlcy5mYWNlO1xuXG4gICAgICBjdHguZm9udCA9IGZvbnRTdHJpbmcucmVwbGFjZSgvXCIvZywgJycpO1xuICAgICAgdmFsdWVzLmZvbnQgPSBjdHguZm9udDtcbiAgICAgIHZhbHVlcy5oZWlnaHQgPSB2YWx1ZXMuc2l6ZTtcbiAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkaWZmZXJlbnRTdGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpZmZlcmVudFN0YXRlKHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgcmV0dXJuIHNlbGVjdGVkICE9PSB0aGlzLnNlbGVjdGVkU3RhdGUgfHwgaG92ZXIgIT09IHRoaXMuaG92ZXJTdGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGV4cGxvZGVzIHRoZSBwYXNzZWQgdGV4dCBpbnRvIGxpbmVzIGFuZCBkZXRlcm1pbmVzIHRoZSB3aWR0aCwgaGVpZ2h0IGFuZCBudW1iZXIgb2YgbGluZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5UZXh0ICB0aGUgdGV4dCB0byBleHBsb2RlXG4gICAgICogQHJldHVybnMge3t3aWR0aCwgaGVpZ2h0LCBsaW5lc318Kn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfcHJvY2Vzc0xhYmVsVGV4dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wcm9jZXNzTGFiZWxUZXh0KGN0eCwgc2VsZWN0ZWQsIGhvdmVyLCBpblRleHQpIHtcbiAgICAgIHZhciBzcGxpdHRlciA9IG5ldyBMYWJlbFNwbGl0dGVyKGN0eCwgdGhpcywgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIHJldHVybiBzcGxpdHRlci5wcm9jZXNzKGluVGV4dCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBleHBsb2RlcyB0aGUgbGFiZWwgc3RyaW5nIGludG8gbGluZXMgYW5kIHNldHMgdGhlIHdpZHRoLCBoZWlnaHQgYW5kIG51bWJlciBvZiBsaW5lcy5cbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfcHJvY2Vzc0xhYmVsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Byb2Nlc3NMYWJlbChjdHgsIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgaWYgKHRoaXMubGFiZWxEaXJ0eSA9PT0gZmFsc2UgJiYgIXRoaXMuZGlmZmVyZW50U3RhdGUoc2VsZWN0ZWQsIGhvdmVyKSkgcmV0dXJuO1xuXG4gICAgICB2YXIgc3RhdGUgPSB0aGlzLl9wcm9jZXNzTGFiZWxUZXh0KGN0eCwgc2VsZWN0ZWQsIGhvdmVyLCB0aGlzLmVsZW1lbnRPcHRpb25zLmxhYmVsKTtcblxuICAgICAgaWYgKHRoaXMuZm9udE9wdGlvbnMubWluV2R0ID4gMCAmJiBzdGF0ZS53aWR0aCA8IHRoaXMuZm9udE9wdGlvbnMubWluV2R0KSB7XG4gICAgICAgIHN0YXRlLndpZHRoID0gdGhpcy5mb250T3B0aW9ucy5taW5XZHQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2l6ZS5sYWJlbEhlaWdodCA9IHN0YXRlLmhlaWdodDtcbiAgICAgIGlmICh0aGlzLmZvbnRPcHRpb25zLm1pbkhndCA+IDAgJiYgc3RhdGUuaGVpZ2h0IDwgdGhpcy5mb250T3B0aW9ucy5taW5IZ3QpIHtcbiAgICAgICAgc3RhdGUuaGVpZ2h0ID0gdGhpcy5mb250T3B0aW9ucy5taW5IZ3Q7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGluZXMgPSBzdGF0ZS5saW5lcztcbiAgICAgIHRoaXMubGluZUNvdW50ID0gc3RhdGUubGluZXMubGVuZ3RoO1xuICAgICAgdGhpcy5zaXplLndpZHRoID0gc3RhdGUud2lkdGg7XG4gICAgICB0aGlzLnNpemUuaGVpZ2h0ID0gc3RhdGUuaGVpZ2h0O1xuICAgICAgdGhpcy5zZWxlY3RlZFN0YXRlID0gc2VsZWN0ZWQ7XG4gICAgICB0aGlzLmhvdmVyU3RhdGUgPSBob3ZlcjtcblxuICAgICAgdGhpcy5sYWJlbERpcnR5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhpcyBsYWJlbCBpcyB2aXNpYmxlXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoaXMgbGFiZWwgd2lsbCBiZSBzaG93LCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndmlzaWJsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZpc2libGUoKSB7XG4gICAgICBpZiAodGhpcy5zaXplLndpZHRoID09PSAwIHx8IHRoaXMuc2l6ZS5oZWlnaHQgPT09IDAgfHwgdGhpcy5lbGVtZW50T3B0aW9ucy5sYWJlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gbm90aGluZyB0byBkaXNwbGF5XG4gICAgICB9XG5cbiAgICAgIHZhciB2aWV3Rm9udFNpemUgPSB0aGlzLmZvbnRPcHRpb25zLnNpemUgKiB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgIGlmICh2aWV3Rm9udFNpemUgPCB0aGlzLmVsZW1lbnRPcHRpb25zLnNjYWxpbmcubGFiZWwuZHJhd1RocmVzaG9sZCAtIDEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBUb28gc21hbGwgb3IgdG9vIGZhciBhd2F5IHRvIHNob3dcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6ICdwYXJzZUZvbnRTdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZUZvbnRTdHJpbmcob3V0T3B0aW9ucywgaW5PcHRpb25zKSB7XG4gICAgICBpZiAoIWluT3B0aW9ucyB8fCB0eXBlb2YgaW5PcHRpb25zICE9PSAnc3RyaW5nJykgcmV0dXJuIGZhbHNlO1xuXG4gICAgICB2YXIgbmV3T3B0aW9uc0FycmF5ID0gaW5PcHRpb25zLnNwbGl0KCcgJyk7XG5cbiAgICAgIG91dE9wdGlvbnMuc2l6ZSA9IG5ld09wdGlvbnNBcnJheVswXS5yZXBsYWNlKCdweCcsICcnKTtcbiAgICAgIG91dE9wdGlvbnMuZmFjZSA9IG5ld09wdGlvbnNBcnJheVsxXTtcbiAgICAgIG91dE9wdGlvbnMuY29sb3IgPSBuZXdPcHRpb25zQXJyYXlbMl07XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTGFiZWw7XG59KCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IExhYmVsO1xuXG4vKioqLyB9KSxcbi8qIDc4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogX193ZWJwYWNrX3JlcXVpcmVfXygxNDEpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cbi8qKiovIH0pLFxuLyogNzkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9zbGljZWRUb0FycmF5MiA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2xpY2VkVG9BcnJheTIpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xudmFyIEVuZFBvaW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oODApWydkZWZhdWx0J107XG5cbi8qKlxuICogVGhlIEJhc2UgQ2xhc3MgZm9yIGFsbCBlZGdlcy5cbiAqXG4gKi9cblxudmFyIEVkZ2VCYXNlID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICovXG4gIGZ1bmN0aW9uIEVkZ2VCYXNlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgRWRnZUJhc2UpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLmxhYmVsTW9kdWxlID0gbGFiZWxNb2R1bGU7XG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIHRoaXMuY29sb3JEaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5jb2xvciA9IHt9O1xuICAgIHRoaXMuc2VsZWN0aW9uV2lkdGggPSAyO1xuICAgIHRoaXMuaG92ZXJXaWR0aCA9IDEuNTtcbiAgICB0aGlzLmZyb21Qb2ludCA9IHRoaXMuZnJvbTtcbiAgICB0aGlzLnRvUG9pbnQgPSB0aGlzLnRvO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbm5lY3RzIGEgbm9kZSB0byBpdHNlbGZcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzM1snZGVmYXVsdCddKShFZGdlQmFzZSwgW3tcbiAgICBrZXk6ICdjb25uZWN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29ubmVjdCgpIHtcbiAgICAgIHRoaXMuZnJvbSA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLm9wdGlvbnMuZnJvbV07XG4gICAgICB0aGlzLnRvID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMub3B0aW9ucy50b107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYWx3YXlzIGZhbHNlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2NsZWFudXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0T3B0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIHRoaXMuZnJvbSA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLm9wdGlvbnMuZnJvbV07XG4gICAgICB0aGlzLnRvID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMub3B0aW9ucy50b107XG4gICAgICB0aGlzLmlkID0gdGhpcy5vcHRpb25zLmlkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZHJhdyBhIGVkZ2UgYXMgYSBsaW5lXG4gICAgICogRHJhdyB0aGlzIGVkZ2UgaW4gdGhlIGdpdmVuIGNhbnZhc1xuICAgICAqIFRoZSAyZCBjb250ZXh0IG9mIGEgSFRNTCBjYW52YXMgY2FuIGJlIHJldHJpZXZlZCBieSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICAgY3R4XG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge05vZGV9IHZpYU5vZGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkcmF3TGluZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdMaW5lKGN0eCwgdmFsdWVzLCBzZWxlY3RlZCwgaG92ZXIsIHZpYU5vZGUpIHtcbiAgICAgIC8vIHNldCBzdHlsZVxuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5nZXRDb2xvcihjdHgsIHZhbHVlcywgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSB2YWx1ZXMud2lkdGg7XG5cbiAgICAgIGlmICh2YWx1ZXMuZGFzaGVzICE9PSBmYWxzZSkge1xuICAgICAgICB0aGlzLl9kcmF3RGFzaGVkTGluZShjdHgsIHZhbHVlcywgdmlhTm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9kcmF3TGluZShjdHgsIHZhbHVlcywgdmlhTm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gICBjdHhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge05vZGV9IHZpYU5vZGVcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IFtmcm9tUG9pbnRdXG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBbdG9Qb2ludF1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZHJhd0xpbmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd0xpbmUoY3R4LCB2YWx1ZXMsIHZpYU5vZGUsIGZyb21Qb2ludCwgdG9Qb2ludCkge1xuICAgICAgaWYgKHRoaXMuZnJvbSAhPSB0aGlzLnRvKSB7XG4gICAgICAgIC8vIGRyYXcgbGluZVxuICAgICAgICB0aGlzLl9saW5lKGN0eCwgdmFsdWVzLCB2aWFOb2RlLCBmcm9tUG9pbnQsIHRvUG9pbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9nZXRDaXJjbGVEYXRhMiA9IHRoaXMuX2dldENpcmNsZURhdGEoY3R4KSxcbiAgICAgICAgICAgIF9nZXRDaXJjbGVEYXRhMyA9ICgwLCBfc2xpY2VkVG9BcnJheTNbJ2RlZmF1bHQnXSkoX2dldENpcmNsZURhdGEyLCAzKSxcbiAgICAgICAgICAgIHggPSBfZ2V0Q2lyY2xlRGF0YTNbMF0sXG4gICAgICAgICAgICB5ID0gX2dldENpcmNsZURhdGEzWzFdLFxuICAgICAgICAgICAgcmFkaXVzID0gX2dldENpcmNsZURhdGEzWzJdO1xuXG4gICAgICAgIHRoaXMuX2NpcmNsZShjdHgsIHZhbHVlcywgeCwgeSwgcmFkaXVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge05vZGV9IHZpYU5vZGVcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IFtmcm9tUG9pbnRdICBUT0RPOiBSZW1vdmUgaW4gbmV4dCBtYWpvciByZWxlYXNlXG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBbdG9Qb2ludF0gICAgVE9ETzogUmVtb3ZlIGluIG5leHQgbWFqb3IgcmVsZWFzZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19kcmF3RGFzaGVkTGluZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3RGFzaGVkTGluZShjdHgsIHZhbHVlcywgdmlhTm9kZSwgZnJvbVBvaW50LCB0b1BvaW50KSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICBjdHgubGluZUNhcCA9ICdyb3VuZCc7XG4gICAgICB2YXIgcGF0dGVybiA9IFs1LCA1XTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcy5kYXNoZXMpID09PSB0cnVlKSB7XG4gICAgICAgIHBhdHRlcm4gPSB2YWx1ZXMuZGFzaGVzO1xuICAgICAgfVxuXG4gICAgICAvLyBvbmx5IGZpcmVmb3ggYW5kIGNocm9tZSBzdXBwb3J0IHRoaXMgbWV0aG9kLCBlbHNlIHdlIHVzZSB0aGUgbGVnYWN5IG9uZS5cbiAgICAgIGlmIChjdHguc2V0TGluZURhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICAgIC8vIHNldCBkYXNoIHNldHRpbmdzIGZvciBjaHJvbWUgb3IgZmlyZWZveFxuICAgICAgICBjdHguc2V0TGluZURhc2gocGF0dGVybik7XG4gICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IDA7XG5cbiAgICAgICAgLy8gZHJhdyB0aGUgbGluZVxuICAgICAgICBpZiAodGhpcy5mcm9tICE9IHRoaXMudG8pIHtcbiAgICAgICAgICAvLyBkcmF3IGxpbmVcbiAgICAgICAgICB0aGlzLl9saW5lKGN0eCwgdmFsdWVzLCB2aWFOb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX2dldENpcmNsZURhdGE0ID0gdGhpcy5fZ2V0Q2lyY2xlRGF0YShjdHgpLFxuICAgICAgICAgICAgICBfZ2V0Q2lyY2xlRGF0YTUgPSAoMCwgX3NsaWNlZFRvQXJyYXkzWydkZWZhdWx0J10pKF9nZXRDaXJjbGVEYXRhNCwgMyksXG4gICAgICAgICAgICAgIHggPSBfZ2V0Q2lyY2xlRGF0YTVbMF0sXG4gICAgICAgICAgICAgIHkgPSBfZ2V0Q2lyY2xlRGF0YTVbMV0sXG4gICAgICAgICAgICAgIHJhZGl1cyA9IF9nZXRDaXJjbGVEYXRhNVsyXTtcblxuICAgICAgICAgIHRoaXMuX2NpcmNsZShjdHgsIHZhbHVlcywgeCwgeSwgcmFkaXVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlc3RvcmUgdGhlIGRhc2ggc2V0dGluZ3MuXG4gICAgICAgIGN0eC5zZXRMaW5lRGFzaChbMF0pO1xuICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSAwO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdW5zdXBwb3J0aW5nIHNtb290aCBsaW5lc1xuICAgICAgICBpZiAodGhpcy5mcm9tICE9IHRoaXMudG8pIHtcbiAgICAgICAgICAvLyBkcmF3IGxpbmVcbiAgICAgICAgICBjdHguZGFzaGVkTGluZSh0aGlzLmZyb20ueCwgdGhpcy5mcm9tLnksIHRoaXMudG8ueCwgdGhpcy50by55LCBwYXR0ZXJuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX2dldENpcmNsZURhdGE2ID0gdGhpcy5fZ2V0Q2lyY2xlRGF0YShjdHgpLFxuICAgICAgICAgICAgICBfZ2V0Q2lyY2xlRGF0YTcgPSAoMCwgX3NsaWNlZFRvQXJyYXkzWydkZWZhdWx0J10pKF9nZXRDaXJjbGVEYXRhNiwgMyksXG4gICAgICAgICAgICAgIF94ID0gX2dldENpcmNsZURhdGE3WzBdLFxuICAgICAgICAgICAgICBfeSA9IF9nZXRDaXJjbGVEYXRhN1sxXSxcbiAgICAgICAgICAgICAgX3JhZGl1cyA9IF9nZXRDaXJjbGVEYXRhN1syXTtcblxuICAgICAgICAgIHRoaXMuX2NpcmNsZShjdHgsIHZhbHVlcywgX3gsIF95LCBfcmFkaXVzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkcmF3IHNoYWRvdyBpZiBlbmFibGVkXG4gICAgICAgIHRoaXMuZW5hYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcblxuICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgLy8gZGlzYWJsZSBzaGFkb3dzIGZvciBvdGhlciBlbGVtZW50cy5cbiAgICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbmVhck5vZGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7e3g6IG51bWJlciwgeTogbnVtYmVyfX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZmluZEJvcmRlclBvc2l0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZEJvcmRlclBvc2l0aW9uKG5lYXJOb2RlLCBjdHgsIG9wdGlvbnMpIHtcbiAgICAgIGlmICh0aGlzLmZyb20gIT0gdGhpcy50bykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uKG5lYXJOb2RlLCBjdHgsIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbkNpcmNsZShuZWFyTm9kZSwgY3R4LCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcmV0dXJucyB7e2Zyb206ICh7eDogbnVtYmVyLCB5OiBudW1iZXIsIHQ6IG51bWJlcn18KiksIHRvOiAoe3g6IG51bWJlciwgeTogbnVtYmVyLCB0OiBudW1iZXJ9fCopfX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZmluZEJvcmRlclBvc2l0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRCb3JkZXJQb3NpdGlvbnMoY3R4KSB7XG4gICAgICB2YXIgZnJvbSA9IHt9O1xuICAgICAgdmFyIHRvID0ge307XG4gICAgICBpZiAodGhpcy5mcm9tICE9IHRoaXMudG8pIHtcbiAgICAgICAgZnJvbSA9IHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbih0aGlzLmZyb20sIGN0eCk7XG4gICAgICAgIHRvID0gdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uKHRoaXMudG8sIGN0eCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX2dldENpcmNsZURhdGEkc2xpY2UgPSB0aGlzLl9nZXRDaXJjbGVEYXRhKGN0eCkuc2xpY2UoMCwgMiksXG4gICAgICAgICAgICBfZ2V0Q2lyY2xlRGF0YSRzbGljZTIgPSAoMCwgX3NsaWNlZFRvQXJyYXkzWydkZWZhdWx0J10pKF9nZXRDaXJjbGVEYXRhJHNsaWNlLCAyKSxcbiAgICAgICAgICAgIHggPSBfZ2V0Q2lyY2xlRGF0YSRzbGljZTJbMF0sXG4gICAgICAgICAgICB5ID0gX2dldENpcmNsZURhdGEkc2xpY2UyWzFdO1xuXG4gICAgICAgIGZyb20gPSB0aGlzLl9maW5kQm9yZGVyUG9zaXRpb25DaXJjbGUodGhpcy5mcm9tLCBjdHgsIHtcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIHk6IHksXG4gICAgICAgICAgbG93OiAwLjI1LFxuICAgICAgICAgIGhpZ2g6IDAuNixcbiAgICAgICAgICBkaXJlY3Rpb246IC0xXG4gICAgICAgIH0pO1xuICAgICAgICB0byA9IHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbkNpcmNsZSh0aGlzLmZyb20sIGN0eCwge1xuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgeTogeSxcbiAgICAgICAgICBsb3c6IDAuNixcbiAgICAgICAgICBoaWdoOiAwLjgsXG4gICAgICAgICAgZGlyZWN0aW9uOiAxXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZnJvbTogZnJvbSwgdG86IHRvIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHJldHVybnMge0FycmF5LjxudW1iZXI+fSB4LCB5LCByYWRpdXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZ2V0Q2lyY2xlRGF0YScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDaXJjbGVEYXRhKGN0eCkge1xuICAgICAgdmFyIHggPSB2b2lkIDAsXG4gICAgICAgICAgeSA9IHZvaWQgMDtcbiAgICAgIHZhciBub2RlID0gdGhpcy5mcm9tO1xuICAgICAgdmFyIHJhZGl1cyA9IHRoaXMub3B0aW9ucy5zZWxmUmVmZXJlbmNlU2l6ZTtcblxuICAgICAgaWYgKGN0eCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChub2RlLnNoYXBlLndpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBub2RlLnNoYXBlLnJlc2l6ZShjdHgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGdldCBjaXJjbGUgY29vcmRpbmF0ZXNcbiAgICAgIGlmIChub2RlLnNoYXBlLndpZHRoID4gbm9kZS5zaGFwZS5oZWlnaHQpIHtcbiAgICAgICAgeCA9IG5vZGUueCArIG5vZGUuc2hhcGUud2lkdGggKiAwLjU7XG4gICAgICAgIHkgPSBub2RlLnkgLSByYWRpdXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0gbm9kZS54ICsgcmFkaXVzO1xuICAgICAgICB5ID0gbm9kZS55IC0gbm9kZS5zaGFwZS5oZWlnaHQgKiAwLjU7XG4gICAgICB9XG4gICAgICByZXR1cm4gW3gsIHksIHJhZGl1c107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgcG9pbnQgb24gYSBjaXJjbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwZXJjZW50YWdlIC0gVmFsdWUgYmV0d2VlbiAwIChsaW5lIHN0YXJ0KSBhbmQgMSAobGluZSBlbmQpXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBwb2ludFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19wb2ludE9uQ2lyY2xlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BvaW50T25DaXJjbGUoeCwgeSwgcmFkaXVzLCBwZXJjZW50YWdlKSB7XG4gICAgICB2YXIgYW5nbGUgPSBwZXJjZW50YWdlICogMiAqIE1hdGguUEk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4ICsgcmFkaXVzICogTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICB5OiB5IC0gcmFkaXVzICogTWF0aC5zaW4oYW5nbGUpXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gdXNlcyBiaW5hcnkgc2VhcmNoIHRvIGxvb2sgZm9yIHRoZSBwb2ludCB3aGVyZSB0aGUgY2lyY2xlIGNyb3NzZXMgdGhlIGJvcmRlciBvZiB0aGUgbm9kZS5cbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZmluZEJvcmRlclBvc2l0aW9uQ2lyY2xlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRCb3JkZXJQb3NpdGlvbkNpcmNsZShub2RlLCBjdHgsIG9wdGlvbnMpIHtcbiAgICAgIHZhciB4ID0gb3B0aW9ucy54O1xuICAgICAgdmFyIHkgPSBvcHRpb25zLnk7XG4gICAgICB2YXIgbG93ID0gb3B0aW9ucy5sb3c7XG4gICAgICB2YXIgaGlnaCA9IG9wdGlvbnMuaGlnaDtcbiAgICAgIHZhciBkaXJlY3Rpb24gPSBvcHRpb25zLmRpcmVjdGlvbjtcblxuICAgICAgdmFyIG1heEl0ZXJhdGlvbnMgPSAxMDtcbiAgICAgIHZhciBpdGVyYXRpb24gPSAwO1xuICAgICAgdmFyIHJhZGl1cyA9IHRoaXMub3B0aW9ucy5zZWxmUmVmZXJlbmNlU2l6ZTtcbiAgICAgIHZhciBwb3MgPSB2b2lkIDAsXG4gICAgICAgICAgYW5nbGUgPSB2b2lkIDAsXG4gICAgICAgICAgZGlzdGFuY2VUb0JvcmRlciA9IHZvaWQgMCxcbiAgICAgICAgICBkaXN0YW5jZVRvUG9pbnQgPSB2b2lkIDAsXG4gICAgICAgICAgZGlmZmVyZW5jZSA9IHZvaWQgMDtcbiAgICAgIHZhciB0aHJlc2hvbGQgPSAwLjA1O1xuICAgICAgdmFyIG1pZGRsZSA9IChsb3cgKyBoaWdoKSAqIDAuNTtcblxuICAgICAgd2hpbGUgKGxvdyA8PSBoaWdoICYmIGl0ZXJhdGlvbiA8IG1heEl0ZXJhdGlvbnMpIHtcbiAgICAgICAgbWlkZGxlID0gKGxvdyArIGhpZ2gpICogMC41O1xuXG4gICAgICAgIHBvcyA9IHRoaXMuX3BvaW50T25DaXJjbGUoeCwgeSwgcmFkaXVzLCBtaWRkbGUpO1xuICAgICAgICBhbmdsZSA9IE1hdGguYXRhbjIobm9kZS55IC0gcG9zLnksIG5vZGUueCAtIHBvcy54KTtcbiAgICAgICAgZGlzdGFuY2VUb0JvcmRlciA9IG5vZGUuZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICAgICAgZGlzdGFuY2VUb1BvaW50ID0gTWF0aC5zcXJ0KE1hdGgucG93KHBvcy54IC0gbm9kZS54LCAyKSArIE1hdGgucG93KHBvcy55IC0gbm9kZS55LCAyKSk7XG4gICAgICAgIGRpZmZlcmVuY2UgPSBkaXN0YW5jZVRvQm9yZGVyIC0gZGlzdGFuY2VUb1BvaW50O1xuICAgICAgICBpZiAoTWF0aC5hYnMoZGlmZmVyZW5jZSkgPCB0aHJlc2hvbGQpIHtcbiAgICAgICAgICBicmVhazsgLy8gZm91bmRcbiAgICAgICAgfSBlbHNlIGlmIChkaWZmZXJlbmNlID4gMCkge1xuICAgICAgICAgIC8vIGRpc3RhbmNlIHRvIG5vZGVzIGlzIGxhcmdlciB0aGFuIGRpc3RhbmNlIHRvIGJvcmRlciAtLT4gdCBuZWVkcyB0byBiZSBiaWdnZXIgaWYgd2UncmUgbG9va2luZyBhdCB0aGUgdG8gbm9kZS5cbiAgICAgICAgICBpZiAoZGlyZWN0aW9uID4gMCkge1xuICAgICAgICAgICAgbG93ID0gbWlkZGxlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoaWdoID0gbWlkZGxlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZGlyZWN0aW9uID4gMCkge1xuICAgICAgICAgICAgaGlnaCA9IG1pZGRsZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG93ID0gbWlkZGxlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpdGVyYXRpb24rKztcbiAgICAgIH1cbiAgICAgIHBvcy50ID0gbWlkZGxlO1xuXG4gICAgICByZXR1cm4gcG9zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbGluZSB3aWR0aCBvZiB0aGUgZWRnZS4gRGVwZW5kcyBvbiB3aWR0aCBhbmQgd2hldGhlciBvbmUgb2YgdGhlXG4gICAgICogY29ubmVjdGVkIG5vZGVzIGlzIHNlbGVjdGVkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHJldHVybnMge251bWJlcn0gd2lkdGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRMaW5lV2lkdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMaW5lV2lkdGgoc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICBpZiAoc2VsZWN0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMuc2VsZWN0aW9uV2lkdGgsIDAuMyAvIHRoaXMuYm9keS52aWV3LnNjYWxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChob3ZlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLmhvdmVyV2lkdGgsIDAuMyAvIHRoaXMuYm9keS52aWV3LnNjYWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5vcHRpb25zLndpZHRoLCAwLjMgLyB0aGlzLmJvZHkudmlldy5zY2FsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZCAtIFVudXNlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXIgLSBVbnVzZWRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRDb2xvcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbG9yKGN0eCwgdmFsdWVzLCBzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIGlmICh2YWx1ZXMuaW5oZXJpdHNDb2xvciAhPT0gZmFsc2UpIHtcbiAgICAgICAgLy8gd2hlbiB0aGlzIGlzIGEgbG9vcCBlZGdlLCBqdXN0IHVzZSB0aGUgJ2Zyb20nIG1ldGhvZFxuICAgICAgICBpZiAodmFsdWVzLmluaGVyaXRzQ29sb3IgPT09ICdib3RoJyAmJiB0aGlzLmZyb20uaWQgIT09IHRoaXMudG8uaWQpIHtcbiAgICAgICAgICB2YXIgZ3JkID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KHRoaXMuZnJvbS54LCB0aGlzLmZyb20ueSwgdGhpcy50by54LCB0aGlzLnRvLnkpO1xuICAgICAgICAgIHZhciBmcm9tQ29sb3IgPSB2b2lkIDAsXG4gICAgICAgICAgICAgIHRvQ29sb3IgPSB2b2lkIDA7XG4gICAgICAgICAgZnJvbUNvbG9yID0gdGhpcy5mcm9tLm9wdGlvbnMuY29sb3IuaGlnaGxpZ2h0LmJvcmRlcjtcbiAgICAgICAgICB0b0NvbG9yID0gdGhpcy50by5vcHRpb25zLmNvbG9yLmhpZ2hsaWdodC5ib3JkZXI7XG5cbiAgICAgICAgICBpZiAodGhpcy5mcm9tLnNlbGVjdGVkID09PSBmYWxzZSAmJiB0aGlzLnRvLnNlbGVjdGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZnJvbUNvbG9yID0gdXRpbC5vdmVycmlkZU9wYWNpdHkodGhpcy5mcm9tLm9wdGlvbnMuY29sb3IuYm9yZGVyLCB2YWx1ZXMub3BhY2l0eSk7XG4gICAgICAgICAgICB0b0NvbG9yID0gdXRpbC5vdmVycmlkZU9wYWNpdHkodGhpcy50by5vcHRpb25zLmNvbG9yLmJvcmRlciwgdmFsdWVzLm9wYWNpdHkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5mcm9tLnNlbGVjdGVkID09PSB0cnVlICYmIHRoaXMudG8uc2VsZWN0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0b0NvbG9yID0gdGhpcy50by5vcHRpb25zLmNvbG9yLmJvcmRlcjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZnJvbS5zZWxlY3RlZCA9PT0gZmFsc2UgJiYgdGhpcy50by5zZWxlY3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgZnJvbUNvbG9yID0gdGhpcy5mcm9tLm9wdGlvbnMuY29sb3IuYm9yZGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBncmQuYWRkQ29sb3JTdG9wKDAsIGZyb21Db2xvcik7XG4gICAgICAgICAgZ3JkLmFkZENvbG9yU3RvcCgxLCB0b0NvbG9yKTtcblxuICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tIHRoaXMgcmV0dXJucyAtLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuICAgICAgICAgIHJldHVybiBncmQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWVzLmluaGVyaXRzQ29sb3IgPT09ICd0bycpIHtcbiAgICAgICAgICByZXR1cm4gdXRpbC5vdmVycmlkZU9wYWNpdHkodGhpcy50by5vcHRpb25zLmNvbG9yLmJvcmRlciwgdmFsdWVzLm9wYWNpdHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFwiZnJvbVwiXG4gICAgICAgICAgcmV0dXJuIHV0aWwub3ZlcnJpZGVPcGFjaXR5KHRoaXMuZnJvbS5vcHRpb25zLmNvbG9yLmJvcmRlciwgdmFsdWVzLm9wYWNpdHkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdXRpbC5vdmVycmlkZU9wYWNpdHkodmFsdWVzLmNvbG9yLCB2YWx1ZXMub3BhY2l0eSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhdyBhIGxpbmUgZnJvbSBhIG5vZGUgdG8gaXRzZWxmLCBhIGNpcmNsZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2NpcmNsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jaXJjbGUoY3R4LCB2YWx1ZXMsIHgsIHksIHJhZGl1cykge1xuICAgICAgLy8gZHJhdyBzaGFkb3cgaWYgZW5hYmxlZFxuICAgICAgdGhpcy5lbmFibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuXG4gICAgICAvLyBkcmF3IGEgY2lyY2xlXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguYXJjKHgsIHksIHJhZGl1cywgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgLy8gZGlzYWJsZSBzaGFkb3dzIGZvciBvdGhlciBlbGVtZW50cy5cbiAgICAgIHRoaXMuZGlzYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7XG4gICAgfVxuXG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGEgcG9pbnQgKHgzLHkzKSBhbmQgYSBsaW5lIHNlZ21lbnQgZnJvbSAoeDEseTEpIHRvICh4Mix5MikuXG4gICAgICogKHgzLHkzKSBpcyB0aGUgcG9pbnQuXG4gICAgICpcbiAgICAgKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg0OTIxMS9zaG9ydGVzdC1kaXN0YW5jYWUtYmV0d2Vlbi1hLXBvaW50LWFuZC1hLWxpbmUtc2VnbWVudFxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkzXG4gICAgICogQHBhcmFtIHtOb2RlfSB2aWFcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXREaXN0YW5jZVRvRWRnZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERpc3RhbmNlVG9FZGdlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHZpYSwgdmFsdWVzKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICB2YXIgcmV0dXJuVmFsdWUgPSAwO1xuICAgICAgaWYgKHRoaXMuZnJvbSAhPSB0aGlzLnRvKSB7XG4gICAgICAgIHJldHVyblZhbHVlID0gdGhpcy5fZ2V0RGlzdGFuY2VUb0VkZ2UoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgdmlhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfZ2V0Q2lyY2xlRGF0YTggPSB0aGlzLl9nZXRDaXJjbGVEYXRhKHVuZGVmaW5lZCksXG4gICAgICAgICAgICBfZ2V0Q2lyY2xlRGF0YTkgPSAoMCwgX3NsaWNlZFRvQXJyYXkzWydkZWZhdWx0J10pKF9nZXRDaXJjbGVEYXRhOCwgMyksXG4gICAgICAgICAgICB4ID0gX2dldENpcmNsZURhdGE5WzBdLFxuICAgICAgICAgICAgeSA9IF9nZXRDaXJjbGVEYXRhOVsxXSxcbiAgICAgICAgICAgIHJhZGl1cyA9IF9nZXRDaXJjbGVEYXRhOVsyXTtcblxuICAgICAgICB2YXIgZHggPSB4IC0geDM7XG4gICAgICAgIHZhciBkeSA9IHkgLSB5MztcbiAgICAgICAgcmV0dXJuVmFsdWUgPSBNYXRoLmFicyhNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpIC0gcmFkaXVzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkzXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZ2V0RGlzdGFuY2VUb0xpbmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGlzdGFuY2VUb0xpbmUoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgICAgdmFyIHB4ID0geDIgLSB4MTtcbiAgICAgIHZhciBweSA9IHkyIC0geTE7XG4gICAgICB2YXIgc29tZXRoaW5nID0gcHggKiBweCArIHB5ICogcHk7XG4gICAgICB2YXIgdSA9ICgoeDMgLSB4MSkgKiBweCArICh5MyAtIHkxKSAqIHB5KSAvIHNvbWV0aGluZztcblxuICAgICAgaWYgKHUgPiAxKSB7XG4gICAgICAgIHUgPSAxO1xuICAgICAgfSBlbHNlIGlmICh1IDwgMCkge1xuICAgICAgICB1ID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIHggPSB4MSArIHUgKiBweDtcbiAgICAgIHZhciB5ID0geTEgKyB1ICogcHk7XG4gICAgICB2YXIgZHggPSB4IC0geDM7XG4gICAgICB2YXIgZHkgPSB5IC0geTM7XG5cbiAgICAgIC8vIyBOb3RlOiBJZiB0aGUgYWN0dWFsIGRpc3RhbmNlIGRvZXMgbm90IG1hdHRlcixcbiAgICAgIC8vIyBpZiB5b3Ugb25seSB3YW50IHRvIGNvbXBhcmUgd2hhdCB0aGlzIGZ1bmN0aW9uXG4gICAgICAvLyMgcmV0dXJucyB0byBvdGhlciByZXN1bHRzIG9mIHRoaXMgZnVuY3Rpb24sIHlvdVxuICAgICAgLy8jIGNhbiBqdXN0IHJldHVybiB0aGUgc3F1YXJlZCBkaXN0YW5jZSBpbnN0ZWFkXG4gICAgICAvLyMgKGkuZS4gcmVtb3ZlIHRoZSBzcXJ0KSB0byBnYWluIGEgbGl0dGxlIHBlcmZvcm1hbmNlXG5cbiAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge05vZGV9IHZpYU5vZGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlc1xuICAgICAqIEByZXR1cm5zIHt7cG9pbnQ6ICosIGNvcmU6IHt4OiBudW1iZXIsIHk6IG51bWJlcn0sIGFuZ2xlOiAqLCBsZW5ndGg6IG51bWJlciwgdHlwZTogKn19XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldEFycm93RGF0YScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFycm93RGF0YShjdHgsIHBvc2l0aW9uLCB2aWFOb2RlLCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgLy8gc2V0IGxldHNcbiAgICAgIHZhciBhbmdsZSA9IHZvaWQgMDtcbiAgICAgIHZhciBhcnJvd1BvaW50ID0gdm9pZCAwO1xuICAgICAgdmFyIG5vZGUxID0gdm9pZCAwO1xuICAgICAgdmFyIG5vZGUyID0gdm9pZCAwO1xuICAgICAgdmFyIGd1aWRlT2Zmc2V0ID0gdm9pZCAwO1xuICAgICAgdmFyIHNjYWxlRmFjdG9yID0gdm9pZCAwO1xuICAgICAgdmFyIHR5cGUgPSB2b2lkIDA7XG4gICAgICB2YXIgbGluZVdpZHRoID0gdmFsdWVzLndpZHRoO1xuXG4gICAgICBpZiAocG9zaXRpb24gPT09ICdmcm9tJykge1xuICAgICAgICBub2RlMSA9IHRoaXMuZnJvbTtcbiAgICAgICAgbm9kZTIgPSB0aGlzLnRvO1xuICAgICAgICBndWlkZU9mZnNldCA9IDAuMTtcbiAgICAgICAgc2NhbGVGYWN0b3IgPSB2YWx1ZXMuZnJvbUFycm93U2NhbGU7XG4gICAgICAgIHR5cGUgPSB2YWx1ZXMuZnJvbUFycm93VHlwZTtcbiAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICd0bycpIHtcbiAgICAgICAgbm9kZTEgPSB0aGlzLnRvO1xuICAgICAgICBub2RlMiA9IHRoaXMuZnJvbTtcbiAgICAgICAgZ3VpZGVPZmZzZXQgPSAtMC4xO1xuICAgICAgICBzY2FsZUZhY3RvciA9IHZhbHVlcy50b0Fycm93U2NhbGU7XG4gICAgICAgIHR5cGUgPSB2YWx1ZXMudG9BcnJvd1R5cGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlMSA9IHRoaXMudG87XG4gICAgICAgIG5vZGUyID0gdGhpcy5mcm9tO1xuICAgICAgICBzY2FsZUZhY3RvciA9IHZhbHVlcy5taWRkbGVBcnJvd1NjYWxlO1xuICAgICAgICB0eXBlID0gdmFsdWVzLm1pZGRsZUFycm93VHlwZTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgbm90IGNvbm5lY3RlZCB0byBpdHNlbGZcbiAgICAgIGlmIChub2RlMSAhPSBub2RlMikge1xuICAgICAgICBpZiAocG9zaXRpb24gIT09ICdtaWRkbGUnKSB7XG4gICAgICAgICAgLy8gZHJhdyBhcnJvdyBoZWFkXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zbW9vdGguZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgYXJyb3dQb2ludCA9IHRoaXMuZmluZEJvcmRlclBvc2l0aW9uKG5vZGUxLCBjdHgsIHsgdmlhOiB2aWFOb2RlIH0pO1xuICAgICAgICAgICAgdmFyIGd1aWRlUG9zID0gdGhpcy5nZXRQb2ludChNYXRoLm1heCgwLjAsIE1hdGgubWluKDEuMCwgYXJyb3dQb2ludC50ICsgZ3VpZGVPZmZzZXQpKSwgdmlhTm9kZSk7XG4gICAgICAgICAgICBhbmdsZSA9IE1hdGguYXRhbjIoYXJyb3dQb2ludC55IC0gZ3VpZGVQb3MueSwgYXJyb3dQb2ludC54IC0gZ3VpZGVQb3MueCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFuZ2xlID0gTWF0aC5hdGFuMihub2RlMS55IC0gbm9kZTIueSwgbm9kZTEueCAtIG5vZGUyLngpO1xuICAgICAgICAgICAgYXJyb3dQb2ludCA9IHRoaXMuZmluZEJvcmRlclBvc2l0aW9uKG5vZGUxLCBjdHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbmdsZSA9IE1hdGguYXRhbjIobm9kZTEueSAtIG5vZGUyLnksIG5vZGUxLnggLSBub2RlMi54KTtcbiAgICAgICAgICBhcnJvd1BvaW50ID0gdGhpcy5nZXRQb2ludCgwLjUsIHZpYU5vZGUpOyAvLyB0aGlzIGlzIDAuNiB0byBhY2NvdW50IGZvciB0aGUgc2l6ZSBvZiB0aGUgYXJyb3cuXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRyYXcgY2lyY2xlXG4gICAgICAgIHZhciBfZ2V0Q2lyY2xlRGF0YTEwID0gdGhpcy5fZ2V0Q2lyY2xlRGF0YShjdHgpLFxuICAgICAgICAgICAgX2dldENpcmNsZURhdGExMSA9ICgwLCBfc2xpY2VkVG9BcnJheTNbJ2RlZmF1bHQnXSkoX2dldENpcmNsZURhdGExMCwgMyksXG4gICAgICAgICAgICB4ID0gX2dldENpcmNsZURhdGExMVswXSxcbiAgICAgICAgICAgIHkgPSBfZ2V0Q2lyY2xlRGF0YTExWzFdLFxuICAgICAgICAgICAgcmFkaXVzID0gX2dldENpcmNsZURhdGExMVsyXTtcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09ICdmcm9tJykge1xuICAgICAgICAgIGFycm93UG9pbnQgPSB0aGlzLmZpbmRCb3JkZXJQb3NpdGlvbih0aGlzLmZyb20sIGN0eCwge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICBsb3c6IDAuMjUsXG4gICAgICAgICAgICBoaWdoOiAwLjYsXG4gICAgICAgICAgICBkaXJlY3Rpb246IC0xXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYW5nbGUgPSBhcnJvd1BvaW50LnQgKiAtMiAqIE1hdGguUEkgKyAxLjUgKiBNYXRoLlBJICsgMC4xICogTWF0aC5QSTtcbiAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3RvJykge1xuICAgICAgICAgIGFycm93UG9pbnQgPSB0aGlzLmZpbmRCb3JkZXJQb3NpdGlvbih0aGlzLmZyb20sIGN0eCwge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICBsb3c6IDAuNixcbiAgICAgICAgICAgIGhpZ2g6IDEuMCxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogMVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFuZ2xlID0gYXJyb3dQb2ludC50ICogLTIgKiBNYXRoLlBJICsgMS41ICogTWF0aC5QSSAtIDEuMSAqIE1hdGguUEk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXJyb3dQb2ludCA9IHRoaXMuX3BvaW50T25DaXJjbGUoeCwgeSwgcmFkaXVzLCAwLjE3NSk7XG4gICAgICAgICAgYW5nbGUgPSAzLjkyNjk5MDgxNjk4NzI0MTQ7IC8vID09PSAwLjE3NSAqIC0yICogTWF0aC5QSSArIDEuNSAqIE1hdGguUEkgKyAwLjEgKiBNYXRoLlBJO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ21pZGRsZScgJiYgc2NhbGVGYWN0b3IgPCAwKSBsaW5lV2lkdGggKj0gLTE7IC8vIHJldmVyc2VkIG1pZGRsZSBhcnJvd1xuICAgICAgdmFyIGxlbmd0aCA9IDE1ICogc2NhbGVGYWN0b3IgKyAzICogbGluZVdpZHRoOyAvLyAzKiBsaW5lV2lkdGggaXMgdGhlIHdpZHRoIG9mIHRoZSBlZGdlLlxuXG4gICAgICB2YXIgeGkgPSBhcnJvd1BvaW50LnggLSBsZW5ndGggKiAwLjkgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICB2YXIgeWkgPSBhcnJvd1BvaW50LnkgLSBsZW5ndGggKiAwLjkgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgICB2YXIgYXJyb3dDb3JlID0geyB4OiB4aSwgeTogeWkgfTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcG9pbnQ6IGFycm93UG9pbnQsXG4gICAgICAgIGNvcmU6IGFycm93Q29yZSxcbiAgICAgICAgYW5nbGU6IGFuZ2xlLFxuICAgICAgICBsZW5ndGg6IGxlbmd0aCxcbiAgICAgICAgdHlwZTogdHlwZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJyb3dEYXRhXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RyYXdBcnJvd0hlYWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3QXJyb3dIZWFkKGN0eCwgdmFsdWVzLCBzZWxlY3RlZCwgaG92ZXIsIGFycm93RGF0YSkge1xuICAgICAgLy8gc2V0IHN0eWxlXG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmdldENvbG9yKGN0eCwgdmFsdWVzLCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGN0eC5zdHJva2VTdHlsZTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSB2YWx1ZXMud2lkdGg7XG5cbiAgICAgIEVuZFBvaW50cy5kcmF3KGN0eCwgYXJyb3dEYXRhKTtcblxuICAgICAgLy8gZHJhdyBzaGFkb3cgaWYgZW5hYmxlZFxuICAgICAgdGhpcy5lbmFibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIC8vIGRpc2FibGUgc2hhZG93cyBmb3Igb3RoZXIgZWxlbWVudHMuXG4gICAgICB0aGlzLmRpc2FibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZW5hYmxlU2hhZG93JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5hYmxlU2hhZG93KGN0eCwgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWVzLnNoYWRvdyA9PT0gdHJ1ZSkge1xuICAgICAgICBjdHguc2hhZG93Q29sb3IgPSB2YWx1ZXMuc2hhZG93Q29sb3I7XG4gICAgICAgIGN0eC5zaGFkb3dCbHVyID0gdmFsdWVzLnNoYWRvd1NpemU7XG4gICAgICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gdmFsdWVzLnNoYWRvd1g7XG4gICAgICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gdmFsdWVzLnNoYWRvd1k7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkaXNhYmxlU2hhZG93JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzYWJsZVNoYWRvdyhjdHgsIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlcy5zaGFkb3cgPT09IHRydWUpIHtcbiAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gJ3JnYmEoMCwwLDAsMCknO1xuICAgICAgICBjdHguc2hhZG93Qmx1ciA9IDA7XG4gICAgICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gMDtcbiAgICAgICAgY3R4LnNoYWRvd09mZnNldFkgPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7e3RvQXJyb3c6IGJvb2xlYW4sIHRvQXJyb3dTY2FsZTogKGFsbE9wdGlvbnMuZWRnZXMuYXJyb3dzLnRvLnNjYWxlRmFjdG9yfHtudW1iZXJ9fGFsbE9wdGlvbnMuZWRnZXMuYXJyb3dzLm1pZGRsZS5zY2FsZUZhY3RvcnxhbGxPcHRpb25zLmVkZ2VzLmFycm93cy5mcm9tLnNjYWxlRmFjdG9yfEFycmF5fG51bWJlciksIHRvQXJyb3dUeXBlOiAqLCBtaWRkbGVBcnJvdzogYm9vbGVhbiwgbWlkZGxlQXJyb3dTY2FsZTogKG51bWJlcnxhbGxPcHRpb25zLmVkZ2VzLmFycm93cy5taWRkbGUuc2NhbGVGYWN0b3J8e251bWJlcn18QXJyYXkpLCBtaWRkbGVBcnJvd1R5cGU6IChhbGxPcHRpb25zLmVkZ2VzLmFycm93cy5taWRkbGUudHlwZXx7c3RyaW5nfXxzdHJpbmd8KiksIGZyb21BcnJvdzogYm9vbGVhbiwgZnJvbUFycm93U2NhbGU6IChhbGxPcHRpb25zLmVkZ2VzLmFycm93cy50by5zY2FsZUZhY3Rvcnx7bnVtYmVyfXxhbGxPcHRpb25zLmVkZ2VzLmFycm93cy5taWRkbGUuc2NhbGVGYWN0b3J8YWxsT3B0aW9ucy5lZGdlcy5hcnJvd3MuZnJvbS5zY2FsZUZhY3RvcnxBcnJheXxudW1iZXIpLCBmcm9tQXJyb3dUeXBlOiAqLCBhcnJvd1N0cmlrZXRocm91Z2g6ICgqfGJvb2xlYW58YWxsT3B0aW9ucy5lZGdlcy5hcnJvd1N0cmlrZXRocm91Z2h8e2Jvb2xlYW59KSwgY29sb3I6IHVuZGVmaW5lZCwgaW5oZXJpdHNDb2xvcjogKHN0cmluZ3xzdHJpbmd8c3RyaW5nfGFsbE9wdGlvbnMuZWRnZXMuY29sb3IuaW5oZXJpdHx7c3RyaW5nLCBib29sZWFufXxBcnJheXwqKSwgb3BhY2l0eTogKiwgaGlkZGVuOiAqLCBsZW5ndGg6ICosIHNoYWRvdzogKiwgc2hhZG93Q29sb3I6ICosIHNoYWRvd1NpemU6ICosIHNoYWRvd1g6ICosIHNoYWRvd1k6ICosIGRhc2hlczogKCp8Ym9vbGVhbnxBcnJheXxhbGxPcHRpb25zLmVkZ2VzLmRhc2hlc3x7Ym9vbGVhbiwgYXJyYXl9KSwgd2lkdGg6ICp9fSB2YWx1ZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZHJhd0JhY2tncm91bmQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3QmFja2dyb3VuZChjdHgsIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlcy5iYWNrZ3JvdW5kICE9PSBmYWxzZSkge1xuICAgICAgICB2YXIgYXR0cnMgPSBbJ3N0cm9rZVN0eWxlJywgJ2xpbmVXaWR0aCcsICdkYXNoZXMnXTtcbiAgICAgICAgdmFyIG9yaWdDdHhBdHRyID0ge307XG4gICAgICAgIC8vIHNhdmUgb3JpZ2luYWwgbGluZSBhdHRyc1xuICAgICAgICBhdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRybmFtZSkge1xuICAgICAgICAgIG9yaWdDdHhBdHRyW2F0dHJuYW1lXSA9IGN0eFthdHRybmFtZV07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHZhbHVlcy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSB2YWx1ZXMuYmFja2dyb3VuZFNpemU7XG4gICAgICAgIHRoaXMuc2V0U3Ryb2tlRGFzaGVkKGN0eCwgdmFsdWVzLmJhY2tncm91bmREYXNoZXMpO1xuXG4gICAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgICAvLyByZXN0b3JlIG9yaWdpbmFsIGxpbmUgYXR0cnNcbiAgICAgICAgYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cm5hbWUpIHtcbiAgICAgICAgICBjdHhbYXR0cm5hbWVdID0gb3JpZ0N0eEF0dHJbYXR0cm5hbWVdO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRTdHJva2VEYXNoZWQoY3R4LCB2YWx1ZXMuZGFzaGVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58QXJyYXl9IGRhc2hlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRTdHJva2VEYXNoZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTdHJva2VEYXNoZWQoY3R4LCBkYXNoZXMpIHtcbiAgICAgIGlmIChkYXNoZXMgIT09IGZhbHNlKSB7XG4gICAgICAgIGlmIChjdHguc2V0TGluZURhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBwYXR0ZXJuID0gWzUsIDVdO1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhc2hlcykgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHBhdHRlcm4gPSBkYXNoZXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChwYXR0ZXJuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ3NldExpbmVEYXNoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyLiBUaGUgZGFzaGVkIHN0cm9rZSBjYW5ub3QgYmUgdXNlZC4nKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGN0eC5zZXRMaW5lRGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY3R4LnNldExpbmVEYXNoKFtdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ3NldExpbmVEYXNoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyLiBUaGUgZGFzaGVkIHN0cm9rZSBjYW5ub3QgYmUgdXNlZC4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRWRnZUJhc2U7XG59KCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEVkZ2VCYXNlO1xuXG4vKioqLyB9KSxcbi8qIDgwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cbnZhciBfaW5oZXJpdHMyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLyoqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIExvY2F0aW9uIG9mIGFsbCB0aGUgZW5kcG9pbnQgZHJhd2luZyByb3V0aW5lcy5cbiAqXG4gKiBFdmVyeSBlbmRwb2ludCBoYXMgaXRzIG93biBkcmF3aW5nIHJvdXRpbmUsIHdoaWNoIGNvbnRhaW5zIGFuIGVuZHBvaW50IGRlZmluaXRpb24uXG4gKlxuICogVGhlIGVuZHBvaW50IGRlZmluaXRpb25zIG11c3QgaGF2ZSB0aGUgZm9sbG93aW5nIHByb3BlcmllczpcbiAqXG4gKiAtICgwLDApIGlzIHRoZSBjb25uZWN0aW9uIHBvaW50IHRvIHRoZSBub2RlIGl0IGF0dGFjaGVzIHRvXG4gKiAtIFRoZSBlbmRwb2ludHMgYXJlIG9yaWVudGF0ZWQgdG8gdGhlIHBvc2l0aXZlIHgtZGlyZWN0aW9uXG4gKiAtIFRoZSBsZW5ndGggb2YgdGhlIGVuZHBvaW50IGlzIGF0IG1vc3QgMVxuICpcbiAqIEFzIGxvbmcgYXMgdGhlIGVuZHBvaW50IGNsYXNzZXMgcmVtYWluIHNpbXBsZSBhbmQgbm90IHRvbyBudW1lcm91cywgdGhleSB3aWxsXG4gKiBiZSBjb250YWluZWQgd2l0aGluIHRoaXMgbW9kdWxlLlxuICogQWxsIGNsYXNzZXMgaGVyZSBleGNlcHQgYEVuZFBvaW50c2Agc2hvdWxkIGJlIGNvbnNpZGVyZWQgYXMgcHJpdmF0ZSB0byB0aGlzIG1vZHVsZS5cbiAqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIyMjIEZ1cnRoZXIgQWN0aW9uc1xuICpcbiAqIEFmdGVyIGFkZGluZyBhIG5ldyBlbmRwb2ludCBoZXJlLCB5b3UgYWxzbyBuZWVkIHRvIGRvIHRoZSBmb2xsb3dpbmcgdGhpbmdzOlxuICpcbiAqIC0gQWRkIHRoZSBuZXcgZW5kcG9pbnQgbmFtZSB0byBgbmV0d29yay9vcHRpb25zLmpzYCBpbiBhcnJheSBgZW5kUG9pbnRzYC5cbiAqIC0gQWRkIHRoZSBuZXcgZW5kcG9pbnQgbmFtZSB0byB0aGUgZG9jdW1lbnRhdGlvbi5cbiAqICAgU2NhbiBmb3IgJ2Fycm93cy50by50eXBlYCBhbmQgYWRkIGl0IHRvIHRoZSBkZXNjcmlwdGlvbi5cbiAqIC0gQWRkIHRoZSBlbmRwb2ludCB0byB0aGUgZXhhbXBsZXMuIEF0IHRoZSB2ZXJ5IGxlYXN0LCBhZGQgaXQgdG8gZXhhbXBsZVxuICogICBgZWRnZVN0eWxlcy9hcnJvd1R5cGVzYC5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbi8qKlxuICogQ29tbW9uIG1ldGhvZHMgZm9yIGVuZHBvaW50c1xuICpcbiAqIEBjbGFzc1xuICovXG52YXIgRW5kUG9pbnQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEVuZFBvaW50KCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIEVuZFBvaW50KTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKEVuZFBvaW50LCBudWxsLCBbe1xuICAgIGtleTogJ3RyYW5zZm9ybScsXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0cmFuc2Zvcm1hdGlvbiBvbiBwb2ludHMgZm9yIGRpc3BsYXkuXG4gICAgICpcbiAgICAgKiBUaGUgZm9sbG93aW5nIGlzIGRvbmU6XG4gICAgICogLSByb3RhdGUgYnkgdGhlIHNwZWNpZmllZCBhbmdsZVxuICAgICAqIC0gbXVsdGlwbHkgdGhlIChub3JtYWxpemVkKSBjb29yZGluYXRlcyBieSB0aGUgcGFzc2VkIGxlbmd0aFxuICAgICAqIC0gb2Zmc2V0IGJ5IHRoZSB0YXJnZXQgY29vcmRpbmF0ZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXk8UG9pbnQ+fSBwb2ludHNcbiAgICAgKiBAcGFyYW0ge0Fycm93RGF0YX0gYXJyb3dEYXRhXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFuc2Zvcm0ocG9pbnRzLCBhcnJvd0RhdGEpIHtcbiAgICAgIGlmICghKHBvaW50cyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICBwb2ludHMgPSBbcG9pbnRzXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHggPSBhcnJvd0RhdGEucG9pbnQueDtcbiAgICAgIHZhciB5ID0gYXJyb3dEYXRhLnBvaW50Lnk7XG4gICAgICB2YXIgYW5nbGUgPSBhcnJvd0RhdGEuYW5nbGU7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyb3dEYXRhLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHAgPSBwb2ludHNbaV07XG4gICAgICAgIHZhciB4dCA9IHAueCAqIE1hdGguY29zKGFuZ2xlKSAtIHAueSAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgdmFyIHl0ID0gcC54ICogTWF0aC5zaW4oYW5nbGUpICsgcC55ICogTWF0aC5jb3MoYW5nbGUpO1xuXG4gICAgICAgIHAueCA9IHggKyBsZW5ndGggKiB4dDtcbiAgICAgICAgcC55ID0geSArIGxlbmd0aCAqIHl0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyYXcgYSBjbG9zZWQgcGF0aCB1c2luZyB0aGUgZ2l2ZW4gcmVhbCBjb29yZGluYXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxQb2ludD59IHBvaW50c1xuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZHJhd1BhdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3UGF0aChjdHgsIHBvaW50cykge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyhwb2ludHNbMF0ueCwgcG9pbnRzWzBdLnkpO1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBwb2ludHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3R4LmxpbmVUbyhwb2ludHNbaV0ueCwgcG9pbnRzW2ldLnkpO1xuICAgICAgfVxuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRW5kUG9pbnQ7XG59KCk7XG5cbi8qKlxuICogRHJhd2luZyBtZXRob2RzIGZvciB0aGUgYXJyb3cgZW5kcG9pbnQuXG4gKiBAZXh0ZW5kcyBFbmRQb2ludFxuICovXG5cblxudmFyIEFycm93ID0gZnVuY3Rpb24gKF9FbmRQb2ludCkge1xuICAoMCwgX2luaGVyaXRzM1snZGVmYXVsdCddKShBcnJvdywgX0VuZFBvaW50KTtcblxuICBmdW5jdGlvbiBBcnJvdygpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrM1snZGVmYXVsdCddKSh0aGlzLCBBcnJvdyk7XG4gICAgcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjNbJ2RlZmF1bHQnXSkodGhpcywgKEFycm93Ll9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMlsnZGVmYXVsdCddKShBcnJvdykpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoQXJyb3csIG51bGwsIFt7XG4gICAga2V5OiAnZHJhdycsXG5cbiAgICAvKipcbiAgICAgKiBEcmF3IHRoaXMgc2hhcGUgYXQgdGhlIGVuZCBvZiBhIGxpbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtBcnJvd0RhdGF9IGFycm93RGF0YVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIGFycm93RGF0YSkge1xuICAgICAgLy8gTm9ybWFsaXplZCBwb2ludHMgb2YgY2xvc2VkIHBhdGgsIGluIHRoZSBvcmRlciB0aGF0IHRoZXkgc2hvdWxkIGJlIGRyYXduLlxuICAgICAgLy8gKDAsIDApIGlzIHRoZSBhdHRhY2htZW50IHBvaW50LCBhbmQgdGhlIHBvaW50IGFyb3VuZCB3aGljaCBzaG91bGQgYmUgcm90YXRlZFxuICAgICAgdmFyIHBvaW50cyA9IFt7IHg6IDAsIHk6IDAgfSwgeyB4OiAtMSwgeTogMC4zIH0sIHsgeDogLTAuOSwgeTogMCB9LCB7IHg6IC0xLCB5OiAtMC4zIH1dO1xuXG4gICAgICBFbmRQb2ludC50cmFuc2Zvcm0ocG9pbnRzLCBhcnJvd0RhdGEpO1xuICAgICAgRW5kUG9pbnQuZHJhd1BhdGgoY3R4LCBwb2ludHMpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQXJyb3c7XG59KEVuZFBvaW50KTtcblxuLyoqXG4gKiBEcmF3aW5nIG1ldGhvZHMgZm9yIHRoZSBjcm93IGVuZHBvaW50LlxuICogQGV4dGVuZHMgRW5kUG9pbnRcbiAqL1xuXG5cbnZhciBDcm93ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDcm93KCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIENyb3cpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoQ3JvdywgbnVsbCwgW3tcbiAgICBrZXk6ICdkcmF3JyxcblxuICAgIC8qKlxuICAgICAqIERyYXcgdGhpcyBzaGFwZSBhdCB0aGUgZW5kIG9mIGEgbGluZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93RGF0YX0gYXJyb3dEYXRhXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICAvLyBOb3JtYWxpemVkIHBvaW50cyBvZiBjbG9zZWQgcGF0aCwgaW4gdGhlIG9yZGVyIHRoYXQgdGhleSBzaG91bGQgYmUgZHJhd24uXG4gICAgICAvLyAoMCwgMCkgaXMgdGhlIGF0dGFjaG1lbnQgcG9pbnQsIGFuZCB0aGUgcG9pbnQgYXJvdW5kIHdoaWNoIHNob3VsZCBiZSByb3RhdGVkXG4gICAgICB2YXIgcG9pbnRzID0gW3sgeDogLTEsIHk6IDAgfSwgeyB4OiAwLCB5OiAwLjMgfSwgeyB4OiAtMC40LCB5OiAwIH0sIHsgeDogMCwgeTogLTAuMyB9XTtcblxuICAgICAgRW5kUG9pbnQudHJhbnNmb3JtKHBvaW50cywgYXJyb3dEYXRhKTtcbiAgICAgIEVuZFBvaW50LmRyYXdQYXRoKGN0eCwgcG9pbnRzKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENyb3c7XG59KCk7XG5cbi8qKlxuICogRHJhd2luZyBtZXRob2RzIGZvciB0aGUgY3VydmUgZW5kcG9pbnQuXG4gKiBAZXh0ZW5kcyBFbmRQb2ludFxuICovXG5cblxudmFyIEN1cnZlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDdXJ2ZSgpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrM1snZGVmYXVsdCddKSh0aGlzLCBDdXJ2ZSk7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzM1snZGVmYXVsdCddKShDdXJ2ZSwgbnVsbCwgW3tcbiAgICBrZXk6ICdkcmF3JyxcblxuICAgIC8qKlxuICAgICAqIERyYXcgdGhpcyBzaGFwZSBhdCB0aGUgZW5kIG9mIGEgbGluZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93RGF0YX0gYXJyb3dEYXRhXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICAvLyBOb3JtYWxpemVkIHBvaW50cyBvZiBjbG9zZWQgcGF0aCwgaW4gdGhlIG9yZGVyIHRoYXQgdGhleSBzaG91bGQgYmUgZHJhd24uXG4gICAgICAvLyAoMCwgMCkgaXMgdGhlIGF0dGFjaG1lbnQgcG9pbnQsIGFuZCB0aGUgcG9pbnQgYXJvdW5kIHdoaWNoIHNob3VsZCBiZSByb3RhdGVkXG4gICAgICB2YXIgcG9pbnQgPSB7IHg6IC0wLjQsIHk6IDAgfTtcbiAgICAgIEVuZFBvaW50LnRyYW5zZm9ybShwb2ludCwgYXJyb3dEYXRhKTtcblxuICAgICAgLy8gVXBkYXRlIGVuZHBvaW50IHN0eWxlIGZvciBkcmF3aW5nIHRyYW5zcGFyZW50IGFyYy5cbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGN0eC5maWxsU3R5bGU7XG4gICAgICBjdHguZmlsbFN0eWxlID0gJ3JnYmEoMCwgMCwgMCwgMCknO1xuXG4gICAgICAvLyBEZWZpbmUgY3VydmUgZW5kcG9pbnQgYXMgc2VtaWNpcmNsZS5cbiAgICAgIHZhciBwaSA9IE1hdGguUEk7XG4gICAgICB2YXIgc3RhcnRfYW5nbGUgPSBhcnJvd0RhdGEuYW5nbGUgLSBwaSAvIDI7XG4gICAgICB2YXIgZW5kX2FuZ2xlID0gYXJyb3dEYXRhLmFuZ2xlICsgcGkgLyAyO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LmFyYyhwb2ludC54LCBwb2ludC55LCBhcnJvd0RhdGEubGVuZ3RoICogMC40LCBzdGFydF9hbmdsZSwgZW5kX2FuZ2xlLCBmYWxzZSk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDdXJ2ZTtcbn0oKTtcblxuLyoqXG4gKiBEcmF3aW5nIG1ldGhvZHMgZm9yIHRoZSBpbnZlcnRlZCBjdXJ2ZSBlbmRwb2ludC5cbiAqIEBleHRlbmRzIEVuZFBvaW50XG4gKi9cblxuXG52YXIgSW52ZXJ0ZWRDdXJ2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSW52ZXJ0ZWRDdXJ2ZSgpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrM1snZGVmYXVsdCddKSh0aGlzLCBJbnZlcnRlZEN1cnZlKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKEludmVydGVkQ3VydmUsIG51bGwsIFt7XG4gICAga2V5OiAnZHJhdycsXG5cbiAgICAvKipcbiAgICAgKiBEcmF3IHRoaXMgc2hhcGUgYXQgdGhlIGVuZCBvZiBhIGxpbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtBcnJvd0RhdGF9IGFycm93RGF0YVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIGFycm93RGF0YSkge1xuICAgICAgLy8gTm9ybWFsaXplZCBwb2ludHMgb2YgY2xvc2VkIHBhdGgsIGluIHRoZSBvcmRlciB0aGF0IHRoZXkgc2hvdWxkIGJlIGRyYXduLlxuICAgICAgLy8gKDAsIDApIGlzIHRoZSBhdHRhY2htZW50IHBvaW50LCBhbmQgdGhlIHBvaW50IGFyb3VuZCB3aGljaCBzaG91bGQgYmUgcm90YXRlZFxuICAgICAgdmFyIHBvaW50ID0geyB4OiAtMC4zLCB5OiAwIH07XG4gICAgICBFbmRQb2ludC50cmFuc2Zvcm0ocG9pbnQsIGFycm93RGF0YSk7XG5cbiAgICAgIC8vIFVwZGF0ZSBlbmRwb2ludCBzdHlsZSBmb3IgZHJhd2luZyB0cmFuc3BhcmVudCBhcmMuXG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjdHguZmlsbFN0eWxlO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9ICdyZ2JhKDAsIDAsIDAsIDApJztcblxuICAgICAgLy8gRGVmaW5lIGludmVydGVkIGN1cnZlIGVuZHBvaW50IGFzIHNlbWljaXJjbGUuXG4gICAgICB2YXIgcGkgPSBNYXRoLlBJO1xuICAgICAgdmFyIHN0YXJ0X2FuZ2xlID0gYXJyb3dEYXRhLmFuZ2xlICsgcGkgLyAyO1xuICAgICAgdmFyIGVuZF9hbmdsZSA9IGFycm93RGF0YS5hbmdsZSArIDMgKiBwaSAvIDI7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguYXJjKHBvaW50LngsIHBvaW50LnksIGFycm93RGF0YS5sZW5ndGggKiAwLjQsIHN0YXJ0X2FuZ2xlLCBlbmRfYW5nbGUsIGZhbHNlKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEludmVydGVkQ3VydmU7XG59KCk7XG5cbi8qKlxuICogRHJhd2luZyBtZXRob2RzIGZvciB0aGUgdHJpbmFnbGUgZW5kcG9pbnQuXG4gKiBAZXh0ZW5kcyBFbmRQb2ludFxuICovXG5cblxudmFyIFRyaWFuZ2xlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUcmlhbmdsZSgpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrM1snZGVmYXVsdCddKSh0aGlzLCBUcmlhbmdsZSk7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzM1snZGVmYXVsdCddKShUcmlhbmdsZSwgbnVsbCwgW3tcbiAgICBrZXk6ICdkcmF3JyxcblxuICAgIC8qKlxuICAgICAqIERyYXcgdGhpcyBzaGFwZSBhdCB0aGUgZW5kIG9mIGEgbGluZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93RGF0YX0gYXJyb3dEYXRhXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICAvLyBOb3JtYWxpemVkIHBvaW50cyBvZiBjbG9zZWQgcGF0aCwgaW4gdGhlIG9yZGVyIHRoYXQgdGhleSBzaG91bGQgYmUgZHJhd24uXG4gICAgICAvLyAoMCwgMCkgaXMgdGhlIGF0dGFjaG1lbnQgcG9pbnQsIGFuZCB0aGUgcG9pbnQgYXJvdW5kIHdoaWNoIHNob3VsZCBiZSByb3RhdGVkXG4gICAgICB2YXIgcG9pbnRzID0gW3sgeDogMC4wMiwgeTogMCB9LCB7IHg6IC0xLCB5OiAwLjMgfSwgeyB4OiAtMSwgeTogLTAuMyB9XTtcblxuICAgICAgRW5kUG9pbnQudHJhbnNmb3JtKHBvaW50cywgYXJyb3dEYXRhKTtcbiAgICAgIEVuZFBvaW50LmRyYXdQYXRoKGN0eCwgcG9pbnRzKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFRyaWFuZ2xlO1xufSgpO1xuXG4vKipcbiAqIERyYXdpbmcgbWV0aG9kcyBmb3IgdGhlIGludmVydGVkIHRyaW5hZ2xlIGVuZHBvaW50LlxuICogQGV4dGVuZHMgRW5kUG9pbnRcbiAqL1xuXG5cbnZhciBJbnZlcnRlZFRyaWFuZ2xlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBJbnZlcnRlZFRyaWFuZ2xlKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIEludmVydGVkVHJpYW5nbGUpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoSW52ZXJ0ZWRUcmlhbmdsZSwgbnVsbCwgW3tcbiAgICBrZXk6ICdkcmF3JyxcblxuICAgIC8qKlxuICAgICAqIERyYXcgdGhpcyBzaGFwZSBhdCB0aGUgZW5kIG9mIGEgbGluZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93RGF0YX0gYXJyb3dEYXRhXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICAvLyBOb3JtYWxpemVkIHBvaW50cyBvZiBjbG9zZWQgcGF0aCwgaW4gdGhlIG9yZGVyIHRoYXQgdGhleSBzaG91bGQgYmUgZHJhd24uXG4gICAgICAvLyAoMCwgMCkgaXMgdGhlIGF0dGFjaG1lbnQgcG9pbnQsIGFuZCB0aGUgcG9pbnQgYXJvdW5kIHdoaWNoIHNob3VsZCBiZSByb3RhdGVkXG4gICAgICB2YXIgcG9pbnRzID0gW3sgeDogMCwgeTogMC4zIH0sIHsgeDogMCwgeTogLTAuMyB9LCB7IHg6IC0xLCB5OiAwIH1dO1xuXG4gICAgICBFbmRQb2ludC50cmFuc2Zvcm0ocG9pbnRzLCBhcnJvd0RhdGEpO1xuICAgICAgRW5kUG9pbnQuZHJhd1BhdGgoY3R4LCBwb2ludHMpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gSW52ZXJ0ZWRUcmlhbmdsZTtcbn0oKTtcblxuLyoqXG4gKiBEcmF3aW5nIG1ldGhvZHMgZm9yIHRoZSBjaXJjbGUgZW5kcG9pbnQuXG4gKi9cblxuXG52YXIgQ2lyY2xlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDaXJjbGUoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgQ2lyY2xlKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKENpcmNsZSwgbnVsbCwgW3tcbiAgICBrZXk6ICdkcmF3JyxcblxuICAgIC8qKlxuICAgICAqIERyYXcgdGhpcyBzaGFwZSBhdCB0aGUgZW5kIG9mIGEgbGluZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93RGF0YX0gYXJyb3dEYXRhXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICB2YXIgcG9pbnQgPSB7IHg6IC0wLjQsIHk6IDAgfTtcblxuICAgICAgRW5kUG9pbnQudHJhbnNmb3JtKHBvaW50LCBhcnJvd0RhdGEpO1xuICAgICAgY3R4LmNpcmNsZShwb2ludC54LCBwb2ludC55LCBhcnJvd0RhdGEubGVuZ3RoICogMC40KTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENpcmNsZTtcbn0oKTtcblxuLyoqXG4gKiBEcmF3aW5nIG1ldGhvZHMgZm9yIHRoZSBiYXIgZW5kcG9pbnQuXG4gKi9cblxuXG52YXIgQmFyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCYXIoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgQmFyKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKEJhciwgbnVsbCwgW3tcbiAgICBrZXk6ICdkcmF3JyxcblxuICAgIC8qKlxuICAgICAqIERyYXcgdGhpcyBzaGFwZSBhdCB0aGUgZW5kIG9mIGEgbGluZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93RGF0YX0gYXJyb3dEYXRhXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICAvKlxuICAgICAgdmFyIHBvaW50cyA9IFtcbiAgICAgICAge3g6MCwgeTowLjV9LFxuICAgICAgICB7eDowLCB5Oi0wLjV9XG4gICAgICBdO1xuICAgICAgIEVuZFBvaW50LnRyYW5zZm9ybShwb2ludHMsIGFycm93RGF0YSk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKHBvaW50c1swXS54LCBwb2ludHNbMF0ueSk7XG4gICAgICBjdHgubGluZVRvKHBvaW50c1sxXS54LCBwb2ludHNbMV0ueSk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAqL1xuXG4gICAgICB2YXIgcG9pbnRzID0gW3sgeDogMCwgeTogMC41IH0sIHsgeDogMCwgeTogLTAuNSB9LCB7IHg6IC0wLjE1LCB5OiAtMC41IH0sIHsgeDogLTAuMTUsIHk6IDAuNSB9XTtcblxuICAgICAgRW5kUG9pbnQudHJhbnNmb3JtKHBvaW50cywgYXJyb3dEYXRhKTtcbiAgICAgIEVuZFBvaW50LmRyYXdQYXRoKGN0eCwgcG9pbnRzKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEJhcjtcbn0oKTtcblxuLyoqXG4gKiBEcmF3aW5nIG1ldGhvZHMgZm9yIHRoZSBib3ggZW5kcG9pbnQuXG4gKi9cblxuXG52YXIgQm94ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCb3goKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgQm94KTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKEJveCwgbnVsbCwgW3tcbiAgICBrZXk6ICdkcmF3JyxcblxuICAgIC8qKlxuICAgICAqIERyYXcgdGhpcyBzaGFwZSBhdCB0aGUgZW5kIG9mIGEgbGluZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93RGF0YX0gYXJyb3dEYXRhXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICB2YXIgcG9pbnRzID0gW3sgeDogMCwgeTogMC4zIH0sIHsgeDogMCwgeTogLTAuMyB9LCB7IHg6IC0wLjYsIHk6IC0wLjMgfSwgeyB4OiAtMC42LCB5OiAwLjMgfV07XG5cbiAgICAgIEVuZFBvaW50LnRyYW5zZm9ybShwb2ludHMsIGFycm93RGF0YSk7XG4gICAgICBFbmRQb2ludC5kcmF3UGF0aChjdHgsIHBvaW50cyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBCb3g7XG59KCk7XG5cbi8qKlxuICogRHJhd2luZyBtZXRob2RzIGZvciB0aGUgZGlhbW9uZCBlbmRwb2ludC5cbiAqL1xuXG5cbnZhciBEaWFtb25kID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEaWFtb25kKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIERpYW1vbmQpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoRGlhbW9uZCwgbnVsbCwgW3tcbiAgICBrZXk6ICdkcmF3JyxcblxuICAgIC8qKlxuICAgICAqIERyYXcgdGhpcyBzaGFwZSBhdCB0aGUgZW5kIG9mIGEgbGluZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93RGF0YX0gYXJyb3dEYXRhXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICB2YXIgcG9pbnRzID0gW3sgeDogMCwgeTogMCB9LCB7IHg6IC0wLjUsIHk6IC0wLjMgfSwgeyB4OiAtMSwgeTogMCB9LCB7IHg6IC0wLjUsIHk6IDAuMyB9XTtcblxuICAgICAgRW5kUG9pbnQudHJhbnNmb3JtKHBvaW50cywgYXJyb3dEYXRhKTtcbiAgICAgIEVuZFBvaW50LmRyYXdQYXRoKGN0eCwgcG9pbnRzKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIERpYW1vbmQ7XG59KCk7XG5cbi8qKlxuICogRHJhd2luZyBtZXRob2RzIGZvciB0aGUgdmVlIGVuZHBvaW50LlxuICogQGV4dGVuZHMgRW5kUG9pbnRcbiAqL1xuXG5cbnZhciBWZWUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFZlZSgpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrM1snZGVmYXVsdCddKSh0aGlzLCBWZWUpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoVmVlLCBudWxsLCBbe1xuICAgIGtleTogJ2RyYXcnLFxuXG4gICAgLyoqXG4gICAgICogRHJhdyB0aGlzIHNoYXBlIGF0IHRoZSBlbmQgb2YgYSBsaW5lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7QXJyb3dEYXRhfSBhcnJvd0RhdGFcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCBhcnJvd0RhdGEpIHtcbiAgICAgIC8vIE5vcm1hbGl6ZWQgcG9pbnRzIG9mIGNsb3NlZCBwYXRoLCBpbiB0aGUgb3JkZXIgdGhhdCB0aGV5IHNob3VsZCBiZSBkcmF3bi5cbiAgICAgIC8vICgwLCAwKSBpcyB0aGUgYXR0YWNobWVudCBwb2ludCwgYW5kIHRoZSBwb2ludCBhcm91bmQgd2hpY2ggc2hvdWxkIGJlIHJvdGF0ZWRcbiAgICAgIHZhciBwb2ludHMgPSBbeyB4OiAtMSwgeTogMC4zIH0sIHsgeDogLTAuNSwgeTogMCB9LCB7IHg6IC0xLCB5OiAtMC4zIH0sIHsgeDogMCwgeTogMCB9XTtcblxuICAgICAgRW5kUG9pbnQudHJhbnNmb3JtKHBvaW50cywgYXJyb3dEYXRhKTtcbiAgICAgIEVuZFBvaW50LmRyYXdQYXRoKGN0eCwgcG9pbnRzKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFZlZTtcbn0oKTtcblxuLyoqXG4gKiBEcmF3aW5nIG1ldGhvZHMgZm9yIHRoZSBlbmRwb2ludHMuXG4gKi9cblxuXG52YXIgRW5kUG9pbnRzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFbmRQb2ludHMoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgRW5kUG9pbnRzKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKEVuZFBvaW50cywgbnVsbCwgW3tcbiAgICBrZXk6ICdkcmF3JyxcblxuICAgIC8qKlxuICAgICAqIERyYXcgYW4gZW5kcG9pbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93RGF0YX0gYXJyb3dEYXRhXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICB2YXIgdHlwZTtcbiAgICAgIGlmIChhcnJvd0RhdGEudHlwZSkge1xuICAgICAgICB0eXBlID0gYXJyb3dEYXRhLnR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2NpcmNsZSc6XG4gICAgICAgICAgQ2lyY2xlLmRyYXcoY3R4LCBhcnJvd0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdib3gnOlxuICAgICAgICAgIEJveC5kcmF3KGN0eCwgYXJyb3dEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY3Jvdyc6XG4gICAgICAgICAgQ3Jvdy5kcmF3KGN0eCwgYXJyb3dEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY3VydmUnOlxuICAgICAgICAgIEN1cnZlLmRyYXcoY3R4LCBhcnJvd0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkaWFtb25kJzpcbiAgICAgICAgICBEaWFtb25kLmRyYXcoY3R4LCBhcnJvd0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdpbnZfY3VydmUnOlxuICAgICAgICAgIEludmVydGVkQ3VydmUuZHJhdyhjdHgsIGFycm93RGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RyaWFuZ2xlJzpcbiAgICAgICAgICBUcmlhbmdsZS5kcmF3KGN0eCwgYXJyb3dEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaW52X3RyaWFuZ2xlJzpcbiAgICAgICAgICBJbnZlcnRlZFRyaWFuZ2xlLmRyYXcoY3R4LCBhcnJvd0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdiYXInOlxuICAgICAgICAgIEJhci5kcmF3KGN0eCwgYXJyb3dEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndmVlJzpcbiAgICAgICAgICBWZWUuZHJhdyhjdHgsIGFycm93RGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Fycm93JzogLy8gZmFsbC10aHJvdWdoXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgQXJyb3cuZHJhdyhjdHgsIGFycm93RGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBFbmRQb2ludHM7XG59KCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEVuZFBvaW50cztcblxuLyoqKi8gfSksXG4vKiA4MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLyoqXG4gKiBCYXJuZXMgSHV0IFNvbHZlclxuICovXG52YXIgQmFybmVzSHV0U29sdmVyID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHt7cGh5c2ljc05vZGVJbmRpY2VzOiBBcnJheSwgcGh5c2ljc0VkZ2VJbmRpY2VzOiBBcnJheSwgZm9yY2VzOiB7fSwgdmVsb2NpdGllczoge319fSBwaHlzaWNzQm9keVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gQmFybmVzSHV0U29sdmVyKGJvZHksIHBoeXNpY3NCb2R5LCBvcHRpb25zKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgQmFybmVzSHV0U29sdmVyKTtcblxuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5waHlzaWNzQm9keSA9IHBoeXNpY3NCb2R5O1xuICAgIHRoaXMuYmFybmVzSHV0VHJlZTtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgdGhpcy5yYW5kb21TZWVkID0gNTtcblxuICAgIC8vIGRlYnVnOiBzaG93IGdyaWRcbiAgICAvLyB0aGlzLmJvZHkuZW1pdHRlci5vbihcImFmdGVyRHJhd2luZ1wiLCAoY3R4KSA9PiB7dGhpcy5fZGVidWcoY3R4LCcjZmYwMDAwJyl9KVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoQmFybmVzSHV0U29sdmVyLCBbe1xuICAgIGtleTogJ3NldE9wdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICB0aGlzLnRoZXRhSW52ZXJzZWQgPSAxIC8gdGhpcy5vcHRpb25zLnRoZXRhO1xuXG4gICAgICAvLyBpZiAxIHRoZW4gbWluIGRpc3RhbmNlID0gMC41LCBpZiAwLjUgdGhlbiBtaW4gZGlzdGFuY2UgPSAwLjUgKyAwLjUqbm9kZS5zaGFwZS5yYWRpdXNcbiAgICAgIHRoaXMub3ZlcmxhcEF2b2lkYW5jZUZhY3RvciA9IDEgLSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCB0aGlzLm9wdGlvbnMuYXZvaWRPdmVybGFwKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSByYW5kb20gaW50ZWdlclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZWVkZWRSYW5kb20nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWVkZWRSYW5kb20oKSB7XG4gICAgICB2YXIgeCA9IE1hdGguc2luKHRoaXMucmFuZG9tU2VlZCsrKSAqIDEwMDAwO1xuICAgICAgcmV0dXJuIHggLSBNYXRoLmZsb29yKHgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyB0aGUgZm9yY2VzIHRoZSBub2RlcyBhcHBseSBvbiBlYWNoIG90aGVyIGJhc2VkIG9uIGEgZ3Jhdml0YXRpb25hbCBtb2RlbC5cbiAgICAgKiBUaGUgQmFybmVzIEh1dCBtZXRob2QgaXMgdXNlZCB0byBzcGVlZCB1cCB0aGlzIE4tYm9keSBzaW11bGF0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc29sdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzb2x2ZSgpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZ3Jhdml0YXRpb25hbENvbnN0YW50ICE9PSAwICYmIHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIG5vZGUgPSB2b2lkIDA7XG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgICAgdmFyIG5vZGVJbmRpY2VzID0gdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXM7XG4gICAgICAgIHZhciBub2RlQ291bnQgPSBub2RlSW5kaWNlcy5sZW5ndGg7XG5cbiAgICAgICAgLy8gY3JlYXRlIHRoZSB0cmVlXG4gICAgICAgIHZhciBiYXJuZXNIdXRUcmVlID0gdGhpcy5fZm9ybUJhcm5lc0h1dFRyZWUobm9kZXMsIG5vZGVJbmRpY2VzKTtcblxuICAgICAgICAvLyBmb3IgZGVidWdnaW5nXG4gICAgICAgIHRoaXMuYmFybmVzSHV0VHJlZSA9IGJhcm5lc0h1dFRyZWU7XG5cbiAgICAgICAgLy8gcGxhY2UgdGhlIG5vZGVzIG9uZSBieSBvbmUgcmVjdXJzaXZlbHlcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlQ291bnQ7IGkrKykge1xuICAgICAgICAgIG5vZGUgPSBub2Rlc1tub2RlSW5kaWNlc1tpXV07XG4gICAgICAgICAgaWYgKG5vZGUub3B0aW9ucy5tYXNzID4gMCkge1xuICAgICAgICAgICAgLy8gc3RhcnRpbmcgd2l0aCByb290IGlzIGlycmVsZXZhbnQsIGl0IG5ldmVyIHBhc3NlcyB0aGUgQmFybmVzSHV0U29sdmVyIGNvbmRpdGlvblxuICAgICAgICAgICAgdGhpcy5fZ2V0Rm9yY2VDb250cmlidXRpb25zKGJhcm5lc0h1dFRyZWUucm9vdCwgbm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmVudEJyYW5jaFxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19nZXRGb3JjZUNvbnRyaWJ1dGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Rm9yY2VDb250cmlidXRpb25zKHBhcmVudEJyYW5jaCwgbm9kZSkge1xuICAgICAgdGhpcy5fZ2V0Rm9yY2VDb250cmlidXRpb24ocGFyZW50QnJhbmNoLmNoaWxkcmVuLk5XLCBub2RlKTtcbiAgICAgIHRoaXMuX2dldEZvcmNlQ29udHJpYnV0aW9uKHBhcmVudEJyYW5jaC5jaGlsZHJlbi5ORSwgbm9kZSk7XG4gICAgICB0aGlzLl9nZXRGb3JjZUNvbnRyaWJ1dGlvbihwYXJlbnRCcmFuY2guY2hpbGRyZW4uU1csIG5vZGUpO1xuICAgICAgdGhpcy5fZ2V0Rm9yY2VDb250cmlidXRpb24ocGFyZW50QnJhbmNoLmNoaWxkcmVuLlNFLCBub2RlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHRyYXZlcnNlcyB0aGUgYmFybmVzSHV0VHJlZS4gSXQgY2hlY2tzIHdoZW4gaXQgY2FuIGFwcHJveGltYXRlIGRpc3RhbnQgbm9kZXMgd2l0aCB0aGVpciBjZW50ZXIgb2YgbWFzcy5cbiAgICAgKiBJZiBhIHJlZ2lvbiBjb250YWlucyBhIHNpbmdsZSBub2RlLCB3ZSBjaGVjayBpZiBpdCBpcyBub3QgaXRzZWxmLCB0aGVuIHdlIGFwcGx5IHRoZSBmb3JjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnRCcmFuY2hcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZ2V0Rm9yY2VDb250cmlidXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Rm9yY2VDb250cmlidXRpb24ocGFyZW50QnJhbmNoLCBub2RlKSB7XG4gICAgICAvLyB3ZSBnZXQgbm8gZm9yY2UgY29udHJpYnV0aW9uIGZyb20gYW4gZW1wdHkgcmVnaW9uXG4gICAgICBpZiAocGFyZW50QnJhbmNoLmNoaWxkcmVuQ291bnQgPiAwKSB7XG4gICAgICAgIHZhciBkeCA9IHZvaWQgMCxcbiAgICAgICAgICAgIGR5ID0gdm9pZCAwLFxuICAgICAgICAgICAgZGlzdGFuY2UgPSB2b2lkIDA7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBjZW50ZXIgb2YgbWFzcyB0byB0aGUgbm9kZS5cbiAgICAgICAgZHggPSBwYXJlbnRCcmFuY2guY2VudGVyT2ZNYXNzLnggLSBub2RlLng7XG4gICAgICAgIGR5ID0gcGFyZW50QnJhbmNoLmNlbnRlck9mTWFzcy55IC0gbm9kZS55O1xuICAgICAgICBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgICAgICAgLy8gQmFybmVzSHV0U29sdmVyIGNvbmRpdGlvblxuICAgICAgICAvLyBvcmlnaW5hbCBjb25kaXRpb24gOiBzL2QgPCB0aGV0YSA9IHBhc3NlZCAgPT09ICBkL3MgPiAxL3RoZXRhID0gcGFzc2VkXG4gICAgICAgIC8vIGNhbGNTaXplID0gMS9zIC0tPiBkICogMS9zID4gMS90aGV0YSA9IHBhc3NlZFxuICAgICAgICBpZiAoZGlzdGFuY2UgKiBwYXJlbnRCcmFuY2guY2FsY1NpemUgPiB0aGlzLnRoZXRhSW52ZXJzZWQpIHtcbiAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVGb3JjZXMoZGlzdGFuY2UsIGR4LCBkeSwgbm9kZSwgcGFyZW50QnJhbmNoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBEaWQgbm90IHBhc3MgdGhlIGNvbmRpdGlvbiwgZ28gaW50byBjaGlsZHJlbiBpZiBhdmFpbGFibGVcbiAgICAgICAgICBpZiAocGFyZW50QnJhbmNoLmNoaWxkcmVuQ291bnQgPT09IDQpIHtcbiAgICAgICAgICAgIHRoaXMuX2dldEZvcmNlQ29udHJpYnV0aW9ucyhwYXJlbnRCcmFuY2gsIG5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBwYXJlbnRCcmFuY2ggbXVzdCBoYXZlIG9ubHkgb25lIG5vZGUsIGlmIGl0IHdhcyBlbXB0eSB3ZSB3b3VsZG50IGJlIGhlcmVcbiAgICAgICAgICAgIGlmIChwYXJlbnRCcmFuY2guY2hpbGRyZW4uZGF0YS5pZCAhPSBub2RlLmlkKSB7XG4gICAgICAgICAgICAgIC8vIGlmIGl0IGlzIG5vdCBzZWxmXG4gICAgICAgICAgICAgIHRoaXMuX2NhbGN1bGF0ZUZvcmNlcyhkaXN0YW5jZSwgZHgsIGR5LCBub2RlLCBwYXJlbnRCcmFuY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgZm9yY2VzIGJhc2VkIG9uIHRoZSBkaXN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkeVxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnRCcmFuY2hcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfY2FsY3VsYXRlRm9yY2VzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGN1bGF0ZUZvcmNlcyhkaXN0YW5jZSwgZHgsIGR5LCBub2RlLCBwYXJlbnRCcmFuY2gpIHtcbiAgICAgIGlmIChkaXN0YW5jZSA9PT0gMCkge1xuICAgICAgICBkaXN0YW5jZSA9IDAuMTtcbiAgICAgICAgZHggPSBkaXN0YW5jZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3ZlcmxhcEF2b2lkYW5jZUZhY3RvciA8IDEgJiYgbm9kZS5zaGFwZS5yYWRpdXMpIHtcbiAgICAgICAgZGlzdGFuY2UgPSBNYXRoLm1heCgwLjEgKyB0aGlzLm92ZXJsYXBBdm9pZGFuY2VGYWN0b3IgKiBub2RlLnNoYXBlLnJhZGl1cywgZGlzdGFuY2UgLSBub2RlLnNoYXBlLnJhZGl1cyk7XG4gICAgICB9XG5cbiAgICAgIC8vIHRoZSBkaXZpZGluZyBieSB0aGUgZGlzdGFuY2UgY3ViZWQgaW5zdGVhZCBvZiBzcXVhcmVkIGFsbG93cyB1cyB0byBnZXQgdGhlIGZ4IGFuZCBmeSBjb21wb25lbnRzIHdpdGhvdXQgc2luZXMgYW5kIGNvc2luZXNcbiAgICAgIC8vIGl0IGlzIHNob3J0aGFuZCBmb3IgZ3Jhdml0eWZvcmNlIHdpdGggZGlzdGFuY2Ugc3F1YXJlZCBhbmQgZnggPSBkeC9kaXN0YW5jZSAqIGdyYXZpdHlGb3JjZVxuICAgICAgdmFyIGdyYXZpdHlGb3JjZSA9IHRoaXMub3B0aW9ucy5ncmF2aXRhdGlvbmFsQ29uc3RhbnQgKiBwYXJlbnRCcmFuY2gubWFzcyAqIG5vZGUub3B0aW9ucy5tYXNzIC8gTWF0aC5wb3coZGlzdGFuY2UsIDMpO1xuICAgICAgdmFyIGZ4ID0gZHggKiBncmF2aXR5Rm9yY2U7XG4gICAgICB2YXIgZnkgPSBkeSAqIGdyYXZpdHlGb3JjZTtcblxuICAgICAgdGhpcy5waHlzaWNzQm9keS5mb3JjZXNbbm9kZS5pZF0ueCArPSBmeDtcbiAgICAgIHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGUuaWRdLnkgKz0gZnk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBjb25zdHJ1Y3RzIHRoZSBiYXJuZXNIdXQgdHJlZSByZWN1cnNpdmVseS4gSXQgY3JlYXRlcyB0aGUgcm9vdCwgc3BsaXRzIGl0IGFuZCBzdGFydHMgcGxhY2luZyB0aGUgbm9kZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOb2RlPn0gbm9kZXNcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBub2RlSW5kaWNlc1xuICAgICAqIEByZXR1cm5zIHt7cm9vdDoge2NlbnRlck9mTWFzczoge3g6IG51bWJlciwgeTogbnVtYmVyfSwgbWFzczogbnVtYmVyLCByYW5nZToge21pblg6IG51bWJlciwgbWF4WDogbnVtYmVyLCBtaW5ZOiBudW1iZXIsIG1heFk6IG51bWJlcn0sIHNpemU6IG51bWJlciwgY2FsY1NpemU6IG51bWJlciwgY2hpbGRyZW46IHtkYXRhOiBudWxsfSwgbWF4V2lkdGg6IG51bWJlciwgbGV2ZWw6IG51bWJlciwgY2hpbGRyZW5Db3VudDogbnVtYmVyfX19IEJhcm5lc0h1dFRyZWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZm9ybUJhcm5lc0h1dFRyZWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZm9ybUJhcm5lc0h1dFRyZWUobm9kZXMsIG5vZGVJbmRpY2VzKSB7XG4gICAgICB2YXIgbm9kZSA9IHZvaWQgMDtcbiAgICAgIHZhciBub2RlQ291bnQgPSBub2RlSW5kaWNlcy5sZW5ndGg7XG5cbiAgICAgIHZhciBtaW5YID0gbm9kZXNbbm9kZUluZGljZXNbMF1dLng7XG4gICAgICB2YXIgbWluWSA9IG5vZGVzW25vZGVJbmRpY2VzWzBdXS55O1xuICAgICAgdmFyIG1heFggPSBub2Rlc1tub2RlSW5kaWNlc1swXV0ueDtcbiAgICAgIHZhciBtYXhZID0gbm9kZXNbbm9kZUluZGljZXNbMF1dLnk7XG5cbiAgICAgIC8vIGdldCB0aGUgcmFuZ2Ugb2YgdGhlIG5vZGVzXG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IG5vZGVDb3VudDsgaSsrKSB7XG4gICAgICAgIHZhciBfbm9kZSA9IG5vZGVzW25vZGVJbmRpY2VzW2ldXTtcbiAgICAgICAgdmFyIHggPSBfbm9kZS54O1xuICAgICAgICB2YXIgeSA9IF9ub2RlLnk7XG4gICAgICAgIGlmIChfbm9kZS5vcHRpb25zLm1hc3MgPiAwKSB7XG4gICAgICAgICAgaWYgKHggPCBtaW5YKSB7XG4gICAgICAgICAgICBtaW5YID0geDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHggPiBtYXhYKSB7XG4gICAgICAgICAgICBtYXhYID0geDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHkgPCBtaW5ZKSB7XG4gICAgICAgICAgICBtaW5ZID0geTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHkgPiBtYXhZKSB7XG4gICAgICAgICAgICBtYXhZID0geTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIG1ha2UgdGhlIHJhbmdlIGEgc3F1YXJlXG4gICAgICB2YXIgc2l6ZURpZmYgPSBNYXRoLmFicyhtYXhYIC0gbWluWCkgLSBNYXRoLmFicyhtYXhZIC0gbWluWSk7IC8vIGRpZmZlcmVuY2UgYmV0d2VlbiBYIGFuZCBZXG4gICAgICBpZiAoc2l6ZURpZmYgPiAwKSB7XG4gICAgICAgIG1pblkgLT0gMC41ICogc2l6ZURpZmY7XG4gICAgICAgIG1heFkgKz0gMC41ICogc2l6ZURpZmY7XG4gICAgICB9IC8vIHhTaXplID4geVNpemVcbiAgICAgIGVsc2Uge1xuICAgICAgICAgIG1pblggKz0gMC41ICogc2l6ZURpZmY7XG4gICAgICAgICAgbWF4WCAtPSAwLjUgKiBzaXplRGlmZjtcbiAgICAgICAgfSAvLyB4U2l6ZSA8IHlTaXplXG5cbiAgICAgIHZhciBtaW5pbXVtVHJlZVNpemUgPSAxZS01O1xuICAgICAgdmFyIHJvb3RTaXplID0gTWF0aC5tYXgobWluaW11bVRyZWVTaXplLCBNYXRoLmFicyhtYXhYIC0gbWluWCkpO1xuICAgICAgdmFyIGhhbGZSb290U2l6ZSA9IDAuNSAqIHJvb3RTaXplO1xuICAgICAgdmFyIGNlbnRlclggPSAwLjUgKiAobWluWCArIG1heFgpLFxuICAgICAgICAgIGNlbnRlclkgPSAwLjUgKiAobWluWSArIG1heFkpO1xuXG4gICAgICAvLyBjb25zdHJ1Y3QgdGhlIGJhcm5lc0h1dFRyZWVcbiAgICAgIHZhciBiYXJuZXNIdXRUcmVlID0ge1xuICAgICAgICByb290OiB7XG4gICAgICAgICAgY2VudGVyT2ZNYXNzOiB7IHg6IDAsIHk6IDAgfSxcbiAgICAgICAgICBtYXNzOiAwLFxuICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICBtaW5YOiBjZW50ZXJYIC0gaGFsZlJvb3RTaXplLFxuICAgICAgICAgICAgbWF4WDogY2VudGVyWCArIGhhbGZSb290U2l6ZSxcbiAgICAgICAgICAgIG1pblk6IGNlbnRlclkgLSBoYWxmUm9vdFNpemUsXG4gICAgICAgICAgICBtYXhZOiBjZW50ZXJZICsgaGFsZlJvb3RTaXplXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzaXplOiByb290U2l6ZSxcbiAgICAgICAgICBjYWxjU2l6ZTogMSAvIHJvb3RTaXplLFxuICAgICAgICAgIGNoaWxkcmVuOiB7IGRhdGE6IG51bGwgfSxcbiAgICAgICAgICBtYXhXaWR0aDogMCxcbiAgICAgICAgICBsZXZlbDogMCxcbiAgICAgICAgICBjaGlsZHJlbkNvdW50OiA0XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLl9zcGxpdEJyYW5jaChiYXJuZXNIdXRUcmVlLnJvb3QpO1xuXG4gICAgICAvLyBwbGFjZSB0aGUgbm9kZXMgb25lIGJ5IG9uZSByZWN1cnNpdmVseVxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5vZGVDb3VudDsgX2krKykge1xuICAgICAgICBub2RlID0gbm9kZXNbbm9kZUluZGljZXNbX2ldXTtcbiAgICAgICAgaWYgKG5vZGUub3B0aW9ucy5tYXNzID4gMCkge1xuICAgICAgICAgIHRoaXMuX3BsYWNlSW5UcmVlKGJhcm5lc0h1dFRyZWUucm9vdCwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gbWFrZSBnbG9iYWxcbiAgICAgIHJldHVybiBiYXJuZXNIdXRUcmVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRoaXMgdXBkYXRlcyB0aGUgbWFzcyBvZiBhIGJyYW5jaC4gdGhpcyBpcyBpbmNyZWFzZWQgYnkgYWRkaW5nIGEgbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnRCcmFuY2hcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfdXBkYXRlQnJhbmNoTWFzcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVCcmFuY2hNYXNzKHBhcmVudEJyYW5jaCwgbm9kZSkge1xuICAgICAgdmFyIGNlbnRlck9mTWFzcyA9IHBhcmVudEJyYW5jaC5jZW50ZXJPZk1hc3M7XG4gICAgICB2YXIgdG90YWxNYXNzID0gcGFyZW50QnJhbmNoLm1hc3MgKyBub2RlLm9wdGlvbnMubWFzcztcbiAgICAgIHZhciB0b3RhbE1hc3NJbnYgPSAxIC8gdG90YWxNYXNzO1xuXG4gICAgICBjZW50ZXJPZk1hc3MueCA9IGNlbnRlck9mTWFzcy54ICogcGFyZW50QnJhbmNoLm1hc3MgKyBub2RlLnggKiBub2RlLm9wdGlvbnMubWFzcztcbiAgICAgIGNlbnRlck9mTWFzcy54ICo9IHRvdGFsTWFzc0ludjtcblxuICAgICAgY2VudGVyT2ZNYXNzLnkgPSBjZW50ZXJPZk1hc3MueSAqIHBhcmVudEJyYW5jaC5tYXNzICsgbm9kZS55ICogbm9kZS5vcHRpb25zLm1hc3M7XG4gICAgICBjZW50ZXJPZk1hc3MueSAqPSB0b3RhbE1hc3NJbnY7XG5cbiAgICAgIHBhcmVudEJyYW5jaC5tYXNzID0gdG90YWxNYXNzO1xuICAgICAgdmFyIGJpZ2dlc3RTaXplID0gTWF0aC5tYXgoTWF0aC5tYXgobm9kZS5oZWlnaHQsIG5vZGUucmFkaXVzKSwgbm9kZS53aWR0aCk7XG4gICAgICBwYXJlbnRCcmFuY2gubWF4V2lkdGggPSBwYXJlbnRCcmFuY2gubWF4V2lkdGggPCBiaWdnZXN0U2l6ZSA/IGJpZ2dlc3RTaXplIDogcGFyZW50QnJhbmNoLm1heFdpZHRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGRldGVybWluZSBpbiB3aGljaCBicmFuY2ggdGhlIG5vZGUgd2lsbCBiZSBwbGFjZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyZW50QnJhbmNoXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBza2lwTWFzc1VwZGF0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19wbGFjZUluVHJlZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wbGFjZUluVHJlZShwYXJlbnRCcmFuY2gsIG5vZGUsIHNraXBNYXNzVXBkYXRlKSB7XG4gICAgICBpZiAoc2tpcE1hc3NVcGRhdGUgIT0gdHJ1ZSB8fCBza2lwTWFzc1VwZGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgbWFzcyBvZiB0aGUgYnJhbmNoLlxuICAgICAgICB0aGlzLl91cGRhdGVCcmFuY2hNYXNzKHBhcmVudEJyYW5jaCwgbm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByYW5nZSA9IHBhcmVudEJyYW5jaC5jaGlsZHJlbi5OVy5yYW5nZTtcbiAgICAgIHZhciByZWdpb24gPSB2b2lkIDA7XG4gICAgICBpZiAocmFuZ2UubWF4WCA+IG5vZGUueCkge1xuICAgICAgICAvLyBpbiBOVyBvciBTV1xuICAgICAgICBpZiAocmFuZ2UubWF4WSA+IG5vZGUueSkge1xuICAgICAgICAgIHJlZ2lvbiA9ICdOVyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVnaW9uID0gJ1NXJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaW4gTkUgb3IgU0VcbiAgICAgICAgaWYgKHJhbmdlLm1heFkgPiBub2RlLnkpIHtcbiAgICAgICAgICByZWdpb24gPSAnTkUnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZ2lvbiA9ICdTRSc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fcGxhY2VJblJlZ2lvbihwYXJlbnRCcmFuY2gsIG5vZGUsIHJlZ2lvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYWN0dWFsbHkgcGxhY2UgdGhlIG5vZGUgaW4gYSByZWdpb24gKG9yIGJyYW5jaClcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnRCcmFuY2hcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcGFyYW0geydOVyd8ICdORScgfCAnU1cnIHwgJ1NFJ30gcmVnaW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3BsYWNlSW5SZWdpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGxhY2VJblJlZ2lvbihwYXJlbnRCcmFuY2gsIG5vZGUsIHJlZ2lvbikge1xuICAgICAgdmFyIGNoaWxkcmVuID0gcGFyZW50QnJhbmNoLmNoaWxkcmVuW3JlZ2lvbl07XG5cbiAgICAgIHN3aXRjaCAoY2hpbGRyZW4uY2hpbGRyZW5Db3VudCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgLy8gcGxhY2Ugbm9kZSBoZXJlXG4gICAgICAgICAgY2hpbGRyZW4uY2hpbGRyZW4uZGF0YSA9IG5vZGU7XG4gICAgICAgICAgY2hpbGRyZW4uY2hpbGRyZW5Db3VudCA9IDE7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlQnJhbmNoTWFzcyhjaGlsZHJlbiwgbm9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAvLyBjb252ZXJ0IGludG8gY2hpbGRyZW5cbiAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgdHdvIG5vZGVzIGV4YWN0bHkgb3ZlcmxhcHBpbmcgKG9uIGluaXQsIG9uIG9wZW5pbmcgb2YgY2x1c3RlciBldGMuKVxuICAgICAgICAgIC8vIHdlIG1vdmUgb25lIG5vZGUgYSBsaXR0bGUgYml0IGFuZCB3ZSBkbyBub3QgcHV0IGl0IGluIHRoZSB0cmVlLlxuICAgICAgICAgIGlmIChjaGlsZHJlbi5jaGlsZHJlbi5kYXRhLnggPT09IG5vZGUueCAmJiBjaGlsZHJlbi5jaGlsZHJlbi5kYXRhLnkgPT09IG5vZGUueSkge1xuICAgICAgICAgICAgbm9kZS54ICs9IHRoaXMuc2VlZGVkUmFuZG9tKCk7XG4gICAgICAgICAgICBub2RlLnkgKz0gdGhpcy5zZWVkZWRSYW5kb20oKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc3BsaXRCcmFuY2goY2hpbGRyZW4pO1xuICAgICAgICAgICAgdGhpcy5fcGxhY2VJblRyZWUoY2hpbGRyZW4sIG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIC8vIHBsYWNlIGluIGJyYW5jaFxuICAgICAgICAgIHRoaXMuX3BsYWNlSW5UcmVlKGNoaWxkcmVuLCBub2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0aGlzIGZ1bmN0aW9uIHNwbGl0cyBhIGJyYW5jaCBpbnRvIDQgc3ViIGJyYW5jaGVzLiBJZiB0aGUgYnJhbmNoIGNvbnRhaW5lZCBhIG5vZGUsIHdlIHBsYWNlIGl0IGluIHRoZSBzdWJicmFuY2hcbiAgICAgKiBhZnRlciB0aGUgc3BsaXQgaXMgY29tcGxldGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyZW50QnJhbmNoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3NwbGl0QnJhbmNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NwbGl0QnJhbmNoKHBhcmVudEJyYW5jaCkge1xuICAgICAgLy8gaWYgdGhlIGJyYW5jaCBpcyBzaGFkZWQgd2l0aCBhIG5vZGUsIHJlcGxhY2UgdGhlIG5vZGUgaW4gdGhlIG5ldyBzdWJzZXQuXG4gICAgICB2YXIgY29udGFpbmVkTm9kZSA9IG51bGw7XG4gICAgICBpZiAocGFyZW50QnJhbmNoLmNoaWxkcmVuQ291bnQgPT09IDEpIHtcbiAgICAgICAgY29udGFpbmVkTm9kZSA9IHBhcmVudEJyYW5jaC5jaGlsZHJlbi5kYXRhO1xuICAgICAgICBwYXJlbnRCcmFuY2gubWFzcyA9IDA7XG4gICAgICAgIHBhcmVudEJyYW5jaC5jZW50ZXJPZk1hc3MueCA9IDA7XG4gICAgICAgIHBhcmVudEJyYW5jaC5jZW50ZXJPZk1hc3MueSA9IDA7XG4gICAgICB9XG4gICAgICBwYXJlbnRCcmFuY2guY2hpbGRyZW5Db3VudCA9IDQ7XG4gICAgICBwYXJlbnRCcmFuY2guY2hpbGRyZW4uZGF0YSA9IG51bGw7XG4gICAgICB0aGlzLl9pbnNlcnRSZWdpb24ocGFyZW50QnJhbmNoLCAnTlcnKTtcbiAgICAgIHRoaXMuX2luc2VydFJlZ2lvbihwYXJlbnRCcmFuY2gsICdORScpO1xuICAgICAgdGhpcy5faW5zZXJ0UmVnaW9uKHBhcmVudEJyYW5jaCwgJ1NXJyk7XG4gICAgICB0aGlzLl9pbnNlcnRSZWdpb24ocGFyZW50QnJhbmNoLCAnU0UnKTtcblxuICAgICAgaWYgKGNvbnRhaW5lZE5vZGUgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9wbGFjZUluVHJlZShwYXJlbnRCcmFuY2gsIGNvbnRhaW5lZE5vZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc3ViZGl2aWRlcyB0aGUgcmVnaW9uIGludG8gZm91ciBuZXcgc2VnbWVudHMuXG4gICAgICogU3BlY2lmaWNhbGx5LCB0aGlzIGluc2VydHMgYSBzaW5nbGUgbmV3IHNlZ21lbnQuXG4gICAgICogSXQgZmlsbHMgdGhlIGNoaWxkcmVuIHNlY3Rpb24gb2YgdGhlIHBhcmVudEJyYW5jaFxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmVudEJyYW5jaFxuICAgICAqIEBwYXJhbSB7J05XJ3wgJ05FJyB8ICdTVycgfCAnU0UnfSByZWdpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfaW5zZXJ0UmVnaW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luc2VydFJlZ2lvbihwYXJlbnRCcmFuY2gsIHJlZ2lvbikge1xuICAgICAgdmFyIG1pblggPSB2b2lkIDAsXG4gICAgICAgICAgbWF4WCA9IHZvaWQgMCxcbiAgICAgICAgICBtaW5ZID0gdm9pZCAwLFxuICAgICAgICAgIG1heFkgPSB2b2lkIDA7XG4gICAgICB2YXIgY2hpbGRTaXplID0gMC41ICogcGFyZW50QnJhbmNoLnNpemU7XG4gICAgICBzd2l0Y2ggKHJlZ2lvbikge1xuICAgICAgICBjYXNlICdOVyc6XG4gICAgICAgICAgbWluWCA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5YO1xuICAgICAgICAgIG1heFggPSBwYXJlbnRCcmFuY2gucmFuZ2UubWluWCArIGNoaWxkU2l6ZTtcbiAgICAgICAgICBtaW5ZID0gcGFyZW50QnJhbmNoLnJhbmdlLm1pblk7XG4gICAgICAgICAgbWF4WSA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5ZICsgY2hpbGRTaXplO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdORSc6XG4gICAgICAgICAgbWluWCA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5YICsgY2hpbGRTaXplO1xuICAgICAgICAgIG1heFggPSBwYXJlbnRCcmFuY2gucmFuZ2UubWF4WDtcbiAgICAgICAgICBtaW5ZID0gcGFyZW50QnJhbmNoLnJhbmdlLm1pblk7XG4gICAgICAgICAgbWF4WSA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5ZICsgY2hpbGRTaXplO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdTVyc6XG4gICAgICAgICAgbWluWCA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5YO1xuICAgICAgICAgIG1heFggPSBwYXJlbnRCcmFuY2gucmFuZ2UubWluWCArIGNoaWxkU2l6ZTtcbiAgICAgICAgICBtaW5ZID0gcGFyZW50QnJhbmNoLnJhbmdlLm1pblkgKyBjaGlsZFNpemU7XG4gICAgICAgICAgbWF4WSA9IHBhcmVudEJyYW5jaC5yYW5nZS5tYXhZO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdTRSc6XG4gICAgICAgICAgbWluWCA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5YICsgY2hpbGRTaXplO1xuICAgICAgICAgIG1heFggPSBwYXJlbnRCcmFuY2gucmFuZ2UubWF4WDtcbiAgICAgICAgICBtaW5ZID0gcGFyZW50QnJhbmNoLnJhbmdlLm1pblkgKyBjaGlsZFNpemU7XG4gICAgICAgICAgbWF4WSA9IHBhcmVudEJyYW5jaC5yYW5nZS5tYXhZO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBwYXJlbnRCcmFuY2guY2hpbGRyZW5bcmVnaW9uXSA9IHtcbiAgICAgICAgY2VudGVyT2ZNYXNzOiB7IHg6IDAsIHk6IDAgfSxcbiAgICAgICAgbWFzczogMCxcbiAgICAgICAgcmFuZ2U6IHsgbWluWDogbWluWCwgbWF4WDogbWF4WCwgbWluWTogbWluWSwgbWF4WTogbWF4WSB9LFxuICAgICAgICBzaXplOiAwLjUgKiBwYXJlbnRCcmFuY2guc2l6ZSxcbiAgICAgICAgY2FsY1NpemU6IDIgKiBwYXJlbnRCcmFuY2guY2FsY1NpemUsXG4gICAgICAgIGNoaWxkcmVuOiB7IGRhdGE6IG51bGwgfSxcbiAgICAgICAgbWF4V2lkdGg6IDAsXG4gICAgICAgIGxldmVsOiBwYXJlbnRCcmFuY2gubGV2ZWwgKyAxLFxuICAgICAgICBjaGlsZHJlbkNvdW50OiAwXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICBERUJVR0dJTkcgQkVMT1cgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGZvciBkZWJ1Z2dpbmcgcHVycG9zZWQsIGl0IGRyYXdzIHRoZSB0cmVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19kZWJ1ZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWJ1ZyhjdHgsIGNvbG9yKSB7XG4gICAgICBpZiAodGhpcy5iYXJuZXNIdXRUcmVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XG5cbiAgICAgICAgdGhpcy5fZHJhd0JyYW5jaCh0aGlzLmJhcm5lc0h1dFRyZWUucm9vdCwgY3R4LCBjb2xvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLiBJdCBkcmF3cyB0aGUgYnJhbmNoZXMgcmVjdXJzaXZlbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYnJhbmNoXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19kcmF3QnJhbmNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdCcmFuY2goYnJhbmNoLCBjdHgsIGNvbG9yKSB7XG4gICAgICBpZiAoY29sb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb2xvciA9ICcjRkYwMDAwJztcbiAgICAgIH1cblxuICAgICAgaWYgKGJyYW5jaC5jaGlsZHJlbkNvdW50ID09PSA0KSB7XG4gICAgICAgIHRoaXMuX2RyYXdCcmFuY2goYnJhbmNoLmNoaWxkcmVuLk5XLCBjdHgpO1xuICAgICAgICB0aGlzLl9kcmF3QnJhbmNoKGJyYW5jaC5jaGlsZHJlbi5ORSwgY3R4KTtcbiAgICAgICAgdGhpcy5fZHJhd0JyYW5jaChicmFuY2guY2hpbGRyZW4uU0UsIGN0eCk7XG4gICAgICAgIHRoaXMuX2RyYXdCcmFuY2goYnJhbmNoLmNoaWxkcmVuLlNXLCBjdHgpO1xuICAgICAgfVxuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKGJyYW5jaC5yYW5nZS5taW5YLCBicmFuY2gucmFuZ2UubWluWSk7XG4gICAgICBjdHgubGluZVRvKGJyYW5jaC5yYW5nZS5tYXhYLCBicmFuY2gucmFuZ2UubWluWSk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8oYnJhbmNoLnJhbmdlLm1heFgsIGJyYW5jaC5yYW5nZS5taW5ZKTtcbiAgICAgIGN0eC5saW5lVG8oYnJhbmNoLnJhbmdlLm1heFgsIGJyYW5jaC5yYW5nZS5tYXhZKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyhicmFuY2gucmFuZ2UubWF4WCwgYnJhbmNoLnJhbmdlLm1heFkpO1xuICAgICAgY3R4LmxpbmVUbyhicmFuY2gucmFuZ2UubWluWCwgYnJhbmNoLnJhbmdlLm1heFkpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKGJyYW5jaC5yYW5nZS5taW5YLCBicmFuY2gucmFuZ2UubWF4WSk7XG4gICAgICBjdHgubGluZVRvKGJyYW5jaC5yYW5nZS5taW5YLCBicmFuY2gucmFuZ2UubWluWSk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgIC8qXG4gICAgICAgaWYgKGJyYW5jaC5tYXNzID4gMCkge1xuICAgICAgIGN0eC5jaXJjbGUoYnJhbmNoLmNlbnRlck9mTWFzcy54LCBicmFuY2guY2VudGVyT2ZNYXNzLnksIDMqYnJhbmNoLm1hc3MpO1xuICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICB9XG4gICAgICAgKi9cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEJhcm5lc0h1dFNvbHZlcjtcbn0oKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gQmFybmVzSHV0U29sdmVyO1xuXG4vKioqLyB9KSxcbi8qIDgyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbi8qKlxuICogQ2VudHJhbCBHcmF2aXR5IFNvbHZlclxuICovXG52YXIgQ2VudHJhbEdyYXZpdHlTb2x2ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge3twaHlzaWNzTm9kZUluZGljZXM6IEFycmF5LCBwaHlzaWNzRWRnZUluZGljZXM6IEFycmF5LCBmb3JjZXM6IHt9LCB2ZWxvY2l0aWVzOiB7fX19IHBoeXNpY3NCb2R5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBDZW50cmFsR3Jhdml0eVNvbHZlcihib2R5LCBwaHlzaWNzQm9keSwgb3B0aW9ucykge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szW1wiZGVmYXVsdFwiXSkodGhpcywgQ2VudHJhbEdyYXZpdHlTb2x2ZXIpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLnBoeXNpY3NCb2R5ID0gcGh5c2ljc0JvZHk7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbXCJkZWZhdWx0XCJdKShDZW50cmFsR3Jhdml0eVNvbHZlciwgW3tcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyBmb3JjZXMgZm9yIGVhY2ggbm9kZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic29sdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc29sdmUoKSB7XG4gICAgICB2YXIgZHggPSB2b2lkIDAsXG4gICAgICAgICAgZHkgPSB2b2lkIDAsXG4gICAgICAgICAgZGlzdGFuY2UgPSB2b2lkIDAsXG4gICAgICAgICAgbm9kZSA9IHZvaWQgMDtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIHZhciBub2RlSW5kaWNlcyA9IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzO1xuICAgICAgdmFyIGZvcmNlcyA9IHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlSWQgPSBub2RlSW5kaWNlc1tpXTtcbiAgICAgICAgbm9kZSA9IG5vZGVzW25vZGVJZF07XG4gICAgICAgIGR4ID0gLW5vZGUueDtcbiAgICAgICAgZHkgPSAtbm9kZS55O1xuICAgICAgICBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgICAgICAgdGhpcy5fY2FsY3VsYXRlRm9yY2VzKGRpc3RhbmNlLCBkeCwgZHksIGZvcmNlcywgbm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBmb3JjZXMgYmFzZWQgb24gdGhlIGRpc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkeVxuICAgICAqIEBwYXJhbSB7T2JqZWN0PE5vZGUuaWQsIHZpcy5Ob2RlPn0gZm9yY2VzXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jYWxjdWxhdGVGb3JjZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGN1bGF0ZUZvcmNlcyhkaXN0YW5jZSwgZHgsIGR5LCBmb3JjZXMsIG5vZGUpIHtcbiAgICAgIHZhciBncmF2aXR5Rm9yY2UgPSBkaXN0YW5jZSA9PT0gMCA/IDAgOiB0aGlzLm9wdGlvbnMuY2VudHJhbEdyYXZpdHkgLyBkaXN0YW5jZTtcbiAgICAgIGZvcmNlc1tub2RlLmlkXS54ID0gZHggKiBncmF2aXR5Rm9yY2U7XG4gICAgICBmb3JjZXNbbm9kZS5pZF0ueSA9IGR5ICogZ3Jhdml0eUZvcmNlO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ2VudHJhbEdyYXZpdHlTb2x2ZXI7XG59KCk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gQ2VudHJhbEdyYXZpdHlTb2x2ZXI7XG5cbi8qKiovIH0pLFxuLyogODMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4OCk7XG5cbi8qKiovIH0pLFxuLyogODQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8qKlxuICogVGhpcyBvYmplY3QgY29udGFpbnMgYWxsIHBvc3NpYmxlIG9wdGlvbnMuIEl0IHdpbGwgY2hlY2sgaWYgdGhlIHR5cGVzIGFyZSBjb3JyZWN0LCBpZiByZXF1aXJlZCBpZiB0aGUgb3B0aW9uIGlzIG9uZVxuICogb2YgdGhlIGFsbG93ZWQgdmFsdWVzLlxuICpcbiAqIF9fYW55X18gbWVhbnMgdGhhdCB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgZG9lcyBub3QgbWF0dGVyLlxuICogX190eXBlX18gaXMgYSByZXF1aXJlZCBmaWVsZCBmb3IgYWxsIG9iamVjdHMgYW5kIGNvbnRhaW5zIHRoZSBhbGxvd2VkIHR5cGVzIG9mIGFsbCBvYmplY3RzXG4gKi9cbnZhciBzdHJpbmcgPSAnc3RyaW5nJztcbnZhciBib29sID0gJ2Jvb2xlYW4nO1xudmFyIG51bWJlciA9ICdudW1iZXInO1xudmFyIGFycmF5ID0gJ2FycmF5JztcbnZhciBvYmplY3QgPSAnb2JqZWN0JzsgLy8gc2hvdWxkIG9ubHkgYmUgaW4gYSBfX3R5cGVfXyBwcm9wZXJ0eVxudmFyIGRvbSA9ICdkb20nO1xudmFyIGFueSA9ICdhbnknO1xuXG4vLyBMaXN0IG9mIGVuZHBvaW50c1xudmFyIGVuZFBvaW50cyA9IFsnYXJyb3cnLCAnY2lyY2xlJywgJ2JhciddO1xuXG52YXIgYWxsT3B0aW9ucyA9IHtcbiAgY29uZmlndXJlOiB7XG4gICAgZW5hYmxlZDogeyBib29sZWFuOiBib29sIH0sXG4gICAgZmlsdGVyOiB7IGJvb2xlYW46IGJvb2wsIHN0cmluZzogc3RyaW5nLCBhcnJheTogYXJyYXksICdmdW5jdGlvbic6ICdmdW5jdGlvbicgfSxcbiAgICBjb250YWluZXI6IHsgZG9tOiBkb20gfSxcbiAgICBzaG93QnV0dG9uOiB7IGJvb2xlYW46IGJvb2wgfSxcbiAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgYm9vbGVhbjogYm9vbCwgc3RyaW5nOiBzdHJpbmcsIGFycmF5OiBhcnJheSwgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9XG4gIH0sXG4gIGVkZ2VzOiB7XG4gICAgYXJyb3dzOiB7XG4gICAgICB0bzoge1xuICAgICAgICBlbmFibGVkOiB7IGJvb2xlYW46IGJvb2wgfSxcbiAgICAgICAgc2NhbGVGYWN0b3I6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgdHlwZTogeyBzdHJpbmc6IGVuZFBvaW50cyB9LFxuICAgICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgYm9vbGVhbjogYm9vbCB9XG4gICAgICB9LFxuICAgICAgbWlkZGxlOiB7XG4gICAgICAgIGVuYWJsZWQ6IHsgYm9vbGVhbjogYm9vbCB9LFxuICAgICAgICBzY2FsZUZhY3RvcjogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICB0eXBlOiB7IHN0cmluZzogZW5kUG9pbnRzIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBib29sZWFuOiBib29sIH1cbiAgICAgIH0sXG4gICAgICBmcm9tOiB7XG4gICAgICAgIGVuYWJsZWQ6IHsgYm9vbGVhbjogYm9vbCB9LFxuICAgICAgICBzY2FsZUZhY3RvcjogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICB0eXBlOiB7IHN0cmluZzogZW5kUG9pbnRzIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBib29sZWFuOiBib29sIH1cbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzogeyBzdHJpbmc6IFsnZnJvbScsICd0bycsICdtaWRkbGUnXSwgb2JqZWN0OiBvYmplY3QgfVxuICAgIH0sXG4gICAgYXJyb3dTdHJpa2V0aHJvdWdoOiB7IGJvb2xlYW46IGJvb2wgfSxcbiAgICBiYWNrZ3JvdW5kOiB7XG4gICAgICBlbmFibGVkOiB7IGJvb2xlYW46IGJvb2wgfSxcbiAgICAgIGNvbG9yOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICBzaXplOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICBkYXNoZXM6IHsgYm9vbGVhbjogYm9vbCwgYXJyYXk6IGFycmF5IH0sXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgYm9vbGVhbjogYm9vbCB9XG4gICAgfSxcbiAgICBjaG9zZW46IHtcbiAgICAgIGxhYmVsOiB7IGJvb2xlYW46IGJvb2wsICdmdW5jdGlvbic6ICdmdW5jdGlvbicgfSxcbiAgICAgIGVkZ2U6IHsgYm9vbGVhbjogYm9vbCwgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIGJvb2xlYW46IGJvb2wgfVxuICAgIH0sXG4gICAgY29sb3I6IHtcbiAgICAgIGNvbG9yOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICBoaWdobGlnaHQ6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgIGhvdmVyOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICBpbmhlcml0OiB7IHN0cmluZzogWydmcm9tJywgJ3RvJywgJ2JvdGgnXSwgYm9vbGVhbjogYm9vbCB9LFxuICAgICAgb3BhY2l0eTogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIHN0cmluZzogc3RyaW5nIH1cbiAgICB9LFxuICAgIGRhc2hlczogeyBib29sZWFuOiBib29sLCBhcnJheTogYXJyYXkgfSxcbiAgICBmb250OiB7XG4gICAgICBjb2xvcjogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgc2l6ZTogeyBudW1iZXI6IG51bWJlciB9LCAvLyBweFxuICAgICAgZmFjZTogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgYmFja2dyb3VuZDogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgc3Ryb2tlV2lkdGg6IHsgbnVtYmVyOiBudW1iZXIgfSwgLy8gcHhcbiAgICAgIHN0cm9rZUNvbG9yOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICBhbGlnbjogeyBzdHJpbmc6IFsnaG9yaXpvbnRhbCcsICd0b3AnLCAnbWlkZGxlJywgJ2JvdHRvbSddIH0sXG4gICAgICB2YWRqdXN0OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICBtdWx0aTogeyBib29sZWFuOiBib29sLCBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgYm9sZDoge1xuICAgICAgICBjb2xvcjogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgICBzaXplOiB7IG51bWJlcjogbnVtYmVyIH0sIC8vIHB4XG4gICAgICAgIGZhY2U6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgICAgbW9kOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgIHZhZGp1c3Q6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIHN0cmluZzogc3RyaW5nIH1cbiAgICAgIH0sXG4gICAgICBib2xkaXRhbDoge1xuICAgICAgICBjb2xvcjogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgICBzaXplOiB7IG51bWJlcjogbnVtYmVyIH0sIC8vIHB4XG4gICAgICAgIGZhY2U6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgICAgbW9kOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgIHZhZGp1c3Q6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIHN0cmluZzogc3RyaW5nIH1cbiAgICAgIH0sXG4gICAgICBpdGFsOiB7XG4gICAgICAgIGNvbG9yOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgIHNpemU6IHsgbnVtYmVyOiBudW1iZXIgfSwgLy8gcHhcbiAgICAgICAgZmFjZTogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgICBtb2Q6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgICAgdmFkanVzdDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgc3RyaW5nOiBzdHJpbmcgfVxuICAgICAgfSxcbiAgICAgIG1vbm86IHtcbiAgICAgICAgY29sb3I6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgICAgc2l6ZTogeyBudW1iZXI6IG51bWJlciB9LCAvLyBweFxuICAgICAgICBmYWNlOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgIG1vZDogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgICB2YWRqdXN0OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBzdHJpbmc6IHN0cmluZyB9XG4gICAgICB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIHN0cmluZzogc3RyaW5nIH1cbiAgICB9LFxuICAgIGhpZGRlbjogeyBib29sZWFuOiBib29sIH0sXG4gICAgaG92ZXJXaWR0aDogeyAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nLCBudW1iZXI6IG51bWJlciB9LFxuICAgIGxhYmVsOiB7IHN0cmluZzogc3RyaW5nLCB1bmRlZmluZWQ6ICd1bmRlZmluZWQnIH0sXG4gICAgbGFiZWxIaWdobGlnaHRCb2xkOiB7IGJvb2xlYW46IGJvb2wgfSxcbiAgICBsZW5ndGg6IHsgbnVtYmVyOiBudW1iZXIsIHVuZGVmaW5lZDogJ3VuZGVmaW5lZCcgfSxcbiAgICBwaHlzaWNzOiB7IGJvb2xlYW46IGJvb2wgfSxcbiAgICBzY2FsaW5nOiB7XG4gICAgICBtaW46IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIG1heDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgbGFiZWw6IHtcbiAgICAgICAgZW5hYmxlZDogeyBib29sZWFuOiBib29sIH0sXG4gICAgICAgIG1pbjogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBtYXg6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgbWF4VmlzaWJsZTogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBkcmF3VGhyZXNob2xkOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBib29sZWFuOiBib29sIH1cbiAgICAgIH0sXG4gICAgICBjdXN0b21TY2FsaW5nRnVuY3Rpb246IHsgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICAgIH0sXG4gICAgc2VsZWN0aW9uV2lkdGg6IHsgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJywgbnVtYmVyOiBudW1iZXIgfSxcbiAgICBzZWxmUmVmZXJlbmNlU2l6ZTogeyBudW1iZXI6IG51bWJlciB9LFxuICAgIHNoYWRvdzoge1xuICAgICAgZW5hYmxlZDogeyBib29sZWFuOiBib29sIH0sXG4gICAgICBjb2xvcjogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgc2l6ZTogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgeDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgeTogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIGJvb2xlYW46IGJvb2wgfVxuICAgIH0sXG4gICAgc21vb3RoOiB7XG4gICAgICBlbmFibGVkOiB7IGJvb2xlYW46IGJvb2wgfSxcbiAgICAgIHR5cGU6IHtcbiAgICAgICAgc3RyaW5nOiBbJ2R5bmFtaWMnLCAnY29udGludW91cycsICdkaXNjcmV0ZScsICdkaWFnb25hbENyb3NzJywgJ3N0cmFpZ2h0Q3Jvc3MnLCAnaG9yaXpvbnRhbCcsICd2ZXJ0aWNhbCcsICdjdXJ2ZWRDVycsICdjdXJ2ZWRDQ1cnLCAnY3ViaWNCZXppZXInXVxuICAgICAgfSxcbiAgICAgIHJvdW5kbmVzczogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgZm9yY2VEaXJlY3Rpb246IHtcbiAgICAgICAgc3RyaW5nOiBbJ2hvcml6b250YWwnLCAndmVydGljYWwnLCAnbm9uZSddLFxuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIGJvb2xlYW46IGJvb2wgfVxuICAgIH0sXG4gICAgdGl0bGU6IHsgc3RyaW5nOiBzdHJpbmcsIHVuZGVmaW5lZDogJ3VuZGVmaW5lZCcgfSxcbiAgICB3aWR0aDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgIHdpZHRoQ29uc3RyYWludDoge1xuICAgICAgbWF4aW11bTogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIGJvb2xlYW46IGJvb2wsIG51bWJlcjogbnVtYmVyIH1cbiAgICB9LFxuICAgIHZhbHVlOiB7IG51bWJlcjogbnVtYmVyLCB1bmRlZmluZWQ6ICd1bmRlZmluZWQnIH0sXG4gICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICB9LFxuICBncm91cHM6IHtcbiAgICB1c2VEZWZhdWx0R3JvdXBzOiB7IGJvb2xlYW46IGJvb2wgfSxcbiAgICBfX2FueV9fOiAnZ2V0IGZyb20gbm9kZXMsIHdpbGwgYmUgb3ZlcndyaXR0ZW4gYmVsb3cnLFxuICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0IH1cbiAgfSxcbiAgaW50ZXJhY3Rpb246IHtcbiAgICBkcmFnTm9kZXM6IHsgYm9vbGVhbjogYm9vbCB9LFxuICAgIGRyYWdWaWV3OiB7IGJvb2xlYW46IGJvb2wgfSxcbiAgICBoaWRlRWRnZXNPbkRyYWc6IHsgYm9vbGVhbjogYm9vbCB9LFxuICAgIGhpZGVFZGdlc09uWm9vbTogeyBib29sZWFuOiBib29sIH0sXG4gICAgaGlkZU5vZGVzT25EcmFnOiB7IGJvb2xlYW46IGJvb2wgfSxcbiAgICBob3ZlcjogeyBib29sZWFuOiBib29sIH0sXG4gICAga2V5Ym9hcmQ6IHtcbiAgICAgIGVuYWJsZWQ6IHsgYm9vbGVhbjogYm9vbCB9LFxuICAgICAgc3BlZWQ6IHtcbiAgICAgICAgeDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICB5OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIHpvb206IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICAgICAgfSxcbiAgICAgIGJpbmRUb1dpbmRvdzogeyBib29sZWFuOiBib29sIH0sXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgYm9vbGVhbjogYm9vbCB9XG4gICAgfSxcbiAgICBtdWx0aXNlbGVjdDogeyBib29sZWFuOiBib29sIH0sXG4gICAgbmF2aWdhdGlvbkJ1dHRvbnM6IHsgYm9vbGVhbjogYm9vbCB9LFxuICAgIHNlbGVjdGFibGU6IHsgYm9vbGVhbjogYm9vbCB9LFxuICAgIHNlbGVjdENvbm5lY3RlZEVkZ2VzOiB7IGJvb2xlYW46IGJvb2wgfSxcbiAgICBob3ZlckNvbm5lY3RlZEVkZ2VzOiB7IGJvb2xlYW46IGJvb2wgfSxcbiAgICB0b29sdGlwRGVsYXk6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICB6b29tVmlldzogeyBib29sZWFuOiBib29sIH0sXG4gICAgem9vbVNwZWVkOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICB9LFxuICBsYXlvdXQ6IHtcbiAgICByYW5kb21TZWVkOiB7IHVuZGVmaW5lZDogJ3VuZGVmaW5lZCcsIG51bWJlcjogbnVtYmVyIH0sXG4gICAgaW1wcm92ZWRMYXlvdXQ6IHsgYm9vbGVhbjogYm9vbCB9LFxuICAgIGhpZXJhcmNoaWNhbDoge1xuICAgICAgZW5hYmxlZDogeyBib29sZWFuOiBib29sIH0sXG4gICAgICBsZXZlbFNlcGFyYXRpb246IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIG5vZGVTcGFjaW5nOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICB0cmVlU3BhY2luZzogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgYmxvY2tTaGlmdGluZzogeyBib29sZWFuOiBib29sIH0sXG4gICAgICBlZGdlTWluaW1pemF0aW9uOiB7IGJvb2xlYW46IGJvb2wgfSxcbiAgICAgIHBhcmVudENlbnRyYWxpemF0aW9uOiB7IGJvb2xlYW46IGJvb2wgfSxcbiAgICAgIGRpcmVjdGlvbjogeyBzdHJpbmc6IFsnVUQnLCAnRFUnLCAnTFInLCAnUkwnXSB9LCAvLyBVRCwgRFUsIExSLCBSTFxuICAgICAgc29ydE1ldGhvZDogeyBzdHJpbmc6IFsnaHVic2l6ZScsICdkaXJlY3RlZCddIH0sIC8vIGh1YnNpemUsIGRpcmVjdGVkXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgYm9vbGVhbjogYm9vbCB9XG4gICAgfSxcbiAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gIH0sXG4gIG1hbmlwdWxhdGlvbjoge1xuICAgIGVuYWJsZWQ6IHsgYm9vbGVhbjogYm9vbCB9LFxuICAgIGluaXRpYWxseUFjdGl2ZTogeyBib29sZWFuOiBib29sIH0sXG4gICAgYWRkTm9kZTogeyBib29sZWFuOiBib29sLCAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nIH0sXG4gICAgYWRkRWRnZTogeyBib29sZWFuOiBib29sLCAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nIH0sXG4gICAgZWRpdE5vZGU6IHsgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgIGVkaXRFZGdlOiB7XG4gICAgICBlZGl0V2l0aG91dERyYWc6IHsgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIGJvb2xlYW46IGJvb2wsICdmdW5jdGlvbic6ICdmdW5jdGlvbicgfVxuICAgIH0sXG4gICAgZGVsZXRlTm9kZTogeyBib29sZWFuOiBib29sLCAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nIH0sXG4gICAgZGVsZXRlRWRnZTogeyBib29sZWFuOiBib29sLCAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nIH0sXG4gICAgY29udHJvbE5vZGVTdHlsZTogJ2dldCBmcm9tIG5vZGVzLCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJlbG93JyxcbiAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgYm9vbGVhbjogYm9vbCB9XG4gIH0sXG4gIG5vZGVzOiB7XG4gICAgYm9yZGVyV2lkdGg6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICBib3JkZXJXaWR0aFNlbGVjdGVkOiB7IG51bWJlcjogbnVtYmVyLCB1bmRlZmluZWQ6ICd1bmRlZmluZWQnIH0sXG4gICAgYnJva2VuSW1hZ2U6IHsgc3RyaW5nOiBzdHJpbmcsIHVuZGVmaW5lZDogJ3VuZGVmaW5lZCcgfSxcbiAgICBjaG9zZW46IHtcbiAgICAgIGxhYmVsOiB7IGJvb2xlYW46IGJvb2wsICdmdW5jdGlvbic6ICdmdW5jdGlvbicgfSxcbiAgICAgIG5vZGU6IHsgYm9vbGVhbjogYm9vbCwgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIGJvb2xlYW46IGJvb2wgfVxuICAgIH0sXG4gICAgY29sb3I6IHtcbiAgICAgIGJvcmRlcjogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgYmFja2dyb3VuZDogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgICBiYWNrZ3JvdW5kOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBzdHJpbmc6IHN0cmluZyB9XG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgIGJhY2tncm91bmQ6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIHN0cmluZzogc3RyaW5nIH1cbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgc3RyaW5nOiBzdHJpbmcgfVxuICAgIH0sXG4gICAgZml4ZWQ6IHtcbiAgICAgIHg6IHsgYm9vbGVhbjogYm9vbCB9LFxuICAgICAgeTogeyBib29sZWFuOiBib29sIH0sXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgYm9vbGVhbjogYm9vbCB9XG4gICAgfSxcbiAgICBmb250OiB7XG4gICAgICBhbGlnbjogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgY29sb3I6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgIHNpemU6IHsgbnVtYmVyOiBudW1iZXIgfSwgLy8gcHhcbiAgICAgIGZhY2U6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgIGJhY2tncm91bmQ6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgIHN0cm9rZVdpZHRoOiB7IG51bWJlcjogbnVtYmVyIH0sIC8vIHB4XG4gICAgICBzdHJva2VDb2xvcjogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgdmFkanVzdDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgbXVsdGk6IHsgYm9vbGVhbjogYm9vbCwgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgIGJvbGQ6IHtcbiAgICAgICAgY29sb3I6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgICAgc2l6ZTogeyBudW1iZXI6IG51bWJlciB9LCAvLyBweFxuICAgICAgICBmYWNlOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgIG1vZDogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgICB2YWRqdXN0OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBzdHJpbmc6IHN0cmluZyB9XG4gICAgICB9LFxuICAgICAgYm9sZGl0YWw6IHtcbiAgICAgICAgY29sb3I6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgICAgc2l6ZTogeyBudW1iZXI6IG51bWJlciB9LCAvLyBweFxuICAgICAgICBmYWNlOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgIG1vZDogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgICB2YWRqdXN0OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBzdHJpbmc6IHN0cmluZyB9XG4gICAgICB9LFxuICAgICAgaXRhbDoge1xuICAgICAgICBjb2xvcjogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgICBzaXplOiB7IG51bWJlcjogbnVtYmVyIH0sIC8vIHB4XG4gICAgICAgIGZhY2U6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgICAgbW9kOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgIHZhZGp1c3Q6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIHN0cmluZzogc3RyaW5nIH1cbiAgICAgIH0sXG4gICAgICBtb25vOiB7XG4gICAgICAgIGNvbG9yOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgIHNpemU6IHsgbnVtYmVyOiBudW1iZXIgfSwgLy8gcHhcbiAgICAgICAgZmFjZTogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgICBtb2Q6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgICAgdmFkanVzdDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgc3RyaW5nOiBzdHJpbmcgfVxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBzdHJpbmc6IHN0cmluZyB9XG4gICAgfSxcbiAgICBncm91cDogeyBzdHJpbmc6IHN0cmluZywgbnVtYmVyOiBudW1iZXIsIHVuZGVmaW5lZDogJ3VuZGVmaW5lZCcgfSxcbiAgICBoZWlnaHRDb25zdHJhaW50OiB7XG4gICAgICBtaW5pbXVtOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICB2YWxpZ246IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBib29sZWFuOiBib29sLCBudW1iZXI6IG51bWJlciB9XG4gICAgfSxcbiAgICBoaWRkZW46IHsgYm9vbGVhbjogYm9vbCB9LFxuICAgIGljb246IHtcbiAgICAgIGZhY2U6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgIGNvZGU6IHsgc3RyaW5nOiBzdHJpbmcgfSwgLy8nXFx1ZjAwNycsXG4gICAgICBzaXplOiB7IG51bWJlcjogbnVtYmVyIH0sIC8vNTAsXG4gICAgICBjb2xvcjogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICAgIH0sXG4gICAgaWQ6IHsgc3RyaW5nOiBzdHJpbmcsIG51bWJlcjogbnVtYmVyIH0sXG4gICAgaW1hZ2U6IHtcbiAgICAgIHNlbGVjdGVkOiB7IHN0cmluZzogc3RyaW5nLCB1bmRlZmluZWQ6ICd1bmRlZmluZWQnIH0sIC8vIC0tPiBVUkxcbiAgICAgIHVuc2VsZWN0ZWQ6IHsgc3RyaW5nOiBzdHJpbmcsIHVuZGVmaW5lZDogJ3VuZGVmaW5lZCcgfSwgLy8gLS0+IFVSTFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIHN0cmluZzogc3RyaW5nIH1cbiAgICB9LFxuICAgIGxhYmVsOiB7IHN0cmluZzogc3RyaW5nLCB1bmRlZmluZWQ6ICd1bmRlZmluZWQnIH0sXG4gICAgbGFiZWxIaWdobGlnaHRCb2xkOiB7IGJvb2xlYW46IGJvb2wgfSxcbiAgICBsZXZlbDogeyBudW1iZXI6IG51bWJlciwgdW5kZWZpbmVkOiAndW5kZWZpbmVkJyB9LFxuICAgIG1hcmdpbjoge1xuICAgICAgdG9wOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICByaWdodDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgYm90dG9tOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICBsZWZ0OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgbnVtYmVyOiBudW1iZXIgfVxuICAgIH0sXG4gICAgbWFzczogeyBudW1iZXI6IG51bWJlciB9LFxuICAgIHBoeXNpY3M6IHsgYm9vbGVhbjogYm9vbCB9LFxuICAgIHNjYWxpbmc6IHtcbiAgICAgIG1pbjogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgbWF4OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICBsYWJlbDoge1xuICAgICAgICBlbmFibGVkOiB7IGJvb2xlYW46IGJvb2wgfSxcbiAgICAgICAgbWluOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIG1heDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBtYXhWaXNpYmxlOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIGRyYXdUaHJlc2hvbGQ6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIGJvb2xlYW46IGJvb2wgfVxuICAgICAgfSxcbiAgICAgIGN1c3RvbVNjYWxpbmdGdW5jdGlvbjogeyAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nIH0sXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gICAgfSxcbiAgICBzaGFkb3c6IHtcbiAgICAgIGVuYWJsZWQ6IHsgYm9vbGVhbjogYm9vbCB9LFxuICAgICAgY29sb3I6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgIHNpemU6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIHg6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIHk6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBib29sZWFuOiBib29sIH1cbiAgICB9LFxuICAgIHNoYXBlOiB7XG4gICAgICBzdHJpbmc6IFsnZWxsaXBzZScsICdjaXJjbGUnLCAnZGF0YWJhc2UnLCAnYm94JywgJ3RleHQnLCAnaW1hZ2UnLCAnY2lyY3VsYXJJbWFnZScsICdkaWFtb25kJywgJ2RvdCcsICdzdGFyJywgJ3RyaWFuZ2xlJywgJ3RyaWFuZ2xlRG93bicsICdzcXVhcmUnLCAnaWNvbicsICdoZXhhZ29uJ11cbiAgICB9LFxuICAgIHNoYXBlUHJvcGVydGllczoge1xuICAgICAgYm9yZGVyRGFzaGVzOiB7IGJvb2xlYW46IGJvb2wsIGFycmF5OiBhcnJheSB9LFxuICAgICAgYm9yZGVyUmFkaXVzOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICBpbnRlcnBvbGF0aW9uOiB7IGJvb2xlYW46IGJvb2wgfSxcbiAgICAgIHVzZUltYWdlU2l6ZTogeyBib29sZWFuOiBib29sIH0sXG4gICAgICB1c2VCb3JkZXJXaXRoSW1hZ2U6IHsgYm9vbGVhbjogYm9vbCB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICAgIH0sXG4gICAgc2l6ZTogeyBudW1iZXI6IG51bWJlciB9LFxuICAgIHRpdGxlOiB7IHN0cmluZzogc3RyaW5nLCBkb206IGRvbSwgdW5kZWZpbmVkOiAndW5kZWZpbmVkJyB9LFxuICAgIHZhbHVlOiB7IG51bWJlcjogbnVtYmVyLCB1bmRlZmluZWQ6ICd1bmRlZmluZWQnIH0sXG4gICAgd2lkdGhDb25zdHJhaW50OiB7XG4gICAgICBtaW5pbXVtOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICBtYXhpbXVtOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgYm9vbGVhbjogYm9vbCwgbnVtYmVyOiBudW1iZXIgfVxuICAgIH0sXG4gICAgeDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgIHk6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gIH0sXG4gIHBoeXNpY3M6IHtcbiAgICBlbmFibGVkOiB7IGJvb2xlYW46IGJvb2wgfSxcbiAgICBiYXJuZXNIdXQ6IHtcbiAgICAgIGdyYXZpdGF0aW9uYWxDb25zdGFudDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgY2VudHJhbEdyYXZpdHk6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIHNwcmluZ0xlbmd0aDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgc3ByaW5nQ29uc3RhbnQ6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIGRhbXBpbmc6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIGF2b2lkT3ZlcmxhcDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICAgIH0sXG4gICAgZm9yY2VBdGxhczJCYXNlZDoge1xuICAgICAgZ3Jhdml0YXRpb25hbENvbnN0YW50OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICBjZW50cmFsR3Jhdml0eTogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgc3ByaW5nTGVuZ3RoOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICBzcHJpbmdDb25zdGFudDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgZGFtcGluZzogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgYXZvaWRPdmVybGFwOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gICAgfSxcbiAgICByZXB1bHNpb246IHtcbiAgICAgIGNlbnRyYWxHcmF2aXR5OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICBzcHJpbmdMZW5ndGg6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIHNwcmluZ0NvbnN0YW50OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICBub2RlRGlzdGFuY2U6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIGRhbXBpbmc6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0IH1cbiAgICB9LFxuICAgIGhpZXJhcmNoaWNhbFJlcHVsc2lvbjoge1xuICAgICAgY2VudHJhbEdyYXZpdHk6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIHNwcmluZ0xlbmd0aDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgc3ByaW5nQ29uc3RhbnQ6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIG5vZGVEaXN0YW5jZTogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgZGFtcGluZzogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICAgIH0sXG4gICAgbWF4VmVsb2NpdHk6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICBtaW5WZWxvY2l0eTogeyBudW1iZXI6IG51bWJlciB9LCAvLyBweC9zXG4gICAgc29sdmVyOiB7XG4gICAgICBzdHJpbmc6IFsnYmFybmVzSHV0JywgJ3JlcHVsc2lvbicsICdoaWVyYXJjaGljYWxSZXB1bHNpb24nLCAnZm9yY2VBdGxhczJCYXNlZCddXG4gICAgfSxcbiAgICBzdGFiaWxpemF0aW9uOiB7XG4gICAgICBlbmFibGVkOiB7IGJvb2xlYW46IGJvb2wgfSxcbiAgICAgIGl0ZXJhdGlvbnM6IHsgbnVtYmVyOiBudW1iZXIgfSwgLy8gbWF4aW11bSBudW1iZXIgb2YgaXRlcmF0aW9uIHRvIHN0YWJpbGl6ZVxuICAgICAgdXBkYXRlSW50ZXJ2YWw6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIG9ubHlEeW5hbWljRWRnZXM6IHsgYm9vbGVhbjogYm9vbCB9LFxuICAgICAgZml0OiB7IGJvb2xlYW46IGJvb2wgfSxcbiAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBib29sZWFuOiBib29sIH1cbiAgICB9LFxuICAgIHRpbWVzdGVwOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgYWRhcHRpdmVUaW1lc3RlcDogeyBib29sZWFuOiBib29sIH0sXG4gICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIGJvb2xlYW46IGJvb2wgfVxuICB9LFxuXG4gIC8vZ2xvYmFscyA6XG4gIGF1dG9SZXNpemU6IHsgYm9vbGVhbjogYm9vbCB9LFxuICBjbGlja1RvVXNlOiB7IGJvb2xlYW46IGJvb2wgfSxcbiAgbG9jYWxlOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gIGxvY2FsZXM6IHtcbiAgICBfX2FueV9fOiB7IGFueTogYW55IH0sXG4gICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICB9LFxuICBoZWlnaHQ6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgd2lkdGg6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxufTtcblxuYWxsT3B0aW9ucy5ncm91cHMuX19hbnlfXyA9IGFsbE9wdGlvbnMubm9kZXM7XG5hbGxPcHRpb25zLm1hbmlwdWxhdGlvbi5jb250cm9sTm9kZVN0eWxlID0gYWxsT3B0aW9ucy5ub2RlcztcblxudmFyIGNvbmZpZ3VyZU9wdGlvbnMgPSB7XG4gIG5vZGVzOiB7XG4gICAgYm9yZGVyV2lkdGg6IFsxLCAwLCAxMCwgMV0sXG4gICAgYm9yZGVyV2lkdGhTZWxlY3RlZDogWzIsIDAsIDEwLCAxXSxcbiAgICBjb2xvcjoge1xuICAgICAgYm9yZGVyOiBbJ2NvbG9yJywgJyMyQjdDRTknXSxcbiAgICAgIGJhY2tncm91bmQ6IFsnY29sb3InLCAnIzk3QzJGQyddLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogWydjb2xvcicsICcjMkI3Q0U5J10sXG4gICAgICAgIGJhY2tncm91bmQ6IFsnY29sb3InLCAnI0QyRTVGRiddXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBbJ2NvbG9yJywgJyMyQjdDRTknXSxcbiAgICAgICAgYmFja2dyb3VuZDogWydjb2xvcicsICcjRDJFNUZGJ11cbiAgICAgIH1cbiAgICB9LFxuICAgIGZpeGVkOiB7XG4gICAgICB4OiBmYWxzZSxcbiAgICAgIHk6IGZhbHNlXG4gICAgfSxcbiAgICBmb250OiB7XG4gICAgICBjb2xvcjogWydjb2xvcicsICcjMzQzNDM0J10sXG4gICAgICBzaXplOiBbMTQsIDAsIDEwMCwgMV0sIC8vIHB4XG4gICAgICBmYWNlOiBbJ2FyaWFsJywgJ3ZlcmRhbmEnLCAndGFob21hJ10sXG4gICAgICBiYWNrZ3JvdW5kOiBbJ2NvbG9yJywgJ25vbmUnXSxcbiAgICAgIHN0cm9rZVdpZHRoOiBbMCwgMCwgNTAsIDFdLCAvLyBweFxuICAgICAgc3Ryb2tlQ29sb3I6IFsnY29sb3InLCAnI2ZmZmZmZiddXG4gICAgfSxcbiAgICAvL2dyb3VwOiAnc3RyaW5nJyxcbiAgICBoaWRkZW46IGZhbHNlLFxuICAgIGxhYmVsSGlnaGxpZ2h0Qm9sZDogdHJ1ZSxcbiAgICAvL2ljb246IHtcbiAgICAvLyAgZmFjZTogJ3N0cmluZycsICAvLydGb250QXdlc29tZScsXG4gICAgLy8gIGNvZGU6ICdzdHJpbmcnLCAgLy8nXFx1ZjAwNycsXG4gICAgLy8gIHNpemU6IFs1MCwgMCwgMjAwLCAxXSwgIC8vNTAsXG4gICAgLy8gIGNvbG9yOiBbJ2NvbG9yJywnIzJCN0NFOSddICAgLy8nI2FhMDBmZidcbiAgICAvL30sXG4gICAgLy9pbWFnZTogJ3N0cmluZycsIC8vIC0tPiBVUkxcbiAgICBwaHlzaWNzOiB0cnVlLFxuICAgIHNjYWxpbmc6IHtcbiAgICAgIG1pbjogWzEwLCAwLCAyMDAsIDFdLFxuICAgICAgbWF4OiBbMzAsIDAsIDIwMCwgMV0sXG4gICAgICBsYWJlbDoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgbWluOiBbMTQsIDAsIDIwMCwgMV0sXG4gICAgICAgIG1heDogWzMwLCAwLCAyMDAsIDFdLFxuICAgICAgICBtYXhWaXNpYmxlOiBbMzAsIDAsIDIwMCwgMV0sXG4gICAgICAgIGRyYXdUaHJlc2hvbGQ6IFs1LCAwLCAyMCwgMV1cbiAgICAgIH1cbiAgICB9LFxuICAgIHNoYWRvdzoge1xuICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICBjb2xvcjogJ3JnYmEoMCwwLDAsMC41KScsXG4gICAgICBzaXplOiBbMTAsIDAsIDIwLCAxXSxcbiAgICAgIHg6IFs1LCAtMzAsIDMwLCAxXSxcbiAgICAgIHk6IFs1LCAtMzAsIDMwLCAxXVxuICAgIH0sXG4gICAgc2hhcGU6IFsnZWxsaXBzZScsICdib3gnLCAnY2lyY2xlJywgJ2RhdGFiYXNlJywgJ2RpYW1vbmQnLCAnZG90JywgJ3NxdWFyZScsICdzdGFyJywgJ3RleHQnLCAndHJpYW5nbGUnLCAndHJpYW5nbGVEb3duJywgJ2hleGFnb24nXSxcbiAgICBzaGFwZVByb3BlcnRpZXM6IHtcbiAgICAgIGJvcmRlckRhc2hlczogZmFsc2UsXG4gICAgICBib3JkZXJSYWRpdXM6IFs2LCAwLCAyMCwgMV0sXG4gICAgICBpbnRlcnBvbGF0aW9uOiB0cnVlLFxuICAgICAgdXNlSW1hZ2VTaXplOiBmYWxzZVxuICAgIH0sXG4gICAgc2l6ZTogWzI1LCAwLCAyMDAsIDFdXG4gIH0sXG4gIGVkZ2VzOiB7XG4gICAgYXJyb3dzOiB7XG4gICAgICB0bzogeyBlbmFibGVkOiBmYWxzZSwgc2NhbGVGYWN0b3I6IFsxLCAwLCAzLCAwLjA1XSwgdHlwZTogJ2Fycm93JyB9LFxuICAgICAgbWlkZGxlOiB7IGVuYWJsZWQ6IGZhbHNlLCBzY2FsZUZhY3RvcjogWzEsIDAsIDMsIDAuMDVdLCB0eXBlOiAnYXJyb3cnIH0sXG4gICAgICBmcm9tOiB7IGVuYWJsZWQ6IGZhbHNlLCBzY2FsZUZhY3RvcjogWzEsIDAsIDMsIDAuMDVdLCB0eXBlOiAnYXJyb3cnIH1cbiAgICB9LFxuICAgIGFycm93U3RyaWtldGhyb3VnaDogdHJ1ZSxcbiAgICBjb2xvcjoge1xuICAgICAgY29sb3I6IFsnY29sb3InLCAnIzg0ODQ4NCddLFxuICAgICAgaGlnaGxpZ2h0OiBbJ2NvbG9yJywgJyM4NDg0ODQnXSxcbiAgICAgIGhvdmVyOiBbJ2NvbG9yJywgJyM4NDg0ODQnXSxcbiAgICAgIGluaGVyaXQ6IFsnZnJvbScsICd0bycsICdib3RoJywgdHJ1ZSwgZmFsc2VdLFxuICAgICAgb3BhY2l0eTogWzEsIDAsIDEsIDAuMDVdXG4gICAgfSxcbiAgICBkYXNoZXM6IGZhbHNlLFxuICAgIGZvbnQ6IHtcbiAgICAgIGNvbG9yOiBbJ2NvbG9yJywgJyMzNDM0MzQnXSxcbiAgICAgIHNpemU6IFsxNCwgMCwgMTAwLCAxXSwgLy8gcHhcbiAgICAgIGZhY2U6IFsnYXJpYWwnLCAndmVyZGFuYScsICd0YWhvbWEnXSxcbiAgICAgIGJhY2tncm91bmQ6IFsnY29sb3InLCAnbm9uZSddLFxuICAgICAgc3Ryb2tlV2lkdGg6IFsyLCAwLCA1MCwgMV0sIC8vIHB4XG4gICAgICBzdHJva2VDb2xvcjogWydjb2xvcicsICcjZmZmZmZmJ10sXG4gICAgICBhbGlnbjogWydob3Jpem9udGFsJywgJ3RvcCcsICdtaWRkbGUnLCAnYm90dG9tJ11cbiAgICB9LFxuICAgIGhpZGRlbjogZmFsc2UsXG4gICAgaG92ZXJXaWR0aDogWzEuNSwgMCwgNSwgMC4xXSxcbiAgICBsYWJlbEhpZ2hsaWdodEJvbGQ6IHRydWUsXG4gICAgcGh5c2ljczogdHJ1ZSxcbiAgICBzY2FsaW5nOiB7XG4gICAgICBtaW46IFsxLCAwLCAxMDAsIDFdLFxuICAgICAgbWF4OiBbMTUsIDAsIDEwMCwgMV0sXG4gICAgICBsYWJlbDoge1xuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBtaW46IFsxNCwgMCwgMjAwLCAxXSxcbiAgICAgICAgbWF4OiBbMzAsIDAsIDIwMCwgMV0sXG4gICAgICAgIG1heFZpc2libGU6IFszMCwgMCwgMjAwLCAxXSxcbiAgICAgICAgZHJhd1RocmVzaG9sZDogWzUsIDAsIDIwLCAxXVxuICAgICAgfVxuICAgIH0sXG4gICAgc2VsZWN0aW9uV2lkdGg6IFsxLjUsIDAsIDUsIDAuMV0sXG4gICAgc2VsZlJlZmVyZW5jZVNpemU6IFsyMCwgMCwgMjAwLCAxXSxcbiAgICBzaGFkb3c6IHtcbiAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgY29sb3I6ICdyZ2JhKDAsMCwwLDAuNSknLFxuICAgICAgc2l6ZTogWzEwLCAwLCAyMCwgMV0sXG4gICAgICB4OiBbNSwgLTMwLCAzMCwgMV0sXG4gICAgICB5OiBbNSwgLTMwLCAzMCwgMV1cbiAgICB9LFxuICAgIHNtb290aDoge1xuICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgIHR5cGU6IFsnZHluYW1pYycsICdjb250aW51b3VzJywgJ2Rpc2NyZXRlJywgJ2RpYWdvbmFsQ3Jvc3MnLCAnc3RyYWlnaHRDcm9zcycsICdob3Jpem9udGFsJywgJ3ZlcnRpY2FsJywgJ2N1cnZlZENXJywgJ2N1cnZlZENDVycsICdjdWJpY0JlemllciddLFxuICAgICAgZm9yY2VEaXJlY3Rpb246IFsnaG9yaXpvbnRhbCcsICd2ZXJ0aWNhbCcsICdub25lJ10sXG4gICAgICByb3VuZG5lc3M6IFswLjUsIDAsIDEsIDAuMDVdXG4gICAgfSxcbiAgICB3aWR0aDogWzEsIDAsIDMwLCAxXVxuICB9LFxuICBsYXlvdXQ6IHtcbiAgICAvL3JhbmRvbVNlZWQ6IFswLCAwLCA1MDAsIDFdLFxuICAgIC8vaW1wcm92ZWRMYXlvdXQ6IHRydWUsXG4gICAgaGllcmFyY2hpY2FsOiB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIGxldmVsU2VwYXJhdGlvbjogWzE1MCwgMjAsIDUwMCwgNV0sXG4gICAgICBub2RlU3BhY2luZzogWzEwMCwgMjAsIDUwMCwgNV0sXG4gICAgICB0cmVlU3BhY2luZzogWzIwMCwgMjAsIDUwMCwgNV0sXG4gICAgICBibG9ja1NoaWZ0aW5nOiB0cnVlLFxuICAgICAgZWRnZU1pbmltaXphdGlvbjogdHJ1ZSxcbiAgICAgIHBhcmVudENlbnRyYWxpemF0aW9uOiB0cnVlLFxuICAgICAgZGlyZWN0aW9uOiBbJ1VEJywgJ0RVJywgJ0xSJywgJ1JMJ10sIC8vIFVELCBEVSwgTFIsIFJMXG4gICAgICBzb3J0TWV0aG9kOiBbJ2h1YnNpemUnLCAnZGlyZWN0ZWQnXSAvLyBodWJzaXplLCBkaXJlY3RlZFxuICAgIH1cbiAgfSxcbiAgaW50ZXJhY3Rpb246IHtcbiAgICBkcmFnTm9kZXM6IHRydWUsXG4gICAgZHJhZ1ZpZXc6IHRydWUsXG4gICAgaGlkZUVkZ2VzT25EcmFnOiBmYWxzZSxcbiAgICBoaWRlRWRnZXNPblpvb206IGZhbHNlLFxuICAgIGhpZGVOb2Rlc09uRHJhZzogZmFsc2UsXG4gICAgaG92ZXI6IGZhbHNlLFxuICAgIGtleWJvYXJkOiB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIHNwZWVkOiB7XG4gICAgICAgIHg6IFsxMCwgMCwgNDAsIDFdLFxuICAgICAgICB5OiBbMTAsIDAsIDQwLCAxXSxcbiAgICAgICAgem9vbTogWzAuMDIsIDAsIDAuMSwgMC4wMDVdXG4gICAgICB9LFxuICAgICAgYmluZFRvV2luZG93OiB0cnVlXG4gICAgfSxcbiAgICBtdWx0aXNlbGVjdDogZmFsc2UsXG4gICAgbmF2aWdhdGlvbkJ1dHRvbnM6IGZhbHNlLFxuICAgIHNlbGVjdGFibGU6IHRydWUsXG4gICAgc2VsZWN0Q29ubmVjdGVkRWRnZXM6IHRydWUsXG4gICAgaG92ZXJDb25uZWN0ZWRFZGdlczogdHJ1ZSxcbiAgICB0b29sdGlwRGVsYXk6IFszMDAsIDAsIDEwMDAsIDI1XSxcbiAgICB6b29tVmlldzogdHJ1ZSxcbiAgICB6b29tU3BlZWQ6IDFcbiAgfSxcbiAgbWFuaXB1bGF0aW9uOiB7XG4gICAgZW5hYmxlZDogZmFsc2UsXG4gICAgaW5pdGlhbGx5QWN0aXZlOiBmYWxzZVxuICB9LFxuICBwaHlzaWNzOiB7XG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBiYXJuZXNIdXQ6IHtcbiAgICAgIC8vdGhldGE6IFswLjUsIDAuMSwgMSwgMC4wNV0sXG4gICAgICBncmF2aXRhdGlvbmFsQ29uc3RhbnQ6IFstMjAwMCwgLTMwMDAwLCAwLCA1MF0sXG4gICAgICBjZW50cmFsR3Jhdml0eTogWzAuMywgMCwgMTAsIDAuMDVdLFxuICAgICAgc3ByaW5nTGVuZ3RoOiBbOTUsIDAsIDUwMCwgNV0sXG4gICAgICBzcHJpbmdDb25zdGFudDogWzAuMDQsIDAsIDEuMiwgMC4wMDVdLFxuICAgICAgZGFtcGluZzogWzAuMDksIDAsIDEsIDAuMDFdLFxuICAgICAgYXZvaWRPdmVybGFwOiBbMCwgMCwgMSwgMC4wMV1cbiAgICB9LFxuICAgIGZvcmNlQXRsYXMyQmFzZWQ6IHtcbiAgICAgIC8vdGhldGE6IFswLjUsIDAuMSwgMSwgMC4wNV0sXG4gICAgICBncmF2aXRhdGlvbmFsQ29uc3RhbnQ6IFstNTAsIC01MDAsIDAsIDFdLFxuICAgICAgY2VudHJhbEdyYXZpdHk6IFswLjAxLCAwLCAxLCAwLjAwNV0sXG4gICAgICBzcHJpbmdMZW5ndGg6IFs5NSwgMCwgNTAwLCA1XSxcbiAgICAgIHNwcmluZ0NvbnN0YW50OiBbMC4wOCwgMCwgMS4yLCAwLjAwNV0sXG4gICAgICBkYW1waW5nOiBbMC40LCAwLCAxLCAwLjAxXSxcbiAgICAgIGF2b2lkT3ZlcmxhcDogWzAsIDAsIDEsIDAuMDFdXG4gICAgfSxcbiAgICByZXB1bHNpb246IHtcbiAgICAgIGNlbnRyYWxHcmF2aXR5OiBbMC4yLCAwLCAxMCwgMC4wNV0sXG4gICAgICBzcHJpbmdMZW5ndGg6IFsyMDAsIDAsIDUwMCwgNV0sXG4gICAgICBzcHJpbmdDb25zdGFudDogWzAuMDUsIDAsIDEuMiwgMC4wMDVdLFxuICAgICAgbm9kZURpc3RhbmNlOiBbMTAwLCAwLCA1MDAsIDVdLFxuICAgICAgZGFtcGluZzogWzAuMDksIDAsIDEsIDAuMDFdXG4gICAgfSxcbiAgICBoaWVyYXJjaGljYWxSZXB1bHNpb246IHtcbiAgICAgIGNlbnRyYWxHcmF2aXR5OiBbMC4yLCAwLCAxMCwgMC4wNV0sXG4gICAgICBzcHJpbmdMZW5ndGg6IFsxMDAsIDAsIDUwMCwgNV0sXG4gICAgICBzcHJpbmdDb25zdGFudDogWzAuMDEsIDAsIDEuMiwgMC4wMDVdLFxuICAgICAgbm9kZURpc3RhbmNlOiBbMTIwLCAwLCA1MDAsIDVdLFxuICAgICAgZGFtcGluZzogWzAuMDksIDAsIDEsIDAuMDFdXG4gICAgfSxcbiAgICBtYXhWZWxvY2l0eTogWzUwLCAwLCAxNTAsIDFdLFxuICAgIG1pblZlbG9jaXR5OiBbMC4xLCAwLjAxLCAwLjUsIDAuMDFdLFxuICAgIHNvbHZlcjogWydiYXJuZXNIdXQnLCAnZm9yY2VBdGxhczJCYXNlZCcsICdyZXB1bHNpb24nLCAnaGllcmFyY2hpY2FsUmVwdWxzaW9uJ10sXG4gICAgdGltZXN0ZXA6IFswLjUsIDAuMDEsIDEsIDAuMDFdXG4gICAgLy9hZGFwdGl2ZVRpbWVzdGVwOiB0cnVlXG4gIH1cbn07XG5cbmV4cG9ydHMuYWxsT3B0aW9ucyA9IGFsbE9wdGlvbnM7XG5leHBvcnRzLmNvbmZpZ3VyZU9wdGlvbnMgPSBjb25maWd1cmVPcHRpb25zO1xuXG4vKioqLyB9KSxcbi8qIDg1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxuLy8gTmV0d29ya1xudXRpbC5leHRlbmQoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXygxMjEpKTtcblxuLyoqKi8gfSksXG4vKiA4NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDM3KTtcbl9fd2VicGFja19yZXF1aXJlX18oNDcpO1xubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk4KTtcblxuXG4vKioqLyB9KSxcbi8qIDg3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IF9fd2VicGFja19yZXF1aXJlX18oODgpO1xudmFyIHN0ZXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg5KTtcbnZhciBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcbnZhciB0b0lPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYwKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBraW5kID0gdGhpcy5faztcbiAgdmFyIGluZGV4ID0gdGhpcy5faSsrO1xuICBpZiAoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpIHtcbiAgICB0aGlzLl90ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzdGVwKDEpO1xuICB9XG4gIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHN0ZXAoMCwgaW5kZXgpO1xuICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuXG5cbi8qKiovIH0pLFxuLyogODggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG5cblxuLyoqKi8gfSksXG4vKiA4OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkb25lLCB2YWx1ZSkge1xuICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZSB9O1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDkwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICh0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDkxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgY3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MSk7XG52YXIgZGVzY3JpcHRvciA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nik7XG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbl9fd2VicGFja19yZXF1aXJlX18oMTkpKEl0ZXJhdG9yUHJvdG90eXBlLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpKCdpdGVyYXRvcicpLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpIHtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7IG5leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDkyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBkUCA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG52YXIgZ2V0S2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oMjYpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaSA9IDA7XG4gIHZhciBQO1xuICB3aGlsZSAobGVuZ3RoID4gaSkgZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcbiAgcmV0dXJuIE87XG59O1xuXG5cbi8qKiovIH0pLFxuLyogOTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcbnZhciB0b0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oOTQpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IF9fd2VicGFja19yZXF1aXJlX18oOTUpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pIHtcbiAgICAgIGlmIChPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiA5NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyKTtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuXG5cbi8qKiovIH0pLFxuLyogOTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHRvSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oNDIpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDk2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBkb2N1bWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMTApLmRvY3VtZW50O1xubW9kdWxlLmV4cG9ydHMgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblxuLyoqKi8gfSksXG4vKiA5NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgdG9JbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Mik7XG52YXIgZGVmaW5lZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xuLy8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG4vLyBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRPX1NUUklORykge1xuICByZXR1cm4gZnVuY3Rpb24gKHRoYXQsIHBvcykge1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpO1xuICAgIHZhciBpID0gdG9JbnRlZ2VyKHBvcyk7XG4gICAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAoaSA8IDAgfHwgaSA+PSBsKSByZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgYSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZlxuICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcbiAgICAgIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDk4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xudmFyIGdldCA9IF9fd2VicGFja19yZXF1aXJlX18oOTkpO1xubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpLmdldEl0ZXJhdG9yID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBpdGVyRm4gPSBnZXQoaXQpO1xuICBpZiAodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgcmV0dXJuIGFuT2JqZWN0KGl0ZXJGbi5jYWxsKGl0KSk7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogOTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3KTtcbnZhciBJVEVSQVRPUiA9IF9fd2VicGFja19yZXF1aXJlX18oOCkoJ2l0ZXJhdG9yJyk7XG52YXIgSXRlcmF0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNikuZ2V0SXRlcmF0b3JNZXRob2QgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ICE9IHVuZGVmaW5lZCkgcmV0dXJuIGl0W0lURVJBVE9SXVxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDEwMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEwMSk7XG52YXIgJE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNikuT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGUoUCwgRCkge1xuICByZXR1cm4gJE9iamVjdC5jcmVhdGUoUCwgRCk7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMTAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciAkZXhwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG4vLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0JywgeyBjcmVhdGU6IF9fd2VicGFja19yZXF1aXJlX18oNDEpIH0pO1xuXG5cbi8qKiovIH0pLFxuLyogMTAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbl9fd2VicGFja19yZXF1aXJlX18oMTAzKTtcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KS5PYmplY3Qua2V5cztcblxuXG4vKioqLyB9KSxcbi8qIDEwMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyAxOS4xLjIuMTQgT2JqZWN0LmtleXMoTylcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMzApO1xudmFyICRrZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XG5cbl9fd2VicGFja19yZXF1aXJlX18oNjgpKCdrZXlzJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24ga2V5cyhpdCkge1xuICAgIHJldHVybiAka2V5cyh0b09iamVjdChpdCkpO1xuICB9O1xufSk7XG5cblxuLyoqKi8gfSksXG4vKiAxMDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxubW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwNSksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuLyoqKi8gfSksXG4vKiAxMDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuX193ZWJwYWNrX3JlcXVpcmVfXyg0Nyk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDM3KTtcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OCkuZignaXRlcmF0b3InKTtcblxuXG4vKioqLyB9KSxcbi8qIDEwNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IF9fd2VicGFja19yZXF1aXJlX18oMTA3KSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG4vKioqLyB9KSxcbi8qIDEwNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEwOCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDExMyk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDExNCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDExNSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNikuU3ltYm9sO1xuXG5cbi8qKiovIH0pLFxuLyogMTA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vLyBFQ01BU2NyaXB0IDYgc3ltYm9scyBzaGltXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcbnZhciAkZXhwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG52YXIgcmVkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY0KTtcbnZhciBNRVRBID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDkpLktFWTtcbnZhciAkZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcbnZhciBzaGFyZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IF9fd2VicGFja19yZXF1aXJlX18oNDYpO1xudmFyIHVpZCA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpO1xudmFyIHdrcyA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG52YXIgd2tzRXh0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OCk7XG52YXIgd2tzRGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OSk7XG52YXIgZW51bUtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMCk7XG52YXIgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oMTExKTtcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG52YXIgdG9JT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG52YXIgdG9QcmltaXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwKTtcbnZhciBjcmVhdGVEZXNjID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG52YXIgX2NyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDEpO1xudmFyIGdPUE5FeHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMik7XG52YXIgJEdPUEQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwKTtcbnZhciAkRFAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcbnZhciAka2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oMjYpO1xudmFyIGdPUEQgPSAkR09QRC5mO1xudmFyIGRQID0gJERQLmY7XG52YXIgZ09QTiA9IGdPUE5FeHQuZjtcbnZhciAkU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciAkSlNPTiA9IGdsb2JhbC5KU09OO1xudmFyIF9zdHJpbmdpZnkgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgSElEREVOID0gd2tzKCdfaGlkZGVuJyk7XG52YXIgVE9fUFJJTUlUSVZFID0gd2tzKCd0b1ByaW1pdGl2ZScpO1xudmFyIGlzRW51bSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKTtcbnZhciBBbGxTeW1ib2xzID0gc2hhcmVkKCdzeW1ib2xzJyk7XG52YXIgT1BTeW1ib2xzID0gc2hhcmVkKCdvcC1zeW1ib2xzJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3RbUFJPVE9UWVBFXTtcbnZhciBVU0VfTkFUSVZFID0gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcbnZhciBRT2JqZWN0ID0gZ2xvYmFsLlFPYmplY3Q7XG4vLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcbnZhciBzZXR0ZXIgPSAhUU9iamVjdCB8fCAhUU9iamVjdFtQUk9UT1RZUEVdIHx8ICFRT2JqZWN0W1BST1RPVFlQRV0uZmluZENoaWxkO1xuXG4vLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcbnZhciBzZXRTeW1ib2xEZXNjID0gREVTQ1JJUFRPUlMgJiYgJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIF9jcmVhdGUoZFAoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZFAodGhpcywgJ2EnLCB7IHZhbHVlOiA3IH0pLmE7IH1cbiAgfSkpLmEgIT0gNztcbn0pID8gZnVuY3Rpb24gKGl0LCBrZXksIEQpIHtcbiAgdmFyIHByb3RvRGVzYyA9IGdPUEQoT2JqZWN0UHJvdG8sIGtleSk7XG4gIGlmIChwcm90b0Rlc2MpIGRlbGV0ZSBPYmplY3RQcm90b1trZXldO1xuICBkUChpdCwga2V5LCBEKTtcbiAgaWYgKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pIGRQKE9iamVjdFByb3RvLCBrZXksIHByb3RvRGVzYyk7XG59IDogZFA7XG5cbnZhciB3cmFwID0gZnVuY3Rpb24gKHRhZykge1xuICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX2NyZWF0ZSgkU3ltYm9sW1BST1RPVFlQRV0pO1xuICBzeW0uX2sgPSB0YWc7XG4gIHJldHVybiBzeW07XG59O1xuXG52YXIgaXNTeW1ib2wgPSBVU0VfTkFUSVZFICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCBpbnN0YW5jZW9mICRTeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCkge1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvKSAkZGVmaW5lUHJvcGVydHkoT1BTeW1ib2xzLCBrZXksIEQpO1xuICBhbk9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEQpO1xuICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSkpIHtcbiAgICBpZiAoIUQuZW51bWVyYWJsZSkge1xuICAgICAgaWYgKCFoYXMoaXQsIEhJRERFTikpIGRQKGl0LCBISURERU4sIGNyZWF0ZURlc2MoMSwge30pKTtcbiAgICAgIGl0W0hJRERFTl1ba2V5XSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSBpdFtISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEQgPSBfY3JlYXRlKEQsIHsgZW51bWVyYWJsZTogY3JlYXRlRGVzYygwLCBmYWxzZSkgfSk7XG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzYyhpdCwga2V5LCBEKTtcbiAgfSByZXR1cm4gZFAoaXQsIGtleSwgRCk7XG59O1xudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhpdCwgUCkge1xuICBhbk9iamVjdChpdCk7XG4gIHZhciBrZXlzID0gZW51bUtleXMoUCA9IHRvSU9iamVjdChQKSk7XG4gIHZhciBpID0gMDtcbiAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKGwgPiBpKSAkZGVmaW5lUHJvcGVydHkoaXQsIGtleSA9IGtleXNbaSsrXSwgUFtrZXldKTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGl0LCBQKSB7XG4gIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBfY3JlYXRlKGl0KSA6ICRkZWZpbmVQcm9wZXJ0aWVzKF9jcmVhdGUoaXQpLCBQKTtcbn07XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KSB7XG4gIHZhciBFID0gaXNFbnVtLmNhbGwodGhpcywga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSk7XG4gIGlmICh0aGlzID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldID8gRSA6IHRydWU7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICBpdCA9IHRvSU9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpIHJldHVybjtcbiAgdmFyIEQgPSBnT1BEKGl0LCBrZXkpO1xuICBpZiAoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKSBELmVudW1lcmFibGUgPSB0cnVlO1xuICByZXR1cm4gRDtcbn07XG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHZhciBuYW1lcyA9IGdPUE4odG9JT2JqZWN0KGl0KSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkge1xuICAgIGlmICghaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIGtleSAhPSBISURERU4gJiYga2V5ICE9IE1FVEEpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkge1xuICB2YXIgSVNfT1AgPSBpdCA9PT0gT2JqZWN0UHJvdG87XG4gIHZhciBuYW1lcyA9IGdPUE4oSVNfT1AgPyBPUFN5bWJvbHMgOiB0b0lPYmplY3QoaXQpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7XG4gICAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiAoSVNfT1AgPyBoYXMoT2JqZWN0UHJvdG8sIGtleSkgOiB0cnVlKSkgcmVzdWx0LnB1c2goQWxsU3ltYm9sc1trZXldKTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gMTkuNC4xLjEgU3ltYm9sKFtkZXNjcmlwdGlvbl0pXG5pZiAoIVVTRV9OQVRJVkUpIHtcbiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpIHRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yIScpO1xuICAgIHZhciB0YWcgPSB1aWQoYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICAgIHZhciAkc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8pICRzZXQuY2FsbChPUFN5bWJvbHMsIHZhbHVlKTtcbiAgICAgIGlmIChoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKSB0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xuICAgICAgc2V0U3ltYm9sRGVzYyh0aGlzLCB0YWcsIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbiAgICB9O1xuICAgIGlmIChERVNDUklQVE9SUyAmJiBzZXR0ZXIpIHNldFN5bWJvbERlc2MoT2JqZWN0UHJvdG8sIHRhZywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogJHNldCB9KTtcbiAgICByZXR1cm4gd3JhcCh0YWcpO1xuICB9O1xuICByZWRlZmluZSgkU3ltYm9sW1BST1RPVFlQRV0sICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9rO1xuICB9KTtcblxuICAkR09QRC5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgJERQLmYgPSAkZGVmaW5lUHJvcGVydHk7XG4gIF9fd2VicGFja19yZXF1aXJlX18oNjkpLmYgPSBnT1BORXh0LmYgPSAkZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgX193ZWJwYWNrX3JlcXVpcmVfXygzMikuZiA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgX193ZWJwYWNrX3JlcXVpcmVfXyg1MCkuZiA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgaWYgKERFU0NSSVBUT1JTICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KSkge1xuICAgIHJlZGVmaW5lKE9iamVjdFByb3RvLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHRydWUpO1xuICB9XG5cbiAgd2tzRXh0LmYgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiB3cmFwKHdrcyhuYW1lKSk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHsgU3ltYm9sOiAkU3ltYm9sIH0pO1xuXG5mb3IgKHZhciBlczZTeW1ib2xzID0gKFxuICAvLyAxOS40LjIuMiwgMTkuNC4yLjMsIDE5LjQuMi40LCAxOS40LjIuNiwgMTkuNC4yLjgsIDE5LjQuMi45LCAxOS40LjIuMTAsIDE5LjQuMi4xMSwgMTkuNC4yLjEyLCAxOS40LjIuMTMsIDE5LjQuMi4xNFxuICAnaGFzSW5zdGFuY2UsaXNDb25jYXRTcHJlYWRhYmxlLGl0ZXJhdG9yLG1hdGNoLHJlcGxhY2Usc2VhcmNoLHNwZWNpZXMsc3BsaXQsdG9QcmltaXRpdmUsdG9TdHJpbmdUYWcsdW5zY29wYWJsZXMnXG4pLnNwbGl0KCcsJyksIGogPSAwOyBlczZTeW1ib2xzLmxlbmd0aCA+IGo7KXdrcyhlczZTeW1ib2xzW2orK10pO1xuXG5mb3IgKHZhciB3ZWxsS25vd25TeW1ib2xzID0gJGtleXMod2tzLnN0b3JlKSwgayA9IDA7IHdlbGxLbm93blN5bWJvbHMubGVuZ3RoID4gazspIHdrc0RlZmluZSh3ZWxsS25vd25TeW1ib2xzW2srK10pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnU3ltYm9sJywge1xuICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yKGtleSlcbiAgJ2Zvcic6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gaGFzKFN5bWJvbFJlZ2lzdHJ5LCBrZXkgKz0gJycpXG4gICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV1cbiAgICAgIDogU3ltYm9sUmVnaXN0cnlba2V5XSA9ICRTeW1ib2woa2V5KTtcbiAgfSxcbiAgLy8gMTkuNC4yLjUgU3ltYm9sLmtleUZvcihzeW0pXG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKHN5bSkge1xuICAgIGlmICghaXNTeW1ib2woc3ltKSkgdGhyb3cgVHlwZUVycm9yKHN5bSArICcgaXMgbm90IGEgc3ltYm9sIScpO1xuICAgIGZvciAodmFyIGtleSBpbiBTeW1ib2xSZWdpc3RyeSkgaWYgKFN5bWJvbFJlZ2lzdHJ5W2tleV0gPT09IHN5bSkgcmV0dXJuIGtleTtcbiAgfSxcbiAgdXNlU2V0dGVyOiBmdW5jdGlvbiAoKSB7IHNldHRlciA9IHRydWU7IH0sXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24gKCkgeyBzZXR0ZXIgPSBmYWxzZTsgfVxufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pO1xuXG4vLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkodmFsdWUgWywgcmVwbGFjZXIgWywgc3BhY2VdXSlcbiRKU09OICYmICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCFVU0VfTkFUSVZFIHx8ICRmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciBTID0gJFN5bWJvbCgpO1xuICAvLyBNUyBFZGdlIGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyB7fVxuICAvLyBXZWJLaXQgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIG51bGxcbiAgLy8gVjggdGhyb3dzIG9uIGJveGVkIHN5bWJvbHNcbiAgcmV0dXJuIF9zdHJpbmdpZnkoW1NdKSAhPSAnW251bGxdJyB8fCBfc3RyaW5naWZ5KHsgYTogUyB9KSAhPSAne30nIHx8IF9zdHJpbmdpZnkoT2JqZWN0KFMpKSAhPSAne30nO1xufSkpLCAnSlNPTicsIHtcbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpIHtcbiAgICB2YXIgYXJncyA9IFtpdF07XG4gICAgdmFyIGkgPSAxO1xuICAgIHZhciByZXBsYWNlciwgJHJlcGxhY2VyO1xuICAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaSkgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICAkcmVwbGFjZXIgPSByZXBsYWNlciA9IGFyZ3NbMV07XG4gICAgaWYgKCFpc09iamVjdChyZXBsYWNlcikgJiYgaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpIHJldHVybjsgLy8gSUU4IHJldHVybnMgc3RyaW5nIG9uIHVuZGVmaW5lZFxuICAgIGlmICghaXNBcnJheShyZXBsYWNlcikpIHJlcGxhY2VyID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgJHJlcGxhY2VyID09ICdmdW5jdGlvbicpIHZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICBpZiAoIWlzU3ltYm9sKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgYXJnc1sxXSA9IHJlcGxhY2VyO1xuICAgIHJldHVybiBfc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmdzKTtcbiAgfVxufSk7XG5cbi8vIDE5LjQuMy40IFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV0oaGludClcbiRTeW1ib2xbUFJPVE9UWVBFXVtUT19QUklNSVRJVkVdIHx8IF9fd2VicGFja19yZXF1aXJlX18oMTkpKCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7XG4vLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCAnU3ltYm9sJyk7XG4vLyAyMC4yLjEuOSBNYXRoW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhNYXRoLCAnTWF0aCcsIHRydWUpO1xuLy8gMjQuMy4zIEpTT05bQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpO1xuXG5cbi8qKiovIH0pLFxuLyogMTA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBNRVRBID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSkoJ21ldGEnKTtcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xudmFyIHNldERlc2MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKS5mO1xudmFyIGlkID0gMDtcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIEZSRUVaRSA9ICFfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBpc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7XG59KTtcbnZhciBzZXRNZXRhID0gZnVuY3Rpb24gKGl0KSB7XG4gIHNldERlc2MoaXQsIE1FVEEsIHsgdmFsdWU6IHtcbiAgICBpOiAnTycgKyArK2lkLCAvLyBvYmplY3QgSURcbiAgICB3OiB7fSAgICAgICAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IH0pO1xufTtcbnZhciBmYXN0S2V5ID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgLy8gcmV0dXJuIHByaW1pdGl2ZSB3aXRoIHByZWZpeFxuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiAnRic7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gb2JqZWN0IElEXG4gIH0gcmV0dXJuIGl0W01FVEFdLmk7XG59O1xudmFyIGdldFdlYWsgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICBpZiAoIWhhcyhpdCwgTUVUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuIHRydWU7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBoYXNoIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gcmV0dXJuIGl0W01FVEFdLnc7XG59O1xuLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKEZSRUVaRSAmJiBtZXRhLk5FRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBKSkgc2V0TWV0YShpdCk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgbWV0YSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBLRVk6IE1FVEEsXG4gIE5FRUQ6IGZhbHNlLFxuICBmYXN0S2V5OiBmYXN0S2V5LFxuICBnZXRXZWFrOiBnZXRXZWFrLFxuICBvbkZyZWV6ZTogb25GcmVlemVcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gYWxsIGVudW1lcmFibGUgb2JqZWN0IGtleXMsIGluY2x1ZGVzIHN5bWJvbHNcbnZhciBnZXRLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XG52YXIgZ09QUyA9IF9fd2VicGFja19yZXF1aXJlX18oNTApO1xudmFyIHBJRSA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHJlc3VsdCA9IGdldEtleXMoaXQpO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgaWYgKGdldFN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IGdldFN5bWJvbHMoaXQpO1xuICAgIHZhciBpc0VudW0gPSBwSUUuZjtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAoc3ltYm9scy5sZW5ndGggPiBpKSBpZiAoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcbnZhciBjb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KTtcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5Jztcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xudmFyIHRvSU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xudmFyIGdPUE4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5KS5mO1xudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZ09QTihpdCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgcmV0dXJuIHdpbmRvd05hbWVzICYmIHRvU3RyaW5nLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nID8gZ2V0V2luZG93TmFtZXMoaXQpIDogZ09QTih0b0lPYmplY3QoaXQpKTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxMTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXG5cbi8qKiovIH0pLFxuLyogMTE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbl9fd2VicGFja19yZXF1aXJlX18oNDkpKCdhc3luY0l0ZXJhdG9yJyk7XG5cblxuLyoqKi8gfSksXG4vKiAxMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuX193ZWJwYWNrX3JlcXVpcmVfXyg0OSkoJ29ic2VydmFibGUnKTtcblxuXG4vKioqLyB9KSxcbi8qIDExNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24obW9kdWxlKSB7dmFyIHJlcXVpcmU7Ly8hIG1vbWVudC5qc1xuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICAgdHJ1ZSA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIGdsb2JhbC5tb21lbnQgPSBmYWN0b3J5KClcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIGhvb2tDYWxsYmFjaztcblxuICAgIGZ1bmN0aW9uIGhvb2tzICgpIHtcbiAgICAgICAgcmV0dXJuIGhvb2tDYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgZG9uZSB0byByZWdpc3RlciB0aGUgbWV0aG9kIGNhbGxlZCB3aXRoIG1vbWVudCgpXG4gICAgLy8gd2l0aG91dCBjcmVhdGluZyBjaXJjdWxhciBkZXBlbmRlbmNpZXMuXG4gICAgZnVuY3Rpb24gc2V0SG9va0NhbGxiYWNrIChjYWxsYmFjaykge1xuICAgICAgICBob29rQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FycmF5KGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIEFycmF5IHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPYmplY3QoaW5wdXQpIHtcbiAgICAgICAgLy8gSUU4IHdpbGwgdHJlYXQgdW5kZWZpbmVkIGFuZCBudWxsIGFzIG9iamVjdCBpZiBpdCB3YXNuJ3QgZm9yXG4gICAgICAgIC8vIGlucHV0ICE9IG51bGxcbiAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPYmplY3RFbXB0eShvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubGVuZ3RoID09PSAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBrO1xuICAgICAgICAgICAgZm9yIChrIGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09PSB2b2lkIDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNOdW1iZXIoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgTnVtYmVyXSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXRlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIERhdGUgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hcChhcnIsIGZuKSB7XG4gICAgICAgIHZhciByZXMgPSBbXSwgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzLnB1c2goZm4oYXJyW2ldLCBpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNPd25Qcm9wKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLCBiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRlbmQoYSwgYikge1xuICAgICAgICBmb3IgKHZhciBpIGluIGIpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGIsIGkpKSB7XG4gICAgICAgICAgICAgICAgYVtpXSA9IGJbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzT3duUHJvcChiLCAndG9TdHJpbmcnKSkge1xuICAgICAgICAgICAgYS50b1N0cmluZyA9IGIudG9TdHJpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzT3duUHJvcChiLCAndmFsdWVPZicpKSB7XG4gICAgICAgICAgICBhLnZhbHVlT2YgPSBiLnZhbHVlT2Y7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVVVEMgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCB0cnVlKS51dGMoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZhdWx0UGFyc2luZ0ZsYWdzKCkge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIGRlZXAgY2xvbmUgdGhpcyBvYmplY3QuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbXB0eSAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHVudXNlZFRva2VucyAgICA6IFtdLFxuICAgICAgICAgICAgdW51c2VkSW5wdXQgICAgIDogW10sXG4gICAgICAgICAgICBvdmVyZmxvdyAgICAgICAgOiAtMixcbiAgICAgICAgICAgIGNoYXJzTGVmdE92ZXIgICA6IDAsXG4gICAgICAgICAgICBudWxsSW5wdXQgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIGludmFsaWRNb250aCAgICA6IG51bGwsXG4gICAgICAgICAgICBpbnZhbGlkRm9ybWF0ICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHVzZXJJbnZhbGlkYXRlZCA6IGZhbHNlLFxuICAgICAgICAgICAgaXNvICAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICBwYXJzZWREYXRlUGFydHMgOiBbXSxcbiAgICAgICAgICAgIG1lcmlkaWVtICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICByZmMyODIyICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHdlZWtkYXlNaXNtYXRjaCA6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2luZ0ZsYWdzKG0pIHtcbiAgICAgICAgaWYgKG0uX3BmID09IG51bGwpIHtcbiAgICAgICAgICAgIG0uX3BmID0gZGVmYXVsdFBhcnNpbmdGbGFncygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9wZjtcbiAgICB9XG5cbiAgICB2YXIgc29tZTtcbiAgICBpZiAoQXJyYXkucHJvdG90eXBlLnNvbWUpIHtcbiAgICAgICAgc29tZSA9IEFycmF5LnByb3RvdHlwZS5zb21lO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNvbWUgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgICAgICAgICB2YXIgdCA9IE9iamVjdCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpIGluIHQgJiYgZnVuLmNhbGwodGhpcywgdFtpXSwgaSwgdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNWYWxpZChtKSB7XG4gICAgICAgIGlmIChtLl9pc1ZhbGlkID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBmbGFncyA9IGdldFBhcnNpbmdGbGFncyhtKTtcbiAgICAgICAgICAgIHZhciBwYXJzZWRQYXJ0cyA9IHNvbWUuY2FsbChmbGFncy5wYXJzZWREYXRlUGFydHMsIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgIT0gbnVsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGlzTm93VmFsaWQgPSAhaXNOYU4obS5fZC5nZXRUaW1lKCkpICYmXG4gICAgICAgICAgICAgICAgZmxhZ3Mub3ZlcmZsb3cgPCAwICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmVtcHR5ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRNb250aCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkV2Vla2RheSAmJlxuICAgICAgICAgICAgICAgICFmbGFncy53ZWVrZGF5TWlzbWF0Y2ggJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MubnVsbElucHV0ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRGb3JtYXQgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MudXNlckludmFsaWRhdGVkICYmXG4gICAgICAgICAgICAgICAgKCFmbGFncy5tZXJpZGllbSB8fCAoZmxhZ3MubWVyaWRpZW0gJiYgcGFyc2VkUGFydHMpKTtcblxuICAgICAgICAgICAgaWYgKG0uX3N0cmljdCkge1xuICAgICAgICAgICAgICAgIGlzTm93VmFsaWQgPSBpc05vd1ZhbGlkICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLmNoYXJzTGVmdE92ZXIgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MudW51c2VkVG9rZW5zLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy5iaWdIb3VyID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuaXNGcm96ZW4gPT0gbnVsbCB8fCAhT2JqZWN0LmlzRnJvemVuKG0pKSB7XG4gICAgICAgICAgICAgICAgbS5faXNWYWxpZCA9IGlzTm93VmFsaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNOb3dWYWxpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS5faXNWYWxpZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVJbnZhbGlkIChmbGFncykge1xuICAgICAgICB2YXIgbSA9IGNyZWF0ZVVUQyhOYU4pO1xuICAgICAgICBpZiAoZmxhZ3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgZXh0ZW5kKGdldFBhcnNpbmdGbGFncyhtKSwgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLnVzZXJJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICAvLyBQbHVnaW5zIHRoYXQgYWRkIHByb3BlcnRpZXMgc2hvdWxkIGFsc28gYWRkIHRoZSBrZXkgaGVyZSAobnVsbCB2YWx1ZSksXG4gICAgLy8gc28gd2UgY2FuIHByb3Blcmx5IGNsb25lIG91cnNlbHZlcy5cbiAgICB2YXIgbW9tZW50UHJvcGVydGllcyA9IGhvb2tzLm1vbWVudFByb3BlcnRpZXMgPSBbXTtcblxuICAgIGZ1bmN0aW9uIGNvcHlDb25maWcodG8sIGZyb20pIHtcbiAgICAgICAgdmFyIGksIHByb3AsIHZhbDtcblxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2lzQU1vbWVudE9iamVjdCkpIHtcbiAgICAgICAgICAgIHRvLl9pc0FNb21lbnRPYmplY3QgPSBmcm9tLl9pc0FNb21lbnRPYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pKSkge1xuICAgICAgICAgICAgdG8uX2kgPSBmcm9tLl9pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fZikpIHtcbiAgICAgICAgICAgIHRvLl9mID0gZnJvbS5fZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2wpKSB7XG4gICAgICAgICAgICB0by5fbCA9IGZyb20uX2w7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9zdHJpY3QpKSB7XG4gICAgICAgICAgICB0by5fc3RyaWN0ID0gZnJvbS5fc3RyaWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fdHptKSkge1xuICAgICAgICAgICAgdG8uX3R6bSA9IGZyb20uX3R6bTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2lzVVRDKSkge1xuICAgICAgICAgICAgdG8uX2lzVVRDID0gZnJvbS5faXNVVEM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9vZmZzZXQpKSB7XG4gICAgICAgICAgICB0by5fb2Zmc2V0ID0gZnJvbS5fb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fcGYpKSB7XG4gICAgICAgICAgICB0by5fcGYgPSBnZXRQYXJzaW5nRmxhZ3MoZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9sb2NhbGUpKSB7XG4gICAgICAgICAgICB0by5fbG9jYWxlID0gZnJvbS5fbG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vbWVudFByb3BlcnRpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG1vbWVudFByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwcm9wID0gbW9tZW50UHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgICAgICB2YWwgPSBmcm9tW3Byb3BdO1xuICAgICAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICB0b1twcm9wXSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuXG4gICAgdmFyIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcblxuICAgIC8vIE1vbWVudCBwcm90b3R5cGUgb2JqZWN0XG4gICAgZnVuY3Rpb24gTW9tZW50KGNvbmZpZykge1xuICAgICAgICBjb3B5Q29uZmlnKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgIHRoaXMuX2QgPSBuZXcgRGF0ZShjb25maWcuX2QgIT0gbnVsbCA/IGNvbmZpZy5fZC5nZXRUaW1lKCkgOiBOYU4pO1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9kID0gbmV3IERhdGUoTmFOKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmV2ZW50IGluZmluaXRlIGxvb3AgaW4gY2FzZSB1cGRhdGVPZmZzZXQgY3JlYXRlcyBuZXcgbW9tZW50XG4gICAgICAgIC8vIG9iamVjdHMuXG4gICAgICAgIGlmICh1cGRhdGVJblByb2dyZXNzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdXBkYXRlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc01vbWVudCAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBNb21lbnQgfHwgKG9iaiAhPSBudWxsICYmIG9iai5faXNBTW9tZW50T2JqZWN0ICE9IG51bGwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic0Zsb29yIChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIC8vIC0wIC0+IDBcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKSB8fCAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSW50KGFyZ3VtZW50Rm9yQ29lcmNpb24pIHtcbiAgICAgICAgdmFyIGNvZXJjZWROdW1iZXIgPSArYXJndW1lbnRGb3JDb2VyY2lvbixcbiAgICAgICAgICAgIHZhbHVlID0gMDtcblxuICAgICAgICBpZiAoY29lcmNlZE51bWJlciAhPT0gMCAmJiBpc0Zpbml0ZShjb2VyY2VkTnVtYmVyKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBhYnNGbG9vcihjb2VyY2VkTnVtYmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvLyBjb21wYXJlIHR3byBhcnJheXMsIHJldHVybiB0aGUgbnVtYmVyIG9mIGRpZmZlcmVuY2VzXG4gICAgZnVuY3Rpb24gY29tcGFyZUFycmF5cyhhcnJheTEsIGFycmF5MiwgZG9udENvbnZlcnQpIHtcbiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKGFycmF5MS5sZW5ndGgsIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgbGVuZ3RoRGlmZiA9IE1hdGguYWJzKGFycmF5MS5sZW5ndGggLSBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgICAgIGRpZmZzID0gMCxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKChkb250Q29udmVydCAmJiBhcnJheTFbaV0gIT09IGFycmF5MltpXSkgfHxcbiAgICAgICAgICAgICAgICAoIWRvbnRDb252ZXJ0ICYmIHRvSW50KGFycmF5MVtpXSkgIT09IHRvSW50KGFycmF5MltpXSkpKSB7XG4gICAgICAgICAgICAgICAgZGlmZnMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlmZnMgKyBsZW5ndGhEaWZmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gICAgICAgIGlmIChob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPT09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgKHR5cGVvZiBjb25zb2xlICE9PSAgJ3VuZGVmaW5lZCcpICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdEZXByZWNhdGlvbiB3YXJuaW5nOiAnICsgbXNnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZShtc2csIGZuKSB7XG4gICAgICAgIHZhciBmaXJzdFRpbWUgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiBleHRlbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyKG51bGwsIG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgYXJnO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZyA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1tpXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyArPSAnXFxuWycgKyBpICsgJ10gJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBhcmd1bWVudHNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcgKz0ga2V5ICsgJzogJyArIGFyZ3VtZW50c1swXVtrZXldICsgJywgJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZy5zbGljZSgwLCAtMik7IC8vIFJlbW92ZSB0cmFpbGluZyBjb21tYSBhbmQgc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goYXJnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2Fybihtc2cgKyAnXFxuQXJndW1lbnRzOiAnICsgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncykuam9pbignJykgKyAnXFxuJyArIChuZXcgRXJyb3IoKSkuc3RhY2spO1xuICAgICAgICAgICAgICAgIGZpcnN0VGltZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sIGZuKTtcbiAgICB9XG5cbiAgICB2YXIgZGVwcmVjYXRpb25zID0ge307XG5cbiAgICBmdW5jdGlvbiBkZXByZWNhdGVTaW1wbGUobmFtZSwgbXNnKSB7XG4gICAgICAgIGlmIChob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyKG5hbWUsIG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZXByZWNhdGlvbnNbbmFtZV0pIHtcbiAgICAgICAgICAgIHdhcm4obXNnKTtcbiAgICAgICAgICAgIGRlcHJlY2F0aW9uc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPSBmYWxzZTtcbiAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgPSBudWxsO1xuXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBGdW5jdGlvbiB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldCAoY29uZmlnKSB7XG4gICAgICAgIHZhciBwcm9wLCBpO1xuICAgICAgICBmb3IgKGkgaW4gY29uZmlnKSB7XG4gICAgICAgICAgICBwcm9wID0gY29uZmlnW2ldO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ocHJvcCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2ldID0gcHJvcDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpc1snXycgKyBpXSA9IHByb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xuICAgICAgICAvLyBMZW5pZW50IG9yZGluYWwgcGFyc2luZyBhY2NlcHRzIGp1c3QgYSBudW1iZXIgaW4gYWRkaXRpb24gdG9cbiAgICAgICAgLy8gbnVtYmVyICsgKHBvc3NpYmx5KSBzdHVmZiBjb21pbmcgZnJvbSBfZGF5T2ZNb250aE9yZGluYWxQYXJzZS5cbiAgICAgICAgLy8gVE9ETzogUmVtb3ZlIFwib3JkaW5hbFBhcnNlXCIgZmFsbGJhY2sgaW4gbmV4dCBtYWpvciByZWxlYXNlLlxuICAgICAgICB0aGlzLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlTGVuaWVudCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAodGhpcy5fZGF5T2ZNb250aE9yZGluYWxQYXJzZS5zb3VyY2UgfHwgdGhpcy5fb3JkaW5hbFBhcnNlLnNvdXJjZSkgK1xuICAgICAgICAgICAgICAgICd8JyArICgvXFxkezEsMn0vKS5zb3VyY2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNoaWxkQ29uZmlnKSB7XG4gICAgICAgIHZhciByZXMgPSBleHRlbmQoe30sIHBhcmVudENvbmZpZyksIHByb3A7XG4gICAgICAgIGZvciAocHJvcCBpbiBjaGlsZENvbmZpZykge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoY2hpbGRDb25maWcsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHBhcmVudENvbmZpZ1twcm9wXSkgJiYgaXNPYmplY3QoY2hpbGRDb25maWdbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBleHRlbmQocmVzW3Byb3BdLCBwYXJlbnRDb25maWdbcHJvcF0pO1xuICAgICAgICAgICAgICAgICAgICBleHRlbmQocmVzW3Byb3BdLCBjaGlsZENvbmZpZ1twcm9wXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGlsZENvbmZpZ1twcm9wXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IGNoaWxkQ29uZmlnW3Byb3BdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXNbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAocHJvcCBpbiBwYXJlbnRDb25maWcpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKHBhcmVudENvbmZpZywgcHJvcCkgJiZcbiAgICAgICAgICAgICAgICAgICAgIWhhc093blByb3AoY2hpbGRDb25maWcsIHByb3ApICYmXG4gICAgICAgICAgICAgICAgICAgIGlzT2JqZWN0KHBhcmVudENvbmZpZ1twcm9wXSkpIHtcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgY2hhbmdlcyB0byBwcm9wZXJ0aWVzIGRvbid0IG1vZGlmeSBwYXJlbnQgY29uZmlnXG4gICAgICAgICAgICAgICAgcmVzW3Byb3BdID0gZXh0ZW5kKHt9LCByZXNbcHJvcF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTG9jYWxlKGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIga2V5cztcblxuICAgIGlmIChPYmplY3Qua2V5cykge1xuICAgICAgICBrZXlzID0gT2JqZWN0LmtleXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAga2V5cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHZhciBpLCByZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcChvYmosIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRDYWxlbmRhciA9IHtcbiAgICAgICAgc2FtZURheSA6ICdbVG9kYXkgYXRdIExUJyxcbiAgICAgICAgbmV4dERheSA6ICdbVG9tb3Jyb3cgYXRdIExUJyxcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBbYXRdIExUJyxcbiAgICAgICAgbGFzdERheSA6ICdbWWVzdGVyZGF5IGF0XSBMVCcsXG4gICAgICAgIGxhc3RXZWVrIDogJ1tMYXN0XSBkZGRkIFthdF0gTFQnLFxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjYWxlbmRhciAoa2V5LCBtb20sIG5vdykge1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fY2FsZW5kYXJba2V5XSB8fCB0aGlzLl9jYWxlbmRhclsnc2FtZUVsc2UnXTtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24ob3V0cHV0KSA/IG91dHB1dC5jYWxsKG1vbSwgbm93KSA6IG91dHB1dDtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvbmdEYXRlRm9ybWF0ID0ge1xuICAgICAgICBMVFMgIDogJ2g6bW06c3MgQScsXG4gICAgICAgIExUICAgOiAnaDptbSBBJyxcbiAgICAgICAgTCAgICA6ICdNTS9ERC9ZWVlZJyxcbiAgICAgICAgTEwgICA6ICdNTU1NIEQsIFlZWVknLFxuICAgICAgICBMTEwgIDogJ01NTU0gRCwgWVlZWSBoOm1tIEEnLFxuICAgICAgICBMTExMIDogJ2RkZGQsIE1NTU0gRCwgWVlZWSBoOm1tIEEnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvbmdEYXRlRm9ybWF0IChrZXkpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0sXG4gICAgICAgICAgICBmb3JtYXRVcHBlciA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleS50b1VwcGVyQ2FzZSgpXTtcblxuICAgICAgICBpZiAoZm9ybWF0IHx8ICFmb3JtYXRVcHBlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0gPSBmb3JtYXRVcHBlci5yZXBsYWNlKC9NTU1NfE1NfEREfGRkZGQvZywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbC5zbGljZSgxKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRJbnZhbGlkRGF0ZSA9ICdJbnZhbGlkIGRhdGUnO1xuXG4gICAgZnVuY3Rpb24gaW52YWxpZERhdGUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52YWxpZERhdGU7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRPcmRpbmFsID0gJyVkJztcbiAgICB2YXIgZGVmYXVsdERheU9mTW9udGhPcmRpbmFsUGFyc2UgPSAvXFxkezEsMn0vO1xuXG4gICAgZnVuY3Rpb24gb3JkaW5hbCAobnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcmRpbmFsLnJlcGxhY2UoJyVkJywgbnVtYmVyKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFJlbGF0aXZlVGltZSA9IHtcbiAgICAgICAgZnV0dXJlIDogJ2luICVzJyxcbiAgICAgICAgcGFzdCAgIDogJyVzIGFnbycsXG4gICAgICAgIHMgIDogJ2EgZmV3IHNlY29uZHMnLFxuICAgICAgICBzcyA6ICclZCBzZWNvbmRzJyxcbiAgICAgICAgbSAgOiAnYSBtaW51dGUnLFxuICAgICAgICBtbSA6ICclZCBtaW51dGVzJyxcbiAgICAgICAgaCAgOiAnYW4gaG91cicsXG4gICAgICAgIGhoIDogJyVkIGhvdXJzJyxcbiAgICAgICAgZCAgOiAnYSBkYXknLFxuICAgICAgICBkZCA6ICclZCBkYXlzJyxcbiAgICAgICAgTSAgOiAnYSBtb250aCcsXG4gICAgICAgIE1NIDogJyVkIG1vbnRocycsXG4gICAgICAgIHkgIDogJ2EgeWVhcicsXG4gICAgICAgIHl5IDogJyVkIHllYXJzJ1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiByZWxhdGl2ZVRpbWUgKG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSkge1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW3N0cmluZ107XG4gICAgICAgIHJldHVybiAoaXNGdW5jdGlvbihvdXRwdXQpKSA/XG4gICAgICAgICAgICBvdXRwdXQobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSA6XG4gICAgICAgICAgICBvdXRwdXQucmVwbGFjZSgvJWQvaSwgbnVtYmVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXN0RnV0dXJlIChkaWZmLCBvdXRwdXQpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX3JlbGF0aXZlVGltZVtkaWZmID4gMCA/ICdmdXR1cmUnIDogJ3Bhc3QnXTtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oZm9ybWF0KSA/IGZvcm1hdChvdXRwdXQpIDogZm9ybWF0LnJlcGxhY2UoLyVzL2ksIG91dHB1dCk7XG4gICAgfVxuXG4gICAgdmFyIGFsaWFzZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFVuaXRBbGlhcyAodW5pdCwgc2hvcnRoYW5kKSB7XG4gICAgICAgIHZhciBsb3dlckNhc2UgPSB1bml0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGFsaWFzZXNbbG93ZXJDYXNlXSA9IGFsaWFzZXNbbG93ZXJDYXNlICsgJ3MnXSA9IGFsaWFzZXNbc2hvcnRoYW5kXSA9IHVuaXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplVW5pdHModW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB1bml0cyA9PT0gJ3N0cmluZycgPyBhbGlhc2VzW3VuaXRzXSB8fCBhbGlhc2VzW3VuaXRzLnRvTG93ZXJDYXNlKCldIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZU9iamVjdFVuaXRzKGlucHV0T2JqZWN0KSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSB7fSxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wLFxuICAgICAgICAgICAgcHJvcDtcblxuICAgICAgICBmb3IgKHByb3AgaW4gaW5wdXRPYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGlucHV0T2JqZWN0LCBwcm9wKSkge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wID0gbm9ybWFsaXplVW5pdHMocHJvcCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRQcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRJbnB1dFtub3JtYWxpemVkUHJvcF0gPSBpbnB1dE9iamVjdFtwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZElucHV0O1xuICAgIH1cblxuICAgIHZhciBwcmlvcml0aWVzID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGRVbml0UHJpb3JpdHkodW5pdCwgcHJpb3JpdHkpIHtcbiAgICAgICAgcHJpb3JpdGllc1t1bml0XSA9IHByaW9yaXR5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFByaW9yaXRpemVkVW5pdHModW5pdHNPYmopIHtcbiAgICAgICAgdmFyIHVuaXRzID0gW107XG4gICAgICAgIGZvciAodmFyIHUgaW4gdW5pdHNPYmopIHtcbiAgICAgICAgICAgIHVuaXRzLnB1c2goe3VuaXQ6IHUsIHByaW9yaXR5OiBwcmlvcml0aWVzW3VdfSk7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEucHJpb3JpdHkgLSBiLnByaW9yaXR5O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHVuaXRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHplcm9GaWxsKG51bWJlciwgdGFyZ2V0TGVuZ3RoLCBmb3JjZVNpZ24pIHtcbiAgICAgICAgdmFyIGFic051bWJlciA9ICcnICsgTWF0aC5hYnMobnVtYmVyKSxcbiAgICAgICAgICAgIHplcm9zVG9GaWxsID0gdGFyZ2V0TGVuZ3RoIC0gYWJzTnVtYmVyLmxlbmd0aCxcbiAgICAgICAgICAgIHNpZ24gPSBudW1iZXIgPj0gMDtcbiAgICAgICAgcmV0dXJuIChzaWduID8gKGZvcmNlU2lnbiA/ICcrJyA6ICcnKSA6ICctJykgK1xuICAgICAgICAgICAgTWF0aC5wb3coMTAsIE1hdGgubWF4KDAsIHplcm9zVG9GaWxsKSkudG9TdHJpbmcoKS5zdWJzdHIoMSkgKyBhYnNOdW1iZXI7XG4gICAgfVxuXG4gICAgdmFyIGZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oW0hoXW1tKHNzKT98TW98TU0/TT9NP3xEb3xERERvfEREP0Q/RD98ZGRkP2Q/fGRvP3x3W298d10/fFdbb3xXXT98UW8/fFlZWVlZWXxZWVlZWXxZWVlZfFlZfGdnKGdnZz8pP3xHRyhHR0c/KT98ZXxFfGF8QXxoaD98SEg/fGtrP3xtbT98c3M/fFN7MSw5fXx4fFh8eno/fFpaP3wuKS9nO1xuXG4gICAgdmFyIGxvY2FsRm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhMVFN8TFR8TEw/TD9MP3xsezEsNH0pL2c7XG5cbiAgICB2YXIgZm9ybWF0RnVuY3Rpb25zID0ge307XG5cbiAgICB2YXIgZm9ybWF0VG9rZW5GdW5jdGlvbnMgPSB7fTtcblxuICAgIC8vIHRva2VuOiAgICAnTSdcbiAgICAvLyBwYWRkZWQ6ICAgWydNTScsIDJdXG4gICAgLy8gb3JkaW5hbDogICdNbydcbiAgICAvLyBjYWxsYmFjazogZnVuY3Rpb24gKCkgeyB0aGlzLm1vbnRoKCkgKyAxIH1cbiAgICBmdW5jdGlvbiBhZGRGb3JtYXRUb2tlbiAodG9rZW4sIHBhZGRlZCwgb3JkaW5hbCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBjYWxsYmFjaztcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbY2FsbGJhY2tdKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dID0gZnVuYztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFkZGVkKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1twYWRkZWRbMF1dID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB6ZXJvRmlsbChmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHBhZGRlZFsxXSwgcGFkZGVkWzJdKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yZGluYWwpIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW29yZGluYWxdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5vcmRpbmFsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdG9rZW4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0Lm1hdGNoKC9cXFtbXFxzXFxTXS8pKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXlxcW3xcXF0kL2csICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXFxcXC9nLCAnJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCkge1xuICAgICAgICB2YXIgYXJyYXkgPSBmb3JtYXQubWF0Y2goZm9ybWF0dGluZ1Rva2VucyksIGksIGxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXSkge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoYXJyYXlbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtb20pIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSAnJywgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSBpc0Z1bmN0aW9uKGFycmF5W2ldKSA/IGFycmF5W2ldLmNhbGwobW9tLCBmb3JtYXQpIDogYXJyYXlbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIGZvcm1hdCBkYXRlIHVzaW5nIG5hdGl2ZSBkYXRlIG9iamVjdFxuICAgIGZ1bmN0aW9uIGZvcm1hdE1vbWVudChtLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFtLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG0ubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBleHBhbmRGb3JtYXQoZm9ybWF0LCBtLmxvY2FsZURhdGEoKSk7XG4gICAgICAgIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdID0gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gfHwgbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCk7XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdKG0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cGFuZEZvcm1hdChmb3JtYXQsIGxvY2FsZSkge1xuICAgICAgICB2YXIgaSA9IDU7XG5cbiAgICAgICAgZnVuY3Rpb24gcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLmxvbmdEYXRlRm9ybWF0KGlucHV0KSB8fCBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAoaSA+PSAwICYmIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy50ZXN0KGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKGxvY2FsRm9ybWF0dGluZ1Rva2VucywgcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKTtcbiAgICAgICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2gxICAgICAgICAgPSAvXFxkLzsgICAgICAgICAgICAvLyAgICAgICAwIC0gOVxuICAgIHZhciBtYXRjaDIgICAgICAgICA9IC9cXGRcXGQvOyAgICAgICAgICAvLyAgICAgIDAwIC0gOTlcbiAgICB2YXIgbWF0Y2gzICAgICAgICAgPSAvXFxkezN9LzsgICAgICAgICAvLyAgICAgMDAwIC0gOTk5XG4gICAgdmFyIG1hdGNoNCAgICAgICAgID0gL1xcZHs0fS87ICAgICAgICAgLy8gICAgMDAwMCAtIDk5OTlcbiAgICB2YXIgbWF0Y2g2ICAgICAgICAgPSAvWystXT9cXGR7Nn0vOyAgICAvLyAtOTk5OTk5IC0gOTk5OTk5XG4gICAgdmFyIG1hdGNoMXRvMiAgICAgID0gL1xcZFxcZD8vOyAgICAgICAgIC8vICAgICAgIDAgLSA5OVxuICAgIHZhciBtYXRjaDN0bzQgICAgICA9IC9cXGRcXGRcXGRcXGQ/LzsgICAgIC8vICAgICA5OTkgLSA5OTk5XG4gICAgdmFyIG1hdGNoNXRvNiAgICAgID0gL1xcZFxcZFxcZFxcZFxcZFxcZD8vOyAvLyAgIDk5OTk5IC0gOTk5OTk5XG4gICAgdmFyIG1hdGNoMXRvMyAgICAgID0gL1xcZHsxLDN9LzsgICAgICAgLy8gICAgICAgMCAtIDk5OVxuICAgIHZhciBtYXRjaDF0bzQgICAgICA9IC9cXGR7MSw0fS87ICAgICAgIC8vICAgICAgIDAgLSA5OTk5XG4gICAgdmFyIG1hdGNoMXRvNiAgICAgID0gL1srLV0/XFxkezEsNn0vOyAgLy8gLTk5OTk5OSAtIDk5OTk5OVxuXG4gICAgdmFyIG1hdGNoVW5zaWduZWQgID0gL1xcZCsvOyAgICAgICAgICAgLy8gICAgICAgMCAtIGluZlxuICAgIHZhciBtYXRjaFNpZ25lZCAgICA9IC9bKy1dP1xcZCsvOyAgICAgIC8vICAgIC1pbmYgLSBpbmZcblxuICAgIHZhciBtYXRjaE9mZnNldCAgICA9IC9afFsrLV1cXGRcXGQ6P1xcZFxcZC9naTsgLy8gKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG4gICAgdmFyIG1hdGNoU2hvcnRPZmZzZXQgPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy9naTsgLy8gKzAwIC0wMCArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcblxuICAgIHZhciBtYXRjaFRpbWVzdGFtcCA9IC9bKy1dP1xcZCsoXFwuXFxkezEsM30pPy87IC8vIDEyMzQ1Njc4OSAxMjM0NTY3ODkuMTIzXG5cbiAgICAvLyBhbnkgd29yZCAob3IgdHdvKSBjaGFyYWN0ZXJzIG9yIG51bWJlcnMgaW5jbHVkaW5nIHR3by90aHJlZSB3b3JkIG1vbnRoIGluIGFyYWJpYy5cbiAgICAvLyBpbmNsdWRlcyBzY290dGlzaCBnYWVsaWMgdHdvIHdvcmQgYW5kIGh5cGhlbmF0ZWQgbW9udGhzXG4gICAgdmFyIG1hdGNoV29yZCA9IC9bMC05XXswLDI1Nn1bJ2EtelxcdTAwQTAtXFx1MDVGRlxcdTA3MDAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkYwN1xcdUZGMTAtXFx1RkZFRl17MSwyNTZ9fFtcXHUwNjAwLVxcdTA2RkZcXC9dezEsMjU2fShcXHMqP1tcXHUwNjAwLVxcdTA2RkZdezEsMjU2fSl7MSwyfS9pO1xuXG4gICAgdmFyIHJlZ2V4ZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFJlZ2V4VG9rZW4gKHRva2VuLCByZWdleCwgc3RyaWN0UmVnZXgpIHtcbiAgICAgICAgcmVnZXhlc1t0b2tlbl0gPSBpc0Z1bmN0aW9uKHJlZ2V4KSA/IHJlZ2V4IDogZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGVEYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gKGlzU3RyaWN0ICYmIHN0cmljdFJlZ2V4KSA/IHN0cmljdFJlZ2V4IDogcmVnZXg7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2VSZWdleEZvclRva2VuICh0b2tlbiwgY29uZmlnKSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcChyZWdleGVzLCB0b2tlbikpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHVuZXNjYXBlRm9ybWF0KHRva2VuKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVnZXhlc1t0b2tlbl0oY29uZmlnLl9zdHJpY3QsIGNvbmZpZy5fbG9jYWxlKTtcbiAgICB9XG5cbiAgICAvLyBDb2RlIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNTYxNDkzL2lzLXRoZXJlLWEtcmVnZXhwLWVzY2FwZS1mdW5jdGlvbi1pbi1qYXZhc2NyaXB0XG4gICAgZnVuY3Rpb24gdW5lc2NhcGVGb3JtYXQocykge1xuICAgICAgICByZXR1cm4gcmVnZXhFc2NhcGUocy5yZXBsYWNlKCdcXFxcJywgJycpLnJlcGxhY2UoL1xcXFwoXFxbKXxcXFxcKFxcXSl8XFxbKFteXFxdXFxbXSopXFxdfFxcXFwoLikvZywgZnVuY3Rpb24gKG1hdGNoZWQsIHAxLCBwMiwgcDMsIHA0KSB7XG4gICAgICAgICAgICByZXR1cm4gcDEgfHwgcDIgfHwgcDMgfHwgcDQ7XG4gICAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWdleEVzY2FwZShzKSB7XG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xuICAgIH1cblxuICAgIHZhciB0b2tlbnMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFBhcnNlVG9rZW4gKHRva2VuLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgaSwgZnVuYyA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdG9rZW4gPSBbdG9rZW5dO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc051bWJlcihjYWxsYmFjaykpIHtcbiAgICAgICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbY2FsbGJhY2tdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRva2Vuc1t0b2tlbltpXV0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkV2Vla1BhcnNlVG9rZW4gKHRva2VuLCBjYWxsYmFjaykge1xuICAgICAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgICAgICBjb25maWcuX3cgPSBjb25maWcuX3cgfHwge307XG4gICAgICAgICAgICBjYWxsYmFjayhpbnB1dCwgY29uZmlnLl93LCBjb25maWcsIHRva2VuKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIGlucHV0LCBjb25maWcpIHtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwgJiYgaGFzT3duUHJvcCh0b2tlbnMsIHRva2VuKSkge1xuICAgICAgICAgICAgdG9rZW5zW3Rva2VuXShpbnB1dCwgY29uZmlnLl9hLCBjb25maWcsIHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBZRUFSID0gMDtcbiAgICB2YXIgTU9OVEggPSAxO1xuICAgIHZhciBEQVRFID0gMjtcbiAgICB2YXIgSE9VUiA9IDM7XG4gICAgdmFyIE1JTlVURSA9IDQ7XG4gICAgdmFyIFNFQ09ORCA9IDU7XG4gICAgdmFyIE1JTExJU0VDT05EID0gNjtcbiAgICB2YXIgV0VFSyA9IDc7XG4gICAgdmFyIFdFRUtEQVkgPSA4O1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1knLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB5ID0gdGhpcy55ZWFyKCk7XG4gICAgICAgIHJldHVybiB5IDw9IDk5OTkgPyAnJyArIHkgOiAnKycgKyB5O1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWScsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnllYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWScsICAgNF0sICAgICAgIDAsICd5ZWFyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWScsICA1XSwgICAgICAgMCwgJ3llYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZWScsIDYsIHRydWVdLCAwLCAneWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd5ZWFyJywgJ3knKTtcblxuICAgIC8vIFBSSU9SSVRJRVNcblxuICAgIGFkZFVuaXRQcmlvcml0eSgneWVhcicsIDEpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignWScsICAgICAgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWVknLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVlZWScsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydZWVlZWScsICdZWVlZWVknXSwgWUVBUik7XG4gICAgYWRkUGFyc2VUb2tlbignWVlZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBpbnB1dC5sZW5ndGggPT09IDIgPyBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCkgOiB0b0ludChpbnB1dCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W1lFQVJdID0gaG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1knLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W1lFQVJdID0gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIGZ1bmN0aW9uIGRheXNJblllYXIoeWVhcikge1xuICAgICAgICByZXR1cm4gaXNMZWFwWWVhcih5ZWFyKSA/IDM2NiA6IDM2NTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiAgICAgICAgcmV0dXJuICh5ZWFyICUgNCA9PT0gMCAmJiB5ZWFyICUgMTAwICE9PSAwKSB8fCB5ZWFyICUgNDAwID09PSAwO1xuICAgIH1cblxuICAgIC8vIEhPT0tTXG5cbiAgICBob29rcy5wYXJzZVR3b0RpZ2l0WWVhciA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gdG9JbnQoaW5wdXQpICsgKHRvSW50KGlucHV0KSA+IDY4ID8gMTkwMCA6IDIwMDApO1xuICAgIH07XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0WWVhciA9IG1ha2VHZXRTZXQoJ0Z1bGxZZWFyJywgdHJ1ZSk7XG5cbiAgICBmdW5jdGlvbiBnZXRJc0xlYXBZZWFyICgpIHtcbiAgICAgICAgcmV0dXJuIGlzTGVhcFllYXIodGhpcy55ZWFyKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VHZXRTZXQgKHVuaXQsIGtlZXBUaW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2V0JDEodGhpcywgdW5pdCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCBrZWVwVGltZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXQodGhpcywgdW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0IChtb20sIHVuaXQpIHtcbiAgICAgICAgcmV0dXJuIG1vbS5pc1ZhbGlkKCkgP1xuICAgICAgICAgICAgbW9tLl9kWydnZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKCkgOiBOYU47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0JDEgKG1vbSwgdW5pdCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG1vbS5pc1ZhbGlkKCkgJiYgIWlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKHVuaXQgPT09ICdGdWxsWWVhcicgJiYgaXNMZWFwWWVhcihtb20ueWVhcigpKSAmJiBtb20ubW9udGgoKSA9PT0gMSAmJiBtb20uZGF0ZSgpID09PSAyOSkge1xuICAgICAgICAgICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSh2YWx1ZSwgbW9tLm1vbnRoKCksIGRheXNJbk1vbnRoKHZhbHVlLCBtb20ubW9udGgoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIHN0cmluZ0dldCAodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXNbdW5pdHNdKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBzdHJpbmdTZXQgKHVuaXRzLCB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHVuaXRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVPYmplY3RVbml0cyh1bml0cyk7XG4gICAgICAgICAgICB2YXIgcHJpb3JpdGl6ZWQgPSBnZXRQcmlvcml0aXplZFVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJpb3JpdGl6ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzW3ByaW9yaXRpemVkW2ldLnVuaXRdKHVuaXRzW3ByaW9yaXRpemVkW2ldLnVuaXRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb2QobiwgeCkge1xuICAgICAgICByZXR1cm4gKChuICUgeCkgKyB4KSAlIHg7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4T2Y7XG5cbiAgICBpZiAoQXJyYXkucHJvdG90eXBlLmluZGV4T2YpIHtcbiAgICAgICAgaW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4T2YgPSBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgLy8gSSBrbm93XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNbaV0gPT09IG8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XG4gICAgICAgIGlmIChpc05hTih5ZWFyKSB8fCBpc05hTihtb250aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1vZE1vbnRoID0gbW9kKG1vbnRoLCAxMik7XG4gICAgICAgIHllYXIgKz0gKG1vbnRoIC0gbW9kTW9udGgpIC8gMTI7XG4gICAgICAgIHJldHVybiBtb2RNb250aCA9PT0gMSA/IChpc0xlYXBZZWFyKHllYXIpID8gMjkgOiAyOCkgOiAoMzEgLSBtb2RNb250aCAlIDcgJSAyKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignTScsIFsnTU0nLCAyXSwgJ01vJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb250aCgpICsgMTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHNTaG9ydCh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ01NTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHModGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnbW9udGgnLCAnTScpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnbW9udGgnLCA4KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ00nLCAgICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NJywgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignTU1NJywgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUubW9udGhzU2hvcnRSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG4gICAgYWRkUmVnZXhUb2tlbignTU1NTScsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUubW9udGhzUmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ00nLCAnTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNT05USF0gPSB0b0ludChpbnB1dCkgLSAxO1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ01NTScsICdNTU1NJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgdmFyIG1vbnRoID0gY29uZmlnLl9sb2NhbGUubW9udGhzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XG4gICAgICAgIC8vIGlmIHdlIGRpZG4ndCBmaW5kIGEgbW9udGggbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkLlxuICAgICAgICBpZiAobW9udGggIT0gbnVsbCkge1xuICAgICAgICAgICAgYXJyYXlbTU9OVEhdID0gbW9udGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkTW9udGggPSBpbnB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgdmFyIE1PTlRIU19JTl9GT1JNQVQgPSAvRFtvRF0/KFxcW1teXFxbXFxdXSpcXF18XFxzKStNTU1NPy87XG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNb250aHMgPSAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHMgKG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRocykgPyB0aGlzLl9tb250aHMgOlxuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1snc3RhbmRhbG9uZSddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRocykgPyB0aGlzLl9tb250aHNbbS5tb250aCgpXSA6XG4gICAgICAgICAgICB0aGlzLl9tb250aHNbKHRoaXMuX21vbnRocy5pc0Zvcm1hdCB8fCBNT05USFNfSU5fRk9STUFUKS50ZXN0KGZvcm1hdCkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ11bbS5tb250aCgpXTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0ID0gJ0phbl9GZWJfTWFyX0Fwcl9NYXlfSnVuX0p1bF9BdWdfU2VwX09jdF9Ob3ZfRGVjJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRoc1Nob3J0IChtLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHNTaG9ydCkgPyB0aGlzLl9tb250aHNTaG9ydCA6XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRbJ3N0YW5kYWxvbmUnXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHNTaG9ydCkgPyB0aGlzLl9tb250aHNTaG9ydFttLm1vbnRoKCldIDpcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0W01PTlRIU19JTl9GT1JNQVQudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSddW20ubW9udGgoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlU3RyaWN0UGFyc2UobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgaWksIG1vbSwgbGxjID0gbW9udGhOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2UpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IHVzZWRcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgKytpKSB7XG4gICAgICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSB0aGlzLm1vbnRocyhtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ01NTScpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ01NTScpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHNQYXJzZSAobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVN0cmljdFBhcnNlLmNhbGwodGhpcywgbW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX21vbnRoc1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBhZGQgc29ydGluZ1xuICAgICAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIG1vbnRoIChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyXG4gICAgICAgIC8vIHNlZSBzb3J0aW5nIGluIGNvbXB1dGVNb250aHNQYXJzZVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgIXRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJywgJ2knKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN0cmljdCAmJiAhdGhpcy5fbW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICByZWdleCA9ICdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdNTU1NJyAmJiB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdNTU0nICYmIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fbW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBzZXRNb250aCAobW9tLCB2YWx1ZSkge1xuICAgICAgICB2YXIgZGF5T2ZNb250aDtcblxuICAgICAgICBpZiAoIW1vbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIC8vIE5vIG9wXG4gICAgICAgICAgICByZXR1cm4gbW9tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICgvXlxcZCskLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdG9JbnQodmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG1vbS5sb2NhbGVEYXRhKCkubW9udGhzUGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IEFub3RoZXIgc2lsZW50IGZhaWx1cmU/XG4gICAgICAgICAgICAgICAgaWYgKCFpc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkYXlPZk1vbnRoID0gTWF0aC5taW4obW9tLmRhdGUoKSwgZGF5c0luTW9udGgobW9tLnllYXIoKSwgdmFsdWUpKTtcbiAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArICdNb250aCddKHZhbHVlLCBkYXlPZk1vbnRoKTtcbiAgICAgICAgcmV0dXJuIG1vbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRNb250aCAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldE1vbnRoKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGdldCh0aGlzLCAnTW9udGgnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERheXNJbk1vbnRoICgpIHtcbiAgICAgICAgcmV0dXJuIGRheXNJbk1vbnRoKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TW9udGhzU2hvcnRSZWdleCA9IG1hdGNoV29yZDtcbiAgICBmdW5jdGlvbiBtb250aHNTaG9ydFJlZ2V4IChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVNb250aHNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzU2hvcnRSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRSZWdleCA9IGRlZmF1bHRNb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggOiB0aGlzLl9tb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRNb250aHNSZWdleCA9IG1hdGNoV29yZDtcbiAgICBmdW5jdGlvbiBtb250aHNSZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlTW9udGhzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1JlZ2V4ID0gZGVmYXVsdE1vbnRoc1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNTdHJpY3RSZWdleCA6IHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZU1vbnRoc1BhcnNlICgpIHtcbiAgICAgICAgZnVuY3Rpb24gY21wTGVuUmV2KGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNob3J0UGllY2VzID0gW10sIGxvbmdQaWVjZXMgPSBbXSwgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIGksIG1vbTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICBzaG9ydFBpZWNlcy5wdXNoKHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykpO1xuICAgICAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKHRoaXMubW9udGhzKG1vbSwgJycpKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2godGhpcy5tb250aHMobW9tLCAnJykpO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaCh0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIG1vbnRoIChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XG4gICAgICAgIC8vIHdpbGwgbWF0Y2ggdGhlIGxvbmdlciBwaWVjZS5cbiAgICAgICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBsb25nUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbWl4ZWRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgc2hvcnRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShzaG9ydFBpZWNlc1tpXSk7XG4gICAgICAgICAgICBsb25nUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobG9uZ1BpZWNlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDI0OyBpKyspIHtcbiAgICAgICAgICAgIG1peGVkUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobWl4ZWRQaWVjZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbW9udGhzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX21vbnRoc1Nob3J0UmVnZXggPSB0aGlzLl9tb250aHNSZWdleDtcbiAgICAgICAgdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBsb25nUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIHNob3J0UGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVEYXRlICh5LCBtLCBkLCBoLCBNLCBzLCBtcykge1xuICAgICAgICAvLyBjYW4ndCBqdXN0IGFwcGx5KCkgdG8gY3JlYXRlIGEgZGF0ZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzE4MTM0OFxuICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHksIG0sIGQsIGgsIE0sIHMsIG1zKTtcblxuICAgICAgICAvLyB0aGUgZGF0ZSBjb25zdHJ1Y3RvciByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwICYmIGlzRmluaXRlKGRhdGUuZ2V0RnVsbFllYXIoKSkpIHtcbiAgICAgICAgICAgIGRhdGUuc2V0RnVsbFllYXIoeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlVVRDRGF0ZSAoeSkge1xuICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuXG4gICAgICAgIC8vIHRoZSBEYXRlLlVUQyBmdW5jdGlvbiByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwICYmIGlzRmluaXRlKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSkpIHtcbiAgICAgICAgICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgLy8gc3RhcnQtb2YtZmlyc3Qtd2VlayAtIHN0YXJ0LW9mLXllYXJcbiAgICBmdW5jdGlvbiBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIC8vIGZpcnN0LXdlZWsgZGF5IC0tIHdoaWNoIGphbnVhcnkgaXMgYWx3YXlzIGluIHRoZSBmaXJzdCB3ZWVrICg0IGZvciBpc28sIDEgZm9yIG90aGVyKVxuICAgICAgICAgICAgZndkID0gNyArIGRvdyAtIGRveSxcbiAgICAgICAgICAgIC8vIGZpcnN0LXdlZWsgZGF5IGxvY2FsIHdlZWtkYXkgLS0gd2hpY2ggbG9jYWwgd2Vla2RheSBpcyBmd2RcbiAgICAgICAgICAgIGZ3ZGx3ID0gKDcgKyBjcmVhdGVVVENEYXRlKHllYXIsIDAsIGZ3ZCkuZ2V0VVRDRGF5KCkgLSBkb3cpICUgNztcblxuICAgICAgICByZXR1cm4gLWZ3ZGx3ICsgZndkIC0gMTtcbiAgICB9XG5cbiAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlI0NhbGN1bGF0aW5nX2FfZGF0ZV9naXZlbl90aGVfeWVhci4yQ193ZWVrX251bWJlcl9hbmRfd2Vla2RheVxuICAgIGZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrcyh5ZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgICAgICB2YXIgbG9jYWxXZWVrZGF5ID0gKDcgKyB3ZWVrZGF5IC0gZG93KSAlIDcsXG4gICAgICAgICAgICB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSxcbiAgICAgICAgICAgIGRheU9mWWVhciA9IDEgKyA3ICogKHdlZWsgLSAxKSArIGxvY2FsV2Vla2RheSArIHdlZWtPZmZzZXQsXG4gICAgICAgICAgICByZXNZZWFyLCByZXNEYXlPZlllYXI7XG5cbiAgICAgICAgaWYgKGRheU9mWWVhciA8PSAwKSB7XG4gICAgICAgICAgICByZXNZZWFyID0geWVhciAtIDE7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlzSW5ZZWFyKHJlc1llYXIpICsgZGF5T2ZZZWFyO1xuICAgICAgICB9IGVsc2UgaWYgKGRheU9mWWVhciA+IGRheXNJblllYXIoeWVhcikpIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSB5ZWFyICsgMTtcbiAgICAgICAgICAgIHJlc0RheU9mWWVhciA9IGRheU9mWWVhciAtIGRheXNJblllYXIoeWVhcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNZZWFyID0geWVhcjtcbiAgICAgICAgICAgIHJlc0RheU9mWWVhciA9IGRheU9mWWVhcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5ZWFyOiByZXNZZWFyLFxuICAgICAgICAgICAgZGF5T2ZZZWFyOiByZXNEYXlPZlllYXJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3ZWVrT2ZZZWFyKG1vbSwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQobW9tLnllYXIoKSwgZG93LCBkb3kpLFxuICAgICAgICAgICAgd2VlayA9IE1hdGguZmxvb3IoKG1vbS5kYXlPZlllYXIoKSAtIHdlZWtPZmZzZXQgLSAxKSAvIDcpICsgMSxcbiAgICAgICAgICAgIHJlc1dlZWssIHJlc1llYXI7XG5cbiAgICAgICAgaWYgKHdlZWsgPCAxKSB7XG4gICAgICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKSAtIDE7XG4gICAgICAgICAgICByZXNXZWVrID0gd2VlayArIHdlZWtzSW5ZZWFyKHJlc1llYXIsIGRvdywgZG95KTtcbiAgICAgICAgfSBlbHNlIGlmICh3ZWVrID4gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpKSB7XG4gICAgICAgICAgICByZXNXZWVrID0gd2VlayAtIHdlZWtzSW5ZZWFyKG1vbS55ZWFyKCksIGRvdywgZG95KTtcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpO1xuICAgICAgICAgICAgcmVzV2VlayA9IHdlZWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2VlazogcmVzV2VlayxcbiAgICAgICAgICAgIHllYXI6IHJlc1llYXJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3ZWVrc0luWWVhcih5ZWFyLCBkb3csIGRveSkge1xuICAgICAgICB2YXIgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSksXG4gICAgICAgICAgICB3ZWVrT2Zmc2V0TmV4dCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyICsgMSwgZG93LCBkb3kpO1xuICAgICAgICByZXR1cm4gKGRheXNJblllYXIoeWVhcikgLSB3ZWVrT2Zmc2V0ICsgd2Vla09mZnNldE5leHQpIC8gNztcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbigndycsIFsnd3cnLCAyXSwgJ3dvJywgJ3dlZWsnKTtcbiAgICBhZGRGb3JtYXRUb2tlbignVycsIFsnV1cnLCAyXSwgJ1dvJywgJ2lzb1dlZWsnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnd2VlaycsICd3Jyk7XG4gICAgYWRkVW5pdEFsaWFzKCdpc29XZWVrJywgJ1cnKTtcblxuICAgIC8vIFBSSU9SSVRJRVNcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnd2VlaycsIDUpO1xuICAgIGFkZFVuaXRQcmlvcml0eSgnaXNvV2VlaycsIDUpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigndycsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3d3JywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1cnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdXVycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsndycsICd3dycsICdXJywgJ1dXJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuLnN1YnN0cigwLCAxKV0gPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrIChtb20pIHtcbiAgICAgICAgcmV0dXJuIHdlZWtPZlllYXIobW9tLCB0aGlzLl93ZWVrLmRvdywgdGhpcy5fd2Vlay5kb3kpLndlZWs7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrID0ge1xuICAgICAgICBkb3cgOiAwLCAvLyBTdW5kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgZG95IDogNiAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVGaXJzdERheU9mV2VlayAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrLmRvdztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVGaXJzdERheU9mWWVhciAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrLmRveTtcbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRXZWVrIChpbnB1dCkge1xuICAgICAgICB2YXIgd2VlayA9IHRoaXMubG9jYWxlRGF0YSgpLndlZWsodGhpcyk7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09XZWVrIChpbnB1dCkge1xuICAgICAgICB2YXIgd2VlayA9IHdlZWtPZlllYXIodGhpcywgMSwgNCkud2VlaztcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkJywgMCwgJ2RvJywgJ2RheScpO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNNaW4odGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c1Nob3J0KHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGRkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzKHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZScsIDAsIDAsICd3ZWVrZGF5Jyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ0UnLCAwLCAwLCAnaXNvV2Vla2RheScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdkYXknLCAnZCcpO1xuICAgIGFkZFVuaXRBbGlhcygnd2Vla2RheScsICdlJyk7XG4gICAgYWRkVW5pdEFsaWFzKCdpc29XZWVrZGF5JywgJ0UnKTtcblxuICAgIC8vIFBSSU9SSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdkYXknLCAxMSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCd3ZWVrZGF5JywgMTEpO1xuICAgIGFkZFVuaXRQcmlvcml0eSgnaXNvV2Vla2RheScsIDExKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2QnLCAgICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2UnLCAgICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0UnLCAgICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2RkJywgICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzTWluUmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2RkZCcsICAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1Nob3J0UmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2RkZGQnLCAgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2RkJywgJ2RkZCcsICdkZGRkJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB2YXIgd2Vla2RheSA9IGNvbmZpZy5fbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XG4gICAgICAgIC8vIGlmIHdlIGRpZG4ndCBnZXQgYSB3ZWVrZGF5IG5hbWUsIG1hcmsgdGhlIGRhdGUgYXMgaW52YWxpZFxuICAgICAgICBpZiAod2Vla2RheSAhPSBudWxsKSB7XG4gICAgICAgICAgICB3ZWVrLmQgPSB3ZWVrZGF5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZFdlZWtkYXkgPSBpbnB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydkJywgJ2UnLCAnRSddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbl0gPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICBmdW5jdGlvbiBwYXJzZVdlZWtkYXkoaW5wdXQsIGxvY2FsZSkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc05hTihpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChpbnB1dCwgMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5wdXQgPSBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCk7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUlzb1dlZWtkYXkoaW5wdXQsIGxvY2FsZSkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KSAlIDcgfHwgNztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNOYU4oaW5wdXQpID8gbnVsbCA6IGlucHV0O1xuICAgIH1cblxuICAgIC8vIExPQ0FMRVNcblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXMgPSAnU3VuZGF5X01vbmRheV9UdWVzZGF5X1dlZG5lc2RheV9UaHVyc2RheV9GcmlkYXlfU2F0dXJkYXknLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXMgKG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX3dlZWtkYXlzKSA/IHRoaXMuX3dlZWtkYXlzIDpcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1snc3RhbmRhbG9uZSddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX3dlZWtkYXlzKSA/IHRoaXMuX3dlZWtkYXlzW20uZGF5KCldIDpcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzW3RoaXMuX3dlZWtkYXlzLmlzRm9ybWF0LnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLmRheSgpXTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQgPSAnU3VuX01vbl9UdWVfV2VkX1RodV9GcmlfU2F0Jy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzU2hvcnQgKG0pIHtcbiAgICAgICAgcmV0dXJuIChtKSA/IHRoaXMuX3dlZWtkYXlzU2hvcnRbbS5kYXkoKV0gOiB0aGlzLl93ZWVrZGF5c1Nob3J0O1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4gPSAnU3VfTW9fVHVfV2VfVGhfRnJfU2EnLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNNaW4gKG0pIHtcbiAgICAgICAgcmV0dXJuIChtKSA/IHRoaXMuX3dlZWtkYXlzTWluW20uZGF5KCldIDogdGhpcy5fd2Vla2RheXNNaW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlU3RyaWN0UGFyc2UkMSh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksIGlpLCBtb20sIGxsYyA9IHdlZWtkYXlOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlID0gW107XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyArK2kpIHtcbiAgICAgICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNNaW4obW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5cyhtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09ICdkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdkZGRkJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09ICdkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNQYXJzZSAod2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVTdHJpY3RQYXJzZSQxLmNhbGwodGhpcywgd2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG5cbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgIXRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMud2Vla2RheXMobW9tLCAnJykucmVwbGFjZSgnLicsICdcXFxcLj8nKSArICckJywgJ2knKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMud2Vla2RheXNNaW4obW9tLCAnJykucmVwbGFjZSgnLicsICdcXFxcLj8nKSArICckJywgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHJlZ2V4ID0gJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykgKyAnfF4nICsgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGRkZCcgJiYgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ2RkZCcgJiYgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZCcgJiYgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldERheU9mV2VlayAoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXkgPSB0aGlzLl9pc1VUQyA/IHRoaXMuX2QuZ2V0VVRDRGF5KCkgOiB0aGlzLl9kLmdldERheSgpO1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaW5wdXQgPSBwYXJzZVdlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChpbnB1dCAtIGRheSwgJ2QnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkYXk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRMb2NhbGVEYXlPZldlZWsgKGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2Vla2RheSA9ICh0aGlzLmRheSgpICsgNyAtIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdykgJSA3O1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWtkYXkgOiB0aGlzLmFkZChpbnB1dCAtIHdlZWtkYXksICdkJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPRGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBiZWhhdmVzIHRoZSBzYW1lIGFzIG1vbWVudCNkYXkgZXhjZXB0XG4gICAgICAgIC8vIGFzIGEgZ2V0dGVyLCByZXR1cm5zIDcgaW5zdGVhZCBvZiAwICgxLTcgcmFuZ2UgaW5zdGVhZCBvZiAwLTYpXG4gICAgICAgIC8vIGFzIGEgc2V0dGVyLCBzdW5kYXkgc2hvdWxkIGJlbG9uZyB0byB0aGUgcHJldmlvdXMgd2Vlay5cblxuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHdlZWtkYXkgPSBwYXJzZUlzb1dlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRheSh0aGlzLmRheSgpICUgNyA/IHdlZWtkYXkgOiB3ZWVrZGF5IC0gNyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXkoKSB8fCA3O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRXZWVrZGF5c1JlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIHdlZWtkYXlzUmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1JlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCA6IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFdlZWtkYXlzU2hvcnRSZWdleCA9IG1hdGNoV29yZDtcbiAgICBmdW5jdGlvbiB3ZWVrZGF5c1Nob3J0UmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNTaG9ydFJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXggPSBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRXZWVrZGF5c01pblJlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIHdlZWtkYXlzTWluUmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c01pblJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c01pblJlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCA6IHRoaXMuX3dlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVXZWVrZGF5c1BhcnNlICgpIHtcbiAgICAgICAgZnVuY3Rpb24gY21wTGVuUmV2KGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1pblBpZWNlcyA9IFtdLCBzaG9ydFBpZWNlcyA9IFtdLCBsb25nUGllY2VzID0gW10sIG1peGVkUGllY2VzID0gW10sXG4gICAgICAgICAgICBpLCBtb20sIG1pbnAsIHNob3J0cCwgbG9uZ3A7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgbWlucCA9IHRoaXMud2Vla2RheXNNaW4obW9tLCAnJyk7XG4gICAgICAgICAgICBzaG9ydHAgPSB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgICAgICBsb25ncCA9IHRoaXMud2Vla2RheXMobW9tLCAnJyk7XG4gICAgICAgICAgICBtaW5QaWVjZXMucHVzaChtaW5wKTtcbiAgICAgICAgICAgIHNob3J0UGllY2VzLnB1c2goc2hvcnRwKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKG1pbnApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChzaG9ydHApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSB3ZWVrZGF5IChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XG4gICAgICAgIC8vIHdpbGwgbWF0Y2ggdGhlIGxvbmdlciBwaWVjZS5cbiAgICAgICAgbWluUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBsb25nUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbWl4ZWRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBzaG9ydFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKHNob3J0UGllY2VzW2ldKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXNbaV0gPSByZWdleEVzY2FwZShsb25nUGllY2VzW2ldKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobWl4ZWRQaWVjZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fd2Vla2RheXNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5SZWdleCA9IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG5cbiAgICAgICAgdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBzaG9ydFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaW5QaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGZ1bmN0aW9uIGhGb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhvdXJzKCkgJSAxMiB8fCAxMjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBrRm9ybWF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3VycygpIHx8IDI0O1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKCdIJywgWydISCcsIDJdLCAwLCAnaG91cicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdoJywgWydoaCcsIDJdLCAwLCBoRm9ybWF0KTtcbiAgICBhZGRGb3JtYXRUb2tlbignaycsIFsna2snLCAyXSwgMCwga0Zvcm1hdCk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignaG1tJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyBoRm9ybWF0LmFwcGx5KHRoaXMpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyBoRm9ybWF0LmFwcGx5KHRoaXMpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcbiAgICAgICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdIbW0nLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnJyArIHRoaXMuaG91cnMoKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdIbW1zcycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGhpcy5ob3VycygpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcbiAgICAgICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIG1lcmlkaWVtICh0b2tlbiwgbG93ZXJjYXNlKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubWVyaWRpZW0odGhpcy5ob3VycygpLCB0aGlzLm1pbnV0ZXMoKSwgbG93ZXJjYXNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbWVyaWRpZW0oJ2EnLCB0cnVlKTtcbiAgICBtZXJpZGllbSgnQScsIGZhbHNlKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnaG91cicsICdoJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnaG91cicsIDEzKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGZ1bmN0aW9uIG1hdGNoTWVyaWRpZW0gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5fbWVyaWRpZW1QYXJzZTtcbiAgICB9XG5cbiAgICBhZGRSZWdleFRva2VuKCdhJywgIG1hdGNoTWVyaWRpZW0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0EnLCAgbWF0Y2hNZXJpZGllbSk7XG4gICAgYWRkUmVnZXhUb2tlbignSCcsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2gnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdrJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignSEgnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignaGgnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbigna2snLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbiAgICBhZGRSZWdleFRva2VuKCdobW0nLCBtYXRjaDN0bzQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2htbXNzJywgbWF0Y2g1dG82KTtcbiAgICBhZGRSZWdleFRva2VuKCdIbW0nLCBtYXRjaDN0bzQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0htbXNzJywgbWF0Y2g1dG82KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydIJywgJ0hIJ10sIEhPVVIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydrJywgJ2trJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIga0lucHV0ID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICBhcnJheVtIT1VSXSA9IGtJbnB1dCA9PT0gMjQgPyAwIDoga0lucHV0O1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oWydhJywgJ0EnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5faXNQbSA9IGNvbmZpZy5fbG9jYWxlLmlzUE0oaW5wdXQpO1xuICAgICAgICBjb25maWcuX21lcmlkaWVtID0gaW5wdXQ7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2gnLCAnaGgnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdobW0nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIHBvcyA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvcykpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvcykpO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdobW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zMSA9IGlucHV0Lmxlbmd0aCAtIDQ7XG4gICAgICAgIHZhciBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczEsIDIpKTtcbiAgICAgICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ0htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignSG1tc3MnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIHBvczEgPSBpbnB1dC5sZW5ndGggLSA0O1xuICAgICAgICB2YXIgcG9zMiA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvczEpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MxLCAyKSk7XG4gICAgICAgIGFycmF5W1NFQ09ORF0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMikpO1xuICAgIH0pO1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlSXNQTSAoaW5wdXQpIHtcbiAgICAgICAgLy8gSUU4IFF1aXJrcyBNb2RlICYgSUU3IFN0YW5kYXJkcyBNb2RlIGRvIG5vdCBhbGxvdyBhY2Nlc3Npbmcgc3RyaW5ncyBsaWtlIGFycmF5c1xuICAgICAgICAvLyBVc2luZyBjaGFyQXQgc2hvdWxkIGJlIG1vcmUgY29tcGF0aWJsZS5cbiAgICAgICAgcmV0dXJuICgoaW5wdXQgKyAnJykudG9Mb3dlckNhc2UoKS5jaGFyQXQoMCkgPT09ICdwJyk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlID0gL1thcF1cXC4/bT9cXC4/L2k7XG4gICAgZnVuY3Rpb24gbG9jYWxlTWVyaWRpZW0gKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XG4gICAgICAgIGlmIChob3VycyA+IDExKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdwbScgOiAnUE0nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAnYW0nIDogJ0FNJztcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgLy8gU2V0dGluZyB0aGUgaG91ciBzaG91bGQga2VlcCB0aGUgdGltZSwgYmVjYXVzZSB0aGUgdXNlciBleHBsaWNpdGx5XG4gICAgLy8gc3BlY2lmaWVkIHdoaWNoIGhvdXIgdGhleSB3YW50LiBTbyB0cnlpbmcgdG8gbWFpbnRhaW4gdGhlIHNhbWUgaG91ciAoaW5cbiAgICAvLyBhIG5ldyB0aW1lem9uZSkgbWFrZXMgc2Vuc2UuIEFkZGluZy9zdWJ0cmFjdGluZyBob3VycyBkb2VzIG5vdCBmb2xsb3dcbiAgICAvLyB0aGlzIHJ1bGUuXG4gICAgdmFyIGdldFNldEhvdXIgPSBtYWtlR2V0U2V0KCdIb3VycycsIHRydWUpO1xuXG4gICAgdmFyIGJhc2VDb25maWcgPSB7XG4gICAgICAgIGNhbGVuZGFyOiBkZWZhdWx0Q2FsZW5kYXIsXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0OiBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQsXG4gICAgICAgIGludmFsaWREYXRlOiBkZWZhdWx0SW52YWxpZERhdGUsXG4gICAgICAgIG9yZGluYWw6IGRlZmF1bHRPcmRpbmFsLFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSxcbiAgICAgICAgcmVsYXRpdmVUaW1lOiBkZWZhdWx0UmVsYXRpdmVUaW1lLFxuXG4gICAgICAgIG1vbnRoczogZGVmYXVsdExvY2FsZU1vbnRocyxcbiAgICAgICAgbW9udGhzU2hvcnQ6IGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCxcblxuICAgICAgICB3ZWVrOiBkZWZhdWx0TG9jYWxlV2VlayxcblxuICAgICAgICB3ZWVrZGF5czogZGVmYXVsdExvY2FsZVdlZWtkYXlzLFxuICAgICAgICB3ZWVrZGF5c01pbjogZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0OiBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCxcblxuICAgICAgICBtZXJpZGllbVBhcnNlOiBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZVxuICAgIH07XG5cbiAgICAvLyBpbnRlcm5hbCBzdG9yYWdlIGZvciBsb2NhbGUgY29uZmlnIGZpbGVzXG4gICAgdmFyIGxvY2FsZXMgPSB7fTtcbiAgICB2YXIgbG9jYWxlRmFtaWxpZXMgPSB7fTtcbiAgICB2YXIgZ2xvYmFsTG9jYWxlO1xuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplTG9jYWxlKGtleSkge1xuICAgICAgICByZXR1cm4ga2V5ID8ga2V5LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnXycsICctJykgOiBrZXk7XG4gICAgfVxuXG4gICAgLy8gcGljayB0aGUgbG9jYWxlIGZyb20gdGhlIGFycmF5XG4gICAgLy8gdHJ5IFsnZW4tYXUnLCAnZW4tZ2InXSBhcyAnZW4tYXUnLCAnZW4tZ2InLCAnZW4nLCBhcyBpbiBtb3ZlIHRocm91Z2ggdGhlIGxpc3QgdHJ5aW5nIGVhY2hcbiAgICAvLyBzdWJzdHJpbmcgZnJvbSBtb3N0IHNwZWNpZmljIHRvIGxlYXN0LCBidXQgbW92ZSB0byB0aGUgbmV4dCBhcnJheSBpdGVtIGlmIGl0J3MgYSBtb3JlIHNwZWNpZmljIHZhcmlhbnQgdGhhbiB0aGUgY3VycmVudCByb290XG4gICAgZnVuY3Rpb24gY2hvb3NlTG9jYWxlKG5hbWVzKSB7XG4gICAgICAgIHZhciBpID0gMCwgaiwgbmV4dCwgbG9jYWxlLCBzcGxpdDtcblxuICAgICAgICB3aGlsZSAoaSA8IG5hbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgc3BsaXQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaV0pLnNwbGl0KCctJyk7XG4gICAgICAgICAgICBqID0gc3BsaXQubGVuZ3RoO1xuICAgICAgICAgICAgbmV4dCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpICsgMV0pO1xuICAgICAgICAgICAgbmV4dCA9IG5leHQgPyBuZXh0LnNwbGl0KCctJykgOiBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKGogPiAwKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShzcGxpdC5zbGljZSgwLCBqKS5qb2luKCctJykpO1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgJiYgbmV4dC5sZW5ndGggPj0gaiAmJiBjb21wYXJlQXJyYXlzKHNwbGl0LCBuZXh0LCB0cnVlKSA+PSBqIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvL3RoZSBuZXh0IGFycmF5IGl0ZW0gaXMgYmV0dGVyIHRoYW4gYSBzaGFsbG93ZXIgc3Vic3RyaW5nIG9mIHRoaXMgb25lXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkTG9jYWxlKG5hbWUpIHtcbiAgICAgICAgdmFyIG9sZExvY2FsZSA9IG51bGw7XG4gICAgICAgIC8vIFRPRE86IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIHJlZ2lzdGVyIGFuZCBsb2FkIGFsbCB0aGUgbG9jYWxlcyBpbiBOb2RlXG4gICAgICAgIGlmICghbG9jYWxlc1tuYW1lXSAmJiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICAgICAgbW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9sZExvY2FsZSA9IGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICAgICAgICAgICAgICB2YXIgYWxpYXNlZFJlcXVpcmUgPSByZXF1aXJlO1xuICAgICAgICAgICAgICAgICEoZnVuY3Rpb24gd2VicGFja01pc3NpbmdNb2R1bGUoKSB7IHZhciBlID0gbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlIFxcXCIuL2xvY2FsZVxcXCJcIik7IGUuY29kZSA9ICdNT0RVTEVfTk9UX0ZPVU5EJzsgdGhyb3cgZTsgfSgpKTtcbiAgICAgICAgICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUob2xkTG9jYWxlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGxvYWQgbG9jYWxlIGFuZCB0aGVuIHNldCB0aGUgZ2xvYmFsIGxvY2FsZS4gIElmXG4gICAgLy8gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudCBnbG9iYWxcbiAgICAvLyBsb2NhbGUga2V5LlxuICAgIGZ1bmN0aW9uIGdldFNldEdsb2JhbExvY2FsZSAoa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGdldExvY2FsZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRlZmluZUxvY2FsZShrZXksIHZhbHVlcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gbW9tZW50LmR1cmF0aW9uLl9sb2NhbGUgPSBtb21lbnQuX2xvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgZ2xvYmFsTG9jYWxlID0gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIGNvbnNvbGUgIT09ICAndW5kZWZpbmVkJykgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vd2FybiB1c2VyIGlmIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGJ1dCB0aGUgbG9jYWxlIGNvdWxkIG5vdCBiZSBzZXRcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdMb2NhbGUgJyArIGtleSArICAnIG5vdCBmb3VuZC4gRGlkIHlvdSBmb3JnZXQgdG8gbG9hZCBpdD8nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlLl9hYmJyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmluZUxvY2FsZSAobmFtZSwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbGUsIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XG4gICAgICAgICAgICBjb25maWcuYWJiciA9IG5hbWU7XG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKCdkZWZpbmVMb2NhbGVPdmVycmlkZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlIG1vbWVudC51cGRhdGVMb2NhbGUobG9jYWxlTmFtZSwgY29uZmlnKSB0byBjaGFuZ2UgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYW4gZXhpc3RpbmcgbG9jYWxlLiBtb21lbnQuZGVmaW5lTG9jYWxlKGxvY2FsZU5hbWUsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbmZpZykgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgY3JlYXRpbmcgYSBuZXcgbG9jYWxlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1NlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2RlZmluZS1sb2NhbGUvIGZvciBtb3JlIGluZm8uJyk7XG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tuYW1lXS5fY29uZmlnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb25maWcucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlc1tjb25maWcucGFyZW50TG9jYWxlXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0uX2NvbmZpZztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGNvbmZpZy5wYXJlbnRMb2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZS5fY29uZmlnO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IG5ldyBMb2NhbGUobWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKSk7XG5cbiAgICAgICAgICAgIGlmIChsb2NhbGVGYW1pbGllc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW25hbWVdLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lTG9jYWxlKHgubmFtZSwgeC5jb25maWcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGxvY2FsZSBBRlRFUiBhbGwgY2hpbGQgbG9jYWxlcyBoYXZlIGJlZW5cbiAgICAgICAgICAgIC8vIGNyZWF0ZWQsIHNvIHdlIHdvbid0IGVuZCB1cCB3aXRoIHRoZSBjaGlsZCBsb2NhbGUgc2V0LlxuICAgICAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuXG5cbiAgICAgICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdXNlZnVsIGZvciB0ZXN0aW5nXG4gICAgICAgICAgICBkZWxldGUgbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlTG9jYWxlKG5hbWUsIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbGUsIHRtcExvY2FsZSwgcGFyZW50Q29uZmlnID0gYmFzZUNvbmZpZztcbiAgICAgICAgICAgIC8vIE1FUkdFXG4gICAgICAgICAgICB0bXBMb2NhbGUgPSBsb2FkTG9jYWxlKG5hbWUpO1xuICAgICAgICAgICAgaWYgKHRtcExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gdG1wTG9jYWxlLl9jb25maWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25maWcgPSBtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjb25maWcpO1xuICAgICAgICAgICAgbG9jYWxlID0gbmV3IExvY2FsZShjb25maWcpO1xuICAgICAgICAgICAgbG9jYWxlLnBhcmVudExvY2FsZSA9IGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbG9jYWxlO1xuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBhc3MgbnVsbCBmb3IgY29uZmlnIHRvIHVudXBkYXRlLCB1c2VmdWwgZm9yIHRlc3RzXG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm5zIGxvY2FsZSBkYXRhXG4gICAgZnVuY3Rpb24gZ2V0TG9jYWxlIChrZXkpIHtcbiAgICAgICAgdmFyIGxvY2FsZTtcblxuICAgICAgICBpZiAoa2V5ICYmIGtleS5fbG9jYWxlICYmIGtleS5fbG9jYWxlLl9hYmJyKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXkuX2xvY2FsZS5fYWJicjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0FycmF5KGtleSkpIHtcbiAgICAgICAgICAgIC8vc2hvcnQtY2lyY3VpdCBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5ID0gW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hvb3NlTG9jYWxlKGtleSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdExvY2FsZXMoKSB7XG4gICAgICAgIHJldHVybiBrZXlzKGxvY2FsZXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrT3ZlcmZsb3cgKG0pIHtcbiAgICAgICAgdmFyIG92ZXJmbG93O1xuICAgICAgICB2YXIgYSA9IG0uX2E7XG5cbiAgICAgICAgaWYgKGEgJiYgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID09PSAtMikge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPVxuICAgICAgICAgICAgICAgIGFbTU9OVEhdICAgICAgIDwgMCB8fCBhW01PTlRIXSAgICAgICA+IDExICA/IE1PTlRIIDpcbiAgICAgICAgICAgICAgICBhW0RBVEVdICAgICAgICA8IDEgfHwgYVtEQVRFXSAgICAgICAgPiBkYXlzSW5Nb250aChhW1lFQVJdLCBhW01PTlRIXSkgPyBEQVRFIDpcbiAgICAgICAgICAgICAgICBhW0hPVVJdICAgICAgICA8IDAgfHwgYVtIT1VSXSAgICAgICAgPiAyNCB8fCAoYVtIT1VSXSA9PT0gMjQgJiYgKGFbTUlOVVRFXSAhPT0gMCB8fCBhW1NFQ09ORF0gIT09IDAgfHwgYVtNSUxMSVNFQ09ORF0gIT09IDApKSA/IEhPVVIgOlxuICAgICAgICAgICAgICAgIGFbTUlOVVRFXSAgICAgIDwgMCB8fCBhW01JTlVURV0gICAgICA+IDU5ICA/IE1JTlVURSA6XG4gICAgICAgICAgICAgICAgYVtTRUNPTkRdICAgICAgPCAwIHx8IGFbU0VDT05EXSAgICAgID4gNTkgID8gU0VDT05EIDpcbiAgICAgICAgICAgICAgICBhW01JTExJU0VDT05EXSA8IDAgfHwgYVtNSUxMSVNFQ09ORF0gPiA5OTkgPyBNSUxMSVNFQ09ORCA6XG4gICAgICAgICAgICAgICAgLTE7XG5cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93RGF5T2ZZZWFyICYmIChvdmVyZmxvdyA8IFlFQVIgfHwgb3ZlcmZsb3cgPiBEQVRFKSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gREFURTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla3MgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrZGF5ICYmIG92ZXJmbG93ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gV0VFS0RBWTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID0gb3ZlcmZsb3c7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICAvLyBQaWNrIHRoZSBmaXJzdCBkZWZpbmVkIG9mIHR3byBvciB0aHJlZSBhcmd1bWVudHMuXG4gICAgZnVuY3Rpb24gZGVmYXVsdHMoYSwgYiwgYykge1xuICAgICAgICBpZiAoYSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYiAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZykge1xuICAgICAgICAvLyBob29rcyBpcyBhY3R1YWxseSB0aGUgZXhwb3J0ZWQgbW9tZW50IG9iamVjdFxuICAgICAgICB2YXIgbm93VmFsdWUgPSBuZXcgRGF0ZShob29rcy5ub3coKSk7XG4gICAgICAgIGlmIChjb25maWcuX3VzZVVUQykge1xuICAgICAgICAgICAgcmV0dXJuIFtub3dWYWx1ZS5nZXRVVENGdWxsWWVhcigpLCBub3dWYWx1ZS5nZXRVVENNb250aCgpLCBub3dWYWx1ZS5nZXRVVENEYXRlKCldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbm93VmFsdWUuZ2V0RnVsbFllYXIoKSwgbm93VmFsdWUuZ2V0TW9udGgoKSwgbm93VmFsdWUuZ2V0RGF0ZSgpXTtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IGFuIGFycmF5IHRvIGEgZGF0ZS5cbiAgICAvLyB0aGUgYXJyYXkgc2hvdWxkIG1pcnJvciB0aGUgcGFyYW1ldGVycyBiZWxvd1xuICAgIC8vIG5vdGU6IGFsbCB2YWx1ZXMgcGFzdCB0aGUgeWVhciBhcmUgb3B0aW9uYWwgYW5kIHdpbGwgZGVmYXVsdCB0byB0aGUgbG93ZXN0IHBvc3NpYmxlIHZhbHVlLlxuICAgIC8vIFt5ZWFyLCBtb250aCwgZGF5ICwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kXVxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21BcnJheSAoY29uZmlnKSB7XG4gICAgICAgIHZhciBpLCBkYXRlLCBpbnB1dCA9IFtdLCBjdXJyZW50RGF0ZSwgZXhwZWN0ZWRXZWVrZGF5LCB5ZWFyVG9Vc2U7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudERhdGUgPSBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZyk7XG5cbiAgICAgICAgLy9jb21wdXRlIGRheSBvZiB0aGUgeWVhciBmcm9tIHdlZWtzIGFuZCB3ZWVrZGF5c1xuICAgICAgICBpZiAoY29uZmlnLl93ICYmIGNvbmZpZy5fYVtEQVRFXSA9PSBudWxsICYmIGNvbmZpZy5fYVtNT05USF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2lmIHRoZSBkYXkgb2YgdGhlIHllYXIgaXMgc2V0LCBmaWd1cmUgb3V0IHdoYXQgaXQgaXNcbiAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHllYXJUb1VzZSA9IGRlZmF1bHRzKGNvbmZpZy5fYVtZRUFSXSwgY3VycmVudERhdGVbWUVBUl0pO1xuXG4gICAgICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXJUb1VzZSkgfHwgY29uZmlnLl9kYXlPZlllYXIgPT09IDApIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dEYXlPZlllYXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZSh5ZWFyVG9Vc2UsIDAsIGNvbmZpZy5fZGF5T2ZZZWFyKTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNT05USF0gPSBkYXRlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICBjb25maWcuX2FbREFURV0gPSBkYXRlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCBkYXRlLlxuICAgICAgICAvLyAqIGlmIG5vIHllYXIsIG1vbnRoLCBkYXkgb2YgbW9udGggYXJlIGdpdmVuLCBkZWZhdWx0IHRvIHRvZGF5XG4gICAgICAgIC8vICogaWYgZGF5IG9mIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG1vbnRoIGFuZCB5ZWFyXG4gICAgICAgIC8vICogaWYgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgb25seSB5ZWFyXG4gICAgICAgIC8vICogaWYgeWVhciBpcyBnaXZlbiwgZG9uJ3QgZGVmYXVsdCBhbnl0aGluZ1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMyAmJiBjb25maWcuX2FbaV0gPT0gbnVsbDsgKytpKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IGN1cnJlbnREYXRlW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gWmVybyBvdXQgd2hhdGV2ZXIgd2FzIG5vdCBkZWZhdWx0ZWQsIGluY2x1ZGluZyB0aW1lXG4gICAgICAgIGZvciAoOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IChjb25maWcuX2FbaV0gPT0gbnVsbCkgPyAoaSA9PT0gMiA/IDEgOiAwKSA6IGNvbmZpZy5fYVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGZvciAyNDowMDowMC4wMDBcbiAgICAgICAgaWYgKGNvbmZpZy5fYVtIT1VSXSA9PT0gMjQgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbTUlOVVRFXSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtTRUNPTkRdID09PSAwICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW01JTExJU0VDT05EXSA9PT0gMCkge1xuICAgICAgICAgICAgY29uZmlnLl9uZXh0RGF5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWcuX2QgPSAoY29uZmlnLl91c2VVVEMgPyBjcmVhdGVVVENEYXRlIDogY3JlYXRlRGF0ZSkuYXBwbHkobnVsbCwgaW5wdXQpO1xuICAgICAgICBleHBlY3RlZFdlZWtkYXkgPSBjb25maWcuX3VzZVVUQyA/IGNvbmZpZy5fZC5nZXRVVENEYXkoKSA6IGNvbmZpZy5fZC5nZXREYXkoKTtcblxuICAgICAgICAvLyBBcHBseSB0aW1lem9uZSBvZmZzZXQgZnJvbSBpbnB1dC4gVGhlIGFjdHVhbCB1dGNPZmZzZXQgY2FuIGJlIGNoYW5nZWRcbiAgICAgICAgLy8gd2l0aCBwYXJzZVpvbmUuXG4gICAgICAgIGlmIChjb25maWcuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpIC0gY29uZmlnLl90em0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fbmV4dERheSkge1xuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMjQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBmb3IgbWlzbWF0Y2hpbmcgZGF5IG9mIHdlZWtcbiAgICAgICAgaWYgKGNvbmZpZy5fdyAmJiB0eXBlb2YgY29uZmlnLl93LmQgIT09ICd1bmRlZmluZWQnICYmIGNvbmZpZy5fdy5kICE9PSBleHBlY3RlZFdlZWtkYXkpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLndlZWtkYXlNaXNtYXRjaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKSB7XG4gICAgICAgIHZhciB3LCB3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3ksIHRlbXAsIHdlZWtkYXlPdmVyZmxvdztcblxuICAgICAgICB3ID0gY29uZmlnLl93O1xuICAgICAgICBpZiAody5HRyAhPSBudWxsIHx8IHcuVyAhPSBudWxsIHx8IHcuRSAhPSBudWxsKSB7XG4gICAgICAgICAgICBkb3cgPSAxO1xuICAgICAgICAgICAgZG95ID0gNDtcblxuICAgICAgICAgICAgLy8gVE9ETzogV2UgbmVlZCB0byB0YWtlIHRoZSBjdXJyZW50IGlzb1dlZWtZZWFyLCBidXQgdGhhdCBkZXBlbmRzIG9uXG4gICAgICAgICAgICAvLyBob3cgd2UgaW50ZXJwcmV0IG5vdyAobG9jYWwsIHV0YywgZml4ZWQgb2Zmc2V0KS4gU28gY3JlYXRlXG4gICAgICAgICAgICAvLyBhIG5vdyB2ZXJzaW9uIG9mIGN1cnJlbnQgY29uZmlnICh0YWtlIGxvY2FsL3V0Yy9vZmZzZXQgZmxhZ3MsIGFuZFxuICAgICAgICAgICAgLy8gY3JlYXRlIG5vdykuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuR0csIGNvbmZpZy5fYVtZRUFSXSwgd2Vla09mWWVhcihjcmVhdGVMb2NhbCgpLCAxLCA0KS55ZWFyKTtcbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LlcsIDEpO1xuICAgICAgICAgICAgd2Vla2RheSA9IGRlZmF1bHRzKHcuRSwgMSk7XG4gICAgICAgICAgICBpZiAod2Vla2RheSA8IDEgfHwgd2Vla2RheSA+IDcpIHtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG93ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG93O1xuICAgICAgICAgICAgZG95ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG95O1xuXG4gICAgICAgICAgICB2YXIgY3VyV2VlayA9IHdlZWtPZlllYXIoY3JlYXRlTG9jYWwoKSwgZG93LCBkb3kpO1xuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuZ2csIGNvbmZpZy5fYVtZRUFSXSwgY3VyV2Vlay55ZWFyKTtcblxuICAgICAgICAgICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IHdlZWsuXG4gICAgICAgICAgICB3ZWVrID0gZGVmYXVsdHMody53LCBjdXJXZWVrLndlZWspO1xuXG4gICAgICAgICAgICBpZiAody5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZWVrZGF5IC0tIGxvdyBkYXkgbnVtYmVycyBhcmUgY29uc2lkZXJlZCBuZXh0IHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5kO1xuICAgICAgICAgICAgICAgIGlmICh3ZWVrZGF5IDwgMCB8fCB3ZWVrZGF5ID4gNikge1xuICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAody5lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBsb2NhbCB3ZWVrZGF5IC0tIGNvdW50aW5nIHN0YXJ0cyBmcm9tIGJlZ2luaW5nIG9mIHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5lICsgZG93O1xuICAgICAgICAgICAgICAgIGlmICh3LmUgPCAwIHx8IHcuZSA+IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gYmVnaW5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSBkb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdlZWsgPCAxIHx8IHdlZWsgPiB3ZWVrc0luWWVhcih3ZWVrWWVhciwgZG93LCBkb3kpKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dXZWVrcyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAod2Vla2RheU92ZXJmbG93ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd1dlZWtkYXkgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGVtcCA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xuICAgICAgICAgICAgY29uZmlnLl9hW1lFQVJdID0gdGVtcC55ZWFyO1xuICAgICAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0ZW1wLmRheU9mWWVhcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlzbyA4NjAxIHJlZ2V4XG4gICAgLy8gMDAwMC0wMC0wMCAwMDAwLVcwMCBvciAwMDAwLVcwMC0wICsgVCArIDAwIG9yIDAwOjAwIG9yIDAwOjAwOjAwIG9yIDAwOjAwOjAwLjAwMCArICswMDowMCBvciArMDAwMCBvciArMDApXG4gICAgdmFyIGV4dGVuZGVkSXNvUmVnZXggPSAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pLSg/OlxcZFxcZC1cXGRcXGR8V1xcZFxcZC1cXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkKSkoPzooVHwgKShcXGRcXGQoPzo6XFxkXFxkKD86OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbXFwrXFwtXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/JC87XG4gICAgdmFyIGJhc2ljSXNvUmVnZXggPSAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pKD86XFxkXFxkXFxkXFxkfFdcXGRcXGRcXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkKSkoPzooVHwgKShcXGRcXGQoPzpcXGRcXGQoPzpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoW1xcK1xcLV1cXGRcXGQoPzo6P1xcZFxcZCk/fFxccypaKT8pPyQvO1xuXG4gICAgdmFyIHR6UmVnZXggPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy87XG5cbiAgICB2YXIgaXNvRGF0ZXMgPSBbXG4gICAgICAgIFsnWVlZWVlZLU1NLUREJywgL1srLV1cXGR7Nn0tXFxkXFxkLVxcZFxcZC9dLFxuICAgICAgICBbJ1lZWVktTU0tREQnLCAvXFxkezR9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICAgICAgWydHR0dHLVtXXVdXLUUnLCAvXFxkezR9LVdcXGRcXGQtXFxkL10sXG4gICAgICAgIFsnR0dHRy1bV11XVycsIC9cXGR7NH0tV1xcZFxcZC8sIGZhbHNlXSxcbiAgICAgICAgWydZWVlZLURERCcsIC9cXGR7NH0tXFxkezN9L10sXG4gICAgICAgIFsnWVlZWS1NTScsIC9cXGR7NH0tXFxkXFxkLywgZmFsc2VdLFxuICAgICAgICBbJ1lZWVlZWU1NREQnLCAvWystXVxcZHsxMH0vXSxcbiAgICAgICAgWydZWVlZTU1ERCcsIC9cXGR7OH0vXSxcbiAgICAgICAgLy8gWVlZWU1NIGlzIE5PVCBhbGxvd2VkIGJ5IHRoZSBzdGFuZGFyZFxuICAgICAgICBbJ0dHR0dbV11XV0UnLCAvXFxkezR9V1xcZHszfS9dLFxuICAgICAgICBbJ0dHR0dbV11XVycsIC9cXGR7NH1XXFxkezJ9LywgZmFsc2VdLFxuICAgICAgICBbJ1lZWVlEREQnLCAvXFxkezd9L11cbiAgICBdO1xuXG4gICAgLy8gaXNvIHRpbWUgZm9ybWF0cyBhbmQgcmVnZXhlc1xuICAgIHZhciBpc29UaW1lcyA9IFtcbiAgICAgICAgWydISDptbTpzcy5TU1NTJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkXFwuXFxkKy9dLFxuICAgICAgICBbJ0hIOm1tOnNzLFNTU1MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQsXFxkKy9dLFxuICAgICAgICBbJ0hIOm1tOnNzJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkL10sXG4gICAgICAgIFsnSEg6bW0nLCAvXFxkXFxkOlxcZFxcZC9dLFxuICAgICAgICBbJ0hIbW1zcy5TU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZFxcLlxcZCsvXSxcbiAgICAgICAgWydISG1tc3MsU1NTUycsIC9cXGRcXGRcXGRcXGRcXGRcXGQsXFxkKy9dLFxuICAgICAgICBbJ0hIbW1zcycsIC9cXGRcXGRcXGRcXGRcXGRcXGQvXSxcbiAgICAgICAgWydISG1tJywgL1xcZFxcZFxcZFxcZC9dLFxuICAgICAgICBbJ0hIJywgL1xcZFxcZC9dXG4gICAgXTtcblxuICAgIHZhciBhc3BOZXRKc29uUmVnZXggPSAvXlxcLz9EYXRlXFwoKFxcLT9cXGQrKS9pO1xuXG4gICAgLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXRcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tSVNPKGNvbmZpZykge1xuICAgICAgICB2YXIgaSwgbCxcbiAgICAgICAgICAgIHN0cmluZyA9IGNvbmZpZy5faSxcbiAgICAgICAgICAgIG1hdGNoID0gZXh0ZW5kZWRJc29SZWdleC5leGVjKHN0cmluZykgfHwgYmFzaWNJc29SZWdleC5leGVjKHN0cmluZyksXG4gICAgICAgICAgICBhbGxvd1RpbWUsIGRhdGVGb3JtYXQsIHRpbWVGb3JtYXQsIHR6Rm9ybWF0O1xuXG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaXNvID0gdHJ1ZTtcblxuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb0RhdGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpc29EYXRlc1tpXVsxXS5leGVjKG1hdGNoWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRlRm9ybWF0ID0gaXNvRGF0ZXNbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgIGFsbG93VGltZSA9IGlzb0RhdGVzW2ldWzJdICE9PSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGVGb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaFszXSkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29UaW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzb1RpbWVzW2ldWzFdLmV4ZWMobWF0Y2hbM10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaFsyXSBzaG91bGQgYmUgJ1QnIG9yIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lRm9ybWF0ID0gKG1hdGNoWzJdIHx8ICcgJykgKyBpc29UaW1lc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aW1lRm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFsbG93VGltZSAmJiB0aW1lRm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hbNF0pIHtcbiAgICAgICAgICAgICAgICBpZiAodHpSZWdleC5leGVjKG1hdGNoWzRdKSkge1xuICAgICAgICAgICAgICAgICAgICB0ekZvcm1hdCA9ICdaJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbmZpZy5fZiA9IGRhdGVGb3JtYXQgKyAodGltZUZvcm1hdCB8fCAnJykgKyAodHpGb3JtYXQgfHwgJycpO1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSRkMgMjgyMiByZWdleDogRm9yIGRldGFpbHMgc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyODIyI3NlY3Rpb24tMy4zXG4gICAgdmFyIHJmYzI4MjIgPSAvXig/OihNb258VHVlfFdlZHxUaHV8RnJpfFNhdHxTdW4pLD9cXHMpPyhcXGR7MSwyfSlcXHMoSmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpXFxzKFxcZHsyLDR9KVxccyhcXGRcXGQpOihcXGRcXGQpKD86OihcXGRcXGQpKT9cXHMoPzooVVR8R01UfFtFQ01QXVtTRF1UKXwoW1p6XSl8KFsrLV1cXGR7NH0pKSQvO1xuXG4gICAgZnVuY3Rpb24gZXh0cmFjdEZyb21SRkMyODIyU3RyaW5ncyh5ZWFyU3RyLCBtb250aFN0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0cikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW1xuICAgICAgICAgICAgdW50cnVuY2F0ZVllYXIoeWVhclN0ciksXG4gICAgICAgICAgICBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQuaW5kZXhPZihtb250aFN0ciksXG4gICAgICAgICAgICBwYXJzZUludChkYXlTdHIsIDEwKSxcbiAgICAgICAgICAgIHBhcnNlSW50KGhvdXJTdHIsIDEwKSxcbiAgICAgICAgICAgIHBhcnNlSW50KG1pbnV0ZVN0ciwgMTApXG4gICAgICAgIF07XG5cbiAgICAgICAgaWYgKHNlY29uZFN0cikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VJbnQoc2Vjb25kU3RyLCAxMCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bnRydW5jYXRlWWVhcih5ZWFyU3RyKSB7XG4gICAgICAgIHZhciB5ZWFyID0gcGFyc2VJbnQoeWVhclN0ciwgMTApO1xuICAgICAgICBpZiAoeWVhciA8PSA0OSkge1xuICAgICAgICAgICAgcmV0dXJuIDIwMDAgKyB5ZWFyO1xuICAgICAgICB9IGVsc2UgaWYgKHllYXIgPD0gOTk5KSB7XG4gICAgICAgICAgICByZXR1cm4gMTkwMCArIHllYXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHllYXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlcHJvY2Vzc1JGQzI4MjIocykge1xuICAgICAgICAvLyBSZW1vdmUgY29tbWVudHMgYW5kIGZvbGRpbmcgd2hpdGVzcGFjZSBhbmQgcmVwbGFjZSBtdWx0aXBsZS1zcGFjZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuICAgICAgICByZXR1cm4gcy5yZXBsYWNlKC9cXChbXildKlxcKXxbXFxuXFx0XS9nLCAnICcpLnJlcGxhY2UoLyhcXHNcXHMrKS9nLCAnICcpLnJlcGxhY2UoL15cXHNcXHMqLywgJycpLnJlcGxhY2UoL1xcc1xccyokLywgJycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrV2Vla2RheSh3ZWVrZGF5U3RyLCBwYXJzZWRJbnB1dCwgY29uZmlnKSB7XG4gICAgICAgIGlmICh3ZWVrZGF5U3RyKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBSZXBsYWNlIHRoZSB2YW5pbGxhIEpTIERhdGUgb2JqZWN0IHdpdGggYW4gaW5kZXBlbnRlbnQgZGF5LW9mLXdlZWsgY2hlY2suXG4gICAgICAgICAgICB2YXIgd2Vla2RheVByb3ZpZGVkID0gZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQuaW5kZXhPZih3ZWVrZGF5U3RyKSxcbiAgICAgICAgICAgICAgICB3ZWVrZGF5QWN0dWFsID0gbmV3IERhdGUocGFyc2VkSW5wdXRbMF0sIHBhcnNlZElucHV0WzFdLCBwYXJzZWRJbnB1dFsyXSkuZ2V0RGF5KCk7XG4gICAgICAgICAgICBpZiAod2Vla2RheVByb3ZpZGVkICE9PSB3ZWVrZGF5QWN0dWFsKSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykud2Vla2RheU1pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIG9ic09mZnNldHMgPSB7XG4gICAgICAgIFVUOiAwLFxuICAgICAgICBHTVQ6IDAsXG4gICAgICAgIEVEVDogLTQgKiA2MCxcbiAgICAgICAgRVNUOiAtNSAqIDYwLFxuICAgICAgICBDRFQ6IC01ICogNjAsXG4gICAgICAgIENTVDogLTYgKiA2MCxcbiAgICAgICAgTURUOiAtNiAqIDYwLFxuICAgICAgICBNU1Q6IC03ICogNjAsXG4gICAgICAgIFBEVDogLTcgKiA2MCxcbiAgICAgICAgUFNUOiAtOCAqIDYwXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZU9mZnNldChvYnNPZmZzZXQsIG1pbGl0YXJ5T2Zmc2V0LCBudW1PZmZzZXQpIHtcbiAgICAgICAgaWYgKG9ic09mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIG9ic09mZnNldHNbb2JzT2Zmc2V0XTtcbiAgICAgICAgfSBlbHNlIGlmIChtaWxpdGFyeU9mZnNldCkge1xuICAgICAgICAgICAgLy8gdGhlIG9ubHkgYWxsb3dlZCBtaWxpdGFyeSB0eiBpcyBaXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBobSA9IHBhcnNlSW50KG51bU9mZnNldCwgMTApO1xuICAgICAgICAgICAgdmFyIG0gPSBobSAlIDEwMCwgaCA9IChobSAtIG0pIC8gMTAwO1xuICAgICAgICAgICAgcmV0dXJuIGggKiA2MCArIG07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkYXRlIGFuZCB0aW1lIGZyb20gcmVmIDI4MjIgZm9ybWF0XG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHJmYzI4MjIuZXhlYyhwcmVwcm9jZXNzUkZDMjgyMihjb25maWcuX2kpKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VkQXJyYXkgPSBleHRyYWN0RnJvbVJGQzI4MjJTdHJpbmdzKG1hdGNoWzRdLCBtYXRjaFszXSwgbWF0Y2hbMl0sIG1hdGNoWzVdLCBtYXRjaFs2XSwgbWF0Y2hbN10pO1xuICAgICAgICAgICAgaWYgKCFjaGVja1dlZWtkYXkobWF0Y2hbMV0sIHBhcnNlZEFycmF5LCBjb25maWcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25maWcuX2EgPSBwYXJzZWRBcnJheTtcbiAgICAgICAgICAgIGNvbmZpZy5fdHptID0gY2FsY3VsYXRlT2Zmc2V0KG1hdGNoWzhdLCBtYXRjaFs5XSwgbWF0Y2hbMTBdKTtcblxuICAgICAgICAgICAgY29uZmlnLl9kID0gY3JlYXRlVVRDRGF0ZS5hcHBseShudWxsLCBjb25maWcuX2EpO1xuICAgICAgICAgICAgY29uZmlnLl9kLnNldFVUQ01pbnV0ZXMoY29uZmlnLl9kLmdldFVUQ01pbnV0ZXMoKSAtIGNvbmZpZy5fdHptKTtcblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykucmZjMjgyMiA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgZnJvbSBpc28gZm9ybWF0IG9yIGZhbGxiYWNrXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZyhjb25maWcpIHtcbiAgICAgICAgdmFyIG1hdGNoZWQgPSBhc3BOZXRKc29uUmVnZXguZXhlYyhjb25maWcuX2kpO1xuXG4gICAgICAgIGlmIChtYXRjaGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgrbWF0Y2hlZFsxXSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XG4gICAgICAgIGlmIChjb25maWcuX2lzVmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBkZWxldGUgY29uZmlnLl9pc1ZhbGlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaW5hbCBhdHRlbXB0LCB1c2UgSW5wdXQgRmFsbGJhY2tcbiAgICAgICAgaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICB9XG5cbiAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ3ZhbHVlIHByb3ZpZGVkIGlzIG5vdCBpbiBhIHJlY29nbml6ZWQgUkZDMjgyMiBvciBJU08gZm9ybWF0LiBtb21lbnQgY29uc3RydWN0aW9uIGZhbGxzIGJhY2sgdG8ganMgRGF0ZSgpLCAnICtcbiAgICAgICAgJ3doaWNoIGlzIG5vdCByZWxpYWJsZSBhY3Jvc3MgYWxsIGJyb3dzZXJzIGFuZCB2ZXJzaW9ucy4gTm9uIFJGQzI4MjIvSVNPIGRhdGUgZm9ybWF0cyBhcmUgJyArXG4gICAgICAgICdkaXNjb3VyYWdlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGFuIHVwY29taW5nIG1ham9yIHJlbGVhc2UuIFBsZWFzZSByZWZlciB0byAnICtcbiAgICAgICAgJ2h0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvanMtZGF0ZS8gZm9yIG1vcmUgaW5mby4nLFxuICAgICAgICBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShjb25maWcuX2kgKyAoY29uZmlnLl91c2VVVEMgPyAnIFVUQycgOiAnJykpO1xuICAgICAgICB9XG4gICAgKTtcblxuICAgIC8vIGNvbnN0YW50IHRoYXQgcmVmZXJzIHRvIHRoZSBJU08gc3RhbmRhcmRcbiAgICBob29rcy5JU09fODYwMSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gY29uc3RhbnQgdGhhdCByZWZlcnMgdG8gdGhlIFJGQyAyODIyIGZvcm1cbiAgICBob29rcy5SRkNfMjgyMiA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgZm9ybWF0IHN0cmluZ1xuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyB0byBhbm90aGVyIHBhcnQgb2YgdGhlIGNyZWF0aW9uIGZsb3cgdG8gcHJldmVudCBjaXJjdWxhciBkZXBzXG4gICAgICAgIGlmIChjb25maWcuX2YgPT09IGhvb2tzLklTT184NjAxKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5fZiA9PT0gaG9va3MuUkZDXzI4MjIpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21SRkMyODIyKGNvbmZpZyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uZmlnLl9hID0gW107XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gdHJ1ZTtcblxuICAgICAgICAvLyBUaGlzIGFycmF5IGlzIHVzZWQgdG8gbWFrZSBhIERhdGUsIGVpdGhlciB3aXRoIGBuZXcgRGF0ZWAgb3IgYERhdGUuVVRDYFxuICAgICAgICB2YXIgc3RyaW5nID0gJycgKyBjb25maWcuX2ksXG4gICAgICAgICAgICBpLCBwYXJzZWRJbnB1dCwgdG9rZW5zLCB0b2tlbiwgc2tpcHBlZCxcbiAgICAgICAgICAgIHN0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG4gICAgICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoID0gMDtcblxuICAgICAgICB0b2tlbnMgPSBleHBhbmRGb3JtYXQoY29uZmlnLl9mLCBjb25maWcuX2xvY2FsZSkubWF0Y2goZm9ybWF0dGluZ1Rva2VucykgfHwgW107XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICBwYXJzZWRJbnB1dCA9IChzdHJpbmcubWF0Y2goZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpKSB8fCBbXSlbMF07XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygndG9rZW4nLCB0b2tlbiwgJ3BhcnNlZElucHV0JywgcGFyc2VkSW5wdXQsXG4gICAgICAgICAgICAvLyAgICAgICAgICdyZWdleCcsIGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSk7XG4gICAgICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBza2lwcGVkID0gc3RyaW5nLnN1YnN0cigwLCBzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkpO1xuICAgICAgICAgICAgICAgIGlmIChza2lwcGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChza2lwcGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSArIHBhcnNlZElucHV0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCArPSBwYXJzZWRJbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkb24ndCBwYXJzZSBpZiBpdCdzIG5vdCBhIGtub3duIHRva2VuXG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBwYXJzZWRJbnB1dCwgY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbmZpZy5fc3RyaWN0ICYmICFwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCByZW1haW5pbmcgdW5wYXJzZWQgaW5wdXQgbGVuZ3RoIHRvIHRoZSBzdHJpbmdcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuY2hhcnNMZWZ0T3ZlciA9IHN0cmluZ0xlbmd0aCAtIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGg7XG4gICAgICAgIGlmIChzdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChzdHJpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYXIgXzEyaCBmbGFnIGlmIGhvdXIgaXMgPD0gMTJcbiAgICAgICAgaWYgKGNvbmZpZy5fYVtIT1VSXSA8PSAxMiAmJlxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID4gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnBhcnNlZERhdGVQYXJ0cyA9IGNvbmZpZy5fYS5zbGljZSgwKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykubWVyaWRpZW0gPSBjb25maWcuX21lcmlkaWVtO1xuICAgICAgICAvLyBoYW5kbGUgbWVyaWRpZW1cbiAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gbWVyaWRpZW1GaXhXcmFwKGNvbmZpZy5fbG9jYWxlLCBjb25maWcuX2FbSE9VUl0sIGNvbmZpZy5fbWVyaWRpZW0pO1xuXG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgICAgICBjaGVja092ZXJmbG93KGNvbmZpZyk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBtZXJpZGllbUZpeFdyYXAgKGxvY2FsZSwgaG91ciwgbWVyaWRpZW0pIHtcbiAgICAgICAgdmFyIGlzUG07XG5cbiAgICAgICAgaWYgKG1lcmlkaWVtID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhbGUubWVyaWRpZW1Ib3VyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubWVyaWRpZW1Ib3VyKGhvdXIsIG1lcmlkaWVtKTtcbiAgICAgICAgfSBlbHNlIGlmIChsb2NhbGUuaXNQTSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBGYWxsYmFja1xuICAgICAgICAgICAgaXNQbSA9IGxvY2FsZS5pc1BNKG1lcmlkaWVtKTtcbiAgICAgICAgICAgIGlmIChpc1BtICYmIGhvdXIgPCAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgKz0gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzUG0gJiYgaG91ciA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICBob3VyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBub3Qgc3VwcG9zZWQgdG8gaGFwcGVuXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGFycmF5IG9mIGZvcm1hdCBzdHJpbmdzXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZykge1xuICAgICAgICB2YXIgdGVtcENvbmZpZyxcbiAgICAgICAgICAgIGJlc3RNb21lbnQsXG5cbiAgICAgICAgICAgIHNjb3JlVG9CZWF0LFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZTtcblxuICAgICAgICBpZiAoY29uZmlnLl9mLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZEZvcm1hdCA9IHRydWU7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShOYU4pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbmZpZy5fZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3VycmVudFNjb3JlID0gMDtcbiAgICAgICAgICAgIHRlbXBDb25maWcgPSBjb3B5Q29uZmlnKHt9LCBjb25maWcpO1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5fdXNlVVRDICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0ZW1wQ29uZmlnLl91c2VVVEMgPSBjb25maWcuX3VzZVVUQztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRlbXBDb25maWcuX2YgPSBjb25maWcuX2ZbaV07XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KHRlbXBDb25maWcpO1xuXG4gICAgICAgICAgICBpZiAoIWlzVmFsaWQodGVtcENvbmZpZykpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW55IGlucHV0IHRoYXQgd2FzIG5vdCBwYXJzZWQgYWRkIGEgcGVuYWx0eSBmb3IgdGhhdCBmb3JtYXRcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuY2hhcnNMZWZ0T3ZlcjtcblxuICAgICAgICAgICAgLy9vciB0b2tlbnNcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykudW51c2VkVG9rZW5zLmxlbmd0aCAqIDEwO1xuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuc2NvcmUgPSBjdXJyZW50U2NvcmU7XG5cbiAgICAgICAgICAgIGlmIChzY29yZVRvQmVhdCA9PSBudWxsIHx8IGN1cnJlbnRTY29yZSA8IHNjb3JlVG9CZWF0KSB7XG4gICAgICAgICAgICAgICAgc2NvcmVUb0JlYXQgPSBjdXJyZW50U2NvcmU7XG4gICAgICAgICAgICAgICAgYmVzdE1vbWVudCA9IHRlbXBDb25maWc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHRlbmQoY29uZmlnLCBiZXN0TW9tZW50IHx8IHRlbXBDb25maWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21PYmplY3QoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoY29uZmlnLl9pKTtcbiAgICAgICAgY29uZmlnLl9hID0gbWFwKFtpLnllYXIsIGkubW9udGgsIGkuZGF5IHx8IGkuZGF0ZSwgaS5ob3VyLCBpLm1pbnV0ZSwgaS5zZWNvbmQsIGkubWlsbGlzZWNvbmRdLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqICYmIHBhcnNlSW50KG9iaiwgMTApO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVGcm9tQ29uZmlnIChjb25maWcpIHtcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhwcmVwYXJlQ29uZmlnKGNvbmZpZykpKTtcbiAgICAgICAgaWYgKHJlcy5fbmV4dERheSkge1xuICAgICAgICAgICAgLy8gQWRkaW5nIGlzIHNtYXJ0IGVub3VnaCBhcm91bmQgRFNUXG4gICAgICAgICAgICByZXMuYWRkKDEsICdkJyk7XG4gICAgICAgICAgICByZXMuX25leHREYXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXBhcmVDb25maWcgKGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBmb3JtYXQgPSBjb25maWcuX2Y7XG5cbiAgICAgICAgY29uZmlnLl9sb2NhbGUgPSBjb25maWcuX2xvY2FsZSB8fCBnZXRMb2NhbGUoY29uZmlnLl9sKTtcblxuICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgKGZvcm1hdCA9PT0gdW5kZWZpbmVkICYmIGlucHV0ID09PSAnJykpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKHtudWxsSW5wdXQ6IHRydWV9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25maWcuX2kgPSBpbnB1dCA9IGNvbmZpZy5fbG9jYWxlLnByZXBhcnNlKGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc01vbWVudChpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3coaW5wdXQpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBpbnB1dDtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCkge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICB9ICBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkKGNvbmZpZykpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gY29uZmlnLl9pO1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShob29rcy5ub3coKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQudmFsdWVPZigpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nKGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYSA9IG1hcChpbnB1dC5zbGljZSgwKSwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChvYmosIDEwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tT2JqZWN0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpKSB7XG4gICAgICAgICAgICAvLyBmcm9tIG1pbGxpc2Vjb25kc1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxvY2FsT3JVVEMgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBpc1VUQykge1xuICAgICAgICB2YXIgYyA9IHt9O1xuXG4gICAgICAgIGlmIChsb2NhbGUgPT09IHRydWUgfHwgbG9jYWxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgc3RyaWN0ID0gbG9jYWxlO1xuICAgICAgICAgICAgbG9jYWxlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChpc09iamVjdChpbnB1dCkgJiYgaXNPYmplY3RFbXB0eShpbnB1dCkpIHx8XG4gICAgICAgICAgICAgICAgKGlzQXJyYXkoaW5wdXQpICYmIGlucHV0Lmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICAgIGlucHV0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9iamVjdCBjb25zdHJ1Y3Rpb24gbXVzdCBiZSBkb25lIHRoaXMgd2F5LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTQyM1xuICAgICAgICBjLl9pc0FNb21lbnRPYmplY3QgPSB0cnVlO1xuICAgICAgICBjLl91c2VVVEMgPSBjLl9pc1VUQyA9IGlzVVRDO1xuICAgICAgICBjLl9sID0gbG9jYWxlO1xuICAgICAgICBjLl9pID0gaW5wdXQ7XG4gICAgICAgIGMuX2YgPSBmb3JtYXQ7XG4gICAgICAgIGMuX3N0cmljdCA9IHN0cmljdDtcblxuICAgICAgICByZXR1cm4gY3JlYXRlRnJvbUNvbmZpZyhjKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMb2NhbCAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGZhbHNlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG90eXBlTWluID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50KCkubWluIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWF4IGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvbWluLW1heC8nLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdGhlciA8IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgdmFyIHByb3RvdHlwZU1heCA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudCgpLm1heCBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1pbiBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL21pbi1tYXgvJyxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXIgPiB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIC8vIFBpY2sgYSBtb21lbnQgbSBmcm9tIG1vbWVudHMgc28gdGhhdCBtW2ZuXShvdGhlcikgaXMgdHJ1ZSBmb3IgYWxsXG4gICAgLy8gb3RoZXIuIFRoaXMgcmVsaWVzIG9uIHRoZSBmdW5jdGlvbiBmbiB0byBiZSB0cmFuc2l0aXZlLlxuICAgIC8vXG4gICAgLy8gbW9tZW50cyBzaG91bGQgZWl0aGVyIGJlIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzIG9yIGFuIGFycmF5LCB3aG9zZVxuICAgIC8vIGZpcnN0IGVsZW1lbnQgaXMgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMuXG4gICAgZnVuY3Rpb24gcGlja0J5KGZuLCBtb21lbnRzKSB7XG4gICAgICAgIHZhciByZXMsIGk7XG4gICAgICAgIGlmIChtb21lbnRzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5KG1vbWVudHNbMF0pKSB7XG4gICAgICAgICAgICBtb21lbnRzID0gbW9tZW50c1swXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1vbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXMgPSBtb21lbnRzWzBdO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbW9tZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKCFtb21lbnRzW2ldLmlzVmFsaWQoKSB8fCBtb21lbnRzW2ldW2ZuXShyZXMpKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gbW9tZW50c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8vIFRPRE86IFVzZSBbXS5zb3J0IGluc3RlYWQ/XG4gICAgZnVuY3Rpb24gbWluICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICAgICAgcmV0dXJuIHBpY2tCeSgnaXNCZWZvcmUnLCBhcmdzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXggKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICByZXR1cm4gcGlja0J5KCdpc0FmdGVyJywgYXJncyk7XG4gICAgfVxuXG4gICAgdmFyIG5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIERhdGUubm93ID8gRGF0ZS5ub3coKSA6ICsobmV3IERhdGUoKSk7XG4gICAgfTtcblxuICAgIHZhciBvcmRlcmluZyA9IFsneWVhcicsICdxdWFydGVyJywgJ21vbnRoJywgJ3dlZWsnLCAnZGF5JywgJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCcsICdtaWxsaXNlY29uZCddO1xuXG4gICAgZnVuY3Rpb24gaXNEdXJhdGlvblZhbGlkKG0pIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG0pIHtcbiAgICAgICAgICAgIGlmICghKGluZGV4T2YuY2FsbChvcmRlcmluZywga2V5KSAhPT0gLTEgJiYgKG1ba2V5XSA9PSBudWxsIHx8ICFpc05hTihtW2tleV0pKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdW5pdEhhc0RlY2ltYWwgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlcmluZy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKG1bb3JkZXJpbmdbaV1dKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVuaXRIYXNEZWNpbWFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gb25seSBhbGxvdyBub24taW50ZWdlcnMgZm9yIHNtYWxsZXN0IHVuaXRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlRmxvYXQobVtvcmRlcmluZ1tpXV0pICE9PSB0b0ludChtW29yZGVyaW5nW2ldXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pdEhhc0RlY2ltYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVmFsaWQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVmFsaWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSW52YWxpZCQxKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oTmFOKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBEdXJhdGlvbiAoZHVyYXRpb24pIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGR1cmF0aW9uKSxcbiAgICAgICAgICAgIHllYXJzID0gbm9ybWFsaXplZElucHV0LnllYXIgfHwgMCxcbiAgICAgICAgICAgIHF1YXJ0ZXJzID0gbm9ybWFsaXplZElucHV0LnF1YXJ0ZXIgfHwgMCxcbiAgICAgICAgICAgIG1vbnRocyA9IG5vcm1hbGl6ZWRJbnB1dC5tb250aCB8fCAwLFxuICAgICAgICAgICAgd2Vla3MgPSBub3JtYWxpemVkSW5wdXQud2VlayB8fCAwLFxuICAgICAgICAgICAgZGF5cyA9IG5vcm1hbGl6ZWRJbnB1dC5kYXkgfHwgMCxcbiAgICAgICAgICAgIGhvdXJzID0gbm9ybWFsaXplZElucHV0LmhvdXIgfHwgMCxcbiAgICAgICAgICAgIG1pbnV0ZXMgPSBub3JtYWxpemVkSW5wdXQubWludXRlIHx8IDAsXG4gICAgICAgICAgICBzZWNvbmRzID0gbm9ybWFsaXplZElucHV0LnNlY29uZCB8fCAwLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gbm9ybWFsaXplZElucHV0Lm1pbGxpc2Vjb25kIHx8IDA7XG5cbiAgICAgICAgdGhpcy5faXNWYWxpZCA9IGlzRHVyYXRpb25WYWxpZChub3JtYWxpemVkSW5wdXQpO1xuXG4gICAgICAgIC8vIHJlcHJlc2VudGF0aW9uIGZvciBkYXRlQWRkUmVtb3ZlXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9ICttaWxsaXNlY29uZHMgK1xuICAgICAgICAgICAgc2Vjb25kcyAqIDFlMyArIC8vIDEwMDBcbiAgICAgICAgICAgIG1pbnV0ZXMgKiA2ZTQgKyAvLyAxMDAwICogNjBcbiAgICAgICAgICAgIGhvdXJzICogMTAwMCAqIDYwICogNjA7IC8vdXNpbmcgMTAwMCAqIDYwICogNjAgaW5zdGVhZCBvZiAzNmU1IHRvIGF2b2lkIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9ycyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjk3OFxuICAgICAgICAvLyBCZWNhdXNlIG9mIGRhdGVBZGRSZW1vdmUgdHJlYXRzIDI0IGhvdXJzIGFzIGRpZmZlcmVudCBmcm9tIGFcbiAgICAgICAgLy8gZGF5IHdoZW4gd29ya2luZyBhcm91bmQgRFNULCB3ZSBuZWVkIHRvIHN0b3JlIHRoZW0gc2VwYXJhdGVseVxuICAgICAgICB0aGlzLl9kYXlzID0gK2RheXMgK1xuICAgICAgICAgICAgd2Vla3MgKiA3O1xuICAgICAgICAvLyBJdCBpcyBpbXBvc3NpYmxlIHRvIHRyYW5zbGF0ZSBtb250aHMgaW50byBkYXlzIHdpdGhvdXQga25vd2luZ1xuICAgICAgICAvLyB3aGljaCBtb250aHMgeW91IGFyZSBhcmUgdGFsa2luZyBhYm91dCwgc28gd2UgaGF2ZSB0byBzdG9yZVxuICAgICAgICAvLyBpdCBzZXBhcmF0ZWx5LlxuICAgICAgICB0aGlzLl9tb250aHMgPSArbW9udGhzICtcbiAgICAgICAgICAgIHF1YXJ0ZXJzICogMyArXG4gICAgICAgICAgICB5ZWFycyAqIDEyO1xuXG4gICAgICAgIHRoaXMuX2RhdGEgPSB7fTtcblxuICAgICAgICB0aGlzLl9sb2NhbGUgPSBnZXRMb2NhbGUoKTtcblxuICAgICAgICB0aGlzLl9idWJibGUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0R1cmF0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIER1cmF0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic1JvdW5kIChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKC0xICogbnVtYmVyKSAqIC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGZ1bmN0aW9uIG9mZnNldCAodG9rZW4sIHNlcGFyYXRvcikge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbih0b2tlbiwgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMudXRjT2Zmc2V0KCk7XG4gICAgICAgICAgICB2YXIgc2lnbiA9ICcrJztcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gLW9mZnNldDtcbiAgICAgICAgICAgICAgICBzaWduID0gJy0nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNpZ24gKyB6ZXJvRmlsbCh+fihvZmZzZXQgLyA2MCksIDIpICsgc2VwYXJhdG9yICsgemVyb0ZpbGwofn4ob2Zmc2V0KSAlIDYwLCAyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb2Zmc2V0KCdaJywgJzonKTtcbiAgICBvZmZzZXQoJ1paJywgJycpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignWicsICBtYXRjaFNob3J0T2Zmc2V0KTtcbiAgICBhZGRSZWdleFRva2VuKCdaWicsIG1hdGNoU2hvcnRPZmZzZXQpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydaJywgJ1paJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX3VzZVVUQyA9IHRydWU7XG4gICAgICAgIGNvbmZpZy5fdHptID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaFNob3J0T2Zmc2V0LCBpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyB0aW1lem9uZSBjaHVua2VyXG4gICAgLy8gJysxMDowMCcgPiBbJzEwJywgICcwMCddXG4gICAgLy8gJy0xNTMwJyAgPiBbJy0xNScsICczMCddXG4gICAgdmFyIGNodW5rT2Zmc2V0ID0gLyhbXFwrXFwtXXxcXGRcXGQpL2dpO1xuXG4gICAgZnVuY3Rpb24gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaGVyLCBzdHJpbmcpIHtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSAoc3RyaW5nIHx8ICcnKS5tYXRjaChtYXRjaGVyKTtcblxuICAgICAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2h1bmsgICA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXSB8fCBbXTtcbiAgICAgICAgdmFyIHBhcnRzICAgPSAoY2h1bmsgKyAnJykubWF0Y2goY2h1bmtPZmZzZXQpIHx8IFsnLScsIDAsIDBdO1xuICAgICAgICB2YXIgbWludXRlcyA9ICsocGFydHNbMV0gKiA2MCkgKyB0b0ludChwYXJ0c1syXSk7XG5cbiAgICAgICAgcmV0dXJuIG1pbnV0ZXMgPT09IDAgP1xuICAgICAgICAgIDAgOlxuICAgICAgICAgIHBhcnRzWzBdID09PSAnKycgPyBtaW51dGVzIDogLW1pbnV0ZXM7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGEgbW9tZW50IGZyb20gaW5wdXQsIHRoYXQgaXMgbG9jYWwvdXRjL3pvbmUgZXF1aXZhbGVudCB0byBtb2RlbC5cbiAgICBmdW5jdGlvbiBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIG1vZGVsKSB7XG4gICAgICAgIHZhciByZXMsIGRpZmY7XG4gICAgICAgIGlmIChtb2RlbC5faXNVVEMpIHtcbiAgICAgICAgICAgIHJlcyA9IG1vZGVsLmNsb25lKCk7XG4gICAgICAgICAgICBkaWZmID0gKGlzTW9tZW50KGlucHV0KSB8fCBpc0RhdGUoaW5wdXQpID8gaW5wdXQudmFsdWVPZigpIDogY3JlYXRlTG9jYWwoaW5wdXQpLnZhbHVlT2YoKSkgLSByZXMudmFsdWVPZigpO1xuICAgICAgICAgICAgLy8gVXNlIGxvdy1sZXZlbCBhcGksIGJlY2F1c2UgdGhpcyBmbiBpcyBsb3ctbGV2ZWwgYXBpLlxuICAgICAgICAgICAgcmVzLl9kLnNldFRpbWUocmVzLl9kLnZhbHVlT2YoKSArIGRpZmYpO1xuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHJlcywgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVMb2NhbChpbnB1dCkubG9jYWwoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERhdGVPZmZzZXQgKG0pIHtcbiAgICAgICAgLy8gT24gRmlyZWZveC4yNCBEYXRlI2dldFRpbWV6b25lT2Zmc2V0IHJldHVybnMgYSBmbG9hdGluZyBwb2ludC5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvcHVsbC8xODcxXG4gICAgICAgIHJldHVybiAtTWF0aC5yb3VuZChtLl9kLmdldFRpbWV6b25lT2Zmc2V0KCkgLyAxNSkgKiAxNTtcbiAgICB9XG5cbiAgICAvLyBIT09LU1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciBhIG1vbWVudCBpcyBtdXRhdGVkLlxuICAgIC8vIEl0IGlzIGludGVuZGVkIHRvIGtlZXAgdGhlIG9mZnNldCBpbiBzeW5jIHdpdGggdGhlIHRpbWV6b25lLlxuICAgIGhvb2tzLnVwZGF0ZU9mZnNldCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgLy8ga2VlcExvY2FsVGltZSA9IHRydWUgbWVhbnMgb25seSBjaGFuZ2UgdGhlIHRpbWV6b25lLCB3aXRob3V0XG4gICAgLy8gYWZmZWN0aW5nIHRoZSBsb2NhbCBob3VyLiBTbyA1OjMxOjI2ICswMzAwIC0tW3V0Y09mZnNldCgyLCB0cnVlKV0tLT5cbiAgICAvLyA1OjMxOjI2ICswMjAwIEl0IGlzIHBvc3NpYmxlIHRoYXQgNTozMToyNiBkb2Vzbid0IGV4aXN0IHdpdGggb2Zmc2V0XG4gICAgLy8gKzAyMDAsIHNvIHdlIGFkanVzdCB0aGUgdGltZSBhcyBuZWVkZWQsIHRvIGJlIHZhbGlkLlxuICAgIC8vXG4gICAgLy8gS2VlcGluZyB0aGUgdGltZSBhY3R1YWxseSBhZGRzL3N1YnRyYWN0cyAob25lIGhvdXIpXG4gICAgLy8gZnJvbSB0aGUgYWN0dWFsIHJlcHJlc2VudGVkIHRpbWUuIFRoYXQgaXMgd2h5IHdlIGNhbGwgdXBkYXRlT2Zmc2V0XG4gICAgLy8gYSBzZWNvbmQgdGltZS4gSW4gY2FzZSBpdCB3YW50cyB1cyB0byBjaGFuZ2UgdGhlIG9mZnNldCBhZ2FpblxuICAgIC8vIF9jaGFuZ2VJblByb2dyZXNzID09IHRydWUgY2FzZSwgdGhlbiB3ZSBoYXZlIHRvIGFkanVzdCwgYmVjYXVzZVxuICAgIC8vIHRoZXJlIGlzIG5vIHN1Y2ggdGltZSBpbiB0aGUgZ2l2ZW4gdGltZXpvbmUuXG4gICAgZnVuY3Rpb24gZ2V0U2V0T2Zmc2V0IChpbnB1dCwga2VlcExvY2FsVGltZSwga2VlcE1pbnV0ZXMpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX29mZnNldCB8fCAwLFxuICAgICAgICAgICAgbG9jYWxBZGp1c3Q7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hTaG9ydE9mZnNldCwgaW5wdXQpO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGlucHV0KSA8IDE2ICYmICFrZWVwTWludXRlcykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQgKiA2MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5faXNVVEMgJiYga2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgICAgIGxvY2FsQWRqdXN0ID0gZ2V0RGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX29mZnNldCA9IGlucHV0O1xuICAgICAgICAgICAgdGhpcy5faXNVVEMgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGxvY2FsQWRqdXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChsb2NhbEFkanVzdCwgJ20nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvZmZzZXQgIT09IGlucHV0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFrZWVwTG9jYWxUaW1lIHx8IHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkU3VidHJhY3QodGhpcywgY3JlYXRlRHVyYXRpb24oaW5wdXQgLSBvZmZzZXQsICdtJyksIDEsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gb2Zmc2V0IDogZ2V0RGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldFpvbmUgKGlucHV0LCBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gLWlucHV0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldChpbnB1dCwga2VlcExvY2FsVGltZSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC10aGlzLnV0Y09mZnNldCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9VVEMgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvTG9jYWwgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzVVRDKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgwLCBrZWVwTG9jYWxUaW1lKTtcbiAgICAgICAgICAgIHRoaXMuX2lzVVRDID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJ0cmFjdChnZXREYXRlT2Zmc2V0KHRoaXMpLCAnbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0ICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCh0aGlzLl90em0sIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5faSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciB0Wm9uZSA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hPZmZzZXQsIHRoaXMuX2kpO1xuICAgICAgICAgICAgaWYgKHRab25lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnV0Y09mZnNldCh0Wm9uZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgwLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNBbGlnbmVkSG91ck9mZnNldCAoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0ID0gaW5wdXQgPyBjcmVhdGVMb2NhbChpbnB1dCkudXRjT2Zmc2V0KCkgOiAwO1xuXG4gICAgICAgIHJldHVybiAodGhpcy51dGNPZmZzZXQoKSAtIGlucHV0KSAlIDYwID09PSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lICgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoMCkudXRjT2Zmc2V0KCkgfHxcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoNSkudXRjT2Zmc2V0KClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQgKCkge1xuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX2lzRFNUU2hpZnRlZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYyA9IHt9O1xuXG4gICAgICAgIGNvcHlDb25maWcoYywgdGhpcyk7XG4gICAgICAgIGMgPSBwcmVwYXJlQ29uZmlnKGMpO1xuXG4gICAgICAgIGlmIChjLl9hKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBjLl9pc1VUQyA/IGNyZWF0ZVVUQyhjLl9hKSA6IGNyZWF0ZUxvY2FsKGMuX2EpO1xuICAgICAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gdGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICAgICBjb21wYXJlQXJyYXlzKGMuX2EsIG90aGVyLnRvQXJyYXkoKSkgPiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTG9jYWwgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyAhdGhpcy5faXNVVEMgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1V0Y09mZnNldCAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2lzVVRDIDogZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNVdGMgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9pc1VUQyAmJiB0aGlzLl9vZmZzZXQgPT09IDAgOiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBBU1AuTkVUIGpzb24gZGF0ZSBmb3JtYXQgcmVnZXhcbiAgICB2YXIgYXNwTmV0UmVnZXggPSAvXihcXC18XFwrKT8oPzooXFxkKilbLiBdKT8oXFxkKylcXDooXFxkKykoPzpcXDooXFxkKykoXFwuXFxkKik/KT8kLztcblxuICAgIC8vIGZyb20gaHR0cDovL2RvY3MuY2xvc3VyZS1saWJyYXJ5Lmdvb2dsZWNvZGUuY29tL2dpdC9jbG9zdXJlX2dvb2dfZGF0ZV9kYXRlLmpzLnNvdXJjZS5odG1sXG4gICAgLy8gc29tZXdoYXQgbW9yZSBpbiBsaW5lIHdpdGggNC40LjMuMiAyMDA0IHNwZWMsIGJ1dCBhbGxvd3MgZGVjaW1hbCBhbnl3aGVyZVxuICAgIC8vIGFuZCBmdXJ0aGVyIG1vZGlmaWVkIHRvIGFsbG93IGZvciBzdHJpbmdzIGNvbnRhaW5pbmcgYm90aCB3ZWVrIGFuZCBkYXlcbiAgICB2YXIgaXNvUmVnZXggPSAvXigtfFxcKyk/UCg/OihbLStdP1swLTksLl0qKVkpPyg/OihbLStdP1swLTksLl0qKU0pPyg/OihbLStdP1swLTksLl0qKVcpPyg/OihbLStdP1swLTksLl0qKUQpPyg/OlQoPzooWy0rXT9bMC05LC5dKilIKT8oPzooWy0rXT9bMC05LC5dKilNKT8oPzooWy0rXT9bMC05LC5dKilTKT8pPyQvO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlRHVyYXRpb24gKGlucHV0LCBrZXkpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gaW5wdXQsXG4gICAgICAgICAgICAvLyBtYXRjaGluZyBhZ2FpbnN0IHJlZ2V4cCBpcyBleHBlbnNpdmUsIGRvIGl0IG9uIGRlbWFuZFxuICAgICAgICAgICAgbWF0Y2ggPSBudWxsLFxuICAgICAgICAgICAgc2lnbixcbiAgICAgICAgICAgIHJldCxcbiAgICAgICAgICAgIGRpZmZSZXM7XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBtcyA6IGlucHV0Ll9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICAgICAgZCAgOiBpbnB1dC5fZGF5cyxcbiAgICAgICAgICAgICAgICBNICA6IGlucHV0Ll9tb250aHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uW2tleV0gPSBpbnB1dDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb24ubWlsbGlzZWNvbmRzID0gaW5wdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoISEobWF0Y2ggPSBhc3BOZXRSZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgICAgIHNpZ24gPSAobWF0Y2hbMV0gPT09ICctJykgPyAtMSA6IDE7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB5ICA6IDAsXG4gICAgICAgICAgICAgICAgZCAgOiB0b0ludChtYXRjaFtEQVRFXSkgICAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIGggIDogdG9JbnQobWF0Y2hbSE9VUl0pICAgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICBtICA6IHRvSW50KG1hdGNoW01JTlVURV0pICAgICAgICAgICAgICAgICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgcyAgOiB0b0ludChtYXRjaFtTRUNPTkRdKSAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIG1zIDogdG9JbnQoYWJzUm91bmQobWF0Y2hbTUlMTElTRUNPTkRdICogMTAwMCkpICogc2lnbiAvLyB0aGUgbWlsbGlzZWNvbmQgZGVjaW1hbCBwb2ludCBpcyBpbmNsdWRlZCBpbiB0aGUgbWF0Y2hcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoISEobWF0Y2ggPSBpc29SZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgICAgIHNpZ24gPSAobWF0Y2hbMV0gPT09ICctJykgPyAtMSA6IChtYXRjaFsxXSA9PT0gJysnKSA/IDEgOiAxO1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeSA6IHBhcnNlSXNvKG1hdGNoWzJdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBNIDogcGFyc2VJc28obWF0Y2hbM10sIHNpZ24pLFxuICAgICAgICAgICAgICAgIHcgOiBwYXJzZUlzbyhtYXRjaFs0XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgZCA6IHBhcnNlSXNvKG1hdGNoWzVdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBoIDogcGFyc2VJc28obWF0Y2hbNl0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIG0gOiBwYXJzZUlzbyhtYXRjaFs3XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgcyA6IHBhcnNlSXNvKG1hdGNoWzhdLCBzaWduKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7Ly8gY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZHVyYXRpb24gPT09ICdvYmplY3QnICYmICgnZnJvbScgaW4gZHVyYXRpb24gfHwgJ3RvJyBpbiBkdXJhdGlvbikpIHtcbiAgICAgICAgICAgIGRpZmZSZXMgPSBtb21lbnRzRGlmZmVyZW5jZShjcmVhdGVMb2NhbChkdXJhdGlvbi5mcm9tKSwgY3JlYXRlTG9jYWwoZHVyYXRpb24udG8pKTtcblxuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgICAgIGR1cmF0aW9uLm1zID0gZGlmZlJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgICAgICBkdXJhdGlvbi5NID0gZGlmZlJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXQgPSBuZXcgRHVyYXRpb24oZHVyYXRpb24pO1xuXG4gICAgICAgIGlmIChpc0R1cmF0aW9uKGlucHV0KSAmJiBoYXNPd25Qcm9wKGlucHV0LCAnX2xvY2FsZScpKSB7XG4gICAgICAgICAgICByZXQuX2xvY2FsZSA9IGlucHV0Ll9sb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGNyZWF0ZUR1cmF0aW9uLmZuID0gRHVyYXRpb24ucHJvdG90eXBlO1xuICAgIGNyZWF0ZUR1cmF0aW9uLmludmFsaWQgPSBjcmVhdGVJbnZhbGlkJDE7XG5cbiAgICBmdW5jdGlvbiBwYXJzZUlzbyAoaW5wLCBzaWduKSB7XG4gICAgICAgIC8vIFdlJ2Qgbm9ybWFsbHkgdXNlIH5+aW5wIGZvciB0aGlzLCBidXQgdW5mb3J0dW5hdGVseSBpdCBhbHNvXG4gICAgICAgIC8vIGNvbnZlcnRzIGZsb2F0cyB0byBpbnRzLlxuICAgICAgICAvLyBpbnAgbWF5IGJlIHVuZGVmaW5lZCwgc28gY2FyZWZ1bCBjYWxsaW5nIHJlcGxhY2Ugb24gaXQuXG4gICAgICAgIHZhciByZXMgPSBpbnAgJiYgcGFyc2VGbG9hdChpbnAucmVwbGFjZSgnLCcsICcuJykpO1xuICAgICAgICAvLyBhcHBseSBzaWduIHdoaWxlIHdlJ3JlIGF0IGl0XG4gICAgICAgIHJldHVybiAoaXNOYU4ocmVzKSA/IDAgOiByZXMpICogc2lnbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXMgPSB7bWlsbGlzZWNvbmRzOiAwLCBtb250aHM6IDB9O1xuXG4gICAgICAgIHJlcy5tb250aHMgPSBvdGhlci5tb250aCgpIC0gYmFzZS5tb250aCgpICtcbiAgICAgICAgICAgIChvdGhlci55ZWFyKCkgLSBiYXNlLnllYXIoKSkgKiAxMjtcbiAgICAgICAgaWYgKGJhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKS5pc0FmdGVyKG90aGVyKSkge1xuICAgICAgICAgICAgLS1yZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzLm1pbGxpc2Vjb25kcyA9ICtvdGhlciAtICsoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpKTtcblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIGlmICghKGJhc2UuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7bWlsbGlzZWNvbmRzOiAwLCBtb250aHM6IDB9O1xuICAgICAgICB9XG5cbiAgICAgICAgb3RoZXIgPSBjbG9uZVdpdGhPZmZzZXQob3RoZXIsIGJhc2UpO1xuICAgICAgICBpZiAoYmFzZS5pc0JlZm9yZShvdGhlcikpIHtcbiAgICAgICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShvdGhlciwgYmFzZSk7XG4gICAgICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gLXJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgICAgICByZXMubW9udGhzID0gLXJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8vIFRPRE86IHJlbW92ZSAnbmFtZScgYXJnIGFmdGVyIGRlcHJlY2F0aW9uIGlzIHJlbW92ZWRcbiAgICBmdW5jdGlvbiBjcmVhdGVBZGRlcihkaXJlY3Rpb24sIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwsIHBlcmlvZCkge1xuICAgICAgICAgICAgdmFyIGR1ciwgdG1wO1xuICAgICAgICAgICAgLy9pbnZlcnQgdGhlIGFyZ3VtZW50cywgYnV0IGNvbXBsYWluIGFib3V0IGl0XG4gICAgICAgICAgICBpZiAocGVyaW9kICE9PSBudWxsICYmICFpc05hTigrcGVyaW9kKSkge1xuICAgICAgICAgICAgICAgIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCAnbW9tZW50KCkuJyArIG5hbWUgICsgJyhwZXJpb2QsIG51bWJlcikgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBtb21lbnQoKS4nICsgbmFtZSArICcobnVtYmVyLCBwZXJpb2QpLiAnICtcbiAgICAgICAgICAgICAgICAnU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvYWRkLWludmVydGVkLXBhcmFtLyBmb3IgbW9yZSBpbmZvLicpO1xuICAgICAgICAgICAgICAgIHRtcCA9IHZhbDsgdmFsID0gcGVyaW9kOyBwZXJpb2QgPSB0bXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbCA9IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gK3ZhbCA6IHZhbDtcbiAgICAgICAgICAgIGR1ciA9IGNyZWF0ZUR1cmF0aW9uKHZhbCwgcGVyaW9kKTtcbiAgICAgICAgICAgIGFkZFN1YnRyYWN0KHRoaXMsIGR1ciwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFN1YnRyYWN0IChtb20sIGR1cmF0aW9uLCBpc0FkZGluZywgdXBkYXRlT2Zmc2V0KSB7XG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgZGF5cyA9IGFic1JvdW5kKGR1cmF0aW9uLl9kYXlzKSxcbiAgICAgICAgICAgIG1vbnRocyA9IGFic1JvdW5kKGR1cmF0aW9uLl9tb250aHMpO1xuXG4gICAgICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZU9mZnNldCA9IHVwZGF0ZU9mZnNldCA9PSBudWxsID8gdHJ1ZSA6IHVwZGF0ZU9mZnNldDtcblxuICAgICAgICBpZiAobW9udGhzKSB7XG4gICAgICAgICAgICBzZXRNb250aChtb20sIGdldChtb20sICdNb250aCcpICsgbW9udGhzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXlzKSB7XG4gICAgICAgICAgICBzZXQkMShtb20sICdEYXRlJywgZ2V0KG1vbSwgJ0RhdGUnKSArIGRheXMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbGxpc2Vjb25kcykge1xuICAgICAgICAgICAgbW9tLl9kLnNldFRpbWUobW9tLl9kLnZhbHVlT2YoKSArIG1pbGxpc2Vjb25kcyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlT2Zmc2V0KSB7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQobW9tLCBkYXlzIHx8IG1vbnRocyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYWRkICAgICAgPSBjcmVhdGVBZGRlcigxLCAnYWRkJyk7XG4gICAgdmFyIHN1YnRyYWN0ID0gY3JlYXRlQWRkZXIoLTEsICdzdWJ0cmFjdCcpO1xuXG4gICAgZnVuY3Rpb24gZ2V0Q2FsZW5kYXJGb3JtYXQobXlNb21lbnQsIG5vdykge1xuICAgICAgICB2YXIgZGlmZiA9IG15TW9tZW50LmRpZmYobm93LCAnZGF5cycsIHRydWUpO1xuICAgICAgICByZXR1cm4gZGlmZiA8IC02ID8gJ3NhbWVFbHNlJyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IC0xID8gJ2xhc3RXZWVrJyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDAgPyAnbGFzdERheScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAxID8gJ3NhbWVEYXknIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgMiA/ICduZXh0RGF5JyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDcgPyAnbmV4dFdlZWsnIDogJ3NhbWVFbHNlJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxlbmRhciQxICh0aW1lLCBmb3JtYXRzKSB7XG4gICAgICAgIC8vIFdlIHdhbnQgdG8gY29tcGFyZSB0aGUgc3RhcnQgb2YgdG9kYXksIHZzIHRoaXMuXG4gICAgICAgIC8vIEdldHRpbmcgc3RhcnQtb2YtdG9kYXkgZGVwZW5kcyBvbiB3aGV0aGVyIHdlJ3JlIGxvY2FsL3V0Yy9vZmZzZXQgb3Igbm90LlxuICAgICAgICB2YXIgbm93ID0gdGltZSB8fCBjcmVhdGVMb2NhbCgpLFxuICAgICAgICAgICAgc29kID0gY2xvbmVXaXRoT2Zmc2V0KG5vdywgdGhpcykuc3RhcnRPZignZGF5JyksXG4gICAgICAgICAgICBmb3JtYXQgPSBob29rcy5jYWxlbmRhckZvcm1hdCh0aGlzLCBzb2QpIHx8ICdzYW1lRWxzZSc7XG5cbiAgICAgICAgdmFyIG91dHB1dCA9IGZvcm1hdHMgJiYgKGlzRnVuY3Rpb24oZm9ybWF0c1tmb3JtYXRdKSA/IGZvcm1hdHNbZm9ybWF0XS5jYWxsKHRoaXMsIG5vdykgOiBmb3JtYXRzW2Zvcm1hdF0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChvdXRwdXQgfHwgdGhpcy5sb2NhbGVEYXRhKCkuY2FsZW5kYXIoZm9ybWF0LCB0aGlzLCBjcmVhdGVMb2NhbChub3cpKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgICAgICByZXR1cm4gbmV3IE1vbWVudCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FmdGVyIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyghaXNVbmRlZmluZWQodW5pdHMpID8gdW5pdHMgOiAnbWlsbGlzZWNvbmQnKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPiBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbElucHV0LnZhbHVlT2YoKSA8IHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKS52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0JlZm9yZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBjcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHMoIWlzVW5kZWZpbmVkKHVuaXRzKSA/IHVuaXRzIDogJ21pbGxpc2Vjb25kJyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpIDwgbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmVuZE9mKHVuaXRzKS52YWx1ZU9mKCkgPCBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQmV0d2VlbiAoZnJvbSwgdG8sIHVuaXRzLCBpbmNsdXNpdml0eSkge1xuICAgICAgICBpbmNsdXNpdml0eSA9IGluY2x1c2l2aXR5IHx8ICcoKSc7XG4gICAgICAgIHJldHVybiAoaW5jbHVzaXZpdHlbMF0gPT09ICcoJyA/IHRoaXMuaXNBZnRlcihmcm9tLCB1bml0cykgOiAhdGhpcy5pc0JlZm9yZShmcm9tLCB1bml0cykpICYmXG4gICAgICAgICAgICAoaW5jbHVzaXZpdHlbMV0gPT09ICcpJyA/IHRoaXMuaXNCZWZvcmUodG8sIHVuaXRzKSA6ICF0aGlzLmlzQWZ0ZXIodG8sIHVuaXRzKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KSxcbiAgICAgICAgICAgIGlucHV0TXM7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMgfHwgJ21pbGxpc2Vjb25kJyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpID09PSBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0TXMgPSBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cykudmFsdWVPZigpIDw9IGlucHV0TXMgJiYgaW5wdXRNcyA8PSB0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZU9yQWZ0ZXIgKGlucHV0LCB1bml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1NhbWUoaW5wdXQsIHVuaXRzKSB8fCB0aGlzLmlzQWZ0ZXIoaW5wdXQsdW5pdHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZU9yQmVmb3JlIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTYW1lKGlucHV0LCB1bml0cykgfHwgdGhpcy5pc0JlZm9yZShpbnB1dCx1bml0cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGlmZiAoaW5wdXQsIHVuaXRzLCBhc0Zsb2F0KSB7XG4gICAgICAgIHZhciB0aGF0LFxuICAgICAgICAgICAgem9uZURlbHRhLFxuICAgICAgICAgICAgb3V0cHV0O1xuXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICB0aGF0ID0gY2xvbmVXaXRoT2Zmc2V0KGlucHV0LCB0aGlzKTtcblxuICAgICAgICBpZiAoIXRoYXQuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgem9uZURlbHRhID0gKHRoYXQudXRjT2Zmc2V0KCkgLSB0aGlzLnV0Y09mZnNldCgpKSAqIDZlNDtcblxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICBjYXNlICd5ZWFyJzogb3V0cHV0ID0gbW9udGhEaWZmKHRoaXMsIHRoYXQpIC8gMTI7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW9udGgnOiBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCk7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncXVhcnRlcic6IG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KSAvIDM7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDFlMzsgYnJlYWs7IC8vIDEwMDBcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6IG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyA2ZTQ7IGJyZWFrOyAvLyAxMDAwICogNjBcbiAgICAgICAgICAgIGNhc2UgJ2hvdXInOiBvdXRwdXQgPSAodGhpcyAtIHRoYXQpIC8gMzZlNTsgYnJlYWs7IC8vIDEwMDAgKiA2MCAqIDYwXG4gICAgICAgICAgICBjYXNlICdkYXknOiBvdXRwdXQgPSAodGhpcyAtIHRoYXQgLSB6b25lRGVsdGEpIC8gODY0ZTU7IGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MCAqIDI0LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICBjYXNlICd3ZWVrJzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0IC0gem9uZURlbHRhKSAvIDYwNDhlNTsgYnJlYWs7IC8vIDEwMDAgKiA2MCAqIDYwICogMjQgKiA3LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICBkZWZhdWx0OiBvdXRwdXQgPSB0aGlzIC0gdGhhdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhc0Zsb2F0ID8gb3V0cHV0IDogYWJzRmxvb3Iob3V0cHV0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb250aERpZmYgKGEsIGIpIHtcbiAgICAgICAgLy8gZGlmZmVyZW5jZSBpbiBtb250aHNcbiAgICAgICAgdmFyIHdob2xlTW9udGhEaWZmID0gKChiLnllYXIoKSAtIGEueWVhcigpKSAqIDEyKSArIChiLm1vbnRoKCkgLSBhLm1vbnRoKCkpLFxuICAgICAgICAgICAgLy8gYiBpcyBpbiAoYW5jaG9yIC0gMSBtb250aCwgYW5jaG9yICsgMSBtb250aClcbiAgICAgICAgICAgIGFuY2hvciA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYsICdtb250aHMnKSxcbiAgICAgICAgICAgIGFuY2hvcjIsIGFkanVzdDtcblxuICAgICAgICBpZiAoYiAtIGFuY2hvciA8IDApIHtcbiAgICAgICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmIC0gMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IgLSBhbmNob3IyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmICsgMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IyIC0gYW5jaG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY2hlY2sgZm9yIG5lZ2F0aXZlIHplcm8sIHJldHVybiB6ZXJvIGlmIG5lZ2F0aXZlIHplcm9cbiAgICAgICAgcmV0dXJuIC0od2hvbGVNb250aERpZmYgKyBhZGp1c3QpIHx8IDA7XG4gICAgfVxuXG4gICAgaG9va3MuZGVmYXVsdEZvcm1hdCA9ICdZWVlZLU1NLUREVEhIOm1tOnNzWic7XG4gICAgaG9va3MuZGVmYXVsdEZvcm1hdFV0YyA9ICdZWVlZLU1NLUREVEhIOm1tOnNzW1pdJztcblxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5sb2NhbGUoJ2VuJykuZm9ybWF0KCdkZGQgTU1NIEREIFlZWVkgSEg6bW06c3MgW0dNVF1aWicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSVNPU3RyaW5nKGtlZXBPZmZzZXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHV0YyA9IGtlZXBPZmZzZXQgIT09IHRydWU7XG4gICAgICAgIHZhciBtID0gdXRjID8gdGhpcy5jbG9uZSgpLnV0YygpIDogdGhpcztcbiAgICAgICAgaWYgKG0ueWVhcigpIDwgMCB8fCBtLnllYXIoKSA+IDk5OTkpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQobSwgdXRjID8gJ1lZWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXScgOiAnWVlZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTWicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nKSkge1xuICAgICAgICAgICAgLy8gbmF0aXZlIGltcGxlbWVudGF0aW9uIGlzIH41MHggZmFzdGVyLCB1c2UgaXQgd2hlbiB3ZSBjYW5cbiAgICAgICAgICAgIGlmICh1dGMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0RhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy52YWx1ZU9mKCkgKyB0aGlzLnV0Y09mZnNldCgpICogNjAgKiAxMDAwKS50b0lTT1N0cmluZygpLnJlcGxhY2UoJ1onLCBmb3JtYXRNb21lbnQobSwgJ1onKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChtLCB1dGMgPyAnWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXScgOiAnWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1onKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBodW1hbiByZWFkYWJsZSByZXByZXNlbnRhdGlvbiBvZiBhIG1vbWVudCB0aGF0IGNhblxuICAgICAqIGFsc28gYmUgZXZhbHVhdGVkIHRvIGdldCBhIG5ldyBtb21lbnQgd2hpY2ggaXMgdGhlIHNhbWVcbiAgICAgKlxuICAgICAqIEBsaW5rIGh0dHBzOi8vbm9kZWpzLm9yZy9kaXN0L2xhdGVzdC9kb2NzL2FwaS91dGlsLmh0bWwjdXRpbF9jdXN0b21faW5zcGVjdF9mdW5jdGlvbl9vbl9vYmplY3RzXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnbW9tZW50LmludmFsaWQoLyogJyArIHRoaXMuX2kgKyAnICovKSc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZ1bmMgPSAnbW9tZW50JztcbiAgICAgICAgdmFyIHpvbmUgPSAnJztcbiAgICAgICAgaWYgKCF0aGlzLmlzTG9jYWwoKSkge1xuICAgICAgICAgICAgZnVuYyA9IHRoaXMudXRjT2Zmc2V0KCkgPT09IDAgPyAnbW9tZW50LnV0YycgOiAnbW9tZW50LnBhcnNlWm9uZSc7XG4gICAgICAgICAgICB6b25lID0gJ1onO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmVmaXggPSAnWycgKyBmdW5jICsgJyhcIl0nO1xuICAgICAgICB2YXIgeWVhciA9ICgwIDw9IHRoaXMueWVhcigpICYmIHRoaXMueWVhcigpIDw9IDk5OTkpID8gJ1lZWVknIDogJ1lZWVlZWSc7XG4gICAgICAgIHZhciBkYXRldGltZSA9ICctTU0tRERbVF1ISDptbTpzcy5TU1MnO1xuICAgICAgICB2YXIgc3VmZml4ID0gem9uZSArICdbXCIpXSc7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KHByZWZpeCArIHllYXIgKyBkYXRldGltZSArIHN1ZmZpeCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0IChpbnB1dFN0cmluZykge1xuICAgICAgICBpZiAoIWlucHV0U3RyaW5nKSB7XG4gICAgICAgICAgICBpbnB1dFN0cmluZyA9IHRoaXMuaXNVdGMoKSA/IGhvb2tzLmRlZmF1bHRGb3JtYXRVdGMgOiBob29rcy5kZWZhdWx0Rm9ybWF0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdXRwdXQgPSBmb3JtYXRNb21lbnQodGhpcywgaW5wdXRTdHJpbmcpO1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkucG9zdGZvcm1hdChvdXRwdXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZyb20gKHRpbWUsIHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAgICAgKChpc01vbWVudCh0aW1lKSAmJiB0aW1lLmlzVmFsaWQoKSkgfHxcbiAgICAgICAgICAgICAgICAgY3JlYXRlTG9jYWwodGltZSkuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHt0bzogdGhpcywgZnJvbTogdGltZX0pLmxvY2FsZSh0aGlzLmxvY2FsZSgpKS5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZyb21Ob3cgKHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbShjcmVhdGVMb2NhbCgpLCB3aXRob3V0U3VmZml4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0byAodGltZSwgd2l0aG91dFN1ZmZpeCkge1xuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fFxuICAgICAgICAgICAgICAgICBjcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oe2Zyb206IHRoaXMsIHRvOiB0aW1lfSkubG9jYWxlKHRoaXMubG9jYWxlKCkpLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9Ob3cgKHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG8oY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgLy8gSWYgcGFzc2VkIGEgbG9jYWxlIGtleSwgaXQgd2lsbCBzZXQgdGhlIGxvY2FsZSBmb3IgdGhpc1xuICAgIC8vIGluc3RhbmNlLiAgT3RoZXJ3aXNlLCBpdCB3aWxsIHJldHVybiB0aGUgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbiAgICAvLyB2YXJpYWJsZXMgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAgZnVuY3Rpb24gbG9jYWxlIChrZXkpIHtcbiAgICAgICAgdmFyIG5ld0xvY2FsZURhdGE7XG5cbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxlLl9hYmJyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3TG9jYWxlRGF0YSA9IGdldExvY2FsZShrZXkpO1xuICAgICAgICAgICAgaWYgKG5ld0xvY2FsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvY2FsZSA9IG5ld0xvY2FsZURhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsYW5nID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50KCkubGFuZygpIGlzIGRlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZSBtb21lbnQoKS5sb2NhbGVEYXRhKCkgdG8gZ2V0IHRoZSBsYW5ndWFnZSBjb25maWd1cmF0aW9uLiBVc2UgbW9tZW50KCkubG9jYWxlKCkgdG8gY2hhbmdlIGxhbmd1YWdlcy4nLFxuICAgICAgICBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZURhdGEgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YXJ0T2YgKHVuaXRzKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICAvLyB0aGUgZm9sbG93aW5nIHN3aXRjaCBpbnRlbnRpb25hbGx5IG9taXRzIGJyZWFrIGtleXdvcmRzXG4gICAgICAgIC8vIHRvIHV0aWxpemUgZmFsbGluZyB0aHJvdWdoIHRoZSBjYXNlcy5cbiAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICAgICAgdGhpcy5tb250aCgwKTtcbiAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGUoMSk7XG4gICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICBjYXNlICdpc29XZWVrJzpcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgICAgICAgICB0aGlzLmhvdXJzKDApO1xuICAgICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgICAgIHRoaXMubWludXRlcygwKTtcbiAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgICAgIHRoaXMuc2Vjb25kcygwKTtcbiAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgICAgIHRoaXMubWlsbGlzZWNvbmRzKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2Vla3MgYXJlIGEgc3BlY2lhbCBjYXNlXG4gICAgICAgIGlmICh1bml0cyA9PT0gJ3dlZWsnKSB7XG4gICAgICAgICAgICB0aGlzLndlZWtkYXkoMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaXRzID09PSAnaXNvV2VlaycpIHtcbiAgICAgICAgICAgIHRoaXMuaXNvV2Vla2RheSgxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHF1YXJ0ZXJzIGFyZSBhbHNvIHNwZWNpYWxcbiAgICAgICAgaWYgKHVuaXRzID09PSAncXVhcnRlcicpIHtcbiAgICAgICAgICAgIHRoaXMubW9udGgoTWF0aC5mbG9vcih0aGlzLm1vbnRoKCkgLyAzKSAqIDMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5kT2YgKHVuaXRzKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICBpZiAodW5pdHMgPT09IHVuZGVmaW5lZCB8fCB1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAnZGF0ZScgaXMgYW4gYWxpYXMgZm9yICdkYXknLCBzbyBpdCBzaG91bGQgYmUgY29uc2lkZXJlZCBhcyBzdWNoLlxuICAgICAgICBpZiAodW5pdHMgPT09ICdkYXRlJykge1xuICAgICAgICAgICAgdW5pdHMgPSAnZGF5JztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0T2YodW5pdHMpLmFkZCgxLCAodW5pdHMgPT09ICdpc29XZWVrJyA/ICd3ZWVrJyA6IHVuaXRzKSkuc3VidHJhY3QoMSwgJ21zJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsdWVPZiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kLnZhbHVlT2YoKSAtICgodGhpcy5fb2Zmc2V0IHx8IDApICogNjAwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuaXggKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih0aGlzLnZhbHVlT2YoKSAvIDEwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvRGF0ZSAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnZhbHVlT2YoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9BcnJheSAoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFttLnllYXIoKSwgbS5tb250aCgpLCBtLmRhdGUoKSwgbS5ob3VyKCksIG0ubWludXRlKCksIG0uc2Vjb25kKCksIG0ubWlsbGlzZWNvbmQoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9PYmplY3QgKCkge1xuICAgICAgICB2YXIgbSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5ZWFyczogbS55ZWFyKCksXG4gICAgICAgICAgICBtb250aHM6IG0ubW9udGgoKSxcbiAgICAgICAgICAgIGRhdGU6IG0uZGF0ZSgpLFxuICAgICAgICAgICAgaG91cnM6IG0uaG91cnMoKSxcbiAgICAgICAgICAgIG1pbnV0ZXM6IG0ubWludXRlcygpLFxuICAgICAgICAgICAgc2Vjb25kczogbS5zZWNvbmRzKCksXG4gICAgICAgICAgICBtaWxsaXNlY29uZHM6IG0ubWlsbGlzZWNvbmRzKClcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0pTT04gKCkge1xuICAgICAgICAvLyBuZXcgRGF0ZShOYU4pLnRvSlNPTigpID09PSBudWxsXG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMudG9JU09TdHJpbmcoKSA6IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNWYWxpZCQyICgpIHtcbiAgICAgICAgcmV0dXJuIGlzVmFsaWQodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2luZ0ZsYWdzICgpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVuZCh7fSwgZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnZhbGlkQXQgKCkge1xuICAgICAgICByZXR1cm4gZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpLm92ZXJmbG93O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0aW9uRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlucHV0OiB0aGlzLl9pLFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLl9mLFxuICAgICAgICAgICAgbG9jYWxlOiB0aGlzLl9sb2NhbGUsXG4gICAgICAgICAgICBpc1VUQzogdGhpcy5faXNVVEMsXG4gICAgICAgICAgICBzdHJpY3Q6IHRoaXMuX3N0cmljdFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnZ2cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53ZWVrWWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydHRycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzb1dlZWtZZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBhZGRXZWVrWWVhckZvcm1hdFRva2VuICh0b2tlbiwgZ2V0dGVyKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKDAsIFt0b2tlbiwgdG9rZW4ubGVuZ3RoXSwgMCwgZ2V0dGVyKTtcbiAgICB9XG5cbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnJywgICAgICd3ZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2dnJywgICAgJ3dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignR0dHRycsICAnaXNvV2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHRycsICdpc29XZWVrWWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrWWVhcicsICdnZycpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2Vla1llYXInLCAnR0cnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWtZZWFyJywgMSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrWWVhcicsIDEpO1xuXG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdHJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignZycsICAgICAgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdnZycsICAgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignR0dHRycsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnZ2cnLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdHR0dHRycsICBtYXRjaDF0bzYsIG1hdGNoNik7XG4gICAgYWRkUmVnZXhUb2tlbignZ2dnZ2cnLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydnZ2dnJywgJ2dnZ2dnJywgJ0dHR0cnLCAnR0dHR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDIpXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZ2cnLCAnR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW5dID0gaG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXIgKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKHRoaXMsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgdGhpcy53ZWVrKCksXG4gICAgICAgICAgICAgICAgdGhpcy53ZWVrZGF5KCksXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93LFxuICAgICAgICAgICAgICAgIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRveSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPV2Vla1llYXIgKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKHRoaXMsXG4gICAgICAgICAgICAgICAgaW5wdXQsIHRoaXMuaXNvV2VlaygpLCB0aGlzLmlzb1dlZWtkYXkoKSwgMSwgNCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SVNPV2Vla3NJblllYXIgKCkge1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIDEsIDQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFdlZWtzSW5ZZWFyICgpIHtcbiAgICAgICAgdmFyIHdlZWtJbmZvID0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWs7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgd2Vla0luZm8uZG93LCB3ZWVrSW5mby5kb3kpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWtZZWFySGVscGVyKGlucHV0LCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgICAgICB2YXIgd2Vla3NUYXJnZXQ7XG4gICAgICAgIGlmIChpbnB1dCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gd2Vla09mWWVhcih0aGlzLCBkb3csIGRveSkueWVhcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdlZWtzVGFyZ2V0ID0gd2Vla3NJblllYXIoaW5wdXQsIGRvdywgZG95KTtcbiAgICAgICAgICAgIGlmICh3ZWVrID4gd2Vla3NUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICB3ZWVrID0gd2Vla3NUYXJnZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2V0V2Vla0FsbC5jYWxsKHRoaXMsIGlucHV0LCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRXZWVrQWxsKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgICAgICB2YXIgZGF5T2ZZZWFyRGF0YSA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpLFxuICAgICAgICAgICAgZGF0ZSA9IGNyZWF0ZVVUQ0RhdGUoZGF5T2ZZZWFyRGF0YS55ZWFyLCAwLCBkYXlPZlllYXJEYXRhLmRheU9mWWVhcik7XG5cbiAgICAgICAgdGhpcy55ZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSk7XG4gICAgICAgIHRoaXMubW9udGgoZGF0ZS5nZXRVVENNb250aCgpKTtcbiAgICAgICAgdGhpcy5kYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1EnLCAwLCAnUW8nLCAncXVhcnRlcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdxdWFydGVyJywgJ1EnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3F1YXJ0ZXInLCA3KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1EnLCBtYXRjaDEpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1EnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9ICh0b0ludChpbnB1dCkgLSAxKSAqIDM7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRRdWFydGVyIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IE1hdGguY2VpbCgodGhpcy5tb250aCgpICsgMSkgLyAzKSA6IHRoaXMubW9udGgoKGlucHV0IC0gMSkgKiAzICsgdGhpcy5tb250aCgpICUgMyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0QnLCBbJ0REJywgMl0sICdEbycsICdkYXRlJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RhdGUnLCAnRCcpO1xuXG4gICAgLy8gUFJJT1JJVFlcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2RhdGUnLCA5KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0QnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdERCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdEbycsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIC8vIFRPRE86IFJlbW92ZSBcIm9yZGluYWxQYXJzZVwiIGZhbGxiYWNrIGluIG5leHQgbWFqb3IgcmVsZWFzZS5cbiAgICAgICAgcmV0dXJuIGlzU3RyaWN0ID9cbiAgICAgICAgICAobG9jYWxlLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlIHx8IGxvY2FsZS5fb3JkaW5hbFBhcnNlKSA6XG4gICAgICAgICAgbG9jYWxlLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlTGVuaWVudDtcbiAgICB9KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydEJywgJ0REJ10sIERBVEUpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtEQVRFXSA9IHRvSW50KGlucHV0Lm1hdGNoKG1hdGNoMXRvMilbMF0pO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldERheU9mTW9udGggPSBtYWtlR2V0U2V0KCdEYXRlJywgdHJ1ZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignREREJywgWydEREREJywgM10sICdERERvJywgJ2RheU9mWWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdkYXlPZlllYXInLCAnREREJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF5T2ZZZWFyJywgNCk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdEREQnLCAgbWF0Y2gxdG8zKTtcbiAgICBhZGRSZWdleFRva2VuKCdEREREJywgbWF0Y2gzKTtcbiAgICBhZGRQYXJzZVRva2VuKFsnREREJywgJ0REREQnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0RGF5T2ZZZWFyIChpbnB1dCkge1xuICAgICAgICB2YXIgZGF5T2ZZZWFyID0gTWF0aC5yb3VuZCgodGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpIC0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ3llYXInKSkgLyA4NjRlNSkgKyAxO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IGRheU9mWWVhciA6IHRoaXMuYWRkKChpbnB1dCAtIGRheU9mWWVhciksICdkJyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ20nLCBbJ21tJywgMl0sIDAsICdtaW51dGUnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnbWludXRlJywgJ20nKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ21pbnV0ZScsIDE0KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ20nLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdtbScsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRQYXJzZVRva2VuKFsnbScsICdtbSddLCBNSU5VVEUpO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldE1pbnV0ZSA9IG1ha2VHZXRTZXQoJ01pbnV0ZXMnLCBmYWxzZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbigncycsIFsnc3MnLCAyXSwgMCwgJ3NlY29uZCcpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdzZWNvbmQnLCAncycpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnc2Vjb25kJywgMTUpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigncycsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3NzJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydzJywgJ3NzJ10sIFNFQ09ORCk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0U2Vjb25kID0gbWFrZUdldFNldCgnU2Vjb25kcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdTJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTAwKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1MnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1MnLCAzXSwgMCwgJ21pbGxpc2Vjb25kJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTJywgNF0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1MnLCA1XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTJywgNl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTJywgN10sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1MnLCA4XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1NTJywgOV0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDA7XG4gICAgfSk7XG5cblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnbWlsbGlzZWNvbmQnLCAnbXMnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ21pbGxpc2Vjb25kJywgMTYpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignUycsICAgIG1hdGNoMXRvMywgbWF0Y2gxKTtcbiAgICBhZGRSZWdleFRva2VuKCdTUycsICAgbWF0Y2gxdG8zLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1NTUycsICBtYXRjaDF0bzMsIG1hdGNoMyk7XG5cbiAgICB2YXIgdG9rZW47XG4gICAgZm9yICh0b2tlbiA9ICdTU1NTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgICAgICBhZGRSZWdleFRva2VuKHRva2VuLCBtYXRjaFVuc2lnbmVkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU1zKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNSUxMSVNFQ09ORF0gPSB0b0ludCgoJzAuJyArIGlucHV0KSAqIDEwMDApO1xuICAgIH1cblxuICAgIGZvciAodG9rZW4gPSAnUyc7IHRva2VuLmxlbmd0aCA8PSA5OyB0b2tlbiArPSAnUycpIHtcbiAgICAgICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgcGFyc2VNcyk7XG4gICAgfVxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRNaWxsaXNlY29uZCA9IG1ha2VHZXRTZXQoJ01pbGxpc2Vjb25kcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCd6JywgIDAsIDAsICd6b25lQWJicicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd6eicsIDAsIDAsICd6b25lTmFtZScpO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0Wm9uZUFiYnIgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnVVRDJyA6ICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFpvbmVOYW1lICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ0Nvb3JkaW5hdGVkIFVuaXZlcnNhbCBUaW1lJyA6ICcnO1xuICAgIH1cblxuICAgIHZhciBwcm90byA9IE1vbWVudC5wcm90b3R5cGU7XG5cbiAgICBwcm90by5hZGQgICAgICAgICAgICAgICA9IGFkZDtcbiAgICBwcm90by5jYWxlbmRhciAgICAgICAgICA9IGNhbGVuZGFyJDE7XG4gICAgcHJvdG8uY2xvbmUgICAgICAgICAgICAgPSBjbG9uZTtcbiAgICBwcm90by5kaWZmICAgICAgICAgICAgICA9IGRpZmY7XG4gICAgcHJvdG8uZW5kT2YgICAgICAgICAgICAgPSBlbmRPZjtcbiAgICBwcm90by5mb3JtYXQgICAgICAgICAgICA9IGZvcm1hdDtcbiAgICBwcm90by5mcm9tICAgICAgICAgICAgICA9IGZyb207XG4gICAgcHJvdG8uZnJvbU5vdyAgICAgICAgICAgPSBmcm9tTm93O1xuICAgIHByb3RvLnRvICAgICAgICAgICAgICAgID0gdG87XG4gICAgcHJvdG8udG9Ob3cgICAgICAgICAgICAgPSB0b05vdztcbiAgICBwcm90by5nZXQgICAgICAgICAgICAgICA9IHN0cmluZ0dldDtcbiAgICBwcm90by5pbnZhbGlkQXQgICAgICAgICA9IGludmFsaWRBdDtcbiAgICBwcm90by5pc0FmdGVyICAgICAgICAgICA9IGlzQWZ0ZXI7XG4gICAgcHJvdG8uaXNCZWZvcmUgICAgICAgICAgPSBpc0JlZm9yZTtcbiAgICBwcm90by5pc0JldHdlZW4gICAgICAgICA9IGlzQmV0d2VlbjtcbiAgICBwcm90by5pc1NhbWUgICAgICAgICAgICA9IGlzU2FtZTtcbiAgICBwcm90by5pc1NhbWVPckFmdGVyICAgICA9IGlzU2FtZU9yQWZ0ZXI7XG4gICAgcHJvdG8uaXNTYW1lT3JCZWZvcmUgICAgPSBpc1NhbWVPckJlZm9yZTtcbiAgICBwcm90by5pc1ZhbGlkICAgICAgICAgICA9IGlzVmFsaWQkMjtcbiAgICBwcm90by5sYW5nICAgICAgICAgICAgICA9IGxhbmc7XG4gICAgcHJvdG8ubG9jYWxlICAgICAgICAgICAgPSBsb2NhbGU7XG4gICAgcHJvdG8ubG9jYWxlRGF0YSAgICAgICAgPSBsb2NhbGVEYXRhO1xuICAgIHByb3RvLm1heCAgICAgICAgICAgICAgID0gcHJvdG90eXBlTWF4O1xuICAgIHByb3RvLm1pbiAgICAgICAgICAgICAgID0gcHJvdG90eXBlTWluO1xuICAgIHByb3RvLnBhcnNpbmdGbGFncyAgICAgID0gcGFyc2luZ0ZsYWdzO1xuICAgIHByb3RvLnNldCAgICAgICAgICAgICAgID0gc3RyaW5nU2V0O1xuICAgIHByb3RvLnN0YXJ0T2YgICAgICAgICAgID0gc3RhcnRPZjtcbiAgICBwcm90by5zdWJ0cmFjdCAgICAgICAgICA9IHN1YnRyYWN0O1xuICAgIHByb3RvLnRvQXJyYXkgICAgICAgICAgID0gdG9BcnJheTtcbiAgICBwcm90by50b09iamVjdCAgICAgICAgICA9IHRvT2JqZWN0O1xuICAgIHByb3RvLnRvRGF0ZSAgICAgICAgICAgID0gdG9EYXRlO1xuICAgIHByb3RvLnRvSVNPU3RyaW5nICAgICAgID0gdG9JU09TdHJpbmc7XG4gICAgcHJvdG8uaW5zcGVjdCAgICAgICAgICAgPSBpbnNwZWN0O1xuICAgIHByb3RvLnRvSlNPTiAgICAgICAgICAgID0gdG9KU09OO1xuICAgIHByb3RvLnRvU3RyaW5nICAgICAgICAgID0gdG9TdHJpbmc7XG4gICAgcHJvdG8udW5peCAgICAgICAgICAgICAgPSB1bml4O1xuICAgIHByb3RvLnZhbHVlT2YgICAgICAgICAgID0gdmFsdWVPZjtcbiAgICBwcm90by5jcmVhdGlvbkRhdGEgICAgICA9IGNyZWF0aW9uRGF0YTtcbiAgICBwcm90by55ZWFyICAgICAgID0gZ2V0U2V0WWVhcjtcbiAgICBwcm90by5pc0xlYXBZZWFyID0gZ2V0SXNMZWFwWWVhcjtcbiAgICBwcm90by53ZWVrWWVhciAgICA9IGdldFNldFdlZWtZZWFyO1xuICAgIHByb3RvLmlzb1dlZWtZZWFyID0gZ2V0U2V0SVNPV2Vla1llYXI7XG4gICAgcHJvdG8ucXVhcnRlciA9IHByb3RvLnF1YXJ0ZXJzID0gZ2V0U2V0UXVhcnRlcjtcbiAgICBwcm90by5tb250aCAgICAgICA9IGdldFNldE1vbnRoO1xuICAgIHByb3RvLmRheXNJbk1vbnRoID0gZ2V0RGF5c0luTW9udGg7XG4gICAgcHJvdG8ud2VlayAgICAgICAgICAgPSBwcm90by53ZWVrcyAgICAgICAgPSBnZXRTZXRXZWVrO1xuICAgIHByb3RvLmlzb1dlZWsgICAgICAgID0gcHJvdG8uaXNvV2Vla3MgICAgID0gZ2V0U2V0SVNPV2VlaztcbiAgICBwcm90by53ZWVrc0luWWVhciAgICA9IGdldFdlZWtzSW5ZZWFyO1xuICAgIHByb3RvLmlzb1dlZWtzSW5ZZWFyID0gZ2V0SVNPV2Vla3NJblllYXI7XG4gICAgcHJvdG8uZGF0ZSAgICAgICA9IGdldFNldERheU9mTW9udGg7XG4gICAgcHJvdG8uZGF5ICAgICAgICA9IHByb3RvLmRheXMgICAgICAgICAgICAgPSBnZXRTZXREYXlPZldlZWs7XG4gICAgcHJvdG8ud2Vla2RheSAgICA9IGdldFNldExvY2FsZURheU9mV2VlaztcbiAgICBwcm90by5pc29XZWVrZGF5ID0gZ2V0U2V0SVNPRGF5T2ZXZWVrO1xuICAgIHByb3RvLmRheU9mWWVhciAgPSBnZXRTZXREYXlPZlllYXI7XG4gICAgcHJvdG8uaG91ciA9IHByb3RvLmhvdXJzID0gZ2V0U2V0SG91cjtcbiAgICBwcm90by5taW51dGUgPSBwcm90by5taW51dGVzID0gZ2V0U2V0TWludXRlO1xuICAgIHByb3RvLnNlY29uZCA9IHByb3RvLnNlY29uZHMgPSBnZXRTZXRTZWNvbmQ7XG4gICAgcHJvdG8ubWlsbGlzZWNvbmQgPSBwcm90by5taWxsaXNlY29uZHMgPSBnZXRTZXRNaWxsaXNlY29uZDtcbiAgICBwcm90by51dGNPZmZzZXQgICAgICAgICAgICA9IGdldFNldE9mZnNldDtcbiAgICBwcm90by51dGMgICAgICAgICAgICAgICAgICA9IHNldE9mZnNldFRvVVRDO1xuICAgIHByb3RvLmxvY2FsICAgICAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9Mb2NhbDtcbiAgICBwcm90by5wYXJzZVpvbmUgICAgICAgICAgICA9IHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0O1xuICAgIHByb3RvLmhhc0FsaWduZWRIb3VyT2Zmc2V0ID0gaGFzQWxpZ25lZEhvdXJPZmZzZXQ7XG4gICAgcHJvdG8uaXNEU1QgICAgICAgICAgICAgICAgPSBpc0RheWxpZ2h0U2F2aW5nVGltZTtcbiAgICBwcm90by5pc0xvY2FsICAgICAgICAgICAgICA9IGlzTG9jYWw7XG4gICAgcHJvdG8uaXNVdGNPZmZzZXQgICAgICAgICAgPSBpc1V0Y09mZnNldDtcbiAgICBwcm90by5pc1V0YyAgICAgICAgICAgICAgICA9IGlzVXRjO1xuICAgIHByb3RvLmlzVVRDICAgICAgICAgICAgICAgID0gaXNVdGM7XG4gICAgcHJvdG8uem9uZUFiYnIgPSBnZXRab25lQWJicjtcbiAgICBwcm90by56b25lTmFtZSA9IGdldFpvbmVOYW1lO1xuICAgIHByb3RvLmRhdGVzICA9IGRlcHJlY2F0ZSgnZGF0ZXMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIGRhdGUgaW5zdGVhZC4nLCBnZXRTZXREYXlPZk1vbnRoKTtcbiAgICBwcm90by5tb250aHMgPSBkZXByZWNhdGUoJ21vbnRocyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgbW9udGggaW5zdGVhZCcsIGdldFNldE1vbnRoKTtcbiAgICBwcm90by55ZWFycyAgPSBkZXByZWNhdGUoJ3llYXJzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSB5ZWFyIGluc3RlYWQnLCBnZXRTZXRZZWFyKTtcbiAgICBwcm90by56b25lICAgPSBkZXByZWNhdGUoJ21vbWVudCgpLnpvbmUgaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudCgpLnV0Y09mZnNldCBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL3pvbmUvJywgZ2V0U2V0Wm9uZSk7XG4gICAgcHJvdG8uaXNEU1RTaGlmdGVkID0gZGVwcmVjYXRlKCdpc0RTVFNoaWZ0ZWQgaXMgZGVwcmVjYXRlZC4gU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvZHN0LXNoaWZ0ZWQvIGZvciBtb3JlIGluZm9ybWF0aW9uJywgaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkKTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVVuaXggKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbChpbnB1dCAqIDEwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUluWm9uZSAoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpLnBhcnNlWm9uZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZVBhcnNlUG9zdEZvcm1hdCAoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvJDEgPSBMb2NhbGUucHJvdG90eXBlO1xuXG4gICAgcHJvdG8kMS5jYWxlbmRhciAgICAgICAgPSBjYWxlbmRhcjtcbiAgICBwcm90byQxLmxvbmdEYXRlRm9ybWF0ICA9IGxvbmdEYXRlRm9ybWF0O1xuICAgIHByb3RvJDEuaW52YWxpZERhdGUgICAgID0gaW52YWxpZERhdGU7XG4gICAgcHJvdG8kMS5vcmRpbmFsICAgICAgICAgPSBvcmRpbmFsO1xuICAgIHByb3RvJDEucHJlcGFyc2UgICAgICAgID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xuICAgIHByb3RvJDEucG9zdGZvcm1hdCAgICAgID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xuICAgIHByb3RvJDEucmVsYXRpdmVUaW1lICAgID0gcmVsYXRpdmVUaW1lO1xuICAgIHByb3RvJDEucGFzdEZ1dHVyZSAgICAgID0gcGFzdEZ1dHVyZTtcbiAgICBwcm90byQxLnNldCAgICAgICAgICAgICA9IHNldDtcblxuICAgIHByb3RvJDEubW9udGhzICAgICAgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzO1xuICAgIHByb3RvJDEubW9udGhzU2hvcnQgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzU2hvcnQ7XG4gICAgcHJvdG8kMS5tb250aHNQYXJzZSAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHNQYXJzZTtcbiAgICBwcm90byQxLm1vbnRoc1JlZ2V4ICAgICAgID0gbW9udGhzUmVnZXg7XG4gICAgcHJvdG8kMS5tb250aHNTaG9ydFJlZ2V4ICA9IG1vbnRoc1Nob3J0UmVnZXg7XG4gICAgcHJvdG8kMS53ZWVrID0gbG9jYWxlV2VlaztcbiAgICBwcm90byQxLmZpcnN0RGF5T2ZZZWFyID0gbG9jYWxlRmlyc3REYXlPZlllYXI7XG4gICAgcHJvdG8kMS5maXJzdERheU9mV2VlayA9IGxvY2FsZUZpcnN0RGF5T2ZXZWVrO1xuXG4gICAgcHJvdG8kMS53ZWVrZGF5cyAgICAgICA9ICAgICAgICBsb2NhbGVXZWVrZGF5cztcbiAgICBwcm90byQxLndlZWtkYXlzTWluICAgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzTWluO1xuICAgIHByb3RvJDEud2Vla2RheXNTaG9ydCAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNTaG9ydDtcbiAgICBwcm90byQxLndlZWtkYXlzUGFyc2UgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzUGFyc2U7XG5cbiAgICBwcm90byQxLndlZWtkYXlzUmVnZXggICAgICAgPSAgICAgICAgd2Vla2RheXNSZWdleDtcbiAgICBwcm90byQxLndlZWtkYXlzU2hvcnRSZWdleCAgPSAgICAgICAgd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgIHByb3RvJDEud2Vla2RheXNNaW5SZWdleCAgICA9ICAgICAgICB3ZWVrZGF5c01pblJlZ2V4O1xuXG4gICAgcHJvdG8kMS5pc1BNID0gbG9jYWxlSXNQTTtcbiAgICBwcm90byQxLm1lcmlkaWVtID0gbG9jYWxlTWVyaWRpZW07XG5cbiAgICBmdW5jdGlvbiBnZXQkMSAoZm9ybWF0LCBpbmRleCwgZmllbGQsIHNldHRlcikge1xuICAgICAgICB2YXIgbG9jYWxlID0gZ2V0TG9jYWxlKCk7XG4gICAgICAgIHZhciB1dGMgPSBjcmVhdGVVVEMoKS5zZXQoc2V0dGVyLCBpbmRleCk7XG4gICAgICAgIHJldHVybiBsb2NhbGVbZmllbGRdKHV0YywgZm9ybWF0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TW9udGhzSW1wbCAoZm9ybWF0LCBpbmRleCwgZmllbGQpIHtcbiAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuXG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0JDEoZm9ybWF0LCBpbmRleCwgZmllbGQsICdtb250aCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIG91dFtpXSA9IGdldCQxKGZvcm1hdCwgaSwgZmllbGQsICdtb250aCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgLy8gKClcbiAgICAvLyAoNSlcbiAgICAvLyAoZm10LCA1KVxuICAgIC8vIChmbXQpXG4gICAgLy8gKHRydWUpXG4gICAgLy8gKHRydWUsIDUpXG4gICAgLy8gKHRydWUsIGZtdCwgNSlcbiAgICAvLyAodHJ1ZSwgZm10KVxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5c0ltcGwgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgZmllbGQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsb2NhbGVTb3J0ZWQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IGxvY2FsZVNvcnRlZDtcbiAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgbG9jYWxlU29ydGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9jYWxlID0gZ2V0TG9jYWxlKCksXG4gICAgICAgICAgICBzaGlmdCA9IGxvY2FsZVNvcnRlZCA/IGxvY2FsZS5fd2Vlay5kb3cgOiAwO1xuXG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0JDEoZm9ybWF0LCAoaW5kZXggKyBzaGlmdCkgJSA3LCBmaWVsZCwgJ2RheScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgb3V0W2ldID0gZ2V0JDEoZm9ybWF0LCAoaSArIHNoaWZ0KSAlIDcsIGZpZWxkLCAnZGF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TW9udGhzIChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdE1vbnRoc1Nob3J0IChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzU2hvcnQnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0V2Vla2RheXMgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5cycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5c1Nob3J0IChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNTaG9ydCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5c01pbiAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzTWluJyk7XG4gICAgfVxuXG4gICAgZ2V0U2V0R2xvYmFsTG9jYWxlKCdlbicsIHtcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KHRofHN0fG5kfHJkKS8sXG4gICAgICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgYiA9IG51bWJlciAlIDEwLFxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0b0ludChudW1iZXIgJSAxMDAgLyAxMCkgPT09IDEpID8gJ3RoJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDEpID8gJ3N0JyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDIpID8gJ25kJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDMpID8gJ3JkJyA6ICd0aCc7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5cbiAgICBob29rcy5sYW5nID0gZGVwcmVjYXRlKCdtb21lbnQubGFuZyBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZSBpbnN0ZWFkLicsIGdldFNldEdsb2JhbExvY2FsZSk7XG4gICAgaG9va3MubGFuZ0RhdGEgPSBkZXByZWNhdGUoJ21vbWVudC5sYW5nRGF0YSBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZURhdGEgaW5zdGVhZC4nLCBnZXRMb2NhbGUpO1xuXG4gICAgdmFyIG1hdGhBYnMgPSBNYXRoLmFicztcblxuICAgIGZ1bmN0aW9uIGFicyAoKSB7XG4gICAgICAgIHZhciBkYXRhICAgICAgICAgICA9IHRoaXMuX2RhdGE7XG5cbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gbWF0aEFicyh0aGlzLl9taWxsaXNlY29uZHMpO1xuICAgICAgICB0aGlzLl9kYXlzICAgICAgICAgPSBtYXRoQWJzKHRoaXMuX2RheXMpO1xuICAgICAgICB0aGlzLl9tb250aHMgICAgICAgPSBtYXRoQWJzKHRoaXMuX21vbnRocyk7XG5cbiAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgID0gbWF0aEFicyhkYXRhLm1pbGxpc2Vjb25kcyk7XG4gICAgICAgIGRhdGEuc2Vjb25kcyAgICAgICA9IG1hdGhBYnMoZGF0YS5zZWNvbmRzKTtcbiAgICAgICAgZGF0YS5taW51dGVzICAgICAgID0gbWF0aEFicyhkYXRhLm1pbnV0ZXMpO1xuICAgICAgICBkYXRhLmhvdXJzICAgICAgICAgPSBtYXRoQWJzKGRhdGEuaG91cnMpO1xuICAgICAgICBkYXRhLm1vbnRocyAgICAgICAgPSBtYXRoQWJzKGRhdGEubW9udGhzKTtcbiAgICAgICAgZGF0YS55ZWFycyAgICAgICAgID0gbWF0aEFicyhkYXRhLnllYXJzKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRTdWJ0cmFjdCQxIChkdXJhdGlvbiwgaW5wdXQsIHZhbHVlLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlRHVyYXRpb24oaW5wdXQsIHZhbHVlKTtcblxuICAgICAgICBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzICs9IGRpcmVjdGlvbiAqIG90aGVyLl9taWxsaXNlY29uZHM7XG4gICAgICAgIGR1cmF0aW9uLl9kYXlzICAgICAgICAgKz0gZGlyZWN0aW9uICogb3RoZXIuX2RheXM7XG4gICAgICAgIGR1cmF0aW9uLl9tb250aHMgICAgICAgKz0gZGlyZWN0aW9uICogb3RoZXIuX21vbnRocztcblxuICAgICAgICByZXR1cm4gZHVyYXRpb24uX2J1YmJsZSgpO1xuICAgIH1cblxuICAgIC8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIGFkZCgxLCAncycpIG9yIGFkZChkdXJhdGlvbilcbiAgICBmdW5jdGlvbiBhZGQkMSAoaW5wdXQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhZGRTdWJ0cmFjdCQxKHRoaXMsIGlucHV0LCB2YWx1ZSwgMSk7XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgc3VidHJhY3QoMSwgJ3MnKSBvciBzdWJ0cmFjdChkdXJhdGlvbilcbiAgICBmdW5jdGlvbiBzdWJ0cmFjdCQxIChpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFkZFN1YnRyYWN0JDEodGhpcywgaW5wdXQsIHZhbHVlLCAtMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzQ2VpbCAobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnViYmxlICgpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcbiAgICAgICAgdmFyIGRheXMgICAgICAgICA9IHRoaXMuX2RheXM7XG4gICAgICAgIHZhciBtb250aHMgICAgICAgPSB0aGlzLl9tb250aHM7XG4gICAgICAgIHZhciBkYXRhICAgICAgICAgPSB0aGlzLl9kYXRhO1xuICAgICAgICB2YXIgc2Vjb25kcywgbWludXRlcywgaG91cnMsIHllYXJzLCBtb250aHNGcm9tRGF5cztcblxuICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgbWl4IG9mIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB2YWx1ZXMsIGJ1YmJsZSBkb3duIGZpcnN0XG4gICAgICAgIC8vIGNoZWNrOiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjE2NlxuICAgICAgICBpZiAoISgobWlsbGlzZWNvbmRzID49IDAgJiYgZGF5cyA+PSAwICYmIG1vbnRocyA+PSAwKSB8fFxuICAgICAgICAgICAgICAgIChtaWxsaXNlY29uZHMgPD0gMCAmJiBkYXlzIDw9IDAgJiYgbW9udGhzIDw9IDApKSkge1xuICAgICAgICAgICAgbWlsbGlzZWNvbmRzICs9IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRocykgKyBkYXlzKSAqIDg2NGU1O1xuICAgICAgICAgICAgZGF5cyA9IDA7XG4gICAgICAgICAgICBtb250aHMgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBjb2RlIGJ1YmJsZXMgdXAgdmFsdWVzLCBzZWUgdGhlIHRlc3RzIGZvclxuICAgICAgICAvLyBleGFtcGxlcyBvZiB3aGF0IHRoYXQgbWVhbnMuXG4gICAgICAgIGRhdGEubWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzICUgMTAwMDtcblxuICAgICAgICBzZWNvbmRzICAgICAgICAgICA9IGFic0Zsb29yKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xuICAgICAgICBkYXRhLnNlY29uZHMgICAgICA9IHNlY29uZHMgJSA2MDtcblxuICAgICAgICBtaW51dGVzICAgICAgICAgICA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgICAgIGRhdGEubWludXRlcyAgICAgID0gbWludXRlcyAlIDYwO1xuXG4gICAgICAgIGhvdXJzICAgICAgICAgICAgID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICAgICAgZGF0YS5ob3VycyAgICAgICAgPSBob3VycyAlIDI0O1xuXG4gICAgICAgIGRheXMgKz0gYWJzRmxvb3IoaG91cnMgLyAyNCk7XG5cbiAgICAgICAgLy8gY29udmVydCBkYXlzIHRvIG1vbnRoc1xuICAgICAgICBtb250aHNGcm9tRGF5cyA9IGFic0Zsb29yKGRheXNUb01vbnRocyhkYXlzKSk7XG4gICAgICAgIG1vbnRocyArPSBtb250aHNGcm9tRGF5cztcbiAgICAgICAgZGF5cyAtPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHNGcm9tRGF5cykpO1xuXG4gICAgICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICAgICAgeWVhcnMgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgICAgIG1vbnRocyAlPSAxMjtcblxuICAgICAgICBkYXRhLmRheXMgICA9IGRheXM7XG4gICAgICAgIGRhdGEubW9udGhzID0gbW9udGhzO1xuICAgICAgICBkYXRhLnllYXJzICA9IHllYXJzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheXNUb01vbnRocyAoZGF5cykge1xuICAgICAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxNDYwOTcgZGF5cyAodGFraW5nIGludG8gYWNjb3VudCBsZWFwIHllYXIgcnVsZXMpXG4gICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDEyIG1vbnRocyA9PT0gNDgwMFxuICAgICAgICByZXR1cm4gZGF5cyAqIDQ4MDAgLyAxNDYwOTc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhzVG9EYXlzIChtb250aHMpIHtcbiAgICAgICAgLy8gdGhlIHJldmVyc2Ugb2YgZGF5c1RvTW9udGhzXG4gICAgICAgIHJldHVybiBtb250aHMgKiAxNDYwOTcgLyA0ODAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzICh1bml0cykge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXlzO1xuICAgICAgICB2YXIgbW9udGhzO1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzO1xuXG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuXG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21vbnRoJyB8fCB1bml0cyA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgICBkYXlzICAgPSB0aGlzLl9kYXlzICAgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgIG1vbnRocyA9IHRoaXMuX21vbnRocyArIGRheXNUb01vbnRocyhkYXlzKTtcbiAgICAgICAgICAgIHJldHVybiB1bml0cyA9PT0gJ21vbnRoJyA/IG1vbnRocyA6IG1vbnRocyAvIDEyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaGFuZGxlIG1pbGxpc2Vjb25kcyBzZXBhcmF0ZWx5IGJlY2F1c2Ugb2YgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgKGlzc3VlICMxODY3KVxuICAgICAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMgKyBNYXRoLnJvdW5kKG1vbnRoc1RvRGF5cyh0aGlzLl9tb250aHMpKTtcbiAgICAgICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd3ZWVrJyAgIDogcmV0dXJuIGRheXMgLyA3ICAgICArIG1pbGxpc2Vjb25kcyAvIDYwNDhlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdkYXknICAgIDogcmV0dXJuIGRheXMgICAgICAgICArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ2hvdXInICAgOiByZXR1cm4gZGF5cyAqIDI0ICAgICsgbWlsbGlzZWNvbmRzIC8gMzZlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdtaW51dGUnIDogcmV0dXJuIGRheXMgKiAxNDQwICArIG1pbGxpc2Vjb25kcyAvIDZlNDtcbiAgICAgICAgICAgICAgICBjYXNlICdzZWNvbmQnIDogcmV0dXJuIGRheXMgKiA4NjQwMCArIG1pbGxpc2Vjb25kcyAvIDEwMDA7XG4gICAgICAgICAgICAgICAgLy8gTWF0aC5mbG9vciBwcmV2ZW50cyBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyBoZXJlXG4gICAgICAgICAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOiByZXR1cm4gTWF0aC5mbG9vcihkYXlzICogODY0ZTUpICsgbWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcignVW5rbm93biB1bml0ICcgKyB1bml0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiBVc2UgdGhpcy5hcygnbXMnKT9cbiAgICBmdW5jdGlvbiB2YWx1ZU9mJDEgKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgK1xuICAgICAgICAgICAgdGhpcy5fZGF5cyAqIDg2NGU1ICtcbiAgICAgICAgICAgICh0aGlzLl9tb250aHMgJSAxMikgKiAyNTkyZTYgK1xuICAgICAgICAgICAgdG9JbnQodGhpcy5fbW9udGhzIC8gMTIpICogMzE1MzZlNlxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VBcyAoYWxpYXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFzKGFsaWFzKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgYXNNaWxsaXNlY29uZHMgPSBtYWtlQXMoJ21zJyk7XG4gICAgdmFyIGFzU2Vjb25kcyAgICAgID0gbWFrZUFzKCdzJyk7XG4gICAgdmFyIGFzTWludXRlcyAgICAgID0gbWFrZUFzKCdtJyk7XG4gICAgdmFyIGFzSG91cnMgICAgICAgID0gbWFrZUFzKCdoJyk7XG4gICAgdmFyIGFzRGF5cyAgICAgICAgID0gbWFrZUFzKCdkJyk7XG4gICAgdmFyIGFzV2Vla3MgICAgICAgID0gbWFrZUFzKCd3Jyk7XG4gICAgdmFyIGFzTW9udGhzICAgICAgID0gbWFrZUFzKCdNJyk7XG4gICAgdmFyIGFzWWVhcnMgICAgICAgID0gbWFrZUFzKCd5Jyk7XG5cbiAgICBmdW5jdGlvbiBjbG9uZSQxICgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldCQyICh1bml0cykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpc1t1bml0cyArICdzJ10oKSA6IE5hTjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlR2V0dGVyKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2RhdGFbbmFtZV0gOiBOYU47XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIG1pbGxpc2Vjb25kcyA9IG1ha2VHZXR0ZXIoJ21pbGxpc2Vjb25kcycpO1xuICAgIHZhciBzZWNvbmRzICAgICAgPSBtYWtlR2V0dGVyKCdzZWNvbmRzJyk7XG4gICAgdmFyIG1pbnV0ZXMgICAgICA9IG1ha2VHZXR0ZXIoJ21pbnV0ZXMnKTtcbiAgICB2YXIgaG91cnMgICAgICAgID0gbWFrZUdldHRlcignaG91cnMnKTtcbiAgICB2YXIgZGF5cyAgICAgICAgID0gbWFrZUdldHRlcignZGF5cycpO1xuICAgIHZhciBtb250aHMgICAgICAgPSBtYWtlR2V0dGVyKCdtb250aHMnKTtcbiAgICB2YXIgeWVhcnMgICAgICAgID0gbWFrZUdldHRlcigneWVhcnMnKTtcblxuICAgIGZ1bmN0aW9uIHdlZWtzICgpIHtcbiAgICAgICAgcmV0dXJuIGFic0Zsb29yKHRoaXMuZGF5cygpIC8gNyk7XG4gICAgfVxuXG4gICAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbiAgICB2YXIgdGhyZXNob2xkcyA9IHtcbiAgICAgICAgc3M6IDQ0LCAgICAgICAgIC8vIGEgZmV3IHNlY29uZHMgdG8gc2Vjb25kc1xuICAgICAgICBzIDogNDUsICAgICAgICAgLy8gc2Vjb25kcyB0byBtaW51dGVcbiAgICAgICAgbSA6IDQ1LCAgICAgICAgIC8vIG1pbnV0ZXMgdG8gaG91clxuICAgICAgICBoIDogMjIsICAgICAgICAgLy8gaG91cnMgdG8gZGF5XG4gICAgICAgIGQgOiAyNiwgICAgICAgICAvLyBkYXlzIHRvIG1vbnRoXG4gICAgICAgIE0gOiAxMSAgICAgICAgICAvLyBtb250aHMgdG8geWVhclxuICAgIH07XG5cbiAgICAvLyBoZWxwZXIgZnVuY3Rpb24gZm9yIG1vbWVudC5mbi5mcm9tLCBtb21lbnQuZm4uZnJvbU5vdywgYW5kIG1vbWVudC5kdXJhdGlvbi5mbi5odW1hbml6ZVxuICAgIGZ1bmN0aW9uIHN1YnN0aXR1dGVUaW1lQWdvKHN0cmluZywgbnVtYmVyLCB3aXRob3V0U3VmZml4LCBpc0Z1dHVyZSwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUucmVsYXRpdmVUaW1lKG51bWJlciB8fCAxLCAhIXdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbGF0aXZlVGltZSQxIChwb3NOZWdEdXJhdGlvbiwgd2l0aG91dFN1ZmZpeCwgbG9jYWxlKSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IGNyZWF0ZUR1cmF0aW9uKHBvc05lZ0R1cmF0aW9uKS5hYnMoKTtcbiAgICAgICAgdmFyIHNlY29uZHMgID0gcm91bmQoZHVyYXRpb24uYXMoJ3MnKSk7XG4gICAgICAgIHZhciBtaW51dGVzICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdtJykpO1xuICAgICAgICB2YXIgaG91cnMgICAgPSByb3VuZChkdXJhdGlvbi5hcygnaCcpKTtcbiAgICAgICAgdmFyIGRheXMgICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ2QnKSk7XG4gICAgICAgIHZhciBtb250aHMgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdNJykpO1xuICAgICAgICB2YXIgeWVhcnMgICAgPSByb3VuZChkdXJhdGlvbi5hcygneScpKTtcblxuICAgICAgICB2YXIgYSA9IHNlY29uZHMgPD0gdGhyZXNob2xkcy5zcyAmJiBbJ3MnLCBzZWNvbmRzXSAgfHxcbiAgICAgICAgICAgICAgICBzZWNvbmRzIDwgdGhyZXNob2xkcy5zICAgJiYgWydzcycsIHNlY29uZHNdIHx8XG4gICAgICAgICAgICAgICAgbWludXRlcyA8PSAxICAgICAgICAgICAgICYmIFsnbSddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIG1pbnV0ZXMgPCB0aHJlc2hvbGRzLm0gICAmJiBbJ21tJywgbWludXRlc10gfHxcbiAgICAgICAgICAgICAgICBob3VycyAgIDw9IDEgICAgICAgICAgICAgJiYgWydoJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgaG91cnMgICA8IHRocmVzaG9sZHMuaCAgICYmIFsnaGgnLCBob3Vyc10gICB8fFxuICAgICAgICAgICAgICAgIGRheXMgICAgPD0gMSAgICAgICAgICAgICAmJiBbJ2QnXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBkYXlzICAgIDwgdGhyZXNob2xkcy5kICAgJiYgWydkZCcsIGRheXNdICAgIHx8XG4gICAgICAgICAgICAgICAgbW9udGhzICA8PSAxICAgICAgICAgICAgICYmIFsnTSddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIG1vbnRocyAgPCB0aHJlc2hvbGRzLk0gICAmJiBbJ01NJywgbW9udGhzXSAgfHxcbiAgICAgICAgICAgICAgICB5ZWFycyAgIDw9IDEgICAgICAgICAgICAgJiYgWyd5J10gICAgICAgICAgIHx8IFsneXknLCB5ZWFyc107XG5cbiAgICAgICAgYVsyXSA9IHdpdGhvdXRTdWZmaXg7XG4gICAgICAgIGFbM10gPSArcG9zTmVnRHVyYXRpb24gPiAwO1xuICAgICAgICBhWzRdID0gbG9jYWxlO1xuICAgICAgICByZXR1cm4gc3Vic3RpdHV0ZVRpbWVBZ28uYXBwbHkobnVsbCwgYSk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldCB0aGUgcm91bmRpbmcgZnVuY3Rpb24gZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuICAgIGZ1bmN0aW9uIGdldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nIChyb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgICAgIGlmIChyb3VuZGluZ0Z1bmN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByb3VuZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mKHJvdW5kaW5nRnVuY3Rpb24pID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByb3VuZCA9IHJvdW5kaW5nRnVuY3Rpb247XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldCBhIHRocmVzaG9sZCBmb3IgcmVsYXRpdmUgdGltZSBzdHJpbmdzXG4gICAgZnVuY3Rpb24gZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkICh0aHJlc2hvbGQsIGxpbWl0KSB7XG4gICAgICAgIGlmICh0aHJlc2hvbGRzW3RocmVzaG9sZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW1pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhyZXNob2xkc1t0aHJlc2hvbGRdO1xuICAgICAgICB9XG4gICAgICAgIHRocmVzaG9sZHNbdGhyZXNob2xkXSA9IGxpbWl0O1xuICAgICAgICBpZiAodGhyZXNob2xkID09PSAncycpIHtcbiAgICAgICAgICAgIHRocmVzaG9sZHMuc3MgPSBsaW1pdCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaHVtYW5pemUgKHdpdGhTdWZmaXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9jYWxlID0gdGhpcy5sb2NhbGVEYXRhKCk7XG4gICAgICAgIHZhciBvdXRwdXQgPSByZWxhdGl2ZVRpbWUkMSh0aGlzLCAhd2l0aFN1ZmZpeCwgbG9jYWxlKTtcblxuICAgICAgICBpZiAod2l0aFN1ZmZpeCkge1xuICAgICAgICAgICAgb3V0cHV0ID0gbG9jYWxlLnBhc3RGdXR1cmUoK3RoaXMsIG91dHB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbG9jYWxlLnBvc3Rmb3JtYXQob3V0cHV0KTtcbiAgICB9XG5cbiAgICB2YXIgYWJzJDEgPSBNYXRoLmFicztcblxuICAgIGZ1bmN0aW9uIHNpZ24oeCkge1xuICAgICAgICByZXR1cm4gKCh4ID4gMCkgLSAoeCA8IDApKSB8fCAreDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0lTT1N0cmluZyQxKCkge1xuICAgICAgICAvLyBmb3IgSVNPIHN0cmluZ3Mgd2UgZG8gbm90IHVzZSB0aGUgbm9ybWFsIGJ1YmJsaW5nIHJ1bGVzOlxuICAgICAgICAvLyAgKiBtaWxsaXNlY29uZHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIGhvdXJzXG4gICAgICAgIC8vICAqIGRheXMgZG8gbm90IGJ1YmJsZSBhdCBhbGxcbiAgICAgICAgLy8gICogbW9udGhzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSB5ZWFyc1xuICAgICAgICAvLyBUaGlzIGlzIGJlY2F1c2UgdGhlcmUgaXMgbm8gY29udGV4dC1mcmVlIGNvbnZlcnNpb24gYmV0d2VlbiBob3VycyBhbmQgZGF5c1xuICAgICAgICAvLyAodGhpbmsgb2YgY2xvY2sgY2hhbmdlcylcbiAgICAgICAgLy8gYW5kIGFsc28gbm90IGJldHdlZW4gZGF5cyBhbmQgbW9udGhzICgyOC0zMSBkYXlzIHBlciBtb250aClcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2Vjb25kcyA9IGFicyQxKHRoaXMuX21pbGxpc2Vjb25kcykgLyAxMDAwO1xuICAgICAgICB2YXIgZGF5cyAgICAgICAgID0gYWJzJDEodGhpcy5fZGF5cyk7XG4gICAgICAgIHZhciBtb250aHMgICAgICAgPSBhYnMkMSh0aGlzLl9tb250aHMpO1xuICAgICAgICB2YXIgbWludXRlcywgaG91cnMsIHllYXJzO1xuXG4gICAgICAgIC8vIDM2MDAgc2Vjb25kcyAtPiA2MCBtaW51dGVzIC0+IDEgaG91clxuICAgICAgICBtaW51dGVzICAgICAgICAgICA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgICAgIGhvdXJzICAgICAgICAgICAgID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICAgICAgc2Vjb25kcyAlPSA2MDtcbiAgICAgICAgbWludXRlcyAlPSA2MDtcblxuICAgICAgICAvLyAxMiBtb250aHMgLT4gMSB5ZWFyXG4gICAgICAgIHllYXJzICA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICAgICAgbW9udGhzICU9IDEyO1xuXG5cbiAgICAgICAgLy8gaW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL2RvcmRpbGxlL21vbWVudC1pc29kdXJhdGlvbi9ibG9iL21hc3Rlci9tb21lbnQuaXNvZHVyYXRpb24uanNcbiAgICAgICAgdmFyIFkgPSB5ZWFycztcbiAgICAgICAgdmFyIE0gPSBtb250aHM7XG4gICAgICAgIHZhciBEID0gZGF5cztcbiAgICAgICAgdmFyIGggPSBob3VycztcbiAgICAgICAgdmFyIG0gPSBtaW51dGVzO1xuICAgICAgICB2YXIgcyA9IHNlY29uZHMgPyBzZWNvbmRzLnRvRml4ZWQoMykucmVwbGFjZSgvXFwuPzArJC8sICcnKSA6ICcnO1xuICAgICAgICB2YXIgdG90YWwgPSB0aGlzLmFzU2Vjb25kcygpO1xuXG4gICAgICAgIGlmICghdG90YWwpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIHNhbWUgYXMgQyMncyAoTm9kYSkgYW5kIHB5dGhvbiAoaXNvZGF0ZSkuLi5cbiAgICAgICAgICAgIC8vIGJ1dCBub3Qgb3RoZXIgSlMgKGdvb2cuZGF0ZSlcbiAgICAgICAgICAgIHJldHVybiAnUDBEJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b3RhbFNpZ24gPSB0b3RhbCA8IDAgPyAnLScgOiAnJztcbiAgICAgICAgdmFyIHltU2lnbiA9IHNpZ24odGhpcy5fbW9udGhzKSAhPT0gc2lnbih0b3RhbCkgPyAnLScgOiAnJztcbiAgICAgICAgdmFyIGRheXNTaWduID0gc2lnbih0aGlzLl9kYXlzKSAhPT0gc2lnbih0b3RhbCkgPyAnLScgOiAnJztcbiAgICAgICAgdmFyIGhtc1NpZ24gPSBzaWduKHRoaXMuX21pbGxpc2Vjb25kcykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XG5cbiAgICAgICAgcmV0dXJuIHRvdGFsU2lnbiArICdQJyArXG4gICAgICAgICAgICAoWSA/IHltU2lnbiArIFkgKyAnWScgOiAnJykgK1xuICAgICAgICAgICAgKE0gPyB5bVNpZ24gKyBNICsgJ00nIDogJycpICtcbiAgICAgICAgICAgIChEID8gZGF5c1NpZ24gKyBEICsgJ0QnIDogJycpICtcbiAgICAgICAgICAgICgoaCB8fCBtIHx8IHMpID8gJ1QnIDogJycpICtcbiAgICAgICAgICAgIChoID8gaG1zU2lnbiArIGggKyAnSCcgOiAnJykgK1xuICAgICAgICAgICAgKG0gPyBobXNTaWduICsgbSArICdNJyA6ICcnKSArXG4gICAgICAgICAgICAocyA/IGhtc1NpZ24gKyBzICsgJ1MnIDogJycpO1xuICAgIH1cblxuICAgIHZhciBwcm90byQyID0gRHVyYXRpb24ucHJvdG90eXBlO1xuXG4gICAgcHJvdG8kMi5pc1ZhbGlkICAgICAgICA9IGlzVmFsaWQkMTtcbiAgICBwcm90byQyLmFicyAgICAgICAgICAgID0gYWJzO1xuICAgIHByb3RvJDIuYWRkICAgICAgICAgICAgPSBhZGQkMTtcbiAgICBwcm90byQyLnN1YnRyYWN0ICAgICAgID0gc3VidHJhY3QkMTtcbiAgICBwcm90byQyLmFzICAgICAgICAgICAgID0gYXM7XG4gICAgcHJvdG8kMi5hc01pbGxpc2Vjb25kcyA9IGFzTWlsbGlzZWNvbmRzO1xuICAgIHByb3RvJDIuYXNTZWNvbmRzICAgICAgPSBhc1NlY29uZHM7XG4gICAgcHJvdG8kMi5hc01pbnV0ZXMgICAgICA9IGFzTWludXRlcztcbiAgICBwcm90byQyLmFzSG91cnMgICAgICAgID0gYXNIb3VycztcbiAgICBwcm90byQyLmFzRGF5cyAgICAgICAgID0gYXNEYXlzO1xuICAgIHByb3RvJDIuYXNXZWVrcyAgICAgICAgPSBhc1dlZWtzO1xuICAgIHByb3RvJDIuYXNNb250aHMgICAgICAgPSBhc01vbnRocztcbiAgICBwcm90byQyLmFzWWVhcnMgICAgICAgID0gYXNZZWFycztcbiAgICBwcm90byQyLnZhbHVlT2YgICAgICAgID0gdmFsdWVPZiQxO1xuICAgIHByb3RvJDIuX2J1YmJsZSAgICAgICAgPSBidWJibGU7XG4gICAgcHJvdG8kMi5jbG9uZSAgICAgICAgICA9IGNsb25lJDE7XG4gICAgcHJvdG8kMi5nZXQgICAgICAgICAgICA9IGdldCQyO1xuICAgIHByb3RvJDIubWlsbGlzZWNvbmRzICAgPSBtaWxsaXNlY29uZHM7XG4gICAgcHJvdG8kMi5zZWNvbmRzICAgICAgICA9IHNlY29uZHM7XG4gICAgcHJvdG8kMi5taW51dGVzICAgICAgICA9IG1pbnV0ZXM7XG4gICAgcHJvdG8kMi5ob3VycyAgICAgICAgICA9IGhvdXJzO1xuICAgIHByb3RvJDIuZGF5cyAgICAgICAgICAgPSBkYXlzO1xuICAgIHByb3RvJDIud2Vla3MgICAgICAgICAgPSB3ZWVrcztcbiAgICBwcm90byQyLm1vbnRocyAgICAgICAgID0gbW9udGhzO1xuICAgIHByb3RvJDIueWVhcnMgICAgICAgICAgPSB5ZWFycztcbiAgICBwcm90byQyLmh1bWFuaXplICAgICAgID0gaHVtYW5pemU7XG4gICAgcHJvdG8kMi50b0lTT1N0cmluZyAgICA9IHRvSVNPU3RyaW5nJDE7XG4gICAgcHJvdG8kMi50b1N0cmluZyAgICAgICA9IHRvSVNPU3RyaW5nJDE7XG4gICAgcHJvdG8kMi50b0pTT04gICAgICAgICA9IHRvSVNPU3RyaW5nJDE7XG4gICAgcHJvdG8kMi5sb2NhbGUgICAgICAgICA9IGxvY2FsZTtcbiAgICBwcm90byQyLmxvY2FsZURhdGEgICAgID0gbG9jYWxlRGF0YTtcblxuICAgIHByb3RvJDIudG9Jc29TdHJpbmcgPSBkZXByZWNhdGUoJ3RvSXNvU3RyaW5nKCkgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSB0b0lTT1N0cmluZygpIGluc3RlYWQgKG5vdGljZSB0aGUgY2FwaXRhbHMpJywgdG9JU09TdHJpbmckMSk7XG4gICAgcHJvdG8kMi5sYW5nID0gbGFuZztcblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdYJywgMCwgMCwgJ3VuaXgnKTtcbiAgICBhZGRGb3JtYXRUb2tlbigneCcsIDAsIDAsICd2YWx1ZU9mJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCd4JywgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1gnLCBtYXRjaFRpbWVzdGFtcCk7XG4gICAgYWRkUGFyc2VUb2tlbignWCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShwYXJzZUZsb2F0KGlucHV0LCAxMCkgKiAxMDAwKTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCd4JywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHRvSW50KGlucHV0KSk7XG4gICAgfSk7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5cblxuICAgIGhvb2tzLnZlcnNpb24gPSAnMi4yMi4yJztcblxuICAgIHNldEhvb2tDYWxsYmFjayhjcmVhdGVMb2NhbCk7XG5cbiAgICBob29rcy5mbiAgICAgICAgICAgICAgICAgICAgPSBwcm90bztcbiAgICBob29rcy5taW4gICAgICAgICAgICAgICAgICAgPSBtaW47XG4gICAgaG9va3MubWF4ICAgICAgICAgICAgICAgICAgID0gbWF4O1xuICAgIGhvb2tzLm5vdyAgICAgICAgICAgICAgICAgICA9IG5vdztcbiAgICBob29rcy51dGMgICAgICAgICAgICAgICAgICAgPSBjcmVhdGVVVEM7XG4gICAgaG9va3MudW5peCAgICAgICAgICAgICAgICAgID0gY3JlYXRlVW5peDtcbiAgICBob29rcy5tb250aHMgICAgICAgICAgICAgICAgPSBsaXN0TW9udGhzO1xuICAgIGhvb2tzLmlzRGF0ZSAgICAgICAgICAgICAgICA9IGlzRGF0ZTtcbiAgICBob29rcy5sb2NhbGUgICAgICAgICAgICAgICAgPSBnZXRTZXRHbG9iYWxMb2NhbGU7XG4gICAgaG9va3MuaW52YWxpZCAgICAgICAgICAgICAgID0gY3JlYXRlSW52YWxpZDtcbiAgICBob29rcy5kdXJhdGlvbiAgICAgICAgICAgICAgPSBjcmVhdGVEdXJhdGlvbjtcbiAgICBob29rcy5pc01vbWVudCAgICAgICAgICAgICAgPSBpc01vbWVudDtcbiAgICBob29rcy53ZWVrZGF5cyAgICAgICAgICAgICAgPSBsaXN0V2Vla2RheXM7XG4gICAgaG9va3MucGFyc2Vab25lICAgICAgICAgICAgID0gY3JlYXRlSW5ab25lO1xuICAgIGhvb2tzLmxvY2FsZURhdGEgICAgICAgICAgICA9IGdldExvY2FsZTtcbiAgICBob29rcy5pc0R1cmF0aW9uICAgICAgICAgICAgPSBpc0R1cmF0aW9uO1xuICAgIGhvb2tzLm1vbnRoc1Nob3J0ICAgICAgICAgICA9IGxpc3RNb250aHNTaG9ydDtcbiAgICBob29rcy53ZWVrZGF5c01pbiAgICAgICAgICAgPSBsaXN0V2Vla2RheXNNaW47XG4gICAgaG9va3MuZGVmaW5lTG9jYWxlICAgICAgICAgID0gZGVmaW5lTG9jYWxlO1xuICAgIGhvb2tzLnVwZGF0ZUxvY2FsZSAgICAgICAgICA9IHVwZGF0ZUxvY2FsZTtcbiAgICBob29rcy5sb2NhbGVzICAgICAgICAgICAgICAgPSBsaXN0TG9jYWxlcztcbiAgICBob29rcy53ZWVrZGF5c1Nob3J0ICAgICAgICAgPSBsaXN0V2Vla2RheXNTaG9ydDtcbiAgICBob29rcy5ub3JtYWxpemVVbml0cyAgICAgICAgPSBub3JtYWxpemVVbml0cztcbiAgICBob29rcy5yZWxhdGl2ZVRpbWVSb3VuZGluZyAgPSBnZXRTZXRSZWxhdGl2ZVRpbWVSb3VuZGluZztcbiAgICBob29rcy5yZWxhdGl2ZVRpbWVUaHJlc2hvbGQgPSBnZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQ7XG4gICAgaG9va3MuY2FsZW5kYXJGb3JtYXQgICAgICAgID0gZ2V0Q2FsZW5kYXJGb3JtYXQ7XG4gICAgaG9va3MucHJvdG90eXBlICAgICAgICAgICAgID0gcHJvdG87XG5cbiAgICAvLyBjdXJyZW50bHkgSFRNTDUgaW5wdXQgdHlwZSBvbmx5IHN1cHBvcnRzIDI0LWhvdXIgZm9ybWF0c1xuICAgIGhvb2tzLkhUTUw1X0ZNVCA9IHtcbiAgICAgICAgREFURVRJTUVfTE9DQUw6ICdZWVlZLU1NLUREVEhIOm1tJywgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJkYXRldGltZS1sb2NhbFwiIC8+XG4gICAgICAgIERBVEVUSU1FX0xPQ0FMX1NFQ09ORFM6ICdZWVlZLU1NLUREVEhIOm1tOnNzJywgIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZXRpbWUtbG9jYWxcIiBzdGVwPVwiMVwiIC8+XG4gICAgICAgIERBVEVUSU1FX0xPQ0FMX01TOiAnWVlZWS1NTS1ERFRISDptbTpzcy5TU1MnLCAgIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZXRpbWUtbG9jYWxcIiBzdGVwPVwiMC4wMDFcIiAvPlxuICAgICAgICBEQVRFOiAnWVlZWS1NTS1ERCcsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cImRhdGVcIiAvPlxuICAgICAgICBUSU1FOiAnSEg6bW0nLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cInRpbWVcIiAvPlxuICAgICAgICBUSU1FX1NFQ09ORFM6ICdISDptbTpzcycsICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cInRpbWVcIiBzdGVwPVwiMVwiIC8+XG4gICAgICAgIFRJTUVfTVM6ICdISDptbTpzcy5TU1MnLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwidGltZVwiIHN0ZXA9XCIwLjAwMVwiIC8+XG4gICAgICAgIFdFRUs6ICdZWVlZLVtXXVdXJywgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwid2Vla1wiIC8+XG4gICAgICAgIE1PTlRIOiAnWVlZWS1NTScgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwibW9udGhcIiAvPlxuICAgIH07XG5cbiAgICByZXR1cm4gaG9va3M7XG5cbn0pKSk7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDExNykobW9kdWxlKSkpXG5cbi8qKiovIH0pLFxuLyogMTE3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdGlmKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn07XHJcblxuXG4vKioqLyB9KSxcbi8qIDExOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5mdW5jdGlvbiB3ZWJwYWNrRW1wdHlDb250ZXh0KHJlcSkge1xuXHR0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgcmVxICsgXCInLlwiKTtcbn1cbndlYnBhY2tFbXB0eUNvbnRleHQua2V5cyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gW107IH07XG53ZWJwYWNrRW1wdHlDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrRW1wdHlDb250ZXh0O1xubW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrRW1wdHlDb250ZXh0O1xud2VicGFja0VtcHR5Q29udGV4dC5pZCA9IDExODtcblxuLyoqKi8gfSksXG4vKiAxMTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbi8qIGVzbGludC1kaXNhYmxlIHJlcXVpcmUtanNkb2MgKi9cblxudmFyIF9ybmc7XG5cbnZhciBnbG9iYWxWYXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogbnVsbDtcblxuaWYgKGdsb2JhbFZhciAmJiBnbG9iYWxWYXIuY3J5cHRvICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgLy8gV0hBVFdHIGNyeXB0by1iYXNlZCBSTkcgLSBodHRwOi8vd2lraS53aGF0d2cub3JnL3dpa2kvQ3J5cHRvXG4gIC8vIE1vZGVyYXRlbHkgZmFzdCwgaGlnaCBxdWFsaXR5XG4gIHZhciBfcm5kczggPSBuZXcgVWludDhBcnJheSgxNik7XG4gIF9ybmcgPSBmdW5jdGlvbiB3aGF0d2dSTkcoKSB7XG4gICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhfcm5kczgpO1xuICAgIHJldHVybiBfcm5kczg7XG4gIH07XG59XG5cbmlmICghX3JuZykge1xuICAvLyBNYXRoLnJhbmRvbSgpLWJhc2VkIChSTkcpXG4gIC8vXG4gIC8vIElmIGFsbCBlbHNlIGZhaWxzLCB1c2UgTWF0aC5yYW5kb20oKS4gIEl0J3MgZmFzdCwgYnV0IGlzIG9mIHVuc3BlY2lmaWVkXG4gIC8vIHF1YWxpdHkuXG4gIHZhciBfcm5kcyA9IG5ldyBBcnJheSgxNik7XG4gIF9ybmcgPSBmdW5jdGlvbiBfcm5nKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCByOyBpIDwgMTY7IGkrKykge1xuICAgICAgaWYgKChpICYgMHgwMykgPT09IDApIHIgPSBNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDA7XG4gICAgICBfcm5kc1tpXSA9IHIgPj4+ICgoaSAmIDB4MDMpIDw8IDMpICYgMHhmZjtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JuZHM7XG4gIH07XG59XG5cbi8vICAgICB1dWlkLmpzXG4vL1xuLy8gICAgIENvcHlyaWdodCAoYykgMjAxMC0yMDEyIFJvYmVydCBLaWVmZmVyXG4vLyAgICAgTUlUIExpY2Vuc2UgLSBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cbi8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuICBXZSBmZWF0dXJlXG4vLyBkZXRlY3QgdG8gZGV0ZXJtaW5lIHRoZSBiZXN0IFJORyBzb3VyY2UsIG5vcm1hbGl6aW5nIHRvIGEgZnVuY3Rpb24gdGhhdFxuLy8gcmV0dXJucyAxMjgtYml0cyBvZiByYW5kb21uZXNzLCBzaW5jZSB0aGF0J3Mgd2hhdCdzIHVzdWFsbHkgcmVxdWlyZWRcblxuLy92YXIgX3JuZyA9IHJlcXVpcmUoJy4vcm5nJyk7XG5cbi8vIE1hcHMgZm9yIG51bWJlciA8LT4gaGV4IHN0cmluZyBjb252ZXJzaW9uXG52YXIgX2J5dGVUb0hleCA9IFtdO1xudmFyIF9oZXhUb0J5dGUgPSB7fTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgX2J5dGVUb0hleFtpXSA9IChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSk7XG4gIF9oZXhUb0J5dGVbX2J5dGVUb0hleFtpXV0gPSBpO1xufVxuXG4vLyAqKmBwYXJzZSgpYCAtIFBhcnNlIGEgVVVJRCBpbnRvIGl0J3MgY29tcG9uZW50IGJ5dGVzKipcbmZ1bmN0aW9uIHBhcnNlKHMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwLFxuICAgICAgaWkgPSAwO1xuXG4gIGJ1ZiA9IGJ1ZiB8fCBbXTtcbiAgcy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1swLTlhLWZdezJ9L2csIGZ1bmN0aW9uIChvY3QpIHtcbiAgICBpZiAoaWkgPCAxNikge1xuICAgICAgLy8gRG9uJ3Qgb3ZlcmZsb3chXG4gICAgICBidWZbaSArIGlpKytdID0gX2hleFRvQnl0ZVtvY3RdO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gWmVybyBvdXQgcmVtYWluaW5nIGJ5dGVzIGlmIHN0cmluZyB3YXMgc2hvcnRcbiAgd2hpbGUgKGlpIDwgMTYpIHtcbiAgICBidWZbaSArIGlpKytdID0gMDtcbiAgfVxuXG4gIHJldHVybiBidWY7XG59XG5cbi8vICoqYHVucGFyc2UoKWAgLSBDb252ZXJ0IFVVSUQgYnl0ZSBhcnJheSAoYWxhIHBhcnNlKCkpIGludG8gYSBzdHJpbmcqKlxuZnVuY3Rpb24gdW5wYXJzZShidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IG9mZnNldCB8fCAwLFxuICAgICAgYnRoID0gX2J5dGVUb0hleDtcbiAgcmV0dXJuIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgKyBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgJy0nICsgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgKyBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV07XG59XG5cbi8vICoqYHYxKClgIC0gR2VuZXJhdGUgdGltZS1iYXNlZCBVVUlEKipcbi8vXG4vLyBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vTGlvc0svVVVJRC5qc1xuLy8gYW5kIGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS91dWlkLmh0bWxcblxuLy8gcmFuZG9tICMncyB3ZSBuZWVkIHRvIGluaXQgbm9kZSBhbmQgY2xvY2tzZXFcbnZhciBfc2VlZEJ5dGVzID0gX3JuZygpO1xuXG4vLyBQZXIgNC41LCBjcmVhdGUgYW5kIDQ4LWJpdCBub2RlIGlkLCAoNDcgcmFuZG9tIGJpdHMgKyBtdWx0aWNhc3QgYml0ID0gMSlcbnZhciBfbm9kZUlkID0gW19zZWVkQnl0ZXNbMF0gfCAweDAxLCBfc2VlZEJ5dGVzWzFdLCBfc2VlZEJ5dGVzWzJdLCBfc2VlZEJ5dGVzWzNdLCBfc2VlZEJ5dGVzWzRdLCBfc2VlZEJ5dGVzWzVdXTtcblxuLy8gUGVyIDQuMi4yLCByYW5kb21pemUgKDE0IGJpdCkgY2xvY2tzZXFcbnZhciBfY2xvY2tzZXEgPSAoX3NlZWRCeXRlc1s2XSA8PCA4IHwgX3NlZWRCeXRlc1s3XSkgJiAweDNmZmY7XG5cbi8vIFByZXZpb3VzIHV1aWQgY3JlYXRpb24gdGltZVxudmFyIF9sYXN0TVNlY3MgPSAwLFxuICAgIF9sYXN0TlNlY3MgPSAwO1xuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2Jyb29mYS9ub2RlLXV1aWQgZm9yIEFQSSBkZXRhaWxzXG5mdW5jdGlvbiB2MShvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcbiAgdmFyIGIgPSBidWYgfHwgW107XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIGNsb2Nrc2VxID0gb3B0aW9ucy5jbG9ja3NlcSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jbG9ja3NlcSA6IF9jbG9ja3NlcTtcblxuICAvLyBVVUlEIHRpbWVzdGFtcHMgYXJlIDEwMCBuYW5vLXNlY29uZCB1bml0cyBzaW5jZSB0aGUgR3JlZ29yaWFuIGVwb2NoLFxuICAvLyAoMTU4Mi0xMC0xNSAwMDowMCkuICBKU051bWJlcnMgYXJlbid0IHByZWNpc2UgZW5vdWdoIGZvciB0aGlzLCBzb1xuICAvLyB0aW1lIGlzIGhhbmRsZWQgaW50ZXJuYWxseSBhcyAnbXNlY3MnIChpbnRlZ2VyIG1pbGxpc2Vjb25kcykgYW5kICduc2VjcydcbiAgLy8gKDEwMC1uYW5vc2Vjb25kcyBvZmZzZXQgZnJvbSBtc2Vjcykgc2luY2UgdW5peCBlcG9jaCwgMTk3MC0wMS0wMSAwMDowMC5cbiAgdmFyIG1zZWNzID0gb3B0aW9ucy5tc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tc2VjcyA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gIC8vIFBlciA0LjIuMS4yLCB1c2UgY291bnQgb2YgdXVpZCdzIGdlbmVyYXRlZCBkdXJpbmcgdGhlIGN1cnJlbnQgY2xvY2tcbiAgLy8gY3ljbGUgdG8gc2ltdWxhdGUgaGlnaGVyIHJlc29sdXRpb24gY2xvY2tcbiAgdmFyIG5zZWNzID0gb3B0aW9ucy5uc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uc2VjcyA6IF9sYXN0TlNlY3MgKyAxO1xuXG4gIC8vIFRpbWUgc2luY2UgbGFzdCB1dWlkIGNyZWF0aW9uIChpbiBtc2VjcylcbiAgdmFyIGR0ID0gbXNlY3MgLSBfbGFzdE1TZWNzICsgKG5zZWNzIC0gX2xhc3ROU2VjcykgLyAxMDAwMDtcblxuICAvLyBQZXIgNC4yLjEuMiwgQnVtcCBjbG9ja3NlcSBvbiBjbG9jayByZWdyZXNzaW9uXG4gIGlmIChkdCA8IDAgJiYgb3B0aW9ucy5jbG9ja3NlcSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2xvY2tzZXEgPSBjbG9ja3NlcSArIDEgJiAweDNmZmY7XG4gIH1cblxuICAvLyBSZXNldCBuc2VjcyBpZiBjbG9jayByZWdyZXNzZXMgKG5ldyBjbG9ja3NlcSkgb3Igd2UndmUgbW92ZWQgb250byBhIG5ld1xuICAvLyB0aW1lIGludGVydmFsXG4gIGlmICgoZHQgPCAwIHx8IG1zZWNzID4gX2xhc3RNU2VjcykgJiYgb3B0aW9ucy5uc2VjcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbnNlY3MgPSAwO1xuICB9XG5cbiAgLy8gUGVyIDQuMi4xLjIgVGhyb3cgZXJyb3IgaWYgdG9vIG1hbnkgdXVpZHMgYXJlIHJlcXVlc3RlZFxuICBpZiAobnNlY3MgPj0gMTAwMDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1dWlkLnYxKCk6IENhbid0IGNyZWF0ZSBtb3JlIHRoYW4gMTBNIHV1aWRzL3NlY1wiKTtcbiAgfVxuXG4gIF9sYXN0TVNlY3MgPSBtc2VjcztcbiAgX2xhc3ROU2VjcyA9IG5zZWNzO1xuICBfY2xvY2tzZXEgPSBjbG9ja3NlcTtcblxuICAvLyBQZXIgNC4xLjQgLSBDb252ZXJ0IGZyb20gdW5peCBlcG9jaCB0byBHcmVnb3JpYW4gZXBvY2hcbiAgbXNlY3MgKz0gMTIyMTkyOTI4MDAwMDA7XG5cbiAgLy8gYHRpbWVfbG93YFxuICB2YXIgdGwgPSAoKG1zZWNzICYgMHhmZmZmZmZmKSAqIDEwMDAwICsgbnNlY3MpICUgMHgxMDAwMDAwMDA7XG4gIGJbaSsrXSA9IHRsID4+PiAyNCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsID4+PiAxNiAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdGwgJiAweGZmO1xuXG4gIC8vIGB0aW1lX21pZGBcbiAgdmFyIHRtaCA9IG1zZWNzIC8gMHgxMDAwMDAwMDAgKiAxMDAwMCAmIDB4ZmZmZmZmZjtcbiAgYltpKytdID0gdG1oID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdG1oICYgMHhmZjtcblxuICAvLyBgdGltZV9oaWdoX2FuZF92ZXJzaW9uYFxuICBiW2krK10gPSB0bWggPj4+IDI0ICYgMHhmIHwgMHgxMDsgLy8gaW5jbHVkZSB2ZXJzaW9uXG4gIGJbaSsrXSA9IHRtaCA+Pj4gMTYgJiAweGZmO1xuXG4gIC8vIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYCAoUGVyIDQuMi4yIC0gaW5jbHVkZSB2YXJpYW50KVxuICBiW2krK10gPSBjbG9ja3NlcSA+Pj4gOCB8IDB4ODA7XG5cbiAgLy8gYGNsb2NrX3NlcV9sb3dgXG4gIGJbaSsrXSA9IGNsb2Nrc2VxICYgMHhmZjtcblxuICAvLyBgbm9kZWBcbiAgdmFyIG5vZGUgPSBvcHRpb25zLm5vZGUgfHwgX25vZGVJZDtcbiAgZm9yICh2YXIgbiA9IDA7IG4gPCA2OyBuKyspIHtcbiAgICBiW2kgKyBuXSA9IG5vZGVbbl07XG4gIH1cblxuICByZXR1cm4gYnVmID8gYnVmIDogdW5wYXJzZShiKTtcbn1cblxuLy8gKipgdjQoKWAgLSBHZW5lcmF0ZSByYW5kb20gVVVJRCoqXG5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYnJvb2ZhL25vZGUtdXVpZCBmb3IgQVBJIGRldGFpbHNcbmZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIC8vIERlcHJlY2F0ZWQgLSAnZm9ybWF0JyBhcmd1bWVudCwgYXMgc3VwcG9ydGVkIGluIHYxLjJcbiAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09ICdzdHJpbmcnKSB7XG4gICAgYnVmID0gb3B0aW9ucyA9PSAnYmluYXJ5JyA/IG5ldyBBcnJheSgxNikgOiBudWxsO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IF9ybmcpKCk7XG5cbiAgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuICBybmRzWzZdID0gcm5kc1s2XSAmIDB4MGYgfCAweDQwO1xuICBybmRzWzhdID0gcm5kc1s4XSAmIDB4M2YgfCAweDgwO1xuXG4gIC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuICBpZiAoYnVmKSB7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IDE2OyBpaSsrKSB7XG4gICAgICBidWZbaSArIGlpXSA9IHJuZHNbaWldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWYgfHwgdW5wYXJzZShybmRzKTtcbn1cblxuLy8gRXhwb3J0IHB1YmxpYyBBUElcbnZhciB1dWlkID0gdjQ7XG51dWlkLnYxID0gdjE7XG51dWlkLnY0ID0gdjQ7XG51dWlkLnBhcnNlID0gcGFyc2U7XG51dWlkLnVucGFyc2UgPSB1bnBhcnNlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHV1aWQ7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXygxMjApKSlcblxuLyoqKi8gfSksXG4vKiAxMjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cbi8qKiovIH0pLFxuLyogMTIxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8vIHV0aWxzXG5leHBvcnRzLnV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuZXhwb3J0cy5ET011dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjIpO1xuXG4vLyBkYXRhXG5leHBvcnRzLkRhdGFTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbmV4cG9ydHMuRGF0YVZpZXcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxKTtcbmV4cG9ydHMuUXVldWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyKTtcblxuLy8gTmV0d29ya1xuZXhwb3J0cy5OZXR3b3JrID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjQpO1xuZXhwb3J0cy5uZXR3b3JrID0ge1xuICBJbWFnZXM6IF9fd2VicGFja19yZXF1aXJlX18oNzYpLFxuICBkb3RwYXJzZXI6IF9fd2VicGFja19yZXF1aXJlX18oNzQpLFxuICBnZXBoaVBhcnNlcjogX193ZWJwYWNrX3JlcXVpcmVfXyg3NSksXG4gIGFsbE9wdGlvbnM6IF9fd2VicGFja19yZXF1aXJlX18oODQpXG59O1xuZXhwb3J0cy5uZXR3b3JrLmNvbnZlcnREb3QgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgcmV0dXJuIGV4cG9ydHMubmV0d29yay5kb3RwYXJzZXIuRE9UVG9HcmFwaChpbnB1dCk7XG59O1xuZXhwb3J0cy5uZXR3b3JrLmNvbnZlcnRHZXBoaSA9IGZ1bmN0aW9uIChpbnB1dCwgb3B0aW9ucykge1xuICByZXR1cm4gZXhwb3J0cy5uZXR3b3JrLmdlcGhpUGFyc2VyLnBhcnNlR2VwaGkoaW5wdXQsIG9wdGlvbnMpO1xufTtcblxuLy8gYnVuZGxlZCBleHRlcm5hbCBsaWJyYXJpZXNcbmV4cG9ydHMubW9tZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MSk7XG5leHBvcnRzLkhhbW1lciA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xuZXhwb3J0cy5rZXljaGFybSA9IF9fd2VicGFja19yZXF1aXJlX18oNTIpO1xuXG4vKioqLyB9KSxcbi8qIDEyMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vLyBET00gdXRpbGl0eSBtZXRob2RzXG5cbi8qKlxuICogdGhpcyBwcmVwYXJlcyB0aGUgSlNPTiBjb250YWluZXIgZm9yIGFsbG9jYXRpbmcgU1ZHIGVsZW1lbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gSlNPTmNvbnRhaW5lclxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5wcmVwYXJlRWxlbWVudHMgPSBmdW5jdGlvbiAoSlNPTmNvbnRhaW5lcikge1xuICAvLyBjbGVhbnVwIHRoZSByZWR1bmRhbnQgc3ZnRWxlbWVudHM7XG4gIGZvciAodmFyIGVsZW1lbnRUeXBlIGluIEpTT05jb250YWluZXIpIHtcbiAgICBpZiAoSlNPTmNvbnRhaW5lci5oYXNPd25Qcm9wZXJ0eShlbGVtZW50VHlwZSkpIHtcbiAgICAgIEpTT05jb250YWluZXJbZWxlbWVudFR5cGVdLnJlZHVuZGFudCA9IEpTT05jb250YWluZXJbZWxlbWVudFR5cGVdLnVzZWQ7XG4gICAgICBKU09OY29udGFpbmVyW2VsZW1lbnRUeXBlXS51c2VkID0gW107XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIHRoaXMgY2xlYW5zIHVwIGFsbCB0aGUgdW51c2VkIFNWRyBlbGVtZW50cy4gQnkgYXNraW5nIGZvciB0aGUgcGFyZW50Tm9kZSwgd2Ugb25seSBuZWVkIHRvIHN1cHBseSB0aGUgSlNPTiBjb250YWluZXIgZnJvbVxuICogd2hpY2ggdG8gcmVtb3ZlIHRoZSByZWR1bmRhbnQgZWxlbWVudHMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IEpTT05jb250YWluZXJcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuY2xlYW51cEVsZW1lbnRzID0gZnVuY3Rpb24gKEpTT05jb250YWluZXIpIHtcbiAgLy8gY2xlYW51cCB0aGUgcmVkdW5kYW50IHN2Z0VsZW1lbnRzO1xuICBmb3IgKHZhciBlbGVtZW50VHlwZSBpbiBKU09OY29udGFpbmVyKSB7XG4gICAgaWYgKEpTT05jb250YWluZXIuaGFzT3duUHJvcGVydHkoZWxlbWVudFR5cGUpKSB7XG4gICAgICBpZiAoSlNPTmNvbnRhaW5lcltlbGVtZW50VHlwZV0ucmVkdW5kYW50KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgSlNPTmNvbnRhaW5lcltlbGVtZW50VHlwZV0ucmVkdW5kYW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgSlNPTmNvbnRhaW5lcltlbGVtZW50VHlwZV0ucmVkdW5kYW50W2ldLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoSlNPTmNvbnRhaW5lcltlbGVtZW50VHlwZV0ucmVkdW5kYW50W2ldKTtcbiAgICAgICAgfVxuICAgICAgICBKU09OY29udGFpbmVyW2VsZW1lbnRUeXBlXS5yZWR1bmRhbnQgPSBbXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRW5zdXJlcyB0aGF0IGFsbCBlbGVtZW50cyBhcmUgcmVtb3ZlZCBmaXJzdCB1cCBzbyB0aGV5IGNhbiBiZSByZWNyZWF0ZWQgY2xlYW5seVxuICogQHBhcmFtIHtPYmplY3R9IEpTT05jb250YWluZXJcbiAqL1xuZXhwb3J0cy5yZXNldEVsZW1lbnRzID0gZnVuY3Rpb24gKEpTT05jb250YWluZXIpIHtcbiAgZXhwb3J0cy5wcmVwYXJlRWxlbWVudHMoSlNPTmNvbnRhaW5lcik7XG4gIGV4cG9ydHMuY2xlYW51cEVsZW1lbnRzKEpTT05jb250YWluZXIpO1xuICBleHBvcnRzLnByZXBhcmVFbGVtZW50cyhKU09OY29udGFpbmVyKTtcbn07XG5cbi8qKlxuICogQWxsb2NhdGUgb3IgZ2VuZXJhdGUgYW4gU1ZHIGVsZW1lbnQgaWYgbmVlZGVkLiBTdG9yZSBhIHJlZmVyZW5jZSB0byBpdCBpbiB0aGUgSlNPTiBjb250YWluZXIgYW5kIGRyYXcgaXQgaW4gdGhlIHN2Z0NvbnRhaW5lclxuICogdGhlIEpTT04gY29udGFpbmVyIGFuZCB0aGUgU1ZHIGNvbnRhaW5lciBoYXZlIHRvIGJlIHN1cHBsaWVkIHNvIG90aGVyIHN2ZyBjb250YWluZXJzIChsaWtlIHRoZSBsZWdlbmQpIGNhbiB1c2UgdGhpcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudFR5cGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBKU09OY29udGFpbmVyXG4gKiBAcGFyYW0ge09iamVjdH0gc3ZnQ29udGFpbmVyXG4gKiBAcmV0dXJucyB7RWxlbWVudH1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuZ2V0U1ZHRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50VHlwZSwgSlNPTmNvbnRhaW5lciwgc3ZnQ29udGFpbmVyKSB7XG4gIHZhciBlbGVtZW50O1xuICAvLyBhbGxvY2F0ZSBTVkcgZWxlbWVudCwgaWYgaXQgZG9lc250IHlldCBleGlzdCwgY3JlYXRlIG9uZS5cbiAgaWYgKEpTT05jb250YWluZXIuaGFzT3duUHJvcGVydHkoZWxlbWVudFR5cGUpKSB7XG4gICAgLy8gdGhpcyBlbGVtZW50IGhhcyBiZWVuIGNyZWF0ZWQgYmVmb3JlXG4gICAgLy8gY2hlY2sgaWYgdGhlcmUgaXMgYW4gcmVkdW5kYW50IGVsZW1lbnRcbiAgICBpZiAoSlNPTmNvbnRhaW5lcltlbGVtZW50VHlwZV0ucmVkdW5kYW50Lmxlbmd0aCA+IDApIHtcbiAgICAgIGVsZW1lbnQgPSBKU09OY29udGFpbmVyW2VsZW1lbnRUeXBlXS5yZWR1bmRhbnRbMF07XG4gICAgICBKU09OY29udGFpbmVyW2VsZW1lbnRUeXBlXS5yZWR1bmRhbnQuc2hpZnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY3JlYXRlIGEgbmV3IGVsZW1lbnQgYW5kIGFkZCBpdCB0byB0aGUgU1ZHXG4gICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIGVsZW1lbnRUeXBlKTtcbiAgICAgIHN2Z0NvbnRhaW5lci5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gY3JlYXRlIGEgbmV3IGVsZW1lbnQgYW5kIGFkZCBpdCB0byB0aGUgU1ZHLCBhbHNvIGNyZWF0ZSBhIG5ldyBvYmplY3QgaW4gdGhlIHN2Z0VsZW1lbnRzIHRvIGtlZXAgdHJhY2sgb2YgaXQuXG4gICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCBlbGVtZW50VHlwZSk7XG4gICAgSlNPTmNvbnRhaW5lcltlbGVtZW50VHlwZV0gPSB7IHVzZWQ6IFtdLCByZWR1bmRhbnQ6IFtdIH07XG4gICAgc3ZnQ29udGFpbmVyLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICB9XG4gIEpTT05jb250YWluZXJbZWxlbWVudFR5cGVdLnVzZWQucHVzaChlbGVtZW50KTtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG4vKipcbiAqIEFsbG9jYXRlIG9yIGdlbmVyYXRlIGFuIFNWRyBlbGVtZW50IGlmIG5lZWRlZC4gU3RvcmUgYSByZWZlcmVuY2UgdG8gaXQgaW4gdGhlIEpTT04gY29udGFpbmVyIGFuZCBkcmF3IGl0IGluIHRoZSBzdmdDb250YWluZXJcbiAqIHRoZSBKU09OIGNvbnRhaW5lciBhbmQgdGhlIFNWRyBjb250YWluZXIgaGF2ZSB0byBiZSBzdXBwbGllZCBzbyBvdGhlciBzdmcgY29udGFpbmVycyAobGlrZSB0aGUgbGVnZW5kKSBjYW4gdXNlIHRoaXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnRUeXBlXG4gKiBAcGFyYW0ge09iamVjdH0gSlNPTmNvbnRhaW5lclxuICogQHBhcmFtIHtFbGVtZW50fSBET01Db250YWluZXJcbiAqIEBwYXJhbSB7RWxlbWVudH0gaW5zZXJ0QmVmb3JlXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZXhwb3J0cy5nZXRET01FbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnRUeXBlLCBKU09OY29udGFpbmVyLCBET01Db250YWluZXIsIGluc2VydEJlZm9yZSkge1xuICB2YXIgZWxlbWVudDtcbiAgLy8gYWxsb2NhdGUgRE9NIGVsZW1lbnQsIGlmIGl0IGRvZXNudCB5ZXQgZXhpc3QsIGNyZWF0ZSBvbmUuXG4gIGlmIChKU09OY29udGFpbmVyLmhhc093blByb3BlcnR5KGVsZW1lbnRUeXBlKSkge1xuICAgIC8vIHRoaXMgZWxlbWVudCBoYXMgYmVlbiBjcmVhdGVkIGJlZm9yZVxuICAgIC8vIGNoZWNrIGlmIHRoZXJlIGlzIGFuIHJlZHVuZGFudCBlbGVtZW50XG4gICAgaWYgKEpTT05jb250YWluZXJbZWxlbWVudFR5cGVdLnJlZHVuZGFudC5sZW5ndGggPiAwKSB7XG4gICAgICBlbGVtZW50ID0gSlNPTmNvbnRhaW5lcltlbGVtZW50VHlwZV0ucmVkdW5kYW50WzBdO1xuICAgICAgSlNPTmNvbnRhaW5lcltlbGVtZW50VHlwZV0ucmVkdW5kYW50LnNoaWZ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNyZWF0ZSBhIG5ldyBlbGVtZW50IGFuZCBhZGQgaXQgdG8gdGhlIFNWR1xuICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZWxlbWVudFR5cGUpO1xuICAgICAgaWYgKGluc2VydEJlZm9yZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIERPTUNvbnRhaW5lci5pbnNlcnRCZWZvcmUoZWxlbWVudCwgaW5zZXJ0QmVmb3JlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIERPTUNvbnRhaW5lci5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gY3JlYXRlIGEgbmV3IGVsZW1lbnQgYW5kIGFkZCBpdCB0byB0aGUgU1ZHLCBhbHNvIGNyZWF0ZSBhIG5ldyBvYmplY3QgaW4gdGhlIHN2Z0VsZW1lbnRzIHRvIGtlZXAgdHJhY2sgb2YgaXQuXG4gICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZWxlbWVudFR5cGUpO1xuICAgIEpTT05jb250YWluZXJbZWxlbWVudFR5cGVdID0geyB1c2VkOiBbXSwgcmVkdW5kYW50OiBbXSB9O1xuICAgIGlmIChpbnNlcnRCZWZvcmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgRE9NQ29udGFpbmVyLmluc2VydEJlZm9yZShlbGVtZW50LCBpbnNlcnRCZWZvcmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBET01Db250YWluZXIuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgfVxuICB9XG4gIEpTT05jb250YWluZXJbZWxlbWVudFR5cGVdLnVzZWQucHVzaChlbGVtZW50KTtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG4vKipcbiAqIERyYXcgYSBwb2ludCBvYmplY3QuIFRoaXMgaXMgYSBzZXBhcmF0ZSBmdW5jdGlvbiBiZWNhdXNlIGl0IGNhbiBhbHNvIGJlIGNhbGxlZCBieSB0aGUgbGVnZW5kLlxuICogVGhlIHJlYXNvbiB0aGUgSlNPTmNvbnRhaW5lciBhbmQgdGhlIHRhcmdldCBTVkcgc3ZnQ29udGFpbmVyIGhhdmUgdG8gYmUgc3VwcGxpZWQgaXMgc28gdGhlIGxlZ2VuZCBjYW4gdXNlIHRoZXNlIGZ1bmN0aW9uc1xuICogYXMgd2VsbC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHBhcmFtIHtudW1iZXJ9IHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBncm91cFRlbXBsYXRlOiBBIHRlbXBsYXRlIGNvbnRhaW5pbmcgdGhlIG5lY2Vzc2FyeSBpbmZvcm1hdGlvbiB0byBkcmF3IHRoZSBkYXRhcG9pbnQgZS5nLiwge3N0eWxlOiAnY2lyY2xlJywgc2l6ZTogNSwgY2xhc3NOYW1lOiAnY2xhc3NOYW1lJyB9XG4gKiBAcGFyYW0ge09iamVjdH0gSlNPTmNvbnRhaW5lclxuICogQHBhcmFtIHtPYmplY3R9IHN2Z0NvbnRhaW5lclxuICogQHBhcmFtIHtPYmplY3R9IGxhYmVsT2JqXG4gKiBAcmV0dXJucyB7dmlzLlBvaW50SXRlbX1cbiAqL1xuZXhwb3J0cy5kcmF3UG9pbnQgPSBmdW5jdGlvbiAoeCwgeSwgZ3JvdXBUZW1wbGF0ZSwgSlNPTmNvbnRhaW5lciwgc3ZnQ29udGFpbmVyLCBsYWJlbE9iaikge1xuICB2YXIgcG9pbnQ7XG4gIGlmIChncm91cFRlbXBsYXRlLnN0eWxlID09ICdjaXJjbGUnKSB7XG4gICAgcG9pbnQgPSBleHBvcnRzLmdldFNWR0VsZW1lbnQoJ2NpcmNsZScsIEpTT05jb250YWluZXIsIHN2Z0NvbnRhaW5lcik7XG4gICAgcG9pbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2N4JywgeCk7XG4gICAgcG9pbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2N5JywgeSk7XG4gICAgcG9pbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3InLCAwLjUgKiBncm91cFRlbXBsYXRlLnNpemUpO1xuICB9IGVsc2Uge1xuICAgIHBvaW50ID0gZXhwb3J0cy5nZXRTVkdFbGVtZW50KCdyZWN0JywgSlNPTmNvbnRhaW5lciwgc3ZnQ29udGFpbmVyKTtcbiAgICBwb2ludC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneCcsIHggLSAwLjUgKiBncm91cFRlbXBsYXRlLnNpemUpO1xuICAgIHBvaW50LnNldEF0dHJpYnV0ZU5TKG51bGwsICd5JywgeSAtIDAuNSAqIGdyb3VwVGVtcGxhdGUuc2l6ZSk7XG4gICAgcG9pbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3dpZHRoJywgZ3JvdXBUZW1wbGF0ZS5zaXplKTtcbiAgICBwb2ludC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnaGVpZ2h0JywgZ3JvdXBUZW1wbGF0ZS5zaXplKTtcbiAgfVxuXG4gIGlmIChncm91cFRlbXBsYXRlLnN0eWxlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcG9pbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3N0eWxlJywgZ3JvdXBUZW1wbGF0ZS5zdHlsZXMpO1xuICB9XG4gIHBvaW50LnNldEF0dHJpYnV0ZU5TKG51bGwsICdjbGFzcycsIGdyb3VwVGVtcGxhdGUuY2xhc3NOYW1lICsgJyB2aXMtcG9pbnQnKTtcbiAgLy9oYW5kbGUgbGFiZWxcblxuICBpZiAobGFiZWxPYmopIHtcbiAgICB2YXIgbGFiZWwgPSBleHBvcnRzLmdldFNWR0VsZW1lbnQoJ3RleHQnLCBKU09OY29udGFpbmVyLCBzdmdDb250YWluZXIpO1xuICAgIGlmIChsYWJlbE9iai54T2Zmc2V0KSB7XG4gICAgICB4ID0geCArIGxhYmVsT2JqLnhPZmZzZXQ7XG4gICAgfVxuXG4gICAgaWYgKGxhYmVsT2JqLnlPZmZzZXQpIHtcbiAgICAgIHkgPSB5ICsgbGFiZWxPYmoueU9mZnNldDtcbiAgICB9XG4gICAgaWYgKGxhYmVsT2JqLmNvbnRlbnQpIHtcbiAgICAgIGxhYmVsLnRleHRDb250ZW50ID0gbGFiZWxPYmouY29udGVudDtcbiAgICB9XG5cbiAgICBpZiAobGFiZWxPYmouY2xhc3NOYW1lKSB7XG4gICAgICBsYWJlbC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnY2xhc3MnLCBsYWJlbE9iai5jbGFzc05hbWUgKyAnIHZpcy1sYWJlbCcpO1xuICAgIH1cbiAgICBsYWJlbC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneCcsIHgpO1xuICAgIGxhYmVsLnNldEF0dHJpYnV0ZU5TKG51bGwsICd5JywgeSk7XG4gIH1cblxuICByZXR1cm4gcG9pbnQ7XG59O1xuXG4vKipcbiAqIGRyYXcgYSBiYXIgU1ZHIGVsZW1lbnQgY2VudGVyZWQgb24gdGhlIFggY29vcmRpbmF0ZVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcGFyYW0ge251bWJlcn0geVxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XG4gKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gSlNPTmNvbnRhaW5lclxuICogQHBhcmFtIHtPYmplY3R9IHN2Z0NvbnRhaW5lclxuICogQHBhcmFtIHtzdHJpbmd9IHN0eWxlXG4gKi9cbmV4cG9ydHMuZHJhd0JhciA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjbGFzc05hbWUsIEpTT05jb250YWluZXIsIHN2Z0NvbnRhaW5lciwgc3R5bGUpIHtcbiAgaWYgKGhlaWdodCAhPSAwKSB7XG4gICAgaWYgKGhlaWdodCA8IDApIHtcbiAgICAgIGhlaWdodCAqPSAtMTtcbiAgICAgIHkgLT0gaGVpZ2h0O1xuICAgIH1cbiAgICB2YXIgcmVjdCA9IGV4cG9ydHMuZ2V0U1ZHRWxlbWVudCgncmVjdCcsIEpTT05jb250YWluZXIsIHN2Z0NvbnRhaW5lcik7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneCcsIHggLSAwLjUgKiB3aWR0aCk7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneScsIHkpO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgJ3dpZHRoJywgd2lkdGgpO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgJ2hlaWdodCcsIGhlaWdodCk7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnY2xhc3MnLCBjbGFzc05hbWUpO1xuICAgIGlmIChzdHlsZSkge1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnc3R5bGUnLCBzdHlsZSk7XG4gICAgfVxuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDEyMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgY29yZSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG52YXIgJEpTT04gPSBjb3JlLkpTT04gfHwgKGNvcmUuSlNPTiA9IHsgc3RyaW5naWZ5OiBKU09OLnN0cmluZ2lmeSB9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3RyaW5naWZ5KGl0KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgcmV0dXJuICRKU09OLnN0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJndW1lbnRzKTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxMjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gTG9hZCBjdXN0b20gc2hhcGVzIGludG8gQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEyNSk7XG5cbnZhciBFbWl0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Myk7XG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgZG90cGFyc2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NCk7XG52YXIgZ2VwaGlQYXJzZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc1KTtcbnZhciBBY3RpdmF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyNik7XG52YXIgbG9jYWxlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTI5KTtcblxudmFyIEltYWdlcyA9IF9fd2VicGFja19yZXF1aXJlX18oNzYpWydkZWZhdWx0J107XG52YXIgR3JvdXBzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzQpWydkZWZhdWx0J107XG52YXIgTm9kZXNIYW5kbGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzUpWydkZWZhdWx0J107XG52YXIgRWRnZXNIYW5kbGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjUpWydkZWZhdWx0J107XG52YXIgUGh5c2ljc0VuZ2luZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTcxKVsnZGVmYXVsdCddO1xudmFyIENsdXN0ZXJFbmdpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3OClbJ2RlZmF1bHQnXTtcbnZhciBDYW52YXNSZW5kZXJlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTgwKVsnZGVmYXVsdCddO1xudmFyIENhbnZhcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTgxKVsnZGVmYXVsdCddO1xudmFyIFZpZXcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4MilbJ2RlZmF1bHQnXTtcbnZhciBJbnRlcmFjdGlvbkhhbmRsZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4MylbJ2RlZmF1bHQnXTtcbnZhciBTZWxlY3Rpb25IYW5kbGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxODYpWydkZWZhdWx0J107XG52YXIgTGF5b3V0RW5naW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXygxODcpWydkZWZhdWx0J107XG52YXIgTWFuaXB1bGF0aW9uU3lzdGVtID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOTApWydkZWZhdWx0J107XG52YXIgQ29uZmlndXJhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOTEpWydkZWZhdWx0J107XG52YXIgVmFsaWRhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NClbJ2RlZmF1bHQnXTtcblxudmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NCksXG4gICAgcHJpbnRTdHlsZSA9IF9yZXF1aXJlLnByaW50U3R5bGU7XG5cbnZhciBfcmVxdWlyZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0KSxcbiAgICBhbGxPcHRpb25zID0gX3JlcXVpcmUyLmFsbE9wdGlvbnMsXG4gICAgY29uZmlndXJlT3B0aW9ucyA9IF9yZXF1aXJlMi5jb25maWd1cmVPcHRpb25zO1xuXG52YXIgS2FtYWRhS2F3YWkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5MylbJ2RlZmF1bHQnXTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXR3b3JrIHZpc3VhbGl6YXRpb24sIGRpc3BsYXlpbmcgbm9kZXMgYW5kIGVkZ2VzLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGFpbmVyICAgVGhlIERPTSBlbGVtZW50IGluIHdoaWNoIHRoZSBOZXR3b3JrIHdpbGxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlIGNyZWF0ZWQuIE5vcm1hbGx5IGEgZGl2IGVsZW1lbnQuXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAgICAgICAgIEFuIG9iamVjdCBjb250YWluaW5nIHBhcmFtZXRlcnNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge0FycmF5fSBub2Rlc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7QXJyYXl9IGVkZ2VzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAgICAgIE9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvciBOZXR3b3JrXG4gKi9cbmZ1bmN0aW9uIE5ldHdvcmsoY29udGFpbmVyLCBkYXRhLCBvcHRpb25zKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE5ldHdvcmspKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdDb25zdHJ1Y3RvciBtdXN0IGJlIGNhbGxlZCB3aXRoIHRoZSBuZXcgb3BlcmF0b3InKTtcbiAgfVxuXG4gIC8vIHNldCBjb25zdGFudCB2YWx1ZXNcbiAgdGhpcy5vcHRpb25zID0ge307XG4gIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgbG9jYWxlOiAnZW4nLFxuICAgIGxvY2FsZXM6IGxvY2FsZXMsXG4gICAgY2xpY2tUb1VzZTogZmFsc2VcbiAgfTtcbiAgdXRpbC5leHRlbmQodGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICAvKipcbiAgICogQ29udGFpbmVycyBmb3Igbm9kZXMgYW5kIGVkZ2VzLlxuICAgKlxuICAgKiAnZWRnZXMnIGFuZCAnbm9kZXMnIGNvbnRhaW4gdGhlIGZ1bGwgZGVmaW5pdGlvbnMgb2YgYWxsIHRoZSBuZXR3b3JrIGVsZW1lbnRzLlxuICAgKiAnbm9kZUluZGljZXMnIGFuZCAnZWRnZUluZGljZXMnIGNvbnRhaW4gdGhlIGlkJ3Mgb2YgdGhlIGFjdGl2ZSBlbGVtZW50cy5cbiAgICpcbiAgICogVGhlIGRpc3RpbmN0aW9uIGlzIGltcG9ydGFudCwgYmVjYXVzZSBhIGRlZmluZWQgbm9kZSBuZWVkIG5vdCBiZSBhY3RpdmUsIGkuZS5cbiAgICogdmlzaWJsZSBvbiB0aGUgY2FudmFzLiBUaGlzIGhhcHBlbnMgaW4gcGFydGljdWxhciB3aGVuIGNsdXN0ZXJzIGFyZSBkZWZpbmVkLCBpblxuICAgKiB0aGF0IGNhc2UgdGhlcmUgd2lsbCBiZSBub2RlcyBhbmQgZWRnZXMgbm90IGRpc3BsYXllZC5cbiAgICogVGhlIGJvdHRvbSBsaW5lIGlzIHRoYXQgYWxsIGNvZGUgd2l0aCBhY3Rpb25zIHJlbGF0ZWQgdG8gdmlzaWJpbGl0eSwgKm11c3QqIHVzZVxuICAgKiAnbm9kZUluZGljZXMnIGFuZCAnZWRnZUluZGljZXMnLCBub3QgJ25vZGVzJyBhbmQgJ2VkZ2VzJyBkaXJlY3RseS5cbiAgICovXG4gIHRoaXMuYm9keSA9IHtcbiAgICBjb250YWluZXI6IGNvbnRhaW5lcixcblxuICAgIC8vIFNlZSBjb21tZW50IGFib3ZlIGZvciBmb2xsb3dpbmcgZmllbGRzXG4gICAgbm9kZXM6IHt9LFxuICAgIG5vZGVJbmRpY2VzOiBbXSxcbiAgICBlZGdlczoge30sXG4gICAgZWRnZUluZGljZXM6IFtdLFxuXG4gICAgZW1pdHRlcjoge1xuICAgICAgb246IHRoaXMub24uYmluZCh0aGlzKSxcbiAgICAgIG9mZjogdGhpcy5vZmYuYmluZCh0aGlzKSxcbiAgICAgIGVtaXQ6IHRoaXMuZW1pdC5iaW5kKHRoaXMpLFxuICAgICAgb25jZTogdGhpcy5vbmNlLmJpbmQodGhpcylcbiAgICB9LFxuICAgIGV2ZW50TGlzdGVuZXJzOiB7XG4gICAgICBvblRhcDogZnVuY3Rpb24gb25UYXAoKSB7fSxcbiAgICAgIG9uVG91Y2g6IGZ1bmN0aW9uIG9uVG91Y2goKSB7fSxcbiAgICAgIG9uRG91YmxlVGFwOiBmdW5jdGlvbiBvbkRvdWJsZVRhcCgpIHt9LFxuICAgICAgb25Ib2xkOiBmdW5jdGlvbiBvbkhvbGQoKSB7fSxcbiAgICAgIG9uRHJhZ1N0YXJ0OiBmdW5jdGlvbiBvbkRyYWdTdGFydCgpIHt9LFxuICAgICAgb25EcmFnOiBmdW5jdGlvbiBvbkRyYWcoKSB7fSxcbiAgICAgIG9uRHJhZ0VuZDogZnVuY3Rpb24gb25EcmFnRW5kKCkge30sXG4gICAgICBvbk1vdXNlV2hlZWw6IGZ1bmN0aW9uIG9uTW91c2VXaGVlbCgpIHt9LFxuICAgICAgb25QaW5jaDogZnVuY3Rpb24gb25QaW5jaCgpIHt9LFxuICAgICAgb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIG9uTW91c2VNb3ZlKCkge30sXG4gICAgICBvblJlbGVhc2U6IGZ1bmN0aW9uIG9uUmVsZWFzZSgpIHt9LFxuICAgICAgb25Db250ZXh0OiBmdW5jdGlvbiBvbkNvbnRleHQoKSB7fVxuICAgIH0sXG4gICAgZGF0YToge1xuICAgICAgbm9kZXM6IG51bGwsIC8vIEEgRGF0YVNldCBvciBEYXRhVmlld1xuICAgICAgZWRnZXM6IG51bGwgLy8gQSBEYXRhU2V0IG9yIERhdGFWaWV3XG4gICAgfSxcbiAgICBmdW5jdGlvbnM6IHtcbiAgICAgIGNyZWF0ZU5vZGU6IGZ1bmN0aW9uIGNyZWF0ZU5vZGUoKSB7fSxcbiAgICAgIGNyZWF0ZUVkZ2U6IGZ1bmN0aW9uIGNyZWF0ZUVkZ2UoKSB7fSxcbiAgICAgIGdldFBvaW50ZXI6IGZ1bmN0aW9uIGdldFBvaW50ZXIoKSB7fVxuICAgIH0sXG4gICAgbW9kdWxlczoge30sXG4gICAgdmlldzoge1xuICAgICAgc2NhbGU6IDEsXG4gICAgICB0cmFuc2xhdGlvbjogeyB4OiAwLCB5OiAwIH1cbiAgICB9XG5cbiAgICAvLyBiaW5kIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgfTt0aGlzLmJpbmRFdmVudExpc3RlbmVycygpO1xuXG4gIC8vIHNldHRpbmcgdXAgYWxsIG1vZHVsZXNcbiAgdGhpcy5pbWFnZXMgPSBuZXcgSW1hZ2VzKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3RoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19yZXF1ZXN0UmVkcmF3Jyk7XG4gIH0pOyAvLyBvYmplY3Qgd2l0aCBpbWFnZXNcbiAgdGhpcy5ncm91cHMgPSBuZXcgR3JvdXBzKCk7IC8vIG9iamVjdCB3aXRoIGdyb3Vwc1xuICB0aGlzLmNhbnZhcyA9IG5ldyBDYW52YXModGhpcy5ib2R5KTsgLy8gRE9NIGhhbmRsZXJcbiAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyID0gbmV3IFNlbGVjdGlvbkhhbmRsZXIodGhpcy5ib2R5LCB0aGlzLmNhbnZhcyk7IC8vIFNlbGVjdGlvbiBoYW5kbGVyXG4gIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyID0gbmV3IEludGVyYWN0aW9uSGFuZGxlcih0aGlzLmJvZHksIHRoaXMuY2FudmFzLCB0aGlzLnNlbGVjdGlvbkhhbmRsZXIpOyAvLyBJbnRlcmFjdGlvbiBoYW5kbGVyIGhhbmRsZXMgYWxsIHRoZSBoYW1tZXIgYmluZGluZ3MgKHRoYXQgYXJlIGJvdW5kIGJ5IGNhbnZhcyksIGtleVxuICB0aGlzLnZpZXcgPSBuZXcgVmlldyh0aGlzLmJvZHksIHRoaXMuY2FudmFzKTsgLy8gY2FtZXJhIGhhbmRsZXIsIGRvZXMgYW5pbWF0aW9ucyBhbmQgem9vbXNcbiAgdGhpcy5yZW5kZXJlciA9IG5ldyBDYW52YXNSZW5kZXJlcih0aGlzLmJvZHksIHRoaXMuY2FudmFzKTsgLy8gcmVuZGVyZXIsIHN0YXJ0cyByZW5kZXJsb29wLCBoYXMgZXZlbnRzIHRoYXQgbW9kdWxlcyBjYW4gaG9vayBpbnRvXG4gIHRoaXMucGh5c2ljcyA9IG5ldyBQaHlzaWNzRW5naW5lKHRoaXMuYm9keSk7IC8vIHBoeXNpY3MgZW5naW5lLCBkb2VzIGFsbCB0aGUgc2ltdWxhdGlvbnNcbiAgdGhpcy5sYXlvdXRFbmdpbmUgPSBuZXcgTGF5b3V0RW5naW5lKHRoaXMuYm9keSk7IC8vIGxheW91dCBlbmdpbmUgZm9yIGluaXRhbCBsYXlvdXQgYW5kIGhpZXJhcmNoaWNhbCBsYXlvdXRcbiAgdGhpcy5jbHVzdGVyaW5nID0gbmV3IENsdXN0ZXJFbmdpbmUodGhpcy5ib2R5KTsgLy8gY2x1c3RlcmluZyBhcGlcbiAgdGhpcy5tYW5pcHVsYXRpb24gPSBuZXcgTWFuaXB1bGF0aW9uU3lzdGVtKHRoaXMuYm9keSwgdGhpcy5jYW52YXMsIHRoaXMuc2VsZWN0aW9uSGFuZGxlcik7IC8vIGRhdGEgbWFuaXB1bGF0aW9uIHN5c3RlbVxuXG4gIHRoaXMubm9kZXNIYW5kbGVyID0gbmV3IE5vZGVzSGFuZGxlcih0aGlzLmJvZHksIHRoaXMuaW1hZ2VzLCB0aGlzLmdyb3VwcywgdGhpcy5sYXlvdXRFbmdpbmUpOyAvLyBIYW5kbGUgYWRkaW5nLCBkZWxldGluZyBhbmQgdXBkYXRpbmcgb2Ygbm9kZXMgYXMgd2VsbCBhcyBnbG9iYWwgb3B0aW9uc1xuICB0aGlzLmVkZ2VzSGFuZGxlciA9IG5ldyBFZGdlc0hhbmRsZXIodGhpcy5ib2R5LCB0aGlzLmltYWdlcywgdGhpcy5ncm91cHMpOyAvLyBIYW5kbGUgYWRkaW5nLCBkZWxldGluZyBhbmQgdXBkYXRpbmcgb2YgZWRnZXMgYXMgd2VsbCBhcyBnbG9iYWwgb3B0aW9uc1xuXG4gIHRoaXMuYm9keS5tb2R1bGVzWydrYW1hZGFLYXdhaSddID0gbmV3IEthbWFkYUthd2FpKHRoaXMuYm9keSwgMTUwLCAwLjA1KTsgLy8gTGF5b3V0aW5nIGFsZ29yaXRobS5cbiAgdGhpcy5ib2R5Lm1vZHVsZXNbJ2NsdXN0ZXJpbmcnXSA9IHRoaXMuY2x1c3RlcmluZztcblxuICAvLyBjcmVhdGUgdGhlIERPTSBlbGVtZW50c1xuICB0aGlzLmNhbnZhcy5fY3JlYXRlKCk7XG5cbiAgLy8gYXBwbHkgb3B0aW9uc1xuICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgLy8gbG9hZCBkYXRhICh0aGUgZGlzYWJsZSBzdGFydCB2YXJpYWJsZSB3aWxsIGJlIHRoZSBzYW1lIGFzIHRoZSBlbmFibGVkIGNsdXN0ZXJpbmcpXG4gIHRoaXMuc2V0RGF0YShkYXRhKTtcbn1cblxuLy8gRXh0ZW5kIE5ldHdvcmsgd2l0aCBhbiBFbWl0dGVyIG1peGluXG5FbWl0dGVyKE5ldHdvcmsucHJvdG90eXBlKTtcblxuLyoqXG4gKiBTZXQgb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuTmV0d29yay5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gIGlmIChvcHRpb25zID09PSBudWxsKSB7XG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZDsgLy8gVGhpcyBlbnN1cmVzIHRoYXQgb3B0aW9ucyBoYW5kbGluZyBkb2Vzbid0IGNyYXNoIGluIHRoZSBoYW5kbGluZ1xuICB9XG5cbiAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBlcnJvckZvdW5kID0gVmFsaWRhdG9yLnZhbGlkYXRlKG9wdGlvbnMsIGFsbE9wdGlvbnMpO1xuICAgIGlmIChlcnJvckZvdW5kID09PSB0cnVlKSB7XG4gICAgICBjb25zb2xlLmxvZygnJWNFcnJvcnMgaGF2ZSBiZWVuIGZvdW5kIGluIHRoZSBzdXBwbGllZCBvcHRpb25zIG9iamVjdC4nLCBwcmludFN0eWxlKTtcbiAgICB9XG5cbiAgICAvLyBjb3B5IHRoZSBnbG9iYWwgZmllbGRzIG92ZXJcbiAgICB2YXIgZmllbGRzID0gWydsb2NhbGUnLCAnbG9jYWxlcycsICdjbGlja1RvVXNlJ107XG4gICAgdXRpbC5zZWxlY3RpdmVEZWVwRXh0ZW5kKGZpZWxkcywgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgIC8vIHRoZSBoaWVyYXJjaGljYWwgc3lzdGVtIGNhbiBhZGFwdCB0aGUgZWRnZXMgYW5kIHRoZSBwaHlzaWNzIHRvIGl0J3Mgb3duIG9wdGlvbnMgYmVjYXVzZSBub3QgYWxsIGNvbWJpbmF0aW9ucyB3b3JrIHdpdGggdGhlIGhpZXJhcmljaGljYWwgc3lzdGVtLlxuICAgIG9wdGlvbnMgPSB0aGlzLmxheW91dEVuZ2luZS5zZXRPcHRpb25zKG9wdGlvbnMubGF5b3V0LCBvcHRpb25zKTtcblxuICAgIHRoaXMuY2FudmFzLnNldE9wdGlvbnMob3B0aW9ucyk7IC8vIG9wdGlvbnMgZm9yIGNhbnZhcyBhcmUgaW4gZ2xvYmFsc1xuXG4gICAgLy8gcGFzcyB0aGUgb3B0aW9ucyB0byB0aGUgbW9kdWxlc1xuICAgIHRoaXMuZ3JvdXBzLnNldE9wdGlvbnMob3B0aW9ucy5ncm91cHMpO1xuICAgIHRoaXMubm9kZXNIYW5kbGVyLnNldE9wdGlvbnMob3B0aW9ucy5ub2Rlcyk7XG4gICAgdGhpcy5lZGdlc0hhbmRsZXIuc2V0T3B0aW9ucyhvcHRpb25zLmVkZ2VzKTtcbiAgICB0aGlzLnBoeXNpY3Muc2V0T3B0aW9ucyhvcHRpb25zLnBoeXNpY3MpO1xuICAgIHRoaXMubWFuaXB1bGF0aW9uLnNldE9wdGlvbnMob3B0aW9ucy5tYW5pcHVsYXRpb24sIG9wdGlvbnMsIHRoaXMub3B0aW9ucyk7IC8vIG1hbmlwdWxhdGlvbiB1c2VzIHRoZSBsb2NhbGVzIGluIHRoZSBnbG9iYWxzXG5cbiAgICB0aGlzLmludGVyYWN0aW9uSGFuZGxlci5zZXRPcHRpb25zKG9wdGlvbnMuaW50ZXJhY3Rpb24pO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0T3B0aW9ucyhvcHRpb25zLmludGVyYWN0aW9uKTsgLy8gb3B0aW9ucyBmb3IgcmVuZGVyaW5nIGFyZSBpbiBpbnRlcmFjdGlvblxuICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5zZXRPcHRpb25zKG9wdGlvbnMuaW50ZXJhY3Rpb24pOyAvLyBvcHRpb25zIGZvciBzZWxlY3Rpb24gYXJlIGluIGludGVyYWN0aW9uXG5cbiAgICAvLyByZWxvYWQgdGhlIHNldHRpbmdzIG9mIHRoZSBub2RlcyB0byBhcHBseSBjaGFuZ2VzIGluIGdyb3VwcyB0aGF0IGFyZSBub3QgcmVmZXJlbmNlZCBieSBwb2ludGVyLlxuICAgIGlmIChvcHRpb25zLmdyb3VwcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdyZWZyZXNoTm9kZXMnKTtcbiAgICB9XG4gICAgLy8gdGhlc2UgdHdvIGRvIG5vdCBoYXZlIG9wdGlvbnMgYXQgdGhlIG1vbWVudCwgaGVyZSBmb3IgY29tcGxldGVuZXNzXG4gICAgLy90aGlzLnZpZXcuc2V0T3B0aW9ucyhvcHRpb25zLnZpZXcpO1xuICAgIC8vdGhpcy5jbHVzdGVyaW5nLnNldE9wdGlvbnMob3B0aW9ucy5jbHVzdGVyaW5nKTtcblxuICAgIGlmICgnY29uZmlndXJlJyBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAoIXRoaXMuY29uZmlndXJhdG9yKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdG9yID0gbmV3IENvbmZpZ3VyYXRvcih0aGlzLCB0aGlzLmJvZHkuY29udGFpbmVyLCBjb25maWd1cmVPcHRpb25zLCB0aGlzLmNhbnZhcy5waXhlbFJhdGlvKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb25maWd1cmF0b3Iuc2V0T3B0aW9ucyhvcHRpb25zLmNvbmZpZ3VyZSk7XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIGNvbmZpZ3VyYXRpb24gc3lzdGVtIGlzIGVuYWJsZWQsIGNvcHkgYWxsIG9wdGlvbnMgYW5kIHB1dCB0aGVtIGludG8gdGhlIGNvbmZpZyBzeXN0ZW1cbiAgICBpZiAodGhpcy5jb25maWd1cmF0b3IgJiYgdGhpcy5jb25maWd1cmF0b3Iub3B0aW9ucy5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICB2YXIgbmV0d29ya09wdGlvbnMgPSB7XG4gICAgICAgIG5vZGVzOiB7fSxcbiAgICAgICAgZWRnZXM6IHt9LFxuICAgICAgICBsYXlvdXQ6IHt9LFxuICAgICAgICBpbnRlcmFjdGlvbjoge30sXG4gICAgICAgIG1hbmlwdWxhdGlvbjoge30sXG4gICAgICAgIHBoeXNpY3M6IHt9LFxuICAgICAgICBnbG9iYWw6IHt9XG4gICAgICB9O1xuICAgICAgdXRpbC5kZWVwRXh0ZW5kKG5ldHdvcmtPcHRpb25zLm5vZGVzLCB0aGlzLm5vZGVzSGFuZGxlci5vcHRpb25zKTtcbiAgICAgIHV0aWwuZGVlcEV4dGVuZChuZXR3b3JrT3B0aW9ucy5lZGdlcywgdGhpcy5lZGdlc0hhbmRsZXIub3B0aW9ucyk7XG4gICAgICB1dGlsLmRlZXBFeHRlbmQobmV0d29ya09wdGlvbnMubGF5b3V0LCB0aGlzLmxheW91dEVuZ2luZS5vcHRpb25zKTtcbiAgICAgIC8vIGxvYWQgdGhlIHNlbGVjdGlvbkhhbmRsZXIgYW5kIHJlbmRlciBkZWZhdWx0IG9wdGlvbnMgaW4gdG8gdGhlIGludGVyYWN0aW9uIGdyb3VwXG4gICAgICB1dGlsLmRlZXBFeHRlbmQobmV0d29ya09wdGlvbnMuaW50ZXJhY3Rpb24sIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5vcHRpb25zKTtcbiAgICAgIHV0aWwuZGVlcEV4dGVuZChuZXR3b3JrT3B0aW9ucy5pbnRlcmFjdGlvbiwgdGhpcy5yZW5kZXJlci5vcHRpb25zKTtcblxuICAgICAgdXRpbC5kZWVwRXh0ZW5kKG5ldHdvcmtPcHRpb25zLmludGVyYWN0aW9uLCB0aGlzLmludGVyYWN0aW9uSGFuZGxlci5vcHRpb25zKTtcbiAgICAgIHV0aWwuZGVlcEV4dGVuZChuZXR3b3JrT3B0aW9ucy5tYW5pcHVsYXRpb24sIHRoaXMubWFuaXB1bGF0aW9uLm9wdGlvbnMpO1xuICAgICAgdXRpbC5kZWVwRXh0ZW5kKG5ldHdvcmtPcHRpb25zLnBoeXNpY3MsIHRoaXMucGh5c2ljcy5vcHRpb25zKTtcblxuICAgICAgLy8gbG9hZCBnbG9iYWxzIGludG8gdGhlIGdsb2JhbCBvYmplY3RcbiAgICAgIHV0aWwuZGVlcEV4dGVuZChuZXR3b3JrT3B0aW9ucy5nbG9iYWwsIHRoaXMuY2FudmFzLm9wdGlvbnMpO1xuICAgICAgdXRpbC5kZWVwRXh0ZW5kKG5ldHdvcmtPcHRpb25zLmdsb2JhbCwgdGhpcy5vcHRpb25zKTtcblxuICAgICAgdGhpcy5jb25maWd1cmF0b3Iuc2V0TW9kdWxlT3B0aW9ucyhuZXR3b3JrT3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIG5ldHdvcmsgZ2xvYmFsIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucy5jbGlja1RvVXNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChvcHRpb25zLmNsaWNrVG9Vc2UgPT09IHRydWUpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZhdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmFjdGl2YXRvciA9IG5ldyBBY3RpdmF0b3IodGhpcy5jYW52YXMuZnJhbWUpO1xuICAgICAgICAgIHRoaXMuYWN0aXZhdG9yLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczIuYm9keS5lbWl0dGVyLmVtaXQoJ2FjdGl2YXRlJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2YXRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5hY3RpdmF0b3IuZGVzdHJveSgpO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLmFjdGl2YXRvcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdhY3RpdmF0ZScpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdhY3RpdmF0ZScpO1xuICAgIH1cblxuICAgIHRoaXMuY2FudmFzLnNldFNpemUoKTtcbiAgICAvLyBzdGFydCB0aGUgcGh5c2ljcyBzaW11bGF0aW9uLiBDYW4gYmUgc2FmZWx5IGNhbGxlZCBtdWx0aXBsZSB0aW1lcy5cbiAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdzdGFydFNpbXVsYXRpb24nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIHZpc2libGUgbm9kZXMgYW5kIGVkZ2VzIGxpc3Qgd2l0aCB0aGUgbW9zdCByZWNlbnQgbm9kZSBzdGF0ZS5cbiAqXG4gKiBWaXNpYmxlIG5vZGVzIGFyZSBzdG9yZWQgaW4gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLlxuICogVmlzaWJsZSBlZGdlcyBhcmUgc3RvcmVkIGluIHRoaXMuYm9keS5lZGdlSW5kaWNlcy5cbiAqIEEgbm9kZSBvciBlZGdlcyBpcyB2aXNpYmxlIGlmIGl0IGlzIG5vdCBoaWRkZW4gb3IgY2x1c3RlcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbk5ldHdvcmsucHJvdG90eXBlLl91cGRhdGVWaXNpYmxlSW5kaWNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gIHRoaXMuYm9keS5ub2RlSW5kaWNlcyA9IFtdO1xuICB0aGlzLmJvZHkuZWRnZUluZGljZXMgPSBbXTtcblxuICBmb3IgKHZhciBub2RlSWQgaW4gbm9kZXMpIHtcbiAgICBpZiAobm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgaWYgKCF0aGlzLmNsdXN0ZXJpbmcuX2lzQ2x1c3RlcmVkTm9kZShub2RlSWQpICYmIG5vZGVzW25vZGVJZF0ub3B0aW9ucy5oaWRkZW4gPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuYm9keS5ub2RlSW5kaWNlcy5wdXNoKG5vZGVzW25vZGVJZF0uaWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGVkZ2VJZCBpbiBlZGdlcykge1xuICAgIGlmIChlZGdlcy5oYXNPd25Qcm9wZXJ0eShlZGdlSWQpKSB7XG4gICAgICB2YXIgZWRnZSA9IGVkZ2VzW2VkZ2VJZF07XG5cbiAgICAgIC8vIEl0IGNhbiBoYXBwZW4gdGhhdCB0aGlzIGlzIGV4ZWN1dGVkICphZnRlciogYSBub2RlIGVkZ2UgaGFzIGJlZW4gcmVtb3ZlZCxcbiAgICAgIC8vIGJ1dCAqYmVmb3JlKiB0aGUgZWRnZSBpdHNlbGYgaGFzIGJlZW4gcmVtb3ZlZC4gVGFraW5nIHRoaXMgaW50byBhY2NvdW50LlxuICAgICAgdmFyIGZyb21Ob2RlID0gbm9kZXNbZWRnZS5mcm9tSWRdO1xuICAgICAgdmFyIHRvTm9kZSA9IG5vZGVzW2VkZ2UudG9JZF07XG4gICAgICB2YXIgZWRnZU5vZGVzUHJlc2VudCA9IGZyb21Ob2RlICE9PSB1bmRlZmluZWQgJiYgdG9Ob2RlICE9PSB1bmRlZmluZWQ7XG5cbiAgICAgIHZhciBpc1Zpc2libGUgPSAhdGhpcy5jbHVzdGVyaW5nLl9pc0NsdXN0ZXJlZEVkZ2UoZWRnZUlkKSAmJiBlZGdlLm9wdGlvbnMuaGlkZGVuID09PSBmYWxzZSAmJiBlZGdlTm9kZXNQcmVzZW50ICYmIGZyb21Ob2RlLm9wdGlvbnMuaGlkZGVuID09PSBmYWxzZSAmJiAvLyBBbHNvIGhpZGRlbiBpZiBhbnkgb2YgaXRzIGNvbm5lY3Rpbmcgbm9kZXMgYXJlIGhpZGRlblxuICAgICAgdG9Ob2RlLm9wdGlvbnMuaGlkZGVuID09PSBmYWxzZTsgLy8gaWRlbVxuXG4gICAgICBpZiAoaXNWaXNpYmxlKSB7XG4gICAgICAgIHRoaXMuYm9keS5lZGdlSW5kaWNlcy5wdXNoKGVkZ2UuaWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBCaW5kIGFsbCBldmVudHNcbiAqL1xuTmV0d29yay5wcm90b3R5cGUuYmluZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAvLyBUaGlzIGV2ZW50IHdpbGwgdHJpZ2dlciBhIHJlYnVpbGRpbmcgb2YgdGhlIGNhY2hlIGV2ZXJ5dGhpbmcuXG4gIC8vIFVzZWQgd2hlbiBub2RlcyBvciBlZGdlcyBoYXZlIGJlZW4gYWRkZWQgb3IgcmVtb3ZlZC5cbiAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ19kYXRhQ2hhbmdlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBfdGhpczMuZWRnZXNIYW5kbGVyLl91cGRhdGVTdGF0ZSgpO1xuICAgIF90aGlzMy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2RhdGFVcGRhdGVkJyk7XG4gIH0pO1xuXG4gIC8vIHRoaXMgaXMgY2FsbGVkIHdoZW4gb3B0aW9ucyBvZiBFWElTVElORyBub2RlcyBvciBlZGdlcyBoYXZlIGNoYW5nZWQuXG4gIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdfZGF0YVVwZGF0ZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgLy8gT3JkZXIgaW1wb3J0YW50IGluIGZvbGxvd2luZyBibG9ja1xuICAgIF90aGlzMy5jbHVzdGVyaW5nLl91cGRhdGVTdGF0ZSgpO1xuICAgIF90aGlzMy5fdXBkYXRlVmlzaWJsZUluZGljZXMoKTtcblxuICAgIF90aGlzMy5fdXBkYXRlVmFsdWVSYW5nZShfdGhpczMuYm9keS5ub2Rlcyk7XG4gICAgX3RoaXMzLl91cGRhdGVWYWx1ZVJhbmdlKF90aGlzMy5ib2R5LmVkZ2VzKTtcbiAgICAvLyBzdGFydCBzaW11bGF0aW9uIChjYW4gYmUgY2FsbGVkIHNhZmVseSwgZXZlbiBpZiBhbHJlYWR5IHJ1bm5pbmcpXG4gICAgX3RoaXMzLmJvZHkuZW1pdHRlci5lbWl0KCdzdGFydFNpbXVsYXRpb24nKTtcbiAgICBfdGhpczMuYm9keS5lbWl0dGVyLmVtaXQoJ19yZXF1ZXN0UmVkcmF3Jyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBTZXQgbm9kZXMgYW5kIGVkZ2VzLCBhbmQgb3B0aW9uYWxseSBvcHRpb25zIGFzIHdlbGwuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgICAgICAgICAgICAgIE9iamVjdCBjb250YWluaW5nIHBhcmFtZXRlcnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge0FycmF5IHwgRGF0YVNldCB8IERhdGFWaWV3fSBbbm9kZXNdIEFycmF5IHdpdGggbm9kZXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7QXJyYXkgfCBEYXRhU2V0IHwgRGF0YVZpZXd9IFtlZGdlc10gQXJyYXkgd2l0aCBlZGdlc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmd9IFtkb3RdIFN0cmluZyBjb250YWluaW5nIGRhdGEgaW4gRE9UIGZvcm1hdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmd9IFtnZXBoaV0gU3RyaW5nIGNvbnRhaW5pbmcgZGF0YSBpbiBnZXBoaSBKU09OIGZvcm1hdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtPcHRpb25zfSBbb3B0aW9uc10gT2JqZWN0IHdpdGggb3B0aW9uc1xuICovXG5OZXR3b3JrLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgLy8gcmVzZXQgdGhlIHBoeXNpY3MgZW5naW5lLlxuICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdyZXNldFBoeXNpY3MnKTtcbiAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX3Jlc2V0RGF0YScpO1xuXG4gIC8vIHVuc2VsZWN0IGFsbCB0byBlbnN1cmUgbm8gc2VsZWN0aW9ucyBmcm9tIG9sZCBkYXRhIGFyZSBjYXJyaWVkIG92ZXIuXG4gIHRoaXMuc2VsZWN0aW9uSGFuZGxlci51bnNlbGVjdEFsbCgpO1xuXG4gIGlmIChkYXRhICYmIGRhdGEuZG90ICYmIChkYXRhLm5vZGVzIHx8IGRhdGEuZWRnZXMpKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdEYXRhIG11c3QgY29udGFpbiBlaXRoZXIgcGFyYW1ldGVyIFwiZG90XCIgb3IgJyArICcgcGFyYW1ldGVyIHBhaXIgXCJub2Rlc1wiIGFuZCBcImVkZ2VzXCIsIGJ1dCBub3QgYm90aC4nKTtcbiAgfVxuXG4gIC8vIHNldCBvcHRpb25zXG4gIHRoaXMuc2V0T3B0aW9ucyhkYXRhICYmIGRhdGEub3B0aW9ucyk7XG4gIC8vIHNldCBhbGwgZGF0YVxuICBpZiAoZGF0YSAmJiBkYXRhLmRvdCkge1xuICAgIGNvbnNvbGUubG9nKCdUaGUgZG90IHByb3BlcnR5IGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdGhlIHN0YXRpYyBjb252ZXJ0RG90IG1ldGhvZCB0byBjb252ZXJ0IERPVCBpbnRvIHZpcy5uZXR3b3JrIGZvcm1hdCBhbmQgdXNlIHRoZSBub3JtYWwgZGF0YSBmb3JtYXQgd2l0aCBub2RlcyBhbmQgZWRnZXMuIFRoaXMgY29udmVydGVyIGlzIHVzZWQgbGlrZSB0aGlzOiB2YXIgZGF0YSA9IHZpcy5uZXR3b3JrLmNvbnZlcnREb3QoZG90U3RyaW5nKTsnKTtcbiAgICAvLyBwYXJzZSBET1QgZmlsZVxuICAgIHZhciBkb3REYXRhID0gZG90cGFyc2VyLkRPVFRvR3JhcGgoZGF0YS5kb3QpO1xuICAgIHRoaXMuc2V0RGF0YShkb3REYXRhKTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoZGF0YSAmJiBkYXRhLmdlcGhpKSB7XG4gICAgLy8gcGFyc2UgRE9UIGZpbGVcbiAgICBjb25zb2xlLmxvZygnVGhlIGdlcGhpIHByb3BlcnR5IGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdGhlIHN0YXRpYyBjb252ZXJ0R2VwaGkgbWV0aG9kIHRvIGNvbnZlcnQgZ2VwaGkgaW50byB2aXMubmV0d29yayBmb3JtYXQgYW5kIHVzZSB0aGUgbm9ybWFsIGRhdGEgZm9ybWF0IHdpdGggbm9kZXMgYW5kIGVkZ2VzLiBUaGlzIGNvbnZlcnRlciBpcyB1c2VkIGxpa2UgdGhpczogdmFyIGRhdGEgPSB2aXMubmV0d29yay5jb252ZXJ0R2VwaGkoZ2VwaGlKc29uKTsnKTtcbiAgICB2YXIgZ2VwaGlEYXRhID0gZ2VwaGlQYXJzZXIucGFyc2VHZXBoaShkYXRhLmdlcGhpKTtcbiAgICB0aGlzLnNldERhdGEoZ2VwaGlEYXRhKTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5ub2Rlc0hhbmRsZXIuc2V0RGF0YShkYXRhICYmIGRhdGEubm9kZXMsIHRydWUpO1xuICAgIHRoaXMuZWRnZXNIYW5kbGVyLnNldERhdGEoZGF0YSAmJiBkYXRhLmVkZ2VzLCB0cnVlKTtcbiAgfVxuXG4gIC8vIGVtaXQgY2hhbmdlIGluIGRhdGFcbiAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2RhdGFDaGFuZ2VkJyk7XG5cbiAgLy8gZW1pdCBkYXRhIGxvYWRlZFxuICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfZGF0YUxvYWRlZCcpO1xuXG4gIC8vIGZpbmQgYSBzdGFibGUgcG9zaXRpb24gb3Igc3RhcnQgYW5pbWF0aW5nIHRvIGEgc3RhYmxlIHBvc2l0aW9uXG4gIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ2luaXRQaHlzaWNzJyk7XG59O1xuXG4vKipcbiAqIENsZWFucyB1cCBhbGwgYmluZGluZ3Mgb2YgdGhlIG5ldHdvcmssIHJlbW92aW5nIGl0IGZ1bGx5IGZyb20gdGhlIG1lbW9yeSBJRiB0aGUgdmFyaWFibGUgaXMgc2V0IHRvIG51bGwgYWZ0ZXIgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLlxuICogdmFyIG5ldHdvcmsgPSBuZXcgdmlzLk5ldHdvcmsoLi4pO1xuICogbmV0d29yay5kZXN0cm95KCk7XG4gKiBuZXR3b3JrID0gbnVsbDtcbiAqL1xuTmV0d29yay5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnZGVzdHJveScpO1xuICAvLyBjbGVhciBldmVudHNcbiAgdGhpcy5ib2R5LmVtaXR0ZXIub2ZmKCk7XG4gIHRoaXMub2ZmKCk7XG5cbiAgLy8gZGVsZXRlIG1vZHVsZXNcbiAgZGVsZXRlIHRoaXMuZ3JvdXBzO1xuICBkZWxldGUgdGhpcy5jYW52YXM7XG4gIGRlbGV0ZSB0aGlzLnNlbGVjdGlvbkhhbmRsZXI7XG4gIGRlbGV0ZSB0aGlzLmludGVyYWN0aW9uSGFuZGxlcjtcbiAgZGVsZXRlIHRoaXMudmlldztcbiAgZGVsZXRlIHRoaXMucmVuZGVyZXI7XG4gIGRlbGV0ZSB0aGlzLnBoeXNpY3M7XG4gIGRlbGV0ZSB0aGlzLmxheW91dEVuZ2luZTtcbiAgZGVsZXRlIHRoaXMuY2x1c3RlcmluZztcbiAgZGVsZXRlIHRoaXMubWFuaXB1bGF0aW9uO1xuICBkZWxldGUgdGhpcy5ub2Rlc0hhbmRsZXI7XG4gIGRlbGV0ZSB0aGlzLmVkZ2VzSGFuZGxlcjtcbiAgZGVsZXRlIHRoaXMuY29uZmlndXJhdG9yO1xuICBkZWxldGUgdGhpcy5pbWFnZXM7XG5cbiAgZm9yICh2YXIgbm9kZUlkIGluIHRoaXMuYm9keS5ub2Rlcykge1xuICAgIGlmICghdGhpcy5ib2R5Lm5vZGVzLmhhc093blByb3BlcnR5KG5vZGVJZCkpIGNvbnRpbnVlO1xuICAgIGRlbGV0ZSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgfVxuXG4gIGZvciAodmFyIGVkZ2VJZCBpbiB0aGlzLmJvZHkuZWRnZXMpIHtcbiAgICBpZiAoIXRoaXMuYm9keS5lZGdlcy5oYXNPd25Qcm9wZXJ0eShlZGdlSWQpKSBjb250aW51ZTtcbiAgICBkZWxldGUgdGhpcy5ib2R5LmVkZ2VzW2VkZ2VJZF07XG4gIH1cblxuICAvLyByZW1vdmUgdGhlIGNvbnRhaW5lciBhbmQgZXZlcnl0aGluZyBpbnNpZGUgaXQgcmVjdXJzaXZlbHlcbiAgdXRpbC5yZWN1cnNpdmVET01EZWxldGUodGhpcy5ib2R5LmNvbnRhaW5lcik7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgdmFsdWVzIG9mIGFsbCBvYmplY3QgaW4gdGhlIGdpdmVuIGFycmF5IGFjY29yZGluZyB0byB0aGUgY3VycmVudFxuICogdmFsdWUgcmFuZ2Ugb2YgdGhlIG9iamVjdHMgaW4gdGhlIGFycmF5LlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAgICBBbiBvYmplY3QgY29udGFpbmluZyBhIHNldCBvZiBFZGdlcyBvciBOb2Rlc1xuICogICAgICAgICAgICAgICAgICAgICAgICBUaGUgb2JqZWN0cyBtdXN0IGhhdmUgYSBtZXRob2QgZ2V0VmFsdWUoKSBhbmRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWVSYW5nZShtaW4sIG1heCkuXG4gKiBAcHJpdmF0ZVxuICovXG5OZXR3b3JrLnByb3RvdHlwZS5fdXBkYXRlVmFsdWVSYW5nZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGlkO1xuXG4gIC8vIGRldGVybWluZSB0aGUgcmFuZ2Ugb2YgdGhlIG9iamVjdHNcbiAgdmFyIHZhbHVlTWluID0gdW5kZWZpbmVkO1xuICB2YXIgdmFsdWVNYXggPSB1bmRlZmluZWQ7XG4gIHZhciB2YWx1ZVRvdGFsID0gMDtcbiAgZm9yIChpZCBpbiBvYmopIHtcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgdmFyIHZhbHVlID0gb2JqW2lkXS5nZXRWYWx1ZSgpO1xuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFsdWVNaW4gPSB2YWx1ZU1pbiA9PT0gdW5kZWZpbmVkID8gdmFsdWUgOiBNYXRoLm1pbih2YWx1ZSwgdmFsdWVNaW4pO1xuICAgICAgICB2YWx1ZU1heCA9IHZhbHVlTWF4ID09PSB1bmRlZmluZWQgPyB2YWx1ZSA6IE1hdGgubWF4KHZhbHVlLCB2YWx1ZU1heCk7XG4gICAgICAgIHZhbHVlVG90YWwgKz0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gYWRqdXN0IHRoZSByYW5nZSBvZiBhbGwgb2JqZWN0c1xuICBpZiAodmFsdWVNaW4gIT09IHVuZGVmaW5lZCAmJiB2YWx1ZU1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChpZCBpbiBvYmopIHtcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgIG9ialtpZF0uc2V0VmFsdWVSYW5nZSh2YWx1ZU1pbiwgdmFsdWVNYXgsIHZhbHVlVG90YWwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgd2hlbiB0aGUgTmV0d29yayBpcyBhY3RpdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTmV0d29yay5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhdGhpcy5hY3RpdmF0b3IgfHwgdGhpcy5hY3RpdmF0b3IuYWN0aXZlO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuc2V0U2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2FudmFzLnNldFNpemUuYXBwbHkodGhpcy5jYW52YXMsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuY2FudmFzVG9ET00gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNhbnZhcy5jYW52YXNUb0RPTS5hcHBseSh0aGlzLmNhbnZhcywgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5ET010b0NhbnZhcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2FudmFzLkRPTXRvQ2FudmFzLmFwcGx5KHRoaXMuY2FudmFzLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBOb2RlcyBjYW4gYmUgaW4gY2x1c3RlcnMuIENsdXN0ZXJzIGNhbiBhbHNvIGJlIGluIGNsdXN0ZXJzLiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYW5kIGFycmF5IG9mXG4gKiBub2RlSWRzIHNob3dpbmcgd2hlcmUgdGhlIG5vZGUgaXMuXG4gKlxuICogSWYgYW55IG5vZGVJZCBpbiB0aGUgY2hhaW4sIGVzcGVjaWFsbHkgdGhlIGZpcnN0IHBhc3NlZCBpbiBhcyBhIHBhcmFtZXRlciwgaXMgbm90IHByZXNlbnQgaW5cbiAqIHRoZSBjdXJyZW50IG5vZGVzIGxpc3QsIGFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkLlxuICpcbiAqIEV4YW1wbGU6XG4gKiBjbHVzdGVyICdBJyBjb250YWlucyBjbHVzdGVyICdCJyxcbiAqIGNsdXN0ZXIgJ0InIGNvbnRhaW5zIGNsdXN0ZXIgJ0MnLFxuICogY2x1c3RlciAnQycgY29udGFpbnMgbm9kZSAnZnJlZCcuXG4gKiBganNuZXR3b3JrLmNsdXN0ZXJpbmcuZmluZE5vZGUoJ2ZyZWQnKWAgd2lsbCByZXR1cm4gYFsnQScsJ0InLCdDJywnZnJlZCddYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IG5vZGVJZFxuICogQHJldHVybnMge0FycmF5fVxuICovXG5OZXR3b3JrLnByb3RvdHlwZS5maW5kTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy5maW5kTm9kZS5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5pc0NsdXN0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNsdXN0ZXJpbmcuaXNDbHVzdGVyLmFwcGx5KHRoaXMuY2x1c3RlcmluZywgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5vcGVuQ2x1c3RlciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy5vcGVuQ2x1c3Rlci5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuY2x1c3RlciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy5jbHVzdGVyLmFwcGx5KHRoaXMuY2x1c3RlcmluZywgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5nZXROb2Rlc0luQ2x1c3RlciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy5nZXROb2Rlc0luQ2x1c3Rlci5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuY2x1c3RlckJ5Q29ubmVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy5jbHVzdGVyQnlDb25uZWN0aW9uLmFwcGx5KHRoaXMuY2x1c3RlcmluZywgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5jbHVzdGVyQnlIdWJzaXplID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jbHVzdGVyaW5nLmNsdXN0ZXJCeUh1YnNpemUuYXBwbHkodGhpcy5jbHVzdGVyaW5nLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCB3aWxsIGNsdXN0ZXIgYWxsIG5vZGVzIHdpdGggMSBlZGdlIHdpdGggdGhlaXIgcmVzcGVjdGl2ZSBjb25uZWN0ZWQgbm9kZS5cbiAqIFRoZSBvcHRpb25zIG9iamVjdCBpcyBleHBsYWluZWQgaW4gZnVsbCA8YSBkYXRhLXNjcm9sbD1cIlwiIGRhdGEtb3B0aW9ucz1cInsgJnF1b3Q7ZWFzaW5nJnF1b3Q7OiAmcXVvdDtlYXNlSW5DdWJpYyZxdW90OyB9XCIgaHJlZj1cIiNvcHRpb25zT2JqZWN0XCI+YmVsb3c8L2E+LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cbk5ldHdvcmsucHJvdG90eXBlLmNsdXN0ZXJPdXRsaWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy5jbHVzdGVyT3V0bGllcnMuYXBwbHkodGhpcy5jbHVzdGVyaW5nLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuZ2V0U2VlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubGF5b3V0RW5naW5lLmdldFNlZWQuYXBwbHkodGhpcy5sYXlvdXRFbmdpbmUsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuZW5hYmxlRWRpdE1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm1hbmlwdWxhdGlvbi5lbmFibGVFZGl0TW9kZS5hcHBseSh0aGlzLm1hbmlwdWxhdGlvbiwgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5kaXNhYmxlRWRpdE1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm1hbmlwdWxhdGlvbi5kaXNhYmxlRWRpdE1vZGUuYXBwbHkodGhpcy5tYW5pcHVsYXRpb24sIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuYWRkTm9kZU1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm1hbmlwdWxhdGlvbi5hZGROb2RlTW9kZS5hcHBseSh0aGlzLm1hbmlwdWxhdGlvbiwgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5lZGl0Tm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmVkaXROb2RlLmFwcGx5KHRoaXMubWFuaXB1bGF0aW9uLCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLmVkaXROb2RlTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc29sZS5sb2coJ0RlcHJlY2F0ZWQ6IFBsZWFzZSB1c2UgZWRpdE5vZGUgaW5zdGVhZCBvZiBlZGl0Tm9kZU1vZGUuJyk7XG4gIHJldHVybiB0aGlzLm1hbmlwdWxhdGlvbi5lZGl0Tm9kZS5hcHBseSh0aGlzLm1hbmlwdWxhdGlvbiwgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5hZGRFZGdlTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmFkZEVkZ2VNb2RlLmFwcGx5KHRoaXMubWFuaXB1bGF0aW9uLCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLmVkaXRFZGdlTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmVkaXRFZGdlTW9kZS5hcHBseSh0aGlzLm1hbmlwdWxhdGlvbiwgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5kZWxldGVTZWxlY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmRlbGV0ZVNlbGVjdGVkLmFwcGx5KHRoaXMubWFuaXB1bGF0aW9uLCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLmdldFBvc2l0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubm9kZXNIYW5kbGVyLmdldFBvc2l0aW9ucy5hcHBseSh0aGlzLm5vZGVzSGFuZGxlciwgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5zdG9yZVBvc2l0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubm9kZXNIYW5kbGVyLnN0b3JlUG9zaXRpb25zLmFwcGx5KHRoaXMubm9kZXNIYW5kbGVyLCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLm1vdmVOb2RlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ub2Rlc0hhbmRsZXIubW92ZU5vZGUuYXBwbHkodGhpcy5ub2Rlc0hhbmRsZXIsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuZ2V0Qm91bmRpbmdCb3ggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm5vZGVzSGFuZGxlci5nZXRCb3VuZGluZ0JveC5hcHBseSh0aGlzLm5vZGVzSGFuZGxlciwgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5nZXRDb25uZWN0ZWROb2RlcyA9IGZ1bmN0aW9uIChvYmplY3RJZCkge1xuICBpZiAodGhpcy5ib2R5Lm5vZGVzW29iamVjdElkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXNIYW5kbGVyLmdldENvbm5lY3RlZE5vZGVzLmFwcGx5KHRoaXMubm9kZXNIYW5kbGVyLCBhcmd1bWVudHMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLmVkZ2VzSGFuZGxlci5nZXRDb25uZWN0ZWROb2Rlcy5hcHBseSh0aGlzLmVkZ2VzSGFuZGxlciwgYXJndW1lbnRzKTtcbiAgfVxufTtcbk5ldHdvcmsucHJvdG90eXBlLmdldENvbm5lY3RlZEVkZ2VzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ub2Rlc0hhbmRsZXIuZ2V0Q29ubmVjdGVkRWRnZXMuYXBwbHkodGhpcy5ub2Rlc0hhbmRsZXIsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuc3RhcnRTaW11bGF0aW9uID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5waHlzaWNzLnN0YXJ0U2ltdWxhdGlvbi5hcHBseSh0aGlzLnBoeXNpY3MsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuc3RvcFNpbXVsYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnBoeXNpY3Muc3RvcFNpbXVsYXRpb24uYXBwbHkodGhpcy5waHlzaWNzLCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLnN0YWJpbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucGh5c2ljcy5zdGFiaWxpemUuYXBwbHkodGhpcy5waHlzaWNzLCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRTZWxlY3Rpb24uYXBwbHkodGhpcy5zZWxlY3Rpb25IYW5kbGVyLCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLnNldFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5zZXRTZWxlY3Rpb24uYXBwbHkodGhpcy5zZWxlY3Rpb25IYW5kbGVyLCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLmdldFNlbGVjdGVkTm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0ZWROb2Rlcy5hcHBseSh0aGlzLnNlbGVjdGlvbkhhbmRsZXIsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuZ2V0U2VsZWN0ZWRFZGdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRTZWxlY3RlZEVkZ2VzLmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlciwgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5nZXROb2RlQXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldE5vZGVBdC5hcHBseSh0aGlzLnNlbGVjdGlvbkhhbmRsZXIsIGFyZ3VtZW50cyk7XG4gIGlmIChub2RlICE9PSB1bmRlZmluZWQgJiYgbm9kZS5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG5vZGUuaWQ7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59O1xuTmV0d29yay5wcm90b3R5cGUuZ2V0RWRnZUF0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWRnZSA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRFZGdlQXQuYXBwbHkodGhpcy5zZWxlY3Rpb25IYW5kbGVyLCBhcmd1bWVudHMpO1xuICBpZiAoZWRnZSAhPT0gdW5kZWZpbmVkICYmIGVkZ2UuaWQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBlZGdlLmlkO1xuICB9XG4gIHJldHVybiBlZGdlO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLnNlbGVjdE5vZGVzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnNlbGVjdE5vZGVzLmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlciwgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5zZWxlY3RFZGdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5zZWxlY3RFZGdlcy5hcHBseSh0aGlzLnNlbGVjdGlvbkhhbmRsZXIsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUudW5zZWxlY3RBbGwgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VsZWN0aW9uSGFuZGxlci51bnNlbGVjdEFsbC5hcHBseSh0aGlzLnNlbGVjdGlvbkhhbmRsZXIsIGFyZ3VtZW50cyk7XG4gIHRoaXMucmVkcmF3KCk7XG59O1xuTmV0d29yay5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yZW5kZXJlci5yZWRyYXcuYXBwbHkodGhpcy5yZW5kZXJlciwgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5nZXRTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMudmlldy5nZXRTY2FsZS5hcHBseSh0aGlzLnZpZXcsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuZ2V0Vmlld1Bvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy52aWV3LmdldFZpZXdQb3NpdGlvbi5hcHBseSh0aGlzLnZpZXcsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuZml0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy52aWV3LmZpdC5hcHBseSh0aGlzLnZpZXcsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy52aWV3Lm1vdmVUby5hcHBseSh0aGlzLnZpZXcsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnZpZXcuZm9jdXMuYXBwbHkodGhpcy52aWV3LCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLnJlbGVhc2VOb2RlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy52aWV3LnJlbGVhc2VOb2RlLmFwcGx5KHRoaXMudmlldywgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5nZXRPcHRpb25zRnJvbUNvbmZpZ3VyYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgaWYgKHRoaXMuY29uZmlndXJhdG9yKSB7XG4gICAgb3B0aW9ucyA9IHRoaXMuY29uZmlndXJhdG9yLmdldE9wdGlvbnMuYXBwbHkodGhpcy5jb25maWd1cmF0b3IpO1xuICB9XG4gIHJldHVybiBvcHRpb25zO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBOZXR3b3JrO1xuXG4vKioqLyB9KSxcbi8qIDEyNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKipcbiAqIENhbnZhcyBzaGFwZXMgdXNlZCBieSBOZXR3b3JrXG4gKi9cbmlmICh0eXBlb2YgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEICE9PSAndW5kZWZpbmVkJykge1xuICAvKipcbiAgICogRHJhdyBhIGNpcmNsZSBzaGFwZVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgKiBAcGFyYW0ge251bWJlcn0gclxuICAgKi9cbiAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5jaXJjbGUgPSBmdW5jdGlvbiAoeCwgeSwgcikge1xuICAgIHRoaXMuYmVnaW5QYXRoKCk7XG4gICAgdGhpcy5hcmMoeCwgeSwgciwgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEcmF3IGEgc3F1YXJlIHNoYXBlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IGhvcml6b250YWwgY2VudGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IHZlcnRpY2FsIGNlbnRlclxuICAgKiBAcGFyYW0ge251bWJlcn0gciAgIHNpemUsIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIHNxdWFyZVxuICAgKi9cbiAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5zcXVhcmUgPSBmdW5jdGlvbiAoeCwgeSwgcikge1xuICAgIHRoaXMuYmVnaW5QYXRoKCk7XG4gICAgdGhpcy5yZWN0KHggLSByLCB5IC0gciwgciAqIDIsIHIgKiAyKTtcbiAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEcmF3IGEgdHJpYW5nbGUgc2hhcGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggaG9yaXpvbnRhbCBjZW50ZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgdmVydGljYWwgY2VudGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByICAgcmFkaXVzLCBoYWxmIHRoZSBsZW5ndGggb2YgdGhlIHNpZGVzIG9mIHRoZSB0cmlhbmdsZVxuICAgKi9cbiAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS50cmlhbmdsZSA9IGZ1bmN0aW9uICh4LCB5LCByKSB7XG4gICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FcXVpbGF0ZXJhbF90cmlhbmdsZVxuICAgIHRoaXMuYmVnaW5QYXRoKCk7XG5cbiAgICAvLyB0aGUgY2hhbmdlIGluIHJhZGl1cyBhbmQgdGhlIG9mZnNldCBpcyBoZXJlIHRvIGNlbnRlciB0aGUgc2hhcGVcbiAgICByICo9IDEuMTU7XG4gICAgeSArPSAwLjI3NSAqIHI7XG5cbiAgICB2YXIgcyA9IHIgKiAyO1xuICAgIHZhciBzMiA9IHMgLyAyO1xuICAgIHZhciBpciA9IE1hdGguc3FydCgzKSAvIDYgKiBzOyAvLyByYWRpdXMgb2YgaW5uZXIgY2lyY2xlXG4gICAgdmFyIGggPSBNYXRoLnNxcnQocyAqIHMgLSBzMiAqIHMyKTsgLy8gaGVpZ2h0XG5cbiAgICB0aGlzLm1vdmVUbyh4LCB5IC0gKGggLSBpcikpO1xuICAgIHRoaXMubGluZVRvKHggKyBzMiwgeSArIGlyKTtcbiAgICB0aGlzLmxpbmVUbyh4IC0gczIsIHkgKyBpcik7XG4gICAgdGhpcy5saW5lVG8oeCwgeSAtIChoIC0gaXIpKTtcbiAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEcmF3IGEgdHJpYW5nbGUgc2hhcGUgaW4gZG93bndhcmQgb3JpZW50YXRpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggaG9yaXpvbnRhbCBjZW50ZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgdmVydGljYWwgY2VudGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByIHJhZGl1c1xuICAgKi9cbiAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS50cmlhbmdsZURvd24gPSBmdW5jdGlvbiAoeCwgeSwgcikge1xuICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXF1aWxhdGVyYWxfdHJpYW5nbGVcbiAgICB0aGlzLmJlZ2luUGF0aCgpO1xuXG4gICAgLy8gdGhlIGNoYW5nZSBpbiByYWRpdXMgYW5kIHRoZSBvZmZzZXQgaXMgaGVyZSB0byBjZW50ZXIgdGhlIHNoYXBlXG4gICAgciAqPSAxLjE1O1xuICAgIHkgLT0gMC4yNzUgKiByO1xuXG4gICAgdmFyIHMgPSByICogMjtcbiAgICB2YXIgczIgPSBzIC8gMjtcbiAgICB2YXIgaXIgPSBNYXRoLnNxcnQoMykgLyA2ICogczsgLy8gcmFkaXVzIG9mIGlubmVyIGNpcmNsZVxuICAgIHZhciBoID0gTWF0aC5zcXJ0KHMgKiBzIC0gczIgKiBzMik7IC8vIGhlaWdodFxuXG4gICAgdGhpcy5tb3ZlVG8oeCwgeSArIChoIC0gaXIpKTtcbiAgICB0aGlzLmxpbmVUbyh4ICsgczIsIHkgLSBpcik7XG4gICAgdGhpcy5saW5lVG8oeCAtIHMyLCB5IC0gaXIpO1xuICAgIHRoaXMubGluZVRvKHgsIHkgKyAoaCAtIGlyKSk7XG4gICAgdGhpcy5jbG9zZVBhdGgoKTtcbiAgfTtcblxuICAvKipcbiAgICogRHJhdyBhIHN0YXIgc2hhcGUsIGEgc3RhciB3aXRoIDUgcG9pbnRzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IGhvcml6b250YWwgY2VudGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IHZlcnRpY2FsIGNlbnRlclxuICAgKiBAcGFyYW0ge251bWJlcn0gciAgIHJhZGl1cywgaGFsZiB0aGUgbGVuZ3RoIG9mIHRoZSBzaWRlcyBvZiB0aGUgdHJpYW5nbGVcbiAgICovXG4gIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuc3RhciA9IGZ1bmN0aW9uICh4LCB5LCByKSB7XG4gICAgLy8gaHR0cDovL3d3dy5odG1sNWNhbnZhc3R1dG9yaWFscy5jb20vbGFicy9odG1sNS1jYW52YXMtc3Rhci1zcGlubmVyL1xuICAgIHRoaXMuYmVnaW5QYXRoKCk7XG5cbiAgICAvLyB0aGUgY2hhbmdlIGluIHJhZGl1cyBhbmQgdGhlIG9mZnNldCBpcyBoZXJlIHRvIGNlbnRlciB0aGUgc2hhcGVcbiAgICByICo9IDAuODI7XG4gICAgeSArPSAwLjEgKiByO1xuXG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCAxMDsgbisrKSB7XG4gICAgICB2YXIgcmFkaXVzID0gbiAlIDIgPT09IDAgPyByICogMS4zIDogciAqIDAuNTtcbiAgICAgIHRoaXMubGluZVRvKHggKyByYWRpdXMgKiBNYXRoLnNpbihuICogMiAqIE1hdGguUEkgLyAxMCksIHkgLSByYWRpdXMgKiBNYXRoLmNvcyhuICogMiAqIE1hdGguUEkgLyAxMCkpO1xuICAgIH1cblxuICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERyYXcgYSBEaWFtb25kIHNoYXBlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IGhvcml6b250YWwgY2VudGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IHZlcnRpY2FsIGNlbnRlclxuICAgKiBAcGFyYW0ge251bWJlcn0gciAgIHJhZGl1cywgaGFsZiB0aGUgbGVuZ3RoIG9mIHRoZSBzaWRlcyBvZiB0aGUgdHJpYW5nbGVcbiAgICovXG4gIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuZGlhbW9uZCA9IGZ1bmN0aW9uICh4LCB5LCByKSB7XG4gICAgLy8gaHR0cDovL3d3dy5odG1sNWNhbnZhc3R1dG9yaWFscy5jb20vbGFicy9odG1sNS1jYW52YXMtc3Rhci1zcGlubmVyL1xuICAgIHRoaXMuYmVnaW5QYXRoKCk7XG5cbiAgICB0aGlzLmxpbmVUbyh4LCB5ICsgcik7XG4gICAgdGhpcy5saW5lVG8oeCArIHIsIHkpO1xuICAgIHRoaXMubGluZVRvKHgsIHkgLSByKTtcbiAgICB0aGlzLmxpbmVUbyh4IC0gciwgeSk7XG5cbiAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEyNTU1MTIvaG93LXRvLWRyYXctYS1yb3VuZGVkLXJlY3RhbmdsZS1vbi1odG1sLWNhbnZhc1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgKiBAcGFyYW0ge251bWJlcn0gd1xuICAgKiBAcGFyYW0ge251bWJlcn0gaFxuICAgKiBAcGFyYW0ge251bWJlcn0gclxuICAgKi9cbiAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5yb3VuZFJlY3QgPSBmdW5jdGlvbiAoeCwgeSwgdywgaCwgcikge1xuICAgIHZhciByMmQgPSBNYXRoLlBJIC8gMTgwO1xuICAgIGlmICh3IC0gMiAqIHIgPCAwKSB7XG4gICAgICByID0gdyAvIDI7XG4gICAgfSAvL2Vuc3VyZSB0aGF0IHRoZSByYWRpdXMgaXNuJ3QgdG9vIGxhcmdlIGZvciB4XG4gICAgaWYgKGggLSAyICogciA8IDApIHtcbiAgICAgIHIgPSBoIC8gMjtcbiAgICB9IC8vZW5zdXJlIHRoYXQgdGhlIHJhZGl1cyBpc24ndCB0b28gbGFyZ2UgZm9yIHlcbiAgICB0aGlzLmJlZ2luUGF0aCgpO1xuICAgIHRoaXMubW92ZVRvKHggKyByLCB5KTtcbiAgICB0aGlzLmxpbmVUbyh4ICsgdyAtIHIsIHkpO1xuICAgIHRoaXMuYXJjKHggKyB3IC0gciwgeSArIHIsIHIsIHIyZCAqIDI3MCwgcjJkICogMzYwLCBmYWxzZSk7XG4gICAgdGhpcy5saW5lVG8oeCArIHcsIHkgKyBoIC0gcik7XG4gICAgdGhpcy5hcmMoeCArIHcgLSByLCB5ICsgaCAtIHIsIHIsIDAsIHIyZCAqIDkwLCBmYWxzZSk7XG4gICAgdGhpcy5saW5lVG8oeCArIHIsIHkgKyBoKTtcbiAgICB0aGlzLmFyYyh4ICsgciwgeSArIGggLSByLCByLCByMmQgKiA5MCwgcjJkICogMTgwLCBmYWxzZSk7XG4gICAgdGhpcy5saW5lVG8oeCwgeSArIHIpO1xuICAgIHRoaXMuYXJjKHggKyByLCB5ICsgciwgciwgcjJkICogMTgwLCByMmQgKiAyNzAsIGZhbHNlKTtcbiAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIxNzI3OTgvaG93LXRvLWRyYXctYW4tb3ZhbC1pbi1odG1sNS1jYW52YXNcbiAgICpcbiAgICogUG9zdGZpeCAnX3ZpcycgYWRkZWQgdG8gZGlzY2VybiBpdCBmcm9tIHN0YW5kYXJkIG1ldGhvZCBlbGxpcHNlKCkuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoXG4gICAqL1xuICBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLmVsbGlwc2VfdmlzID0gZnVuY3Rpb24gKHgsIHksIHcsIGgpIHtcbiAgICB2YXIga2FwcGEgPSAwLjU1MjI4NDgsXG4gICAgICAgIG94ID0gdyAvIDIgKiBrYXBwYSxcbiAgICAgICAgLy8gY29udHJvbCBwb2ludCBvZmZzZXQgaG9yaXpvbnRhbFxuICAgIG95ID0gaCAvIDIgKiBrYXBwYSxcbiAgICAgICAgLy8gY29udHJvbCBwb2ludCBvZmZzZXQgdmVydGljYWxcbiAgICB4ZSA9IHggKyB3LFxuICAgICAgICAvLyB4LWVuZFxuICAgIHllID0geSArIGgsXG4gICAgICAgIC8vIHktZW5kXG4gICAgeG0gPSB4ICsgdyAvIDIsXG4gICAgICAgIC8vIHgtbWlkZGxlXG4gICAgeW0gPSB5ICsgaCAvIDI7IC8vIHktbWlkZGxlXG5cbiAgICB0aGlzLmJlZ2luUGF0aCgpO1xuICAgIHRoaXMubW92ZVRvKHgsIHltKTtcbiAgICB0aGlzLmJlemllckN1cnZlVG8oeCwgeW0gLSBveSwgeG0gLSBveCwgeSwgeG0sIHkpO1xuICAgIHRoaXMuYmV6aWVyQ3VydmVUbyh4bSArIG94LCB5LCB4ZSwgeW0gLSBveSwgeGUsIHltKTtcbiAgICB0aGlzLmJlemllckN1cnZlVG8oeGUsIHltICsgb3ksIHhtICsgb3gsIHllLCB4bSwgeWUpO1xuICAgIHRoaXMuYmV6aWVyQ3VydmVUbyh4bSAtIG94LCB5ZSwgeCwgeW0gKyBveSwgeCwgeW0pO1xuICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjE3Mjc5OC9ob3ctdG8tZHJhdy1hbi1vdmFsLWluLWh0bWw1LWNhbnZhc1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgKiBAcGFyYW0ge251bWJlcn0gd1xuICAgKiBAcGFyYW0ge251bWJlcn0gaFxuICAgKi9cbiAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5kYXRhYmFzZSA9IGZ1bmN0aW9uICh4LCB5LCB3LCBoKSB7XG4gICAgdmFyIGYgPSAxIC8gMztcbiAgICB2YXIgd0VsbGlwc2UgPSB3O1xuICAgIHZhciBoRWxsaXBzZSA9IGggKiBmO1xuXG4gICAgdmFyIGthcHBhID0gMC41NTIyODQ4LFxuICAgICAgICBveCA9IHdFbGxpcHNlIC8gMiAqIGthcHBhLFxuICAgICAgICAvLyBjb250cm9sIHBvaW50IG9mZnNldCBob3Jpem9udGFsXG4gICAgb3kgPSBoRWxsaXBzZSAvIDIgKiBrYXBwYSxcbiAgICAgICAgLy8gY29udHJvbCBwb2ludCBvZmZzZXQgdmVydGljYWxcbiAgICB4ZSA9IHggKyB3RWxsaXBzZSxcbiAgICAgICAgLy8geC1lbmRcbiAgICB5ZSA9IHkgKyBoRWxsaXBzZSxcbiAgICAgICAgLy8geS1lbmRcbiAgICB4bSA9IHggKyB3RWxsaXBzZSAvIDIsXG4gICAgICAgIC8vIHgtbWlkZGxlXG4gICAgeW0gPSB5ICsgaEVsbGlwc2UgLyAyLFxuICAgICAgICAvLyB5LW1pZGRsZVxuICAgIHltYiA9IHkgKyAoaCAtIGhFbGxpcHNlIC8gMiksXG4gICAgICAgIC8vIHktbWlkbGxlLCBib3R0b20gZWxsaXBzZVxuICAgIHllYiA9IHkgKyBoOyAvLyB5LWVuZCwgYm90dG9tIGVsbGlwc2VcblxuICAgIHRoaXMuYmVnaW5QYXRoKCk7XG4gICAgdGhpcy5tb3ZlVG8oeGUsIHltKTtcblxuICAgIHRoaXMuYmV6aWVyQ3VydmVUbyh4ZSwgeW0gKyBveSwgeG0gKyBveCwgeWUsIHhtLCB5ZSk7XG4gICAgdGhpcy5iZXppZXJDdXJ2ZVRvKHhtIC0gb3gsIHllLCB4LCB5bSArIG95LCB4LCB5bSk7XG5cbiAgICB0aGlzLmJlemllckN1cnZlVG8oeCwgeW0gLSBveSwgeG0gLSBveCwgeSwgeG0sIHkpO1xuICAgIHRoaXMuYmV6aWVyQ3VydmVUbyh4bSArIG94LCB5LCB4ZSwgeW0gLSBveSwgeGUsIHltKTtcblxuICAgIHRoaXMubGluZVRvKHhlLCB5bWIpO1xuXG4gICAgdGhpcy5iZXppZXJDdXJ2ZVRvKHhlLCB5bWIgKyBveSwgeG0gKyBveCwgeWViLCB4bSwgeWViKTtcbiAgICB0aGlzLmJlemllckN1cnZlVG8oeG0gLSBveCwgeWViLCB4LCB5bWIgKyBveSwgeCwgeW1iKTtcblxuICAgIHRoaXMubGluZVRvKHgsIHltKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB1cCB0aGUgZGFzaGVkTGluZSBmdW5jdGlvbmFsaXR5IGZvciBkcmF3aW5nXG4gICAqIE9yaWdpbmFsIGNvZGUgY2FtZSBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDU3NjcyNC9kb3R0ZWQtc3Ryb2tlLWluLWNhbnZhc1xuICAgKiBAYXV0aG9yIERhdmlkIEpvcmRhblxuICAgKiBAZGF0ZSAyMDEyLTA4LTA4XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4MlxuICAgKiBAcGFyYW0ge251bWJlcn0geTJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdHRlcm5cbiAgICovXG4gIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuZGFzaGVkTGluZSA9IGZ1bmN0aW9uICh4LCB5LCB4MiwgeTIsIHBhdHRlcm4pIHtcbiAgICB0aGlzLmJlZ2luUGF0aCgpO1xuICAgIHRoaXMubW92ZVRvKHgsIHkpO1xuXG4gICAgdmFyIHBhdHRlcm5MZW5ndGggPSBwYXR0ZXJuLmxlbmd0aDtcbiAgICB2YXIgZHggPSB4MiAtIHg7XG4gICAgdmFyIGR5ID0geTIgLSB5O1xuICAgIHZhciBzbG9wZSA9IGR5IC8gZHg7XG4gICAgdmFyIGRpc3RSZW1haW5pbmcgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIHZhciBwYXR0ZXJuSW5kZXggPSAwO1xuICAgIHZhciBkcmF3ID0gdHJ1ZTtcbiAgICB2YXIgeFN0ZXAgPSAwO1xuICAgIHZhciBkYXNoTGVuZ3RoID0gcGF0dGVyblswXTtcblxuICAgIHdoaWxlIChkaXN0UmVtYWluaW5nID49IDAuMSkge1xuICAgICAgZGFzaExlbmd0aCA9IHBhdHRlcm5bcGF0dGVybkluZGV4KysgJSBwYXR0ZXJuTGVuZ3RoXTtcbiAgICAgIGlmIChkYXNoTGVuZ3RoID4gZGlzdFJlbWFpbmluZykge1xuICAgICAgICBkYXNoTGVuZ3RoID0gZGlzdFJlbWFpbmluZztcbiAgICAgIH1cblxuICAgICAgeFN0ZXAgPSBNYXRoLnNxcnQoZGFzaExlbmd0aCAqIGRhc2hMZW5ndGggLyAoMSArIHNsb3BlICogc2xvcGUpKTtcbiAgICAgIHhTdGVwID0gZHggPCAwID8gLXhTdGVwIDogeFN0ZXA7XG4gICAgICB4ICs9IHhTdGVwO1xuICAgICAgeSArPSBzbG9wZSAqIHhTdGVwO1xuXG4gICAgICBpZiAoZHJhdyA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmxpbmVUbyh4LCB5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubW92ZVRvKHgsIHkpO1xuICAgICAgfVxuXG4gICAgICBkaXN0UmVtYWluaW5nIC09IGRhc2hMZW5ndGg7XG4gICAgICBkcmF3ID0gIWRyYXc7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBEcmF3IGEgSGV4YWdvbiBzaGFwZSB3aXRoIDYgc2lkZXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHggaG9yaXpvbnRhbCBjZW50ZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkgdmVydGljYWwgY2VudGVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByICAgcmFkaXVzXG4gICAqL1xuICBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLmhleGFnb24gPSBmdW5jdGlvbiAoeCwgeSwgcikge1xuICAgIHRoaXMuYmVnaW5QYXRoKCk7XG4gICAgdmFyIHNpZGVzID0gNjtcbiAgICB2YXIgYSA9IE1hdGguUEkgKiAyIC8gc2lkZXM7XG4gICAgdGhpcy5tb3ZlVG8oeCArIHIsIHkpO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgc2lkZXM7IGkrKykge1xuICAgICAgdGhpcy5saW5lVG8oeCArIHIgKiBNYXRoLmNvcyhhICogaSksIHkgKyByICogTWF0aC5zaW4oYSAqIGkpKTtcbiAgICB9XG4gICAgdGhpcy5jbG9zZVBhdGgoKTtcbiAgfTtcbn1cblxuLyoqKi8gfSksXG4vKiAxMjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGtleWNoYXJtID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Mik7XG52YXIgRW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oNzMpO1xudmFyIEhhbW1lciA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG4vKipcbiAqIFR1cm4gYW4gZWxlbWVudCBpbnRvIGFuIGNsaWNrVG9Vc2UgZWxlbWVudC5cbiAqIFdoZW4gbm90IGFjdGl2ZSwgdGhlIGVsZW1lbnQgaGFzIGEgdHJhbnNwYXJlbnQgb3ZlcmxheS4gV2hlbiB0aGUgb3ZlcmxheSBpc1xuICogY2xpY2tlZCwgdGhlIG1vZGUgaXMgY2hhbmdlZCB0byBhY3RpdmUuXG4gKiBXaGVuIGFjdGl2ZSwgdGhlIGVsZW1lbnQgaXMgZGlzcGxheWVkIHdpdGggYSBibHVlIGJvcmRlciBhcm91bmQgaXQsIGFuZFxuICogdGhlIGludGVyYWN0aXZlIGNvbnRlbnRzIG9mIHRoZSBlbGVtZW50IGNhbiBiZSB1c2VkLiBXaGVuIGNsaWNrZWQgb3V0c2lkZVxuICogdGhlIGVsZW1lbnQsIHRoZSBlbGVtZW50cyBtb2RlIGlzIGNoYW5nZWQgdG8gaW5hY3RpdmUuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRhaW5lclxuICogQGNvbnN0cnVjdG9yIEFjdGl2YXRvclxuICovXG5mdW5jdGlvbiBBY3RpdmF0b3IoY29udGFpbmVyKSB7XG4gIHRoaXMuYWN0aXZlID0gZmFsc2U7XG5cbiAgdGhpcy5kb20gPSB7XG4gICAgY29udGFpbmVyOiBjb250YWluZXJcbiAgfTtcblxuICB0aGlzLmRvbS5vdmVybGF5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLm92ZXJsYXkuY2xhc3NOYW1lID0gJ3Zpcy1vdmVybGF5JztcblxuICB0aGlzLmRvbS5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kb20ub3ZlcmxheSk7XG5cbiAgdGhpcy5oYW1tZXIgPSBIYW1tZXIodGhpcy5kb20ub3ZlcmxheSk7XG4gIHRoaXMuaGFtbWVyLm9uKCd0YXAnLCB0aGlzLl9vblRhcE92ZXJsYXkuYmluZCh0aGlzKSk7XG5cbiAgLy8gYmxvY2sgYWxsIHRvdWNoIGV2ZW50cyAoZXhjZXB0IHRhcClcbiAgdmFyIG1lID0gdGhpcztcbiAgdmFyIGV2ZW50cyA9IFsndGFwJywgJ2RvdWJsZXRhcCcsICdwcmVzcycsICdwaW5jaCcsICdwYW4nLCAncGFuc3RhcnQnLCAncGFubW92ZScsICdwYW5lbmQnXTtcbiAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgbWUuaGFtbWVyLm9uKGV2ZW50LCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBhdHRhY2ggYSBjbGljayBldmVudCB0byB0aGUgd2luZG93LCBpbiBvcmRlciB0byBkZWFjdGl2YXRlIHdoZW4gY2xpY2tpbmcgb3V0c2lkZSB0aGUgdGltZWxpbmVcbiAgaWYgKGRvY3VtZW50ICYmIGRvY3VtZW50LmJvZHkpIHtcbiAgICB0aGlzLm9uQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmICghX2hhc1BhcmVudChldmVudC50YXJnZXQsIGNvbnRhaW5lcikpIHtcbiAgICAgICAgbWUuZGVhY3RpdmF0ZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25DbGljayk7XG4gIH1cblxuICBpZiAodGhpcy5rZXljaGFybSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5rZXljaGFybS5kZXN0cm95KCk7XG4gIH1cbiAgdGhpcy5rZXljaGFybSA9IGtleWNoYXJtKCk7XG5cbiAgLy8ga2V5Y2hhcm0gbGlzdGVuZXIgb25seSBib3VuZGVkIHdoZW4gYWN0aXZlKVxuICB0aGlzLmVzY0xpc3RlbmVyID0gdGhpcy5kZWFjdGl2YXRlLmJpbmQodGhpcyk7XG59XG5cbi8vIHR1cm4gaW50byBhbiBldmVudCBlbWl0dGVyXG5FbWl0dGVyKEFjdGl2YXRvci5wcm90b3R5cGUpO1xuXG4vLyBUaGUgY3VycmVudGx5IGFjdGl2ZSBhY3RpdmF0b3JcbkFjdGl2YXRvci5jdXJyZW50ID0gbnVsbDtcblxuLyoqXG4gKiBEZXN0cm95IHRoZSBhY3RpdmF0b3IuIENsZWFucyB1cCBhbGwgY3JlYXRlZCBET00gYW5kIGV2ZW50IGxpc3RlbmVyc1xuICovXG5BY3RpdmF0b3IucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZGVhY3RpdmF0ZSgpO1xuXG4gIC8vIHJlbW92ZSBkb21cbiAgdGhpcy5kb20ub3ZlcmxheS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLm92ZXJsYXkpO1xuXG4gIC8vIHJlbW92ZSBnbG9iYWwgZXZlbnQgbGlzdGVuZXJcbiAgaWYgKHRoaXMub25DbGljaykge1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uQ2xpY2spO1xuICB9XG4gIC8vIHJlbW92ZSBrZXljaGFybVxuICBpZiAodGhpcy5rZXljaGFybSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5rZXljaGFybS5kZXN0cm95KCk7XG4gIH1cbiAgdGhpcy5rZXljaGFybSA9IG51bGw7XG4gIC8vIGNsZWFudXAgaGFtbWVyIGluc3RhbmNlc1xuICB0aGlzLmhhbW1lci5kZXN0cm95KCk7XG4gIHRoaXMuaGFtbWVyID0gbnVsbDtcbiAgLy8gRklYTUU6IGNsZWFuaW5nIHVwIGhhbW1lciBpbnN0YW5jZXMgZG9lc24ndCB3b3JrIChUaW1lbGluZSBub3QgcmVtb3ZlZCBmcm9tIG1lbW9yeSlcbn07XG5cbi8qKlxuICogQWN0aXZhdGUgdGhlIGVsZW1lbnRcbiAqIE92ZXJsYXkgaXMgaGlkZGVuLCBlbGVtZW50IGlzIGRlY29yYXRlZCB3aXRoIGEgYmx1ZSBzaGFkb3cgYm9yZGVyXG4gKi9cbkFjdGl2YXRvci5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIHdlIGFsbG93IG9ubHkgb25lIGFjdGl2ZSBhY3RpdmF0b3IgYXQgYSB0aW1lXG4gIGlmIChBY3RpdmF0b3IuY3VycmVudCkge1xuICAgIEFjdGl2YXRvci5jdXJyZW50LmRlYWN0aXZhdGUoKTtcbiAgfVxuICBBY3RpdmF0b3IuY3VycmVudCA9IHRoaXM7XG5cbiAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICB0aGlzLmRvbS5vdmVybGF5LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHV0aWwuYWRkQ2xhc3NOYW1lKHRoaXMuZG9tLmNvbnRhaW5lciwgJ3Zpcy1hY3RpdmUnKTtcblxuICB0aGlzLmVtaXQoJ2NoYW5nZScpO1xuICB0aGlzLmVtaXQoJ2FjdGl2YXRlJyk7XG5cbiAgLy8gdWdseSBoYWNrOiBiaW5kIEVTQyBhZnRlciBlbWl0dGluZyB0aGUgZXZlbnRzLCBhcyB0aGUgTmV0d29yayByZWJpbmRzIGFsbFxuICAvLyBrZXlib2FyZCBldmVudHMgb24gYSAnY2hhbmdlJyBldmVudFxuICB0aGlzLmtleWNoYXJtLmJpbmQoJ2VzYycsIHRoaXMuZXNjTGlzdGVuZXIpO1xufTtcblxuLyoqXG4gKiBEZWFjdGl2YXRlIHRoZSBlbGVtZW50XG4gKiBPdmVybGF5IGlzIGRpc3BsYXllZCBvbiB0b3Agb2YgdGhlIGVsZW1lbnRcbiAqL1xuQWN0aXZhdG9yLnByb3RvdHlwZS5kZWFjdGl2YXRlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICB0aGlzLmRvbS5vdmVybGF5LnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgdXRpbC5yZW1vdmVDbGFzc05hbWUodGhpcy5kb20uY29udGFpbmVyLCAndmlzLWFjdGl2ZScpO1xuICB0aGlzLmtleWNoYXJtLnVuYmluZCgnZXNjJywgdGhpcy5lc2NMaXN0ZW5lcik7XG5cbiAgdGhpcy5lbWl0KCdjaGFuZ2UnKTtcbiAgdGhpcy5lbWl0KCdkZWFjdGl2YXRlJyk7XG59O1xuXG4vKipcbiAqIEhhbmRsZSBhIHRhcCBldmVudDogYWN0aXZhdGUgdGhlIGNvbnRhaW5lclxuICogQHBhcmFtIHtFdmVudH0gIGV2ZW50ICAgVGhlIGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5BY3RpdmF0b3IucHJvdG90eXBlLl9vblRhcE92ZXJsYXkgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgLy8gYWN0aXZhdGUgdGhlIGNvbnRhaW5lclxuICB0aGlzLmFjdGl2YXRlKCk7XG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xufTtcblxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgdGhlIGVsZW1lbnQgaGFzIHRoZSByZXF1ZXN0ZWQgcGFyZW50IGVsZW1lbnQgc29tZXdoZXJlIGluXG4gKiBpdHMgY2hhaW4gb2YgcGFyZW50IG5vZGVzLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIHdoZW4gdGhlIHBhcmVudCBpcyBmb3VuZCBzb21ld2hlcmUgaW4gdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgY2hhaW4gb2YgcGFyZW50IG5vZGVzLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2hhc1BhcmVudChlbGVtZW50LCBwYXJlbnQpIHtcbiAgd2hpbGUgKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudCA9PT0gcGFyZW50KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQWN0aXZhdG9yO1xuXG4vKioqLyB9KSxcbi8qIDEyNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fO1xuXG4oZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgaWYgKHRydWUpIHtcbiAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgIShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW10sIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9IChmYWN0b3J5KSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/XG5cdFx0XHRcdChfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18uYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXykpIDogX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgIC8vIE5vZGUuIERvZXMgbm90IHdvcmsgd2l0aCBzdHJpY3QgQ29tbW9uSlMsIGJ1dFxuICAgIC8vIG9ubHkgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxuICAgIC8vIGxpa2UgTm9kZS5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBCcm93c2VyIGdsb2JhbHMgKHJvb3QgaXMgd2luZG93KVxuICAgIHdpbmRvdy5wcm9wYWdhdGluZyA9IGZhY3RvcnkoKTtcbiAgfVxufShmdW5jdGlvbiAoKSB7XG4gIHZhciBfZmlyc3RUYXJnZXQgPSBudWxsOyAvLyBzaW5nbGV0b24sIHdpbGwgY29udGFpbiB0aGUgdGFyZ2V0IGVsZW1lbnQgd2hlcmUgdGhlIHRvdWNoIGV2ZW50IHN0YXJ0ZWRcblxuICAvKipcbiAgICogRXh0ZW5kIGFuIEhhbW1lci5qcyBpbnN0YW5jZSB3aXRoIGV2ZW50IHByb3BhZ2F0aW9uLlxuICAgKlxuICAgKiBGZWF0dXJlczpcbiAgICogLSBFdmVudHMgZW1pdHRlZCBieSBoYW1tZXIgd2lsbCBwcm9wYWdhdGUgaW4gb3JkZXIgZnJvbSBjaGlsZCB0byBwYXJlbnRcbiAgICogICBlbGVtZW50cy5cbiAgICogLSBFdmVudHMgYXJlIGV4dGVuZGVkIHdpdGggYSBmdW5jdGlvbiBgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClgIHRvIHN0b3BcbiAgICogICBwcm9wYWdhdGlvbiB0byBwYXJlbnQgZWxlbWVudHMuXG4gICAqIC0gQW4gb3B0aW9uIGBwcmV2ZW50RGVmYXVsdGAgdG8gc3RvcCBhbGwgZGVmYXVsdCBicm93c2VyIGJlaGF2aW9yLlxuICAgKlxuICAgKiBVc2FnZTpcbiAgICogICB2YXIgaGFtbWVyID0gcHJvcGFnYXRpbmdIYW1tZXIobmV3IEhhbW1lcihlbGVtZW50KSk7XG4gICAqICAgdmFyIGhhbW1lciA9IHByb3BhZ2F0aW5nSGFtbWVyKG5ldyBIYW1tZXIoZWxlbWVudCksIHtwcmV2ZW50RGVmYXVsdDogdHJ1ZX0pO1xuICAgKlxuICAgKiBAcGFyYW0ge0hhbW1lci5NYW5hZ2VyfSBoYW1tZXIgICBBbiBoYW1tZXIgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgICAgIEF2YWlsYWJsZSBvcHRpb25zOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIGBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB8IGZhbHNlIHwgJ21vdXNlJyB8ICd0b3VjaCcgfCAncGVuJ2AuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRW5mb3JjZSBwcmV2ZW50aW5nIHRoZSBkZWZhdWx0IGJyb3dzZXIgYmVoYXZpb3IuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2Fubm90IGJlIHNldCB0byBgZmFsc2VgLlxuICAgKiBAcmV0dXJuIHtIYW1tZXIuTWFuYWdlcn0gUmV0dXJucyB0aGUgc2FtZSBoYW1tZXIgaW5zdGFuY2Ugd2l0aCBleHRlbmRlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25hbGl0eVxuICAgKi9cbiAgcmV0dXJuIGZ1bmN0aW9uIHByb3BhZ2F0aW5nKGhhbW1lciwgb3B0aW9ucykge1xuICAgIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMgfHwge1xuICAgICAgcHJldmVudERlZmF1bHQ6IGZhbHNlXG4gICAgfTtcblxuICAgIGlmIChoYW1tZXIuTWFuYWdlcikge1xuICAgICAgLy8gVGhpcyBsb29rcyBsaWtlIHRoZSBIYW1tZXIgY29uc3RydWN0b3IuXG4gICAgICAvLyBPdmVybG9hZCB0aGUgY29uc3RydWN0b3JzIHdpdGggb3VyIG93bi5cbiAgICAgIHZhciBIYW1tZXIgPSBoYW1tZXI7XG5cbiAgICAgIHZhciBQcm9wYWdhdGluZ0hhbW1lciA9IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG8gPSBPYmplY3QuY3JlYXRlKF9vcHRpb25zKTtcbiAgICAgICAgaWYgKG9wdGlvbnMpIEhhbW1lci5hc3NpZ24obywgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBwcm9wYWdhdGluZyhuZXcgSGFtbWVyKGVsZW1lbnQsIG8pLCBvKTtcbiAgICAgIH07XG4gICAgICBIYW1tZXIuYXNzaWduKFByb3BhZ2F0aW5nSGFtbWVyLCBIYW1tZXIpO1xuXG4gICAgICBQcm9wYWdhdGluZ0hhbW1lci5NYW5hZ2VyID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG8gPSBPYmplY3QuY3JlYXRlKF9vcHRpb25zKTtcbiAgICAgICAgaWYgKG9wdGlvbnMpIEhhbW1lci5hc3NpZ24obywgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBwcm9wYWdhdGluZyhuZXcgSGFtbWVyLk1hbmFnZXIoZWxlbWVudCwgbyksIG8pO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIFByb3BhZ2F0aW5nSGFtbWVyO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBhIHdyYXBwZXIgb2JqZWN0IHdoaWNoIHdpbGwgb3ZlcnJpZGUgdGhlIGZ1bmN0aW9uc1xuICAgIC8vIGBvbmAsIGBvZmZgLCBgZGVzdHJveWAsIGFuZCBgZW1pdGAgb2YgdGhlIGhhbW1lciBpbnN0YW5jZVxuICAgIHZhciB3cmFwcGVyID0gT2JqZWN0LmNyZWF0ZShoYW1tZXIpO1xuXG4gICAgLy8gYXR0YWNoIHRvIERPTSBlbGVtZW50XG4gICAgdmFyIGVsZW1lbnQgPSBoYW1tZXIuZWxlbWVudDtcblxuICAgIGlmKCFlbGVtZW50LmhhbW1lcikgZWxlbWVudC5oYW1tZXIgPSBbXTtcbiAgICBlbGVtZW50LmhhbW1lci5wdXNoKHdyYXBwZXIpO1xuXG4gICAgLy8gcmVnaXN0ZXIgYW4gZXZlbnQgdG8gY2F0Y2ggdGhlIHN0YXJ0IG9mIGEgZ2VzdHVyZSBhbmQgc3RvcmUgdGhlXG4gICAgLy8gdGFyZ2V0IGluIGEgc2luZ2xldG9uXG4gICAgaGFtbWVyLm9uKCdoYW1tZXIuaW5wdXQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChfb3B0aW9ucy5wcmV2ZW50RGVmYXVsdCA9PT0gdHJ1ZSB8fCAoX29wdGlvbnMucHJldmVudERlZmF1bHQgPT09IGV2ZW50LnBvaW50ZXJUeXBlKSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmlzRmlyc3QpIHtcbiAgICAgICAgX2ZpcnN0VGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqIEB0eXBlIHtPYmplY3QuPFN0cmluZywgQXJyYXkuPGZ1bmN0aW9uPj59ICovXG4gICAgd3JhcHBlci5faGFuZGxlcnMgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgaGFuZGxlciBmb3Igb25lIG9yIG11bHRpcGxlIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudHMgICAgQSBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIHdpdGggZXZlbnRzXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciBBIGNhbGxiYWNrIGZ1bmN0aW9uLCBjYWxsZWQgYXMgaGFuZGxlcihldmVudClcbiAgICAgKiBAcmV0dXJucyB7SGFtbWVyLk1hbmFnZXJ9IFJldHVybnMgdGhlIGhhbW1lciBpbnN0YW5jZVxuICAgICAqL1xuICAgIHdyYXBwZXIub24gPSBmdW5jdGlvbiAoZXZlbnRzLCBoYW5kbGVyKSB7XG4gICAgICAvLyByZWdpc3RlciB0aGUgaGFuZGxlclxuICAgICAgc3BsaXQoZXZlbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgX2hhbmRsZXJzID0gd3JhcHBlci5faGFuZGxlcnNbZXZlbnRdO1xuICAgICAgICBpZiAoIV9oYW5kbGVycykge1xuICAgICAgICAgIHdyYXBwZXIuX2hhbmRsZXJzW2V2ZW50XSA9IF9oYW5kbGVycyA9IFtdO1xuXG4gICAgICAgICAgLy8gcmVnaXN0ZXIgdGhlIHN0YXRpYywgcHJvcGFnYXRlZCBoYW5kbGVyXG4gICAgICAgICAgaGFtbWVyLm9uKGV2ZW50LCBwcm9wYWdhdGVkSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgX2hhbmRsZXJzLnB1c2goaGFuZGxlcik7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVucmVnaXN0ZXIgYSBoYW5kbGVyIGZvciBvbmUgb3IgbXVsdGlwbGUgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50cyAgICAgIEEgc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyB3aXRoIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtoYW5kbGVyXSBPcHRpb25hbC4gVGhlIHJlZ2lzdGVyZWQgaGFuZGxlci4gSWYgbm90XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVkLCBhbGwgaGFuZGxlcnMgZm9yIGdpdmVuIGV2ZW50c1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmUgcmVtb3ZlZC5cbiAgICAgKiBAcmV0dXJucyB7SGFtbWVyLk1hbmFnZXJ9ICAgUmV0dXJucyB0aGUgaGFtbWVyIGluc3RhbmNlXG4gICAgICovXG4gICAgd3JhcHBlci5vZmYgPSBmdW5jdGlvbiAoZXZlbnRzLCBoYW5kbGVyKSB7XG4gICAgICAvLyB1bnJlZ2lzdGVyIHRoZSBoYW5kbGVyXG4gICAgICBzcGxpdChldmVudHMpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBfaGFuZGxlcnMgPSB3cmFwcGVyLl9oYW5kbGVyc1tldmVudF07XG4gICAgICAgIGlmIChfaGFuZGxlcnMpIHtcbiAgICAgICAgICBfaGFuZGxlcnMgPSBoYW5kbGVyID8gX2hhbmRsZXJzLmZpbHRlcihmdW5jdGlvbiAoaCkge1xuICAgICAgICAgICAgcmV0dXJuIGggIT09IGhhbmRsZXI7XG4gICAgICAgICAgfSkgOiBbXTtcblxuICAgICAgICAgIGlmIChfaGFuZGxlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgd3JhcHBlci5faGFuZGxlcnNbZXZlbnRdID0gX2hhbmRsZXJzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBzdGF0aWMsIHByb3BhZ2F0ZWQgaGFuZGxlclxuICAgICAgICAgICAgaGFtbWVyLm9mZihldmVudCwgcHJvcGFnYXRlZEhhbmRsZXIpO1xuICAgICAgICAgICAgZGVsZXRlIHdyYXBwZXIuX2hhbmRsZXJzW2V2ZW50XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRW1pdCB0byB0aGUgZXZlbnQgbGlzdGVuZXJzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICovXG4gICAgd3JhcHBlci5lbWl0ID0gZnVuY3Rpb24oZXZlbnRUeXBlLCBldmVudCkge1xuICAgICAgX2ZpcnN0VGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgaGFtbWVyLmVtaXQoZXZlbnRUeXBlLCBldmVudCk7XG4gICAgfTtcblxuICAgIHdyYXBwZXIuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIERldGFjaCBmcm9tIERPTSBlbGVtZW50XG4gICAgICB2YXIgaGFtbWVycyA9IGhhbW1lci5lbGVtZW50LmhhbW1lcjtcbiAgICAgIHZhciBpZHggPSBoYW1tZXJzLmluZGV4T2Yod3JhcHBlcik7XG4gICAgICBpZihpZHggIT09IC0xKSBoYW1tZXJzLnNwbGljZShpZHgsMSk7XG4gICAgICBpZighaGFtbWVycy5sZW5ndGgpIGRlbGV0ZSBoYW1tZXIuZWxlbWVudC5oYW1tZXI7XG5cbiAgICAgIC8vIGNsZWFyIGFsbCBoYW5kbGVyc1xuICAgICAgd3JhcHBlci5faGFuZGxlcnMgPSB7fTtcblxuICAgICAgLy8gY2FsbCBvcmlnaW5hbCBoYW1tZXIgZGVzdHJveVxuICAgICAgaGFtbWVyLmRlc3Ryb3koKTtcbiAgICB9O1xuXG4gICAgLy8gc3BsaXQgYSBzdHJpbmcgd2l0aCBzcGFjZSBzZXBhcmF0ZWQgd29yZHNcbiAgICBmdW5jdGlvbiBzcGxpdChldmVudHMpIHtcbiAgICAgIHJldHVybiBldmVudHMubWF0Y2goL1teIF0rL2cpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3RhdGljIGV2ZW50IGhhbmRsZXIsIGFwcGx5aW5nIGV2ZW50IHByb3BhZ2F0aW9uLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb3BhZ2F0ZWRIYW5kbGVyKGV2ZW50KSB7XG4gICAgICAvLyBsZXQgb25seSBhIHNpbmdsZSBoYW1tZXIgaW5zdGFuY2UgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgIGlmIChldmVudC50eXBlICE9PSAnaGFtbWVyLmlucHV0Jykge1xuICAgICAgICAvLyBpdCBpcyBwb3NzaWJsZSB0aGF0IHRoZSBzYW1lIHNyY0V2ZW50IGlzIHVzZWQgd2l0aCBtdWx0aXBsZSBoYW1tZXIgZXZlbnRzLFxuICAgICAgICAvLyB3ZSBrZWVwIHRyYWNrIG9uIHdoaWNoIGV2ZW50cyBhcmUgaGFuZGxlZCBpbiBhbiBvYmplY3QgX2hhbmRsZWRcbiAgICAgICAgaWYgKCFldmVudC5zcmNFdmVudC5faGFuZGxlZCkge1xuICAgICAgICAgIGV2ZW50LnNyY0V2ZW50Ll9oYW5kbGVkID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQuc3JjRXZlbnQuX2hhbmRsZWRbZXZlbnQudHlwZV0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZXZlbnQuc3JjRXZlbnQuX2hhbmRsZWRbZXZlbnQudHlwZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGF0dGFjaCBhIHN0b3BQcm9wYWdhdGlvbiBmdW5jdGlvbiB0byB0aGUgZXZlbnRcbiAgICAgIHZhciBzdG9wcGVkID0gZmFsc2U7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgfTtcblxuICAgICAgLy93cmFwIHRoZSBzcmNFdmVudCdzIHN0b3BQcm9wYWdhdGlvbiB0byBhbHNvIHN0b3AgaGFtbWVyIHByb3BhZ2F0aW9uOlxuICAgICAgdmFyIHNyY1N0b3AgPSBldmVudC5zcmNFdmVudC5zdG9wUHJvcGFnYXRpb24uYmluZChldmVudC5zcmNFdmVudCk7XG4gICAgICBpZih0eXBlb2Ygc3JjU3RvcCA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgZXZlbnQuc3JjRXZlbnQuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICBzcmNTdG9wKCk7XG4gICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gYXR0YWNoIGZpcnN0VGFyZ2V0IHByb3BlcnR5IHRvIHRoZSBldmVudFxuICAgICAgZXZlbnQuZmlyc3RUYXJnZXQgPSBfZmlyc3RUYXJnZXQ7XG5cbiAgICAgIC8vIHByb3BhZ2F0ZSBvdmVyIGFsbCBlbGVtZW50cyAodW50aWwgc3RvcHBlZClcbiAgICAgIHZhciBlbGVtID0gX2ZpcnN0VGFyZ2V0O1xuICAgICAgd2hpbGUgKGVsZW0gJiYgIXN0b3BwZWQpIHtcbiAgICAgICAgdmFyIGVsZW1IYW1tZXIgPSBlbGVtLmhhbW1lcjtcbiAgICAgICAgaWYoZWxlbUhhbW1lcil7XG4gICAgICAgICAgdmFyIF9oYW5kbGVycztcbiAgICAgICAgICBmb3IodmFyIGsgPSAwOyBrIDwgZWxlbUhhbW1lci5sZW5ndGg7IGsrKyl7XG4gICAgICAgICAgICBfaGFuZGxlcnMgPSBlbGVtSGFtbWVyW2tdLl9oYW5kbGVyc1tldmVudC50eXBlXTtcbiAgICAgICAgICAgIGlmKF9oYW5kbGVycykgZm9yICh2YXIgaSA9IDA7IGkgPCBfaGFuZGxlcnMubGVuZ3RoICYmICFzdG9wcGVkOyBpKyspIHtcbiAgICAgICAgICAgICAgX2hhbmRsZXJzW2ldKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxlbSA9IGVsZW0ucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gd3JhcHBlcjtcbiAgfTtcbn0pKTtcblxuXG4vKioqLyB9KSxcbi8qIDEyOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187LyohIEhhbW1lci5KUyAtIHYyLjAuNyAtIDIwMTYtMDQtMjJcbiAqIGh0dHA6Ly9oYW1tZXJqcy5naXRodWIuaW8vXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE2IEpvcmlrIFRhbmdlbGRlcjtcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSAqL1xuKGZ1bmN0aW9uKHdpbmRvdywgZG9jdW1lbnQsIGV4cG9ydE5hbWUsIHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbnZhciBWRU5ET1JfUFJFRklYRVMgPSBbJycsICd3ZWJraXQnLCAnTW96JywgJ01TJywgJ21zJywgJ28nXTtcbnZhciBURVNUX0VMRU1FTlQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxudmFyIFRZUEVfRlVOQ1RJT04gPSAnZnVuY3Rpb24nO1xuXG52YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xudmFyIGFicyA9IE1hdGguYWJzO1xudmFyIG5vdyA9IERhdGUubm93O1xuXG4vKipcbiAqIHNldCBhIHRpbWVvdXQgd2l0aCBhIGdpdmVuIHNjb3BlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBzZXRUaW1lb3V0Q29udGV4dChmbiwgdGltZW91dCwgY29udGV4dCkge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGJpbmRGbihmbiwgY29udGV4dCksIHRpbWVvdXQpO1xufVxuXG4vKipcbiAqIGlmIHRoZSBhcmd1bWVudCBpcyBhbiBhcnJheSwgd2Ugd2FudCB0byBleGVjdXRlIHRoZSBmbiBvbiBlYWNoIGVudHJ5XG4gKiBpZiBpdCBhaW50IGFuIGFycmF5IHdlIGRvbid0IHdhbnQgdG8gZG8gYSB0aGluZy5cbiAqIHRoaXMgaXMgdXNlZCBieSBhbGwgdGhlIG1ldGhvZHMgdGhhdCBhY2NlcHQgYSBzaW5nbGUgYW5kIGFycmF5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfEFycmF5fSBhcmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBmblxuICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGludm9rZUFycmF5QXJnKGFyZywgZm4sIGNvbnRleHQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgIGVhY2goYXJnLCBjb250ZXh0W2ZuXSwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogd2FsayBvYmplY3RzIGFuZCBhcnJheXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICovXG5mdW5jdGlvbiBlYWNoKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICB2YXIgaTtcblxuICAgIGlmICghb2JqKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob2JqLmZvckVhY2gpIHtcbiAgICAgICAgb2JqLmZvckVhY2goaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IG9iai5sZW5ndGgpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICAgICAgb2JqLmhhc093blByb3BlcnR5KGkpICYmIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIHdyYXAgYSBtZXRob2Qgd2l0aCBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgYW5kIHN0YWNrIHRyYWNlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIG5ldyBmdW5jdGlvbiB3cmFwcGluZyB0aGUgc3VwcGxpZWQgbWV0aG9kLlxuICovXG5mdW5jdGlvbiBkZXByZWNhdGUobWV0aG9kLCBuYW1lLCBtZXNzYWdlKSB7XG4gICAgdmFyIGRlcHJlY2F0aW9uTWVzc2FnZSA9ICdERVBSRUNBVEVEIE1FVEhPRDogJyArIG5hbWUgKyAnXFxuJyArIG1lc3NhZ2UgKyAnIEFUIFxcbic7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZSA9IG5ldyBFcnJvcignZ2V0LXN0YWNrLXRyYWNlJyk7XG4gICAgICAgIHZhciBzdGFjayA9IGUgJiYgZS5zdGFjayA/IGUuc3RhY2sucmVwbGFjZSgvXlteXFwoXSs/W1xcbiRdL2dtLCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9eXFxzK2F0XFxzKy9nbSwgJycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXk9iamVjdC48YW5vbnltb3VzPlxccypcXCgvZ20sICd7YW5vbnltb3VzfSgpQCcpIDogJ1Vua25vd24gU3RhY2sgVHJhY2UnO1xuXG4gICAgICAgIHZhciBsb2cgPSB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUud2FybiB8fCB3aW5kb3cuY29uc29sZS5sb2cpO1xuICAgICAgICBpZiAobG9nKSB7XG4gICAgICAgICAgICBsb2cuY2FsbCh3aW5kb3cuY29uc29sZSwgZGVwcmVjYXRpb25NZXNzYWdlLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbi8qKlxuICogZXh0ZW5kIG9iamVjdC5cbiAqIG1lYW5zIHRoYXQgcHJvcGVydGllcyBpbiBkZXN0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgdGhlIG9uZXMgaW4gc3JjLlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICogQHBhcmFtIHsuLi5PYmplY3R9IG9iamVjdHNfdG9fYXNzaWduXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB0YXJnZXRcbiAqL1xudmFyIGFzc2lnbjtcbmlmICh0eXBlb2YgT2JqZWN0LmFzc2lnbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGFzc2lnbiA9IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQpIHtcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3V0cHV0ID0gT2JqZWN0KHRhcmdldCk7XG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCAmJiBzb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuZXh0S2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KG5leHRLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbbmV4dEtleV0gPSBzb3VyY2VbbmV4dEtleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xufSBlbHNlIHtcbiAgICBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xufVxuXG4vKipcbiAqIGV4dGVuZCBvYmplY3QuXG4gKiBtZWFucyB0aGF0IHByb3BlcnRpZXMgaW4gZGVzdCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IHRoZSBvbmVzIGluIHNyYy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0XG4gKiBAcGFyYW0ge09iamVjdH0gc3JjXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFttZXJnZT1mYWxzZV1cbiAqIEByZXR1cm5zIHtPYmplY3R9IGRlc3RcbiAqL1xudmFyIGV4dGVuZCA9IGRlcHJlY2F0ZShmdW5jdGlvbiBleHRlbmQoZGVzdCwgc3JjLCBtZXJnZSkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc3JjKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBrZXlzLmxlbmd0aCkge1xuICAgICAgICBpZiAoIW1lcmdlIHx8IChtZXJnZSAmJiBkZXN0W2tleXNbaV1dID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICBkZXN0W2tleXNbaV1dID0gc3JjW2tleXNbaV1dO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG59LCAnZXh0ZW5kJywgJ1VzZSBgYXNzaWduYC4nKTtcblxuLyoqXG4gKiBtZXJnZSB0aGUgdmFsdWVzIGZyb20gc3JjIGluIHRoZSBkZXN0LlxuICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIHRoYXQgZXhpc3QgaW4gZGVzdCB3aWxsIG5vdCBiZSBvdmVyd3JpdHRlbiBieSBzcmNcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0XG4gKiBAcGFyYW0ge09iamVjdH0gc3JjXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBkZXN0XG4gKi9cbnZhciBtZXJnZSA9IGRlcHJlY2F0ZShmdW5jdGlvbiBtZXJnZShkZXN0LCBzcmMpIHtcbiAgICByZXR1cm4gZXh0ZW5kKGRlc3QsIHNyYywgdHJ1ZSk7XG59LCAnbWVyZ2UnLCAnVXNlIGBhc3NpZ25gLicpO1xuXG4vKipcbiAqIHNpbXBsZSBjbGFzcyBpbmhlcml0YW5jZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2hpbGRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGJhc2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc11cbiAqL1xuZnVuY3Rpb24gaW5oZXJpdChjaGlsZCwgYmFzZSwgcHJvcGVydGllcykge1xuICAgIHZhciBiYXNlUCA9IGJhc2UucHJvdG90eXBlLFxuICAgICAgICBjaGlsZFA7XG5cbiAgICBjaGlsZFAgPSBjaGlsZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGJhc2VQKTtcbiAgICBjaGlsZFAuY29uc3RydWN0b3IgPSBjaGlsZDtcbiAgICBjaGlsZFAuX3N1cGVyID0gYmFzZVA7XG5cbiAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICBhc3NpZ24oY2hpbGRQLCBwcm9wZXJ0aWVzKTtcbiAgICB9XG59XG5cbi8qKlxuICogc2ltcGxlIGZ1bmN0aW9uIGJpbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBiaW5kRm4oZm4sIGNvbnRleHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gYm91bmRGbigpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBsZXQgYSBib29sZWFuIHZhbHVlIGFsc28gYmUgYSBmdW5jdGlvbiB0aGF0IG11c3QgcmV0dXJuIGEgYm9vbGVhblxuICogdGhpcyBmaXJzdCBpdGVtIGluIGFyZ3Mgd2lsbCBiZSB1c2VkIGFzIHRoZSBjb250ZXh0XG4gKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IHZhbFxuICogQHBhcmFtIHtBcnJheX0gW2FyZ3NdXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gYm9vbE9yRm4odmFsLCBhcmdzKSB7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT0gVFlQRV9GVU5DVElPTikge1xuICAgICAgICByZXR1cm4gdmFsLmFwcGx5KGFyZ3MgPyBhcmdzWzBdIHx8IHVuZGVmaW5lZCA6IHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG5cbi8qKlxuICogdXNlIHRoZSB2YWwyIHdoZW4gdmFsMSBpcyB1bmRlZmluZWRcbiAqIEBwYXJhbSB7Kn0gdmFsMVxuICogQHBhcmFtIHsqfSB2YWwyXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gaWZVbmRlZmluZWQodmFsMSwgdmFsMikge1xuICAgIHJldHVybiAodmFsMSA9PT0gdW5kZWZpbmVkKSA/IHZhbDIgOiB2YWwxO1xufVxuXG4vKipcbiAqIGFkZEV2ZW50TGlzdGVuZXIgd2l0aCBtdWx0aXBsZSBldmVudHMgYXQgb25jZVxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAqL1xuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcnModGFyZ2V0LCB0eXBlcywgaGFuZGxlcikge1xuICAgIGVhY2goc3BsaXRTdHIodHlwZXMpLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiByZW1vdmVFdmVudExpc3RlbmVyIHdpdGggbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2VcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRhcmdldCwgdHlwZXMsIGhhbmRsZXIpIHtcbiAgICBlYWNoKHNwbGl0U3RyKHR5cGVzKSwgZnVuY3Rpb24odHlwZSkge1xuICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogZmluZCBpZiBhIG5vZGUgaXMgaW4gdGhlIGdpdmVuIHBhcmVudFxuICogQG1ldGhvZCBoYXNQYXJlbnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudFxuICogQHJldHVybiB7Qm9vbGVhbn0gZm91bmRcbiAqL1xuZnVuY3Rpb24gaGFzUGFyZW50KG5vZGUsIHBhcmVudCkge1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlID09IHBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIHNtYWxsIGluZGV4T2Ygd3JhcHBlclxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcbiAqIEByZXR1cm5zIHtCb29sZWFufSBmb3VuZFxuICovXG5mdW5jdGlvbiBpblN0cihzdHIsIGZpbmQpIHtcbiAgICByZXR1cm4gc3RyLmluZGV4T2YoZmluZCkgPiAtMTtcbn1cblxuLyoqXG4gKiBzcGxpdCBzdHJpbmcgb24gd2hpdGVzcGFjZVxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge0FycmF5fSB3b3Jkc1xuICovXG5mdW5jdGlvbiBzcGxpdFN0cihzdHIpIHtcbiAgICByZXR1cm4gc3RyLnRyaW0oKS5zcGxpdCgvXFxzKy9nKTtcbn1cblxuLyoqXG4gKiBmaW5kIGlmIGEgYXJyYXkgY29udGFpbnMgdGhlIG9iamVjdCB1c2luZyBpbmRleE9mIG9yIGEgc2ltcGxlIHBvbHlGaWxsXG4gKiBAcGFyYW0ge0FycmF5fSBzcmNcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaW5kXG4gKiBAcGFyYW0ge1N0cmluZ30gW2ZpbmRCeUtleV1cbiAqIEByZXR1cm4ge0Jvb2xlYW58TnVtYmVyfSBmYWxzZSB3aGVuIG5vdCBmb3VuZCwgb3IgdGhlIGluZGV4XG4gKi9cbmZ1bmN0aW9uIGluQXJyYXkoc3JjLCBmaW5kLCBmaW5kQnlLZXkpIHtcbiAgICBpZiAoc3JjLmluZGV4T2YgJiYgIWZpbmRCeUtleSkge1xuICAgICAgICByZXR1cm4gc3JjLmluZGV4T2YoZmluZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHNyYy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICgoZmluZEJ5S2V5ICYmIHNyY1tpXVtmaW5kQnlLZXldID09IGZpbmQpIHx8ICghZmluZEJ5S2V5ICYmIHNyY1tpXSA9PT0gZmluZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxufVxuXG4vKipcbiAqIGNvbnZlcnQgYXJyYXktbGlrZSBvYmplY3RzIHRvIHJlYWwgYXJyYXlzXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaiwgMCk7XG59XG5cbi8qKlxuICogdW5pcXVlIGFycmF5IHdpdGggb2JqZWN0cyBiYXNlZCBvbiBhIGtleSAobGlrZSAnaWQnKSBvciBqdXN0IGJ5IHRoZSBhcnJheSdzIHZhbHVlXG4gKiBAcGFyYW0ge0FycmF5fSBzcmMgW3tpZDoxfSx7aWQ6Mn0se2lkOjF9XVxuICogQHBhcmFtIHtTdHJpbmd9IFtrZXldXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtzb3J0PUZhbHNlXVxuICogQHJldHVybnMge0FycmF5fSBbe2lkOjF9LHtpZDoyfV1cbiAqL1xuZnVuY3Rpb24gdW5pcXVlQXJyYXkoc3JjLCBrZXksIHNvcnQpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IHNyYy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbCA9IGtleSA/IHNyY1tpXVtrZXldIDogc3JjW2ldO1xuICAgICAgICBpZiAoaW5BcnJheSh2YWx1ZXMsIHZhbCkgPCAwKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goc3JjW2ldKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXNbaV0gPSB2YWw7XG4gICAgICAgIGkrKztcbiAgICB9XG5cbiAgICBpZiAoc29ydCkge1xuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuc29ydCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuc29ydChmdW5jdGlvbiBzb3J0VW5pcXVlQXJyYXkoYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhW2tleV0gPiBiW2tleV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xufVxuXG4vKipcbiAqIGdldCB0aGUgcHJlZml4ZWQgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICogQHJldHVybnMge1N0cmluZ3xVbmRlZmluZWR9IHByZWZpeGVkXG4gKi9cbmZ1bmN0aW9uIHByZWZpeGVkKG9iaiwgcHJvcGVydHkpIHtcbiAgICB2YXIgcHJlZml4LCBwcm9wO1xuICAgIHZhciBjYW1lbFByb3AgPSBwcm9wZXJ0eVswXS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc2xpY2UoMSk7XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBWRU5ET1JfUFJFRklYRVMubGVuZ3RoKSB7XG4gICAgICAgIHByZWZpeCA9IFZFTkRPUl9QUkVGSVhFU1tpXTtcbiAgICAgICAgcHJvcCA9IChwcmVmaXgpID8gcHJlZml4ICsgY2FtZWxQcm9wIDogcHJvcGVydHk7XG5cbiAgICAgICAgaWYgKHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvcDtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogZ2V0IGEgdW5pcXVlIGlkXG4gKiBAcmV0dXJucyB7bnVtYmVyfSB1bmlxdWVJZFxuICovXG52YXIgX3VuaXF1ZUlkID0gMTtcbmZ1bmN0aW9uIHVuaXF1ZUlkKCkge1xuICAgIHJldHVybiBfdW5pcXVlSWQrKztcbn1cblxuLyoqXG4gKiBnZXQgdGhlIHdpbmRvdyBvYmplY3Qgb2YgYW4gZWxlbWVudFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0RvY3VtZW50Vmlld3xXaW5kb3d9XG4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvd0ZvckVsZW1lbnQoZWxlbWVudCkge1xuICAgIHZhciBkb2MgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQgfHwgZWxlbWVudDtcbiAgICByZXR1cm4gKGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93IHx8IHdpbmRvdyk7XG59XG5cbnZhciBNT0JJTEVfUkVHRVggPSAvbW9iaWxlfHRhYmxldHxpcChhZHxob25lfG9kKXxhbmRyb2lkL2k7XG5cbnZhciBTVVBQT1JUX1RPVUNIID0gKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyk7XG52YXIgU1VQUE9SVF9QT0lOVEVSX0VWRU5UUyA9IHByZWZpeGVkKHdpbmRvdywgJ1BvaW50ZXJFdmVudCcpICE9PSB1bmRlZmluZWQ7XG52YXIgU1VQUE9SVF9PTkxZX1RPVUNIID0gU1VQUE9SVF9UT1VDSCAmJiBNT0JJTEVfUkVHRVgudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxudmFyIElOUFVUX1RZUEVfVE9VQ0ggPSAndG91Y2gnO1xudmFyIElOUFVUX1RZUEVfUEVOID0gJ3Blbic7XG52YXIgSU5QVVRfVFlQRV9NT1VTRSA9ICdtb3VzZSc7XG52YXIgSU5QVVRfVFlQRV9LSU5FQ1QgPSAna2luZWN0JztcblxudmFyIENPTVBVVEVfSU5URVJWQUwgPSAyNTtcblxudmFyIElOUFVUX1NUQVJUID0gMTtcbnZhciBJTlBVVF9NT1ZFID0gMjtcbnZhciBJTlBVVF9FTkQgPSA0O1xudmFyIElOUFVUX0NBTkNFTCA9IDg7XG5cbnZhciBESVJFQ1RJT05fTk9ORSA9IDE7XG52YXIgRElSRUNUSU9OX0xFRlQgPSAyO1xudmFyIERJUkVDVElPTl9SSUdIVCA9IDQ7XG52YXIgRElSRUNUSU9OX1VQID0gODtcbnZhciBESVJFQ1RJT05fRE9XTiA9IDE2O1xuXG52YXIgRElSRUNUSU9OX0hPUklaT05UQUwgPSBESVJFQ1RJT05fTEVGVCB8IERJUkVDVElPTl9SSUdIVDtcbnZhciBESVJFQ1RJT05fVkVSVElDQUwgPSBESVJFQ1RJT05fVVAgfCBESVJFQ1RJT05fRE9XTjtcbnZhciBESVJFQ1RJT05fQUxMID0gRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUw7XG5cbnZhciBQUk9QU19YWSA9IFsneCcsICd5J107XG52YXIgUFJPUFNfQ0xJRU5UX1hZID0gWydjbGllbnRYJywgJ2NsaWVudFknXTtcblxuLyoqXG4gKiBjcmVhdGUgbmV3IGlucHV0IHR5cGUgbWFuYWdlclxuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge0lucHV0fVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIElucHV0KG1hbmFnZXIsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMuZWxlbWVudCA9IG1hbmFnZXIuZWxlbWVudDtcbiAgICB0aGlzLnRhcmdldCA9IG1hbmFnZXIub3B0aW9ucy5pbnB1dFRhcmdldDtcblxuICAgIC8vIHNtYWxsZXIgd3JhcHBlciBhcm91bmQgdGhlIGhhbmRsZXIsIGZvciB0aGUgc2NvcGUgYW5kIHRoZSBlbmFibGVkIHN0YXRlIG9mIHRoZSBtYW5hZ2VyLFxuICAgIC8vIHNvIHdoZW4gZGlzYWJsZWQgdGhlIGlucHV0IGV2ZW50cyBhcmUgY29tcGxldGVseSBieXBhc3NlZC5cbiAgICB0aGlzLmRvbUhhbmRsZXIgPSBmdW5jdGlvbihldikge1xuICAgICAgICBpZiAoYm9vbE9yRm4obWFuYWdlci5vcHRpb25zLmVuYWJsZSwgW21hbmFnZXJdKSkge1xuICAgICAgICAgICAgc2VsZi5oYW5kbGVyKGV2KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmluaXQoKTtcblxufVxuXG5JbnB1dC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogc2hvdWxkIGhhbmRsZSB0aGUgaW5wdXRFdmVudCBkYXRhIGFuZCB0cmlnZ2VyIHRoZSBjYWxsYmFja1xuICAgICAqIEB2aXJ0dWFsXG4gICAgICovXG4gICAgaGFuZGxlcjogZnVuY3Rpb24oKSB7IH0sXG5cbiAgICAvKipcbiAgICAgKiBiaW5kIHRoZSBldmVudHNcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5ldkVsICYmIGFkZEV2ZW50TGlzdGVuZXJzKHRoaXMuZWxlbWVudCwgdGhpcy5ldkVsLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgICB0aGlzLmV2VGFyZ2V0ICYmIGFkZEV2ZW50TGlzdGVuZXJzKHRoaXMudGFyZ2V0LCB0aGlzLmV2VGFyZ2V0LCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgICB0aGlzLmV2V2luICYmIGFkZEV2ZW50TGlzdGVuZXJzKGdldFdpbmRvd0ZvckVsZW1lbnQodGhpcy5lbGVtZW50KSwgdGhpcy5ldldpbiwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdW5iaW5kIHRoZSBldmVudHNcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5ldkVsICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMuZWxlbWVudCwgdGhpcy5ldkVsLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgICB0aGlzLmV2VGFyZ2V0ICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMudGFyZ2V0LCB0aGlzLmV2VGFyZ2V0LCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgICB0aGlzLmV2V2luICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKGdldFdpbmRvd0ZvckVsZW1lbnQodGhpcy5lbGVtZW50KSwgdGhpcy5ldldpbiwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIGNyZWF0ZSBuZXcgaW5wdXQgdHlwZSBtYW5hZ2VyXG4gKiBjYWxsZWQgYnkgdGhlIE1hbmFnZXIgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7SGFtbWVyfSBtYW5hZ2VyXG4gKiBAcmV0dXJucyB7SW5wdXR9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0SW5zdGFuY2UobWFuYWdlcikge1xuICAgIHZhciBUeXBlO1xuICAgIHZhciBpbnB1dENsYXNzID0gbWFuYWdlci5vcHRpb25zLmlucHV0Q2xhc3M7XG5cbiAgICBpZiAoaW5wdXRDbGFzcykge1xuICAgICAgICBUeXBlID0gaW5wdXRDbGFzcztcbiAgICB9IGVsc2UgaWYgKFNVUFBPUlRfUE9JTlRFUl9FVkVOVFMpIHtcbiAgICAgICAgVHlwZSA9IFBvaW50ZXJFdmVudElucHV0O1xuICAgIH0gZWxzZSBpZiAoU1VQUE9SVF9PTkxZX1RPVUNIKSB7XG4gICAgICAgIFR5cGUgPSBUb3VjaElucHV0O1xuICAgIH0gZWxzZSBpZiAoIVNVUFBPUlRfVE9VQ0gpIHtcbiAgICAgICAgVHlwZSA9IE1vdXNlSW5wdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgVHlwZSA9IFRvdWNoTW91c2VJbnB1dDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyAoVHlwZSkobWFuYWdlciwgaW5wdXRIYW5kbGVyKTtcbn1cblxuLyoqXG4gKiBoYW5kbGUgaW5wdXQgZXZlbnRzXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICovXG5mdW5jdGlvbiBpbnB1dEhhbmRsZXIobWFuYWdlciwgZXZlbnRUeXBlLCBpbnB1dCkge1xuICAgIHZhciBwb2ludGVyc0xlbiA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aDtcbiAgICB2YXIgY2hhbmdlZFBvaW50ZXJzTGVuID0gaW5wdXQuY2hhbmdlZFBvaW50ZXJzLmxlbmd0aDtcbiAgICB2YXIgaXNGaXJzdCA9IChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiAocG9pbnRlcnNMZW4gLSBjaGFuZ2VkUG9pbnRlcnNMZW4gPT09IDApKTtcbiAgICB2YXIgaXNGaW5hbCA9IChldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiAocG9pbnRlcnNMZW4gLSBjaGFuZ2VkUG9pbnRlcnNMZW4gPT09IDApKTtcblxuICAgIGlucHV0LmlzRmlyc3QgPSAhIWlzRmlyc3Q7XG4gICAgaW5wdXQuaXNGaW5hbCA9ICEhaXNGaW5hbDtcblxuICAgIGlmIChpc0ZpcnN0KSB7XG4gICAgICAgIG1hbmFnZXIuc2Vzc2lvbiA9IHt9O1xuICAgIH1cblxuICAgIC8vIHNvdXJjZSBldmVudCBpcyB0aGUgbm9ybWFsaXplZCB2YWx1ZSBvZiB0aGUgZG9tRXZlbnRzXG4gICAgLy8gbGlrZSAndG91Y2hzdGFydCwgbW91c2V1cCwgcG9pbnRlcmRvd24nXG4gICAgaW5wdXQuZXZlbnRUeXBlID0gZXZlbnRUeXBlO1xuXG4gICAgLy8gY29tcHV0ZSBzY2FsZSwgcm90YXRpb24gZXRjXG4gICAgY29tcHV0ZUlucHV0RGF0YShtYW5hZ2VyLCBpbnB1dCk7XG5cbiAgICAvLyBlbWl0IHNlY3JldCBldmVudFxuICAgIG1hbmFnZXIuZW1pdCgnaGFtbWVyLmlucHV0JywgaW5wdXQpO1xuXG4gICAgbWFuYWdlci5yZWNvZ25pemUoaW5wdXQpO1xuICAgIG1hbmFnZXIuc2Vzc2lvbi5wcmV2SW5wdXQgPSBpbnB1dDtcbn1cblxuLyoqXG4gKiBleHRlbmQgdGhlIGRhdGEgd2l0aCBzb21lIHVzYWJsZSBwcm9wZXJ0aWVzIGxpa2Ugc2NhbGUsIHJvdGF0ZSwgdmVsb2NpdHkgZXRjXG4gKiBAcGFyYW0ge09iamVjdH0gbWFuYWdlclxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVJbnB1dERhdGEobWFuYWdlciwgaW5wdXQpIHtcbiAgICB2YXIgc2Vzc2lvbiA9IG1hbmFnZXIuc2Vzc2lvbjtcbiAgICB2YXIgcG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycztcbiAgICB2YXIgcG9pbnRlcnNMZW5ndGggPSBwb2ludGVycy5sZW5ndGg7XG5cbiAgICAvLyBzdG9yZSB0aGUgZmlyc3QgaW5wdXQgdG8gY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBhbmQgZGlyZWN0aW9uXG4gICAgaWYgKCFzZXNzaW9uLmZpcnN0SW5wdXQpIHtcbiAgICAgICAgc2Vzc2lvbi5maXJzdElucHV0ID0gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpO1xuICAgIH1cblxuICAgIC8vIHRvIGNvbXB1dGUgc2NhbGUgYW5kIHJvdGF0aW9uIHdlIG5lZWQgdG8gc3RvcmUgdGhlIG11bHRpcGxlIHRvdWNoZXNcbiAgICBpZiAocG9pbnRlcnNMZW5ndGggPiAxICYmICFzZXNzaW9uLmZpcnN0TXVsdGlwbGUpIHtcbiAgICAgICAgc2Vzc2lvbi5maXJzdE11bHRpcGxlID0gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpO1xuICAgIH0gZWxzZSBpZiAocG9pbnRlcnNMZW5ndGggPT09IDEpIHtcbiAgICAgICAgc2Vzc2lvbi5maXJzdE11bHRpcGxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGZpcnN0SW5wdXQgPSBzZXNzaW9uLmZpcnN0SW5wdXQ7XG4gICAgdmFyIGZpcnN0TXVsdGlwbGUgPSBzZXNzaW9uLmZpcnN0TXVsdGlwbGU7XG4gICAgdmFyIG9mZnNldENlbnRlciA9IGZpcnN0TXVsdGlwbGUgPyBmaXJzdE11bHRpcGxlLmNlbnRlciA6IGZpcnN0SW5wdXQuY2VudGVyO1xuXG4gICAgdmFyIGNlbnRlciA9IGlucHV0LmNlbnRlciA9IGdldENlbnRlcihwb2ludGVycyk7XG4gICAgaW5wdXQudGltZVN0YW1wID0gbm93KCk7XG4gICAgaW5wdXQuZGVsdGFUaW1lID0gaW5wdXQudGltZVN0YW1wIC0gZmlyc3RJbnB1dC50aW1lU3RhbXA7XG5cbiAgICBpbnB1dC5hbmdsZSA9IGdldEFuZ2xlKG9mZnNldENlbnRlciwgY2VudGVyKTtcbiAgICBpbnB1dC5kaXN0YW5jZSA9IGdldERpc3RhbmNlKG9mZnNldENlbnRlciwgY2VudGVyKTtcblxuICAgIGNvbXB1dGVEZWx0YVhZKHNlc3Npb24sIGlucHV0KTtcbiAgICBpbnB1dC5vZmZzZXREaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24oaW5wdXQuZGVsdGFYLCBpbnB1dC5kZWx0YVkpO1xuXG4gICAgdmFyIG92ZXJhbGxWZWxvY2l0eSA9IGdldFZlbG9jaXR5KGlucHV0LmRlbHRhVGltZSwgaW5wdXQuZGVsdGFYLCBpbnB1dC5kZWx0YVkpO1xuICAgIGlucHV0Lm92ZXJhbGxWZWxvY2l0eVggPSBvdmVyYWxsVmVsb2NpdHkueDtcbiAgICBpbnB1dC5vdmVyYWxsVmVsb2NpdHlZID0gb3ZlcmFsbFZlbG9jaXR5Lnk7XG4gICAgaW5wdXQub3ZlcmFsbFZlbG9jaXR5ID0gKGFicyhvdmVyYWxsVmVsb2NpdHkueCkgPiBhYnMob3ZlcmFsbFZlbG9jaXR5LnkpKSA/IG92ZXJhbGxWZWxvY2l0eS54IDogb3ZlcmFsbFZlbG9jaXR5Lnk7XG5cbiAgICBpbnB1dC5zY2FsZSA9IGZpcnN0TXVsdGlwbGUgPyBnZXRTY2FsZShmaXJzdE11bHRpcGxlLnBvaW50ZXJzLCBwb2ludGVycykgOiAxO1xuICAgIGlucHV0LnJvdGF0aW9uID0gZmlyc3RNdWx0aXBsZSA/IGdldFJvdGF0aW9uKGZpcnN0TXVsdGlwbGUucG9pbnRlcnMsIHBvaW50ZXJzKSA6IDA7XG5cbiAgICBpbnB1dC5tYXhQb2ludGVycyA9ICFzZXNzaW9uLnByZXZJbnB1dCA/IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA6ICgoaW5wdXQucG9pbnRlcnMubGVuZ3RoID5cbiAgICAgICAgc2Vzc2lvbi5wcmV2SW5wdXQubWF4UG9pbnRlcnMpID8gaW5wdXQucG9pbnRlcnMubGVuZ3RoIDogc2Vzc2lvbi5wcmV2SW5wdXQubWF4UG9pbnRlcnMpO1xuXG4gICAgY29tcHV0ZUludGVydmFsSW5wdXREYXRhKHNlc3Npb24sIGlucHV0KTtcblxuICAgIC8vIGZpbmQgdGhlIGNvcnJlY3QgdGFyZ2V0XG4gICAgdmFyIHRhcmdldCA9IG1hbmFnZXIuZWxlbWVudDtcbiAgICBpZiAoaGFzUGFyZW50KGlucHV0LnNyY0V2ZW50LnRhcmdldCwgdGFyZ2V0KSkge1xuICAgICAgICB0YXJnZXQgPSBpbnB1dC5zcmNFdmVudC50YXJnZXQ7XG4gICAgfVxuICAgIGlucHV0LnRhcmdldCA9IHRhcmdldDtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZURlbHRhWFkoc2Vzc2lvbiwgaW5wdXQpIHtcbiAgICB2YXIgY2VudGVyID0gaW5wdXQuY2VudGVyO1xuICAgIHZhciBvZmZzZXQgPSBzZXNzaW9uLm9mZnNldERlbHRhIHx8IHt9O1xuICAgIHZhciBwcmV2RGVsdGEgPSBzZXNzaW9uLnByZXZEZWx0YSB8fCB7fTtcbiAgICB2YXIgcHJldklucHV0ID0gc2Vzc2lvbi5wcmV2SW5wdXQgfHwge307XG5cbiAgICBpZiAoaW5wdXQuZXZlbnRUeXBlID09PSBJTlBVVF9TVEFSVCB8fCBwcmV2SW5wdXQuZXZlbnRUeXBlID09PSBJTlBVVF9FTkQpIHtcbiAgICAgICAgcHJldkRlbHRhID0gc2Vzc2lvbi5wcmV2RGVsdGEgPSB7XG4gICAgICAgICAgICB4OiBwcmV2SW5wdXQuZGVsdGFYIHx8IDAsXG4gICAgICAgICAgICB5OiBwcmV2SW5wdXQuZGVsdGFZIHx8IDBcbiAgICAgICAgfTtcblxuICAgICAgICBvZmZzZXQgPSBzZXNzaW9uLm9mZnNldERlbHRhID0ge1xuICAgICAgICAgICAgeDogY2VudGVyLngsXG4gICAgICAgICAgICB5OiBjZW50ZXIueVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGlucHV0LmRlbHRhWCA9IHByZXZEZWx0YS54ICsgKGNlbnRlci54IC0gb2Zmc2V0LngpO1xuICAgIGlucHV0LmRlbHRhWSA9IHByZXZEZWx0YS55ICsgKGNlbnRlci55IC0gb2Zmc2V0LnkpO1xufVxuXG4vKipcbiAqIHZlbG9jaXR5IGlzIGNhbGN1bGF0ZWQgZXZlcnkgeCBtc1xuICogQHBhcmFtIHtPYmplY3R9IHNlc3Npb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICovXG5mdW5jdGlvbiBjb21wdXRlSW50ZXJ2YWxJbnB1dERhdGEoc2Vzc2lvbiwgaW5wdXQpIHtcbiAgICB2YXIgbGFzdCA9IHNlc3Npb24ubGFzdEludGVydmFsIHx8IGlucHV0LFxuICAgICAgICBkZWx0YVRpbWUgPSBpbnB1dC50aW1lU3RhbXAgLSBsYXN0LnRpbWVTdGFtcCxcbiAgICAgICAgdmVsb2NpdHksIHZlbG9jaXR5WCwgdmVsb2NpdHlZLCBkaXJlY3Rpb247XG5cbiAgICBpZiAoaW5wdXQuZXZlbnRUeXBlICE9IElOUFVUX0NBTkNFTCAmJiAoZGVsdGFUaW1lID4gQ09NUFVURV9JTlRFUlZBTCB8fCBsYXN0LnZlbG9jaXR5ID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHZhciBkZWx0YVggPSBpbnB1dC5kZWx0YVggLSBsYXN0LmRlbHRhWDtcbiAgICAgICAgdmFyIGRlbHRhWSA9IGlucHV0LmRlbHRhWSAtIGxhc3QuZGVsdGFZO1xuXG4gICAgICAgIHZhciB2ID0gZ2V0VmVsb2NpdHkoZGVsdGFUaW1lLCBkZWx0YVgsIGRlbHRhWSk7XG4gICAgICAgIHZlbG9jaXR5WCA9IHYueDtcbiAgICAgICAgdmVsb2NpdHlZID0gdi55O1xuICAgICAgICB2ZWxvY2l0eSA9IChhYnModi54KSA+IGFicyh2LnkpKSA/IHYueCA6IHYueTtcbiAgICAgICAgZGlyZWN0aW9uID0gZ2V0RGlyZWN0aW9uKGRlbHRhWCwgZGVsdGFZKTtcblxuICAgICAgICBzZXNzaW9uLmxhc3RJbnRlcnZhbCA9IGlucHV0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVzZSBsYXRlc3QgdmVsb2NpdHkgaW5mbyBpZiBpdCBkb2Vzbid0IG92ZXJ0YWtlIGEgbWluaW11bSBwZXJpb2RcbiAgICAgICAgdmVsb2NpdHkgPSBsYXN0LnZlbG9jaXR5O1xuICAgICAgICB2ZWxvY2l0eVggPSBsYXN0LnZlbG9jaXR5WDtcbiAgICAgICAgdmVsb2NpdHlZID0gbGFzdC52ZWxvY2l0eVk7XG4gICAgICAgIGRpcmVjdGlvbiA9IGxhc3QuZGlyZWN0aW9uO1xuICAgIH1cblxuICAgIGlucHV0LnZlbG9jaXR5ID0gdmVsb2NpdHk7XG4gICAgaW5wdXQudmVsb2NpdHlYID0gdmVsb2NpdHlYO1xuICAgIGlucHV0LnZlbG9jaXR5WSA9IHZlbG9jaXR5WTtcbiAgICBpbnB1dC5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG59XG5cbi8qKlxuICogY3JlYXRlIGEgc2ltcGxlIGNsb25lIGZyb20gdGhlIGlucHV0IHVzZWQgZm9yIHN0b3JhZ2Ugb2YgZmlyc3RJbnB1dCBhbmQgZmlyc3RNdWx0aXBsZVxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBjbG9uZWRJbnB1dERhdGFcbiAqL1xuZnVuY3Rpb24gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpIHtcbiAgICAvLyBtYWtlIGEgc2ltcGxlIGNvcHkgb2YgdGhlIHBvaW50ZXJzIGJlY2F1c2Ugd2Ugd2lsbCBnZXQgYSByZWZlcmVuY2UgaWYgd2UgZG9uJ3RcbiAgICAvLyB3ZSBvbmx5IG5lZWQgY2xpZW50WFkgZm9yIHRoZSBjYWxjdWxhdGlvbnNcbiAgICB2YXIgcG9pbnRlcnMgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBpbnB1dC5wb2ludGVycy5sZW5ndGgpIHtcbiAgICAgICAgcG9pbnRlcnNbaV0gPSB7XG4gICAgICAgICAgICBjbGllbnRYOiByb3VuZChpbnB1dC5wb2ludGVyc1tpXS5jbGllbnRYKSxcbiAgICAgICAgICAgIGNsaWVudFk6IHJvdW5kKGlucHV0LnBvaW50ZXJzW2ldLmNsaWVudFkpXG4gICAgICAgIH07XG4gICAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0aW1lU3RhbXA6IG5vdygpLFxuICAgICAgICBwb2ludGVyczogcG9pbnRlcnMsXG4gICAgICAgIGNlbnRlcjogZ2V0Q2VudGVyKHBvaW50ZXJzKSxcbiAgICAgICAgZGVsdGFYOiBpbnB1dC5kZWx0YVgsXG4gICAgICAgIGRlbHRhWTogaW5wdXQuZGVsdGFZXG4gICAgfTtcbn1cblxuLyoqXG4gKiBnZXQgdGhlIGNlbnRlciBvZiBhbGwgdGhlIHBvaW50ZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBwb2ludGVyc1xuICogQHJldHVybiB7T2JqZWN0fSBjZW50ZXIgY29udGFpbnMgYHhgIGFuZCBgeWAgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBnZXRDZW50ZXIocG9pbnRlcnMpIHtcbiAgICB2YXIgcG9pbnRlcnNMZW5ndGggPSBwb2ludGVycy5sZW5ndGg7XG5cbiAgICAvLyBubyBuZWVkIHRvIGxvb3Agd2hlbiBvbmx5IG9uZSB0b3VjaFxuICAgIGlmIChwb2ludGVyc0xlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogcm91bmQocG9pbnRlcnNbMF0uY2xpZW50WCksXG4gICAgICAgICAgICB5OiByb3VuZChwb2ludGVyc1swXS5jbGllbnRZKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciB4ID0gMCwgeSA9IDAsIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgcG9pbnRlcnNMZW5ndGgpIHtcbiAgICAgICAgeCArPSBwb2ludGVyc1tpXS5jbGllbnRYO1xuICAgICAgICB5ICs9IHBvaW50ZXJzW2ldLmNsaWVudFk7XG4gICAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB4OiByb3VuZCh4IC8gcG9pbnRlcnNMZW5ndGgpLFxuICAgICAgICB5OiByb3VuZCh5IC8gcG9pbnRlcnNMZW5ndGgpXG4gICAgfTtcbn1cblxuLyoqXG4gKiBjYWxjdWxhdGUgdGhlIHZlbG9jaXR5IGJldHdlZW4gdHdvIHBvaW50cy4gdW5pdCBpcyBpbiBweCBwZXIgbXMuXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsdGFUaW1lXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEByZXR1cm4ge09iamVjdH0gdmVsb2NpdHkgYHhgIGFuZCBgeWBcbiAqL1xuZnVuY3Rpb24gZ2V0VmVsb2NpdHkoZGVsdGFUaW1lLCB4LCB5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCAvIGRlbHRhVGltZSB8fCAwLFxuICAgICAgICB5OiB5IC8gZGVsdGFUaW1lIHx8IDBcbiAgICB9O1xufVxuXG4vKipcbiAqIGdldCB0aGUgZGlyZWN0aW9uIGJldHdlZW4gdHdvIHBvaW50c1xuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGRpcmVjdGlvblxuICovXG5mdW5jdGlvbiBnZXREaXJlY3Rpb24oeCwgeSkge1xuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAgIHJldHVybiBESVJFQ1RJT05fTk9ORTtcbiAgICB9XG5cbiAgICBpZiAoYWJzKHgpID49IGFicyh5KSkge1xuICAgICAgICByZXR1cm4geCA8IDAgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgICB9XG4gICAgcmV0dXJuIHkgPCAwID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSBhYnNvbHV0ZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMSB7eCwgeX1cbiAqIEBwYXJhbSB7T2JqZWN0fSBwMiB7eCwgeX1cbiAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wc10gY29udGFpbmluZyB4IGFuZCB5IGtleXNcbiAqIEByZXR1cm4ge051bWJlcn0gZGlzdGFuY2VcbiAqL1xuZnVuY3Rpb24gZ2V0RGlzdGFuY2UocDEsIHAyLCBwcm9wcykge1xuICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgcHJvcHMgPSBQUk9QU19YWTtcbiAgICB9XG4gICAgdmFyIHggPSBwMltwcm9wc1swXV0gLSBwMVtwcm9wc1swXV0sXG4gICAgICAgIHkgPSBwMltwcm9wc1sxXV0gLSBwMVtwcm9wc1sxXV07XG5cbiAgICByZXR1cm4gTWF0aC5zcXJ0KCh4ICogeCkgKyAoeSAqIHkpKTtcbn1cblxuLyoqXG4gKiBjYWxjdWxhdGUgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge09iamVjdH0gcDFcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMlxuICogQHBhcmFtIHtBcnJheX0gW3Byb3BzXSBjb250YWluaW5nIHggYW5kIHkga2V5c1xuICogQHJldHVybiB7TnVtYmVyfSBhbmdsZVxuICovXG5mdW5jdGlvbiBnZXRBbmdsZShwMSwgcDIsIHByb3BzKSB7XG4gICAgaWYgKCFwcm9wcykge1xuICAgICAgICBwcm9wcyA9IFBST1BTX1hZO1xuICAgIH1cbiAgICB2YXIgeCA9IHAyW3Byb3BzWzBdXSAtIHAxW3Byb3BzWzBdXSxcbiAgICAgICAgeSA9IHAyW3Byb3BzWzFdXSAtIHAxW3Byb3BzWzFdXTtcbiAgICByZXR1cm4gTWF0aC5hdGFuMih5LCB4KSAqIDE4MCAvIE1hdGguUEk7XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSByb3RhdGlvbiBkZWdyZWVzIGJldHdlZW4gdHdvIHBvaW50ZXJzZXRzXG4gKiBAcGFyYW0ge0FycmF5fSBzdGFydCBhcnJheSBvZiBwb2ludGVyc1xuICogQHBhcmFtIHtBcnJheX0gZW5kIGFycmF5IG9mIHBvaW50ZXJzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHJvdGF0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldFJvdGF0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gZ2V0QW5nbGUoZW5kWzFdLCBlbmRbMF0sIFBST1BTX0NMSUVOVF9YWSkgKyBnZXRBbmdsZShzdGFydFsxXSwgc3RhcnRbMF0sIFBST1BTX0NMSUVOVF9YWSk7XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSBzY2FsZSBmYWN0b3IgYmV0d2VlbiB0d28gcG9pbnRlcnNldHNcbiAqIG5vIHNjYWxlIGlzIDEsIGFuZCBnb2VzIGRvd24gdG8gMCB3aGVuIHBpbmNoZWQgdG9nZXRoZXIsIGFuZCBiaWdnZXIgd2hlbiBwaW5jaGVkIG91dFxuICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiBwb2ludGVyc1xuICogQHJldHVybiB7TnVtYmVyfSBzY2FsZVxuICovXG5mdW5jdGlvbiBnZXRTY2FsZShzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIGdldERpc3RhbmNlKGVuZFswXSwgZW5kWzFdLCBQUk9QU19DTElFTlRfWFkpIC8gZ2V0RGlzdGFuY2Uoc3RhcnRbMF0sIHN0YXJ0WzFdLCBQUk9QU19DTElFTlRfWFkpO1xufVxuXG52YXIgTU9VU0VfSU5QVVRfTUFQID0ge1xuICAgIG1vdXNlZG93bjogSU5QVVRfU1RBUlQsXG4gICAgbW91c2Vtb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIG1vdXNldXA6IElOUFVUX0VORFxufTtcblxudmFyIE1PVVNFX0VMRU1FTlRfRVZFTlRTID0gJ21vdXNlZG93bic7XG52YXIgTU9VU0VfV0lORE9XX0VWRU5UUyA9ICdtb3VzZW1vdmUgbW91c2V1cCc7XG5cbi8qKlxuICogTW91c2UgZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cbmZ1bmN0aW9uIE1vdXNlSW5wdXQoKSB7XG4gICAgdGhpcy5ldkVsID0gTU9VU0VfRUxFTUVOVF9FVkVOVFM7XG4gICAgdGhpcy5ldldpbiA9IE1PVVNFX1dJTkRPV19FVkVOVFM7XG5cbiAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTsgLy8gbW91c2Vkb3duIHN0YXRlXG5cbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KE1vdXNlSW5wdXQsIElucHV0LCB7XG4gICAgLyoqXG4gICAgICogaGFuZGxlIG1vdXNlIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgICAqL1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIE1FaGFuZGxlcihldikge1xuICAgICAgICB2YXIgZXZlbnRUeXBlID0gTU9VU0VfSU5QVVRfTUFQW2V2LnR5cGVdO1xuXG4gICAgICAgIC8vIG9uIHN0YXJ0IHdlIHdhbnQgdG8gaGF2ZSB0aGUgbGVmdCBtb3VzZSBidXR0b24gZG93blxuICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgZXYuYnV0dG9uID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnByZXNzZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX01PVkUgJiYgZXYud2hpY2ggIT09IDEpIHtcbiAgICAgICAgICAgIGV2ZW50VHlwZSA9IElOUFVUX0VORDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1vdXNlIG11c3QgYmUgZG93blxuICAgICAgICBpZiAoIXRoaXMucHJlc3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICAgICAgdGhpcy5wcmVzc2VkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgZXZlbnRUeXBlLCB7XG4gICAgICAgICAgICBwb2ludGVyczogW2V2XSxcbiAgICAgICAgICAgIGNoYW5nZWRQb2ludGVyczogW2V2XSxcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX01PVVNFLFxuICAgICAgICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG52YXIgUE9JTlRFUl9JTlBVVF9NQVAgPSB7XG4gICAgcG9pbnRlcmRvd246IElOUFVUX1NUQVJULFxuICAgIHBvaW50ZXJtb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIHBvaW50ZXJ1cDogSU5QVVRfRU5ELFxuICAgIHBvaW50ZXJjYW5jZWw6IElOUFVUX0NBTkNFTCxcbiAgICBwb2ludGVyb3V0OiBJTlBVVF9DQU5DRUxcbn07XG5cbi8vIGluIElFMTAgdGhlIHBvaW50ZXIgdHlwZXMgaXMgZGVmaW5lZCBhcyBhbiBlbnVtXG52YXIgSUUxMF9QT0lOVEVSX1RZUEVfRU5VTSA9IHtcbiAgICAyOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgIDM6IElOUFVUX1RZUEVfUEVOLFxuICAgIDQ6IElOUFVUX1RZUEVfTU9VU0UsXG4gICAgNTogSU5QVVRfVFlQRV9LSU5FQ1QgLy8gc2VlIGh0dHBzOi8vdHdpdHRlci5jb20vamFjb2Jyb3NzaS9zdGF0dXMvNDgwNTk2NDM4NDg5ODkwODE2XG59O1xuXG52YXIgUE9JTlRFUl9FTEVNRU5UX0VWRU5UUyA9ICdwb2ludGVyZG93bic7XG52YXIgUE9JTlRFUl9XSU5ET1dfRVZFTlRTID0gJ3BvaW50ZXJtb3ZlIHBvaW50ZXJ1cCBwb2ludGVyY2FuY2VsJztcblxuLy8gSUUxMCBoYXMgcHJlZml4ZWQgc3VwcG9ydCwgYW5kIGNhc2Utc2Vuc2l0aXZlXG5pZiAod2luZG93Lk1TUG9pbnRlckV2ZW50ICYmICF3aW5kb3cuUG9pbnRlckV2ZW50KSB7XG4gICAgUE9JTlRFUl9FTEVNRU5UX0VWRU5UUyA9ICdNU1BvaW50ZXJEb3duJztcbiAgICBQT0lOVEVSX1dJTkRPV19FVkVOVFMgPSAnTVNQb2ludGVyTW92ZSBNU1BvaW50ZXJVcCBNU1BvaW50ZXJDYW5jZWwnO1xufVxuXG4vKipcbiAqIFBvaW50ZXIgZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cbmZ1bmN0aW9uIFBvaW50ZXJFdmVudElucHV0KCkge1xuICAgIHRoaXMuZXZFbCA9IFBPSU5URVJfRUxFTUVOVF9FVkVOVFM7XG4gICAgdGhpcy5ldldpbiA9IFBPSU5URVJfV0lORE9XX0VWRU5UUztcblxuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB0aGlzLnN0b3JlID0gKHRoaXMubWFuYWdlci5zZXNzaW9uLnBvaW50ZXJFdmVudHMgPSBbXSk7XG59XG5cbmluaGVyaXQoUG9pbnRlckV2ZW50SW5wdXQsIElucHV0LCB7XG4gICAgLyoqXG4gICAgICogaGFuZGxlIG1vdXNlIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgICAqL1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIFBFaGFuZGxlcihldikge1xuICAgICAgICB2YXIgc3RvcmUgPSB0aGlzLnN0b3JlO1xuICAgICAgICB2YXIgcmVtb3ZlUG9pbnRlciA9IGZhbHNlO1xuXG4gICAgICAgIHZhciBldmVudFR5cGVOb3JtYWxpemVkID0gZXYudHlwZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ21zJywgJycpO1xuICAgICAgICB2YXIgZXZlbnRUeXBlID0gUE9JTlRFUl9JTlBVVF9NQVBbZXZlbnRUeXBlTm9ybWFsaXplZF07XG4gICAgICAgIHZhciBwb2ludGVyVHlwZSA9IElFMTBfUE9JTlRFUl9UWVBFX0VOVU1bZXYucG9pbnRlclR5cGVdIHx8IGV2LnBvaW50ZXJUeXBlO1xuXG4gICAgICAgIHZhciBpc1RvdWNoID0gKHBvaW50ZXJUeXBlID09IElOUFVUX1RZUEVfVE9VQ0gpO1xuXG4gICAgICAgIC8vIGdldCBpbmRleCBvZiB0aGUgZXZlbnQgaW4gdGhlIHN0b3JlXG4gICAgICAgIHZhciBzdG9yZUluZGV4ID0gaW5BcnJheShzdG9yZSwgZXYucG9pbnRlcklkLCAncG9pbnRlcklkJyk7XG5cbiAgICAgICAgLy8gc3RhcnQgYW5kIG1vdXNlIG11c3QgYmUgZG93blxuICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgKGV2LmJ1dHRvbiA9PT0gMCB8fCBpc1RvdWNoKSkge1xuICAgICAgICAgICAgaWYgKHN0b3JlSW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgc3RvcmUucHVzaChldik7XG4gICAgICAgICAgICAgICAgc3RvcmVJbmRleCA9IHN0b3JlLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICAgICAgICAgIHJlbW92ZVBvaW50ZXIgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaXQgbm90IGZvdW5kLCBzbyB0aGUgcG9pbnRlciBoYXNuJ3QgYmVlbiBkb3duIChzbyBpdCdzIHByb2JhYmx5IGEgaG92ZXIpXG4gICAgICAgIGlmIChzdG9yZUluZGV4IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBldmVudCBpbiB0aGUgc3RvcmVcbiAgICAgICAgc3RvcmVbc3RvcmVJbmRleF0gPSBldjtcblxuICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgZXZlbnRUeXBlLCB7XG4gICAgICAgICAgICBwb2ludGVyczogc3RvcmUsXG4gICAgICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IFtldl0sXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogcG9pbnRlclR5cGUsXG4gICAgICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHJlbW92ZVBvaW50ZXIpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBmcm9tIHRoZSBzdG9yZVxuICAgICAgICAgICAgc3RvcmUuc3BsaWNlKHN0b3JlSW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbnZhciBTSU5HTEVfVE9VQ0hfSU5QVVRfTUFQID0ge1xuICAgIHRvdWNoc3RhcnQ6IElOUFVUX1NUQVJULFxuICAgIHRvdWNobW92ZTogSU5QVVRfTU9WRSxcbiAgICB0b3VjaGVuZDogSU5QVVRfRU5ELFxuICAgIHRvdWNoY2FuY2VsOiBJTlBVVF9DQU5DRUxcbn07XG5cbnZhciBTSU5HTEVfVE9VQ0hfVEFSR0VUX0VWRU5UUyA9ICd0b3VjaHN0YXJ0JztcbnZhciBTSU5HTEVfVE9VQ0hfV0lORE9XX0VWRU5UUyA9ICd0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCc7XG5cbi8qKlxuICogVG91Y2ggZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cbmZ1bmN0aW9uIFNpbmdsZVRvdWNoSW5wdXQoKSB7XG4gICAgdGhpcy5ldlRhcmdldCA9IFNJTkdMRV9UT1VDSF9UQVJHRVRfRVZFTlRTO1xuICAgIHRoaXMuZXZXaW4gPSBTSU5HTEVfVE9VQ0hfV0lORE9XX0VWRU5UUztcbiAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcblxuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoU2luZ2xlVG91Y2hJbnB1dCwgSW5wdXQsIHtcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBURWhhbmRsZXIoZXYpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBTSU5HTEVfVE9VQ0hfSU5QVVRfTUFQW2V2LnR5cGVdO1xuXG4gICAgICAgIC8vIHNob3VsZCB3ZSBoYW5kbGUgdGhlIHRvdWNoIGV2ZW50cz9cbiAgICAgICAgaWYgKHR5cGUgPT09IElOUFVUX1NUQVJUKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b3VjaGVzID0gbm9ybWFsaXplU2luZ2xlVG91Y2hlcy5jYWxsKHRoaXMsIGV2LCB0eXBlKTtcblxuICAgICAgICAvLyB3aGVuIGRvbmUsIHJlc2V0IHRoZSBzdGFydGVkIHN0YXRlXG4gICAgICAgIGlmICh0eXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkgJiYgdG91Y2hlc1swXS5sZW5ndGggLSB0b3VjaGVzWzFdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgdHlwZSwge1xuICAgICAgICAgICAgcG9pbnRlcnM6IHRvdWNoZXNbMF0sXG4gICAgICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IHRvdWNoZXNbMV0sXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9UT1VDSCxcbiAgICAgICAgICAgIHNyY0V2ZW50OiBldlxuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBAdGhpcyB7VG91Y2hJbnB1dH1cbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICogQHBhcmFtIHtOdW1iZXJ9IHR5cGUgZmxhZ1xuICogQHJldHVybnMge3VuZGVmaW5lZHxBcnJheX0gW2FsbCwgY2hhbmdlZF1cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplU2luZ2xlVG91Y2hlcyhldiwgdHlwZSkge1xuICAgIHZhciBhbGwgPSB0b0FycmF5KGV2LnRvdWNoZXMpO1xuICAgIHZhciBjaGFuZ2VkID0gdG9BcnJheShldi5jaGFuZ2VkVG91Y2hlcyk7XG5cbiAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICAgIGFsbCA9IHVuaXF1ZUFycmF5KGFsbC5jb25jYXQoY2hhbmdlZCksICdpZGVudGlmaWVyJywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFthbGwsIGNoYW5nZWRdO1xufVxuXG52YXIgVE9VQ0hfSU5QVVRfTUFQID0ge1xuICAgIHRvdWNoc3RhcnQ6IElOUFVUX1NUQVJULFxuICAgIHRvdWNobW92ZTogSU5QVVRfTU9WRSxcbiAgICB0b3VjaGVuZDogSU5QVVRfRU5ELFxuICAgIHRvdWNoY2FuY2VsOiBJTlBVVF9DQU5DRUxcbn07XG5cbnZhciBUT1VDSF9UQVJHRVRfRVZFTlRTID0gJ3RvdWNoc3RhcnQgdG91Y2htb3ZlIHRvdWNoZW5kIHRvdWNoY2FuY2VsJztcblxuLyoqXG4gKiBNdWx0aS11c2VyIHRvdWNoIGV2ZW50cyBpbnB1dFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5mdW5jdGlvbiBUb3VjaElucHV0KCkge1xuICAgIHRoaXMuZXZUYXJnZXQgPSBUT1VDSF9UQVJHRVRfRVZFTlRTO1xuICAgIHRoaXMudGFyZ2V0SWRzID0ge307XG5cbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KFRvdWNoSW5wdXQsIElucHV0LCB7XG4gICAgaGFuZGxlcjogZnVuY3Rpb24gTVRFaGFuZGxlcihldikge1xuICAgICAgICB2YXIgdHlwZSA9IFRPVUNIX0lOUFVUX01BUFtldi50eXBlXTtcbiAgICAgICAgdmFyIHRvdWNoZXMgPSBnZXRUb3VjaGVzLmNhbGwodGhpcywgZXYsIHR5cGUpO1xuICAgICAgICBpZiAoIXRvdWNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCB0eXBlLCB7XG4gICAgICAgICAgICBwb2ludGVyczogdG91Y2hlc1swXSxcbiAgICAgICAgICAgIGNoYW5nZWRQb2ludGVyczogdG91Y2hlc1sxXSxcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgICAgICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIEB0aGlzIHtUb3VjaElucHV0fVxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKiBAcGFyYW0ge051bWJlcn0gdHlwZSBmbGFnXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfEFycmF5fSBbYWxsLCBjaGFuZ2VkXVxuICovXG5mdW5jdGlvbiBnZXRUb3VjaGVzKGV2LCB0eXBlKSB7XG4gICAgdmFyIGFsbFRvdWNoZXMgPSB0b0FycmF5KGV2LnRvdWNoZXMpO1xuICAgIHZhciB0YXJnZXRJZHMgPSB0aGlzLnRhcmdldElkcztcblxuICAgIC8vIHdoZW4gdGhlcmUgaXMgb25seSBvbmUgdG91Y2gsIHRoZSBwcm9jZXNzIGNhbiBiZSBzaW1wbGlmaWVkXG4gICAgaWYgKHR5cGUgJiAoSU5QVVRfU1RBUlQgfCBJTlBVVF9NT1ZFKSAmJiBhbGxUb3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB0YXJnZXRJZHNbYWxsVG91Y2hlc1swXS5pZGVudGlmaWVyXSA9IHRydWU7XG4gICAgICAgIHJldHVybiBbYWxsVG91Y2hlcywgYWxsVG91Y2hlc107XG4gICAgfVxuXG4gICAgdmFyIGksXG4gICAgICAgIHRhcmdldFRvdWNoZXMsXG4gICAgICAgIGNoYW5nZWRUb3VjaGVzID0gdG9BcnJheShldi5jaGFuZ2VkVG91Y2hlcyksXG4gICAgICAgIGNoYW5nZWRUYXJnZXRUb3VjaGVzID0gW10sXG4gICAgICAgIHRhcmdldCA9IHRoaXMudGFyZ2V0O1xuXG4gICAgLy8gZ2V0IHRhcmdldCB0b3VjaGVzIGZyb20gdG91Y2hlc1xuICAgIHRhcmdldFRvdWNoZXMgPSBhbGxUb3VjaGVzLmZpbHRlcihmdW5jdGlvbih0b3VjaCkge1xuICAgICAgICByZXR1cm4gaGFzUGFyZW50KHRvdWNoLnRhcmdldCwgdGFyZ2V0KTtcbiAgICB9KTtcblxuICAgIC8vIGNvbGxlY3QgdG91Y2hlc1xuICAgIGlmICh0eXBlID09PSBJTlBVVF9TVEFSVCkge1xuICAgICAgICBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCB0YXJnZXRUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGFyZ2V0SWRzW3RhcmdldFRvdWNoZXNbaV0uaWRlbnRpZmllcl0gPSB0cnVlO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIGNoYW5nZWQgdG91Y2hlcyB0byBvbmx5IGNvbnRhaW4gdG91Y2hlcyB0aGF0IGV4aXN0IGluIHRoZSBjb2xsZWN0ZWQgdGFyZ2V0IGlkc1xuICAgIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgY2hhbmdlZFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICAgIGlmICh0YXJnZXRJZHNbY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcl0pIHtcbiAgICAgICAgICAgIGNoYW5nZWRUYXJnZXRUb3VjaGVzLnB1c2goY2hhbmdlZFRvdWNoZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYW51cCByZW1vdmVkIHRvdWNoZXNcbiAgICAgICAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgICAgICAgZGVsZXRlIHRhcmdldElkc1tjaGFuZ2VkVG91Y2hlc1tpXS5pZGVudGlmaWVyXTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuXG4gICAgaWYgKCFjaGFuZ2VkVGFyZ2V0VG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBbXG4gICAgICAgIC8vIG1lcmdlIHRhcmdldFRvdWNoZXMgd2l0aCBjaGFuZ2VkVGFyZ2V0VG91Y2hlcyBzbyBpdCBjb250YWlucyBBTEwgdG91Y2hlcywgaW5jbHVkaW5nICdlbmQnIGFuZCAnY2FuY2VsJ1xuICAgICAgICB1bmlxdWVBcnJheSh0YXJnZXRUb3VjaGVzLmNvbmNhdChjaGFuZ2VkVGFyZ2V0VG91Y2hlcyksICdpZGVudGlmaWVyJywgdHJ1ZSksXG4gICAgICAgIGNoYW5nZWRUYXJnZXRUb3VjaGVzXG4gICAgXTtcbn1cblxuLyoqXG4gKiBDb21iaW5lZCB0b3VjaCBhbmQgbW91c2UgaW5wdXRcbiAqXG4gKiBUb3VjaCBoYXMgYSBoaWdoZXIgcHJpb3JpdHkgdGhlbiBtb3VzZSwgYW5kIHdoaWxlIHRvdWNoaW5nIG5vIG1vdXNlIGV2ZW50cyBhcmUgYWxsb3dlZC5cbiAqIFRoaXMgYmVjYXVzZSB0b3VjaCBkZXZpY2VzIGFsc28gZW1pdCBtb3VzZSBldmVudHMgd2hpbGUgZG9pbmcgYSB0b3VjaC5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cblxudmFyIERFRFVQX1RJTUVPVVQgPSAyNTAwO1xudmFyIERFRFVQX0RJU1RBTkNFID0gMjU7XG5cbmZ1bmN0aW9uIFRvdWNoTW91c2VJbnB1dCgpIHtcbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdmFyIGhhbmRsZXIgPSBiaW5kRm4odGhpcy5oYW5kbGVyLCB0aGlzKTtcbiAgICB0aGlzLnRvdWNoID0gbmV3IFRvdWNoSW5wdXQodGhpcy5tYW5hZ2VyLCBoYW5kbGVyKTtcbiAgICB0aGlzLm1vdXNlID0gbmV3IE1vdXNlSW5wdXQodGhpcy5tYW5hZ2VyLCBoYW5kbGVyKTtcblxuICAgIHRoaXMucHJpbWFyeVRvdWNoID0gbnVsbDtcbiAgICB0aGlzLmxhc3RUb3VjaGVzID0gW107XG59XG5cbmluaGVyaXQoVG91Y2hNb3VzZUlucHV0LCBJbnB1dCwge1xuICAgIC8qKlxuICAgICAqIGhhbmRsZSBtb3VzZSBhbmQgdG91Y2ggZXZlbnRzXG4gICAgICogQHBhcmFtIHtIYW1tZXJ9IG1hbmFnZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXRFdmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgKi9cbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBUTUVoYW5kbGVyKG1hbmFnZXIsIGlucHV0RXZlbnQsIGlucHV0RGF0YSkge1xuICAgICAgICB2YXIgaXNUb3VjaCA9IChpbnB1dERhdGEucG9pbnRlclR5cGUgPT0gSU5QVVRfVFlQRV9UT1VDSCksXG4gICAgICAgICAgICBpc01vdXNlID0gKGlucHV0RGF0YS5wb2ludGVyVHlwZSA9PSBJTlBVVF9UWVBFX01PVVNFKTtcblxuICAgICAgICBpZiAoaXNNb3VzZSAmJiBpbnB1dERhdGEuc291cmNlQ2FwYWJpbGl0aWVzICYmIGlucHV0RGF0YS5zb3VyY2VDYXBhYmlsaXRpZXMuZmlyZXNUb3VjaEV2ZW50cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2hlbiB3ZSdyZSBpbiBhIHRvdWNoIGV2ZW50LCByZWNvcmQgdG91Y2hlcyB0byAgZGUtZHVwZSBzeW50aGV0aWMgbW91c2UgZXZlbnRcbiAgICAgICAgaWYgKGlzVG91Y2gpIHtcbiAgICAgICAgICAgIHJlY29yZFRvdWNoZXMuY2FsbCh0aGlzLCBpbnB1dEV2ZW50LCBpbnB1dERhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTW91c2UgJiYgaXNTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGlucHV0RGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sobWFuYWdlciwgaW5wdXRFdmVudCwgaW5wdXREYXRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnRvdWNoLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5tb3VzZS5kZXN0cm95KCk7XG4gICAgfVxufSk7XG5cbmZ1bmN0aW9uIHJlY29yZFRvdWNoZXMoZXZlbnRUeXBlLCBldmVudERhdGEpIHtcbiAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpIHtcbiAgICAgICAgdGhpcy5wcmltYXJ5VG91Y2ggPSBldmVudERhdGEuY2hhbmdlZFBvaW50ZXJzWzBdLmlkZW50aWZpZXI7XG4gICAgICAgIHNldExhc3RUb3VjaC5jYWxsKHRoaXMsIGV2ZW50RGF0YSk7XG4gICAgfSBlbHNlIGlmIChldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgICBzZXRMYXN0VG91Y2guY2FsbCh0aGlzLCBldmVudERhdGEpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2V0TGFzdFRvdWNoKGV2ZW50RGF0YSkge1xuICAgIHZhciB0b3VjaCA9IGV2ZW50RGF0YS5jaGFuZ2VkUG9pbnRlcnNbMF07XG5cbiAgICBpZiAodG91Y2guaWRlbnRpZmllciA9PT0gdGhpcy5wcmltYXJ5VG91Y2gpIHtcbiAgICAgICAgdmFyIGxhc3RUb3VjaCA9IHt4OiB0b3VjaC5jbGllbnRYLCB5OiB0b3VjaC5jbGllbnRZfTtcbiAgICAgICAgdGhpcy5sYXN0VG91Y2hlcy5wdXNoKGxhc3RUb3VjaCk7XG4gICAgICAgIHZhciBsdHMgPSB0aGlzLmxhc3RUb3VjaGVzO1xuICAgICAgICB2YXIgcmVtb3ZlTGFzdFRvdWNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaSA9IGx0cy5pbmRleE9mKGxhc3RUb3VjaCk7XG4gICAgICAgICAgICBpZiAoaSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgbHRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgc2V0VGltZW91dChyZW1vdmVMYXN0VG91Y2gsIERFRFVQX1RJTUVPVVQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNTeW50aGV0aWNFdmVudChldmVudERhdGEpIHtcbiAgICB2YXIgeCA9IGV2ZW50RGF0YS5zcmNFdmVudC5jbGllbnRYLCB5ID0gZXZlbnREYXRhLnNyY0V2ZW50LmNsaWVudFk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxhc3RUb3VjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0ID0gdGhpcy5sYXN0VG91Y2hlc1tpXTtcbiAgICAgICAgdmFyIGR4ID0gTWF0aC5hYnMoeCAtIHQueCksIGR5ID0gTWF0aC5hYnMoeSAtIHQueSk7XG4gICAgICAgIGlmIChkeCA8PSBERURVUF9ESVNUQU5DRSAmJiBkeSA8PSBERURVUF9ESVNUQU5DRSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgUFJFRklYRURfVE9VQ0hfQUNUSU9OID0gcHJlZml4ZWQoVEVTVF9FTEVNRU5ULnN0eWxlLCAndG91Y2hBY3Rpb24nKTtcbnZhciBOQVRJVkVfVE9VQ0hfQUNUSU9OID0gUFJFRklYRURfVE9VQ0hfQUNUSU9OICE9PSB1bmRlZmluZWQ7XG5cbi8vIG1hZ2ljYWwgdG91Y2hBY3Rpb24gdmFsdWVcbnZhciBUT1VDSF9BQ1RJT05fQ09NUFVURSA9ICdjb21wdXRlJztcbnZhciBUT1VDSF9BQ1RJT05fQVVUTyA9ICdhdXRvJztcbnZhciBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OID0gJ21hbmlwdWxhdGlvbic7IC8vIG5vdCBpbXBsZW1lbnRlZFxudmFyIFRPVUNIX0FDVElPTl9OT05FID0gJ25vbmUnO1xudmFyIFRPVUNIX0FDVElPTl9QQU5fWCA9ICdwYW4teCc7XG52YXIgVE9VQ0hfQUNUSU9OX1BBTl9ZID0gJ3Bhbi15JztcbnZhciBUT1VDSF9BQ1RJT05fTUFQID0gZ2V0VG91Y2hBY3Rpb25Qcm9wcygpO1xuXG4vKipcbiAqIFRvdWNoIEFjdGlvblxuICogc2V0cyB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkgb3IgdXNlcyB0aGUganMgYWx0ZXJuYXRpdmVcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gVG91Y2hBY3Rpb24obWFuYWdlciwgdmFsdWUpIHtcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIHRoaXMuc2V0KHZhbHVlKTtcbn1cblxuVG91Y2hBY3Rpb24ucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIHNldCB0aGUgdG91Y2hBY3Rpb24gdmFsdWUgb24gdGhlIGVsZW1lbnQgb3IgZW5hYmxlIHRoZSBwb2x5ZmlsbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgLy8gZmluZCBvdXQgdGhlIHRvdWNoLWFjdGlvbiBieSB0aGUgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgaWYgKHZhbHVlID09IFRPVUNIX0FDVElPTl9DT01QVVRFKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuY29tcHV0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE5BVElWRV9UT1VDSF9BQ1RJT04gJiYgdGhpcy5tYW5hZ2VyLmVsZW1lbnQuc3R5bGUgJiYgVE9VQ0hfQUNUSU9OX01BUFt2YWx1ZV0pIHtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbGVtZW50LnN0eWxlW1BSRUZJWEVEX1RPVUNIX0FDVElPTl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGlvbnMgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICoganVzdCByZS1zZXQgdGhlIHRvdWNoQWN0aW9uIHZhbHVlXG4gICAgICovXG4gICAgdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZXQodGhpcy5tYW5hZ2VyLm9wdGlvbnMudG91Y2hBY3Rpb24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjb21wdXRlIHRoZSB2YWx1ZSBmb3IgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5IGJhc2VkIG9uIHRoZSByZWNvZ25pemVyJ3Mgc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIGNvbXB1dGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYWN0aW9ucyA9IFtdO1xuICAgICAgICBlYWNoKHRoaXMubWFuYWdlci5yZWNvZ25pemVycywgZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgICAgICAgICAgaWYgKGJvb2xPckZuKHJlY29nbml6ZXIub3B0aW9ucy5lbmFibGUsIFtyZWNvZ25pemVyXSkpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25zID0gYWN0aW9ucy5jb25jYXQocmVjb2duaXplci5nZXRUb3VjaEFjdGlvbigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjbGVhblRvdWNoQWN0aW9ucyhhY3Rpb25zLmpvaW4oJyAnKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBvbiBlYWNoIGlucHV0IGN5Y2xlIGFuZCBwcm92aWRlcyB0aGUgcHJldmVudGluZyBvZiB0aGUgYnJvd3NlciBiZWhhdmlvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqL1xuICAgIHByZXZlbnREZWZhdWx0czogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIHNyY0V2ZW50ID0gaW5wdXQuc3JjRXZlbnQ7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBpbnB1dC5vZmZzZXREaXJlY3Rpb247XG5cbiAgICAgICAgLy8gaWYgdGhlIHRvdWNoIGFjdGlvbiBkaWQgcHJldmVudGVkIG9uY2UgdGhpcyBzZXNzaW9uXG4gICAgICAgIGlmICh0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgIHNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYWN0aW9ucyA9IHRoaXMuYWN0aW9ucztcbiAgICAgICAgdmFyIGhhc05vbmUgPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTk9ORSkgJiYgIVRPVUNIX0FDVElPTl9NQVBbVE9VQ0hfQUNUSU9OX05PTkVdO1xuICAgICAgICB2YXIgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSkgJiYgIVRPVUNIX0FDVElPTl9NQVBbVE9VQ0hfQUNUSU9OX1BBTl9ZXTtcbiAgICAgICAgdmFyIGhhc1BhblggPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1gpICYmICFUT1VDSF9BQ1RJT05fTUFQW1RPVUNIX0FDVElPTl9QQU5fWF07XG5cbiAgICAgICAgaWYgKGhhc05vbmUpIHtcbiAgICAgICAgICAgIC8vZG8gbm90IHByZXZlbnQgZGVmYXVsdHMgaWYgdGhpcyBpcyBhIHRhcCBnZXN0dXJlXG5cbiAgICAgICAgICAgIHZhciBpc1RhcFBvaW50ZXIgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IDE7XG4gICAgICAgICAgICB2YXIgaXNUYXBNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgMjtcbiAgICAgICAgICAgIHZhciBpc1RhcFRvdWNoVGltZSA9IGlucHV0LmRlbHRhVGltZSA8IDI1MDtcblxuICAgICAgICAgICAgaWYgKGlzVGFwUG9pbnRlciAmJiBpc1RhcE1vdmVtZW50ICYmIGlzVGFwVG91Y2hUaW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc1BhblggJiYgaGFzUGFuWSkge1xuICAgICAgICAgICAgLy8gYHBhbi14IHBhbi15YCBtZWFucyBicm93c2VyIGhhbmRsZXMgYWxsIHNjcm9sbGluZy9wYW5uaW5nLCBkbyBub3QgcHJldmVudFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc05vbmUgfHxcbiAgICAgICAgICAgIChoYXNQYW5ZICYmIGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB8fFxuICAgICAgICAgICAgKGhhc1BhblggJiYgZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJldmVudFNyYyhzcmNFdmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2FsbCBwcmV2ZW50RGVmYXVsdCB0byBwcmV2ZW50IHRoZSBicm93c2VyJ3MgZGVmYXVsdCBiZWhhdmlvciAoc2Nyb2xsaW5nIGluIG1vc3QgY2FzZXMpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNyY0V2ZW50XG4gICAgICovXG4gICAgcHJldmVudFNyYzogZnVuY3Rpb24oc3JjRXZlbnQpIHtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnNlc3Npb24ucHJldmVudGVkID0gdHJ1ZTtcbiAgICAgICAgc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIHdoZW4gdGhlIHRvdWNoQWN0aW9ucyBhcmUgY29sbGVjdGVkIHRoZXkgYXJlIG5vdCBhIHZhbGlkIHZhbHVlLCBzbyB3ZSBuZWVkIHRvIGNsZWFuIHRoaW5ncyB1cC4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvbnNcbiAqIEByZXR1cm5zIHsqfVxuICovXG5mdW5jdGlvbiBjbGVhblRvdWNoQWN0aW9ucyhhY3Rpb25zKSB7XG4gICAgLy8gbm9uZVxuICAgIGlmIChpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTk9ORSkpIHtcbiAgICAgICAgcmV0dXJuIFRPVUNIX0FDVElPTl9OT05FO1xuICAgIH1cblxuICAgIHZhciBoYXNQYW5YID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9YKTtcbiAgICB2YXIgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSk7XG5cbiAgICAvLyBpZiBib3RoIHBhbi14IGFuZCBwYW4teSBhcmUgc2V0IChkaWZmZXJlbnQgcmVjb2duaXplcnNcbiAgICAvLyBmb3IgZGlmZmVyZW50IGRpcmVjdGlvbnMsIGUuZy4gaG9yaXpvbnRhbCBwYW4gYnV0IHZlcnRpY2FsIHN3aXBlPylcbiAgICAvLyB3ZSBuZWVkIG5vbmUgKGFzIG90aGVyd2lzZSB3aXRoIHBhbi14IHBhbi15IGNvbWJpbmVkIG5vbmUgb2YgdGhlc2VcbiAgICAvLyByZWNvZ25pemVycyB3aWxsIHdvcmssIHNpbmNlIHRoZSBicm93c2VyIHdvdWxkIGhhbmRsZSBhbGwgcGFubmluZ1xuICAgIGlmIChoYXNQYW5YICYmIGhhc1BhblkpIHtcbiAgICAgICAgcmV0dXJuIFRPVUNIX0FDVElPTl9OT05FO1xuICAgIH1cblxuICAgIC8vIHBhbi14IE9SIHBhbi15XG4gICAgaWYgKGhhc1BhblggfHwgaGFzUGFuWSkge1xuICAgICAgICByZXR1cm4gaGFzUGFuWCA/IFRPVUNIX0FDVElPTl9QQU5fWCA6IFRPVUNIX0FDVElPTl9QQU5fWTtcbiAgICB9XG5cbiAgICAvLyBtYW5pcHVsYXRpb25cbiAgICBpZiAoaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTikpIHtcbiAgICAgICAgcmV0dXJuIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT047XG4gICAgfVxuXG4gICAgcmV0dXJuIFRPVUNIX0FDVElPTl9BVVRPO1xufVxuXG5mdW5jdGlvbiBnZXRUb3VjaEFjdGlvblByb3BzKCkge1xuICAgIGlmICghTkFUSVZFX1RPVUNIX0FDVElPTikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciB0b3VjaE1hcCA9IHt9O1xuICAgIHZhciBjc3NTdXBwb3J0cyA9IHdpbmRvdy5DU1MgJiYgd2luZG93LkNTUy5zdXBwb3J0cztcbiAgICBbJ2F1dG8nLCAnbWFuaXB1bGF0aW9uJywgJ3Bhbi15JywgJ3Bhbi14JywgJ3Bhbi14IHBhbi15JywgJ25vbmUnXS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCkge1xuXG4gICAgICAgIC8vIElmIGNzcy5zdXBwb3J0cyBpcyBub3Qgc3VwcG9ydGVkIGJ1dCB0aGVyZSBpcyBuYXRpdmUgdG91Y2gtYWN0aW9uIGFzc3VtZSBpdCBzdXBwb3J0c1xuICAgICAgICAvLyBhbGwgdmFsdWVzLiBUaGlzIGlzIHRoZSBjYXNlIGZvciBJRSAxMCBhbmQgMTEuXG4gICAgICAgIHRvdWNoTWFwW3ZhbF0gPSBjc3NTdXBwb3J0cyA/IHdpbmRvdy5DU1Muc3VwcG9ydHMoJ3RvdWNoLWFjdGlvbicsIHZhbCkgOiB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiB0b3VjaE1hcDtcbn1cblxuLyoqXG4gKiBSZWNvZ25pemVyIGZsb3cgZXhwbGFpbmVkOyAqXG4gKiBBbGwgcmVjb2duaXplcnMgaGF2ZSB0aGUgaW5pdGlhbCBzdGF0ZSBvZiBQT1NTSUJMRSB3aGVuIGEgaW5wdXQgc2Vzc2lvbiBzdGFydHMuXG4gKiBUaGUgZGVmaW5pdGlvbiBvZiBhIGlucHV0IHNlc3Npb24gaXMgZnJvbSB0aGUgZmlyc3QgaW5wdXQgdW50aWwgdGhlIGxhc3QgaW5wdXQsIHdpdGggYWxsIGl0J3MgbW92ZW1lbnQgaW4gaXQuICpcbiAqIEV4YW1wbGUgc2Vzc2lvbiBmb3IgbW91c2UtaW5wdXQ6IG1vdXNlZG93biAtPiBtb3VzZW1vdmUgLT4gbW91c2V1cFxuICpcbiAqIE9uIGVhY2ggcmVjb2duaXppbmcgY3ljbGUgKHNlZSBNYW5hZ2VyLnJlY29nbml6ZSkgdGhlIC5yZWNvZ25pemUoKSBtZXRob2QgaXMgZXhlY3V0ZWRcbiAqIHdoaWNoIGRldGVybWluZXMgd2l0aCBzdGF0ZSBpdCBzaG91bGQgYmUuXG4gKlxuICogSWYgdGhlIHJlY29nbml6ZXIgaGFzIHRoZSBzdGF0ZSBGQUlMRUQsIENBTkNFTExFRCBvciBSRUNPR05JWkVEIChlcXVhbHMgRU5ERUQpLCBpdCBpcyByZXNldCB0b1xuICogUE9TU0lCTEUgdG8gZ2l2ZSBpdCBhbm90aGVyIGNoYW5nZSBvbiB0aGUgbmV4dCBjeWNsZS5cbiAqXG4gKiAgICAgICAgICAgICAgIFBvc3NpYmxlXG4gKiAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgKy0tLS0tKy0tLS0tLS0tLS0tLS0tLStcbiAqICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgKy0tLS0tKy0tLS0tKyAgICAgICAgICAgICAgIHxcbiAqICAgICAgfCAgICAgICAgICAgfCAgICAgICAgICAgICAgIHxcbiAqICAgRmFpbGVkICAgICAgQ2FuY2VsbGVkICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLSstLS0tLS0rXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICAgUmVjb2duaXplZCAgICAgICBCZWdhblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDaGFuZ2VkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRW5kZWQvUmVjb2duaXplZFxuICovXG52YXIgU1RBVEVfUE9TU0lCTEUgPSAxO1xudmFyIFNUQVRFX0JFR0FOID0gMjtcbnZhciBTVEFURV9DSEFOR0VEID0gNDtcbnZhciBTVEFURV9FTkRFRCA9IDg7XG52YXIgU1RBVEVfUkVDT0dOSVpFRCA9IFNUQVRFX0VOREVEO1xudmFyIFNUQVRFX0NBTkNFTExFRCA9IDE2O1xudmFyIFNUQVRFX0ZBSUxFRCA9IDMyO1xuXG4vKipcbiAqIFJlY29nbml6ZXJcbiAqIEV2ZXJ5IHJlY29nbml6ZXIgbmVlZHMgdG8gZXh0ZW5kIGZyb20gdGhpcyBjbGFzcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gUmVjb2duaXplcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gYXNzaWduKHt9LCB0aGlzLmRlZmF1bHRzLCBvcHRpb25zIHx8IHt9KTtcblxuICAgIHRoaXMuaWQgPSB1bmlxdWVJZCgpO1xuXG4gICAgdGhpcy5tYW5hZ2VyID0gbnVsbDtcblxuICAgIC8vIGRlZmF1bHQgaXMgZW5hYmxlIHRydWVcbiAgICB0aGlzLm9wdGlvbnMuZW5hYmxlID0gaWZVbmRlZmluZWQodGhpcy5vcHRpb25zLmVuYWJsZSwgdHJ1ZSk7XG5cbiAgICB0aGlzLnN0YXRlID0gU1RBVEVfUE9TU0lCTEU7XG5cbiAgICB0aGlzLnNpbXVsdGFuZW91cyA9IHt9O1xuICAgIHRoaXMucmVxdWlyZUZhaWwgPSBbXTtcbn1cblxuUmVjb2duaXplci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQHZpcnR1YWxcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7fSxcblxuICAgIC8qKlxuICAgICAqIHNldCBvcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtSZWNvZ25pemVyfVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBhc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgICAvLyBhbHNvIHVwZGF0ZSB0aGUgdG91Y2hBY3Rpb24sIGluIGNhc2Ugc29tZXRoaW5nIGNoYW5nZWQgYWJvdXQgdGhlIGRpcmVjdGlvbnMvZW5hYmxlZCBzdGF0ZVxuICAgICAgICB0aGlzLm1hbmFnZXIgJiYgdGhpcy5tYW5hZ2VyLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVjb2duaXplIHNpbXVsdGFuZW91cyB3aXRoIGFuIG90aGVyIHJlY29nbml6ZXIuXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAqL1xuICAgIHJlY29nbml6ZVdpdGg6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAncmVjb2duaXplV2l0aCcsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaW11bHRhbmVvdXMgPSB0aGlzLnNpbXVsdGFuZW91cztcbiAgICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgICBpZiAoIXNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdKSB7XG4gICAgICAgICAgICBzaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXSA9IG90aGVyUmVjb2duaXplcjtcbiAgICAgICAgICAgIG90aGVyUmVjb2duaXplci5yZWNvZ25pemVXaXRoKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBkcm9wIHRoZSBzaW11bHRhbmVvdXMgbGluay4gaXQgZG9lc250IHJlbW92ZSB0aGUgbGluayBvbiB0aGUgb3RoZXIgcmVjb2duaXplci5cbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAgICovXG4gICAgZHJvcFJlY29nbml6ZVdpdGg6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAnZHJvcFJlY29nbml6ZVdpdGgnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVjb2duaXplciBjYW4gb25seSBydW4gd2hlbiBhbiBvdGhlciBpcyBmYWlsaW5nXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAqL1xuICAgIHJlcXVpcmVGYWlsdXJlOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ3JlcXVpcmVGYWlsdXJlJywgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlcXVpcmVGYWlsID0gdGhpcy5yZXF1aXJlRmFpbDtcbiAgICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgICBpZiAoaW5BcnJheShyZXF1aXJlRmFpbCwgb3RoZXJSZWNvZ25pemVyKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJlcXVpcmVGYWlsLnB1c2gob3RoZXJSZWNvZ25pemVyKTtcbiAgICAgICAgICAgIG90aGVyUmVjb2duaXplci5yZXF1aXJlRmFpbHVyZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZHJvcCB0aGUgcmVxdWlyZUZhaWx1cmUgbGluay4gaXQgZG9lcyBub3QgcmVtb3ZlIHRoZSBsaW5rIG9uIHRoZSBvdGhlciByZWNvZ25pemVyLlxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICBkcm9wUmVxdWlyZUZhaWx1cmU6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAnZHJvcFJlcXVpcmVGYWlsdXJlJywgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgICB2YXIgaW5kZXggPSBpbkFycmF5KHRoaXMucmVxdWlyZUZhaWwsIG90aGVyUmVjb2duaXplcik7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVpcmVGYWlsLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGhhcyByZXF1aXJlIGZhaWx1cmVzIGJvb2xlYW5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNSZXF1aXJlRmFpbHVyZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1aXJlRmFpbC5sZW5ndGggPiAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBpZiB0aGUgcmVjb2duaXplciBjYW4gcmVjb2duaXplIHNpbXVsdGFuZW91cyB3aXRoIGFuIG90aGVyIHJlY29nbml6ZXJcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGNhblJlY29nbml6ZVdpdGg6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICByZXR1cm4gISF0aGlzLnNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBZb3Ugc2hvdWxkIHVzZSBgdHJ5RW1pdGAgaW5zdGVhZCBvZiBgZW1pdGAgZGlyZWN0bHkgdG8gY2hlY2tcbiAgICAgKiB0aGF0IGFsbCB0aGUgbmVlZGVkIHJlY29nbml6ZXJzIGhhcyBmYWlsZWQgYmVmb3JlIGVtaXR0aW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqL1xuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcblxuICAgICAgICBmdW5jdGlvbiBlbWl0KGV2ZW50KSB7XG4gICAgICAgICAgICBzZWxmLm1hbmFnZXIuZW1pdChldmVudCwgaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gJ3BhbnN0YXJ0JyBhbmQgJ3Bhbm1vdmUnXG4gICAgICAgIGlmIChzdGF0ZSA8IFNUQVRFX0VOREVEKSB7XG4gICAgICAgICAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCArIHN0YXRlU3RyKHN0YXRlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCk7IC8vIHNpbXBsZSAnZXZlbnROYW1lJyBldmVudHNcblxuICAgICAgICBpZiAoaW5wdXQuYWRkaXRpb25hbEV2ZW50KSB7IC8vIGFkZGl0aW9uYWwgZXZlbnQocGFubGVmdCwgcGFucmlnaHQsIHBpbmNoaW4sIHBpbmNob3V0Li4uKVxuICAgICAgICAgICAgZW1pdChpbnB1dC5hZGRpdGlvbmFsRXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGFuZW5kIGFuZCBwYW5jYW5jZWxcbiAgICAgICAgaWYgKHN0YXRlID49IFNUQVRFX0VOREVEKSB7XG4gICAgICAgICAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCArIHN0YXRlU3RyKHN0YXRlKSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhhdCBhbGwgdGhlIHJlcXVpcmUgZmFpbHVyZSByZWNvZ25pemVycyBoYXMgZmFpbGVkLFxuICAgICAqIGlmIHRydWUsIGl0IGVtaXRzIGEgZ2VzdHVyZSBldmVudCxcbiAgICAgKiBvdGhlcndpc2UsIHNldHVwIHRoZSBzdGF0ZSB0byBGQUlMRUQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICovXG4gICAgdHJ5RW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuRW1pdCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpdCdzIGZhaWxpbmcgYW55d2F5XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbiB3ZSBlbWl0P1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGNhbkVtaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgdGhpcy5yZXF1aXJlRmFpbC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMucmVxdWlyZUZhaWxbaV0uc3RhdGUgJiAoU1RBVEVfRkFJTEVEIHwgU1RBVEVfUE9TU0lCTEUpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdXBkYXRlIHRoZSByZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqL1xuICAgIHJlY29nbml6ZTogZnVuY3Rpb24oaW5wdXREYXRhKSB7XG4gICAgICAgIC8vIG1ha2UgYSBuZXcgY29weSBvZiB0aGUgaW5wdXREYXRhXG4gICAgICAgIC8vIHNvIHdlIGNhbiBjaGFuZ2UgdGhlIGlucHV0RGF0YSB3aXRob3V0IG1lc3NpbmcgdXAgdGhlIG90aGVyIHJlY29nbml6ZXJzXG4gICAgICAgIHZhciBpbnB1dERhdGFDbG9uZSA9IGFzc2lnbih7fSwgaW5wdXREYXRhKTtcblxuICAgICAgICAvLyBpcyBpcyBlbmFibGVkIGFuZCBhbGxvdyByZWNvZ25pemluZz9cbiAgICAgICAgaWYgKCFib29sT3JGbih0aGlzLm9wdGlvbnMuZW5hYmxlLCBbdGhpcywgaW5wdXREYXRhQ2xvbmVdKSkge1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0ZBSUxFRDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlc2V0IHdoZW4gd2UndmUgcmVhY2hlZCB0aGUgZW5kXG4gICAgICAgIGlmICh0aGlzLnN0YXRlICYgKFNUQVRFX1JFQ09HTklaRUQgfCBTVEFURV9DQU5DRUxMRUQgfCBTVEFURV9GQUlMRUQpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUE9TU0lCTEU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5wcm9jZXNzKGlucHV0RGF0YUNsb25lKTtcblxuICAgICAgICAvLyB0aGUgcmVjb2duaXplciBoYXMgcmVjb2duaXplZCBhIGdlc3R1cmVcbiAgICAgICAgLy8gc28gdHJpZ2dlciBhbiBldmVudFxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAmIChTVEFURV9CRUdBTiB8IFNUQVRFX0NIQU5HRUQgfCBTVEFURV9FTkRFRCB8IFNUQVRFX0NBTkNFTExFRCkpIHtcbiAgICAgICAgICAgIHRoaXMudHJ5RW1pdChpbnB1dERhdGFDbG9uZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRoZSBzdGF0ZSBvZiB0aGUgcmVjb2duaXplclxuICAgICAqIHRoZSBhY3R1YWwgcmVjb2duaXppbmcgaGFwcGVucyBpbiB0aGlzIG1ldGhvZFxuICAgICAqIEB2aXJ0dWFsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqIEByZXR1cm5zIHtDb25zdH0gU1RBVEVcbiAgICAgKi9cbiAgICBwcm9jZXNzOiBmdW5jdGlvbihpbnB1dERhdGEpIHsgfSwgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gdGhlIHByZWZlcnJlZCB0b3VjaC1hY3Rpb25cbiAgICAgKiBAdmlydHVhbFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7IH0sXG5cbiAgICAvKipcbiAgICAgKiBjYWxsZWQgd2hlbiB0aGUgZ2VzdHVyZSBpc24ndCBhbGxvd2VkIHRvIHJlY29nbml6ZVxuICAgICAqIGxpa2Ugd2hlbiBhbm90aGVyIGlzIGJlaW5nIHJlY29nbml6ZWQgb3IgaXQgaXMgZGlzYWJsZWRcbiAgICAgKiBAdmlydHVhbFxuICAgICAqL1xuICAgIHJlc2V0OiBmdW5jdGlvbigpIHsgfVxufTtcblxuLyoqXG4gKiBnZXQgYSB1c2FibGUgc3RyaW5nLCB1c2VkIGFzIGV2ZW50IHBvc3RmaXhcbiAqIEBwYXJhbSB7Q29uc3R9IHN0YXRlXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdGF0ZVxuICovXG5mdW5jdGlvbiBzdGF0ZVN0cihzdGF0ZSkge1xuICAgIGlmIChzdGF0ZSAmIFNUQVRFX0NBTkNFTExFRCkge1xuICAgICAgICByZXR1cm4gJ2NhbmNlbCc7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0VOREVEKSB7XG4gICAgICAgIHJldHVybiAnZW5kJztcbiAgICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfQ0hBTkdFRCkge1xuICAgICAgICByZXR1cm4gJ21vdmUnO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUgJiBTVEFURV9CRUdBTikge1xuICAgICAgICByZXR1cm4gJ3N0YXJ0JztcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIGRpcmVjdGlvbiBjb25zIHRvIHN0cmluZ1xuICogQHBhcmFtIHtDb25zdH0gZGlyZWN0aW9uXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBkaXJlY3Rpb25TdHIoZGlyZWN0aW9uKSB7XG4gICAgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fRE9XTikge1xuICAgICAgICByZXR1cm4gJ2Rvd24nO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09IERJUkVDVElPTl9VUCkge1xuICAgICAgICByZXR1cm4gJ3VwJztcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fTEVGVCkge1xuICAgICAgICByZXR1cm4gJ2xlZnQnO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09IERJUkVDVElPTl9SSUdIVCkge1xuICAgICAgICByZXR1cm4gJ3JpZ2h0JztcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIGdldCBhIHJlY29nbml6ZXIgYnkgbmFtZSBpZiBpdCBpcyBib3VuZCB0byBhIG1hbmFnZXJcbiAqIEBwYXJhbSB7UmVjb2duaXplcnxTdHJpbmd9IG90aGVyUmVjb2duaXplclxuICogQHBhcmFtIHtSZWNvZ25pemVyfSByZWNvZ25pemVyXG4gKiBAcmV0dXJucyB7UmVjb2duaXplcn1cbiAqL1xuZnVuY3Rpb24gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHJlY29nbml6ZXIpIHtcbiAgICB2YXIgbWFuYWdlciA9IHJlY29nbml6ZXIubWFuYWdlcjtcbiAgICBpZiAobWFuYWdlcikge1xuICAgICAgICByZXR1cm4gbWFuYWdlci5nZXQob3RoZXJSZWNvZ25pemVyKTtcbiAgICB9XG4gICAgcmV0dXJuIG90aGVyUmVjb2duaXplcjtcbn1cblxuLyoqXG4gKiBUaGlzIHJlY29nbml6ZXIgaXMganVzdCB1c2VkIGFzIGEgYmFzZSBmb3IgdGhlIHNpbXBsZSBhdHRyaWJ1dGUgcmVjb2duaXplcnMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gQXR0clJlY29nbml6ZXIoKSB7XG4gICAgUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KEF0dHJSZWNvZ25pemVyLCBSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgICAqL1xuICAgICAgICBwb2ludGVyczogMVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGNoZWNrIGlmIGl0IHRoZSByZWNvZ25pemVyIHJlY2VpdmVzIHZhbGlkIGlucHV0LCBsaWtlIGlucHV0LmRpc3RhbmNlID4gMTAuXG4gICAgICogQG1lbWJlcm9mIEF0dHJSZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHJlY29nbml6ZWRcbiAgICAgKi9cbiAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIG9wdGlvblBvaW50ZXJzID0gdGhpcy5vcHRpb25zLnBvaW50ZXJzO1xuICAgICAgICByZXR1cm4gb3B0aW9uUG9pbnRlcnMgPT09IDAgfHwgaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25Qb2ludGVycztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvY2VzcyB0aGUgaW5wdXQgYW5kIHJldHVybiB0aGUgc3RhdGUgZm9yIHRoZSByZWNvZ25pemVyXG4gICAgICogQG1lbWJlcm9mIEF0dHJSZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICogQHJldHVybnMgeyp9IFN0YXRlXG4gICAgICovXG4gICAgcHJvY2VzczogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IGlucHV0LmV2ZW50VHlwZTtcblxuICAgICAgICB2YXIgaXNSZWNvZ25pemVkID0gc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEKTtcbiAgICAgICAgdmFyIGlzVmFsaWQgPSB0aGlzLmF0dHJUZXN0KGlucHV0KTtcblxuICAgICAgICAvLyBvbiBjYW5jZWwgaW5wdXQgYW5kIHdlJ3ZlIHJlY29nbml6ZWQgYmVmb3JlLCByZXR1cm4gU1RBVEVfQ0FOQ0VMTEVEXG4gICAgICAgIGlmIChpc1JlY29nbml6ZWQgJiYgKGV2ZW50VHlwZSAmIElOUFVUX0NBTkNFTCB8fCAhaXNWYWxpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0NBTkNFTExFRDtcbiAgICAgICAgfSBlbHNlIGlmIChpc1JlY29nbml6ZWQgfHwgaXNWYWxpZCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0VOREVEO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghKHN0YXRlICYgU1RBVEVfQkVHQU4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX0JFR0FOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfQ0hBTkdFRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFBhblxuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvd24gYW5kIG1vdmVkIGluIHRoZSBhbGxvd2VkIGRpcmVjdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gUGFuUmVjb2duaXplcigpIHtcbiAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5wWCA9IG51bGw7XG4gICAgdGhpcy5wWSA9IG51bGw7XG59XG5cbmluaGVyaXQoUGFuUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFBhblJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3BhbicsXG4gICAgICAgIHRocmVzaG9sZDogMTAsXG4gICAgICAgIHBvaW50ZXJzOiAxLFxuICAgICAgICBkaXJlY3Rpb246IERJUkVDVElPTl9BTExcbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgICAgICAgdmFyIGFjdGlvbnMgPSBbXTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XG4gICAgICAgICAgICBhY3Rpb25zLnB1c2goVE9VQ0hfQUNUSU9OX1BBTl9ZKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSB7XG4gICAgICAgICAgICBhY3Rpb25zLnB1c2goVE9VQ0hfQUNUSU9OX1BBTl9YKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWN0aW9ucztcbiAgICB9LFxuXG4gICAgZGlyZWN0aW9uVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHZhciBoYXNNb3ZlZCA9IHRydWU7XG4gICAgICAgIHZhciBkaXN0YW5jZSA9IGlucHV0LmRpc3RhbmNlO1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gaW5wdXQuZGlyZWN0aW9uO1xuICAgICAgICB2YXIgeCA9IGlucHV0LmRlbHRhWDtcbiAgICAgICAgdmFyIHkgPSBpbnB1dC5kZWx0YVk7XG5cbiAgICAgICAgLy8gbG9jayB0byBheGlzP1xuICAgICAgICBpZiAoIShkaXJlY3Rpb24gJiBvcHRpb25zLmRpcmVjdGlvbikpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gKHggPT09IDApID8gRElSRUNUSU9OX05PTkUgOiAoeCA8IDApID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XG4gICAgICAgICAgICAgICAgaGFzTW92ZWQgPSB4ICE9IHRoaXMucFg7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhpbnB1dC5kZWx0YVgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSAoeSA9PT0gMCkgPyBESVJFQ1RJT05fTk9ORSA6ICh5IDwgMCkgPyBESVJFQ1RJT05fVVAgOiBESVJFQ1RJT05fRE9XTjtcbiAgICAgICAgICAgICAgICBoYXNNb3ZlZCA9IHkgIT0gdGhpcy5wWTtcbiAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IE1hdGguYWJzKGlucHV0LmRlbHRhWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXQuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgICByZXR1cm4gaGFzTW92ZWQgJiYgZGlzdGFuY2UgPiBvcHRpb25zLnRocmVzaG9sZCAmJiBkaXJlY3Rpb24gJiBvcHRpb25zLmRpcmVjdGlvbjtcbiAgICB9LFxuXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBBdHRyUmVjb2duaXplci5wcm90b3R5cGUuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiZcbiAgICAgICAgICAgICh0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4gfHwgKCEodGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKSAmJiB0aGlzLmRpcmVjdGlvblRlc3QoaW5wdXQpKSk7XG4gICAgfSxcblxuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG5cbiAgICAgICAgdGhpcy5wWCA9IGlucHV0LmRlbHRhWDtcbiAgICAgICAgdGhpcy5wWSA9IGlucHV0LmRlbHRhWTtcblxuICAgICAgICB2YXIgZGlyZWN0aW9uID0gZGlyZWN0aW9uU3RyKGlucHV0LmRpcmVjdGlvbik7XG5cbiAgICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgaW5wdXQuYWRkaXRpb25hbEV2ZW50ID0gdGhpcy5vcHRpb25zLmV2ZW50ICsgZGlyZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N1cGVyLmVtaXQuY2FsbCh0aGlzLCBpbnB1dCk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogUGluY2hcbiAqIFJlY29nbml6ZWQgd2hlbiB0d28gb3IgbW9yZSBwb2ludGVycyBhcmUgbW92aW5nIHRvd2FyZCAoem9vbS1pbikgb3IgYXdheSBmcm9tIGVhY2ggb3RoZXIgKHpvb20tb3V0KS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gUGluY2hSZWNvZ25pemVyKCkge1xuICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoUGluY2hSZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUGluY2hSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICdwaW5jaCcsXG4gICAgICAgIHRocmVzaG9sZDogMCxcbiAgICAgICAgcG9pbnRlcnM6IDJcbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9OT05FXTtcbiAgICB9LFxuXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdXBlci5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJlxuICAgICAgICAgICAgKE1hdGguYWJzKGlucHV0LnNjYWxlIC0gMSkgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkIHx8IHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTik7XG4gICAgfSxcblxuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIGlmIChpbnB1dC5zY2FsZSAhPT0gMSkge1xuICAgICAgICAgICAgdmFyIGluT3V0ID0gaW5wdXQuc2NhbGUgPCAxID8gJ2luJyA6ICdvdXQnO1xuICAgICAgICAgICAgaW5wdXQuYWRkaXRpb25hbEV2ZW50ID0gdGhpcy5vcHRpb25zLmV2ZW50ICsgaW5PdXQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3VwZXIuZW1pdC5jYWxsKHRoaXMsIGlucHV0KTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBQcmVzc1xuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvd24gZm9yIHggbXMgd2l0aG91dCBhbnkgbW92ZW1lbnQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gUHJlc3NSZWNvZ25pemVyKCkge1xuICAgIFJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICB0aGlzLl9pbnB1dCA9IG51bGw7XG59XG5cbmluaGVyaXQoUHJlc3NSZWNvZ25pemVyLCBSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQcmVzc1JlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3ByZXNzJyxcbiAgICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICAgIHRpbWU6IDI1MSwgLy8gbWluaW1hbCB0aW1lIG9mIHRoZSBwb2ludGVyIHRvIGJlIHByZXNzZWRcbiAgICAgICAgdGhyZXNob2xkOiA5IC8vIGEgbWluaW1hbCBtb3ZlbWVudCBpcyBvaywgYnV0IGtlZXAgaXQgbG93XG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fQVVUT107XG4gICAgfSxcblxuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB2YXIgdmFsaWRQb2ludGVycyA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9ucy5wb2ludGVycztcbiAgICAgICAgdmFyIHZhbGlkTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IG9wdGlvbnMudGhyZXNob2xkO1xuICAgICAgICB2YXIgdmFsaWRUaW1lID0gaW5wdXQuZGVsdGFUaW1lID4gb3B0aW9ucy50aW1lO1xuXG4gICAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG5cbiAgICAgICAgLy8gd2Ugb25seSBhbGxvdyBsaXR0bGUgbW92ZW1lbnRcbiAgICAgICAgLy8gYW5kIHdlJ3ZlIHJlYWNoZWQgYW4gZW5kIGV2ZW50LCBzbyBhIHRhcCBpcyBwb3NzaWJsZVxuICAgICAgICBpZiAoIXZhbGlkTW92ZW1lbnQgfHwgIXZhbGlkUG9pbnRlcnMgfHwgKGlucHV0LmV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmICF2YWxpZFRpbWUpKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dENvbnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgICAgICAgICAgdGhpcy50cnlFbWl0KCk7XG4gICAgICAgICAgICB9LCBvcHRpb25zLnRpbWUsIHRoaXMpO1xuICAgICAgICB9IGVsc2UgaWYgKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICAgICAgcmV0dXJuIFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICB9LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICAgIH0sXG5cbiAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU1RBVEVfUkVDT0dOSVpFRCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlucHV0ICYmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQpKSB7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQgKyAndXAnLCBpbnB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pbnB1dC50aW1lU3RhbXAgPSBub3coKTtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgdGhpcy5faW5wdXQpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKlxuICogUm90YXRlXG4gKiBSZWNvZ25pemVkIHdoZW4gdHdvIG9yIG1vcmUgcG9pbnRlciBhcmUgbW92aW5nIGluIGEgY2lyY3VsYXIgbW90aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxuICovXG5mdW5jdGlvbiBSb3RhdGVSZWNvZ25pemVyKCkge1xuICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoUm90YXRlUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFJvdGF0ZVJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3JvdGF0ZScsXG4gICAgICAgIHRocmVzaG9sZDogMCxcbiAgICAgICAgcG9pbnRlcnM6IDJcbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9OT05FXTtcbiAgICB9LFxuXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdXBlci5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJlxuICAgICAgICAgICAgKE1hdGguYWJzKGlucHV0LnJvdGF0aW9uKSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgfHwgdGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBTd2lwZVxuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIG1vdmluZyBmYXN0ICh2ZWxvY2l0eSksIHdpdGggZW5vdWdoIGRpc3RhbmNlIGluIHRoZSBhbGxvd2VkIGRpcmVjdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gU3dpcGVSZWNvZ25pemVyKCkge1xuICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoU3dpcGVSZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgU3dpcGVSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICdzd2lwZScsXG4gICAgICAgIHRocmVzaG9sZDogMTAsXG4gICAgICAgIHZlbG9jaXR5OiAwLjMsXG4gICAgICAgIGRpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUwsXG4gICAgICAgIHBvaW50ZXJzOiAxXG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFBhblJlY29nbml6ZXIucHJvdG90eXBlLmdldFRvdWNoQWN0aW9uLmNhbGwodGhpcyk7XG4gICAgfSxcblxuICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgICAgICAgdmFyIHZlbG9jaXR5O1xuXG4gICAgICAgIGlmIChkaXJlY3Rpb24gJiAoRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUwpKSB7XG4gICAgICAgICAgICB2ZWxvY2l0eSA9IGlucHV0Lm92ZXJhbGxWZWxvY2l0eTtcbiAgICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICAgICAgdmVsb2NpdHkgPSBpbnB1dC5vdmVyYWxsVmVsb2NpdHlYO1xuICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkge1xuICAgICAgICAgICAgdmVsb2NpdHkgPSBpbnB1dC5vdmVyYWxsVmVsb2NpdHlZO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1cGVyLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmXG4gICAgICAgICAgICBkaXJlY3Rpb24gJiBpbnB1dC5vZmZzZXREaXJlY3Rpb24gJiZcbiAgICAgICAgICAgIGlucHV0LmRpc3RhbmNlID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCAmJlxuICAgICAgICAgICAgaW5wdXQubWF4UG9pbnRlcnMgPT0gdGhpcy5vcHRpb25zLnBvaW50ZXJzICYmXG4gICAgICAgICAgICBhYnModmVsb2NpdHkpID4gdGhpcy5vcHRpb25zLnZlbG9jaXR5ICYmIGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORDtcbiAgICB9LFxuXG4gICAgZW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGRpcmVjdGlvblN0cihpbnB1dC5vZmZzZXREaXJlY3Rpb24pO1xuICAgICAgICBpZiAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQgKyBkaXJlY3Rpb24sIGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgaW5wdXQpO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIEEgdGFwIGlzIGVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvaW5nIGEgc21hbGwgdGFwL2NsaWNrLiBNdWx0aXBsZSB0YXBzIGFyZSByZWNvZ25pemVkIGlmIHRoZXkgb2NjdXJcbiAqIGJldHdlZW4gdGhlIGdpdmVuIGludGVydmFsIGFuZCBwb3NpdGlvbi4gVGhlIGRlbGF5IG9wdGlvbiBjYW4gYmUgdXNlZCB0byByZWNvZ25pemUgbXVsdGktdGFwcyB3aXRob3V0IGZpcmluZ1xuICogYSBzaW5nbGUgdGFwLlxuICpcbiAqIFRoZSBldmVudERhdGEgZnJvbSB0aGUgZW1pdHRlZCBldmVudCBjb250YWlucyB0aGUgcHJvcGVydHkgYHRhcENvdW50YCwgd2hpY2ggY29udGFpbnMgdGhlIGFtb3VudCBvZlxuICogbXVsdGktdGFwcyBiZWluZyByZWNvZ25pemVkLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIFRhcFJlY29nbml6ZXIoKSB7XG4gICAgUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgLy8gcHJldmlvdXMgdGltZSBhbmQgY2VudGVyLFxuICAgIC8vIHVzZWQgZm9yIHRhcCBjb3VudGluZ1xuICAgIHRoaXMucFRpbWUgPSBmYWxzZTtcbiAgICB0aGlzLnBDZW50ZXIgPSBmYWxzZTtcblxuICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICB0aGlzLl9pbnB1dCA9IG51bGw7XG4gICAgdGhpcy5jb3VudCA9IDA7XG59XG5cbmluaGVyaXQoVGFwUmVjb2duaXplciwgUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUGluY2hSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICd0YXAnLFxuICAgICAgICBwb2ludGVyczogMSxcbiAgICAgICAgdGFwczogMSxcbiAgICAgICAgaW50ZXJ2YWw6IDMwMCwgLy8gbWF4IHRpbWUgYmV0d2VlbiB0aGUgbXVsdGktdGFwIHRhcHNcbiAgICAgICAgdGltZTogMjUwLCAvLyBtYXggdGltZSBvZiB0aGUgcG9pbnRlciB0byBiZSBkb3duIChsaWtlIGZpbmdlciBvbiB0aGUgc2NyZWVuKVxuICAgICAgICB0aHJlc2hvbGQ6IDksIC8vIGEgbWluaW1hbCBtb3ZlbWVudCBpcyBvaywgYnV0IGtlZXAgaXQgbG93XG4gICAgICAgIHBvc1RocmVzaG9sZDogMTAgLy8gYSBtdWx0aS10YXAgY2FuIGJlIGEgYml0IG9mZiB0aGUgaW5pdGlhbCBwb3NpdGlvblxuICAgIH0sXG5cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTl07XG4gICAgfSxcblxuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgICAgIHZhciB2YWxpZFBvaW50ZXJzID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25zLnBvaW50ZXJzO1xuICAgICAgICB2YXIgdmFsaWRNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgb3B0aW9ucy50aHJlc2hvbGQ7XG4gICAgICAgIHZhciB2YWxpZFRvdWNoVGltZSA9IGlucHV0LmRlbHRhVGltZSA8IG9wdGlvbnMudGltZTtcblxuICAgICAgICB0aGlzLnJlc2V0KCk7XG5cbiAgICAgICAgaWYgKChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9TVEFSVCkgJiYgKHRoaXMuY291bnQgPT09IDApKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mYWlsVGltZW91dCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2Ugb25seSBhbGxvdyBsaXR0bGUgbW92ZW1lbnRcbiAgICAgICAgLy8gYW5kIHdlJ3ZlIHJlYWNoZWQgYW4gZW5kIGV2ZW50LCBzbyBhIHRhcCBpcyBwb3NzaWJsZVxuICAgICAgICBpZiAodmFsaWRNb3ZlbWVudCAmJiB2YWxpZFRvdWNoVGltZSAmJiB2YWxpZFBvaW50ZXJzKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuZXZlbnRUeXBlICE9IElOUFVUX0VORCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZhaWxUaW1lb3V0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB2YWxpZEludGVydmFsID0gdGhpcy5wVGltZSA/IChpbnB1dC50aW1lU3RhbXAgLSB0aGlzLnBUaW1lIDwgb3B0aW9ucy5pbnRlcnZhbCkgOiB0cnVlO1xuICAgICAgICAgICAgdmFyIHZhbGlkTXVsdGlUYXAgPSAhdGhpcy5wQ2VudGVyIHx8IGdldERpc3RhbmNlKHRoaXMucENlbnRlciwgaW5wdXQuY2VudGVyKSA8IG9wdGlvbnMucG9zVGhyZXNob2xkO1xuXG4gICAgICAgICAgICB0aGlzLnBUaW1lID0gaW5wdXQudGltZVN0YW1wO1xuICAgICAgICAgICAgdGhpcy5wQ2VudGVyID0gaW5wdXQuY2VudGVyO1xuXG4gICAgICAgICAgICBpZiAoIXZhbGlkTXVsdGlUYXAgfHwgIXZhbGlkSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50ID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3VudCArPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9pbnB1dCA9IGlucHV0O1xuXG4gICAgICAgICAgICAvLyBpZiB0YXAgY291bnQgbWF0Y2hlcyB3ZSBoYXZlIHJlY29nbml6ZWQgaXQsXG4gICAgICAgICAgICAvLyBlbHNlIGl0IGhhcyBiZWdhbiByZWNvZ25pemluZy4uLlxuICAgICAgICAgICAgdmFyIHRhcENvdW50ID0gdGhpcy5jb3VudCAlIG9wdGlvbnMudGFwcztcbiAgICAgICAgICAgIGlmICh0YXBDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIG5vIGZhaWxpbmcgcmVxdWlyZW1lbnRzLCBpbW1lZGlhdGVseSB0cmlnZ2VyIHRoZSB0YXAgZXZlbnRcbiAgICAgICAgICAgICAgICAvLyBvciB3YWl0IGFzIGxvbmcgYXMgdGhlIG11bHRpdGFwIGludGVydmFsIHRvIHRyaWdnZXJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaGFzUmVxdWlyZUZhaWx1cmVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0Q29udGV4dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cnlFbWl0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMuaW50ZXJ2YWwsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfQkVHQU47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gICAgfSxcblxuICAgIGZhaWxUaW1lb3V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0Q29udGV4dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gICAgICAgIH0sIHRoaXMub3B0aW9ucy5pbnRlcnZhbCwgdGhpcyk7XG4gICAgICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gICAgfSxcblxuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgICB9LFxuXG4gICAgZW1pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09IFNUQVRFX1JFQ09HTklaRUQpIHtcbiAgICAgICAgICAgIHRoaXMuX2lucHV0LnRhcENvdW50ID0gdGhpcy5jb3VudDtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgdGhpcy5faW5wdXQpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKlxuICogU2ltcGxlIHdheSB0byBjcmVhdGUgYSBtYW5hZ2VyIHdpdGggYSBkZWZhdWx0IHNldCBvZiByZWNvZ25pemVycy5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBIYW1tZXIoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMucmVjb2duaXplcnMgPSBpZlVuZGVmaW5lZChvcHRpb25zLnJlY29nbml6ZXJzLCBIYW1tZXIuZGVmYXVsdHMucHJlc2V0KTtcbiAgICByZXR1cm4gbmV3IE1hbmFnZXIoZWxlbWVudCwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogQGNvbnN0IHtzdHJpbmd9XG4gKi9cbkhhbW1lci5WRVJTSU9OID0gJzIuMC43JztcblxuLyoqXG4gKiBkZWZhdWx0IHNldHRpbmdzXG4gKiBAbmFtZXNwYWNlXG4gKi9cbkhhbW1lci5kZWZhdWx0cyA9IHtcbiAgICAvKipcbiAgICAgKiBzZXQgaWYgRE9NIGV2ZW50cyBhcmUgYmVpbmcgdHJpZ2dlcmVkLlxuICAgICAqIEJ1dCB0aGlzIGlzIHNsb3dlciBhbmQgdW51c2VkIGJ5IHNpbXBsZSBpbXBsZW1lbnRhdGlvbnMsIHNvIGRpc2FibGVkIGJ5IGRlZmF1bHQuXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBkb21FdmVudHM6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGZvciB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkvZmFsbGJhY2suXG4gICAgICogV2hlbiBzZXQgdG8gYGNvbXB1dGVgIGl0IHdpbGwgbWFnaWNhbGx5IHNldCB0aGUgY29ycmVjdCB2YWx1ZSBiYXNlZCBvbiB0aGUgYWRkZWQgcmVjb2duaXplcnMuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBjb21wdXRlXG4gICAgICovXG4gICAgdG91Y2hBY3Rpb246IFRPVUNIX0FDVElPTl9DT01QVVRFLFxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIGVuYWJsZTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEVYUEVSSU1FTlRBTCBGRUFUVVJFIC0tIGNhbiBiZSByZW1vdmVkL2NoYW5nZWRcbiAgICAgKiBDaGFuZ2UgdGhlIHBhcmVudCBpbnB1dCB0YXJnZXQgZWxlbWVudC5cbiAgICAgKiBJZiBOdWxsLCB0aGVuIGl0IGlzIGJlaW5nIHNldCB0aGUgdG8gbWFpbiBlbGVtZW50LlxuICAgICAqIEB0eXBlIHtOdWxsfEV2ZW50VGFyZ2V0fVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICBpbnB1dFRhcmdldDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIGZvcmNlIGFuIGlucHV0IGNsYXNzXG4gICAgICogQHR5cGUge051bGx8RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIGlucHV0Q2xhc3M6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHJlY29nbml6ZXIgc2V0dXAgd2hlbiBjYWxsaW5nIGBIYW1tZXIoKWBcbiAgICAgKiBXaGVuIGNyZWF0aW5nIGEgbmV3IE1hbmFnZXIgdGhlc2Ugd2lsbCBiZSBza2lwcGVkLlxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICBwcmVzZXQ6IFtcbiAgICAgICAgLy8gUmVjb2duaXplckNsYXNzLCBvcHRpb25zLCBbcmVjb2duaXplV2l0aCwgLi4uXSwgW3JlcXVpcmVGYWlsdXJlLCAuLi5dXG4gICAgICAgIFtSb3RhdGVSZWNvZ25pemVyLCB7ZW5hYmxlOiBmYWxzZX1dLFxuICAgICAgICBbUGluY2hSZWNvZ25pemVyLCB7ZW5hYmxlOiBmYWxzZX0sIFsncm90YXRlJ11dLFxuICAgICAgICBbU3dpcGVSZWNvZ25pemVyLCB7ZGlyZWN0aW9uOiBESVJFQ1RJT05fSE9SSVpPTlRBTH1dLFxuICAgICAgICBbUGFuUmVjb2duaXplciwge2RpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUx9LCBbJ3N3aXBlJ11dLFxuICAgICAgICBbVGFwUmVjb2duaXplcl0sXG4gICAgICAgIFtUYXBSZWNvZ25pemVyLCB7ZXZlbnQ6ICdkb3VibGV0YXAnLCB0YXBzOiAyfSwgWyd0YXAnXV0sXG4gICAgICAgIFtQcmVzc1JlY29nbml6ZXJdXG4gICAgXSxcblxuICAgIC8qKlxuICAgICAqIFNvbWUgQ1NTIHByb3BlcnRpZXMgY2FuIGJlIHVzZWQgdG8gaW1wcm92ZSB0aGUgd29ya2luZyBvZiBIYW1tZXIuXG4gICAgICogQWRkIHRoZW0gdG8gdGhpcyBtZXRob2QgYW5kIHRoZXkgd2lsbCBiZSBzZXQgd2hlbiBjcmVhdGluZyBhIG5ldyBNYW5hZ2VyLlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKi9cbiAgICBjc3NQcm9wczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogRGlzYWJsZXMgdGV4dCBzZWxlY3Rpb24gdG8gaW1wcm92ZSB0aGUgZHJhZ2dpbmcgZ2VzdHVyZS4gTWFpbmx5IGZvciBkZXNrdG9wIGJyb3dzZXJzLlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICovXG4gICAgICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzYWJsZSB0aGUgV2luZG93cyBQaG9uZSBncmlwcGVycyB3aGVuIHByZXNzaW5nIGFuIGVsZW1lbnQuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICAgKi9cbiAgICAgICAgdG91Y2hTZWxlY3Q6ICdub25lJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzYWJsZXMgdGhlIGRlZmF1bHQgY2FsbG91dCBzaG93biB3aGVuIHlvdSB0b3VjaCBhbmQgaG9sZCBhIHRvdWNoIHRhcmdldC5cbiAgICAgICAgICogT24gaU9TLCB3aGVuIHlvdSB0b3VjaCBhbmQgaG9sZCBhIHRvdWNoIHRhcmdldCBzdWNoIGFzIGEgbGluaywgU2FmYXJpIGRpc3BsYXlzXG4gICAgICAgICAqIGEgY2FsbG91dCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBsaW5rLiBUaGlzIHByb3BlcnR5IGFsbG93cyB5b3UgdG8gZGlzYWJsZSB0aGF0IGNhbGxvdXQuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICAgKi9cbiAgICAgICAgdG91Y2hDYWxsb3V0OiAnbm9uZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB3aGV0aGVyIHpvb21pbmcgaXMgZW5hYmxlZC4gVXNlZCBieSBJRTEwPlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICovXG4gICAgICAgIGNvbnRlbnRab29taW5nOiAnbm9uZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGF0IGFuIGVudGlyZSBlbGVtZW50IHNob3VsZCBiZSBkcmFnZ2FibGUgaW5zdGVhZCBvZiBpdHMgY29udGVudHMuIE1haW5seSBmb3IgZGVza3RvcCBicm93c2Vycy5cbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgICAqL1xuICAgICAgICB1c2VyRHJhZzogJ25vbmUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdmVycmlkZXMgdGhlIGhpZ2hsaWdodCBjb2xvciBzaG93biB3aGVuIHRoZSB1c2VyIHRhcHMgYSBsaW5rIG9yIGEgSmF2YVNjcmlwdFxuICAgICAgICAgKiBjbGlja2FibGUgZWxlbWVudCBpbiBpT1MuIFRoaXMgcHJvcGVydHkgb2JleXMgdGhlIGFscGhhIHZhbHVlLCBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdyZ2JhKDAsMCwwLDApJ1xuICAgICAgICAgKi9cbiAgICAgICAgdGFwSGlnaGxpZ2h0Q29sb3I6ICdyZ2JhKDAsMCwwLDApJ1xuICAgIH1cbn07XG5cbnZhciBTVE9QID0gMTtcbnZhciBGT1JDRURfU1RPUCA9IDI7XG5cbi8qKlxuICogTWFuYWdlclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE1hbmFnZXIoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IGFzc2lnbih7fSwgSGFtbWVyLmRlZmF1bHRzLCBvcHRpb25zIHx8IHt9KTtcblxuICAgIHRoaXMub3B0aW9ucy5pbnB1dFRhcmdldCA9IHRoaXMub3B0aW9ucy5pbnB1dFRhcmdldCB8fCBlbGVtZW50O1xuXG4gICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgIHRoaXMuc2Vzc2lvbiA9IHt9O1xuICAgIHRoaXMucmVjb2duaXplcnMgPSBbXTtcbiAgICB0aGlzLm9sZENzc1Byb3BzID0ge307XG5cbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuaW5wdXQgPSBjcmVhdGVJbnB1dEluc3RhbmNlKHRoaXMpO1xuICAgIHRoaXMudG91Y2hBY3Rpb24gPSBuZXcgVG91Y2hBY3Rpb24odGhpcywgdGhpcy5vcHRpb25zLnRvdWNoQWN0aW9uKTtcblxuICAgIHRvZ2dsZUNzc1Byb3BzKHRoaXMsIHRydWUpO1xuXG4gICAgZWFjaCh0aGlzLm9wdGlvbnMucmVjb2duaXplcnMsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgdmFyIHJlY29nbml6ZXIgPSB0aGlzLmFkZChuZXcgKGl0ZW1bMF0pKGl0ZW1bMV0pKTtcbiAgICAgICAgaXRlbVsyXSAmJiByZWNvZ25pemVyLnJlY29nbml6ZVdpdGgoaXRlbVsyXSk7XG4gICAgICAgIGl0ZW1bM10gJiYgcmVjb2duaXplci5yZXF1aXJlRmFpbHVyZShpdGVtWzNdKTtcbiAgICB9LCB0aGlzKTtcbn1cblxuTWFuYWdlci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogc2V0IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtNYW5hZ2VyfVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBhc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgICAvLyBPcHRpb25zIHRoYXQgbmVlZCBhIGxpdHRsZSBtb3JlIHNldHVwXG4gICAgICAgIGlmIChvcHRpb25zLnRvdWNoQWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmlucHV0VGFyZ2V0KSB7XG4gICAgICAgICAgICAvLyBDbGVhbiB1cCBleGlzdGluZyBldmVudCBsaXN0ZW5lcnMgYW5kIHJlaW5pdGlhbGl6ZVxuICAgICAgICAgICAgdGhpcy5pbnB1dC5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmlucHV0LnRhcmdldCA9IG9wdGlvbnMuaW5wdXRUYXJnZXQ7XG4gICAgICAgICAgICB0aGlzLmlucHV0LmluaXQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc3RvcCByZWNvZ25pemluZyBmb3IgdGhpcyBzZXNzaW9uLlxuICAgICAqIFRoaXMgc2Vzc2lvbiB3aWxsIGJlIGRpc2NhcmRlZCwgd2hlbiBhIG5ldyBbaW5wdXRdc3RhcnQgZXZlbnQgaXMgZmlyZWQuXG4gICAgICogV2hlbiBmb3JjZWQsIHRoZSByZWNvZ25pemVyIGN5Y2xlIGlzIHN0b3BwZWQgaW1tZWRpYXRlbHkuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2VdXG4gICAgICovXG4gICAgc3RvcDogZnVuY3Rpb24oZm9yY2UpIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uLnN0b3BwZWQgPSBmb3JjZSA/IEZPUkNFRF9TVE9QIDogU1RPUDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcnVuIHRoZSByZWNvZ25pemVycyFcbiAgICAgKiBjYWxsZWQgYnkgdGhlIGlucHV0SGFuZGxlciBmdW5jdGlvbiBvbiBldmVyeSBtb3ZlbWVudCBvZiB0aGUgcG9pbnRlcnMgKHRvdWNoZXMpXG4gICAgICogaXQgd2Fsa3MgdGhyb3VnaCBhbGwgdGhlIHJlY29nbml6ZXJzIGFuZCB0cmllcyB0byBkZXRlY3QgdGhlIGdlc3R1cmUgdGhhdCBpcyBiZWluZyBtYWRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqL1xuICAgIHJlY29nbml6ZTogZnVuY3Rpb24oaW5wdXREYXRhKSB7XG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xuICAgICAgICBpZiAoc2Vzc2lvbi5zdG9wcGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBydW4gdGhlIHRvdWNoLWFjdGlvbiBwb2x5ZmlsbFxuICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnByZXZlbnREZWZhdWx0cyhpbnB1dERhdGEpO1xuXG4gICAgICAgIHZhciByZWNvZ25pemVyO1xuICAgICAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzO1xuXG4gICAgICAgIC8vIHRoaXMgaG9sZHMgdGhlIHJlY29nbml6ZXIgdGhhdCBpcyBiZWluZyByZWNvZ25pemVkLlxuICAgICAgICAvLyBzbyB0aGUgcmVjb2duaXplcidzIHN0YXRlIG5lZWRzIHRvIGJlIEJFR0FOLCBDSEFOR0VELCBFTkRFRCBvciBSRUNPR05JWkVEXG4gICAgICAgIC8vIGlmIG5vIHJlY29nbml6ZXIgaXMgZGV0ZWN0aW5nIGEgdGhpbmcsIGl0IGlzIHNldCB0byBgbnVsbGBcbiAgICAgICAgdmFyIGN1clJlY29nbml6ZXIgPSBzZXNzaW9uLmN1clJlY29nbml6ZXI7XG5cbiAgICAgICAgLy8gcmVzZXQgd2hlbiB0aGUgbGFzdCByZWNvZ25pemVyIGlzIHJlY29nbml6ZWRcbiAgICAgICAgLy8gb3Igd2hlbiB3ZSdyZSBpbiBhIG5ldyBzZXNzaW9uXG4gICAgICAgIGlmICghY3VyUmVjb2duaXplciB8fCAoY3VyUmVjb2duaXplciAmJiBjdXJSZWNvZ25pemVyLnN0YXRlICYgU1RBVEVfUkVDT0dOSVpFRCkpIHtcbiAgICAgICAgICAgIGN1clJlY29nbml6ZXIgPSBzZXNzaW9uLmN1clJlY29nbml6ZXIgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHJlY29nbml6ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVjb2duaXplciA9IHJlY29nbml6ZXJzW2ldO1xuXG4gICAgICAgICAgICAvLyBmaW5kIG91dCBpZiB3ZSBhcmUgYWxsb3dlZCB0cnkgdG8gcmVjb2duaXplIHRoZSBpbnB1dCBmb3IgdGhpcyBvbmUuXG4gICAgICAgICAgICAvLyAxLiAgIGFsbG93IGlmIHRoZSBzZXNzaW9uIGlzIE5PVCBmb3JjZWQgc3RvcHBlZCAoc2VlIHRoZSAuc3RvcCgpIG1ldGhvZClcbiAgICAgICAgICAgIC8vIDIuICAgYWxsb3cgaWYgd2Ugc3RpbGwgaGF2ZW4ndCByZWNvZ25pemVkIGEgZ2VzdHVyZSBpbiB0aGlzIHNlc3Npb24sIG9yIHRoZSB0aGlzIHJlY29nbml6ZXIgaXMgdGhlIG9uZVxuICAgICAgICAgICAgLy8gICAgICB0aGF0IGlzIGJlaW5nIHJlY29nbml6ZWQuXG4gICAgICAgICAgICAvLyAzLiAgIGFsbG93IGlmIHRoZSByZWNvZ25pemVyIGlzIGFsbG93ZWQgdG8gcnVuIHNpbXVsdGFuZW91cyB3aXRoIHRoZSBjdXJyZW50IHJlY29nbml6ZWQgcmVjb2duaXplci5cbiAgICAgICAgICAgIC8vICAgICAgdGhpcyBjYW4gYmUgc2V0dXAgd2l0aCB0aGUgYHJlY29nbml6ZVdpdGgoKWAgbWV0aG9kIG9uIHRoZSByZWNvZ25pemVyLlxuICAgICAgICAgICAgaWYgKHNlc3Npb24uc3RvcHBlZCAhPT0gRk9SQ0VEX1NUT1AgJiYgKCAvLyAxXG4gICAgICAgICAgICAgICAgICAgICFjdXJSZWNvZ25pemVyIHx8IHJlY29nbml6ZXIgPT0gY3VyUmVjb2duaXplciB8fCAvLyAyXG4gICAgICAgICAgICAgICAgICAgIHJlY29nbml6ZXIuY2FuUmVjb2duaXplV2l0aChjdXJSZWNvZ25pemVyKSkpIHsgLy8gM1xuICAgICAgICAgICAgICAgIHJlY29nbml6ZXIucmVjb2duaXplKGlucHV0RGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlY29nbml6ZXIucmVzZXQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlIHJlY29nbml6ZXIgaGFzIGJlZW4gcmVjb2duaXppbmcgdGhlIGlucHV0IGFzIGEgdmFsaWQgZ2VzdHVyZSwgd2Ugd2FudCB0byBzdG9yZSB0aGlzIG9uZSBhcyB0aGVcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgYWN0aXZlIHJlY29nbml6ZXIuIGJ1dCBvbmx5IGlmIHdlIGRvbid0IGFscmVhZHkgaGF2ZSBhbiBhY3RpdmUgcmVjb2duaXplclxuICAgICAgICAgICAgaWYgKCFjdXJSZWNvZ25pemVyICYmIHJlY29nbml6ZXIuc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEIHwgU1RBVEVfRU5ERUQpKSB7XG4gICAgICAgICAgICAgICAgY3VyUmVjb2duaXplciA9IHNlc3Npb24uY3VyUmVjb2duaXplciA9IHJlY29nbml6ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZ2V0IGEgcmVjb2duaXplciBieSBpdHMgZXZlbnQgbmFtZS5cbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSByZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ8TnVsbH1cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKHJlY29nbml6ZXIgaW5zdGFuY2VvZiBSZWNvZ25pemVyKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjb2duaXplcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjb2duaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChyZWNvZ25pemVyc1tpXS5vcHRpb25zLmV2ZW50ID09IHJlY29nbml6ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjb2duaXplcnNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGFkZCBhIHJlY29nbml6ZXIgdG8gdGhlIG1hbmFnZXJcbiAgICAgKiBleGlzdGluZyByZWNvZ25pemVycyB3aXRoIHRoZSBzYW1lIGV2ZW50IG5hbWUgd2lsbCBiZSByZW1vdmVkXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSByZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ8TWFuYWdlcn1cbiAgICAgKi9cbiAgICBhZGQ6IGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKHJlY29nbml6ZXIsICdhZGQnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgZXhpc3RpbmdcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gdGhpcy5nZXQocmVjb2duaXplci5vcHRpb25zLmV2ZW50KTtcbiAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZShleGlzdGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlY29nbml6ZXJzLnB1c2gocmVjb2duaXplcik7XG4gICAgICAgIHJlY29nbml6ZXIubWFuYWdlciA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHJlY29nbml6ZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSBhIHJlY29nbml6ZXIgYnkgbmFtZSBvciBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcnxTdHJpbmd9IHJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7TWFuYWdlcn1cbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKHJlY29nbml6ZXIsICdyZW1vdmUnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICByZWNvZ25pemVyID0gdGhpcy5nZXQocmVjb2duaXplcik7XG5cbiAgICAgICAgLy8gbGV0J3MgbWFrZSBzdXJlIHRoaXMgcmVjb2duaXplciBleGlzdHNcbiAgICAgICAgaWYgKHJlY29nbml6ZXIpIHtcbiAgICAgICAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBpbkFycmF5KHJlY29nbml6ZXJzLCByZWNvZ25pemVyKTtcblxuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJlY29nbml6ZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBiaW5kIGV2ZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50c1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICAgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSB0aGlzXG4gICAgICovXG4gICAgb246IGZ1bmN0aW9uKGV2ZW50cywgaGFuZGxlcikge1xuICAgICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzO1xuICAgICAgICBlYWNoKHNwbGl0U3RyKGV2ZW50cyksIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBoYW5kbGVyc1tldmVudF0gPSBoYW5kbGVyc1tldmVudF0gfHwgW107XG4gICAgICAgICAgICBoYW5kbGVyc1tldmVudF0ucHVzaChoYW5kbGVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB1bmJpbmQgZXZlbnQsIGxlYXZlIGVtaXQgYmxhbmsgdG8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudHNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcl1cbiAgICAgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSB0aGlzXG4gICAgICovXG4gICAgb2ZmOiBmdW5jdGlvbihldmVudHMsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzO1xuICAgICAgICBlYWNoKHNwbGl0U3RyKGV2ZW50cyksIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgaGFuZGxlcnNbZXZlbnRdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyc1tldmVudF0gJiYgaGFuZGxlcnNbZXZlbnRdLnNwbGljZShpbkFycmF5KGhhbmRsZXJzW2V2ZW50XSwgaGFuZGxlciksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGVtaXQgZXZlbnQgdG8gdGhlIGxpc3RlbmVyc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgZW1pdDogZnVuY3Rpb24oZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgLy8gd2UgYWxzbyB3YW50IHRvIHRyaWdnZXIgZG9tIGV2ZW50c1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRvbUV2ZW50cykge1xuICAgICAgICAgICAgdHJpZ2dlckRvbUV2ZW50KGV2ZW50LCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vIGhhbmRsZXJzLCBzbyBza2lwIGl0IGFsbFxuICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzW2V2ZW50XSAmJiB0aGlzLmhhbmRsZXJzW2V2ZW50XS5zbGljZSgpO1xuICAgICAgICBpZiAoIWhhbmRsZXJzIHx8ICFoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEudHlwZSA9IGV2ZW50O1xuICAgICAgICBkYXRhLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkYXRhLnNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IGhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgaGFuZGxlcnNbaV0oZGF0YSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZGVzdHJveSB0aGUgbWFuYWdlciBhbmQgdW5iaW5kcyBhbGwgZXZlbnRzXG4gICAgICogaXQgZG9lc24ndCB1bmJpbmQgZG9tIGV2ZW50cywgdGhhdCBpcyB0aGUgdXNlciBvd24gcmVzcG9uc2liaWxpdHlcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ICYmIHRvZ2dsZUNzc1Byb3BzKHRoaXMsIGZhbHNlKTtcblxuICAgICAgICB0aGlzLmhhbmRsZXJzID0ge307XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHt9O1xuICAgICAgICB0aGlzLmlucHV0LmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICB9XG59O1xuXG4vKipcbiAqIGFkZC9yZW1vdmUgdGhlIGNzcyBwcm9wZXJ0aWVzIGFzIGRlZmluZWQgaW4gbWFuYWdlci5vcHRpb25zLmNzc1Byb3BzXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYWRkXG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZUNzc1Byb3BzKG1hbmFnZXIsIGFkZCkge1xuICAgIHZhciBlbGVtZW50ID0gbWFuYWdlci5lbGVtZW50O1xuICAgIGlmICghZWxlbWVudC5zdHlsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwcm9wO1xuICAgIGVhY2gobWFuYWdlci5vcHRpb25zLmNzc1Byb3BzLCBmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICBwcm9wID0gcHJlZml4ZWQoZWxlbWVudC5zdHlsZSwgbmFtZSk7XG4gICAgICAgIGlmIChhZGQpIHtcbiAgICAgICAgICAgIG1hbmFnZXIub2xkQ3NzUHJvcHNbcHJvcF0gPSBlbGVtZW50LnN0eWxlW3Byb3BdO1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IG1hbmFnZXIub2xkQ3NzUHJvcHNbcHJvcF0gfHwgJyc7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWFkZCkge1xuICAgICAgICBtYW5hZ2VyLm9sZENzc1Byb3BzID0ge307XG4gICAgfVxufVxuXG4vKipcbiAqIHRyaWdnZXIgZG9tIGV2ZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKi9cbmZ1bmN0aW9uIHRyaWdnZXJEb21FdmVudChldmVudCwgZGF0YSkge1xuICAgIHZhciBnZXN0dXJlRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBnZXN0dXJlRXZlbnQuaW5pdEV2ZW50KGV2ZW50LCB0cnVlLCB0cnVlKTtcbiAgICBnZXN0dXJlRXZlbnQuZ2VzdHVyZSA9IGRhdGE7XG4gICAgZGF0YS50YXJnZXQuZGlzcGF0Y2hFdmVudChnZXN0dXJlRXZlbnQpO1xufVxuXG5hc3NpZ24oSGFtbWVyLCB7XG4gICAgSU5QVVRfU1RBUlQ6IElOUFVUX1NUQVJULFxuICAgIElOUFVUX01PVkU6IElOUFVUX01PVkUsXG4gICAgSU5QVVRfRU5EOiBJTlBVVF9FTkQsXG4gICAgSU5QVVRfQ0FOQ0VMOiBJTlBVVF9DQU5DRUwsXG5cbiAgICBTVEFURV9QT1NTSUJMRTogU1RBVEVfUE9TU0lCTEUsXG4gICAgU1RBVEVfQkVHQU46IFNUQVRFX0JFR0FOLFxuICAgIFNUQVRFX0NIQU5HRUQ6IFNUQVRFX0NIQU5HRUQsXG4gICAgU1RBVEVfRU5ERUQ6IFNUQVRFX0VOREVELFxuICAgIFNUQVRFX1JFQ09HTklaRUQ6IFNUQVRFX1JFQ09HTklaRUQsXG4gICAgU1RBVEVfQ0FOQ0VMTEVEOiBTVEFURV9DQU5DRUxMRUQsXG4gICAgU1RBVEVfRkFJTEVEOiBTVEFURV9GQUlMRUQsXG5cbiAgICBESVJFQ1RJT05fTk9ORTogRElSRUNUSU9OX05PTkUsXG4gICAgRElSRUNUSU9OX0xFRlQ6IERJUkVDVElPTl9MRUZULFxuICAgIERJUkVDVElPTl9SSUdIVDogRElSRUNUSU9OX1JJR0hULFxuICAgIERJUkVDVElPTl9VUDogRElSRUNUSU9OX1VQLFxuICAgIERJUkVDVElPTl9ET1dOOiBESVJFQ1RJT05fRE9XTixcbiAgICBESVJFQ1RJT05fSE9SSVpPTlRBTDogRElSRUNUSU9OX0hPUklaT05UQUwsXG4gICAgRElSRUNUSU9OX1ZFUlRJQ0FMOiBESVJFQ1RJT05fVkVSVElDQUwsXG4gICAgRElSRUNUSU9OX0FMTDogRElSRUNUSU9OX0FMTCxcblxuICAgIE1hbmFnZXI6IE1hbmFnZXIsXG4gICAgSW5wdXQ6IElucHV0LFxuICAgIFRvdWNoQWN0aW9uOiBUb3VjaEFjdGlvbixcblxuICAgIFRvdWNoSW5wdXQ6IFRvdWNoSW5wdXQsXG4gICAgTW91c2VJbnB1dDogTW91c2VJbnB1dCxcbiAgICBQb2ludGVyRXZlbnRJbnB1dDogUG9pbnRlckV2ZW50SW5wdXQsXG4gICAgVG91Y2hNb3VzZUlucHV0OiBUb3VjaE1vdXNlSW5wdXQsXG4gICAgU2luZ2xlVG91Y2hJbnB1dDogU2luZ2xlVG91Y2hJbnB1dCxcblxuICAgIFJlY29nbml6ZXI6IFJlY29nbml6ZXIsXG4gICAgQXR0clJlY29nbml6ZXI6IEF0dHJSZWNvZ25pemVyLFxuICAgIFRhcDogVGFwUmVjb2duaXplcixcbiAgICBQYW46IFBhblJlY29nbml6ZXIsXG4gICAgU3dpcGU6IFN3aXBlUmVjb2duaXplcixcbiAgICBQaW5jaDogUGluY2hSZWNvZ25pemVyLFxuICAgIFJvdGF0ZTogUm90YXRlUmVjb2duaXplcixcbiAgICBQcmVzczogUHJlc3NSZWNvZ25pemVyLFxuXG4gICAgb246IGFkZEV2ZW50TGlzdGVuZXJzLFxuICAgIG9mZjogcmVtb3ZlRXZlbnRMaXN0ZW5lcnMsXG4gICAgZWFjaDogZWFjaCxcbiAgICBtZXJnZTogbWVyZ2UsXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgYXNzaWduOiBhc3NpZ24sXG4gICAgaW5oZXJpdDogaW5oZXJpdCxcbiAgICBiaW5kRm46IGJpbmRGbixcbiAgICBwcmVmaXhlZDogcHJlZml4ZWRcbn0pO1xuXG4vLyB0aGlzIHByZXZlbnRzIGVycm9ycyB3aGVuIEhhbW1lciBpcyBsb2FkZWQgaW4gdGhlIHByZXNlbmNlIG9mIGFuIEFNRFxuLy8gIHN0eWxlIGxvYWRlciBidXQgYnkgc2NyaXB0IHRhZywgbm90IGJ5IHRoZSBsb2FkZXIuXG52YXIgZnJlZUdsb2JhbCA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6ICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge30pKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5mcmVlR2xvYmFsLkhhbW1lciA9IEhhbW1lcjtcblxuaWYgKHRydWUpIHtcbiAgICAhKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gSGFtbWVyO1xuICAgIH0pLmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xufSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBIYW1tZXI7XG59IGVsc2Uge1xuICAgIHdpbmRvd1tleHBvcnROYW1lXSA9IEhhbW1lcjtcbn1cblxufSkod2luZG93LCBkb2N1bWVudCwgJ0hhbW1lcicpO1xuXG5cbi8qKiovIH0pLFxuLyogMTI5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8vIEVuZ2xpc2hcbmV4cG9ydHNbJ2VuJ10gPSB7XG4gIGVkaXQ6ICdFZGl0JyxcbiAgZGVsOiAnRGVsZXRlIHNlbGVjdGVkJyxcbiAgYmFjazogJ0JhY2snLFxuICBhZGROb2RlOiAnQWRkIE5vZGUnLFxuICBhZGRFZGdlOiAnQWRkIEVkZ2UnLFxuICBlZGl0Tm9kZTogJ0VkaXQgTm9kZScsXG4gIGVkaXRFZGdlOiAnRWRpdCBFZGdlJyxcbiAgYWRkRGVzY3JpcHRpb246ICdDbGljayBpbiBhbiBlbXB0eSBzcGFjZSB0byBwbGFjZSBhIG5ldyBub2RlLicsXG4gIGVkZ2VEZXNjcmlwdGlvbjogJ0NsaWNrIG9uIGEgbm9kZSBhbmQgZHJhZyB0aGUgZWRnZSB0byBhbm90aGVyIG5vZGUgdG8gY29ubmVjdCB0aGVtLicsXG4gIGVkaXRFZGdlRGVzY3JpcHRpb246ICdDbGljayBvbiB0aGUgY29udHJvbCBwb2ludHMgYW5kIGRyYWcgdGhlbSB0byBhIG5vZGUgdG8gY29ubmVjdCB0byBpdC4nLFxuICBjcmVhdGVFZGdlRXJyb3I6ICdDYW5ub3QgbGluayBlZGdlcyB0byBhIGNsdXN0ZXIuJyxcbiAgZGVsZXRlQ2x1c3RlckVycm9yOiAnQ2x1c3RlcnMgY2Fubm90IGJlIGRlbGV0ZWQuJyxcbiAgZWRpdENsdXN0ZXJFcnJvcjogJ0NsdXN0ZXJzIGNhbm5vdCBiZSBlZGl0ZWQuJ1xufTtcbmV4cG9ydHNbJ2VuX0VOJ10gPSBleHBvcnRzWydlbiddO1xuZXhwb3J0c1snZW5fVVMnXSA9IGV4cG9ydHNbJ2VuJ107XG5cbi8vIEdlcm1hblxuZXhwb3J0c1snZGUnXSA9IHtcbiAgZWRpdDogJ0VkaXRpZXJlbicsXG4gIGRlbDogJ0xcXHhGNnNjaGUgQXVzd2FobCcsXG4gIGJhY2s6ICdadXJcXHhGQ2NrJyxcbiAgYWRkTm9kZTogJ0tub3RlbiBoaW56dWZcXHhGQ2dlbicsXG4gIGFkZEVkZ2U6ICdLYW50ZSBoaW56dWZcXHhGQ2dlbicsXG4gIGVkaXROb2RlOiAnS25vdGVuIGVkaXRpZXJlbicsXG4gIGVkaXRFZGdlOiAnS2FudGUgZWRpdGllcmVuJyxcbiAgYWRkRGVzY3JpcHRpb246ICdLbGlja2UgYXVmIGVpbmUgZnJlaWUgU3RlbGxlLCB1bSBlaW5lbiBuZXVlbiBLbm90ZW4genUgcGxhemllcmVuLicsXG4gIGVkZ2VEZXNjcmlwdGlvbjogJ0tsaWNrZSBhdWYgZWluZW4gS25vdGVuIHVuZCB6aWVoZSBkaWUgS2FudGUgenUgZWluZW0gYW5kZXJlbiBLbm90ZW4sIHVtIGRpZXNlIHp1IHZlcmJpbmRlbi4nLFxuICBlZGl0RWRnZURlc2NyaXB0aW9uOiAnS2xpY2tlIGF1ZiBkaWUgVmVyYmluZHVuZ3NwdW5rdGUgdW5kIHppZWhlIGRpZXNlIGF1ZiBlaW5lbiBLbm90ZW4sIHVtIHNpZSB6dSB2ZXJiaW5kZW4uJyxcbiAgY3JlYXRlRWRnZUVycm9yOiAnRXMgaXN0IG5pY2h0IG1cXHhGNmdsaWNoLCBLYW50ZW4gbWl0IENsdXN0ZXJuIHp1IHZlcmJpbmRlbi4nLFxuICBkZWxldGVDbHVzdGVyRXJyb3I6ICdDbHVzdGVyIGtcXHhGNm5uZW4gbmljaHQgZ2VsXFx4RjZzY2h0IHdlcmRlbi4nLFxuICBlZGl0Q2x1c3RlckVycm9yOiAnQ2x1c3RlciBrXFx4RjZubmVuIG5pY2h0IGVkaXRpZXJ0IHdlcmRlbi4nXG59O1xuZXhwb3J0c1snZGVfREUnXSA9IGV4cG9ydHNbJ2RlJ107XG5cbi8vIFNwYW5pc2hcbmV4cG9ydHNbJ2VzJ10gPSB7XG4gIGVkaXQ6ICdFZGl0YXInLFxuICBkZWw6ICdFbGltaW5hciBzZWxlY2NpXFx4RjNuJyxcbiAgYmFjazogJ1xceEMxdHJhcycsXG4gIGFkZE5vZGU6ICdBXFx4RjFhZGlyIG5vZG8nLFxuICBhZGRFZGdlOiAnQVxceEYxYWRpciBhcmlzdGEnLFxuICBlZGl0Tm9kZTogJ0VkaXRhciBub2RvJyxcbiAgZWRpdEVkZ2U6ICdFZGl0YXIgYXJpc3RhJyxcbiAgYWRkRGVzY3JpcHRpb246ICdIYWdhIGNsaWMgZW4gdW4gbHVnYXIgdmFjXFx4RURvIHBhcmEgY29sb2NhciB1biBudWV2byBub2RvLicsXG4gIGVkZ2VEZXNjcmlwdGlvbjogJ0hhZ2EgY2xpYyBlbiB1biBub2RvIHkgYXJyYXN0cmUgbGEgYXJpc3RhIGhhY2lhIG90cm8gbm9kbyBwYXJhIGNvbmVjdGFybG9zLicsXG4gIGVkaXRFZGdlRGVzY3JpcHRpb246ICdIYWdhIGNsaWMgZW4gdW4gcHVudG8gZGUgY29udHJvbCB5IGFycmFzdHJlbG8gYSB1biBub2RvIHBhcmEgY29uZWN0YXJsby4nLFxuICBjcmVhdGVFZGdlRXJyb3I6ICdObyBzZSBwdWVkZSBjb25lY3RhciB1bmEgYXJpc3RhIGEgdW4gZ3J1cG8uJyxcbiAgZGVsZXRlQ2x1c3RlckVycm9yOiAnTm8gZXMgcG9zaWJsZSBlbGltaW5hciBncnVwb3MuJyxcbiAgZWRpdENsdXN0ZXJFcnJvcjogJ05vIGVzIHBvc2libGUgZWRpdGFyIGdydXBvcy4nXG59O1xuZXhwb3J0c1snZXNfRVMnXSA9IGV4cG9ydHNbJ2VzJ107XG5cbi8vSXRhbGlhbm9cbmV4cG9ydHNbJ2l0J10gPSB7XG4gIGVkaXQ6ICdNb2RpZmljYScsXG4gIGRlbDogJ0NhbmNlbGxhIGxhIHNlbGV6aW9uZScsXG4gIGJhY2s6ICdJbmRpZXRybycsXG4gIGFkZE5vZGU6ICdBZ2dpdW5naSB1biBub2RvJyxcbiAgYWRkRWRnZTogJ0FnZ2l1bmdpIHVuIHZlcnRpY2UnLFxuICBlZGl0Tm9kZTogJ01vZGlmaWNhIGlsIG5vZG8nLFxuICBlZGl0RWRnZTogJ01vZGlmaWNhIGlsIHZlcnRpY2UnLFxuICBhZGREZXNjcmlwdGlvbjogJ0NsaWNjYSBwZXIgYWdnaXVuZ2VyZSB1biBudW92byBub2RvJyxcbiAgZWRnZURlc2NyaXB0aW9uOiAnQ2xpY2NhIHN1IHVuIG5vZG8gZSB0cmFzY2luYWxvIGFkIHVuIGFsdHJvIG5vZG8gcGVyIGNvbm5ldHRlcmxpLicsXG4gIGVkaXRFZGdlRGVzY3JpcHRpb246ICdDbGljY2Egc3VpIFB1bnRpIGRpIGNvbnRyb2xsbyBlIHRyYXNjaW5hbGkgYWQgdW4gbm9kbyBwZXIgY29ubmV0dGVybGkuJyxcbiAgY3JlYXRlRWRnZUVycm9yOiAnTm9uIHNpIHBvc3Nvbm8gY29sbGVnYXJlIHZlcnRpY2kgYWQgdW4gY2x1c3RlcicsXG4gIGRlbGV0ZUNsdXN0ZXJFcnJvcjogJ0kgY2x1c3RlciBub24gcG9zc29ubyBlc3NlcmUgY2FuY2VsbGF0aScsXG4gIGVkaXRDbHVzdGVyRXJyb3I6ICdJIGNsdXN0ZXJzIG5vbiBwb3Nzb25vIGVzc2VyZSBtb2RpZmljYXRpLidcbn07XG5leHBvcnRzWydpdF9JVCddID0gZXhwb3J0c1snaXQnXTtcblxuLy8gRHV0Y2hcbmV4cG9ydHNbJ25sJ10gPSB7XG4gIGVkaXQ6ICdXaWp6aWdlbicsXG4gIGRlbDogJ1NlbGVjdGllIHZlcndpamRlcmVuJyxcbiAgYmFjazogJ1RlcnVnJyxcbiAgYWRkTm9kZTogJ05vZGUgdG9ldm9lZ2VuJyxcbiAgYWRkRWRnZTogJ0xpbmsgdG9ldm9lZ2VuJyxcbiAgZWRpdE5vZGU6ICdOb2RlIHdpanppZ2VuJyxcbiAgZWRpdEVkZ2U6ICdMaW5rIHdpanppZ2VuJyxcbiAgYWRkRGVzY3JpcHRpb246ICdLbGlrIG9wIGVlbiBsZWVnIGdlYmllZCBvbSBlZW4gbmlldXdlIG5vZGUgdGUgbWFrZW4uJyxcbiAgZWRnZURlc2NyaXB0aW9uOiAnS2xpayBvcCBlZW4gbm9kZSBlbiBzbGVlcCBkZSBsaW5rIG5hYXIgZWVuIGFuZGVyZSBub2RlIG9tIHplIHRlIHZlcmJpbmRlbi4nLFxuICBlZGl0RWRnZURlc2NyaXB0aW9uOiAnS2xpayBvcCBkZSB2ZXJiaW5kaW5nc3B1bnRlbiBlbiBzbGVlcCB6ZSBuYWFyIGVlbiBub2RlIG9tIGRhYXJtZWUgdGUgdmVyYmluZGVuLicsXG4gIGNyZWF0ZUVkZ2VFcnJvcjogJ0thbiBnZWVuIGxpbmsgbWFrZW4gbmFhciBlZW4gY2x1c3Rlci4nLFxuICBkZWxldGVDbHVzdGVyRXJyb3I6ICdDbHVzdGVycyBrdW5uZW4gbmlldCB3b3JkZW4gdmVyd2lqZGVyZC4nLFxuICBlZGl0Q2x1c3RlckVycm9yOiAnQ2x1c3RlcnMga3VubmVuIG5pZXQgd29yZGVuIGFhbmdlcGFzdC4nXG59O1xuZXhwb3J0c1snbmxfTkwnXSA9IGV4cG9ydHNbJ25sJ107XG5leHBvcnRzWydubF9CRSddID0gZXhwb3J0c1snbmwnXTtcblxuLy8gUG9ydHVndWVzZSBCcmF6aWxcbmV4cG9ydHNbJ3B0LWJyJ10gPSB7XG4gIGVkaXQ6ICdFZGl0YXInLFxuICBkZWw6ICdSZW1vdmVyIHNlbGVjaW9uYWRvJyxcbiAgYmFjazogJ1ZvbHRhcicsXG4gIGFkZE5vZGU6ICdBZGljaW9uYXIgbsOzJyxcbiAgYWRkRWRnZTogJ0FkaWNpb25hciBhcmVzdGEnLFxuICBlZGl0Tm9kZTogJ0VkaXRhciBuw7MnLFxuICBlZGl0RWRnZTogJ0VkaXRhciBhcmVzdGEnLFxuICBhZGREZXNjcmlwdGlvbjogJ0NsaXF1ZSBlbSB1bSBlc3Bhw6dvIGVtIGJyYW5jbyBwYXJhIGFkaWNpb25hciB1bSBub3ZvIG7DsycsXG4gIGVkZ2VEZXNjcmlwdGlvbjogJ0NsaXF1ZSBlbSB1bSBuw7MgZSBhcnJhc3RlIGEgYXJlc3RhIGF0w6kgb3V0cm8gbsOzIHBhcmEgY29uZWN0w6EtbG9zJyxcbiAgZWRpdEVkZ2VEZXNjcmlwdGlvbjogJ0NsaXF1ZSBub3MgcG9udG9zIGRlIGNvbnRyb2xlIGUgb3MgYXJyYXN0ZSBwYXJhIHVtIG7DsyBwYXJhIGNvbmVjdMOhLWxvcycsXG4gIGNyZWF0ZUVkZ2VFcnJvcjogJ07Do28gZm9pIHBvc3PDrXZlbCBsaW5rYXIgYXJlc3RhcyBhIHVtIGNsdXN0ZXIuJyxcbiAgZGVsZXRlQ2x1c3RlckVycm9yOiAnQ2x1c3RlcnMgbsOjbyBwdWRlcmFtIHNlciByZW1vdmlkb3MuJyxcbiAgZWRpdENsdXN0ZXJFcnJvcjogJ0NsdXN0ZXJzIG7Do28gcHVkZXJhbSBzZXIgZWRpdGFkb3MuJ1xufTtcbmV4cG9ydHNbJ3B0LUJSJ10gPSBleHBvcnRzWydwdC1iciddO1xuZXhwb3J0c1sncHRfQlInXSA9IGV4cG9ydHNbJ3B0LWJyJ107XG5leHBvcnRzWydwdF9iciddID0gZXhwb3J0c1sncHQtYnInXTtcblxuLy8gUnVzc2lhblxuZXhwb3J0c1sncnUnXSA9IHtcbiAgZWRpdDogJ9Cg0LXQtNCw0LrRgtC40YDQvtCy0LDRgtGMJyxcbiAgZGVsOiAn0KPQtNCw0LvQuNGC0Ywg0LLRi9Cx0YDQsNC90L3QvtC1JyxcbiAgYmFjazogJ9Cd0LDQt9Cw0LQnLFxuICBhZGROb2RlOiAn0JTQvtCx0LDQstC40YLRjCDRg9C30LXQuycsXG4gIGFkZEVkZ2U6ICfQlNC+0LHQsNCy0LjRgtGMINGA0LXQsdGA0L4nLFxuICBlZGl0Tm9kZTogJ9Cg0LXQtNCw0LrRgtC40YDQvtCy0LDRgtGMINGD0LfQtdC7JyxcbiAgZWRpdEVkZ2U6ICfQoNC10LTQsNC60YLQuNGA0L7QstCw0YLRjCDRgNC10LHRgNC+JyxcbiAgYWRkRGVzY3JpcHRpb246ICfQmtC70LjQutC90LjRgtC1INCyINGB0LLQvtCx0L7QtNC90L7QtSDQvNC10YHRgtC+LCDRh9GC0L7QsdGLINC00L7QsdCw0LLQuNGC0Ywg0L3QvtCy0YvQuSDRg9C30LXQuy4nLFxuICBlZGdlRGVzY3JpcHRpb246ICfQmtC70LjQutC90LjRgtC1INC90LAg0YPQt9C10Lsg0Lgg0L/RgNC+0YLRj9C90LjRgtC1INGA0LXQsdGA0L4g0Log0LTRgNGD0LPQvtC80YMg0YPQt9C70YMsINGH0YLQvtCx0Ysg0YHQvtC10LTQuNC90LjRgtGMINC40YUuJyxcbiAgZWRpdEVkZ2VEZXNjcmlwdGlvbjogJ9Ca0LvQuNC60L3QuNGC0LUg0L3QsCDQutC+0L3RgtGA0L7Qu9GM0L3Ri9C1INGC0L7Rh9C60Lgg0Lgg0L/QtdGA0LXRgtCw0YnQuNGC0LUg0LjRhSDQsiDRg9C30LXQuywg0YfRgtC+0LHRiyDQv9C+0LTQutC70Y7Rh9C40YLRjNGB0Y8g0Log0L3QtdC80YMuJyxcbiAgY3JlYXRlRWRnZUVycm9yOiAn0J3QtdCy0L7Qt9C80L7QttC90L4g0YHQvtC10LTQuNC90LjRgtGMINGA0LXQsdGA0LAg0LIg0LrQu9Cw0YHRgtC10YAuJyxcbiAgZGVsZXRlQ2x1c3RlckVycm9yOiAn0JrQu9Cw0YHRgtC10YDRiyDQvdC1INC80L7Qs9GD0YIg0LHRi9GC0Ywg0YPQtNCw0LvQtdC90YsnLFxuICBlZGl0Q2x1c3RlckVycm9yOiAn0JrQu9Cw0YHRgtC10YDRiyDQvdC10LTQvtGB0YLRg9C/0L3RiyDQtNC70Y8g0YDQtdC00LDQutGC0LjRgNC+0LLQsNC90LjRjy4nXG59O1xuZXhwb3J0c1sncnVfUlUnXSA9IGV4cG9ydHNbJ3J1J107XG5cbi8vIENoaW5lc2VcbmV4cG9ydHNbJ2NuJ10gPSB7XG4gIGVkaXQ6ICfnvJbovpEnLFxuICBkZWw6ICfliKDpmaTpgInlrponLFxuICBiYWNrOiAn6L+U5ZueJyxcbiAgYWRkTm9kZTogJ+a3u+WKoOiKgueCuScsXG4gIGFkZEVkZ2U6ICfmt7vliqDov57mjqXnur8nLFxuICBlZGl0Tm9kZTogJ+e8lui+keiKgueCuScsXG4gIGVkaXRFZGdlOiAn57yW6L6R6L+e5o6l57q/JyxcbiAgYWRkRGVzY3JpcHRpb246ICfljZXlh7vnqbrnmb3lpITmlL7nva7mlrDoioLngrnjgIInLFxuICBlZGdlRGVzY3JpcHRpb246ICfljZXlh7vmn5DkuKroioLngrnlubblsIbor6Xov57mjqXnur/mi5bliqjliLDlj6bkuIDkuKroioLngrnku6Xov57mjqXlroPku6zjgIInLFxuICBlZGl0RWRnZURlc2NyaXB0aW9uOiAn5Y2V5Ye75o6n5Yi26IqC54K55bm25bCG5a6D5Lus5ouW5Yiw6IqC54K55LiK6L+e5o6l44CCJyxcbiAgY3JlYXRlRWRnZUVycm9yOiAn5peg5rOV5bCG6L+e5o6l57q/6L+e5o6l5Yiw576k6ZuG44CCJyxcbiAgZGVsZXRlQ2x1c3RlckVycm9yOiAn5peg5rOV5Yig6Zmk576k6ZuG44CCJyxcbiAgZWRpdENsdXN0ZXJFcnJvcjogJ+aXoOazlee8lui+kee+pOmbhuOAgidcbn07XG5leHBvcnRzWyd6aF9DTiddID0gZXhwb3J0c1snY24nXTtcblxuLy8gVWtyYWluaWFuXG5leHBvcnRzWyd1ayddID0ge1xuICBlZGl0OiAn0KDQtdC00LDQs9GD0LLQsNGC0LgnLFxuICBkZWw6ICfQktC40LTQsNC70LjRgtC4INC+0LHRgNCw0L3QtScsXG4gIGJhY2s6ICfQndCw0LfQsNC0JyxcbiAgYWRkTm9kZTogJ9CU0L7QtNCw0YLQuCDQstGD0LfQvtC7JyxcbiAgYWRkRWRnZTogJ9CU0L7QtNCw0YLQuCDQutGA0LDQuScsXG4gIGVkaXROb2RlOiAn0KDQtdC00LDQs9GD0LLQsNGC0Lgg0LLRg9C30L7QuycsXG4gIGVkaXRFZGdlOiAn0KDQtdC00LDQs9GD0LLQsNGC0Lgg0LrRgNCw0LknLFxuICBhZGREZXNjcmlwdGlvbjogJ0vQu9GW0LrQvdGW0YLRjCDQvdCwINCy0ZbQu9GM0L3QtSDQvNGW0YHRhtC1LCDRidC+0LEg0LTQvtC00LDRgtC4INC90L7QstC40Lkg0LLRg9C30L7Quy4nLFxuICBlZGdlRGVzY3JpcHRpb246IFwi0JrQu9GW0LrQvdGW0YLRjCDQvdCwINCy0YPQt9C+0Lsg0ZYg0L/QtdGA0LXRgtGP0LPQvdGW0YLRjCDQutGA0LDQuSDQtNC+INGW0L3RiNC+0LPQviDQstGD0LfQu9CwLCDRidC+0LEg0ZfRhSDQtyfRlNC00L3QsNGC0LguXCIsXG4gIGVkaXRFZGdlRGVzY3JpcHRpb246ICfQmtC70ZbQutC90ZbRgtGMINC90LAg0LrQvtC90YLRgNC+0LvRjNC90ZYg0YLQvtGH0LrQuCDRliDQv9C10YDQtdGC0Y/Qs9C90ZbRgtGMINGX0YUg0YMg0LLRg9C30L7Quywg0YnQvtCxINC/0ZbQtNC60LvRjtGH0LjRgtC40YHRjyDQtNC+INC90YzQvtCz0L4uJyxcbiAgY3JlYXRlRWRnZUVycm9yOiBcItCd0LUg0LzQvtC20LvQuNCy0L4g0L7QsSfRlNC00L3QsNGC0Lgg0LrRgNCw0Zcg0LIg0LPRgNGD0L/Rgy5cIixcbiAgZGVsZXRlQ2x1c3RlckVycm9yOiAn0JPRgNGD0L/QuCDQvdC1INC80L7QttGD0YLRjCDQsdGD0YLQuCDQstC40LTQsNC70LXQvdGWLicsXG4gIGVkaXRDbHVzdGVyRXJyb3I6ICfQk9GA0YPQv9C4INC90LXQtNC+0YHRgtGD0L/QvdGWINC00LvRjyDRgNC10LTQsNCz0YPQstCw0L3QvdGPLidcbn07XG5leHBvcnRzWyd1a19VQSddID0gZXhwb3J0c1sndWsnXTtcblxuLy8gRnJlbmNoXG5leHBvcnRzWydmciddID0ge1xuICBlZGl0OiAnRWRpdGVyJyxcbiAgZGVsOiAnRWZmYWNlciBsYSBzZWxlY3Rpb24nLFxuICBiYWNrOiAnUmV0b3VyJyxcbiAgYWRkTm9kZTogJ0Fqb3V0ZXIgdW4gbm9ldWQnLFxuICBhZGRFZGdlOiAnQWpvdXRlciB1biBsaWVuJyxcbiAgZWRpdE5vZGU6ICdFZGl0ZXIgbGUgbm9ldWQnLFxuICBlZGl0RWRnZTogJ0VkaXRlciBsZSBsaWVuJyxcbiAgYWRkRGVzY3JpcHRpb246ICdDbGlxdWV6IGRhbnMgdW4gZW5kcm9pdCB2aWRlIHBvdXIgcGxhY2VyIHVuIG5vZXVkLicsXG4gIGVkZ2VEZXNjcmlwdGlvbjogJ0NsaXF1ZXogc3VyIHVuIG5vZXVkIGV0IGdsaXNzZXogbGUgbGllbiB2ZXJzIHVuIGF1dHJlIG5vZXVkIHBvdXIgbGVzIGNvbm5lY3Rlci4nLFxuICBlZGl0RWRnZURlc2NyaXB0aW9uOiAnQ2xpcXVleiBzdXIgbGVzIHBvaW50cyBkZSBjb250csO0bGUgZXQgZ2xpc3Nlei1sZXMgcG91ciBjb25uZWN0ZXIgdW4gbm9ldWQuJyxcbiAgY3JlYXRlRWRnZUVycm9yOiAnSW1wb3NzaWJsZSBkZSBjcsOpZXIgdW4gbGllbiB2ZXJzIHVuIGNsdXN0ZXIuJyxcbiAgZGVsZXRlQ2x1c3RlckVycm9yOiAnTGVzIGNsdXN0ZXJzIG5lIHBldXZlbnQgcGFzIMOqdHJlIMOpZmZhY8Opcy4nLFxuICBlZGl0Q2x1c3RlckVycm9yOiAnTGVzIGNsdXN0ZXJzIG5lIHBldXZlbnQgcGFzIMOqdHJlIMOpZGl0ZXMuJ1xufTtcbmV4cG9ydHNbJ2ZyX0ZSJ10gPSBleHBvcnRzWydmciddO1xuXG4vKioqLyB9KSxcbi8qIDEzMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IF9fd2VicGFja19yZXF1aXJlX18oMTMxKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG4vKioqLyB9KSxcbi8qIDEzMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEzMik7XG52YXIgJE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNikuT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKSB7XG4gIHJldHVybiAkT2JqZWN0LmRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2MpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDEzMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgJGV4cG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuLy8gMTkuMS4yLjQgLyAxNS4yLjMuNiBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIV9fd2VicGFja19yZXF1aXJlX18oMTMpLCAnT2JqZWN0JywgeyBkZWZpbmVQcm9wZXJ0eTogX193ZWJwYWNrX3JlcXVpcmVfXygxMikuZiB9KTtcblxuXG4vKioqLyB9KSxcbi8qIDEzMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLyoqXG4gKiBBc3NvY2lhdGVzIGEgY2FudmFzIHRvIGEgZ2l2ZW4gaW1hZ2UsIGNvbnRhaW5pbmcgYSBudW1iZXIgb2YgcmVuZGVyaW5nc1xuICogb2YgdGhlIGltYWdlIGF0IHZhcmlvdXMgc2l6ZXMuXG4gKlxuICogVGhpcyB0ZWNobmlxdWUgaXMga25vd24gYXMgJ21pcG1hcHBpbmcnLlxuICpcbiAqIE5PVEU6IEltYWdlcyBjYW4gYWxzbyBiZSBvZiB0eXBlICdkYXRhOnN2Zyt4bWxgLiBUaGlzIGNvZGUgYWxzbyB3b3Jrc1xuICogICAgICAgZm9yIHN2ZywgYnV0IHRoZSBtaXBtYXBwaW5nIG1heSBub3QgYmUgbmVjZXNzYXJ5LlxuICpcbiAqIEBwYXJhbSB7SW1hZ2V9IGltYWdlXG4gKi9cbnZhciBDYWNoZWRJbWFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGZ1bmN0aW9uIENhY2hlZEltYWdlKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIENhY2hlZEltYWdlKTtcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB0aGlzLk5VTV9JVEVSQVRJT05TID0gNDsgLy8gTnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBjb29yZGluYXRlcyBhcnJheVxuXG4gICAgdGhpcy5pbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIGltYWdlIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBsb2FkZWQuXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoQ2FjaGVkSW1hZ2UsIFt7XG4gICAga2V5OiAnaW5pdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICBpZiAodGhpcy5pbml0aWFsaXplZCgpKSByZXR1cm47XG5cbiAgICAgIHRoaXMuc3JjID0gdGhpcy5pbWFnZS5zcmM7IC8vIEZvciBzYW1lIGludGVyZmFjZSB3aXRoIEltYWdlXG4gICAgICB2YXIgdyA9IHRoaXMuaW1hZ2Uud2lkdGg7XG4gICAgICB2YXIgaCA9IHRoaXMuaW1hZ2UuaGVpZ2h0O1xuXG4gICAgICAvLyBFYXNlIGV4dGVybmFsIGFjY2Vzc1xuICAgICAgdGhpcy53aWR0aCA9IHc7XG4gICAgICB0aGlzLmhlaWdodCA9IGg7XG5cbiAgICAgIHZhciBoMiA9IE1hdGguZmxvb3IoaCAvIDIpO1xuICAgICAgdmFyIGg0ID0gTWF0aC5mbG9vcihoIC8gNCk7XG4gICAgICB2YXIgaDggPSBNYXRoLmZsb29yKGggLyA4KTtcbiAgICAgIHZhciBoMTYgPSBNYXRoLmZsb29yKGggLyAxNik7XG5cbiAgICAgIHZhciB3MiA9IE1hdGguZmxvb3IodyAvIDIpO1xuICAgICAgdmFyIHc0ID0gTWF0aC5mbG9vcih3IC8gNCk7XG4gICAgICB2YXIgdzggPSBNYXRoLmZsb29yKHcgLyA4KTtcbiAgICAgIHZhciB3MTYgPSBNYXRoLmZsb29yKHcgLyAxNik7XG5cbiAgICAgIC8vIE1ha2UgY2FudmFzIGFzIHNtYWxsIGFzIHBvc3NpYmxlXG4gICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IDMgKiB3NDtcbiAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IGgyO1xuXG4gICAgICAvLyBDb29yZGluYXRlcyBhbmQgc2l6ZXMgb2YgaW1hZ2VzIGNvbnRhaW5lZCBpbiB0aGUgY2FudmFzXG4gICAgICAvLyBWYWx1ZXMgcGVyIHJvdzogIFt0b3AgeCwgbGVmdCB5LCB3aWR0aCwgaGVpZ2h0XVxuXG4gICAgICB0aGlzLmNvb3JkaW5hdGVzID0gW1swLCAwLCB3MiwgaDJdLCBbdzIsIDAsIHc0LCBoNF0sIFt3MiwgaDQsIHc4LCBoOF0sIFs1ICogdzgsIGg0LCB3MTYsIGgxNl1dO1xuXG4gICAgICB0aGlzLl9maWxsTWlwTWFwKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBpbml0KCkgaGFzIGJlZW4gY2FsbGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2luaXRpYWxpemVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb29yZGluYXRlcyAhPT0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZHJhdyBtYWluIGltYWdlIGluIHZhcmlvdXMgc2l6ZXMgdG8gdGhlIGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBUaGUgcmF0aW9uYWxlIGJlaGluZCB0aGlzIGlzIHRvIHJlZHVjZSBhcnRlZmFjdHMgZHVlIHRvIGludGVycG9sYXRpb25cbiAgICAgKiBhdCBkaWZmZXJpbmcgem9vbSBsZXZlbHMuXG4gICAgICpcbiAgICAgKiBTb3VyY2U6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xLzE4NzYxNDA0LzEyMjM1MzFcbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kcyB0YWtlcyB0aGUgcmVzaXppbmcgb3V0IG9mIHRoZSBkcmF3aW5nIGxvb3AsIGluIG9yZGVyIHRvXG4gICAgICogcmVkdWNlIHBlcmZvcm1hbmNlIG92ZXJoZWFkLlxuICAgICAqXG4gICAgICogVE9ETzogVGhlIGNvZGUgYXNzdW1lcyB0aGF0IGEgMkQgY29udGV4dCBjYW4gYWx3YXlzIGJlIGdvdHRlbi4gVGhpcyBpc1xuICAgICAqICAgICAgIG5vdCBuZWNlc3NhcmlseSB0cnVlISBPVE9ILCBpZiBub3QgdHJ1ZSB0aGVuIHVzYWdlIG9mIHRoaXMgY2xhc3NcbiAgICAgKiAgICAgICBpcyBzZW5zZWxlc3MuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZmlsbE1pcE1hcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maWxsTWlwTWFwKCkge1xuICAgICAgdmFyIGN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgIC8vIEZpcnN0IHpvb20tbGV2ZWwgY29tZXMgZnJvbSB0aGUgaW1hZ2VcbiAgICAgIHZhciB0byA9IHRoaXMuY29vcmRpbmF0ZXNbMF07XG4gICAgICBjdHguZHJhd0ltYWdlKHRoaXMuaW1hZ2UsIHRvWzBdLCB0b1sxXSwgdG9bMl0sIHRvWzNdKTtcblxuICAgICAgLy8gVGhlIHJlc3QgYXJlIGNvcHkgYWN0aW9ucyBpbnRlcm5hbCB0byB0aGUgY2FudmFzL2NvbnRleHRcbiAgICAgIGZvciAodmFyIGl0ZXJhdGlvbnMgPSAxOyBpdGVyYXRpb25zIDwgdGhpcy5OVU1fSVRFUkFUSU9OUzsgaXRlcmF0aW9ucysrKSB7XG4gICAgICAgIHZhciBmcm9tID0gdGhpcy5jb29yZGluYXRlc1tpdGVyYXRpb25zIC0gMV07XG4gICAgICAgIHZhciBfdG8gPSB0aGlzLmNvb3JkaW5hdGVzW2l0ZXJhdGlvbnNdO1xuXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5jYW52YXMsIGZyb21bMF0sIGZyb21bMV0sIGZyb21bMl0sIGZyb21bM10sIF90b1swXSwgX3RvWzFdLCBfdG9bMl0sIF90b1szXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhdyB0aGUgaW1hZ2UsIHVzaW5nIHRoZSBtaXBtYXAgaWYgbmVjZXNzYXJ5LlxuICAgICAqXG4gICAgICogTWlwTWFwIGlzIG9ubHkgdXNlZCBpZiBwYXJhbSBmYWN0b3IgPiAyOyBvdGhlcndpc2UsIG9yaWdpbmFsIGJpdG1hcFxuICAgICAqIGlzIHJlc2l6ZWQuIFRoaXMgaXMgYWxzbyB1c2VkIHRvIHNraXAgbWlwbWFwIHVzYWdlLCBlLmcuIGJ5IHNldHRpbmcgZmFjdG9yID0gMVxuICAgICAqXG4gICAgICogQ3JlZGl0cyB0byAnQWxleCBkZSBNdWxkZXInIGZvciBvcmlnaW5hbCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggIGNvbnRleHQgb24gd2hpY2ggdG8gZHJhdyB6b29tZWQgaW1hZ2VcbiAgICAgKiBAcGFyYW0ge0Zsb2F0fSBmYWN0b3Igc2NhbGUgZmFjdG9yIGF0IHdoaWNoIHRvIGRyYXdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVmdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b3BcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RyYXdJbWFnZUF0UG9zaXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3SW1hZ2VBdFBvc2l0aW9uKGN0eCwgZmFjdG9yLCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIGlmICghdGhpcy5pbml0aWFsaXplZCgpKSByZXR1cm47IC8vY2FuJ3QgZHJhdyBpbWFnZSB5ZXQgbm90IGludGlhbGl6ZWRcblxuICAgICAgaWYgKGZhY3RvciA+IDIpIHtcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIHpvb21lZCBpbWFnZSB0byB1c2VcbiAgICAgICAgZmFjdG9yICo9IDAuNTtcbiAgICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgICB3aGlsZSAoZmFjdG9yID4gMiAmJiBpdGVyYXRpb25zIDwgdGhpcy5OVU1fSVRFUkFUSU9OUykge1xuICAgICAgICAgIGZhY3RvciAqPSAwLjU7XG4gICAgICAgICAgaXRlcmF0aW9ucyArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGl0ZXJhdGlvbnMgPj0gdGhpcy5OVU1fSVRFUkFUSU9OUykge1xuICAgICAgICAgIGl0ZXJhdGlvbnMgPSB0aGlzLk5VTV9JVEVSQVRJT05TIC0gMTtcbiAgICAgICAgfVxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiaXRlcmF0aW9uczogXCIgKyBpdGVyYXRpb25zKTtcblxuICAgICAgICB2YXIgZnJvbSA9IHRoaXMuY29vcmRpbmF0ZXNbaXRlcmF0aW9uc107XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5jYW52YXMsIGZyb21bMF0sIGZyb21bMV0sIGZyb21bMl0sIGZyb21bM10sIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBEcmF3IGltYWdlIGRpcmVjdGx5XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5pbWFnZSwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENhY2hlZEltYWdlO1xufSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBDYWNoZWRJbWFnZTtcblxuLyoqKi8gfSksXG4vKiAxMzQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxuLyoqXG4gKiBUaGlzIGNsYXNzIGNhbiBzdG9yZSBncm91cHMgYW5kIG9wdGlvbnMgc3BlY2lmaWMgZm9yIGdyb3Vwcy5cbiAqL1xuXG52YXIgR3JvdXBzID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgZnVuY3Rpb24gR3JvdXBzKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIEdyb3Vwcyk7XG5cbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgdGhpcy5kZWZhdWx0SW5kZXggPSAwO1xuICAgIHRoaXMuZ3JvdXBzQXJyYXkgPSBbXTtcbiAgICB0aGlzLmdyb3VwSW5kZXggPSAwO1xuXG4gICAgdGhpcy5kZWZhdWx0R3JvdXBzID0gW3tcbiAgICAgIGJvcmRlcjogJyMyQjdDRTknLFxuICAgICAgYmFja2dyb3VuZDogJyM5N0MyRkMnLFxuICAgICAgaGlnaGxpZ2h0OiB7IGJvcmRlcjogJyMyQjdDRTknLCBiYWNrZ3JvdW5kOiAnI0QyRTVGRicgfSxcbiAgICAgIGhvdmVyOiB7IGJvcmRlcjogJyMyQjdDRTknLCBiYWNrZ3JvdW5kOiAnI0QyRTVGRicgfVxuICAgIH0sIC8vIDA6IGJsdWVcbiAgICB7XG4gICAgICBib3JkZXI6ICcjRkZBNTAwJyxcbiAgICAgIGJhY2tncm91bmQ6ICcjRkZGRjAwJyxcbiAgICAgIGhpZ2hsaWdodDogeyBib3JkZXI6ICcjRkZBNTAwJywgYmFja2dyb3VuZDogJyNGRkZGQTMnIH0sXG4gICAgICBob3ZlcjogeyBib3JkZXI6ICcjRkZBNTAwJywgYmFja2dyb3VuZDogJyNGRkZGQTMnIH1cbiAgICB9LCAvLyAxOiB5ZWxsb3dcbiAgICB7XG4gICAgICBib3JkZXI6ICcjRkEwQTEwJyxcbiAgICAgIGJhY2tncm91bmQ6ICcjRkI3RTgxJyxcbiAgICAgIGhpZ2hsaWdodDogeyBib3JkZXI6ICcjRkEwQTEwJywgYmFja2dyb3VuZDogJyNGRkFGQjEnIH0sXG4gICAgICBob3ZlcjogeyBib3JkZXI6ICcjRkEwQTEwJywgYmFja2dyb3VuZDogJyNGRkFGQjEnIH1cbiAgICB9LCAvLyAyOiByZWRcbiAgICB7XG4gICAgICBib3JkZXI6ICcjNDFBOTA2JyxcbiAgICAgIGJhY2tncm91bmQ6ICcjN0JFMTQxJyxcbiAgICAgIGhpZ2hsaWdodDogeyBib3JkZXI6ICcjNDFBOTA2JywgYmFja2dyb3VuZDogJyNBMUVDNzYnIH0sXG4gICAgICBob3ZlcjogeyBib3JkZXI6ICcjNDFBOTA2JywgYmFja2dyb3VuZDogJyNBMUVDNzYnIH1cbiAgICB9LCAvLyAzOiBncmVlblxuICAgIHtcbiAgICAgIGJvcmRlcjogJyNFMTI5RjAnLFxuICAgICAgYmFja2dyb3VuZDogJyNFQjdERjQnLFxuICAgICAgaGlnaGxpZ2h0OiB7IGJvcmRlcjogJyNFMTI5RjAnLCBiYWNrZ3JvdW5kOiAnI0YwQjNGNScgfSxcbiAgICAgIGhvdmVyOiB7IGJvcmRlcjogJyNFMTI5RjAnLCBiYWNrZ3JvdW5kOiAnI0YwQjNGNScgfVxuICAgIH0sIC8vIDQ6IG1hZ2VudGFcbiAgICB7XG4gICAgICBib3JkZXI6ICcjN0MyOUYwJyxcbiAgICAgIGJhY2tncm91bmQ6ICcjQUQ4NUU0JyxcbiAgICAgIGhpZ2hsaWdodDogeyBib3JkZXI6ICcjN0MyOUYwJywgYmFja2dyb3VuZDogJyNEM0JERjAnIH0sXG4gICAgICBob3ZlcjogeyBib3JkZXI6ICcjN0MyOUYwJywgYmFja2dyb3VuZDogJyNEM0JERjAnIH1cbiAgICB9LCAvLyA1OiBwdXJwbGVcbiAgICB7XG4gICAgICBib3JkZXI6ICcjQzM3RjAwJyxcbiAgICAgIGJhY2tncm91bmQ6ICcjRkZBODA3JyxcbiAgICAgIGhpZ2hsaWdodDogeyBib3JkZXI6ICcjQzM3RjAwJywgYmFja2dyb3VuZDogJyNGRkNBNjYnIH0sXG4gICAgICBob3ZlcjogeyBib3JkZXI6ICcjQzM3RjAwJywgYmFja2dyb3VuZDogJyNGRkNBNjYnIH1cbiAgICB9LCAvLyA2OiBvcmFuZ2VcbiAgICB7XG4gICAgICBib3JkZXI6ICcjNDIyMEZCJyxcbiAgICAgIGJhY2tncm91bmQ6ICcjNkU2RUZEJyxcbiAgICAgIGhpZ2hsaWdodDogeyBib3JkZXI6ICcjNDIyMEZCJywgYmFja2dyb3VuZDogJyM5QjlCRkQnIH0sXG4gICAgICBob3ZlcjogeyBib3JkZXI6ICcjNDIyMEZCJywgYmFja2dyb3VuZDogJyM5QjlCRkQnIH1cbiAgICB9LCAvLyA3OiBkYXJrYmx1ZVxuICAgIHtcbiAgICAgIGJvcmRlcjogJyNGRDVBNzcnLFxuICAgICAgYmFja2dyb3VuZDogJyNGRkMwQ0InLFxuICAgICAgaGlnaGxpZ2h0OiB7IGJvcmRlcjogJyNGRDVBNzcnLCBiYWNrZ3JvdW5kOiAnI0ZGRDFEOScgfSxcbiAgICAgIGhvdmVyOiB7IGJvcmRlcjogJyNGRDVBNzcnLCBiYWNrZ3JvdW5kOiAnI0ZGRDFEOScgfVxuICAgIH0sIC8vIDg6IHBpbmtcbiAgICB7XG4gICAgICBib3JkZXI6ICcjNEFENjNBJyxcbiAgICAgIGJhY2tncm91bmQ6ICcjQzJGQUJDJyxcbiAgICAgIGhpZ2hsaWdodDogeyBib3JkZXI6ICcjNEFENjNBJywgYmFja2dyb3VuZDogJyNFNkZGRTMnIH0sXG4gICAgICBob3ZlcjogeyBib3JkZXI6ICcjNEFENjNBJywgYmFja2dyb3VuZDogJyNFNkZGRTMnIH1cbiAgICB9LCAvLyA5OiBtaW50XG5cbiAgICB7XG4gICAgICBib3JkZXI6ICcjOTkwMDAwJyxcbiAgICAgIGJhY2tncm91bmQ6ICcjRUUwMDAwJyxcbiAgICAgIGhpZ2hsaWdodDogeyBib3JkZXI6ICcjQkIwMDAwJywgYmFja2dyb3VuZDogJyNGRjMzMzMnIH0sXG4gICAgICBob3ZlcjogeyBib3JkZXI6ICcjQkIwMDAwJywgYmFja2dyb3VuZDogJyNGRjMzMzMnIH1cbiAgICB9LCAvLyAxMDpicmlnaHQgcmVkXG5cbiAgICB7XG4gICAgICBib3JkZXI6ICcjRkY2MDAwJyxcbiAgICAgIGJhY2tncm91bmQ6ICcjRkY2MDAwJyxcbiAgICAgIGhpZ2hsaWdodDogeyBib3JkZXI6ICcjRkY2MDAwJywgYmFja2dyb3VuZDogJyNGRjYwMDAnIH0sXG4gICAgICBob3ZlcjogeyBib3JkZXI6ICcjRkY2MDAwJywgYmFja2dyb3VuZDogJyNGRjYwMDAnIH1cbiAgICB9LCAvLyAxMjogcmVhbCBvcmFuZ2VcbiAgICB7XG4gICAgICBib3JkZXI6ICcjOTdDMkZDJyxcbiAgICAgIGJhY2tncm91bmQ6ICcjMkI3Q0U5JyxcbiAgICAgIGhpZ2hsaWdodDogeyBib3JkZXI6ICcjRDJFNUZGJywgYmFja2dyb3VuZDogJyMyQjdDRTknIH0sXG4gICAgICBob3ZlcjogeyBib3JkZXI6ICcjRDJFNUZGJywgYmFja2dyb3VuZDogJyMyQjdDRTknIH1cbiAgICB9LCAvLyAxMzogYmx1ZVxuICAgIHtcbiAgICAgIGJvcmRlcjogJyMzOTk2MDUnLFxuICAgICAgYmFja2dyb3VuZDogJyMyNTVDMDMnLFxuICAgICAgaGlnaGxpZ2h0OiB7IGJvcmRlcjogJyMzOTk2MDUnLCBiYWNrZ3JvdW5kOiAnIzI1NUMwMycgfSxcbiAgICAgIGhvdmVyOiB7IGJvcmRlcjogJyMzOTk2MDUnLCBiYWNrZ3JvdW5kOiAnIzI1NUMwMycgfVxuICAgIH0sIC8vIDE0OiBncmVlblxuICAgIHtcbiAgICAgIGJvcmRlcjogJyNCNzAwNTQnLFxuICAgICAgYmFja2dyb3VuZDogJyNGRjAwN0UnLFxuICAgICAgaGlnaGxpZ2h0OiB7IGJvcmRlcjogJyNCNzAwNTQnLCBiYWNrZ3JvdW5kOiAnI0ZGMDA3RScgfSxcbiAgICAgIGhvdmVyOiB7IGJvcmRlcjogJyNCNzAwNTQnLCBiYWNrZ3JvdW5kOiAnI0ZGMDA3RScgfVxuICAgIH0sIC8vIDE1OiBtYWdlbnRhXG4gICAge1xuICAgICAgYm9yZGVyOiAnI0FEODVFNCcsXG4gICAgICBiYWNrZ3JvdW5kOiAnIzdDMjlGMCcsXG4gICAgICBoaWdobGlnaHQ6IHsgYm9yZGVyOiAnI0QzQkRGMCcsIGJhY2tncm91bmQ6ICcjN0MyOUYwJyB9LFxuICAgICAgaG92ZXI6IHsgYm9yZGVyOiAnI0QzQkRGMCcsIGJhY2tncm91bmQ6ICcjN0MyOUYwJyB9XG4gICAgfSwgLy8gMTY6IHB1cnBsZVxuICAgIHtcbiAgICAgIGJvcmRlcjogJyM0NTU3RkEnLFxuICAgICAgYmFja2dyb3VuZDogJyMwMDBFQTEnLFxuICAgICAgaGlnaGxpZ2h0OiB7IGJvcmRlcjogJyM2RTZFRkQnLCBiYWNrZ3JvdW5kOiAnIzAwMEVBMScgfSxcbiAgICAgIGhvdmVyOiB7IGJvcmRlcjogJyM2RTZFRkQnLCBiYWNrZ3JvdW5kOiAnIzAwMEVBMScgfVxuICAgIH0sIC8vIDE3OiBkYXJrYmx1ZVxuICAgIHtcbiAgICAgIGJvcmRlcjogJyNGRkMwQ0InLFxuICAgICAgYmFja2dyb3VuZDogJyNGRDVBNzcnLFxuICAgICAgaGlnaGxpZ2h0OiB7IGJvcmRlcjogJyNGRkQxRDknLCBiYWNrZ3JvdW5kOiAnI0ZENUE3NycgfSxcbiAgICAgIGhvdmVyOiB7IGJvcmRlcjogJyNGRkQxRDknLCBiYWNrZ3JvdW5kOiAnI0ZENUE3NycgfVxuICAgIH0sIC8vIDE4OiBwaW5rXG4gICAge1xuICAgICAgYm9yZGVyOiAnI0MyRkFCQycsXG4gICAgICBiYWNrZ3JvdW5kOiAnIzc0RDY2QScsXG4gICAgICBoaWdobGlnaHQ6IHsgYm9yZGVyOiAnI0U2RkZFMycsIGJhY2tncm91bmQ6ICcjNzRENjZBJyB9LFxuICAgICAgaG92ZXI6IHsgYm9yZGVyOiAnI0U2RkZFMycsIGJhY2tncm91bmQ6ICcjNzRENjZBJyB9XG4gICAgfSwgLy8gMTk6IG1pbnRcblxuICAgIHtcbiAgICAgIGJvcmRlcjogJyNFRTAwMDAnLFxuICAgICAgYmFja2dyb3VuZDogJyM5OTAwMDAnLFxuICAgICAgaGlnaGxpZ2h0OiB7IGJvcmRlcjogJyNGRjMzMzMnLCBiYWNrZ3JvdW5kOiAnI0JCMDAwMCcgfSxcbiAgICAgIGhvdmVyOiB7IGJvcmRlcjogJyNGRjMzMzMnLCBiYWNrZ3JvdW5kOiAnI0JCMDAwMCcgfSAvLyAyMDpicmlnaHQgcmVkXG4gICAgfV07XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgdXNlRGVmYXVsdEdyb3VwczogdHJ1ZVxuICAgIH07XG4gICAgdXRpbC5leHRlbmQodGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKEdyb3VwcywgW3tcbiAgICBrZXk6ICdzZXRPcHRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB2YXIgb3B0aW9uRmllbGRzID0gWyd1c2VEZWZhdWx0R3JvdXBzJ107XG5cbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZm9yICh2YXIgZ3JvdXBOYW1lIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShncm91cE5hbWUpKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9uRmllbGRzLmluZGV4T2YoZ3JvdXBOYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgdmFyIGdyb3VwID0gb3B0aW9uc1tncm91cE5hbWVdO1xuICAgICAgICAgICAgICB0aGlzLmFkZChncm91cE5hbWUsIGdyb3VwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBhbGwgZ3JvdXBzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2NsZWFyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgICAgdGhpcy5ncm91cHNBcnJheSA9IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBncm91cCBvcHRpb25zIG9mIGEgZ3JvdXBuYW1lLlxuICAgICAqIElmIGdyb3VwbmFtZSBpcyBub3QgZm91bmQsIGEgbmV3IGdyb3VwIG1heSBiZSBjcmVhdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSAgICAgICBncm91cG5hbWUgICAgIENhbiBiZSBhIG51bWJlciwgc3RyaW5nLCBEYXRlLCBldGMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbc2hvdWxkQ3JlYXRlPXRydWVdIElmIHRydWUsIGNyZWF0ZSBhIG5ldyBncm91cFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGZvdW5kIG9yIGNyZWF0ZWQgZ3JvdXBcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KGdyb3VwbmFtZSkge1xuICAgICAgdmFyIHNob3VsZENyZWF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcblxuICAgICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cHNbZ3JvdXBuYW1lXTtcblxuICAgICAgaWYgKGdyb3VwID09PSB1bmRlZmluZWQgJiYgc2hvdWxkQ3JlYXRlKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudXNlRGVmYXVsdEdyb3VwcyA9PT0gZmFsc2UgJiYgdGhpcy5ncm91cHNBcnJheS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gY3JlYXRlIG5ldyBncm91cFxuICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuZ3JvdXBJbmRleCAlIHRoaXMuZ3JvdXBzQXJyYXkubGVuZ3RoO1xuICAgICAgICAgIHRoaXMuZ3JvdXBJbmRleCsrO1xuICAgICAgICAgIGdyb3VwID0ge307XG4gICAgICAgICAgZ3JvdXAuY29sb3IgPSB0aGlzLmdyb3Vwc1t0aGlzLmdyb3Vwc0FycmF5W2luZGV4XV07XG4gICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBuYW1lXSA9IGdyb3VwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNyZWF0ZSBuZXcgZ3JvdXBcbiAgICAgICAgICB2YXIgX2luZGV4ID0gdGhpcy5kZWZhdWx0SW5kZXggJSB0aGlzLmRlZmF1bHRHcm91cHMubGVuZ3RoO1xuICAgICAgICAgIHRoaXMuZGVmYXVsdEluZGV4Kys7XG4gICAgICAgICAgZ3JvdXAgPSB7fTtcbiAgICAgICAgICBncm91cC5jb2xvciA9IHRoaXMuZGVmYXVsdEdyb3Vwc1tfaW5kZXhdO1xuICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwbmFtZV0gPSBncm91cDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgY3VzdG9tIGdyb3VwIHN0eWxlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGdyb3VwTmFtZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZSAgICAgICBBbiBvYmplY3QgY29udGFpbmluZyBib3JkZXJDb2xvcixcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yLCBldGMuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBncm91cCAgICAgIFRoZSBjcmVhdGVkIGdyb3VwIG9iamVjdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhZGQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoZ3JvdXBOYW1lLCBzdHlsZSkge1xuICAgICAgdGhpcy5ncm91cHNbZ3JvdXBOYW1lXSA9IHN0eWxlO1xuICAgICAgdGhpcy5ncm91cHNBcnJheS5wdXNoKGdyb3VwTmFtZSk7XG4gICAgICByZXR1cm4gc3R5bGU7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBHcm91cHM7XG59KCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEdyb3VwcztcblxuLyoqKi8gfSksXG4vKiAxMzUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbnZhciBEYXRhU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgRGF0YVZpZXcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxKTtcbnZhciBOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNClbJ2RlZmF1bHQnXTtcblxuLyoqXG4gKiBIYW5kbGVyIGZvciBOb2Rlc1xuICovXG5cbnZhciBOb2Rlc0hhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0ltYWdlc30gaW1hZ2VzXG4gICAqIEBwYXJhbSB7QXJyYXkuPEdyb3VwPn0gZ3JvdXBzXG4gICAqIEBwYXJhbSB7TGF5b3V0RW5naW5lfSBsYXlvdXRFbmdpbmVcbiAgICovXG4gIGZ1bmN0aW9uIE5vZGVzSGFuZGxlcihib2R5LCBpbWFnZXMsIGdyb3VwcywgbGF5b3V0RW5naW5lKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIE5vZGVzSGFuZGxlcik7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuaW1hZ2VzID0gaW1hZ2VzO1xuICAgIHRoaXMuZ3JvdXBzID0gZ3JvdXBzO1xuICAgIHRoaXMubGF5b3V0RW5naW5lID0gbGF5b3V0RW5naW5lO1xuXG4gICAgLy8gY3JlYXRlIHRoZSBub2RlIEFQSSBpbiB0aGUgYm9keSBjb250YWluZXJcbiAgICB0aGlzLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZU5vZGUgPSB0aGlzLmNyZWF0ZS5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5ub2Rlc0xpc3RlbmVycyA9IHtcbiAgICAgIGFkZDogZnVuY3Rpb24gYWRkKGV2ZW50LCBwYXJhbXMpIHtcbiAgICAgICAgX3RoaXMuYWRkKHBhcmFtcy5pdGVtcyk7XG4gICAgICB9LFxuICAgICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoZXZlbnQsIHBhcmFtcykge1xuICAgICAgICBfdGhpcy51cGRhdGUocGFyYW1zLml0ZW1zLCBwYXJhbXMuZGF0YSwgcGFyYW1zLm9sZERhdGEpO1xuICAgICAgfSxcbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGV2ZW50LCBwYXJhbXMpIHtcbiAgICAgICAgX3RoaXMucmVtb3ZlKHBhcmFtcy5pdGVtcyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBib3JkZXJXaWR0aDogMSxcbiAgICAgIGJvcmRlcldpZHRoU2VsZWN0ZWQ6IDIsXG4gICAgICBicm9rZW5JbWFnZTogdW5kZWZpbmVkLFxuICAgICAgY29sb3I6IHtcbiAgICAgICAgYm9yZGVyOiAnIzJCN0NFOScsXG4gICAgICAgIGJhY2tncm91bmQ6ICcjOTdDMkZDJyxcbiAgICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgICAgYm9yZGVyOiAnIzJCN0NFOScsXG4gICAgICAgICAgYmFja2dyb3VuZDogJyNEMkU1RkYnXG4gICAgICAgIH0sXG4gICAgICAgIGhvdmVyOiB7XG4gICAgICAgICAgYm9yZGVyOiAnIzJCN0NFOScsXG4gICAgICAgICAgYmFja2dyb3VuZDogJyNEMkU1RkYnXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBmaXhlZDoge1xuICAgICAgICB4OiBmYWxzZSxcbiAgICAgICAgeTogZmFsc2VcbiAgICAgIH0sXG4gICAgICBmb250OiB7XG4gICAgICAgIGNvbG9yOiAnIzM0MzQzNCcsXG4gICAgICAgIHNpemU6IDE0LCAvLyBweFxuICAgICAgICBmYWNlOiAnYXJpYWwnLFxuICAgICAgICBiYWNrZ3JvdW5kOiAnbm9uZScsXG4gICAgICAgIHN0cm9rZVdpZHRoOiAwLCAvLyBweFxuICAgICAgICBzdHJva2VDb2xvcjogJyNmZmZmZmYnLFxuICAgICAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgICAgIHZhZGp1c3Q6IDAsXG4gICAgICAgIG11bHRpOiBmYWxzZSxcbiAgICAgICAgYm9sZDoge1xuICAgICAgICAgIG1vZDogJ2JvbGQnXG4gICAgICAgIH0sXG4gICAgICAgIGJvbGRpdGFsOiB7XG4gICAgICAgICAgbW9kOiAnYm9sZCBpdGFsaWMnXG4gICAgICAgIH0sXG4gICAgICAgIGl0YWw6IHtcbiAgICAgICAgICBtb2Q6ICdpdGFsaWMnXG4gICAgICAgIH0sXG4gICAgICAgIG1vbm86IHtcbiAgICAgICAgICBtb2Q6ICcnLFxuICAgICAgICAgIHNpemU6IDE1LCAvLyBweFxuICAgICAgICAgIGZhY2U6ICdtb25vc3BhY2UnLFxuICAgICAgICAgIHZhZGp1c3Q6IDJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGdyb3VwOiB1bmRlZmluZWQsXG4gICAgICBoaWRkZW46IGZhbHNlLFxuICAgICAgaWNvbjoge1xuICAgICAgICBmYWNlOiAnRm9udEF3ZXNvbWUnLCAvLydGb250QXdlc29tZScsXG4gICAgICAgIGNvZGU6IHVuZGVmaW5lZCwgLy8nXFx1ZjAwNycsXG4gICAgICAgIHNpemU6IDUwLCAvLzUwLFxuICAgICAgICBjb2xvcjogJyMyQjdDRTknIC8vJyNhYTAwZmYnXG4gICAgICB9LFxuICAgICAgaW1hZ2U6IHVuZGVmaW5lZCwgLy8gLS0+IFVSTFxuICAgICAgbGFiZWw6IHVuZGVmaW5lZCxcbiAgICAgIGxhYmVsSGlnaGxpZ2h0Qm9sZDogdHJ1ZSxcbiAgICAgIGxldmVsOiB1bmRlZmluZWQsXG4gICAgICBtYXJnaW46IHtcbiAgICAgICAgdG9wOiA1LFxuICAgICAgICByaWdodDogNSxcbiAgICAgICAgYm90dG9tOiA1LFxuICAgICAgICBsZWZ0OiA1XG4gICAgICB9LFxuICAgICAgbWFzczogMSxcbiAgICAgIHBoeXNpY3M6IHRydWUsXG4gICAgICBzY2FsaW5nOiB7XG4gICAgICAgIG1pbjogMTAsXG4gICAgICAgIG1heDogMzAsXG4gICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgbWluOiAxNCxcbiAgICAgICAgICBtYXg6IDMwLFxuICAgICAgICAgIG1heFZpc2libGU6IDMwLFxuICAgICAgICAgIGRyYXdUaHJlc2hvbGQ6IDVcbiAgICAgICAgfSxcbiAgICAgICAgY3VzdG9tU2NhbGluZ0Z1bmN0aW9uOiBmdW5jdGlvbiBjdXN0b21TY2FsaW5nRnVuY3Rpb24obWluLCBtYXgsIHRvdGFsLCB2YWx1ZSkge1xuICAgICAgICAgIGlmIChtYXggPT09IG1pbikge1xuICAgICAgICAgICAgcmV0dXJuIDAuNTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHNjYWxlID0gMSAvIChtYXggLSBtaW4pO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsICh2YWx1ZSAtIG1pbikgKiBzY2FsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2hhZG93OiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBjb2xvcjogJ3JnYmEoMCwwLDAsMC41KScsXG4gICAgICAgIHNpemU6IDEwLFxuICAgICAgICB4OiA1LFxuICAgICAgICB5OiA1XG4gICAgICB9LFxuICAgICAgc2hhcGU6ICdlbGxpcHNlJyxcbiAgICAgIHNoYXBlUHJvcGVydGllczoge1xuICAgICAgICBib3JkZXJEYXNoZXM6IGZhbHNlLCAvLyBvbmx5IGZvciBib3JkZXJzXG4gICAgICAgIGJvcmRlclJhZGl1czogNiwgLy8gb25seSBmb3IgYm94IHNoYXBlXG4gICAgICAgIGludGVycG9sYXRpb246IHRydWUsIC8vIG9ubHkgZm9yIGltYWdlIGFuZCBjaXJjdWxhckltYWdlIHNoYXBlc1xuICAgICAgICB1c2VJbWFnZVNpemU6IGZhbHNlLCAvLyBvbmx5IGZvciBpbWFnZSBhbmQgY2lyY3VsYXJJbWFnZSBzaGFwZXNcbiAgICAgICAgdXNlQm9yZGVyV2l0aEltYWdlOiBmYWxzZSAvLyBvbmx5IGZvciBpbWFnZSBzaGFwZVxuICAgICAgfSxcbiAgICAgIHNpemU6IDI1LFxuICAgICAgdGl0bGU6IHVuZGVmaW5lZCxcbiAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICB4OiB1bmRlZmluZWQsXG4gICAgICB5OiB1bmRlZmluZWRcblxuICAgICAgLy8gUHJvdGVjdCBmcm9tIGlkaW9jeVxuICAgIH07aWYgKHRoaXMuZGVmYXVsdE9wdGlvbnMubWFzcyA8PSAwKSB7XG4gICAgICB0aHJvdyAnSW50ZXJuYWwgZXJyb3I6IG1hc3MgaW4gZGVmYXVsdE9wdGlvbnMgb2YgTm9kZXNIYW5kbGVyIG1heSBub3QgYmUgemVybyBvciBuZWdhdGl2ZSc7XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zID0gdXRpbC5icmlkZ2VPYmplY3QodGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgICB0aGlzLmJpbmRFdmVudExpc3RlbmVycygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJpbmRzIGV2ZW50IGxpc3RlbmVyc1xuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKE5vZGVzSGFuZGxlciwgW3tcbiAgICBrZXk6ICdiaW5kRXZlbnRMaXN0ZW5lcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgLy8gcmVmcmVzaCB0aGUgbm9kZXMuIFVzZWQgd2hlbiByZXZlcnRpbmcgZnJvbSBoaWVyYXJjaGljYWwgbGF5b3V0XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbigncmVmcmVzaE5vZGVzJywgdGhpcy5yZWZyZXNoLmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ3JlZnJlc2gnLCB0aGlzLnJlZnJlc2guYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbC5mb3JFYWNoKF90aGlzMi5ub2Rlc0xpc3RlbmVycywgZnVuY3Rpb24gKGNhbGxiYWNrLCBldmVudCkge1xuICAgICAgICAgIGlmIChfdGhpczIuYm9keS5kYXRhLm5vZGVzKSBfdGhpczIuYm9keS5kYXRhLm5vZGVzLm9mZihldmVudCwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVsZXRlIF90aGlzMi5ib2R5LmZ1bmN0aW9ucy5jcmVhdGVOb2RlO1xuICAgICAgICBkZWxldGUgX3RoaXMyLm5vZGVzTGlzdGVuZXJzLmFkZDtcbiAgICAgICAgZGVsZXRlIF90aGlzMi5ub2Rlc0xpc3RlbmVycy51cGRhdGU7XG4gICAgICAgIGRlbGV0ZSBfdGhpczIubm9kZXNMaXN0ZW5lcnMucmVtb3ZlO1xuICAgICAgICBkZWxldGUgX3RoaXMyLm5vZGVzTGlzdGVuZXJzO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRPcHRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIE5vZGUucGFyc2VPcHRpb25zKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBzaGFwZSBpbiBhbGwgbm9kZXNcbiAgICAgICAgaWYgKG9wdGlvbnMuc2hhcGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGZvciAodmFyIG5vZGVJZCBpbiB0aGlzLmJvZHkubm9kZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgICAgICB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXS51cGRhdGVTaGFwZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgZm9udCBpbiBhbGwgbm9kZXNcbiAgICAgICAgaWYgKG9wdGlvbnMuZm9udCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZm9yICh2YXIgX25vZGVJZCBpbiB0aGlzLmJvZHkubm9kZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXMuaGFzT3duUHJvcGVydHkoX25vZGVJZCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW19ub2RlSWRdLnVwZGF0ZUxhYmVsTW9kdWxlKCk7XG4gICAgICAgICAgICAgIHRoaXMuYm9keS5ub2Rlc1tfbm9kZUlkXS5uZWVkc1JlZnJlc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHNoYXBlIHNpemUgaW4gYWxsIG5vZGVzXG4gICAgICAgIGlmIChvcHRpb25zLnNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGZvciAodmFyIF9ub2RlSWQyIGluIHRoaXMuYm9keS5ub2Rlcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlcy5oYXNPd25Qcm9wZXJ0eShfbm9kZUlkMikpIHtcbiAgICAgICAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW19ub2RlSWQyXS5uZWVkc1JlZnJlc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHN0YXRlIG9mIHRoZSB2YXJpYWJsZXMgaWYgbmVlZGVkXG4gICAgICAgIGlmIChvcHRpb25zLmhpZGRlbiAhPT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMucGh5c2ljcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2RhdGFDaGFuZ2VkJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYSBkYXRhIHNldCB3aXRoIG5vZGVzIGZvciB0aGUgbmV0d29ya1xuICAgICAqIEBwYXJhbSB7QXJyYXkgfCBEYXRhU2V0IHwgRGF0YVZpZXd9IG5vZGVzICAgICAgICAgVGhlIGRhdGEgY29udGFpbmluZyB0aGUgbm9kZXMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZG9Ob3RFbWl0PWZhbHNlXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldERhdGEnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXREYXRhKG5vZGVzKSB7XG4gICAgICB2YXIgZG9Ob3RFbWl0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgICAgdmFyIG9sZE5vZGVzRGF0YSA9IHRoaXMuYm9keS5kYXRhLm5vZGVzO1xuXG4gICAgICBpZiAobm9kZXMgaW5zdGFuY2VvZiBEYXRhU2V0IHx8IG5vZGVzIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICAgICAgdGhpcy5ib2R5LmRhdGEubm9kZXMgPSBub2RlcztcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShub2RlcykpIHtcbiAgICAgICAgdGhpcy5ib2R5LmRhdGEubm9kZXMgPSBuZXcgRGF0YVNldCgpO1xuICAgICAgICB0aGlzLmJvZHkuZGF0YS5ub2Rlcy5hZGQobm9kZXMpO1xuICAgICAgfSBlbHNlIGlmICghbm9kZXMpIHtcbiAgICAgICAgdGhpcy5ib2R5LmRhdGEubm9kZXMgPSBuZXcgRGF0YVNldCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkgb3IgRGF0YVNldCBleHBlY3RlZCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAob2xkTm9kZXNEYXRhKSB7XG4gICAgICAgIC8vIHVuc3Vic2NyaWJlIGZyb20gb2xkIGRhdGFzZXRcbiAgICAgICAgdXRpbC5mb3JFYWNoKHRoaXMubm9kZXNMaXN0ZW5lcnMsIGZ1bmN0aW9uIChjYWxsYmFjaywgZXZlbnQpIHtcbiAgICAgICAgICBvbGROb2Rlc0RhdGEub2ZmKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyByZW1vdmUgZHJhd24gbm9kZXNcbiAgICAgIHRoaXMuYm9keS5ub2RlcyA9IHt9O1xuXG4gICAgICBpZiAodGhpcy5ib2R5LmRhdGEubm9kZXMpIHtcbiAgICAgICAgLy8gc3Vic2NyaWJlIHRvIG5ldyBkYXRhc2V0XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHV0aWwuZm9yRWFjaCh0aGlzLm5vZGVzTGlzdGVuZXJzLCBmdW5jdGlvbiAoY2FsbGJhY2ssIGV2ZW50KSB7XG4gICAgICAgICAgbWUuYm9keS5kYXRhLm5vZGVzLm9uKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGRyYXcgYWxsIG5ldyBub2Rlc1xuICAgICAgICB2YXIgaWRzID0gdGhpcy5ib2R5LmRhdGEubm9kZXMuZ2V0SWRzKCk7XG4gICAgICAgIHRoaXMuYWRkKGlkcywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkb05vdEVtaXQgPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19kYXRhQ2hhbmdlZCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBub2Rlc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyW10gfCBzdHJpbmdbXX0gaWRzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZG9Ob3RFbWl0PWZhbHNlXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2FkZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChpZHMpIHtcbiAgICAgIHZhciBkb05vdEVtaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gICAgICB2YXIgaWQgPSB2b2lkIDA7XG4gICAgICB2YXIgbmV3Tm9kZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlkID0gaWRzW2ldO1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMuYm9keS5kYXRhLm5vZGVzLmdldChpZCk7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGUocHJvcGVydGllcyk7XG4gICAgICAgIG5ld05vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIHRoaXMuYm9keS5ub2Rlc1tpZF0gPSBub2RlOyAvLyBub3RlOiB0aGlzIG1heSByZXBsYWNlIGFuIGV4aXN0aW5nIG5vZGVcbiAgICAgIH1cblxuICAgICAgdGhpcy5sYXlvdXRFbmdpbmUucG9zaXRpb25Jbml0aWFsbHkobmV3Tm9kZXMpO1xuXG4gICAgICBpZiAoZG9Ob3RFbWl0ID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfZGF0YUNoYW5nZWQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZXhpc3Rpbmcgbm9kZXMsIG9yIGNyZWF0ZSB0aGVtIHdoZW4gbm90IHlldCBleGlzdGluZ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyW10gfCBzdHJpbmdbXX0gaWRzIGlkJ3Mgb2YgY2hhbmdlZCBub2Rlc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNoYW5nZWREYXRhIGFycmF5IHdpdGggY2hhbmdlZCBkYXRhXG4gICAgICogQHBhcmFtIHtBcnJheXx1bmRlZmluZWR9IG9sZERhdGEgb3B0aW9uYWw7IGFycmF5IHdpdGggcHJldmlvdXMgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShpZHMsIGNoYW5nZWREYXRhLCBvbGREYXRhKSB7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICB2YXIgZGF0YUNoYW5nZWQgPSBmYWxzZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpZCA9IGlkc1tpXTtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpZF07XG4gICAgICAgIHZhciBkYXRhID0gY2hhbmdlZERhdGFbaV07XG4gICAgICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyB1cGRhdGUgbm9kZVxuICAgICAgICAgIGlmIChub2RlLnNldE9wdGlvbnMoZGF0YSkpIHtcbiAgICAgICAgICAgIGRhdGFDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0YUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIC8vIGNyZWF0ZSBub2RlXG4gICAgICAgICAgbm9kZSA9IHRoaXMuY3JlYXRlKGRhdGEpO1xuICAgICAgICAgIG5vZGVzW2lkXSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFkYXRhQ2hhbmdlZCAmJiBvbGREYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGFueSBjaGFuZ2VzIHdoaWNoIHNob3VsZCB0cmlnZ2VyIGEgbGF5b3V0IHJlY2FsY3VsYXRpb25cbiAgICAgICAgLy8gRm9yIG5vdywgdGhpcyBpcyBqdXN0ICdsZXZlbCcgZm9yIGhpZXJhcmNoaWNhbCBsYXlvdXRcbiAgICAgICAgLy8gQXNzdW1wdGlvbjogb2xkIGFuZCBuZXcgZGF0YSBhcnJhbmdlZCBpbiBzYW1lIG9yZGVyOyBhdCB0aW1lIG9mIHdyaXRpbmcsIHRoaXMgaG9sZHMuXG4gICAgICAgIGRhdGFDaGFuZ2VkID0gY2hhbmdlZERhdGEuc29tZShmdW5jdGlvbiAobmV3VmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgdmFyIG9sZFZhbHVlID0gb2xkRGF0YVtpbmRleF07XG4gICAgICAgICAgcmV0dXJuIG9sZFZhbHVlICYmIG9sZFZhbHVlLmxldmVsICE9PSBuZXdWYWx1ZS5sZXZlbDtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhQ2hhbmdlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfZGF0YUNoYW5nZWQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19kYXRhVXBkYXRlZCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBleGlzdGluZyBub2Rlcy4gSWYgbm9kZXMgZG8gbm90IGV4aXN0LCB0aGUgbWV0aG9kIHdpbGwganVzdCBpZ25vcmUgaXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXSB8IHN0cmluZ1tdfSBpZHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZW1vdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoaWRzKSB7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpZCA9IGlkc1tpXTtcbiAgICAgICAgZGVsZXRlIG5vZGVzW2lkXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2RhdGFDaGFuZ2VkJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY3JlYXRlIGEgbm9kZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtjbGFzc30gW2NvbnN0cnVjdG9yQ2xhc3M9Tm9kZS5kZWZhdWx0XVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdjcmVhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgdmFyIGNvbnN0cnVjdG9yQ2xhc3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IE5vZGU7XG5cbiAgICAgIHJldHVybiBuZXcgY29uc3RydWN0b3JDbGFzcyhwcm9wZXJ0aWVzLCB0aGlzLmJvZHksIHRoaXMuaW1hZ2VzLCB0aGlzLmdyb3VwcywgdGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NsZWFyUG9zaXRpb25zPWZhbHNlXVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZWZyZXNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVmcmVzaCgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgY2xlYXJQb3NpdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuXG4gICAgICB1dGlsLmZvckVhY2godGhpcy5ib2R5Lm5vZGVzLCBmdW5jdGlvbiAobm9kZSwgbm9kZUlkKSB7XG4gICAgICAgIHZhciBkYXRhID0gX3RoaXMzLmJvZHkuZGF0YS5ub2Rlcy5nZXQobm9kZUlkKTtcbiAgICAgICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChjbGVhclBvc2l0aW9ucyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgbm9kZS5zZXRPcHRpb25zKHsgeDogbnVsbCwgeTogbnVsbCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS5zZXRPcHRpb25zKHsgZml4ZWQ6IGZhbHNlIH0pO1xuICAgICAgICAgIG5vZGUuc2V0T3B0aW9ucyhkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcG9zaXRpb25zIG9mIHRoZSBub2Rlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOb2RlLmlkPnxTdHJpbmd9IFtpZHNdICAtLT4gb3B0aW9uYWwsIGNhbiBiZSBhcnJheSBvZiBub2RlSWRzLCBjYW4gYmUgc3RyaW5nXG4gICAgICogQHJldHVybnMge3t9fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRQb3NpdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb3NpdGlvbnMoaWRzKSB7XG4gICAgICB2YXIgZGF0YUFycmF5ID0ge307XG4gICAgICBpZiAoaWRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaWRzKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW2lkc1tpXV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tpZHNbaV1dO1xuICAgICAgICAgICAgICBkYXRhQXJyYXlbaWRzW2ldXSA9IHsgeDogTWF0aC5yb3VuZChub2RlLngpLCB5OiBNYXRoLnJvdW5kKG5vZGUueSkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlc1tpZHNdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBfbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tpZHNdO1xuICAgICAgICAgICAgZGF0YUFycmF5W2lkc10gPSB7IHg6IE1hdGgucm91bmQoX25vZGUueCksIHk6IE1hdGgucm91bmQoX25vZGUueSkgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgdmFyIF9ub2RlMiA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLmJvZHkubm9kZUluZGljZXNbX2ldXTtcbiAgICAgICAgICBkYXRhQXJyYXlbdGhpcy5ib2R5Lm5vZGVJbmRpY2VzW19pXV0gPSB7XG4gICAgICAgICAgICB4OiBNYXRoLnJvdW5kKF9ub2RlMi54KSxcbiAgICAgICAgICAgIHk6IE1hdGgucm91bmQoX25vZGUyLnkpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFBcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkIHRoZSBYWSBwb3NpdGlvbnMgb2YgdGhlIG5vZGVzIGludG8gdGhlIGRhdGFzZXQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3N0b3JlUG9zaXRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcmVQb3NpdGlvbnMoKSB7XG4gICAgICAvLyB0b2RvOiBhZGQgc3VwcG9ydCBmb3IgY2x1c3RlcnMgYW5kIGhpZXJhcmNoaWNhbC5cbiAgICAgIHZhciBkYXRhQXJyYXkgPSBbXTtcbiAgICAgIHZhciBkYXRhc2V0ID0gdGhpcy5ib2R5LmRhdGEubm9kZXMuZ2V0RGF0YVNldCgpO1xuXG4gICAgICBmb3IgKHZhciBub2RlSWQgaW4gZGF0YXNldC5fZGF0YSkge1xuICAgICAgICBpZiAoZGF0YXNldC5fZGF0YS5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICBpZiAoZGF0YXNldC5fZGF0YVtub2RlSWRdLnggIT0gTWF0aC5yb3VuZChub2RlLngpIHx8IGRhdGFzZXQuX2RhdGFbbm9kZUlkXS55ICE9IE1hdGgucm91bmQobm9kZS55KSkge1xuICAgICAgICAgICAgZGF0YUFycmF5LnB1c2goe1xuICAgICAgICAgICAgICBpZDogbm9kZS5pZCxcbiAgICAgICAgICAgICAgeDogTWF0aC5yb3VuZChub2RlLngpLFxuICAgICAgICAgICAgICB5OiBNYXRoLnJvdW5kKG5vZGUueSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGF0YXNldC51cGRhdGUoZGF0YUFycmF5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIGJvdW5kaW5nIGJveCBvZiBhIG5vZGUuXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBub2RlSWRcbiAgICAgKiBAcmV0dXJucyB7anwqfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRCb3VuZGluZ0JveCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJvdW5kaW5nQm94KG5vZGVJZCkge1xuICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdLnNoYXBlLmJvdW5kaW5nQm94O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgSWRzIG9mIG5vZGVzIGNvbm5lY3RlZCB0byB0aGlzIG5vZGUuXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBub2RlSWRcbiAgICAgKiBAcGFyYW0geyd0byd8J2Zyb20nfHVuZGVmaW5lZH0gZGlyZWN0aW9uIHZhbHVlcyAnZnJvbScgYW5kICd0bycgc2VsZWN0IHJlc3BlY3RpdmVseSBwYXJlbnQgYW5kIGNoaWxkIG5vZGVzIG9ubHkuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbnkgb3RoZXIgdmFsdWUgcmV0dXJucyBib3RoIHBhcmVudCBhbmQgY2hpbGQgbm9kZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRDb25uZWN0ZWROb2RlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbm5lY3RlZE5vZGVzKG5vZGVJZCwgZGlyZWN0aW9uKSB7XG4gICAgICB2YXIgbm9kZUxpc3QgPSBbXTtcbiAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICAgIHZhciBub2RlT2JqID0ge307IC8vIHVzZWQgdG8gcXVpY2tseSBjaGVjayBpZiBub2RlIGFscmVhZHkgZXhpc3RzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5lZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlZGdlID0gbm9kZS5lZGdlc1tpXTtcbiAgICAgICAgICBpZiAoZGlyZWN0aW9uICE9PSAndG8nICYmIGVkZ2UudG9JZCA9PSBub2RlLmlkKSB7XG4gICAgICAgICAgICAvLyB0aGVzZSBhcmUgZG91YmxlIGVxdWFscyBzaW5jZSBpZHMgY2FuIGJlIG51bWVyaWMgb3Igc3RyaW5nXG4gICAgICAgICAgICBpZiAobm9kZU9ialtlZGdlLmZyb21JZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBub2RlTGlzdC5wdXNoKGVkZ2UuZnJvbUlkKTtcbiAgICAgICAgICAgICAgbm9kZU9ialtlZGdlLmZyb21JZF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uICE9PSAnZnJvbScgJiYgZWRnZS5mcm9tSWQgPT0gbm9kZS5pZCkge1xuICAgICAgICAgICAgLy8gdGhlc2UgYXJlIGRvdWJsZSBlcXVhbHMgc2luY2UgaWRzIGNhbiBiZSBudW1lcmljIG9yIHN0cmluZ1xuICAgICAgICAgICAgaWYgKG5vZGVPYmpbZWRnZS50b0lkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIG5vZGVMaXN0LnB1c2goZWRnZS50b0lkKTtcbiAgICAgICAgICAgICAgbm9kZU9ialtlZGdlLnRvSWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlTGlzdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGlkcyBvZiB0aGUgZWRnZXMgY29ubmVjdGVkIHRvIHRoaXMgbm9kZS5cbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IG5vZGVJZFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRDb25uZWN0ZWRFZGdlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbm5lY3RlZEVkZ2VzKG5vZGVJZCkge1xuICAgICAgdmFyIGVkZ2VMaXN0ID0gW107XG4gICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBlZGdlTGlzdC5wdXNoKG5vZGUuZWRnZXNbaV0uaWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZygnTm9kZUlkIHByb3ZpZGVkIGZvciBnZXRDb25uZWN0ZWRFZGdlcyBkb2VzIG5vdCBleGlzdC4gUHJvdmlkZWQ6ICcsIG5vZGVJZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWRnZUxpc3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW92ZSBhIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IG5vZGVJZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbW92ZU5vZGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlTm9kZShub2RlSWQsIHgsIHkpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXS54ID0gTnVtYmVyKHgpO1xuICAgICAgICB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXS55ID0gTnVtYmVyKHkpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczQuYm9keS5lbWl0dGVyLmVtaXQoJ3N0YXJ0U2ltdWxhdGlvbicpO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdOb2RlIGlkIHN1cHBsaWVkIHRvIG1vdmVOb2RlIGRvZXMgbm90IGV4aXN0LiBQcm92aWRlZDogJywgbm9kZUlkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE5vZGVzSGFuZGxlcjtcbn0oKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gTm9kZXNIYW5kbGVyO1xuXG4vKioqLyB9KSxcbi8qIDEzNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IF9fd2VicGFja19yZXF1aXJlX18oMTM3KSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG4vKioqLyB9KSxcbi8qIDEzNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDM3KTtcbl9fd2VicGFja19yZXF1aXJlX18oNDcpO1xubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzOCk7XG5cblxuLyoqKi8gfSksXG4vKiAxMzggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3KTtcbnZhciBJVEVSQVRPUiA9IF9fd2VicGFja19yZXF1aXJlX18oOCkoJ2l0ZXJhdG9yJyk7XG52YXIgSXRlcmF0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNikuaXNJdGVyYWJsZSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTyA9IE9iamVjdChpdCk7XG4gIHJldHVybiBPW0lURVJBVE9SXSAhPT0gdW5kZWZpbmVkXG4gICAgfHwgJ0BAaXRlcmF0b3InIGluIE9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgfHwgSXRlcmF0b3JzLmhhc093blByb3BlcnR5KGNsYXNzb2YoTykpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDEzOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cbnZhciBfc2xpY2VkVG9BcnJheTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zbGljZWRUb0FycmF5Mik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgTGFiZWxBY2N1bXVsYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTQwKVsnZGVmYXVsdCddO1xudmFyIENvbXBvbmVudFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KVsnZGVmYXVsdCddO1xuXG4vLyBIYXNoIG9mIHByZXBhcmVkIHJlZ2V4cCdzIGZvciB0YWdzXG52YXIgdGFnUGF0dGVybiA9IHtcbiAgLy8gSFRNTFxuICAnPGI+JzogLzxiPi8sXG4gICc8aT4nOiAvPGk+LyxcbiAgJzxjb2RlPic6IC88Y29kZT4vLFxuICAnPC9iPic6IC88XFwvYj4vLFxuICAnPC9pPic6IC88XFwvaT4vLFxuICAnPC9jb2RlPic6IC88XFwvY29kZT4vLFxuICAvLyBNYXJrZG93blxuICAnKic6IC9cXCovLCAvLyBib2xkXG4gIF86IC9cXF8vLCAvLyBpdGFsXG4gICdgJzogL2AvLCAvLyBtb25vXG4gIGFmdGVyQm9sZDogL1teXFwqXS8sXG4gIGFmdGVySXRhbDogL1teX10vLFxuICBhZnRlck1vbm86IC9bXmBdL1xuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBoZWxwZXIgY2xhc3MgZm9yIHBhcnNpbmcgdGhlIG1hcmt1cCB0YWdzIGZvciBIVE1MIGFuZCBNYXJrZG93bi5cbiAgICpcbiAgICogTk9URTogU2VxdWVuY2VzIG9mIHRhYnMgYW5kIHNwYWNlcyBhcmUgcmVkdWNlZCB0byBzaW5nbGUgc3BhY2UuXG4gICAqICAgICAgIFNjYW4gdXNhZ2Ugb2YgYHRoaXMuc3BhY2luZ2Agd2l0aGluIG1ldGhvZFxuICAgKi9cbn07XG52YXIgTWFya3VwQWNjdW11bGF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2VcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgIHRleHQgdG8gcGFyc2UgZm9yIG1hcmt1cFxuICAgKi9cbiAgZnVuY3Rpb24gTWFya3VwQWNjdW11bGF0b3IodGV4dCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIE1hcmt1cEFjY3VtdWxhdG9yKTtcblxuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgdGhpcy5ib2xkID0gZmFsc2U7XG4gICAgdGhpcy5pdGFsID0gZmFsc2U7XG4gICAgdGhpcy5tb25vID0gZmFsc2U7XG4gICAgdGhpcy5zcGFjaW5nID0gZmFsc2U7XG4gICAgdGhpcy5wb3NpdGlvbiA9IDA7XG4gICAgdGhpcy5idWZmZXIgPSAnJztcbiAgICB0aGlzLm1vZFN0YWNrID0gW107XG5cbiAgICB0aGlzLmJsb2NrcyA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbW9kIGxhYmVsIGN1cnJlbnRseSBvbiB0aGUgdG9wIG9mIHRoZSBzdGFja1xuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAgbGFiZWwgb2YgdG9wbW9zdCBtb2RcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzM1snZGVmYXVsdCddKShNYXJrdXBBY2N1bXVsYXRvciwgW3tcbiAgICBrZXk6ICdtb2QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb2QoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tb2RTdGFjay5sZW5ndGggPT09IDAgPyAnbm9ybWFsJyA6IHRoaXMubW9kU3RhY2tbMF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBtb2QgbGFiZWwgY3VycmVudGx5IGFjdGl2ZVxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gIGxhYmVsIG9mIGFjdGl2ZSBtb2RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdtb2ROYW1lJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW9kTmFtZSgpIHtcbiAgICAgIGlmICh0aGlzLm1vZFN0YWNrLmxlbmd0aCA9PT0gMCkgcmV0dXJuICdub3JtYWwnO2Vsc2UgaWYgKHRoaXMubW9kU3RhY2tbMF0gPT09ICdtb25vJykgcmV0dXJuICdtb25vJztlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuYm9sZCAmJiB0aGlzLml0YWwpIHtcbiAgICAgICAgICByZXR1cm4gJ2JvbGRpdGFsJztcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmJvbGQpIHtcbiAgICAgICAgICByZXR1cm4gJ2JvbGQnO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXRhbCkge1xuICAgICAgICAgIHJldHVybiAnaXRhbCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdlbWl0QmxvY2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbWl0QmxvY2soKSB7XG4gICAgICBpZiAodGhpcy5zcGFjaW5nKSB7XG4gICAgICAgIHRoaXMuYWRkKCcgJyk7XG4gICAgICAgIHRoaXMuc3BhY2luZyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5ibG9ja3MucHVzaCh7IHRleHQ6IHRoaXMuYnVmZmVyLCBtb2Q6IHRoaXMubW9kTmFtZSgpIH0pO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9ICcnO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE91dHB1dCB0ZXh0IHRvIGJ1ZmZlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgIHRleHQgdG8gYWRkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYWRkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKHRleHQpIHtcbiAgICAgIGlmICh0ZXh0ID09PSAnICcpIHtcbiAgICAgICAgdGhpcy5zcGFjaW5nID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNwYWNpbmcpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgKz0gJyAnO1xuICAgICAgICB0aGlzLnNwYWNpbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0ZXh0ICE9ICcgJykge1xuICAgICAgICB0aGlzLmJ1ZmZlciArPSB0ZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBwYXJzaW5nIG9mIHdoaXRlc3BhY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaCAgdGhlIGNoYXJhY3RlciB0byBjaGVja1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBjaGFyYWN0ZXIgd2FzIHByb2Nlc3NlZCBhcyB3aGl0ZXNwYWNlLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncGFyc2VXUycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlV1MoY2gpIHtcbiAgICAgIGlmICgvWyBcXHRdLy50ZXN0KGNoKSkge1xuICAgICAgICBpZiAoIXRoaXMubW9ubykge1xuICAgICAgICAgIHRoaXMuc3BhY2luZyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5hZGQoY2gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWUgIGxhYmVsIGZvciBibG9jayB0eXBlIHRvIHNldFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldFRhZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFRhZyh0YWdOYW1lKSB7XG4gICAgICB0aGlzLmVtaXRCbG9jaygpO1xuICAgICAgdGhpc1t0YWdOYW1lXSA9IHRydWU7XG4gICAgICB0aGlzLm1vZFN0YWNrLnVuc2hpZnQodGFnTmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWUgIGxhYmVsIGZvciBibG9jayB0eXBlIHRvIHVuc2V0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndW5zZXRUYWcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnNldFRhZyh0YWdOYW1lKSB7XG4gICAgICB0aGlzLmVtaXRCbG9jaygpO1xuICAgICAgdGhpc1t0YWdOYW1lXSA9IGZhbHNlO1xuICAgICAgdGhpcy5tb2RTdGFjay5zaGlmdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWdOYW1lIGxhYmVsIGZvciBibG9jayB0eXBlIHdlIGFyZSBjdXJyZW50bHkgcHJvY2Vzc2luZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfFJlZ0V4cH0gdGFnIHN0cmluZyB0byBtYXRjaCBpbiB0ZXh0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIHRhZyB3YXMgcHJvY2Vzc2VkLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncGFyc2VTdGFydFRhZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlU3RhcnRUYWcodGFnTmFtZSwgdGFnKSB7XG4gICAgICAvLyBOb3RlOiBpZiAnbW9ubycgcGFzc2VkIGFzIHRhZ05hbWUsIHRoZXJlIGlzIGEgZG91YmxlIGNoZWNrIGhlcmUuIFRoaXMgaXMgT0tcbiAgICAgIGlmICghdGhpcy5tb25vICYmICF0aGlzW3RhZ05hbWVdICYmIHRoaXMubWF0Y2godGFnKSkge1xuICAgICAgICB0aGlzLnNldFRhZyh0YWdOYW1lKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xSZWdFeHB9IHRhZ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYWR2YW5jZT10cnVlXSBpZiBzZXQsIGFkdmFuY2UgY3VycmVudCBwb3NpdGlvbiBpbiB0ZXh0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgbWF0Y2ggYXQgZ2l2ZW4gcG9zaXRpb24sIGZhbHNlIG90aGVyd2lzZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ21hdGNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF0Y2godGFnKSB7XG4gICAgICB2YXIgYWR2YW5jZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcblxuICAgICAgdmFyIF9wcmVwYXJlUmVnRXhwID0gdGhpcy5wcmVwYXJlUmVnRXhwKHRhZyksXG4gICAgICAgICAgX3ByZXBhcmVSZWdFeHAyID0gKDAsIF9zbGljZWRUb0FycmF5M1snZGVmYXVsdCddKShfcHJlcGFyZVJlZ0V4cCwgMiksXG4gICAgICAgICAgcmVnRXhwID0gX3ByZXBhcmVSZWdFeHAyWzBdLFxuICAgICAgICAgIGxlbmd0aCA9IF9wcmVwYXJlUmVnRXhwMlsxXTtcblxuICAgICAgdmFyIG1hdGNoZWQgPSByZWdFeHAudGVzdCh0aGlzLnRleHQuc3Vic3RyKHRoaXMucG9zaXRpb24sIGxlbmd0aCkpO1xuXG4gICAgICBpZiAobWF0Y2hlZCAmJiBhZHZhbmNlKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gbGVuZ3RoIC0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hdGNoZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWUgbGFiZWwgZm9yIGJsb2NrIHR5cGUgd2UgYXJlIGN1cnJlbnRseSBwcm9jZXNzaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd8UmVnRXhwfSB0YWcgc3RyaW5nIHRvIG1hdGNoIGluIHRleHRcbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW25leHRUYWddIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBtYXRjaCBmb3IgY2hhcmFjdGVycyAqZm9sbG93aW5nKiB0aGUgY3VycmVudCB0YWdcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgdGFnIHdhcyBwcm9jZXNzZWQsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwYXJzZUVuZFRhZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlRW5kVGFnKHRhZ05hbWUsIHRhZywgbmV4dFRhZykge1xuICAgICAgdmFyIGNoZWNrVGFnID0gdGhpcy5tb2QoKSA9PT0gdGFnTmFtZTtcbiAgICAgIGlmICh0YWdOYW1lID09PSAnbW9ubycpIHtcbiAgICAgICAgLy8gc3BlY2lhbCBoYW5kbGluZyBmb3IgJ21vbm8nXG4gICAgICAgIGNoZWNrVGFnID0gY2hlY2tUYWcgJiYgdGhpcy5tb25vO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hlY2tUYWcgPSBjaGVja1RhZyAmJiAhdGhpcy5tb25vO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hlY2tUYWcgJiYgdGhpcy5tYXRjaCh0YWcpKSB7XG4gICAgICAgIGlmIChuZXh0VGFnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBQdXJwb3NlIG9mIHRoZSBmb2xsb3dpbmcgbWF0Y2ggaXMgdG8gcHJldmVudCBhIGRpcmVjdCB1bnNldC9zZXQgb2YgYSBnaXZlbiB0YWdcbiAgICAgICAgICAvLyBFLmcuICcqYm9sZCAqKnN0aWxsIGJvbGQqJyA9PiAnKmJvbGQgc3RpbGwgYm9sZConXG4gICAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gPT09IHRoaXMudGV4dC5sZW5ndGggLSAxIHx8IHRoaXMubWF0Y2gobmV4dFRhZywgZmFsc2UpKSB7XG4gICAgICAgICAgICB0aGlzLnVuc2V0VGFnKHRhZ05hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnVuc2V0VGFnKHRhZ05hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xSZWdFeHB9IHRhZyAgc3RyaW5nIHRvIG1hdGNoIGluIHRleHRcbiAgICAgKiBAcGFyYW0ge3ZhbHVlfSB2YWx1ZSAgc3RyaW5nIHRvIHJlcGxhY2UgdGFnIHdpdGgsIGlmIGZvdW5kIGF0IGN1cnJlbnQgcG9zaXRpb25cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgdGFnIHdhcyBwcm9jZXNzZWQsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZXBsYWNlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZSh0YWcsIHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5tYXRjaCh0YWcpKSB7XG4gICAgICAgIHRoaXMuYWRkKHZhbHVlKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSBsZW5ndGggLSAxO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgdGhlIHRhZyBpZiBpdCBpc24ndCBhbHJlYWR5IG9uZS5cbiAgICAgKlxuICAgICAqIFRoZSByZXR1cm4gdmFsdWUgaXMgYW4gYXJyYXkgYFtSZWdFeHAsIG51bWJlcl1gLCB3aXRoIGV4YWN0bHkgdHdvIHZhbHVlLCB3aGVyZTpcbiAgICAgKiAgLSBSZWdFeHAgaXMgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byB1c2VcbiAgICAgKiAgLSBudW1iZXIgaXMgdGhlIGxlbnRoIG9mIHRoZSBpbnB1dCBzdHJpbmcgdG8gbWF0Y2hcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfFJlZ0V4cH0gdGFnICBzdHJpbmcgdG8gbWF0Y2ggaW4gdGV4dFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byB1c2UgYW5kIGxlbmd0aCBvZiBpbnB1dCBzdHJpbmcgdG8gbWF0Y2hcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwcmVwYXJlUmVnRXhwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlcGFyZVJlZ0V4cCh0YWcpIHtcbiAgICAgIHZhciBsZW5ndGggPSB2b2lkIDA7XG4gICAgICB2YXIgcmVnRXhwID0gdm9pZCAwO1xuICAgICAgaWYgKHRhZyBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZWdFeHAgPSB0YWc7XG4gICAgICAgIGxlbmd0aCA9IDE7IC8vIEFTU1VNUFRJT046IHJlZ2V4cCBvbmx5IHRlc3RzIG9uZSBjaGFyYWN0ZXJcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVzZSBwcmVwYXJlZCByZWdleHAgaWYgcHJlc2VudFxuICAgICAgICB2YXIgcHJlcGFyZWQgPSB0YWdQYXR0ZXJuW3RhZ107XG4gICAgICAgIGlmIChwcmVwYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVnRXhwID0gcHJlcGFyZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVnRXhwID0gbmV3IFJlZ0V4cCh0YWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGVuZ3RoID0gdGFnLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtyZWdFeHAsIGxlbmd0aF07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBNYXJrdXBBY2N1bXVsYXRvcjtcbn0oKTtcblxuLyoqXG4gKiBIZWxwZXIgY2xhc3MgZm9yIExhYmVsIHdoaWNoIGV4cGxvZGVzIHRoZSBsYWJlbCB0ZXh0IGludG8gbGluZXMgYW5kIGJsb2NrcyB3aXRoaW4gbGluZXNcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5cblxudmFyIExhYmVsU3BsaXR0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENhbnZhcyByZW5kZXJpbmcgY29udGV4dFxuICAgKiBAcGFyYW0ge0xhYmVsfSBwYXJlbnQgcmVmZXJlbmNlIHRvIHRoZSBMYWJlbCBpbnN0YW5jZSB1c2luZyBjdXJyZW50IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgKi9cbiAgZnVuY3Rpb24gTGFiZWxTcGxpdHRlcihjdHgsIHBhcmVudCwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIExhYmVsU3BsaXR0ZXIpO1xuXG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG5cbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayB0byBkZXRlcm1pbmUgdGV4dCB3aWR0aDsgcGFzc2VkIHRvIExhYmVsQWNjdW11bGF0b3IgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdGV4dCBzdHJpbmcgdG8gZGV0ZXJtaW5lIHdpZHRoIG9mXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBtb2QgIGZvbnQgdHlwZSB0byB1c2UgZm9yIHRoaXMgdGV4dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0geyB3aWR0aCwgdmFsdWVzfSB3aWR0aCBpbiBwaXhlbHMgYW5kIGZvbnQgYXR0cmlidXRlc1xuICAgICAqL1xuICAgIHZhciB0ZXh0V2lkdGggPSBmdW5jdGlvbiB0ZXh0V2lkdGgodGV4dCwgbW9kKSB7XG4gICAgICBpZiAodGV4dCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gMDtcblxuICAgICAgLy8gVE9ETzogVGhpcyBjYW4gYmUgZG9uZSBtb3JlIGVmZmljaWVudGx5IHdpdGggY2FjaGluZ1xuICAgICAgdmFyIHZhbHVlcyA9IF90aGlzLnBhcmVudC5nZXRGb3JtYXR0aW5nVmFsdWVzKGN0eCwgc2VsZWN0ZWQsIGhvdmVyLCBtb2QpO1xuXG4gICAgICB2YXIgd2lkdGggPSAwO1xuICAgICAgaWYgKHRleHQgIT09ICcnKSB7XG4gICAgICAgIC8vIE5PVEU6IFRoZSBmb2xsb3dpbmcgbWF5IGFjdHVhbGx5IGJlICppbmNvcnJlY3QqIGZvciB0aGUgbW9kIGZvbnRzIVxuICAgICAgICAvLyAgICAgICBUaGlzIHJldHVybnMgdGhlIHNpemUgd2l0aCBhIHJlZ3VsYXIgZm9udCwgYm9sZCBldGMuIG1heVxuICAgICAgICAvLyAgICAgICBoYXZlIGRpZmZlcmVudCBzaXplcy5cbiAgICAgICAgdmFyIG1lYXN1cmUgPSBfdGhpcy5jdHgubWVhc3VyZVRleHQodGV4dCk7XG4gICAgICAgIHdpZHRoID0gbWVhc3VyZS53aWR0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgd2lkdGg6IHdpZHRoLCB2YWx1ZXM6IHZhbHVlcyB9O1xuICAgIH07XG5cbiAgICB0aGlzLmxpbmVzID0gbmV3IExhYmVsQWNjdW11bGF0b3IodGV4dFdpZHRoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdCBwYXNzZWQgdGV4dCBvZiBhIGxhYmVsIGludG8gbGluZXMgYW5kIGJsb2Nrcy5cbiAgICpcbiAgICogIyBOT1RFXG4gICAqXG4gICAqIFRoZSBoYW5kbGluZyBvZiBzcGFjaW5nIGlzIG9wdGlvbiBkZXBlbmRlbnQ6XG4gICAqXG4gICAqIC0gaWYgYGZvbnQubXVsdGkgOiBmYWxzZWAsIGFsbCBzcGFjZXMgYXJlIHJldGFpbmVkXG4gICAqIC0gaWYgYGZvbnQubXVsdGkgOiB0cnVlYCwgZXZlcnkgc2VxdWVuY2Ugb2Ygc3BhY2VzIGlzIGNvbXByZXNzZWQgdG8gYSBzaW5nbGUgc3BhY2VcbiAgICpcbiAgICogVGhpcyBtaWdodCBub3QgYmUgdGhlIGJlc3Qgd2F5IHRvIGRvIGl0LCBidXQgdGhpcyBpcyBhcyBpdCBoYXMgYmVlbiB3b3JraW5nIHRpbGwgbm93LlxuICAgKiBJbiBvcmRlciBub3QgdG8gYnJlYWsgZXhpc3RpbmcgZnVuY3Rpb25hbGl0eSwgZm9yIHRoZSB0aW1lIGJlaW5nIHRoaXMgYmVoYXZpb3VyIHdpbGxcbiAgICogYmUgcmV0YWluZWQgaW4gYW55IGNvZGUgY2hhbmdlcy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgIHRleHQgdG8gc3BsaXRcbiAgICogQHJldHVybnMge0FycmF5PGxpbmU+fVxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKExhYmVsU3BsaXR0ZXIsIFt7XG4gICAga2V5OiAncHJvY2VzcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3ModGV4dCkge1xuICAgICAgaWYgKCFDb21wb25lbnRVdGlsLmlzVmFsaWRMYWJlbCh0ZXh0KSkge1xuICAgICAgICByZXR1cm4gdGhpcy5saW5lcy5maW5hbGl6ZSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZm9udCA9IHRoaXMucGFyZW50LmZvbnRPcHRpb25zO1xuXG4gICAgICAvLyBOb3JtYWxpemUgdGhlIGVuZC1vZi1saW5lJ3MgdG8gYSBzaW5nbGUgcmVwcmVzZW50YXRpb24gLSBvcmRlciBpbXBvcnRhbnRcbiAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcclxcbi9nLCAnXFxuJyk7IC8vIERvcyBFT0wnc1xuICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxyL2csICdcXG4nKTsgLy8gTWFjIEVPTCdzXG5cbiAgICAgIC8vIE5vdGUgdGhhdCBhdCB0aGlzIHBvaW50LCB0aGVyZSBjYW4gYmUgbm8gXFxyJ3MgaW4gdGhlIHRleHQuXG4gICAgICAvLyBUaGlzIGlzIHVzZWQgbGF0ZXIgb24gc3BsaXRTdHJpbmdJbnRvTGluZXMoKSB0byBzcGxpdCBtdWx0aWZvbnQgdGV4dHMuXG5cbiAgICAgIHZhciBubExpbmVzID0gU3RyaW5nKHRleHQpLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBsaW5lQ291bnQgPSBubExpbmVzLmxlbmd0aDtcblxuICAgICAgaWYgKGZvbnQubXVsdGkpIHtcbiAgICAgICAgLy8gTXVsdGktZm9udCBjYXNlOiBzdHlsaW5nIHRhZ3MgYWN0aXZlXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZUNvdW50OyBpKyspIHtcbiAgICAgICAgICB2YXIgYmxvY2tzID0gdGhpcy5zcGxpdEJsb2NrcyhubExpbmVzW2ldLCBmb250Lm11bHRpKTtcbiAgICAgICAgICAvLyBQb3N0OiBTZXF1ZW5jZXMgb2YgdGFicyBhbmQgc3BhY2VzIGFyZSByZWR1Y2VkIHRvIHNpbmdsZSBzcGFjZVxuXG4gICAgICAgICAgaWYgKGJsb2NrcyA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcblxuICAgICAgICAgIGlmIChibG9ja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVzLm5ld0xpbmUoJycpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGZvbnQubWF4V2R0ID4gMCkge1xuICAgICAgICAgICAgLy8gd2lkdGhDb25zdHJhaW50Lm1heGltdW0gZGVmaW5lZFxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnUnVubmluZyB3aWR0aENvbnN0cmFpbnQgbXVsdGksIG1heDogJyArIHRoaXMuZm9udE9wdGlvbnMubWF4V2R0KTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYmxvY2tzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIHZhciBtb2QgPSBibG9ja3Nbal0ubW9kO1xuICAgICAgICAgICAgICB2YXIgX3RleHQgPSBibG9ja3Nbal0udGV4dDtcbiAgICAgICAgICAgICAgdGhpcy5zcGxpdFN0cmluZ0ludG9MaW5lcyhfdGV4dCwgbW9kLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gd2lkdGhDb25zdHJhaW50Lm1heGltdW0gTk9UIGRlZmluZWRcbiAgICAgICAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBibG9ja3MubGVuZ3RoOyBfaisrKSB7XG4gICAgICAgICAgICAgIHZhciBfbW9kID0gYmxvY2tzW19qXS5tb2Q7XG4gICAgICAgICAgICAgIHZhciBfdGV4dDIgPSBibG9ja3NbX2pdLnRleHQ7XG4gICAgICAgICAgICAgIHRoaXMubGluZXMuYXBwZW5kKF90ZXh0MiwgX21vZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5saW5lcy5uZXdMaW5lKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNpbmdsZS1mb250IGNhc2VcbiAgICAgICAgaWYgKGZvbnQubWF4V2R0ID4gMCkge1xuICAgICAgICAgIC8vIHdpZHRoQ29uc3RyYWludC5tYXhpbXVtIGRlZmluZWRcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnUnVubmluZyB3aWR0aENvbnN0cmFpbnQgbm9ybWFsLCBtYXg6ICcgKyB0aGlzLmZvbnRPcHRpb25zLm1heFdkdCk7XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxpbmVDb3VudDsgX2krKykge1xuICAgICAgICAgICAgdGhpcy5zcGxpdFN0cmluZ0ludG9MaW5lcyhubExpbmVzW19pXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHdpZHRoQ29uc3RyYWludC5tYXhpbXVtIE5PVCBkZWZpbmVkXG4gICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbGluZUNvdW50OyBfaTIrKykge1xuICAgICAgICAgICAgdGhpcy5saW5lcy5uZXdMaW5lKG5sTGluZXNbX2kyXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmxpbmVzLmZpbmFsaXplKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbm9ybWFsaXplIHRoZSBtYXJrdXAgc3lzdGVtXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58J21kJ3wnbWFya2Rvd24nfCdodG1sJ30gbWFya3VwU3lzdGVtXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZGVjb2RlTWFya3VwU3lzdGVtJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVjb2RlTWFya3VwU3lzdGVtKG1hcmt1cFN5c3RlbSkge1xuICAgICAgdmFyIHN5c3RlbSA9ICdub25lJztcbiAgICAgIGlmIChtYXJrdXBTeXN0ZW0gPT09ICdtYXJrZG93bicgfHwgbWFya3VwU3lzdGVtID09PSAnbWQnKSB7XG4gICAgICAgIHN5c3RlbSA9ICdtYXJrZG93bic7XG4gICAgICB9IGVsc2UgaWYgKG1hcmt1cFN5c3RlbSA9PT0gdHJ1ZSB8fCBtYXJrdXBTeXN0ZW0gPT09ICdodG1sJykge1xuICAgICAgICBzeXN0ZW0gPSAnaHRtbCc7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3lzdGVtO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NwbGl0SHRtbEJsb2NrcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNwbGl0SHRtbEJsb2Nrcyh0ZXh0KSB7XG4gICAgICB2YXIgcyA9IG5ldyBNYXJrdXBBY2N1bXVsYXRvcih0ZXh0KTtcblxuICAgICAgdmFyIHBhcnNlRW50aXRpZXMgPSBmdW5jdGlvbiBwYXJzZUVudGl0aWVzKGNoKSB7XG4gICAgICAgIGlmICgvJi8udGVzdChjaCkpIHtcbiAgICAgICAgICB2YXIgcGFyc2VkID0gcy5yZXBsYWNlKHMudGV4dCwgJyZsdDsnLCAnPCcpIHx8IHMucmVwbGFjZShzLnRleHQsICcmYW1wOycsICcmJyk7XG5cbiAgICAgICAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgICAgICAgcy5hZGQoJyYnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG5cbiAgICAgIHdoaWxlIChzLnBvc2l0aW9uIDwgcy50ZXh0Lmxlbmd0aCkge1xuICAgICAgICB2YXIgY2ggPSBzLnRleHQuY2hhckF0KHMucG9zaXRpb24pO1xuXG4gICAgICAgIHZhciBwYXJzZWQgPSBzLnBhcnNlV1MoY2gpIHx8IC88Ly50ZXN0KGNoKSAmJiAocy5wYXJzZVN0YXJ0VGFnKCdib2xkJywgJzxiPicpIHx8IHMucGFyc2VTdGFydFRhZygnaXRhbCcsICc8aT4nKSB8fCBzLnBhcnNlU3RhcnRUYWcoJ21vbm8nLCAnPGNvZGU+JykgfHwgcy5wYXJzZUVuZFRhZygnYm9sZCcsICc8L2I+JykgfHwgcy5wYXJzZUVuZFRhZygnaXRhbCcsICc8L2k+JykgfHwgcy5wYXJzZUVuZFRhZygnbW9ubycsICc8L2NvZGU+JykpIHx8IHBhcnNlRW50aXRpZXMoY2gpO1xuXG4gICAgICAgIGlmICghcGFyc2VkKSB7XG4gICAgICAgICAgcy5hZGQoY2gpO1xuICAgICAgICB9XG4gICAgICAgIHMucG9zaXRpb24rKztcbiAgICAgIH1cbiAgICAgIHMuZW1pdEJsb2NrKCk7XG4gICAgICByZXR1cm4gcy5ibG9ja3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc3BsaXRNYXJrZG93bkJsb2NrcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNwbGl0TWFya2Rvd25CbG9ja3ModGV4dCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBzID0gbmV3IE1hcmt1cEFjY3VtdWxhdG9yKHRleHQpO1xuICAgICAgdmFyIGJlZ2luYWJsZSA9IHRydWU7XG5cbiAgICAgIHZhciBwYXJzZU92ZXJyaWRlID0gZnVuY3Rpb24gcGFyc2VPdmVycmlkZShjaCkge1xuICAgICAgICBpZiAoL1xcXFwvLnRlc3QoY2gpKSB7XG4gICAgICAgICAgaWYgKHMucG9zaXRpb24gPCBfdGhpczIudGV4dC5sZW5ndGggKyAxKSB7XG4gICAgICAgICAgICBzLnBvc2l0aW9uKys7XG4gICAgICAgICAgICBjaCA9IF90aGlzMi50ZXh0LmNoYXJBdChzLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIGlmICgvIFxcdC8udGVzdChjaCkpIHtcbiAgICAgICAgICAgICAgcy5zcGFjaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHMuYWRkKGNoKTtcbiAgICAgICAgICAgICAgYmVnaW5hYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuXG4gICAgICB3aGlsZSAocy5wb3NpdGlvbiA8IHMudGV4dC5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGNoID0gcy50ZXh0LmNoYXJBdChzLnBvc2l0aW9uKTtcblxuICAgICAgICB2YXIgcGFyc2VkID0gcy5wYXJzZVdTKGNoKSB8fCBwYXJzZU92ZXJyaWRlKGNoKSB8fCAoYmVnaW5hYmxlIHx8IHMuc3BhY2luZykgJiYgKHMucGFyc2VTdGFydFRhZygnYm9sZCcsICcqJykgfHwgcy5wYXJzZVN0YXJ0VGFnKCdpdGFsJywgJ18nKSB8fCBzLnBhcnNlU3RhcnRUYWcoJ21vbm8nLCAnYCcpKSB8fCBzLnBhcnNlRW5kVGFnKCdib2xkJywgJyonLCAnYWZ0ZXJCb2xkJykgfHwgcy5wYXJzZUVuZFRhZygnaXRhbCcsICdfJywgJ2FmdGVySXRhbCcpIHx8IHMucGFyc2VFbmRUYWcoJ21vbm8nLCAnYCcsICdhZnRlck1vbm8nKTtcblxuICAgICAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgICAgIHMuYWRkKGNoKTtcbiAgICAgICAgICBiZWdpbmFibGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzLnBvc2l0aW9uKys7XG4gICAgICB9XG4gICAgICBzLmVtaXRCbG9jaygpO1xuICAgICAgcmV0dXJuIHMuYmxvY2tzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4cGxvZGVzIGEgcGllY2Ugb2YgdGV4dCBpbnRvIHNpbmdsZS1mb250IGJsb2NrcyB1c2luZyBhIGdpdmVuIG1hcmt1cFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58J21kJ3wnbWFya2Rvd24nfCdodG1sJ30gbWFya3VwU3lzdGVtXG4gICAgICogQHJldHVybnMge0FycmF5Ljx7dGV4dDogc3RyaW5nLCBtb2Q6IHN0cmluZ30+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NwbGl0QmxvY2tzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3BsaXRCbG9ja3ModGV4dCwgbWFya3VwU3lzdGVtKSB7XG4gICAgICB2YXIgc3lzdGVtID0gdGhpcy5kZWNvZGVNYXJrdXBTeXN0ZW0obWFya3VwU3lzdGVtKTtcbiAgICAgIGlmIChzeXN0ZW0gPT09ICdub25lJykge1xuICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgIG1vZDogJ25vcm1hbCdcbiAgICAgICAgfV07XG4gICAgICB9IGVsc2UgaWYgKHN5c3RlbSA9PT0gJ21hcmtkb3duJykge1xuICAgICAgICByZXR1cm4gdGhpcy5zcGxpdE1hcmtkb3duQmxvY2tzKHRleHQpO1xuICAgICAgfSBlbHNlIGlmIChzeXN0ZW0gPT09ICdodG1sJykge1xuICAgICAgICByZXR1cm4gdGhpcy5zcGxpdEh0bWxCbG9ja3ModGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0ZXh0IGxlbmd0aCBvdmVyIHRoZSBjdXJyZW50IG1heCB3aXRoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnb3Zlck1heFdpZHRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3Zlck1heFdpZHRoKHRleHQpIHtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMuY3R4Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoO1xuICAgICAgcmV0dXJuIHRoaXMubGluZXMuY3VyV2lkdGgoKSArIHdpZHRoID4gdGhpcy5wYXJlbnQuZm9udE9wdGlvbnMubWF4V2R0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB0aGUgbG9uZ2VzdCBwYXJ0IG9mIHRoZSBzZW50ZW5jZSB3aGljaCBzdGlsbCBmaXRzIGluIHRoZVxuICAgICAqIGN1cnJlbnQgbWF4IHdpZHRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gd29yZHMgIEFycmF5IG9mIHN0cmluZ3Mgc2lnbmlmeWluZyBhIHRleHQgbGluZXNcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgaW5kZXggb2YgZmlyc3QgaXRlbSBpbiBzdHJpbmcgbWFraW5nIHN0cmluZyBnbyBvdmVyIG1heFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldExvbmdlc3RGaXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMb25nZXN0Rml0KHdvcmRzKSB7XG4gICAgICB2YXIgdGV4dCA9ICcnO1xuICAgICAgdmFyIHcgPSAwO1xuXG4gICAgICB3aGlsZSAodyA8IHdvcmRzLmxlbmd0aCkge1xuICAgICAgICB2YXIgcHJlID0gdGV4dCA9PT0gJycgPyAnJyA6ICcgJztcbiAgICAgICAgdmFyIG5ld1RleHQgPSB0ZXh0ICsgcHJlICsgd29yZHNbd107XG5cbiAgICAgICAgaWYgKHRoaXMub3Zlck1heFdpZHRoKG5ld1RleHQpKSBicmVhaztcbiAgICAgICAgdGV4dCA9IG5ld1RleHQ7XG4gICAgICAgIHcrKztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHRoZSBsb25nZXN0IHBhcnQgb2YgdGhlIHN0cmluZyB3aGljaCBzdGlsbCBmaXRzIGluIHRoZVxuICAgICAqIGN1cnJlbnQgbWF4IHdpZHRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gd29yZHMgQXJyYXkgb2Ygc3RyaW5ncyBzaWduaWZ5aW5nIGEgdGV4dCBsaW5lc1xuICAgICAqIEByZXR1cm4ge251bWJlcn0gaW5kZXggb2YgZmlyc3QgaXRlbSBpbiBzdHJpbmcgbWFraW5nIHN0cmluZyBnbyBvdmVyIG1heFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRMb25nZXN0Rml0V29yZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExvbmdlc3RGaXRXb3JkKHdvcmRzKSB7XG4gICAgICB2YXIgdyA9IDA7XG5cbiAgICAgIHdoaWxlICh3IDwgd29yZHMubGVuZ3RoKSB7XG4gICAgICAgIGlmICh0aGlzLm92ZXJNYXhXaWR0aCh3b3Jkcy5zbGljZSgwLCB3KSkpIGJyZWFrO1xuICAgICAgICB3Kys7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB3O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNwbGl0IHRoZSBwYXNzZWQgdGV4dCBpbnRvIGxpbmVzLCBhY2NvcmRpbmcgdG8gd2lkdGggY29uc3RyYWludCAoaWYgYW55KS5cbiAgICAgKlxuICAgICAqIFRoZSBtZXRob2QgYXNzdW1lcyB0aGF0IHRoZSBpbnB1dCBzdHJpbmcgaXMgYSBzaW5nbGUgbGluZSwgaS5lLiB3aXRob3V0IGxpbmVzIGJyZWFrLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgcmV0YWlucyBzcGFjZXMsIGlmIHN0aWxsIHByZXNlbnQgKGNhc2UgYGZvbnQubXVsdGk6IGZhbHNlYCkuXG4gICAgICogQSBzcGFjZSB3aGljaCBmYWxscyBvbiBhbiBpbnRlcm5hbCBsaW5lIGJyZWFrLCB3aWxsIGJlIHJlcGxhY2VkIGJ5IGEgbmV3bGluZS5cbiAgICAgKiBUaGVyZSBpcyBubyBzcGVjaWFsIGhhbmRsaW5nIG9mIHRhYnM7IHRoZXNlIGdvIGFsb25nIHdpdGggdGhlIGZsb3cuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFttb2Q9J25vcm1hbCddXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbYXBwZW5kTGFzdD1mYWxzZV1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzcGxpdFN0cmluZ0ludG9MaW5lcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNwbGl0U3RyaW5nSW50b0xpbmVzKHN0cikge1xuICAgICAgdmFyIG1vZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ25vcm1hbCc7XG4gICAgICB2YXIgYXBwZW5kTGFzdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgICAgIC8vIFN0aWxsLXByZXNlbnQgc3BhY2VzIGFyZSByZWxldmFudCwgcmV0YWluIHRoZW1cbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9eKCArKS9nLCAnJDFcXHInKTtcbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC8oW15cXHJdW14gXSopKCArKS9nLCAnJDFcXHIkMlxccicpO1xuICAgICAgdmFyIHdvcmRzID0gc3RyLnNwbGl0KCdcXHInKTtcblxuICAgICAgd2hpbGUgKHdvcmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLmdldExvbmdlc3RGaXQod29yZHMpO1xuXG4gICAgICAgIGlmICh3ID09PSAwKSB7XG4gICAgICAgICAgLy8gU3BlY2lhbCBjYXNlOiB0aGUgZmlyc3Qgd29yZCBpcyBhbHJlYWR5IGxhcmdlciB0aGFuIHRoZSBtYXggd2lkdGguXG4gICAgICAgICAgdmFyIHdvcmQgPSB3b3Jkc1swXTtcblxuICAgICAgICAgIC8vIEJyZWFrIHRoZSB3b3JkIHRvIHRoZSBsYXJnZXN0IHBhcnQgdGhhdCBmaXRzIHRoZSBsaW5lXG4gICAgICAgICAgdmFyIHggPSB0aGlzLmdldExvbmdlc3RGaXRXb3JkKHdvcmQpO1xuICAgICAgICAgIHRoaXMubGluZXMubmV3TGluZSh3b3JkLnNsaWNlKDAsIHgpLCBtb2QpO1xuXG4gICAgICAgICAgLy8gQWRqdXN0IHRoZSB3b3JkLCBzbyB0aGF0IHRoZSByZXN0IHdpbGwgYmUgZG9uZSBuZXh0IGl0ZXJhdGlvblxuICAgICAgICAgIHdvcmRzWzBdID0gd29yZC5zbGljZSh4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBza2lwIGFueSBzcGFjZSB0aGF0IGlzIHJlcGxhY2VkIGJ5IGEgbmV3bGluZVxuICAgICAgICAgIHZhciBuZXdXID0gdztcbiAgICAgICAgICBpZiAod29yZHNbdyAtIDFdID09PSAnICcpIHtcbiAgICAgICAgICAgIHctLTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHdvcmRzW25ld1ddID09PSAnICcpIHtcbiAgICAgICAgICAgIG5ld1crKztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdGV4dCA9IHdvcmRzLnNsaWNlKDAsIHcpLmpvaW4oJycpO1xuXG4gICAgICAgICAgaWYgKHcgPT0gd29yZHMubGVuZ3RoICYmIGFwcGVuZExhc3QpIHtcbiAgICAgICAgICAgIHRoaXMubGluZXMuYXBwZW5kKHRleHQsIG1vZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGluZXMubmV3TGluZSh0ZXh0LCBtb2QpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEFkanVzdCB0aGUgd29yZCwgc28gdGhhdCB0aGUgcmVzdCB3aWxsIGJlIGRvbmUgbmV4dCBpdGVyYXRpb25cbiAgICAgICAgICB3b3JkcyA9IHdvcmRzLnNsaWNlKG5ld1cpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBMYWJlbFNwbGl0dGVyO1xufSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBMYWJlbFNwbGl0dGVyO1xuXG4vKioqLyB9KSxcbi8qIDE0MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2Fzc2lnbiA9IF9fd2VicGFja19yZXF1aXJlX18oNzgpO1xuXG52YXIgX2Fzc2lnbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hc3NpZ24pO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLyoqXG4gKiBDYWxsYmFjayB0byBkZXRlcm1pbmUgdGV4dCBkaW1lbnNpb25zLCB1c2luZyB0aGUgcGFyZW50IGxhYmVsIHNldHRpbmdzLlxuICogQGNhbGxiYWNrIE1lYXN1cmVUZXh0XG4gKiBAcGFyYW0ge3RleHR9IHRleHRcbiAqIEBwYXJhbSB7dGV4dH0gbW9kXG4gKiBAcmV0dXJuIHtPYmplY3R9IHsgd2lkdGgsIHZhbHVlc30gd2lkdGggaW4gcGl4ZWxzIGFuZCBmb250IGF0dHJpYnV0ZXNcbiAqL1xuXG4vKipcbiAqIEhlbHBlciBjbGFzcyBmb3IgTGFiZWwgd2hpY2ggY29sbGVjdHMgcmVzdWx0cyBvZiBzcGxpdHRpbmcgbGFiZWxzIGludG8gbGluZXMgYW5kIGJsb2Nrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgTGFiZWxBY2N1bXVsYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7TWVhc3VyZVRleHR9IG1lYXN1cmVUZXh0XG4gICAqL1xuICBmdW5jdGlvbiBMYWJlbEFjY3VtdWxhdG9yKG1lYXN1cmVUZXh0KSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgTGFiZWxBY2N1bXVsYXRvcik7XG5cbiAgICB0aGlzLm1lYXN1cmVUZXh0ID0gbWVhc3VyZVRleHQ7XG4gICAgdGhpcy5jdXJyZW50ID0gMDtcbiAgICB0aGlzLndpZHRoID0gMDtcbiAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgdGhpcy5saW5lcyA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZCBnaXZlbiB0ZXh0IHRvIHRoZSBnaXZlbiBsaW5lLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gIGwgICAgaW5kZXggb2YgbGluZSB0byBhZGQgdG9cbiAgICogQHBhcmFtIHtzdHJpbmd9ICB0ZXh0IHN0cmluZyB0byBhcHBlbmQgdG8gbGluZVxuICAgKiBAcGFyYW0geydib2xkJ3wnaXRhbCd8J2JvbGRpdGFsJ3wnbW9ubyd8J25vcm1hbCd9IFttb2Q9J25vcm1hbCddXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoTGFiZWxBY2N1bXVsYXRvciwgW3tcbiAgICBrZXk6ICdfYWRkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZChsLCB0ZXh0KSB7XG4gICAgICB2YXIgbW9kID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAnbm9ybWFsJztcblxuICAgICAgaWYgKHRoaXMubGluZXNbbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmxpbmVzW2xdID0ge1xuICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICBibG9ja3M6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIHN0aWxsIG5lZWQgdG8gc2V0IGEgYmxvY2sgZm9yIHVuZGVmaW5lZCBhbmQgZW1wdHkgdGV4dHMsIGhlbmNlIHJldHVybiBhdCB0aGlzIHBvaW50XG4gICAgICAvLyBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHdlIGRvbid0IGtub3cgYXQgdGhpcyBwb2ludCBpZiB3ZSdyZSBhdCB0aGVcbiAgICAgIC8vIHN0YXJ0IG9mIGFuIGVtcHR5IGxpbmUgb3Igbm90LlxuICAgICAgLy8gVG8gY29tcGVuc2F0ZSwgZW1wdHkgYmxvY2tzIGFyZSByZW1vdmVkIGluIGBmaW5hbGl6ZSgpYC5cbiAgICAgIC8vXG4gICAgICAvLyBFbXB0eSBzdHJpbmdzIHNob3VsZCBzdGlsbCBoYXZlIGEgaGVpZ2h0XG4gICAgICB2YXIgdG1wVGV4dCA9IHRleHQ7XG4gICAgICBpZiAodGV4dCA9PT0gdW5kZWZpbmVkIHx8IHRleHQgPT09ICcnKSB0bXBUZXh0ID0gJyAnO1xuXG4gICAgICAvLyBEZXRlcm1pbmUgd2lkdGggYW5kIGdldCB0aGUgZm9udCBwcm9wZXJ0aWVzXG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5tZWFzdXJlVGV4dCh0bXBUZXh0LCBtb2QpO1xuICAgICAgdmFyIGJsb2NrID0gKDAsIF9hc3NpZ24yWydkZWZhdWx0J10pKHt9LCByZXN1bHQudmFsdWVzKTtcbiAgICAgIGJsb2NrLnRleHQgPSB0ZXh0O1xuICAgICAgYmxvY2sud2lkdGggPSByZXN1bHQud2lkdGg7XG4gICAgICBibG9jay5tb2QgPSBtb2Q7XG5cbiAgICAgIGlmICh0ZXh0ID09PSB1bmRlZmluZWQgfHwgdGV4dCA9PT0gJycpIHtcbiAgICAgICAgYmxvY2sud2lkdGggPSAwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxpbmVzW2xdLmJsb2Nrcy5wdXNoKGJsb2NrKTtcblxuICAgICAgLy8gVXBkYXRlIHRoZSBsaW5lIHdpZHRoLiBXZSBuZWVkIHRoaXMgZm9yIGRldGVybWluaW5nIGlmIGEgc3RyaW5nIGdvZXMgb3ZlciBtYXggd2lkdGhcbiAgICAgIHRoaXMubGluZXNbbF0ud2lkdGggKz0gYmxvY2sud2lkdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgd2lkdGggaW4gcGl4ZWxzIG9mIHRoZSBjdXJyZW50IGxpbmUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdjdXJXaWR0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGN1cldpZHRoKCkge1xuICAgICAgdmFyIGxpbmUgPSB0aGlzLmxpbmVzW3RoaXMuY3VycmVudF07XG4gICAgICBpZiAobGluZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gMDtcblxuICAgICAgcmV0dXJuIGxpbmUud2lkdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIHRleHQgaW4gYmxvY2sgdG8gY3VycmVudCBsaW5lXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgICAqIEBwYXJhbSB7J2JvbGQnfCdpdGFsJ3wnYm9sZGl0YWwnfCdtb25vJ3wnbm9ybWFsJ30gW21vZD0nbm9ybWFsJ11cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYXBwZW5kJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kKHRleHQpIHtcbiAgICAgIHZhciBtb2QgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICdub3JtYWwnO1xuXG4gICAgICB0aGlzLl9hZGQodGhpcy5jdXJyZW50LCB0ZXh0LCBtb2QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCB0ZXh0IGluIGJsb2NrIHRvIGN1cnJlbnQgbGluZSBhbmQgc3RhcnQgYSBuZXcgbGluZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICAgKiBAcGFyYW0geydib2xkJ3wnaXRhbCd8J2JvbGRpdGFsJ3wnbW9ubyd8J25vcm1hbCd9IFttb2Q9J25vcm1hbCddXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ25ld0xpbmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXdMaW5lKHRleHQpIHtcbiAgICAgIHZhciBtb2QgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICdub3JtYWwnO1xuXG4gICAgICB0aGlzLl9hZGQodGhpcy5jdXJyZW50LCB0ZXh0LCBtb2QpO1xuICAgICAgdGhpcy5jdXJyZW50Kys7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIGFuZCBzZXQgdGhlIGhlaWdodHMgb2YgYWxsIHRoZSBsaW5lcyBjdXJyZW50bHkgY29udGFpbmVkIGluIHRoaXMgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB3aWR0aCBoYXMgYWxyZWFkeSBiZWVuIHNldC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RldGVybWluZUxpbmVIZWlnaHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGV0ZXJtaW5lTGluZUhlaWdodHMoKSB7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMubGluZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmxpbmVzW2tdO1xuXG4gICAgICAgIC8vIExvb2tpbmcgZm9yIG1heCBoZWlnaHQgb2YgYmxvY2tzIGluIGxpbmVcbiAgICAgICAgdmFyIGhlaWdodCA9IDA7XG5cbiAgICAgICAgaWYgKGxpbmUuYmxvY2tzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBDYW4gaGFwcGVuIGlmIHRleHQgY29udGFpbnMgZS5nLiAnXFxuICdcbiAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IGxpbmUuYmxvY2tzLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgICAgICB2YXIgYmxvY2sgPSBsaW5lLmJsb2Nrc1tsXTtcblxuICAgICAgICAgICAgaWYgKGhlaWdodCA8IGJsb2NrLmhlaWdodCkge1xuICAgICAgICAgICAgICBoZWlnaHQgPSBibG9jay5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGluZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHRoZSBmdWxsIHNpemUgb2YgdGhlIGxhYmVsIHRleHQsIGFzIGRldGVybWluZWQgYnkgY3VycmVudCBsaW5lcyBhbmQgYmxvY2tzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkZXRlcm1pbmVMYWJlbFNpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXRlcm1pbmVMYWJlbFNpemUoKSB7XG4gICAgICB2YXIgd2lkdGggPSAwO1xuICAgICAgdmFyIGhlaWdodCA9IDA7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMubGluZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmxpbmVzW2tdO1xuXG4gICAgICAgIGlmIChsaW5lLndpZHRoID4gd2lkdGgpIHtcbiAgICAgICAgICB3aWR0aCA9IGxpbmUud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaGVpZ2h0ICs9IGxpbmUuaGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIGVtcHR5IGJsb2NrcyBhbmQgZW1wdHkgbGluZXMgd2UgZG9uJ3QgbmVlZFxuICAgICAqXG4gICAgICogVGhpcyBtdXN0IGJlIGRvbmUgYWZ0ZXIgdGhlIHdpZHRoL2hlaWdodCBkZXRlcm1pbmF0aW9uLFxuICAgICAqIHNvIHRoYXQgdGhlc2UgYXJlIHNldCBwcm9wZXJseSBmb3IgcHJvY2Vzc2luZyBoZXJlLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0FycmF5PExpbmU+fSBMaW5lcyB3aXRoIGVtcHR5IGJsb2NrcyAoYW5kIHNvbWUgZW1wdHkgbGluZXMpIHJlbW92ZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZW1vdmVFbXB0eUJsb2NrcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUVtcHR5QmxvY2tzKCkge1xuICAgICAgdmFyIHRtcExpbmVzID0gW107XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMubGluZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmxpbmVzW2tdO1xuXG4gICAgICAgIC8vIE5vdGU6IGFuIGVtcHR5IGxpbmUgaW4gYmV0d2VlbiB0ZXh0IGhhcyB3aWR0aCB6ZXJvIGJ1dCBpcyBzdGlsbCByZWxldmFudCB0byBsYXlvdXQuXG4gICAgICAgIC8vIFNvIHdlIGNhbid0IHVzZSB3aWR0aCBmb3IgdGVzdGluZyBlbXB0eSBsaW5lIGhlcmVcbiAgICAgICAgaWYgKGxpbmUuYmxvY2tzLmxlbmd0aCA9PT0gMCkgY29udGludWU7XG5cbiAgICAgICAgLy8gRGlzY2FyZCBmaW5hbCBlbXB0eSBsaW5lIGFsd2F5c1xuICAgICAgICBpZiAoayA9PT0gdGhpcy5saW5lcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgaWYgKGxpbmUud2lkdGggPT09IDApIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRtcExpbmUgPSB7fTtcbiAgICAgICAgKDAsIF9hc3NpZ24yWydkZWZhdWx0J10pKHRtcExpbmUsIGxpbmUpO1xuICAgICAgICB0bXBMaW5lLmJsb2NrcyA9IFtdO1xuXG4gICAgICAgIHZhciBmaXJzdEVtcHR5QmxvY2sgPSB2b2lkIDA7XG4gICAgICAgIHZhciB0bXBCbG9ja3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBsaW5lLmJsb2Nrcy5sZW5ndGg7IGwrKykge1xuICAgICAgICAgIHZhciBibG9jayA9IGxpbmUuYmxvY2tzW2xdO1xuICAgICAgICAgIGlmIChibG9jay53aWR0aCAhPT0gMCkge1xuICAgICAgICAgICAgdG1wQmxvY2tzLnB1c2goYmxvY2spO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZmlyc3RFbXB0eUJsb2NrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZmlyc3RFbXB0eUJsb2NrID0gYmxvY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlcmUgaXMgKnNvbWUqIHRleHQgcHJlc2VudFxuICAgICAgICBpZiAodG1wQmxvY2tzLmxlbmd0aCA9PT0gMCAmJiBmaXJzdEVtcHR5QmxvY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRtcEJsb2Nrcy5wdXNoKGZpcnN0RW1wdHlCbG9jayk7XG4gICAgICAgIH1cblxuICAgICAgICB0bXBMaW5lLmJsb2NrcyA9IHRtcEJsb2NrcztcblxuICAgICAgICB0bXBMaW5lcy5wdXNoKHRtcExpbmUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdG1wTGluZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBzaXplcyBmb3IgYWxsIGxpbmVzIGFuZCB0aGUgd2hvbGUgdGhpbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7e3dpZHRoOiAobnVtYmVyfCopLCBoZWlnaHQ6IChudW1iZXJ8KiksIGxpbmVzOiBBcnJheX19XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2ZpbmFsaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluYWxpemUoKSB7XG4gICAgICAvL2NvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KHRoaXMubGluZXMsIG51bGwsIDIpKTtcblxuICAgICAgdGhpcy5kZXRlcm1pbmVMaW5lSGVpZ2h0cygpO1xuICAgICAgdGhpcy5kZXRlcm1pbmVMYWJlbFNpemUoKTtcbiAgICAgIHZhciB0bXBMaW5lcyA9IHRoaXMucmVtb3ZlRW1wdHlCbG9ja3MoKTtcblxuICAgICAgLy8gUmV0dXJuIGEgc2ltcGxlIGhhc2ggb2JqZWN0IGZvciBmdXJ0aGVyIHByb2Nlc3NpbmcuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgbGluZXM6IHRtcExpbmVzXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTGFiZWxBY2N1bXVsYXRvcjtcbn0oKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gTGFiZWxBY2N1bXVsYXRvcjtcblxuLyoqKi8gfSksXG4vKiAxNDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuX193ZWJwYWNrX3JlcXVpcmVfXygxNDIpO1xubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpLk9iamVjdC5hc3NpZ247XG5cblxuLyoqKi8gfSksXG4vKiAxNDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gMTkuMS4zLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSlcbnZhciAkZXhwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GLCAnT2JqZWN0JywgeyBhc3NpZ246IF9fd2VicGFja19yZXF1aXJlX18oMTQzKSB9KTtcblxuXG4vKioqLyB9KSxcbi8qIDE0MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxudmFyIGdldEtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcbnZhciBnT1BTID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MCk7XG52YXIgcElFID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG52YXIgdG9PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKTtcbnZhciBJT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OSk7XG52YXIgJGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxubW9kdWxlLmV4cG9ydHMgPSAhJGFzc2lnbiB8fCBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKShmdW5jdGlvbiAoKSB7XG4gIHZhciBBID0ge307XG4gIHZhciBCID0ge307XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgUyA9IFN5bWJvbCgpO1xuICB2YXIgSyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbU10gPSA3O1xuICBLLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7IEJba10gPSBrOyB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW1NdICE9IDcgfHwgT2JqZWN0LmtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IEs7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBUID0gdG9PYmplY3QodGFyZ2V0KTtcbiAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAxO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgdmFyIGlzRW51bSA9IHBJRS5mO1xuICB3aGlsZSAoYUxlbiA+IGluZGV4KSB7XG4gICAgdmFyIFMgPSBJT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgdmFyIGtleXMgPSBnZXRTeW1ib2xzID8gZ2V0S2V5cyhTKS5jb25jYXQoZ2V0U3ltYm9scyhTKSkgOiBnZXRLZXlzKFMpO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaikgaWYgKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpIFRba2V5XSA9IFNba2V5XTtcbiAgfSByZXR1cm4gVDtcbn0gOiAkYXNzaWduO1xuXG5cbi8qKiovIH0pLFxuLyogMTQ0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxudmFyIF9pbmhlcml0czIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cbnZhciBfTm9kZUJhc2UyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5cbnZhciBfTm9kZUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTm9kZUJhc2UyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vKipcbiAqIEEgQm94IE5vZGUvQ2x1c3RlciBzaGFwZS5cbiAqXG4gKiBAZXh0ZW5kcyBOb2RlQmFzZVxuICovXG52YXIgQm94ID0gZnVuY3Rpb24gKF9Ob2RlQmFzZSkge1xuICAoMCwgX2luaGVyaXRzM1snZGVmYXVsdCddKShCb3gsIF9Ob2RlQmFzZSk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBCb3gob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrM1snZGVmYXVsdCddKSh0aGlzLCBCb3gpO1xuXG4gICAgdmFyIF90aGlzID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuM1snZGVmYXVsdCddKSh0aGlzLCAoQm94Ll9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMlsnZGVmYXVsdCddKShCb3gpKS5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSk7XG5cbiAgICBfdGhpcy5fc2V0TWFyZ2lucyhsYWJlbE1vZHVsZSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtib29sZWFufSBbc2VsZWN0ZWRdXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hvdmVyXVxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKEJveCwgW3tcbiAgICBrZXk6ICdyZXNpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoY3R4KSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuc2VsZWN0ZWQ7XG4gICAgICB2YXIgaG92ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRoaXMuaG92ZXI7XG5cbiAgICAgIGlmICh0aGlzLm5lZWRzUmVmcmVzaChzZWxlY3RlZCwgaG92ZXIpKSB7XG4gICAgICAgIHZhciBkaW1lbnNpb25zID0gdGhpcy5nZXREaW1lbnNpb25zRnJvbUxhYmVsKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcblxuICAgICAgICB0aGlzLndpZHRoID0gZGltZW5zaW9ucy53aWR0aCArIHRoaXMubWFyZ2luLnJpZ2h0ICsgdGhpcy5tYXJnaW4ubGVmdDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBkaW1lbnNpb25zLmhlaWdodCArIHRoaXMubWFyZ2luLnRvcCArIHRoaXMubWFyZ2luLmJvdHRvbTtcbiAgICAgICAgdGhpcy5yYWRpdXMgPSB0aGlzLndpZHRoIC8gMjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkcmF3JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICB0aGlzLnJlc2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAvIDI7XG4gICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAvIDI7XG5cbiAgICAgIHRoaXMuaW5pdENvbnRleHRGb3JEcmF3KGN0eCwgdmFsdWVzKTtcbiAgICAgIGN0eC5yb3VuZFJlY3QodGhpcy5sZWZ0LCB0aGlzLnRvcCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHZhbHVlcy5ib3JkZXJSYWRpdXMpO1xuICAgICAgdGhpcy5wZXJmb3JtRmlsbChjdHgsIHZhbHVlcyk7XG5cbiAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdCb3goeCwgeSwgY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgdGhpcy5sYWJlbE1vZHVsZS5kcmF3KGN0eCwgdGhpcy5sZWZ0ICsgdGhpcy50ZXh0U2l6ZS53aWR0aCAvIDIgKyB0aGlzLm1hcmdpbi5sZWZ0LCB0aGlzLnRvcCArIHRoaXMudGV4dFNpemUuaGVpZ2h0IC8gMiArIHRoaXMubWFyZ2luLnRvcCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZUJvdW5kaW5nQm94JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQm91bmRpbmdCb3goeCwgeSwgY3R4LCBzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUJvdW5kaW5nQm94KHgsIHksIGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcblxuICAgICAgdmFyIGJvcmRlclJhZGl1cyA9IHRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMuYm9yZGVyUmFkaXVzOyAvLyBvbmx5IGVmZmVjdGl2ZSBmb3IgYm94XG4gICAgICB0aGlzLl9hZGRCb3VuZGluZ0JveE1hcmdpbihib3JkZXJSYWRpdXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Rpc3RhbmNlVG9Cb3JkZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgIHRoaXMucmVzaXplKGN0eCk7XG4gICAgICB2YXIgYm9yZGVyV2lkdGggPSB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGg7XG5cbiAgICAgIHJldHVybiBNYXRoLm1pbihNYXRoLmFicyh0aGlzLndpZHRoIC8gMiAvIE1hdGguY29zKGFuZ2xlKSksIE1hdGguYWJzKHRoaXMuaGVpZ2h0IC8gMiAvIE1hdGguc2luKGFuZ2xlKSkpICsgYm9yZGVyV2lkdGg7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBCb3g7XG59KF9Ob2RlQmFzZTNbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEJveDtcblxuLyoqKi8gfSksXG4vKiAxNDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuX193ZWJwYWNrX3JlcXVpcmVfXygxNDYpO1xubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpLk9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxuXG4vKioqLyB9KSxcbi8qIDE0NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyAxOS4xLjIuOSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMzApO1xudmFyICRnZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oNjYpO1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDY4KSgnZ2V0UHJvdG90eXBlT2YnLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZihpdCkge1xuICAgIHJldHVybiAkZ2V0UHJvdG90eXBlT2YodG9PYmplY3QoaXQpKTtcbiAgfTtcbn0pO1xuXG5cbi8qKiovIH0pLFxuLyogMTQ3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogX193ZWJwYWNrX3JlcXVpcmVfXygxNDgpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cbi8qKiovIH0pLFxuLyogMTQ4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbl9fd2VicGFja19yZXF1aXJlX18oMTQ5KTtcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KS5PYmplY3Quc2V0UHJvdG90eXBlT2Y7XG5cblxuLyoqKi8gfSksXG4vKiAxNDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gMTkuMS4zLjE5IE9iamVjdC5zZXRQcm90b3R5cGVPZihPLCBwcm90bylcbnZhciAkZXhwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHsgc2V0UHJvdG90eXBlT2Y6IF9fd2VicGFja19yZXF1aXJlX18oMTUwKS5zZXQgfSk7XG5cblxuLyoqKi8gfSksXG4vKiAxNTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcbnZhciBjaGVjayA9IGZ1bmN0aW9uIChPLCBwcm90bykge1xuICBhbk9iamVjdChPKTtcbiAgaWYgKCFpc09iamVjdChwcm90bykgJiYgcHJvdG8gIT09IG51bGwpIHRocm93IFR5cGVFcnJvcihwcm90byArIFwiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGZ1bmN0aW9uICh0ZXN0LCBidWdneSwgc2V0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBzZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxKShGdW5jdGlvbi5jYWxsLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwKS5mKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQsIDIpO1xuICAgICAgICBzZXQodGVzdCwgW10pO1xuICAgICAgICBidWdneSA9ICEodGVzdCBpbnN0YW5jZW9mIEFycmF5KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHsgYnVnZ3kgPSB0cnVlOyB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcbiAgICAgICAgY2hlY2soTywgcHJvdG8pO1xuICAgICAgICBpZiAoYnVnZ3kpIE8uX19wcm90b19fID0gcHJvdG87XG4gICAgICAgIGVsc2Ugc2V0KE8sIHByb3RvKTtcbiAgICAgICAgcmV0dXJuIE87XG4gICAgICB9O1xuICAgIH0oe30sIGZhbHNlKSA6IHVuZGVmaW5lZCksXG4gIGNoZWNrOiBjaGVja1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDE1MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2dldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cbnZhciBfaW5oZXJpdHMyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG52YXIgX0NpcmNsZUltYWdlQmFzZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUzKTtcblxudmFyIF9DaXJjbGVJbWFnZUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2lyY2xlSW1hZ2VCYXNlMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLyoqXG4gKiBBIENpcmNsZSBOb2RlL0NsdXN0ZXIgc2hhcGUuXG4gKlxuICogQGV4dGVuZHMgQ2lyY2xlSW1hZ2VCYXNlXG4gKi9cbnZhciBDaXJjbGUgPSBmdW5jdGlvbiAoX0NpcmNsZUltYWdlQmFzZSkge1xuICAoMCwgX2luaGVyaXRzM1snZGVmYXVsdCddKShDaXJjbGUsIF9DaXJjbGVJbWFnZUJhc2UpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gQ2lyY2xlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgQ2lyY2xlKTtcblxuICAgIHZhciBfdGhpcyA9ICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjNbJ2RlZmF1bHQnXSkodGhpcywgKENpcmNsZS5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjJbJ2RlZmF1bHQnXSkoQ2lyY2xlKSkuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuXG4gICAgX3RoaXMuX3NldE1hcmdpbnMobGFiZWxNb2R1bGUpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NlbGVjdGVkXVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtob3Zlcl1cbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzM1snZGVmYXVsdCddKShDaXJjbGUsIFt7XG4gICAga2V5OiAncmVzaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKGN0eCkge1xuICAgICAgdmFyIHNlbGVjdGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLnNlbGVjdGVkO1xuICAgICAgdmFyIGhvdmVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0aGlzLmhvdmVyO1xuXG4gICAgICBpZiAodGhpcy5uZWVkc1JlZnJlc2goc2VsZWN0ZWQsIGhvdmVyKSkge1xuICAgICAgICB2YXIgZGltZW5zaW9ucyA9IHRoaXMuZ2V0RGltZW5zaW9uc0Zyb21MYWJlbChjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG5cbiAgICAgICAgdmFyIGRpYW1ldGVyID0gTWF0aC5tYXgoZGltZW5zaW9ucy53aWR0aCArIHRoaXMubWFyZ2luLnJpZ2h0ICsgdGhpcy5tYXJnaW4ubGVmdCwgZGltZW5zaW9ucy5oZWlnaHQgKyB0aGlzLm1hcmdpbi50b3AgKyB0aGlzLm1hcmdpbi5ib3R0b20pO1xuXG4gICAgICAgIHRoaXMub3B0aW9ucy5zaXplID0gZGlhbWV0ZXIgLyAyOyAvLyBOT1RFOiB0aGlzIHNpemUgZmllbGQgb25seSBzZXQgaGVyZSwgbm90IGluIEVsbGlwc2UsIERhdGFiYXNlLCBCb3hcbiAgICAgICAgdGhpcy53aWR0aCA9IGRpYW1ldGVyO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGRpYW1ldGVyO1xuICAgICAgICB0aGlzLnJhZGl1cyA9IHRoaXMud2lkdGggLyAyO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RyYXcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHRoaXMucmVzaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIHRoaXMubGVmdCA9IHggLSB0aGlzLndpZHRoIC8gMjtcbiAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0IC8gMjtcblxuICAgICAgdGhpcy5fZHJhd1Jhd0NpcmNsZShjdHgsIHgsIHksIHZhbHVlcyk7XG5cbiAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdCb3goeCwgeSk7XG4gICAgICB0aGlzLmxhYmVsTW9kdWxlLmRyYXcoY3R4LCB0aGlzLmxlZnQgKyB0aGlzLnRleHRTaXplLndpZHRoIC8gMiArIHRoaXMubWFyZ2luLmxlZnQsIHksIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVCb3VuZGluZ0JveCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kaW5nQm94KHgsIHkpIHtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gudG9wID0geSAtIHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0ID0geCAtIHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5yaWdodCA9IHggKyB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0geSArIHRoaXMub3B0aW9ucy5zaXplO1xuICAgIH1cblxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSAtIFVudXNlZFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Rpc3RhbmNlVG9Cb3JkZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHRoaXMucmVzaXplKGN0eCk7XG4gICAgICByZXR1cm4gdGhpcy53aWR0aCAqIDAuNTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENpcmNsZTtcbn0oX0NpcmNsZUltYWdlQmFzZTNbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IENpcmNsZTtcblxuLyoqKi8gfSksXG4vKiAxNTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9nZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxudmFyIF9DaXJjbGVJbWFnZUJhc2UyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Myk7XG5cbnZhciBfQ2lyY2xlSW1hZ2VCYXNlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NpcmNsZUltYWdlQmFzZTIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbi8qKlxuICogQSBDaXJjdWxhckltYWdlIE5vZGUvQ2x1c3RlciBzaGFwZS5cbiAqXG4gKiBAZXh0ZW5kcyBDaXJjbGVJbWFnZUJhc2VcbiAqL1xudmFyIENpcmN1bGFySW1hZ2UgPSBmdW5jdGlvbiAoX0NpcmNsZUltYWdlQmFzZSkge1xuICAoMCwgX2luaGVyaXRzM1snZGVmYXVsdCddKShDaXJjdWxhckltYWdlLCBfQ2lyY2xlSW1hZ2VCYXNlKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICogQHBhcmFtIHtJbWFnZX0gaW1hZ2VPYmpcbiAgICogQHBhcmFtIHtJbWFnZX0gaW1hZ2VPYmpBbHRcbiAgICovXG4gIGZ1bmN0aW9uIENpcmN1bGFySW1hZ2Uob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUsIGltYWdlT2JqLCBpbWFnZU9iakFsdCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIENpcmN1bGFySW1hZ2UpO1xuXG4gICAgdmFyIF90aGlzID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuM1snZGVmYXVsdCddKSh0aGlzLCAoQ2lyY3VsYXJJbWFnZS5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjJbJ2RlZmF1bHQnXSkoQ2lyY3VsYXJJbWFnZSkpLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpKTtcblxuICAgIF90aGlzLnNldEltYWdlcyhpbWFnZU9iaiwgaW1hZ2VPYmpBbHQpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NlbGVjdGVkXVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtob3Zlcl1cbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzM1snZGVmYXVsdCddKShDaXJjdWxhckltYWdlLCBbe1xuICAgIGtleTogJ3Jlc2l6ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShjdHgpIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5zZWxlY3RlZDtcbiAgICAgIHZhciBob3ZlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdGhpcy5ob3ZlcjtcblxuICAgICAgdmFyIGltYWdlQWJzZW50ID0gdGhpcy5pbWFnZU9iai5zcmMgPT09IHVuZGVmaW5lZCB8fCB0aGlzLmltYWdlT2JqLndpZHRoID09PSB1bmRlZmluZWQgfHwgdGhpcy5pbWFnZU9iai5oZWlnaHQgPT09IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGltYWdlQWJzZW50KSB7XG4gICAgICAgIHZhciBkaWFtZXRlciA9IHRoaXMub3B0aW9ucy5zaXplICogMjtcbiAgICAgICAgdGhpcy53aWR0aCA9IGRpYW1ldGVyO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGRpYW1ldGVyO1xuICAgICAgICB0aGlzLnJhZGl1cyA9IDAuNSAqIHRoaXMud2lkdGg7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQXQgdGhpcyBwb2ludCwgYW4gaW1hZ2UgaXMgcHJlc2VudCwgaS5lLiB0aGlzLmltYWdlT2JqIGlzIHZhbGlkLlxuICAgICAgaWYgKHRoaXMubmVlZHNSZWZyZXNoKHNlbGVjdGVkLCBob3ZlcikpIHtcbiAgICAgICAgdGhpcy5fcmVzaXplSW1hZ2UoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkcmF3JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICB0aGlzLnN3aXRjaEltYWdlcyhzZWxlY3RlZCk7XG4gICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggLyAyO1xuICAgICAgdGhpcy50b3AgPSB5IC0gdGhpcy5oZWlnaHQgLyAyO1xuXG4gICAgICAvLyBkcmF3IHRoZSBiYWNrZ3JvdW5kIGNpcmNsZS4gSU1QT1JUQU5UOiB0aGUgc3Ryb2tlIGluIHRoaXMgbWV0aG9kIGlzIHVzZWQgYnkgdGhlIGNsaXAgbWV0aG9kIGJlbG93LlxuICAgICAgdGhpcy5fZHJhd1Jhd0NpcmNsZShjdHgsIHgsIHksIHZhbHVlcyk7XG5cbiAgICAgIC8vIG5vdyB3ZSBkcmF3IGluIHRoZSBjaXJjbGUsIHdlIHNhdmUgc28gd2UgY2FuIHJldmVydCB0aGUgY2xpcCBvcGVyYXRpb24gYWZ0ZXIgZHJhd2luZy5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAvLyBjbGlwIGlzIHVzZWQgdG8gdXNlIHRoZSBzdHJva2UgaW4gZHJhd1Jhd0NpcmNsZSBhcyBhbiBhcmVhIHRoYXQgd2UgY2FuIGRyYXcgaW4uXG4gICAgICBjdHguY2xpcCgpO1xuICAgICAgLy8gZHJhdyB0aGUgaW1hZ2VcbiAgICAgIHRoaXMuX2RyYXdJbWFnZUF0UG9zaXRpb24oY3R4LCB2YWx1ZXMpO1xuICAgICAgLy8gcmVzdG9yZSBzbyB3ZSBjYW4gYWdhaW4gZHJhdyBvbiB0aGUgZnVsbCBjYW52YXNcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgIHRoaXMuX2RyYXdJbWFnZUxhYmVsKGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyKTtcblxuICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ0JveCh4LCB5KTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBjb21wYXJlIHdpdGggQ2lyY2xlLnVwZGF0ZUJvdW5kaW5nQm94KCksIGNvbnNvbGlkYXRlPyBNb3JlIHN0dWZmIGlzIGhhcHBlbmluZyBoZXJlXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVCb3VuZGluZ0JveCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kaW5nQm94KHgsIHkpIHtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gudG9wID0geSAtIHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0ID0geCAtIHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5yaWdodCA9IHggKyB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0geSArIHRoaXMub3B0aW9ucy5zaXplO1xuXG4gICAgICAvLyBUT0RPOiBjb21wYXJlIHdpdGggSW1hZ2UudXBkYXRlQm91bmRpbmdCb3goKSwgY29uc29saWRhdGU/XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSBNYXRoLm1pbih0aGlzLmJvdW5kaW5nQm94LmxlZnQsIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5sZWZ0KTtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSBNYXRoLm1heCh0aGlzLmJvdW5kaW5nQm94LnJpZ2h0LCB0aGlzLmxhYmVsTW9kdWxlLnNpemUubGVmdCArIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS53aWR0aCk7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSA9IE1hdGgubWF4KHRoaXMuYm91bmRpbmdCb3guYm90dG9tLCB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSArIHRoaXMubGFiZWxPZmZzZXQpO1xuICAgIH1cblxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSAtIFVudXNlZFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Rpc3RhbmNlVG9Cb3JkZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHRoaXMucmVzaXplKGN0eCk7XG4gICAgICByZXR1cm4gdGhpcy53aWR0aCAqIDAuNTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENpcmN1bGFySW1hZ2U7XG59KF9DaXJjbGVJbWFnZUJhc2UzWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBDaXJjdWxhckltYWdlO1xuXG4vKioqLyB9KSxcbi8qIDE1MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2dldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cbnZhciBfaW5oZXJpdHMyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG52YXIgX05vZGVCYXNlMiA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xuXG52YXIgX05vZGVCYXNlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX05vZGVCYXNlMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLyoqXG4gKiBBIERhdGFiYXNlIE5vZGUvQ2x1c3RlciBzaGFwZS5cbiAqXG4gKiBAZXh0ZW5kcyBOb2RlQmFzZVxuICovXG52YXIgRGF0YWJhc2UgPSBmdW5jdGlvbiAoX05vZGVCYXNlKSB7XG4gICgwLCBfaW5oZXJpdHMzWydkZWZhdWx0J10pKERhdGFiYXNlLCBfTm9kZUJhc2UpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gRGF0YWJhc2Uob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrM1snZGVmYXVsdCddKSh0aGlzLCBEYXRhYmFzZSk7XG5cbiAgICB2YXIgX3RoaXMgPSAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zWydkZWZhdWx0J10pKHRoaXMsIChEYXRhYmFzZS5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjJbJ2RlZmF1bHQnXSkoRGF0YWJhc2UpKS5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSk7XG5cbiAgICBfdGhpcy5fc2V0TWFyZ2lucyhsYWJlbE1vZHVsZSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoRGF0YWJhc2UsIFt7XG4gICAga2V5OiAncmVzaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICBpZiAodGhpcy5uZWVkc1JlZnJlc2goc2VsZWN0ZWQsIGhvdmVyKSkge1xuICAgICAgICB2YXIgZGltZW5zaW9ucyA9IHRoaXMuZ2V0RGltZW5zaW9uc0Zyb21MYWJlbChjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICAgIHZhciBzaXplID0gZGltZW5zaW9ucy53aWR0aCArIHRoaXMubWFyZ2luLnJpZ2h0ICsgdGhpcy5tYXJnaW4ubGVmdDtcblxuICAgICAgICB0aGlzLndpZHRoID0gc2l6ZTtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBzaXplO1xuICAgICAgICB0aGlzLnJhZGl1cyA9IHRoaXMud2lkdGggLyAyO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RyYXcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHRoaXMucmVzaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIHRoaXMubGVmdCA9IHggLSB0aGlzLndpZHRoIC8gMjtcbiAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0IC8gMjtcblxuICAgICAgdGhpcy5pbml0Q29udGV4dEZvckRyYXcoY3R4LCB2YWx1ZXMpO1xuICAgICAgY3R4LmRhdGFiYXNlKHggLSB0aGlzLndpZHRoIC8gMiwgeSAtIHRoaXMuaGVpZ2h0IC8gMiwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgdGhpcy5wZXJmb3JtRmlsbChjdHgsIHZhbHVlcyk7XG5cbiAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdCb3goeCwgeSwgY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgdGhpcy5sYWJlbE1vZHVsZS5kcmF3KGN0eCwgdGhpcy5sZWZ0ICsgdGhpcy50ZXh0U2l6ZS53aWR0aCAvIDIgKyB0aGlzLm1hcmdpbi5sZWZ0LCB0aGlzLnRvcCArIHRoaXMudGV4dFNpemUuaGVpZ2h0IC8gMiArIHRoaXMubWFyZ2luLnRvcCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZGlzdGFuY2VUb0JvcmRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBEYXRhYmFzZTtcbn0oX05vZGVCYXNlM1snZGVmYXVsdCddKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gRGF0YWJhc2U7XG5cbi8qKiovIH0pLFxuLyogMTU0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxudmFyIF9pbmhlcml0czIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cbnZhciBfU2hhcGVCYXNlMiA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xuXG52YXIgX1NoYXBlQmFzZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TaGFwZUJhc2UyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vKipcbiAqIEEgRGlhbW9uZCBOb2RlL0NsdXN0ZXIgc2hhcGUuXG4gKlxuICogQGV4dGVuZHMgU2hhcGVCYXNlXG4gKi9cbnZhciBEaWFtb25kID0gZnVuY3Rpb24gKF9TaGFwZUJhc2UpIHtcbiAgKDAsIF9pbmhlcml0czNbJ2RlZmF1bHQnXSkoRGlhbW9uZCwgX1NoYXBlQmFzZSk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBEaWFtb25kKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgRGlhbW9uZCk7XG4gICAgcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjNbJ2RlZmF1bHQnXSkodGhpcywgKERpYW1vbmQuX19wcm90b19fIHx8ICgwLCBfZ2V0UHJvdG90eXBlT2YyWydkZWZhdWx0J10pKERpYW1vbmQpKS5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzM1snZGVmYXVsdCddKShEaWFtb25kLCBbe1xuICAgIGtleTogJ2RyYXcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHRoaXMuX2RyYXdTaGFwZShjdHgsICdkaWFtb25kJywgNCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Rpc3RhbmNlVG9Cb3JkZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRGlhbW9uZDtcbn0oX1NoYXBlQmFzZTNbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IERpYW1vbmQ7XG5cbi8qKiovIH0pLFxuLyogMTU1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxudmFyIF9pbmhlcml0czIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cbnZhciBfU2hhcGVCYXNlMiA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xuXG52YXIgX1NoYXBlQmFzZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TaGFwZUJhc2UyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vKipcbiAqIEEgRG90IE5vZGUvQ2x1c3RlciBzaGFwZS5cbiAqXG4gKiBAZXh0ZW5kcyBTaGFwZUJhc2VcbiAqL1xudmFyIERvdCA9IGZ1bmN0aW9uIChfU2hhcGVCYXNlKSB7XG4gICgwLCBfaW5oZXJpdHMzWydkZWZhdWx0J10pKERvdCwgX1NoYXBlQmFzZSk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBEb3Qob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrM1snZGVmYXVsdCddKSh0aGlzLCBEb3QpO1xuICAgIHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zWydkZWZhdWx0J10pKHRoaXMsIChEb3QuX19wcm90b19fIHx8ICgwLCBfZ2V0UHJvdG90eXBlT2YyWydkZWZhdWx0J10pKERvdCkpLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKERvdCwgW3tcbiAgICBrZXk6ICdkcmF3JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICB0aGlzLl9kcmF3U2hhcGUoY3R4LCAnY2lyY2xlJywgMiwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpO1xuICAgIH1cblxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Rpc3RhbmNlVG9Cb3JkZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHRoaXMucmVzaXplKGN0eCk7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnNpemU7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBEb3Q7XG59KF9TaGFwZUJhc2UzWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBEb3Q7XG5cbi8qKiovIH0pLFxuLyogMTU2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxudmFyIF9pbmhlcml0czIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cbnZhciBfTm9kZUJhc2UyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5cbnZhciBfTm9kZUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTm9kZUJhc2UyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vKipcbiAqIEFtIEVsbGlwc2UgTm9kZS9DbHVzdGVyIHNoYXBlLlxuICpcbiAqIEBleHRlbmRzIE5vZGVCYXNlXG4gKi9cbnZhciBFbGxpcHNlID0gZnVuY3Rpb24gKF9Ob2RlQmFzZSkge1xuICAoMCwgX2luaGVyaXRzM1snZGVmYXVsdCddKShFbGxpcHNlLCBfTm9kZUJhc2UpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gRWxsaXBzZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIEVsbGlwc2UpO1xuICAgIHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zWydkZWZhdWx0J10pKHRoaXMsIChFbGxpcHNlLl9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMlsnZGVmYXVsdCddKShFbGxpcHNlKSkuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtib29sZWFufSBbc2VsZWN0ZWRdXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hvdmVyXVxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKEVsbGlwc2UsIFt7XG4gICAga2V5OiAncmVzaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKGN0eCkge1xuICAgICAgdmFyIHNlbGVjdGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLnNlbGVjdGVkO1xuICAgICAgdmFyIGhvdmVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0aGlzLmhvdmVyO1xuXG4gICAgICBpZiAodGhpcy5uZWVkc1JlZnJlc2goc2VsZWN0ZWQsIGhvdmVyKSkge1xuICAgICAgICB2YXIgZGltZW5zaW9ucyA9IHRoaXMuZ2V0RGltZW5zaW9uc0Zyb21MYWJlbChjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG5cbiAgICAgICAgdGhpcy5oZWlnaHQgPSBkaW1lbnNpb25zLmhlaWdodCAqIDI7XG4gICAgICAgIHRoaXMud2lkdGggPSBkaW1lbnNpb25zLndpZHRoICsgZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgICAgIHRoaXMucmFkaXVzID0gMC41ICogdGhpcy53aWR0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkcmF3JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICB0aGlzLnJlc2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAqIDAuNTtcbiAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0ICogMC41O1xuXG4gICAgICB0aGlzLmluaXRDb250ZXh0Rm9yRHJhdyhjdHgsIHZhbHVlcyk7XG4gICAgICBjdHguZWxsaXBzZV92aXModGhpcy5sZWZ0LCB0aGlzLnRvcCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgdGhpcy5wZXJmb3JtRmlsbChjdHgsIHZhbHVlcyk7XG5cbiAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdCb3goeCwgeSwgY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgdGhpcy5sYWJlbE1vZHVsZS5kcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkaXN0YW5jZVRvQm9yZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICB0aGlzLnJlc2l6ZShjdHgpO1xuICAgICAgdmFyIGEgPSB0aGlzLndpZHRoICogMC41O1xuICAgICAgdmFyIGIgPSB0aGlzLmhlaWdodCAqIDAuNTtcbiAgICAgIHZhciB3ID0gTWF0aC5zaW4oYW5nbGUpICogYTtcbiAgICAgIHZhciBoID0gTWF0aC5jb3MoYW5nbGUpICogYjtcbiAgICAgIHJldHVybiBhICogYiAvIE1hdGguc3FydCh3ICogdyArIGggKiBoKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEVsbGlwc2U7XG59KF9Ob2RlQmFzZTNbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEVsbGlwc2U7XG5cbi8qKiovIH0pLFxuLyogMTU3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxudmFyIF9pbmhlcml0czIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cbnZhciBfTm9kZUJhc2UyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5cbnZhciBfTm9kZUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTm9kZUJhc2UyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vKipcbiAqIEFuIGljb24gcmVwbGFjZW1lbnQgZm9yIHRoZSBkZWZhdWx0IE5vZGUgc2hhcGUuXG4gKlxuICogQGV4dGVuZHMgTm9kZUJhc2VcbiAqL1xudmFyIEljb24gPSBmdW5jdGlvbiAoX05vZGVCYXNlKSB7XG4gICgwLCBfaW5oZXJpdHMzWydkZWZhdWx0J10pKEljb24sIF9Ob2RlQmFzZSk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBJY29uKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgSWNvbik7XG5cbiAgICB2YXIgX3RoaXMgPSAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zWydkZWZhdWx0J10pKHRoaXMsIChJY29uLl9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMlsnZGVmYXVsdCddKShJY29uKSkuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuXG4gICAgX3RoaXMuX3NldE1hcmdpbnMobGFiZWxNb2R1bGUpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IC0gVW51c2VkLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzZWxlY3RlZF1cbiAgICogQHBhcmFtIHtib29sZWFufSBbaG92ZXJdXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoSWNvbiwgW3tcbiAgICBrZXk6ICdyZXNpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgIGlmICh0aGlzLm5lZWRzUmVmcmVzaChzZWxlY3RlZCwgaG92ZXIpKSB7XG4gICAgICAgIHRoaXMuaWNvblNpemUgPSB7XG4gICAgICAgICAgd2lkdGg6IE51bWJlcih0aGlzLm9wdGlvbnMuaWNvbi5zaXplKSxcbiAgICAgICAgICBoZWlnaHQ6IE51bWJlcih0aGlzLm9wdGlvbnMuaWNvbi5zaXplKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5pY29uU2l6ZS53aWR0aCArIHRoaXMubWFyZ2luLnJpZ2h0ICsgdGhpcy5tYXJnaW4ubGVmdDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmljb25TaXplLmhlaWdodCArIHRoaXMubWFyZ2luLnRvcCArIHRoaXMubWFyZ2luLmJvdHRvbTtcbiAgICAgICAgdGhpcy5yYWRpdXMgPSAwLjUgKiB0aGlzLndpZHRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RyYXcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHRoaXMucmVzaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIHRoaXMub3B0aW9ucy5pY29uLnNpemUgPSB0aGlzLm9wdGlvbnMuaWNvbi5zaXplIHx8IDUwO1xuXG4gICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAvIDI7XG4gICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICB0aGlzLl9pY29uKGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxhYmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGljb25UZXh0U3BhY2luZyA9IDU7XG4gICAgICAgIHRoaXMubGFiZWxNb2R1bGUuZHJhdyhjdHgsIHRoaXMubGVmdCArIHRoaXMuaWNvblNpemUud2lkdGggLyAyICsgdGhpcy5tYXJnaW4ubGVmdCwgeSArIHRoaXMuaGVpZ2h0IC8gMiArIGljb25UZXh0U3BhY2luZywgc2VsZWN0ZWQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nQm94KHgsIHkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVCb3VuZGluZ0JveCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kaW5nQm94KHgsIHkpIHtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gudG9wID0geSAtIHRoaXMub3B0aW9ucy5pY29uLnNpemUgKiAwLjU7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSB4IC0gdGhpcy5vcHRpb25zLmljb24uc2l6ZSAqIDAuNTtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSB4ICsgdGhpcy5vcHRpb25zLmljb24uc2l6ZSAqIDAuNTtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0geSArIHRoaXMub3B0aW9ucy5pY29uLnNpemUgKiAwLjU7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubGFiZWwgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmxhYmVsTW9kdWxlLnNpemUud2lkdGggPiAwKSB7XG4gICAgICAgIHZhciBpY29uVGV4dFNwYWNpbmcgPSA1O1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSBNYXRoLm1pbih0aGlzLmJvdW5kaW5nQm94LmxlZnQsIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5sZWZ0KTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5yaWdodCA9IE1hdGgubWF4KHRoaXMuYm91bmRpbmdCb3gucmlnaHQsIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5sZWZ0ICsgdGhpcy5sYWJlbE1vZHVsZS5zaXplLndpZHRoKTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gPSBNYXRoLm1heCh0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSwgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gKyB0aGlzLmxhYmVsTW9kdWxlLnNpemUuaGVpZ2h0ICsgaWNvblRleHRTcGFjaW5nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyIC0gVW51c2VkXG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfaWNvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pY29uKGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHZhciBpY29uU2l6ZSA9IE51bWJlcih0aGlzLm9wdGlvbnMuaWNvbi5zaXplKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5pY29uLmNvZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjdHguZm9udCA9IChzZWxlY3RlZCA/ICdib2xkICcgOiAnJykgKyBpY29uU2l6ZSArICdweCAnICsgdGhpcy5vcHRpb25zLmljb24uZmFjZTtcblxuICAgICAgICAvLyBkcmF3IGljb25cbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMub3B0aW9ucy5pY29uLmNvbG9yIHx8ICdibGFjayc7XG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXG4gICAgICAgIC8vIGRyYXcgc2hhZG93IGlmIGVuYWJsZWRcbiAgICAgICAgdGhpcy5lbmFibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuICAgICAgICBjdHguZmlsbFRleHQodGhpcy5vcHRpb25zLmljb24uY29kZSwgeCwgeSk7XG5cbiAgICAgICAgLy8gZGlzYWJsZSBzaGFkb3dzIGZvciBvdGhlciBlbGVtZW50cy5cbiAgICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1doZW4gdXNpbmcgdGhlIGljb24gc2hhcGUsIHlvdSBuZWVkIHRvIGRlZmluZSB0aGUgY29kZSBpbiB0aGUgaWNvbiBvcHRpb25zIG9iamVjdC4gVGhpcyBjYW4gYmUgZG9uZSBwZXIgbm9kZSBvciBnbG9iYWxseS4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkaXN0YW5jZVRvQm9yZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEljb247XG59KF9Ob2RlQmFzZTNbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEljb247XG5cbi8qKiovIH0pLFxuLyogMTU4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxudmFyIF9pbmhlcml0czIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cbnZhciBfQ2lyY2xlSW1hZ2VCYXNlMiA9IF9fd2VicGFja19yZXF1aXJlX18oNTMpO1xuXG52YXIgX0NpcmNsZUltYWdlQmFzZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DaXJjbGVJbWFnZUJhc2UyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vKipcbiAqIEFuIGltYWdlLWJhc2VkIHJlcGxhY2VtZW50IGZvciB0aGUgZGVmYXVsdCBOb2RlIHNoYXBlLlxuICpcbiAqIEBleHRlbmRzIENpcmNsZUltYWdlQmFzZVxuICovXG52YXIgSW1hZ2UgPSBmdW5jdGlvbiAoX0NpcmNsZUltYWdlQmFzZSkge1xuICAoMCwgX2luaGVyaXRzM1snZGVmYXVsdCddKShJbWFnZSwgX0NpcmNsZUltYWdlQmFzZSk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqIEBwYXJhbSB7SW1hZ2V9IGltYWdlT2JqXG4gICAqIEBwYXJhbSB7SW1hZ2V9IGltYWdlT2JqQWx0XG4gICAqL1xuICBmdW5jdGlvbiBJbWFnZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSwgaW1hZ2VPYmosIGltYWdlT2JqQWx0KSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgSW1hZ2UpO1xuXG4gICAgdmFyIF90aGlzID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuM1snZGVmYXVsdCddKSh0aGlzLCAoSW1hZ2UuX19wcm90b19fIHx8ICgwLCBfZ2V0UHJvdG90eXBlT2YyWydkZWZhdWx0J10pKEltYWdlKSkuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuXG4gICAgX3RoaXMuc2V0SW1hZ2VzKGltYWdlT2JqLCBpbWFnZU9iakFsdCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggLSBVbnVzZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NlbGVjdGVkXVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtob3Zlcl1cbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzM1snZGVmYXVsdCddKShJbWFnZSwgW3tcbiAgICBrZXk6ICdyZXNpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoY3R4KSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuc2VsZWN0ZWQ7XG4gICAgICB2YXIgaG92ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRoaXMuaG92ZXI7XG5cbiAgICAgIHZhciBpbWFnZUFic2VudCA9IHRoaXMuaW1hZ2VPYmouc3JjID09PSB1bmRlZmluZWQgfHwgdGhpcy5pbWFnZU9iai53aWR0aCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuaW1hZ2VPYmouaGVpZ2h0ID09PSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChpbWFnZUFic2VudCkge1xuICAgICAgICB2YXIgc2lkZSA9IHRoaXMub3B0aW9ucy5zaXplICogMjtcbiAgICAgICAgdGhpcy53aWR0aCA9IHNpZGU7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gc2lkZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5uZWVkc1JlZnJlc2goc2VsZWN0ZWQsIGhvdmVyKSkge1xuICAgICAgICB0aGlzLl9yZXNpemVJbWFnZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RyYXcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHRoaXMuc3dpdGNoSW1hZ2VzKHNlbGVjdGVkKTtcbiAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAvIDI7XG4gICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAvIDI7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLnVzZUJvcmRlcldpdGhJbWFnZSA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgbmV1dHJhbGJvcmRlcldpZHRoID0gdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoO1xuICAgICAgICB2YXIgc2VsZWN0aW9uTGluZVdpZHRoID0gdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoU2VsZWN0ZWQgfHwgMiAqIHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgICAgICAgdmFyIGJvcmRlcldpZHRoID0gKHNlbGVjdGVkID8gc2VsZWN0aW9uTGluZVdpZHRoIDogbmV1dHJhbGJvcmRlcldpZHRoKSAvIHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gTWF0aC5taW4odGhpcy53aWR0aCwgYm9yZGVyV2lkdGgpO1xuXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgICAvLyBzZXR1cCB0aGUgbGluZSBwcm9wZXJ0aWVzLlxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzZWxlY3RlZCA/IHRoaXMub3B0aW9ucy5jb2xvci5oaWdobGlnaHQuYm9yZGVyIDogaG92ZXIgPyB0aGlzLm9wdGlvbnMuY29sb3IuaG92ZXIuYm9yZGVyIDogdGhpcy5vcHRpb25zLmNvbG9yLmJvcmRlcjtcblxuICAgICAgICAvLyBzZXQgYSBmaWxsc3R5bGVcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHNlbGVjdGVkID8gdGhpcy5vcHRpb25zLmNvbG9yLmhpZ2hsaWdodC5iYWNrZ3JvdW5kIDogaG92ZXIgPyB0aGlzLm9wdGlvbnMuY29sb3IuaG92ZXIuYmFja2dyb3VuZCA6IHRoaXMub3B0aW9ucy5jb2xvci5iYWNrZ3JvdW5kO1xuXG4gICAgICAgIC8vIGRyYXcgYSByZWN0YW5nbGUgdG8gZm9ybSB0aGUgYm9yZGVyIGFyb3VuZC4gVGhpcyByZWN0YW5nbGUgaXMgZmlsbGVkIHNvIHRoZSBvcGFjaXR5IG9mIGEgcGljdHVyZSAoaW4gZnV0dXJlIHZpcyByZWxlYXNlcz8pIGNhbiBiZSB1c2VkIHRvIHRpbnQgdGhlIGltYWdlXG4gICAgICAgIGN0eC5yZWN0KHRoaXMubGVmdCAtIDAuNSAqIGN0eC5saW5lV2lkdGgsIHRoaXMudG9wIC0gMC41ICogY3R4LmxpbmVXaWR0aCwgdGhpcy53aWR0aCArIGN0eC5saW5lV2lkdGgsIHRoaXMuaGVpZ2h0ICsgY3R4LmxpbmVXaWR0aCk7XG4gICAgICAgIGN0eC5maWxsKCk7XG5cbiAgICAgICAgdGhpcy5wZXJmb3JtU3Ryb2tlKGN0eCwgdmFsdWVzKTtcblxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2RyYXdJbWFnZUF0UG9zaXRpb24oY3R4LCB2YWx1ZXMpO1xuXG4gICAgICB0aGlzLl9kcmF3SW1hZ2VMYWJlbChjdHgsIHgsIHksIHNlbGVjdGVkLCBob3Zlcik7XG5cbiAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdCb3goeCwgeSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZUJvdW5kaW5nQm94JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQm91bmRpbmdCb3goeCwgeSkge1xuICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZUJvdW5kaW5nQm94KHgsIHkpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxhYmVsICE9PSB1bmRlZmluZWQgJiYgdGhpcy5sYWJlbE1vZHVsZS5zaXplLndpZHRoID4gMCkge1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSBNYXRoLm1pbih0aGlzLmJvdW5kaW5nQm94LmxlZnQsIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5sZWZ0KTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5yaWdodCA9IE1hdGgubWF4KHRoaXMuYm91bmRpbmdCb3gucmlnaHQsIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5sZWZ0ICsgdGhpcy5sYWJlbE1vZHVsZS5zaXplLndpZHRoKTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gPSBNYXRoLm1heCh0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSwgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gKyB0aGlzLmxhYmVsT2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkaXN0YW5jZVRvQm9yZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEltYWdlO1xufShfQ2lyY2xlSW1hZ2VCYXNlM1snZGVmYXVsdCddKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gSW1hZ2U7XG5cbi8qKiovIH0pLFxuLyogMTU5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxudmFyIF9pbmhlcml0czIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cbnZhciBfU2hhcGVCYXNlMiA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xuXG52YXIgX1NoYXBlQmFzZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TaGFwZUJhc2UyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vKipcbiAqIEEgU3F1YXJlIE5vZGUvQ2x1c3RlciBzaGFwZS5cbiAqXG4gKiBAZXh0ZW5kcyBTaGFwZUJhc2VcbiAqL1xudmFyIFNxdWFyZSA9IGZ1bmN0aW9uIChfU2hhcGVCYXNlKSB7XG4gICgwLCBfaW5oZXJpdHMzWydkZWZhdWx0J10pKFNxdWFyZSwgX1NoYXBlQmFzZSk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBTcXVhcmUob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrM1snZGVmYXVsdCddKSh0aGlzLCBTcXVhcmUpO1xuICAgIHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zWydkZWZhdWx0J10pKHRoaXMsIChTcXVhcmUuX19wcm90b19fIHx8ICgwLCBfZ2V0UHJvdG90eXBlT2YyWydkZWZhdWx0J10pKFNxdWFyZSkpLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKFNxdWFyZSwgW3tcbiAgICBrZXk6ICdkcmF3JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICB0aGlzLl9kcmF3U2hhcGUoY3R4LCAnc3F1YXJlJywgMiwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Rpc3RhbmNlVG9Cb3JkZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gU3F1YXJlO1xufShfU2hhcGVCYXNlM1snZGVmYXVsdCddKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gU3F1YXJlO1xuXG4vKioqLyB9KSxcbi8qIDE2MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2dldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cbnZhciBfaW5oZXJpdHMyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG52YXIgX1NoYXBlQmFzZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcblxudmFyIF9TaGFwZUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2hhcGVCYXNlMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLyoqXG4gKiBBIEhleGFnb24gTm9kZS9DbHVzdGVyIHNoYXBlLlxuICpcbiAqIEBleHRlbmRzIFNoYXBlQmFzZVxuICovXG52YXIgSGV4YWdvbiA9IGZ1bmN0aW9uIChfU2hhcGVCYXNlKSB7XG4gICgwLCBfaW5oZXJpdHMzWydkZWZhdWx0J10pKEhleGFnb24sIF9TaGFwZUJhc2UpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gSGV4YWdvbihvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIEhleGFnb24pO1xuICAgIHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zWydkZWZhdWx0J10pKHRoaXMsIChIZXhhZ29uLl9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMlsnZGVmYXVsdCddKShIZXhhZ29uKSkuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoSGV4YWdvbiwgW3tcbiAgICBrZXk6ICdkcmF3JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICB0aGlzLl9kcmF3U2hhcGUoY3R4LCAnaGV4YWdvbicsIDQsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkaXN0YW5jZVRvQm9yZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEhleGFnb247XG59KF9TaGFwZUJhc2UzWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBIZXhhZ29uO1xuXG4vKioqLyB9KSxcbi8qIDE2MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2dldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cbnZhciBfaW5oZXJpdHMyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG52YXIgX1NoYXBlQmFzZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcblxudmFyIF9TaGFwZUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2hhcGVCYXNlMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLyoqXG4gKiBBIFN0YXIgTm9kZS9DbHVzdGVyIHNoYXBlLlxuICpcbiAqIEBleHRlbmRzIFNoYXBlQmFzZVxuICovXG52YXIgU3RhciA9IGZ1bmN0aW9uIChfU2hhcGVCYXNlKSB7XG4gICgwLCBfaW5oZXJpdHMzWydkZWZhdWx0J10pKFN0YXIsIF9TaGFwZUJhc2UpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gU3RhcihvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIFN0YXIpO1xuICAgIHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zWydkZWZhdWx0J10pKHRoaXMsIChTdGFyLl9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMlsnZGVmYXVsdCddKShTdGFyKSkuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoU3RhciwgW3tcbiAgICBrZXk6ICdkcmF3JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICB0aGlzLl9kcmF3U2hhcGUoY3R4LCAnc3RhcicsIDQsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkaXN0YW5jZVRvQm9yZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFN0YXI7XG59KF9TaGFwZUJhc2UzWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBTdGFyO1xuXG4vKioqLyB9KSxcbi8qIDE2MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2dldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cbnZhciBfaW5oZXJpdHMyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG52YXIgX05vZGVCYXNlMiA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xuXG52YXIgX05vZGVCYXNlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX05vZGVCYXNlMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLyoqXG4gKiBBIHRleHQtYmFzZWQgcmVwbGFjZW1lbnQgZm9yIHRoZSBkZWZhdWx0IE5vZGUgc2hhcGUuXG4gKlxuICogQGV4dGVuZHMgTm9kZUJhc2VcbiAqL1xudmFyIFRleHQgPSBmdW5jdGlvbiAoX05vZGVCYXNlKSB7XG4gICgwLCBfaW5oZXJpdHMzWydkZWZhdWx0J10pKFRleHQsIF9Ob2RlQmFzZSk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBUZXh0KG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgVGV4dCk7XG5cbiAgICB2YXIgX3RoaXMgPSAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zWydkZWZhdWx0J10pKHRoaXMsIChUZXh0Ll9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMlsnZGVmYXVsdCddKShUZXh0KSkuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuXG4gICAgX3RoaXMuX3NldE1hcmdpbnMobGFiZWxNb2R1bGUpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKFRleHQsIFt7XG4gICAga2V5OiAncmVzaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICBpZiAodGhpcy5uZWVkc1JlZnJlc2goc2VsZWN0ZWQsIGhvdmVyKSkge1xuICAgICAgICB0aGlzLnRleHRTaXplID0gdGhpcy5sYWJlbE1vZHVsZS5nZXRUZXh0U2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICAgIHRoaXMud2lkdGggPSB0aGlzLnRleHRTaXplLndpZHRoICsgdGhpcy5tYXJnaW4ucmlnaHQgKyB0aGlzLm1hcmdpbi5sZWZ0O1xuICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMudGV4dFNpemUuaGVpZ2h0ICsgdGhpcy5tYXJnaW4udG9wICsgdGhpcy5tYXJnaW4uYm90dG9tO1xuICAgICAgICB0aGlzLnJhZGl1cyA9IDAuNSAqIHRoaXMud2lkdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZHJhdycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgdGhpcy5yZXNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggLyAyO1xuICAgICAgdGhpcy50b3AgPSB5IC0gdGhpcy5oZWlnaHQgLyAyO1xuXG4gICAgICAvLyBkcmF3IHNoYWRvdyBpZiBlbmFibGVkXG4gICAgICB0aGlzLmVuYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7XG4gICAgICB0aGlzLmxhYmVsTW9kdWxlLmRyYXcoY3R4LCB0aGlzLmxlZnQgKyB0aGlzLnRleHRTaXplLndpZHRoIC8gMiArIHRoaXMubWFyZ2luLmxlZnQsIHRoaXMudG9wICsgdGhpcy50ZXh0U2l6ZS5oZWlnaHQgLyAyICsgdGhpcy5tYXJnaW4udG9wLCBzZWxlY3RlZCwgaG92ZXIpO1xuXG4gICAgICAvLyBkaXNhYmxlIHNoYWRvd3MgZm9yIG90aGVyIGVsZW1lbnRzLlxuICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcblxuICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ0JveCh4LCB5LCBjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZGlzdGFuY2VUb0JvcmRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBUZXh0O1xufShfTm9kZUJhc2UzWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBUZXh0O1xuXG4vKioqLyB9KSxcbi8qIDE2MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2dldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cbnZhciBfaW5oZXJpdHMyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG52YXIgX1NoYXBlQmFzZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcblxudmFyIF9TaGFwZUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2hhcGVCYXNlMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLyoqXG4gKiBBIFRyaWFuZ2xlIE5vZGUvQ2x1c3RlciBzaGFwZS5cbiAqXG4gKiBAZXh0ZW5kcyBTaGFwZUJhc2VcbiAqL1xudmFyIFRyaWFuZ2xlID0gZnVuY3Rpb24gKF9TaGFwZUJhc2UpIHtcbiAgKDAsIF9pbmhlcml0czNbJ2RlZmF1bHQnXSkoVHJpYW5nbGUsIF9TaGFwZUJhc2UpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gVHJpYW5nbGUob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrM1snZGVmYXVsdCddKSh0aGlzLCBUcmlhbmdsZSk7XG4gICAgcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjNbJ2RlZmF1bHQnXSkodGhpcywgKFRyaWFuZ2xlLl9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMlsnZGVmYXVsdCddKShUcmlhbmdsZSkpLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoVHJpYW5nbGUsIFt7XG4gICAga2V5OiAnZHJhdycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgdGhpcy5fZHJhd1NoYXBlKGN0eCwgJ3RyaWFuZ2xlJywgMywgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Rpc3RhbmNlVG9Cb3JkZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVHJpYW5nbGU7XG59KF9TaGFwZUJhc2UzWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBUcmlhbmdsZTtcblxuLyoqKi8gfSksXG4vKiAxNjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9nZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxudmFyIF9TaGFwZUJhc2UyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG5cbnZhciBfU2hhcGVCYXNlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NoYXBlQmFzZTIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbi8qKlxuICogQSBkb3dud2FyZCBmYWNpbmcgVHJpYW5nbGUgTm9kZS9DbHVzdGVyIHNoYXBlLlxuICpcbiAqIEBleHRlbmRzIFNoYXBlQmFzZVxuICovXG52YXIgVHJpYW5nbGVEb3duID0gZnVuY3Rpb24gKF9TaGFwZUJhc2UpIHtcbiAgKDAsIF9pbmhlcml0czNbJ2RlZmF1bHQnXSkoVHJpYW5nbGVEb3duLCBfU2hhcGVCYXNlKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICovXG4gIGZ1bmN0aW9uIFRyaWFuZ2xlRG93bihvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIFRyaWFuZ2xlRG93bik7XG4gICAgcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjNbJ2RlZmF1bHQnXSkodGhpcywgKFRyaWFuZ2xlRG93bi5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjJbJ2RlZmF1bHQnXSkoVHJpYW5nbGVEb3duKSkuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzM1snZGVmYXVsdCddKShUcmlhbmdsZURvd24sIFt7XG4gICAga2V5OiAnZHJhdycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgdGhpcy5fZHJhd1NoYXBlKGN0eCwgJ3RyaWFuZ2xlRG93bicsIDMsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkaXN0YW5jZVRvQm9yZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFRyaWFuZ2xlRG93bjtcbn0oX1NoYXBlQmFzZTNbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFRyaWFuZ2xlRG93bjtcblxuLyoqKi8gfSksXG4vKiAxNjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbnZhciBEYXRhU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgRGF0YVZpZXcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxKTtcbnZhciBFZGdlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NSlbJ2RlZmF1bHQnXTtcblxuLyoqXG4gKiBIYW5kbGVyIGZvciBFZGdlc1xuICovXG5cbnZhciBFZGdlc0hhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0FycmF5LjxJbWFnZT59IGltYWdlc1xuICAgKiBAcGFyYW0ge0FycmF5LjxHcm91cD59IGdyb3Vwc1xuICAgKi9cbiAgZnVuY3Rpb24gRWRnZXNIYW5kbGVyKGJvZHksIGltYWdlcywgZ3JvdXBzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIEVkZ2VzSGFuZGxlcik7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuaW1hZ2VzID0gaW1hZ2VzO1xuICAgIHRoaXMuZ3JvdXBzID0gZ3JvdXBzO1xuXG4gICAgLy8gY3JlYXRlIHRoZSBlZGdlIEFQSSBpbiB0aGUgYm9keSBjb250YWluZXJcbiAgICB0aGlzLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZUVkZ2UgPSB0aGlzLmNyZWF0ZS5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5lZGdlc0xpc3RlbmVycyA9IHtcbiAgICAgIGFkZDogZnVuY3Rpb24gYWRkKGV2ZW50LCBwYXJhbXMpIHtcbiAgICAgICAgX3RoaXMuYWRkKHBhcmFtcy5pdGVtcyk7XG4gICAgICB9LFxuICAgICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoZXZlbnQsIHBhcmFtcykge1xuICAgICAgICBfdGhpcy51cGRhdGUocGFyYW1zLml0ZW1zKTtcbiAgICAgIH0sXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShldmVudCwgcGFyYW1zKSB7XG4gICAgICAgIF90aGlzLnJlbW92ZShwYXJhbXMuaXRlbXMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgYXJyb3dzOiB7XG4gICAgICAgIHRvOiB7IGVuYWJsZWQ6IGZhbHNlLCBzY2FsZUZhY3RvcjogMSwgdHlwZTogJ2Fycm93JyB9LCAvLyBib29sZWFuIC8ge2Fycm93U2NhbGVGYWN0b3I6MX0gLyB7ZW5hYmxlZDogZmFsc2UsIGFycm93U2NhbGVGYWN0b3I6MX1cbiAgICAgICAgbWlkZGxlOiB7IGVuYWJsZWQ6IGZhbHNlLCBzY2FsZUZhY3RvcjogMSwgdHlwZTogJ2Fycm93JyB9LFxuICAgICAgICBmcm9tOiB7IGVuYWJsZWQ6IGZhbHNlLCBzY2FsZUZhY3RvcjogMSwgdHlwZTogJ2Fycm93JyB9XG4gICAgICB9LFxuICAgICAgYXJyb3dTdHJpa2V0aHJvdWdoOiB0cnVlLFxuICAgICAgY29sb3I6IHtcbiAgICAgICAgY29sb3I6ICcjODQ4NDg0JyxcbiAgICAgICAgaGlnaGxpZ2h0OiAnIzg0ODQ4NCcsXG4gICAgICAgIGhvdmVyOiAnIzg0ODQ4NCcsXG4gICAgICAgIGluaGVyaXQ6ICdmcm9tJyxcbiAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICB9LFxuICAgICAgZGFzaGVzOiBmYWxzZSxcbiAgICAgIGZvbnQ6IHtcbiAgICAgICAgY29sb3I6ICcjMzQzNDM0JyxcbiAgICAgICAgc2l6ZTogMTQsIC8vIHB4XG4gICAgICAgIGZhY2U6ICdhcmlhbCcsXG4gICAgICAgIGJhY2tncm91bmQ6ICdub25lJyxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDIsIC8vIHB4XG4gICAgICAgIHN0cm9rZUNvbG9yOiAnI2ZmZmZmZicsXG4gICAgICAgIGFsaWduOiAnaG9yaXpvbnRhbCcsXG4gICAgICAgIG11bHRpOiBmYWxzZSxcbiAgICAgICAgdmFkanVzdDogMCxcbiAgICAgICAgYm9sZDoge1xuICAgICAgICAgIG1vZDogJ2JvbGQnXG4gICAgICAgIH0sXG4gICAgICAgIGJvbGRpdGFsOiB7XG4gICAgICAgICAgbW9kOiAnYm9sZCBpdGFsaWMnXG4gICAgICAgIH0sXG4gICAgICAgIGl0YWw6IHtcbiAgICAgICAgICBtb2Q6ICdpdGFsaWMnXG4gICAgICAgIH0sXG4gICAgICAgIG1vbm86IHtcbiAgICAgICAgICBtb2Q6ICcnLFxuICAgICAgICAgIHNpemU6IDE1LCAvLyBweFxuICAgICAgICAgIGZhY2U6ICdjb3VyaWVyIG5ldycsXG4gICAgICAgICAgdmFkanVzdDogMlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaGlkZGVuOiBmYWxzZSxcbiAgICAgIGhvdmVyV2lkdGg6IDEuNSxcbiAgICAgIGxhYmVsOiB1bmRlZmluZWQsXG4gICAgICBsYWJlbEhpZ2hsaWdodEJvbGQ6IHRydWUsXG4gICAgICBsZW5ndGg6IHVuZGVmaW5lZCxcbiAgICAgIHBoeXNpY3M6IHRydWUsXG4gICAgICBzY2FsaW5nOiB7XG4gICAgICAgIG1pbjogMSxcbiAgICAgICAgbWF4OiAxNSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgIG1pbjogMTQsXG4gICAgICAgICAgbWF4OiAzMCxcbiAgICAgICAgICBtYXhWaXNpYmxlOiAzMCxcbiAgICAgICAgICBkcmF3VGhyZXNob2xkOiA1XG4gICAgICAgIH0sXG4gICAgICAgIGN1c3RvbVNjYWxpbmdGdW5jdGlvbjogZnVuY3Rpb24gY3VzdG9tU2NhbGluZ0Z1bmN0aW9uKG1pbiwgbWF4LCB0b3RhbCwgdmFsdWUpIHtcbiAgICAgICAgICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICAgICAgICAgIHJldHVybiAwLjU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IDEgLyAobWF4IC0gbWluKTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCgwLCAodmFsdWUgLSBtaW4pICogc2NhbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNlbGVjdGlvbldpZHRoOiAxLjUsXG4gICAgICBzZWxmUmVmZXJlbmNlU2l6ZTogMjAsXG4gICAgICBzaGFkb3c6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIGNvbG9yOiAncmdiYSgwLDAsMCwwLjUpJyxcbiAgICAgICAgc2l6ZTogMTAsXG4gICAgICAgIHg6IDUsXG4gICAgICAgIHk6IDVcbiAgICAgIH0sXG4gICAgICBiYWNrZ3JvdW5kOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBjb2xvcjogJ3JnYmEoMTExLDExMSwxMTEsMSknLFxuICAgICAgICBzaXplOiAxMCxcbiAgICAgICAgZGFzaGVzOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHNtb290aDoge1xuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICB0eXBlOiAnZHluYW1pYycsXG4gICAgICAgIGZvcmNlRGlyZWN0aW9uOiAnbm9uZScsXG4gICAgICAgIHJvdW5kbmVzczogMC41XG4gICAgICB9LFxuICAgICAgdGl0bGU6IHVuZGVmaW5lZCxcbiAgICAgIHdpZHRoOiAxLFxuICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgIH07XG5cbiAgICB1dGlsLmRlZXBFeHRlbmQodGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICAgIHRoaXMuYmluZEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cblxuICAvKipcbiAgICogQmluZHMgZXZlbnQgbGlzdGVuZXJzXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoRWRnZXNIYW5kbGVyLCBbe1xuICAgIGtleTogJ2JpbmRFdmVudExpc3RlbmVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRFdmVudExpc3RlbmVycygpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAvLyB0aGlzIGFsbG93cyBleHRlcm5hbCBtb2R1bGVzIHRvIGZvcmNlIGFsbCBkeW5hbWljIGN1cnZlcyB0byB0dXJuIHN0YXRpYy5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdfZm9yY2VEaXNhYmxlRHluYW1pY0N1cnZlcycsIGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciBlbWl0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuXG4gICAgICAgIGlmICh0eXBlID09PSAnZHluYW1pYycpIHtcbiAgICAgICAgICB0eXBlID0gJ2NvbnRpbnVvdXMnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXRhQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBlZGdlSWQgaW4gX3RoaXMyLmJvZHkuZWRnZXMpIHtcbiAgICAgICAgICBpZiAoX3RoaXMyLmJvZHkuZWRnZXMuaGFzT3duUHJvcGVydHkoZWRnZUlkKSkge1xuICAgICAgICAgICAgdmFyIGVkZ2UgPSBfdGhpczIuYm9keS5lZGdlc1tlZGdlSWRdO1xuICAgICAgICAgICAgdmFyIGVkZ2VEYXRhID0gX3RoaXMyLmJvZHkuZGF0YS5lZGdlcy5fZGF0YVtlZGdlSWRdO1xuXG4gICAgICAgICAgICAvLyBvbmx5IGZvcmNpYmx5IHJlbW92ZSB0aGUgc21vb3RoIGN1cnZlIGlmIHRoZSBkYXRhIGhhcyBiZWVuIHNldCBvZiB0aGUgZWRnZSBoYXMgdGhlIHNtb290aCBjdXJ2ZXMgZGVmaW5lZC5cbiAgICAgICAgICAgIC8vIHRoaXMgaXMgYmVjYXVzZSBhIGNoYW5nZSBpbiB0aGUgZ2xvYmFsIHdvdWxkIG5vdCBhZmZlY3QgdGhlc2UgY3VydmVzLlxuICAgICAgICAgICAgaWYgKGVkZ2VEYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdmFyIHNtb290aE9wdGlvbnMgPSBlZGdlRGF0YS5zbW9vdGg7XG4gICAgICAgICAgICAgIGlmIChzbW9vdGhPcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc21vb3RoT3B0aW9ucy5lbmFibGVkID09PSB0cnVlICYmIHNtb290aE9wdGlvbnMudHlwZSA9PT0gJ2R5bmFtaWMnKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGVkZ2Uuc2V0T3B0aW9ucyh7IHNtb290aDogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlZGdlLnNldE9wdGlvbnMoeyBzbW9vdGg6IHsgdHlwZTogdHlwZSB9IH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZGF0YUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZW1pdCA9PT0gdHJ1ZSAmJiBkYXRhQ2hhbmdlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIF90aGlzMi5ib2R5LmVtaXR0ZXIuZW1pdCgnX2RhdGFDaGFuZ2VkJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyB0aGlzIGlzIGNhbGxlZCB3aGVuIG9wdGlvbnMgb2YgRVhJU1RJTkcgbm9kZXMgb3IgZWRnZXMgaGF2ZSBjaGFuZ2VkLlxuICAgICAgLy9cbiAgICAgIC8vIE5PVEU6IE5vdCB0cnVlLCBjYWxsZWQgd2hlbiBvcHRpb25zIGhhdmUgTk9UIGNoYW5nZWQsIGZvciBib3RoIGV4aXN0aW5nIGFzIHdlbGwgYXMgbmV3IG5vZGVzLlxuICAgICAgLy8gICAgICAgU2VlIHVwZGF0ZSgpIGZvciBsb2dpYy5cbiAgICAgIC8vIFRPRE86IFZlcmlmeSBhbmQgZXhhbWluZSB0aGUgY29uc2VxdWVuY2VzIG9mIHRoaXMuIEl0IG1pZ2h0IHN0aWxsIHRyaWdnZXIgd2hlblxuICAgICAgLy8gICAgICAgbm9uLW9wdGlvbiBmaWVsZHMgaGF2ZSBjaGFuZ2VkLCBidXQgdGhlbiByZWNvbm5lY3RpbmcgZWRnZXMgaXMgc3RpbGwgdXNlbGVzcy5cbiAgICAgIC8vICAgICAgIEFsdGVybmF0aXZlbHksIGl0IG1pZ2h0IGFsc28gYmUgY2FsbGVkIHdoZW4gZWRnZXMgYXJlIHJlbW92ZWQuXG4gICAgICAvL1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ19kYXRhVXBkYXRlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLnJlY29ubmVjdEVkZ2VzKCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gcmVmcmVzaCB0aGUgZWRnZXMuIFVzZWQgd2hlbiByZXZlcnRpbmcgZnJvbSBoaWVyYXJjaGljYWwgbGF5b3V0XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbigncmVmcmVzaEVkZ2VzJywgdGhpcy5yZWZyZXNoLmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ3JlZnJlc2gnLCB0aGlzLnJlZnJlc2guYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbC5mb3JFYWNoKF90aGlzMi5lZGdlc0xpc3RlbmVycywgZnVuY3Rpb24gKGNhbGxiYWNrLCBldmVudCkge1xuICAgICAgICAgIGlmIChfdGhpczIuYm9keS5kYXRhLmVkZ2VzKSBfdGhpczIuYm9keS5kYXRhLmVkZ2VzLm9mZihldmVudCwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVsZXRlIF90aGlzMi5ib2R5LmZ1bmN0aW9ucy5jcmVhdGVFZGdlO1xuICAgICAgICBkZWxldGUgX3RoaXMyLmVkZ2VzTGlzdGVuZXJzLmFkZDtcbiAgICAgICAgZGVsZXRlIF90aGlzMi5lZGdlc0xpc3RlbmVycy51cGRhdGU7XG4gICAgICAgIGRlbGV0ZSBfdGhpczIuZWRnZXNMaXN0ZW5lcnMucmVtb3ZlO1xuICAgICAgICBkZWxldGUgX3RoaXMyLmVkZ2VzTGlzdGVuZXJzO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRPcHRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHVzZSB0aGUgcGFyc2VyIGZyb20gdGhlIEVkZ2UgY2xhc3MgdG8gZmlsbCBpbiBhbGwgc2hvcnRoYW5kIG5vdGF0aW9uc1xuICAgICAgICBFZGdlLnBhcnNlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMsIHRydWUsIHRoaXMuZGVmYXVsdE9wdGlvbnMsIHRydWUpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBzbW9vdGggc2V0dGluZ3MgaW4gYWxsIGVkZ2VzXG4gICAgICAgIHZhciBkYXRhQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBpZiAob3B0aW9ucy5zbW9vdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGZvciAodmFyIGVkZ2VJZCBpbiB0aGlzLmJvZHkuZWRnZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJvZHkuZWRnZXMuaGFzT3duUHJvcGVydHkoZWRnZUlkKSkge1xuICAgICAgICAgICAgICBkYXRhQ2hhbmdlZCA9IHRoaXMuYm9keS5lZGdlc1tlZGdlSWRdLnVwZGF0ZUVkZ2VUeXBlKCkgfHwgZGF0YUNoYW5nZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIGZvbnRzIGluIGFsbCBlZGdlc1xuICAgICAgICBpZiAob3B0aW9ucy5mb250ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBmb3IgKHZhciBfZWRnZUlkIGluIHRoaXMuYm9keS5lZGdlcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYm9keS5lZGdlcy5oYXNPd25Qcm9wZXJ0eShfZWRnZUlkKSkge1xuICAgICAgICAgICAgICB0aGlzLmJvZHkuZWRnZXNbX2VkZ2VJZF0udXBkYXRlTGFiZWxNb2R1bGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHN0YXRlIG9mIHRoZSB2YXJpYWJsZXMgaWYgbmVlZGVkXG4gICAgICAgIGlmIChvcHRpb25zLmhpZGRlbiAhPT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMucGh5c2ljcyAhPT0gdW5kZWZpbmVkIHx8IGRhdGFDaGFuZ2VkID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2RhdGFDaGFuZ2VkJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkIGVkZ2VzIGJ5IHJlYWRpbmcgdGhlIGRhdGEgdGFibGVcbiAgICAgKiBAcGFyYW0ge0FycmF5IHwgRGF0YVNldCB8IERhdGFWaWV3fSBlZGdlcyAgICBUaGUgZGF0YSBjb250YWluaW5nIHRoZSBlZGdlcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkb05vdEVtaXQ9ZmFsc2VdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0RGF0YScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldERhdGEoZWRnZXMpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgZG9Ob3RFbWl0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgICAgdmFyIG9sZEVkZ2VzRGF0YSA9IHRoaXMuYm9keS5kYXRhLmVkZ2VzO1xuXG4gICAgICBpZiAoZWRnZXMgaW5zdGFuY2VvZiBEYXRhU2V0IHx8IGVkZ2VzIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICAgICAgdGhpcy5ib2R5LmRhdGEuZWRnZXMgPSBlZGdlcztcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShlZGdlcykpIHtcbiAgICAgICAgdGhpcy5ib2R5LmRhdGEuZWRnZXMgPSBuZXcgRGF0YVNldCgpO1xuICAgICAgICB0aGlzLmJvZHkuZGF0YS5lZGdlcy5hZGQoZWRnZXMpO1xuICAgICAgfSBlbHNlIGlmICghZWRnZXMpIHtcbiAgICAgICAgdGhpcy5ib2R5LmRhdGEuZWRnZXMgPSBuZXcgRGF0YVNldCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkgb3IgRGF0YVNldCBleHBlY3RlZCcpO1xuICAgICAgfVxuXG4gICAgICAvLyBUT0RPOiBpcyB0aGlzIG51bGwgb3IgdW5kZWZpbmVkIG9yIGZhbHNlP1xuICAgICAgaWYgKG9sZEVkZ2VzRGF0YSkge1xuICAgICAgICAvLyB1bnN1YnNjcmliZSBmcm9tIG9sZCBkYXRhc2V0XG4gICAgICAgIHV0aWwuZm9yRWFjaCh0aGlzLmVkZ2VzTGlzdGVuZXJzLCBmdW5jdGlvbiAoY2FsbGJhY2ssIGV2ZW50KSB7XG4gICAgICAgICAgb2xkRWRnZXNEYXRhLm9mZihldmVudCwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gcmVtb3ZlIGRyYXduIGVkZ2VzXG4gICAgICB0aGlzLmJvZHkuZWRnZXMgPSB7fTtcblxuICAgICAgLy8gVE9ETzogaXMgdGhpcyBudWxsIG9yIHVuZGVmaW5lZCBvciBmYWxzZT9cbiAgICAgIGlmICh0aGlzLmJvZHkuZGF0YS5lZGdlcykge1xuICAgICAgICAvLyBzdWJzY3JpYmUgdG8gbmV3IGRhdGFzZXRcbiAgICAgICAgdXRpbC5mb3JFYWNoKHRoaXMuZWRnZXNMaXN0ZW5lcnMsIGZ1bmN0aW9uIChjYWxsYmFjaywgZXZlbnQpIHtcbiAgICAgICAgICBfdGhpczMuYm9keS5kYXRhLmVkZ2VzLm9uKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGRyYXcgYWxsIG5ldyBub2Rlc1xuICAgICAgICB2YXIgaWRzID0gdGhpcy5ib2R5LmRhdGEuZWRnZXMuZ2V0SWRzKCk7XG4gICAgICAgIHRoaXMuYWRkKGlkcywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19hZGp1c3RFZGdlc0ZvckhpZXJhcmNoaWNhbExheW91dCcpO1xuICAgICAgaWYgKGRvTm90RW1pdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2RhdGFDaGFuZ2VkJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGVkZ2VzXG4gICAgICogQHBhcmFtIHtudW1iZXJbXSB8IHN0cmluZ1tdfSBpZHNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkb05vdEVtaXQ9ZmFsc2VdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYWRkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKGlkcykge1xuICAgICAgdmFyIGRvTm90RW1pdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcbiAgICAgIHZhciBlZGdlc0RhdGEgPSB0aGlzLmJvZHkuZGF0YS5lZGdlcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGlkID0gaWRzW2ldO1xuXG4gICAgICAgIHZhciBvbGRFZGdlID0gZWRnZXNbaWRdO1xuICAgICAgICBpZiAob2xkRWRnZSkge1xuICAgICAgICAgIG9sZEVkZ2UuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRhdGEgPSBlZGdlc0RhdGEuZ2V0KGlkLCB7IHNob3dJbnRlcm5hbElkczogdHJ1ZSB9KTtcbiAgICAgICAgZWRnZXNbaWRdID0gdGhpcy5jcmVhdGUoZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19hZGp1c3RFZGdlc0ZvckhpZXJhcmNoaWNhbExheW91dCcpO1xuXG4gICAgICBpZiAoZG9Ob3RFbWl0ID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfZGF0YUNoYW5nZWQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZXhpc3RpbmcgZWRnZXMsIG9yIGNyZWF0ZSB0aGVtIHdoZW4gbm90IHlldCBleGlzdGluZ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyW10gfCBzdHJpbmdbXX0gaWRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKGlkcykge1xuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuICAgICAgdmFyIGVkZ2VzRGF0YSA9IHRoaXMuYm9keS5kYXRhLmVkZ2VzO1xuICAgICAgdmFyIGRhdGFDaGFuZ2VkID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaWQgPSBpZHNbaV07XG4gICAgICAgIHZhciBkYXRhID0gZWRnZXNEYXRhLmdldChpZCk7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbaWRdO1xuICAgICAgICBpZiAoZWRnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gdXBkYXRlIGVkZ2VcbiAgICAgICAgICBlZGdlLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICBkYXRhQ2hhbmdlZCA9IGVkZ2Uuc2V0T3B0aW9ucyhkYXRhKSB8fCBkYXRhQ2hhbmdlZDsgLy8gaWYgYSBzdXBwb3J0IG5vZGUgaXMgYWRkZWQsIGRhdGEgY2FuIGJlIGNoYW5nZWQuXG4gICAgICAgICAgZWRnZS5jb25uZWN0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY3JlYXRlIGVkZ2VcbiAgICAgICAgICB0aGlzLmJvZHkuZWRnZXNbaWRdID0gdGhpcy5jcmVhdGUoZGF0YSk7XG4gICAgICAgICAgZGF0YUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhQ2hhbmdlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfYWRqdXN0RWRnZXNGb3JIaWVyYXJjaGljYWxMYXlvdXQnKTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2RhdGFDaGFuZ2VkJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfZGF0YVVwZGF0ZWQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgZXhpc3RpbmcgZWRnZXMuIE5vbiBleGlzdGluZyBpZHMgd2lsbCBiZSBpZ25vcmVkXG4gICAgICogQHBhcmFtIHtudW1iZXJbXSB8IHN0cmluZ1tdfSBpZHNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtlbWl0PXRydWVdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncmVtb3ZlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKGlkcykge1xuICAgICAgdmFyIGVtaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG5cbiAgICAgIGlmIChpZHMubGVuZ3RoID09PSAwKSByZXR1cm47IC8vIGVhcmx5IG91dFxuXG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gICAgICB1dGlsLmZvckVhY2goaWRzLCBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tpZF07XG4gICAgICAgIGlmIChlZGdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBlZGdlLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKGVtaXQpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2RhdGFDaGFuZ2VkJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVmcmVzaGVzIEVkZ2UgSGFuZGxlclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZWZyZXNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVmcmVzaCgpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB1dGlsLmZvckVhY2godGhpcy5ib2R5LmVkZ2VzLCBmdW5jdGlvbiAoZWRnZSwgZWRnZUlkKSB7XG4gICAgICAgIHZhciBkYXRhID0gX3RoaXM0LmJvZHkuZGF0YS5lZGdlcy5fZGF0YVtlZGdlSWRdO1xuICAgICAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZWRnZS5zZXRPcHRpb25zKGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzXG4gICAgICogQHJldHVybnMge0VkZ2V9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2NyZWF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICByZXR1cm4gbmV3IEVkZ2UocHJvcGVydGllcywgdGhpcy5ib2R5LCB0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY29ubmVjdCBhbGwgZWRnZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZWNvbm5lY3RFZGdlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlY29ubmVjdEVkZ2VzKCkge1xuICAgICAgdmFyIGlkO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuXG4gICAgICBmb3IgKGlkIGluIG5vZGVzKSB7XG4gICAgICAgIGlmIChub2Rlcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICBub2Rlc1tpZF0uZWRnZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGlkIGluIGVkZ2VzKSB7XG4gICAgICAgIGlmIChlZGdlcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2lkXTtcbiAgICAgICAgICBlZGdlLmZyb20gPSBudWxsO1xuICAgICAgICAgIGVkZ2UudG8gPSBudWxsO1xuICAgICAgICAgIGVkZ2UuY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VkZ2UuaWR9IGVkZ2VJZFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0Q29ubmVjdGVkTm9kZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb25uZWN0ZWROb2RlcyhlZGdlSWQpIHtcbiAgICAgIHZhciBub2RlTGlzdCA9IFtdO1xuICAgICAgaWYgKHRoaXMuYm9keS5lZGdlc1tlZGdlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGVkZ2UgPSB0aGlzLmJvZHkuZWRnZXNbZWRnZUlkXTtcbiAgICAgICAgaWYgKGVkZ2UuZnJvbUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBub2RlTGlzdC5wdXNoKGVkZ2UuZnJvbUlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWRnZS50b0lkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBub2RlTGlzdC5wdXNoKGVkZ2UudG9JZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlTGlzdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGVyZSBpcyBubyBkaXJlY3QgcmVsYXRpb24gYmV0d2VlbiB0aGUgbm9kZXMgYW5kIHRoZSBlZGdlcyBEYXRhU2V0LFxuICAgICAqIHNvIHRoZSByaWdodCBwbGFjZSB0byBkbyBjYWxsIHRoaXMgaXMgaW4gdGhlIGhhbmRsZXIgZm9yIGV2ZW50IGBfZGF0YVVwZGF0ZWRgLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfdXBkYXRlU3RhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlU3RhdGUoKSB7XG4gICAgICB0aGlzLl9hZGRNaXNzaW5nRWRnZXMoKTtcbiAgICAgIHRoaXMuX3JlbW92ZUludmFsaWRFZGdlcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjYW4gZm9yIG1pc3Npbmcgbm9kZXMgYW5kIHJlbW92ZSBjb3JyZXNwb25kaW5nIGVkZ2VzLCBpZiBhbnkuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3JlbW92ZUludmFsaWRFZGdlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVJbnZhbGlkRWRnZXMoKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgdmFyIGVkZ2VzVG9EZWxldGUgPSBbXTtcblxuICAgICAgdXRpbC5mb3JFYWNoKHRoaXMuYm9keS5lZGdlcywgZnVuY3Rpb24gKGVkZ2UsIGlkKSB7XG4gICAgICAgIHZhciB0b05vZGUgPSBfdGhpczUuYm9keS5ub2Rlc1tlZGdlLnRvSWRdO1xuICAgICAgICB2YXIgZnJvbU5vZGUgPSBfdGhpczUuYm9keS5ub2Rlc1tlZGdlLmZyb21JZF07XG5cbiAgICAgICAgLy8gU2tpcCBjbHVzdGVyaW5nIGVkZ2VzIGhlcmUsIGxldCB0aGUgQ2x1c3RlcmluZyBtb2R1bGUgaGFuZGxlIHRob3NlXG4gICAgICAgIGlmICh0b05vZGUgIT09IHVuZGVmaW5lZCAmJiB0b05vZGUuaXNDbHVzdGVyID09PSB0cnVlIHx8IGZyb21Ob2RlICE9PSB1bmRlZmluZWQgJiYgZnJvbU5vZGUuaXNDbHVzdGVyID09PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRvTm9kZSA9PT0gdW5kZWZpbmVkIHx8IGZyb21Ob2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBlZGdlc1RvRGVsZXRlLnB1c2goaWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5yZW1vdmUoZWRnZXNUb0RlbGV0ZSwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFkZCBhbGwgZWRnZXMgZnJvbSBkYXRhc2V0IHRoYXQgYXJlIG5vdCBpbiB0aGUgY2FjaGVkIHN0YXRlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2FkZE1pc3NpbmdFZGdlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRNaXNzaW5nRWRnZXMoKSB7XG4gICAgICB2YXIgZWRnZXNEYXRhID0gdGhpcy5ib2R5LmRhdGEuZWRnZXM7XG4gICAgICBpZiAoZWRnZXNEYXRhID09PSB1bmRlZmluZWQgfHwgZWRnZXNEYXRhID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjsgLy8gTm8gZWRnZXMgRGF0YVNldCB5ZXQ7IGNhbiBoYXBwZW4gb24gc3RhcnR1cFxuICAgICAgfVxuXG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gICAgICB2YXIgYWRkSWRzID0gW107XG5cbiAgICAgIGVkZ2VzRGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlRGF0YSwgZWRnZUlkKSB7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbZWRnZUlkXTtcbiAgICAgICAgaWYgKGVkZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGFkZElkcy5wdXNoKGVkZ2VJZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmFkZChhZGRJZHMsIHRydWUpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRWRnZXNIYW5kbGVyO1xufSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBFZGdlc0hhbmRsZXI7XG5cbi8qKiovIH0pLFxuLyogMTY2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfc2xpY2VkVG9BcnJheTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblxudmFyIF9zbGljZWRUb0FycmF5MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NsaWNlZFRvQXJyYXkyKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxudmFyIF9DdWJpY0JlemllckVkZ2VCYXNlMiA9IF9fd2VicGFja19yZXF1aXJlX18oMTY3KTtcblxudmFyIF9DdWJpY0JlemllckVkZ2VCYXNlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0N1YmljQmV6aWVyRWRnZUJhc2UyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vKipcbiAqIEEgQ3ViaWMgQmV6aWVyIEVkZ2UuIEJlemllciBjdXJ2ZXMgYXJlIHVzZWQgdG8gbW9kZWwgc21vb3RoIGdyYWR1YWxcbiAqIGN1cnZlcyBpbiBwYXRocyBiZXR3ZWVuIG5vZGVzLlxuICpcbiAqIEBleHRlbmRzIEN1YmljQmV6aWVyRWRnZUJhc2VcbiAqL1xudmFyIEN1YmljQmV6aWVyRWRnZSA9IGZ1bmN0aW9uIChfQ3ViaWNCZXppZXJFZGdlQmFzZSkge1xuICAoMCwgX2luaGVyaXRzM1snZGVmYXVsdCddKShDdWJpY0JlemllckVkZ2UsIF9DdWJpY0JlemllckVkZ2VCYXNlKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICovXG4gIGZ1bmN0aW9uIEN1YmljQmV6aWVyRWRnZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIEN1YmljQmV6aWVyRWRnZSk7XG4gICAgcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjNbJ2RlZmF1bHQnXSkodGhpcywgKEN1YmljQmV6aWVyRWRnZS5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjJbJ2RlZmF1bHQnXSkoQ3ViaWNCZXppZXJFZGdlKSkuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIERyYXcgYSBsaW5lIGJldHdlZW4gdHdvIG5vZGVzXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgKiBAcGFyYW0ge0FycmF5LjxOb2RlPn0gdmlhTm9kZXNcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzM1snZGVmYXVsdCddKShDdWJpY0JlemllckVkZ2UsIFt7XG4gICAga2V5OiAnX2xpbmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbGluZShjdHgsIHZhbHVlcywgdmlhTm9kZXMpIHtcbiAgICAgIC8vIGdldCB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIHN1cHBvcnQgcG9pbnRzLlxuICAgICAgdmFyIHZpYTEgPSB2aWFOb2Rlc1swXTtcbiAgICAgIHZhciB2aWEyID0gdmlhTm9kZXNbMV07XG4gICAgICB0aGlzLl9iZXppZXJDdXJ2ZShjdHgsIHZhbHVlcywgdmlhMSwgdmlhMik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHt4OiBudW1iZXIsIHk6IG51bWJlcn0+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19nZXRWaWFDb29yZGluYXRlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRWaWFDb29yZGluYXRlcygpIHtcbiAgICAgIHZhciBkeCA9IHRoaXMuZnJvbS54IC0gdGhpcy50by54O1xuICAgICAgdmFyIGR5ID0gdGhpcy5mcm9tLnkgLSB0aGlzLnRvLnk7XG5cbiAgICAgIHZhciB4MSA9IHZvaWQgMCxcbiAgICAgICAgICB5MSA9IHZvaWQgMCxcbiAgICAgICAgICB4MiA9IHZvaWQgMCxcbiAgICAgICAgICB5MiA9IHZvaWQgMDtcbiAgICAgIHZhciByb3VuZG5lc3MgPSB0aGlzLm9wdGlvbnMuc21vb3RoLnJvdW5kbmVzcztcblxuICAgICAgLy8gaG9yaXpvbnRhbCBpZiB4ID4geSBvciBpZiBkaXJlY3Rpb24gaXMgZm9yY2VkIG9yIGlmIGRpcmVjdGlvbiBpcyBob3Jpem9udGFsXG4gICAgICBpZiAoKE1hdGguYWJzKGR4KSA+IE1hdGguYWJzKGR5KSB8fCB0aGlzLm9wdGlvbnMuc21vb3RoLmZvcmNlRGlyZWN0aW9uID09PSB0cnVlIHx8IHRoaXMub3B0aW9ucy5zbW9vdGguZm9yY2VEaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJykgJiYgdGhpcy5vcHRpb25zLnNtb290aC5mb3JjZURpcmVjdGlvbiAhPT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICB5MSA9IHRoaXMuZnJvbS55O1xuICAgICAgICB5MiA9IHRoaXMudG8ueTtcbiAgICAgICAgeDEgPSB0aGlzLmZyb20ueCAtIHJvdW5kbmVzcyAqIGR4O1xuICAgICAgICB4MiA9IHRoaXMudG8ueCArIHJvdW5kbmVzcyAqIGR4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeTEgPSB0aGlzLmZyb20ueSAtIHJvdW5kbmVzcyAqIGR5O1xuICAgICAgICB5MiA9IHRoaXMudG8ueSArIHJvdW5kbmVzcyAqIGR5O1xuICAgICAgICB4MSA9IHRoaXMuZnJvbS54O1xuICAgICAgICB4MiA9IHRoaXMudG8ueDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFt7IHg6IHgxLCB5OiB5MSB9LCB7IHg6IHgyLCB5OiB5MiB9XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48e3g6IG51bWJlciwgeTogbnVtYmVyfT59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldFZpYU5vZGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWaWFOb2RlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5lYXJOb2RlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiBudW1iZXIsIHQ6IG51bWJlcn19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2ZpbmRCb3JkZXJQb3NpdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kQm9yZGVyUG9zaXRpb24obmVhck5vZGUsIGN0eCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbkJlemllcihuZWFyTm9kZSwgY3R4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4M1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5M1xuICAgICAqIEBwYXJhbSB7Tm9kZX0gdmlhMVxuICAgICAqIEBwYXJhbSB7Tm9kZX0gdmlhMlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2dldERpc3RhbmNlVG9FZGdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERpc3RhbmNlVG9FZGdlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDYgJiYgYXJndW1lbnRzWzZdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNl0gOiB0aGlzLl9nZXRWaWFDb29yZGluYXRlcygpLFxuICAgICAgICAgIF9yZWYyID0gKDAsIF9zbGljZWRUb0FycmF5M1snZGVmYXVsdCddKShfcmVmLCAyKSxcbiAgICAgICAgICB2aWExID0gX3JlZjJbMF0sXG4gICAgICAgICAgdmlhMiA9IF9yZWYyWzFdO1xuXG4gICAgICAvLyB4Myx5MyBpcyB0aGUgcG9pbnRcbiAgICAgIHJldHVybiB0aGlzLl9nZXREaXN0YW5jZVRvQmV6aWVyRWRnZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB2aWExLCB2aWEyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21iaW5lZCBmdW5jdGlvbiBvZiBwb2ludE9uTGluZSBhbmQgcG9pbnRPbkJlemllci4gVGhpcyBnaXZlcyB0aGUgY29vcmRpbmF0ZXMgb2YgYSBwb2ludCBvbiB0aGUgbGluZSBhdCBhIGNlcnRhaW4gcGVyY2VudGFnZSBvZiB0aGUgd2F5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBlcmNlbnRhZ2VcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IFt2aWExPXRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKClbMF1dXG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBbdmlhMj10aGlzLl9nZXRWaWFDb29yZGluYXRlcygpWzFdXVxuICAgICAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldFBvaW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9pbnQocGVyY2VudGFnZSkge1xuICAgICAgdmFyIF9yZWYzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLl9nZXRWaWFDb29yZGluYXRlcygpLFxuICAgICAgICAgIF9yZWY0ID0gKDAsIF9zbGljZWRUb0FycmF5M1snZGVmYXVsdCddKShfcmVmMywgMiksXG4gICAgICAgICAgdmlhMSA9IF9yZWY0WzBdLFxuICAgICAgICAgIHZpYTIgPSBfcmVmNFsxXTtcblxuICAgICAgdmFyIHQgPSBwZXJjZW50YWdlO1xuICAgICAgdmFyIHZlYyA9IFtdO1xuICAgICAgdmVjWzBdID0gTWF0aC5wb3coMSAtIHQsIDMpO1xuICAgICAgdmVjWzFdID0gMyAqIHQgKiBNYXRoLnBvdygxIC0gdCwgMik7XG4gICAgICB2ZWNbMl0gPSAzICogTWF0aC5wb3codCwgMikgKiAoMSAtIHQpO1xuICAgICAgdmVjWzNdID0gTWF0aC5wb3codCwgMyk7XG4gICAgICB2YXIgeCA9IHZlY1swXSAqIHRoaXMuZnJvbVBvaW50LnggKyB2ZWNbMV0gKiB2aWExLnggKyB2ZWNbMl0gKiB2aWEyLnggKyB2ZWNbM10gKiB0aGlzLnRvUG9pbnQueDtcbiAgICAgIHZhciB5ID0gdmVjWzBdICogdGhpcy5mcm9tUG9pbnQueSArIHZlY1sxXSAqIHZpYTEueSArIHZlY1syXSAqIHZpYTIueSArIHZlY1szXSAqIHRoaXMudG9Qb2ludC55O1xuXG4gICAgICByZXR1cm4geyB4OiB4LCB5OiB5IH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDdWJpY0JlemllckVkZ2U7XG59KF9DdWJpY0JlemllckVkZ2VCYXNlM1snZGVmYXVsdCddKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gQ3ViaWNCZXppZXJFZGdlO1xuXG4vKioqLyB9KSxcbi8qIDE2NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2dldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cbnZhciBfaW5oZXJpdHMyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG52YXIgX0JlemllckVkZ2VCYXNlMiA9IF9fd2VicGFja19yZXF1aXJlX18oNTYpO1xuXG52YXIgX0JlemllckVkZ2VCYXNlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0JlemllckVkZ2VCYXNlMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLyoqXG4gKiBBIEJhc2UgQ2xhc3MgZm9yIGFsbCBDdWJpYyBCZXppZXIgRWRnZXMuIEJlemllciBjdXJ2ZXMgYXJlIHVzZWQgdG8gbW9kZWxcbiAqIHNtb290aCBncmFkdWFsIGN1cnZlcyBpbiBwYXRocyBiZXR3ZWVuIG5vZGVzLlxuICpcbiAqIEBleHRlbmRzIEJlemllckVkZ2VCYXNlXG4gKi9cbnZhciBDdWJpY0JlemllckVkZ2VCYXNlID0gZnVuY3Rpb24gKF9CZXppZXJFZGdlQmFzZSkge1xuICAoMCwgX2luaGVyaXRzM1snZGVmYXVsdCddKShDdWJpY0JlemllckVkZ2VCYXNlLCBfQmV6aWVyRWRnZUJhc2UpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gQ3ViaWNCZXppZXJFZGdlQmFzZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIEN1YmljQmV6aWVyRWRnZUJhc2UpO1xuICAgIHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zWydkZWZhdWx0J10pKHRoaXMsIChDdWJpY0JlemllckVkZ2VCYXNlLl9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMlsnZGVmYXVsdCddKShDdWJpY0JlemllckVkZ2VCYXNlKSkuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiBhIHBvaW50ICh4Myx5MykgYW5kIGEgbGluZSBzZWdtZW50IGZyb21cbiAgICogKHgxLHkxKSB0byAoeDIseTIpLlxuICAgKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg0OTIxMS9zaG9ydGVzdC1kaXN0YW5jYWUtYmV0d2Vlbi1hLXBvaW50LWFuZC1hLWxpbmUtc2VnbWVudFxuICAgKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CJUMzJUE5emllcl9jdXJ2ZVxuICAgKiBAcGFyYW0ge251bWJlcn0geDEgZnJvbSB4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5MSBmcm9tIHlcbiAgICogQHBhcmFtIHtudW1iZXJ9IHgyIHRvIHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkyIHRvIHlcbiAgICogQHBhcmFtIHtudW1iZXJ9IHgzIHBvaW50IHRvIGNoZWNrIHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkzIHBvaW50IHRvIGNoZWNrIHlcbiAgICogQHBhcmFtIHtOb2RlfSB2aWExXG4gICAqIEBwYXJhbSB7Tm9kZX0gdmlhMlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKEN1YmljQmV6aWVyRWRnZUJhc2UsIFt7XG4gICAga2V5OiAnX2dldERpc3RhbmNlVG9CZXppZXJFZGdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERpc3RhbmNlVG9CZXppZXJFZGdlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHZpYTEsIHZpYTIpIHtcbiAgICAgIC8vIHgzLHkzIGlzIHRoZSBwb2ludFxuICAgICAgdmFyIG1pbkRpc3RhbmNlID0gMWU5O1xuICAgICAgdmFyIGRpc3RhbmNlID0gdm9pZCAwO1xuICAgICAgdmFyIGkgPSB2b2lkIDAsXG4gICAgICAgICAgdCA9IHZvaWQgMCxcbiAgICAgICAgICB4ID0gdm9pZCAwLFxuICAgICAgICAgIHkgPSB2b2lkIDA7XG4gICAgICB2YXIgbGFzdFggPSB4MTtcbiAgICAgIHZhciBsYXN0WSA9IHkxO1xuICAgICAgdmFyIHZlYyA9IFswLCAwLCAwLCAwXTtcbiAgICAgIGZvciAoaSA9IDE7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgIHQgPSAwLjEgKiBpO1xuICAgICAgICB2ZWNbMF0gPSBNYXRoLnBvdygxIC0gdCwgMyk7XG4gICAgICAgIHZlY1sxXSA9IDMgKiB0ICogTWF0aC5wb3coMSAtIHQsIDIpO1xuICAgICAgICB2ZWNbMl0gPSAzICogTWF0aC5wb3codCwgMikgKiAoMSAtIHQpO1xuICAgICAgICB2ZWNbM10gPSBNYXRoLnBvdyh0LCAzKTtcbiAgICAgICAgeCA9IHZlY1swXSAqIHgxICsgdmVjWzFdICogdmlhMS54ICsgdmVjWzJdICogdmlhMi54ICsgdmVjWzNdICogeDI7XG4gICAgICAgIHkgPSB2ZWNbMF0gKiB5MSArIHZlY1sxXSAqIHZpYTEueSArIHZlY1syXSAqIHZpYTIueSArIHZlY1szXSAqIHkyO1xuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICBkaXN0YW5jZSA9IHRoaXMuX2dldERpc3RhbmNlVG9MaW5lKGxhc3RYLCBsYXN0WSwgeCwgeSwgeDMsIHkzKTtcbiAgICAgICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlIDwgbWluRGlzdGFuY2UgPyBkaXN0YW5jZSA6IG1pbkRpc3RhbmNlO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RYID0geDtcbiAgICAgICAgbGFzdFkgPSB5O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWluRGlzdGFuY2U7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDdWJpY0JlemllckVkZ2VCYXNlO1xufShfQmV6aWVyRWRnZUJhc2UzWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBDdWJpY0JlemllckVkZ2VCYXNlO1xuXG4vKioqLyB9KSxcbi8qIDE2OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cbnZhciBfc2xpY2VkVG9BcnJheTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zbGljZWRUb0FycmF5Mik7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxudmFyIF9pbmhlcml0czIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cbnZhciBfQmV6aWVyRWRnZUJhc2UyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Nik7XG5cbnZhciBfQmV6aWVyRWRnZUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmV6aWVyRWRnZUJhc2UyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vKipcbiAqIEEgRHluYW1pYyBCZXppZXIgRWRnZS4gQmV6aWVyIGN1cnZlcyBhcmUgdXNlZCB0byBtb2RlbCBzbW9vdGggZ3JhZHVhbFxuICogY3VydmVzIGluIHBhdGhzIGJldHdlZW4gbm9kZXMuIFRoZSBEeW5hbWljIHBpZWNlIHJlZmVycyB0byBob3cgdGhlIGN1cnZlXG4gKiByZWFjdHMgdG8gcGh5c2ljcyBjaGFuZ2VzLlxuICpcbiAqIEBleHRlbmRzIEJlemllckVkZ2VCYXNlXG4gKi9cbnZhciBCZXppZXJFZGdlRHluYW1pYyA9IGZ1bmN0aW9uIChfQmV6aWVyRWRnZUJhc2UpIHtcbiAgKDAsIF9pbmhlcml0czNbJ2RlZmF1bHQnXSkoQmV6aWVyRWRnZUR5bmFtaWMsIF9CZXppZXJFZGdlQmFzZSk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBCZXppZXJFZGdlRHluYW1pYyhvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIEJlemllckVkZ2VEeW5hbWljKTtcblxuICAgIC8vIC0tPiB0aGlzIGNhbGxzIHRoZSBzZXRPcHRpb25zIGJlbG93XG4gICAgdmFyIF90aGlzID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuM1snZGVmYXVsdCddKSh0aGlzLCAoQmV6aWVyRWRnZUR5bmFtaWMuX19wcm90b19fIHx8ICgwLCBfZ2V0UHJvdG90eXBlT2YyWydkZWZhdWx0J10pKEJlemllckVkZ2VEeW5hbWljKSkuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuICAgIC8vdGhpcy52aWEgPSB1bmRlZmluZWQ7IC8vIEhlcmUgZm9yIGNvbXBsZXRlbmVzcyBidXQgbm90IGFsbG93ZWQgdG8gZGVmaW5lZCBiZWZvcmUgc3VwZXIoKSBpcyBpbnZva2VkLlxuXG5cbiAgICBfdGhpcy5fYm91bmRGdW5jdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnBvc2l0aW9uQmV6aWVyTm9kZSgpO1xuICAgIH07XG4gICAgX3RoaXMuYm9keS5lbWl0dGVyLm9uKCdfcmVwb3NpdGlvbkJlemllck5vZGVzJywgX3RoaXMuX2JvdW5kRnVuY3Rpb24pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKEJlemllckVkZ2VEeW5hbWljLCBbe1xuICAgIGtleTogJ3NldE9wdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIC8vIGNoZWNrIGlmIHRoZSBwaHlzaWNzIGhhcyBjaGFuZ2VkLlxuICAgICAgdmFyIHBoeXNpY3NDaGFuZ2UgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucGh5c2ljcyAhPT0gb3B0aW9ucy5waHlzaWNzKSB7XG4gICAgICAgIHBoeXNpY3NDaGFuZ2UgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBzZXQgdGhlIG9wdGlvbnMgYW5kIHRoZSB0byBhbmQgZnJvbSBub2Rlc1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIHRoaXMuaWQgPSB0aGlzLm9wdGlvbnMuaWQ7XG4gICAgICB0aGlzLmZyb20gPSB0aGlzLmJvZHkubm9kZXNbdGhpcy5vcHRpb25zLmZyb21dO1xuICAgICAgdGhpcy50byA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLm9wdGlvbnMudG9dO1xuXG4gICAgICAvLyBzZXR1cCB0aGUgc3VwcG9ydCBub2RlIGFuZCBjb25uZWN0XG4gICAgICB0aGlzLnNldHVwU3VwcG9ydE5vZGUoKTtcbiAgICAgIHRoaXMuY29ubmVjdCgpO1xuXG4gICAgICAvLyB3aGVuIHdlIGNoYW5nZSB0aGUgcGh5c2ljcyBzdGF0ZSBvZiB0aGUgZWRnZSwgd2UgcmVwb3NpdGlvbiB0aGUgc3VwcG9ydCBub2RlLlxuICAgICAgaWYgKHBoeXNpY3NDaGFuZ2UgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy52aWEuc2V0T3B0aW9ucyh7IHBoeXNpY3M6IHRoaXMub3B0aW9ucy5waHlzaWNzIH0pO1xuICAgICAgICB0aGlzLnBvc2l0aW9uQmV6aWVyTm9kZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbm5lY3RzIGFuIGVkZ2UgdG8gbm9kZShzKVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdjb25uZWN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29ubmVjdCgpIHtcbiAgICAgIHRoaXMuZnJvbSA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLm9wdGlvbnMuZnJvbV07XG4gICAgICB0aGlzLnRvID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMub3B0aW9ucy50b107XG4gICAgICBpZiAodGhpcy5mcm9tID09PSB1bmRlZmluZWQgfHwgdGhpcy50byA9PT0gdW5kZWZpbmVkIHx8IHRoaXMub3B0aW9ucy5waHlzaWNzID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLnZpYS5zZXRPcHRpb25zKHsgcGh5c2ljczogZmFsc2UgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBmaXggd2VpcmQgYmVoYXZpb3VyIHdoZXJlIGEgc2VsZiByZWZlcmVuY2luZyBub2RlIGhhcyBwaHlzaWNzIGVuYWJsZWRcbiAgICAgICAgaWYgKHRoaXMuZnJvbS5pZCA9PT0gdGhpcy50by5pZCkge1xuICAgICAgICAgIHRoaXMudmlhLnNldE9wdGlvbnMoeyBwaHlzaWNzOiBmYWxzZSB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnZpYS5zZXRPcHRpb25zKHsgcGh5c2ljczogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSB0aGUgc3VwcG9ydCBub2Rlc1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdjbGVhbnVwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9mZignX3JlcG9zaXRpb25CZXppZXJOb2RlcycsIHRoaXMuX2JvdW5kRnVuY3Rpb24pO1xuICAgICAgaWYgKHRoaXMudmlhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuYm9keS5ub2Rlc1t0aGlzLnZpYS5pZF07XG4gICAgICAgIHRoaXMudmlhID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCZXppZXIgY3VydmVzIHJlcXVpcmUgYW4gYW5jaG9yIHBvaW50IHRvIGNhbGN1bGF0ZSB0aGUgc21vb3RoIGZsb3cuIFRoZXNlIHBvaW50cyBhcmUgbm9kZXMuIFRoZXNlIG5vZGVzIGFyZSBpbnZpc2libGUgYnV0XG4gICAgICogYXJlIHVzZWQgZm9yIHRoZSBmb3JjZSBjYWxjdWxhdGlvbi5cbiAgICAgKlxuICAgICAqIFRoZSBjaGFuZ2VkIGRhdGEgaXMgbm90IGNhbGxlZCwgaWYgbmVlZGVkLCBpdCBpcyByZXR1cm5lZCBieSB0aGUgbWFpbiBlZGdlIGNvbnN0cnVjdG9yLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldHVwU3VwcG9ydE5vZGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXR1cFN1cHBvcnROb2RlKCkge1xuICAgICAgaWYgKHRoaXMudmlhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIG5vZGVJZCA9ICdlZGdlSWQ6JyArIHRoaXMuaWQ7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5LmZ1bmN0aW9ucy5jcmVhdGVOb2RlKHtcbiAgICAgICAgICBpZDogbm9kZUlkLFxuICAgICAgICAgIHNoYXBlOiAnY2lyY2xlJyxcbiAgICAgICAgICBwaHlzaWNzOiB0cnVlLFxuICAgICAgICAgIGhpZGRlbjogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0gPSBub2RlO1xuICAgICAgICB0aGlzLnZpYSA9IG5vZGU7XG4gICAgICAgIHRoaXMudmlhLnBhcmVudEVkZ2VJZCA9IHRoaXMuaWQ7XG4gICAgICAgIHRoaXMucG9zaXRpb25CZXppZXJOb2RlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUG9zaXRpb25zIGJlemllciBub2RlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Bvc2l0aW9uQmV6aWVyTm9kZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvc2l0aW9uQmV6aWVyTm9kZSgpIHtcbiAgICAgIGlmICh0aGlzLnZpYSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZnJvbSAhPT0gdW5kZWZpbmVkICYmIHRoaXMudG8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnZpYS54ID0gMC41ICogKHRoaXMuZnJvbS54ICsgdGhpcy50by54KTtcbiAgICAgICAgdGhpcy52aWEueSA9IDAuNSAqICh0aGlzLmZyb20ueSArIHRoaXMudG8ueSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMudmlhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy52aWEueCA9IDA7XG4gICAgICAgIHRoaXMudmlhLnkgPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyYXcgYSBsaW5lIGJldHdlZW4gdHdvIG5vZGVzXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge05vZGV9IHZpYU5vZGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfbGluZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9saW5lKGN0eCwgdmFsdWVzLCB2aWFOb2RlKSB7XG4gICAgICB0aGlzLl9iZXppZXJDdXJ2ZShjdHgsIHZhbHVlcywgdmlhTm9kZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Tm9kZXx1bmRlZmluZWR8Knx7aW5kZXgsIGxpbmUsIGNvbHVtbn19XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldFZpYU5vZGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWaWFOb2RlKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmlhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbWJpbmVkIGZ1bmN0aW9uIG9mIHBvaW50T25MaW5lIGFuZCBwb2ludE9uQmV6aWVyLiBUaGlzIGdpdmVzIHRoZSBjb29yZGluYXRlcyBvZiBhIHBvaW50IG9uIHRoZSBsaW5lIGF0IGEgY2VydGFpbiBwZXJjZW50YWdlIG9mIHRoZSB3YXlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwZXJjZW50YWdlXG4gICAgICogQHBhcmFtIHtOb2RlfSB2aWFOb2RlXG4gICAgICogQHJldHVybnMge3t4OiBudW1iZXIsIHk6IG51bWJlcn19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0UG9pbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb2ludChwZXJjZW50YWdlKSB7XG4gICAgICB2YXIgdmlhTm9kZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy52aWE7XG5cbiAgICAgIHZhciB0ID0gcGVyY2VudGFnZTtcbiAgICAgIHZhciB4ID0gdm9pZCAwLFxuICAgICAgICAgIHkgPSB2b2lkIDA7XG4gICAgICBpZiAodGhpcy5mcm9tID09PSB0aGlzLnRvKSB7XG4gICAgICAgIHZhciBfZ2V0Q2lyY2xlRGF0YSA9IHRoaXMuX2dldENpcmNsZURhdGEodGhpcy5mcm9tKSxcbiAgICAgICAgICAgIF9nZXRDaXJjbGVEYXRhMiA9ICgwLCBfc2xpY2VkVG9BcnJheTNbJ2RlZmF1bHQnXSkoX2dldENpcmNsZURhdGEsIDMpLFxuICAgICAgICAgICAgY3ggPSBfZ2V0Q2lyY2xlRGF0YTJbMF0sXG4gICAgICAgICAgICBjeSA9IF9nZXRDaXJjbGVEYXRhMlsxXSxcbiAgICAgICAgICAgIGNyID0gX2dldENpcmNsZURhdGEyWzJdO1xuXG4gICAgICAgIHZhciBhID0gMiAqIE1hdGguUEkgKiAoMSAtIHQpO1xuICAgICAgICB4ID0gY3ggKyBjciAqIE1hdGguc2luKGEpO1xuICAgICAgICB5ID0gY3kgKyBjciAtIGNyICogKDEgLSBNYXRoLmNvcyhhKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0gTWF0aC5wb3coMSAtIHQsIDIpICogdGhpcy5mcm9tUG9pbnQueCArIDIgKiB0ICogKDEgLSB0KSAqIHZpYU5vZGUueCArIE1hdGgucG93KHQsIDIpICogdGhpcy50b1BvaW50Lng7XG4gICAgICAgIHkgPSBNYXRoLnBvdygxIC0gdCwgMikgKiB0aGlzLmZyb21Qb2ludC55ICsgMiAqIHQgKiAoMSAtIHQpICogdmlhTm9kZS55ICsgTWF0aC5wb3codCwgMikgKiB0aGlzLnRvUG9pbnQueTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgeDogeCwgeTogeSB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBuZWFyTm9kZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZmluZEJvcmRlclBvc2l0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRCb3JkZXJQb3NpdGlvbihuZWFyTm9kZSwgY3R4KSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uQmV6aWVyKG5lYXJOb2RlLCBjdHgsIHRoaXMudmlhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4M1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5M1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2dldERpc3RhbmNlVG9FZGdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERpc3RhbmNlVG9FZGdlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICAgIC8vIHgzLHkzIGlzIHRoZSBwb2ludFxuICAgICAgcmV0dXJuIHRoaXMuX2dldERpc3RhbmNlVG9CZXppZXJFZGdlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHRoaXMudmlhKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEJlemllckVkZ2VEeW5hbWljO1xufShfQmV6aWVyRWRnZUJhc2UzWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBCZXppZXJFZGdlRHluYW1pYztcblxuLyoqKi8gfSksXG4vKiAxNjkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9nZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxudmFyIF9CZXppZXJFZGdlQmFzZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2KTtcblxudmFyIF9CZXppZXJFZGdlQmFzZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9CZXppZXJFZGdlQmFzZTIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbi8qKlxuICogQSBTdGF0aWMgQmV6aWVyIEVkZ2UuIEJlemllciBjdXJ2ZXMgYXJlIHVzZWQgdG8gbW9kZWwgc21vb3RoIGdyYWR1YWxcbiAqIGN1cnZlcyBpbiBwYXRocyBiZXR3ZWVuIG5vZGVzLlxuICpcbiAqIEBleHRlbmRzIEJlemllckVkZ2VCYXNlXG4gKi9cbnZhciBCZXppZXJFZGdlU3RhdGljID0gZnVuY3Rpb24gKF9CZXppZXJFZGdlQmFzZSkge1xuICAoMCwgX2luaGVyaXRzM1snZGVmYXVsdCddKShCZXppZXJFZGdlU3RhdGljLCBfQmV6aWVyRWRnZUJhc2UpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gQmV6aWVyRWRnZVN0YXRpYyhvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIEJlemllckVkZ2VTdGF0aWMpO1xuICAgIHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zWydkZWZhdWx0J10pKHRoaXMsIChCZXppZXJFZGdlU3RhdGljLl9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMlsnZGVmYXVsdCddKShCZXppZXJFZGdlU3RhdGljKSkuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIERyYXcgYSBsaW5lIGJldHdlZW4gdHdvIG5vZGVzXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgKiBAcGFyYW0ge05vZGV9IHZpYU5vZGVcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzM1snZGVmYXVsdCddKShCZXppZXJFZGdlU3RhdGljLCBbe1xuICAgIGtleTogJ19saW5lJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2xpbmUoY3R4LCB2YWx1ZXMsIHZpYU5vZGUpIHtcbiAgICAgIHRoaXMuX2JlemllckN1cnZlKGN0eCwgdmFsdWVzLCB2aWFOb2RlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48e3g6IG51bWJlciwgeTogbnVtYmVyfT59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldFZpYU5vZGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWaWFOb2RlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2UgZG8gbm90IHVzZSB0aGUgdG8gYW5kIGZyb21Qb2ludHMgaGVyZSB0byBtYWtlIHRoZSB2aWEgbm9kZXMgdGhlIHNhbWUgYXMgZWRnZXMgd2l0aG91dCBhcnJvd3MuXG4gICAgICogQHJldHVybnMge3t4OiB1bmRlZmluZWQsIHk6IHVuZGVmaW5lZH19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2dldFZpYUNvb3JkaW5hdGVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFZpYUNvb3JkaW5hdGVzKCkge1xuICAgICAgLy8gQXNzdW1wdGlvbjogeC95IGNvb3JkaW5hdGVzIGluIGZyb20vdG8gYWx3YXlzIGRlZmluZWRcbiAgICAgIHZhciB4VmlhID0gdW5kZWZpbmVkO1xuICAgICAgdmFyIHlWaWEgPSB1bmRlZmluZWQ7XG4gICAgICB2YXIgZmFjdG9yID0gdGhpcy5vcHRpb25zLnNtb290aC5yb3VuZG5lc3M7XG4gICAgICB2YXIgdHlwZSA9IHRoaXMub3B0aW9ucy5zbW9vdGgudHlwZTtcbiAgICAgIHZhciBkeCA9IE1hdGguYWJzKHRoaXMuZnJvbS54IC0gdGhpcy50by54KTtcbiAgICAgIHZhciBkeSA9IE1hdGguYWJzKHRoaXMuZnJvbS55IC0gdGhpcy50by55KTtcbiAgICAgIGlmICh0eXBlID09PSAnZGlzY3JldGUnIHx8IHR5cGUgPT09ICdkaWFnb25hbENyb3NzJykge1xuICAgICAgICB2YXIgc3RlcFggPSB2b2lkIDA7XG4gICAgICAgIHZhciBzdGVwWSA9IHZvaWQgMDtcblxuICAgICAgICBpZiAoZHggPD0gZHkpIHtcbiAgICAgICAgICBzdGVwWCA9IHN0ZXBZID0gZmFjdG9yICogZHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RlcFggPSBzdGVwWSA9IGZhY3RvciAqIGR4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZnJvbS54ID4gdGhpcy50by54KSBzdGVwWCA9IC1zdGVwWDtcbiAgICAgICAgaWYgKHRoaXMuZnJvbS55ID49IHRoaXMudG8ueSkgc3RlcFkgPSAtc3RlcFk7XG5cbiAgICAgICAgeFZpYSA9IHRoaXMuZnJvbS54ICsgc3RlcFg7XG4gICAgICAgIHlWaWEgPSB0aGlzLmZyb20ueSArIHN0ZXBZO1xuXG4gICAgICAgIGlmICh0eXBlID09PSAnZGlzY3JldGUnKSB7XG4gICAgICAgICAgaWYgKGR4IDw9IGR5KSB7XG4gICAgICAgICAgICB4VmlhID0gZHggPCBmYWN0b3IgKiBkeSA/IHRoaXMuZnJvbS54IDogeFZpYTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeVZpYSA9IGR5IDwgZmFjdG9yICogZHggPyB0aGlzLmZyb20ueSA6IHlWaWE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJhaWdodENyb3NzJykge1xuICAgICAgICB2YXIgX3N0ZXBYID0gKDEgLSBmYWN0b3IpICogZHg7XG4gICAgICAgIHZhciBfc3RlcFkgPSAoMSAtIGZhY3RvcikgKiBkeTtcblxuICAgICAgICBpZiAoZHggPD0gZHkpIHtcbiAgICAgICAgICAvLyB1cCAtIGRvd25cbiAgICAgICAgICBfc3RlcFggPSAwO1xuICAgICAgICAgIGlmICh0aGlzLmZyb20ueSA8IHRoaXMudG8ueSkgX3N0ZXBZID0gLV9zdGVwWTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBsZWZ0IC0gcmlnaHRcbiAgICAgICAgICBpZiAodGhpcy5mcm9tLnggPCB0aGlzLnRvLngpIF9zdGVwWCA9IC1fc3RlcFg7XG4gICAgICAgICAgX3N0ZXBZID0gMDtcbiAgICAgICAgfVxuICAgICAgICB4VmlhID0gdGhpcy50by54ICsgX3N0ZXBYO1xuICAgICAgICB5VmlhID0gdGhpcy50by55ICsgX3N0ZXBZO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgdmFyIF9zdGVwWDIgPSAoMSAtIGZhY3RvcikgKiBkeDtcbiAgICAgICAgaWYgKHRoaXMuZnJvbS54IDwgdGhpcy50by54KSBfc3RlcFgyID0gLV9zdGVwWDI7XG4gICAgICAgIHhWaWEgPSB0aGlzLnRvLnggKyBfc3RlcFgyO1xuICAgICAgICB5VmlhID0gdGhpcy5mcm9tLnk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgdmFyIF9zdGVwWTIgPSAoMSAtIGZhY3RvcikgKiBkeTtcbiAgICAgICAgaWYgKHRoaXMuZnJvbS55IDwgdGhpcy50by55KSBfc3RlcFkyID0gLV9zdGVwWTI7XG4gICAgICAgIHhWaWEgPSB0aGlzLmZyb20ueDtcbiAgICAgICAgeVZpYSA9IHRoaXMudG8ueSArIF9zdGVwWTI7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjdXJ2ZWRDVycpIHtcbiAgICAgICAgZHggPSB0aGlzLnRvLnggLSB0aGlzLmZyb20ueDtcbiAgICAgICAgZHkgPSB0aGlzLmZyb20ueSAtIHRoaXMudG8ueTtcbiAgICAgICAgdmFyIHJhZGl1cyA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgIHZhciBwaSA9IE1hdGguUEk7XG5cbiAgICAgICAgdmFyIG9yaWdpbmFsQW5nbGUgPSBNYXRoLmF0YW4yKGR5LCBkeCk7XG4gICAgICAgIHZhciBteUFuZ2xlID0gKG9yaWdpbmFsQW5nbGUgKyAoZmFjdG9yICogMC41ICsgMC41KSAqIHBpKSAlICgyICogcGkpO1xuXG4gICAgICAgIHhWaWEgPSB0aGlzLmZyb20ueCArIChmYWN0b3IgKiAwLjUgKyAwLjUpICogcmFkaXVzICogTWF0aC5zaW4obXlBbmdsZSk7XG4gICAgICAgIHlWaWEgPSB0aGlzLmZyb20ueSArIChmYWN0b3IgKiAwLjUgKyAwLjUpICogcmFkaXVzICogTWF0aC5jb3MobXlBbmdsZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjdXJ2ZWRDQ1cnKSB7XG4gICAgICAgIGR4ID0gdGhpcy50by54IC0gdGhpcy5mcm9tLng7XG4gICAgICAgIGR5ID0gdGhpcy5mcm9tLnkgLSB0aGlzLnRvLnk7XG4gICAgICAgIHZhciBfcmFkaXVzID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgdmFyIF9waSA9IE1hdGguUEk7XG5cbiAgICAgICAgdmFyIF9vcmlnaW5hbEFuZ2xlID0gTWF0aC5hdGFuMihkeSwgZHgpO1xuICAgICAgICB2YXIgX215QW5nbGUgPSAoX29yaWdpbmFsQW5nbGUgKyAoLWZhY3RvciAqIDAuNSArIDAuNSkgKiBfcGkpICUgKDIgKiBfcGkpO1xuXG4gICAgICAgIHhWaWEgPSB0aGlzLmZyb20ueCArIChmYWN0b3IgKiAwLjUgKyAwLjUpICogX3JhZGl1cyAqIE1hdGguc2luKF9teUFuZ2xlKTtcbiAgICAgICAgeVZpYSA9IHRoaXMuZnJvbS55ICsgKGZhY3RvciAqIDAuNSArIDAuNSkgKiBfcmFkaXVzICogTWF0aC5jb3MoX215QW5nbGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY29udGludW91c1xuICAgICAgICB2YXIgX3N0ZXBYMyA9IHZvaWQgMDtcbiAgICAgICAgdmFyIF9zdGVwWTMgPSB2b2lkIDA7XG5cbiAgICAgICAgaWYgKGR4IDw9IGR5KSB7XG4gICAgICAgICAgX3N0ZXBYMyA9IF9zdGVwWTMgPSBmYWN0b3IgKiBkeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfc3RlcFgzID0gX3N0ZXBZMyA9IGZhY3RvciAqIGR4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZnJvbS54ID4gdGhpcy50by54KSBfc3RlcFgzID0gLV9zdGVwWDM7XG4gICAgICAgIGlmICh0aGlzLmZyb20ueSA+PSB0aGlzLnRvLnkpIF9zdGVwWTMgPSAtX3N0ZXBZMztcblxuICAgICAgICB4VmlhID0gdGhpcy5mcm9tLnggKyBfc3RlcFgzO1xuICAgICAgICB5VmlhID0gdGhpcy5mcm9tLnkgKyBfc3RlcFkzO1xuXG4gICAgICAgIGlmIChkeCA8PSBkeSkge1xuICAgICAgICAgIGlmICh0aGlzLmZyb20ueCA8PSB0aGlzLnRvLngpIHtcbiAgICAgICAgICAgIHhWaWEgPSB0aGlzLnRvLnggPCB4VmlhID8gdGhpcy50by54IDogeFZpYTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeFZpYSA9IHRoaXMudG8ueCA+IHhWaWEgPyB0aGlzLnRvLnggOiB4VmlhO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5mcm9tLnkgPj0gdGhpcy50by55KSB7XG4gICAgICAgICAgICB5VmlhID0gdGhpcy50by55ID4geVZpYSA/IHRoaXMudG8ueSA6IHlWaWE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHlWaWEgPSB0aGlzLnRvLnkgPCB5VmlhID8gdGhpcy50by55IDogeVZpYTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHg6IHhWaWEsIHk6IHlWaWEgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbmVhck5vZGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZmluZEJvcmRlclBvc2l0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRCb3JkZXJQb3NpdGlvbihuZWFyTm9kZSwgY3R4KSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIHJldHVybiB0aGlzLl9maW5kQm9yZGVyUG9zaXRpb25CZXppZXIobmVhck5vZGUsIGN0eCwgb3B0aW9ucy52aWEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkzXG4gICAgICogQHBhcmFtIHtOb2RlfSB2aWFOb2RlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZ2V0RGlzdGFuY2VUb0VkZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGlzdGFuY2VUb0VkZ2UoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgICAgdmFyIHZpYU5vZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gNiAmJiBhcmd1bWVudHNbNl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s2XSA6IHRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKCk7XG5cbiAgICAgIC8vIHgzLHkzIGlzIHRoZSBwb2ludFxuICAgICAgcmV0dXJuIHRoaXMuX2dldERpc3RhbmNlVG9CZXppZXJFZGdlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHZpYU5vZGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbWJpbmVkIGZ1bmN0aW9uIG9mIHBvaW50T25MaW5lIGFuZCBwb2ludE9uQmV6aWVyLiBUaGlzIGdpdmVzIHRoZSBjb29yZGluYXRlcyBvZiBhIHBvaW50IG9uIHRoZSBsaW5lIGF0IGEgY2VydGFpbiBwZXJjZW50YWdlIG9mIHRoZSB3YXlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGVyY2VudGFnZVxuICAgICAqIEBwYXJhbSB7Tm9kZX0gdmlhTm9kZVxuICAgICAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldFBvaW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9pbnQocGVyY2VudGFnZSkge1xuICAgICAgdmFyIHZpYU5vZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKCk7XG5cbiAgICAgIHZhciB0ID0gcGVyY2VudGFnZTtcbiAgICAgIHZhciB4ID0gTWF0aC5wb3coMSAtIHQsIDIpICogdGhpcy5mcm9tUG9pbnQueCArIDIgKiB0ICogKDEgLSB0KSAqIHZpYU5vZGUueCArIE1hdGgucG93KHQsIDIpICogdGhpcy50b1BvaW50Lng7XG4gICAgICB2YXIgeSA9IE1hdGgucG93KDEgLSB0LCAyKSAqIHRoaXMuZnJvbVBvaW50LnkgKyAyICogdCAqICgxIC0gdCkgKiB2aWFOb2RlLnkgKyBNYXRoLnBvdyh0LCAyKSAqIHRoaXMudG9Qb2ludC55O1xuXG4gICAgICByZXR1cm4geyB4OiB4LCB5OiB5IH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBCZXppZXJFZGdlU3RhdGljO1xufShfQmV6aWVyRWRnZUJhc2UzWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBCZXppZXJFZGdlU3RhdGljO1xuXG4vKioqLyB9KSxcbi8qIDE3MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2dldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cbnZhciBfaW5oZXJpdHMyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG52YXIgX0VkZ2VCYXNlMiA9IF9fd2VicGFja19yZXF1aXJlX18oNzkpO1xuXG52YXIgX0VkZ2VCYXNlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0VkZ2VCYXNlMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLyoqXG4gKiBBIFN0cmFpZ2h0IEVkZ2UuXG4gKlxuICogQGV4dGVuZHMgRWRnZUJhc2VcbiAqL1xudmFyIFN0cmFpZ2h0RWRnZSA9IGZ1bmN0aW9uIChfRWRnZUJhc2UpIHtcbiAgKDAsIF9pbmhlcml0czNbJ2RlZmF1bHQnXSkoU3RyYWlnaHRFZGdlLCBfRWRnZUJhc2UpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gU3RyYWlnaHRFZGdlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgU3RyYWlnaHRFZGdlKTtcbiAgICByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuM1snZGVmYXVsdCddKSh0aGlzLCAoU3RyYWlnaHRFZGdlLl9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMlsnZGVmYXVsdCddKShTdHJhaWdodEVkZ2UpKS5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSk7XG4gIH1cblxuICAvKipcbiAgICogRHJhdyBhIGxpbmUgYmV0d2VlbiB0d28gbm9kZXNcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoU3RyYWlnaHRFZGdlLCBbe1xuICAgIGtleTogJ19saW5lJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2xpbmUoY3R4LCB2YWx1ZXMpIHtcbiAgICAgIC8vIGRyYXcgYSBzdHJhaWdodCBsaW5lXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKHRoaXMuZnJvbVBvaW50LngsIHRoaXMuZnJvbVBvaW50LnkpO1xuICAgICAgY3R4LmxpbmVUbyh0aGlzLnRvUG9pbnQueCwgdGhpcy50b1BvaW50LnkpO1xuICAgICAgLy8gZHJhdyBzaGFkb3cgaWYgZW5hYmxlZFxuICAgICAgdGhpcy5lbmFibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldFZpYU5vZGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWaWFOb2RlKCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21iaW5lZCBmdW5jdGlvbiBvZiBwb2ludE9uTGluZSBhbmQgcG9pbnRPbkJlemllci4gVGhpcyBnaXZlcyB0aGUgY29vcmRpbmF0ZXMgb2YgYSBwb2ludCBvbiB0aGUgbGluZSBhdCBhIGNlcnRhaW4gcGVyY2VudGFnZSBvZiB0aGUgd2F5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGVyY2VudGFnZVxuICAgICAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldFBvaW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9pbnQocGVyY2VudGFnZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogKDEgLSBwZXJjZW50YWdlKSAqIHRoaXMuZnJvbVBvaW50LnggKyBwZXJjZW50YWdlICogdGhpcy50b1BvaW50LngsXG4gICAgICAgIHk6ICgxIC0gcGVyY2VudGFnZSkgKiB0aGlzLmZyb21Qb2ludC55ICsgcGVyY2VudGFnZSAqIHRoaXMudG9Qb2ludC55XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBuZWFyTm9kZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcmV0dXJucyB7e3g6IG51bWJlciwgeTogbnVtYmVyfX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZmluZEJvcmRlclBvc2l0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRCb3JkZXJQb3NpdGlvbihuZWFyTm9kZSwgY3R4KSB7XG4gICAgICB2YXIgbm9kZTEgPSB0aGlzLnRvO1xuICAgICAgdmFyIG5vZGUyID0gdGhpcy5mcm9tO1xuICAgICAgaWYgKG5lYXJOb2RlLmlkID09PSB0aGlzLmZyb20uaWQpIHtcbiAgICAgICAgbm9kZTEgPSB0aGlzLmZyb207XG4gICAgICAgIG5vZGUyID0gdGhpcy50bztcbiAgICAgIH1cblxuICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMihub2RlMS55IC0gbm9kZTIueSwgbm9kZTEueCAtIG5vZGUyLngpO1xuICAgICAgdmFyIGR4ID0gbm9kZTEueCAtIG5vZGUyLng7XG4gICAgICB2YXIgZHkgPSBub2RlMS55IC0gbm9kZTIueTtcbiAgICAgIHZhciBlZGdlU2VnbWVudExlbmd0aCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICB2YXIgdG9Cb3JkZXJEaXN0ID0gbmVhck5vZGUuZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICAgIHZhciB0b0JvcmRlclBvaW50ID0gKGVkZ2VTZWdtZW50TGVuZ3RoIC0gdG9Cb3JkZXJEaXN0KSAvIGVkZ2VTZWdtZW50TGVuZ3RoO1xuXG4gICAgICB2YXIgYm9yZGVyUG9zID0ge307XG4gICAgICBib3JkZXJQb3MueCA9ICgxIC0gdG9Cb3JkZXJQb2ludCkgKiBub2RlMi54ICsgdG9Cb3JkZXJQb2ludCAqIG5vZGUxLng7XG4gICAgICBib3JkZXJQb3MueSA9ICgxIC0gdG9Cb3JkZXJQb2ludCkgKiBub2RlMi55ICsgdG9Cb3JkZXJQb2ludCAqIG5vZGUxLnk7XG5cbiAgICAgIHJldHVybiBib3JkZXJQb3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19nZXREaXN0YW5jZVRvRWRnZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXREaXN0YW5jZVRvRWRnZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgICAvLyB4Myx5MyBpcyB0aGUgcG9pbnRcbiAgICAgIHJldHVybiB0aGlzLl9nZXREaXN0YW5jZVRvTGluZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFN0cmFpZ2h0RWRnZTtcbn0oX0VkZ2VCYXNlM1snZGVmYXVsdCddKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gU3RyYWlnaHRFZGdlO1xuXG4vKioqLyB9KSxcbi8qIDE3MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2tleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG52YXIgX2tleXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfa2V5cyk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgQmFybmVzSHV0U29sdmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MSlbJ2RlZmF1bHQnXTtcbnZhciBSZXB1bHNpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3MilbJ2RlZmF1bHQnXTtcbnZhciBIaWVyYXJjaGljYWxSZXB1bHNpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3MylbJ2RlZmF1bHQnXTtcbnZhciBTcHJpbmdTb2x2ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3NClbJ2RlZmF1bHQnXTtcbnZhciBIaWVyYXJjaGljYWxTcHJpbmdTb2x2ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3NSlbJ2RlZmF1bHQnXTtcbnZhciBDZW50cmFsR3Jhdml0eVNvbHZlciA9IF9fd2VicGFja19yZXF1aXJlX18oODIpWydkZWZhdWx0J107XG52YXIgRm9yY2VBdGxhczJCYXNlZFJlcHVsc2lvblNvbHZlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTc2KVsnZGVmYXVsdCddO1xudmFyIEZvcmNlQXRsYXMyQmFzZWRDZW50cmFsR3Jhdml0eVNvbHZlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTc3KVsnZGVmYXVsdCddO1xudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xudmFyIEVuZFBvaW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oODApWydkZWZhdWx0J107IC8vIGZvciBkZWJ1Z2dpbmcgd2l0aCBfZHJhd0ZvcmNlcygpXG5cbi8qKlxuICogVGhlIHBoeXNpY3MgZW5naW5lXG4gKi9cblxudmFyIFBoeXNpY3NFbmdpbmUgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgKi9cbiAgZnVuY3Rpb24gUGh5c2ljc0VuZ2luZShib2R5KSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgUGh5c2ljc0VuZ2luZSk7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMucGh5c2ljc0JvZHkgPSB7XG4gICAgICBwaHlzaWNzTm9kZUluZGljZXM6IFtdLFxuICAgICAgcGh5c2ljc0VkZ2VJbmRpY2VzOiBbXSxcbiAgICAgIGZvcmNlczoge30sXG4gICAgICB2ZWxvY2l0aWVzOiB7fVxuICAgIH07XG5cbiAgICB0aGlzLnBoeXNpY3NFbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLnNpbXVsYXRpb25JbnRlcnZhbCA9IDEwMDAgLyA2MDtcbiAgICB0aGlzLnJlcXVpcmVzVGltZW91dCA9IHRydWU7XG4gICAgdGhpcy5wcmV2aW91c1N0YXRlcyA9IHt9O1xuICAgIHRoaXMucmVmZXJlbmNlU3RhdGUgPSB7fTtcbiAgICB0aGlzLmZyZWV6ZUNhY2hlID0ge307XG4gICAgdGhpcy5yZW5kZXJUaW1lciA9IHVuZGVmaW5lZDtcblxuICAgIC8vIHBhcmFtZXRlcnMgZm9yIHRoZSBhZGFwdGl2ZSB0aW1lc3RlcFxuICAgIHRoaXMuYWRhcHRpdmVUaW1lc3RlcCA9IGZhbHNlO1xuICAgIHRoaXMuYWRhcHRpdmVUaW1lc3RlcEVuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmFkYXB0aXZlQ291bnRlciA9IDA7XG4gICAgdGhpcy5hZGFwdGl2ZUludGVydmFsID0gMztcblxuICAgIHRoaXMuc3RhYmlsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuc3RhcnRlZFN0YWJpbGl6YXRpb24gPSBmYWxzZTtcbiAgICB0aGlzLnN0YWJpbGl6YXRpb25JdGVyYXRpb25zID0gMDtcbiAgICB0aGlzLnJlYWR5ID0gZmFsc2U7IC8vIHdpbGwgYmUgc2V0IHRvIHRydWUgaWYgdGhlIHN0YWJpbGl6ZVxuXG4gICAgLy8gZGVmYXVsdCBvcHRpb25zXG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICBiYXJuZXNIdXQ6IHtcbiAgICAgICAgdGhldGE6IDAuNSxcbiAgICAgICAgZ3Jhdml0YXRpb25hbENvbnN0YW50OiAtMjAwMCxcbiAgICAgICAgY2VudHJhbEdyYXZpdHk6IDAuMyxcbiAgICAgICAgc3ByaW5nTGVuZ3RoOiA5NSxcbiAgICAgICAgc3ByaW5nQ29uc3RhbnQ6IDAuMDQsXG4gICAgICAgIGRhbXBpbmc6IDAuMDksXG4gICAgICAgIGF2b2lkT3ZlcmxhcDogMFxuICAgICAgfSxcbiAgICAgIGZvcmNlQXRsYXMyQmFzZWQ6IHtcbiAgICAgICAgdGhldGE6IDAuNSxcbiAgICAgICAgZ3Jhdml0YXRpb25hbENvbnN0YW50OiAtNTAsXG4gICAgICAgIGNlbnRyYWxHcmF2aXR5OiAwLjAxLFxuICAgICAgICBzcHJpbmdDb25zdGFudDogMC4wOCxcbiAgICAgICAgc3ByaW5nTGVuZ3RoOiAxMDAsXG4gICAgICAgIGRhbXBpbmc6IDAuNCxcbiAgICAgICAgYXZvaWRPdmVybGFwOiAwXG4gICAgICB9LFxuICAgICAgcmVwdWxzaW9uOiB7XG4gICAgICAgIGNlbnRyYWxHcmF2aXR5OiAwLjIsXG4gICAgICAgIHNwcmluZ0xlbmd0aDogMjAwLFxuICAgICAgICBzcHJpbmdDb25zdGFudDogMC4wNSxcbiAgICAgICAgbm9kZURpc3RhbmNlOiAxMDAsXG4gICAgICAgIGRhbXBpbmc6IDAuMDksXG4gICAgICAgIGF2b2lkT3ZlcmxhcDogMFxuICAgICAgfSxcbiAgICAgIGhpZXJhcmNoaWNhbFJlcHVsc2lvbjoge1xuICAgICAgICBjZW50cmFsR3Jhdml0eTogMC4wLFxuICAgICAgICBzcHJpbmdMZW5ndGg6IDEwMCxcbiAgICAgICAgc3ByaW5nQ29uc3RhbnQ6IDAuMDEsXG4gICAgICAgIG5vZGVEaXN0YW5jZTogMTIwLFxuICAgICAgICBkYW1waW5nOiAwLjA5XG4gICAgICB9LFxuICAgICAgbWF4VmVsb2NpdHk6IDUwLFxuICAgICAgbWluVmVsb2NpdHk6IDAuNzUsIC8vIHB4L3NcbiAgICAgIHNvbHZlcjogJ2Jhcm5lc0h1dCcsXG4gICAgICBzdGFiaWxpemF0aW9uOiB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGl0ZXJhdGlvbnM6IDEwMDAsIC8vIG1heGltdW0gbnVtYmVyIG9mIGl0ZXJhdGlvbiB0byBzdGFiaWxpemVcbiAgICAgICAgdXBkYXRlSW50ZXJ2YWw6IDUwLFxuICAgICAgICBvbmx5RHluYW1pY0VkZ2VzOiBmYWxzZSxcbiAgICAgICAgZml0OiB0cnVlXG4gICAgICB9LFxuICAgICAgdGltZXN0ZXA6IDAuNSxcbiAgICAgIGFkYXB0aXZlVGltZXN0ZXA6IHRydWVcbiAgICB9O1xuICAgIHV0aWwuZXh0ZW5kKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG4gICAgdGhpcy50aW1lc3RlcCA9IDAuNTtcbiAgICB0aGlzLmxheW91dEZhaWxlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5iaW5kRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kcyBldmVudCBsaXN0ZW5lcnNcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzM1snZGVmYXVsdCddKShQaHlzaWNzRW5naW5lLCBbe1xuICAgIGtleTogJ2JpbmRFdmVudExpc3RlbmVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRFdmVudExpc3RlbmVycygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdpbml0UGh5c2ljcycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuaW5pdFBoeXNpY3MoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ19sYXlvdXRGYWlsZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmxheW91dEZhaWxlZCA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdyZXNldFBoeXNpY3MnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnN0b3BTaW11bGF0aW9uKCk7XG4gICAgICAgIF90aGlzLnJlYWR5ID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdkaXNhYmxlUGh5c2ljcycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMucGh5c2ljc0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuc3RvcFNpbXVsYXRpb24oKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ3Jlc3RvcmVQaHlzaWNzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5zZXRPcHRpb25zKF90aGlzLm9wdGlvbnMpO1xuICAgICAgICBpZiAoX3RoaXMucmVhZHkgPT09IHRydWUpIHtcbiAgICAgICAgICBfdGhpcy5zdGFydFNpbXVsYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignc3RhcnRTaW11bGF0aW9uJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3RoaXMucmVhZHkgPT09IHRydWUpIHtcbiAgICAgICAgICBfdGhpcy5zdGFydFNpbXVsYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignc3RvcFNpbXVsYXRpb24nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnN0b3BTaW11bGF0aW9uKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5zdG9wU2ltdWxhdGlvbihmYWxzZSk7XG4gICAgICAgIF90aGlzLmJvZHkuZW1pdHRlci5vZmYoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ19kYXRhQ2hhbmdlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gTm9kZXMgYW5kL29yIGVkZ2VzIGhhdmUgYmVlbiBhZGRlZCBvciByZW1vdmVkLCB1cGRhdGUgc2hvcnRjdXQgbGlzdHMuXG4gICAgICAgIF90aGlzLnVwZGF0ZVBoeXNpY3NEYXRhKCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gZGVidWc6IHNob3cgZm9yY2VzXG4gICAgICAvLyB0aGlzLmJvZHkuZW1pdHRlci5vbihcImFmdGVyRHJhd2luZ1wiLCAoY3R4KSA9PiB7dGhpcy5fZHJhd0ZvcmNlcyhjdHgpO30pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNldCB0aGUgcGh5c2ljcyBvcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0T3B0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMucGh5c2ljc0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLnN0b3BTaW11bGF0aW9uKCk7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnBoeXNpY3NFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnN0YXJ0U2ltdWxhdGlvbigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucGh5c2ljc0VuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgIHV0aWwuc2VsZWN0aXZlTm90RGVlcEV4dGVuZChbJ3N0YWJpbGl6YXRpb24nXSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgICB1dGlsLm1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMsICdzdGFiaWxpemF0aW9uJyk7XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5lbmFibGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLnBoeXNpY3NFbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnN0b3BTaW11bGF0aW9uKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gc2V0IHRoZSB0aW1lc3RlcFxuICAgICAgICAgIHRoaXMudGltZXN0ZXAgPSB0aGlzLm9wdGlvbnMudGltZXN0ZXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNvbmZpZ3VyZSB0aGUgZW5naW5lLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdpbml0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHZhciBvcHRpb25zO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zb2x2ZXIgPT09ICdmb3JjZUF0bGFzMkJhc2VkJykge1xuICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLmZvcmNlQXRsYXMyQmFzZWQ7XG4gICAgICAgIHRoaXMubm9kZXNTb2x2ZXIgPSBuZXcgRm9yY2VBdGxhczJCYXNlZFJlcHVsc2lvblNvbHZlcih0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmVkZ2VzU29sdmVyID0gbmV3IFNwcmluZ1NvbHZlcih0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmdyYXZpdHlTb2x2ZXIgPSBuZXcgRm9yY2VBdGxhczJCYXNlZENlbnRyYWxHcmF2aXR5U29sdmVyKHRoaXMuYm9keSwgdGhpcy5waHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5zb2x2ZXIgPT09ICdyZXB1bHNpb24nKSB7XG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMucmVwdWxzaW9uO1xuICAgICAgICB0aGlzLm5vZGVzU29sdmVyID0gbmV3IFJlcHVsc2lvbih0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmVkZ2VzU29sdmVyID0gbmV3IFNwcmluZ1NvbHZlcih0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmdyYXZpdHlTb2x2ZXIgPSBuZXcgQ2VudHJhbEdyYXZpdHlTb2x2ZXIodGhpcy5ib2R5LCB0aGlzLnBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnNvbHZlciA9PT0gJ2hpZXJhcmNoaWNhbFJlcHVsc2lvbicpIHtcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWxSZXB1bHNpb247XG4gICAgICAgIHRoaXMubm9kZXNTb2x2ZXIgPSBuZXcgSGllcmFyY2hpY2FsUmVwdWxzaW9uKHRoaXMuYm9keSwgdGhpcy5waHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZWRnZXNTb2x2ZXIgPSBuZXcgSGllcmFyY2hpY2FsU3ByaW5nU29sdmVyKHRoaXMuYm9keSwgdGhpcy5waHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZ3Jhdml0eVNvbHZlciA9IG5ldyBDZW50cmFsR3Jhdml0eVNvbHZlcih0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYmFybmVzSHV0XG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuYmFybmVzSHV0O1xuICAgICAgICB0aGlzLm5vZGVzU29sdmVyID0gbmV3IEJhcm5lc0h1dFNvbHZlcih0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmVkZ2VzU29sdmVyID0gbmV3IFNwcmluZ1NvbHZlcih0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmdyYXZpdHlTb2x2ZXIgPSBuZXcgQ2VudHJhbEdyYXZpdHlTb2x2ZXIodGhpcy5ib2R5LCB0aGlzLnBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5tb2RlbE9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGluaXRpYWxpemUgdGhlIGVuZ2luZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdpbml0UGh5c2ljcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRQaHlzaWNzKCkge1xuICAgICAgaWYgKHRoaXMucGh5c2ljc0VuYWJsZWQgPT09IHRydWUgJiYgdGhpcy5vcHRpb25zLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdGFiaWxpemF0aW9uLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLnN0YWJpbGl6ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3RhYmlsaXplZCA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMucmVhZHkgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ2ZpdCcsIHt9LCB0aGlzLmxheW91dEZhaWxlZCk7IC8vIGlmIHRoZSBsYXlvdXQgZmFpbGVkLCB3ZSB1c2UgdGhlIGFwcHJveGltYXRpb24gZm9yIHRoZSB6b29tXG4gICAgICAgICAgdGhpcy5zdGFydFNpbXVsYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZWFkeSA9IHRydWU7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ2ZpdCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IHRoZSBzaW11bGF0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3N0YXJ0U2ltdWxhdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0U2ltdWxhdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnBoeXNpY3NFbmFibGVkID09PSB0cnVlICYmIHRoaXMub3B0aW9ucy5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuc3RhYmlsaXplZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIHdoZW4gdmlzaWJsZSwgYWRhcHRpdml0eSBpcyBkaXNhYmxlZC5cbiAgICAgICAgdGhpcy5hZGFwdGl2ZVRpbWVzdGVwID0gZmFsc2U7XG5cbiAgICAgICAgLy8gdGhpcyBzZXRzIHRoZSB3aWR0aCBvZiBhbGwgbm9kZXMgaW5pdGlhbGx5IHdoaWNoIGNvdWxkIGJlIHJlcXVpcmVkIGZvciB0aGUgYXZvaWRPdmVybGFwXG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19yZXNpemVOb2RlcycpO1xuICAgICAgICBpZiAodGhpcy52aWV3RnVuY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMudmlld0Z1bmN0aW9uID0gdGhpcy5zaW11bGF0aW9uU3RlcC5iaW5kKHRoaXMpO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdpbml0UmVkcmF3JywgdGhpcy52aWV3RnVuY3Rpb24pO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19zdGFydFJlbmRlcmluZycpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfcmVkcmF3Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RvcCB0aGUgc2ltdWxhdGlvbiwgZm9yY2Ugc3RhYmlsaXphdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtlbWl0PXRydWVdXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3N0b3BTaW11bGF0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcFNpbXVsYXRpb24oKSB7XG4gICAgICB2YXIgZW1pdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcblxuICAgICAgdGhpcy5zdGFiaWxpemVkID0gdHJ1ZTtcbiAgICAgIGlmIChlbWl0ID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX2VtaXRTdGFiaWxpemVkKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy52aWV3RnVuY3Rpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vZmYoJ2luaXRSZWRyYXcnLCB0aGlzLnZpZXdGdW5jdGlvbik7XG4gICAgICAgIHRoaXMudmlld0Z1bmN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoZW1pdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19zdG9wUmVuZGVyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmlld0Z1bmN0aW9uIGluc2VydHMgdGhpcyBzdGVwIGludG8gZWFjaCByZW5kZXIgbG9vcC4gSXQgY2FsbHMgdGhlIHBoeXNpY3MgdGljayBhbmQgaGFuZGxlcyB0aGUgY2xlYW51cCBhdCBzdGFiaWxpemVkLlxuICAgICAqXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NpbXVsYXRpb25TdGVwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2ltdWxhdGlvblN0ZXAoKSB7XG4gICAgICAvLyBjaGVjayBpZiB0aGUgcGh5c2ljcyBoYXZlIHNldHRsZWRcbiAgICAgIHZhciBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgdGhpcy5waHlzaWNzVGljaygpO1xuICAgICAgdmFyIHBoeXNpY3NUaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcblxuICAgICAgLy8gcnVuIGRvdWJsZSBzcGVlZCBpZiBpdCBpcyBhIGxpdHRsZSBncmFwaFxuICAgICAgaWYgKChwaHlzaWNzVGltZSA8IDAuNCAqIHRoaXMuc2ltdWxhdGlvbkludGVydmFsIHx8IHRoaXMucnVuRG91YmxlU3BlZWQgPT09IHRydWUpICYmIHRoaXMuc3RhYmlsaXplZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5waHlzaWNzVGljaygpO1xuXG4gICAgICAgIC8vIHRoaXMgbWFrZXMgc3VyZSB0aGVyZSBpcyBubyBqaXR0ZXIuIFRoZSBkZWNpc2lvbiBpcyB0YWtlbiBvbmNlIHRvIHJ1biBpdCBhdCBkb3VibGUgc3BlZWQuXG4gICAgICAgIHRoaXMucnVuRG91YmxlU3BlZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zdGFiaWxpemVkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuc3RvcFNpbXVsYXRpb24oKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0cmlnZ2VyIHRoZSBzdGFiaWxpemVkIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthbW91bnRPZkl0ZXJhdGlvbnM9dGhpcy5zdGFiaWxpemF0aW9uSXRlcmF0aW9uc11cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZW1pdFN0YWJpbGl6ZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZW1pdFN0YWJpbGl6ZWQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGFtb3VudE9mSXRlcmF0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdGhpcy5zdGFiaWxpemF0aW9uSXRlcmF0aW9ucztcblxuICAgICAgaWYgKHRoaXMuc3RhYmlsaXphdGlvbkl0ZXJhdGlvbnMgPiAxIHx8IHRoaXMuc3RhcnRlZFN0YWJpbGl6YXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMyLmJvZHkuZW1pdHRlci5lbWl0KCdzdGFiaWxpemVkJywgeyBpdGVyYXRpb25zOiBhbW91bnRPZkl0ZXJhdGlvbnMgfSk7XG4gICAgICAgICAgX3RoaXMyLnN0YXJ0ZWRTdGFiaWxpemF0aW9uID0gZmFsc2U7XG4gICAgICAgICAgX3RoaXMyLnN0YWJpbGl6YXRpb25JdGVyYXRpb25zID0gMDtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBmb3JjZXMgZm9yIG9uZSBwaHlzaWNzIGl0ZXJhdGlvbiBhbmQgbW92ZSB0aGUgbm9kZXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncGh5c2ljc1N0ZXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwaHlzaWNzU3RlcCgpIHtcbiAgICAgIHRoaXMuZ3Jhdml0eVNvbHZlci5zb2x2ZSgpO1xuICAgICAgdGhpcy5ub2Rlc1NvbHZlci5zb2x2ZSgpO1xuICAgICAgdGhpcy5lZGdlc1NvbHZlci5zb2x2ZSgpO1xuICAgICAgdGhpcy5tb3ZlTm9kZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGR5bmFtaWMgYWRqdXN0bWVudHMgdG8gdGhlIHRpbWVzdGVwLCBiYXNlZCBvbiBjdXJyZW50IHN0YXRlLlxuICAgICAqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIGZvciBwaHlzaWNzVGljaygpLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2FkanVzdFRpbWVTdGVwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRqdXN0VGltZVN0ZXAoKSB7XG4gICAgICB2YXIgZmFjdG9yID0gMS4yOyAvLyBGYWN0b3IgZm9yIGluY3JlYXNpbmcgdGhlIHRpbWVzdGVwIG9uIHN1Y2Nlc3MuXG5cbiAgICAgIC8vIHdlIGNvbXBhcmUgdGhlIHR3byBzdGVwcy4gaWYgaXQgaXMgYWNjZXB0YWJsZSB3ZSBkb3VibGUgdGhlIHN0ZXAuXG4gICAgICBpZiAodGhpcy5fZXZhbHVhdGVTdGVwUXVhbGl0eSgpID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMudGltZXN0ZXAgPSBmYWN0b3IgKiB0aGlzLnRpbWVzdGVwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgbm90LCB3ZSBkZWNyZWFzZSB0aGUgc3RlcCB0byBhIG1pbmltdW0gb2YgdGhlIG9wdGlvbnMgdGltZXN0ZXAuXG4gICAgICAgIC8vIGlmIHRoZSBkZWNyZWFzZWQgdGltZXN0ZXAgaXMgc21hbGxlciB0aGFuIHRoZSBvcHRpb25zIHN0ZXAsIHdlIGRvIG5vdCByZXNldCB0aGUgY291bnRlclxuICAgICAgICAvLyB3ZSBhc3N1bWUgdGhhdCB0aGUgb3B0aW9ucyB0aW1lc3RlcCBpcyBzdGFibGUgZW5vdWdoLlxuICAgICAgICBpZiAodGhpcy50aW1lc3RlcCAvIGZhY3RvciA8IHRoaXMub3B0aW9ucy50aW1lc3RlcCkge1xuICAgICAgICAgIHRoaXMudGltZXN0ZXAgPSB0aGlzLm9wdGlvbnMudGltZXN0ZXA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaWYgdGhlIHRpbWVzdGVwIHdhcyBsYXJnZXIgdGhhbiAyIHRpbWVzIHRoZSBvcHRpb24gb25lIHdlIGNoZWNrIHRoZSBhZGFwdGl2aXR5IGFnYWluIHRvIGVuc3VyZVxuICAgICAgICAgIC8vIHRoYXQgbGFyZ2UgaW5zdGFiaWxpdGllcyBkbyBub3QgZm9ybS5cbiAgICAgICAgICB0aGlzLmFkYXB0aXZlQ291bnRlciA9IC0xOyAvLyBjaGVjayBhZ2FpbiBuZXh0IGl0ZXJhdGlvblxuICAgICAgICAgIHRoaXMudGltZXN0ZXAgPSBNYXRoLm1heCh0aGlzLm9wdGlvbnMudGltZXN0ZXAsIHRoaXMudGltZXN0ZXAgLyBmYWN0b3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzaW5nbGUgc2ltdWxhdGlvbiBzdGVwIChvciAndGljaycpIGluIHRoZSBwaHlzaWNzIHNpbXVsYXRpb25cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3BoeXNpY3NUaWNrJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGh5c2ljc1RpY2soKSB7XG4gICAgICB0aGlzLl9zdGFydFN0YWJpbGl6aW5nKCk7IC8vIHRoaXMgZW5zdXJlcyB0aGF0IHRoZXJlIGlzIG5vIHN0YXJ0IGV2ZW50IHdoZW4gdGhlIG5ldHdvcmsgaXMgYWxyZWFkeSBzdGFibGUuXG4gICAgICBpZiAodGhpcy5zdGFiaWxpemVkID09PSB0cnVlKSByZXR1cm47XG5cbiAgICAgIC8vIGFkYXB0aXZpdHkgbWVhbnMgdGhlIHRpbWVzdGVwIGFkYXB0cyB0byB0aGUgc2l0dWF0aW9uLCBvbmx5IGFwcGxpY2FibGUgZm9yIHN0YWJpbGl6YXRpb25cbiAgICAgIGlmICh0aGlzLmFkYXB0aXZlVGltZXN0ZXAgPT09IHRydWUgJiYgdGhpcy5hZGFwdGl2ZVRpbWVzdGVwRW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyB0aW1lc3RlcCByZW1haW5zIHN0YWJsZSBmb3IgXCJpbnRlcnZhbFwiIGl0ZXJhdGlvbnMuXG4gICAgICAgIHZhciBkb0FkYXB0aXZlID0gdGhpcy5hZGFwdGl2ZUNvdW50ZXIgJSB0aGlzLmFkYXB0aXZlSW50ZXJ2YWwgPT09IDA7XG5cbiAgICAgICAgaWYgKGRvQWRhcHRpdmUpIHtcbiAgICAgICAgICAvLyBmaXJzdCB0aGUgYmlnIHN0ZXAgYW5kIHJldmVydC5cbiAgICAgICAgICB0aGlzLnRpbWVzdGVwID0gMiAqIHRoaXMudGltZXN0ZXA7XG4gICAgICAgICAgdGhpcy5waHlzaWNzU3RlcCgpO1xuICAgICAgICAgIHRoaXMucmV2ZXJ0KCk7IC8vIHNhdmVzIHRoZSByZWZlcmVuY2Ugc3RhdGVcblxuICAgICAgICAgIC8vIG5vdyB0aGUgbm9ybWFsIHN0ZXAuIFNpbmNlIHRoaXMgaXMgdGhlIGxhc3Qgc3RlcCwgaXQgaXMgdGhlIG1vcmUgc3RhYmxlIG9uZSBhbmQgd2Ugd2lsbCB0YWtlIHRoaXMuXG4gICAgICAgICAgdGhpcy50aW1lc3RlcCA9IDAuNSAqIHRoaXMudGltZXN0ZXA7XG5cbiAgICAgICAgICAvLyBzaW5jZSBpdCdzIGhhbGYgdGhlIHN0ZXAsIHdlIGRvIGl0IHR3aWNlLlxuICAgICAgICAgIHRoaXMucGh5c2ljc1N0ZXAoKTtcbiAgICAgICAgICB0aGlzLnBoeXNpY3NTdGVwKCk7XG5cbiAgICAgICAgICB0aGlzLmFkanVzdFRpbWVTdGVwKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5waHlzaWNzU3RlcCgpOyAvLyBub3JtYWwgc3RlcCwga2VlcGluZyB0aW1lc3RlcCBjb25zdGFudFxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hZGFwdGl2ZUNvdW50ZXIgKz0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNhc2UgZm9yIHRoZSBzdGF0aWMgdGltZXN0ZXAsIHdlIHJlc2V0IGl0IHRvIHRoZSBvbmUgaW4gb3B0aW9ucyBhbmQgdGFrZSBhIG5vcm1hbCBzdGVwLlxuICAgICAgICB0aGlzLnRpbWVzdGVwID0gdGhpcy5vcHRpb25zLnRpbWVzdGVwO1xuICAgICAgICB0aGlzLnBoeXNpY3NTdGVwKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnN0YWJpbGl6ZWQgPT09IHRydWUpIHRoaXMucmV2ZXJ0KCk7XG4gICAgICB0aGlzLnN0YWJpbGl6YXRpb25JdGVyYXRpb25zKys7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm9kZXMgYW5kIGVkZ2VzIGNhbiBoYXZlIHRoZSBwaHlzaWNzIHRvZ2dsZXMgb24gb3Igb2ZmLiBBIGNvbGxlY3Rpb24gb2YgaW5kaWNlcyBpcyBjcmVhdGVkIGhlcmUgc28gd2UgY2FuIHNraXAgdGhlIGNoZWNrIGFsbCB0aGUgdGltZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZVBoeXNpY3NEYXRhJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlUGh5c2ljc0RhdGEoKSB7XG4gICAgICB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlcyA9IHt9O1xuICAgICAgdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXMgPSBbXTtcbiAgICAgIHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc0VkZ2VJbmRpY2VzID0gW107XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG5cbiAgICAgIC8vIGdldCBub2RlIGluZGljZXMgZm9yIHBoeXNpY3NcbiAgICAgIGZvciAodmFyIG5vZGVJZCBpbiBub2Rlcykge1xuICAgICAgICBpZiAobm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgIGlmIChub2Rlc1tub2RlSWRdLm9wdGlvbnMucGh5c2ljcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXMucHVzaChub2Rlc1tub2RlSWRdLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZ2V0IGVkZ2UgaW5kaWNlcyBmb3IgcGh5c2ljc1xuICAgICAgZm9yICh2YXIgZWRnZUlkIGluIGVkZ2VzKSB7XG4gICAgICAgIGlmIChlZGdlcy5oYXNPd25Qcm9wZXJ0eShlZGdlSWQpKSB7XG4gICAgICAgICAgaWYgKGVkZ2VzW2VkZ2VJZF0ub3B0aW9ucy5waHlzaWNzID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NFZGdlSW5kaWNlcy5wdXNoKGVkZ2VzW2VkZ2VJZF0uaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBnZXQgdGhlIHZlbG9jaXR5IGFuZCB0aGUgZm9yY2VzIHZlY3RvclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgX25vZGVJZCA9IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzW2ldO1xuICAgICAgICB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tfbm9kZUlkXSA9IHsgeDogMCwgeTogMFxuXG4gICAgICAgICAgLy8gZm9yY2VzIGNhbiBiZSByZXNldCBiZWNhdXNlIHRoZXkgYXJlIHJlY2FsY3VsYXRlZC4gVmVsb2NpdGllcyBoYXZlIHRvIHBlcnNpc3QuXG4gICAgICAgIH07aWYgKHRoaXMucGh5c2ljc0JvZHkudmVsb2NpdGllc1tfbm9kZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5waHlzaWNzQm9keS52ZWxvY2l0aWVzW19ub2RlSWRdID0geyB4OiAwLCB5OiAwIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gY2xlYW4gZGVsZXRlZCBub2RlcyBmcm9tIHRoZSB2ZWxvY2l0eSB2ZWN0b3JcbiAgICAgIGZvciAodmFyIF9ub2RlSWQyIGluIHRoaXMucGh5c2ljc0JvZHkudmVsb2NpdGllcykge1xuICAgICAgICBpZiAobm9kZXNbX25vZGVJZDJdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5waHlzaWNzQm9keS52ZWxvY2l0aWVzW19ub2RlSWQyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVydCB0aGUgc2ltdWxhdGlvbiBvbmUgc3RlcC4gVGhpcyBpcyBkb25lIHNvIGFmdGVyIHN0YWJpbGl6YXRpb24sIGV2ZXJ5IG5ldyBzdGFydCBvZiB0aGUgc2ltdWxhdGlvbiB3aWxsIGFsc28gc2F5IHN0YWJpbGl6ZWQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3JldmVydCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJldmVydCgpIHtcbiAgICAgIHZhciBub2RlSWRzID0gKDAsIF9rZXlzMlsnZGVmYXVsdCddKSh0aGlzLnByZXZpb3VzU3RhdGVzKTtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIHZhciB2ZWxvY2l0aWVzID0gdGhpcy5waHlzaWNzQm9keS52ZWxvY2l0aWVzO1xuICAgICAgdGhpcy5yZWZlcmVuY2VTdGF0ZSA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGVJZCA9IG5vZGVJZHNbaV07XG4gICAgICAgIGlmIChub2Rlc1tub2RlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAobm9kZXNbbm9kZUlkXS5vcHRpb25zLnBoeXNpY3MgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMucmVmZXJlbmNlU3RhdGVbbm9kZUlkXSA9IHtcbiAgICAgICAgICAgICAgcG9zaXRpb25zOiB7IHg6IG5vZGVzW25vZGVJZF0ueCwgeTogbm9kZXNbbm9kZUlkXS55IH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2ZWxvY2l0aWVzW25vZGVJZF0ueCA9IHRoaXMucHJldmlvdXNTdGF0ZXNbbm9kZUlkXS52eDtcbiAgICAgICAgICAgIHZlbG9jaXRpZXNbbm9kZUlkXS55ID0gdGhpcy5wcmV2aW91c1N0YXRlc1tub2RlSWRdLnZ5O1xuICAgICAgICAgICAgbm9kZXNbbm9kZUlkXS54ID0gdGhpcy5wcmV2aW91c1N0YXRlc1tub2RlSWRdLng7XG4gICAgICAgICAgICBub2Rlc1tub2RlSWRdLnkgPSB0aGlzLnByZXZpb3VzU3RhdGVzW25vZGVJZF0ueTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMucHJldmlvdXNTdGF0ZXNbbm9kZUlkXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgY29tcGFyZXMgdGhlIHJlZmVyZW5jZSBzdGF0ZSB0byB0aGUgY3VycmVudCBzdGF0ZVxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2V2YWx1YXRlU3RlcFF1YWxpdHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZhbHVhdGVTdGVwUXVhbGl0eSgpIHtcbiAgICAgIHZhciBkeCA9IHZvaWQgMCxcbiAgICAgICAgICBkeSA9IHZvaWQgMCxcbiAgICAgICAgICBkcG9zID0gdm9pZCAwO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgdmFyIHJlZmVyZW5jZSA9IHRoaXMucmVmZXJlbmNlU3RhdGU7XG4gICAgICB2YXIgcG9zVGhyZXNob2xkID0gMC4zO1xuXG4gICAgICBmb3IgKHZhciBub2RlSWQgaW4gdGhpcy5yZWZlcmVuY2VTdGF0ZSkge1xuICAgICAgICBpZiAodGhpcy5yZWZlcmVuY2VTdGF0ZS5oYXNPd25Qcm9wZXJ0eShub2RlSWQpICYmIG5vZGVzW25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGR4ID0gbm9kZXNbbm9kZUlkXS54IC0gcmVmZXJlbmNlW25vZGVJZF0ucG9zaXRpb25zLng7XG4gICAgICAgICAgZHkgPSBub2Rlc1tub2RlSWRdLnkgLSByZWZlcmVuY2Vbbm9kZUlkXS5wb3NpdGlvbnMueTtcblxuICAgICAgICAgIGRwb3MgPSBNYXRoLnNxcnQoTWF0aC5wb3coZHgsIDIpICsgTWF0aC5wb3coZHksIDIpKTtcblxuICAgICAgICAgIGlmIChkcG9zID4gcG9zVGhyZXNob2xkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBtb3ZlIHRoZSBub2RlcyBvbmUgdGltZXN0ZXAgYW5kIGNoZWNrIGlmIHRoZXkgYXJlIHN0YWJpbGl6ZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbW92ZU5vZGVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZU5vZGVzKCkge1xuICAgICAgdmFyIG5vZGVJbmRpY2VzID0gdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXM7XG4gICAgICB2YXIgbWF4Tm9kZVZlbG9jaXR5ID0gMDtcbiAgICAgIHZhciBhdmVyYWdlTm9kZVZlbG9jaXR5ID0gMDtcblxuICAgICAgLy8gdGhlIHZlbG9jaXR5IHRocmVzaG9sZCAoZW5lcmd5IGluIHRoZSBzeXN0ZW0pIGZvciB0aGUgYWRhcHRpdml0eSB0b2dnbGVcbiAgICAgIHZhciB2ZWxvY2l0eUFkYXB0aXZlVGhyZXNob2xkID0gNTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZUlkID0gbm9kZUluZGljZXNbaV07XG4gICAgICAgIHZhciBub2RlVmVsb2NpdHkgPSB0aGlzLl9wZXJmb3JtU3RlcChub2RlSWQpO1xuICAgICAgICAvLyBzdGFiaWxpemVkIGlzIHRydWUgaWYgc3RhYmlsaXplZCBpcyB0cnVlIGFuZCB2ZWxvY2l0eSBpcyBzbWFsbGVyIHRoYW4gdm1pbiAtLT4gYWxsIG5vZGVzIG11c3QgYmUgc3RhYmlsaXplZFxuICAgICAgICBtYXhOb2RlVmVsb2NpdHkgPSBNYXRoLm1heChtYXhOb2RlVmVsb2NpdHksIG5vZGVWZWxvY2l0eSk7XG4gICAgICAgIGF2ZXJhZ2VOb2RlVmVsb2NpdHkgKz0gbm9kZVZlbG9jaXR5O1xuICAgICAgfVxuXG4gICAgICAvLyBldmFsdWF0aW5nIHRoZSBzdGFiaWxpemVkIGFuZCBhZGFwdGl2ZVRpbWVzdGVwRW5hYmxlZCBjb25kaXRpb25zXG4gICAgICB0aGlzLmFkYXB0aXZlVGltZXN0ZXBFbmFibGVkID0gYXZlcmFnZU5vZGVWZWxvY2l0eSAvIG5vZGVJbmRpY2VzLmxlbmd0aCA8IHZlbG9jaXR5QWRhcHRpdmVUaHJlc2hvbGQ7XG4gICAgICB0aGlzLnN0YWJpbGl6ZWQgPSBtYXhOb2RlVmVsb2NpdHkgPCB0aGlzLm9wdGlvbnMubWluVmVsb2NpdHk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIG5ldyB2ZWxvY2l0eSBmb3IgYSBjb29yZGluYXRlIGRpcmVjdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHYgIHZlbG9jaXR5IGZvciBjdXJyZW50IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZiAgcmVndWxhciBmb3JjZSBmb3IgY3VycmVudCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG0gIG1hc3Mgb2YgY3VycmVudCBub2RlXG4gICAgICogQHJldHVybnMge251bWJlcn0gbmV3IHZlbG9jaXR5IGZvciBjdXJyZW50IGNvb3JkaW5hdGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdjYWxjdWxhdGVDb21wb25lbnRWZWxvY2l0eScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZUNvbXBvbmVudFZlbG9jaXR5KHYsIGYsIG0pIHtcbiAgICAgIHZhciBkZiA9IHRoaXMubW9kZWxPcHRpb25zLmRhbXBpbmcgKiB2OyAvLyBkYW1waW5nIGZvcmNlXG4gICAgICB2YXIgYSA9IChmIC0gZGYpIC8gbTsgLy8gYWNjZWxlcmF0aW9uXG5cbiAgICAgIHYgKz0gYSAqIHRoaXMudGltZXN0ZXA7XG5cbiAgICAgIC8vIFB1dCBhIGxpbWl0IG9uIHRoZSB2ZWxvY2l0aWVzIGlmIGl0IGlzIHJlYWxseSBoaWdoXG4gICAgICB2YXIgbWF4ViA9IHRoaXMub3B0aW9ucy5tYXhWZWxvY2l0eSB8fCAxZTk7XG4gICAgICBpZiAoTWF0aC5hYnModikgPiBtYXhWKSB7XG4gICAgICAgIHYgPSB2ID4gMCA/IG1heFYgOiAtbWF4VjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHY7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybSB0aGUgYWN0dWFsIHN0ZXBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gbm9kZUlkXG4gICAgICogQHJldHVybnMge251bWJlcn0gdGhlIG5ldyB2ZWxvY2l0eSBvZiBnaXZlbiBub2RlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3BlcmZvcm1TdGVwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BlcmZvcm1TdGVwKG5vZGVJZCkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgIHZhciBmb3JjZSA9IHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGVJZF07XG4gICAgICB2YXIgdmVsb2NpdHkgPSB0aGlzLnBoeXNpY3NCb2R5LnZlbG9jaXRpZXNbbm9kZUlkXTtcblxuICAgICAgLy8gc3RvcmUgdGhlIHN0YXRlIHNvIHdlIGNhbiByZXZlcnRcbiAgICAgIHRoaXMucHJldmlvdXNTdGF0ZXNbbm9kZUlkXSA9IHtcbiAgICAgICAgeDogbm9kZS54LFxuICAgICAgICB5OiBub2RlLnksXG4gICAgICAgIHZ4OiB2ZWxvY2l0eS54LFxuICAgICAgICB2eTogdmVsb2NpdHkueVxuICAgICAgfTtcblxuICAgICAgaWYgKG5vZGUub3B0aW9ucy5maXhlZC54ID09PSBmYWxzZSkge1xuICAgICAgICB2ZWxvY2l0eS54ID0gdGhpcy5jYWxjdWxhdGVDb21wb25lbnRWZWxvY2l0eSh2ZWxvY2l0eS54LCBmb3JjZS54LCBub2RlLm9wdGlvbnMubWFzcyk7XG4gICAgICAgIG5vZGUueCArPSB2ZWxvY2l0eS54ICogdGhpcy50aW1lc3RlcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcmNlLnggPSAwO1xuICAgICAgICB2ZWxvY2l0eS54ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUub3B0aW9ucy5maXhlZC55ID09PSBmYWxzZSkge1xuICAgICAgICB2ZWxvY2l0eS55ID0gdGhpcy5jYWxjdWxhdGVDb21wb25lbnRWZWxvY2l0eSh2ZWxvY2l0eS55LCBmb3JjZS55LCBub2RlLm9wdGlvbnMubWFzcyk7XG4gICAgICAgIG5vZGUueSArPSB2ZWxvY2l0eS55ICogdGhpcy50aW1lc3RlcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcmNlLnkgPSAwO1xuICAgICAgICB2ZWxvY2l0eS55ID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIHRvdGFsVmVsb2NpdHkgPSBNYXRoLnNxcnQoTWF0aC5wb3codmVsb2NpdHkueCwgMikgKyBNYXRoLnBvdyh2ZWxvY2l0eS55LCAyKSk7XG4gICAgICByZXR1cm4gdG90YWxWZWxvY2l0eTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGluaXRpYWxpemluZyBhbmQgc3RhYmlsaXppbmcsIHdlIGNhbiBmcmVlemUgbm9kZXMgd2l0aCBhIHByZWRlZmluZWQgcG9zaXRpb24uXG4gICAgICogVGhpcyBncmVhdGx5IHNwZWVkcyB1cCBzdGFiaWxpemF0aW9uIGJlY2F1c2Ugb25seSB0aGUgc3VwcG9ydG5vZGVzIGZvciB0aGUgc21vb3RoQ3VydmVzIGhhdmUgdG8gc2V0dGxlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2ZyZWV6ZU5vZGVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZyZWV6ZU5vZGVzKCkge1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgZm9yICh2YXIgaWQgaW4gbm9kZXMpIHtcbiAgICAgICAgaWYgKG5vZGVzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgIGlmIChub2Rlc1tpZF0ueCAmJiBub2Rlc1tpZF0ueSkge1xuICAgICAgICAgICAgdmFyIGZpeGVkID0gbm9kZXNbaWRdLm9wdGlvbnMuZml4ZWQ7XG4gICAgICAgICAgICB0aGlzLmZyZWV6ZUNhY2hlW2lkXSA9IHsgeDogZml4ZWQueCwgeTogZml4ZWQueSB9O1xuICAgICAgICAgICAgZml4ZWQueCA9IHRydWU7XG4gICAgICAgICAgICBmaXhlZC55ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVbmZyZWV6ZXMgdGhlIG5vZGVzIHRoYXQgaGF2ZSBiZWVuIGZyb3plbiBieSBfZnJlZXplRGVmaW5lZE5vZGVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3Jlc3RvcmVGcm96ZW5Ob2RlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXN0b3JlRnJvemVuTm9kZXMoKSB7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICBmb3IgKHZhciBpZCBpbiBub2Rlcykge1xuICAgICAgICBpZiAobm9kZXMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZnJlZXplQ2FjaGVbaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5vZGVzW2lkXS5vcHRpb25zLmZpeGVkLnggPSB0aGlzLmZyZWV6ZUNhY2hlW2lkXS54O1xuICAgICAgICAgICAgbm9kZXNbaWRdLm9wdGlvbnMuZml4ZWQueSA9IHRoaXMuZnJlZXplQ2FjaGVbaWRdLnk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmZyZWV6ZUNhY2hlID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZCBhIHN0YWJsZSBwb3NpdGlvbiBmb3IgYWxsIG5vZGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2l0ZXJhdGlvbnM9dGhpcy5vcHRpb25zLnN0YWJpbGl6YXRpb24uaXRlcmF0aW9uc11cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc3RhYmlsaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhYmlsaXplKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBpdGVyYXRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLm9wdGlvbnMuc3RhYmlsaXphdGlvbi5pdGVyYXRpb25zO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdGlvbnMgIT09ICdudW1iZXInKSB7XG4gICAgICAgIGl0ZXJhdGlvbnMgPSB0aGlzLm9wdGlvbnMuc3RhYmlsaXphdGlvbi5pdGVyYXRpb25zO1xuICAgICAgICBjb25zb2xlLmxvZygnVGhlIHN0YWJpbGl6ZSBtZXRob2QgbmVlZHMgYSBudW1lcmljIGFtb3VudCBvZiBpdGVyYXRpb25zLiBTd2l0Y2hpbmcgdG8gZGVmYXVsdDogJywgaXRlcmF0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5yZWFkeSA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gZW5hYmxlIGFkYXB0aXZlIHRpbWVzdGVwc1xuICAgICAgdGhpcy5hZGFwdGl2ZVRpbWVzdGVwID0gdHJ1ZSAmJiB0aGlzLm9wdGlvbnMuYWRhcHRpdmVUaW1lc3RlcDtcblxuICAgICAgLy8gdGhpcyBzZXRzIHRoZSB3aWR0aCBvZiBhbGwgbm9kZXMgaW5pdGlhbGx5IHdoaWNoIGNvdWxkIGJlIHJlcXVpcmVkIGZvciB0aGUgYXZvaWRPdmVybGFwXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfcmVzaXplTm9kZXMnKTtcblxuICAgICAgdGhpcy5zdG9wU2ltdWxhdGlvbigpOyAvLyBzdG9wIHRoZSByZW5kZXIgbG9vcFxuICAgICAgdGhpcy5zdGFiaWxpemVkID0gZmFsc2U7XG5cbiAgICAgIC8vIGJsb2NrIHJlZHJhdyByZXF1ZXN0c1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2Jsb2NrUmVkcmF3Jyk7XG4gICAgICB0aGlzLnRhcmdldEl0ZXJhdGlvbnMgPSBpdGVyYXRpb25zO1xuXG4gICAgICAvLyBzdGFydCB0aGUgc3RhYmlsaXphdGlvblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdGFiaWxpemF0aW9uLm9ubHlEeW5hbWljRWRnZXMgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5fZnJlZXplTm9kZXMoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhYmlsaXphdGlvbkl0ZXJhdGlvbnMgPSAwO1xuXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMy5fc3RhYmlsaXphdGlvbkJhdGNoKCk7XG4gICAgICB9LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiBub3QgYWxyZWFkeSBzdGFiaWxpemluZywgc3RhcnQgaXQgYW5kIGVtaXQgYSBzdGFydCBldmVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHN0YWJpbGl6YXRpb24gc3RhcnRlZCB3aXRoIHRoaXMgY2FsbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19zdGFydFN0YWJpbGl6aW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3N0YXJ0U3RhYmlsaXppbmcoKSB7XG4gICAgICBpZiAodGhpcy5zdGFydGVkU3RhYmlsaXphdGlvbiA9PT0gdHJ1ZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdzdGFydFN0YWJpbGl6aW5nJyk7XG4gICAgICB0aGlzLnN0YXJ0ZWRTdGFiaWxpemF0aW9uID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9uZSBiYXRjaCBvZiBzdGFiaWxpemF0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3N0YWJpbGl6YXRpb25CYXRjaCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zdGFiaWxpemF0aW9uQmF0Y2goKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdmFyIHJ1bm5pbmcgPSBmdW5jdGlvbiBydW5uaW5nKCkge1xuICAgICAgICByZXR1cm4gX3RoaXM0LnN0YWJpbGl6ZWQgPT09IGZhbHNlICYmIF90aGlzNC5zdGFiaWxpemF0aW9uSXRlcmF0aW9ucyA8IF90aGlzNC50YXJnZXRJdGVyYXRpb25zO1xuICAgICAgfTtcblxuICAgICAgdmFyIHNlbmRQcm9ncmVzcyA9IGZ1bmN0aW9uIHNlbmRQcm9ncmVzcygpIHtcbiAgICAgICAgX3RoaXM0LmJvZHkuZW1pdHRlci5lbWl0KCdzdGFiaWxpemF0aW9uUHJvZ3Jlc3MnLCB7XG4gICAgICAgICAgaXRlcmF0aW9uczogX3RoaXM0LnN0YWJpbGl6YXRpb25JdGVyYXRpb25zLFxuICAgICAgICAgIHRvdGFsOiBfdGhpczQudGFyZ2V0SXRlcmF0aW9uc1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLl9zdGFydFN0YWJpbGl6aW5nKCkpIHtcbiAgICAgICAgc2VuZFByb2dyZXNzKCk7IC8vIEVuc3VyZSB0aGF0IHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBzdGFydCBldmVudC5cbiAgICAgIH1cblxuICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgIHdoaWxlIChydW5uaW5nKCkgJiYgY291bnQgPCB0aGlzLm9wdGlvbnMuc3RhYmlsaXphdGlvbi51cGRhdGVJbnRlcnZhbCkge1xuICAgICAgICB0aGlzLnBoeXNpY3NUaWNrKCk7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICB9XG5cbiAgICAgIHNlbmRQcm9ncmVzcygpO1xuXG4gICAgICBpZiAocnVubmluZygpKSB7XG4gICAgICAgIHNldFRpbWVvdXQodGhpcy5fc3RhYmlsaXphdGlvbkJhdGNoLmJpbmQodGhpcyksIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZmluYWxpemVTdGFiaWxpemF0aW9uKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV3JhcCB1cCB0aGUgc3RhYmlsaXphdGlvbiwgZml0IGFuZCBlbWl0IHRoZSBldmVudHMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2ZpbmFsaXplU3RhYmlsaXphdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5hbGl6ZVN0YWJpbGl6YXRpb24oKSB7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfYWxsb3dSZWRyYXcnKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RhYmlsaXphdGlvbi5maXQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnZml0Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RhYmlsaXphdGlvbi5vbmx5RHluYW1pY0VkZ2VzID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX3Jlc3RvcmVGcm96ZW5Ob2RlcygpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdzdGFiaWxpemF0aW9uSXRlcmF0aW9uc0RvbmUnKTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19yZXF1ZXN0UmVkcmF3Jyk7XG5cbiAgICAgIGlmICh0aGlzLnN0YWJpbGl6ZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5fZW1pdFN0YWJpbGl6ZWQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhcnRTaW11bGF0aW9uKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVhZHkgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICBERUJVR0dJTkcgQkVMT1cgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXG5cbiAgICAvKipcbiAgICAgKiBEZWJ1ZyBmdW5jdGlvbiB0aGF0IGRpc3BsYXkgYXJyb3dzIGZvciB0aGUgZm9yY2VzIGN1cnJlbnRseSBhY3RpdmUgaW4gdGhlIG5ldHdvcmsuXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyB3aGVuIGRlYnVnZ2luZyBvbmx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19kcmF3Rm9yY2VzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdGb3JjZXMoY3R4KSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzW2ldO1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tpbmRleF07XG4gICAgICAgIHZhciBmb3JjZSA9IHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW2luZGV4XTtcbiAgICAgICAgdmFyIGZhY3RvciA9IDIwO1xuICAgICAgICB2YXIgY29sb3JGYWN0b3IgPSAwLjAzO1xuICAgICAgICB2YXIgZm9yY2VTaXplID0gTWF0aC5zcXJ0KE1hdGgucG93KGZvcmNlLngsIDIpICsgTWF0aC5wb3coZm9yY2UueCwgMikpO1xuXG4gICAgICAgIHZhciBzaXplID0gTWF0aC5taW4oTWF0aC5tYXgoNSwgZm9yY2VTaXplKSwgMTUpO1xuICAgICAgICB2YXIgYXJyb3dTaXplID0gMyAqIHNpemU7XG5cbiAgICAgICAgdmFyIGNvbG9yID0gdXRpbC5IU1ZUb0hleCgoMTgwIC0gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgY29sb3JGYWN0b3IgKiBmb3JjZVNpemUpKSAqIDE4MCkgLyAzNjAsIDEsIDEpO1xuXG4gICAgICAgIHZhciBwb2ludCA9IHtcbiAgICAgICAgICB4OiBub2RlLnggKyBmYWN0b3IgKiBmb3JjZS54LFxuICAgICAgICAgIHk6IG5vZGUueSArIGZhY3RvciAqIGZvcmNlLnlcbiAgICAgICAgfTtcblxuICAgICAgICBjdHgubGluZVdpZHRoID0gc2l6ZTtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhub2RlLngsIG5vZGUueSk7XG4gICAgICAgIGN0eC5saW5lVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKGZvcmNlLnksIGZvcmNlLngpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICAgIEVuZFBvaW50cy5kcmF3KGN0eCwge1xuICAgICAgICAgIHR5cGU6ICdhcnJvdycsXG4gICAgICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgICAgIGFuZ2xlOiBhbmdsZSxcbiAgICAgICAgICBsZW5ndGg6IGFycm93U2l6ZVxuICAgICAgICB9KTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFBoeXNpY3NFbmdpbmU7XG59KCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFBoeXNpY3NFbmdpbmU7XG5cbi8qKiovIH0pLFxuLyogMTcyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbi8qKlxuICogUmVwdWxzaW9uIFNvbHZlclxuICovXG52YXIgUmVwdWxzaW9uU29sdmVyID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHt7cGh5c2ljc05vZGVJbmRpY2VzOiBBcnJheSwgcGh5c2ljc0VkZ2VJbmRpY2VzOiBBcnJheSwgZm9yY2VzOiB7fSwgdmVsb2NpdGllczoge319fSBwaHlzaWNzQm9keVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gUmVwdWxzaW9uU29sdmVyKGJvZHksIHBoeXNpY3NCb2R5LCBvcHRpb25zKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbXCJkZWZhdWx0XCJdKSh0aGlzLCBSZXB1bHNpb25Tb2x2ZXIpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLnBoeXNpY3NCb2R5ID0gcGh5c2ljc0JvZHk7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbXCJkZWZhdWx0XCJdKShSZXB1bHNpb25Tb2x2ZXIsIFt7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgZm9yY2VzIHRoZSBub2RlcyBhcHBseSBvbiBlYWNoIG90aGVyIGJhc2VkIG9uIGEgcmVwdWxzaW9uIGZpZWxkLlxuICAgICAqIFRoaXMgZmllbGQgaXMgbGluZWFybHkgYXBwcm94aW1hdGVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNvbHZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvbHZlKCkge1xuICAgICAgdmFyIGR4LCBkeSwgZGlzdGFuY2UsIGZ4LCBmeSwgcmVwdWxzaW5nRm9yY2UsIG5vZGUxLCBub2RlMjtcblxuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgdmFyIG5vZGVJbmRpY2VzID0gdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXM7XG4gICAgICB2YXIgZm9yY2VzID0gdGhpcy5waHlzaWNzQm9keS5mb3JjZXM7XG5cbiAgICAgIC8vIHJlcHVsc2luZyBmb3JjZXMgYmV0d2VlbiBub2Rlc1xuICAgICAgdmFyIG5vZGVEaXN0YW5jZSA9IHRoaXMub3B0aW9ucy5ub2RlRGlzdGFuY2U7XG5cbiAgICAgIC8vIGFwcHJveGltYXRpb24gY29uc3RhbnRzXG4gICAgICB2YXIgYSA9IC0yIC8gMyAvIG5vZGVEaXN0YW5jZTtcbiAgICAgIHZhciBiID0gNCAvIDM7XG5cbiAgICAgIC8vIHdlIGxvb3AgZnJvbSBpIG92ZXIgYWxsIGJ1dCB0aGUgbGFzdCBlbnRyZWUgaW4gdGhlIGFycmF5XG4gICAgICAvLyBqIGxvb3BzIGZyb20gaSsxIHRvIHRoZSBsYXN0LiBUaGlzIHdheSB3ZSBkbyBub3QgZG91YmxlIGNvdW50IGFueSBvZiB0aGUgaW5kaWNlcywgbm9yIGkgPT09IGpcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZUluZGljZXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIG5vZGUxID0gbm9kZXNbbm9kZUluZGljZXNbaV1dO1xuICAgICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBub2RlSW5kaWNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIG5vZGUyID0gbm9kZXNbbm9kZUluZGljZXNbal1dO1xuXG4gICAgICAgICAgZHggPSBub2RlMi54IC0gbm9kZTEueDtcbiAgICAgICAgICBkeSA9IG5vZGUyLnkgLSBub2RlMS55O1xuICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblxuICAgICAgICAgIC8vIHNhbWUgY29uZGl0aW9uIGFzIEJhcm5lc0h1dFNvbHZlciwgbWFraW5nIHN1cmUgbm9kZXMgYXJlIG5ldmVyIDEwMCUgb3ZlcmxhcHBpbmcuXG4gICAgICAgICAgaWYgKGRpc3RhbmNlID09PSAwKSB7XG4gICAgICAgICAgICBkaXN0YW5jZSA9IDAuMSAqIE1hdGgucmFuZG9tKCk7XG4gICAgICAgICAgICBkeCA9IGRpc3RhbmNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChkaXN0YW5jZSA8IDIgKiBub2RlRGlzdGFuY2UpIHtcbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8IDAuNSAqIG5vZGVEaXN0YW5jZSkge1xuICAgICAgICAgICAgICByZXB1bHNpbmdGb3JjZSA9IDEuMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlcHVsc2luZ0ZvcmNlID0gYSAqIGRpc3RhbmNlICsgYjsgLy8gbGluZWFyIGFwcHJveCBvZiAgMSAvICgxICsgTWF0aC5leHAoKGRpc3RhbmNlIC8gbm9kZURpc3RhbmNlIC0gMSkgKiBzdGVlcG5lc3MpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVwdWxzaW5nRm9yY2UgPSByZXB1bHNpbmdGb3JjZSAvIGRpc3RhbmNlO1xuXG4gICAgICAgICAgICBmeCA9IGR4ICogcmVwdWxzaW5nRm9yY2U7XG4gICAgICAgICAgICBmeSA9IGR5ICogcmVwdWxzaW5nRm9yY2U7XG5cbiAgICAgICAgICAgIGZvcmNlc1tub2RlMS5pZF0ueCAtPSBmeDtcbiAgICAgICAgICAgIGZvcmNlc1tub2RlMS5pZF0ueSAtPSBmeTtcbiAgICAgICAgICAgIGZvcmNlc1tub2RlMi5pZF0ueCArPSBmeDtcbiAgICAgICAgICAgIGZvcmNlc1tub2RlMi5pZF0ueSArPSBmeTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFJlcHVsc2lvblNvbHZlcjtcbn0oKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBSZXB1bHNpb25Tb2x2ZXI7XG5cbi8qKiovIH0pLFxuLyogMTczICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbi8qKlxuICogSGllcmFyY2hpY2FsIFJlcHVsc2lvbiBTb2x2ZXJcbiAqL1xudmFyIEhpZXJhcmNoaWNhbFJlcHVsc2lvblNvbHZlciA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7e3BoeXNpY3NOb2RlSW5kaWNlczogQXJyYXksIHBoeXNpY3NFZGdlSW5kaWNlczogQXJyYXksIGZvcmNlczoge30sIHZlbG9jaXRpZXM6IHt9fX0gcGh5c2ljc0JvZHlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIEhpZXJhcmNoaWNhbFJlcHVsc2lvblNvbHZlcihib2R5LCBwaHlzaWNzQm9keSwgb3B0aW9ucykge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szW1wiZGVmYXVsdFwiXSkodGhpcywgSGllcmFyY2hpY2FsUmVwdWxzaW9uU29sdmVyKTtcblxuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5waHlzaWNzQm9keSA9IHBoeXNpY3NCb2R5O1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzW1wiZGVmYXVsdFwiXSkoSGllcmFyY2hpY2FsUmVwdWxzaW9uU29sdmVyLCBbe1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGZvcmNlcyB0aGUgbm9kZXMgYXBwbHkgb24gZWFjaCBvdGhlciBiYXNlZCBvbiBhIHJlcHVsc2lvbiBmaWVsZC5cbiAgICAgKiBUaGlzIGZpZWxkIGlzIGxpbmVhcmx5IGFwcHJveGltYXRlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzb2x2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzb2x2ZSgpIHtcbiAgICAgIHZhciBkeCwgZHksIGRpc3RhbmNlLCBmeCwgZnksIHJlcHVsc2luZ0ZvcmNlLCBub2RlMSwgbm9kZTIsIGksIGo7XG5cbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIHZhciBub2RlSW5kaWNlcyA9IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzO1xuICAgICAgdmFyIGZvcmNlcyA9IHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzO1xuXG4gICAgICAvLyByZXB1bHNpbmcgZm9yY2VzIGJldHdlZW4gbm9kZXNcbiAgICAgIHZhciBub2RlRGlzdGFuY2UgPSB0aGlzLm9wdGlvbnMubm9kZURpc3RhbmNlO1xuXG4gICAgICAvLyB3ZSBsb29wIGZyb20gaSBvdmVyIGFsbCBidXQgdGhlIGxhc3QgZW50cmVlIGluIHRoZSBhcnJheVxuICAgICAgLy8gaiBsb29wcyBmcm9tIGkrMSB0byB0aGUgbGFzdC4gVGhpcyB3YXkgd2UgZG8gbm90IGRvdWJsZSBjb3VudCBhbnkgb2YgdGhlIGluZGljZXMsIG5vciBpID09PSBqXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbm9kZUluZGljZXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIG5vZGUxID0gbm9kZXNbbm9kZUluZGljZXNbaV1dO1xuICAgICAgICBmb3IgKGogPSBpICsgMTsgaiA8IG5vZGVJbmRpY2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgbm9kZTIgPSBub2Rlc1tub2RlSW5kaWNlc1tqXV07XG5cbiAgICAgICAgICAvLyBub2RlcyBvbmx5IGFmZmVjdCBub2RlcyBvbiB0aGVpciBsZXZlbFxuICAgICAgICAgIGlmIChub2RlMS5sZXZlbCA9PT0gbm9kZTIubGV2ZWwpIHtcbiAgICAgICAgICAgIGR4ID0gbm9kZTIueCAtIG5vZGUxLng7XG4gICAgICAgICAgICBkeSA9IG5vZGUyLnkgLSBub2RlMS55O1xuICAgICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICAgICAgICB2YXIgc3RlZXBuZXNzID0gMC4wNTtcbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8IG5vZGVEaXN0YW5jZSkge1xuICAgICAgICAgICAgICByZXB1bHNpbmdGb3JjZSA9IC1NYXRoLnBvdyhzdGVlcG5lc3MgKiBkaXN0YW5jZSwgMikgKyBNYXRoLnBvdyhzdGVlcG5lc3MgKiBub2RlRGlzdGFuY2UsIDIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVwdWxzaW5nRm9yY2UgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbm9ybWFsaXplIGZvcmNlIHdpdGhcbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSA9PT0gMCkge1xuICAgICAgICAgICAgICBkaXN0YW5jZSA9IDAuMDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXB1bHNpbmdGb3JjZSA9IHJlcHVsc2luZ0ZvcmNlIC8gZGlzdGFuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmeCA9IGR4ICogcmVwdWxzaW5nRm9yY2U7XG4gICAgICAgICAgICBmeSA9IGR5ICogcmVwdWxzaW5nRm9yY2U7XG5cbiAgICAgICAgICAgIGZvcmNlc1tub2RlMS5pZF0ueCAtPSBmeDtcbiAgICAgICAgICAgIGZvcmNlc1tub2RlMS5pZF0ueSAtPSBmeTtcbiAgICAgICAgICAgIGZvcmNlc1tub2RlMi5pZF0ueCArPSBmeDtcbiAgICAgICAgICAgIGZvcmNlc1tub2RlMi5pZF0ueSArPSBmeTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEhpZXJhcmNoaWNhbFJlcHVsc2lvblNvbHZlcjtcbn0oKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBIaWVyYXJjaGljYWxSZXB1bHNpb25Tb2x2ZXI7XG5cbi8qKiovIH0pLFxuLyogMTc0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbi8qKlxuICogU3ByaW5nIFNvbHZlclxuICovXG52YXIgU3ByaW5nU29sdmVyID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHt7cGh5c2ljc05vZGVJbmRpY2VzOiBBcnJheSwgcGh5c2ljc0VkZ2VJbmRpY2VzOiBBcnJheSwgZm9yY2VzOiB7fSwgdmVsb2NpdGllczoge319fSBwaHlzaWNzQm9keVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gU3ByaW5nU29sdmVyKGJvZHksIHBoeXNpY3NCb2R5LCBvcHRpb25zKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbXCJkZWZhdWx0XCJdKSh0aGlzLCBTcHJpbmdTb2x2ZXIpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLnBoeXNpY3NCb2R5ID0gcGh5c2ljc0JvZHk7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbXCJkZWZhdWx0XCJdKShTcHJpbmdTb2x2ZXIsIFt7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyB0aGUgc3ByaW5nZm9yY2VzIG9uIHRoZSBub2RlcywgYWNjb3VudGluZyBmb3IgdGhlIHN1cHBvcnQgbm9kZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic29sdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc29sdmUoKSB7XG4gICAgICB2YXIgZWRnZUxlbmd0aCA9IHZvaWQgMCxcbiAgICAgICAgICBlZGdlID0gdm9pZCAwO1xuICAgICAgdmFyIGVkZ2VJbmRpY2VzID0gdGhpcy5waHlzaWNzQm9keS5waHlzaWNzRWRnZUluZGljZXM7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gICAgICB2YXIgbm9kZTEgPSB2b2lkIDAsXG4gICAgICAgICAgbm9kZTIgPSB2b2lkIDAsXG4gICAgICAgICAgbm9kZTMgPSB2b2lkIDA7XG5cbiAgICAgIC8vIGZvcmNlcyBjYXVzZWQgYnkgdGhlIGVkZ2VzLCBtb2RlbGxlZCBhcyBzcHJpbmdzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVkZ2UgPSBlZGdlc1tlZGdlSW5kaWNlc1tpXV07XG4gICAgICAgIGlmIChlZGdlLmNvbm5lY3RlZCA9PT0gdHJ1ZSAmJiBlZGdlLnRvSWQgIT09IGVkZ2UuZnJvbUlkKSB7XG4gICAgICAgICAgLy8gb25seSBjYWxjdWxhdGUgZm9yY2VzIGlmIG5vZGVzIGFyZSBpbiB0aGUgc2FtZSBzZWN0b3JcbiAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW2VkZ2UudG9JZF0gIT09IHVuZGVmaW5lZCAmJiB0aGlzLmJvZHkubm9kZXNbZWRnZS5mcm9tSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChlZGdlLmVkZ2VUeXBlLnZpYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGVkZ2VMZW5ndGggPSBlZGdlLm9wdGlvbnMubGVuZ3RoID09PSB1bmRlZmluZWQgPyB0aGlzLm9wdGlvbnMuc3ByaW5nTGVuZ3RoIDogZWRnZS5vcHRpb25zLmxlbmd0aDtcbiAgICAgICAgICAgICAgbm9kZTEgPSBlZGdlLnRvO1xuICAgICAgICAgICAgICBub2RlMiA9IGVkZ2UuZWRnZVR5cGUudmlhO1xuICAgICAgICAgICAgICBub2RlMyA9IGVkZ2UuZnJvbTtcblxuICAgICAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVTcHJpbmdGb3JjZShub2RlMSwgbm9kZTIsIDAuNSAqIGVkZ2VMZW5ndGgpO1xuICAgICAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVTcHJpbmdGb3JjZShub2RlMiwgbm9kZTMsIDAuNSAqIGVkZ2VMZW5ndGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gdGhlICogMS41IGlzIGhlcmUgc28gdGhlIGVkZ2UgbG9va3MgYXMgbGFyZ2UgYXMgYSBzbW9vdGggZWRnZS4gSXQgZG9lcyBub3QgaW5pdGlhbGx5IGJlY2F1c2UgdGhlIHNtb290aCBlZGdlcyB1c2VcbiAgICAgICAgICAgICAgLy8gdGhlIHN1cHBvcnQgbm9kZXMgd2hpY2ggZXhlcnQgYSByZXB1bHNpdmUgZm9yY2Ugb24gdGhlIHRvIGFuZCBmcm9tIG5vZGVzLCBtYWtpbmcgdGhlIGVkZ2UgYXBwZWFyIGxhcmdlci5cbiAgICAgICAgICAgICAgZWRnZUxlbmd0aCA9IGVkZ2Uub3B0aW9ucy5sZW5ndGggPT09IHVuZGVmaW5lZCA/IHRoaXMub3B0aW9ucy5zcHJpbmdMZW5ndGggKiAxLjUgOiBlZGdlLm9wdGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVTcHJpbmdGb3JjZShlZGdlLmZyb20sIGVkZ2UudG8sIGVkZ2VMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIGNvZGUgYWN0dWFsbHkgcGVyZm9ybWluZyB0aGUgY2FsY3VsYXRpb24gZm9yIHRoZSBmdW5jdGlvbiBhYm92ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZTFcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVkZ2VMZW5ndGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NhbGN1bGF0ZVNwcmluZ0ZvcmNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxjdWxhdGVTcHJpbmdGb3JjZShub2RlMSwgbm9kZTIsIGVkZ2VMZW5ndGgpIHtcbiAgICAgIHZhciBkeCA9IG5vZGUxLnggLSBub2RlMi54O1xuICAgICAgdmFyIGR5ID0gbm9kZTEueSAtIG5vZGUyLnk7XG4gICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLm1heChNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpLCAwLjAxKTtcblxuICAgICAgLy8gdGhlIDEvZGlzdGFuY2UgaXMgc28gdGhlIGZ4IGFuZCBmeSBjYW4gYmUgY2FsY3VsYXRlZCB3aXRob3V0IHNpbmUgb3IgY29zaW5lLlxuICAgICAgdmFyIHNwcmluZ0ZvcmNlID0gdGhpcy5vcHRpb25zLnNwcmluZ0NvbnN0YW50ICogKGVkZ2VMZW5ndGggLSBkaXN0YW5jZSkgLyBkaXN0YW5jZTtcblxuICAgICAgdmFyIGZ4ID0gZHggKiBzcHJpbmdGb3JjZTtcbiAgICAgIHZhciBmeSA9IGR5ICogc3ByaW5nRm9yY2U7XG5cbiAgICAgIC8vIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSBvbmUgbm9kZSBpcyBub3QgcGFydCBvZiB0aGUgcGh5c2Npc1xuICAgICAgaWYgKHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGUxLmlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGUxLmlkXS54ICs9IGZ4O1xuICAgICAgICB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tub2RlMS5pZF0ueSArPSBmeTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGUyLmlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGUyLmlkXS54IC09IGZ4O1xuICAgICAgICB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tub2RlMi5pZF0ueSAtPSBmeTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFNwcmluZ1NvbHZlcjtcbn0oKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBTcHJpbmdTb2x2ZXI7XG5cbi8qKiovIH0pLFxuLyogMTc1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbi8qKlxuICogSGllcmFyY2hpY2FsIFNwcmluZyBTb2x2ZXJcbiAqL1xudmFyIEhpZXJhcmNoaWNhbFNwcmluZ1NvbHZlciA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7e3BoeXNpY3NOb2RlSW5kaWNlczogQXJyYXksIHBoeXNpY3NFZGdlSW5kaWNlczogQXJyYXksIGZvcmNlczoge30sIHZlbG9jaXRpZXM6IHt9fX0gcGh5c2ljc0JvZHlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIEhpZXJhcmNoaWNhbFNwcmluZ1NvbHZlcihib2R5LCBwaHlzaWNzQm9keSwgb3B0aW9ucykge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szW1wiZGVmYXVsdFwiXSkodGhpcywgSGllcmFyY2hpY2FsU3ByaW5nU29sdmVyKTtcblxuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5waHlzaWNzQm9keSA9IHBoeXNpY3NCb2R5O1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzW1wiZGVmYXVsdFwiXSkoSGllcmFyY2hpY2FsU3ByaW5nU29sdmVyLCBbe1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgdGhlIHNwcmluZ2ZvcmNlcyBvbiB0aGUgbm9kZXMsIGFjY291bnRpbmcgZm9yIHRoZSBzdXBwb3J0IG5vZGVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNvbHZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvbHZlKCkge1xuICAgICAgdmFyIGVkZ2VMZW5ndGgsIGVkZ2U7XG4gICAgICB2YXIgZHgsIGR5LCBmeCwgZnksIHNwcmluZ0ZvcmNlLCBkaXN0YW5jZTtcbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcbiAgICAgIHZhciBmYWN0b3IgPSAwLjU7XG5cbiAgICAgIHZhciBlZGdlSW5kaWNlcyA9IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc0VkZ2VJbmRpY2VzO1xuICAgICAgdmFyIG5vZGVJbmRpY2VzID0gdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXM7XG4gICAgICB2YXIgZm9yY2VzID0gdGhpcy5waHlzaWNzQm9keS5mb3JjZXM7XG5cbiAgICAgIC8vIGluaXRpYWxpemUgdGhlIHNwcmluZyBmb3JjZSBjb3VudGVyc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZUlkID0gbm9kZUluZGljZXNbaV07XG4gICAgICAgIGZvcmNlc1tub2RlSWRdLnNwcmluZ0Z4ID0gMDtcbiAgICAgICAgZm9yY2VzW25vZGVJZF0uc3ByaW5nRnkgPSAwO1xuICAgICAgfVxuXG4gICAgICAvLyBmb3JjZXMgY2F1c2VkIGJ5IHRoZSBlZGdlcywgbW9kZWxsZWQgYXMgc3ByaW5nc1xuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGVkZ2VJbmRpY2VzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBlZGdlID0gZWRnZXNbZWRnZUluZGljZXNbX2ldXTtcbiAgICAgICAgaWYgKGVkZ2UuY29ubmVjdGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgZWRnZUxlbmd0aCA9IGVkZ2Uub3B0aW9ucy5sZW5ndGggPT09IHVuZGVmaW5lZCA/IHRoaXMub3B0aW9ucy5zcHJpbmdMZW5ndGggOiBlZGdlLm9wdGlvbnMubGVuZ3RoO1xuXG4gICAgICAgICAgZHggPSBlZGdlLmZyb20ueCAtIGVkZ2UudG8ueDtcbiAgICAgICAgICBkeSA9IGVkZ2UuZnJvbS55IC0gZWRnZS50by55O1xuICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgICBkaXN0YW5jZSA9IGRpc3RhbmNlID09PSAwID8gMC4wMSA6IGRpc3RhbmNlO1xuXG4gICAgICAgICAgLy8gdGhlIDEvZGlzdGFuY2UgaXMgc28gdGhlIGZ4IGFuZCBmeSBjYW4gYmUgY2FsY3VsYXRlZCB3aXRob3V0IHNpbmUgb3IgY29zaW5lLlxuICAgICAgICAgIHNwcmluZ0ZvcmNlID0gdGhpcy5vcHRpb25zLnNwcmluZ0NvbnN0YW50ICogKGVkZ2VMZW5ndGggLSBkaXN0YW5jZSkgLyBkaXN0YW5jZTtcblxuICAgICAgICAgIGZ4ID0gZHggKiBzcHJpbmdGb3JjZTtcbiAgICAgICAgICBmeSA9IGR5ICogc3ByaW5nRm9yY2U7XG5cbiAgICAgICAgICBpZiAoZWRnZS50by5sZXZlbCAhPSBlZGdlLmZyb20ubGV2ZWwpIHtcbiAgICAgICAgICAgIGlmIChmb3JjZXNbZWRnZS50b0lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGZvcmNlc1tlZGdlLnRvSWRdLnNwcmluZ0Z4IC09IGZ4O1xuICAgICAgICAgICAgICBmb3JjZXNbZWRnZS50b0lkXS5zcHJpbmdGeSAtPSBmeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JjZXNbZWRnZS5mcm9tSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZm9yY2VzW2VkZ2UuZnJvbUlkXS5zcHJpbmdGeCArPSBmeDtcbiAgICAgICAgICAgICAgZm9yY2VzW2VkZ2UuZnJvbUlkXS5zcHJpbmdGeSArPSBmeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZvcmNlc1tlZGdlLnRvSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZm9yY2VzW2VkZ2UudG9JZF0ueCAtPSBmYWN0b3IgKiBmeDtcbiAgICAgICAgICAgICAgZm9yY2VzW2VkZ2UudG9JZF0ueSAtPSBmYWN0b3IgKiBmeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JjZXNbZWRnZS5mcm9tSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZm9yY2VzW2VkZ2UuZnJvbUlkXS54ICs9IGZhY3RvciAqIGZ4O1xuICAgICAgICAgICAgICBmb3JjZXNbZWRnZS5mcm9tSWRdLnkgKz0gZmFjdG9yICogZnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG5vcm1hbGl6ZSBzcHJpbmcgZm9yY2VzXG4gICAgICBzcHJpbmdGb3JjZSA9IDE7XG4gICAgICB2YXIgc3ByaW5nRngsIHNwcmluZ0Z5O1xuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbm9kZUluZGljZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICB2YXIgX25vZGVJZCA9IG5vZGVJbmRpY2VzW19pMl07XG4gICAgICAgIHNwcmluZ0Z4ID0gTWF0aC5taW4oc3ByaW5nRm9yY2UsIE1hdGgubWF4KC1zcHJpbmdGb3JjZSwgZm9yY2VzW19ub2RlSWRdLnNwcmluZ0Z4KSk7XG4gICAgICAgIHNwcmluZ0Z5ID0gTWF0aC5taW4oc3ByaW5nRm9yY2UsIE1hdGgubWF4KC1zcHJpbmdGb3JjZSwgZm9yY2VzW19ub2RlSWRdLnNwcmluZ0Z5KSk7XG5cbiAgICAgICAgZm9yY2VzW19ub2RlSWRdLnggKz0gc3ByaW5nRng7XG4gICAgICAgIGZvcmNlc1tfbm9kZUlkXS55ICs9IHNwcmluZ0Z5O1xuICAgICAgfVxuXG4gICAgICAvLyByZXRhaW4gZW5lcmd5IGJhbGFuY2VcbiAgICAgIHZhciB0b3RhbEZ4ID0gMDtcbiAgICAgIHZhciB0b3RhbEZ5ID0gMDtcbiAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IG5vZGVJbmRpY2VzLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgICAgdmFyIF9ub2RlSWQyID0gbm9kZUluZGljZXNbX2kzXTtcbiAgICAgICAgdG90YWxGeCArPSBmb3JjZXNbX25vZGVJZDJdLng7XG4gICAgICAgIHRvdGFsRnkgKz0gZm9yY2VzW19ub2RlSWQyXS55O1xuICAgICAgfVxuICAgICAgdmFyIGNvcnJlY3Rpb25GeCA9IHRvdGFsRnggLyBub2RlSW5kaWNlcy5sZW5ndGg7XG4gICAgICB2YXIgY29ycmVjdGlvbkZ5ID0gdG90YWxGeSAvIG5vZGVJbmRpY2VzLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgbm9kZUluZGljZXMubGVuZ3RoOyBfaTQrKykge1xuICAgICAgICB2YXIgX25vZGVJZDMgPSBub2RlSW5kaWNlc1tfaTRdO1xuICAgICAgICBmb3JjZXNbX25vZGVJZDNdLnggLT0gY29ycmVjdGlvbkZ4O1xuICAgICAgICBmb3JjZXNbX25vZGVJZDNdLnkgLT0gY29ycmVjdGlvbkZ5O1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gSGllcmFyY2hpY2FsU3ByaW5nU29sdmVyO1xufSgpO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IEhpZXJhcmNoaWNhbFNwcmluZ1NvbHZlcjtcblxuLyoqKi8gfSksXG4vKiAxNzYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9nZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxudmFyIF9CYXJuZXNIdXRTb2x2ZXIyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MSk7XG5cbnZhciBfQmFybmVzSHV0U29sdmVyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Jhcm5lc0h1dFNvbHZlcjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbi8qKlxuICogQGV4dGVuZHMgQmFybmVzSHV0U29sdmVyXG4gKi9cbnZhciBGb3JjZUF0bGFzMkJhc2VkUmVwdWxzaW9uU29sdmVyID0gZnVuY3Rpb24gKF9CYXJuZXNIdXRTb2x2ZXIpIHtcbiAgKDAsIF9pbmhlcml0czNbJ2RlZmF1bHQnXSkoRm9yY2VBdGxhczJCYXNlZFJlcHVsc2lvblNvbHZlciwgX0Jhcm5lc0h1dFNvbHZlcik7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7e3BoeXNpY3NOb2RlSW5kaWNlczogQXJyYXksIHBoeXNpY3NFZGdlSW5kaWNlczogQXJyYXksIGZvcmNlczoge30sIHZlbG9jaXRpZXM6IHt9fX0gcGh5c2ljc0JvZHlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIEZvcmNlQXRsYXMyQmFzZWRSZXB1bHNpb25Tb2x2ZXIoYm9keSwgcGh5c2ljc0JvZHksIG9wdGlvbnMpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrM1snZGVmYXVsdCddKSh0aGlzLCBGb3JjZUF0bGFzMkJhc2VkUmVwdWxzaW9uU29sdmVyKTtcbiAgICByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuM1snZGVmYXVsdCddKSh0aGlzLCAoRm9yY2VBdGxhczJCYXNlZFJlcHVsc2lvblNvbHZlci5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjJbJ2RlZmF1bHQnXSkoRm9yY2VBdGxhczJCYXNlZFJlcHVsc2lvblNvbHZlcikpLmNhbGwodGhpcywgYm9keSwgcGh5c2ljc0JvZHksIG9wdGlvbnMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGZvcmNlcyBiYXNlZCBvbiB0aGUgZGlzdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZVxuICAgKiBAcGFyYW0ge251bWJlcn0gZHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IGR5XG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyZW50QnJhbmNoXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoRm9yY2VBdGxhczJCYXNlZFJlcHVsc2lvblNvbHZlciwgW3tcbiAgICBrZXk6ICdfY2FsY3VsYXRlRm9yY2VzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGN1bGF0ZUZvcmNlcyhkaXN0YW5jZSwgZHgsIGR5LCBub2RlLCBwYXJlbnRCcmFuY2gpIHtcbiAgICAgIGlmIChkaXN0YW5jZSA9PT0gMCkge1xuICAgICAgICBkaXN0YW5jZSA9IDAuMSAqIE1hdGgucmFuZG9tKCk7XG4gICAgICAgIGR4ID0gZGlzdGFuY2U7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm92ZXJsYXBBdm9pZGFuY2VGYWN0b3IgPCAxICYmIG5vZGUuc2hhcGUucmFkaXVzKSB7XG4gICAgICAgIGRpc3RhbmNlID0gTWF0aC5tYXgoMC4xICsgdGhpcy5vdmVybGFwQXZvaWRhbmNlRmFjdG9yICogbm9kZS5zaGFwZS5yYWRpdXMsIGRpc3RhbmNlIC0gbm9kZS5zaGFwZS5yYWRpdXMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVncmVlID0gbm9kZS5lZGdlcy5sZW5ndGggKyAxO1xuICAgICAgLy8gdGhlIGRpdmlkaW5nIGJ5IHRoZSBkaXN0YW5jZSBjdWJlZCBpbnN0ZWFkIG9mIHNxdWFyZWQgYWxsb3dzIHVzIHRvIGdldCB0aGUgZnggYW5kIGZ5IGNvbXBvbmVudHMgd2l0aG91dCBzaW5lcyBhbmQgY29zaW5lc1xuICAgICAgLy8gaXQgaXMgc2hvcnRoYW5kIGZvciBncmF2aXR5Zm9yY2Ugd2l0aCBkaXN0YW5jZSBzcXVhcmVkIGFuZCBmeCA9IGR4L2Rpc3RhbmNlICogZ3Jhdml0eUZvcmNlXG4gICAgICB2YXIgZ3Jhdml0eUZvcmNlID0gdGhpcy5vcHRpb25zLmdyYXZpdGF0aW9uYWxDb25zdGFudCAqIHBhcmVudEJyYW5jaC5tYXNzICogbm9kZS5vcHRpb25zLm1hc3MgKiBkZWdyZWUgLyBNYXRoLnBvdyhkaXN0YW5jZSwgMik7XG4gICAgICB2YXIgZnggPSBkeCAqIGdyYXZpdHlGb3JjZTtcbiAgICAgIHZhciBmeSA9IGR5ICogZ3Jhdml0eUZvcmNlO1xuXG4gICAgICB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tub2RlLmlkXS54ICs9IGZ4O1xuICAgICAgdGhpcy5waHlzaWNzQm9keS5mb3JjZXNbbm9kZS5pZF0ueSArPSBmeTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEZvcmNlQXRsYXMyQmFzZWRSZXB1bHNpb25Tb2x2ZXI7XG59KF9CYXJuZXNIdXRTb2x2ZXIzWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBGb3JjZUF0bGFzMkJhc2VkUmVwdWxzaW9uU29sdmVyO1xuXG4vKioqLyB9KSxcbi8qIDE3NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2dldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cbnZhciBfaW5oZXJpdHMyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG52YXIgX0NlbnRyYWxHcmF2aXR5U29sdmVyMiA9IF9fd2VicGFja19yZXF1aXJlX18oODIpO1xuXG52YXIgX0NlbnRyYWxHcmF2aXR5U29sdmVyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NlbnRyYWxHcmF2aXR5U29sdmVyMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLyoqXG4gKiBAZXh0ZW5kcyBDZW50cmFsR3Jhdml0eVNvbHZlclxuICovXG52YXIgRm9yY2VBdGxhczJCYXNlZENlbnRyYWxHcmF2aXR5U29sdmVyID0gZnVuY3Rpb24gKF9DZW50cmFsR3Jhdml0eVNvbHZlcikge1xuICAoMCwgX2luaGVyaXRzM1snZGVmYXVsdCddKShGb3JjZUF0bGFzMkJhc2VkQ2VudHJhbEdyYXZpdHlTb2x2ZXIsIF9DZW50cmFsR3Jhdml0eVNvbHZlcik7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7e3BoeXNpY3NOb2RlSW5kaWNlczogQXJyYXksIHBoeXNpY3NFZGdlSW5kaWNlczogQXJyYXksIGZvcmNlczoge30sIHZlbG9jaXRpZXM6IHt9fX0gcGh5c2ljc0JvZHlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIEZvcmNlQXRsYXMyQmFzZWRDZW50cmFsR3Jhdml0eVNvbHZlcihib2R5LCBwaHlzaWNzQm9keSwgb3B0aW9ucykge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIEZvcmNlQXRsYXMyQmFzZWRDZW50cmFsR3Jhdml0eVNvbHZlcik7XG4gICAgcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjNbJ2RlZmF1bHQnXSkodGhpcywgKEZvcmNlQXRsYXMyQmFzZWRDZW50cmFsR3Jhdml0eVNvbHZlci5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjJbJ2RlZmF1bHQnXSkoRm9yY2VBdGxhczJCYXNlZENlbnRyYWxHcmF2aXR5U29sdmVyKSkuY2FsbCh0aGlzLCBib2R5LCBwaHlzaWNzQm9keSwgb3B0aW9ucykpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgZm9yY2VzIGJhc2VkIG9uIHRoZSBkaXN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkeFxuICAgKiBAcGFyYW0ge251bWJlcn0gZHlcbiAgICogQHBhcmFtIHtPYmplY3Q8Tm9kZS5pZCwgTm9kZT59IGZvcmNlc1xuICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzM1snZGVmYXVsdCddKShGb3JjZUF0bGFzMkJhc2VkQ2VudHJhbEdyYXZpdHlTb2x2ZXIsIFt7XG4gICAga2V5OiAnX2NhbGN1bGF0ZUZvcmNlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxjdWxhdGVGb3JjZXMoZGlzdGFuY2UsIGR4LCBkeSwgZm9yY2VzLCBub2RlKSB7XG4gICAgICBpZiAoZGlzdGFuY2UgPiAwKSB7XG4gICAgICAgIHZhciBkZWdyZWUgPSBub2RlLmVkZ2VzLmxlbmd0aCArIDE7XG4gICAgICAgIHZhciBncmF2aXR5Rm9yY2UgPSB0aGlzLm9wdGlvbnMuY2VudHJhbEdyYXZpdHkgKiBkZWdyZWUgKiBub2RlLm9wdGlvbnMubWFzcztcbiAgICAgICAgZm9yY2VzW25vZGUuaWRdLnggPSBkeCAqIGdyYXZpdHlGb3JjZTtcbiAgICAgICAgZm9yY2VzW25vZGUuaWRdLnkgPSBkeSAqIGdyYXZpdHlGb3JjZTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEZvcmNlQXRsYXMyQmFzZWRDZW50cmFsR3Jhdml0eVNvbHZlcjtcbn0oX0NlbnRyYWxHcmF2aXR5U29sdmVyM1snZGVmYXVsdCddKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gRm9yY2VBdGxhczJCYXNlZENlbnRyYWxHcmF2aXR5U29sdmVyO1xuXG4vKioqLyB9KSxcbi8qIDE3OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2tleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG52YXIgX2tleXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfa2V5cyk7XG5cbnZhciBfdHlwZW9mMiA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbnZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiMgVE9ET1xuXG4tIGBlZGdlUmVwbGFjZWRCeUlkYCBub3QgY2xlYW5lZCB1cCB5ZXQgb24gY2x1c3RlciBlZGdlIHJlbW92YWxcbi0gYWxsb3dTaW5nbGVOb2RlQ2x1c3RlciBjb3VsZCBiZSBhIGdsb2JhbCBvcHRpb24gYXMgd2VsbDsgY3VycmVudGx5IG5lZWRzIHRvIGFsd2F5c1xuICBiZSBwYXNzZWQgdG8gY2x1c3RlcmluZyBtZXRob2RzXG5cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuIyBTdGF0ZSBNb2RlbCBmb3IgQ2x1c3RlcmluZ1xuXG5UaGUgdG90YWwgc3RhdGUgZm9yIGNsdXN0ZXJpbmcgaXMgbm9uLXRyaXZpYWwuIEl0IGlzIHVzZWZ1bCB0byBoYXZlIGEgbW9kZWxcbmF2YWlsYWJsZSBhcyB0byBob3cgaXQgd29ya3MuIFRoZSBmb2xsb3dpbmcgZG9jdW1lbnRzIHRoZSByZWxldmFudCBzdGF0ZSBpdGVtcy5cblxuXG4jIyBOZXR3b3JrIFN0YXRlXG5cblRoZSBmb2xsb3dpbmcgYG5ldHdvcmtgLW1lbWJlcnMgYXJlIHJlbGV2YW50IHRvIGNsdXN0ZXJpbmc6XG5cbi0gYGJvZHkubm9kZXNgICAgICAgIC0gYWxsIG5vZGVzIGFjdGl2ZWx5IHBhcnRpY2lwYXRpbmcgaW4gdGhlIG5ldHdvcmtcbi0gYGJvZHkuZWRnZXNgICAgICAgIC0gc2FtZSBmb3IgZWRnZXNcbi0gYGJvZHkubm9kZUluZGljZXNgIC0gaWQncyBvZiBub2RlcyB0aGF0IGFyZSB2aXNpYmxlIGF0IGEgZ2l2ZW4gbW9tZW50XG4tIGBib2R5LmVkZ2VJbmRpY2VzYCAtIHNhbWUgZm9yIGVkZ2VzXG5cblRoaXMgaW5jbHVkZXM6XG5cbi0gaGVscGVyIG5vZGVzIGZvciBkcmFnZ2luZyBpbiBgbWFuaXB1bGF0aW9uYFxuLSBoZWxwZXIgbm9kZXMgZm9yIGVkZ2UgdHlwZSBgZHluYW1pY2Bcbi0gY2x1c3RlciBub2RlcyBhbmQgZWRnZXNcbi0gdGhlcmUgbWF5IGJlIG1vcmUgdGhhbiB0aGlzLlxuXG5BIG5vZGUvZWRnZSBtYXkgYmUgbWlzc2luZyBpbiB0aGUgYEluZGljZXNgIG1lbWJlciBpZjpcblxuLSBpdCBpcyBhIGhlbHBlciBub2RlXG4tIHRoZSBub2RlIG9yIGVkZ2Ugc3RhdGUgaGFzIG9wdGlvbiBgaGlkZGVuYCBzZXRcbi0gSXQgaXMgbm90IHZpc2libGUgZHVlIHRvIGNsdXN0ZXJpbmdcblxuXG4jIyBDbHVzdGVyaW5nIFN0YXRlXG5cbkZvciB0aGUgaGFzaGVzLCB0aGUgaWQncyBvZiB0aGUgbm9kZXMvZWRnZXMgYXJlIHVzZWQgYXMga2V5LlxuXG5NZW1iZXIgYG5ldHdvcmsuY2x1c3RlcmluZ2AgY29udGFpbnMgdGhlIGZvbGxvd2luZyBpdGVtczpcblxuLSBgY2x1c3RlcmVkTm9kZXNgIC0gaGFzaCB3aXRoIHZhbHVlczogeyBjbHVzdGVySWQ6IDxpZCBvZiBjbHVzdGVyPiwgbm9kZTogPG5vZGUgaW5zdGFuY2U+fVxuLSBgY2x1c3RlcmVkRWRnZXNgIC0gaGFzaCB3aXRoIHZhbHVlczogcmVzdG9yZSBpbmZvcm1hdGlvbiBmb3IgZ2l2ZW4gZWRnZVxuXG5cbkR1ZSB0byBuZXN0aW5nIG9mIGNsdXN0ZXJzLCB0aGVzZSBtZW1iZXJzIGNhbiBjb250YWluIGNsdXN0ZXIgbm9kZXMgYW5kIGVkZ2VzIGFzIHdlbGwuXG5cblRoZSBpbXBvcnRhbnQgdGhpbmcgdG8gbm90ZSBoZXJlLCBpcyB0aGF0IHRoZSBjbHVzdGVyZWQgbm9kZXMgYW5kIGVkZ2VzIGFsc29cbmFwcGVhciBpbiB0aGUgbWVtYmVycyBvZiB0aGUgY2x1c3RlciBub2Rlcy4gRm9yIGRhdGEgdXBkYXRlLCBpdCBpcyB0aGVyZWZvcmUgXG5pbXBvcnRhbnQgdG8gc2NhbiB0aGVzZSBsaXN0cyBhcyB3ZWxsIGFzIHRoZSBjbHVzdGVyIG5vZGVzLlxuXG5cbiMjIyBDbHVzdGVyIE5vZGVcblxuQSBjbHVzdGVyIG5vZGUgaGFzIHRoZSBmb2xsb3dpbmcgZXh0cmEgZmllbGRzOlxuXG4tIGBpc0NsdXN0ZXIgOiB0cnVlYCAtIGluZGljYXRpb24gdGhhdCB0aGlzIGlzIGEgY2x1c3RlciBub2RlXG4tIGBjb250YWluZWROb2Rlc2AgICAtIGhhc2ggb2Ygbm9kZXMgY29udGFpbmVkIGluIHRoaXMgY2x1c3RlclxuLSBgY29udGFpbmVkRWRnZXNgICAgLSBzYW1lIGZvciBlZGdlc1xuLSBgZWRnZXNgICAgICAgICAgICAgLSBhcnJheSBvZiBjbHVzdGVyIGVkZ2VzIGZvciB0aGlzIG5vZGUgXG5cblxuKipOT1RFOioqXG5cbi0gYGNvbnRhaW5lZEVkZ2VzYCBjYW4gYWxzbyBjb250YWluIGVkZ2VzIHdoaWNoIGFyZSBub3QgY2x1c3RlcmVkOyBlLmcuIGFuIGVkZ2VcbiAgIGNvbm5lY3RpbmcgdHdvIG5vZGVzIGluIHRoZSBzYW1lIGNsdXN0ZXIuXG5cblxuIyMjIENsdXN0ZXIgRWRnZVxuXG5UaGVzZSBhcmUgdGhlIGl0ZW1zIGluIHRoZSBgZWRnZXNgIG1lbWJlciBvZiBhIGNsdXN0ZXJlZCBub2RlLiBUaGV5IGhhdmUgdGhlXG5mb2xsb3dpbmcgcmVsZXZhbnQgbWVtYmVyczpcblxuLSAnY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZHNgIC0gYXJyYXkgb2YgaWQncyBvZiBlZGdlcyByZXBsYWNlZCBieSB0aGlzIGVkZ2VcblxuTm90ZSB0aGF0IGl0J3MgcG9zc2libGUgdG8gbmVzdCBjbHVzdGVycywgc28gdGhhdCBgY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZHNgXG5jYW4gY29udGFpbiBlZGdlIGlkJ3Mgb2Ygb3RoZXIgY2x1c3RlcnMuXG5cblxuIyMjIENsdXN0ZXJlZCBFZGdlXG5cblRoaXMgaXMgYW55IGVkZ2UgY29udGFpbmVkIGJ5IGEgY2x1c3RlciBlZGdlLiBJdCBnZXRzIHRoZSBmb2xsb3dpbmcgYWRkaXRpb25hbFxubWVtYmVyOlxuXG4tIGBlZGdlUmVwbGFjZWRCeUlkYCAtIGlkIG9mIHRoZSBjbHVzdGVyIGVkZ2UgaW4gd2hpY2ggY3VycmVudCBlZGdlIGlzIGNsdXN0ZXJlZFxuXG5cbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xudmFyIE5ldHdvcmtVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NylbJ2RlZmF1bHQnXTtcbnZhciBDbHVzdGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNzkpWydkZWZhdWx0J107XG52YXIgRWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTUpWydkZWZhdWx0J107IC8vIE9ubHkgbmVlZGVkIGZvciBjaGVjayBvbiB0eXBlIVxudmFyIE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KVsnZGVmYXVsdCddOyAvLyBPbmx5IG5lZWRlZCBmb3IgY2hlY2sgb24gdHlwZSFcblxuLyoqXG4gKiBUaGUgY2x1c3RlcmluZyBlbmdpbmVcbiAqL1xuXG52YXIgQ2x1c3RlckVuZ2luZSA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5XG4gICAqL1xuICBmdW5jdGlvbiBDbHVzdGVyRW5naW5lKGJvZHkpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgQ2x1c3RlckVuZ2luZSk7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuY2x1c3RlcmVkTm9kZXMgPSB7fTsgLy8ga2V5OiBub2RlIGlkLCB2YWx1ZTogeyBjbHVzdGVySWQ6IDxpZCBvZiBjbHVzdGVyPiwgbm9kZTogPG5vZGUgaW5zdGFuY2U+fVxuICAgIHRoaXMuY2x1c3RlcmVkRWRnZXMgPSB7fTsgLy8ga2V5OiBlZGdlIGlkLCB2YWx1ZTogcmVzdG9yZSBpbmZvcm1hdGlvbiBmb3IgZ2l2ZW4gZWRnZVxuXG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHt9O1xuICAgIHV0aWwuZXh0ZW5kKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignX3Jlc2V0RGF0YScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLmNsdXN0ZXJlZE5vZGVzID0ge307XG4gICAgICBfdGhpcy5jbHVzdGVyZWRFZGdlcyA9IHt9O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBodWJzaXplXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoQ2x1c3RlckVuZ2luZSwgW3tcbiAgICBrZXk6ICdjbHVzdGVyQnlIdWJzaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2x1c3RlckJ5SHVic2l6ZShodWJzaXplLCBvcHRpb25zKSB7XG4gICAgICBpZiAoaHVic2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGh1YnNpemUgPSB0aGlzLl9nZXRIdWJTaXplKCk7XG4gICAgICB9IGVsc2UgaWYgKCh0eXBlb2YgaHVic2l6ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6ICgwLCBfdHlwZW9mM1snZGVmYXVsdCddKShodWJzaXplKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLl9jaGVja09wdGlvbnMoaHVic2l6ZSk7XG4gICAgICAgIGh1YnNpemUgPSB0aGlzLl9nZXRIdWJTaXplKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBub2Rlc1RvQ2x1c3RlciA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbdGhpcy5ib2R5Lm5vZGVJbmRpY2VzW2ldXTtcbiAgICAgICAgaWYgKG5vZGUuZWRnZXMubGVuZ3RoID49IGh1YnNpemUpIHtcbiAgICAgICAgICBub2Rlc1RvQ2x1c3Rlci5wdXNoKG5vZGUuaWQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBub2Rlc1RvQ2x1c3Rlci5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdGhpcy5jbHVzdGVyQnlDb25uZWN0aW9uKG5vZGVzVG9DbHVzdGVyW19pXSwgb3B0aW9ucywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19kYXRhQ2hhbmdlZCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGxvb3Agb3ZlciBhbGwgbm9kZXMsIGNoZWNrIGlmIHRoZXkgYWRoZXJlIHRvIHRoZSBjb25kaXRpb24gYW5kIGNsdXN0ZXIgaWYgbmVlZGVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmVmcmVzaERhdGE9dHJ1ZV1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY2x1c3RlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsdXN0ZXIoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgdmFyIHJlZnJlc2hEYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuXG4gICAgICBpZiAob3B0aW9ucy5qb2luQ29uZGl0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY2FsbCBjbHVzdGVyQnlOb2RlRGF0YSB3aXRob3V0IGEgam9pbkNvbmRpdGlvbiBmdW5jdGlvbiBpbiB0aGUgb3B0aW9ucy4nKTtcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgaWYgdGhlIG9wdGlvbnMgb2JqZWN0IGlzIGZpbmUsIGFwcGVuZCBpZiBuZWVkZWRcbiAgICAgIG9wdGlvbnMgPSB0aGlzLl9jaGVja09wdGlvbnMob3B0aW9ucyk7XG5cbiAgICAgIHZhciBjaGlsZE5vZGVzT2JqID0ge307XG4gICAgICB2YXIgY2hpbGRFZGdlc09iaiA9IHt9O1xuXG4gICAgICAvLyBjb2xsZWN0IHRoZSBub2RlcyB0aGF0IHdpbGwgYmUgaW4gdGhlIGNsdXN0ZXJcbiAgICAgIHV0aWwuZm9yRWFjaCh0aGlzLmJvZHkubm9kZXMsIGZ1bmN0aW9uIChub2RlLCBub2RlSWQpIHtcbiAgICAgICAgaWYgKG5vZGUub3B0aW9ucyAmJiBvcHRpb25zLmpvaW5Db25kaXRpb24obm9kZS5vcHRpb25zKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGNoaWxkTm9kZXNPYmpbbm9kZUlkXSA9IG5vZGU7XG5cbiAgICAgICAgICAvLyBjb2xsZWN0IHRoZSBlZGdlcyB0aGF0IHdpbGwgYmUgaW4gdGhlIGNsdXN0ZXJcbiAgICAgICAgICB1dGlsLmZvckVhY2gobm9kZS5lZGdlcywgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgICAgIGlmIChfdGhpczIuY2x1c3RlcmVkRWRnZXNbZWRnZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBjaGlsZEVkZ2VzT2JqW2VkZ2UuaWRdID0gZWRnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX2NsdXN0ZXIoY2hpbGROb2Rlc09iaiwgY2hpbGRFZGdlc09iaiwgb3B0aW9ucywgcmVmcmVzaERhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsdXN0ZXIgYWxsIG5vZGVzIGluIHRoZSBuZXR3b3JrIHRoYXQgaGF2ZSBvbmx5IFggZWRnZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZWRnZUNvdW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZWZyZXNoRGF0YT10cnVlXVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdjbHVzdGVyQnlFZGdlQ291bnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbHVzdGVyQnlFZGdlQ291bnQoZWRnZUNvdW50LCBvcHRpb25zKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIHJlZnJlc2hEYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuXG4gICAgICBvcHRpb25zID0gdGhpcy5fY2hlY2tPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgdmFyIGNsdXN0ZXJzID0gW107XG4gICAgICB2YXIgdXNlZE5vZGVzID0ge307XG4gICAgICB2YXIgZWRnZSA9IHZvaWQgMCxcbiAgICAgICAgICBlZGdlcyA9IHZvaWQgMCxcbiAgICAgICAgICByZWxldmFudEVkZ2VDb3VudCA9IHZvaWQgMDtcbiAgICAgIC8vIGNvbGxlY3QgdGhlIG5vZGVzIHRoYXQgd2lsbCBiZSBpbiB0aGUgY2x1c3RlclxuXG4gICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChpKSB7XG4gICAgICAgIHZhciBjaGlsZE5vZGVzT2JqID0ge307XG4gICAgICAgIHZhciBjaGlsZEVkZ2VzT2JqID0ge307XG4gICAgICAgIHZhciBub2RlSWQgPSBfdGhpczMuYm9keS5ub2RlSW5kaWNlc1tpXTtcbiAgICAgICAgdmFyIG5vZGUgPSBfdGhpczMuYm9keS5ub2Rlc1tub2RlSWRdO1xuXG4gICAgICAgIC8vIGlmIHRoaXMgbm9kZSBpcyBhbHJlYWR5IHVzZWQgaW4gYW5vdGhlciBjbHVzdGVyIHRoaXMgc2Vzc2lvbiwgd2UgZG8gbm90IGhhdmUgdG8gcmUtZXZhbHVhdGUgaXQuXG4gICAgICAgIGlmICh1c2VkTm9kZXNbbm9kZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVsZXZhbnRFZGdlQ291bnQgPSAwO1xuICAgICAgICAgIGVkZ2VzID0gW107XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2RlLmVkZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBlZGdlID0gbm9kZS5lZGdlc1tqXTtcbiAgICAgICAgICAgIGlmIChfdGhpczMuY2x1c3RlcmVkRWRnZXNbZWRnZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBpZiAoZWRnZS50b0lkICE9PSBlZGdlLmZyb21JZCkge1xuICAgICAgICAgICAgICAgIHJlbGV2YW50RWRnZUNvdW50Kys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWRnZXMucHVzaChlZGdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB0aGlzIG5vZGUgcXVhbGlmaWVzLCB3ZSBjb2xsZWN0IGl0cyBuZWlnaGJvdXJzIHRvIHN0YXJ0IHRoZSBjbHVzdGVyaW5nIHByb2Nlc3MuXG4gICAgICAgICAgaWYgKHJlbGV2YW50RWRnZUNvdW50ID09PSBlZGdlQ291bnQpIHtcbiAgICAgICAgICAgIGNoZWNrSm9pbkNvbmRpdGlvbiA9IGZ1bmN0aW9uIGNoZWNrSm9pbkNvbmRpdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLmpvaW5Db25kaXRpb24gPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmpvaW5Db25kaXRpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBjbG9uZWRPcHRpb25zID0gTmV0d29ya1V0aWwuY2xvbmVPcHRpb25zKG5vZGUpO1xuICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5qb2luQ29uZGl0aW9uKGNsb25lZE9wdGlvbnMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGdhdGhlcmluZ1N1Y2Nlc3NmdWwgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IGVkZ2VzLmxlbmd0aDsgX2orKykge1xuICAgICAgICAgICAgICBlZGdlID0gZWRnZXNbX2pdO1xuICAgICAgICAgICAgICB2YXIgY2hpbGROb2RlSWQgPSBfdGhpczMuX2dldENvbm5lY3RlZElkKGVkZ2UsIG5vZGVJZCk7XG4gICAgICAgICAgICAgIC8vIGFkZCB0aGUgbm9kZXMgdG8gdGhlIGxpc3QgYnkgdGhlIGpvaW4gY29uZGl0aW9uLlxuICAgICAgICAgICAgICBpZiAoY2hlY2tKb2luQ29uZGl0aW9uKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRFZGdlc09ialtlZGdlLmlkXSA9IGVkZ2U7XG4gICAgICAgICAgICAgICAgY2hpbGROb2Rlc09ialtub2RlSWRdID0gbm9kZTtcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVzT2JqW2NoaWxkTm9kZUlkXSA9IF90aGlzMy5ib2R5Lm5vZGVzW2NoaWxkTm9kZUlkXTtcbiAgICAgICAgICAgICAgICB1c2VkTm9kZXNbbm9kZUlkXSA9IHRydWU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBub2RlIGRvZXMgbm90IHF1YWxpZnkgYWZ0ZXIgYWxsLlxuICAgICAgICAgICAgICAgIGdhdGhlcmluZ1N1Y2Nlc3NmdWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBhZGQgdG8gdGhlIGNsdXN0ZXIgcXVldWVcbiAgICAgICAgICAgIGlmICgoMCwgX2tleXMyWydkZWZhdWx0J10pKGNoaWxkTm9kZXNPYmopLmxlbmd0aCA+IDAgJiYgKDAsIF9rZXlzMlsnZGVmYXVsdCddKShjaGlsZEVkZ2VzT2JqKS5sZW5ndGggPiAwICYmIGdhdGhlcmluZ1N1Y2Nlc3NmdWwgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIFNlYXJjaCBmb3IgY2x1c3RlciBkYXRhIHRoYXQgY29udGFpbnMgYW55IG9mIHRoZSBub2RlIGlkJ3NcbiAgICAgICAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgbm8gam9pbkNvbmRpdGlvbiwgb3RoZXJ3aXNlIHJldHVybiB2YWx1ZSBvZiBqb2luQ29uZGl0aW9uXG4gICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICBmaW5kQ2x1c3RlckRhdGEgPSBmdW5jdGlvbiBmaW5kQ2x1c3RlckRhdGEoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBjbHVzdGVycy5sZW5ndGg7ICsrbikge1xuICAgICAgICAgICAgICAgICAgLy8gU2VhcmNoIGZvciBhIGNsdXN0ZXIgY29udGFpbmluZyBhbnkgb2YgdGhlIG5vZGUgaWQnc1xuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbSBpbiBjaGlsZE5vZGVzT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbHVzdGVyc1tuXS5ub2Rlc1ttXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsdXN0ZXJzW25dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAvLyBJZiBhbnkgb2YgdGhlIGZvdW5kIG5vZGVzIGlzIHBhcnQgb2YgYSBjbHVzdGVyIGZvdW5kIGluIHRoaXMgbWV0aG9kLFxuICAgICAgICAgICAgICAvLyBhZGQgdGhlIGN1cnJlbnQgdmFsdWVzIHRvIHRoYXQgY2x1c3RlclxuXG5cbiAgICAgICAgICAgICAgZm91bmRDbHVzdGVyID0gZmluZENsdXN0ZXJEYXRhKCk7XG5cbiAgICAgICAgICAgICAgaWYgKGZvdW5kQ2x1c3RlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIG5vZGVzIHRvIGZvdW5kIGNsdXN0ZXIgaWYgbm90IHByZXNlbnRcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBtIGluIGNoaWxkTm9kZXNPYmopIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmb3VuZENsdXN0ZXIubm9kZXNbbV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZENsdXN0ZXIubm9kZXNbbV0gPSBjaGlsZE5vZGVzT2JqW21dO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFkZCBlZGdlcyB0byBmb3VuZCBjbHVzdGVyLCBpZiBub3QgcHJlc2VudFxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9tIGluIGNoaWxkRWRnZXNPYmopIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmb3VuZENsdXN0ZXIuZWRnZXNbX21dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRDbHVzdGVyLmVkZ2VzW19tXSA9IGNoaWxkRWRnZXNPYmpbX21dO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgY2x1c3RlciBncm91cFxuICAgICAgICAgICAgICAgIGNsdXN0ZXJzLnB1c2goeyBub2RlczogY2hpbGROb2Rlc09iaiwgZWRnZXM6IGNoaWxkRWRnZXNPYmogfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVja0pvaW5Db25kaXRpb247XG4gICAgICAgIHZhciBmaW5kQ2x1c3RlckRhdGE7XG4gICAgICAgIHZhciBmb3VuZENsdXN0ZXI7XG5cbiAgICAgICAgX2xvb3AoaSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2x1c3RlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5fY2x1c3RlcihjbHVzdGVyc1tpXS5ub2RlcywgY2x1c3RlcnNbaV0uZWRnZXMsIG9wdGlvbnMsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZnJlc2hEYXRhID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19kYXRhQ2hhbmdlZCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsdXN0ZXIgYWxsIG5vZGVzIGluIHRoZSBuZXR3b3JrIHRoYXQgaGF2ZSBvbmx5IDEgZWRnZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmVmcmVzaERhdGE9dHJ1ZV1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY2x1c3Rlck91dGxpZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2x1c3Rlck91dGxpZXJzKG9wdGlvbnMpIHtcbiAgICAgIHZhciByZWZyZXNoRGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcblxuICAgICAgdGhpcy5jbHVzdGVyQnlFZGdlQ291bnQoMSwgb3B0aW9ucywgcmVmcmVzaERhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsdXN0ZXIgYWxsIG5vZGVzIGluIHRoZSBuZXR3b3JrIHRoYXQgaGF2ZSBvbmx5IDIgZWRnZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmVmcmVzaERhdGE9dHJ1ZV1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY2x1c3RlckJyaWRnZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbHVzdGVyQnJpZGdlcyhvcHRpb25zKSB7XG4gICAgICB2YXIgcmVmcmVzaERhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG5cbiAgICAgIHRoaXMuY2x1c3RlckJ5RWRnZUNvdW50KDIsIG9wdGlvbnMsIHJlZnJlc2hEYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzdWNrIGFsbCBjb25uZWN0ZWQgbm9kZXMgb2YgYSBub2RlIGludG8gdGhlIG5vZGUuXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBub2RlSWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlZnJlc2hEYXRhPXRydWVdXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2NsdXN0ZXJCeUNvbm5lY3Rpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbHVzdGVyQnlDb25uZWN0aW9uKG5vZGVJZCwgb3B0aW9ucykge1xuICAgICAgdmFyIHJlZnJlc2hEYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuXG4gICAgICAvLyBraWxsIGNvbmRpdGlvbnNcbiAgICAgIGlmIChub2RlSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG5vZGVJZCBzdXBwbGllZCB0byBjbHVzdGVyQnlDb25uZWN0aW9uIScpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgbm9kZUlkIGdpdmVuIHRvIGNsdXN0ZXJCeUNvbm5lY3Rpb24gZG9lcyBub3QgZXhpc3QhJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICBvcHRpb25zID0gdGhpcy5fY2hlY2tPcHRpb25zKG9wdGlvbnMsIG5vZGUpO1xuICAgICAgaWYgKG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLnggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLmNsdXN0ZXJOb2RlUHJvcGVydGllcy54ID0gbm9kZS54O1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLmNsdXN0ZXJOb2RlUHJvcGVydGllcy55ID0gbm9kZS55O1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmZpeGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5jbHVzdGVyTm9kZVByb3BlcnRpZXMuZml4ZWQgPSB7fTtcbiAgICAgICAgb3B0aW9ucy5jbHVzdGVyTm9kZVByb3BlcnRpZXMuZml4ZWQueCA9IG5vZGUub3B0aW9ucy5maXhlZC54O1xuICAgICAgICBvcHRpb25zLmNsdXN0ZXJOb2RlUHJvcGVydGllcy5maXhlZC55ID0gbm9kZS5vcHRpb25zLmZpeGVkLnk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGlsZE5vZGVzT2JqID0ge307XG4gICAgICB2YXIgY2hpbGRFZGdlc09iaiA9IHt9O1xuICAgICAgdmFyIHBhcmVudE5vZGVJZCA9IG5vZGUuaWQ7XG4gICAgICB2YXIgcGFyZW50Q2xvbmVkT3B0aW9ucyA9IE5ldHdvcmtVdGlsLmNsb25lT3B0aW9ucyhub2RlKTtcbiAgICAgIGNoaWxkTm9kZXNPYmpbcGFyZW50Tm9kZUlkXSA9IG5vZGU7XG5cbiAgICAgIC8vIGNvbGxlY3QgdGhlIG5vZGVzIHRoYXQgd2lsbCBiZSBpbiB0aGUgY2x1c3RlclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlZGdlID0gbm9kZS5lZGdlc1tpXTtcbiAgICAgICAgaWYgKHRoaXMuY2x1c3RlcmVkRWRnZXNbZWRnZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBjaGlsZE5vZGVJZCA9IHRoaXMuX2dldENvbm5lY3RlZElkKGVkZ2UsIHBhcmVudE5vZGVJZCk7XG5cbiAgICAgICAgICAvLyBpZiB0aGUgY2hpbGQgbm9kZSBpcyBub3QgaW4gYSBjbHVzdGVyXG4gICAgICAgICAgaWYgKHRoaXMuY2x1c3RlcmVkTm9kZXNbY2hpbGROb2RlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGVJZCAhPT0gcGFyZW50Tm9kZUlkKSB7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLmpvaW5Db25kaXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNoaWxkRWRnZXNPYmpbZWRnZS5pZF0gPSBlZGdlO1xuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXNPYmpbY2hpbGROb2RlSWRdID0gdGhpcy5ib2R5Lm5vZGVzW2NoaWxkTm9kZUlkXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjbG9uZSB0aGUgb3B0aW9ucyBhbmQgaW5zZXJ0IHNvbWUgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIHRoYXQgY291bGQgYmUgaW50ZXJlc3RpbmcuXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkQ2xvbmVkT3B0aW9ucyA9IE5ldHdvcmtVdGlsLmNsb25lT3B0aW9ucyh0aGlzLmJvZHkubm9kZXNbY2hpbGROb2RlSWRdKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5qb2luQ29uZGl0aW9uKHBhcmVudENsb25lZE9wdGlvbnMsIGNoaWxkQ2xvbmVkT3B0aW9ucykgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIGNoaWxkRWRnZXNPYmpbZWRnZS5pZF0gPSBlZGdlO1xuICAgICAgICAgICAgICAgICAgY2hpbGROb2Rlc09ialtjaGlsZE5vZGVJZF0gPSB0aGlzLmJvZHkubm9kZXNbY2hpbGROb2RlSWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gc3dhbGxvdyB0aGUgZWRnZSBpZiBpdCBpcyBzZWxmLXJlZmVyZW5jaW5nLlxuICAgICAgICAgICAgICBjaGlsZEVkZ2VzT2JqW2VkZ2UuaWRdID0gZWRnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZE5vZGVJRHMgPSAoMCwgX2tleXMyWydkZWZhdWx0J10pKGNoaWxkTm9kZXNPYmopLm1hcChmdW5jdGlvbiAoY2hpbGROb2RlKSB7XG4gICAgICAgIHJldHVybiBjaGlsZE5vZGVzT2JqW2NoaWxkTm9kZV0uaWQ7XG4gICAgICB9KTtcblxuICAgICAgZm9yIChjaGlsZE5vZGUgaW4gY2hpbGROb2Rlc09iaikge1xuICAgICAgICBpZiAoIWNoaWxkTm9kZXNPYmouaGFzT3duUHJvcGVydHkoY2hpbGROb2RlKSkgY29udGludWU7XG5cbiAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXNPYmpbY2hpbGROb2RlXTtcbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBjaGlsZE5vZGUuZWRnZXMubGVuZ3RoOyB5KyspIHtcbiAgICAgICAgICB2YXIgY2hpbGRFZGdlID0gY2hpbGROb2RlLmVkZ2VzW3ldO1xuICAgICAgICAgIGlmIChjaGlsZE5vZGVJRHMuaW5kZXhPZih0aGlzLl9nZXRDb25uZWN0ZWRJZChjaGlsZEVkZ2UsIGNoaWxkTm9kZS5pZCkpID4gLTEpIHtcbiAgICAgICAgICAgIGNoaWxkRWRnZXNPYmpbY2hpbGRFZGdlLmlkXSA9IGNoaWxkRWRnZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2NsdXN0ZXIoY2hpbGROb2Rlc09iaiwgY2hpbGRFZGdlc09iaiwgb3B0aW9ucywgcmVmcmVzaERhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gY3JlYXRlcyB0aGUgZWRnZXMgdGhhdCB3aWxsIGJlIGF0dGFjaGVkIHRvIHRoZSBjbHVzdGVyXG4gICAgICogSXQgbG9va3MgZm9yIGVkZ2VzIHRoYXQgYXJlIGNvbm5lY3RlZCB0byB0aGUgbm9kZXMgZnJvbSB0aGUgXCJvdXRzaWRlJyBvZiB0aGUgY2x1c3Rlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e05vZGUuaWQ6IHZpcy5Ob2RlfX0gY2hpbGROb2Rlc09ialxuICAgICAqIEBwYXJhbSB7e3Zpcy5FZGdlLmlkOiB2aXMuRWRnZX19IGNoaWxkRWRnZXNPYmpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2x1c3Rlck5vZGVQcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNsdXN0ZXJFZGdlUHJvcGVydGllc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19jcmVhdGVDbHVzdGVyRWRnZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlQ2x1c3RlckVkZ2VzKGNoaWxkTm9kZXNPYmosIGNoaWxkRWRnZXNPYmosIGNsdXN0ZXJOb2RlUHJvcGVydGllcywgY2x1c3RlckVkZ2VQcm9wZXJ0aWVzKSB7XG4gICAgICB2YXIgZWRnZSA9IHZvaWQgMCxcbiAgICAgICAgICBjaGlsZE5vZGVJZCA9IHZvaWQgMCxcbiAgICAgICAgICBjaGlsZE5vZGUgPSB2b2lkIDAsXG4gICAgICAgICAgdG9JZCA9IHZvaWQgMCxcbiAgICAgICAgICBmcm9tSWQgPSB2b2lkIDAsXG4gICAgICAgICAgb3RoZXJOb2RlSWQgPSB2b2lkIDA7XG5cbiAgICAgIC8vIGxvb3Agb3ZlciBhbGwgY2hpbGQgbm9kZXMgYW5kIHRoZWlyIGVkZ2VzIHRvIGZpbmQgZWRnZXMgZ29pbmcgb3V0IG9mIHRoZSBjbHVzdGVyXG4gICAgICAvLyB0aGVzZSBlZGdlcyB3aWxsIGJlIHJlcGxhY2VkIGJ5IGNsdXN0ZXJFZGdlcy5cbiAgICAgIHZhciBjaGlsZEtleXMgPSAoMCwgX2tleXMyWydkZWZhdWx0J10pKGNoaWxkTm9kZXNPYmopO1xuICAgICAgdmFyIGNyZWF0ZUVkZ2VzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGlsZE5vZGVJZCA9IGNoaWxkS2V5c1tpXTtcbiAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2Rlc09ialtjaGlsZE5vZGVJZF07XG5cbiAgICAgICAgLy8gY29uc3RydWN0IG5ldyBlZGdlcyBmcm9tIHRoZSBjbHVzdGVyIHRvIG90aGVyc1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNoaWxkTm9kZS5lZGdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGVkZ2UgPSBjaGlsZE5vZGUuZWRnZXNbal07XG4gICAgICAgICAgLy8gd2Ugb25seSBoYW5kbGUgZWRnZXMgdGhhdCBhcmUgdmlzaWJsZSB0byB0aGUgc3lzdGVtLCBub3QgdGhlIGRpc2FibGVkIG9uZXMgZnJvbSB0aGUgY2x1c3RlcmluZyBwcm9jZXNzLlxuICAgICAgICAgIGlmICh0aGlzLmNsdXN0ZXJlZEVkZ2VzW2VkZ2UuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHNlbGYtcmVmZXJlbmNpbmcgZWRnZXMgd2lsbCBiZSBhZGRlZCB0byB0aGUgXCJoaWRkZW5cIiBsaXN0XG4gICAgICAgICAgICBpZiAoZWRnZS50b0lkID09IGVkZ2UuZnJvbUlkKSB7XG4gICAgICAgICAgICAgIGNoaWxkRWRnZXNPYmpbZWRnZS5pZF0gPSBlZGdlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gc2V0IHVwIHRoZSBmcm9tIGFuZCB0by5cbiAgICAgICAgICAgICAgaWYgKGVkZ2UudG9JZCA9PSBjaGlsZE5vZGVJZCkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBkb3VibGUgZXF1YWxzIGJlY2F1c2UgaW50cyBhbmQgc3RyaW5ncyBjYW4gYmUgaW50ZXJjaGFuZ2VkIGhlcmUuXG4gICAgICAgICAgICAgICAgdG9JZCA9IGNsdXN0ZXJOb2RlUHJvcGVydGllcy5pZDtcbiAgICAgICAgICAgICAgICBmcm9tSWQgPSBlZGdlLmZyb21JZDtcbiAgICAgICAgICAgICAgICBvdGhlck5vZGVJZCA9IGZyb21JZDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b0lkID0gZWRnZS50b0lkO1xuICAgICAgICAgICAgICAgIGZyb21JZCA9IGNsdXN0ZXJOb2RlUHJvcGVydGllcy5pZDtcbiAgICAgICAgICAgICAgICBvdGhlck5vZGVJZCA9IHRvSWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT25seSBlZGdlcyBmcm9tIHRoZSBjbHVzdGVyIG91dHdhcmRzIGFyZSBiZWluZyByZXBsYWNlZC5cbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGVzT2JqW290aGVyTm9kZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGNyZWF0ZUVkZ2VzLnB1c2goeyBlZGdlOiBlZGdlLCBmcm9tSWQ6IGZyb21JZCwgdG9JZDogdG9JZCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy9cbiAgICAgIC8vIEhlcmUgd2UgYWN0dWFsbHkgY3JlYXRlIHRoZSByZXBsYWNlbWVudCBlZGdlcy5cbiAgICAgIC8vXG4gICAgICAvLyBXZSBjb3VsZCBub3QgZG8gdGhpcyBpbiB0aGUgbG9vcCBhYm92ZSBhcyB0aGUgY3JlYXRpb24gcHJvY2Vzc1xuICAgICAgLy8gd291bGQgYWRkIGFuIGVkZ2UgdG8gdGhlIGVkZ2VzIGFycmF5IHdlIGFyZSBpdGVyYXRpbmcgb3Zlci5cbiAgICAgIC8vXG4gICAgICAvLyBOT1RFOiBhIGNsdXN0ZXJlZCBlZGdlIGNhbiBoYXZlIG11bHRpcGxlIGJhc2UgZWRnZXMhXG4gICAgICAvL1xuICAgICAgdmFyIG5ld0VkZ2VzID0gW107XG5cbiAgICAgIC8qKlxuICAgICAgICogRmluZCBhIGNsdXN0ZXIgZWRnZSB3aGljaCBtYXRjaGVzIHRoZSBnaXZlbiBjcmVhdGVkIGVkZ2UuXG4gICAgICAgKiBAcGFyYW0ge3Zpcy5FZGdlfSBjcmVhdGVkRWRnZVxuICAgICAgICogQHJldHVybnMge3Zpcy5FZGdlfVxuICAgICAgICovXG4gICAgICB2YXIgZ2V0TmV3RWRnZSA9IGZ1bmN0aW9uIGdldE5ld0VkZ2UoY3JlYXRlZEVkZ2UpIHtcbiAgICAgICAgZm9yICh2YXIgX2oyID0gMDsgX2oyIDwgbmV3RWRnZXMubGVuZ3RoOyBfajIrKykge1xuICAgICAgICAgIHZhciBuZXdFZGdlID0gbmV3RWRnZXNbX2oyXTtcblxuICAgICAgICAgIC8vIFdlIHJlcGxhY2UgYm90aCB0byBhbmQgZnJvbSBlZGdlcyB3aXRoIGEgc2luZ2xlIGNsdXN0ZXIgZWRnZVxuICAgICAgICAgIHZhciBtYXRjaFRvRGlyZWN0aW9uID0gY3JlYXRlZEVkZ2UuZnJvbUlkID09PSBuZXdFZGdlLmZyb21JZCAmJiBjcmVhdGVkRWRnZS50b0lkID09PSBuZXdFZGdlLnRvSWQ7XG4gICAgICAgICAgdmFyIG1hdGNoRnJvbURpcmVjdGlvbiA9IGNyZWF0ZWRFZGdlLmZyb21JZCA9PT0gbmV3RWRnZS50b0lkICYmIGNyZWF0ZWRFZGdlLnRvSWQgPT09IG5ld0VkZ2UuZnJvbUlkO1xuXG4gICAgICAgICAgaWYgKG1hdGNoVG9EaXJlY3Rpb24gfHwgbWF0Y2hGcm9tRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3RWRnZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIF9qMyA9IDA7IF9qMyA8IGNyZWF0ZUVkZ2VzLmxlbmd0aDsgX2ozKyspIHtcbiAgICAgICAgdmFyIGNyZWF0ZWRFZGdlID0gY3JlYXRlRWRnZXNbX2ozXTtcbiAgICAgICAgdmFyIF9lZGdlID0gY3JlYXRlZEVkZ2UuZWRnZTtcbiAgICAgICAgdmFyIG5ld0VkZ2UgPSBnZXROZXdFZGdlKGNyZWF0ZWRFZGdlKTtcblxuICAgICAgICBpZiAobmV3RWRnZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIENyZWF0ZSBhIGNsdXN0ZXJlZCBlZGdlIGZvciB0aGlzIGNvbm5lY3Rpb25cbiAgICAgICAgICBuZXdFZGdlID0gdGhpcy5fY3JlYXRlQ2x1c3RlcmVkRWRnZShjcmVhdGVkRWRnZS5mcm9tSWQsIGNyZWF0ZWRFZGdlLnRvSWQsIF9lZGdlLCBjbHVzdGVyRWRnZVByb3BlcnRpZXMpO1xuXG4gICAgICAgICAgbmV3RWRnZXMucHVzaChuZXdFZGdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdFZGdlLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzLnB1c2goX2VkZ2UuaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWxzbyByZWZlcmVuY2UgdGhlIG5ldyBlZGdlIGluIHRoZSBvbGQgZWRnZVxuICAgICAgICB0aGlzLmJvZHkuZWRnZXNbX2VkZ2UuaWRdLmVkZ2VSZXBsYWNlZEJ5SWQgPSBuZXdFZGdlLmlkO1xuXG4gICAgICAgIC8vIGhpZGUgdGhlIHJlcGxhY2VkIGVkZ2VcbiAgICAgICAgdGhpcy5fYmFja3VwRWRnZU9wdGlvbnMoX2VkZ2UpO1xuICAgICAgICBfZWRnZS5zZXRPcHRpb25zKHsgcGh5c2ljczogZmFsc2UgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBjaGVja3MgdGhlIG9wdGlvbnMgdGhhdCBjYW4gYmUgc3VwcGxpZWQgdG8gdGhlIGRpZmZlcmVudCBjbHVzdGVyIGZ1bmN0aW9uc1xuICAgICAqIGZvciBjZXJ0YWluIGZpZWxkcyBhbmQgaW5zZXJ0cyBkZWZhdWx0cyBpZiBuZWVkZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19jaGVja09wdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2hlY2tPcHRpb25zKCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICBpZiAob3B0aW9ucy5jbHVzdGVyRWRnZVByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLmNsdXN0ZXJFZGdlUHJvcGVydGllcyA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5jbHVzdGVyTm9kZVByb3BlcnRpZXMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgY2hpbGROb2Rlc09iaiAgICAgICAgIHwgb2JqZWN0IHdpdGggbm9kZSBvYmplY3RzLCBpZCBhcyBrZXlzLCBzYW1lIGFzIGNoaWxkTm9kZXMgZXhjZXB0IGl0IGFsc28gY29udGFpbnMgYSBzb3VyY2Ugbm9kZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICBjaGlsZEVkZ2VzT2JqICAgICAgICAgfCBvYmplY3Qgd2l0aCBlZGdlIG9iamVjdHMsIGlkIGFzIGtleXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgICAgb3B0aW9ucyAgICAgICAgICAgICAgIHwgb2JqZWN0IHdpdGgge2NsdXN0ZXJOb2RlUHJvcGVydGllcywgY2x1c3RlckVkZ2VQcm9wZXJ0aWVzLCBwcm9jZXNzUHJvcGVydGllc31cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgcmVmcmVzaERhdGEgfCB3aGVuIHRydWUsIGRvIG5vdCB3cmFwIHVwXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2NsdXN0ZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2x1c3RlcihjaGlsZE5vZGVzT2JqLCBjaGlsZEVkZ2VzT2JqLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcmVmcmVzaERhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHRydWU7XG5cbiAgICAgIC8vIFJlbW92ZSBub2RlcyB3aGljaCBhcmUgYWxyZWFkeSBjbHVzdGVyZWRcbiAgICAgIHZhciB0bXBOb2Rlc1RvUmVtb3ZlID0gW107XG4gICAgICBmb3IgKHZhciBfbm9kZUlkIGluIGNoaWxkTm9kZXNPYmopIHtcbiAgICAgICAgaWYgKGNoaWxkTm9kZXNPYmouaGFzT3duUHJvcGVydHkoX25vZGVJZCkpIHtcbiAgICAgICAgICBpZiAodGhpcy5jbHVzdGVyZWROb2Rlc1tfbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0bXBOb2Rlc1RvUmVtb3ZlLnB1c2goX25vZGVJZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgdG1wTm9kZXNUb1JlbW92ZS5sZW5ndGg7ICsrbikge1xuICAgICAgICBkZWxldGUgY2hpbGROb2Rlc09ialt0bXBOb2Rlc1RvUmVtb3ZlW25dXTtcbiAgICAgIH1cblxuICAgICAgLy8ga2lsbCBjb25kaXRpb246IG5vIG5vZGVzIGRvbid0IGJvdGhlclxuICAgICAgaWYgKCgwLCBfa2V5czJbJ2RlZmF1bHQnXSkoY2hpbGROb2Rlc09iaikubGVuZ3RoID09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBhbGxvdyBjbHVzdGVycyBvZiAxIGlmIG9wdGlvbnMgYWxsb3dcbiAgICAgIGlmICgoMCwgX2tleXMyWydkZWZhdWx0J10pKGNoaWxkTm9kZXNPYmopLmxlbmd0aCA9PSAxICYmIG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmFsbG93U2luZ2xlTm9kZUNsdXN0ZXIgIT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBjbHVzdGVyTm9kZVByb3BlcnRpZXMgPSB1dGlsLmRlZXBFeHRlbmQoe30sIG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzKTtcblxuICAgICAgLy8gY29uc3RydWN0IHRoZSBjbHVzdGVyTm9kZVByb3BlcnRpZXNcbiAgICAgIGlmIChvcHRpb25zLnByb2Nlc3NQcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gZ2V0IHRoZSBjaGlsZE5vZGUgb3B0aW9uc1xuICAgICAgICB2YXIgY2hpbGROb2Rlc09wdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX25vZGVJZDIgaW4gY2hpbGROb2Rlc09iaikge1xuICAgICAgICAgIGlmIChjaGlsZE5vZGVzT2JqLmhhc093blByb3BlcnR5KF9ub2RlSWQyKSkge1xuICAgICAgICAgICAgdmFyIGNsb25lZE9wdGlvbnMgPSBOZXR3b3JrVXRpbC5jbG9uZU9wdGlvbnMoY2hpbGROb2Rlc09ialtfbm9kZUlkMl0pO1xuICAgICAgICAgICAgY2hpbGROb2Rlc09wdGlvbnMucHVzaChjbG9uZWRPcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgY2x1c3RlciBwcm9wZXJ0aWVzIGJhc2VkIG9uIGNoaWxkTm9kZXNcbiAgICAgICAgdmFyIGNoaWxkRWRnZXNPcHRpb25zID0gW107XG4gICAgICAgIGZvciAodmFyIGVkZ2VJZCBpbiBjaGlsZEVkZ2VzT2JqKSB7XG4gICAgICAgICAgaWYgKGNoaWxkRWRnZXNPYmouaGFzT3duUHJvcGVydHkoZWRnZUlkKSkge1xuICAgICAgICAgICAgLy8gdGhlc2UgY2x1c3RlciBlZGdlcyB3aWxsIGJlIHJlbW92ZWQgb24gY3JlYXRpb24gb2YgdGhlIGNsdXN0ZXIuXG4gICAgICAgICAgICBpZiAoZWRnZUlkLnN1YnN0cigwLCAxMikgIT09ICdjbHVzdGVyRWRnZTonKSB7XG4gICAgICAgICAgICAgIHZhciBfY2xvbmVkT3B0aW9ucyA9IE5ldHdvcmtVdGlsLmNsb25lT3B0aW9ucyhjaGlsZEVkZ2VzT2JqW2VkZ2VJZF0sICdlZGdlJyk7XG4gICAgICAgICAgICAgIGNoaWxkRWRnZXNPcHRpb25zLnB1c2goX2Nsb25lZE9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNsdXN0ZXJOb2RlUHJvcGVydGllcyA9IG9wdGlvbnMucHJvY2Vzc1Byb3BlcnRpZXMoY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLCBjaGlsZE5vZGVzT3B0aW9ucywgY2hpbGRFZGdlc09wdGlvbnMpO1xuICAgICAgICBpZiAoIWNsdXN0ZXJOb2RlUHJvcGVydGllcykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHByb2Nlc3NQcm9wZXJ0aWVzIGZ1bmN0aW9uIGRvZXMgbm90IHJldHVybiBwcm9wZXJ0aWVzIScpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIGlmIHdlIGhhdmUgYW4gdW5pcXVlIGlkO1xuICAgICAgaWYgKGNsdXN0ZXJOb2RlUHJvcGVydGllcy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNsdXN0ZXJOb2RlUHJvcGVydGllcy5pZCA9ICdjbHVzdGVyOicgKyB1dGlsLnJhbmRvbVVVSUQoKTtcbiAgICAgIH1cbiAgICAgIHZhciBjbHVzdGVySWQgPSBjbHVzdGVyTm9kZVByb3BlcnRpZXMuaWQ7XG5cbiAgICAgIGlmIChjbHVzdGVyTm9kZVByb3BlcnRpZXMubGFiZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjbHVzdGVyTm9kZVByb3BlcnRpZXMubGFiZWwgPSAnY2x1c3Rlcic7XG4gICAgICB9XG5cbiAgICAgIC8vIGdpdmUgdGhlIGNsdXN0ZXJOb2RlIGEgcG9zaXRpb24gaWYgaXQgZG9lcyBub3QgaGF2ZSBvbmUuXG4gICAgICB2YXIgcG9zID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKGNsdXN0ZXJOb2RlUHJvcGVydGllcy54ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcG9zID0gdGhpcy5fZ2V0Q2x1c3RlclBvc2l0aW9uKGNoaWxkTm9kZXNPYmopO1xuICAgICAgICBjbHVzdGVyTm9kZVByb3BlcnRpZXMueCA9IHBvcy54O1xuICAgICAgfVxuICAgICAgaWYgKGNsdXN0ZXJOb2RlUHJvcGVydGllcy55ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHBvcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcG9zID0gdGhpcy5fZ2V0Q2x1c3RlclBvc2l0aW9uKGNoaWxkTm9kZXNPYmopO1xuICAgICAgICB9XG4gICAgICAgIGNsdXN0ZXJOb2RlUHJvcGVydGllcy55ID0gcG9zLnk7XG4gICAgICB9XG5cbiAgICAgIC8vIGZvcmNlIHRoZSBJRCB0byByZW1haW4gdGhlIHNhbWVcbiAgICAgIGNsdXN0ZXJOb2RlUHJvcGVydGllcy5pZCA9IGNsdXN0ZXJJZDtcblxuICAgICAgLy8gY3JlYXRlIHRoZSBjbHVzdGVyIE5vZGVcbiAgICAgIC8vIE5vdGUgdGhhdCBhbGxvd1NpbmdsZU5vZGVDbHVzdGVyLCBpZiBwcmVzZW50LCBpcyBzdG9yZWQgaW4gdGhlIG9wdGlvbnMgYXMgd2VsbFxuICAgICAgdmFyIGNsdXN0ZXJOb2RlID0gdGhpcy5ib2R5LmZ1bmN0aW9ucy5jcmVhdGVOb2RlKGNsdXN0ZXJOb2RlUHJvcGVydGllcywgQ2x1c3Rlcik7XG4gICAgICBjbHVzdGVyTm9kZS5jb250YWluZWROb2RlcyA9IGNoaWxkTm9kZXNPYmo7XG4gICAgICBjbHVzdGVyTm9kZS5jb250YWluZWRFZGdlcyA9IGNoaWxkRWRnZXNPYmo7XG4gICAgICAvLyBjYWNoZSBhIGNvcHkgZnJvbSB0aGUgY2x1c3RlciBlZGdlIHByb3BlcnRpZXMgaWYgd2UgaGF2ZSB0byByZWNvbm5lY3Qgb3RoZXJzIGxhdGVyIG9uXG4gICAgICBjbHVzdGVyTm9kZS5jbHVzdGVyRWRnZVByb3BlcnRpZXMgPSBvcHRpb25zLmNsdXN0ZXJFZGdlUHJvcGVydGllcztcblxuICAgICAgLy8gZmluYWxseSBwdXQgdGhlIGNsdXN0ZXIgbm9kZSBpbnRvIGdsb2JhbFxuICAgICAgdGhpcy5ib2R5Lm5vZGVzW2NsdXN0ZXJOb2RlUHJvcGVydGllcy5pZF0gPSBjbHVzdGVyTm9kZTtcblxuICAgICAgdGhpcy5fY2x1c3RlckVkZ2VzKGNoaWxkTm9kZXNPYmosIGNoaWxkRWRnZXNPYmosIGNsdXN0ZXJOb2RlUHJvcGVydGllcywgb3B0aW9ucy5jbHVzdGVyRWRnZVByb3BlcnRpZXMpO1xuXG4gICAgICAvLyBzZXQgSUQgdG8gdW5kZWZpbmVkIHNvIG5vIGR1cGxpY2F0ZXMgYXJpc2VcbiAgICAgIGNsdXN0ZXJOb2RlUHJvcGVydGllcy5pZCA9IHVuZGVmaW5lZDtcblxuICAgICAgLy8gd3JhcCB1cFxuICAgICAgaWYgKHJlZnJlc2hEYXRhID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19kYXRhQ2hhbmdlZCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFZGdlfSBlZGdlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2JhY2t1cEVkZ2VPcHRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2JhY2t1cEVkZ2VPcHRpb25zKGVkZ2UpIHtcbiAgICAgIGlmICh0aGlzLmNsdXN0ZXJlZEVkZ2VzW2VkZ2UuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5jbHVzdGVyZWRFZGdlc1tlZGdlLmlkXSA9IHsgcGh5c2ljczogZWRnZS5vcHRpb25zLnBoeXNpY3MgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWRnZX0gZWRnZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19yZXN0b3JlRWRnZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXN0b3JlRWRnZShlZGdlKSB7XG4gICAgICB2YXIgb3JpZ2luYWxPcHRpb25zID0gdGhpcy5jbHVzdGVyZWRFZGdlc1tlZGdlLmlkXTtcbiAgICAgIGlmIChvcmlnaW5hbE9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlZGdlLnNldE9wdGlvbnMoeyBwaHlzaWNzOiBvcmlnaW5hbE9wdGlvbnMucGh5c2ljcyB9KTtcbiAgICAgICAgZGVsZXRlIHRoaXMuY2x1c3RlcmVkRWRnZXNbZWRnZS5pZF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSBub2RlIGlzIGEgY2x1c3Rlci5cbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IG5vZGVJZFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdpc0NsdXN0ZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0NsdXN0ZXIobm9kZUlkKSB7XG4gICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0uaXNDbHVzdGVyID09PSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coJ05vZGUgZG9lcyBub3QgZXhpc3QuJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBjbHVzdGVyIG5vZGUgYmFzZWQgb24gd2hhdCdzIGluc2lkZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjaGlsZE5vZGVzT2JqICAgIHwgb2JqZWN0IHdpdGggbm9kZSBvYmplY3RzLCBpZCBhcyBrZXlzXG4gICAgICogQHJldHVybnMge3t4OiBudW1iZXIsIHk6IG51bWJlcn19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2dldENsdXN0ZXJQb3NpdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDbHVzdGVyUG9zaXRpb24oY2hpbGROb2Rlc09iaikge1xuICAgICAgdmFyIGNoaWxkS2V5cyA9ICgwLCBfa2V5czJbJ2RlZmF1bHQnXSkoY2hpbGROb2Rlc09iaik7XG4gICAgICB2YXIgbWluWCA9IGNoaWxkTm9kZXNPYmpbY2hpbGRLZXlzWzBdXS54O1xuICAgICAgdmFyIG1heFggPSBjaGlsZE5vZGVzT2JqW2NoaWxkS2V5c1swXV0ueDtcbiAgICAgIHZhciBtaW5ZID0gY2hpbGROb2Rlc09ialtjaGlsZEtleXNbMF1dLnk7XG4gICAgICB2YXIgbWF4WSA9IGNoaWxkTm9kZXNPYmpbY2hpbGRLZXlzWzBdXS55O1xuICAgICAgdmFyIG5vZGUgPSB2b2lkIDA7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGNoaWxkS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBub2RlID0gY2hpbGROb2Rlc09ialtjaGlsZEtleXNbaV1dO1xuICAgICAgICBtaW5YID0gbm9kZS54IDwgbWluWCA/IG5vZGUueCA6IG1pblg7XG4gICAgICAgIG1heFggPSBub2RlLnggPiBtYXhYID8gbm9kZS54IDogbWF4WDtcbiAgICAgICAgbWluWSA9IG5vZGUueSA8IG1pblkgPyBub2RlLnkgOiBtaW5ZO1xuICAgICAgICBtYXhZID0gbm9kZS55ID4gbWF4WSA/IG5vZGUueSA6IG1heFk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IHg6IDAuNSAqIChtaW5YICsgbWF4WCksIHk6IDAuNSAqIChtaW5ZICsgbWF4WSkgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVuIGEgY2x1c3RlciBieSBjYWxsaW5nIHRoaXMgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHt2aXMuRWRnZS5pZH0gIGNsdXN0ZXJOb2RlSWQgfCB0aGUgSUQgb2YgdGhlIGNsdXN0ZXIgbm9kZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtib29sZWFufSByZWZyZXNoRGF0YSB8IHdyYXAgdXAgYWZ0ZXJ3YXJkcyBpZiBub3QgdHJ1ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdvcGVuQ2x1c3RlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wZW5DbHVzdGVyKGNsdXN0ZXJOb2RlSWQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciByZWZyZXNoRGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcblxuICAgICAgLy8ga2lsbCBjb25kaXRpb25zXG4gICAgICBpZiAoY2x1c3Rlck5vZGVJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gY2x1c3Rlck5vZGVJZCBzdXBwbGllZCB0byBvcGVuQ2x1c3Rlci4nKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNsdXN0ZXJOb2RlID0gdGhpcy5ib2R5Lm5vZGVzW2NsdXN0ZXJOb2RlSWRdO1xuXG4gICAgICBpZiAoY2x1c3Rlck5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjbHVzdGVyTm9kZUlkIHN1cHBsaWVkIHRvIG9wZW5DbHVzdGVyIGRvZXMgbm90IGV4aXN0LicpO1xuICAgICAgfVxuICAgICAgaWYgKGNsdXN0ZXJOb2RlLmlzQ2x1c3RlciAhPT0gdHJ1ZSB8fCBjbHVzdGVyTm9kZS5jb250YWluZWROb2RlcyA9PT0gdW5kZWZpbmVkIHx8IGNsdXN0ZXJOb2RlLmNvbnRhaW5lZEVkZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgbm9kZTonICsgY2x1c3Rlck5vZGVJZCArICcgaXMgbm90IGEgdmFsaWQgY2x1c3Rlci4nKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgY3VycmVudCBjbHVzdGVyIGlzIGNsdXN0ZXJlZCBpdHNlbGZcbiAgICAgIHZhciBzdGFjayA9IHRoaXMuZmluZE5vZGUoY2x1c3Rlck5vZGVJZCk7XG4gICAgICB2YXIgcGFyZW50SW5kZXggPSBzdGFjay5pbmRleE9mKGNsdXN0ZXJOb2RlSWQpIC0gMTtcbiAgICAgIGlmIChwYXJlbnRJbmRleCA+PSAwKSB7XG4gICAgICAgIC8vIEN1cnJlbnQgY2x1c3RlciBpcyBjbHVzdGVyZWQ7IHRyYW5zZmVyIGNvbnRhaW5lZCBub2RlcyBhbmQgZWRnZXMgdG8gcGFyZW50XG4gICAgICAgIHZhciBwYXJlbnRDbHVzdGVyTm9kZUlkID0gc3RhY2tbcGFyZW50SW5kZXhdO1xuICAgICAgICB2YXIgcGFyZW50Q2x1c3Rlck5vZGUgPSB0aGlzLmJvZHkubm9kZXNbcGFyZW50Q2x1c3Rlck5vZGVJZF07XG5cbiAgICAgICAgLy8gY2x1c3RlcmluZy5jbHVzdGVyZWROb2RlcyBhbmQgY2x1c3RlcmluZy5jbHVzdGVyZWRFZGdlcyByZW1haW4gdW5jaGFuZ2VkXG4gICAgICAgIHBhcmVudENsdXN0ZXJOb2RlLl9vcGVuQ2hpbGRDbHVzdGVyKGNsdXN0ZXJOb2RlSWQpO1xuXG4gICAgICAgIC8vIEFsbCBjb21wb25lbnRzIG9mIGNoaWxkIGNsdXN0ZXIgbm9kZSBoYXZlIGJlZW4gdHJhbnNmZXJyZWQuIEl0IGNhbiBkaWUgbm93LlxuICAgICAgICBkZWxldGUgdGhpcy5ib2R5Lm5vZGVzW2NsdXN0ZXJOb2RlSWRdO1xuICAgICAgICBpZiAocmVmcmVzaERhdGEgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfZGF0YUNoYW5nZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gbWFpbiBib2R5XG4gICAgICB2YXIgY29udGFpbmVkTm9kZXMgPSBjbHVzdGVyTm9kZS5jb250YWluZWROb2RlcztcbiAgICAgIHZhciBjb250YWluZWRFZGdlcyA9IGNsdXN0ZXJOb2RlLmNvbnRhaW5lZEVkZ2VzO1xuXG4gICAgICAvLyBhbGxvdyB0aGUgdXNlciB0byBwb3NpdGlvbiB0aGUgbm9kZXMgYWZ0ZXIgcmVsZWFzZS5cbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5yZWxlYXNlRnVuY3Rpb24gIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0aW9ucy5yZWxlYXNlRnVuY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIHBvc2l0aW9ucyA9IHt9O1xuICAgICAgICB2YXIgY2x1c3RlclBvc2l0aW9uID0geyB4OiBjbHVzdGVyTm9kZS54LCB5OiBjbHVzdGVyTm9kZS55IH07XG4gICAgICAgIGZvciAodmFyIF9ub2RlSWQzIGluIGNvbnRhaW5lZE5vZGVzKSB7XG4gICAgICAgICAgaWYgKGNvbnRhaW5lZE5vZGVzLmhhc093blByb3BlcnR5KF9ub2RlSWQzKSkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lZE5vZGUgPSB0aGlzLmJvZHkubm9kZXNbX25vZGVJZDNdO1xuICAgICAgICAgICAgcG9zaXRpb25zW19ub2RlSWQzXSA9IHsgeDogY29udGFpbmVkTm9kZS54LCB5OiBjb250YWluZWROb2RlLnkgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld1Bvc2l0aW9ucyA9IG9wdGlvbnMucmVsZWFzZUZ1bmN0aW9uKGNsdXN0ZXJQb3NpdGlvbiwgcG9zaXRpb25zKTtcblxuICAgICAgICBmb3IgKHZhciBfbm9kZUlkNCBpbiBjb250YWluZWROb2Rlcykge1xuICAgICAgICAgIGlmIChjb250YWluZWROb2Rlcy5oYXNPd25Qcm9wZXJ0eShfbm9kZUlkNCkpIHtcbiAgICAgICAgICAgIHZhciBfY29udGFpbmVkTm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tfbm9kZUlkNF07XG4gICAgICAgICAgICBpZiAobmV3UG9zaXRpb25zW19ub2RlSWQ0XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIF9jb250YWluZWROb2RlLnggPSBuZXdQb3NpdGlvbnNbX25vZGVJZDRdLnggPT09IHVuZGVmaW5lZCA/IGNsdXN0ZXJOb2RlLnggOiBuZXdQb3NpdGlvbnNbX25vZGVJZDRdLng7XG4gICAgICAgICAgICAgIF9jb250YWluZWROb2RlLnkgPSBuZXdQb3NpdGlvbnNbX25vZGVJZDRdLnkgPT09IHVuZGVmaW5lZCA/IGNsdXN0ZXJOb2RlLnkgOiBuZXdQb3NpdGlvbnNbX25vZGVJZDRdLnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjb3B5IHRoZSBwb3NpdGlvbiBmcm9tIHRoZSBjbHVzdGVyXG4gICAgICAgIHV0aWwuZm9yRWFjaChjb250YWluZWROb2RlcywgZnVuY3Rpb24gKGNvbnRhaW5lZE5vZGUpIHtcbiAgICAgICAgICAvLyBpbmhlcml0IHBvc2l0aW9uXG4gICAgICAgICAgaWYgKGNvbnRhaW5lZE5vZGUub3B0aW9ucy5maXhlZC54ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY29udGFpbmVkTm9kZS54ID0gY2x1c3Rlck5vZGUueDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbnRhaW5lZE5vZGUub3B0aW9ucy5maXhlZC55ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY29udGFpbmVkTm9kZS55ID0gY2x1c3Rlck5vZGUueTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyByZWxlYXNlIG5vZGVzXG4gICAgICBmb3IgKHZhciBfbm9kZUlkNSBpbiBjb250YWluZWROb2Rlcykge1xuICAgICAgICBpZiAoY29udGFpbmVkTm9kZXMuaGFzT3duUHJvcGVydHkoX25vZGVJZDUpKSB7XG4gICAgICAgICAgdmFyIF9jb250YWluZWROb2RlMiA9IHRoaXMuYm9keS5ub2Rlc1tfbm9kZUlkNV07XG5cbiAgICAgICAgICAvLyBpbmhlcml0IHNwZWVkXG4gICAgICAgICAgX2NvbnRhaW5lZE5vZGUyLnZ4ID0gY2x1c3Rlck5vZGUudng7XG4gICAgICAgICAgX2NvbnRhaW5lZE5vZGUyLnZ5ID0gY2x1c3Rlck5vZGUudnk7XG5cbiAgICAgICAgICBfY29udGFpbmVkTm9kZTIuc2V0T3B0aW9ucyh7IHBoeXNpY3M6IHRydWUgfSk7XG5cbiAgICAgICAgICBkZWxldGUgdGhpcy5jbHVzdGVyZWROb2Rlc1tfbm9kZUlkNV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gY29weSB0aGUgY2x1c3Rlck5vZGUgZWRnZXMgYmVjYXVzZSB3ZSBjYW5ub3QgaXRlcmF0ZSBvdmVyIGFuIG9iamVjdCB0aGF0IHdlIGFkZCBvciByZW1vdmUgZnJvbS5cbiAgICAgIHZhciBlZGdlc1RvQmVEZWxldGVkID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsdXN0ZXJOb2RlLmVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVkZ2VzVG9CZURlbGV0ZWQucHVzaChjbHVzdGVyTm9kZS5lZGdlc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFjdHVhbGx5IGhhbmRsaW5nIHRoZSBkZWxldGluZy5cbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGVkZ2VzVG9CZURlbGV0ZWQubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzVG9CZURlbGV0ZWRbX2kyXTtcbiAgICAgICAgdmFyIG90aGVyTm9kZUlkID0gdGhpcy5fZ2V0Q29ubmVjdGVkSWQoZWRnZSwgY2x1c3Rlck5vZGVJZCk7XG4gICAgICAgIHZhciBvdGhlck5vZGUgPSB0aGlzLmNsdXN0ZXJlZE5vZGVzW290aGVyTm9kZUlkXTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVkZ2UuY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgdHJhbnNmZXJJZCA9IGVkZ2UuY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZHNbal07XG4gICAgICAgICAgdmFyIHRyYW5zZmVyRWRnZSA9IHRoaXMuYm9keS5lZGdlc1t0cmFuc2ZlcklkXTtcbiAgICAgICAgICBpZiAodHJhbnNmZXJFZGdlID09PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgLy8gaWYgdGhlIG90aGVyIG5vZGUgaXMgaW4gYW5vdGhlciBjbHVzdGVyLCB3ZSB0cmFuc2ZlciBvd25lcnNoaXAgb2YgdGhpcyBlZGdlIHRvIHRoZSBvdGhlciBjbHVzdGVyXG4gICAgICAgICAgaWYgKG90aGVyTm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyB0cmFuc2ZlciBvd25lcnNoaXA6XG4gICAgICAgICAgICB2YXIgb3RoZXJDbHVzdGVyID0gdGhpcy5ib2R5Lm5vZGVzW290aGVyTm9kZS5jbHVzdGVySWRdO1xuICAgICAgICAgICAgb3RoZXJDbHVzdGVyLmNvbnRhaW5lZEVkZ2VzW3RyYW5zZmVyRWRnZS5pZF0gPSB0cmFuc2ZlckVkZ2U7XG5cbiAgICAgICAgICAgIC8vIGRlbGV0ZSBsb2NhbCByZWZlcmVuY2VcbiAgICAgICAgICAgIGRlbGV0ZSBjb250YWluZWRFZGdlc1t0cmFuc2ZlckVkZ2UuaWRdO1xuXG4gICAgICAgICAgICAvLyBnZXQgdG8gYW5kIGZyb21cbiAgICAgICAgICAgIHZhciBmcm9tSWQgPSB0cmFuc2ZlckVkZ2UuZnJvbUlkO1xuICAgICAgICAgICAgdmFyIHRvSWQgPSB0cmFuc2ZlckVkZ2UudG9JZDtcbiAgICAgICAgICAgIGlmICh0cmFuc2ZlckVkZ2UudG9JZCA9PSBvdGhlck5vZGVJZCkge1xuICAgICAgICAgICAgICB0b0lkID0gb3RoZXJOb2RlLmNsdXN0ZXJJZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZyb21JZCA9IG90aGVyTm9kZS5jbHVzdGVySWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBuZXcgY2x1c3RlciBlZGdlIGZyb20gdGhlIG90aGVyQ2x1c3RlclxuICAgICAgICAgICAgdGhpcy5fY3JlYXRlQ2x1c3RlcmVkRWRnZShmcm9tSWQsIHRvSWQsIHRyYW5zZmVyRWRnZSwgb3RoZXJDbHVzdGVyLmNsdXN0ZXJFZGdlUHJvcGVydGllcywgeyBoaWRkZW46IGZhbHNlLCBwaHlzaWNzOiB0cnVlIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZXN0b3JlRWRnZSh0cmFuc2ZlckVkZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGVkZ2UucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGhhbmRsZSB0aGUgcmVsZWFzaW5nIG9mIHRoZSBlZGdlc1xuICAgICAgZm9yICh2YXIgZWRnZUlkIGluIGNvbnRhaW5lZEVkZ2VzKSB7XG4gICAgICAgIGlmIChjb250YWluZWRFZGdlcy5oYXNPd25Qcm9wZXJ0eShlZGdlSWQpKSB7XG4gICAgICAgICAgdGhpcy5fcmVzdG9yZUVkZ2UoY29udGFpbmVkRWRnZXNbZWRnZUlkXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gcmVtb3ZlIGNsdXN0ZXJOb2RlXG4gICAgICBkZWxldGUgdGhpcy5ib2R5Lm5vZGVzW2NsdXN0ZXJOb2RlSWRdO1xuXG4gICAgICBpZiAocmVmcmVzaERhdGEgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2RhdGFDaGFuZ2VkJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NsdXN0ZXIuaWR9IGNsdXN0ZXJJZFxuICAgICAqIEByZXR1cm5zIHtBcnJheS48Tm9kZS5pZD59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldE5vZGVzSW5DbHVzdGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Tm9kZXNJbkNsdXN0ZXIoY2x1c3RlcklkKSB7XG4gICAgICB2YXIgbm9kZXNBcnJheSA9IFtdO1xuICAgICAgaWYgKHRoaXMuaXNDbHVzdGVyKGNsdXN0ZXJJZCkgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lZE5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzW2NsdXN0ZXJJZF0uY29udGFpbmVkTm9kZXM7XG4gICAgICAgIGZvciAodmFyIF9ub2RlSWQ2IGluIGNvbnRhaW5lZE5vZGVzKSB7XG4gICAgICAgICAgaWYgKGNvbnRhaW5lZE5vZGVzLmhhc093blByb3BlcnR5KF9ub2RlSWQ2KSkge1xuICAgICAgICAgICAgbm9kZXNBcnJheS5wdXNoKHRoaXMuYm9keS5ub2Rlc1tfbm9kZUlkNl0uaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZXNBcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHN0YWNrIGNsdXN0ZXJJZCdzIHRoYXQgYSBjZXJ0YWluIG5vZGUgcmVzaWRlcyBpbi4gY2x1c3RlciBBIC0+IGNsdXN0ZXIgQiAtPiBjbHVzdGVyIEMgLT4gbm9kZVxuICAgICAqXG4gICAgICogSWYgYSBub2RlIGNhbid0IGJlIGZvdW5kIGluIHRoZSBjaGFpbiwgcmV0dXJuIGFuIGVtcHR5IGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBub2RlSWRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2ZpbmROb2RlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZE5vZGUobm9kZUlkKSB7XG4gICAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICAgIHZhciBtYXggPSAxMDA7XG4gICAgICB2YXIgY291bnRlciA9IDA7XG4gICAgICB2YXIgbm9kZSA9IHZvaWQgMDtcblxuICAgICAgd2hpbGUgKHRoaXMuY2x1c3RlcmVkTm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkICYmIGNvdW50ZXIgPCBtYXgpIHtcbiAgICAgICAgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gW107XG4gICAgICAgIHN0YWNrLnB1c2gobm9kZS5pZCk7XG5cbiAgICAgICAgbm9kZUlkID0gdGhpcy5jbHVzdGVyZWROb2Rlc1tub2RlSWRdLmNsdXN0ZXJJZDtcbiAgICAgICAgY291bnRlcisrO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gW107XG4gICAgICBzdGFjay5wdXNoKG5vZGUuaWQpO1xuXG4gICAgICBzdGFjay5yZXZlcnNlKCk7XG4gICAgICByZXR1cm4gc3RhY2s7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNpbmcgYSBjbHVzdGVyZWQgbm9kZUlkLCB1cGRhdGUgd2l0aCB0aGUgbmV3IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge3Zpcy5FZGdlLmlkfSBjbHVzdGVyZWROb2RlSWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbmV3T3B0aW9uc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVDbHVzdGVyZWROb2RlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQ2x1c3RlcmVkTm9kZShjbHVzdGVyZWROb2RlSWQsIG5ld09wdGlvbnMpIHtcbiAgICAgIGlmIChjbHVzdGVyZWROb2RlSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGNsdXN0ZXJlZE5vZGVJZCBzdXBwbGllZCB0byB1cGRhdGVDbHVzdGVyZWROb2RlLicpO1xuICAgICAgfVxuICAgICAgaWYgKG5ld09wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG5ld09wdGlvbnMgc3VwcGxpZWQgdG8gdXBkYXRlQ2x1c3RlcmVkTm9kZS4nKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbY2x1c3RlcmVkTm9kZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGNsdXN0ZXJlZE5vZGVJZCBzdXBwbGllZCB0byB1cGRhdGVDbHVzdGVyZWROb2RlIGRvZXMgbm90IGV4aXN0LicpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJvZHkubm9kZXNbY2x1c3RlcmVkTm9kZUlkXS5zZXRPcHRpb25zKG5ld09wdGlvbnMpO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2RhdGFDaGFuZ2VkJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNpbmcgYSBiYXNlIGVkZ2VJZCwgdXBkYXRlIGFsbCByZWxhdGVkIGNsdXN0ZXJlZCBlZGdlcyB3aXRoIHRoZSBuZXcgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7dmlzLkVkZ2UuaWR9IHN0YXJ0RWRnZUlkXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG5ld09wdGlvbnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlRWRnZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUVkZ2Uoc3RhcnRFZGdlSWQsIG5ld09wdGlvbnMpIHtcbiAgICAgIGlmIChzdGFydEVkZ2VJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc3RhcnRFZGdlSWQgc3VwcGxpZWQgdG8gdXBkYXRlRWRnZS4nKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXdPcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBuZXdPcHRpb25zIHN1cHBsaWVkIHRvIHVwZGF0ZUVkZ2UuJyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5ib2R5LmVkZ2VzW3N0YXJ0RWRnZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHN0YXJ0RWRnZUlkIHN1cHBsaWVkIHRvIHVwZGF0ZUVkZ2UgZG9lcyBub3QgZXhpc3QuJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBhbGxFZGdlSWRzID0gdGhpcy5nZXRDbHVzdGVyZWRFZGdlcyhzdGFydEVkZ2VJZCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbEVkZ2VJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSB0aGlzLmJvZHkuZWRnZXNbYWxsRWRnZUlkc1tpXV07XG4gICAgICAgIGVkZ2Uuc2V0T3B0aW9ucyhuZXdPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19kYXRhQ2hhbmdlZCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhIHN0YWNrIG9mIGNsdXN0ZXJFZGdlSWQncyAoK2Jhc2UgZWRnZWlkKSB0aGF0IGEgYmFzZSBlZGdlIGlzIHRoZSBzYW1lIGFzLiBjbHVzdGVyIGVkZ2UgQyAtPiBjbHVzdGVyIGVkZ2UgQiAtPiBjbHVzdGVyIGVkZ2UgQSAtPiBiYXNlIGVkZ2UoZWRnZUlkKVxuICAgICAqIEBwYXJhbSB7dmlzLkVkZ2UuaWR9IGVkZ2VJZFxuICAgICAqIEByZXR1cm5zIHtBcnJheS48dmlzLkVkZ2UuaWQ+fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRDbHVzdGVyZWRFZGdlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENsdXN0ZXJlZEVkZ2VzKGVkZ2VJZCkge1xuICAgICAgdmFyIHN0YWNrID0gW107XG4gICAgICB2YXIgbWF4ID0gMTAwO1xuICAgICAgdmFyIGNvdW50ZXIgPSAwO1xuXG4gICAgICB3aGlsZSAoZWRnZUlkICE9PSB1bmRlZmluZWQgJiYgdGhpcy5ib2R5LmVkZ2VzW2VkZ2VJZF0gIT09IHVuZGVmaW5lZCAmJiBjb3VudGVyIDwgbWF4KSB7XG4gICAgICAgIHN0YWNrLnB1c2godGhpcy5ib2R5LmVkZ2VzW2VkZ2VJZF0uaWQpO1xuICAgICAgICBlZGdlSWQgPSB0aGlzLmJvZHkuZWRnZXNbZWRnZUlkXS5lZGdlUmVwbGFjZWRCeUlkO1xuICAgICAgICBjb3VudGVyKys7XG4gICAgICB9XG4gICAgICBzdGFjay5yZXZlcnNlKCk7XG4gICAgICByZXR1cm4gc3RhY2s7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBiYXNlIGVkZ2UgaWQgb2YgY2x1c3RlckVkZ2VJZC4gY2x1c3RlciBlZGdlIChjbHVzdGVyZWRFZGdlSWQpIC0+IGNsdXN0ZXIgZWRnZSBCIC0+IGNsdXN0ZXIgZWRnZSBDIC0+IGJhc2UgZWRnZVxuICAgICAqIEBwYXJhbSB7dmlzLkVkZ2UuaWR9IGNsdXN0ZXJlZEVkZ2VJZFxuICAgICAqIEByZXR1cm5zIHt2aXMuRWRnZS5pZH0gYmFzZUVkZ2VJZFxuICAgICAqXG4gICAgICogVE9ETzogZGVwcmVjYXRlIGluIDUuMC4wLiBNZXRob2QgZ2V0QmFzZUVkZ2VzKCkgaXMgdGhlIGNvcnJlY3Qgb25lIHRvIHVzZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0QmFzZUVkZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCYXNlRWRnZShjbHVzdGVyZWRFZGdlSWQpIHtcbiAgICAgIC8vIEp1c3Qga2x1ZGdlIHRoaXMgYnkgcmV0dXJuaW5nIHRoZSBmaXJzdCBiYXNlIGVkZ2UgaWQgZm91bmRcbiAgICAgIHJldHVybiB0aGlzLmdldEJhc2VFZGdlcyhjbHVzdGVyZWRFZGdlSWQpWzBdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgcmVndWxhciBlZGdlcyBmb3IgdGhpcyBjbHVzdGVyZWQgZWRnZSBpZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7dmlzLkVkZ2UuaWR9IGNsdXN0ZXJlZEVkZ2VJZFxuICAgICAqIEByZXR1cm5zIHtBcnJheS48dmlzLkVkZ2UuaWQ+fSBhbGwgYmFzZUVkZ2VJZCdzIHVuZGVyIHRoaXMgY2x1c3RlcmVkIGVkZ2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0QmFzZUVkZ2VzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QmFzZUVkZ2VzKGNsdXN0ZXJlZEVkZ2VJZCkge1xuICAgICAgdmFyIElkc1RvSGFuZGxlID0gW2NsdXN0ZXJlZEVkZ2VJZF07XG4gICAgICB2YXIgZG9uZUlkcyA9IFtdO1xuICAgICAgdmFyIGZvdW5kSWRzID0gW107XG4gICAgICB2YXIgbWF4ID0gMTAwO1xuICAgICAgdmFyIGNvdW50ZXIgPSAwO1xuXG4gICAgICB3aGlsZSAoSWRzVG9IYW5kbGUubGVuZ3RoID4gMCAmJiBjb3VudGVyIDwgbWF4KSB7XG4gICAgICAgIHZhciBuZXh0SWQgPSBJZHNUb0hhbmRsZS5wb3AoKTtcbiAgICAgICAgaWYgKG5leHRJZCA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTsgLy8gUGFyYW5vaWEgaGVyZSBhbmQgb253YXJkc1xuICAgICAgICB2YXIgbmV4dEVkZ2UgPSB0aGlzLmJvZHkuZWRnZXNbbmV4dElkXTtcbiAgICAgICAgaWYgKG5leHRFZGdlID09PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xuICAgICAgICBjb3VudGVyKys7XG5cbiAgICAgICAgdmFyIHJlcGxhY2luZ0lkcyA9IG5leHRFZGdlLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzO1xuICAgICAgICBpZiAocmVwbGFjaW5nSWRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBuZXh0SWQgaXMgYSBiYXNlIGlkXG4gICAgICAgICAgZm91bmRJZHMucHVzaChuZXh0SWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFub3RoZXIgY2x1c3RlciBlZGdlLCB1bnJhdmVsIHRoaXMgb25lIGFzIHdlbGxcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcGxhY2luZ0lkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHJlcGxhY2luZ0lkID0gcmVwbGFjaW5nSWRzW2ldO1xuXG4gICAgICAgICAgICAvLyBEb24ndCBhZGQgaWYgYWxyZWFkeSBoYW5kbGVkXG4gICAgICAgICAgICAvLyBUT0RPOiBuZXZlciB0cmlnZ2VyczsgZmluZCBhIHRlc3QtY2FzZSB3aGljaCBkb2VzXG4gICAgICAgICAgICBpZiAoSWRzVG9IYW5kbGUuaW5kZXhPZihyZXBsYWNpbmdJZHMpICE9PSAtMSB8fCBkb25lSWRzLmluZGV4T2YocmVwbGFjaW5nSWRzKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIElkc1RvSGFuZGxlLnB1c2gocmVwbGFjaW5nSWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRvbmVJZHMucHVzaChuZXh0SWQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm91bmRJZHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBJZCB0aGUgbm9kZSBpcyBjb25uZWN0ZWQgdG9cbiAgICAgKiBAcGFyYW0ge3Zpcy5FZGdlfSBlZGdlXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBub2RlSWRcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZ2V0Q29ubmVjdGVkSWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Q29ubmVjdGVkSWQoZWRnZSwgbm9kZUlkKSB7XG4gICAgICBpZiAoZWRnZS50b0lkICE9IG5vZGVJZCkge1xuICAgICAgICByZXR1cm4gZWRnZS50b0lkO1xuICAgICAgfSBlbHNlIGlmIChlZGdlLmZyb21JZCAhPSBub2RlSWQpIHtcbiAgICAgICAgcmV0dXJuIGVkZ2UuZnJvbUlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVkZ2UuZnJvbUlkO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdlIGRldGVybWluZSBob3cgbWFueSBjb25uZWN0aW9ucyBkZW5vdGUgYW4gaW1wb3J0YW50IGh1Yi5cbiAgICAgKiBXZSB0YWtlIHRoZSBtZWFuICsgMipzdGQgYXMgdGhlIGltcG9ydGFudCBodWIgc2l6ZS4gKEFzc3VtaW5nIGEgbm9ybWFsIGRpc3RyaWJ1dGlvbiBvZiBkYXRhLCB+Mi4yJSlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2dldEh1YlNpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0SHViU2l6ZSgpIHtcbiAgICAgIHZhciBhdmVyYWdlID0gMDtcbiAgICAgIHZhciBhdmVyYWdlU3F1YXJlZCA9IDA7XG4gICAgICB2YXIgaHViQ291bnRlciA9IDA7XG4gICAgICB2YXIgbGFyZ2VzdEh1YiA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBfbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLmJvZHkubm9kZUluZGljZXNbaV1dO1xuICAgICAgICBpZiAoX25vZGUuZWRnZXMubGVuZ3RoID4gbGFyZ2VzdEh1Yikge1xuICAgICAgICAgIGxhcmdlc3RIdWIgPSBfbm9kZS5lZGdlcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgYXZlcmFnZSArPSBfbm9kZS5lZGdlcy5sZW5ndGg7XG4gICAgICAgIGF2ZXJhZ2VTcXVhcmVkICs9IE1hdGgucG93KF9ub2RlLmVkZ2VzLmxlbmd0aCwgMik7XG4gICAgICAgIGh1YkNvdW50ZXIgKz0gMTtcbiAgICAgIH1cbiAgICAgIGF2ZXJhZ2UgPSBhdmVyYWdlIC8gaHViQ291bnRlcjtcbiAgICAgIGF2ZXJhZ2VTcXVhcmVkID0gYXZlcmFnZVNxdWFyZWQgLyBodWJDb3VudGVyO1xuXG4gICAgICB2YXIgdmFyaWFuY2UgPSBhdmVyYWdlU3F1YXJlZCAtIE1hdGgucG93KGF2ZXJhZ2UsIDIpO1xuICAgICAgdmFyIHN0YW5kYXJkRGV2aWF0aW9uID0gTWF0aC5zcXJ0KHZhcmlhbmNlKTtcblxuICAgICAgdmFyIGh1YlRocmVzaG9sZCA9IE1hdGguZmxvb3IoYXZlcmFnZSArIDIgKiBzdGFuZGFyZERldmlhdGlvbik7XG5cbiAgICAgIC8vIGFsd2F5cyBoYXZlIGF0IGxlYXN0IG9uZSB0byBjbHVzdGVyXG4gICAgICBpZiAoaHViVGhyZXNob2xkID4gbGFyZ2VzdEh1Yikge1xuICAgICAgICBodWJUaHJlc2hvbGQgPSBsYXJnZXN0SHViO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaHViVGhyZXNob2xkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBlZGdlIGZvciB0aGUgY2x1c3RlciByZXByZXNlbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gZnJvbUlkXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSB0b0lkXG4gICAgICogQHBhcmFtIHt2aXMuRWRnZX0gYmFzZUVkZ2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2x1c3RlckVkZ2VQcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4dHJhT3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtFZGdlfSBuZXdseSBjcmVhdGVkIGNsdXN0ZXJlZCBlZGdlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2NyZWF0ZUNsdXN0ZXJlZEVkZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlQ2x1c3RlcmVkRWRnZShmcm9tSWQsIHRvSWQsIGJhc2VFZGdlLCBjbHVzdGVyRWRnZVByb3BlcnRpZXMsIGV4dHJhT3B0aW9ucykge1xuICAgICAgLy8gY29weSB0aGUgb3B0aW9ucyBvZiB0aGUgZWRnZSB3ZSB3aWxsIHJlcGxhY2VcbiAgICAgIHZhciBjbG9uZWRPcHRpb25zID0gTmV0d29ya1V0aWwuY2xvbmVPcHRpb25zKGJhc2VFZGdlLCAnZWRnZScpO1xuICAgICAgLy8gbWFrZSBzdXJlIHRoZSBwcm9wZXJ0aWVzIG9mIGNsdXN0ZXJFZGdlcyBhcmUgc3VwZXJpbXBvc2VkIG9uIGl0XG4gICAgICB1dGlsLmRlZXBFeHRlbmQoY2xvbmVkT3B0aW9ucywgY2x1c3RlckVkZ2VQcm9wZXJ0aWVzKTtcblxuICAgICAgLy8gc2V0IHVwIHRoZSBlZGdlXG4gICAgICBjbG9uZWRPcHRpb25zLmZyb20gPSBmcm9tSWQ7XG4gICAgICBjbG9uZWRPcHRpb25zLnRvID0gdG9JZDtcbiAgICAgIGNsb25lZE9wdGlvbnMuaWQgPSAnY2x1c3RlckVkZ2U6JyArIHV0aWwucmFuZG9tVVVJRCgpO1xuXG4gICAgICAvLyBhcHBseSB0aGUgZWRnZSBzcGVjaWZpYyBvcHRpb25zIHRvIGl0IGlmIHNwZWNpZmllZFxuICAgICAgaWYgKGV4dHJhT3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHV0aWwuZGVlcEV4dGVuZChjbG9uZWRPcHRpb25zLCBleHRyYU9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3RWRnZSA9IHRoaXMuYm9keS5mdW5jdGlvbnMuY3JlYXRlRWRnZShjbG9uZWRPcHRpb25zKTtcbiAgICAgIG5ld0VkZ2UuY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZHMgPSBbYmFzZUVkZ2UuaWRdO1xuICAgICAgbmV3RWRnZS5jb25uZWN0KCk7XG5cbiAgICAgIC8vIFJlZ2lzdGVyIHRoZSBuZXcgZWRnZVxuICAgICAgdGhpcy5ib2R5LmVkZ2VzW25ld0VkZ2UuaWRdID0gbmV3RWRnZTtcblxuICAgICAgcmV0dXJuIG5ld0VkZ2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIHRoZSBwYXNzZWQgY2hpbGQgbm9kZXMgYW5kIGVkZ2VzIHRvIHRoZSBnaXZlbiBjbHVzdGVyIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdHxOb2RlfSBjaGlsZE5vZGVzICBoYXNoIG9mIG5vZGVzIG9yIHNpbmdsZSBub2RlIHRvIGFkZCBpbiBjbHVzdGVyXG4gICAgICogQHBhcmFtIHtPYmplY3R8RWRnZX0gY2hpbGRFZGdlcyAgaGFzaCBvZiBlZGdlcyBvciBzaW5nbGUgZWRnZSB0byB0YWtlIGludG8gYWNjb3VudCB3aGVuIGNsdXN0ZXJpbmdcbiAgICAgKiBAcGFyYW0ge05vZGV9IGNsdXN0ZXJOb2RlICBjbHVzdGVyIG5vZGUgdG8gYWRkIG5vZGVzIGFuZCBlZGdlcyB0b1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY2x1c3RlckVkZ2VQcm9wZXJ0aWVzXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19jbHVzdGVyRWRnZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2x1c3RlckVkZ2VzKGNoaWxkTm9kZXMsIGNoaWxkRWRnZXMsIGNsdXN0ZXJOb2RlLCBjbHVzdGVyRWRnZVByb3BlcnRpZXMpIHtcbiAgICAgIGlmIChjaGlsZEVkZ2VzIGluc3RhbmNlb2YgRWRnZSkge1xuICAgICAgICB2YXIgZWRnZSA9IGNoaWxkRWRnZXM7XG4gICAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgICAgb2JqW2VkZ2UuaWRdID0gZWRnZTtcbiAgICAgICAgY2hpbGRFZGdlcyA9IG9iajtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoaWxkTm9kZXMgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgIHZhciBfbm9kZTIgPSBjaGlsZE5vZGVzO1xuICAgICAgICB2YXIgX29iaiA9IHt9O1xuICAgICAgICBfb2JqW19ub2RlMi5pZF0gPSBfbm9kZTI7XG4gICAgICAgIGNoaWxkTm9kZXMgPSBfb2JqO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2x1c3Rlck5vZGUgPT09IHVuZGVmaW5lZCB8fCBjbHVzdGVyTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19jbHVzdGVyRWRnZXM6IHBhcmFtZXRlciBjbHVzdGVyTm9kZSByZXF1aXJlZCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2x1c3RlckVkZ2VQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gVGFrZSB0aGUgcmVxdWlyZWQgcHJvcGVydGllcyBmcm9tIHRoZSBjbHVzdGVyIG5vZGVcbiAgICAgICAgY2x1c3RlckVkZ2VQcm9wZXJ0aWVzID0gY2x1c3Rlck5vZGUuY2x1c3RlckVkZ2VQcm9wZXJ0aWVzO1xuICAgICAgfVxuXG4gICAgICAvLyBjcmVhdGUgdGhlIG5ldyBlZGdlcyB0aGF0IHdpbGwgY29ubmVjdCB0byB0aGUgY2x1c3Rlci5cbiAgICAgIC8vIEFsbCBzZWxmLXJlZmVyZW5jaW5nIGVkZ2VzIHdpbGwgYmUgYWRkZWQgdG8gY2hpbGRFZGdlcyBoZXJlLlxuICAgICAgdGhpcy5fY3JlYXRlQ2x1c3RlckVkZ2VzKGNoaWxkTm9kZXMsIGNoaWxkRWRnZXMsIGNsdXN0ZXJOb2RlLCBjbHVzdGVyRWRnZVByb3BlcnRpZXMpO1xuXG4gICAgICAvLyBkaXNhYmxlIHRoZSBjaGlsZEVkZ2VzXG4gICAgICBmb3IgKHZhciBlZGdlSWQgaW4gY2hpbGRFZGdlcykge1xuICAgICAgICBpZiAoY2hpbGRFZGdlcy5oYXNPd25Qcm9wZXJ0eShlZGdlSWQpKSB7XG4gICAgICAgICAgaWYgKHRoaXMuYm9keS5lZGdlc1tlZGdlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBfZWRnZTIgPSB0aGlzLmJvZHkuZWRnZXNbZWRnZUlkXTtcbiAgICAgICAgICAgIC8vIGNhY2hlIHRoZSBvcHRpb25zIGJlZm9yZSBjaGFuZ2luZ1xuICAgICAgICAgICAgdGhpcy5fYmFja3VwRWRnZU9wdGlvbnMoX2VkZ2UyKTtcbiAgICAgICAgICAgIC8vIGRpc2FibGUgcGh5c2ljcyBhbmQgaGlkZSB0aGUgZWRnZVxuICAgICAgICAgICAgX2VkZ2UyLnNldE9wdGlvbnMoeyBwaHlzaWNzOiBmYWxzZSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZGlzYWJsZSB0aGUgY2hpbGROb2Rlc1xuICAgICAgZm9yICh2YXIgX25vZGVJZDcgaW4gY2hpbGROb2Rlcykge1xuICAgICAgICBpZiAoY2hpbGROb2Rlcy5oYXNPd25Qcm9wZXJ0eShfbm9kZUlkNykpIHtcbiAgICAgICAgICB0aGlzLmNsdXN0ZXJlZE5vZGVzW19ub2RlSWQ3XSA9IHtcbiAgICAgICAgICAgIGNsdXN0ZXJJZDogY2x1c3Rlck5vZGUuaWQsXG4gICAgICAgICAgICBub2RlOiB0aGlzLmJvZHkubm9kZXNbX25vZGVJZDddXG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLmJvZHkubm9kZXNbX25vZGVJZDddLnNldE9wdGlvbnMoeyBwaHlzaWNzOiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpbiB3aGljaCBjbHVzdGVyIGdpdmVuIG5vZGVJZCByZXNpZGVzLlxuICAgICAqXG4gICAgICogSWYgbm90IGluIGNsdXN0ZXIsIHJldHVybiB1bmRlZmluZWQuXG4gICAgICpcbiAgICAgKiBOT1RFOiBJZiB5b3Uga25vdyBhIGNsZWFuZXIgd2F5IHRvIGRvIHRoaXMsIHBsZWFzZSBlbmxpZ2h0ZW4gbWUgKHdpbXJpam5kZXJzKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gbm9kZUlkXG4gICAgICogQHJldHVybnMge05vZGV8dW5kZWZpbmVkfSBOb2RlIGluc3RhbmNlIGZvciBjbHVzdGVyLCBpZiBwcmVzZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2dldENsdXN0ZXJOb2RlRm9yTm9kZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDbHVzdGVyTm9kZUZvck5vZGUobm9kZUlkKSB7XG4gICAgICBpZiAobm9kZUlkID09PSB1bmRlZmluZWQpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB2YXIgY2x1c3RlcmVkTm9kZSA9IHRoaXMuY2x1c3RlcmVkTm9kZXNbbm9kZUlkXTtcblxuICAgICAgLy8gTk9URTogSWYgbm8gY2x1c3RlciBpbmZvIGZvdW5kLCBpdCBzaG91bGQgYWN0dWFsbHkgYmUgYW4gZXJyb3JcbiAgICAgIGlmIChjbHVzdGVyZWROb2RlID09PSB1bmRlZmluZWQpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB2YXIgY2x1c3RlcklkID0gY2x1c3RlcmVkTm9kZS5jbHVzdGVySWQ7XG4gICAgICBpZiAoY2x1c3RlcklkID09PSB1bmRlZmluZWQpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICAgIHJldHVybiB0aGlzLmJvZHkubm9kZXNbY2x1c3RlcklkXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb24gZm9yIGNvbmRpdGlvbmFsbHkgcmVtb3ZpbmcgaXRlbXMgaW4gYXJyYXlcbiAgICAgKlxuICAgICAqIERvbmUgbGlrZSB0aGlzIGJlY2F1c2UgQXJyYXkuZmlsdGVyKCkgaXMgbm90IGZ1bGx5IHN1cHBvcnRlZCBieSBhbGwgSUUncy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19maWx0ZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZmlsdGVyKGFyciwgY2FsbGJhY2spIHtcbiAgICAgIHZhciByZXQgPSBbXTtcblxuICAgICAgdXRpbC5mb3JFYWNoKGFyciwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKGl0ZW0pKSB7XG4gICAgICAgICAgcmV0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjYW4gYWxsIGVkZ2VzIGZvciBjaGFuZ2VzIGluIGNsdXN0ZXJpbmcgYW5kIGFkanVzdCB0aGlzIGlmIG5lY2Vzc2FyeS5cbiAgICAgKlxuICAgICAqIENhbGwgdGhpcyAoaW50ZXJuYWxseSkgYWZ0ZXIgdGhlcmUgaGFzIGJlZW4gYSBjaGFuZ2UgaW4gbm9kZSBvciBlZGdlIGRhdGEuXG4gICAgICpcbiAgICAgKiBQcmU6IFN0YXRlcyBvZiB0aGlzLmJvZHkubm9kZXMgYW5kIHRoaXMuYm9keS5lZGdlcyBjb25zaXN0ZW50XG4gICAgICogUHJlOiB0aGlzLmNsdXN0ZXJlZE5vZGVzIGFuZCB0aGlzLmNsdXN0ZXJlZEVkZ2UgY29uc2lzdGVudCB3aXRoIGNvbnRhaW5lZE5vZGVzIGFuZCBjb250YWluZWRFZGdlc1xuICAgICAqICAgICAgb2YgY2x1c3RlciBub2Rlcy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3VwZGF0ZVN0YXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZVN0YXRlKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHZhciBub2RlSWQgPSB2b2lkIDA7XG4gICAgICB2YXIgZGVsZXRlZE5vZGVJZHMgPSBbXTtcbiAgICAgIHZhciBkZWxldGVkRWRnZUlkcyA9IHt9O1xuXG4gICAgICAvKipcbiAgICAgICAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGNsdXN0ZXJpbmcgbm9kZXMgb25seVxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrICBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGNsdXN0ZXIgbm9kZVxuICAgICAgICovXG4gICAgICB2YXIgZWFjaENsdXN0ZXJOb2RlID0gZnVuY3Rpb24gZWFjaENsdXN0ZXJOb2RlKGNhbGxiYWNrKSB7XG4gICAgICAgIHV0aWwuZm9yRWFjaChfdGhpczQuYm9keS5ub2RlcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICBpZiAobm9kZS5pc0NsdXN0ZXIgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICAvL1xuICAgICAgLy8gUmVtb3ZlIGRlbGV0ZWQgcmVndWxhciBub2RlcyBmcm9tIGNsdXN0ZXJpbmdcbiAgICAgIC8vXG5cbiAgICAgIC8vIERldGVybWluZSB0aGUgZGVsZXRlZCBub2Rlc1xuICAgICAgZm9yIChub2RlSWQgaW4gdGhpcy5jbHVzdGVyZWROb2Rlcykge1xuICAgICAgICBpZiAoIXRoaXMuY2x1c3RlcmVkTm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkgY29udGludWU7XG4gICAgICAgIHZhciBfbm9kZTMgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcblxuICAgICAgICBpZiAoX25vZGUzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkZWxldGVkTm9kZUlkcy5wdXNoKG5vZGVJZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIG5vZGVzIGZyb20gY2x1c3RlciBub2Rlc1xuICAgICAgZWFjaENsdXN0ZXJOb2RlKGZ1bmN0aW9uIChjbHVzdGVyTm9kZSkge1xuICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGRlbGV0ZWROb2RlSWRzLmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgZGVsZXRlIGNsdXN0ZXJOb2RlLmNvbnRhaW5lZE5vZGVzW2RlbGV0ZWROb2RlSWRzW25dXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIFJlbW92ZSBub2RlcyBmcm9tIGNsdXN0ZXIgbGlzdFxuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBkZWxldGVkTm9kZUlkcy5sZW5ndGg7IG4rKykge1xuICAgICAgICBkZWxldGUgdGhpcy5jbHVzdGVyZWROb2Rlc1tkZWxldGVkTm9kZUlkc1tuXV07XG4gICAgICB9XG5cbiAgICAgIC8vXG4gICAgICAvLyBSZW1vdmUgZGVsZXRlZCBlZGdlcyBmcm9tIGNsdXN0ZXJpbmdcbiAgICAgIC8vXG5cbiAgICAgIC8vIEFkZCB0aGUgZGVsZXRlZCBjbHVzdGVyZWQgZWRnZXMgdG8gdGhlIGxpc3RcbiAgICAgIHV0aWwuZm9yRWFjaCh0aGlzLmNsdXN0ZXJlZEVkZ2VzLCBmdW5jdGlvbiAoZWRnZUlkKSB7XG4gICAgICAgIHZhciBlZGdlID0gX3RoaXM0LmJvZHkuZWRnZXNbZWRnZUlkXTtcbiAgICAgICAgaWYgKGVkZ2UgPT09IHVuZGVmaW5lZCB8fCAhZWRnZS5lbmRQb2ludHNWYWxpZCgpKSB7XG4gICAgICAgICAgZGVsZXRlZEVkZ2VJZHNbZWRnZUlkXSA9IGVkZ2VJZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIENsdXN0ZXIgbm9kZXMgY2FuIGFsc28gY29udGFpbiBlZGdlcyB3aGljaCBhcmUgbm90IGNsdXN0ZXJlZCxcbiAgICAgIC8vIGkuZS4gbm9kZXMgMS0yIHdpdGhpbiBjbHVzdGVyIHdpdGggYW4gZWRnZSBpbiBiZXR3ZWVuLlxuICAgICAgLy8gU28gdGhlIGNsdXN0ZXIgbm9kZXMgYWxzbyBuZWVkIHRvIGJlIHNjYW5uZWQgZm9yIGludmFsaWQgZWRnZXNcbiAgICAgIGVhY2hDbHVzdGVyTm9kZShmdW5jdGlvbiAoY2x1c3Rlck5vZGUpIHtcbiAgICAgICAgdXRpbC5mb3JFYWNoKGNsdXN0ZXJOb2RlLmNvbnRhaW5lZEVkZ2VzLCBmdW5jdGlvbiAoZWRnZSwgZWRnZUlkKSB7XG4gICAgICAgICAgaWYgKCFlZGdlLmVuZFBvaW50c1ZhbGlkKCkgJiYgIWRlbGV0ZWRFZGdlSWRzW2VkZ2VJZF0pIHtcbiAgICAgICAgICAgIGRlbGV0ZWRFZGdlSWRzW2VkZ2VJZF0gPSBlZGdlSWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBbHNvIHNjYW4gZm9yIGNsdXN0ZXIgZWRnZXMgd2hpY2ggbmVlZCB0byBiZSByZW1vdmVkIGluIHRoZSBhY3RpdmUgbGlzdC5cbiAgICAgIC8vIFJlZ3VsYXIgZWRnZXMgaGF2ZSBiZWVuIHJlbW92ZWQgYmVmb3JlaGFuZCwgc28gdGhpcyBvbmx5IHBpY2tzIHVwIHRoZSBjbHVzdGVyIGVkZ2VzLlxuICAgICAgdXRpbC5mb3JFYWNoKHRoaXMuYm9keS5lZGdlcywgZnVuY3Rpb24gKGVkZ2UsIGVkZ2VJZCkge1xuICAgICAgICAvLyBFeHBsaWNpdGx5IHNjYW4gdGhlIGNvbnRhaW5lZCBlZGdlcyBmb3IgdmFsaWRpdHlcbiAgICAgICAgdmFyIGlzVmFsaWQgPSB0cnVlO1xuICAgICAgICB2YXIgcmVwbGFjZWRJZHMgPSBlZGdlLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzO1xuICAgICAgICBpZiAocmVwbGFjZWRJZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBudW1WYWxpZCA9IDA7XG5cbiAgICAgICAgICB1dGlsLmZvckVhY2gocmVwbGFjZWRJZHMsIGZ1bmN0aW9uIChjb250YWluZWRFZGdlSWQpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZWRFZGdlID0gX3RoaXM0LmJvZHkuZWRnZXNbY29udGFpbmVkRWRnZUlkXTtcblxuICAgICAgICAgICAgaWYgKGNvbnRhaW5lZEVkZ2UgIT09IHVuZGVmaW5lZCAmJiBjb250YWluZWRFZGdlLmVuZFBvaW50c1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgbnVtVmFsaWQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlzVmFsaWQgPSBudW1WYWxpZCA+IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWVkZ2UuZW5kUG9pbnRzVmFsaWQoKSB8fCAhaXNWYWxpZCkge1xuICAgICAgICAgIGRlbGV0ZWRFZGdlSWRzW2VkZ2VJZF0gPSBlZGdlSWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBSZW1vdmUgZWRnZXMgZnJvbSBjbHVzdGVyIG5vZGVzXG4gICAgICBlYWNoQ2x1c3Rlck5vZGUoZnVuY3Rpb24gKGNsdXN0ZXJOb2RlKSB7XG4gICAgICAgIHV0aWwuZm9yRWFjaChkZWxldGVkRWRnZUlkcywgZnVuY3Rpb24gKGRlbGV0ZWRFZGdlSWQpIHtcbiAgICAgICAgICBkZWxldGUgY2x1c3Rlck5vZGUuY29udGFpbmVkRWRnZXNbZGVsZXRlZEVkZ2VJZF07XG5cbiAgICAgICAgICB1dGlsLmZvckVhY2goY2x1c3Rlck5vZGUuZWRnZXMsIGZ1bmN0aW9uIChlZGdlLCBtKSB7XG4gICAgICAgICAgICBpZiAoZWRnZS5pZCA9PT0gZGVsZXRlZEVkZ2VJZCkge1xuICAgICAgICAgICAgICBjbHVzdGVyTm9kZS5lZGdlc1ttXSA9IG51bGw7IC8vIERvbid0IHdhbnQgdG8gZGlyZWN0bHkgZGVsZXRlIGhlcmUsIGJlY2F1c2UgaW4gdGhlIGxvb3BcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlZGdlLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzID0gX3RoaXM0Ll9maWx0ZXIoZWRnZS5jbHVzdGVyaW5nRWRnZVJlcGxhY2luZ0lkcywgZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgIHJldHVybiAhZGVsZXRlZEVkZ2VJZHNbaWRdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBDbGVhbiB1cCB0aGUgbnVsbHNcbiAgICAgICAgICBjbHVzdGVyTm9kZS5lZGdlcyA9IF90aGlzNC5fZmlsdGVyKGNsdXN0ZXJOb2RlLmVkZ2VzLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0gIT09IG51bGw7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFJlbW92ZSBmcm9tIGNsdXN0ZXIgbGlzdFxuICAgICAgdXRpbC5mb3JFYWNoKGRlbGV0ZWRFZGdlSWRzLCBmdW5jdGlvbiAoZWRnZUlkKSB7XG4gICAgICAgIGRlbGV0ZSBfdGhpczQuY2x1c3RlcmVkRWRnZXNbZWRnZUlkXTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBSZW1vdmUgY2x1c3RlciBlZGdlcyBmcm9tIGFjdGl2ZSBsaXN0ICh0aGlzLmJvZHkuZWRnZXMpLlxuICAgICAgLy8gZGVsZXRlZEVkZ2VJZHMgc3RpbGwgY29udGFpbnMgaWQgb2YgcmVndWxhciBlZGdlcywgYnV0IHRoZXNlIHNob3VsZCBhbGxcbiAgICAgIC8vIGJlIGdvbmUgd2hlbiB5b3UgcmVhY2ggaGVyZS5cbiAgICAgIHV0aWwuZm9yRWFjaChkZWxldGVkRWRnZUlkcywgZnVuY3Rpb24gKGVkZ2VJZCkge1xuICAgICAgICBkZWxldGUgX3RoaXM0LmJvZHkuZWRnZXNbZWRnZUlkXTtcbiAgICAgIH0pO1xuXG4gICAgICAvL1xuICAgICAgLy8gQ2hlY2sgY2hhbmdlZCBjbHVzdGVyIHN0YXRlIG9mIGVkZ2VzXG4gICAgICAvL1xuXG4gICAgICAvLyBJdGVyYXRpbmcgb3ZlciBrZXlzIGhlcmUsIGJlY2F1c2UgZWRnZXMgbWF5IGJlIHJlbW92ZWQgaW4gdGhlIGxvb3BcbiAgICAgIHZhciBpZHMgPSAoMCwgX2tleXMyWydkZWZhdWx0J10pKHRoaXMuYm9keS5lZGdlcyk7XG4gICAgICB1dGlsLmZvckVhY2goaWRzLCBmdW5jdGlvbiAoZWRnZUlkKSB7XG4gICAgICAgIHZhciBlZGdlID0gX3RoaXM0LmJvZHkuZWRnZXNbZWRnZUlkXTtcblxuICAgICAgICB2YXIgc2hvdWxkQmVDbHVzdGVyZWQgPSBfdGhpczQuX2lzQ2x1c3RlcmVkTm9kZShlZGdlLmZyb21JZCkgfHwgX3RoaXM0Ll9pc0NsdXN0ZXJlZE5vZGUoZWRnZS50b0lkKTtcbiAgICAgICAgaWYgKHNob3VsZEJlQ2x1c3RlcmVkID09PSBfdGhpczQuX2lzQ2x1c3RlcmVkRWRnZShlZGdlLmlkKSkge1xuICAgICAgICAgIHJldHVybjsgLy8gYWxsIGlzIHdlbGxcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaG91bGRCZUNsdXN0ZXJlZCkge1xuICAgICAgICAgIC8vIGFkZCBlZGdlIHRvIGNsdXN0ZXJpbmdcbiAgICAgICAgICB2YXIgY2x1c3RlckZyb20gPSBfdGhpczQuX2dldENsdXN0ZXJOb2RlRm9yTm9kZShlZGdlLmZyb21JZCk7XG4gICAgICAgICAgaWYgKGNsdXN0ZXJGcm9tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIF90aGlzNC5fY2x1c3RlckVkZ2VzKF90aGlzNC5ib2R5Lm5vZGVzW2VkZ2UuZnJvbUlkXSwgZWRnZSwgY2x1c3RlckZyb20pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjbHVzdGVyVG8gPSBfdGhpczQuX2dldENsdXN0ZXJOb2RlRm9yTm9kZShlZGdlLnRvSWQpO1xuICAgICAgICAgIGlmIChjbHVzdGVyVG8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgX3RoaXM0Ll9jbHVzdGVyRWRnZXMoX3RoaXM0LmJvZHkubm9kZXNbZWRnZS50b0lkXSwgZWRnZSwgY2x1c3RlclRvKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBUT0RPOiBjaGVjayB0aGF0IGl0IHdvcmtzIGZvciBib3RoIGVkZ2VzIGNsdXN0ZXJlZFxuICAgICAgICAgIC8vICAgICAgIChUaGlzIG1pZ2h0IGJlIHBhcmFub2lhKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5vdCBiZSBoYXBwZW5pbmcsIHRoZSBzdGF0ZSBzaG91bGRcbiAgICAgICAgICAvLyBiZSBwcm9wZXJseSB1cGRhdGVkIGF0IHRoaXMgcG9pbnQuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBJZiBpdCAqaXMqIHJlYWNoZWQgZHVyaW5nIG5vcm1hbCBvcGVyYXRpb24sIHRoZW4gd2UgaGF2ZSB0byBpbXBsZW1lbnRcbiAgICAgICAgICAvLyB1bmRvIGNsdXN0ZXJpbmcgZm9yIHRoaXMgZWRnZSBoZXJlLlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVtb3ZlIGVkZ2UgZnJvbSBjbHVzdGVyaW5nIG5vdCBpbXBsZW1lbnRlZCEnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIENsdXN0ZXJzIG1heSBiZSBuZXN0ZWQgdG8gYW55IGxldmVsLiBLZWVwIG9uIG9wZW5pbmcgdW50aWwgbm90aGluZyB0byBvcGVuXG4gICAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgdmFyIGNvbnRpbnVlTG9vcCA9IHRydWU7XG5cbiAgICAgIHZhciBfbG9vcDIgPSBmdW5jdGlvbiBfbG9vcDIoKSB7XG4gICAgICAgIHZhciBjbHVzdGVyc1RvT3BlbiA9IFtdO1xuXG4gICAgICAgIC8vIERldGVybWluZSB0aGUgaWQncyBvZiBjbHVzdGVycyB0aGF0IG5lZWQgb3BlbmluZ1xuICAgICAgICBlYWNoQ2x1c3Rlck5vZGUoZnVuY3Rpb24gKGNsdXN0ZXJOb2RlKSB7XG4gICAgICAgICAgdmFyIG51bU5vZGVzID0gKDAsIF9rZXlzMlsnZGVmYXVsdCddKShjbHVzdGVyTm9kZS5jb250YWluZWROb2RlcykubGVuZ3RoO1xuICAgICAgICAgIHZhciBhbGxvd1NpbmdsZSA9IGNsdXN0ZXJOb2RlLm9wdGlvbnMuYWxsb3dTaW5nbGVOb2RlQ2x1c3RlciA9PT0gdHJ1ZTtcbiAgICAgICAgICBpZiAoYWxsb3dTaW5nbGUgJiYgbnVtTm9kZXMgPCAxIHx8ICFhbGxvd1NpbmdsZSAmJiBudW1Ob2RlcyA8IDIpIHtcbiAgICAgICAgICAgIGNsdXN0ZXJzVG9PcGVuLnB1c2goY2x1c3Rlck5vZGUuaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gT3BlbiB0aGVtXG4gICAgICAgIGZvciAodmFyIF9uID0gMDsgX24gPCBjbHVzdGVyc1RvT3Blbi5sZW5ndGg7ICsrX24pIHtcbiAgICAgICAgICBfdGhpczQub3BlbkNsdXN0ZXIoY2x1c3RlcnNUb09wZW5bX25dLCB7fSwgZmFsc2UgLyogRG9uJ3QgcmVmcmVzaCwgd2UncmUgaW4gYW4gcmVmcmVzaC91cGRhdGUgYWxyZWFkeSAqL1xuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBjb250aW51ZUxvb3AgPSBjbHVzdGVyc1RvT3Blbi5sZW5ndGggPiAwO1xuICAgICAgICBjaGFuZ2VkID0gY2hhbmdlZCB8fCBjb250aW51ZUxvb3A7XG4gICAgICB9O1xuXG4gICAgICB3aGlsZSAoY29udGludWVMb29wKSB7XG4gICAgICAgIF9sb29wMigpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICB0aGlzLl91cGRhdGVTdGF0ZSgpOyAvLyBSZWRvIHRoaXMgbWV0aG9kIChyZWN1cnNpb24gcG9zc2libGUhIHNob3VsZCBiZSBzYWZlKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpZiBub2RlIHdpdGggZ2l2ZW4gaWQgaXMgcGFydCBvZiBhIGNsdXN0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IG5vZGVJZFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgcGFydCBvZiBhIGNsdXN0ZXIuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19pc0NsdXN0ZXJlZE5vZGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNDbHVzdGVyZWROb2RlKG5vZGVJZCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2x1c3RlcmVkTm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpZiBlZGdlIHdpdGggZ2l2ZW4gaWQgaXMgbm90IHZpc2libGUgZHVlIHRvIGNsdXN0ZXJpbmcuXG4gICAgICpcbiAgICAgKiBBbiBlZGdlIGlzIGNvbnNpZGVyZWQgY2x1c3RlcmVkIGlmOlxuICAgICAqIC0gaXQgaXMgZGlyZWN0bHkgcmVwbGFjZWQgYnkgYSBjbHVzdGVyaW5nIGVkZ2VcbiAgICAgKiAtIGFueSBvZiBpdHMgY29ubmVjdGluZyBub2RlcyBpcyBpbiBhIGNsdXN0ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7dmlzLkVkZ2UuaWR9IGVkZ2VJZFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgcGFydCBvZiBhIGNsdXN0ZXIuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19pc0NsdXN0ZXJlZEVkZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNDbHVzdGVyZWRFZGdlKGVkZ2VJZCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2x1c3RlcmVkRWRnZXNbZWRnZUlkXSAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ2x1c3RlckVuZ2luZTtcbn0oKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gQ2x1c3RlckVuZ2luZTtcblxuLyoqKi8gfSksXG4vKiAxNzkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9nZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpWydkZWZhdWx0J107XG5cbi8qKlxuICogQSBDbHVzdGVyIGlzIGEgc3BlY2lhbCBOb2RlIHRoYXQgYWxsb3dzIGEgZ3JvdXAgb2YgTm9kZXMgcG9zaXRpb25lZCBjbG9zZWx5IHRvZ2V0aGVyXG4gKiB0byBiZSByZXByZXNlbnRlZCBieSBhIHNpbmdsZSBDbHVzdGVyIE5vZGUuXG4gKlxuICogQGV4dGVuZHMgTm9kZVxuICovXG5cbnZhciBDbHVzdGVyID0gZnVuY3Rpb24gKF9Ob2RlKSB7XG4gICgwLCBfaW5oZXJpdHMzWydkZWZhdWx0J10pKENsdXN0ZXIsIF9Ob2RlKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtBcnJheS48SFRNTEltYWdlRWxlbWVudD59aW1hZ2VsaXN0XG4gICAqIEBwYXJhbSB7QXJyYXl9IGdyb3VwbGlzdFxuICAgKiBAcGFyYW0ge09iamVjdH0gZ2xvYmFsT3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdE9wdGlvbnMgICAgIEdsb2JhbCBkZWZhdWx0IG9wdGlvbnMgZm9yIG5vZGVzXG4gICAqL1xuICBmdW5jdGlvbiBDbHVzdGVyKG9wdGlvbnMsIGJvZHksIGltYWdlbGlzdCwgZ3JvdXBsaXN0LCBnbG9iYWxPcHRpb25zLCBkZWZhdWx0T3B0aW9ucykge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIENsdXN0ZXIpO1xuXG4gICAgdmFyIF90aGlzID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuM1snZGVmYXVsdCddKSh0aGlzLCAoQ2x1c3Rlci5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjJbJ2RlZmF1bHQnXSkoQ2x1c3RlcikpLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgaW1hZ2VsaXN0LCBncm91cGxpc3QsIGdsb2JhbE9wdGlvbnMsIGRlZmF1bHRPcHRpb25zKSk7XG5cbiAgICBfdGhpcy5pc0NsdXN0ZXIgPSB0cnVlO1xuICAgIF90aGlzLmNvbnRhaW5lZE5vZGVzID0ge307XG4gICAgX3RoaXMuY29udGFpbmVkRWRnZXMgPSB7fTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmZXIgY2hpbGQgY2x1c3RlciBkYXRhIHRvIGN1cnJlbnQgYW5kIGRpc2Nvbm5lY3QgdGhlIGNoaWxkIGNsdXN0ZXIuXG4gICAqXG4gICAqIFBsZWFzZSBjb25zdWx0IHRoZSBoZWFkZXIgY29tbWVudCBpbiAnQ2x1c3RlcmluZy5qcycgZm9yIHRoZSBmaWVsZHMgc2V0IGhlcmUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gY2hpbGRDbHVzdGVySWQgIGlkIG9mIGNoaWxkIGNsdXN0ZXIgdG8gb3BlblxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKENsdXN0ZXIsIFt7XG4gICAga2V5OiAnX29wZW5DaGlsZENsdXN0ZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb3BlbkNoaWxkQ2x1c3RlcihjaGlsZENsdXN0ZXJJZCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBjaGlsZENsdXN0ZXIgPSB0aGlzLmJvZHkubm9kZXNbY2hpbGRDbHVzdGVySWRdO1xuICAgICAgaWYgKHRoaXMuY29udGFpbmVkTm9kZXNbY2hpbGRDbHVzdGVySWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub2RlIHdpdGggaWQ6ICcgKyBjaGlsZENsdXN0ZXJJZCArICcgbm90IGluIGN1cnJlbnQgY2x1c3RlcicpO1xuICAgICAgfVxuICAgICAgaWYgKCFjaGlsZENsdXN0ZXIuaXNDbHVzdGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm9kZSB3aXRoIGlkOiAnICsgY2hpbGRDbHVzdGVySWQgKyAnIGlzIG5vdCBhIGNsdXN0ZXInKTtcbiAgICAgIH1cblxuICAgICAgLy8gRGlzY29ubmVjdCBjaGlsZCBjbHVzdGVyIGZyb20gY3VycmVudCBjbHVzdGVyXG4gICAgICBkZWxldGUgdGhpcy5jb250YWluZWROb2Rlc1tjaGlsZENsdXN0ZXJJZF07XG4gICAgICB1dGlsLmZvckVhY2goY2hpbGRDbHVzdGVyLmVkZ2VzLCBmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICBkZWxldGUgX3RoaXMyLmNvbnRhaW5lZEVkZ2VzW2VkZ2UuaWRdO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFRyYW5zZmVyIG5vZGVzIGFuZCBlZGdlc1xuICAgICAgdXRpbC5mb3JFYWNoKGNoaWxkQ2x1c3Rlci5jb250YWluZWROb2RlcywgZnVuY3Rpb24gKG5vZGUsIG5vZGVJZCkge1xuICAgICAgICBfdGhpczIuY29udGFpbmVkTm9kZXNbbm9kZUlkXSA9IG5vZGU7XG4gICAgICB9KTtcbiAgICAgIGNoaWxkQ2x1c3Rlci5jb250YWluZWROb2RlcyA9IHt9O1xuXG4gICAgICB1dGlsLmZvckVhY2goY2hpbGRDbHVzdGVyLmNvbnRhaW5lZEVkZ2VzLCBmdW5jdGlvbiAoZWRnZSwgZWRnZUlkKSB7XG4gICAgICAgIF90aGlzMi5jb250YWluZWRFZGdlc1tlZGdlSWRdID0gZWRnZTtcbiAgICAgIH0pO1xuICAgICAgY2hpbGRDbHVzdGVyLmNvbnRhaW5lZEVkZ2VzID0ge307XG5cbiAgICAgIC8vIFRyYW5zZmVyIGVkZ2VzIHdpdGhpbiBjbHVzdGVyIGVkZ2VzIHdoaWNoIGFyZSBjbHVzdGVyZWRcbiAgICAgIHV0aWwuZm9yRWFjaChjaGlsZENsdXN0ZXIuZWRnZXMsIGZ1bmN0aW9uIChjbHVzdGVyRWRnZSkge1xuICAgICAgICB1dGlsLmZvckVhY2goX3RoaXMyLmVkZ2VzLCBmdW5jdGlvbiAocGFyZW50Q2x1c3RlckVkZ2UpIHtcbiAgICAgICAgICAvLyBBc3N1bXB0aW9uOiBhIGNsdXN0ZXJlZCBlZGdlIGNhbiBvbmx5IGJlIHByZXNlbnQgaW4gYSBzaW5nbGUgY2x1c3RlcmluZyBlZGdlXG4gICAgICAgICAgLy8gTm90IHRlc3RlZCBoZXJlXG4gICAgICAgICAgdmFyIGluZGV4ID0gcGFyZW50Q2x1c3RlckVkZ2UuY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZHMuaW5kZXhPZihjbHVzdGVyRWRnZS5pZCk7XG4gICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuO1xuXG4gICAgICAgICAgdXRpbC5mb3JFYWNoKGNsdXN0ZXJFZGdlLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzLCBmdW5jdGlvbiAoc3JjSWQpIHtcbiAgICAgICAgICAgIHBhcmVudENsdXN0ZXJFZGdlLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzLnB1c2goc3JjSWQpO1xuXG4gICAgICAgICAgICAvLyBNYWludGFpbiBjb3JyZWN0IGJvb2trZWVwaW5nIGZvciB0cmFuc2ZlcnJlZCBlZGdlXG4gICAgICAgICAgICBfdGhpczIuYm9keS5lZGdlc1tzcmNJZF0uZWRnZVJlcGxhY2VkQnlJZCA9IHBhcmVudENsdXN0ZXJFZGdlLmlkO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gUmVtb3ZlIGNsdXN0ZXIgZWRnZSBmcm9tIHBhcmVudCBjbHVzdGVyIGVkZ2VcbiAgICAgICAgICBwYXJlbnRDbHVzdGVyRWRnZS5jbHVzdGVyaW5nRWRnZVJlcGxhY2luZ0lkcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgY2hpbGRDbHVzdGVyLmVkZ2VzID0gW107XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDbHVzdGVyO1xufShOb2RlKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gQ2x1c3RlcjtcblxuLyoqKi8gfSksXG4vKiAxODAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgpIHRvIGEgdXNhYmxlIGZvcm0uXG4gKlxuICogU3BlY2lmaWNhbGx5LCBzZXQgdXAgdGhpcyBtZXRob2QgZm9yIHRoZSBjYXNlIG9mIHJ1bm5pbmcgb24gbm9kZS5qcyB3aXRoIGpzZG9tIGVuYWJsZWQuXG4gKlxuICogTk9URVM6XG4gKlxuICogKiBPbiBub2RlLmpzLCB3aGVuIGNhbGxpbmcgdGhpcyBkaXJlY3RseSBvdXRzaWRlIG9mIHRoaXMgY2xhc3MsIGB3aW5kb3dgIGlzIG5vdCBkZWZpbmVkLlxuICogICBUaGlzIGhhcHBlbnMgZXZlbiBpZiBqc2RvbSBpcyB1c2VkLlxuICogKiBGb3Igbm9kZS5qcyArIGpzZG9tLCBgd2luZG93YCBpcyBhdmFpbGFibGUgYXQgdGhlIG1vbWVudCB0aGUgY29uc3RydWN0b3IgaXMgY2FsbGVkLlxuICogICBGb3IgdGhpcyByZWFzb24sIHRoZSBjYWxsZWQgaXMgcGxhY2VkIHdpdGhpbiB0aGUgY29uc3RydWN0b3IuXG4gKiAqIEV2ZW4gdGhlbiwgYHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKWAgaXMgbm90IGRlZmluZWQsIHNvIGl0IHN0aWxsIG5lZWRzIHRvIGJlIGFkZGVkLlxuICogKiBEdXJpbmcgdW5pdCB0ZXN0aW5nLCBpdCBoYXBwZW5zIHRoYXQgdGhlIHdpbmRvdyBvYmplY3QgaXMgcmVzZXQgZHVyaW5nIGV4ZWN1dGlvbiwgY2F1c2luZ1xuICogICBhIHJ1bnRpbWUgZXJyb3IgZHVlIHRvIG1pc3NpbmcgYHJlcXVlc3RBbmltYXRpb25GcmFtZSgpYC4gVGhpcyBuZWVkcyB0byBiZSBjb21wZW5zYXRlZCBmb3IsXG4gKiAgIHNlZSBgX3JlcXVlc3ROZXh0RnJhbWUoKWAuXG4gKiAqIFNpbmNlIHRoaXMgaXMgYSBnbG9iYWwgb2JqZWN0LCBpdCBtYXkgYWZmZWN0IG90aGVyIG1vZHVsZXMgYmVzaWRlcyBgTmV0d29ya2AuIFdpdGggbm9ybWFsXG4gKiAgIHVzYWdlLCB0aGlzIGRvZXMgbm90IGNhdXNlIGFueSBwcm9ibGVtcy4gRHVyaW5nIHVuaXQgdGVzdGluZywgZXJyb3JzIG1heSBvY2N1ci4gVGhlc2UgaGF2ZVxuICogICBiZWVuIGNvbXBlbnNhdGVkIGZvciwgc2VlIGNvbW1lbnQgYmxvY2sgaW4gX3JlcXVlc3ROZXh0RnJhbWUoKS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfaW5pdFJlcXVlc3RBbmltYXRpb25GcmFtZSgpIHtcbiAgdmFyIGZ1bmM7XG5cbiAgaWYgKHdpbmRvdyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZnVuYyA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZTtcbiAgfVxuXG4gIGlmIChmdW5jID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyB3aW5kb3cgb3IgbWV0aG9kIG5vdCBwcmVzZW50LCBzZXR0aW5nIG1vY2sgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgLy9jb25zb2xlLmxvZyhcIkNhbGxlZCBtb2NrIHJlcXVlc3RBbmltYXRpb25GcmFtZVwiKTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuYztcbiAgfVxufVxuXG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbi8qKlxuICogVGhlIGNhbnZhcyByZW5kZXJlclxuICovXG5cbnZhciBDYW52YXNSZW5kZXJlciA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7Q2FudmFzfSBjYW52YXNcbiAgICovXG4gIGZ1bmN0aW9uIENhbnZhc1JlbmRlcmVyKGJvZHksIGNhbnZhcykge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIENhbnZhc1JlbmRlcmVyKTtcblxuICAgIF9pbml0UmVxdWVzdEFuaW1hdGlvbkZyYW1lKCk7XG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcblxuICAgIHRoaXMucmVkcmF3UmVxdWVzdGVkID0gZmFsc2U7XG4gICAgdGhpcy5yZW5kZXJUaW1lciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJlcXVpcmVzVGltZW91dCA9IHRydWU7XG4gICAgdGhpcy5yZW5kZXJpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlclJlcXVlc3RzID0gMDtcbiAgICB0aGlzLmFsbG93UmVkcmF3ID0gdHJ1ZTtcblxuICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnpvb21pbmcgPSBmYWxzZTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgaGlkZUVkZ2VzT25EcmFnOiBmYWxzZSxcbiAgICAgIGhpZGVFZGdlc09uWm9vbTogZmFsc2UsXG4gICAgICBoaWRlTm9kZXNPbkRyYWc6IGZhbHNlXG4gICAgfTtcbiAgICB1dGlsLmV4dGVuZCh0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gICAgdGhpcy5fZGV0ZXJtaW5lQnJvd3Nlck1ldGhvZCgpO1xuICAgIHRoaXMuYmluZEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cblxuICAvKipcbiAgICogQmluZHMgZXZlbnQgbGlzdGVuZXJzXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoQ2FudmFzUmVuZGVyZXIsIFt7XG4gICAga2V5OiAnYmluZEV2ZW50TGlzdGVuZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ2RyYWdTdGFydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignZHJhZ0VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ3pvb20nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnpvb21pbmcgPSB0cnVlO1xuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KF90aGlzLnpvb21UaW1lb3V0SWQpO1xuICAgICAgICBfdGhpcy56b29tVGltZW91dElkID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLnpvb21pbmcgPSBmYWxzZTtcbiAgICAgICAgICBfdGhpcy5fcmVxdWVzdFJlZHJhdy5iaW5kKF90aGlzKSgpO1xuICAgICAgICB9LCAyNTApO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignX3Jlc2l6ZU5vZGVzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5fcmVzaXplTm9kZXMoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ19yZWRyYXcnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpcy5yZW5kZXJpbmdBY3RpdmUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgX3RoaXMuX3JlZHJhdygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdfYmxvY2tSZWRyYXcnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmFsbG93UmVkcmF3ID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdfYWxsb3dSZWRyYXcnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmFsbG93UmVkcmF3ID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMucmVkcmF3UmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdfcmVxdWVzdFJlZHJhdycsIHRoaXMuX3JlcXVlc3RSZWRyYXcuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignX3N0YXJ0UmVuZGVyaW5nJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5yZW5kZXJSZXF1ZXN0cyArPSAxO1xuICAgICAgICBfdGhpcy5yZW5kZXJpbmdBY3RpdmUgPSB0cnVlO1xuICAgICAgICBfdGhpcy5fc3RhcnRSZW5kZXJpbmcoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ19zdG9wUmVuZGVyaW5nJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5yZW5kZXJSZXF1ZXN0cyAtPSAxO1xuICAgICAgICBfdGhpcy5yZW5kZXJpbmdBY3RpdmUgPSBfdGhpcy5yZW5kZXJSZXF1ZXN0cyA+IDA7XG4gICAgICAgIF90aGlzLnJlbmRlclRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMucmVuZGVyUmVxdWVzdHMgPSAwO1xuICAgICAgICBfdGhpcy5hbGxvd1JlZHJhdyA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5yZW5kZXJpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgaWYgKF90aGlzLnJlcXVpcmVzVGltZW91dCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy5yZW5kZXJUaW1lcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKF90aGlzLnJlbmRlclRpbWVyKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5ib2R5LmVtaXR0ZXIub2ZmKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldE9wdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGZpZWxkcyA9IFsnaGlkZUVkZ2VzT25EcmFnJywgJ2hpZGVFZGdlc09uWm9vbScsICdoaWRlTm9kZXNPbkRyYWcnXTtcbiAgICAgICAgdXRpbC5zZWxlY3RpdmVEZWVwRXh0ZW5kKGZpZWxkcywgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlIHRoZSBkcmF3aW5nIG9mIHRoZSBuZXh0IGZyYW1lLlxuICAgICAqXG4gICAgICogQ2FsbHMgdGhlIGNhbGxiYWNrIHdoZW4gdGhlIG5leHQgZnJhbWUgY2FuIG9yIHdpbGwgYmUgZHJhd24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWxheSAtIHRpbWVvdXQgY2FzZSBvbmx5LCB3YWl0IHRoaXMgbnVtYmVyIG9mIG1pbGxpc2Vjb25kc1xuICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbnx1bmRlZmluZWR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3JlcXVlc3ROZXh0RnJhbWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVxdWVzdE5leHRGcmFtZShjYWxsYmFjaywgZGVsYXkpIHtcbiAgICAgIC8vIER1cmluZyB1bml0IHRlc3RpbmcsIGl0IGhhcHBlbnMgdGhhdCB0aGUgbW9jayB3aW5kb3cgb2JqZWN0IGlzIHJlc2V0IHdoaWxlXG4gICAgICAvLyB0aGUgbmV4dCBmcmFtZSBpcyBzdGlsbCBwZW5kaW5nLiBUaGVuLCBlaXRoZXIgJ3dpbmRvdycgaXMgbm90IHByZXNlbnQsIG9yXG4gICAgICAvLyAncmVxdWVzdEFuaW1hdGlvbkZyYW1lKCknIGlzIG5vdCBwcmVzZW50IGJlY2F1c2UgaXQgaXMgbm90IGRlZmluZWQgb24gdGhlXG4gICAgICAvLyBtb2NrIHdpbmRvdyBvYmplY3QuXG4gICAgICAvL1xuICAgICAgLy8gQXMgYSBjb25zZXF1ZW5jZSwgdW5yZWxhdGVkIHVuaXQgdGVzdHMgbWF5IGFwcGVhciB0byBmYWlsLCBldmVuIGlmIHRoZSBwcm9ibGVtXG4gICAgICAvLyBkZXNjcmliZWQgaGFwcGVucyBpbiB0aGUgY3VycmVudCB1bml0IHRlc3QuXG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBpcyBub3Qgc29tZXRoaW5nIHRoYXQgd2lsbCBoYXBwZW4gaW4gbm9ybWFsIG9wZXJhdGlvbiwgYnV0IHdlIHN0aWxsIG5lZWRcbiAgICAgIC8vIHRvIHRha2UgaXQgaW50byBhY2NvdW50LlxuICAgICAgLy9cbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuOyAvLyBEb2luZyBgaWYgKHdpbmRvdyA9PT0gdW5kZWZpbmVkKWAgZG9lcyBub3Qgd29yayBoZXJlIVxuXG4gICAgICB2YXIgdGltZXIgPSB2b2lkIDA7XG5cbiAgICAgIHZhciBteVdpbmRvdyA9IHdpbmRvdzsgLy8gR3JhYiBhIHJlZmVyZW5jZSB0byByZWR1Y2UgdGhlIHBvc3NpYmlsaXR5IHRoYXQgJ3dpbmRvdycgaXMgcmVzZXRcbiAgICAgIC8vIHdoaWxlIHJ1bm5pbmcgdGhpcyBtZXRob2QuXG5cbiAgICAgIGlmICh0aGlzLnJlcXVpcmVzVGltZW91dCA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyB3YWl0IGdpdmVuIG51bWJlciBvZiBtaWxsaXNlY29uZHMgYW5kIHBlcmZvcm0gdGhlIGFuaW1hdGlvbiBzdGVwIGZ1bmN0aW9uXG4gICAgICAgIHRpbWVyID0gbXlXaW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgZGVsYXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG15V2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgICAgIHRpbWVyID0gbXlXaW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGltZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfc3RhcnRSZW5kZXJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc3RhcnRSZW5kZXJpbmcoKSB7XG4gICAgICBpZiAodGhpcy5yZW5kZXJpbmdBY3RpdmUgPT09IHRydWUpIHtcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyVGltZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMucmVuZGVyVGltZXIgPSB0aGlzLl9yZXF1ZXN0TmV4dEZyYW1lKHRoaXMuX3JlbmRlclN0ZXAuYmluZCh0aGlzKSwgdGhpcy5zaW11bGF0aW9uSW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfcmVuZGVyU3RlcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW5kZXJTdGVwKCkge1xuICAgICAgaWYgKHRoaXMucmVuZGVyaW5nQWN0aXZlID09PSB0cnVlKSB7XG4gICAgICAgIC8vIHJlc2V0IHRoZSByZW5kZXJUaW1lciBzbyBhIG5ldyBzY2hlZHVsZWQgYW5pbWF0aW9uIHN0ZXAgY2FuIGJlIHNldFxuICAgICAgICB0aGlzLnJlbmRlclRpbWVyID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmICh0aGlzLnJlcXVpcmVzVGltZW91dCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIC8vIHRoaXMgc2NoZWR1bGVzIGEgbmV3IHNpbXVsYXRpb24gc3RlcFxuICAgICAgICAgIHRoaXMuX3N0YXJ0UmVuZGVyaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9yZWRyYXcoKTtcblxuICAgICAgICBpZiAodGhpcy5yZXF1aXJlc1RpbWVvdXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgLy8gdGhpcyBzY2hlZHVsZXMgYSBuZXcgc2ltdWxhdGlvbiBzdGVwXG4gICAgICAgICAgdGhpcy5fc3RhcnRSZW5kZXJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZHJhdyB0aGUgbmV0d29yayB3aXRoIHRoZSBjdXJyZW50IGRhdGFcbiAgICAgKiBjaGFydCB3aWxsIGJlIHJlc2l6ZWQgdG9vLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZWRyYXcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWRyYXcoKSB7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdzZXRTaXplJyk7XG4gICAgICB0aGlzLl9yZWRyYXcoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWRyYXcgdGhlIG5ldHdvcmsgd2l0aCB0aGUgY3VycmVudCBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3JlcXVlc3RSZWRyYXcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVxdWVzdFJlZHJhdygpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5yZWRyYXdSZXF1ZXN0ZWQgIT09IHRydWUgJiYgdGhpcy5yZW5kZXJpbmdBY3RpdmUgPT09IGZhbHNlICYmIHRoaXMuYWxsb3dSZWRyYXcgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5yZWRyYXdSZXF1ZXN0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0TmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczIuX3JlZHJhdyhmYWxzZSk7XG4gICAgICAgIH0sIDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZHJhdyB0aGUgbmV0d29yayB3aXRoIHRoZSBjdXJyZW50IGRhdGFcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtoaWRkZW49ZmFsc2VdIHwgVXNlZCB0byBnZXQgdGhlIGZpcnN0IGVzdGltYXRlIG9mIHRoZSBub2RlIHNpemVzLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPbmx5IHRoZSBub2RlcyBhcmUgZHJhd24gYWZ0ZXIgd2hpY2ggdGhleSBhcmUgcXVpY2tseSBkcmF3biBvdmVyLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19yZWRyYXcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVkcmF3KCkge1xuICAgICAgdmFyIGhpZGRlbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG5cbiAgICAgIGlmICh0aGlzLmFsbG93UmVkcmF3ID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ2luaXRSZWRyYXcnKTtcblxuICAgICAgICB0aGlzLnJlZHJhd1JlcXVlc3RlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIHdoZW4gdGhlIGNvbnRhaW5lciBkaXYgd2FzIGhpZGRlbiwgdGhpcyBmaXhlcyBpdCBiYWNrIHVwIVxuICAgICAgICBpZiAodGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLndpZHRoID09PSAwIHx8IHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5oZWlnaHQgPT09IDApIHtcbiAgICAgICAgICB0aGlzLmNhbnZhcy5zZXRTaXplKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbnZhcy5zZXRUcmFuc2Zvcm0oKTtcblxuICAgICAgICB2YXIgY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgpO1xuXG4gICAgICAgIC8vIGNsZWFyIHRoZSBjYW52YXNcbiAgICAgICAgdmFyIHcgPSB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGg7XG4gICAgICAgIHZhciBoID0gdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodDtcbiAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3LCBoKTtcblxuICAgICAgICAvLyBpZiB0aGUgZGl2IGlzIGhpZGRlbiwgd2Ugc3RvcCB0aGUgcmVkcmF3IGhlcmUgZm9yIHBlcmZvcm1hbmNlLlxuICAgICAgICBpZiAodGhpcy5jYW52YXMuZnJhbWUuY2xpZW50V2lkdGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgc2NhbGluZyBhbmQgdHJhbnNsYXRpb25cbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi54LCB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi55KTtcbiAgICAgICAgY3R4LnNjYWxlKHRoaXMuYm9keS52aWV3LnNjYWxlLCB0aGlzLmJvZHkudmlldy5zY2FsZSk7XG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdiZWZvcmVEcmF3aW5nJywgY3R4KTtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gICAgICAgIGlmIChoaWRkZW4gPT09IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKCh0aGlzLmRyYWdnaW5nID09PSBmYWxzZSB8fCB0aGlzLmRyYWdnaW5nID09PSB0cnVlICYmIHRoaXMub3B0aW9ucy5oaWRlRWRnZXNPbkRyYWcgPT09IGZhbHNlKSAmJiAodGhpcy56b29taW5nID09PSBmYWxzZSB8fCB0aGlzLnpvb21pbmcgPT09IHRydWUgJiYgdGhpcy5vcHRpb25zLmhpZGVFZGdlc09uWm9vbSA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgICB0aGlzLl9kcmF3RWRnZXMoY3R4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZyA9PT0gZmFsc2UgfHwgdGhpcy5kcmFnZ2luZyA9PT0gdHJ1ZSAmJiB0aGlzLm9wdGlvbnMuaGlkZU5vZGVzT25EcmFnID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMuX2RyYXdOb2RlcyhjdHgsIGhpZGRlbik7XG4gICAgICAgIH1cblxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ2FmdGVyRHJhd2luZycsIGN0eCk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcblxuICAgICAgICAvLyByZXN0b3JlIG9yaWdpbmFsIHNjYWxpbmcgYW5kIHRyYW5zbGF0aW9uXG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIGlmIChoaWRkZW4gPT09IHRydWUpIHtcbiAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHcsIGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVkcmF3IGFsbCBub2Rlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICAgY3R4XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbYWx3YXlzU2hvd11cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfcmVzaXplTm9kZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzaXplTm9kZXMoKSB7XG4gICAgICB0aGlzLmNhbnZhcy5zZXRUcmFuc2Zvcm0oKTtcbiAgICAgIHZhciBjdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCk7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi54LCB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi55KTtcbiAgICAgIGN0eC5zY2FsZSh0aGlzLmJvZHkudmlldy5zY2FsZSwgdGhpcy5ib2R5LnZpZXcuc2NhbGUpO1xuXG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICB2YXIgbm9kZSA9IHZvaWQgMDtcblxuICAgICAgLy8gcmVzaXplIGFsbCBub2Rlc1xuICAgICAgZm9yICh2YXIgbm9kZUlkIGluIG5vZGVzKSB7XG4gICAgICAgIGlmIChub2Rlcy5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgbm9kZSA9IG5vZGVzW25vZGVJZF07XG4gICAgICAgICAgbm9kZS5yZXNpemUoY3R4KTtcbiAgICAgICAgICBub2RlLnVwZGF0ZUJvdW5kaW5nQm94KGN0eCwgbm9kZS5zZWxlY3RlZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gcmVzdG9yZSBvcmlnaW5hbCBzY2FsaW5nIGFuZCB0cmFuc2xhdGlvblxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWRyYXcgYWxsIG5vZGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4ICAyRCBjb250ZXh0IG9mIGEgSFRNTCBjYW52YXNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthbHdheXNTaG93XVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19kcmF3Tm9kZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd05vZGVzKGN0eCkge1xuICAgICAgdmFyIGFsd2F5c1Nob3cgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICB2YXIgbm9kZUluZGljZXMgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7XG4gICAgICB2YXIgbm9kZSA9IHZvaWQgMDtcbiAgICAgIHZhciBzZWxlY3RlZCA9IFtdO1xuICAgICAgdmFyIG1hcmdpbiA9IDIwO1xuICAgICAgdmFyIHRvcExlZnQgPSB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyh7IHg6IC1tYXJnaW4sIHk6IC1tYXJnaW4gfSk7XG4gICAgICB2YXIgYm90dG9tUmlnaHQgPSB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyh7XG4gICAgICAgIHg6IHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCArIG1hcmdpbixcbiAgICAgICAgeTogdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodCArIG1hcmdpblxuICAgICAgfSk7XG4gICAgICB2YXIgdmlld2FibGVBcmVhID0ge1xuICAgICAgICB0b3A6IHRvcExlZnQueSxcbiAgICAgICAgbGVmdDogdG9wTGVmdC54LFxuICAgICAgICBib3R0b206IGJvdHRvbVJpZ2h0LnksXG4gICAgICAgIHJpZ2h0OiBib3R0b21SaWdodC54XG5cbiAgICAgICAgLy8gZHJhdyB1bnNlbGVjdGVkIG5vZGVzO1xuICAgICAgfTtmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5vZGUgPSBub2Rlc1tub2RlSW5kaWNlc1tpXV07XG4gICAgICAgIC8vIHNldCBzZWxlY3RlZCBub2RlcyBhc2lkZVxuICAgICAgICBpZiAobm9kZS5pc1NlbGVjdGVkKCkpIHtcbiAgICAgICAgICBzZWxlY3RlZC5wdXNoKG5vZGVJbmRpY2VzW2ldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoYWx3YXlzU2hvdyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgbm9kZS5kcmF3KGN0eCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChub2RlLmlzQm91bmRpbmdCb3hPdmVybGFwcGluZ1dpdGgodmlld2FibGVBcmVhKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgbm9kZS5kcmF3KGN0eCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUudXBkYXRlQm91bmRpbmdCb3goY3R4LCBub2RlLnNlbGVjdGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZHJhdyB0aGUgc2VsZWN0ZWQgbm9kZXMgb24gdG9wXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgc2VsZWN0ZWQubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG5vZGUgPSBub2Rlc1tzZWxlY3RlZFtfaV1dO1xuICAgICAgICBub2RlLmRyYXcoY3R4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWRyYXcgYWxsIGVkZ2VzXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAgMkQgY29udGV4dCBvZiBhIEhUTUwgY2FudmFzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2RyYXdFZGdlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3RWRnZXMoY3R4KSB7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gICAgICB2YXIgZWRnZUluZGljZXMgPSB0aGlzLmJvZHkuZWRnZUluZGljZXM7XG4gICAgICB2YXIgZWRnZSA9IHZvaWQgMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBlZGdlID0gZWRnZXNbZWRnZUluZGljZXNbaV1dO1xuICAgICAgICBpZiAoZWRnZS5jb25uZWN0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICBlZGdlLmRyYXcoY3R4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpZiB0aGUgYnJvd3NlciByZXF1aXJlcyBhIHNldFRpbWVvdXQgb3IgYSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuIFRoaXMgd2FzIHJlcXVpcmVkIGJlY2F1c2VcbiAgICAgKiBzb21lIGltcGxlbWVudGF0aW9ucyAoc2FmYXJpIGFuZCBJRTkpIGRpZCBub3Qgc3VwcG9ydCByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZGV0ZXJtaW5lQnJvd3Nlck1ldGhvZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXRlcm1pbmVCcm93c2VyTWV0aG9kKCkge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBicm93c2VyVHlwZSA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdGhpcy5yZXF1aXJlc1RpbWVvdXQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGJyb3dzZXJUeXBlLmluZGV4T2YoJ21zaWUgOS4wJykgIT0gLTEpIHtcbiAgICAgICAgICAvLyBJRSA5XG4gICAgICAgICAgdGhpcy5yZXF1aXJlc1RpbWVvdXQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGJyb3dzZXJUeXBlLmluZGV4T2YoJ3NhZmFyaScpICE9IC0xKSB7XG4gICAgICAgICAgLy8gc2FmYXJpXG4gICAgICAgICAgaWYgKGJyb3dzZXJUeXBlLmluZGV4T2YoJ2Nocm9tZScpIDw9IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVpcmVzVGltZW91dCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlcXVpcmVzVGltZW91dCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDYW52YXNSZW5kZXJlcjtcbn0oKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gQ2FudmFzUmVuZGVyZXI7XG5cbi8qKiovIH0pLFxuLyogMTgxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgSGFtbWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG52YXIgaGFtbWVyVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpO1xuXG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBtYWluIGZyYW1lIGZvciB0aGUgTmV0d29yay5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgb25jZSB3aGVuIGEgTmV0d29yayBvYmplY3QgaXMgY3JlYXRlZC4gVGhlIGZyYW1lXG4gKiBjb250YWlucyBhIGNhbnZhcywgYW5kIHRoaXMgY2FudmFzIGNvbnRhaW5zIGFsbCBvYmplY3RzIGxpa2UgdGhlIGF4aXMgYW5kXG4gKiBub2Rlcy5cbiAqL1xuXG52YXIgQ2FudmFzID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGJvZHlcbiAgICovXG4gIGZ1bmN0aW9uIENhbnZhcyhib2R5KSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgQ2FudmFzKTtcblxuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5waXhlbFJhdGlvID0gMTtcbiAgICB0aGlzLnJlc2l6ZVRpbWVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmVzaXplRnVuY3Rpb24gPSB0aGlzLl9vblJlc2l6ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuY2FtZXJhU3RhdGUgPSB7fTtcbiAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5jYW52YXNWaWV3Q2VudGVyID0ge307XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgYXV0b1Jlc2l6ZTogdHJ1ZSxcbiAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgd2lkdGg6ICcxMDAlJ1xuICAgIH07XG4gICAgdXRpbC5leHRlbmQodGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICAgIHRoaXMuYmluZEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cblxuICAvKipcbiAgICogQmluZHMgZXZlbnQgbGlzdGVuZXJzXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoQ2FudmFzLCBbe1xuICAgIGtleTogJ2JpbmRFdmVudExpc3RlbmVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRFdmVudExpc3RlbmVycygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIC8vIGJpbmQgdGhlIGV2ZW50c1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub25jZSgncmVzaXplJywgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBpZiAob2JqLndpZHRoICE9PSAwKSB7XG4gICAgICAgICAgX3RoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnggPSBvYmoud2lkdGggKiAwLjU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iai5oZWlnaHQgIT09IDApIHtcbiAgICAgICAgICBfdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueSA9IG9iai5oZWlnaHQgKiAwLjU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ3NldFNpemUnLCB0aGlzLnNldFNpemUuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuaGFtbWVyRnJhbWUuZGVzdHJveSgpO1xuICAgICAgICBfdGhpcy5oYW1tZXIuZGVzdHJveSgpO1xuICAgICAgICBfdGhpcy5fY2xlYW5VcCgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0T3B0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGZpZWxkcyA9IFsnd2lkdGgnLCAnaGVpZ2h0JywgJ2F1dG9SZXNpemUnXTtcbiAgICAgICAgdXRpbC5zZWxlY3RpdmVEZWVwRXh0ZW5kKGZpZWxkcywgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvUmVzaXplID09PSB0cnVlKSB7XG4gICAgICAgIC8vIGF1dG9tYXRpY2FsbHkgYWRhcHQgdG8gYSBjaGFuZ2luZyBzaXplIG9mIHRoZSBicm93c2VyLlxuICAgICAgICB0aGlzLl9jbGVhblVwKCk7XG4gICAgICAgIHRoaXMucmVzaXplVGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGNoYW5nZWQgPSBfdGhpczIuc2V0U2l6ZSgpO1xuICAgICAgICAgIGlmIChjaGFuZ2VkID09PSB0cnVlKSB7XG4gICAgICAgICAgICBfdGhpczIuYm9keS5lbWl0dGVyLmVtaXQoJ19yZXF1ZXN0UmVkcmF3Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgdGhpcy5yZXNpemVGdW5jdGlvbiA9IHRoaXMuX29uUmVzaXplLmJpbmQodGhpcyk7XG4gICAgICAgIHV0aWwuYWRkRXZlbnRMaXN0ZW5lcih3aW5kb3csICdyZXNpemUnLCB0aGlzLnJlc2l6ZUZ1bmN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfY2xlYW5VcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jbGVhblVwKCkge1xuICAgICAgLy8gYXV0b21hdGljYWxseSBhZGFwdCB0byBhIGNoYW5naW5nIHNpemUgb2YgdGhlIGJyb3dzZXIuXG4gICAgICBpZiAodGhpcy5yZXNpemVUaW1lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5yZXNpemVUaW1lcik7XG4gICAgICB9XG4gICAgICB1dGlsLnJlbW92ZUV2ZW50TGlzdGVuZXIod2luZG93LCAncmVzaXplJywgdGhpcy5yZXNpemVGdW5jdGlvbik7XG4gICAgICB0aGlzLnJlc2l6ZUZ1bmN0aW9uID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19vblJlc2l6ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vblJlc2l6ZSgpIHtcbiAgICAgIHRoaXMuc2V0U2l6ZSgpO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX3JlZHJhdycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhbmQgc3RvcmUgdGhlIGNhbWVyYVN0YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BpeGVsUmF0aW89dGhpcy5waXhlbFJhdGlvXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19nZXRDYW1lcmFTdGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDYW1lcmFTdGF0ZSgpIHtcbiAgICAgIHZhciBwaXhlbFJhdGlvID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLnBpeGVsUmF0aW87XG5cbiAgICAgIGlmICh0aGlzLmluaXRpYWxpemVkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuY2FtZXJhU3RhdGUucHJldmlvdXNXaWR0aCA9IHRoaXMuZnJhbWUuY2FudmFzLndpZHRoIC8gcGl4ZWxSYXRpbztcbiAgICAgICAgdGhpcy5jYW1lcmFTdGF0ZS5wcmV2aW91c0hlaWdodCA9IHRoaXMuZnJhbWUuY2FudmFzLmhlaWdodCAvIHBpeGVsUmF0aW87XG4gICAgICAgIHRoaXMuY2FtZXJhU3RhdGUuc2NhbGUgPSB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgICAgdGhpcy5jYW1lcmFTdGF0ZS5wb3NpdGlvbiA9IHRoaXMuRE9NdG9DYW52YXMoe1xuICAgICAgICAgIHg6IDAuNSAqIHRoaXMuZnJhbWUuY2FudmFzLndpZHRoIC8gcGl4ZWxSYXRpbyxcbiAgICAgICAgICB5OiAwLjUgKiB0aGlzLmZyYW1lLmNhbnZhcy5oZWlnaHQgLyBwaXhlbFJhdGlvXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY2FtZXJhU3RhdGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfc2V0Q2FtZXJhU3RhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0Q2FtZXJhU3RhdGUoKSB7XG4gICAgICBpZiAodGhpcy5jYW1lcmFTdGF0ZS5zY2FsZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoICE9PSAwICYmIHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodCAhPT0gMCAmJiB0aGlzLnBpeGVsUmF0aW8gIT09IDAgJiYgdGhpcy5jYW1lcmFTdGF0ZS5wcmV2aW91c1dpZHRoID4gMCkge1xuICAgICAgICB2YXIgd2lkdGhSYXRpbyA9IHRoaXMuZnJhbWUuY2FudmFzLndpZHRoIC8gdGhpcy5waXhlbFJhdGlvIC8gdGhpcy5jYW1lcmFTdGF0ZS5wcmV2aW91c1dpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0UmF0aW8gPSB0aGlzLmZyYW1lLmNhbnZhcy5oZWlnaHQgLyB0aGlzLnBpeGVsUmF0aW8gLyB0aGlzLmNhbWVyYVN0YXRlLnByZXZpb3VzSGVpZ2h0O1xuICAgICAgICB2YXIgbmV3U2NhbGUgPSB0aGlzLmNhbWVyYVN0YXRlLnNjYWxlO1xuXG4gICAgICAgIGlmICh3aWR0aFJhdGlvICE9IDEgJiYgaGVpZ2h0UmF0aW8gIT0gMSkge1xuICAgICAgICAgIG5ld1NjYWxlID0gdGhpcy5jYW1lcmFTdGF0ZS5zY2FsZSAqIDAuNSAqICh3aWR0aFJhdGlvICsgaGVpZ2h0UmF0aW8pO1xuICAgICAgICB9IGVsc2UgaWYgKHdpZHRoUmF0aW8gIT0gMSkge1xuICAgICAgICAgIG5ld1NjYWxlID0gdGhpcy5jYW1lcmFTdGF0ZS5zY2FsZSAqIHdpZHRoUmF0aW87XG4gICAgICAgIH0gZWxzZSBpZiAoaGVpZ2h0UmF0aW8gIT0gMSkge1xuICAgICAgICAgIG5ld1NjYWxlID0gdGhpcy5jYW1lcmFTdGF0ZS5zY2FsZSAqIGhlaWdodFJhdGlvO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ib2R5LnZpZXcuc2NhbGUgPSBuZXdTY2FsZTtcbiAgICAgICAgLy8gdGhpcyBjb21lcyBmcm9tIHRoZSB2aWV3IG1vZHVsZS5cbiAgICAgICAgdmFyIGN1cnJlbnRWaWV3Q2VudGVyID0gdGhpcy5ET010b0NhbnZhcyh7XG4gICAgICAgICAgeDogMC41ICogdGhpcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGgsXG4gICAgICAgICAgeTogMC41ICogdGhpcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBkaXN0YW5jZUZyb21DZW50ZXIgPSB7XG4gICAgICAgICAgLy8gb2Zmc2V0IGZyb20gdmlldywgZGlzdGFuY2UgdmlldyBoYXMgdG8gY2hhbmdlIGJ5IHRoZXNlIHggYW5kIHkgdG8gY2VudGVyIHRoZSBub2RlXG4gICAgICAgICAgeDogY3VycmVudFZpZXdDZW50ZXIueCAtIHRoaXMuY2FtZXJhU3RhdGUucG9zaXRpb24ueCxcbiAgICAgICAgICB5OiBjdXJyZW50Vmlld0NlbnRlci55IC0gdGhpcy5jYW1lcmFTdGF0ZS5wb3NpdGlvbi55XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnggKz0gZGlzdGFuY2VGcm9tQ2VudGVyLnggKiB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueSArPSBkaXN0YW5jZUZyb21DZW50ZXIueSAqIHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3ByZXBhcmVWYWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wcmVwYXJlVmFsdWUodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSArICdweCc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHZhbHVlLmluZGV4T2YoJyUnKSAhPT0gLTEgfHwgdmFsdWUuaW5kZXhPZigncHgnKSAhPT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUuaW5kZXhPZignJScpID09PSAtMSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZSArICdweCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHVzZSB0aGUgdmFsdWUgc3VwcGxpZWQgZm9yIHdpZHRoIG9yIGhlaWdodDonICsgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgSFRNTFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfY3JlYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZSgpIHtcbiAgICAgIC8vIHJlbW92ZSBhbGwgZWxlbWVudHMgZnJvbSB0aGUgY29udGFpbmVyIGVsZW1lbnQuXG4gICAgICB3aGlsZSAodGhpcy5ib2R5LmNvbnRhaW5lci5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgdGhpcy5ib2R5LmNvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLmJvZHkuY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzLmZyYW1lLmNsYXNzTmFtZSA9ICd2aXMtbmV0d29yayc7XG4gICAgICB0aGlzLmZyYW1lLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgIHRoaXMuZnJhbWUuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgIHRoaXMuZnJhbWUudGFiSW5kZXggPSA5MDA7IC8vIHRhYiBpbmRleCBpcyByZXF1aXJlZCBmb3Iga2V5Y2hhcm0gdG8gYmluZCBrZXlzdHJva2VzIHRvIHRoZSBkaXYgaW5zdGVhZCBvZiB0aGUgd2luZG93XG5cbiAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICB0aGlzLmZyYW1lLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgdGhpcy5mcmFtZS5jYW52YXMuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmZyYW1lLmNhbnZhcyk7XG5cbiAgICAgIGlmICghdGhpcy5mcmFtZS5jYW52YXMuZ2V0Q29udGV4dCkge1xuICAgICAgICB2YXIgbm9DYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcbiAgICAgICAgbm9DYW52YXMuc3R5bGUuY29sb3IgPSAncmVkJztcbiAgICAgICAgbm9DYW52YXMuc3R5bGUuZm9udFdlaWdodCA9ICdib2xkJztcbiAgICAgICAgbm9DYW52YXMuc3R5bGUucGFkZGluZyA9ICcxMHB4JztcbiAgICAgICAgbm9DYW52YXMuaW5uZXJIVE1MID0gJ0Vycm9yOiB5b3VyIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBIVE1MIGNhbnZhcyc7XG4gICAgICAgIHRoaXMuZnJhbWUuY2FudmFzLmFwcGVuZENoaWxkKG5vQ2FudmFzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NldFBpeGVsUmF0aW8oKTtcbiAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0oKTtcbiAgICAgIH1cblxuICAgICAgLy8gYWRkIHRoZSBmcmFtZSB0byB0aGUgY29udGFpbmVyIGVsZW1lbnRcbiAgICAgIHRoaXMuYm9keS5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5mcmFtZSk7XG5cbiAgICAgIHRoaXMuYm9keS52aWV3LnNjYWxlID0gMTtcbiAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uID0ge1xuICAgICAgICB4OiAwLjUgKiB0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCxcbiAgICAgICAgeTogMC41ICogdGhpcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0XG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9iaW5kSGFtbWVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBiaW5kcyBoYW1tZXIsIGl0IGNhbiBiZSByZXBlYXRlZCBvdmVyIGFuZCBvdmVyIGR1ZSB0byB0aGUgdW5pcXVlbmVzcyBjaGVjay5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfYmluZEhhbW1lcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9iaW5kSGFtbWVyKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLmhhbW1lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuaGFtbWVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZHJhZyA9IHt9O1xuICAgICAgdGhpcy5waW5jaCA9IHt9O1xuXG4gICAgICAvLyBpbml0IGhhbW1lclxuICAgICAgdGhpcy5oYW1tZXIgPSBuZXcgSGFtbWVyKHRoaXMuZnJhbWUuY2FudmFzKTtcbiAgICAgIHRoaXMuaGFtbWVyLmdldCgncGluY2gnKS5zZXQoeyBlbmFibGU6IHRydWUgfSk7XG4gICAgICAvLyBlbmFibGUgdG8gZ2V0IGJldHRlciByZXNwb25zZSwgdG9kbzogdGVzdCBvbiBtb2JpbGUuXG4gICAgICB0aGlzLmhhbW1lci5nZXQoJ3BhbicpLnNldCh7IHRocmVzaG9sZDogNSwgZGlyZWN0aW9uOiBIYW1tZXIuRElSRUNUSU9OX0FMTCB9KTtcblxuICAgICAgaGFtbWVyVXRpbC5vblRvdWNoKHRoaXMuaGFtbWVyLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Ub3VjaChldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFtbWVyLm9uKCd0YXAnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25UYXAoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmhhbW1lci5vbignZG91YmxldGFwJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uRG91YmxlVGFwKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5oYW1tZXIub24oJ3ByZXNzJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uSG9sZChldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFtbWVyLm9uKCdwYW5zdGFydCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vbkRyYWdTdGFydChldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFtbWVyLm9uKCdwYW5tb3ZlJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uRHJhZyhldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFtbWVyLm9uKCdwYW5lbmQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25EcmFnRW5kKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5oYW1tZXIub24oJ3BpbmNoJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uUGluY2goZXZlbnQpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFRPRE86IG5lYXRseSBjbGVhbnVwIHRoZXNlIGhhbmRsZXJzIHdoZW4gcmUtY3JlYXRpbmcgdGhlIENhbnZhcywgSUYgdGhlc2UgYXJlIGRvbmUgd2l0aCBoYW1tZXIsIGV2ZW50LnN0b3BQcm9wYWdhdGlvbiB3aWxsIG5vdCB3b3JrP1xuICAgICAgdGhpcy5mcmFtZS5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vbk1vdXNlV2hlZWwoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmZyYW1lLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vbk1vdXNlV2hlZWwoZXZlbnQpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuZnJhbWUuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vbk1vdXNlTW92ZShldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZnJhbWUuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uQ29udGV4dChldmVudCk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5oYW1tZXJGcmFtZSA9IG5ldyBIYW1tZXIodGhpcy5mcmFtZSk7XG4gICAgICBoYW1tZXJVdGlsLm9uUmVsZWFzZSh0aGlzLmhhbW1lckZyYW1lLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25SZWxlYXNlKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBhIG5ldyBzaXplIGZvciB0aGUgbmV0d29ya1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3aWR0aCAgIFdpZHRoIGluIHBpeGVscyBvciBwZXJjZW50YWdlIChmb3IgZXhhbXBsZSAnODAwcHgnXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgb3IgJzUwJScpXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGhlaWdodCAgSGVpZ2h0IGluIHBpeGVscyBvciBwZXJjZW50YWdlICAoZm9yIGV4YW1wbGUgJzQwMHB4J1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgIG9yICczMCUnKVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRTaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U2l6ZSgpIHtcbiAgICAgIHZhciB3aWR0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdGhpcy5vcHRpb25zLndpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5vcHRpb25zLmhlaWdodDtcblxuICAgICAgd2lkdGggPSB0aGlzLl9wcmVwYXJlVmFsdWUod2lkdGgpO1xuICAgICAgaGVpZ2h0ID0gdGhpcy5fcHJlcGFyZVZhbHVlKGhlaWdodCk7XG5cbiAgICAgIHZhciBlbWl0RXZlbnQgPSBmYWxzZTtcbiAgICAgIHZhciBvbGRXaWR0aCA9IHRoaXMuZnJhbWUuY2FudmFzLndpZHRoO1xuICAgICAgdmFyIG9sZEhlaWdodCA9IHRoaXMuZnJhbWUuY2FudmFzLmhlaWdodDtcblxuICAgICAgLy8gdXBkYXRlIHRoZSBwaXhlbCByYXRpb1xuICAgICAgLy9cbiAgICAgIC8vIE5PVEU6IENvbW1lbnQgaW4gZm9sbG93aW5nIGlzIHJhdGhlciBpbmNvbnNpc3RlbnQ7IHRoaXMgaXMgdGhlIE9OTFkgcGxhY2UgaW4gdGhlIGNvZGVcbiAgICAgIC8vICAgICAgIHdoZXJlIGl0IGlzIGFzc3VtZWQgdGhhdCB0aGUgcGl4ZWwgcmF0aW8gY291bGQgY2hhbmdlIGF0IHJ1bnRpbWUuXG4gICAgICAvLyAgICAgICBUaGUgb25seSB3YXkgSSBjYW4gdGhpbmsgb2YgdGhpcyBoYXBwZW5pbmcgaXMgYSByb3RhdGluZyBzY3JlZW4gb3IgdGFibGV0OyBidXQgdGhlblxuICAgICAgLy8gICAgICAgdGhlcmUgc2hvdWxkIGJlIGEgbWVjaGFuaXNtIGZvciByZWxvYWRpbmcgdGhlIGRhdGEgKFRPRE86IGNoZWNrIGlmIHRoaXMgaXMgcHJlc2VudCkuXG4gICAgICAvL1xuICAgICAgLy8gICAgICAgSWYgdGhlIGFzc3VtcHRpb24gaXMgdHJ1ZSAoaS5lLiBwaXhlbCByYXRpbyBjYW4gY2hhbmdlIGF0IHJ1bnRpbWUpLCB0aGVuICphbGwqIHVzYWdlXG4gICAgICAvLyAgICAgICBvZiBwaXhlbCByYXRpbyBtdXN0IGJlIG92ZXJoYXVsZWQgZm9yIHRoaXMuXG4gICAgICAvL1xuICAgICAgLy8gICAgICAgRm9yIHRoZSB0aW1lIGJlaW5nLCBJIHdpbGwgaHVtb3IgdGhlIGFzc3VtcHRpb24gaGVyZSwgYW5kIGluIHRoZSByZXN0IG9mIHRoZSBjb2RlIGFzc3VtZSBpdCBpc1xuICAgICAgLy8gICAgICAgY29uc3RhbnQuXG4gICAgICB2YXIgcHJldmlvdXNSYXRpbyA9IHRoaXMucGl4ZWxSYXRpbzsgLy8gd2UgY2FjaGUgdGhpcyBiZWNhdXNlIHRoZSBjYW1lcmEgc3RhdGUgc3RvcmFnZSBuZWVkcyB0aGUgb2xkIHZhbHVlXG4gICAgICB0aGlzLl9zZXRQaXhlbFJhdGlvKCk7XG5cbiAgICAgIGlmICh3aWR0aCAhPSB0aGlzLm9wdGlvbnMud2lkdGggfHwgaGVpZ2h0ICE9IHRoaXMub3B0aW9ucy5oZWlnaHQgfHwgdGhpcy5mcmFtZS5zdHlsZS53aWR0aCAhPSB3aWR0aCB8fCB0aGlzLmZyYW1lLnN0eWxlLmhlaWdodCAhPSBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5fZ2V0Q2FtZXJhU3RhdGUocHJldmlvdXNSYXRpbyk7XG5cbiAgICAgICAgdGhpcy5mcmFtZS5zdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmZyYW1lLnN0eWxlLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICB0aGlzLmZyYW1lLmNhbnZhcy5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgICAgdGhpcy5mcmFtZS5jYW52YXMuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuXG4gICAgICAgIHRoaXMuZnJhbWUuY2FudmFzLndpZHRoID0gTWF0aC5yb3VuZCh0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCAqIHRoaXMucGl4ZWxSYXRpbyk7XG4gICAgICAgIHRoaXMuZnJhbWUuY2FudmFzLmhlaWdodCA9IE1hdGgucm91bmQodGhpcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0ICogdGhpcy5waXhlbFJhdGlvKTtcblxuICAgICAgICB0aGlzLm9wdGlvbnMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5vcHRpb25zLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICB0aGlzLmNhbnZhc1ZpZXdDZW50ZXIgPSB7XG4gICAgICAgICAgeDogMC41ICogdGhpcy5mcmFtZS5jbGllbnRXaWR0aCxcbiAgICAgICAgICB5OiAwLjUgKiB0aGlzLmZyYW1lLmNsaWVudEhlaWdodFxuICAgICAgICB9O1xuXG4gICAgICAgIGVtaXRFdmVudCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGlzIHdvdWxkIGFkYXB0IHRoZSB3aWR0aCBvZiB0aGUgY2FudmFzIHRvIHRoZSB3aWR0aCBmcm9tIDEwMCUgaWYgYW5kIG9ubHkgaWZcbiAgICAgICAgLy8gdGhlcmUgaXMgYSBjaGFuZ2UuXG5cbiAgICAgICAgdmFyIG5ld1dpZHRoID0gTWF0aC5yb3VuZCh0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCAqIHRoaXMucGl4ZWxSYXRpbyk7XG4gICAgICAgIHZhciBuZXdIZWlnaHQgPSBNYXRoLnJvdW5kKHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodCAqIHRoaXMucGl4ZWxSYXRpbyk7XG5cbiAgICAgICAgLy8gc3RvcmUgdGhlIGNhbWVyYSBpZiB0aGVyZSBpcyBhIGNoYW5nZSBpbiBzaXplLlxuICAgICAgICBpZiAodGhpcy5mcmFtZS5jYW52YXMud2lkdGggIT09IG5ld1dpZHRoIHx8IHRoaXMuZnJhbWUuY2FudmFzLmhlaWdodCAhPT0gbmV3SGVpZ2h0KSB7XG4gICAgICAgICAgdGhpcy5fZ2V0Q2FtZXJhU3RhdGUocHJldmlvdXNSYXRpbyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5mcmFtZS5jYW52YXMud2lkdGggIT09IG5ld1dpZHRoKSB7XG4gICAgICAgICAgdGhpcy5mcmFtZS5jYW52YXMud2lkdGggPSBuZXdXaWR0aDtcbiAgICAgICAgICBlbWl0RXZlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZyYW1lLmNhbnZhcy5oZWlnaHQgIT09IG5ld0hlaWdodCkge1xuICAgICAgICAgIHRoaXMuZnJhbWUuY2FudmFzLmhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgICAgICBlbWl0RXZlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChlbWl0RXZlbnQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgncmVzaXplJywge1xuICAgICAgICAgIHdpZHRoOiBNYXRoLnJvdW5kKHRoaXMuZnJhbWUuY2FudmFzLndpZHRoIC8gdGhpcy5waXhlbFJhdGlvKSxcbiAgICAgICAgICBoZWlnaHQ6IE1hdGgucm91bmQodGhpcy5mcmFtZS5jYW52YXMuaGVpZ2h0IC8gdGhpcy5waXhlbFJhdGlvKSxcbiAgICAgICAgICBvbGRXaWR0aDogTWF0aC5yb3VuZChvbGRXaWR0aCAvIHRoaXMucGl4ZWxSYXRpbyksXG4gICAgICAgICAgb2xkSGVpZ2h0OiBNYXRoLnJvdW5kKG9sZEhlaWdodCAvIHRoaXMucGl4ZWxSYXRpbylcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gcmVzdG9yZSB0aGUgY2FtZXJhIG9uIGNoYW5nZS5cbiAgICAgICAgdGhpcy5fc2V0Q2FtZXJhU3RhdGUoKTtcbiAgICAgIH1cblxuICAgICAgLy8gc2V0IGluaXRpYWxpemVkIHNvIHRoZSBnZXQgYW5kIHNldCBjYW1lcmEgd2lsbCB3b3JrIGZyb20gbm93IG9uLlxuICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICByZXR1cm4gZW1pdEV2ZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybnMge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0Q29udGV4dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5mcmFtZS5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgdGhlIHBpeGVsIHJhdGlvIGZvciB2YXJpb3VzIGJyb3dzZXJzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZGV0ZXJtaW5lUGl4ZWxSYXRpbycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXRlcm1pbmVQaXhlbFJhdGlvKCkge1xuICAgICAgdmFyIGN0eCA9IHRoaXMuZ2V0Q29udGV4dCgpO1xuICAgICAgaWYgKGN0eCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGdldCBjYW52YXggY29udGV4dCcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbnVtZXJhdG9yID0gMTtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyAod2luZG93ICE9PSB1bmRlZmluZWQpIGRvZXNuJ3Qgd29yayBoZXJlIVxuICAgICAgICAvLyBQcm90ZWN0aW9uIGR1cmluZyB1bml0IHRlc3RzLCB3aGVyZSAnd2luZG93JyBjYW4gYmUgbWlzc2luZ1xuICAgICAgICBudW1lcmF0b3IgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVub21pbmF0b3IgPSBjdHgud2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5vQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHguYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCAxO1xuXG4gICAgICByZXR1cm4gbnVtZXJhdG9yIC8gZGVub21pbmF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGF6eSBkZXRlcm1pbmF0aW9uIG9mIHBpeGVsIHJhdGlvLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3NldFBpeGVsUmF0aW8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0UGl4ZWxSYXRpbygpIHtcbiAgICAgIHRoaXMucGl4ZWxSYXRpbyA9IHRoaXMuX2RldGVybWluZVBpeGVsUmF0aW8oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHRyYW5zZm9ybSBpbiB0aGUgY29udGFpbmVkIGNvbnRleHQsIGJhc2VkIG9uIGl0cyBwaXhlbFJhdGlvXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldFRyYW5zZm9ybScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFRyYW5zZm9ybSgpIHtcbiAgICAgIHZhciBjdHggPSB0aGlzLmdldENvbnRleHQoKTtcbiAgICAgIGlmIChjdHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgY2FudmF4IGNvbnRleHQnKTtcbiAgICAgIH1cblxuICAgICAgY3R4LnNldFRyYW5zZm9ybSh0aGlzLnBpeGVsUmF0aW8sIDAsIDAsIHRoaXMucGl4ZWxSYXRpbywgMCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgWCBjb29yZGluYXRlIGluIERPTS1zcGFjZSAoY29vcmRpbmF0ZSBwb2ludCBpbiBicm93c2VyIHJlbGF0aXZlIHRvIHRoZSBjb250YWluZXIgZGl2KSB0b1xuICAgICAqIHRoZSBYIGNvb3JkaW5hdGUgaW4gY2FudmFzLXNwYWNlICh0aGUgc2ltdWxhdGlvbiBzYW5kYm94LCB3aGljaCB0aGUgY2FtZXJhIGxvb2tzIHVwb24pXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19YY29udmVydERPTXRvQ2FudmFzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX1hjb252ZXJ0RE9NdG9DYW52YXMoeCkge1xuICAgICAgcmV0dXJuICh4IC0gdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueCkgLyB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBYIGNvb3JkaW5hdGUgaW4gY2FudmFzLXNwYWNlICh0aGUgc2ltdWxhdGlvbiBzYW5kYm94LCB3aGljaCB0aGUgY2FtZXJhIGxvb2tzIHVwb24pIHRvXG4gICAgICogdGhlIFggY29vcmRpbmF0ZSBpbiBET00tc3BhY2UgKGNvb3JkaW5hdGUgcG9pbnQgaW4gYnJvd3NlciByZWxhdGl2ZSB0byB0aGUgY29udGFpbmVyIGRpdilcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX1hjb252ZXJ0Q2FudmFzVG9ET00nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfWGNvbnZlcnRDYW52YXNUb0RPTSh4KSB7XG4gICAgICByZXR1cm4geCAqIHRoaXMuYm9keS52aWV3LnNjYWxlICsgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBZIGNvb3JkaW5hdGUgaW4gRE9NLXNwYWNlIChjb29yZGluYXRlIHBvaW50IGluIGJyb3dzZXIgcmVsYXRpdmUgdG8gdGhlIGNvbnRhaW5lciBkaXYpIHRvXG4gICAgICogdGhlIFkgY29vcmRpbmF0ZSBpbiBjYW52YXMtc3BhY2UgKHRoZSBzaW11bGF0aW9uIHNhbmRib3gsIHdoaWNoIHRoZSBjYW1lcmEgbG9va3MgdXBvbilcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX1ljb252ZXJ0RE9NdG9DYW52YXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfWWNvbnZlcnRET010b0NhbnZhcyh5KSB7XG4gICAgICByZXR1cm4gKHkgLSB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi55KSAvIHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGhlIFkgY29vcmRpbmF0ZSBpbiBjYW52YXMtc3BhY2UgKHRoZSBzaW11bGF0aW9uIHNhbmRib3gsIHdoaWNoIHRoZSBjYW1lcmEgbG9va3MgdXBvbikgdG9cbiAgICAgKiB0aGUgWSBjb29yZGluYXRlIGluIERPTS1zcGFjZSAoY29vcmRpbmF0ZSBwb2ludCBpbiBicm93c2VyIHJlbGF0aXZlIHRvIHRoZSBjb250YWluZXIgZGl2KVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfWWNvbnZlcnRDYW52YXNUb0RPTScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ZY29udmVydENhbnZhc1RvRE9NKHkpIHtcbiAgICAgIHJldHVybiB5ICogdGhpcy5ib2R5LnZpZXcuc2NhbGUgKyB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi55O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7cG9pbnR9IHBvc1xuICAgICAqIEByZXR1cm5zIHtwb2ludH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY2FudmFzVG9ET00nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYW52YXNUb0RPTShwb3MpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHRoaXMuX1hjb252ZXJ0Q2FudmFzVG9ET00ocG9zLngpLFxuICAgICAgICB5OiB0aGlzLl9ZY29udmVydENhbnZhc1RvRE9NKHBvcy55KVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7cG9pbnR9IHBvc1xuICAgICAqIEByZXR1cm5zIHtwb2ludH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnRE9NdG9DYW52YXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBET010b0NhbnZhcyhwb3MpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHRoaXMuX1hjb252ZXJ0RE9NdG9DYW52YXMocG9zLngpLFxuICAgICAgICB5OiB0aGlzLl9ZY29udmVydERPTXRvQ2FudmFzKHBvcy55KVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENhbnZhcztcbn0oKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gQ2FudmFzO1xuXG4vKioqLyB9KSxcbi8qIDE4MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2Fzc2lnbiA9IF9fd2VicGFja19yZXF1aXJlX18oNzgpO1xuXG52YXIgX2Fzc2lnbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hc3NpZ24pO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgTmV0d29ya1V0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3KVsnZGVmYXVsdCddO1xuXG4vKipcbiAqIFRoZSB2aWV3XG4gKi9cblxudmFyIFZpZXcgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0NhbnZhc30gY2FudmFzXG4gICAqL1xuICBmdW5jdGlvbiBWaWV3KGJvZHksIGNhbnZhcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrM1snZGVmYXVsdCddKSh0aGlzLCBWaWV3KTtcblxuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG5cbiAgICB0aGlzLmFuaW1hdGlvblNwZWVkID0gMSAvIHRoaXMucmVuZGVyUmVmcmVzaFJhdGU7XG4gICAgdGhpcy5hbmltYXRpb25FYXNpbmdGdW5jdGlvbiA9ICdlYXNlSW5PdXRRdWludCc7XG4gICAgdGhpcy5lYXNpbmdUaW1lID0gMDtcbiAgICB0aGlzLnNvdXJjZVNjYWxlID0gMDtcbiAgICB0aGlzLnRhcmdldFNjYWxlID0gMDtcbiAgICB0aGlzLnNvdXJjZVRyYW5zbGF0aW9uID0gMDtcbiAgICB0aGlzLnRhcmdldFRyYW5zbGF0aW9uID0gMDtcbiAgICB0aGlzLmxvY2tlZE9uTm9kZUlkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubG9ja2VkT25Ob2RlT2Zmc2V0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudG91Y2hUaW1lID0gMDtcblxuICAgIHRoaXMudmlld0Z1bmN0aW9uID0gdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ2ZpdCcsIHRoaXMuZml0LmJpbmQodGhpcykpO1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdhbmltYXRpb25GaW5pc2hlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfc3RvcFJlbmRlcmluZycpO1xuICAgIH0pO1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCd1bmxvY2tOb2RlJywgdGhpcy5yZWxlYXNlTm9kZS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoVmlldywgW3tcbiAgICBrZXk6ICdzZXRPcHRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucygpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHpvb21zIG91dCB0byBmaXQgYWxsIGRhdGEgb24gc2NyZWVuIGJhc2VkIG9uIGFtb3VudCBvZiBub2Rlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17e25vZGVzPUFycmF5fX1dXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaW5pdGlhbFpvb209ZmFsc2VdICB8IHpvb20gYmFzZWQgb24gZml0dGVkIGZvcm11bGEgb3IgcmFuZ2UsIHRydWUgPSBmaXR0ZWQsIGRlZmF1bHQgPSBmYWxzZTtcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZml0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZml0KCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHsgbm9kZXM6IFtdIH07XG4gICAgICB2YXIgaW5pdGlhbFpvb20gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gICAgICB2YXIgcmFuZ2UgPSB2b2lkIDA7XG4gICAgICB2YXIgem9vbUxldmVsID0gdm9pZCAwO1xuICAgICAgb3B0aW9ucyA9ICgwLCBfYXNzaWduMlsnZGVmYXVsdCddKSh7fSwgb3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5ub2RlcyA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMubm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIG9wdGlvbnMubm9kZXMgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbml0aWFsWm9vbSA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBjaGVjayBpZiBtb3JlIHRoYW4gaGFsZiBvZiB0aGUgbm9kZXMgaGF2ZSBhIHByZWRlZmluZWQgcG9zaXRpb24uIElmIHNvLCB3ZSB1c2UgdGhlIHJhbmdlLCBub3QgdGhlIGFwcHJveGltYXRpb24uXG4gICAgICAgIHZhciBwb3NpdGlvbkRlZmluZWQgPSAwO1xuICAgICAgICBmb3IgKHZhciBub2RlSWQgaW4gdGhpcy5ib2R5Lm5vZGVzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlcy5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgICAgICAgaWYgKG5vZGUucHJlZGVmaW5lZFBvc2l0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHBvc2l0aW9uRGVmaW5lZCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zaXRpb25EZWZpbmVkID4gMC41ICogdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuZml0KG9wdGlvbnMsIGZhbHNlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByYW5nZSA9IE5ldHdvcmtVdGlsLmdldFJhbmdlKHRoaXMuYm9keS5ub2Rlcywgb3B0aW9ucy5ub2Rlcyk7XG5cbiAgICAgICAgdmFyIG51bWJlck9mTm9kZXMgPSB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoO1xuICAgICAgICB6b29tTGV2ZWwgPSAxMi42NjIgLyAobnVtYmVyT2ZOb2RlcyArIDcuNDE0NykgKyAwLjA5NjQ4MjI7IC8vIHRoaXMgaXMgb2J0YWluZWQgZnJvbSBmaXR0aW5nIGEgZGF0YXNldCBmcm9tIDUgcG9pbnRzIHdpdGggc2NhbGUgbGV2ZWxzIHRoYXQgbG9va2VkIGdvb2QuXG5cbiAgICAgICAgLy8gY29ycmVjdCBmb3IgbGFyZ2VyIGNhbnZhc3Nlcy5cbiAgICAgICAgdmFyIGZhY3RvciA9IE1hdGgubWluKHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCAvIDYwMCwgdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodCAvIDYwMCk7XG4gICAgICAgIHpvb21MZXZlbCAqPSBmYWN0b3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfcmVzaXplTm9kZXMnKTtcbiAgICAgICAgcmFuZ2UgPSBOZXR3b3JrVXRpbC5nZXRSYW5nZSh0aGlzLmJvZHkubm9kZXMsIG9wdGlvbnMubm9kZXMpO1xuXG4gICAgICAgIHZhciB4RGlzdGFuY2UgPSBNYXRoLmFicyhyYW5nZS5tYXhYIC0gcmFuZ2UubWluWCkgKiAxLjE7XG4gICAgICAgIHZhciB5RGlzdGFuY2UgPSBNYXRoLmFicyhyYW5nZS5tYXhZIC0gcmFuZ2UubWluWSkgKiAxLjE7XG5cbiAgICAgICAgdmFyIHhab29tTGV2ZWwgPSB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGggLyB4RGlzdGFuY2U7XG4gICAgICAgIHZhciB5Wm9vbUxldmVsID0gdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodCAvIHlEaXN0YW5jZTtcblxuICAgICAgICB6b29tTGV2ZWwgPSB4Wm9vbUxldmVsIDw9IHlab29tTGV2ZWwgPyB4Wm9vbUxldmVsIDogeVpvb21MZXZlbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHpvb21MZXZlbCA+IDEuMCkge1xuICAgICAgICB6b29tTGV2ZWwgPSAxLjA7XG4gICAgICB9IGVsc2UgaWYgKHpvb21MZXZlbCA9PT0gMCkge1xuICAgICAgICB6b29tTGV2ZWwgPSAxLjA7XG4gICAgICB9XG5cbiAgICAgIHZhciBjZW50ZXIgPSBOZXR3b3JrVXRpbC5maW5kQ2VudGVyKHJhbmdlKTtcbiAgICAgIHZhciBhbmltYXRpb25PcHRpb25zID0ge1xuICAgICAgICBwb3NpdGlvbjogY2VudGVyLFxuICAgICAgICBzY2FsZTogem9vbUxldmVsLFxuICAgICAgICBhbmltYXRpb246IG9wdGlvbnMuYW5pbWF0aW9uXG4gICAgICB9O1xuICAgICAgdGhpcy5tb3ZlVG8oYW5pbWF0aW9uT3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLy8gYW5pbWF0aW9uXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXIgYSBub2RlIGluIHZpZXcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbm9kZUlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zXVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdmb2N1cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvY3VzKG5vZGVJZCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgbm9kZVBvc2l0aW9uID0ge1xuICAgICAgICAgIHg6IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdLngsXG4gICAgICAgICAgeTogdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0ueVxuICAgICAgICB9O1xuICAgICAgICBvcHRpb25zLnBvc2l0aW9uID0gbm9kZVBvc2l0aW9uO1xuICAgICAgICBvcHRpb25zLmxvY2tlZE9uTm9kZSA9IG5vZGVJZDtcblxuICAgICAgICB0aGlzLm1vdmVUbyhvcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdOb2RlOiAnICsgbm9kZUlkICsgJyBjYW5ub3QgYmUgZm91bmQuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAgfCAgb3B0aW9ucy5vZmZzZXQgICA9IHt4Om51bWJlciwgeTpudW1iZXJ9ICAgLy8gb2Zmc2V0IGZyb20gdGhlIGNlbnRlciBpbiBET00gcGl4ZWxzXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG9wdGlvbnMuc2NhbGUgICAgPSBudW1iZXIgICAgICAgICAgICAgICAgIC8vIHNjYWxlIHRvIG1vdmUgdG9cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgb3B0aW9ucy5wb3NpdGlvbiA9IHt4Om51bWJlciwgeTpudW1iZXJ9ICAgLy8gcG9zaXRpb24gdG8gbW92ZSB0b1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBvcHRpb25zLmFuaW1hdGlvbiA9IHtkdXJhdGlvbjpudW1iZXIsIGVhc2luZ0Z1bmN0aW9uOlN0cmluZ30gfHwgQm9vbGVhbiAgIC8vIHBvc2l0aW9uIHRvIG1vdmUgdG9cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbW92ZVRvJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZVRvKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5vZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLm9mZnNldCA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMub2Zmc2V0LnggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLm9mZnNldC54ID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLm9mZnNldC55ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5vZmZzZXQueSA9IDA7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5zY2FsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMuc2NhbGUgPSB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnBvc2l0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5wb3NpdGlvbiA9IHRoaXMuZ2V0Vmlld1Bvc2l0aW9uKCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5hbmltYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLmFuaW1hdGlvbiA9IHsgZHVyYXRpb246IDAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmFuaW1hdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgb3B0aW9ucy5hbmltYXRpb24gPSB7IGR1cmF0aW9uOiAwIH07XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5hbmltYXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgb3B0aW9ucy5hbmltYXRpb24gPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmFuaW1hdGlvbi5kdXJhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMuYW5pbWF0aW9uLmR1cmF0aW9uID0gMTAwMDtcbiAgICAgIH0gLy8gZGVmYXVsdCBkdXJhdGlvblxuICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uLmVhc2luZ0Z1bmN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5hbmltYXRpb24uZWFzaW5nRnVuY3Rpb24gPSAnZWFzZUluT3V0UXVhZCc7XG4gICAgICB9IC8vIGRlZmF1bHQgZWFzaW5nIGZ1bmN0aW9uXG5cbiAgICAgIHRoaXMuYW5pbWF0ZVZpZXcob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAgfCAgb3B0aW9ucy5vZmZzZXQgICA9IHt4Om51bWJlciwgeTpudW1iZXJ9ICAgLy8gb2Zmc2V0IGZyb20gdGhlIGNlbnRlciBpbiBET00gcGl4ZWxzXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG9wdGlvbnMudGltZSAgICAgPSBudW1iZXIgICAgICAgICAgICAgICAgIC8vIGFuaW1hdGlvbiB0aW1lIGluIG1pbGxpc2Vjb25kc1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBvcHRpb25zLnNjYWxlICAgID0gbnVtYmVyICAgICAgICAgICAgICAgICAvLyBzY2FsZSB0byBhbmltYXRlIHRvXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG9wdGlvbnMucG9zaXRpb24gPSB7eDpudW1iZXIsIHk6bnVtYmVyfSAgIC8vIHBvc2l0aW9uIHRvIGFuaW1hdGUgdG9cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgb3B0aW9ucy5lYXNpbmdGdW5jdGlvbiA9IFN0cmluZyAgICAgICAgICAgLy8gbGluZWFyLCBlYXNlSW5RdWFkLCBlYXNlT3V0UXVhZCwgZWFzZUluT3V0UXVhZCxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWFzZUluQ3ViaWMsIGVhc2VPdXRDdWJpYywgZWFzZUluT3V0Q3ViaWMsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVhc2VJblF1YXJ0LCBlYXNlT3V0UXVhcnQsIGVhc2VJbk91dFF1YXJ0LFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlYXNlSW5RdWludCwgZWFzZU91dFF1aW50LCBlYXNlSW5PdXRRdWludFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhbmltYXRlVmlldycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFuaW1hdGVWaWV3KG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5hbmltYXRpb25FYXNpbmdGdW5jdGlvbiA9IG9wdGlvbnMuYW5pbWF0aW9uLmVhc2luZ0Z1bmN0aW9uO1xuICAgICAgLy8gcmVsZWFzZSBpZiBzb21ldGhpbmcgZm9jdXNzZWQgb24gdGhlIG5vZGVcbiAgICAgIHRoaXMucmVsZWFzZU5vZGUoKTtcbiAgICAgIGlmIChvcHRpb25zLmxvY2tlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmxvY2tlZE9uTm9kZUlkID0gb3B0aW9ucy5sb2NrZWRPbk5vZGU7XG4gICAgICAgIHRoaXMubG9ja2VkT25Ob2RlT2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIC8vIGZvcmNlZnVsbHkgY29tcGxldGUgdGhlIG9sZCBhbmltYXRpb24gaWYgaXQgd2FzIHN0aWxsIHJ1bm5pbmdcbiAgICAgIGlmICh0aGlzLmVhc2luZ1RpbWUgIT0gMCkge1xuICAgICAgICB0aGlzLl90cmFuc2l0aW9uUmVkcmF3KHRydWUpOyAvLyBieSBzZXR0aW5nIGVhc2luZ3RpbWUgdG8gMSwgd2UgZmluaXNoIHRoZSBhbmltYXRpb24uXG4gICAgICB9XG5cbiAgICAgIHRoaXMuc291cmNlU2NhbGUgPSB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgIHRoaXMuc291cmNlVHJhbnNsYXRpb24gPSB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbjtcbiAgICAgIHRoaXMudGFyZ2V0U2NhbGUgPSBvcHRpb25zLnNjYWxlO1xuXG4gICAgICAvLyBzZXQgdGhlIHNjYWxlIHNvIHRoZSB2aWV3Q2VudGVyIGlzIGJhc2VkIG9uIHRoZSBjb3JyZWN0IHpvb20gbGV2ZWwuIFRoaXMgaXMgb3ZlcnJpZGRlbiBpbiB0aGUgdHJhbnNpdGlvblJlZHJhd1xuICAgICAgLy8gYnV0IGF0IGxlYXN0IHRoZW4gd2UnbGwgaGF2ZSB0aGUgdGFyZ2V0IHRyYW5zaXRpb25cbiAgICAgIHRoaXMuYm9keS52aWV3LnNjYWxlID0gdGhpcy50YXJnZXRTY2FsZTtcbiAgICAgIHZhciB2aWV3Q2VudGVyID0gdGhpcy5jYW52YXMuRE9NdG9DYW52YXMoe1xuICAgICAgICB4OiAwLjUgKiB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGgsXG4gICAgICAgIHk6IDAuNSAqIHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHRcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgZGlzdGFuY2VGcm9tQ2VudGVyID0ge1xuICAgICAgICAvLyBvZmZzZXQgZnJvbSB2aWV3LCBkaXN0YW5jZSB2aWV3IGhhcyB0byBjaGFuZ2UgYnkgdGhlc2UgeCBhbmQgeSB0byBjZW50ZXIgdGhlIG5vZGVcbiAgICAgICAgeDogdmlld0NlbnRlci54IC0gb3B0aW9ucy5wb3NpdGlvbi54LFxuICAgICAgICB5OiB2aWV3Q2VudGVyLnkgLSBvcHRpb25zLnBvc2l0aW9uLnlcbiAgICAgIH07XG4gICAgICB0aGlzLnRhcmdldFRyYW5zbGF0aW9uID0ge1xuICAgICAgICB4OiB0aGlzLnNvdXJjZVRyYW5zbGF0aW9uLnggKyBkaXN0YW5jZUZyb21DZW50ZXIueCAqIHRoaXMudGFyZ2V0U2NhbGUgKyBvcHRpb25zLm9mZnNldC54LFxuICAgICAgICB5OiB0aGlzLnNvdXJjZVRyYW5zbGF0aW9uLnkgKyBkaXN0YW5jZUZyb21DZW50ZXIueSAqIHRoaXMudGFyZ2V0U2NhbGUgKyBvcHRpb25zLm9mZnNldC55XG5cbiAgICAgICAgLy8gaWYgdGhlIHRpbWUgaXMgc2V0IHRvIDAsIGRvbid0IGRvIGFuIGFuaW1hdGlvblxuICAgICAgfTtpZiAob3B0aW9ucy5hbmltYXRpb24uZHVyYXRpb24gPT09IDApIHtcbiAgICAgICAgaWYgKHRoaXMubG9ja2VkT25Ob2RlSWQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy52aWV3RnVuY3Rpb24gPSB0aGlzLl9sb2NrZWRSZWRyYXcuYmluZCh0aGlzKTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignaW5pdFJlZHJhdycsIHRoaXMudmlld0Z1bmN0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmJvZHkudmlldy5zY2FsZSA9IHRoaXMudGFyZ2V0U2NhbGU7XG4gICAgICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24gPSB0aGlzLnRhcmdldFRyYW5zbGF0aW9uO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19yZXF1ZXN0UmVkcmF3Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3BlZWQgPSAxIC8gKDYwICogb3B0aW9ucy5hbmltYXRpb24uZHVyYXRpb24gKiAwLjAwMSkgfHwgMSAvIDYwOyAvLyA2MCBmb3IgNjAgc2Vjb25kcywgMC4wMDEgZm9yIG1pbGxpJ3NcbiAgICAgICAgdGhpcy5hbmltYXRpb25FYXNpbmdGdW5jdGlvbiA9IG9wdGlvbnMuYW5pbWF0aW9uLmVhc2luZ0Z1bmN0aW9uO1xuXG4gICAgICAgIHRoaXMudmlld0Z1bmN0aW9uID0gdGhpcy5fdHJhbnNpdGlvblJlZHJhdy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignaW5pdFJlZHJhdycsIHRoaXMudmlld0Z1bmN0aW9uKTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX3N0YXJ0UmVuZGVyaW5nJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdXNlZCB0byBhbmltYXRlIHNtb290aGx5IGJ5IGhpamFja2luZyB0aGUgcmVkcmF3IGZ1bmN0aW9uLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19sb2NrZWRSZWRyYXcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbG9ja2VkUmVkcmF3KCkge1xuICAgICAgdmFyIG5vZGVQb3NpdGlvbiA9IHtcbiAgICAgICAgeDogdGhpcy5ib2R5Lm5vZGVzW3RoaXMubG9ja2VkT25Ob2RlSWRdLngsXG4gICAgICAgIHk6IHRoaXMuYm9keS5ub2Rlc1t0aGlzLmxvY2tlZE9uTm9kZUlkXS55XG4gICAgICB9O1xuICAgICAgdmFyIHZpZXdDZW50ZXIgPSB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyh7XG4gICAgICAgIHg6IDAuNSAqIHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCxcbiAgICAgICAgeTogMC41ICogdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodFxuICAgICAgfSk7XG4gICAgICB2YXIgZGlzdGFuY2VGcm9tQ2VudGVyID0ge1xuICAgICAgICAvLyBvZmZzZXQgZnJvbSB2aWV3LCBkaXN0YW5jZSB2aWV3IGhhcyB0byBjaGFuZ2UgYnkgdGhlc2UgeCBhbmQgeSB0byBjZW50ZXIgdGhlIG5vZGVcbiAgICAgICAgeDogdmlld0NlbnRlci54IC0gbm9kZVBvc2l0aW9uLngsXG4gICAgICAgIHk6IHZpZXdDZW50ZXIueSAtIG5vZGVQb3NpdGlvbi55XG4gICAgICB9O1xuICAgICAgdmFyIHNvdXJjZVRyYW5zbGF0aW9uID0gdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb247XG4gICAgICB2YXIgdGFyZ2V0VHJhbnNsYXRpb24gPSB7XG4gICAgICAgIHg6IHNvdXJjZVRyYW5zbGF0aW9uLnggKyBkaXN0YW5jZUZyb21DZW50ZXIueCAqIHRoaXMuYm9keS52aWV3LnNjYWxlICsgdGhpcy5sb2NrZWRPbk5vZGVPZmZzZXQueCxcbiAgICAgICAgeTogc291cmNlVHJhbnNsYXRpb24ueSArIGRpc3RhbmNlRnJvbUNlbnRlci55ICogdGhpcy5ib2R5LnZpZXcuc2NhbGUgKyB0aGlzLmxvY2tlZE9uTm9kZU9mZnNldC55XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbiA9IHRhcmdldFRyYW5zbGF0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0cyBzdGF0ZSBvZiBhIGxvY2tlZCBvbiBOb2RlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3JlbGVhc2VOb2RlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVsZWFzZU5vZGUoKSB7XG4gICAgICBpZiAodGhpcy5sb2NrZWRPbk5vZGVJZCAhPT0gdW5kZWZpbmVkICYmIHRoaXMudmlld0Z1bmN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub2ZmKCdpbml0UmVkcmF3JywgdGhpcy52aWV3RnVuY3Rpb24pO1xuICAgICAgICB0aGlzLmxvY2tlZE9uTm9kZUlkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmxvY2tlZE9uTm9kZU9mZnNldCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmaW5pc2hlZD1mYWxzZV1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfdHJhbnNpdGlvblJlZHJhdycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90cmFuc2l0aW9uUmVkcmF3KCkge1xuICAgICAgdmFyIGZpbmlzaGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcblxuICAgICAgdGhpcy5lYXNpbmdUaW1lICs9IHRoaXMuYW5pbWF0aW9uU3BlZWQ7XG4gICAgICB0aGlzLmVhc2luZ1RpbWUgPSBmaW5pc2hlZCA9PT0gdHJ1ZSA/IDEuMCA6IHRoaXMuZWFzaW5nVGltZTtcblxuICAgICAgdmFyIHByb2dyZXNzID0gdXRpbC5lYXNpbmdGdW5jdGlvbnNbdGhpcy5hbmltYXRpb25FYXNpbmdGdW5jdGlvbl0odGhpcy5lYXNpbmdUaW1lKTtcblxuICAgICAgdGhpcy5ib2R5LnZpZXcuc2NhbGUgPSB0aGlzLnNvdXJjZVNjYWxlICsgKHRoaXMudGFyZ2V0U2NhbGUgLSB0aGlzLnNvdXJjZVNjYWxlKSAqIHByb2dyZXNzO1xuICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24gPSB7XG4gICAgICAgIHg6IHRoaXMuc291cmNlVHJhbnNsYXRpb24ueCArICh0aGlzLnRhcmdldFRyYW5zbGF0aW9uLnggLSB0aGlzLnNvdXJjZVRyYW5zbGF0aW9uLngpICogcHJvZ3Jlc3MsXG4gICAgICAgIHk6IHRoaXMuc291cmNlVHJhbnNsYXRpb24ueSArICh0aGlzLnRhcmdldFRyYW5zbGF0aW9uLnkgLSB0aGlzLnNvdXJjZVRyYW5zbGF0aW9uLnkpICogcHJvZ3Jlc3NcblxuICAgICAgICAvLyBjbGVhbnVwXG4gICAgICB9O2lmICh0aGlzLmVhc2luZ1RpbWUgPj0gMS4wKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9mZignaW5pdFJlZHJhdycsIHRoaXMudmlld0Z1bmN0aW9uKTtcbiAgICAgICAgdGhpcy5lYXNpbmdUaW1lID0gMDtcbiAgICAgICAgaWYgKHRoaXMubG9ja2VkT25Ob2RlSWQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy52aWV3RnVuY3Rpb24gPSB0aGlzLl9sb2NrZWRSZWRyYXcuYmluZCh0aGlzKTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignaW5pdFJlZHJhdycsIHRoaXMudmlld0Z1bmN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdhbmltYXRpb25GaW5pc2hlZCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0U2NhbGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTY2FsZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRWaWV3UG9zaXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWaWV3UG9zaXRpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYW52YXMuRE9NdG9DYW52YXMoe1xuICAgICAgICB4OiAwLjUgKiB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGgsXG4gICAgICAgIHk6IDAuNSAqIHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHRcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVmlldztcbn0oKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gVmlldztcblxuLyoqKi8gfSksXG4vKiAxODMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbnZhciBOYXZpZ2F0aW9uSGFuZGxlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTg0KVsnZGVmYXVsdCddO1xudmFyIFBvcHVwID0gX193ZWJwYWNrX3JlcXVpcmVfXygxODUpWydkZWZhdWx0J107XG5cbi8qKlxuICogSGFuZGxlciBmb3IgaW50ZXJhY3Rpb25zXG4gKi9cblxudmFyIEludGVyYWN0aW9uSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7Q2FudmFzfSBjYW52YXNcbiAgICogQHBhcmFtIHtTZWxlY3Rpb25IYW5kbGVyfSBzZWxlY3Rpb25IYW5kbGVyXG4gICAqL1xuICBmdW5jdGlvbiBJbnRlcmFjdGlvbkhhbmRsZXIoYm9keSwgY2FudmFzLCBzZWxlY3Rpb25IYW5kbGVyKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgSW50ZXJhY3Rpb25IYW5kbGVyKTtcblxuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyID0gc2VsZWN0aW9uSGFuZGxlcjtcbiAgICB0aGlzLm5hdmlnYXRpb25IYW5kbGVyID0gbmV3IE5hdmlnYXRpb25IYW5kbGVyKGJvZHksIGNhbnZhcyk7XG5cbiAgICAvLyBiaW5kIHRoZSBldmVudHMgZnJvbSBoYW1tZXIgdG8gZnVuY3Rpb25zIGluIHRoaXMgb2JqZWN0XG4gICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uVGFwID0gdGhpcy5vblRhcC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vblRvdWNoID0gdGhpcy5vblRvdWNoLmJpbmQodGhpcyk7XG4gICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uRG91YmxlVGFwID0gdGhpcy5vbkRvdWJsZVRhcC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vbkhvbGQgPSB0aGlzLm9uSG9sZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vbkRyYWdTdGFydCA9IHRoaXMub25EcmFnU3RhcnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25EcmFnID0gdGhpcy5vbkRyYWcuYmluZCh0aGlzKTtcbiAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25EcmFnRW5kID0gdGhpcy5vbkRyYWdFbmQuYmluZCh0aGlzKTtcbiAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Nb3VzZVdoZWVsID0gdGhpcy5vbk1vdXNlV2hlZWwuYmluZCh0aGlzKTtcbiAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25QaW5jaCA9IHRoaXMub25QaW5jaC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vbk1vdXNlTW92ZSA9IHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25SZWxlYXNlID0gdGhpcy5vblJlbGVhc2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Db250ZXh0ID0gdGhpcy5vbkNvbnRleHQuYmluZCh0aGlzKTtcblxuICAgIHRoaXMudG91Y2hUaW1lID0gMDtcbiAgICB0aGlzLmRyYWcgPSB7fTtcbiAgICB0aGlzLnBpbmNoID0ge307XG4gICAgdGhpcy5wb3B1cCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBvcHVwT2JqID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucG9wdXBUaW1lciA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMuYm9keS5mdW5jdGlvbnMuZ2V0UG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlci5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGRyYWdOb2RlczogdHJ1ZSxcbiAgICAgIGRyYWdWaWV3OiB0cnVlLFxuICAgICAgaG92ZXI6IGZhbHNlLFxuICAgICAga2V5Ym9hcmQ6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIHNwZWVkOiB7IHg6IDEwLCB5OiAxMCwgem9vbTogMC4wMiB9LFxuICAgICAgICBiaW5kVG9XaW5kb3c6IHRydWVcbiAgICAgIH0sXG4gICAgICBuYXZpZ2F0aW9uQnV0dG9uczogZmFsc2UsXG4gICAgICB0b29sdGlwRGVsYXk6IDMwMCxcbiAgICAgIHpvb21WaWV3OiB0cnVlLFxuICAgICAgem9vbVNwZWVkOiAxXG4gICAgfTtcbiAgICB1dGlsLmV4dGVuZCh0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gICAgdGhpcy5iaW5kRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kcyBldmVudCBsaXN0ZW5lcnNcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzM1snZGVmYXVsdCddKShJbnRlcmFjdGlvbkhhbmRsZXIsIFt7XG4gICAga2V5OiAnYmluZEV2ZW50TGlzdGVuZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChfdGhpcy5wb3B1cFRpbWVyKTtcbiAgICAgICAgZGVsZXRlIF90aGlzLmJvZHkuZnVuY3Rpb25zLmdldFBvaW50ZXI7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldE9wdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gZXh0ZW5kIGFsbCBidXQgdGhlIHZhbHVlcyBpbiBmaWVsZHNcbiAgICAgICAgdmFyIGZpZWxkcyA9IFsnaGlkZUVkZ2VzT25EcmFnJywgJ2hpZGVFZGdlc09uWm9vbScsICdoaWRlTm9kZXNPbkRyYWcnLCAna2V5Ym9hcmQnLCAnbXVsdGlzZWxlY3QnLCAnc2VsZWN0YWJsZScsICdzZWxlY3RDb25uZWN0ZWRFZGdlcyddO1xuICAgICAgICB1dGlsLnNlbGVjdGl2ZU5vdERlZXBFeHRlbmQoZmllbGRzLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICAgIC8vIG1lcmdlIHRoZSBrZXlib2FyZCBvcHRpb25zIGluLlxuICAgICAgICB1dGlsLm1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMsICdrZXlib2FyZCcpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnRvb2x0aXApIHtcbiAgICAgICAgICB1dGlsLmV4dGVuZCh0aGlzLm9wdGlvbnMudG9vbHRpcCwgb3B0aW9ucy50b29sdGlwKTtcbiAgICAgICAgICBpZiAob3B0aW9ucy50b29sdGlwLmNvbG9yKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMudG9vbHRpcC5jb2xvciA9IHV0aWwucGFyc2VDb2xvcihvcHRpb25zLnRvb2x0aXAuY29sb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLm5hdmlnYXRpb25IYW5kbGVyLnNldE9wdGlvbnModGhpcy5vcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHBvaW50ZXIgbG9jYXRpb24gZnJvbSBhIHRvdWNoIGxvY2F0aW9uXG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSB0b3VjaFxuICAgICAqIEByZXR1cm4ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvaW50ZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRQb2ludGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9pbnRlcih0b3VjaCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogdG91Y2gueCAtIHV0aWwuZ2V0QWJzb2x1dGVMZWZ0KHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcyksXG4gICAgICAgIHk6IHRvdWNoLnkgLSB1dGlsLmdldEFic29sdXRlVG9wKHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcylcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT24gc3RhcnQgb2YgYSB0b3VjaCBnZXN0dXJlLCBzdG9yZSB0aGUgcG9pbnRlclxuICAgICAqIEBwYXJhbSB7RXZlbnR9ICBldmVudCAgIFRoZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ29uVG91Y2gnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblRvdWNoKGV2ZW50KSB7XG4gICAgICBpZiAobmV3IERhdGUoKS52YWx1ZU9mKCkgLSB0aGlzLnRvdWNoVGltZSA+IDUwKSB7XG4gICAgICAgIHRoaXMuZHJhZy5wb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICAgIHRoaXMuZHJhZy5waW5jaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGluY2guc2NhbGUgPSB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgICAgLy8gdG8gYXZvaWQgZG91YmxlIGZpcmVpbmcgb2YgdGhpcyBldmVudCBiZWNhdXNlIHdlIGhhdmUgdHdvIGhhbW1lciBpbnN0YW5jZXMuIChvbiBjYW52YXMgYW5kIG9uIGZyYW1lKVxuICAgICAgICB0aGlzLnRvdWNoVGltZSA9IG5ldyBEYXRlKCkudmFsdWVPZigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGhhbmRsZSB0YXAvY2xpY2sgZXZlbnQ6IHNlbGVjdC91bnNlbGVjdCBhIG5vZGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ29uVGFwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25UYXAoZXZlbnQpIHtcbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICB2YXIgbXVsdGlzZWxlY3QgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIub3B0aW9ucy5tdWx0aXNlbGVjdCAmJiAoZXZlbnQuY2hhbmdlZFBvaW50ZXJzWzBdLmN0cmxLZXkgfHwgZXZlbnQuY2hhbmdlZFBvaW50ZXJzWzBdLm1ldGFLZXkpO1xuXG4gICAgICB0aGlzLmNoZWNrU2VsZWN0aW9uQ2hhbmdlcyhwb2ludGVyLCBldmVudCwgbXVsdGlzZWxlY3QpO1xuICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZW5lcmF0ZUNsaWNrRXZlbnQoJ2NsaWNrJywgZXZlbnQsIHBvaW50ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGhhbmRsZSBkb3VibGV0YXAgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ29uRG91YmxlVGFwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Eb3VibGVUYXAoZXZlbnQpIHtcbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dlbmVyYXRlQ2xpY2tFdmVudCgnZG91YmxlQ2xpY2snLCBldmVudCwgcG9pbnRlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaGFuZGxlIGxvbmcgdGFwIGV2ZW50OiBtdWx0aSBzZWxlY3Qgbm9kZXNcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ29uSG9sZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uSG9sZChldmVudCkge1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcbiAgICAgIHZhciBtdWx0aXNlbGVjdCA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5vcHRpb25zLm11bHRpc2VsZWN0O1xuXG4gICAgICB0aGlzLmNoZWNrU2VsZWN0aW9uQ2hhbmdlcyhwb2ludGVyLCBldmVudCwgbXVsdGlzZWxlY3QpO1xuXG4gICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dlbmVyYXRlQ2xpY2tFdmVudCgnY2xpY2snLCBldmVudCwgcG9pbnRlcik7XG4gICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dlbmVyYXRlQ2xpY2tFdmVudCgnaG9sZCcsIGV2ZW50LCBwb2ludGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBoYW5kbGUgdGhlIHJlbGVhc2Ugb2YgdGhlIHNjcmVlblxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdvblJlbGVhc2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblJlbGVhc2UoZXZlbnQpIHtcbiAgICAgIGlmIChuZXcgRGF0ZSgpLnZhbHVlT2YoKSAtIHRoaXMudG91Y2hUaW1lID4gMTApIHtcbiAgICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZW5lcmF0ZUNsaWNrRXZlbnQoJ3JlbGVhc2UnLCBldmVudCwgcG9pbnRlcik7XG4gICAgICAgIC8vIHRvIGF2b2lkIGRvdWJsZSBmaXJlaW5nIG9mIHRoaXMgZXZlbnQgYmVjYXVzZSB3ZSBoYXZlIHR3byBoYW1tZXIgaW5zdGFuY2VzLiAob24gY2FudmFzIGFuZCBvbiBmcmFtZSlcbiAgICAgICAgdGhpcy50b3VjaFRpbWUgPSBuZXcgRGF0ZSgpLnZhbHVlT2YoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ29uQ29udGV4dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQ29udGV4dChldmVudCkge1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoeyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZIH0pO1xuICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZW5lcmF0ZUNsaWNrRXZlbnQoJ29uY29udGV4dCcsIGV2ZW50LCBwb2ludGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3QgYW5kIGRlc2VsZWN0IG5vZGVzIGRlcGVuZGluZyBjdXJyZW50IHNlbGVjdGlvbiBjaGFuZ2UuXG4gICAgICpcbiAgICAgKiBGb3IgY2hhbmdpbmcgbm9kZXMsIHNlbGVjdC9kZXNlbGVjdCBldmVudHMgYXJlIGZpcmVkLlxuICAgICAqXG4gICAgICogTk9URTogRm9yIGEgZ2l2ZW4gZWRnZSwgaWYgb25lIGNvbm5lY3Rpbmcgbm9kZSBpcyBkZXNlbGVjdGVkIGFuZCB3aXRoIHRoZSBzYW1lXG4gICAgICogICAgICAgY2xpY2sgdGhlIG90aGVyIG5vZGUgaXMgc2VsZWN0ZWQsIG5vIGV2ZW50cyBmb3IgdGhlIGVkZ2Ugd2lsbCBmaXJlLlxuICAgICAqICAgICAgIEl0IHdhcyBzZWxlY3RlZCBhbmQgaXQgd2lsbCByZW1haW4gc2VsZWN0ZWQuXG4gICAgICpcbiAgICAgKiBUT0RPOiBUaGlzIGlzIGFsbCBTZWxlY3Rpb25IYW5kbGVyIGNhbGxzOyB0aGUgbWV0aG9kIHNob3VsZCBiZSBtb3ZlZCB0byB0aGVyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gcG9pbnRlclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbYWRkPWZhbHNlXVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdjaGVja1NlbGVjdGlvbkNoYW5nZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja1NlbGVjdGlvbkNoYW5nZXMocG9pbnRlciwgZXZlbnQpIHtcbiAgICAgIHZhciBhZGQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gICAgICB2YXIgcHJldmlvdXNTZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIGlmIChhZGQgPT09IHRydWUpIHtcbiAgICAgICAgc2VsZWN0ZWQgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuc2VsZWN0QWRkaXRpb25hbE9uUG9pbnQocG9pbnRlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxlY3RlZCA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5zZWxlY3RPblBvaW50KHBvaW50ZXIpO1xuICAgICAgfVxuICAgICAgdmFyIGN1cnJlbnRTZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgIC8vIFNlZSBOT1RFIGluIG1ldGhvZCBjb21tZW50IGZvciB0aGUgcmVhc29uIHRvIGRvIGl0IGxpa2UgdGhpc1xuICAgICAgdmFyIGRlc2VsZWN0ZWRJdGVtcyA9IHRoaXMuX2RldGVybWluZURpZmZlcmVuY2UocHJldmlvdXNTZWxlY3Rpb24sIGN1cnJlbnRTZWxlY3Rpb24pO1xuICAgICAgdmFyIHNlbGVjdGVkSXRlbXMgPSB0aGlzLl9kZXRlcm1pbmVEaWZmZXJlbmNlKGN1cnJlbnRTZWxlY3Rpb24sIHByZXZpb3VzU2VsZWN0aW9uKTtcblxuICAgICAgaWYgKGRlc2VsZWN0ZWRJdGVtcy5lZGdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2VuZXJhdGVDbGlja0V2ZW50KCdkZXNlbGVjdEVkZ2UnLCBldmVudCwgcG9pbnRlciwgcHJldmlvdXNTZWxlY3Rpb24pO1xuICAgICAgICBzZWxlY3RlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChkZXNlbGVjdGVkSXRlbXMubm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dlbmVyYXRlQ2xpY2tFdmVudCgnZGVzZWxlY3ROb2RlJywgZXZlbnQsIHBvaW50ZXIsIHByZXZpb3VzU2VsZWN0aW9uKTtcbiAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZWN0ZWRJdGVtcy5ub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2VuZXJhdGVDbGlja0V2ZW50KCdzZWxlY3ROb2RlJywgZXZlbnQsIHBvaW50ZXIpO1xuICAgICAgICBzZWxlY3RlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxlY3RlZEl0ZW1zLmVkZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZW5lcmF0ZUNsaWNrRXZlbnQoJ3NlbGVjdEVkZ2UnLCBldmVudCwgcG9pbnRlcik7XG4gICAgICAgIHNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gZmlyZSB0aGUgc2VsZWN0IGV2ZW50IGlmIGFueXRoaW5nIGhhcyBiZWVuIHNlbGVjdGVkIG9yIGRlc2VsZWN0ZWRcbiAgICAgIGlmIChzZWxlY3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBzZWxlY3Qgb3IgdW5zZWxlY3RcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZW5lcmF0ZUNsaWNrRXZlbnQoJ3NlbGVjdCcsIGV2ZW50LCBwb2ludGVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIG5vZGUgYW5kIGVkZ2UgaWQncyBmcm9tIHRoZSBmaXJzdCBzZXQgdGhhdCBhcmUgcHJlc2VudCBpbiB0aGUgc2Vjb25kIG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e25vZGVzOiBBcnJheS48Tm9kZT4sIGVkZ2VzOiBBcnJheS48dmlzLkVkZ2U+fX0gZmlyc3RTZXRcbiAgICAgKiBAcGFyYW0ge3tub2RlczogQXJyYXkuPE5vZGU+LCBlZGdlczogQXJyYXkuPHZpcy5FZGdlPn19IHNlY29uZFNldFxuICAgICAqIEByZXR1cm5zIHt7bm9kZXM6IEFycmF5LjxOb2RlPiwgZWRnZXM6IEFycmF5Ljx2aXMuRWRnZT59fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19kZXRlcm1pbmVEaWZmZXJlbmNlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RldGVybWluZURpZmZlcmVuY2UoZmlyc3RTZXQsIHNlY29uZFNldCkge1xuICAgICAgdmFyIGFycmF5RGlmZiA9IGZ1bmN0aW9uIGFycmF5RGlmZihmaXJzdEFyciwgc2Vjb25kQXJyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpcnN0QXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gZmlyc3RBcnJbaV07XG4gICAgICAgICAgaWYgKHNlY29uZEFyci5pbmRleE9mKHZhbHVlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZXM6IGFycmF5RGlmZihmaXJzdFNldC5ub2Rlcywgc2Vjb25kU2V0Lm5vZGVzKSxcbiAgICAgICAgZWRnZXM6IGFycmF5RGlmZihmaXJzdFNldC5lZGdlcywgc2Vjb25kU2V0LmVkZ2VzKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBieSBvbkRyYWdTdGFydC5cbiAgICAgKiBJdCBpcyBzZXBhcmF0ZWQgb3V0IGJlY2F1c2Ugd2UgY2FuIHRoZW4gb3ZlcmxvYWQgaXQgZm9yIHRoZSBkYXRhbWFuaXB1bGF0aW9uIHN5c3RlbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnb25EcmFnU3RhcnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkRyYWdTdGFydChldmVudCkge1xuICAgICAgLy9pbiBjYXNlIHRoZSB0b3VjaCBldmVudCB3YXMgdHJpZ2dlcmVkIG9uIGFuIGV4dGVybmFsIGRpdiwgZG8gdGhlIGluaXRpYWwgdG91Y2ggbm93LlxuICAgICAgaWYgKHRoaXMuZHJhZy5wb2ludGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5vblRvdWNoKGV2ZW50KTtcbiAgICAgIH1cblxuICAgICAgLy8gbm90ZTogZHJhZy5wb2ludGVyIGlzIHNldCBpbiBvblRvdWNoIHRvIGdldCB0aGUgaW5pdGlhbCB0b3VjaCBsb2NhdGlvblxuICAgICAgdmFyIG5vZGUgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0Tm9kZUF0KHRoaXMuZHJhZy5wb2ludGVyKTtcblxuICAgICAgdGhpcy5kcmFnLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuZHJhZy5zZWxlY3Rpb24gPSBbXTtcbiAgICAgIHRoaXMuZHJhZy50cmFuc2xhdGlvbiA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbik7IC8vIGNvcHkgdGhlIG9iamVjdFxuICAgICAgdGhpcy5kcmFnLm5vZGVJZCA9IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLm9wdGlvbnMuZHJhZ05vZGVzID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuZHJhZy5ub2RlSWQgPSBub2RlLmlkO1xuICAgICAgICAvLyBzZWxlY3QgdGhlIGNsaWNrZWQgbm9kZSBpZiBub3QgeWV0IHNlbGVjdGVkXG4gICAgICAgIGlmIChub2RlLmlzU2VsZWN0ZWQoKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIudW5zZWxlY3RBbGwoKTtcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuc2VsZWN0T2JqZWN0KG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWZ0ZXIgc2VsZWN0IHRvIGNvbnRhaW4gdGhlIG5vZGVcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZW5lcmF0ZUNsaWNrRXZlbnQoJ2RyYWdTdGFydCcsIGV2ZW50LCB0aGlzLmRyYWcucG9pbnRlcik7XG5cbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5zZWxlY3Rpb25PYmoubm9kZXM7XG4gICAgICAgIC8vIGNyZWF0ZSBhbiBhcnJheSB3aXRoIHRoZSBzZWxlY3RlZCBub2RlcyBhbmQgdGhlaXIgb3JpZ2luYWwgbG9jYXRpb24gYW5kIHN0YXR1c1xuICAgICAgICBmb3IgKHZhciBub2RlSWQgaW4gc2VsZWN0aW9uKSB7XG4gICAgICAgICAgaWYgKHNlbGVjdGlvbi5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0gc2VsZWN0aW9uW25vZGVJZF07XG4gICAgICAgICAgICB2YXIgcyA9IHtcbiAgICAgICAgICAgICAgaWQ6IG9iamVjdC5pZCxcbiAgICAgICAgICAgICAgbm9kZTogb2JqZWN0LFxuXG4gICAgICAgICAgICAgIC8vIHN0b3JlIG9yaWdpbmFsIHgsIHksIHhGaXhlZCBhbmQgeUZpeGVkLCBtYWtlIHRoZSBub2RlIHRlbXBvcmFyaWx5IEZpeGVkXG4gICAgICAgICAgICAgIHg6IG9iamVjdC54LFxuICAgICAgICAgICAgICB5OiBvYmplY3QueSxcbiAgICAgICAgICAgICAgeEZpeGVkOiBvYmplY3Qub3B0aW9ucy5maXhlZC54LFxuICAgICAgICAgICAgICB5Rml4ZWQ6IG9iamVjdC5vcHRpb25zLmZpeGVkLnlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG9iamVjdC5vcHRpb25zLmZpeGVkLnggPSB0cnVlO1xuICAgICAgICAgICAgb2JqZWN0Lm9wdGlvbnMuZml4ZWQueSA9IHRydWU7XG5cbiAgICAgICAgICAgIHRoaXMuZHJhZy5zZWxlY3Rpb24ucHVzaChzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGZhbGxiYWNrIGlmIG5vIG5vZGUgaXMgc2VsZWN0ZWQgYW5kIHRodXMgdGhlIHZpZXcgaXMgZHJhZ2dlZC5cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZW5lcmF0ZUNsaWNrRXZlbnQoJ2RyYWdTdGFydCcsIGV2ZW50LCB0aGlzLmRyYWcucG9pbnRlciwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBoYW5kbGUgZHJhZyBldmVudFxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnb25EcmFnJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25EcmFnKGV2ZW50KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuZHJhZy5waW5jaGVkID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gcmVtb3ZlIHRoZSBmb2N1cyBvbiBub2RlIGlmIGl0IGlzIGZvY3Vzc2VkIG9uIGJ5IHRoZSBmb2N1c09uTm9kZVxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgndW5sb2NrTm9kZScpO1xuXG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuXG4gICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5kcmFnLnNlbGVjdGlvbjtcbiAgICAgIGlmIChzZWxlY3Rpb24gJiYgc2VsZWN0aW9uLmxlbmd0aCAmJiB0aGlzLm9wdGlvbnMuZHJhZ05vZGVzID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2VuZXJhdGVDbGlja0V2ZW50KCdkcmFnZ2luZycsIGV2ZW50LCBwb2ludGVyKTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgZGVsdGEncyBhbmQgbmV3IGxvY2F0aW9uXG4gICAgICAgIHZhciBkZWx0YVggPSBwb2ludGVyLnggLSB0aGlzLmRyYWcucG9pbnRlci54O1xuICAgICAgICB2YXIgZGVsdGFZID0gcG9pbnRlci55IC0gdGhpcy5kcmFnLnBvaW50ZXIueTtcblxuICAgICAgICAvLyB1cGRhdGUgcG9zaXRpb24gb2YgYWxsIHNlbGVjdGVkIG5vZGVzXG4gICAgICAgIHNlbGVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IHNlbGVjdGlvbi5ub2RlO1xuICAgICAgICAgIC8vIG9ubHkgbW92ZSB0aGUgbm9kZSBpZiBpdCB3YXMgbm90IGZpeGVkIGluaXRpYWxseVxuICAgICAgICAgIGlmIChzZWxlY3Rpb24ueEZpeGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgbm9kZS54ID0gX3RoaXMyLmNhbnZhcy5fWGNvbnZlcnRET010b0NhbnZhcyhfdGhpczIuY2FudmFzLl9YY29udmVydENhbnZhc1RvRE9NKHNlbGVjdGlvbi54KSArIGRlbHRhWCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIG9ubHkgbW92ZSB0aGUgbm9kZSBpZiBpdCB3YXMgbm90IGZpeGVkIGluaXRpYWxseVxuICAgICAgICAgIGlmIChzZWxlY3Rpb24ueUZpeGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgbm9kZS55ID0gX3RoaXMyLmNhbnZhcy5fWWNvbnZlcnRET010b0NhbnZhcyhfdGhpczIuY2FudmFzLl9ZY29udmVydENhbnZhc1RvRE9NKHNlbGVjdGlvbi55KSArIGRlbHRhWSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBzdGFydCB0aGUgc2ltdWxhdGlvbiBvZiB0aGUgcGh5c2ljc1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdzdGFydFNpbXVsYXRpb24nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG1vdmUgdGhlIG5ldHdvcmtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kcmFnVmlldyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2VuZXJhdGVDbGlja0V2ZW50KCdkcmFnZ2luZycsIGV2ZW50LCBwb2ludGVyLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgICAgICAgLy8gaWYgdGhlIGRyYWcgd2FzIG5vdCBzdGFydGVkIHByb3Blcmx5IGJlY2F1c2UgdGhlIGNsaWNrIHN0YXJ0ZWQgb3V0c2lkZSB0aGUgbmV0d29yayBkaXYsIHN0YXJ0IGl0IG5vdy5cbiAgICAgICAgICBpZiAodGhpcy5kcmFnLnBvaW50ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5vbkRyYWdTdGFydChldmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBkaWZmWCA9IHBvaW50ZXIueCAtIHRoaXMuZHJhZy5wb2ludGVyLng7XG4gICAgICAgICAgdmFyIGRpZmZZID0gcG9pbnRlci55IC0gdGhpcy5kcmFnLnBvaW50ZXIueTtcblxuICAgICAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uID0ge1xuICAgICAgICAgICAgeDogdGhpcy5kcmFnLnRyYW5zbGF0aW9uLnggKyBkaWZmWCxcbiAgICAgICAgICAgIHk6IHRoaXMuZHJhZy50cmFuc2xhdGlvbi55ICsgZGlmZllcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19yZXF1ZXN0UmVkcmF3Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBoYW5kbGUgZHJhZyBzdGFydCBldmVudFxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnb25EcmFnRW5kJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25EcmFnRW5kKGV2ZW50KSB7XG4gICAgICB0aGlzLmRyYWcuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLmRyYWcuc2VsZWN0aW9uO1xuICAgICAgaWYgKHNlbGVjdGlvbiAmJiBzZWxlY3Rpb24ubGVuZ3RoKSB7XG4gICAgICAgIHNlbGVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgLy8gcmVzdG9yZSBvcmlnaW5hbCB4Rml4ZWQgYW5kIHlGaXhlZFxuICAgICAgICAgIHMubm9kZS5vcHRpb25zLmZpeGVkLnggPSBzLnhGaXhlZDtcbiAgICAgICAgICBzLm5vZGUub3B0aW9ucy5maXhlZC55ID0gcy55Rml4ZWQ7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dlbmVyYXRlQ2xpY2tFdmVudCgnZHJhZ0VuZCcsIGV2ZW50LCB0aGlzLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKSk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3N0YXJ0U2ltdWxhdGlvbicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZW5lcmF0ZUNsaWNrRXZlbnQoJ2RyYWdFbmQnLCBldmVudCwgdGhpcy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlciksIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19yZXF1ZXN0UmVkcmF3Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIHBpbmNoIGV2ZW50XG4gICAgICogQHBhcmFtIHtFdmVudH0gIGV2ZW50ICAgVGhlIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnb25QaW5jaCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uUGluY2goZXZlbnQpIHtcbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG5cbiAgICAgIHRoaXMuZHJhZy5waW5jaGVkID0gdHJ1ZTtcbiAgICAgIGlmICh0aGlzLnBpbmNoWydzY2FsZSddID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5waW5jaC5zY2FsZSA9IDE7XG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE86IGVuYWJsZWQgbW92aW5nIHdoaWxlIHBpbmNoaW5nP1xuICAgICAgdmFyIHNjYWxlID0gdGhpcy5waW5jaC5zY2FsZSAqIGV2ZW50LnNjYWxlO1xuICAgICAgdGhpcy56b29tKHNjYWxlLCBwb2ludGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBab29tIHRoZSBuZXR3b3JrIGluIG9yIG91dFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZSBhIG51bWJlciBhcm91bmQgMSwgYW5kIGJldHdlZW4gMC4wMSBhbmQgMTBcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvaW50ZXIgICAgUG9zaXRpb24gb24gc2NyZWVuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnem9vbScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHpvb20oc2NhbGUsIHBvaW50ZXIpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuem9vbVZpZXcgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIHNjYWxlT2xkID0gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICAgIGlmIChzY2FsZSA8IDAuMDAwMDEpIHtcbiAgICAgICAgICBzY2FsZSA9IDAuMDAwMDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjYWxlID4gMTApIHtcbiAgICAgICAgICBzY2FsZSA9IDEwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByZVNjYWxlRHJhZ1BvaW50ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0aGlzLmRyYWcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICh0aGlzLmRyYWcuZHJhZ2dpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHByZVNjYWxlRHJhZ1BvaW50ZXIgPSB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyh0aGlzLmRyYWcucG9pbnRlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vICsgdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodCAvIDJcbiAgICAgICAgdmFyIHRyYW5zbGF0aW9uID0gdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb247XG5cbiAgICAgICAgdmFyIHNjYWxlRnJhYyA9IHNjYWxlIC8gc2NhbGVPbGQ7XG4gICAgICAgIHZhciB0eCA9ICgxIC0gc2NhbGVGcmFjKSAqIHBvaW50ZXIueCArIHRyYW5zbGF0aW9uLnggKiBzY2FsZUZyYWM7XG4gICAgICAgIHZhciB0eSA9ICgxIC0gc2NhbGVGcmFjKSAqIHBvaW50ZXIueSArIHRyYW5zbGF0aW9uLnkgKiBzY2FsZUZyYWM7XG5cbiAgICAgICAgdGhpcy5ib2R5LnZpZXcuc2NhbGUgPSBzY2FsZTtcbiAgICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24gPSB7IHg6IHR4LCB5OiB0eSB9O1xuXG4gICAgICAgIGlmIChwcmVTY2FsZURyYWdQb2ludGVyICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBwb3N0U2NhbGVEcmFnUG9pbnRlciA9IHRoaXMuY2FudmFzLmNhbnZhc1RvRE9NKHByZVNjYWxlRHJhZ1BvaW50ZXIpO1xuICAgICAgICAgIHRoaXMuZHJhZy5wb2ludGVyLnggPSBwb3N0U2NhbGVEcmFnUG9pbnRlci54O1xuICAgICAgICAgIHRoaXMuZHJhZy5wb2ludGVyLnkgPSBwb3N0U2NhbGVEcmFnUG9pbnRlci55O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX3JlcXVlc3RSZWRyYXcnKTtcblxuICAgICAgICBpZiAoc2NhbGVPbGQgPCBzY2FsZSkge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3pvb20nLCB7XG4gICAgICAgICAgICBkaXJlY3Rpb246ICcrJyxcbiAgICAgICAgICAgIHNjYWxlOiB0aGlzLmJvZHkudmlldy5zY2FsZSxcbiAgICAgICAgICAgIHBvaW50ZXI6IHBvaW50ZXJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCd6b29tJywge1xuICAgICAgICAgICAgZGlyZWN0aW9uOiAnLScsXG4gICAgICAgICAgICBzY2FsZTogdGhpcy5ib2R5LnZpZXcuc2NhbGUsXG4gICAgICAgICAgICBwb2ludGVyOiBwb2ludGVyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBoYW5kbGVyIGZvciBtb3VzZSB3aGVlbCBldmVudCwgdXNlZCB0byB6b29tIHRoZSB0aW1lbGluZVxuICAgICAqIFNlZSBodHRwOi8vYWRvbWFzLm9yZy9qYXZhc2NyaXB0LW1vdXNlLXdoZWVsL1xuICAgICAqICAgICBodHRwczovL2dpdGh1Yi5jb20vRWlnaHRNZWRpYS9oYW1tZXIuanMvaXNzdWVzLzI1NlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnb25Nb3VzZVdoZWVsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Nb3VzZVdoZWVsKGV2ZW50KSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnpvb21WaWV3ID09PSB0cnVlKSB7XG4gICAgICAgIC8vIHJldHJpZXZlIGRlbHRhXG4gICAgICAgIHZhciBkZWx0YSA9IDA7XG4gICAgICAgIGlmIChldmVudC53aGVlbERlbHRhKSB7XG4gICAgICAgICAgLyogSUUvT3BlcmEuICovXG4gICAgICAgICAgZGVsdGEgPSBldmVudC53aGVlbERlbHRhIC8gMTIwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmRldGFpbCkge1xuICAgICAgICAgIC8qIE1vemlsbGEgY2FzZS4gKi9cbiAgICAgICAgICAvLyBJbiBNb3ppbGxhLCBzaWduIG9mIGRlbHRhIGlzIGRpZmZlcmVudCB0aGFuIGluIElFLlxuICAgICAgICAgIC8vIEFsc28sIGRlbHRhIGlzIG11bHRpcGxlIG9mIDMuXG4gICAgICAgICAgZGVsdGEgPSAtZXZlbnQuZGV0YWlsIC8gMztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGRlbHRhIGlzIG5vbnplcm8sIGhhbmRsZSBpdC5cbiAgICAgICAgLy8gQmFzaWNhbGx5LCBkZWx0YSBpcyBub3cgcG9zaXRpdmUgaWYgd2hlZWwgd2FzIHNjcm9sbGVkIHVwLFxuICAgICAgICAvLyBhbmQgbmVnYXRpdmUsIGlmIHdoZWVsIHdhcyBzY3JvbGxlZCBkb3duLlxuICAgICAgICBpZiAoZGVsdGEgIT09IDApIHtcbiAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIG5ldyBzY2FsZVxuICAgICAgICAgIHZhciBzY2FsZSA9IHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgICAgIHZhciB6b29tID0gZGVsdGEgKiAodGhpcy5vcHRpb25zLnpvb21TcGVlZCAvIDEwKTtcbiAgICAgICAgICBpZiAoZGVsdGEgPCAwKSB7XG4gICAgICAgICAgICB6b29tID0gem9vbSAvICgxIC0gem9vbSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNjYWxlICo9IDEgKyB6b29tO1xuXG4gICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBwb2ludGVyIGxvY2F0aW9uXG4gICAgICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoeyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZIH0pO1xuXG4gICAgICAgICAgLy8gYXBwbHkgdGhlIG5ldyBzY2FsZVxuICAgICAgICAgIHRoaXMuem9vbShzY2FsZSwgcG9pbnRlcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQcmV2ZW50IGRlZmF1bHQgYWN0aW9ucyBjYXVzZWQgYnkgbW91c2Ugd2hlZWwuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW91c2UgbW92ZSBoYW5kbGVyIGZvciBjaGVja2luZyB3aGV0aGVyIHRoZSB0aXRsZSBtb3ZlcyBvdmVyIGEgbm9kZSB3aXRoIGEgdGl0bGUuXG4gICAgICogQHBhcmFtICB7RXZlbnR9IGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnb25Nb3VzZU1vdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1vdXNlTW92ZShldmVudCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSB9KTtcbiAgICAgIHZhciBwb3B1cFZpc2libGUgPSBmYWxzZTtcblxuICAgICAgLy8gY2hlY2sgaWYgdGhlIHByZXZpb3VzbHkgc2VsZWN0ZWQgbm9kZSBpcyBzdGlsbCBzZWxlY3RlZFxuICAgICAgaWYgKHRoaXMucG9wdXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodGhpcy5wb3B1cC5oaWRkZW4gPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhpcy5fY2hlY2tIaWRlUG9wdXAocG9pbnRlcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGUgcG9wdXAgd2FzIG5vdCBoaWRkZW4gYWJvdmVcbiAgICAgICAgaWYgKHRoaXMucG9wdXAuaGlkZGVuID09PSBmYWxzZSkge1xuICAgICAgICAgIHBvcHVwVmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5wb3B1cC5zZXRQb3NpdGlvbihwb2ludGVyLnggKyAzLCBwb2ludGVyLnkgLSA1KTtcbiAgICAgICAgICB0aGlzLnBvcHVwLnNob3coKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBpZiB3ZSBiaW5kIHRoZSBrZXlib2FyZCB0byB0aGUgZGl2LCB3ZSBoYXZlIHRvIGhpZ2hsaWdodCBpdCB0byB1c2UgaXQuIFRoaXMgaGlnaGxpZ2h0cyBpdCBvbiBtb3VzZSBvdmVyLlxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5rZXlib2FyZC5iaW5kVG9XaW5kb3cgPT09IGZhbHNlICYmIHRoaXMub3B0aW9ucy5rZXlib2FyZC5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLmZyYW1lLmZvY3VzKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHN0YXJ0IGEgdGltZW91dCB0aGF0IHdpbGwgY2hlY2sgaWYgdGhlIG1vdXNlIGlzIHBvc2l0aW9uZWQgYWJvdmUgYW4gZWxlbWVudFxuICAgICAgaWYgKHBvcHVwVmlzaWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMucG9wdXBUaW1lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnBvcHVwVGltZXIpOyAvLyBzdG9wIGFueSBydW5uaW5nIGNhbGN1bGF0aW9uVGltZXJcbiAgICAgICAgICB0aGlzLnBvcHVwVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmRyYWcuZHJhZ2dpbmcpIHtcbiAgICAgICAgICB0aGlzLnBvcHVwVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczMuX2NoZWNrU2hvd1BvcHVwKHBvaW50ZXIpO1xuICAgICAgICAgIH0sIHRoaXMub3B0aW9ucy50b29sdGlwRGVsYXkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGFkZGluZyBob3ZlciBoaWdobGlnaHRzXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhvdmVyID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5ob3Zlck9iamVjdChldmVudCwgcG9pbnRlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlcmUgaXMgYW4gZWxlbWVudCBvbiB0aGUgZ2l2ZW4gcG9zaXRpb24gaW4gdGhlIG5ldHdvcmtcbiAgICAgKiAoYSBub2RlIG9yIGVkZ2UpLiBJZiBzbywgYW5kIGlmIHRoaXMgZWxlbWVudCBoYXMgYSB0aXRsZSxcbiAgICAgKiBzaG93IGEgcG9wdXAgd2luZG93IHdpdGggaXRzIHRpdGxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHt7eDpudW1iZXIsIHk6bnVtYmVyfX0gcG9pbnRlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19jaGVja1Nob3dQb3B1cCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jaGVja1Nob3dQb3B1cChwb2ludGVyKSB7XG4gICAgICB2YXIgeCA9IHRoaXMuY2FudmFzLl9YY29udmVydERPTXRvQ2FudmFzKHBvaW50ZXIueCk7XG4gICAgICB2YXIgeSA9IHRoaXMuY2FudmFzLl9ZY29udmVydERPTXRvQ2FudmFzKHBvaW50ZXIueSk7XG4gICAgICB2YXIgcG9pbnRlck9iaiA9IHtcbiAgICAgICAgbGVmdDogeCxcbiAgICAgICAgdG9wOiB5LFxuICAgICAgICByaWdodDogeCxcbiAgICAgICAgYm90dG9tOiB5XG4gICAgICB9O1xuXG4gICAgICB2YXIgcHJldmlvdXNQb3B1cE9iaklkID0gdGhpcy5wb3B1cE9iaiA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogdGhpcy5wb3B1cE9iai5pZDtcbiAgICAgIHZhciBub2RlVW5kZXJDdXJzb3IgPSBmYWxzZTtcbiAgICAgIHZhciBwb3B1cFR5cGUgPSAnbm9kZSc7XG5cbiAgICAgIC8vIGNoZWNrIGlmIGEgbm9kZSBpcyB1bmRlciB0aGUgY3Vyc29yLlxuICAgICAgaWYgKHRoaXMucG9wdXBPYmogPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBzZWFyY2ggdGhlIG5vZGVzIGZvciBvdmVybGFwLCBzZWxlY3QgdGhlIHRvcCBvbmUgaW4gY2FzZSBvZiBtdWx0aXBsZSBub2Rlc1xuICAgICAgICB2YXIgbm9kZUluZGljZXMgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7XG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgICAgdmFyIG5vZGUgPSB2b2lkIDA7XG4gICAgICAgIHZhciBvdmVybGFwcGluZ05vZGVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBub2RlID0gbm9kZXNbbm9kZUluZGljZXNbaV1dO1xuICAgICAgICAgIGlmIChub2RlLmlzT3ZlcmxhcHBpbmdXaXRoKHBvaW50ZXJPYmopID09PSB0cnVlKSB7XG4gICAgICAgICAgICBub2RlVW5kZXJDdXJzb3IgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKG5vZGUuZ2V0VGl0bGUoKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIG92ZXJsYXBwaW5nTm9kZXMucHVzaChub2RlSW5kaWNlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG92ZXJsYXBwaW5nTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBvdmVybGFwcGluZyBub2Rlcywgc2VsZWN0IHRoZSBsYXN0IG9uZSwgdGhpcyBpcyB0aGUgb25lIHdoaWNoIGlzIGRyYXduIG9uIHRvcCBvZiB0aGUgb3RoZXJzXG4gICAgICAgICAgdGhpcy5wb3B1cE9iaiA9IG5vZGVzW292ZXJsYXBwaW5nTm9kZXNbb3ZlcmxhcHBpbmdOb2Rlcy5sZW5ndGggLSAxXV07XG4gICAgICAgICAgLy8gaWYgeW91IGhvdmVyIG92ZXIgYSBub2RlLCB0aGUgdGl0bGUgb2YgdGhlIGVkZ2UgaXMgbm90IHN1cHBvc2VkIHRvIGJlIHNob3duLlxuICAgICAgICAgIG5vZGVVbmRlckN1cnNvciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucG9wdXBPYmogPT09IHVuZGVmaW5lZCAmJiBub2RlVW5kZXJDdXJzb3IgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIHNlYXJjaCB0aGUgZWRnZXMgZm9yIG92ZXJsYXBcbiAgICAgICAgdmFyIGVkZ2VJbmRpY2VzID0gdGhpcy5ib2R5LmVkZ2VJbmRpY2VzO1xuICAgICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gICAgICAgIHZhciBlZGdlID0gdm9pZCAwO1xuICAgICAgICB2YXIgb3ZlcmxhcHBpbmdFZGdlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZWRnZUluZGljZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgZWRnZSA9IGVkZ2VzW2VkZ2VJbmRpY2VzW19pXV07XG4gICAgICAgICAgaWYgKGVkZ2UuaXNPdmVybGFwcGluZ1dpdGgocG9pbnRlck9iaikgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmIChlZGdlLmNvbm5lY3RlZCA9PT0gdHJ1ZSAmJiBlZGdlLmdldFRpdGxlKCkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBvdmVybGFwcGluZ0VkZ2VzLnB1c2goZWRnZUluZGljZXNbX2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3ZlcmxhcHBpbmdFZGdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhpcy5wb3B1cE9iaiA9IGVkZ2VzW292ZXJsYXBwaW5nRWRnZXNbb3ZlcmxhcHBpbmdFZGdlcy5sZW5ndGggLSAxXV07XG4gICAgICAgICAgcG9wdXBUeXBlID0gJ2VkZ2UnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnBvcHVwT2JqICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gc2hvdyBwb3B1cCBtZXNzYWdlIHdpbmRvd1xuICAgICAgICBpZiAodGhpcy5wb3B1cE9iai5pZCAhPT0gcHJldmlvdXNQb3B1cE9iaklkKSB7XG4gICAgICAgICAgaWYgKHRoaXMucG9wdXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5wb3B1cCA9IG5ldyBQb3B1cCh0aGlzLmNhbnZhcy5mcmFtZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5wb3B1cC5wb3B1cFRhcmdldFR5cGUgPSBwb3B1cFR5cGU7XG4gICAgICAgICAgdGhpcy5wb3B1cC5wb3B1cFRhcmdldElkID0gdGhpcy5wb3B1cE9iai5pZDtcblxuICAgICAgICAgIC8vIGFkanVzdCBhIHNtYWxsIG9mZnNldCBzdWNoIHRoYXQgdGhlIG1vdXNlIGN1cnNvciBpcyBsb2NhdGVkIGluIHRoZVxuICAgICAgICAgIC8vIGJvdHRvbSBsZWZ0IGxvY2F0aW9uIG9mIHRoZSBwb3B1cCwgYW5kIHlvdSBjYW4gZWFzaWx5IG1vdmUgb3ZlciB0aGVcbiAgICAgICAgICAvLyBwb3B1cCBhcmVhXG4gICAgICAgICAgdGhpcy5wb3B1cC5zZXRQb3NpdGlvbihwb2ludGVyLnggKyAzLCBwb2ludGVyLnkgLSA1KTtcbiAgICAgICAgICB0aGlzLnBvcHVwLnNldFRleHQodGhpcy5wb3B1cE9iai5nZXRUaXRsZSgpKTtcbiAgICAgICAgICB0aGlzLnBvcHVwLnNob3coKTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdzaG93UG9wdXAnLCB0aGlzLnBvcHVwT2JqLmlkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMucG9wdXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMucG9wdXAuaGlkZSgpO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ2hpZGVQb3B1cCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIHBvcHVwIG11c3QgYmUgaGlkZGVuLCB3aGljaCBpcyB0aGUgY2FzZSB3aGVuIHRoZSBtb3VzZSBpcyBub1xuICAgICAqIGxvbmdlciBob3ZlcmluZyBvbiB0aGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHt7eDpudW1iZXIsIHk6bnVtYmVyfX0gcG9pbnRlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19jaGVja0hpZGVQb3B1cCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jaGVja0hpZGVQb3B1cChwb2ludGVyKSB7XG4gICAgICB2YXIgcG9pbnRlck9iaiA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fcG9pbnRlclRvUG9zaXRpb25PYmplY3QocG9pbnRlcik7XG5cbiAgICAgIHZhciBzdGlsbE9uT2JqID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5wb3B1cC5wb3B1cFRhcmdldFR5cGUgPT09ICdub2RlJykge1xuICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW3RoaXMucG9wdXAucG9wdXBUYXJnZXRJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHN0aWxsT25PYmogPSB0aGlzLmJvZHkubm9kZXNbdGhpcy5wb3B1cC5wb3B1cFRhcmdldElkXS5pc092ZXJsYXBwaW5nV2l0aChwb2ludGVyT2JqKTtcblxuICAgICAgICAgIC8vIGlmIHRoZSBtb3VzZSBpcyBzdGlsbCBvbmUgdGhlIG5vZGUsIHdlIGhhdmUgdG8gY2hlY2sgaWYgaXQgaXMgbm90IGFsc28gb24gb25lIHRoYXQgaXMgZHJhd24gb24gdG9wIG9mIGl0LlxuICAgICAgICAgIC8vIHdlIGluaXRpYWxseSBvbmx5IGNoZWNrIHN0aWxsT25PYmogYmVjYXVzZSB0aGlzIGlzIG11Y2ggZmFzdGVyLlxuICAgICAgICAgIGlmIChzdGlsbE9uT2JqID09PSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgb3Zlck5vZGUgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0Tm9kZUF0KHBvaW50ZXIpO1xuICAgICAgICAgICAgc3RpbGxPbk9iaiA9IG92ZXJOb2RlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG92ZXJOb2RlLmlkID09PSB0aGlzLnBvcHVwLnBvcHVwVGFyZ2V0SWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldE5vZGVBdChwb2ludGVyKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHRoaXMuYm9keS5lZGdlc1t0aGlzLnBvcHVwLnBvcHVwVGFyZ2V0SWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0aWxsT25PYmogPSB0aGlzLmJvZHkuZWRnZXNbdGhpcy5wb3B1cC5wb3B1cFRhcmdldElkXS5pc092ZXJsYXBwaW5nV2l0aChwb2ludGVyT2JqKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN0aWxsT25PYmogPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMucG9wdXBPYmogPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucG9wdXAuaGlkZSgpO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdoaWRlUG9wdXAnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEludGVyYWN0aW9uSGFuZGxlcjtcbn0oKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gSW50ZXJhY3Rpb25IYW5kbGVyO1xuXG4vKioqLyB9KSxcbi8qIDE4NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIEhhbW1lciA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xudmFyIGhhbW1lclV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KTtcbnZhciBrZXljaGFybSA9IF9fd2VicGFja19yZXF1aXJlX18oNTIpO1xuXG4vKipcbiAqIE5hdmlnYXRpb24gSGFuZGxlclxuICovXG5cbnZhciBOYXZpZ2F0aW9uSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7Q2FudmFzfSBjYW52YXNcbiAgICovXG4gIGZ1bmN0aW9uIE5hdmlnYXRpb25IYW5kbGVyKGJvZHksIGNhbnZhcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrM1snZGVmYXVsdCddKSh0aGlzLCBOYXZpZ2F0aW9uSGFuZGxlcik7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuXG4gICAgdGhpcy5pY29uc0NyZWF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLm5hdmlnYXRpb25IYW1tZXJzID0gW107XG4gICAgdGhpcy5ib3VuZEZ1bmN0aW9ucyA9IHt9O1xuICAgIHRoaXMudG91Y2hUaW1lID0gMDtcbiAgICB0aGlzLmFjdGl2YXRlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ2FjdGl2YXRlJywgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuYWN0aXZhdGVkID0gdHJ1ZTtcbiAgICAgIF90aGlzLmNvbmZpZ3VyZUtleWJvYXJkQmluZGluZ3MoKTtcbiAgICB9KTtcbiAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignZGVhY3RpdmF0ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLmFjdGl2YXRlZCA9IGZhbHNlO1xuICAgICAgX3RoaXMuY29uZmlndXJlS2V5Ym9hcmRCaW5kaW5ncygpO1xuICAgIH0pO1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKF90aGlzLmtleWNoYXJtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgX3RoaXMua2V5Y2hhcm0uZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzM1snZGVmYXVsdCddKShOYXZpZ2F0aW9uSGFuZGxlciwgW3tcbiAgICBrZXk6ICdzZXRPcHRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuY3JlYXRlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBvciByZWZyZXNoZXMgbmF2aWdhdGlvbiBhbmQgc2V0cyBrZXkgYmluZGluZ3NcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY3JlYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5uYXZpZ2F0aW9uQnV0dG9ucyA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAodGhpcy5pY29uc0NyZWF0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhpcy5sb2FkTmF2aWdhdGlvbkVsZW1lbnRzKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pY29uc0NyZWF0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5jbGVhbk5hdmlnYXRpb24oKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb25maWd1cmVLZXlib2FyZEJpbmRpbmdzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYW5zIHVwIHByZXZpb3VzIG5hdmlnYXRpb24gaXRlbXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY2xlYW5OYXZpZ2F0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYW5OYXZpZ2F0aW9uKCkge1xuICAgICAgLy8gY2xlYW4gaGFtbWVyIGJpbmRpbmdzXG4gICAgICBpZiAodGhpcy5uYXZpZ2F0aW9uSGFtbWVycy5sZW5ndGggIT0gMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubmF2aWdhdGlvbkhhbW1lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLm5hdmlnYXRpb25IYW1tZXJzW2ldLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5hdmlnYXRpb25IYW1tZXJzID0gW107XG4gICAgICB9XG5cbiAgICAgIC8vIGNsZWFuIHVwIHByZXZpb3VzIG5hdmlnYXRpb24gaXRlbXNcbiAgICAgIGlmICh0aGlzLm5hdmlnYXRpb25ET00gJiYgdGhpcy5uYXZpZ2F0aW9uRE9NWyd3cmFwcGVyJ10gJiYgdGhpcy5uYXZpZ2F0aW9uRE9NWyd3cmFwcGVyJ10ucGFyZW50Tm9kZSkge1xuICAgICAgICB0aGlzLm5hdmlnYXRpb25ET01bJ3dyYXBwZXInXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMubmF2aWdhdGlvbkRPTVsnd3JhcHBlciddKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pY29uc0NyZWF0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGlvbiBvZiB0aGUgbmF2aWdhdGlvbiBjb250cm9scyBub2Rlcy4gVGhleSBhcmUgZHJhd24gb3ZlciB0aGUgcmVzdCBvZiB0aGUgbm9kZXMgYW5kIGFyZSBub3QgYWZmZWN0ZWQgYnkgc2NhbGUgYW5kIHRyYW5zbGF0aW9uXG4gICAgICogdGhleSBoYXZlIGEgdHJpZ2dlckZ1bmN0aW9uIHdoaWNoIGlzIGNhbGxlZCBvbiBjbGljay4gSWYgdGhlIHBvc2l0aW9uIG9mIHRoZSBuYXZpZ2F0aW9uIGNvbnRyb2xzIGlzIGRlcGVuZGVudFxuICAgICAqIG9uIHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoIG9yIHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodCwgd2UgZmxhZyBob3Jpem9udGFsQWxpZ25MZWZ0IGFuZCB2ZXJ0aWNhbEFsaWduVG9wIGZhbHNlLlxuICAgICAqIFRoaXMgbWVhbnMgdGhhdCB0aGUgbG9jYXRpb24gd2lsbCBiZSBjb3JyZWN0ZWQgYnkgdGhlIF9yZWxvY2F0ZU5hdmlnYXRpb24gZnVuY3Rpb24gb24gYSBzaXplIGNoYW5nZSBvZiB0aGUgY2FudmFzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbG9hZE5hdmlnYXRpb25FbGVtZW50cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWROYXZpZ2F0aW9uRWxlbWVudHMoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy5jbGVhbk5hdmlnYXRpb24oKTtcblxuICAgICAgdGhpcy5uYXZpZ2F0aW9uRE9NID0ge307XG4gICAgICB2YXIgbmF2aWdhdGlvbkRpdnMgPSBbJ3VwJywgJ2Rvd24nLCAnbGVmdCcsICdyaWdodCcsICd6b29tSW4nLCAnem9vbU91dCcsICd6b29tRXh0ZW5kcyddO1xuICAgICAgdmFyIG5hdmlnYXRpb25EaXZBY3Rpb25zID0gWydfbW92ZVVwJywgJ19tb3ZlRG93bicsICdfbW92ZUxlZnQnLCAnX21vdmVSaWdodCcsICdfem9vbUluJywgJ196b29tT3V0JywgJ19maXQnXTtcblxuICAgICAgdGhpcy5uYXZpZ2F0aW9uRE9NWyd3cmFwcGVyJ10gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMubmF2aWdhdGlvbkRPTVsnd3JhcHBlciddLmNsYXNzTmFtZSA9ICd2aXMtbmF2aWdhdGlvbic7XG4gICAgICB0aGlzLmNhbnZhcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLm5hdmlnYXRpb25ET01bJ3dyYXBwZXInXSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmF2aWdhdGlvbkRpdnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uRE9NW25hdmlnYXRpb25EaXZzW2ldXSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLm5hdmlnYXRpb25ET01bbmF2aWdhdGlvbkRpdnNbaV1dLmNsYXNzTmFtZSA9ICd2aXMtYnV0dG9uIHZpcy0nICsgbmF2aWdhdGlvbkRpdnNbaV07XG4gICAgICAgIHRoaXMubmF2aWdhdGlvbkRPTVsnd3JhcHBlciddLmFwcGVuZENoaWxkKHRoaXMubmF2aWdhdGlvbkRPTVtuYXZpZ2F0aW9uRGl2c1tpXV0pO1xuXG4gICAgICAgIHZhciBoYW1tZXIgPSBuZXcgSGFtbWVyKHRoaXMubmF2aWdhdGlvbkRPTVtuYXZpZ2F0aW9uRGl2c1tpXV0pO1xuICAgICAgICBpZiAobmF2aWdhdGlvbkRpdkFjdGlvbnNbaV0gPT09ICdfZml0Jykge1xuICAgICAgICAgIGhhbW1lclV0aWwub25Ub3VjaChoYW1tZXIsIHRoaXMuX2ZpdC5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYW1tZXJVdGlsLm9uVG91Y2goaGFtbWVyLCB0aGlzLmJpbmRUb1JlZHJhdy5iaW5kKHRoaXMsIG5hdmlnYXRpb25EaXZBY3Rpb25zW2ldKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm5hdmlnYXRpb25IYW1tZXJzLnB1c2goaGFtbWVyKTtcbiAgICAgIH1cblxuICAgICAgLy8gdXNlIGEgaGFtbWVyIGZvciB0aGUgcmVsZWFzZSBzbyB3ZSBkbyBub3QgcmVxdWlyZSB0aGUgb25lIHVzZWQgaW4gdGhlIHJlc3Qgb2YgdGhlIG5ldHdvcmtcbiAgICAgIC8vIHRoZSBvbmUgdGhlIHJlc3QgdXNlcyBjYW4gYmUgb3ZlcmxvYWRlZCBieSB0aGUgbWFuaXB1bGF0aW9uIHN5c3RlbS5cbiAgICAgIHZhciBoYW1tZXJGcmFtZSA9IG5ldyBIYW1tZXIodGhpcy5jYW52YXMuZnJhbWUpO1xuICAgICAgaGFtbWVyVXRpbC5vblJlbGVhc2UoaGFtbWVyRnJhbWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLl9zdG9wTW92ZW1lbnQoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5uYXZpZ2F0aW9uSGFtbWVycy5wdXNoKGhhbW1lckZyYW1lKTtcblxuICAgICAgdGhpcy5pY29uc0NyZWF0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdiaW5kVG9SZWRyYXcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kVG9SZWRyYXcoYWN0aW9uKSB7XG4gICAgICBpZiAodGhpcy5ib3VuZEZ1bmN0aW9uc1thY3Rpb25dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5ib3VuZEZ1bmN0aW9uc1thY3Rpb25dID0gdGhpc1thY3Rpb25dLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdpbml0UmVkcmF3JywgdGhpcy5ib3VuZEZ1bmN0aW9uc1thY3Rpb25dKTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX3N0YXJ0UmVuZGVyaW5nJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3VuYmluZEZyb21SZWRyYXcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmJpbmRGcm9tUmVkcmF3KGFjdGlvbikge1xuICAgICAgaWYgKHRoaXMuYm91bmRGdW5jdGlvbnNbYWN0aW9uXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9mZignaW5pdFJlZHJhdycsIHRoaXMuYm91bmRGdW5jdGlvbnNbYWN0aW9uXSk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19zdG9wUmVuZGVyaW5nJyk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmJvdW5kRnVuY3Rpb25zW2FjdGlvbl07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdGhpcyBzdG9wcyBhbGwgbW92ZW1lbnQgaW5kdWNlZCBieSB0aGUgbmF2aWdhdGlvbiBidXR0b25zXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZml0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpdCgpIHtcbiAgICAgIGlmIChuZXcgRGF0ZSgpLnZhbHVlT2YoKSAtIHRoaXMudG91Y2hUaW1lID4gNzAwKSB7XG4gICAgICAgIC8vIFRPRE86IGZpeCB1Z2x5IGhhY2sgdG8gYXZvaWQgaGFtbWVyJ3MgZG91YmxlIGZpcmVpbmcgb2YgZXZlbnQgKGJlY2F1c2Ugd2UgdXNlIHJlbGVhc2U/KVxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdmaXQnLCB7IGR1cmF0aW9uOiA3MDAgfSk7XG4gICAgICAgIHRoaXMudG91Y2hUaW1lID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdGhpcyBzdG9wcyBhbGwgbW92ZW1lbnQgaW5kdWNlZCBieSB0aGUgbmF2aWdhdGlvbiBidXR0b25zXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfc3RvcE1vdmVtZW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3N0b3BNb3ZlbWVudCgpIHtcbiAgICAgIGZvciAodmFyIGJvdW5kQWN0aW9uIGluIHRoaXMuYm91bmRGdW5jdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuYm91bmRGdW5jdGlvbnMuaGFzT3duUHJvcGVydHkoYm91bmRBY3Rpb24pKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub2ZmKCdpbml0UmVkcmF3JywgdGhpcy5ib3VuZEZ1bmN0aW9uc1tib3VuZEFjdGlvbl0pO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19zdG9wUmVuZGVyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuYm91bmRGdW5jdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfbW92ZVVwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21vdmVVcCgpIHtcbiAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnkgKz0gdGhpcy5vcHRpb25zLmtleWJvYXJkLnNwZWVkLnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX21vdmVEb3duJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21vdmVEb3duKCkge1xuICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueSAtPSB0aGlzLm9wdGlvbnMua2V5Ym9hcmQuc3BlZWQueTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfbW92ZUxlZnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbW92ZUxlZnQoKSB7XG4gICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi54ICs9IHRoaXMub3B0aW9ucy5rZXlib2FyZC5zcGVlZC54O1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19tb3ZlUmlnaHQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbW92ZVJpZ2h0KCkge1xuICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueCAtPSB0aGlzLm9wdGlvbnMua2V5Ym9hcmQuc3BlZWQueDtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfem9vbUluJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3pvb21JbigpIHtcbiAgICAgIHZhciBzY2FsZU9sZCA9IHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgdmFyIHNjYWxlID0gdGhpcy5ib2R5LnZpZXcuc2NhbGUgKiAoMSArIHRoaXMub3B0aW9ucy5rZXlib2FyZC5zcGVlZC56b29tKTtcbiAgICAgIHZhciB0cmFuc2xhdGlvbiA9IHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uO1xuICAgICAgdmFyIHNjYWxlRnJhYyA9IHNjYWxlIC8gc2NhbGVPbGQ7XG4gICAgICB2YXIgdHggPSAoMSAtIHNjYWxlRnJhYykgKiB0aGlzLmNhbnZhcy5jYW52YXNWaWV3Q2VudGVyLnggKyB0cmFuc2xhdGlvbi54ICogc2NhbGVGcmFjO1xuICAgICAgdmFyIHR5ID0gKDEgLSBzY2FsZUZyYWMpICogdGhpcy5jYW52YXMuY2FudmFzVmlld0NlbnRlci55ICsgdHJhbnNsYXRpb24ueSAqIHNjYWxlRnJhYztcblxuICAgICAgdGhpcy5ib2R5LnZpZXcuc2NhbGUgPSBzY2FsZTtcbiAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uID0geyB4OiB0eCwgeTogdHkgfTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3pvb20nLCB7XG4gICAgICAgIGRpcmVjdGlvbjogJysnLFxuICAgICAgICBzY2FsZTogdGhpcy5ib2R5LnZpZXcuc2NhbGUsXG4gICAgICAgIHBvaW50ZXI6IG51bGxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3pvb21PdXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfem9vbU91dCgpIHtcbiAgICAgIHZhciBzY2FsZU9sZCA9IHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgdmFyIHNjYWxlID0gdGhpcy5ib2R5LnZpZXcuc2NhbGUgLyAoMSArIHRoaXMub3B0aW9ucy5rZXlib2FyZC5zcGVlZC56b29tKTtcbiAgICAgIHZhciB0cmFuc2xhdGlvbiA9IHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uO1xuICAgICAgdmFyIHNjYWxlRnJhYyA9IHNjYWxlIC8gc2NhbGVPbGQ7XG4gICAgICB2YXIgdHggPSAoMSAtIHNjYWxlRnJhYykgKiB0aGlzLmNhbnZhcy5jYW52YXNWaWV3Q2VudGVyLnggKyB0cmFuc2xhdGlvbi54ICogc2NhbGVGcmFjO1xuICAgICAgdmFyIHR5ID0gKDEgLSBzY2FsZUZyYWMpICogdGhpcy5jYW52YXMuY2FudmFzVmlld0NlbnRlci55ICsgdHJhbnNsYXRpb24ueSAqIHNjYWxlRnJhYztcblxuICAgICAgdGhpcy5ib2R5LnZpZXcuc2NhbGUgPSBzY2FsZTtcbiAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uID0geyB4OiB0eCwgeTogdHkgfTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3pvb20nLCB7XG4gICAgICAgIGRpcmVjdGlvbjogJy0nLFxuICAgICAgICBzY2FsZTogdGhpcy5ib2R5LnZpZXcuc2NhbGUsXG4gICAgICAgIHBvaW50ZXI6IG51bGxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGJpbmQgYWxsIGtleXMgdXNpbmcga2V5Y2hhcm0uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2NvbmZpZ3VyZUtleWJvYXJkQmluZGluZ3MnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25maWd1cmVLZXlib2FyZEJpbmRpbmdzKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLmtleWNoYXJtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5rZXljaGFybS5kZXN0cm95KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMua2V5Ym9hcmQuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmtleWJvYXJkLmJpbmRUb1dpbmRvdyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMua2V5Y2hhcm0gPSBrZXljaGFybSh7IGNvbnRhaW5lcjogd2luZG93LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmtleWNoYXJtID0ga2V5Y2hhcm0oe1xuICAgICAgICAgICAgY29udGFpbmVyOiB0aGlzLmNhbnZhcy5mcmFtZSxcbiAgICAgICAgICAgIHByZXZlbnREZWZhdWx0OiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmtleWNoYXJtLnJlc2V0KCk7XG5cbiAgICAgICAgaWYgKHRoaXMuYWN0aXZhdGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKCd1cCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoJ19tb3ZlVXAnKTtcbiAgICAgICAgICB9LCAna2V5ZG93bicpO1xuICAgICAgICAgIHRoaXMua2V5Y2hhcm0uYmluZCgnZG93bicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoJ19tb3ZlRG93bicpO1xuICAgICAgICAgIH0sICdrZXlkb3duJyk7XG4gICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKCdsZWZ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLmJpbmRUb1JlZHJhdygnX21vdmVMZWZ0Jyk7XG4gICAgICAgICAgfSwgJ2tleWRvd24nKTtcbiAgICAgICAgICB0aGlzLmtleWNoYXJtLmJpbmQoJ3JpZ2h0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLmJpbmRUb1JlZHJhdygnX21vdmVSaWdodCcpO1xuICAgICAgICAgIH0sICdrZXlkb3duJyk7XG4gICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKCc9JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLmJpbmRUb1JlZHJhdygnX3pvb21JbicpO1xuICAgICAgICAgIH0sICdrZXlkb3duJyk7XG4gICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKCdudW0rJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLmJpbmRUb1JlZHJhdygnX3pvb21JbicpO1xuICAgICAgICAgIH0sICdrZXlkb3duJyk7XG4gICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKCdudW0tJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLmJpbmRUb1JlZHJhdygnX3pvb21PdXQnKTtcbiAgICAgICAgICB9LCAna2V5ZG93bicpO1xuICAgICAgICAgIHRoaXMua2V5Y2hhcm0uYmluZCgnLScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoJ196b29tT3V0Jyk7XG4gICAgICAgICAgfSwgJ2tleWRvd24nKTtcbiAgICAgICAgICB0aGlzLmtleWNoYXJtLmJpbmQoJ1snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMuYmluZFRvUmVkcmF3KCdfem9vbU91dCcpO1xuICAgICAgICAgIH0sICdrZXlkb3duJyk7XG4gICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKCddJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLmJpbmRUb1JlZHJhdygnX3pvb21JbicpO1xuICAgICAgICAgIH0sICdrZXlkb3duJyk7XG4gICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKCdwYWdldXAnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMuYmluZFRvUmVkcmF3KCdfem9vbUluJyk7XG4gICAgICAgICAgfSwgJ2tleWRvd24nKTtcbiAgICAgICAgICB0aGlzLmtleWNoYXJtLmJpbmQoJ3BhZ2Vkb3duJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLmJpbmRUb1JlZHJhdygnX3pvb21PdXQnKTtcbiAgICAgICAgICB9LCAna2V5ZG93bicpO1xuXG4gICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKCd1cCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KCdfbW92ZVVwJyk7XG4gICAgICAgICAgfSwgJ2tleXVwJyk7XG4gICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKCdkb3duJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoJ19tb3ZlRG93bicpO1xuICAgICAgICAgIH0sICdrZXl1cCcpO1xuICAgICAgICAgIHRoaXMua2V5Y2hhcm0uYmluZCgnbGVmdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KCdfbW92ZUxlZnQnKTtcbiAgICAgICAgICB9LCAna2V5dXAnKTtcbiAgICAgICAgICB0aGlzLmtleWNoYXJtLmJpbmQoJ3JpZ2h0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoJ19tb3ZlUmlnaHQnKTtcbiAgICAgICAgICB9LCAna2V5dXAnKTtcbiAgICAgICAgICB0aGlzLmtleWNoYXJtLmJpbmQoJz0nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMudW5iaW5kRnJvbVJlZHJhdygnX3pvb21JbicpO1xuICAgICAgICAgIH0sICdrZXl1cCcpO1xuICAgICAgICAgIHRoaXMua2V5Y2hhcm0uYmluZCgnbnVtKycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KCdfem9vbUluJyk7XG4gICAgICAgICAgfSwgJ2tleXVwJyk7XG4gICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKCdudW0tJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoJ196b29tT3V0Jyk7XG4gICAgICAgICAgfSwgJ2tleXVwJyk7XG4gICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKCctJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoJ196b29tT3V0Jyk7XG4gICAgICAgICAgfSwgJ2tleXVwJyk7XG4gICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKCdbJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoJ196b29tT3V0Jyk7XG4gICAgICAgICAgfSwgJ2tleXVwJyk7XG4gICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKCddJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoJ196b29tSW4nKTtcbiAgICAgICAgICB9LCAna2V5dXAnKTtcbiAgICAgICAgICB0aGlzLmtleWNoYXJtLmJpbmQoJ3BhZ2V1cCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KCdfem9vbUluJyk7XG4gICAgICAgICAgfSwgJ2tleXVwJyk7XG4gICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKCdwYWdlZG93bicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KCdfem9vbU91dCcpO1xuICAgICAgICAgIH0sICdrZXl1cCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBOYXZpZ2F0aW9uSGFuZGxlcjtcbn0oKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gTmF2aWdhdGlvbkhhbmRsZXI7XG5cbi8qKiovIH0pLFxuLyogMTg1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vKipcbiAqIFBvcHVwIGlzIGEgY2xhc3MgdG8gY3JlYXRlIGEgcG9wdXAgd2luZG93IHdpdGggc29tZSB0ZXh0XG4gKi9cbnZhciBQb3B1cCA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gY29udGFpbmVyICAgICAgIFRoZSBjb250YWluZXIgb2JqZWN0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gIG92ZXJmbG93TWV0aG9kICBIb3cgdGhlIHBvcHVwIHNob3VsZCBhY3QgdG8gb3ZlcmZsb3dpbmcgKCdmbGlwJyBvciAnY2FwJylcbiAgICovXG4gIGZ1bmN0aW9uIFBvcHVwKGNvbnRhaW5lciwgb3ZlcmZsb3dNZXRob2QpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrM1snZGVmYXVsdCddKSh0aGlzLCBQb3B1cCk7XG5cbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLm92ZXJmbG93TWV0aG9kID0gb3ZlcmZsb3dNZXRob2QgfHwgJ2NhcCc7XG5cbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy5wYWRkaW5nID0gNTtcbiAgICB0aGlzLmhpZGRlbiA9IGZhbHNlO1xuXG4gICAgLy8gY3JlYXRlIHRoZSBmcmFtZVxuICAgIHRoaXMuZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmZyYW1lLmNsYXNzTmFtZSA9ICd2aXMtdG9vbHRpcCc7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5mcmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggICBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBwb3B1cCB3aW5kb3dcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgICBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgcG9wdXAgd2luZG93XG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoUG9wdXAsIFt7XG4gICAga2V5OiAnc2V0UG9zaXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQb3NpdGlvbih4LCB5KSB7XG4gICAgICB0aGlzLnggPSBwYXJzZUludCh4KTtcbiAgICAgIHRoaXMueSA9IHBhcnNlSW50KHkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY29udGVudCBmb3IgdGhlIHBvcHVwIHdpbmRvdy4gVGhpcyBjYW4gYmUgSFRNTCBjb2RlIG9yIHRleHQuXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBFbGVtZW50fSBjb250ZW50XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldFRleHQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRUZXh0KGNvbnRlbnQpIHtcbiAgICAgIGlmIChjb250ZW50IGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICB0aGlzLmZyYW1lLmlubmVySFRNTCA9ICcnO1xuICAgICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5mcmFtZS5pbm5lckhUTUwgPSBjb250ZW50OyAvLyBzdHJpbmcgY29udGFpbmluZyB0ZXh0IG9yIEhUTUxcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaG93IHRoZSBwb3B1cCB3aW5kb3dcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkb1Nob3ddICAgIFNob3cgb3IgaGlkZSB0aGUgd2luZG93XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Nob3cnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93KGRvU2hvdykge1xuICAgICAgaWYgKGRvU2hvdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRvU2hvdyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChkb1Nob3cgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuZnJhbWUuY2xpZW50SGVpZ2h0O1xuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmZyYW1lLmNsaWVudFdpZHRoO1xuICAgICAgICB2YXIgbWF4SGVpZ2h0ID0gdGhpcy5mcmFtZS5wYXJlbnROb2RlLmNsaWVudEhlaWdodDtcbiAgICAgICAgdmFyIG1heFdpZHRoID0gdGhpcy5mcmFtZS5wYXJlbnROb2RlLmNsaWVudFdpZHRoO1xuXG4gICAgICAgIHZhciBsZWZ0ID0gMCxcbiAgICAgICAgICAgIHRvcCA9IDA7XG5cbiAgICAgICAgaWYgKHRoaXMub3ZlcmZsb3dNZXRob2QgPT0gJ2ZsaXAnKSB7XG4gICAgICAgICAgdmFyIGlzTGVmdCA9IGZhbHNlLFxuICAgICAgICAgICAgICBpc1RvcCA9IHRydWU7IC8vIFdoZXJlIGFyb3VuZCB0aGUgcG9zaXRpb24gaXQncyBsb2NhdGVkXG5cbiAgICAgICAgICBpZiAodGhpcy55IC0gaGVpZ2h0IDwgdGhpcy5wYWRkaW5nKSB7XG4gICAgICAgICAgICBpc1RvcCA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLnggKyB3aWR0aCA+IG1heFdpZHRoIC0gdGhpcy5wYWRkaW5nKSB7XG4gICAgICAgICAgICBpc0xlZnQgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc0xlZnQpIHtcbiAgICAgICAgICAgIGxlZnQgPSB0aGlzLnggLSB3aWR0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVmdCA9IHRoaXMueDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNUb3ApIHtcbiAgICAgICAgICAgIHRvcCA9IHRoaXMueSAtIGhlaWdodDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9wID0gdGhpcy55O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b3AgPSB0aGlzLnkgLSBoZWlnaHQ7XG4gICAgICAgICAgaWYgKHRvcCArIGhlaWdodCArIHRoaXMucGFkZGluZyA+IG1heEhlaWdodCkge1xuICAgICAgICAgICAgdG9wID0gbWF4SGVpZ2h0IC0gaGVpZ2h0IC0gdGhpcy5wYWRkaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodG9wIDwgdGhpcy5wYWRkaW5nKSB7XG4gICAgICAgICAgICB0b3AgPSB0aGlzLnBhZGRpbmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGVmdCA9IHRoaXMueDtcbiAgICAgICAgICBpZiAobGVmdCArIHdpZHRoICsgdGhpcy5wYWRkaW5nID4gbWF4V2lkdGgpIHtcbiAgICAgICAgICAgIGxlZnQgPSBtYXhXaWR0aCAtIHdpZHRoIC0gdGhpcy5wYWRkaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobGVmdCA8IHRoaXMucGFkZGluZykge1xuICAgICAgICAgICAgbGVmdCA9IHRoaXMucGFkZGluZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZyYW1lLnN0eWxlLmxlZnQgPSBsZWZ0ICsgJ3B4JztcbiAgICAgICAgdGhpcy5mcmFtZS5zdHlsZS50b3AgPSB0b3AgKyAncHgnO1xuICAgICAgICB0aGlzLmZyYW1lLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgICAgIHRoaXMuaGlkZGVuID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIaWRlIHRoZSBwb3B1cCB3aW5kb3dcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaGlkZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgICB0aGlzLmhpZGRlbiA9IHRydWU7XG4gICAgICB0aGlzLmZyYW1lLnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgICB0aGlzLmZyYW1lLnN0eWxlLnRvcCA9ICcwJztcbiAgICAgIHRoaXMuZnJhbWUuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGUgcG9wdXAgd2luZG93XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy5mcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZnJhbWUpOyAvLyBSZW1vdmUgZWxlbWVudCBmcm9tIERPTVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gUG9wdXA7XG59KCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFBvcHVwO1xuXG4vKioqLyB9KSxcbi8qIDE4NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2tleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG52YXIgX2tleXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfa2V5cyk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpWydkZWZhdWx0J107XG52YXIgRWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTUpWydkZWZhdWx0J107XG5cbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxuLyoqXG4gKiBUaGUgaGFuZGxlciBmb3Igc2VsZWN0aW9uc1xuICovXG5cbnZhciBTZWxlY3Rpb25IYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtDYW52YXN9IGNhbnZhc1xuICAgKi9cbiAgZnVuY3Rpb24gU2VsZWN0aW9uSGFuZGxlcihib2R5LCBjYW52YXMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgU2VsZWN0aW9uSGFuZGxlcik7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMuc2VsZWN0aW9uT2JqID0geyBub2RlczogW10sIGVkZ2VzOiBbXSB9O1xuICAgIHRoaXMuaG92ZXJPYmogPSB7IG5vZGVzOiB7fSwgZWRnZXM6IHt9IH07XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgbXVsdGlzZWxlY3Q6IGZhbHNlLFxuICAgICAgc2VsZWN0YWJsZTogdHJ1ZSxcbiAgICAgIHNlbGVjdENvbm5lY3RlZEVkZ2VzOiB0cnVlLFxuICAgICAgaG92ZXJDb25uZWN0ZWRFZGdlczogdHJ1ZVxuICAgIH07XG4gICAgdXRpbC5leHRlbmQodGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdfZGF0YUNoYW5nZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy51cGRhdGVTZWxlY3Rpb24oKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoU2VsZWN0aW9uSGFuZGxlciwgW3tcbiAgICBrZXk6ICdzZXRPcHRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBmaWVsZHMgPSBbJ211bHRpc2VsZWN0JywgJ2hvdmVyQ29ubmVjdGVkRWRnZXMnLCAnc2VsZWN0YWJsZScsICdzZWxlY3RDb25uZWN0ZWRFZGdlcyddO1xuICAgICAgICB1dGlsLnNlbGVjdGl2ZURlZXBFeHRlbmQoZmllbGRzLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGhhbmRsZXMgdGhlIHNlbGVjdGlvbiBwYXJ0IG9mIHRoZSB0YXA7XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvaW50ZXJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2VsZWN0T25Qb2ludCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdE9uUG9pbnQocG9pbnRlcikge1xuICAgICAgdmFyIHNlbGVjdGVkID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNlbGVjdGFibGUgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIG9iaiA9IHRoaXMuZ2V0Tm9kZUF0KHBvaW50ZXIpIHx8IHRoaXMuZ2V0RWRnZUF0KHBvaW50ZXIpO1xuXG4gICAgICAgIC8vIHVuc2VsZWN0IGFmdGVyIGdldHRpbmcgdGhlIG9iamVjdHMgaW4gb3JkZXIgdG8gcmVzdG9yZSB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgICAgICB0aGlzLnVuc2VsZWN0QWxsKCk7XG5cbiAgICAgICAgaWYgKG9iaiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc2VsZWN0ZWQgPSB0aGlzLnNlbGVjdE9iamVjdChvYmopO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19yZXF1ZXN0UmVkcmF3Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvaW50ZXJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2VsZWN0QWRkaXRpb25hbE9uUG9pbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3RBZGRpdGlvbmFsT25Qb2ludChwb2ludGVyKSB7XG4gICAgICB2YXIgc2VsZWN0aW9uQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zZWxlY3RhYmxlID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBvYmogPSB0aGlzLmdldE5vZGVBdChwb2ludGVyKSB8fCB0aGlzLmdldEVkZ2VBdChwb2ludGVyKTtcblxuICAgICAgICBpZiAob2JqICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzZWxlY3Rpb25DaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAob2JqLmlzU2VsZWN0ZWQoKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5kZXNlbGVjdE9iamVjdChvYmopO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdE9iamVjdChvYmopO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19yZXF1ZXN0UmVkcmF3Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxlY3Rpb25DaGFuZ2VkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgc3RhbmRhcmQgZmllbGRzIGZvciBhbiBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwb2ludGVyIE9iamVjdCB3aXRoIHRoZSB4IGFuZCB5IHNjcmVlbiBjb29yZGluYXRlcyBvZiB0aGUgbW91c2VcbiAgICAgKiBAcmV0dXJucyB7e319XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2luaXRCYXNlRXZlbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdEJhc2VFdmVudChldmVudCwgcG9pbnRlcikge1xuICAgICAgdmFyIHByb3BlcnRpZXMgPSB7fTtcblxuICAgICAgcHJvcGVydGllc1sncG9pbnRlciddID0ge1xuICAgICAgICBET006IHsgeDogcG9pbnRlci54LCB5OiBwb2ludGVyLnkgfSxcbiAgICAgICAgY2FudmFzOiB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyhwb2ludGVyKVxuICAgICAgfTtcbiAgICAgIHByb3BlcnRpZXNbJ2V2ZW50J10gPSBldmVudDtcblxuICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYW4gZXZlbnQgd2hpY2ggdGhlIHVzZXIgY2FuIGNhdGNoLlxuICAgICAqXG4gICAgICogVGhpcyBhZGRzIHNvbWUgZXh0cmEgZGF0YSB0byB0aGUgZXZlbnQgd2l0aCByZXNwZWN0IHRvIGN1cnNvciBwb3NpdGlvbiBhbmRcbiAgICAgKiBzZWxlY3RlZCBub2RlcyBhbmQgZWRnZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlICAgICAgICAgICAgICAgICAgICAgICAgICBOYW1lIG9mIGV2ZW50IHRvIHNlbmRcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSAgZXZlbnRcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvaW50ZXIgICAgICAgICAgICBPYmplY3Qgd2l0aCB0aGUgeCBhbmQgeSBzY3JlZW4gY29vcmRpbmF0ZXMgb2YgdGhlIG1vdXNlXG4gICAgICogQHBhcmFtIHtPYmplY3R8dW5kZWZpbmVkfSBvbGRTZWxlY3Rpb24gICAgICAgICAgICAgSWYgcHJlc2VudCwgc2VsZWN0aW9uIHN0YXRlIGJlZm9yZSBldmVudCBvY2N1cmVkXG4gICAgICogQHBhcmFtIHtib29sZWFufHVuZGVmaW5lZH0gW2VtcHR5U2VsZWN0aW9uPWZhbHNlXSAgSW5kaWNhdGUgaWYgc2VsZWN0aW9uIGRhdGEgc2hvdWxkIGJlIHBhc3NlZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZ2VuZXJhdGVDbGlja0V2ZW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dlbmVyYXRlQ2xpY2tFdmVudChldmVudFR5cGUsIGV2ZW50LCBwb2ludGVyLCBvbGRTZWxlY3Rpb24pIHtcbiAgICAgIHZhciBlbXB0eVNlbGVjdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogZmFsc2U7XG5cbiAgICAgIHZhciBwcm9wZXJ0aWVzID0gdGhpcy5faW5pdEJhc2VFdmVudChldmVudCwgcG9pbnRlcik7XG5cbiAgICAgIGlmIChlbXB0eVNlbGVjdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICBwcm9wZXJ0aWVzLm5vZGVzID0gW107XG4gICAgICAgIHByb3BlcnRpZXMuZWRnZXMgPSBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0bXAgPSB0aGlzLmdldFNlbGVjdGlvbigpO1xuICAgICAgICBwcm9wZXJ0aWVzLm5vZGVzID0gdG1wLm5vZGVzO1xuICAgICAgICBwcm9wZXJ0aWVzLmVkZ2VzID0gdG1wLmVkZ2VzO1xuICAgICAgfVxuXG4gICAgICBpZiAob2xkU2VsZWN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvcGVydGllc1sncHJldmlvdXNTZWxlY3Rpb24nXSA9IG9sZFNlbGVjdGlvbjtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50VHlwZSA9PSAnY2xpY2snKSB7XG4gICAgICAgIC8vIEZvciB0aGUgdGltZSBiZWluZywgcmVzdHJpY3QgdGhpcyBmdW5jdGlvbmFsaXR5IHRvXG4gICAgICAgIC8vIGp1c3QgdGhlIGNsaWNrIGV2ZW50LlxuICAgICAgICBwcm9wZXJ0aWVzLml0ZW1zID0gdGhpcy5nZXRDbGlja2VkSXRlbXMocG9pbnRlcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudC5jb250cm9sRWRnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BlcnRpZXMuY29udHJvbEVkZ2UgPSBldmVudC5jb250cm9sRWRnZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChldmVudFR5cGUsIHByb3BlcnRpZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hpZ2hsaWdodEVkZ2VzPXRoaXMub3B0aW9ucy5zZWxlY3RDb25uZWN0ZWRFZGdlc11cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2VsZWN0T2JqZWN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0T2JqZWN0KG9iaikge1xuICAgICAgdmFyIGhpZ2hsaWdodEVkZ2VzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLm9wdGlvbnMuc2VsZWN0Q29ubmVjdGVkRWRnZXM7XG5cbiAgICAgIGlmIChvYmogIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICAgIGlmIChoaWdobGlnaHRFZGdlcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0Q29ubmVjdGVkRWRnZXMob2JqKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb2JqLnNlbGVjdCgpO1xuICAgICAgICB0aGlzLl9hZGRUb1NlbGVjdGlvbihvYmopO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZGVzZWxlY3RPYmplY3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXNlbGVjdE9iamVjdChvYmopIHtcbiAgICAgIGlmIChvYmouaXNTZWxlY3RlZCgpID09PSB0cnVlKSB7XG4gICAgICAgIG9iai5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yZW1vdmVGcm9tU2VsZWN0aW9uKG9iaik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0cmlldmUgYWxsIG5vZGVzIG92ZXJsYXBwaW5nIHdpdGggZ2l2ZW4gb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAgQW4gb2JqZWN0IHdpdGggcGFyYW1ldGVycyBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b21cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJbXX0gICBBbiBhcnJheSB3aXRoIGlkJ3Mgb2YgdGhlIG92ZXJsYXBwaW5nIG5vZGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2dldEFsbE5vZGVzT3ZlcmxhcHBpbmdXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEFsbE5vZGVzT3ZlcmxhcHBpbmdXaXRoKG9iamVjdCkge1xuICAgICAgdmFyIG92ZXJsYXBwaW5nTm9kZXMgPSBbXTtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlSWQgPSB0aGlzLmJvZHkubm9kZUluZGljZXNbaV07XG4gICAgICAgIGlmIChub2Rlc1tub2RlSWRdLmlzT3ZlcmxhcHBpbmdXaXRoKG9iamVjdCkpIHtcbiAgICAgICAgICBvdmVybGFwcGluZ05vZGVzLnB1c2gobm9kZUlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG92ZXJsYXBwaW5nTm9kZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgcG9zaXRpb24gb2JqZWN0IGluIGNhbnZhc3NwYWNlIGZyb20gYSBzaW5nbGUgcG9pbnQgaW4gc2NyZWVuc3BhY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gcG9pbnRlclxuICAgICAqIEByZXR1cm5zIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgcmlnaHQ6IG51bWJlciwgYm90dG9tOiBudW1iZXJ9fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19wb2ludGVyVG9Qb3NpdGlvbk9iamVjdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wb2ludGVyVG9Qb3NpdGlvbk9iamVjdChwb2ludGVyKSB7XG4gICAgICB2YXIgY2FudmFzUG9zID0gdGhpcy5jYW52YXMuRE9NdG9DYW52YXMocG9pbnRlcik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBjYW52YXNQb3MueCAtIDEsXG4gICAgICAgIHRvcDogY2FudmFzUG9zLnkgKyAxLFxuICAgICAgICByaWdodDogY2FudmFzUG9zLnggKyAxLFxuICAgICAgICBib3R0b206IGNhbnZhc1Bvcy55IC0gMVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHRvcCBub2RlIGF0IHRoZSBwYXNzZWQgcG9pbnQgKGxpa2UgYSBjbGljaylcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gcG9pbnRlclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldHVybk5vZGU9dHJ1ZV1cbiAgICAgKiBAcmV0dXJuIHtOb2RlIHwgdW5kZWZpbmVkfSBub2RlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldE5vZGVBdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5vZGVBdChwb2ludGVyKSB7XG4gICAgICB2YXIgcmV0dXJuTm9kZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcblxuICAgICAgLy8gd2UgZmlyc3QgY2hlY2sgaWYgdGhpcyBpcyBhbiBuYXZpZ2F0aW9uIGNvbnRyb2xzIGVsZW1lbnRcbiAgICAgIHZhciBwb3NpdGlvbk9iamVjdCA9IHRoaXMuX3BvaW50ZXJUb1Bvc2l0aW9uT2JqZWN0KHBvaW50ZXIpO1xuICAgICAgdmFyIG92ZXJsYXBwaW5nTm9kZXMgPSB0aGlzLl9nZXRBbGxOb2Rlc092ZXJsYXBwaW5nV2l0aChwb3NpdGlvbk9iamVjdCk7XG4gICAgICAvLyBpZiB0aGVyZSBhcmUgb3ZlcmxhcHBpbmcgbm9kZXMsIHNlbGVjdCB0aGUgbGFzdCBvbmUsIHRoaXMgaXMgdGhlXG4gICAgICAvLyBvbmUgd2hpY2ggaXMgZHJhd24gb24gdG9wIG9mIHRoZSBvdGhlcnNcbiAgICAgIGlmIChvdmVybGFwcGluZ05vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKHJldHVybk5vZGUgPT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5Lm5vZGVzW292ZXJsYXBwaW5nTm9kZXNbb3ZlcmxhcHBpbmdOb2Rlcy5sZW5ndGggLSAxXV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG92ZXJsYXBwaW5nTm9kZXNbb3ZlcmxhcHBpbmdOb2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXRyaWV2ZSBhbGwgZWRnZXMgb3ZlcmxhcHBpbmcgd2l0aCBnaXZlbiBvYmplY3QsIHNlbGVjdG9yIGlzIGFyb3VuZCBjZW50ZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0ICBBbiBvYmplY3Qgd2l0aCBwYXJhbWV0ZXJzIGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IG92ZXJsYXBwaW5nRWRnZXMgQW4gYXJyYXkgd2l0aCBpZCdzIG9mIHRoZSBvdmVybGFwcGluZyBub2Rlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19nZXRFZGdlc092ZXJsYXBwaW5nV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRFZGdlc092ZXJsYXBwaW5nV2l0aChvYmplY3QsIG92ZXJsYXBwaW5nRWRnZXMpIHtcbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5LmVkZ2VJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlZGdlSWQgPSB0aGlzLmJvZHkuZWRnZUluZGljZXNbaV07XG4gICAgICAgIGlmIChlZGdlc1tlZGdlSWRdLmlzT3ZlcmxhcHBpbmdXaXRoKG9iamVjdCkpIHtcbiAgICAgICAgICBvdmVybGFwcGluZ0VkZ2VzLnB1c2goZWRnZUlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHJpZXZlIGFsbCBub2RlcyBvdmVybGFwcGluZyB3aXRoIGdpdmVuIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgIEFuIG9iamVjdCB3aXRoIHBhcmFtZXRlcnMgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tXG4gICAgICogQHJldHVybiB7bnVtYmVyW119ICAgQW4gYXJyYXkgd2l0aCBpZCdzIG9mIHRoZSBvdmVybGFwcGluZyBub2Rlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19nZXRBbGxFZGdlc092ZXJsYXBwaW5nV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRBbGxFZGdlc092ZXJsYXBwaW5nV2l0aChvYmplY3QpIHtcbiAgICAgIHZhciBvdmVybGFwcGluZ0VkZ2VzID0gW107XG4gICAgICB0aGlzLl9nZXRFZGdlc092ZXJsYXBwaW5nV2l0aChvYmplY3QsIG92ZXJsYXBwaW5nRWRnZXMpO1xuICAgICAgcmV0dXJuIG92ZXJsYXBwaW5nRWRnZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBlZGdlcyBuZWFyZXN0IHRvIHRoZSBwYXNzZWQgcG9pbnQgKGxpa2UgYSBjbGljaylcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gcG9pbnRlclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldHVybkVkZ2U9dHJ1ZV1cbiAgICAgKiBAcmV0dXJuIHtFZGdlIHwgdW5kZWZpbmVkfSBub2RlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldEVkZ2VBdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVkZ2VBdChwb2ludGVyKSB7XG4gICAgICB2YXIgcmV0dXJuRWRnZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcblxuICAgICAgLy8gSXRlcmF0ZSBvdmVyIGVkZ2VzLCBwaWNrIGNsb3Nlc3Qgd2l0aGluIDEwXG4gICAgICB2YXIgY2FudmFzUG9zID0gdGhpcy5jYW52YXMuRE9NdG9DYW52YXMocG9pbnRlcik7XG4gICAgICB2YXIgbWluZGlzdCA9IDEwO1xuICAgICAgdmFyIG92ZXJsYXBwaW5nRWRnZSA9IG51bGw7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9keS5lZGdlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWRnZUlkID0gdGhpcy5ib2R5LmVkZ2VJbmRpY2VzW2ldO1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2VkZ2VJZF07XG4gICAgICAgIGlmIChlZGdlLmNvbm5lY3RlZCkge1xuICAgICAgICAgIHZhciB4RnJvbSA9IGVkZ2UuZnJvbS54O1xuICAgICAgICAgIHZhciB5RnJvbSA9IGVkZ2UuZnJvbS55O1xuICAgICAgICAgIHZhciB4VG8gPSBlZGdlLnRvLng7XG4gICAgICAgICAgdmFyIHlUbyA9IGVkZ2UudG8ueTtcbiAgICAgICAgICB2YXIgZGlzdCA9IGVkZ2UuZWRnZVR5cGUuZ2V0RGlzdGFuY2VUb0VkZ2UoeEZyb20sIHlGcm9tLCB4VG8sIHlUbywgY2FudmFzUG9zLngsIGNhbnZhc1Bvcy55KTtcbiAgICAgICAgICBpZiAoZGlzdCA8IG1pbmRpc3QpIHtcbiAgICAgICAgICAgIG92ZXJsYXBwaW5nRWRnZSA9IGVkZ2VJZDtcbiAgICAgICAgICAgIG1pbmRpc3QgPSBkaXN0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG92ZXJsYXBwaW5nRWRnZSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAocmV0dXJuRWRnZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmJvZHkuZWRnZXNbb3ZlcmxhcHBpbmdFZGdlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gb3ZlcmxhcHBpbmdFZGdlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBvYmplY3QgdG8gdGhlIHNlbGVjdGlvbiBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfYWRkVG9TZWxlY3Rpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkVG9TZWxlY3Rpb24ob2JqKSB7XG4gICAgICBpZiAob2JqIGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbk9iai5ub2Rlc1tvYmouaWRdID0gb2JqO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25PYmouZWRnZXNbb2JqLmlkXSA9IG9iajtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgb2JqZWN0IHRvIHRoZSBzZWxlY3Rpb24gYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2FkZFRvSG92ZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkVG9Ib3ZlcihvYmopIHtcbiAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgIHRoaXMuaG92ZXJPYmoubm9kZXNbb2JqLmlkXSA9IG9iajtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaG92ZXJPYmouZWRnZXNbb2JqLmlkXSA9IG9iajtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBzaW5nbGUgb3B0aW9uIGZyb20gc2VsZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19yZW1vdmVGcm9tU2VsZWN0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZUZyb21TZWxlY3Rpb24ob2JqKSB7XG4gICAgICBpZiAob2JqIGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICBkZWxldGUgdGhpcy5zZWxlY3Rpb25PYmoubm9kZXNbb2JqLmlkXTtcbiAgICAgICAgdGhpcy5fdW5zZWxlY3RDb25uZWN0ZWRFZGdlcyhvYmopO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuc2VsZWN0aW9uT2JqLmVkZ2VzW29iai5pZF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5zZWxlY3QgYWxsLiBUaGUgc2VsZWN0aW9uT2JqIGlzIHVzZWZ1bCBmb3IgdGhpcy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndW5zZWxlY3RBbGwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnNlbGVjdEFsbCgpIHtcbiAgICAgIGZvciAodmFyIG5vZGVJZCBpbiB0aGlzLnNlbGVjdGlvbk9iai5ub2Rlcykge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25PYmoubm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uT2JqLm5vZGVzW25vZGVJZF0udW5zZWxlY3QoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgZWRnZUlkIGluIHRoaXMuc2VsZWN0aW9uT2JqLmVkZ2VzKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk9iai5lZGdlcy5oYXNPd25Qcm9wZXJ0eShlZGdlSWQpKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25PYmouZWRnZXNbZWRnZUlkXS51bnNlbGVjdCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2VsZWN0aW9uT2JqID0geyBub2Rlczoge30sIGVkZ2VzOiB7fSB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHVybiB0aGUgbnVtYmVyIG9mIHNlbGVjdGVkIG5vZGVzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19nZXRTZWxlY3RlZE5vZGVDb3VudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRTZWxlY3RlZE5vZGVDb3VudCgpIHtcbiAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICBmb3IgKHZhciBub2RlSWQgaW4gdGhpcy5zZWxlY3Rpb25PYmoubm9kZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uT2JqLm5vZGVzLmhhc093blByb3BlcnR5KG5vZGVJZCkpIHtcbiAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY291bnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRoZSBzZWxlY3RlZCBub2RlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19nZXRTZWxlY3RlZE5vZGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0U2VsZWN0ZWROb2RlKCkge1xuICAgICAgZm9yICh2YXIgbm9kZUlkIGluIHRoaXMuc2VsZWN0aW9uT2JqLm5vZGVzKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk9iai5ub2Rlcy5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uT2JqLm5vZGVzW25vZGVJZF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRoZSBzZWxlY3RlZCBlZGdlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19nZXRTZWxlY3RlZEVkZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0U2VsZWN0ZWRFZGdlKCkge1xuICAgICAgZm9yICh2YXIgZWRnZUlkIGluIHRoaXMuc2VsZWN0aW9uT2JqLmVkZ2VzKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk9iai5lZGdlcy5oYXNPd25Qcm9wZXJ0eShlZGdlSWQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uT2JqLmVkZ2VzW2VkZ2VJZF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRoZSBudW1iZXIgb2Ygc2VsZWN0ZWQgZWRnZXNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2dldFNlbGVjdGVkRWRnZUNvdW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFNlbGVjdGVkRWRnZUNvdW50KCkge1xuICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgIGZvciAodmFyIGVkZ2VJZCBpbiB0aGlzLnNlbGVjdGlvbk9iai5lZGdlcykge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25PYmouZWRnZXMuaGFzT3duUHJvcGVydHkoZWRnZUlkKSkge1xuICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gdGhlIG51bWJlciBvZiBzZWxlY3RlZCBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZ2V0U2VsZWN0ZWRPYmplY3RDb3VudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRTZWxlY3RlZE9iamVjdENvdW50KCkge1xuICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgIGZvciAodmFyIG5vZGVJZCBpbiB0aGlzLnNlbGVjdGlvbk9iai5ub2Rlcykge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25PYmoubm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGVkZ2VJZCBpbiB0aGlzLnNlbGVjdGlvbk9iai5lZGdlcykge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25PYmouZWRnZXMuaGFzT3duUHJvcGVydHkoZWRnZUlkKSkge1xuICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhbnl0aGluZyBpcyBzZWxlY3RlZFxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3NlbGVjdGlvbklzRW1wdHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2VsZWN0aW9uSXNFbXB0eSgpIHtcbiAgICAgIGZvciAodmFyIG5vZGVJZCBpbiB0aGlzLnNlbGVjdGlvbk9iai5ub2Rlcykge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25PYmoubm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgZWRnZUlkIGluIHRoaXMuc2VsZWN0aW9uT2JqLmVkZ2VzKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk9iai5lZGdlcy5oYXNPd25Qcm9wZXJ0eShlZGdlSWQpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjaGVjayBpZiBvbmUgb2YgdGhlIHNlbGVjdGVkIG5vZGVzIGlzIGEgY2x1c3Rlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19jbHVzdGVySW5TZWxlY3Rpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2x1c3RlckluU2VsZWN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgbm9kZUlkIGluIHRoaXMuc2VsZWN0aW9uT2JqLm5vZGVzKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk9iai5ub2Rlcy5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uT2JqLm5vZGVzW25vZGVJZF0uY2x1c3RlclNpemUgPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZWxlY3QgdGhlIGVkZ2VzIGNvbm5lY3RlZCB0byB0aGUgbm9kZSB0aGF0IGlzIGJlaW5nIHNlbGVjdGVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfc2VsZWN0Q29ubmVjdGVkRWRnZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2VsZWN0Q29ubmVjdGVkRWRnZXMobm9kZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlZGdlID0gbm9kZS5lZGdlc1tpXTtcbiAgICAgICAgZWRnZS5zZWxlY3QoKTtcbiAgICAgICAgdGhpcy5fYWRkVG9TZWxlY3Rpb24oZWRnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2VsZWN0IHRoZSBlZGdlcyBjb25uZWN0ZWQgdG8gdGhlIG5vZGUgdGhhdCBpcyBiZWluZyBzZWxlY3RlZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2hvdmVyQ29ubmVjdGVkRWRnZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaG92ZXJDb25uZWN0ZWRFZGdlcyhub2RlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBub2RlLmVkZ2VzW2ldO1xuICAgICAgICBlZGdlLmhvdmVyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fYWRkVG9Ib3ZlcihlZGdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB1bnNlbGVjdCB0aGUgZWRnZXMgY29ubmVjdGVkIHRvIHRoZSBub2RlIHRoYXQgaXMgYmVpbmcgc2VsZWN0ZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ191bnNlbGVjdENvbm5lY3RlZEVkZ2VzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Vuc2VsZWN0Q29ubmVjdGVkRWRnZXMobm9kZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlZGdlID0gbm9kZS5lZGdlc1tpXTtcbiAgICAgICAgZWRnZS51bnNlbGVjdCgpO1xuICAgICAgICB0aGlzLl9yZW1vdmVGcm9tU2VsZWN0aW9uKGVkZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGUgaGlnaGxpZ2h0IGZyb20gYSBub2RlIG9yIGVkZ2UsIGluIHJlc3BvbnNlIHRvIG1vdXNlIG1vdmVtZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSAgZXZlbnRcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvaW50ZXIgb2JqZWN0IHdpdGggdGhlIHggYW5kIHkgc2NyZWVuIGNvb3JkaW5hdGVzIG9mIHRoZSBtb3VzZVxuICAgICAqIEBwYXJhbSB7Tm9kZXx2aXMuRWRnZX0gb2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZW1pdEJsdXJFdmVudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVtaXRCbHVyRXZlbnQoZXZlbnQsIHBvaW50ZXIsIG9iamVjdCkge1xuICAgICAgdmFyIHByb3BlcnRpZXMgPSB0aGlzLl9pbml0QmFzZUV2ZW50KGV2ZW50LCBwb2ludGVyKTtcblxuICAgICAgaWYgKG9iamVjdC5ob3ZlciA9PT0gdHJ1ZSkge1xuICAgICAgICBvYmplY3QuaG92ZXIgPSBmYWxzZTtcbiAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgICAgICBwcm9wZXJ0aWVzLm5vZGUgPSBvYmplY3QuaWQ7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnYmx1ck5vZGUnLCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wZXJ0aWVzLmVkZ2UgPSBvYmplY3QuaWQ7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnYmx1ckVkZ2UnLCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgaGlnaGxpZ2h0IGZvciBhIG5vZGUgb3IgZWRnZSwgaW4gcmVzcG9uc2UgdG8gbW91c2UgbW92ZW1lbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9ICBldmVudFxuICAgICAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gcG9pbnRlciBvYmplY3Qgd2l0aCB0aGUgeCBhbmQgeSBzY3JlZW4gY29vcmRpbmF0ZXMgb2YgdGhlIG1vdXNlXG4gICAgICogQHBhcmFtIHtOb2RlfHZpcy5FZGdlfSBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gaG92ZXJDaGFuZ2VkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZW1pdEhvdmVyRXZlbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbWl0SG92ZXJFdmVudChldmVudCwgcG9pbnRlciwgb2JqZWN0KSB7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMuX2luaXRCYXNlRXZlbnQoZXZlbnQsIHBvaW50ZXIpO1xuICAgICAgdmFyIGhvdmVyQ2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAob2JqZWN0LmhvdmVyID09PSBmYWxzZSkge1xuICAgICAgICBvYmplY3QuaG92ZXIgPSB0cnVlO1xuICAgICAgICB0aGlzLl9hZGRUb0hvdmVyKG9iamVjdCk7XG4gICAgICAgIGhvdmVyQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgICAgcHJvcGVydGllcy5ub2RlID0gb2JqZWN0LmlkO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ2hvdmVyTm9kZScsIHByb3BlcnRpZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BlcnRpZXMuZWRnZSA9IG9iamVjdC5pZDtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdob3ZlckVkZ2UnLCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaG92ZXJDaGFuZ2VkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYWN0aW9ucyBpbiByZXNwb25zZSB0byBhIG1vdXNlIG1vdmVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gIGV2ZW50XG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwb2ludGVyIHwgb2JqZWN0IHdpdGggdGhlIHggYW5kIHkgc2NyZWVuIGNvb3JkaW5hdGVzIG9mIHRoZSBtb3VzZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdob3Zlck9iamVjdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhvdmVyT2JqZWN0KGV2ZW50LCBwb2ludGVyKSB7XG4gICAgICB2YXIgb2JqZWN0ID0gdGhpcy5nZXROb2RlQXQocG9pbnRlcik7XG4gICAgICBpZiAob2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb2JqZWN0ID0gdGhpcy5nZXRFZGdlQXQocG9pbnRlcik7XG4gICAgICB9XG5cbiAgICAgIHZhciBob3ZlckNoYW5nZWQgPSBmYWxzZTtcbiAgICAgIC8vIHJlbW92ZSBhbGwgbm9kZSBob3ZlciBoaWdobGlnaHRzXG4gICAgICBmb3IgKHZhciBub2RlSWQgaW4gdGhpcy5ob3Zlck9iai5ub2Rlcykge1xuICAgICAgICBpZiAodGhpcy5ob3Zlck9iai5ub2Rlcy5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgaWYgKG9iamVjdCA9PT0gdW5kZWZpbmVkIHx8IG9iamVjdCBpbnN0YW5jZW9mIE5vZGUgJiYgb2JqZWN0LmlkICE9IG5vZGVJZCB8fCBvYmplY3QgaW5zdGFuY2VvZiBFZGdlKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXRCbHVyRXZlbnQoZXZlbnQsIHBvaW50ZXIsIHRoaXMuaG92ZXJPYmoubm9kZXNbbm9kZUlkXSk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5ob3Zlck9iai5ub2Rlc1tub2RlSWRdO1xuICAgICAgICAgICAgaG92ZXJDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gcmVtb3ZpbmcgYWxsIGVkZ2UgaG92ZXIgaGlnaGxpZ2h0c1xuICAgICAgZm9yICh2YXIgZWRnZUlkIGluIHRoaXMuaG92ZXJPYmouZWRnZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuaG92ZXJPYmouZWRnZXMuaGFzT3duUHJvcGVydHkoZWRnZUlkKSkge1xuICAgICAgICAgIC8vIGlmIHRoZSBob3ZlciBoYXMgYmVlbiBjaGFuZ2VkIGhlcmUgaXQgbWVhbnMgdGhhdCB0aGUgbm9kZSBoYXMgYmVlbiBob3ZlcmVkIG92ZXIgb3Igb2ZmXG4gICAgICAgICAgLy8gd2UgdGhlbiBkbyBub3QgdXNlIHRoZSBlbWl0Qmx1ckV2ZW50IG1ldGhvZCBoZXJlLlxuICAgICAgICAgIGlmIChob3ZlckNoYW5nZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuaG92ZXJPYmouZWRnZXNbZWRnZUlkXS5ob3ZlciA9IGZhbHNlO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuaG92ZXJPYmouZWRnZXNbZWRnZUlkXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gaWYgdGhlIGJsdXIgcmVtYWlucyB0aGUgc2FtZSBhbmQgdGhlIG9iamVjdCBpcyB1bmRlZmluZWQgKG1vdXNlIG9mZikgb3IgYW5vdGhlclxuICAgICAgICAgIC8vIGVkZ2UgaGFzIGJlZW4gaG92ZXJlZCwgb3IgYW5vdGhlciBub2RlIGhhcyBiZWVuIGhvdmVyZWQgd2UgYmx1ciB0aGUgZWRnZS5cbiAgICAgICAgICBlbHNlIGlmIChvYmplY3QgPT09IHVuZGVmaW5lZCB8fCBvYmplY3QgaW5zdGFuY2VvZiBFZGdlICYmIG9iamVjdC5pZCAhPSBlZGdlSWQgfHwgb2JqZWN0IGluc3RhbmNlb2YgTm9kZSAmJiAhb2JqZWN0LmhvdmVyKSB7XG4gICAgICAgICAgICAgIHRoaXMuZW1pdEJsdXJFdmVudChldmVudCwgcG9pbnRlciwgdGhpcy5ob3Zlck9iai5lZGdlc1tlZGdlSWRdKTtcbiAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuaG92ZXJPYmouZWRnZXNbZWRnZUlkXTtcbiAgICAgICAgICAgICAgaG92ZXJDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob2JqZWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGhvdmVyZWRFZGdlc0NvdW50ID0gKDAsIF9rZXlzMlsnZGVmYXVsdCddKSh0aGlzLmhvdmVyT2JqLmVkZ2VzKS5sZW5ndGg7XG4gICAgICAgIHZhciBob3ZlcmVkTm9kZXNDb3VudCA9ICgwLCBfa2V5czJbJ2RlZmF1bHQnXSkodGhpcy5ob3Zlck9iai5ub2RlcykubGVuZ3RoO1xuICAgICAgICB2YXIgbmV3T25seUhvdmVyZWRFZGdlID0gb2JqZWN0IGluc3RhbmNlb2YgRWRnZSAmJiBob3ZlcmVkRWRnZXNDb3VudCA9PT0gMCAmJiBob3ZlcmVkTm9kZXNDb3VudCA9PT0gMDtcblxuICAgICAgICBpZiAoaG92ZXJDaGFuZ2VkIHx8IG5ld09ubHlIb3ZlcmVkRWRnZSkge1xuICAgICAgICAgIGhvdmVyQ2hhbmdlZCA9IHRoaXMuZW1pdEhvdmVyRXZlbnQoZXZlbnQsIHBvaW50ZXIsIG9iamVjdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgTm9kZSAmJiB0aGlzLm9wdGlvbnMuaG92ZXJDb25uZWN0ZWRFZGdlcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuX2hvdmVyQ29ubmVjdGVkRWRnZXMob2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaG92ZXJDaGFuZ2VkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19yZXF1ZXN0UmVkcmF3Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiByZXRyaWV2ZSB0aGUgY3VycmVudGx5IHNlbGVjdGVkIG9iamVjdHNcbiAgICAgKiBAcmV0dXJuIHt7bm9kZXM6IEFycmF5LjxzdHJpbmc+LCBlZGdlczogQXJyYXkuPHN0cmluZz59fSBzZWxlY3Rpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0U2VsZWN0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2VsZWN0aW9uKCkge1xuICAgICAgdmFyIG5vZGVJZHMgPSB0aGlzLmdldFNlbGVjdGVkTm9kZXMoKTtcbiAgICAgIHZhciBlZGdlSWRzID0gdGhpcy5nZXRTZWxlY3RlZEVkZ2VzKCk7XG4gICAgICByZXR1cm4geyBub2Rlczogbm9kZUlkcywgZWRnZXM6IGVkZ2VJZHMgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIHJldHJpZXZlIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgbm9kZXNcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmdbXX0gc2VsZWN0aW9uICAgIEFuIGFycmF5IHdpdGggdGhlIGlkcyBvZiB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQgbm9kZXMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldFNlbGVjdGVkTm9kZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTZWxlY3RlZE5vZGVzKCkge1xuICAgICAgdmFyIGlkQXJyYXkgPSBbXTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2VsZWN0YWJsZSA9PT0gdHJ1ZSkge1xuICAgICAgICBmb3IgKHZhciBub2RlSWQgaW4gdGhpcy5zZWxlY3Rpb25PYmoubm9kZXMpIHtcbiAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25PYmoubm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgICAgaWRBcnJheS5wdXNoKHRoaXMuc2VsZWN0aW9uT2JqLm5vZGVzW25vZGVJZF0uaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGlkQXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiByZXRyaWV2ZSB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGVkZ2VzXG4gICAgICogQHJldHVybiB7QXJyYXl9IHNlbGVjdGlvbiAgICBBbiBhcnJheSB3aXRoIHRoZSBpZHMgb2YgdGhlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkIG5vZGVzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRTZWxlY3RlZEVkZ2VzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2VsZWN0ZWRFZGdlcygpIHtcbiAgICAgIHZhciBpZEFycmF5ID0gW107XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNlbGVjdGFibGUgPT09IHRydWUpIHtcbiAgICAgICAgZm9yICh2YXIgZWRnZUlkIGluIHRoaXMuc2VsZWN0aW9uT2JqLmVkZ2VzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uT2JqLmVkZ2VzLmhhc093blByb3BlcnR5KGVkZ2VJZCkpIHtcbiAgICAgICAgICAgIGlkQXJyYXkucHVzaCh0aGlzLnNlbGVjdGlvbk9iai5lZGdlc1tlZGdlSWRdLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpZEFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG4gICAgICogQHBhcmFtIHt7bm9kZXM6IEFycmF5LjxzdHJpbmc+LCBlZGdlczogQXJyYXkuPHN0cmluZz59fSBzZWxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9wdGlvbnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0U2VsZWN0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U2VsZWN0aW9uKHNlbGVjdGlvbikge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICB2YXIgaSA9IHZvaWQgMCxcbiAgICAgICAgICBpZCA9IHZvaWQgMDtcblxuICAgICAgaWYgKCFzZWxlY3Rpb24gfHwgIXNlbGVjdGlvbi5ub2RlcyAmJiAhc2VsZWN0aW9uLmVkZ2VzKSB0aHJvdyAnU2VsZWN0aW9uIG11c3QgYmUgYW4gb2JqZWN0IHdpdGggbm9kZXMgYW5kL29yIGVkZ2VzIHByb3BlcnRpZXMnO1xuICAgICAgLy8gZmlyc3QgdW5zZWxlY3QgYW55IHNlbGVjdGVkIG5vZGUsIGlmIG9wdGlvbiBpcyB0cnVlIG9yIHVuZGVmaW5lZFxuICAgICAgaWYgKG9wdGlvbnMudW5zZWxlY3RBbGwgfHwgb3B0aW9ucy51bnNlbGVjdEFsbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMudW5zZWxlY3RBbGwoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxlY3Rpb24ubm9kZXMpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlbGVjdGlvbi5ub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlkID0gc2VsZWN0aW9uLm5vZGVzW2ldO1xuXG4gICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbaWRdO1xuICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ05vZGUgd2l0aCBpZCBcIicgKyBpZCArICdcIiBub3QgZm91bmQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZG9uJ3Qgc2VsZWN0IGVkZ2VzIHdpdGggaXRcbiAgICAgICAgICB0aGlzLnNlbGVjdE9iamVjdChub2RlLCBvcHRpb25zLmhpZ2hsaWdodEVkZ2VzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZWN0aW9uLmVkZ2VzKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWxlY3Rpb24uZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZCA9IHNlbGVjdGlvbi5lZGdlc1tpXTtcblxuICAgICAgICAgIHZhciBlZGdlID0gdGhpcy5ib2R5LmVkZ2VzW2lkXTtcbiAgICAgICAgICBpZiAoIWVkZ2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdFZGdlIHdpdGggaWQgXCInICsgaWQgKyAnXCIgbm90IGZvdW5kJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc2VsZWN0T2JqZWN0KGVkZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfcmVxdWVzdFJlZHJhdycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNlbGVjdCB6ZXJvIG9yIG1vcmUgbm9kZXMgd2l0aCB0aGUgb3B0aW9uIHRvIGhpZ2hsaWdodCBlZGdlc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyW10gfCBzdHJpbmdbXX0gc2VsZWN0aW9uICAgICBBbiBhcnJheSB3aXRoIHRoZSBpZHMgb2YgdGhlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkIG5vZGVzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hpZ2hsaWdodEVkZ2VzXVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZWxlY3ROb2RlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdE5vZGVzKHNlbGVjdGlvbikge1xuICAgICAgdmFyIGhpZ2hsaWdodEVkZ2VzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuXG4gICAgICBpZiAoIXNlbGVjdGlvbiB8fCBzZWxlY3Rpb24ubGVuZ3RoID09PSB1bmRlZmluZWQpIHRocm93ICdTZWxlY3Rpb24gbXVzdCBiZSBhbiBhcnJheSB3aXRoIGlkcyc7XG5cbiAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKHsgbm9kZXM6IHNlbGVjdGlvbiB9LCB7IGhpZ2hsaWdodEVkZ2VzOiBoaWdobGlnaHRFZGdlcyB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZWxlY3QgemVybyBvciBtb3JlIGVkZ2VzXG4gICAgICogQHBhcmFtIHtudW1iZXJbXSB8IHN0cmluZ1tdfSBzZWxlY3Rpb24gICAgIEFuIGFycmF5IHdpdGggdGhlIGlkcyBvZiB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQgbm9kZXMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NlbGVjdEVkZ2VzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0RWRnZXMoc2VsZWN0aW9uKSB7XG4gICAgICBpZiAoIXNlbGVjdGlvbiB8fCBzZWxlY3Rpb24ubGVuZ3RoID09PSB1bmRlZmluZWQpIHRocm93ICdTZWxlY3Rpb24gbXVzdCBiZSBhbiBhcnJheSB3aXRoIGlkcyc7XG5cbiAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKHsgZWRnZXM6IHNlbGVjdGlvbiB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSB0aGUgc2VsZWN0aW9uOiByZW1vdmUgaWRzIG9mIG5vZGVzIHdoaWNoIG5vIGxvbmdlciBleGlzdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZVNlbGVjdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVNlbGVjdGlvbigpIHtcbiAgICAgIGZvciAodmFyIG5vZGVJZCBpbiB0aGlzLnNlbGVjdGlvbk9iai5ub2Rlcykge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25PYmoubm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgIGlmICghdGhpcy5ib2R5Lm5vZGVzLmhhc093blByb3BlcnR5KG5vZGVJZCkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNlbGVjdGlvbk9iai5ub2Rlc1tub2RlSWRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgZWRnZUlkIGluIHRoaXMuc2VsZWN0aW9uT2JqLmVkZ2VzKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk9iai5lZGdlcy5oYXNPd25Qcm9wZXJ0eShlZGdlSWQpKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLmJvZHkuZWRnZXMuaGFzT3duUHJvcGVydHkoZWRnZUlkKSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2VsZWN0aW9uT2JqLmVkZ2VzW2VkZ2VJZF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIGFsbCB0aGUgdmlzdWFsIGVsZW1lbnRzIGNsaWNrZWQgd2hpY2ggYXJlIG9uIHRoZSBnaXZlbiBwb2ludC5cbiAgICAgKlxuICAgICAqIEFsbCBlbGVtZW50cyBhcmUgcmV0dXJuZWQ7IHRoaXMgaW5jbHVkZXMgbm9kZXMsIGVkZ2VzIGFuZCB0aGVpciBsYWJlbHMuXG4gICAgICogVGhlIG9yZGVyIHJldHVybmVkIGlzIGZyb20gaGlnaGVzdCB0byBsb3dlc3QsIGkuZS4gZWxlbWVudCAwIG9mIHRoZSByZXR1cm5cbiAgICAgKiB2YWx1ZSBpcyB0aGUgdG9wbW9zdCBpdGVtIGNsaWNrZWQgb24uXG4gICAgICpcbiAgICAgKiBUaGUgcmV0dXJuIHZhbHVlIGNvbnNpc3RzIG9mIGFuIGFycmF5IG9mIHRoZSBmb2xsb3dpbmcgcG9zc2libGUgZWxlbWVudHM6XG4gICAgICpcbiAgICAgKiAtIGB7bm9kZUlkOm51bWJlcn1gICAgICAgICAgICAgIC0gbm9kZSB3aXRoIGdpdmVuIGlkIGNsaWNrZWQgb25cbiAgICAgKiAtIGB7bm9kZUlkOm51bWJlciwgbGFiZWxJZDowfWAgIC0gbGFiZWwgb2Ygbm9kZSB3aXRoIGdpdmVuIGlkIGNsaWNrZWQgb25cbiAgICAgKiAtIGB7ZWRnZUlkOm51bWJlcn1gICAgICAgICAgICAgIC0gZWRnZSB3aXRoIGdpdmVuIGlkIGNsaWNrZWQgb25cbiAgICAgKiAtIGB7ZWRnZTpudW1iZXIsIGxhYmVsSWQ6MH1gICAgIC0gbGFiZWwgb2YgZWRnZSB3aXRoIGdpdmVuIGlkIGNsaWNrZWQgb25cbiAgICAgKlxuICAgICAqICMjIE5PVEVTXG4gICAgICpcbiAgICAgKiAtIEN1cnJlbnRseSwgdGhlcmUgaXMgb25seSBvbmUgbGFiZWwgYXNzb2NpYXRlZCB3aXRoIGEgbm9kZSBvciBhbiBlZGdlLFxuICAgICAqICAgYnV0IHRoaXMgaXMgZXhwZWN0ZWQgdG8gY2hhbmdlIHNvbWV3aGVyZSBpbiB0aGUgZnV0dXJlLlxuICAgICAqIC0gU2luY2UgdGhlcmUgaXMgbm8gei1pbmRleGluZyB5ZXQsIGl0IGlzIG5vdCByZWFsbHkgcG9zc2libGUgdG8gc2V0IHRoZSBub2RlcyBhbmRcbiAgICAgKiAgIGVkZ2VzIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBGb3IgdGhlIHRpbWUgYmVpbmcsIG5vZGVzIGNvbWUgZmlyc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3BvaW50fSBwb2ludGVyICBtb3VzZSBwb3NpdGlvbiBpbiBzY3JlZW4gY29vcmRpbmF0ZXNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG5vZGVDbGlja0l0ZW18bm9kZUxhYmVsQ2xpY2tJdGVtfGVkZ2VDbGlja0l0ZW18ZWRnZUxhYmVsQ2xpY2tJdGVtPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRDbGlja2VkSXRlbXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDbGlja2VkSXRlbXMocG9pbnRlcikge1xuICAgICAgdmFyIHBvaW50ID0gdGhpcy5jYW52YXMuRE9NdG9DYW52YXMocG9pbnRlcik7XG4gICAgICB2YXIgaXRlbXMgPSBbXTtcblxuICAgICAgLy8gTm90ZSByZXZlcnNlIG9yZGVyOyB3ZSB3YW50IHRoZSB0b3Btb3N0IGNsaWNrZWQgaXRlbXMgdG8gYmUgZmlyc3QgaW4gdGhlIGFycmF5XG4gICAgICAvLyBBbHNvIG5vdGUgdGhhdCBzZWxlY3RlZCBub2RlcyBhcmUgZGlzcmVnYXJkZWQgaGVyZTsgdGhlc2Ugbm9ybWFsbHkgZGlzcGxheSBvbiB0b3BcbiAgICAgIHZhciBub2RlSW5kaWNlcyA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcztcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIGZvciAodmFyIGkgPSBub2RlSW5kaWNlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW25vZGVJbmRpY2VzW2ldXTtcbiAgICAgICAgdmFyIHJldCA9IG5vZGUuZ2V0SXRlbXNPblBvaW50KHBvaW50KTtcbiAgICAgICAgaXRlbXMucHVzaC5hcHBseShpdGVtcywgcmV0KTsgLy8gQXBwZW5kIHRoZSByZXR1cm4gdmFsdWUgdG8gdGhlIHJ1bm5pbmcgbGlzdC5cbiAgICAgIH1cblxuICAgICAgdmFyIGVkZ2VJbmRpY2VzID0gdGhpcy5ib2R5LmVkZ2VJbmRpY2VzO1xuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuICAgICAgZm9yICh2YXIgX2kgPSBlZGdlSW5kaWNlcy5sZW5ndGggLSAxOyBfaSA+PSAwOyBfaS0tKSB7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbZWRnZUluZGljZXNbX2ldXTtcbiAgICAgICAgdmFyIF9yZXQgPSBlZGdlLmdldEl0ZW1zT25Qb2ludChwb2ludCk7XG4gICAgICAgIGl0ZW1zLnB1c2guYXBwbHkoaXRlbXMsIF9yZXQpOyAvLyBBcHBlbmQgdGhlIHJldHVybiB2YWx1ZSB0byB0aGUgcnVubmluZyBsaXN0LlxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXRlbXM7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBTZWxlY3Rpb25IYW5kbGVyO1xufSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBTZWxlY3Rpb25IYW5kbGVyO1xuXG4vKioqLyB9KSxcbi8qIDE4NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogVGhlcmUncyBhIG1peC11cCB3aXRoIHRlcm1zIGluIHRoZSBjb2RlLiBGb2xsb3dpbmcgYXJlIHRoZSBmb3JtYWwgZGVmaW5pdGlvbnM6XG4gKlxuICogICB0cmVlICAgLSBhIHN0cmljdCBoaWVyYXJjaGljYWwgbmV0d29yaywgaS5lLiBldmVyeSBub2RlIGhhcyBhdCBtb3N0IG9uZSBwYXJlbnRcbiAqICAgZm9yZXN0IC0gYSBjb2xsZWN0aW9uIG9mIHRyZWVzLiBUaGVzZSBkaXN0aW5jdCB0cmVlcyBhcmUgdGh1cyBub3QgY29ubmVjdGVkLlxuICpcbiAqIFNvOlxuICogLSBpbiBhIG5ldHdvcmsgdGhhdCBpcyBub3QgYSB0cmVlLCB0aGVyZSBleGlzdCBub2RlcyB3aXRoIG11bHRpcGxlIHBhcmVudHMuXG4gKiAtIGEgbmV0d29yayBjb25zaXN0aW5nIG9mIHVuY29ubmVjdGVkIHN1Yi1uZXR3b3Jrcywgb2Ygd2hpY2ggYXQgbGVhc3Qgb25lXG4gKiAgIGlzIG5vdCBhIHRyZWUsIGlzIG5vdCBhIGZvcmVzdC5cbiAqXG4gKiBJbiB0aGUgY29kZSwgdGhlIGRlZmluaXRpb25zIGFyZTpcbiAqXG4gKiAgIHRyZWUgICAtIGFueSBkaXNjb25uZWN0ZWQgc3ViLW5ldHdvcmssIHN0cmljdCBoaWVyYXJjaGljYWwgb3Igbm90LlxuICogICBmb3Jlc3QgLSBhIGJ1bmNoIG9mIHRoZXNlIHN1Yi1uZXR3b3Jrc1xuICpcbiAqIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdHJlZSBhbmQgbm90LXRyZWUgaXMgaW1wb3J0YW50IGluIHRoZSBjb2RlLCBub3RhYmx5IHdpdGhpblxuICogdG8gdGhlIGJsb2NrLXNoaWZ0aW5nIGFsZ29yaXRobS4gVGhlIGFsZ29yaXRobSBhc3N1bWVzIGZvcm1hbCB0cmVlcyBhbmQgZmFpbHNcbiAqIGZvciBub3QtdHJlZXMsIG9mdGVuIGluIGEgc3BlY3RhY3VsYXIgbWFubmVyIChzZWFyY2ggZm9yICdleHBsb2RpbmcgbmV0d29yaycgaW4gdGhlIGlzc3VlcykuXG4gKlxuICogSW4gb3JkZXIgdG8gZGlzdGluZ3Vpc2ggdGhlIGRlZmluaXRpb25zIGluIHRoZSBmb2xsb3dpbmcgY29kZSwgdGhlIGFkamVjdGl2ZSAnZm9ybWFsJyBpc1xuICogdXNlZC4gSWYgJ2Zvcm1hbCcgaXMgYWJzZW50LCB5b3UgbXVzdCBhc3N1bWUgdGhlIG5vbi1mb3JtYWwgZGVmaW5pdGlvbi5cbiAqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBOT1RFU1xuICogPT09PT1cbiAqXG4gKiBBIGhpZXJhcmNoaWNhbCBsYXlvdXQgaXMgYSBkaWZmZXJlbnQgdGhpbmcgZnJvbSBhIGhpZXJhcmNoaWNhbCBuZXR3b3JrLlxuICogVGhlIGxheW91dCBpcyBhIHdheSB0byBhcnJhbmdlIHRoZSBub2RlcyBpbiB0aGUgdmlldzsgdGhpcyBjYW4gYmUgZG9uZVxuICogb24gbm9uLWhpZXJhcmNoaWNhbCBuZXR3b3JrcyBhcyB3ZWxsLiBUaGUgY29udmVyc2UgaXMgYWxzbyBwb3NzaWJsZS5cbiAqL1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfc2xpY2VkVG9BcnJheTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblxudmFyIF9zbGljZWRUb0FycmF5MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NsaWNlZFRvQXJyYXkyKTtcblxudmFyIF90eXBlb2YyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxudmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mMik7XG5cbnZhciBfa2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBfa2V5czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9rZXlzKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBUaW1Tb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4Myk7XG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgTmV0d29ya1V0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3KVsnZGVmYXVsdCddO1xuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4OSksXG4gICAgSG9yaXpvbnRhbFN0cmF0ZWd5ID0gX3JlcXVpcmUuSG9yaXpvbnRhbFN0cmF0ZWd5LFxuICAgIFZlcnRpY2FsU3RyYXRlZ3kgPSBfcmVxdWlyZS5WZXJ0aWNhbFN0cmF0ZWd5O1xuXG4vKipcbiAqIENvbnRhaW5lciBmb3IgZGVyaXZlZCBkYXRhIG9uIGN1cnJlbnQgbmV0d29yaywgcmVsYXRpbmcgdG8gaGllcmFyY2h5LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cblxuXG52YXIgSGllcmFyY2hpY2FsU3RhdHVzID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgZnVuY3Rpb24gSGllcmFyY2hpY2FsU3RhdHVzKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIEhpZXJhcmNoaWNhbFN0YXR1cyk7XG5cbiAgICB0aGlzLmNoaWxkcmVuUmVmZXJlbmNlID0ge307IC8vIGNoaWxkIGlkJ3MgcGVyIG5vZGUgaWRcbiAgICB0aGlzLnBhcmVudFJlZmVyZW5jZSA9IHt9OyAvLyBwYXJlbnQgaWQncyBwZXIgbm9kZSBpZFxuICAgIHRoaXMudHJlZXMgPSB7fTsgLy8gdHJlZSBpZCBwZXIgbm9kZSBpZDsgaS5lLiB0byB3aGljaCB0cmVlIGRvZXMgZ2l2ZW4gbm9kZSBpZCBiZWxvbmdcblxuICAgIHRoaXMuZGlzdHJpYnV0aW9uT3JkZXJpbmcgPSB7fTsgLy8gVGhlIG5vZGVzIHBlciBsZXZlbCwgaW4gdGhlIGRpc3BsYXkgb3JkZXJcbiAgICB0aGlzLmxldmVscyA9IHt9OyAvLyBoaWVyYXJjaHkgbGV2ZWwgcGVyIG5vZGUgaWRcbiAgICB0aGlzLmRpc3RyaWJ1dGlvbkluZGV4ID0ge307IC8vIFRoZSBwb3NpdGlvbiBvZiB0aGUgbm9kZSBpbiB0aGUgbGV2ZWwgc29ydGluZyBvcmRlciwgcGVyIG5vZGUgaWQuXG5cbiAgICB0aGlzLmlzVHJlZSA9IGZhbHNlOyAvLyBUcnVlIGlmIGN1cnJlbnQgbmV0d29yayBpcyBhIGZvcm1hbCB0cmVlXG4gICAgdGhpcy50cmVlSW5kZXggPSAtMTsgLy8gSGlnaGVzdCB0cmVlIGlkIGluIGN1cnJlbnQgbmV0d29yay5cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgdGhlIHJlbGF0aW9uIGJldHdlZW4gZ2l2ZW4gbm9kZXMgdG8gdGhlIGN1cnJlbnQgc3RhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZS5pZH0gcGFyZW50Tm9kZUlkXG4gICAqIEBwYXJhbSB7Tm9kZS5pZH0gY2hpbGROb2RlSWRcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzM1snZGVmYXVsdCddKShIaWVyYXJjaGljYWxTdGF0dXMsIFt7XG4gICAga2V5OiAnYWRkUmVsYXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRSZWxhdGlvbihwYXJlbnROb2RlSWQsIGNoaWxkTm9kZUlkKSB7XG4gICAgICBpZiAodGhpcy5jaGlsZHJlblJlZmVyZW5jZVtwYXJlbnROb2RlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlblJlZmVyZW5jZVtwYXJlbnROb2RlSWRdID0gW107XG4gICAgICB9XG4gICAgICB0aGlzLmNoaWxkcmVuUmVmZXJlbmNlW3BhcmVudE5vZGVJZF0ucHVzaChjaGlsZE5vZGVJZCk7XG5cbiAgICAgIGlmICh0aGlzLnBhcmVudFJlZmVyZW5jZVtjaGlsZE5vZGVJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnBhcmVudFJlZmVyZW5jZVtjaGlsZE5vZGVJZF0gPSBbXTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGFyZW50UmVmZXJlbmNlW2NoaWxkTm9kZUlkXS5wdXNoKHBhcmVudE5vZGVJZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIGN1cnJlbnQgc3RhdGUgaXMgZm9yIGEgZm9ybWFsIHRyZWUgb3IgZm9ybWFsIGZvcmVzdC5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgdGhlIGNhc2UgaWYgZXZlcnkgbm9kZSBoYXMgYXQgbW9zdCBvbmUgcGFyZW50LlxuICAgICAqXG4gICAgICogUHJlOiBwYXJlbnRSZWZlcmVuY2UgaW5pdCdlZCBwcm9wZXJseSBmb3IgY3VycmVudCBuZXR3b3JrXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2NoZWNrSWZUcmVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tJZlRyZWUoKSB7XG4gICAgICBmb3IgKHZhciBpIGluIHRoaXMucGFyZW50UmVmZXJlbmNlKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudFJlZmVyZW5jZVtpXS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdGhpcy5pc1RyZWUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5pc1RyZWUgPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgbnVtYmVyIG9mIHNlcGFyYXRlIHRyZWVzIGluIHRoZSBjdXJyZW50IG5ldHdvcmsuXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbnVtVHJlZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBudW1UcmVlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyZWVJbmRleCArIDE7IC8vIFRoaXMgYXNzdW1lcyB0aGUgaW5kZXhlcyBhcmUgYXNzaWduZWQgY29uc2VjaXRpdmVseVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbiBhIHRyZWUgaWQgdG8gYSBub2RlXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB0cmVlSWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0VHJlZUluZGV4JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VHJlZUluZGV4KG5vZGUsIHRyZWVJZCkge1xuICAgICAgaWYgKHRyZWVJZCA9PT0gdW5kZWZpbmVkKSByZXR1cm47IC8vIERvbid0IGJvdGhlclxuXG4gICAgICBpZiAodGhpcy50cmVlc1tub2RlLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMudHJlZXNbbm9kZS5pZF0gPSB0cmVlSWQ7XG4gICAgICAgIHRoaXMudHJlZUluZGV4ID0gTWF0aC5tYXgodHJlZUlkLCB0aGlzLnRyZWVJbmRleCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5zdXJlIGxldmVsIGZvciBnaXZlbiBpZCBpcyBkZWZpbmVkLlxuICAgICAqXG4gICAgICogU2V0cyBsZXZlbCB0byB6ZXJvIGZvciBnaXZlbiBub2RlIGlkIGlmIG5vdCBhbHJlYWR5IHByZXNlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gbm9kZUlkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Vuc3VyZUxldmVsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5zdXJlTGV2ZWwobm9kZUlkKSB7XG4gICAgICBpZiAodGhpcy5sZXZlbHNbbm9kZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMubGV2ZWxzW25vZGVJZF0gPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgbWF4aW11bSBsZXZlbCBvZiBhIGJyYW5jaC5cbiAgICAgKlxuICAgICAqIFRPRE86IE5ldmVyIGVudGVyZWQ7IGZpbmQgYSB0ZXN0IGNhc2UgdG8gdGVzdCB0aGlzIVxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gbm9kZUlkXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0TWF4TGV2ZWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNYXhMZXZlbChub2RlSWQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBhY2N1bXVsYXRvciA9IHt9O1xuXG4gICAgICB2YXIgX2dldE1heExldmVsID0gZnVuY3Rpb24gX2dldE1heExldmVsKG5vZGVJZCkge1xuICAgICAgICBpZiAoYWNjdW11bGF0b3Jbbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yW25vZGVJZF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxldmVsID0gX3RoaXMubGV2ZWxzW25vZGVJZF07XG4gICAgICAgIGlmIChfdGhpcy5jaGlsZHJlblJlZmVyZW5jZVtub2RlSWRdKSB7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuID0gX3RoaXMuY2hpbGRyZW5SZWZlcmVuY2Vbbm9kZUlkXTtcbiAgICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBsZXZlbCA9IE1hdGgubWF4KGxldmVsLCBfZ2V0TWF4TGV2ZWwoY2hpbGRyZW5baV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYWNjdW11bGF0b3Jbbm9kZUlkXSA9IGxldmVsO1xuICAgICAgICByZXR1cm4gbGV2ZWw7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gX2dldE1heExldmVsKG5vZGVJZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVBXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlQlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdsZXZlbERvd25zdHJlYW0nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsZXZlbERvd25zdHJlYW0obm9kZUEsIG5vZGVCKSB7XG4gICAgICBpZiAodGhpcy5sZXZlbHNbbm9kZUIuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gc2V0IGluaXRpYWwgbGV2ZWxcbiAgICAgICAgaWYgKHRoaXMubGV2ZWxzW25vZGVBLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5sZXZlbHNbbm9kZUEuaWRdID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgbGV2ZWxcbiAgICAgICAgdGhpcy5sZXZlbHNbbm9kZUIuaWRdID0gdGhpcy5sZXZlbHNbbm9kZUEuaWRdICsgMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTbWFsbCB1dGlsIG1ldGhvZCB0byBzZXQgdGhlIG1pbmltdW0gbGV2ZWxzIG9mIHRoZSBub2RlcyB0byB6ZXJvLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48Tm9kZT59IG5vZGVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldE1pbkxldmVsVG9aZXJvJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TWluTGV2ZWxUb1plcm8obm9kZXMpIHtcbiAgICAgIHZhciBtaW5MZXZlbCA9IDFlOTtcbiAgICAgIC8vIGdldCB0aGUgbWluaW11bSBsZXZlbFxuICAgICAgZm9yICh2YXIgbm9kZUlkIGluIG5vZGVzKSB7XG4gICAgICAgIGlmIChub2Rlcy5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgaWYgKHRoaXMubGV2ZWxzW25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbWluTGV2ZWwgPSBNYXRoLm1pbih0aGlzLmxldmVsc1tub2RlSWRdLCBtaW5MZXZlbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHN1YnRyYWN0IHRoZSBtaW5pbXVtIGZyb20gdGhlIHNldCBzbyB3ZSBoYXZlIGEgcmFuZ2Ugc3RhcnRpbmcgZnJvbSAwXG4gICAgICBmb3IgKHZhciBfbm9kZUlkIGluIG5vZGVzKSB7XG4gICAgICAgIGlmIChub2Rlcy5oYXNPd25Qcm9wZXJ0eShfbm9kZUlkKSkge1xuICAgICAgICAgIGlmICh0aGlzLmxldmVsc1tfbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmxldmVsc1tfbm9kZUlkXSAtPSBtaW5MZXZlbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG1pbiBhbmQgbWF4IHh5LWNvb3JkaW5hdGVzIG9mIGEgZ2l2ZW4gdHJlZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48Tm9kZT59IG5vZGVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge3ttaW5feDogbnVtYmVyLCBtYXhfeDogbnVtYmVyLCBtaW5feTogbnVtYmVyLCBtYXhfeTogbnVtYmVyfX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0VHJlZVNpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUcmVlU2l6ZShub2RlcywgaW5kZXgpIHtcbiAgICAgIHZhciBtaW5feCA9IDFlOTtcbiAgICAgIHZhciBtYXhfeCA9IC0xZTk7XG4gICAgICB2YXIgbWluX3kgPSAxZTk7XG4gICAgICB2YXIgbWF4X3kgPSAtMWU5O1xuXG4gICAgICBmb3IgKHZhciBub2RlSWQgaW4gdGhpcy50cmVlcykge1xuICAgICAgICBpZiAodGhpcy50cmVlcy5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgaWYgKHRoaXMudHJlZXNbbm9kZUlkXSA9PT0gaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICAgIG1pbl94ID0gTWF0aC5taW4obm9kZS54LCBtaW5feCk7XG4gICAgICAgICAgICBtYXhfeCA9IE1hdGgubWF4KG5vZGUueCwgbWF4X3gpO1xuICAgICAgICAgICAgbWluX3kgPSBNYXRoLm1pbihub2RlLnksIG1pbl95KTtcbiAgICAgICAgICAgIG1heF95ID0gTWF0aC5tYXgobm9kZS55LCBtYXhfeSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1pbl94OiBtaW5feCxcbiAgICAgICAgbWF4X3g6IG1heF94LFxuICAgICAgICBtaW5feTogbWluX3ksXG4gICAgICAgIG1heF95OiBtYXhfeVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0d28gbm9kZXMgaGF2ZSB0aGUgc2FtZSBwYXJlbnQocylcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZTFcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgdHdvIG5vZGVzIGhhdmUgYSBzYW1lIGFuY2VzdG9yIG5vZGUsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdoYXNTYW1lUGFyZW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzU2FtZVBhcmVudChub2RlMSwgbm9kZTIpIHtcbiAgICAgIHZhciBwYXJlbnRzMSA9IHRoaXMucGFyZW50UmVmZXJlbmNlW25vZGUxLmlkXTtcbiAgICAgIHZhciBwYXJlbnRzMiA9IHRoaXMucGFyZW50UmVmZXJlbmNlW25vZGUyLmlkXTtcbiAgICAgIGlmIChwYXJlbnRzMSA9PT0gdW5kZWZpbmVkIHx8IHBhcmVudHMyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudHMxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGFyZW50czIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAocGFyZW50czFbaV0gPT0gcGFyZW50czJbal0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHR3byBub2RlcyBhcmUgaW4gdGhlIHNhbWUgdHJlZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZTFcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGlzIGlzIHNvLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaW5TYW1lU3ViTmV0d29yaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluU2FtZVN1Yk5ldHdvcmsobm9kZTEsIG5vZGUyKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmVlc1tub2RlMS5pZF0gPT09IHRoaXMudHJlZXNbbm9kZTIuaWRdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhIGxpc3Qgb2YgdGhlIGRpc3RpbmN0IGxldmVscyBpbiB0aGUgY3VycmVudCBuZXR3b3JrXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldExldmVscycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExldmVscygpIHtcbiAgICAgIHJldHVybiAoMCwgX2tleXMyWydkZWZhdWx0J10pKHRoaXMuZGlzdHJpYnV0aW9uT3JkZXJpbmcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhIG5vZGUgdG8gdGhlIG9yZGVyaW5nIHBlciBsZXZlbFxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxldmVsXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2FkZFRvT3JkZXJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRUb09yZGVyaW5nKG5vZGUsIGxldmVsKSB7XG4gICAgICBpZiAodGhpcy5kaXN0cmlidXRpb25PcmRlcmluZ1tsZXZlbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmRpc3RyaWJ1dGlvbk9yZGVyaW5nW2xldmVsXSA9IFtdO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNQcmVzZW50ID0gZmFsc2U7XG4gICAgICB2YXIgY3VyTGV2ZWwgPSB0aGlzLmRpc3RyaWJ1dGlvbk9yZGVyaW5nW2xldmVsXTtcbiAgICAgIGZvciAodmFyIG4gaW4gY3VyTGV2ZWwpIHtcbiAgICAgICAgLy9pZiAoY3VyTGV2ZWxbbl0uaWQgPT09IG5vZGUuaWQpIHtcbiAgICAgICAgaWYgKGN1ckxldmVsW25dID09PSBub2RlKSB7XG4gICAgICAgICAgaXNQcmVzZW50ID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWlzUHJlc2VudCkge1xuICAgICAgICB0aGlzLmRpc3RyaWJ1dGlvbk9yZGVyaW5nW2xldmVsXS5wdXNoKG5vZGUpO1xuICAgICAgICB0aGlzLmRpc3RyaWJ1dGlvbkluZGV4W25vZGUuaWRdID0gdGhpcy5kaXN0cmlidXRpb25PcmRlcmluZ1tsZXZlbF0ubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEhpZXJhcmNoaWNhbFN0YXR1cztcbn0oKTtcblxuLyoqXG4gKiBUaGUgTGF5b3V0IEVuZ2luZVxuICovXG5cblxudmFyIExheW91dEVuZ2luZSA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5XG4gICAqL1xuICBmdW5jdGlvbiBMYXlvdXRFbmdpbmUoYm9keSkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIExheW91dEVuZ2luZSk7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuXG4gICAgdGhpcy5pbml0aWFsUmFuZG9tU2VlZCA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDApO1xuICAgIHRoaXMucmFuZG9tU2VlZCA9IHRoaXMuaW5pdGlhbFJhbmRvbVNlZWQ7XG4gICAgdGhpcy5zZXRQaHlzaWNzID0gZmFsc2U7XG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgdGhpcy5vcHRpb25zQmFja3VwID0geyBwaHlzaWNzOiB7fSB9O1xuXG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIHJhbmRvbVNlZWQ6IHVuZGVmaW5lZCxcbiAgICAgIGltcHJvdmVkTGF5b3V0OiB0cnVlLFxuICAgICAgaGllcmFyY2hpY2FsOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBsZXZlbFNlcGFyYXRpb246IDE1MCxcbiAgICAgICAgbm9kZVNwYWNpbmc6IDEwMCxcbiAgICAgICAgdHJlZVNwYWNpbmc6IDIwMCxcbiAgICAgICAgYmxvY2tTaGlmdGluZzogdHJ1ZSxcbiAgICAgICAgZWRnZU1pbmltaXphdGlvbjogdHJ1ZSxcbiAgICAgICAgcGFyZW50Q2VudHJhbGl6YXRpb246IHRydWUsXG4gICAgICAgIGRpcmVjdGlvbjogJ1VEJywgLy8gVUQsIERVLCBMUiwgUkxcbiAgICAgICAgc29ydE1ldGhvZDogJ2h1YnNpemUnIC8vIGh1YnNpemUsIGRpcmVjdGVkXG4gICAgICB9XG4gICAgfTtcbiAgICB1dGlsLmV4dGVuZCh0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuICAgIHRoaXMuYmluZEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cblxuICAvKipcbiAgICogQmluZHMgZXZlbnQgbGlzdGVuZXJzXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoTGF5b3V0RW5naW5lLCBbe1xuICAgIGtleTogJ2JpbmRFdmVudExpc3RlbmVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRFdmVudExpc3RlbmVycygpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignX2RhdGFDaGFuZ2VkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuc2V0dXBIaWVyYXJjaGljYWxMYXlvdXQoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ19kYXRhTG9hZGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIubGF5b3V0TmV0d29yaygpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignX3Jlc2V0SGllcmFyY2hpY2FsTGF5b3V0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuc2V0dXBIaWVyYXJjaGljYWxMYXlvdXQoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ19hZGp1c3RFZGdlc0ZvckhpZXJhcmNoaWNhbExheW91dCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKF90aGlzMi5vcHRpb25zLmhpZXJhcmNoaWNhbC5lbmFibGVkICE9PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdldCB0aGUgdHlwZSBvZiBzdGF0aWMgc21vb3RoIGN1cnZlIGluIGNhc2UgaXQgaXMgcmVxdWlyZWRcbiAgICAgICAgdmFyIHR5cGUgPSBfdGhpczIuZGlyZWN0aW9uLmN1cnZlVHlwZSgpO1xuXG4gICAgICAgIC8vIGZvcmNlIGFsbCBlZGdlcyBpbnRvIHN0YXRpYyBzbW9vdGggY3VydmVzLlxuICAgICAgICBfdGhpczIuYm9keS5lbWl0dGVyLmVtaXQoJ19mb3JjZURpc2FibGVEeW5hbWljQ3VydmVzJywgdHlwZSwgZmFsc2UpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhbGxPcHRpb25zXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0T3B0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucywgYWxsT3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgaGllcmFyY2hpY2FsID0gdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbDtcbiAgICAgICAgdmFyIHByZXZIaWVyYXJjaGljYWxTdGF0ZSA9IGhpZXJhcmNoaWNhbC5lbmFibGVkO1xuICAgICAgICB1dGlsLnNlbGVjdGl2ZURlZXBFeHRlbmQoWydyYW5kb21TZWVkJywgJ2ltcHJvdmVkTGF5b3V0J10sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHV0aWwubWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgb3B0aW9ucywgJ2hpZXJhcmNoaWNhbCcpO1xuICAgICAgICBpZiAob3B0aW9ucy5yYW5kb21TZWVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmluaXRpYWxSYW5kb21TZWVkID0gb3B0aW9ucy5yYW5kb21TZWVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhpZXJhcmNoaWNhbC5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgaWYgKHByZXZIaWVyYXJjaGljYWxTdGF0ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gcmVmcmVzaCB0aGUgb3ZlcnJpZGRlbiBvcHRpb25zIGZvciBub2RlcyBhbmQgZWRnZXMuXG4gICAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdyZWZyZXNoJywgdHJ1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBsZXZlbCBzZXBhcmF0aW9uIGlzIHRoZSByaWdodCB3YXkgdXBcbiAgICAgICAgICBpZiAoaGllcmFyY2hpY2FsLmRpcmVjdGlvbiA9PT0gJ1JMJyB8fCBoaWVyYXJjaGljYWwuZGlyZWN0aW9uID09PSAnRFUnKSB7XG4gICAgICAgICAgICBpZiAoaGllcmFyY2hpY2FsLmxldmVsU2VwYXJhdGlvbiA+IDApIHtcbiAgICAgICAgICAgICAgaGllcmFyY2hpY2FsLmxldmVsU2VwYXJhdGlvbiAqPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGhpZXJhcmNoaWNhbC5sZXZlbFNlcGFyYXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgIGhpZXJhcmNoaWNhbC5sZXZlbFNlcGFyYXRpb24gKj0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5zZXREaXJlY3Rpb25TdHJhdGVneSgpO1xuXG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX3Jlc2V0SGllcmFyY2hpY2FsTGF5b3V0Jyk7XG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGUgaGllcmFyY2hpY2FsIHN5c3RlbSBuZWVkcyBpdCdzIG93biBwaHlzaWNzIGFuZCBzbW9vdGggY3VydmUgc2V0dGluZ3MsXG4gICAgICAgICAgLy8gd2UgYWRhcHQgdGhlIG90aGVyIG9wdGlvbnMgaWYgbmVlZGVkLlxuICAgICAgICAgIHJldHVybiB0aGlzLmFkYXB0QWxsT3B0aW9uc0ZvckhpZXJhcmNoaWNhbExheW91dChhbGxPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocHJldkhpZXJhcmNoaWNhbFN0YXRlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAvLyByZWZyZXNoIHRoZSBvdmVycmlkZGVuIG9wdGlvbnMgZm9yIG5vZGVzIGFuZCBlZGdlcy5cbiAgICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3JlZnJlc2gnKTtcbiAgICAgICAgICAgIHJldHVybiB1dGlsLmRlZXBFeHRlbmQoYWxsT3B0aW9ucywgdGhpcy5vcHRpb25zQmFja3VwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhbGxPcHRpb25zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFsbE9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhZGFwdEFsbE9wdGlvbnNGb3JIaWVyYXJjaGljYWxMYXlvdXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGFwdEFsbE9wdGlvbnNGb3JIaWVyYXJjaGljYWxMYXlvdXQoYWxsT3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgYmFja3VwUGh5c2ljcyA9IHRoaXMub3B0aW9uc0JhY2t1cC5waHlzaWNzO1xuXG4gICAgICAgIC8vIHNldCB0aGUgcGh5c2ljc1xuICAgICAgICBpZiAoYWxsT3B0aW9ucy5waHlzaWNzID09PSB1bmRlZmluZWQgfHwgYWxsT3B0aW9ucy5waHlzaWNzID09PSB0cnVlKSB7XG4gICAgICAgICAgYWxsT3B0aW9ucy5waHlzaWNzID0ge1xuICAgICAgICAgICAgZW5hYmxlZDogYmFja3VwUGh5c2ljcy5lbmFibGVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogYmFja3VwUGh5c2ljcy5lbmFibGVkLFxuICAgICAgICAgICAgc29sdmVyOiAnaGllcmFyY2hpY2FsUmVwdWxzaW9uJ1xuICAgICAgICAgIH07XG4gICAgICAgICAgYmFja3VwUGh5c2ljcy5lbmFibGVkID0gYmFja3VwUGh5c2ljcy5lbmFibGVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogYmFja3VwUGh5c2ljcy5lbmFibGVkO1xuICAgICAgICAgIGJhY2t1cFBoeXNpY3Muc29sdmVyID0gYmFja3VwUGh5c2ljcy5zb2x2ZXIgfHwgJ2Jhcm5lc0h1dCc7XG4gICAgICAgIH0gZWxzZSBpZiAoKDAsIF90eXBlb2YzWydkZWZhdWx0J10pKGFsbE9wdGlvbnMucGh5c2ljcykgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgYmFja3VwUGh5c2ljcy5lbmFibGVkID0gYWxsT3B0aW9ucy5waHlzaWNzLmVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhbGxPcHRpb25zLnBoeXNpY3MuZW5hYmxlZDtcbiAgICAgICAgICBiYWNrdXBQaHlzaWNzLnNvbHZlciA9IGFsbE9wdGlvbnMucGh5c2ljcy5zb2x2ZXIgfHwgJ2Jhcm5lc0h1dCc7XG4gICAgICAgICAgYWxsT3B0aW9ucy5waHlzaWNzLnNvbHZlciA9ICdoaWVyYXJjaGljYWxSZXB1bHNpb24nO1xuICAgICAgICB9IGVsc2UgaWYgKGFsbE9wdGlvbnMucGh5c2ljcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBiYWNrdXBQaHlzaWNzLnNvbHZlciA9ICdiYXJuZXNIdXQnO1xuICAgICAgICAgIGFsbE9wdGlvbnMucGh5c2ljcyA9IHsgc29sdmVyOiAnaGllcmFyY2hpY2FsUmVwdWxzaW9uJyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IHRoZSB0eXBlIG9mIHN0YXRpYyBzbW9vdGggY3VydmUgaW4gY2FzZSBpdCBpcyByZXF1aXJlZFxuICAgICAgICB2YXIgdHlwZSA9IHRoaXMuZGlyZWN0aW9uLmN1cnZlVHlwZSgpO1xuXG4gICAgICAgIC8vIGRpc2FibGUgc21vb3RoIGN1cnZlcyBpZiBub3RoaW5nIGlzIGRlZmluZWQuIElmIHNtb290aCBjdXJ2ZXMgaGF2ZSBiZWVuIHR1cm5lZCBvbixcbiAgICAgICAgLy8gdHVybiB0aGVtIGludG8gc3RhdGljIHNtb290aCBjdXJ2ZXMuXG4gICAgICAgIGlmIChhbGxPcHRpb25zLmVkZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnNCYWNrdXAuZWRnZXMgPSB7XG4gICAgICAgICAgICBzbW9vdGg6IHsgZW5hYmxlZDogdHJ1ZSwgdHlwZTogJ2R5bmFtaWMnIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGFsbE9wdGlvbnMuZWRnZXMgPSB7IHNtb290aDogZmFsc2UgfTtcbiAgICAgICAgfSBlbHNlIGlmIChhbGxPcHRpb25zLmVkZ2VzLnNtb290aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zQmFja3VwLmVkZ2VzID0ge1xuICAgICAgICAgICAgc21vb3RoOiB7IGVuYWJsZWQ6IHRydWUsIHR5cGU6ICdkeW5hbWljJyB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBhbGxPcHRpb25zLmVkZ2VzLnNtb290aCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgYWxsT3B0aW9ucy5lZGdlcy5zbW9vdGggPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zQmFja3VwLmVkZ2VzID0geyBzbW9vdGg6IGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoIH07XG4gICAgICAgICAgICBhbGxPcHRpb25zLmVkZ2VzLnNtb290aCA9IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogYWxsT3B0aW9ucy5lZGdlcy5zbW9vdGgsXG4gICAgICAgICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzbW9vdGggPSBhbGxPcHRpb25zLmVkZ2VzLnNtb290aDtcblxuICAgICAgICAgICAgLy8gYWxsb3cgY3VzdG9tIHR5cGVzIGV4Y2VwdCBmb3IgZHluYW1pY1xuICAgICAgICAgICAgaWYgKHNtb290aC50eXBlICE9PSB1bmRlZmluZWQgJiYgc21vb3RoLnR5cGUgIT09ICdkeW5hbWljJykge1xuICAgICAgICAgICAgICB0eXBlID0gc21vb3RoLnR5cGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRPRE86IHRoaXMgaXMgb3B0aW9ucyBtZXJnaW5nOyBzZWUgaWYgdGhlIHN0YW5kYXJkIHJvdXRpbmVzIGNhbiBiZSB1c2VkIGhlcmUuXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNCYWNrdXAuZWRnZXMgPSB7XG4gICAgICAgICAgICAgIHNtb290aDogc21vb3RoLmVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBzbW9vdGguZW5hYmxlZCxcbiAgICAgICAgICAgICAgdHlwZTogc21vb3RoLnR5cGUgPT09IHVuZGVmaW5lZCA/ICdkeW5hbWljJyA6IHNtb290aC50eXBlLFxuICAgICAgICAgICAgICByb3VuZG5lc3M6IHNtb290aC5yb3VuZG5lc3MgPT09IHVuZGVmaW5lZCA/IDAuNSA6IHNtb290aC5yb3VuZG5lc3MsXG4gICAgICAgICAgICAgIGZvcmNlRGlyZWN0aW9uOiBzbW9vdGguZm9yY2VEaXJlY3Rpb24gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogc21vb3RoLmZvcmNlRGlyZWN0aW9uXG5cbiAgICAgICAgICAgICAgLy8gTk9URTogQ29weWluZyBhbiBvYmplY3QgdG8gc2VsZjsgdGhpcyBpcyBiYXNpY2FsbHkgc2V0dGluZyBkZWZhdWx0cyBmb3IgdW5kZWZpbmVkIHZhcmlhYmxlc1xuICAgICAgICAgICAgfTthbGxPcHRpb25zLmVkZ2VzLnNtb290aCA9IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogc21vb3RoLmVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBzbW9vdGguZW5hYmxlZCxcbiAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgcm91bmRuZXNzOiBzbW9vdGgucm91bmRuZXNzID09PSB1bmRlZmluZWQgPyAwLjUgOiBzbW9vdGgucm91bmRuZXNzLFxuICAgICAgICAgICAgICBmb3JjZURpcmVjdGlvbjogc21vb3RoLmZvcmNlRGlyZWN0aW9uID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IHNtb290aC5mb3JjZURpcmVjdGlvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGb3JjZSBhbGwgZWRnZXMgaW50byBzdGF0aWMgc21vb3RoIGN1cnZlcy5cbiAgICAgICAgLy8gT25seSBhcHBsaWVzIHRvIGVkZ2VzIHRoYXQgZG8gbm90IHVzZSB0aGUgZ2xvYmFsIG9wdGlvbnMgZm9yIHNtb290aC5cbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2ZvcmNlRGlzYWJsZUR5bmFtaWNDdXJ2ZXMnLCB0eXBlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFsbE9wdGlvbnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZWVkZWRSYW5kb20nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWVkZWRSYW5kb20oKSB7XG4gICAgICB2YXIgeCA9IE1hdGguc2luKHRoaXMucmFuZG9tU2VlZCsrKSAqIDEwMDAwO1xuICAgICAgcmV0dXJuIHggLSBNYXRoLmZsb29yKHgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48Tm9kZT59IG5vZGVzQXJyYXlcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncG9zaXRpb25Jbml0aWFsbHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3NpdGlvbkluaXRpYWxseShub2Rlc0FycmF5KSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5lbmFibGVkICE9PSB0cnVlKSB7XG4gICAgICAgIHRoaXMucmFuZG9tU2VlZCA9IHRoaXMuaW5pdGlhbFJhbmRvbVNlZWQ7XG4gICAgICAgIHZhciByYWRpdXMgPSBub2Rlc0FycmF5Lmxlbmd0aCArIDUwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzQXJyYXlbaV07XG4gICAgICAgICAgdmFyIGFuZ2xlID0gMiAqIE1hdGguUEkgKiB0aGlzLnNlZWRlZFJhbmRvbSgpO1xuICAgICAgICAgIGlmIChub2RlLnggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbm9kZS54ID0gcmFkaXVzICogTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobm9kZS55ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5vZGUueSA9IHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgS2FtYWRhIEthd2FpIHRvIHBvc2l0aW9uIG5vZGVzLiBUaGlzIGlzIHF1aXRlIGEgaGVhdnkgYWxnb3JpdGhtIHNvIGlmIHRoZXJlIGFyZSBhIGxvdCBvZiBub2RlcyB3ZVxuICAgICAqIGNsdXN0ZXIgdGhlbSBmaXJzdCB0byByZWR1Y2UgdGhlIGFtb3VudC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbGF5b3V0TmV0d29yaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxheW91dE5ldHdvcmsoKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5lbmFibGVkICE9PSB0cnVlICYmIHRoaXMub3B0aW9ucy5pbXByb3ZlZExheW91dCA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgaW5kaWNlcyA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcztcblxuICAgICAgICAvLyBmaXJzdCBjaGVjayBpZiB3ZSBzaG91bGQgS2FtYWRhIEthd2FpIHRvIGxheW91dC4gVGhlIHRocmVzaG9sZCBpcyBpZiBsZXNzIHRoYW4gaGFsZiBvZiB0aGUgdmlzaWJsZVxuICAgICAgICAvLyBub2RlcyBoYXZlIHByZWRlZmluZWQgcG9zaXRpb25zIHdlIHVzZSB0aGlzLlxuICAgICAgICB2YXIgcG9zaXRpb25EZWZpbmVkID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbaW5kaWNlc1tpXV07XG4gICAgICAgICAgaWYgKG5vZGUucHJlZGVmaW5lZFBvc2l0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICBwb3NpdGlvbkRlZmluZWQgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBsZXNzIHRoYW4gaGFsZiBvZiB0aGUgbm9kZXMgaGF2ZSBhIHByZWRlZmluZWQgcG9zaXRpb24gd2UgY29udGludWVcbiAgICAgICAgaWYgKHBvc2l0aW9uRGVmaW5lZCA8IDAuNSAqIGluZGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIE1BWF9MRVZFTFMgPSAxMDtcbiAgICAgICAgICB2YXIgbGV2ZWwgPSAwO1xuICAgICAgICAgIHZhciBjbHVzdGVyVGhyZXNob2xkID0gMTUwOyAvLyBUT0RPIGFkZCB0aGlzIHRvIG9wdGlvbnNcblxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gRGVmaW5lIHRoZSBvcHRpb25zIGZvciB0aGUgaGlkZGVuIGNsdXN0ZXIgbm9kZXNcbiAgICAgICAgICAvLyBUaGVzZSBvcHRpb25zIGRvbid0IHByb3BhZ2F0ZSBvdXRzaWRlIHRoZSBjbHVzdGVyaW5nIHBoYXNlLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gU29tZSBvcHRpb25zIGFyZSBleHBsaWNpdGx5IGRpc2FibGVkLCBiZWNhdXNlIHRoZXkgbWF5IGJlIHNldCBpbiBncm91cCBvciBkZWZhdWx0IG5vZGUgb3B0aW9ucy5cbiAgICAgICAgICAvLyBUaGUgY2x1c3RlcnMgYXJlIG5ldmVyIGRpc3BsYXllZCwgc28gbW9zdCBleHBsaWNpdCBzZXR0aW5ncyBoZXJlIHNlcnZlIGFzIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbnMuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBUaGUgZXhwbGljaXQgc2V0dGluZyBvZiAnc2hhcGUnIGlzIHRvIGF2b2lkIGBzaGFwZTogJ2ltYWdlJ2A7IGltYWdlcyBhcmUgbm90IHBhc3NlZCB0byB0aGUgaGlkZGVuXG4gICAgICAgICAgLy8gY2x1c3RlciBub2RlcywgbGVhZGluZyB0byBhbiBleGNlcHRpb24gb24gY3JlYXRpb24uXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBBbGwgc2V0dGluZ3MgaGVyZSBhcmUgcGVyZm9ybWFuY2UgcmVsYXRlZCwgZXhjZXB0IHdoZW4gbm90ZWQgb3RoZXJ3aXNlLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgdmFyIGNsdXN0ZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgY2x1c3Rlck5vZGVQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgIHNoYXBlOiAnZWxsaXBzZScsIC8vIEJ1Z2ZpeDogYXZvaWQgdHlwZSAnaW1hZ2UnLCBubyBpbWFnZXMgc3VwcGxpZWRcbiAgICAgICAgICAgICAgbGFiZWw6ICcnLCAvLyBhdm9pZCBsYWJlbCBoYW5kbGluZ1xuICAgICAgICAgICAgICBncm91cDogJycsIC8vIGF2b2lkIGdyb3VwIGhhbmRsaW5nXG4gICAgICAgICAgICAgIGZvbnQ6IHsgbXVsdGk6IGZhbHNlIC8vIGF2b2lkIGZvbnQgcHJvcGFnYXRpb25cbiAgICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgY2x1c3RlckVkZ2VQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgIGxhYmVsOiAnJywgLy8gYXZvaWQgbGFiZWwgaGFuZGxpbmdcbiAgICAgICAgICAgICAgZm9udDogeyBtdWx0aTogZmFsc2UgfSwgLy8gYXZvaWQgZm9udCBwcm9wYWdhdGlvblxuICAgICAgICAgICAgICBzbW9vdGg6IHtcbiAgICAgICAgICAgICAgICBlbmFibGVkOiBmYWxzZSAvLyBhdm9pZCBkcmF3aW5nIHBlbmFsdHkgZm9yIGNvbXBsZXggZWRnZXNcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgYSBsb3Qgb2Ygbm9kZXMsIHdlIGNsdXN0ZXIgYmVmb3JlIHdlIHJ1biB0aGUgYWxnb3JpdGhtLlxuICAgICAgICAgICAgLy8gTk9URTogdGhpcyBwYXJ0IGZhaWxzIHRvIGZpbmQgY2x1c3RlcnMgZm9yIGxhcmdlIHNjYWxlLWZyZWUgbmV0d29ya3MsIHdoaWNoIHNob3VsZFxuICAgICAgICAgICAgLy8gICAgICAgYmUgZWFzaWx5IGNsdXN0ZXJhYmxlLlxuICAgICAgICAgICAgLy8gVE9ETzogZXhhbWluZSB3aHkgdGhpcyBpcyBzb1xuICAgICAgICAgIH07aWYgKGluZGljZXMubGVuZ3RoID4gY2x1c3RlclRocmVzaG9sZCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0TGVuZ3RoID0gaW5kaWNlcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoaW5kaWNlcy5sZW5ndGggPiBjbHVzdGVyVGhyZXNob2xkICYmIGxldmVsIDw9IE1BWF9MRVZFTFMpIHtcbiAgICAgICAgICAgICAgLy9jb25zb2xlLnRpbWUoXCJjbHVzdGVyaW5nXCIpXG4gICAgICAgICAgICAgIGxldmVsICs9IDE7XG4gICAgICAgICAgICAgIHZhciBiZWZvcmUgPSBpbmRpY2VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG1hbnkgbm9kZXMgd2UgZG8gYSBodWJzaXplIGNsdXN0ZXJcbiAgICAgICAgICAgICAgaWYgKGxldmVsICUgMyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYm9keS5tb2R1bGVzLmNsdXN0ZXJpbmcuY2x1c3RlckJyaWRnZXMoY2x1c3Rlck9wdGlvbnMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYm9keS5tb2R1bGVzLmNsdXN0ZXJpbmcuY2x1c3Rlck91dGxpZXJzKGNsdXN0ZXJPcHRpb25zKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgYWZ0ZXIgPSBpbmRpY2VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgaWYgKGJlZm9yZSA9PSBhZnRlciAmJiBsZXZlbCAlIDMgIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWNsdXN0ZXJBbGwoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfbGF5b3V0RmFpbGVkJyk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKCdUaGlzIG5ldHdvcmsgY291bGQgbm90IGJlIHBvc2l0aW9uZWQgYnkgdGhpcyB2ZXJzaW9uIG9mIHRoZSBpbXByb3ZlZCBsYXlvdXQgYWxnb3JpdGhtLicgKyAnIFBsZWFzZSBkaXNhYmxlIGltcHJvdmVkTGF5b3V0IGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vY29uc29sZS50aW1lRW5kKFwiY2x1c3RlcmluZ1wiKVxuICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGJlZm9yZSxsZXZlbCxhZnRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpbmNyZWFzZSB0aGUgc2l6ZSBvZiB0aGUgZWRnZXNcbiAgICAgICAgICAgIHRoaXMuYm9keS5tb2R1bGVzLmthbWFkYUthd2FpLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgICBzcHJpbmdMZW5ndGg6IE1hdGgubWF4KDE1MCwgMiAqIHN0YXJ0TGVuZ3RoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsZXZlbCA+IE1BWF9MRVZFTFMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIlRoZSBjbHVzdGVyaW5nIGRpZG4ndCBzdWNjZWVkIHdpdGhpbiB0aGUgYW1vdW50IG9mIGludGVyYXRpb25zIGFsbG93ZWQsXCIgKyAnIHByb2dyZXNzaW5nIHdpdGggcGFydGlhbCByZXN1bHQuJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gcG9zaXRpb24gdGhlIHN5c3RlbSBmb3IgdGhlc2Ugbm9kZXMgYW5kIGVkZ2VzXG4gICAgICAgICAgdGhpcy5ib2R5Lm1vZHVsZXMua2FtYWRhS2F3YWkuc29sdmUoaW5kaWNlcywgdGhpcy5ib2R5LmVkZ2VJbmRpY2VzLCB0cnVlKTtcblxuICAgICAgICAgIC8vIHNoaWZ0IHRvIGNlbnRlciBwb2ludFxuICAgICAgICAgIHRoaXMuX3NoaWZ0VG9DZW50ZXIoKTtcblxuICAgICAgICAgIC8vIHBlcnR1cmIgdGhlIG5vZGVzIGEgbGl0dGxlIGJpdCB0byBmb3JjZSB0aGUgcGh5c2ljcyB0byBraWNrIGluXG4gICAgICAgICAgdmFyIG9mZnNldCA9IDcwO1xuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBpbmRpY2VzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgLy8gT25seSBwZXJ0dXJiIHRoZSBub2RlcyB0aGF0IGFyZW4ndCBmaXhlZFxuICAgICAgICAgICAgdmFyIF9ub2RlID0gdGhpcy5ib2R5Lm5vZGVzW2luZGljZXNbX2ldXTtcbiAgICAgICAgICAgIGlmIChfbm9kZS5wcmVkZWZpbmVkUG9zaXRpb24gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIF9ub2RlLnggKz0gKDAuNSAtIHRoaXMuc2VlZGVkUmFuZG9tKCkpICogb2Zmc2V0O1xuICAgICAgICAgICAgICBfbm9kZS55ICs9ICgwLjUgLSB0aGlzLnNlZWRlZFJhbmRvbSgpKSAqIG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB1bmNsdXN0ZXIgYWxsIGNsdXN0ZXJzXG4gICAgICAgICAgdGhpcy5fZGVjbHVzdGVyQWxsKCk7XG5cbiAgICAgICAgICAvLyByZXBvc2l0aW9uIGFsbCBiZXppZXIgbm9kZXMuXG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX3JlcG9zaXRpb25CZXppZXJOb2RlcycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW92ZSBhbGwgdGhlIG5vZGVzIHRvd2FyZHMgdG8gdGhlIGNlbnRlciBzbyBncmF2aXRhdGlvbmFsIHB1bGwgd2lsIG5vdCBtb3ZlIHRoZSBub2RlcyBhd2F5IGZyb20gdmlld1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19zaGlmdFRvQ2VudGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NoaWZ0VG9DZW50ZXIoKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBOZXR3b3JrVXRpbC5nZXRSYW5nZUNvcmUodGhpcy5ib2R5Lm5vZGVzLCB0aGlzLmJvZHkubm9kZUluZGljZXMpO1xuICAgICAgdmFyIGNlbnRlciA9IE5ldHdvcmtVdGlsLmZpbmRDZW50ZXIocmFuZ2UpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbdGhpcy5ib2R5Lm5vZGVJbmRpY2VzW2ldXTtcbiAgICAgICAgbm9kZS54IC09IGNlbnRlci54O1xuICAgICAgICBub2RlLnkgLT0gY2VudGVyLnk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhwYW5kcyBhbGwgY2x1c3RlcnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZGVjbHVzdGVyQWxsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RlY2x1c3RlckFsbCgpIHtcbiAgICAgIHZhciBjbHVzdGVyc1ByZXNlbnQgPSB0cnVlO1xuICAgICAgd2hpbGUgKGNsdXN0ZXJzUHJlc2VudCA9PT0gdHJ1ZSkge1xuICAgICAgICBjbHVzdGVyc1ByZXNlbnQgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW3RoaXMuYm9keS5ub2RlSW5kaWNlc1tpXV0uaXNDbHVzdGVyID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjbHVzdGVyc1ByZXNlbnQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5ib2R5Lm1vZHVsZXMuY2x1c3RlcmluZy5vcGVuQ2x1c3Rlcih0aGlzLmJvZHkubm9kZUluZGljZXNbaV0sIHt9LCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjbHVzdGVyc1ByZXNlbnQgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfZGF0YUNoYW5nZWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcnwqfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRTZWVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2VlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmluaXRpYWxSYW5kb21TZWVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIG1haW4gZnVuY3Rpb24gdG8gbGF5b3V0IHRoZSBub2RlcyBpbiBhIGhpZXJhcmNoaWNhbCB3YXkuXG4gICAgICogSXQgY2hlY2tzIGlmIHRoZSBub2RlIGRldGFpbHMgYXJlIHN1cHBsaWVkIGNvcnJlY3RseVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0dXBIaWVyYXJjaGljYWxMYXlvdXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXR1cEhpZXJhcmNoaWNhbExheW91dCgpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmVuYWJsZWQgPT09IHRydWUgJiYgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gZ2V0IHRoZSBzaXplIG9mIHRoZSBsYXJnZXN0IGh1YnMgYW5kIGNoZWNrIGlmIHRoZSB1c2VyIGhhcyBkZWZpbmVkIGEgbGV2ZWwgZm9yIGEgbm9kZS5cbiAgICAgICAgdmFyIG5vZGUgPSB2b2lkIDAsXG4gICAgICAgICAgICBub2RlSWQgPSB2b2lkIDA7XG4gICAgICAgIHZhciBkZWZpbmVkTGV2ZWwgPSBmYWxzZTtcbiAgICAgICAgdmFyIHVuZGVmaW5lZExldmVsID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGFzdE5vZGVPbkxldmVsID0ge307XG4gICAgICAgIHRoaXMuaGllcmFyY2hpY2FsID0gbmV3IEhpZXJhcmNoaWNhbFN0YXR1cygpO1xuXG4gICAgICAgIGZvciAobm9kZUlkIGluIHRoaXMuYm9keS5ub2Rlcykge1xuICAgICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgICAgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgICAgICAgaWYgKG5vZGUub3B0aW9ucy5sZXZlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGRlZmluZWRMZXZlbCA9IHRydWU7XG4gICAgICAgICAgICAgIHRoaXMuaGllcmFyY2hpY2FsLmxldmVsc1tub2RlSWRdID0gbm9kZS5vcHRpb25zLmxldmVsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdW5kZWZpbmVkTGV2ZWwgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZSB1c2VyIGRlZmluZWQgc29tZSBsZXZlbHMgYnV0IG5vdCBhbGwsIGFsZXJ0IGFuZCBydW4gd2l0aG91dCBoaWVyYXJjaGljYWwgbGF5b3V0XG4gICAgICAgIGlmICh1bmRlZmluZWRMZXZlbCA9PT0gdHJ1ZSAmJiBkZWZpbmVkTGV2ZWwgPT09IHRydWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvIHVzZSB0aGUgaGllcmFyY2hpY2FsIGxheW91dCwgbm9kZXMgcmVxdWlyZSBlaXRoZXIgbm8gcHJlZGVmaW5lZCBsZXZlbHMnICsgJyBvciBsZXZlbHMgaGF2ZSB0byBiZSBkZWZpbmVkIGZvciBhbGwgbm9kZXMuJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZGVmaW5lIGxldmVscyBpZiB1bmRlZmluZWQgYnkgdGhlIHVzZXJzLiBCYXNlZCBvbiBodWJzaXplLlxuICAgICAgICAgIGlmICh1bmRlZmluZWRMZXZlbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIHNvcnRNZXRob2QgPSB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLnNvcnRNZXRob2Q7XG4gICAgICAgICAgICBpZiAoc29ydE1ldGhvZCA9PT0gJ2h1YnNpemUnKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2RldGVybWluZUxldmVsc0J5SHVic2l6ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzb3J0TWV0aG9kID09PSAnZGlyZWN0ZWQnKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2RldGVybWluZUxldmVsc0RpcmVjdGVkKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNvcnRNZXRob2QgPT09ICdjdXN0b20nKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2RldGVybWluZUxldmVsc0N1c3RvbUNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZmFsbGJhY2sgZm9yIGNhc2VzIHdoZXJlIHRoZXJlIGFyZSBub2RlcyBidXQgbm8gZWRnZXNcbiAgICAgICAgICBmb3IgKHZhciBfbm9kZUlkMiBpbiB0aGlzLmJvZHkubm9kZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXMuaGFzT3duUHJvcGVydHkoX25vZGVJZDIpKSB7XG4gICAgICAgICAgICAgIHRoaXMuaGllcmFyY2hpY2FsLmVuc3VyZUxldmVsKF9ub2RlSWQyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gY2hlY2sgdGhlIGRpc3RyaWJ1dGlvbiBvZiB0aGUgbm9kZXMgcGVyIGxldmVsLlxuICAgICAgICAgIHZhciBkaXN0cmlidXRpb24gPSB0aGlzLl9nZXREaXN0cmlidXRpb24oKTtcblxuICAgICAgICAgIC8vIGdldCB0aGUgcGFyZW50IGNoaWxkcmVuIHJlbGF0aW9ucy5cbiAgICAgICAgICB0aGlzLl9nZW5lcmF0ZU1hcCgpO1xuXG4gICAgICAgICAgLy8gcGxhY2UgdGhlIG5vZGVzIG9uIHRoZSBjYW52YXMuXG4gICAgICAgICAgdGhpcy5fcGxhY2VOb2Rlc0J5SGllcmFyY2h5KGRpc3RyaWJ1dGlvbik7XG5cbiAgICAgICAgICAvLyBjb25kZW5zZSB0aGUgd2hpdGVzcGFjZS5cbiAgICAgICAgICB0aGlzLl9jb25kZW5zZUhpZXJhcmNoeSgpO1xuXG4gICAgICAgICAgLy8gc2hpZnQgdG8gY2VudGVyIHNvIGdyYXZpdHkgZG9lcyBub3QgaGF2ZSB0byBkbyBtdWNoXG4gICAgICAgICAgdGhpcy5fc2hpZnRUb0NlbnRlcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2NvbmRlbnNlSGllcmFyY2h5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbmRlbnNlSGllcmFyY2h5KCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIC8vIEdsb2JhbCB2YXIgaW4gdGhpcyBzY29wZSB0byBkZWZpbmUgd2hlbiB0aGUgbW92ZW1lbnQgaGFzIHN0b3BwZWQuXG4gICAgICB2YXIgc3RpbGxTaGlmdGluZyA9IGZhbHNlO1xuICAgICAgdmFyIGJyYW5jaGVzID0ge307XG4gICAgICAvLyBmaXJzdCB3ZSBoYXZlIHNvbWUgbWV0aG9kcyB0byBoZWxwIHNoaWZ0aW5nIHRyZWVzIGFyb3VuZC5cbiAgICAgIC8vIHRoZSBtYWluIG1ldGhvZCB0byBzaGlmdCB0aGUgdHJlZXNcbiAgICAgIHZhciBzaGlmdFRyZWVzID0gZnVuY3Rpb24gc2hpZnRUcmVlcygpIHtcbiAgICAgICAgdmFyIHRyZWVTaXplcyA9IGdldFRyZWVTaXplcygpO1xuICAgICAgICB2YXIgc2hpZnRCeSA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZVNpemVzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgIHZhciBkaWZmID0gdHJlZVNpemVzW2ldLm1heCAtIHRyZWVTaXplc1tpICsgMV0ubWluO1xuICAgICAgICAgIHNoaWZ0QnkgKz0gZGlmZiArIF90aGlzMy5vcHRpb25zLmhpZXJhcmNoaWNhbC50cmVlU3BhY2luZztcbiAgICAgICAgICBzaGlmdFRyZWUoaSArIDEsIHNoaWZ0QnkpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBzaGlmdCBhIHNpbmdsZSB0cmVlIGJ5IGFuIG9mZnNldFxuICAgICAgdmFyIHNoaWZ0VHJlZSA9IGZ1bmN0aW9uIHNoaWZ0VHJlZShpbmRleCwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciB0cmVlcyA9IF90aGlzMy5oaWVyYXJjaGljYWwudHJlZXM7XG5cbiAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIHRyZWVzKSB7XG4gICAgICAgICAgaWYgKHRyZWVzLmhhc093blByb3BlcnR5KG5vZGVJZCkpIHtcbiAgICAgICAgICAgIGlmICh0cmVlc1tub2RlSWRdID09PSBpbmRleCkge1xuICAgICAgICAgICAgICBfdGhpczMuZGlyZWN0aW9uLnNoaWZ0KG5vZGVJZCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIGdldCB0aGUgd2lkdGggb2YgYWxsIHRyZWVzXG4gICAgICB2YXIgZ2V0VHJlZVNpemVzID0gZnVuY3Rpb24gZ2V0VHJlZVNpemVzKCkge1xuICAgICAgICB2YXIgdHJlZVdpZHRocyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzMy5oaWVyYXJjaGljYWwubnVtVHJlZXMoKTsgaSsrKSB7XG4gICAgICAgICAgdHJlZVdpZHRocy5wdXNoKF90aGlzMy5kaXJlY3Rpb24uZ2V0VHJlZVNpemUoaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmVlV2lkdGhzO1xuICAgICAgfTtcblxuICAgICAgLy8gZ2V0IGEgbWFwIG9mIGFsbCBub2RlcyBpbiB0aGlzIGJyYW5jaFxuICAgICAgdmFyIGdldEJyYW5jaE5vZGVzID0gZnVuY3Rpb24gZ2V0QnJhbmNoTm9kZXMoc291cmNlLCBtYXApIHtcbiAgICAgICAgaWYgKG1hcFtzb3VyY2UuaWRdKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG1hcFtzb3VyY2UuaWRdID0gdHJ1ZTtcbiAgICAgICAgaWYgKF90aGlzMy5oaWVyYXJjaGljYWwuY2hpbGRyZW5SZWZlcmVuY2Vbc291cmNlLmlkXSkge1xuICAgICAgICAgIHZhciBjaGlsZHJlbiA9IF90aGlzMy5oaWVyYXJjaGljYWwuY2hpbGRyZW5SZWZlcmVuY2Vbc291cmNlLmlkXTtcbiAgICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBnZXRCcmFuY2hOb2RlcyhfdGhpczMuYm9keS5ub2Rlc1tjaGlsZHJlbltpXV0sIG1hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBnZXQgYSBtaW4gbWF4IHdpZHRoIGFzIHdlbGwgYXMgdGhlIG1heGltdW0gbW92ZW1lbnQgc3BhY2UgaXQgaGFzIG9uIGVpdGhlciBzaWRlc1xuICAgICAgLy8gd2UgdXNlIG1pbiBtYXggdGVybWlub2xvZ3kgYmVjYXVzZSB3aWR0aCBhbmQgaGVpZ2h0IGNhbiBpbnRlcmNoYW5nZSBkZXBlbmRpbmcgb24gdGhlIGRpcmVjdGlvbiBvZiB0aGUgbGF5b3V0XG4gICAgICB2YXIgZ2V0QnJhbmNoQm91bmRhcnkgPSBmdW5jdGlvbiBnZXRCcmFuY2hCb3VuZGFyeShicmFuY2hNYXApIHtcbiAgICAgICAgdmFyIG1heExldmVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxZTk7XG5cbiAgICAgICAgdmFyIG1pblNwYWNlID0gMWU5O1xuICAgICAgICB2YXIgbWF4U3BhY2UgPSAxZTk7XG4gICAgICAgIHZhciBtaW4gPSAxZTk7XG4gICAgICAgIHZhciBtYXggPSAtMWU5O1xuICAgICAgICBmb3IgKHZhciBicmFuY2hOb2RlIGluIGJyYW5jaE1hcCkge1xuICAgICAgICAgIGlmIChicmFuY2hNYXAuaGFzT3duUHJvcGVydHkoYnJhbmNoTm9kZSkpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gX3RoaXMzLmJvZHkubm9kZXNbYnJhbmNoTm9kZV07XG4gICAgICAgICAgICB2YXIgbGV2ZWwgPSBfdGhpczMuaGllcmFyY2hpY2FsLmxldmVsc1tub2RlLmlkXTtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IF90aGlzMy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24obm9kZSk7XG5cbiAgICAgICAgICAgIC8vIGdldCB0aGUgc3BhY2UgYXJvdW5kIHRoZSBub2RlLlxuXG4gICAgICAgICAgICB2YXIgX2dldFNwYWNlQXJvdW5kTm9kZTIgPSBfdGhpczMuX2dldFNwYWNlQXJvdW5kTm9kZShub2RlLCBicmFuY2hNYXApLFxuICAgICAgICAgICAgICAgIF9nZXRTcGFjZUFyb3VuZE5vZGUzID0gKDAsIF9zbGljZWRUb0FycmF5M1snZGVmYXVsdCddKShfZ2V0U3BhY2VBcm91bmROb2RlMiwgMiksXG4gICAgICAgICAgICAgICAgbWluU3BhY2VOb2RlID0gX2dldFNwYWNlQXJvdW5kTm9kZTNbMF0sXG4gICAgICAgICAgICAgICAgbWF4U3BhY2VOb2RlID0gX2dldFNwYWNlQXJvdW5kTm9kZTNbMV07XG5cbiAgICAgICAgICAgIG1pblNwYWNlID0gTWF0aC5taW4obWluU3BhY2VOb2RlLCBtaW5TcGFjZSk7XG4gICAgICAgICAgICBtYXhTcGFjZSA9IE1hdGgubWluKG1heFNwYWNlTm9kZSwgbWF4U3BhY2UpO1xuXG4gICAgICAgICAgICAvLyB0aGUgd2lkdGggaXMgb25seSByZWxldmFudCBmb3IgdGhlIGxldmVscyB0d28gbm9kZXMgaGF2ZSBpbiBjb21tb24uIFRoaXMgaXMgd2h5IHdlIGZpbHRlciBvbiB0aGlzLlxuICAgICAgICAgICAgaWYgKGxldmVsIDw9IG1heExldmVsKSB7XG4gICAgICAgICAgICAgIG1pbiA9IE1hdGgubWluKHBvc2l0aW9uLCBtaW4pO1xuICAgICAgICAgICAgICBtYXggPSBNYXRoLm1heChwb3NpdGlvbiwgbWF4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW21pbiwgbWF4LCBtaW5TcGFjZSwgbWF4U3BhY2VdO1xuICAgICAgfTtcblxuICAgICAgLy8gY2hlY2sgd2hhdCB0aGUgbWF4aW11bSBsZXZlbCBpcyB0aGVzZSBub2RlcyBoYXZlIGluIGNvbW1vbi5cbiAgICAgIHZhciBnZXRDb2xsaXNpb25MZXZlbCA9IGZ1bmN0aW9uIGdldENvbGxpc2lvbkxldmVsKG5vZGUxLCBub2RlMikge1xuICAgICAgICB2YXIgbWF4TGV2ZWwxID0gX3RoaXMzLmhpZXJhcmNoaWNhbC5nZXRNYXhMZXZlbChub2RlMS5pZCk7XG4gICAgICAgIHZhciBtYXhMZXZlbDIgPSBfdGhpczMuaGllcmFyY2hpY2FsLmdldE1heExldmVsKG5vZGUyLmlkKTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKG1heExldmVsMSwgbWF4TGV2ZWwyKTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29uZGVuc2UgZWxlbWVudHMuIFRoZXNlIGNhbiBiZSBub2RlcyBvciBicmFuY2hlcyBkZXBlbmRpbmcgb24gdGhlIGNhbGxiYWNrLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBsZXZlbHNcbiAgICAgICAqIEBwYXJhbSB7Kn0gY2VudGVyUGFyZW50c1xuICAgICAgICovXG4gICAgICB2YXIgc2hpZnRFbGVtZW50c0Nsb3NlciA9IGZ1bmN0aW9uIHNoaWZ0RWxlbWVudHNDbG9zZXIoY2FsbGJhY2ssIGxldmVscywgY2VudGVyUGFyZW50cykge1xuICAgICAgICB2YXIgaGllciA9IF90aGlzMy5oaWVyYXJjaGljYWw7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbaV07XG4gICAgICAgICAgdmFyIGxldmVsTm9kZXMgPSBoaWVyLmRpc3RyaWJ1dGlvbk9yZGVyaW5nW2xldmVsXTtcbiAgICAgICAgICBpZiAobGV2ZWxOb2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxldmVsTm9kZXMubGVuZ3RoIC0gMTsgaisrKSB7XG4gICAgICAgICAgICAgIHZhciBub2RlMSA9IGxldmVsTm9kZXNbal07XG4gICAgICAgICAgICAgIHZhciBub2RlMiA9IGxldmVsTm9kZXNbaiArIDFdO1xuXG4gICAgICAgICAgICAgIC8vIE5PVEU6IGxvZ2ljIG1haW50YWluZWQgYXMgaXQgd2FzOyBpZiBub2RlcyBoYXZlIHNhbWUgYW5jZXN0b3IsXG4gICAgICAgICAgICAgIC8vICAgICAgIHRoZW4gb2YgY291cnNlIHRoZXkgYXJlIGluIHRoZSBzYW1lIHN1Yi1uZXR3b3JrLlxuICAgICAgICAgICAgICBpZiAoaGllci5oYXNTYW1lUGFyZW50KG5vZGUxLCBub2RlMikgJiYgaGllci5pblNhbWVTdWJOZXR3b3JrKG5vZGUxLCBub2RlMikpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhub2RlMSwgbm9kZTIsIGNlbnRlclBhcmVudHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBjYWxsYmFjayBmb3Igc2hpZnRpbmcgYnJhbmNoZXNcbiAgICAgIHZhciBicmFuY2hTaGlmdENhbGxiYWNrID0gZnVuY3Rpb24gYnJhbmNoU2hpZnRDYWxsYmFjayhub2RlMSwgbm9kZTIpIHtcbiAgICAgICAgdmFyIGNlbnRlclBhcmVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgICAgICAgLy93aW5kb3cuQ0FMTEJBQ0tTLnB1c2goKCkgPT4ge1xuICAgICAgICB2YXIgcG9zMSA9IF90aGlzMy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24obm9kZTEpO1xuICAgICAgICB2YXIgcG9zMiA9IF90aGlzMy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24obm9kZTIpO1xuICAgICAgICB2YXIgZGlmZkFicyA9IE1hdGguYWJzKHBvczIgLSBwb3MxKTtcbiAgICAgICAgdmFyIG5vZGVTcGFjaW5nID0gX3RoaXMzLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nO1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiTk9XIENIRUNLSU5HOlwiLCBub2RlMS5pZCwgbm9kZTIuaWQsIGRpZmZBYnMpO1xuICAgICAgICBpZiAoZGlmZkFicyA+IG5vZGVTcGFjaW5nKSB7XG4gICAgICAgICAgdmFyIGJyYW5jaE5vZGVzMSA9IHt9O1xuICAgICAgICAgIHZhciBicmFuY2hOb2RlczIgPSB7fTtcblxuICAgICAgICAgIGdldEJyYW5jaE5vZGVzKG5vZGUxLCBicmFuY2hOb2RlczEpO1xuICAgICAgICAgIGdldEJyYW5jaE5vZGVzKG5vZGUyLCBicmFuY2hOb2RlczIpO1xuXG4gICAgICAgICAgLy8gY2hlY2sgdGhlIGxhcmdlc3QgZGlzdGFuY2UgYmV0d2VlbiB0aGUgYnJhbmNoZXNcbiAgICAgICAgICB2YXIgbWF4TGV2ZWwgPSBnZXRDb2xsaXNpb25MZXZlbChub2RlMSwgbm9kZTIpO1xuICAgICAgICAgIHZhciBicmFuY2hOb2RlQm91bmRhcnkxID0gZ2V0QnJhbmNoQm91bmRhcnkoYnJhbmNoTm9kZXMxLCBtYXhMZXZlbCk7XG4gICAgICAgICAgdmFyIGJyYW5jaE5vZGVCb3VuZGFyeTIgPSBnZXRCcmFuY2hCb3VuZGFyeShicmFuY2hOb2RlczIsIG1heExldmVsKTtcbiAgICAgICAgICB2YXIgbWF4MSA9IGJyYW5jaE5vZGVCb3VuZGFyeTFbMV07XG4gICAgICAgICAgdmFyIG1pbjIgPSBicmFuY2hOb2RlQm91bmRhcnkyWzBdO1xuICAgICAgICAgIHZhciBtaW5TcGFjZTIgPSBicmFuY2hOb2RlQm91bmRhcnkyWzJdO1xuXG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhub2RlMS5pZCwgZ2V0QnJhbmNoQm91bmRhcnkoYnJhbmNoTm9kZXMxLCBtYXhMZXZlbCksIG5vZGUyLmlkLFxuICAgICAgICAgIC8vICAgICAgICAgICAgZ2V0QnJhbmNoQm91bmRhcnkoYnJhbmNoTm9kZXMyLCBtYXhMZXZlbCksIG1heExldmVsKTtcbiAgICAgICAgICB2YXIgZGlmZkJyYW5jaCA9IE1hdGguYWJzKG1heDEgLSBtaW4yKTtcbiAgICAgICAgICBpZiAoZGlmZkJyYW5jaCA+IG5vZGVTcGFjaW5nKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gbWF4MSAtIG1pbjIgKyBub2RlU3BhY2luZztcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAtbWluU3BhY2UyICsgbm9kZVNwYWNpbmcpIHtcbiAgICAgICAgICAgICAgb2Zmc2V0ID0gLW1pblNwYWNlMiArIG5vZGVTcGFjaW5nO1xuICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiUkVTRVRUSU5HIE9GRlNFVFwiLCBtYXgxIC0gbWluMiArIHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcsIC1taW5TcGFjZTIsIG9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiU0hJRlRJTkdcIiwgbm9kZTIuaWQsIG9mZnNldCk7XG4gICAgICAgICAgICAgIF90aGlzMy5fc2hpZnRCbG9jayhub2RlMi5pZCwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgc3RpbGxTaGlmdGluZyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgaWYgKGNlbnRlclBhcmVudCA9PT0gdHJ1ZSkgX3RoaXMzLl9jZW50ZXJQYXJlbnQobm9kZTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvL3RoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVkcmF3XCIpO30pXG4gICAgICB9O1xuXG4gICAgICB2YXIgbWluaW1pemVFZGdlTGVuZ3RoID0gZnVuY3Rpb24gbWluaW1pemVFZGdlTGVuZ3RoKGl0ZXJhdGlvbnMsIG5vZGUpIHtcbiAgICAgICAgLy93aW5kb3cuQ0FMTEJBQ0tTLnB1c2goKCkgPT4ge1xuICAgICAgICAvLyAgY29uc29sZS5sb2coXCJ0c1wiLG5vZGUuaWQpO1xuICAgICAgICB2YXIgbm9kZUlkID0gbm9kZS5pZDtcbiAgICAgICAgdmFyIGFsbEVkZ2VzID0gbm9kZS5lZGdlcztcbiAgICAgICAgdmFyIG5vZGVMZXZlbCA9IF90aGlzMy5oaWVyYXJjaGljYWwubGV2ZWxzW25vZGUuaWRdO1xuXG4gICAgICAgIC8vIGdhdGhlciBjb25zdGFudHNcbiAgICAgICAgdmFyIEMyID0gX3RoaXMzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmxldmVsU2VwYXJhdGlvbiAqIF90aGlzMy5vcHRpb25zLmhpZXJhcmNoaWNhbC5sZXZlbFNlcGFyYXRpb247XG4gICAgICAgIHZhciByZWZlcmVuY2VOb2RlcyA9IHt9O1xuICAgICAgICB2YXIgYWJvdmVFZGdlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbEVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVkZ2UgPSBhbGxFZGdlc1tpXTtcbiAgICAgICAgICBpZiAoZWRnZS50b0lkICE9IGVkZ2UuZnJvbUlkKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXJOb2RlID0gZWRnZS50b0lkID09IG5vZGVJZCA/IGVkZ2UuZnJvbSA6IGVkZ2UudG87XG4gICAgICAgICAgICByZWZlcmVuY2VOb2Rlc1thbGxFZGdlc1tpXS5pZF0gPSBvdGhlck5vZGU7XG4gICAgICAgICAgICBpZiAoX3RoaXMzLmhpZXJhcmNoaWNhbC5sZXZlbHNbb3RoZXJOb2RlLmlkXSA8IG5vZGVMZXZlbCkge1xuICAgICAgICAgICAgICBhYm92ZUVkZ2VzLnB1c2goZWRnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGlmZmVyZW50aWF0ZWQgc3VtIG9mIGxlbmd0aHMgYmFzZWQgb24gb25seSBtb3Zpbmcgb25lIG5vZGUgb3ZlciBvbmUgYXhpc1xuICAgICAgICB2YXIgZ2V0RnggPSBmdW5jdGlvbiBnZXRGeChwb2ludCwgZWRnZXMpIHtcbiAgICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBlZGdlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgICBpZiAocmVmZXJlbmNlTm9kZXNbZWRnZXNbX2kyXS5pZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB2YXIgYSA9IF90aGlzMy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24ocmVmZXJlbmNlTm9kZXNbZWRnZXNbX2kyXS5pZF0pIC0gcG9pbnQ7XG4gICAgICAgICAgICAgIHN1bSArPSBhIC8gTWF0aC5zcXJ0KGEgKiBhICsgQzIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3VtO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGRvdWJseSBkaWZmZXJlbnRpYXRlZCBzdW0gb2YgbGVuZ3RocyBiYXNlZCBvbiBvbmx5IG1vdmluZyBvbmUgbm9kZSBvdmVyIG9uZSBheGlzXG4gICAgICAgIHZhciBnZXRERnggPSBmdW5jdGlvbiBnZXRERngocG9pbnQsIGVkZ2VzKSB7XG4gICAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgZWRnZXMubGVuZ3RoOyBfaTMrKykge1xuICAgICAgICAgICAgaWYgKHJlZmVyZW5jZU5vZGVzW2VkZ2VzW19pM10uaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdmFyIGEgPSBfdGhpczMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKHJlZmVyZW5jZU5vZGVzW2VkZ2VzW19pM10uaWRdKSAtIHBvaW50O1xuICAgICAgICAgICAgICBzdW0gLT0gQzIgKiBNYXRoLnBvdyhhICogYSArIEMyLCAtMS41KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHN1bTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZ2V0R3Vlc3MgPSBmdW5jdGlvbiBnZXRHdWVzcyhpdGVyYXRpb25zLCBlZGdlcykge1xuICAgICAgICAgIHZhciBndWVzcyA9IF90aGlzMy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24obm9kZSk7XG4gICAgICAgICAgLy8gTmV3dG9uJ3MgbWV0aG9kIGZvciBvcHRpbWl6YXRpb25cbiAgICAgICAgICB2YXIgZ3Vlc3NNYXAgPSB7fTtcbiAgICAgICAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBpdGVyYXRpb25zOyBfaTQrKykge1xuICAgICAgICAgICAgdmFyIGZ4ID0gZ2V0RngoZ3Vlc3MsIGVkZ2VzKTtcbiAgICAgICAgICAgIHZhciBkZnggPSBnZXRERngoZ3Vlc3MsIGVkZ2VzKTtcblxuICAgICAgICAgICAgLy8gd2UgbGltaXQgdGhlIG1vdmVtZW50IHRvIGF2b2lkIGluc3RhYmlsaXR5LlxuICAgICAgICAgICAgdmFyIGxpbWl0ID0gNDA7XG4gICAgICAgICAgICB2YXIgcmF0aW8gPSBNYXRoLm1heCgtbGltaXQsIE1hdGgubWluKGxpbWl0LCBNYXRoLnJvdW5kKGZ4IC8gZGZ4KSkpO1xuICAgICAgICAgICAgZ3Vlc3MgPSBndWVzcyAtIHJhdGlvO1xuICAgICAgICAgICAgLy8gcmVkdWNlIGR1cGxpY2F0ZXNcbiAgICAgICAgICAgIGlmIChndWVzc01hcFtndWVzc10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGd1ZXNzTWFwW2d1ZXNzXSA9IF9pNDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGd1ZXNzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBtb3ZlQnJhbmNoID0gZnVuY3Rpb24gbW92ZUJyYW5jaChndWVzcykge1xuICAgICAgICAgIC8vIHBvc2l0aW9uIG5vZGUgaWYgdGhlcmUgaXMgc3BhY2VcbiAgICAgICAgICB2YXIgbm9kZVBvc2l0aW9uID0gX3RoaXMzLmRpcmVjdGlvbi5nZXRQb3NpdGlvbihub2RlKTtcblxuICAgICAgICAgIC8vIGNoZWNrIG1vdmFibGUgYXJlYSBvZiB0aGUgYnJhbmNoXG4gICAgICAgICAgaWYgKGJyYW5jaGVzW25vZGUuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBicmFuY2hOb2RlcyA9IHt9O1xuICAgICAgICAgICAgZ2V0QnJhbmNoTm9kZXMobm9kZSwgYnJhbmNoTm9kZXMpO1xuICAgICAgICAgICAgYnJhbmNoZXNbbm9kZS5pZF0gPSBicmFuY2hOb2RlcztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGJyYW5jaEJvdW5kYXJ5ID0gZ2V0QnJhbmNoQm91bmRhcnkoYnJhbmNoZXNbbm9kZS5pZF0pO1xuICAgICAgICAgIHZhciBtaW5TcGFjZUJyYW5jaCA9IGJyYW5jaEJvdW5kYXJ5WzJdO1xuICAgICAgICAgIHZhciBtYXhTcGFjZUJyYW5jaCA9IGJyYW5jaEJvdW5kYXJ5WzNdO1xuXG4gICAgICAgICAgdmFyIGRpZmYgPSBndWVzcyAtIG5vZGVQb3NpdGlvbjtcblxuICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIGFyZSBhbGxvd2VkIHRvIG1vdmUgdGhlIG5vZGU6XG4gICAgICAgICAgdmFyIGJyYW5jaE9mZnNldCA9IDA7XG4gICAgICAgICAgaWYgKGRpZmYgPiAwKSB7XG4gICAgICAgICAgICBicmFuY2hPZmZzZXQgPSBNYXRoLm1pbihkaWZmLCBtYXhTcGFjZUJyYW5jaCAtIF90aGlzMy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChkaWZmIDwgMCkge1xuICAgICAgICAgICAgYnJhbmNoT2Zmc2V0ID0gLU1hdGgubWluKC1kaWZmLCBtaW5TcGFjZUJyYW5jaCAtIF90aGlzMy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGJyYW5jaE9mZnNldCAhPSAwKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwibW92aW5nIGJyYW5jaDpcIixicmFuY2hPZmZzZXQsIG1heFNwYWNlQnJhbmNoLCBtaW5TcGFjZUJyYW5jaClcbiAgICAgICAgICAgIF90aGlzMy5fc2hpZnRCbG9jayhub2RlLmlkLCBicmFuY2hPZmZzZXQpO1xuICAgICAgICAgICAgLy90aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlZHJhd1wiKTtcbiAgICAgICAgICAgIHN0aWxsU2hpZnRpbmcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbW92ZU5vZGUgPSBmdW5jdGlvbiBtb3ZlTm9kZShndWVzcykge1xuICAgICAgICAgIHZhciBub2RlUG9zaXRpb24gPSBfdGhpczMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKG5vZGUpO1xuXG4gICAgICAgICAgLy8gcG9zaXRpb24gbm9kZSBpZiB0aGVyZSBpcyBzcGFjZVxuXG4gICAgICAgICAgdmFyIF9nZXRTcGFjZUFyb3VuZE5vZGU0ID0gX3RoaXMzLl9nZXRTcGFjZUFyb3VuZE5vZGUobm9kZSksXG4gICAgICAgICAgICAgIF9nZXRTcGFjZUFyb3VuZE5vZGU1ID0gKDAsIF9zbGljZWRUb0FycmF5M1snZGVmYXVsdCddKShfZ2V0U3BhY2VBcm91bmROb2RlNCwgMiksXG4gICAgICAgICAgICAgIG1pblNwYWNlID0gX2dldFNwYWNlQXJvdW5kTm9kZTVbMF0sXG4gICAgICAgICAgICAgIG1heFNwYWNlID0gX2dldFNwYWNlQXJvdW5kTm9kZTVbMV07XG5cbiAgICAgICAgICB2YXIgZGlmZiA9IGd1ZXNzIC0gbm9kZVBvc2l0aW9uO1xuICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIGFyZSBhbGxvd2VkIHRvIG1vdmUgdGhlIG5vZGU6XG4gICAgICAgICAgdmFyIG5ld1Bvc2l0aW9uID0gbm9kZVBvc2l0aW9uO1xuICAgICAgICAgIGlmIChkaWZmID4gMCkge1xuICAgICAgICAgICAgbmV3UG9zaXRpb24gPSBNYXRoLm1pbihub2RlUG9zaXRpb24gKyAobWF4U3BhY2UgLSBfdGhpczMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcpLCBndWVzcyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChkaWZmIDwgMCkge1xuICAgICAgICAgICAgbmV3UG9zaXRpb24gPSBNYXRoLm1heChub2RlUG9zaXRpb24gLSAobWluU3BhY2UgLSBfdGhpczMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcpLCBndWVzcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG5ld1Bvc2l0aW9uICE9PSBub2RlUG9zaXRpb24pIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJtb3ZpbmcgTm9kZTpcIixkaWZmLCBtaW5TcGFjZSwgbWF4U3BhY2UpO1xuICAgICAgICAgICAgX3RoaXMzLmRpcmVjdGlvbi5zZXRQb3NpdGlvbihub2RlLCBuZXdQb3NpdGlvbik7XG4gICAgICAgICAgICAvL3RoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVkcmF3XCIpO1xuICAgICAgICAgICAgc3RpbGxTaGlmdGluZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBndWVzcyA9IGdldEd1ZXNzKGl0ZXJhdGlvbnMsIGFib3ZlRWRnZXMpO1xuICAgICAgICBtb3ZlQnJhbmNoKGd1ZXNzKTtcbiAgICAgICAgZ3Vlc3MgPSBnZXRHdWVzcyhpdGVyYXRpb25zLCBhbGxFZGdlcyk7XG4gICAgICAgIG1vdmVOb2RlKGd1ZXNzKTtcbiAgICAgICAgLy99KVxuICAgICAgfTtcblxuICAgICAgLy8gbWV0aG9kIHRvIHJlbW92ZSB3aGl0ZXNwYWNlIGJldHdlZW4gYnJhbmNoZXMuIEJlY2F1c2Ugd2UgZG8gYm90dG9tIHVwLCB3ZSBjYW4gY2VudGVyIHRoZSBwYXJlbnRzLlxuICAgICAgdmFyIG1pbmltaXplRWRnZUxlbmd0aEJvdHRvbVVwID0gZnVuY3Rpb24gbWluaW1pemVFZGdlTGVuZ3RoQm90dG9tVXAoaXRlcmF0aW9ucykge1xuICAgICAgICB2YXIgbGV2ZWxzID0gX3RoaXMzLmhpZXJhcmNoaWNhbC5nZXRMZXZlbHMoKTtcbiAgICAgICAgbGV2ZWxzID0gbGV2ZWxzLnJldmVyc2UoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVyYXRpb25zOyBpKyspIHtcbiAgICAgICAgICBzdGlsbFNoaWZ0aW5nID0gZmFsc2U7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZXZlbHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBsZXZlbCA9IGxldmVsc1tqXTtcbiAgICAgICAgICAgIHZhciBsZXZlbE5vZGVzID0gX3RoaXMzLmhpZXJhcmNoaWNhbC5kaXN0cmlidXRpb25PcmRlcmluZ1tsZXZlbF07XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGxldmVsTm9kZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgbWluaW1pemVFZGdlTGVuZ3RoKDEwMDAsIGxldmVsTm9kZXNba10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RpbGxTaGlmdGluZyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkZJTklTSEVEIG1pbmltaXplRWRnZUxlbmd0aEJvdHRvbVVwIElOIFwiICsgaSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIG1ldGhvZCB0byByZW1vdmUgd2hpdGVzcGFjZSBiZXR3ZWVuIGJyYW5jaGVzLiBCZWNhdXNlIHdlIGRvIGJvdHRvbSB1cCwgd2UgY2FuIGNlbnRlciB0aGUgcGFyZW50cy5cbiAgICAgIHZhciBzaGlmdEJyYW5jaGVzQ2xvc2VyQm90dG9tVXAgPSBmdW5jdGlvbiBzaGlmdEJyYW5jaGVzQ2xvc2VyQm90dG9tVXAoaXRlcmF0aW9ucykge1xuICAgICAgICB2YXIgbGV2ZWxzID0gX3RoaXMzLmhpZXJhcmNoaWNhbC5nZXRMZXZlbHMoKTtcbiAgICAgICAgbGV2ZWxzID0gbGV2ZWxzLnJldmVyc2UoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVyYXRpb25zOyBpKyspIHtcbiAgICAgICAgICBzdGlsbFNoaWZ0aW5nID0gZmFsc2U7XG4gICAgICAgICAgc2hpZnRFbGVtZW50c0Nsb3NlcihicmFuY2hTaGlmdENhbGxiYWNrLCBsZXZlbHMsIHRydWUpO1xuICAgICAgICAgIGlmIChzdGlsbFNoaWZ0aW5nICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiRklOSVNIRUQgc2hpZnRCcmFuY2hlc0Nsb3NlckJvdHRvbVVwIElOIFwiICsgKGkrMSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBjZW50ZXIgYWxsIHBhcmVudHNcbiAgICAgIHZhciBjZW50ZXJBbGxQYXJlbnRzID0gZnVuY3Rpb24gY2VudGVyQWxsUGFyZW50cygpIHtcbiAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIF90aGlzMy5ib2R5Lm5vZGVzKSB7XG4gICAgICAgICAgaWYgKF90aGlzMy5ib2R5Lm5vZGVzLmhhc093blByb3BlcnR5KG5vZGVJZCkpIF90aGlzMy5fY2VudGVyUGFyZW50KF90aGlzMy5ib2R5Lm5vZGVzW25vZGVJZF0pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBjZW50ZXIgYWxsIHBhcmVudHNcbiAgICAgIHZhciBjZW50ZXJBbGxQYXJlbnRzQm90dG9tVXAgPSBmdW5jdGlvbiBjZW50ZXJBbGxQYXJlbnRzQm90dG9tVXAoKSB7XG4gICAgICAgIHZhciBsZXZlbHMgPSBfdGhpczMuaGllcmFyY2hpY2FsLmdldExldmVscygpO1xuICAgICAgICBsZXZlbHMgPSBsZXZlbHMucmV2ZXJzZSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxldmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBsZXZlbCA9IGxldmVsc1tpXTtcbiAgICAgICAgICB2YXIgbGV2ZWxOb2RlcyA9IF90aGlzMy5oaWVyYXJjaGljYWwuZGlzdHJpYnV0aW9uT3JkZXJpbmdbbGV2ZWxdO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGV2ZWxOb2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgX3RoaXMzLl9jZW50ZXJQYXJlbnQobGV2ZWxOb2Rlc1tqXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyB0aGUgYWN0dWFsIHdvcmsgaXMgZG9uZSBoZXJlLlxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuYmxvY2tTaGlmdGluZyA9PT0gdHJ1ZSkge1xuICAgICAgICBzaGlmdEJyYW5jaGVzQ2xvc2VyQm90dG9tVXAoNSk7XG4gICAgICAgIGNlbnRlckFsbFBhcmVudHMoKTtcbiAgICAgIH1cblxuICAgICAgLy8gbWluaW1pemUgZWRnZSBsZW5ndGhcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmVkZ2VNaW5pbWl6YXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgbWluaW1pemVFZGdlTGVuZ3RoQm90dG9tVXAoMjApO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5wYXJlbnRDZW50cmFsaXphdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICBjZW50ZXJBbGxQYXJlbnRzQm90dG9tVXAoKTtcbiAgICAgIH1cblxuICAgICAgc2hpZnRUcmVlcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZ2l2ZXMgdGhlIHNwYWNlIGFyb3VuZCB0aGUgbm9kZS4gSUYgYSBtYXAgaXMgc3VwcGxpZWQsIGl0IHdpbGwgb25seSBjaGVjayBhZ2FpbnN0IG5vZGVzIE5PVCBpbiB0aGUgbWFwLlxuICAgICAqIFRoaXMgaXMgdXNlZCB0byBvbmx5IGdldCB0aGUgZGlzdGFuY2VzIHRvIG5vZGVzIG91dHNpZGUgb2YgYSBicmFuY2guXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHt7Tm9kZS5pZDogdmlzLk5vZGV9fSBtYXBcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2dldFNwYWNlQXJvdW5kTm9kZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRTcGFjZUFyb3VuZE5vZGUobm9kZSwgbWFwKSB7XG4gICAgICB2YXIgdXNlTWFwID0gdHJ1ZTtcbiAgICAgIGlmIChtYXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1c2VNYXAgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBsZXZlbCA9IHRoaXMuaGllcmFyY2hpY2FsLmxldmVsc1tub2RlLmlkXTtcbiAgICAgIGlmIChsZXZlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuaGllcmFyY2hpY2FsLmRpc3RyaWJ1dGlvbkluZGV4W25vZGUuaWRdO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLmRpcmVjdGlvbi5nZXRQb3NpdGlvbihub2RlKTtcbiAgICAgICAgdmFyIG9yZGVyaW5nID0gdGhpcy5oaWVyYXJjaGljYWwuZGlzdHJpYnV0aW9uT3JkZXJpbmdbbGV2ZWxdO1xuICAgICAgICB2YXIgbWluU3BhY2UgPSAxZTk7XG4gICAgICAgIHZhciBtYXhTcGFjZSA9IDFlOTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgdmFyIHByZXZOb2RlID0gb3JkZXJpbmdbaW5kZXggLSAxXTtcbiAgICAgICAgICBpZiAodXNlTWFwID09PSB0cnVlICYmIG1hcFtwcmV2Tm9kZS5pZF0gPT09IHVuZGVmaW5lZCB8fCB1c2VNYXAgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB2YXIgcHJldlBvcyA9IHRoaXMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKHByZXZOb2RlKTtcbiAgICAgICAgICAgIG1pblNwYWNlID0gcG9zaXRpb24gLSBwcmV2UG9zO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleCAhPSBvcmRlcmluZy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgdmFyIG5leHROb2RlID0gb3JkZXJpbmdbaW5kZXggKyAxXTtcbiAgICAgICAgICBpZiAodXNlTWFwID09PSB0cnVlICYmIG1hcFtuZXh0Tm9kZS5pZF0gPT09IHVuZGVmaW5lZCB8fCB1c2VNYXAgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB2YXIgbmV4dFBvcyA9IHRoaXMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKG5leHROb2RlKTtcbiAgICAgICAgICAgIG1heFNwYWNlID0gTWF0aC5taW4obWF4U3BhY2UsIG5leHRQb3MgLSBwb3NpdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFttaW5TcGFjZSwgbWF4U3BhY2VdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFswLCAwXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXZSB1c2UgdGhpcyBtZXRob2QgdG8gY2VudGVyIGEgcGFyZW50IG5vZGUgYW5kIGNoZWNrIGlmIGl0IGRvZXMgbm90IGNyb3NzIG90aGVyIG5vZGVzIHdoZW4gaXQgZG9lcy5cbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfY2VudGVyUGFyZW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NlbnRlclBhcmVudChub2RlKSB7XG4gICAgICBpZiAodGhpcy5oaWVyYXJjaGljYWwucGFyZW50UmVmZXJlbmNlW25vZGUuaWRdKSB7XG4gICAgICAgIHZhciBwYXJlbnRzID0gdGhpcy5oaWVyYXJjaGljYWwucGFyZW50UmVmZXJlbmNlW25vZGUuaWRdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcGFyZW50SWQgPSBwYXJlbnRzW2ldO1xuICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gdGhpcy5ib2R5Lm5vZGVzW3BhcmVudElkXTtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmhpZXJhcmNoaWNhbC5jaGlsZHJlblJlZmVyZW5jZVtwYXJlbnRJZF07XG5cbiAgICAgICAgICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gZ2V0IHRoZSByYW5nZSBvZiB0aGUgY2hpbGRyZW5cbiAgICAgICAgICAgIHZhciBuZXdQb3NpdGlvbiA9IHRoaXMuX2dldENlbnRlclBvc2l0aW9uKGNoaWxkcmVuKTtcblxuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24ocGFyZW50Tm9kZSk7XG5cbiAgICAgICAgICAgIHZhciBfZ2V0U3BhY2VBcm91bmROb2RlNiA9IHRoaXMuX2dldFNwYWNlQXJvdW5kTm9kZShwYXJlbnROb2RlKSxcbiAgICAgICAgICAgICAgICBfZ2V0U3BhY2VBcm91bmROb2RlNyA9ICgwLCBfc2xpY2VkVG9BcnJheTNbJ2RlZmF1bHQnXSkoX2dldFNwYWNlQXJvdW5kTm9kZTYsIDIpLFxuICAgICAgICAgICAgICAgIG1pblNwYWNlID0gX2dldFNwYWNlQXJvdW5kTm9kZTdbMF0sXG4gICAgICAgICAgICAgICAgbWF4U3BhY2UgPSBfZ2V0U3BhY2VBcm91bmROb2RlN1sxXTtcblxuICAgICAgICAgICAgdmFyIGRpZmYgPSBwb3NpdGlvbiAtIG5ld1Bvc2l0aW9uO1xuICAgICAgICAgICAgaWYgKGRpZmYgPCAwICYmIE1hdGguYWJzKGRpZmYpIDwgbWF4U3BhY2UgLSB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nIHx8IGRpZmYgPiAwICYmIE1hdGguYWJzKGRpZmYpIDwgbWluU3BhY2UgLSB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nKSB7XG4gICAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uLnNldFBvc2l0aW9uKHBhcmVudE5vZGUsIG5ld1Bvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHBsYWNlcyB0aGUgbm9kZXMgb24gdGhlIGNhbnZhcyBiYXNlZCBvbiB0aGUgaGllcmFyY2hpYWwgZGlzdHJpYnV0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRpc3RyaWJ1dGlvbiB8IG9idGFpbmVkIGJ5IHRoZSBmdW5jdGlvbiB0aGlzLl9nZXREaXN0cmlidXRpb24oKVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19wbGFjZU5vZGVzQnlIaWVyYXJjaHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGxhY2VOb2Rlc0J5SGllcmFyY2h5KGRpc3RyaWJ1dGlvbikge1xuICAgICAgdGhpcy5wb3NpdGlvbmVkTm9kZXMgPSB7fTtcbiAgICAgIC8vIHN0YXJ0IHBsYWNpbmcgYWxsIHRoZSBsZXZlbCAwIG5vZGVzIGZpcnN0LiBUaGVuIHJlY3Vyc2l2ZWx5IHBvc2l0aW9uIHRoZWlyIGJyYW5jaGVzLlxuICAgICAgZm9yICh2YXIgbGV2ZWwgaW4gZGlzdHJpYnV0aW9uKSB7XG4gICAgICAgIGlmIChkaXN0cmlidXRpb24uaGFzT3duUHJvcGVydHkobGV2ZWwpKSB7XG4gICAgICAgICAgLy8gc29ydCBub2RlcyBpbiBsZXZlbCBieSBwb3NpdGlvbjpcbiAgICAgICAgICB2YXIgbm9kZUFycmF5ID0gKDAsIF9rZXlzMlsnZGVmYXVsdCddKShkaXN0cmlidXRpb25bbGV2ZWxdKTtcbiAgICAgICAgICBub2RlQXJyYXkgPSB0aGlzLl9pbmRleEFycmF5VG9Ob2Rlcyhub2RlQXJyYXkpO1xuICAgICAgICAgIHRoaXMuZGlyZWN0aW9uLnNvcnQobm9kZUFycmF5KTtcbiAgICAgICAgICB2YXIgaGFuZGxlZE5vZGVDb3VudCA9IDA7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBub2RlQXJyYXlbaV07XG4gICAgICAgICAgICBpZiAodGhpcy5wb3NpdGlvbmVkTm9kZXNbbm9kZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB2YXIgc3BhY2luZyA9IHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmc7XG4gICAgICAgICAgICAgIHZhciBwb3MgPSBzcGFjaW5nICogaGFuZGxlZE5vZGVDb3VudDtcbiAgICAgICAgICAgICAgLy8gV2UgZ2V0IHRoZSBYIG9yIFkgdmFsdWVzIHdlIG5lZWQgYW5kIHN0b3JlIHRoZW0gaW4gcG9zIGFuZCBwcmV2aW91c1Bvcy5cbiAgICAgICAgICAgICAgLy8gVGhlIGdldCBhbmQgc2V0IG1ha2Ugc3VyZSB3ZSBnZXQgWCBvciBZXG4gICAgICAgICAgICAgIGlmIChoYW5kbGVkTm9kZUNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIHBvcyA9IHRoaXMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKG5vZGVBcnJheVtpIC0gMV0pICsgc3BhY2luZztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLmRpcmVjdGlvbi5zZXRQb3NpdGlvbihub2RlLCBwb3MsIGxldmVsKTtcbiAgICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGVQb3NpdGlvbkFuZENvbnRpbnVlKG5vZGUsIGxldmVsLCBwb3MpO1xuXG4gICAgICAgICAgICAgIGhhbmRsZWROb2RlQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGEgcmVjdXJzaXZlbHkgY2FsbGVkIGZ1bmN0aW9uIHRvIGVudW1lcmF0ZSB0aGUgYnJhbmNoZXMgZnJvbSB0aGUgbGFyZ2VzdCBodWJzIGFuZCBwbGFjZSB0aGUgbm9kZXNcbiAgICAgKiBvbiBhIFggcG9zaXRpb24gdGhhdCBlbnN1cmVzIHRoZXJlIHdpbGwgYmUgbm8gb3ZlcmxhcC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gcGFyZW50SWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyZW50TGV2ZWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfcGxhY2VCcmFuY2hOb2RlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wbGFjZUJyYW5jaE5vZGVzKHBhcmVudElkLCBwYXJlbnRMZXZlbCkge1xuICAgICAgdmFyIGNoaWxkUmVmID0gdGhpcy5oaWVyYXJjaGljYWwuY2hpbGRyZW5SZWZlcmVuY2VbcGFyZW50SWRdO1xuXG4gICAgICAvLyBpZiB0aGlzIGlzIG5vdCBhIHBhcmVudCwgY2FuY2VsIHRoZSBwbGFjaW5nLiBUaGlzIGNhbiBoYXBwZW4gd2l0aCBtdWx0aXBsZSBwYXJlbnRzIHRvIG9uZSBjaGlsZC5cbiAgICAgIGlmIChjaGlsZFJlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gZ2V0IGEgbGlzdCBvZiBjaGlsZE5vZGVzXG4gICAgICB2YXIgY2hpbGROb2RlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZFJlZi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGlsZE5vZGVzLnB1c2godGhpcy5ib2R5Lm5vZGVzW2NoaWxkUmVmW2ldXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHVzZSB0aGUgcG9zaXRpb25zIHRvIG9yZGVyIHRoZSBub2Rlcy5cbiAgICAgIHRoaXMuZGlyZWN0aW9uLnNvcnQoY2hpbGROb2Rlcyk7XG5cbiAgICAgIC8vIHBvc2l0aW9uIHRoZSBjaGlsZE5vZGVzXG4gICAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBjaGlsZE5vZGVzLmxlbmd0aDsgX2k1KyspIHtcbiAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXNbX2k1XTtcbiAgICAgICAgdmFyIGNoaWxkTm9kZUxldmVsID0gdGhpcy5oaWVyYXJjaGljYWwubGV2ZWxzW2NoaWxkTm9kZS5pZF07XG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBjaGlsZCBub2RlIGlzIGJlbG93IHRoZSBwYXJlbnQgbm9kZSBhbmQgaWYgaXQgaGFzIGFscmVhZHkgYmVlbiBwb3NpdGlvbmVkLlxuICAgICAgICBpZiAoY2hpbGROb2RlTGV2ZWwgPiBwYXJlbnRMZXZlbCAmJiB0aGlzLnBvc2l0aW9uZWROb2Rlc1tjaGlsZE5vZGUuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBnZXQgdGhlIGFtb3VudCBvZiBzcGFjZSByZXF1aXJlZCBmb3IgdGhpcyBub2RlLiBJZiBwYXJlbnQgdGhlIHdpZHRoIGlzIGJhc2VkIG9uIHRoZSBhbW91bnQgb2YgY2hpbGRyZW4uXG4gICAgICAgICAgdmFyIHNwYWNpbmcgPSB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nO1xuICAgICAgICAgIHZhciBwb3MgPSB2b2lkIDA7XG5cbiAgICAgICAgICAvLyB3ZSBnZXQgdGhlIFggb3IgWSB2YWx1ZXMgd2UgbmVlZCBhbmQgc3RvcmUgdGhlbSBpbiBwb3MgYW5kIHByZXZpb3VzUG9zLlxuICAgICAgICAgIC8vIFRoZSBnZXQgYW5kIHNldCBtYWtlIHN1cmUgd2UgZ2V0IFggb3IgWVxuICAgICAgICAgIGlmIChfaTUgPT09IDApIHtcbiAgICAgICAgICAgIHBvcyA9IHRoaXMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKHRoaXMuYm9keS5ub2Rlc1twYXJlbnRJZF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3MgPSB0aGlzLmRpcmVjdGlvbi5nZXRQb3NpdGlvbihjaGlsZE5vZGVzW19pNSAtIDFdKSArIHNwYWNpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZGlyZWN0aW9uLnNldFBvc2l0aW9uKGNoaWxkTm9kZSwgcG9zLCBjaGlsZE5vZGVMZXZlbCk7XG4gICAgICAgICAgdGhpcy5fdmFsaWRhdGVQb3NpdGlvbkFuZENvbnRpbnVlKGNoaWxkTm9kZSwgY2hpbGROb2RlTGV2ZWwsIHBvcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGNlbnRlciB0aGUgcGFyZW50IG5vZGVzLlxuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuX2dldENlbnRlclBvc2l0aW9uKGNoaWxkTm9kZXMpO1xuICAgICAgdGhpcy5kaXJlY3Rpb24uc2V0UG9zaXRpb24odGhpcy5ib2R5Lm5vZGVzW3BhcmVudElkXSwgY2VudGVyLCBwYXJlbnRMZXZlbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgY2hlY2tzIGZvciBvdmVybGFwIGFuZCBpZiByZXF1aXJlZCBzaGlmdHMgdGhlIGJyYW5jaC4gSXQgYWxzbyBrZWVwcyByZWNvcmRzIG9mIHBvc2l0aW9uZWQgbm9kZXMuXG4gICAgICogRmluYWxseSBpdCB3aWxsIGNhbGwgX3BsYWNlQnJhbmNoTm9kZXMgdG8gcGxhY2UgdGhlIGJyYW5jaCBub2Rlcy5cbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGV2ZWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3ZhbGlkYXRlUG9zaXRpb25BbmRDb250aW51ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF92YWxpZGF0ZVBvc2l0aW9uQW5kQ29udGludWUobm9kZSwgbGV2ZWwsIHBvcykge1xuICAgICAgLy8gVGhpcyBtZXRob2Qgb25seSB3b3JrcyBmb3IgZm9ybWFsIHRyZWVzIGFuZCBmb3JtYWwgZm9yZXN0c1xuICAgICAgLy8gRWFybHkgZXhpdCBpZiB0aGlzIGlzIG5vdCB0aGUgY2FzZVxuICAgICAgaWYgKCF0aGlzLmhpZXJhcmNoaWNhbC5pc1RyZWUpIHJldHVybjtcblxuICAgICAgLy8gaWYgb3ZlcmxhcCBoYXMgYmVlbiBkZXRlY3RlZCwgd2Ugc2hpZnQgdGhlIGJyYW5jaFxuICAgICAgaWYgKHRoaXMubGFzdE5vZGVPbkxldmVsW2xldmVsXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBwcmV2aW91c1BvcyA9IHRoaXMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKHRoaXMuYm9keS5ub2Rlc1t0aGlzLmxhc3ROb2RlT25MZXZlbFtsZXZlbF1dKTtcbiAgICAgICAgaWYgKHBvcyAtIHByZXZpb3VzUG9zIDwgdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZykge1xuICAgICAgICAgIHZhciBkaWZmID0gcHJldmlvdXNQb3MgKyB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nIC0gcG9zO1xuICAgICAgICAgIHZhciBzaGFyZWRQYXJlbnQgPSB0aGlzLl9maW5kQ29tbW9uUGFyZW50KHRoaXMubGFzdE5vZGVPbkxldmVsW2xldmVsXSwgbm9kZS5pZCk7XG4gICAgICAgICAgdGhpcy5fc2hpZnRCbG9jayhzaGFyZWRQYXJlbnQud2l0aENoaWxkLCBkaWZmKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmxhc3ROb2RlT25MZXZlbFtsZXZlbF0gPSBub2RlLmlkOyAvLyBzdG9yZSBjaGFuZ2UgaW4gcG9zaXRpb24uXG4gICAgICB0aGlzLnBvc2l0aW9uZWROb2Rlc1tub2RlLmlkXSA9IHRydWU7XG4gICAgICB0aGlzLl9wbGFjZUJyYW5jaE5vZGVzKG5vZGUuaWQsIGxldmVsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWNlaXZlcyBhbiBhcnJheSB3aXRoIG5vZGUgaW5kaWNlcyBhbmQgcmV0dXJucyBhbiBhcnJheSB3aXRoIHRoZSBhY3R1YWwgbm9kZSByZWZlcmVuY2VzLlxuICAgICAqIFVzZWQgZm9yIHNvcnRpbmcgYmFzZWQgb24gbm9kZSBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE5vZGUuaWQ+fSBpZEFycmF5XG4gICAgICogQHJldHVybnMge0FycmF5LjxOb2RlPn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2luZGV4QXJyYXlUb05vZGVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luZGV4QXJyYXlUb05vZGVzKGlkQXJyYXkpIHtcbiAgICAgIHZhciBhcnJheSA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycmF5LnB1c2godGhpcy5ib2R5Lm5vZGVzW2lkQXJyYXlbaV1dKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGdldCB0aGUgZGlzdHJpYnV0aW9uIG9mIGxldmVscyBiYXNlZCBvbiBodWJzaXplXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19nZXREaXN0cmlidXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGlzdHJpYnV0aW9uKCkge1xuICAgICAgdmFyIGRpc3RyaWJ1dGlvbiA9IHt9O1xuICAgICAgdmFyIG5vZGVJZCA9IHZvaWQgMCxcbiAgICAgICAgICBub2RlID0gdm9pZCAwO1xuXG4gICAgICAvLyB3ZSBmaXggWSBiZWNhdXNlIHRoZSBoaWVyYXJjaHkgaXMgdmVydGljYWwsXG4gICAgICAvLyB3ZSBmaXggWCBzbyB3ZSBkbyBub3QgZ2l2ZSBhIG5vZGUgYW4geCBwb3NpdGlvbiBmb3IgYSBzZWNvbmQgdGltZS5cbiAgICAgIC8vIHRoZSBmaXggb2YgWCBpcyByZW1vdmVkIGFmdGVyIHRoZSB4IHZhbHVlIGhhcyBiZWVuIHNldC5cbiAgICAgIGZvciAobm9kZUlkIGluIHRoaXMuYm9keS5ub2Rlcykge1xuICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzLmhhc093blByb3BlcnR5KG5vZGVJZCkpIHtcbiAgICAgICAgICBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICAgICAgdmFyIGxldmVsID0gdGhpcy5oaWVyYXJjaGljYWwubGV2ZWxzW25vZGVJZF0gPT09IHVuZGVmaW5lZCA/IDAgOiB0aGlzLmhpZXJhcmNoaWNhbC5sZXZlbHNbbm9kZUlkXTtcbiAgICAgICAgICB0aGlzLmRpcmVjdGlvbi5maXgobm9kZSwgbGV2ZWwpO1xuICAgICAgICAgIGlmIChkaXN0cmlidXRpb25bbGV2ZWxdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRpc3RyaWJ1dGlvbltsZXZlbF0gPSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGlzdHJpYnV0aW9uW2xldmVsXVtub2RlSWRdID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRpc3RyaWJ1dGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGFjdGl2ZSAoaS5lLiB2aXNpYmxlKSBlZGdlcyBmb3IgdGhpcyBub2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHZpcy5FZGdlPn0gQXJyYXkgb2YgZWRnZSBpbnN0YW5jZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZ2V0QWN0aXZlRWRnZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0QWN0aXZlRWRnZXMobm9kZSkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgdXRpbC5mb3JFYWNoKG5vZGUuZWRnZXMsIGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgIGlmIChfdGhpczQuYm9keS5lZGdlSW5kaWNlcy5pbmRleE9mKGVkZ2UuaWQpICE9PSAtMSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGVkZ2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGh1YnNpemVzIGZvciBhbGwgYWN0aXZlIG5vZGVzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZ2V0SHViU2l6ZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0SHViU2l6ZXMoKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgdmFyIGh1YlNpemVzID0ge307XG4gICAgICB2YXIgbm9kZUlkcyA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcztcblxuICAgICAgdXRpbC5mb3JFYWNoKG5vZGVJZHMsIGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfdGhpczUuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgICB2YXIgaHViU2l6ZSA9IF90aGlzNS5fZ2V0QWN0aXZlRWRnZXMobm9kZSkubGVuZ3RoO1xuICAgICAgICBodWJTaXplc1todWJTaXplXSA9IHRydWU7XG4gICAgICB9KTtcblxuICAgICAgLy8gTWFrZSBhbiBhcnJheSBvZiB0aGUgc2l6ZSBzb3J0ZWQgZGVzY2VuZGluZ1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgdXRpbC5mb3JFYWNoKGh1YlNpemVzLCBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgICByZXN1bHQucHVzaChOdW1iZXIoc2l6ZSkpO1xuICAgICAgfSk7XG5cbiAgICAgIFRpbVNvcnQuc29ydChyZXN1bHQsIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBiIC0gYTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRoaXMgZnVuY3Rpb24gYWxsb2NhdGVzIG5vZGVzIGluIGxldmVscyBiYXNlZCBvbiB0aGUgcmVjdXJzaXZlIGJyYW5jaGluZyBmcm9tIHRoZSBsYXJnZXN0IGh1YnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZGV0ZXJtaW5lTGV2ZWxzQnlIdWJzaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RldGVybWluZUxldmVsc0J5SHVic2l6ZSgpIHtcbiAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICB2YXIgbGV2ZWxEb3duc3RyZWFtID0gZnVuY3Rpb24gbGV2ZWxEb3duc3RyZWFtKG5vZGVBLCBub2RlQikge1xuICAgICAgICBfdGhpczYuaGllcmFyY2hpY2FsLmxldmVsRG93bnN0cmVhbShub2RlQSwgbm9kZUIpO1xuICAgICAgfTtcblxuICAgICAgdmFyIGh1YlNpemVzID0gdGhpcy5fZ2V0SHViU2l6ZXMoKTtcblxuICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoaSkge1xuICAgICAgICB2YXIgaHViU2l6ZSA9IGh1YlNpemVzW2ldO1xuICAgICAgICBpZiAoaHViU2l6ZSA9PT0gMCkgcmV0dXJuICdicmVhayc7XG5cbiAgICAgICAgdXRpbC5mb3JFYWNoKF90aGlzNi5ib2R5Lm5vZGVJbmRpY2VzLCBmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBfdGhpczYuYm9keS5ub2Rlc1tub2RlSWRdO1xuXG4gICAgICAgICAgaWYgKGh1YlNpemUgPT09IF90aGlzNi5fZ2V0QWN0aXZlRWRnZXMobm9kZSkubGVuZ3RoKSB7XG4gICAgICAgICAgICBfdGhpczYuX2NyYXdsTmV0d29yayhsZXZlbERvd25zdHJlYW0sIG5vZGVJZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaHViU2l6ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIF9yZXQgPSBfbG9vcChpKTtcblxuICAgICAgICBpZiAoX3JldCA9PT0gJ2JyZWFrJykgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVE9ETzogcmVsZWFzZSBmZWF0dXJlXG4gICAgICogVE9ETzogRGV0ZXJtaW5lIGlmIHRoaXMgZmVhdHVyZSBpcyBuZWVkZWQgYXQgYWxsXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZGV0ZXJtaW5lTGV2ZWxzQ3VzdG9tQ2FsbGJhY2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGV0ZXJtaW5lTGV2ZWxzQ3VzdG9tQ2FsbGJhY2soKSB7XG4gICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgdmFyIG1pbkxldmVsID0gMTAwMDAwO1xuXG4gICAgICAvLyBUT0RPOiB0aGlzIHNob3VsZCBjb21lIGZyb20gb3B0aW9ucy5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgdmFyIGN1c3RvbUNhbGxiYWNrID0gZnVuY3Rpb24gY3VzdG9tQ2FsbGJhY2sobm9kZUEsIG5vZGVCLCBlZGdlKSB7fTtcblxuICAgICAgLy8gVE9ETzogcGVyaGFwcyBtb3ZlIHRvIEhpZXJhcmNoaWNhbFN0YXR1cy5cbiAgICAgIC8vICAgICAgIEJ1dCBJIGN1cnJlbnRseSBkb24ndCBzZWUgdGhlIHBvaW50LCB0aGlzIG1ldGhvZCBpcyBub3QgdXNlZC5cbiAgICAgIHZhciBsZXZlbEJ5RGlyZWN0aW9uID0gZnVuY3Rpb24gbGV2ZWxCeURpcmVjdGlvbihub2RlQSwgbm9kZUIsIGVkZ2UpIHtcbiAgICAgICAgdmFyIGxldmVsQSA9IF90aGlzNy5oaWVyYXJjaGljYWwubGV2ZWxzW25vZGVBLmlkXTtcbiAgICAgICAgLy8gc2V0IGluaXRpYWwgbGV2ZWxcbiAgICAgICAgaWYgKGxldmVsQSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGV2ZWxBID0gX3RoaXM3LmhpZXJhcmNoaWNhbC5sZXZlbHNbbm9kZUEuaWRdID0gbWluTGV2ZWw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGlmZiA9IGN1c3RvbUNhbGxiYWNrKE5ldHdvcmtVdGlsLmNsb25lT3B0aW9ucyhub2RlQSwgJ25vZGUnKSwgTmV0d29ya1V0aWwuY2xvbmVPcHRpb25zKG5vZGVCLCAnbm9kZScpLCBOZXR3b3JrVXRpbC5jbG9uZU9wdGlvbnMoZWRnZSwgJ2VkZ2UnKSk7XG5cbiAgICAgICAgX3RoaXM3LmhpZXJhcmNoaWNhbC5sZXZlbHNbbm9kZUIuaWRdID0gbGV2ZWxBICsgZGlmZjtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX2NyYXdsTmV0d29yayhsZXZlbEJ5RGlyZWN0aW9uKTtcbiAgICAgIHRoaXMuaGllcmFyY2hpY2FsLnNldE1pbkxldmVsVG9aZXJvKHRoaXMuYm9keS5ub2Rlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWxsb2NhdGUgbm9kZXMgaW4gbGV2ZWxzIGJhc2VkIG9uIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGVkZ2VzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2RldGVybWluZUxldmVsc0RpcmVjdGVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RldGVybWluZUxldmVsc0RpcmVjdGVkKCkge1xuICAgICAgdmFyIF90aGlzOCA9IHRoaXM7XG5cbiAgICAgIHZhciBtaW5MZXZlbCA9IDEwMDAwO1xuXG4gICAgICAvKipcbiAgICAgICAqIENoZWNrIGlmIHRoZXJlIGlzIGFuIGVkZ2UgZ29pbmcgdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiBmb3IgZ2l2ZW4gZWRnZVxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RWRnZX0gZWRnZSAgZWRnZSB0byBjaGVja1xuICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlcmUncyBhbm90aGVyIGVkZ2UgZ29pbmcgaW50byB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uXG4gICAgICAgKi9cbiAgICAgIHZhciBpc0JpZGlyZWN0aW9uYWwgPSBmdW5jdGlvbiBpc0JpZGlyZWN0aW9uYWwoZWRnZSkge1xuICAgICAgICB1dGlsLmZvckVhY2goX3RoaXM4LmJvZHkuZWRnZXMsIGZ1bmN0aW9uIChvdGhlckVkZ2UpIHtcbiAgICAgICAgICBpZiAob3RoZXJFZGdlLnRvSWQgPT09IGVkZ2UuZnJvbUlkICYmIG90aGVyRWRnZS5mcm9tSWQgPT09IGVkZ2UudG9JZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuXG4gICAgICB2YXIgbGV2ZWxCeURpcmVjdGlvbiA9IGZ1bmN0aW9uIGxldmVsQnlEaXJlY3Rpb24obm9kZUEsIG5vZGVCLCBlZGdlKSB7XG4gICAgICAgIHZhciBsZXZlbEEgPSBfdGhpczguaGllcmFyY2hpY2FsLmxldmVsc1tub2RlQS5pZF07XG4gICAgICAgIHZhciBsZXZlbEIgPSBfdGhpczguaGllcmFyY2hpY2FsLmxldmVsc1tub2RlQi5pZF07XG5cbiAgICAgICAgaWYgKGlzQmlkaXJlY3Rpb25hbChlZGdlKSAmJiBsZXZlbEEgIT09IHVuZGVmaW5lZCAmJiBsZXZlbEIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIERvbid0IHJlZG8gdGhlIGxldmVsIGRldGVybWluYXRpb24gaWYgYWxyZWFkeSBkb25lIGluIHRoaXMgY2FzZS5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgaW5pdGlhbCBsZXZlbFxuICAgICAgICBpZiAobGV2ZWxBID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBsZXZlbEEgPSBfdGhpczguaGllcmFyY2hpY2FsLmxldmVsc1tub2RlQS5pZF0gPSBtaW5MZXZlbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWRnZS50b0lkID09IG5vZGVCLmlkKSB7XG4gICAgICAgICAgX3RoaXM4LmhpZXJhcmNoaWNhbC5sZXZlbHNbbm9kZUIuaWRdID0gbGV2ZWxBICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpczguaGllcmFyY2hpY2FsLmxldmVsc1tub2RlQi5pZF0gPSBsZXZlbEEgLSAxO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9jcmF3bE5ldHdvcmsobGV2ZWxCeURpcmVjdGlvbik7XG4gICAgICB0aGlzLmhpZXJhcmNoaWNhbC5zZXRNaW5MZXZlbFRvWmVybyh0aGlzLmJvZHkubm9kZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgYm9va2tlZXBpbmcgb2YgcGFyZW50IGFuZCBjaGlsZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZ2VuZXJhdGVNYXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2VuZXJhdGVNYXAoKSB7XG4gICAgICB2YXIgX3RoaXM5ID0gdGhpcztcblxuICAgICAgdmFyIGZpbGxJblJlbGF0aW9ucyA9IGZ1bmN0aW9uIGZpbGxJblJlbGF0aW9ucyhwYXJlbnROb2RlLCBjaGlsZE5vZGUpIHtcbiAgICAgICAgaWYgKF90aGlzOS5oaWVyYXJjaGljYWwubGV2ZWxzW2NoaWxkTm9kZS5pZF0gPiBfdGhpczkuaGllcmFyY2hpY2FsLmxldmVsc1twYXJlbnROb2RlLmlkXSkge1xuICAgICAgICAgIF90aGlzOS5oaWVyYXJjaGljYWwuYWRkUmVsYXRpb24ocGFyZW50Tm9kZS5pZCwgY2hpbGROb2RlLmlkKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5fY3Jhd2xOZXR3b3JrKGZpbGxJblJlbGF0aW9ucyk7XG4gICAgICB0aGlzLmhpZXJhcmNoaWNhbC5jaGVja0lmVHJlZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyYXdsIG92ZXIgdGhlIGVudGlyZSBuZXR3b3JrIGFuZCB1c2UgYSBjYWxsYmFjayBvbiBlYWNoIG5vZGUgY291cGxlIHRoYXQgaXMgY29ubmVjdGVkIHRvIGVhY2ggb3RoZXIuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrPWZ1bmN0aW9uKCl7fV0gICAgICAgICAgfCB3aWxsIHJlY2VpdmUgbm9kZUEsIG5vZGVCIGFuZCB0aGUgY29ubmVjdGluZyBlZGdlLiBBIGFuZCBCIGFyZSBkaXN0aW5jdC5cbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IHN0YXJ0aW5nTm9kZUlkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2NyYXdsTmV0d29yaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmF3bE5ldHdvcmsoKSB7XG4gICAgICB2YXIgX3RoaXMxMCA9IHRoaXM7XG5cbiAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZnVuY3Rpb24gKCkge307XG4gICAgICB2YXIgc3RhcnRpbmdOb2RlSWQgPSBhcmd1bWVudHNbMV07XG5cbiAgICAgIHZhciBwcm9ncmVzcyA9IHt9O1xuXG4gICAgICB2YXIgY3Jhd2xlciA9IGZ1bmN0aW9uIGNyYXdsZXIobm9kZSwgdHJlZSkge1xuICAgICAgICBpZiAocHJvZ3Jlc3Nbbm9kZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIF90aGlzMTAuaGllcmFyY2hpY2FsLnNldFRyZWVJbmRleChub2RlLCB0cmVlKTtcblxuICAgICAgICAgIHByb2dyZXNzW25vZGUuaWRdID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgY2hpbGROb2RlID0gdm9pZCAwO1xuICAgICAgICAgIHZhciBlZGdlcyA9IF90aGlzMTAuX2dldEFjdGl2ZUVkZ2VzKG5vZGUpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBlZGdlID0gZWRnZXNbaV07XG4gICAgICAgICAgICBpZiAoZWRnZS5jb25uZWN0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgaWYgKGVkZ2UudG9JZCA9PSBub2RlLmlkKSB7XG4gICAgICAgICAgICAgICAgLy8gTm90ICc9PT0nIGJlY2F1c2UgaWQncyBjYW4gYmUgc3RyaW5nIGFuZCBudW1lcmljXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlID0gZWRnZS5mcm9tO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGVkZ2UudG87XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAobm9kZS5pZCAhPSBjaGlsZE5vZGUuaWQpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3QgJyE9PScgYmVjYXVzZSBpZCdzIGNhbiBiZSBzdHJpbmcgYW5kIG51bWVyaWNcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhub2RlLCBjaGlsZE5vZGUsIGVkZ2UpO1xuICAgICAgICAgICAgICAgIGNyYXdsZXIoY2hpbGROb2RlLCB0cmVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKHN0YXJ0aW5nTm9kZUlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gQ3Jhd2wgb3ZlciBhbGwgbm9kZXNcbiAgICAgICAgdmFyIHRyZWVJbmRleCA9IDA7IC8vIFNlcnZlcyB0byBwYXNzIGEgdW5pcXVlIGlkIGZvciB0aGUgY3VycmVudCBkaXN0aW5jdCB0cmVlXG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbm9kZUlkID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzW2ldO1xuXG4gICAgICAgICAgaWYgKHByb2dyZXNzW25vZGVJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICAgIGNyYXdsZXIobm9kZSwgdHJlZUluZGV4KTtcbiAgICAgICAgICAgIHRyZWVJbmRleCArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ3Jhd2wgZnJvbSB0aGUgZ2l2ZW4gc3RhcnRpbmcgbm9kZVxuICAgICAgICB2YXIgX25vZGUyID0gdGhpcy5ib2R5Lm5vZGVzW3N0YXJ0aW5nTm9kZUlkXTtcbiAgICAgICAgaWYgKF9ub2RlMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignTm9kZSBub3QgZm91bmQ6Jywgc3RhcnRpbmdOb2RlSWQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjcmF3bGVyKF9ub2RlMik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2hpZnQgYSBicmFuY2ggYSBjZXJ0YWluIGRpc3RhbmNlXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBwYXJlbnRJZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaWZmXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3NoaWZ0QmxvY2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2hpZnRCbG9jayhwYXJlbnRJZCwgZGlmZikge1xuICAgICAgdmFyIF90aGlzMTEgPSB0aGlzO1xuXG4gICAgICB2YXIgcHJvZ3Jlc3MgPSB7fTtcbiAgICAgIHZhciBzaGlmdGVyID0gZnVuY3Rpb24gc2hpZnRlcihwYXJlbnRJZCkge1xuICAgICAgICBpZiAocHJvZ3Jlc3NbcGFyZW50SWRdKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHByb2dyZXNzW3BhcmVudElkXSA9IHRydWU7XG4gICAgICAgIF90aGlzMTEuZGlyZWN0aW9uLnNoaWZ0KHBhcmVudElkLCBkaWZmKTtcblxuICAgICAgICB2YXIgY2hpbGRSZWYgPSBfdGhpczExLmhpZXJhcmNoaWNhbC5jaGlsZHJlblJlZmVyZW5jZVtwYXJlbnRJZF07XG4gICAgICAgIGlmIChjaGlsZFJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZFJlZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc2hpZnRlcihjaGlsZFJlZltpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgc2hpZnRlcihwYXJlbnRJZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZCBhIGNvbW1vbiBwYXJlbnQgYmV0d2VlbiBicmFuY2hlcy5cbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IGNoaWxkQVxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gY2hpbGRCXG4gICAgICogQHJldHVybnMge3tmb3VuZFBhcmVudCwgd2l0aENoaWxkfX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZmluZENvbW1vblBhcmVudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kQ29tbW9uUGFyZW50KGNoaWxkQSwgY2hpbGRCKSB7XG4gICAgICB2YXIgX3RoaXMxMiA9IHRoaXM7XG5cbiAgICAgIHZhciBwYXJlbnRzID0ge307XG4gICAgICB2YXIgaXRlcmF0ZVBhcmVudHMgPSBmdW5jdGlvbiBpdGVyYXRlUGFyZW50cyhwYXJlbnRzLCBjaGlsZCkge1xuICAgICAgICB2YXIgcGFyZW50UmVmID0gX3RoaXMxMi5oaWVyYXJjaGljYWwucGFyZW50UmVmZXJlbmNlW2NoaWxkXTtcbiAgICAgICAgaWYgKHBhcmVudFJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnRSZWYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRSZWZbaV07XG4gICAgICAgICAgICBwYXJlbnRzW3BhcmVudF0gPSB0cnVlO1xuICAgICAgICAgICAgaXRlcmF0ZVBhcmVudHMocGFyZW50cywgcGFyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgZmluZFBhcmVudCA9IGZ1bmN0aW9uIGZpbmRQYXJlbnQocGFyZW50cywgY2hpbGQpIHtcbiAgICAgICAgdmFyIHBhcmVudFJlZiA9IF90aGlzMTIuaGllcmFyY2hpY2FsLnBhcmVudFJlZmVyZW5jZVtjaGlsZF07XG4gICAgICAgIGlmIChwYXJlbnRSZWYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50UmVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gcGFyZW50UmVmW2ldO1xuICAgICAgICAgICAgaWYgKHBhcmVudHNbcGFyZW50XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IGZvdW5kUGFyZW50OiBwYXJlbnQsIHdpdGhDaGlsZDogY2hpbGQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBicmFuY2ggPSBmaW5kUGFyZW50KHBhcmVudHMsIHBhcmVudCk7XG4gICAgICAgICAgICBpZiAoYnJhbmNoLmZvdW5kUGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBicmFuY2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZvdW5kUGFyZW50OiBudWxsLCB3aXRoQ2hpbGQ6IGNoaWxkIH07XG4gICAgICB9O1xuXG4gICAgICBpdGVyYXRlUGFyZW50cyhwYXJlbnRzLCBjaGlsZEEpO1xuICAgICAgcmV0dXJuIGZpbmRQYXJlbnQocGFyZW50cywgY2hpbGRCKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHN0cmF0ZWd5IHBhdHRlcm4gZm9yIGhhbmRsaW5nIHRoZSBjb29yZGluYXRlcyBnaXZlbiB0aGUgY3VycmVudCBkaXJlY3Rpb24uXG4gICAgICpcbiAgICAgKiBUaGUgaW5kaXZpZHVhbCBpbnN0YW5jZXMgY29udGFpbiBhbGwgdGhlIG9wZXJhdGlvbnMgYW5kIGRhdGEgc3BlY2lmaWMgdG8gYSBsYXlvdXQgZGlyZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZXZlbFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RvTm90VXBkYXRlPWZhbHNlXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldERpcmVjdGlvblN0cmF0ZWd5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGlyZWN0aW9uU3RyYXRlZ3koKSB7XG4gICAgICB2YXIgaXNWZXJ0aWNhbCA9IHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZGlyZWN0aW9uID09PSAnVUQnIHx8IHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZGlyZWN0aW9uID09PSAnRFUnO1xuXG4gICAgICBpZiAoaXNWZXJ0aWNhbCkge1xuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IG5ldyBWZXJ0aWNhbFN0cmF0ZWd5KHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBuZXcgSG9yaXpvbnRhbFN0cmF0ZWd5KHRoaXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB0aGUgY2VudGVyIHBvc2l0aW9uIG9mIGEgYnJhbmNoIGZyb20gdGhlIHBhc3NlZCBsaXN0IG9mIGNoaWxkIG5vZGVzXG4gICAgICpcbiAgICAgKiBUaGlzIHRha2VzIGludG8gYWNjb3VudCB0aGUgcG9zaXRpb25zIG9mIGFsbCB0aGUgY2hpbGQgbm9kZXMuXG4gICAgICogQHBhcmFtIHtBcnJheS48Tm9kZXx2aXMuTm9kZS5pZD59IGNoaWxkTm9kZXMgIEFycmF5IG9mIGVpdGhlciBjaGlsZCBub2RlcyBvciBub2RlIGlkJ3NcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2dldENlbnRlclBvc2l0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldENlbnRlclBvc2l0aW9uKGNoaWxkTm9kZXMpIHtcbiAgICAgIHZhciBtaW5Qb3MgPSAxZTk7XG4gICAgICB2YXIgbWF4UG9zID0gLTFlOTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZE5vZGUgPSB2b2lkIDA7XG4gICAgICAgIGlmIChjaGlsZE5vZGVzW2ldLmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzW2ldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjaGlsZE5vZGVJZCA9IGNoaWxkTm9kZXNbaV07XG4gICAgICAgICAgY2hpbGROb2RlID0gdGhpcy5ib2R5Lm5vZGVzW2NoaWxkTm9kZUlkXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKGNoaWxkTm9kZSk7XG4gICAgICAgIG1pblBvcyA9IE1hdGgubWluKG1pblBvcywgcG9zaXRpb24pO1xuICAgICAgICBtYXhQb3MgPSBNYXRoLm1heChtYXhQb3MsIHBvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDAuNSAqIChtaW5Qb3MgKyBtYXhQb3MpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTGF5b3V0RW5naW5lO1xufSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBMYXlvdXRFbmdpbmU7XG5cbi8qKiovIH0pLFxuLyogMTg4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8qKioqXG4gKiBUaGUgTUlUIExpY2Vuc2VcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgTWFyY28gWmljY2FyZGlcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICpcbiAqKioqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgaWYgKHRydWUpIHtcbiAgICAhKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbZXhwb3J0c10sIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9IChmYWN0b3J5KSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/XG5cdFx0XHRcdChfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18uYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXykpIDogX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGZhY3RvcnkoZXhwb3J0cyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG1vZCA9IHtcbiAgICAgIGV4cG9ydHM6IHt9XG4gICAgfTtcbiAgICBmYWN0b3J5KG1vZC5leHBvcnRzKTtcbiAgICBnbG9iYWwudGltc29ydCA9IG1vZC5leHBvcnRzO1xuICB9XG59KSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykge1xuICAndXNlIHN0cmljdCc7XG5cbiAgZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbiAgZXhwb3J0cy5zb3J0ID0gc29ydDtcblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBERUZBVUxUX01JTl9NRVJHRSA9IDMyO1xuXG4gIHZhciBERUZBVUxUX01JTl9HQUxMT1BJTkcgPSA3O1xuXG4gIHZhciBERUZBVUxUX1RNUF9TVE9SQUdFX0xFTkdUSCA9IDI1NjtcblxuICB2YXIgUE9XRVJTX09GX1RFTiA9IFsxZTAsIDFlMSwgMWUyLCAxZTMsIDFlNCwgMWU1LCAxZTYsIDFlNywgMWU4LCAxZTldO1xuXG4gIGZ1bmN0aW9uIGxvZzEwKHgpIHtcbiAgICBpZiAoeCA8IDFlNSkge1xuICAgICAgaWYgKHggPCAxZTIpIHtcbiAgICAgICAgcmV0dXJuIHggPCAxZTEgPyAwIDogMTtcbiAgICAgIH1cblxuICAgICAgaWYgKHggPCAxZTQpIHtcbiAgICAgICAgcmV0dXJuIHggPCAxZTMgPyAyIDogMztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDQ7XG4gICAgfVxuXG4gICAgaWYgKHggPCAxZTcpIHtcbiAgICAgIHJldHVybiB4IDwgMWU2ID8gNSA6IDY7XG4gICAgfVxuXG4gICAgaWYgKHggPCAxZTkpIHtcbiAgICAgIHJldHVybiB4IDwgMWU4ID8gNyA6IDg7XG4gICAgfVxuXG4gICAgcmV0dXJuIDk7XG4gIH1cblxuICBmdW5jdGlvbiBhbHBoYWJldGljYWxDb21wYXJlKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYgKH4gfmEgPT09IGEgJiYgfiB+YiA9PT0gYikge1xuICAgICAgaWYgKGEgPT09IDAgfHwgYiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChhIDwgMCB8fCBiIDwgMCkge1xuICAgICAgICBpZiAoYiA+PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGEgPj0gMCkge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgYSA9IC1hO1xuICAgICAgICBiID0gLWI7XG4gICAgICB9XG5cbiAgICAgIHZhciBhbCA9IGxvZzEwKGEpO1xuICAgICAgdmFyIGJsID0gbG9nMTAoYik7XG5cbiAgICAgIHZhciB0ID0gMDtcblxuICAgICAgaWYgKGFsIDwgYmwpIHtcbiAgICAgICAgYSAqPSBQT1dFUlNfT0ZfVEVOW2JsIC0gYWwgLSAxXTtcbiAgICAgICAgYiAvPSAxMDtcbiAgICAgICAgdCA9IC0xO1xuICAgICAgfSBlbHNlIGlmIChhbCA+IGJsKSB7XG4gICAgICAgIGIgKj0gUE9XRVJTX09GX1RFTlthbCAtIGJsIC0gMV07XG4gICAgICAgIGEgLz0gMTA7XG4gICAgICAgIHQgPSAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICByZXR1cm4gdDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiAxO1xuICAgIH1cblxuICAgIHZhciBhU3RyID0gU3RyaW5nKGEpO1xuICAgIHZhciBiU3RyID0gU3RyaW5nKGIpO1xuXG4gICAgaWYgKGFTdHIgPT09IGJTdHIpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHJldHVybiBhU3RyIDwgYlN0ciA/IC0xIDogMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1pblJ1bkxlbmd0aChuKSB7XG4gICAgdmFyIHIgPSAwO1xuXG4gICAgd2hpbGUgKG4gPj0gREVGQVVMVF9NSU5fTUVSR0UpIHtcbiAgICAgIHIgfD0gbiAmIDE7XG4gICAgICBuID4+PSAxO1xuICAgIH1cblxuICAgIHJldHVybiBuICsgcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VBc2NlbmRpbmdSdW4oYXJyYXksIGxvLCBoaSwgY29tcGFyZSkge1xuICAgIHZhciBydW5IaSA9IGxvICsgMTtcblxuICAgIGlmIChydW5IaSA9PT0gaGkpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGlmIChjb21wYXJlKGFycmF5W3J1bkhpKytdLCBhcnJheVtsb10pIDwgMCkge1xuICAgICAgd2hpbGUgKHJ1bkhpIDwgaGkgJiYgY29tcGFyZShhcnJheVtydW5IaV0sIGFycmF5W3J1bkhpIC0gMV0pIDwgMCkge1xuICAgICAgICBydW5IaSsrO1xuICAgICAgfVxuXG4gICAgICByZXZlcnNlUnVuKGFycmF5LCBsbywgcnVuSGkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAocnVuSGkgPCBoaSAmJiBjb21wYXJlKGFycmF5W3J1bkhpXSwgYXJyYXlbcnVuSGkgLSAxXSkgPj0gMCkge1xuICAgICAgICBydW5IaSsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBydW5IaSAtIGxvO1xuICB9XG5cbiAgZnVuY3Rpb24gcmV2ZXJzZVJ1bihhcnJheSwgbG8sIGhpKSB7XG4gICAgaGktLTtcblxuICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICB2YXIgdCA9IGFycmF5W2xvXTtcbiAgICAgIGFycmF5W2xvKytdID0gYXJyYXlbaGldO1xuICAgICAgYXJyYXlbaGktLV0gPSB0O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGJpbmFyeUluc2VydGlvblNvcnQoYXJyYXksIGxvLCBoaSwgc3RhcnQsIGNvbXBhcmUpIHtcbiAgICBpZiAoc3RhcnQgPT09IGxvKSB7XG4gICAgICBzdGFydCsrO1xuICAgIH1cblxuICAgIGZvciAoOyBzdGFydCA8IGhpOyBzdGFydCsrKSB7XG4gICAgICB2YXIgcGl2b3QgPSBhcnJheVtzdGFydF07XG5cbiAgICAgIHZhciBsZWZ0ID0gbG87XG4gICAgICB2YXIgcmlnaHQgPSBzdGFydDtcblxuICAgICAgd2hpbGUgKGxlZnQgPCByaWdodCkge1xuICAgICAgICB2YXIgbWlkID0gbGVmdCArIHJpZ2h0ID4+PiAxO1xuXG4gICAgICAgIGlmIChjb21wYXJlKHBpdm90LCBhcnJheVttaWRdKSA8IDApIHtcbiAgICAgICAgICByaWdodCA9IG1pZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZWZ0ID0gbWlkICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbiA9IHN0YXJ0IC0gbGVmdDtcblxuICAgICAgc3dpdGNoIChuKSB7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBhcnJheVtsZWZ0ICsgM10gPSBhcnJheVtsZWZ0ICsgMl07XG5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGFycmF5W2xlZnQgKyAyXSA9IGFycmF5W2xlZnQgKyAxXTtcblxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgYXJyYXlbbGVmdCArIDFdID0gYXJyYXlbbGVmdF07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgd2hpbGUgKG4gPiAwKSB7XG4gICAgICAgICAgICBhcnJheVtsZWZ0ICsgbl0gPSBhcnJheVtsZWZ0ICsgbiAtIDFdO1xuICAgICAgICAgICAgbi0tO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYXJyYXlbbGVmdF0gPSBwaXZvdDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnYWxsb3BMZWZ0KHZhbHVlLCBhcnJheSwgc3RhcnQsIGxlbmd0aCwgaGludCwgY29tcGFyZSkge1xuICAgIHZhciBsYXN0T2Zmc2V0ID0gMDtcbiAgICB2YXIgbWF4T2Zmc2V0ID0gMDtcbiAgICB2YXIgb2Zmc2V0ID0gMTtcblxuICAgIGlmIChjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnRdKSA+IDApIHtcbiAgICAgIG1heE9mZnNldCA9IGxlbmd0aCAtIGhpbnQ7XG5cbiAgICAgIHdoaWxlIChvZmZzZXQgPCBtYXhPZmZzZXQgJiYgY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50ICsgb2Zmc2V0XSkgPiAwKSB7XG4gICAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIG9mZnNldCA9IChvZmZzZXQgPDwgMSkgKyAxO1xuXG4gICAgICAgIGlmIChvZmZzZXQgPD0gMCkge1xuICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgIH1cblxuICAgICAgbGFzdE9mZnNldCArPSBoaW50O1xuICAgICAgb2Zmc2V0ICs9IGhpbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1heE9mZnNldCA9IGhpbnQgKyAxO1xuICAgICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCAmJiBjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnQgLSBvZmZzZXRdKSA8PSAwKSB7XG4gICAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIG9mZnNldCA9IChvZmZzZXQgPDwgMSkgKyAxO1xuXG4gICAgICAgIGlmIChvZmZzZXQgPD0gMCkge1xuICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9mZnNldCA+IG1heE9mZnNldCkge1xuICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIHZhciB0bXAgPSBsYXN0T2Zmc2V0O1xuICAgICAgbGFzdE9mZnNldCA9IGhpbnQgLSBvZmZzZXQ7XG4gICAgICBvZmZzZXQgPSBoaW50IC0gdG1wO1xuICAgIH1cblxuICAgIGxhc3RPZmZzZXQrKztcbiAgICB3aGlsZSAobGFzdE9mZnNldCA8IG9mZnNldCkge1xuICAgICAgdmFyIG0gPSBsYXN0T2Zmc2V0ICsgKG9mZnNldCAtIGxhc3RPZmZzZXQgPj4+IDEpO1xuXG4gICAgICBpZiAoY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBtXSkgPiAwKSB7XG4gICAgICAgIGxhc3RPZmZzZXQgPSBtICsgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldCA9IG07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBnYWxsb3BSaWdodCh2YWx1ZSwgYXJyYXksIHN0YXJ0LCBsZW5ndGgsIGhpbnQsIGNvbXBhcmUpIHtcbiAgICB2YXIgbGFzdE9mZnNldCA9IDA7XG4gICAgdmFyIG1heE9mZnNldCA9IDA7XG4gICAgdmFyIG9mZnNldCA9IDE7XG5cbiAgICBpZiAoY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50XSkgPCAwKSB7XG4gICAgICBtYXhPZmZzZXQgPSBoaW50ICsgMTtcblxuICAgICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCAmJiBjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnQgLSBvZmZzZXRdKSA8IDApIHtcbiAgICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCA8PCAxKSArIDE7XG5cbiAgICAgICAgaWYgKG9mZnNldCA8PSAwKSB7XG4gICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvZmZzZXQgPiBtYXhPZmZzZXQpIHtcbiAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICB2YXIgdG1wID0gbGFzdE9mZnNldDtcbiAgICAgIGxhc3RPZmZzZXQgPSBoaW50IC0gb2Zmc2V0O1xuICAgICAgb2Zmc2V0ID0gaGludCAtIHRtcDtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF4T2Zmc2V0ID0gbGVuZ3RoIC0gaGludDtcblxuICAgICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCAmJiBjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnQgKyBvZmZzZXRdKSA+PSAwKSB7XG4gICAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIG9mZnNldCA9IChvZmZzZXQgPDwgMSkgKyAxO1xuXG4gICAgICAgIGlmIChvZmZzZXQgPD0gMCkge1xuICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgIH1cblxuICAgICAgbGFzdE9mZnNldCArPSBoaW50O1xuICAgICAgb2Zmc2V0ICs9IGhpbnQ7XG4gICAgfVxuXG4gICAgbGFzdE9mZnNldCsrO1xuXG4gICAgd2hpbGUgKGxhc3RPZmZzZXQgPCBvZmZzZXQpIHtcbiAgICAgIHZhciBtID0gbGFzdE9mZnNldCArIChvZmZzZXQgLSBsYXN0T2Zmc2V0ID4+PiAxKTtcblxuICAgICAgaWYgKGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgbV0pIDwgMCkge1xuICAgICAgICBvZmZzZXQgPSBtO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFzdE9mZnNldCA9IG0gKyAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvZmZzZXQ7XG4gIH1cblxuICB2YXIgVGltU29ydCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGltU29ydChhcnJheSwgY29tcGFyZSkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRpbVNvcnQpO1xuXG4gICAgICB0aGlzLmFycmF5ID0gbnVsbDtcbiAgICAgIHRoaXMuY29tcGFyZSA9IG51bGw7XG4gICAgICB0aGlzLm1pbkdhbGxvcCA9IERFRkFVTFRfTUlOX0dBTExPUElORztcbiAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgIHRoaXMudG1wU3RvcmFnZUxlbmd0aCA9IERFRkFVTFRfVE1QX1NUT1JBR0VfTEVOR1RIO1xuICAgICAgdGhpcy5zdGFja0xlbmd0aCA9IDA7XG4gICAgICB0aGlzLnJ1blN0YXJ0ID0gbnVsbDtcbiAgICAgIHRoaXMucnVuTGVuZ3RoID0gbnVsbDtcbiAgICAgIHRoaXMuc3RhY2tTaXplID0gMDtcblxuICAgICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICAgICAgdGhpcy5jb21wYXJlID0gY29tcGFyZTtcblxuICAgICAgdGhpcy5sZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIGlmICh0aGlzLmxlbmd0aCA8IDIgKiBERUZBVUxUX1RNUF9TVE9SQUdFX0xFTkdUSCkge1xuICAgICAgICB0aGlzLnRtcFN0b3JhZ2VMZW5ndGggPSB0aGlzLmxlbmd0aCA+Pj4gMTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50bXAgPSBuZXcgQXJyYXkodGhpcy50bXBTdG9yYWdlTGVuZ3RoKTtcblxuICAgICAgdGhpcy5zdGFja0xlbmd0aCA9IHRoaXMubGVuZ3RoIDwgMTIwID8gNSA6IHRoaXMubGVuZ3RoIDwgMTU0MiA/IDEwIDogdGhpcy5sZW5ndGggPCAxMTkxNTEgPyAxOSA6IDQwO1xuXG4gICAgICB0aGlzLnJ1blN0YXJ0ID0gbmV3IEFycmF5KHRoaXMuc3RhY2tMZW5ndGgpO1xuICAgICAgdGhpcy5ydW5MZW5ndGggPSBuZXcgQXJyYXkodGhpcy5zdGFja0xlbmd0aCk7XG4gICAgfVxuXG4gICAgVGltU29ydC5wcm90b3R5cGUucHVzaFJ1biA9IGZ1bmN0aW9uIHB1c2hSdW4ocnVuU3RhcnQsIHJ1bkxlbmd0aCkge1xuICAgICAgdGhpcy5ydW5TdGFydFt0aGlzLnN0YWNrU2l6ZV0gPSBydW5TdGFydDtcbiAgICAgIHRoaXMucnVuTGVuZ3RoW3RoaXMuc3RhY2tTaXplXSA9IHJ1bkxlbmd0aDtcbiAgICAgIHRoaXMuc3RhY2tTaXplICs9IDE7XG4gICAgfTtcblxuICAgIFRpbVNvcnQucHJvdG90eXBlLm1lcmdlUnVucyA9IGZ1bmN0aW9uIG1lcmdlUnVucygpIHtcbiAgICAgIHdoaWxlICh0aGlzLnN0YWNrU2l6ZSA+IDEpIHtcbiAgICAgICAgdmFyIG4gPSB0aGlzLnN0YWNrU2l6ZSAtIDI7XG5cbiAgICAgICAgaWYgKG4gPj0gMSAmJiB0aGlzLnJ1bkxlbmd0aFtuIC0gMV0gPD0gdGhpcy5ydW5MZW5ndGhbbl0gKyB0aGlzLnJ1bkxlbmd0aFtuICsgMV0gfHwgbiA+PSAyICYmIHRoaXMucnVuTGVuZ3RoW24gLSAyXSA8PSB0aGlzLnJ1bkxlbmd0aFtuXSArIHRoaXMucnVuTGVuZ3RoW24gLSAxXSkge1xuXG4gICAgICAgICAgaWYgKHRoaXMucnVuTGVuZ3RoW24gLSAxXSA8IHRoaXMucnVuTGVuZ3RoW24gKyAxXSkge1xuICAgICAgICAgICAgbi0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnJ1bkxlbmd0aFtuXSA+IHRoaXMucnVuTGVuZ3RoW24gKyAxXSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVyZ2VBdChuKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVGltU29ydC5wcm90b3R5cGUuZm9yY2VNZXJnZVJ1bnMgPSBmdW5jdGlvbiBmb3JjZU1lcmdlUnVucygpIHtcbiAgICAgIHdoaWxlICh0aGlzLnN0YWNrU2l6ZSA+IDEpIHtcbiAgICAgICAgdmFyIG4gPSB0aGlzLnN0YWNrU2l6ZSAtIDI7XG5cbiAgICAgICAgaWYgKG4gPiAwICYmIHRoaXMucnVuTGVuZ3RoW24gLSAxXSA8IHRoaXMucnVuTGVuZ3RoW24gKyAxXSkge1xuICAgICAgICAgIG4tLTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWVyZ2VBdChuKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVGltU29ydC5wcm90b3R5cGUubWVyZ2VBdCA9IGZ1bmN0aW9uIG1lcmdlQXQoaSkge1xuICAgICAgdmFyIGNvbXBhcmUgPSB0aGlzLmNvbXBhcmU7XG4gICAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5O1xuXG4gICAgICB2YXIgc3RhcnQxID0gdGhpcy5ydW5TdGFydFtpXTtcbiAgICAgIHZhciBsZW5ndGgxID0gdGhpcy5ydW5MZW5ndGhbaV07XG4gICAgICB2YXIgc3RhcnQyID0gdGhpcy5ydW5TdGFydFtpICsgMV07XG4gICAgICB2YXIgbGVuZ3RoMiA9IHRoaXMucnVuTGVuZ3RoW2kgKyAxXTtcblxuICAgICAgdGhpcy5ydW5MZW5ndGhbaV0gPSBsZW5ndGgxICsgbGVuZ3RoMjtcblxuICAgICAgaWYgKGkgPT09IHRoaXMuc3RhY2tTaXplIC0gMykge1xuICAgICAgICB0aGlzLnJ1blN0YXJ0W2kgKyAxXSA9IHRoaXMucnVuU3RhcnRbaSArIDJdO1xuICAgICAgICB0aGlzLnJ1bkxlbmd0aFtpICsgMV0gPSB0aGlzLnJ1bkxlbmd0aFtpICsgMl07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhY2tTaXplLS07XG5cbiAgICAgIHZhciBrID0gZ2FsbG9wUmlnaHQoYXJyYXlbc3RhcnQyXSwgYXJyYXksIHN0YXJ0MSwgbGVuZ3RoMSwgMCwgY29tcGFyZSk7XG4gICAgICBzdGFydDEgKz0gaztcbiAgICAgIGxlbmd0aDEgLT0gaztcblxuICAgICAgaWYgKGxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZW5ndGgyID0gZ2FsbG9wTGVmdChhcnJheVtzdGFydDEgKyBsZW5ndGgxIC0gMV0sIGFycmF5LCBzdGFydDIsIGxlbmd0aDIsIGxlbmd0aDIgLSAxLCBjb21wYXJlKTtcblxuICAgICAgaWYgKGxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobGVuZ3RoMSA8PSBsZW5ndGgyKSB7XG4gICAgICAgIHRoaXMubWVyZ2VMb3coc3RhcnQxLCBsZW5ndGgxLCBzdGFydDIsIGxlbmd0aDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tZXJnZUhpZ2goc3RhcnQxLCBsZW5ndGgxLCBzdGFydDIsIGxlbmd0aDIpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBUaW1Tb3J0LnByb3RvdHlwZS5tZXJnZUxvdyA9IGZ1bmN0aW9uIG1lcmdlTG93KHN0YXJ0MSwgbGVuZ3RoMSwgc3RhcnQyLCBsZW5ndGgyKSB7XG5cbiAgICAgIHZhciBjb21wYXJlID0gdGhpcy5jb21wYXJlO1xuICAgICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheTtcbiAgICAgIHZhciB0bXAgPSB0aGlzLnRtcDtcbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDE7IGkrKykge1xuICAgICAgICB0bXBbaV0gPSBhcnJheVtzdGFydDEgKyBpXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGN1cnNvcjEgPSAwO1xuICAgICAgdmFyIGN1cnNvcjIgPSBzdGFydDI7XG4gICAgICB2YXIgZGVzdCA9IHN0YXJ0MTtcblxuICAgICAgYXJyYXlbZGVzdCsrXSA9IGFycmF5W2N1cnNvcjIrK107XG5cbiAgICAgIGlmICgtLWxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDE7IGkrKykge1xuICAgICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IHRtcFtjdXJzb3IxICsgaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobGVuZ3RoMSA9PT0gMSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgICAgYXJyYXlbZGVzdCArIGldID0gYXJyYXlbY3Vyc29yMiArIGldO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5W2Rlc3QgKyBsZW5ndGgyXSA9IHRtcFtjdXJzb3IxXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWluR2FsbG9wID0gdGhpcy5taW5HYWxsb3A7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBjb3VudDEgPSAwO1xuICAgICAgICB2YXIgY291bnQyID0gMDtcbiAgICAgICAgdmFyIGV4aXQgPSBmYWxzZTtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgaWYgKGNvbXBhcmUoYXJyYXlbY3Vyc29yMl0sIHRtcFtjdXJzb3IxXSkgPCAwKSB7XG4gICAgICAgICAgICBhcnJheVtkZXN0KytdID0gYXJyYXlbY3Vyc29yMisrXTtcbiAgICAgICAgICAgIGNvdW50MisrO1xuICAgICAgICAgICAgY291bnQxID0gMDtcblxuICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMiA9PT0gMCkge1xuICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycmF5W2Rlc3QrK10gPSB0bXBbY3Vyc29yMSsrXTtcbiAgICAgICAgICAgIGNvdW50MSsrO1xuICAgICAgICAgICAgY291bnQyID0gMDtcbiAgICAgICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDEpIHtcbiAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoKGNvdW50MSB8IGNvdW50MikgPCBtaW5HYWxsb3ApO1xuXG4gICAgICAgIGlmIChleGl0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBkbyB7XG4gICAgICAgICAgY291bnQxID0gZ2FsbG9wUmlnaHQoYXJyYXlbY3Vyc29yMl0sIHRtcCwgY3Vyc29yMSwgbGVuZ3RoMSwgMCwgY29tcGFyZSk7XG5cbiAgICAgICAgICBpZiAoY291bnQxICE9PSAwKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQxOyBpKyspIHtcbiAgICAgICAgICAgICAgYXJyYXlbZGVzdCArIGldID0gdG1wW2N1cnNvcjEgKyBpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVzdCArPSBjb3VudDE7XG4gICAgICAgICAgICBjdXJzb3IxICs9IGNvdW50MTtcbiAgICAgICAgICAgIGxlbmd0aDEgLT0gY291bnQxO1xuICAgICAgICAgICAgaWYgKGxlbmd0aDEgPD0gMSkge1xuICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXJyYXlbZGVzdCsrXSA9IGFycmF5W2N1cnNvcjIrK107XG5cbiAgICAgICAgICBpZiAoLS1sZW5ndGgyID09PSAwKSB7XG4gICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvdW50MiA9IGdhbGxvcExlZnQodG1wW2N1cnNvcjFdLCBhcnJheSwgY3Vyc29yMiwgbGVuZ3RoMiwgMCwgY29tcGFyZSk7XG5cbiAgICAgICAgICBpZiAoY291bnQyICE9PSAwKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQyOyBpKyspIHtcbiAgICAgICAgICAgICAgYXJyYXlbZGVzdCArIGldID0gYXJyYXlbY3Vyc29yMiArIGldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZXN0ICs9IGNvdW50MjtcbiAgICAgICAgICAgIGN1cnNvcjIgKz0gY291bnQyO1xuICAgICAgICAgICAgbGVuZ3RoMiAtPSBjb3VudDI7XG5cbiAgICAgICAgICAgIGlmIChsZW5ndGgyID09PSAwKSB7XG4gICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYXJyYXlbZGVzdCsrXSA9IHRtcFtjdXJzb3IxKytdO1xuXG4gICAgICAgICAgaWYgKC0tbGVuZ3RoMSA9PT0gMSkge1xuICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtaW5HYWxsb3AtLTtcbiAgICAgICAgfSB3aGlsZSAoY291bnQxID49IERFRkFVTFRfTUlOX0dBTExPUElORyB8fCBjb3VudDIgPj0gREVGQVVMVF9NSU5fR0FMTE9QSU5HKTtcblxuICAgICAgICBpZiAoZXhpdCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1pbkdhbGxvcCA8IDApIHtcbiAgICAgICAgICBtaW5HYWxsb3AgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgbWluR2FsbG9wICs9IDI7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWluR2FsbG9wID0gbWluR2FsbG9wO1xuXG4gICAgICBpZiAobWluR2FsbG9wIDwgMSkge1xuICAgICAgICB0aGlzLm1pbkdhbGxvcCA9IDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChsZW5ndGgxID09PSAxKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSBhcnJheVtjdXJzb3IyICsgaV07XG4gICAgICAgIH1cbiAgICAgICAgYXJyYXlbZGVzdCArIGxlbmd0aDJdID0gdG1wW2N1cnNvcjFdO1xuICAgICAgfSBlbHNlIGlmIChsZW5ndGgxID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWVyZ2VMb3cgcHJlY29uZGl0aW9ucyB3ZXJlIG5vdCByZXNwZWN0ZWQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgxOyBpKyspIHtcbiAgICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSB0bXBbY3Vyc29yMSArIGldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIFRpbVNvcnQucHJvdG90eXBlLm1lcmdlSGlnaCA9IGZ1bmN0aW9uIG1lcmdlSGlnaChzdGFydDEsIGxlbmd0aDEsIHN0YXJ0MiwgbGVuZ3RoMikge1xuICAgICAgdmFyIGNvbXBhcmUgPSB0aGlzLmNvbXBhcmU7XG4gICAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5O1xuICAgICAgdmFyIHRtcCA9IHRoaXMudG1wO1xuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgIHRtcFtpXSA9IGFycmF5W3N0YXJ0MiArIGldO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3Vyc29yMSA9IHN0YXJ0MSArIGxlbmd0aDEgLSAxO1xuICAgICAgdmFyIGN1cnNvcjIgPSBsZW5ndGgyIC0gMTtcbiAgICAgIHZhciBkZXN0ID0gc3RhcnQyICsgbGVuZ3RoMiAtIDE7XG4gICAgICB2YXIgY3VzdG9tQ3Vyc29yID0gMDtcbiAgICAgIHZhciBjdXN0b21EZXN0ID0gMDtcblxuICAgICAgYXJyYXlbZGVzdC0tXSA9IGFycmF5W2N1cnNvcjEtLV07XG5cbiAgICAgIGlmICgtLWxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgY3VzdG9tQ3Vyc29yID0gZGVzdCAtIChsZW5ndGgyIC0gMSk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICAgIGFycmF5W2N1c3RvbUN1cnNvciArIGldID0gdG1wW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobGVuZ3RoMiA9PT0gMSkge1xuICAgICAgICBkZXN0IC09IGxlbmd0aDE7XG4gICAgICAgIGN1cnNvcjEgLT0gbGVuZ3RoMTtcbiAgICAgICAgY3VzdG9tRGVzdCA9IGRlc3QgKyAxO1xuICAgICAgICBjdXN0b21DdXJzb3IgPSBjdXJzb3IxICsgMTtcblxuICAgICAgICBmb3IgKGkgPSBsZW5ndGgxIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBhcnJheVtjdXN0b21EZXN0ICsgaV0gPSBhcnJheVtjdXN0b21DdXJzb3IgKyBpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFycmF5W2Rlc3RdID0gdG1wW2N1cnNvcjJdO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBtaW5HYWxsb3AgPSB0aGlzLm1pbkdhbGxvcDtcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGNvdW50MSA9IDA7XG4gICAgICAgIHZhciBjb3VudDIgPSAwO1xuICAgICAgICB2YXIgZXhpdCA9IGZhbHNlO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBpZiAoY29tcGFyZSh0bXBbY3Vyc29yMl0sIGFycmF5W2N1cnNvcjFdKSA8IDApIHtcbiAgICAgICAgICAgIGFycmF5W2Rlc3QtLV0gPSBhcnJheVtjdXJzb3IxLS1dO1xuICAgICAgICAgICAgY291bnQxKys7XG4gICAgICAgICAgICBjb3VudDIgPSAwO1xuICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMSA9PT0gMCkge1xuICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycmF5W2Rlc3QtLV0gPSB0bXBbY3Vyc29yMi0tXTtcbiAgICAgICAgICAgIGNvdW50MisrO1xuICAgICAgICAgICAgY291bnQxID0gMDtcbiAgICAgICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDEpIHtcbiAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoKGNvdW50MSB8IGNvdW50MikgPCBtaW5HYWxsb3ApO1xuXG4gICAgICAgIGlmIChleGl0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBkbyB7XG4gICAgICAgICAgY291bnQxID0gbGVuZ3RoMSAtIGdhbGxvcFJpZ2h0KHRtcFtjdXJzb3IyXSwgYXJyYXksIHN0YXJ0MSwgbGVuZ3RoMSwgbGVuZ3RoMSAtIDEsIGNvbXBhcmUpO1xuXG4gICAgICAgICAgaWYgKGNvdW50MSAhPT0gMCkge1xuICAgICAgICAgICAgZGVzdCAtPSBjb3VudDE7XG4gICAgICAgICAgICBjdXJzb3IxIC09IGNvdW50MTtcbiAgICAgICAgICAgIGxlbmd0aDEgLT0gY291bnQxO1xuICAgICAgICAgICAgY3VzdG9tRGVzdCA9IGRlc3QgKyAxO1xuICAgICAgICAgICAgY3VzdG9tQ3Vyc29yID0gY3Vyc29yMSArIDE7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IGNvdW50MSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgIGFycmF5W2N1c3RvbURlc3QgKyBpXSA9IGFycmF5W2N1c3RvbUN1cnNvciArIGldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGVuZ3RoMSA9PT0gMCkge1xuICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXJyYXlbZGVzdC0tXSA9IHRtcFtjdXJzb3IyLS1dO1xuXG4gICAgICAgICAgaWYgKC0tbGVuZ3RoMiA9PT0gMSkge1xuICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb3VudDIgPSBsZW5ndGgyIC0gZ2FsbG9wTGVmdChhcnJheVtjdXJzb3IxXSwgdG1wLCAwLCBsZW5ndGgyLCBsZW5ndGgyIC0gMSwgY29tcGFyZSk7XG5cbiAgICAgICAgICBpZiAoY291bnQyICE9PSAwKSB7XG4gICAgICAgICAgICBkZXN0IC09IGNvdW50MjtcbiAgICAgICAgICAgIGN1cnNvcjIgLT0gY291bnQyO1xuICAgICAgICAgICAgbGVuZ3RoMiAtPSBjb3VudDI7XG4gICAgICAgICAgICBjdXN0b21EZXN0ID0gZGVzdCArIDE7XG4gICAgICAgICAgICBjdXN0b21DdXJzb3IgPSBjdXJzb3IyICsgMTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50MjsgaSsrKSB7XG4gICAgICAgICAgICAgIGFycmF5W2N1c3RvbURlc3QgKyBpXSA9IHRtcFtjdXN0b21DdXJzb3IgKyBpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxlbmd0aDIgPD0gMSkge1xuICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXJyYXlbZGVzdC0tXSA9IGFycmF5W2N1cnNvcjEtLV07XG5cbiAgICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG1pbkdhbGxvcC0tO1xuICAgICAgICB9IHdoaWxlIChjb3VudDEgPj0gREVGQVVMVF9NSU5fR0FMTE9QSU5HIHx8IGNvdW50MiA+PSBERUZBVUxUX01JTl9HQUxMT1BJTkcpO1xuXG4gICAgICAgIGlmIChleGl0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWluR2FsbG9wIDwgMCkge1xuICAgICAgICAgIG1pbkdhbGxvcCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBtaW5HYWxsb3AgKz0gMjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5taW5HYWxsb3AgPSBtaW5HYWxsb3A7XG5cbiAgICAgIGlmIChtaW5HYWxsb3AgPCAxKSB7XG4gICAgICAgIHRoaXMubWluR2FsbG9wID0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxlbmd0aDIgPT09IDEpIHtcbiAgICAgICAgZGVzdCAtPSBsZW5ndGgxO1xuICAgICAgICBjdXJzb3IxIC09IGxlbmd0aDE7XG4gICAgICAgIGN1c3RvbURlc3QgPSBkZXN0ICsgMTtcbiAgICAgICAgY3VzdG9tQ3Vyc29yID0gY3Vyc29yMSArIDE7XG5cbiAgICAgICAgZm9yIChpID0gbGVuZ3RoMSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgYXJyYXlbY3VzdG9tRGVzdCArIGldID0gYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV07XG4gICAgICAgIH1cblxuICAgICAgICBhcnJheVtkZXN0XSA9IHRtcFtjdXJzb3IyXTtcbiAgICAgIH0gZWxzZSBpZiAobGVuZ3RoMiA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21lcmdlSGlnaCBwcmVjb25kaXRpb25zIHdlcmUgbm90IHJlc3BlY3RlZCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VzdG9tQ3Vyc29yID0gZGVzdCAtIChsZW5ndGgyIC0gMSk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgICBhcnJheVtjdXN0b21DdXJzb3IgKyBpXSA9IHRtcFtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gVGltU29ydDtcbiAgfSkoKTtcblxuICBmdW5jdGlvbiBzb3J0KGFycmF5LCBjb21wYXJlLCBsbywgaGkpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW4gb25seSBzb3J0IGFycmF5cycpO1xuICAgIH1cblxuICAgIGlmICghY29tcGFyZSkge1xuICAgICAgY29tcGFyZSA9IGFscGhhYmV0aWNhbENvbXBhcmU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY29tcGFyZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaGkgPSBsbztcbiAgICAgIGxvID0gY29tcGFyZTtcbiAgICAgIGNvbXBhcmUgPSBhbHBoYWJldGljYWxDb21wYXJlO1xuICAgIH1cblxuICAgIGlmICghbG8pIHtcbiAgICAgIGxvID0gMDtcbiAgICB9XG4gICAgaWYgKCFoaSkge1xuICAgICAgaGkgPSBhcnJheS5sZW5ndGg7XG4gICAgfVxuXG4gICAgdmFyIHJlbWFpbmluZyA9IGhpIC0gbG87XG5cbiAgICBpZiAocmVtYWluaW5nIDwgMikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBydW5MZW5ndGggPSAwO1xuXG4gICAgaWYgKHJlbWFpbmluZyA8IERFRkFVTFRfTUlOX01FUkdFKSB7XG4gICAgICBydW5MZW5ndGggPSBtYWtlQXNjZW5kaW5nUnVuKGFycmF5LCBsbywgaGksIGNvbXBhcmUpO1xuICAgICAgYmluYXJ5SW5zZXJ0aW9uU29ydChhcnJheSwgbG8sIGhpLCBsbyArIHJ1bkxlbmd0aCwgY29tcGFyZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRzID0gbmV3IFRpbVNvcnQoYXJyYXksIGNvbXBhcmUpO1xuXG4gICAgdmFyIG1pblJ1biA9IG1pblJ1bkxlbmd0aChyZW1haW5pbmcpO1xuXG4gICAgZG8ge1xuICAgICAgcnVuTGVuZ3RoID0gbWFrZUFzY2VuZGluZ1J1bihhcnJheSwgbG8sIGhpLCBjb21wYXJlKTtcbiAgICAgIGlmIChydW5MZW5ndGggPCBtaW5SdW4pIHtcbiAgICAgICAgdmFyIGZvcmNlID0gcmVtYWluaW5nO1xuICAgICAgICBpZiAoZm9yY2UgPiBtaW5SdW4pIHtcbiAgICAgICAgICBmb3JjZSA9IG1pblJ1bjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJpbmFyeUluc2VydGlvblNvcnQoYXJyYXksIGxvLCBsbyArIGZvcmNlLCBsbyArIHJ1bkxlbmd0aCwgY29tcGFyZSk7XG4gICAgICAgIHJ1bkxlbmd0aCA9IGZvcmNlO1xuICAgICAgfVxuXG4gICAgICB0cy5wdXNoUnVuKGxvLCBydW5MZW5ndGgpO1xuICAgICAgdHMubWVyZ2VSdW5zKCk7XG5cbiAgICAgIHJlbWFpbmluZyAtPSBydW5MZW5ndGg7XG4gICAgICBsbyArPSBydW5MZW5ndGg7XG4gICAgfSB3aGlsZSAocmVtYWluaW5nICE9PSAwKTtcblxuICAgIHRzLmZvcmNlTWVyZ2VSdW5zKCk7XG4gIH1cbn0pO1xuXG5cbi8qKiovIH0pLFxuLyogMTg5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlZlcnRpY2FsU3RyYXRlZ3kgPSBleHBvcnRzLkhvcml6b250YWxTdHJhdGVneSA9IHVuZGVmaW5lZDtcblxudmFyIF9nZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxudmFyIF9pbmhlcml0czIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vKipcbiAqIEhlbHBlciBjbGFzc2VzIGZvciBMYXlvdXRFbmdpbmUuXG4gKlxuICogU3RyYXRlZ3kgcGF0dGVybiBmb3IgdXNhZ2Ugb2YgZGlyZWN0aW9uIG1ldGhvZHMgZm9yIGhpZXJhcmNoaWNhbCBsYXlvdXRzLlxuICovXG52YXIgVGltU29ydCA9IF9fd2VicGFja19yZXF1aXJlX18oODMpO1xuXG4vKipcbiAqIEludGVyZmFjZSBkZWZpbml0aW9uIGZvciBkaXJlY3Rpb24gc3RyYXRlZ3kgY2xhc3Nlcy5cbiAqXG4gKiBUaGlzIGNsYXNzIGRlc2NyaWJlcyB0aGUgaW50ZXJmYWNlIGZvciB0aGUgU3RyYXRlZ3lcbiAqIHBhdHRlcm4gY2xhc3NlcyB1c2VkIHRvIGRpZmZlcmVudGlhdGUgaG9yaXpvbnRhbCBhbmQgdmVydGljYWxcbiAqIGRpcmVjdGlvbiBvZiBoaWVyYXJjaGljYWwgcmVzdWx0cy5cbiAqXG4gKiBGb3IgYSBnaXZlbiBkaXJlY3Rpb24sIG9uZSBjb29yZGluYXRlIHdpbGwgYmUgJ2ZpeGVkJywgbWVhbmluZyB0aGF0IGl0IGlzXG4gKiBkZXRlcm1pbmVkIGJ5IGxldmVsLlxuICogVGhlIG90aGVyIGNvb3JkaW5hdGUgaXMgJ3VuZml4ZWQnLCBtZWFuaW5nIHRoYXQgdGhlIG5vZGVzIG9uIGEgZ2l2ZW4gbGV2ZWxcbiAqIGNhbiBzdGlsbCBtb3ZlIGFsb25nIHRoYXQgY29vcmRpbmF0ZS4gU286XG4gKlxuICogLSBgdmVydGljYWxgIGxheW91dDogYHhgIHVuZml4ZWQsIGB5YCBmaXhlZCBwZXIgbGV2ZWxcbiAqIC0gYGhvcml6b250YWxgIGxheW91dDogYHhgIGZpeGVkIHBlciBsZXZlbCwgYHlgIHVuZml4ZWRcbiAqXG4gKiBUaGUgbG9jYWwgbWV0aG9kcyBhcmUgc3R1YnMgYW5kIHNob3VsZCBiZSByZWdhcmRlZCBhcyBhYnN0cmFjdC5cbiAqIERlcml2ZWQgY2xhc3NlcyAqKm11c3QqKiBpbXBsZW1lbnQgYWxsIHRoZSBtZXRob2RzIHRoZW1zZWx2ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgRGlyZWN0aW9uSW50ZXJmYWNlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEaXJlY3Rpb25JbnRlcmZhY2UoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgRGlyZWN0aW9uSW50ZXJmYWNlKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKERpcmVjdGlvbkludGVyZmFjZSwgW3tcbiAgICBrZXk6ICdhYnN0cmFjdCcsXG5cbiAgICAvKiogQGlnbm9yZSAqKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gYWJzdHJhY3QoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBpbnN0YW50aWF0ZSBhYnN0cmFjdCBjbGFzcyFcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBhIGR1bW15IGNhbGwgd2hpY2ggaXMgdXNlZCB0byBzdXBwcmVzcyB0aGUganNkb2MgZXJyb3JzIG9mIHR5cGU6XG4gICAgICpcbiAgICAgKiAgIFwiJ3BhcmFtJyBpcyBhc3NpZ25lZCBhIHZhbHVlIGJ1dCBuZXZlciB1c2VkXCJcbiAgICAgKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKiovXG5cbiAgfSwge1xuICAgIGtleTogJ2Zha2VfdXNlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmFrZV91c2UoKSB7fVxuICAgIC8vIERvIG5vdGhpbmcgc3BlY2lhbFxuXG5cbiAgICAvKipcbiAgICAgKiBUeXBlIHRvIHVzZSB0byB0cmFuc2xhdGUgZHluYW1pYyBjdXJ2ZXMgdG8sIGluIHRoZSBjYXNlIG9mIGhpZXJhcmNoaWNhbCBsYXlvdXQuXG4gICAgICogRHluYW1pYyBjdXJ2ZXMgZG8gbm90IHdvcmsgZm9yIHRoZXNlLlxuICAgICAqXG4gICAgICogVGhlIHZhbHVlIHNob3VsZCBiZSBwZXJwZW5kaWN1bGFyIHRvIHRoZSBhY3R1YWwgZGlyZWN0aW9uIG9mIHRoZSBsYXlvdXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IERpcmVjdGlvbiwgZWl0aGVyICd2ZXJ0aWNhbCcgb3IgJ2hvcml6b250YWwnXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2N1cnZlVHlwZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGN1cnZlVHlwZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmFic3RyYWN0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgY29vcmRpbmF0ZSB0aGF0IGlzIG5vdCBmaXhlZCBmb3IgdGhpcyBkaXJlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIG5vZGUgdG8gcmVhZFxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVmFsdWUgb2YgdGhlIHVuZml4ZWQgY29vcmRpbmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRQb3NpdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvc2l0aW9uKG5vZGUpIHtcbiAgICAgIHRoaXMuZmFrZV91c2Uobm9kZSk7XG4gICAgICByZXR1cm4gdGhpcy5hYnN0cmFjdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdmFsdWUgb2YgdGhlIGNvb3JkaW5hdGUgdGhhdCBpcyBub3QgZml4ZWQgZm9yIHRoaXMgZGlyZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBub2RlIHRvIGFkanVzdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGV2ZWxdIGlmIHNwZWNpZmllZCwgdGhlIGhpZXJhcmNoeSBsZXZlbCB0aGF0IHRoaXMgbm9kZSBzaG91bGQgYmUgZml4ZWQgdG9cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0UG9zaXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQb3NpdGlvbihub2RlLCBwb3NpdGlvbikge1xuICAgICAgdmFyIGxldmVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMuZmFrZV91c2Uobm9kZSwgcG9zaXRpb24sIGxldmVsKTtcbiAgICAgIHRoaXMuYWJzdHJhY3QoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHdpZHRoIG9mIGEgdHJlZS5cbiAgICAgKlxuICAgICAqIEEgYHRyZWVgIGhlcmUgaXMgYSBzdWJzZXQgb2Ygbm9kZXMgd2l0aGluIHRoZSBuZXR3b3JrIHdoaWNoIGFyZSBub3QgY29ubmVjdGVkIHRvIG90aGVyIG5vZGVzLFxuICAgICAqIG9ubHkgYW1vbmcgdGhlbXNlbHZlcy4gSW4gZXNzZW5jZSwgaXQgaXMgYSBzdWItbmV0d29yay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggbnVtYmVyIG9mIGEgdHJlZVxuICAgICAqIEByZXR1cm4ge251bWJlcn0gdGhlIHdpZHRoIG9mIGEgdHJlZSBpbiB0aGUgdmlldyBjb29yZGluYXRlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRUcmVlU2l6ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRyZWVTaXplKGluZGV4KSB7XG4gICAgICB0aGlzLmZha2VfdXNlKGluZGV4KTtcbiAgICAgIHJldHVybiB0aGlzLmFic3RyYWN0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU29ydCBhcnJheSBvZiBub2RlcyBvbiB0aGUgdW5maXhlZCBjb29yZGluYXRlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBjaHJvbWUgaGFzIG5vbi1zdGFibGUgc29ydGluZyBpbXBsZW1lbnRhdGlvbiwgd2hpY2hcbiAgICAgKiBoYXMgYSB0ZW5kZW5jeSB0byBjaGFuZ2UgdGhlIG9yZGVyIG9mIHRoZSBhcnJheSBpdGVtcyxcbiAgICAgKiBldmVuIGlmIHRoZSBjdXN0b20gc29ydCBmdW5jdGlvbiByZXR1cm5zIDAuXG4gICAgICpcbiAgICAgKiBGb3IgdGhpcyByZWFzb24sIGFuIGV4dGVybmFsIHNvcnQgaW1wbGVtZW50YXRpb24gaXMgdXNlZCxcbiAgICAgKiB3aGljaCBoYXMgdGhlIGFkZGVkIGJlbmVmaXQgb2YgYmVpbmcgZmFzdGVyIHRoYW4gdGhlIHN0YW5kYXJkXG4gICAgICogcGxhdGZvcm1zIGltcGxlbWVudGF0aW9uLiBUaGlzIGhhcyBiZWVuIHZlcmlmaWVkIG9uIGBub2RlLmpzYCxcbiAgICAgKiBgZmlyZWZveGAgYW5kIGBjaHJvbWVgIChhbGwgbGludXgpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48Tm9kZT59IG5vZGVBcnJheSBhcnJheSBvZiBub2RlcyB0byBzb3J0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NvcnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzb3J0KG5vZGVBcnJheSkge1xuICAgICAgdGhpcy5mYWtlX3VzZShub2RlQXJyYXkpO1xuICAgICAgdGhpcy5hYnN0cmFjdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbiB0aGUgZml4ZWQgY29vcmRpbmF0ZSBvZiB0aGUgbm9kZSB0byB0aGUgZ2l2ZW4gbGV2ZWxcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUaGUgbm9kZSB0byBhZGp1c3RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGV2ZWwgVGhlIGxldmVsIHRvIGZpeCB0b1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdmaXgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaXgobm9kZSwgbGV2ZWwpIHtcbiAgICAgIHRoaXMuZmFrZV91c2Uobm9kZSwgbGV2ZWwpO1xuICAgICAgdGhpcy5hYnN0cmFjdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhbiBvZmZzZXQgdG8gdGhlIHVuZml4ZWQgY29vcmRpbmF0ZSBvZiB0aGUgZ2l2ZW4gbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZUlkfSBub2RlSWQgSWQgb2YgdGhlIG5vZGUgdG8gYWRqdXN0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpZmYgT2Zmc2V0IHRvIGFkZCB0byB0aGUgdW5maXhlZCBjb29yZGluYXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NoaWZ0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hpZnQobm9kZUlkLCBkaWZmKSB7XG4gICAgICB0aGlzLmZha2VfdXNlKG5vZGVJZCwgZGlmZik7XG4gICAgICB0aGlzLmFic3RyYWN0KCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBEaXJlY3Rpb25JbnRlcmZhY2U7XG59KCk7XG5cbi8qKlxuICogVmVydGljYWwgU3RyYXRlZ3lcbiAqXG4gKiBDb29yZGluYXRlIGB5YCBpcyBmaXhlZCBvbiBsZXZlbHMsIGNvb3JkaW5hdGUgYHhgIGlzIHVuZml4ZWQuXG4gKlxuICogQGV4dGVuZHMgRGlyZWN0aW9uSW50ZXJmYWNlXG4gKiBAcHJpdmF0ZVxuICovXG5cblxudmFyIFZlcnRpY2FsU3RyYXRlZ3kgPSBmdW5jdGlvbiAoX0RpcmVjdGlvbkludGVyZmFjZSkge1xuICAoMCwgX2luaGVyaXRzM1snZGVmYXVsdCddKShWZXJ0aWNhbFN0cmF0ZWd5LCBfRGlyZWN0aW9uSW50ZXJmYWNlKTtcblxuICAvKipcbiAgICogQ29uc3RydWN0b3JcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGxheW91dCByZWZlcmVuY2UgdG8gdGhlIHBhcmVudCBMYXlvdXRFbmdpbmUgaW5zdGFuY2UuXG4gICAqL1xuICBmdW5jdGlvbiBWZXJ0aWNhbFN0cmF0ZWd5KGxheW91dCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIFZlcnRpY2FsU3RyYXRlZ3kpO1xuXG4gICAgdmFyIF90aGlzID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuM1snZGVmYXVsdCddKSh0aGlzLCAoVmVydGljYWxTdHJhdGVneS5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjJbJ2RlZmF1bHQnXSkoVmVydGljYWxTdHJhdGVneSkpLmNhbGwodGhpcykpO1xuXG4gICAgX3RoaXMubGF5b3V0ID0gbGF5b3V0O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoVmVydGljYWxTdHJhdGVneSwgW3tcbiAgICBrZXk6ICdjdXJ2ZVR5cGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjdXJ2ZVR5cGUoKSB7XG4gICAgICByZXR1cm4gJ2hvcml6b250YWwnO1xuICAgIH1cblxuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRQb3NpdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvc2l0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLng7XG4gICAgfVxuXG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldFBvc2l0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UG9zaXRpb24obm9kZSwgcG9zaXRpb24pIHtcbiAgICAgIHZhciBsZXZlbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAobGV2ZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmxheW91dC5oaWVyYXJjaGljYWwuYWRkVG9PcmRlcmluZyhub2RlLCBsZXZlbCk7XG4gICAgICB9XG4gICAgICBub2RlLnggPSBwb3NpdGlvbjtcbiAgICB9XG5cbiAgICAvKiogQGluaGVyaXRkb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0VHJlZVNpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUcmVlU2l6ZShpbmRleCkge1xuICAgICAgdmFyIHJlcyA9IHRoaXMubGF5b3V0LmhpZXJhcmNoaWNhbC5nZXRUcmVlU2l6ZSh0aGlzLmxheW91dC5ib2R5Lm5vZGVzLCBpbmRleCk7XG4gICAgICByZXR1cm4geyBtaW46IHJlcy5taW5feCwgbWF4OiByZXMubWF4X3ggfTtcbiAgICB9XG5cbiAgICAvKiogQGluaGVyaXRkb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc29ydCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvcnQobm9kZUFycmF5KSB7XG4gICAgICBUaW1Tb3J0LnNvcnQobm9kZUFycmF5LCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYS54IC0gYi54O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG5cbiAgfSwge1xuICAgIGtleTogJ2ZpeCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpeChub2RlLCBsZXZlbCkge1xuICAgICAgbm9kZS55ID0gdGhpcy5sYXlvdXQub3B0aW9ucy5oaWVyYXJjaGljYWwubGV2ZWxTZXBhcmF0aW9uICogbGV2ZWw7XG4gICAgICBub2RlLm9wdGlvbnMuZml4ZWQueSA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NoaWZ0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hpZnQobm9kZUlkLCBkaWZmKSB7XG4gICAgICB0aGlzLmxheW91dC5ib2R5Lm5vZGVzW25vZGVJZF0ueCArPSBkaWZmO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVmVydGljYWxTdHJhdGVneTtcbn0oRGlyZWN0aW9uSW50ZXJmYWNlKTtcblxuLyoqXG4gKiBIb3Jpem9udGFsIFN0cmF0ZWd5XG4gKlxuICogQ29vcmRpbmF0ZSBgeGAgaXMgZml4ZWQgb24gbGV2ZWxzLCBjb29yZGluYXRlIGB5YCBpcyB1bmZpeGVkLlxuICpcbiAqIEBleHRlbmRzIERpcmVjdGlvbkludGVyZmFjZVxuICogQHByaXZhdGVcbiAqL1xuXG5cbnZhciBIb3Jpem9udGFsU3RyYXRlZ3kgPSBmdW5jdGlvbiAoX0RpcmVjdGlvbkludGVyZmFjZTIpIHtcbiAgKDAsIF9pbmhlcml0czNbJ2RlZmF1bHQnXSkoSG9yaXpvbnRhbFN0cmF0ZWd5LCBfRGlyZWN0aW9uSW50ZXJmYWNlMik7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsYXlvdXQgcmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgTGF5b3V0RW5naW5lIGluc3RhbmNlLlxuICAgKi9cbiAgZnVuY3Rpb24gSG9yaXpvbnRhbFN0cmF0ZWd5KGxheW91dCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIEhvcml6b250YWxTdHJhdGVneSk7XG5cbiAgICB2YXIgX3RoaXMyID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuM1snZGVmYXVsdCddKSh0aGlzLCAoSG9yaXpvbnRhbFN0cmF0ZWd5Ll9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMlsnZGVmYXVsdCddKShIb3Jpem9udGFsU3RyYXRlZ3kpKS5jYWxsKHRoaXMpKTtcblxuICAgIF90aGlzMi5sYXlvdXQgPSBsYXlvdXQ7XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoSG9yaXpvbnRhbFN0cmF0ZWd5LCBbe1xuICAgIGtleTogJ2N1cnZlVHlwZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGN1cnZlVHlwZSgpIHtcbiAgICAgIHJldHVybiAndmVydGljYWwnO1xuICAgIH1cblxuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRQb3NpdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvc2l0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLnk7XG4gICAgfVxuXG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldFBvc2l0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UG9zaXRpb24obm9kZSwgcG9zaXRpb24pIHtcbiAgICAgIHZhciBsZXZlbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAobGV2ZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmxheW91dC5oaWVyYXJjaGljYWwuYWRkVG9PcmRlcmluZyhub2RlLCBsZXZlbCk7XG4gICAgICB9XG4gICAgICBub2RlLnkgPSBwb3NpdGlvbjtcbiAgICB9XG5cbiAgICAvKiogQGluaGVyaXRkb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0VHJlZVNpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUcmVlU2l6ZShpbmRleCkge1xuICAgICAgdmFyIHJlcyA9IHRoaXMubGF5b3V0LmhpZXJhcmNoaWNhbC5nZXRUcmVlU2l6ZSh0aGlzLmxheW91dC5ib2R5Lm5vZGVzLCBpbmRleCk7XG4gICAgICByZXR1cm4geyBtaW46IHJlcy5taW5feSwgbWF4OiByZXMubWF4X3kgfTtcbiAgICB9XG5cbiAgICAvKiogQGluaGVyaXRkb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc29ydCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvcnQobm9kZUFycmF5KSB7XG4gICAgICBUaW1Tb3J0LnNvcnQobm9kZUFycmF5LCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYS55IC0gYi55O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG5cbiAgfSwge1xuICAgIGtleTogJ2ZpeCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpeChub2RlLCBsZXZlbCkge1xuICAgICAgbm9kZS54ID0gdGhpcy5sYXlvdXQub3B0aW9ucy5oaWVyYXJjaGljYWwubGV2ZWxTZXBhcmF0aW9uICogbGV2ZWw7XG4gICAgICBub2RlLm9wdGlvbnMuZml4ZWQueCA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NoaWZ0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hpZnQobm9kZUlkLCBkaWZmKSB7XG4gICAgICB0aGlzLmxheW91dC5ib2R5Lm5vZGVzW25vZGVJZF0ueSArPSBkaWZmO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gSG9yaXpvbnRhbFN0cmF0ZWd5O1xufShEaXJlY3Rpb25JbnRlcmZhY2UpO1xuXG5leHBvcnRzLkhvcml6b250YWxTdHJhdGVneSA9IEhvcml6b250YWxTdHJhdGVneTtcbmV4cG9ydHMuVmVydGljYWxTdHJhdGVneSA9IFZlcnRpY2FsU3RyYXRlZ3k7XG5cbi8qKiovIH0pLFxuLyogMTkwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfa2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBfa2V5czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9rZXlzKTtcblxudmFyIF9zdHJpbmdpZnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcblxudmFyIF9zdHJpbmdpZnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RyaW5naWZ5KTtcblxudmFyIF90eXBlb2YyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxudmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mMik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgSGFtbWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG52YXIgaGFtbWVyVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpO1xuXG4vKipcbiAqIENsZWFycyB0aGUgdG9vbGJhciBkaXYgZWxlbWVudCBvZiBjaGlsZHJlblxuICpcbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIE1hbmlwdWxhdGlvblN5c3RlbSA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7Q2FudmFzfSBjYW52YXNcbiAgICogQHBhcmFtIHtTZWxlY3Rpb25IYW5kbGVyfSBzZWxlY3Rpb25IYW5kbGVyXG4gICAqL1xuICBmdW5jdGlvbiBNYW5pcHVsYXRpb25TeXN0ZW0oYm9keSwgY2FudmFzLCBzZWxlY3Rpb25IYW5kbGVyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIE1hbmlwdWxhdGlvblN5c3RlbSk7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlciA9IHNlbGVjdGlvbkhhbmRsZXI7XG5cbiAgICB0aGlzLmVkaXRNb2RlID0gZmFsc2U7XG4gICAgdGhpcy5tYW5pcHVsYXRpb25EaXYgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5lZGl0TW9kZURpdiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNsb3NlRGl2ID0gdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5tYW5pcHVsYXRpb25IYW1tZXJzID0gW107XG4gICAgdGhpcy50ZW1wb3JhcnlVSUZ1bmN0aW9ucyA9IHt9O1xuICAgIHRoaXMudGVtcG9yYXJ5RXZlbnRGdW5jdGlvbnMgPSBbXTtcblxuICAgIHRoaXMudG91Y2hUaW1lID0gMDtcbiAgICB0aGlzLnRlbXBvcmFyeUlkcyA9IHsgbm9kZXM6IFtdLCBlZGdlczogW10gfTtcbiAgICB0aGlzLmd1aUVuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmluTW9kZSA9IGZhbHNlO1xuICAgIHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZSA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIGluaXRpYWxseUFjdGl2ZTogZmFsc2UsXG4gICAgICBhZGROb2RlOiB0cnVlLFxuICAgICAgYWRkRWRnZTogdHJ1ZSxcbiAgICAgIGVkaXROb2RlOiB1bmRlZmluZWQsXG4gICAgICBlZGl0RWRnZTogdHJ1ZSxcbiAgICAgIGRlbGV0ZU5vZGU6IHRydWUsXG4gICAgICBkZWxldGVFZGdlOiB0cnVlLFxuICAgICAgY29udHJvbE5vZGVTdHlsZToge1xuICAgICAgICBzaGFwZTogJ2RvdCcsXG4gICAgICAgIHNpemU6IDYsXG4gICAgICAgIGNvbG9yOiB7XG4gICAgICAgICAgYmFja2dyb3VuZDogJyNmZjAwMDAnLFxuICAgICAgICAgIGJvcmRlcjogJyMzYzNjM2MnLFxuICAgICAgICAgIGhpZ2hsaWdodDogeyBiYWNrZ3JvdW5kOiAnIzA3Zjk2OCcsIGJvcmRlcjogJyMzYzNjM2MnIH1cbiAgICAgICAgfSxcbiAgICAgICAgYm9yZGVyV2lkdGg6IDIsXG4gICAgICAgIGJvcmRlcldpZHRoU2VsZWN0ZWQ6IDJcbiAgICAgIH1cbiAgICB9O1xuICAgIHV0aWwuZXh0ZW5kKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLl9jbGVhbigpO1xuICAgIH0pO1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdfZGF0YUNoYW5nZWQnLCB0aGlzLl9yZXN0b3JlLmJpbmQodGhpcykpO1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdfcmVzZXREYXRhJywgdGhpcy5fcmVzdG9yZS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBzb21ldGhpbmcgY2hhbmdlcyBpbiB0aGUgZGF0YSBkdXJpbmcgZWRpdGluZywgc3dpdGNoIGJhY2sgdG8gdGhlIGluaXRpYWwgZGF0YW1hbmlwdWxhdGlvbiBzdGF0ZSBhbmQgY2xvc2UgYWxsIGVkaXQgbW9kZXMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbJ2RlZmF1bHQnXSkoTWFuaXB1bGF0aW9uU3lzdGVtLCBbe1xuICAgIGtleTogJ19yZXN0b3JlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc3RvcmUoKSB7XG4gICAgICBpZiAodGhpcy5pbk1vZGUgIT09IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW5pdGlhbGx5QWN0aXZlID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGlzYWJsZUVkaXRNb2RlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIE9wdGlvbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFsbE9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZ2xvYmFsT3B0aW9uc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRPcHRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zLCBhbGxPcHRpb25zLCBnbG9iYWxPcHRpb25zKSB7XG4gICAgICBpZiAoYWxsT3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhbGxPcHRpb25zLmxvY2FsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmxvY2FsZSA9IGFsbE9wdGlvbnMubG9jYWxlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5sb2NhbGUgPSBnbG9iYWxPcHRpb25zLmxvY2FsZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxsT3B0aW9ucy5sb2NhbGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMubG9jYWxlcyA9IGFsbE9wdGlvbnMubG9jYWxlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMubG9jYWxlcyA9IGdsb2JhbE9wdGlvbnMubG9jYWxlcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmVuYWJsZWQgPSBvcHRpb25zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICB1dGlsLmRlZXBFeHRlbmQodGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmluaXRpYWxseUFjdGl2ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuZWRpdE1vZGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldHVwKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5hYmxlIG9yIGRpc2FibGUgZWRpdC1tb2RlLiBEcmF3cyB0aGUgRE9NIHJlcXVpcmVkIGFuZCBjbGVhbnMgdXAgYWZ0ZXIgaXRzZWxmLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndG9nZ2xlRWRpdE1vZGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGVFZGl0TW9kZSgpIHtcbiAgICAgIGlmICh0aGlzLmVkaXRNb2RlID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZUVkaXRNb2RlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5hYmxlcyBFZGl0IE1vZGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZW5hYmxlRWRpdE1vZGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGVFZGl0TW9kZSgpIHtcbiAgICAgIHRoaXMuZWRpdE1vZGUgPSB0cnVlO1xuXG4gICAgICB0aGlzLl9jbGVhbigpO1xuICAgICAgaWYgKHRoaXMuZ3VpRW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgdGhpcy5jbG9zZURpdi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgdGhpcy5lZGl0TW9kZURpdi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEaXNhYmxlcyBFZGl0IE1vZGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZGlzYWJsZUVkaXRNb2RlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzYWJsZUVkaXRNb2RlKCkge1xuICAgICAgdGhpcy5lZGl0TW9kZSA9IGZhbHNlO1xuXG4gICAgICB0aGlzLl9jbGVhbigpO1xuICAgICAgaWYgKHRoaXMuZ3VpRW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLmNsb3NlRGl2LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMuZWRpdE1vZGVEaXYuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIHRoaXMuX2NyZWF0ZUVkaXRCdXR0b24oKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBtYWluIHRvb2xiYXIuIFJlbW92ZXMgZnVuY3Rpb25zIGJvdW5kIHRvIHRoZSBzZWxlY3QgZXZlbnQuIEJpbmRzIGFsbCB0aGUgYnV0dG9ucyBvZiB0aGUgdG9vbGJhci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Nob3dNYW5pcHVsYXRvclRvb2xiYXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93TWFuaXB1bGF0b3JUb29sYmFyKCkge1xuICAgICAgLy8gcmVzdG9yZSB0aGUgc3RhdGUgb2YgYW55IGJvdW5kIGZ1bmN0aW9ucyBvciBldmVudHMsIHJlbW92ZSBjb250cm9sIG5vZGVzLCByZXN0b3JlIHBoeXNpY3NcbiAgICAgIHRoaXMuX2NsZWFuKCk7XG5cbiAgICAgIC8vIHJlc2V0IGdsb2JhbCB2YXJpYWJsZXNcbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NID0ge307XG5cbiAgICAgIC8vIGlmIHRoZSBndWkgaXMgZW5hYmxlZCwgZHJhdyBhbGwgZWxlbWVudHMuXG4gICAgICBpZiAodGhpcy5ndWlFbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIC8vIGEgX3Jlc3RvcmUgd2lsbCBoaWRlIHRoZXNlIG1lbnVzXG4gICAgICAgIHRoaXMuZWRpdE1vZGUgPSB0cnVlO1xuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgdGhpcy5jbG9zZURpdi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblxuICAgICAgICB2YXIgc2VsZWN0ZWROb2RlQ291bnQgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dldFNlbGVjdGVkTm9kZUNvdW50KCk7XG4gICAgICAgIHZhciBzZWxlY3RlZEVkZ2VDb3VudCA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2V0U2VsZWN0ZWRFZGdlQ291bnQoKTtcbiAgICAgICAgdmFyIHNlbGVjdGVkVG90YWxDb3VudCA9IHNlbGVjdGVkTm9kZUNvdW50ICsgc2VsZWN0ZWRFZGdlQ291bnQ7XG4gICAgICAgIHZhciBsb2NhbGUgPSB0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXTtcbiAgICAgICAgdmFyIG5lZWRTZXBlcmF0b3IgPSBmYWxzZTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFkZE5vZGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhpcy5fY3JlYXRlQWRkTm9kZUJ1dHRvbihsb2NhbGUpO1xuICAgICAgICAgIG5lZWRTZXBlcmF0b3IgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWRkRWRnZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBpZiAobmVlZFNlcGVyYXRvciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlU2VwZXJhdG9yKDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZWVkU2VwZXJhdG9yID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fY3JlYXRlQWRkRWRnZUJ1dHRvbihsb2NhbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGVjdGVkTm9kZUNvdW50ID09PSAxICYmIHR5cGVvZiB0aGlzLm9wdGlvbnMuZWRpdE5vZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBpZiAobmVlZFNlcGVyYXRvciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlU2VwZXJhdG9yKDIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZWVkU2VwZXJhdG9yID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fY3JlYXRlRWRpdE5vZGVCdXR0b24obG9jYWxlKTtcbiAgICAgICAgfSBlbHNlIGlmIChzZWxlY3RlZEVkZ2VDb3VudCA9PT0gMSAmJiBzZWxlY3RlZE5vZGVDb3VudCA9PT0gMCAmJiB0aGlzLm9wdGlvbnMuZWRpdEVkZ2UgIT09IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKG5lZWRTZXBlcmF0b3IgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVNlcGVyYXRvcigzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmVlZFNlcGVyYXRvciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2NyZWF0ZUVkaXRFZGdlQnV0dG9uKGxvY2FsZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgYnV0dG9uc1xuICAgICAgICBpZiAoc2VsZWN0ZWRUb3RhbENvdW50ICE9PSAwKSB7XG4gICAgICAgICAgaWYgKHNlbGVjdGVkTm9kZUNvdW50ID4gMCAmJiB0aGlzLm9wdGlvbnMuZGVsZXRlTm9kZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmIChuZWVkU2VwZXJhdG9yID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVNlcGVyYXRvcig0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZURlbGV0ZUJ1dHRvbihsb2NhbGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0ZWROb2RlQ291bnQgPT09IDAgJiYgdGhpcy5vcHRpb25zLmRlbGV0ZUVkZ2UgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAobmVlZFNlcGVyYXRvciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVTZXBlcmF0b3IoNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVEZWxldGVCdXR0b24obG9jYWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBiaW5kIHRoZSBjbG9zZSBidXR0b25cbiAgICAgICAgdGhpcy5fYmluZEhhbW1lclRvRGl2KHRoaXMuY2xvc2VEaXYsIHRoaXMudG9nZ2xlRWRpdE1vZGUuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgLy8gcmVmcmVzaCB0aGlzIGJhciBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHNlbGVjdGVkXG4gICAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRFdmVudCgnc2VsZWN0JywgdGhpcy5zaG93TWFuaXB1bGF0b3JUb29sYmFyLmJpbmQodGhpcykpO1xuICAgICAgfVxuXG4gICAgICAvLyByZWRyYXcgdG8gc2hvdyBhbnkgcG9zc2libGUgY2hhbmdlc1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX3JlZHJhdycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgdG9vbGJhciBmb3IgYWRkaW5nIE5vZGVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2FkZE5vZGVNb2RlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkTm9kZU1vZGUoKSB7XG4gICAgICAvLyB3aGVuIHVzaW5nIHRoZSBndWksIGVuYWJsZSBlZGl0IG1vZGUgaWYgaXQgd2FzbnQgYWxyZWFkeS5cbiAgICAgIGlmICh0aGlzLmVkaXRNb2RlICE9PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICAgIH1cblxuICAgICAgLy8gcmVzdG9yZSB0aGUgc3RhdGUgb2YgYW55IGJvdW5kIGZ1bmN0aW9ucyBvciBldmVudHMsIHJlbW92ZSBjb250cm9sIG5vZGVzLCByZXN0b3JlIHBoeXNpY3NcbiAgICAgIHRoaXMuX2NsZWFuKCk7XG5cbiAgICAgIHRoaXMuaW5Nb2RlID0gJ2FkZE5vZGUnO1xuICAgICAgaWYgKHRoaXMuZ3VpRW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgbG9jYWxlID0gdGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV07XG4gICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NID0ge307XG4gICAgICAgIHRoaXMuX2NyZWF0ZUJhY2tCdXR0b24obG9jYWxlKTtcbiAgICAgICAgdGhpcy5fY3JlYXRlU2VwZXJhdG9yKCk7XG4gICAgICAgIHRoaXMuX2NyZWF0ZURlc2NyaXB0aW9uKGxvY2FsZVsnYWRkRGVzY3JpcHRpb24nXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1snZW4nXVsnYWRkRGVzY3JpcHRpb24nXSk7XG5cbiAgICAgICAgLy8gYmluZCB0aGUgY2xvc2UgYnV0dG9uXG4gICAgICAgIHRoaXMuX2JpbmRIYW1tZXJUb0Rpdih0aGlzLmNsb3NlRGl2LCB0aGlzLnRvZ2dsZUVkaXRNb2RlLmJpbmQodGhpcykpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kRXZlbnQoJ2NsaWNrJywgdGhpcy5fcGVyZm9ybUFkZE5vZGUuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY2FsbCB0aGUgYm91bmQgZnVuY3Rpb24gdG8gaGFuZGxlIHRoZSBlZGl0aW5nIG9mIHRoZSBub2RlLiBUaGUgbm9kZSBoYXMgdG8gYmUgc2VsZWN0ZWQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2VkaXROb2RlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWRpdE5vZGUoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgLy8gd2hlbiB1c2luZyB0aGUgZ3VpLCBlbmFibGUgZWRpdCBtb2RlIGlmIGl0IHdhc250IGFscmVhZHkuXG4gICAgICBpZiAodGhpcy5lZGl0TW9kZSAhPT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlc3RvcmUgdGhlIHN0YXRlIG9mIGFueSBib3VuZCBmdW5jdGlvbnMgb3IgZXZlbnRzLCByZW1vdmUgY29udHJvbCBub2RlcywgcmVzdG9yZSBwaHlzaWNzXG4gICAgICB0aGlzLl9jbGVhbigpO1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dldFNlbGVjdGVkTm9kZSgpO1xuICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmluTW9kZSA9ICdlZGl0Tm9kZSc7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmVkaXROb2RlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgaWYgKG5vZGUuaXNDbHVzdGVyICE9PSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHV0aWwuZGVlcEV4dGVuZCh7fSwgbm9kZS5vcHRpb25zLCBmYWxzZSk7XG4gICAgICAgICAgICBkYXRhLnggPSBub2RlLng7XG4gICAgICAgICAgICBkYXRhLnkgPSBub2RlLnk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWRpdE5vZGUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lZGl0Tm9kZShkYXRhLCBmdW5jdGlvbiAoZmluYWxpemVkRGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChmaW5hbGl6ZWREYXRhICE9PSBudWxsICYmIGZpbmFsaXplZERhdGEgIT09IHVuZGVmaW5lZCAmJiBfdGhpczIuaW5Nb2RlID09PSAnZWRpdE5vZGUnKSB7XG4gICAgICAgICAgICAgICAgICAvLyBpZiBmb3Igd2hhdGV2ZXIgcmVhc29uIHRoZSBtb2RlIGhhcyBjaGFuZ2VzIChkdWUgdG8gZGF0YXNldCBjaGFuZ2UpIGRpc3JlZ2FyZCB0aGUgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzMi5ib2R5LmRhdGEubm9kZXMuZ2V0RGF0YVNldCgpLnVwZGF0ZShmaW5hbGl6ZWREYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMyLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBmdW5jdGlvbiBmb3IgZWRpdCBkb2VzIG5vdCBzdXBwb3J0IHR3byBhcmd1bWVudHMgKGRhdGEsIGNhbGxiYWNrKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbGVydCh0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXVsnZWRpdENsdXN0ZXJFcnJvciddIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzWydlbiddWydlZGl0Q2x1c3RlckVycm9yJ10pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGZ1bmN0aW9uIGhhcyBiZWVuIGNvbmZpZ3VyZWQgdG8gaGFuZGxlIHRoZSBlZGl0aW5nIG9mIG5vZGVzLicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjcmVhdGUgdGhlIHRvb2xiYXIgdG8gY29ubmVjdCBub2Rlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhZGRFZGdlTW9kZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEVkZ2VNb2RlKCkge1xuICAgICAgLy8gd2hlbiB1c2luZyB0aGUgZ3VpLCBlbmFibGUgZWRpdCBtb2RlIGlmIGl0IHdhc250IGFscmVhZHkuXG4gICAgICBpZiAodGhpcy5lZGl0TW9kZSAhPT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlc3RvcmUgdGhlIHN0YXRlIG9mIGFueSBib3VuZCBmdW5jdGlvbnMgb3IgZXZlbnRzLCByZW1vdmUgY29udHJvbCBub2RlcywgcmVzdG9yZSBwaHlzaWNzXG4gICAgICB0aGlzLl9jbGVhbigpO1xuXG4gICAgICB0aGlzLmluTW9kZSA9ICdhZGRFZGdlJztcbiAgICAgIGlmICh0aGlzLmd1aUVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIGxvY2FsZSA9IHRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdO1xuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTSA9IHt9O1xuICAgICAgICB0aGlzLl9jcmVhdGVCYWNrQnV0dG9uKGxvY2FsZSk7XG4gICAgICAgIHRoaXMuX2NyZWF0ZVNlcGVyYXRvcigpO1xuICAgICAgICB0aGlzLl9jcmVhdGVEZXNjcmlwdGlvbihsb2NhbGVbJ2VkZ2VEZXNjcmlwdGlvbiddIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzWydlbiddWydlZGdlRGVzY3JpcHRpb24nXSk7XG5cbiAgICAgICAgLy8gYmluZCB0aGUgY2xvc2UgYnV0dG9uXG4gICAgICAgIHRoaXMuX2JpbmRIYW1tZXJUb0Rpdih0aGlzLmNsb3NlRGl2LCB0aGlzLnRvZ2dsZUVkaXRNb2RlLmJpbmQodGhpcykpO1xuICAgICAgfVxuXG4gICAgICAvLyB0ZW1wb3JhcmlseSBvdmVybG9hZCBmdW5jdGlvbnNcbiAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSSgnb25Ub3VjaCcsIHRoaXMuX2hhbmRsZUNvbm5lY3QuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kVUkoJ29uRHJhZ0VuZCcsIHRoaXMuX2ZpbmlzaENvbm5lY3QuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kVUkoJ29uRHJhZycsIHRoaXMuX2RyYWdDb250cm9sTm9kZS5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSSgnb25SZWxlYXNlJywgdGhpcy5fZmluaXNoQ29ubmVjdC5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSSgnb25EcmFnU3RhcnQnLCB0aGlzLl9kcmFnU3RhcnRFZGdlLmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZFVJKCdvbkhvbGQnLCBmdW5jdGlvbiAoKSB7fSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY3JlYXRlIHRoZSB0b29sYmFyIHRvIGVkaXQgZWRnZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZWRpdEVkZ2VNb2RlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWRpdEVkZ2VNb2RlKCkge1xuICAgICAgLy8gd2hlbiB1c2luZyB0aGUgZ3VpLCBlbmFibGUgZWRpdCBtb2RlIGlmIGl0IHdhc24ndCBhbHJlYWR5LlxuICAgICAgaWYgKHRoaXMuZWRpdE1vZGUgIT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyByZXN0b3JlIHRoZSBzdGF0ZSBvZiBhbnkgYm91bmQgZnVuY3Rpb25zIG9yIGV2ZW50cywgcmVtb3ZlIGNvbnRyb2wgbm9kZXMsIHJlc3RvcmUgcGh5c2ljc1xuICAgICAgdGhpcy5fY2xlYW4oKTtcblxuICAgICAgdGhpcy5pbk1vZGUgPSAnZWRpdEVkZ2UnO1xuICAgICAgaWYgKCgwLCBfdHlwZW9mM1snZGVmYXVsdCddKSh0aGlzLm9wdGlvbnMuZWRpdEVkZ2UpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdGhpcy5vcHRpb25zLmVkaXRFZGdlLmVkaXRXaXRob3V0RHJhZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLmVkZ2VCZWluZ0VkaXRlZElkID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldFNlbGVjdGVkRWRnZXMoKVswXTtcbiAgICAgICAgaWYgKHRoaXMuZWRnZUJlaW5nRWRpdGVkSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBlZGdlID0gdGhpcy5ib2R5LmVkZ2VzW3RoaXMuZWRnZUJlaW5nRWRpdGVkSWRdO1xuICAgICAgICAgIHRoaXMuX3BlcmZvcm1FZGl0RWRnZShlZGdlLmZyb20sIGVkZ2UudG8pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZ3VpRW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgbG9jYWxlID0gdGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV07XG4gICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NID0ge307XG4gICAgICAgIHRoaXMuX2NyZWF0ZUJhY2tCdXR0b24obG9jYWxlKTtcbiAgICAgICAgdGhpcy5fY3JlYXRlU2VwZXJhdG9yKCk7XG4gICAgICAgIHRoaXMuX2NyZWF0ZURlc2NyaXB0aW9uKGxvY2FsZVsnZWRpdEVkZ2VEZXNjcmlwdGlvbiddIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzWydlbiddWydlZGl0RWRnZURlc2NyaXB0aW9uJ10pO1xuXG4gICAgICAgIC8vIGJpbmQgdGhlIGNsb3NlIGJ1dHRvblxuICAgICAgICB0aGlzLl9iaW5kSGFtbWVyVG9EaXYodGhpcy5jbG9zZURpdiwgdGhpcy50b2dnbGVFZGl0TW9kZS5iaW5kKHRoaXMpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lZGdlQmVpbmdFZGl0ZWRJZCA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRTZWxlY3RlZEVkZ2VzKClbMF07XG4gICAgICBpZiAodGhpcy5lZGdlQmVpbmdFZGl0ZWRJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBfZWRnZSA9IHRoaXMuYm9keS5lZGdlc1t0aGlzLmVkZ2VCZWluZ0VkaXRlZElkXTtcblxuICAgICAgICAvLyBjcmVhdGUgY29udHJvbCBub2Rlc1xuICAgICAgICB2YXIgY29udHJvbE5vZGVGcm9tID0gdGhpcy5fZ2V0TmV3VGFyZ2V0Tm9kZShfZWRnZS5mcm9tLngsIF9lZGdlLmZyb20ueSk7XG4gICAgICAgIHZhciBjb250cm9sTm9kZVRvID0gdGhpcy5fZ2V0TmV3VGFyZ2V0Tm9kZShfZWRnZS50by54LCBfZWRnZS50by55KTtcblxuICAgICAgICB0aGlzLnRlbXBvcmFyeUlkcy5ub2Rlcy5wdXNoKGNvbnRyb2xOb2RlRnJvbS5pZCk7XG4gICAgICAgIHRoaXMudGVtcG9yYXJ5SWRzLm5vZGVzLnB1c2goY29udHJvbE5vZGVUby5pZCk7XG5cbiAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW2NvbnRyb2xOb2RlRnJvbS5pZF0gPSBjb250cm9sTm9kZUZyb207XG4gICAgICAgIHRoaXMuYm9keS5ub2RlSW5kaWNlcy5wdXNoKGNvbnRyb2xOb2RlRnJvbS5pZCk7XG4gICAgICAgIHRoaXMuYm9keS5ub2Rlc1tjb250cm9sTm9kZVRvLmlkXSA9IGNvbnRyb2xOb2RlVG87XG4gICAgICAgIHRoaXMuYm9keS5ub2RlSW5kaWNlcy5wdXNoKGNvbnRyb2xOb2RlVG8uaWQpO1xuXG4gICAgICAgIC8vIHRlbXBvcmFyaWx5IG92ZXJsb2FkIFVJIGZ1bmN0aW9ucywgY2xlYW5lZCB1cCBhdXRvbWF0aWNhbGx5IGJlY2F1c2Ugb2YgX3RlbXBvcmFyeUJpbmRVSVxuICAgICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kVUkoJ29uVG91Y2gnLCB0aGlzLl9jb250cm9sTm9kZVRvdWNoLmJpbmQodGhpcykpOyAvLyB1c2VkIHRvIGdldCB0aGUgcG9zaXRpb25cbiAgICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZFVJKCdvblRhcCcsIGZ1bmN0aW9uICgpIHt9KTsgLy8gZGlzYWJsZWRcbiAgICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZFVJKCdvbkhvbGQnLCBmdW5jdGlvbiAoKSB7fSk7IC8vIGRpc2FibGVkXG4gICAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSSgnb25EcmFnU3RhcnQnLCB0aGlzLl9jb250cm9sTm9kZURyYWdTdGFydC5iaW5kKHRoaXMpKTsgLy8gdXNlZCB0byBzZWxlY3QgY29udHJvbCBub2RlXG4gICAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSSgnb25EcmFnJywgdGhpcy5fY29udHJvbE5vZGVEcmFnLmJpbmQodGhpcykpOyAvLyB1c2VkIHRvIGRyYWcgY29udHJvbCBub2RlXG4gICAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSSgnb25EcmFnRW5kJywgdGhpcy5fY29udHJvbE5vZGVEcmFnRW5kLmJpbmQodGhpcykpOyAvLyB1c2VkIHRvIGNvbm5lY3Qgb3IgcmV2ZXJ0IGNvbnRyb2wgbm9kZXNcbiAgICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZFVJKCdvbk1vdXNlTW92ZScsIGZ1bmN0aW9uICgpIHt9KTsgLy8gZGlzYWJsZWRcblxuICAgICAgICAvLyBjcmVhdGUgZnVuY3Rpb24gdG8gcG9zaXRpb24gY29udHJvbCBub2RlcyBjb3JyZWN0bHkgb24gbW92ZW1lbnRcbiAgICAgICAgLy8gYXV0b21hdGljYWxseSBjbGVhbmVkIHVwIGJlY2F1c2Ugd2UgdXNlIHRoZSB0ZW1wb3JhcnkgYmluZFxuICAgICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kRXZlbnQoJ2JlZm9yZURyYXdpbmcnLCBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgdmFyIHBvc2l0aW9ucyA9IF9lZGdlLmVkZ2VUeXBlLmZpbmRCb3JkZXJQb3NpdGlvbnMoY3R4KTtcbiAgICAgICAgICBpZiAoY29udHJvbE5vZGVGcm9tLnNlbGVjdGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY29udHJvbE5vZGVGcm9tLnggPSBwb3NpdGlvbnMuZnJvbS54O1xuICAgICAgICAgICAgY29udHJvbE5vZGVGcm9tLnkgPSBwb3NpdGlvbnMuZnJvbS55O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29udHJvbE5vZGVUby5zZWxlY3RlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnRyb2xOb2RlVG8ueCA9IHBvc2l0aW9ucy50by54O1xuICAgICAgICAgICAgY29udHJvbE5vZGVUby55ID0gcG9zaXRpb25zLnRvLnk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfcmVkcmF3Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBkZWxldGUgZXZlcnl0aGluZyBpbiB0aGUgc2VsZWN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RlbGV0ZVNlbGVjdGVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlU2VsZWN0ZWQoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgLy8gd2hlbiB1c2luZyB0aGUgZ3VpLCBlbmFibGUgZWRpdCBtb2RlIGlmIGl0IHdhc250IGFscmVhZHkuXG4gICAgICBpZiAodGhpcy5lZGl0TW9kZSAhPT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlc3RvcmUgdGhlIHN0YXRlIG9mIGFueSBib3VuZCBmdW5jdGlvbnMgb3IgZXZlbnRzLCByZW1vdmUgY29udHJvbCBub2RlcywgcmVzdG9yZSBwaHlzaWNzXG4gICAgICB0aGlzLl9jbGVhbigpO1xuXG4gICAgICB0aGlzLmluTW9kZSA9ICdkZWxldGUnO1xuICAgICAgdmFyIHNlbGVjdGVkTm9kZXMgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0ZWROb2RlcygpO1xuICAgICAgdmFyIHNlbGVjdGVkRWRnZXMgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0ZWRFZGdlcygpO1xuICAgICAgdmFyIGRlbGV0ZUZ1bmN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKHNlbGVjdGVkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW3NlbGVjdGVkTm9kZXNbaV1dLmlzQ2x1c3RlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgYWxlcnQodGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV1bJ2RlbGV0ZUNsdXN0ZXJFcnJvciddIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzWydlbiddWydkZWxldGVDbHVzdGVyRXJyb3InXSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuZGVsZXRlTm9kZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRlbGV0ZUZ1bmN0aW9uID0gdGhpcy5vcHRpb25zLmRlbGV0ZU5vZGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc2VsZWN0ZWRFZGdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmRlbGV0ZUVkZ2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBkZWxldGVGdW5jdGlvbiA9IHRoaXMub3B0aW9ucy5kZWxldGVFZGdlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZGVsZXRlRnVuY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7IG5vZGVzOiBzZWxlY3RlZE5vZGVzLCBlZGdlczogc2VsZWN0ZWRFZGdlcyB9O1xuICAgICAgICBpZiAoZGVsZXRlRnVuY3Rpb24ubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgZGVsZXRlRnVuY3Rpb24oZGF0YSwgZnVuY3Rpb24gKGZpbmFsaXplZERhdGEpIHtcbiAgICAgICAgICAgIGlmIChmaW5hbGl6ZWREYXRhICE9PSBudWxsICYmIGZpbmFsaXplZERhdGEgIT09IHVuZGVmaW5lZCAmJiBfdGhpczMuaW5Nb2RlID09PSAnZGVsZXRlJykge1xuICAgICAgICAgICAgICAvLyBpZiBmb3Igd2hhdGV2ZXIgcmVhc29uIHRoZSBtb2RlIGhhcyBjaGFuZ2VzIChkdWUgdG8gZGF0YXNldCBjaGFuZ2UpIGRpc3JlZ2FyZCB0aGUgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgX3RoaXMzLmJvZHkuZGF0YS5lZGdlcy5nZXREYXRhU2V0KCkucmVtb3ZlKGZpbmFsaXplZERhdGEuZWRnZXMpO1xuICAgICAgICAgICAgICBfdGhpczMuYm9keS5kYXRhLm5vZGVzLmdldERhdGFTZXQoKS5yZW1vdmUoZmluYWxpemVkRGF0YS5ub2Rlcyk7XG4gICAgICAgICAgICAgIF90aGlzMy5ib2R5LmVtaXR0ZXIuZW1pdCgnc3RhcnRTaW11bGF0aW9uJyk7XG4gICAgICAgICAgICAgIF90aGlzMy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBfdGhpczMuYm9keS5lbWl0dGVyLmVtaXQoJ3N0YXJ0U2ltdWxhdGlvbicpO1xuICAgICAgICAgICAgICBfdGhpczMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGZ1bmN0aW9uIGZvciBkZWxldGUgZG9lcyBub3Qgc3VwcG9ydCB0d28gYXJndW1lbnRzIChkYXRhLCBjYWxsYmFjayknKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ib2R5LmRhdGEuZWRnZXMuZ2V0RGF0YVNldCgpLnJlbW92ZShzZWxlY3RlZEVkZ2VzKTtcbiAgICAgICAgdGhpcy5ib2R5LmRhdGEubm9kZXMuZ2V0RGF0YVNldCgpLnJlbW92ZShzZWxlY3RlZE5vZGVzKTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnc3RhcnRTaW11bGF0aW9uJyk7XG4gICAgICAgIHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBQUklWQVRFICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi8vXG5cbiAgICAvKipcbiAgICAgKiBkcmF3IG9yIHJlbW92ZSB0aGUgRE9NXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3NldHVwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIC8vIEVuYWJsZSB0aGUgR1VJXG4gICAgICAgIHRoaXMuZ3VpRW5hYmxlZCA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5fY3JlYXRlV3JhcHBlcnMoKTtcbiAgICAgICAgaWYgKHRoaXMuZWRpdE1vZGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhpcy5fY3JlYXRlRWRpdEJ1dHRvbigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZW1vdmVNYW5pcHVsYXRpb25ET00oKTtcblxuICAgICAgICAvLyBkaXNhYmxlIHRoZSBndWlcbiAgICAgICAgdGhpcy5ndWlFbmFibGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY3JlYXRlIHRoZSBkaXYgb3ZlcmxheXMgdGhhdCBjb250YWluIHRoZSBET01cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfY3JlYXRlV3JhcHBlcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlV3JhcHBlcnMoKSB7XG4gICAgICAvLyBsb2FkIHRoZSBtYW5pcHVsYXRvciBIVE1MIGVsZW1lbnRzLiBBbGwgc3R5bGluZyBkb25lIGluIGNzcy5cbiAgICAgIGlmICh0aGlzLm1hbmlwdWxhdGlvbkRpdiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LmNsYXNzTmFtZSA9ICd2aXMtbWFuaXB1bGF0aW9uJztcbiAgICAgICAgaWYgKHRoaXMuZWRpdE1vZGUgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FudmFzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMubWFuaXB1bGF0aW9uRGl2KTtcbiAgICAgIH1cblxuICAgICAgLy8gY29udGFpbmVyIGZvciB0aGUgZWRpdCBidXR0b24uXG4gICAgICBpZiAodGhpcy5lZGl0TW9kZURpdiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZWRpdE1vZGVEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5lZGl0TW9kZURpdi5jbGFzc05hbWUgPSAndmlzLWVkaXQtbW9kZSc7XG4gICAgICAgIGlmICh0aGlzLmVkaXRNb2RlID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5lZGl0TW9kZURpdi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZWRpdE1vZGVEaXYuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYW52YXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5lZGl0TW9kZURpdik7XG4gICAgICB9XG5cbiAgICAgIC8vIGNvbnRhaW5lciBmb3IgdGhlIGNsb3NlIGRpdiBidXR0b25cbiAgICAgIGlmICh0aGlzLmNsb3NlRGl2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5jbG9zZURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmNsb3NlRGl2LmNsYXNzTmFtZSA9ICd2aXMtY2xvc2UnO1xuICAgICAgICB0aGlzLmNsb3NlRGl2LnN0eWxlLmRpc3BsYXkgPSB0aGlzLm1hbmlwdWxhdGlvbkRpdi5zdHlsZS5kaXNwbGF5O1xuICAgICAgICB0aGlzLmNhbnZhcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmNsb3NlRGl2KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZW5lcmF0ZSBhIG5ldyB0YXJnZXQgbm9kZS4gVXNlZCBmb3IgY3JlYXRpbmcgbmV3IGVkZ2VzIGFuZCBlZGl0aW5nIGVkZ2VzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge05vZGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2dldE5ld1RhcmdldE5vZGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0TmV3VGFyZ2V0Tm9kZSh4LCB5KSB7XG4gICAgICB2YXIgY29udHJvbE5vZGVTdHlsZSA9IHV0aWwuZGVlcEV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLmNvbnRyb2xOb2RlU3R5bGUpO1xuXG4gICAgICBjb250cm9sTm9kZVN0eWxlLmlkID0gJ3RhcmdldE5vZGUnICsgdXRpbC5yYW5kb21VVUlEKCk7XG4gICAgICBjb250cm9sTm9kZVN0eWxlLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgY29udHJvbE5vZGVTdHlsZS5waHlzaWNzID0gZmFsc2U7XG4gICAgICBjb250cm9sTm9kZVN0eWxlLnggPSB4O1xuICAgICAgY29udHJvbE5vZGVTdHlsZS55ID0geTtcblxuICAgICAgLy8gd2UgaGF2ZSB0byBkZWZpbmUgdGhlIGJvdW5kaW5nIGJveCBpbiBvcmRlciBmb3IgdGhlIG5vZGVzIHRvIGJlIGRyYXduIGltbWVkaWF0ZWx5XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5mdW5jdGlvbnMuY3JlYXRlTm9kZShjb250cm9sTm9kZVN0eWxlKTtcbiAgICAgIG5vZGUuc2hhcGUuYm91bmRpbmdCb3ggPSB7IGxlZnQ6IHgsIHJpZ2h0OiB4LCB0b3A6IHksIGJvdHRvbTogeSB9O1xuXG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhlIGVkaXQgYnV0dG9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19jcmVhdGVFZGl0QnV0dG9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUVkaXRCdXR0b24oKSB7XG4gICAgICAvLyByZXN0b3JlIGV2ZXJ5dGhpbmcgdG8gaXQncyBvcmlnaW5hbCBzdGF0ZSAoaWYgYXBwbGljYWJsZSlcbiAgICAgIHRoaXMuX2NsZWFuKCk7XG5cbiAgICAgIC8vIHJlc2V0IHRoZSBtYW5pcHVsYXRpb25ET01cbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NID0ge307XG5cbiAgICAgIC8vIGVtcHR5IHRoZSBlZGl0TW9kZURpdlxuICAgICAgdXRpbC5yZWN1cnNpdmVET01EZWxldGUodGhpcy5lZGl0TW9kZURpdik7XG5cbiAgICAgIC8vIGNyZWF0ZSB0aGUgY29udGVudHMgZm9yIHRoZSBlZGl0TW9kZSBidXR0b25cbiAgICAgIHZhciBsb2NhbGUgPSB0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXTtcbiAgICAgIHZhciBidXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oJ2VkaXRNb2RlJywgJ3Zpcy1idXR0b24gdmlzLWVkaXQgdmlzLWVkaXQtbW9kZScsIGxvY2FsZVsnZWRpdCddIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzWydlbiddWydlZGl0J10pO1xuICAgICAgdGhpcy5lZGl0TW9kZURpdi5hcHBlbmRDaGlsZChidXR0b24pO1xuXG4gICAgICAvLyBiaW5kIGEgaGFtbWVyIGxpc3RlbmVyIHRvIHRoZSBidXR0b24sIGNhbGxpbmcgdGhlIGZ1bmN0aW9uIHRvZ2dsZUVkaXRNb2RlLlxuICAgICAgdGhpcy5fYmluZEhhbW1lclRvRGl2KGJ1dHRvbiwgdGhpcy50b2dnbGVFZGl0TW9kZS5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0aGlzIGZ1bmN0aW9uIGNsZWFucyB1cCBhZnRlciBldmVyeXRoaW5nIHRoaXMgbW9kdWxlIGRvZXMuIFRlbXBvcmFyeSBlbGVtZW50cywgZnVuY3Rpb25zIGFuZCBldmVudHMgYXJlIHJlbW92ZWQsIHBoeXNpY3MgcmVzdG9yZWQsIGhhbW1lcnMgcmVtb3ZlZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfY2xlYW4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2xlYW4oKSB7XG4gICAgICAvLyBub3QgaW4gbW9kZVxuICAgICAgdGhpcy5pbk1vZGUgPSBmYWxzZTtcblxuICAgICAgLy8gX2NsZWFuIHRoZSBkaXZzXG4gICAgICBpZiAodGhpcy5ndWlFbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIHV0aWwucmVjdXJzaXZlRE9NRGVsZXRlKHRoaXMuZWRpdE1vZGVEaXYpO1xuICAgICAgICB1dGlsLnJlY3Vyc2l2ZURPTURlbGV0ZSh0aGlzLm1hbmlwdWxhdGlvbkRpdik7XG5cbiAgICAgICAgLy8gcmVtb3ZlcyBhbGwgdGhlIGJpbmRpbmdzIGFuZCBvdmVybG9hZHNcbiAgICAgICAgdGhpcy5fY2xlYW5NYW5pcHVsYXRvckhhbW1lcnMoKTtcbiAgICAgIH1cblxuICAgICAgLy8gcmVtb3ZlIHRlbXBvcmFyeSBub2RlcyBhbmQgZWRnZXNcbiAgICAgIHRoaXMuX2NsZWFudXBUZW1wb3JhcnlOb2Rlc0FuZEVkZ2VzKCk7XG5cbiAgICAgIC8vIHJlc3RvcmUgb3ZlcmxvYWRlZCBVSSBmdW5jdGlvbnNcbiAgICAgIHRoaXMuX3VuYmluZFRlbXBvcmFyeVVJcygpO1xuXG4gICAgICAvLyByZW1vdmUgdGhlIHRlbXBvcmFyeUV2ZW50RnVuY3Rpb25zXG4gICAgICB0aGlzLl91bmJpbmRUZW1wb3JhcnlFdmVudHMoKTtcblxuICAgICAgLy8gcmVzdG9yZSB0aGUgcGh5c2ljcyBpZiByZXF1aXJlZFxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgncmVzdG9yZVBoeXNpY3MnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFYWNoIGRvbSBlbGVtZW50IGhhcyBpdCdzIG93biBoYW1tZXIuIFRoZXkgYXJlIHN0b3JlZCBpbiB0aGlzLm1hbmlwdWxhdGlvbkhhbW1lcnMuIFRoaXMgY2xlYW5zIHRoZW0gdXAuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2NsZWFuTWFuaXB1bGF0b3JIYW1tZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NsZWFuTWFuaXB1bGF0b3JIYW1tZXJzKCkge1xuICAgICAgLy8gX2NsZWFuIGhhbW1lciBiaW5kaW5nc1xuICAgICAgaWYgKHRoaXMubWFuaXB1bGF0aW9uSGFtbWVycy5sZW5ndGggIT0gMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubWFuaXB1bGF0aW9uSGFtbWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMubWFuaXB1bGF0aW9uSGFtbWVyc1tpXS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25IYW1tZXJzID0gW107XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCBET00gZWxlbWVudHMgY3JlYXRlZCBieSB0aGlzIG1vZHVsZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfcmVtb3ZlTWFuaXB1bGF0aW9uRE9NJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZU1hbmlwdWxhdGlvbkRPTSgpIHtcbiAgICAgIC8vIHJlbW92ZXMgYWxsIHRoZSBiaW5kaW5ncyBhbmQgb3ZlcmxvYWRzXG4gICAgICB0aGlzLl9jbGVhbigpO1xuXG4gICAgICAvLyBlbXB0eSB0aGUgbWFuaXB1bGF0aW9uIGRpdnNcbiAgICAgIHV0aWwucmVjdXJzaXZlRE9NRGVsZXRlKHRoaXMubWFuaXB1bGF0aW9uRGl2KTtcbiAgICAgIHV0aWwucmVjdXJzaXZlRE9NRGVsZXRlKHRoaXMuZWRpdE1vZGVEaXYpO1xuICAgICAgdXRpbC5yZWN1cnNpdmVET01EZWxldGUodGhpcy5jbG9zZURpdik7XG5cbiAgICAgIC8vIHJlbW92ZSB0aGUgbWFuaXB1bGF0aW9uIGRpdnNcbiAgICAgIGlmICh0aGlzLm1hbmlwdWxhdGlvbkRpdikge1xuICAgICAgICB0aGlzLmNhbnZhcy5mcmFtZS5yZW1vdmVDaGlsZCh0aGlzLm1hbmlwdWxhdGlvbkRpdik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5lZGl0TW9kZURpdikge1xuICAgICAgICB0aGlzLmNhbnZhcy5mcmFtZS5yZW1vdmVDaGlsZCh0aGlzLmVkaXRNb2RlRGl2KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNsb3NlRGl2KSB7XG4gICAgICAgIHRoaXMuY2FudmFzLmZyYW1lLnJlbW92ZUNoaWxkKHRoaXMuY2xvc2VEaXYpO1xuICAgICAgfVxuXG4gICAgICAvLyBzZXQgdGhlIHJlZmVyZW5jZXMgdG8gdW5kZWZpbmVkXG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdiA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZWRpdE1vZGVEaXYgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmNsb3NlRGl2ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNyZWF0ZSBhIHNlcGVyYXRvciBsaW5lLiB0aGUgaW5kZXggaXMgdG8gZGlmZmVyZW50aWF0ZSBpbiB0aGUgbWFuaXB1bGF0aW9uIGRvbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXg9MV1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfY3JlYXRlU2VwZXJhdG9yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZVNlcGVyYXRvcigpIHtcbiAgICAgIHZhciBpbmRleCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMTtcblxuICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET01bJ3NlcGVyYXRvckxpbmVEaXYnICsgaW5kZXhdID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTVsnc2VwZXJhdG9yTGluZURpdicgKyBpbmRleF0uY2xhc3NOYW1lID0gJ3Zpcy1zZXBhcmF0b3ItbGluZSc7XG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5hcHBlbmRDaGlsZCh0aGlzLm1hbmlwdWxhdGlvbkRPTVsnc2VwZXJhdG9yTGluZURpdicgKyBpbmRleF0pO1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gICAgRE9NIGZ1bmN0aW9ucyBmb3IgYnV0dG9ucyAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TG9jYWxlfSBsb2NhbGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfY3JlYXRlQWRkTm9kZUJ1dHRvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVBZGROb2RlQnV0dG9uKGxvY2FsZSkge1xuICAgICAgdmFyIGJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbignYWRkTm9kZScsICd2aXMtYnV0dG9uIHZpcy1hZGQnLCBsb2NhbGVbJ2FkZE5vZGUnXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1snZW4nXVsnYWRkTm9kZSddKTtcbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LmFwcGVuZENoaWxkKGJ1dHRvbik7XG4gICAgICB0aGlzLl9iaW5kSGFtbWVyVG9EaXYoYnV0dG9uLCB0aGlzLmFkZE5vZGVNb2RlLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtMb2NhbGV9IGxvY2FsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19jcmVhdGVBZGRFZGdlQnV0dG9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUFkZEVkZ2VCdXR0b24obG9jYWxlKSB7XG4gICAgICB2YXIgYnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKCdhZGRFZGdlJywgJ3Zpcy1idXR0b24gdmlzLWNvbm5lY3QnLCBsb2NhbGVbJ2FkZEVkZ2UnXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1snZW4nXVsnYWRkRWRnZSddKTtcbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LmFwcGVuZENoaWxkKGJ1dHRvbik7XG4gICAgICB0aGlzLl9iaW5kSGFtbWVyVG9EaXYoYnV0dG9uLCB0aGlzLmFkZEVkZ2VNb2RlLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtMb2NhbGV9IGxvY2FsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19jcmVhdGVFZGl0Tm9kZUJ1dHRvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVFZGl0Tm9kZUJ1dHRvbihsb2NhbGUpIHtcbiAgICAgIHZhciBidXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oJ2VkaXROb2RlJywgJ3Zpcy1idXR0b24gdmlzLWVkaXQnLCBsb2NhbGVbJ2VkaXROb2RlJ10gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbJ2VuJ11bJ2VkaXROb2RlJ10pO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcbiAgICAgIHRoaXMuX2JpbmRIYW1tZXJUb0RpdihidXR0b24sIHRoaXMuZWRpdE5vZGUuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xvY2FsZX0gbG9jYWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2NyZWF0ZUVkaXRFZGdlQnV0dG9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUVkaXRFZGdlQnV0dG9uKGxvY2FsZSkge1xuICAgICAgdmFyIGJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbignZWRpdEVkZ2UnLCAndmlzLWJ1dHRvbiB2aXMtZWRpdCcsIGxvY2FsZVsnZWRpdEVkZ2UnXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1snZW4nXVsnZWRpdEVkZ2UnXSk7XG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5hcHBlbmRDaGlsZChidXR0b24pO1xuICAgICAgdGhpcy5fYmluZEhhbW1lclRvRGl2KGJ1dHRvbiwgdGhpcy5lZGl0RWRnZU1vZGUuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xvY2FsZX0gbG9jYWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2NyZWF0ZURlbGV0ZUJ1dHRvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVEZWxldGVCdXR0b24obG9jYWxlKSB7XG4gICAgICB2YXIgZGVsZXRlQnRuQ2xhc3M7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgICBkZWxldGVCdG5DbGFzcyA9ICd2aXMtYnV0dG9uIHZpcy1kZWxldGUtcnRsJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZUJ0bkNsYXNzID0gJ3Zpcy1idXR0b24gdmlzLWRlbGV0ZSc7XG4gICAgICB9XG4gICAgICB2YXIgYnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKCdkZWxldGUnLCBkZWxldGVCdG5DbGFzcywgbG9jYWxlWydkZWwnXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1snZW4nXVsnZGVsJ10pO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcbiAgICAgIHRoaXMuX2JpbmRIYW1tZXJUb0RpdihidXR0b24sIHRoaXMuZGVsZXRlU2VsZWN0ZWQuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xvY2FsZX0gbG9jYWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2NyZWF0ZUJhY2tCdXR0b24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlQmFja0J1dHRvbihsb2NhbGUpIHtcbiAgICAgIHZhciBidXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oJ2JhY2snLCAndmlzLWJ1dHRvbiB2aXMtYmFjaycsIGxvY2FsZVsnYmFjayddIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzWydlbiddWydiYWNrJ10pO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcbiAgICAgIHRoaXMuX2JpbmRIYW1tZXJUb0RpdihidXR0b24sIHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhci5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAgICogQHBhcmFtIHtsYWJlbH0gbGFiZWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGFiZWxDbGFzc05hbWVcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2NyZWF0ZUJ1dHRvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVCdXR0b24oaWQsIGNsYXNzTmFtZSwgbGFiZWwpIHtcbiAgICAgIHZhciBsYWJlbENsYXNzTmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogJ3Zpcy1sYWJlbCc7XG5cbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NW2lkICsgJ0RpdiddID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTVtpZCArICdEaXYnXS5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTVtpZCArICdMYWJlbCddID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTVtpZCArICdMYWJlbCddLmNsYXNzTmFtZSA9IGxhYmVsQ2xhc3NOYW1lO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET01baWQgKyAnTGFiZWwnXS5pbm5lckhUTUwgPSBsYWJlbDtcbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NW2lkICsgJ0RpdiddLmFwcGVuZENoaWxkKHRoaXMubWFuaXB1bGF0aW9uRE9NW2lkICsgJ0xhYmVsJ10pO1xuICAgICAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uRE9NW2lkICsgJ0RpdiddO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfY3JlYXRlRGVzY3JpcHRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlRGVzY3JpcHRpb24obGFiZWwpIHtcbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LmFwcGVuZENoaWxkKHRoaXMuX2NyZWF0ZUJ1dHRvbignZGVzY3JpcHRpb24nLCAndmlzLWJ1dHRvbiB2aXMtbm9uZScsIGxhYmVsKSk7XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRW5kIG9mIERPTSBmdW5jdGlvbnMgZm9yIGJ1dHRvbnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLy9cblxuICAgIC8qKlxuICAgICAqIHRoaXMgYmluZHMgYW4gZXZlbnQgdW50aWwgY2xlYW51cCBieSB0aGUgY2xlYW4gZnVuY3Rpb25zLlxuICAgICAqIEBwYXJhbSB7RXZlbnR9ICBldmVudCAgIFRoZSBldmVudFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IG5ld0Z1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3RlbXBvcmFyeUJpbmRFdmVudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90ZW1wb3JhcnlCaW5kRXZlbnQoZXZlbnQsIG5ld0Z1bmN0aW9uKSB7XG4gICAgICB0aGlzLnRlbXBvcmFyeUV2ZW50RnVuY3Rpb25zLnB1c2goe1xuICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgIGJvdW5kRnVuY3Rpb246IG5ld0Z1bmN0aW9uXG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKGV2ZW50LCBuZXdGdW5jdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdGhpcyBvdmVycmlkZXMgYW4gVUkgZnVuY3Rpb24gdW50aWwgY2xlYW51cCBieSB0aGUgY2xlYW4gZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gVUlmdW5jdGlvbk5hbWVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBuZXdGdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ190ZW1wb3JhcnlCaW5kVUknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdGVtcG9yYXJ5QmluZFVJKFVJZnVuY3Rpb25OYW1lLCBuZXdGdW5jdGlvbikge1xuICAgICAgaWYgKHRoaXMuYm9keS5ldmVudExpc3RlbmVyc1tVSWZ1bmN0aW9uTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnRlbXBvcmFyeVVJRnVuY3Rpb25zW1VJZnVuY3Rpb25OYW1lXSA9IHRoaXMuYm9keS5ldmVudExpc3RlbmVyc1tVSWZ1bmN0aW9uTmFtZV07XG4gICAgICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVyc1tVSWZ1bmN0aW9uTmFtZV0gPSBuZXdGdW5jdGlvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBVSSBmdW5jdGlvbiBkb2VzIG5vdCBleGlzdC4gVHlwbz8gWW91IHRyaWVkOiAnICsgVUlmdW5jdGlvbk5hbWUgKyAnIHBvc3NpYmxlIGFyZTogJyArICgwLCBfc3RyaW5naWZ5MlsnZGVmYXVsdCddKSgoMCwgX2tleXMyWydkZWZhdWx0J10pKHRoaXMuYm9keS5ldmVudExpc3RlbmVycykpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlIHRoZSBvdmVycmlkZGVuIFVJIGZ1bmN0aW9ucyB0byB0aGVpciBvcmlnaW5hbCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ191bmJpbmRUZW1wb3JhcnlVSXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5iaW5kVGVtcG9yYXJ5VUlzKCkge1xuICAgICAgZm9yICh2YXIgZnVuY3Rpb25OYW1lIGluIHRoaXMudGVtcG9yYXJ5VUlGdW5jdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMudGVtcG9yYXJ5VUlGdW5jdGlvbnMuaGFzT3duUHJvcGVydHkoZnVuY3Rpb25OYW1lKSkge1xuICAgICAgICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVyc1tmdW5jdGlvbk5hbWVdID0gdGhpcy50ZW1wb3JhcnlVSUZ1bmN0aW9uc1tmdW5jdGlvbk5hbWVdO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnRlbXBvcmFyeVVJRnVuY3Rpb25zW2Z1bmN0aW9uTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMudGVtcG9yYXJ5VUlGdW5jdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVbmJpbmQgdGhlIGV2ZW50cyBjcmVhdGVkIGJ5IF90ZW1wb3JhcnlCaW5kRXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfdW5iaW5kVGVtcG9yYXJ5RXZlbnRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VuYmluZFRlbXBvcmFyeUV2ZW50cygpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50ZW1wb3JhcnlFdmVudEZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXZlbnROYW1lID0gdGhpcy50ZW1wb3JhcnlFdmVudEZ1bmN0aW9uc1tpXS5ldmVudDtcbiAgICAgICAgdmFyIGJvdW5kRnVuY3Rpb24gPSB0aGlzLnRlbXBvcmFyeUV2ZW50RnVuY3Rpb25zW2ldLmJvdW5kRnVuY3Rpb247XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9mZihldmVudE5hbWUsIGJvdW5kRnVuY3Rpb24pO1xuICAgICAgfVxuICAgICAgdGhpcy50ZW1wb3JhcnlFdmVudEZ1bmN0aW9ucyA9IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJpbmQgYW4gaGFtbWVyIGluc3RhbmNlIHRvIGEgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGRvbUVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBib3VuZEZ1bmN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19iaW5kSGFtbWVyVG9EaXYnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYmluZEhhbW1lclRvRGl2KGRvbUVsZW1lbnQsIGJvdW5kRnVuY3Rpb24pIHtcbiAgICAgIHZhciBoYW1tZXIgPSBuZXcgSGFtbWVyKGRvbUVsZW1lbnQsIHt9KTtcbiAgICAgIGhhbW1lclV0aWwub25Ub3VjaChoYW1tZXIsIGJvdW5kRnVuY3Rpb24pO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25IYW1tZXJzLnB1c2goaGFtbWVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOZWF0bHkgY2xlYW4gdXAgdGVtcG9yYXJ5IGVkZ2VzIGFuZCBub2Rlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19jbGVhbnVwVGVtcG9yYXJ5Tm9kZXNBbmRFZGdlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jbGVhbnVwVGVtcG9yYXJ5Tm9kZXNBbmRFZGdlcygpIHtcbiAgICAgIC8vIF9jbGVhbiB0ZW1wb3JhcnkgZWRnZXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50ZW1wb3JhcnlJZHMuZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5ib2R5LmVkZ2VzW3RoaXMudGVtcG9yYXJ5SWRzLmVkZ2VzW2ldXS5kaXNjb25uZWN0KCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmJvZHkuZWRnZXNbdGhpcy50ZW1wb3JhcnlJZHMuZWRnZXNbaV1dO1xuICAgICAgICB2YXIgaW5kZXhUZW1wRWRnZSA9IHRoaXMuYm9keS5lZGdlSW5kaWNlcy5pbmRleE9mKHRoaXMudGVtcG9yYXJ5SWRzLmVkZ2VzW2ldKTtcbiAgICAgICAgaWYgKGluZGV4VGVtcEVkZ2UgIT09IC0xKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVkZ2VJbmRpY2VzLnNwbGljZShpbmRleFRlbXBFZGdlLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBfY2xlYW4gdGVtcG9yYXJ5IG5vZGVzXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdGhpcy50ZW1wb3JhcnlJZHMubm9kZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmJvZHkubm9kZXNbdGhpcy50ZW1wb3JhcnlJZHMubm9kZXNbX2ldXTtcbiAgICAgICAgdmFyIGluZGV4VGVtcE5vZGUgPSB0aGlzLmJvZHkubm9kZUluZGljZXMuaW5kZXhPZih0aGlzLnRlbXBvcmFyeUlkcy5ub2Rlc1tfaV0pO1xuICAgICAgICBpZiAoaW5kZXhUZW1wTm9kZSAhPT0gLTEpIHtcbiAgICAgICAgICB0aGlzLmJvZHkubm9kZUluZGljZXMuc3BsaWNlKGluZGV4VGVtcE5vZGUsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMudGVtcG9yYXJ5SWRzID0geyBub2RlczogW10sIGVkZ2VzOiBbXSB9O1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFRElUIEVER0UgRlVOQ1RJT05TIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLy9cblxuICAgIC8qKlxuICAgICAqIHRoZSB0b3VjaCBpcyB1c2VkIHRvIGdldCB0aGUgcG9zaXRpb24gb2YgdGhlIGluaXRpYWwgY2xpY2tcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSAgZXZlbnQgICBUaGUgZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfY29udHJvbE5vZGVUb3VjaCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jb250cm9sTm9kZVRvdWNoKGV2ZW50KSB7XG4gICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIudW5zZWxlY3RBbGwoKTtcbiAgICAgIHRoaXMubGFzdFRvdWNoID0gdGhpcy5ib2R5LmZ1bmN0aW9ucy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICB0aGlzLmxhc3RUb3VjaC50cmFuc2xhdGlvbiA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbik7IC8vIGNvcHkgdGhlIG9iamVjdFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRoZSBkcmFnIHN0YXJ0IGlzIHVzZWQgdG8gbWFyayBvbmUgb2YgdGhlIGNvbnRyb2wgbm9kZXMgYXMgc2VsZWN0ZWQuXG4gICAgICogQHBhcmFtIHtFdmVudH0gIGV2ZW50ICAgVGhlIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2NvbnRyb2xOb2RlRHJhZ1N0YXJ0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbnRyb2xOb2RlRHJhZ1N0YXJ0KCkgLyogZXZlbnQgKi97XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMubGFzdFRvdWNoO1xuICAgICAgdmFyIHBvaW50ZXJPYmogPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX3BvaW50ZXJUb1Bvc2l0aW9uT2JqZWN0KHBvaW50ZXIpO1xuICAgICAgdmFyIGZyb20gPSB0aGlzLmJvZHkubm9kZXNbdGhpcy50ZW1wb3JhcnlJZHMubm9kZXNbMF1dO1xuICAgICAgdmFyIHRvID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMudGVtcG9yYXJ5SWRzLm5vZGVzWzFdXTtcbiAgICAgIHZhciBlZGdlID0gdGhpcy5ib2R5LmVkZ2VzW3RoaXMuZWRnZUJlaW5nRWRpdGVkSWRdO1xuICAgICAgdGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlID0gdW5kZWZpbmVkO1xuXG4gICAgICB2YXIgZnJvbVNlbGVjdCA9IGZyb20uaXNPdmVybGFwcGluZ1dpdGgocG9pbnRlck9iaik7XG4gICAgICB2YXIgdG9TZWxlY3QgPSB0by5pc092ZXJsYXBwaW5nV2l0aChwb2ludGVyT2JqKTtcblxuICAgICAgaWYgKGZyb21TZWxlY3QgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlID0gZnJvbTtcbiAgICAgICAgZWRnZS5lZGdlVHlwZS5mcm9tID0gZnJvbTtcbiAgICAgIH0gZWxzZSBpZiAodG9TZWxlY3QgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlID0gdG87XG4gICAgICAgIGVkZ2UuZWRnZVR5cGUudG8gPSB0bztcbiAgICAgIH1cblxuICAgICAgLy8gd2UgdXNlIHRoZSBzZWxlY3Rpb24gdG8gZmluZCB0aGUgbm9kZSB0aGF0IGlzIGJlaW5nIGRyYWdnZWQuIFdlIGV4cGxpY2l0bHkgc2VsZWN0IGl0IGhlcmUuXG4gICAgICBpZiAodGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnNlbGVjdE9iamVjdCh0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfcmVkcmF3Jyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZHJhZ2dpbmcgdGhlIGNvbnRyb2wgbm9kZXMgb3IgdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7RXZlbnR9ICBldmVudCAgIFRoZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19jb250cm9sTm9kZURyYWcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY29udHJvbE5vZGVEcmFnKGV2ZW50KSB7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdkaXNhYmxlUGh5c2ljcycpO1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcbiAgICAgIHZhciBwb3MgPSB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyhwb2ludGVyKTtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUueCA9IHBvcy54O1xuICAgICAgICB0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUueSA9IHBvcy55O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgdGhlIGRyYWcgd2FzIG5vdCBzdGFydGVkIHByb3Blcmx5IGJlY2F1c2UgdGhlIGNsaWNrIHN0YXJ0ZWQgb3V0c2lkZSB0aGUgbmV0d29yayBkaXYsIHN0YXJ0IGl0IG5vdy5cbiAgICAgICAgdmFyIGRpZmZYID0gcG9pbnRlci54IC0gdGhpcy5sYXN0VG91Y2gueDtcbiAgICAgICAgdmFyIGRpZmZZID0gcG9pbnRlci55IC0gdGhpcy5sYXN0VG91Y2gueTtcbiAgICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24gPSB7XG4gICAgICAgICAgeDogdGhpcy5sYXN0VG91Y2gudHJhbnNsYXRpb24ueCArIGRpZmZYLFxuICAgICAgICAgIHk6IHRoaXMubGFzdFRvdWNoLnRyYW5zbGF0aW9uLnkgKyBkaWZmWVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX3JlZHJhdycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNvbm5lY3Rpbmcgb3IgcmVzdG9yaW5nIHRoZSBjb250cm9sIG5vZGVzLlxuICAgICAqIEBwYXJhbSB7RXZlbnR9ICBldmVudCAgIFRoZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19jb250cm9sTm9kZURyYWdFbmQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY29udHJvbE5vZGVEcmFnRW5kKGV2ZW50KSB7XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuYm9keS5mdW5jdGlvbnMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuICAgICAgdmFyIHBvaW50ZXJPYmogPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX3BvaW50ZXJUb1Bvc2l0aW9uT2JqZWN0KHBvaW50ZXIpO1xuICAgICAgdmFyIGVkZ2UgPSB0aGlzLmJvZHkuZWRnZXNbdGhpcy5lZGdlQmVpbmdFZGl0ZWRJZF07XG4gICAgICAvLyBpZiB0aGUgbm9kZSB0aGF0IHdhcyBkcmFnZ2VkIGlzIG5vdCBhIGNvbnRyb2wgbm9kZSwgcmV0dXJuXG4gICAgICBpZiAodGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyB3ZSB1c2UgdGhlIHNlbGVjdGlvbiB0byBmaW5kIHRoZSBub2RlIHRoYXQgaXMgYmVpbmcgZHJhZ2dlZC4gV2UgZXhwbGljaXRseSBERXNlbGVjdCB0aGUgY29udHJvbCBub2RlIGhlcmUuXG4gICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIudW5zZWxlY3RBbGwoKTtcbiAgICAgIHZhciBvdmVybGFwcGluZ05vZGVJZHMgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dldEFsbE5vZGVzT3ZlcmxhcHBpbmdXaXRoKHBvaW50ZXJPYmopO1xuICAgICAgdmFyIG5vZGUgPSB1bmRlZmluZWQ7XG4gICAgICBmb3IgKHZhciBpID0gb3ZlcmxhcHBpbmdOb2RlSWRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmIChvdmVybGFwcGluZ05vZGVJZHNbaV0gIT09IHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZS5pZCkge1xuICAgICAgICAgIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbb3ZlcmxhcHBpbmdOb2RlSWRzW2ldXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gcGVyZm9ybSB0aGUgY29ubmVjdGlvblxuICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAobm9kZS5pc0NsdXN0ZXIgPT09IHRydWUpIHtcbiAgICAgICAgICBhbGVydCh0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXVsnY3JlYXRlRWRnZUVycm9yJ10gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbJ2VuJ11bJ2NyZWF0ZUVkZ2VFcnJvciddKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZnJvbSA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLnRlbXBvcmFyeUlkcy5ub2Rlc1swXV07XG4gICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZS5pZCA9PT0gZnJvbS5pZCkge1xuICAgICAgICAgICAgdGhpcy5fcGVyZm9ybUVkaXRFZGdlKG5vZGUuaWQsIGVkZ2UudG8uaWQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wZXJmb3JtRWRpdEVkZ2UoZWRnZS5mcm9tLmlkLCBub2RlLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVkZ2UudXBkYXRlRWRnZVR5cGUoKTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgncmVzdG9yZVBoeXNpY3MnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX3JlZHJhdycpO1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFTkQgT0YgRURJVCBFREdFIEZVTkNUSU9OUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEFERCBFREdFIEZVTkNUSU9OUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXG4gICAgLyoqXG4gICAgICogdGhlIGZ1bmN0aW9uIGJvdW5kIHRvIHRoZSBzZWxlY3Rpb24gZXZlbnQuIEl0IGNoZWNrcyBpZiB5b3Ugd2FudCB0byBjb25uZWN0IGEgY2x1c3RlciBhbmQgY2hhbmdlcyB0aGUgZGVzY3JpcHRpb25cbiAgICAgKiB0byB3YWxrIHRoZSB1c2VyIHRocm91Z2ggdGhlIHByb2Nlc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19oYW5kbGVDb25uZWN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUNvbm5lY3QoZXZlbnQpIHtcbiAgICAgIC8vIGNoZWNrIHRvIGF2b2lkIGRvdWJsZSBmaXJlaW5nIG9mIHRoaXMgZnVuY3Rpb24uXG4gICAgICBpZiAobmV3IERhdGUoKS52YWx1ZU9mKCkgLSB0aGlzLnRvdWNoVGltZSA+IDEwMCkge1xuICAgICAgICB0aGlzLmxhc3RUb3VjaCA9IHRoaXMuYm9keS5mdW5jdGlvbnMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuICAgICAgICB0aGlzLmxhc3RUb3VjaC50cmFuc2xhdGlvbiA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbik7IC8vIGNvcHkgdGhlIG9iamVjdFxuXG4gICAgICAgIHZhciBwb2ludGVyID0gdGhpcy5sYXN0VG91Y2g7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldE5vZGVBdChwb2ludGVyKTtcblxuICAgICAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKG5vZGUuaXNDbHVzdGVyID09PSB0cnVlKSB7XG4gICAgICAgICAgICBhbGVydCh0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXVsnY3JlYXRlRWRnZUVycm9yJ10gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbJ2VuJ11bJ2NyZWF0ZUVkZ2VFcnJvciddKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY3JlYXRlIGEgbm9kZSB0aGUgdGVtcG9yYXJ5IGxpbmUgY2FuIGxvb2sgYXRcbiAgICAgICAgICAgIHZhciB0YXJnZXROb2RlID0gdGhpcy5fZ2V0TmV3VGFyZ2V0Tm9kZShub2RlLngsIG5vZGUueSk7XG4gICAgICAgICAgICB0aGlzLmJvZHkubm9kZXNbdGFyZ2V0Tm9kZS5pZF0gPSB0YXJnZXROb2RlO1xuICAgICAgICAgICAgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLnB1c2godGFyZ2V0Tm9kZS5pZCk7XG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhIHRlbXBvcmFyeSBlZGdlXG4gICAgICAgICAgICB2YXIgY29ubmVjdGlvbkVkZ2UgPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZUVkZ2Uoe1xuICAgICAgICAgICAgICBpZDogJ2Nvbm5lY3Rpb25FZGdlJyArIHV0aWwucmFuZG9tVVVJRCgpLFxuICAgICAgICAgICAgICBmcm9tOiBub2RlLmlkLFxuICAgICAgICAgICAgICB0bzogdGFyZ2V0Tm9kZS5pZCxcbiAgICAgICAgICAgICAgcGh5c2ljczogZmFsc2UsXG4gICAgICAgICAgICAgIHNtb290aDoge1xuICAgICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvbnRpbnVvdXMnLFxuICAgICAgICAgICAgICAgIHJvdW5kbmVzczogMC41XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5ib2R5LmVkZ2VzW2Nvbm5lY3Rpb25FZGdlLmlkXSA9IGNvbm5lY3Rpb25FZGdlO1xuICAgICAgICAgICAgdGhpcy5ib2R5LmVkZ2VJbmRpY2VzLnB1c2goY29ubmVjdGlvbkVkZ2UuaWQpO1xuXG4gICAgICAgICAgICB0aGlzLnRlbXBvcmFyeUlkcy5ub2Rlcy5wdXNoKHRhcmdldE5vZGUuaWQpO1xuICAgICAgICAgICAgdGhpcy50ZW1wb3JhcnlJZHMuZWRnZXMucHVzaChjb25uZWN0aW9uRWRnZS5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudG91Y2hUaW1lID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19kcmFnQ29udHJvbE5vZGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhZ0NvbnRyb2xOb2RlKGV2ZW50KSB7XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuYm9keS5mdW5jdGlvbnMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuXG4gICAgICB2YXIgcG9pbnRlck9iaiA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fcG9pbnRlclRvUG9zaXRpb25PYmplY3QocG9pbnRlcik7XG4gICAgICAvLyByZW1lbWJlciB0aGUgZWRnZSBpZFxuICAgICAgdmFyIGNvbm5lY3RGcm9tSWQgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAodGhpcy50ZW1wb3JhcnlJZHMuZWRnZXNbMF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25uZWN0RnJvbUlkID0gdGhpcy5ib2R5LmVkZ2VzW3RoaXMudGVtcG9yYXJ5SWRzLmVkZ2VzWzBdXS5mcm9tSWQ7XG4gICAgICB9XG4gICAgICAvLyBnZXQgdGhlIG92ZXJsYXBwaW5nIG5vZGUgYnV0IE5PVCB0aGUgdGVtcG9yYXJ5IG5vZGU7XG4gICAgICB2YXIgb3ZlcmxhcHBpbmdOb2RlSWRzID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZXRBbGxOb2Rlc092ZXJsYXBwaW5nV2l0aChwb2ludGVyT2JqKTtcbiAgICAgIHZhciBub2RlID0gdW5kZWZpbmVkO1xuICAgICAgZm9yICh2YXIgaSA9IG92ZXJsYXBwaW5nTm9kZUlkcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAvLyBpZiB0aGUgbm9kZSBpZCBpcyBOT1QgYSB0ZW1wb3Jhcnkgbm9kZSwgYWNjZXB0IHRoZSBub2RlLlxuICAgICAgICBpZiAodGhpcy50ZW1wb3JhcnlJZHMubm9kZXMuaW5kZXhPZihvdmVybGFwcGluZ05vZGVJZHNbaV0pID09PSAtMSkge1xuICAgICAgICAgIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbb3ZlcmxhcHBpbmdOb2RlSWRzW2ldXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBldmVudC5jb250cm9sRWRnZSA9IHsgZnJvbTogY29ubmVjdEZyb21JZCwgdG86IG5vZGUgPyBub2RlLmlkIDogdW5kZWZpbmVkIH07XG4gICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dlbmVyYXRlQ2xpY2tFdmVudCgnY29udHJvbE5vZGVEcmFnZ2luZycsIGV2ZW50LCBwb2ludGVyKTtcblxuICAgICAgaWYgKHRoaXMudGVtcG9yYXJ5SWRzLm5vZGVzWzBdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHRhcmdldE5vZGUgPSB0aGlzLmJvZHkubm9kZXNbdGhpcy50ZW1wb3JhcnlJZHMubm9kZXNbMF1dOyAvLyB0aGVyZSBpcyBvbmx5IG9uZSB0ZW1wIG5vZGUgaW4gdGhlIGFkZCBlZGdlIG1vZGUuXG4gICAgICAgIHRhcmdldE5vZGUueCA9IHRoaXMuY2FudmFzLl9YY29udmVydERPTXRvQ2FudmFzKHBvaW50ZXIueCk7XG4gICAgICAgIHRhcmdldE5vZGUueSA9IHRoaXMuY2FudmFzLl9ZY29udmVydERPTXRvQ2FudmFzKHBvaW50ZXIueSk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19yZWRyYXcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkaWZmWCA9IHBvaW50ZXIueCAtIHRoaXMubGFzdFRvdWNoLng7XG4gICAgICAgIHZhciBkaWZmWSA9IHBvaW50ZXIueSAtIHRoaXMubGFzdFRvdWNoLnk7XG4gICAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uID0ge1xuICAgICAgICAgIHg6IHRoaXMubGFzdFRvdWNoLnRyYW5zbGF0aW9uLnggKyBkaWZmWCxcbiAgICAgICAgICB5OiB0aGlzLmxhc3RUb3VjaC50cmFuc2xhdGlvbi55ICsgZGlmZllcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25uZWN0IHRoZSBuZXcgZWRnZSB0byB0aGUgdGFyZ2V0IGlmIG9uZSBleGlzdHMsIG90aGVyd2lzZSByZW1vdmUgdGVtcCBsaW5lXG4gICAgICogQHBhcmFtIHtFdmVudH0gIGV2ZW50ICAgVGhlIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2ZpbmlzaENvbm5lY3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZmluaXNoQ29ubmVjdChldmVudCkge1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcbiAgICAgIHZhciBwb2ludGVyT2JqID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9wb2ludGVyVG9Qb3NpdGlvbk9iamVjdChwb2ludGVyKTtcblxuICAgICAgLy8gcmVtZW1iZXIgdGhlIGVkZ2UgaWRcbiAgICAgIHZhciBjb25uZWN0RnJvbUlkID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKHRoaXMudGVtcG9yYXJ5SWRzLmVkZ2VzWzBdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29ubmVjdEZyb21JZCA9IHRoaXMuYm9keS5lZGdlc1t0aGlzLnRlbXBvcmFyeUlkcy5lZGdlc1swXV0uZnJvbUlkO1xuICAgICAgfVxuXG4gICAgICAvLyBnZXQgdGhlIG92ZXJsYXBwaW5nIG5vZGUgYnV0IE5PVCB0aGUgdGVtcG9yYXJ5IG5vZGU7XG4gICAgICB2YXIgb3ZlcmxhcHBpbmdOb2RlSWRzID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZXRBbGxOb2Rlc092ZXJsYXBwaW5nV2l0aChwb2ludGVyT2JqKTtcbiAgICAgIHZhciBub2RlID0gdW5kZWZpbmVkO1xuICAgICAgZm9yICh2YXIgaSA9IG92ZXJsYXBwaW5nTm9kZUlkcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAvLyBpZiB0aGUgbm9kZSBpZCBpcyBOT1QgYSB0ZW1wb3Jhcnkgbm9kZSwgYWNjZXB0IHRoZSBub2RlLlxuICAgICAgICBpZiAodGhpcy50ZW1wb3JhcnlJZHMubm9kZXMuaW5kZXhPZihvdmVybGFwcGluZ05vZGVJZHNbaV0pID09PSAtMSkge1xuICAgICAgICAgIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbb3ZlcmxhcHBpbmdOb2RlSWRzW2ldXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBjbGVhbiB0ZW1wb3Jhcnkgbm9kZXMgYW5kIGVkZ2VzLlxuICAgICAgdGhpcy5fY2xlYW51cFRlbXBvcmFyeU5vZGVzQW5kRWRnZXMoKTtcblxuICAgICAgLy8gcGVyZm9ybSB0aGUgY29ubmVjdGlvblxuICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAobm9kZS5pc0NsdXN0ZXIgPT09IHRydWUpIHtcbiAgICAgICAgICBhbGVydCh0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXVsnY3JlYXRlRWRnZUVycm9yJ10gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbJ2VuJ11bJ2NyZWF0ZUVkZ2VFcnJvciddKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW2Nvbm5lY3RGcm9tSWRdICE9PSB1bmRlZmluZWQgJiYgdGhpcy5ib2R5Lm5vZGVzW25vZGUuaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3BlcmZvcm1BZGRFZGdlKGNvbm5lY3RGcm9tSWQsIG5vZGUuaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBldmVudC5jb250cm9sRWRnZSA9IHsgZnJvbTogY29ubmVjdEZyb21JZCwgdG86IG5vZGUgPyBub2RlLmlkIDogdW5kZWZpbmVkIH07XG4gICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dlbmVyYXRlQ2xpY2tFdmVudCgnY29udHJvbE5vZGVEcmFnRW5kJywgZXZlbnQsIHBvaW50ZXIpO1xuXG4gICAgICAvLyBObyBuZWVkIHRvIGRvIF9nZW5lcmF0ZWNsaWNrZXZlbnQoJ2RyYWdFbmQnKSBoZXJlLCB0aGUgcmVndWxhciBkcmFnRW5kIGV2ZW50IGZpcmVzLlxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX3JlZHJhdycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZHJhZ1N0YXJ0RWRnZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmFnU3RhcnRFZGdlKGV2ZW50KSB7XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMubGFzdFRvdWNoO1xuICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZW5lcmF0ZUNsaWNrRXZlbnQoJ2RyYWdTdGFydCcsIGV2ZW50LCBwb2ludGVyLCB1bmRlZmluZWQsIHRydWUpO1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFTkQgT0YgQUREIEVER0UgRlVOQ1RJT05TIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFBlcmZvcm1pbmcgYWxsIHRoZSBhY3R1YWwgZGF0YSBtYW5pcHVsYXRpb24gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLy9cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBub2RlIG9uIHRoZSBzcGVjaWZpZWQgbG9jYXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjbGlja0RhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfcGVyZm9ybUFkZE5vZGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGVyZm9ybUFkZE5vZGUoY2xpY2tEYXRhKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdmFyIGRlZmF1bHREYXRhID0ge1xuICAgICAgICBpZDogdXRpbC5yYW5kb21VVUlEKCksXG4gICAgICAgIHg6IGNsaWNrRGF0YS5wb2ludGVyLmNhbnZhcy54LFxuICAgICAgICB5OiBjbGlja0RhdGEucG9pbnRlci5jYW52YXMueSxcbiAgICAgICAgbGFiZWw6ICduZXcnXG4gICAgICB9O1xuXG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5hZGROb2RlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWRkTm9kZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuYWRkTm9kZShkZWZhdWx0RGF0YSwgZnVuY3Rpb24gKGZpbmFsaXplZERhdGEpIHtcbiAgICAgICAgICAgIGlmIChmaW5hbGl6ZWREYXRhICE9PSBudWxsICYmIGZpbmFsaXplZERhdGEgIT09IHVuZGVmaW5lZCAmJiBfdGhpczQuaW5Nb2RlID09PSAnYWRkTm9kZScpIHtcbiAgICAgICAgICAgICAgLy8gaWYgZm9yIHdoYXRldmVyIHJlYXNvbiB0aGUgbW9kZSBoYXMgY2hhbmdlcyAoZHVlIHRvIGRhdGFzZXQgY2hhbmdlKSBkaXNyZWdhcmQgdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICAgIF90aGlzNC5ib2R5LmRhdGEubm9kZXMuZ2V0RGF0YVNldCgpLmFkZChmaW5hbGl6ZWREYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzNC5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZnVuY3Rpb24gZm9yIGFkZCBkb2VzIG5vdCBzdXBwb3J0IHR3byBhcmd1bWVudHMgKGRhdGEsY2FsbGJhY2spJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYm9keS5kYXRhLm5vZGVzLmdldERhdGFTZXQoKS5hZGQoZGVmYXVsdERhdGEpO1xuICAgICAgICB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjb25uZWN0IHR3byBub2RlcyB3aXRoIGEgbmV3IGVkZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IHNvdXJjZU5vZGVJZFxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gdGFyZ2V0Tm9kZUlkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3BlcmZvcm1BZGRFZGdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BlcmZvcm1BZGRFZGdlKHNvdXJjZU5vZGVJZCwgdGFyZ2V0Tm9kZUlkKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgdmFyIGRlZmF1bHREYXRhID0geyBmcm9tOiBzb3VyY2VOb2RlSWQsIHRvOiB0YXJnZXROb2RlSWQgfTtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmFkZEVkZ2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hZGRFZGdlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5hZGRFZGdlKGRlZmF1bHREYXRhLCBmdW5jdGlvbiAoZmluYWxpemVkRGF0YSkge1xuICAgICAgICAgICAgaWYgKGZpbmFsaXplZERhdGEgIT09IG51bGwgJiYgZmluYWxpemVkRGF0YSAhPT0gdW5kZWZpbmVkICYmIF90aGlzNS5pbk1vZGUgPT09ICdhZGRFZGdlJykge1xuICAgICAgICAgICAgICAvLyBpZiBmb3Igd2hhdGV2ZXIgcmVhc29uIHRoZSBtb2RlIGhhcyBjaGFuZ2VzIChkdWUgdG8gZGF0YXNldCBjaGFuZ2UpIGRpc3JlZ2FyZCB0aGUgY2FsbGJhY2tcbiAgICAgICAgICAgICAgX3RoaXM1LmJvZHkuZGF0YS5lZGdlcy5nZXREYXRhU2V0KCkuYWRkKGZpbmFsaXplZERhdGEpO1xuICAgICAgICAgICAgICBfdGhpczUuc2VsZWN0aW9uSGFuZGxlci51bnNlbGVjdEFsbCgpO1xuICAgICAgICAgICAgICBfdGhpczUuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGZ1bmN0aW9uIGZvciBjb25uZWN0IGRvZXMgbm90IHN1cHBvcnQgdHdvIGFyZ3VtZW50cyAoZGF0YSxjYWxsYmFjayknKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ib2R5LmRhdGEuZWRnZXMuZ2V0RGF0YVNldCgpLmFkZChkZWZhdWx0RGF0YSk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci51bnNlbGVjdEFsbCgpO1xuICAgICAgICB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjb25uZWN0IHR3byBub2RlcyB3aXRoIGEgbmV3IGVkZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IHNvdXJjZU5vZGVJZFxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gdGFyZ2V0Tm9kZUlkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3BlcmZvcm1FZGl0RWRnZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wZXJmb3JtRWRpdEVkZ2Uoc291cmNlTm9kZUlkLCB0YXJnZXROb2RlSWQpIHtcbiAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICB2YXIgZGVmYXVsdERhdGEgPSB7XG4gICAgICAgIGlkOiB0aGlzLmVkZ2VCZWluZ0VkaXRlZElkLFxuICAgICAgICBmcm9tOiBzb3VyY2VOb2RlSWQsXG4gICAgICAgIHRvOiB0YXJnZXROb2RlSWQsXG4gICAgICAgIGxhYmVsOiB0aGlzLmJvZHkuZGF0YS5lZGdlcy5fZGF0YVt0aGlzLmVkZ2VCZWluZ0VkaXRlZElkXS5sYWJlbFxuICAgICAgfTtcbiAgICAgIHZhciBlZUZ1bmN0ID0gdGhpcy5vcHRpb25zLmVkaXRFZGdlO1xuICAgICAgaWYgKCh0eXBlb2YgZWVGdW5jdCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6ICgwLCBfdHlwZW9mM1snZGVmYXVsdCddKShlZUZ1bmN0KSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGVlRnVuY3QgPSBlZUZ1bmN0LmVkaXRXaXRob3V0RHJhZztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZWVGdW5jdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAoZWVGdW5jdC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICBlZUZ1bmN0KGRlZmF1bHREYXRhLCBmdW5jdGlvbiAoZmluYWxpemVkRGF0YSkge1xuICAgICAgICAgICAgaWYgKGZpbmFsaXplZERhdGEgPT09IG51bGwgfHwgZmluYWxpemVkRGF0YSA9PT0gdW5kZWZpbmVkIHx8IF90aGlzNi5pbk1vZGUgIT09ICdlZGl0RWRnZScpIHtcbiAgICAgICAgICAgICAgLy8gaWYgZm9yIHdoYXRldmVyIHJlYXNvbiB0aGUgbW9kZSBoYXMgY2hhbmdlcyAoZHVlIHRvIGRhdGFzZXQgY2hhbmdlKSBkaXNyZWdhcmQgdGhlIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIF90aGlzNi5ib2R5LmVkZ2VzW2RlZmF1bHREYXRhLmlkXS51cGRhdGVFZGdlVHlwZSgpO1xuICAgICAgICAgICAgICBfdGhpczYuYm9keS5lbWl0dGVyLmVtaXQoJ19yZWRyYXcnKTtcbiAgICAgICAgICAgICAgX3RoaXM2LnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIF90aGlzNi5ib2R5LmRhdGEuZWRnZXMuZ2V0RGF0YVNldCgpLnVwZGF0ZShmaW5hbGl6ZWREYXRhKTtcbiAgICAgICAgICAgICAgX3RoaXM2LnNlbGVjdGlvbkhhbmRsZXIudW5zZWxlY3RBbGwoKTtcbiAgICAgICAgICAgICAgX3RoaXM2LnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBmdW5jdGlvbiBmb3IgZWRpdCBkb2VzIG5vdCBzdXBwb3J0IHR3byBhcmd1bWVudHMgKGRhdGEsIGNhbGxiYWNrKScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJvZHkuZGF0YS5lZGdlcy5nZXREYXRhU2V0KCkudXBkYXRlKGRlZmF1bHREYXRhKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnVuc2VsZWN0QWxsKCk7XG4gICAgICAgIHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTWFuaXB1bGF0aW9uU3lzdGVtO1xufSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBNYW5pcHVsYXRpb25TeXN0ZW07XG5cbi8qKiovIH0pLFxuLyogMTkxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfc3RyaW5naWZ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG5cbnZhciBfc3RyaW5naWZ5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N0cmluZ2lmeSk7XG5cbnZhciBfdHlwZW9mMiA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbnZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgQ29sb3JQaWNrZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5MilbJ2RlZmF1bHQnXTtcblxuLyoqXG4gKiBUaGUgd2F5IHRoaXMgd29ya3MgaXMgZm9yIGFsbCBwcm9wZXJ0aWVzIG9mIHRoaXMucG9zc2libGUgb3B0aW9ucywgeW91IGNhbiBzdXBwbHkgdGhlIHByb3BlcnR5IG5hbWUgaW4gYW55IGZvcm0gdG8gbGlzdCB0aGUgb3B0aW9ucy5cbiAqIEJvb2xlYW4gb3B0aW9ucyBhcmUgcmVjb2duaXNlZCBhcyBCb29sZWFuXG4gKiBOdW1iZXIgb3B0aW9ucyBzaG91bGQgYmUgd3JpdHRlbiBhcyBhcnJheTogW2RlZmF1bHQgdmFsdWUsIG1pbiB2YWx1ZSwgbWF4IHZhbHVlLCBzdGVwc2l6ZV1cbiAqIENvbG9ycyBzaG91bGQgYmUgd3JpdHRlbiBhcyBhcnJheTogWydjb2xvcicsICcjZmZmZmZmJ11cbiAqIFN0cmluZ3Mgd2l0aCBzaG91bGQgYmUgd3JpdHRlbiBhcyBhcnJheTogW29wdGlvbjEsIG9wdGlvbjIsIG9wdGlvbjMsIC4uXVxuICpcbiAqIFRoZSBvcHRpb25zIGFyZSBtYXRjaGVkIHdpdGggdGhlaXIgY291bnRlcnBhcnRzIGluIGVhY2ggb2YgdGhlIG1vZHVsZXMgYW5kIHRoZSB2YWx1ZXMgdXNlZCBpbiB0aGUgY29uZmlndXJhdGlvbiBhcmVcbiAqL1xuXG52YXIgQ29uZmlndXJhdG9yID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmVudE1vZHVsZSAgICAgICAgfCB0aGUgbG9jYXRpb24gd2hlcmUgcGFyZW50TW9kdWxlLnNldE9wdGlvbnMoKSBjYW4gYmUgY2FsbGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0Q29udGFpbmVyICAgIHwgdGhlIGRlZmF1bHQgY29udGFpbmVyIG9mIHRoZSBtb2R1bGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ3VyZU9wdGlvbnMgICAgfCB0aGUgZnVsbHkgY29uZmlndXJlZCBhbmQgcHJlZGVmaW5lZCBvcHRpb25zIHNldCBmb3VuZCBpbiBhbGxPcHRpb25zLmpzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvICAgICAgICAgIHwgY2FudmFzIHBpeGVsIHJhdGlvXG4gICAqL1xuICBmdW5jdGlvbiBDb25maWd1cmF0b3IocGFyZW50TW9kdWxlLCBkZWZhdWx0Q29udGFpbmVyLCBjb25maWd1cmVPcHRpb25zKSB7XG4gICAgdmFyIHBpeGVsUmF0aW8gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDE7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgQ29uZmlndXJhdG9yKTtcblxuICAgIHRoaXMucGFyZW50ID0gcGFyZW50TW9kdWxlO1xuICAgIHRoaXMuY2hhbmdlZE9wdGlvbnMgPSBbXTtcbiAgICB0aGlzLmNvbnRhaW5lciA9IGRlZmF1bHRDb250YWluZXI7XG4gICAgdGhpcy5hbGxvd0NyZWF0aW9uID0gZmFsc2U7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5wb3B1cENvdW50ZXIgPSAwO1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIGZpbHRlcjogdHJ1ZSxcbiAgICAgIGNvbnRhaW5lcjogdW5kZWZpbmVkLFxuICAgICAgc2hvd0J1dHRvbjogdHJ1ZVxuICAgIH07XG4gICAgdXRpbC5leHRlbmQodGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICAgIHRoaXMuY29uZmlndXJlT3B0aW9ucyA9IGNvbmZpZ3VyZU9wdGlvbnM7XG4gICAgdGhpcy5tb2R1bGVPcHRpb25zID0ge307XG4gICAgdGhpcy5kb21FbGVtZW50cyA9IFtdO1xuICAgIHRoaXMucG9wdXBEaXYgPSB7fTtcbiAgICB0aGlzLnBvcHVwTGltaXQgPSA1O1xuICAgIHRoaXMucG9wdXBIaXN0b3J5ID0ge307XG4gICAgdGhpcy5jb2xvclBpY2tlciA9IG5ldyBDb2xvclBpY2tlcihwaXhlbFJhdGlvKTtcbiAgICB0aGlzLndyYXBwZXIgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogcmVmcmVzaCBhbGwgb3B0aW9ucy5cbiAgICogQmVjYXVzZSBhbGwgbW9kdWxlcyBwYXJzZSB0aGVpciBvcHRpb25zIGJ5IHRoZW1zZWx2ZXMsIHdlIGp1c3QgdXNlIHRoZWlyIG9wdGlvbnMuIFdlIGNvcHkgdGhlbSBoZXJlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKENvbmZpZ3VyYXRvciwgW3tcbiAgICBrZXk6ICdzZXRPcHRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHJlc2V0IHRoZSBwb3B1cCBoaXN0b3J5IGJlY2F1c2UgdGhlIGluZGljZXMgbWF5IGhhdmUgYmVlbiBjaGFuZ2VkLlxuICAgICAgICB0aGlzLnBvcHVwSGlzdG9yeSA9IHt9O1xuICAgICAgICB0aGlzLl9yZW1vdmVQb3B1cCgpO1xuXG4gICAgICAgIHZhciBlbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5maWx0ZXIgPSBvcHRpb25zO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5maWx0ZXIgPSBvcHRpb25zLmpvaW4oKTtcbiAgICAgICAgfSBlbHNlIGlmICgodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiAoMCwgX3R5cGVvZjNbJ2RlZmF1bHQnXSkob3B0aW9ucykpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMgY2Fubm90IGJlIG51bGwnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wdGlvbnMuY29udGFpbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5jb250YWluZXIgPSBvcHRpb25zLmNvbnRhaW5lcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wdGlvbnMuZmlsdGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5maWx0ZXIgPSBvcHRpb25zLmZpbHRlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wdGlvbnMuc2hvd0J1dHRvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuc2hvd0J1dHRvbiA9IG9wdGlvbnMuc2hvd0J1dHRvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wdGlvbnMuZW5hYmxlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlbmFibGVkID0gb3B0aW9ucy5lbmFibGVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmZpbHRlciA9IHRydWU7XG4gICAgICAgICAgZW5hYmxlZCA9IG9wdGlvbnM7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuZmlsdGVyID0gb3B0aW9ucztcbiAgICAgICAgICBlbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmZpbHRlciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBlbmFibGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9wdGlvbnMuZW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgICB9XG4gICAgICB0aGlzLl9jbGVhbigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZU9wdGlvbnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0TW9kdWxlT3B0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE1vZHVsZU9wdGlvbnMobW9kdWxlT3B0aW9ucykge1xuICAgICAgdGhpcy5tb2R1bGVPcHRpb25zID0gbW9kdWxlT3B0aW9ucztcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLl9jbGVhbigpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNvbnRhaW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5jb250YWluZXIgPSB0aGlzLm9wdGlvbnMuY29udGFpbmVyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NyZWF0ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbGwgRE9NIGVsZW1lbnRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2NyZWF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGUoKSB7XG4gICAgICB0aGlzLl9jbGVhbigpO1xuICAgICAgdGhpcy5jaGFuZ2VkT3B0aW9ucyA9IFtdO1xuXG4gICAgICB2YXIgZmlsdGVyID0gdGhpcy5vcHRpb25zLmZpbHRlcjtcbiAgICAgIHZhciBjb3VudGVyID0gMDtcbiAgICAgIHZhciBzaG93ID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBvcHRpb24gaW4gdGhpcy5jb25maWd1cmVPcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyZU9wdGlvbnMuaGFzT3duUHJvcGVydHkob3B0aW9uKSkge1xuICAgICAgICAgIHRoaXMuYWxsb3dDcmVhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgIHNob3cgPSBmYWxzZTtcbiAgICAgICAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc2hvdyA9IGZpbHRlcihvcHRpb24sIFtdKTtcbiAgICAgICAgICAgIHNob3cgPSBzaG93IHx8IHRoaXMuX2hhbmRsZU9iamVjdCh0aGlzLmNvbmZpZ3VyZU9wdGlvbnNbb3B0aW9uXSwgW29wdGlvbl0sIHRydWUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZmlsdGVyID09PSB0cnVlIHx8IGZpbHRlci5pbmRleE9mKG9wdGlvbikgIT09IC0xKSB7XG4gICAgICAgICAgICBzaG93ID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2hvdyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuYWxsb3dDcmVhdGlvbiA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIGxpbmVicmVhayBiZXR3ZWVuIGNhdGVnb3JpZXNcbiAgICAgICAgICAgIGlmIChjb3VudGVyID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLl9tYWtlSXRlbShbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhIGhlYWRlciBmb3IgdGhlIGNhdGVnb3J5XG4gICAgICAgICAgICB0aGlzLl9tYWtlSGVhZGVyKG9wdGlvbik7XG5cbiAgICAgICAgICAgIC8vIGdldCB0aGUgc3ViIG9wdGlvbnNcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZU9iamVjdCh0aGlzLmNvbmZpZ3VyZU9wdGlvbnNbb3B0aW9uXSwgW29wdGlvbl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb3VudGVyKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX21ha2VCdXR0b24oKTtcbiAgICAgIHRoaXMuX3B1c2goKTtcbiAgICAgIC8vfiB0aGlzLmNvbG9yUGlja2VyLmluc2VydFRvKHRoaXMuY29udGFpbmVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBkcmF3IGFsbCBET00gZWxlbWVudHMgb24gdGhlIHNjcmVlblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19wdXNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3B1c2goKSB7XG4gICAgICB0aGlzLndyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMud3JhcHBlci5jbGFzc05hbWUgPSAndmlzLWNvbmZpZ3VyYXRpb24td3JhcHBlcic7XG4gICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLndyYXBwZXIpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRvbUVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLmRvbUVsZW1lbnRzW2ldKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2hvd1BvcHVwSWZOZWVkZWQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBkZWxldGUgYWxsIERPTSBlbGVtZW50c1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19jbGVhbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jbGVhbigpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kb21FbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndyYXBwZXIucmVtb3ZlQ2hpbGQodGhpcy5kb21FbGVtZW50c1tpXSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLndyYXBwZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLndyYXBwZXIpO1xuICAgICAgICB0aGlzLndyYXBwZXIgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB0aGlzLmRvbUVsZW1lbnRzID0gW107XG5cbiAgICAgIHRoaXMuX3JlbW92ZVBvcHVwKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBhY3R1YWxPcHRpb25zIGlmIGl0IGV4aXN0c1xuICAgICAqIEBwYXJhbSB7YXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19nZXRWYWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRWYWx1ZShwYXRoKSB7XG4gICAgICB2YXIgYmFzZSA9IHRoaXMubW9kdWxlT3B0aW9ucztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYmFzZVtwYXRoW2ldXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYmFzZSA9IGJhc2VbcGF0aFtpXV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmFzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYWxsIG9wdGlvbiBlbGVtZW50cyBhcmUgd3JhcHBlZCBpbiBhbiBpdGVtXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheS48RWxlbWVudD59IGRvbUVsZW1lbnRzXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfbWFrZUl0ZW0nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFrZUl0ZW0ocGF0aCkge1xuICAgICAgaWYgKHRoaXMuYWxsb3dDcmVhdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgaXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBpdGVtLmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWl0ZW0gdmlzLWNvbmZpZy1zJyArIHBhdGgubGVuZ3RoO1xuXG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBkb21FbGVtZW50cyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICBkb21FbGVtZW50c1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cblxuICAgICAgICBkb21FbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgaXRlbS5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudHMucHVzaChpdGVtKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9tRWxlbWVudHMubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaGVhZGVyIGZvciBtYWpvciBzdWJqZWN0c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX21ha2VIZWFkZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFrZUhlYWRlcihuYW1lKSB7XG4gICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkaXYuY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctaGVhZGVyJztcbiAgICAgIGRpdi5pbm5lckhUTUwgPSBuYW1lO1xuICAgICAgdGhpcy5fbWFrZUl0ZW0oW10sIGRpdik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbWFrZSBhIGxhYmVsLCBpZiBpdCBpcyBhbiBvYmplY3QgbGFiZWwsIGl0IGdldHMgZGlmZmVyZW50IHN0eWxpbmcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBwYXRoICAgIHwgd2hlcmUgdG8gbG9vayBmb3IgdGhlIGFjdHVhbCBvcHRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb2JqZWN0TGFiZWxcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX21ha2VMYWJlbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlTGFiZWwobmFtZSwgcGF0aCkge1xuICAgICAgdmFyIG9iamVjdExhYmVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZGl2LmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWxhYmVsIHZpcy1jb25maWctcycgKyBwYXRoLmxlbmd0aDtcbiAgICAgIGlmIChvYmplY3RMYWJlbCA9PT0gdHJ1ZSkge1xuICAgICAgICBkaXYuaW5uZXJIVE1MID0gJzxpPjxiPicgKyBuYW1lICsgJzo8L2I+PC9pPic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXYuaW5uZXJIVE1MID0gbmFtZSArICc6JztcbiAgICAgIH1cbiAgICAgIHJldHVybiBkaXY7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbWFrZSBhIGRyb3Bkb3duIGxpc3QgZm9yIG11bHRpcGxlIHBvc3NpYmxlIHN0cmluZyBvcHRvaW5zXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYXJyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHthcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX21ha2VEcm9wZG93bicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlRHJvcGRvd24oYXJyLCB2YWx1ZSwgcGF0aCkge1xuICAgICAgdmFyIHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NlbGVjdCcpO1xuICAgICAgc2VsZWN0LmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLXNlbGVjdCc7XG4gICAgICB2YXIgc2VsZWN0ZWRWYWx1ZSA9IDA7XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYXJyLmluZGV4T2YodmFsdWUpICE9PSAtMSkge1xuICAgICAgICAgIHNlbGVjdGVkVmFsdWUgPSBhcnIuaW5kZXhPZih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG9wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgICAgICBvcHRpb24udmFsdWUgPSBhcnJbaV07XG4gICAgICAgIGlmIChpID09PSBzZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gJ3NlbGVjdGVkJztcbiAgICAgICAgfVxuICAgICAgICBvcHRpb24uaW5uZXJIVE1MID0gYXJyW2ldO1xuICAgICAgICBzZWxlY3QuYXBwZW5kQ2hpbGQob3B0aW9uKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIHNlbGVjdC5vbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbWUuX3VwZGF0ZSh0aGlzLnZhbHVlLCBwYXRoKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBsYWJlbCA9IHRoaXMuX21ha2VMYWJlbChwYXRoW3BhdGgubGVuZ3RoIC0gMV0sIHBhdGgpO1xuICAgICAgdGhpcy5fbWFrZUl0ZW0ocGF0aCwgbGFiZWwsIHNlbGVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbWFrZSBhIHJhbmdlIG9iamVjdCBmb3IgbnVtZXJpYyBvcHRpb25zXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYXJyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHthcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX21ha2VSYW5nZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlUmFuZ2UoYXJyLCB2YWx1ZSwgcGF0aCkge1xuICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IGFyclswXTtcbiAgICAgIHZhciBtaW4gPSBhcnJbMV07XG4gICAgICB2YXIgbWF4ID0gYXJyWzJdO1xuICAgICAgdmFyIHN0ZXAgPSBhcnJbM107XG4gICAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgcmFuZ2UuY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctcmFuZ2UnO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmFuZ2UudHlwZSA9ICdyYW5nZSc7IC8vIG5vdCBzdXBwb3J0ZWQgb24gSUU5XG4gICAgICAgIHJhbmdlLm1pbiA9IG1pbjtcbiAgICAgICAgcmFuZ2UubWF4ID0gbWF4O1xuICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgLy8gVE9ETzogQWRkIHNvbWUgZXJyb3IgaGFuZGxpbmcgYW5kIHJlbW92ZSB0aGlzIGxpbnQgZXhjZXB0aW9uXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5XG4gICAgICByYW5nZS5zdGVwID0gc3RlcDtcblxuICAgICAgLy8gc2V0IHVwIHRoZSBwb3B1cCBzZXR0aW5ncyBpbiBjYXNlIHRoZXkgYXJlIG5lZWRlZC5cbiAgICAgIHZhciBwb3B1cFN0cmluZyA9ICcnO1xuICAgICAgdmFyIHBvcHVwVmFsdWUgPSAwO1xuXG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgZmFjdG9yID0gMS4yO1xuICAgICAgICBpZiAodmFsdWUgPCAwICYmIHZhbHVlICogZmFjdG9yIDwgbWluKSB7XG4gICAgICAgICAgcmFuZ2UubWluID0gTWF0aC5jZWlsKHZhbHVlICogZmFjdG9yKTtcbiAgICAgICAgICBwb3B1cFZhbHVlID0gcmFuZ2UubWluO1xuICAgICAgICAgIHBvcHVwU3RyaW5nID0gJ3JhbmdlIGluY3JlYXNlZCc7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgLyBmYWN0b3IgPCBtaW4pIHtcbiAgICAgICAgICByYW5nZS5taW4gPSBNYXRoLmNlaWwodmFsdWUgLyBmYWN0b3IpO1xuICAgICAgICAgIHBvcHVwVmFsdWUgPSByYW5nZS5taW47XG4gICAgICAgICAgcG9wdXBTdHJpbmcgPSAncmFuZ2UgaW5jcmVhc2VkJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgKiBmYWN0b3IgPiBtYXggJiYgbWF4ICE9PSAxKSB7XG4gICAgICAgICAgcmFuZ2UubWF4ID0gTWF0aC5jZWlsKHZhbHVlICogZmFjdG9yKTtcbiAgICAgICAgICBwb3B1cFZhbHVlID0gcmFuZ2UubWF4O1xuICAgICAgICAgIHBvcHVwU3RyaW5nID0gJ3JhbmdlIGluY3JlYXNlZCc7XG4gICAgICAgIH1cbiAgICAgICAgcmFuZ2UudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhbmdlLnZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgaW5wdXQuY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctcmFuZ2VpbnB1dCc7XG4gICAgICBpbnB1dC52YWx1ZSA9IHJhbmdlLnZhbHVlO1xuXG4gICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgcmFuZ2Uub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlucHV0LnZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgbWUuX3VwZGF0ZShOdW1iZXIodGhpcy52YWx1ZSksIHBhdGgpO1xuICAgICAgfTtcbiAgICAgIHJhbmdlLm9uaW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlucHV0LnZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBsYWJlbCA9IHRoaXMuX21ha2VMYWJlbChwYXRoW3BhdGgubGVuZ3RoIC0gMV0sIHBhdGgpO1xuICAgICAgdmFyIGl0ZW1JbmRleCA9IHRoaXMuX21ha2VJdGVtKHBhdGgsIGxhYmVsLCByYW5nZSwgaW5wdXQpO1xuXG4gICAgICAvLyBpZiBhIHBvcHVwIGlzIG5lZWRlZCBBTkQgaXQgaGFzIG5vdCBiZWVuIHNob3duIGZvciB0aGlzIHZhbHVlLCBzaG93IGl0LlxuICAgICAgaWYgKHBvcHVwU3RyaW5nICE9PSAnJyAmJiB0aGlzLnBvcHVwSGlzdG9yeVtpdGVtSW5kZXhdICE9PSBwb3B1cFZhbHVlKSB7XG4gICAgICAgIHRoaXMucG9wdXBIaXN0b3J5W2l0ZW1JbmRleF0gPSBwb3B1cFZhbHVlO1xuICAgICAgICB0aGlzLl9zZXR1cFBvcHVwKHBvcHVwU3RyaW5nLCBpdGVtSW5kZXgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG1ha2UgYSBidXR0b24gb2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX21ha2VCdXR0b24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFrZUJ1dHRvbigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd0J1dHRvbiA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgZ2VuZXJhdGVCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZ2VuZXJhdGVCdXR0b24uY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctYnV0dG9uJztcbiAgICAgICAgZ2VuZXJhdGVCdXR0b24uaW5uZXJIVE1MID0gJ2dlbmVyYXRlIG9wdGlvbnMnO1xuICAgICAgICBnZW5lcmF0ZUJ1dHRvbi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLl9wcmludE9wdGlvbnMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgZ2VuZXJhdGVCdXR0b24ub25tb3VzZW92ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZ2VuZXJhdGVCdXR0b24uY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctYnV0dG9uIGhvdmVyJztcbiAgICAgICAgfTtcbiAgICAgICAgZ2VuZXJhdGVCdXR0b24ub25tb3VzZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBnZW5lcmF0ZUJ1dHRvbi5jbGFzc05hbWUgPSAndmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1idXR0b24nO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMub3B0aW9uc0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLm9wdGlvbnNDb250YWluZXIuY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctb3B0aW9uLWNvbnRhaW5lcic7XG5cbiAgICAgICAgdGhpcy5kb21FbGVtZW50cy5wdXNoKHRoaXMub3B0aW9uc0NvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudHMucHVzaChnZW5lcmF0ZUJ1dHRvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcHJlcGFyZSB0aGUgcG9wdXBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3NldHVwUG9wdXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXBQb3B1cChzdHJpbmcsIGluZGV4KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6ZWQgPT09IHRydWUgJiYgdGhpcy5hbGxvd0NyZWF0aW9uID09PSB0cnVlICYmIHRoaXMucG9wdXBDb3VudGVyIDwgdGhpcy5wb3B1cExpbWl0KSB7XG4gICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZGl2LmlkID0gJ3Zpcy1jb25maWd1cmF0aW9uLXBvcHVwJztcbiAgICAgICAgZGl2LmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbi1wb3B1cCc7XG4gICAgICAgIGRpdi5pbm5lckhUTUwgPSBzdHJpbmc7XG4gICAgICAgIGRpdi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMi5fcmVtb3ZlUG9wdXAoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wb3B1cENvdW50ZXIgKz0gMTtcbiAgICAgICAgdGhpcy5wb3B1cERpdiA9IHsgaHRtbDogZGl2LCBpbmRleDogaW5kZXggfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZW1vdmUgdGhlIHBvcHVwIGZyb20gdGhlIGRvbVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19yZW1vdmVQb3B1cCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVQb3B1cCgpIHtcbiAgICAgIGlmICh0aGlzLnBvcHVwRGl2Lmh0bWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnBvcHVwRGl2Lmh0bWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnBvcHVwRGl2Lmh0bWwpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5wb3B1cERpdi5oaWRlVGltZW91dCk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBvcHVwRGl2LmRlbGV0ZVRpbWVvdXQpO1xuICAgICAgICB0aGlzLnBvcHVwRGl2ID0ge307XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2hvdyB0aGUgcG9wdXAgaWYgaXQgaXMgbmVlZGVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19zaG93UG9wdXBJZk5lZWRlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zaG93UG9wdXBJZk5lZWRlZCgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5wb3B1cERpdi5odG1sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGNvcnJlc3BvbmRpbmdFbGVtZW50ID0gdGhpcy5kb21FbGVtZW50c1t0aGlzLnBvcHVwRGl2LmluZGV4XTtcbiAgICAgICAgdmFyIHJlY3QgPSBjb3JyZXNwb25kaW5nRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdGhpcy5wb3B1cERpdi5odG1sLnN0eWxlLmxlZnQgPSByZWN0LmxlZnQgKyAncHgnO1xuICAgICAgICB0aGlzLnBvcHVwRGl2Lmh0bWwuc3R5bGUudG9wID0gcmVjdC50b3AgLSAzMCArICdweCc7IC8vIDMwIGlzIHRoZSBoZWlnaHQ7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5wb3B1cERpdi5odG1sKTtcbiAgICAgICAgdGhpcy5wb3B1cERpdi5oaWRlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMy5wb3B1cERpdi5odG1sLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgICB9LCAxNTAwKTtcbiAgICAgICAgdGhpcy5wb3B1cERpdi5kZWxldGVUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMzLl9yZW1vdmVQb3B1cCgpO1xuICAgICAgICB9LCAxODAwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBtYWtlIGEgY2hlY2tib3ggZm9yIGJvb2xlYW4gb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVmYXVsdFZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHthcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX21ha2VDaGVja2JveCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlQ2hlY2tib3goZGVmYXVsdFZhbHVlLCB2YWx1ZSwgcGF0aCkge1xuICAgICAgdmFyIGNoZWNrYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgIGNoZWNrYm94LnR5cGUgPSAnY2hlY2tib3gnO1xuICAgICAgY2hlY2tib3guY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctY2hlY2tib3gnO1xuICAgICAgY2hlY2tib3guY2hlY2tlZCA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNoZWNrYm94LmNoZWNrZWQgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICBpZiAoKHR5cGVvZiBkZWZhdWx0VmFsdWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiAoMCwgX3R5cGVvZjNbJ2RlZmF1bHQnXSkoZGVmYXVsdFZhbHVlKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IGRlZmF1bHRWYWx1ZS5lbmFibGVkKSB7XG4gICAgICAgICAgICAgIHRoaXMuY2hhbmdlZE9wdGlvbnMucHVzaCh7IHBhdGg6IHBhdGgsIHZhbHVlOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VkT3B0aW9ucy5wdXNoKHsgcGF0aDogcGF0aCwgdmFsdWU6IHZhbHVlIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgY2hlY2tib3gub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1lLl91cGRhdGUodGhpcy5jaGVja2VkLCBwYXRoKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBsYWJlbCA9IHRoaXMuX21ha2VMYWJlbChwYXRoW3BhdGgubGVuZ3RoIC0gMV0sIHBhdGgpO1xuICAgICAgdGhpcy5fbWFrZUl0ZW0ocGF0aCwgbGFiZWwsIGNoZWNrYm94KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBtYWtlIGEgdGV4dCBpbnB1dCBmaWVsZCBmb3Igc3RyaW5nIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlZmF1bHRWYWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7YXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19tYWtlVGV4dElucHV0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VUZXh0SW5wdXQoZGVmYXVsdFZhbHVlLCB2YWx1ZSwgcGF0aCkge1xuICAgICAgdmFyIGNoZWNrYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgIGNoZWNrYm94LnR5cGUgPSAndGV4dCc7XG4gICAgICBjaGVja2JveC5jbGFzc05hbWUgPSAndmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy10ZXh0JztcbiAgICAgIGNoZWNrYm94LnZhbHVlID0gdmFsdWU7XG4gICAgICBpZiAodmFsdWUgIT09IGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICB0aGlzLmNoYW5nZWRPcHRpb25zLnB1c2goeyBwYXRoOiBwYXRoLCB2YWx1ZTogdmFsdWUgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICBjaGVja2JveC5vbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbWUuX3VwZGF0ZSh0aGlzLnZhbHVlLCBwYXRoKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBsYWJlbCA9IHRoaXMuX21ha2VMYWJlbChwYXRoW3BhdGgubGVuZ3RoIC0gMV0sIHBhdGgpO1xuICAgICAgdGhpcy5fbWFrZUl0ZW0ocGF0aCwgbGFiZWwsIGNoZWNrYm94KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBtYWtlIGEgY29sb3IgZmllbGQgd2l0aCBhIGNvbG9yIHBpY2tlciBmb3IgY29sb3IgZmllbGRzXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYXJyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHthcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX21ha2VDb2xvckZpZWxkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VDb2xvckZpZWxkKGFyciwgdmFsdWUsIHBhdGgpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB2YXIgZGVmYXVsdENvbG9yID0gYXJyWzFdO1xuICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdENvbG9yIDogdmFsdWU7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gJ25vbmUnKSB7XG4gICAgICAgIGRpdi5jbGFzc05hbWUgPSAndmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1jb2xvckJsb2NrJztcbiAgICAgICAgZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGl2LmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWNvbG9yQmxvY2sgbm9uZSc7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlID0gdmFsdWUgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRDb2xvciA6IHZhbHVlO1xuICAgICAgZGl2Lm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzNC5fc2hvd0NvbG9yUGlja2VyKHZhbHVlLCBkaXYsIHBhdGgpO1xuICAgICAgfTtcblxuICAgICAgdmFyIGxhYmVsID0gdGhpcy5fbWFrZUxhYmVsKHBhdGhbcGF0aC5sZW5ndGggLSAxXSwgcGF0aCk7XG4gICAgICB0aGlzLl9tYWtlSXRlbShwYXRoLCBsYWJlbCwgZGl2KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB1c2VkIGJ5IHRoZSBjb2xvciBidXR0b25zIHRvIGNhbGwgdGhlIGNvbG9yIHBpY2tlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkaXZcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBwYXRoICAgIHwgd2hlcmUgdG8gbG9vayBmb3IgdGhlIGFjdHVhbCBvcHRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfc2hvd0NvbG9yUGlja2VyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Nob3dDb2xvclBpY2tlcih2YWx1ZSwgZGl2LCBwYXRoKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgLy8gY2xlYXIgdGhlIGNhbGxiYWNrIGZyb20gdGhpcyBkaXZcbiAgICAgIGRpdi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAgIHRoaXMuY29sb3JQaWNrZXIuaW5zZXJ0VG8oZGl2KTtcbiAgICAgIHRoaXMuY29sb3JQaWNrZXIuc2hvdygpO1xuXG4gICAgICB0aGlzLmNvbG9yUGlja2VyLnNldENvbG9yKHZhbHVlKTtcbiAgICAgIHRoaXMuY29sb3JQaWNrZXIuc2V0VXBkYXRlQ2FsbGJhY2soZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIHZhciBjb2xvclN0cmluZyA9ICdyZ2JhKCcgKyBjb2xvci5yICsgJywnICsgY29sb3IuZyArICcsJyArIGNvbG9yLmIgKyAnLCcgKyBjb2xvci5hICsgJyknO1xuICAgICAgICBkaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY29sb3JTdHJpbmc7XG4gICAgICAgIF90aGlzNS5fdXBkYXRlKGNvbG9yU3RyaW5nLCBwYXRoKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBvbiBjbG9zZSBvZiB0aGUgY29sb3JwaWNrZXIsIHJlc3RvcmUgdGhlIGNhbGxiYWNrLlxuICAgICAgdGhpcy5jb2xvclBpY2tlci5zZXRDbG9zZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGl2Lm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXM1Ll9zaG93Q29sb3JQaWNrZXIodmFsdWUsIGRpdiwgcGF0aCk7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwYXJzZSBhbiBvYmplY3QgYW5kIGRyYXcgdGhlIGNvcnJlY3QgaXRlbXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gICAgICogQHBhcmFtIHthcnJheX0gW3BhdGg9W11dICAgIHwgd2hlcmUgdG8gbG9vayBmb3IgdGhlIGFjdHVhbCBvcHRpb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjaGVja09ubHk9ZmFsc2VdXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2hhbmRsZU9iamVjdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVPYmplY3Qob2JqKSB7XG4gICAgICB2YXIgcGF0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG4gICAgICB2YXIgY2hlY2tPbmx5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICAgICAgdmFyIHNob3cgPSBmYWxzZTtcbiAgICAgIHZhciBmaWx0ZXIgPSB0aGlzLm9wdGlvbnMuZmlsdGVyO1xuICAgICAgdmFyIHZpc2libGVJblNldCA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIgc3ViT2JqIGluIG9iaikge1xuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHN1Yk9iaikpIHtcbiAgICAgICAgICBzaG93ID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgaXRlbSA9IG9ialtzdWJPYmpdO1xuICAgICAgICAgIHZhciBuZXdQYXRoID0gdXRpbC5jb3B5QW5kRXh0ZW5kQXJyYXkocGF0aCwgc3ViT2JqKTtcbiAgICAgICAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc2hvdyA9IGZpbHRlcihzdWJPYmosIHBhdGgpO1xuXG4gICAgICAgICAgICAvLyBpZiBuZWVkZWQgd2UgbXVzdCBnbyBkZWVwZXIgaW50byB0aGUgb2JqZWN0LlxuICAgICAgICAgICAgaWYgKHNob3cgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIGlmICghKGl0ZW0gaW5zdGFuY2VvZiBBcnJheSkgJiYgdHlwZW9mIGl0ZW0gIT09ICdzdHJpbmcnICYmIHR5cGVvZiBpdGVtICE9PSAnYm9vbGVhbicgJiYgaXRlbSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWxsb3dDcmVhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHNob3cgPSB0aGlzLl9oYW5kbGVPYmplY3QoaXRlbSwgbmV3UGF0aCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hbGxvd0NyZWF0aW9uID0gY2hlY2tPbmx5ID09PSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzaG93ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdmlzaWJsZUluU2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2dldFZhbHVlKG5ld1BhdGgpO1xuXG4gICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgIHRoaXMuX2hhbmRsZUFycmF5KGl0ZW0sIHZhbHVlLCBuZXdQYXRoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIHRoaXMuX21ha2VUZXh0SW5wdXQoaXRlbSwgdmFsdWUsIG5ld1BhdGgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgIHRoaXMuX21ha2VDaGVja2JveChpdGVtLCB2YWx1ZSwgbmV3UGF0aCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0gaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgICAgLy8gY29sbGFwc2UgdGhlIHBoeXNpY3Mgb3B0aW9ucyB0aGF0IGFyZSBub3QgZW5hYmxlZFxuICAgICAgICAgICAgICB2YXIgZHJhdyA9IHRydWU7XG4gICAgICAgICAgICAgIGlmIChwYXRoLmluZGV4T2YoJ3BoeXNpY3MnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tb2R1bGVPcHRpb25zLnBoeXNpY3Muc29sdmVyICE9PSBzdWJPYmopIHtcbiAgICAgICAgICAgICAgICAgIGRyYXcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoZHJhdyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIC8vIGluaXRpYWxseSBjb2xsYXBzZSBvcHRpb25zIHdpdGggYW4gZGlzYWJsZWQgZW5hYmxlZCBvcHRpb24uXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uZW5hYmxlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZW5hYmxlZFBhdGggPSB1dGlsLmNvcHlBbmRFeHRlbmRBcnJheShuZXdQYXRoLCAnZW5hYmxlZCcpO1xuICAgICAgICAgICAgICAgICAgdmFyIGVuYWJsZWRWYWx1ZSA9IHRoaXMuX2dldFZhbHVlKGVuYWJsZWRQYXRoKTtcbiAgICAgICAgICAgICAgICAgIGlmIChlbmFibGVkVmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhYmVsID0gdGhpcy5fbWFrZUxhYmVsKHN1Yk9iaiwgbmV3UGF0aCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21ha2VJdGVtKG5ld1BhdGgsIGxhYmVsKTtcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJsZUluU2V0ID0gdGhpcy5faGFuZGxlT2JqZWN0KGl0ZW0sIG5ld1BhdGgpIHx8IHZpc2libGVJblNldDtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21ha2VDaGVja2JveChpdGVtLCBlbmFibGVkVmFsdWUsIG5ld1BhdGgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX2xhYmVsID0gdGhpcy5fbWFrZUxhYmVsKHN1Yk9iaiwgbmV3UGF0aCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9tYWtlSXRlbShuZXdQYXRoLCBfbGFiZWwpO1xuICAgICAgICAgICAgICAgICAgdmlzaWJsZUluU2V0ID0gdGhpcy5faGFuZGxlT2JqZWN0KGl0ZW0sIG5ld1BhdGgpIHx8IHZpc2libGVJblNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2RvbnQga25vdyBob3cgdG8gaGFuZGxlJywgaXRlbSwgc3ViT2JqLCBuZXdQYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2aXNpYmxlSW5TZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaGFuZGxlIHRoZSBhcnJheSB0eXBlIG9mIG9wdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGFyclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7YXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19oYW5kbGVBcnJheScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVBcnJheShhcnIsIHZhbHVlLCBwYXRoKSB7XG4gICAgICBpZiAodHlwZW9mIGFyclswXSA9PT0gJ3N0cmluZycgJiYgYXJyWzBdID09PSAnY29sb3InKSB7XG4gICAgICAgIHRoaXMuX21ha2VDb2xvckZpZWxkKGFyciwgdmFsdWUsIHBhdGgpO1xuICAgICAgICBpZiAoYXJyWzFdICE9PSB2YWx1ZSkge1xuICAgICAgICAgIHRoaXMuY2hhbmdlZE9wdGlvbnMucHVzaCh7IHBhdGg6IHBhdGgsIHZhbHVlOiB2YWx1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJyWzBdID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLl9tYWtlRHJvcGRvd24oYXJyLCB2YWx1ZSwgcGF0aCk7XG4gICAgICAgIGlmIChhcnJbMF0gIT09IHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5jaGFuZ2VkT3B0aW9ucy5wdXNoKHsgcGF0aDogcGF0aCwgdmFsdWU6IHZhbHVlIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcnJbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIHRoaXMuX21ha2VSYW5nZShhcnIsIHZhbHVlLCBwYXRoKTtcbiAgICAgICAgaWYgKGFyclswXSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICB0aGlzLmNoYW5nZWRPcHRpb25zLnB1c2goeyBwYXRoOiBwYXRoLCB2YWx1ZTogTnVtYmVyKHZhbHVlKSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNhbGxlZCB0byB1cGRhdGUgdGhlIG5ldHdvcmsgd2l0aCB0aGUgbmV3IHNldHRpbmdzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7YXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ191cGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlKHZhbHVlLCBwYXRoKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuX2NvbnN0cnVjdE9wdGlvbnModmFsdWUsIHBhdGgpO1xuXG4gICAgICBpZiAodGhpcy5wYXJlbnQuYm9keSAmJiB0aGlzLnBhcmVudC5ib2R5LmVtaXR0ZXIgJiYgdGhpcy5wYXJlbnQuYm9keS5lbWl0dGVyLmVtaXQpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQuYm9keS5lbWl0dGVyLmVtaXQoJ2NvbmZpZ0NoYW5nZScsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICB0aGlzLnBhcmVudC5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBwYXRoXG4gICAgICogQHBhcmFtIHt7fX0gb3B0aW9uc09ialxuICAgICAqIEByZXR1cm5zIHt7fX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfY29uc3RydWN0T3B0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jb25zdHJ1Y3RPcHRpb25zKHZhbHVlLCBwYXRoKSB7XG4gICAgICB2YXIgb3B0aW9uc09iaiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIHZhciBwb2ludGVyID0gb3B0aW9uc09iajtcblxuICAgICAgLy8gd2hlbiBkcm9wZG93biBib3hlcyBjYW4gYmUgc3RyaW5nIG9yIGJvb2xlYW4sIHdlIHR5cGVjYXN0IGl0IGludG8gY29ycmVjdCB0eXBlc1xuICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gJ3RydWUnID8gdHJ1ZSA6IHZhbHVlO1xuICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gJ2ZhbHNlJyA/IGZhbHNlIDogdmFsdWU7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocGF0aFtpXSAhPT0gJ2dsb2JhbCcpIHtcbiAgICAgICAgICBpZiAocG9pbnRlcltwYXRoW2ldXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwb2ludGVyW3BhdGhbaV1dID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpICE9PSBwYXRoLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHBvaW50ZXIgPSBwb2ludGVyW3BhdGhbaV1dO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb2ludGVyW3BhdGhbaV1dID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb3B0aW9uc09iajtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfcHJpbnRPcHRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3ByaW50T3B0aW9ucygpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5nZXRPcHRpb25zKCk7XG4gICAgICB0aGlzLm9wdGlvbnNDb250YWluZXIuaW5uZXJIVE1MID0gJzxwcmU+dmFyIG9wdGlvbnMgPSAnICsgKDAsIF9zdHJpbmdpZnkyWydkZWZhdWx0J10pKG9wdGlvbnMsIG51bGwsIDIpICsgJzwvcHJlPic7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7e319IG9wdGlvbnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0T3B0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE9wdGlvbnMoKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoYW5nZWRPcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX2NvbnN0cnVjdE9wdGlvbnModGhpcy5jaGFuZ2VkT3B0aW9uc1tpXS52YWx1ZSwgdGhpcy5jaGFuZ2VkT3B0aW9uc1tpXS5wYXRoLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ29uZmlndXJhdG9yO1xufSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBDb25maWd1cmF0b3I7XG5cbi8qKiovIH0pLFxuLyogMTkyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfc3RyaW5naWZ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG5cbnZhciBfc3RyaW5naWZ5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N0cmluZ2lmeSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgSGFtbWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG52YXIgaGFtbWVyVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpO1xudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgaHRtbENvbG9ycyA9IHtcbiAgYmxhY2s6ICcjMDAwMDAwJyxcbiAgbmF2eTogJyMwMDAwODAnLFxuICBkYXJrYmx1ZTogJyMwMDAwOEInLFxuICBtZWRpdW1ibHVlOiAnIzAwMDBDRCcsXG4gIGJsdWU6ICcjMDAwMEZGJyxcbiAgZGFya2dyZWVuOiAnIzAwNjQwMCcsXG4gIGdyZWVuOiAnIzAwODAwMCcsXG4gIHRlYWw6ICcjMDA4MDgwJyxcbiAgZGFya2N5YW46ICcjMDA4QjhCJyxcbiAgZGVlcHNreWJsdWU6ICcjMDBCRkZGJyxcbiAgZGFya3R1cnF1b2lzZTogJyMwMENFRDEnLFxuICBtZWRpdW1zcHJpbmdncmVlbjogJyMwMEZBOUEnLFxuICBsaW1lOiAnIzAwRkYwMCcsXG4gIHNwcmluZ2dyZWVuOiAnIzAwRkY3RicsXG4gIGFxdWE6ICcjMDBGRkZGJyxcbiAgY3lhbjogJyMwMEZGRkYnLFxuICBtaWRuaWdodGJsdWU6ICcjMTkxOTcwJyxcbiAgZG9kZ2VyYmx1ZTogJyMxRTkwRkYnLFxuICBsaWdodHNlYWdyZWVuOiAnIzIwQjJBQScsXG4gIGZvcmVzdGdyZWVuOiAnIzIyOEIyMicsXG4gIHNlYWdyZWVuOiAnIzJFOEI1NycsXG4gIGRhcmtzbGF0ZWdyYXk6ICcjMkY0RjRGJyxcbiAgbGltZWdyZWVuOiAnIzMyQ0QzMicsXG4gIG1lZGl1bXNlYWdyZWVuOiAnIzNDQjM3MScsXG4gIHR1cnF1b2lzZTogJyM0MEUwRDAnLFxuICByb3lhbGJsdWU6ICcjNDE2OUUxJyxcbiAgc3RlZWxibHVlOiAnIzQ2ODJCNCcsXG4gIGRhcmtzbGF0ZWJsdWU6ICcjNDgzRDhCJyxcbiAgbWVkaXVtdHVycXVvaXNlOiAnIzQ4RDFDQycsXG4gIGluZGlnbzogJyM0QjAwODInLFxuICBkYXJrb2xpdmVncmVlbjogJyM1NTZCMkYnLFxuICBjYWRldGJsdWU6ICcjNUY5RUEwJyxcbiAgY29ybmZsb3dlcmJsdWU6ICcjNjQ5NUVEJyxcbiAgbWVkaXVtYXF1YW1hcmluZTogJyM2NkNEQUEnLFxuICBkaW1ncmF5OiAnIzY5Njk2OScsXG4gIHNsYXRlYmx1ZTogJyM2QTVBQ0QnLFxuICBvbGl2ZWRyYWI6ICcjNkI4RTIzJyxcbiAgc2xhdGVncmF5OiAnIzcwODA5MCcsXG4gIGxpZ2h0c2xhdGVncmF5OiAnIzc3ODg5OScsXG4gIG1lZGl1bXNsYXRlYmx1ZTogJyM3QjY4RUUnLFxuICBsYXduZ3JlZW46ICcjN0NGQzAwJyxcbiAgY2hhcnRyZXVzZTogJyM3RkZGMDAnLFxuICBhcXVhbWFyaW5lOiAnIzdGRkZENCcsXG4gIG1hcm9vbjogJyM4MDAwMDAnLFxuICBwdXJwbGU6ICcjODAwMDgwJyxcbiAgb2xpdmU6ICcjODA4MDAwJyxcbiAgZ3JheTogJyM4MDgwODAnLFxuICBza3libHVlOiAnIzg3Q0VFQicsXG4gIGxpZ2h0c2t5Ymx1ZTogJyM4N0NFRkEnLFxuICBibHVldmlvbGV0OiAnIzhBMkJFMicsXG4gIGRhcmtyZWQ6ICcjOEIwMDAwJyxcbiAgZGFya21hZ2VudGE6ICcjOEIwMDhCJyxcbiAgc2FkZGxlYnJvd246ICcjOEI0NTEzJyxcbiAgZGFya3NlYWdyZWVuOiAnIzhGQkM4RicsXG4gIGxpZ2h0Z3JlZW46ICcjOTBFRTkwJyxcbiAgbWVkaXVtcHVycGxlOiAnIzkzNzBEOCcsXG4gIGRhcmt2aW9sZXQ6ICcjOTQwMEQzJyxcbiAgcGFsZWdyZWVuOiAnIzk4RkI5OCcsXG4gIGRhcmtvcmNoaWQ6ICcjOTkzMkNDJyxcbiAgeWVsbG93Z3JlZW46ICcjOUFDRDMyJyxcbiAgc2llbm5hOiAnI0EwNTIyRCcsXG4gIGJyb3duOiAnI0E1MkEyQScsXG4gIGRhcmtncmF5OiAnI0E5QTlBOScsXG4gIGxpZ2h0Ymx1ZTogJyNBREQ4RTYnLFxuICBncmVlbnllbGxvdzogJyNBREZGMkYnLFxuICBwYWxldHVycXVvaXNlOiAnI0FGRUVFRScsXG4gIGxpZ2h0c3RlZWxibHVlOiAnI0IwQzRERScsXG4gIHBvd2RlcmJsdWU6ICcjQjBFMEU2JyxcbiAgZmlyZWJyaWNrOiAnI0IyMjIyMicsXG4gIGRhcmtnb2xkZW5yb2Q6ICcjQjg4NjBCJyxcbiAgbWVkaXVtb3JjaGlkOiAnI0JBNTVEMycsXG4gIHJvc3licm93bjogJyNCQzhGOEYnLFxuICBkYXJra2hha2k6ICcjQkRCNzZCJyxcbiAgc2lsdmVyOiAnI0MwQzBDMCcsXG4gIG1lZGl1bXZpb2xldHJlZDogJyNDNzE1ODUnLFxuICBpbmRpYW5yZWQ6ICcjQ0Q1QzVDJyxcbiAgcGVydTogJyNDRDg1M0YnLFxuICBjaG9jb2xhdGU6ICcjRDI2OTFFJyxcbiAgdGFuOiAnI0QyQjQ4QycsXG4gIGxpZ2h0Z3JleTogJyNEM0QzRDMnLFxuICBwYWxldmlvbGV0cmVkOiAnI0Q4NzA5MycsXG4gIHRoaXN0bGU6ICcjRDhCRkQ4JyxcbiAgb3JjaGlkOiAnI0RBNzBENicsXG4gIGdvbGRlbnJvZDogJyNEQUE1MjAnLFxuICBjcmltc29uOiAnI0RDMTQzQycsXG4gIGdhaW5zYm9ybzogJyNEQ0RDREMnLFxuICBwbHVtOiAnI0REQTBERCcsXG4gIGJ1cmx5d29vZDogJyNERUI4ODcnLFxuICBsaWdodGN5YW46ICcjRTBGRkZGJyxcbiAgbGF2ZW5kZXI6ICcjRTZFNkZBJyxcbiAgZGFya3NhbG1vbjogJyNFOTk2N0EnLFxuICB2aW9sZXQ6ICcjRUU4MkVFJyxcbiAgcGFsZWdvbGRlbnJvZDogJyNFRUU4QUEnLFxuICBsaWdodGNvcmFsOiAnI0YwODA4MCcsXG4gIGtoYWtpOiAnI0YwRTY4QycsXG4gIGFsaWNlYmx1ZTogJyNGMEY4RkYnLFxuICBob25leWRldzogJyNGMEZGRjAnLFxuICBhenVyZTogJyNGMEZGRkYnLFxuICBzYW5keWJyb3duOiAnI0Y0QTQ2MCcsXG4gIHdoZWF0OiAnI0Y1REVCMycsXG4gIGJlaWdlOiAnI0Y1RjVEQycsXG4gIHdoaXRlc21va2U6ICcjRjVGNUY1JyxcbiAgbWludGNyZWFtOiAnI0Y1RkZGQScsXG4gIGdob3N0d2hpdGU6ICcjRjhGOEZGJyxcbiAgc2FsbW9uOiAnI0ZBODA3MicsXG4gIGFudGlxdWV3aGl0ZTogJyNGQUVCRDcnLFxuICBsaW5lbjogJyNGQUYwRTYnLFxuICBsaWdodGdvbGRlbnJvZHllbGxvdzogJyNGQUZBRDInLFxuICBvbGRsYWNlOiAnI0ZERjVFNicsXG4gIHJlZDogJyNGRjAwMDAnLFxuICBmdWNoc2lhOiAnI0ZGMDBGRicsXG4gIG1hZ2VudGE6ICcjRkYwMEZGJyxcbiAgZGVlcHBpbms6ICcjRkYxNDkzJyxcbiAgb3JhbmdlcmVkOiAnI0ZGNDUwMCcsXG4gIHRvbWF0bzogJyNGRjYzNDcnLFxuICBob3RwaW5rOiAnI0ZGNjlCNCcsXG4gIGNvcmFsOiAnI0ZGN0Y1MCcsXG4gIGRhcmtvcmFuZ2U6ICcjRkY4QzAwJyxcbiAgbGlnaHRzYWxtb246ICcjRkZBMDdBJyxcbiAgb3JhbmdlOiAnI0ZGQTUwMCcsXG4gIGxpZ2h0cGluazogJyNGRkI2QzEnLFxuICBwaW5rOiAnI0ZGQzBDQicsXG4gIGdvbGQ6ICcjRkZENzAwJyxcbiAgcGVhY2hwdWZmOiAnI0ZGREFCOScsXG4gIG5hdmFqb3doaXRlOiAnI0ZGREVBRCcsXG4gIG1vY2Nhc2luOiAnI0ZGRTRCNScsXG4gIGJpc3F1ZTogJyNGRkU0QzQnLFxuICBtaXN0eXJvc2U6ICcjRkZFNEUxJyxcbiAgYmxhbmNoZWRhbG1vbmQ6ICcjRkZFQkNEJyxcbiAgcGFwYXlhd2hpcDogJyNGRkVGRDUnLFxuICBsYXZlbmRlcmJsdXNoOiAnI0ZGRjBGNScsXG4gIHNlYXNoZWxsOiAnI0ZGRjVFRScsXG4gIGNvcm5zaWxrOiAnI0ZGRjhEQycsXG4gIGxlbW9uY2hpZmZvbjogJyNGRkZBQ0QnLFxuICBmbG9yYWx3aGl0ZTogJyNGRkZBRjAnLFxuICBzbm93OiAnI0ZGRkFGQScsXG4gIHllbGxvdzogJyNGRkZGMDAnLFxuICBsaWdodHllbGxvdzogJyNGRkZGRTAnLFxuICBpdm9yeTogJyNGRkZGRjAnLFxuICB3aGl0ZTogJyNGRkZGRkYnXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcGl4ZWxSYXRpbz0xXVxuICAgKi9cbn07XG52YXIgQ29sb3JQaWNrZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3BpeGVsUmF0aW89MV1cbiAgICovXG4gIGZ1bmN0aW9uIENvbG9yUGlja2VyKCkge1xuICAgIHZhciBwaXhlbFJhdGlvID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAxO1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szWydkZWZhdWx0J10pKHRoaXMsIENvbG9yUGlja2VyKTtcblxuICAgIHRoaXMucGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XG4gICAgdGhpcy5nZW5lcmF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNlbnRlckNvb3JkaW5hdGVzID0geyB4OiAyODkgLyAyLCB5OiAyODkgLyAyIH07XG4gICAgdGhpcy5yID0gMjg5ICogMC40OTtcbiAgICB0aGlzLmNvbG9yID0geyByOiAyNTUsIGc6IDI1NSwgYjogMjU1LCBhOiAxLjAgfTtcbiAgICB0aGlzLmh1ZUNpcmNsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmluaXRpYWxDb2xvciA9IHsgcjogMjU1LCBnOiAyNTUsIGI6IDI1NSwgYTogMS4wIH07XG4gICAgdGhpcy5wcmV2aW91c0NvbG9yID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYXBwbGllZCA9IGZhbHNlO1xuXG4gICAgLy8gYm91bmQgYnlcbiAgICB0aGlzLnVwZGF0ZUNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgdGhpcy5jbG9zZUNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBjcmVhdGUgYWxsIERPTSBlbGVtZW50c1xuICAgIHRoaXMuX2NyZWF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIHRoaXMgaW5zZXJ0cyB0aGUgY29sb3JQaWNrZXIgaW50byBhIGRpdiBmcm9tIHRoZSBET01cbiAgICogQHBhcmFtIHtFbGVtZW50fSBjb250YWluZXJcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzM1snZGVmYXVsdCddKShDb2xvclBpY2tlciwgW3tcbiAgICBrZXk6ICdpbnNlcnRUbycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydFRvKGNvbnRhaW5lcikge1xuICAgICAgaWYgKHRoaXMuaGFtbWVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5oYW1tZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmhhbW1lciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5mcmFtZSk7XG4gICAgICB0aGlzLl9iaW5kSGFtbWVyKCk7XG5cbiAgICAgIHRoaXMuX3NldFNpemUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0aGUgY2FsbGJhY2sgaXMgZXhlY3V0ZWQgb24gYXBwbHkgYW5kIHNhdmUuIEJpbmQgaXQgdG8gdGhlIGFwcGxpY2F0aW9uXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0VXBkYXRlQ2FsbGJhY2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRVcGRhdGVDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnVwZGF0ZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uIGF0dGVtcHRlZCB0byBzZXQgYXMgY29sb3JQaWNrZXIgdXBkYXRlIGNhbGxiYWNrIGlzIG5vdCBhIGZ1bmN0aW9uLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRoZSBjYWxsYmFjayBpcyBleGVjdXRlZCBvbiBhcHBseSBhbmQgc2F2ZS4gQmluZCBpdCB0byB0aGUgYXBwbGljYXRpb25cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRDbG9zZUNhbGxiYWNrJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q2xvc2VDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLmNsb3NlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gYXR0ZW1wdGVkIHRvIHNldCBhcyBjb2xvclBpY2tlciBjbG9zaW5nIGNhbGxiYWNrIGlzIG5vdCBhIGZ1bmN0aW9uLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfaXNDb2xvclN0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pc0NvbG9yU3RyaW5nKGNvbG9yKSB7XG4gICAgICBpZiAodHlwZW9mIGNvbG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gaHRtbENvbG9yc1tjb2xvcl07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjb2xvciBvZiB0aGUgY29sb3JQaWNrZXJcbiAgICAgKiBTdXBwb3J0ZWQgZm9ybWF0czpcbiAgICAgKiAncmVkJyAgICAgICAgICAgICAgICAgICAtLT4gSFRNTCBjb2xvciBzdHJpbmdcbiAgICAgKiAnI2ZmZmZmZicgICAgICAgICAgICAgICAtLT4gaGV4IHN0cmluZ1xuICAgICAqICdyZ2IoMjU1LDI1NSwyNTUpJyAgICAgIC0tPiByZ2Igc3RyaW5nXG4gICAgICogJ3JnYmEoMjU1LDI1NSwyNTUsMS4wKScgLS0+IHJnYmEgc3RyaW5nXG4gICAgICoge3I6MjU1LGc6MjU1LGI6MjU1fSAgICAgLS0+IHJnYiBvYmplY3RcbiAgICAgKiB7cjoyNTUsZzoyNTUsYjoyNTUsYToxLjB9IC0tPiByZ2JhIG9iamVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gY29sb3JcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzZXRJbml0aWFsPXRydWVdXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldENvbG9yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q29sb3IoY29sb3IpIHtcbiAgICAgIHZhciBzZXRJbml0aWFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuXG4gICAgICBpZiAoY29sb3IgPT09ICdub25lJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciByZ2JhID0gdm9pZCAwO1xuXG4gICAgICAvLyBpZiBhIGh0bWwgY29sb3Igc2hvcnRoYW5kIGlzIHVzZWQsIGNvbnZlcnQgdG8gaGV4XG4gICAgICB2YXIgaHRtbENvbG9yID0gdGhpcy5faXNDb2xvclN0cmluZyhjb2xvcik7XG4gICAgICBpZiAoaHRtbENvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29sb3IgPSBodG1sQ29sb3I7XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIGZvcm1hdFxuICAgICAgaWYgKHV0aWwuaXNTdHJpbmcoY29sb3IpID09PSB0cnVlKSB7XG4gICAgICAgIGlmICh1dGlsLmlzVmFsaWRSR0IoY29sb3IpID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIHJnYmFBcnJheSA9IGNvbG9yLnN1YnN0cig0KS5zdWJzdHIoMCwgY29sb3IubGVuZ3RoIC0gNSkuc3BsaXQoJywnKTtcbiAgICAgICAgICByZ2JhID0geyByOiByZ2JhQXJyYXlbMF0sIGc6IHJnYmFBcnJheVsxXSwgYjogcmdiYUFycmF5WzJdLCBhOiAxLjAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh1dGlsLmlzVmFsaWRSR0JBKGNvbG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBfcmdiYUFycmF5ID0gY29sb3Iuc3Vic3RyKDUpLnN1YnN0cigwLCBjb2xvci5sZW5ndGggLSA2KS5zcGxpdCgnLCcpO1xuICAgICAgICAgIHJnYmEgPSB7XG4gICAgICAgICAgICByOiBfcmdiYUFycmF5WzBdLFxuICAgICAgICAgICAgZzogX3JnYmFBcnJheVsxXSxcbiAgICAgICAgICAgIGI6IF9yZ2JhQXJyYXlbMl0sXG4gICAgICAgICAgICBhOiBfcmdiYUFycmF5WzNdXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh1dGlsLmlzVmFsaWRIZXgoY29sb3IpID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIHJnYk9iaiA9IHV0aWwuaGV4VG9SR0IoY29sb3IpO1xuICAgICAgICAgIHJnYmEgPSB7IHI6IHJnYk9iai5yLCBnOiByZ2JPYmouZywgYjogcmdiT2JqLmIsIGE6IDEuMCB9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY29sb3IgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICBpZiAoY29sb3IuciAhPT0gdW5kZWZpbmVkICYmIGNvbG9yLmcgIT09IHVuZGVmaW5lZCAmJiBjb2xvci5iICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBhbHBoYSA9IGNvbG9yLmEgIT09IHVuZGVmaW5lZCA/IGNvbG9yLmEgOiAnMS4wJztcbiAgICAgICAgICAgIHJnYmEgPSB7IHI6IGNvbG9yLnIsIGc6IGNvbG9yLmcsIGI6IGNvbG9yLmIsIGE6IGFscGhhIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHNldCBjb2xvclxuICAgICAgaWYgKHJnYmEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gY29sb3IgcGFzc2VkIHRvIHRoZSBjb2xvclBpY2tlci4gU3VwcG9ydGVkIGFyZSBzdHJpbmdzOiByZ2IsIGhleCwgcmdiYS4gT2JqZWN0OiByZ2IgKHtyOnIsZzpnLGI6YixbYTphXX0pLiBTdXBwbGllZDogJyArICgwLCBfc3RyaW5naWZ5MlsnZGVmYXVsdCddKShjb2xvcikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2V0Q29sb3IocmdiYSwgc2V0SW5pdGlhbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdGhpcyBzaG93cyB0aGUgY29sb3IgcGlja2VyLlxuICAgICAqIFRoZSBodWUgY2lyY2xlIGlzIGNvbnN0cnVjdGVkIG9uY2UgYW5kIHN0b3JlZC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2hvdycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgICBpZiAodGhpcy5jbG9zZUNhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5jbG9zZUNhbGxiYWNrKCk7XG4gICAgICAgIHRoaXMuY2xvc2VDYWxsYmFjayA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hcHBsaWVkID0gZmFsc2U7XG4gICAgICB0aGlzLmZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgdGhpcy5fZ2VuZXJhdGVIdWVDaXJjbGUoKTtcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUFJJVkFURSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4gICAgLyoqXG4gICAgICogSGlkZSB0aGUgcGlja2VyLiBJcyBjYWxsZWQgYnkgdGhlIGNhbmNlbCBidXR0b24uXG4gICAgICogT3B0aW9uYWwgYm9vbGVhbiB0byBzdG9yZSB0aGUgcHJldmlvdXMgY29sb3IgZm9yIGVhc3kgYWNjZXNzIGxhdGVyIG9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3N0b3JlUHJldmlvdXM9dHJ1ZV1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfaGlkZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oaWRlKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHN0b3JlUHJldmlvdXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG5cbiAgICAgIC8vIHN0b3JlIHRoZSBwcmV2aW91cyBjb2xvciBmb3IgbmV4dCB0aW1lO1xuICAgICAgaWYgKHN0b3JlUHJldmlvdXMgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5wcmV2aW91c0NvbG9yID0gdXRpbC5leHRlbmQoe30sIHRoaXMuY29sb3IpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5hcHBsaWVkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQ2FsbGJhY2sodGhpcy5pbml0aWFsQ29sb3IpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgIC8vIGNhbGwgdGhlIGNsb3NpbmcgY2FsbGJhY2ssIHJlc3RvcmluZyB0aGUgb25jbGljayBtZXRob2QuXG4gICAgICAvLyB0aGlzIGlzIGluIGEgc2V0VGltZW91dCBiZWNhdXNlIGl0IHdpbGwgdHJpZ2dlciB0aGUgc2hvdyBhZ2FpbiBiZWZvcmUgdGhlIGNsaWNrIGlzIGRvbmUuXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKF90aGlzLmNsb3NlQ2FsbGJhY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIF90aGlzLmNsb3NlQ2FsbGJhY2soKTtcbiAgICAgICAgICBfdGhpcy5jbG9zZUNhbGxiYWNrID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBib3VuZCB0byB0aGUgc2F2ZSBidXR0b24uIFNhdmVzIGFuZCBoaWRlcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfc2F2ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zYXZlKCkge1xuICAgICAgdGhpcy51cGRhdGVDYWxsYmFjayh0aGlzLmNvbG9yKTtcbiAgICAgIHRoaXMuYXBwbGllZCA9IGZhbHNlO1xuICAgICAgdGhpcy5faGlkZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJvdW5kIHRvIGFwcGx5IGJ1dHRvbi4gU2F2ZXMgYnV0IGRvZXMgbm90IGNsb3NlLiBJcyB1bmRvbmUgYnkgdGhlIGNhbmNlbCBidXR0b24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2FwcGx5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FwcGx5KCkge1xuICAgICAgdGhpcy5hcHBsaWVkID0gdHJ1ZTtcbiAgICAgIHRoaXMudXBkYXRlQ2FsbGJhY2sodGhpcy5jb2xvcik7XG4gICAgICB0aGlzLl91cGRhdGVQaWNrZXIodGhpcy5jb2xvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbG9hZCB0aGUgY29sb3IgZnJvbSB0aGUgcHJldmlvdXMgc2Vzc2lvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfbG9hZExhc3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbG9hZExhc3QoKSB7XG4gICAgICBpZiAodGhpcy5wcmV2aW91c0NvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5zZXRDb2xvcih0aGlzLnByZXZpb3VzQ29sb3IsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsZXJ0KCdUaGVyZSBpcyBubyBsYXN0IGNvbG9yIHRvIGxvYWQuLi4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZXQgdGhlIGNvbG9yLCBwbGFjZSB0aGUgcGlja2VyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJnYmFcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzZXRJbml0aWFsPXRydWVdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3NldENvbG9yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldENvbG9yKHJnYmEpIHtcbiAgICAgIHZhciBzZXRJbml0aWFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuXG4gICAgICAvLyBzdG9yZSB0aGUgaW5pdGlhbCBjb2xvclxuICAgICAgaWYgKHNldEluaXRpYWwgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5pbml0aWFsQ29sb3IgPSB1dGlsLmV4dGVuZCh7fSwgcmdiYSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29sb3IgPSByZ2JhO1xuICAgICAgdmFyIGhzdiA9IHV0aWwuUkdCVG9IU1YocmdiYS5yLCByZ2JhLmcsIHJnYmEuYik7XG5cbiAgICAgIHZhciBhbmdsZUNvbnZlcnQgPSAyICogTWF0aC5QSTtcbiAgICAgIHZhciByYWRpdXMgPSB0aGlzLnIgKiBoc3YucztcbiAgICAgIHZhciB4ID0gdGhpcy5jZW50ZXJDb29yZGluYXRlcy54ICsgcmFkaXVzICogTWF0aC5zaW4oYW5nbGVDb252ZXJ0ICogaHN2LmgpO1xuICAgICAgdmFyIHkgPSB0aGlzLmNlbnRlckNvb3JkaW5hdGVzLnkgKyByYWRpdXMgKiBNYXRoLmNvcyhhbmdsZUNvbnZlcnQgKiBoc3YuaCk7XG5cbiAgICAgIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5zdHlsZS5sZWZ0ID0geCAtIDAuNSAqIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5jbGllbnRXaWR0aCArICdweCc7XG4gICAgICB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3Iuc3R5bGUudG9wID0geSAtIDAuNSAqIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5jbGllbnRIZWlnaHQgKyAncHgnO1xuXG4gICAgICB0aGlzLl91cGRhdGVQaWNrZXIocmdiYSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYm91bmQgdG8gb3BhY2l0eSBjb250cm9sXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3NldE9wYWNpdHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0T3BhY2l0eSh2YWx1ZSkge1xuICAgICAgdGhpcy5jb2xvci5hID0gdmFsdWUgLyAxMDA7XG4gICAgICB0aGlzLl91cGRhdGVQaWNrZXIodGhpcy5jb2xvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYm91bmQgdG8gYnJpZ2h0bmVzcyBjb250cm9sXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3NldEJyaWdodG5lc3MnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0QnJpZ2h0bmVzcyh2YWx1ZSkge1xuICAgICAgdmFyIGhzdiA9IHV0aWwuUkdCVG9IU1YodGhpcy5jb2xvci5yLCB0aGlzLmNvbG9yLmcsIHRoaXMuY29sb3IuYik7XG4gICAgICBoc3YudiA9IHZhbHVlIC8gMTAwO1xuICAgICAgdmFyIHJnYmEgPSB1dGlsLkhTVlRvUkdCKGhzdi5oLCBoc3YucywgaHN2LnYpO1xuICAgICAgcmdiYVsnYSddID0gdGhpcy5jb2xvci5hO1xuICAgICAgdGhpcy5jb2xvciA9IHJnYmE7XG4gICAgICB0aGlzLl91cGRhdGVQaWNrZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB1cGRhdGUgdGhlIGNvbG9yIHBpY2tlci4gQSBibGFjayBjaXJjbGUgb3ZlcmxheXMgdGhlIGh1ZSBjaXJjbGUgdG8gbWltaWMgdGhlIGJyaWdodG5lc3MgZGVjcmVhc2luZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmdiYVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ191cGRhdGVQaWNrZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlUGlja2VyKCkge1xuICAgICAgdmFyIHJnYmEgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRoaXMuY29sb3I7XG5cbiAgICAgIHZhciBoc3YgPSB1dGlsLlJHQlRvSFNWKHJnYmEuciwgcmdiYS5nLCByZ2JhLmIpO1xuICAgICAgdmFyIGN0eCA9IHRoaXMuY29sb3JQaWNrZXJDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGlmICh0aGlzLnBpeGVsUmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5waXhlbFJhdGlvID0gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIC8gKGN0eC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDEpO1xuICAgICAgfVxuICAgICAgY3R4LnNldFRyYW5zZm9ybSh0aGlzLnBpeGVsUmF0aW8sIDAsIDAsIHRoaXMucGl4ZWxSYXRpbywgMCwgMCk7XG5cbiAgICAgIC8vIGNsZWFyIHRoZSBjYW52YXNcbiAgICAgIHZhciB3ID0gdGhpcy5jb2xvclBpY2tlckNhbnZhcy5jbGllbnRXaWR0aDtcbiAgICAgIHZhciBoID0gdGhpcy5jb2xvclBpY2tlckNhbnZhcy5jbGllbnRIZWlnaHQ7XG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHcsIGgpO1xuXG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKHRoaXMuaHVlQ2lyY2xlLCAwLCAwKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAncmdiYSgwLDAsMCwnICsgKDEgLSBoc3YudikgKyAnKSc7XG4gICAgICBjdHguY2lyY2xlKHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueCwgdGhpcy5jZW50ZXJDb29yZGluYXRlcy55LCB0aGlzLnIpO1xuICAgICAgY3R4LmZpbGwoKTtcblxuICAgICAgdGhpcy5icmlnaHRuZXNzUmFuZ2UudmFsdWUgPSAxMDAgKiBoc3YudjtcbiAgICAgIHRoaXMub3BhY2l0eVJhbmdlLnZhbHVlID0gMTAwICogcmdiYS5hO1xuXG4gICAgICB0aGlzLmluaXRpYWxDb2xvckRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiYSgnICsgdGhpcy5pbml0aWFsQ29sb3IuciArICcsJyArIHRoaXMuaW5pdGlhbENvbG9yLmcgKyAnLCcgKyB0aGlzLmluaXRpYWxDb2xvci5iICsgJywnICsgdGhpcy5pbml0aWFsQ29sb3IuYSArICcpJztcbiAgICAgIHRoaXMubmV3Q29sb3JEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3JnYmEoJyArIHRoaXMuY29sb3IuciArICcsJyArIHRoaXMuY29sb3IuZyArICcsJyArIHRoaXMuY29sb3IuYiArICcsJyArIHRoaXMuY29sb3IuYSArICcpJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB1c2VkIGJ5IGNyZWF0ZSB0byBzZXQgdGhlIHNpemUgb2YgdGhlIGNhbnZhcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfc2V0U2l6ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRTaXplKCkge1xuICAgICAgdGhpcy5jb2xvclBpY2tlckNhbnZhcy5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgIHRoaXMuY29sb3JQaWNrZXJDYW52YXMuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuXG4gICAgICB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLndpZHRoID0gMjg5ICogdGhpcy5waXhlbFJhdGlvO1xuICAgICAgdGhpcy5jb2xvclBpY2tlckNhbnZhcy5oZWlnaHQgPSAyODkgKiB0aGlzLnBpeGVsUmF0aW87XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY3JlYXRlIGFsbCBkb20gZWxlbWVudHNcbiAgICAgKiBUT0RPOiBjbGVhbnVwLCBsb3RzIG9mIHNpbWlsYXIgZG9tIGVsZW1lbnRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2NyZWF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGUoKSB7XG4gICAgICB0aGlzLmZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzLmZyYW1lLmNsYXNzTmFtZSA9ICd2aXMtY29sb3ItcGlja2VyJztcblxuICAgICAgdGhpcy5jb2xvclBpY2tlckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3IuY2xhc3NOYW1lID0gJ3Zpcy1zZWxlY3Rvcic7XG4gICAgICB0aGlzLmNvbG9yUGlja2VyRGl2LmFwcGVuZENoaWxkKHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvcik7XG5cbiAgICAgIHRoaXMuY29sb3JQaWNrZXJDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgIHRoaXMuY29sb3JQaWNrZXJEaXYuYXBwZW5kQ2hpbGQodGhpcy5jb2xvclBpY2tlckNhbnZhcyk7XG5cbiAgICAgIGlmICghdGhpcy5jb2xvclBpY2tlckNhbnZhcy5nZXRDb250ZXh0KSB7XG4gICAgICAgIHZhciBub0NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICAgICAgICBub0NhbnZhcy5zdHlsZS5jb2xvciA9ICdyZWQnO1xuICAgICAgICBub0NhbnZhcy5zdHlsZS5mb250V2VpZ2h0ID0gJ2JvbGQnO1xuICAgICAgICBub0NhbnZhcy5zdHlsZS5wYWRkaW5nID0gJzEwcHgnO1xuICAgICAgICBub0NhbnZhcy5pbm5lckhUTUwgPSAnRXJyb3I6IHlvdXIgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IEhUTUwgY2FudmFzJztcbiAgICAgICAgdGhpcy5jb2xvclBpY2tlckNhbnZhcy5hcHBlbmRDaGlsZChub0NhbnZhcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5jb2xvclBpY2tlckNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB0aGlzLnBpeGVsUmF0aW8gPSAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSkgLyAoY3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMSk7XG4gICAgICAgIHRoaXMuY29sb3JQaWNrZXJDYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5zZXRUcmFuc2Zvcm0odGhpcy5waXhlbFJhdGlvLCAwLCAwLCB0aGlzLnBpeGVsUmF0aW8sIDAsIDApO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbG9yUGlja2VyRGl2LmNsYXNzTmFtZSA9ICd2aXMtY29sb3InO1xuXG4gICAgICB0aGlzLm9wYWNpdHlEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMub3BhY2l0eURpdi5jbGFzc05hbWUgPSAndmlzLW9wYWNpdHknO1xuXG4gICAgICB0aGlzLmJyaWdodG5lc3NEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMuYnJpZ2h0bmVzc0Rpdi5jbGFzc05hbWUgPSAndmlzLWJyaWdodG5lc3MnO1xuXG4gICAgICB0aGlzLmFycm93RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzLmFycm93RGl2LmNsYXNzTmFtZSA9ICd2aXMtYXJyb3cnO1xuXG4gICAgICB0aGlzLm9wYWNpdHlSYW5nZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLm9wYWNpdHlSYW5nZS50eXBlID0gJ3JhbmdlJzsgLy8gTm90IHN1cHBvcnRlZCBvbiBJRTlcbiAgICAgICAgdGhpcy5vcGFjaXR5UmFuZ2UubWluID0gJzAnO1xuICAgICAgICB0aGlzLm9wYWNpdHlSYW5nZS5tYXggPSAnMTAwJztcbiAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgIC8vIFRPRE86IEFkZCBzb21lIGVycm9yIGhhbmRsaW5nIGFuZCByZW1vdmUgdGhpcyBsaW50IGV4Y2VwdGlvblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxuICAgICAgdGhpcy5vcGFjaXR5UmFuZ2UudmFsdWUgPSAnMTAwJztcbiAgICAgIHRoaXMub3BhY2l0eVJhbmdlLmNsYXNzTmFtZSA9ICd2aXMtcmFuZ2UnO1xuXG4gICAgICB0aGlzLmJyaWdodG5lc3NSYW5nZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmJyaWdodG5lc3NSYW5nZS50eXBlID0gJ3JhbmdlJzsgLy8gTm90IHN1cHBvcnRlZCBvbiBJRTlcbiAgICAgICAgdGhpcy5icmlnaHRuZXNzUmFuZ2UubWluID0gJzAnO1xuICAgICAgICB0aGlzLmJyaWdodG5lc3NSYW5nZS5tYXggPSAnMTAwJztcbiAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgIC8vIFRPRE86IEFkZCBzb21lIGVycm9yIGhhbmRsaW5nIGFuZCByZW1vdmUgdGhpcyBsaW50IGV4Y2VwdGlvblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxuICAgICAgdGhpcy5icmlnaHRuZXNzUmFuZ2UudmFsdWUgPSAnMTAwJztcbiAgICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlLmNsYXNzTmFtZSA9ICd2aXMtcmFuZ2UnO1xuXG4gICAgICB0aGlzLm9wYWNpdHlEaXYuYXBwZW5kQ2hpbGQodGhpcy5vcGFjaXR5UmFuZ2UpO1xuICAgICAgdGhpcy5icmlnaHRuZXNzRGl2LmFwcGVuZENoaWxkKHRoaXMuYnJpZ2h0bmVzc1JhbmdlKTtcblxuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIHRoaXMub3BhY2l0eVJhbmdlLm9uY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBtZS5fc2V0T3BhY2l0eSh0aGlzLnZhbHVlKTtcbiAgICAgIH07XG4gICAgICB0aGlzLm9wYWNpdHlSYW5nZS5vbmlucHV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBtZS5fc2V0T3BhY2l0eSh0aGlzLnZhbHVlKTtcbiAgICAgIH07XG4gICAgICB0aGlzLmJyaWdodG5lc3NSYW5nZS5vbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbWUuX3NldEJyaWdodG5lc3ModGhpcy52YWx1ZSk7XG4gICAgICB9O1xuICAgICAgdGhpcy5icmlnaHRuZXNzUmFuZ2Uub25pbnB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbWUuX3NldEJyaWdodG5lc3ModGhpcy52YWx1ZSk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmJyaWdodG5lc3NMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5icmlnaHRuZXNzTGFiZWwuY2xhc3NOYW1lID0gJ3Zpcy1sYWJlbCB2aXMtYnJpZ2h0bmVzcyc7XG4gICAgICB0aGlzLmJyaWdodG5lc3NMYWJlbC5pbm5lckhUTUwgPSAnYnJpZ2h0bmVzczonO1xuXG4gICAgICB0aGlzLm9wYWNpdHlMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5vcGFjaXR5TGFiZWwuY2xhc3NOYW1lID0gJ3Zpcy1sYWJlbCB2aXMtb3BhY2l0eSc7XG4gICAgICB0aGlzLm9wYWNpdHlMYWJlbC5pbm5lckhUTUwgPSAnb3BhY2l0eTonO1xuXG4gICAgICB0aGlzLm5ld0NvbG9yRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzLm5ld0NvbG9yRGl2LmNsYXNzTmFtZSA9ICd2aXMtbmV3LWNvbG9yJztcbiAgICAgIHRoaXMubmV3Q29sb3JEaXYuaW5uZXJIVE1MID0gJ25ldyc7XG5cbiAgICAgIHRoaXMuaW5pdGlhbENvbG9yRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzLmluaXRpYWxDb2xvckRpdi5jbGFzc05hbWUgPSAndmlzLWluaXRpYWwtY29sb3InO1xuICAgICAgdGhpcy5pbml0aWFsQ29sb3JEaXYuaW5uZXJIVE1MID0gJ2luaXRpYWwnO1xuXG4gICAgICB0aGlzLmNhbmNlbEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5jYW5jZWxCdXR0b24uY2xhc3NOYW1lID0gJ3Zpcy1idXR0b24gdmlzLWNhbmNlbCc7XG4gICAgICB0aGlzLmNhbmNlbEJ1dHRvbi5pbm5lckhUTUwgPSAnY2FuY2VsJztcbiAgICAgIHRoaXMuY2FuY2VsQnV0dG9uLm9uY2xpY2sgPSB0aGlzLl9oaWRlLmJpbmQodGhpcywgZmFsc2UpO1xuXG4gICAgICB0aGlzLmFwcGx5QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzLmFwcGx5QnV0dG9uLmNsYXNzTmFtZSA9ICd2aXMtYnV0dG9uIHZpcy1hcHBseSc7XG4gICAgICB0aGlzLmFwcGx5QnV0dG9uLmlubmVySFRNTCA9ICdhcHBseSc7XG4gICAgICB0aGlzLmFwcGx5QnV0dG9uLm9uY2xpY2sgPSB0aGlzLl9hcHBseS5iaW5kKHRoaXMpO1xuXG4gICAgICB0aGlzLnNhdmVCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMuc2F2ZUJ1dHRvbi5jbGFzc05hbWUgPSAndmlzLWJ1dHRvbiB2aXMtc2F2ZSc7XG4gICAgICB0aGlzLnNhdmVCdXR0b24uaW5uZXJIVE1MID0gJ3NhdmUnO1xuICAgICAgdGhpcy5zYXZlQnV0dG9uLm9uY2xpY2sgPSB0aGlzLl9zYXZlLmJpbmQodGhpcyk7XG5cbiAgICAgIHRoaXMubG9hZEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5sb2FkQnV0dG9uLmNsYXNzTmFtZSA9ICd2aXMtYnV0dG9uIHZpcy1sb2FkJztcbiAgICAgIHRoaXMubG9hZEJ1dHRvbi5pbm5lckhUTUwgPSAnbG9hZCBsYXN0JztcbiAgICAgIHRoaXMubG9hZEJ1dHRvbi5vbmNsaWNrID0gdGhpcy5fbG9hZExhc3QuYmluZCh0aGlzKTtcblxuICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmNvbG9yUGlja2VyRGl2KTtcbiAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5hcnJvd0Rpdik7XG4gICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuYnJpZ2h0bmVzc0xhYmVsKTtcbiAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5icmlnaHRuZXNzRGl2KTtcbiAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5vcGFjaXR5TGFiZWwpO1xuICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLm9wYWNpdHlEaXYpO1xuICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLm5ld0NvbG9yRGl2KTtcbiAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5pbml0aWFsQ29sb3JEaXYpO1xuXG4gICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuY2FuY2VsQnV0dG9uKTtcbiAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5hcHBseUJ1dHRvbik7XG4gICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuc2F2ZUJ1dHRvbik7XG4gICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMubG9hZEJ1dHRvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYmluZCBoYW1tZXIgdG8gdGhlIGNvbG9yIHBpY2tlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19iaW5kSGFtbWVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2JpbmRIYW1tZXIoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy5kcmFnID0ge307XG4gICAgICB0aGlzLnBpbmNoID0ge307XG4gICAgICB0aGlzLmhhbW1lciA9IG5ldyBIYW1tZXIodGhpcy5jb2xvclBpY2tlckNhbnZhcyk7XG4gICAgICB0aGlzLmhhbW1lci5nZXQoJ3BpbmNoJykuc2V0KHsgZW5hYmxlOiB0cnVlIH0pO1xuXG4gICAgICBoYW1tZXJVdGlsLm9uVG91Y2godGhpcy5oYW1tZXIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczIuX21vdmVTZWxlY3RvcihldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFtbWVyLm9uKCd0YXAnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMyLl9tb3ZlU2VsZWN0b3IoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmhhbW1lci5vbigncGFuc3RhcnQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMyLl9tb3ZlU2VsZWN0b3IoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmhhbW1lci5vbigncGFubW92ZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczIuX21vdmVTZWxlY3RvcihldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFtbWVyLm9uKCdwYW5lbmQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMyLl9tb3ZlU2VsZWN0b3IoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2VuZXJhdGUgdGhlIGh1ZSBjaXJjbGUuIFRoaXMgaXMgcmVsYXRpdmVseSBoZWF2eSAoMjAwbXMpIGFuZCBpcyBkb25lIG9ubHkgb25jZSBvbiB0aGUgZmlyc3QgdGltZSBpdCBpcyBzaG93bi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZ2VuZXJhdGVIdWVDaXJjbGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2VuZXJhdGVIdWVDaXJjbGUoKSB7XG4gICAgICBpZiAodGhpcy5nZW5lcmF0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGlmICh0aGlzLnBpeGVsUmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnBpeGVsUmF0aW8gPSAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSkgLyAoY3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnNldFRyYW5zZm9ybSh0aGlzLnBpeGVsUmF0aW8sIDAsIDAsIHRoaXMucGl4ZWxSYXRpbywgMCwgMCk7XG5cbiAgICAgICAgLy8gY2xlYXIgdGhlIGNhbnZhc1xuICAgICAgICB2YXIgdyA9IHRoaXMuY29sb3JQaWNrZXJDYW52YXMuY2xpZW50V2lkdGg7XG4gICAgICAgIHZhciBoID0gdGhpcy5jb2xvclBpY2tlckNhbnZhcy5jbGllbnRIZWlnaHQ7XG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdywgaCk7XG5cbiAgICAgICAgLy8gZHJhdyBodWUgY2lyY2xlXG4gICAgICAgIHZhciB4ID0gdm9pZCAwLFxuICAgICAgICAgICAgeSA9IHZvaWQgMCxcbiAgICAgICAgICAgIGh1ZSA9IHZvaWQgMCxcbiAgICAgICAgICAgIHNhdCA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5jZW50ZXJDb29yZGluYXRlcyA9IHsgeDogdyAqIDAuNSwgeTogaCAqIDAuNSB9O1xuICAgICAgICB0aGlzLnIgPSAwLjQ5ICogdztcbiAgICAgICAgdmFyIGFuZ2xlQ29udmVydCA9IDIgKiBNYXRoLlBJIC8gMzYwO1xuICAgICAgICB2YXIgaGZhYyA9IDEgLyAzNjA7XG4gICAgICAgIHZhciBzZmFjID0gMSAvIHRoaXMucjtcbiAgICAgICAgdmFyIHJnYiA9IHZvaWQgMDtcbiAgICAgICAgZm9yIChodWUgPSAwOyBodWUgPCAzNjA7IGh1ZSsrKSB7XG4gICAgICAgICAgZm9yIChzYXQgPSAwOyBzYXQgPCB0aGlzLnI7IHNhdCsrKSB7XG4gICAgICAgICAgICB4ID0gdGhpcy5jZW50ZXJDb29yZGluYXRlcy54ICsgc2F0ICogTWF0aC5zaW4oYW5nbGVDb252ZXJ0ICogaHVlKTtcbiAgICAgICAgICAgIHkgPSB0aGlzLmNlbnRlckNvb3JkaW5hdGVzLnkgKyBzYXQgKiBNYXRoLmNvcyhhbmdsZUNvbnZlcnQgKiBodWUpO1xuICAgICAgICAgICAgcmdiID0gdXRpbC5IU1ZUb1JHQihodWUgKiBoZmFjLCBzYXQgKiBzZmFjLCAxKTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAncmdiKCcgKyByZ2IuciArICcsJyArIHJnYi5nICsgJywnICsgcmdiLmIgKyAnKSc7XG4gICAgICAgICAgICBjdHguZmlsbFJlY3QoeCAtIDAuNSwgeSAtIDAuNSwgMiwgMik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZ2JhKDAsMCwwLDEpJztcbiAgICAgICAgY3R4LmNpcmNsZSh0aGlzLmNlbnRlckNvb3JkaW5hdGVzLngsIHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueSwgdGhpcy5yKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICAgIHRoaXMuaHVlQ2lyY2xlID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCB3LCBoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZ2VuZXJhdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBtb3ZlIHRoZSBzZWxlY3Rvci4gVGhpcyBpcyBjYWxsZWQgYnkgaGFtbWVyIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9ICBldmVudCAgIFRoZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19tb3ZlU2VsZWN0b3InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbW92ZVNlbGVjdG9yKGV2ZW50KSB7XG4gICAgICB2YXIgcmVjdCA9IHRoaXMuY29sb3JQaWNrZXJEaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgbGVmdCA9IGV2ZW50LmNlbnRlci54IC0gcmVjdC5sZWZ0O1xuICAgICAgdmFyIHRvcCA9IGV2ZW50LmNlbnRlci55IC0gcmVjdC50b3A7XG5cbiAgICAgIHZhciBjZW50ZXJZID0gMC41ICogdGhpcy5jb2xvclBpY2tlckRpdi5jbGllbnRIZWlnaHQ7XG4gICAgICB2YXIgY2VudGVyWCA9IDAuNSAqIHRoaXMuY29sb3JQaWNrZXJEaXYuY2xpZW50V2lkdGg7XG5cbiAgICAgIHZhciB4ID0gbGVmdCAtIGNlbnRlclg7XG4gICAgICB2YXIgeSA9IHRvcCAtIGNlbnRlclk7XG5cbiAgICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbjIoeCwgeSk7XG4gICAgICB2YXIgcmFkaXVzID0gMC45OCAqIE1hdGgubWluKE1hdGguc3FydCh4ICogeCArIHkgKiB5KSwgY2VudGVyWCk7XG5cbiAgICAgIHZhciBuZXdUb3AgPSBNYXRoLmNvcyhhbmdsZSkgKiByYWRpdXMgKyBjZW50ZXJZO1xuICAgICAgdmFyIG5ld0xlZnQgPSBNYXRoLnNpbihhbmdsZSkgKiByYWRpdXMgKyBjZW50ZXJYO1xuXG4gICAgICB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3Iuc3R5bGUudG9wID0gbmV3VG9wIC0gMC41ICogdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLmNsaWVudEhlaWdodCArICdweCc7XG4gICAgICB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3Iuc3R5bGUubGVmdCA9IG5ld0xlZnQgLSAwLjUgKiB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3IuY2xpZW50V2lkdGggKyAncHgnO1xuXG4gICAgICAvLyBzZXQgY29sb3JcbiAgICAgIHZhciBoID0gYW5nbGUgLyAoMiAqIE1hdGguUEkpO1xuICAgICAgaCA9IGggPCAwID8gaCArIDEgOiBoO1xuICAgICAgdmFyIHMgPSByYWRpdXMgLyB0aGlzLnI7XG4gICAgICB2YXIgaHN2ID0gdXRpbC5SR0JUb0hTVih0aGlzLmNvbG9yLnIsIHRoaXMuY29sb3IuZywgdGhpcy5jb2xvci5iKTtcbiAgICAgIGhzdi5oID0gaDtcbiAgICAgIGhzdi5zID0gcztcbiAgICAgIHZhciByZ2JhID0gdXRpbC5IU1ZUb1JHQihoc3YuaCwgaHN2LnMsIGhzdi52KTtcbiAgICAgIHJnYmFbJ2EnXSA9IHRoaXMuY29sb3IuYTtcbiAgICAgIHRoaXMuY29sb3IgPSByZ2JhO1xuXG4gICAgICAvLyB1cGRhdGUgcHJldmlld3NcbiAgICAgIHRoaXMuaW5pdGlhbENvbG9yRGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdyZ2JhKCcgKyB0aGlzLmluaXRpYWxDb2xvci5yICsgJywnICsgdGhpcy5pbml0aWFsQ29sb3IuZyArICcsJyArIHRoaXMuaW5pdGlhbENvbG9yLmIgKyAnLCcgKyB0aGlzLmluaXRpYWxDb2xvci5hICsgJyknO1xuICAgICAgdGhpcy5uZXdDb2xvckRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiYSgnICsgdGhpcy5jb2xvci5yICsgJywnICsgdGhpcy5jb2xvci5nICsgJywnICsgdGhpcy5jb2xvci5iICsgJywnICsgdGhpcy5jb2xvci5hICsgJyknO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ29sb3JQaWNrZXI7XG59KCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IENvbG9yUGlja2VyO1xuXG4vKioqLyB9KSxcbi8qIDE5MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cbnZhciBfc2xpY2VkVG9BcnJheTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zbGljZWRUb0FycmF5Mik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxudmFyIF9GbG95ZFdhcnNoYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOTQpO1xuXG52YXIgX0Zsb3lkV2Fyc2hhbGwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRmxveWRXYXJzaGFsbCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLyoqXG4gKiBLYW1hZGFLYXdhaSBwb3NpdGlvbnMgdGhlIG5vZGVzIGluaXRpYWxseSBiYXNlZCBvblxuICpcbiAqIFwiQU4gQUxHT1JJVEhNIEZPUiBEUkFXSU5HIEdFTkVSQUwgVU5ESVJFQ1RFRCBHUkFQSFNcIlxuICogLS0gVG9taWhpc2EgS0FNQURBIGFuZCBTYXRvcnUgS0FXQUkgaW4gMTk4OVxuICpcbiAqIFBvc3NpYmxlIG9wdGltaXphdGlvbnMgaW4gdGhlIGRpc3RhbmNlIGNhbGN1bGF0aW9uIGNhbiBiZSBpbXBsZW1lbnRlZC5cbiAqL1xudmFyIEthbWFkYUthd2FpID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtudW1iZXJ9IGVkZ2VMZW5ndGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IGVkZ2VTdHJlbmd0aFxuICAgKi9cbiAgZnVuY3Rpb24gS2FtYWRhS2F3YWkoYm9keSwgZWRnZUxlbmd0aCwgZWRnZVN0cmVuZ3RoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbJ2RlZmF1bHQnXSkodGhpcywgS2FtYWRhS2F3YWkpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLnNwcmluZ0xlbmd0aCA9IGVkZ2VMZW5ndGg7XG4gICAgdGhpcy5zcHJpbmdDb25zdGFudCA9IGVkZ2VTdHJlbmd0aDtcbiAgICB0aGlzLmRpc3RhbmNlU29sdmVyID0gbmV3IF9GbG95ZFdhcnNoYWxsMlsnZGVmYXVsdCddKCk7XG4gIH1cblxuICAvKipcbiAgICogTm90IHN1cmUgaWYgbmVlZGVkIGJ1dCBjYW4gYmUgdXNlZCB0byB1cGRhdGUgdGhlIHNwcmluZyBsZW5ndGggYW5kIHNwcmluZyBjb25zdGFudFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzWydkZWZhdWx0J10pKEthbWFkYUthd2FpLCBbe1xuICAgIGtleTogJ3NldE9wdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnNwcmluZ0xlbmd0aCkge1xuICAgICAgICAgIHRoaXMuc3ByaW5nTGVuZ3RoID0gb3B0aW9ucy5zcHJpbmdMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuc3ByaW5nQ29uc3RhbnQpIHtcbiAgICAgICAgICB0aGlzLnNwcmluZ0NvbnN0YW50ID0gb3B0aW9ucy5zcHJpbmdDb25zdGFudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBvc2l0aW9uIHRoZSBzeXN0ZW1cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOb2RlPn0gbm9kZXNBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHZpcy5FZGdlPn0gZWRnZXNBcnJheVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lnbm9yZUNsdXN0ZXJzPWZhbHNlXVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzb2x2ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvbHZlKG5vZGVzQXJyYXksIGVkZ2VzQXJyYXkpIHtcbiAgICAgIHZhciBpZ25vcmVDbHVzdGVycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgICAgIC8vIGdldCBkaXN0YW5jZSBtYXRyaXhcbiAgICAgIHZhciBEX21hdHJpeCA9IHRoaXMuZGlzdGFuY2VTb2x2ZXIuZ2V0RGlzdGFuY2VzKHRoaXMuYm9keSwgbm9kZXNBcnJheSwgZWRnZXNBcnJheSk7IC8vIGRpc3RhbmNlIG1hdHJpeFxuXG4gICAgICAvLyBnZXQgdGhlIEwgTWF0cml4XG4gICAgICB0aGlzLl9jcmVhdGVMX21hdHJpeChEX21hdHJpeCk7XG5cbiAgICAgIC8vIGdldCB0aGUgSyBNYXRyaXhcbiAgICAgIHRoaXMuX2NyZWF0ZUtfbWF0cml4KERfbWF0cml4KTtcblxuICAgICAgLy8gaW5pdGlhbCBFIE1hdHJpeFxuICAgICAgdGhpcy5fY3JlYXRlRV9tYXRyaXgoKTtcblxuICAgICAgLy8gY2FsY3VsYXRlIHBvc2l0aW9uc1xuICAgICAgdmFyIHRocmVzaG9sZCA9IDAuMDE7XG4gICAgICB2YXIgaW5uZXJUaHJlc2hvbGQgPSAxO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgdmFyIG1heEl0ZXJhdGlvbnMgPSBNYXRoLm1heCgxMDAwLCBNYXRoLm1pbigxMCAqIHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGgsIDYwMDApKTtcbiAgICAgIHZhciBtYXhJbm5lckl0ZXJhdGlvbnMgPSA1O1xuXG4gICAgICB2YXIgbWF4RW5lcmd5ID0gMWU5O1xuICAgICAgdmFyIGhpZ2hFX25vZGVJZCA9IDAsXG4gICAgICAgICAgZEVfZHggPSAwLFxuICAgICAgICAgIGRFX2R5ID0gMCxcbiAgICAgICAgICBkZWx0YV9tID0gMCxcbiAgICAgICAgICBzdWJJdGVyYXRpb25zID0gMDtcblxuICAgICAgd2hpbGUgKG1heEVuZXJneSA+IHRocmVzaG9sZCAmJiBpdGVyYXRpb25zIDwgbWF4SXRlcmF0aW9ucykge1xuICAgICAgICBpdGVyYXRpb25zICs9IDE7XG4gICAgICAgIHZhciBfZ2V0SGlnaGVzdEVuZXJneU5vZGUyID0gdGhpcy5fZ2V0SGlnaGVzdEVuZXJneU5vZGUoaWdub3JlQ2x1c3RlcnMpO1xuXG4gICAgICAgIHZhciBfZ2V0SGlnaGVzdEVuZXJneU5vZGUzID0gKDAsIF9zbGljZWRUb0FycmF5M1snZGVmYXVsdCddKShfZ2V0SGlnaGVzdEVuZXJneU5vZGUyLCA0KTtcblxuICAgICAgICBoaWdoRV9ub2RlSWQgPSBfZ2V0SGlnaGVzdEVuZXJneU5vZGUzWzBdO1xuICAgICAgICBtYXhFbmVyZ3kgPSBfZ2V0SGlnaGVzdEVuZXJneU5vZGUzWzFdO1xuICAgICAgICBkRV9keCA9IF9nZXRIaWdoZXN0RW5lcmd5Tm9kZTNbMl07XG4gICAgICAgIGRFX2R5ID0gX2dldEhpZ2hlc3RFbmVyZ3lOb2RlM1szXTtcblxuICAgICAgICBkZWx0YV9tID0gbWF4RW5lcmd5O1xuICAgICAgICBzdWJJdGVyYXRpb25zID0gMDtcbiAgICAgICAgd2hpbGUgKGRlbHRhX20gPiBpbm5lclRocmVzaG9sZCAmJiBzdWJJdGVyYXRpb25zIDwgbWF4SW5uZXJJdGVyYXRpb25zKSB7XG4gICAgICAgICAgc3ViSXRlcmF0aW9ucyArPSAxO1xuICAgICAgICAgIHRoaXMuX21vdmVOb2RlKGhpZ2hFX25vZGVJZCwgZEVfZHgsIGRFX2R5KTtcbiAgICAgICAgICB2YXIgX2dldEVuZXJneTIgPSB0aGlzLl9nZXRFbmVyZ3koaGlnaEVfbm9kZUlkKTtcblxuICAgICAgICAgIHZhciBfZ2V0RW5lcmd5MyA9ICgwLCBfc2xpY2VkVG9BcnJheTNbJ2RlZmF1bHQnXSkoX2dldEVuZXJneTIsIDMpO1xuXG4gICAgICAgICAgZGVsdGFfbSA9IF9nZXRFbmVyZ3kzWzBdO1xuICAgICAgICAgIGRFX2R4ID0gX2dldEVuZXJneTNbMV07XG4gICAgICAgICAgZEVfZHkgPSBfZ2V0RW5lcmd5M1syXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgbm9kZSB3aXRoIHRoZSBoaWdoZXN0IGVuZXJneVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaWdub3JlQ2x1c3RlcnNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2dldEhpZ2hlc3RFbmVyZ3lOb2RlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEhpZ2hlc3RFbmVyZ3lOb2RlKGlnbm9yZUNsdXN0ZXJzKSB7XG4gICAgICB2YXIgbm9kZXNBcnJheSA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcztcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIHZhciBtYXhFbmVyZ3kgPSAwO1xuICAgICAgdmFyIG1heEVuZXJneU5vZGVJZCA9IG5vZGVzQXJyYXlbMF07XG4gICAgICB2YXIgZEVfZHhfbWF4ID0gMCxcbiAgICAgICAgICBkRV9keV9tYXggPSAwO1xuXG4gICAgICBmb3IgKHZhciBub2RlSWR4ID0gMDsgbm9kZUlkeCA8IG5vZGVzQXJyYXkubGVuZ3RoOyBub2RlSWR4KyspIHtcbiAgICAgICAgdmFyIG0gPSBub2Rlc0FycmF5W25vZGVJZHhdO1xuICAgICAgICAvLyBieSBub3QgZXZhbHVhdGluZyBub2RlcyB3aXRoIHByZWRlZmluZWQgcG9zaXRpb25zIHdlIHNob3VsZCBvbmx5IG1vdmUgbm9kZXMgdGhhdCBoYXZlIG5vIHBvc2l0aW9ucy5cbiAgICAgICAgaWYgKG5vZGVzW21dLnByZWRlZmluZWRQb3NpdGlvbiA9PT0gZmFsc2UgfHwgbm9kZXNbbV0uaXNDbHVzdGVyID09PSB0cnVlICYmIGlnbm9yZUNsdXN0ZXJzID09PSB0cnVlIHx8IG5vZGVzW21dLm9wdGlvbnMuZml4ZWQueCA9PT0gdHJ1ZSB8fCBub2Rlc1ttXS5vcHRpb25zLmZpeGVkLnkgPT09IHRydWUpIHtcbiAgICAgICAgICB2YXIgX2dldEVuZXJneTQgPSB0aGlzLl9nZXRFbmVyZ3kobSksXG4gICAgICAgICAgICAgIF9nZXRFbmVyZ3k1ID0gKDAsIF9zbGljZWRUb0FycmF5M1snZGVmYXVsdCddKShfZ2V0RW5lcmd5NCwgMyksXG4gICAgICAgICAgICAgIGRlbHRhX20gPSBfZ2V0RW5lcmd5NVswXSxcbiAgICAgICAgICAgICAgZEVfZHggPSBfZ2V0RW5lcmd5NVsxXSxcbiAgICAgICAgICAgICAgZEVfZHkgPSBfZ2V0RW5lcmd5NVsyXTtcblxuICAgICAgICAgIGlmIChtYXhFbmVyZ3kgPCBkZWx0YV9tKSB7XG4gICAgICAgICAgICBtYXhFbmVyZ3kgPSBkZWx0YV9tO1xuICAgICAgICAgICAgbWF4RW5lcmd5Tm9kZUlkID0gbTtcbiAgICAgICAgICAgIGRFX2R4X21heCA9IGRFX2R4O1xuICAgICAgICAgICAgZEVfZHlfbWF4ID0gZEVfZHk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbbWF4RW5lcmd5Tm9kZUlkLCBtYXhFbmVyZ3ksIGRFX2R4X21heCwgZEVfZHlfbWF4XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjYWxjdWxhdGUgdGhlIGVuZXJneSBvZiBhIHNpbmdsZSBub2RlXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBtXG4gICAgICogQHJldHVybnMge251bWJlcltdfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19nZXRFbmVyZ3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RW5lcmd5KG0pIHtcbiAgICAgIHZhciBfRV9zdW1zJG0gPSAoMCwgX3NsaWNlZFRvQXJyYXkzWydkZWZhdWx0J10pKHRoaXMuRV9zdW1zW21dLCAyKSxcbiAgICAgICAgICBkRV9keCA9IF9FX3N1bXMkbVswXSxcbiAgICAgICAgICBkRV9keSA9IF9FX3N1bXMkbVsxXTtcblxuICAgICAgdmFyIGRlbHRhX20gPSBNYXRoLnNxcnQoTWF0aC5wb3coZEVfZHgsIDIpICsgTWF0aC5wb3coZEVfZHksIDIpKTtcbiAgICAgIHJldHVybiBbZGVsdGFfbSwgZEVfZHgsIGRFX2R5XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBtb3ZlIHRoZSBub2RlIGJhc2VkIG9uIGl0J3MgZW5lcmd5XG4gICAgICogdGhlIGR4IGFuZCBkeSBhcmUgY2FsY3VsYXRlZCBmcm9tIHRoZSBsaW5lYXIgc3lzdGVtIHByb3Bvc2VkIGJ5IEthbWFkYSBhbmQgS2F3YWlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkRV9keFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkRV9keVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19tb3ZlTm9kZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tb3ZlTm9kZShtLCBkRV9keCwgZEVfZHkpIHtcbiAgICAgIHZhciBub2Rlc0FycmF5ID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgdmFyIGQyRV9keDIgPSAwO1xuICAgICAgdmFyIGQyRV9keGR5ID0gMDtcbiAgICAgIHZhciBkMkVfZHkyID0gMDtcblxuICAgICAgdmFyIHhfbSA9IG5vZGVzW21dLng7XG4gICAgICB2YXIgeV9tID0gbm9kZXNbbV0ueTtcbiAgICAgIHZhciBrbSA9IHRoaXMuS19tYXRyaXhbbV07XG4gICAgICB2YXIgbG0gPSB0aGlzLkxfbWF0cml4W21dO1xuXG4gICAgICBmb3IgKHZhciBpSWR4ID0gMDsgaUlkeCA8IG5vZGVzQXJyYXkubGVuZ3RoOyBpSWR4KyspIHtcbiAgICAgICAgdmFyIGkgPSBub2Rlc0FycmF5W2lJZHhdO1xuICAgICAgICBpZiAoaSAhPT0gbSkge1xuICAgICAgICAgIHZhciB4X2kgPSBub2Rlc1tpXS54O1xuICAgICAgICAgIHZhciB5X2kgPSBub2Rlc1tpXS55O1xuICAgICAgICAgIHZhciBrbWF0ID0ga21baV07XG4gICAgICAgICAgdmFyIGxtYXQgPSBsbVtpXTtcbiAgICAgICAgICB2YXIgZGVub21pbmF0b3IgPSAxLjAgLyBNYXRoLnBvdyhNYXRoLnBvdyh4X20gLSB4X2ksIDIpICsgTWF0aC5wb3coeV9tIC0geV9pLCAyKSwgMS41KTtcbiAgICAgICAgICBkMkVfZHgyICs9IGttYXQgKiAoMSAtIGxtYXQgKiBNYXRoLnBvdyh5X20gLSB5X2ksIDIpICogZGVub21pbmF0b3IpO1xuICAgICAgICAgIGQyRV9keGR5ICs9IGttYXQgKiAobG1hdCAqICh4X20gLSB4X2kpICogKHlfbSAtIHlfaSkgKiBkZW5vbWluYXRvcik7XG4gICAgICAgICAgZDJFX2R5MiArPSBrbWF0ICogKDEgLSBsbWF0ICogTWF0aC5wb3coeF9tIC0geF9pLCAyKSAqIGRlbm9taW5hdG9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gbWFrZSB0aGUgdmFyaWFibGUgbmFtZXMgZWFzaWVyIHRvIG1ha2UgdGhlIHNvbHZpbmcgb2YgdGhlIGxpbmVhciBzeXN0ZW0gZWFzaWVyIHRvIHJlYWRcbiAgICAgIHZhciBBID0gZDJFX2R4MixcbiAgICAgICAgICBCID0gZDJFX2R4ZHksXG4gICAgICAgICAgQyA9IGRFX2R4LFxuICAgICAgICAgIEQgPSBkMkVfZHkyLFxuICAgICAgICAgIEUgPSBkRV9keTtcblxuICAgICAgLy8gc29sdmUgdGhlIGxpbmVhciBzeXN0ZW0gZm9yIGR4IGFuZCBkeVxuICAgICAgdmFyIGR5ID0gKEMgLyBBICsgRSAvIEIpIC8gKEIgLyBBIC0gRCAvIEIpO1xuICAgICAgdmFyIGR4ID0gLShCICogZHkgKyBDKSAvIEE7XG5cbiAgICAgIC8vIG1vdmUgdGhlIG5vZGVcbiAgICAgIG5vZGVzW21dLnggKz0gZHg7XG4gICAgICBub2Rlc1ttXS55ICs9IGR5O1xuXG4gICAgICAvLyBSZWNhbGN1bGF0ZSBFX21hdHJpeCAoc2hvdWxkIGJlIGluY3JlbWVudGFsKVxuICAgICAgdGhpcy5fdXBkYXRlRV9tYXRyaXgobSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBMIG1hdHJpeDogZWRnZSBsZW5ndGggdGltZXMgc2hvcnRlc3QgcGF0aFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBEX21hdHJpeFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19jcmVhdGVMX21hdHJpeCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVMX21hdHJpeChEX21hdHJpeCkge1xuICAgICAgdmFyIG5vZGVzQXJyYXkgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7XG4gICAgICB2YXIgZWRnZUxlbmd0aCA9IHRoaXMuc3ByaW5nTGVuZ3RoO1xuXG4gICAgICB0aGlzLkxfbWF0cml4ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5MX21hdHJpeFtub2Rlc0FycmF5W2ldXSA9IHt9O1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vZGVzQXJyYXkubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB0aGlzLkxfbWF0cml4W25vZGVzQXJyYXlbaV1dW25vZGVzQXJyYXlbal1dID0gZWRnZUxlbmd0aCAqIERfbWF0cml4W25vZGVzQXJyYXlbaV1dW25vZGVzQXJyYXlbal1dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBLIG1hdHJpeDogc3ByaW5nIGNvbnN0YW50cyB0aW1lcyBzaG9ydGVzdCBwYXRoXG4gICAgICogQHBhcmFtIHtPYmplY3R9IERfbWF0cml4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2NyZWF0ZUtfbWF0cml4JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUtfbWF0cml4KERfbWF0cml4KSB7XG4gICAgICB2YXIgbm9kZXNBcnJheSA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcztcbiAgICAgIHZhciBlZGdlU3RyZW5ndGggPSB0aGlzLnNwcmluZ0NvbnN0YW50O1xuXG4gICAgICB0aGlzLktfbWF0cml4ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5LX21hdHJpeFtub2Rlc0FycmF5W2ldXSA9IHt9O1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vZGVzQXJyYXkubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB0aGlzLktfbWF0cml4W25vZGVzQXJyYXlbaV1dW25vZGVzQXJyYXlbal1dID0gZWRnZVN0cmVuZ3RoICogTWF0aC5wb3coRF9tYXRyaXhbbm9kZXNBcnJheVtpXV1bbm9kZXNBcnJheVtqXV0sIC0yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBDcmVhdGUgbWF0cml4IHdpdGggYWxsIGVuZXJnaWVzIGJldHdlZW4gbm9kZXNcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2NyZWF0ZUVfbWF0cml4JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUVfbWF0cml4KCkge1xuICAgICAgdmFyIG5vZGVzQXJyYXkgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICB0aGlzLkVfbWF0cml4ID0ge307XG4gICAgICB0aGlzLkVfc3VtcyA9IHt9O1xuICAgICAgZm9yICh2YXIgbUlkeCA9IDA7IG1JZHggPCBub2Rlc0FycmF5Lmxlbmd0aDsgbUlkeCsrKSB7XG4gICAgICAgIHRoaXMuRV9tYXRyaXhbbm9kZXNBcnJheVttSWR4XV0gPSBbXTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIF9tSWR4ID0gMDsgX21JZHggPCBub2Rlc0FycmF5Lmxlbmd0aDsgX21JZHgrKykge1xuICAgICAgICB2YXIgbSA9IG5vZGVzQXJyYXlbX21JZHhdO1xuICAgICAgICB2YXIgeF9tID0gbm9kZXNbbV0ueDtcbiAgICAgICAgdmFyIHlfbSA9IG5vZGVzW21dLnk7XG4gICAgICAgIHZhciBkRV9keCA9IDA7XG4gICAgICAgIHZhciBkRV9keSA9IDA7XG4gICAgICAgIGZvciAodmFyIGlJZHggPSBfbUlkeDsgaUlkeCA8IG5vZGVzQXJyYXkubGVuZ3RoOyBpSWR4KyspIHtcbiAgICAgICAgICB2YXIgaSA9IG5vZGVzQXJyYXlbaUlkeF07XG4gICAgICAgICAgaWYgKGkgIT09IG0pIHtcbiAgICAgICAgICAgIHZhciB4X2kgPSBub2Rlc1tpXS54O1xuICAgICAgICAgICAgdmFyIHlfaSA9IG5vZGVzW2ldLnk7XG4gICAgICAgICAgICB2YXIgZGVub21pbmF0b3IgPSAxLjAgLyBNYXRoLnNxcnQoTWF0aC5wb3coeF9tIC0geF9pLCAyKSArIE1hdGgucG93KHlfbSAtIHlfaSwgMikpO1xuICAgICAgICAgICAgdGhpcy5FX21hdHJpeFttXVtpSWR4XSA9IFt0aGlzLktfbWF0cml4W21dW2ldICogKHhfbSAtIHhfaSAtIHRoaXMuTF9tYXRyaXhbbV1baV0gKiAoeF9tIC0geF9pKSAqIGRlbm9taW5hdG9yKSwgdGhpcy5LX21hdHJpeFttXVtpXSAqICh5X20gLSB5X2kgLSB0aGlzLkxfbWF0cml4W21dW2ldICogKHlfbSAtIHlfaSkgKiBkZW5vbWluYXRvcildO1xuICAgICAgICAgICAgdGhpcy5FX21hdHJpeFtpXVtfbUlkeF0gPSB0aGlzLkVfbWF0cml4W21dW2lJZHhdO1xuICAgICAgICAgICAgZEVfZHggKz0gdGhpcy5FX21hdHJpeFttXVtpSWR4XVswXTtcbiAgICAgICAgICAgIGRFX2R5ICs9IHRoaXMuRV9tYXRyaXhbbV1baUlkeF1bMV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vU3RvcmUgc3VtXG4gICAgICAgIHRoaXMuRV9zdW1zW21dID0gW2RFX2R4LCBkRV9keV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIG1ldGhvZCwganVzdCBkb2luZyBzaW5nbGUgY29sdW1uIChyb3dzIGFyZSBhdXRvLXVwZGF0ZWQpICh1cGRhdGUgYWxsIHN1bXMpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ191cGRhdGVFX21hdHJpeCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVFX21hdHJpeChtKSB7XG4gICAgICB2YXIgbm9kZXNBcnJheSA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcztcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIHZhciBjb2xtID0gdGhpcy5FX21hdHJpeFttXTtcbiAgICAgIHZhciBrY29sbSA9IHRoaXMuS19tYXRyaXhbbV07XG4gICAgICB2YXIgbGNvbG0gPSB0aGlzLkxfbWF0cml4W21dO1xuICAgICAgdmFyIHhfbSA9IG5vZGVzW21dLng7XG4gICAgICB2YXIgeV9tID0gbm9kZXNbbV0ueTtcbiAgICAgIHZhciBkRV9keCA9IDA7XG4gICAgICB2YXIgZEVfZHkgPSAwO1xuICAgICAgZm9yICh2YXIgaUlkeCA9IDA7IGlJZHggPCBub2Rlc0FycmF5Lmxlbmd0aDsgaUlkeCsrKSB7XG4gICAgICAgIHZhciBpID0gbm9kZXNBcnJheVtpSWR4XTtcbiAgICAgICAgaWYgKGkgIT09IG0pIHtcbiAgICAgICAgICAvL0tlZXAgb2xkIGVuZXJneSB2YWx1ZSBmb3Igc3VtIG1vZGlmaWNhdGlvbiBiZWxvd1xuICAgICAgICAgIHZhciBjZWxsID0gY29sbVtpSWR4XTtcbiAgICAgICAgICB2YXIgb2xkRHggPSBjZWxsWzBdO1xuICAgICAgICAgIHZhciBvbGREeSA9IGNlbGxbMV07XG5cbiAgICAgICAgICAvL0NhbGMgbmV3IGVuZXJneTpcbiAgICAgICAgICB2YXIgeF9pID0gbm9kZXNbaV0ueDtcbiAgICAgICAgICB2YXIgeV9pID0gbm9kZXNbaV0ueTtcbiAgICAgICAgICB2YXIgZGVub21pbmF0b3IgPSAxLjAgLyBNYXRoLnNxcnQoTWF0aC5wb3coeF9tIC0geF9pLCAyKSArIE1hdGgucG93KHlfbSAtIHlfaSwgMikpO1xuICAgICAgICAgIHZhciBkeCA9IGtjb2xtW2ldICogKHhfbSAtIHhfaSAtIGxjb2xtW2ldICogKHhfbSAtIHhfaSkgKiBkZW5vbWluYXRvcik7XG4gICAgICAgICAgdmFyIGR5ID0ga2NvbG1baV0gKiAoeV9tIC0geV9pIC0gbGNvbG1baV0gKiAoeV9tIC0geV9pKSAqIGRlbm9taW5hdG9yKTtcbiAgICAgICAgICBjb2xtW2lJZHhdID0gW2R4LCBkeV07XG4gICAgICAgICAgZEVfZHggKz0gZHg7XG4gICAgICAgICAgZEVfZHkgKz0gZHk7XG5cbiAgICAgICAgICAvL2FkZCBuZXcgZW5lcmd5IHRvIHN1bSBvZiBlYWNoIGNvbHVtblxuICAgICAgICAgIHZhciBzdW0gPSB0aGlzLkVfc3Vtc1tpXTtcbiAgICAgICAgICBzdW1bMF0gKz0gZHggLSBvbGREeDtcbiAgICAgICAgICBzdW1bMV0gKz0gZHkgLSBvbGREeTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy9TdG9yZSBzdW0gYXQgLTEgaW5kZXhcbiAgICAgIHRoaXMuRV9zdW1zW21dID0gW2RFX2R4LCBkRV9keV07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBLYW1hZGFLYXdhaTtcbn0oKTsgLy8gZGlzdGFuY2UgZmluZGluZyBhbGdvcml0aG1cblxuXG5leHBvcnRzWydkZWZhdWx0J10gPSBLYW1hZGFLYXdhaTtcblxuLyoqKi8gfSksXG4vKiAxOTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuLyoqXG4gKiAgVGhlIEZsb3lk4oCTV2Fyc2hhbGwgYWxnb3JpdGhtIGlzIGFuIGFsZ29yaXRobSBmb3IgZmluZGluZyBzaG9ydGVzdCBwYXRocyBpblxuICogIGEgd2VpZ2h0ZWQgZ3JhcGggd2l0aCBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBlZGdlIHdlaWdodHMgKGJ1dCB3aXRoIG5vIG5lZ2F0aXZlXG4gKiAgY3ljbGVzKS4gLSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GbG95ZOKAk1dhcnNoYWxsX2FsZ29yaXRobVxuICovXG52YXIgRmxveWRXYXJzaGFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGZ1bmN0aW9uIEZsb3lkV2Fyc2hhbGwoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazNbXCJkZWZhdWx0XCJdKSh0aGlzLCBGbG95ZFdhcnNoYWxsKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0FycmF5LjxOb2RlPn0gbm9kZXNBcnJheVxuICAgKiBAcGFyYW0ge0FycmF5LjxFZGdlPn0gZWRnZXNBcnJheVxuICAgKiBAcmV0dXJucyB7e319XG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczNbXCJkZWZhdWx0XCJdKShGbG95ZFdhcnNoYWxsLCBbe1xuICAgIGtleTogXCJnZXREaXN0YW5jZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGlzdGFuY2VzKGJvZHksIG5vZGVzQXJyYXksIGVkZ2VzQXJyYXkpIHtcbiAgICAgIHZhciBEX21hdHJpeCA9IHt9O1xuICAgICAgdmFyIGVkZ2VzID0gYm9keS5lZGdlcztcblxuICAgICAgLy8gcHJlcGFyZSBtYXRyaXggd2l0aCBsYXJnZSBudW1iZXJzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc0FycmF5W2ldO1xuICAgICAgICB2YXIgY2VsbCA9IHt9O1xuICAgICAgICBEX21hdHJpeFtub2RlXSA9IGNlbGw7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm9kZXNBcnJheS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNlbGxbbm9kZXNBcnJheVtqXV0gPSBpID09IGogPyAwIDogMWU5O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHB1dCB0aGUgd2VpZ2h0cyBmb3IgdGhlIGVkZ2VzIGluLiBUaGlzIGFzc3VtZXMgdW5pZGlyZWN0aW9uYWxpdHkuXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZWRnZXNBcnJheS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tlZGdlc0FycmF5W19pXV07XG4gICAgICAgIC8vIGVkZ2UgaGFzIHRvIGJlIGNvbm5lY3RlZCBpZiBpdCBjb3VudHMgdG8gdGhlIGRpc3RhbmNlcy4gSWYgaXQgaXMgY29ubmVjdGVkIHRvIGlubmVyIGNsdXN0ZXJzIGl0IHdpbGwgY3Jhc2ggc28gd2UgYWxzbyBjaGVjayBpZiBpdCBpcyBpbiB0aGUgRF9tYXRyaXhcbiAgICAgICAgaWYgKGVkZ2UuY29ubmVjdGVkID09PSB0cnVlICYmIERfbWF0cml4W2VkZ2UuZnJvbUlkXSAhPT0gdW5kZWZpbmVkICYmIERfbWF0cml4W2VkZ2UudG9JZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIERfbWF0cml4W2VkZ2UuZnJvbUlkXVtlZGdlLnRvSWRdID0gMTtcbiAgICAgICAgICBEX21hdHJpeFtlZGdlLnRvSWRdW2VkZ2UuZnJvbUlkXSA9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG5vZGVDb3VudCA9IG5vZGVzQXJyYXkubGVuZ3RoO1xuXG4gICAgICAvLyBBZGFwdGVkIEZsb3lkV2Fyc2hhbGwgYmFzZWQgb24gdW5pZGlyZWN0aW9uYWxpdHkgdG8gZ3JlYXRseSByZWR1Y2UgY29tcGxleGl0eS5cbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbm9kZUNvdW50OyBrKyspIHtcbiAgICAgICAgdmFyIGtub2RlID0gbm9kZXNBcnJheVtrXTtcbiAgICAgICAgdmFyIGtjb2xtID0gRF9tYXRyaXhba25vZGVdO1xuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBub2RlQ291bnQgLSAxOyBfaTIrKykge1xuICAgICAgICAgIHZhciBpbm9kZSA9IG5vZGVzQXJyYXlbX2kyXTtcbiAgICAgICAgICB2YXIgaWNvbG0gPSBEX21hdHJpeFtpbm9kZV07XG4gICAgICAgICAgZm9yICh2YXIgX2ogPSBfaTIgKyAxOyBfaiA8IG5vZGVDb3VudDsgX2orKykge1xuICAgICAgICAgICAgdmFyIGpub2RlID0gbm9kZXNBcnJheVtfal07XG4gICAgICAgICAgICB2YXIgamNvbG0gPSBEX21hdHJpeFtqbm9kZV07XG5cbiAgICAgICAgICAgIHZhciB2YWwgPSBNYXRoLm1pbihpY29sbVtqbm9kZV0sIGljb2xtW2tub2RlXSArIGtjb2xtW2pub2RlXSk7XG4gICAgICAgICAgICBpY29sbVtqbm9kZV0gPSB2YWw7XG4gICAgICAgICAgICBqY29sbVtpbm9kZV0gPSB2YWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBEX21hdHJpeDtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEZsb3lkV2Fyc2hhbGw7XG59KCk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gRmxveWRXYXJzaGFsbDtcblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12aXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9