"use strict";
(self["webpackChunkgrafana"] = self["webpackChunkgrafana"] || []).push([["canvasPanel"],{

/***/ "./public/app/core/components/Layers/AddLayerButton.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AddLayerButton": () => (/* binding */ AddLayerButton)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");



const AddLayerButton = ({
  onChange,
  options,
  label
}) => {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.ValuePicker, {
    icon: "plus",
    label: label,
    variant: "secondary",
    options: options,
    onChange: onChange,
    isFullWidth: true
  });
};

/***/ }),

/***/ "./public/app/core/components/Layers/LayerDragDropList.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LayerDragDropList": () => (/* binding */ LayerDragDropList)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/__virtual__/react-beautiful-dnd-virtual-27e4b658e7/0/cache/react-beautiful-dnd-npm-13.1.0-fcf5568b1c-12b7e9fbe8.zip/node_modules/react-beautiful-dnd/dist/react-beautiful-dnd.esm.js");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _LayerName__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/core/components/Layers/LayerName.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");









const LayerDragDropList = ({
  layers,
  getLayerInfo,
  onDragEnd,
  onSelect,
  onDelete,
  onDuplicate,
  isFrame,
  selection,
  excludeBaseLayer,
  onNameChange,
  verifyLayerNameUniqueness
}) => {
  const style = styles(_grafana_runtime__WEBPACK_IMPORTED_MODULE_2__.config.theme);

  const getRowStyle = isSelected => {
    return isSelected ? `${style.row} ${style.sel}` : style.row;
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_6__.DragDropContext, {
    onDragEnd: onDragEnd,
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_6__.Droppable, {
      droppableId: "droppable",
      children: (provided, snapshot) => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", Object.assign({}, provided.droppableProps, {
        ref: provided.innerRef,
        children: [(() => {
          // reverse order
          const rows = [];
          const lastLayerIndex = excludeBaseLayer ? 1 : 0;
          const shouldRenderDragIconLengthThreshold = excludeBaseLayer ? 2 : 1;

          for (let i = layers.length - 1; i >= lastLayerIndex; i--) {
            const element = layers[i];
            const uid = element.getName();
            const isSelected = Boolean(selection === null || selection === void 0 ? void 0 : selection.includes(uid));
            rows.push( /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_6__.Draggable, {
              draggableId: uid,
              index: rows.length,
              children: (provided, snapshot) => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", Object.assign({
                className: getRowStyle(isSelected),
                ref: provided.innerRef
              }, provided.draggableProps, provided.dragHandleProps, {
                onMouseDown: () => onSelect(element),
                children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_LayerName__WEBPACK_IMPORTED_MODULE_4__.LayerName, {
                  name: uid,
                  onChange: v => onNameChange(element, v),
                  verifyLayerNameUniqueness: verifyLayerNameUniqueness !== null && verifyLayerNameUniqueness !== void 0 ? verifyLayerNameUniqueness : undefined
                }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
                  className: style.textWrapper,
                  children: ["\xA0 ", getLayerInfo(element)]
                }), isFrame(element) && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
                  children: [onDuplicate ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.IconButton, {
                    name: "copy",
                    title: 'Duplicate',
                    className: style.actionIcon,
                    onClick: () => onDuplicate(element),
                    surface: "header"
                  }) : null, /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.IconButton, {
                    name: "trash-alt",
                    title: 'remove',
                    className: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.cx)(style.actionIcon, style.dragIcon),
                    onClick: () => onDelete(element),
                    surface: "header"
                  }), layers.length > shouldRenderDragIconLengthThreshold && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Icon, {
                    title: "Drag and drop to reorder",
                    name: "draggabledots",
                    size: "lg",
                    className: style.dragIcon
                  })]
                })]
              }))
            }, uid));
          }

          return rows;
        })(), provided.placeholder]
      }))
    })
  });
};
LayerDragDropList.defaultProps = {
  isGroup: () => false
};
const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.stylesFactory)(theme => ({
  wrapper: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    margin-bottom: ${theme.spacing.md};
  `,
  row: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    padding: ${theme.spacing.xs} ${theme.spacing.sm};
    border-radius: ${theme.border.radius.sm};
    background: ${theme.colors.bg2};
    min-height: ${theme.spacing.formInputHeight}px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 3px;
    cursor: pointer;

    border: 1px solid ${theme.colors.formInputBorder};
    &:hover {
      border: 1px solid ${theme.colors.formInputBorderHover};
    }
  `,
  sel: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    border: 1px solid ${theme.colors.formInputBorderActive};
    &:hover {
      border: 1px solid ${theme.colors.formInputBorderActive};
    }
  `,
  dragIcon: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    cursor: drag;
  `,
  actionIcon: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    color: ${theme.colors.textWeak};
    &:hover {
      color: ${theme.colors.text};
    }
  `,
  typeWrapper: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    color: ${theme.colors.textBlue};
    margin-right: 5px;
  `,
  textWrapper: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    display: flex;
    align-items: center;
    flex-grow: 1;
    overflow: hidden;
    margin-right: ${theme.spacing.sm};
  `
}));

/***/ }),

/***/ "./public/app/core/components/Layers/LayerName.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LayerName": () => (/* binding */ LayerName)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");






const LayerName = ({
  name,
  onChange,
  verifyLayerNameUniqueness
}) => {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.useStyles)(getStyles);
  const [isEditing, setIsEditing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);
  const [validationError, setValidationError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);

  const onEditLayer = event => {
    setIsEditing(true);
  };

  const onEndEditName = newName => {
    setIsEditing(false);

    if (validationError) {
      setValidationError(null);
      return;
    }

    if (name !== newName) {
      onChange(newName);
    }
  };

  const onInputChange = event => {
    const newName = event.currentTarget.value.trim();

    if (newName.length === 0) {
      setValidationError('An empty layer name is not allowed');
      return;
    }

    if (verifyLayerNameUniqueness && !verifyLayerNameUniqueness(newName) && newName !== name) {
      setValidationError('Layer name already exists');
      return;
    }

    if (validationError) {
      setValidationError(null);
    }
  };

  const onEditLayerBlur = event => {
    onEndEditName(event.currentTarget.value.trim());
  };

  const onKeyDown = event => {
    if (event.key === 'Enter') {
      onEndEditName(event.target.value);
    }
  };

  const onFocus = event => {
    event.target.select();
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.Fragment, {
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)("div", {
      className: styles.wrapper,
      children: [!isEditing && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)("button", {
        className: styles.layerNameWrapper,
        title: "Edit layer name",
        onClick: onEditLayer,
        "data-testid": "layer-name-div",
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("span", {
          className: styles.layerName,
          children: name
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Icon, {
          name: "pen",
          className: styles.layerEditIcon,
          size: "sm"
        })]
      }), isEditing && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.Fragment, {
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Input, {
          type: "text",
          defaultValue: name,
          onBlur: onEditLayerBlur,
          autoFocus: true,
          onKeyDown: onKeyDown,
          onFocus: onFocus,
          invalid: validationError !== null,
          onChange: onInputChange,
          className: styles.layerNameInput,
          "data-testid": "layer-name-input"
        }), validationError && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.FieldValidationMessage, {
          horizontal: true,
          children: validationError
        })]
      })]
    })
  });
};

const getStyles = theme => {
  return {
    wrapper: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
      label: Wrapper;
      display: flex;
      align-items: center;
      margin-left: ${theme.spacing.xs};
    `,
    layerNameWrapper: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
      display: flex;
      cursor: pointer;
      border: 1px solid transparent;
      border-radius: ${theme.border.radius.md};
      align-items: center;
      padding: 0 0 0 ${theme.spacing.xs};
      margin: 0;
      background: transparent;

      &:hover {
        background: ${theme.colors.bg3};
        border: 1px dashed ${theme.colors.border3};
      }

      &:focus {
        border: 2px solid ${theme.colors.formInputBorderActive};
      }

      &:hover,
      &:focus {
        .query-name-edit-icon {
          visibility: visible;
        }
      }
    `,
    layerName: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
      font-weight: ${theme.typography.weight.semibold};
      color: ${theme.colors.textBlue};
      cursor: pointer;
      overflow: hidden;
      margin-left: ${theme.spacing.xs};
    `,
    layerEditIcon: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.cx)(_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
        margin-left: ${theme.spacing.md};
        visibility: hidden;
      `, 'query-name-edit-icon'),
    layerNameInput: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
      max-width: 300px;
      margin: -4px 0;
    `
  };
};

/***/ }),

/***/ "./public/app/features/canvas/element.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);


/***/ }),

/***/ "./public/app/features/canvas/elements/button.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "buttonItem": () => (/* binding */ buttonItem)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_features_dimensions_editors_TextDimensionEditor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/dimensions/editors/TextDimensionEditor.tsx");
/* harmony import */ var app_plugins_panel_canvas_editor_APIEditor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/panel/canvas/editor/APIEditor.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");






class ButtonDisplay extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {
  render() {
    const {
      data
    } = this.props;

    const onClick = () => {
      if (data !== null && data !== void 0 && data.api) {
        (0,app_plugins_panel_canvas_editor_APIEditor__WEBPACK_IMPORTED_MODULE_3__.callApi)(data.api);
      }
    };

    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Button, {
      type: "submit",
      onClick: onClick,
      children: data === null || data === void 0 ? void 0 : data.text
    });
  }

}

const buttonItem = {
  id: 'button',
  name: 'Button',
  description: 'Button',
  display: ButtonDisplay,
  defaultSize: {
    width: 200,
    height: 50
  },
  getNewOptions: options => Object.assign({}, options),
  // Called when data changes
  prepareData: (ctx, cfg) => {
    var _cfg$api;

    const data = {
      text: cfg !== null && cfg !== void 0 && cfg.text ? ctx.getText(cfg.text).value() : '',
      api: (_cfg$api = cfg === null || cfg === void 0 ? void 0 : cfg.api) !== null && _cfg$api !== void 0 ? _cfg$api : undefined
    };
    return data;
  },
  // Heatmap overlay options
  registerOptionsUI: builder => {
    const category = ['Button'];
    builder.addCustomEditor({
      category,
      id: 'textSelector',
      path: 'config.text',
      name: 'Text',
      editor: app_features_dimensions_editors_TextDimensionEditor__WEBPACK_IMPORTED_MODULE_2__.TextDimensionEditor
    }).addCustomEditor({
      category,
      id: 'apiSelector',
      path: 'config.api',
      name: 'API',
      editor: app_plugins_panel_canvas_editor_APIEditor__WEBPACK_IMPORTED_MODULE_3__.APIEditor
    });
  }
};

/***/ }),

/***/ "./public/app/features/canvas/elements/droneFront.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "droneFrontItem": () => (/* binding */ droneFrontItem)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/features/dimensions/editors/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _g, _g2, _g3, _g4;








const DroneFrontDisplay = props => {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.useStyles2)(getStyles);
  const {
    data
  } = props;
  const droneFrontTransformStyle = `rotate(${data !== null && data !== void 0 && data.rollAngle ? data.rollAngle : 0}deg)`;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("svg", {
    className: styles.droneFront,
    xmlns: "http://www.w3.org/2000/svg",
    xmlnsXlink: "http://www.w3.org/1999/xlink",
    viewBox: "0 0 1300 290",
    style: {
      transform: droneFrontTransformStyle
    },
    children: [_g || (_g = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("g", {
      className: "arms",
      stroke: "black",
      strokeWidth: "28px",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("line", {
        x1: "510",
        x2: "320",
        y1: "100",
        y2: "150"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("line", {
        x1: "510",
        x2: "320",
        y1: "190",
        y2: "210"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("line", {
        x1: "790",
        x2: "980",
        y1: "190",
        y2: "210"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("line", {
        x1: "790",
        x2: "980",
        y1: "100",
        y2: "150"
      })]
    })), _g2 || (_g2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("g", {
      className: "body",
      stroke: "black",
      strokeWidth: "28px",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        fill: "none",
        d: " M 510 130 C 510 124 510 110 510 100 C 510 90 530 71 540 70 C 640 61 670 60 760 70 C 770 71 790 90 790 100 Q 790 120 790 130 L 790 130 Q 790 177 790 196 C 790 207 770 225 760 226 C 670 236 640 236 540 226 C 530 226 510 206 510 196 Q 510 177 510 130 Q 510 133 510 130 Z "
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("circle", {
        cx: "650",
        cy: "160",
        r: "40",
        fill: "none"
      })]
    })), _g3 || (_g3 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("g", {
      className: "motors",
      stroke: "black",
      strokeWidth: "28px",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        className: "motor",
        fill: "none",
        d: " M 320 60 L 250 60 L 250 230 L 260 290 L 310 290 L 320 230 L 320 60 Z "
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        className: "motor",
        fill: "none",
        d: " M 1050 60 L 980 60 L 980 230 L 990 290 L 1040 290 L 1050 230 L 1050 60 Z "
      })]
    })), _g4 || (_g4 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("g", {
      className: "propellers",
      fill: "black",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        className: "prop",
        d: " M 270 60 L 300 60 L 300 20 Q 311 30 330 30 Q 349 30 570 10 L 300 10 Q 300 0 290 0 C 286 0 284 0 280 0 Q 270 0 270 10 L 0 10 Q 220 30 240 30 Q 260 30 270 20 L 270 60 Z "
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        className: "prop",
        d: " M 1000 60 L 1030 60 L 1030 20 Q 1041 30 1060 30 Q 1079 30 1300 10 L 1030 10 Q 1030 0 1020 0 C 1016 0 1014 0 1010 0 Q 1000 0 1000 10 L 730 10 Q 950 30 970 30 Q 990 30 1000 20 L 1000 60 Z "
      })]
    }))]
  });
};

const droneFrontItem = {
  id: 'droneFront',
  name: 'Drone Front',
  description: 'Drone front',
  display: DroneFrontDisplay,
  defaultSize: {
    width: 100,
    height: 100
  },
  getNewOptions: options => Object.assign({}, options),
  // Called when data changes
  prepareData: (ctx, cfg) => {
    const data = {
      rollAngle: cfg !== null && cfg !== void 0 && cfg.rollAngle ? ctx.getScalar(cfg.rollAngle).value() : 0
    };
    return data;
  },
  registerOptionsUI: builder => {
    const category = ['Drone Front'];
    builder.addCustomEditor({
      category,
      id: 'rollAngle',
      path: 'config.rollAngle',
      name: 'Roll Angle',
      editor: app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_3__.ScalarDimensionEditor
    });
  }
};

const getStyles = theme => ({
  droneFront: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    transition: transform 0.4s;
  `
});

/***/ }),

/***/ "./public/app/features/canvas/elements/droneSide.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "droneSideItem": () => (/* binding */ droneSideItem)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/features/dimensions/editors/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _g, _g2, _g3, _g4;








const DroneSideDisplay = props => {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.useStyles2)(getStyles);
  const {
    data
  } = props;
  const droneSidePitchTransformStyle = `rotate(${data !== null && data !== void 0 && data.pitchAngle ? data.pitchAngle : 0}deg)`;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("svg", {
    className: styles.droneSide,
    xmlns: "http://www.w3.org/2000/svg",
    xmlnsXlink: "http://www.w3.org/1999/xlink",
    viewBox: "0 0 1300 290",
    style: {
      transform: droneSidePitchTransformStyle
    },
    children: [_g || (_g = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("g", {
      className: "arms",
      stroke: "black",
      strokeWidth: "28px",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("line", {
        x1: "510",
        x2: "320",
        y1: "100",
        y2: "150"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("line", {
        x1: "510",
        x2: "320",
        y1: "190",
        y2: "210"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("line", {
        x1: "790",
        x2: "980",
        y1: "190",
        y2: "210"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("line", {
        x1: "790",
        x2: "980",
        y1: "100",
        y2: "150"
      })]
    })), _g2 || (_g2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("g", {
      className: "body",
      stroke: "black",
      strokeWidth: "28px",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        fill: "none",
        d: " M 510 130 C 510 124 510 110 510 100 C 510 90 530 71 540 70 C 640 61 670 60 760 70 C 770 71 790 90 790 100 Q 790 120 790 130 L 790 130 Q 790 177 790 196 C 790 207 770 225 760 226 C 670 236 640 236 540 226 C 530 226 510 206 510 196 Q 510 177 510 130 Q 510 133 510 130 Z "
      })
    })), _g3 || (_g3 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("g", {
      className: "motors",
      stroke: "black",
      strokeWidth: "28px",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        className: "motor",
        fill: "none",
        d: " M 320 60 L 250 60 L 250 230 L 260 290 L 310 290 L 320 230 L 320 60 Z "
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        className: "motor",
        fill: "none",
        d: " M 1050 60 L 980 60 L 980 230 L 990 290 L 1040 290 L 1050 230 L 1050 60 Z "
      })]
    })), _g4 || (_g4 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("g", {
      className: "propellers",
      fill: "black",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        className: "prop",
        d: " M 270 60 L 300 60 L 300 20 Q 311 30 330 30 Q 349 30 570 10 L 300 10 Q 300 0 290 0 C 286 0 284 0 280 0 Q 270 0 270 10 L 0 10 Q 220 30 240 30 Q 260 30 270 20 L 270 60 Z "
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        className: "prop",
        d: " M 1000 60 L 1030 60 L 1030 20 Q 1041 30 1060 30 Q 1079 30 1300 10 L 1030 10 Q 1030 0 1020 0 C 1016 0 1014 0 1010 0 Q 1000 0 1000 10 L 730 10 Q 950 30 970 30 Q 990 30 1000 20 L 1000 60 Z "
      })]
    }))]
  });
};

const droneSideItem = {
  id: 'droneSide',
  name: 'Drone Side',
  description: 'Drone Side',
  display: DroneSideDisplay,
  defaultSize: {
    width: 100,
    height: 100
  },
  getNewOptions: options => Object.assign({}, options),
  // Called when data changes
  prepareData: (ctx, cfg) => {
    const data = {
      pitchAngle: cfg !== null && cfg !== void 0 && cfg.pitchAngle ? ctx.getScalar(cfg.pitchAngle).value() : 0
    };
    return data;
  },
  registerOptionsUI: builder => {
    const category = ['Drone Side'];
    builder.addCustomEditor({
      category,
      id: 'pitchAngle',
      path: 'config.pitchAngle',
      name: 'Pitch Angle',
      editor: app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_3__.ScalarDimensionEditor
    });
  }
};

const getStyles = theme => ({
  droneSide: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    transition: transform 0.4s;
  `
});

/***/ }),

/***/ "./public/app/features/canvas/elements/droneTop.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "droneTopItem": () => (/* binding */ droneTopItem)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/features/dimensions/editors/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _path, _path2;








const DroneTopDisplay = props => {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.useStyles2)(getStyles);
  const {
    data
  } = props;
  const fRightRotorAnimation = `spin ${data !== null && data !== void 0 && data.fRightRotorRPM ? 60 / Math.abs(data.fRightRotorRPM) : 0}s linear infinite`;
  const fLeftRotorAnimation = `spin ${data !== null && data !== void 0 && data.fLeftRotorRPM ? 60 / Math.abs(data.fLeftRotorRPM) : 0}s linear infinite`;
  const bRightRotorAnimation = `spin ${data !== null && data !== void 0 && data.bRightRotorRPM ? 60 / Math.abs(data.bRightRotorRPM) : 0}s linear infinite`;
  const bLeftRotorAnimation = `spin ${data !== null && data !== void 0 && data.bLeftRotorRPM ? 60 / Math.abs(data.bLeftRotorRPM) : 0}s linear infinite`;
  const droneTopTransformStyle = `rotate(${data !== null && data !== void 0 && data.yawAngle ? data.yawAngle : 0}deg)`;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    xmlnsXlink: "http://www.w3.org/1999/xlink",
    viewBox: "-43 -43 640 640",
    xmlSpace: "preserve",
    style: {
      transform: droneTopTransformStyle
    },
    children: [_path || (_path = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
      fillRule: "evenodd",
      d: " M 137.95 127.967 C 137.14 127.157 136.189 126.58 135.178 126.218 C 138.173 121.545 139.967 116.036 140.125 110.123 L 217.64 151.862 C 214.049 157.411 211.8 163.922 211.386 170.95 L 209.694 199.712 L 137.95 127.967 L 137.95 127.967 L 137.95 127.967 L 137.95 127.967 L 137.95 127.967 L 137.95 127.967 L 137.95 127.967 L 137.95 127.967 L 137.95 127.967 Z  M 134.268 426.981 C 130.211 421.314 124.328 417.045 117.482 415.041 L 201.999 330.523 L 201.385 340.955 C 200.67 353.107 202.829 364.914 207.563 375.673 L 134.268 426.981 L 134.268 426.981 L 134.268 426.981 L 134.268 426.981 L 134.268 426.981 L 134.268 426.981 L 134.268 426.981 L 134.268 426.981 Z  M 324.765 373.673 L 228.527 373.673 Q 215.374 358.611 216.361 341.835 L 226.361 171.832 C 226.825 163.94 231.012 157.096 237.146 152.957 L 316.146 152.957 C 322.28 157.096 326.466 163.94 326.931 171.832 L 336.931 341.835 Q 337.918 358.611 324.765 373.673 L 324.765 373.673 L 324.765 373.673 L 324.765 373.673 L 324.765 373.673 L 324.765 373.673 L 324.765 373.673 Z  M 435.81 415.041 C 428.964 417.045 423.081 421.314 419.024 426.981 L 345.727 375.673 C 350.461 364.914 352.62 353.107 351.905 340.955 L 351.291 330.523 L 435.81 415.041 L 435.81 415.041 L 435.81 415.041 L 435.81 415.041 L 435.81 415.041 L 435.81 415.041 Z  M 343.596 199.713 L 341.904 170.951 C 341.49 163.923 339.242 157.411 335.651 151.863 L 413.167 110.124 C 413.325 116.037 415.119 121.546 418.114 126.219 C 417.103 126.581 416.152 127.158 415.342 127.968 L 343.596 199.713 L 343.596 199.713 L 343.596 199.713 L 343.596 199.713 L 343.596 199.713 Z  M 444.646 92.771 C 453.744 92.771 461.146 100.172 461.146 109.271 C 461.146 118.369 453.744 125.771 444.646 125.771 C 435.548 125.771 428.146 118.369 428.146 109.271 C 428.146 100.172 435.548 92.771 444.646 92.771 L 444.646 92.771 L 444.646 92.771 L 444.646 92.771 Z  M 108.647 92.771 C 117.745 92.771 125.147 100.172 125.147 109.271 C 125.147 118.369 117.745 125.771 108.647 125.771 C 99.549 125.771 92.147 118.369 92.147 109.271 C 92.147 100.172 99.549 92.771 108.647 92.771 L 108.647 92.771 L 108.647 92.771 Z  M 108.647 461.771 C 99.549 461.771 92.147 454.369 92.147 445.271 C 92.147 436.172 99.549 428.771 108.647 428.771 C 117.745 428.771 125.147 436.172 125.147 445.271 C 125.147 454.369 117.745 461.771 108.647 461.771 L 108.647 461.771 Z  M 92.322 136.202 C 97.086 139.1 102.675 140.771 108.647 140.771 C 114.883 140.771 120.697 138.941 125.594 135.802 C 125.956 136.813 126.534 137.764 127.343 138.573 L 207.342 218.573 C 207.711 218.942 208.109 219.264 208.528 219.54 L 203.212 309.908 C 201.794 310.182 200.44 310.869 199.342 311.967 L 95.343 415.967 C 94.954 416.356 94.62 416.779 94.335 417.224 C 93.651 417.575 92.976 417.942 92.322 418.34 Q 84.615 424.182 81.716 428.946 C 78.817 433.71 77.147 439.299 77.147 445.271 C 77.147 462.64 91.278 476.771 108.647 476.771 C 114.619 476.771 120.208 475.1 124.972 472.202 C 129.736 469.304 132.678 466.36 135.577 461.596 C 138.476 456.832 140.147 451.243 140.147 445.271 C 140.147 443.943 140.055 442.637 139.895 441.352 L 214.997 388.78 C 217.05 391.677 336.242 391.678 338.295 388.78 L 413.398 441.352 C 413.238 442.637 413.146 443.943 413.146 445.271 C 413.146 451.243 414.817 456.832 417.715 461.596 C 420.613 466.36 423.557 469.304 428.321 472.202 C 433.085 475.1 438.674 476.771 444.646 476.771 C 462.015 476.771 476.146 462.64 476.146 445.271 C 476.146 439.299 474.475 433.71 471.577 428.946 C 468.679 424.182 459.642 417.575 458.958 417.224 C 458.672 416.779 458.339 416.356 457.95 415.967 L 353.95 311.967 C 352.852 310.869 351.498 310.182 350.08 309.908 L 344.764 219.54 C 345.183 219.264 345.581 218.942 345.95 218.573 L 425.95 138.573 C 426.76 137.763 427.337 136.812 427.699 135.802 C 432.596 138.941 438.409 140.771 444.646 140.771 C 450.618 140.771 456.207 139.1 460.971 136.202 C 465.735 133.304 468.679 130.36 471.577 125.596 C 474.475 120.832 476.146 115.243 476.146 109.271 C 476.146 91.903 462.015 77.772 444.646 77.772 C 438.674 77.772 433.085 79.442 428.321 82.34 L 416.215 91.446 L 324.765 140.688 C 318.402 136.324 310.718 133.771 302.473 133.771 L 250.819 133.771 C 242.574 133.771 234.89 136.324 228.527 140.688 L 137.078 91.446 L 124.972 82.34 C 120.208 79.442 114.619 77.772 108.647 77.772 C 91.278 77.772 77.147 91.903 77.147 109.271 C 77.147 115.243 78.818 120.832 81.716 125.595 C 84.614 130.358 87.558 133.304 92.322 136.202 L 92.322 136.202 L 92.322 136.202 L 92.322 136.202 L 92.322 136.202 L 92.322 136.202 L 92.322 136.202 L 92.322 136.202 L 92.322 136.202 Z  M 444.646 461.771 C 435.548 461.771 428.146 454.369 428.146 445.271 C 428.146 436.172 435.548 428.771 444.646 428.771 C 453.744 428.771 461.146 436.172 461.146 445.271 C 461.146 454.369 453.744 461.771 444.646 461.771 Z "
    })), _path2 || (_path2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
      fillRule: "evenodd",
      d: " M 259.458 334.235 L 259.458 337.211 L 254.514 337.211 L 254.514 350.795 L 250.842 350.795 L 250.842 337.211 L 245.898 337.211 L 245.898 334.235 L 259.458 334.235 Z  M 266.226 347.939 L 272.586 347.939 L 272.754 350.627 L 272.754 350.627 Q 270.498 350.867 265.074 350.867 L 265.074 350.867 L 265.074 350.867 Q 263.418 350.867 262.434 349.967 L 262.434 349.967 L 262.434 349.967 Q 261.45 349.067 261.426 347.531 L 261.426 347.531 L 261.426 337.499 L 261.426 337.499 Q 261.45 335.963 262.434 335.063 L 262.434 335.063 L 262.434 335.063 Q 263.418 334.163 265.074 334.163 L 265.074 334.163 L 265.074 334.163 Q 270.498 334.163 272.754 334.403 L 272.754 334.403 L 272.586 337.115 L 266.226 337.115 L 266.226 337.115 Q 265.626 337.115 265.362 337.403 L 265.362 337.403 L 265.362 337.403 Q 265.098 337.691 265.098 338.339 L 265.098 338.339 L 265.098 340.859 L 271.698 340.859 L 271.698 343.499 L 265.098 343.499 L 265.098 346.691 L 265.098 346.691 Q 265.098 347.363 265.362 347.651 L 265.362 347.651 L 265.362 347.651 Q 265.626 347.939 266.226 347.939 L 266.226 347.939 Z  M 275.202 333.995 L 278.73 333.995 L 278.73 346.931 L 278.73 346.931 Q 278.73 348.131 280.074 348.131 L 280.074 348.131 L 281.034 348.131 L 281.442 350.603 L 281.442 350.603 Q 280.53 351.083 278.61 351.083 L 278.61 351.083 L 278.61 351.083 Q 277.026 351.083 276.114 350.231 L 276.114 350.231 L 276.114 350.231 Q 275.202 349.379 275.202 347.819 L 275.202 347.819 L 275.202 333.995 Z  M 283.05 333.995 L 286.578 333.995 L 286.578 346.931 L 286.578 346.931 Q 286.578 348.131 287.922 348.131 L 287.922 348.131 L 288.882 348.131 L 289.29 350.603 L 289.29 350.603 Q 288.378 351.083 286.458 351.083 L 286.458 351.083 L 286.458 351.083 Q 284.874 351.083 283.962 350.231 L 283.962 350.231 L 283.962 350.231 Q 283.05 349.379 283.05 347.819 L 283.05 347.819 L 283.05 333.995 Z  M 292.086 335.759 L 292.086 335.759 L 292.086 335.759 Q 293.634 333.923 297.618 333.923 L 297.618 333.923 L 297.618 333.923 Q 301.602 333.923 303.162 335.759 L 303.162 335.759 L 303.162 335.759 Q 304.722 337.595 304.722 342.515 L 304.722 342.515 L 304.722 342.515 Q 304.722 347.435 303.162 349.271 L 303.162 349.271 L 303.162 349.271 Q 301.602 351.107 297.618 351.107 L 297.618 351.107 L 297.618 351.107 Q 293.634 351.107 292.086 349.271 L 292.086 349.271 L 292.086 349.271 Q 290.538 347.435 290.538 342.515 L 290.538 342.515 L 290.538 342.515 Q 290.538 337.595 292.086 335.759 Z  M 300.174 338.051 L 300.174 338.051 L 300.174 338.051 Q 299.49 336.875 297.618 336.875 L 297.618 336.875 L 297.618 336.875 Q 295.746 336.875 295.062 338.051 L 295.062 338.051 L 295.062 338.051 Q 294.378 339.227 294.378 342.515 L 294.378 342.515 L 294.378 342.515 Q 294.378 345.803 295.062 346.979 L 295.062 346.979 L 295.062 346.979 Q 295.746 348.155 297.618 348.155 L 297.618 348.155 L 297.618 348.155 Q 299.49 348.155 300.174 346.979 L 300.174 346.979 L 300.174 346.979 Q 300.858 345.803 300.858 342.515 L 300.858 342.515 L 300.858 342.515 Q 300.858 339.227 300.174 338.051 Z "
    })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("g", {
      className: "propeller-group",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        className: `${styles.propeller} ${styles.propellerCW}`,
        style: {
          animation: bRightRotorAnimation
        },
        d: " M 461.563 418.77 L 463.992 416.34 Q 465.495 407.116 466.461 400.395 C 467.426 393.675 469.363 388.087 474.731 383.284 Q 533.862 341.514 538.196 338.859 C 542.529 336.203 548.345 334.299 551.492 338.29 C 554.639 342.282 553.481 346.02 549.419 350.082 L 471.147 428.354 L 461.563 418.77 Z  M 427.729 471.772 L 425.299 474.202 Q 423.797 483.426 422.831 490.146 C 421.866 496.867 419.929 502.454 414.561 507.257 Q 355.43 549.028 351.096 551.683 C 346.763 554.338 340.947 556.243 337.8 552.251 C 334.653 548.26 335.811 544.522 339.873 540.46 L 418.145 462.187 L 427.729 471.772 Z "
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        className: `${styles.propeller} ${styles.propellerCCW}`,
        style: {
          animation: fRightRotorAnimation
        },
        d: " M 461.563 135.773 L 463.992 138.203 Q 465.495 147.426 466.461 154.147 C 467.426 160.868 469.363 166.455 474.731 171.258 Q 533.862 213.028 538.196 215.684 C 542.529 218.339 548.345 220.244 551.492 216.252 C 554.639 212.26 553.481 208.523 549.419 204.46 L 471.147 126.188 L 461.563 135.773 Z  M 427.729 82.77 L 425.299 80.34 Q 423.797 71.117 422.831 64.396 C 421.866 57.675 419.929 52.088 414.561 47.285 Q 355.43 5.515 351.096 2.859 C 346.763 0.204 340.947 -1.701 337.8 2.291 C 334.653 6.282 335.811 10.02 339.873 14.082 L 418.145 92.355 L 427.729 82.77 Z "
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        className: `${styles.propeller} ${styles.propellerCCW}`,
        style: {
          animation: bLeftRotorAnimation
        },
        d: " M 125.563 471.772 L 127.993 474.202 Q 129.496 483.426 130.461 490.146 C 131.427 496.867 133.363 502.454 138.731 507.257 Q 197.863 549.028 202.196 551.683 C 206.53 554.338 212.345 556.243 215.492 552.251 C 218.639 548.26 217.482 544.522 213.419 540.46 L 135.148 462.187 L 125.563 471.772 Z  M 91.73 418.77 L 89.3 416.34 Q 87.797 407.116 86.832 400.395 C 85.866 393.675 83.93 388.087 78.562 383.284 Q 19.431 341.514 15.097 338.859 C 10.763 336.203 4.948 334.299 1.801 338.29 C -1.346 342.282 -0.189 346.02 3.874 350.082 L 82.146 428.354 L 91.73 418.77 Z "
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        className: `${styles.propeller} ${styles.propellerCW}`,
        style: {
          animation: fLeftRotorAnimation
        },
        d: " M 125.563 82.77 L 127.993 80.34 Q 129.496 71.117 130.461 64.396 C 131.427 57.675 133.363 52.088 138.731 47.285 Q 197.863 5.515 202.196 2.859 C 206.53 0.204 212.345 -1.701 215.492 2.291 C 218.639 6.282 217.482 10.02 213.419 14.083 L 135.147 92.355 L 125.563 82.77 Z  M 91.73 135.773 L 89.3 138.203 Q 87.797 147.426 86.832 154.147 C 85.866 160.868 83.93 166.455 78.562 171.258 Q 19.431 213.028 15.097 215.684 C 10.763 218.339 4.948 220.243 1.801 216.252 C -1.346 212.26 -0.189 208.523 3.874 204.46 L 82.146 126.188 L 91.73 135.773 Z "
      })]
    })]
  });
};

const droneTopItem = {
  id: 'droneTop',
  name: 'Drone Top',
  description: 'Drone top',
  display: DroneTopDisplay,
  defaultSize: {
    width: 100,
    height: 100
  },
  getNewOptions: options => Object.assign({}, options),
  // Called when data changes
  prepareData: (ctx, cfg) => {
    const data = {
      bRightRotorRPM: cfg !== null && cfg !== void 0 && cfg.bRightRotorRPM ? ctx.getScalar(cfg.bRightRotorRPM).value() : 0,
      bLeftRotorRPM: cfg !== null && cfg !== void 0 && cfg.bLeftRotorRPM ? ctx.getScalar(cfg.bLeftRotorRPM).value() : 0,
      fRightRotorRPM: cfg !== null && cfg !== void 0 && cfg.fRightRotorRPM ? ctx.getScalar(cfg.fRightRotorRPM).value() : 0,
      fLeftRotorRPM: cfg !== null && cfg !== void 0 && cfg.fLeftRotorRPM ? ctx.getScalar(cfg.fLeftRotorRPM).value() : 0,
      yawAngle: cfg !== null && cfg !== void 0 && cfg.yawAngle ? ctx.getScalar(cfg.yawAngle).value() : 0
    };
    return data;
  },
  registerOptionsUI: builder => {
    const category = ['Drone Top'];
    builder.addCustomEditor({
      category,
      id: 'yawAngle',
      path: 'config.yawAngle',
      name: 'Yaw Angle',
      editor: app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_3__.ScalarDimensionEditor
    }).addCustomEditor({
      category,
      id: 'fRightRotorRPM',
      path: 'config.fRightRotorRPM',
      name: 'Front Right Rotor RPM',
      editor: app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_3__.ScalarDimensionEditor
    }).addCustomEditor({
      category,
      id: 'fLeftRotorRPM',
      path: 'config.fLeftRotorRPM',
      name: 'Front Left Rotor RPM',
      editor: app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_3__.ScalarDimensionEditor
    }).addCustomEditor({
      category,
      id: 'bRightRotorRPM',
      path: 'config.bRightRotorRPM',
      name: 'Back Right Rotor RPM',
      editor: app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_3__.ScalarDimensionEditor
    }).addCustomEditor({
      category,
      id: 'bLeftRotorRPM',
      path: 'config.bLeftRotorRPM',
      name: 'Back Left Rotor RPM',
      editor: app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_3__.ScalarDimensionEditor
    });
  }
};

const getStyles = theme => ({
  propeller: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    transform-origin: 50% 50%;
    transform-box: fill-box;
    display: block;
    @keyframes spin {
      from {
        transform: rotate(0deg);
      }
      to {
        transform: rotate(360deg);
      }
    }
  `,
  propellerCW: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    animation-direction: normal;
  `,
  propellerCCW: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    animation-direction: reverse;
  `
});

/***/ }),

/***/ "./public/app/features/canvas/elements/icon.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IconDisplay": () => (/* binding */ IconDisplay),
/* harmony export */   "iconItem": () => (/* binding */ iconItem)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_inlinesvg__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/__virtual__/react-inlinesvg-virtual-f6307798ef/0/cache/react-inlinesvg-npm-2.3.0-9b0402e461-ea43f6ec06.zip/node_modules/react-inlinesvg/esm/index.js");
/* harmony import */ var app_features_dimensions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/features/dimensions/index.ts");
/* harmony import */ var app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/features/dimensions/editors/index.ts");
/* harmony import */ var app_plugins_panel_canvas_editor_APIEditor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/panel/canvas/editor/APIEditor.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");








// When a stoke is defined, we want the path to be in page units
const svgStrokePathClass = _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
  path {
    vector-effect: non-scaling-stroke;
  }
`;
function IconDisplay(props) {
  const {
    data
  } = props;

  if (!(data !== null && data !== void 0 && data.path)) {
    return null;
  }

  const onClick = () => {
    if (data !== null && data !== void 0 && data.api) {
      (0,app_plugins_panel_canvas_editor_APIEditor__WEBPACK_IMPORTED_MODULE_5__.callApi)(data.api);
    }
  };

  const svgStyle = {
    fill: data === null || data === void 0 ? void 0 : data.fill,
    stroke: data === null || data === void 0 ? void 0 : data.strokeColor,
    strokeWidth: data === null || data === void 0 ? void 0 : data.stroke
  };
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(react_inlinesvg__WEBPACK_IMPORTED_MODULE_7__["default"], {
    onClick: onClick,
    src: data.path,
    style: svgStyle,
    className: svgStyle.strokeWidth ? svgStrokePathClass : undefined
  });
}
const iconItem = {
  id: 'icon',
  name: 'Icon',
  description: 'SVG Icon display',
  display: IconDisplay,
  getNewOptions: options => Object.assign({
    placement: {
      width: 50,
      height: 50,
      top: 0,
      left: 0
    }
  }, options, {
    config: {
      path: {
        mode: app_features_dimensions__WEBPACK_IMPORTED_MODULE_3__.ResourceDimensionMode.Fixed,
        fixed: 'img/icons/unicons/question-circle.svg'
      },
      fill: {
        fixed: '#FFF899'
      }
    }
  }),
  // Called when data changes
  prepareData: (ctx, cfg) => {
    var _cfg$api, _cfg$stroke;

    let path = undefined;

    if (cfg.path) {
      path = ctx.getResource(cfg.path).value();
    }

    if (!path || !(0,lodash__WEBPACK_IMPORTED_MODULE_1__.isString)(path)) {
      path = (0,app_features_dimensions__WEBPACK_IMPORTED_MODULE_3__.getPublicOrAbsoluteUrl)('img/icons/unicons/question-circle.svg');
    }

    const data = {
      path,
      fill: cfg.fill ? ctx.getColor(cfg.fill).value() : '#CCC',
      api: (_cfg$api = cfg === null || cfg === void 0 ? void 0 : cfg.api) !== null && _cfg$api !== void 0 ? _cfg$api : undefined
    };

    if ((_cfg$stroke = cfg.stroke) !== null && _cfg$stroke !== void 0 && _cfg$stroke.width && cfg.stroke.color) {
      if (cfg.stroke.width > 0) {
        var _cfg$stroke2;

        data.stroke = (_cfg$stroke2 = cfg.stroke) === null || _cfg$stroke2 === void 0 ? void 0 : _cfg$stroke2.width;
        data.strokeColor = ctx.getColor(cfg.stroke.color).value();
      }
    }

    return data;
  },
  // Heatmap overlay options
  registerOptionsUI: builder => {
    const category = ['Icon'];
    builder.addCustomEditor({
      category,
      id: 'iconSelector',
      path: 'config.path',
      name: 'SVG Path',
      editor: app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_4__.ResourceDimensionEditor,
      settings: {
        resourceType: 'icon'
      }
    }).addCustomEditor({
      category,
      id: 'config.fill',
      path: 'config.fill',
      name: 'Fill color',
      editor: app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_4__.ColorDimensionEditor,
      settings: {},
      defaultValue: {
        // Configured values
        fixed: 'grey'
      }
    }).addSliderInput({
      category,
      path: 'config.stroke.width',
      name: 'Stroke',
      defaultValue: 0,
      settings: {
        min: 0,
        max: 10
      }
    }).addCustomEditor({
      category,
      id: 'config.stroke.color',
      path: 'config.stroke.color',
      name: 'Stroke color',
      editor: app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_4__.ColorDimensionEditor,
      settings: {},
      defaultValue: {
        // Configured values
        fixed: 'grey'
      },
      showIf: cfg => {
        var _cfg$config, _cfg$config$stroke;

        return Boolean(cfg === null || cfg === void 0 ? void 0 : (_cfg$config = cfg.config) === null || _cfg$config === void 0 ? void 0 : (_cfg$config$stroke = _cfg$config.stroke) === null || _cfg$config$stroke === void 0 ? void 0 : _cfg$config$stroke.width);
      }
    }).addCustomEditor({
      category,
      id: 'apiSelector',
      path: 'config.api',
      name: 'API',
      editor: app_plugins_panel_canvas_editor_APIEditor__WEBPACK_IMPORTED_MODULE_5__.APIEditor
    });
  }
};

/***/ }),

/***/ "./public/app/features/canvas/elements/notFound.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "notFoundItem": () => (/* binding */ notFoundItem)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _h;





class NotFoundDisplay extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {
  render() {
    const {
      config
    } = this.props;
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)("div", {
      children: [_h || (_h = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("h3", {
        children: "NOT FOUND:"
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("pre", {
        children: JSON.stringify(config, null, 2)
      })]
    });
  }

}

const notFoundItem = {
  id: 'not-found',
  name: 'Not found',
  description: 'Display when element type is not found in the registry',
  display: NotFoundDisplay,
  defaultSize: {
    width: 100,
    height: 100
  },
  getNewOptions: () => ({
    config: {}
  })
};

/***/ }),

/***/ "./public/app/features/canvas/elements/textBox.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Align": () => (/* binding */ Align),
/* harmony export */   "VAlign": () => (/* binding */ VAlign),
/* harmony export */   "textBoxItem": () => (/* binding */ textBoxItem)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_core_config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/core/config.ts");
/* harmony import */ var app_features_dimensions_editors_ColorDimensionEditor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/features/dimensions/editors/ColorDimensionEditor.tsx");
/* harmony import */ var app_features_dimensions_editors_TextDimensionEditor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/features/dimensions/editors/TextDimensionEditor.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");







let Align;

(function (Align) {
  Align["Left"] = "left";
  Align["Center"] = "center";
  Align["Right"] = "right";
})(Align || (Align = {}));

let VAlign;

(function (VAlign) {
  VAlign["Top"] = "top";
  VAlign["Middle"] = "middle";
  VAlign["Bottom"] = "bottom";
})(VAlign || (VAlign = {}));

class TextBoxDisplay extends react__WEBPACK_IMPORTED_MODULE_1__.PureComponent {
  render() {
    const {
      data
    } = this.props;
    const styles = getStyles(app_core_config__WEBPACK_IMPORTED_MODULE_3__.config.theme2, data);
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("div", {
      className: styles.container,
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("span", {
        className: styles.span,
        children: data === null || data === void 0 ? void 0 : data.text
      })
    });
  }

}

const getStyles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.stylesFactory)((theme, data) => ({
  container: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    position: absolute;
    height: 100%;
    width: 100%;
    display: table;
  `,
  span: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    display: table-cell;
    vertical-align: ${data.valign};
    text-align: ${data.align};
    font-size: ${data === null || data === void 0 ? void 0 : data.size}px;
    color: ${data === null || data === void 0 ? void 0 : data.color};
  `
}));
const textBoxItem = {
  id: 'text-box',
  name: 'Text',
  description: 'Text box',
  display: TextBoxDisplay,
  defaultSize: {
    width: 240,
    height: 160
  },
  getNewOptions: options => Object.assign({
    background: {
      color: {
        fixed: 'grey'
      }
    }
  }, options, {
    config: {
      align: Align.Left,
      valign: VAlign.Middle
    }
  }),
  // Called when data changes
  prepareData: (ctx, cfg) => {
    var _cfg$align, _cfg$valign;

    const data = {
      text: cfg.text ? ctx.getText(cfg.text).value() : '',
      align: (_cfg$align = cfg.align) !== null && _cfg$align !== void 0 ? _cfg$align : Align.Center,
      valign: (_cfg$valign = cfg.valign) !== null && _cfg$valign !== void 0 ? _cfg$valign : VAlign.Middle,
      size: cfg.size
    };

    if (cfg.color) {
      data.color = ctx.getColor(cfg.color).value();
    }

    return data;
  },
  // Heatmap overlay options
  registerOptionsUI: builder => {
    const category = ['Text box'];
    builder.addCustomEditor({
      category,
      id: 'textSelector',
      path: 'config.text',
      name: 'Text',
      editor: app_features_dimensions_editors_TextDimensionEditor__WEBPACK_IMPORTED_MODULE_5__.TextDimensionEditor
    }).addCustomEditor({
      category,
      id: 'config.color',
      path: 'config.color',
      name: 'Text color',
      editor: app_features_dimensions_editors_ColorDimensionEditor__WEBPACK_IMPORTED_MODULE_4__.ColorDimensionEditor,
      settings: {},
      defaultValue: {}
    }).addRadio({
      category,
      path: 'config.align',
      name: 'Align text',
      settings: {
        options: [{
          value: Align.Left,
          label: 'Left'
        }, {
          value: Align.Center,
          label: 'Center'
        }, {
          value: Align.Right,
          label: 'Right'
        }]
      },
      defaultValue: Align.Left
    }).addRadio({
      category,
      path: 'config.valign',
      name: 'Vertical align',
      settings: {
        options: [{
          value: VAlign.Top,
          label: 'Top'
        }, {
          value: VAlign.Middle,
          label: 'Middle'
        }, {
          value: VAlign.Bottom,
          label: 'Bottom'
        }]
      },
      defaultValue: VAlign.Middle
    }).addNumberInput({
      category,
      path: 'config.size',
      name: 'Text size',
      settings: {
        placeholder: 'Auto'
      }
    });
  }
};

/***/ }),

/***/ "./public/app/features/canvas/elements/windTurbine.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "windTurbineItem": () => (/* binding */ windTurbineItem)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/features/dimensions/editors/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _symbol, _g, _use, _use2, _use3;








const WindTurbineDisplay = props => {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.useStyles2)(getStyles);
  const {
    data
  } = props;
  const windTurbineAnimation = `spin ${data !== null && data !== void 0 && data.rpm ? 60 / Math.abs(data.rpm) : 0}s linear infinite`;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("svg", {
    viewBox: "0 0 189.326 283.989",
    preserveAspectRatio: "xMidYMid meet",
    children: [_symbol || (_symbol = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("symbol", {
      id: "blade",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        fill: "#e6e6e6",
        id: "blade-front",
        d: "M14.6491879,1.85011601 C14.2684455,-0.0535962877 10.7150812,-0.815081206 9.06473318,3.37308585 L0.434338747,70.7658933 L8.93805104,91.9607889 L15.4106729,90.437819 L17.5684455,78.3807425 L14.5218097,1.97679814 L14.6491879,1.85011601 Z"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        fill: "#d0d6d7",
        id: "blade-side",
        d: "M11.0951276,0.581206497 C10.3336427,0.961948956 9.57215777,1.85011601 8.93735499,3.24640371 L0.306960557,70.6392111 L8.81067285,91.8341067 L3.35359629,70.0044084 L11.0951276,0.581206497 Z"
      })]
    })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("g", {
      children: [_g || (_g = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("g", {
        id: "structure",
        transform: "translate(58.123, 82.664)",
        fillRule: "nonzero",
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("polygon", {
          id: "tower",
          fill: "#e6e6e6",
          points: "33.111,10.984 39.965,10.984 44.28,196.176 28.796,196.176"
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
          id: "yaw",
          fill: "rgba(0,0,0,0.25)",
          d: "M40.3454756,23.2948956 L40.7262181,34.8445476 C38.8225058,35.0986079 35.7765661,35.0986079 32.349884,34.337123 L32.7306265,23.2955916 L40.3454756,23.2955916 L40.3454756,23.2948956 Z"
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
          id: "base",
          fill: "#d0d6d7",
          transform: "translate(0 42)",
          d: "M26.3846868,150.591647 L46.5640371,150.591647 C48.8484919,150.591647 50.7522042,152.49536 50.7522042,154.779814 L50.7522042,158.967981 L22.0691415,158.967981 L22.0691415,154.779814 C22.0691415,152.49536 23.9728538,150.591647 26.2573086,150.591647 L26.3846868,150.591647 Z"
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("circle", {
          id: "nacelle",
          fill: "#e6e6e6",
          cx: "36.54",
          cy: "12",
          r: "11.93"
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("circle", {
          id: "gearbox",
          fill: "none",
          stroke: "#d0d6d7",
          strokeWidth: "2.75",
          cx: "36.538",
          cy: "11.999",
          r: "5.8"
        })]
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("g", {
        className: styles.blade,
        style: {
          animation: windTurbineAnimation
        },
        children: [_use || (_use = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("use", {
          id: "blade1",
          href: "#blade",
          x: "83.24",
          y: "0"
        })), _use2 || (_use2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("use", {
          id: "blade2",
          href: "#blade",
          x: "83.24",
          y: "0",
          transform: "rotate(120 94.663 94.663)"
        })), _use3 || (_use3 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("use", {
          id: "blade3",
          href: "#blade",
          x: "83.24",
          y: "0",
          transform: "rotate(-120 94.663 94.663)"
        }))]
      })]
    })]
  });
};

const windTurbineItem = {
  id: 'windTurbine',
  name: 'Wind Turbine',
  description: 'Spinny spinny',
  display: WindTurbineDisplay,
  defaultSize: {
    width: 100,
    height: 100
  },
  getNewOptions: options => Object.assign({}, options),
  // Called when data changes
  prepareData: (ctx, cfg) => {
    const data = {
      rpm: cfg !== null && cfg !== void 0 && cfg.rpm ? ctx.getScalar(cfg.rpm).value() : 0
    };
    return data;
  },
  registerOptionsUI: builder => {
    const category = ['Wind Turbine'];
    builder.addCustomEditor({
      category,
      id: 'rpm',
      path: 'config.rpm',
      name: 'RPM',
      editor: app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_3__.ScalarDimensionEditor
    });
  }
};

const getStyles = theme => ({
  blade: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    @keyframes spin {
      from {
        transform: rotate(0deg);
      }
      to {
        transform: rotate(360deg);
      }
    }

    transform-origin: 94.663px 94.663px;
    transform: rotate(15deg);
  `
});

/***/ }),

/***/ "./public/app/features/canvas/frame.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);


/***/ }),

/***/ "./public/app/features/canvas/index.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BackgroundImageSize": () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_0__.BackgroundImageSize),
/* harmony export */   "CanvasFrameOptions": () => (/* reexport safe */ _frame__WEBPACK_IMPORTED_MODULE_2__.CanvasFrameOptions),
/* harmony export */   "DEFAULT_CANVAS_ELEMENT_CONFIG": () => (/* reexport safe */ _registry__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_CANVAS_ELEMENT_CONFIG),
/* harmony export */   "HorizontalConstraint": () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_0__.HorizontalConstraint),
/* harmony export */   "VerticalConstraint": () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_0__.VerticalConstraint),
/* harmony export */   "canvasElementRegistry": () => (/* reexport safe */ _registry__WEBPACK_IMPORTED_MODULE_3__.canvasElementRegistry)
/* harmony export */ });
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/features/canvas/types.ts");
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/features/canvas/element.ts");
/* harmony import */ var _frame__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/canvas/frame.ts");
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/features/canvas/registry.ts");





/***/ }),

/***/ "./public/app/features/canvas/registry.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEFAULT_CANVAS_ELEMENT_CONFIG": () => (/* binding */ DEFAULT_CANVAS_ELEMENT_CONFIG),
/* harmony export */   "canvasElementRegistry": () => (/* binding */ canvasElementRegistry)
/* harmony export */ });
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _elements_button__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/features/canvas/elements/button.tsx");
/* harmony import */ var _elements_droneFront__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/canvas/elements/droneFront.tsx");
/* harmony import */ var _elements_droneSide__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/features/canvas/elements/droneSide.tsx");
/* harmony import */ var _elements_droneTop__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/features/canvas/elements/droneTop.tsx");
/* harmony import */ var _elements_icon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/features/canvas/elements/icon.tsx");
/* harmony import */ var _elements_textBox__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/features/canvas/elements/textBox.tsx");
/* harmony import */ var _elements_windTurbine__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/features/canvas/elements/windTurbine.tsx");








const DEFAULT_CANVAS_ELEMENT_CONFIG = Object.assign({}, _elements_icon__WEBPACK_IMPORTED_MODULE_5__.iconItem.getNewOptions(), {
  type: _elements_icon__WEBPACK_IMPORTED_MODULE_5__.iconItem.id,
  name: `Element 1`
});
const canvasElementRegistry = new _grafana_data__WEBPACK_IMPORTED_MODULE_0__.Registry(() => [_elements_icon__WEBPACK_IMPORTED_MODULE_5__.iconItem, // default for now
_elements_textBox__WEBPACK_IMPORTED_MODULE_6__.textBoxItem, _elements_button__WEBPACK_IMPORTED_MODULE_1__.buttonItem, _elements_droneTop__WEBPACK_IMPORTED_MODULE_4__.droneTopItem, _elements_droneFront__WEBPACK_IMPORTED_MODULE_2__.droneFrontItem, _elements_droneSide__WEBPACK_IMPORTED_MODULE_3__.droneSideItem, _elements_windTurbine__WEBPACK_IMPORTED_MODULE_7__.windTurbineItem]);

/***/ }),

/***/ "./public/app/features/canvas/runtime/element.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ElementState": () => (/* binding */ ElementState)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var app_features_canvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/features/canvas/index.ts");
/* harmony import */ var app_features_canvas_elements_notFound__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/canvas/elements/notFound.tsx");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/features/canvas/types.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






let counter = 0;
class ElementState {
  // UID necessary for moveable to work (for now)
  // Filled in by ref
  // Calculated
  // depends on the type
  constructor(item, options, parent) {
    var _options$constraint, _options$placement;

    this.item = item;
    this.options = options;
    this.parent = parent;

    _defineProperty(this, "UID", counter++);

    _defineProperty(this, "revId", 0);

    _defineProperty(this, "sizeStyle", {});

    _defineProperty(this, "dataStyle", {});

    _defineProperty(this, "div", void 0);

    _defineProperty(this, "data", void 0);

    _defineProperty(this, "initElement", target => {
      this.div = target;
      this.applyLayoutStylesToDiv();
    });

    _defineProperty(this, "applyDrag", event => {
      event.target.style.transform = event.transform;
    });

    _defineProperty(this, "applyResize", event => {
      const {
        options
      } = this;
      const {
        placement,
        constraint
      } = options;
      const {
        vertical,
        horizontal
      } = constraint !== null && constraint !== void 0 ? constraint : {};
      const top = vertical === _types__WEBPACK_IMPORTED_MODULE_3__.VerticalConstraint.Top || vertical === _types__WEBPACK_IMPORTED_MODULE_3__.VerticalConstraint.TopBottom;
      const bottom = vertical === _types__WEBPACK_IMPORTED_MODULE_3__.VerticalConstraint.Bottom || vertical === _types__WEBPACK_IMPORTED_MODULE_3__.VerticalConstraint.TopBottom;
      const left = horizontal === _types__WEBPACK_IMPORTED_MODULE_3__.HorizontalConstraint.Left || horizontal === _types__WEBPACK_IMPORTED_MODULE_3__.HorizontalConstraint.LeftRight;
      const right = horizontal === _types__WEBPACK_IMPORTED_MODULE_3__.HorizontalConstraint.Right || horizontal === _types__WEBPACK_IMPORTED_MODULE_3__.HorizontalConstraint.LeftRight;
      const style = event.target.style;
      const deltaX = event.delta[0];
      const deltaY = event.delta[1];
      const dirLR = event.direction[0];
      const dirTB = event.direction[1];

      if (dirLR === 1) {
        // RIGHT
        if (right) {
          placement.right -= deltaX;
          style.right = `${placement.right}px`;

          if (!left) {
            placement.width = event.width;
            style.width = `${placement.width}px`;
          }
        } else {
          placement.width = event.width;
          style.width = `${placement.width}px`;
        }
      } else if (dirLR === -1) {
        // LEFT
        if (left) {
          placement.left -= deltaX;
          placement.width = event.width;
          style.left = `${placement.left}px`;
          style.width = `${placement.width}px`;
        } else {
          placement.width += deltaX;
          style.width = `${placement.width}px`;
        }
      }

      if (dirTB === -1) {
        // TOP
        if (top) {
          placement.top -= deltaY;
          placement.height = event.height;
          style.top = `${placement.top}px`;
          style.height = `${placement.height}px`;
        } else {
          placement.height = event.height;
          style.height = `${placement.height}px`;
        }
      } else if (dirTB === 1) {
        // BOTTOM
        if (bottom) {
          placement.bottom -= deltaY;
          placement.height = event.height;
          style.bottom = `${placement.bottom}px`;
          style.height = `${placement.height}px`;
        } else {
          placement.height = event.height;
          style.height = `${placement.height}px`;
        }
      }
    });

    this.item = item;
    this.options = options;
    this.parent = parent;
    const fallbackName = `Element ${Date.now()}`;

    if (!options) {
      this.options = {
        type: item.id,
        name: fallbackName
      };
    }

    options.constraint = (_options$constraint = options.constraint) !== null && _options$constraint !== void 0 ? _options$constraint : {
      vertical: _types__WEBPACK_IMPORTED_MODULE_3__.VerticalConstraint.Top,
      horizontal: _types__WEBPACK_IMPORTED_MODULE_3__.HorizontalConstraint.Left
    };
    options.placement = (_options$placement = options.placement) !== null && _options$placement !== void 0 ? _options$placement : {
      width: 100,
      height: 100,
      top: 0,
      left: 0
    };
    const scene = this.getScene();

    if (!options.name) {
      const newName = scene === null || scene === void 0 ? void 0 : scene.getNextElementName();
      options.name = newName !== null && newName !== void 0 ? newName : fallbackName;
    }

    scene === null || scene === void 0 ? void 0 : scene.byName.set(options.name, this);
  }

  getScene() {
    let trav = this.parent;

    while (trav) {
      if (trav.isRoot()) {
        return trav.scene;
      }

      trav = trav.parent;
    }

    return undefined;
  }

  getName() {
    return this.options.name;
  }
  /** Use the configured options to update CSS style properties directly on the wrapper div **/


  applyLayoutStylesToDiv() {
    var _this$options$placeme, _placement$top, _placement$height, _placement$bottom, _placement$height2, _placement$top2, _placement$bottom2, _placement$top3, _placement$height3, _placement$top4, _placement$bottom3, _placement$left, _placement$width, _placement$right, _placement$width2, _placement$left2, _placement$right2, _placement$left3, _placement$width3, _placement$left4, _placement$right3;

    if (this.isRoot()) {
      // Root supersedes layout engine and is always 100% width + height of panel
      return;
    }

    const {
      constraint
    } = this.options;
    const {
      vertical,
      horizontal
    } = constraint !== null && constraint !== void 0 ? constraint : {};
    const placement = (_this$options$placeme = this.options.placement) !== null && _this$options$placeme !== void 0 ? _this$options$placeme : {};
    const style = {
      position: 'absolute'
    };
    const translate = ['0px', '0px'];

    switch (vertical) {
      case _types__WEBPACK_IMPORTED_MODULE_3__.VerticalConstraint.Top:
        placement.top = (_placement$top = placement.top) !== null && _placement$top !== void 0 ? _placement$top : 0;
        placement.height = (_placement$height = placement.height) !== null && _placement$height !== void 0 ? _placement$height : 100;
        style.top = `${placement.top}px`;
        style.height = `${placement.height}px`;
        delete placement.bottom;
        break;

      case _types__WEBPACK_IMPORTED_MODULE_3__.VerticalConstraint.Bottom:
        placement.bottom = (_placement$bottom = placement.bottom) !== null && _placement$bottom !== void 0 ? _placement$bottom : 0;
        placement.height = (_placement$height2 = placement.height) !== null && _placement$height2 !== void 0 ? _placement$height2 : 100;
        style.bottom = `${placement.bottom}px`;
        style.height = `${placement.height}px`;
        delete placement.top;
        break;

      case _types__WEBPACK_IMPORTED_MODULE_3__.VerticalConstraint.TopBottom:
        placement.top = (_placement$top2 = placement.top) !== null && _placement$top2 !== void 0 ? _placement$top2 : 0;
        placement.bottom = (_placement$bottom2 = placement.bottom) !== null && _placement$bottom2 !== void 0 ? _placement$bottom2 : 0;
        style.top = `${placement.top}px`;
        style.bottom = `${placement.bottom}px`;
        delete placement.height;
        break;

      case _types__WEBPACK_IMPORTED_MODULE_3__.VerticalConstraint.Center:
        placement.top = (_placement$top3 = placement.top) !== null && _placement$top3 !== void 0 ? _placement$top3 : 0;
        placement.height = (_placement$height3 = placement.height) !== null && _placement$height3 !== void 0 ? _placement$height3 : 100;
        translate[1] = '-50%';
        style.top = `calc(50% - ${placement.top}px)`;
        style.height = `${placement.height}px`;
        delete placement.bottom;
        break;

      case _types__WEBPACK_IMPORTED_MODULE_3__.VerticalConstraint.Scale:
        placement.top = (_placement$top4 = placement.top) !== null && _placement$top4 !== void 0 ? _placement$top4 : 0;
        placement.bottom = (_placement$bottom3 = placement.bottom) !== null && _placement$bottom3 !== void 0 ? _placement$bottom3 : 0;
        style.top = `${placement.top}%`;
        style.bottom = `${placement.bottom}%`;
        delete placement.height;
        break;
    }

    switch (horizontal) {
      case _types__WEBPACK_IMPORTED_MODULE_3__.HorizontalConstraint.Left:
        placement.left = (_placement$left = placement.left) !== null && _placement$left !== void 0 ? _placement$left : 0;
        placement.width = (_placement$width = placement.width) !== null && _placement$width !== void 0 ? _placement$width : 100;
        style.left = `${placement.left}px`;
        style.width = `${placement.width}px`;
        delete placement.right;
        break;

      case _types__WEBPACK_IMPORTED_MODULE_3__.HorizontalConstraint.Right:
        placement.right = (_placement$right = placement.right) !== null && _placement$right !== void 0 ? _placement$right : 0;
        placement.width = (_placement$width2 = placement.width) !== null && _placement$width2 !== void 0 ? _placement$width2 : 100;
        style.right = `${placement.right}px`;
        style.width = `${placement.width}px`;
        delete placement.left;
        break;

      case _types__WEBPACK_IMPORTED_MODULE_3__.HorizontalConstraint.LeftRight:
        placement.left = (_placement$left2 = placement.left) !== null && _placement$left2 !== void 0 ? _placement$left2 : 0;
        placement.right = (_placement$right2 = placement.right) !== null && _placement$right2 !== void 0 ? _placement$right2 : 0;
        style.left = `${placement.left}px`;
        style.right = `${placement.right}px`;
        delete placement.width;
        break;

      case _types__WEBPACK_IMPORTED_MODULE_3__.HorizontalConstraint.Center:
        placement.left = (_placement$left3 = placement.left) !== null && _placement$left3 !== void 0 ? _placement$left3 : 0;
        placement.width = (_placement$width3 = placement.width) !== null && _placement$width3 !== void 0 ? _placement$width3 : 100;
        translate[0] = '-50%';
        style.left = `calc(50% - ${placement.left}px)`;
        style.width = `${placement.width}px`;
        delete placement.right;
        break;

      case _types__WEBPACK_IMPORTED_MODULE_3__.HorizontalConstraint.Scale:
        placement.left = (_placement$left4 = placement.left) !== null && _placement$left4 !== void 0 ? _placement$left4 : 0;
        placement.right = (_placement$right3 = placement.right) !== null && _placement$right3 !== void 0 ? _placement$right3 : 0;
        style.left = `${placement.left}%`;
        style.right = `${placement.right}%`;
        delete placement.width;
        break;
    }

    style.transform = `translate(${translate[0]}, ${translate[1]})`;
    this.options.placement = placement;
    this.sizeStyle = style;

    if (this.div) {
      for (const key in this.sizeStyle) {
        this.div.style[key] = this.sizeStyle[key];
      }

      for (const key in this.dataStyle) {
        this.div.style[key] = this.dataStyle[key];
      }
    }
  }

  setPlacementFromConstraint(elementContainer, parentContainer) {
    var _elementContainer$wid, _elementContainer, _elementContainer$hei, _elementContainer2, _parentContainer$heig, _parentContainer, _parentContainer$heig2, _parentContainer2, _parentContainer$widt, _parentContainer3, _parentContainer$widt2, _parentContainer4;

    const {
      constraint
    } = this.options;
    const {
      vertical,
      horizontal
    } = constraint !== null && constraint !== void 0 ? constraint : {};

    if (!elementContainer) {
      elementContainer = this.div && this.div.getBoundingClientRect();
    }

    if (!parentContainer) {
      var _this$div$parentEleme;

      parentContainer = this.div && ((_this$div$parentEleme = this.div.parentElement) === null || _this$div$parentEleme === void 0 ? void 0 : _this$div$parentEleme.getBoundingClientRect());
    }

    const relativeTop = elementContainer && parentContainer ? Math.abs(Math.round(elementContainer.top - parentContainer.top)) : 0;
    const relativeBottom = elementContainer && parentContainer ? Math.abs(Math.round(elementContainer.bottom - parentContainer.bottom)) : 0;
    const relativeLeft = elementContainer && parentContainer ? Math.abs(Math.round(elementContainer.left - parentContainer.left)) : 0;
    const relativeRight = elementContainer && parentContainer ? Math.abs(Math.round(elementContainer.right - parentContainer.right)) : 0;
    const placement = {};
    const width = (_elementContainer$wid = (_elementContainer = elementContainer) === null || _elementContainer === void 0 ? void 0 : _elementContainer.width) !== null && _elementContainer$wid !== void 0 ? _elementContainer$wid : 100;
    const height = (_elementContainer$hei = (_elementContainer2 = elementContainer) === null || _elementContainer2 === void 0 ? void 0 : _elementContainer2.height) !== null && _elementContainer$hei !== void 0 ? _elementContainer$hei : 100;

    switch (vertical) {
      case _types__WEBPACK_IMPORTED_MODULE_3__.VerticalConstraint.Top:
        placement.top = relativeTop;
        placement.height = height;
        break;

      case _types__WEBPACK_IMPORTED_MODULE_3__.VerticalConstraint.Bottom:
        placement.bottom = relativeBottom;
        placement.height = height;
        break;

      case _types__WEBPACK_IMPORTED_MODULE_3__.VerticalConstraint.TopBottom:
        placement.top = relativeTop;
        placement.bottom = relativeBottom;
        break;

      case _types__WEBPACK_IMPORTED_MODULE_3__.VerticalConstraint.Center:
        const elementCenter = elementContainer ? relativeTop + height / 2 : 0;
        const parentCenter = parentContainer ? parentContainer.height / 2 : 0;
        const distanceFromCenter = parentCenter - elementCenter;
        placement.top = distanceFromCenter;
        placement.height = height;
        break;

      case _types__WEBPACK_IMPORTED_MODULE_3__.VerticalConstraint.Scale:
        placement.top = relativeTop / ((_parentContainer$heig = (_parentContainer = parentContainer) === null || _parentContainer === void 0 ? void 0 : _parentContainer.height) !== null && _parentContainer$heig !== void 0 ? _parentContainer$heig : height) * 100;
        placement.bottom = relativeBottom / ((_parentContainer$heig2 = (_parentContainer2 = parentContainer) === null || _parentContainer2 === void 0 ? void 0 : _parentContainer2.height) !== null && _parentContainer$heig2 !== void 0 ? _parentContainer$heig2 : height) * 100;
        break;
    }

    switch (horizontal) {
      case _types__WEBPACK_IMPORTED_MODULE_3__.HorizontalConstraint.Left:
        placement.left = relativeLeft;
        placement.width = width;
        break;

      case _types__WEBPACK_IMPORTED_MODULE_3__.HorizontalConstraint.Right:
        placement.right = relativeRight;
        placement.width = width;
        break;

      case _types__WEBPACK_IMPORTED_MODULE_3__.HorizontalConstraint.LeftRight:
        placement.left = relativeLeft;
        placement.right = relativeRight;
        break;

      case _types__WEBPACK_IMPORTED_MODULE_3__.HorizontalConstraint.Center:
        const elementCenter = elementContainer ? relativeLeft + width / 2 : 0;
        const parentCenter = parentContainer ? parentContainer.width / 2 : 0;
        const distanceFromCenter = parentCenter - elementCenter;
        placement.left = distanceFromCenter;
        placement.width = width;
        break;

      case _types__WEBPACK_IMPORTED_MODULE_3__.HorizontalConstraint.Scale:
        placement.left = relativeLeft / ((_parentContainer$widt = (_parentContainer3 = parentContainer) === null || _parentContainer3 === void 0 ? void 0 : _parentContainer3.width) !== null && _parentContainer$widt !== void 0 ? _parentContainer$widt : width) * 100;
        placement.right = relativeRight / ((_parentContainer$widt2 = (_parentContainer4 = parentContainer) === null || _parentContainer4 === void 0 ? void 0 : _parentContainer4.width) !== null && _parentContainer$widt2 !== void 0 ? _parentContainer$widt2 : width) * 100;
        break;
    }

    this.options.placement = placement;
    this.applyLayoutStylesToDiv();
    this.revId++;
  }

  updateData(ctx) {
    var _background$size;

    if (this.item.prepareData) {
      this.data = this.item.prepareData(ctx, this.options.config);
      this.revId++; // rerender
    }

    const {
      background,
      border
    } = this.options;
    const css = {};

    if (background) {
      if (background.color) {
        const color = ctx.getColor(background.color);
        css.backgroundColor = color.value();
      }

      if (background.image) {
        const image = ctx.getResource(background.image);

        if (image) {
          const v = image.value();

          if (v) {
            css.backgroundImage = `url("${v}")`;

            switch ((_background$size = background.size) !== null && _background$size !== void 0 ? _background$size : app_features_canvas__WEBPACK_IMPORTED_MODULE_1__.BackgroundImageSize.Contain) {
              case app_features_canvas__WEBPACK_IMPORTED_MODULE_1__.BackgroundImageSize.Contain:
                css.backgroundSize = 'contain';
                css.backgroundRepeat = 'no-repeat';
                break;

              case app_features_canvas__WEBPACK_IMPORTED_MODULE_1__.BackgroundImageSize.Cover:
                css.backgroundSize = 'cover';
                css.backgroundRepeat = 'no-repeat';
                break;

              case app_features_canvas__WEBPACK_IMPORTED_MODULE_1__.BackgroundImageSize.Original:
                css.backgroundRepeat = 'no-repeat';
                break;

              case app_features_canvas__WEBPACK_IMPORTED_MODULE_1__.BackgroundImageSize.Tile:
                css.backgroundRepeat = 'repeat';
                break;

              case app_features_canvas__WEBPACK_IMPORTED_MODULE_1__.BackgroundImageSize.Fill:
                css.backgroundSize = '100% 100%';
                break;
            }
          }
        }
      }
    }

    if (border && border.color && border.width) {
      const color = ctx.getColor(border.color);
      css.borderWidth = border.width;
      css.borderStyle = 'solid';
      css.borderColor = color.value(); // Move the image to inside the border

      if (css.backgroundImage) {
        css.backgroundOrigin = 'padding-box';
      }
    }

    this.dataStyle = css;
    this.applyLayoutStylesToDiv();
  }

  isRoot() {
    return false;
  }
  /** Recursively visit all nodes */


  visit(visitor) {
    visitor(this);
  }

  onChange(options) {
    if (this.item.id !== options.type) {
      var _canvasElementRegistr;

      this.item = (_canvasElementRegistr = app_features_canvas__WEBPACK_IMPORTED_MODULE_1__.canvasElementRegistry.getIfExists(options.type)) !== null && _canvasElementRegistr !== void 0 ? _canvasElementRegistr : app_features_canvas_elements_notFound__WEBPACK_IMPORTED_MODULE_2__.notFoundItem;
    } // rename handling


    const oldName = this.options.name;
    const newName = options.name;
    this.revId++;
    this.options = Object.assign({}, options);
    let trav = this.parent;

    while (trav) {
      if (trav.isRoot()) {
        trav.scene.save();
        break;
      }

      trav.revId++;
      trav = trav.parent;
    }

    const scene = this.getScene();

    if (oldName !== newName && scene) {
      scene.byName.delete(oldName);
      scene.byName.set(newName, this);
    }
  }

  getSaveModel() {
    return Object.assign({}, this.options);
  }

  render() {
    const {
      item
    } = this;
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
      ref: this.initElement,
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(item.display, {
        config: this.options.config,
        data: this.data
      }, `${this.UID}/${this.revId}`)
    }, this.UID);
  }

}

/***/ }),

/***/ "./public/app/features/canvas/runtime/frame.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FrameState": () => (/* binding */ FrameState),
/* harmony export */   "frameItemDummy": () => (/* binding */ frameItemDummy)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var app_features_canvas__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/canvas/index.ts");
/* harmony import */ var app_features_canvas_elements_notFound__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/features/canvas/elements/notFound.tsx");
/* harmony import */ var app_plugins_panel_canvas_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/panel/canvas/types.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/features/canvas/types.ts");
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/features/canvas/runtime/element.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _div;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }









const frameItemDummy = {
  id: 'frame',
  name: 'Frame',
  description: 'Frame',
  getNewOptions: () => ({
    config: {}
  }),
  // eslint-disable-next-line react/display-name
  display: () => {
    return _div || (_div = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
      children: "FRAME!"
    }));
  }
};
class FrameState extends _element__WEBPACK_IMPORTED_MODULE_6__.ElementState {
  constructor(options, scene, parent) {
    super(frameItemDummy, options, parent);
    this.options = options;
    this.parent = parent;

    _defineProperty(this, "elements", []);

    _defineProperty(this, "scene", void 0);

    _defineProperty(this, "doAction", (action, element, updateName = true, shiftItemsOnDuplicate = true) => {
      switch (action) {
        case app_plugins_panel_canvas_types__WEBPACK_IMPORTED_MODULE_4__.LayerActionID.Delete:
          this.elements = this.elements.filter(e => e !== element);
          this.scene.byName.delete(element.options.name);
          this.scene.save();
          this.reinitializeMoveable();
          break;

        case app_plugins_panel_canvas_types__WEBPACK_IMPORTED_MODULE_4__.LayerActionID.Duplicate:
          if (element.item.id === 'frame') {
            console.log('Can not duplicate frames (yet)', action, element);
            return;
          }

          const opts = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.cloneDeep)(element.options);

          if (shiftItemsOnDuplicate) {
            const {
              constraint,
              placement: oldPlacement
            } = element.options;
            const {
              vertical,
              horizontal
            } = constraint !== null && constraint !== void 0 ? constraint : {};
            const placement = oldPlacement !== null && oldPlacement !== void 0 ? oldPlacement : {};

            switch (vertical) {
              case _types__WEBPACK_IMPORTED_MODULE_5__.VerticalConstraint.Top:
              case _types__WEBPACK_IMPORTED_MODULE_5__.VerticalConstraint.TopBottom:
                if (placement.top == null) {
                  placement.top = 25;
                } else {
                  placement.top += 10;
                }

                break;

              case _types__WEBPACK_IMPORTED_MODULE_5__.VerticalConstraint.Bottom:
                if (placement.bottom == null) {
                  placement.bottom = 100;
                } else {
                  placement.bottom -= 10;
                }

                break;
            }

            switch (horizontal) {
              case _types__WEBPACK_IMPORTED_MODULE_5__.HorizontalConstraint.Left:
              case _types__WEBPACK_IMPORTED_MODULE_5__.HorizontalConstraint.LeftRight:
                if (placement.left == null) {
                  placement.left = 50;
                } else {
                  placement.left += 10;
                }

                break;

              case _types__WEBPACK_IMPORTED_MODULE_5__.HorizontalConstraint.Right:
                if (placement.right == null) {
                  placement.right = 50;
                } else {
                  placement.right -= 10;
                }

                break;
            }

            opts.placement = placement;
          }

          const copy = new _element__WEBPACK_IMPORTED_MODULE_6__.ElementState(element.item, opts, this);
          copy.updateData(this.scene.context);

          if (updateName) {
            copy.options.name = this.scene.getNextElementName();
          }

          this.elements.push(copy);
          this.scene.byName.set(copy.options.name, copy);
          this.scene.save();
          this.reinitializeMoveable();
          break;

        default:
          console.log('DO action', action, element);
          return;
      }
    });

    this.options = options;
    this.parent = parent;
    this.scene = scene; // mutate options object

    let {
      elements
    } = this.options;

    if (!elements) {
      this.options.elements = elements = [];
    }

    for (const c of elements) {
      if (c.type === 'frame') {
        this.elements.push(new FrameState(c, scene, this));
      } else {
        var _canvasElementRegistr;

        const item = (_canvasElementRegistr = app_features_canvas__WEBPACK_IMPORTED_MODULE_2__.canvasElementRegistry.getIfExists(c.type)) !== null && _canvasElementRegistr !== void 0 ? _canvasElementRegistr : app_features_canvas_elements_notFound__WEBPACK_IMPORTED_MODULE_3__.notFoundItem;
        this.elements.push(new _element__WEBPACK_IMPORTED_MODULE_6__.ElementState(item, c, this));
      }
    }
  }

  isRoot() {
    return false;
  }

  updateData(ctx) {
    super.updateData(ctx);

    for (const elem of this.elements) {
      elem.updateData(ctx);
    }
  } // used in the layer editor


  reorder(startIndex, endIndex) {
    const result = Array.from(this.elements);
    const [removed] = result.splice(startIndex, 1);
    result.splice(endIndex, 0, removed);
    this.elements = result;
    this.reinitializeMoveable();
  }

  reinitializeMoveable() {
    // Need to first clear current selection and then re-init moveable with slight delay
    this.scene.clearCurrentSelection();
    setTimeout(() => this.scene.initMoveable(true, this.scene.isEditingEnabled), 100);
  } // ??? or should this be on the element directly?
  // are actions scoped to layers?


  render() {
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
      ref: this.initElement,
      style: {
        overflow: 'hidden'
      },
      children: this.elements.map(v => v.render())
    }, this.UID);
  }
  /** Recursively visit all nodes */


  visit(visitor) {
    super.visit(visitor);

    for (const e of this.elements) {
      visitor(e);
    }
  }

  getSaveModel() {
    return Object.assign({}, this.options, {
      elements: this.elements.map(v => v.getSaveModel())
    });
  }

}

/***/ }),

/***/ "./public/app/features/canvas/runtime/root.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RootElement": () => (/* binding */ RootElement)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _frame__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/features/canvas/runtime/frame.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
const _excluded = ["placement", "constraint"];

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




class RootElement extends _frame__WEBPACK_IMPORTED_MODULE_1__.FrameState {
  constructor(options, scene, changeCallback) {
    super(options, scene);
    this.options = options;
    this.scene = scene;
    this.changeCallback = changeCallback;

    _defineProperty(this, "setRootRef", target => {
      this.div = target;
    });

    this.options = options;
    this.scene = scene;
    this.changeCallback = changeCallback;
    this.sizeStyle = {
      height: '100%',
      width: '100%'
    };
  }

  isRoot() {
    return true;
  } // root type can not change


  onChange(options) {
    this.revId++;
    this.options = Object.assign({}, options);
    this.changeCallback();
  }

  getSaveModel() {
    const _this$options = this.options,
          rest = _objectWithoutPropertiesLoose(_this$options, _excluded);

    return Object.assign({}, rest, {
      // everything except placement & constraint
      elements: this.elements.map(v => v.getSaveModel())
    });
  }

  render() {
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)("div", {
      ref: this.setRootRef,
      style: Object.assign({}, this.sizeStyle, this.dataStyle),
      children: this.elements.map(v => v.render())
    }, this.UID);
  }

}

/***/ }),

/***/ "./public/app/features/canvas/runtime/scene.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Scene": () => (/* binding */ Scene)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var moveable__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./.yarn/cache/moveable-npm-0.28.0-32d066096a-1fee85a8c7.zip/node_modules/moveable/dist/moveable.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/ReplaySubject.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/Subject.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/first.js");
/* harmony import */ var selecto__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./.yarn/cache/selecto-npm-1.15.0-eb84959df5-ae19513c77.zip/node_modules/selecto/dist/selecto.esm.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_core_config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/core/config.ts");
/* harmony import */ var app_features_canvas__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/features/canvas/index.ts");
/* harmony import */ var app_features_dimensions_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/features/dimensions/utils.ts");
/* harmony import */ var app_plugins_panel_canvas_types__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/panel/canvas/types.ts");
/* harmony import */ var _frame__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/features/canvas/runtime/frame.tsx");
/* harmony import */ var _root__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./public/app/features/canvas/runtime/root.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }















class Scene {
  // called after resize/drag for editor updates
  constructor(cfg, enableEditing, onSave) {
    this.onSave = onSave;

    _defineProperty(this, "styles", getStyles(app_core_config__WEBPACK_IMPORTED_MODULE_3__.config.theme2));

    _defineProperty(this, "selection", new rxjs__WEBPACK_IMPORTED_MODULE_10__.ReplaySubject(1));

    _defineProperty(this, "moved", new rxjs__WEBPACK_IMPORTED_MODULE_11__.Subject());

    _defineProperty(this, "byName", new Map());

    _defineProperty(this, "root", void 0);

    _defineProperty(this, "revId", 0);

    _defineProperty(this, "width", 0);

    _defineProperty(this, "height", 0);

    _defineProperty(this, "style", {});

    _defineProperty(this, "data", void 0);

    _defineProperty(this, "selecto", void 0);

    _defineProperty(this, "moveable", void 0);

    _defineProperty(this, "div", void 0);

    _defineProperty(this, "currentLayer", void 0);

    _defineProperty(this, "isEditingEnabled", void 0);

    _defineProperty(this, "skipNextSelectionBroadcast", false);

    _defineProperty(this, "getNextElementName", (isFrame = false) => {
      const label = isFrame ? 'Frame' : 'Element';
      let idx = this.byName.size + 1;
      const max = idx + 100;

      while ( true && idx < max) {
        const name = `${label} ${idx++}`;

        if (!this.byName.has(name)) {
          return name;
        }
      }

      return `${label} ${Date.now()}`;
    });

    _defineProperty(this, "canRename", v => {
      return !this.byName.has(v);
    });

    _defineProperty(this, "context", {
      getColor: color => (0,app_features_dimensions_utils__WEBPACK_IMPORTED_MODULE_5__.getColorDimensionFromData)(this.data, color),
      getScale: scale => (0,app_features_dimensions_utils__WEBPACK_IMPORTED_MODULE_5__.getScaleDimensionFromData)(this.data, scale),
      getScalar: scalar => (0,app_features_dimensions_utils__WEBPACK_IMPORTED_MODULE_5__.getScalarDimensionFromData)(this.data, scalar),
      getText: text => (0,app_features_dimensions_utils__WEBPACK_IMPORTED_MODULE_5__.getTextDimensionFromData)(this.data, text),
      getResource: res => (0,app_features_dimensions_utils__WEBPACK_IMPORTED_MODULE_5__.getResourceDimensionFromData)(this.data, res)
    });

    _defineProperty(this, "generateFrameContainer", elements => {
      let minTop = Infinity;
      let minLeft = Infinity;
      let maxRight = 0;
      let maxBottom = 0;
      elements.forEach(element => {
        var _element$div;

        const elementContainer = (_element$div = element.div) === null || _element$div === void 0 ? void 0 : _element$div.getBoundingClientRect();

        if (!elementContainer) {
          return;
        }

        if (minTop > elementContainer.top) {
          minTop = elementContainer.top;
        }

        if (minLeft > elementContainer.left) {
          minLeft = elementContainer.left;
        }

        if (maxRight < elementContainer.right) {
          maxRight = elementContainer.right;
        }

        if (maxBottom < elementContainer.bottom) {
          maxBottom = elementContainer.bottom;
        }
      });
      return {
        top: minTop,
        left: minLeft,
        width: maxRight - minLeft,
        height: maxBottom - minTop
      };
    });

    _defineProperty(this, "save", (updateMoveable = false) => {
      this.onSave(this.root.getSaveModel());

      if (updateMoveable) {
        setTimeout(() => {
          if (this.div) {
            this.initMoveable(true, this.isEditingEnabled);
          }
        }, 100);
      }
    });

    _defineProperty(this, "findElementByTarget", target => {
      // We will probably want to add memoization to this as we are calling on drag / resize
      const stack = [...this.root.elements];

      while (stack.length > 0) {
        const currentElement = stack.shift();

        if (currentElement && currentElement.div && currentElement.div === target) {
          return currentElement;
        }

        const nestedElements = currentElement instanceof _frame__WEBPACK_IMPORTED_MODULE_7__.FrameState ? currentElement.elements : [];

        for (const nestedElement of nestedElements) {
          stack.unshift(nestedElement);
        }
      }

      return undefined;
    });

    _defineProperty(this, "setRef", sceneContainer => {
      this.div = sceneContainer;
    });

    _defineProperty(this, "select", selection => {
      if (this.selecto) {
        this.selecto.setSelectedTargets(selection.targets);
        this.updateSelection(selection);
      }
    });

    _defineProperty(this, "updateSelection", selection => {
      this.moveable.target = selection.targets;

      if (this.skipNextSelectionBroadcast) {
        this.skipNextSelectionBroadcast = false;
        return;
      }

      if (selection.frame) {
        this.selection.next([selection.frame]);
      } else {
        const s = selection.targets.map(t => this.findElementByTarget(t));
        this.selection.next(s);
      }
    });

    _defineProperty(this, "generateTargetElements", rootElements => {
      let targetElements = [];
      const stack = [...rootElements];

      while (stack.length > 0) {
        const currentElement = stack.shift();

        if (currentElement && currentElement.div) {
          targetElements.push(currentElement.div);
        }

        const nestedElements = currentElement instanceof _frame__WEBPACK_IMPORTED_MODULE_7__.FrameState ? currentElement.elements : [];

        for (const nestedElement of nestedElements) {
          stack.unshift(nestedElement);
        }
      }

      return targetElements;
    });

    _defineProperty(this, "initMoveable", (destroySelecto = false, allowChanges = true) => {
      const targetElements = this.generateTargetElements(this.root.elements);

      if (destroySelecto && this.selecto) {
        this.selecto.destroy();
      }

      this.selecto = new selecto__WEBPACK_IMPORTED_MODULE_12__["default"]({
        container: this.div,
        selectableTargets: targetElements,
        selectByClick: true
      });
      this.moveable = new moveable__WEBPACK_IMPORTED_MODULE_13__["default"](this.div, {
        draggable: allowChanges,
        resizable: allowChanges,
        origin: false
      }).on('clickGroup', event => {
        this.selecto.clickTarget(event.inputEvent, event.inputTarget);
      }).on('drag', event => {
        const targetedElement = this.findElementByTarget(event.target);
        targetedElement.applyDrag(event);
      }).on('dragGroup', e => {
        e.events.forEach(event => {
          const targetedElement = this.findElementByTarget(event.target);
          targetedElement.applyDrag(event);
        });
      }).on('dragEnd', event => {
        const targetedElement = this.findElementByTarget(event.target);

        if (targetedElement) {
          targetedElement === null || targetedElement === void 0 ? void 0 : targetedElement.setPlacementFromConstraint();
        }

        this.moved.next(Date.now());
      }).on('resize', event => {
        const targetedElement = this.findElementByTarget(event.target);
        targetedElement.applyResize(event);
        this.moved.next(Date.now()); // TODO only on end
      }).on('resizeGroup', e => {
        e.events.forEach(event => {
          const targetedElement = this.findElementByTarget(event.target);
          targetedElement.applyResize(event);
        });
        this.moved.next(Date.now()); // TODO only on end
      }).on('resizeEnd', event => {
        const targetedElement = this.findElementByTarget(event.target);

        if (targetedElement) {
          targetedElement === null || targetedElement === void 0 ? void 0 : targetedElement.setPlacementFromConstraint();
        }
      });
      let targets = [];
      this.selecto.on('dragStart', event => {
        const selectedTarget = event.inputEvent.target;
        const isTargetMoveableElement = this.moveable.isMoveableElement(selectedTarget) || targets.some(target => target === selectedTarget || target.contains(selectedTarget));

        if (isTargetMoveableElement) {
          // Prevent drawing selection box when selected target is a moveable element
          event.stop();
        }
      }).on('selectEnd', event => {
        targets = event.selected;
        this.updateSelection({
          targets
        });

        if (event.isDragStart) {
          event.inputEvent.preventDefault();
          setTimeout(() => {
            this.moveable.dragStart(event.inputEvent);
          });
        }
      });
    });

    this.onSave = onSave;
    this.root = this.load(cfg, enableEditing);
  }

  load(cfg, enableEditing) {
    this.root = new _root__WEBPACK_IMPORTED_MODULE_8__.RootElement(cfg !== null && cfg !== void 0 ? cfg : {
      type: 'frame',
      elements: [app_features_canvas__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_CANVAS_ELEMENT_CONFIG]
    }, this, this.save // callback when changes are made
    );
    this.isEditingEnabled = enableEditing;
    setTimeout(() => {
      if (this.div) {
        // If editing is enabled, clear selecto instance
        const destroySelecto = enableEditing;
        this.initMoveable(destroySelecto, enableEditing);
        this.currentLayer = this.root;
        this.selection.next([]);
      }
    }, 100);
    return this.root;
  }

  updateData(data) {
    this.data = data;
    this.root.updateData(this.context);
  }

  updateSize(width, height) {
    var _this$selecto;

    this.width = width;
    this.height = height;
    this.style = {
      width,
      height
    };

    if ((_this$selecto = this.selecto) !== null && _this$selecto !== void 0 && _this$selecto.getSelectedTargets().length) {
      this.clearCurrentSelection();
    }
  }

  frameSelection() {
    this.selection.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_14__.first)()).subscribe(currentSelectedElements => {
      var _currentLayer$div;

      const currentLayer = currentSelectedElements[0].parent;
      const newLayer = new _frame__WEBPACK_IMPORTED_MODULE_7__.FrameState({
        type: 'frame',
        name: this.getNextElementName(true),
        elements: []
      }, this, currentSelectedElements[0].parent);
      const framePlacement = this.generateFrameContainer(currentSelectedElements);
      newLayer.options.placement = framePlacement;
      currentSelectedElements.forEach(element => {
        var _element$div2;

        const elementContainer = (_element$div2 = element.div) === null || _element$div2 === void 0 ? void 0 : _element$div2.getBoundingClientRect();
        element.setPlacementFromConstraint(elementContainer, framePlacement);
        currentLayer.doAction(app_plugins_panel_canvas_types__WEBPACK_IMPORTED_MODULE_6__.LayerActionID.Delete, element);
        newLayer.doAction(app_plugins_panel_canvas_types__WEBPACK_IMPORTED_MODULE_6__.LayerActionID.Duplicate, element, false, false);
      });
      newLayer.setPlacementFromConstraint(framePlacement, (_currentLayer$div = currentLayer.div) === null || _currentLayer$div === void 0 ? void 0 : _currentLayer$div.getBoundingClientRect());
      currentLayer.elements.push(newLayer);
      this.byName.set(newLayer.getName(), newLayer);
      this.save();
    });
  }

  clearCurrentSelection(skipNextSelectionBroadcast = false) {
    var _this$selecto2;

    this.skipNextSelectionBroadcast = skipNextSelectionBroadcast;
    let event = new MouseEvent('click');
    (_this$selecto2 = this.selecto) === null || _this$selecto2 === void 0 ? void 0 : _this$selecto2.clickTarget(event, this.div);
  }

  updateCurrentLayer(newLayer) {
    this.currentLayer = newLayer;
    this.clearCurrentSelection();
    this.save();
  }

  render() {
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("div", {
      className: this.styles.wrap,
      style: this.style,
      ref: this.setRef,
      children: this.root.render()
    }, this.revId);
  }

}
const getStyles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.stylesFactory)(theme => ({
  wrap: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    overflow: hidden;
    position: relative;
  `,
  toolbar: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    position: absolute;
    bottom: 0;
    margin: 10px;
  `
}));

/***/ }),

/***/ "./public/app/features/canvas/types.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BackgroundImageSize": () => (/* binding */ BackgroundImageSize),
/* harmony export */   "HorizontalConstraint": () => (/* binding */ HorizontalConstraint),
/* harmony export */   "VerticalConstraint": () => (/* binding */ VerticalConstraint)
/* harmony export */ });
let HorizontalConstraint;

(function (HorizontalConstraint) {
  HorizontalConstraint["Left"] = "left";
  HorizontalConstraint["Right"] = "right";
  HorizontalConstraint["LeftRight"] = "leftright";
  HorizontalConstraint["Center"] = "center";
  HorizontalConstraint["Scale"] = "scale";
})(HorizontalConstraint || (HorizontalConstraint = {}));

let VerticalConstraint;

(function (VerticalConstraint) {
  VerticalConstraint["Top"] = "top";
  VerticalConstraint["Bottom"] = "bottom";
  VerticalConstraint["TopBottom"] = "topbottom";
  VerticalConstraint["Center"] = "center";
  VerticalConstraint["Scale"] = "scale";
})(VerticalConstraint || (VerticalConstraint = {}));

let BackgroundImageSize;

(function (BackgroundImageSize) {
  BackgroundImageSize["Original"] = "original";
  BackgroundImageSize["Contain"] = "contain";
  BackgroundImageSize["Cover"] = "cover";
  BackgroundImageSize["Fill"] = "fill";
  BackgroundImageSize["Tile"] = "tile";
})(BackgroundImageSize || (BackgroundImageSize = {}));

/***/ }),

/***/ "./public/app/plugins/panel/canvas/CanvasPanel.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CanvasPanel": () => (/* binding */ CanvasPanel),
/* harmony export */   "activePanelSubject": () => (/* binding */ activePanelSubject)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/ReplaySubject.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/Subscription.js");
/* harmony import */ var _grafana_runtime_src__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_features_canvas_runtime_scene__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/features/canvas/runtime/scene.tsx");
/* harmony import */ var app_types_events__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/types/events.ts");
/* harmony import */ var _InlineEdit__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/panel/canvas/InlineEdit.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }












let canvasInstances = [];
let activeCanvasPanel = undefined;
let isInlineEditOpen = false;
const activePanelSubject = new rxjs__WEBPACK_IMPORTED_MODULE_8__.ReplaySubject(1);
class CanvasPanel extends react__WEBPACK_IMPORTED_MODULE_1__.Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "panelContext", {});

    _defineProperty(this, "scene", void 0);

    _defineProperty(this, "subs", new rxjs__WEBPACK_IMPORTED_MODULE_9__.Subscription());

    _defineProperty(this, "needsReload", false);

    _defineProperty(this, "styles", getStyles(_grafana_runtime_src__WEBPACK_IMPORTED_MODULE_2__.config.theme));

    _defineProperty(this, "isEditing", _grafana_runtime_src__WEBPACK_IMPORTED_MODULE_2__.locationService.getSearchObject().editPanel !== undefined);

    _defineProperty(this, "onUpdateScene", root => {
      const {
        onOptionsChange,
        options
      } = this.props;
      onOptionsChange(Object.assign({}, options, {
        root
      }));
      this.setState({
        refresh: this.state.refresh + 1
      }); // console.log('send changes', root);
    });

    _defineProperty(this, "inlineEditButtonClick", () => {
      if (isInlineEditOpen) {
        this.forceUpdate();
        this.setActivePanel();
        return;
      }

      this.setActivePanel();
      this.setState({
        openInlineEdit: true
      });
      isInlineEditOpen = true;
    });

    _defineProperty(this, "inlineEditButtonClose", () => {
      this.setState({
        openInlineEdit: false
      });
      isInlineEditOpen = false;
    });

    _defineProperty(this, "setActivePanel", () => {
      activeCanvasPanel = this;
      activePanelSubject.next({
        panel: this
      });
    });

    _defineProperty(this, "renderInlineEdit", () => {
      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_InlineEdit__WEBPACK_IMPORTED_MODULE_6__.InlineEdit, {
        onClose: () => this.inlineEditButtonClose()
      });
    });

    this.state = {
      refresh: 0,
      openInlineEdit: false
    }; // Only the initial options are ever used.
    // later changes are all controlled by the scene

    this.scene = new app_features_canvas_runtime_scene__WEBPACK_IMPORTED_MODULE_4__.Scene(this.props.options.root, this.props.options.inlineEditing, this.onUpdateScene);
    this.scene.updateSize(props.width, props.height);
    this.scene.updateData(props.data);
    this.subs.add(this.props.eventBus.subscribe(app_types_events__WEBPACK_IMPORTED_MODULE_5__.PanelEditEnteredEvent, evt => {
      // Remove current selection when entering edit mode for any panel in dashboard
      this.scene.clearCurrentSelection();
      this.inlineEditButtonClose();
    }));
    this.subs.add(this.props.eventBus.subscribe(app_types_events__WEBPACK_IMPORTED_MODULE_5__.PanelEditExitedEvent, evt => {
      if (this.props.id === evt.payload) {
        this.needsReload = true;
      }
    }));
  }

  componentDidMount() {
    activeCanvasPanel = this;
    activePanelSubject.next({
      panel: this
    });
    this.panelContext = this.context;

    if (this.panelContext.onInstanceStateChange) {
      this.panelContext.onInstanceStateChange({
        scene: this.scene,
        layer: this.scene.root
      });
      this.subs.add(this.scene.selection.subscribe({
        next: v => {
          this.panelContext.onInstanceStateChange({
            scene: this.scene,
            selected: v,
            layer: this.scene.root
          });
          activeCanvasPanel = this;
          activePanelSubject.next({
            panel: this
          });
          canvasInstances.forEach(canvasInstance => {
            if (canvasInstance !== activeCanvasPanel) {
              canvasInstance.scene.clearCurrentSelection(true);
            }
          });
        }
      }));
    }

    canvasInstances.push(this);
  }

  componentWillUnmount() {
    this.subs.unsubscribe();
    isInlineEditOpen = false;
    canvasInstances = canvasInstances.filter(ci => {
      var _activeCanvasPanel;

      return ci.props.id !== ((_activeCanvasPanel = activeCanvasPanel) === null || _activeCanvasPanel === void 0 ? void 0 : _activeCanvasPanel.props.id);
    });
  } // NOTE, all changes to the scene flow through this function
  // even the editor gets current state from the same scene instance!


  shouldComponentUpdate(nextProps, nextState) {
    const {
      width,
      height,
      data
    } = this.props;
    let changed = false;

    if (width !== nextProps.width || height !== nextProps.height) {
      this.scene.updateSize(nextProps.width, nextProps.height);
      changed = true;
    }

    if (data !== nextProps.data) {
      this.scene.updateData(nextProps.data);
      changed = true;
    }

    if (this.state.refresh !== nextState.refresh) {
      changed = true;
    }

    if (this.state.openInlineEdit !== nextState.openInlineEdit) {
      changed = true;
    } // After editing, the options are valid, but the scene was in a different panel or inline editing mode has changed


    const shouldUpdateSceneAndPanel = this.needsReload && this.props.options !== nextProps.options;
    const inlineEditingSwitched = this.props.options.inlineEditing !== nextProps.options.inlineEditing;

    if (shouldUpdateSceneAndPanel || inlineEditingSwitched) {
      this.needsReload = false;
      this.scene.load(nextProps.options.root, nextProps.options.inlineEditing);
      this.scene.updateSize(nextProps.width, nextProps.height);
      this.scene.updateData(nextProps.data);
      changed = true;

      if (inlineEditingSwitched && this.props.options.inlineEditing) {
        var _this$scene$selecto;

        (_this$scene$selecto = this.scene.selecto) === null || _this$scene$selecto === void 0 ? void 0 : _this$scene$selecto.destroy();
      }
    }

    return changed;
  }

  render() {
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.Fragment, {
      children: [this.scene.render(), this.props.options.inlineEditing && !this.isEditing && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
          className: this.styles.inlineEditButton,
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
            size: "lg",
            variant: "secondary",
            icon: "edit",
            "data-btninlineedit": this.props.id,
            onClick: this.inlineEditButtonClick
          })
        }), this.state.openInlineEdit && this.renderInlineEdit()]
      })]
    });
  }

}

_defineProperty(CanvasPanel, "contextType", _grafana_ui__WEBPACK_IMPORTED_MODULE_3__.PanelContextRoot);

const getStyles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.stylesFactory)(theme => ({
  inlineEditButton: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    position: absolute;
    bottom: 8px;
    left: 8px;
    z-index: 999;
  `
}));

/***/ }),

/***/ "./public/app/plugins/panel/canvas/InlineEdit.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InlineEdit": () => (/* binding */ InlineEdit)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_draggable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/react-draggable-virtual-eb201fa540/0/cache/react-draggable-npm-4.4.4-f0b7a5c546-b8258a5893.zip/node_modules/react-draggable/build/cjs/cjs.js");
/* harmony import */ var react_draggable__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_draggable__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var react_resizable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/__virtual__/react-resizable-virtual-13412137cd/0/cache/react-resizable-npm-3.0.4-aa39f9db2b-cbf86ad04b.zip/node_modules/react-resizable/index.js");
/* harmony import */ var react_resizable__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react_resizable__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_core_store__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/core/store.ts");
/* harmony import */ var _InlineEditBody__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/panel/canvas/InlineEditBody.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _div, _InlineEditBody;










const OFFSET_X = 70;
const InlineEdit = ({
  onClose
}) => {
  const btnInlineEdit = document.querySelector('[data-btninlineedit]').getBoundingClientRect();
  const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.useStyles2)(getStyles);
  const inlineEditKey = 'inlineEditPanel';
  const defaultMeasurements = {
    width: 350,
    height: 400
  };
  const defaultX = btnInlineEdit.x + OFFSET_X;
  const defaultY = btnInlineEdit.y - defaultMeasurements.height;
  const savedPlacement = app_core_store__WEBPACK_IMPORTED_MODULE_5__["default"].getObject(inlineEditKey, {
    x: defaultX,
    y: defaultY,
    w: defaultMeasurements.width,
    h: defaultMeasurements.height
  });
  const [measurements, setMeasurements] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({
    width: savedPlacement.w,
    height: savedPlacement.h
  });
  const [placement, setPlacement] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({
    x: savedPlacement.x,
    y: savedPlacement.y
  });

  const onDragStop = (event, dragElement) => {
    let x = dragElement.x < 0 ? 0 : dragElement.x;
    let y = dragElement.y < 0 ? 0 : dragElement.y;
    setPlacement({
      x: x,
      y: y
    });
    saveToStore(x, y, measurements.width, measurements.height);
  };

  const onResizeStop = (event, data) => {
    const {
      size
    } = data;
    setMeasurements({
      width: size.width,
      height: size.height
    });
    saveToStore(placement.x, placement.y, size.width, size.height);
  };

  const saveToStore = (x, y, width, height) => {
    app_core_store__WEBPACK_IMPORTED_MODULE_5__["default"].setObject(inlineEditKey, {
      x: x,
      y: y,
      w: width,
      h: height
    });
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.Portal, {
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
      className: styles.draggableWrapper,
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)((react_draggable__WEBPACK_IMPORTED_MODULE_2___default()), {
        handle: "strong",
        onStop: onDragStop,
        position: {
          x: placement.x,
          y: placement.y
        },
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(react_resizable__WEBPACK_IMPORTED_MODULE_3__.Resizable, {
          height: measurements.height,
          width: measurements.width,
          onResize: onResizeStop,
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
            className: styles.inlineEditorContainer,
            style: {
              height: `${measurements.height}px`,
              width: `${measurements.width}px`
            },
            ref: ref,
            children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("strong", {
              className: styles.inlineEditorHeader,
              children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
                className: styles.placeholder
              }), _div || (_div = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
                children: "Canvas Inline Editor"
              })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.IconButton, {
                name: "times",
                size: "xl",
                className: styles.inlineEditorClose,
                onClick: onClose
              })]
            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
              className: styles.inlineEditorContentWrapper,
              children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
                className: styles.inlineEditorContent,
                children: _InlineEditBody || (_InlineEditBody = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_InlineEditBody__WEBPACK_IMPORTED_MODULE_6__.InlineEditBody, {}))
              })
            })]
          })
        })
      })
    })
  });
};

const getStyles = theme => ({
  inlineEditorContainer: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    display: flex;
    flex-direction: column;
    background: ${theme.v1.colors.panelBg};
    box-shadow: 5px 5px 20px -5px #000000;
    z-index: 1000;
    opacity: 1;
  `,
  draggableWrapper: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    width: 0;
    height: 0;
  `,
  inlineEditorHeader: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    display: flex;
    align-items: center;
    justify-content: center;
    background: ${theme.colors.background.canvas};
    border: 1px solid ${theme.colors.border.weak};
    height: 40px;
    cursor: move;
  `,
  inlineEditorContent: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    white-space: pre-wrap;
    padding: 10px;
  `,
  inlineEditorClose: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    margin-left: auto;
  `,
  placeholder: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    width: 24px;
    height: 24px;
    visibility: hidden;
    margin-right: auto;
  `,
  inlineEditorContentWrapper: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
    overflow: scroll;
  `
});

/***/ }),

/***/ "./public/app/plugins/panel/canvas/InlineEditBody.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InlineEditBody": () => (/* binding */ InlineEditBody)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_use__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./.yarn/__virtual__/react-use-virtual-00326e70ba/0/cache/react-use-npm-17.3.2-a032cbeb01-7379460f51.zip/node_modules/react-use/esm/useObservable.js");
/* harmony import */ var app_features_canvas_runtime_frame__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/canvas/runtime/frame.tsx");
/* harmony import */ var app_features_dashboard_components_PanelEditor_OptionsPaneCategoryDescriptor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/features/dashboard/components/PanelEditor/OptionsPaneCategoryDescriptor.tsx");
/* harmony import */ var app_features_dashboard_components_PanelEditor_getVisualizationOptions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/features/dashboard/components/PanelEditor/getVisualizationOptions.tsx");
/* harmony import */ var app_features_dashboard_components_PanelEditor_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/features/dashboard/components/PanelEditor/utils.ts");
/* harmony import */ var _CanvasPanel__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/panel/canvas/CanvasPanel.tsx");
/* harmony import */ var _editor_elementEditor__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/plugins/panel/canvas/editor/elementEditor.tsx");
/* harmony import */ var _editor_layerEditor__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./public/app/plugins/panel/canvas/editor/layerEditor.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");












const InlineEditBody = () => {
  var _activePanel$panel$co;

  const activePanel = (0,react_use__WEBPACK_IMPORTED_MODULE_10__["default"])(_CanvasPanel__WEBPACK_IMPORTED_MODULE_6__.activePanelSubject);
  const instanceState = activePanel === null || activePanel === void 0 ? void 0 : (_activePanel$panel$co = activePanel.panel.context) === null || _activePanel$panel$co === void 0 ? void 0 : _activePanel$panel$co.instanceState;
  const pane = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {
    const state = instanceState;

    if (!state) {
      return new app_features_dashboard_components_PanelEditor_OptionsPaneCategoryDescriptor__WEBPACK_IMPORTED_MODULE_3__.OptionsPaneCategoryDescriptor({
        id: 'root',
        title: 'root'
      });
    }

    const supplier = (builder, context) => {
      builder.addNestedOptions((0,_editor_layerEditor__WEBPACK_IMPORTED_MODULE_8__.getLayerEditor)(instanceState));
      const selection = state.selected;

      if ((selection === null || selection === void 0 ? void 0 : selection.length) === 1) {
        const element = selection[0];

        if (!(element instanceof app_features_canvas_runtime_frame__WEBPACK_IMPORTED_MODULE_2__.FrameState)) {
          builder.addNestedOptions((0,_editor_elementEditor__WEBPACK_IMPORTED_MODULE_7__.getElementEditor)({
            category: [`Selected element (${element.options.name})`],
            element,
            scene: state.scene
          }));
        }
      }
    };

    return getOptionsPaneCategoryDescriptor({}, supplier);
  }, [instanceState]);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsxs)("div", {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("div", {
      children: pane.items.map(v => v.render())
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("div", {
      children: pane.categories.map(c => {
        return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsxs)("div", {
          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("h5", {
            children: c.props.title
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("div", {
            children: c.items.map(s => s.render())
          })]
        }, c.props.id);
      })
    })]
  });
}; // 🤮🤮🤮🤮 this oddly does not actually do anything, but structure is required.  I'll try to clean it up...

function getOptionsPaneCategoryDescriptor(props, supplier) {
  const context = {
    data: props.input,
    options: props.options
  };
  const root = new app_features_dashboard_components_PanelEditor_OptionsPaneCategoryDescriptor__WEBPACK_IMPORTED_MODULE_3__.OptionsPaneCategoryDescriptor({
    id: 'root',
    title: 'root'
  });

  const getOptionsPaneCategory = categoryNames => {
    if (categoryNames !== null && categoryNames !== void 0 && categoryNames.length) {
      const key = categoryNames[0];
      let sub = root.categories.find(v => v.props.id === key);

      if (!sub) {
        sub = new app_features_dashboard_components_PanelEditor_OptionsPaneCategoryDescriptor__WEBPACK_IMPORTED_MODULE_3__.OptionsPaneCategoryDescriptor({
          id: key,
          title: key
        });
        root.categories.push(sub);
      }

      return sub;
    }

    return root;
  };

  const access = {
    getValue: path => (0,lodash__WEBPACK_IMPORTED_MODULE_0__.get)(props.options, path),
    onChange: (path, value) => {
      props.onChange((0,app_features_dashboard_components_PanelEditor_utils__WEBPACK_IMPORTED_MODULE_5__.setOptionImmutably)(props.options, path, value));
    }
  }; // Use the panel options loader

  (0,app_features_dashboard_components_PanelEditor_getVisualizationOptions__WEBPACK_IMPORTED_MODULE_4__.fillOptionsPaneItems)(supplier, access, getOptionsPaneCategory, context);
  return root;
}

/***/ }),

/***/ "./public/app/plugins/panel/canvas/editor/APIEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "APIEditor": () => (/* binding */ APIEditor),
/* harmony export */   "callApi": () => (/* binding */ callApi)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_core_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/core/core.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _JSONFormatter, _br;









const dummyStringSettings = {
  settings: {}
};
const callApi = (api, isTest = false) => {
  if (api) {
    var _api$data;

    (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_2__.getBackendSrv)().fetch({
      url: api.endpoint,
      method: 'POST',
      data: (_api$data = api.data) !== null && _api$data !== void 0 ? _api$data : {}
    }).subscribe({
      error: error => {
        if (isTest) {
          app_core_core__WEBPACK_IMPORTED_MODULE_4__.appEvents.emit(_grafana_data__WEBPACK_IMPORTED_MODULE_1__.AppEvents.alertError, ['Error has occurred: ', JSON.stringify(error)]);
          console.error(error);
        }
      },
      complete: () => {
        if (isTest) {
          app_core_core__WEBPACK_IMPORTED_MODULE_4__.appEvents.emit(_grafana_data__WEBPACK_IMPORTED_MODULE_1__.AppEvents.alertSuccess, ['Test successful']);
        }
      }
    });
  }
};
const APIEditor = props => {
  var _value$data, _value$data2;

  const {
    value,
    context,
    onChange
  } = props;
  const labelWidth = 9;
  const onEndpointChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(endpoint => {
    onChange(Object.assign({}, value, {
      endpoint
    }));
  }, [onChange, value]);
  const onDataChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(data => {
    onChange(Object.assign({}, value, {
      data
    }));
  }, [onChange, value]);

  const renderJSON = data => {
    try {
      const json = JSON.parse(data);
      return _JSONFormatter || (_JSONFormatter = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.JSONFormatter, {
        json: json
      }));
    } catch (error) {
      return `Invalid JSON provided: ${error.message}`;
    }
  };

  const renderTestAPIButton = api => {
    if (api && api.endpoint) {
      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
        onClick: () => callApi(api, true),
        title: 'Test API',
        children: "Test API"
      });
    }

    return;
  };

  return _grafana_runtime__WEBPACK_IMPORTED_MODULE_2__.config.disableSanitizeHtml ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.InlineFieldRow, {
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.InlineField, {
        label: 'Endpoint',
        labelWidth: labelWidth,
        grow: true,
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.StringValueEditor, {
          context: context,
          value: value === null || value === void 0 ? void 0 : value.endpoint,
          onChange: onEndpointChange,
          item: dummyStringSettings
        })
      })
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.InlineFieldRow, {
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.InlineField, {
        label: 'Data',
        labelWidth: labelWidth,
        grow: true,
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.StringValueEditor, {
          context: context,
          value: (_value$data = value === null || value === void 0 ? void 0 : value.data) !== null && _value$data !== void 0 ? _value$data : '{}',
          onChange: onDataChange,
          item: dummyStringSettings
        })
      })
    }), renderTestAPIButton(value), _br || (_br = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("br", {})), renderJSON((_value$data2 = value === null || value === void 0 ? void 0 : value.data) !== null && _value$data2 !== void 0 ? _value$data2 : '{}')]
  }) : /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
    children: "Must enable disableSanitizeHtml feature flag to access"
  });
};

/***/ }),

/***/ "./public/app/plugins/panel/canvas/editor/LayerElementListEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LayerElementListEditor": () => (/* binding */ LayerElementListEditor)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_core_app_events__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/core/app_events.ts");
/* harmony import */ var app_core_components_Layers_AddLayerButton__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/core/components/Layers/AddLayerButton.tsx");
/* harmony import */ var app_core_components_Layers_LayerDragDropList__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/core/components/Layers/LayerDragDropList.tsx");
/* harmony import */ var app_features_canvas__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/features/canvas/index.ts");
/* harmony import */ var app_features_canvas_elements_notFound__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/features/canvas/elements/notFound.tsx");
/* harmony import */ var app_features_canvas_runtime_element__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./public/app/features/canvas/runtime/element.tsx");
/* harmony import */ var app_features_canvas_runtime_frame__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./public/app/features/canvas/runtime/frame.tsx");
/* harmony import */ var app_types_events__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./public/app/types/events.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./public/app/plugins/panel/canvas/types.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _div, _div2, _br;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
















class LayerElementListEditor extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "getScene", () => {
      const {
        settings
      } = this.props.item;

      if (!(settings !== null && settings !== void 0 && settings.layer)) {
        return;
      }

      return settings.layer.scene;
    });

    _defineProperty(this, "onAddItem", sel => {
      var _canvasElementRegistr;

      const {
        settings
      } = this.props.item;

      if (!(settings !== null && settings !== void 0 && settings.layer)) {
        return;
      }

      const {
        layer
      } = settings;
      const item = (_canvasElementRegistr = app_features_canvas__WEBPACK_IMPORTED_MODULE_6__.canvasElementRegistry.getIfExists(sel.value)) !== null && _canvasElementRegistr !== void 0 ? _canvasElementRegistr : app_features_canvas_elements_notFound__WEBPACK_IMPORTED_MODULE_7__.notFoundItem;
      const newElementOptions = item.getNewOptions();
      newElementOptions.type = item.id;
      const newElement = new app_features_canvas_runtime_element__WEBPACK_IMPORTED_MODULE_8__.ElementState(item, newElementOptions, layer);
      newElement.updateData(layer.scene.context);
      layer.elements.push(newElement);
      layer.scene.save();
      layer.reinitializeMoveable();
    });

    _defineProperty(this, "onSelect", item => {
      const {
        settings
      } = this.props.item;

      if (settings !== null && settings !== void 0 && settings.scene) {
        try {
          let selection = {
            targets: []
          };

          if (item instanceof app_features_canvas_runtime_frame__WEBPACK_IMPORTED_MODULE_9__.FrameState) {
            const targetElements = [];
            targetElements.push(item === null || item === void 0 ? void 0 : item.div);
            selection.targets = targetElements;
            selection.frame = item;
            settings.scene.select(selection);
          } else if (item instanceof app_features_canvas_runtime_element__WEBPACK_IMPORTED_MODULE_8__.ElementState) {
            const targetElement = [item === null || item === void 0 ? void 0 : item.div];
            selection.targets = targetElement;
            settings.scene.select(selection);
          }
        } catch (error) {
          app_core_app_events__WEBPACK_IMPORTED_MODULE_3__["default"].emit(_grafana_data__WEBPACK_IMPORTED_MODULE_1__.AppEvents.alertError, ['Unable to select element, try selecting element in panel instead']);
        }
      }
    });

    _defineProperty(this, "onClearSelection", () => {
      const {
        settings
      } = this.props.item;

      if (!(settings !== null && settings !== void 0 && settings.layer)) {
        return;
      }

      const {
        layer
      } = settings;
      layer.scene.clearCurrentSelection();
    });

    _defineProperty(this, "onDragEnd", result => {
      if (!result.destination) {
        return;
      }

      const {
        settings
      } = this.props.item;

      if (!(settings !== null && settings !== void 0 && settings.layer)) {
        return;
      }

      const {
        layer
      } = settings;
      const count = layer.elements.length - 1;
      const src = (result.source.index - count) * -1;
      const dst = (result.destination.index - count) * -1;
      layer.reorder(src, dst);
    });

    _defineProperty(this, "goUpLayer", () => {
      const settings = this.props.item.settings;

      if (!(settings !== null && settings !== void 0 && settings.layer) || !(settings !== null && settings !== void 0 && settings.scene)) {
        return;
      }

      const {
        scene,
        layer
      } = settings;

      if (layer.parent) {
        scene.updateCurrentLayer(layer.parent);
      }
    });

    _defineProperty(this, "decoupleFrame", () => {
      const settings = this.props.item.settings;

      if (!(settings !== null && settings !== void 0 && settings.layer)) {
        return;
      }

      const {
        layer
      } = settings;
      this.deleteFrame();
      layer.elements.forEach(element => {
        var _element$div, _layer$parent, _layer$parent$div, _layer$parent2;

        const elementContainer = (_element$div = element.div) === null || _element$div === void 0 ? void 0 : _element$div.getBoundingClientRect();
        element.setPlacementFromConstraint(elementContainer, (_layer$parent = layer.parent) === null || _layer$parent === void 0 ? void 0 : (_layer$parent$div = _layer$parent.div) === null || _layer$parent$div === void 0 ? void 0 : _layer$parent$div.getBoundingClientRect());
        (_layer$parent2 = layer.parent) === null || _layer$parent2 === void 0 ? void 0 : _layer$parent2.doAction(_types__WEBPACK_IMPORTED_MODULE_11__.LayerActionID.Duplicate, element, false, false);
      });
    });

    _defineProperty(this, "onDecoupleFrame", () => {
      app_core_app_events__WEBPACK_IMPORTED_MODULE_3__["default"].publish(new app_types_events__WEBPACK_IMPORTED_MODULE_10__.ShowConfirmModalEvent({
        title: 'Decouple frame',
        text: `Are you sure you want to decouple this frame?`,
        text2: 'This will remove the frame and push nested elements in the next level up.',
        confirmText: 'Yes',
        yesText: 'Decouple',
        onConfirm: async () => {
          this.decoupleFrame();
        }
      }));
    });

    _defineProperty(this, "deleteFrame", () => {
      var _layer$parent3;

      const settings = this.props.item.settings;

      if (!(settings !== null && settings !== void 0 && settings.layer)) {
        return;
      }

      const {
        layer
      } = settings;
      const scene = this.getScene();
      scene === null || scene === void 0 ? void 0 : scene.byName.delete(layer.getName());
      layer.elements.forEach(element => scene === null || scene === void 0 ? void 0 : scene.byName.delete(element.getName()));
      (_layer$parent3 = layer.parent) === null || _layer$parent3 === void 0 ? void 0 : _layer$parent3.doAction(_types__WEBPACK_IMPORTED_MODULE_11__.LayerActionID.Delete, layer);
      this.goUpLayer();
    });

    _defineProperty(this, "onFrameSelection", () => {
      const scene = this.getScene();

      if (scene) {
        scene.frameSelection();
      } else {
        console.warn('no scene!');
      }
    });

    _defineProperty(this, "onDeleteFrame", () => {
      app_core_app_events__WEBPACK_IMPORTED_MODULE_3__["default"].publish(new app_types_events__WEBPACK_IMPORTED_MODULE_10__.ShowConfirmModalEvent({
        title: 'Delete frame',
        text: `Are you sure you want to delete this frame?`,
        text2: 'This will delete the frame and all nested elements.',
        icon: 'trash-alt',
        confirmText: 'Delete',
        yesText: 'Delete',
        onConfirm: async () => {
          this.deleteFrame();
        }
      }));
    });
  }

  render() {
    const settings = this.props.item.settings;

    if (!settings) {
      return _div || (_div = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_12__.jsx)("div", {
        children: "No settings"
      }));
    }

    const layer = settings.layer;

    if (!layer) {
      return _div2 || (_div2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_12__.jsx)("div", {
        children: "Missing layer?"
      }));
    }

    const onDelete = element => {
      layer.doAction(_types__WEBPACK_IMPORTED_MODULE_11__.LayerActionID.Delete, element);
    };

    const onDuplicate = element => {
      layer.doAction(_types__WEBPACK_IMPORTED_MODULE_11__.LayerActionID.Duplicate, element);
    };

    const getLayerInfo = element => {
      return element.options.type;
    };

    const onNameChange = (element, name) => {
      element.onChange(Object.assign({}, element.options, {
        name
      }));
    };

    const isFrame = element => {
      return element instanceof app_features_canvas_runtime_frame__WEBPACK_IMPORTED_MODULE_9__.FrameState;
    };

    const verifyLayerNameUniqueness = nameToVerify => {
      const scene = this.getScene();
      return Boolean(scene === null || scene === void 0 ? void 0 : scene.canRename(nameToVerify));
    };

    const selection = settings.selected ? settings.selected.map(v => v.getName()) : [];
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_12__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_12__.Fragment, {
      children: [!layer.isRoot() && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_12__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_12__.Fragment, {
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_12__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Button, {
          icon: "angle-up",
          size: "sm",
          variant: "secondary",
          onClick: this.goUpLayer,
          children: "Go up level"
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_12__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Button, {
          size: "sm",
          variant: "secondary",
          onClick: () => this.onSelect(layer),
          children: "Select frame"
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_12__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Button, {
          size: "sm",
          variant: "secondary",
          onClick: () => this.onDecoupleFrame(),
          children: "Decouple frame"
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_12__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Button, {
          size: "sm",
          variant: "secondary",
          onClick: () => this.onDeleteFrame(),
          children: "Delete frame"
        })]
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_12__.jsx)(app_core_components_Layers_LayerDragDropList__WEBPACK_IMPORTED_MODULE_5__.LayerDragDropList, {
        onDragEnd: this.onDragEnd,
        onSelect: this.onSelect,
        onDelete: onDelete,
        onDuplicate: onDuplicate,
        getLayerInfo: getLayerInfo,
        onNameChange: onNameChange,
        verifyLayerNameUniqueness: verifyLayerNameUniqueness,
        isFrame: isFrame,
        layers: layer.elements,
        selection: selection
      }), _br || (_br = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_12__.jsx)("br", {})), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_12__.jsxs)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.HorizontalGroup, {
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_12__.jsx)(app_core_components_Layers_AddLayerButton__WEBPACK_IMPORTED_MODULE_4__.AddLayerButton, {
          onChange: this.onAddItem,
          options: app_features_canvas__WEBPACK_IMPORTED_MODULE_6__.canvasElementRegistry.selectOptions().options,
          label: 'Add item'
        }), selection.length > 0 && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_12__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Button, {
          size: "sm",
          variant: "secondary",
          onClick: this.onClearSelection,
          children: "Clear selection"
        }), selection.length > 1 && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_12__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Button, {
          size: "sm",
          variant: "secondary",
          onClick: this.onFrameSelection,
          children: "Frame selection"
        })]
      })]
    });
  }

}

/***/ }),

/***/ "./public/app/plugins/panel/canvas/editor/PlacementEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PlacementEditor": () => (/* binding */ PlacementEditor)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_use__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/__virtual__/react-use-virtual-00326e70ba/0/cache/react-use-npm-17.3.2-a032cbeb01-7379460f51.zip/node_modules/react-use/esm/useObservable.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/Subject.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_features_canvas__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/canvas/index.ts");
/* harmony import */ var app_features_dimensions_editors_NumberInput__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/features/dimensions/editors/NumberInput.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _div, _div2, _br;










const places = ['top', 'left', 'bottom', 'right', 'width', 'height'];
const horizontalOptions = [{
  label: 'Left',
  value: app_features_canvas__WEBPACK_IMPORTED_MODULE_2__.HorizontalConstraint.Left
}, {
  label: 'Right',
  value: app_features_canvas__WEBPACK_IMPORTED_MODULE_2__.HorizontalConstraint.Right
}, {
  label: 'Left and right',
  value: app_features_canvas__WEBPACK_IMPORTED_MODULE_2__.HorizontalConstraint.LeftRight
}, {
  label: 'Center',
  value: app_features_canvas__WEBPACK_IMPORTED_MODULE_2__.HorizontalConstraint.Center
}, {
  label: 'Scale',
  value: app_features_canvas__WEBPACK_IMPORTED_MODULE_2__.HorizontalConstraint.Scale
}];
const verticalOptions = [{
  label: 'Top',
  value: app_features_canvas__WEBPACK_IMPORTED_MODULE_2__.VerticalConstraint.Top
}, {
  label: 'Bottom',
  value: app_features_canvas__WEBPACK_IMPORTED_MODULE_2__.VerticalConstraint.Bottom
}, {
  label: 'Top and bottom',
  value: app_features_canvas__WEBPACK_IMPORTED_MODULE_2__.VerticalConstraint.TopBottom
}, {
  label: 'Center',
  value: app_features_canvas__WEBPACK_IMPORTED_MODULE_2__.VerticalConstraint.Center
}, {
  label: 'Scale',
  value: app_features_canvas__WEBPACK_IMPORTED_MODULE_2__.VerticalConstraint.Scale
}];
const PlacementEditor = ({
  item
}) => {
  var _options$constraint;

  const settings = item.settings; // Will force a rerender whenever the subject changes

  (0,react_use__WEBPACK_IMPORTED_MODULE_5__["default"])(settings !== null && settings !== void 0 && settings.scene ? settings.scene.moved : new rxjs__WEBPACK_IMPORTED_MODULE_6__.Subject());

  if (!settings) {
    return _div || (_div = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
      children: "Loading..."
    }));
  }

  const element = settings.element;

  if (!element) {
    return _div2 || (_div2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
      children: "???"
    }));
  }

  const {
    options
  } = element;
  const {
    placement,
    constraint: layout
  } = options;

  const onHorizontalConstraintChange = h => {
    element.options.constraint.horizontal = h.value;
    element.setPlacementFromConstraint();
    settings.scene.revId++;
    settings.scene.save(true);
  };

  const onVerticalConstraintChange = v => {
    element.options.constraint.vertical = v.value;
    element.setPlacementFromConstraint();
    settings.scene.revId++;
    settings.scene.save(true);
  };

  const onPositionChange = (value, placement) => {
    element.options.placement[placement] = value !== null && value !== void 0 ? value : element.options.placement[placement];
    element.applyLayoutStylesToDiv();
    settings.scene.clearCurrentSelection();
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.VerticalGroup, {
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Select, {
        options: verticalOptions,
        onChange: onVerticalConstraintChange,
        value: layout === null || layout === void 0 ? void 0 : layout.vertical
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Select, {
        options: horizontalOptions,
        onChange: onHorizontalConstraintChange,
        value: (_options$constraint = options.constraint) === null || _options$constraint === void 0 ? void 0 : _options$constraint.horizontal
      })]
    }), _br || (_br = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("br", {})), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Field, {
      label: "Position",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.Fragment, {
        children: places.map(p => {
          const v = placement[p];

          if (v == null) {
            return null;
          }

          return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.InlineFieldRow, {
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.InlineField, {
              label: p,
              labelWidth: 8,
              grow: true,
              children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(app_features_dimensions_editors_NumberInput__WEBPACK_IMPORTED_MODULE_3__.NumberInput, {
                value: v,
                onChange: v => onPositionChange(v, p)
              })
            })
          }, p);
        })
      })
    })]
  });
};

/***/ }),

/***/ "./public/app/plugins/panel/canvas/editor/elementEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getElementEditor": () => (/* binding */ getElementEditor)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var app_features_canvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/features/canvas/index.ts");
/* harmony import */ var app_features_dashboard_components_PanelEditor_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/dashboard/components/PanelEditor/utils.ts");
/* harmony import */ var _PlacementEditor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/panel/canvas/editor/PlacementEditor.tsx");
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/panel/canvas/editor/options.ts");





function getElementEditor(opts) {
  return {
    category: opts.category,
    path: '--',
    // not used!
    // Note that canvas editor writes things to the scene!
    values: parent => ({
      getValue: path => {
        return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.get)(opts.element.options, path);
      },
      onChange: (path, value) => {
        let options = opts.element.options;

        if (path === 'type' && value) {
          const layer = app_features_canvas__WEBPACK_IMPORTED_MODULE_1__.canvasElementRegistry.getIfExists(value);

          if (!layer) {
            console.warn('layer does not exist', value);
            return;
          }

          options = Object.assign({}, options, layer.getNewOptions(options), {
            type: layer.id
          });
        } else {
          options = (0,app_features_dashboard_components_PanelEditor_utils__WEBPACK_IMPORTED_MODULE_2__.setOptionImmutably)(options, path, value);
        }

        opts.element.onChange(options);
        opts.element.updateData(opts.scene.context);
      }
    }),
    // Dynamically fill the selected element
    build: (builder, context) => {
      var _options$type;

      const {
        options
      } = opts.element;
      const layerTypes = app_features_canvas__WEBPACK_IMPORTED_MODULE_1__.canvasElementRegistry.selectOptions(options !== null && options !== void 0 && options.type // the selected value
      ? [options.type] // as an array
      : [app_features_canvas__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_CANVAS_ELEMENT_CONFIG.type]);
      builder.addSelect({
        path: 'type',
        name: undefined,
        // required, but hide space
        settings: {
          options: layerTypes.options
        }
      }); // force clean layer configuration

      const layer = app_features_canvas__WEBPACK_IMPORTED_MODULE_1__.canvasElementRegistry.getIfExists((_options$type = options === null || options === void 0 ? void 0 : options.type) !== null && _options$type !== void 0 ? _options$type : app_features_canvas__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_CANVAS_ELEMENT_CONFIG.type);
      let currentOptions = options;

      if (!currentOptions) {
        currentOptions = Object.assign({}, layer.getNewOptions(options), {
          type: layer.id,
          name: `Element ${Date.now()}.${Math.floor(Math.random() * 100)}`
        });
      }

      const ctx = Object.assign({}, context, {
        options: currentOptions
      });

      if (layer !== null && layer !== void 0 && layer.registerOptionsUI) {
        layer.registerOptionsUI(builder, ctx);
      }

      _options__WEBPACK_IMPORTED_MODULE_4__.optionBuilder.addBackground(builder, ctx);
      _options__WEBPACK_IMPORTED_MODULE_4__.optionBuilder.addBorder(builder, ctx);
      builder.addCustomEditor({
        category: ['Layout'],
        id: 'content',
        path: '__',
        // not used
        name: 'Constraints',
        editor: _PlacementEditor__WEBPACK_IMPORTED_MODULE_3__.PlacementEditor,
        settings: opts
      });
    }
  };
}

/***/ }),

/***/ "./public/app/plugins/panel/canvas/editor/layerEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getLayerEditor": () => (/* binding */ getLayerEditor)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var app_features_canvas_runtime_frame__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/features/canvas/runtime/frame.tsx");
/* harmony import */ var app_features_dashboard_components_PanelEditor_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/dashboard/components/PanelEditor/utils.ts");
/* harmony import */ var _LayerElementListEditor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/panel/canvas/editor/LayerElementListEditor.tsx");
/* harmony import */ var _PlacementEditor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/panel/canvas/editor/PlacementEditor.tsx");
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/panel/canvas/editor/options.ts");






function getLayerEditor(opts) {
  const {
    selected,
    scene
  } = opts;

  if (!scene.currentLayer) {
    scene.currentLayer = scene.root;
  }

  if (selected) {
    for (const element of selected) {
      if (element instanceof app_features_canvas_runtime_frame__WEBPACK_IMPORTED_MODULE_1__.FrameState) {
        scene.currentLayer = element;
        break;
      }

      if (element.parent) {
        scene.currentLayer = element.parent;
        break;
      }
    }
  }

  const options = scene.currentLayer.options || {
    elements: []
  };
  return {
    category: ['Layer'],
    path: '--',
    // not used!
    // Note that canvas editor writes things to the scene!
    values: parent => ({
      getValue: path => {
        return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.get)(options, path);
      },
      onChange: (path, value) => {
        var _scene$currentLayer, _scene$currentLayer2;

        if (path === 'type' && value) {
          console.warn('unable to change layer type');
          return;
        }

        const c = (0,app_features_dashboard_components_PanelEditor_utils__WEBPACK_IMPORTED_MODULE_2__.setOptionImmutably)(options, path, value);
        (_scene$currentLayer = scene.currentLayer) === null || _scene$currentLayer === void 0 ? void 0 : _scene$currentLayer.onChange(c);
        (_scene$currentLayer2 = scene.currentLayer) === null || _scene$currentLayer2 === void 0 ? void 0 : _scene$currentLayer2.updateData(scene.context);
      }
    }),
    // Dynamically fill the selected element
    build: (builder, context) => {
      const currentLayer = scene.currentLayer;

      if (currentLayer && !currentLayer.isRoot()) {// TODO: the non-root nav option
      }

      builder.addCustomEditor({
        id: 'content',
        path: 'root',
        name: 'Elements',
        editor: _LayerElementListEditor__WEBPACK_IMPORTED_MODULE_3__.LayerElementListEditor,
        settings: {
          scene,
          layer: scene.currentLayer,
          selected
        }
      });
      const ctx = Object.assign({}, context, {
        options
      });
      _options__WEBPACK_IMPORTED_MODULE_5__.optionBuilder.addBackground(builder, ctx);
      _options__WEBPACK_IMPORTED_MODULE_5__.optionBuilder.addBorder(builder, ctx);

      if (currentLayer && !currentLayer.isRoot()) {
        builder.addCustomEditor({
          category: ['Layout'],
          id: 'content',
          path: '__',
          // not used
          name: 'Constraints',
          editor: _PlacementEditor__WEBPACK_IMPORTED_MODULE_4__.PlacementEditor,
          settings: {
            scene: opts.scene,
            element: currentLayer
          }
        });
      }
    }
  };
}

/***/ }),

/***/ "./public/app/plugins/panel/canvas/editor/options.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "optionBuilder": () => (/* binding */ optionBuilder)
/* harmony export */ });
/* harmony import */ var app_features_canvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/features/canvas/index.ts");
/* harmony import */ var app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/features/dimensions/editors/index.ts");


const optionBuilder = {
  addBackground: (builder, context) => {
    const category = ['Background'];
    builder.addCustomEditor({
      category,
      id: 'background.color',
      path: 'background.color',
      name: 'Color',
      editor: app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_1__.ColorDimensionEditor,
      settings: {},
      defaultValue: {
        // Configured values
        fixed: ''
      }
    }).addCustomEditor({
      category,
      id: 'background.image',
      path: 'background.image',
      name: 'Image',
      editor: app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_1__.ResourceDimensionEditor,
      settings: {
        resourceType: 'image'
      }
    }).addRadio({
      category,
      path: 'background.size',
      name: 'Image size',
      settings: {
        options: [{
          value: app_features_canvas__WEBPACK_IMPORTED_MODULE_0__.BackgroundImageSize.Original,
          label: 'Original'
        }, {
          value: app_features_canvas__WEBPACK_IMPORTED_MODULE_0__.BackgroundImageSize.Contain,
          label: 'Contain'
        }, {
          value: app_features_canvas__WEBPACK_IMPORTED_MODULE_0__.BackgroundImageSize.Cover,
          label: 'Cover'
        }, {
          value: app_features_canvas__WEBPACK_IMPORTED_MODULE_0__.BackgroundImageSize.Fill,
          label: 'Fill'
        }, {
          value: app_features_canvas__WEBPACK_IMPORTED_MODULE_0__.BackgroundImageSize.Tile,
          label: 'Tile'
        }]
      },
      defaultValue: app_features_canvas__WEBPACK_IMPORTED_MODULE_0__.BackgroundImageSize.Cover
    });
  },
  addBorder: (builder, context) => {
    var _context$options, _context$options$bord;

    const category = ['Border'];
    builder.addSliderInput({
      category,
      path: 'border.width',
      name: 'Width',
      defaultValue: 2,
      settings: {
        min: 0,
        max: 20
      }
    });

    if ((_context$options = context.options) !== null && _context$options !== void 0 && (_context$options$bord = _context$options.border) !== null && _context$options$bord !== void 0 && _context$options$bord.width) {
      builder.addCustomEditor({
        category,
        id: 'border.color',
        path: 'border.color',
        name: 'Color',
        editor: app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_1__.ColorDimensionEditor,
        settings: {},
        defaultValue: {
          // Configured values
          fixed: ''
        }
      });
    }
  }
};

/***/ }),

/***/ "./public/app/plugins/panel/canvas/module.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "plugin": () => (/* binding */ plugin)
/* harmony export */ });
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var app_features_canvas_runtime_frame__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/features/canvas/runtime/frame.tsx");
/* harmony import */ var _CanvasPanel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/panel/canvas/CanvasPanel.tsx");
/* harmony import */ var _editor_elementEditor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/panel/canvas/editor/elementEditor.tsx");
/* harmony import */ var _editor_layerEditor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/panel/canvas/editor/layerEditor.tsx");





const plugin = new _grafana_data__WEBPACK_IMPORTED_MODULE_0__.PanelPlugin(_CanvasPanel__WEBPACK_IMPORTED_MODULE_2__.CanvasPanel).setNoPadding() // extend to panel edges
.useFieldConfig().setPanelOptions((builder, context) => {
  const state = context.instanceState;
  builder.addBooleanSwitch({
    path: 'inlineEditing',
    name: 'Inline editing',
    description: 'Enable editing the panel directly',
    defaultValue: true
  });

  if (state) {
    builder.addNestedOptions((0,_editor_layerEditor__WEBPACK_IMPORTED_MODULE_4__.getLayerEditor)(state));
    const selection = state.selected;

    if ((selection === null || selection === void 0 ? void 0 : selection.length) === 1) {
      const element = selection[0];

      if (!(element instanceof app_features_canvas_runtime_frame__WEBPACK_IMPORTED_MODULE_1__.FrameState)) {
        builder.addNestedOptions((0,_editor_elementEditor__WEBPACK_IMPORTED_MODULE_3__.getElementEditor)({
          category: [`Selected element (${element.options.name})`],
          element,
          scene: state.scene
        }));
      }
    }
  }
});

/***/ }),

/***/ "./public/app/plugins/panel/canvas/types.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LayerActionID": () => (/* binding */ LayerActionID)
/* harmony export */ });
let LayerActionID;

(function (LayerActionID) {
  LayerActionID["Delete"] = "delete";
  LayerActionID["Duplicate"] = "duplicate";
  LayerActionID["MoveTop"] = "move-top";
  LayerActionID["MoveBottom"] = "move-bottom";
})(LayerActionID || (LayerActionID = {}));

/***/ }),

/***/ "./.yarn/__virtual__/css-styled-virtual-9ef8f05de2/0/cache/css-styled-npm-1.0.0-5104a882d5-3f2f995938.zip/node_modules/css-styled/dist/styled.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@daybrush-utils-npm-1.6.0-547486bf79-2579bc17e0.zip/node_modules/@daybrush/utils/dist/utils.esm.js");
/*
Copyright (c) 2019 Daybrush
name: css-styled
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/css-styled.git
version: 1.0.0
*/


function hash(str) {
  var hash = 5381,
      i    = str.length;

  while(i) {
    hash = (hash * 33) ^ str.charCodeAt(--i);
  }

  /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed
   * integers. Since we want the results to be always positive, convert the
   * signed int to an unsigned by doing an unsigned bitshift. */
  return hash >>> 0;
}

var stringHash = hash;

function getHash(str) {
  return stringHash(str).toString(36);
}
function getShadowRoot(parentElement) {
  if (parentElement && parentElement.getRootNode) {
    var rootNode = parentElement.getRootNode();

    if (rootNode.nodeType === 11) {
      return rootNode;
    }
  }

  return;
}
function replaceStyle(className, css, options) {
  if (options.original) {
    return css;
  }

  return css.replace(/([^};{\s}][^};{]*|^\s*){/mg, function (_, selector) {
    var trimmedSelector = selector.trim();
    return (trimmedSelector ? (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.splitComma)(trimmedSelector) : [""]).map(function (subSelector) {
      var trimmedSubSelector = subSelector.trim();

      if (trimmedSubSelector.indexOf("@") === 0) {
        return trimmedSubSelector;
      } else if (trimmedSubSelector.indexOf(":global") > -1) {
        return trimmedSubSelector.replace(/\:global/g, "");
      } else if (trimmedSubSelector.indexOf(":host") > -1) {
        return "" + trimmedSubSelector.replace(/\:host/g, "." + className);
      } else if (trimmedSubSelector) {
        return "." + className + " " + trimmedSubSelector;
      } else {
        return "." + className;
      }
    }).join(", ") + " {";
  });
}
function injectStyle(className, css, options, shadowRoot) {
  var style = document.createElement("style");
  style.setAttribute("type", "text/css");
  style.setAttribute("data-styled-id", className);

  if (options.nonce) {
    style.setAttribute("nonce", options.nonce);
  }

  style.innerHTML = replaceStyle(className, css, options);
  (shadowRoot || document.head || document.body).appendChild(style);
  return style;
}

/**
 * Create an styled object that can be defined and inserted into the css.
 * @param - css styles
 */

function styled(css) {
  var injectClassName = "rCS" + getHash(css);
  var injectCount = 0;
  var injectElement;
  return {
    className: injectClassName,
    inject: function (el, options) {
      if (options === void 0) {
        options = {};
      }

      var shadowRoot = getShadowRoot(el);
      var firstMount = injectCount === 0;
      var styleElement;

      if (shadowRoot || firstMount) {
        styleElement = injectStyle(injectClassName, css, options, shadowRoot);
      }

      if (firstMount) {
        injectElement = styleElement;
      }

      if (!shadowRoot) {
        ++injectCount;
      }

      return {
        destroy: function () {
          if (shadowRoot) {
            el.removeChild(styleElement);
            styleElement = null;
          } else {
            if (injectCount > 0) {
              --injectCount;
            }

            if (injectCount === 0 && injectElement) {
              injectElement.parentNode.removeChild(injectElement);
              injectElement = null;
            }
          }
        }
      };
    }
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (styled);
//# sourceMappingURL=styled.esm.js.map


/***/ }),

/***/ "./.yarn/__virtual__/react-compat-moveable-virtual-81b7a42abb/0/cache/react-compat-moveable-npm-0.16.0-395b3c92e9-b20bd91698.zip/node_modules/react-compat-moveable/dist/moveable.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Clippable": () => (/* binding */ Clippable),
/* harmony export */   "Draggable": () => (/* binding */ Draggable),
/* harmony export */   "EdgeDraggable": () => (/* binding */ edgeDraggable),
/* harmony export */   "InitialMoveable": () => (/* binding */ InitialMoveable),
/* harmony export */   "MOVEABLE_ABLES": () => (/* binding */ MOVEABLE_ABLES),
/* harmony export */   "MOVEABLE_EVENTS": () => (/* binding */ MOVEABLE_EVENTS),
/* harmony export */   "MOVEABLE_EVENTS_MAP": () => (/* binding */ MOVEABLE_EVENTS_MAP),
/* harmony export */   "MOVEABLE_EVENTS_PROPS_MAP": () => (/* binding */ MOVEABLE_EVENTS_PROPS_MAP),
/* harmony export */   "MOVEABLE_METHODS": () => (/* binding */ MOVEABLE_METHODS),
/* harmony export */   "MOVEABLE_PROPS": () => (/* binding */ MOVEABLE_PROPS),
/* harmony export */   "MOVEABLE_PROPS_MAP": () => (/* binding */ MOVEABLE_PROPS_MAP),
/* harmony export */   "Pinchable": () => (/* binding */ Pinchable),
/* harmony export */   "Resizable": () => (/* binding */ Resizable),
/* harmony export */   "Rotatable": () => (/* binding */ Rotatable),
/* harmony export */   "Roundable": () => (/* binding */ Roundable),
/* harmony export */   "Scalable": () => (/* binding */ Scalable),
/* harmony export */   "Snappable": () => (/* binding */ Snappable),
/* harmony export */   "Warpable": () => (/* binding */ Warpable),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "getElementInfo": () => (/* binding */ getElementInfo),
/* harmony export */   "makeAble": () => (/* binding */ makeAble),
/* harmony export */   "makeMoveable": () => (/* binding */ makeMoveable)
/* harmony export */ });
/* harmony import */ var _egjs_agent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@egjs-agent-npm-2.3.0-e88ca0eec2-2506e8feff.zip/node_modules/@egjs/agent/dist/agent.esm.js");
/* harmony import */ var framework_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/framework-utils-npm-1.1.0-37a54a069c-01b61ead17.zip/node_modules/framework-utils/dist/utils.esm.js");
/* harmony import */ var _daybrush_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/@daybrush-utils-npm-1.6.0-547486bf79-2579bc17e0.zip/node_modules/@daybrush/utils/dist/utils.esm.js");
/* harmony import */ var _scena_matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/@scena-matrix-npm-1.1.1-da964f6b3a-e96aeab712.zip/node_modules/@scena/matrix/dist/matrix.esm.js");
/* harmony import */ var css_to_mat__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/css-to-mat-npm-1.0.3-8a69ed71de-a3fc98bfad.zip/node_modules/css-to-mat/dist/css-to-mat.esm.js");
/* harmony import */ var _egjs_children_differ__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/@egjs-children-differ-npm-1.0.1-37f45ddf97-087f286822.zip/node_modules/@egjs/children-differ/dist/children-differ.esm.js");
/* harmony import */ var overlap_area__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/overlap-area-npm-1.0.0-ece5a4fc6a-37d82ea4ea.zip/node_modules/overlap-area/dist/overlap-area.esm.js");
/* harmony import */ var _scena_dragscroll__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/cache/@scena-dragscroll-npm-1.1.1-8fe60775f9-aacb335870.zip/node_modules/@scena/dragscroll/dist/dragscroll.esm.js");
/* harmony import */ var react_simple_compat__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./.yarn/cache/react-simple-compat-npm-1.2.1-d35db08ba4-07a47e750f.zip/node_modules/react-simple-compat/dist/compat.esm.js");
/* harmony import */ var gesto__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./.yarn/cache/gesto-npm-1.7.0-7d5440000b-f2a66bcf0f.zip/node_modules/gesto/dist/gesto.esm.js");
/* harmony import */ var react_compat_css_styled__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./.yarn/cache/react-compat-css-styled-npm-1.0.8-52211d26f8-7a8e51849e.zip/node_modules/react-compat-css-styled/dist/styled.esm.js");
/*
Copyright (c) 2019 Daybrush
name: react-compat-moveable
license: MIT
author: Daybrush
repository: https://github.com/daybrush/moveable/blob/master/packages/react-compat-moveable
version: 0.16.0
*/












/*
Copyright (c) 2019 Daybrush
name: react-moveable
license: MIT
author: Daybrush
repository: https://github.com/daybrush/moveable/blob/master/packages/react-moveable
version: 0.31.0
*/

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

function makeAble(name, able) {
  var _a;

  return __assign({
    events: {},
    props: (_a = {}, _a[name] = Boolean, _a),
    name: name
  }, able);
}

function getSVGCursor(scale, degree) {
  return "data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"" + 32 * scale + "px\" height=\"" + 32 * scale + "px\" viewBox=\"0 0 32 32\" ><path d=\"M 16,5 L 12,10 L 14.5,10 L 14.5,22 L 12,22 L 16,27 L 20,22 L 17.5,22 L 17.5,10 L 20, 10 L 16,5 Z\" stroke-linejoin=\"round\" stroke-width=\"1.2\" fill=\"black\" stroke=\"white\" style=\"transform:rotate(" + degree + "deg);transform-origin: 16px 16px\"></path></svg>";
}

function getCursorCSS(degree) {
  var x1 = getSVGCursor(1, degree); // const x2 = getSVGCursor(2, degree);

  var degree45 = Math.round(degree / 45) * 45 % 180;
  var defaultCursor = "ns-resize";

  if (degree45 === 135) {
    defaultCursor = "nwse-resize";
  } else if (degree45 === 45) {
    defaultCursor = "nesw-resize";
  } else if (degree45 === 90) {
    defaultCursor = "ew-resize";
  } // tslint:disable-next-line: max-line-length


  return "cursor:" + defaultCursor + ";cursor: url('" + x1 + "') 16 16, " + defaultCursor + ";";
}

var agent = (0,_egjs_agent__WEBPACK_IMPORTED_MODULE_0__["default"])();
var IS_WEBKIT = agent.browser.webkit;
var IS_WEBKIT605 = IS_WEBKIT && function () {
  var navi = typeof window === "undefined" ? {
    userAgent: ""
  } : window.navigator;
  var res = /applewebkit\/([^\s]+)/g.exec(navi.userAgent.toLowerCase());
  return res ? parseFloat(res[1]) < 605 : false;
}();
var PREFIX = "moveable-";
var MOVEABLE_CSS = "\n{\n\tposition: absolute;\n\twidth: 1px;\n\theight: 1px;\n\tleft: 0;\n\ttop: 0;\n    z-index: 3000;\n    --moveable-color: #4af;\n    --zoom: 1;\n    --zoompx: 1px;\n    will-change: transform;\n}\n.control-box {\n    z-index: 0;\n}\n.line, .control {\n    position: absolute;\n\tleft: 0;\n    top: 0;\n    will-change: transform;\n}\n.control {\n\twidth: 14px;\n\theight: 14px;\n\tborder-radius: 50%;\n\tborder: 2px solid #fff;\n\tbox-sizing: border-box;\n    background: #4af;\n    background: var(--moveable-color);\n\tmargin-top: -7px;\n    margin-left: -7px;\n    border: 2px solid #fff;\n    z-index: 10;\n}\n.padding {\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    width: 100px;\n    height: 100px;\n    transform-origin: 0 0;\n}\n.line {\n\twidth: 1px;\n    height: 1px;\n    background: #4af;\n    background: var(--moveable-color);\n\ttransform-origin: 0px 50%;\n}\n.line.dashed {\n    box-sizing: border-box;\n    background: transparent;\n}\n.line.dashed.horizontal {\n    border-top: 1px dashed #4af;\n    border-top-color: #4af;\n    border-top-color: var(--moveable-color);\n}\n.line.dashed.vertical {\n    border-left: 1px dashed #4af;\n    border-left-color: #4af;\n    border-left-color: var(--moveable-color);\n}\n.line.vertical {\n    transform: translateX(-50%);\n}\n.line.horizontal {\n    transform: translateY(-50%);\n}\n.line.vertical.bold {\n    width: 2px;\n}\n.line.horizontal.bold {\n    height: 2px;\n}\n\n.control.origin {\n\tborder-color: #f55;\n\tbackground: #fff;\n\twidth: 12px;\n\theight: 12px;\n\tmargin-top: -6px;\n    margin-left: -6px;\n\tpointer-events: none;\n}\n" + [0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165].map(function (degree) {
  return "\n.direction[data-rotation=\"" + degree + "\"] {\n\t" + getCursorCSS(degree) + "\n}\n";
}).join("\n") + "\n.group {\n    z-index: -1;\n}\n.area {\n    position: absolute;\n}\n.area-pieces {\n    position: absolute;\n    top: 0;\n    left: 0;\n    display: none;\n}\n.area.avoid, .area.pass {\n    pointer-events: none;\n}\n.area.avoid+.area-pieces {\n    display: block;\n}\n.area-piece {\n    position: absolute;\n}\n\n" + (IS_WEBKIT605 ? ":global svg *:before {\n\tcontent:\"\";\n\ttransform-origin: inherit;\n}" : "") + "\n";
var NEARBY_POS = [[0, 1, 2], [1, 0, 3], [2, 0, 3], [3, 1, 2]];
var FLOAT_POINT_NUM = 0.0001;
var TINY_NUM = 0.0000001;
var MIN_SCALE = 0.000000001;
var MAX_NUM = Math.pow(10, 10);
var MIN_NUM = -MAX_NUM;
var DIRECTIONS = ["n", "w", "s", "e", "nw", "ne", "sw", "se"];
var DIRECTION_INDEXES = {
  n: [0, 1],
  s: [2, 3],
  w: [2, 0],
  e: [1, 3],
  nw: [0],
  ne: [1],
  sw: [2],
  se: [3]
};
var DIRECTION_ROTATIONS = {
  n: 0,
  s: 180,
  w: 270,
  e: 90,
  nw: 315,
  ne: 45,
  sw: 225,
  se: 135
};
var MOVEABLE_METHODS = ["isMoveableElement", "updateRect", "updateTarget", "destroy", "dragStart", "isInside", "hitTest", "setState", "getRect", "request", "isDragging", "getManager", "forceUpdate"];

function multiply2(pos1, pos2) {
  return [pos1[0] * pos2[0], pos1[1] * pos2[1]];
}
function prefix() {
  var classNames = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    classNames[_i] = arguments[_i];
  }

  return framework_utils__WEBPACK_IMPORTED_MODULE_1__.prefixNames.apply(void 0, __spreadArray([PREFIX], classNames));
}
function getTransformMatrix(transform) {
  if (!transform || transform === "none") {
    return [1, 0, 0, 1, 0, 0];
  }

  if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.isObject)(transform)) {
    return transform;
  }

  var value = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.splitBracket)(transform).value;
  return value.split(/s*,\s*/g).map(function (v) {
    return parseFloat(v);
  });
}
function getAbsoluteMatrix(matrix, n, origin) {
  return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.multiplies)(n, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createOriginMatrix)(origin, n), matrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createOriginMatrix)(origin.map(function (a) {
    return -a;
  }), n));
}
function measureSVGSize(el, unit, isHorizontal) {
  if (unit === "%") {
    var viewBox = getSVGViewBox(el.ownerSVGElement);
    return viewBox[isHorizontal ? "width" : "height"] / 100;
  }

  return 1;
}
function getBeforeTransformOrigin(el) {
  var relativeOrigin = getTransformOrigin(getComputedStyle(el, ":before"));
  return relativeOrigin.map(function (o, i) {
    var _a = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.splitUnit)(o),
        value = _a.value,
        unit = _a.unit;

    return value * measureSVGSize(el, unit, i === 0);
  });
}
function getTransformOrigin(style) {
  var transformOrigin = style.transformOrigin;
  return transformOrigin ? transformOrigin.split(" ") : ["0", "0"];
}
function getOffsetInfo(el, lastParent, isParent) {
  var body = document.body;
  var target = !el || isParent ? el : el.parentElement;
  var isEnd = el === lastParent || target === lastParent;
  var position = "relative";

  while (target && target !== body) {
    if (lastParent === target) {
      isEnd = true;
    }

    var style = getComputedStyle(target);
    var transform = style.transform;
    position = style.position;

    if (target.tagName.toLowerCase() === "svg" || position !== "static" || transform && transform !== "none") {
      break;
    }

    target = target.parentElement;
    position = "relative";
  }

  return {
    isStatic: position === "static",
    isEnd: isEnd || !target || target === body,
    offsetParent: target || body
  };
}
function getOffsetPosInfo(el, container, style, isFixed) {
  var _a;

  var tagName = el.tagName.toLowerCase();
  var offsetLeft = el.offsetLeft;
  var offsetTop = el.offsetTop;

  if (isFixed) {
    var containerClientRect = (container || document.documentElement).getBoundingClientRect();
    offsetLeft -= containerClientRect.left;
    offsetTop -= containerClientRect.top;
  } // svg


  var isSVG = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(offsetLeft);
  var hasOffset = !isSVG;
  var origin;
  var targetOrigin; // inner svg element

  if (!hasOffset && tagName !== "svg") {
    origin = IS_WEBKIT605 ? getBeforeTransformOrigin(el) : getTransformOrigin(style).map(function (pos) {
      return parseFloat(pos);
    });
    targetOrigin = origin.slice();
    hasOffset = true;
    _a = getSVGGraphicsOffset(el, origin), offsetLeft = _a[0], offsetTop = _a[1], origin[0] = _a[2], origin[1] = _a[3];
  } else {
    origin = getTransformOrigin(style).map(function (pos) {
      return parseFloat(pos);
    });
    targetOrigin = origin.slice();
  }

  return {
    tagName: tagName,
    isSVG: isSVG,
    hasOffset: hasOffset,
    offset: [offsetLeft || 0, offsetTop || 0],
    origin: origin,
    targetOrigin: targetOrigin
  };
}
function getBodyOffset(el, isSVG, style) {
  if (style === void 0) {
    style = getComputedStyle(el);
  }

  var bodyStyle = getComputedStyle(document.body);
  var bodyPosition = bodyStyle.position;

  if (!isSVG && (!bodyPosition || bodyPosition === "static")) {
    return [0, 0];
  }

  var marginLeft = parseInt(bodyStyle.marginLeft, 10);
  var marginTop = parseInt(bodyStyle.marginTop, 10);

  if (style.position === "absolute") {
    if (style.top !== "auto" || style.bottom !== "auto") {
      marginTop = 0;
    }

    if (style.left !== "auto" || style.right !== "auto") {
      marginLeft = 0;
    }
  }

  return [marginLeft, marginTop];
}
function convert3DMatrixes(matrixes) {
  matrixes.forEach(function (info) {
    var matrix = info.matrix;

    if (matrix) {
      info.matrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.convertDimension)(matrix, 3, 4);
    }
  });
}
function getMatrixStackInfo(target, container, checkContainer) {
  var el = target;
  var matrixes = [];
  var requestEnd = !checkContainer && target === container;
  var isEnd = requestEnd;
  var is3d = false;
  var n = 3;
  var transformOrigin;
  var targetTransformOrigin;
  var targetMatrix;
  var offsetContainer = getOffsetInfo(container, container, true).offsetParent;

  while (el && !isEnd) {
    isEnd = requestEnd;
    var style = getComputedStyle(el);
    var position = style.position;
    var isFixed = position === "fixed";
    var matrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.convertCSStoMatrix)(getTransformMatrix(style.transform)); // convert 3 to 4

    var length = matrix.length;

    if (!is3d && length === 16) {
      is3d = true;
      n = 4;
      convert3DMatrixes(matrixes);

      if (targetMatrix) {
        targetMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.convertDimension)(targetMatrix, 3, 4);
      }
    }

    if (is3d && length === 9) {
      matrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.convertDimension)(matrix, 3, 4);
    }

    var _a = getOffsetPosInfo(el, container, style, isFixed),
        tagName = _a.tagName,
        hasOffset = _a.hasOffset,
        isSVG = _a.isSVG,
        origin = _a.origin,
        targetOrigin = _a.targetOrigin,
        offsetPos = _a.offset;

    var offsetLeft = offsetPos[0],
        offsetTop = offsetPos[1];

    if (tagName === "svg" && targetMatrix) {
      // scale matrix for svg's SVGElements.
      matrixes.push({
        type: "target",
        target: el,
        matrix: getSVGMatrix(el, n)
      });
      matrixes.push({
        type: "offset",
        target: el,
        matrix: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createIdentityMatrix)(n)
      });
    } else if (tagName === "g" && target !== el) {
      offsetLeft = 0;
      offsetTop = 0;
    }

    var _b = getOffsetInfo(el, container),
        offsetParent = _b.offsetParent,
        isOffsetEnd = _b.isEnd,
        isStatic = _b.isStatic;

    if (IS_WEBKIT && hasOffset && !isSVG && isStatic && (position === "relative" || position === "static")) {
      offsetLeft -= offsetParent.offsetLeft;
      offsetTop -= offsetParent.offsetTop;
      requestEnd = requestEnd || isOffsetEnd;
    }

    var parentClientLeft = 0;
    var parentClientTop = 0;

    if (hasOffset && offsetContainer !== offsetParent) {
      // border
      parentClientLeft = offsetParent.clientLeft;
      parentClientTop = offsetParent.clientTop;
    }

    if (hasOffset && offsetParent === document.body) {
      var margin = getBodyOffset(el, false, style);
      offsetLeft += margin[0];
      offsetTop += margin[1];
    }

    matrixes.push({
      type: "target",
      target: el,
      matrix: getAbsoluteMatrix(matrix, n, origin)
    });

    if (hasOffset) {
      matrixes.push({
        type: "offset",
        target: el,
        matrix: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createOriginMatrix)([offsetLeft - el.scrollLeft + parentClientLeft, offsetTop - el.scrollTop + parentClientTop], n)
      });
    } else {
      // svg
      matrixes.push({
        type: "offset",
        target: el,
        origin: origin
      });
    }

    if (!targetMatrix) {
      targetMatrix = matrix;
    }

    if (!transformOrigin) {
      transformOrigin = origin;
    }

    if (!targetTransformOrigin) {
      targetTransformOrigin = targetOrigin;
    }

    if (isEnd || isFixed) {
      break;
    } else {
      el = offsetParent;
      requestEnd = isOffsetEnd;
    }

    if (!checkContainer || el === document.body) {
      isEnd = requestEnd;
    }
  }

  if (!targetMatrix) {
    targetMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createIdentityMatrix)(n);
  }

  if (!transformOrigin) {
    transformOrigin = [0, 0];
  }

  if (!targetTransformOrigin) {
    targetTransformOrigin = [0, 0];
  }

  return {
    offsetContainer: offsetContainer,
    matrixes: matrixes,
    targetMatrix: targetMatrix,
    transformOrigin: transformOrigin,
    targetOrigin: targetTransformOrigin,
    is3d: is3d
  };
}
function calculateElementInfo(target, container, rootContainer, isAbsolute3d) {
  var _a;

  if (rootContainer === void 0) {
    rootContainer = container;
  }

  var width = 0;
  var height = 0;
  var rotation = 0;
  var allResult = {};

  if (target) {
    var style = getComputedStyle(target);
    width = target.offsetWidth;
    height = target.offsetHeight;

    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(width)) {
      _a = getSize(target, style, true), width = _a[0], height = _a[1];
    }
  }

  if (target) {
    var result = calculateMatrixStack(target, container, rootContainer, isAbsolute3d);
    var position = calculateMoveablePosition(result.allMatrix, result.transformOrigin, width, height);
    allResult = __assign(__assign({}, result), position);
    var rotationPosition = calculateMoveablePosition(result.allMatrix, [50, 50], 100, 100);
    rotation = getRotationRad([rotationPosition.pos1, rotationPosition.pos2], rotationPosition.direction);
  }

  var n = isAbsolute3d ? 4 : 3;
  return __assign({
    width: width,
    height: height,
    rotation: rotation,
    // rootMatrix: number[];
    // beforeMatrix: number[];
    // offsetMatrix: number[];
    // allMatrix: number[];
    // targetMatrix: number[];
    // targetTransform: string;
    // transformOrigin: number[];
    // targetOrigin: number[];
    // is3d: boolean;
    rootMatrix: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createIdentityMatrix)(n),
    beforeMatrix: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createIdentityMatrix)(n),
    offsetMatrix: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createIdentityMatrix)(n),
    allMatrix: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createIdentityMatrix)(n),
    targetMatrix: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createIdentityMatrix)(n),
    targetTransform: "",
    transformOrigin: [0, 0],
    targetOrigin: [0, 0],
    is3d: !!isAbsolute3d,
    // left: number;
    // top: number;
    // right: number;
    // bottom: number;
    // origin: number[];
    // pos1: number[];
    // pos2: number[];
    // pos3: number[];
    // pos4: number[];
    // direction: 1 | -1;
    left: 0,
    top: 0,
    right: 0,
    bottom: 0,
    origin: [0, 0],
    pos1: [0, 0],
    pos2: [0, 0],
    pos3: [0, 0],
    pos4: [0, 0],
    direction: 1
  }, allResult);
}
function getElementInfo(target, container, rootContainer) {
  if (rootContainer === void 0) {
    rootContainer = container;
  }

  return calculateElementInfo(target, container, rootContainer, true);
}
function calculateMatrixStack(target, container, rootContainer, isAbsolute3d) {
  var _a;

  if (rootContainer === void 0) {
    rootContainer = container;
  }

  var _b = getMatrixStackInfo(target, container),
      matrixes = _b.matrixes,
      is3d = _b.is3d,
      prevTargetMatrix = _b.targetMatrix,
      transformOrigin = _b.transformOrigin,
      targetOrigin = _b.targetOrigin,
      offsetContainer = _b.offsetContainer; // prevMatrix


  var _c = getMatrixStackInfo(offsetContainer, rootContainer, true),
      rootMatrixes = _c.matrixes,
      isRoot3d = _c.is3d; // prevRootMatrix
  // if (rootContainer === document.body) {
  //     console.log(offsetContainer, rootContainer, rootMatrixes);
  // }


  var isNext3d = isAbsolute3d || isRoot3d || is3d;
  var n = isNext3d ? 4 : 3;
  var isSVGGraphicElement = target.tagName.toLowerCase() !== "svg" && "ownerSVGElement" in target;
  var targetMatrix = prevTargetMatrix; // let allMatrix = prevMatrix ? convertDimension(prevMatrix, prevN!, n) : createIdentityMatrix(n);
  // let rootMatrix = prevRootMatrix ? convertDimension(prevRootMatrix, prevN!, n) : createIdentityMatrix(n);
  // let beforeMatrix = prevMatrix ? convertDimension(prevMatrix, prevN!, n) : createIdentityMatrix(n);

  var allMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createIdentityMatrix)(n);
  var rootMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createIdentityMatrix)(n);
  var beforeMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createIdentityMatrix)(n);
  var offsetMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createIdentityMatrix)(n);
  var length = matrixes.length;
  rootMatrixes.reverse();
  matrixes.reverse();

  if (!is3d && isNext3d) {
    targetMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.convertDimension)(targetMatrix, 3, 4);
    convert3DMatrixes(matrixes);
  }

  if (!isRoot3d && isNext3d) {
    convert3DMatrixes(rootMatrixes);
  } // rootMatrix = (...) -> container -> offset -> absolute -> offset -> absolute(targetMatrix)
  // rootMatrixBeforeOffset = lastOffsetMatrix -> (...) -> container
  // beforeMatrix = (... -> container -> offset -> absolute) -> offset -> absolute(targetMatrix)
  // offsetMatrix = (... -> container -> offset -> absolute -> offset) -> absolute(targetMatrix)


  rootMatrixes.forEach(function (info) {
    rootMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.multiply)(rootMatrix, info.matrix, n);
  });
  var originalRootContainer = rootContainer || document.body;
  var endContainer = ((_a = rootMatrixes[0]) === null || _a === void 0 ? void 0 : _a.target) || getOffsetInfo(originalRootContainer, originalRootContainer, true).offsetParent;
  var rootMatrixBeforeOffset = rootMatrixes.slice(1).reduce(function (matrix, info) {
    return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.multiply)(matrix, info.matrix, n);
  }, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createIdentityMatrix)(n));
  matrixes.forEach(function (info, i) {
    if (length - 2 === i) {
      // length - 3
      beforeMatrix = allMatrix.slice();
    }

    if (length - 1 === i) {
      // length - 2
      offsetMatrix = allMatrix.slice();
    } // calculate for SVGElement


    if (!info.matrix) {
      var nextInfo = matrixes[i + 1];
      var offset = getSVGOffset(info, nextInfo, endContainer, n, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.multiply)(rootMatrixBeforeOffset, allMatrix, n));
      info.matrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createOriginMatrix)(offset, n);
    }

    allMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.multiply)(allMatrix, info.matrix, n);
  });
  var isMatrix3d = !isSVGGraphicElement && is3d;

  if (!targetMatrix) {
    targetMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createIdentityMatrix)(isMatrix3d ? 4 : 3);
  }

  var targetTransform = makeMatrixCSS(isSVGGraphicElement && targetMatrix.length === 16 ? (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.convertDimension)(targetMatrix, 4, 3) : targetMatrix, isMatrix3d);
  rootMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.ignoreDimension)(rootMatrix, n, n);
  return {
    rootMatrix: rootMatrix,
    beforeMatrix: beforeMatrix,
    offsetMatrix: offsetMatrix,
    allMatrix: allMatrix,
    targetMatrix: targetMatrix,
    targetTransform: targetTransform,
    transformOrigin: transformOrigin,
    targetOrigin: targetOrigin,
    is3d: isNext3d
  };
}
function makeMatrixCSS(matrix, is3d) {
  if (is3d === void 0) {
    is3d = matrix.length > 9;
  }

  return (is3d ? "matrix3d" : "matrix") + "(" + (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.convertMatrixtoCSS)(matrix, !is3d).join(",") + ")";
}
function getSVGViewBox(el) {
  var clientWidth = el.clientWidth;
  var clientHeight = el.clientHeight;

  if (!el) {
    return {
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      clientWidth: clientWidth,
      clientHeight: clientHeight
    };
  }

  var viewBox = el.viewBox;
  var baseVal = viewBox && viewBox.baseVal || {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  };
  return {
    x: baseVal.x,
    y: baseVal.y,
    width: baseVal.width || clientWidth,
    height: baseVal.height || clientHeight,
    clientWidth: clientWidth,
    clientHeight: clientHeight
  };
}
function getSVGMatrix(el, n) {
  var _a = getSVGViewBox(el),
      viewBoxWidth = _a.width,
      viewBoxHeight = _a.height,
      clientWidth = _a.clientWidth,
      clientHeight = _a.clientHeight;

  var scaleX = clientWidth / viewBoxWidth;
  var scaleY = clientHeight / viewBoxHeight;
  var preserveAspectRatio = el.preserveAspectRatio.baseVal; // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/preserveAspectRatio

  var align = preserveAspectRatio.align; // 1 : meet 2: slice

  var meetOrSlice = preserveAspectRatio.meetOrSlice;
  var svgOrigin = [0, 0];
  var scale = [scaleX, scaleY];
  var translate = [0, 0];

  if (align !== 1) {
    var xAlign = (align - 2) % 3;
    var yAlign = Math.floor((align - 2) / 3);
    svgOrigin[0] = viewBoxWidth * xAlign / 2;
    svgOrigin[1] = viewBoxHeight * yAlign / 2;
    var scaleDimension = meetOrSlice === 2 ? Math.max(scaleY, scaleX) : Math.min(scaleX, scaleY);
    scale[0] = scaleDimension;
    scale[1] = scaleDimension;
    translate[0] = (clientWidth - viewBoxWidth) / 2 * xAlign;
    translate[1] = (clientHeight - viewBoxHeight) / 2 * yAlign;
  }

  var scaleMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createScaleMatrix)(scale, n);
  scaleMatrix[n * (n - 1)] = translate[0], scaleMatrix[n * (n - 1) + 1] = translate[1];
  return getAbsoluteMatrix(scaleMatrix, n, svgOrigin);
}
function getSVGGraphicsOffset(el, origin) {
  if (!el.getBBox) {
    return [0, 0];
  }

  var bbox = el.getBBox();
  var viewBox = getSVGViewBox(el.ownerSVGElement);
  var left = bbox.x - viewBox.x;
  var top = bbox.y - viewBox.y;
  return [left, top, origin[0] - left, origin[1] - top];
}
function calculatePosition(matrix, pos, n) {
  return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.calculate)(matrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.convertPositionMatrix)(pos, n), n);
}
function calculatePoses(matrix, width, height, n) {
  return [[0, 0], [width, 0], [0, height], [width, height]].map(function (pos) {
    return calculatePosition(matrix, pos, n);
  });
}
function getRect(poses) {
  var posesX = poses.map(function (pos) {
    return pos[0];
  });
  var posesY = poses.map(function (pos) {
    return pos[1];
  });
  var left = Math.min.apply(Math, posesX);
  var top = Math.min.apply(Math, posesY);
  var right = Math.max.apply(Math, posesX);
  var bottom = Math.max.apply(Math, posesY);
  var rectWidth = right - left;
  var rectHeight = bottom - top;
  return {
    left: left,
    top: top,
    right: right,
    bottom: bottom,
    width: rectWidth,
    height: rectHeight
  };
}
function calculateRect(matrix, width, height, n) {
  var poses = calculatePoses(matrix, width, height, n);
  return getRect(poses);
}
function getSVGOffset(offsetInfo, targetInfo, container, n, beforeMatrix) {
  var _a;

  var target = offsetInfo.target;
  var origin = offsetInfo.origin;
  var targetMatrix = targetInfo.matrix;

  var _b = getSize(target, undefined, true),
      width = _b[0],
      height = _b[1];

  var containerClientRect = container.getBoundingClientRect();
  var margin = [0, 0];

  if (container === document.body) {
    margin = getBodyOffset(target, true);
  }

  var rect = target.getBoundingClientRect();
  var rectLeft = rect.left - containerClientRect.left + container.scrollLeft - (container.clientLeft || 0) + margin[0];
  var rectTop = rect.top - containerClientRect.top + container.scrollTop - (container.clientTop || 0) + margin[1];
  var rectWidth = rect.width;
  var rectHeight = rect.height;
  var mat = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.multiplies)(n, beforeMatrix, targetMatrix);

  var _c = calculateRect(mat, width, height, n),
      prevLeft = _c.left,
      prevTop = _c.top,
      prevWidth = _c.width,
      prevHeight = _c.height;

  var posOrigin = calculatePosition(mat, origin, n);
  var prevOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(posOrigin, [prevLeft, prevTop]);
  var rectOrigin = [rectLeft + prevOrigin[0] * rectWidth / prevWidth, rectTop + prevOrigin[1] * rectHeight / prevHeight];
  var offset = [0, 0];
  var count = 0;

  while (++count < 10) {
    var inverseBeforeMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.invert)(beforeMatrix, n);
    _a = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(calculatePosition(inverseBeforeMatrix, rectOrigin, n), calculatePosition(inverseBeforeMatrix, posOrigin, n)), offset[0] = _a[0], offset[1] = _a[1];
    var mat2 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.multiplies)(n, beforeMatrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createOriginMatrix)(offset, n), targetMatrix);

    var _d = calculateRect(mat2, width, height, n),
        nextLeft = _d.left,
        nextTop = _d.top;

    var distLeft = nextLeft - rectLeft;
    var distTop = nextTop - rectTop;

    if (Math.abs(distLeft) < 2 && Math.abs(distTop) < 2) {
      break;
    }

    rectOrigin[0] -= distLeft;
    rectOrigin[1] -= distTop;
  }

  return offset.map(function (p) {
    return Math.round(p);
  });
}
function calculateMoveablePosition(matrix, origin, width, height) {
  var is3d = matrix.length === 16;
  var n = is3d ? 4 : 3;
  var poses = calculatePoses(matrix, width, height, n);
  var _a = poses[0],
      x1 = _a[0],
      y1 = _a[1],
      _b = poses[1],
      x2 = _b[0],
      y2 = _b[1],
      _c = poses[2],
      x3 = _c[0],
      y3 = _c[1],
      _d = poses[3],
      x4 = _d[0],
      y4 = _d[1];

  var _e = calculatePosition(matrix, origin, n),
      originX = _e[0],
      originY = _e[1];

  var left = Math.min(x1, x2, x3, x4);
  var top = Math.min(y1, y2, y3, y4);
  var right = Math.max(x1, x2, x3, x4);
  var bottom = Math.max(y1, y2, y3, y4);
  x1 = x1 - left || 0;
  x2 = x2 - left || 0;
  x3 = x3 - left || 0;
  x4 = x4 - left || 0;
  y1 = y1 - top || 0;
  y2 = y2 - top || 0;
  y3 = y3 - top || 0;
  y4 = y4 - top || 0;
  originX = originX - left || 0;
  originY = originY - top || 0;
  var direction = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getShapeDirection)(poses);
  return {
    left: left,
    top: top,
    right: right,
    bottom: bottom,
    origin: [originX, originY],
    pos1: [x1, y1],
    pos2: [x2, y2],
    pos3: [x3, y3],
    pos4: [x4, y4],
    direction: direction
  };
}
function getDistSize(vec) {
  return Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1]);
}
function getDiagonalSize(pos1, pos2) {
  return getDistSize([pos2[0] - pos1[0], pos2[1] - pos1[1]]);
}
function getLineStyle(pos1, pos2, zoom, rad) {
  if (zoom === void 0) {
    zoom = 1;
  }

  if (rad === void 0) {
    rad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)(pos1, pos2);
  }

  var width = getDiagonalSize(pos1, pos2);
  return {
    transform: "translateY(-50%) translate(" + pos1[0] + "px, " + pos1[1] + "px) rotate(" + rad + "rad) scaleY(" + zoom + ")",
    width: width + "px"
  };
}
function getControlTransform(rotation, zoom) {
  var poses = [];

  for (var _i = 2; _i < arguments.length; _i++) {
    poses[_i - 2] = arguments[_i];
  }

  var length = poses.length;
  var x = poses.reduce(function (prev, pos) {
    return prev + pos[0];
  }, 0) / length;
  var y = poses.reduce(function (prev, pos) {
    return prev + pos[1];
  }, 0) / length;
  return {
    transform: "translateZ(0px) translate(" + x + "px, " + y + "px) rotate(" + rotation + "rad) scale(" + zoom + ")"
  };
}
function getCSSSize(target) {
  var style = getComputedStyle(target);
  return [parseFloat(style.width), parseFloat(style.height)];
}
function getSize(target, style, isOffset, isBoxSizing) {
  if (style === void 0) {
    style = getComputedStyle(target);
  }

  if (isBoxSizing === void 0) {
    isBoxSizing = isOffset || style.boxSizing === "border-box";
  }

  var width = target.offsetWidth;
  var height = target.offsetHeight;
  var hasOffset = !(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(width);

  if ((isOffset || isBoxSizing) && hasOffset) {
    return [width, height];
  }

  if (!hasOffset && target.tagName.toLowerCase() !== "svg") {
    var bbox = target.getBBox();
    return [bbox.width, bbox.height];
  }

  width = target.clientWidth;
  height = target.clientHeight;

  if (isOffset || isBoxSizing) {
    var borderLeft = parseFloat(style.borderLeftWidth) || 0;
    var borderRight = parseFloat(style.borderRightWidth) || 0;
    var borderTop = parseFloat(style.borderTopWidth) || 0;
    var borderBottom = parseFloat(style.borderBottomWidth) || 0;
    return [width + borderLeft + borderRight, height + borderTop + borderBottom];
  } else {
    var paddingLeft = parseFloat(style.paddingLeft) || 0;
    var paddingRight = parseFloat(style.paddingRight) || 0;
    var paddingTop = parseFloat(style.paddingTop) || 0;
    var paddingBottom = parseFloat(style.paddingBottom) || 0;
    return [width - paddingLeft - paddingRight, height - paddingTop - paddingBottom];
  }
}
function getRotationRad(poses, direction) {
  return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)(direction > 0 ? poses[0] : poses[1], direction > 0 ? poses[1] : poses[0]);
}
function getTargetInfo(moveableElement, target, container, parentContainer, rootContainer) {
  var beforeDirection = 1;
  var beforeOrigin = [0, 0];
  var targetClientRect = resetClientRect();
  var containerClientRect = resetClientRect();
  var moveableClientRect = resetClientRect();
  var result = calculateElementInfo(target, container, rootContainer, false);

  if (target) {
    var n = result.is3d ? 4 : 3;
    var beforePosition = calculateMoveablePosition(result.offsetMatrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(result.transformOrigin, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.getOrigin)(result.targetMatrix, n)), result.width, result.height);
    beforeDirection = beforePosition.direction;
    beforeOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(beforePosition.origin, [beforePosition.left - result.left, beforePosition.top - result.top]);
    targetClientRect = getClientRect(target);
    containerClientRect = getClientRect(getOffsetInfo(parentContainer, parentContainer, true).offsetParent || document.body, true);

    if (moveableElement) {
      moveableClientRect = getClientRect(moveableElement);
    }
  }

  return __assign({
    targetClientRect: targetClientRect,
    containerClientRect: containerClientRect,
    moveableClientRect: moveableClientRect,
    beforeDirection: beforeDirection,
    beforeOrigin: beforeOrigin,
    originalBeforeOrigin: beforeOrigin,
    target: target
  }, result);
}
function resetClientRect() {
  return {
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
    width: 0,
    height: 0,
    clientLeft: 0,
    clientTop: 0,
    clientWidth: 0,
    clientHeight: 0,
    scrollWidth: 0,
    scrollHeight: 0
  };
}
function getClientRect(el, isExtends) {
  var left = 0;
  var top = 0;
  var width = 0;
  var height = 0;

  if (el === document.body || el === document.documentElement) {
    width = window.innerWidth;
    height = window.innerHeight;
    left = -(document.documentElement.scrollLeft || document.body.scrollLeft);
    top = -(document.documentElement.scrollTop || document.body.scrollTop);
  } else {
    var clientRect = el.getBoundingClientRect();
    left = clientRect.left;
    top = clientRect.top;
    width = clientRect.width;
    height = clientRect.height;
  }

  var rect = {
    left: left,
    right: left + width,
    top: top,
    bottom: top + height,
    width: width,
    height: height
  };

  if (isExtends) {
    rect.clientLeft = el.clientLeft;
    rect.clientTop = el.clientTop;
    rect.clientWidth = el.clientWidth;
    rect.clientHeight = el.clientHeight;
    rect.scrollWidth = el.scrollWidth;
    rect.scrollHeight = el.scrollHeight;
    rect.overflow = getComputedStyle(el).overflow !== "visible";
  }

  return rect;
}
function getDirection(target) {
  if (!target) {
    return;
  }

  var direciton = target.getAttribute("data-direction");

  if (!direciton) {
    return;
  }

  var dir = [0, 0];
  direciton.indexOf("w") > -1 && (dir[0] = -1);
  direciton.indexOf("e") > -1 && (dir[0] = 1);
  direciton.indexOf("n") > -1 && (dir[1] = -1);
  direciton.indexOf("s") > -1 && (dir[1] = 1);
  return dir;
}
function getAbsolutePoses(poses, dist) {
  return [(0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(dist, poses[0]), (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(dist, poses[1]), (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(dist, poses[2]), (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(dist, poses[3])];
}
function getAbsolutePosesByState(_a) {
  var left = _a.left,
      top = _a.top,
      pos1 = _a.pos1,
      pos2 = _a.pos2,
      pos3 = _a.pos3,
      pos4 = _a.pos4;
  return getAbsolutePoses([pos1, pos2, pos3, pos4], [left, top]);
}
function roundSign(num) {
  return Math.round(num % 1 === -0.5 ? num - 1 : num);
}
function unset(self, name) {
  var _a;

  (_a = self[name]) === null || _a === void 0 ? void 0 : _a.unset();
  self[name] = null;
}
function fillParams(moveable, e, params) {
  var datas = e.datas;

  if (!datas.datas) {
    datas.datas = {};
  }

  var nextParams = __assign(__assign({}, params), {
    target: moveable.state.target,
    clientX: e.clientX,
    clientY: e.clientY,
    inputEvent: e.inputEvent,
    currentTarget: moveable,
    moveable: moveable,
    datas: datas.datas
  });

  if (datas.isStartEvent) {
    datas.lastEvent = nextParams;
  } else {
    datas.isStartEvent = true;
  }

  return nextParams;
}
function fillEndParams(moveable, e, params) {
  var datas = e.datas;
  var isDrag = "isDrag" in params ? params.isDrag : e.isDrag;

  if (!datas.datas) {
    datas.datas = {};
  }

  return __assign(__assign({
    isDrag: isDrag
  }, params), {
    moveable: moveable,
    target: moveable.state.target,
    clientX: e.clientX,
    clientY: e.clientY,
    inputEvent: e.inputEvent,
    currentTarget: moveable,
    lastEvent: datas.lastEvent,
    isDouble: e.isDouble,
    datas: datas.datas
  });
}
function triggerEvent(moveable, name, params, isManager) {
  return moveable.triggerEvent(name, params, isManager);
}
function getComputedStyle(el, pseudoElt) {
  return window.getComputedStyle(el, pseudoElt);
}
function filterAbles(ables, methods, triggerAblesSimultaneously) {
  var enabledAbles = {};
  var ableGroups = {};
  return ables.filter(function (able) {
    var name = able.name;

    if (enabledAbles[name] || !methods.some(function (method) {
      return able[method];
    })) {
      return false;
    }

    if (!triggerAblesSimultaneously && able.ableGroup) {
      if (ableGroups[able.ableGroup]) {
        return false;
      }

      ableGroups[able.ableGroup] = true;
    }

    enabledAbles[name] = true;
    return true;
  });
}
function equals(a1, a2) {
  return a1 === a2 || a1 == null && a2 == null;
}
function selectValue() {
  var values = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    values[_i] = arguments[_i];
  }

  var length = values.length - 1;

  for (var i = 0; i < length; ++i) {
    var value = values[i];

    if (!(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(value)) {
      return value;
    }
  }

  return values[length];
}
function groupBy(arr, func) {
  var groups = [];
  var groupKeys = [];
  arr.forEach(function (el, index) {
    var groupKey = func(el, index, arr);
    var keyIndex = groupKeys.indexOf(groupKey);
    var group = groups[keyIndex] || [];

    if (keyIndex === -1) {
      groupKeys.push(groupKey);
      groups.push(group);
    }

    group.push(el);
  });
  return groups;
}
function groupByMap(arr, func) {
  var groups = [];
  var groupKeys = {};
  arr.forEach(function (el, index) {
    var groupKey = func(el, index, arr);
    var group = groupKeys[groupKey];

    if (!group) {
      group = [];
      groupKeys[groupKey] = group;
      groups.push(group);
    }

    group.push(el);
  });
  return groups;
}
function flat(arr) {
  return arr.reduce(function (prev, cur) {
    return prev.concat(cur);
  }, []);
}
function maxOffset() {
  var args = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }

  args.sort(function (a, b) {
    return Math.abs(b) - Math.abs(a);
  });
  return args[0];
}
function calculateInversePosition(matrix, pos, n) {
  return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.calculate)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.invert)(matrix, n), (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.convertPositionMatrix)(pos, n), n);
}
function convertDragDist(state, e) {
  var _a;

  var is3d = state.is3d,
      rootMatrix = state.rootMatrix;
  var n = is3d ? 4 : 3;
  _a = calculateInversePosition(rootMatrix, [e.distX, e.distY], n), e.distX = _a[0], e.distY = _a[1];
  return e;
}
function calculatePadding(matrix, pos, transformOrigin, origin, n) {
  return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(calculatePosition(matrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(transformOrigin, pos), n), origin);
}
function convertCSSSize(value, size, isRelative) {
  return isRelative ? value / size * 100 + "%" : value + "px";
}
function moveControlPos(controlPoses, index, dist, isRect) {
  var _a = controlPoses[index],
      direction = _a.direction,
      sub = _a.sub;
  var dists = controlPoses.map(function () {
    return [0, 0];
  });
  var directions = direction ? direction.split("") : [];

  if (isRect && index < 8) {
    var verticalDirection_1 = directions.filter(function (dir) {
      return dir === "w" || dir === "e";
    })[0];
    var horizontalDirection_1 = directions.filter(function (dir) {
      return dir === "n" || dir === "s";
    })[0];
    dists[index] = dist;
    controlPoses.forEach(function (controlPose, i) {
      var controlDir = controlPose.direction;

      if (!controlDir) {
        return;
      }

      if (controlDir.indexOf(verticalDirection_1) > -1) {
        dists[i][0] = dist[0];
      }

      if (controlDir.indexOf(horizontalDirection_1) > -1) {
        dists[i][1] = dist[1];
      }
    });

    if (verticalDirection_1) {
      dists[1][0] = dist[0] / 2;
      dists[5][0] = dist[0] / 2;
    }

    if (horizontalDirection_1) {
      dists[3][1] = dist[1] / 2;
      dists[7][1] = dist[1] / 2;
    }
  } else if (direction && !sub) {
    directions.forEach(function (dir) {
      var isVertical = dir === "n" || dir === "s";
      controlPoses.forEach(function (controlPose, i) {
        var dirDir = controlPose.direction,
            dirHorizontal = controlPose.horizontal,
            dirVertical = controlPose.vertical;

        if (!dirDir || dirDir.indexOf(dir) === -1) {
          return;
        }

        dists[i] = [isVertical || !dirHorizontal ? 0 : dist[0], !isVertical || !dirVertical ? 0 : dist[1]];
      });
    });
  } else {
    dists[index] = dist;
  }

  return dists;
}
function getTinyDist(v) {
  return Math.abs(v) <= TINY_NUM ? 0 : v;
}
function directionCondition(moveable, e) {
  if (e.isRequest) {
    if (e.requestAble === "resizable" || e.requestAble === "scalable") {
      return e.parentDirection;
    } else {
      return false;
    }
  }

  return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.hasClass)(e.inputEvent.target, prefix("direction"));
}
function invertObject(obj) {
  var nextObj = {};

  for (var name in obj) {
    nextObj[obj[name]] = name;
  }

  return nextObj;
}
function getTransform(transforms, index) {
  var beforeFunctionTexts = transforms.slice(0, index < 0 ? undefined : index);
  var beforeFunctionTexts2 = transforms.slice(0, index < 0 ? undefined : index + 1);
  var targetFunctionText = transforms[index] || "";
  var afterFunctionTexts = index < 0 ? [] : transforms.slice(index);
  var afterFunctionTexts2 = index < 0 ? [] : transforms.slice(index + 1);
  var beforeFunctions = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.parse)(beforeFunctionTexts);
  var beforeFunctions2 = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.parse)(beforeFunctionTexts2);
  var targetFunctions = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.parse)([targetFunctionText]);
  var afterFunctions = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.parse)(afterFunctionTexts);
  var afterFunctions2 = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.parse)(afterFunctionTexts2);
  var beforeFunctionMatrix = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.toMat)(beforeFunctions);
  var beforeFunctionMatrix2 = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.toMat)(beforeFunctions2);
  var afterFunctionMatrix = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.toMat)(afterFunctions);
  var afterFunctionMatrix2 = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.toMat)(afterFunctions2);
  var allFunctionMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.multiply)(beforeFunctionMatrix, afterFunctionMatrix, 4);
  return {
    transforms: transforms,
    beforeFunctionMatrix: beforeFunctionMatrix,
    beforeFunctionMatrix2: beforeFunctionMatrix2,
    targetFunctionMatrix: (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.toMat)(targetFunctions),
    afterFunctionMatrix: afterFunctionMatrix,
    afterFunctionMatrix2: afterFunctionMatrix2,
    allFunctionMatrix: allFunctionMatrix,
    beforeFunctions: beforeFunctions,
    beforeFunctions2: beforeFunctions2,
    targetFunction: targetFunctions[0],
    afterFunctions: afterFunctions,
    afterFunctions2: afterFunctions2,
    beforeFunctionTexts: beforeFunctionTexts,
    beforeFunctionTexts2: beforeFunctionTexts2,
    targetFunctionText: targetFunctionText,
    afterFunctionTexts: afterFunctionTexts,
    afterFunctionTexts2: afterFunctionTexts2
  };
}
function isArrayFormat(arr) {
  if (!arr || !(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.isObject)(arr)) {
    return false;
  }

  return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.isArray)(arr) || "length" in arr;
}
function getRefTarget(target, isSelector) {
  if (!target) {
    return null;
  }

  if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.isString)(target)) {
    if (isSelector) {
      return document.querySelector(target);
    }

    return target;
  }

  if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.isFunction)(target)) {
    return target();
  }

  if ("current" in target) {
    return target.current;
  }

  return target;
}
function getRefTargets(targets, isSelector) {
  if (!targets) {
    return [];
  }

  var userTargets = isArrayFormat(targets) ? [].slice.call(targets) : [targets];
  return userTargets.reduce(function (prev, target) {
    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.isString)(target) && isSelector) {
      return __spreadArray(__spreadArray([], prev), [].slice.call(document.querySelectorAll(target)));
    }

    prev.push(getRefTarget(target, isSelector));
    return prev;
  }, []);
}
function getElementTargets(targets, selectorMap) {
  var elementTargets = [];
  targets.forEach(function (target) {
    if (!target) {
      return;
    }

    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.isString)(target)) {
      if (selectorMap[target]) {
        elementTargets.push.apply(elementTargets, selectorMap[target]);
      }

      return;
    }

    elementTargets.push(target);
  });
  return elementTargets;
}
function getAbsoluteRotation(pos1, pos2, direction) {
  var deg = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)(pos1, pos2) / Math.PI * 180;
  deg = direction >= 0 ? deg : 180 - deg;
  deg = deg >= 0 ? deg : 360 + deg;
  return deg;
}
function getDragDistByState(state, dist) {
  var rootMatrix = state.rootMatrix,
      is3d = state.is3d;
  var n = is3d ? 4 : 3;
  var inverseMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.invert)(rootMatrix, n);

  if (!is3d) {
    inverseMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.convertDimension)(inverseMatrix, 3, 4);
  }

  inverseMatrix[12] = 0;
  inverseMatrix[13] = 0;
  inverseMatrix[14] = 0;
  return (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.calculateMatrixDist)(inverseMatrix, dist);
}

/**
 * @namespace Moveable.Pinchable
 * @description Whether or not target can be pinched with draggable, resizable, scalable, rotatable (default: false)
 */

var Pinchable = makeAble("pinchable", {
  events: {
    onPinchStart: "pinchStart",
    onPinch: "pinch",
    onPinchEnd: "pinchEnd",
    onPinchGroupStart: "pinchGroupStart",
    onPinchGroup: "pinchGroup",
    onPinchGroupEnd: "pinchGroupEnd"
  },
  dragStart: function () {
    return true;
  },
  pinchStart: function (moveable, e) {
    var datas = e.datas,
        targets = e.targets,
        angle = e.angle,
        originalDatas = e.originalDatas;
    var _a = moveable.props,
        pinchable = _a.pinchable,
        ables = _a.ables;

    if (!pinchable) {
      return false;
    }

    var eventName = "onPinch" + (targets ? "Group" : "") + "Start";
    var controlEventName = "drag" + (targets ? "Group" : "") + "ControlStart";
    var pinchAbles = (pinchable === true ? moveable.controlAbles : ables.filter(function (able) {
      return pinchable.indexOf(able.name) > -1;
    })).filter(function (able) {
      return able.canPinch && able[controlEventName];
    });
    var params = fillParams(moveable, e, {});

    if (targets) {
      params.targets = targets;
    }

    var result = triggerEvent(moveable, eventName, params);
    datas.isPinch = result !== false;
    datas.ables = pinchAbles;
    var isPinch = datas.isPinch;

    if (!isPinch) {
      return false;
    }

    pinchAbles.forEach(function (able) {
      originalDatas[able.name] = originalDatas[able.name] || {};

      if (!able[controlEventName]) {
        return;
      }

      var ableEvent = __assign(__assign({}, e), {
        datas: originalDatas[able.name],
        parentRotate: angle,
        isPinch: true
      });

      able[controlEventName](moveable, ableEvent);
    });
    moveable.state.snapRenderInfo = {
      request: e.isRequest,
      direction: [0, 0]
    };
    return isPinch;
  },
  pinch: function (moveable, e) {
    var datas = e.datas,
        pinchScale = e.scale,
        distance = e.distance,
        originalDatas = e.originalDatas,
        inputEvent = e.inputEvent,
        targets = e.targets,
        angle = e.angle;

    if (!datas.isPinch) {
      return;
    }

    var parentDistance = distance * (1 - 1 / pinchScale);
    var params = fillParams(moveable, e, {});

    if (targets) {
      params.targets = targets;
    }

    var eventName = "onPinch" + (targets ? "Group" : "");
    triggerEvent(moveable, eventName, params);
    var ables = datas.ables;
    var controlEventName = "drag" + (targets ? "Group" : "") + "Control";
    ables.forEach(function (able) {
      if (!able[controlEventName]) {
        return;
      }

      able[controlEventName](moveable, __assign(__assign({}, e), {
        datas: originalDatas[able.name],
        inputEvent: inputEvent,
        parentDistance: parentDistance,
        parentRotate: angle,
        isPinch: true
      }));
    });
    return params;
  },
  pinchEnd: function (moveable, e) {
    var datas = e.datas,
        isPinch = e.isPinch,
        inputEvent = e.inputEvent,
        targets = e.targets,
        originalDatas = e.originalDatas;

    if (!datas.isPinch) {
      return;
    }

    var eventName = "onPinch" + (targets ? "Group" : "") + "End";
    var params = fillEndParams(moveable, e, {
      isDrag: isPinch
    });

    if (targets) {
      params.targets = targets;
    }

    triggerEvent(moveable, eventName, params);
    var ables = datas.ables;
    var controlEventName = "drag" + (targets ? "Group" : "") + "ControlEnd";
    ables.forEach(function (able) {
      if (!able[controlEventName]) {
        return;
      }

      able[controlEventName](moveable, __assign(__assign({}, e), {
        isDrag: isPinch,
        datas: originalDatas[able.name],
        inputEvent: inputEvent,
        isPinch: true
      }));
    });
    return isPinch;
  },
  pinchGroupStart: function (moveable, e) {
    return this.pinchStart(moveable, __assign(__assign({}, e), {
      targets: moveable.props.targets
    }));
  },
  pinchGroup: function (moveable, e) {
    return this.pinch(moveable, __assign(__assign({}, e), {
      targets: moveable.props.targets
    }));
  },
  pinchGroupEnd: function (moveable, e) {
    return this.pinchEnd(moveable, __assign(__assign({}, e), {
      targets: moveable.props.targets
    }));
  }
});
/**
 * Whether or not target can be pinched with draggable, resizable, scalable, rotatable (default: false)
 * @name Moveable.Pinchable#pinchable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.pinchable = true;
 */

/**
 * When the pinch starts, the pinchStart event is called with part of scaleStart, rotateStart, resizeStart
 * @memberof Moveable.Pinchable
 * @event pinchStart
 * @param {Moveable.Pinchable.OnPinchStart} - Parameters for the pinchStart event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     rotatable: true,
 *     scalable: true,
 *     pinchable: true, // ["rotatable", "scalable"]
 * });
 * moveable.on("pinchStart", ({ target }) => {
 *     console.log(target);
 * });
 * moveable.on("rotateStart", ({ target }) => {
 *     console.log(target);
 * });
 * moveable.on("scaleStart", ({ target }) => {
 *     console.log(target);
 * });
 */

/**
 * When pinching, the pinch event is called with part of scale, rotate, resize
 * @memberof Moveable.Pinchable
 * @event pinch
 * @param {Moveable.Pinchable.OnPinch} - Parameters for the pinch event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     rotatable: true,
 *     scalable: true,
 *     pinchable: true, // ["rotatable", "scalable"]
 * });
 * moveable.on("pinch", ({ target }) => {
 *     console.log(target);
 * });
 * moveable.on("rotate", ({ target }) => {
 *     console.log(target);
 * });
 * moveable.on("scale", ({ target }) => {
 *     console.log(target);
 * });
 */

/**
 * When the pinch finishes, the pinchEnd event is called.
 * @memberof Moveable.Pinchable
 * @event pinchEnd
 * @param {Moveable.Pinchable.OnPinchEnd} - Parameters for the pinchEnd event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     rotatable: true,
 *     scalable: true,
 *     pinchable: true, // ["rotatable", "scalable"]
 * });
 * moveable.on("pinchEnd", ({ target }) => {
 *     console.log(target);
 * });
 * moveable.on("rotateEnd", ({ target }) => {
 *     console.log(target);
 * });
 * moveable.on("scaleEnd", ({ target }) => {
 *     console.log(target);
 * });
 */

/**
 * When the group pinch starts, the `pinchGroupStart` event is called.
 * @memberof Moveable.Pinchable
 * @event pinchGroupStart
 * @param {Moveable.Pinchable.OnPinchGroupStart} - Parameters for the `pinchGroupStart` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 *     pinchable: true
 * });
 * moveable.on("pinchGroupStart", ({ targets }) => {
 *     console.log("onPinchGroupStart", targets);
 * });
 */

/**
 * When the group pinch, the `pinchGroup` event is called.
 * @memberof Moveable.Pinchable
 * @event pinchGroup
 * @param {Moveable.Pinchable.OnPinchGroup} - Parameters for the `pinchGroup` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 *     pinchable: true
 * });
 * moveable.on("pinchGroup", ({ targets, events }) => {
 *     console.log("onPinchGroup", targets);
 * });
 */

/**
 * When the group pinch finishes, the `pinchGroupEnd` event is called.
 * @memberof Moveable.Pinchable
 * @event pinchGroupEnd
 * @param {Moveable.Pinchable.OnPinchGroupEnd} - Parameters for the `pinchGroupEnd` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 *     pinchable: true
 * });
 * moveable.on("pinchGroupEnd", ({ targets, isDrag }) => {
 *     console.log("onPinchGroupEnd", targets, isDrag);
 * });
 */

function setCustomDrag(e, state, delta, isPinch, isConvert) {
  var result = state.gesto.move(delta, e.inputEvent);
  var datas = result.originalDatas || result.datas;
  var draggableDatas = datas.draggable || (datas.draggable = {});
  return __assign(__assign({}, isConvert ? convertDragDist(state, result) : result), {
    isDrag: true,
    isPinch: !!isPinch,
    parentEvent: true,
    datas: draggableDatas,
    originalDatas: e.originalDatas
  });
}

var CustomGesto =
/*#__PURE__*/
function () {
  function CustomGesto() {
    this.prevX = 0;
    this.prevY = 0;
    this.startX = 0;
    this.startY = 0;
    this.isDrag = false;
    this.isFlag = false;
    this.datas = {
      draggable: {}
    };
  }

  var __proto = CustomGesto.prototype;

  __proto.dragStart = function (client, e) {
    this.isDrag = false;
    this.isFlag = false;
    var originalDatas = e.originalDatas;
    this.datas = originalDatas;

    if (!originalDatas.draggable) {
      originalDatas.draggable = {};
    }

    return __assign(__assign({}, this.move(client, e.inputEvent)), {
      type: "dragstart"
    });
  };

  __proto.drag = function (client, inputEvent) {
    return this.move([client[0] - this.prevX, client[1] - this.prevY], inputEvent);
  };

  __proto.move = function (delta, inputEvent) {
    var clientX;
    var clientY;

    if (!this.isFlag) {
      this.prevX = delta[0];
      this.prevY = delta[1];
      this.startX = delta[0];
      this.startY = delta[1];
      clientX = delta[0];
      clientY = delta[1];
      this.isFlag = true;
    } else {
      clientX = this.prevX + delta[0];
      clientY = this.prevY + delta[1];
      this.isDrag = true;
    }

    this.prevX = clientX;
    this.prevY = clientY;
    return {
      type: "drag",
      clientX: clientX,
      clientY: clientY,
      inputEvent: inputEvent,
      isDrag: this.isDrag,
      distX: clientX - this.startX,
      distY: clientY - this.startY,
      deltaX: delta[0],
      deltaY: delta[1],
      datas: this.datas.draggable,
      originalDatas: this.datas,
      parentEvent: true,
      parentGesto: this
    };
  };

  return CustomGesto;
}();

function fillChildEvents(moveable, name, e) {
  var datas = e.originalDatas;
  datas.groupable = datas.groupable || {};
  var groupableDatas = datas.groupable;
  groupableDatas.childDatas = groupableDatas.childDatas || [];
  var childDatas = groupableDatas.childDatas;
  return moveable.moveables.map(function (_, i) {
    childDatas[i] = childDatas[i] || {};
    childDatas[i][name] = childDatas[i][name] || {};
    return __assign(__assign({}, e), {
      datas: childDatas[i][name],
      originalDatas: childDatas[i]
    });
  });
}
function triggerChildGesto(moveable, able, type, delta, e, isConvert) {
  var isStart = !!type.match(/Start$/g);
  var isEnd = !!type.match(/End$/g);
  var isPinch = e.isPinch;
  var datas = e.datas;
  var events = fillChildEvents(moveable, able.name, e);
  var moveables = moveable.moveables;
  var childs = events.map(function (ev, i) {
    var childMoveable = moveables[i];
    var childEvent = ev;

    if (isStart) {
      childEvent = new CustomGesto().dragStart(delta, ev);
    } else {
      if (!childMoveable.state.gesto) {
        childMoveable.state.gesto = datas.childGestos[i];
      }

      childEvent = setCustomDrag(ev, childMoveable.state, delta, isPinch, isConvert);
    }

    var result = able[type](childMoveable, __assign(__assign({}, childEvent), {
      parentFlag: true
    }));

    if (isEnd) {
      childMoveable.state.gesto = null;
    }

    return result;
  });

  if (isStart) {
    datas.childGestos = moveables.map(function (child) {
      return child.state.gesto;
    });
  }

  return childs;
}
function triggerChildAbles(moveable, able, type, e, eachEvent, callback) {
  if (eachEvent === void 0) {
    eachEvent = function (_, ev) {
      return ev;
    };
  }

  var isEnd = !!type.match(/End$/g);
  var events = fillChildEvents(moveable, able.name, e);
  var moveables = moveable.moveables;
  var childs = events.map(function (ev, i) {
    var childMoveable = moveables[i];
    var childEvent = ev;
    childEvent = eachEvent(childMoveable, ev);
    var result = able[type](childMoveable, __assign(__assign({}, childEvent), {
      parentFlag: true
    }));
    result && callback && callback(childMoveable, ev, result, i);

    if (isEnd) {
      childMoveable.state.gesto = null;
    }

    return result;
  });
  return childs;
}

function calculatePointerDist(moveable, e) {
  var clientX = e.clientX,
      clientY = e.clientY,
      datas = e.datas;
  var _a = moveable.state,
      moveableClientRect = _a.moveableClientRect,
      rootMatrix = _a.rootMatrix,
      is3d = _a.is3d,
      pos1 = _a.pos1;
  var left = moveableClientRect.left,
      top = moveableClientRect.top;
  var n = is3d ? 4 : 3;

  var _b = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(calculateInversePosition(rootMatrix, [clientX - left, clientY - top], n), pos1),
      posX = _b[0],
      posY = _b[1];

  var _c = getDragDist({
    datas: datas,
    distX: posX,
    distY: posY
  }),
      distX = _c[0],
      distY = _c[1];

  return [distX, distY];
}
function setDragStart(moveable, _a) {
  var datas = _a.datas;
  var _b = moveable.state,
      allMatrix = _b.allMatrix,
      beforeMatrix = _b.beforeMatrix,
      is3d = _b.is3d,
      left = _b.left,
      top = _b.top,
      origin = _b.origin,
      offsetMatrix = _b.offsetMatrix,
      targetMatrix = _b.targetMatrix,
      transformOrigin = _b.transformOrigin;
  var n = is3d ? 4 : 3;
  datas.is3d = is3d;
  datas.matrix = allMatrix;
  datas.targetMatrix = targetMatrix;
  datas.beforeMatrix = beforeMatrix;
  datas.offsetMatrix = offsetMatrix;
  datas.transformOrigin = transformOrigin;
  datas.inverseMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.invert)(allMatrix, n);
  datas.inverseBeforeMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.invert)(beforeMatrix, n);
  datas.absoluteOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.convertPositionMatrix)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)([left, top], origin), n);
  datas.startDragBeforeDist = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.calculate)(datas.inverseBeforeMatrix, datas.absoluteOrigin, n);
  datas.startDragDist = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.calculate)(datas.inverseMatrix, datas.absoluteOrigin, n);
}
function getTransformDirection(e) {
  return calculateMoveablePosition(e.datas.beforeTransform, [50, 50], 100, 100).direction;
}
function resolveTransformEvent(event, functionName) {
  var datas = event.datas,
      originalDatas = event.originalDatas.beforeRenderable;
  var index = datas.transformIndex;
  var nextTransforms = originalDatas.nextTransforms;
  var nextTransformAppendedIndexes = originalDatas.nextTransformAppendedIndexes;
  var nextIndex = 0;

  if (index === -1) {
    nextIndex = nextTransforms.length;
    datas.transformIndex = nextIndex;
  } else {
    nextIndex = index + nextTransformAppendedIndexes.filter(function (i) {
      return i < index;
    }).length;
  }

  var result = getTransform(nextTransforms, nextIndex);
  var targetFunction = result.targetFunction;
  var matFunctionName = functionName === "rotate" ? "rotateZ" : functionName;
  datas.beforeFunctionTexts = result.beforeFunctionTexts;
  datas.afterFunctionTexts = result.afterFunctionTexts;
  datas.beforeTransform = result.beforeFunctionMatrix;
  datas.beforeTransform2 = result.beforeFunctionMatrix2;
  datas.targetTansform = result.targetFunctionMatrix;
  datas.afterTransform = result.afterFunctionMatrix;
  datas.afterTransform2 = result.afterFunctionMatrix2;
  datas.targetAllTransform = result.allFunctionMatrix;

  if (targetFunction.functionName === matFunctionName) {
    datas.afterFunctionTexts.splice(0, 1);
    datas.isAppendTransform = false;
  } else {
    datas.isAppendTransform = true;
    originalDatas.nextTransformAppendedIndexes = __spreadArray(__spreadArray([], nextTransformAppendedIndexes), [nextIndex]);
  }
}
function convertTransformFormat(datas, value, dist) {
  return datas.beforeFunctionTexts.join(" ") + " " + (datas.isAppendTransform ? dist : value) + " " + datas.afterFunctionTexts.join(" ");
}
function getTransformDist(_a) {
  var datas = _a.datas,
      distX = _a.distX,
      distY = _a.distY;

  var _b = getBeforeDragDist({
    datas: datas,
    distX: distX,
    distY: distY
  }),
      bx = _b[0],
      by = _b[1]; // B * [tx, ty] * A = [bx, by] * targetMatrix;
  // [tx, ty] = B-1 * [bx, by] * targetMatrix * A-1 * [0, 0];


  var res = getTransfromMatrix(datas, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.fromTranslation)([bx, by], 4));
  return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.calculate)(res, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.convertPositionMatrix)([0, 0, 0], 4), 4);
}
function getTransfromMatrix(datas, targetMatrix, isAfter) {
  var beforeTransform = datas.beforeTransform,
      afterTransform = datas.afterTransform,
      beforeTransform2 = datas.beforeTransform2,
      afterTransform2 = datas.afterTransform2,
      targetAllTransform = datas.targetAllTransform; // B * afterTargetMatrix * A = (targetMatrix * targetAllTransform)
  // afterTargetMatrix = B-1 * targetMatrix * targetAllTransform * A-1
  // nextTargetMatrix = (targetMatrix * targetAllTransform)

  var nextTargetMatrix = isAfter ? (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.multiply)(targetAllTransform, targetMatrix, 4) : (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.multiply)(targetMatrix, targetAllTransform, 4); // res1 = B-1 * nextTargetMatrix

  var res1 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.multiply)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.invert)(isAfter ? beforeTransform2 : beforeTransform, 4), nextTargetMatrix, 4); // res3 = res2 * A-1

  var afterTargetMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.multiply)(res1, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.invert)(isAfter ? afterTransform2 : afterTransform, 4), 4);
  return afterTargetMatrix;
}
function getBeforeDragDist(_a) {
  var datas = _a.datas,
      distX = _a.distX,
      distY = _a.distY; // TT = BT

  var inverseBeforeMatrix = datas.inverseBeforeMatrix,
      is3d = datas.is3d,
      startDragBeforeDist = datas.startDragBeforeDist,
      absoluteOrigin = datas.absoluteOrigin;
  var n = is3d ? 4 : 3; // ABS_ORIGIN * [distX, distY] = BM * (ORIGIN + [tx, ty])
  // BM -1 * ABS_ORIGIN * [distX, distY] - ORIGIN = [tx, ty]

  return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.calculate)(inverseBeforeMatrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(absoluteOrigin, [distX, distY]), n), startDragBeforeDist);
}
function getDragDist(_a, isBefore) {
  var datas = _a.datas,
      distX = _a.distX,
      distY = _a.distY;
  var inverseBeforeMatrix = datas.inverseBeforeMatrix,
      inverseMatrix = datas.inverseMatrix,
      is3d = datas.is3d,
      startDragBeforeDist = datas.startDragBeforeDist,
      startDragDist = datas.startDragDist,
      absoluteOrigin = datas.absoluteOrigin;
  var n = is3d ? 4 : 3;
  return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.calculate)(isBefore ? inverseBeforeMatrix : inverseMatrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(absoluteOrigin, [distX, distY]), n), isBefore ? startDragBeforeDist : startDragDist);
}
function getInverseDragDist(_a, isBefore) {
  var datas = _a.datas,
      distX = _a.distX,
      distY = _a.distY;
  var beforeMatrix = datas.beforeMatrix,
      matrix = datas.matrix,
      is3d = datas.is3d,
      startDragBeforeDist = datas.startDragBeforeDist,
      startDragDist = datas.startDragDist,
      absoluteOrigin = datas.absoluteOrigin;
  var n = is3d ? 4 : 3;
  return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.calculate)(isBefore ? beforeMatrix : matrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(isBefore ? startDragBeforeDist : startDragDist, [distX, distY]), n), absoluteOrigin);
}
function calculateTransformOrigin(transformOrigin, width, height, prevWidth, prevHeight, prevOrigin) {
  if (prevWidth === void 0) {
    prevWidth = width;
  }

  if (prevHeight === void 0) {
    prevHeight = height;
  }

  if (prevOrigin === void 0) {
    prevOrigin = [0, 0];
  }

  if (!transformOrigin) {
    return prevOrigin;
  }

  return transformOrigin.map(function (pos, i) {
    var _a = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.splitUnit)(pos),
        value = _a.value,
        unit = _a.unit;

    var prevSize = i ? prevHeight : prevWidth;
    var size = i ? height : width;

    if (pos === "%" || isNaN(value)) {
      // no value but %
      var measureRatio = prevSize ? prevOrigin[i] / prevSize : 0;
      return size * measureRatio;
    } else if (unit !== "%") {
      return value;
    }

    return size * value / 100;
  });
}
function getPosIndexesByDirection(direction) {
  var indexes = [];

  if (direction[1] >= 0) {
    if (direction[0] >= 0) {
      indexes.push(3);
    }

    if (direction[0] <= 0) {
      indexes.push(2);
    }
  }

  if (direction[1] <= 0) {
    if (direction[0] >= 0) {
      indexes.push(1);
    }

    if (direction[0] <= 0) {
      indexes.push(0);
    }
  }

  return indexes;
}
function getPosesByDirection(poses, direction) {
  /*
  [-1, -1](pos1)       [0, -1](pos1,pos2)       [1, -1](pos2)
  [-1, 0](pos1, pos3)                           [1, 0](pos2, pos4)
  [-1, 1](pos3)        [0, 1](pos3, pos4)       [1, 1](pos4)
  */
  return getPosIndexesByDirection(direction).map(function (index) {
    return poses[index];
  });
}
function getPosByDirection(poses, direction) {
  /*
  [-1, -1](pos1)       [0, -1](pos1,pos2)       [1, -1](pos2)
  [-1, 0](pos1, pos3)                           [1, 0](pos2, pos4)
  [-1, 1](pos3)        [0, 1](pos3, pos4)       [1, 1](pos4)
  */
  var nextPoses = getPosesByDirection(poses, direction);
  return [(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.average)(nextPoses.map(function (pos) {
    return pos[0];
  })), (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.average)(nextPoses.map(function (pos) {
    return pos[1];
  }))];
}
function getPosByReverseDirection(poses, direction) {
  /*
  [-1, -1](pos4)       [0, -1](pos3,pos4)       [1, -1](pos3)
  [-1, 0](pos2, pos4)                           [1, 0](pos3, pos1)
  [-1, 1](pos2)        [0, 1](pos1, pos2)       [1, 1](pos1)
  */
  return getPosByDirection(poses, direction.map(function (dir) {
    return -dir;
  }));
}

function getDist(startPos, matrix, width, height, n, fixedDirection) {
  var poses = calculatePoses(matrix, width, height, n);
  var fixedPos = getPosByDirection(poses, fixedDirection);
  var distX = startPos[0] - fixedPos[0];
  var distY = startPos[1] - fixedPos[1];
  return [distX, distY];
}

function getNextMatrix(offsetMatrix, targetMatrix, origin, n) {
  return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.multiply)(offsetMatrix, getAbsoluteMatrix(targetMatrix, n, origin), n);
}
function getNextTransformMatrix(state, datas, transform) {
  var transformOrigin = state.transformOrigin,
      offsetMatrix = state.offsetMatrix,
      is3d = state.is3d;
  var beforeTransform = datas.beforeTransform,
      afterTransform = datas.afterTransform;
  var n = is3d ? 4 : 3;
  var targetTransform = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.parseMat)([transform]);
  return getNextMatrix(offsetMatrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.convertDimension)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.multiply)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.multiply)(beforeTransform, targetTransform, 4), afterTransform, 4), 4, n), transformOrigin, n);
}
function scaleMatrix(state, scale) {
  var transformOrigin = state.transformOrigin,
      offsetMatrix = state.offsetMatrix,
      is3d = state.is3d,
      targetMatrix = state.targetMatrix;
  var n = is3d ? 4 : 3;
  return getNextMatrix(offsetMatrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.multiply)(targetMatrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createScaleMatrix)(scale, n), n), transformOrigin, n);
}
function fillTransformStartEvent(e) {
  var originalDatas = e.originalDatas.beforeRenderable;
  return {
    setTransform: function (transform, index) {
      if (index === void 0) {
        index = -1;
      }

      originalDatas.startTransforms = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.isArray)(transform) ? transform : (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.splitSpace)(transform);
      setTransformIndex(e, index);
    },
    setTransformIndex: function (index) {
      setTransformIndex(e, index);
    }
  };
}
function setDefaultTransformIndex(e, property) {
  var originalDatas = e.originalDatas.beforeRenderable;
  var startTransforms = originalDatas.startTransforms;
  setTransformIndex(e, (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.findIndex)(startTransforms, function (func) {
    return func.indexOf(property + "(") === 0;
  }));
}
function setTransformIndex(e, index) {
  var originalDatas = e.originalDatas.beforeRenderable;
  var datas = e.datas;
  datas.transformIndex = index;

  if (index === -1) {
    return;
  }

  var transform = originalDatas.startTransforms[index];

  if (!transform) {
    return;
  }

  var info = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.parse)([transform]);
  datas.startValue = info[0].functionValue;
}
function fillOriginalTransform(e, transform) {
  var originalDatas = e.originalDatas.beforeRenderable;
  originalDatas.nextTransforms = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.splitSpace)(transform);
}
function getNextTransformText(e) {
  var originalDatas = e.originalDatas.beforeRenderable;
  return originalDatas.nextTransforms.join(" ");
}
function fillTransformEvent(moveable, nextTransform, delta, isPinch, e) {
  fillOriginalTransform(e, nextTransform);
  return {
    transform: nextTransform,
    drag: Draggable.drag(moveable, setCustomDrag(e, moveable.state, delta, isPinch, false))
  };
}
function getTranslateDist(moveable, transform, fixedDirection, fixedPosition, datas) {
  var state = moveable.state;
  var left = state.left,
      top = state.top;
  var groupable = moveable.props.groupable;
  var nextMatrix = getNextTransformMatrix(moveable.state, datas, transform);
  var groupLeft = groupable ? left : 0;
  var groupTop = groupable ? top : 0;
  var nextFixedPosition = getDirectionOffset(moveable, fixedDirection, nextMatrix);
  var dist = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(fixedPosition, nextFixedPosition);
  return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(dist, [groupLeft, groupTop]);
}
function getScaleDist(moveable, scaleDist, fixedDirection, fixedPosition, datas) {
  return getTranslateDist(moveable, "scale(" + scaleDist.join(", ") + ")", fixedDirection, fixedPosition, datas);
}
function getOriginDirection(moveable) {
  var _a = moveable.state,
      width = _a.width,
      height = _a.height,
      transformOrigin = _a.transformOrigin;
  return [-1 + transformOrigin[0] / (width / 2), -1 + transformOrigin[1] / (height / 2)];
}
function getDirectionOffset(moveable, direction, nextMatrix) {
  if (nextMatrix === void 0) {
    nextMatrix = moveable.state.allMatrix;
  }

  var _a = moveable.state,
      width = _a.width,
      height = _a.height,
      is3d = _a.is3d;
  var n = is3d ? 4 : 3;
  var nextFixedOffset = [width / 2 * (1 + direction[0]), height / 2 * (1 + direction[1])];
  return calculatePosition(nextMatrix, nextFixedOffset, n);
}
function getRotateDist(moveable, rotateDist, fixedPosition, datas) {
  var fixedDirection = getOriginDirection(moveable);
  return getTranslateDist(moveable, "rotate(" + rotateDist + "deg)", fixedDirection, fixedPosition, datas);
}
function getResizeDist(moveable, width, height, fixedDirection, fixedPosition, transformOrigin) {
  var groupable = moveable.props.groupable;
  var _a = moveable.state,
      prevOrigin = _a.transformOrigin,
      targetMatrix = _a.targetMatrix,
      offsetMatrix = _a.offsetMatrix,
      is3d = _a.is3d,
      prevWidth = _a.width,
      prevHeight = _a.height,
      left = _a.left,
      top = _a.top;
  var n = is3d ? 4 : 3;
  var nextOrigin = calculateTransformOrigin(transformOrigin, width, height, prevWidth, prevHeight, prevOrigin);
  var groupLeft = groupable ? left : 0;
  var groupTop = groupable ? top : 0;
  var nextMatrix = getNextMatrix(offsetMatrix, targetMatrix, nextOrigin, n);
  var dist = getDist(fixedPosition, nextMatrix, width, height, n, fixedDirection);
  return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(dist, [groupLeft, groupTop]);
}
function getAbsolutePosition(moveable, direction) {
  return getPosByDirection(getAbsolutePosesByState(moveable.state), direction);
}

var VERTICAL_NAMES = ["left", "right", "center"];
var HORIZONTAL_NAMES = ["top", "bottom", "middle"];
var VERTICAL_NAMES_MAP = {
  start: "left",
  end: "right",
  center: "center"
};
var HORIZONTAL_NAMES_MAP = {
  start: "top",
  end: "bottom",
  center: "middle"
};
function hasGuidelines(moveable, ableName) {
  var _a = moveable.props,
      snappable = _a.snappable,
      bounds = _a.bounds,
      innerBounds = _a.innerBounds,
      verticalGuidelines = _a.verticalGuidelines,
      horizontalGuidelines = _a.horizontalGuidelines,
      snapGridWidth = _a.snapGridWidth,
      snapGridHeight = _a.snapGridHeight,
      _b = moveable.state,
      guidelines = _b.guidelines,
      enableSnap = _b.enableSnap;

  if (!snappable || !enableSnap || ableName && snappable !== true && snappable.indexOf(ableName) < 0) {
    return false;
  }

  if (snapGridWidth || snapGridHeight || bounds || innerBounds || guidelines && guidelines.length || verticalGuidelines && verticalGuidelines.length || horizontalGuidelines && horizontalGuidelines.length) {
    return true;
  }

  return false;
}
function getSnapDirections(snapDirections) {
  if (snapDirections === false) {
    return {};
  } else if (snapDirections === true || !snapDirections) {
    return {
      left: true,
      right: true,
      top: true,
      bottom: true
    };
  }

  return snapDirections;
}
function mapSnapDirectionPoses(snapDirections, snapPoses) {
  var nextSnapDirections = getSnapDirections(snapDirections);
  var nextSnapPoses = {};

  for (var name in nextSnapDirections) {
    if (name in snapPoses && nextSnapDirections[name]) {
      nextSnapPoses[name] = snapPoses[name];
    }
  }

  return nextSnapPoses;
}
function splitSnapDirectionPoses(snapDirections, snapPoses) {
  var nextSnapPoses = mapSnapDirectionPoses(snapDirections, snapPoses);
  var horizontalNames = HORIZONTAL_NAMES.filter(function (name) {
    return name in nextSnapPoses;
  });
  var verticalNames = VERTICAL_NAMES.filter(function (name) {
    return name in nextSnapPoses;
  });
  return {
    horizontal: horizontalNames.map(function (name) {
      return nextSnapPoses[name];
    }),
    vertical: verticalNames.map(function (name) {
      return nextSnapPoses[name];
    })
  };
}
function getGapGuidelines(moveable, targetRect, snapThreshold) {
  var elementRects = moveable.state.elementRects;
  var gapGuidelines = [];
  [["vertical", VERTICAL_NAMES_MAP, HORIZONTAL_NAMES_MAP], ["horizontal", HORIZONTAL_NAMES_MAP, VERTICAL_NAMES_MAP]].forEach(function (_a) {
    var type = _a[0],
        mainNames = _a[1],
        sideNames = _a[2];
    var targetStart = targetRect[mainNames.start];
    var targetEnd = targetRect[mainNames.end];
    var targetCenter = targetRect[mainNames.center];
    var targetStart2 = targetRect[sideNames.start];
    var targetEnd2 = targetRect[sideNames.end]; // element : moveable

    function getDist(elementRect) {
      var rect = elementRect.rect;

      if (rect[mainNames.end] < targetStart + snapThreshold) {
        return targetStart - rect[mainNames.end];
      } else if (targetEnd - snapThreshold < rect[mainNames.start]) {
        return rect[mainNames.start] - targetEnd;
      } else {
        return -1;
      }
    }

    var nextElementRects = elementRects.filter(function (elementRect) {
      var rect = elementRect.rect;

      if (rect[sideNames.start] > targetEnd2 || rect[sideNames.end] < targetStart2) {
        return false;
      }

      return getDist(elementRect) > 0;
    }).sort(function (a, b) {
      return getDist(a) - getDist(b);
    });
    var groups = [];
    nextElementRects.forEach(function (snapRect1) {
      nextElementRects.forEach(function (snapRect2) {
        if (snapRect1 === snapRect2) {
          return;
        }

        var rect1 = snapRect1.rect;
        var rect2 = snapRect2.rect;
        var rect1Start = rect1[sideNames.start];
        var rect1End = rect1[sideNames.end];
        var rect2Start = rect2[sideNames.start];
        var rect2End = rect2[sideNames.end];

        if (rect1Start > rect2End || rect2Start > rect1End) {
          return;
        }

        groups.push([snapRect1, snapRect2]);
      });
    });
    groups.forEach(function (_a) {
      var snapRect1 = _a[0],
          snapRect2 = _a[1];
      var rect1 = snapRect1.rect;
      var rect2 = snapRect2.rect;
      var rect1Start = rect1[mainNames.start];
      var rect1End = rect1[mainNames.end];
      var rect2Start = rect2[mainNames.start];
      var rect2End = rect2[mainNames.end];
      var gap = 0;
      var pos = 0;
      var isStart = false;
      var isCenter = false;
      var isEnd = false;

      if (rect1End <= targetStart && targetEnd <= rect2Start) {
        // (l)element1(r) : (l)target(r) : (l)element2(r)
        isCenter = true;
        gap = (rect2Start - rect1End - (targetEnd - targetStart)) / 2;
        pos = rect1End + gap + (targetEnd - targetStart) / 2;

        if (Math.abs(pos - targetCenter) > snapThreshold) {
          return;
        }
      } else if (rect1End < rect2Start && rect2End < targetStart + snapThreshold) {
        // (l)element1(r) : (l)element2(r) : (l)target
        isStart = true;
        gap = rect2Start - rect1End;
        pos = rect2End + gap;

        if (Math.abs(pos - targetStart) > snapThreshold) {
          return;
        }
      } else if (rect1End < rect2Start && targetEnd - snapThreshold < rect1Start) {
        // target(r) : (l)element1(r) : (l)element2(r)
        isEnd = true;
        gap = rect2Start - rect1End;
        pos = rect1Start - gap;

        if (Math.abs(pos - targetEnd) > snapThreshold) {
          return;
        }
      } else {
        return;
      }

      if (!gap) {
        return;
      }

      gapGuidelines.push({
        type: type,
        pos: type === "vertical" ? [pos, 0] : [0, pos],
        element: snapRect2.element,
        size: 0,
        className: snapRect2.className,
        isStart: isStart,
        isCenter: isCenter,
        isEnd: isEnd,
        gap: gap,
        hide: true,
        gapRects: [snapRect1, snapRect2]
      });
    });
  });
  return gapGuidelines;
}
function getDefaultGuidelines(horizontalGuidelines, verticalGuidelines, width, height, clientLeft, clientTop, snapOffset) {
  if (clientLeft === void 0) {
    clientLeft = 0;
  }

  if (clientTop === void 0) {
    clientTop = 0;
  }

  if (snapOffset === void 0) {
    snapOffset = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
  }

  var guidelines = [];
  var snapOffsetLeft = snapOffset.left,
      snapOffsetTop = snapOffset.top,
      snapOffsetBottom = snapOffset.bottom,
      snapOffsetRight = snapOffset.right;
  var snapWidth = width + snapOffsetRight - snapOffsetLeft;
  var snapHeight = height + snapOffsetBottom - snapOffsetTop;
  horizontalGuidelines && horizontalGuidelines.forEach(function (pos) {
    guidelines.push({
      type: "horizontal",
      pos: [snapOffsetLeft, (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(pos - clientTop + snapOffsetTop, 0.1)],
      size: snapWidth
    });
  });
  verticalGuidelines && verticalGuidelines.forEach(function (pos) {
    guidelines.push({
      type: "vertical",
      pos: [(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(pos - clientLeft + snapOffsetLeft, 0.1), snapOffsetTop],
      size: snapHeight
    });
  });
  return guidelines;
}
function calculateContainerPos(rootMatrix, containerRect, n) {
  var clientPos = calculatePosition(rootMatrix, [containerRect.clientLeft, containerRect.clientTop], n);
  return [containerRect.left + clientPos[0], containerRect.top + clientPos[1]];
}
function getSnapElementRects(moveable, values) {
  if (!values.length) {
    return [];
  }

  var state = moveable.state;
  var containerClientRect = state.containerClientRect,
      _a = state.targetClientRect,
      clientTop = _a.top,
      clientLeft = _a.left,
      rootMatrix = state.rootMatrix,
      is3d = state.is3d;
  var n = is3d ? 4 : 3;

  var _b = calculateContainerPos(rootMatrix, containerClientRect, n),
      containerLeft = _b[0],
      containerTop = _b[1];

  var poses = getAbsolutePosesByState(state);

  var _c = (0,overlap_area__WEBPACK_IMPORTED_MODULE_5__.getMinMaxs)(poses),
      targetLeft = _c.minX,
      targetTop = _c.minY;

  var _d = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)([targetLeft, targetTop], calculateInversePosition(rootMatrix, [clientLeft - containerLeft, clientTop - containerTop], n)).map(function (pos) {
    return roundSign(pos);
  }),
      distLeft = _d[0],
      distTop = _d[1];

  return values.map(function (value) {
    var rect = value.element.getBoundingClientRect();
    var left = rect.left - containerLeft;
    var top = rect.top - containerTop;
    var bottom = top + rect.height;
    var right = left + rect.width;

    var _a = calculateInversePosition(rootMatrix, [left, top], n),
        elementLeft = _a[0],
        elementTop = _a[1];

    var _b = calculateInversePosition(rootMatrix, [right, bottom], n),
        elementRight = _b[0],
        elementBottom = _b[1];

    return __assign(__assign({}, value), {
      rect: {
        left: elementLeft + distLeft,
        right: elementRight + distLeft,
        top: elementTop + distTop,
        bottom: elementBottom + distTop,
        center: (elementLeft + elementRight) / 2 + distLeft,
        middle: (elementTop + elementBottom) / 2 + distTop
      }
    });
  });
}
function getElementGuidelines(moveable) {
  var state = moveable.state;
  var _a = moveable.props.elementGuidelines,
      elementGuidelines = _a === void 0 ? [] : _a;

  if (!elementGuidelines.length) {
    state.elementRects = [];
    return [];
  }

  var prevValues = (state.elementRects || []).filter(function (snapRect) {
    return !snapRect.refresh;
  });
  var nextElementGuidelines = elementGuidelines.map(function (el) {
    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.isObject)(el) && "element" in el) {
      return el;
    }

    return {
      element: getRefTarget(el, true)
    };
  }).filter(function (value) {
    return value.element;
  });

  var _b = (0,_egjs_children_differ__WEBPACK_IMPORTED_MODULE_6__.diff)(prevValues.map(function (v) {
    return v.element;
  }), nextElementGuidelines.map(function (v) {
    return v.element;
  })),
      maintained = _b.maintained,
      added = _b.added;

  var nextValues = [];
  maintained.forEach(function (_a) {
    var prevIndex = _a[0],
        nextIndex = _a[1];
    nextValues[nextIndex] = prevValues[prevIndex];
  });
  getSnapElementRects(moveable, added.map(function (index) {
    return nextElementGuidelines[index];
  })).map(function (rect, i) {
    nextValues[added[i]] = rect;
  });
  state.elementRects = nextValues;
  var elementSnapDirections = getSnapDirections(moveable.props.elementSnapDirections);
  var nextGuidelines = [];
  nextValues.forEach(function (snapRect) {
    var element = snapRect.element,
        _a = snapRect.top,
        topValue = _a === void 0 ? elementSnapDirections.top : _a,
        _b = snapRect.left,
        leftValue = _b === void 0 ? elementSnapDirections.left : _b,
        _c = snapRect.right,
        rightValue = _c === void 0 ? elementSnapDirections.right : _c,
        _d = snapRect.bottom,
        bottomValue = _d === void 0 ? elementSnapDirections.bottom : _d,
        _e = snapRect.center,
        centerValue = _e === void 0 ? elementSnapDirections.center : _e,
        _f = snapRect.middle,
        middleValue = _f === void 0 ? elementSnapDirections.middle : _f,
        className = snapRect.className,
        rect = snapRect.rect;

    var _g = splitSnapDirectionPoses({
      top: topValue,
      right: rightValue,
      left: leftValue,
      bottom: bottomValue,
      center: centerValue,
      middle: middleValue
    }, rect),
        horizontal = _g.horizontal,
        vertical = _g.vertical;

    var rectTop = rect.top;
    var rectLeft = rect.left;
    var width = rect.right - rectLeft;
    var height = rect.bottom - rectTop;
    var sizes = [width, height];
    vertical.forEach(function (pos) {
      nextGuidelines.push({
        type: "vertical",
        element: element,
        pos: [(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(pos, 0.1), rectTop],
        size: height,
        sizes: sizes,
        className: className,
        elementRect: snapRect
      });
    });
    horizontal.forEach(function (pos) {
      nextGuidelines.push({
        type: "horizontal",
        element: element,
        pos: [rectLeft, (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(pos, 0.1)],
        size: width,
        sizes: sizes,
        className: className,
        elementRect: snapRect
      });
    });
  });
  return nextGuidelines;
}
function getTotalGuidelines(moveable) {
  var _a = moveable.state,
      snapOffset = _a.snapOffset,
      _b = _a.containerClientRect,
      overflow = _b.overflow,
      containerHeight = _b.scrollHeight,
      containerWidth = _b.scrollWidth,
      containerClientHeight = _b.clientHeight,
      containerClientWidth = _b.clientWidth,
      clientLeft = _b.clientLeft,
      clientTop = _b.clientTop;
  var _c = moveable.props,
      _d = _c.snapGap,
      snapGap = _d === void 0 ? true : _d,
      verticalGuidelines = _c.verticalGuidelines,
      horizontalGuidelines = _c.horizontalGuidelines,
      _e = _c.snapThreshold,
      snapThreshold = _e === void 0 ? 5 : _e,
      _f = _c.snapGridWidth,
      snapGridWidth = _f === void 0 ? 0 : _f,
      _g = _c.snapGridHeight,
      snapGridHeight = _g === void 0 ? 0 : _g;
  var elementGuidelines = getElementGuidelines(moveable);

  var totalGuidelines = __spreadArray([], elementGuidelines);

  if (snapGap) {
    var _h = getRect(getAbsolutePosesByState(moveable.state)),
        top = _h.top,
        left = _h.left,
        bottom = _h.bottom,
        right = _h.right;

    totalGuidelines.push.apply(totalGuidelines, getGapGuidelines(moveable, {
      top: top,
      left: left,
      bottom: bottom,
      right: right,
      center: (left + right) / 2,
      middle: (top + bottom) / 2
    }, snapThreshold));
  }

  totalGuidelines.push.apply(totalGuidelines, getGridGuidelines(snapGridWidth, snapGridHeight, overflow ? containerWidth : containerClientWidth, overflow ? containerHeight : containerClientHeight, clientLeft, clientTop));
  totalGuidelines.push.apply(totalGuidelines, getDefaultGuidelines(horizontalGuidelines || false, verticalGuidelines || false, overflow ? containerWidth : containerClientWidth, overflow ? containerHeight : containerClientHeight, clientLeft, clientTop, snapOffset));
  return totalGuidelines;
}
function getGridGuidelines(snapGridWidth, snapGridHeight, containerWidth, containerHeight, clientLeft, clientTop) {
  if (clientLeft === void 0) {
    clientLeft = 0;
  }

  if (clientTop === void 0) {
    clientTop = 0;
  }

  var guidelines = [];

  if (snapGridHeight) {
    for (var pos = 0; pos <= containerHeight; pos += snapGridHeight) {
      guidelines.push({
        type: "horizontal",
        pos: [0, (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(pos - clientTop, 0.1)],
        size: containerWidth,
        hide: true
      });
    }
  }

  if (snapGridWidth) {
    for (var pos = 0; pos <= containerWidth; pos += snapGridWidth) {
      guidelines.push({
        type: "vertical",
        pos: [(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(pos - clientLeft, 0.1), 0],
        size: containerHeight,
        hide: true
      });
    }
  }

  return guidelines;
}

function checkMoveableSnapPoses(moveable, posesX, posesY, customSnapThreshold) {
  var props = moveable.props;
  var snapThreshold = selectValue(customSnapThreshold, props.snapThreshold, 5);
  return checkSnapPoses(moveable.state.guidelines, posesX, posesY, snapThreshold);
}
function checkSnapPoses(guidelines, posesX, posesY, snapThreshold) {
  return {
    vertical: checkSnap(guidelines, "vertical", posesX, snapThreshold),
    horizontal: checkSnap(guidelines, "horizontal", posesY, snapThreshold)
  };
}
function checkSnapKeepRatio(moveable, startPos, endPos) {
  var endX = endPos[0],
      endY = endPos[1];
  var startX = startPos[0],
      startY = startPos[1];

  var _a = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(endPos, startPos),
      dx = _a[0],
      dy = _a[1];

  var isBottom = dy > 0;
  var isRight = dx > 0;
  dx = getTinyDist(dx);
  dy = getTinyDist(dy);
  var verticalInfo = {
    isSnap: false,
    offset: 0,
    pos: 0
  };
  var horizontalInfo = {
    isSnap: false,
    offset: 0,
    pos: 0
  };

  if (dx === 0 && dy === 0) {
    return {
      vertical: verticalInfo,
      horizontal: horizontalInfo
    };
  }

  var _b = checkMoveableSnapPoses(moveable, dx ? [endX] : [], dy ? [endY] : []),
      verticalSnapInfo = _b.vertical,
      horizontalSnapInfo = _b.horizontal;

  verticalSnapInfo.posInfos.filter(function (_a) {
    var pos = _a.pos;
    return isRight ? pos >= startX : pos <= startX;
  });
  horizontalSnapInfo.posInfos.filter(function (_a) {
    var pos = _a.pos;
    return isBottom ? pos >= startY : pos <= startY;
  });
  verticalSnapInfo.isSnap = verticalSnapInfo.posInfos.length > 0;
  horizontalSnapInfo.isSnap = horizontalSnapInfo.posInfos.length > 0;

  var _c = getNearestSnapGuidelineInfo(verticalSnapInfo),
      isVerticalSnap = _c.isSnap,
      verticalGuideline = _c.guideline;

  var _d = getNearestSnapGuidelineInfo(horizontalSnapInfo),
      isHorizontalSnap = _d.isSnap,
      horizontalGuideline = _d.guideline;

  var horizontalPos = isHorizontalSnap ? horizontalGuideline.pos[1] : 0;
  var verticalPos = isVerticalSnap ? verticalGuideline.pos[0] : 0;

  if (dx === 0) {
    if (isHorizontalSnap) {
      horizontalInfo.isSnap = true;
      horizontalInfo.pos = horizontalGuideline.pos[1];
      horizontalInfo.offset = endY - horizontalInfo.pos;
    }
  } else if (dy === 0) {
    if (isVerticalSnap) {
      verticalInfo.isSnap = true;
      verticalInfo.pos = verticalPos;
      verticalInfo.offset = endX - verticalPos;
    }
  } else {
    // y - y1 = a * (x - x1)
    var a = dy / dx;
    var b = endPos[1] - a * endX;
    var y = 0;
    var x = 0;
    var isSnap = false;

    if (isVerticalSnap) {
      x = verticalPos;
      y = a * x + b;
      isSnap = true;
    } else if (isHorizontalSnap) {
      y = horizontalPos;
      x = (y - b) / a;
      isSnap = true;
    }

    if (isSnap) {
      verticalInfo.isSnap = true;
      verticalInfo.pos = x;
      verticalInfo.offset = endX - x;
      horizontalInfo.isSnap = true;
      horizontalInfo.pos = y;
      horizontalInfo.offset = endY - y;
    }
  }

  return {
    vertical: verticalInfo,
    horizontal: horizontalInfo
  };
}
function checkSnaps(moveable, rect, customSnapThreshold) {
  var poses = splitSnapDirectionPoses(moveable.props.snapDirections, rect);
  return checkMoveableSnapPoses(moveable, poses.vertical, poses.horizontal, customSnapThreshold);
}
function getNearestSnapGuidelineInfo(snapInfo) {
  var isSnap = snapInfo.isSnap;

  if (!isSnap) {
    return {
      isSnap: false,
      offset: 0,
      dist: -1,
      pos: 0,
      guideline: null
    };
  }

  var posInfo = snapInfo.posInfos[0];
  var guidelineInfo = posInfo.guidelineInfos[0];
  var offset = guidelineInfo.offset;
  var dist = guidelineInfo.dist;
  var guideline = guidelineInfo.guideline;
  return {
    isSnap: isSnap,
    offset: offset,
    dist: dist,
    pos: posInfo.pos,
    guideline: guideline
  };
}

function checkSnap(guidelines, targetType, targetPoses, snapThreshold) {
  if (!guidelines || !guidelines.length) {
    return {
      isSnap: false,
      index: -1,
      posInfos: []
    };
  }

  var isVertical = targetType === "vertical";
  var posType = isVertical ? 0 : 1;
  var snapPosInfos = targetPoses.map(function (targetPos, index) {
    var guidelineInfos = guidelines.map(function (guideline) {
      var pos = guideline.pos;
      var offset = targetPos - pos[posType];
      return {
        offset: offset,
        dist: Math.abs(offset),
        guideline: guideline
      };
    }).filter(function (_a) {
      var guideline = _a.guideline,
          dist = _a.dist;
      var type = guideline.type;

      if (type !== targetType || dist > snapThreshold) {
        return false;
      }

      return true;
    }).sort(function (a, b) {
      return a.dist - b.dist;
    });
    return {
      pos: targetPos,
      index: index,
      guidelineInfos: guidelineInfos
    };
  }).filter(function (snapPosInfo) {
    return snapPosInfo.guidelineInfos.length > 0;
  }).sort(function (a, b) {
    return a.guidelineInfos[0].dist - b.guidelineInfos[0].dist;
  });
  var isSnap = snapPosInfos.length > 0;
  return {
    isSnap: isSnap,
    index: isSnap ? snapPosInfos[0].index : -1,
    posInfos: snapPosInfos
  };
}

function getSnapInfosByDirection(moveable, poses, snapDirection) {
  var nextPoses = [];

  if (snapDirection[0] && snapDirection[1]) {
    nextPoses = [snapDirection, [-snapDirection[0], snapDirection[1]], [snapDirection[0], -snapDirection[1]]].map(function (direction) {
      return getPosByDirection(poses, direction);
    });
  } else if (!snapDirection[0] && !snapDirection[1]) {
    var alignPoses = [poses[0], poses[1], poses[3], poses[2], poses[0]];

    for (var i = 0; i < 4; ++i) {
      nextPoses.push(alignPoses[i]);
      nextPoses.push([(alignPoses[i][0] + alignPoses[i + 1][0]) / 2, (alignPoses[i][1] + alignPoses[i + 1][1]) / 2]);
    }
  } else {
    if (moveable.props.keepRatio) {
      nextPoses = [[-1, -1], [-1, 1], [1, -1], [1, 1], snapDirection].map(function (dir) {
        return getPosByDirection(poses, dir);
      });
    } else {
      nextPoses = getPosesByDirection(poses, snapDirection);

      if (nextPoses.length > 1) {
        nextPoses.push([(nextPoses[0][0] + nextPoses[1][0]) / 2, (nextPoses[0][1] + nextPoses[1][1]) / 2]);
      }
    }
  }

  return checkMoveableSnapPoses(moveable, nextPoses.map(function (pos) {
    return pos[0];
  }), nextPoses.map(function (pos) {
    return pos[1];
  }), 1);
}
function checkSnapBoundPriority(a, b) {
  var aDist = Math.abs(a.offset);
  var bDist = Math.abs(b.offset);

  if (a.isBound && b.isBound) {
    return bDist - aDist;
  } else if (a.isBound) {
    return -1;
  } else if (b.isBound) {
    return 1;
  } else if (a.isSnap && b.isSnap) {
    return bDist - aDist;
  } else if (a.isSnap) {
    return -1;
  } else if (b.isSnap) {
    return 1;
  } else if (aDist < TINY_NUM) {
    return 1;
  } else if (bDist < TINY_NUM) {
    return -1;
  }

  return aDist - bDist;
}
function getNearOffsetInfo(offsets, index) {
  return offsets.slice().sort(function (a, b) {
    var aSign = a.sign[index];
    var bSign = b.sign[index];
    var aOffset = a.offset[index];
    var bOffset = b.offset[index]; // -1 The positions of a and b do not change.
    // 1 The positions of a and b are reversed.

    if (!aSign) {
      return 1;
    } else if (!bSign) {
      return -1;
    }

    return checkSnapBoundPriority({
      isBound: a.isBound,
      isSnap: a.isSnap,
      offset: aOffset
    }, {
      isBound: b.isBound,
      isSnap: b.isSnap,
      offset: bOffset
    });
  })[0];
}
function getCheckSnapDirections(direction, keepRatio) {
  var directions = [];
  var fixedDirection = [-direction[0], -direction[1]];

  if (direction[0] && direction[1]) {
    directions.push([fixedDirection, [direction[0], -direction[1]]], [fixedDirection, [-direction[0], direction[1]]]);

    if (keepRatio) {
      // pass two direction condition
      directions.push([fixedDirection, direction]);
    }
  } else if (direction[0]) {
    // vertcal
    if (keepRatio) {
      directions.push([fixedDirection, [fixedDirection[0], -1]], [fixedDirection, [fixedDirection[0], 1]], [fixedDirection, [direction[0], -1]], [fixedDirection, direction], [fixedDirection, [direction[0], 1]]);
    } else {
      directions.push([[fixedDirection[0], -1], [direction[0], -1]], [[fixedDirection[0], 0], [direction[0], 0]], [[fixedDirection[0], 1], [direction[0], 1]]);
    }
  } else if (direction[1]) {
    // horizontal
    if (keepRatio) {
      directions.push([fixedDirection, [-1, fixedDirection[1]]], [fixedDirection, [1, fixedDirection[1]]], [fixedDirection, [-1, direction[1]]], [fixedDirection, [1, direction[1]]], [fixedDirection, direction]);
    } else {
      directions.push([[-1, fixedDirection[1]], [-1, direction[1]]], [[0, fixedDirection[1]], [0, direction[1]]], [[1, fixedDirection[1]], [1, direction[1]]]);
    }
  } else {
    // [0, 0] to all direction
    directions.push([fixedDirection, [1, 0]], [fixedDirection, [-1, 0]], [fixedDirection, [0, -1]], [fixedDirection, [0, 1]], [[1, 0], [1, -1]], [[1, 0], [1, 1]], [[0, 1], [1, 1]], [[0, 1], [-1, 1]], [[-1, 0], [-1, -1]], [[-1, 0], [-1, 1]], [[0, -1], [1, -1]], [[0, -1], [-1, -1]]);
  }

  return directions;
}

function isStartLine(dot, line) {
  // l    o     => true
  // o    l    => false
  var cx = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.average)([line[0][0], line[1][0]]);
  var cy = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.average)([line[0][1], line[1][1]]);
  return {
    vertical: cx <= dot[0],
    horizontal: cy <= dot[1]
  };
}

function hitTestLine(dot, _a) {
  var pos1 = _a[0],
      pos2 = _a[1];
  var dx = pos2[0] - pos1[0];
  var dy = pos2[1] - pos1[1];

  if (Math.abs(dx) < TINY_NUM) {
    dx = 0;
  }

  if (Math.abs(dy) < TINY_NUM) {
    dy = 0;
  }

  var test1;
  var test2;

  if (!dx) {
    test1 = pos1[0];
    test2 = dot[0];
  } else if (!dy) {
    test1 = pos1[1];
    test2 = dot[1];
  } else {
    var a = dy / dx; // y = a * (x - pos1) + pos1

    test1 = a * (dot[0] - pos1[0]) + pos1[1];
    test2 = dot[1];
  }

  return test1 - test2;
}

function isSameStartLine(dots, line, error) {
  if (error === void 0) {
    error = TINY_NUM;
  }

  var centerSign = hitTestLine(dots[0], line) <= 0;
  return dots.slice(1).every(function (dot) {
    var value = hitTestLine(dot, line);
    var sign = value <= 0;
    return sign === centerSign || Math.abs(value) <= error;
  });
}

function checkInnerBoundDot(pos, start, end, isStart, threshold) {
  if (threshold === void 0) {
    threshold = 0;
  }

  if (isStart && start - threshold <= pos || !isStart && pos <= end + threshold) {
    // false 402 565 602 => 37 ([0, 37])
    // true 400 524.9712603540036 600 => 124 ([124, 0])
    // true 400 410 600 => 10 ([10, 0])
    return {
      isBound: true,
      offset: isStart ? start - pos : end - pos
    };
  }

  return {
    isBound: false,
    offset: 0
  };
}

function checkInnerBound(moveable, line, center) {
  var bounds = moveable.props.innerBounds;

  if (!bounds) {
    return {
      isAllBound: false,
      isBound: false,
      isVerticalBound: false,
      isHorizontalBound: false,
      offset: [0, 0]
    };
  }

  var left = bounds.left,
      top = bounds.top,
      width = bounds.width,
      height = bounds.height;
  var leftLine = [[left, top], [left, top + height]];
  var topLine = [[left, top], [left + width, top]];
  var rightLine = [[left + width, top], [left + width, top + height]];
  var bottomLine = [[left, top + height], [left + width, top + height]];

  var _a = isStartLine(center, line),
      isHorizontalStart = _a.horizontal,
      isVerticalStart = _a.vertical;

  if (isSameStartLine([center, [left, top], [left + width, top], [left, top + height], [left + width, top + height]], line)) {
    return {
      isAllBound: false,
      isBound: false,
      isVerticalBound: false,
      isHorizontalBound: false,
      offset: [0, 0]
    };
  } // test vertical


  var topBoundInfo = checkLineBoundCollision(line, topLine, isVerticalStart);
  var bottomBoundInfo = checkLineBoundCollision(line, bottomLine, isVerticalStart); // test horizontal

  var leftBoundInfo = checkLineBoundCollision(line, leftLine, isHorizontalStart);
  var rightBoundInfo = checkLineBoundCollision(line, rightLine, isHorizontalStart);
  var isAllVerticalBound = topBoundInfo.isBound && bottomBoundInfo.isBound;
  var isVerticalBound = topBoundInfo.isBound || bottomBoundInfo.isBound;
  var isAllHorizontalBound = leftBoundInfo.isBound && rightBoundInfo.isBound;
  var isHorizontalBound = leftBoundInfo.isBound || rightBoundInfo.isBound;
  var verticalOffset = maxOffset(topBoundInfo.offset, bottomBoundInfo.offset);
  var horizontalOffset = maxOffset(leftBoundInfo.offset, rightBoundInfo.offset);
  var offset = [0, 0];
  var isBound = false;
  var isAllBound = false;

  if (Math.abs(horizontalOffset) < Math.abs(verticalOffset)) {
    offset = [verticalOffset, 0];
    isBound = isVerticalBound;
    isAllBound = isAllVerticalBound;
  } else {
    offset = [0, horizontalOffset];
    isBound = isHorizontalBound;
    isAllBound = isAllHorizontalBound;
  }

  return {
    isAllBound: isAllBound,
    isVerticalBound: isVerticalBound,
    isHorizontalBound: isHorizontalBound,
    isBound: isBound,
    offset: offset
  };
}

function checkLineBoundCollision(line, boundLine, isStart, threshold, isRender) {
  var dot1 = line[0];
  var dot2 = line[1];
  var boundDot1 = boundLine[0];
  var boundDot2 = boundLine[1];
  var dy1 = getTinyDist(dot2[1] - dot1[1]);
  var dx1 = getTinyDist(dot2[0] - dot1[0]);
  var dy2 = getTinyDist(boundDot2[1] - boundDot1[1]);
  var dx2 = getTinyDist(boundDot2[0] - boundDot1[0]); // dx2 or dy2 is zero

  if (!dx2) {
    // vertical
    if (isRender && !dy1) {
      // 90deg
      return {
        isBound: false,
        offset: 0
      };
    } else if (dx1) {
      // const y = dy1 ? dy1 / dx1 * (boundDot1[0] - dot1[0]) + dot1[1] : dot1[1];
      var y = dy1 / dx1 * (boundDot1[0] - dot1[0]) + dot1[1]; // boundDot1[1] <= y  <= boundDot2[1]

      return checkInnerBoundDot(y, boundDot1[1], boundDot2[1], isStart, threshold);
    } else {
      var offset = boundDot1[0] - dot1[0];
      var isBound = Math.abs(offset) <= (threshold || 0);
      return {
        isBound: isBound,
        offset: isBound ? offset : 0
      };
    }
  } else if (!dy2) {
    // horizontal
    if (isRender && !dx1) {
      // 90deg
      return {
        isBound: false,
        offset: 0
      };
    } else if (dy1) {
      // y = a * (x - x1) + y1
      // x = (y - y1) / a + x1
      // const a = dy1 / dx1;
      // const x = dx1 ? (boundDot1[1] - dot1[1]) / a + dot1[0] : dot1[0];
      var x = (boundDot1[1] - dot1[1]) / (dy1 / dx1) + dot1[0]; // boundDot1[0] <= x && x <= boundDot2[0]

      return checkInnerBoundDot(x, boundDot1[0], boundDot2[0], isStart, threshold);
    } else {
      var offset = boundDot1[1] - dot1[1];
      var isBound = Math.abs(offset) <= (threshold || 0);
      return {
        isBound: isBound,
        offset: isBound ? offset : 0
      };
    }
  }

  return {
    isBound: false,
    offset: 0
  };
}

function getInnerBoundInfo(moveable, lines, center, datas) {
  return lines.map(function (_a) {
    var multiple = _a[0],
        pos1 = _a[1],
        pos2 = _a[2];

    var _b = checkInnerBound(moveable, [pos1, pos2], center),
        isBound = _b.isBound,
        offset = _b.offset,
        isVerticalBound = _b.isVerticalBound,
        isHorizontalBound = _b.isHorizontalBound;

    var sizeOffset = getDragDist({
      datas: datas,
      distX: offset[0],
      distY: offset[1]
    }).map(function (size, i) {
      return size * (multiple[i] ? 2 / multiple[i] : 0);
    });
    return {
      sign: multiple,
      isBound: isBound,
      isVerticalBound: isVerticalBound,
      isHorizontalBound: isHorizontalBound,
      isSnap: false,
      offset: sizeOffset
    };
  });
}
function getInnerBoundDragInfo(moveable, poses, datas) {
  var _a;

  var lines = getCheckInnerBoundLines(poses, [0, 0], false).map(function (_a) {
    var sign = _a[0],
        pos1 = _a[1],
        pos2 = _a[2];
    return [sign.map(function (dir) {
      return Math.abs(dir) * 2;
    }), pos1, pos2];
  });
  var innerBoundInfo = getInnerBoundInfo(moveable, lines, getPosByDirection(poses, [0, 0]), datas);
  var widthOffsetInfo = getNearOffsetInfo(innerBoundInfo, 0);
  var heightOffsetInfo = getNearOffsetInfo(innerBoundInfo, 1);
  var verticalOffset = 0;
  var horizontalOffset = 0;
  var isVerticalBound = widthOffsetInfo.isVerticalBound || heightOffsetInfo.isVerticalBound;
  var isHorizontalBound = widthOffsetInfo.isHorizontalBound || heightOffsetInfo.isHorizontalBound;

  if (isVerticalBound || isHorizontalBound) {
    _a = getInverseDragDist({
      datas: datas,
      distX: -widthOffsetInfo.offset[0],
      distY: -heightOffsetInfo.offset[1]
    }), verticalOffset = _a[0], horizontalOffset = _a[1];
  }

  return {
    vertical: {
      isBound: isVerticalBound,
      offset: verticalOffset
    },
    horizontal: {
      isBound: isHorizontalBound,
      offset: horizontalOffset
    }
  };
}
function getCheckSnapLineDirections(direction, keepRatio) {
  var lineDirections = [];
  var x = direction[0];
  var y = direction[1];

  if (x && y) {
    lineDirections.push([[0, y * 2], direction, [-x, y]], [[x * 2, 0], direction, [x, -y]]);
  } else if (x) {
    // vertcal
    lineDirections.push([[x * 2, 0], [x, 1], [x, -1]]);

    if (keepRatio) {
      lineDirections.push([[0, -1], [x, -1], [-x, -1]], [[0, 1], [x, 1], [-x, 1]]);
    }
  } else if (y) {
    // horizontal
    lineDirections.push([[0, y * 2], [1, y], [-1, y]]);

    if (keepRatio) {
      lineDirections.push([[-1, 0], [-1, y], [-1, -y]], [[1, 0], [1, y], [1, -y]]);
    }
  } else {
    // [0, 0] to all direction
    lineDirections.push([[-1, 0], [-1, -1], [-1, 1]], [[1, 0], [1, -1], [1, 1]], [[0, -1], [-1, -1], [1, -1]], [[0, 1], [-1, 1], [1, 1]]);
  }

  return lineDirections;
}
function getCheckInnerBoundLines(poses, direction, keepRatio) {
  return getCheckSnapLineDirections(direction, keepRatio).map(function (_a) {
    var sign = _a[0],
        dir1 = _a[1],
        dir2 = _a[2];
    return [sign, getPosByDirection(poses, dir1), getPosByDirection(poses, dir2)];
  });
}

function isBoundRotate(relativePoses, boundDots, center, rad) {
  var nextPoses = rad ? relativePoses.map(function (pos) {
    return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.rotate)(pos, rad);
  }) : relativePoses;

  var dots = __spreadArray([center], boundDots);

  return [[nextPoses[0], nextPoses[1]], [nextPoses[1], nextPoses[3]], [nextPoses[3], nextPoses[2]], [nextPoses[2], nextPoses[0]]].some(function (line) {
    return !isSameStartLine(dots, line);
  });
}

function getDistPointLine(_a) {
  // x = 0, y = 0
  // d = (ax + by + c) / root(a2 + b2)
  var pos1 = _a[0],
      pos2 = _a[1];
  var dx = pos2[0] - pos1[0];
  var dy = pos2[1] - pos1[1];

  if (!dx) {
    return Math.abs(pos1[0]);
  }

  if (!dy) {
    return Math.abs(pos1[1]);
  } // y - y1 = a(x - x1)
  // 0 = ax -y + -a * x1 + y1


  var a = dy / dx;
  return Math.abs((-a * pos1[0] + pos1[1]) / Math.sqrt(Math.pow(a, 2) + 1));
}

function solveReverseLine(_a) {
  var pos1 = _a[0],
      pos2 = _a[1];
  var dx = pos2[0] - pos1[0];
  var dy = pos2[1] - pos1[1];

  if (!dx) {
    return [pos1[0], 0];
  }

  if (!dy) {
    return [0, pos1[1]];
  }

  var a = dy / dx; // y - y1 = a (x  - x1)
  // y = ax - a * x1 + y1

  var b = -a * pos1[0] + pos1[1]; // y = ax + b = -1/a x
  // x = -b / (a + 1 / a)
  // y = b / (1 + 1 / a^2)

  return [-b / (a + 1 / a), b / (a * a + 1)];
}

function checkRotateInnerBounds(moveable, prevPoses, nextPoses, origin, rotation) {
  var bounds = moveable.props.innerBounds;
  var rad = rotation * Math.PI / 180;

  if (!bounds) {
    return [];
  }

  var left = bounds.left,
      top = bounds.top,
      width = bounds.width,
      height = bounds.height;
  var relativeLeft = left - origin[0];
  var relativeRight = left + width - origin[0];
  var relativeTop = top - origin[1];
  var relativeBottom = top + height - origin[1];
  var dots = [[relativeLeft, relativeTop], [relativeRight, relativeTop], [relativeLeft, relativeBottom], [relativeRight, relativeBottom]];
  var center = getPosByDirection(nextPoses, [0, 0]);

  if (!isBoundRotate(nextPoses, dots, center, 0)) {
    return [];
  }

  var result = [];
  var dotInfos = dots.map(function (dot) {
    return [getDistSize(dot), (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)([0, 0], dot)];
  });
  [[nextPoses[0], nextPoses[1]], [nextPoses[1], nextPoses[3]], [nextPoses[3], nextPoses[2]], [nextPoses[2], nextPoses[0]]].forEach(function (line) {
    var lineRad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)([0, 0], solveReverseLine(line));
    var lineDist = getDistPointLine(line);
    result.push.apply(result, dotInfos.filter(function (_a) {
      var dotDist = _a[0];
      return dotDist && lineDist <= dotDist;
    }).map(function (_a) {
      var dotDist = _a[0],
          dotRad = _a[1];
      var distRad = Math.acos(dotDist ? lineDist / dotDist : 0);
      var nextRad1 = dotRad + distRad;
      var nextRad2 = dotRad - distRad;
      return [rad + nextRad1 - lineRad, rad + nextRad2 - lineRad];
    }).reduce(function (prev, cur) {
      prev.push.apply(prev, cur);
      return prev;
    }, []).filter(function (nextRad) {
      return !isBoundRotate(prevPoses, dots, center, nextRad);
    }).map(function (nextRad) {
      return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(nextRad * 180 / Math.PI, TINY_NUM);
    }));
  });
  return result;
}
function checkInnerBoundPoses(moveable) {
  var innerBounds = moveable.props.innerBounds;

  if (!innerBounds) {
    return {
      vertical: [],
      horizontal: []
    };
  }

  var _a = moveable.getRect(),
      pos1 = _a.pos1,
      pos2 = _a.pos2,
      pos3 = _a.pos3,
      pos4 = _a.pos4;

  var poses = [pos1, pos2, pos3, pos4];
  var center = getPosByDirection(poses, [0, 0]);
  var left = innerBounds.left,
      top = innerBounds.top,
      width = innerBounds.width,
      height = innerBounds.height;
  var leftLine = [[left, top], [left, top + height]];
  var topLine = [[left, top], [left + width, top]];
  var rightLine = [[left + width, top], [left + width, top + height]];
  var bottomLine = [[left, top + height], [left + width, top + height]];
  var lines = [[pos1, pos2], [pos2, pos4], [pos4, pos3], [pos3, pos1]];
  var horizontalPoses = [];
  var verticalPoses = [];
  var boundMap = {
    top: false,
    bottom: false,
    left: false,
    right: false
  };
  lines.forEach(function (line) {
    var _a = isStartLine(center, line),
        isHorizontalStart = _a.horizontal,
        isVerticalStart = _a.vertical; // test vertical


    var topBoundInfo = checkLineBoundCollision(line, topLine, isVerticalStart, 1, true);
    var bottomBoundInfo = checkLineBoundCollision(line, bottomLine, isVerticalStart, 1, true); // test horizontal

    var leftBoundInfo = checkLineBoundCollision(line, leftLine, isHorizontalStart, 1, true);
    var rightBoundInfo = checkLineBoundCollision(line, rightLine, isHorizontalStart, 1, true);

    if (topBoundInfo.isBound && !boundMap.top) {
      horizontalPoses.push(top);
      boundMap.top = true;
    }

    if (bottomBoundInfo.isBound && !boundMap.bottom) {
      horizontalPoses.push(top + height);
      boundMap.bottom = true;
    }

    if (leftBoundInfo.isBound && !boundMap.left) {
      verticalPoses.push(left);
      boundMap.left = true;
    }

    if (rightBoundInfo.isBound && !boundMap.right) {
      verticalPoses.push(left + width);
      boundMap.right = true;
    }
  });
  return {
    horizontal: horizontalPoses,
    vertical: verticalPoses
  };
}

function checkBoundPoses(bounds, verticalPoses, horizontalPoses) {
  var _a = bounds || {},
      _b = _a.position,
      position = _b === void 0 ? "client" : _b,
      _c = _a.left,
      left = _c === void 0 ? -Infinity : _c,
      _d = _a.top,
      top = _d === void 0 ? -Infinity : _d,
      _e = _a.right,
      right = _e === void 0 ? Infinity : _e,
      _f = _a.bottom,
      bottom = _f === void 0 ? Infinity : _f;

  var nextBounds = {
    position: position,
    left: left,
    top: top,
    right: right,
    bottom: bottom
  };
  return {
    vertical: checkBounds(nextBounds, verticalPoses, true),
    horizontal: checkBounds(nextBounds, horizontalPoses, false)
  };
}
function getBounds(moveable, externalBounds) {
  var _a = moveable.state,
      _b = _a.containerClientRect,
      containerHeight = _b.clientHeight,
      containerWidth = _b.clientWidth,
      clientLeft = _b.clientLeft,
      clientTop = _b.clientTop,
      _c = _a.snapOffset,
      snapOffsetLeft = _c.left,
      snapOffsetTop = _c.top,
      snapOffsetRight = _c.right,
      snapOffsetBottom = _c.bottom;
  var bounds = externalBounds || moveable.props.bounds || {};
  var position = bounds.position || "client";
  var isCSS = position === "css";
  var _d = bounds.left,
      left = _d === void 0 ? -Infinity : _d,
      _e = bounds.top,
      top = _e === void 0 ? -Infinity : _e;
  var _f = bounds.right,
      right = _f === void 0 ? isCSS ? -Infinity : Infinity : _f,
      _g = bounds.bottom,
      bottom = _g === void 0 ? isCSS ? -Infinity : Infinity : _g;

  if (isCSS) {
    right = containerWidth + snapOffsetRight - snapOffsetLeft - right;
    bottom = containerHeight + snapOffsetBottom - snapOffsetTop - bottom;
  }

  return {
    left: left + snapOffsetLeft - clientLeft,
    right: right + snapOffsetLeft - clientLeft,
    top: top + snapOffsetTop - clientTop,
    bottom: bottom + snapOffsetTop - clientTop
  };
}
function checkBoundKeepRatio(moveable, startPos, endPos) {
  var _a = getBounds(moveable),
      left = _a.left,
      top = _a.top,
      right = _a.right,
      bottom = _a.bottom;

  var endX = endPos[0],
      endY = endPos[1];

  var _b = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(endPos, startPos),
      dx = _b[0],
      dy = _b[1];

  if (Math.abs(dx) < TINY_NUM) {
    dx = 0;
  }

  if (Math.abs(dy) < TINY_NUM) {
    dy = 0;
  }

  var isBottom = dy > 0;
  var isRight = dx > 0;
  var verticalInfo = {
    isBound: false,
    offset: 0,
    pos: 0
  };
  var horizontalInfo = {
    isBound: false,
    offset: 0,
    pos: 0
  };

  if (dx === 0 && dy === 0) {
    return {
      vertical: verticalInfo,
      horizontal: horizontalInfo
    };
  } else if (dx === 0) {
    if (isBottom) {
      if (bottom < endY) {
        horizontalInfo.pos = bottom;
        horizontalInfo.offset = endY - bottom;
      }
    } else {
      if (top > endY) {
        horizontalInfo.pos = top;
        horizontalInfo.offset = endY - top;
      }
    }
  } else if (dy === 0) {
    if (isRight) {
      if (right < endX) {
        verticalInfo.pos = right;
        verticalInfo.offset = endX - right;
      }
    } else {
      if (left > endX) {
        verticalInfo.pos = left;
        verticalInfo.offset = endX - left;
      }
    }
  } else {
    // y - y1 = a * (x - x1)
    var a = dy / dx;
    var b = endPos[1] - a * endX;
    var y = 0;
    var x = 0;
    var isBound = false;

    if (isRight && right <= endX) {
      y = a * right + b;
      x = right;
      isBound = true;
    } else if (!isRight && endX <= left) {
      y = a * left + b;
      x = left;
      isBound = true;
    }

    if (isBound) {
      if (y < top || y > bottom) {
        isBound = false;
      }
    }

    if (!isBound) {
      if (isBottom && bottom <= endY) {
        y = bottom;
        x = (y - b) / a;
        isBound = true;
      } else if (!isBottom && endY <= top) {
        y = top;
        x = (y - b) / a;
        isBound = true;
      }
    }

    if (isBound) {
      verticalInfo.isBound = true;
      verticalInfo.pos = x;
      verticalInfo.offset = endX - x;
      horizontalInfo.isBound = true;
      horizontalInfo.pos = y;
      horizontalInfo.offset = endY - y;
    }
  }

  return {
    vertical: verticalInfo,
    horizontal: horizontalInfo
  };
}

function checkBounds(bounds, poses, isVertical) {
  // 0   [100 - 200]  300
  var startBoundPos = bounds[isVertical ? "left" : "top"];
  var endBoundPos = bounds[isVertical ? "right" : "bottom"]; // 450

  var minPos = Math.min.apply(Math, poses);
  var maxPos = Math.max.apply(Math, poses);
  var boundInfos = [];

  if (startBoundPos + 1 > minPos) {
    boundInfos.push({
      isBound: true,
      offset: minPos - startBoundPos,
      pos: startBoundPos
    });
  }

  if (endBoundPos - 1 < maxPos) {
    boundInfos.push({
      isBound: true,
      offset: maxPos - endBoundPos,
      pos: endBoundPos
    });
  }

  if (!boundInfos.length) {
    boundInfos.push({
      isBound: false,
      offset: 0,
      pos: 0
    });
  }

  return boundInfos.sort(function (a, b) {
    return Math.abs(b.offset) - Math.abs(a.offset);
  });
}

function isBoundRotate$1(relativePoses, boundRect, rad) {
  var nextPoses = rad ? relativePoses.map(function (pos) {
    return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.rotate)(pos, rad);
  }) : relativePoses;
  return nextPoses.some(function (pos) {
    return pos[0] < boundRect.left && Math.abs(pos[0] - boundRect.left) > 0.1 || pos[0] > boundRect.right && Math.abs(pos[0] - boundRect.right) > 0.1 || pos[1] < boundRect.top && Math.abs(pos[1] - boundRect.top) > 0.1 || pos[1] > boundRect.bottom && Math.abs(pos[1] - boundRect.bottom) > 0.1;
  });
}
function boundRotate(vec, boundPos, index) {
  var r = getDistSize(vec);
  var nextPos = Math.sqrt(r * r - boundPos * boundPos) || 0;
  return [nextPos, -nextPos].sort(function (a, b) {
    return Math.abs(a - vec[index ? 0 : 1]) - Math.abs(b - vec[index ? 0 : 1]);
  }).map(function (pos) {
    return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)([0, 0], index ? [pos, boundPos] : [boundPos, pos]);
  });
}
function checkRotateBounds(moveable, prevPoses, nextPoses, origin, rotation) {
  if (!moveable.props.bounds) {
    return [];
  }

  var rad = rotation * Math.PI / 180;

  var _a = getBounds(moveable),
      left = _a.left,
      top = _a.top,
      right = _a.right,
      bottom = _a.bottom;

  var relativeLeft = left - origin[0];
  var relativeRight = right - origin[0];
  var relativeTop = top - origin[1];
  var relativeBottom = bottom - origin[1];
  var boundRect = {
    left: relativeLeft,
    top: relativeTop,
    right: relativeRight,
    bottom: relativeBottom
  };

  if (!isBoundRotate$1(nextPoses, boundRect, 0)) {
    return [];
  }

  var result = [];
  [[relativeLeft, 0], [relativeRight, 0], [relativeTop, 1], [relativeBottom, 1]].forEach(function (_a) {
    var boundPos = _a[0],
        index = _a[1];
    nextPoses.forEach(function (nextPos) {
      var relativeRad1 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)([0, 0], nextPos);
      result.push.apply(result, boundRotate(nextPos, boundPos, index).map(function (relativeRad2) {
        return rad + relativeRad2 - relativeRad1;
      }).filter(function (nextRad) {
        return !isBoundRotate$1(prevPoses, boundRect, nextRad);
      }).map(function (nextRad) {
        return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(nextRad * 180 / Math.PI, TINY_NUM);
      }));
    });
  });
  return result;
}

function renderGuideline(info, React) {
  var _a;

  var direction = info.direction,
      classNames = info.classNames,
      size = info.size,
      pos = info.pos,
      zoom = info.zoom,
      key = info.key;
  var isHorizontal = direction === "horizontal";
  var scaleType = isHorizontal ? "Y" : "X"; // const scaleType2 = isHorizontal ? "Y" : "X";

  return React.createElement("div", {
    key: key,
    className: classNames.join(" "),
    style: (_a = {}, _a[isHorizontal ? "width" : "height"] = "" + size, _a.transform = "translate(" + pos[0] + ", " + pos[1] + ") translate" + scaleType + "(-50%) scale" + scaleType + "(" + zoom + ")", _a)
  });
}
function renderInnerGuideline(info, React) {
  return renderGuideline(__assign(__assign({}, info), {
    classNames: __spreadArray([prefix("line", "guideline", info.direction)], info.classNames).filter(function (className) {
      return className;
    }),
    size: info.size || info.sizeValue + "px",
    pos: info.pos || info.posValue.map(function (v) {
      return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(v, 0.1) + "px";
    })
  }), React);
}
function renderSnapPoses(moveable, direction, snapPoses, minPos, targetPos, size, index, React) {
  var zoom = moveable.props.zoom;
  return snapPoses.map(function (_a, i) {
    var type = _a.type,
        pos = _a.pos;
    var renderPos = [0, 0];
    renderPos[index] = minPos;
    renderPos[index ? 0 : 1] = -targetPos + pos;
    return renderInnerGuideline({
      key: direction + "TargetGuideline" + i,
      classNames: [prefix("target", "bold", type)],
      posValue: renderPos,
      sizeValue: size,
      zoom: zoom,
      direction: direction
    }, React);
  });
}
function renderGuidelines(moveable, type, guidelines, targetPos, targetRect, React) {
  var _a = moveable.props,
      zoom = _a.zoom,
      isDisplayInnerSnapDigit = _a.isDisplayInnerSnapDigit;
  var mainNames = type === "horizontal" ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;
  var targetStart = targetRect[mainNames.start];
  var targetEnd = targetRect[mainNames.end];
  return guidelines.filter(function (_a) {
    var hide = _a.hide,
        elementRect = _a.elementRect;

    if (hide) {
      return false;
    }

    if (isDisplayInnerSnapDigit && elementRect) {
      // inner
      var rect = elementRect.rect;

      if (rect[mainNames.start] <= targetStart && targetEnd <= rect[mainNames.end]) {
        return false;
      }
    }

    return true;
  }).map(function (guideline, i) {
    var pos = guideline.pos,
        size = guideline.size,
        element = guideline.element;
    var renderPos = [-targetPos[0] + pos[0], -targetPos[1] + pos[1]];
    return renderInnerGuideline({
      key: type + "-default-guideline-" + i,
      classNames: element ? [prefix("bold")] : [],
      direction: type,
      posValue: renderPos,
      sizeValue: size,
      zoom: zoom
    }, React);
  });
}
function renderDigitLine(moveable, type, lineType, index, gap, renderPos, className, React) {
  var _a;

  var _b = moveable.props,
      _c = _b.snapDigit,
      snapDigit = _c === void 0 ? 0 : _c,
      _d = _b.isDisplaySnapDigit,
      isDisplaySnapDigit = _d === void 0 ? true : _d,
      _e = _b.snapDistFormat,
      snapDistFormat = _e === void 0 ? function (v) {
    return v;
  } : _e,
      zoom = _b.zoom;
  var scaleType = type === "horizontal" ? "X" : "Y";
  var sizeName = type === "vertical" ? "height" : "width";
  var absGap = Math.abs(gap);
  var snapSize = isDisplaySnapDigit ? parseFloat(absGap.toFixed(snapDigit)) : 0;
  return React.createElement("div", {
    key: type + "-" + lineType + "-guideline-" + index,
    className: prefix("guideline-group", type),
    style: (_a = {
      left: renderPos[0] + "px",
      top: renderPos[1] + "px"
    }, _a[sizeName] = absGap + "px", _a)
  }, renderInnerGuideline({
    direction: type,
    classNames: [prefix(lineType), className],
    size: "100%",
    posValue: [0, 0],
    sizeValue: absGap,
    zoom: zoom
  }, React), React.createElement("div", {
    className: prefix("size-value", "gap"),
    style: {
      transform: "translate" + scaleType + "(-50%) scale(" + zoom + ")"
    }
  }, snapSize > 0 ? snapDistFormat(snapSize) : ""));
}
function groupByElementGuidelines(type, guidelines, targetRect, isDisplayInnerSnapDigit) {
  var index = type === "vertical" ? 0 : 1;
  var otherIndex = type === "vertical" ? 1 : 0;
  var names = index ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;
  var targetStart = targetRect[names.start];
  var targetEnd = targetRect[names.end];
  return groupBy(guidelines, function (guideline) {
    return guideline.pos[index];
  }).map(function (nextGuidelines) {
    var start = [];
    var end = [];
    var inner = [];
    nextGuidelines.forEach(function (guideline) {
      var _a, _b;

      var element = guideline.element;
      var rect = guideline.elementRect.rect;

      if (rect[names.end] < targetStart) {
        start.push(guideline);
      } else if (targetEnd < rect[names.start]) {
        end.push(guideline);
      } else if (rect[names.start] <= targetStart && targetEnd <= rect[names.end] && isDisplayInnerSnapDigit) {
        var pos = guideline.pos;
        var elementRect1 = {
          element: element,
          rect: __assign(__assign({}, rect), (_a = {}, _a[names.end] = rect[names.start], _a))
        };
        var elementRect2 = {
          element: element,
          rect: __assign(__assign({}, rect), (_b = {}, _b[names.start] = rect[names.end], _b))
        };
        var nextPos1 = [0, 0];
        var nextPos2 = [0, 0];
        nextPos1[index] = pos[index];
        nextPos1[otherIndex] = pos[otherIndex];
        nextPos2[index] = pos[index];
        nextPos2[otherIndex] = pos[otherIndex] + guideline.size;
        start.push({
          type: type,
          pos: nextPos1,
          size: 0,
          elementRect: elementRect1
        });
        end.push({
          type: type,
          pos: nextPos2,
          size: 0,
          elementRect: elementRect2
        }); // inner.push(guideline);
      }
    });
    start.sort(function (a, b) {
      return b.pos[otherIndex] - a.pos[otherIndex];
    });
    end.sort(function (a, b) {
      return a.pos[otherIndex] - b.pos[otherIndex];
    });
    return {
      total: nextGuidelines,
      start: start,
      end: end,
      inner: inner
    };
  });
}
function renderDashedGuidelines(moveable, guidelines, targetPos, targetRect, React) {
  var isDisplayInnerSnapDigit = moveable.props.isDisplayInnerSnapDigit;
  var rendered = [];
  ["vertical", "horizontal"].forEach(function (type) {
    var nextGuidelines = guidelines.filter(function (guideline) {
      return guideline.type === type;
    });
    var index = type === "vertical" ? 1 : 0;
    var otherIndex = index ? 0 : 1;
    var groups = groupByElementGuidelines(type, nextGuidelines, targetRect, isDisplayInnerSnapDigit);
    var mainNames = index ? HORIZONTAL_NAMES_MAP : VERTICAL_NAMES_MAP;
    var sideNames = index ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;
    var targetStart = targetRect[mainNames.start];
    var targetEnd = targetRect[mainNames.end];
    groups.forEach(function (_a) {
      var total = _a.total,
          start = _a.start,
          end = _a.end,
          inner = _a.inner;
      var sidePos = targetPos[otherIndex] + total[0].pos[otherIndex] - targetRect[sideNames.start];
      var prevRect = targetRect;
      start.forEach(function (guideline) {
        var nextRect = guideline.elementRect.rect;
        var size = prevRect[mainNames.start] - nextRect[mainNames.end];

        if (size > 0) {
          var renderPos = [0, 0];
          renderPos[index] = targetPos[index] + prevRect[mainNames.start] - targetStart - size;
          renderPos[otherIndex] = sidePos;
          rendered.push(renderDigitLine(moveable, type, "dashed", rendered.length, size, renderPos, guideline.className, React));
        }

        prevRect = nextRect;
      });
      prevRect = targetRect;
      end.forEach(function (guideline) {
        var nextRect = guideline.elementRect.rect;
        var size = nextRect[mainNames.start] - prevRect[mainNames.end];

        if (size > 0) {
          var renderPos = [0, 0];
          renderPos[index] = targetPos[index] + prevRect[mainNames.end] - targetStart;
          renderPos[otherIndex] = sidePos;
          rendered.push(renderDigitLine(moveable, type, "dashed", rendered.length, size, renderPos, guideline.className, React));
        }

        prevRect = nextRect;
      });
      inner.forEach(function (guideline) {
        var nextRect = guideline.elementRect.rect;
        var size1 = targetStart - nextRect[mainNames.start];
        var size2 = nextRect[mainNames.end] - targetEnd;
        var renderPos1 = [0, 0];
        var renderPos2 = [0, 0];
        renderPos1[index] = targetPos[index] - size1;
        renderPos1[otherIndex] = sidePos;
        renderPos2[index] = targetPos[index] + targetEnd - targetStart;
        renderPos2[otherIndex] = sidePos;
        rendered.push(renderDigitLine(moveable, type, "dashed", rendered.length, size1, renderPos1, guideline.className, React));
        rendered.push(renderDigitLine(moveable, type, "dashed", rendered.length, size2, renderPos2, guideline.className, React));
      });
    });
  });
  return rendered;
}
function renderGapGuidelines(moveable, guidelines, targetPos, targetRect, React) {
  var rendered = [];
  ["horizontal", "vertical"].forEach(function (type) {
    var nextGuidelines = guidelines.filter(function (guideline) {
      return guideline.type === type;
    });
    var index = type === "vertical" ? 0 : 1;
    var otherIndex = index ? 0 : 1;
    var mainNames = index ? HORIZONTAL_NAMES_MAP : VERTICAL_NAMES_MAP;
    var sideNames = index ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;
    var targetStart = targetRect[mainNames.start];
    var targetEnd = targetRect[mainNames.end];
    var targetSideStart = targetRect[sideNames.start];
    var targetSideEnd = targetRect[sideNames.end];
    nextGuidelines.forEach(function (_a) {
      var gap = _a.gap,
          gapRects = _a.gapRects,
          className = _a.className;
      var sideStartPos = Math.max.apply(Math, __spreadArray([targetSideStart], gapRects.map(function (_a) {
        var rect = _a.rect;
        return rect[sideNames.start];
      })));
      var sideEndPos = Math.min.apply(Math, __spreadArray([targetSideEnd], gapRects.map(function (_a) {
        var rect = _a.rect;
        return rect[sideNames.end];
      })));
      var sideCenterPos = (sideStartPos + sideEndPos) / 2;

      if (sideStartPos === sideEndPos || sideCenterPos === (targetSideStart + targetSideEnd) / 2) {
        return;
      }

      gapRects.forEach(function (_a) {
        var rect = _a.rect;
        var renderPos = [targetPos[0], targetPos[1]];

        if (rect[mainNames.end] < targetStart) {
          renderPos[index] += rect[mainNames.end] - targetStart;
        } else if (targetEnd < rect[mainNames.start]) {
          renderPos[index] += rect[mainNames.start] - targetStart - gap;
        } else {
          return;
        }

        renderPos[otherIndex] += sideCenterPos - targetSideStart;
        rendered.push(renderDigitLine(moveable, index ? "vertical" : "horizontal", "gap", rendered.length, gap, renderPos, className, React));
      });
    });
  });
  return rendered;
}

function solveEquation(pos1, pos2, snapOffset, isVertical) {
  var dx = pos2[0] - pos1[0];
  var dy = pos2[1] - pos1[1];

  if (Math.abs(dx) < _daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.TINY_NUM) {
    dx = 0;
  }

  if (Math.abs(dy) < _daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.TINY_NUM) {
    dy = 0;
  }

  if (!dx) {
    // y = 0 * x + b
    // only horizontal
    if (!isVertical) {
      return [0, snapOffset];
    }

    return [0, 0];
  }

  if (!dy) {
    // only vertical
    if (isVertical) {
      return [snapOffset, 0];
    }

    return [0, 0];
  } // y = ax + b


  var a = dy / dx;
  var b = pos1[1] - a * pos1[0];

  if (isVertical) {
    // y = a * x + b
    var y = a * (pos2[0] + snapOffset) + b;
    return [snapOffset, y - pos2[1]];
  } else {
    // x = (y - b) / a
    var x = (pos2[1] + snapOffset - b) / a;
    return [x - pos2[0], snapOffset];
  }
}

function solveNextOffset(pos1, pos2, offset, isVertical, datas) {
  var sizeOffset = solveEquation(pos1, pos2, offset, isVertical);

  if (!sizeOffset) {
    return {
      isOutside: false,
      offset: [0, 0]
    };
  }

  var size = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getDist)(pos1, pos2);
  var dist1 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getDist)(sizeOffset, pos1);
  var dist2 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getDist)(sizeOffset, pos2);
  var isOutside = dist1 > size || dist2 > size;

  var _a = getDragDist({
    datas: datas,
    distX: sizeOffset[0],
    distY: sizeOffset[1]
  }),
      widthOffset = _a[0],
      heightOffset = _a[1];

  return {
    offset: [widthOffset, heightOffset],
    isOutside: isOutside
  };
}

function getSnapBound(boundInfo, snapInfo) {
  if (boundInfo.isBound) {
    return boundInfo.offset;
  } else if (snapInfo.isSnap) {
    return getNearestSnapGuidelineInfo(snapInfo).offset;
  }

  return 0;
}

function checkThrottleDragRotate(throttleDragRotate, _a, _b, _c, _d) {
  var distX = _a[0],
      distY = _a[1];
  var isVerticalBound = _b[0],
      isHorizontalBound = _b[1];
  var isVerticalSnap = _c[0],
      isHorizontalSnap = _c[1];
  var verticalOffset = _d[0],
      horizontalOffset = _d[1];
  var offsetX = -verticalOffset;
  var offsetY = -horizontalOffset;

  if (throttleDragRotate && distX && distY) {
    offsetX = 0;
    offsetY = 0;
    var adjustPoses = [];

    if (isVerticalBound && isHorizontalBound) {
      adjustPoses.push([0, horizontalOffset], [verticalOffset, 0]);
    } else if (isVerticalBound) {
      adjustPoses.push([verticalOffset, 0]);
    } else if (isHorizontalBound) {
      adjustPoses.push([0, horizontalOffset]);
    } else if (isVerticalSnap && isHorizontalSnap) {
      adjustPoses.push([0, horizontalOffset], [verticalOffset, 0]);
    } else if (isVerticalSnap) {
      adjustPoses.push([verticalOffset, 0]);
    } else if (isHorizontalSnap) {
      adjustPoses.push([0, horizontalOffset]);
    }

    if (adjustPoses.length) {
      adjustPoses.sort(function (a, b) {
        return getDistSize((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)([distX, distY], a)) - getDistSize((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)([distX, distY], b));
      });
      var adjustPos = adjustPoses[0];

      if (adjustPos[0] && Math.abs(distX) > _daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.TINY_NUM) {
        offsetX = -adjustPos[0];
        offsetY = distY * Math.abs(distX + offsetX) / Math.abs(distX) - distY;
      } else if (adjustPos[1] && Math.abs(distY) > _daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.TINY_NUM) {
        var prevDistY = distY;
        offsetY = -adjustPos[1];
        offsetX = distX * Math.abs(distY + offsetY) / Math.abs(prevDistY) - distX;
      }

      if (throttleDragRotate && isHorizontalBound && isVerticalBound) {
        if (Math.abs(offsetX) > _daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.TINY_NUM && Math.abs(offsetX) < Math.abs(verticalOffset)) {
          var scale = Math.abs(verticalOffset) / Math.abs(offsetX);
          offsetX *= scale;
          offsetY *= scale;
        } else if (Math.abs(offsetY) > _daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.TINY_NUM && Math.abs(offsetY) < Math.abs(horizontalOffset)) {
          var scale = Math.abs(horizontalOffset) / Math.abs(offsetY);
          offsetX *= scale;
          offsetY *= scale;
        } else {
          offsetX = maxOffset(-verticalOffset, offsetX);
          offsetY = maxOffset(-horizontalOffset, offsetY);
        }
      }
    }
  } else {
    offsetX = distX || isVerticalBound ? -verticalOffset : 0;
    offsetY = distY || isHorizontalBound ? -horizontalOffset : 0;
  }

  return [offsetX, offsetY];
}
function checkSnapBoundsDrag(moveable, distX, distY, throttleDragRotate, isRequest, datas) {
  if (!hasGuidelines(moveable, "draggable")) {
    return [{
      isSnap: false,
      isBound: false,
      offset: 0
    }, {
      isSnap: false,
      isBound: false,
      offset: 0
    }];
  }

  var poses = getAbsolutePoses(datas.absolutePoses, [distX, distY]);

  var _a = getRect(poses),
      left = _a.left,
      right = _a.right,
      top = _a.top,
      bottom = _a.bottom;

  var boundPoses = {
    horizontal: poses.map(function (pos) {
      return pos[1];
    }),
    vertical: poses.map(function (pos) {
      return pos[0];
    })
  };
  var snapDirections = getSnapDirections(moveable.props.snapDirections);
  var snapPoses = splitSnapDirectionPoses(snapDirections, {
    left: left,
    right: right,
    top: top,
    bottom: bottom,
    center: (left + right) / 2,
    middle: (top + bottom) / 2
  });

  var _b = checkMoveableSnapBounds(moveable, isRequest, snapPoses, boundPoses),
      verticalSnapBoundInfo = _b.vertical,
      horizontalSnapBoundInfo = _b.horizontal;

  var _c = getInnerBoundDragInfo(moveable, poses, datas),
      verticalInnerBoundInfo = _c.vertical,
      horizontalInnerBoundInfo = _c.horizontal;

  var isVerticalSnap = verticalSnapBoundInfo.isSnap;
  var isHorizontalSnap = horizontalSnapBoundInfo.isSnap;
  var isVerticalBound = verticalSnapBoundInfo.isBound || verticalInnerBoundInfo.isBound;
  var isHorizontalBound = horizontalSnapBoundInfo.isBound || horizontalInnerBoundInfo.isBound;
  var verticalOffset = maxOffset(verticalSnapBoundInfo.offset, verticalInnerBoundInfo.offset);
  var horizontalOffset = maxOffset(horizontalSnapBoundInfo.offset, horizontalInnerBoundInfo.offset);

  var _d = checkThrottleDragRotate(throttleDragRotate, [distX, distY], [isVerticalBound, isHorizontalBound], [isVerticalSnap, isHorizontalSnap], [verticalOffset, horizontalOffset]),
      offsetX = _d[0],
      offsetY = _d[1];

  return [{
    isBound: isVerticalBound,
    isSnap: isVerticalSnap,
    offset: offsetX
  }, {
    isBound: isHorizontalBound,
    isSnap: isHorizontalSnap,
    offset: offsetY
  }];
}
function checkMoveableSnapBounds(moveable, isRequest, poses, boundPoses) {
  if (boundPoses === void 0) {
    boundPoses = poses;
  }

  var _a = checkBoundPoses(getBounds(moveable), boundPoses.vertical, boundPoses.horizontal),
      horizontalBoundInfos = _a.horizontal,
      verticalBoundInfos = _a.vertical;

  var _b = isRequest ? {
    horizontal: {
      isSnap: false,
      index: -1
    },
    vertical: {
      isSnap: false,
      index: -1
    }
  } : checkMoveableSnapPoses(moveable, poses.vertical, poses.horizontal),
      horizontalSnapInfo = _b.horizontal,
      verticalSnapInfo = _b.vertical;

  var horizontalOffset = getSnapBound(horizontalBoundInfos[0], horizontalSnapInfo);
  var verticalOffset = getSnapBound(verticalBoundInfos[0], verticalSnapInfo);
  var horizontalDist = Math.abs(horizontalOffset);
  var verticalDist = Math.abs(verticalOffset);
  return {
    horizontal: {
      isBound: horizontalBoundInfos[0].isBound,
      isSnap: horizontalSnapInfo.isSnap,
      snapIndex: horizontalSnapInfo.index,
      offset: horizontalOffset,
      dist: horizontalDist,
      bounds: horizontalBoundInfos,
      snap: horizontalSnapInfo
    },
    vertical: {
      isBound: verticalBoundInfos[0].isBound,
      isSnap: verticalSnapInfo.isSnap,
      snapIndex: verticalSnapInfo.index,
      offset: verticalOffset,
      dist: verticalDist,
      bounds: verticalBoundInfos,
      snap: verticalSnapInfo
    }
  };
}
function checkSnapBounds(guideines, bounds, posesX, posesY, snapThreshold) {
  var _a = checkBoundPoses(bounds, posesX, posesY),
      horizontalBoundInfos = _a.horizontal,
      verticalBoundInfos = _a.vertical; // options.isRequest ? {
  //     horizontal: { isSnap: false, index: -1 } as SnapInfo,
  //     vertical: { isSnap: false, index: -1 } as SnapInfo,
  // } :


  var _b = checkSnapPoses(guideines, posesX, posesY, snapThreshold),
      horizontalSnapInfo = _b.horizontal,
      verticalSnapInfo = _b.vertical;

  var horizontalOffset = getSnapBound(horizontalBoundInfos[0], horizontalSnapInfo);
  var verticalOffset = getSnapBound(verticalBoundInfos[0], verticalSnapInfo);
  var horizontalDist = Math.abs(horizontalOffset);
  var verticalDist = Math.abs(verticalOffset);
  return {
    horizontal: {
      isBound: horizontalBoundInfos[0].isBound,
      isSnap: horizontalSnapInfo.isSnap,
      snapIndex: horizontalSnapInfo.index,
      offset: horizontalOffset,
      dist: horizontalDist,
      bounds: horizontalBoundInfos,
      snap: horizontalSnapInfo
    },
    vertical: {
      isBound: verticalBoundInfos[0].isBound,
      isSnap: verticalSnapInfo.isSnap,
      snapIndex: verticalSnapInfo.index,
      offset: verticalOffset,
      dist: verticalDist,
      bounds: verticalBoundInfos,
      snap: verticalSnapInfo
    }
  };
}

function checkSnapRightLine(startPos, endPos, snapBoundInfo, keepRatio) {
  var rad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)(startPos, endPos) / Math.PI * 180;
  var _a = snapBoundInfo.vertical,
      isVerticalBound = _a.isBound,
      isVerticalSnap = _a.isSnap,
      verticalDist = _a.dist,
      _b = snapBoundInfo.horizontal,
      isHorizontalBound = _b.isBound,
      isHorizontalSnap = _b.isSnap,
      horizontalDist = _b.dist;
  var rad180 = rad % 180;
  var isHorizontalLine = rad180 < 3 || rad180 > 177;
  var isVerticalLine = rad180 > 87 && rad180 < 93;

  if (horizontalDist < verticalDist) {
    if (isVerticalBound || isVerticalSnap && !isVerticalLine && (!keepRatio || !isHorizontalLine)) {
      return "vertical";
    }
  }

  if (isHorizontalBound || isHorizontalSnap && !isHorizontalLine && (!keepRatio || !isVerticalLine)) {
    return "horizontal";
  }

  return "";
}

function getSnapBoundInfo(moveable, poses, directions, keepRatio, isRequest, datas) {
  return directions.map(function (_a) {
    var startDirection = _a[0],
        endDirection = _a[1];
    var otherStartPos = getPosByDirection(poses, startDirection);
    var otherEndPos = getPosByDirection(poses, endDirection);
    var snapBoundInfo = keepRatio ? checkSnapBoundsKeepRatio(moveable, otherStartPos, otherEndPos, isRequest) : checkMoveableSnapBounds(moveable, isRequest, {
      vertical: [otherEndPos[0]],
      horizontal: [otherEndPos[1]]
    });
    var _b = snapBoundInfo.horizontal,
        // dist: otherHorizontalDist,
    otherHorizontalOffset = _b.offset,
        isOtherHorizontalBound = _b.isBound,
        isOtherHorizontalSnap = _b.isSnap,
        _c = snapBoundInfo.vertical,
        // dist: otherVerticalDist,
    otherVerticalOffset = _c.offset,
        isOtherVerticalBound = _c.isBound,
        isOtherVerticalSnap = _c.isSnap;
    var multiple = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(endDirection, startDirection);

    if (!otherVerticalOffset && !otherHorizontalOffset) {
      return {
        isBound: isOtherVerticalBound || isOtherHorizontalBound,
        isSnap: isOtherVerticalSnap || isOtherHorizontalSnap,
        sign: multiple,
        offset: [0, 0]
      };
    }

    var snapLine = checkSnapRightLine(otherStartPos, otherEndPos, snapBoundInfo, keepRatio);

    if (!snapLine) {
      return {
        sign: multiple,
        isBound: false,
        isSnap: false,
        offset: [0, 0]
      };
    }

    var isVertical = snapLine === "vertical";
    var sizeOffset = solveNextOffset(otherStartPos, otherEndPos, -(isVertical ? otherVerticalOffset : otherHorizontalOffset), isVertical, datas).offset.map(function (size, i) {
      return size * (multiple[i] ? 2 / multiple[i] : 0);
    });
    return {
      sign: multiple,
      isBound: isVertical ? isOtherVerticalBound : isOtherHorizontalBound,
      isSnap: isVertical ? isOtherVerticalSnap : isOtherHorizontalSnap,
      offset: sizeOffset
    };
  });
}

function getSnapBoundOffset(boundInfo, snapInfo) {
  if (boundInfo.isBound) {
    return boundInfo.offset;
  } else if (snapInfo.isSnap) {
    return snapInfo.offset;
  }

  return 0;
}

function checkSnapBoundsKeepRatio(moveable, startPos, endPos, isRequest) {
  var _a = checkBoundKeepRatio(moveable, startPos, endPos),
      horizontalBoundInfo = _a.horizontal,
      verticalBoundInfo = _a.vertical;

  var _b = isRequest ? {
    horizontal: {
      isSnap: false
    },
    vertical: {
      isSnap: false
    }
  } : checkSnapKeepRatio(moveable, startPos, endPos),
      horizontalSnapInfo = _b.horizontal,
      verticalSnapInfo = _b.vertical;

  var horizontalOffset = getSnapBoundOffset(horizontalBoundInfo, horizontalSnapInfo);
  var verticalOffset = getSnapBoundOffset(verticalBoundInfo, verticalSnapInfo);
  var horizontalDist = Math.abs(horizontalOffset);
  var verticalDist = Math.abs(verticalOffset);
  return {
    horizontal: {
      isBound: horizontalBoundInfo.isBound,
      isSnap: horizontalSnapInfo.isSnap,
      offset: horizontalOffset,
      dist: horizontalDist
    },
    vertical: {
      isBound: verticalBoundInfo.isBound,
      isSnap: verticalSnapInfo.isSnap,
      offset: verticalOffset,
      dist: verticalDist
    }
  };
}
function checkMaxBounds(moveable, poses, direction, fixedPosition, datas) {
  var fixedDirection = [-direction[0], -direction[1]];
  var _a = moveable.state,
      width = _a.width,
      height = _a.height;
  var bounds = moveable.props.bounds;
  var maxWidth = Infinity;
  var maxHeight = Infinity;

  if (bounds) {
    var directions = [[direction[0], -direction[1]], [-direction[0], direction[1]]];
    var _b = bounds.left,
        left_1 = _b === void 0 ? -Infinity : _b,
        _c = bounds.top,
        top_1 = _c === void 0 ? -Infinity : _c,
        _d = bounds.right,
        right_1 = _d === void 0 ? Infinity : _d,
        _e = bounds.bottom,
        bottom_1 = _e === void 0 ? Infinity : _e;
    directions.forEach(function (otherDirection) {
      var isCheckVertical = otherDirection[0] !== fixedDirection[0];
      var isCheckHorizontal = otherDirection[1] !== fixedDirection[1];
      var otherPos = getPosByDirection(poses, otherDirection);
      var deg = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)(fixedPosition, otherPos) * 360 / Math.PI;

      if (isCheckHorizontal) {
        var nextOtherPos = otherPos.slice();

        if (Math.abs(deg - 360) < 2 || Math.abs(deg - 180) < 2) {
          nextOtherPos[1] = fixedPosition[1];
        }

        var _a = solveNextOffset(fixedPosition, nextOtherPos, (fixedPosition[1] < otherPos[1] ? bottom_1 : top_1) - otherPos[1], false, datas),
            _b = _a.offset,
            heightOffset = _b[1],
            isHeightOutside = _a.isOutside;

        if (!isNaN(heightOffset)) {
          maxHeight = height + (isHeightOutside ? 1 : -1) * Math.abs(heightOffset);
        }
      }

      if (isCheckVertical) {
        var nextOtherPos = otherPos.slice();

        if (Math.abs(deg - 90) < 2 || Math.abs(deg - 270) < 2) {
          nextOtherPos[0] = fixedPosition[0];
        }

        var _c = solveNextOffset(fixedPosition, nextOtherPos, (fixedPosition[0] < otherPos[0] ? right_1 : left_1) - otherPos[0], true, datas),
            widthOffset = _c.offset[0],
            isWidthOutside = _c.isOutside;

        if (!isNaN(widthOffset)) {
          maxWidth = width + (isWidthOutside ? 1 : -1) * Math.abs(widthOffset);
        }
      }
    });
  }

  return {
    maxWidth: maxWidth,
    maxHeight: maxHeight
  };
}

function snapStart(moveable) {
  var state = moveable.state;

  if (state.guidelines && state.guidelines.length) {
    return;
  }

  var container = moveable.state.container;
  var snapContainer = moveable.props.snapContainer || container;
  var containerClientRect = state.containerClientRect;
  var snapOffset = {
    left: 0,
    top: 0,
    bottom: 0,
    right: 0
  };

  if (container !== snapContainer) {
    var snapContainerTarget = getRefTarget(snapContainer, true);

    if (snapContainerTarget) {
      var snapContainerRect = getClientRect(snapContainerTarget);
      var offset1 = getDragDistByState(state, [snapContainerRect.left - containerClientRect.left, snapContainerRect.top - containerClientRect.top]);
      var offset2 = getDragDistByState(state, [snapContainerRect.right - containerClientRect.right, snapContainerRect.bottom - containerClientRect.bottom]);
      snapOffset.left = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(offset1[0], 0.1);
      snapOffset.top = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(offset1[1], 0.1);
      snapOffset.right = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(offset2[0], 0.1);
      snapOffset.bottom = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(offset2[1], 0.1);
    }
  }

  state.snapOffset = snapOffset;
  state.guidelines = getTotalGuidelines(moveable);
  state.enableSnap = true;
}

function getNextFixedPoses(matrix, width, height, fixedPos, direction, is3d) {
  var nextPoses = calculatePoses(matrix, width, height, is3d ? 4 : 3);
  var nextPos = getPosByReverseDirection(nextPoses, direction);
  return getAbsolutePoses(nextPoses, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(fixedPos, nextPos));
}
function getSizeOffsetInfo(moveable, poses, direction, keepRatio, isRequest, datas) {
  var directions = getCheckSnapDirections(direction, keepRatio);
  var lines = getCheckInnerBoundLines(poses, direction, keepRatio);

  var offsets = __spreadArray(__spreadArray([], getSnapBoundInfo(moveable, poses, directions, keepRatio, isRequest, datas)), getInnerBoundInfo(moveable, lines, getPosByDirection(poses, [0, 0]), datas));

  var widthOffsetInfo = getNearOffsetInfo(offsets, 0);
  var heightOffsetInfo = getNearOffsetInfo(offsets, 1);
  return {
    width: {
      isBound: widthOffsetInfo.isBound,
      offset: widthOffsetInfo.offset[0]
    },
    height: {
      isBound: heightOffsetInfo.isBound,
      offset: heightOffsetInfo.offset[1]
    }
  };
}
function recheckSizeByTwoDirection(moveable, poses, width, height, maxWidth, maxHeight, direction, isRequest, datas) {
  var snapPos = getPosByDirection(poses, direction);

  var _a = checkMoveableSnapBounds(moveable, isRequest, {
    vertical: [snapPos[0]],
    horizontal: [snapPos[1]]
  }),
      horizontalOffset = _a.horizontal.offset,
      verticalOffset = _a.vertical.offset;

  if (verticalOffset || horizontalOffset) {
    var _b = getDragDist({
      datas: datas,
      distX: -verticalOffset,
      distY: -horizontalOffset
    }),
        nextWidthOffset = _b[0],
        nextHeightOffset = _b[1];

    var nextWidth = Math.min(maxWidth || Infinity, width + direction[0] * nextWidthOffset);
    var nextHeight = Math.min(maxHeight || Infinity, height + direction[1] * nextHeightOffset);
    return [nextWidth - width, nextHeight - height];
  }

  return [0, 0];
}
function checkSizeDist(moveable, getNextPoses, width, height, direction, fixedPosition, isRequest, datas) {
  var poses = getAbsolutePosesByState(moveable.state);
  var keepRatio = moveable.props.keepRatio;
  var widthOffset = 0;
  var heightOffset = 0;

  for (var i = 0; i < 2; ++i) {
    var nextPoses = getNextPoses(widthOffset, heightOffset);

    var _a = getSizeOffsetInfo(moveable, nextPoses, direction, keepRatio, isRequest, datas),
        widthOffsetInfo = _a.width,
        heightOffsetInfo = _a.height;

    var isWidthBound = widthOffsetInfo.isBound;
    var isHeightBound = heightOffsetInfo.isBound;
    var nextWidthOffset = widthOffsetInfo.offset;
    var nextHeightOffset = heightOffsetInfo.offset;

    if (i === 1) {
      if (!isWidthBound) {
        nextWidthOffset = 0;
      }

      if (!isHeightBound) {
        nextHeightOffset = 0;
      }
    }

    if (i === 0 && isRequest && !isWidthBound && !isHeightBound) {
      return [0, 0];
    }

    if (keepRatio) {
      var widthDist = Math.abs(nextWidthOffset) * (width ? 1 / width : 1);
      var heightDist = Math.abs(nextHeightOffset) * (height ? 1 / height : 1);
      var isGetWidthOffset = isWidthBound && isHeightBound ? widthDist < heightDist : isHeightBound || !isWidthBound && widthDist < heightDist;

      if (isGetWidthOffset) {
        // width : height = ? : heightOffset
        nextWidthOffset = width * nextHeightOffset / height;
      } else {
        // width : height = widthOffset : ?
        nextHeightOffset = height * nextWidthOffset / width;
      }
    }

    widthOffset += nextWidthOffset;
    heightOffset += nextHeightOffset;
  }

  if (direction[0] && direction[1]) {
    var _b = checkMaxBounds(moveable, poses, direction, fixedPosition, datas),
        maxWidth = _b.maxWidth,
        maxHeight = _b.maxHeight;

    var _c = recheckSizeByTwoDirection(moveable, getNextPoses(widthOffset, heightOffset).map(function (pos) {
      return pos.map(function (p) {
        return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(p, FLOAT_POINT_NUM);
      });
    }), width + widthOffset, height + heightOffset, maxWidth, maxHeight, direction, isRequest, datas),
        nextWidthOffset = _c[0],
        nextHeightOffset = _c[1];

    widthOffset += nextWidthOffset;
    heightOffset += nextHeightOffset;
  }

  return [widthOffset, heightOffset];
}
function checkSnapRotate(moveable, rect, origin, rotation) {
  if (!hasGuidelines(moveable, "rotatable")) {
    return rotation;
  }

  var pos1 = rect.pos1,
      pos2 = rect.pos2,
      pos3 = rect.pos3,
      pos4 = rect.pos4;
  var rad = rotation * Math.PI / 180;
  var prevPoses = [pos1, pos2, pos3, pos4].map(function (pos) {
    return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(pos, origin);
  });
  var nextPoses = prevPoses.map(function (pos) {
    return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.rotate)(pos, rad);
  });

  var result = __spreadArray(__spreadArray([], checkRotateBounds(moveable, prevPoses, nextPoses, origin, rotation)), checkRotateInnerBounds(moveable, prevPoses, nextPoses, origin, rotation));

  result.sort(function (a, b) {
    return Math.abs(a - rotation) - Math.abs(b - rotation);
  });

  if (result.length) {
    return result[0];
  } else {
    return rotation;
  }
}
function checkSnapResize(moveable, width, height, direction, fixedPosition, isRequest, datas) {
  if (!hasGuidelines(moveable, "resizable")) {
    return [0, 0];
  }

  var _a = moveable.state,
      allMatrix = _a.allMatrix,
      is3d = _a.is3d;
  return checkSizeDist(moveable, function (widthOffset, heightOffset) {
    return getNextFixedPoses(allMatrix, width + widthOffset, height + heightOffset, fixedPosition, direction, is3d);
  }, width, height, direction, fixedPosition, isRequest, datas);
}
function checkSnapScale(moveable, scale, direction, isRequest, datas) {
  var width = datas.width,
      height = datas.height,
      fixedPosition = datas.fixedPosition;

  if (!hasGuidelines(moveable, "scalable")) {
    return [0, 0];
  }

  var is3d = datas.is3d;
  var sizeDist = checkSizeDist(moveable, function (widthOffset, heightOffset) {
    return getNextFixedPoses(scaleMatrix(datas, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(scale, [widthOffset / width, heightOffset / height])), width, height, fixedPosition, direction, is3d);
  }, width, height, direction, fixedPosition, isRequest, datas);
  return [sizeDist[0] / width, sizeDist[1] / height];
}
function startCheckSnapDrag(moveable, datas) {
  datas.absolutePoses = getAbsolutePosesByState(moveable.state);
}

function getSnapGuidelines(posInfos) {
  var guidelines = [];
  posInfos.forEach(function (posInfo) {
    posInfo.guidelineInfos.forEach(function (_a) {
      var guideline = _a.guideline;

      if (guidelines.indexOf(guideline) > -1) {
        return;
      }

      guidelines.push(guideline);
    });
  });
  return guidelines;
}

function addBoundGuidelines(moveable, verticalPoses, horizontalPoses, verticalSnapPoses, horizontalSnapPoses, externalBounds) {
  var _a = checkBoundPoses(getBounds(moveable, externalBounds), verticalPoses, horizontalPoses),
      verticalBoundInfos = _a.vertical,
      horizontalBoundInfos = _a.horizontal;

  verticalBoundInfos.forEach(function (info) {
    if (info.isBound) {
      verticalSnapPoses.push({
        type: "bounds",
        pos: info.pos
      });
    }
  });
  horizontalBoundInfos.forEach(function (info) {
    if (info.isBound) {
      horizontalSnapPoses.push({
        type: "bounds",
        pos: info.pos
      });
    }
  });

  var _b = checkInnerBoundPoses(moveable),
      verticalInnerBoundPoses = _b.vertical,
      horizontalInnerBoundPoses = _b.horizontal;

  verticalInnerBoundPoses.forEach(function (innerPos) {
    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.findIndex)(verticalSnapPoses, function (_a) {
      var type = _a.type,
          pos = _a.pos;
      return type === "bounds" && pos === innerPos;
    }) >= 0) {
      return;
    }

    verticalSnapPoses.push({
      type: "bounds",
      pos: innerPos
    });
  });
  horizontalInnerBoundPoses.forEach(function (innerPos) {
    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.findIndex)(horizontalSnapPoses, function (_a) {
      var type = _a.type,
          pos = _a.pos;
      return type === "bounds" && pos === innerPos;
    }) >= 0) {
      return;
    }

    horizontalSnapPoses.push({
      type: "bounds",
      pos: innerPos
    });
  });
}
/**
 * @namespace Moveable.Snappable
 * @description Whether or not target can be snapped to the guideline. (default: false)
 * @sort 2
 */


var Snappable = {
  name: "snappable",
  dragRelation: "strong",
  props: {
    snappable: [Boolean, Array],
    snapContainer: Object,
    snapDirections: [Boolean, Object],
    elementSnapDirections: [Boolean, Object],
    snapGap: Boolean,
    snapGridWidth: Number,
    snapGridHeight: Number,
    isDisplaySnapDigit: Boolean,
    isDisplayInnerSnapDigit: Boolean,
    snapDigit: Number,
    snapThreshold: Number,
    horizontalGuidelines: Array,
    verticalGuidelines: Array,
    elementGuidelines: Array,
    bounds: Object,
    innerBounds: Object,
    snapDistFormat: Function
  },
  events: {
    onSnap: "snap"
  },
  css: [":host {\n    --bounds-color: #d66;\n}\n.guideline {\n    pointer-events: none;\n    z-index: 2;\n}\n.guideline.bounds {\n    background: #d66;\n    background: var(--bounds-color);\n}\n.guideline-group {\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.guideline-group .size-value {\n    position: absolute;\n    color: #f55;\n    font-size: 12px;\n    font-weight: bold;\n}\n.guideline-group.horizontal .size-value {\n    transform-origin: 50% 100%;\n    transform: translateX(-50%);\n    left: 50%;\n    bottom: 5px;\n}\n.guideline-group.vertical .size-value {\n    transform-origin: 0% 50%;\n    top: 50%;\n    transform: translateY(-50%);\n    left: 5px;\n}\n.guideline.gap {\n    background: #f55;\n}\n.size-value.gap {\n    color: #f55;\n}\n"],
  render: function (moveable, React) {
    var state = moveable.state;
    var targetTop = state.top,
        targetLeft = state.left,
        pos1 = state.pos1,
        pos2 = state.pos2,
        pos3 = state.pos3,
        pos4 = state.pos4,
        snapRenderInfo = state.snapRenderInfo;

    if (!snapRenderInfo || !hasGuidelines(moveable, "")) {
      return [];
    }

    state.guidelines = getTotalGuidelines(moveable);
    var minLeft = Math.min(pos1[0], pos2[0], pos3[0], pos4[0]);
    var minTop = Math.min(pos1[1], pos2[1], pos3[1], pos4[1]);
    var externalPoses = snapRenderInfo.externalPoses || [];
    var poses = getAbsolutePosesByState(moveable.state);
    var verticalSnapPoses = [];
    var horizontalSnapPoses = [];
    var verticalGuidelines = [];
    var horizontalGuidelines = [];
    var snapInfos = [];

    var _a = getRect(poses),
        width = _a.width,
        height = _a.height,
        top = _a.top,
        left = _a.left,
        bottom = _a.bottom,
        right = _a.right;

    var targetRect = {
      left: left,
      right: right,
      top: top,
      bottom: bottom,
      center: (left + right) / 2,
      middle: (top + bottom) / 2
    };
    var hasExternalPoses = externalPoses.length > 0;
    var externalRect = hasExternalPoses ? getRect(externalPoses) : {};

    if (!snapRenderInfo.request) {
      if (snapRenderInfo.direction) {
        snapInfos.push(getSnapInfosByDirection(moveable, poses, snapRenderInfo.direction));
      }

      if (snapRenderInfo.snap) {
        var rect = getRect(poses);

        if (snapRenderInfo.center) {
          rect.middle = (rect.top + rect.bottom) / 2;
          rect.center = (rect.left + rect.right) / 2;
        }

        snapInfos.push(checkSnaps(moveable, rect, 1));
      }

      if (hasExternalPoses) {
        if (snapRenderInfo.center) {
          externalRect.middle = (externalRect.top + externalRect.bottom) / 2;
          externalRect.center = (externalRect.left + externalRect.right) / 2;
        }

        snapInfos.push(checkSnaps(moveable, externalRect, 1));
      }

      snapInfos.forEach(function (snapInfo) {
        var verticalPosInfos = snapInfo.vertical.posInfos,
            horizontalPosInfos = snapInfo.horizontal.posInfos;
        verticalSnapPoses.push.apply(verticalSnapPoses, verticalPosInfos.filter(function (_a) {
          var guidelineInfos = _a.guidelineInfos;
          return guidelineInfos.some(function (_a) {
            var guideline = _a.guideline;
            return !guideline.hide;
          });
        }).map(function (posInfo) {
          return {
            type: "snap",
            pos: posInfo.pos
          };
        }));
        horizontalSnapPoses.push.apply(horizontalSnapPoses, horizontalPosInfos.filter(function (_a) {
          var guidelineInfos = _a.guidelineInfos;
          return guidelineInfos.some(function (_a) {
            var guideline = _a.guideline;
            return !guideline.hide;
          });
        }).map(function (posInfo) {
          return {
            type: "snap",
            pos: posInfo.pos
          };
        }));
        verticalGuidelines.push.apply(verticalGuidelines, getSnapGuidelines(verticalPosInfos));
        horizontalGuidelines.push.apply(horizontalGuidelines, getSnapGuidelines(horizontalPosInfos));
      });
    }

    addBoundGuidelines(moveable, [left, right], [top, bottom], verticalSnapPoses, horizontalSnapPoses);

    if (hasExternalPoses) {
      addBoundGuidelines(moveable, [externalRect.left, externalRect.right], [externalRect.top, externalRect.bottom], verticalSnapPoses, horizontalSnapPoses, snapRenderInfo.externalBounds);
    }

    var allGuidelines = __spreadArray(__spreadArray([], verticalGuidelines), horizontalGuidelines);

    var elementGuidelines = allGuidelines.filter(function (guideline) {
      return guideline.element && !guideline.gapRects;
    });
    var gapGuidelines = allGuidelines.filter(function (guideline) {
      return guideline.gapRects;
    });
    triggerEvent(moveable, "onSnap", {
      guidelines: allGuidelines.filter(function (_a) {
        var element = _a.element;
        return !element;
      }),
      elements: elementGuidelines,
      gaps: gapGuidelines
    }, true);
    return __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], renderDashedGuidelines(moveable, elementGuidelines, [minLeft, minTop], targetRect, React)), renderGapGuidelines(moveable, gapGuidelines, [minLeft, minTop], targetRect, React)), renderGuidelines(moveable, "horizontal", horizontalGuidelines, [targetLeft, targetTop], targetRect, React)), renderGuidelines(moveable, "vertical", verticalGuidelines, [targetLeft, targetTop], targetRect, React)), renderSnapPoses(moveable, "horizontal", horizontalSnapPoses, minLeft, targetTop, width, 0, React)), renderSnapPoses(moveable, "vertical", verticalSnapPoses, minTop, targetLeft, height, 1, React));
  },
  dragStart: function (moveable, e) {
    moveable.state.snapRenderInfo = {
      request: e.isRequest,
      snap: true,
      center: true
    };
    snapStart(moveable);
  },
  drag: function (moveable) {
    var state = moveable.state;
    state.guidelines = getTotalGuidelines(moveable);
  },
  pinchStart: function (moveable) {
    this.unset(moveable);
  },
  dragEnd: function (moveable) {
    this.unset(moveable);
  },
  dragControlCondition: function (moveable, e) {
    if (directionCondition(moveable, e) || dragControlCondition(moveable, e)) {
      return true;
    }

    if (!e.isRequest && e.inputEvent) {
      return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.hasClass)(e.inputEvent.target, prefix("snap-control"));
    }
  },
  dragControlStart: function (moveable) {
    moveable.state.snapRenderInfo = null;
    snapStart(moveable);
  },
  dragControl: function (moveable) {
    this.drag(moveable);
  },
  dragControlEnd: function (moveable) {
    this.unset(moveable);
  },
  dragGroupStart: function (moveable, e) {
    this.dragStart(moveable, e);
  },
  dragGroup: function (moveable) {
    this.drag(moveable);
  },
  dragGroupEnd: function (moveable) {
    this.unset(moveable);
  },
  dragGroupControlStart: function (moveable) {
    moveable.state.snapRenderInfo = null;
    snapStart(moveable);
  },
  dragGroupControl: function (moveable) {
    this.drag(moveable);
  },
  dragGroupControlEnd: function (moveable) {
    this.unset(moveable);
  },
  unset: function (moveable) {
    var state = moveable.state;
    state.enableSnap = false;
    state.guidelines = [];
    state.snapRenderInfo = null;
    state.elementRects = [];
  }
};
/**
 * Whether or not target can be snapped to the guideline. (default: false)
 * @name Moveable.Snappable#snappable
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.snappable = true;
 */

/**
 *  A snap container that is the basis for snap, bounds, and innerBounds. (default: null = container)
 * @name Moveable.Snappable#snapContainer
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.querySelector(".container"));
 *
 * moveable.snapContainer = document.body;
 */

/**
 * You can specify the directions to snap to the target. (default: { left: true, top: true, right: true, bottom: true })
 * @name Moveable.Snappable#snapDirections
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   snappable: true,
 *   snapDirections: true,
 * });
 * // snap center
 * moveable.snapDirections = { left: true, top: true, right: true, bottom: true, center: true, middle: true };
 */

/**
 * You can specify the snap directions of elements. (default: { left: true, top: true, right: true, bottom: true })
 * @name Moveable.Snappable#elementSnapDirections
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   snappable: true,
 *   elementSnapDirections: true,
 * });
 * // snap center
 * moveable.elementSnapDirections = { left: true, top: true, right: true, bottom: true, center: true, middle: true };
 */

/**
 * When you drag, make the gap snap in the element guidelines. (default: true)
 * @name Moveable.Snappable#snapGap
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   snappable: true,
 *   snapVertical: true,
 *   snapHorizontal: true,
 *   snapElement: true,
 *   snapGap: true,
 * });
 *
 * moveable.snapGap = false;
 */

/**
 * Distance value that can snap to guidelines. (default: 5)
 * @name Moveable.Snappable#snapThreshold
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.snapThreshold = 5;
 */

/**
 * Add guidelines in the horizontal direction. (default: [])
 * @name Moveable.Snappable#horizontalGuidelines
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.horizontalGuidelines = [100, 200, 500];
 */

/**
 * Add guidelines in the vertical direction. (default: [])
 * @name Moveable.Snappable#verticalGuidelines
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.verticalGuidelines = [100, 200, 500];
 */

/**
 * Add guidelines for the element. (default: [])
 * @name Moveable.Snappable#elementGuidelines
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.elementGuidelines = [
 *   document.querySelector(".element"),
 * ];
 */

/**
 * You can set up boundaries. (default: null)
 * @name Moveable.Snappable#bounds
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.bounds = { left: 0, right: 1000, top: 0, bottom: 1000};
 */

/**
 * You can set up inner boundaries. (default: null)
 * @name Moveable.Snappable#innerBounds
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.innerBounds = { left: 500, top: 500, width: 100, height: 100};
 */

/**
 * snap distance digits (default: 0)
 * @name Moveable.Snappable#snapDigit
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.snapDigit = 0
 */

/**
 * If width size is greater than 0, you can vertical snap to the grid. (default: 0)
 * @name Moveable.Snappable#snapGridWidth
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.snapGridWidth = 5;
 */

/**
 * If height size is greater than 0, you can horizontal snap to the grid. (default: 0)
 * @name Moveable.Snappable#snapGridHeight
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.snapGridHeight = 5;
 */

/**
 * Whether to show snap distance (default: true)
 * @name Moveable.Snappable#isDisplaySnapDigit
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.isDisplaySnapDigit = true;
 */

/**
 * Whether to show element inner snap distance (default: false)
 * @name Moveable.Snappable#isDisplayInnerSnapDigit
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.isDisplayInnerSnapDigit = true;
 */

/**
 * You can set the text format of the distance shown in the guidelines. (default: self)
 * @name Moveable.Snappable#snapDistFormat
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *  snappable: true,
 *  snapDistFormat: v => v,
 * });
 * moveable.snapDistFormat = v => `${v}px`;
 */

/**
 * When you drag or dragControl, the `snap` event is called.
 * @memberof Moveable.Snappable
 * @event snap
 * @param {Moveable.Snappable.OnSnap} - Parameters for the `snap` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     snappable: true
 * });
 * moveable.on("snap", e => {
 *     console.log("onSnap", e);
 * });
 */

/**
 * @namespace Draggable
 * @memberof Moveable
 * @description Draggable refers to the ability to drag and move targets.
 */

var Draggable = {
  name: "draggable",
  props: {
    draggable: Boolean,
    throttleDrag: Number,
    throttleDragRotate: Number,
    startDragRotate: Number,
    edgeDraggable: Boolean
  },
  events: {
    onDragStart: "dragStart",
    onDrag: "drag",
    onDragEnd: "dragEnd",
    onDragGroupStart: "dragGroupStart",
    onDragGroup: "dragGroup",
    onDragGroupEnd: "dragGroupEnd"
  },
  render: function (moveable, React) {
    var _a = moveable.props,
        throttleDragRotate = _a.throttleDragRotate,
        zoom = _a.zoom;
    var _b = moveable.state,
        dragInfo = _b.dragInfo,
        beforeOrigin = _b.beforeOrigin;

    if (!throttleDragRotate || !dragInfo) {
      return [];
    }

    var dist = dragInfo.dist;

    if (!dist[0] && !dist[1]) {
      return [];
    }

    var width = getDistSize(dist);
    var rad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)(dist, [0, 0]);
    return [React.createElement("div", {
      className: prefix("line", "horizontal", "dragline", "dashed"),
      key: "dragRotateGuideline",
      style: {
        width: width + "px",
        transform: "translate(" + beforeOrigin[0] + "px, " + beforeOrigin[1] + "px) rotate(" + rad + "rad) scaleY(" + zoom + ")"
      }
    })];
  },
  dragStart: function (moveable, e) {
    var datas = e.datas,
        parentEvent = e.parentEvent,
        parentGesto = e.parentGesto;
    var state = moveable.state;
    var target = state.target,
        gesto = state.gesto;

    if (gesto) {
      return false;
    }

    state.gesto = parentGesto || moveable.targetGesto;
    var style = getComputedStyle(target);
    datas.datas = {};
    datas.left = parseFloat(style.left || "") || 0;
    datas.top = parseFloat(style.top || "") || 0;
    datas.bottom = parseFloat(style.bottom || "") || 0;
    datas.right = parseFloat(style.right || "") || 0;
    datas.startValue = [0, 0];
    setDragStart(moveable, e);
    setDefaultTransformIndex(e, "translate");
    startCheckSnapDrag(moveable, datas);
    datas.prevDist = [0, 0];
    datas.prevBeforeDist = [0, 0];
    datas.isDrag = false;
    datas.deltaOffset = [0, 0];
    datas.distOffset = [0, 0];
    var params = fillParams(moveable, e, __assign({
      set: function (translate) {
        datas.startValue = translate;
      }
    }, fillTransformStartEvent(e)));
    var result = parentEvent || triggerEvent(moveable, "onDragStart", params);

    if (result !== false) {
      datas.isDrag = true;
      moveable.state.dragInfo = {
        startRect: moveable.getRect(),
        dist: [0, 0]
      };
    } else {
      state.gesto = null;
      datas.isPinch = false;
    }

    return datas.isDrag ? params : false;
  },
  drag: function (moveable, e) {
    if (!e) {
      return;
    }

    resolveTransformEvent(e, "translate");
    var datas = e.datas,
        parentEvent = e.parentEvent,
        parentFlag = e.parentFlag,
        isPinch = e.isPinch,
        isRequest = e.isRequest;
    var distX = e.distX,
        distY = e.distY;
    var isDrag = datas.isDrag,
        prevDist = datas.prevDist,
        prevBeforeDist = datas.prevBeforeDist,
        startValue = datas.startValue,
        distOffset = datas.distOffset;

    if (!isDrag) {
      return;
    }

    distX += distOffset[0];
    distY += distOffset[1];
    var props = moveable.props;
    var parentMoveable = props.parentMoveable;
    var throttleDrag = parentEvent ? 0 : props.throttleDrag || 0;
    var throttleDragRotate = parentEvent ? 0 : props.throttleDragRotate || 0;
    var isSnap = false;
    var dragRotateRad = 0;

    if (!parentEvent && throttleDragRotate > 0 && (distX || distY)) {
      var startDragRotate = props.startDragRotate || 0;
      var deg = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(startDragRotate + (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)([0, 0], [distX, distY]) * 180 / Math.PI, throttleDragRotate) - startDragRotate;
      var ry = distY * Math.abs(Math.cos((deg - 90) / 180 * Math.PI));
      var rx = distX * Math.abs(Math.cos(deg / 180 * Math.PI));
      var r = getDistSize([rx, ry]);
      dragRotateRad = deg * Math.PI / 180;
      distX = r * Math.cos(dragRotateRad);
      distY = r * Math.sin(dragRotateRad);
    }

    if (!isPinch && !parentEvent && !parentFlag && (!throttleDragRotate || distX || distY)) {
      var _a = checkSnapBoundsDrag(moveable, distX, distY, throttleDragRotate, isRequest, datas),
          verticalInfo = _a[0],
          horizontalInfo = _a[1];

      var isVerticalSnap = verticalInfo.isSnap,
          isVerticalBound = verticalInfo.isBound,
          verticalOffset = verticalInfo.offset;
      var isHorizontalSnap = horizontalInfo.isSnap,
          isHorizontalBound = horizontalInfo.isBound,
          horizontalOffset = horizontalInfo.offset;
      isSnap = isVerticalSnap || isHorizontalSnap || isVerticalBound || isHorizontalBound;
      distX += verticalOffset;
      distY += horizontalOffset;
    }

    var beforeTranslate = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(getBeforeDragDist({
      datas: datas,
      distX: distX,
      distY: distY
    }), startValue);
    var translate = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(getTransformDist({
      datas: datas,
      distX: distX,
      distY: distY
    }), startValue);

    if (!throttleDragRotate && !isSnap) {
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttleArray)(translate, throttleDrag);
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttleArray)(beforeTranslate, throttleDrag);
    }

    var beforeDist = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(beforeTranslate, startValue);
    var dist = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(translate, startValue);
    var delta = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(dist, prevDist);
    var beforeDelta = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(beforeDist, prevBeforeDist);
    datas.prevDist = dist;
    datas.prevBeforeDist = beforeDist;
    datas.passDelta = delta; //distX - (datas.passDistX || 0);
    // datas.passDeltaY = distY - (datas.passDistY || 0);

    datas.passDist = dist; //distX;
    // datas.passDistY = distY;

    var left = datas.left + beforeDist[0];
    var top = datas.top + beforeDist[1];
    var right = datas.right - beforeDist[0];
    var bottom = datas.bottom - beforeDist[1];
    var nextTransform = convertTransformFormat(datas, "translate(" + translate[0] + "px, " + translate[1] + "px)", "translate(" + dist[0] + "px, " + dist[1] + "px)");
    fillOriginalTransform(e, nextTransform);
    moveable.state.dragInfo.dist = parentEvent ? [0, 0] : dist;

    if (!parentEvent && !parentMoveable && delta.every(function (num) {
      return !num;
    }) && beforeDelta.some(function (num) {
      return !num;
    })) {
      return;
    }

    var _b = moveable.state,
        width = _b.width,
        height = _b.height;
    var params = fillParams(moveable, e, {
      transform: nextTransform,
      dist: dist,
      delta: delta,
      translate: translate,
      beforeDist: beforeDist,
      beforeDelta: beforeDelta,
      beforeTranslate: beforeTranslate,
      left: left,
      top: top,
      right: right,
      bottom: bottom,
      width: width,
      height: height,
      isPinch: isPinch
    });
    !parentEvent && triggerEvent(moveable, "onDrag", params);
    return params;
  },
  dragAfter: function (moveable, e) {
    var datas = e.datas;
    var _a = e.datas,
        deltaOffset = _a.deltaOffset,
        distOffset = _a.distOffset;

    if (deltaOffset[0] || deltaOffset[1]) {
      datas.deltaOffset = [0, 0];
      distOffset[0] = deltaOffset[0];
      distOffset[1] = deltaOffset[1];
      return this.drag(moveable, e);
    }

    return false;
  },
  dragEnd: function (moveable, e) {
    var parentEvent = e.parentEvent,
        datas = e.datas;
    moveable.state.gesto = null;
    moveable.state.dragInfo = null;

    if (!datas.isDrag) {
      return;
    }

    datas.isDrag = false;
    var param = fillEndParams(moveable, e, {});
    !parentEvent && triggerEvent(moveable, "onDragEnd", param);
    return param;
  },
  dragGroupStart: function (moveable, e) {
    var datas = e.datas,
        clientX = e.clientX,
        clientY = e.clientY;
    var params = this.dragStart(moveable, e);

    if (!params) {
      return false;
    }

    var events = triggerChildGesto(moveable, this, "dragStart", [clientX || 0, clientY || 0], e, false);

    var nextParams = __assign(__assign({}, params), {
      targets: moveable.props.targets,
      events: events
    });

    var result = triggerEvent(moveable, "onDragGroupStart", nextParams);
    datas.isDrag = result !== false;
    return datas.isDrag ? params : false;
  },
  dragGroup: function (moveable, e) {
    var datas = e.datas;

    if (!datas.isDrag) {
      return;
    }

    var params = this.drag(moveable, e);
    var passDelta = e.datas.passDelta;
    var events = triggerChildGesto(moveable, this, "drag", passDelta, e, false);

    if (!params) {
      return;
    }

    var nextParams = __assign({
      targets: moveable.props.targets,
      events: events
    }, params);

    triggerEvent(moveable, "onDragGroup", nextParams);
    return nextParams;
  },
  dragGroupEnd: function (moveable, e) {
    var isDrag = e.isDrag,
        datas = e.datas;

    if (!datas.isDrag) {
      return;
    }

    this.dragEnd(moveable, e);
    var events = triggerChildGesto(moveable, this, "dragEnd", [0, 0], e, false);
    triggerEvent(moveable, "onDragGroupEnd", fillEndParams(moveable, e, {
      targets: moveable.props.targets,
      events: events
    }));
    return isDrag;
  },

  /**
   * @method Moveable.Draggable#request
   * @param {object} [e] - the draggable's request parameter
   * @param {number} [e.x] - x position
   * @param {number} [e.y] - y position
   * @param {number} [e.deltaX] - X number to move
   * @param {number} [e.deltaY] - Y number to move
   * @return {Moveable.Requester} Moveable Requester
   * @example
    * // Instantly Request (requestStart - request - requestEnd)
   * // Use Relative Value
   * moveable.request("draggable", { deltaX: 10, deltaY: 10 }, true);
   * // Use Absolute Value
   * moveable.request("draggable", { x: 200, y: 100 }, true);
   *
   * // requestStart
   * const requester = moveable.request("draggable");
   *
   * // request
   * // Use Relative Value
   * requester.request({ deltaX: 10, deltaY: 10 });
   * requester.request({ deltaX: 10, deltaY: 10 });
   * requester.request({ deltaX: 10, deltaY: 10 });
   * // Use Absolute Value
   * moveable.request("draggable", { x: 200, y: 100 });
   * moveable.request("draggable", { x: 220, y: 100 });
   * moveable.request("draggable", { x: 240, y: 100 });
   *
   * // requestEnd
   * requester.requestEnd();
   */
  request: function (moveable) {
    var datas = {};
    var rect = moveable.getRect();
    var distX = 0;
    var distY = 0;
    return {
      isControl: false,
      requestStart: function () {
        return {
          datas: datas
        };
      },
      request: function (e) {
        if ("x" in e) {
          distX = e.x - rect.left;
        } else if ("deltaX" in e) {
          distX += e.deltaX;
        }

        if ("y" in e) {
          distY = e.y - rect.top;
        } else if ("deltaY" in e) {
          distY += e.deltaY;
        }

        return {
          datas: datas,
          distX: distX,
          distY: distY
        };
      },
      requestEnd: function () {
        return {
          datas: datas,
          isDrag: true
        };
      }
    };
  },
  unset: function (moveable) {
    moveable.state.dragInfo = null;
  }
};
/**
 * Whether or not target can be dragged. (default: false)
 * @name Moveable.Draggable#draggable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.draggable = true;
 */

/**
 * throttle of x, y when drag.
 * @name Moveable.Draggable#throttleDrag
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.throttleDrag = 1;
 */

/**
* throttle of angle of x, y when drag.
* @name Moveable.Draggable#throttleDragRotate
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body);
*
* moveable.throttleDragRotate = 45;
*/

/**
* start angle of throttleDragRotate of x, y when drag.
* @name Moveable.Draggable#startDragRotate
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body);
*
* // 45, 135, 225, 315
* moveable.throttleDragRotate = 90;
* moveable.startDragRotate = 45;
*/

/**
 * When the drag starts, the dragStart event is called.
 * @memberof Moveable.Draggable
 * @event dragStart
 * @param {Moveable.Draggable.OnDragStart} - Parameters for the dragStart event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { draggable: true });
 * moveable.on("dragStart", ({ target }) => {
 *     console.log(target);
 * });
 */

/**
 * When dragging, the drag event is called.
 * @memberof Moveable.Draggable
 * @event drag
 * @param {Moveable.Draggable.OnDrag} - Parameters for the drag event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { draggable: true });
 * moveable.on("drag", ({ target, transform }) => {
 *     target.style.transform = transform;
 * });
 */

/**
 * When the drag finishes, the dragEnd event is called.
 * @memberof Moveable.Draggable
 * @event dragEnd
 * @param {Moveable.Draggable.OnDragEnd} - Parameters for the dragEnd event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { draggable: true });
 * moveable.on("dragEnd", ({ target, isDrag }) => {
 *     console.log(target, isDrag);
 * });
 */

/**
* When the group drag starts, the `dragGroupStart` event is called.
* @memberof Moveable.Draggable
* @event dragGroupStart
* @param {Moveable.Draggable.OnDragGroupStart} - Parameters for the `dragGroupStart` event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     target: [].slice.call(document.querySelectorAll(".target")),
*     draggable: true
* });
* moveable.on("dragGroupStart", ({ targets }) => {
*     console.log("onDragGroupStart", targets);
* });
*/

/**
* When the group drag, the `dragGroup` event is called.
* @memberof Moveable.Draggable
* @event dragGroup
* @param {Moveable.Draggable.OnDragGroup} - Parameters for the `dragGroup` event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     target: [].slice.call(document.querySelectorAll(".target")),
*     draggable: true
* });
* moveable.on("dragGroup", ({ targets, events }) => {
*     console.log("onDragGroup", targets);
*     events.forEach(ev => {
*          // drag event
*          console.log("onDrag left, top", ev.left, ev.top);
*          // ev.target!.style.left = `${ev.left}px`;
*          // ev.target!.style.top = `${ev.top}px`;
*          console.log("onDrag translate", ev.dist);
*          ev.target!.style.transform = ev.transform;)
*     });
* });
*/

/**
 * When the group drag finishes, the `dragGroupEnd` event is called.
 * @memberof Moveable.Draggable
 * @event dragGroupEnd
 * @param {Moveable.Draggable.OnDragGroupEnd} - Parameters for the `dragGroupEnd` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 *     draggable: true
 * });
 * moveable.on("dragGroupEnd", ({ targets, isDrag }) => {
 *     console.log("onDragGroupEnd", targets, isDrag);
 * });
 */

function renderDirectionControls(moveable, defaultDirections, React, additionalClassName) {
  if (additionalClassName === void 0) {
    additionalClassName = "";
  }

  var _a = moveable.state,
      renderPoses = _a.renderPoses,
      rotationRad = _a.rotation,
      direction = _a.direction;
  var _b = moveable.props,
      _c = _b.renderDirections,
      directions = _c === void 0 ? defaultDirections : _c,
      zoom = _b.zoom;
  var directionMap = {};

  if (!directions) {
    return [];
  }

  var sign = direction > 0 ? 1 : -1;
  var renderDirections = directions === true ? DIRECTIONS : directions;
  var degRotation = rotationRad / Math.PI * 180;
  renderDirections.forEach(function (dir) {
    directionMap[dir] = true;
  });
  return renderDirections.map(function (dir) {
    var indexes = DIRECTION_INDEXES[dir];

    if (!indexes || !directionMap[dir]) {
      return null;
    }

    var directionRotation = ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(degRotation, 15) + sign * DIRECTION_ROTATIONS[dir] + 720) % 180;
    return React.createElement("div", {
      className: prefix("control", "direction", dir, additionalClassName),
      "data-rotation": directionRotation,
      "data-direction": dir,
      key: "direction-" + dir,
      style: getControlTransform.apply(void 0, __spreadArray([rotationRad, zoom], indexes.map(function (index) {
        return renderPoses[index];
      })))
    });
  });
}
function renderLine(React, direction, pos1, pos2, zoom, key) {
  var classNames = [];

  for (var _i = 6; _i < arguments.length; _i++) {
    classNames[_i - 6] = arguments[_i];
  }

  var rad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)(pos1, pos2);
  var rotation = direction ? (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(rad / Math.PI * 180, 15) % 180 : -1;
  return React.createElement("div", {
    key: "line" + key,
    className: prefix.apply(void 0, __spreadArray(["line", "direction", direction], classNames)),
    "data-rotation": rotation,
    "data-line-index": key,
    "data-direction": direction,
    style: getLineStyle(pos1, pos2, zoom, rad)
  });
}
function renderAllDirections(moveable, React) {
  return renderDirectionControls(moveable, DIRECTIONS, React);
}
function renderDiagonalDirections(moveable, React) {
  return renderDirectionControls(moveable, ["nw", "ne", "sw", "se"], React);
}

/**
 * @namespace Rotatable
 * @memberof Moveable
 * @description Rotatable indicates whether the target can be rotated.
 */

function setRotateStartInfo(moveable, datas, clientX, clientY, origin, rect) {
  var n = moveable.state.is3d ? 4 : 3;
  var nextOrigin = calculatePosition(moveable.state.rootMatrix, origin, n);
  var startAbsoluteOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)([rect.left, rect.top], nextOrigin);
  datas.startAbsoluteOrigin = startAbsoluteOrigin;
  datas.prevDeg = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)(startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180;
  datas.prevSnapDeg = datas.prevDeg;
  datas.startDeg = datas.prevDeg;
  datas.loop = 0;
}

function getParentDeg(moveable, moveableRect, datas, parentDist, direction, startValue) {
  var prevDeg = datas.prevDeg; // const absoluteDeg = startValue + parentDist;

  var dist = checkSnapRotate(moveable, moveableRect, datas.origin, parentDist);
  datas.prevDeg = dist;
  var delta = dist - prevDeg;
  return [delta, dist, startValue + dist];
}

function getDeg(moveable, moveableRect, datas, deg, direction, startValue, throttleRotate, isSnap) {
  var prevDeg = datas.prevDeg,
      prevSnapDeg = datas.prevSnapDeg,
      startDeg = datas.startDeg,
      prevLoop = datas.loop;

  if (prevDeg > deg && prevDeg > 270 && deg < 90) {
    // 360 => 0
    ++datas.loop;
  } else if (prevDeg < deg && prevDeg < 90 && deg > 270) {
    // 0 => 360
    --datas.loop;
  }

  var loop = datas.loop;
  var absolutePrevSnapDeg = prevLoop * 360 + prevSnapDeg - startDeg + startValue;
  var absoluteDeg = loop * 360 + deg - startDeg + startValue;
  datas.prevDeg = absoluteDeg - loop * 360 + startDeg - startValue;
  absoluteDeg = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(absoluteDeg, throttleRotate);
  var dist = direction * (absoluteDeg - startValue);

  if (isSnap) {
    dist = checkSnapRotate(moveable, moveableRect, datas.origin, dist);
    absoluteDeg = dist / direction + startValue;
  }

  datas.prevSnapDeg = absoluteDeg - loop * 360 + startDeg - startValue;
  var delta = direction * (absoluteDeg - absolutePrevSnapDeg);
  return [delta, dist, startValue + dist];
}

function getRotateInfo(moveable, moveableRect, datas, direction, clientX, clientY, startValue, throttleRotate) {
  return getDeg(moveable, moveableRect, datas, (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)(datas.startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180, direction, startValue, throttleRotate, true);
}
function getRotationPositions(rotationPosition, _a, direction) {
  var pos1 = _a[0],
      pos2 = _a[1],
      pos3 = _a[2],
      pos4 = _a[3];

  if (rotationPosition === "none") {
    return;
  }

  var _b = (rotationPosition || "top").split("-"),
      dir1 = _b[0],
      dir2 = _b[1];

  var radPoses = [pos1, pos2]; // if (scale[0] < 0) {
  //     dir1 = getReversePositionX(dir1);
  //     dir2 = getReversePositionX(dir2);
  // }
  // if (scale[1] < 0) {
  //     dir1 = getReversePositionY(dir1);
  //     dir2 = getReversePositionY(dir2);
  // }

  if (dir1 === "left") {
    radPoses = [pos3, pos1];
  } else if (dir1 === "right") {
    radPoses = [pos2, pos4];
  } else if (dir1 === "bottom") {
    radPoses = [pos4, pos3];
  }

  var pos = [(radPoses[0][0] + radPoses[1][0]) / 2, (radPoses[0][1] + radPoses[1][1]) / 2];
  var rad = getRotationRad(radPoses, direction);

  if (dir2) {
    var isStart = dir2 === "top" || dir2 === "left";
    var isReverse = dir1 === "bottom" || dir1 === "left";
    pos = radPoses[isStart && !isReverse || !isStart && isReverse ? 0 : 1];
  }

  return [pos, rad];
}
function dragControlCondition(moveable, e) {
  if (e.isRequest) {
    return e.requestAble === "rotatable";
  }

  var target = e.inputEvent.target;

  if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.hasClass)(target, prefix("rotation-control"))) {
    return true;
  }

  var rotationTarget = moveable.props.rotationTarget;

  if (rotationTarget) {
    return getRefTargets(rotationTarget, true).some(function (element) {
      if (!element) {
        return false;
      }

      return target === element || target.contains(element);
    });
  }

  return false;
}
var Rotatable = {
  name: "rotatable",
  canPinch: true,
  props: {
    rotatable: Boolean,
    rotationPosition: String,
    throttleRotate: Number,
    renderDirections: Object,
    rotationTarget: Object
  },
  events: {
    onRotateStart: "rotateStart",
    onRotate: "rotate",
    onRotateEnd: "rotateEnd",
    onRotateGroupStart: "rotateGroupStart",
    onRotateGroup: "rotateGroup",
    onRotateGroupEnd: "rotateGroupEnd"
  },
  css: [".rotation {\n            position: absolute;\n            height: 40px;\n            width: 1px;\n            transform-origin: 50% 100%;\n            height: calc(40px * var(--zoom));\n            top: auto;\n            left: 0;\n            bottom: 100%;\n            will-change: transform;\n        }\n        .rotation .rotation-line {\n            display: block;\n            width: 100%;\n            height: 100%;\n            transform-origin: 50% 50%;\n        }\n        .rotation .rotation-control {\n            border-color: #4af;\n            border-color: var(--moveable-color);\n            background:#fff;\n            cursor: alias;\n        }"],
  render: function (moveable, React) {
    var _a = moveable.props,
        rotatable = _a.rotatable,
        rotationPosition = _a.rotationPosition,
        zoom = _a.zoom,
        renderDirections = _a.renderDirections;
    var _b = moveable.state,
        renderPoses = _b.renderPoses,
        direction = _b.direction;

    if (!rotatable) {
      return null;
    }

    var positions = getRotationPositions(rotationPosition, renderPoses, direction);
    var jsxs = [];

    if (positions) {
      var pos = positions[0],
          rad = positions[1];
      jsxs.push(React.createElement("div", {
        key: "rotation",
        className: prefix("rotation"),
        style: {
          // tslint:disable-next-line: max-line-length
          transform: "translate(-50%) translate(" + pos[0] + "px, " + pos[1] + "px) rotate(" + rad + "rad)"
        }
      }, React.createElement("div", {
        className: prefix("line rotation-line"),
        style: {
          transform: "scaleX(" + zoom + ")"
        }
      }), React.createElement("div", {
        className: prefix("control rotation-control"),
        style: {
          transform: "translate(0.5px) scale(" + zoom + ")"
        }
      })));
    }

    if (renderDirections) {
      jsxs.push.apply(jsxs, renderDirectionControls(moveable, [], React));
    }

    return jsxs;
  },
  dragControlCondition: dragControlCondition,
  dragControlStart: function (moveable, e) {
    var datas = e.datas,
        clientX = e.clientX,
        clientY = e.clientY,
        parentRotate = e.parentRotate,
        parentFlag = e.parentFlag,
        isPinch = e.isPinch,
        isRequest = e.isRequest;
    var _a = moveable.state,
        target = _a.target,
        left = _a.left,
        top = _a.top,
        origin = _a.origin,
        beforeOrigin = _a.beforeOrigin,
        direction = _a.direction,
        beforeDirection = _a.beforeDirection,
        targetTransform = _a.targetTransform,
        moveableClientRect = _a.moveableClientRect;

    if (!isRequest && !target) {
      return false;
    }

    var rect = moveable.getRect();
    datas.rect = rect;
    datas.transform = targetTransform;
    datas.left = left;
    datas.top = top;
    datas.fixedPosition = getDirectionOffset(moveable, getOriginDirection(moveable));
    datas.absoluteInfo = {
      origin: rect.origin,
      startValue: rect.rotation
    };
    setRotateStartInfo(moveable, datas.absoluteInfo, clientX, clientY, origin, moveableClientRect);

    if (isRequest || isPinch || parentFlag) {
      var externalRotate = parentRotate || 0;
      datas.beforeInfo = {
        origin: rect.beforeOrigin,
        prevDeg: externalRotate,
        startDeg: externalRotate,
        prevSnapDeg: externalRotate,
        loop: 0
      };
      datas.afterInfo = {
        origin: rect.origin,
        prevDeg: externalRotate,
        startDeg: externalRotate,
        prevSnapDeg: externalRotate,
        loop: 0
      };
    } else {
      datas.beforeInfo = {
        origin: rect.beforeOrigin
      };
      datas.afterInfo = {
        origin: rect.origin
      };
      setRotateStartInfo(moveable, datas.beforeInfo, clientX, clientY, beforeOrigin, moveableClientRect);
      setRotateStartInfo(moveable, datas.afterInfo, clientX, clientY, origin, moveableClientRect);
    }

    datas.direction = direction;
    datas.beforeDirection = beforeDirection;
    datas.startValue = 0;
    datas.datas = {};
    setDefaultTransformIndex(e, "rotate");
    var params = fillParams(moveable, e, __assign(__assign({
      set: function (rotatation) {
        datas.startValue = rotatation * Math.PI / 180;
      }
    }, fillTransformStartEvent(e)), {
      dragStart: Draggable.dragStart(moveable, new CustomGesto().dragStart([0, 0], e))
    }));
    var result = triggerEvent(moveable, "onRotateStart", params);
    datas.isRotate = result !== false;
    moveable.state.snapRenderInfo = {
      request: e.isRequest
    };
    return datas.isRotate ? params : false;
  },
  dragControl: function (moveable, e) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;

    var datas = e.datas,
        clientX = e.clientX,
        clientY = e.clientY,
        parentRotate = e.parentRotate,
        parentFlag = e.parentFlag,
        isPinch = e.isPinch,
        groupDelta = e.groupDelta;
    var beforeDirection = datas.beforeDirection,
        beforeInfo = datas.beforeInfo,
        afterInfo = datas.afterInfo,
        absoluteInfo = datas.absoluteInfo,
        isRotate = datas.isRotate,
        startValue = datas.startValue,
        rect = datas.rect;

    if (!isRotate) {
      return;
    }

    resolveTransformEvent(e, "rotate");
    var targetDirection = getTransformDirection(e);
    var direction = beforeDirection * targetDirection;
    var _k = moveable.props,
        _l = _k.throttleRotate,
        throttleRotate = _l === void 0 ? 0 : _l,
        parentMoveable = _k.parentMoveable;
    var delta;
    var dist;
    var rotate;
    var beforeDelta;
    var beforeDist;
    var beforeRotate;
    var absoluteDelta;
    var absoluteDist;
    var absoluteRotate;
    var startDeg = 180 / Math.PI * startValue;
    var absoluteStartDeg = absoluteInfo.startValue;

    if (!parentFlag && "parentDist" in e) {
      var parentDist = e.parentDist;
      _a = getParentDeg(moveable, rect, afterInfo, parentDist, direction, startDeg), delta = _a[0], dist = _a[1], rotate = _a[2];
      _b = getParentDeg(moveable, rect, beforeInfo, parentDist, beforeDirection, startDeg), beforeDelta = _b[0], beforeDist = _b[1], beforeRotate = _b[2];
      _c = getParentDeg(moveable, rect, absoluteInfo, parentDist, direction, absoluteStartDeg), absoluteDelta = _c[0], absoluteDist = _c[1], absoluteRotate = _c[2];
    } else if (isPinch || parentFlag) {
      _d = getDeg(moveable, rect, afterInfo, parentRotate, direction, startDeg, throttleRotate), delta = _d[0], dist = _d[1], rotate = _d[2];
      _e = getDeg(moveable, rect, beforeInfo, parentRotate, beforeDirection, startDeg, throttleRotate), beforeDelta = _e[0], beforeDist = _e[1], beforeRotate = _e[2];
      _f = getDeg(moveable, rect, absoluteInfo, parentRotate, direction, absoluteStartDeg, throttleRotate), absoluteDelta = _f[0], absoluteDist = _f[1], absoluteRotate = _f[2];
    } else {
      _g = getRotateInfo(moveable, rect, afterInfo, direction, clientX, clientY, startDeg, throttleRotate), delta = _g[0], dist = _g[1], rotate = _g[2];
      _h = getRotateInfo(moveable, rect, beforeInfo, beforeDirection, clientX, clientY, startDeg, throttleRotate), beforeDelta = _h[0], beforeDist = _h[1], beforeRotate = _h[2];
      _j = getRotateInfo(moveable, rect, absoluteInfo, direction, clientX, clientY, absoluteStartDeg, throttleRotate), absoluteDelta = _j[0], absoluteDist = _j[1], absoluteRotate = _j[2];
    }

    if (!absoluteDelta && !delta && !beforeDelta && !parentMoveable) {
      return;
    }

    var nextTransform = convertTransformFormat(datas, "rotate(" + rotate + "deg)", "rotate(" + dist + "deg)");
    var inverseDist = getRotateDist(moveable, dist, datas.fixedPosition, datas);
    var inverseDelta = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(groupDelta || [0, 0], inverseDist), datas.prevInverseDist || [0, 0]);
    datas.prevInverseDist = inverseDist;
    var params = fillParams(moveable, e, __assign({
      delta: delta,
      dist: dist,
      rotate: rotate,
      beforeDist: beforeDist,
      beforeDelta: beforeDelta,
      beforeRotate: beforeRotate,
      absoluteDist: absoluteDist,
      absoluteDelta: absoluteDelta,
      absoluteRotate: absoluteRotate,
      isPinch: !!isPinch
    }, fillTransformEvent(moveable, nextTransform, inverseDelta, isPinch, e)));
    triggerEvent(moveable, "onRotate", params);
    return params;
  },
  dragControlEnd: function (moveable, e) {
    var datas = e.datas;

    if (!datas.isRotate) {
      return;
    }

    datas.isRotate = false;
    var params = fillEndParams(moveable, e, {});
    triggerEvent(moveable, "onRotateEnd", params);
    return params;
  },
  dragGroupControlCondition: dragControlCondition,
  dragGroupControlStart: function (moveable, e) {
    var datas = e.datas;
    var _a = moveable.state,
        parentLeft = _a.left,
        parentTop = _a.top,
        parentBeforeOrigin = _a.beforeOrigin;
    var params = this.dragControlStart(moveable, e);

    if (!params) {
      return false;
    }

    params.set(datas.beforeDirection * moveable.rotation);
    var events = triggerChildAbles(moveable, this, "dragControlStart", e, function (child, ev) {
      var _a = child.state,
          left = _a.left,
          top = _a.top,
          beforeOrigin = _a.beforeOrigin;
      var childClient = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)([left, top], [parentLeft, parentTop]), (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(beforeOrigin, parentBeforeOrigin));
      ev.datas.groupClient = childClient;
      return __assign(__assign({}, ev), {
        parentRotate: 0
      });
    });

    var nextParams = __assign(__assign({}, params), {
      targets: moveable.props.targets,
      events: events
    });

    var result = triggerEvent(moveable, "onRotateGroupStart", nextParams);
    datas.isRotate = result !== false;
    return datas.isRotate ? params : false;
  },
  dragGroupControl: function (moveable, e) {
    var datas = e.datas;

    if (!datas.isRotate) {
      return;
    }

    var params = this.dragControl(moveable, e);

    if (!params) {
      return;
    }

    var direction = datas.beforeDirection;
    var parentRotate = params.beforeDist;
    var deg = params.beforeDelta;
    var rad = deg / 180 * Math.PI;
    var events = triggerChildAbles(moveable, this, "dragControl", e, function (_, ev) {
      var _a = ev.datas.groupClient,
          prevX = _a[0],
          prevY = _a[1];

      var _b = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.rotate)([prevX, prevY], rad * direction),
          clientX = _b[0],
          clientY = _b[1];

      var delta = [clientX - prevX, clientY - prevY];
      ev.datas.groupClient = [clientX, clientY];
      return __assign(__assign({}, ev), {
        parentRotate: parentRotate,
        groupDelta: delta
      });
    });
    moveable.rotation = direction * params.beforeRotate;

    var nextParams = __assign({
      targets: moveable.props.targets,
      events: events,
      set: function (rotation) {
        moveable.rotation = rotation;
      }
    }, params);

    triggerEvent(moveable, "onRotateGroup", nextParams);
    return nextParams;
  },
  dragGroupControlEnd: function (moveable, e) {
    var isDrag = e.isDrag,
        datas = e.datas;

    if (!datas.isRotate) {
      return;
    }

    this.dragControlEnd(moveable, e);
    var events = triggerChildAbles(moveable, this, "dragControlEnd", e);
    var nextParams = fillEndParams(moveable, e, {
      targets: moveable.props.targets,
      events: events
    });
    triggerEvent(moveable, "onRotateGroupEnd", nextParams);
    return isDrag;
  },

  /**
   * @method Moveable.Rotatable#request
   * @param {object} [e] - the Resizable's request parameter
   * @param {number} [e.deltaRotate=0] -  delta number of rotation
   * @param {number} [e.rotate=0] - absolute number of moveable's rotation
   * @return {Moveable.Requester} Moveable Requester
   * @example
    * // Instantly Request (requestStart - request - requestEnd)
   * moveable.request("rotatable", { deltaRotate: 10 }, true);
   *
   * * moveable.request("rotatable", { rotate: 10 }, true);
   *
   * // requestStart
   * const requester = moveable.request("rotatable");
   *
   * // request
   * requester.request({ deltaRotate: 10 });
   * requester.request({ deltaRotate: 10 });
   * requester.request({ deltaRotate: 10 });
   *
   * requester.request({ rotate: 10 });
   * requester.request({ rotate: 20 });
   * requester.request({ rotate: 30 });
   *
   * // requestEnd
   * requester.requestEnd();
   */
  request: function (moveable) {
    var datas = {};
    var distRotate = 0;
    var startRotation = moveable.getRotation();
    return {
      isControl: true,
      requestStart: function () {
        return {
          datas: datas
        };
      },
      request: function (e) {
        if ("deltaRotate" in e) {
          distRotate += e.deltaRotate;
        } else if ("rotate" in e) {
          distRotate = e.rotate - startRotation;
        }

        return {
          datas: datas,
          parentDist: distRotate
        };
      },
      requestEnd: function () {
        return {
          datas: datas,
          isDrag: true
        };
      }
    };
  }
};
/**
 * Whether or not target can be rotated. (default: false)
 * @name Moveable.Rotatable#rotatable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.rotatable = true;
 */

/**
 * You can specify the position of the rotation. (default: "top")
 * @name Moveable.Rotatable#rotationPosition
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   rotationPosition: "top",
 * });
 *
 * moveable.rotationPosition = "bottom"
 */

/**
 * throttle of angle(degree) when rotate.
 * @name Moveable.Rotatable#throttleRotate
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.throttleRotate = 1;
 */

/**
 * When the rotate starts, the rotateStart event is called.
 * @memberof Moveable.Rotatable
 * @event rotateStart
 * @param {Moveable.Rotatable.OnRotateStart} - Parameters for the rotateStart event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { rotatable: true });
 * moveable.on("rotateStart", ({ target }) => {
 *     console.log(target);
 * });
 */

/**
* When rotating, the rotate event is called.
* @memberof Moveable.Rotatable
* @event rotate
* @param {Moveable.Rotatable.OnRotate} - Parameters for the rotate event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, { rotatable: true });
* moveable.on("rotate", ({ target, transform, dist }) => {
*     target.style.transform = transform;
* });
*/

/**
 * When the rotate finishes, the rotateEnd event is called.
 * @memberof Moveable.Rotatable
 * @event rotateEnd
 * @param {Moveable.Rotatable.OnRotateEnd} - Parameters for the rotateEnd event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { rotatable: true });
 * moveable.on("rotateEnd", ({ target, isDrag }) => {
 *     console.log(target, isDrag);
 * });
 */

/**
 * When the group rotate starts, the `rotateGroupStart` event is called.
 * @memberof Moveable.Rotatable
 * @event rotateGroupStart
 * @param {Moveable.Rotatable.OnRotateGroupStart} - Parameters for the `rotateGroupStart` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 *     rotatable: true
 * });
 * moveable.on("rotateGroupStart", ({ targets }) => {
 *     console.log("onRotateGroupStart", targets);
 * });
 */

/**
* When the group rotate, the `rotateGroup` event is called.
* @memberof Moveable.Rotatable
* @event rotateGroup
* @param {Moveable.Rotatable.OnRotateGroup} - Parameters for the `rotateGroup` event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     target: [].slice.call(document.querySelectorAll(".target")),
*     rotatable: true
* });
* moveable.on("rotateGroup", ({ targets, events }) => {
*     console.log("onRotateGroup", targets);
*     events.forEach(ev => {
*         const target = ev.target;
*         // ev.drag is a drag event that occurs when the group rotate.
*         const left = ev.drag.beforeDist[0];
*         const top = ev.drag.beforeDist[1];
*         const deg = ev.beforeDist;
*     });
* });
*/

/**
 * When the group rotate finishes, the `rotateGroupEnd` event is called.
 * @memberof Moveable.Rotatable
 * @event rotateGroupEnd
 * @param {Moveable.Rotatable.OnRotateGroupEnd} - Parameters for the `rotateGroupEnd` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 *     rotatable: true
 * });
 * moveable.on("rotateGroupEnd", ({ targets, isDrag }) => {
 *     console.log("onRotateGroupEnd", targets, isDrag);
 * });
 */

/**
 * @namespace Resizable
 * @memberof Moveable
 * @description Resizable indicates whether the target's width and height can be increased or decreased.
 */

var Resizable = {
  name: "resizable",
  ableGroup: "size",
  canPinch: true,
  props: {
    resizable: Boolean,
    throttleResize: Number,
    renderDirections: Array,
    keepRatio: Boolean
  },
  events: {
    onResizeStart: "resizeStart",
    onResize: "resize",
    onResizeEnd: "resizeEnd",
    onResizeGroupStart: "resizeGroupStart",
    onResizeGroup: "resizeGroup",
    onResizeGroupEnd: "resizeGroupEnd"
  },
  render: function (moveable, React) {
    var _a = moveable.props,
        resizable = _a.resizable,
        edge = _a.edge;

    if (resizable) {
      if (edge) {
        return renderDiagonalDirections(moveable, React);
      }

      return renderAllDirections(moveable, React);
    }
  },
  dragControlCondition: directionCondition,
  dragControlStart: function (moveable, e) {
    var _a;

    var inputEvent = e.inputEvent,
        isPinch = e.isPinch,
        parentDirection = e.parentDirection,
        datas = e.datas,
        parentFlag = e.parentFlag;
    var direction = parentDirection || (isPinch ? [0, 0] : getDirection(inputEvent.target));
    var _b = moveable.state,
        target = _b.target,
        width = _b.width,
        height = _b.height;

    if (!direction || !target) {
      return false;
    }

    !isPinch && setDragStart(moveable, e);
    datas.datas = {};
    datas.direction = direction;
    datas.startOffsetWidth = width;
    datas.startOffsetHeight = height;
    datas.prevWidth = 0;
    datas.prevHeight = 0;
    _a = getCSSSize(target), datas.startWidth = _a[0], datas.startHeight = _a[1];
    var padding = [Math.max(0, width - datas.startWidth), Math.max(0, height - datas.startHeight)];
    datas.minSize = padding;
    datas.maxSize = [Infinity, Infinity];

    if (!parentFlag) {
      var style = getComputedStyle(target);
      var position = style.position,
          minWidth = style.minWidth,
          minHeight = style.minHeight,
          maxWidth = style.maxWidth,
          maxHeight = style.maxHeight;
      var isParentElement = position === "static" || position === "relative";
      var container = isParentElement ? target.parentElement : target.offsetParent;
      var containerWidth = width;
      var containerHeight = height;

      if (container) {
        containerWidth = container.clientWidth;
        containerHeight = container.clientHeight;

        if (isParentElement) {
          var containerStyle = getComputedStyle(container);
          containerWidth -= parseFloat(containerStyle.paddingLeft) || 0;
          containerHeight -= parseFloat(containerStyle.paddingTop) || 0;
        }
      }

      datas.minSize = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)([(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.convertUnitSize)(minWidth, containerWidth) || 0, (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.convertUnitSize)(minHeight, containerHeight) || 0], padding);
      datas.maxSize = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)([(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.convertUnitSize)(maxWidth, containerWidth) || Infinity, (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.convertUnitSize)(maxHeight, containerHeight) || Infinity], padding);
    }

    var transformOrigin = moveable.props.transformOrigin || "% %";
    datas.transformOrigin = transformOrigin && (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.isString)(transformOrigin) ? transformOrigin.split(" ") : transformOrigin;
    datas.isWidth = !direction[0] && !direction[1] || direction[0] || !direction[1];

    function setRatio(ratio) {
      datas.ratio = ratio && isFinite(ratio) ? ratio : 0;
    }

    function setFixedDirection(fixedDirection) {
      datas.fixedDirection = fixedDirection;
      datas.fixedPosition = getAbsolutePosition(moveable, fixedDirection);
    }

    setRatio(width / height);
    setFixedDirection([-direction[0], -direction[1]]);
    var params = fillParams(moveable, e, {
      direction: direction,
      set: function (_a) {
        var startWidth = _a[0],
            startHeight = _a[1];
        datas.startWidth = startWidth;
        datas.startHeight = startHeight;
      },
      setMin: function (minSize) {
        datas.minSize = minSize;
      },
      setMax: function (maxSize) {
        datas.maxSize = [maxSize[0] || Infinity, maxSize[1] || Infinity];
      },
      setRatio: setRatio,
      setFixedDirection: setFixedDirection,
      setOrigin: function (origin) {
        datas.transformOrigin = origin;
      },
      dragStart: Draggable.dragStart(moveable, new CustomGesto().dragStart([0, 0], e))
    });
    var result = triggerEvent(moveable, "onResizeStart", params);

    if (result !== false) {
      datas.isResize = true;
      moveable.state.snapRenderInfo = {
        request: e.isRequest,
        direction: direction
      };
    }

    return datas.isResize ? params : false;
  },
  dragControl: function (moveable, e) {
    var _a;

    var datas = e.datas,
        distX = e.distX,
        distY = e.distY,
        parentFlag = e.parentFlag,
        isPinch = e.isPinch,
        parentDistance = e.parentDistance,
        parentScale = e.parentScale,
        parentKeepRatio = e.parentKeepRatio,
        dragClient = e.dragClient,
        parentDist = e.parentDist,
        isRequest = e.isRequest;
    var isResize = datas.isResize,
        transformOrigin = datas.transformOrigin,
        fixedDirection = datas.fixedDirection,
        startWidth = datas.startWidth,
        startHeight = datas.startHeight,
        prevWidth = datas.prevWidth,
        prevHeight = datas.prevHeight,
        minSize = datas.minSize,
        maxSize = datas.maxSize,
        ratio = datas.ratio,
        isWidth = datas.isWidth,
        startOffsetWidth = datas.startOffsetWidth,
        startOffsetHeight = datas.startOffsetHeight;

    if (!isResize) {
      return;
    }

    var _b = moveable.props,
        _c = _b.throttleResize,
        throttleResize = _c === void 0 ? 0 : _c,
        parentMoveable = _b.parentMoveable,
        _d = _b.snapThreshold,
        snapThreshold = _d === void 0 ? 5 : _d;
    var direction = datas.direction;
    var sizeDirection = direction;
    var distWidth = 0;
    var distHeight = 0;

    if (!direction[0] && !direction[1]) {
      sizeDirection = [1, 1];
    }

    var keepRatio = ratio && (moveable.props.keepRatio || parentKeepRatio);
    var fixedPosition = dragClient;

    if (!dragClient) {
      if (!parentFlag && isPinch) {
        fixedPosition = getAbsolutePosition(moveable, [0, 0]);
      } else {
        fixedPosition = datas.fixedPosition;
      }
    }

    if (parentDist) {
      distWidth = parentDist[0];
      distHeight = parentDist[1];

      if (keepRatio) {
        if (!distWidth) {
          distWidth = distHeight * ratio;
        } else if (!distHeight) {
          distHeight = distWidth / ratio;
        }
      }
    } else if (parentScale) {
      distWidth = (parentScale[0] - 1) * startOffsetWidth;
      distHeight = (parentScale[1] - 1) * startOffsetHeight;
    } else if (isPinch) {
      if (parentDistance) {
        distWidth = parentDistance;
        distHeight = parentDistance * startOffsetHeight / startOffsetWidth;
      }
    } else {
      var dist = getDragDist({
        datas: datas,
        distX: distX,
        distY: distY
      });
      distWidth = sizeDirection[0] * dist[0];
      distHeight = sizeDirection[1] * dist[1];

      if (keepRatio && startOffsetWidth && startOffsetHeight) {
        var rad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)([0, 0], dist);
        var standardRad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)([0, 0], sizeDirection);
        var size = getDistSize([distWidth, distHeight]);
        var signSize = Math.cos(rad - standardRad) * size;

        if (!sizeDirection[0]) {
          // top, bottom
          distHeight = signSize;
          distWidth = distHeight / ratio;
        } else if (!sizeDirection[1]) {
          // left, right
          distWidth = signSize;
          distHeight = distWidth * ratio;
        } else {
          // two-way
          var startWidthSize = sizeDirection[0] * 2 * startOffsetWidth;
          var startHeightSize = sizeDirection[1] * 2 * startOffsetHeight;
          var distSize = getDistSize([startWidthSize + dist[0], startHeightSize + dist[1]]) - getDistSize([startWidthSize, startHeightSize]);
          var ratioRad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)([0, 0], [ratio, 1]);
          distWidth = Math.cos(ratioRad) * distSize;
          distHeight = Math.sin(ratioRad) * distSize;
        }
      } else if (!keepRatio) {
        var nextDirection = __spreadArray([], direction);

        if (!startOffsetWidth) {
          if (dist[0] < 0) {
            nextDirection[0] = -1;
          } else if (dist[0] > 0) {
            nextDirection[0] = 1;
          }
        }

        if (!startOffsetHeight) {
          if (dist[1] < 0) {
            nextDirection[1] = -1;
          } else if (dist[1] > 0) {
            nextDirection[1] = 1;
          }
        }

        direction = nextDirection;
        sizeDirection = nextDirection;
        distWidth = sizeDirection[0] * dist[0];
        distHeight = sizeDirection[1] * dist[1];
      }
    }

    var nextWidth = sizeDirection[0] || keepRatio ? Math.max(startOffsetWidth + distWidth, TINY_NUM) : startOffsetWidth;
    var nextHeight = sizeDirection[1] || keepRatio ? Math.max(startOffsetHeight + distHeight, TINY_NUM) : startOffsetHeight;

    if (keepRatio && startOffsetWidth && startOffsetHeight) {
      // startOffsetWidth : startOffsetHeight = nextWidth : nextHeight
      if (isWidth) {
        nextHeight = nextWidth / ratio;
      } else {
        nextWidth = nextHeight * ratio;
      }
    }

    var snapDist = [0, 0];

    if (!isPinch) {
      snapDist = checkSnapResize(moveable, nextWidth, nextHeight, direction, fixedPosition, isRequest, datas);
    }

    if (parentDist) {
      !parentDist[0] && (snapDist[0] = 0);
      !parentDist[1] && (snapDist[1] = 0);
    }

    if (keepRatio) {
      if (sizeDirection[0] && sizeDirection[1] && snapDist[0] && snapDist[1]) {
        if (Math.abs(snapDist[0]) > Math.abs(snapDist[1])) {
          snapDist[1] = 0;
        } else {
          snapDist[0] = 0;
        }
      }

      var isNoSnap = !snapDist[0] && !snapDist[1];

      if (isNoSnap) {
        if (isWidth) {
          nextWidth = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(nextWidth, throttleResize);
        } else {
          nextHeight = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(nextHeight, throttleResize);
        }
      }

      if (sizeDirection[0] && !sizeDirection[1] || snapDist[0] && !snapDist[1] || isNoSnap && isWidth) {
        nextWidth += snapDist[0];
        nextHeight = nextWidth / ratio;
      } else if (!sizeDirection[0] && sizeDirection[1] || !snapDist[0] && snapDist[1] || isNoSnap && !isWidth) {
        nextHeight += snapDist[1];
        nextWidth = nextHeight * ratio;
      }
    } else {
      if (startOffsetWidth + distWidth < -snapThreshold) {
        snapDist[0] = 0;
      }

      if (startOffsetWidth + distHeight < -snapThreshold) {
        snapDist[1] = 0;
      }

      nextWidth += snapDist[0];
      nextHeight += snapDist[1];

      if (!snapDist[0]) {
        nextWidth = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(nextWidth, throttleResize);
      }

      if (!snapDist[1]) {
        nextHeight = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(nextHeight, throttleResize);
      }
    }

    _a = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.calculateBoundSize)([nextWidth, nextHeight], minSize, maxSize, keepRatio), nextWidth = _a[0], nextHeight = _a[1];
    nextWidth = Math.round(nextWidth);
    nextHeight = Math.round(nextHeight);
    distWidth = nextWidth - startOffsetWidth;
    distHeight = nextHeight - startOffsetHeight;
    var delta = [distWidth - prevWidth, distHeight - prevHeight];
    datas.prevWidth = distWidth;
    datas.prevHeight = distHeight;
    var inverseDelta = getResizeDist(moveable, nextWidth, nextHeight, fixedDirection, fixedPosition, transformOrigin);

    if (!parentMoveable && delta.every(function (num) {
      return !num;
    }) && inverseDelta.every(function (num) {
      return !num;
    })) {
      return;
    }

    var params = fillParams(moveable, e, {
      width: startWidth + distWidth,
      height: startHeight + distHeight,
      offsetWidth: nextWidth,
      offsetHeight: nextHeight,
      direction: direction,
      dist: [distWidth, distHeight],
      delta: delta,
      isPinch: !!isPinch,
      drag: Draggable.drag(moveable, setCustomDrag(e, moveable.state, inverseDelta, !!isPinch, false))
    });
    triggerEvent(moveable, "onResize", params);
    return params;
  },
  dragControlAfter: function (moveable, e) {
    var datas = e.datas;
    var isResize = datas.isResize,
        startOffsetWidth = datas.startOffsetWidth,
        startOffsetHeight = datas.startOffsetHeight,
        prevWidth = datas.prevWidth,
        prevHeight = datas.prevHeight;

    if (!isResize) {
      return;
    }

    var _a = moveable.state,
        width = _a.width,
        height = _a.height;
    var errorWidth = width - (startOffsetWidth + prevWidth);
    var errorHeight = height - (startOffsetHeight + prevHeight);
    var isErrorWidth = Math.abs(errorWidth) > 3;
    var isErrorHeight = Math.abs(errorHeight) > 3;

    if (isErrorWidth) {
      datas.startWidth += errorWidth;
      datas.startOffsetWidth += errorWidth;
      datas.prevWidth += errorWidth;
    }

    if (isErrorHeight) {
      datas.startHeight += errorHeight;
      datas.startOffsetHeight += errorHeight;
      datas.prevHeight += errorHeight;
    }

    if (isErrorWidth || isErrorHeight) {
      return this.dragControl(moveable, e);
    }
  },
  dragControlEnd: function (moveable, e) {
    var datas = e.datas;

    if (!datas.isResize) {
      return;
    }

    datas.isResize = false;
    var params = fillEndParams(moveable, e, {});
    triggerEvent(moveable, "onResizeEnd", params);
    return params;
  },
  dragGroupControlCondition: directionCondition,
  dragGroupControlStart: function (moveable, e) {
    var datas = e.datas;
    var params = this.dragControlStart(moveable, e);

    if (!params) {
      return false;
    }

    var originalEvents = fillChildEvents(moveable, "resizable", e);

    function setDist(child, ev) {
      var fixedDirection = datas.fixedDirection;
      var fixedPosition = datas.fixedPosition;
      var pos = getAbsolutePosition(child, fixedDirection);

      var _a = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.calculate)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createRotateMatrix)(-moveable.rotation / 180 * Math.PI, 3), [pos[0] - fixedPosition[0], pos[1] - fixedPosition[1], 1], 3),
          originalX = _a[0],
          originalY = _a[1];

      ev.datas.originalX = originalX;
      ev.datas.originalY = originalY;
      return ev;
    }

    var events = triggerChildAbles(moveable, this, "dragControlStart", e, function (child, ev) {
      return setDist(child, ev);
    });

    var nextParams = __assign(__assign({}, params), {
      targets: moveable.props.targets,
      events: events,
      setFixedDirection: function (fixedDirection) {
        params.setFixedDirection(fixedDirection);
        events.forEach(function (ev, i) {
          ev.setFixedDirection(fixedDirection);
          setDist(moveable.moveables[i], originalEvents[i]);
        });
      }
    });

    var result = triggerEvent(moveable, "onResizeGroupStart", nextParams);
    datas.isResize = result !== false;
    return datas.isResize ? params : false;
  },
  dragGroupControl: function (moveable, e) {
    var datas = e.datas;

    if (!datas.isResize) {
      return;
    }

    var params = this.dragControl(moveable, e);

    if (!params) {
      return;
    }

    var offsetWidth = params.offsetWidth,
        offsetHeight = params.offsetHeight,
        dist = params.dist;
    var keepRatio = moveable.props.keepRatio;
    var parentScale = [offsetWidth / (offsetWidth - dist[0]), offsetHeight / (offsetHeight - dist[1])];
    var fixedPosition = datas.fixedPosition;
    var events = triggerChildAbles(moveable, this, "dragControl", e, function (_, ev) {
      var _a = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.calculate)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createRotateMatrix)(moveable.rotation / 180 * Math.PI, 3), [ev.datas.originalX * parentScale[0], ev.datas.originalY * parentScale[1], 1], 3),
          clientX = _a[0],
          clientY = _a[1];

      return __assign(__assign({}, ev), {
        parentDist: null,
        parentScale: parentScale,
        dragClient: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(fixedPosition, [clientX, clientY]),
        parentKeepRatio: keepRatio
      });
    });

    var nextParams = __assign({
      targets: moveable.props.targets,
      events: events
    }, params);

    triggerEvent(moveable, "onResizeGroup", nextParams);
    return nextParams;
  },
  dragGroupControlEnd: function (moveable, e) {
    var isDrag = e.isDrag,
        datas = e.datas;

    if (!datas.isResize) {
      return;
    }

    this.dragControlEnd(moveable, e);
    var events = triggerChildAbles(moveable, this, "dragControlEnd", e);
    var nextParams = fillEndParams(moveable, e, {
      targets: moveable.props.targets,
      events: events
    });
    triggerEvent(moveable, "onResizeGroupEnd", nextParams);
    return isDrag;
  },

  /**
   * @method Moveable.Resizable#request
   * @param {object} [e] - the Resizable's request parameter
   * @param {number} [e.direction=[1, 1]] - Direction to resize
   * @param {number} [e.deltaWidth] - delta number of width
   * @param {number} [e.deltaHeight] - delta number of height
   * @param {number} [e.offsetWidth] - offset number of width
   * @param {number} [e.offsetHeight] - offset number of height
   * @param {number} [e.isInstant] - Whether to execute the request instantly
   * @return {Moveable.Requester} Moveable Requester
   * @example
    * // Instantly Request (requestStart - request - requestEnd)
   * // Use Relative Value
   * moveable.request("resizable", { deltaWidth: 10, deltaHeight: 10 }, true);
   *
   * // Use Absolute Value
   * moveable.request("resizable", { offsetWidth: 100, offsetHeight: 100 }, true);
   *
   * // requestStart
   * const requester = moveable.request("resizable");
   *
   * // request
   * // Use Relative Value
   * requester.request({ deltaWidth: 10, deltaHeight: 10 });
   * requester.request({ deltaWidth: 10, deltaHeight: 10 });
   * requester.request({ deltaWidth: 10, deltaHeight: 10 });
   *
   * // Use Absolute Value
   * moveable.request("resizable", { offsetWidth: 100, offsetHeight: 100 });
   * moveable.request("resizable", { offsetWidth: 110, offsetHeight: 100 });
   * moveable.request("resizable", { offsetWidth: 120, offsetHeight: 100 });
   *
   * // requestEnd
   * requester.requestEnd();
   */
  request: function (moveable) {
    var datas = {};
    var distWidth = 0;
    var distHeight = 0;
    var rect = moveable.getRect();
    return {
      isControl: true,
      requestStart: function (e) {
        return {
          datas: datas,
          parentDirection: e.direction || [1, 1]
        };
      },
      request: function (e) {
        if ("offsetWidth" in e) {
          distWidth = e.offsetWidth - rect.offsetWidth;
        } else if ("deltaWidth" in e) {
          distWidth += e.deltaWidth;
        }

        if ("offsetHeight" in e) {
          distHeight = e.offsetHeight - rect.offsetHeight;
        } else if ("deltaHeight" in e) {
          distHeight += e.deltaHeight;
        }

        return {
          datas: datas,
          parentDist: [distWidth, distHeight]
        };
      },
      requestEnd: function () {
        return {
          datas: datas,
          isDrag: true
        };
      }
    };
  }
};
/**
 * Whether or not target can be resized. (default: false)
 * @name Moveable.Resizable#resizable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     resizable: false,
 * });
 *
 * moveable.resizable = true;
 */

/**
 * throttle of width, height when resize.
 * @name Moveable.Resizable#throttleResize
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   resizable: true,
 *   throttleResize: 0,
 * });
 *
 * moveable.throttleResize = 1;
 */

/**
 * When resize or scale, keeps a ratio of the width, height. (default: false)
 * @name Moveable.Resizable#keepRatio
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   resizable: true,
 * });
 *
 * moveable.keepRatio = true;
 */

/**
 * Set directions to show the control box. (default: ["n", "nw", "ne", "s", "se", "sw", "e", "w"])
 * @name Moveable.Resizable#renderDirections
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   resizable: true,
 *   renderDirections: ["n", "nw", "ne", "s", "se", "sw", "e", "w"],
 * });
 *
 * moveable.renderDirections = ["nw", "ne", "sw", "se"];
 */

/**
 * When the resize starts, the resizeStart event is called.
 * @memberof Moveable.Resizable
 * @event resizeStart
 * @param {Moveable.Resizable.OnResizeStart} - Parameters for the resizeStart event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { resizable: true });
 * moveable.on("resizeStart", ({ target }) => {
 *     console.log(target);
 * });
 */

/**
 * When resizing, the resize event is called.
 * @memberof Moveable.Resizable
 * @event resize
 * @param {Moveable.Resizable.OnResize} - Parameters for the resize event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { resizable: true });
 * moveable.on("resize", ({ target, width, height }) => {
 *     target.style.width = `${e.width}px`;
 *     target.style.height = `${e.height}px`;
 * });
 */

/**
 * When the resize finishes, the resizeEnd event is called.
 * @memberof Moveable.Resizable
 * @event resizeEnd
 * @param {Moveable.Resizable.OnResizeEnd} - Parameters for the resizeEnd event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { resizable: true });
 * moveable.on("resizeEnd", ({ target, isDrag }) => {
 *     console.log(target, isDrag);
 * });
 */

/**
* When the group resize starts, the `resizeGroupStart` event is called.
* @memberof Moveable.Resizable
* @event resizeGroupStart
* @param {Moveable.Resizable.OnResizeGroupStart} - Parameters for the `resizeGroupStart` event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     target: [].slice.call(document.querySelectorAll(".target")),
*     resizable: true
* });
* moveable.on("resizeGroupStart", ({ targets }) => {
*     console.log("onResizeGroupStart", targets);
* });
*/

/**
* When the group resize, the `resizeGroup` event is called.
* @memberof Moveable.Resizable
* @event resizeGroup
* @param {Moveable.Resizable.onResizeGroup} - Parameters for the `resizeGroup` event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     target: [].slice.call(document.querySelectorAll(".target")),
*     resizable: true
* });
* moveable.on("resizeGroup", ({ targets, events }) => {
*     console.log("onResizeGroup", targets);
*     events.forEach(ev => {
*         const offset = [
*             direction[0] < 0 ? -ev.delta[0] : 0,
*             direction[1] < 0 ? -ev.delta[1] : 0,
*         ];
*         // ev.drag is a drag event that occurs when the group resize.
*         const left = offset[0] + ev.drag.beforeDist[0];
*         const top = offset[1] + ev.drag.beforeDist[1];
*         const width = ev.width;
*         const top = ev.top;
*     });
* });
*/

/**
 * When the group resize finishes, the `resizeGroupEnd` event is called.
 * @memberof Moveable.Resizable
 * @event resizeGroupEnd
 * @param {Moveable.Resizable.OnResizeGroupEnd} - Parameters for the `resizeGroupEnd` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 *     resizable: true
 * });
 * moveable.on("resizeGroupEnd", ({ targets, isDrag }) => {
 *     console.log("onResizeGroupEnd", targets, isDrag);
 * });
 */

/**
 * @namespace Scalable
 * @memberof Moveable
 * @description Scalable indicates whether the target's x and y can be scale of transform.
 */

var Scalable = {
  name: "scalable",
  ableGroup: "size",
  canPinch: true,
  props: {
    scalable: Boolean,
    throttleScale: Number,
    renderDirections: String,
    keepRatio: Boolean
  },
  events: {
    onScaleStart: "scaleStart",
    onScale: "scale",
    onScaleEnd: "scaleEnd",
    onScaleGroupStart: "scaleGroupStart",
    onScaleGroup: "scaleGroup",
    onScaleGroupEnd: "scaleGroupEnd"
  },
  render: function (moveable, React) {
    var _a = moveable.props,
        resizable = _a.resizable,
        scalable = _a.scalable,
        edge = _a.edge;

    if (!resizable && scalable) {
      if (edge) {
        return renderDiagonalDirections(moveable, React);
      }

      return renderAllDirections(moveable, React);
    }
  },
  dragControlCondition: directionCondition,
  dragControlStart: function (moveable, e) {
    var datas = e.datas,
        isPinch = e.isPinch,
        inputEvent = e.inputEvent,
        parentDirection = e.parentDirection;
    var direction = parentDirection || (isPinch ? [0, 0] : getDirection(inputEvent.target));
    var _a = moveable.state,
        width = _a.width,
        height = _a.height,
        targetTransform = _a.targetTransform,
        target = _a.target,
        pos1 = _a.pos1,
        pos2 = _a.pos2,
        pos4 = _a.pos4;

    if (!direction || !target) {
      return false;
    }

    if (!isPinch) {
      setDragStart(moveable, e);
    }

    datas.datas = {};
    datas.transform = targetTransform;
    datas.prevDist = [1, 1];
    datas.direction = direction;
    datas.width = width;
    datas.height = height;
    datas.startValue = [1, 1];
    var scaleWidth = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getDist)(pos1, pos2);
    var scaleHeight = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getDist)(pos2, pos4);
    var isWidth = !direction[0] && !direction[1] || direction[0] || !direction[1];
    datas.scaleWidth = scaleWidth;
    datas.scaleHeight = scaleHeight;
    datas.scaleXRatio = scaleWidth / width;
    datas.scaleYRatio = scaleHeight / height;
    setDefaultTransformIndex(e, "scale");
    datas.isWidth = isWidth;

    function setRatio(ratio) {
      datas.ratio = ratio && isFinite(ratio) ? ratio : 0;
    }

    function setFixedDirection(fixedDirection) {
      datas.fixedDirection = fixedDirection;
      datas.fixedPosition = getAbsolutePosition(moveable, fixedDirection);
    }

    setRatio((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getDist)(pos1, pos2) / (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getDist)(pos2, pos4));
    setFixedDirection([-direction[0], -direction[1]]);
    var params = fillParams(moveable, e, __assign(__assign({
      direction: direction,
      set: function (scale) {
        datas.startValue = scale;
      },
      setRatio: setRatio,
      setFixedDirection: setFixedDirection
    }, fillTransformStartEvent(e)), {
      dragStart: Draggable.dragStart(moveable, new CustomGesto().dragStart([0, 0], e))
    }));
    var result = triggerEvent(moveable, "onScaleStart", params);

    if (result !== false) {
      datas.isScale = true;
      moveable.state.snapRenderInfo = {
        request: e.isRequest,
        direction: direction
      };
    }

    return datas.isScale ? params : false;
  },
  dragControl: function (moveable, e) {
    resolveTransformEvent(e, "scale");
    var datas = e.datas,
        distX = e.distX,
        distY = e.distY,
        parentScale = e.parentScale,
        parentDistance = e.parentDistance,
        parentKeepRatio = e.parentKeepRatio,
        parentFlag = e.parentFlag,
        isPinch = e.isPinch,
        dragClient = e.dragClient,
        parentDist = e.parentDist,
        isRequest = e.isRequest;
    var prevDist = datas.prevDist,
        direction = datas.direction,
        width = datas.width,
        height = datas.height,
        isScale = datas.isScale,
        startValue = datas.startValue,
        isWidth = datas.isWidth,
        ratio = datas.ratio,
        fixedDirection = datas.fixedDirection,
        scaleXRatio = datas.scaleXRatio,
        scaleYRatio = datas.scaleYRatio;

    if (!isScale) {
      return false;
    }

    var _a = moveable.props,
        throttleScale = _a.throttleScale,
        parentMoveable = _a.parentMoveable;
    var sizeDirection = direction;

    if (!direction[0] && !direction[1]) {
      sizeDirection = [1, 1];
    }

    var keepRatio = ratio && (moveable.props.keepRatio || parentKeepRatio);
    var state = moveable.state;
    var scaleX = 1;
    var scaleY = 1;
    var fixedPosition = dragClient;

    if (!dragClient) {
      if (!parentFlag && isPinch) {
        fixedPosition = getAbsolutePosition(moveable, [0, 0]);
      } else {
        fixedPosition = datas.fixedPosition;
      }
    }

    if (parentDist) {
      scaleX = (width + parentDist[0]) / width;
      scaleY = (height + parentDist[1]) / height;
    } else if (parentScale) {
      scaleX = parentScale[0];
      scaleY = parentScale[1];
    } else if (isPinch) {
      if (parentDistance) {
        scaleX = (width + parentDistance) / width;
        scaleY = (height + parentDistance * height / width) / height;
      }
    } else {
      var dragDist = getDragDist({
        datas: datas,
        distX: distX,
        distY: distY
      });
      var distScaleWidth = sizeDirection[0] * dragDist[0] * scaleXRatio;
      var distScaleHeight = sizeDirection[1] * dragDist[1] * scaleYRatio;

      if (keepRatio && width && height) {
        if (!sizeDirection[0]) {
          // top, bottom
          // distHeight = signSize;
          distScaleWidth = distScaleHeight * ratio;
        } else if (!sizeDirection[1]) {
          // left, right
          // distWidth = signSize;
          distScaleHeight = distScaleWidth / ratio;
        } else {
          var size = getDistSize([distScaleWidth, distScaleHeight]); // two-way

          var dragRad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)([0, 0], dragDist);
          var standardRad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)([0, 0], sizeDirection);
          var signSize = Math.cos(dragRad - standardRad) * size;
          var ratioRad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)([0, 0], [ratio, 1]);
          distScaleWidth = Math.cos(ratioRad) * signSize;
          distScaleHeight = Math.sin(ratioRad) * signSize;
        }
      }

      scaleX = (width + distScaleWidth / scaleXRatio) / width;
      scaleY = (height + distScaleHeight / scaleYRatio) / height;
    }

    scaleX = sizeDirection[0] || keepRatio ? scaleX * startValue[0] : startValue[0];
    scaleY = sizeDirection[1] || keepRatio ? scaleY * startValue[1] : startValue[1];

    if (scaleX === 0) {
      scaleX = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;
    }

    if (scaleY === 0) {
      scaleY = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;
    }

    var dist = [scaleX / startValue[0], scaleY / startValue[1]];
    var scale = [scaleX, scaleY];

    if (!isPinch && moveable.props.groupable) {
      var snapRenderInfo = state.snapRenderInfo || {};
      var stateDirection = snapRenderInfo.direction;

      if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.isArray)(stateDirection) && (stateDirection[0] || stateDirection[1])) {
        state.snapRenderInfo = {
          direction: direction,
          request: e.isRequest
        };
      }
    }

    var snapDist = [0, 0];

    if (!isPinch) {
      snapDist = checkSnapScale(moveable, dist, direction, isRequest, datas);
    }

    if (keepRatio) {
      if (sizeDirection[0] && sizeDirection[1] && snapDist[0] && snapDist[1]) {
        if (Math.abs(snapDist[0] * width) > Math.abs(snapDist[1] * height)) {
          snapDist[1] = 0;
        } else {
          snapDist[0] = 0;
        }
      }

      var isNoSnap = !snapDist[0] && !snapDist[1];

      if (isNoSnap) {
        if (isWidth) {
          dist[0] = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(dist[0] * startValue[0], throttleScale) / startValue[0];
        } else {
          dist[1] = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(dist[1] * startValue[1], throttleScale) / startValue[1];
        }
      }

      if (sizeDirection[0] && !sizeDirection[1] || snapDist[0] && !snapDist[1] || isNoSnap && isWidth) {
        dist[0] += snapDist[0];
        var snapHeight = width * dist[0] * startValue[0] / ratio;
        dist[1] = snapHeight / height / startValue[1];
      } else if (!sizeDirection[0] && sizeDirection[1] || !snapDist[0] && snapDist[1] || isNoSnap && !isWidth) {
        dist[1] += snapDist[1];
        var snapWidth = height * dist[1] * startValue[1] * ratio;
        dist[0] = snapWidth / width / startValue[0];
      }
    } else {
      dist[0] += snapDist[0];
      dist[1] += snapDist[1];

      if (!snapDist[0]) {
        dist[0] = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(dist[0] * startValue[0], throttleScale) / startValue[0];
      }

      if (!snapDist[1]) {
        dist[1] = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(dist[1] * startValue[1], throttleScale) / startValue[1];
      }
    }

    if (dist[0] === 0) {
      dist[0] = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;
    }

    if (dist[1] === 0) {
      dist[1] = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;
    }

    var delta = [dist[0] / prevDist[0], dist[1] / prevDist[1]];
    scale = multiply2(dist, startValue);
    var inverseDist = getScaleDist(moveable, dist, fixedDirection, fixedPosition, datas);
    var inverseDelta = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(inverseDist, datas.prevInverseDist || [0, 0]);
    datas.prevDist = dist;
    datas.prevInverseDist = inverseDist;

    if (scaleX === prevDist[0] && scaleY === prevDist[1] && inverseDelta.every(function (num) {
      return !num;
    }) && !parentMoveable) {
      return false;
    }

    var nextTransform = convertTransformFormat(datas, "scale(" + scale.join(", ") + ")", "scale(" + dist.join(", ") + ")");
    var params = fillParams(moveable, e, __assign({
      offsetWidth: width,
      offsetHeight: height,
      direction: direction,
      // beforeScale,
      // beforeDist,
      // beforeDelta,
      scale: scale,
      dist: dist,
      delta: delta,
      isPinch: !!isPinch
    }, fillTransformEvent(moveable, nextTransform, inverseDelta, isPinch, e)));
    triggerEvent(moveable, "onScale", params);
    return params;
  },
  dragControlEnd: function (moveable, e) {
    var datas = e.datas,
        isDrag = e.isDrag;

    if (!datas.isScale) {
      return false;
    }

    datas.isScale = false;
    triggerEvent(moveable, "onScaleEnd", fillEndParams(moveable, e, {}));
    return isDrag;
  },
  dragGroupControlCondition: directionCondition,
  dragGroupControlStart: function (moveable, e) {
    var datas = e.datas;
    var params = this.dragControlStart(moveable, e);

    if (!params) {
      return false;
    }

    var originalEvents = fillChildEvents(moveable, "resizable", e);

    function setDist(child, ev) {
      var fixedDirection = datas.fixedDirection;
      var fixedPosition = datas.fixedPosition;
      var pos = getAbsolutePosition(child, fixedDirection);

      var _a = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.calculate)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createRotateMatrix)(-moveable.rotation / 180 * Math.PI, 3), [pos[0] - fixedPosition[0], pos[1] - fixedPosition[1], 1], 3),
          originalX = _a[0],
          originalY = _a[1];

      ev.datas.originalX = originalX;
      ev.datas.originalY = originalY;
      return ev;
    }

    datas.moveableScale = moveable.scale;
    var events = triggerChildAbles(moveable, this, "dragControlStart", e, function (child, ev) {
      return setDist(child, ev);
    });

    var nextParams = __assign(__assign({}, params), {
      targets: moveable.props.targets,
      events: events,
      setFixedDirection: function (fixedDirection) {
        params.setFixedDirection(fixedDirection);
        events.forEach(function (ev, i) {
          ev.setFixedDirection(fixedDirection);
          setDist(moveable.moveables[i], originalEvents[i]);
        });
      }
    });

    var result = triggerEvent(moveable, "onScaleGroupStart", nextParams);
    datas.isScale = result !== false;
    return datas.isScale ? nextParams : false;
  },
  dragGroupControl: function (moveable, e) {
    var datas = e.datas;

    if (!datas.isScale) {
      return;
    }

    var params = this.dragControl(moveable, e);

    if (!params) {
      return;
    }

    var moveableScale = datas.moveableScale;
    moveable.scale = [params.scale[0] * moveableScale[0], params.scale[1] * moveableScale[1]];
    var keepRatio = moveable.props.keepRatio;
    var dist = params.dist,
        scale = params.scale;
    var fixedPosition = datas.fixedPosition;
    var events = triggerChildAbles(moveable, this, "dragControl", e, function (_, ev) {
      var _a = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.calculate)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createRotateMatrix)(moveable.rotation / 180 * Math.PI, 3), [ev.datas.originalX * dist[0], ev.datas.originalY * dist[1], 1], 3),
          clientX = _a[0],
          clientY = _a[1];

      return __assign(__assign({}, ev), {
        parentDist: null,
        parentScale: scale,
        parentKeepRatio: keepRatio,
        dragClient: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(fixedPosition, [clientX, clientY])
      });
    });

    var nextParams = __assign({
      targets: moveable.props.targets,
      events: events
    }, params);

    triggerEvent(moveable, "onScaleGroup", nextParams);
    return nextParams;
  },
  dragGroupControlEnd: function (moveable, e) {
    var isDrag = e.isDrag,
        datas = e.datas;

    if (!datas.isScale) {
      return;
    }

    this.dragControlEnd(moveable, e);
    var events = triggerChildAbles(moveable, this, "dragControlEnd", e);
    var nextParams = fillEndParams(moveable, e, {
      targets: moveable.props.targets,
      events: events
    });
    triggerEvent(moveable, "onScaleGroupEnd", nextParams);
    return isDrag;
  },

  /**
   * @method Moveable.Scalable#request
   * @param {object} [e] - the Resizable's request parameter
   * @param {number} [e.direction=[1, 1]] - Direction to scale
   * @param {number} [e.deltaWidth] - delta number of width
   * @param {number} [e.deltaHeight] - delta number of height
   * @return {Moveable.Requester} Moveable Requester
   * @example
    * // Instantly Request (requestStart - request - requestEnd)
   * moveable.request("scalable", { deltaWidth: 10, deltaHeight: 10 }, true);
   *
   * // requestStart
   * const requester = moveable.request("scalable");
   *
   * // request
   * requester.request({ deltaWidth: 10, deltaHeight: 10 });
   * requester.request({ deltaWidth: 10, deltaHeight: 10 });
   * requester.request({ deltaWidth: 10, deltaHeight: 10 });
   *
   * // requestEnd
   * requester.requestEnd();
   */
  request: function () {
    var datas = {};
    var distWidth = 0;
    var distHeight = 0;
    return {
      isControl: true,
      requestStart: function (e) {
        return {
          datas: datas,
          parentDirection: e.direction || [1, 1]
        };
      },
      request: function (e) {
        distWidth += e.deltaWidth;
        distHeight += e.deltaHeight;
        return {
          datas: datas,
          parentDist: [distWidth, distHeight]
        };
      },
      requestEnd: function () {
        return {
          datas: datas,
          isDrag: true
        };
      }
    };
  }
};
/**
 * Whether or not target can scaled. (default: false)
 * @name Moveable.Scalable#scalable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.scalable = true;
 */

/**
 * throttle of scaleX, scaleY when scale.
 * @name Moveable.Scalable#throttleScale
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.throttleScale = 0.1;
 */

/**
 * Set directions to show the control box. (default: ["n", "nw", "ne", "s", "se", "sw", "e", "w"])
 * @name Moveable.Scalable#renderDirections
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     scalable: true,
 *   renderDirections: ["n", "nw", "ne", "s", "se", "sw", "e", "w"],
 * });
 *
 * moveable.renderDirections = ["nw", "ne", "sw", "se"];
 */

/**
 * When resize or scale, keeps a ratio of the width, height. (default: false)
 * @name Moveable.Scalable#keepRatio
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     scalable: true,
 * });
 *
 * moveable.keepRatio = true;
 */

/**
 * When the scale starts, the scaleStart event is called.
 * @memberof Moveable.Scalable
 * @event scaleStart
 * @param {Moveable.Scalable.OnScaleStart} - Parameters for the scaleStart event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { scalable: true });
 * moveable.on("scaleStart", ({ target }) => {
 *     console.log(target);
 * });
 */

/**
 * When scaling, the scale event is called.
 * @memberof Moveable.Scalable
 * @event scale
 * @param {Moveable.Scalable.OnScale} - Parameters for the scale event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { scalable: true });
 * moveable.on("scale", ({ target, transform, dist }) => {
 *     target.style.transform = transform;
 * });
 */

/**
 * When the scale finishes, the scaleEnd event is called.
 * @memberof Moveable.Scalable
 * @event scaleEnd
 * @param {Moveable.Scalable.OnScaleEnd} - Parameters for the scaleEnd event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { scalable: true });
 * moveable.on("scaleEnd", ({ target, isDrag }) => {
 *     console.log(target, isDrag);
 * });
 */

/**
* When the group scale starts, the `scaleGroupStart` event is called.
* @memberof Moveable.Scalable
* @event scaleGroupStart
* @param {Moveable.Scalable.OnScaleGroupStart} - Parameters for the `scaleGroupStart` event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     target: [].slice.call(document.querySelectorAll(".target")),
*     scalable: true
* });
* moveable.on("scaleGroupStart", ({ targets }) => {
*     console.log("onScaleGroupStart", targets);
* });
*/

/**
* When the group scale, the `scaleGroup` event is called.
* @memberof Moveable.Scalable
* @event scaleGroup
* @param {Moveable.Scalable.OnScaleGroup} - Parameters for the `scaleGroup` event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     target: [].slice.call(document.querySelectorAll(".target")),
*     scalable: true
* });
* moveable.on("scaleGroup", ({ targets, events }) => {
*     console.log("onScaleGroup", targets);
*     events.forEach(ev => {
*         const target = ev.target;
*         // ev.drag is a drag event that occurs when the group scale.
*         const left = ev.drag.beforeDist[0];
*         const top = ev.drag.beforeDist[1];
*         const scaleX = ev.scale[0];
*         const scaleY = ev.scale[1];
*     });
* });
*/

/**
 * When the group scale finishes, the `scaleGroupEnd` event is called.
 * @memberof Moveable.Scalable
 * @event scaleGroupEnd
 * @param {Moveable.Scalable.OnScaleGroupEnd} - Parameters for the `scaleGroupEnd` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 *     scalable: true
 * });
 * moveable.on("scaleGroupEnd", ({ targets, isDrag }) => {
 *     console.log("onScaleGroupEnd", targets, isDrag);
 * });
 */

function getMiddleLinePos(pos1, pos2) {
  return pos1.map(function (pos, i) {
    return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.dot)(pos, pos2[i], 1, 2);
  });
}

function getTriangleRad(pos1, pos2, pos3) {
  // pos1 Rad
  var rad1 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)(pos1, pos2);
  var rad2 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)(pos1, pos3);
  var rad = rad2 - rad1;
  return rad >= 0 ? rad : rad + 2 * Math.PI;
}

function isValidPos(poses1, poses2) {
  var rad1 = getTriangleRad(poses1[0], poses1[1], poses1[2]);
  var rad2 = getTriangleRad(poses2[0], poses2[1], poses2[2]);
  var pi = Math.PI;

  if (rad1 >= pi && rad2 <= pi || rad1 <= pi && rad2 >= pi) {
    return false;
  }

  return true;
}
/**
 * @namespace Moveable.Warpable
 * @description Warpable indicates whether the target can be warped(distorted, bented).
 */


var Warpable = {
  name: "warpable",
  ableGroup: "size",
  props: {
    warpable: Boolean,
    renderDirections: Array
  },
  events: {
    onWarpStart: "warpStart",
    onWarp: "warp",
    onWarpEnd: "warpEnd"
  },
  render: function (moveable, React) {
    var _a = moveable.props,
        resizable = _a.resizable,
        scalable = _a.scalable,
        warpable = _a.warpable,
        zoom = _a.zoom;

    if (resizable || scalable || !warpable) {
      return [];
    }

    var _b = moveable.state,
        pos1 = _b.pos1,
        pos2 = _b.pos2,
        pos3 = _b.pos3,
        pos4 = _b.pos4;
    var linePosFrom1 = getMiddleLinePos(pos1, pos2);
    var linePosFrom2 = getMiddleLinePos(pos2, pos1);
    var linePosFrom3 = getMiddleLinePos(pos1, pos3);
    var linePosFrom4 = getMiddleLinePos(pos3, pos1);
    var linePosTo1 = getMiddleLinePos(pos3, pos4);
    var linePosTo2 = getMiddleLinePos(pos4, pos3);
    var linePosTo3 = getMiddleLinePos(pos2, pos4);
    var linePosTo4 = getMiddleLinePos(pos4, pos2);
    return __spreadArray([React.createElement("div", {
      className: prefix("line"),
      key: "middeLine1",
      style: getLineStyle(linePosFrom1, linePosTo1, zoom)
    }), React.createElement("div", {
      className: prefix("line"),
      key: "middeLine2",
      style: getLineStyle(linePosFrom2, linePosTo2, zoom)
    }), React.createElement("div", {
      className: prefix("line"),
      key: "middeLine3",
      style: getLineStyle(linePosFrom3, linePosTo3, zoom)
    }), React.createElement("div", {
      className: prefix("line"),
      key: "middeLine4",
      style: getLineStyle(linePosFrom4, linePosTo4, zoom)
    })], renderAllDirections(moveable, React));
  },
  dragControlCondition: function (moveable, e) {
    if (e.isRequest) {
      return false;
    }

    return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.hasClass)(e.inputEvent.target, prefix("direction"));
  },
  dragControlStart: function (moveable, e) {
    var datas = e.datas,
        inputEvent = e.inputEvent;
    var target = moveable.props.target;
    var inputTarget = inputEvent.target;
    var direction = getDirection(inputTarget);

    if (!direction || !target) {
      return false;
    }

    var state = moveable.state;
    var transformOrigin = state.transformOrigin,
        is3d = state.is3d,
        targetTransform = state.targetTransform,
        targetMatrix = state.targetMatrix,
        width = state.width,
        height = state.height,
        left = state.left,
        top = state.top;
    datas.datas = {};
    datas.targetTransform = targetTransform;
    datas.warpTargetMatrix = is3d ? targetMatrix : (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.convertDimension)(targetMatrix, 3, 4);
    datas.targetInverseMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.ignoreDimension)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.invert)(datas.warpTargetMatrix, 4), 3, 4);
    datas.direction = direction;
    datas.left = left;
    datas.top = top;
    datas.poses = [[0, 0], [width, 0], [0, height], [width, height]].map(function (p) {
      return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(p, transformOrigin);
    });
    datas.nextPoses = datas.poses.map(function (_a) {
      var x = _a[0],
          y = _a[1];
      return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.calculate)(datas.warpTargetMatrix, [x, y, 0, 1], 4);
    });
    datas.startValue = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createIdentityMatrix)(4);
    datas.prevMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createIdentityMatrix)(4);
    datas.absolutePoses = getAbsolutePosesByState(state);
    datas.posIndexes = getPosIndexesByDirection(direction);
    setDragStart(moveable, e);
    setDefaultTransformIndex(e, "matrix3d");
    state.snapRenderInfo = {
      request: e.isRequest,
      direction: direction
    };
    var params = fillParams(moveable, e, __assign({
      set: function (matrix) {
        datas.startValue = matrix;
      }
    }, fillTransformStartEvent(e)));
    var result = triggerEvent(moveable, "onWarpStart", params);

    if (result !== false) {
      datas.isWarp = true;
    }

    return datas.isWarp;
  },
  dragControl: function (moveable, e) {
    var datas = e.datas,
        isRequest = e.isRequest;
    var distX = e.distX,
        distY = e.distY;
    var targetInverseMatrix = datas.targetInverseMatrix,
        prevMatrix = datas.prevMatrix,
        isWarp = datas.isWarp,
        startValue = datas.startValue,
        poses = datas.poses,
        posIndexes = datas.posIndexes,
        absolutePoses = datas.absolutePoses;

    if (!isWarp) {
      return false;
    }

    resolveTransformEvent(e, "matrix3d");

    if (hasGuidelines(moveable, "warpable")) {
      var selectedPoses = posIndexes.map(function (index) {
        return absolutePoses[index];
      });

      if (selectedPoses.length > 1) {
        selectedPoses.push([(selectedPoses[0][0] + selectedPoses[1][0]) / 2, (selectedPoses[0][1] + selectedPoses[1][1]) / 2]);
      }

      var _a = checkMoveableSnapBounds(moveable, isRequest, {
        horizontal: selectedPoses.map(function (pos) {
          return pos[1] + distY;
        }),
        vertical: selectedPoses.map(function (pos) {
          return pos[0] + distX;
        })
      }),
          horizontalSnapInfo = _a.horizontal,
          verticalSnapInfo = _a.vertical;

      distY -= horizontalSnapInfo.offset;
      distX -= verticalSnapInfo.offset;
    }

    var dist = getDragDist({
      datas: datas,
      distX: distX,
      distY: distY
    }, true);
    var nextPoses = datas.nextPoses.slice();
    posIndexes.forEach(function (index) {
      nextPoses[index] = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(nextPoses[index], dist);
    });

    if (!NEARBY_POS.every(function (nearByPoses) {
      return isValidPos(nearByPoses.map(function (i) {
        return poses[i];
      }), nearByPoses.map(function (i) {
        return nextPoses[i];
      }));
    })) {
      return false;
    }

    var h = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createWarpMatrix)(poses[0], poses[2], poses[1], poses[3], nextPoses[0], nextPoses[2], nextPoses[1], nextPoses[3]);

    if (!h.length) {
      return false;
    } // B * A * M


    var afterMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.multiply)(targetInverseMatrix, h, 4); // B * M * A

    var matrix = getTransfromMatrix(datas, afterMatrix, true);
    var delta = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.multiply)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.invert)(prevMatrix, 4), matrix, 4);
    datas.prevMatrix = matrix;
    var totalMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.multiply)(startValue, matrix, 4);
    var nextTransform = convertTransformFormat(datas, "matrix3d(" + totalMatrix.join(", ") + ")", "matrix3d(" + matrix.join(", ") + ")");
    fillOriginalTransform(e, nextTransform);
    triggerEvent(moveable, "onWarp", fillParams(moveable, e, {
      delta: delta,
      matrix: totalMatrix,
      dist: matrix,
      multiply: _scena_matrix__WEBPACK_IMPORTED_MODULE_3__.multiply,
      transform: nextTransform
    }));
    return true;
  },
  dragControlEnd: function (moveable, e) {
    var datas = e.datas,
        isDrag = e.isDrag;

    if (!datas.isWarp) {
      return false;
    }

    datas.isWarp = false;
    triggerEvent(moveable, "onWarpEnd", fillEndParams(moveable, e, {}));
    return isDrag;
  }
};
/**
 * Whether or not target can be warped. (default: false)
 * @name Moveable.Warpable#warpable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.warpable = true;
 */

/**
* Set directions to show the control box. (default: ["n", "nw", "ne", "s", "se", "sw", "e", "w"])
* @name Moveable.Warpable#renderDirections
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     warpable: true,
*     renderDirections: ["n", "nw", "ne", "s", "se", "sw", "e", "w"],
* });
*
* moveable.renderDirections = ["nw", "ne", "sw", "se"];
*/

/**
* When the warp starts, the warpStart event is called.
* @memberof Moveable.Warpable
* @event warpStart
* @param {Moveable.Warpable.OnWarpStart} - Parameters for the warpStart event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, { warpable: true });
* moveable.on("warpStart", ({ target }) => {
*     console.log(target);
* });
*/

/**
 * When warping, the warp event is called.
 * @memberof Moveable.Warpable
 * @event warp
 * @param {Moveable.Warpable.OnWarp} - Parameters for the warp event
 * @example
 * import Moveable from "moveable";
 * let matrix = [
 *  1, 0, 0, 0,
 *  0, 1, 0, 0,
 *  0, 0, 1, 0,
 *  0, 0, 0, 1,
 * ];
 * const moveable = new Moveable(document.body, { warpable: true });
 * moveable.on("warp", ({ target, transform, delta, multiply }) => {
 *    // target.style.transform = transform;
 *    matrix = multiply(matrix, delta);
 *    target.style.transform = `matrix3d(${matrix.join(",")})`;
 * });
 */

/**
 * When the warp finishes, the warpEnd event is called.
 * @memberof Moveable.Warpable
 * @event warpEnd
 * @param {Moveable.Warpable.OnWarpEnd} - Parameters for the warpEnd event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { warpable: true });
 * moveable.on("warpEnd", ({ target, isDrag }) => {
 *     console.log(target, isDrag);
 * });
 */

var AREA_PIECES = /*#__PURE__*/prefix("area-pieces");
var AREA_PIECE = /*#__PURE__*/prefix("area-piece");
var AVOID = /*#__PURE__*/prefix("avoid");

function restoreStyle(moveable) {
  var el = moveable.areaElement;
  var _a = moveable.state,
      width = _a.width,
      height = _a.height;
  (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.removeClass)(el, AVOID);
  el.style.cssText += "left: 0px; top: 0px; width: " + width + "px; height: " + height + "px";
}

function renderPieces(React) {
  return React.createElement("div", {
    key: "area_pieces",
    className: AREA_PIECES
  }, React.createElement("div", {
    className: AREA_PIECE
  }), React.createElement("div", {
    className: AREA_PIECE
  }), React.createElement("div", {
    className: AREA_PIECE
  }), React.createElement("div", {
    className: AREA_PIECE
  }));
}

var DragArea = {
  name: "dragArea",
  props: {
    dragArea: Boolean,
    passDragArea: Boolean
  },
  events: {
    onClick: "click",
    onClickGroup: "clickGroup"
  },
  render: function (moveable, React) {
    var _a = moveable.props,
        target = _a.target,
        dragArea = _a.dragArea,
        groupable = _a.groupable,
        passDragArea = _a.passDragArea;
    var _b = moveable.state,
        width = _b.width,
        height = _b.height,
        renderPoses = _b.renderPoses;
    var className = passDragArea ? prefix("area", "pass") : prefix("area");

    if (groupable) {
      return [React.createElement("div", {
        key: "area",
        ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_1__.ref)(moveable, "areaElement"),
        className: className
      }), renderPieces(React)];
    }

    if (!target || !dragArea) {
      return [];
    }

    var h = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createWarpMatrix)([0, 0], [width, 0], [0, height], [width, height], renderPoses[0], renderPoses[1], renderPoses[2], renderPoses[3]);
    var transform = h.length ? makeMatrixCSS(h, true) : "none";
    return [React.createElement("div", {
      key: "area",
      ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_1__.ref)(moveable, "areaElement"),
      className: className,
      style: {
        top: "0px",
        left: "0px",
        width: width + "px",
        height: height + "px",
        transformOrigin: "0 0",
        transform: transform
      }
    }), renderPieces(React)];
  },
  dragStart: function (moveable, _a) {
    var datas = _a.datas,
        clientX = _a.clientX,
        clientY = _a.clientY,
        inputEvent = _a.inputEvent;

    if (!inputEvent) {
      return false;
    }

    datas.isDragArea = false;
    var areaElement = moveable.areaElement;
    var state = moveable.state;
    var moveableClientRect = state.moveableClientRect,
        renderPoses = state.renderPoses,
        rootMatrix = state.rootMatrix,
        is3d = state.is3d;
    var left = moveableClientRect.left,
        top = moveableClientRect.top;

    var _b = getRect(renderPoses),
        relativeLeft = _b.left,
        relativeTop = _b.top,
        width = _b.width,
        height = _b.height;

    var n = is3d ? 4 : 3;

    var _c = calculateInversePosition(rootMatrix, [clientX - left, clientY - top], n),
        posX = _c[0],
        posY = _c[1];

    posX -= relativeLeft;
    posY -= relativeTop;
    var rects = [{
      left: relativeLeft,
      top: relativeTop,
      width: width,
      height: posY - 10
    }, {
      left: relativeLeft,
      top: relativeTop,
      width: posX - 10,
      height: height
    }, {
      left: relativeLeft,
      top: relativeTop + posY + 10,
      width: width,
      height: height - posY - 10
    }, {
      left: relativeLeft + posX + 10,
      top: relativeTop,
      width: width - posX - 10,
      height: height
    }];
    var children = [].slice.call(areaElement.nextElementSibling.children);
    rects.forEach(function (rect, i) {
      children[i].style.cssText = "left: " + rect.left + "px;top: " + rect.top + "px; width: " + rect.width + "px; height: " + rect.height + "px;";
    });
    (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.addClass)(areaElement, AVOID);
    state.disableNativeEvent = true;
    return;
  },
  drag: function (moveable, _a) {
    var datas = _a.datas,
        inputEvent = _a.inputEvent;
    this.enableNativeEvent(moveable);

    if (!inputEvent) {
      return false;
    }

    if (!datas.isDragArea) {
      datas.isDragArea = true;
      restoreStyle(moveable);
    }
  },
  dragEnd: function (moveable, e) {
    this.enableNativeEvent(moveable);
    var inputEvent = e.inputEvent,
        datas = e.datas;

    if (!inputEvent) {
      return false;
    }

    if (!datas.isDragArea) {
      restoreStyle(moveable);
    }
  },
  dragGroupStart: function (moveable, e) {
    return this.dragStart(moveable, e);
  },
  dragGroup: function (moveable, e) {
    return this.drag(moveable, e);
  },
  dragGroupEnd: function (moveable, e) {
    return this.dragEnd(moveable, e);
  },
  unset: function (moveable) {
    restoreStyle(moveable);
    moveable.state.disableNativeEvent = false;
  },
  enableNativeEvent: function (moveable) {
    var state = moveable.state;

    if (state.disableNativeEvent) {
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.requestAnimationFrame)(function () {
        state.disableNativeEvent = false;
      });
    }
  }
};
/**
 * Add an event to the moveable area instead of the target for stopPropagation. (default: false, true in group)
 * @name Moveable#dragArea
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *  dragArea: false,
 * });
 */

/**
 * Set `pointerEvents: none;` css to pass events in dragArea. (default: false)
 * @name Moveable#passDragArea
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *  dragArea: false,
 * });
 */

var Origin = makeAble("origin", {
  render: function (moveable, React) {
    var zoom = moveable.props.zoom;
    var _a = moveable.state,
        beforeOrigin = _a.beforeOrigin,
        rotation = _a.rotation;
    return [React.createElement("div", {
      className: prefix("control", "origin"),
      style: getControlTransform(rotation, zoom, beforeOrigin),
      key: "beforeOrigin"
    })];
  }
});
/**
 * Whether or not the origin controlbox will be visible or not (default: true)
 * @name Moveable#origin
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.origin = true;
 */

function getDefaultScrollPosition(e) {
  var scrollContainer = e.scrollContainer;
  return [scrollContainer.scrollLeft, scrollContainer.scrollTop];
}
/**
 * @namespace Moveable.Scrollable
 * @description Whether or not target can be scrolled to the scroll container (default: false)
 */


var Scrollable = {
  name: "scrollable",
  canPinch: true,
  props: {
    scrollable: Boolean,
    scrollContainer: Object,
    scrollThreshold: Number,
    getScrollPosition: Function
  },
  events: {
    onScroll: "scroll",
    onScrollGroup: "scrollGroup"
  },
  dragRelation: "strong",
  dragStart: function (moveable, e) {
    var props = moveable.props;
    var _a = props.scrollContainer,
        scrollContainer = _a === void 0 ? moveable.getContainer() : _a;
    var dragScroll = new _scena_dragscroll__WEBPACK_IMPORTED_MODULE_7__["default"]();
    var scrollContainerElement = getRefTarget(scrollContainer, true);
    e.datas.dragScroll = dragScroll;
    var gestoName = e.isControl ? "controlGesto" : "targetGesto";
    var targets = e.targets;
    dragScroll.on("scroll", function (_a) {
      var container = _a.container,
          direction = _a.direction;
      var params = fillParams(moveable, e, {
        scrollContainer: container,
        direction: direction
      });
      var eventName = targets ? "onScrollGroup" : "onScroll";

      if (targets) {
        params.targets = targets;
      }

      triggerEvent(moveable, eventName, params);
    }).on("move", function (_a) {
      var offsetX = _a.offsetX,
          offsetY = _a.offsetY;
      moveable[gestoName].scrollBy(offsetX, offsetY, e.inputEvent, false);
    });
    dragScroll.dragStart(e, {
      container: scrollContainerElement
    });
  },
  checkScroll: function (moveable, e) {
    var dragScroll = e.datas.dragScroll;

    if (!dragScroll) {
      return;
    }

    var _a = moveable.props,
        _b = _a.scrollContainer,
        scrollContainer = _b === void 0 ? moveable.getContainer() : _b,
        _c = _a.scrollThreshold,
        scrollThreshold = _c === void 0 ? 0 : _c,
        _d = _a.getScrollPosition,
        getScrollPosition = _d === void 0 ? getDefaultScrollPosition : _d;
    dragScroll.drag(e, {
      container: scrollContainer,
      threshold: scrollThreshold,
      getScrollPosition: function (ev) {
        return getScrollPosition({
          scrollContainer: ev.container,
          direction: ev.direction
        });
      }
    });
    return true;
  },
  drag: function (moveable, e) {
    return this.checkScroll(moveable, e);
  },
  dragEnd: function (moveable, e) {
    e.datas.dragScroll.dragEnd();
    e.datas.dragScroll = null;
  },
  dragControlStart: function (moveable, e) {
    return this.dragStart(moveable, __assign(__assign({}, e), {
      isControl: true
    }));
  },
  dragControl: function (moveable, e) {
    return this.drag(moveable, e);
  },
  dragControlEnd: function (moveable, e) {
    return this.dragEnd(moveable, e);
  },
  dragGroupStart: function (moveable, e) {
    return this.dragStart(moveable, __assign(__assign({}, e), {
      targets: moveable.props.targets
    }));
  },
  dragGroup: function (moveable, e) {
    return this.drag(moveable, __assign(__assign({}, e), {
      targets: moveable.props.targets
    }));
  },
  dragGroupEnd: function (moveable, e) {
    return this.dragEnd(moveable, __assign(__assign({}, e), {
      targets: moveable.props.targets
    }));
  },
  dragGroupControlStart: function (moveable, e) {
    return this.dragStart(moveable, __assign(__assign({}, e), {
      targets: moveable.props.targets,
      isControl: true
    }));
  },
  dragGroupContro: function (moveable, e) {
    return this.drag(moveable, __assign(__assign({}, e), {
      targets: moveable.props.targets
    }));
  },
  dragGroupControEnd: function (moveable, e) {
    return this.dragEnd(moveable, __assign(__assign({}, e), {
      targets: moveable.props.targets
    }));
  }
};
/**
 * Whether or not target can be scrolled to the scroll container (default: false)
 * @name Moveable.Scrollable#scrollable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   scrollable: true,
 *   scrollContainer: document.body,
 *   scrollThreshold: 0,
 *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),
 * });
 *
 * moveable.scrollable = true;
 */

/**
 * The container to which scroll is applied (default: container)
 * @name Moveable.Scrollable#scrollContainer
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   scrollable: true,
 *   scrollContainer: document.body,
 *   scrollThreshold: 0,
 *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),
 * });
 */

/**
 * Expand the range of the scroll check area. (default: 0)
 * @name Moveable.Scrollable#scrollThreshold
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   scrollable: true,
 *   scrollContainer: document.body,
 *   scrollThreshold: 0,
 *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),
 * });
 */

/**
 * Sets a function to get the scroll position. (default: Function)
 * @name Moveable.Scrollable#getScrollPosition
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   scrollable: true,
 *   scrollContainer: document.body,
 *   scrollThreshold: 0,
 *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),
 * });
 *
 */

/**
 * When the drag cursor leaves the scrollContainer, the `scroll` event occur to scroll.
 * @memberof Moveable.Scrollable
 * @event scroll
 * @param {Moveable.Scrollable.OnScroll} - Parameters for the `scroll` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: document.querySelector(".target"),
 * });
 * moveable.on("scroll", ({ scrollContainer, direction }) => {
 *   scrollContainer.scrollLeft += direction[0] * 10;
 *   scrollContainer.scrollTop += direction[1] * 10;
 * });
 */

/**
 * When the drag cursor leaves the scrollContainer, the `scrollGroup` event occur to scroll in group.
 * @memberof Moveable.Scrollable
 * @event scrollGroup
 * @param {Moveable.Scrollable.OnScrollGroup} - Parameters for the `scrollGroup` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 * });
 * moveable.on("scroll", ({ scrollContainer, direction }) => {
 *   scrollContainer.scrollLeft += direction[0] * 10;
 *   scrollContainer.scrollTop += direction[1] * 10;
 * });
 */

var Default = {
  name: "",
  props: {
    target: Object,
    dragTarget: Object,
    container: Object,
    portalContainer: Object,
    rootContainer: Object,
    useResizeObserver: Boolean,
    zoom: Number,
    transformOrigin: Array,
    edge: Boolean,
    ables: Array,
    className: String,
    pinchThreshold: Number,
    pinchOutside: Boolean,
    triggerAblesSimultaneously: Boolean,
    checkInput: Boolean,
    cspNonce: String,
    translateZ: Number,
    hideDefaultLines: Boolean,
    props: Object
  },
  events: {}
};

var Padding = makeAble("padding", {
  render: function (moveable, React) {
    var props = moveable.props;

    if (props.dragArea) {
      return [];
    }

    var padding = props.padding || {};
    var _a = padding.left,
        left = _a === void 0 ? 0 : _a,
        _b = padding.top,
        top = _b === void 0 ? 0 : _b,
        _c = padding.right,
        right = _c === void 0 ? 0 : _c,
        _d = padding.bottom,
        bottom = _d === void 0 ? 0 : _d;
    var _e = moveable.state,
        renderPoses = _e.renderPoses,
        pos1 = _e.pos1,
        pos2 = _e.pos2,
        pos3 = _e.pos3,
        pos4 = _e.pos4;
    var poses = [pos1, pos2, pos3, pos4];
    var paddingDirections = [];

    if (left > 0) {
      paddingDirections.push([0, 2]);
    }

    if (top > 0) {
      paddingDirections.push([0, 1]);
    }

    if (right > 0) {
      paddingDirections.push([1, 3]);
    }

    if (bottom > 0) {
      paddingDirections.push([2, 3]);
    }

    return paddingDirections.map(function (_a, i) {
      var dir1 = _a[0],
          dir2 = _a[1];
      var paddingPos1 = poses[dir1];
      var paddingPos2 = poses[dir2];
      var paddingPos3 = renderPoses[dir1];
      var paddingPos4 = renderPoses[dir2];
      var h = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createWarpMatrix)([0, 0], [100, 0], [0, 100], [100, 100], paddingPos1, paddingPos2, paddingPos3, paddingPos4);

      if (!h.length) {
        return undefined;
      }

      return React.createElement("div", {
        key: "padding" + i,
        className: prefix("padding"),
        style: {
          transform: makeMatrixCSS(h, true)
        }
      });
    });
  }
});
/**
 * Add padding around the target to increase the drag area. (default: null)
 * @name Moveable#padding
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *  target: document.querySelector(".target"),
 *  padding: { left: 0, top: 0, right: 0, bottom: 0 },
 * });
 * moveable.padding = { left: 10, top: 10, right: 10, bottom: 10 },
 * moveable.updateRect();
 */

var RADIUS_DIRECTIONS = ["nw", "ne", "se", "sw"];

function calculateRatio(values, size) {
  var sumSize = values[0] + values[1];
  var sumRatio = sumSize > size ? size / sumSize : 1;
  values[0] *= sumRatio;
  values[1] = size - values[1] * sumRatio;
  return values;
}

var HORIZONTAL_RADIUS_ORDER = [1, 2, 5, 6];
var VERTICAL_RADIUS_ORDER = [0, 3, 4, 7];
var HORIZONTAL_RADIUS_DIRECTIONS = [1, -1, -1, 1];
var VERTICAL_RADIUS_DIRECTIONS = [1, 1, -1, -1];
function getRadiusStyles(poses, controlPoses, isRelative, width, height, left, top, right, bottom) {
  if (left === void 0) {
    left = 0;
  }

  if (top === void 0) {
    top = 0;
  }

  if (right === void 0) {
    right = width;
  }

  if (bottom === void 0) {
    bottom = height;
  }

  var clipStyles = [];
  var isVertical = false;
  var raws = poses.map(function (pos, i) {
    var _a = controlPoses[i],
        horizontal = _a.horizontal,
        vertical = _a.vertical;

    if (vertical && !isVertical) {
      isVertical = true;
      clipStyles.push("/");
    }

    if (isVertical) {
      var rawPos = Math.max(0, vertical === 1 ? pos[1] - top : bottom - pos[1]);
      clipStyles.push(convertCSSSize(rawPos, height, isRelative));
      return rawPos;
    } else {
      var rawPos = Math.max(0, horizontal === 1 ? pos[0] - left : right - pos[0]);
      clipStyles.push(convertCSSSize(rawPos, width, isRelative));
      return rawPos;
    }
  });
  return {
    styles: clipStyles,
    raws: raws
  };
}
function getRadiusRange(controlPoses) {
  // [start, length]
  var horizontalRange = [0, 0];
  var verticalRange = [0, 0];
  var length = controlPoses.length;

  for (var i = 0; i < length; ++i) {
    var clipPose = controlPoses[i];

    if (!clipPose.sub) {
      continue;
    }

    if (clipPose.horizontal) {
      if (horizontalRange[1] === 0) {
        horizontalRange[0] = i;
      }

      horizontalRange[1] = i - horizontalRange[0] + 1;
      verticalRange[0] = i + 1;
    }

    if (clipPose.vertical) {
      if (verticalRange[1] === 0) {
        verticalRange[0] = i;
      }

      verticalRange[1] = i - verticalRange[0] + 1;
    }
  }

  return {
    horizontalRange: horizontalRange,
    verticalRange: verticalRange
  };
}
function getRadiusValues(values, width, height, left, top, minCounts) {
  var _a, _b, _c, _d;

  if (minCounts === void 0) {
    minCounts = [0, 0];
  }

  var splitIndex = values.indexOf("/");
  var splitLength = (splitIndex > -1 ? values.slice(0, splitIndex) : values).length;
  var horizontalValues = values.slice(0, splitLength);
  var verticalValues = values.slice(splitLength + 1);
  var _e = horizontalValues[0],
      nwValue = _e === void 0 ? "0px" : _e,
      _f = horizontalValues[1],
      neValue = _f === void 0 ? nwValue : _f,
      _g = horizontalValues[2],
      seValue = _g === void 0 ? nwValue : _g,
      _h = horizontalValues[3],
      swValue = _h === void 0 ? neValue : _h;
  var _j = verticalValues[0],
      wnValue = _j === void 0 ? nwValue : _j,
      _k = verticalValues[1],
      enValue = _k === void 0 ? wnValue : _k,
      _l = verticalValues[2],
      esValue = _l === void 0 ? wnValue : _l,
      _m = verticalValues[3],
      wsValue = _m === void 0 ? enValue : _m;
  var horizontalRawPoses = [nwValue, neValue, seValue, swValue].map(function (pos) {
    return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.convertUnitSize)(pos, width);
  });
  var verticalRawPoses = [wnValue, enValue, esValue, wsValue].map(function (pos) {
    return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.convertUnitSize)(pos, height);
  });
  var horizontalPoses = horizontalRawPoses.slice();
  var verticalPoses = verticalRawPoses.slice();
  _a = calculateRatio([horizontalPoses[0], horizontalPoses[1]], width), horizontalPoses[0] = _a[0], horizontalPoses[1] = _a[1];
  _b = calculateRatio([horizontalPoses[3], horizontalPoses[2]], width), horizontalPoses[3] = _b[0], horizontalPoses[2] = _b[1];
  _c = calculateRatio([verticalPoses[0], verticalPoses[3]], height), verticalPoses[0] = _c[0], verticalPoses[3] = _c[1];
  _d = calculateRatio([verticalPoses[1], verticalPoses[2]], height), verticalPoses[1] = _d[0], verticalPoses[2] = _d[1];
  var nextHorizontalPoses = horizontalPoses.slice(0, Math.max(minCounts[0], horizontalValues.length));
  var nextVerticalPoses = verticalPoses.slice(0, Math.max(minCounts[1], verticalValues.length));
  return __spreadArray(__spreadArray([], nextHorizontalPoses.map(function (pos, i) {
    var direction = RADIUS_DIRECTIONS[i];
    return {
      horizontal: HORIZONTAL_RADIUS_DIRECTIONS[i],
      vertical: 0,
      pos: [left + pos, top + (VERTICAL_RADIUS_DIRECTIONS[i] === -1 ? height : 0)],
      sub: true,
      raw: horizontalRawPoses[i],
      direction: direction
    };
  })), nextVerticalPoses.map(function (pos, i) {
    var direction = RADIUS_DIRECTIONS[i];
    return {
      horizontal: 0,
      vertical: VERTICAL_RADIUS_DIRECTIONS[i],
      pos: [left + (HORIZONTAL_RADIUS_DIRECTIONS[i] === -1 ? width : 0), top + pos],
      sub: true,
      raw: verticalRawPoses[i],
      direction: direction
    };
  }));
}
function removeRadiusPos(controlPoses, poses, index, startIndex, length) {
  if (length === void 0) {
    length = poses.length;
  }

  var _a = getRadiusRange(controlPoses.slice(startIndex)),
      horizontalRange = _a.horizontalRange,
      verticalRange = _a.verticalRange;

  var radiuslIndex = index - startIndex;
  var deleteCount = 0;

  if (radiuslIndex === 0) {
    deleteCount = length;
  } else if (radiuslIndex > 0 && radiuslIndex < horizontalRange[1]) {
    deleteCount = horizontalRange[1] - radiuslIndex;
  } else if (radiuslIndex >= verticalRange[0]) {
    deleteCount = verticalRange[0] + verticalRange[1] - radiuslIndex;
  } else {
    return;
  }

  controlPoses.splice(index, deleteCount);
  poses.splice(index, deleteCount);
}
function addRadiusPos(controlPoses, poses, startIndex, horizontalIndex, verticalIndex, distX, distY, right, bottom, left, top) {
  if (left === void 0) {
    left = 0;
  }

  if (top === void 0) {
    top = 0;
  }

  var _a = getRadiusRange(controlPoses.slice(startIndex)),
      horizontalRange = _a.horizontalRange,
      verticalRange = _a.verticalRange;

  if (horizontalIndex > -1) {
    var radiusX = HORIZONTAL_RADIUS_DIRECTIONS[horizontalIndex] === 1 ? distX - left : right - distX;

    for (var i = horizontalRange[1]; i <= horizontalIndex; ++i) {
      var y = VERTICAL_RADIUS_DIRECTIONS[i] === 1 ? top : bottom;
      var x = 0;

      if (horizontalIndex === i) {
        x = distX;
      } else if (i === 0) {
        x = left + radiusX;
      } else if (HORIZONTAL_RADIUS_DIRECTIONS[i] === -1) {
        x = right - (poses[startIndex][0] - left);
      }

      controlPoses.splice(startIndex + i, 0, {
        horizontal: HORIZONTAL_RADIUS_DIRECTIONS[i],
        vertical: 0,
        pos: [x, y]
      });
      poses.splice(startIndex + i, 0, [x, y]);

      if (i === 0) {
        break;
      }
    }
  } else if (verticalIndex > -1) {
    var radiusY = VERTICAL_RADIUS_DIRECTIONS[verticalIndex] === 1 ? distY - top : bottom - distY;

    if (horizontalRange[1] === 0 && verticalRange[1] === 0) {
      var pos = [left + radiusY, top];
      controlPoses.push({
        horizontal: HORIZONTAL_RADIUS_DIRECTIONS[0],
        vertical: 0,
        pos: pos
      });
      poses.push(pos);
    }

    var startVerticalIndex = verticalRange[0];

    for (var i = verticalRange[1]; i <= verticalIndex; ++i) {
      var x = HORIZONTAL_RADIUS_DIRECTIONS[i] === 1 ? left : right;
      var y = 0;

      if (verticalIndex === i) {
        y = distY;
      } else if (i === 0) {
        y = top + radiusY;
      } else if (VERTICAL_RADIUS_DIRECTIONS[i] === 1) {
        y = poses[startIndex + startVerticalIndex][1];
      } else if (VERTICAL_RADIUS_DIRECTIONS[i] === -1) {
        y = bottom - (poses[startIndex + startVerticalIndex][1] - top);
      }

      controlPoses.push({
        horizontal: 0,
        vertical: VERTICAL_RADIUS_DIRECTIONS[i],
        pos: [x, y]
      });
      poses.push([x, y]);

      if (i === 0) {
        break;
      }
    }
  }
}
function splitRadiusPoses(controlPoses, raws) {
  if (raws === void 0) {
    raws = controlPoses.map(function (pos) {
      return pos.raw;
    });
  }

  var horizontals = controlPoses.map(function (pos, i) {
    return pos.horizontal ? raws[i] : null;
  }).filter(function (pos) {
    return pos != null;
  });
  var verticals = controlPoses.map(function (pos, i) {
    return pos.vertical ? raws[i] : null;
  }).filter(function (pos) {
    return pos != null;
  });
  return {
    horizontals: horizontals,
    verticals: verticals
  };
}

var CLIP_DIRECTIONS = [[0, -1, "n"], [1, 0, "e"]];
var CLIP_RECT_DIRECTIONS = [[-1, -1, "nw"], [0, -1, "n"], [1, -1, "ne"], [1, 0, "e"], [1, 1, "se"], [0, 1, "s"], [-1, 1, "sw"], [-1, 0, "w"]]; // 1 2 5 6 0 3 4 7
// 0 1 2 3 4 5 6 7

function getClipStyles(moveable, clipPath, poses) {
  var clipRelative = moveable.props.clipRelative;
  var _a = moveable.state,
      width = _a.width,
      height = _a.height;
  var _b = clipPath,
      clipType = _b.type,
      clipPoses = _b.poses;
  var isRect = clipType === "rect";
  var isCircle = clipType === "circle";

  if (clipType === "polygon") {
    return poses.map(function (pos) {
      return convertCSSSize(pos[0], width, clipRelative) + " " + convertCSSSize(pos[1], height, clipRelative);
    });
  } else if (isRect || clipType === "inset") {
    var top = poses[1][1];
    var right = poses[3][0];
    var left = poses[7][0];
    var bottom = poses[5][1];

    if (isRect) {
      return [top, right, bottom, left].map(function (pos) {
        return pos + "px";
      });
    }

    var clipStyles = [top, width - right, height - bottom, left].map(function (pos, i) {
      return convertCSSSize(pos, i % 2 ? width : height, clipRelative);
    });

    if (poses.length > 8) {
      var _c = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(poses[4], poses[0]),
          subWidth = _c[0],
          subHeight = _c[1];

      clipStyles.push.apply(clipStyles, __spreadArray(["round"], getRadiusStyles(poses.slice(8), clipPoses.slice(8), clipRelative, subWidth, subHeight, left, top, right, bottom).styles));
    }

    return clipStyles;
  } else if (isCircle || clipType === "ellipse") {
    var center = poses[0];
    var ry = convertCSSSize(Math.abs(poses[1][1] - center[1]), isCircle ? Math.sqrt((width * width + height * height) / 2) : height, clipRelative);
    var clipStyles = isCircle ? [ry] : [convertCSSSize(Math.abs(poses[2][0] - center[0]), width, clipRelative), ry];
    clipStyles.push("at", convertCSSSize(center[0], width, clipRelative), convertCSSSize(center[1], height, clipRelative));
    return clipStyles;
  }
}

function getRectPoses(top, right, bottom, left) {
  var xs = [left, (left + right) / 2, right];
  var ys = [top, (top + bottom) / 2, bottom];
  return CLIP_RECT_DIRECTIONS.map(function (_a) {
    var dirx = _a[0],
        diry = _a[1],
        dir = _a[2];
    var x = xs[dirx + 1];
    var y = ys[diry + 1];
    return {
      vertical: Math.abs(diry),
      horizontal: Math.abs(dirx),
      direction: dir,
      pos: [x, y]
    };
  });
}

function getClipPath(target, width, height, defaultClip, customClip) {
  var _a, _b, _c, _d, _e, _f, _g;

  var clipText = customClip;

  if (!clipText) {
    var style = getComputedStyle(target);
    var clipPath = style.clipPath;
    clipText = clipPath !== "none" ? clipPath : style.clip;
  }

  if (!clipText || clipText === "none" || clipText === "auto") {
    clipText = defaultClip;

    if (!clipText) {
      return;
    }
  }

  var _h = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.splitBracket)(clipText),
      _j = _h.prefix,
      clipPrefix = _j === void 0 ? clipText : _j,
      _k = _h.value,
      value = _k === void 0 ? "" : _k;

  var isCircle = clipPrefix === "circle";
  var splitter = " ";

  if (clipPrefix === "polygon") {
    var values = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.splitComma)(value || "0% 0%, 100% 0%, 100% 100%, 0% 100%");
    splitter = ",";
    var poses = values.map(function (pos) {
      var _a = pos.split(" "),
          xPos = _a[0],
          yPos = _a[1];

      return {
        vertical: 1,
        horizontal: 1,
        pos: [(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.convertUnitSize)(xPos, width), (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.convertUnitSize)(yPos, height)]
      };
    });
    return {
      type: clipPrefix,
      clipText: clipText,
      poses: poses,
      splitter: splitter
    };
  } else if (isCircle || clipPrefix === "ellipse") {
    var xPos = "";
    var yPos = "";
    var radiusX_1 = 0;
    var radiusY_1 = 0;
    var values = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.splitSpace)(value);

    if (isCircle) {
      var radius = "";
      _a = values[0], radius = _a === void 0 ? "50%" : _a, _b = values[2], xPos = _b === void 0 ? "50%" : _b, _c = values[3], yPos = _c === void 0 ? "50%" : _c;
      radiusX_1 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.convertUnitSize)(radius, Math.sqrt((width * width + height * height) / 2));
      radiusY_1 = radiusX_1;
    } else {
      var xRadius = "";
      var yRadius = "";
      _d = values[0], xRadius = _d === void 0 ? "50%" : _d, _e = values[1], yRadius = _e === void 0 ? "50%" : _e, _f = values[3], xPos = _f === void 0 ? "50%" : _f, _g = values[4], yPos = _g === void 0 ? "50%" : _g;
      radiusX_1 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.convertUnitSize)(xRadius, width);
      radiusY_1 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.convertUnitSize)(yRadius, height);
    }

    var centerPos_1 = [(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.convertUnitSize)(xPos, width), (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.convertUnitSize)(yPos, height)];

    var poses = __spreadArray([{
      vertical: 1,
      horizontal: 1,
      pos: centerPos_1,
      direction: "nesw"
    }], CLIP_DIRECTIONS.slice(0, isCircle ? 1 : 2).map(function (dir) {
      return {
        vertical: Math.abs(dir[1]),
        horizontal: dir[0],
        direction: dir[2],
        sub: true,
        pos: [centerPos_1[0] + dir[0] * radiusX_1, centerPos_1[1] + dir[1] * radiusY_1]
      };
    }));

    return {
      type: clipPrefix,
      clipText: clipText,
      radiusX: radiusX_1,
      radiusY: radiusY_1,
      left: centerPos_1[0] - radiusX_1,
      top: centerPos_1[1] - radiusY_1,
      poses: poses,
      splitter: splitter
    };
  } else if (clipPrefix === "inset") {
    var values = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.splitSpace)(value || "0 0 0 0");
    var roundIndex = values.indexOf("round");
    var rectLength = (roundIndex > -1 ? values.slice(0, roundIndex) : values).length;
    var radiusValues = values.slice(rectLength + 1);

    var _l = values.slice(0, rectLength),
        topValue = _l[0],
        _m = _l[1],
        rightValue = _m === void 0 ? topValue : _m,
        _o = _l[2],
        bottomValue = _o === void 0 ? topValue : _o,
        _p = _l[3],
        leftValue = _p === void 0 ? rightValue : _p;

    var _q = [topValue, bottomValue].map(function (pos) {
      return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.convertUnitSize)(pos, height);
    }),
        top = _q[0],
        bottom = _q[1];

    var _r = [leftValue, rightValue].map(function (pos) {
      return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.convertUnitSize)(pos, width);
    }),
        left = _r[0],
        right = _r[1];

    var nextRight = width - right;
    var nextBottom = height - bottom;
    var radiusPoses = getRadiusValues(radiusValues, nextRight - left, nextBottom - top, left, top);

    var poses = __spreadArray(__spreadArray([], getRectPoses(top, nextRight, nextBottom, left)), radiusPoses);

    return {
      type: "inset",
      clipText: clipText,
      poses: poses,
      top: top,
      left: left,
      right: nextRight,
      bottom: nextBottom,
      radius: radiusValues,
      splitter: splitter
    };
  } else if (clipPrefix === "rect") {
    // top right bottom left
    var values = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.splitComma)(value || "0px, " + width + "px, " + height + "px, 0px");
    splitter = ",";

    var _s = values.map(function (pos) {
      var posValue = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.splitUnit)(pos).value;
      return posValue;
    }),
        top = _s[0],
        right = _s[1],
        bottom = _s[2],
        left = _s[3];

    var poses = getRectPoses(top, right, bottom, left);
    return {
      type: "rect",
      clipText: clipText,
      poses: poses,
      top: top,
      right: right,
      bottom: bottom,
      left: left,
      values: values,
      splitter: splitter
    };
  }

  return;
}

function addClipPath(moveable, e) {
  var _a = calculatePointerDist(moveable, e),
      distX = _a[0],
      distY = _a[1];

  var _b = e.datas,
      clipPath = _b.clipPath,
      index = _b.index;
  var _c = clipPath,
      clipType = _c.type,
      clipPoses = _c.poses,
      splitter = _c.splitter;
  var poses = clipPoses.map(function (pos) {
    return pos.pos;
  });

  if (clipType === "polygon") {
    poses.splice(index, 0, [distX, distY]);
  } else if (clipType === "inset") {
    var horizontalIndex = HORIZONTAL_RADIUS_ORDER.indexOf(index);
    var verticalIndex = VERTICAL_RADIUS_ORDER.indexOf(index);
    var length = clipPoses.length;
    addRadiusPos(clipPoses, poses, 8, horizontalIndex, verticalIndex, distX, distY, poses[4][0], poses[4][1], poses[0][0], poses[0][1]);

    if (length === clipPoses.length) {
      return;
    }
  } else {
    return;
  }

  var clipStyles = getClipStyles(moveable, clipPath, poses);
  triggerEvent(moveable, "onClip", fillParams(moveable, e, {
    clipEventType: "added",
    clipType: clipType,
    poses: poses,
    clipStyles: clipStyles,
    clipStyle: clipType + "(" + clipStyles.join(splitter) + ")",
    distX: 0,
    distY: 0
  }));
}

function removeClipPath(moveable, e) {
  var _a = e.datas,
      clipPath = _a.clipPath,
      index = _a.index;
  var _b = clipPath,
      clipType = _b.type,
      clipPoses = _b.poses,
      splitter = _b.splitter;
  var poses = clipPoses.map(function (pos) {
    return pos.pos;
  });
  var length = poses.length;

  if (clipType === "polygon") {
    clipPoses.splice(index, 1);
    poses.splice(index, 1);
  } else if (clipType === "inset") {
    if (index < 8) {
      return;
    }

    removeRadiusPos(clipPoses, poses, index, 8, length);

    if (length === clipPoses.length) {
      return;
    }
  } else {
    return;
  }

  var clipStyles = getClipStyles(moveable, clipPath, poses);
  triggerEvent(moveable, "onClip", fillParams(moveable, e, {
    clipEventType: "removed",
    clipType: clipType,
    poses: poses,
    clipStyles: clipStyles,
    clipStyle: clipType + "(" + clipStyles.join(splitter) + ")",
    distX: 0,
    distY: 0
  }));
}
/**
 * @namespace Moveable.Clippable
 * @description Whether to clip the target.
 */


var Clippable = {
  name: "clippable",
  props: {
    clippable: Boolean,
    defaultClipPath: String,
    customClipPath: String,
    clipRelative: Boolean,
    clipArea: Boolean,
    dragWithClip: Boolean,
    clipTargetBounds: Boolean,
    clipVerticalGuidelines: Array,
    clipHorizontalGuidelines: Array,
    clipSnapThreshold: Boolean
  },
  events: {
    onClipStart: "clipStart",
    onClip: "clip",
    onClipEnd: "clipEnd"
  },
  css: [".control.clip-control {\n    background: #6d6;\n    cursor: pointer;\n}\n.control.clip-control.clip-radius {\n    background: #d66;\n}\n.line.clip-line {\n    background: #6e6;\n    cursor: move;\n    z-index: 1;\n}\n.clip-area {\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.clip-ellipse {\n    position: absolute;\n    cursor: move;\n    border: 1px solid #6d6;\n    border: var(--zoompx) solid #6d6;\n    border-radius: 50%;\n    transform-origin: 0px 0px;\n}", ":host {\n    --bounds-color: #d66;\n}", ".guideline {\n    pointer-events: none;\n    z-index: 2;\n}", ".line.guideline.bounds {\n    background: #d66;\n    background: var(--bounds-color);\n}"],
  render: function (moveable, React) {
    var _a = moveable.props,
        customClipPath = _a.customClipPath,
        defaultClipPath = _a.defaultClipPath,
        clipArea = _a.clipArea,
        zoom = _a.zoom;
    var _b = moveable.state,
        target = _b.target,
        width = _b.width,
        height = _b.height,
        allMatrix = _b.allMatrix,
        is3d = _b.is3d,
        left = _b.left,
        top = _b.top,
        pos1 = _b.pos1,
        pos2 = _b.pos2,
        pos3 = _b.pos3,
        pos4 = _b.pos4,
        clipPathState = _b.clipPathState,
        snapBoundInfos = _b.snapBoundInfos,
        rotationRad = _b.rotation;

    if (!target) {
      return [];
    }

    var clipPath = getClipPath(target, width, height, defaultClipPath || "inset", clipPathState || customClipPath);

    if (!clipPath) {
      return [];
    }

    var n = is3d ? 4 : 3;
    var type = clipPath.type;
    var clipPoses = clipPath.poses;
    var poses = clipPoses.map(function (pos) {
      // return [x, y];
      var calculatedPos = calculatePosition(allMatrix, pos.pos, n);
      return [calculatedPos[0] - left, calculatedPos[1] - top];
    });
    var controls = [];
    var lines = [];
    var isRect = type === "rect";
    var isInset = type === "inset";
    var isPolygon = type === "polygon";

    if (isRect || isInset || isPolygon) {
      var linePoses_1 = isInset ? poses.slice(0, 8) : poses;
      lines = linePoses_1.map(function (to, i) {
        var from = i === 0 ? linePoses_1[linePoses_1.length - 1] : linePoses_1[i - 1];
        var rad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)(from, to);
        var dist = getDiagonalSize(from, to);
        return React.createElement("div", {
          key: "clipLine" + i,
          className: prefix("line", "clip-line", "snap-control"),
          "data-clip-index": i,
          style: {
            width: dist + "px",
            transform: "translate(" + from[0] + "px, " + from[1] + "px) rotate(" + rad + "rad) scaleY(" + zoom + ")"
          }
        });
      });
    }

    controls = poses.map(function (pos, i) {
      return React.createElement("div", {
        key: "clipControl" + i,
        className: prefix("control", "clip-control", "snap-control"),
        "data-clip-index": i,
        style: {
          transform: "translate(" + pos[0] + "px, " + pos[1] + "px) rotate(" + rotationRad + "rad) scale(" + zoom + ")"
        }
      });
    });

    if (isInset) {
      controls.push.apply(controls, poses.slice(8).map(function (pos, i) {
        return React.createElement("div", {
          key: "clipRadiusControl" + i,
          className: prefix("control", "clip-control", "clip-radius", "snap-control"),
          "data-clip-index": 8 + i,
          style: {
            transform: "translate(" + pos[0] + "px, " + pos[1] + "px) rotate(" + rotationRad + "rad) scale(" + zoom + ")"
          }
        });
      }));
    }

    if (type === "circle" || type === "ellipse") {
      var clipLeft = clipPath.left,
          clipTop = clipPath.top,
          radiusX = clipPath.radiusX,
          radiusY = clipPath.radiusY;

      var _c = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(calculatePosition(allMatrix, [clipLeft, clipTop], n), calculatePosition(allMatrix, [0, 0], n)),
          distLeft = _c[0],
          distTop = _c[1];

      var ellipseClipPath = "none";

      if (!clipArea) {
        var piece = Math.max(10, radiusX / 5, radiusY / 5);
        var areaPoses = [];

        for (var i = 0; i <= piece; ++i) {
          var rad = Math.PI * 2 / piece * i;
          areaPoses.push([radiusX + (radiusX - zoom) * Math.cos(rad), radiusY + (radiusY - zoom) * Math.sin(rad)]);
        }

        areaPoses.push([radiusX, -2]);
        areaPoses.push([-2, -2]);
        areaPoses.push([-2, radiusY * 2 + 2]);
        areaPoses.push([radiusX * 2 + 2, radiusY * 2 + 2]);
        areaPoses.push([radiusX * 2 + 2, -2]);
        areaPoses.push([radiusX, -2]);
        ellipseClipPath = "polygon(" + areaPoses.map(function (pos) {
          return pos[0] + "px " + pos[1] + "px";
        }).join(", ") + ")";
      }

      controls.push(React.createElement("div", {
        key: "clipEllipse",
        className: prefix("clip-ellipse", "snap-control"),
        style: {
          width: radiusX * 2 + "px",
          height: radiusY * 2 + "px",
          clipPath: ellipseClipPath,
          transform: "translate(" + (-left + distLeft) + "px, " + (-top + distTop) + "px) " + makeMatrixCSS(allMatrix)
        }
      }));
    }

    if (clipArea) {
      var _d = getRect(__spreadArray([pos1, pos2, pos3, pos4], poses)),
          allWidth = _d.width,
          allHeight = _d.height,
          allLeft_1 = _d.left,
          allTop_1 = _d.top;

      if (isPolygon || isRect || isInset) {
        var areaPoses = isInset ? poses.slice(0, 8) : poses;
        controls.push(React.createElement("div", {
          key: "clipArea",
          className: prefix("clip-area", "snap-control"),
          style: {
            width: allWidth + "px",
            height: allHeight + "px",
            transform: "translate(" + allLeft_1 + "px, " + allTop_1 + "px)",
            clipPath: "polygon(" + areaPoses.map(function (pos) {
              return pos[0] - allLeft_1 + "px " + (pos[1] - allTop_1) + "px";
            }).join(", ") + ")"
          }
        }));
      }
    }

    if (snapBoundInfos) {
      ["vertical", "horizontal"].forEach(function (directionType) {
        var info = snapBoundInfos[directionType];
        var isHorizontal = directionType === "horizontal";

        if (info.isSnap) {
          lines.push.apply(lines, info.snap.posInfos.map(function (_a, i) {
            var pos = _a.pos;
            var snapPos1 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(calculatePosition(allMatrix, isHorizontal ? [0, pos] : [pos, 0], n), [left, top]);
            var snapPos2 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(calculatePosition(allMatrix, isHorizontal ? [width, pos] : [pos, height], n), [left, top]);
            return renderLine(React, "", snapPos1, snapPos2, zoom, "clip" + directionType + "snap" + i, "guideline");
          }));
        }

        if (info.isBound) {
          lines.push.apply(lines, info.bounds.map(function (_a, i) {
            var pos = _a.pos;
            var snapPos1 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(calculatePosition(allMatrix, isHorizontal ? [0, pos] : [pos, 0], n), [left, top]);
            var snapPos2 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(calculatePosition(allMatrix, isHorizontal ? [width, pos] : [pos, height], n), [left, top]);
            return renderLine(React, "", snapPos1, snapPos2, zoom, "clip" + directionType + "bounds" + i, "guideline", "bounds", "bold");
          }));
        }
      });
    }

    return __spreadArray(__spreadArray([], controls), lines);
  },
  dragControlCondition: function (moveable, e) {
    return e.inputEvent && (e.inputEvent.target.getAttribute("class") || "").indexOf("clip") > -1;
  },
  dragStart: function (moveable, e) {
    var props = moveable.props;
    var _a = props.dragWithClip,
        dragWithClip = _a === void 0 ? true : _a;

    if (dragWithClip) {
      return false;
    }

    return this.dragControlStart(moveable, e);
  },
  drag: function (moveable, e) {
    return this.dragControl(moveable, e);
  },
  dragEnd: function (moveable, e) {
    return this.dragControlEnd(moveable, e);
  },
  dragControlStart: function (moveable, e) {
    var state = moveable.state;
    var _a = moveable.props,
        defaultClipPath = _a.defaultClipPath,
        customClipPath = _a.customClipPath;
    var target = state.target,
        width = state.width,
        height = state.height;
    var inputTarget = e.inputEvent ? e.inputEvent.target : null;
    var className = inputTarget && inputTarget.getAttribute("class") || "";
    var datas = e.datas;
    var clipPath = getClipPath(target, width, height, defaultClipPath || "inset", customClipPath);

    if (!clipPath) {
      return false;
    }

    var clipText = clipPath.clipText,
        type = clipPath.type,
        poses = clipPath.poses;
    var result = triggerEvent(moveable, "onClipStart", fillParams(moveable, e, {
      clipType: type,
      clipStyle: clipText,
      poses: poses.map(function (pos) {
        return pos.pos;
      })
    }));

    if (result === false) {
      datas.isClipStart = false;
      return false;
    }

    datas.isControl = className && className.indexOf("clip-control") > -1;
    datas.isLine = className.indexOf("clip-line") > -1;
    datas.isArea = className.indexOf("clip-area") > -1 || className.indexOf("clip-ellipse") > -1;
    datas.index = inputTarget ? parseInt(inputTarget.getAttribute("data-clip-index"), 10) : -1;
    datas.clipPath = clipPath;
    datas.isClipStart = true;
    state.clipPathState = clipText;
    setDragStart(moveable, e);
    return true;
  },
  dragControl: function (moveable, e) {
    var _a;

    var datas = e.datas,
        originalDatas = e.originalDatas;

    if (!datas.isClipStart) {
      return false;
    }

    var _b = datas,
        isControl = _b.isControl,
        isLine = _b.isLine,
        isArea = _b.isArea,
        index = _b.index,
        clipPath = _b.clipPath;

    if (!clipPath) {
      return false;
    }

    var _c = getDragDist(e),
        distX = _c[0],
        distY = _c[1];

    var props = moveable.props;
    var state = moveable.state;
    var width = state.width,
        height = state.height;
    var isDragWithTarget = !isArea && !isControl && !isLine;
    var clipType = clipPath.type,
        clipPoses = clipPath.poses,
        splitter = clipPath.splitter;
    var poses = clipPoses.map(function (pos) {
      return pos.pos;
    });

    if (isDragWithTarget) {
      distX = -distX;
      distY = -distY;
    }

    var isAll = !isControl || clipPoses[index].direction === "nesw";
    var isRect = clipType === "inset" || clipType === "rect";
    var dists = clipPoses.map(function () {
      return [0, 0];
    });

    if (isControl && !isAll) {
      var _d = clipPoses[index],
          horizontal = _d.horizontal,
          vertical = _d.vertical;
      var dist = [distX * Math.abs(horizontal), distY * Math.abs(vertical)];
      dists = moveControlPos(clipPoses, index, dist, isRect);
    } else if (isAll) {
      dists = poses.map(function () {
        return [distX, distY];
      });
    }

    var nextPoses = poses.map(function (pos, i) {
      return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(pos, dists[i]);
    });

    var guidePoses = __spreadArray([], nextPoses);

    state.snapBoundInfos = null;
    var isCircle = clipPath.type === "circle";
    var isEllipse = clipPath.type === "ellipse";

    if (isCircle || isEllipse) {
      var guideRect = getRect(nextPoses);
      var ry = Math.abs(guideRect.bottom - guideRect.top);
      var rx = Math.abs(isEllipse ? guideRect.right - guideRect.left : ry);
      var bottom = nextPoses[0][1] + ry;
      var left = nextPoses[0][0] - rx;
      var right = nextPoses[0][0] + rx; // right

      if (isCircle) {
        guidePoses.push([right, guideRect.bottom]);
        dists.push([1, 0]);
      } // bottom


      guidePoses.push([guideRect.left, bottom]);
      dists.push([0, 1]); // left

      guidePoses.push([left, guideRect.bottom]);
      dists.push([1, 0]);
    }

    var guidelines = getDefaultGuidelines((props.clipHorizontalGuidelines || []).map(function (v) {
      return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.convertUnitSize)("" + v, height);
    }), (props.clipVerticalGuidelines || []).map(function (v) {
      return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.convertUnitSize)("" + v, width);
    }), width, height);
    var guideXPoses = [];
    var guideYPoses = [];

    if (isCircle || isEllipse) {
      guideXPoses = [guidePoses[4][0], guidePoses[2][0]];
      guideYPoses = [guidePoses[1][1], guidePoses[3][1]];
    } else if (isRect) {
      var rectPoses = [guidePoses[0], guidePoses[2], guidePoses[4], guidePoses[6]];
      var rectDists_1 = [dists[0], dists[2], dists[4], dists[6]];
      guideXPoses = rectPoses.filter(function (_, i) {
        return rectDists_1[i][0];
      }).map(function (pos) {
        return pos[0];
      });
      guideYPoses = rectPoses.filter(function (_, i) {
        return rectDists_1[i][1];
      }).map(function (pos) {
        return pos[1];
      });
    } else {
      guideXPoses = guidePoses.filter(function (_, i) {
        return dists[i][0];
      }).map(function (pos) {
        return pos[0];
      });
      guideYPoses = guidePoses.filter(function (_, i) {
        return dists[i][1];
      }).map(function (pos) {
        return pos[1];
      });
    }

    var boundDelta = [0, 0];

    var _loop_1 = function (i) {
      var _e = checkSnapBounds(guidelines, props.clipTargetBounds && {
        left: 0,
        top: 0,
        right: width,
        bottom: height
      }, guideXPoses, guideYPoses, 5),
          horizontalSnapInfo = _e.horizontal,
          verticalSnapInfo = _e.vertical;

      var snapOffsetY = horizontalSnapInfo.offset;
      var snapOffsetX = verticalSnapInfo.offset;

      if (horizontalSnapInfo.isBound) {
        boundDelta[1] += snapOffsetY;
      }

      if (verticalSnapInfo.isBound) {
        boundDelta[0] += snapOffsetX;
      }

      if ((isEllipse || isCircle) && dists[0][0] === 0 && dists[0][1] === 0) {
        var guideRect = getRect(nextPoses);
        var cy = guideRect.bottom - guideRect.top;
        var cx = isEllipse ? guideRect.right - guideRect.left : cy;
        var distSnapX = verticalSnapInfo.isBound ? Math.abs(snapOffsetX) : verticalSnapInfo.snapIndex === 0 ? -snapOffsetX : snapOffsetX;
        var distSnapY = horizontalSnapInfo.isBound ? Math.abs(snapOffsetY) : horizontalSnapInfo.snapIndex === 0 ? -snapOffsetY : snapOffsetY;
        cx -= distSnapX;
        cy -= distSnapY;

        if (isCircle) {
          cy = checkSnapBoundPriority(verticalSnapInfo, horizontalSnapInfo) > 0 ? cy : cx;
          cx = cy;
        }

        var center = guidePoses[0];
        guidePoses[1][1] = center[1] - cy;
        guidePoses[2][0] = center[0] + cx;
        guidePoses[3][1] = center[1] + cy;
        guidePoses[4][0] = center[0] - cx;
      } else {
        guidePoses.forEach(function (pos, j) {
          var dist = dists[j];

          if (dist[0]) {
            pos[0] -= snapOffsetX;
          }

          if (dist[1]) {
            pos[1] -= snapOffsetY;
          }
        });
        return "break";
      }
    };

    for (var i = 0; i < 2; ++i) {
      var state_1 = _loop_1();

      if (state_1 === "break") break;
    }

    var nextClipStyles = getClipStyles(moveable, clipPath, nextPoses);
    var clipStyle = clipType + "(" + nextClipStyles.join(splitter) + ")";
    state.clipPathState = clipStyle;

    if (isCircle || isEllipse) {
      guideXPoses = [guidePoses[4][0], guidePoses[2][0]];
      guideYPoses = [guidePoses[1][1], guidePoses[3][1]];
    } else if (isRect) {
      var rectPoses = [guidePoses[0], guidePoses[2], guidePoses[4], guidePoses[6]];
      guideXPoses = rectPoses.map(function (pos) {
        return pos[0];
      });
      guideYPoses = rectPoses.map(function (pos) {
        return pos[1];
      });
    } else {
      guideXPoses = guidePoses.map(function (pos) {
        return pos[0];
      });
      guideYPoses = guidePoses.map(function (pos) {
        return pos[1];
      });
    }

    state.snapBoundInfos = checkSnapBounds(guidelines, props.clipTargetBounds && {
      left: 0,
      top: 0,
      right: width,
      bottom: height
    }, guideXPoses, guideYPoses, 1);

    if (originalDatas.draggable) {
      var is3d = state.is3d,
          allMatrix = state.allMatrix;
      var n = is3d ? 4 : 3;
      _a = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.multiply)(allMatrix, [boundDelta[0], boundDelta[1], 0, 0], n), boundDelta[0] = _a[0], boundDelta[1] = _a[1];
      originalDatas.draggable.deltaOffset = boundDelta;
    }

    triggerEvent(moveable, "onClip", fillParams(moveable, e, {
      clipEventType: "changed",
      clipType: clipType,
      poses: nextPoses,
      clipStyle: clipStyle,
      clipStyles: nextClipStyles,
      distX: distX,
      distY: distY
    }));
    return true;
  },
  dragControlEnd: function (moveable, e) {
    this.unset(moveable);
    var isDrag = e.isDrag,
        datas = e.datas,
        isDouble = e.isDouble;
    var isLine = datas.isLine,
        isClipStart = datas.isClipStart,
        isControl = datas.isControl;

    if (!isClipStart) {
      return false;
    }

    triggerEvent(moveable, "onClipEnd", fillEndParams(moveable, e, {}));

    if (isDouble) {
      if (isControl) {
        removeClipPath(moveable, e);
      } else if (isLine) {
        // add
        addClipPath(moveable, e);
      }
    }

    return isDouble || isDrag;
  },
  unset: function (moveable) {
    moveable.state.clipPathState = "";
    moveable.state.snapBoundInfos = null;
  }
};
/**
 * Whether to clip the target. (default: false)
 * @name Moveable.Clippable#clippable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     clippable: true,
 *     defaultClipPath: "inset",
 *     customClipPath: "",
 *     clipRelative: false,
 *     clipArea: false,
 *     dragWithClip: true,
 * });
 * moveable.on("clipStart", e => {
 *     console.log(e);
 * }).on("clip", e => {
 *     if (e.clipType === "rect") {
 *         e.target.style.clip = e.clipStyle;
 *     } else {
 *         e.target.style.clipPath = e.clipStyle;
 *     }
 * }).on("clipEnd", e => {
 *     console.log(e);
 * });
 */

/**
 *  If clippath is not set, the default value can be set. (defaultClipPath < style < customClipPath < dragging clipPath)
 * @name Moveable.Clippable#defaultClipPath
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     clippable: true,
 *     defaultClipPath: "inset",
 *     customClipPath: "",
 *     clipRelative: false,
 *     clipArea: false,
 *     dragWithClip: true,
 * });
 * moveable.on("clipStart", e => {
 *     console.log(e);
 * }).on("clip", e => {
 *     if (e.clipType === "rect") {
 *         e.target.style.clip = e.clipStyle;
 *     } else {
 *         e.target.style.clipPath = e.clipStyle;
 *     }
 * }).on("clipEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * % Can be used instead of the absolute px (`rect` not possible) (default: false)
 * @name Moveable.Clippable#clipRelative
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     clippable: true,
 *     defaultClipPath: "inset",
 *     customClipPath: "",
 *     clipRelative: false,
 *     clipArea: false,
 *     dragWithClip: true,
 * });
 * moveable.on("clipStart", e => {
 *     console.log(e);
 * }).on("clip", e => {
 *     if (e.clipType === "rect") {
 *         e.target.style.clip = e.clipStyle;
 *     } else {
 *         e.target.style.clipPath = e.clipStyle;
 *     }
 * }).on("clipEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * You can force the custom clipPath. (defaultClipPath < style < customClipPath < dragging clipPath)
 * @name Moveable.Clippable#customClipPath
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     clippable: true,
 *     defaultClipPath: "inset",
 *     customClipPath: "",
 *     clipRelative: false,
 *     clipArea: false,
 *     dragWithClip: true,
 * });
 * moveable.on("clipStart", e => {
 *     console.log(e);
 * }).on("clip", e => {
 *     if (e.clipType === "rect") {
 *         e.target.style.clip = e.clipStyle;
 *     } else {
 *         e.target.style.clipPath = e.clipStyle;
 *     }
 * }).on("clipEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * When dragging the target, the clip also moves. (default: true)
 * @name Moveable.Clippable#dragWithClip
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     clippable: true,
 *     defaultClipPath: "inset",
 *     customClipPath: "",
 *     clipRelative: false,
 *     clipArea: false,
 *     dragWithClip: true,
 * });
 * moveable.on("clipStart", e => {
 *     console.log(e);
 * }).on("clip", e => {
 *     if (e.clipType === "rect") {
 *         e.target.style.clip = e.clipStyle;
 *     } else {
 *         e.target.style.clipPath = e.clipStyle;
 *     }
 * }).on("clipEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * You can drag the clip by setting clipArea. (default: false)
 * @name Moveable.Clippable#clipArea
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     clippable: true,
 *     defaultClipPath: "inset",
 *     customClipPath: "",
 *     clipRelative: false,
 *     clipArea: false,
 *     dragWithClip: true,
 * });
 * moveable.on("clipStart", e => {
 *     console.log(e);
 * }).on("clip", e => {
 *     if (e.clipType === "rect") {
 *         e.target.style.clip = e.clipStyle;
 *     } else {
 *         e.target.style.clipPath = e.clipStyle;
 *     }
 * }).on("clipEnd", e => {
 *     console.log(e);
 * });
 */

/**
* Whether the clip is bound to the target. (default: false)
* @name Moveable.Clippable#clipTargetBounds
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     clippable: true,
*     defaultClipPath: "inset",
*     customClipPath: "",
*     clipRelative: false,
*     clipArea: false,
*     dragWithClip: true,
*     clipTargetBounds: true,
* });
* moveable.on("clipStart", e => {
*     console.log(e);
* }).on("clip", e => {
*     if (e.clipType === "rect") {
*         e.target.style.clip = e.clipStyle;
*     } else {
*         e.target.style.clipPath = e.clipStyle;
*     }
* }).on("clipEnd", e => {
*     console.log(e);
* });
*/

/**
* Add clip guidelines in the vertical direction. (default: [])
* @name Moveable.Clippable#clipVerticalGuidelines
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     clippable: true,
*     defaultClipPath: "inset",
*     customClipPath: "",
*     clipRelative: false,
*     clipArea: false,
*     dragWithClip: true,
*     clipVerticalGuidelines: [0, 100, 200],
*     clipHorizontalGuidelines: [0, 100, 200],
*     clipSnapThreshold: 5,
* });
*/

/**
* Add clip guidelines in the horizontal direction. (default: [])
* @name Moveable.Clippable#clipHorizontalGuidelines
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     clippable: true,
*     defaultClipPath: "inset",
*     customClipPath: "",
*     clipRelative: false,
*     clipArea: false,
*     dragWithClip: true,
*     clipVerticalGuidelines: [0, 100, 200],
*     clipHorizontalGuidelines: [0, 100, 200],
*     clipSnapThreshold: 5,
* });
*/

/**
* istance value that can snap to clip guidelines. (default: 5)
* @name Moveable.Clippable#clipSnapThreshold
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     clippable: true,
*     defaultClipPath: "inset",
*     customClipPath: "",
*     clipRelative: false,
*     clipArea: false,
*     dragWithClip: true,
*     clipVerticalGuidelines: [0, 100, 200],
*     clipHorizontalGuidelines: [0, 100, 200],
*     clipSnapThreshold: 5,
* });
*/

/**
 * When drag start the clip area or controls, the `clipStart` event is called.
 * @memberof Moveable.Clippable
 * @event clipStart
 * @param {Moveable.Clippable.OnClipStart} - Parameters for the `clipStart` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     clippable: true,
 *     defaultClipPath: "inset",
 *     customClipPath: "",
 *     clipRelative: false,
 *     clipArea: false,
 *     dragWithClip: true,
 * });
 * moveable.on("clipStart", e => {
 *     console.log(e);
 * }).on("clip", e => {
 *     if (e.clipType === "rect") {
 *         e.target.style.clip = e.clipStyle;
 *     } else {
 *         e.target.style.clipPath = e.clipStyle;
 *     }
 * }).on("clipEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * When drag the clip area or controls, the `clip` event is called.
 * @memberof Moveable.Clippable
 * @event clip
 * @param {Moveable.Clippable.OnClip} - Parameters for the `clip` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     clippable: true,
 *     defaultClipPath: "inset",
 *     customClipPath: "",
 *     clipRelative: false,
 *     clipArea: false,
 *     dragWithClip: true,
 * });
 * moveable.on("clipStart", e => {
 *     console.log(e);
 * }).on("clip", e => {
 *     if (e.clipType === "rect") {
 *         e.target.style.clip = e.clipStyle;
 *     } else {
 *         e.target.style.clipPath = e.clipStyle;
 *     }
 * }).on("clipEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * When drag end the clip area or controls, the `clipEnd` event is called.
 * @memberof Moveable.Clippable
 * @event clipEnd
 * @param {Moveable.Clippable.OnClipEnd} - Parameters for the `clipEnd` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     clippable: true,
 *     defaultClipPath: "inset",
 *     customClipPath: "",
 *     clipRelative: false,
 *     clipArea: false,
 *     dragWithClip: true,
 * });
 * moveable.on("clipStart", e => {
 *     console.log(e);
 * }).on("clip", e => {
 *     if (e.clipType === "rect") {
 *         e.target.style.clip = e.clipStyle;
 *     } else {
 *         e.target.style.clipPath = e.clipStyle;
 *     }
 * }).on("clipEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * @namespace OriginDraggable
 * @memberof Moveable
 * @description Whether to drag origin (default: false)
 */

var OriginDraggable = {
  name: "originDraggable",
  props: {
    originDraggable: Boolean,
    originRelative: Boolean
  },
  events: {
    onDragOriginStart: "dragOriginStart",
    onDragOrigin: "dragOrigin",
    onDragOriginEnd: "dragOriginEnd"
  },
  css: [":host[data-able-origindraggable] .control.origin {\n    pointer-events: auto;\n}"],
  dragControlCondition: function (_, e) {
    if (e.isRequest) {
      return e.requestAble === "originDraggable";
    }

    return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.hasClass)(e.inputEvent.target, prefix("origin"));
  },
  dragControlStart: function (moveable, e) {
    var datas = e.datas;
    setDragStart(moveable, e);
    var params = fillParams(moveable, e, {
      dragStart: Draggable.dragStart(moveable, new CustomGesto().dragStart([0, 0], e))
    });
    var result = triggerEvent(moveable, "onDragOriginStart", params);
    datas.startOrigin = moveable.state.transformOrigin;
    datas.startTargetOrigin = moveable.state.targetOrigin;
    datas.prevOrigin = [0, 0];
    datas.isDragOrigin = true;

    if (result === false) {
      datas.isDragOrigin = false;
      return false;
    }

    return params;
  },
  dragControl: function (moveable, e) {
    var datas = e.datas,
        isPinch = e.isPinch,
        isRequest = e.isRequest;

    if (!datas.isDragOrigin) {
      return false;
    }

    var _a = getDragDist(e),
        distX = _a[0],
        distY = _a[1];

    var state = moveable.state;
    var width = state.width,
        height = state.height,
        offsetMatrix = state.offsetMatrix,
        targetMatrix = state.targetMatrix,
        is3d = state.is3d;
    var _b = moveable.props.originRelative,
        originRelative = _b === void 0 ? true : _b;
    var n = is3d ? 4 : 3;
    var dist = [distX, distY];

    if (isRequest) {
      var distOrigin = e.distOrigin;

      if (distOrigin[0] || distOrigin[1]) {
        dist = distOrigin;
      }
    }

    var origin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(datas.startOrigin, dist);
    var targetOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(datas.startTargetOrigin, dist);
    var delta = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(dist, datas.prevOrigin);
    var nextMatrix = getNextMatrix(offsetMatrix, targetMatrix, origin, n);
    var rect = moveable.getRect();
    var nextRect = getRect(calculatePoses(nextMatrix, width, height, n));
    var dragDelta = [rect.left - nextRect.left, rect.top - nextRect.top];
    datas.prevOrigin = dist;
    var transformOrigin = [convertCSSSize(targetOrigin[0], width, originRelative), convertCSSSize(targetOrigin[1], height, originRelative)].join(" ");
    var params = fillParams(moveable, e, {
      width: width,
      height: height,
      origin: origin,
      dist: dist,
      delta: delta,
      transformOrigin: transformOrigin,
      drag: Draggable.drag(moveable, setCustomDrag(e, moveable.state, dragDelta, !!isPinch, false))
    });
    triggerEvent(moveable, "onDragOrigin", params);
    return params;
  },
  dragControlEnd: function (moveable, e) {
    var datas = e.datas;

    if (!datas.isDragOrigin) {
      return false;
    }

    triggerEvent(moveable, "onDragOriginEnd", fillEndParams(moveable, e, {}));
    return true;
  },
  dragGroupControlCondition: function (moveable, e) {
    return this.dragControlCondition(moveable, e);
  },
  dragGroupControlStart: function (moveable, e) {
    var params = this.dragControlStart(moveable, e);

    if (!params) {
      return false;
    }

    return true;
  },
  dragGroupControl: function (moveable, e) {
    var params = this.dragControl(moveable, e);

    if (!params) {
      return false;
    }

    moveable.transformOrigin = params.transformOrigin;
    return true;
  },

  /**
  * @method Moveable.OriginDraggable#request
  * @param {object} e - the OriginDraggable's request parameter
  * @param {number} [e.x] - x position
  * @param {number} [e.y] - y position
  * @param {number} [e.deltaX] - x number to move
  * @param {number} [e.deltaY] - y number to move
  * @param {array} [e.deltaOrigin] - left, top number to move transform-origin
  * @param {array} [e.origin] - transform-origin position
  * @param {number} [e.isInstant] - Whether to execute the request instantly
  * @return {Moveable.Requester} Moveable Requester
  * @example
   * // Instantly Request (requestStart - request - requestEnd)
  * // Use Relative Value
  * moveable.request("originDraggable", { deltaX: 10, deltaY: 10 }, true);
  * // Use Absolute Value
  * moveable.request("originDraggable", { x: 200, y: 100 }, true);
  * // Use Transform Value
  * moveable.request("originDraggable", { deltaOrigin: [10, 0] }, true);
  * moveable.request("originDraggable", { origin: [100, 0] }, true);
  * // requestStart
  * const requester = moveable.request("originDraggable");
  *
  * // request
  * // Use Relative Value
  * requester.request({ deltaX: 10, deltaY: 10 });
  * requester.request({ deltaX: 10, deltaY: 10 });
  * requester.request({ deltaX: 10, deltaY: 10 });
  * // Use Absolute Value
  * moveable.request("originDraggable", { x: 200, y: 100 });
  * moveable.request("originDraggable", { x: 220, y: 100 });
  * moveable.request("originDraggable", { x: 240, y: 100 });
  *
  * // requestEnd
  * requester.requestEnd();
  */
  request: function (moveable) {
    var datas = {};
    var rect = moveable.getRect();
    var distX = 0;
    var distY = 0;
    var transformOrigin = rect.transformOrigin;
    var distOrigin = [0, 0];
    return {
      isControl: true,
      requestStart: function () {
        return {
          datas: datas
        };
      },
      request: function (e) {
        if ("deltaOrigin" in e) {
          distOrigin[0] += e.deltaOrigin[0];
          distOrigin[1] += e.deltaOrigin[1];
        } else if ("origin" in e) {
          distOrigin[0] = e.origin[0] - transformOrigin[0];
          distOrigin[1] = e.origin[1] - transformOrigin[1];
        } else {
          if ("x" in e) {
            distX = e.x - rect.left;
          } else if ("deltaX" in e) {
            distX += e.deltaX;
          }

          if ("y" in e) {
            distY = e.y - rect.top;
          } else if ("deltaY" in e) {
            distY += e.deltaY;
          }
        }

        return {
          datas: datas,
          distX: distX,
          distY: distY,
          distOrigin: distOrigin
        };
      },
      requestEnd: function () {
        return {
          datas: datas,
          isDrag: true
        };
      }
    };
  }
};
/**
 * Whether to drag origin (default: false)
 * @name Moveable.OriginDraggable#originDraggable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     originDraggable: true,
 * });
 * let translate = [0, 0];
 * moveable.on("dragOriginStart", e => {
 *     e.dragStart && e.dragStart.set(translate);
 * }).on("dragOrigin", e => {
 *     translate = e.drag.beforeTranslate;
 *     e.target.style.cssText
 *         = `transform-origin: ${e.transformOrigin};`
 *         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;
 * }).on("dragOriginEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * % Can be used instead of the absolute px (default: true)
 * @name Moveable.OriginDraggable#originRelative
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     originDraggable: true,
 *     originRelative: false,
 * });
 * moveable.originRelative = true;
 */

/**
* When drag start the origin, the `dragOriginStart` event is called.
* @memberof Moveable.OriginDraggable
* @event dragOriginStart
* @param {Moveable.OriginDraggable.OnDragOriginStart} - Parameters for the `dragOriginStart` event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     originDraggable: true,
* });
* let translate = [0, 0];
* moveable.on("dragOriginStart", e => {
*     e.dragStart && e.dragStart.set(translate);
* }).on("dragOrigin", e => {
*     translate = e.drag.beforeTranslate;
*     e.target.style.cssText
*         = `transform-origin: ${e.transformOrigin};`
*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;
* }).on("dragOriginEnd", e => {
*     console.log(e);
* });
*/

/**
* When drag the origin, the `dragOrigin` event is called.
* @memberof Moveable.OriginDraggable
* @event dragOrigin
* @param {Moveable.OriginDraggable.OnDragOrigin} - Parameters for the `dragOrigin` event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     originDraggable: true,
* });
* let translate = [0, 0];
* moveable.on("dragOriginStart", e => {
*     e.dragStart && e.dragStart.set(translate);
* }).on("dragOrigin", e => {
*     translate = e.drag.beforeTranslate;
*     e.target.style.cssText
*         = `transform-origin: ${e.transformOrigin};`
*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;
* }).on("dragOriginEnd", e => {
*     console.log(e);
* });
*/

/**
* When drag end the origin, the `dragOriginEnd` event is called.
* @memberof Moveable.OriginDraggable
* @event dragOriginEnd
* @param {Moveable.OriginDraggable.OnDragOriginEnd} - Parameters for the `dragOriginEnd` event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     originDraggable: true,
* });
* let translate = [0, 0];
* moveable.on("dragOriginStart", e => {
*     e.dragStart && e.dragStart.set(translate);
* }).on("dragOrigin", e => {
*     translate = e.drag.beforeTranslate;
*     e.target.style.cssText
*         = `transform-origin: ${e.transformOrigin};`
*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;
* }).on("dragOriginEnd", e => {
*     console.log(e);
* });
*/

function addBorderRadius(controlPoses, poses, lineIndex, distX, distY, width, height) {
  var _a = splitRadiusPoses(controlPoses),
      horizontals = _a.horizontals,
      verticals = _a.verticals;

  var horizontalsLength = horizontals.length;
  var verticalsLength = verticals.length; // lineIndex
  // 0 top
  // 1 right
  // 2 left
  // 3 bottom
  // 0 top - left
  // 1 top - right
  // 2 bottom - right
  // 3 bottom - left
  // 0 left - top
  // 1 right - top
  // 2 right - bottom
  // 3 left - bottom

  var horizontalIndex = -1;
  var verticalIndex = -1;

  if (lineIndex === 0) {
    if (horizontalsLength === 0) {
      horizontalIndex = 0;
    } else if (horizontalsLength === 1) {
      horizontalIndex = 1;
    }
  } else if (lineIndex === 3) {
    if (horizontalsLength <= 2) {
      horizontalIndex = 2;
    } else if (horizontalsLength <= 3) {
      horizontalIndex = 3;
    }
  }

  if (lineIndex === 2) {
    if (verticalsLength === 0) {
      verticalIndex = 0;
    } else if (verticalsLength < 4) {
      verticalIndex = 3;
    }
  } else if (lineIndex === 1) {
    if (verticalsLength <= 1) {
      verticalIndex = 1;
    } else if (verticalsLength <= 2) {
      verticalIndex = 2;
    }
  }

  addRadiusPos(controlPoses, poses, 0, horizontalIndex, verticalIndex, distX, distY, width, height);
}

function getBorderRadius(target, width, height, minCounts, state) {
  if (minCounts === void 0) {
    minCounts = [0, 0];
  }

  var borderRadius;
  var values = [];

  if (!state) {
    var style = getComputedStyle(target);
    borderRadius = style && style.borderRadius || "";
  } else {
    borderRadius = state;
  }

  if (!borderRadius || !state && borderRadius === "0px") {
    values = [];
  } else {
    values = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.splitSpace)(borderRadius);
  }

  return getRadiusValues(values, width, height, 0, 0, minCounts);
}

function triggerRoundEvent(moveable, e, dist, delta, controlPoses, nextPoses) {
  var state = moveable.state;
  var width = state.width,
      height = state.height;

  var _a = getRadiusStyles(nextPoses, controlPoses, moveable.props.roundRelative, width, height),
      raws = _a.raws,
      styles = _a.styles;

  var _b = splitRadiusPoses(controlPoses, raws),
      horizontals = _b.horizontals,
      verticals = _b.verticals;

  var borderRadius = styles.join(" ");
  state.borderRadiusState = borderRadius;
  triggerEvent(moveable, "onRound", fillParams(moveable, e, {
    horizontals: horizontals,
    verticals: verticals,
    borderRadius: borderRadius,
    width: width,
    height: height,
    delta: delta,
    dist: dist
  }));
}
/**
 * @namespace Moveable.Roundable
 * @description Whether to show and drag or double click border-radius
 */


var Roundable = {
  name: "roundable",
  props: {
    roundable: Boolean,
    roundRelative: Boolean,
    minRoundControls: Array,
    maxRoundControls: Array,
    roundClickable: Boolean
  },
  events: {
    onRoundStart: "roundStart",
    onRound: "round",
    onRoundEnd: "roundEnd"
  },
  css: [".control.border-radius {\n    background: #d66;\n    cursor: pointer;\n}", ":host[data-able-roundable] .line.direction {\n    cursor: pointer;\n}"],
  render: function (moveable, React) {
    var _a = moveable.state,
        target = _a.target,
        width = _a.width,
        height = _a.height,
        allMatrix = _a.allMatrix,
        is3d = _a.is3d,
        left = _a.left,
        top = _a.top,
        borderRadiusState = _a.borderRadiusState;
    var _b = moveable.props,
        _c = _b.minRoundControls,
        minRoundControls = _c === void 0 ? [0, 0] : _c,
        _d = _b.maxRoundControls,
        maxRoundControls = _d === void 0 ? [4, 4] : _d,
        zoom = _b.zoom;

    if (!target) {
      return null;
    }

    var n = is3d ? 4 : 3;
    var radiusValues = getBorderRadius(target, width, height, minRoundControls, borderRadiusState);

    if (!radiusValues) {
      return null;
    }

    var verticalCount = 0;
    var horizontalCount = 0;
    return radiusValues.map(function (v, i) {
      horizontalCount += Math.abs(v.horizontal);
      verticalCount += Math.abs(v.vertical);
      var pos = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(calculatePosition(allMatrix, v.pos, n), [left, top]);
      var isDisplay = v.vertical ? verticalCount <= maxRoundControls[1] : horizontalCount <= maxRoundControls[0];
      return React.createElement("div", {
        key: "borderRadiusControl" + i,
        className: prefix("control", "border-radius"),
        "data-radius-index": i,
        style: {
          display: isDisplay ? "block" : "none",
          transform: "translate(" + pos[0] + "px, " + pos[1] + "px) scale(" + zoom + ")"
        }
      });
    });
  },
  dragControlCondition: function (moveable, e) {
    if (!e.inputEvent || e.isRequest) {
      return false;
    }

    var className = e.inputEvent.target.getAttribute("class") || "";
    return className.indexOf("border-radius") > -1 || className.indexOf("moveable-line") > -1 && className.indexOf("moveable-direction") > -1;
  },
  dragControlStart: function (moveable, e) {
    var inputEvent = e.inputEvent,
        datas = e.datas;
    var inputTarget = inputEvent.target;
    var className = inputTarget.getAttribute("class") || "";
    var isControl = className.indexOf("border-radius") > -1;
    var isLine = className.indexOf("moveable-line") > -1 && className.indexOf("moveable-direction") > -1;
    var controlIndex = isControl ? parseInt(inputTarget.getAttribute("data-radius-index"), 10) : -1;
    var lineIndex = isLine ? parseInt(inputTarget.getAttribute("data-line-index"), 10) : -1;

    if (!isControl && !isLine) {
      return false;
    }

    var result = triggerEvent(moveable, "onRoundStart", fillParams(moveable, e, {}));

    if (result === false) {
      return false;
    }

    datas.lineIndex = lineIndex;
    datas.controlIndex = controlIndex;
    datas.isControl = isControl;
    datas.isLine = isLine;
    setDragStart(moveable, e);
    var _a = moveable.props,
        roundRelative = _a.roundRelative,
        _b = _a.minRoundControls,
        minRoundControls = _b === void 0 ? [0, 0] : _b;
    var state = moveable.state;
    var target = state.target,
        width = state.width,
        height = state.height;
    datas.isRound = true;
    datas.prevDist = [0, 0];
    var controlPoses = getBorderRadius(target, width, height, minRoundControls) || [];
    datas.controlPoses = controlPoses;
    state.borderRadiusState = getRadiusStyles(controlPoses.map(function (pos) {
      return pos.pos;
    }), controlPoses, roundRelative, width, height).styles.join(" ");
    return true;
  },
  dragControl: function (moveable, e) {
    var datas = e.datas;

    if (!datas.isRound || !datas.isControl || !datas.controlPoses.length) {
      return false;
    }

    var index = datas.controlIndex;
    var controlPoses = datas.controlPoses;

    var _a = getDragDist(e),
        distX = _a[0],
        distY = _a[1];

    var dist = [distX, distY];
    var delta = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(dist, datas.prevDist);
    var _b = moveable.props.maxRoundControls,
        maxRoundControls = _b === void 0 ? [4, 4] : _b;
    var _c = moveable.state,
        width = _c.width,
        height = _c.height;
    var selectedControlPose = controlPoses[index];
    var selectedVertical = selectedControlPose.vertical;
    var selectedHorizontal = selectedControlPose.horizontal; // 0: [0, 1, 2, 3] maxCount === 1
    // 0: [0, 2] maxCount === 2
    // 1: [1, 3] maxCount === 2
    // 0: [0] maxCount === 3
    // 1: [1, 3] maxCount === 3

    var dists = controlPoses.map(function (pose) {
      var horizontal = pose.horizontal,
          vertical = pose.vertical;
      var poseDist = [horizontal * selectedHorizontal * dist[0], vertical * selectedVertical * dist[1]];

      if (horizontal) {
        if (maxRoundControls[0] === 1) {
          return poseDist;
        } else if (maxRoundControls[0] < 4 && horizontal !== selectedHorizontal) {
          return poseDist;
        }
      } else if (maxRoundControls[1] === 0) {
        poseDist[1] = vertical * selectedHorizontal * dist[0] / width * height;
        return poseDist;
      } else if (selectedVertical) {
        if (maxRoundControls[1] === 1) {
          return poseDist;
        } else if (maxRoundControls[1] < 4 && vertical !== selectedVertical) {
          return poseDist;
        }
      }

      return [0, 0];
    });
    dists[index] = dist;
    var nextPoses = controlPoses.map(function (pos, i) {
      return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(pos.pos, dists[i]);
    });
    datas.prevDist = [distX, distY];
    triggerRoundEvent(moveable, e, dist, delta, controlPoses, nextPoses);
    return true;
  },
  dragControlEnd: function (moveable, e) {
    var state = moveable.state;
    state.borderRadiusState = "";
    var datas = e.datas,
        isDouble = e.isDouble;

    if (!datas.isRound) {
      return false;
    }

    var width = state.width,
        height = state.height;
    var isControl = datas.isControl,
        controlIndex = datas.controlIndex,
        isLine = datas.isLine,
        lineIndex = datas.lineIndex;
    var controlPoses = datas.controlPoses;
    var poses = controlPoses.map(function (pos) {
      return pos.pos;
    });
    var length = poses.length;
    var _a = moveable.props.roundClickable,
        roundClickable = _a === void 0 ? true : _a;

    if (isDouble && roundClickable) {
      if (isControl) {
        removeRadiusPos(controlPoses, poses, controlIndex, 0);
      } else if (isLine) {
        var _b = calculatePointerDist(moveable, e),
            distX = _b[0],
            distY = _b[1];

        addBorderRadius(controlPoses, poses, lineIndex, distX, distY, width, height);
      }

      if (length !== controlPoses.length) {
        triggerRoundEvent(moveable, e, [0, 0], [0, 0], controlPoses, poses);
      }
    }

    triggerEvent(moveable, "onRoundEnd", fillEndParams(moveable, e, {}));
    state.borderRadiusState = "";
    return true;
  },
  unset: function (moveable) {
    moveable.state.borderRadiusState = "";
  }
};
/**
 * Whether to show and drag or double click border-radius, (default: false)
 * @name Moveable.Roundable#roundable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     roundable: true,
 *     roundRelative: false,
 * });
 * moveable.on("roundStart", e => {
 *     console.log(e);
 * }).on("round", e => {
 *     e.target.style.borderRadius = e.borderRadius;
 * }).on("roundEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * % Can be used instead of the absolute px
 * @name Moveable.Roundable#roundRelative
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     roundable: true,
 *     roundRelative: false,
 * });
 * moveable.on("roundStart", e => {
 *     console.log(e);
 * }).on("round", e => {
 *     e.target.style.borderRadius = e.borderRadius;
 * }).on("roundEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * Minimum number of round controls. It moves in proportion by control. [horizontal, vertical] (default: [0, 0])
 * @name Moveable.Roundable#minRoundControls
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     roundable: true,
 *     roundRelative: false,
 *     minRoundControls: [0, 0],
 * });
 * moveable.maxRoundControls = [1, 0];
 */

/**
 * Maximum number of round controls. It moves in proportion by control. [horizontal, vertical] (default: [4, 4])
 * @name Moveable.Roundable#maxRoundControls
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     roundable: true,
 *     roundRelative: false,
 *     maxRoundControls: [4, 4],
 * });
 * moveable.maxRoundControls = [1, 0];
 */

/**
 * @property - Whether you can add/delete round controls by double-clicking a line or control. (default: true)
 * @name Moveable.Roundable#roundClickable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     roundable: true,
 *     roundRelative: false,
 *     roundClickable: true,
 * });
 * moveable.roundClickable = false;
 */

/**
 * When drag start the clip area or controls, the `roundStart` event is called.
 * @memberof Moveable.Roundable
 * @event roundStart
 * @param {Moveable.Roundable.OnRoundStart} - Parameters for the `roundStart` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     roundable: true,
 *     roundRelative: false,
 * });
 * moveable.on("roundStart", e => {
 *     console.log(e);
 * }).on("round", e => {
 *     e.target.style.borderRadius = e.borderRadius;
 * }).on("roundEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * When drag or double click the border area or controls, the `round` event is called.
 * @memberof Moveable.Roundable
 * @event round
 * @param {Moveable.Roundable.OnRound} - Parameters for the `round` event
 * @example
  * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     roundable: true,
 *     roundRelative: false,
 * });
 * moveable.on("roundStart", e => {
 *     console.log(e);
 * }).on("round", e => {
 *     e.target.style.borderRadius = e.borderRadius;
 * }).on("roundEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * When drag end the border area or controls, the `roundEnd` event is called.
 * @memberof Moveable.Roundable
 * @event roundEnd
 * @param {Moveable.Roundable.onRoundEnd} - Parameters for the `roundEnd` event
 * @example
  * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     roundable: true,
 *     roundRelative: false,
 * });
 * moveable.on("roundStart", e => {
 *     console.log(e);
 * }).on("round", e => {
 *     e.target.style.borderRadius = e.borderRadius;
 * }).on("roundEnd", e => {
 *     console.log(e);
 * });
 */

function isIdentityMatrix(matrix, is3d) {
  var value = is3d ? "matrix3d(" + (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createIdentityMatrix)(4) : "matrix(" + (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createIdentityMatrix)(3) + ")";
  return matrix === value || matrix === "matrix(1,0,0,1,0,0)";
}

var BeforeRenderable = {
  isPinch: true,
  name: "beforeRenderable",
  props: {},
  events: {
    onBeforeRenderStart: "beforeRenderStart",
    onBeforeRender: "beforeRender",
    onBeforeRenderEnd: "beforeRenderEnd",
    onBeforeRenderGroupStart: "beforeRenderGroupStart",
    onBeforeRenderGroup: "beforeRenderGroup",
    onBeforeRenderGroupEnd: "beforeRenderGroupEnd"
  },
  dragRelation: "weak",
  setTransform: function (moveable, e) {
    var _a = moveable.state,
        is3d = _a.is3d,
        target = _a.target,
        targetMatrix = _a.targetMatrix;
    var transform = target === null || target === void 0 ? void 0 : target.style.transform;
    var cssMatrix = is3d ? "matrix3d(" + targetMatrix.join(",") + ")" : "matrix(" + (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.convertMatrixtoCSS)(targetMatrix, true) + ")";
    var startTransform = !transform || transform === "none" ? cssMatrix : transform;
    e.datas.startTransforms = isIdentityMatrix(startTransform, is3d) ? [] : (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.splitSpace)(startTransform);
  },
  resetTransform: function (e) {
    e.datas.nextTransforms = e.datas.startTransforms;
    e.datas.nextTransformAppendedIndexes = [];
  },
  fillDragStartParams: function (moveable, e) {
    return fillParams(moveable, e, {
      setTransform: function (transform) {
        e.datas.startTransforms = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.isArray)(transform) ? transform : (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.splitSpace)(transform);
      },
      isPinch: !!e.isPinch
    });
  },
  fillDragParams: function (moveable, e) {
    return fillParams(moveable, e, {
      isPinch: !!e.isPinch
    });
  },
  dragStart: function (moveable, e) {
    this.setTransform(moveable, e);
    triggerEvent(moveable, "onBeforeRenderStart", this.fillDragStartParams(moveable, e));
  },
  drag: function (moveable, e) {
    this.resetTransform(e);
    triggerEvent(moveable, "onBeforeRender", fillParams(moveable, e, {
      isPinch: !!e.isPinch
    }));
  },
  dragEnd: function (moveable, e) {
    triggerEvent(moveable, "onBeforeRenderEnd", fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      isDrag: e.isDrag
    }));
  },
  dragGroupStart: function (moveable, e) {
    var _this = this;

    this.dragStart(moveable, e);
    var events = fillChildEvents(moveable, "beforeRenderable", e);
    var moveables = moveable.moveables;
    var params = events.map(function (childEvent, i) {
      var childMoveable = moveables[i];

      _this.setTransform(childMoveable, childEvent);

      return _this.fillDragStartParams(childMoveable, childEvent);
    });
    triggerEvent(moveable, "onBeforeRenderGroupStart", fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      targets: moveable.props.targets,
      setTransform: function () {},
      events: params
    }));
  },
  dragGroup: function (moveable, e) {
    var _this = this;

    this.drag(moveable, e);
    var events = fillChildEvents(moveable, "beforeRenderable", e);
    var moveables = moveable.moveables;
    var params = events.map(function (childEvent, i) {
      var childMoveable = moveables[i];

      _this.resetTransform(childEvent);

      return _this.fillDragParams(childMoveable, childEvent);
    });
    triggerEvent(moveable, "onBeforeRenderGroup", fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      targets: moveable.props.targets,
      events: params
    }));
  },
  dragGroupEnd: function (moveable, e) {
    this.dragEnd(moveable, e);
    triggerEvent(moveable, "onBeforeRenderGroupEnd", fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      isDrag: e.isDrag,
      targets: moveable.props.targets
    }));
  },
  dragControlStart: function (moveable, e) {
    return this.dragStart(moveable, e);
  },
  dragControl: function (moveable, e) {
    return this.drag(moveable, e);
  },
  dragControlEnd: function (moveable, e) {
    return this.dragEnd(moveable, e);
  },
  dragGroupControlStart: function (moveable, e) {
    return this.dragGroupStart(moveable, e);
  },
  dragGroupControl: function (moveable, e) {
    return this.dragGroup(moveable, e);
  },
  dragGroupControlEnd: function (moveable, e) {
    return this.dragGroupEnd(moveable, e);
  }
};

var Renderable = {
  name: "renderable",
  props: {},
  events: {
    onRenderStart: "renderStart",
    onRender: "render",
    onRenderEnd: "renderEnd",
    onRenderGroupStart: "renderGroupStart",
    onRenderGroup: "renderGroup",
    onRenderGroupEnd: "renderGroupEnd"
  },
  dragRelation: "weak",
  dragStart: function (moveable, e) {
    triggerEvent(moveable, "onRenderStart", fillParams(moveable, e, {
      isPinch: !!e.isPinch
    }));
  },
  drag: function (moveable, e) {
    triggerEvent(moveable, "onRender", this.fillDragParams(moveable, e));
  },
  dragAfter: function (moveable, e) {
    if (e.resultCount) {
      return this.drag(moveable, e);
    }
  },
  dragEnd: function (moveable, e) {
    triggerEvent(moveable, "onRenderEnd", this.fillDragEndParams(moveable, e));
  },
  dragGroupStart: function (moveable, e) {
    triggerEvent(moveable, "onRenderGroupStart", fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      targets: moveable.props.targets
    }));
  },
  dragGroup: function (moveable, e) {
    var _this = this;

    var events = fillChildEvents(moveable, "beforeRenderable", e);
    var moveables = moveable.moveables;
    var params = events.map(function (childEvent, i) {
      var childMoveable = moveables[i];
      return _this.fillDragParams(childMoveable, childEvent);
    });
    triggerEvent(moveable, "onRenderGroup", fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      targets: moveable.props.targets,
      transform: getNextTransformText(e),
      events: params
    }));
  },
  dragGroupEnd: function (moveable, e) {
    var _this = this;

    var events = fillChildEvents(moveable, "beforeRenderable", e);
    var moveables = moveable.moveables;
    var params = events.map(function (childEvent, i) {
      var childMoveable = moveables[i];
      return _this.fillDragEndParams(childMoveable, childEvent);
    });
    triggerEvent(moveable, "onRenderGroupEnd", fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      isDrag: e.isDrag,
      targets: moveable.props.targets,
      events: params
    }));
  },
  dragControlStart: function (moveable, e) {
    return this.dragStart(moveable, e);
  },
  dragControl: function (moveable, e) {
    return this.drag(moveable, e);
  },
  dragControlAfter: function (moveable, e) {
    return this.dragAfter(moveable, e);
  },
  dragControlEnd: function (moveable, e) {
    return this.dragEnd(moveable, e);
  },
  dragGroupControlStart: function (moveable, e) {
    return this.dragGroupStart(moveable, e);
  },
  dragGroupControl: function (moveable, e) {
    return this.dragGroup(moveable, e);
  },
  dragGroupControlEnd: function (moveable, e) {
    return this.dragGroupEnd(moveable, e);
  },
  fillDragParams: function (moveable, e) {
    return fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      transform: getNextTransformText(e)
    });
  },
  fillDragEndParams: function (moveable, e) {
    return fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      isDrag: e.isDrag
    });
  }
};

function triggerAble(moveable, ableType, eventOperation, eventAffix, eventType, e, requestInstant) {
  var isStart = eventType === "Start";
  var target = moveable.state.target;
  var isRequest = e.isRequest;

  if (!target || isStart && eventAffix.indexOf("Control") > -1 && !isRequest && moveable.areaElement === e.inputEvent.target) {
    return false;
  } // "drag" "Control" "After"


  var eventName = "" + eventOperation + eventAffix + eventType;
  var conditionName = "" + eventOperation + eventAffix + "Condition";
  var isEnd = eventType === "End";
  var isAfter = eventType === "After";
  var isFirstStart = isStart && (!moveable.targetGesto || !moveable.controlGesto || !moveable.targetGesto.isFlag() || !moveable.controlGesto.isFlag());

  if (isFirstStart) {
    moveable.updateRect(eventType, true, false);
  }

  if (eventType === "" && !isRequest) {
    convertDragDist(moveable.state, e);
  } // const isGroup = eventAffix.indexOf("Group") > -1;


  var ables = __spreadArray([], moveable[ableType]);

  if (isRequest) {
    var requestAble_1 = e.requestAble;

    if (!ables.some(function (able) {
      return able.name === requestAble_1;
    })) {
      ables.push.apply(ables, moveable.props.ables.filter(function (able) {
        return able.name === requestAble_1;
      }));
    }
  }

  if (!ables.length) {
    return false;
  }

  var eventAbles = __spreadArray(__spreadArray([BeforeRenderable], ables), [Renderable]).filter(function (able) {
    return able[eventName];
  });

  var datas = e.datas;

  if (isFirstStart) {
    eventAbles.forEach(function (able) {
      able.unset && able.unset(moveable);
    });
  }

  var inputEvent = e.inputEvent;
  var inputTarget;

  if (isEnd && inputEvent) {
    inputTarget = document.elementFromPoint(e.clientX, e.clientY) || inputEvent.target;
  }

  var resultCount = 0;
  var results = eventAbles.filter(function (able) {
    var ableName = able.name;
    var nextDatas = datas[ableName] || (datas[ableName] = {});

    if (isStart) {
      nextDatas.isEventStart = !able[conditionName] || able[conditionName](moveable, e);
    }

    if (nextDatas.isEventStart) {
      var result = able[eventName](moveable, __assign(__assign({}, e), {
        resultCount: resultCount,
        datas: nextDatas,
        originalDatas: datas,
        inputTarget: inputTarget
      }));

      if (isStart && result === false) {
        nextDatas.isEventStart = false;
      }

      resultCount += result ? 1 : 0;
      return result;
    }

    return false;
  });
  var isUpdate = results.length;
  var isForceEnd = false; // end ables

  if (isStart && eventAbles.length && !isUpdate) {
    isForceEnd = eventAbles.filter(function (able) {
      var ableName = able.name;
      var nextDatas = datas[ableName];

      if (nextDatas.isEventStart) {
        if (able.dragRelation === "strong") {
          // cancel drag
          nextDatas.isEventStart = false;
          return false;
        } // start drag


        return true;
      } // cancel event


      return false;
    }).length === 0;
  }

  if (isEnd || isForceEnd) {
    moveable.state.gesto = null;

    if (moveable.moveables) {
      moveable.moveables.forEach(function (childMoveable) {
        childMoveable.state.gesto = null;
      });
    }
  }

  if (isFirstStart && isForceEnd) {
    eventAbles.forEach(function (able) {
      able.unset && able.unset(moveable);
    });
  }

  if (isStart && !isRequest && isUpdate) {
    e === null || e === void 0 ? void 0 : e.preventDefault();
  }

  if (moveable.isUnmounted || isForceEnd) {
    return false;
  }

  if (!isStart && isUpdate && !requestInstant || isEnd) {
    moveable.updateRect(isEnd ? eventType : "", true, false);
    moveable.forceUpdate();
  }

  if (!isStart && !isEnd && !isAfter && isUpdate && !requestInstant) {
    triggerAble(moveable, ableType, eventOperation, eventAffix, eventType + "After", e);
  }

  return true;
}
function getTargetAbleGesto(moveable, moveableTarget, eventAffix) {
  var controlBox = moveable.controlBox.getElement();
  var targets = [];
  targets.push(controlBox);

  if (!moveable.props.dragArea || moveable.props.dragTarget) {
    targets.push(moveableTarget);
  }

  var startFunc = function (e) {
    var eventTarget = e.inputEvent.target;
    var areaElement = moveable.areaElement;
    return eventTarget === areaElement || !moveable.isMoveableElement(eventTarget) && !moveable.controlBox.getElement().contains(eventTarget) || (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.hasClass)(eventTarget, "moveable-area") || (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.hasClass)(eventTarget, "moveable-padding");
  };

  return getAbleGesto(moveable, targets, "targetAbles", eventAffix, {
    dragStart: startFunc,
    pinchStart: startFunc
  });
}
function getAbleGesto(moveable, target, ableType, eventAffix, conditionFunctions) {
  if (conditionFunctions === void 0) {
    conditionFunctions = {};
  }

  var _a = moveable.props,
      pinchOutside = _a.pinchOutside,
      pinchThreshold = _a.pinchThreshold;
  var options = {
    preventDefault: false,
    container: window,
    pinchThreshold: pinchThreshold,
    pinchOutside: pinchOutside
  };
  var gesto = new gesto__WEBPACK_IMPORTED_MODULE_8__["default"](target, options);
  ["drag", "pinch"].forEach(function (eventOperation) {
    ["Start", "", "End"].forEach(function (eventType) {
      gesto.on("" + eventOperation + eventType, function (e) {
        var eventName = e.eventType;

        if (conditionFunctions[eventName] && !conditionFunctions[eventName](e)) {
          e.stop();
          return;
        }

        var result = triggerAble(moveable, ableType, eventOperation, eventAffix, eventType, e);

        if (!result) {
          e.stop();
        }
      });
    });
  });
  return gesto;
}

var EventManager =
/*#__PURE__*/
function () {
  function EventManager(target, moveable, eventName) {
    var _this = this;

    this.target = target;
    this.moveable = moveable;
    this.eventName = eventName;
    this.ables = [];

    this.onEvent = function (e) {
      var eventName = _this.eventName;
      var moveable = _this.moveable;

      if (moveable.state.disableNativeEvent) {
        return;
      }

      _this.ables.forEach(function (able) {
        able[eventName](moveable, {
          inputEvent: e
        });
      });
    };

    this.target.addEventListener(this.eventName.toLowerCase(), this.onEvent);
  }

  var __proto = EventManager.prototype;

  __proto.setAbles = function (ables) {
    this.ables = ables;
  };

  __proto.destroy = function () {
    this.target.removeEventListener(this.eventName.toLowerCase(), this.onEvent);
    this.target = null;
    this.moveable = null;
  };

  return EventManager;
}();

var MoveableManager =
/*#__PURE__*/
function (_super) {
  __extends(MoveableManager, _super);

  function MoveableManager() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.state = __assign({
      container: null,
      gesto: null,
      renderPoses: [[0, 0], [0, 0], [0, 0], [0, 0]],
      disableNativeEvent: false
    }, getTargetInfo(null));
    _this.enabledAbles = [];
    _this.targetAbles = [];
    _this.controlAbles = [];
    _this.rotation = 0;
    _this.scale = [1, 1];
    _this.isUnmounted = false;
    _this.events = {
      "mouseEnter": null,
      "mouseLeave": null
    };
    _this._prevTarget = null;
    _this._prevDragArea = false;
    _this._observer = null;
    _this._observerId = 0;

    _this.onPreventClick = function (e) {
      e.stopPropagation();
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.removeEvent)(window, "click", _this.onPreventClick, true);
    };

    _this.checkUpdateRect = function () {
      if (_this.isDragging()) {
        return;
      }

      var parentMoveable = _this.props.parentMoveable;

      if (parentMoveable) {
        parentMoveable.checkUpdateRect();
        return;
      }

      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.cancelAnimationFrame)(_this._observerId);
      _this._observerId = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.requestAnimationFrame)(function () {
        if (_this.isDragging()) {
          return;
        }

        _this.updateRect();
      });
    };

    return _this;
  }

  var __proto = MoveableManager.prototype;

  __proto.render = function () {
    var props = this.props;
    var state = this.state;
    var parentPosition = props.parentPosition,
        className = props.className,
        propsTarget = props.target,
        zoom = props.zoom,
        cspNonce = props.cspNonce,
        translateZ = props.translateZ,
        ControlBoxElement = props.cssStyled,
        portalContainer = props.portalContainer;
    this.checkUpdate();
    this.updateRenderPoses();

    var _a = parentPosition || {
      left: 0,
      top: 0
    },
        parentLeft = _a.left,
        parentTop = _a.top;

    var left = state.left,
        top = state.top,
        stateTarget = state.target,
        direction = state.direction;
    var groupTargets = props.targets;
    var isDisplay = (groupTargets && groupTargets.length || propsTarget) && stateTarget;
    var isDragging = this.isDragging();
    var ableAttributes = {};
    this.getEnabledAbles().forEach(function (able) {
      ableAttributes["data-able-" + able.name.toLowerCase()] = true;
    });
    return (0,react_simple_compat__WEBPACK_IMPORTED_MODULE_9__.createElement)(ControlBoxElement, __assign({
      cspNonce: cspNonce,
      ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_1__.ref)(this, "controlBox"),
      className: prefix("control-box", direction === -1 ? "reverse" : "", isDragging ? "dragging" : "") + " " + className
    }, ableAttributes, {
      onClick: this.onPreventClick,
      portalContainer: portalContainer,
      style: {
        "position": "absolute",
        "display": isDisplay ? "block" : "none",
        "transform": "translate3d(" + (left - parentLeft) + "px, " + (top - parentTop) + "px, " + translateZ + ")",
        "--zoom": zoom,
        "--zoompx": zoom + "px"
      }
    }), this.renderAbles(), this._renderLines());
  };

  __proto.componentDidMount = function () {
    this.controlBox.getElement();
    var props = this.props;
    var parentMoveable = props.parentMoveable,
        container = props.container,
        wrapperMoveable = props.wrapperMoveable;

    this._updateTargets();

    this._updateNativeEvents();

    this._updateEvents();

    if (!container && !parentMoveable && !wrapperMoveable) {
      this.updateRect("", false, true);
    }

    this.updateCheckInput();

    this._updateObserver(this.props);
  };

  __proto.componentDidUpdate = function (prevProps) {
    this._updateNativeEvents();

    this._updateEvents();

    this._updateTargets();

    this.updateCheckInput();

    this._updateObserver(prevProps);
  };

  __proto.componentWillUnmount = function () {
    this.isUnmounted = true;
    unset(this, "targetGesto");
    unset(this, "controlGesto");
    var events = this.events;

    for (var name in events) {
      var manager = events[name];
      manager && manager.destroy();
    }
  };

  __proto.getContainer = function () {
    var _a = this.props,
        parentMoveable = _a.parentMoveable,
        wrapperMoveable = _a.wrapperMoveable,
        container = _a.container;
    return container || wrapperMoveable && wrapperMoveable.getContainer() || parentMoveable && parentMoveable.getContainer() || this.controlBox.getElement().parentElement;
  };
  /**
   * Check if the target is an element included in the moveable.
   * @method Moveable#isMoveableElement
   * @param - the target
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * window.addEventListener("click", e => {
   *     if (!moveable.isMoveableElement(e.target)) {
   *         moveable.target = e.target;
   *     }
   * });
   */


  __proto.isMoveableElement = function (target) {
    return target && (target.getAttribute("class") || "").indexOf(PREFIX) > -1;
  };
  /**
   * You can drag start the Moveable through the external `MouseEvent`or `TouchEvent`. (Angular: ngDragStart)
   * @method Moveable#dragStart
   * @param - external `MouseEvent`or `TouchEvent`
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * document.body.addEventListener("mousedown", e => {
   *     if (!moveable.isMoveableElement(e.target)) {
   *          moveable.dragStart(e);
   *     }
   * });
   */


  __proto.dragStart = function (e) {
    if (this.targetGesto) {
      this.targetGesto.triggerDragStart(e);
    }

    return this;
  };
  /**
   * Hit test an element or rect on a moveable target.
   * @method Moveable#hitTest
   * @param - element or rect to test
   * @return - Get hit test rate (rate > 0 is hitted)
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * document.body.addEventListener("mousedown", e => {
   *     if (moveable.hitTest(e.target) > 0) {
   *          console.log("hiited");
   *     }
   * });
   */


  __proto.hitTest = function (el) {
    var _a = this.state,
        target = _a.target,
        pos1 = _a.pos1,
        pos2 = _a.pos2,
        pos3 = _a.pos3,
        pos4 = _a.pos4,
        targetClientRect = _a.targetClientRect;

    if (!target) {
      return 0;
    }

    var rect;

    if (el instanceof Element) {
      var clientRect = el.getBoundingClientRect();
      rect = {
        left: clientRect.left,
        top: clientRect.top,
        width: clientRect.width,
        height: clientRect.height
      };
    } else {
      rect = __assign({
        width: 0,
        height: 0
      }, el);
    }

    var rectLeft = rect.left,
        rectTop = rect.top,
        rectWidth = rect.width,
        rectHeight = rect.height;
    var points = (0,overlap_area__WEBPACK_IMPORTED_MODULE_5__.fitPoints)([pos1, pos2, pos4, pos3], targetClientRect);
    var size = (0,overlap_area__WEBPACK_IMPORTED_MODULE_5__.getOverlapSize)(points, [[rectLeft, rectTop], [rectLeft + rectWidth, rectTop], [rectLeft + rectWidth, rectTop + rectHeight], [rectLeft, rectTop + rectHeight]]);
    var totalSize = (0,overlap_area__WEBPACK_IMPORTED_MODULE_5__.getAreaSize)(points);

    if (!size || !totalSize) {
      return 0;
    }

    return Math.min(100, size / totalSize * 100);
  };
  /**
   * Whether the coordinates are inside Moveable
   * @method Moveable#isInside
   * @param - x coordinate
   * @param - y coordinate
   * @return - True if the coordinate is in moveable or false
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * document.body.addEventListener("mousedown", e => {
   *     if (moveable.isInside(e.clientX, e.clientY)) {
   *          console.log("inside");
   *     }
   * });
   */


  __proto.isInside = function (clientX, clientY) {
    var _a = this.state,
        target = _a.target,
        pos1 = _a.pos1,
        pos2 = _a.pos2,
        pos3 = _a.pos3,
        pos4 = _a.pos4,
        targetClientRect = _a.targetClientRect;

    if (!target) {
      return false;
    }

    return (0,overlap_area__WEBPACK_IMPORTED_MODULE_5__.isInside)([clientX, clientY], (0,overlap_area__WEBPACK_IMPORTED_MODULE_5__.fitPoints)([pos1, pos2, pos4, pos3], targetClientRect));
  };
  /**
   * If the width, height, left, and top of all elements change, update the shape of the moveable.
   * @method Moveable#updateRect
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * window.addEventListener("resize", e => {
   *     moveable.updateRect();
   * });
   */


  __proto.updateRect = function (type, isTarget, isSetState) {
    if (isSetState === void 0) {
      isSetState = true;
    }

    var props = this.props;
    var parentMoveable = props.parentMoveable;
    var state = this.state;
    var target = state.target || this.props.target;
    var container = this.getContainer();
    var rootContainer = parentMoveable ? parentMoveable.props.rootContainer : props.rootContainer;
    this.updateState(getTargetInfo(this.controlBox && this.controlBox.getElement(), target, container, container, rootContainer || container), parentMoveable ? false : isSetState);
  };
  /**
   * Check if the moveable state is being dragged.
   * @method Moveable#isDragging
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * // false
   * console.log(moveable.isDragging());
   *
   * moveable.on("drag", () => {
   *   // true
   *   console.log(moveable.isDragging());
   * });
   */


  __proto.isDragging = function () {
    return (this.targetGesto ? this.targetGesto.isFlag() : false) || (this.controlGesto ? this.controlGesto.isFlag() : false);
  };
  /**
   * If the width, height, left, and top of the only target change, update the shape of the moveable.
   * @method Moveable#updateTarget
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * moveable.updateTarget();
   */


  __proto.updateTarget = function (type) {
    this.updateRect(type, true);
  };
  /**
   * You can get the vertex information, position and offset size information of the target based on the container.
   * @method Moveable#getRect
   * @return - The Rect Info
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * const rectInfo = moveable.getRect();
   */


  __proto.getRect = function () {
    var state = this.state;
    var poses = getAbsolutePosesByState(this.state);
    var pos1 = poses[0],
        pos2 = poses[1],
        pos3 = poses[2],
        pos4 = poses[3];
    var rect = getRect(poses);
    var offsetWidth = state.width,
        offsetHeight = state.height;
    var width = rect.width,
        height = rect.height,
        left = rect.left,
        top = rect.top;
    var statePos = [state.left, state.top];
    var origin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(statePos, state.origin);
    var beforeOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(statePos, state.beforeOrigin);
    var transformOrigin = state.transformOrigin;
    return {
      width: width,
      height: height,
      left: left,
      top: top,
      pos1: pos1,
      pos2: pos2,
      pos3: pos3,
      pos4: pos4,
      offsetWidth: offsetWidth,
      offsetHeight: offsetHeight,
      beforeOrigin: beforeOrigin,
      origin: origin,
      transformOrigin: transformOrigin,
      rotation: this.getRotation()
    };
  };
  /**
   * Get a manager that manages the moveable's state and props.
   * @method Moveable#getManager
   * @return - The Rect Info
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * const manager = moveable.getManager(); // real moveable class instance
   */


  __proto.getManager = function () {
    return this;
  };

  __proto.getRotation = function () {
    var _a = this.state,
        pos1 = _a.pos1,
        pos2 = _a.pos2,
        direction = _a.direction;
    return getAbsoluteRotation(pos1, pos2, direction);
  };
  /**
   * Request able through a method rather than an event.
   * At the moment of execution, requestStart is executed,
   * and then request and requestEnd can be executed through Requester.
   * @method Moveable#request
   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Draggable.html#request|Draggable Requester}
   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Resizable.html#request|Resizable Requester}
   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Scalable.html#request|Scalable Requester}
   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Rotatable.html#request|Rotatable Requester}
   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.OriginDraggable.html#request|OriginDraggable Requester}
   * @param - ableName
   * @param - request to be able params.
   * @param - If isInstant is true, request and requestEnd are executed immediately.
   * @return - Able Requester. If there is no request in able, nothing will work.
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * // Instantly Request (requestStart - request - requestEnd)
   * moveable.request("draggable", { deltaX: 10, deltaY: 10 }, true);
   *
   * // Start move
   * const requester = moveable.request("draggable");
   * requester.request({ deltaX: 10, deltaY: 10 });
   * requester.request({ deltaX: 10, deltaY: 10 });
   * requester.request({ deltaX: 10, deltaY: 10 });
   * requester.requestEnd();
   */


  __proto.request = function (ableName, param, isInstant) {
    if (param === void 0) {
      param = {};
    }

    var _a = this.props,
        ables = _a.ables,
        groupable = _a.groupable;
    var requsetAble = ables.filter(function (able) {
      return able.name === ableName;
    })[0];

    if (this.isDragging() || !requsetAble || !requsetAble.request) {
      return {
        request: function () {
          return this;
        },
        requestEnd: function () {
          return this;
        }
      };
    }

    var self = this;
    var ableRequester = requsetAble.request(this);
    var requestInstant = isInstant || param.isInstant;
    var ableType = ableRequester.isControl ? "controlAbles" : "targetAbles";
    var eventAffix = "" + (groupable ? "Group" : "") + (ableRequester.isControl ? "Control" : "");
    var requester = {
      request: function (ableParam) {
        triggerAble(self, ableType, "drag", eventAffix, "", __assign(__assign({}, ableRequester.request(ableParam)), {
          requestAble: ableName,
          isRequest: true
        }), requestInstant);
        return this;
      },
      requestEnd: function () {
        triggerAble(self, ableType, "drag", eventAffix, "End", __assign(__assign({}, ableRequester.requestEnd()), {
          requestAble: ableName,
          isRequest: true
        }), requestInstant);
        return this;
      }
    };
    triggerAble(self, ableType, "drag", eventAffix, "Start", __assign(__assign({}, ableRequester.requestStart(param)), {
      requestAble: ableName,
      isRequest: true
    }), requestInstant);
    return requestInstant ? requester.request(param).requestEnd() : requester;
  };
  /**
   * Remove the Moveable object and the events.
   * @method Moveable#destroy
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * moveable.destroy();
   */


  __proto.destroy = function () {
    this.componentWillUnmount();
  };

  __proto.updateRenderPoses = function () {
    var state = this.state;
    var props = this.props;
    var originalBeforeOrigin = state.originalBeforeOrigin,
        transformOrigin = state.transformOrigin,
        allMatrix = state.allMatrix,
        is3d = state.is3d,
        pos1 = state.pos1,
        pos2 = state.pos2,
        pos3 = state.pos3,
        pos4 = state.pos4,
        stateLeft = state.left,
        stateTop = state.top;

    var _a = props.padding || {},
        _b = _a.left,
        left = _b === void 0 ? 0 : _b,
        _c = _a.top,
        top = _c === void 0 ? 0 : _c,
        _d = _a.bottom,
        bottom = _d === void 0 ? 0 : _d,
        _e = _a.right,
        right = _e === void 0 ? 0 : _e;

    var n = is3d ? 4 : 3;
    var absoluteOrigin = props.groupable ? originalBeforeOrigin : (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(originalBeforeOrigin, [stateLeft, stateTop]);
    state.renderPoses = [(0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(pos1, calculatePadding(allMatrix, [-left, -top], transformOrigin, absoluteOrigin, n)), (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(pos2, calculatePadding(allMatrix, [right, -top], transformOrigin, absoluteOrigin, n)), (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(pos3, calculatePadding(allMatrix, [-left, bottom], transformOrigin, absoluteOrigin, n)), (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(pos4, calculatePadding(allMatrix, [right, bottom], transformOrigin, absoluteOrigin, n))];
  };

  __proto.checkUpdate = function () {
    var _a = this.props,
        target = _a.target,
        container = _a.container,
        parentMoveable = _a.parentMoveable;
    var _b = this.state,
        stateTarget = _b.target,
        stateContainer = _b.container;

    if (!stateTarget && !target) {
      return;
    }

    this.updateAbles();
    var isChanged = !equals(stateTarget, target) || !equals(stateContainer, container);

    if (!isChanged) {
      return;
    }

    var moveableContainer = container || this.controlBox;

    if (moveableContainer) {
      this.unsetAbles();
    }

    this.updateState({
      target: target,
      container: container
    });

    if (!parentMoveable && moveableContainer) {
      this.updateRect("End", false, false);
    }
  };

  __proto.triggerEvent = function (name, e) {
    var callback = this.props[name];
    return callback && callback(e);
  };

  __proto.useCSS = function (tag, css) {
    var customStyleMap = this.props.customStyledMap;
    var key = tag + css;

    if (!customStyleMap[key]) {
      customStyleMap[key] = (0,react_compat_css_styled__WEBPACK_IMPORTED_MODULE_10__["default"])(tag, css);
    }

    return customStyleMap[key];
  };

  __proto.unsetAbles = function () {
    var _this = this;

    this.targetAbles.forEach(function (able) {
      if (able.unset) {
        able.unset(_this);
      }
    });
  };

  __proto.updateAbles = function (ables, eventAffix) {
    if (ables === void 0) {
      ables = this.props.ables;
    }

    if (eventAffix === void 0) {
      eventAffix = "";
    }

    var props = this.props;
    var triggerAblesSimultaneously = props.triggerAblesSimultaneously;
    var enabledAbles = ables.filter(function (able) {
      return able && (able.always && props[able.name] !== false || props[able.name]);
    });
    var dragStart = "drag" + eventAffix + "Start";
    var pinchStart = "pinch" + eventAffix + "Start";
    var dragControlStart = "drag" + eventAffix + "ControlStart";
    var targetAbles = filterAbles(enabledAbles, [dragStart, pinchStart], triggerAblesSimultaneously);
    var controlAbles = filterAbles(enabledAbles, [dragControlStart], triggerAblesSimultaneously);
    this.enabledAbles = enabledAbles;
    this.targetAbles = targetAbles;
    this.controlAbles = controlAbles;
  };

  __proto.updateState = function (nextState, isSetState) {
    if (isSetState) {
      this.setState(nextState);
    } else {
      var state = this.state;

      for (var name in nextState) {
        state[name] = nextState[name];
      }
    }
  };

  __proto.getEnabledAbles = function () {
    var props = this.props;
    var ables = props.ables;
    return ables.filter(function (able) {
      return able && props[able.name];
    });
  };

  __proto.renderAbles = function () {
    var _this = this;

    var props = this.props;
    var triggerAblesSimultaneously = props.triggerAblesSimultaneously;
    var Renderer = {
      createElement: react_simple_compat__WEBPACK_IMPORTED_MODULE_9__.createElement
    };
    return groupByMap(flat(filterAbles(this.getEnabledAbles(), ["render"], triggerAblesSimultaneously).map(function (_a) {
      var render = _a.render;
      return render(_this, Renderer) || [];
    })).filter(function (el) {
      return el;
    }), function (_a) {
      var key = _a.key;
      return key;
    }).map(function (group) {
      return group[0];
    });
  };

  __proto.updateCheckInput = function () {
    this.targetGesto && (this.targetGesto.options.checkInput = this.props.checkInput);
  };

  __proto._updateObserver = function (prevProps) {
    var _a;

    var props = this.props;
    var target = props.target;

    if (!window.ResizeObserver || !target || !props.useResizeObserver) {
      (_a = this._observer) === null || _a === void 0 ? void 0 : _a.disconnect();
      return;
    }

    if (prevProps.target === target && this._observer) {
      return;
    }

    var observer = new ResizeObserver(this.checkUpdateRect);
    observer.observe(target, {
      box: "border-box"
    });
    this._observer = observer;
    return;
  };

  __proto._updateEvents = function () {
    var controlBoxElement = this.controlBox.getElement();
    var hasTargetAble = this.targetAbles.length;
    var hasControlAble = this.controlAbles.length;
    var props = this.props;
    var target = props.dragTarget || props.target;

    var isUnset = !hasTargetAble && this.targetGesto || this._isTargetChanged(true);

    if (isUnset) {
      unset(this, "targetGesto");
      this.updateState({
        gesto: null
      });
    }

    if (!hasControlAble) {
      unset(this, "controlGesto");
    }

    if (target && hasTargetAble && !this.targetGesto) {
      this.targetGesto = getTargetAbleGesto(this, target, "");
    }

    if (!this.controlGesto && hasControlAble) {
      this.controlGesto = getAbleGesto(this, controlBoxElement, "controlAbles", "Control");
    }
  };

  __proto._updateTargets = function () {
    var props = this.props;
    this._prevTarget = props.dragTarget || props.target;
    this._prevDragArea = props.dragArea;
  };

  __proto._renderLines = function () {
    var props = this.props;
    var edge = props.edge,
        zoom = props.zoom,
        hideDefaultLines = props.hideDefaultLines;

    if (hideDefaultLines) {
      return [];
    }

    var renderPoses = this.state.renderPoses;
    var Renderer = {
      createElement: react_simple_compat__WEBPACK_IMPORTED_MODULE_9__.createElement
    };
    return [renderLine(Renderer, edge ? "n" : "", renderPoses[0], renderPoses[1], zoom, 0), renderLine(Renderer, edge ? "e" : "", renderPoses[1], renderPoses[3], zoom, 1), renderLine(Renderer, edge ? "w" : "", renderPoses[0], renderPoses[2], zoom, 2), renderLine(Renderer, edge ? "s" : "", renderPoses[2], renderPoses[3], zoom, 3)];
  };

  __proto._isTargetChanged = function (useDragArea) {
    var props = this.props;
    var target = props.dragTarget || props.target;
    var prevTarget = this._prevTarget;
    var prevDragArea = this._prevDragArea;
    var dragArea = props.dragArea; // check target without dragArea

    var isTargetChanged = !dragArea && prevTarget !== target;
    var isDragAreaChanged = (useDragArea || dragArea) && prevDragArea !== dragArea;
    return isTargetChanged || isDragAreaChanged;
  };

  __proto._updateNativeEvents = function () {
    var _this = this;

    var props = this.props;
    var target = props.dragArea ? this.areaElement : this.state.target;
    var events = this.events;
    var eventKeys = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getKeys)(events);

    if (this._isTargetChanged()) {
      for (var eventName in events) {
        var manager = events[eventName];
        manager && manager.destroy();
        events[eventName] = null;
      }
    }

    if (!target) {
      return;
    }

    var enabledAbles = this.enabledAbles;
    eventKeys.forEach(function (eventName) {
      var ables = filterAbles(enabledAbles, [eventName]);
      var hasAbles = ables.length > 0;
      var manager = events[eventName];

      if (!hasAbles) {
        if (manager) {
          manager.destroy();
          events[eventName] = null;
        }

        return;
      }

      if (!manager) {
        manager = new EventManager(target, _this, eventName);
        events[eventName] = manager;
      }

      manager.setAbles(ables);
    });
  };

  MoveableManager.defaultProps = {
    target: null,
    dragTarget: null,
    container: null,
    rootContainer: null,
    origin: true,
    edge: false,
    parentMoveable: null,
    wrapperMoveable: null,
    parentPosition: null,
    portalContainer: null,
    useResizeObserver: false,
    ables: [],
    pinchThreshold: 20,
    dragArea: false,
    passDragArea: false,
    transformOrigin: "",
    className: "",
    zoom: 1,
    triggerAblesSimultaneously: false,
    padding: {},
    pinchOutside: true,
    checkInput: false,
    groupable: false,
    hideDefaultLines: false,
    cspNonce: "",
    translateZ: 0,
    cssStyled: null,
    customStyledMap: {},
    props: {}
  };
  return MoveableManager;
}(react_simple_compat__WEBPACK_IMPORTED_MODULE_9__.PureComponent);
/**
 * The target to indicate Moveable Control Box.
 * @name Moveable#target
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 * moveable.target = document.querySelector(".target");
 */

/**
 * Zooms in the elements of a moveable.
 * @name Moveable#zoom
 * @default 1
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 * moveable.zoom = 2;
 */

/**
 * Whether the target size is detected and updated whenever it changes.
 * @name Moveable#zoom
 * @default false
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 * moveable.useResizeObserver = true;
 */

/**
 * Resize, Scale Events at edges
 * @name Moveable#edge
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 * moveable.edge = true;
 */

/**
 * You can specify the className of the moveable controlbox.
 * @name Moveable#className
 * @default ""
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   className: "",
 * });
 *
 * moveable.className = "moveable1";
 */

/**
 * The target(s) to drag Moveable target(s)
 * @name Moveable#dragTarget
 * @default target
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 * moveable.target = document.querySelector(".target");
 * moveable.dragTarget = document.querySelector(".dragTarget");
 */

/**
 * `renderStart` event occurs at the first start of all events.
 * @memberof Moveable
 * @event renderStart
 * @param {Moveable.OnRenderStart} - Parameters for the `renderStart` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: document.querySelector(".target"),
 * });
 * moveable.on("renderStart", ({ target }) => {
 *     console.log("onRenderStart", target);
 * });
 */

/**
 * `render` event occurs before the target is drawn on the screen.
 * @memberof Moveable
 * @event render
 * @param {Moveable.OnRender} - Parameters for the `render` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: document.querySelector(".target"),
 * });
 * moveable.on("render", ({ target }) => {
 *     console.log("onRender", target);
 * });
 */

/**
 * `renderEnd` event occurs at the end of all events.
 * @memberof Moveable
 * @event renderEnd
 * @param {Moveable.OnRenderEnd} - Parameters for the `renderEnd` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: document.querySelector(".target"),
 * });
 * moveable.on("renderEnd", ({ target }) => {
 *     console.log("onRenderEnd", target);
 * });
 */

/**
 * `renderGroupStart` event occurs at the first start of all events in group.
 * @memberof Moveable
 * @event renderGroupStart
 * @param {Moveable.OnRenderGroupStart} - Parameters for the `renderGroupStart` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 * });
 * moveable.on("renderGroupStart", ({ targets }) => {
 *     console.log("onRenderGroupStart", targets);
 * });
 */

/**
 * `renderGroup` event occurs before the target is drawn on the screen in group.
 * @memberof Moveable
 * @event renderGroup
 * @param {Moveable.OnRenderGroup} - Parameters for the `renderGroup` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 * });
 * moveable.on("renderGroup", ({ targets }) => {
 *     console.log("onRenderGroup", targets);
 * });
 */

/**
 * `renderGroupEnd` event occurs at the end of all events in group.
 * @memberof Moveable
 * @event renderGroupEnd
 * @param {Moveable.OnRenderGroupEnd} - Parameters for the `renderGroupEnd` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 * });
 * moveable.on("renderGroupEnd", ({ targets }) => {
 *     console.log("onRenderGroupEnd", targets);
 * });
 */

var Groupable = {
  name: "groupable",
  props: {
    defaultGroupRotate: Number,
    defaultGroupOrigin: String,
    groupable: Boolean
  },
  events: {},
  render: function (moveable, React) {
    var targets = moveable.props.targets || [];
    moveable.moveables = [];
    var _a = moveable.state,
        left = _a.left,
        top = _a.top;
    var position = {
      left: left,
      top: top
    };
    var props = moveable.props;
    return targets.map(function (target, i) {
      return React.createElement(MoveableManager, {
        key: "moveable" + i,
        ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_1__.refs)(moveable, "moveables", i),
        target: target,
        origin: false,
        cssStyled: props.cssStyled,
        customStyledMap: props.customStyledMap,
        useResizeObserver: props.useResizeObserver,
        parentMoveable: moveable,
        parentPosition: position
      });
    });
  }
};

var Clickable = makeAble("clickable", {
  props: {
    clickable: Boolean
  },
  events: {
    onClick: "click",
    onClickGroup: "clickGroup"
  },
  always: true,
  dragRelation: "weak",
  dragStart: function (moveable, e) {
    if (!e.isRequest) {
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.addEvent)(window, "click", moveable.onPreventClick, true);
    }
  },
  dragControlStart: function (moveable, e) {
    this.dragStart(moveable, e);
  },
  dragGroupStart: function (moveable, e) {
    this.dragStart(moveable, e);
    e.datas.inputTarget = e.inputEvent && e.inputEvent.target;
  },
  dragEnd: function (moveable, e) {
    this.endEvent(moveable);
    var target = moveable.state.target;
    var inputEvent = e.inputEvent;
    var inputTarget = e.inputTarget;
    var isMoveableElement = moveable.isMoveableElement(inputTarget);
    var containsElement = !isMoveableElement && moveable.controlBox.getElement().contains(inputTarget);

    if (!e.isDrag || containsElement) {
      this.unset(moveable);
    }

    if (!inputEvent || !inputTarget || e.isDrag || moveable.isMoveableElement(inputTarget) || containsElement // External event duplicate target or dragAreaElement
    ) {
        return;
      }

    var containsTarget = target.contains(inputTarget);
    triggerEvent(moveable, "onClick", fillParams(moveable, e, {
      isDouble: e.isDouble,
      inputTarget: inputTarget,
      isTarget: target === inputTarget,
      containsTarget: containsTarget
    }));
  },
  dragGroupEnd: function (moveable, e) {
    this.endEvent(moveable);
    var inputEvent = e.inputEvent;
    var inputTarget = e.inputTarget;

    if (!inputEvent || !inputTarget || e.isDrag || moveable.isMoveableElement(inputTarget) // External event duplicate target or dragAreaElement
    || e.datas.inputTarget === inputTarget) {
      return;
    }

    var targets = moveable.props.targets;
    var targetIndex = targets.indexOf(inputTarget);
    var isTarget = targetIndex > -1;
    var containsTarget = false;

    if (targetIndex === -1) {
      targetIndex = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.findIndex)(targets, function (parentTarget) {
        return parentTarget.contains(inputTarget);
      });
      containsTarget = targetIndex > -1;
    }

    triggerEvent(moveable, "onClickGroup", fillParams(moveable, e, {
      isDouble: e.isDouble,
      targets: targets,
      inputTarget: inputTarget,
      targetIndex: targetIndex,
      isTarget: isTarget,
      containsTarget: containsTarget
    }));
  },
  dragControlEnd: function (moveable, e) {
    this.dragEnd(moveable, e);
  },
  dragGroupControlEnd: function (moveable, e) {
    this.dragEnd(moveable, e);
  },
  endEvent: function (moveable) {
    var _this = this;

    (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.requestAnimationFrame)(function () {
      _this.unset(moveable);
    });
  },
  unset: function (moveable) {
    (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.removeEvent)(window, "click", moveable.onPreventClick, true);
  }
});
/**
 * When you click on the element, the `click` event is called.
 * @memberof Moveable
 * @event click
 * @param {Moveable.OnClick} - Parameters for the `click` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: document.querySelector(".target"),
 * });
 * moveable.on("click", ({ hasTarget, containsTarget, targetIndex }) => {
 *     // If you click on an element other than the target and not included in the target, index is -1.
 *     console.log("onClickGroup", target, hasTarget, containsTarget, targetIndex);
 * });
 */

/**
 * When you click on the element inside the group, the `clickGroup` event is called.
 * @memberof Moveable
 * @event clickGroup
 * @param {Moveable.OnClickGroup} - Parameters for the `clickGroup` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 * });
 * moveable.on("clickGroup", ({ inputTarget, isTarget, containsTarget, targetIndex }) => {
 *     // If you click on an element other than the target and not included in the target, index is -1.
 *     console.log("onClickGroup", inputTarget, isTarget, containsTarget, targetIndex);
 * });
 */

function getDraggableEvent(e) {
  var datas = e.originalDatas.draggable;

  if (!datas) {
    e.originalDatas.draggable = {};
    datas = e.originalDatas.draggable;
  }

  return __assign(__assign({}, e), {
    datas: datas
  });
}

var edgeDraggable = makeAble("edgeDraggable", {
  dragControlCondition: function (moveable, e) {
    if (!moveable.props.edgeDraggable || !e.inputEvent) {
      return false;
    }

    var target = e.inputEvent.target;
    return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.hasClass)(target, prefix("direction")) && (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.hasClass)(target, prefix("line"));
  },
  dragControlStart: function (moveable, e) {
    return Draggable.dragStart(moveable, getDraggableEvent(e));
  },
  dragControl: function (moveable, e) {
    return Draggable.drag(moveable, getDraggableEvent(e));
  },
  dragControlEnd: function (moveable, e) {
    return Draggable.dragEnd(moveable, getDraggableEvent(e));
  },
  dragGroupControlCondition: function (moveable, e) {
    if (!moveable.props.edgeDraggable || !e.inputEvent) {
      return false;
    }

    var target = e.inputEvent.target;
    return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.hasClass)(target, prefix("direction")) && (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.hasClass)(target, prefix("line"));
  },
  dragGroupControlStart: function (moveable, e) {
    return Draggable.dragGroupStart(moveable, getDraggableEvent(e));
  },
  dragGroupControl: function (moveable, e) {
    return Draggable.dragGroup(moveable, getDraggableEvent(e));
  },
  dragGroupControlEnd: function (moveable, e) {
    return Draggable.dragGroupEnd(moveable, getDraggableEvent(e));
  },
  unset: function (moveable) {
    return Draggable.unset(moveable);
  }
});
/**
 * Whether to move by dragging the edge line (default: false)
 * @name Moveable.Draggable#edgeDraggable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *  draggable: true,
 *  edgeDraggable: false,
 * });
 *
 * moveable.edgeDraggable = true;
 */

var IndividualGroupable = {
  name: "individualGroupable",
  props: {
    individualGroupable: Boolean
  },
  events: {}
};

var MOVEABLE_ABLES = /*#__PURE__*/[BeforeRenderable, Default, Snappable, Pinchable, Draggable, edgeDraggable, Rotatable, Resizable, Scalable, Warpable, Scrollable, Padding, Origin, OriginDraggable, Clippable, Roundable, Groupable, IndividualGroupable, Clickable, DragArea, Renderable];
var MOVEABLE_EVENTS_PROPS_MAP = /*#__PURE__*/MOVEABLE_ABLES.reduce(function (current, able) {
  return __assign(__assign({}, current), "events" in able ? able.events : {});
}, {});
var MOVEABLE_PROPS_MAP = /*#__PURE__*/MOVEABLE_ABLES.reduce(function (current, able) {
  return __assign(__assign({}, current), able.props);
}, {});
var MOVEABLE_EVENTS_MAP = /*#__PURE__*/invertObject(MOVEABLE_EVENTS_PROPS_MAP);
var MOVEABLE_EVENTS = Object.keys(MOVEABLE_EVENTS_MAP);
var MOVEABLE_PROPS = Object.keys(MOVEABLE_PROPS_MAP);

function getMaxPos(poses, index) {
  return Math.max.apply(Math, poses.map(function (_a) {
    var pos1 = _a[0],
        pos2 = _a[1],
        pos3 = _a[2],
        pos4 = _a[3];
    return Math.max(pos1[index], pos2[index], pos3[index], pos4[index]);
  }));
}

function getMinPos(poses, index) {
  return Math.min.apply(Math, poses.map(function (_a) {
    var pos1 = _a[0],
        pos2 = _a[1],
        pos3 = _a[2],
        pos4 = _a[3];
    return Math.min(pos1[index], pos2[index], pos3[index], pos4[index]);
  }));
}

function getGroupRect(moveables, rotation) {
  if (!moveables.length) {
    return [0, 0, 0, 0];
  }

  var moveablePoses = moveables.map(function (_a) {
    var state = _a.state;
    return getAbsolutePosesByState(state);
  });
  var minX = MAX_NUM;
  var minY = MAX_NUM;
  var groupWidth = 0;
  var groupHeight = 0;
  var fixedRotation = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(rotation, TINY_NUM);

  if (fixedRotation % 90) {
    var rad_1 = fixedRotation / 180 * Math.PI;
    var a1_1 = Math.tan(rad_1);
    var a2_1 = -1 / a1_1;
    var b1MinMax_1 = [MIN_NUM, MAX_NUM];
    var b2MinMax_1 = [MIN_NUM, MAX_NUM];
    moveablePoses.forEach(function (poses) {
      poses.forEach(function (pos) {
        // ax + b = y
        // b = y - ax
        var b1 = pos[1] - a1_1 * pos[0];
        var b2 = pos[1] - a2_1 * pos[0];
        b1MinMax_1[0] = Math.max(b1MinMax_1[0], b1);
        b1MinMax_1[1] = Math.min(b1MinMax_1[1], b1);
        b2MinMax_1[0] = Math.max(b2MinMax_1[0], b2);
        b2MinMax_1[1] = Math.min(b2MinMax_1[1], b2);
      });
    });
    b1MinMax_1.forEach(function (b1) {
      // a1x + b1 = a2x + b2
      b2MinMax_1.forEach(function (b2) {
        // (a1 - a2)x = b2 - b1
        var x = (b2 - b1) / (a1_1 - a2_1);
        var y = a1_1 * x + b1;
        minX = Math.min(minX, x);
        minY = Math.min(minY, y);
      });
    });
    var rotatePoses = moveablePoses.map(function (_a) {
      var pos1 = _a[0],
          pos2 = _a[1],
          pos3 = _a[2],
          pos4 = _a[3];
      return [(0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.rotate)(pos1, -rad_1), (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.rotate)(pos2, -rad_1), (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.rotate)(pos3, -rad_1), (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.rotate)(pos4, -rad_1)];
    });
    groupWidth = getMaxPos(rotatePoses, 0) - getMinPos(rotatePoses, 0);
    groupHeight = getMaxPos(rotatePoses, 1) - getMinPos(rotatePoses, 1);
  } else {
    minX = getMinPos(moveablePoses, 0);
    minY = getMinPos(moveablePoses, 1);
    groupWidth = getMaxPos(moveablePoses, 0) - minX;
    groupHeight = getMaxPos(moveablePoses, 1) - minY;

    if (fixedRotation % 180) {
      var changedWidth = groupWidth;
      groupWidth = groupHeight;
      groupHeight = changedWidth;
    }
  }

  return [minX, minY, groupWidth, groupHeight];
}
/**
 * @namespace Moveable.Group
 * @description You can make targets moveable.
 */


var MoveableGroup =
/*#__PURE__*/
function (_super) {
  __extends(MoveableGroup, _super);

  function MoveableGroup() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.differ = new _egjs_children_differ__WEBPACK_IMPORTED_MODULE_6__["default"]();
    _this.moveables = [];
    _this.transformOrigin = "50% 50%";
    return _this;
  }

  var __proto = MoveableGroup.prototype;

  __proto.checkUpdate = function () {
    this.updateAbles();
  };

  __proto.updateRect = function (type, isTarget, isSetState) {
    if (isSetState === void 0) {
      isSetState = true;
    }

    if (!this.controlBox) {
      return;
    }

    this.moveables.forEach(function (moveable) {
      moveable.updateRect(type, false, false);
    });
    var state = this.state;
    var props = this.props;
    var target = state.target || props.target;

    if (!isTarget || type !== "" && props.updateGroup) {
      // reset rotataion
      this.rotation = props.defaultGroupRotate;
      this.transformOrigin = props.defaultGroupOrigin || "50% 50%";
      this.scale = [1, 1];
    }

    var rotation = this.rotation;
    var scale = this.scale;

    var _a = getGroupRect(this.moveables, rotation),
        left = _a[0],
        top = _a[1],
        width = _a[2],
        height = _a[3]; // tslint:disable-next-line: max-line-length


    var transform = "rotate(" + rotation + "deg) scale(" + (scale[0] >= 0 ? 1 : -1) + ", " + (scale[1] >= 0 ? 1 : -1) + ")";
    target.style.cssText += "left:0px;top:0px; transform-origin: " + this.transformOrigin + "; width:" + width + "px; height:" + height + "px;" + ("transform:" + transform);
    state.width = width;
    state.height = height;
    var container = this.getContainer();
    var info = getTargetInfo(this.controlBox.getElement(), target, this.controlBox.getElement(), this.getContainer(), this.props.rootContainer || container);
    var pos = [info.left, info.top];

    var _b = getAbsolutePosesByState(info),
        pos1 = _b[0],
        pos2 = _b[1],
        pos3 = _b[2],
        pos4 = _b[3]; // info.left + info.pos(1 ~ 4)


    var minPos = (0,overlap_area__WEBPACK_IMPORTED_MODULE_5__.getMinMaxs)([pos1, pos2, pos3, pos4]);
    var delta = [minPos.minX, minPos.minY];
    info.pos1 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(pos1, delta);
    info.pos2 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(pos2, delta);
    info.pos3 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(pos3, delta);
    info.pos4 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(pos4, delta);
    info.left = left - info.left + delta[0];
    info.top = top - info.top + delta[1];
    info.origin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(pos, info.origin), delta);
    info.beforeOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(pos, info.beforeOrigin), delta);
    info.originalBeforeOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(pos, info.originalBeforeOrigin); // info.transformOrigin = minus(plus(pos, info.transformOrigin!), delta);

    var clientRect = info.targetClientRect;
    var direction = scale[0] * scale[1] > 0 ? 1 : -1;
    clientRect.top += info.top - state.top;
    clientRect.left += info.left - state.left;
    target.style.transform = "translate(" + -delta[0] + "px, " + -delta[1] + "px) " + transform;
    this.updateState(__assign(__assign({}, info), {
      direction: direction,
      beforeDirection: direction
    }), isSetState);
  };

  __proto.getRect = function () {
    return __assign(__assign({}, _super.prototype.getRect.call(this)), {
      children: this.moveables.map(function (child) {
        return child.getRect();
      })
    });
  };

  __proto.triggerEvent = function (name, e, isManager) {
    if (isManager || name.indexOf("Group") > -1) {
      return _super.prototype.triggerEvent.call(this, name, e);
    }
  };

  __proto.updateAbles = function () {
    _super.prototype.updateAbles.call(this, __spreadArray(__spreadArray([], this.props.ables), [Groupable]), "Group");
  };

  __proto._updateTargets = function () {
    _super.prototype._updateTargets.call(this);

    this._prevTarget = this.props.dragTarget || this.areaElement;
  };

  __proto._updateEvents = function () {
    var state = this.state;
    var props = this.props;
    var prevTarget = this._prevTarget;
    var nextTarget = props.dragTarget || this.areaElement;

    if (prevTarget !== nextTarget) {
      unset(this, "targetGesto");
      unset(this, "controlGesto");
      state.target = null;
    }

    if (!state.target) {
      state.target = this.areaElement;
      this.controlBox.getElement().style.display = "block";
      this.targetGesto = getTargetAbleGesto(this, nextTarget, "Group");
      this.controlGesto = getAbleGesto(this, this.controlBox.getElement(), "controlAbles", "GroupControl");
    }

    var isContainerChanged = !equals(state.container, props.container);

    if (isContainerChanged) {
      state.container = props.container;
    }

    var _a = this.differ.update(props.targets),
        added = _a.added,
        changed = _a.changed,
        removed = _a.removed;

    if (isContainerChanged || added.length || changed.length || removed.length) {
      this.updateRect();
    }
  };

  __proto._updateObserver = function () {};

  MoveableGroup.defaultProps = __assign(__assign({}, MoveableManager.defaultProps), {
    transformOrigin: ["50%", "50%"],
    groupable: true,
    dragArea: true,
    keepRatio: true,
    targets: [],
    defaultGroupRotate: 0,
    defaultGroupOrigin: "50% 50%"
  });
  return MoveableGroup;
}(MoveableManager);

/**
 * @namespace Moveable.IndividualGroup
 * @description Create targets individually, not as a group.Create targets individually, not as a group.
 */

var MoveableIndividualGroup =
/*#__PURE__*/
function (_super) {
  __extends(MoveableIndividualGroup, _super);

  function MoveableIndividualGroup() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.moveables = [];
    return _this;
  }

  var __proto = MoveableIndividualGroup.prototype;

  __proto.render = function () {
    var _this = this;

    var _a = this.props,
        cspNonce = _a.cspNonce,
        ControlBoxElement = _a.cssStyled,
        targets = _a.targets;
    return (0,react_simple_compat__WEBPACK_IMPORTED_MODULE_9__.createElement)(ControlBoxElement, {
      cspNonce: cspNonce,
      ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_1__.ref)(this, "controlBox"),
      className: prefix("control-box")
    }, targets.map(function (target, i) {
      return (0,react_simple_compat__WEBPACK_IMPORTED_MODULE_9__.createElement)(MoveableManager, __assign({
        key: "moveable" + i,
        ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_1__.refs)(_this, "moveables", i)
      }, _this.props, {
        target: target,
        wrapperMoveable: _this
      }));
    }));
  };

  __proto.componentDidUpdate = function () {};

  __proto.updateRect = function (type, isTarget, isSetState) {
    if (isSetState === void 0) {
      isSetState = true;
    }

    this.moveables.forEach(function (moveable) {
      moveable.updateRect(type, isTarget, isSetState);
    });
  };

  __proto.getRect = function () {
    return __assign(__assign({}, _super.prototype.getRect.call(this)), {
      children: this.moveables.map(function (child) {
        return child.getRect();
      })
    });
  };

  __proto.request = function () {
    return {
      request: function () {
        return this;
      },
      requestEnd: function () {
        return this;
      }
    };
  };

  __proto.dragStart = function () {
    return this;
  };

  __proto.hitTest = function () {
    return 0;
  };

  __proto.isInside = function () {
    return false;
  };

  __proto.isDragging = function () {
    return false;
  };

  __proto.updateRenderPoses = function () {};

  __proto.checkUpdate = function () {};

  __proto.triggerEvent = function () {};

  __proto.updateAbles = function () {};

  __proto._updateEvents = function () {};

  __proto._updateObserver = function () {};

  return MoveableIndividualGroup;
}(MoveableManager);

var InitialMoveable =
/*#__PURE__*/
function (_super) {
  __extends(InitialMoveable, _super);

  function InitialMoveable() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.refTargets = [];
    _this.selectorMap = {};
    return _this;
  }

  var __proto = InitialMoveable.prototype;

  InitialMoveable.makeStyled = function () {
    var cssMap = {};
    var ables = this.getTotalAbles();
    ables.forEach(function (_a) {
      var css = _a.css;

      if (!css) {
        return;
      }

      css.forEach(function (text) {
        cssMap[text] = true;
      });
    });
    var style = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getKeys)(cssMap).join("\n");
    this.defaultStyled = (0,react_compat_css_styled__WEBPACK_IMPORTED_MODULE_10__["default"])("div", (0,framework_utils__WEBPACK_IMPORTED_MODULE_1__.prefixCSS)(PREFIX, MOVEABLE_CSS + style));
  };

  InitialMoveable.getTotalAbles = function () {
    return __spreadArray([Default, Groupable, IndividualGroupable, DragArea], this.defaultAbles);
  };

  __proto.render = function () {
    var moveableContructor = this.constructor;

    if (!moveableContructor.defaultStyled) {
      moveableContructor.makeStyled();
    }

    var _a = this.props,
        userAbles = _a.ables,
        userProps = _a.props,
        props = __rest(_a, ["ables", "props"]);

    var refTargets = this._updateRefs(true);

    var elementTargets = getElementTargets(refTargets, this.selectorMap);
    var isGroup = elementTargets.length > 1;
    var totalAbles = moveableContructor.getTotalAbles();

    var ables = __spreadArray(__spreadArray([], totalAbles), userAbles || []);

    var nextProps = __assign(__assign(__assign({}, props), userProps || {}), {
      ables: ables,
      cssStyled: moveableContructor.defaultStyled,
      customStyledMap: moveableContructor.customStyledMap
    });

    if (isGroup) {
      if (props.individualGroupable) {
        return (0,react_simple_compat__WEBPACK_IMPORTED_MODULE_9__.createElement)(MoveableIndividualGroup, __assign({
          key: "individual-group",
          ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_1__.ref)(this, "moveable")
        }, nextProps, {
          target: null,
          targets: elementTargets
        }));
      }

      return (0,react_simple_compat__WEBPACK_IMPORTED_MODULE_9__.createElement)(MoveableGroup, __assign({
        key: "group",
        ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_1__.ref)(this, "moveable")
      }, nextProps, {
        target: null,
        targets: elementTargets
      }));
    } else {
      return (0,react_simple_compat__WEBPACK_IMPORTED_MODULE_9__.createElement)(MoveableManager, __assign({
        key: "single",
        ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_1__.ref)(this, "moveable")
      }, nextProps, {
        target: elementTargets[0]
      }));
    }
  };

  __proto.componentDidMount = function () {
    this._updateRefs();
  };

  __proto.componentDidUpdate = function () {
    this._updateRefs();
  };

  __proto.getManager = function () {
    return this.moveable;
  };

  __proto._updateRefs = function (isRender) {
    var prevRefTargets = this.refTargets;
    var nextRefTargets = getRefTargets(this.props.target || this.props.targets);
    var isBrowser = typeof document !== "undefined";
    var isUpdate = prevRefTargets.length !== nextRefTargets.length || prevRefTargets.some(function (target, i) {
      var nextTarget = nextRefTargets[i];

      if (!target && !nextTarget) {
        return false;
      } else if (target !== nextTarget) {
        return true;
      }

      return false;
    });
    var selectorMap = this.selectorMap;
    var nextSelectorMap = {};
    this.refTargets.forEach(function (target) {
      if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.isString)(target)) {
        if (!selectorMap[target] && isBrowser) {
          isUpdate = true;
          nextSelectorMap[target] = [].slice.call(document.querySelectorAll(target));
        } else {
          nextSelectorMap[target] = selectorMap[target];
        }
      }
    });
    this.refTargets = nextRefTargets;
    this.selectorMap = nextSelectorMap;

    if (!isRender && isUpdate) {
      this.forceUpdate();
    }

    return nextRefTargets;
  };

  InitialMoveable.defaultAbles = [];
  InitialMoveable.customStyledMap = {};
  InitialMoveable.defaultStyled = null;

  __decorate([(0,framework_utils__WEBPACK_IMPORTED_MODULE_1__.withMethods)(MOVEABLE_METHODS)], InitialMoveable.prototype, "moveable", void 0);

  return InitialMoveable;
}(react_simple_compat__WEBPACK_IMPORTED_MODULE_9__.PureComponent);

var Moveable =
/*#__PURE__*/
function (_super) {
  __extends(Moveable, _super);

  function Moveable() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  Moveable.defaultAbles = MOVEABLE_ABLES;
  return Moveable;
}(InitialMoveable);

function makeMoveable(ables) {
  var _a;

  return _a =
  /*#__PURE__*/
  function (_super) {
    __extends(Moveable, _super);

    function Moveable() {
      return _super !== null && _super.apply(this, arguments) || this;
    }

    return Moveable;
  }(InitialMoveable), _a.defaultAbles = ables, _a;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Moveable);



/***/ }),

/***/ "./.yarn/__virtual__/react-resizable-virtual-13412137cd/0/cache/react-resizable-npm-3.0.4-aa39f9db2b-cbf86ad04b.zip/node_modules/react-resizable/build/Resizable.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



exports.__esModule = true;
exports["default"] = void 0;

var React = _interopRequireWildcard(__webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js"));

var _reactDraggable = __webpack_require__("./.yarn/__virtual__/react-draggable-virtual-eb201fa540/0/cache/react-draggable-npm-4.4.4-f0b7a5c546-b8258a5893.zip/node_modules/react-draggable/build/cjs/cjs.js");

var _utils = __webpack_require__("./.yarn/__virtual__/react-resizable-virtual-13412137cd/0/cache/react-resizable-npm-3.0.4-aa39f9db2b-cbf86ad04b.zip/node_modules/react-resizable/build/utils.js");

var _propTypes = __webpack_require__("./.yarn/__virtual__/react-resizable-virtual-13412137cd/0/cache/react-resizable-npm-3.0.4-aa39f9db2b-cbf86ad04b.zip/node_modules/react-resizable/build/propTypes.js");

var _excluded = ["children", "className", "draggableOpts", "width", "height", "handle", "handleSize", "lockAspectRatio", "axis", "minConstraints", "maxConstraints", "onResize", "onResizeStop", "onResizeStart", "resizeHandles", "transformScale"];

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

// The base <Resizable> component.
// This component does not have state and relies on the parent to set its props based on callback data.
var Resizable = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(Resizable, _React$Component);

  function Resizable() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.handleRefs = {};
    _this.lastHandleRect = null;
    _this.slack = null;
    return _this;
  }

  var _proto = Resizable.prototype;

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.resetData();
  };

  _proto.resetData = function resetData() {
    this.lastHandleRect = this.slack = null;
  } // Clamp width and height within provided constraints
  ;

  _proto.runConstraints = function runConstraints(width, height) {
    var _this$props = this.props,
        minConstraints = _this$props.minConstraints,
        maxConstraints = _this$props.maxConstraints,
        lockAspectRatio = _this$props.lockAspectRatio; // short circuit

    if (!minConstraints && !maxConstraints && !lockAspectRatio) return [width, height]; // If constraining to min and max, we need to also fit width and height to aspect ratio.

    if (lockAspectRatio) {
      var ratio = this.props.width / this.props.height;
      var deltaW = width - this.props.width;
      var deltaH = height - this.props.height; // Find which coordinate was greater and should push the other toward it.
      // E.g.:
      // ratio = 1, deltaW = 10, deltaH = 5, deltaH should become 10.
      // ratio = 2, deltaW = 10, deltaH = 6, deltaW should become 12.

      if (Math.abs(deltaW) > Math.abs(deltaH * ratio)) {
        height = width / ratio;
      } else {
        width = height * ratio;
      }
    }

    var oldW = width,
        oldH = height; // Add slack to the values used to calculate bound position. This will ensure that if
    // we start removing slack, the element won't react to it right away until it's been
    // completely removed.

    var _ref = this.slack || [0, 0],
        slackW = _ref[0],
        slackH = _ref[1];

    width += slackW;
    height += slackH;

    if (minConstraints) {
      width = Math.max(minConstraints[0], width);
      height = Math.max(minConstraints[1], height);
    }

    if (maxConstraints) {
      width = Math.min(maxConstraints[0], width);
      height = Math.min(maxConstraints[1], height);
    } // If the width or height changed, we must have introduced some slack. Record it for the next iteration.


    this.slack = [slackW + (oldW - width), slackH + (oldH - height)];
    return [width, height];
  }
  /**
   * Wrapper around drag events to provide more useful data.
   *
   * @param  {String} handlerName Handler name to wrap.
   * @return {Function}           Handler function.
   */
  ;

  _proto.resizeHandler = function resizeHandler(handlerName, axis) {
    var _this2 = this;

    return function (e, _ref2) {
      var node = _ref2.node,
          deltaX = _ref2.deltaX,
          deltaY = _ref2.deltaY;
      // Reset data in case it was left over somehow (should not be possible)
      if (handlerName === 'onResizeStart') _this2.resetData(); // Axis restrictions

      var canDragX = (_this2.props.axis === 'both' || _this2.props.axis === 'x') && axis !== 'n' && axis !== 's';
      var canDragY = (_this2.props.axis === 'both' || _this2.props.axis === 'y') && axis !== 'e' && axis !== 'w'; // No dragging possible.

      if (!canDragX && !canDragY) return; // Decompose axis for later use

      var axisV = axis[0];
      var axisH = axis[axis.length - 1]; // intentionally not axis[1], so that this catches axis === 'w' for example
      // Track the element being dragged to account for changes in position.
      // If a handle's position is changed between callbacks, we need to factor this in to the next callback.
      // Failure to do so will cause the element to "skip" when resized upwards or leftwards.

      var handleRect = node.getBoundingClientRect();

      if (_this2.lastHandleRect != null) {
        // If the handle has repositioned on either axis since last render,
        // we need to increase our callback values by this much.
        // Only checking 'n', 'w' since resizing by 's', 'w' won't affect the overall position on page,
        if (axisH === 'w') {
          var deltaLeftSinceLast = handleRect.left - _this2.lastHandleRect.left;
          deltaX += deltaLeftSinceLast;
        }

        if (axisV === 'n') {
          var deltaTopSinceLast = handleRect.top - _this2.lastHandleRect.top;
          deltaY += deltaTopSinceLast;
        }
      } // Storage of last rect so we know how much it has really moved.


      _this2.lastHandleRect = handleRect; // Reverse delta if using top or left drag handles.

      if (axisH === 'w') deltaX = -deltaX;
      if (axisV === 'n') deltaY = -deltaY; // Update w/h by the deltas. Also factor in transformScale.

      var width = _this2.props.width + (canDragX ? deltaX / _this2.props.transformScale : 0);
      var height = _this2.props.height + (canDragY ? deltaY / _this2.props.transformScale : 0); // Run user-provided constraints.

      var _this2$runConstraints = _this2.runConstraints(width, height);

      width = _this2$runConstraints[0];
      height = _this2$runConstraints[1];
      var dimensionsChanged = width !== _this2.props.width || height !== _this2.props.height; // Call user-supplied callback if present.

      var cb = typeof _this2.props[handlerName] === 'function' ? _this2.props[handlerName] : null; // Don't call 'onResize' if dimensions haven't changed.

      var shouldSkipCb = handlerName === 'onResize' && !dimensionsChanged;

      if (cb && !shouldSkipCb) {
        e.persist == null ? void 0 : e.persist();
        cb(e, {
          node: node,
          size: {
            width: width,
            height: height
          },
          handle: axis
        });
      } // Reset internal data


      if (handlerName === 'onResizeStop') _this2.resetData();
    };
  } // Render a resize handle given an axis & DOM ref. Ref *must* be attached for
  // the underlying draggable library to work properly.
  ;

  _proto.renderResizeHandle = function renderResizeHandle(handleAxis, ref) {
    var handle = this.props.handle; // No handle provided, make the default

    if (!handle) {
      return /*#__PURE__*/React.createElement("span", {
        className: "react-resizable-handle react-resizable-handle-" + handleAxis,
        ref: ref
      });
    } // Handle is a function, such as:
    // `handle={(handleAxis) => <span className={...} />}`


    if (typeof handle === 'function') {
      return handle(handleAxis, ref);
    } // Handle is a React component (composite or DOM).


    var isDOMElement = typeof handle.type === 'string';

    var props = _objectSpread({
      ref: ref
    }, isDOMElement ? {} : {
      handleAxis: handleAxis
    });

    return /*#__PURE__*/React.cloneElement(handle, props);
  };

  _proto.render = function render() {
    var _this3 = this;

    // Pass along only props not meant for the `<Resizable>`.`
    // eslint-disable-next-line no-unused-vars
    var _this$props2 = this.props,
        children = _this$props2.children,
        className = _this$props2.className,
        draggableOpts = _this$props2.draggableOpts,
        width = _this$props2.width,
        height = _this$props2.height,
        handle = _this$props2.handle,
        handleSize = _this$props2.handleSize,
        lockAspectRatio = _this$props2.lockAspectRatio,
        axis = _this$props2.axis,
        minConstraints = _this$props2.minConstraints,
        maxConstraints = _this$props2.maxConstraints,
        onResize = _this$props2.onResize,
        onResizeStop = _this$props2.onResizeStop,
        onResizeStart = _this$props2.onResizeStart,
        resizeHandles = _this$props2.resizeHandles,
        transformScale = _this$props2.transformScale,
        p = _objectWithoutPropertiesLoose(_this$props2, _excluded); // What we're doing here is getting the child of this element, and cloning it with this element's props.
    // We are then defining its children as:
    // 1. Its original children (resizable's child's children), and
    // 2. One or more draggable handles.


    return (0, _utils.cloneElement)(children, _objectSpread(_objectSpread({}, p), {}, {
      className: (className ? className + " " : '') + "react-resizable",
      children: [].concat(children.props.children, resizeHandles.map(function (handleAxis) {
        var _this3$handleRefs$han;

        // Create a ref to the handle so that `<DraggableCore>` doesn't have to use ReactDOM.findDOMNode().
        var ref = (_this3$handleRefs$han = _this3.handleRefs[handleAxis]) != null ? _this3$handleRefs$han : _this3.handleRefs[handleAxis] = /*#__PURE__*/React.createRef();
        return /*#__PURE__*/React.createElement(_reactDraggable.DraggableCore, _extends({}, draggableOpts, {
          nodeRef: ref,
          key: "resizableHandle-" + handleAxis,
          onStop: _this3.resizeHandler('onResizeStop', handleAxis),
          onStart: _this3.resizeHandler('onResizeStart', handleAxis),
          onDrag: _this3.resizeHandler('onResize', handleAxis)
        }), _this3.renderResizeHandle(handleAxis, ref));
      }))
    }));
  };

  return Resizable;
}(React.Component);

exports["default"] = Resizable;
Resizable.propTypes = _propTypes.resizableProps;
Resizable.defaultProps = {
  axis: 'both',
  handleSize: [20, 20],
  lockAspectRatio: false,
  minConstraints: [20, 20],
  maxConstraints: [Infinity, Infinity],
  resizeHandles: ['se'],
  transformScale: 1
};

/***/ }),

/***/ "./.yarn/__virtual__/react-resizable-virtual-13412137cd/0/cache/react-resizable-npm-3.0.4-aa39f9db2b-cbf86ad04b.zip/node_modules/react-resizable/build/ResizableBox.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



exports.__esModule = true;
exports["default"] = void 0;

var React = _interopRequireWildcard(__webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js"));

var _propTypes = _interopRequireDefault(__webpack_require__("./.yarn/cache/prop-types-npm-15.7.2-d7a04f2274-5eef82fdda.zip/node_modules/prop-types/index.js"));

var _Resizable = _interopRequireDefault(__webpack_require__("./.yarn/__virtual__/react-resizable-virtual-13412137cd/0/cache/react-resizable-npm-3.0.4-aa39f9db2b-cbf86ad04b.zip/node_modules/react-resizable/build/Resizable.js"));

var _propTypes2 = __webpack_require__("./.yarn/__virtual__/react-resizable-virtual-13412137cd/0/cache/react-resizable-npm-3.0.4-aa39f9db2b-cbf86ad04b.zip/node_modules/react-resizable/build/propTypes.js");

var _excluded = ["handle", "handleSize", "onResize", "onResizeStart", "onResizeStop", "draggableOpts", "minConstraints", "maxConstraints", "lockAspectRatio", "axis", "width", "height", "resizeHandles", "style", "transformScale"];

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var ResizableBox = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(ResizableBox, _React$Component);

  function ResizableBox() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.state = {
      width: _this.props.width,
      height: _this.props.height,
      propsWidth: _this.props.width,
      propsHeight: _this.props.height
    };

    _this.onResize = function (e, data) {
      var size = data.size;

      if (_this.props.onResize) {
        e.persist == null ? void 0 : e.persist();

        _this.setState(size, function () {
          return _this.props.onResize && _this.props.onResize(e, data);
        });
      } else {
        _this.setState(size);
      }
    };

    return _this;
  }

  ResizableBox.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {
    // If parent changes height/width, set that in our state.
    if (state.propsWidth !== props.width || state.propsHeight !== props.height) {
      return {
        width: props.width,
        height: props.height,
        propsWidth: props.width,
        propsHeight: props.height
      };
    }

    return null;
  };

  var _proto = ResizableBox.prototype;

  _proto.render = function render() {
    // Basic wrapper around a Resizable instance.
    // If you use Resizable directly, you are responsible for updating the child component
    // with a new width and height.
    var _this$props = this.props,
        handle = _this$props.handle,
        handleSize = _this$props.handleSize,
        onResize = _this$props.onResize,
        onResizeStart = _this$props.onResizeStart,
        onResizeStop = _this$props.onResizeStop,
        draggableOpts = _this$props.draggableOpts,
        minConstraints = _this$props.minConstraints,
        maxConstraints = _this$props.maxConstraints,
        lockAspectRatio = _this$props.lockAspectRatio,
        axis = _this$props.axis,
        width = _this$props.width,
        height = _this$props.height,
        resizeHandles = _this$props.resizeHandles,
        style = _this$props.style,
        transformScale = _this$props.transformScale,
        props = _objectWithoutPropertiesLoose(_this$props, _excluded);

    return /*#__PURE__*/React.createElement(_Resizable.default, {
      axis: axis,
      draggableOpts: draggableOpts,
      handle: handle,
      handleSize: handleSize,
      height: this.state.height,
      lockAspectRatio: lockAspectRatio,
      maxConstraints: maxConstraints,
      minConstraints: minConstraints,
      onResizeStart: onResizeStart,
      onResize: this.onResize,
      onResizeStop: onResizeStop,
      resizeHandles: resizeHandles,
      transformScale: transformScale,
      width: this.state.width
    }, /*#__PURE__*/React.createElement("div", _extends({}, props, {
      style: _objectSpread(_objectSpread({}, style), {}, {
        width: this.state.width + 'px',
        height: this.state.height + 'px'
      })
    })));
  };

  return ResizableBox;
}(React.Component);

exports["default"] = ResizableBox;
ResizableBox.propTypes = _objectSpread(_objectSpread({}, _propTypes2.resizableProps), {}, {
  children: _propTypes.default.element
});

/***/ }),

/***/ "./.yarn/__virtual__/react-resizable-virtual-13412137cd/0/cache/react-resizable-npm-3.0.4-aa39f9db2b-cbf86ad04b.zip/node_modules/react-resizable/build/propTypes.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



exports.__esModule = true;
exports.resizableProps = void 0;

var _propTypes = _interopRequireDefault(__webpack_require__("./.yarn/cache/prop-types-npm-15.7.2-d7a04f2274-5eef82fdda.zip/node_modules/prop-types/index.js"));

var _reactDraggable = __webpack_require__("./.yarn/__virtual__/react-draggable-virtual-eb201fa540/0/cache/react-draggable-npm-4.4.4-f0b7a5c546-b8258a5893.zip/node_modules/react-draggable/build/cjs/cjs.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var resizableProps = {
  /*
  * Restricts resizing to a particular axis (default: 'both')
  * 'both' - allows resizing by width or height
  * 'x' - only allows the width to be changed
  * 'y' - only allows the height to be changed
  * 'none' - disables resizing altogether
  * */
  axis: _propTypes.default.oneOf(['both', 'x', 'y', 'none']),
  className: _propTypes.default.string,

  /*
  * Require that one and only one child be present.
  * */
  children: _propTypes.default.element.isRequired,

  /*
  * These will be passed wholesale to react-draggable's DraggableCore
  * */
  draggableOpts: _propTypes.default.shape({
    allowAnyClick: _propTypes.default.bool,
    cancel: _propTypes.default.string,
    children: _propTypes.default.node,
    disabled: _propTypes.default.bool,
    enableUserSelectHack: _propTypes.default.bool,
    offsetParent: _propTypes.default.node,
    grid: _propTypes.default.arrayOf(_propTypes.default.number),
    handle: _propTypes.default.string,
    nodeRef: _propTypes.default.object,
    onStart: _propTypes.default.func,
    onDrag: _propTypes.default.func,
    onStop: _propTypes.default.func,
    onMouseDown: _propTypes.default.func,
    scale: _propTypes.default.number
  }),

  /*
  * Initial height
  * */
  height: _propTypes.default.number.isRequired,

  /*
  * Customize cursor resize handle
  * */
  handle: _propTypes.default.oneOfType([_propTypes.default.node, _propTypes.default.func]),

  /*
  * If you change this, be sure to update your css
  * */
  handleSize: _propTypes.default.arrayOf(_propTypes.default.number),
  lockAspectRatio: _propTypes.default.bool,

  /*
  * Max X & Y measure
  * */
  maxConstraints: _propTypes.default.arrayOf(_propTypes.default.number),

  /*
  * Min X & Y measure
  * */
  minConstraints: _propTypes.default.arrayOf(_propTypes.default.number),

  /*
  * Called on stop resize event
  * */
  onResizeStop: _propTypes.default.func,

  /*
  * Called on start resize event
  * */
  onResizeStart: _propTypes.default.func,

  /*
  * Called on resize event
  * */
  onResize: _propTypes.default.func,

  /*
  * Defines which resize handles should be rendered (default: 'se')
  * 's' - South handle (bottom-center)
  * 'w' - West handle (left-center)
  * 'e' - East handle (right-center)
  * 'n' - North handle (top-center)
  * 'sw' - Southwest handle (bottom-left)
  * 'nw' - Northwest handle (top-left)
  * 'se' - Southeast handle (bottom-right)
  * 'ne' - Northeast handle (top-center)
  * */
  resizeHandles: _propTypes.default.arrayOf(_propTypes.default.oneOf(['s', 'w', 'e', 'n', 'sw', 'nw', 'se', 'ne'])),

  /*
  * If `transform: scale(n)` is set on the parent, this should be set to `n`.
  * */
  transformScale: _propTypes.default.number,

  /*
   * Initial width
   */
  width: _propTypes.default.number.isRequired
};
exports.resizableProps = resizableProps;

/***/ }),

/***/ "./.yarn/__virtual__/react-resizable-virtual-13412137cd/0/cache/react-resizable-npm-3.0.4-aa39f9db2b-cbf86ad04b.zip/node_modules/react-resizable/build/utils.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



exports.__esModule = true;
exports.cloneElement = cloneElement;

var _react = _interopRequireDefault(__webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// React.addons.cloneWithProps look-alike that merges style & className.
function cloneElement(element, props) {
  if (props.style && element.props.style) {
    props.style = _objectSpread(_objectSpread({}, element.props.style), props.style);
  }

  if (props.className && element.props.className) {
    props.className = element.props.className + " " + props.className;
  }

  return /*#__PURE__*/_react.default.cloneElement(element, props);
}

/***/ }),

/***/ "./.yarn/__virtual__/react-resizable-virtual-13412137cd/0/cache/react-resizable-npm-3.0.4-aa39f9db2b-cbf86ad04b.zip/node_modules/react-resizable/index.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


module.exports = function() {
  throw new Error("Don't instantiate Resizable directly! Use require('react-resizable').Resizable");
};

module.exports.Resizable = __webpack_require__("./.yarn/__virtual__/react-resizable-virtual-13412137cd/0/cache/react-resizable-npm-3.0.4-aa39f9db2b-cbf86ad04b.zip/node_modules/react-resizable/build/Resizable.js")["default"];
module.exports.ResizableBox = __webpack_require__("./.yarn/__virtual__/react-resizable-virtual-13412137cd/0/cache/react-resizable-npm-3.0.4-aa39f9db2b-cbf86ad04b.zip/node_modules/react-resizable/build/ResizableBox.js")["default"];


/***/ }),

/***/ "./.yarn/__virtual__/react-use-virtual-00326e70ba/0/cache/react-use-npm-17.3.2-a032cbeb01-7379460f51.zip/node_modules/react-use/esm/useObservable.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _useIsomorphicLayoutEffect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/react-use-virtual-00326e70ba/0/cache/react-use-npm-17.3.2-a032cbeb01-7379460f51.zip/node_modules/react-use/esm/useIsomorphicLayoutEffect.js");


function useObservable(observable$, initialValue) {
    var _a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialValue), value = _a[0], update = _a[1];
    (0,_useIsomorphicLayoutEffect__WEBPACK_IMPORTED_MODULE_1__["default"])(function () {
        var s = observable$.subscribe(update);
        return function () { return s.unsubscribe(); };
    }, [observable$]);
    return value;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (useObservable);


/***/ }),

/***/ "./.yarn/cache/@daybrush-utils-npm-1.6.0-547486bf79-2579bc17e0.zip/node_modules/@daybrush/utils/dist/utils.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$": () => (/* binding */ $),
/* harmony export */   "ANIMATION": () => (/* binding */ ANIMATION),
/* harmony export */   "ARRAY": () => (/* binding */ ARRAY),
/* harmony export */   "COLOR_MODELS": () => (/* binding */ COLOR_MODELS),
/* harmony export */   "DEFAULT_UNIT_PRESETS": () => (/* binding */ DEFAULT_UNIT_PRESETS),
/* harmony export */   "FILTER": () => (/* binding */ FILTER),
/* harmony export */   "FUNCTION": () => (/* binding */ FUNCTION),
/* harmony export */   "HSL": () => (/* binding */ HSL),
/* harmony export */   "HSLA": () => (/* binding */ HSLA),
/* harmony export */   "IS_WINDOW": () => (/* binding */ IS_WINDOW),
/* harmony export */   "KEYFRAMES": () => (/* binding */ KEYFRAMES),
/* harmony export */   "NUMBER": () => (/* binding */ NUMBER),
/* harmony export */   "OBJECT": () => (/* binding */ OBJECT),
/* harmony export */   "OPEN_CLOSED_CHARACTERS": () => (/* binding */ OPEN_CLOSED_CHARACTERS),
/* harmony export */   "PROPERTY": () => (/* binding */ PROPERTY),
/* harmony export */   "RGB": () => (/* binding */ RGB),
/* harmony export */   "RGBA": () => (/* binding */ RGBA),
/* harmony export */   "STRING": () => (/* binding */ STRING),
/* harmony export */   "TINY_NUM": () => (/* binding */ TINY_NUM),
/* harmony export */   "TRANSFORM": () => (/* binding */ TRANSFORM),
/* harmony export */   "UNDEFINED": () => (/* binding */ UNDEFINED),
/* harmony export */   "addClass": () => (/* binding */ addClass),
/* harmony export */   "addEvent": () => (/* binding */ addEvent),
/* harmony export */   "average": () => (/* binding */ average),
/* harmony export */   "between": () => (/* binding */ between),
/* harmony export */   "calculateBoundSize": () => (/* binding */ calculateBoundSize),
/* harmony export */   "camelize": () => (/* binding */ camelize),
/* harmony export */   "cancelAnimationFrame": () => (/* binding */ cancelAnimationFrame),
/* harmony export */   "checkBoundSize": () => (/* binding */ checkBoundSize),
/* harmony export */   "convertUnitSize": () => (/* binding */ convertUnitSize),
/* harmony export */   "counter": () => (/* binding */ counter),
/* harmony export */   "cutHex": () => (/* binding */ cutHex),
/* harmony export */   "decamelize": () => (/* binding */ decamelize),
/* harmony export */   "document": () => (/* binding */ doc),
/* harmony export */   "dot": () => (/* binding */ dot),
/* harmony export */   "find": () => (/* binding */ find),
/* harmony export */   "findIndex": () => (/* binding */ findIndex),
/* harmony export */   "findLast": () => (/* binding */ findLast),
/* harmony export */   "findLastIndex": () => (/* binding */ findLastIndex),
/* harmony export */   "fromCSS": () => (/* binding */ fromCSS),
/* harmony export */   "getCenterPoint": () => (/* binding */ getCenterPoint),
/* harmony export */   "getCrossBrowserProperty": () => (/* binding */ getCrossBrowserProperty),
/* harmony export */   "getDist": () => (/* binding */ getDist),
/* harmony export */   "getKeys": () => (/* binding */ getKeys),
/* harmony export */   "getRad": () => (/* binding */ getRad),
/* harmony export */   "getShapeDirection": () => (/* binding */ getShapeDirection),
/* harmony export */   "hasClass": () => (/* binding */ hasClass),
/* harmony export */   "hexToRGBA": () => (/* binding */ hexToRGBA),
/* harmony export */   "hslToRGBA": () => (/* binding */ hslToRGBA),
/* harmony export */   "isArray": () => (/* binding */ isArray),
/* harmony export */   "isFunction": () => (/* binding */ isFunction),
/* harmony export */   "isNumber": () => (/* binding */ isNumber),
/* harmony export */   "isObject": () => (/* binding */ isObject),
/* harmony export */   "isString": () => (/* binding */ isString),
/* harmony export */   "isUndefined": () => (/* binding */ isUndefined),
/* harmony export */   "now": () => (/* binding */ now),
/* harmony export */   "removeClass": () => (/* binding */ removeClass),
/* harmony export */   "removeEvent": () => (/* binding */ removeEvent),
/* harmony export */   "replaceOnce": () => (/* binding */ replaceOnce),
/* harmony export */   "requestAnimationFrame": () => (/* binding */ requestAnimationFrame),
/* harmony export */   "sortOrders": () => (/* binding */ sortOrders),
/* harmony export */   "splitBracket": () => (/* binding */ splitBracket),
/* harmony export */   "splitComma": () => (/* binding */ splitComma),
/* harmony export */   "splitSpace": () => (/* binding */ splitSpace),
/* harmony export */   "splitText": () => (/* binding */ splitText),
/* harmony export */   "splitUnit": () => (/* binding */ splitUnit),
/* harmony export */   "stringToRGBA": () => (/* binding */ stringToRGBA),
/* harmony export */   "sum": () => (/* binding */ sum),
/* harmony export */   "throttle": () => (/* binding */ throttle),
/* harmony export */   "throttleArray": () => (/* binding */ throttleArray),
/* harmony export */   "toArray": () => (/* binding */ toArray),
/* harmony export */   "toFullHex": () => (/* binding */ toFullHex)
/* harmony export */ });
/*
Copyright (c) 2018 Daybrush
@name: @daybrush/utils
license: MIT
author: Daybrush
repository: https://github.com/daybrush/utils
@version 1.6.0
*/
/**
* @namespace
* @name Consts
*/

/**
* get string "rgb"
* @memberof Color
* @example
import {RGB} from "@daybrush/utils";

console.log(RGB); // "rgb"
*/
var RGB = "rgb";
/**
* get string "rgba"
* @memberof Color
* @example
import {RGBA} from "@daybrush/utils";

console.log(RGBA); // "rgba"
*/

var RGBA = "rgba";
/**
* get string "hsl"
* @memberof Color
* @example
import {HSL} from "@daybrush/utils";

console.log(HSL); // "hsl"
*/

var HSL = "hsl";
/**
* get string "hsla"
* @memberof Color
* @example
import {HSLA} from "@daybrush/utils";

console.log(HSLA); // "hsla"
*/

var HSLA = "hsla";
/**
* gets an array of color models.
* @memberof Color
* @example
import {COLOR_MODELS} from "@daybrush/utils";

console.log(COLOR_MODELS); // ["rgb", "rgba", "hsl", "hsla"];
*/

var COLOR_MODELS = [RGB, RGBA, HSL, HSLA];
/**
* get string "function"
* @memberof Consts
* @example
import {FUNCTION} from "@daybrush/utils";

console.log(FUNCTION); // "function"
*/

var FUNCTION = "function";
/**
* get string "property"
* @memberof Consts
* @example
import {PROPERTY} from "@daybrush/utils";

console.log(PROPERTY); // "property"
*/

var PROPERTY = "property";
/**
* get string "array"
* @memberof Consts
* @example
import {ARRAY} from "@daybrush/utils";

console.log(ARRAY); // "array"
*/

var ARRAY = "array";
/**
* get string "object"
* @memberof Consts
* @example
import {OBJECT} from "@daybrush/utils";

console.log(OBJECT); // "object"
*/

var OBJECT = "object";
/**
* get string "string"
* @memberof Consts
* @example
import {STRING} from "@daybrush/utils";

console.log(STRING); // "string"
*/

var STRING = "string";
/**
* get string "number"
* @memberof Consts
* @example
import {NUMBER} from "@daybrush/utils";

console.log(NUMBER); // "number"
*/

var NUMBER = "number";
/**
* get string "undefined"
* @memberof Consts
* @example
import {UNDEFINED} from "@daybrush/utils";

console.log(UNDEFINED); // "undefined"
*/

var UNDEFINED = "undefined";
/**
* Check whether the environment is window or node.js.
* @memberof Consts
* @example
import {IS_WINDOW} from "@daybrush/utils";

console.log(IS_WINDOW); // false in node.js
console.log(IS_WINDOW); // true in browser
*/

var IS_WINDOW = typeof window !== UNDEFINED;
/**
* Check whether the environment is window or node.js.
* @memberof Consts
* @name document
* @example
import {IS_WINDOW} from "@daybrush/utils";

console.log(IS_WINDOW); // false in node.js
console.log(IS_WINDOW); // true in browser
*/

var doc = typeof document !== UNDEFINED && document; // FIXME: this type maybe false
var prefixes = ["webkit", "ms", "moz", "o"];
/**
 * @namespace CrossBrowser
 */

/**
* Get a CSS property with a vendor prefix that supports cross browser.
* @function
* @param {string} property - A CSS property
* @return {string} CSS property with cross-browser vendor prefix
* @memberof CrossBrowser
* @example
import {getCrossBrowserProperty} from "@daybrush/utils";

console.log(getCrossBrowserProperty("transform")); // "transform", "-ms-transform", "-webkit-transform"
console.log(getCrossBrowserProperty("filter")); // "filter", "-webkit-filter"
*/

var getCrossBrowserProperty = /*#__PURE__*/function (property) {
  if (!doc) {
    return "";
  }

  var styles = (doc.body || doc.documentElement).style;
  var length = prefixes.length;

  if (typeof styles[property] !== UNDEFINED) {
    return property;
  }

  for (var i = 0; i < length; ++i) {
    var name = "-" + prefixes[i] + "-" + property;

    if (typeof styles[name] !== UNDEFINED) {
      return name;
    }
  }

  return "";
};
/**
* get string "transfrom" with the vendor prefix.
* @memberof CrossBrowser
* @example
import {TRANSFORM} from "@daybrush/utils";

console.log(TRANSFORM); // "transform", "-ms-transform", "-webkit-transform"
*/

var TRANSFORM = /*#__PURE__*/getCrossBrowserProperty("transform");
/**
* get string "filter" with the vendor prefix.
* @memberof CrossBrowser
* @example
import {FILTER} from "@daybrush/utils";

console.log(FILTER); // "filter", "-ms-filter", "-webkit-filter"
*/

var FILTER = /*#__PURE__*/getCrossBrowserProperty("filter");
/**
* get string "animation" with the vendor prefix.
* @memberof CrossBrowser
* @example
import {ANIMATION} from "@daybrush/utils";

console.log(ANIMATION); // "animation", "-ms-animation", "-webkit-animation"
*/

var ANIMATION = /*#__PURE__*/getCrossBrowserProperty("animation");
/**
* get string "keyframes" with the vendor prefix.
* @memberof CrossBrowser
* @example
import {KEYFRAMES} from "@daybrush/utils";

console.log(KEYFRAMES); // "keyframes", "-ms-keyframes", "-webkit-keyframes"
*/

var KEYFRAMES = /*#__PURE__*/ANIMATION.replace("animation", "keyframes");
var OPEN_CLOSED_CHARACTERS = [{
  open: "(",
  close: ")"
}, {
  open: "\"",
  close: "\""
}, {
  open: "'",
  close: "'"
}, {
  open: "\\\"",
  close: "\\\""
}, {
  open: "\\'",
  close: "\\'"
}];
var TINY_NUM = 0.0000001;
var DEFAULT_UNIT_PRESETS = {
  "cm": function (pos) {
    return pos * 96 / 2.54;
  },
  "mm": function (pos) {
    return pos * 96 / 254;
  },
  "in": function (pos) {
    return pos * 96;
  },
  "pt": function (pos) {
    return pos * 96 / 72;
  },
  "pc": function (pos) {
    return pos * 96 / 6;
  },
  "%": function (pos, size) {
    return pos * size / 100;
  },
  "vw": function (pos, size) {
    if (size === void 0) {
      size = window.innerWidth;
    }

    return pos / 100 * size;
  },
  "vh": function (pos, size) {
    if (size === void 0) {
      size = window.innerHeight;
    }

    return pos / 100 * size;
  },
  "vmax": function (pos, size) {
    if (size === void 0) {
      size = Math.max(window.innerWidth, window.innerHeight);
    }

    return pos / 100 * size;
  },
  "vmin": function (pos, size) {
    if (size === void 0) {
      size = Math.min(window.innerWidth, window.innerHeight);
    }

    return pos / 100 * size;
  }
};

/**
* @namespace
* @name Utils
*/

/**
 * Returns the inner product of two numbers(`a1`, `a2`) by two criteria(`b1`, `b2`).
 * @memberof Utils
 * @param - The first number
 * @param - The second number
 * @param - The first number to base on the inner product
 * @param - The second number to base on the inner product
 * @return - Returns the inner product
import { dot } from "@daybrush/utils";

console.log(dot(0, 15, 2, 3)); // 6
console.log(dot(5, 15, 2, 3)); // 9
console.log(dot(5, 15, 1, 1)); // 10
 */

function dot(a1, a2, b1, b2) {
  return (a1 * b2 + a2 * b1) / (b1 + b2);
}
/**
* Check the type that the value is undefined.
* @memberof Utils
* @param {string} value - Value to check the type
* @return {boolean} true if the type is correct, false otherwise
* @example
import {isUndefined} from "@daybrush/utils";

console.log(isUndefined(undefined)); // true
console.log(isUndefined("")); // false
console.log(isUndefined(1)); // false
console.log(isUndefined(null)); // false
*/

function isUndefined(value) {
  return typeof value === UNDEFINED;
}
/**
* Check the type that the value is object.
* @memberof Utils
* @param {string} value - Value to check the type
* @return {} true if the type is correct, false otherwise
* @example
import {isObject} from "@daybrush/utils";

console.log(isObject({})); // true
console.log(isObject(undefined)); // false
console.log(isObject("")); // false
console.log(isObject(null)); // false
*/

function isObject(value) {
  return value && typeof value === OBJECT;
}
/**
* Check the type that the value is isArray.
* @memberof Utils
* @param {string} value - Value to check the type
* @return {} true if the type is correct, false otherwise
* @example
import {isArray} from "@daybrush/utils";

console.log(isArray([])); // true
console.log(isArray({})); // false
console.log(isArray(undefined)); // false
console.log(isArray(null)); // false
*/

function isArray(value) {
  return Array.isArray(value);
}
/**
* Check the type that the value is string.
* @memberof Utils
* @param {string} value - Value to check the type
* @return {} true if the type is correct, false otherwise
* @example
import {isString} from "@daybrush/utils";

console.log(isString("1234")); // true
console.log(isString(undefined)); // false
console.log(isString(1)); // false
console.log(isString(null)); // false
*/

function isString(value) {
  return typeof value === STRING;
}
function isNumber(value) {
  return typeof value === NUMBER;
}
/**
* Check the type that the value is function.
* @memberof Utils
* @param {string} value - Value to check the type
* @return {} true if the type is correct, false otherwise
* @example
import {isFunction} from "@daybrush/utils";

console.log(isFunction(function a() {})); // true
console.log(isFunction(() => {})); // true
console.log(isFunction("1234")); // false
console.log(isFunction(1)); // false
console.log(isFunction(null)); // false
*/

function isFunction(value) {
  return typeof value === FUNCTION;
}

function isEqualSeparator(character, separator) {
  var isCharacterSpace = character === "" || character == " ";
  var isSeparatorSpace = separator === "" || separator == " ";
  return isSeparatorSpace && isCharacterSpace || character === separator;
}

function findOpen(openCharacter, texts, index, length, openCloseCharacters) {
  var isIgnore = findIgnore(openCharacter, texts, index);

  if (!isIgnore) {
    return findClose(openCharacter, texts, index + 1, length, openCloseCharacters);
  }

  return index;
}

function findIgnore(character, texts, index) {
  if (!character.ignore) {
    return null;
  }

  var otherText = texts.slice(Math.max(index - 3, 0), index + 3).join("");
  return new RegExp(character.ignore).exec(otherText);
}

function findClose(closeCharacter, texts, index, length, openCloseCharacters) {
  var _loop_1 = function (i) {
    var character = texts[i].trim();

    if (character === closeCharacter.close && !findIgnore(closeCharacter, texts, i)) {
      return {
        value: i
      };
    }

    var nextIndex = i; // re open

    var openCharacter = find(openCloseCharacters, function (_a) {
      var open = _a.open;
      return open === character;
    });

    if (openCharacter) {
      nextIndex = findOpen(openCharacter, texts, i, length, openCloseCharacters);
    }

    if (nextIndex === -1) {
      return out_i_1 = i, "break";
    }

    i = nextIndex;
    out_i_1 = i;
  };

  var out_i_1;

  for (var i = index; i < length; ++i) {
    var state_1 = _loop_1(i);

    i = out_i_1;
    if (typeof state_1 === "object") return state_1.value;
    if (state_1 === "break") break;
  }

  return -1;
}

function splitText(text, splitOptions) {
  var _a = isString(splitOptions) ? {
    separator: splitOptions
  } : splitOptions,
      _b = _a.separator,
      separator = _b === void 0 ? "," : _b,
      isSeparateFirst = _a.isSeparateFirst,
      isSeparateOnlyOpenClose = _a.isSeparateOnlyOpenClose,
      _c = _a.isSeparateOpenClose,
      isSeparateOpenClose = _c === void 0 ? isSeparateOnlyOpenClose : _c,
      _d = _a.openCloseCharacters,
      openCloseCharacters = _d === void 0 ? OPEN_CLOSED_CHARACTERS : _d;

  var openClosedText = openCloseCharacters.map(function (_a) {
    var open = _a.open,
        close = _a.close;

    if (open === close) {
      return open;
    }

    return open + "|" + close;
  }).join("|");
  var regexText = "(\\s*" + separator + "\\s*|" + openClosedText + "|\\s+)";
  var regex = new RegExp(regexText, "g");
  var texts = text.split(regex).filter(Boolean);
  var length = texts.length;
  var values = [];
  var tempValues = [];

  function resetTemp() {
    if (tempValues.length) {
      values.push(tempValues.join(""));
      tempValues = [];
      return true;
    }

    return false;
  }

  var _loop_2 = function (i) {
    var character = texts[i].trim();
    var nextIndex = i;
    var openCharacter = find(openCloseCharacters, function (_a) {
      var open = _a.open;
      return open === character;
    });
    var closeCharacter = find(openCloseCharacters, function (_a) {
      var close = _a.close;
      return close === character;
    });

    if (openCharacter) {
      nextIndex = findOpen(openCharacter, texts, i, length, openCloseCharacters);

      if (nextIndex !== -1 && isSeparateOpenClose) {
        if (resetTemp() && isSeparateFirst) {
          return out_i_2 = i, "break";
        }

        values.push(texts.slice(i, nextIndex + 1).join(""));
        i = nextIndex;

        if (isSeparateFirst) {
          return out_i_2 = i, "break";
        }

        return out_i_2 = i, "continue";
      }
    } else if (closeCharacter && !findIgnore(closeCharacter, texts, i)) {
      throw new Error("invalid format: " + closeCharacter.close);
    } else if (isEqualSeparator(character, separator) && !isSeparateOnlyOpenClose) {
      resetTemp();

      if (isSeparateFirst) {
        return out_i_2 = i, "break";
      }

      return out_i_2 = i, "continue";
    }

    if (nextIndex === -1) {
      nextIndex = length - 1;
    }

    tempValues.push(texts.slice(i, nextIndex + 1).join(""));
    i = nextIndex;
    out_i_2 = i;
  };

  var out_i_2;

  for (var i = 0; i < length; ++i) {
    var state_2 = _loop_2(i);

    i = out_i_2;
    if (state_2 === "break") break;
  }

  if (tempValues.length) {
    values.push(tempValues.join(""));
  }

  return values;
}
/**
* divide text by space.
* @memberof Utils
* @param {string} text - text to divide
* @return {Array} divided texts
* @example
import {spliceSpace} from "@daybrush/utils";

console.log(splitSpace("a b c d e f g"));
// ["a", "b", "c", "d", "e", "f", "g"]
console.log(splitSpace("'a,b' c 'd,e' f g"));
// ["'a,b'", "c", "'d,e'", "f", "g"]
*/

function splitSpace(text) {
  // divide comma(space)
  return splitText(text, "");
}
/**
* divide text by comma.
* @memberof Utils
* @param {string} text - text to divide
* @return {Array} divided texts
* @example
import {splitComma} from "@daybrush/utils";

console.log(splitComma("a,b,c,d,e,f,g"));
// ["a", "b", "c", "d", "e", "f", "g"]
console.log(splitComma("'a,b',c,'d,e',f,g"));
// ["'a,b'", "c", "'d,e'", "f", "g"]
*/

function splitComma(text) {
  // divide comma(,)
  // "[^"]*"|'[^']*'
  return splitText(text, ",");
}
/**
* divide text by bracket "(", ")".
* @memberof Utils
* @param {string} text - text to divide
* @return {object} divided texts
* @example
import {splitBracket} from "@daybrush/utils";

console.log(splitBracket("a(1, 2)"));
// {prefix: "a", value: "1, 2", suffix: ""}
console.log(splitBracket("a(1, 2)b"));
// {prefix: "a", value: "1, 2", suffix: "b"}
*/

function splitBracket(text) {
  var matches = /([^(]*)\(([\s\S]*)\)([\s\S]*)/g.exec(text);

  if (!matches || matches.length < 4) {
    return {};
  } else {
    return {
      prefix: matches[1],
      value: matches[2],
      suffix: matches[3]
    };
  }
}
/**
* divide text by number and unit.
* @memberof Utils
* @param {string} text - text to divide
* @return {} divided texts
* @example
import {splitUnit} from "@daybrush/utils";

console.log(splitUnit("10px"));
// {prefix: "", value: 10, unit: "px"}
console.log(splitUnit("-10px"));
// {prefix: "", value: -10, unit: "px"}
console.log(splitUnit("a10%"));
// {prefix: "a", value: 10, unit: "%"}
*/

function splitUnit(text) {
  var matches = /^([^\d|e|\-|\+]*)((?:\d|\.|-|e-|e\+)+)(\S*)$/g.exec(text);

  if (!matches) {
    return {
      prefix: "",
      unit: "",
      value: NaN
    };
  }

  var prefix = matches[1];
  var value = matches[2];
  var unit = matches[3];
  return {
    prefix: prefix,
    unit: unit,
    value: parseFloat(value)
  };
}
/**
* transform strings to camel-case
* @memberof Utils
* @param {String} text - string
* @return {String} camel-case string
* @example
import {camelize} from "@daybrush/utils";

console.log(camelize("transform-origin")); // transformOrigin
console.log(camelize("abcd_efg")); // abcdEfg
console.log(camelize("abcd efg")); // abcdEfg
*/

function camelize(str) {
  return str.replace(/[\s-_]([a-z])/g, function (all, letter) {
    return letter.toUpperCase();
  });
}
/**
* transform a camelized string into a lowercased string.
* @memberof Utils
* @param {string} text - a camel-cased string
* @param {string} [separator="-"] - a separator
* @return {string}  a lowercased string
* @example
import {decamelize} from "@daybrush/utils";

console.log(decamelize("transformOrigin")); // transform-origin
console.log(decamelize("abcdEfg", "_")); // abcd_efg
*/

function decamelize(str, separator) {
  if (separator === void 0) {
    separator = "-";
  }

  return str.replace(/([a-z])([A-Z])/g, function (all, letter, letter2) {
    return "" + letter + separator + letter2.toLowerCase();
  });
}
/**
* transforms something in an array into an array.
* @memberof Utils
* @param - Array form
* @return an array
* @example
import {toArray} from "@daybrush/utils";

const arr1 = toArray(document.querySelectorAll(".a")); // Element[]
const arr2 = toArray(document.querySelectorAll<HTMLElement>(".a")); // HTMLElement[]
*/

function toArray(value) {
  return [].slice.call(value);
}
/**
* Date.now() method
* @memberof CrossBrowser
* @return {number} milliseconds
* @example
import {now} from "@daybrush/utils";

console.log(now()); // 12121324241(milliseconds)
*/

function now() {
  return Date.now ? Date.now() : new Date().getTime();
}
/**
* Returns the index of the first element in the array that satisfies the provided testing function.
* @function
* @memberof CrossBrowser
* @param - The array `findIndex` was called upon.
* @param - A function to execute on each value in the array until the function returns true, indicating that the satisfying element was found.
* @param - Returns defaultIndex if not found by the function.
* @example
import { findIndex } from "@daybrush/utils";

findIndex([{a: 1}, {a: 2}, {a: 3}, {a: 4}], ({ a }) => a === 2); // 1
*/

function findIndex(arr, callback, defaultIndex) {
  if (defaultIndex === void 0) {
    defaultIndex = -1;
  }

  var length = arr.length;

  for (var i = 0; i < length; ++i) {
    if (callback(arr[i], i, arr)) {
      return i;
    }
  }

  return defaultIndex;
}
/**
* Returns the reverse direction index of the first element in the array that satisfies the provided testing function.
* @function
* @memberof CrossBrowser
* @param - The array `findLastIndex` was called upon.
* @param - A function to execute on each value in the array until the function returns true, indicating that the satisfying element was found.
* @param - Returns defaultIndex if not found by the function.
* @example
import { findLastIndex } from "@daybrush/utils";

findLastIndex([{a: 1}, {a: 2}, {a: 3}, {a: 4}], ({ a }) => a === 2); // 1
*/

function findLastIndex(arr, callback, defaultIndex) {
  if (defaultIndex === void 0) {
    defaultIndex = -1;
  }

  var length = arr.length;

  for (var i = length - 1; i >= 0; --i) {
    if (callback(arr[i], i, arr)) {
      return i;
    }
  }

  return defaultIndex;
}
/**
* Returns the value of the reverse direction element in the array that satisfies the provided testing function.
* @function
* @memberof CrossBrowser
* @param - The array `findLast` was called upon.
* @param - A function to execute on each value in the array,
* @param - Returns defalutValue if not found by the function.
* @example
import { find } from "@daybrush/utils";

find([{a: 1}, {a: 2}, {a: 3}, {a: 4}], ({ a }) => a === 2); // {a: 2}
*/

function findLast(arr, callback, defalutValue) {
  var index = findLastIndex(arr, callback);
  return index > -1 ? arr[index] : defalutValue;
}
/**
* Returns the value of the first element in the array that satisfies the provided testing function.
* @function
* @memberof CrossBrowser
* @param - The array `find` was called upon.
* @param - A function to execute on each value in the array,
* @param - Returns defalutValue if not found by the function.
* @example
import { find } from "@daybrush/utils";

find([{a: 1}, {a: 2}, {a: 3}, {a: 4}], ({ a }) => a === 2); // {a: 2}
*/

function find(arr, callback, defalutValue) {
  var index = findIndex(arr, callback);
  return index > -1 ? arr[index] : defalutValue;
}
/**
* window.requestAnimationFrame() method with cross browser.
* @function
* @memberof CrossBrowser
* @param {FrameRequestCallback} callback - The function to call when it's time to update your animation for the next repaint.
* @return {number} id
* @example
import {requestAnimationFrame} from "@daybrush/utils";

requestAnimationFrame((timestamp) => {
  console.log(timestamp);
});
*/

var requestAnimationFrame = /*#__PURE__*/function () {
  var firstTime = now();
  var raf = IS_WINDOW && (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame);
  return raf ? raf.bind(window) : function (callback) {
    var currTime = now();
    var id = window.setTimeout(function () {
      callback(currTime - firstTime);
    }, 1000 / 60);
    return id;
  };
}();
/**
* window.cancelAnimationFrame() method with cross browser.
* @function
* @memberof CrossBrowser
* @param {number} handle - the id obtained through requestAnimationFrame method
* @return {void}
* @example
import { requestAnimationFrame, cancelAnimationFrame } from "@daybrush/utils";

const id = requestAnimationFrame((timestamp) => {
  console.log(timestamp);
});

cancelAnimationFrame(id);
*/

var cancelAnimationFrame = /*#__PURE__*/function () {
  var caf = IS_WINDOW && (window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame);
  return caf ? caf.bind(window) : function (handle) {
    clearTimeout(handle);
  };
}();
/**
* @function
* @memberof Utils
*/

function getKeys(obj) {
  if (Object.keys) {
    return Object.keys(obj);
  }

  var keys = [];

  for (var name in keys) {
    keys.push(name);
  }

  return keys;
}
/**
* @function
* @memberof Utils
*/

function sortOrders(keys, orders) {
  if (orders === void 0) {
    orders = [];
  }

  keys.sort(function (a, b) {
    var index1 = orders.indexOf(a);
    var index2 = orders.indexOf(b);

    if (index2 === -1 && index1 === -1) {
      return 0;
    }

    if (index1 === -1) {
      return 1;
    }

    if (index2 === -1) {
      return -1;
    }

    return index1 - index2;
  });
}
/**
* convert unit size to px size
* @function
* @memberof Utils
*/

function convertUnitSize(pos, size) {
  var _a = splitUnit(pos),
      value = _a.value,
      unit = _a.unit;

  if (isObject(size)) {
    var sizeFunction = size[unit];

    if (sizeFunction) {
      if (isFunction(sizeFunction)) {
        return sizeFunction(value);
      } else if (DEFAULT_UNIT_PRESETS[unit]) {
        return DEFAULT_UNIT_PRESETS[unit](value, sizeFunction);
      }
    }
  } else if (unit === "%") {
    return value * size / 100;
  }

  if (DEFAULT_UNIT_PRESETS[unit]) {
    return DEFAULT_UNIT_PRESETS[unit](value);
  }

  return value;
}
/**
* calculate between min, max
* @function
* @memberof Utils
*/

function between(value, min, max) {
  return Math.max(min, Math.min(value, max));
}
function checkBoundSize(targetSize, compareSize, isMax) {
  return [[throttle(compareSize[0], TINY_NUM), throttle(compareSize[0] * targetSize[1] / targetSize[0], TINY_NUM)], [throttle(compareSize[1] * targetSize[0] / targetSize[1], TINY_NUM), throttle(compareSize[1], TINY_NUM)]].filter(function (size) {
    return size.every(function (value, i) {
      return isMax ? value <= compareSize[i] : value >= compareSize[i];
    });
  })[0] || targetSize;
}
/**
* calculate bound size
* @function
* @memberof Utils
*/

function calculateBoundSize(size, minSize, maxSize, keepRatio) {
  if (!keepRatio) {
    return size.map(function (value, i) {
      return between(value, minSize[i], maxSize[i]);
    });
  }

  var width = size[0],
      height = size[1]; // width : height = minWidth : minHeight;

  var _a = checkBoundSize(size, minSize, false),
      minWidth = _a[0],
      minHeight = _a[1];

  var _b = checkBoundSize(size, maxSize, true),
      maxWidth = _b[0],
      maxHeight = _b[1];

  if (width < minWidth || height < minHeight) {
    width = minWidth;
    height = minHeight;
  } else if (width > maxWidth || height > maxHeight) {
    width = maxWidth;
    height = maxHeight;
  }

  return [width, height];
}
/**
* Add all the numbers.
* @function
* @memberof Utils
*/

function sum(nums) {
  var length = nums.length;
  var total = 0;

  for (var i = length - 1; i >= 0; --i) {
    total += nums[i];
  }

  return total;
}
/**
* Average all numbers.
* @function
* @memberof Utils
*/

function average(nums) {
  var length = nums.length;
  var total = 0;

  for (var i = length - 1; i >= 0; --i) {
    total += nums[i];
  }

  return length ? total / length : 0;
}
/**
* Get the angle of two points. (0 <= rad < 359)
* @function
* @memberof Utils
*/

function getRad(pos1, pos2) {
  var distX = pos2[0] - pos1[0];
  var distY = pos2[1] - pos1[1];
  var rad = Math.atan2(distY, distX);
  return rad >= 0 ? rad : rad + Math.PI * 2;
}
/**
* Get the average point of all points.
* @function
* @memberof Utils
*/

function getCenterPoint(points) {
  return [0, 1].map(function (i) {
    return average(points.map(function (pos) {
      return pos[i];
    }));
  });
}
/**
* Gets the direction of the shape.
* @function
* @memberof Utils
*/

function getShapeDirection(points) {
  var center = getCenterPoint(points);
  var pos1Rad = getRad(center, points[0]);
  var pos2Rad = getRad(center, points[1]);
  return pos1Rad < pos2Rad && pos2Rad - pos1Rad < Math.PI || pos1Rad > pos2Rad && pos2Rad - pos1Rad < -Math.PI ? 1 : -1;
}
/**
* Get the distance between two points.
* @function
* @memberof Utils
*/

function getDist(a, b) {
  return Math.sqrt(Math.pow((b ? b[0] : 0) - a[0], 2) + Math.pow((b ? b[1] : 0) - a[1], 2));
}
/**
* throttle number depending on the unit.
* @function
* @memberof Utils
*/

function throttle(num, unit) {
  if (!unit) {
    return num;
  }

  return Math.round(num / unit) * unit;
}
/**
* throttle number array depending on the unit.
* @function
* @memberof Utils
*/

function throttleArray(nums, unit) {
  nums.forEach(function (_, i) {
    nums[i] = throttle(nums[i], unit);
  });
  return nums;
}
/**
* @function
* @memberof Utils
*/

function counter(num) {
  var nums = [];

  for (var i = 0; i < num; ++i) {
    nums.push(i);
  }

  return nums;
}
/**
* @function
* @memberof Utils
*/

function replaceOnce(text, fromText, toText) {
  var isOnce = false;
  return text.replace(fromText, function () {
    var args = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }

    if (isOnce) {
      return args[0];
    }

    isOnce = true;
    return isString(toText) ? toText : toText.apply(void 0, args);
  });
}

/**
* @namespace
* @name Color
*/

/**
* Remove the # from the hex color.
* @memberof Color
* @param {} hex - hex color
* @return {} hex color
* @example
import {cutHex} from "@daybrush/utils";

console.log(cutHex("#000000")) // "000000"
*/

function cutHex(hex) {
  return hex.replace("#", "");
}
/**
* convert hex color to rgb color.
* @memberof Color
* @param {} hex - hex color
* @return {} rgb color
* @example
import {hexToRGBA} from "@daybrush/utils";

console.log(hexToRGBA("#00000005"));
// [0, 0, 0, 1]
console.log(hexToRGBA("#201045"));
// [32, 16, 69, 1]
*/

function hexToRGBA(hex) {
  var h = cutHex(hex);
  var r = parseInt(h.substring(0, 2), 16);
  var g = parseInt(h.substring(2, 4), 16);
  var b = parseInt(h.substring(4, 6), 16);
  var a = parseInt(h.substring(6, 8), 16) / 255;

  if (isNaN(a)) {
    a = 1;
  }

  return [r, g, b, a];
}
/**
* convert 3(or 4)-digit hex color to 6(or 8)-digit hex color.
* @memberof Color
* @param {} hex - 3(or 4)-digit hex color
* @return {} 6(or 8)-digit hex color
* @example
import {toFullHex} from "@daybrush/utils";

console.log(toFullHex("#123")); // "#112233"
console.log(toFullHex("#123a")); // "#112233aa"
*/

function toFullHex(h) {
  var r = h.charAt(1);
  var g = h.charAt(2);
  var b = h.charAt(3);
  var a = h.charAt(4);
  var arr = ["#", r, r, g, g, b, b, a, a];
  return arr.join("");
}
/**
* convert hsl color to rgba color.
* @memberof Color
* @param {} hsl - hsl color(hue: 0 ~ 360, saturation: 0 ~ 1, lightness: 0 ~ 1, alpha: 0 ~ 1)
* @return {} rgba color
* @example
import {hslToRGBA} from "@daybrush/utils";

console.log(hslToRGBA([150, 0.5, 0.4]));
// [51, 153, 102, 1]
*/

function hslToRGBA(hsl) {
  var _a;

  var h = hsl[0];
  var s = hsl[1];
  var l = hsl[2];

  if (h < 0) {
    h += Math.floor((Math.abs(h) + 360) / 360) * 360;
  }

  h %= 360;
  var c = (1 - Math.abs(2 * l - 1)) * s;
  var x = c * (1 - Math.abs(h / 60 % 2 - 1));
  var m = l - c / 2;
  var rgb;

  if (h < 60) {
    rgb = [c, x, 0];
  } else if (h < 120) {
    rgb = [x, c, 0];
  } else if (h < 180) {
    rgb = [0, c, x];
  } else if (h < 240) {
    rgb = [0, x, c];
  } else if (h < 300) {
    rgb = [x, 0, c];
  } else if (h < 360) {
    rgb = [c, 0, x];
  } else {
    rgb = [0, 0, 0];
  }

  return [Math.round((rgb[0] + m) * 255), Math.round((rgb[1] + m) * 255), Math.round((rgb[2] + m) * 255), (_a = hsl[3]) !== null && _a !== void 0 ? _a : 1];
}
/**
* convert string to rgba color.
* @memberof Color
* @param {} - 3-hex(#000), 4-hex(#0000) 6-hex(#000000), 8-hex(#00000000) or RGB(A), or HSL(A)
* @return {} rgba color
* @example
import {stringToRGBA} from "@daybrush/utils";

console.log(stringToRGBA("#000000")); // [0, 0, 0, 1]
console.log(stringToRGBA("rgb(100, 100, 100)")); // [100, 100, 100, 1]
console.log(stringToRGBA("hsl(150, 0.5, 0.4)")); // [51, 153, 102, 1]
*/

function stringToRGBA(color) {
  if (color.charAt(0) === "#") {
    if (color.length === 4 || color.length === 5) {
      return hexToRGBA(toFullHex(color));
    } else {
      return hexToRGBA(color);
    }
  } else if (color.indexOf("(") !== -1) {
    // in bracket.
    var _a = splitBracket(color),
        prefix = _a.prefix,
        value = _a.value;

    if (!prefix || !value) {
      return undefined;
    }

    var arr = splitComma(value);
    var colorArr = [0, 0, 0, 1];
    var length = arr.length;

    switch (prefix) {
      case RGB:
      case RGBA:
        for (var i = 0; i < length; ++i) {
          colorArr[i] = parseFloat(arr[i]);
        }

        return colorArr;

      case HSL:
      case HSLA:
        for (var i = 0; i < length; ++i) {
          if (arr[i].indexOf("%") !== -1) {
            colorArr[i] = parseFloat(arr[i]) / 100;
          } else {
            colorArr[i] = parseFloat(arr[i]);
          }
        } // hsl, hsla to rgba


        return hslToRGBA(colorArr);
    }
  }

  return undefined;
}

/**
 * Returns all element descendants of node that
 * match selectors.
 */

/**
 * Checks if the specified class value exists in the element's class attribute.
 * @memberof DOM
 * @param - A DOMString containing one or more selectors to match
 * @param - If multi is true, a DOMString containing one or more selectors to match against.
 * @example
import {$} from "@daybrush/utils";

console.log($("div")); // div element
console.log($("div", true)); // [div, div] elements
*/

function $(selectors, multi) {
  return multi ? doc.querySelectorAll(selectors) : doc.querySelector(selectors);
}
/**
* Checks if the specified class value exists in the element's class attribute.
* @memberof DOM
* @param element - target
* @param className - the class name to search
* @return {boolean} return false if the class is not found.
* @example
import {hasClass} from "@daybrush/utils";

console.log(hasClass(element, "start")); // true or false
*/

function hasClass(element, className) {
  if (element.classList) {
    return element.classList.contains(className);
  }

  return !!element.className.match(new RegExp("(\\s|^)" + className + "(\\s|$)"));
}
/**
* Add the specified class value. If these classe already exist in the element's class attribute they are ignored.
* @memberof DOM
* @param element - target
* @param className - the class name to add
* @example
import {addClass} from "@daybrush/utils";

addClass(element, "start");
*/

function addClass(element, className) {
  if (element.classList) {
    element.classList.add(className);
  } else {
    element.className += " " + className;
  }
}
/**
* Removes the specified class value.
* @memberof DOM
* @param element - target
* @param className - the class name to remove
* @example
import {removeClass} from "@daybrush/utils";

removeClass(element, "start");
*/

function removeClass(element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else {
    var reg = new RegExp("(\\s|^)" + className + "(\\s|$)");
    element.className = element.className.replace(reg, " ");
  }
}
/**
* Gets the CSS properties from the element.
* @memberof DOM
* @param elements - elements
* @param properites - the CSS properties
* @return returns CSS properties and values.
* @example
import {fromCSS} from "@daybrush/utils";

console.log(fromCSS(element, ["left", "opacity", "top"])); // {"left": "10px", "opacity": 1, "top": "10px"}
*/

function fromCSS(elements, properties) {
  if (!elements || !properties || !properties.length) {
    return {};
  }

  var element;

  if (elements instanceof Element) {
    element = elements;
  } else if (elements.length) {
    element = elements[0];
  } else {
    return {};
  }

  var cssObject = {};
  var styles = window.getComputedStyle(element);
  var length = properties.length;

  for (var i = 0; i < length; ++i) {
    cssObject[properties[i]] = styles[properties[i]];
  }

  return cssObject;
}
/**
* Sets up a function that will be called whenever the specified event is delivered to the target
* @memberof DOM
* @param - event target
* @param - A case-sensitive string representing the event type to listen for.
* @param - The object which receives a notification (an object that implements the Event interface) when an event of the specified type occurs
* @param - An options object that specifies characteristics about the event listener.
* @example
import {addEvent} from "@daybrush/utils";

addEvent(el, "click", e => {
  console.log(e);
});
*/

function addEvent(el, type, listener, options) {
  el.addEventListener(type, listener, options);
}
/**
* removes from the EventTarget an event listener previously registered with EventTarget.addEventListener()
* @memberof DOM
* @param - event target
* @param - A case-sensitive string representing the event type to listen for.
* @param - The EventListener function of the event handler to remove from the event target.
* @param - An options object that specifies characteristics about the event listener.
* @example
import {addEvent, removeEvent} from "@daybrush/utils";
const listener = e => {
  console.log(e);
};
addEvent(el, "click", listener);
removeEvent(el, "click", listener);
*/

function removeEvent(el, type, listener, options) {
  el.removeEventListener(type, listener, options);
}


//# sourceMappingURL=utils.esm.js.map


/***/ }),

/***/ "./.yarn/cache/@egjs-agent-npm-2.3.0-e88ca0eec2-2506e8feff.zip/node_modules/@egjs/agent/dist/agent.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "getAccurateAgent": () => (/* binding */ getAccurateAgent)
/* harmony export */ });
/*
Copyright (c) 2015 NAVER Corp.
name: @egjs/agent
license: MIT
author: NAVER Corp.
repository: git+https://github.com/naver/agent.git
version: 2.3.0
*/
function some(arr, callback) {
  var length = arr.length;

  for (var i = 0; i < length; ++i) {
    if (callback(arr[i], i)) {
      return true;
    }
  }

  return false;
}
function find(arr, callback) {
  var length = arr.length;

  for (var i = 0; i < length; ++i) {
    if (callback(arr[i], i)) {
      return arr[i];
    }
  }

  return null;
}
function getUserAgent(agent) {
  var userAgent = agent;

  if (typeof userAgent === "undefined") {
    if (typeof navigator === "undefined" || !navigator) {
      return "";
    }

    userAgent = navigator.userAgent || "";
  }

  return userAgent.toLowerCase();
}
function execRegExp(pattern, text) {
  try {
    return new RegExp(pattern, "g").exec(text);
  } catch (e) {
    return null;
  }
}
function hasUserAgentData() {
  if (typeof navigator === "undefined" || !navigator || !navigator.userAgentData) {
    return false;
  }

  var userAgentData = navigator.userAgentData;
  var brands = userAgentData.brands || userAgentData.uaList;
  return !!(brands && brands.length);
}
function findVersion(versionTest, userAgent) {
  var result = execRegExp("(" + versionTest + ")((?:\\/|\\s|:)([0-9|\\.|_]+))", userAgent);
  return result ? result[3] : "";
}
function convertVersion(text) {
  return text.replace(/_/g, ".");
}
function findPreset(presets, userAgent) {
  var userPreset = null;
  var version = "-1";
  some(presets, function (preset) {
    var result = execRegExp("(" + preset.test + ")((?:\\/|\\s|:)([0-9|\\.|_]+))?", userAgent);

    if (!result || preset.brand) {
      return false;
    }

    userPreset = preset;
    version = result[3] || "-1";

    if (preset.versionAlias) {
      version = preset.versionAlias;
    } else if (preset.versionTest) {
      version = findVersion(preset.versionTest.toLowerCase(), userAgent) || version;
    }

    version = convertVersion(version);
    return true;
  });
  return {
    preset: userPreset,
    version: version
  };
}
function findPresetBrand(presets, brands) {
  var brandInfo = {
    brand: "",
    version: "-1"
  };
  some(presets, function (preset) {
    var result = findBrand(brands, preset);

    if (!result) {
      return false;
    }

    brandInfo.brand = preset.id;
    brandInfo.version = preset.versionAlias || result.version;
    return brandInfo.version !== "-1";
  });
  return brandInfo;
}
function findBrand(brands, preset) {
  return find(brands, function (_a) {
    var brand = _a.brand;
    return execRegExp("" + preset.test, brand.toLowerCase());
  });
}

var BROWSER_PRESETS = [{
  test: "phantomjs",
  id: "phantomjs"
}, {
  test: "whale",
  id: "whale"
}, {
  test: "edgios|edge|edg",
  id: "edge"
}, {
  test: "msie|trident|windows phone",
  id: "ie",
  versionTest: "iemobile|msie|rv"
}, {
  test: "miuibrowser",
  id: "miui browser"
}, {
  test: "samsungbrowser",
  id: "samsung internet"
}, {
  test: "samsung",
  id: "samsung internet",
  versionTest: "version"
}, {
  test: "chrome|crios",
  id: "chrome"
}, {
  test: "firefox|fxios",
  id: "firefox"
}, {
  test: "android",
  id: "android browser",
  versionTest: "version"
}, {
  test: "safari|iphone|ipad|ipod",
  id: "safari",
  versionTest: "version"
}]; // chromium's engine(blink) is based on applewebkit 537.36.

var CHROMIUM_PRESETS = [{
  test: "(?=.*applewebkit/(53[0-7]|5[0-2]|[0-4]))(?=.*\\schrome)",
  id: "chrome",
  versionTest: "chrome"
}, {
  test: "chromium",
  id: "chrome"
}, {
  test: "whale",
  id: "chrome",
  versionAlias: "-1",
  brand: true
}];
var WEBKIT_PRESETS = [{
  test: "applewebkit",
  id: "webkit",
  versionTest: "applewebkit|safari"
}];
var WEBVIEW_PRESETS = [{
  test: "(?=(iphone|ipad))(?!(.*version))",
  id: "webview"
}, {
  test: "(?=(android|iphone|ipad))(?=.*(naver|daum|; wv))",
  id: "webview"
}, {
  // test webview
  test: "webview",
  id: "webview"
}];
var OS_PRESETS = [{
  test: "windows phone",
  id: "windows phone"
}, {
  test: "windows 2000",
  id: "window",
  versionAlias: "5.0"
}, {
  test: "windows nt",
  id: "window"
}, {
  test: "iphone|ipad|ipod",
  id: "ios",
  versionTest: "iphone os|cpu os"
}, {
  test: "mac os x",
  id: "mac"
}, {
  test: "android",
  id: "android"
}, {
  test: "tizen",
  id: "tizen"
}, {
  test: "webos|web0s",
  id: "webos"
}];

function parseUserAgentData(osData) {
  var userAgentData = navigator.userAgentData;
  var brands = (userAgentData.uaList || userAgentData.brands).slice();
  var isMobile = userAgentData.mobile || false;
  var firstBrand = brands[0];
  var browser = {
    name: firstBrand.brand,
    version: firstBrand.version,
    majorVersion: -1,
    webkit: false,
    webkitVersion: "-1",
    chromium: false,
    chromiumVersion: "-1",
    webview: !!findPresetBrand(WEBVIEW_PRESETS, brands).brand
  };
  var os = {
    name: "unknown",
    version: "-1",
    majorVersion: -1
  };
  browser.webkit = !browser.chromium && some(WEBKIT_PRESETS, function (preset) {
    return findBrand(brands, preset);
  });
  var chromiumBrand = findPresetBrand(CHROMIUM_PRESETS, brands);
  browser.chromium = !!chromiumBrand.brand;
  browser.chromiumVersion = chromiumBrand.version;

  if (!browser.chromium) {
    var webkitBrand = findPresetBrand(WEBKIT_PRESETS, brands);
    browser.webkit = !!webkitBrand.brand;
    browser.webkitVersion = webkitBrand.version;
  }

  if (osData) {
    var platform_1 = osData.platform.toLowerCase();
    var result = find(OS_PRESETS, function (preset) {
      return new RegExp("" + preset.test, "g").exec(platform_1);
    });
    os.name = result ? result.id : platform_1;
    os.version = osData.platformVersion;
  }

  var browserBrand = findPresetBrand(BROWSER_PRESETS, brands);

  if (browserBrand.brand) {
    browser.name = browserBrand.brand;
    browser.version = osData ? osData.uaFullVersion : browserBrand.version;
  }

  if (navigator.platform === "Linux armv8l") {
    os.name = "android";
  } else if (browser.webkit) {
    os.name = isMobile ? "ios" : "mac";
  }

  if (os.name === "ios" && browser.webview) {
    browser.version = "-1";
  }

  os.version = convertVersion(os.version);
  browser.version = convertVersion(browser.version);
  os.majorVersion = parseInt(os.version, 10);
  browser.majorVersion = parseInt(browser.version, 10);
  return {
    browser: browser,
    os: os,
    isMobile: isMobile,
    isHints: true
  };
}

function parseUserAgent(userAgent) {
  var nextAgent = getUserAgent(userAgent);
  var isMobile = !!/mobi/g.exec(nextAgent);
  var browser = {
    name: "unknown",
    version: "-1",
    majorVersion: -1,
    webview: !!findPreset(WEBVIEW_PRESETS, nextAgent).preset,
    chromium: false,
    chromiumVersion: "-1",
    webkit: false,
    webkitVersion: "-1"
  };
  var os = {
    name: "unknown",
    version: "-1",
    majorVersion: -1
  };

  var _a = findPreset(BROWSER_PRESETS, nextAgent),
      browserPreset = _a.preset,
      browserVersion = _a.version;

  var _b = findPreset(OS_PRESETS, nextAgent),
      osPreset = _b.preset,
      osVersion = _b.version;

  var chromiumPreset = findPreset(CHROMIUM_PRESETS, nextAgent);
  browser.chromium = !!chromiumPreset.preset;
  browser.chromiumVersion = chromiumPreset.version;

  if (!browser.chromium) {
    var webkitPreset = findPreset(WEBKIT_PRESETS, nextAgent);
    browser.webkit = !!webkitPreset.preset;
    browser.webkitVersion = webkitPreset.version;
  }

  if (osPreset) {
    os.name = osPreset.id;
    os.version = osVersion;
    os.majorVersion = parseInt(osVersion, 10);
  }

  if (browserPreset) {
    browser.name = browserPreset.id;
    browser.version = browserVersion;

    if (browser.webview && os.name === "ios" && browser.name !== "safari") {
      browser.webview = false;
    }
  }

  browser.majorVersion = parseInt(browser.version, 10);
  return {
    browser: browser,
    os: os,
    isMobile: isMobile,
    isHints: false
  };
}

/**
 * @namespace eg.agent
 */

/**
* Extracts accuate browser and operating system information from the user agent string or client hints.
* @ko 유저 에이전트 문자열 또는 client hints에서 정확한 브라우저와 운영체제 정보를 추출한다.
* @function eg.agent#getAccurateAgent
* @param - Callback function to get the accuate agent <ko>정확한 에이전트를 가져오기 위한 callback 함수</ko>
* @return - get the accuate agent promise. If Promise are not supported, null is returned. <ko> 정확한 에이전트 promise를 가져온다. Promise를 지원 하지 않는 경우, null을 반환한다. </ko>
* @example
import { getAccurateAgent } from "@egjs/agent";
// eg.agent.getAccurateAgent()
getAccurateAgent().then(agent => {
   const { os, browser, isMobile } = agent;
});
getAccurateAgent(agent => {
    const { os, browser, isMobile } = agent;
});
*/

function getAccurateAgent(callback) {
  if (hasUserAgentData()) {
    return navigator.userAgentData.getHighEntropyValues(["architecture", "model", "platform", "platformVersion", "uaFullVersion"]).then(function (info) {
      var agentInfo = parseUserAgentData(info);
      callback && callback(agentInfo);
      return agentInfo;
    });
  }

  callback && callback(agent());

  if (typeof Promise === "undefined" || !Promise) {
    return null;
  }

  return Promise.resolve(agent());
}
/**
 * Extracts browser and operating system information from the user agent string.
 * @ko 유저 에이전트 문자열에서 브라우저와 운영체제 정보를 추출한다.
 * @function eg.agent#agent
 * @param - user agent string to parse <ko>파싱할 유저에이전트 문자열</ko>
 * @return - agent Info <ko> 에이전트 정보 </ko>
 * @example
import agent from "@egjs/agent";
// eg.agent();
const { os, browser, isMobile } = agent();
 */

function agent(userAgent) {
  if (typeof userAgent === "undefined" && hasUserAgentData()) {
    return parseUserAgentData();
  } else {
    return parseUserAgent(userAgent);
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (agent);

//# sourceMappingURL=agent.esm.js.map


/***/ }),

/***/ "./.yarn/cache/@egjs-children-differ-npm-1.0.1-37f45ddf97-087f286822.zip/node_modules/@egjs/children-differ/dist/children-differ.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "diff": () => (/* binding */ diff)
/* harmony export */ });
/* harmony import */ var _egjs_list_differ__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@egjs-list-differ-npm-1.0.0-f4b91781db-d1827d134d.zip/node_modules/@egjs/list-differ/dist/list-differ.esm.js");
/*
Copyright (c) 2019-present NAVER Corp.
name: @egjs/children-differ
license: MIT
author: NAVER Corp.
repository: https://github.com/naver/egjs-children-differ
version: 1.0.1
*/


/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

/*
egjs-children-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/
var findKeyCallback = typeof Map === "function" ? undefined : function () {
  var childrenCount = 0;
  return function (el) {
    return el.__DIFF_KEY__ || (el.__DIFF_KEY__ = ++childrenCount);
  };
}();

/**
 * A module that checks diff when child are added, removed, or changed .
 * @ko 자식 노드들에서 자식 노드가 추가되거나 삭제되거나 순서가 변경된 사항을 체크하는 모듈입니다.
 * @memberof eg
 * @extends eg.ListDiffer
 */

var ChildrenDiffer =
/*#__PURE__*/
function (_super) {
  __extends(ChildrenDiffer, _super);
  /**
   * @param - Initializing Children <ko> 초기 설정할 자식 노드들</ko>
   */


  function ChildrenDiffer(list) {
    if (list === void 0) {
      list = [];
    }

    return _super.call(this, list, findKeyCallback) || this;
  }

  return ChildrenDiffer;
}(_egjs_list_differ__WEBPACK_IMPORTED_MODULE_0__["default"]);

/*
egjs-children-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/
/**
 *
 * @memberof eg.ChildrenDiffer
 * @static
 * @function
 * @param - Previous List <ko> 이전 목록 </ko>
 * @param - List to Update <ko> 업데이트 할 목록 </ko>
 * @return - Returns the diff between `prevList` and `list` <ko> `prevList`와 `list`의 다른 점을 반환한다.</ko>
 * @example
 * import { diff } from "@egjs/children-differ";
 * // script => eg.ChildrenDiffer.diff
 * const result = diff([0, 1, 2, 3, 4, 5], [7, 8, 0, 4, 3, 6, 2, 1]);
 * // List before update
 * // [1, 2, 3, 4, 5]
 * console.log(result.prevList);
 * // Updated list
 * // [4, 3, 6, 2, 1]
 * console.log(result.list);
 * // Index array of values added to `list`
 * // [0, 1, 5]
 * console.log(result.added);
 * // Index array of values removed in `prevList`
 * // [5]
 * console.log(result.removed);
 * // An array of index pairs of `prevList` and `list` with different indexes from `prevList` and `list`
 * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]
 * console.log(result.changed);
 * // The subset of `changed` and an array of index pairs that moved data directly. Indicate an array of absolute index pairs of `ordered`.(Formatted by: Array<[index of prevList, index of list]>)
 * // [[4, 3], [3, 4], [2, 6]]
 * console.log(result.pureChanged);
 * // An array of index pairs to be `ordered` that can synchronize `list` before adding data. (Formatted by: Array<[prevIndex, nextIndex]>)
 * // [[4, 1], [4, 2], [4, 3]]
 * console.log(result.ordered);
 * // An array of index pairs of `prevList` and `list` that have not been added/removed so data is preserved
 * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]
 * console.log(result.maintained);
 */

function diff(prevList, list) {
  return (0,_egjs_list_differ__WEBPACK_IMPORTED_MODULE_0__.diff)(prevList, list, findKeyCallback);
}

/*
egjs-children-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ChildrenDiffer);

//# sourceMappingURL=children-differ.esm.js.map


/***/ }),

/***/ "./.yarn/cache/@egjs-list-differ-npm-1.0.0-f4b91781db-d1827d134d.zip/node_modules/@egjs/list-differ/dist/list-differ.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "diff": () => (/* binding */ diff)
/* harmony export */ });
/*
Copyright (c) 2019-present NAVER Corp.
name: @egjs/list-differ
license: MIT
author: NAVER Corp.
repository: https://github.com/naver/egjs-list-differ
version: 1.0.0
*/
/*
egjs-list-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/
var PolyMap =
/*#__PURE__*/
function () {
  function PolyMap() {
    this.keys = [];
    this.values = [];
  }

  var __proto = PolyMap.prototype;

  __proto.get = function (key) {
    return this.values[this.keys.indexOf(key)];
  };

  __proto.set = function (key, value) {
    var keys = this.keys;
    var values = this.values;
    var prevIndex = keys.indexOf(key);
    var index = prevIndex === -1 ? keys.length : prevIndex;
    keys[index] = key;
    values[index] = value;
  };

  return PolyMap;
}();

/*
egjs-list-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/
var HashMap =
/*#__PURE__*/
function () {
  function HashMap() {
    this.object = {};
  }

  var __proto = HashMap.prototype;

  __proto.get = function (key) {
    return this.object[key];
  };

  __proto.set = function (key, value) {
    this.object[key] = value;
  };

  return HashMap;
}();

/*
egjs-list-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/
var SUPPORT_MAP = typeof Map === "function";

/*
egjs-list-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/
var Link =
/*#__PURE__*/
function () {
  function Link() {}

  var __proto = Link.prototype;

  __proto.connect = function (prevLink, nextLink) {
    this.prev = prevLink;
    this.next = nextLink;
    prevLink && (prevLink.next = this);
    nextLink && (nextLink.prev = this);
  };

  __proto.disconnect = function () {
    // In double linked list, diconnect the interconnected relationship.
    var prevLink = this.prev;
    var nextLink = this.next;
    prevLink && (prevLink.next = nextLink);
    nextLink && (nextLink.prev = prevLink);
  };

  __proto.getIndex = function () {
    var link = this;
    var index = -1;

    while (link) {
      link = link.prev;
      ++index;
    }

    return index;
  };

  return Link;
}();

/*
egjs-list-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/

function orderChanged(changed, fixed) {
  // It is roughly in the order of these examples.
  // 4, 6, 0, 2, 1, 3, 5, 7
  var fromLinks = []; // 0, 1, 2, 3, 4, 5, 6, 7

  var toLinks = [];
  changed.forEach(function (_a) {
    var from = _a[0],
        to = _a[1];
    var link = new Link();
    fromLinks[from] = link;
    toLinks[to] = link;
  }); // `fromLinks` are connected to each other by double linked list.

  fromLinks.forEach(function (link, i) {
    link.connect(fromLinks[i - 1]);
  });
  return changed.filter(function (_, i) {
    return !fixed[i];
  }).map(function (_a, i) {
    var from = _a[0],
        to = _a[1];

    if (from === to) {
      return [0, 0];
    }

    var fromLink = fromLinks[from];
    var toLink = toLinks[to - 1];
    var fromIndex = fromLink.getIndex(); // Disconnect the link connected to `fromLink`.

    fromLink.disconnect(); // Connect `fromLink` to the right of `toLink`.

    if (!toLink) {
      fromLink.connect(undefined, fromLinks[0]);
    } else {
      fromLink.connect(toLink, toLink.next);
    }

    var toIndex = fromLink.getIndex();
    return [fromIndex, toIndex];
  });
}

var Result =
/*#__PURE__*/
function () {
  function Result(prevList, list, added, removed, changed, maintained, changedBeforeAdded, fixed) {
    this.prevList = prevList;
    this.list = list;
    this.added = added;
    this.removed = removed;
    this.changed = changed;
    this.maintained = maintained;
    this.changedBeforeAdded = changedBeforeAdded;
    this.fixed = fixed;
  }

  var __proto = Result.prototype;
  Object.defineProperty(__proto, "ordered", {
    get: function () {
      if (!this.cacheOrdered) {
        this.caculateOrdered();
      }

      return this.cacheOrdered;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(__proto, "pureChanged", {
    get: function () {
      if (!this.cachePureChanged) {
        this.caculateOrdered();
      }

      return this.cachePureChanged;
    },
    enumerable: true,
    configurable: true
  });

  __proto.caculateOrdered = function () {
    var ordered = orderChanged(this.changedBeforeAdded, this.fixed);
    var changed = this.changed;
    var pureChanged = [];
    this.cacheOrdered = ordered.filter(function (_a, i) {
      var from = _a[0],
          to = _a[1];
      var _b = changed[i],
          fromBefore = _b[0],
          toBefore = _b[1];

      if (from !== to) {
        pureChanged.push([fromBefore, toBefore]);
        return true;
      }
    });
    this.cachePureChanged = pureChanged;
  };

  return Result;
}();

/**
 *
 * @memberof eg.ListDiffer
 * @static
 * @function
 * @param - Previous List <ko> 이전 목록 </ko>
 * @param - List to Update <ko> 업데이트 할 목록 </ko>
 * @param - This callback function returns the key of the item. <ko> 아이템의 키를 반환하는 콜백 함수입니다.</ko>
 * @return - Returns the diff between `prevList` and `list` <ko> `prevList`와 `list`의 다른 점을 반환한다.</ko>
 * @example
 * import { diff } from "@egjs/list-differ";
 * // script => eg.ListDiffer.diff
 * const result = diff([0, 1, 2, 3, 4, 5], [7, 8, 0, 4, 3, 6, 2, 1], e => e);
 * // List before update
 * // [1, 2, 3, 4, 5]
 * console.log(result.prevList);
 * // Updated list
 * // [4, 3, 6, 2, 1]
 * console.log(result.list);
 * // Index array of values added to `list`
 * // [0, 1, 5]
 * console.log(result.added);
 * // Index array of values removed in `prevList`
 * // [5]
 * console.log(result.removed);
 * // An array of index pairs of `prevList` and `list` with different indexes from `prevList` and `list`
 * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]
 * console.log(result.changed);
 * // The subset of `changed` and an array of index pairs that moved data directly. Indicate an array of absolute index pairs of `ordered`.(Formatted by: Array<[index of prevList, index of list]>)
 * // [[4, 3], [3, 4], [2, 6]]
 * console.log(result.pureChanged);
 * // An array of index pairs to be `ordered` that can synchronize `list` before adding data. (Formatted by: Array<[prevIndex, nextIndex]>)
 * // [[4, 1], [4, 2], [4, 3]]
 * console.log(result.ordered);
 * // An array of index pairs of `prevList` and `list` that have not been added/removed so data is preserved
 * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]
 * console.log(result.maintained);
 */

function diff(prevList, list, findKeyCallback) {
  var mapClass = SUPPORT_MAP ? Map : findKeyCallback ? HashMap : PolyMap;

  var callback = findKeyCallback || function (e) {
    return e;
  };

  var added = [];
  var removed = [];
  var maintained = [];
  var prevKeys = prevList.map(callback);
  var keys = list.map(callback);
  var prevKeyMap = new mapClass();
  var keyMap = new mapClass();
  var changedBeforeAdded = [];
  var fixed = [];
  var removedMap = {};
  var changed = [];
  var addedCount = 0;
  var removedCount = 0; // Add prevKeys and keys to the hashmap.

  prevKeys.forEach(function (key, prevListIndex) {
    prevKeyMap.set(key, prevListIndex);
  });
  keys.forEach(function (key, listIndex) {
    keyMap.set(key, listIndex);
  }); // Compare `prevKeys` and `keys` and add them to `removed` if they are not in `keys`.

  prevKeys.forEach(function (key, prevListIndex) {
    var listIndex = keyMap.get(key); // In prevList, but not in list, it is removed.

    if (typeof listIndex === "undefined") {
      ++removedCount;
      removed.push(prevListIndex);
    } else {
      removedMap[listIndex] = removedCount;
    }
  }); // Compare `prevKeys` and `keys` and add them to `added` if they are not in `prevKeys`.

  keys.forEach(function (key, listIndex) {
    var prevListIndex = prevKeyMap.get(key); // In list, but not in prevList, it is added.

    if (typeof prevListIndex === "undefined") {
      added.push(listIndex);
      ++addedCount;
    } else {
      maintained.push([prevListIndex, listIndex]);
      removedCount = removedMap[listIndex] || 0;
      changedBeforeAdded.push([prevListIndex - removedCount, listIndex - addedCount]);
      fixed.push(listIndex === prevListIndex);

      if (prevListIndex !== listIndex) {
        changed.push([prevListIndex, listIndex]);
      }
    }
  }); // Sort by ascending order of 'to(list's index).

  removed.reverse();
  return new Result(prevList, list, added, removed, changed, maintained, changedBeforeAdded, fixed);
}

/**
 * A module that checks diff when values are added, removed, or changed in an array.
 * @ko 배열 또는 오브젝트에서 값이 추가되거나 삭제되거나 순서가 변경사항을 체크하는 모듈입니다.
 * @memberof eg
 */

var ListDiffer =
/*#__PURE__*/
function () {
  /**
   * @param - Initializing Data Array. <ko> 초기 설정할 데이터 배열.</ko>
   * @param - This callback function returns the key of the item. <ko> 아이템의 키를 반환하는 콜백 함수입니다.</ko>
   * @example
   * import ListDiffer from "@egjs/list-differ";
   * // script => eg.ListDiffer
   * const differ = new ListDiffer([0, 1, 2, 3, 4, 5], e => e);
   * const result = differ.update([7, 8, 0, 4, 3, 6, 2, 1]);
   * // List before update
   * // [1, 2, 3, 4, 5]
   * console.log(result.prevList);
   * // Updated list
   * // [4, 3, 6, 2, 1]
   * console.log(result.list);
   * // Index array of values added to `list`.
   * // [0, 1, 5]
   * console.log(result.added);
   * // Index array of values removed in `prevList`.
   * // [5]
   * console.log(result.removed);
   * // An array of index pairs of `prevList` and `list` with different indexes from `prevList` and `list`.
   * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]
   * console.log(result.changed);
   * // The subset of `changed` and an array of index pairs that moved data directly. Indicate an array of absolute index pairs of `ordered`.(Formatted by: Array<[index of prevList, index of list]>)
   * // [[4, 3], [3, 4], [2, 6]]
   * console.log(result.pureChanged);
   * // An array of index pairs to be `ordered` that can synchronize `list` before adding data. (Formatted by: Array<[prevIndex, nextIndex]>)
   * // [[4, 1], [4, 2], [4, 3]]
   * console.log(result.ordered);
   * // An array of index pairs of `prevList` and `list` that have not been added/removed so data is preserved.
   * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]
   * console.log(result.maintained);
   */
  function ListDiffer(list, findKeyCallback) {
    if (list === void 0) {
      list = [];
    }

    this.findKeyCallback = findKeyCallback;
    this.list = [].slice.call(list);
  }
  /**
   * Update list.
   * @ko 리스트를 업데이트를 합니다.
   * @param - List to update <ko> 업데이트할 리스트 </ko>
   * @return - Returns the results of an update from `prevList` to `list`.<ko> `prevList`에서 `list`로 업데이트한 결과를 반환한다. </ko>
   */


  var __proto = ListDiffer.prototype;

  __proto.update = function (list) {
    var newData = [].slice.call(list);
    var result = diff(this.list, newData, this.findKeyCallback);
    this.list = newData;
    return result;
  };

  return ListDiffer;
}();

/*
egjs-list-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ListDiffer);

//# sourceMappingURL=list-differ.esm.js.map


/***/ }),

/***/ "./.yarn/cache/@scena-dragscroll-npm-1.1.1-8fe60775f9-aacb335870.zip/node_modules/@scena/dragscroll/dist/dragscroll.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _scena_event_emitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/@scena-event-emitter-npm-1.0.5-7ebf361d17-400e0f6ab8.zip/node_modules/@scena/event-emitter/dist/event-emitter.esm.js");
/* harmony import */ var _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@daybrush-utils-npm-1.6.0-547486bf79-2579bc17e0.zip/node_modules/@daybrush/utils/dist/utils.esm.js");
/*
Copyright (c) 2019 Daybrush
name: @scena/dragscroll
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/dragscroll.git
version: 1.1.1
*/



/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

function getDefaultScrollPosition(e) {
  var container = e.container;

  if (container === document.body) {
    return [container.scrollLeft || document.documentElement.scrollLeft, container.scrollTop || document.documentElement.scrollTop];
  }

  return [container.scrollLeft, container.scrollTop];
}

var DragScroll =
/*#__PURE__*/
function (_super) {
  __extends(DragScroll, _super);

  function DragScroll() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this._startRect = null;
    _this._startPos = [];
    _this._prevTime = 0;
    _this._timer = 0;
    _this._prevScrollPos = [0, 0];
    _this._isWait = false;
    return _this;
  }

  var __proto = DragScroll.prototype;

  __proto.dragStart = function (e, options) {
    var container = options.container;
    var top = 0;
    var left = 0;
    var width = 0;
    var height = 0;

    if (container === document.body) {
      width = window.innerWidth;
      height = window.innerHeight;
    } else {
      var rect = container.getBoundingClientRect();
      top = rect.top;
      left = rect.left;
      width = rect.width;
      height = rect.height;
    }

    this._startPos = [e.clientX, e.clientY];
    this._startRect = {
      top: top,
      left: left,
      width: width,
      height: height
    };
    this._prevScrollPos = this._getScrollPosition([0, 0], options);
  };

  __proto.drag = function (e, options) {
    var clientX = e.clientX,
        clientY = e.clientY;
    var _a = options.threshold,
        threshold = _a === void 0 ? 0 : _a;

    var _b = this,
        _startRect = _b._startRect,
        _startPos = _b._startPos;

    var direction = [0, 0];

    if (_startRect.top > clientY - threshold) {
      if (_startPos[1] > _startRect.top || clientY < _startPos[1]) {
        direction[1] = -1;
      }
    } else if (_startRect.top + _startRect.height < clientY + threshold) {
      if (_startPos[1] < _startRect.top + _startRect.height || clientY > _startPos[1]) {
        direction[1] = 1;
      }
    }

    if (_startRect.left > clientX - threshold) {
      if (_startPos[0] > _startRect.left || clientX < _startPos[0]) {
        direction[0] = -1;
      }
    } else if (_startRect.left + _startRect.width < clientX + threshold) {
      if (_startPos[0] < _startRect.left + _startRect.width || clientX > _startPos[0]) {
        direction[0] = 1;
      }
    }

    clearTimeout(this._timer);

    if (!direction[0] && !direction[1]) {
      return false;
    }

    return this._continueDrag(__assign(__assign({}, options), {
      direction: direction,
      inputEvent: e,
      isDrag: true
    }));
  };

  __proto.checkScroll = function (options) {
    var _this = this;

    if (this._isWait) {
      return false;
    }

    var _a = options.prevScrollPos,
        prevScrollPos = _a === void 0 ? this._prevScrollPos : _a,
        direction = options.direction,
        _b = options.throttleTime,
        throttleTime = _b === void 0 ? 0 : _b,
        inputEvent = options.inputEvent,
        isDrag = options.isDrag;

    var nextScrollPos = this._getScrollPosition(direction || [0, 0], options);

    var offsetX = nextScrollPos[0] - prevScrollPos[0];
    var offsetY = nextScrollPos[1] - prevScrollPos[1];
    var nextDirection = direction || [offsetX ? Math.abs(offsetX) / offsetX : 0, offsetY ? Math.abs(offsetY) / offsetY : 0];
    this._prevScrollPos = nextScrollPos;

    if (!offsetX && !offsetY) {
      return false;
    }

    this.trigger("move", {
      offsetX: nextDirection[0] ? offsetX : 0,
      offsetY: nextDirection[1] ? offsetY : 0,
      inputEvent: inputEvent
    });

    if (throttleTime && isDrag) {
      this._timer = window.setTimeout(function () {
        _this._continueDrag(options);
      }, throttleTime);
    }

    return true;
  };

  __proto.dragEnd = function () {
    clearTimeout(this._timer);
  };

  __proto._getScrollPosition = function (direction, options) {
    var container = options.container,
        _a = options.getScrollPosition,
        getScrollPosition = _a === void 0 ? getDefaultScrollPosition : _a;
    return getScrollPosition({
      container: container,
      direction: direction
    });
  };

  __proto._continueDrag = function (options) {
    var _this = this;

    var container = options.container,
        direction = options.direction,
        throttleTime = options.throttleTime,
        useScroll = options.useScroll,
        isDrag = options.isDrag,
        inputEvent = options.inputEvent;

    if (isDrag && this._isWait) {
      return;
    }

    var nowTime = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.now)();
    var distTime = Math.max(throttleTime + this._prevTime - nowTime, 0);

    if (distTime > 0) {
      this._timer = window.setTimeout(function () {
        _this._continueDrag(options);
      }, distTime);
      return false;
    }

    this._prevTime = nowTime;

    var prevScrollPos = this._getScrollPosition(direction, options);

    this._prevScrollPos = prevScrollPos;

    if (isDrag) {
      this._isWait = true;
    }

    this.trigger("scroll", {
      container: container,
      direction: direction,
      inputEvent: inputEvent
    });
    this._isWait = false;
    return useScroll || this.checkScroll(__assign(__assign({}, options), {
      prevScrollPos: prevScrollPos,
      direction: direction,
      inputEvent: inputEvent
    }));
  };

  return DragScroll;
}(_scena_event_emitter__WEBPACK_IMPORTED_MODULE_1__["default"]);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DragScroll);
//# sourceMappingURL=dragscroll.esm.js.map


/***/ }),

/***/ "./.yarn/cache/@scena-event-emitter-npm-1.0.5-7ebf361d17-400e0f6ab8.zip/node_modules/@scena/event-emitter/dist/event-emitter.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@daybrush-utils-npm-1.6.0-547486bf79-2579bc17e0.zip/node_modules/@daybrush/utils/dist/utils.esm.js");
/*
Copyright (c) 2019 Daybrush
name: @scena/event-emitter
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/gesture.git
version: 1.0.5
*/


/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
}

/**
 * Implement EventEmitter on object or component.
 */

var EventEmitter =
/*#__PURE__*/
function () {
  function EventEmitter() {
    this._events = {};
  }
  /**
   * Add a listener to the registered event.
   * @param - Name of the event to be added
   * @param - listener function of the event to be added
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Add listener in "a" event
   * emitter.on("a", () => {
   * });
   * // Add listeners
   * emitter.on({
   *  a: () => {},
   *  b: () => {},
   * });
   */


  var __proto = EventEmitter.prototype;

  __proto.on = function (eventName, listener) {
    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(eventName)) {
      for (var name in eventName) {
        this.on(name, eventName[name]);
      }
    } else {
      this._addEvent(eventName, listener, {});
    }

    return this;
  };
  /**
   * Remove listeners registered in the event target.
   * @param - Name of the event to be removed
   * @param - listener function of the event to be removed
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Remove all listeners.
   * emitter.off();
   *
   * // Remove all listeners in "A" event.
   * emitter.off("a");
   *
   *
   * // Remove "listener" listener in "a" event.
   * emitter.off("a", listener);
   */


  __proto.off = function (eventName, listener) {
    if (!eventName) {
      this._events = {};
    } else if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(eventName)) {
      for (var name in eventName) {
        this.off(name);
      }
    } else if (!listener) {
      this._events[eventName] = [];
    } else {
      var events = this._events[eventName];

      if (events) {
        var index = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.findIndex)(events, function (e) {
          return e.listener === listener;
        });

        if (index > -1) {
          events.splice(index, 1);
        }
      }
    }

    return this;
  };
  /**
   * Add a disposable listener and Use promise to the registered event.
   * @param - Name of the event to be added
   * @param - disposable listener function of the event to be added
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Add a disposable listener in "a" event
   * emitter.once("a", () => {
   * });
   *
   * // Use Promise
   * emitter.once("a").then(e => {
   * });
   */


  __proto.once = function (eventName, listener) {
    var _this = this;

    if (listener) {
      this._addEvent(eventName, listener, {
        once: true
      });
    }

    return new Promise(function (resolve) {
      _this._addEvent(eventName, resolve, {
        once: true
      });
    });
  };
  /**
   * Fires an event to call listeners.
   * @param - Event name
   * @param - Event parameter
   * @return If false, stop the event.
   * @example
   *
   * import EventEmitter from "@scena/event-emitter";
   *
   *
   * const emitter = new EventEmitter();
   *
   * emitter.on("a", e => {
   * });
   *
   *
   * emitter.emit("a", {
   *   a: 1,
   * });
   */


  __proto.emit = function (eventName, param) {
    var _this = this;

    if (param === void 0) {
      param = {};
    }

    var events = this._events[eventName];

    if (!eventName || !events) {
      return true;
    }

    var isStop = false;
    param.eventType = eventName;

    param.stop = function () {
      isStop = true;
    };

    param.currentTarget = this;

    __spreadArrays(events).forEach(function (info) {
      info.listener(param);

      if (info.once) {
        _this.off(eventName, info.listener);
      }
    });

    return !isStop;
  };
  /**
   * Fires an event to call listeners.
   * @param - Event name
   * @param - Event parameter
   * @return If false, stop the event.
   * @example
   *
   * import EventEmitter from "@scena/event-emitter";
   *
   *
   * const emitter = new EventEmitter();
   *
   * emitter.on("a", e => {
   * });
   *
   *
   * emitter.emit("a", {
   *   a: 1,
   * });
   */

  /**
  * Fires an event to call listeners.
  * @param - Event name
  * @param - Event parameter
  * @return If false, stop the event.
  * @example
  *
  * import EventEmitter from "@scena/event-emitter";
  *
  *
  * const emitter = new EventEmitter();
  *
  * emitter.on("a", e => {
  * });
  *
  * // emit
  * emitter.trigger("a", {
  *   a: 1,
  * });
  */


  __proto.trigger = function (eventName, param) {
    if (param === void 0) {
      param = {};
    }

    return this.emit(eventName, param);
  };

  __proto._addEvent = function (eventName, listener, options) {
    var events = this._events;
    events[eventName] = events[eventName] || [];
    var listeners = events[eventName];
    listeners.push(__assign({
      listener: listener
    }, options));
  };

  return EventEmitter;
}();

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EventEmitter);
//# sourceMappingURL=event-emitter.esm.js.map


/***/ }),

/***/ "./.yarn/cache/@scena-matrix-npm-1.1.1-da964f6b3a-e96aeab712.zip/node_modules/@scena/matrix/dist/matrix.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "calculate": () => (/* binding */ calculate),
/* harmony export */   "convertCSStoMatrix": () => (/* binding */ convertCSStoMatrix),
/* harmony export */   "convertDimension": () => (/* binding */ convertDimension),
/* harmony export */   "convertMatrixtoCSS": () => (/* binding */ convertMatrixtoCSS),
/* harmony export */   "convertPositionMatrix": () => (/* binding */ convertPositionMatrix),
/* harmony export */   "createIdentityMatrix": () => (/* binding */ createIdentityMatrix),
/* harmony export */   "createOriginMatrix": () => (/* binding */ createOriginMatrix),
/* harmony export */   "createRotateMatrix": () => (/* binding */ createRotateMatrix),
/* harmony export */   "createScaleMatrix": () => (/* binding */ createScaleMatrix),
/* harmony export */   "createWarpMatrix": () => (/* binding */ createWarpMatrix),
/* harmony export */   "fromTranslation": () => (/* binding */ fromTranslation),
/* harmony export */   "getCenter": () => (/* binding */ getCenter),
/* harmony export */   "getOrigin": () => (/* binding */ getOrigin),
/* harmony export */   "ignoreDimension": () => (/* binding */ ignoreDimension),
/* harmony export */   "invert": () => (/* binding */ invert),
/* harmony export */   "matrix3d": () => (/* binding */ matrix3d),
/* harmony export */   "minus": () => (/* binding */ minus),
/* harmony export */   "multiplies": () => (/* binding */ multiplies),
/* harmony export */   "multiply": () => (/* binding */ multiply),
/* harmony export */   "plus": () => (/* binding */ plus),
/* harmony export */   "rotate": () => (/* binding */ rotate),
/* harmony export */   "rotateX3d": () => (/* binding */ rotateX3d),
/* harmony export */   "rotateY3d": () => (/* binding */ rotateY3d),
/* harmony export */   "rotateZ3d": () => (/* binding */ rotateZ3d),
/* harmony export */   "scale3d": () => (/* binding */ scale3d),
/* harmony export */   "translate3d": () => (/* binding */ translate3d),
/* harmony export */   "transpose": () => (/* binding */ transpose)
/* harmony export */ });
/* harmony import */ var _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@daybrush-utils-npm-1.6.0-547486bf79-2579bc17e0.zip/node_modules/@daybrush/utils/dist/utils.esm.js");
/*
Copyright (c) 2020 Daybrush
name: @scena/matrix
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/matrix
version: 1.1.1
*/


function add(matrix, inverseMatrix, startIndex, fromIndex, n, k) {
  for (var i = 0; i < n; ++i) {
    var x = startIndex + i * n;
    var fromX = fromIndex + i * n;
    matrix[x] += matrix[fromX] * k;
    inverseMatrix[x] += inverseMatrix[fromX] * k;
  }
}

function swap(matrix, inverseMatrix, startIndex, fromIndex, n) {
  for (var i = 0; i < n; ++i) {
    var x = startIndex + i * n;
    var fromX = fromIndex + i * n;
    var v = matrix[x];
    var iv = inverseMatrix[x];
    matrix[x] = matrix[fromX];
    matrix[fromX] = v;
    inverseMatrix[x] = inverseMatrix[fromX];
    inverseMatrix[fromX] = iv;
  }
}

function divide(matrix, inverseMatrix, startIndex, n, k) {
  for (var i = 0; i < n; ++i) {
    var x = startIndex + i * n;
    matrix[x] /= k;
    inverseMatrix[x] /= k;
  }
}
/**
 *
 * @namespace Matrix
 */

/**
 * @memberof Matrix
 */


function ignoreDimension(matrix, m, n) {
  if (n === void 0) {
    n = Math.sqrt(matrix.length);
  }

  var newMatrix = matrix.slice();

  for (var i = 0; i < n; ++i) {
    newMatrix[i * n + m - 1] = 0;
    newMatrix[(m - 1) * n + i] = 0;
  }

  newMatrix[(m - 1) * (n + 1)] = 1;
  return newMatrix;
}
/**
 * @memberof Matrix
 */

function invert(matrix, n) {
  if (n === void 0) {
    n = Math.sqrt(matrix.length);
  }

  var newMatrix = matrix.slice();
  var inverseMatrix = createIdentityMatrix(n);

  for (var i = 0; i < n; ++i) {
    // diagonal
    var identityIndex = n * i + i;

    if (!(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.throttle)(newMatrix[identityIndex], _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.TINY_NUM)) {
      // newMatrix[identityIndex] = 0;
      for (var j = i + 1; j < n; ++j) {
        if (newMatrix[n * i + j]) {
          swap(newMatrix, inverseMatrix, i, j, n);
          break;
        }
      }
    }

    if (!(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.throttle)(newMatrix[identityIndex], _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.TINY_NUM)) {
      // no inverse matrix
      return [];
    }

    divide(newMatrix, inverseMatrix, i, n, newMatrix[identityIndex]);

    for (var j = 0; j < n; ++j) {
      var targetStartIndex = j;
      var targetIndex = j + i * n;
      var target = newMatrix[targetIndex];

      if (!(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.throttle)(target, _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.TINY_NUM) || i === j) {
        continue;
      }

      add(newMatrix, inverseMatrix, targetStartIndex, i, n, -target);
    }
  }

  return inverseMatrix;
}
/**
 * @memberof Matrix
 */

function transpose(matrix, n) {
  if (n === void 0) {
    n = Math.sqrt(matrix.length);
  }

  var newMatrix = [];

  for (var i = 0; i < n; ++i) {
    for (var j = 0; j < n; ++j) {
      newMatrix[j * n + i] = matrix[n * i + j];
    }
  }

  return newMatrix;
}
/**
 * @memberof Matrix
 */

function getOrigin(matrix, n) {
  if (n === void 0) {
    n = Math.sqrt(matrix.length);
  }

  var originMatrix = [];
  var w = matrix[n * n - 1];

  for (var i = 0; i < n - 1; ++i) {
    originMatrix[i] = matrix[n * (n - 1) + i] / w;
  }

  originMatrix[n - 1] = 0;
  return originMatrix;
}
/**
 * @memberof Matrix
 */

function fromTranslation(pos, n) {
  var newMatrix = createIdentityMatrix(n);

  for (var i = 0; i < n - 1; ++i) {
    newMatrix[n * (n - 1) + i] = pos[i] || 0;
  }

  return newMatrix;
}
/**
 * @memberof Matrix
 */

function convertPositionMatrix(matrix, n) {
  var newMatrix = matrix.slice();

  for (var i = matrix.length; i < n - 1; ++i) {
    newMatrix[i] = 0;
  }

  newMatrix[n - 1] = 1;
  return newMatrix;
}
/**
 * @memberof Matrix
 */

function convertDimension(matrix, n, m) {
  if (n === void 0) {
    n = Math.sqrt(matrix.length);
  } // n < m


  if (n === m) {
    return matrix;
  }

  var newMatrix = createIdentityMatrix(m);
  var length = Math.min(n, m);

  for (var i = 0; i < length - 1; ++i) {
    for (var j = 0; j < length - 1; ++j) {
      newMatrix[i * m + j] = matrix[i * n + j];
    }

    newMatrix[(i + 1) * m - 1] = matrix[(i + 1) * n - 1];
    newMatrix[(m - 1) * m + i] = matrix[(n - 1) * n + i];
  }

  newMatrix[m * m - 1] = matrix[n * n - 1];
  return newMatrix;
}
/**
 * @memberof Matrix
 */

function multiplies(n) {
  var matrixes = [];

  for (var _i = 1; _i < arguments.length; _i++) {
    matrixes[_i - 1] = arguments[_i];
  }

  var m = createIdentityMatrix(n);
  matrixes.forEach(function (matrix) {
    m = multiply(m, matrix, n);
  });
  return m;
}
/**
 * @memberof Matrix
 */

function multiply(matrix, matrix2, n) {
  if (n === void 0) {
    n = Math.sqrt(matrix.length);
  }

  var newMatrix = []; // 1 y: n
  // 1 x: m
  // 2 x: m
  // 2 y: k
  // n * m X m * k

  var m = matrix.length / n;
  var k = matrix2.length / m;

  if (!m) {
    return matrix2;
  } else if (!k) {
    return matrix;
  }

  for (var i = 0; i < n; ++i) {
    for (var j = 0; j < k; ++j) {
      newMatrix[j * n + i] = 0;

      for (var l = 0; l < m; ++l) {
        // m1 x: m(l), y: n(i)
        // m2 x: k(j):  y: m(l)
        // nw x: n(i), y: k(j)
        newMatrix[j * n + i] += matrix[l * n + i] * matrix2[j * m + l];
      }
    }
  } // n * k


  return newMatrix;
}
/**
 * @memberof Matrix
 */

function plus(pos1, pos2) {
  var length = Math.min(pos1.length, pos2.length);
  var nextPos = pos1.slice();

  for (var i = 0; i < length; ++i) {
    nextPos[i] = nextPos[i] + pos2[i];
  }

  return nextPos;
}
/**
 * @memberof Matrix
 */

function minus(pos1, pos2) {
  var length = Math.min(pos1.length, pos2.length);
  var nextPos = pos1.slice();

  for (var i = 0; i < length; ++i) {
    nextPos[i] = nextPos[i] - pos2[i];
  }

  return nextPos;
}
/**
 * @memberof Matrix
 */

function convertCSStoMatrix(a, is2d) {
  if (is2d === void 0) {
    is2d = a.length === 6;
  }

  if (is2d) {
    return [a[0], a[1], 0, a[2], a[3], 0, a[4], a[5], 1];
  }

  return a;
}
/**
 * @memberof Matrix
 */

function convertMatrixtoCSS(a, is2d) {
  if (is2d === void 0) {
    is2d = a.length === 9;
  }

  if (is2d) {
    return [a[0], a[1], a[3], a[4], a[6], a[7]];
  }

  return a;
}
/**
 * @memberof Matrix
 */

function calculate(matrix, matrix2, n) {
  if (n === void 0) {
    n = matrix2.length;
  }

  var result = multiply(matrix, matrix2, n);
  var k = result[n - 1];
  return result.map(function (v) {
    return v / k;
  });
}
/**
 * @memberof Matrix
 */

function rotateX3d(matrix, rad) {
  return multiply(matrix, [1, 0, 0, 0, 0, Math.cos(rad), Math.sin(rad), 0, 0, -Math.sin(rad), Math.cos(rad), 0, 0, 0, 0, 1], 4);
}
/**
 * @memberof Matrix
 */

function rotateY3d(matrix, rad) {
  return multiply(matrix, [Math.cos(rad), 0, -Math.sin(rad), 0, 0, 1, 0, 0, Math.sin(rad), 0, Math.cos(rad), 0, 0, 0, 0, 1], 4);
}
/**
 * @memberof Matrix
 */

function rotateZ3d(matrix, rad) {
  return multiply(matrix, createRotateMatrix(rad, 4));
}
/**
 * @memberof Matrix
 */

function scale3d(matrix, _a) {
  var _b = _a[0],
      sx = _b === void 0 ? 1 : _b,
      _c = _a[1],
      sy = _c === void 0 ? 1 : _c,
      _d = _a[2],
      sz = _d === void 0 ? 1 : _d;
  return multiply(matrix, [sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1], 4);
}
/**
 * @memberof Matrix
 */

function rotate(pos, rad) {
  return calculate(createRotateMatrix(rad, 3), convertPositionMatrix(pos, 3));
}
/**
 * @memberof Matrix
 */

function translate3d(matrix, _a) {
  var _b = _a[0],
      tx = _b === void 0 ? 0 : _b,
      _c = _a[1],
      ty = _c === void 0 ? 0 : _c,
      _d = _a[2],
      tz = _d === void 0 ? 0 : _d;
  return multiply(matrix, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1], 4);
}
/**
 * @memberof Matrix
 */

function matrix3d(matrix1, matrix2) {
  return multiply(matrix1, matrix2, 4);
}
/**
 * @memberof Matrix
 */

function createRotateMatrix(rad, n) {
  var cos = Math.cos(rad);
  var sin = Math.sin(rad);
  var m = createIdentityMatrix(n); // cos -sin
  // sin cos

  m[0] = cos;
  m[1] = sin;
  m[n] = -sin;
  m[n + 1] = cos;
  return m;
}
/**
 * @memberof Matrix
 */

function createIdentityMatrix(n) {
  var length = n * n;
  var matrix = [];

  for (var i = 0; i < length; ++i) {
    matrix[i] = i % (n + 1) ? 0 : 1;
  }

  return matrix;
}
/**
 * @memberof Matrix
 */

function createScaleMatrix(scale, n) {
  var m = createIdentityMatrix(n);
  var length = Math.min(scale.length, n - 1);

  for (var i = 0; i < length; ++i) {
    m[(n + 1) * i] = scale[i];
  }

  return m;
}
/**
 * @memberof Matrix
 */

function createOriginMatrix(origin, n) {
  var m = createIdentityMatrix(n);
  var length = Math.min(origin.length, n - 1);

  for (var i = 0; i < length; ++i) {
    m[n * (n - 1) + i] = origin[i];
  }

  return m;
}
/**
 * @memberof Matrix
 */

function createWarpMatrix(pos0, pos1, pos2, pos3, nextPos0, nextPos1, nextPos2, nextPos3) {
  var x0 = pos0[0],
      y0 = pos0[1];
  var x1 = pos1[0],
      y1 = pos1[1];
  var x2 = pos2[0],
      y2 = pos2[1];
  var x3 = pos3[0],
      y3 = pos3[1];
  var u0 = nextPos0[0],
      v0 = nextPos0[1];
  var u1 = nextPos1[0],
      v1 = nextPos1[1];
  var u2 = nextPos2[0],
      v2 = nextPos2[1];
  var u3 = nextPos3[0],
      v3 = nextPos3[1];
  var matrix = [x0, 0, x1, 0, x2, 0, x3, 0, y0, 0, y1, 0, y2, 0, y3, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, x0, 0, x1, 0, x2, 0, x3, 0, y0, 0, y1, 0, y2, 0, y3, 0, 1, 0, 1, 0, 1, 0, 1, -u0 * x0, -v0 * x0, -u1 * x1, -v1 * x1, -u2 * x2, -v2 * x2, -u3 * x3, -v3 * x3, -u0 * y0, -v0 * y0, -u1 * y1, -v1 * y1, -u2 * y2, -v2 * y2, -u3 * y3, -v3 * y3];
  var inverseMatrix = invert(matrix, 8);

  if (!inverseMatrix.length) {
    return [];
  }

  var h = multiply(inverseMatrix, [u0, v0, u1, v1, u2, v2, u3, v3], 8);
  h[8] = 1;
  return convertDimension(transpose(h), 3, 4);
}
/**
 * @memberof Matrix
 */

function getCenter(points) {
  return [0, 1].map(function (i) {
    return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.average)(points.map(function (pos) {
      return pos[i];
    }));
  });
}


//# sourceMappingURL=matrix.esm.js.map


/***/ }),

/***/ "./.yarn/cache/css-to-mat-npm-1.0.3-8a69ed71de-a3fc98bfad.zip/node_modules/css-to-mat/dist/css-to-mat.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "calculateMatrixDist": () => (/* binding */ calculateMatrixDist),
/* harmony export */   "createMatrix": () => (/* binding */ createMatrix),
/* harmony export */   "getDistElementMatrix": () => (/* binding */ getDistElementMatrix),
/* harmony export */   "getElementMatrix": () => (/* binding */ getElementMatrix),
/* harmony export */   "parse": () => (/* binding */ parse),
/* harmony export */   "parseMat": () => (/* binding */ parseMat),
/* harmony export */   "toMat": () => (/* binding */ toMat)
/* harmony export */ });
/* harmony import */ var _daybrush_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/@daybrush-utils-npm-1.6.0-547486bf79-2579bc17e0.zip/node_modules/@daybrush/utils/dist/utils.esm.js");
/* harmony import */ var _scena_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@scena-matrix-npm-1.1.1-da964f6b3a-e96aeab712.zip/node_modules/@scena/matrix/dist/matrix.esm.js");
/*
Copyright (c) 2019 Daybrush
name: css-to-mat
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/css-to-mat.git
version: 1.0.3
*/



function createMatrix() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function parseMat(transform) {
  return toMat(parse(transform));
}
function getElementMatrix(el) {
  return parseMat(getComputedStyle(el).transform);
}
function calculateMatrixDist(matrix, pos) {
  var res = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_0__.calculate)(matrix, [pos[0], pos[1] || 0, pos[2] || 0, 1], 4);
  var w = res[3] || 1;
  return [res[0] / w, res[1] / w, res[2] / w];
}
function getDistElementMatrix(el, container) {
  if (container === void 0) {
    container = document.body;
  }

  var target = el;
  var matrix = createMatrix();

  while (target) {
    var transform = getComputedStyle(target).transform;
    matrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_0__.matrix3d)(parseMat(transform), matrix);

    if (target === container) {
      break;
    }

    target = target.parentElement;
  }

  matrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_0__.invert)(matrix, 4);
  matrix[12] = 0;
  matrix[13] = 0;
  matrix[14] = 0;
  return matrix;
}
function toMat(matrixInfos) {
  var target = createMatrix();
  matrixInfos.forEach(function (info) {
    var matrixFunction = info.matrixFunction,
        functionValue = info.functionValue;

    if (!matrixFunction) {
      return;
    }

    target = matrixFunction(target, functionValue);
  });
  return target;
}
function parse(transform) {
  var transforms = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.isArray)(transform) ? transform : (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.splitSpace)(transform);
  return transforms.map(function (t) {
    var _a = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.splitBracket)(t),
        name = _a.prefix,
        value = _a.value;

    var matrixFunction = null;
    var functionName = name;
    var functionValue = "";

    if (name === "translate" || name === "translateX" || name === "translate3d") {
      var _b = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.splitComma)(value).map(function (v) {
        return parseFloat(v);
      }),
          posX = _b[0],
          _c = _b[1],
          posY = _c === void 0 ? 0 : _c,
          _d = _b[2],
          posZ = _d === void 0 ? 0 : _d;

      matrixFunction = _scena_matrix__WEBPACK_IMPORTED_MODULE_0__.translate3d;
      functionValue = [posX, posY, posZ];
    } else if (name === "translateY") {
      var posY = parseFloat(value);
      matrixFunction = _scena_matrix__WEBPACK_IMPORTED_MODULE_0__.translate3d;
      functionValue = [0, posY, 0];
    } else if (name === "translateZ") {
      var posZ = parseFloat(value);
      matrixFunction = _scena_matrix__WEBPACK_IMPORTED_MODULE_0__.translate3d;
      functionValue = [0, 0, posZ];
    } else if (name === "scale" || name === "scale3d") {
      var _e = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.splitComma)(value).map(function (v) {
        return parseFloat(v);
      }),
          sx = _e[0],
          _f = _e[1],
          sy = _f === void 0 ? sx : _f,
          _g = _e[2],
          sz = _g === void 0 ? 1 : _g;

      matrixFunction = _scena_matrix__WEBPACK_IMPORTED_MODULE_0__.scale3d;
      functionValue = [sx, sy, sz];
    } else if (name === "scaleX") {
      var sx = parseFloat(value);
      matrixFunction = _scena_matrix__WEBPACK_IMPORTED_MODULE_0__.scale3d;
      functionValue = [sx, 1, 1];
    } else if (name === "scaleY") {
      var sy = parseFloat(value);
      matrixFunction = _scena_matrix__WEBPACK_IMPORTED_MODULE_0__.scale3d;
      functionValue = [1, sy, 1];
    } else if (name === "scaleZ") {
      var sz = parseFloat(value);
      matrixFunction = _scena_matrix__WEBPACK_IMPORTED_MODULE_0__.scale3d;
      functionValue = [1, 1, sz];
    } else if (name === "rotate" || name === "rotateZ" || name === "rotateX" || name === "rotateY") {
      var _h = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.splitUnit)(value),
          unit = _h.unit,
          unitValue = _h.value;

      var rad = unit === "rad" ? unitValue : unitValue * Math.PI / 180;

      if (name === "rotate" || name === "rotateZ") {
        functionName = "rotateZ";
        matrixFunction = _scena_matrix__WEBPACK_IMPORTED_MODULE_0__.rotateZ3d;
      } else if (name === "rotateX") {
        matrixFunction = _scena_matrix__WEBPACK_IMPORTED_MODULE_0__.rotateX3d;
      } else if (name === "rotateY") {
        matrixFunction = _scena_matrix__WEBPACK_IMPORTED_MODULE_0__.rotateY3d;
      }

      functionValue = rad;
    } else if (name === "matrix3d") {
      matrixFunction = _scena_matrix__WEBPACK_IMPORTED_MODULE_0__.matrix3d;
      functionValue = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.splitComma)(value).map(function (v) {
        return parseFloat(v);
      });
    } else if (name === "matrix") {
      var m = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.splitComma)(value).map(function (v) {
        return parseFloat(v);
      });
      matrixFunction = _scena_matrix__WEBPACK_IMPORTED_MODULE_0__.matrix3d;
      functionValue = [m[0], m[1], 0, 0, m[2], m[3], 0, 0, 0, 0, 1, 0, m[4], m[5], 0, 1];
    } else {
      functionName = "";
    }

    return {
      name: name,
      functionName: functionName,
      value: value,
      matrixFunction: matrixFunction,
      functionValue: functionValue
    };
  });
}


//# sourceMappingURL=css-to-mat.esm.js.map


/***/ }),

/***/ "./.yarn/cache/framework-utils-npm-1.1.0-37a54a069c-01b61ead17.zip/node_modules/framework-utils/dist/utils.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Properties": () => (/* binding */ Properties),
/* harmony export */   "prefixCSS": () => (/* binding */ prefixCSS),
/* harmony export */   "prefixNames": () => (/* binding */ prefixNames),
/* harmony export */   "ref": () => (/* binding */ ref),
/* harmony export */   "refs": () => (/* binding */ refs),
/* harmony export */   "withMethods": () => (/* binding */ withMethods)
/* harmony export */ });
/*
Copyright (c) 2019 Daybrush
name: framework-utils
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/framework-utils.git
version: 1.1.0
*/
function prefixNames(prefix) {
  var classNames = [];

  for (var _i = 1; _i < arguments.length; _i++) {
    classNames[_i - 1] = arguments[_i];
  }

  return classNames.map(function (className) {
    return className.split(" ").map(function (name) {
      return name ? "" + prefix + name : "";
    }).join(" ");
  }).join(" ");
}
function prefixCSS(prefix, css) {
  return css.replace(/([^}{]*){/gm, function (_, selector) {
    return selector.replace(/\.([^{,\s\d.]+)/g, "." + prefix + "$1") + "{";
  });
}
/* react */

function ref(target, name) {
  return function (e) {
    e && (target[name] = e);
  };
}
function refs(target, name, i) {
  return function (e) {
    e && (target[name][i] = e);
  };
}
/* Class Decorator */

function Properties(properties, action) {
  return function (component) {
    var prototype = component.prototype;
    properties.forEach(function (property) {
      action(prototype, property);
    });
  };
}
/* Property Decorator */

function withMethods(methods, duplicate) {
  if (duplicate === void 0) {
    duplicate = {};
  }

  return function (prototype, propertyName) {
    methods.forEach(function (name) {
      var methodName = duplicate[name] || name;

      if (methodName in prototype) {
        return;
      }

      prototype[methodName] = function () {
        var _a;

        var args = [];

        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }

        var result = (_a = this[propertyName])[name].apply(_a, args);

        if (result === this[propertyName]) {
          return this;
        } else {
          return result;
        }
      };
    });
  };
}


//# sourceMappingURL=utils.esm.js.map


/***/ }),

/***/ "./.yarn/cache/gesto-npm-1.7.0-7d5440000b-f2a66bcf0f.zip/node_modules/gesto/dist/gesto.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _scena_event_emitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/@scena-event-emitter-npm-1.0.5-7ebf361d17-400e0f6ab8.zip/node_modules/@scena/event-emitter/dist/event-emitter.esm.js");
/* harmony import */ var _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@daybrush-utils-npm-1.6.0-547486bf79-2579bc17e0.zip/node_modules/@daybrush/utils/dist/utils.esm.js");
/*
Copyright (c) 2019 Daybrush
name: gesto
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/gesto.git
version: 1.7.0
*/



/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

function getRad(pos1, pos2) {
  var distX = pos2[0] - pos1[0];
  var distY = pos2[1] - pos1[1];
  var rad = Math.atan2(distY, distX);
  return rad >= 0 ? rad : rad + Math.PI * 2;
}
function getRotatiion(touches) {
  return getRad([touches[0].clientX, touches[0].clientY], [touches[1].clientX, touches[1].clientY]) / Math.PI * 180;
}
function isMultiTouch(e) {
  return e.touches && e.touches.length >= 2;
}
function getEventClients(e) {
  if (e.touches) {
    return getClients(e.touches);
  } else {
    return [getClient(e)];
  }
}
function getPosition(clients, prevClients, startClients) {
  var length = startClients.length;

  var _a = getAverageClient(clients, length),
      clientX = _a.clientX,
      clientY = _a.clientY,
      originalClientX = _a.originalClientX,
      originalClientY = _a.originalClientY;

  var _b = getAverageClient(prevClients, length),
      prevX = _b.clientX,
      prevY = _b.clientY;

  var _c = getAverageClient(startClients, length),
      startX = _c.clientX,
      startY = _c.clientY;

  var deltaX = clientX - prevX;
  var deltaY = clientY - prevY;
  var distX = clientX - startX;
  var distY = clientY - startY;
  return {
    clientX: originalClientX,
    clientY: originalClientY,
    deltaX: deltaX,
    deltaY: deltaY,
    distX: distX,
    distY: distY
  };
}
function getDist(clients) {
  return Math.sqrt(Math.pow(clients[0].clientX - clients[1].clientX, 2) + Math.pow(clients[0].clientY - clients[1].clientY, 2));
}
function getClients(touches) {
  var length = Math.min(touches.length, 2);
  var clients = [];

  for (var i = 0; i < length; ++i) {
    clients.push(getClient(touches[i]));
  }

  return clients;
}
function getClient(e) {
  return {
    clientX: e.clientX,
    clientY: e.clientY
  };
}
function getAverageClient(clients, length) {
  if (length === void 0) {
    length = clients.length;
  }

  var sumClient = {
    clientX: 0,
    clientY: 0,
    originalClientX: 0,
    originalClientY: 0
  };

  for (var i = 0; i < length; ++i) {
    var client = clients[i];
    sumClient.originalClientX += "originalClientX" in client ? client.originalClientX : client.clientX;
    sumClient.originalClientY += "originalClientY" in client ? client.originalClientY : client.clientY;
    sumClient.clientX += client.clientX;
    sumClient.clientY += client.clientY;
  }

  if (!length) {
    return sumClient;
  }

  return {
    clientX: sumClient.clientX / length,
    clientY: sumClient.clientY / length,
    originalClientX: sumClient.originalClientX / length,
    originalClientY: sumClient.originalClientY / length
  };
}

var ClientStore =
/*#__PURE__*/
function () {
  function ClientStore(clients) {
    this.prevClients = [];
    this.startClients = [];
    this.movement = 0;
    this.length = 0;
    this.startClients = clients;
    this.prevClients = clients;
    this.length = clients.length;
  }

  var __proto = ClientStore.prototype;

  __proto.getAngle = function (clients) {
    if (clients === void 0) {
      clients = this.prevClients;
    }

    return getRotatiion(clients);
  };

  __proto.getRotation = function (clients) {
    if (clients === void 0) {
      clients = this.prevClients;
    }

    return getRotatiion(clients) - getRotatiion(this.startClients);
  };

  __proto.getPosition = function (clients, isAdd) {
    if (clients === void 0) {
      clients = this.prevClients;
    }

    var position = getPosition(clients || this.prevClients, this.prevClients, this.startClients);
    var deltaX = position.deltaX,
        deltaY = position.deltaY;
    this.movement += Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    this.prevClients = clients;
    return position;
  };

  __proto.getPositions = function (clients) {
    if (clients === void 0) {
      clients = this.prevClients;
    }

    var prevClients = this.prevClients;
    return this.startClients.map(function (startClient, i) {
      return getPosition([clients[i]], [prevClients[i]], [startClient]);
    });
  };

  __proto.getMovement = function (clients) {
    var movement = this.movement;

    if (!clients) {
      return movement;
    }

    var currentClient = getAverageClient(clients, this.length);
    var prevClient = getAverageClient(this.prevClients, this.length);
    var deltaX = currentClient.clientX - prevClient.clientX;
    var deltaY = currentClient.clientY - prevClient.clientY;
    return Math.sqrt(deltaX * deltaX + deltaY * deltaY) + movement;
  };

  __proto.getDistance = function (clients) {
    if (clients === void 0) {
      clients = this.prevClients;
    }

    return getDist(clients);
  };

  __proto.getScale = function (clients) {
    if (clients === void 0) {
      clients = this.prevClients;
    }

    return getDist(clients) / getDist(this.startClients);
  };

  __proto.move = function (deltaX, deltaY) {
    this.startClients.forEach(function (client) {
      client.clientX -= deltaX;
      client.clientY -= deltaY;
    });
  };

  return ClientStore;
}();

var INPUT_TAGNAMES = ["textarea", "input"];
/**
 * You can set up drag, pinch events in any browser.
 */

var Gesto =
/*#__PURE__*/
function (_super) {
  __extends(Gesto, _super);
  /**
   *
   */


  function Gesto(targets, options) {
    if (options === void 0) {
      options = {};
    }

    var _this = _super.call(this) || this;

    _this.options = {};
    _this.flag = false;
    _this.pinchFlag = false;
    _this.datas = {};
    _this.isDrag = false;
    _this.isPinch = false;
    _this.isMouse = false;
    _this.isTouch = false;
    _this.clientStores = [];
    _this.targets = [];
    _this.prevTime = 0;
    _this.doubleFlag = false;
    _this._dragFlag = false;

    _this.onDragStart = function (e, isTrusted) {
      if (isTrusted === void 0) {
        isTrusted = true;
      }

      if (!_this.flag && e.cancelable === false) {
        return;
      }

      var _a = _this.options,
          container = _a.container,
          pinchOutside = _a.pinchOutside,
          preventRightClick = _a.preventRightClick,
          preventDefault = _a.preventDefault,
          checkInput = _a.checkInput;
      var isTouch = _this.isTouch;
      var isDragStart = !_this.flag;

      if (isDragStart) {
        var activeElement = document.activeElement;
        var target = e.target;
        var tagName = target.tagName.toLowerCase();
        var hasInput = INPUT_TAGNAMES.indexOf(tagName) > -1;
        var hasContentEditable = target.isContentEditable;

        if (hasInput || hasContentEditable) {
          if (checkInput || activeElement === target) {
            // force false or already focused.
            return false;
          } // no focus


          if (activeElement && hasContentEditable && activeElement.isContentEditable && activeElement.contains(target)) {
            return false;
          }
        } else if ((preventDefault || e.type === "touchstart") && activeElement) {
          var activeTagName = activeElement.tagName;

          if (activeElement.isContentEditable || INPUT_TAGNAMES.indexOf(activeTagName) > -1) {
            activeElement.blur();
          }
        }

        _this.clientStores = [new ClientStore(getEventClients(e))];
        _this.flag = true;
        _this.isDrag = false;
        _this._dragFlag = true;
        _this.datas = {};

        if (preventRightClick && (e.which === 3 || e.button === 2)) {
          _this.initDrag();

          return false;
        }

        _this.doubleFlag = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.now)() - _this.prevTime < 200;

        var result = _this.emit("dragStart", __assign({
          datas: _this.datas,
          inputEvent: e,
          isTrusted: isTrusted,
          isDouble: _this.doubleFlag
        }, _this.getCurrentStore().getPosition(), {
          preventDefault: function () {
            e.preventDefault();
          },
          preventDrag: function () {
            _this._dragFlag = false;
          }
        }));

        if (result === false) {
          _this.initDrag();
        }

        _this.flag && preventDefault && e.preventDefault();
      }

      if (!_this.flag) {
        return false;
      }

      var timer = 0;

      if (isDragStart && isTouch && pinchOutside) {
        timer = setTimeout(function () {
          (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(container, "touchstart", _this.onDragStart, {
            passive: false
          });
        });
      }

      if (!isDragStart && isTouch && pinchOutside) {
        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(container, "touchstart", _this.onDragStart);
      }

      if (_this.flag && isMultiTouch(e)) {
        clearTimeout(timer);

        if (isDragStart && e.touches.length !== e.changedTouches.length) {
          return;
        }

        if (!_this.pinchFlag) {
          _this.onPinchStart(e);
        }
      }
    };

    _this.onDrag = function (e, isScroll) {
      if (!_this.flag) {
        return;
      }

      var clients = getEventClients(e);

      var result = _this.moveClients(clients, e, false);

      if (_this._dragFlag) {
        if (_this.pinchFlag || result.deltaX || result.deltaY) {
          var dragResult = _this.emit("drag", __assign({}, result, {
            isScroll: !!isScroll,
            inputEvent: e
          }));

          if (dragResult === false) {
            _this.stop();

            return;
          }
        }

        if (_this.pinchFlag) {
          _this.onPinch(e, clients);
        }
      }

      _this.getCurrentStore().getPosition(clients, true);
    };

    _this.onDragEnd = function (e) {
      if (!_this.flag) {
        return;
      }

      var _a = _this.options,
          pinchOutside = _a.pinchOutside,
          container = _a.container;

      if (_this.isTouch && pinchOutside) {
        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(container, "touchstart", _this.onDragStart);
      }

      _this.flag = false;

      var position = _this._getPosition();

      var currentTime = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.now)();
      var isDouble = !_this.isDrag && _this.doubleFlag;
      _this.prevTime = _this.isDrag || isDouble ? 0 : currentTime;

      _this.emit("dragEnd", __assign({
        datas: _this.datas,
        isDouble: isDouble,
        isDrag: _this.isDrag,
        isClick: !_this.isDrag,
        inputEvent: e
      }, position));

      if (_this.pinchFlag) {
        _this.onPinchEnd(e);
      }

      _this.clientStores = [];
    };

    _this.onBlur = function () {
      _this.onDragEnd();
    };

    var elements = [].concat(targets);
    _this.options = __assign({
      checkInput: false,
      container: elements.length > 1 ? window : elements[0],
      preventRightClick: true,
      preventDefault: true,
      checkWindowBlur: false,
      pinchThreshold: 0,
      events: ["touch", "mouse"]
    }, options);
    var _a = _this.options,
        container = _a.container,
        events = _a.events,
        checkWindowBlur = _a.checkWindowBlur;
    _this.isTouch = events.indexOf("touch") > -1;
    _this.isMouse = events.indexOf("mouse") > -1;
    _this.targets = elements;

    if (_this.isMouse) {
      elements.forEach(function (el) {
        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(el, "mousedown", _this.onDragStart);
      });
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(container, "mousemove", _this.onDrag);
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(container, "mouseup", _this.onDragEnd);
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(container, "contextmenu", _this.onDragEnd);
    }

    if (checkWindowBlur) {
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(window, "blur", _this.onBlur);
    }

    if (_this.isTouch) {
      var passive_1 = {
        passive: false
      };
      elements.forEach(function (el) {
        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(el, "touchstart", _this.onDragStart, passive_1);
      });
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(container, "touchmove", _this.onDrag, passive_1);
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(container, "touchend", _this.onDragEnd, passive_1);
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(container, "touchcancel", _this.onDragEnd, passive_1);
    }

    return _this;
  }
  /**
   * Stop Gesto's drag events.
   */


  var __proto = Gesto.prototype;

  __proto.stop = function () {
    this.isDrag = false;
    this.flag = false;
    this.clientStores = [];
    this.datas = {};
  };
  /**
   * The total moved distance
   */


  __proto.getMovement = function (clients) {
    return this.getCurrentStore().getMovement(clients) + this.clientStores.slice(1).reduce(function (prev, cur) {
      return prev + cur.movement;
    }, 0);
  };
  /**
   * Whether to drag
   */


  __proto.isDragging = function () {
    return this.isDrag;
  };
  /**
   * Whether to start drag
   */


  __proto.isFlag = function () {
    return this.flag;
  };
  /**
   * Whether to start pinch
   */


  __proto.isPinchFlag = function () {
    return this.pinchFlag;
  };
  /**
  * Whether to start double click
  */


  __proto.isDoubleFlag = function () {
    return this.doubleFlag;
  };
  /**
   * Whether to pinch
   */


  __proto.isPinching = function () {
    return this.isPinch;
  };
  /**
   * If a scroll event occurs, it is corrected by the scroll distance.
   */


  __proto.scrollBy = function (deltaX, deltaY, e, isCallDrag) {
    if (isCallDrag === void 0) {
      isCallDrag = true;
    }

    if (!this.flag) {
      return;
    }

    this.clientStores[0].move(deltaX, deltaY);
    isCallDrag && this.onDrag(e, true);
  };
  /**
   * Create a virtual drag event.
   */


  __proto.move = function (_a, inputEvent) {
    var deltaX = _a[0],
        deltaY = _a[1];
    var store = this.getCurrentStore();
    var nextClients = store.prevClients;
    return this.moveClients(nextClients.map(function (_a) {
      var clientX = _a.clientX,
          clientY = _a.clientY;
      return {
        clientX: clientX + deltaX,
        clientY: clientY + deltaY,
        originalClientX: clientX,
        originalClientY: clientY
      };
    }), inputEvent, true);
  };
  /**
   * The dragStart event is triggered by an external event.
   */


  __proto.triggerDragStart = function (e) {
    this.onDragStart(e, false);
  };
  /**
   * Set the event data while dragging.
   */


  __proto.setEventDatas = function (datas) {
    var currentDatas = this.datas;

    for (var name in datas) {
      currentDatas[name] = datas[name];
    }

    return this;
  };
  /**
   * Get the current event state while dragging.
   */


  __proto.getCurrentEvent = function (inputEvent) {
    return __assign({
      datas: this.datas
    }, this._getPosition(), {
      movement: this.getMovement(),
      isDrag: this.isDrag,
      isPinch: this.isPinch,
      isScroll: false,
      inputEvent: inputEvent
    });
  };
  /**
   * Get & Set the event data while dragging.
   */


  __proto.getEventDatas = function () {
    return this.datas;
  };
  /**
   * Unset Gesto
   */


  __proto.unset = function () {
    var _this = this;

    var targets = this.targets;
    var container = this.options.container;
    this.off();
    (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(window, "blur", this.onBlur);

    if (this.isMouse) {
      targets.forEach(function (target) {
        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(target, "mousedown", _this.onDragStart);
      });
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(container, "mousemove", this.onDrag);
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(container, "mouseup", this.onDragEnd);
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(container, "contextmenu", this.onDragEnd);
    }

    if (this.isTouch) {
      targets.forEach(function (target) {
        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(target, "touchstart", _this.onDragStart);
      });
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(container, "touchstart", this.onDragStart);
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(container, "touchmove", this.onDrag);
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(container, "touchend", this.onDragEnd);
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(container, "touchcancel", this.onDragEnd);
    }
  };

  __proto.onPinchStart = function (e) {
    var pinchThreshold = this.options.pinchThreshold;

    if (this.isDrag && this.getMovement() > pinchThreshold) {
      return;
    }

    var store = new ClientStore(getEventClients(e));
    this.pinchFlag = true;
    this.clientStores.splice(0, 0, store);
    var result = this.emit("pinchStart", __assign({
      datas: this.datas,
      angle: store.getAngle(),
      touches: this.getCurrentStore().getPositions()
    }, store.getPosition(), {
      inputEvent: e
    }));

    if (result === false) {
      this.pinchFlag = false;
    }
  };

  __proto.onPinch = function (e, clients) {
    if (!this.flag || !this.pinchFlag || clients.length < 2) {
      return;
    }

    var store = this.getCurrentStore();
    this.isPinch = true;
    this.emit("pinch", __assign({
      datas: this.datas,
      movement: this.getMovement(clients),
      angle: store.getAngle(clients),
      rotation: store.getRotation(clients),
      touches: store.getPositions(clients),
      scale: store.getScale(clients),
      distance: store.getDistance(clients)
    }, store.getPosition(clients), {
      inputEvent: e
    }));
  };

  __proto.onPinchEnd = function (e) {
    if (!this.pinchFlag) {
      return;
    }

    var isPinch = this.isPinch;
    this.isPinch = false;
    this.pinchFlag = false;
    var store = this.getCurrentStore();
    this.emit("pinchEnd", __assign({
      datas: this.datas,
      isPinch: isPinch,
      touches: store.getPositions()
    }, store.getPosition(), {
      inputEvent: e
    }));
    this.isPinch = false;
    this.pinchFlag = false;
  };

  __proto.initDrag = function () {
    this.clientStores = [];
    this.pinchFlag = false;
    this.doubleFlag = false;
    this.prevTime = 0;
    this.flag = false;
  };

  __proto.getCurrentStore = function () {
    return this.clientStores[0];
  };

  __proto.moveClients = function (clients, inputEvent, isAdd) {
    var position = this._getPosition(clients, isAdd);

    if (position.deltaX || position.deltaY) {
      this.isDrag = true;
    }

    return __assign({
      datas: this.datas
    }, position, {
      movement: this.getMovement(clients),
      isDrag: this.isDrag,
      isPinch: this.isPinch,
      isScroll: false,
      inputEvent: inputEvent
    });
  };

  __proto._getPosition = function (clients, isAdd) {
    var store = this.getCurrentStore();
    var position = store.getPosition(clients, isAdd);

    var _a = this.clientStores.slice(1).reduce(function (prev, cur) {
      var storePosition = cur.getPosition();
      prev.distX += storePosition.distX;
      prev.distY += storePosition.distY;
      return prev;
    }, position),
        distX = _a.distX,
        distY = _a.distY;

    return __assign({}, position, {
      distX: distX,
      distY: distY
    });
  };

  return Gesto;
}(_scena_event_emitter__WEBPACK_IMPORTED_MODULE_1__["default"]);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Gesto);
//# sourceMappingURL=gesto.esm.js.map


/***/ }),

/***/ "./.yarn/cache/keycon-npm-1.1.2-47bb5048df-7be74aaf83.zip/node_modules/keycon/dist/keycon.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "getCombi": () => (/* binding */ getCombi),
/* harmony export */   "getKey": () => (/* binding */ getKey),
/* harmony export */   "getModifierCombi": () => (/* binding */ getModifierCombi)
/* harmony export */ });
/*
Copyright (c) Daybrush
name: keycon
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/keycon.git
version: 1.1.2
*/
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

/*
Copyright (c) 2018 Daybrush
@name: @daybrush/utils
license: MIT
author: Daybrush
repository: https://github.com/daybrush/utils
@version 1.0.0
*/
/**
* get string "object"
* @memberof Consts
* @example
import {OBJECT} from "@daybrush/utils";

console.log(OBJECT); // "object"
*/

var OBJECT = "object";
/**
* get string "string"
* @memberof Consts
* @example
import {STRING} from "@daybrush/utils";

console.log(STRING); // "string"
*/

var STRING = "string";
/**
* Check the type that the value is object.
* @memberof Utils
* @param {string} value - Value to check the type
* @return {} true if the type is correct, false otherwise
* @example
import {isObject} from "@daybrush/utils";

console.log(isObject({})); // true
console.log(isObject(undefined)); // false
console.log(isObject("")); // false
console.log(isObject(null)); // false
*/

function isObject(value) {
  return value && typeof value === OBJECT;
}
/**
* Check the type that the value is isArray.
* @memberof Utils
* @param {string} value - Value to check the type
* @return {} true if the type is correct, false otherwise
* @example
import {isArray} from "@daybrush/utils";

console.log(isArray([])); // true
console.log(isArray({})); // false
console.log(isArray(undefined)); // false
console.log(isArray(null)); // false
*/

function isArray(value) {
  return Array.isArray(value);
}
/**
* Check the type that the value is string.
* @memberof Utils
* @param {string} value - Value to check the type
* @return {} true if the type is correct, false otherwise
* @example
import {isString} from "@daybrush/utils";

console.log(isString("1234")); // true
console.log(isString(undefined)); // false
console.log(isString(1)); // false
console.log(isString(null)); // false
*/

function isString(value) {
  return typeof value === STRING;
}
/**
* Returns the index of the first element in the array that satisfies the provided testing function.
* @function
* @memberof CrossBrowser
* @param - The array `findIndex` was called upon.
* @param - A function to execute on each value in the array until the function returns true, indicating that the satisfying element was found.
* @param - Returns defaultIndex if not found by the function.
* @example
import { findIndex } from "@daybrush/utils";

findIndex([{a: 1}, {a: 2}, {a: 3}, {a: 4}], ({ a }) => a === 2); // 1
*/

function findIndex(arr, callback, defaultIndex) {
  if (defaultIndex === void 0) {
    defaultIndex = -1;
  }

  var length = arr.length;

  for (var i = 0; i < length; ++i) {
    if (callback(arr[i], i, arr)) {
      return i;
    }
  }

  return defaultIndex;
}
/**
* Sets up a function that will be called whenever the specified event is delivered to the target
* @memberof DOM
* @param - event target
* @param - A case-sensitive string representing the event type to listen for.
* @param - The object which receives a notification (an object that implements the Event interface) when an event of the specified type occurs
* @param - An options object that specifies characteristics about the event listener. The available options are:
* @example
import {addEvent} from "@daybrush/utils";

addEvent(el, "click", e => {
  console.log(e);
});
*/

function addEvent(el, type, listener, options) {
  el.addEventListener(type, listener, options);
}
/**
* removes from the EventTarget an event listener previously registered with EventTarget.addEventListener()
* @memberof DOM
* @param - event target
* @param - A case-sensitive string representing the event type to listen for.
* @param - The EventListener function of the event handler to remove from the event target.
* @example
import {addEvent, removeEvent} from "@daybrush/utils";
const listener = e => {
  console.log(e);
};
addEvent(el, "click", listener);
removeEvent(el, "click", listener);
*/

function removeEvent(el, type, listener) {
  el.removeEventListener(type, listener);
}

/*
Copyright (c) 2019 Daybrush
name: @scena/event-emitter
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/gesture.git
version: 1.0.2
*/

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
}

/**
 * Implement EventEmitter on object or component.
 */

var EventEmitter =
/*#__PURE__*/
function () {
  function EventEmitter() {
    this._events = {};
  }
  /**
   * Add a listener to the registered event.
   * @param - Name of the event to be added
   * @param - listener function of the event to be added
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Add listener in "a" event
   * emitter.on("a", () => {
   * });
   * // Add listeners
   * emitter.on({
   *  a: () => {},
   *  b: () => {},
   * });
   */


  var __proto = EventEmitter.prototype;

  __proto.on = function (eventName, listener) {
    if (isObject(eventName)) {
      for (var name in eventName) {
        this.on(name, eventName[name]);
      }
    } else {
      this._addEvent(eventName, listener, {});
    }

    return this;
  };
  /**
   * Remove listeners registered in the event target.
   * @param - Name of the event to be removed
   * @param - listener function of the event to be removed
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Remove all listeners.
   * emitter.off();
   *
   * // Remove all listeners in "A" event.
   * emitter.off("a");
   *
   *
   * // Remove "listener" listener in "a" event.
   * emitter.off("a", listener);
   */


  __proto.off = function (eventName, listener) {
    if (!eventName) {
      this._events = {};
    } else if (isObject(eventName)) {
      for (var name in eventName) {
        this.off(name);
      }
    } else if (!listener) {
      this._events[eventName] = [];
    } else {
      var events = this._events[eventName];

      if (events) {
        var index = findIndex(events, function (e) {
          return e.listener === listener;
        });

        if (index > -1) {
          events.splice(index, 1);
        }
      }
    }

    return this;
  };
  /**
   * Add a disposable listener and Use promise to the registered event.
   * @param - Name of the event to be added
   * @param - disposable listener function of the event to be added
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Add a disposable listener in "a" event
   * emitter.once("a", () => {
   * });
   *
   * // Use Promise
   * emitter.once("a").then(e => {
   * });
   */


  __proto.once = function (eventName, listener) {
    var _this = this;

    if (listener) {
      this._addEvent(eventName, listener, {
        once: true
      });
    }

    return new Promise(function (resolve) {
      _this._addEvent(eventName, resolve, {
        once: true
      });
    });
  };
  /**
   * Fires an event to call listeners.
   * @param - Event name
   * @param - Event parameter
   * @return If false, stop the event.
   * @example
   *
   * import EventEmitter from "@scena/event-emitter";
   *
   *
   * const emitter = new EventEmitter();
   *
   * emitter.on("a", e => {
   * });
   *
   *
   * emitter.emit("a", {
   *   a: 1,
   * });
   */


  __proto.emit = function (eventName, param) {
    var _this = this;

    if (param === void 0) {
      param = {};
    }

    var events = this._events[eventName];

    if (!eventName || !events) {
      return true;
    }

    var isStop = false;
    param.eventType = eventName;

    param.stop = function () {
      isStop = true;
    };

    param.currentTarget = this;

    __spreadArrays(events).forEach(function (info) {
      info.listener(param);

      if (info.once) {
        _this.off(eventName, info.listener);
      }
    });

    return !isStop;
  };
  /**
   * Fires an event to call listeners.
   * @param - Event name
   * @param - Event parameter
   * @return If false, stop the event.
   * @example
   *
   * import EventEmitter from "@scena/event-emitter";
   *
   *
   * const emitter = new EventEmitter();
   *
   * emitter.on("a", e => {
   * });
   *
   *
   * emitter.emit("a", {
   *   a: 1,
   * });
   */

  /**
  * Fires an event to call listeners.
  * @param - Event name
  * @param - Event parameter
  * @return If false, stop the event.
  * @example
  *
  * import EventEmitter from "@scena/event-emitter";
  *
  *
  * const emitter = new EventEmitter();
  *
  * emitter.on("a", e => {
  * });
  *
  * // emit
  * emitter.trigger("a", {
  *   a: 1,
  * });
  */


  __proto.trigger = function (eventName, param) {
    if (param === void 0) {
      param = {};
    }

    return this.emit(eventName, param);
  };

  __proto._addEvent = function (eventName, listener, options) {
    var events = this._events;
    events[eventName] = events[eventName] || [];
    var listeners = events[eventName];
    listeners.push(__assign({
      listener: listener
    }, options));
  };

  return EventEmitter;
}();

function createCommonjsModule(fn, module) {
  return module = {
    exports: {}
  }, fn(module, module.exports), module.exports;
}

var keycode = createCommonjsModule(function (module, exports) {
// Source: http://jsfiddle.net/vWx8V/
// http://stackoverflow.com/questions/5603195/full-list-of-javascript-keycodes

/**
 * Conenience method returns corresponding value for given keyName or keyCode.
 *
 * @param {Mixed} keyCode {Number} or keyName {String}
 * @return {Mixed}
 * @api public
 */

function keyCode(searchInput) {
  // Keyboard Events
  if (searchInput && 'object' === typeof searchInput) {
    var hasKeyCode = searchInput.which || searchInput.keyCode || searchInput.charCode;
    if (hasKeyCode) searchInput = hasKeyCode;
  }

  // Numbers
  if ('number' === typeof searchInput) return names[searchInput]

  // Everything else (cast to string)
  var search = String(searchInput);

  // check codes
  var foundNamedKey = codes[search.toLowerCase()];
  if (foundNamedKey) return foundNamedKey

  // check aliases
  var foundNamedKey = aliases[search.toLowerCase()];
  if (foundNamedKey) return foundNamedKey

  // weird character?
  if (search.length === 1) return search.charCodeAt(0)

  return undefined
}

/**
 * Compares a keyboard event with a given keyCode or keyName.
 *
 * @param {Event} event Keyboard event that should be tested
 * @param {Mixed} keyCode {Number} or keyName {String}
 * @return {Boolean}
 * @api public
 */
keyCode.isEventKey = function isEventKey(event, nameOrCode) {
  if (event && 'object' === typeof event) {
    var keyCode = event.which || event.keyCode || event.charCode;
    if (keyCode === null || keyCode === undefined) { return false; }
    if (typeof nameOrCode === 'string') {
      // check codes
      var foundNamedKey = codes[nameOrCode.toLowerCase()];
      if (foundNamedKey) { return foundNamedKey === keyCode; }
    
      // check aliases
      var foundNamedKey = aliases[nameOrCode.toLowerCase()];
      if (foundNamedKey) { return foundNamedKey === keyCode; }
    } else if (typeof nameOrCode === 'number') {
      return nameOrCode === keyCode;
    }
    return false;
  }
};

exports = module.exports = keyCode;

/**
 * Get by name
 *
 *   exports.code['enter'] // => 13
 */

var codes = exports.code = exports.codes = {
  'backspace': 8,
  'tab': 9,
  'enter': 13,
  'shift': 16,
  'ctrl': 17,
  'alt': 18,
  'pause/break': 19,
  'caps lock': 20,
  'esc': 27,
  'space': 32,
  'page up': 33,
  'page down': 34,
  'end': 35,
  'home': 36,
  'left': 37,
  'up': 38,
  'right': 39,
  'down': 40,
  'insert': 45,
  'delete': 46,
  'command': 91,
  'left command': 91,
  'right command': 93,
  'numpad *': 106,
  'numpad +': 107,
  'numpad -': 109,
  'numpad .': 110,
  'numpad /': 111,
  'num lock': 144,
  'scroll lock': 145,
  'my computer': 182,
  'my calculator': 183,
  ';': 186,
  '=': 187,
  ',': 188,
  '-': 189,
  '.': 190,
  '/': 191,
  '`': 192,
  '[': 219,
  '\\': 220,
  ']': 221,
  "'": 222
};

// Helper aliases

var aliases = exports.aliases = {
  'windows': 91,
  '⇧': 16,
  '⌥': 18,
  '⌃': 17,
  '⌘': 91,
  'ctl': 17,
  'control': 17,
  'option': 18,
  'pause': 19,
  'break': 19,
  'caps': 20,
  'return': 13,
  'escape': 27,
  'spc': 32,
  'spacebar': 32,
  'pgup': 33,
  'pgdn': 34,
  'ins': 45,
  'del': 46,
  'cmd': 91
};

/*!
 * Programatically add the following
 */

// lower case chars
for (i = 97; i < 123; i++) codes[String.fromCharCode(i)] = i - 32;

// numbers
for (var i = 48; i < 58; i++) codes[i - 48] = i;

// function keys
for (i = 1; i < 13; i++) codes['f'+i] = i + 111;

// numpad keys
for (i = 0; i < 10; i++) codes['numpad '+i] = i + 96;

/**
 * Get by code
 *
 *   exports.name[13] // => 'Enter'
 */

var names = exports.names = exports.title = {}; // title for backward compat

// Create reverse mapping
for (i in codes) names[codes[i]] = i;

// Add aliases
for (var alias in aliases) {
  codes[alias] = aliases[alias];
}
});
var keycode_1 = keycode.code;
var keycode_2 = keycode.codes;
var keycode_3 = keycode.aliases;
var keycode_4 = keycode.names;
var keycode_5 = keycode.title;

var codeData = {
  "+": "plus",
  "left command": "meta",
  "right command": "meta"
};
var keysSort = {
  shift: 1,
  ctrl: 2,
  alt: 3,
  meta: 4
};
/**
 * @memberof KeyController
 */

function getKey(keyCode) {
  var key = keycode_4[keyCode] || "";

  for (var name in codeData) {
    key = key.replace(name, codeData[name]);
  }

  return key.replace(/\s/g, "");
}
/**
 * @memberof KeyController
 */

function getCombi(e, key) {
  if (key === void 0) {
    key = getKey(e.keyCode);
  }

  var keys = getModifierCombi(e);
  keys.indexOf(key) === -1 && keys.push(key);
  return keys.filter(Boolean);
}
/**
 * @memberof KeyController
 */

function getModifierCombi(e) {
  var keys = [e.shiftKey && "shift", e.ctrlKey && "ctrl", e.altKey && "alt", e.metaKey && "meta"];
  return keys.filter(Boolean);
}

function getArrangeCombi(keys) {
  var arrangeKeys = keys.slice();
  arrangeKeys.sort(function (prev, next) {
    var prevScore = keysSort[prev] || 5;
    var nextScore = keysSort[next] || 5;
    return prevScore - nextScore;
  });
  return arrangeKeys;
}

var globalKeyController;
/**
 */

var KeyController =
/*#__PURE__*/
function (_super) {
  __extends(KeyController, _super);
  /**
   *
   */


  function KeyController(container) {
    if (container === void 0) {
      container = window;
    }

    var _this = _super.call(this) || this;

    _this.container = container;
    /**
     */

    _this.ctrlKey = false;
    /**
     */

    _this.altKey = false;
    /**
     *
     */

    _this.shiftKey = false;
    /**
     *
     */

    _this.metaKey = false;

    _this.clear = function () {
      _this.ctrlKey = false;
      _this.altKey = false;
      _this.shiftKey = false;
      _this.metaKey = false;
      return _this;
    };

    _this.keydownEvent = function (e) {
      _this.triggerEvent("keydown", e);
    };

    _this.keyupEvent = function (e) {
      _this.triggerEvent("keyup", e);
    };

    _this.blur = function () {
      _this.clear();

      _this.trigger("blur");
    };

    addEvent(container, "blur", _this.blur);
    addEvent(container, "keydown", _this.keydownEvent);
    addEvent(container, "keyup", _this.keyupEvent);
    return _this;
  }

  var __proto = KeyController.prototype;
  Object.defineProperty(KeyController, "global", {
    /**
     */
    get: function () {
      return globalKeyController || (globalKeyController = new KeyController());
    },
    enumerable: false,
    configurable: true
  });

  KeyController.setGlobal = function () {
    return this.global;
  };
  /**
   *
   */


  __proto.destroy = function () {
    var container = this.container;
    this.clear();
    this.off();
    removeEvent(container, "blur", this.blur);
    removeEvent(container, "keydown", this.keydownEvent);
    removeEvent(container, "keyup", this.keyupEvent);
  };
  /**
   *
   */


  __proto.keydown = function (comb, callback) {
    return this.addEvent("keydown", comb, callback);
  };
  /**
   *
   */


  __proto.offKeydown = function (comb, callback) {
    return this.removeEvent("keydown", comb, callback);
  };
  /**
   *
   */


  __proto.offKeyup = function (comb, callback) {
    return this.removeEvent("keyup", comb, callback);
  };
  /**
   *
   */


  __proto.keyup = function (comb, callback) {
    return this.addEvent("keyup", comb, callback);
  };

  __proto.addEvent = function (type, comb, callback) {
    if (isArray(comb)) {
      this.on(type + "." + getArrangeCombi(comb).join("."), callback);
    } else if (isString(comb)) {
      this.on(type + "." + comb, callback);
    } else {
      this.on(type, comb);
    }

    return this;
  };

  __proto.removeEvent = function (type, comb, callback) {
    if (isArray(comb)) {
      this.off(type + "." + getArrangeCombi(comb).join("."), callback);
    } else if (isString(comb)) {
      this.off(type + "." + comb, callback);
    } else {
      this.off(type, comb);
    }

    return this;
  };

  __proto.triggerEvent = function (type, e) {
    this.ctrlKey = e.ctrlKey;
    this.shiftKey = e.shiftKey;
    this.altKey = e.altKey;
    this.metaKey = e.metaKey;
    var key = getKey(e.keyCode);
    var isToggle = key === "ctrl" || key === "shift" || key === "meta" || key === "alt";
    var param = {
      key: key,
      isToggle: isToggle,
      inputEvent: e,
      keyCode: e.keyCode,
      ctrlKey: e.ctrlKey,
      altKey: e.altKey,
      shiftKey: e.shiftKey,
      metaKey: e.metaKey
    };
    this.trigger(type, param);
    this.trigger(type + "." + key, param);
    var combi = getCombi(e, key);
    combi.length > 1 && this.trigger(type + "." + combi.join("."), param);
  };

  return KeyController;
}(EventEmitter);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (KeyController);

//# sourceMappingURL=keycon.esm.js.map


/***/ }),

/***/ "./.yarn/cache/moveable-npm-0.28.0-32d066096a-1fee85a8c7.zip/node_modules/moveable/dist/moveable.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EVENTS": () => (/* binding */ EVENTS),
/* harmony export */   "METHODS": () => (/* binding */ METHODS),
/* harmony export */   "PROPERTIES": () => (/* binding */ PROPERTIES),
/* harmony export */   "PROPS_MAP": () => (/* binding */ PROPS_MAP),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "getElementInfo": () => (/* binding */ getElementInfo),
/* harmony export */   "makeAble": () => (/* binding */ makeAble)
/* harmony export */ });
/* harmony import */ var framework_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/framework-utils-npm-1.1.0-37a54a069c-01b61ead17.zip/node_modules/framework-utils/dist/utils.esm.js");
/* harmony import */ var react_simple_compat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-simple-compat-npm-1.2.1-d35db08ba4-07a47e750f.zip/node_modules/react-simple-compat/dist/compat.esm.js");
/* harmony import */ var react_compat_moveable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/react-compat-moveable-virtual-81b7a42abb/0/cache/react-compat-moveable-npm-0.16.0-395b3c92e9-b20bd91698.zip/node_modules/react-compat-moveable/dist/moveable.esm.js");
/* harmony import */ var _daybrush_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/@daybrush-utils-npm-1.6.0-547486bf79-2579bc17e0.zip/node_modules/@daybrush/utils/dist/utils.esm.js");
/*
Copyright (c) 2019 Daybrush
name: moveable
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/moveable.git
version: 0.28.0
*/





/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

var InnerMoveable =
/*#__PURE__*/
function (_super) {
  __extends(InnerMoveable, _super);

  function InnerMoveable(props) {
    var _this = _super.call(this, props) || this;

    _this.state = {};
    _this.state = _this.props;
    return _this;
  }

  var __proto = InnerMoveable.prototype;

  __proto.render = function () {
    return (0,react_simple_compat__WEBPACK_IMPORTED_MODULE_0__.createPortal)((0,react_simple_compat__WEBPACK_IMPORTED_MODULE_0__.createElement)(react_compat_moveable__WEBPACK_IMPORTED_MODULE_1__["default"], __assign({
      ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_2__.ref)(this, "moveable")
    }, this.state)), this.state.parentElement);
  };

  return InnerMoveable;
}(react_simple_compat__WEBPACK_IMPORTED_MODULE_0__.Component);

var PROPERTIES = react_compat_moveable__WEBPACK_IMPORTED_MODULE_1__.MOVEABLE_PROPS;
var METHODS = react_compat_moveable__WEBPACK_IMPORTED_MODULE_1__.MOVEABLE_METHODS;
var EVENTS = react_compat_moveable__WEBPACK_IMPORTED_MODULE_1__.MOVEABLE_EVENTS;
var PROPS_MAP = react_compat_moveable__WEBPACK_IMPORTED_MODULE_1__.MOVEABLE_PROPS_MAP;

/*
Copyright (c) 2019 Daybrush
name: @scena/event-emitter
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/gesture.git
version: 1.0.3
*/

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign$1 = function () {
  __assign$1 = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign$1.apply(this, arguments);
};
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
}

/**
 * Implement EventEmitter on object or component.
 */

var EventEmitter =
/*#__PURE__*/
function () {
  function EventEmitter() {
    this._events = {};
  }
  /**
   * Add a listener to the registered event.
   * @param - Name of the event to be added
   * @param - listener function of the event to be added
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Add listener in "a" event
   * emitter.on("a", () => {
   * });
   * // Add listeners
   * emitter.on({
   *  a: () => {},
   *  b: () => {},
   * });
   */


  var __proto = EventEmitter.prototype;

  __proto.on = function (eventName, listener) {
    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isObject)(eventName)) {
      for (var name in eventName) {
        this.on(name, eventName[name]);
      }
    } else {
      this._addEvent(eventName, listener, {});
    }

    return this;
  };
  /**
   * Remove listeners registered in the event target.
   * @param - Name of the event to be removed
   * @param - listener function of the event to be removed
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Remove all listeners.
   * emitter.off();
   *
   * // Remove all listeners in "A" event.
   * emitter.off("a");
   *
   *
   * // Remove "listener" listener in "a" event.
   * emitter.off("a", listener);
   */


  __proto.off = function (eventName, listener) {
    if (!eventName) {
      this._events = {};
    } else if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isObject)(eventName)) {
      for (var name in eventName) {
        this.off(name);
      }
    } else if (!listener) {
      this._events[eventName] = [];
    } else {
      var events = this._events[eventName];

      if (events) {
        var index = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.findIndex)(events, function (e) {
          return e.listener === listener;
        });

        if (index > -1) {
          events.splice(index, 1);
        }
      }
    }

    return this;
  };
  /**
   * Add a disposable listener and Use promise to the registered event.
   * @param - Name of the event to be added
   * @param - disposable listener function of the event to be added
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Add a disposable listener in "a" event
   * emitter.once("a", () => {
   * });
   *
   * // Use Promise
   * emitter.once("a").then(e => {
   * });
   */


  __proto.once = function (eventName, listener) {
    var _this = this;

    if (listener) {
      this._addEvent(eventName, listener, {
        once: true
      });
    }

    return new Promise(function (resolve) {
      _this._addEvent(eventName, resolve, {
        once: true
      });
    });
  };
  /**
   * Fires an event to call listeners.
   * @param - Event name
   * @param - Event parameter
   * @return If false, stop the event.
   * @example
   *
   * import EventEmitter from "@scena/event-emitter";
   *
   *
   * const emitter = new EventEmitter();
   *
   * emitter.on("a", e => {
   * });
   *
   *
   * emitter.emit("a", {
   *   a: 1,
   * });
   */


  __proto.emit = function (eventName, param) {
    var _this = this;

    if (param === void 0) {
      param = {};
    }

    var events = this._events[eventName];

    if (!eventName || !events) {
      return true;
    }

    var isStop = false;
    param.eventType = eventName;

    param.stop = function () {
      isStop = true;
    };

    param.currentTarget = this;

    __spreadArrays(events).forEach(function (info) {
      info.listener(param);

      if (info.once) {
        _this.off(eventName, info.listener);
      }
    });

    return !isStop;
  };
  /**
   * Fires an event to call listeners.
   * @param - Event name
   * @param - Event parameter
   * @return If false, stop the event.
   * @example
   *
   * import EventEmitter from "@scena/event-emitter";
   *
   *
   * const emitter = new EventEmitter();
   *
   * emitter.on("a", e => {
   * });
   *
   *
   * emitter.emit("a", {
   *   a: 1,
   * });
   */

  /**
  * Fires an event to call listeners.
  * @param - Event name
  * @param - Event parameter
  * @return If false, stop the event.
  * @example
  *
  * import EventEmitter from "@scena/event-emitter";
  *
  *
  * const emitter = new EventEmitter();
  *
  * emitter.on("a", e => {
  * });
  *
  * // emit
  * emitter.trigger("a", {
  *   a: 1,
  * });
  */


  __proto.trigger = function (eventName, param) {
    if (param === void 0) {
      param = {};
    }

    return this.emit(eventName, param);
  };

  __proto._addEvent = function (eventName, listener, options) {
    var events = this._events;
    events[eventName] = events[eventName] || [];
    var listeners = events[eventName];
    listeners.push(__assign$1({
      listener: listener
    }, options));
  };

  return EventEmitter;
}();

/**
 * Moveable is Draggable! Resizable! Scalable! Rotatable!
 * @sort 1
 * @alias Moveable
 * @extends EventEmitter
 */

var MoveableManager =
/*#__PURE__*/
function (_super) {
  __extends(MoveableManager, _super);
  /**
   *
   */


  function MoveableManager(parentElement, options) {
    if (options === void 0) {
      options = {};
    }

    var _this = _super.call(this) || this;

    _this.tempElement = document.createElement("div");

    var nextOptions = __assign({}, options);

    var events = {};
    EVENTS.forEach(function (name) {
      events[(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.camelize)("on " + name)] = function (e) {
        return _this.trigger(name, e);
      };
    });
    (0,react_simple_compat__WEBPACK_IMPORTED_MODULE_0__.render)((0,react_simple_compat__WEBPACK_IMPORTED_MODULE_0__.createElement)(InnerMoveable, __assign({
      ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_2__.ref)(_this, "innerMoveable"),
      parentElement: parentElement
    }, nextOptions, events)), _this.tempElement);
    var target = nextOptions.target;

    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(target) && target.length > 1) {
      _this.updateRect();
    }

    return _this;
  }

  var __proto = MoveableManager.prototype;

  __proto.setState = function (state, callback) {
    this.innerMoveable.setState(state, callback);
  };

  __proto.destroy = function () {
    (0,react_simple_compat__WEBPACK_IMPORTED_MODULE_0__.render)(null, this.tempElement);
    this.off();
    this.tempElement = null;
    this.innerMoveable = null;
  };

  __proto.getMoveable = function () {
    return this.innerMoveable.moveable;
  };

  MoveableManager = __decorate([(0,framework_utils__WEBPACK_IMPORTED_MODULE_2__.Properties)(METHODS, function (prototype, property) {
    if (prototype[property]) {
      return;
    }

    prototype[property] = function () {
      var args = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }

      var self = this.getMoveable();

      if (!self || !self[property]) {
        return;
      }

      return self[property].apply(self, args);
    };
  }), (0,framework_utils__WEBPACK_IMPORTED_MODULE_2__.Properties)(PROPERTIES, function (prototype, property) {
    Object.defineProperty(prototype, property, {
      get: function () {
        return this.getMoveable().props[property];
      },
      set: function (value) {
        var _a;

        this.setState((_a = {}, _a[property] = value, _a));
      },
      enumerable: true,
      configurable: true
    });
  })], MoveableManager);
  return MoveableManager;
}(EventEmitter);

var Moveable =
/*#__PURE__*/
function (_super) {
  __extends(Moveable, _super);

  function Moveable() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  return Moveable;
}(MoveableManager);

function getElementInfo(target, container, rootContainer) {
  return (0,react_compat_moveable__WEBPACK_IMPORTED_MODULE_1__.getElementInfo)(target, container, rootContainer);
}
function makeAble(name, able) {
  return (0,react_compat_moveable__WEBPACK_IMPORTED_MODULE_1__.makeAble)(name, able);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Moveable);

//# sourceMappingURL=moveable.esm.js.map


/***/ }),

/***/ "./.yarn/cache/overlap-area-npm-1.0.0-ece5a4fc6a-37d82ea4ea.zip/node_modules/overlap-area/dist/overlap-area.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "convertLines": () => (/* binding */ convertLines),
/* harmony export */   "fitPoints": () => (/* binding */ fitPoints),
/* harmony export */   "getAreaSize": () => (/* binding */ getAreaSize),
/* harmony export */   "getIntersectionPoints": () => (/* binding */ getIntersectionPoints),
/* harmony export */   "getIntersectionPointsByConstants": () => (/* binding */ getIntersectionPointsByConstants),
/* harmony export */   "getLinearConstants": () => (/* binding */ getLinearConstants),
/* harmony export */   "getMinMaxs": () => (/* binding */ getMinMaxs),
/* harmony export */   "getOverlapPoints": () => (/* binding */ getOverlapPoints),
/* harmony export */   "getOverlapSize": () => (/* binding */ getOverlapSize),
/* harmony export */   "getPointsOnLines": () => (/* binding */ getPointsOnLines),
/* harmony export */   "isInside": () => (/* binding */ isInside)
/* harmony export */ });
/* harmony import */ var _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@daybrush-utils-npm-1.6.0-547486bf79-2579bc17e0.zip/node_modules/@daybrush/utils/dist/utils.esm.js");
/*
Copyright (c) 2020 Daybrush
name: overlap-area
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/overlap-area.git
version: 1.0.0
*/


/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
}

/**
 * @namespace OverlapArea
 */

/**
 * Gets the size of a shape (polygon) made of points.
 * @memberof OverlapArea
 */

function getAreaSize(points) {
  if (points.length < 3) {
    return 0;
  }

  return Math.abs((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.sum)(points.map(function (point, i) {
    var nextPoint = points[i + 1] || points[0];
    return point[0] * nextPoint[1] - nextPoint[0] * point[1];
  }))) / 2;
}
/**
 * Get points that fit the rect,
 * @memberof OverlapArea
 */

function fitPoints(points, rect) {
  var width = rect.width,
      height = rect.height,
      left = rect.left,
      top = rect.top;

  var _a = getMinMaxs(points),
      minX = _a.minX,
      minY = _a.minY,
      maxX = _a.maxX,
      maxY = _a.maxY;

  var ratioX = width / (maxX - minX);
  var ratioY = height / (maxY - minY);
  return points.map(function (point) {
    return [left + (point[0] - minX) * ratioX, top + (point[1] - minY) * ratioY];
  });
}
/**
 * Get the minimum and maximum points of the points.
 * @memberof OverlapArea
 */

function getMinMaxs(points) {
  var xs = points.map(function (point) {
    return point[0];
  });
  var ys = points.map(function (point) {
    return point[1];
  });
  return {
    minX: Math.min.apply(Math, xs),
    minY: Math.min.apply(Math, ys),
    maxX: Math.max.apply(Math, xs),
    maxY: Math.max.apply(Math, ys)
  };
}
/**
 * Whether the point is in shape
 * @param - point pos
 * @param - shape points
 * @param - whether to check except line
 * @memberof OverlapArea
 */

function isInside(pos, points, excludeLine) {
  var x = pos[0],
      y = pos[1];

  var _a = getMinMaxs(points),
      minX = _a.minX,
      minY = _a.minY,
      maxX = _a.maxX,
      maxY = _a.maxY;

  var xLine = [[minX, y], [maxX, y]];
  var yLine = [[x, minY], [x, maxY]];
  var xLinearConstants = getLinearConstants(xLine[0], xLine[1]);
  var yLinearConstants = getLinearConstants(yLine[0], yLine[1]);
  var lines = convertLines(points);
  var intersectionXPoints = [];
  var intersectionYPoints = [];
  lines.forEach(function (line) {
    var linearConstants = getLinearConstants(line[0], line[1]);
    var xPoints = getPointsOnLines(getIntersectionPointsByConstants(xLinearConstants, linearConstants), [xLine, line]);
    var yPoints = getPointsOnLines(getIntersectionPointsByConstants(yLinearConstants, linearConstants), [yLine, line]);

    if (xPoints.length === 1 ? line[0][1] !== y : true) {
      intersectionXPoints.push.apply(intersectionXPoints, xPoints);
    }

    if (yPoints.length === 1 ? line[0][0] !== x : true) {
      intersectionYPoints.push.apply(intersectionYPoints, yPoints);
    }

    if (!linearConstants[0]) {
      intersectionXPoints.push.apply(intersectionXPoints, xPoints);
    }

    if (!linearConstants[1]) {
      intersectionYPoints.push.apply(intersectionYPoints, yPoints);
    }
  });

  if (!excludeLine) {
    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.findIndex)(intersectionXPoints, function (p) {
      return p[0] === x;
    }) > -1 || (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.findIndex)(intersectionYPoints, function (p) {
      return p[1] === y;
    }) > -1) {
      return true;
    }
  }

  if (intersectionXPoints.filter(function (p) {
    return p[0] > x;
  }).length % 2 && intersectionYPoints.filter(function (p) {
    return p[1] > y;
  }).length % 2) {
    return true;
  }

  return false;
}
/**
 * Get the coefficient of the linear function. [a, b, c] (ax + by + c = 0)
 * @return [a, b, c]
 * @memberof OverlapArea
 */

function getLinearConstants(point1, point2) {
  var x1 = point1[0],
      y1 = point1[1];
  var x2 = point2[0],
      y2 = point2[1]; // ax + by + c = 0

  if (x1 === x2 && y1 === y2) {
    return [0, 0, 0];
  }

  if (x1 === x2) {
    // x = x1
    return [1, 0, -x1];
  } else if (y1 === y2) {
    // y = y1
    return [0, 1, -y1];
  } else {
    // x1 + a * y1 + b = 0
    // x2 + a * y2 + b = 0
    // (x1 -x2) + (y1 - y2) * a = 0
    // a = (x2 - x1) / (y1 - y2)
    // x1 + (x2 - x1) / (y1 - y2)
    var a_1 = (x2 - x1) / (y1 - y2);
    var b_1 = -x1 - a_1 * y1;
    return [1, a_1, b_1];
  }
}
/**
 * Get intersection points with linear functions.
 * @memberof OverlapArea
 */

function getIntersectionPointsByConstants(linearConstants1, linearConstants2) {
  var a1 = linearConstants1[0],
      b1 = linearConstants1[1],
      c1 = linearConstants1[2];
  var a2 = linearConstants2[0],
      b2 = linearConstants2[1],
      c2 = linearConstants2[2];
  var isZeroA = a1 === 0 && a2 === 0;
  var isZeroB = b1 === 0 && b2 === 0;

  if (isZeroA && isZeroB) {
    return [];
  } else if (isZeroA) {
    // b1 * y + c1 = 0
    // b2 * y + c2 = 0
    var y1 = -c1 / b1;
    var y2 = -c2 / b2;

    if (y1 !== y2) {
      return [];
    } else {
      return [[-Infinity, y1], [Infinity, y1]];
    }
  } else if (isZeroB) {
    // a1 * x + c1 = 0
    // a2 * x + c2 = 0
    var x1 = -c1 / a1;
    var x2 = -c2 / a2;

    if (x1 !== x2) {
      return [];
    } else {
      return [[x1, -Infinity], [x1, Infinity]];
    }
  } else if (a1 === 0) {
    // b1 * y + c1 = 0
    // y = - c1 / b1;
    // a2 * x + b2 * y + c2 = 0
    var y = -c1 / b1;
    var x = -(b2 * y + c2) / a2;
    return [[x, y]];
  } else if (a2 === 0) {
    // b2 * y + c2 = 0
    // y = - c2 / b2;
    // a1 * x + b1 * y + c1 = 0
    var y = -c2 / b2;
    var x = -(b1 * y + c1) / a1;
    return [[x, y]];
  } else if (b1 === 0) {
    // a1 * x + c1 = 0
    // x = - c1 / a1;
    // a2 * x + b2 * y + c2 = 0
    var x = -c1 / a1;
    var y = -(a2 * x + c2) / b2;
    return [[x, y]];
  } else if (b2 === 0) {
    // a2 * x + c2 = 0
    // x = - c2 / a2;
    // a1 * x + b1 * y + c1 = 0
    var x = -c2 / a2;
    var y = -(a1 * x + c1) / b1;
    return [[x, y]];
  } else {
    // a1 * x + b1 * y + c1 = 0
    // a2 * x + b2 * y + c2 = 0
    // b2 * a1 * x + b2 * b1 * y + b2 * c1 = 0
    // b1 * a2 * x + b1 * b2 * y + b1 * c2 = 0
    // (b2 * a1 - b1 * a2)  * x = (b1 * c2 - b2 * c1)
    var x = (b1 * c2 - b2 * c1) / (b2 * a1 - b1 * a2);
    var y = -(a1 * x + c1) / b1;
    return [[x, y]];
  }
}
/**
 * Get intersection points to the two lines.
 * @memberof OverlapArea
 */

function getIntersectionPoints(line1, line2, isLimit) {
  var points = getIntersectionPointsByConstants(getLinearConstants(line1[0], line1[1]), getLinearConstants(line2[0], line2[1]));

  if (isLimit) {
    return getPointsOnLines(points, [line1, line2]);
  }

  return points;
}
/**
 * Get the points on the lines (between two points).
 * @memberof OverlapArea
 */

function getPointsOnLines(points, lines) {
  var minMaxs = lines.map(function (line) {
    return [0, 1].map(function (order) {
      return [Math.min(line[0][order], line[1][order]), Math.max(line[0][order], line[1][order])];
    });
  });

  if (points.length === 2) {
    var _a = points[0],
        x = _a[0],
        y = _a[1];

    if (x === points[1][0]) {
      /// Math.max(minY1, minY2)
      var top = Math.max.apply(Math, minMaxs.map(function (minMax) {
        return minMax[1][0];
      })); /// Math.min(maxY1, miax2)

      var bottom = Math.min.apply(Math, minMaxs.map(function (minMax) {
        return minMax[1][1];
      }));

      if (top > bottom) {
        return [];
      }

      return [[x, top], [x, bottom]];
    } else if (y === points[1][1]) {
      /// Math.max(minY1, minY2)
      var left = Math.max.apply(Math, minMaxs.map(function (minMax) {
        return minMax[0][0];
      })); /// Math.min(maxY1, miax2)

      var right = Math.min.apply(Math, minMaxs.map(function (minMax) {
        return minMax[0][1];
      }));

      if (left > right) {
        return [];
      }

      return [[left, y], [right, y]];
    }
  }

  return points.filter(function (point) {
    return minMaxs.every(function (minMax) {
      return minMax[0][0] <= point[0] && point[0] <= minMax[0][1] && minMax[1][0] <= point[1] && point[1] <= minMax[1][1];
    });
  });
}
/**
* Convert two points into lines.
* @function
* @memberof OverlapArea
*/

function convertLines(points) {
  return __spreadArrays(points.slice(1), [points[0]]).map(function (point, i) {
    return [points[i], point];
  });
}
/**
* Get the points of the overlapped part of two shapes.
* @function
* @memberof OverlapArea
*/

function getOverlapPoints(points1, points2) {
  var targetPoints1 = points1.slice();
  var targetPoints2 = points2.slice();

  if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getShapeDirection)(targetPoints1) === -1) {
    targetPoints1.reverse();
  }

  if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getShapeDirection)(targetPoints2) === -1) {
    targetPoints2.reverse();
  }

  var lines1 = convertLines(targetPoints1);
  var lines2 = convertLines(targetPoints2);
  var linearConstantss1 = lines1.map(function (line1) {
    return getLinearConstants(line1[0], line1[1]);
  });
  var linearConstantss2 = lines2.map(function (line2) {
    return getLinearConstants(line2[0], line2[1]);
  });
  var overlapInfos = [];
  linearConstantss1.forEach(function (linearConstants1, i) {
    var line1 = lines1[i];
    var linePointInfos = [];
    linearConstantss2.forEach(function (linearConstants2, j) {
      var intersectionPoints = getIntersectionPointsByConstants(linearConstants1, linearConstants2);
      var points = getPointsOnLines(intersectionPoints, [line1, lines2[j]]);
      linePointInfos.push.apply(linePointInfos, points.map(function (pos) {
        return {
          index1: i,
          index2: j,
          pos: pos
        };
      }));
    });
    linePointInfos.sort(function (a, b) {
      return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getDist)(line1[0], a.pos) - (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getDist)(line1[0], b.pos);
    });
    overlapInfos.push.apply(overlapInfos, linePointInfos);

    if (isInside(line1[1], targetPoints2)) {
      overlapInfos.push({
        index1: i,
        index2: -1,
        pos: line1[1]
      });
    }
  });
  lines2.forEach(function (line2, i) {
    if (isInside(line2[1], targetPoints1)) {
      var isNext_1 = false;
      var index = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.findIndex)(overlapInfos, function (_a) {
        var index2 = _a.index2;

        if (index2 === i) {
          isNext_1 = true;
          return false;
        }

        if (isNext_1) {
          return true;
        }

        return false;
      });

      if (index === -1) {
        isNext_1 = false;
        index = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.findIndex)(overlapInfos, function (_a) {
          var index1 = _a.index1,
              index2 = _a.index2;

          if (index1 === -1 && index2 + 1 === i) {
            isNext_1 = true;
            return false;
          }

          if (isNext_1) {
            return true;
          }

          return false;
        });
      }

      if (index === -1) {
        overlapInfos.push({
          index1: -1,
          index2: i,
          pos: line2[1]
        });
      } else {
        overlapInfos.splice(index, 0, {
          index1: -1,
          index2: i,
          pos: line2[1]
        });
      }
    }
  }); // console.log(overlapInfos);

  var overlapPoints = overlapInfos.map(function (_a) {
    var pos = _a.pos;
    return pos;
  });
  var pointMap = {};
  return overlapPoints.filter(function (point) {
    var key = point[0] + "x" + point[1];

    if (pointMap[key]) {
      return false;
    }

    pointMap[key] = true;
    return true;
  });
}
/**
* Gets the size of the overlapped part of two shapes.
* @function
* @memberof OverlapArea
*/

function getOverlapSize(points1, points2) {
  var points = getOverlapPoints(points1, points2);
  return getAreaSize(points);
}


//# sourceMappingURL=overlap-area.esm.js.map


/***/ }),

/***/ "./.yarn/cache/react-compat-css-styled-npm-1.0.8-52211d26f8-7a8e51849e.zip/node_modules/react-compat-css-styled/dist/styled.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StyledElement": () => (/* binding */ StyledElement),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var css_styled__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/css-styled-virtual-9ef8f05de2/0/cache/css-styled-npm-1.0.0-5104a882d5-3f2f995938.zip/node_modules/css-styled/dist/styled.esm.js");
/* harmony import */ var react_simple_compat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-simple-compat-npm-1.2.1-d35db08ba4-07a47e750f.zip/node_modules/react-simple-compat/dist/compat.esm.js");
/* harmony import */ var framework_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/framework-utils-npm-1.1.0-37a54a069c-01b61ead17.zip/node_modules/framework-utils/dist/utils.esm.js");
/*
Copyright (c) Daybrush
name: react-compat-css-styled
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/css-styled.git
version: 1.0.8
*/




/*
Copyright (c) 2019 Daybrush
name: react-css-styled
license: MIT
author: Daybrush
repository: https://github.com/daybrush/css-styled/tree/master/packages/react-css-styled
version: 1.0.3
*/

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}

var StyledElement =
/*#__PURE__*/
function (_super) {
  __extends(StyledElement, _super);

  function StyledElement() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.injectResult = null;
    _this.tag = "div";
    return _this;
  }

  var __proto = StyledElement.prototype;

  __proto.render = function () {
    var _a = this.props,
        _b = _a.className,
        className = _b === void 0 ? "" : _b,
        cspNonce = _a.cspNonce,
        portalContainer = _a.portalContainer,
        attributes = __rest(_a, ["className", "cspNonce", "portalContainer"]);

    var cssId = this.injector.className;
    var Tag = this.tag;
    var portalAttributes = {};

    if ((react_simple_compat__WEBPACK_IMPORTED_MODULE_0__.version || "").indexOf("simple") > -1 && portalContainer) {
      portalAttributes = {
        portalContainer: portalContainer
      };
    }

    return (0,react_simple_compat__WEBPACK_IMPORTED_MODULE_0__.createElement)(Tag, __assign({
      "ref": (0,framework_utils__WEBPACK_IMPORTED_MODULE_1__.ref)(this, "element"),
      "data-styled-id": cssId,
      "className": className + " " + cssId
    }, portalAttributes, attributes));
  };

  __proto.componentDidMount = function () {
    this.injectResult = this.injector.inject(this.element, {
      nonce: this.props.cspNonce
    });
  };

  __proto.componentWillUnmount = function () {
    this.injectResult.destroy();
    this.injectResult = null;
  };

  __proto.getElement = function () {
    return this.element;
  };

  return StyledElement;
}(react_simple_compat__WEBPACK_IMPORTED_MODULE_0__.Component);

function styled(tag, css) {
  var injector = (0,css_styled__WEBPACK_IMPORTED_MODULE_2__["default"])(css);
  return (
    /*#__PURE__*/
    function (_super) {
      __extends(Styled, _super);

      function Styled() {
        var _this = _super !== null && _super.apply(this, arguments) || this;

        _this.injector = injector;
        _this.tag = tag;
        return _this;
      }

      return Styled;
    }(StyledElement)
  );
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (styled);



/***/ }),

/***/ "./.yarn/cache/react-simple-compat-npm-1.2.1-d35db08ba4-07a47e750f.zip/node_modules/react-simple-compat/dist/compat.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Component": () => (/* binding */ Component),
/* harmony export */   "PureComponent": () => (/* binding */ PureComponent),
/* harmony export */   "createElement": () => (/* binding */ createElement),
/* harmony export */   "createPortal": () => (/* binding */ createPortal),
/* harmony export */   "findDOMNode": () => (/* binding */ findDOMNode),
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
/* harmony import */ var _egjs_list_differ__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@egjs-list-differ-npm-1.0.0-f4b91781db-d1827d134d.zip/node_modules/@egjs/list-differ/dist/list-differ.esm.js");
/* harmony import */ var _daybrush_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/@daybrush-utils-npm-1.6.0-547486bf79-2579bc17e0.zip/node_modules/@daybrush/utils/dist/utils.esm.js");
/*
Copyright (c) Daybrush
name: react-simple-compat
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/react-simple-compat.git
version: 1.2.1
*/



/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
}

function isDiff(a, b) {
  if (a === b) {
    return false;
  }

  for (var i in a) {
    if (!(i in b)) {
      return true;
    }
  }

  for (var i in b) {
    if (a[i] !== b[i]) {
      return true;
    }
  }

  return false;
}

function diffObject(a, b) {
  var keys1 = Object.keys(a);
  var keys2 = Object.keys(b);
  var result = (0,_egjs_list_differ__WEBPACK_IMPORTED_MODULE_0__.diff)(keys1, keys2, function (key) {
    return key;
  });
  var added = {};
  var removed = {};
  var changed = {};
  result.added.forEach(function (index) {
    var name = keys2[index];
    added[name] = b[name];
  });
  result.removed.forEach(function (index) {
    var name = keys1[index];
    removed[name] = a[name];
  });
  result.maintained.forEach(function (_a) {
    var index = _a[0];
    var name = keys1[index];
    var values = [a[name], b[name]];

    if (a[name] !== b[name]) {
      changed[name] = values;
    }
  });
  return {
    added: added,
    removed: removed,
    changed: changed
  };
}

function executeHooks(hooks) {
  hooks.forEach(function (hook) {
    hook();
  });
}

function fillKeys(keys) {
  var index = 0;
  return keys.map(function (key) {
    return key == null ? "$compat" + ++index : "" + key;
  });
}

function createProvider(el, key, index, container) {
  if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.isString)(el) || (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.isNumber)(el)) {
    return new TextProvider("text_" + el, key, index, container, null, {});
  }

  var providerClass = typeof el.type === "string" ? ElementProvider : el.type.prototype.render ? ComponentProvider : FunctionProvider;
  return new providerClass(el.type, key, index, container, el.ref, el.props);
}

function flat(arr) {
  var arr2 = [];
  arr.forEach(function (el) {
    arr2 = arr2.concat((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.isArray)(el) ? flat(el) : el);
  });
  return arr2;
}

function getAttributes(props) {
  var className = props.className,
      otherProps = __rest(props, ["className"]);

  if (className != null) {
    otherProps.class = className;
  }

  delete otherProps.style;
  delete otherProps.children;
  return otherProps;
}

function fillProps(props, defaultProps) {
  if (!defaultProps) {
    return props;
  }

  for (var name in defaultProps) {
    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.isUndefined)(props[name])) {
      props[name] = defaultProps[name];
    }
  }

  return props;
}

function createElement(type, props) {
  var children = [];

  for (var _i = 2; _i < arguments.length; _i++) {
    children[_i - 2] = arguments[_i];
  }

  var _a = props || {},
      key = _a.key,
      ref = _a.ref,
      otherProps = __rest(_a, ["key", "ref"]);

  return {
    type: type,
    key: key,
    ref: ref,
    props: __assign(__assign({}, otherProps), {
      children: flat(children).filter(function (child) {
        return child != null && child !== false;
      })
    })
  };
}

var Provider =
/*#__PURE__*/
function () {
  function Provider(type, key, index, container, ref, props) {
    if (props === void 0) {
      props = {};
    }

    this.type = type;
    this.key = key;
    this.index = index;
    this.container = container;
    this.ref = ref;
    this.props = props;
    this._providers = [];
  }

  var __proto = Provider.prototype;

  __proto._should = function (nextProps, nextState) {
    return true;
  };

  __proto._update = function (hooks, nextElement, nextState, isForceUpdate) {
    if (this.base && !(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.isString)(nextElement) && !isForceUpdate && !this._should(nextElement.props, nextState)) {
      return false;
    }

    this.original = nextElement;

    this._setState(nextState); // render


    var prevProps = this.props;

    if (!(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.isString)(nextElement)) {
      this.props = nextElement.props;
      this.ref = nextElement.ref;
    }

    this._render(hooks, this.base ? prevProps : {}, nextState);

    return true;
  };

  __proto._mounted = function () {
    var ref = this.ref;
    ref && ref(this.base);
  };

  __proto._setState = function (nextstate) {
    return;
  };

  __proto._updated = function () {
    var ref = this.ref;
    ref && ref(this.base);
  };

  __proto._destroy = function () {
    var ref = this.ref;
    ref && ref(null);
  };

  return Provider;
}();

function diffAttributes(attrs1, attrs2, el) {
  var _a = diffObject(attrs1, attrs2),
      added = _a.added,
      removed = _a.removed,
      changed = _a.changed;

  for (var name in added) {
    el.setAttribute(name, added[name]);
  }

  for (var name in changed) {
    el.setAttribute(name, changed[name][1]);
  }

  for (var name in removed) {
    el.removeAttribute(name);
  }
}

function diffEvents(events1, events2, provier) {
  var _a = diffObject(events1, events2),
      added = _a.added,
      removed = _a.removed,
      changed = _a.changed;

  for (var name in removed) {
    provier.removeEventListener(name);
  }

  for (var name in added) {
    provier.addEventListener(name, added[name]);
  }

  for (var name in changed) {
    provier.removeEventListener(name);
    provier.addEventListener(name, changed[name][1]);
  }

  for (var name in removed) {
    provier.removeEventListener(name);
  }
}

function diffStyle(style1, style2, el) {
  var style = el.style;

  var _a = diffObject(style1, style2),
      added = _a.added,
      removed = _a.removed,
      changed = _a.changed;

  for (var beforeName in added) {
    var name = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.decamelize)(beforeName, "-");

    if (style.setProperty) {
      style.setProperty(name, added[beforeName]);
    } else {
      style[name] = added[beforeName];
    }
  }

  for (var beforeName in changed) {
    var name = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.decamelize)(beforeName, "-");

    if (style.setProperty) {
      style.setProperty(name, changed[beforeName][1]);
    } else {
      style[name] = changed[beforeName][1];
    }
  }

  for (var beforeName in removed) {
    var name = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.decamelize)(beforeName, "-");

    if (style.removeProperty) {
      style.removeProperty(name);
    } else {
      style[name] = "";
    }
  }
}

function splitProps(props) {
  var attributes = {};
  var events = {};

  for (var name in props) {
    if (name.indexOf("on") === 0) {
      events[name.replace("on", "").toLowerCase()] = props[name];
    } else {
      attributes[name] = props[name];
    }
  }

  return {
    attributes: attributes,
    events: events
  };
}

var TextProvider =
/*#__PURE__*/
function (_super) {
  __extends(TextProvider, _super);

  function TextProvider() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  var __proto = TextProvider.prototype;

  __proto._render = function (hooks) {
    var _this = this;

    var isMount = !this.base;

    if (isMount) {
      this.base = document.createTextNode(this.type.replace("text_", ""));
    }

    hooks.push(function () {
      if (isMount) {
        _this._mounted();
      } else {
        _this._updated();
      }
    });
    return true;
  };

  __proto._unmount = function () {
    this.base.parentNode.removeChild(this.base);
  };

  return TextProvider;
}(Provider);

var ElementProvider =
/*#__PURE__*/
function (_super) {
  __extends(ElementProvider, _super);

  function ElementProvider() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.events = {};
    _this._isSVG = false;
    return _this;
  }

  var __proto = ElementProvider.prototype;

  __proto.addEventListener = function (name, callback) {
    var events = this.events;

    events[name] = function (e) {
      e.nativeEvent = e;
      callback(e);
    };

    this.base.addEventListener(name, events[name]);
  };

  __proto.removeEventListener = function (name) {
    var events = this.events;
    this.base.removeEventListener(name, events[name]);
    delete events[name];
  };

  __proto._should = function (nextProps) {
    return isDiff(this.props, nextProps);
  };

  __proto._render = function (hooks, prevProps) {
    var _this = this;

    var isMount = !this.base;

    if (isMount) {
      var isSVG = this._hasSVG();

      this._isSVG = isSVG;
      var element = this.props.portalContainer;

      if (!element) {
        var type = this.type;

        if (isSVG) {
          element = document.createElementNS("http://www.w3.org/2000/svg", type);
        } else {
          element = document.createElement(type);
        }
      }

      this.base = element;
    }

    renderProviders(this, this._providers, this.props.children, hooks, null);
    var base = this.base;

    var _a = splitProps(prevProps),
        prevAttributes = _a.attributes,
        prevEvents = _a.events;

    var _b = splitProps(this.props),
        nextAttributes = _b.attributes,
        nextEvents = _b.events;

    diffAttributes(getAttributes(prevAttributes), getAttributes(nextAttributes), base);
    diffEvents(prevEvents, nextEvents, this);
    diffStyle(prevProps.style || {}, this.props.style || {}, base);
    hooks.push(function () {
      if (isMount) {
        _this._mounted();
      } else {
        _this._updated();
      }
    });
    return true;
  };

  __proto._unmount = function () {
    var events = this.events;
    var base = this.base;

    for (var name in events) {
      base.removeEventListener(name, events[name]);
    }

    this._providers.forEach(function (provider) {
      provider._unmount();
    });

    this.events = {};

    if (!this.props.portalContainer) {
      base.parentNode.removeChild(base);
    }
  };

  __proto._hasSVG = function () {
    if (this._isSVG || this.type === "svg") {
      return true;
    }

    var containerNode = findContainerNode(this.container);
    return containerNode && "ownerSVGElement" in containerNode;
  };

  return ElementProvider;
}(Provider);

function findContainerNode(provider) {
  if (!provider) {
    return null;
  }

  var base = provider.base;

  if (base instanceof Node) {
    return base;
  }

  return findContainerNode(provider.container);
}

function findDOMNode(comp) {
  if (!comp) {
    return null;
  }

  if (comp instanceof Node) {
    return comp;
  }

  var providers = comp.$_provider._providers;

  if (!providers.length) {
    return null;
  }

  return findDOMNode(providers[0].base);
}

var FunctionProvider =
/*#__PURE__*/
function (_super) {
  __extends(FunctionProvider, _super);

  function FunctionProvider() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  var __proto = FunctionProvider.prototype;

  __proto._render = function (hooks) {
    var template = this.type(this.props);
    renderProviders(this, this._providers, template ? [template] : [], hooks);
    return true;
  };

  __proto._unmount = function () {
    this._providers.forEach(function (provider) {
      provider._unmount();
    });
  };

  return FunctionProvider;
}(Provider);

var ContainerProvider =
/*#__PURE__*/
function (_super) {
  __extends(ContainerProvider, _super);

  function ContainerProvider(base) {
    var _this = _super.call(this, "container", "container", 0, null) || this;

    _this.base = base;
    return _this;
  }

  var __proto = ContainerProvider.prototype;

  __proto._render = function () {
    return true;
  };

  __proto._unmount = function () {
    return;
  };

  return ContainerProvider;
}(Provider);

var ComponentProvider =
/*#__PURE__*/
function (_super) {
  __extends(ComponentProvider, _super);

  function ComponentProvider(type, key, index, container, ref, props) {
    if (props === void 0) {
      props = {};
    }

    return _super.call(this, type, key, index, container, ref, fillProps(props, type.defaultProps)) || this;
  }

  var __proto = ComponentProvider.prototype;

  __proto._should = function (nextProps, nextState) {
    return this.base.shouldComponentUpdate(fillProps(nextProps, this.type.defaultProps), nextState || this.base.state);
  };

  __proto._render = function (hooks, prevProps, nextState) {
    var _this = this;

    this.props = fillProps(this.props, this.type.defaultProps);
    var isMount = !this.base;

    if (isMount) {
      this.base = new this.type(this.props);
      this.base.$_provider = this;
    } else {
      this.base.props = this.props;
    }

    var base = this.base;
    var prevState = base.state;
    var template = base.render();

    if (template && template.props && !template.props.children.length) {
      template.props.children = this.props.children;
    }

    renderProviders(this, this._providers, template ? [template] : [], hooks, nextState, null);
    hooks.push(function () {
      if (isMount) {
        _this._mounted();

        base.componentDidMount();
      } else {
        _this._updated();

        base.componentDidUpdate(prevProps, prevState);
      }
    });
  };

  __proto._setState = function (nextState) {
    if (!nextState) {
      return;
    }

    var base = this.base;
    base.state = nextState;
  };

  __proto._unmount = function () {
    this._providers.forEach(function (provider) {
      provider._unmount();
    });

    clearTimeout(this.base.$_timer);
    this.base.componentWillUnmount();
  };

  return ComponentProvider;
}(Provider);

var Component =
/*#__PURE__*/
function () {
  function Component(props) {
    if (props === void 0) {
      props = {};
    }

    this.props = props;
    this.state = {};
    this.$_timer = 0;
    this.$_state = {};
  }

  var __proto = Component.prototype;

  __proto.shouldComponentUpdate = function (props, state) {
    return true;
  };

  __proto.render = function () {
    return null;
  };

  __proto.setState = function (state, callback, isForceUpdate) {
    var _this = this;

    if (!this.$_timer) {
      this.$_state = {};
    }

    clearTimeout(this.$_timer);
    this.$_timer = 0;
    this.$_state = __assign(__assign({}, this.$_state), state);

    if (!isForceUpdate) {
      this.$_timer = setTimeout(function () {
        _this.$_timer = 0;

        _this.$_setState(callback, isForceUpdate);
      });
    } else {
      this.$_setState(callback, isForceUpdate);
    }

    return;
  };

  __proto.forceUpdate = function (callback) {
    this.setState({}, callback, true);
  };

  __proto.componentDidMount = function () {};

  __proto.componentDidUpdate = function (prevProps, prevState) {};

  __proto.componentWillUnmount = function () {};

  __proto.$_setState = function (callback, isForceUpdate) {
    var hooks = [];
    var provider = this.$_provider;
    var isUpdate = renderProviders(provider.container, [provider], [provider.original], hooks, __assign(__assign({}, this.state), this.$_state), isForceUpdate);

    if (isUpdate) {
      if (callback) {
        hooks.push(callback);
      }

      executeHooks(hooks);
    }
  };

  return Component;
}();

var PureComponent =
/*#__PURE__*/
function (_super) {
  __extends(PureComponent, _super);

  function PureComponent() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  var __proto = PureComponent.prototype;

  __proto.shouldComponentUpdate = function (props, state) {
    return isDiff(this.props, props) || isDiff(this.state, state);
  };

  return PureComponent;
}(Component);

var _Portal =
/*#__PURE__*/
function (_super) {
  __extends(_Portal, _super);

  function _Portal() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  var __proto = _Portal.prototype;

  __proto.componentDidMount = function () {
    var _a = this.props,
        element = _a.element,
        container = _a.container;
    this._portalProvider = new ContainerProvider(container);
    renderProvider(element, container, this._portalProvider);
  };

  __proto.componentDidUpdate = function () {
    var _a = this.props,
        element = _a.element,
        container = _a.container;
    renderProvider(element, container, this._portalProvider);
  };

  __proto.componentWillUnmount = function () {
    var container = this.props.container;
    renderProvider(null, container, this._portalProvider);
    this._portalProvider = null;
  };

  return _Portal;
}(PureComponent);

function updateProvider(provider, children, nextState) {
  var hooks = [];
  renderProviders(provider, provider._providers, children, hooks, nextState);
  executeHooks(hooks);
}

function getNextSibiling(provider, childProvider) {
  var childProviders = provider._providers;
  var length = childProviders.length;

  for (var i = childProvider.index + 1; i < length; ++i) {
    var el = findDOMNode(childProviders[i].base);

    if (el) {
      return el;
    }
  }

  return null;
}

function diffProviders(containerProvider, providers, children) {
  var childrenKeys = children.map(function (p) {
    return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.isString)(p) ? null : p.key;
  });
  var keys1 = fillKeys(providers.map(function (p) {
    return p.key;
  }));
  var keys2 = fillKeys(childrenKeys);
  var result = (0,_egjs_list_differ__WEBPACK_IMPORTED_MODULE_0__.diff)(keys1, keys2, function (key) {
    return key;
  });
  result.removed.forEach(function (index) {
    providers.splice(index, 1)[0]._unmount();
  });
  result.ordered.forEach(function (_a) {
    var from = _a[0],
        to = _a[1];
    var childrenProvider = providers.splice(from, 1)[0];
    providers.splice(to, 0, childrenProvider);
    var el = findDOMNode(childrenProvider.base);
    var next = findDOMNode(providers[to + 1] && providers[to + 1].base);

    if (el) {
      el.parentNode.insertBefore(el, next);
    }
  });
  result.added.forEach(function (index) {
    providers.splice(index, 0, createProvider(children[index], childrenKeys[index], index, containerProvider));
  });
  var changed = result.maintained.filter(function (_a) {
    var _ = _a[0],
        to = _a[1];
    var el = children[to];
    var childProvider = providers[to];
    var type = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.isString)(el) ? "text_" + el : el.type;

    if (type !== childProvider.type) {
      childProvider._unmount();

      providers.splice(to, 1, createProvider(el, childrenKeys[to], to, containerProvider));
      return true;
    }

    childProvider.index = to;
    return false;
  });
  return __spreadArrays(result.added, changed.map(function (_a) {
    var _ = _a[0],
        to = _a[1];
    return to;
  }));
}

function renderProviders(containerProvider, providers, children, updatedHooks, nextState, isForceUpdate) {
  var result = diffProviders(containerProvider, providers, children);
  var updated = providers.filter(function (childProvider, i) {
    return childProvider._update(updatedHooks, children[i], nextState, isForceUpdate);
  });
  var containerNode = findContainerNode(containerProvider);

  if (containerNode) {
    result.reverse().forEach(function (index) {
      var childProvider = providers[index];
      var el = findDOMNode(childProvider.base);

      if (!el) {
        return;
      }

      if (containerNode !== el && !el.parentNode) {
        var nextElement = getNextSibiling(containerProvider, childProvider);
        containerNode.insertBefore(el, nextElement);
      }
    });
  }

  return updated.length > 0;
}

function renderProvider(element, container, provider) {
  if (provider === void 0) {
    provider = container.__REACT_COMPAT__;
  }

  var isProvider = !!provider;

  if (!provider) {
    provider = new ContainerProvider(container);
  }

  updateProvider(provider, element ? [element] : []);

  if (!isProvider) {
    container.__REACT_COMPAT__ = provider;
  }

  return provider;
}

function render(element, container, callback) {
  var provider = container.__REACT_COMPAT__;

  if (element && !provider) {
    container.innerHTML = "";
  }

  renderProvider(element, container, provider);
  callback && callback();
}
function createPortal(el, container) {
  return createElement(_Portal, {
    element: el,
    container: container
  });
}
var version = "simple-1.1.0";


//# sourceMappingURL=compat.esm.js.map


/***/ }),

/***/ "./.yarn/cache/selecto-npm-1.15.0-eb84959df5-ae19513c77.zip/node_modules/selecto/dist/selecto.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CLASS_NAME": () => (/* binding */ CLASS_NAME),
/* harmony export */   "EVENTS": () => (/* binding */ EVENTS),
/* harmony export */   "METHODS": () => (/* binding */ METHODS),
/* harmony export */   "OPTIONS": () => (/* binding */ OPTIONS),
/* harmony export */   "OPTION_TYPES": () => (/* binding */ OPTION_TYPES),
/* harmony export */   "PROPERTIES": () => (/* binding */ PROPERTIES),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _scena_event_emitter__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./.yarn/cache/@scena-event-emitter-npm-1.0.5-7ebf361d17-400e0f6ab8.zip/node_modules/@scena/event-emitter/dist/event-emitter.esm.js");
/* harmony import */ var gesto__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/cache/gesto-npm-1.7.0-7d5440000b-f2a66bcf0f.zip/node_modules/gesto/dist/gesto.esm.js");
/* harmony import */ var framework_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./.yarn/cache/framework-utils-npm-1.1.0-37a54a069c-01b61ead17.zip/node_modules/framework-utils/dist/utils.esm.js");
/* harmony import */ var _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@daybrush-utils-npm-1.6.0-547486bf79-2579bc17e0.zip/node_modules/@daybrush/utils/dist/utils.esm.js");
/* harmony import */ var _egjs_children_differ__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/@egjs-children-differ-npm-1.0.1-37f45ddf97-087f286822.zip/node_modules/@egjs/children-differ/dist/children-differ.esm.js");
/* harmony import */ var _scena_dragscroll__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/@scena-dragscroll-npm-1.1.1-8fe60775f9-aacb335870.zip/node_modules/@scena/dragscroll/dist/dragscroll.esm.js");
/* harmony import */ var keycon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/keycon-npm-1.1.2-47bb5048df-7be74aaf83.zip/node_modules/keycon/dist/keycon.esm.js");
/* harmony import */ var overlap_area__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/overlap-area-npm-1.0.0-ece5a4fc6a-37d82ea4ea.zip/node_modules/overlap-area/dist/overlap-area.esm.js");
/* harmony import */ var css_to_mat__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/css-to-mat-npm-1.0.3-8a69ed71de-a3fc98bfad.zip/node_modules/css-to-mat/dist/css-to-mat.esm.js");
/* harmony import */ var css_styled__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/css-styled-virtual-9ef8f05de2/0/cache/css-styled-npm-1.0.0-5104a882d5-3f2f995938.zip/node_modules/css-styled/dist/styled.esm.js");
/*
Copyright (c) 2020 Daybrush
name: selecto
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/selecto.git
version: 1.15.0
*/











/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
}

function getClient(e) {
  if ("touches" in e) {
    var touch = e.touches[0] || e.changedTouches[0];
    return {
      clientX: touch.clientX,
      clientY: touch.clientY
    };
  } else {
    return {
      clientX: e.clientX,
      clientY: e.clientY
    };
  }
}
function createElement(jsx, prevTarget, container) {
  var tag = jsx.tag,
      children = jsx.children,
      attributes = jsx.attributes,
      className = jsx.className,
      style = jsx.style;
  var el = prevTarget || document.createElement(tag);

  for (var name in attributes) {
    el.setAttribute(name, attributes[name]);
  }

  var elChildren = el.children;
  children.forEach(function (child, i) {
    createElement(child, elChildren[i], el);
  });

  if (className) {
    className.split(" ").forEach(function (name) {
      if (!(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.hasClass)(el, name)) {
        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addClass)(el, name);
      }
    });
  }

  if (style) {
    var elStyle = el.style;

    for (var name in style) {
      elStyle[name] = style[name];
    }
  }

  if (!prevTarget && container) {
    container.appendChild(el);
  }

  return el;
}
function h(tag, attrs) {
  var children = [];

  for (var _i = 2; _i < arguments.length; _i++) {
    children[_i - 2] = arguments[_i];
  }

  var _a = attrs || {},
      _b = _a.className,
      className = _b === void 0 ? "" : _b,
      _c = _a.style,
      style = _c === void 0 ? {} : _c,
      attributes = __rest(_a, ["className", "style"]);

  return {
    tag: tag,
    className: className,
    style: style,
    attributes: attributes,
    children: children
  };
}
function diffValue(prev, cur, func) {
  if (prev !== cur) {
    func(prev, cur);
  }
}
function getRect(e, ratio, boundArea) {
  var _a;

  if (boundArea === void 0) {
    boundArea = e.datas.boundArea;
  }

  var _b = e.distX,
      distX = _b === void 0 ? 0 : _b,
      _c = e.distY,
      distY = _c === void 0 ? 0 : _c;
  var _d = e.datas,
      startX = _d.startX,
      startY = _d.startY;

  if (ratio > 0) {
    var nextHeight = Math.sqrt((distX * distX + distY * distY) / (1 + ratio * ratio));
    var nextWidth = ratio * nextHeight;
    distX = (distX >= 0 ? 1 : -1) * nextWidth;
    distY = (distY >= 0 ? 1 : -1) * nextHeight;
  }

  var width = Math.abs(distX);
  var height = Math.abs(distY);
  var maxWidth = distX < 0 ? startX - boundArea.left : boundArea.right - startX;
  var maxHeight = distY < 0 ? startY - boundArea.top : boundArea.bottom - startY;
  _a = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.calculateBoundSize)([width, height], [0, 0], [maxWidth, maxHeight], !!ratio), width = _a[0], height = _a[1];
  distX = (distX >= 0 ? 1 : -1) * width;
  distY = (distY >= 0 ? 1 : -1) * height;
  var tx = Math.min(0, distX);
  var ty = Math.min(0, distY);
  var left = startX + tx;
  var top = startY + ty;
  return {
    left: left,
    top: top,
    right: left + width,
    bottom: top + height,
    width: width,
    height: height
  };
}
function getDefaultElementRect(el) {
  var rect = el.getBoundingClientRect();
  var left = rect.left,
      top = rect.top,
      width = rect.width,
      height = rect.height;
  return {
    pos1: [left, top],
    pos2: [left + width, top],
    pos3: [left, top + height],
    pos4: [left + width, top + height]
  };
}
function passTargets(beforeTargets, afterTargets) {
  var _a = (0,_egjs_children_differ__WEBPACK_IMPORTED_MODULE_1__.diff)(beforeTargets, afterTargets),
      list = _a.list,
      prevList = _a.prevList,
      added = _a.added,
      removed = _a.removed;

  return added.map(function (index) {
    return list[index];
  }).concat(removed.map(function (index) {
    return prevList[index];
  }));
}

var injector = (0,css_styled__WEBPACK_IMPORTED_MODULE_2__["default"])("\n:host {\n    position: fixed;\n    display: none;\n    border: 1px solid #4af;\n    background: rgba(68, 170, 255, 0.5);\n    z-index: 100;\n}\n:host {\n    position: absolute;\n}\n");
/**
 * @memberof Selecto
 */

var CLASS_NAME = "selecto-selection " + injector.className;
var PROPERTIES = ["boundContainer", "selectableTargets", "selectByClick", "selectFromInside", "continueSelect", "toggleContinueSelect", "keyContainer", "hitRate", "scrollOptions", "checkInput", "preventDefault", "ratio", "getElementRect", "preventDragFromInside", "rootContainer", "dragCondition", "clickBySelectEnd"];
/**
 * @memberof Selecto
 */

var OPTIONS = __spreadArrays([// ignore target, container,
"dragContainer", "cspNonce"], PROPERTIES);
var OPTION_TYPES = {
  boundContainer: null,
  portalContainer: null,
  container: null,
  dragContainer: null,
  selectableTargets: Array,
  selectByClick: Boolean,
  selectFromInside: Boolean,
  continueSelect: Boolean,
  toggleContinueSelect: Array,
  keyContainer: null,
  hitRate: Number,
  scrollOptions: Object,
  checkInput: Boolean,
  preventDefault: Boolean,
  cspNonce: String,
  ratio: Number,
  getElementRect: Function,
  preventDragFromInside: Boolean,
  rootContainer: Object,
  dragCondition: Function,
  clickBySelectEnd: Boolean
};
/**
 * @memberof Selecto
 */

var EVENTS = ["dragStart", "drag", "dragEnd", "selectStart", "select", "selectEnd", "keydown", "keyup", "scroll"];
/**
 * @memberof Selecto
 */

var METHODS = ["clickTarget", "getSelectableElements", "setSelectedTargets", "getElementPoints", "getSelectedTargets", "findSelectableTargets", "triggerDragStart", "checkScroll"];

/**
 * Selecto.js is a component that allows you to select elements in the drag area using the mouse or touch.
 * @sort 1
 * @extends EventEmitter
 */

var Selecto =
/*#__PURE__*/
function (_super) {
  __extends(Selecto, _super);
  /**
   *
   */


  function Selecto(options) {
    if (options === void 0) {
      options = {};
    }

    var _this = _super.call(this) || this;

    _this.selectedTargets = [];
    _this.dragScroll = new _scena_dragscroll__WEBPACK_IMPORTED_MODULE_3__["default"]();

    _this._onDragStart = function (e, clickedTarget) {
      var datas = e.datas,
          clientX = e.clientX,
          clientY = e.clientY,
          inputEvent = e.inputEvent;
      var _a = _this.options,
          continueSelect = _a.continueSelect,
          selectFromInside = _a.selectFromInside,
          selectByClick = _a.selectByClick,
          rootContainer = _a.rootContainer,
          boundContainer = _a.boundContainer,
          _b = _a.preventDragFromInside,
          preventDragFromInside = _b === void 0 ? true : _b,
          clickBySelectEnd = _a.clickBySelectEnd,
          dragCondition = _a.dragCondition;

      if (dragCondition && !dragCondition(e)) {
        e.stop();
        return;
      }

      _this.findSelectableTargets(datas);

      datas.startSelectedTargets = _this.selectedTargets;
      datas.scaleMatrix = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.createMatrix)();
      datas.containerX = 0;
      datas.containerY = 0;
      var boundArea = {
        left: -Infinity,
        top: -Infinity,
        right: Infinity,
        bottom: Infinity
      };

      if (rootContainer) {
        var containerRect = _this.container.getBoundingClientRect();

        datas.containerX = containerRect.left;
        datas.containerY = containerRect.top;
        datas.scaleMatrix = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.getDistElementMatrix)(_this.container, rootContainer);
      }

      if (boundContainer) {
        var boundInfo = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(boundContainer) && "element" in boundContainer ? __assign({
          left: true,
          top: true,
          bottom: true,
          right: true
        }, boundContainer) : {
          element: boundContainer,
          left: true,
          top: true,
          bottom: true,
          right: true
        };
        var boundElement = boundInfo.element;
        var rectElement = void 0;

        if (boundElement) {
          if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isString)(boundElement)) {
            rectElement = document.querySelector(boundElement);
          } else if (boundElement === true) {
            rectElement = _this.container;
          } else {
            rectElement = boundElement;
          }

          var rect = rectElement.getBoundingClientRect();

          if (boundInfo.left) {
            boundArea.left = rect.left;
          }

          if (boundInfo.top) {
            boundArea.top = rect.top;
          }

          if (boundInfo.right) {
            boundArea.right = rect.right;
          }

          if (boundInfo.bottom) {
            boundArea.bottom = rect.bottom;
          }
        }
      }

      datas.boundArea = boundArea;
      var hitRect = {
        left: clientX,
        top: clientY,
        right: clientX,
        bottom: clientY,
        width: 0,
        height: 0
      };
      var firstPassedTargets = [];

      if (selectByClick && !clickBySelectEnd) {
        var pointTarget = _this._findElement(clickedTarget || document.elementFromPoint(clientX, clientY), datas.selectableTargets);

        firstPassedTargets = pointTarget ? [pointTarget] : [];
      }

      var hasInsideTargets = firstPassedTargets.length > 0;
      var isPreventSelect = !selectFromInside && hasInsideTargets; // prevent drag from inside when selectByClick is false

      if (isPreventSelect && !selectByClick) {
        e.stop();
        return false;
      }

      var type = inputEvent.type;
      var isTrusted = type === "mousedown" || type === "touchstart";
      /**
       * When the drag starts (triggers on mousedown or touchstart), the dragStart event is called.
       * Call the stop () function if you have a specific element or don't want to raise a select
       * @memberof Selecto
       * @event dragStart
       * @param {OnDragStart} - Parameters for the dragStart event
       * @example
       * import Selecto from "selecto";
       *
       * const selecto = new Selecto({
       *   container: document.body,
       *   selectByClick: true,
       *   selectFromInside: false,
       * });
       *
       * selecto.on("dragStart", e => {
       *   if (e.inputEvent.target.tagName === "SPAN") {
       *     e.stop();
       *   }
       * }).on("select", e => {
       *   e.added.forEach(el => {
       *     el.classList.add("selected");
       *   });
       *   e.removed.forEach(el => {
       *     el.classList.remove("selected");
       *   });
       * });
       */

      var result = !e.isClick && isTrusted ? _this.emit("dragStart", __assign({}, e)) : true;

      if (!result) {
        e.stop();
        return false;
      }

      if (!continueSelect) {
        datas.startPassedTargets = [];
      } else {
        firstPassedTargets = passTargets(_this.selectedTargets, firstPassedTargets);
        datas.startPassedTargets = _this.selectedTargets;
      }

      _this.select(_this.selectedTargets, firstPassedTargets, hitRect, inputEvent, true);

      datas.startX = clientX;
      datas.startY = clientY;
      datas.selectFlag = false;
      datas.preventDragFromInside = false;
      var offsetPos = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.calculateMatrixDist)(datas.scaleMatrix, [clientX - datas.containerX, clientY - datas.containerY]);
      datas.boundsArea = _this.target.style.cssText += "position: " + (rootContainer ? "absolute" : "fixed") + ";" + "left:0px;top:0px;" + ("transform: translate(" + offsetPos[0] + "px, " + offsetPos[1] + "px)");

      if (isPreventSelect && selectByClick && !clickBySelectEnd) {
        inputEvent.preventDefault(); // prevent drag from inside when selectByClick is true and force call `selectEnd`

        if (preventDragFromInside) {
          _this.selectEnd(datas.startSelectedTargets, datas.startPassedTargets, hitRect, e);

          datas.preventDragFromInside = true;
        }
      } else {
        datas.selectFlag = true;

        if (type === "touchstart") {
          inputEvent.preventDefault();
        }

        var scrollOptions = _this.options.scrollOptions;

        if (scrollOptions && scrollOptions.container) {
          _this.dragScroll.dragStart(e, scrollOptions);
        }

        if (clickBySelectEnd) {
          datas.selectFlag = false;
          e.preventDrag();
        }
      }

      return true;
    };

    _this._onDrag = function (e) {
      var _a;

      if (e.datas.selectFlag) {
        var scrollOptions = _this.scrollOptions; // If it is a scrolling position, pass drag

        if (((_a = scrollOptions) === null || _a === void 0 ? void 0 : _a.container) && _this.dragScroll.drag(e, scrollOptions)) {
          return;
        }
      }

      _this._checkSelected(e);
    };

    _this._onDragEnd = function (e) {
      var datas = e.datas,
          inputEvent = e.inputEvent;
      var rect = getRect(e, _this.options.ratio);
      var selectFlag = datas.selectFlag;
      /**
       * When the drag ends (triggers on mouseup or touchend after drag), the dragEnd event is called.
       * @memberof Selecto
       * @event dragEnd
       * @param {_OnDragEnd} - Parameters for the dragEnd event
       */

      if (inputEvent && !e.isClick) {
        _this.emit("dragEnd", __assign(__assign({
          isDouble: !!e.isDouble,
          isDrag: false,
          isSelect: selectFlag
        }, e), {
          isClick: !!e.isClick,
          rect: rect
        }));
      }

      _this.target.style.cssText += "display: none;";

      if (selectFlag) {
        datas.selectFlag = false;

        _this.dragScroll.dragEnd();
      } else if (_this.selectByClick && _this.clickBySelectEnd) {
        // only clickBySelectEnd
        var pointTarget = _this._findElement(document.elementFromPoint(e.clientX, e.clientY), datas.selectableTargets);

        _this.select(_this.selectedTargets, pointTarget ? [pointTarget] : [], rect, inputEvent);
      }

      if (!datas.preventDragFromInside) {
        _this.selectEnd(datas.startSelectedTargets, datas.startPassedTargets, rect, e);
      }
    };

    _this._onKeyDown = function (e) {
      if (!_this._sameCombiKey(e)) {
        return;
      }

      _this.continueSelect = true;
      /**
       * When you keydown the key you specified in toggleContinueSelect, the keydown event is called.
       * @memberof Selecto
       * @event keydown
       * @example
       * import Selecto from "selecto";
       *
       * const selecto = new Selecto({
       *   container: document.body,
       *   toggleContinueSelect: "shift";
       *   keyContainer: window,
       * });
       *
       * selecto.on("keydown", () => {
       *   document.querySelector(".button").classList.add("selected");
       * }).on("keyup", () => {
       *   document.querySelector(".button").classList.remove("selected");
       * }).on("select", e => {
       *   e.added.forEach(el => {
       *     el.classList.add("selected");
       *   });
       *   e.removed.forEach(el => {
       *     el.classList.remove("selected");
       *   });
       * });
       */

      _this.emit("keydown", {});
    };

    _this._onKeyUp = function (e) {
      if (!_this._sameCombiKey(e, true)) {
        return;
      }

      _this.continueSelect = false;
      /**
       * When you keyup the key you specified in toggleContinueSelect, the keyup event is called.
       * @memberof Selecto
       * @event keyup
       * @example
       * import Selecto from "selecto";
       *
       * const selecto = new Selecto({
       *   container: document.body,
       *   toggleContinueSelect: "shift";
       *   keyContainer: window,
       * });
       *
       * selecto.on("keydown", () => {
       *   document.querySelector(".button").classList.add("selected");
       * }).on("keyup", () => {
       *   document.querySelector(".button").classList.remove("selected");
       * }).on("select", e => {
       *   e.added.forEach(el => {
       *     el.classList.add("selected");
       *   });
       *   e.removed.forEach(el => {
       *     el.classList.remove("selected");
       *   });
       * });
       */

      _this.emit("keyup", {});
    };

    _this._onBlur = function () {
      if (_this.toggleContinueSelect && _this.continueSelect) {
        _this.continueSelect = false;

        _this.emit("keyup", {});
      }
    };

    _this._onDocumentSelectStart = function (e) {
      if (!_this.gesto.isFlag()) {
        return;
      }

      var dragContainer = _this.dragContainer;

      if (dragContainer === window) {
        dragContainer = document.documentElement;
      }

      var containers = dragContainer instanceof Element ? [dragContainer] : [].slice.call(dragContainer);
      var target = e.target;
      containers.some(function (container) {
        if (container === target || container.contains(target)) {
          e.preventDefault();
          return true;
        }
      });
    };

    _this.target = options.portalContainer;
    _this.container = options.container || document.body;
    _this.options = __assign({
      portalContainer: null,
      container: null,
      dragContainer: null,
      selectableTargets: [],
      selectByClick: true,
      selectFromInside: true,
      clickBySelectEnd: false,
      hitRate: 100,
      continueSelect: false,
      toggleContinueSelect: null,
      keyContainer: null,
      scrollOptions: undefined,
      checkInput: false,
      preventDefault: false,
      boundContainer: false,
      preventDragFromInside: true,
      dragCondition: null,
      rootContainer: null,
      getElementRect: getDefaultElementRect,
      cspNonce: "",
      ratio: 0
    }, options);

    _this.initElement();

    _this.initDragScroll();

    _this.setKeyController();

    return _this;
  }
  /**
   * You can set the currently selected targets.
   *
   */


  var __proto = Selecto.prototype;

  __proto.setSelectedTargets = function (selectedTargets) {
    this.selectedTargets = selectedTargets;
    return this;
  };
  /**
   * You can get the currently selected targets.
   */


  __proto.getSelectedTargets = function () {
    return this.selectedTargets;
  };

  __proto.setKeyContainer = function (keyContainer) {
    var _this = this;

    var options = this.options;
    diffValue(options.keyContainer, keyContainer, function () {
      options.keyContainer = keyContainer;

      _this.setKeyController();
    });
  };

  __proto.setToggleContinueSelect = function (toggleContinueSelect) {
    var _this = this;

    var options = this.options;
    diffValue(options.toggleContinueSelect, toggleContinueSelect, function () {
      options.toggleContinueSelect = toggleContinueSelect;

      _this.setKeyEvent();
    });
  };

  __proto.setPreventDefault = function (value) {
    this.gesto.options.preventDefault = value;
  };

  __proto.setCheckInput = function (value) {
    this.gesto.options.checkInput = value;
  };
  /**
   * `OnDragStart` is triggered by an external event.
   * @param - external event
   * @example
   * import Selecto from "selecto";
   *
   * const selecto = new Selecto();
   *
   * window.addEventListener("mousedown", e => {
   *   selecto.triggerDragStart(e);
   * });
   */


  __proto.triggerDragStart = function (e) {
    this.gesto.triggerDragStart(e);
    return this;
  };
  /**
   * Destroy elements, properties, and events.
   */


  __proto.destroy = function () {
    this.off();
    this.keycon && this.keycon.destroy();
    this.gesto.unset();
    this.injectResult.destroy();
    (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(document, "selectstart", this._onDocumentSelectStart);
    this.keycon = null;
    this.gesto = null;
    this.injectResult = null;
    this.target = null;
    this.container = null;
    this.options = null;
  };

  __proto.getElementPoints = function (target) {
    var getElementRect = this.getElementRect || getDefaultElementRect;
    var info = getElementRect(target);
    var points = [info.pos1, info.pos2, info.pos4, info.pos3];

    if (getElementRect !== getDefaultElementRect) {
      var rect = target.getBoundingClientRect();
      return (0,overlap_area__WEBPACK_IMPORTED_MODULE_5__.fitPoints)(points, rect);
    }

    return points;
  };
  /**
   * Get all elements set in `selectableTargets`.
   */


  __proto.getSelectableElements = function () {
    var selectableElements = [];
    this.options.selectableTargets.forEach(function (target) {
      if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(target)) {
        selectableElements.push(target);
      } else {
        var elements = [].slice.call(document.querySelectorAll(target));
        elements.forEach(function (el) {
          selectableElements.push(el);
        });
      }
    });
    return selectableElements;
  };
  /**
   * If scroll occurs during dragging, you can manually call this method to check the position again.
   */


  __proto.checkScroll = function () {
    var _a;

    if (!this.gesto.isFlag()) {
      return;
    }

    var scrollOptions = this.scrollOptions; // If it is a scrolling position, pass drag

    ((_a = scrollOptions) === null || _a === void 0 ? void 0 : _a.container) && this.dragScroll.checkScroll(__assign({
      inputEvent: this.gesto.getCurrentEvent()
    }, scrollOptions));
  };
  /**
   * Find for selectableTargets again during drag event
   */


  __proto.findSelectableTargets = function (datas) {
    var _this = this;

    if (datas === void 0) {
      datas = this.gesto.getEventDatas();
    }

    var selectableTargets = this.getSelectableElements();
    var selectablePoints = selectableTargets.map(function (target) {
      return _this.getElementPoints(target);
    });
    datas.selectableTargets = selectableTargets;
    datas.selectablePoints = selectablePoints;
  };
  /**
   * External click or mouse events can be applied to the selecto.
   * @params - Extenal click or mouse event
   * @params - Specify the clicked target directly.
   */


  __proto.clickTarget = function (e, clickedTarget) {
    var _a = getClient(e),
        clientX = _a.clientX,
        clientY = _a.clientY;

    var dragEvent = {
      datas: {
        selectFlag: false
      },
      clientX: clientX,
      clientY: clientY,
      inputEvent: e,
      isClick: true,
      stop: function () {
        return false;
      }
    };

    if (this._onDragStart(dragEvent, clickedTarget)) {
      this._onDragEnd(dragEvent);
    }

    return this;
  };

  __proto.setKeyController = function () {
    var _a = this.options,
        keyContainer = _a.keyContainer,
        toggleContinueSelect = _a.toggleContinueSelect;

    if (this.keycon) {
      this.keycon.destroy();
      this.keycon = null;
    }

    if (toggleContinueSelect) {
      this.keycon = new keycon__WEBPACK_IMPORTED_MODULE_6__["default"](keyContainer || window);
      this.keycon.keydown(this._onKeyDown).keyup(this._onKeyUp).on("blur", this._onBlur);
    }
  };

  __proto.setKeyEvent = function () {
    var toggleContinueSelect = this.options.toggleContinueSelect;

    if (!toggleContinueSelect || this.keycon) {
      return;
    }

    this.setKeyController();
  };

  __proto.initElement = function () {
    this.target = createElement(h("div", {
      className: CLASS_NAME
    }), this.target, this.container);
    var target = this.target;
    var _a = this.options,
        dragContainer = _a.dragContainer,
        checkInput = _a.checkInput,
        preventDefault = _a.preventDefault;
    this.dragContainer = typeof dragContainer === "string" ? [].slice.call(document.querySelectorAll(dragContainer)) : dragContainer || this.target.parentNode;
    this.gesto = new gesto__WEBPACK_IMPORTED_MODULE_7__["default"](this.dragContainer, {
      checkWindowBlur: true,
      container: window,
      checkInput: checkInput,
      preventDefault: preventDefault
    }).on({
      dragStart: this._onDragStart,
      drag: this._onDrag,
      dragEnd: this._onDragEnd
    });
    (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(document, "selectstart", this._onDocumentSelectStart);
    this.injectResult = injector.inject(target, {
      nonce: this.options.cspNonce
    });
  };

  __proto.hitTest = function (selectRect, clientX, clientY, targets, selectablePoints) {
    var _a = this.options,
        hitRate = _a.hitRate,
        selectByClick = _a.selectByClick;
    var left = selectRect.left,
        top = selectRect.top,
        right = selectRect.right,
        bottom = selectRect.bottom;
    var rectPoints = [[left, top], [right, top], [right, bottom], [left, bottom]];
    return targets.filter(function (_, i) {
      var points = selectablePoints[i];
      var inArea = (0,overlap_area__WEBPACK_IMPORTED_MODULE_5__.isInside)([clientX, clientY], points);

      if (selectByClick && inArea) {
        return true;
      }

      var overlapPoints = (0,overlap_area__WEBPACK_IMPORTED_MODULE_5__.getOverlapPoints)(rectPoints, points);

      if (!overlapPoints.length) {
        return false;
      }

      var overlapSize = (0,overlap_area__WEBPACK_IMPORTED_MODULE_5__.getAreaSize)(overlapPoints);
      var targetSize = (0,overlap_area__WEBPACK_IMPORTED_MODULE_5__.getAreaSize)(points);
      var hitRateValue = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.splitUnit)("" + hitRate);

      if (hitRateValue.unit === "px") {
        return overlapSize >= hitRateValue.value;
      } else {
        var rate = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.between)(Math.round(overlapSize / targetSize * 100), 0, 100);
        return rate >= Math.min(100, hitRateValue.value);
      }
    });
  };

  __proto.initDragScroll = function () {
    var _this = this;

    this.dragScroll.on("scroll", function (_a) {
      var container = _a.container,
          direction = _a.direction;

      _this.emit("scroll", {
        container: container,
        direction: direction
      });
    }).on("move", function (_a) {
      var offsetX = _a.offsetX,
          offsetY = _a.offsetY,
          inputEvent = _a.inputEvent;
      var gesto = _this.gesto;

      if (!gesto || !gesto.isFlag()) {
        return;
      }

      var datas = _this.gesto.getEventDatas();

      var boundArea = datas.boundArea;
      datas.startX -= offsetX;
      datas.startY -= offsetY;
      datas.selectablePoints.forEach(function (points) {
        points.forEach(function (pos) {
          pos[0] -= offsetX;
          pos[1] -= offsetY;
        });
      });
      boundArea.left -= offsetX;
      boundArea.right -= offsetX;
      boundArea.top -= offsetY;
      boundArea.bottom -= offsetY;

      _this.gesto.scrollBy(offsetX, offsetY, inputEvent.inputEvent, false);

      _this._checkSelected(_this.gesto.getCurrentEvent());
    });
  };

  __proto.select = function (prevSelectedTargets, selectedTargets, rect, inputEvent, isStart) {
    var _a = (0,_egjs_children_differ__WEBPACK_IMPORTED_MODULE_1__.diff)(prevSelectedTargets, selectedTargets),
        added = _a.added,
        removed = _a.removed,
        prevList = _a.prevList,
        list = _a.list;

    this.selectedTargets = selectedTargets;

    if (isStart) {
      /**
       * When the select(drag) starts, the selectStart event is called.
       * @memberof Selecto
       * @event selectStart
       * @param {Selecto.OnSelect} - Parameters for the selectStart event
       * @example
       * import Selecto from "selecto";
       *
       * const selecto = new Selecto({
       *   container: document.body,
       *   selectByClick: true,
       *   selectFromInside: false,
       * });
       *
       * selecto.on("selectStart", e => {
       *   e.added.forEach(el => {
       *     el.classList.add("selected");
       *   });
       *   e.removed.forEach(el => {
       *     el.classList.remove("selected");
       *   });
       * }).on("selectEnd", e => {
       *   e.afterAdded.forEach(el => {
       *     el.classList.add("selected");
       *   });
       *   e.afterRemoved.forEach(el => {
       *     el.classList.remove("selected");
       *   });
       * });
       */
      this.emit("selectStart", {
        selected: selectedTargets,
        added: added.map(function (index) {
          return list[index];
        }),
        removed: removed.map(function (index) {
          return prevList[index];
        }),
        rect: rect,
        inputEvent: inputEvent
      });
    }

    if (added.length || removed.length) {
      /**
       * When the select in real time, the select event is called.
       * @memberof Selecto
       * @event select
       * @param {Selecto.OnSelect} - Parameters for the select event
       * @example
       * import Selecto from "selecto";
       *
       * const selecto = new Selecto({
       *   container: document.body,
       *   selectByClick: true,
       *   selectFromInside: false,
       * });
       *
       * selecto.on("select", e => {
       *   e.added.forEach(el => {
       *     el.classList.add("selected");
       *   });
       *   e.removed.forEach(el => {
       *     el.classList.remove("selected");
       *   });
       * });
       */
      this.emit("select", {
        selected: selectedTargets,
        added: added.map(function (index) {
          return list[index];
        }),
        removed: removed.map(function (index) {
          return prevList[index];
        }),
        rect: rect,
        inputEvent: inputEvent
      });
    }
  };

  __proto.selectEnd = function (startSelectedTargets, startPassedTargets, rect, e) {
    var inputEvent = e.inputEvent,
        isDouble = e.isDouble;

    var _a = (0,_egjs_children_differ__WEBPACK_IMPORTED_MODULE_1__.diff)(startSelectedTargets, this.selectedTargets),
        added = _a.added,
        removed = _a.removed,
        prevList = _a.prevList,
        list = _a.list;

    var _b = (0,_egjs_children_differ__WEBPACK_IMPORTED_MODULE_1__.diff)(startPassedTargets, this.selectedTargets),
        afterAdded = _b.added,
        afterRemoved = _b.removed,
        afterPrevList = _b.prevList,
        afterList = _b.list;

    var type = inputEvent && inputEvent.type;
    var isDragStart = type === "mousedown" || type === "touchstart";
    /**
     * When the select(dragEnd or click) ends, the selectEnd event is called.
     * @memberof Selecto
     * @event selectEnd
     * @param {Selecto.OnSelectEnd} - Parameters for the selectEnd event
     * @example
     * import Selecto from "selecto";
     *
     * const selecto = new Selecto({
     *   container: document.body,
     *   selectByClick: true,
     *   selectFromInside: false,
     * });
     *
     * selecto.on("selectStart", e => {
     *   e.added.forEach(el => {
     *     el.classList.add("selected");
     *   });
     *   e.removed.forEach(el => {
     *     el.classList.remove("selected");
     *   });
     * }).on("selectEnd", e => {
     *   e.afterAdded.forEach(el => {
     *     el.classList.add("selected");
     *   });
     *   e.afterRemoved.forEach(el => {
     *     el.classList.remove("selected");
     *   });
     * });
     */

    this.emit("selectEnd", {
      selected: this.selectedTargets,
      added: added.map(function (index) {
        return list[index];
      }),
      removed: removed.map(function (index) {
        return prevList[index];
      }),
      afterAdded: afterAdded.map(function (index) {
        return afterList[index];
      }),
      afterRemoved: afterRemoved.map(function (index) {
        return afterPrevList[index];
      }),
      isDragStart: isDragStart,
      isClick: !!e.isClick,
      isDouble: !!isDouble,
      rect: rect,
      inputEvent: inputEvent
    });
  };

  __proto._checkSelected = function (e, rect) {
    if (rect === void 0) {
      rect = getRect(e, this.options.ratio);
    }

    var datas = e.datas,
        inputEvent = e.inputEvent;
    var top = rect.top,
        left = rect.left,
        width = rect.width,
        height = rect.height;
    var selectFlag = datas.selectFlag;
    var containerX = datas.containerX,
        containerY = datas.containerY,
        scaleMatrix = datas.scaleMatrix;
    var offsetPos = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.calculateMatrixDist)(scaleMatrix, [left - containerX, top - containerY]);
    var offsetSize = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.calculateMatrixDist)(scaleMatrix, [width, height]);
    var prevSelectedTargets = [];
    var selectedTargets = [];

    if (selectFlag) {
      this.target.style.cssText += "display: block;" + "left:0px;top:0px;pointer-events: none;" + ("transform: translate(" + offsetPos[0] + "px, " + offsetPos[1] + "px);") + ("width:" + offsetSize[0] + "px;height:" + offsetSize[1] + "px;");
      var passedTargets = this.hitTest(rect, datas.startX, datas.startY, datas.selectableTargets, datas.selectablePoints);
      prevSelectedTargets = this.selectedTargets;
      selectedTargets = passTargets(datas.startPassedTargets, passedTargets);
      this.selectedTargets = selectedTargets;
    }
    /**
     * When the drag, the drag event is called.
     * Call the stop () function if you have a specific element or don't want to raise a select
     * @memberof Selecto
     * @event drag
     * @param {OnDrag} - Parameters for the drag event
     * @example
     * import Selecto from "selecto";
     *
     * const selecto = new Selecto({
     *   container: document.body,
     *   selectByClick: true,
     *   selectFromInside: false,
     * });
     *
     * selecto.on("drag", e => {
     *   e.stop();
     * }).on("select", e => {
     *   e.added.forEach(el => {
     *     el.classList.add("selected");
     *   });
     *   e.removed.forEach(el => {
     *     el.classList.remove("selected");
     *   });
     * });
     */


    var result = this.emit("drag", __assign(__assign({}, e), {
      isSelect: selectFlag,
      rect: rect
    }));

    if (result === false) {
      this.target.style.cssText += "display: none;";
      e.stop();
      return;
    }

    if (selectFlag) {
      this.select(prevSelectedTargets, selectedTargets, rect, inputEvent);
    }
  };

  __proto._sameCombiKey = function (e, isKeyup) {
    var toggleContinueSelect = [].concat(this.options.toggleContinueSelect);
    var combi = (0,keycon__WEBPACK_IMPORTED_MODULE_6__.getCombi)(e.inputEvent, e.key);
    var toggleKeys = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(toggleContinueSelect[0]) ? toggleContinueSelect : [toggleContinueSelect];

    if (isKeyup) {
      var singleKey_1 = e.key;
      return toggleKeys.some(function (keys) {
        return keys.some(function (key) {
          return key === singleKey_1;
        });
      });
    }

    return toggleKeys.some(function (keys) {
      return keys.every(function (key) {
        return combi.indexOf(key) > -1;
      });
    });
  };

  __proto._findElement = function (clickedTarget, selectableTargets) {
    var pointTarget = clickedTarget;

    while (pointTarget) {
      if (selectableTargets.indexOf(pointTarget) > -1) {
        break;
      }

      pointTarget = pointTarget.parentElement;
    }

    return pointTarget;
  };

  Selecto = __decorate([(0,framework_utils__WEBPACK_IMPORTED_MODULE_8__.Properties)(PROPERTIES, function (prototype, property) {
    var attributes = {
      enumerable: true,
      configurable: true,
      get: function () {
        return this.options[property];
      }
    };
    var setter = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.camelize)("set " + property);

    if (prototype[setter]) {
      attributes.set = function set(value) {
        this[setter](value);
      };
    } else {
      attributes.set = function set(value) {
        this.options[property] = value;
      };
    }

    Object.defineProperty(prototype, property, attributes);
  })], Selecto);
  return Selecto;
}(_scena_event_emitter__WEBPACK_IMPORTED_MODULE_9__["default"]);

var Selecto$1 =
/*#__PURE__*/
function (_super) {
  __extends(Selecto, _super);

  function Selecto() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  return Selecto;
}(Selecto);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Selecto$1);

//# sourceMappingURL=selecto.esm.js.map


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLFlBQVk7QUFDOUI7O0FBRUEsU0FBUyw0REFBVztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxTQUFTLHdEQUFTLENBQUMscURBQU0sYUFBYSxvRUFBcUI7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxvREFBSywyQkFBMkIsbURBQUk7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG9EQUFLO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7O0FBRUEsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQzs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsd0RBQU87QUFDbEIsV0FBVyx3REFBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQSxvRkFBb0Y7O0FBRXBGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsOERBQThEOztBQUU5RDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsV0FBVyxvREFBSztBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEOztBQUU3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxxREFBTTtBQUNqQixHQUFHO0FBQ0g7QUFDQTtBQUNB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aEQsT0FBTzs7O0FBR1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLHVEQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0RBQUs7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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SUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixxQ0FBcUMsRUFBRTtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkJBQTJCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7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Q0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywrREFBZ0I7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNDQUFzQztBQUNyRCxJQUFJO0FBQ0osd0JBQXdCLDBDQUEwQztBQUNsRTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixZQUFZO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTs7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RUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsT0FBTztBQUMzQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdURBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFFQUFxRTs7QUFFckU7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQ0FBZ0M7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDJCQUEyQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOEJBQThCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCwyREFB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Q0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDs7QUFFNUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQSxRQUFROzs7QUFHUjtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlKQUFpSix5REFBUSxrQ0FBa0MseURBQVE7QUFDbk07O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDZDQUFLO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sNERBQVc7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTSxxRUFBb0I7QUFDMUIsMEJBQTBCLHNFQUFxQjtBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxXQUFXLGtFQUFhO0FBQ3hCO0FBQ0EsV0FBVyxvREFBRztBQUNkO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHVEQUFTO0FBQzFCLGVBQWUsNERBQWM7QUFDN0Isb0JBQW9CLHlEQUFXOztBQUUvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxzREFBUSxxQkFBcUIsdURBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixRQUFRO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixRQUFRO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxVQUFVOztBQUVsQjtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVCQUF1QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUU2ekI7QUFDN3pCOzs7Ozs7Ozs7Ozs7O0FDNzhDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUc7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QscURBQXFEO0FBQ3JEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG1CQUFtQjtBQUM1QjtBQUNBO0FBQ0EsV0FBVyx3QkFBd0I7QUFDbkMsQ0FBQztBQUNEO0FBQ0EsWUFBWSx3QkFBd0I7QUFDcEMsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsd0JBQXdCO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsS0FBSyxFQUFDO0FBQ087QUFDNUI7Ozs7Ozs7Ozs7Ozs7O0FDdFpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDK0Q7O0FBRS9EO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQyxDQUFDLHlEQUFVOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyx1REFBTTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsY0FBYyxFQUFDO0FBQ2Q7QUFDaEI7Ozs7Ozs7Ozs7Ozs7QUM5SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxHQUFHOztBQUVOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDOztBQUV6QywyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRyxHQUFHOztBQUVOO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUcsR0FBRzs7QUFFTjtBQUNBLDZDQUE2Qzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxHQUFHOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLFVBQVUsRUFBQztBQUNWO0FBQ2hCOzs7Ozs7Ozs7Ozs7OztBQ2paQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2dEO0FBQ1Y7O0FBRXRDO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsT0FBTztBQUNwRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixvREFBRztBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQyxDQUFDLDREQUFZOztBQUVkLGlFQUFlLFVBQVUsRUFBQztBQUMxQjs7Ozs7Ozs7Ozs7OztBQzlRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3NEOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsUUFBUTs7QUFFeEQsdUNBQXVDLFFBQVEsc0RBQXNELFFBQVE7O0FBRTdHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLE1BQU07QUFDTjs7O0FBR0E7O0FBRUE7QUFDQSxRQUFRLHlEQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw0Q0FBNEM7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxTQUFTLHlEQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBLG9CQUFvQiwwREFBUztBQUM3QjtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLENBQUM7O0FBRUQsaUVBQWUsWUFBWSxFQUFDO0FBQzVCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM4RDs7QUFFOUQ7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7O0FBR1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDJCQUEyQixvREFBRzs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLHlEQUFRO0FBQ2xCO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDs7QUFFQTtBQUNBLFFBQVEsNERBQVc7QUFDbkI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSw0REFBVztBQUNuQjs7QUFFQTs7QUFFQTs7QUFFQSx3QkFBd0Isb0RBQUc7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEseURBQVE7QUFDaEIsT0FBTztBQUNQLE1BQU0seURBQVE7QUFDZCxNQUFNLHlEQUFRO0FBQ2QsTUFBTSx5REFBUTtBQUNkOztBQUVBO0FBQ0EsTUFBTSx5REFBUTtBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlEQUFRO0FBQ2hCLE9BQU87QUFDUCxNQUFNLHlEQUFRO0FBQ2QsTUFBTSx5REFBUTtBQUNkLE1BQU0seURBQVE7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTyxTQUFTLFFBQVEsWUFBWTtBQUMvQyxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU8sU0FBUyxRQUFRLFlBQVk7QUFDL0MsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUzs7QUFFdEI7QUFDQSxpQkFBaUIsUUFBUTs7QUFFekI7QUFDQSxZQUFZLFFBQVE7O0FBRXBCO0FBQ0EsWUFBWSxRQUFROztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdEQUFnRDs7QUFFaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdB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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsUUFBUSwwREFBUztBQUNqQjtBQUNBLEtBQUssVUFBVSwwREFBUztBQUN4QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FB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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLDJEQUFVOztBQUV6QjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsMkRBQVU7O0FBRXpCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSwyREFBVTs7QUFFekI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLHdCQUF3QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQVE7QUFDeEIscUJBQXFCLHdEQUFPOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdCQUF3QiwyREFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix5REFBUTs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDLENBQUMsNERBQVk7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRCxpRUFBZSxTQUFTLEVBQUM7QUFDaUQ7QUFDMUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9jb3JlL2NvbXBvbmVudHMvTGF5ZXJzL0FkZExheWVyQnV0dG9uLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9jb3JlL2NvbXBvbmVudHMvTGF5ZXJzL0xheWVyRHJhZ0Ryb3BMaXN0LnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9jb3JlL2NvbXBvbmVudHMvTGF5ZXJzL0xheWVyTmFtZS50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvZmVhdHVyZXMvY2FudmFzL2VsZW1lbnRzL2J1dHRvbi50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvZmVhdHVyZXMvY2FudmFzL2VsZW1lbnRzL2Ryb25lRnJvbnQudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL2ZlYXR1cmVzL2NhbnZhcy9lbGVtZW50cy9kcm9uZVNpZGUudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL2ZlYXR1cmVzL2NhbnZhcy9lbGVtZW50cy9kcm9uZVRvcC50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvZmVhdHVyZXMvY2FudmFzL2VsZW1lbnRzL2ljb24udHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL2ZlYXR1cmVzL2NhbnZhcy9lbGVtZW50cy9ub3RGb3VuZC50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvZmVhdHVyZXMvY2FudmFzL2VsZW1lbnRzL3RleHRCb3gudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL2ZlYXR1cmVzL2NhbnZhcy9lbGVtZW50cy93aW5kVHVyYmluZS50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvZmVhdHVyZXMvY2FudmFzL2luZGV4LnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL2ZlYXR1cmVzL2NhbnZhcy9yZWdpc3RyeS50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9mZWF0dXJlcy9jYW52YXMvcnVudGltZS9lbGVtZW50LnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9mZWF0dXJlcy9jYW52YXMvcnVudGltZS9mcmFtZS50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvZmVhdHVyZXMvY2FudmFzL3J1bnRpbWUvcm9vdC50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvZmVhdHVyZXMvY2FudmFzL3J1bnRpbWUvc2NlbmUudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL2ZlYXR1cmVzL2NhbnZhcy90eXBlcy50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL3BhbmVsL2NhbnZhcy9DYW52YXNQYW5lbC50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9wYW5lbC9jYW52YXMvSW5saW5lRWRpdC50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9wYW5lbC9jYW52YXMvSW5saW5lRWRpdEJvZHkudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvcGFuZWwvY2FudmFzL2VkaXRvci9BUElFZGl0b3IudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvcGFuZWwvY2FudmFzL2VkaXRvci9MYXllckVsZW1lbnRMaXN0RWRpdG9yLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL3BhbmVsL2NhbnZhcy9lZGl0b3IvUGxhY2VtZW50RWRpdG9yLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL3BhbmVsL2NhbnZhcy9lZGl0b3IvZWxlbWVudEVkaXRvci50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9wYW5lbC9jYW52YXMvZWRpdG9yL2xheWVyRWRpdG9yLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL3BhbmVsL2NhbnZhcy9lZGl0b3Ivb3B0aW9ucy50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL3BhbmVsL2NhbnZhcy9tb2R1bGUudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvcGFuZWwvY2FudmFzL3R5cGVzLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9fX3ZpcnR1YWxfXy9jc3Mtc3R5bGVkLXZpcnR1YWwtOWVmOGYwNWRlMi8wL2NhY2hlL2Nzcy1zdHlsZWQtbnBtLTEuMC4wLTUxMDRhODgyZDUtM2YyZjk5NTkzOC56aXAvbm9kZV9tb2R1bGVzL2Nzcy1zdHlsZWQvZGlzdC9zdHlsZWQuZXNtLmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9fX3ZpcnR1YWxfXy9yZWFjdC1jb21wYXQtbW92ZWFibGUtdmlydHVhbC04MWI3YTQyYWJiLzAvY2FjaGUvcmVhY3QtY29tcGF0LW1vdmVhYmxlLW5wbS0wLjE2LjAtMzk1YjNjOTJlOS1iMjBiZDkxNjk4LnppcC9ub2RlX21vZHVsZXMvcmVhY3QtY29tcGF0LW1vdmVhYmxlL2Rpc3QvbW92ZWFibGUuZXNtLmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9fX3ZpcnR1YWxfXy9yZWFjdC1yZXNpemFibGUtdmlydHVhbC0xMzQxMjEzN2NkLzAvY2FjaGUvcmVhY3QtcmVzaXphYmxlLW5wbS0zLjAuNC1hYTM5ZjlkYjJiLWNiZjg2YWQwNGIuemlwL25vZGVfbW9kdWxlcy9yZWFjdC1yZXNpemFibGUvYnVpbGQvUmVzaXphYmxlLmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9fX3ZpcnR1YWxfXy9yZWFjdC1yZXNpemFibGUtdmlydHVhbC0xMzQxMjEzN2NkLzAvY2FjaGUvcmVhY3QtcmVzaXphYmxlLW5wbS0zLjAuNC1hYTM5ZjlkYjJiLWNiZjg2YWQwNGIuemlwL25vZGVfbW9kdWxlcy9yZWFjdC1yZXNpemFibGUvYnVpbGQvUmVzaXphYmxlQm94LmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9fX3ZpcnR1YWxfXy9yZWFjdC1yZXNpemFibGUtdmlydHVhbC0xMzQxMjEzN2NkLzAvY2FjaGUvcmVhY3QtcmVzaXphYmxlLW5wbS0zLjAuNC1hYTM5ZjlkYjJiLWNiZjg2YWQwNGIuemlwL25vZGVfbW9kdWxlcy9yZWFjdC1yZXNpemFibGUvYnVpbGQvcHJvcFR5cGVzLmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9fX3ZpcnR1YWxfXy9yZWFjdC1yZXNpemFibGUtdmlydHVhbC0xMzQxMjEzN2NkLzAvY2FjaGUvcmVhY3QtcmVzaXphYmxlLW5wbS0zLjAuNC1hYTM5ZjlkYjJiLWNiZjg2YWQwNGIuemlwL25vZGVfbW9kdWxlcy9yZWFjdC1yZXNpemFibGUvYnVpbGQvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uLy55YXJuL19fdmlydHVhbF9fL3JlYWN0LXJlc2l6YWJsZS12aXJ0dWFsLTEzNDEyMTM3Y2QvMC9jYWNoZS9yZWFjdC1yZXNpemFibGUtbnBtLTMuMC40LWFhMzlmOWRiMmItY2JmODZhZDA0Yi56aXAvbm9kZV9tb2R1bGVzL3JlYWN0LXJlc2l6YWJsZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vX192aXJ0dWFsX18vcmVhY3QtdXNlLXZpcnR1YWwtMDAzMjZlNzBiYS8wL2NhY2hlL3JlYWN0LXVzZS1ucG0tMTcuMy4yLWEwMzJjYmViMDEtNzM3OTQ2MGY1MS56aXAvbm9kZV9tb2R1bGVzL3JlYWN0LXVzZS9lc20vdXNlT2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vY2FjaGUvQGRheWJydXNoLXV0aWxzLW5wbS0xLjYuMC01NDc0ODZiZjc5LTI1NzliYzE3ZTAuemlwL25vZGVfbW9kdWxlcy9AZGF5YnJ1c2gvdXRpbHMvZGlzdC91dGlscy5lc20uanMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uLy55YXJuL2NhY2hlL0BlZ2pzLWFnZW50LW5wbS0yLjMuMC1lODhjYTBlZWMyLTI1MDZlOGZlZmYuemlwL25vZGVfbW9kdWxlcy9AZWdqcy9hZ2VudC9kaXN0L2FnZW50LmVzbS5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vY2FjaGUvQGVnanMtY2hpbGRyZW4tZGlmZmVyLW5wbS0xLjAuMS0zN2Y0NWRkZjk3LTA4N2YyODY4MjIuemlwL25vZGVfbW9kdWxlcy9AZWdqcy9jaGlsZHJlbi1kaWZmZXIvZGlzdC9jaGlsZHJlbi1kaWZmZXIuZXNtLmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9jYWNoZS9AZWdqcy1saXN0LWRpZmZlci1ucG0tMS4wLjAtZjRiOTE3ODFkYi1kMTgyN2QxMzRkLnppcC9ub2RlX21vZHVsZXMvQGVnanMvbGlzdC1kaWZmZXIvZGlzdC9saXN0LWRpZmZlci5lc20uanMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uLy55YXJuL2NhY2hlL0BzY2VuYS1kcmFnc2Nyb2xsLW5wbS0xLjEuMS04ZmU2MDc3NWY5LWFhY2IzMzU4NzAuemlwL25vZGVfbW9kdWxlcy9Ac2NlbmEvZHJhZ3Njcm9sbC9kaXN0L2RyYWdzY3JvbGwuZXNtLmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9jYWNoZS9Ac2NlbmEtZXZlbnQtZW1pdHRlci1ucG0tMS4wLjUtN2ViZjM2MWQxNy00MDBlMGY2YWI4LnppcC9ub2RlX21vZHVsZXMvQHNjZW5hL2V2ZW50LWVtaXR0ZXIvZGlzdC9ldmVudC1lbWl0dGVyLmVzbS5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vY2FjaGUvQHNjZW5hLW1hdHJpeC1ucG0tMS4xLjEtZGE5NjRmNmIzYS1lOTZhZWFiNzEyLnppcC9ub2RlX21vZHVsZXMvQHNjZW5hL21hdHJpeC9kaXN0L21hdHJpeC5lc20uanMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uLy55YXJuL2NhY2hlL2Nzcy10by1tYXQtbnBtLTEuMC4zLThhNjllZDcxZGUtYTNmYzk4YmZhZC56aXAvbm9kZV9tb2R1bGVzL2Nzcy10by1tYXQvZGlzdC9jc3MtdG8tbWF0LmVzbS5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vY2FjaGUvZnJhbWV3b3JrLXV0aWxzLW5wbS0xLjEuMC0zN2E1NGEwNjljLTAxYjYxZWFkMTcuemlwL25vZGVfbW9kdWxlcy9mcmFtZXdvcmstdXRpbHMvZGlzdC91dGlscy5lc20uanMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uLy55YXJuL2NhY2hlL2dlc3RvLW5wbS0xLjcuMC03ZDU0NDAwMDBiLWYyYTY2YmNmMGYuemlwL25vZGVfbW9kdWxlcy9nZXN0by9kaXN0L2dlc3RvLmVzbS5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vY2FjaGUva2V5Y29uLW5wbS0xLjEuMi00N2JiNTA0OGRmLTdiZTc0YWFmODMuemlwL25vZGVfbW9kdWxlcy9rZXljb24vZGlzdC9rZXljb24uZXNtLmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9jYWNoZS9tb3ZlYWJsZS1ucG0tMC4yOC4wLTMyZDA2NjA5NmEtMWZlZTg1YThjNy56aXAvbm9kZV9tb2R1bGVzL21vdmVhYmxlL2Rpc3QvbW92ZWFibGUuZXNtLmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9jYWNoZS9vdmVybGFwLWFyZWEtbnBtLTEuMC4wLWVjZTVhNGZjNmEtMzdkODJlYTRlYS56aXAvbm9kZV9tb2R1bGVzL292ZXJsYXAtYXJlYS9kaXN0L292ZXJsYXAtYXJlYS5lc20uanMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uLy55YXJuL2NhY2hlL3JlYWN0LWNvbXBhdC1jc3Mtc3R5bGVkLW5wbS0xLjAuOC01MjIxMWQyNmY4LTdhOGU1MTg0OWUuemlwL25vZGVfbW9kdWxlcy9yZWFjdC1jb21wYXQtY3NzLXN0eWxlZC9kaXN0L3N0eWxlZC5lc20uanMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uLy55YXJuL2NhY2hlL3JlYWN0LXNpbXBsZS1jb21wYXQtbnBtLTEuMi4xLWQzNWRiMDhiYTQtMDdhNDdlNzUwZi56aXAvbm9kZV9tb2R1bGVzL3JlYWN0LXNpbXBsZS1jb21wYXQvZGlzdC9jb21wYXQuZXNtLmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9jYWNoZS9zZWxlY3RvLW5wbS0xLjE1LjAtZWI4NDk1OWRmNS1hZTE5NTEzYzc3LnppcC9ub2RlX21vZHVsZXMvc2VsZWN0by9kaXN0L3NlbGVjdG8uZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IFNlbGVjdGFibGVWYWx1ZSB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgVmFsdWVQaWNrZXIgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5cbnR5cGUgQWRkTGF5ZXJCdXR0b25Qcm9wcyA9IHtcbiAgb25DaGFuZ2U6IChzZWw6IFNlbGVjdGFibGVWYWx1ZTxzdHJpbmc+KSA9PiB2b2lkO1xuICBvcHRpb25zOiBBcnJheTxTZWxlY3RhYmxlVmFsdWU8c3RyaW5nPj47XG4gIGxhYmVsOiBzdHJpbmc7XG59O1xuXG5leHBvcnQgY29uc3QgQWRkTGF5ZXJCdXR0b24gPSAoeyBvbkNoYW5nZSwgb3B0aW9ucywgbGFiZWwgfTogQWRkTGF5ZXJCdXR0b25Qcm9wcykgPT4ge1xuICByZXR1cm4gKFxuICAgIDxWYWx1ZVBpY2tlclxuICAgICAgaWNvbj1cInBsdXNcIlxuICAgICAgbGFiZWw9e2xhYmVsfVxuICAgICAgdmFyaWFudD1cInNlY29uZGFyeVwiXG4gICAgICBvcHRpb25zPXtvcHRpb25zfVxuICAgICAgb25DaGFuZ2U9e29uQ2hhbmdlfVxuICAgICAgaXNGdWxsV2lkdGg9e3RydWV9XG4gICAgLz5cbiAgKTtcbn07XG4iLCJpbXBvcnQgeyBjc3MsIGN4IH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBEcmFnRHJvcENvbnRleHQsIERyYWdnYWJsZSwgRHJvcHBhYmxlLCBEcm9wUmVzdWx0IH0gZnJvbSAncmVhY3QtYmVhdXRpZnVsLWRuZCc7XG5cbmltcG9ydCB7IEdyYWZhbmFUaGVtZSB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgY29uZmlnIH0gZnJvbSAnQGdyYWZhbmEvcnVudGltZSc7XG5pbXBvcnQgeyBJY29uLCBJY29uQnV0dG9uLCBzdHlsZXNGYWN0b3J5IH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5pbXBvcnQgeyBMYXllck5hbWUgfSBmcm9tICcuL0xheWVyTmFtZSc7XG5pbXBvcnQgeyBMYXllckVsZW1lbnQgfSBmcm9tICcuL3R5cGVzJztcblxudHlwZSBMYXllckRyYWdEcm9wTGlzdFByb3BzPFQgZXh0ZW5kcyBMYXllckVsZW1lbnQ+ID0ge1xuICBsYXllcnM6IFRbXTtcbiAgZ2V0TGF5ZXJJbmZvOiAoZWxlbWVudDogVCkgPT4gc3RyaW5nO1xuICBvbkRyYWdFbmQ6IChyZXN1bHQ6IERyb3BSZXN1bHQpID0+IHZvaWQ7XG4gIG9uU2VsZWN0OiAoZWxlbWVudDogVCkgPT4gYW55O1xuICBvbkRlbGV0ZTogKGVsZW1lbnQ6IFQpID0+IGFueTtcbiAgb25EdXBsaWNhdGU/OiAoZWxlbWVudDogVCkgPT4gYW55O1xuICBpc0ZyYW1lOiAoZWxlbWVudDogVCkgPT4gYm9vbGVhbjtcbiAgc2VsZWN0aW9uPzogc3RyaW5nW107IC8vIGxpc3Qgb2YgdW5pcXVlIGlkcyAobmFtZXMpXG4gIGV4Y2x1ZGVCYXNlTGF5ZXI/OiBib29sZWFuO1xuICBvbk5hbWVDaGFuZ2U6IChlbGVtZW50OiBULCBuZXdOYW1lOiBzdHJpbmcpID0+IGFueTtcbiAgdmVyaWZ5TGF5ZXJOYW1lVW5pcXVlbmVzcz86IChuYW1lVG9DaGVjazogc3RyaW5nKSA9PiBib29sZWFuO1xufTtcblxuZXhwb3J0IGNvbnN0IExheWVyRHJhZ0Ryb3BMaXN0ID0gPFQgZXh0ZW5kcyBMYXllckVsZW1lbnQ+KHtcbiAgbGF5ZXJzLFxuICBnZXRMYXllckluZm8sXG4gIG9uRHJhZ0VuZCxcbiAgb25TZWxlY3QsXG4gIG9uRGVsZXRlLFxuICBvbkR1cGxpY2F0ZSxcbiAgaXNGcmFtZSxcbiAgc2VsZWN0aW9uLFxuICBleGNsdWRlQmFzZUxheWVyLFxuICBvbk5hbWVDaGFuZ2UsXG4gIHZlcmlmeUxheWVyTmFtZVVuaXF1ZW5lc3MsXG59OiBMYXllckRyYWdEcm9wTGlzdFByb3BzPFQ+KSA9PiB7XG4gIGNvbnN0IHN0eWxlID0gc3R5bGVzKGNvbmZpZy50aGVtZSk7XG5cbiAgY29uc3QgZ2V0Um93U3R5bGUgPSAoaXNTZWxlY3RlZDogYm9vbGVhbikgPT4ge1xuICAgIHJldHVybiBpc1NlbGVjdGVkID8gYCR7c3R5bGUucm93fSAke3N0eWxlLnNlbH1gIDogc3R5bGUucm93O1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPERyYWdEcm9wQ29udGV4dCBvbkRyYWdFbmQ9e29uRHJhZ0VuZH0+XG4gICAgICA8RHJvcHBhYmxlIGRyb3BwYWJsZUlkPVwiZHJvcHBhYmxlXCI+XG4gICAgICAgIHsocHJvdmlkZWQsIHNuYXBzaG90KSA9PiAoXG4gICAgICAgICAgPGRpdiB7Li4ucHJvdmlkZWQuZHJvcHBhYmxlUHJvcHN9IHJlZj17cHJvdmlkZWQuaW5uZXJSZWZ9PlxuICAgICAgICAgICAgeygoKSA9PiB7XG4gICAgICAgICAgICAgIC8vIHJldmVyc2Ugb3JkZXJcbiAgICAgICAgICAgICAgY29uc3Qgcm93czogYW55ID0gW107XG4gICAgICAgICAgICAgIGNvbnN0IGxhc3RMYXllckluZGV4ID0gZXhjbHVkZUJhc2VMYXllciA/IDEgOiAwO1xuICAgICAgICAgICAgICBjb25zdCBzaG91bGRSZW5kZXJEcmFnSWNvbkxlbmd0aFRocmVzaG9sZCA9IGV4Y2x1ZGVCYXNlTGF5ZXIgPyAyIDogMTtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGxheWVycy5sZW5ndGggLSAxOyBpID49IGxhc3RMYXllckluZGV4OyBpLS0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gbGF5ZXJzW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVpZCA9IGVsZW1lbnQuZ2V0TmFtZSgpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgaXNTZWxlY3RlZCA9IEJvb2xlYW4oc2VsZWN0aW9uPy5pbmNsdWRlcyh1aWQpKTtcbiAgICAgICAgICAgICAgICByb3dzLnB1c2goXG4gICAgICAgICAgICAgICAgICA8RHJhZ2dhYmxlIGtleT17dWlkfSBkcmFnZ2FibGVJZD17dWlkfSBpbmRleD17cm93cy5sZW5ndGh9PlxuICAgICAgICAgICAgICAgICAgICB7KHByb3ZpZGVkLCBzbmFwc2hvdCkgPT4gKFxuICAgICAgICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Z2V0Um93U3R5bGUoaXNTZWxlY3RlZCl9XG4gICAgICAgICAgICAgICAgICAgICAgICByZWY9e3Byb3ZpZGVkLmlubmVyUmVmfVxuICAgICAgICAgICAgICAgICAgICAgICAgey4uLnByb3ZpZGVkLmRyYWdnYWJsZVByb3BzfVxuICAgICAgICAgICAgICAgICAgICAgICAgey4uLnByb3ZpZGVkLmRyYWdIYW5kbGVQcm9wc31cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uTW91c2VEb3duPXsoKSA9PiBvblNlbGVjdChlbGVtZW50KX1cbiAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICA8TGF5ZXJOYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9e3VpZH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eyh2KSA9PiBvbk5hbWVDaGFuZ2UoZWxlbWVudCwgdil9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZlcmlmeUxheWVyTmFtZVVuaXF1ZW5lc3M9e3ZlcmlmeUxheWVyTmFtZVVuaXF1ZW5lc3MgPz8gdW5kZWZpbmVkfVxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZS50ZXh0V3JhcHBlcn0+Jm5ic3A7IHtnZXRMYXllckluZm8oZWxlbWVudCl9PC9kaXY+XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtpc0ZyYW1lKGVsZW1lbnQpICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7b25EdXBsaWNhdGUgPyAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8SWNvbkJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lPVwiY29weVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlPXsnRHVwbGljYXRlJ31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZS5hY3Rpb25JY29ufVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBvbkR1cGxpY2F0ZShlbGVtZW50KX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VyZmFjZT1cImhlYWRlclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkgOiBudWxsfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPEljb25CdXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9XCJ0cmFzaC1hbHRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9eydyZW1vdmUnfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjeChzdHlsZS5hY3Rpb25JY29uLCBzdHlsZS5kcmFnSWNvbil9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBvbkRlbGV0ZShlbGVtZW50KX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1cmZhY2U9XCJoZWFkZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2xheWVycy5sZW5ndGggPiBzaG91bGRSZW5kZXJEcmFnSWNvbkxlbmd0aFRocmVzaG9sZCAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8SWNvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZT1cIkRyYWcgYW5kIGRyb3AgdG8gcmVvcmRlclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9XCJkcmFnZ2FibGVkb3RzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZT1cImxnXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZS5kcmFnSWNvbn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgPC9EcmFnZ2FibGU+XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiByb3dzO1xuICAgICAgICAgICAgfSkoKX1cblxuICAgICAgICAgICAge3Byb3ZpZGVkLnBsYWNlaG9sZGVyfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApfVxuICAgICAgPC9Ecm9wcGFibGU+XG4gICAgPC9EcmFnRHJvcENvbnRleHQ+XG4gICk7XG59O1xuXG5MYXllckRyYWdEcm9wTGlzdC5kZWZhdWx0UHJvcHMgPSB7XG4gIGlzR3JvdXA6ICgpID0+IGZhbHNlLFxufTtcblxuY29uc3Qgc3R5bGVzID0gc3R5bGVzRmFjdG9yeSgodGhlbWU6IEdyYWZhbmFUaGVtZSkgPT4gKHtcbiAgd3JhcHBlcjogY3NzYFxuICAgIG1hcmdpbi1ib3R0b206ICR7dGhlbWUuc3BhY2luZy5tZH07XG4gIGAsXG4gIHJvdzogY3NzYFxuICAgIHBhZGRpbmc6ICR7dGhlbWUuc3BhY2luZy54c30gJHt0aGVtZS5zcGFjaW5nLnNtfTtcbiAgICBib3JkZXItcmFkaXVzOiAke3RoZW1lLmJvcmRlci5yYWRpdXMuc219O1xuICAgIGJhY2tncm91bmQ6ICR7dGhlbWUuY29sb3JzLmJnMn07XG4gICAgbWluLWhlaWdodDogJHt0aGVtZS5zcGFjaW5nLmZvcm1JbnB1dEhlaWdodH1weDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgIG1hcmdpbi1ib3R0b206IDNweDtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG5cbiAgICBib3JkZXI6IDFweCBzb2xpZCAke3RoZW1lLmNvbG9ycy5mb3JtSW5wdXRCb3JkZXJ9O1xuICAgICY6aG92ZXIge1xuICAgICAgYm9yZGVyOiAxcHggc29saWQgJHt0aGVtZS5jb2xvcnMuZm9ybUlucHV0Qm9yZGVySG92ZXJ9O1xuICAgIH1cbiAgYCxcbiAgc2VsOiBjc3NgXG4gICAgYm9yZGVyOiAxcHggc29saWQgJHt0aGVtZS5jb2xvcnMuZm9ybUlucHV0Qm9yZGVyQWN0aXZlfTtcbiAgICAmOmhvdmVyIHtcbiAgICAgIGJvcmRlcjogMXB4IHNvbGlkICR7dGhlbWUuY29sb3JzLmZvcm1JbnB1dEJvcmRlckFjdGl2ZX07XG4gICAgfVxuICBgLFxuICBkcmFnSWNvbjogY3NzYFxuICAgIGN1cnNvcjogZHJhZztcbiAgYCxcbiAgYWN0aW9uSWNvbjogY3NzYFxuICAgIGNvbG9yOiAke3RoZW1lLmNvbG9ycy50ZXh0V2Vha307XG4gICAgJjpob3ZlciB7XG4gICAgICBjb2xvcjogJHt0aGVtZS5jb2xvcnMudGV4dH07XG4gICAgfVxuICBgLFxuICB0eXBlV3JhcHBlcjogY3NzYFxuICAgIGNvbG9yOiAke3RoZW1lLmNvbG9ycy50ZXh0Qmx1ZX07XG4gICAgbWFyZ2luLXJpZ2h0OiA1cHg7XG4gIGAsXG4gIHRleHRXcmFwcGVyOiBjc3NgXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGZsZXgtZ3JvdzogMTtcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIG1hcmdpbi1yaWdodDogJHt0aGVtZS5zcGFjaW5nLnNtfTtcbiAgYCxcbn0pKTtcbiIsImltcG9ydCB7IGNzcywgY3ggfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBHcmFmYW5hVGhlbWUgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IEljb24sIElucHV0LCBGaWVsZFZhbGlkYXRpb25NZXNzYWdlLCB1c2VTdHlsZXMgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGF5ZXJOYW1lUHJvcHMge1xuICBuYW1lOiBzdHJpbmc7XG4gIG9uQ2hhbmdlOiAodjogc3RyaW5nKSA9PiB2b2lkO1xuICB2ZXJpZnlMYXllck5hbWVVbmlxdWVuZXNzPzogKG5hbWVUb0NoZWNrOiBzdHJpbmcpID0+IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjb25zdCBMYXllck5hbWUgPSAoeyBuYW1lLCBvbkNoYW5nZSwgdmVyaWZ5TGF5ZXJOYW1lVW5pcXVlbmVzcyB9OiBMYXllck5hbWVQcm9wcykgPT4ge1xuICBjb25zdCBzdHlsZXMgPSB1c2VTdHlsZXMoZ2V0U3R5bGVzKTtcblxuICBjb25zdCBbaXNFZGl0aW5nLCBzZXRJc0VkaXRpbmddID0gdXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xuICBjb25zdCBbdmFsaWRhdGlvbkVycm9yLCBzZXRWYWxpZGF0aW9uRXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG5cbiAgY29uc3Qgb25FZGl0TGF5ZXIgPSAoZXZlbnQ6IFJlYWN0LlN5bnRoZXRpY0V2ZW50KSA9PiB7XG4gICAgc2V0SXNFZGl0aW5nKHRydWUpO1xuICB9O1xuXG4gIGNvbnN0IG9uRW5kRWRpdE5hbWUgPSAobmV3TmFtZTogc3RyaW5nKSA9PiB7XG4gICAgc2V0SXNFZGl0aW5nKGZhbHNlKTtcblxuICAgIGlmICh2YWxpZGF0aW9uRXJyb3IpIHtcbiAgICAgIHNldFZhbGlkYXRpb25FcnJvcihudWxsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobmFtZSAhPT0gbmV3TmFtZSkge1xuICAgICAgb25DaGFuZ2UobmV3TmFtZSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IG9uSW5wdXRDaGFuZ2UgPSAoZXZlbnQ6IFJlYWN0LlN5bnRoZXRpY0V2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3QgbmV3TmFtZSA9IGV2ZW50LmN1cnJlbnRUYXJnZXQudmFsdWUudHJpbSgpO1xuXG4gICAgaWYgKG5ld05hbWUubGVuZ3RoID09PSAwKSB7XG4gICAgICBzZXRWYWxpZGF0aW9uRXJyb3IoJ0FuIGVtcHR5IGxheWVyIG5hbWUgaXMgbm90IGFsbG93ZWQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodmVyaWZ5TGF5ZXJOYW1lVW5pcXVlbmVzcyAmJiAhdmVyaWZ5TGF5ZXJOYW1lVW5pcXVlbmVzcyhuZXdOYW1lKSAmJiBuZXdOYW1lICE9PSBuYW1lKSB7XG4gICAgICBzZXRWYWxpZGF0aW9uRXJyb3IoJ0xheWVyIG5hbWUgYWxyZWFkeSBleGlzdHMnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodmFsaWRhdGlvbkVycm9yKSB7XG4gICAgICBzZXRWYWxpZGF0aW9uRXJyb3IobnVsbCk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IG9uRWRpdExheWVyQmx1ciA9IChldmVudDogUmVhY3QuU3ludGhldGljRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcbiAgICBvbkVuZEVkaXROYW1lKGV2ZW50LmN1cnJlbnRUYXJnZXQudmFsdWUudHJpbSgpKTtcbiAgfTtcblxuICBjb25zdCBvbktleURvd24gPSAoZXZlbnQ6IFJlYWN0LktleWJvYXJkRXZlbnQpID0+IHtcbiAgICBpZiAoZXZlbnQua2V5ID09PSAnRW50ZXInKSB7XG4gICAgICBvbkVuZEVkaXROYW1lKChldmVudC50YXJnZXQgYXMgYW55KS52YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IG9uRm9jdXMgPSAoZXZlbnQ6IFJlYWN0LkZvY3VzRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcbiAgICBldmVudC50YXJnZXQuc2VsZWN0KCk7XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy53cmFwcGVyfT5cbiAgICAgICAgeyFpc0VkaXRpbmcgJiYgKFxuICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLmxheWVyTmFtZVdyYXBwZXJ9XG4gICAgICAgICAgICB0aXRsZT1cIkVkaXQgbGF5ZXIgbmFtZVwiXG4gICAgICAgICAgICBvbkNsaWNrPXtvbkVkaXRMYXllcn1cbiAgICAgICAgICAgIGRhdGEtdGVzdGlkPVwibGF5ZXItbmFtZS1kaXZcIlxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17c3R5bGVzLmxheWVyTmFtZX0+e25hbWV9PC9zcGFuPlxuICAgICAgICAgICAgPEljb24gbmFtZT1cInBlblwiIGNsYXNzTmFtZT17c3R5bGVzLmxheWVyRWRpdEljb259IHNpemU9XCJzbVwiIC8+XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICl9XG5cbiAgICAgICAge2lzRWRpdGluZyAmJiAoXG4gICAgICAgICAgPD5cbiAgICAgICAgICAgIDxJbnB1dFxuICAgICAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZT17bmFtZX1cbiAgICAgICAgICAgICAgb25CbHVyPXtvbkVkaXRMYXllckJsdXJ9XG4gICAgICAgICAgICAgIGF1dG9Gb2N1c1xuICAgICAgICAgICAgICBvbktleURvd249e29uS2V5RG93bn1cbiAgICAgICAgICAgICAgb25Gb2N1cz17b25Gb2N1c31cbiAgICAgICAgICAgICAgaW52YWxpZD17dmFsaWRhdGlvbkVycm9yICE9PSBudWxsfVxuICAgICAgICAgICAgICBvbkNoYW5nZT17b25JbnB1dENoYW5nZX1cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMubGF5ZXJOYW1lSW5wdXR9XG4gICAgICAgICAgICAgIGRhdGEtdGVzdGlkPVwibGF5ZXItbmFtZS1pbnB1dFwiXG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAge3ZhbGlkYXRpb25FcnJvciAmJiA8RmllbGRWYWxpZGF0aW9uTWVzc2FnZSBob3Jpem9udGFsPnt2YWxpZGF0aW9uRXJyb3J9PC9GaWVsZFZhbGlkYXRpb25NZXNzYWdlPn1cbiAgICAgICAgICA8Lz5cbiAgICAgICAgKX1cbiAgICAgIDwvZGl2PlxuICAgIDwvPlxuICApO1xufTtcblxuY29uc3QgZ2V0U3R5bGVzID0gKHRoZW1lOiBHcmFmYW5hVGhlbWUpID0+IHtcbiAgcmV0dXJuIHtcbiAgICB3cmFwcGVyOiBjc3NgXG4gICAgICBsYWJlbDogV3JhcHBlcjtcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgbWFyZ2luLWxlZnQ6ICR7dGhlbWUuc3BhY2luZy54c307XG4gICAgYCxcbiAgICBsYXllck5hbWVXcmFwcGVyOiBjc3NgXG4gICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgYm9yZGVyOiAxcHggc29saWQgdHJhbnNwYXJlbnQ7XG4gICAgICBib3JkZXItcmFkaXVzOiAke3RoZW1lLmJvcmRlci5yYWRpdXMubWR9O1xuICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgIHBhZGRpbmc6IDAgMCAwICR7dGhlbWUuc3BhY2luZy54c307XG4gICAgICBtYXJnaW46IDA7XG4gICAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcblxuICAgICAgJjpob3ZlciB7XG4gICAgICAgIGJhY2tncm91bmQ6ICR7dGhlbWUuY29sb3JzLmJnM307XG4gICAgICAgIGJvcmRlcjogMXB4IGRhc2hlZCAke3RoZW1lLmNvbG9ycy5ib3JkZXIzfTtcbiAgICAgIH1cblxuICAgICAgJjpmb2N1cyB7XG4gICAgICAgIGJvcmRlcjogMnB4IHNvbGlkICR7dGhlbWUuY29sb3JzLmZvcm1JbnB1dEJvcmRlckFjdGl2ZX07XG4gICAgICB9XG5cbiAgICAgICY6aG92ZXIsXG4gICAgICAmOmZvY3VzIHtcbiAgICAgICAgLnF1ZXJ5LW5hbWUtZWRpdC1pY29uIHtcbiAgICAgICAgICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgYCxcbiAgICBsYXllck5hbWU6IGNzc2BcbiAgICAgIGZvbnQtd2VpZ2h0OiAke3RoZW1lLnR5cG9ncmFwaHkud2VpZ2h0LnNlbWlib2xkfTtcbiAgICAgIGNvbG9yOiAke3RoZW1lLmNvbG9ycy50ZXh0Qmx1ZX07XG4gICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgbWFyZ2luLWxlZnQ6ICR7dGhlbWUuc3BhY2luZy54c307XG4gICAgYCxcbiAgICBsYXllckVkaXRJY29uOiBjeChcbiAgICAgIGNzc2BcbiAgICAgICAgbWFyZ2luLWxlZnQ6ICR7dGhlbWUuc3BhY2luZy5tZH07XG4gICAgICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgICAgIGAsXG4gICAgICAncXVlcnktbmFtZS1lZGl0LWljb24nXG4gICAgKSxcbiAgICBsYXllck5hbWVJbnB1dDogY3NzYFxuICAgICAgbWF4LXdpZHRoOiAzMDBweDtcbiAgICAgIG1hcmdpbjogLTRweCAwO1xuICAgIGAsXG4gIH07XG59O1xuIiwiaW1wb3J0IFJlYWN0LCB7IFB1cmVDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IEJ1dHRvbiB9IGZyb20gJ0BncmFmYW5hL3VpJztcbmltcG9ydCB7IERpbWVuc2lvbkNvbnRleHQgfSBmcm9tICdhcHAvZmVhdHVyZXMvZGltZW5zaW9ucy9jb250ZXh0JztcbmltcG9ydCB7IFRleHREaW1lbnNpb25FZGl0b3IgfSBmcm9tICdhcHAvZmVhdHVyZXMvZGltZW5zaW9ucy9lZGl0b3JzL1RleHREaW1lbnNpb25FZGl0b3InO1xuaW1wb3J0IHsgVGV4dERpbWVuc2lvbkNvbmZpZyB9IGZyb20gJ2FwcC9mZWF0dXJlcy9kaW1lbnNpb25zL3R5cGVzJztcbmltcG9ydCB7IEFQSUVkaXRvciwgQVBJRWRpdG9yQ29uZmlnLCBjYWxsQXBpIH0gZnJvbSAnYXBwL3BsdWdpbnMvcGFuZWwvY2FudmFzL2VkaXRvci9BUElFZGl0b3InO1xuXG5pbXBvcnQgeyBDYW52YXNFbGVtZW50SXRlbSwgQ2FudmFzRWxlbWVudFByb3BzIH0gZnJvbSAnLi4vZWxlbWVudCc7XG5cbmludGVyZmFjZSBCdXR0b25EYXRhIHtcbiAgdGV4dD86IHN0cmluZztcbiAgYXBpPzogQVBJRWRpdG9yQ29uZmlnO1xufVxuXG5pbnRlcmZhY2UgQnV0dG9uQ29uZmlnIHtcbiAgdGV4dD86IFRleHREaW1lbnNpb25Db25maWc7XG4gIGFwaT86IEFQSUVkaXRvckNvbmZpZztcbn1cblxuY2xhc3MgQnV0dG9uRGlzcGxheSBleHRlbmRzIFB1cmVDb21wb25lbnQ8Q2FudmFzRWxlbWVudFByb3BzPEJ1dHRvbkNvbmZpZywgQnV0dG9uRGF0YT4+IHtcbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgZGF0YSB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBvbkNsaWNrID0gKCkgPT4ge1xuICAgICAgaWYgKGRhdGE/LmFwaSkge1xuICAgICAgICBjYWxsQXBpKGRhdGEuYXBpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxCdXR0b24gdHlwZT1cInN1Ym1pdFwiIG9uQ2xpY2s9e29uQ2xpY2t9PlxuICAgICAgICB7ZGF0YT8udGV4dH1cbiAgICAgIDwvQnV0dG9uPlxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGJ1dHRvbkl0ZW06IENhbnZhc0VsZW1lbnRJdGVtPEJ1dHRvbkNvbmZpZywgQnV0dG9uRGF0YT4gPSB7XG4gIGlkOiAnYnV0dG9uJyxcbiAgbmFtZTogJ0J1dHRvbicsXG4gIGRlc2NyaXB0aW9uOiAnQnV0dG9uJyxcblxuICBkaXNwbGF5OiBCdXR0b25EaXNwbGF5LFxuXG4gIGRlZmF1bHRTaXplOiB7XG4gICAgd2lkdGg6IDIwMCxcbiAgICBoZWlnaHQ6IDUwLFxuICB9LFxuXG4gIGdldE5ld09wdGlvbnM6IChvcHRpb25zKSA9PiAoe1xuICAgIC4uLm9wdGlvbnMsXG4gIH0pLFxuXG4gIC8vIENhbGxlZCB3aGVuIGRhdGEgY2hhbmdlc1xuICBwcmVwYXJlRGF0YTogKGN0eDogRGltZW5zaW9uQ29udGV4dCwgY2ZnOiBCdXR0b25Db25maWcpID0+IHtcbiAgICBjb25zdCBkYXRhOiBCdXR0b25EYXRhID0ge1xuICAgICAgdGV4dDogY2ZnPy50ZXh0ID8gY3R4LmdldFRleHQoY2ZnLnRleHQpLnZhbHVlKCkgOiAnJyxcbiAgICAgIGFwaTogY2ZnPy5hcGkgPz8gdW5kZWZpbmVkLFxuICAgIH07XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfSxcblxuICAvLyBIZWF0bWFwIG92ZXJsYXkgb3B0aW9uc1xuICByZWdpc3Rlck9wdGlvbnNVSTogKGJ1aWxkZXIpID0+IHtcbiAgICBjb25zdCBjYXRlZ29yeSA9IFsnQnV0dG9uJ107XG4gICAgYnVpbGRlclxuICAgICAgLmFkZEN1c3RvbUVkaXRvcih7XG4gICAgICAgIGNhdGVnb3J5LFxuICAgICAgICBpZDogJ3RleHRTZWxlY3RvcicsXG4gICAgICAgIHBhdGg6ICdjb25maWcudGV4dCcsXG4gICAgICAgIG5hbWU6ICdUZXh0JyxcbiAgICAgICAgZWRpdG9yOiBUZXh0RGltZW5zaW9uRWRpdG9yLFxuICAgICAgfSlcbiAgICAgIC5hZGRDdXN0b21FZGl0b3Ioe1xuICAgICAgICBjYXRlZ29yeSxcbiAgICAgICAgaWQ6ICdhcGlTZWxlY3RvcicsXG4gICAgICAgIHBhdGg6ICdjb25maWcuYXBpJyxcbiAgICAgICAgbmFtZTogJ0FQSScsXG4gICAgICAgIGVkaXRvcjogQVBJRWRpdG9yLFxuICAgICAgfSk7XG4gIH0sXG59O1xuIiwiaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCBSZWFjdCwgeyBGQyB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgR3JhZmFuYVRoZW1lMiB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgdXNlU3R5bGVzMiB9IGZyb20gJ0BncmFmYW5hL3VpJztcbmltcG9ydCB7IERpbWVuc2lvbkNvbnRleHQsIFNjYWxhckRpbWVuc2lvbkNvbmZpZyB9IGZyb20gJ2FwcC9mZWF0dXJlcy9kaW1lbnNpb25zJztcbmltcG9ydCB7IFNjYWxhckRpbWVuc2lvbkVkaXRvciB9IGZyb20gJ2FwcC9mZWF0dXJlcy9kaW1lbnNpb25zL2VkaXRvcnMnO1xuXG5pbXBvcnQgeyBDYW52YXNFbGVtZW50SXRlbSwgQ2FudmFzRWxlbWVudFByb3BzIH0gZnJvbSAnLi4vZWxlbWVudCc7XG5cbmludGVyZmFjZSBEcm9uZUZyb250RGF0YSB7XG4gIHJvbGxBbmdsZT86IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIERyb25lRnJvbnRDb25maWcge1xuICByb2xsQW5nbGU/OiBTY2FsYXJEaW1lbnNpb25Db25maWc7XG59XG5cbmNvbnN0IERyb25lRnJvbnREaXNwbGF5OiBGQzxDYW52YXNFbGVtZW50UHJvcHM8RHJvbmVGcm9udENvbmZpZywgRHJvbmVGcm9udERhdGE+PiA9IChwcm9wcykgPT4ge1xuICBjb25zdCBzdHlsZXMgPSB1c2VTdHlsZXMyKGdldFN0eWxlcyk7XG5cbiAgY29uc3QgeyBkYXRhIH0gPSBwcm9wcztcblxuICBjb25zdCBkcm9uZUZyb250VHJhbnNmb3JtU3R5bGUgPSBgcm90YXRlKCR7ZGF0YT8ucm9sbEFuZ2xlID8gZGF0YS5yb2xsQW5nbGUgOiAwfWRlZylgO1xuXG4gIHJldHVybiAoXG4gICAgPHN2Z1xuICAgICAgY2xhc3NOYW1lPXtzdHlsZXMuZHJvbmVGcm9udH1cbiAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgICAgeG1sbnNYbGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIlxuICAgICAgdmlld0JveD1cIjAgMCAxMzAwIDI5MFwiXG4gICAgICBzdHlsZT17eyB0cmFuc2Zvcm06IGRyb25lRnJvbnRUcmFuc2Zvcm1TdHlsZSB9fVxuICAgID5cbiAgICAgIDxnIGNsYXNzTmFtZT1cImFybXNcIiBzdHJva2U9XCJibGFja1wiIHN0cm9rZVdpZHRoPVwiMjhweFwiPlxuICAgICAgICA8bGluZSB4MT1cIjUxMFwiIHgyPVwiMzIwXCIgeTE9XCIxMDBcIiB5Mj1cIjE1MFwiIC8+XG4gICAgICAgIDxsaW5lIHgxPVwiNTEwXCIgeDI9XCIzMjBcIiB5MT1cIjE5MFwiIHkyPVwiMjEwXCIgLz5cbiAgICAgICAgPGxpbmUgeDE9XCI3OTBcIiB4Mj1cIjk4MFwiIHkxPVwiMTkwXCIgeTI9XCIyMTBcIiAvPlxuICAgICAgICA8bGluZSB4MT1cIjc5MFwiIHgyPVwiOTgwXCIgeTE9XCIxMDBcIiB5Mj1cIjE1MFwiIC8+XG4gICAgICA8L2c+XG4gICAgICA8ZyBjbGFzc05hbWU9XCJib2R5XCIgc3Ryb2tlPVwiYmxhY2tcIiBzdHJva2VXaWR0aD1cIjI4cHhcIj5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgICAgZD1cIiBNIDUxMCAxMzAgQyA1MTAgMTI0IDUxMCAxMTAgNTEwIDEwMCBDIDUxMCA5MCA1MzAgNzEgNTQwIDcwIEMgNjQwIDYxIDY3MCA2MCA3NjAgNzAgQyA3NzAgNzEgNzkwIDkwIDc5MCAxMDAgUSA3OTAgMTIwIDc5MCAxMzAgTCA3OTAgMTMwIFEgNzkwIDE3NyA3OTAgMTk2IEMgNzkwIDIwNyA3NzAgMjI1IDc2MCAyMjYgQyA2NzAgMjM2IDY0MCAyMzYgNTQwIDIyNiBDIDUzMCAyMjYgNTEwIDIwNiA1MTAgMTk2IFEgNTEwIDE3NyA1MTAgMTMwIFEgNTEwIDEzMyA1MTAgMTMwIFogXCJcbiAgICAgICAgLz5cbiAgICAgICAgPGNpcmNsZSBjeD1cIjY1MFwiIGN5PVwiMTYwXCIgcj1cIjQwXCIgZmlsbD1cIm5vbmVcIiAvPlxuICAgICAgPC9nPlxuICAgICAgPGcgY2xhc3NOYW1lPVwibW90b3JzXCIgc3Ryb2tlPVwiYmxhY2tcIiBzdHJva2VXaWR0aD1cIjI4cHhcIj5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICBjbGFzc05hbWU9XCJtb3RvclwiXG4gICAgICAgICAgZmlsbD1cIm5vbmVcIlxuICAgICAgICAgIGQ9XCIgTSAzMjAgNjAgTCAyNTAgNjAgTCAyNTAgMjMwIEwgMjYwIDI5MCBMIDMxMCAyOTAgTCAzMjAgMjMwIEwgMzIwIDYwIFogXCJcbiAgICAgICAgLz5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICBjbGFzc05hbWU9XCJtb3RvclwiXG4gICAgICAgICAgZmlsbD1cIm5vbmVcIlxuICAgICAgICAgIGQ9XCIgTSAxMDUwIDYwIEwgOTgwIDYwIEwgOTgwIDIzMCBMIDk5MCAyOTAgTCAxMDQwIDI5MCBMIDEwNTAgMjMwIEwgMTA1MCA2MCBaIFwiXG4gICAgICAgIC8+XG4gICAgICA8L2c+XG4gICAgICA8ZyBjbGFzc05hbWU9XCJwcm9wZWxsZXJzXCIgZmlsbD1cImJsYWNrXCI+XG4gICAgICAgIDxwYXRoXG4gICAgICAgICAgY2xhc3NOYW1lPVwicHJvcFwiXG4gICAgICAgICAgZD1cIiBNIDI3MCA2MCBMIDMwMCA2MCBMIDMwMCAyMCBRIDMxMSAzMCAzMzAgMzAgUSAzNDkgMzAgNTcwIDEwIEwgMzAwIDEwIFEgMzAwIDAgMjkwIDAgQyAyODYgMCAyODQgMCAyODAgMCBRIDI3MCAwIDI3MCAxMCBMIDAgMTAgUSAyMjAgMzAgMjQwIDMwIFEgMjYwIDMwIDI3MCAyMCBMIDI3MCA2MCBaIFwiXG4gICAgICAgIC8+XG4gICAgICAgIDxwYXRoXG4gICAgICAgICAgY2xhc3NOYW1lPVwicHJvcFwiXG4gICAgICAgICAgZD1cIiBNIDEwMDAgNjAgTCAxMDMwIDYwIEwgMTAzMCAyMCBRIDEwNDEgMzAgMTA2MCAzMCBRIDEwNzkgMzAgMTMwMCAxMCBMIDEwMzAgMTAgUSAxMDMwIDAgMTAyMCAwIEMgMTAxNiAwIDEwMTQgMCAxMDEwIDAgUSAxMDAwIDAgMTAwMCAxMCBMIDczMCAxMCBRIDk1MCAzMCA5NzAgMzAgUSA5OTAgMzAgMTAwMCAyMCBMIDEwMDAgNjAgWiBcIlxuICAgICAgICAvPlxuICAgICAgPC9nPlxuICAgIDwvc3ZnPlxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IGRyb25lRnJvbnRJdGVtOiBDYW52YXNFbGVtZW50SXRlbTxhbnksIGFueT4gPSB7XG4gIGlkOiAnZHJvbmVGcm9udCcsXG4gIG5hbWU6ICdEcm9uZSBGcm9udCcsXG4gIGRlc2NyaXB0aW9uOiAnRHJvbmUgZnJvbnQnLFxuXG4gIGRpc3BsYXk6IERyb25lRnJvbnREaXNwbGF5LFxuXG4gIGRlZmF1bHRTaXplOiB7XG4gICAgd2lkdGg6IDEwMCxcbiAgICBoZWlnaHQ6IDEwMCxcbiAgfSxcblxuICBnZXROZXdPcHRpb25zOiAob3B0aW9ucykgPT4gKHtcbiAgICAuLi5vcHRpb25zLFxuICB9KSxcblxuICAvLyBDYWxsZWQgd2hlbiBkYXRhIGNoYW5nZXNcbiAgcHJlcGFyZURhdGE6IChjdHg6IERpbWVuc2lvbkNvbnRleHQsIGNmZzogRHJvbmVGcm9udENvbmZpZykgPT4ge1xuICAgIGNvbnN0IGRhdGE6IERyb25lRnJvbnREYXRhID0ge1xuICAgICAgcm9sbEFuZ2xlOiBjZmc/LnJvbGxBbmdsZSA/IGN0eC5nZXRTY2FsYXIoY2ZnLnJvbGxBbmdsZSkudmFsdWUoKSA6IDAsXG4gICAgfTtcblxuICAgIHJldHVybiBkYXRhO1xuICB9LFxuXG4gIHJlZ2lzdGVyT3B0aW9uc1VJOiAoYnVpbGRlcikgPT4ge1xuICAgIGNvbnN0IGNhdGVnb3J5ID0gWydEcm9uZSBGcm9udCddO1xuICAgIGJ1aWxkZXIuYWRkQ3VzdG9tRWRpdG9yKHtcbiAgICAgIGNhdGVnb3J5LFxuICAgICAgaWQ6ICdyb2xsQW5nbGUnLFxuICAgICAgcGF0aDogJ2NvbmZpZy5yb2xsQW5nbGUnLFxuICAgICAgbmFtZTogJ1JvbGwgQW5nbGUnLFxuICAgICAgZWRpdG9yOiBTY2FsYXJEaW1lbnNpb25FZGl0b3IsXG4gICAgfSk7XG4gIH0sXG59O1xuXG5jb25zdCBnZXRTdHlsZXMgPSAodGhlbWU6IEdyYWZhbmFUaGVtZTIpID0+ICh7XG4gIGRyb25lRnJvbnQ6IGNzc2BcbiAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC40cztcbiAgYCxcbn0pO1xuIiwiaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCBSZWFjdCwgeyBGQyB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgR3JhZmFuYVRoZW1lMiB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgdXNlU3R5bGVzMiB9IGZyb20gJ0BncmFmYW5hL3VpJztcbmltcG9ydCB7IERpbWVuc2lvbkNvbnRleHQsIFNjYWxhckRpbWVuc2lvbkNvbmZpZyB9IGZyb20gJ2FwcC9mZWF0dXJlcy9kaW1lbnNpb25zJztcbmltcG9ydCB7IFNjYWxhckRpbWVuc2lvbkVkaXRvciB9IGZyb20gJ2FwcC9mZWF0dXJlcy9kaW1lbnNpb25zL2VkaXRvcnMnO1xuXG5pbXBvcnQgeyBDYW52YXNFbGVtZW50SXRlbSwgQ2FudmFzRWxlbWVudFByb3BzIH0gZnJvbSAnLi4vZWxlbWVudCc7XG5cbmludGVyZmFjZSBEcm9uZVNpZGVEYXRhIHtcbiAgcGl0Y2hBbmdsZT86IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIERyb25lU2lkZUNvbmZpZyB7XG4gIHBpdGNoQW5nbGU/OiBTY2FsYXJEaW1lbnNpb25Db25maWc7XG59XG5cbmNvbnN0IERyb25lU2lkZURpc3BsYXk6IEZDPENhbnZhc0VsZW1lbnRQcm9wczxEcm9uZVNpZGVDb25maWcsIERyb25lU2lkZURhdGE+PiA9IChwcm9wcykgPT4ge1xuICBjb25zdCBzdHlsZXMgPSB1c2VTdHlsZXMyKGdldFN0eWxlcyk7XG5cbiAgY29uc3QgeyBkYXRhIH0gPSBwcm9wcztcblxuICBjb25zdCBkcm9uZVNpZGVQaXRjaFRyYW5zZm9ybVN0eWxlID0gYHJvdGF0ZSgke2RhdGE/LnBpdGNoQW5nbGUgPyBkYXRhLnBpdGNoQW5nbGUgOiAwfWRlZylgO1xuXG4gIHJldHVybiAoXG4gICAgPHN2Z1xuICAgICAgY2xhc3NOYW1lPXtzdHlsZXMuZHJvbmVTaWRlfVxuICAgICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICAgICB4bWxuc1hsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiXG4gICAgICB2aWV3Qm94PVwiMCAwIDEzMDAgMjkwXCJcbiAgICAgIHN0eWxlPXt7IHRyYW5zZm9ybTogZHJvbmVTaWRlUGl0Y2hUcmFuc2Zvcm1TdHlsZSB9fVxuICAgID5cbiAgICAgIDxnIGNsYXNzTmFtZT1cImFybXNcIiBzdHJva2U9XCJibGFja1wiIHN0cm9rZVdpZHRoPVwiMjhweFwiPlxuICAgICAgICA8bGluZSB4MT1cIjUxMFwiIHgyPVwiMzIwXCIgeTE9XCIxMDBcIiB5Mj1cIjE1MFwiIC8+XG4gICAgICAgIDxsaW5lIHgxPVwiNTEwXCIgeDI9XCIzMjBcIiB5MT1cIjE5MFwiIHkyPVwiMjEwXCIgLz5cbiAgICAgICAgPGxpbmUgeDE9XCI3OTBcIiB4Mj1cIjk4MFwiIHkxPVwiMTkwXCIgeTI9XCIyMTBcIiAvPlxuICAgICAgICA8bGluZSB4MT1cIjc5MFwiIHgyPVwiOTgwXCIgeTE9XCIxMDBcIiB5Mj1cIjE1MFwiIC8+XG4gICAgICA8L2c+XG4gICAgICA8ZyBjbGFzc05hbWU9XCJib2R5XCIgc3Ryb2tlPVwiYmxhY2tcIiBzdHJva2VXaWR0aD1cIjI4cHhcIj5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgICAgZD1cIiBNIDUxMCAxMzAgQyA1MTAgMTI0IDUxMCAxMTAgNTEwIDEwMCBDIDUxMCA5MCA1MzAgNzEgNTQwIDcwIEMgNjQwIDYxIDY3MCA2MCA3NjAgNzAgQyA3NzAgNzEgNzkwIDkwIDc5MCAxMDAgUSA3OTAgMTIwIDc5MCAxMzAgTCA3OTAgMTMwIFEgNzkwIDE3NyA3OTAgMTk2IEMgNzkwIDIwNyA3NzAgMjI1IDc2MCAyMjYgQyA2NzAgMjM2IDY0MCAyMzYgNTQwIDIyNiBDIDUzMCAyMjYgNTEwIDIwNiA1MTAgMTk2IFEgNTEwIDE3NyA1MTAgMTMwIFEgNTEwIDEzMyA1MTAgMTMwIFogXCJcbiAgICAgICAgLz5cbiAgICAgIDwvZz5cbiAgICAgIDxnIGNsYXNzTmFtZT1cIm1vdG9yc1wiIHN0cm9rZT1cImJsYWNrXCIgc3Ryb2tlV2lkdGg9XCIyOHB4XCI+XG4gICAgICAgIDxwYXRoXG4gICAgICAgICAgY2xhc3NOYW1lPVwibW90b3JcIlxuICAgICAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgICAgICBkPVwiIE0gMzIwIDYwIEwgMjUwIDYwIEwgMjUwIDIzMCBMIDI2MCAyOTAgTCAzMTAgMjkwIEwgMzIwIDIzMCBMIDMyMCA2MCBaIFwiXG4gICAgICAgIC8+XG4gICAgICAgIDxwYXRoXG4gICAgICAgICAgY2xhc3NOYW1lPVwibW90b3JcIlxuICAgICAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgICAgICBkPVwiIE0gMTA1MCA2MCBMIDk4MCA2MCBMIDk4MCAyMzAgTCA5OTAgMjkwIEwgMTA0MCAyOTAgTCAxMDUwIDIzMCBMIDEwNTAgNjAgWiBcIlxuICAgICAgICAvPlxuICAgICAgPC9nPlxuICAgICAgPGcgY2xhc3NOYW1lPVwicHJvcGVsbGVyc1wiIGZpbGw9XCJibGFja1wiPlxuICAgICAgICA8cGF0aFxuICAgICAgICAgIGNsYXNzTmFtZT1cInByb3BcIlxuICAgICAgICAgIGQ9XCIgTSAyNzAgNjAgTCAzMDAgNjAgTCAzMDAgMjAgUSAzMTEgMzAgMzMwIDMwIFEgMzQ5IDMwIDU3MCAxMCBMIDMwMCAxMCBRIDMwMCAwIDI5MCAwIEMgMjg2IDAgMjg0IDAgMjgwIDAgUSAyNzAgMCAyNzAgMTAgTCAwIDEwIFEgMjIwIDMwIDI0MCAzMCBRIDI2MCAzMCAyNzAgMjAgTCAyNzAgNjAgWiBcIlxuICAgICAgICAvPlxuICAgICAgICA8cGF0aFxuICAgICAgICAgIGNsYXNzTmFtZT1cInByb3BcIlxuICAgICAgICAgIGQ9XCIgTSAxMDAwIDYwIEwgMTAzMCA2MCBMIDEwMzAgMjAgUSAxMDQxIDMwIDEwNjAgMzAgUSAxMDc5IDMwIDEzMDAgMTAgTCAxMDMwIDEwIFEgMTAzMCAwIDEwMjAgMCBDIDEwMTYgMCAxMDE0IDAgMTAxMCAwIFEgMTAwMCAwIDEwMDAgMTAgTCA3MzAgMTAgUSA5NTAgMzAgOTcwIDMwIFEgOTkwIDMwIDEwMDAgMjAgTCAxMDAwIDYwIFogXCJcbiAgICAgICAgLz5cbiAgICAgIDwvZz5cbiAgICA8L3N2Zz5cbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBkcm9uZVNpZGVJdGVtOiBDYW52YXNFbGVtZW50SXRlbTxhbnksIGFueT4gPSB7XG4gIGlkOiAnZHJvbmVTaWRlJyxcbiAgbmFtZTogJ0Ryb25lIFNpZGUnLFxuICBkZXNjcmlwdGlvbjogJ0Ryb25lIFNpZGUnLFxuXG4gIGRpc3BsYXk6IERyb25lU2lkZURpc3BsYXksXG5cbiAgZGVmYXVsdFNpemU6IHtcbiAgICB3aWR0aDogMTAwLFxuICAgIGhlaWdodDogMTAwLFxuICB9LFxuXG4gIGdldE5ld09wdGlvbnM6IChvcHRpb25zKSA9PiAoe1xuICAgIC4uLm9wdGlvbnMsXG4gIH0pLFxuXG4gIC8vIENhbGxlZCB3aGVuIGRhdGEgY2hhbmdlc1xuICBwcmVwYXJlRGF0YTogKGN0eDogRGltZW5zaW9uQ29udGV4dCwgY2ZnOiBEcm9uZVNpZGVDb25maWcpID0+IHtcbiAgICBjb25zdCBkYXRhOiBEcm9uZVNpZGVEYXRhID0ge1xuICAgICAgcGl0Y2hBbmdsZTogY2ZnPy5waXRjaEFuZ2xlID8gY3R4LmdldFNjYWxhcihjZmcucGl0Y2hBbmdsZSkudmFsdWUoKSA6IDAsXG4gICAgfTtcblxuICAgIHJldHVybiBkYXRhO1xuICB9LFxuXG4gIHJlZ2lzdGVyT3B0aW9uc1VJOiAoYnVpbGRlcikgPT4ge1xuICAgIGNvbnN0IGNhdGVnb3J5ID0gWydEcm9uZSBTaWRlJ107XG4gICAgYnVpbGRlci5hZGRDdXN0b21FZGl0b3Ioe1xuICAgICAgY2F0ZWdvcnksXG4gICAgICBpZDogJ3BpdGNoQW5nbGUnLFxuICAgICAgcGF0aDogJ2NvbmZpZy5waXRjaEFuZ2xlJyxcbiAgICAgIG5hbWU6ICdQaXRjaCBBbmdsZScsXG4gICAgICBlZGl0b3I6IFNjYWxhckRpbWVuc2lvbkVkaXRvcixcbiAgICB9KTtcbiAgfSxcbn07XG5cbmNvbnN0IGdldFN0eWxlcyA9ICh0aGVtZTogR3JhZmFuYVRoZW1lMikgPT4gKHtcbiAgZHJvbmVTaWRlOiBjc3NgXG4gICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuNHM7XG4gIGAsXG59KTtcbiIsImltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgUmVhY3QsIHsgRkMgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IEdyYWZhbmFUaGVtZTIgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IHVzZVN0eWxlczIgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5pbXBvcnQgeyBEaW1lbnNpb25Db250ZXh0LCBTY2FsYXJEaW1lbnNpb25Db25maWcgfSBmcm9tICdhcHAvZmVhdHVyZXMvZGltZW5zaW9ucyc7XG5pbXBvcnQgeyBTY2FsYXJEaW1lbnNpb25FZGl0b3IgfSBmcm9tICdhcHAvZmVhdHVyZXMvZGltZW5zaW9ucy9lZGl0b3JzJztcblxuaW1wb3J0IHsgQ2FudmFzRWxlbWVudEl0ZW0sIENhbnZhc0VsZW1lbnRQcm9wcyB9IGZyb20gJy4uL2VsZW1lbnQnO1xuXG5pbnRlcmZhY2UgRHJvbmVUb3BEYXRhIHtcbiAgYlJpZ2h0Um90b3JSUE0/OiBudW1iZXI7XG4gIGJMZWZ0Um90b3JSUE0/OiBudW1iZXI7XG4gIGZSaWdodFJvdG9yUlBNPzogbnVtYmVyO1xuICBmTGVmdFJvdG9yUlBNPzogbnVtYmVyO1xuICB5YXdBbmdsZT86IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIERyb25lVG9wQ29uZmlnIHtcbiAgYlJpZ2h0Um90b3JSUE0/OiBTY2FsYXJEaW1lbnNpb25Db25maWc7XG4gIGJMZWZ0Um90b3JSUE0/OiBTY2FsYXJEaW1lbnNpb25Db25maWc7XG4gIGZSaWdodFJvdG9yUlBNPzogU2NhbGFyRGltZW5zaW9uQ29uZmlnO1xuICBmTGVmdFJvdG9yUlBNPzogU2NhbGFyRGltZW5zaW9uQ29uZmlnO1xuICB5YXdBbmdsZT86IFNjYWxhckRpbWVuc2lvbkNvbmZpZztcbn1cblxuY29uc3QgRHJvbmVUb3BEaXNwbGF5OiBGQzxDYW52YXNFbGVtZW50UHJvcHM8RHJvbmVUb3BDb25maWcsIERyb25lVG9wRGF0YT4+ID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHN0eWxlcyA9IHVzZVN0eWxlczIoZ2V0U3R5bGVzKTtcblxuICBjb25zdCB7IGRhdGEgfSA9IHByb3BzO1xuXG4gIGNvbnN0IGZSaWdodFJvdG9yQW5pbWF0aW9uID0gYHNwaW4gJHtkYXRhPy5mUmlnaHRSb3RvclJQTSA/IDYwIC8gTWF0aC5hYnMoZGF0YS5mUmlnaHRSb3RvclJQTSkgOiAwfXMgbGluZWFyIGluZmluaXRlYDtcblxuICBjb25zdCBmTGVmdFJvdG9yQW5pbWF0aW9uID0gYHNwaW4gJHtkYXRhPy5mTGVmdFJvdG9yUlBNID8gNjAgLyBNYXRoLmFicyhkYXRhLmZMZWZ0Um90b3JSUE0pIDogMH1zIGxpbmVhciBpbmZpbml0ZWA7XG5cbiAgY29uc3QgYlJpZ2h0Um90b3JBbmltYXRpb24gPSBgc3BpbiAke2RhdGE/LmJSaWdodFJvdG9yUlBNID8gNjAgLyBNYXRoLmFicyhkYXRhLmJSaWdodFJvdG9yUlBNKSA6IDB9cyBsaW5lYXIgaW5maW5pdGVgO1xuXG4gIGNvbnN0IGJMZWZ0Um90b3JBbmltYXRpb24gPSBgc3BpbiAke2RhdGE/LmJMZWZ0Um90b3JSUE0gPyA2MCAvIE1hdGguYWJzKGRhdGEuYkxlZnRSb3RvclJQTSkgOiAwfXMgbGluZWFyIGluZmluaXRlYDtcblxuICBjb25zdCBkcm9uZVRvcFRyYW5zZm9ybVN0eWxlID0gYHJvdGF0ZSgke2RhdGE/Lnlhd0FuZ2xlID8gZGF0YS55YXdBbmdsZSA6IDB9ZGVnKWA7XG5cbiAgcmV0dXJuIChcbiAgICA8c3ZnXG4gICAgICB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgICAgIHhtbG5zWGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCJcbiAgICAgIHZpZXdCb3g9XCItNDMgLTQzIDY0MCA2NDBcIlxuICAgICAgeG1sU3BhY2U9XCJwcmVzZXJ2ZVwiXG4gICAgICBzdHlsZT17eyB0cmFuc2Zvcm06IGRyb25lVG9wVHJhbnNmb3JtU3R5bGUgfX1cbiAgICA+XG4gICAgICA8cGF0aFxuICAgICAgICBmaWxsUnVsZT1cImV2ZW5vZGRcIlxuICAgICAgICBkPVwiIE0gMTM3Ljk1IDEyNy45NjcgQyAxMzcuMTQgMTI3LjE1NyAxMzYuMTg5IDEyNi41OCAxMzUuMTc4IDEyNi4yMTggQyAxMzguMTczIDEyMS41NDUgMTM5Ljk2NyAxMTYuMDM2IDE0MC4xMjUgMTEwLjEyMyBMIDIxNy42NCAxNTEuODYyIEMgMjE0LjA0OSAxNTcuNDExIDIxMS44IDE2My45MjIgMjExLjM4NiAxNzAuOTUgTCAyMDkuNjk0IDE5OS43MTIgTCAxMzcuOTUgMTI3Ljk2NyBMIDEzNy45NSAxMjcuOTY3IEwgMTM3Ljk1IDEyNy45NjcgTCAxMzcuOTUgMTI3Ljk2NyBMIDEzNy45NSAxMjcuOTY3IEwgMTM3Ljk1IDEyNy45NjcgTCAxMzcuOTUgMTI3Ljk2NyBMIDEzNy45NSAxMjcuOTY3IEwgMTM3Ljk1IDEyNy45NjcgWiAgTSAxMzQuMjY4IDQyNi45ODEgQyAxMzAuMjExIDQyMS4zMTQgMTI0LjMyOCA0MTcuMDQ1IDExNy40ODIgNDE1LjA0MSBMIDIwMS45OTkgMzMwLjUyMyBMIDIwMS4zODUgMzQwLjk1NSBDIDIwMC42NyAzNTMuMTA3IDIwMi44MjkgMzY0LjkxNCAyMDcuNTYzIDM3NS42NzMgTCAxMzQuMjY4IDQyNi45ODEgTCAxMzQuMjY4IDQyNi45ODEgTCAxMzQuMjY4IDQyNi45ODEgTCAxMzQuMjY4IDQyNi45ODEgTCAxMzQuMjY4IDQyNi45ODEgTCAxMzQuMjY4IDQyNi45ODEgTCAxMzQuMjY4IDQyNi45ODEgTCAxMzQuMjY4IDQyNi45ODEgWiAgTSAzMjQuNzY1IDM3My42NzMgTCAyMjguNTI3IDM3My42NzMgUSAyMTUuMzc0IDM1OC42MTEgMjE2LjM2MSAzNDEuODM1IEwgMjI2LjM2MSAxNzEuODMyIEMgMjI2LjgyNSAxNjMuOTQgMjMxLjAxMiAxNTcuMDk2IDIzNy4xNDYgMTUyLjk1NyBMIDMxNi4xNDYgMTUyLjk1NyBDIDMyMi4yOCAxNTcuMDk2IDMyNi40NjYgMTYzLjk0IDMyNi45MzEgMTcxLjgzMiBMIDMzNi45MzEgMzQxLjgzNSBRIDMzNy45MTggMzU4LjYxMSAzMjQuNzY1IDM3My42NzMgTCAzMjQuNzY1IDM3My42NzMgTCAzMjQuNzY1IDM3My42NzMgTCAzMjQuNzY1IDM3My42NzMgTCAzMjQuNzY1IDM3My42NzMgTCAzMjQuNzY1IDM3My42NzMgTCAzMjQuNzY1IDM3My42NzMgWiAgTSA0MzUuODEgNDE1LjA0MSBDIDQyOC45NjQgNDE3LjA0NSA0MjMuMDgxIDQyMS4zMTQgNDE5LjAyNCA0MjYuOTgxIEwgMzQ1LjcyNyAzNzUuNjczIEMgMzUwLjQ2MSAzNjQuOTE0IDM1Mi42MiAzNTMuMTA3IDM1MS45MDUgMzQwLjk1NSBMIDM1MS4yOTEgMzMwLjUyMyBMIDQzNS44MSA0MTUuMDQxIEwgNDM1LjgxIDQxNS4wNDEgTCA0MzUuODEgNDE1LjA0MSBMIDQzNS44MSA0MTUuMDQxIEwgNDM1LjgxIDQxNS4wNDEgTCA0MzUuODEgNDE1LjA0MSBaICBNIDM0My41OTYgMTk5LjcxMyBMIDM0MS45MDQgMTcwLjk1MSBDIDM0MS40OSAxNjMuOTIzIDMzOS4yNDIgMTU3LjQxMSAzMzUuNjUxIDE1MS44NjMgTCA0MTMuMTY3IDExMC4xMjQgQyA0MTMuMzI1IDExNi4wMzcgNDE1LjExOSAxMjEuNTQ2IDQxOC4xMTQgMTI2LjIxOSBDIDQxNy4xMDMgMTI2LjU4MSA0MTYuMTUyIDEyNy4xNTggNDE1LjM0MiAxMjcuOTY4IEwgMzQzLjU5NiAxOTkuNzEzIEwgMzQzLjU5NiAxOTkuNzEzIEwgMzQzLjU5NiAxOTkuNzEzIEwgMzQzLjU5NiAxOTkuNzEzIEwgMzQzLjU5NiAxOTkuNzEzIFogIE0gNDQ0LjY0NiA5Mi43NzEgQyA0NTMuNzQ0IDkyLjc3MSA0NjEuMTQ2IDEwMC4xNzIgNDYxLjE0NiAxMDkuMjcxIEMgNDYxLjE0NiAxMTguMzY5IDQ1My43NDQgMTI1Ljc3MSA0NDQuNjQ2IDEyNS43NzEgQyA0MzUuNTQ4IDEyNS43NzEgNDI4LjE0NiAxMTguMzY5IDQyOC4xNDYgMTA5LjI3MSBDIDQyOC4xNDYgMTAwLjE3MiA0MzUuNTQ4IDkyLjc3MSA0NDQuNjQ2IDkyLjc3MSBMIDQ0NC42NDYgOTIuNzcxIEwgNDQ0LjY0NiA5Mi43NzEgTCA0NDQuNjQ2IDkyLjc3MSBaICBNIDEwOC42NDcgOTIuNzcxIEMgMTE3Ljc0NSA5Mi43NzEgMTI1LjE0NyAxMDAuMTcyIDEyNS4xNDcgMTA5LjI3MSBDIDEyNS4xNDcgMTE4LjM2OSAxMTcuNzQ1IDEyNS43NzEgMTA4LjY0NyAxMjUuNzcxIEMgOTkuNTQ5IDEyNS43NzEgOTIuMTQ3IDExOC4zNjkgOTIuMTQ3IDEwOS4yNzEgQyA5Mi4xNDcgMTAwLjE3MiA5OS41NDkgOTIuNzcxIDEwOC42NDcgOTIuNzcxIEwgMTA4LjY0NyA5Mi43NzEgTCAxMDguNjQ3IDkyLjc3MSBaICBNIDEwOC42NDcgNDYxLjc3MSBDIDk5LjU0OSA0NjEuNzcxIDkyLjE0NyA0NTQuMzY5IDkyLjE0NyA0NDUuMjcxIEMgOTIuMTQ3IDQzNi4xNzIgOTkuNTQ5IDQyOC43NzEgMTA4LjY0NyA0MjguNzcxIEMgMTE3Ljc0NSA0MjguNzcxIDEyNS4xNDcgNDM2LjE3MiAxMjUuMTQ3IDQ0NS4yNzEgQyAxMjUuMTQ3IDQ1NC4zNjkgMTE3Ljc0NSA0NjEuNzcxIDEwOC42NDcgNDYxLjc3MSBMIDEwOC42NDcgNDYxLjc3MSBaICBNIDkyLjMyMiAxMzYuMjAyIEMgOTcuMDg2IDEzOS4xIDEwMi42NzUgMTQwLjc3MSAxMDguNjQ3IDE0MC43NzEgQyAxMTQuODgzIDE0MC43NzEgMTIwLjY5NyAxMzguOTQxIDEyNS41OTQgMTM1LjgwMiBDIDEyNS45NTYgMTM2LjgxMyAxMjYuNTM0IDEzNy43NjQgMTI3LjM0MyAxMzguNTczIEwgMjA3LjM0MiAyMTguNTczIEMgMjA3LjcxMSAyMTguOTQyIDIwOC4xMDkgMjE5LjI2NCAyMDguNTI4IDIxOS41NCBMIDIwMy4yMTIgMzA5LjkwOCBDIDIwMS43OTQgMzEwLjE4MiAyMDAuNDQgMzEwLjg2OSAxOTkuMzQyIDMxMS45NjcgTCA5NS4zNDMgNDE1Ljk2NyBDIDk0Ljk1NCA0MTYuMzU2IDk0LjYyIDQxNi43NzkgOTQuMzM1IDQxNy4yMjQgQyA5My42NTEgNDE3LjU3NSA5Mi45NzYgNDE3Ljk0MiA5Mi4zMjIgNDE4LjM0IFEgODQuNjE1IDQyNC4xODIgODEuNzE2IDQyOC45NDYgQyA3OC44MTcgNDMzLjcxIDc3LjE0NyA0MzkuMjk5IDc3LjE0NyA0NDUuMjcxIEMgNzcuMTQ3IDQ2Mi42NCA5MS4yNzggNDc2Ljc3MSAxMDguNjQ3IDQ3Ni43NzEgQyAxMTQuNjE5IDQ3Ni43NzEgMTIwLjIwOCA0NzUuMSAxMjQuOTcyIDQ3Mi4yMDIgQyAxMjkuNzM2IDQ2OS4zMDQgMTMyLjY3OCA0NjYuMzYgMTM1LjU3NyA0NjEuNTk2IEMgMTM4LjQ3NiA0NTYuODMyIDE0MC4xNDcgNDUxLjI0MyAxNDAuMTQ3IDQ0NS4yNzEgQyAxNDAuMTQ3IDQ0My45NDMgMTQwLjA1NSA0NDIuNjM3IDEzOS44OTUgNDQxLjM1MiBMIDIxNC45OTcgMzg4Ljc4IEMgMjE3LjA1IDM5MS42NzcgMzM2LjI0MiAzOTEuNjc4IDMzOC4yOTUgMzg4Ljc4IEwgNDEzLjM5OCA0NDEuMzUyIEMgNDEzLjIzOCA0NDIuNjM3IDQxMy4xNDYgNDQzLjk0MyA0MTMuMTQ2IDQ0NS4yNzEgQyA0MTMuMTQ2IDQ1MS4yNDMgNDE0LjgxNyA0NTYuODMyIDQxNy43MTUgNDYxLjU5NiBDIDQyMC42MTMgNDY2LjM2IDQyMy41NTcgNDY5LjMwNCA0MjguMzIxIDQ3Mi4yMDIgQyA0MzMuMDg1IDQ3NS4xIDQzOC42NzQgNDc2Ljc3MSA0NDQuNjQ2IDQ3Ni43NzEgQyA0NjIuMDE1IDQ3Ni43NzEgNDc2LjE0NiA0NjIuNjQgNDc2LjE0NiA0NDUuMjcxIEMgNDc2LjE0NiA0MzkuMjk5IDQ3NC40NzUgNDMzLjcxIDQ3MS41NzcgNDI4Ljk0NiBDIDQ2OC42NzkgNDI0LjE4MiA0NTkuNjQyIDQxNy41NzUgNDU4Ljk1OCA0MTcuMjI0IEMgNDU4LjY3MiA0MTYuNzc5IDQ1OC4zMzkgNDE2LjM1NiA0NTcuOTUgNDE1Ljk2NyBMIDM1My45NSAzMTEuOTY3IEMgMzUyLjg1MiAzMTAuODY5IDM1MS40OTggMzEwLjE4MiAzNTAuMDggMzA5LjkwOCBMIDM0NC43NjQgMjE5LjU0IEMgMzQ1LjE4MyAyMTkuMjY0IDM0NS41ODEgMjE4Ljk0MiAzNDUuOTUgMjE4LjU3MyBMIDQyNS45NSAxMzguNTczIEMgNDI2Ljc2IDEzNy43NjMgNDI3LjMzNyAxMzYuODEyIDQyNy42OTkgMTM1LjgwMiBDIDQzMi41OTYgMTM4Ljk0MSA0MzguNDA5IDE0MC43NzEgNDQ0LjY0NiAxNDAuNzcxIEMgNDUwLjYxOCAxNDAuNzcxIDQ1Ni4yMDcgMTM5LjEgNDYwLjk3MSAxMzYuMjAyIEMgNDY1LjczNSAxMzMuMzA0IDQ2OC42NzkgMTMwLjM2IDQ3MS41NzcgMTI1LjU5NiBDIDQ3NC40NzUgMTIwLjgzMiA0NzYuMTQ2IDExNS4yNDMgNDc2LjE0NiAxMDkuMjcxIEMgNDc2LjE0NiA5MS45MDMgNDYyLjAxNSA3Ny43NzIgNDQ0LjY0NiA3Ny43NzIgQyA0MzguNjc0IDc3Ljc3MiA0MzMuMDg1IDc5LjQ0MiA0MjguMzIxIDgyLjM0IEwgNDE2LjIxNSA5MS40NDYgTCAzMjQuNzY1IDE0MC42ODggQyAzMTguNDAyIDEzNi4zMjQgMzEwLjcxOCAxMzMuNzcxIDMwMi40NzMgMTMzLjc3MSBMIDI1MC44MTkgMTMzLjc3MSBDIDI0Mi41NzQgMTMzLjc3MSAyMzQuODkgMTM2LjMyNCAyMjguNTI3IDE0MC42ODggTCAxMzcuMDc4IDkxLjQ0NiBMIDEyNC45NzIgODIuMzQgQyAxMjAuMjA4IDc5LjQ0MiAxMTQuNjE5IDc3Ljc3MiAxMDguNjQ3IDc3Ljc3MiBDIDkxLjI3OCA3Ny43NzIgNzcuMTQ3IDkxLjkwMyA3Ny4xNDcgMTA5LjI3MSBDIDc3LjE0NyAxMTUuMjQzIDc4LjgxOCAxMjAuODMyIDgxLjcxNiAxMjUuNTk1IEMgODQuNjE0IDEzMC4zNTggODcuNTU4IDEzMy4zMDQgOTIuMzIyIDEzNi4yMDIgTCA5Mi4zMjIgMTM2LjIwMiBMIDkyLjMyMiAxMzYuMjAyIEwgOTIuMzIyIDEzNi4yMDIgTCA5Mi4zMjIgMTM2LjIwMiBMIDkyLjMyMiAxMzYuMjAyIEwgOTIuMzIyIDEzNi4yMDIgTCA5Mi4zMjIgMTM2LjIwMiBMIDkyLjMyMiAxMzYuMjAyIFogIE0gNDQ0LjY0NiA0NjEuNzcxIEMgNDM1LjU0OCA0NjEuNzcxIDQyOC4xNDYgNDU0LjM2OSA0MjguMTQ2IDQ0NS4yNzEgQyA0MjguMTQ2IDQzNi4xNzIgNDM1LjU0OCA0MjguNzcxIDQ0NC42NDYgNDI4Ljc3MSBDIDQ1My43NDQgNDI4Ljc3MSA0NjEuMTQ2IDQzNi4xNzIgNDYxLjE0NiA0NDUuMjcxIEMgNDYxLjE0NiA0NTQuMzY5IDQ1My43NDQgNDYxLjc3MSA0NDQuNjQ2IDQ2MS43NzEgWiBcIlxuICAgICAgLz5cbiAgICAgIDxwYXRoXG4gICAgICAgIGZpbGxSdWxlPVwiZXZlbm9kZFwiXG4gICAgICAgIGQ9XCIgTSAyNTkuNDU4IDMzNC4yMzUgTCAyNTkuNDU4IDMzNy4yMTEgTCAyNTQuNTE0IDMzNy4yMTEgTCAyNTQuNTE0IDM1MC43OTUgTCAyNTAuODQyIDM1MC43OTUgTCAyNTAuODQyIDMzNy4yMTEgTCAyNDUuODk4IDMzNy4yMTEgTCAyNDUuODk4IDMzNC4yMzUgTCAyNTkuNDU4IDMzNC4yMzUgWiAgTSAyNjYuMjI2IDM0Ny45MzkgTCAyNzIuNTg2IDM0Ny45MzkgTCAyNzIuNzU0IDM1MC42MjcgTCAyNzIuNzU0IDM1MC42MjcgUSAyNzAuNDk4IDM1MC44NjcgMjY1LjA3NCAzNTAuODY3IEwgMjY1LjA3NCAzNTAuODY3IEwgMjY1LjA3NCAzNTAuODY3IFEgMjYzLjQxOCAzNTAuODY3IDI2Mi40MzQgMzQ5Ljk2NyBMIDI2Mi40MzQgMzQ5Ljk2NyBMIDI2Mi40MzQgMzQ5Ljk2NyBRIDI2MS40NSAzNDkuMDY3IDI2MS40MjYgMzQ3LjUzMSBMIDI2MS40MjYgMzQ3LjUzMSBMIDI2MS40MjYgMzM3LjQ5OSBMIDI2MS40MjYgMzM3LjQ5OSBRIDI2MS40NSAzMzUuOTYzIDI2Mi40MzQgMzM1LjA2MyBMIDI2Mi40MzQgMzM1LjA2MyBMIDI2Mi40MzQgMzM1LjA2MyBRIDI2My40MTggMzM0LjE2MyAyNjUuMDc0IDMzNC4xNjMgTCAyNjUuMDc0IDMzNC4xNjMgTCAyNjUuMDc0IDMzNC4xNjMgUSAyNzAuNDk4IDMzNC4xNjMgMjcyLjc1NCAzMzQuNDAzIEwgMjcyLjc1NCAzMzQuNDAzIEwgMjcyLjU4NiAzMzcuMTE1IEwgMjY2LjIyNiAzMzcuMTE1IEwgMjY2LjIyNiAzMzcuMTE1IFEgMjY1LjYyNiAzMzcuMTE1IDI2NS4zNjIgMzM3LjQwMyBMIDI2NS4zNjIgMzM3LjQwMyBMIDI2NS4zNjIgMzM3LjQwMyBRIDI2NS4wOTggMzM3LjY5MSAyNjUuMDk4IDMzOC4zMzkgTCAyNjUuMDk4IDMzOC4zMzkgTCAyNjUuMDk4IDM0MC44NTkgTCAyNzEuNjk4IDM0MC44NTkgTCAyNzEuNjk4IDM0My40OTkgTCAyNjUuMDk4IDM0My40OTkgTCAyNjUuMDk4IDM0Ni42OTEgTCAyNjUuMDk4IDM0Ni42OTEgUSAyNjUuMDk4IDM0Ny4zNjMgMjY1LjM2MiAzNDcuNjUxIEwgMjY1LjM2MiAzNDcuNjUxIEwgMjY1LjM2MiAzNDcuNjUxIFEgMjY1LjYyNiAzNDcuOTM5IDI2Ni4yMjYgMzQ3LjkzOSBMIDI2Ni4yMjYgMzQ3LjkzOSBaICBNIDI3NS4yMDIgMzMzLjk5NSBMIDI3OC43MyAzMzMuOTk1IEwgMjc4LjczIDM0Ni45MzEgTCAyNzguNzMgMzQ2LjkzMSBRIDI3OC43MyAzNDguMTMxIDI4MC4wNzQgMzQ4LjEzMSBMIDI4MC4wNzQgMzQ4LjEzMSBMIDI4MS4wMzQgMzQ4LjEzMSBMIDI4MS40NDIgMzUwLjYwMyBMIDI4MS40NDIgMzUwLjYwMyBRIDI4MC41MyAzNTEuMDgzIDI3OC42MSAzNTEuMDgzIEwgMjc4LjYxIDM1MS4wODMgTCAyNzguNjEgMzUxLjA4MyBRIDI3Ny4wMjYgMzUxLjA4MyAyNzYuMTE0IDM1MC4yMzEgTCAyNzYuMTE0IDM1MC4yMzEgTCAyNzYuMTE0IDM1MC4yMzEgUSAyNzUuMjAyIDM0OS4zNzkgMjc1LjIwMiAzNDcuODE5IEwgMjc1LjIwMiAzNDcuODE5IEwgMjc1LjIwMiAzMzMuOTk1IFogIE0gMjgzLjA1IDMzMy45OTUgTCAyODYuNTc4IDMzMy45OTUgTCAyODYuNTc4IDM0Ni45MzEgTCAyODYuNTc4IDM0Ni45MzEgUSAyODYuNTc4IDM0OC4xMzEgMjg3LjkyMiAzNDguMTMxIEwgMjg3LjkyMiAzNDguMTMxIEwgMjg4Ljg4MiAzNDguMTMxIEwgMjg5LjI5IDM1MC42MDMgTCAyODkuMjkgMzUwLjYwMyBRIDI4OC4zNzggMzUxLjA4MyAyODYuNDU4IDM1MS4wODMgTCAyODYuNDU4IDM1MS4wODMgTCAyODYuNDU4IDM1MS4wODMgUSAyODQuODc0IDM1MS4wODMgMjgzLjk2MiAzNTAuMjMxIEwgMjgzLjk2MiAzNTAuMjMxIEwgMjgzLjk2MiAzNTAuMjMxIFEgMjgzLjA1IDM0OS4zNzkgMjgzLjA1IDM0Ny44MTkgTCAyODMuMDUgMzQ3LjgxOSBMIDI4My4wNSAzMzMuOTk1IFogIE0gMjkyLjA4NiAzMzUuNzU5IEwgMjkyLjA4NiAzMzUuNzU5IEwgMjkyLjA4NiAzMzUuNzU5IFEgMjkzLjYzNCAzMzMuOTIzIDI5Ny42MTggMzMzLjkyMyBMIDI5Ny42MTggMzMzLjkyMyBMIDI5Ny42MTggMzMzLjkyMyBRIDMwMS42MDIgMzMzLjkyMyAzMDMuMTYyIDMzNS43NTkgTCAzMDMuMTYyIDMzNS43NTkgTCAzMDMuMTYyIDMzNS43NTkgUSAzMDQuNzIyIDMzNy41OTUgMzA0LjcyMiAzNDIuNTE1IEwgMzA0LjcyMiAzNDIuNTE1IEwgMzA0LjcyMiAzNDIuNTE1IFEgMzA0LjcyMiAzNDcuNDM1IDMwMy4xNjIgMzQ5LjI3MSBMIDMwMy4xNjIgMzQ5LjI3MSBMIDMwMy4xNjIgMzQ5LjI3MSBRIDMwMS42MDIgMzUxLjEwNyAyOTcuNjE4IDM1MS4xMDcgTCAyOTcuNjE4IDM1MS4xMDcgTCAyOTcuNjE4IDM1MS4xMDcgUSAyOTMuNjM0IDM1MS4xMDcgMjkyLjA4NiAzNDkuMjcxIEwgMjkyLjA4NiAzNDkuMjcxIEwgMjkyLjA4NiAzNDkuMjcxIFEgMjkwLjUzOCAzNDcuNDM1IDI5MC41MzggMzQyLjUxNSBMIDI5MC41MzggMzQyLjUxNSBMIDI5MC41MzggMzQyLjUxNSBRIDI5MC41MzggMzM3LjU5NSAyOTIuMDg2IDMzNS43NTkgWiAgTSAzMDAuMTc0IDMzOC4wNTEgTCAzMDAuMTc0IDMzOC4wNTEgTCAzMDAuMTc0IDMzOC4wNTEgUSAyOTkuNDkgMzM2Ljg3NSAyOTcuNjE4IDMzNi44NzUgTCAyOTcuNjE4IDMzNi44NzUgTCAyOTcuNjE4IDMzNi44NzUgUSAyOTUuNzQ2IDMzNi44NzUgMjk1LjA2MiAzMzguMDUxIEwgMjk1LjA2MiAzMzguMDUxIEwgMjk1LjA2MiAzMzguMDUxIFEgMjk0LjM3OCAzMzkuMjI3IDI5NC4zNzggMzQyLjUxNSBMIDI5NC4zNzggMzQyLjUxNSBMIDI5NC4zNzggMzQyLjUxNSBRIDI5NC4zNzggMzQ1LjgwMyAyOTUuMDYyIDM0Ni45NzkgTCAyOTUuMDYyIDM0Ni45NzkgTCAyOTUuMDYyIDM0Ni45NzkgUSAyOTUuNzQ2IDM0OC4xNTUgMjk3LjYxOCAzNDguMTU1IEwgMjk3LjYxOCAzNDguMTU1IEwgMjk3LjYxOCAzNDguMTU1IFEgMjk5LjQ5IDM0OC4xNTUgMzAwLjE3NCAzNDYuOTc5IEwgMzAwLjE3NCAzNDYuOTc5IEwgMzAwLjE3NCAzNDYuOTc5IFEgMzAwLjg1OCAzNDUuODAzIDMwMC44NTggMzQyLjUxNSBMIDMwMC44NTggMzQyLjUxNSBMIDMwMC44NTggMzQyLjUxNSBRIDMwMC44NTggMzM5LjIyNyAzMDAuMTc0IDMzOC4wNTEgWiBcIlxuICAgICAgLz5cbiAgICAgIDxnIGNsYXNzTmFtZT1cInByb3BlbGxlci1ncm91cFwiPlxuICAgICAgICA8cGF0aFxuICAgICAgICAgIGNsYXNzTmFtZT17YCR7c3R5bGVzLnByb3BlbGxlcn0gJHtzdHlsZXMucHJvcGVsbGVyQ1d9YH1cbiAgICAgICAgICBzdHlsZT17eyBhbmltYXRpb246IGJSaWdodFJvdG9yQW5pbWF0aW9uIH19XG4gICAgICAgICAgZD1cIiBNIDQ2MS41NjMgNDE4Ljc3IEwgNDYzLjk5MiA0MTYuMzQgUSA0NjUuNDk1IDQwNy4xMTYgNDY2LjQ2MSA0MDAuMzk1IEMgNDY3LjQyNiAzOTMuNjc1IDQ2OS4zNjMgMzg4LjA4NyA0NzQuNzMxIDM4My4yODQgUSA1MzMuODYyIDM0MS41MTQgNTM4LjE5NiAzMzguODU5IEMgNTQyLjUyOSAzMzYuMjAzIDU0OC4zNDUgMzM0LjI5OSA1NTEuNDkyIDMzOC4yOSBDIDU1NC42MzkgMzQyLjI4MiA1NTMuNDgxIDM0Ni4wMiA1NDkuNDE5IDM1MC4wODIgTCA0NzEuMTQ3IDQyOC4zNTQgTCA0NjEuNTYzIDQxOC43NyBaICBNIDQyNy43MjkgNDcxLjc3MiBMIDQyNS4yOTkgNDc0LjIwMiBRIDQyMy43OTcgNDgzLjQyNiA0MjIuODMxIDQ5MC4xNDYgQyA0MjEuODY2IDQ5Ni44NjcgNDE5LjkyOSA1MDIuNDU0IDQxNC41NjEgNTA3LjI1NyBRIDM1NS40MyA1NDkuMDI4IDM1MS4wOTYgNTUxLjY4MyBDIDM0Ni43NjMgNTU0LjMzOCAzNDAuOTQ3IDU1Ni4yNDMgMzM3LjggNTUyLjI1MSBDIDMzNC42NTMgNTQ4LjI2IDMzNS44MTEgNTQ0LjUyMiAzMzkuODczIDU0MC40NiBMIDQxOC4xNDUgNDYyLjE4NyBMIDQyNy43MjkgNDcxLjc3MiBaIFwiXG4gICAgICAgIC8+XG4gICAgICAgIDxwYXRoXG4gICAgICAgICAgY2xhc3NOYW1lPXtgJHtzdHlsZXMucHJvcGVsbGVyfSAke3N0eWxlcy5wcm9wZWxsZXJDQ1d9YH1cbiAgICAgICAgICBzdHlsZT17eyBhbmltYXRpb246IGZSaWdodFJvdG9yQW5pbWF0aW9uIH19XG4gICAgICAgICAgZD1cIiBNIDQ2MS41NjMgMTM1Ljc3MyBMIDQ2My45OTIgMTM4LjIwMyBRIDQ2NS40OTUgMTQ3LjQyNiA0NjYuNDYxIDE1NC4xNDcgQyA0NjcuNDI2IDE2MC44NjggNDY5LjM2MyAxNjYuNDU1IDQ3NC43MzEgMTcxLjI1OCBRIDUzMy44NjIgMjEzLjAyOCA1MzguMTk2IDIxNS42ODQgQyA1NDIuNTI5IDIxOC4zMzkgNTQ4LjM0NSAyMjAuMjQ0IDU1MS40OTIgMjE2LjI1MiBDIDU1NC42MzkgMjEyLjI2IDU1My40ODEgMjA4LjUyMyA1NDkuNDE5IDIwNC40NiBMIDQ3MS4xNDcgMTI2LjE4OCBMIDQ2MS41NjMgMTM1Ljc3MyBaICBNIDQyNy43MjkgODIuNzcgTCA0MjUuMjk5IDgwLjM0IFEgNDIzLjc5NyA3MS4xMTcgNDIyLjgzMSA2NC4zOTYgQyA0MjEuODY2IDU3LjY3NSA0MTkuOTI5IDUyLjA4OCA0MTQuNTYxIDQ3LjI4NSBRIDM1NS40MyA1LjUxNSAzNTEuMDk2IDIuODU5IEMgMzQ2Ljc2MyAwLjIwNCAzNDAuOTQ3IC0xLjcwMSAzMzcuOCAyLjI5MSBDIDMzNC42NTMgNi4yODIgMzM1LjgxMSAxMC4wMiAzMzkuODczIDE0LjA4MiBMIDQxOC4xNDUgOTIuMzU1IEwgNDI3LjcyOSA4Mi43NyBaIFwiXG4gICAgICAgIC8+XG4gICAgICAgIDxwYXRoXG4gICAgICAgICAgY2xhc3NOYW1lPXtgJHtzdHlsZXMucHJvcGVsbGVyfSAke3N0eWxlcy5wcm9wZWxsZXJDQ1d9YH1cbiAgICAgICAgICBzdHlsZT17eyBhbmltYXRpb246IGJMZWZ0Um90b3JBbmltYXRpb24gfX1cbiAgICAgICAgICBkPVwiIE0gMTI1LjU2MyA0NzEuNzcyIEwgMTI3Ljk5MyA0NzQuMjAyIFEgMTI5LjQ5NiA0ODMuNDI2IDEzMC40NjEgNDkwLjE0NiBDIDEzMS40MjcgNDk2Ljg2NyAxMzMuMzYzIDUwMi40NTQgMTM4LjczMSA1MDcuMjU3IFEgMTk3Ljg2MyA1NDkuMDI4IDIwMi4xOTYgNTUxLjY4MyBDIDIwNi41MyA1NTQuMzM4IDIxMi4zNDUgNTU2LjI0MyAyMTUuNDkyIDU1Mi4yNTEgQyAyMTguNjM5IDU0OC4yNiAyMTcuNDgyIDU0NC41MjIgMjEzLjQxOSA1NDAuNDYgTCAxMzUuMTQ4IDQ2Mi4xODcgTCAxMjUuNTYzIDQ3MS43NzIgWiAgTSA5MS43MyA0MTguNzcgTCA4OS4zIDQxNi4zNCBRIDg3Ljc5NyA0MDcuMTE2IDg2LjgzMiA0MDAuMzk1IEMgODUuODY2IDM5My42NzUgODMuOTMgMzg4LjA4NyA3OC41NjIgMzgzLjI4NCBRIDE5LjQzMSAzNDEuNTE0IDE1LjA5NyAzMzguODU5IEMgMTAuNzYzIDMzNi4yMDMgNC45NDggMzM0LjI5OSAxLjgwMSAzMzguMjkgQyAtMS4zNDYgMzQyLjI4MiAtMC4xODkgMzQ2LjAyIDMuODc0IDM1MC4wODIgTCA4Mi4xNDYgNDI4LjM1NCBMIDkxLjczIDQxOC43NyBaIFwiXG4gICAgICAgIC8+XG4gICAgICAgIDxwYXRoXG4gICAgICAgICAgY2xhc3NOYW1lPXtgJHtzdHlsZXMucHJvcGVsbGVyfSAke3N0eWxlcy5wcm9wZWxsZXJDV31gfVxuICAgICAgICAgIHN0eWxlPXt7IGFuaW1hdGlvbjogZkxlZnRSb3RvckFuaW1hdGlvbiB9fVxuICAgICAgICAgIGQ9XCIgTSAxMjUuNTYzIDgyLjc3IEwgMTI3Ljk5MyA4MC4zNCBRIDEyOS40OTYgNzEuMTE3IDEzMC40NjEgNjQuMzk2IEMgMTMxLjQyNyA1Ny42NzUgMTMzLjM2MyA1Mi4wODggMTM4LjczMSA0Ny4yODUgUSAxOTcuODYzIDUuNTE1IDIwMi4xOTYgMi44NTkgQyAyMDYuNTMgMC4yMDQgMjEyLjM0NSAtMS43MDEgMjE1LjQ5MiAyLjI5MSBDIDIxOC42MzkgNi4yODIgMjE3LjQ4MiAxMC4wMiAyMTMuNDE5IDE0LjA4MyBMIDEzNS4xNDcgOTIuMzU1IEwgMTI1LjU2MyA4Mi43NyBaICBNIDkxLjczIDEzNS43NzMgTCA4OS4zIDEzOC4yMDMgUSA4Ny43OTcgMTQ3LjQyNiA4Ni44MzIgMTU0LjE0NyBDIDg1Ljg2NiAxNjAuODY4IDgzLjkzIDE2Ni40NTUgNzguNTYyIDE3MS4yNTggUSAxOS40MzEgMjEzLjAyOCAxNS4wOTcgMjE1LjY4NCBDIDEwLjc2MyAyMTguMzM5IDQuOTQ4IDIyMC4yNDMgMS44MDEgMjE2LjI1MiBDIC0xLjM0NiAyMTIuMjYgLTAuMTg5IDIwOC41MjMgMy44NzQgMjA0LjQ2IEwgODIuMTQ2IDEyNi4xODggTCA5MS43MyAxMzUuNzczIFogXCJcbiAgICAgICAgLz5cbiAgICAgIDwvZz5cbiAgICA8L3N2Zz5cbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBkcm9uZVRvcEl0ZW06IENhbnZhc0VsZW1lbnRJdGVtPGFueSwgYW55PiA9IHtcbiAgaWQ6ICdkcm9uZVRvcCcsXG4gIG5hbWU6ICdEcm9uZSBUb3AnLFxuICBkZXNjcmlwdGlvbjogJ0Ryb25lIHRvcCcsXG5cbiAgZGlzcGxheTogRHJvbmVUb3BEaXNwbGF5LFxuXG4gIGRlZmF1bHRTaXplOiB7XG4gICAgd2lkdGg6IDEwMCxcbiAgICBoZWlnaHQ6IDEwMCxcbiAgfSxcblxuICBnZXROZXdPcHRpb25zOiAob3B0aW9ucykgPT4gKHtcbiAgICAuLi5vcHRpb25zLFxuICB9KSxcblxuICAvLyBDYWxsZWQgd2hlbiBkYXRhIGNoYW5nZXNcbiAgcHJlcGFyZURhdGE6IChjdHg6IERpbWVuc2lvbkNvbnRleHQsIGNmZzogRHJvbmVUb3BDb25maWcpID0+IHtcbiAgICBjb25zdCBkYXRhOiBEcm9uZVRvcERhdGEgPSB7XG4gICAgICBiUmlnaHRSb3RvclJQTTogY2ZnPy5iUmlnaHRSb3RvclJQTSA/IGN0eC5nZXRTY2FsYXIoY2ZnLmJSaWdodFJvdG9yUlBNKS52YWx1ZSgpIDogMCxcbiAgICAgIGJMZWZ0Um90b3JSUE06IGNmZz8uYkxlZnRSb3RvclJQTSA/IGN0eC5nZXRTY2FsYXIoY2ZnLmJMZWZ0Um90b3JSUE0pLnZhbHVlKCkgOiAwLFxuICAgICAgZlJpZ2h0Um90b3JSUE06IGNmZz8uZlJpZ2h0Um90b3JSUE0gPyBjdHguZ2V0U2NhbGFyKGNmZy5mUmlnaHRSb3RvclJQTSkudmFsdWUoKSA6IDAsXG4gICAgICBmTGVmdFJvdG9yUlBNOiBjZmc/LmZMZWZ0Um90b3JSUE0gPyBjdHguZ2V0U2NhbGFyKGNmZy5mTGVmdFJvdG9yUlBNKS52YWx1ZSgpIDogMCxcbiAgICAgIHlhd0FuZ2xlOiBjZmc/Lnlhd0FuZ2xlID8gY3R4LmdldFNjYWxhcihjZmcueWF3QW5nbGUpLnZhbHVlKCkgOiAwLFxuICAgIH07XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfSxcblxuICByZWdpc3Rlck9wdGlvbnNVSTogKGJ1aWxkZXIpID0+IHtcbiAgICBjb25zdCBjYXRlZ29yeSA9IFsnRHJvbmUgVG9wJ107XG4gICAgYnVpbGRlclxuICAgICAgLmFkZEN1c3RvbUVkaXRvcih7XG4gICAgICAgIGNhdGVnb3J5LFxuICAgICAgICBpZDogJ3lhd0FuZ2xlJyxcbiAgICAgICAgcGF0aDogJ2NvbmZpZy55YXdBbmdsZScsXG4gICAgICAgIG5hbWU6ICdZYXcgQW5nbGUnLFxuICAgICAgICBlZGl0b3I6IFNjYWxhckRpbWVuc2lvbkVkaXRvcixcbiAgICAgIH0pXG4gICAgICAuYWRkQ3VzdG9tRWRpdG9yKHtcbiAgICAgICAgY2F0ZWdvcnksXG4gICAgICAgIGlkOiAnZlJpZ2h0Um90b3JSUE0nLFxuICAgICAgICBwYXRoOiAnY29uZmlnLmZSaWdodFJvdG9yUlBNJyxcbiAgICAgICAgbmFtZTogJ0Zyb250IFJpZ2h0IFJvdG9yIFJQTScsXG4gICAgICAgIGVkaXRvcjogU2NhbGFyRGltZW5zaW9uRWRpdG9yLFxuICAgICAgfSlcbiAgICAgIC5hZGRDdXN0b21FZGl0b3Ioe1xuICAgICAgICBjYXRlZ29yeSxcbiAgICAgICAgaWQ6ICdmTGVmdFJvdG9yUlBNJyxcbiAgICAgICAgcGF0aDogJ2NvbmZpZy5mTGVmdFJvdG9yUlBNJyxcbiAgICAgICAgbmFtZTogJ0Zyb250IExlZnQgUm90b3IgUlBNJyxcbiAgICAgICAgZWRpdG9yOiBTY2FsYXJEaW1lbnNpb25FZGl0b3IsXG4gICAgICB9KVxuICAgICAgLmFkZEN1c3RvbUVkaXRvcih7XG4gICAgICAgIGNhdGVnb3J5LFxuICAgICAgICBpZDogJ2JSaWdodFJvdG9yUlBNJyxcbiAgICAgICAgcGF0aDogJ2NvbmZpZy5iUmlnaHRSb3RvclJQTScsXG4gICAgICAgIG5hbWU6ICdCYWNrIFJpZ2h0IFJvdG9yIFJQTScsXG4gICAgICAgIGVkaXRvcjogU2NhbGFyRGltZW5zaW9uRWRpdG9yLFxuICAgICAgfSlcbiAgICAgIC5hZGRDdXN0b21FZGl0b3Ioe1xuICAgICAgICBjYXRlZ29yeSxcbiAgICAgICAgaWQ6ICdiTGVmdFJvdG9yUlBNJyxcbiAgICAgICAgcGF0aDogJ2NvbmZpZy5iTGVmdFJvdG9yUlBNJyxcbiAgICAgICAgbmFtZTogJ0JhY2sgTGVmdCBSb3RvciBSUE0nLFxuICAgICAgICBlZGl0b3I6IFNjYWxhckRpbWVuc2lvbkVkaXRvcixcbiAgICAgIH0pO1xuICB9LFxufTtcblxuY29uc3QgZ2V0U3R5bGVzID0gKHRoZW1lOiBHcmFmYW5hVGhlbWUyKSA9PiAoe1xuICBwcm9wZWxsZXI6IGNzc2BcbiAgICB0cmFuc2Zvcm0tb3JpZ2luOiA1MCUgNTAlO1xuICAgIHRyYW5zZm9ybS1ib3g6IGZpbGwtYm94O1xuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIEBrZXlmcmFtZXMgc3BpbiB7XG4gICAgICBmcm9tIHtcbiAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XG4gICAgICB9XG4gICAgICB0byB7XG4gICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XG4gICAgICB9XG4gICAgfVxuICBgLFxuICBwcm9wZWxsZXJDVzogY3NzYFxuICAgIGFuaW1hdGlvbi1kaXJlY3Rpb246IG5vcm1hbDtcbiAgYCxcbiAgcHJvcGVsbGVyQ0NXOiBjc3NgXG4gICAgYW5pbWF0aW9uLWRpcmVjdGlvbjogcmV2ZXJzZTtcbiAgYCxcbn0pO1xuIiwiaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCB7IGlzU3RyaW5nIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBSZWFjdCwgeyBDU1NQcm9wZXJ0aWVzIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFNWRyBmcm9tICdyZWFjdC1pbmxpbmVzdmcnO1xuXG5pbXBvcnQge1xuICBDb2xvckRpbWVuc2lvbkNvbmZpZyxcbiAgUmVzb3VyY2VEaW1lbnNpb25Db25maWcsXG4gIFJlc291cmNlRGltZW5zaW9uTW9kZSxcbiAgZ2V0UHVibGljT3JBYnNvbHV0ZVVybCxcbn0gZnJvbSAnYXBwL2ZlYXR1cmVzL2RpbWVuc2lvbnMnO1xuaW1wb3J0IHsgRGltZW5zaW9uQ29udGV4dCB9IGZyb20gJ2FwcC9mZWF0dXJlcy9kaW1lbnNpb25zL2NvbnRleHQnO1xuaW1wb3J0IHsgQ29sb3JEaW1lbnNpb25FZGl0b3IsIFJlc291cmNlRGltZW5zaW9uRWRpdG9yIH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2RpbWVuc2lvbnMvZWRpdG9ycyc7XG5pbXBvcnQgeyBBUElFZGl0b3IsIEFQSUVkaXRvckNvbmZpZywgY2FsbEFwaSB9IGZyb20gJ2FwcC9wbHVnaW5zL3BhbmVsL2NhbnZhcy9lZGl0b3IvQVBJRWRpdG9yJztcblxuaW1wb3J0IHsgQ2FudmFzRWxlbWVudEl0ZW0sIENhbnZhc0VsZW1lbnRQcm9wcyB9IGZyb20gJy4uL2VsZW1lbnQnO1xuaW1wb3J0IHsgTGluZUNvbmZpZyB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBJY29uQ29uZmlnIHtcbiAgcGF0aD86IFJlc291cmNlRGltZW5zaW9uQ29uZmlnO1xuICBmaWxsPzogQ29sb3JEaW1lbnNpb25Db25maWc7XG4gIHN0cm9rZT86IExpbmVDb25maWc7XG4gIGFwaT86IEFQSUVkaXRvckNvbmZpZztcbn1cblxuaW50ZXJmYWNlIEljb25EYXRhIHtcbiAgcGF0aDogc3RyaW5nO1xuICBmaWxsOiBzdHJpbmc7XG4gIHN0cm9rZUNvbG9yPzogc3RyaW5nO1xuICBzdHJva2U/OiBudW1iZXI7XG4gIGFwaT86IEFQSUVkaXRvckNvbmZpZztcbn1cblxuLy8gV2hlbiBhIHN0b2tlIGlzIGRlZmluZWQsIHdlIHdhbnQgdGhlIHBhdGggdG8gYmUgaW4gcGFnZSB1bml0c1xuY29uc3Qgc3ZnU3Ryb2tlUGF0aENsYXNzID0gY3NzYFxuICBwYXRoIHtcbiAgICB2ZWN0b3ItZWZmZWN0OiBub24tc2NhbGluZy1zdHJva2U7XG4gIH1cbmA7XG5cbmV4cG9ydCBmdW5jdGlvbiBJY29uRGlzcGxheShwcm9wczogQ2FudmFzRWxlbWVudFByb3BzKSB7XG4gIGNvbnN0IHsgZGF0YSB9ID0gcHJvcHM7XG4gIGlmICghZGF0YT8ucGF0aCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3Qgb25DbGljayA9ICgpID0+IHtcbiAgICBpZiAoZGF0YT8uYXBpKSB7XG4gICAgICBjYWxsQXBpKGRhdGEuYXBpKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgc3ZnU3R5bGU6IENTU1Byb3BlcnRpZXMgPSB7XG4gICAgZmlsbDogZGF0YT8uZmlsbCxcbiAgICBzdHJva2U6IGRhdGE/LnN0cm9rZUNvbG9yLFxuICAgIHN0cm9rZVdpZHRoOiBkYXRhPy5zdHJva2UsXG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8U1ZHXG4gICAgICBvbkNsaWNrPXtvbkNsaWNrfVxuICAgICAgc3JjPXtkYXRhLnBhdGh9XG4gICAgICBzdHlsZT17c3ZnU3R5bGV9XG4gICAgICBjbGFzc05hbWU9e3N2Z1N0eWxlLnN0cm9rZVdpZHRoID8gc3ZnU3Ryb2tlUGF0aENsYXNzIDogdW5kZWZpbmVkfVxuICAgIC8+XG4gICk7XG59XG5cbmV4cG9ydCBjb25zdCBpY29uSXRlbTogQ2FudmFzRWxlbWVudEl0ZW08SWNvbkNvbmZpZywgSWNvbkRhdGE+ID0ge1xuICBpZDogJ2ljb24nLFxuICBuYW1lOiAnSWNvbicsXG4gIGRlc2NyaXB0aW9uOiAnU1ZHIEljb24gZGlzcGxheScsXG5cbiAgZGlzcGxheTogSWNvbkRpc3BsYXksXG5cbiAgZ2V0TmV3T3B0aW9uczogKG9wdGlvbnMpID0+ICh7XG4gICAgcGxhY2VtZW50OiB7XG4gICAgICB3aWR0aDogNTAsXG4gICAgICBoZWlnaHQ6IDUwLFxuICAgICAgdG9wOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICB9LFxuICAgIC4uLm9wdGlvbnMsXG4gICAgY29uZmlnOiB7XG4gICAgICBwYXRoOiB7XG4gICAgICAgIG1vZGU6IFJlc291cmNlRGltZW5zaW9uTW9kZS5GaXhlZCxcbiAgICAgICAgZml4ZWQ6ICdpbWcvaWNvbnMvdW5pY29ucy9xdWVzdGlvbi1jaXJjbGUuc3ZnJyxcbiAgICAgIH0sXG4gICAgICBmaWxsOiB7IGZpeGVkOiAnI0ZGRjg5OScgfSxcbiAgICB9LFxuICB9KSxcblxuICAvLyBDYWxsZWQgd2hlbiBkYXRhIGNoYW5nZXNcbiAgcHJlcGFyZURhdGE6IChjdHg6IERpbWVuc2lvbkNvbnRleHQsIGNmZzogSWNvbkNvbmZpZykgPT4ge1xuICAgIGxldCBwYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGNmZy5wYXRoKSB7XG4gICAgICBwYXRoID0gY3R4LmdldFJlc291cmNlKGNmZy5wYXRoKS52YWx1ZSgpO1xuICAgIH1cbiAgICBpZiAoIXBhdGggfHwgIWlzU3RyaW5nKHBhdGgpKSB7XG4gICAgICBwYXRoID0gZ2V0UHVibGljT3JBYnNvbHV0ZVVybCgnaW1nL2ljb25zL3VuaWNvbnMvcXVlc3Rpb24tY2lyY2xlLnN2ZycpO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGE6IEljb25EYXRhID0ge1xuICAgICAgcGF0aCxcbiAgICAgIGZpbGw6IGNmZy5maWxsID8gY3R4LmdldENvbG9yKGNmZy5maWxsKS52YWx1ZSgpIDogJyNDQ0MnLFxuICAgICAgYXBpOiBjZmc/LmFwaSA/PyB1bmRlZmluZWQsXG4gICAgfTtcblxuICAgIGlmIChjZmcuc3Ryb2tlPy53aWR0aCAmJiBjZmcuc3Ryb2tlLmNvbG9yKSB7XG4gICAgICBpZiAoY2ZnLnN0cm9rZS53aWR0aCA+IDApIHtcbiAgICAgICAgZGF0YS5zdHJva2UgPSBjZmcuc3Ryb2tlPy53aWR0aDtcbiAgICAgICAgZGF0YS5zdHJva2VDb2xvciA9IGN0eC5nZXRDb2xvcihjZmcuc3Ryb2tlLmNvbG9yKS52YWx1ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfSxcblxuICAvLyBIZWF0bWFwIG92ZXJsYXkgb3B0aW9uc1xuICByZWdpc3Rlck9wdGlvbnNVSTogKGJ1aWxkZXIpID0+IHtcbiAgICBjb25zdCBjYXRlZ29yeSA9IFsnSWNvbiddO1xuICAgIGJ1aWxkZXJcbiAgICAgIC5hZGRDdXN0b21FZGl0b3Ioe1xuICAgICAgICBjYXRlZ29yeSxcbiAgICAgICAgaWQ6ICdpY29uU2VsZWN0b3InLFxuICAgICAgICBwYXRoOiAnY29uZmlnLnBhdGgnLFxuICAgICAgICBuYW1lOiAnU1ZHIFBhdGgnLFxuICAgICAgICBlZGl0b3I6IFJlc291cmNlRGltZW5zaW9uRWRpdG9yLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIHJlc291cmNlVHlwZTogJ2ljb24nLFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICAgIC5hZGRDdXN0b21FZGl0b3Ioe1xuICAgICAgICBjYXRlZ29yeSxcbiAgICAgICAgaWQ6ICdjb25maWcuZmlsbCcsXG4gICAgICAgIHBhdGg6ICdjb25maWcuZmlsbCcsXG4gICAgICAgIG5hbWU6ICdGaWxsIGNvbG9yJyxcbiAgICAgICAgZWRpdG9yOiBDb2xvckRpbWVuc2lvbkVkaXRvcixcbiAgICAgICAgc2V0dGluZ3M6IHt9LFxuICAgICAgICBkZWZhdWx0VmFsdWU6IHtcbiAgICAgICAgICAvLyBDb25maWd1cmVkIHZhbHVlc1xuICAgICAgICAgIGZpeGVkOiAnZ3JleScsXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgICAgLmFkZFNsaWRlcklucHV0KHtcbiAgICAgICAgY2F0ZWdvcnksXG4gICAgICAgIHBhdGg6ICdjb25maWcuc3Ryb2tlLndpZHRoJyxcbiAgICAgICAgbmFtZTogJ1N0cm9rZScsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogMCxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgbWF4OiAxMCxcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgICAuYWRkQ3VzdG9tRWRpdG9yKHtcbiAgICAgICAgY2F0ZWdvcnksXG4gICAgICAgIGlkOiAnY29uZmlnLnN0cm9rZS5jb2xvcicsXG4gICAgICAgIHBhdGg6ICdjb25maWcuc3Ryb2tlLmNvbG9yJyxcbiAgICAgICAgbmFtZTogJ1N0cm9rZSBjb2xvcicsXG4gICAgICAgIGVkaXRvcjogQ29sb3JEaW1lbnNpb25FZGl0b3IsXG4gICAgICAgIHNldHRpbmdzOiB7fSxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB7XG4gICAgICAgICAgLy8gQ29uZmlndXJlZCB2YWx1ZXNcbiAgICAgICAgICBmaXhlZDogJ2dyZXknLFxuICAgICAgICB9LFxuICAgICAgICBzaG93SWY6IChjZmcpID0+IEJvb2xlYW4oY2ZnPy5jb25maWc/LnN0cm9rZT8ud2lkdGgpLFxuICAgICAgfSlcbiAgICAgIC5hZGRDdXN0b21FZGl0b3Ioe1xuICAgICAgICBjYXRlZ29yeSxcbiAgICAgICAgaWQ6ICdhcGlTZWxlY3RvcicsXG4gICAgICAgIHBhdGg6ICdjb25maWcuYXBpJyxcbiAgICAgICAgbmFtZTogJ0FQSScsXG4gICAgICAgIGVkaXRvcjogQVBJRWRpdG9yLFxuICAgICAgfSk7XG4gIH0sXG59O1xuIiwiaW1wb3J0IFJlYWN0LCB7IFB1cmVDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IENhbnZhc0VsZW1lbnRJdGVtLCBDYW52YXNFbGVtZW50UHJvcHMgfSBmcm9tICcuLi9lbGVtZW50JztcblxuaW50ZXJmYWNlIE5vdEZvdW5kQ29uZmlnIHtcbiAgb3JpZz86IGFueTtcbn1cblxuY2xhc3MgTm90Rm91bmREaXNwbGF5IGV4dGVuZHMgUHVyZUNvbXBvbmVudDxDYW52YXNFbGVtZW50UHJvcHM8Tm90Rm91bmRDb25maWc+PiB7XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGNvbmZpZyB9ID0gdGhpcy5wcm9wcztcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdj5cbiAgICAgICAgPGgzPk5PVCBGT1VORDo8L2gzPlxuICAgICAgICA8cHJlPntKU09OLnN0cmluZ2lmeShjb25maWcsIG51bGwsIDIpfTwvcHJlPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgbm90Rm91bmRJdGVtOiBDYW52YXNFbGVtZW50SXRlbTxOb3RGb3VuZENvbmZpZz4gPSB7XG4gIGlkOiAnbm90LWZvdW5kJyxcbiAgbmFtZTogJ05vdCBmb3VuZCcsXG4gIGRlc2NyaXB0aW9uOiAnRGlzcGxheSB3aGVuIGVsZW1lbnQgdHlwZSBpcyBub3QgZm91bmQgaW4gdGhlIHJlZ2lzdHJ5JyxcblxuICBkaXNwbGF5OiBOb3RGb3VuZERpc3BsYXksXG5cbiAgZGVmYXVsdFNpemU6IHtcbiAgICB3aWR0aDogMTAwLFxuICAgIGhlaWdodDogMTAwLFxuICB9LFxuXG4gIGdldE5ld09wdGlvbnM6ICgpID0+ICh7XG4gICAgY29uZmlnOiB7fSxcbiAgfSksXG59O1xuIiwiaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCBSZWFjdCwgeyBQdXJlQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBHcmFmYW5hVGhlbWUyIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBzdHlsZXNGYWN0b3J5IH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuaW1wb3J0IHsgY29uZmlnIH0gZnJvbSAnYXBwL2NvcmUvY29uZmlnJztcbmltcG9ydCB7IERpbWVuc2lvbkNvbnRleHQgfSBmcm9tICdhcHAvZmVhdHVyZXMvZGltZW5zaW9ucy9jb250ZXh0JztcbmltcG9ydCB7IENvbG9yRGltZW5zaW9uRWRpdG9yIH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2RpbWVuc2lvbnMvZWRpdG9ycy9Db2xvckRpbWVuc2lvbkVkaXRvcic7XG5pbXBvcnQgeyBUZXh0RGltZW5zaW9uRWRpdG9yIH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2RpbWVuc2lvbnMvZWRpdG9ycy9UZXh0RGltZW5zaW9uRWRpdG9yJztcbmltcG9ydCB7IENvbG9yRGltZW5zaW9uQ29uZmlnLCBUZXh0RGltZW5zaW9uQ29uZmlnIH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2RpbWVuc2lvbnMvdHlwZXMnO1xuXG5pbXBvcnQgeyBDYW52YXNFbGVtZW50SXRlbSwgQ2FudmFzRWxlbWVudFByb3BzIH0gZnJvbSAnLi4vZWxlbWVudCc7XG5cbmV4cG9ydCBlbnVtIEFsaWduIHtcbiAgTGVmdCA9ICdsZWZ0JyxcbiAgQ2VudGVyID0gJ2NlbnRlcicsXG4gIFJpZ2h0ID0gJ3JpZ2h0Jyxcbn1cblxuZXhwb3J0IGVudW0gVkFsaWduIHtcbiAgVG9wID0gJ3RvcCcsXG4gIE1pZGRsZSA9ICdtaWRkbGUnLFxuICBCb3R0b20gPSAnYm90dG9tJyxcbn1cblxuaW50ZXJmYWNlIFRleHRCb3hEYXRhIHtcbiAgdGV4dD86IHN0cmluZztcbiAgY29sb3I/OiBzdHJpbmc7XG4gIHNpemU/OiBudW1iZXI7IC8vIDAgb3IgbWlzc2luZyB3aWxsIFwiYXV0byBzaXplXCJcbiAgYWxpZ246IEFsaWduO1xuICB2YWxpZ246IFZBbGlnbjtcbn1cblxuaW50ZXJmYWNlIFRleHRCb3hDb25maWcge1xuICB0ZXh0PzogVGV4dERpbWVuc2lvbkNvbmZpZztcbiAgY29sb3I/OiBDb2xvckRpbWVuc2lvbkNvbmZpZztcbiAgc2l6ZT86IG51bWJlcjsgLy8gMCBvciBtaXNzaW5nIHdpbGwgXCJhdXRvIHNpemVcIlxuICBhbGlnbjogQWxpZ247XG4gIHZhbGlnbjogVkFsaWduO1xufVxuXG5jbGFzcyBUZXh0Qm94RGlzcGxheSBleHRlbmRzIFB1cmVDb21wb25lbnQ8Q2FudmFzRWxlbWVudFByb3BzPFRleHRCb3hDb25maWcsIFRleHRCb3hEYXRhPj4ge1xuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBkYXRhIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHN0eWxlcyA9IGdldFN0eWxlcyhjb25maWcudGhlbWUyLCBkYXRhKTtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5jb250YWluZXJ9PlxuICAgICAgICA8c3BhbiBjbGFzc05hbWU9e3N0eWxlcy5zcGFufT57ZGF0YT8udGV4dH08L3NwYW4+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG5jb25zdCBnZXRTdHlsZXMgPSBzdHlsZXNGYWN0b3J5KCh0aGVtZTogR3JhZmFuYVRoZW1lMiwgZGF0YSkgPT4gKHtcbiAgY29udGFpbmVyOiBjc3NgXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIGhlaWdodDogMTAwJTtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBkaXNwbGF5OiB0YWJsZTtcbiAgYCxcbiAgc3BhbjogY3NzYFxuICAgIGRpc3BsYXk6IHRhYmxlLWNlbGw7XG4gICAgdmVydGljYWwtYWxpZ246ICR7ZGF0YS52YWxpZ259O1xuICAgIHRleHQtYWxpZ246ICR7ZGF0YS5hbGlnbn07XG4gICAgZm9udC1zaXplOiAke2RhdGE/LnNpemV9cHg7XG4gICAgY29sb3I6ICR7ZGF0YT8uY29sb3J9O1xuICBgLFxufSkpO1xuZXhwb3J0IGNvbnN0IHRleHRCb3hJdGVtOiBDYW52YXNFbGVtZW50SXRlbTxUZXh0Qm94Q29uZmlnLCBUZXh0Qm94RGF0YT4gPSB7XG4gIGlkOiAndGV4dC1ib3gnLFxuICBuYW1lOiAnVGV4dCcsXG4gIGRlc2NyaXB0aW9uOiAnVGV4dCBib3gnLFxuXG4gIGRpc3BsYXk6IFRleHRCb3hEaXNwbGF5LFxuXG4gIGRlZmF1bHRTaXplOiB7XG4gICAgd2lkdGg6IDI0MCxcbiAgICBoZWlnaHQ6IDE2MCxcbiAgfSxcblxuICBnZXROZXdPcHRpb25zOiAob3B0aW9ucykgPT4gKHtcbiAgICBiYWNrZ3JvdW5kOiB7XG4gICAgICBjb2xvcjoge1xuICAgICAgICBmaXhlZDogJ2dyZXknLFxuICAgICAgfSxcbiAgICB9LFxuICAgIC4uLm9wdGlvbnMsXG4gICAgY29uZmlnOiB7XG4gICAgICBhbGlnbjogQWxpZ24uTGVmdCxcbiAgICAgIHZhbGlnbjogVkFsaWduLk1pZGRsZSxcbiAgICB9LFxuICB9KSxcblxuICAvLyBDYWxsZWQgd2hlbiBkYXRhIGNoYW5nZXNcbiAgcHJlcGFyZURhdGE6IChjdHg6IERpbWVuc2lvbkNvbnRleHQsIGNmZzogVGV4dEJveENvbmZpZykgPT4ge1xuICAgIGNvbnN0IGRhdGE6IFRleHRCb3hEYXRhID0ge1xuICAgICAgdGV4dDogY2ZnLnRleHQgPyBjdHguZ2V0VGV4dChjZmcudGV4dCkudmFsdWUoKSA6ICcnLFxuICAgICAgYWxpZ246IGNmZy5hbGlnbiA/PyBBbGlnbi5DZW50ZXIsXG4gICAgICB2YWxpZ246IGNmZy52YWxpZ24gPz8gVkFsaWduLk1pZGRsZSxcbiAgICAgIHNpemU6IGNmZy5zaXplLFxuICAgIH07XG5cbiAgICBpZiAoY2ZnLmNvbG9yKSB7XG4gICAgICBkYXRhLmNvbG9yID0gY3R4LmdldENvbG9yKGNmZy5jb2xvcikudmFsdWUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfSxcblxuICAvLyBIZWF0bWFwIG92ZXJsYXkgb3B0aW9uc1xuICByZWdpc3Rlck9wdGlvbnNVSTogKGJ1aWxkZXIpID0+IHtcbiAgICBjb25zdCBjYXRlZ29yeSA9IFsnVGV4dCBib3gnXTtcbiAgICBidWlsZGVyXG4gICAgICAuYWRkQ3VzdG9tRWRpdG9yKHtcbiAgICAgICAgY2F0ZWdvcnksXG4gICAgICAgIGlkOiAndGV4dFNlbGVjdG9yJyxcbiAgICAgICAgcGF0aDogJ2NvbmZpZy50ZXh0JyxcbiAgICAgICAgbmFtZTogJ1RleHQnLFxuICAgICAgICBlZGl0b3I6IFRleHREaW1lbnNpb25FZGl0b3IsXG4gICAgICB9KVxuICAgICAgLmFkZEN1c3RvbUVkaXRvcih7XG4gICAgICAgIGNhdGVnb3J5LFxuICAgICAgICBpZDogJ2NvbmZpZy5jb2xvcicsXG4gICAgICAgIHBhdGg6ICdjb25maWcuY29sb3InLFxuICAgICAgICBuYW1lOiAnVGV4dCBjb2xvcicsXG4gICAgICAgIGVkaXRvcjogQ29sb3JEaW1lbnNpb25FZGl0b3IsXG4gICAgICAgIHNldHRpbmdzOiB7fSxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB7fSxcbiAgICAgIH0pXG4gICAgICAuYWRkUmFkaW8oe1xuICAgICAgICBjYXRlZ29yeSxcbiAgICAgICAgcGF0aDogJ2NvbmZpZy5hbGlnbicsXG4gICAgICAgIG5hbWU6ICdBbGlnbiB0ZXh0JyxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBvcHRpb25zOiBbXG4gICAgICAgICAgICB7IHZhbHVlOiBBbGlnbi5MZWZ0LCBsYWJlbDogJ0xlZnQnIH0sXG4gICAgICAgICAgICB7IHZhbHVlOiBBbGlnbi5DZW50ZXIsIGxhYmVsOiAnQ2VudGVyJyB9LFxuICAgICAgICAgICAgeyB2YWx1ZTogQWxpZ24uUmlnaHQsIGxhYmVsOiAnUmlnaHQnIH0sXG4gICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBBbGlnbi5MZWZ0LFxuICAgICAgfSlcbiAgICAgIC5hZGRSYWRpbyh7XG4gICAgICAgIGNhdGVnb3J5LFxuICAgICAgICBwYXRoOiAnY29uZmlnLnZhbGlnbicsXG4gICAgICAgIG5hbWU6ICdWZXJ0aWNhbCBhbGlnbicsXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgb3B0aW9uczogW1xuICAgICAgICAgICAgeyB2YWx1ZTogVkFsaWduLlRvcCwgbGFiZWw6ICdUb3AnIH0sXG4gICAgICAgICAgICB7IHZhbHVlOiBWQWxpZ24uTWlkZGxlLCBsYWJlbDogJ01pZGRsZScgfSxcbiAgICAgICAgICAgIHsgdmFsdWU6IFZBbGlnbi5Cb3R0b20sIGxhYmVsOiAnQm90dG9tJyB9LFxuICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogVkFsaWduLk1pZGRsZSxcbiAgICAgIH0pXG4gICAgICAuYWRkTnVtYmVySW5wdXQoe1xuICAgICAgICBjYXRlZ29yeSxcbiAgICAgICAgcGF0aDogJ2NvbmZpZy5zaXplJyxcbiAgICAgICAgbmFtZTogJ1RleHQgc2l6ZScsXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgcGxhY2Vob2xkZXI6ICdBdXRvJyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICB9LFxufTtcbiIsImltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgUmVhY3QsIHsgRkMgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IEdyYWZhbmFUaGVtZTIgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IHVzZVN0eWxlczIgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5pbXBvcnQgeyBEaW1lbnNpb25Db250ZXh0LCBTY2FsYXJEaW1lbnNpb25Db25maWcgfSBmcm9tICdhcHAvZmVhdHVyZXMvZGltZW5zaW9ucyc7XG5pbXBvcnQgeyBTY2FsYXJEaW1lbnNpb25FZGl0b3IgfSBmcm9tICdhcHAvZmVhdHVyZXMvZGltZW5zaW9ucy9lZGl0b3JzJztcblxuaW1wb3J0IHsgQ2FudmFzRWxlbWVudEl0ZW0sIENhbnZhc0VsZW1lbnRQcm9wcyB9IGZyb20gJy4uL2VsZW1lbnQnO1xuXG5pbnRlcmZhY2UgV2luZFR1cmJpbmVEYXRhIHtcbiAgcnBtPzogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgV2luZFR1cmJpbmVDb25maWcge1xuICBycG0/OiBTY2FsYXJEaW1lbnNpb25Db25maWc7XG59XG5cbmNvbnN0IFdpbmRUdXJiaW5lRGlzcGxheTogRkM8Q2FudmFzRWxlbWVudFByb3BzPFdpbmRUdXJiaW5lQ29uZmlnLCBXaW5kVHVyYmluZURhdGE+PiA9IChwcm9wcykgPT4ge1xuICBjb25zdCBzdHlsZXMgPSB1c2VTdHlsZXMyKGdldFN0eWxlcyk7XG5cbiAgY29uc3QgeyBkYXRhIH0gPSBwcm9wcztcblxuICBjb25zdCB3aW5kVHVyYmluZUFuaW1hdGlvbiA9IGBzcGluICR7ZGF0YT8ucnBtID8gNjAgLyBNYXRoLmFicyhkYXRhLnJwbSkgOiAwfXMgbGluZWFyIGluZmluaXRlYDtcblxuICByZXR1cm4gKFxuICAgIDxzdmcgdmlld0JveD1cIjAgMCAxODkuMzI2IDI4My45ODlcIiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPVwieE1pZFlNaWQgbWVldFwiPlxuICAgICAgPHN5bWJvbCBpZD1cImJsYWRlXCI+XG4gICAgICAgIDxwYXRoXG4gICAgICAgICAgZmlsbD1cIiNlNmU2ZTZcIlxuICAgICAgICAgIGlkPVwiYmxhZGUtZnJvbnRcIlxuICAgICAgICAgIGQ9XCJNMTQuNjQ5MTg3OSwxLjg1MDExNjAxIEMxNC4yNjg0NDU1LC0wLjA1MzU5NjI4NzcgMTAuNzE1MDgxMiwtMC44MTUwODEyMDYgOS4wNjQ3MzMxOCwzLjM3MzA4NTg1IEwwLjQzNDMzODc0Nyw3MC43NjU4OTMzIEw4LjkzODA1MTA0LDkxLjk2MDc4ODkgTDE1LjQxMDY3MjksOTAuNDM3ODE5IEwxNy41Njg0NDU1LDc4LjM4MDc0MjUgTDE0LjUyMTgwOTcsMS45NzY3OTgxNCBMMTQuNjQ5MTg3OSwxLjg1MDExNjAxIFpcIlxuICAgICAgICAvPlxuICAgICAgICA8cGF0aFxuICAgICAgICAgIGZpbGw9XCIjZDBkNmQ3XCJcbiAgICAgICAgICBpZD1cImJsYWRlLXNpZGVcIlxuICAgICAgICAgIGQ9XCJNMTEuMDk1MTI3NiwwLjU4MTIwNjQ5NyBDMTAuMzMzNjQyNywwLjk2MTk0ODk1NiA5LjU3MjE1Nzc3LDEuODUwMTE2MDEgOC45MzczNTQ5OSwzLjI0NjQwMzcxIEwwLjMwNjk2MDU1Nyw3MC42MzkyMTExIEw4LjgxMDY3Mjg1LDkxLjgzNDEwNjcgTDMuMzUzNTk2MjksNzAuMDA0NDA4NCBMMTEuMDk1MTI3NiwwLjU4MTIwNjQ5NyBaXCJcbiAgICAgICAgLz5cbiAgICAgIDwvc3ltYm9sPlxuXG4gICAgICA8Zz5cbiAgICAgICAgPGcgaWQ9XCJzdHJ1Y3R1cmVcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoNTguMTIzLCA4Mi42NjQpXCIgZmlsbFJ1bGU9XCJub256ZXJvXCI+XG4gICAgICAgICAgPHBvbHlnb24gaWQ9XCJ0b3dlclwiIGZpbGw9XCIjZTZlNmU2XCIgcG9pbnRzPVwiMzMuMTExLDEwLjk4NCAzOS45NjUsMTAuOTg0IDQ0LjI4LDE5Ni4xNzYgMjguNzk2LDE5Ni4xNzZcIiAvPlxuICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICBpZD1cInlhd1wiXG4gICAgICAgICAgICBmaWxsPVwicmdiYSgwLDAsMCwwLjI1KVwiXG4gICAgICAgICAgICBkPVwiTTQwLjM0NTQ3NTYsMjMuMjk0ODk1NiBMNDAuNzI2MjE4MSwzNC44NDQ1NDc2IEMzOC44MjI1MDU4LDM1LjA5ODYwNzkgMzUuNzc2NTY2MSwzNS4wOTg2MDc5IDMyLjM0OTg4NCwzNC4zMzcxMjMgTDMyLjczMDYyNjUsMjMuMjk1NTkxNiBMNDAuMzQ1NDc1NiwyMy4yOTU1OTE2IEw0MC4zNDU0NzU2LDIzLjI5NDg5NTYgWlwiXG4gICAgICAgICAgLz5cbiAgICAgICAgICA8cGF0aFxuICAgICAgICAgICAgaWQ9XCJiYXNlXCJcbiAgICAgICAgICAgIGZpbGw9XCIjZDBkNmQ3XCJcbiAgICAgICAgICAgIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgwIDQyKVwiXG4gICAgICAgICAgICBkPVwiTTI2LjM4NDY4NjgsMTUwLjU5MTY0NyBMNDYuNTY0MDM3MSwxNTAuNTkxNjQ3IEM0OC44NDg0OTE5LDE1MC41OTE2NDcgNTAuNzUyMjA0MiwxNTIuNDk1MzYgNTAuNzUyMjA0MiwxNTQuNzc5ODE0IEw1MC43NTIyMDQyLDE1OC45Njc5ODEgTDIyLjA2OTE0MTUsMTU4Ljk2Nzk4MSBMMjIuMDY5MTQxNSwxNTQuNzc5ODE0IEMyMi4wNjkxNDE1LDE1Mi40OTUzNiAyMy45NzI4NTM4LDE1MC41OTE2NDcgMjYuMjU3MzA4NiwxNTAuNTkxNjQ3IEwyNi4zODQ2ODY4LDE1MC41OTE2NDcgWlwiXG4gICAgICAgICAgLz5cbiAgICAgICAgICA8Y2lyY2xlIGlkPVwibmFjZWxsZVwiIGZpbGw9XCIjZTZlNmU2XCIgY3g9XCIzNi41NFwiIGN5PVwiMTJcIiByPVwiMTEuOTNcIiAvPlxuICAgICAgICAgIDxjaXJjbGUgaWQ9XCJnZWFyYm94XCIgZmlsbD1cIm5vbmVcIiBzdHJva2U9XCIjZDBkNmQ3XCIgc3Ryb2tlV2lkdGg9XCIyLjc1XCIgY3g9XCIzNi41MzhcIiBjeT1cIjExLjk5OVwiIHI9XCI1LjhcIiAvPlxuICAgICAgICA8L2c+XG4gICAgICAgIDxnIGNsYXNzTmFtZT17c3R5bGVzLmJsYWRlfSBzdHlsZT17eyBhbmltYXRpb246IHdpbmRUdXJiaW5lQW5pbWF0aW9uIH19PlxuICAgICAgICAgIDx1c2UgaWQ9XCJibGFkZTFcIiBocmVmPVwiI2JsYWRlXCIgeD1cIjgzLjI0XCIgeT1cIjBcIiAvPlxuICAgICAgICAgIDx1c2UgaWQ9XCJibGFkZTJcIiBocmVmPVwiI2JsYWRlXCIgeD1cIjgzLjI0XCIgeT1cIjBcIiB0cmFuc2Zvcm09XCJyb3RhdGUoMTIwIDk0LjY2MyA5NC42NjMpXCIgLz5cbiAgICAgICAgICA8dXNlIGlkPVwiYmxhZGUzXCIgaHJlZj1cIiNibGFkZVwiIHg9XCI4My4yNFwiIHk9XCIwXCIgdHJhbnNmb3JtPVwicm90YXRlKC0xMjAgOTQuNjYzIDk0LjY2MylcIiAvPlxuICAgICAgICA8L2c+XG4gICAgICA8L2c+XG4gICAgPC9zdmc+XG4gICk7XG59O1xuXG5leHBvcnQgY29uc3Qgd2luZFR1cmJpbmVJdGVtOiBDYW52YXNFbGVtZW50SXRlbTxhbnksIGFueT4gPSB7XG4gIGlkOiAnd2luZFR1cmJpbmUnLFxuICBuYW1lOiAnV2luZCBUdXJiaW5lJyxcbiAgZGVzY3JpcHRpb246ICdTcGlubnkgc3Bpbm55JyxcblxuICBkaXNwbGF5OiBXaW5kVHVyYmluZURpc3BsYXksXG5cbiAgZGVmYXVsdFNpemU6IHtcbiAgICB3aWR0aDogMTAwLFxuICAgIGhlaWdodDogMTAwLFxuICB9LFxuXG4gIGdldE5ld09wdGlvbnM6IChvcHRpb25zKSA9PiAoe1xuICAgIC4uLm9wdGlvbnMsXG4gIH0pLFxuXG4gIC8vIENhbGxlZCB3aGVuIGRhdGEgY2hhbmdlc1xuICBwcmVwYXJlRGF0YTogKGN0eDogRGltZW5zaW9uQ29udGV4dCwgY2ZnOiBXaW5kVHVyYmluZUNvbmZpZykgPT4ge1xuICAgIGNvbnN0IGRhdGE6IFdpbmRUdXJiaW5lRGF0YSA9IHtcbiAgICAgIHJwbTogY2ZnPy5ycG0gPyBjdHguZ2V0U2NhbGFyKGNmZy5ycG0pLnZhbHVlKCkgOiAwLFxuICAgIH07XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfSxcblxuICByZWdpc3Rlck9wdGlvbnNVSTogKGJ1aWxkZXIpID0+IHtcbiAgICBjb25zdCBjYXRlZ29yeSA9IFsnV2luZCBUdXJiaW5lJ107XG4gICAgYnVpbGRlci5hZGRDdXN0b21FZGl0b3Ioe1xuICAgICAgY2F0ZWdvcnksXG4gICAgICBpZDogJ3JwbScsXG4gICAgICBwYXRoOiAnY29uZmlnLnJwbScsXG4gICAgICBuYW1lOiAnUlBNJyxcbiAgICAgIGVkaXRvcjogU2NhbGFyRGltZW5zaW9uRWRpdG9yLFxuICAgIH0pO1xuICB9LFxufTtcblxuY29uc3QgZ2V0U3R5bGVzID0gKHRoZW1lOiBHcmFmYW5hVGhlbWUyKSA9PiAoe1xuICBibGFkZTogY3NzYFxuICAgIEBrZXlmcmFtZXMgc3BpbiB7XG4gICAgICBmcm9tIHtcbiAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XG4gICAgICB9XG4gICAgICB0byB7XG4gICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJhbnNmb3JtLW9yaWdpbjogOTQuNjYzcHggOTQuNjYzcHg7XG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMTVkZWcpO1xuICBgLFxufSk7XG4iLCJleHBvcnQgKiBmcm9tICcuL3R5cGVzJztcbmV4cG9ydCAqIGZyb20gJy4vZWxlbWVudCc7XG5leHBvcnQgeyBDYW52YXNGcmFtZU9wdGlvbnMgfSBmcm9tICcuL2ZyYW1lJztcbmV4cG9ydCAqIGZyb20gJy4vcmVnaXN0cnknO1xuIiwiaW1wb3J0IHsgUmVnaXN0cnkgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcblxuaW1wb3J0IHsgQ2FudmFzRWxlbWVudEl0ZW0sIENhbnZhc0VsZW1lbnRPcHRpb25zIH0gZnJvbSAnLi9lbGVtZW50JztcbmltcG9ydCB7IGJ1dHRvbkl0ZW0gfSBmcm9tICcuL2VsZW1lbnRzL2J1dHRvbic7XG5pbXBvcnQgeyBkcm9uZUZyb250SXRlbSB9IGZyb20gJy4vZWxlbWVudHMvZHJvbmVGcm9udCc7XG5pbXBvcnQgeyBkcm9uZVNpZGVJdGVtIH0gZnJvbSAnLi9lbGVtZW50cy9kcm9uZVNpZGUnO1xuaW1wb3J0IHsgZHJvbmVUb3BJdGVtIH0gZnJvbSAnLi9lbGVtZW50cy9kcm9uZVRvcCc7XG5pbXBvcnQgeyBpY29uSXRlbSB9IGZyb20gJy4vZWxlbWVudHMvaWNvbic7XG5pbXBvcnQgeyB0ZXh0Qm94SXRlbSB9IGZyb20gJy4vZWxlbWVudHMvdGV4dEJveCc7XG5pbXBvcnQgeyB3aW5kVHVyYmluZUl0ZW0gfSBmcm9tICcuL2VsZW1lbnRzL3dpbmRUdXJiaW5lJztcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfQ0FOVkFTX0VMRU1FTlRfQ09ORklHOiBDYW52YXNFbGVtZW50T3B0aW9ucyA9IHtcbiAgLi4uaWNvbkl0ZW0uZ2V0TmV3T3B0aW9ucygpLFxuICB0eXBlOiBpY29uSXRlbS5pZCxcbiAgbmFtZTogYEVsZW1lbnQgMWAsXG59O1xuXG5leHBvcnQgY29uc3QgY2FudmFzRWxlbWVudFJlZ2lzdHJ5ID0gbmV3IFJlZ2lzdHJ5PENhbnZhc0VsZW1lbnRJdGVtPigoKSA9PiBbXG4gIGljb25JdGVtLCAvLyBkZWZhdWx0IGZvciBub3dcbiAgdGV4dEJveEl0ZW0sXG4gIGJ1dHRvbkl0ZW0sXG4gIGRyb25lVG9wSXRlbSxcbiAgZHJvbmVGcm9udEl0ZW0sXG4gIGRyb25lU2lkZUl0ZW0sXG4gIHdpbmRUdXJiaW5lSXRlbSxcbl0pO1xuIiwiaW1wb3J0IFJlYWN0LCB7IENTU1Byb3BlcnRpZXMgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBPbkRyYWcsIE9uUmVzaXplIH0gZnJvbSAncmVhY3QtbW92ZWFibGUvZGVjbGFyYXRpb24vdHlwZXMnO1xuXG5pbXBvcnQgeyBMYXllckVsZW1lbnQgfSBmcm9tICdhcHAvY29yZS9jb21wb25lbnRzL0xheWVycy90eXBlcyc7XG5pbXBvcnQge1xuICBCYWNrZ3JvdW5kSW1hZ2VTaXplLFxuICBDYW52YXNFbGVtZW50SXRlbSxcbiAgQ2FudmFzRWxlbWVudE9wdGlvbnMsXG4gIGNhbnZhc0VsZW1lbnRSZWdpc3RyeSxcbn0gZnJvbSAnYXBwL2ZlYXR1cmVzL2NhbnZhcyc7XG5pbXBvcnQgeyBub3RGb3VuZEl0ZW0gfSBmcm9tICdhcHAvZmVhdHVyZXMvY2FudmFzL2VsZW1lbnRzL25vdEZvdW5kJztcbmltcG9ydCB7IERpbWVuc2lvbkNvbnRleHQgfSBmcm9tICdhcHAvZmVhdHVyZXMvZGltZW5zaW9ucyc7XG5cbmltcG9ydCB7IEhvcml6b250YWxDb25zdHJhaW50LCBQbGFjZW1lbnQsIFZlcnRpY2FsQ29uc3RyYWludCB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgRnJhbWVTdGF0ZSB9IGZyb20gJy4vZnJhbWUnO1xuaW1wb3J0IHsgUm9vdEVsZW1lbnQgfSBmcm9tICcuL3Jvb3QnO1xuaW1wb3J0IHsgU2NlbmUgfSBmcm9tICcuL3NjZW5lJztcblxubGV0IGNvdW50ZXIgPSAwO1xuXG5leHBvcnQgY2xhc3MgRWxlbWVudFN0YXRlIGltcGxlbWVudHMgTGF5ZXJFbGVtZW50IHtcbiAgLy8gVUlEIG5lY2Vzc2FyeSBmb3IgbW92ZWFibGUgdG8gd29yayAoZm9yIG5vdylcbiAgcmVhZG9ubHkgVUlEID0gY291bnRlcisrO1xuICByZXZJZCA9IDA7XG4gIHNpemVTdHlsZTogQ1NTUHJvcGVydGllcyA9IHt9O1xuICBkYXRhU3R5bGU6IENTU1Byb3BlcnRpZXMgPSB7fTtcblxuICAvLyBGaWxsZWQgaW4gYnkgcmVmXG4gIGRpdj86IEhUTUxEaXZFbGVtZW50O1xuXG4gIC8vIENhbGN1bGF0ZWRcbiAgZGF0YT86IGFueTsgLy8gZGVwZW5kcyBvbiB0aGUgdHlwZVxuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBpdGVtOiBDYW52YXNFbGVtZW50SXRlbSwgcHVibGljIG9wdGlvbnM6IENhbnZhc0VsZW1lbnRPcHRpb25zLCBwdWJsaWMgcGFyZW50PzogRnJhbWVTdGF0ZSkge1xuICAgIGNvbnN0IGZhbGxiYWNrTmFtZSA9IGBFbGVtZW50ICR7RGF0ZS5ub3coKX1gO1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0geyB0eXBlOiBpdGVtLmlkLCBuYW1lOiBmYWxsYmFja05hbWUgfTtcbiAgICB9XG5cbiAgICBvcHRpb25zLmNvbnN0cmFpbnQgPSBvcHRpb25zLmNvbnN0cmFpbnQgPz8ge1xuICAgICAgdmVydGljYWw6IFZlcnRpY2FsQ29uc3RyYWludC5Ub3AsXG4gICAgICBob3Jpem9udGFsOiBIb3Jpem9udGFsQ29uc3RyYWludC5MZWZ0LFxuICAgIH07XG4gICAgb3B0aW9ucy5wbGFjZW1lbnQgPSBvcHRpb25zLnBsYWNlbWVudCA/PyB7IHdpZHRoOiAxMDAsIGhlaWdodDogMTAwLCB0b3A6IDAsIGxlZnQ6IDAgfTtcbiAgICBjb25zdCBzY2VuZSA9IHRoaXMuZ2V0U2NlbmUoKTtcbiAgICBpZiAoIW9wdGlvbnMubmFtZSkge1xuICAgICAgY29uc3QgbmV3TmFtZSA9IHNjZW5lPy5nZXROZXh0RWxlbWVudE5hbWUoKTtcbiAgICAgIG9wdGlvbnMubmFtZSA9IG5ld05hbWUgPz8gZmFsbGJhY2tOYW1lO1xuICAgIH1cbiAgICBzY2VuZT8uYnlOYW1lLnNldChvcHRpb25zLm5hbWUsIHRoaXMpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRTY2VuZSgpOiBTY2VuZSB8IHVuZGVmaW5lZCB7XG4gICAgbGV0IHRyYXYgPSB0aGlzLnBhcmVudDtcbiAgICB3aGlsZSAodHJhdikge1xuICAgICAgaWYgKHRyYXYuaXNSb290KCkpIHtcbiAgICAgICAgcmV0dXJuIHRyYXYuc2NlbmU7XG4gICAgICB9XG4gICAgICB0cmF2ID0gdHJhdi5wYXJlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGdldE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5uYW1lO1xuICB9XG5cbiAgLyoqIFVzZSB0aGUgY29uZmlndXJlZCBvcHRpb25zIHRvIHVwZGF0ZSBDU1Mgc3R5bGUgcHJvcGVydGllcyBkaXJlY3RseSBvbiB0aGUgd3JhcHBlciBkaXYgKiovXG4gIGFwcGx5TGF5b3V0U3R5bGVzVG9EaXYoKSB7XG4gICAgaWYgKHRoaXMuaXNSb290KCkpIHtcbiAgICAgIC8vIFJvb3Qgc3VwZXJzZWRlcyBsYXlvdXQgZW5naW5lIGFuZCBpcyBhbHdheXMgMTAwJSB3aWR0aCArIGhlaWdodCBvZiBwYW5lbFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHsgY29uc3RyYWludCB9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHsgdmVydGljYWwsIGhvcml6b250YWwgfSA9IGNvbnN0cmFpbnQgPz8ge307XG4gICAgY29uc3QgcGxhY2VtZW50ID0gdGhpcy5vcHRpb25zLnBsYWNlbWVudCA/PyAoe30gYXMgUGxhY2VtZW50KTtcblxuICAgIGNvbnN0IHN0eWxlOiBSZWFjdC5DU1NQcm9wZXJ0aWVzID0ge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgfTtcblxuICAgIGNvbnN0IHRyYW5zbGF0ZSA9IFsnMHB4JywgJzBweCddO1xuXG4gICAgc3dpdGNoICh2ZXJ0aWNhbCkge1xuICAgICAgY2FzZSBWZXJ0aWNhbENvbnN0cmFpbnQuVG9wOlxuICAgICAgICBwbGFjZW1lbnQudG9wID0gcGxhY2VtZW50LnRvcCA/PyAwO1xuICAgICAgICBwbGFjZW1lbnQuaGVpZ2h0ID0gcGxhY2VtZW50LmhlaWdodCA/PyAxMDA7XG4gICAgICAgIHN0eWxlLnRvcCA9IGAke3BsYWNlbWVudC50b3B9cHhgO1xuICAgICAgICBzdHlsZS5oZWlnaHQgPSBgJHtwbGFjZW1lbnQuaGVpZ2h0fXB4YDtcbiAgICAgICAgZGVsZXRlIHBsYWNlbWVudC5ib3R0b207XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBWZXJ0aWNhbENvbnN0cmFpbnQuQm90dG9tOlxuICAgICAgICBwbGFjZW1lbnQuYm90dG9tID0gcGxhY2VtZW50LmJvdHRvbSA/PyAwO1xuICAgICAgICBwbGFjZW1lbnQuaGVpZ2h0ID0gcGxhY2VtZW50LmhlaWdodCA/PyAxMDA7XG4gICAgICAgIHN0eWxlLmJvdHRvbSA9IGAke3BsYWNlbWVudC5ib3R0b219cHhgO1xuICAgICAgICBzdHlsZS5oZWlnaHQgPSBgJHtwbGFjZW1lbnQuaGVpZ2h0fXB4YDtcbiAgICAgICAgZGVsZXRlIHBsYWNlbWVudC50b3A7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBWZXJ0aWNhbENvbnN0cmFpbnQuVG9wQm90dG9tOlxuICAgICAgICBwbGFjZW1lbnQudG9wID0gcGxhY2VtZW50LnRvcCA/PyAwO1xuICAgICAgICBwbGFjZW1lbnQuYm90dG9tID0gcGxhY2VtZW50LmJvdHRvbSA/PyAwO1xuICAgICAgICBzdHlsZS50b3AgPSBgJHtwbGFjZW1lbnQudG9wfXB4YDtcbiAgICAgICAgc3R5bGUuYm90dG9tID0gYCR7cGxhY2VtZW50LmJvdHRvbX1weGA7XG4gICAgICAgIGRlbGV0ZSBwbGFjZW1lbnQuaGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVmVydGljYWxDb25zdHJhaW50LkNlbnRlcjpcbiAgICAgICAgcGxhY2VtZW50LnRvcCA9IHBsYWNlbWVudC50b3AgPz8gMDtcbiAgICAgICAgcGxhY2VtZW50LmhlaWdodCA9IHBsYWNlbWVudC5oZWlnaHQgPz8gMTAwO1xuICAgICAgICB0cmFuc2xhdGVbMV0gPSAnLTUwJSc7XG4gICAgICAgIHN0eWxlLnRvcCA9IGBjYWxjKDUwJSAtICR7cGxhY2VtZW50LnRvcH1weClgO1xuICAgICAgICBzdHlsZS5oZWlnaHQgPSBgJHtwbGFjZW1lbnQuaGVpZ2h0fXB4YDtcbiAgICAgICAgZGVsZXRlIHBsYWNlbWVudC5ib3R0b207XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBWZXJ0aWNhbENvbnN0cmFpbnQuU2NhbGU6XG4gICAgICAgIHBsYWNlbWVudC50b3AgPSBwbGFjZW1lbnQudG9wID8/IDA7XG4gICAgICAgIHBsYWNlbWVudC5ib3R0b20gPSBwbGFjZW1lbnQuYm90dG9tID8/IDA7XG4gICAgICAgIHN0eWxlLnRvcCA9IGAke3BsYWNlbWVudC50b3B9JWA7XG4gICAgICAgIHN0eWxlLmJvdHRvbSA9IGAke3BsYWNlbWVudC5ib3R0b219JWA7XG4gICAgICAgIGRlbGV0ZSBwbGFjZW1lbnQuaGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGhvcml6b250YWwpIHtcbiAgICAgIGNhc2UgSG9yaXpvbnRhbENvbnN0cmFpbnQuTGVmdDpcbiAgICAgICAgcGxhY2VtZW50LmxlZnQgPSBwbGFjZW1lbnQubGVmdCA/PyAwO1xuICAgICAgICBwbGFjZW1lbnQud2lkdGggPSBwbGFjZW1lbnQud2lkdGggPz8gMTAwO1xuICAgICAgICBzdHlsZS5sZWZ0ID0gYCR7cGxhY2VtZW50LmxlZnR9cHhgO1xuICAgICAgICBzdHlsZS53aWR0aCA9IGAke3BsYWNlbWVudC53aWR0aH1weGA7XG4gICAgICAgIGRlbGV0ZSBwbGFjZW1lbnQucmlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBIb3Jpem9udGFsQ29uc3RyYWludC5SaWdodDpcbiAgICAgICAgcGxhY2VtZW50LnJpZ2h0ID0gcGxhY2VtZW50LnJpZ2h0ID8/IDA7XG4gICAgICAgIHBsYWNlbWVudC53aWR0aCA9IHBsYWNlbWVudC53aWR0aCA/PyAxMDA7XG4gICAgICAgIHN0eWxlLnJpZ2h0ID0gYCR7cGxhY2VtZW50LnJpZ2h0fXB4YDtcbiAgICAgICAgc3R5bGUud2lkdGggPSBgJHtwbGFjZW1lbnQud2lkdGh9cHhgO1xuICAgICAgICBkZWxldGUgcGxhY2VtZW50LmxlZnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBIb3Jpem9udGFsQ29uc3RyYWludC5MZWZ0UmlnaHQ6XG4gICAgICAgIHBsYWNlbWVudC5sZWZ0ID0gcGxhY2VtZW50LmxlZnQgPz8gMDtcbiAgICAgICAgcGxhY2VtZW50LnJpZ2h0ID0gcGxhY2VtZW50LnJpZ2h0ID8/IDA7XG4gICAgICAgIHN0eWxlLmxlZnQgPSBgJHtwbGFjZW1lbnQubGVmdH1weGA7XG4gICAgICAgIHN0eWxlLnJpZ2h0ID0gYCR7cGxhY2VtZW50LnJpZ2h0fXB4YDtcbiAgICAgICAgZGVsZXRlIHBsYWNlbWVudC53aWR0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvcml6b250YWxDb25zdHJhaW50LkNlbnRlcjpcbiAgICAgICAgcGxhY2VtZW50LmxlZnQgPSBwbGFjZW1lbnQubGVmdCA/PyAwO1xuICAgICAgICBwbGFjZW1lbnQud2lkdGggPSBwbGFjZW1lbnQud2lkdGggPz8gMTAwO1xuICAgICAgICB0cmFuc2xhdGVbMF0gPSAnLTUwJSc7XG4gICAgICAgIHN0eWxlLmxlZnQgPSBgY2FsYyg1MCUgLSAke3BsYWNlbWVudC5sZWZ0fXB4KWA7XG4gICAgICAgIHN0eWxlLndpZHRoID0gYCR7cGxhY2VtZW50LndpZHRofXB4YDtcbiAgICAgICAgZGVsZXRlIHBsYWNlbWVudC5yaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvcml6b250YWxDb25zdHJhaW50LlNjYWxlOlxuICAgICAgICBwbGFjZW1lbnQubGVmdCA9IHBsYWNlbWVudC5sZWZ0ID8/IDA7XG4gICAgICAgIHBsYWNlbWVudC5yaWdodCA9IHBsYWNlbWVudC5yaWdodCA/PyAwO1xuICAgICAgICBzdHlsZS5sZWZ0ID0gYCR7cGxhY2VtZW50LmxlZnR9JWA7XG4gICAgICAgIHN0eWxlLnJpZ2h0ID0gYCR7cGxhY2VtZW50LnJpZ2h0fSVgO1xuICAgICAgICBkZWxldGUgcGxhY2VtZW50LndpZHRoO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBzdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7dHJhbnNsYXRlWzBdfSwgJHt0cmFuc2xhdGVbMV19KWA7XG4gICAgdGhpcy5vcHRpb25zLnBsYWNlbWVudCA9IHBsYWNlbWVudDtcbiAgICB0aGlzLnNpemVTdHlsZSA9IHN0eWxlO1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5zaXplU3R5bGUpIHtcbiAgICAgICAgdGhpcy5kaXYuc3R5bGVba2V5IGFzIGFueV0gPSAodGhpcy5zaXplU3R5bGUgYXMgYW55KVtrZXldO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLmRhdGFTdHlsZSkge1xuICAgICAgICB0aGlzLmRpdi5zdHlsZVtrZXkgYXMgYW55XSA9ICh0aGlzLmRhdGFTdHlsZSBhcyBhbnkpW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc2V0UGxhY2VtZW50RnJvbUNvbnN0cmFpbnQoZWxlbWVudENvbnRhaW5lcj86IERPTVJlY3QsIHBhcmVudENvbnRhaW5lcj86IERPTVJlY3QpIHtcbiAgICBjb25zdCB7IGNvbnN0cmFpbnQgfSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7IHZlcnRpY2FsLCBob3Jpem9udGFsIH0gPSBjb25zdHJhaW50ID8/IHt9O1xuXG4gICAgaWYgKCFlbGVtZW50Q29udGFpbmVyKSB7XG4gICAgICBlbGVtZW50Q29udGFpbmVyID0gdGhpcy5kaXYgJiYgdGhpcy5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfVxuICAgIGlmICghcGFyZW50Q29udGFpbmVyKSB7XG4gICAgICBwYXJlbnRDb250YWluZXIgPSB0aGlzLmRpdiAmJiB0aGlzLmRpdi5wYXJlbnRFbGVtZW50Py5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9XG5cbiAgICBjb25zdCByZWxhdGl2ZVRvcCA9XG4gICAgICBlbGVtZW50Q29udGFpbmVyICYmIHBhcmVudENvbnRhaW5lciA/IE1hdGguYWJzKE1hdGgucm91bmQoZWxlbWVudENvbnRhaW5lci50b3AgLSBwYXJlbnRDb250YWluZXIudG9wKSkgOiAwO1xuICAgIGNvbnN0IHJlbGF0aXZlQm90dG9tID1cbiAgICAgIGVsZW1lbnRDb250YWluZXIgJiYgcGFyZW50Q29udGFpbmVyID8gTWF0aC5hYnMoTWF0aC5yb3VuZChlbGVtZW50Q29udGFpbmVyLmJvdHRvbSAtIHBhcmVudENvbnRhaW5lci5ib3R0b20pKSA6IDA7XG4gICAgY29uc3QgcmVsYXRpdmVMZWZ0ID1cbiAgICAgIGVsZW1lbnRDb250YWluZXIgJiYgcGFyZW50Q29udGFpbmVyID8gTWF0aC5hYnMoTWF0aC5yb3VuZChlbGVtZW50Q29udGFpbmVyLmxlZnQgLSBwYXJlbnRDb250YWluZXIubGVmdCkpIDogMDtcbiAgICBjb25zdCByZWxhdGl2ZVJpZ2h0ID1cbiAgICAgIGVsZW1lbnRDb250YWluZXIgJiYgcGFyZW50Q29udGFpbmVyID8gTWF0aC5hYnMoTWF0aC5yb3VuZChlbGVtZW50Q29udGFpbmVyLnJpZ2h0IC0gcGFyZW50Q29udGFpbmVyLnJpZ2h0KSkgOiAwO1xuXG4gICAgY29uc3QgcGxhY2VtZW50ID0ge30gYXMgUGxhY2VtZW50O1xuXG4gICAgY29uc3Qgd2lkdGggPSBlbGVtZW50Q29udGFpbmVyPy53aWR0aCA/PyAxMDA7XG4gICAgY29uc3QgaGVpZ2h0ID0gZWxlbWVudENvbnRhaW5lcj8uaGVpZ2h0ID8/IDEwMDtcblxuICAgIHN3aXRjaCAodmVydGljYWwpIHtcbiAgICAgIGNhc2UgVmVydGljYWxDb25zdHJhaW50LlRvcDpcbiAgICAgICAgcGxhY2VtZW50LnRvcCA9IHJlbGF0aXZlVG9wO1xuICAgICAgICBwbGFjZW1lbnQuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVmVydGljYWxDb25zdHJhaW50LkJvdHRvbTpcbiAgICAgICAgcGxhY2VtZW50LmJvdHRvbSA9IHJlbGF0aXZlQm90dG9tO1xuICAgICAgICBwbGFjZW1lbnQuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVmVydGljYWxDb25zdHJhaW50LlRvcEJvdHRvbTpcbiAgICAgICAgcGxhY2VtZW50LnRvcCA9IHJlbGF0aXZlVG9wO1xuICAgICAgICBwbGFjZW1lbnQuYm90dG9tID0gcmVsYXRpdmVCb3R0b207XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBWZXJ0aWNhbENvbnN0cmFpbnQuQ2VudGVyOlxuICAgICAgICBjb25zdCBlbGVtZW50Q2VudGVyID0gZWxlbWVudENvbnRhaW5lciA/IHJlbGF0aXZlVG9wICsgaGVpZ2h0IC8gMiA6IDA7XG4gICAgICAgIGNvbnN0IHBhcmVudENlbnRlciA9IHBhcmVudENvbnRhaW5lciA/IHBhcmVudENvbnRhaW5lci5oZWlnaHQgLyAyIDogMDtcbiAgICAgICAgY29uc3QgZGlzdGFuY2VGcm9tQ2VudGVyID0gcGFyZW50Q2VudGVyIC0gZWxlbWVudENlbnRlcjtcbiAgICAgICAgcGxhY2VtZW50LnRvcCA9IGRpc3RhbmNlRnJvbUNlbnRlcjtcbiAgICAgICAgcGxhY2VtZW50LmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFZlcnRpY2FsQ29uc3RyYWludC5TY2FsZTpcbiAgICAgICAgcGxhY2VtZW50LnRvcCA9IChyZWxhdGl2ZVRvcCAvIChwYXJlbnRDb250YWluZXI/LmhlaWdodCA/PyBoZWlnaHQpKSAqIDEwMDtcbiAgICAgICAgcGxhY2VtZW50LmJvdHRvbSA9IChyZWxhdGl2ZUJvdHRvbSAvIChwYXJlbnRDb250YWluZXI/LmhlaWdodCA/PyBoZWlnaHQpKSAqIDEwMDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgc3dpdGNoIChob3Jpem9udGFsKSB7XG4gICAgICBjYXNlIEhvcml6b250YWxDb25zdHJhaW50LkxlZnQ6XG4gICAgICAgIHBsYWNlbWVudC5sZWZ0ID0gcmVsYXRpdmVMZWZ0O1xuICAgICAgICBwbGFjZW1lbnQud2lkdGggPSB3aWR0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvcml6b250YWxDb25zdHJhaW50LlJpZ2h0OlxuICAgICAgICBwbGFjZW1lbnQucmlnaHQgPSByZWxhdGl2ZVJpZ2h0O1xuICAgICAgICBwbGFjZW1lbnQud2lkdGggPSB3aWR0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvcml6b250YWxDb25zdHJhaW50LkxlZnRSaWdodDpcbiAgICAgICAgcGxhY2VtZW50LmxlZnQgPSByZWxhdGl2ZUxlZnQ7XG4gICAgICAgIHBsYWNlbWVudC5yaWdodCA9IHJlbGF0aXZlUmlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBIb3Jpem9udGFsQ29uc3RyYWludC5DZW50ZXI6XG4gICAgICAgIGNvbnN0IGVsZW1lbnRDZW50ZXIgPSBlbGVtZW50Q29udGFpbmVyID8gcmVsYXRpdmVMZWZ0ICsgd2lkdGggLyAyIDogMDtcbiAgICAgICAgY29uc3QgcGFyZW50Q2VudGVyID0gcGFyZW50Q29udGFpbmVyID8gcGFyZW50Q29udGFpbmVyLndpZHRoIC8gMiA6IDA7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlRnJvbUNlbnRlciA9IHBhcmVudENlbnRlciAtIGVsZW1lbnRDZW50ZXI7XG4gICAgICAgIHBsYWNlbWVudC5sZWZ0ID0gZGlzdGFuY2VGcm9tQ2VudGVyO1xuICAgICAgICBwbGFjZW1lbnQud2lkdGggPSB3aWR0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvcml6b250YWxDb25zdHJhaW50LlNjYWxlOlxuICAgICAgICBwbGFjZW1lbnQubGVmdCA9IChyZWxhdGl2ZUxlZnQgLyAocGFyZW50Q29udGFpbmVyPy53aWR0aCA/PyB3aWR0aCkpICogMTAwO1xuICAgICAgICBwbGFjZW1lbnQucmlnaHQgPSAocmVsYXRpdmVSaWdodCAvIChwYXJlbnRDb250YWluZXI/LndpZHRoID8/IHdpZHRoKSkgKiAxMDA7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucy5wbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG5cbiAgICB0aGlzLmFwcGx5TGF5b3V0U3R5bGVzVG9EaXYoKTtcbiAgICB0aGlzLnJldklkKys7XG4gIH1cblxuICB1cGRhdGVEYXRhKGN0eDogRGltZW5zaW9uQ29udGV4dCkge1xuICAgIGlmICh0aGlzLml0ZW0ucHJlcGFyZURhdGEpIHtcbiAgICAgIHRoaXMuZGF0YSA9IHRoaXMuaXRlbS5wcmVwYXJlRGF0YShjdHgsIHRoaXMub3B0aW9ucy5jb25maWcpO1xuICAgICAgdGhpcy5yZXZJZCsrOyAvLyByZXJlbmRlclxuICAgIH1cblxuICAgIGNvbnN0IHsgYmFja2dyb3VuZCwgYm9yZGVyIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgY3NzOiBDU1NQcm9wZXJ0aWVzID0ge307XG4gICAgaWYgKGJhY2tncm91bmQpIHtcbiAgICAgIGlmIChiYWNrZ3JvdW5kLmNvbG9yKSB7XG4gICAgICAgIGNvbnN0IGNvbG9yID0gY3R4LmdldENvbG9yKGJhY2tncm91bmQuY29sb3IpO1xuICAgICAgICBjc3MuYmFja2dyb3VuZENvbG9yID0gY29sb3IudmFsdWUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChiYWNrZ3JvdW5kLmltYWdlKSB7XG4gICAgICAgIGNvbnN0IGltYWdlID0gY3R4LmdldFJlc291cmNlKGJhY2tncm91bmQuaW1hZ2UpO1xuICAgICAgICBpZiAoaW1hZ2UpIHtcbiAgICAgICAgICBjb25zdCB2ID0gaW1hZ2UudmFsdWUoKTtcbiAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgY3NzLmJhY2tncm91bmRJbWFnZSA9IGB1cmwoXCIke3Z9XCIpYDtcbiAgICAgICAgICAgIHN3aXRjaCAoYmFja2dyb3VuZC5zaXplID8/IEJhY2tncm91bmRJbWFnZVNpemUuQ29udGFpbikge1xuICAgICAgICAgICAgICBjYXNlIEJhY2tncm91bmRJbWFnZVNpemUuQ29udGFpbjpcbiAgICAgICAgICAgICAgICBjc3MuYmFja2dyb3VuZFNpemUgPSAnY29udGFpbic7XG4gICAgICAgICAgICAgICAgY3NzLmJhY2tncm91bmRSZXBlYXQgPSAnbm8tcmVwZWF0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBCYWNrZ3JvdW5kSW1hZ2VTaXplLkNvdmVyOlxuICAgICAgICAgICAgICAgIGNzcy5iYWNrZ3JvdW5kU2l6ZSA9ICdjb3Zlcic7XG4gICAgICAgICAgICAgICAgY3NzLmJhY2tncm91bmRSZXBlYXQgPSAnbm8tcmVwZWF0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBCYWNrZ3JvdW5kSW1hZ2VTaXplLk9yaWdpbmFsOlxuICAgICAgICAgICAgICAgIGNzcy5iYWNrZ3JvdW5kUmVwZWF0ID0gJ25vLXJlcGVhdCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgQmFja2dyb3VuZEltYWdlU2l6ZS5UaWxlOlxuICAgICAgICAgICAgICAgIGNzcy5iYWNrZ3JvdW5kUmVwZWF0ID0gJ3JlcGVhdCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgQmFja2dyb3VuZEltYWdlU2l6ZS5GaWxsOlxuICAgICAgICAgICAgICAgIGNzcy5iYWNrZ3JvdW5kU2l6ZSA9ICcxMDAlIDEwMCUnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChib3JkZXIgJiYgYm9yZGVyLmNvbG9yICYmIGJvcmRlci53aWR0aCkge1xuICAgICAgY29uc3QgY29sb3IgPSBjdHguZ2V0Q29sb3IoYm9yZGVyLmNvbG9yKTtcbiAgICAgIGNzcy5ib3JkZXJXaWR0aCA9IGJvcmRlci53aWR0aDtcbiAgICAgIGNzcy5ib3JkZXJTdHlsZSA9ICdzb2xpZCc7XG4gICAgICBjc3MuYm9yZGVyQ29sb3IgPSBjb2xvci52YWx1ZSgpO1xuXG4gICAgICAvLyBNb3ZlIHRoZSBpbWFnZSB0byBpbnNpZGUgdGhlIGJvcmRlclxuICAgICAgaWYgKGNzcy5iYWNrZ3JvdW5kSW1hZ2UpIHtcbiAgICAgICAgY3NzLmJhY2tncm91bmRPcmlnaW4gPSAncGFkZGluZy1ib3gnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZGF0YVN0eWxlID0gY3NzO1xuICAgIHRoaXMuYXBwbHlMYXlvdXRTdHlsZXNUb0RpdigpO1xuICB9XG5cbiAgaXNSb290KCk6IHRoaXMgaXMgUm9vdEVsZW1lbnQge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKiBSZWN1cnNpdmVseSB2aXNpdCBhbGwgbm9kZXMgKi9cbiAgdmlzaXQodmlzaXRvcjogKHY6IEVsZW1lbnRTdGF0ZSkgPT4gdm9pZCkge1xuICAgIHZpc2l0b3IodGhpcyk7XG4gIH1cblxuICBvbkNoYW5nZShvcHRpb25zOiBDYW52YXNFbGVtZW50T3B0aW9ucykge1xuICAgIGlmICh0aGlzLml0ZW0uaWQgIT09IG9wdGlvbnMudHlwZSkge1xuICAgICAgdGhpcy5pdGVtID0gY2FudmFzRWxlbWVudFJlZ2lzdHJ5LmdldElmRXhpc3RzKG9wdGlvbnMudHlwZSkgPz8gbm90Rm91bmRJdGVtO1xuICAgIH1cblxuICAgIC8vIHJlbmFtZSBoYW5kbGluZ1xuICAgIGNvbnN0IG9sZE5hbWUgPSB0aGlzLm9wdGlvbnMubmFtZTtcbiAgICBjb25zdCBuZXdOYW1lID0gb3B0aW9ucy5uYW1lO1xuXG4gICAgdGhpcy5yZXZJZCsrO1xuICAgIHRoaXMub3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9O1xuICAgIGxldCB0cmF2ID0gdGhpcy5wYXJlbnQ7XG4gICAgd2hpbGUgKHRyYXYpIHtcbiAgICAgIGlmICh0cmF2LmlzUm9vdCgpKSB7XG4gICAgICAgIHRyYXYuc2NlbmUuc2F2ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRyYXYucmV2SWQrKztcbiAgICAgIHRyYXYgPSB0cmF2LnBhcmVudDtcbiAgICB9XG5cbiAgICBjb25zdCBzY2VuZSA9IHRoaXMuZ2V0U2NlbmUoKTtcbiAgICBpZiAob2xkTmFtZSAhPT0gbmV3TmFtZSAmJiBzY2VuZSkge1xuICAgICAgc2NlbmUuYnlOYW1lLmRlbGV0ZShvbGROYW1lKTtcbiAgICAgIHNjZW5lLmJ5TmFtZS5zZXQobmV3TmFtZSwgdGhpcyk7XG4gICAgfVxuICB9XG5cbiAgZ2V0U2F2ZU1vZGVsKCkge1xuICAgIHJldHVybiB7IC4uLnRoaXMub3B0aW9ucyB9O1xuICB9XG5cbiAgaW5pdEVsZW1lbnQgPSAodGFyZ2V0OiBIVE1MRGl2RWxlbWVudCkgPT4ge1xuICAgIHRoaXMuZGl2ID0gdGFyZ2V0O1xuICAgIHRoaXMuYXBwbHlMYXlvdXRTdHlsZXNUb0RpdigpO1xuICB9O1xuXG4gIGFwcGx5RHJhZyA9IChldmVudDogT25EcmFnKSA9PiB7XG4gICAgZXZlbnQudGFyZ2V0LnN0eWxlLnRyYW5zZm9ybSA9IGV2ZW50LnRyYW5zZm9ybTtcbiAgfTtcblxuICAvLyBraW5kYSBsaWtlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ3JhZmFuYS9ncmFmYW5hLWVkZ2UtYXBwL2Jsb2IvbWFpbi9zcmMvcGFuZWxzL2RyYXcvV3JhcEl0ZW0udHN4I0w0NFxuICBhcHBseVJlc2l6ZSA9IChldmVudDogT25SZXNpemUpID0+IHtcbiAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBwbGFjZW1lbnQsIGNvbnN0cmFpbnQgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgeyB2ZXJ0aWNhbCwgaG9yaXpvbnRhbCB9ID0gY29uc3RyYWludCA/PyB7fTtcblxuICAgIGNvbnN0IHRvcCA9IHZlcnRpY2FsID09PSBWZXJ0aWNhbENvbnN0cmFpbnQuVG9wIHx8IHZlcnRpY2FsID09PSBWZXJ0aWNhbENvbnN0cmFpbnQuVG9wQm90dG9tO1xuICAgIGNvbnN0IGJvdHRvbSA9IHZlcnRpY2FsID09PSBWZXJ0aWNhbENvbnN0cmFpbnQuQm90dG9tIHx8IHZlcnRpY2FsID09PSBWZXJ0aWNhbENvbnN0cmFpbnQuVG9wQm90dG9tO1xuICAgIGNvbnN0IGxlZnQgPSBob3Jpem9udGFsID09PSBIb3Jpem9udGFsQ29uc3RyYWludC5MZWZ0IHx8IGhvcml6b250YWwgPT09IEhvcml6b250YWxDb25zdHJhaW50LkxlZnRSaWdodDtcbiAgICBjb25zdCByaWdodCA9IGhvcml6b250YWwgPT09IEhvcml6b250YWxDb25zdHJhaW50LlJpZ2h0IHx8IGhvcml6b250YWwgPT09IEhvcml6b250YWxDb25zdHJhaW50LkxlZnRSaWdodDtcblxuICAgIGNvbnN0IHN0eWxlID0gZXZlbnQudGFyZ2V0LnN0eWxlO1xuICAgIGNvbnN0IGRlbHRhWCA9IGV2ZW50LmRlbHRhWzBdO1xuICAgIGNvbnN0IGRlbHRhWSA9IGV2ZW50LmRlbHRhWzFdO1xuICAgIGNvbnN0IGRpckxSID0gZXZlbnQuZGlyZWN0aW9uWzBdO1xuICAgIGNvbnN0IGRpclRCID0gZXZlbnQuZGlyZWN0aW9uWzFdO1xuICAgIGlmIChkaXJMUiA9PT0gMSkge1xuICAgICAgLy8gUklHSFRcbiAgICAgIGlmIChyaWdodCkge1xuICAgICAgICBwbGFjZW1lbnQhLnJpZ2h0ISAtPSBkZWx0YVg7XG4gICAgICAgIHN0eWxlLnJpZ2h0ID0gYCR7cGxhY2VtZW50IS5yaWdodH1weGA7XG4gICAgICAgIGlmICghbGVmdCkge1xuICAgICAgICAgIHBsYWNlbWVudCEud2lkdGggPSBldmVudC53aWR0aDtcbiAgICAgICAgICBzdHlsZS53aWR0aCA9IGAke3BsYWNlbWVudCEud2lkdGh9cHhgO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwbGFjZW1lbnQhLndpZHRoISA9IGV2ZW50LndpZHRoO1xuICAgICAgICBzdHlsZS53aWR0aCA9IGAke3BsYWNlbWVudCEud2lkdGh9cHhgO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGlyTFIgPT09IC0xKSB7XG4gICAgICAvLyBMRUZUXG4gICAgICBpZiAobGVmdCkge1xuICAgICAgICBwbGFjZW1lbnQhLmxlZnQhIC09IGRlbHRhWDtcbiAgICAgICAgcGxhY2VtZW50IS53aWR0aCEgPSBldmVudC53aWR0aDtcbiAgICAgICAgc3R5bGUubGVmdCA9IGAke3BsYWNlbWVudCEubGVmdH1weGA7XG4gICAgICAgIHN0eWxlLndpZHRoID0gYCR7cGxhY2VtZW50IS53aWR0aH1weGA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwbGFjZW1lbnQhLndpZHRoISArPSBkZWx0YVg7XG4gICAgICAgIHN0eWxlLndpZHRoID0gYCR7cGxhY2VtZW50IS53aWR0aH1weGA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRpclRCID09PSAtMSkge1xuICAgICAgLy8gVE9QXG4gICAgICBpZiAodG9wKSB7XG4gICAgICAgIHBsYWNlbWVudCEudG9wISAtPSBkZWx0YVk7XG4gICAgICAgIHBsYWNlbWVudCEuaGVpZ2h0ID0gZXZlbnQuaGVpZ2h0O1xuICAgICAgICBzdHlsZS50b3AgPSBgJHtwbGFjZW1lbnQhLnRvcH1weGA7XG4gICAgICAgIHN0eWxlLmhlaWdodCA9IGAke3BsYWNlbWVudCEuaGVpZ2h0fXB4YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBsYWNlbWVudCEuaGVpZ2h0ID0gZXZlbnQuaGVpZ2h0O1xuICAgICAgICBzdHlsZS5oZWlnaHQgPSBgJHtwbGFjZW1lbnQhLmhlaWdodH1weGA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkaXJUQiA9PT0gMSkge1xuICAgICAgLy8gQk9UVE9NXG4gICAgICBpZiAoYm90dG9tKSB7XG4gICAgICAgIHBsYWNlbWVudCEuYm90dG9tISAtPSBkZWx0YVk7XG4gICAgICAgIHBsYWNlbWVudCEuaGVpZ2h0ISA9IGV2ZW50LmhlaWdodDtcbiAgICAgICAgc3R5bGUuYm90dG9tID0gYCR7cGxhY2VtZW50IS5ib3R0b219cHhgO1xuICAgICAgICBzdHlsZS5oZWlnaHQgPSBgJHtwbGFjZW1lbnQhLmhlaWdodH1weGA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwbGFjZW1lbnQhLmhlaWdodCEgPSBldmVudC5oZWlnaHQ7XG4gICAgICAgIHN0eWxlLmhlaWdodCA9IGAke3BsYWNlbWVudCEuaGVpZ2h0fXB4YDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgaXRlbSB9ID0gdGhpcztcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBrZXk9e3RoaXMuVUlEfSByZWY9e3RoaXMuaW5pdEVsZW1lbnR9PlxuICAgICAgICA8aXRlbS5kaXNwbGF5IGtleT17YCR7dGhpcy5VSUR9LyR7dGhpcy5yZXZJZH1gfSBjb25maWc9e3RoaXMub3B0aW9ucy5jb25maWd9IGRhdGE9e3RoaXMuZGF0YX0gLz5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBDYW52YXNGcmFtZU9wdGlvbnMsIGNhbnZhc0VsZW1lbnRSZWdpc3RyeSB9IGZyb20gJ2FwcC9mZWF0dXJlcy9jYW52YXMnO1xuaW1wb3J0IHsgbm90Rm91bmRJdGVtIH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2NhbnZhcy9lbGVtZW50cy9ub3RGb3VuZCc7XG5pbXBvcnQgeyBEaW1lbnNpb25Db250ZXh0IH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2RpbWVuc2lvbnMnO1xuaW1wb3J0IHsgTGF5ZXJBY3Rpb25JRCB9IGZyb20gJ2FwcC9wbHVnaW5zL3BhbmVsL2NhbnZhcy90eXBlcyc7XG5cbmltcG9ydCB7IENhbnZhc0VsZW1lbnRJdGVtIH0gZnJvbSAnLi4vZWxlbWVudCc7XG5pbXBvcnQgeyBIb3Jpem9udGFsQ29uc3RyYWludCwgUGxhY2VtZW50LCBWZXJ0aWNhbENvbnN0cmFpbnQgfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IEVsZW1lbnRTdGF0ZSB9IGZyb20gJy4vZWxlbWVudCc7XG5pbXBvcnQgeyBSb290RWxlbWVudCB9IGZyb20gJy4vcm9vdCc7XG5pbXBvcnQgeyBTY2VuZSB9IGZyb20gJy4vc2NlbmUnO1xuXG5leHBvcnQgY29uc3QgZnJhbWVJdGVtRHVtbXk6IENhbnZhc0VsZW1lbnRJdGVtID0ge1xuICBpZDogJ2ZyYW1lJyxcbiAgbmFtZTogJ0ZyYW1lJyxcbiAgZGVzY3JpcHRpb246ICdGcmFtZScsXG5cbiAgZ2V0TmV3T3B0aW9uczogKCkgPT4gKHtcbiAgICBjb25maWc6IHt9LFxuICB9KSxcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvZGlzcGxheS1uYW1lXG4gIGRpc3BsYXk6ICgpID0+IHtcbiAgICByZXR1cm4gPGRpdj5GUkFNRSE8L2Rpdj47XG4gIH0sXG59O1xuXG5leHBvcnQgY2xhc3MgRnJhbWVTdGF0ZSBleHRlbmRzIEVsZW1lbnRTdGF0ZSB7XG4gIGVsZW1lbnRzOiBFbGVtZW50U3RhdGVbXSA9IFtdO1xuICBzY2VuZTogU2NlbmU7XG5cbiAgY29uc3RydWN0b3IocHVibGljIG9wdGlvbnM6IENhbnZhc0ZyYW1lT3B0aW9ucywgc2NlbmU6IFNjZW5lLCBwdWJsaWMgcGFyZW50PzogRnJhbWVTdGF0ZSkge1xuICAgIHN1cGVyKGZyYW1lSXRlbUR1bW15LCBvcHRpb25zLCBwYXJlbnQpO1xuXG4gICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuXG4gICAgLy8gbXV0YXRlIG9wdGlvbnMgb2JqZWN0XG4gICAgbGV0IHsgZWxlbWVudHMgfSA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoIWVsZW1lbnRzKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuZWxlbWVudHMgPSBlbGVtZW50cyA9IFtdO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgYyBvZiBlbGVtZW50cykge1xuICAgICAgaWYgKGMudHlwZSA9PT0gJ2ZyYW1lJykge1xuICAgICAgICB0aGlzLmVsZW1lbnRzLnB1c2gobmV3IEZyYW1lU3RhdGUoYyBhcyBDYW52YXNGcmFtZU9wdGlvbnMsIHNjZW5lLCB0aGlzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBpdGVtID0gY2FudmFzRWxlbWVudFJlZ2lzdHJ5LmdldElmRXhpc3RzKGMudHlwZSkgPz8gbm90Rm91bmRJdGVtO1xuICAgICAgICB0aGlzLmVsZW1lbnRzLnB1c2gobmV3IEVsZW1lbnRTdGF0ZShpdGVtLCBjLCB0aGlzKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaXNSb290KCk6IHRoaXMgaXMgUm9vdEVsZW1lbnQge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHVwZGF0ZURhdGEoY3R4OiBEaW1lbnNpb25Db250ZXh0KSB7XG4gICAgc3VwZXIudXBkYXRlRGF0YShjdHgpO1xuICAgIGZvciAoY29uc3QgZWxlbSBvZiB0aGlzLmVsZW1lbnRzKSB7XG4gICAgICBlbGVtLnVwZGF0ZURhdGEoY3R4KTtcbiAgICB9XG4gIH1cblxuICAvLyB1c2VkIGluIHRoZSBsYXllciBlZGl0b3JcbiAgcmVvcmRlcihzdGFydEluZGV4OiBudW1iZXIsIGVuZEluZGV4OiBudW1iZXIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBBcnJheS5mcm9tKHRoaXMuZWxlbWVudHMpO1xuICAgIGNvbnN0IFtyZW1vdmVkXSA9IHJlc3VsdC5zcGxpY2Uoc3RhcnRJbmRleCwgMSk7XG4gICAgcmVzdWx0LnNwbGljZShlbmRJbmRleCwgMCwgcmVtb3ZlZCk7XG4gICAgdGhpcy5lbGVtZW50cyA9IHJlc3VsdDtcblxuICAgIHRoaXMucmVpbml0aWFsaXplTW92ZWFibGUoKTtcbiAgfVxuXG4gIHJlaW5pdGlhbGl6ZU1vdmVhYmxlKCkge1xuICAgIC8vIE5lZWQgdG8gZmlyc3QgY2xlYXIgY3VycmVudCBzZWxlY3Rpb24gYW5kIHRoZW4gcmUtaW5pdCBtb3ZlYWJsZSB3aXRoIHNsaWdodCBkZWxheVxuICAgIHRoaXMuc2NlbmUuY2xlYXJDdXJyZW50U2VsZWN0aW9uKCk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnNjZW5lLmluaXRNb3ZlYWJsZSh0cnVlLCB0aGlzLnNjZW5lLmlzRWRpdGluZ0VuYWJsZWQpLCAxMDApO1xuICB9XG5cbiAgLy8gPz8/IG9yIHNob3VsZCB0aGlzIGJlIG9uIHRoZSBlbGVtZW50IGRpcmVjdGx5P1xuICAvLyBhcmUgYWN0aW9ucyBzY29wZWQgdG8gbGF5ZXJzP1xuICBkb0FjdGlvbiA9IChhY3Rpb246IExheWVyQWN0aW9uSUQsIGVsZW1lbnQ6IEVsZW1lbnRTdGF0ZSwgdXBkYXRlTmFtZSA9IHRydWUsIHNoaWZ0SXRlbXNPbkR1cGxpY2F0ZSA9IHRydWUpID0+IHtcbiAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgY2FzZSBMYXllckFjdGlvbklELkRlbGV0ZTpcbiAgICAgICAgdGhpcy5lbGVtZW50cyA9IHRoaXMuZWxlbWVudHMuZmlsdGVyKChlKSA9PiBlICE9PSBlbGVtZW50KTtcbiAgICAgICAgdGhpcy5zY2VuZS5ieU5hbWUuZGVsZXRlKGVsZW1lbnQub3B0aW9ucy5uYW1lKTtcbiAgICAgICAgdGhpcy5zY2VuZS5zYXZlKCk7XG4gICAgICAgIHRoaXMucmVpbml0aWFsaXplTW92ZWFibGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIExheWVyQWN0aW9uSUQuRHVwbGljYXRlOlxuICAgICAgICBpZiAoZWxlbWVudC5pdGVtLmlkID09PSAnZnJhbWUnKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ0NhbiBub3QgZHVwbGljYXRlIGZyYW1lcyAoeWV0KScsIGFjdGlvbiwgZWxlbWVudCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdHMgPSBjbG9uZURlZXAoZWxlbWVudC5vcHRpb25zKTtcblxuICAgICAgICBpZiAoc2hpZnRJdGVtc09uRHVwbGljYXRlKSB7XG4gICAgICAgICAgY29uc3QgeyBjb25zdHJhaW50LCBwbGFjZW1lbnQ6IG9sZFBsYWNlbWVudCB9ID0gZWxlbWVudC5vcHRpb25zO1xuICAgICAgICAgIGNvbnN0IHsgdmVydGljYWwsIGhvcml6b250YWwgfSA9IGNvbnN0cmFpbnQgPz8ge307XG4gICAgICAgICAgY29uc3QgcGxhY2VtZW50ID0gb2xkUGxhY2VtZW50ID8/ICh7fSBhcyBQbGFjZW1lbnQpO1xuXG4gICAgICAgICAgc3dpdGNoICh2ZXJ0aWNhbCkge1xuICAgICAgICAgICAgY2FzZSBWZXJ0aWNhbENvbnN0cmFpbnQuVG9wOlxuICAgICAgICAgICAgY2FzZSBWZXJ0aWNhbENvbnN0cmFpbnQuVG9wQm90dG9tOlxuICAgICAgICAgICAgICBpZiAocGxhY2VtZW50LnRvcCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGxhY2VtZW50LnRvcCA9IDI1O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBsYWNlbWVudC50b3AgKz0gMTA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFZlcnRpY2FsQ29uc3RyYWludC5Cb3R0b206XG4gICAgICAgICAgICAgIGlmIChwbGFjZW1lbnQuYm90dG9tID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQuYm90dG9tID0gMTAwO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBsYWNlbWVudC5ib3R0b20gLT0gMTA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3dpdGNoIChob3Jpem9udGFsKSB7XG4gICAgICAgICAgICBjYXNlIEhvcml6b250YWxDb25zdHJhaW50LkxlZnQ6XG4gICAgICAgICAgICBjYXNlIEhvcml6b250YWxDb25zdHJhaW50LkxlZnRSaWdodDpcbiAgICAgICAgICAgICAgaWYgKHBsYWNlbWVudC5sZWZ0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQubGVmdCA9IDUwO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBsYWNlbWVudC5sZWZ0ICs9IDEwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBIb3Jpem9udGFsQ29uc3RyYWludC5SaWdodDpcbiAgICAgICAgICAgICAgaWYgKHBsYWNlbWVudC5yaWdodCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGxhY2VtZW50LnJpZ2h0ID0gNTA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGxhY2VtZW50LnJpZ2h0IC09IDEwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG9wdHMucGxhY2VtZW50ID0gcGxhY2VtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29weSA9IG5ldyBFbGVtZW50U3RhdGUoZWxlbWVudC5pdGVtLCBvcHRzLCB0aGlzKTtcbiAgICAgICAgY29weS51cGRhdGVEYXRhKHRoaXMuc2NlbmUuY29udGV4dCk7XG4gICAgICAgIGlmICh1cGRhdGVOYW1lKSB7XG4gICAgICAgICAgY29weS5vcHRpb25zLm5hbWUgPSB0aGlzLnNjZW5lLmdldE5leHRFbGVtZW50TmFtZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudHMucHVzaChjb3B5KTtcbiAgICAgICAgdGhpcy5zY2VuZS5ieU5hbWUuc2V0KGNvcHkub3B0aW9ucy5uYW1lLCBjb3B5KTtcbiAgICAgICAgdGhpcy5zY2VuZS5zYXZlKCk7XG4gICAgICAgIHRoaXMucmVpbml0aWFsaXplTW92ZWFibGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb25zb2xlLmxvZygnRE8gYWN0aW9uJywgYWN0aW9uLCBlbGVtZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfTtcblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYga2V5PXt0aGlzLlVJRH0gcmVmPXt0aGlzLmluaXRFbGVtZW50fSBzdHlsZT17eyBvdmVyZmxvdzogJ2hpZGRlbicgfX0+XG4gICAgICAgIHt0aGlzLmVsZW1lbnRzLm1hcCgodikgPT4gdi5yZW5kZXIoKSl9XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgLyoqIFJlY3Vyc2l2ZWx5IHZpc2l0IGFsbCBub2RlcyAqL1xuICB2aXNpdCh2aXNpdG9yOiAodjogRWxlbWVudFN0YXRlKSA9PiB2b2lkKSB7XG4gICAgc3VwZXIudmlzaXQodmlzaXRvcik7XG4gICAgZm9yIChjb25zdCBlIG9mIHRoaXMuZWxlbWVudHMpIHtcbiAgICAgIHZpc2l0b3IoZSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0U2F2ZU1vZGVsKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi50aGlzLm9wdGlvbnMsXG4gICAgICBlbGVtZW50czogdGhpcy5lbGVtZW50cy5tYXAoKHYpID0+IHYuZ2V0U2F2ZU1vZGVsKCkpLFxuICAgIH07XG4gIH1cbn1cbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IENhbnZhc0ZyYW1lT3B0aW9ucywgQ2FudmFzRWxlbWVudE9wdGlvbnMgfSBmcm9tICdhcHAvZmVhdHVyZXMvY2FudmFzJztcblxuaW1wb3J0IHsgRnJhbWVTdGF0ZSB9IGZyb20gJy4vZnJhbWUnO1xuaW1wb3J0IHsgU2NlbmUgfSBmcm9tICcuL3NjZW5lJztcblxuZXhwb3J0IGNsYXNzIFJvb3RFbGVtZW50IGV4dGVuZHMgRnJhbWVTdGF0ZSB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBvcHRpb25zOiBDYW52YXNGcmFtZU9wdGlvbnMsIHB1YmxpYyBzY2VuZTogU2NlbmUsIHByaXZhdGUgY2hhbmdlQ2FsbGJhY2s6ICgpID0+IHZvaWQpIHtcbiAgICBzdXBlcihvcHRpb25zLCBzY2VuZSk7XG5cbiAgICB0aGlzLnNpemVTdHlsZSA9IHtcbiAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICB9O1xuICB9XG5cbiAgaXNSb290KCk6IHRoaXMgaXMgUm9vdEVsZW1lbnQge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gcm9vdCB0eXBlIGNhbiBub3QgY2hhbmdlXG4gIG9uQ2hhbmdlKG9wdGlvbnM6IENhbnZhc0VsZW1lbnRPcHRpb25zKSB7XG4gICAgdGhpcy5yZXZJZCsrO1xuICAgIHRoaXMub3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9IGFzIENhbnZhc0ZyYW1lT3B0aW9ucztcbiAgICB0aGlzLmNoYW5nZUNhbGxiYWNrKCk7XG4gIH1cblxuICBnZXRTYXZlTW9kZWwoKTogQ2FudmFzRnJhbWVPcHRpb25zIHtcbiAgICBjb25zdCB7IHBsYWNlbWVudCwgY29uc3RyYWludCwgLi4ucmVzdCB9ID0gdGhpcy5vcHRpb25zO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlc3QsIC8vIGV2ZXJ5dGhpbmcgZXhjZXB0IHBsYWNlbWVudCAmIGNvbnN0cmFpbnRcbiAgICAgIGVsZW1lbnRzOiB0aGlzLmVsZW1lbnRzLm1hcCgodikgPT4gdi5nZXRTYXZlTW9kZWwoKSksXG4gICAgfTtcbiAgfVxuXG4gIHNldFJvb3RSZWYgPSAodGFyZ2V0OiBIVE1MRGl2RWxlbWVudCkgPT4ge1xuICAgIHRoaXMuZGl2ID0gdGFyZ2V0O1xuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBrZXk9e3RoaXMuVUlEfSByZWY9e3RoaXMuc2V0Um9vdFJlZn0gc3R5bGU9e3sgLi4udGhpcy5zaXplU3R5bGUsIC4uLnRoaXMuZGF0YVN0eWxlIH19PlxuICAgICAgICB7dGhpcy5lbGVtZW50cy5tYXAoKHYpID0+IHYucmVuZGVyKCkpfVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCBNb3ZlYWJsZSBmcm9tICdtb3ZlYWJsZSc7XG5pbXBvcnQgUmVhY3QsIHsgQ1NTUHJvcGVydGllcyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFJlcGxheVN1YmplY3QsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGZpcnN0IH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IFNlbGVjdG8gZnJvbSAnc2VsZWN0byc7XG5cbmltcG9ydCB7IEdyYWZhbmFUaGVtZTIsIFBhbmVsRGF0YSB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgc3R5bGVzRmFjdG9yeSB9IGZyb20gJ0BncmFmYW5hL3VpJztcbmltcG9ydCB7IGNvbmZpZyB9IGZyb20gJ2FwcC9jb3JlL2NvbmZpZyc7XG5pbXBvcnQgeyBDYW52YXNGcmFtZU9wdGlvbnMsIERFRkFVTFRfQ0FOVkFTX0VMRU1FTlRfQ09ORklHIH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2NhbnZhcyc7XG5pbXBvcnQge1xuICBDb2xvckRpbWVuc2lvbkNvbmZpZyxcbiAgUmVzb3VyY2VEaW1lbnNpb25Db25maWcsXG4gIFNjYWxlRGltZW5zaW9uQ29uZmlnLFxuICBUZXh0RGltZW5zaW9uQ29uZmlnLFxuICBEaW1lbnNpb25Db250ZXh0LFxuICBTY2FsYXJEaW1lbnNpb25Db25maWcsXG59IGZyb20gJ2FwcC9mZWF0dXJlcy9kaW1lbnNpb25zJztcbmltcG9ydCB7XG4gIGdldENvbG9yRGltZW5zaW9uRnJvbURhdGEsXG4gIGdldFNjYWxlRGltZW5zaW9uRnJvbURhdGEsXG4gIGdldFJlc291cmNlRGltZW5zaW9uRnJvbURhdGEsXG4gIGdldFRleHREaW1lbnNpb25Gcm9tRGF0YSxcbiAgZ2V0U2NhbGFyRGltZW5zaW9uRnJvbURhdGEsXG59IGZyb20gJ2FwcC9mZWF0dXJlcy9kaW1lbnNpb25zL3V0aWxzJztcbmltcG9ydCB7IExheWVyQWN0aW9uSUQgfSBmcm9tICdhcHAvcGx1Z2lucy9wYW5lbC9jYW52YXMvdHlwZXMnO1xuXG5pbXBvcnQgeyBQbGFjZW1lbnQgfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IEVsZW1lbnRTdGF0ZSB9IGZyb20gJy4vZWxlbWVudCc7XG5pbXBvcnQgeyBGcmFtZVN0YXRlIH0gZnJvbSAnLi9mcmFtZSc7XG5pbXBvcnQgeyBSb290RWxlbWVudCB9IGZyb20gJy4vcm9vdCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VsZWN0aW9uUGFyYW1zIHtcbiAgdGFyZ2V0czogQXJyYXk8SFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50PjtcbiAgZnJhbWU/OiBGcmFtZVN0YXRlO1xufVxuXG5leHBvcnQgY2xhc3MgU2NlbmUge1xuICBzdHlsZXMgPSBnZXRTdHlsZXMoY29uZmlnLnRoZW1lMik7XG4gIHJlYWRvbmx5IHNlbGVjdGlvbiA9IG5ldyBSZXBsYXlTdWJqZWN0PEVsZW1lbnRTdGF0ZVtdPigxKTtcbiAgcmVhZG9ubHkgbW92ZWQgPSBuZXcgU3ViamVjdDxudW1iZXI+KCk7IC8vIGNhbGxlZCBhZnRlciByZXNpemUvZHJhZyBmb3IgZWRpdG9yIHVwZGF0ZXNcbiAgcmVhZG9ubHkgYnlOYW1lID0gbmV3IE1hcDxzdHJpbmcsIEVsZW1lbnRTdGF0ZT4oKTtcbiAgcm9vdDogUm9vdEVsZW1lbnQ7XG5cbiAgcmV2SWQgPSAwO1xuXG4gIHdpZHRoID0gMDtcbiAgaGVpZ2h0ID0gMDtcbiAgc3R5bGU6IENTU1Byb3BlcnRpZXMgPSB7fTtcbiAgZGF0YT86IFBhbmVsRGF0YTtcbiAgc2VsZWN0bz86IFNlbGVjdG87XG4gIG1vdmVhYmxlPzogTW92ZWFibGU7XG4gIGRpdj86IEhUTUxEaXZFbGVtZW50O1xuICBjdXJyZW50TGF5ZXI/OiBGcmFtZVN0YXRlO1xuICBpc0VkaXRpbmdFbmFibGVkPzogYm9vbGVhbjtcbiAgc2tpcE5leHRTZWxlY3Rpb25Ccm9hZGNhc3QgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihjZmc6IENhbnZhc0ZyYW1lT3B0aW9ucywgZW5hYmxlRWRpdGluZzogYm9vbGVhbiwgcHVibGljIG9uU2F2ZTogKGNmZzogQ2FudmFzRnJhbWVPcHRpb25zKSA9PiB2b2lkKSB7XG4gICAgdGhpcy5yb290ID0gdGhpcy5sb2FkKGNmZywgZW5hYmxlRWRpdGluZyk7XG4gIH1cblxuICBnZXROZXh0RWxlbWVudE5hbWUgPSAoaXNGcmFtZSA9IGZhbHNlKSA9PiB7XG4gICAgY29uc3QgbGFiZWwgPSBpc0ZyYW1lID8gJ0ZyYW1lJyA6ICdFbGVtZW50JztcbiAgICBsZXQgaWR4ID0gdGhpcy5ieU5hbWUuc2l6ZSArIDE7XG5cbiAgICBjb25zdCBtYXggPSBpZHggKyAxMDA7XG4gICAgd2hpbGUgKHRydWUgJiYgaWR4IDwgbWF4KSB7XG4gICAgICBjb25zdCBuYW1lID0gYCR7bGFiZWx9ICR7aWR4Kyt9YDtcbiAgICAgIGlmICghdGhpcy5ieU5hbWUuaGFzKG5hbWUpKSB7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBgJHtsYWJlbH0gJHtEYXRlLm5vdygpfWA7XG4gIH07XG5cbiAgY2FuUmVuYW1lID0gKHY6IHN0cmluZykgPT4ge1xuICAgIHJldHVybiAhdGhpcy5ieU5hbWUuaGFzKHYpO1xuICB9O1xuXG4gIGxvYWQoY2ZnOiBDYW52YXNGcmFtZU9wdGlvbnMsIGVuYWJsZUVkaXRpbmc6IGJvb2xlYW4pIHtcbiAgICB0aGlzLnJvb3QgPSBuZXcgUm9vdEVsZW1lbnQoXG4gICAgICBjZmcgPz8ge1xuICAgICAgICB0eXBlOiAnZnJhbWUnLFxuICAgICAgICBlbGVtZW50czogW0RFRkFVTFRfQ0FOVkFTX0VMRU1FTlRfQ09ORklHXSxcbiAgICAgIH0sXG4gICAgICB0aGlzLFxuICAgICAgdGhpcy5zYXZlIC8vIGNhbGxiYWNrIHdoZW4gY2hhbmdlcyBhcmUgbWFkZVxuICAgICk7XG5cbiAgICB0aGlzLmlzRWRpdGluZ0VuYWJsZWQgPSBlbmFibGVFZGl0aW5nO1xuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgICAgLy8gSWYgZWRpdGluZyBpcyBlbmFibGVkLCBjbGVhciBzZWxlY3RvIGluc3RhbmNlXG4gICAgICAgIGNvbnN0IGRlc3Ryb3lTZWxlY3RvID0gZW5hYmxlRWRpdGluZztcbiAgICAgICAgdGhpcy5pbml0TW92ZWFibGUoZGVzdHJveVNlbGVjdG8sIGVuYWJsZUVkaXRpbmcpO1xuICAgICAgICB0aGlzLmN1cnJlbnRMYXllciA9IHRoaXMucm9vdDtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24ubmV4dChbXSk7XG4gICAgICB9XG4gICAgfSwgMTAwKTtcbiAgICByZXR1cm4gdGhpcy5yb290O1xuICB9XG5cbiAgY29udGV4dDogRGltZW5zaW9uQ29udGV4dCA9IHtcbiAgICBnZXRDb2xvcjogKGNvbG9yOiBDb2xvckRpbWVuc2lvbkNvbmZpZykgPT4gZ2V0Q29sb3JEaW1lbnNpb25Gcm9tRGF0YSh0aGlzLmRhdGEsIGNvbG9yKSxcbiAgICBnZXRTY2FsZTogKHNjYWxlOiBTY2FsZURpbWVuc2lvbkNvbmZpZykgPT4gZ2V0U2NhbGVEaW1lbnNpb25Gcm9tRGF0YSh0aGlzLmRhdGEsIHNjYWxlKSxcbiAgICBnZXRTY2FsYXI6IChzY2FsYXI6IFNjYWxhckRpbWVuc2lvbkNvbmZpZykgPT4gZ2V0U2NhbGFyRGltZW5zaW9uRnJvbURhdGEodGhpcy5kYXRhLCBzY2FsYXIpLFxuICAgIGdldFRleHQ6ICh0ZXh0OiBUZXh0RGltZW5zaW9uQ29uZmlnKSA9PiBnZXRUZXh0RGltZW5zaW9uRnJvbURhdGEodGhpcy5kYXRhLCB0ZXh0KSxcbiAgICBnZXRSZXNvdXJjZTogKHJlczogUmVzb3VyY2VEaW1lbnNpb25Db25maWcpID0+IGdldFJlc291cmNlRGltZW5zaW9uRnJvbURhdGEodGhpcy5kYXRhLCByZXMpLFxuICB9O1xuXG4gIHVwZGF0ZURhdGEoZGF0YTogUGFuZWxEYXRhKSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLnJvb3QudXBkYXRlRGF0YSh0aGlzLmNvbnRleHQpO1xuICB9XG5cbiAgdXBkYXRlU2l6ZSh3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcikge1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLnN0eWxlID0geyB3aWR0aCwgaGVpZ2h0IH07XG5cbiAgICBpZiAodGhpcy5zZWxlY3RvPy5nZXRTZWxlY3RlZFRhcmdldHMoKS5sZW5ndGgpIHtcbiAgICAgIHRoaXMuY2xlYXJDdXJyZW50U2VsZWN0aW9uKCk7XG4gICAgfVxuICB9XG5cbiAgZnJhbWVTZWxlY3Rpb24oKSB7XG4gICAgdGhpcy5zZWxlY3Rpb24ucGlwZShmaXJzdCgpKS5zdWJzY3JpYmUoKGN1cnJlbnRTZWxlY3RlZEVsZW1lbnRzKSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50TGF5ZXIgPSBjdXJyZW50U2VsZWN0ZWRFbGVtZW50c1swXS5wYXJlbnQhO1xuXG4gICAgICBjb25zdCBuZXdMYXllciA9IG5ldyBGcmFtZVN0YXRlKFxuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogJ2ZyYW1lJyxcbiAgICAgICAgICBuYW1lOiB0aGlzLmdldE5leHRFbGVtZW50TmFtZSh0cnVlKSxcbiAgICAgICAgICBlbGVtZW50czogW10sXG4gICAgICAgIH0sXG4gICAgICAgIHRoaXMsXG4gICAgICAgIGN1cnJlbnRTZWxlY3RlZEVsZW1lbnRzWzBdLnBhcmVudFxuICAgICAgKTtcblxuICAgICAgY29uc3QgZnJhbWVQbGFjZW1lbnQgPSB0aGlzLmdlbmVyYXRlRnJhbWVDb250YWluZXIoY3VycmVudFNlbGVjdGVkRWxlbWVudHMpO1xuXG4gICAgICBuZXdMYXllci5vcHRpb25zLnBsYWNlbWVudCA9IGZyYW1lUGxhY2VtZW50O1xuXG4gICAgICBjdXJyZW50U2VsZWN0ZWRFbGVtZW50cy5mb3JFYWNoKChlbGVtZW50OiBFbGVtZW50U3RhdGUpID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudENvbnRhaW5lciA9IGVsZW1lbnQuZGl2Py5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgZWxlbWVudC5zZXRQbGFjZW1lbnRGcm9tQ29uc3RyYWludChlbGVtZW50Q29udGFpbmVyLCBmcmFtZVBsYWNlbWVudCBhcyBET01SZWN0KTtcbiAgICAgICAgY3VycmVudExheWVyLmRvQWN0aW9uKExheWVyQWN0aW9uSUQuRGVsZXRlLCBlbGVtZW50KTtcbiAgICAgICAgbmV3TGF5ZXIuZG9BY3Rpb24oTGF5ZXJBY3Rpb25JRC5EdXBsaWNhdGUsIGVsZW1lbnQsIGZhbHNlLCBmYWxzZSk7XG4gICAgICB9KTtcblxuICAgICAgbmV3TGF5ZXIuc2V0UGxhY2VtZW50RnJvbUNvbnN0cmFpbnQoZnJhbWVQbGFjZW1lbnQgYXMgRE9NUmVjdCwgY3VycmVudExheWVyLmRpdj8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xuXG4gICAgICBjdXJyZW50TGF5ZXIuZWxlbWVudHMucHVzaChuZXdMYXllcik7XG5cbiAgICAgIHRoaXMuYnlOYW1lLnNldChuZXdMYXllci5nZXROYW1lKCksIG5ld0xheWVyKTtcblxuICAgICAgdGhpcy5zYXZlKCk7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGdlbmVyYXRlRnJhbWVDb250YWluZXIgPSAoZWxlbWVudHM6IEVsZW1lbnRTdGF0ZVtdKTogUGxhY2VtZW50ID0+IHtcbiAgICBsZXQgbWluVG9wID0gSW5maW5pdHk7XG4gICAgbGV0IG1pbkxlZnQgPSBJbmZpbml0eTtcbiAgICBsZXQgbWF4UmlnaHQgPSAwO1xuICAgIGxldCBtYXhCb3R0b20gPSAwO1xuXG4gICAgZWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudDogRWxlbWVudFN0YXRlKSA9PiB7XG4gICAgICBjb25zdCBlbGVtZW50Q29udGFpbmVyID0gZWxlbWVudC5kaXY/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICBpZiAoIWVsZW1lbnRDb250YWluZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobWluVG9wID4gZWxlbWVudENvbnRhaW5lci50b3ApIHtcbiAgICAgICAgbWluVG9wID0gZWxlbWVudENvbnRhaW5lci50b3A7XG4gICAgICB9XG5cbiAgICAgIGlmIChtaW5MZWZ0ID4gZWxlbWVudENvbnRhaW5lci5sZWZ0KSB7XG4gICAgICAgIG1pbkxlZnQgPSBlbGVtZW50Q29udGFpbmVyLmxlZnQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXhSaWdodCA8IGVsZW1lbnRDb250YWluZXIucmlnaHQpIHtcbiAgICAgICAgbWF4UmlnaHQgPSBlbGVtZW50Q29udGFpbmVyLnJpZ2h0O1xuICAgICAgfVxuXG4gICAgICBpZiAobWF4Qm90dG9tIDwgZWxlbWVudENvbnRhaW5lci5ib3R0b20pIHtcbiAgICAgICAgbWF4Qm90dG9tID0gZWxlbWVudENvbnRhaW5lci5ib3R0b207XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiBtaW5Ub3AsXG4gICAgICBsZWZ0OiBtaW5MZWZ0LFxuICAgICAgd2lkdGg6IG1heFJpZ2h0IC0gbWluTGVmdCxcbiAgICAgIGhlaWdodDogbWF4Qm90dG9tIC0gbWluVG9wLFxuICAgIH07XG4gIH07XG5cbiAgY2xlYXJDdXJyZW50U2VsZWN0aW9uKHNraXBOZXh0U2VsZWN0aW9uQnJvYWRjYXN0ID0gZmFsc2UpIHtcbiAgICB0aGlzLnNraXBOZXh0U2VsZWN0aW9uQnJvYWRjYXN0ID0gc2tpcE5leHRTZWxlY3Rpb25Ccm9hZGNhc3Q7XG4gICAgbGV0IGV2ZW50OiBNb3VzZUV2ZW50ID0gbmV3IE1vdXNlRXZlbnQoJ2NsaWNrJyk7XG4gICAgdGhpcy5zZWxlY3RvPy5jbGlja1RhcmdldChldmVudCwgdGhpcy5kaXYpO1xuICB9XG5cbiAgdXBkYXRlQ3VycmVudExheWVyKG5ld0xheWVyOiBGcmFtZVN0YXRlKSB7XG4gICAgdGhpcy5jdXJyZW50TGF5ZXIgPSBuZXdMYXllcjtcbiAgICB0aGlzLmNsZWFyQ3VycmVudFNlbGVjdGlvbigpO1xuICAgIHRoaXMuc2F2ZSgpO1xuICB9XG5cbiAgc2F2ZSA9ICh1cGRhdGVNb3ZlYWJsZSA9IGZhbHNlKSA9PiB7XG4gICAgdGhpcy5vblNhdmUodGhpcy5yb290LmdldFNhdmVNb2RlbCgpKTtcblxuICAgIGlmICh1cGRhdGVNb3ZlYWJsZSkge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgICAgIHRoaXMuaW5pdE1vdmVhYmxlKHRydWUsIHRoaXMuaXNFZGl0aW5nRW5hYmxlZCk7XG4gICAgICAgIH1cbiAgICAgIH0sIDEwMCk7XG4gICAgfVxuICB9O1xuXG4gIHByaXZhdGUgZmluZEVsZW1lbnRCeVRhcmdldCA9ICh0YXJnZXQ6IEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudCk6IEVsZW1lbnRTdGF0ZSB8IHVuZGVmaW5lZCA9PiB7XG4gICAgLy8gV2Ugd2lsbCBwcm9iYWJseSB3YW50IHRvIGFkZCBtZW1vaXphdGlvbiB0byB0aGlzIGFzIHdlIGFyZSBjYWxsaW5nIG9uIGRyYWcgLyByZXNpemVcblxuICAgIGNvbnN0IHN0YWNrID0gWy4uLnRoaXMucm9vdC5lbGVtZW50c107XG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRFbGVtZW50ID0gc3RhY2suc2hpZnQoKTtcblxuICAgICAgaWYgKGN1cnJlbnRFbGVtZW50ICYmIGN1cnJlbnRFbGVtZW50LmRpdiAmJiBjdXJyZW50RWxlbWVudC5kaXYgPT09IHRhcmdldCkge1xuICAgICAgICByZXR1cm4gY3VycmVudEVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5lc3RlZEVsZW1lbnRzID0gY3VycmVudEVsZW1lbnQgaW5zdGFuY2VvZiBGcmFtZVN0YXRlID8gY3VycmVudEVsZW1lbnQuZWxlbWVudHMgOiBbXTtcbiAgICAgIGZvciAoY29uc3QgbmVzdGVkRWxlbWVudCBvZiBuZXN0ZWRFbGVtZW50cykge1xuICAgICAgICBzdGFjay51bnNoaWZ0KG5lc3RlZEVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgc2V0UmVmID0gKHNjZW5lQ29udGFpbmVyOiBIVE1MRGl2RWxlbWVudCkgPT4ge1xuICAgIHRoaXMuZGl2ID0gc2NlbmVDb250YWluZXI7XG4gIH07XG5cbiAgc2VsZWN0ID0gKHNlbGVjdGlvbjogU2VsZWN0aW9uUGFyYW1zKSA9PiB7XG4gICAgaWYgKHRoaXMuc2VsZWN0bykge1xuICAgICAgdGhpcy5zZWxlY3RvLnNldFNlbGVjdGVkVGFyZ2V0cyhzZWxlY3Rpb24udGFyZ2V0cyk7XG4gICAgICB0aGlzLnVwZGF0ZVNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgIH1cbiAgfTtcblxuICBwcml2YXRlIHVwZGF0ZVNlbGVjdGlvbiA9IChzZWxlY3Rpb246IFNlbGVjdGlvblBhcmFtcykgPT4ge1xuICAgIHRoaXMubW92ZWFibGUhLnRhcmdldCA9IHNlbGVjdGlvbi50YXJnZXRzO1xuXG4gICAgaWYgKHRoaXMuc2tpcE5leHRTZWxlY3Rpb25Ccm9hZGNhc3QpIHtcbiAgICAgIHRoaXMuc2tpcE5leHRTZWxlY3Rpb25Ccm9hZGNhc3QgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc2VsZWN0aW9uLmZyYW1lKSB7XG4gICAgICB0aGlzLnNlbGVjdGlvbi5uZXh0KFtzZWxlY3Rpb24uZnJhbWVdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcyA9IHNlbGVjdGlvbi50YXJnZXRzLm1hcCgodCkgPT4gdGhpcy5maW5kRWxlbWVudEJ5VGFyZ2V0KHQpISk7XG4gICAgICB0aGlzLnNlbGVjdGlvbi5uZXh0KHMpO1xuICAgIH1cbiAgfTtcblxuICBwcml2YXRlIGdlbmVyYXRlVGFyZ2V0RWxlbWVudHMgPSAocm9vdEVsZW1lbnRzOiBFbGVtZW50U3RhdGVbXSk6IEhUTUxEaXZFbGVtZW50W10gPT4ge1xuICAgIGxldCB0YXJnZXRFbGVtZW50czogSFRNTERpdkVsZW1lbnRbXSA9IFtdO1xuXG4gICAgY29uc3Qgc3RhY2sgPSBbLi4ucm9vdEVsZW1lbnRzXTtcbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgY3VycmVudEVsZW1lbnQgPSBzdGFjay5zaGlmdCgpO1xuXG4gICAgICBpZiAoY3VycmVudEVsZW1lbnQgJiYgY3VycmVudEVsZW1lbnQuZGl2KSB7XG4gICAgICAgIHRhcmdldEVsZW1lbnRzLnB1c2goY3VycmVudEVsZW1lbnQuZGl2KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmVzdGVkRWxlbWVudHMgPSBjdXJyZW50RWxlbWVudCBpbnN0YW5jZW9mIEZyYW1lU3RhdGUgPyBjdXJyZW50RWxlbWVudC5lbGVtZW50cyA6IFtdO1xuICAgICAgZm9yIChjb25zdCBuZXN0ZWRFbGVtZW50IG9mIG5lc3RlZEVsZW1lbnRzKSB7XG4gICAgICAgIHN0YWNrLnVuc2hpZnQobmVzdGVkRWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldEVsZW1lbnRzO1xuICB9O1xuXG4gIGluaXRNb3ZlYWJsZSA9IChkZXN0cm95U2VsZWN0byA9IGZhbHNlLCBhbGxvd0NoYW5nZXMgPSB0cnVlKSA9PiB7XG4gICAgY29uc3QgdGFyZ2V0RWxlbWVudHMgPSB0aGlzLmdlbmVyYXRlVGFyZ2V0RWxlbWVudHModGhpcy5yb290LmVsZW1lbnRzKTtcblxuICAgIGlmIChkZXN0cm95U2VsZWN0byAmJiB0aGlzLnNlbGVjdG8pIHtcbiAgICAgIHRoaXMuc2VsZWN0by5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgdGhpcy5zZWxlY3RvID0gbmV3IFNlbGVjdG8oe1xuICAgICAgY29udGFpbmVyOiB0aGlzLmRpdixcbiAgICAgIHNlbGVjdGFibGVUYXJnZXRzOiB0YXJnZXRFbGVtZW50cyxcbiAgICAgIHNlbGVjdEJ5Q2xpY2s6IHRydWUsXG4gICAgfSk7XG5cbiAgICB0aGlzLm1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKHRoaXMuZGl2ISwge1xuICAgICAgZHJhZ2dhYmxlOiBhbGxvd0NoYW5nZXMsXG4gICAgICByZXNpemFibGU6IGFsbG93Q2hhbmdlcyxcbiAgICAgIG9yaWdpbjogZmFsc2UsXG4gICAgfSlcbiAgICAgIC5vbignY2xpY2tHcm91cCcsIChldmVudCkgPT4ge1xuICAgICAgICB0aGlzLnNlbGVjdG8hLmNsaWNrVGFyZ2V0KGV2ZW50LmlucHV0RXZlbnQsIGV2ZW50LmlucHV0VGFyZ2V0KTtcbiAgICAgIH0pXG4gICAgICAub24oJ2RyYWcnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ZWRFbGVtZW50ID0gdGhpcy5maW5kRWxlbWVudEJ5VGFyZ2V0KGV2ZW50LnRhcmdldCk7XG4gICAgICAgIHRhcmdldGVkRWxlbWVudCEuYXBwbHlEcmFnKGV2ZW50KTtcbiAgICAgIH0pXG4gICAgICAub24oJ2RyYWdHcm91cCcsIChlKSA9PiB7XG4gICAgICAgIGUuZXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0ZWRFbGVtZW50ID0gdGhpcy5maW5kRWxlbWVudEJ5VGFyZ2V0KGV2ZW50LnRhcmdldCk7XG4gICAgICAgICAgdGFyZ2V0ZWRFbGVtZW50IS5hcHBseURyYWcoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgICAub24oJ2RyYWdFbmQnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ZWRFbGVtZW50ID0gdGhpcy5maW5kRWxlbWVudEJ5VGFyZ2V0KGV2ZW50LnRhcmdldCk7XG4gICAgICAgIGlmICh0YXJnZXRlZEVsZW1lbnQpIHtcbiAgICAgICAgICB0YXJnZXRlZEVsZW1lbnQ/LnNldFBsYWNlbWVudEZyb21Db25zdHJhaW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1vdmVkLm5leHQoRGF0ZS5ub3coKSk7XG4gICAgICB9KVxuICAgICAgLm9uKCdyZXNpemUnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ZWRFbGVtZW50ID0gdGhpcy5maW5kRWxlbWVudEJ5VGFyZ2V0KGV2ZW50LnRhcmdldCk7XG4gICAgICAgIHRhcmdldGVkRWxlbWVudCEuYXBwbHlSZXNpemUoZXZlbnQpO1xuICAgICAgICB0aGlzLm1vdmVkLm5leHQoRGF0ZS5ub3coKSk7IC8vIFRPRE8gb25seSBvbiBlbmRcbiAgICAgIH0pXG4gICAgICAub24oJ3Jlc2l6ZUdyb3VwJywgKGUpID0+IHtcbiAgICAgICAgZS5ldmVudHMuZm9yRWFjaCgoZXZlbnQpID0+IHtcbiAgICAgICAgICBjb25zdCB0YXJnZXRlZEVsZW1lbnQgPSB0aGlzLmZpbmRFbGVtZW50QnlUYXJnZXQoZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICB0YXJnZXRlZEVsZW1lbnQhLmFwcGx5UmVzaXplKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubW92ZWQubmV4dChEYXRlLm5vdygpKTsgLy8gVE9ETyBvbmx5IG9uIGVuZFxuICAgICAgfSlcbiAgICAgIC5vbigncmVzaXplRW5kJywgKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldGVkRWxlbWVudCA9IHRoaXMuZmluZEVsZW1lbnRCeVRhcmdldChldmVudC50YXJnZXQpO1xuXG4gICAgICAgIGlmICh0YXJnZXRlZEVsZW1lbnQpIHtcbiAgICAgICAgICB0YXJnZXRlZEVsZW1lbnQ/LnNldFBsYWNlbWVudEZyb21Db25zdHJhaW50KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgbGV0IHRhcmdldHM6IEFycmF5PEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudD4gPSBbXTtcbiAgICB0aGlzLnNlbGVjdG8hLm9uKCdkcmFnU3RhcnQnLCAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkVGFyZ2V0ID0gZXZlbnQuaW5wdXRFdmVudC50YXJnZXQ7XG5cbiAgICAgIGNvbnN0IGlzVGFyZ2V0TW92ZWFibGVFbGVtZW50ID1cbiAgICAgICAgdGhpcy5tb3ZlYWJsZSEuaXNNb3ZlYWJsZUVsZW1lbnQoc2VsZWN0ZWRUYXJnZXQpIHx8XG4gICAgICAgIHRhcmdldHMuc29tZSgodGFyZ2V0KSA9PiB0YXJnZXQgPT09IHNlbGVjdGVkVGFyZ2V0IHx8IHRhcmdldC5jb250YWlucyhzZWxlY3RlZFRhcmdldCkpO1xuXG4gICAgICBpZiAoaXNUYXJnZXRNb3ZlYWJsZUVsZW1lbnQpIHtcbiAgICAgICAgLy8gUHJldmVudCBkcmF3aW5nIHNlbGVjdGlvbiBib3ggd2hlbiBzZWxlY3RlZCB0YXJnZXQgaXMgYSBtb3ZlYWJsZSBlbGVtZW50XG4gICAgICAgIGV2ZW50LnN0b3AoKTtcbiAgICAgIH1cbiAgICB9KS5vbignc2VsZWN0RW5kJywgKGV2ZW50KSA9PiB7XG4gICAgICB0YXJnZXRzID0gZXZlbnQuc2VsZWN0ZWQ7XG4gICAgICB0aGlzLnVwZGF0ZVNlbGVjdGlvbih7IHRhcmdldHMgfSk7XG5cbiAgICAgIGlmIChldmVudC5pc0RyYWdTdGFydCkge1xuICAgICAgICBldmVudC5pbnB1dEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMubW92ZWFibGUhLmRyYWdTdGFydChldmVudC5pbnB1dEV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGtleT17dGhpcy5yZXZJZH0gY2xhc3NOYW1lPXt0aGlzLnN0eWxlcy53cmFwfSBzdHlsZT17dGhpcy5zdHlsZX0gcmVmPXt0aGlzLnNldFJlZn0+XG4gICAgICAgIHt0aGlzLnJvb3QucmVuZGVyKCl9XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG5cbmNvbnN0IGdldFN0eWxlcyA9IHN0eWxlc0ZhY3RvcnkoKHRoZW1lOiBHcmFmYW5hVGhlbWUyKSA9PiAoe1xuICB3cmFwOiBjc3NgXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIGAsXG5cbiAgdG9vbGJhcjogY3NzYFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBib3R0b206IDA7XG4gICAgbWFyZ2luOiAxMHB4O1xuICBgLFxufSkpO1xuIiwiaW1wb3J0IHsgQ29sb3JEaW1lbnNpb25Db25maWcsIFJlc291cmNlRGltZW5zaW9uQ29uZmlnIH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2RpbWVuc2lvbnMvdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFBsYWNlbWVudCB7XG4gIHRvcD86IG51bWJlcjtcbiAgbGVmdD86IG51bWJlcjtcbiAgcmlnaHQ/OiBudW1iZXI7XG4gIGJvdHRvbT86IG51bWJlcjtcblxuICB3aWR0aD86IG51bWJlcjtcbiAgaGVpZ2h0PzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbnN0cmFpbnQge1xuICBob3Jpem9udGFsPzogSG9yaXpvbnRhbENvbnN0cmFpbnQ7XG4gIHZlcnRpY2FsPzogVmVydGljYWxDb25zdHJhaW50O1xufVxuXG5leHBvcnQgZW51bSBIb3Jpem9udGFsQ29uc3RyYWludCB7XG4gIExlZnQgPSAnbGVmdCcsXG4gIFJpZ2h0ID0gJ3JpZ2h0JyxcbiAgTGVmdFJpZ2h0ID0gJ2xlZnRyaWdodCcsXG4gIENlbnRlciA9ICdjZW50ZXInLFxuICBTY2FsZSA9ICdzY2FsZScsXG59XG5cbmV4cG9ydCBlbnVtIFZlcnRpY2FsQ29uc3RyYWludCB7XG4gIFRvcCA9ICd0b3AnLFxuICBCb3R0b20gPSAnYm90dG9tJyxcbiAgVG9wQm90dG9tID0gJ3RvcGJvdHRvbScsXG4gIENlbnRlciA9ICdjZW50ZXInLFxuICBTY2FsZSA9ICdzY2FsZScsXG59XG5cbmV4cG9ydCBlbnVtIEJhY2tncm91bmRJbWFnZVNpemUge1xuICBPcmlnaW5hbCA9ICdvcmlnaW5hbCcsXG4gIENvbnRhaW4gPSAnY29udGFpbicsXG4gIENvdmVyID0gJ2NvdmVyJyxcbiAgRmlsbCA9ICdmaWxsJyxcbiAgVGlsZSA9ICd0aWxlJyxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCYWNrZ3JvdW5kQ29uZmlnIHtcbiAgY29sb3I/OiBDb2xvckRpbWVuc2lvbkNvbmZpZztcbiAgaW1hZ2U/OiBSZXNvdXJjZURpbWVuc2lvbkNvbmZpZztcbiAgc2l6ZT86IEJhY2tncm91bmRJbWFnZVNpemU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGluZUNvbmZpZyB7XG4gIGNvbG9yPzogQ29sb3JEaW1lbnNpb25Db25maWc7XG4gIHdpZHRoPzogbnVtYmVyO1xufVxuIiwiaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBSZXBsYXlTdWJqZWN0LCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgR3JhZmFuYVRoZW1lLCBQYW5lbFByb3BzIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBjb25maWcsIGxvY2F0aW9uU2VydmljZSB9IGZyb20gJ0BncmFmYW5hL3J1bnRpbWUvc3JjJztcbmltcG9ydCB7IEJ1dHRvbiwgUGFuZWxDb250ZXh0LCBQYW5lbENvbnRleHRSb290LCBzdHlsZXNGYWN0b3J5IH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuaW1wb3J0IHsgQ2FudmFzRnJhbWVPcHRpb25zIH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2NhbnZhcyc7XG5pbXBvcnQgeyBFbGVtZW50U3RhdGUgfSBmcm9tICdhcHAvZmVhdHVyZXMvY2FudmFzL3J1bnRpbWUvZWxlbWVudCc7XG5pbXBvcnQgeyBTY2VuZSB9IGZyb20gJ2FwcC9mZWF0dXJlcy9jYW52YXMvcnVudGltZS9zY2VuZSc7XG5pbXBvcnQgeyBQYW5lbEVkaXRFbnRlcmVkRXZlbnQsIFBhbmVsRWRpdEV4aXRlZEV2ZW50IH0gZnJvbSAnYXBwL3R5cGVzL2V2ZW50cyc7XG5cbmltcG9ydCB7IElubGluZUVkaXQgfSBmcm9tICcuL0lubGluZUVkaXQnO1xuaW1wb3J0IHsgUGFuZWxPcHRpb25zIH0gZnJvbSAnLi9tb2RlbHMuZ2VuJztcblxuaW50ZXJmYWNlIFByb3BzIGV4dGVuZHMgUGFuZWxQcm9wczxQYW5lbE9wdGlvbnM+IHt9XG5cbmludGVyZmFjZSBTdGF0ZSB7XG4gIHJlZnJlc2g6IG51bWJlcjtcbiAgb3BlbklubGluZUVkaXQ6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5zdGFuY2VTdGF0ZSB7XG4gIHNjZW5lOiBTY2VuZTtcbiAgc2VsZWN0ZWQ6IEVsZW1lbnRTdGF0ZVtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdGlvbkFjdGlvbiB7XG4gIHBhbmVsOiBDYW52YXNQYW5lbDtcbn1cblxubGV0IGNhbnZhc0luc3RhbmNlczogQ2FudmFzUGFuZWxbXSA9IFtdO1xubGV0IGFjdGl2ZUNhbnZhc1BhbmVsOiBDYW52YXNQYW5lbCB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbmxldCBpc0lubGluZUVkaXRPcGVuID0gZmFsc2U7XG5cbmV4cG9ydCBjb25zdCBhY3RpdmVQYW5lbFN1YmplY3QgPSBuZXcgUmVwbGF5U3ViamVjdDxTZWxlY3Rpb25BY3Rpb24+KDEpO1xuXG5leHBvcnQgY2xhc3MgQ2FudmFzUGFuZWwgZXh0ZW5kcyBDb21wb25lbnQ8UHJvcHMsIFN0YXRlPiB7XG4gIHN0YXRpYyBjb250ZXh0VHlwZSA9IFBhbmVsQ29udGV4dFJvb3Q7XG4gIHBhbmVsQ29udGV4dDogUGFuZWxDb250ZXh0ID0ge30gYXMgUGFuZWxDb250ZXh0O1xuXG4gIHJlYWRvbmx5IHNjZW5lOiBTY2VuZTtcbiAgcHJpdmF0ZSBzdWJzID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICBuZWVkc1JlbG9hZCA9IGZhbHNlO1xuICBzdHlsZXMgPSBnZXRTdHlsZXMoY29uZmlnLnRoZW1lKTtcbiAgaXNFZGl0aW5nID0gbG9jYXRpb25TZXJ2aWNlLmdldFNlYXJjaE9iamVjdCgpLmVkaXRQYW5lbCAhPT0gdW5kZWZpbmVkO1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBQcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgcmVmcmVzaDogMCxcbiAgICAgIG9wZW5JbmxpbmVFZGl0OiBmYWxzZSxcbiAgICB9O1xuXG4gICAgLy8gT25seSB0aGUgaW5pdGlhbCBvcHRpb25zIGFyZSBldmVyIHVzZWQuXG4gICAgLy8gbGF0ZXIgY2hhbmdlcyBhcmUgYWxsIGNvbnRyb2xsZWQgYnkgdGhlIHNjZW5lXG4gICAgdGhpcy5zY2VuZSA9IG5ldyBTY2VuZSh0aGlzLnByb3BzLm9wdGlvbnMucm9vdCwgdGhpcy5wcm9wcy5vcHRpb25zLmlubGluZUVkaXRpbmcsIHRoaXMub25VcGRhdGVTY2VuZSk7XG4gICAgdGhpcy5zY2VuZS51cGRhdGVTaXplKHByb3BzLndpZHRoLCBwcm9wcy5oZWlnaHQpO1xuICAgIHRoaXMuc2NlbmUudXBkYXRlRGF0YShwcm9wcy5kYXRhKTtcblxuICAgIHRoaXMuc3Vicy5hZGQoXG4gICAgICB0aGlzLnByb3BzLmV2ZW50QnVzLnN1YnNjcmliZShQYW5lbEVkaXRFbnRlcmVkRXZlbnQsIChldnQpID0+IHtcbiAgICAgICAgLy8gUmVtb3ZlIGN1cnJlbnQgc2VsZWN0aW9uIHdoZW4gZW50ZXJpbmcgZWRpdCBtb2RlIGZvciBhbnkgcGFuZWwgaW4gZGFzaGJvYXJkXG4gICAgICAgIHRoaXMuc2NlbmUuY2xlYXJDdXJyZW50U2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMuaW5saW5lRWRpdEJ1dHRvbkNsb3NlKCk7XG4gICAgICB9KVxuICAgICk7XG5cbiAgICB0aGlzLnN1YnMuYWRkKFxuICAgICAgdGhpcy5wcm9wcy5ldmVudEJ1cy5zdWJzY3JpYmUoUGFuZWxFZGl0RXhpdGVkRXZlbnQsIChldnQpID0+IHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuaWQgPT09IGV2dC5wYXlsb2FkKSB7XG4gICAgICAgICAgdGhpcy5uZWVkc1JlbG9hZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGFjdGl2ZUNhbnZhc1BhbmVsID0gdGhpcztcbiAgICBhY3RpdmVQYW5lbFN1YmplY3QubmV4dCh7IHBhbmVsOiB0aGlzIH0pO1xuXG4gICAgdGhpcy5wYW5lbENvbnRleHQgPSB0aGlzLmNvbnRleHQgYXMgUGFuZWxDb250ZXh0O1xuICAgIGlmICh0aGlzLnBhbmVsQ29udGV4dC5vbkluc3RhbmNlU3RhdGVDaGFuZ2UpIHtcbiAgICAgIHRoaXMucGFuZWxDb250ZXh0Lm9uSW5zdGFuY2VTdGF0ZUNoYW5nZSh7XG4gICAgICAgIHNjZW5lOiB0aGlzLnNjZW5lLFxuICAgICAgICBsYXllcjogdGhpcy5zY2VuZS5yb290LFxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuc3Vicy5hZGQoXG4gICAgICAgIHRoaXMuc2NlbmUuc2VsZWN0aW9uLnN1YnNjcmliZSh7XG4gICAgICAgICAgbmV4dDogKHYpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGFuZWxDb250ZXh0Lm9uSW5zdGFuY2VTdGF0ZUNoYW5nZSEoe1xuICAgICAgICAgICAgICBzY2VuZTogdGhpcy5zY2VuZSxcbiAgICAgICAgICAgICAgc2VsZWN0ZWQ6IHYsXG4gICAgICAgICAgICAgIGxheWVyOiB0aGlzLnNjZW5lLnJvb3QsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYWN0aXZlQ2FudmFzUGFuZWwgPSB0aGlzO1xuICAgICAgICAgICAgYWN0aXZlUGFuZWxTdWJqZWN0Lm5leHQoeyBwYW5lbDogdGhpcyB9KTtcblxuICAgICAgICAgICAgY2FudmFzSW5zdGFuY2VzLmZvckVhY2goKGNhbnZhc0luc3RhbmNlKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChjYW52YXNJbnN0YW5jZSAhPT0gYWN0aXZlQ2FudmFzUGFuZWwpIHtcbiAgICAgICAgICAgICAgICBjYW52YXNJbnN0YW5jZS5zY2VuZS5jbGVhckN1cnJlbnRTZWxlY3Rpb24odHJ1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cblxuICAgIGNhbnZhc0luc3RhbmNlcy5wdXNoKHRoaXMpO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5zdWJzLnVuc3Vic2NyaWJlKCk7XG4gICAgaXNJbmxpbmVFZGl0T3BlbiA9IGZhbHNlO1xuICAgIGNhbnZhc0luc3RhbmNlcyA9IGNhbnZhc0luc3RhbmNlcy5maWx0ZXIoKGNpKSA9PiBjaS5wcm9wcy5pZCAhPT0gYWN0aXZlQ2FudmFzUGFuZWw/LnByb3BzLmlkKTtcbiAgfVxuXG4gIC8vIE5PVEUsIGFsbCBjaGFuZ2VzIHRvIHRoZSBzY2VuZSBmbG93IHRocm91Z2ggdGhpcyBmdW5jdGlvblxuICAvLyBldmVuIHRoZSBlZGl0b3IgZ2V0cyBjdXJyZW50IHN0YXRlIGZyb20gdGhlIHNhbWUgc2NlbmUgaW5zdGFuY2UhXG4gIG9uVXBkYXRlU2NlbmUgPSAocm9vdDogQ2FudmFzRnJhbWVPcHRpb25zKSA9PiB7XG4gICAgY29uc3QgeyBvbk9wdGlvbnNDaGFuZ2UsIG9wdGlvbnMgfSA9IHRoaXMucHJvcHM7XG4gICAgb25PcHRpb25zQ2hhbmdlKHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICByb290LFxuICAgIH0pO1xuXG4gICAgdGhpcy5zZXRTdGF0ZSh7IHJlZnJlc2g6IHRoaXMuc3RhdGUucmVmcmVzaCArIDEgfSk7XG4gICAgLy8gY29uc29sZS5sb2coJ3NlbmQgY2hhbmdlcycsIHJvb3QpO1xuICB9O1xuXG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHM6IFByb3BzLCBuZXh0U3RhdGU6IFN0YXRlKSB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCBkYXRhIH0gPSB0aGlzLnByb3BzO1xuICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG5cbiAgICBpZiAod2lkdGggIT09IG5leHRQcm9wcy53aWR0aCB8fCBoZWlnaHQgIT09IG5leHRQcm9wcy5oZWlnaHQpIHtcbiAgICAgIHRoaXMuc2NlbmUudXBkYXRlU2l6ZShuZXh0UHJvcHMud2lkdGgsIG5leHRQcm9wcy5oZWlnaHQpO1xuICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChkYXRhICE9PSBuZXh0UHJvcHMuZGF0YSkge1xuICAgICAgdGhpcy5zY2VuZS51cGRhdGVEYXRhKG5leHRQcm9wcy5kYXRhKTtcbiAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN0YXRlLnJlZnJlc2ggIT09IG5leHRTdGF0ZS5yZWZyZXNoKSB7XG4gICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdGF0ZS5vcGVuSW5saW5lRWRpdCAhPT0gbmV4dFN0YXRlLm9wZW5JbmxpbmVFZGl0KSB7XG4gICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBBZnRlciBlZGl0aW5nLCB0aGUgb3B0aW9ucyBhcmUgdmFsaWQsIGJ1dCB0aGUgc2NlbmUgd2FzIGluIGEgZGlmZmVyZW50IHBhbmVsIG9yIGlubGluZSBlZGl0aW5nIG1vZGUgaGFzIGNoYW5nZWRcbiAgICBjb25zdCBzaG91bGRVcGRhdGVTY2VuZUFuZFBhbmVsID0gdGhpcy5uZWVkc1JlbG9hZCAmJiB0aGlzLnByb3BzLm9wdGlvbnMgIT09IG5leHRQcm9wcy5vcHRpb25zO1xuICAgIGNvbnN0IGlubGluZUVkaXRpbmdTd2l0Y2hlZCA9IHRoaXMucHJvcHMub3B0aW9ucy5pbmxpbmVFZGl0aW5nICE9PSBuZXh0UHJvcHMub3B0aW9ucy5pbmxpbmVFZGl0aW5nO1xuICAgIGlmIChzaG91bGRVcGRhdGVTY2VuZUFuZFBhbmVsIHx8IGlubGluZUVkaXRpbmdTd2l0Y2hlZCkge1xuICAgICAgdGhpcy5uZWVkc1JlbG9hZCA9IGZhbHNlO1xuICAgICAgdGhpcy5zY2VuZS5sb2FkKG5leHRQcm9wcy5vcHRpb25zLnJvb3QsIG5leHRQcm9wcy5vcHRpb25zLmlubGluZUVkaXRpbmcpO1xuICAgICAgdGhpcy5zY2VuZS51cGRhdGVTaXplKG5leHRQcm9wcy53aWR0aCwgbmV4dFByb3BzLmhlaWdodCk7XG4gICAgICB0aGlzLnNjZW5lLnVwZGF0ZURhdGEobmV4dFByb3BzLmRhdGEpO1xuICAgICAgY2hhbmdlZCA9IHRydWU7XG5cbiAgICAgIGlmIChpbmxpbmVFZGl0aW5nU3dpdGNoZWQgJiYgdGhpcy5wcm9wcy5vcHRpb25zLmlubGluZUVkaXRpbmcpIHtcbiAgICAgICAgdGhpcy5zY2VuZS5zZWxlY3RvPy5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoYW5nZWQ7XG4gIH1cblxuICBpbmxpbmVFZGl0QnV0dG9uQ2xpY2sgPSAoKSA9PiB7XG4gICAgaWYgKGlzSW5saW5lRWRpdE9wZW4pIHtcbiAgICAgIHRoaXMuZm9yY2VVcGRhdGUoKTtcbiAgICAgIHRoaXMuc2V0QWN0aXZlUGFuZWwoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnNldEFjdGl2ZVBhbmVsKCk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IG9wZW5JbmxpbmVFZGl0OiB0cnVlIH0pO1xuICAgIGlzSW5saW5lRWRpdE9wZW4gPSB0cnVlO1xuICB9O1xuXG4gIGlubGluZUVkaXRCdXR0b25DbG9zZSA9ICgpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHsgb3BlbklubGluZUVkaXQ6IGZhbHNlIH0pO1xuICAgIGlzSW5saW5lRWRpdE9wZW4gPSBmYWxzZTtcbiAgfTtcblxuICBzZXRBY3RpdmVQYW5lbCA9ICgpID0+IHtcbiAgICBhY3RpdmVDYW52YXNQYW5lbCA9IHRoaXM7XG4gICAgYWN0aXZlUGFuZWxTdWJqZWN0Lm5leHQoeyBwYW5lbDogdGhpcyB9KTtcbiAgfTtcblxuICByZW5kZXJJbmxpbmVFZGl0ID0gKCkgPT4ge1xuICAgIHJldHVybiA8SW5saW5lRWRpdCBvbkNsb3NlPXsoKSA9PiB0aGlzLmlubGluZUVkaXRCdXR0b25DbG9zZSgpfSAvPjtcbiAgfTtcblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDw+XG4gICAgICAgIHt0aGlzLnNjZW5lLnJlbmRlcigpfVxuICAgICAgICB7dGhpcy5wcm9wcy5vcHRpb25zLmlubGluZUVkaXRpbmcgJiYgIXRoaXMuaXNFZGl0aW5nICYmIChcbiAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3RoaXMuc3R5bGVzLmlubGluZUVkaXRCdXR0b259PlxuICAgICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgICAgc2l6ZT1cImxnXCJcbiAgICAgICAgICAgICAgICB2YXJpYW50PVwic2Vjb25kYXJ5XCJcbiAgICAgICAgICAgICAgICBpY29uPVwiZWRpdFwiXG4gICAgICAgICAgICAgICAgZGF0YS1idG5pbmxpbmVlZGl0PXt0aGlzLnByb3BzLmlkfVxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuaW5saW5lRWRpdEJ1dHRvbkNsaWNrfVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICB7dGhpcy5zdGF0ZS5vcGVuSW5saW5lRWRpdCAmJiB0aGlzLnJlbmRlcklubGluZUVkaXQoKX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKX1cbiAgICAgIDwvPlxuICAgICk7XG4gIH1cbn1cblxuY29uc3QgZ2V0U3R5bGVzID0gc3R5bGVzRmFjdG9yeSgodGhlbWU6IEdyYWZhbmFUaGVtZSkgPT4gKHtcbiAgaW5saW5lRWRpdEJ1dHRvbjogY3NzYFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBib3R0b206IDhweDtcbiAgICBsZWZ0OiA4cHg7XG4gICAgei1pbmRleDogOTk5O1xuICBgLFxufSkpO1xuIiwiaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCBSZWFjdCwgeyBTeW50aGV0aWNFdmVudCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBEcmFnZ2FibGUgZnJvbSAncmVhY3QtZHJhZ2dhYmxlJztcbmltcG9ydCB7IFJlc2l6YWJsZSwgUmVzaXplQ2FsbGJhY2tEYXRhIH0gZnJvbSAncmVhY3QtcmVzaXphYmxlJztcblxuaW1wb3J0IHsgRGltZW5zaW9uczJELCBHcmFmYW5hVGhlbWUyIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBJY29uQnV0dG9uLCBQb3J0YWwsIHVzZVN0eWxlczIgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5pbXBvcnQgc3RvcmUgZnJvbSAnYXBwL2NvcmUvc3RvcmUnO1xuXG5pbXBvcnQgeyBJbmxpbmVFZGl0Qm9keSB9IGZyb20gJy4vSW5saW5lRWRpdEJvZHknO1xuXG50eXBlIFByb3BzID0ge1xuICBvbkNsb3NlPzogKCkgPT4gdm9pZDtcbn07XG5cbmNvbnN0IE9GRlNFVF9YID0gNzA7XG5cbmV4cG9ydCBjb25zdCBJbmxpbmVFZGl0ID0gKHsgb25DbG9zZSB9OiBQcm9wcykgPT4ge1xuICBjb25zdCBidG5JbmxpbmVFZGl0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW2RhdGEtYnRuaW5saW5lZWRpdF0nKSEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IHJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCk7XG4gIGNvbnN0IHN0eWxlcyA9IHVzZVN0eWxlczIoZ2V0U3R5bGVzKTtcbiAgY29uc3QgaW5saW5lRWRpdEtleSA9ICdpbmxpbmVFZGl0UGFuZWwnO1xuXG4gIGNvbnN0IGRlZmF1bHRNZWFzdXJlbWVudHMgPSB7IHdpZHRoOiAzNTAsIGhlaWdodDogNDAwIH07XG4gIGNvbnN0IGRlZmF1bHRYID0gYnRuSW5saW5lRWRpdC54ICsgT0ZGU0VUX1g7XG4gIGNvbnN0IGRlZmF1bHRZID0gYnRuSW5saW5lRWRpdC55IC0gZGVmYXVsdE1lYXN1cmVtZW50cy5oZWlnaHQ7XG5cbiAgY29uc3Qgc2F2ZWRQbGFjZW1lbnQgPSBzdG9yZS5nZXRPYmplY3QoaW5saW5lRWRpdEtleSwge1xuICAgIHg6IGRlZmF1bHRYLFxuICAgIHk6IGRlZmF1bHRZLFxuICAgIHc6IGRlZmF1bHRNZWFzdXJlbWVudHMud2lkdGgsXG4gICAgaDogZGVmYXVsdE1lYXN1cmVtZW50cy5oZWlnaHQsXG4gIH0pO1xuICBjb25zdCBbbWVhc3VyZW1lbnRzLCBzZXRNZWFzdXJlbWVudHNdID0gdXNlU3RhdGU8RGltZW5zaW9uczJEPih7IHdpZHRoOiBzYXZlZFBsYWNlbWVudC53LCBoZWlnaHQ6IHNhdmVkUGxhY2VtZW50LmggfSk7XG4gIGNvbnN0IFtwbGFjZW1lbnQsIHNldFBsYWNlbWVudF0gPSB1c2VTdGF0ZSh7IHg6IHNhdmVkUGxhY2VtZW50LngsIHk6IHNhdmVkUGxhY2VtZW50LnkgfSk7XG5cbiAgY29uc3Qgb25EcmFnU3RvcCA9IChldmVudDogYW55LCBkcmFnRWxlbWVudDogYW55KSA9PiB7XG4gICAgbGV0IHggPSBkcmFnRWxlbWVudC54IDwgMCA/IDAgOiBkcmFnRWxlbWVudC54O1xuICAgIGxldCB5ID0gZHJhZ0VsZW1lbnQueSA8IDAgPyAwIDogZHJhZ0VsZW1lbnQueTtcblxuICAgIHNldFBsYWNlbWVudCh7IHg6IHgsIHk6IHkgfSk7XG4gICAgc2F2ZVRvU3RvcmUoeCwgeSwgbWVhc3VyZW1lbnRzLndpZHRoLCBtZWFzdXJlbWVudHMuaGVpZ2h0KTtcbiAgfTtcblxuICBjb25zdCBvblJlc2l6ZVN0b3AgPSAoZXZlbnQ6IFN5bnRoZXRpY0V2ZW50PEVsZW1lbnQsIEV2ZW50PiwgZGF0YTogUmVzaXplQ2FsbGJhY2tEYXRhKSA9PiB7XG4gICAgY29uc3QgeyBzaXplIH0gPSBkYXRhO1xuICAgIHNldE1lYXN1cmVtZW50cyh7IHdpZHRoOiBzaXplLndpZHRoLCBoZWlnaHQ6IHNpemUuaGVpZ2h0IH0pO1xuICAgIHNhdmVUb1N0b3JlKHBsYWNlbWVudC54LCBwbGFjZW1lbnQueSwgc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuICB9O1xuXG4gIGNvbnN0IHNhdmVUb1N0b3JlID0gKHg6IG51bWJlciwgeTogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcikgPT4ge1xuICAgIHN0b3JlLnNldE9iamVjdChpbmxpbmVFZGl0S2V5LCB7IHg6IHgsIHk6IHksIHc6IHdpZHRoLCBoOiBoZWlnaHQgfSk7XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8UG9ydGFsPlxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5kcmFnZ2FibGVXcmFwcGVyfT5cbiAgICAgICAgPERyYWdnYWJsZSBoYW5kbGU9XCJzdHJvbmdcIiBvblN0b3A9e29uRHJhZ1N0b3B9IHBvc2l0aW9uPXt7IHg6IHBsYWNlbWVudC54LCB5OiBwbGFjZW1lbnQueSB9fT5cbiAgICAgICAgICA8UmVzaXphYmxlIGhlaWdodD17bWVhc3VyZW1lbnRzLmhlaWdodH0gd2lkdGg9e21lYXN1cmVtZW50cy53aWR0aH0gb25SZXNpemU9e29uUmVzaXplU3RvcH0+XG4gICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLmlubGluZUVkaXRvckNvbnRhaW5lcn1cbiAgICAgICAgICAgICAgc3R5bGU9e3sgaGVpZ2h0OiBgJHttZWFzdXJlbWVudHMuaGVpZ2h0fXB4YCwgd2lkdGg6IGAke21lYXN1cmVtZW50cy53aWR0aH1weGAgfX1cbiAgICAgICAgICAgICAgcmVmPXtyZWZ9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDxzdHJvbmcgY2xhc3NOYW1lPXtzdHlsZXMuaW5saW5lRWRpdG9ySGVhZGVyfT5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnBsYWNlaG9sZGVyfSAvPlxuICAgICAgICAgICAgICAgIDxkaXY+Q2FudmFzIElubGluZSBFZGl0b3I8L2Rpdj5cbiAgICAgICAgICAgICAgICA8SWNvbkJ1dHRvbiBuYW1lPVwidGltZXNcIiBzaXplPVwieGxcIiBjbGFzc05hbWU9e3N0eWxlcy5pbmxpbmVFZGl0b3JDbG9zZX0gb25DbGljaz17b25DbG9zZX0gLz5cbiAgICAgICAgICAgICAgPC9zdHJvbmc+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuaW5saW5lRWRpdG9yQ29udGVudFdyYXBwZXJ9PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuaW5saW5lRWRpdG9yQ29udGVudH0+XG4gICAgICAgICAgICAgICAgICA8SW5saW5lRWRpdEJvZHkgLz5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L1Jlc2l6YWJsZT5cbiAgICAgICAgPC9EcmFnZ2FibGU+XG4gICAgICA8L2Rpdj5cbiAgICA8L1BvcnRhbD5cbiAgKTtcbn07XG5cbmNvbnN0IGdldFN0eWxlcyA9ICh0aGVtZTogR3JhZmFuYVRoZW1lMikgPT4gKHtcbiAgaW5saW5lRWRpdG9yQ29udGFpbmVyOiBjc3NgXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIGJhY2tncm91bmQ6ICR7dGhlbWUudjEuY29sb3JzLnBhbmVsQmd9O1xuICAgIGJveC1zaGFkb3c6IDVweCA1cHggMjBweCAtNXB4ICMwMDAwMDA7XG4gICAgei1pbmRleDogMTAwMDtcbiAgICBvcGFjaXR5OiAxO1xuICBgLFxuICBkcmFnZ2FibGVXcmFwcGVyOiBjc3NgXG4gICAgd2lkdGg6IDA7XG4gICAgaGVpZ2h0OiAwO1xuICBgLFxuICBpbmxpbmVFZGl0b3JIZWFkZXI6IGNzc2BcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgYmFja2dyb3VuZDogJHt0aGVtZS5jb2xvcnMuYmFja2dyb3VuZC5jYW52YXN9O1xuICAgIGJvcmRlcjogMXB4IHNvbGlkICR7dGhlbWUuY29sb3JzLmJvcmRlci53ZWFrfTtcbiAgICBoZWlnaHQ6IDQwcHg7XG4gICAgY3Vyc29yOiBtb3ZlO1xuICBgLFxuICBpbmxpbmVFZGl0b3JDb250ZW50OiBjc3NgXG4gICAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xuICAgIHBhZGRpbmc6IDEwcHg7XG4gIGAsXG4gIGlubGluZUVkaXRvckNsb3NlOiBjc3NgXG4gICAgbWFyZ2luLWxlZnQ6IGF1dG87XG4gIGAsXG4gIHBsYWNlaG9sZGVyOiBjc3NgXG4gICAgd2lkdGg6IDI0cHg7XG4gICAgaGVpZ2h0OiAyNHB4O1xuICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgICBtYXJnaW4tcmlnaHQ6IGF1dG87XG4gIGAsXG4gIGlubGluZUVkaXRvckNvbnRlbnRXcmFwcGVyOiBjc3NgXG4gICAgb3ZlcmZsb3c6IHNjcm9sbDtcbiAgYCxcbn0pO1xuIiwiaW1wb3J0IHsgZ2V0IGFzIGxvZGFzaEdldCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgUmVhY3QsIHsgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZU9ic2VydmFibGUgfSBmcm9tICdyZWFjdC11c2UnO1xuXG5pbXBvcnQgeyBQYW5lbE9wdGlvbnNFZGl0b3JCdWlsZGVyLCBTdGFuZGFyZEVkaXRvckNvbnRleHQgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IFBhbmVsT3B0aW9uc1N1cHBsaWVyIH0gZnJvbSAnQGdyYWZhbmEvZGF0YS9zcmMvcGFuZWwvUGFuZWxQbHVnaW4nO1xuaW1wb3J0IHsgTmVzdGVkVmFsdWVBY2Nlc3MgfSBmcm9tICdAZ3JhZmFuYS9kYXRhL3NyYy91dGlscy9PcHRpb25zVUlCdWlsZGVycyc7XG5pbXBvcnQgeyBGcmFtZVN0YXRlIH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2NhbnZhcy9ydW50aW1lL2ZyYW1lJztcbmltcG9ydCB7IE9wdGlvbnNQYW5lQ2F0ZWdvcnlEZXNjcmlwdG9yIH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2Rhc2hib2FyZC9jb21wb25lbnRzL1BhbmVsRWRpdG9yL09wdGlvbnNQYW5lQ2F0ZWdvcnlEZXNjcmlwdG9yJztcbmltcG9ydCB7IGZpbGxPcHRpb25zUGFuZUl0ZW1zIH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2Rhc2hib2FyZC9jb21wb25lbnRzL1BhbmVsRWRpdG9yL2dldFZpc3VhbGl6YXRpb25PcHRpb25zJztcbmltcG9ydCB7IHNldE9wdGlvbkltbXV0YWJseSB9IGZyb20gJ2FwcC9mZWF0dXJlcy9kYXNoYm9hcmQvY29tcG9uZW50cy9QYW5lbEVkaXRvci91dGlscyc7XG5cbmltcG9ydCB7IGFjdGl2ZVBhbmVsU3ViamVjdCwgSW5zdGFuY2VTdGF0ZSB9IGZyb20gJy4vQ2FudmFzUGFuZWwnO1xuaW1wb3J0IHsgZ2V0RWxlbWVudEVkaXRvciB9IGZyb20gJy4vZWRpdG9yL2VsZW1lbnRFZGl0b3InO1xuaW1wb3J0IHsgZ2V0TGF5ZXJFZGl0b3IgfSBmcm9tICcuL2VkaXRvci9sYXllckVkaXRvcic7XG5cbmV4cG9ydCBjb25zdCBJbmxpbmVFZGl0Qm9keSA9ICgpID0+IHtcbiAgY29uc3QgYWN0aXZlUGFuZWwgPSB1c2VPYnNlcnZhYmxlKGFjdGl2ZVBhbmVsU3ViamVjdCk7XG4gIGNvbnN0IGluc3RhbmNlU3RhdGUgPSBhY3RpdmVQYW5lbD8ucGFuZWwuY29udGV4dD8uaW5zdGFuY2VTdGF0ZTtcblxuICBjb25zdCBwYW5lID0gdXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3Qgc3RhdGU6IEluc3RhbmNlU3RhdGUgPSBpbnN0YW5jZVN0YXRlO1xuICAgIGlmICghc3RhdGUpIHtcbiAgICAgIHJldHVybiBuZXcgT3B0aW9uc1BhbmVDYXRlZ29yeURlc2NyaXB0b3IoeyBpZDogJ3Jvb3QnLCB0aXRsZTogJ3Jvb3QnIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHN1cHBsaWVyID0gKGJ1aWxkZXI6IFBhbmVsT3B0aW9uc0VkaXRvckJ1aWxkZXI8YW55PiwgY29udGV4dDogU3RhbmRhcmRFZGl0b3JDb250ZXh0PGFueT4pID0+IHtcbiAgICAgIGJ1aWxkZXIuYWRkTmVzdGVkT3B0aW9ucyhnZXRMYXllckVkaXRvcihpbnN0YW5jZVN0YXRlKSk7XG5cbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGVkO1xuICAgICAgaWYgKHNlbGVjdGlvbj8ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBzZWxlY3Rpb25bMF07XG4gICAgICAgIGlmICghKGVsZW1lbnQgaW5zdGFuY2VvZiBGcmFtZVN0YXRlKSkge1xuICAgICAgICAgIGJ1aWxkZXIuYWRkTmVzdGVkT3B0aW9ucyhcbiAgICAgICAgICAgIGdldEVsZW1lbnRFZGl0b3Ioe1xuICAgICAgICAgICAgICBjYXRlZ29yeTogW2BTZWxlY3RlZCBlbGVtZW50ICgke2VsZW1lbnQub3B0aW9ucy5uYW1lfSlgXSxcbiAgICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgICAgc2NlbmU6IHN0YXRlLnNjZW5lLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBnZXRPcHRpb25zUGFuZUNhdGVnb3J5RGVzY3JpcHRvcih7fSwgc3VwcGxpZXIpO1xuICB9LCBbaW5zdGFuY2VTdGF0ZV0pO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdj5cbiAgICAgIDxkaXY+e3BhbmUuaXRlbXMubWFwKCh2KSA9PiB2LnJlbmRlcigpKX08L2Rpdj5cbiAgICAgIDxkaXY+XG4gICAgICAgIHtwYW5lLmNhdGVnb3JpZXMubWFwKChjKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXYga2V5PXtjLnByb3BzLmlkfT5cbiAgICAgICAgICAgICAgPGg1PntjLnByb3BzLnRpdGxlfTwvaDU+XG4gICAgICAgICAgICAgIDxkaXY+e2MuaXRlbXMubWFwKChzKSA9PiBzLnJlbmRlcigpKX08L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICk7XG4gICAgICAgIH0pfVxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG4vLyDwn6Su8J+krvCfpK7wn6SuIHRoaXMgb2RkbHkgZG9lcyBub3QgYWN0dWFsbHkgZG8gYW55dGhpbmcsIGJ1dCBzdHJ1Y3R1cmUgaXMgcmVxdWlyZWQuICBJJ2xsIHRyeSB0byBjbGVhbiBpdCB1cC4uLlxuZnVuY3Rpb24gZ2V0T3B0aW9uc1BhbmVDYXRlZ29yeURlc2NyaXB0b3I8VCA9IGFueT4oXG4gIHByb3BzOiBhbnksXG4gIHN1cHBsaWVyOiBQYW5lbE9wdGlvbnNTdXBwbGllcjxUPlxuKTogT3B0aW9uc1BhbmVDYXRlZ29yeURlc2NyaXB0b3Ige1xuICBjb25zdCBjb250ZXh0OiBTdGFuZGFyZEVkaXRvckNvbnRleHQ8dW5rbm93biwgdW5rbm93bj4gPSB7XG4gICAgZGF0YTogcHJvcHMuaW5wdXQsXG4gICAgb3B0aW9uczogcHJvcHMub3B0aW9ucyxcbiAgfTtcblxuICBjb25zdCByb290ID0gbmV3IE9wdGlvbnNQYW5lQ2F0ZWdvcnlEZXNjcmlwdG9yKHsgaWQ6ICdyb290JywgdGl0bGU6ICdyb290JyB9KTtcbiAgY29uc3QgZ2V0T3B0aW9uc1BhbmVDYXRlZ29yeSA9IChjYXRlZ29yeU5hbWVzPzogc3RyaW5nW10pOiBPcHRpb25zUGFuZUNhdGVnb3J5RGVzY3JpcHRvciA9PiB7XG4gICAgaWYgKGNhdGVnb3J5TmFtZXM/Lmxlbmd0aCkge1xuICAgICAgY29uc3Qga2V5ID0gY2F0ZWdvcnlOYW1lc1swXTtcbiAgICAgIGxldCBzdWIgPSByb290LmNhdGVnb3JpZXMuZmluZCgodikgPT4gdi5wcm9wcy5pZCA9PT0ga2V5KTtcbiAgICAgIGlmICghc3ViKSB7XG4gICAgICAgIHN1YiA9IG5ldyBPcHRpb25zUGFuZUNhdGVnb3J5RGVzY3JpcHRvcih7IGlkOiBrZXksIHRpdGxlOiBrZXkgfSk7XG4gICAgICAgIHJvb3QuY2F0ZWdvcmllcy5wdXNoKHN1Yik7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3ViO1xuICAgIH1cbiAgICByZXR1cm4gcm9vdDtcbiAgfTtcblxuICBjb25zdCBhY2Nlc3M6IE5lc3RlZFZhbHVlQWNjZXNzID0ge1xuICAgIGdldFZhbHVlOiAocGF0aDogc3RyaW5nKSA9PiBsb2Rhc2hHZXQocHJvcHMub3B0aW9ucywgcGF0aCksXG4gICAgb25DaGFuZ2U6IChwYXRoOiBzdHJpbmcsIHZhbHVlOiBhbnkpID0+IHtcbiAgICAgIHByb3BzLm9uQ2hhbmdlKHNldE9wdGlvbkltbXV0YWJseShwcm9wcy5vcHRpb25zIGFzIGFueSwgcGF0aCwgdmFsdWUpKTtcbiAgICB9LFxuICB9O1xuXG4gIC8vIFVzZSB0aGUgcGFuZWwgb3B0aW9ucyBsb2FkZXJcbiAgZmlsbE9wdGlvbnNQYW5lSXRlbXMoc3VwcGxpZXIsIGFjY2VzcywgZ2V0T3B0aW9uc1BhbmVDYXRlZ29yeSwgY29udGV4dCk7XG4gIHJldHVybiByb290O1xufVxuIiwiaW1wb3J0IFJlYWN0LCB7IEZDLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgQXBwRXZlbnRzLCBTdGFuZGFyZEVkaXRvclByb3BzLCBTdGFuZGFyZEVkaXRvcnNSZWdpc3RyeUl0ZW0sIFN0cmluZ0ZpZWxkQ29uZmlnU2V0dGluZ3MgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IGNvbmZpZywgZ2V0QmFja2VuZFNydiB9IGZyb20gJ0BncmFmYW5hL3J1bnRpbWUnO1xuaW1wb3J0IHsgQnV0dG9uLCBJbmxpbmVGaWVsZCwgSW5saW5lRmllbGRSb3csIEpTT05Gb3JtYXR0ZXIsIFN0cmluZ1ZhbHVlRWRpdG9yIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuaW1wb3J0IHsgYXBwRXZlbnRzIH0gZnJvbSAnYXBwL2NvcmUvY29yZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQVBJRWRpdG9yQ29uZmlnIHtcbiAgZW5kcG9pbnQ6IHN0cmluZztcbiAgZGF0YT86IHN0cmluZztcbn1cblxuY29uc3QgZHVtbXlTdHJpbmdTZXR0aW5nczogU3RhbmRhcmRFZGl0b3JzUmVnaXN0cnlJdGVtPHN0cmluZywgU3RyaW5nRmllbGRDb25maWdTZXR0aW5ncz4gPSB7XG4gIHNldHRpbmdzOiB7fSxcbn0gYXMgYW55O1xuXG5leHBvcnQgY29uc3QgY2FsbEFwaSA9IChhcGk6IEFQSUVkaXRvckNvbmZpZywgaXNUZXN0ID0gZmFsc2UpID0+IHtcbiAgaWYgKGFwaSkge1xuICAgIGdldEJhY2tlbmRTcnYoKVxuICAgICAgLmZldGNoKHtcbiAgICAgICAgdXJsOiBhcGkuZW5kcG9pbnQhLFxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgZGF0YTogYXBpLmRhdGEgPz8ge30sXG4gICAgICB9KVxuICAgICAgLnN1YnNjcmliZSh7XG4gICAgICAgIGVycm9yOiAoZXJyb3I6IGFueSkgPT4ge1xuICAgICAgICAgIGlmIChpc1Rlc3QpIHtcbiAgICAgICAgICAgIGFwcEV2ZW50cy5lbWl0KEFwcEV2ZW50cy5hbGVydEVycm9yLCBbJ0Vycm9yIGhhcyBvY2N1cnJlZDogJywgSlNPTi5zdHJpbmdpZnkoZXJyb3IpXSk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgaWYgKGlzVGVzdCkge1xuICAgICAgICAgICAgYXBwRXZlbnRzLmVtaXQoQXBwRXZlbnRzLmFsZXJ0U3VjY2VzcywgWydUZXN0IHN1Y2Nlc3NmdWwnXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgfSk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBBUElFZGl0b3I6IEZDPFN0YW5kYXJkRWRpdG9yUHJvcHM8QVBJRWRpdG9yQ29uZmlnLCBhbnksIGFueT4+ID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHsgdmFsdWUsIGNvbnRleHQsIG9uQ2hhbmdlIH0gPSBwcm9wcztcbiAgY29uc3QgbGFiZWxXaWR0aCA9IDk7XG5cbiAgY29uc3Qgb25FbmRwb2ludENoYW5nZSA9IHVzZUNhbGxiYWNrKFxuICAgIChlbmRwb2ludCkgPT4ge1xuICAgICAgb25DaGFuZ2Uoe1xuICAgICAgICAuLi52YWx1ZSxcbiAgICAgICAgZW5kcG9pbnQsXG4gICAgICB9KTtcbiAgICB9LFxuICAgIFtvbkNoYW5nZSwgdmFsdWVdXG4gICk7XG5cbiAgY29uc3Qgb25EYXRhQ2hhbmdlID0gdXNlQ2FsbGJhY2soXG4gICAgKGRhdGEpID0+IHtcbiAgICAgIG9uQ2hhbmdlKHtcbiAgICAgICAgLi4udmFsdWUsXG4gICAgICAgIGRhdGEsXG4gICAgICB9KTtcbiAgICB9LFxuICAgIFtvbkNoYW5nZSwgdmFsdWVdXG4gICk7XG5cbiAgY29uc3QgcmVuZGVySlNPTiA9IChkYXRhOiBzdHJpbmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QganNvbiA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICByZXR1cm4gPEpTT05Gb3JtYXR0ZXIganNvbj17anNvbn0gLz47XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBgSW52YWxpZCBKU09OIHByb3ZpZGVkOiAke2Vycm9yLm1lc3NhZ2V9YDtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgcmVuZGVyVGVzdEFQSUJ1dHRvbiA9IChhcGk6IEFQSUVkaXRvckNvbmZpZykgPT4ge1xuICAgIGlmIChhcGkgJiYgYXBpLmVuZHBvaW50KSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8QnV0dG9uIG9uQ2xpY2s9eygpID0+IGNhbGxBcGkoYXBpLCB0cnVlKX0gdGl0bGU9eydUZXN0IEFQSSd9PlxuICAgICAgICAgIFRlc3QgQVBJXG4gICAgICAgIDwvQnV0dG9uPlxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH07XG5cbiAgcmV0dXJuIGNvbmZpZy5kaXNhYmxlU2FuaXRpemVIdG1sID8gKFxuICAgIDw+XG4gICAgICA8SW5saW5lRmllbGRSb3c+XG4gICAgICAgIDxJbmxpbmVGaWVsZCBsYWJlbD17J0VuZHBvaW50J30gbGFiZWxXaWR0aD17bGFiZWxXaWR0aH0gZ3Jvdz17dHJ1ZX0+XG4gICAgICAgICAgPFN0cmluZ1ZhbHVlRWRpdG9yXG4gICAgICAgICAgICBjb250ZXh0PXtjb250ZXh0fVxuICAgICAgICAgICAgdmFsdWU9e3ZhbHVlPy5lbmRwb2ludH1cbiAgICAgICAgICAgIG9uQ2hhbmdlPXtvbkVuZHBvaW50Q2hhbmdlfVxuICAgICAgICAgICAgaXRlbT17ZHVtbXlTdHJpbmdTZXR0aW5nc31cbiAgICAgICAgICAvPlxuICAgICAgICA8L0lubGluZUZpZWxkPlxuICAgICAgPC9JbmxpbmVGaWVsZFJvdz5cbiAgICAgIDxJbmxpbmVGaWVsZFJvdz5cbiAgICAgICAgPElubGluZUZpZWxkIGxhYmVsPXsnRGF0YSd9IGxhYmVsV2lkdGg9e2xhYmVsV2lkdGh9IGdyb3c9e3RydWV9PlxuICAgICAgICAgIDxTdHJpbmdWYWx1ZUVkaXRvclxuICAgICAgICAgICAgY29udGV4dD17Y29udGV4dH1cbiAgICAgICAgICAgIHZhbHVlPXt2YWx1ZT8uZGF0YSA/PyAne30nfVxuICAgICAgICAgICAgb25DaGFuZ2U9e29uRGF0YUNoYW5nZX1cbiAgICAgICAgICAgIGl0ZW09e2R1bW15U3RyaW5nU2V0dGluZ3N9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9JbmxpbmVGaWVsZD5cbiAgICAgIDwvSW5saW5lRmllbGRSb3c+XG4gICAgICB7cmVuZGVyVGVzdEFQSUJ1dHRvbih2YWx1ZSl9XG4gICAgICA8YnIgLz5cbiAgICAgIHtyZW5kZXJKU09OKHZhbHVlPy5kYXRhID8/ICd7fScpfVxuICAgIDwvPlxuICApIDogKFxuICAgIDw+TXVzdCBlbmFibGUgZGlzYWJsZVNhbml0aXplSHRtbCBmZWF0dXJlIGZsYWcgdG8gYWNjZXNzPC8+XG4gICk7XG59O1xuIiwiaW1wb3J0IFJlYWN0LCB7IFB1cmVDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBEcm9wUmVzdWx0IH0gZnJvbSAncmVhY3QtYmVhdXRpZnVsLWRuZCc7XG5cbmltcG9ydCB7IEFwcEV2ZW50cywgU2VsZWN0YWJsZVZhbHVlLCBTdGFuZGFyZEVkaXRvclByb3BzIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBCdXR0b24sIEhvcml6b250YWxHcm91cCB9IGZyb20gJ0BncmFmYW5hL3VpJztcbmltcG9ydCBhcHBFdmVudHMgZnJvbSAnYXBwL2NvcmUvYXBwX2V2ZW50cyc7XG5pbXBvcnQgeyBBZGRMYXllckJ1dHRvbiB9IGZyb20gJ2FwcC9jb3JlL2NvbXBvbmVudHMvTGF5ZXJzL0FkZExheWVyQnV0dG9uJztcbmltcG9ydCB7IExheWVyRHJhZ0Ryb3BMaXN0IH0gZnJvbSAnYXBwL2NvcmUvY29tcG9uZW50cy9MYXllcnMvTGF5ZXJEcmFnRHJvcExpc3QnO1xuaW1wb3J0IHsgQ2FudmFzRWxlbWVudE9wdGlvbnMsIGNhbnZhc0VsZW1lbnRSZWdpc3RyeSB9IGZyb20gJ2FwcC9mZWF0dXJlcy9jYW52YXMnO1xuaW1wb3J0IHsgbm90Rm91bmRJdGVtIH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2NhbnZhcy9lbGVtZW50cy9ub3RGb3VuZCc7XG5pbXBvcnQgeyBFbGVtZW50U3RhdGUgfSBmcm9tICdhcHAvZmVhdHVyZXMvY2FudmFzL3J1bnRpbWUvZWxlbWVudCc7XG5pbXBvcnQgeyBGcmFtZVN0YXRlIH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2NhbnZhcy9ydW50aW1lL2ZyYW1lJztcbmltcG9ydCB7IFNlbGVjdGlvblBhcmFtcyB9IGZyb20gJ2FwcC9mZWF0dXJlcy9jYW52YXMvcnVudGltZS9zY2VuZSc7XG5pbXBvcnQgeyBTaG93Q29uZmlybU1vZGFsRXZlbnQgfSBmcm9tICdhcHAvdHlwZXMvZXZlbnRzJztcblxuaW1wb3J0IHsgUGFuZWxPcHRpb25zIH0gZnJvbSAnLi4vbW9kZWxzLmdlbic7XG5pbXBvcnQgeyBMYXllckFjdGlvbklEIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBMYXllckVkaXRvclByb3BzIH0gZnJvbSAnLi9sYXllckVkaXRvcic7XG5cbnR5cGUgUHJvcHMgPSBTdGFuZGFyZEVkaXRvclByb3BzPGFueSwgTGF5ZXJFZGl0b3JQcm9wcywgUGFuZWxPcHRpb25zPjtcblxuZXhwb3J0IGNsYXNzIExheWVyRWxlbWVudExpc3RFZGl0b3IgZXh0ZW5kcyBQdXJlQ29tcG9uZW50PFByb3BzPiB7XG4gIGdldFNjZW5lID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgc2V0dGluZ3MgfSA9IHRoaXMucHJvcHMuaXRlbTtcbiAgICBpZiAoIXNldHRpbmdzPy5sYXllcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gc2V0dGluZ3MubGF5ZXIuc2NlbmU7XG4gIH07XG5cbiAgb25BZGRJdGVtID0gKHNlbDogU2VsZWN0YWJsZVZhbHVlPHN0cmluZz4pID0+IHtcbiAgICBjb25zdCB7IHNldHRpbmdzIH0gPSB0aGlzLnByb3BzLml0ZW07XG4gICAgaWYgKCFzZXR0aW5ncz8ubGF5ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBsYXllciB9ID0gc2V0dGluZ3M7XG5cbiAgICBjb25zdCBpdGVtID0gY2FudmFzRWxlbWVudFJlZ2lzdHJ5LmdldElmRXhpc3RzKHNlbC52YWx1ZSkgPz8gbm90Rm91bmRJdGVtO1xuICAgIGNvbnN0IG5ld0VsZW1lbnRPcHRpb25zID0gaXRlbS5nZXROZXdPcHRpb25zKCkgYXMgQ2FudmFzRWxlbWVudE9wdGlvbnM7XG4gICAgbmV3RWxlbWVudE9wdGlvbnMudHlwZSA9IGl0ZW0uaWQ7XG4gICAgY29uc3QgbmV3RWxlbWVudCA9IG5ldyBFbGVtZW50U3RhdGUoaXRlbSwgbmV3RWxlbWVudE9wdGlvbnMsIGxheWVyKTtcbiAgICBuZXdFbGVtZW50LnVwZGF0ZURhdGEobGF5ZXIuc2NlbmUuY29udGV4dCk7XG4gICAgbGF5ZXIuZWxlbWVudHMucHVzaChuZXdFbGVtZW50KTtcbiAgICBsYXllci5zY2VuZS5zYXZlKCk7XG5cbiAgICBsYXllci5yZWluaXRpYWxpemVNb3ZlYWJsZSgpO1xuICB9O1xuXG4gIG9uU2VsZWN0ID0gKGl0ZW06IGFueSkgPT4ge1xuICAgIGNvbnN0IHsgc2V0dGluZ3MgfSA9IHRoaXMucHJvcHMuaXRlbTtcblxuICAgIGlmIChzZXR0aW5ncz8uc2NlbmUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBzZWxlY3Rpb246IFNlbGVjdGlvblBhcmFtcyA9IHsgdGFyZ2V0czogW10gfTtcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBGcmFtZVN0YXRlKSB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudHM6IEhUTUxEaXZFbGVtZW50W10gPSBbXTtcbiAgICAgICAgICB0YXJnZXRFbGVtZW50cy5wdXNoKGl0ZW0/LmRpdiEpO1xuICAgICAgICAgIHNlbGVjdGlvbi50YXJnZXRzID0gdGFyZ2V0RWxlbWVudHM7XG4gICAgICAgICAgc2VsZWN0aW9uLmZyYW1lID0gaXRlbTtcbiAgICAgICAgICBzZXR0aW5ncy5zY2VuZS5zZWxlY3Qoc2VsZWN0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgRWxlbWVudFN0YXRlKSB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IFtpdGVtPy5kaXYhXTtcbiAgICAgICAgICBzZWxlY3Rpb24udGFyZ2V0cyA9IHRhcmdldEVsZW1lbnQ7XG4gICAgICAgICAgc2V0dGluZ3Muc2NlbmUuc2VsZWN0KHNlbGVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGFwcEV2ZW50cy5lbWl0KEFwcEV2ZW50cy5hbGVydEVycm9yLCBbJ1VuYWJsZSB0byBzZWxlY3QgZWxlbWVudCwgdHJ5IHNlbGVjdGluZyBlbGVtZW50IGluIHBhbmVsIGluc3RlYWQnXSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIG9uQ2xlYXJTZWxlY3Rpb24gPSAoKSA9PiB7XG4gICAgY29uc3QgeyBzZXR0aW5ncyB9ID0gdGhpcy5wcm9wcy5pdGVtO1xuXG4gICAgaWYgKCFzZXR0aW5ncz8ubGF5ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7IGxheWVyIH0gPSBzZXR0aW5ncztcblxuICAgIGxheWVyLnNjZW5lLmNsZWFyQ3VycmVudFNlbGVjdGlvbigpO1xuICB9O1xuXG4gIG9uRHJhZ0VuZCA9IChyZXN1bHQ6IERyb3BSZXN1bHQpID0+IHtcbiAgICBpZiAoIXJlc3VsdC5kZXN0aW5hdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHsgc2V0dGluZ3MgfSA9IHRoaXMucHJvcHMuaXRlbTtcbiAgICBpZiAoIXNldHRpbmdzPy5sYXllcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHsgbGF5ZXIgfSA9IHNldHRpbmdzO1xuXG4gICAgY29uc3QgY291bnQgPSBsYXllci5lbGVtZW50cy5sZW5ndGggLSAxO1xuICAgIGNvbnN0IHNyYyA9IChyZXN1bHQuc291cmNlLmluZGV4IC0gY291bnQpICogLTE7XG4gICAgY29uc3QgZHN0ID0gKHJlc3VsdC5kZXN0aW5hdGlvbi5pbmRleCAtIGNvdW50KSAqIC0xO1xuXG4gICAgbGF5ZXIucmVvcmRlcihzcmMsIGRzdCk7XG4gIH07XG5cbiAgZ29VcExheWVyID0gKCkgPT4ge1xuICAgIGNvbnN0IHNldHRpbmdzID0gdGhpcy5wcm9wcy5pdGVtLnNldHRpbmdzO1xuXG4gICAgaWYgKCFzZXR0aW5ncz8ubGF5ZXIgfHwgIXNldHRpbmdzPy5zY2VuZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHsgc2NlbmUsIGxheWVyIH0gPSBzZXR0aW5ncztcblxuICAgIGlmIChsYXllci5wYXJlbnQpIHtcbiAgICAgIHNjZW5lLnVwZGF0ZUN1cnJlbnRMYXllcihsYXllci5wYXJlbnQpO1xuICAgIH1cbiAgfTtcblxuICBwcml2YXRlIGRlY291cGxlRnJhbWUgPSAoKSA9PiB7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSB0aGlzLnByb3BzLml0ZW0uc2V0dGluZ3M7XG5cbiAgICBpZiAoIXNldHRpbmdzPy5sYXllcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHsgbGF5ZXIgfSA9IHNldHRpbmdzO1xuXG4gICAgdGhpcy5kZWxldGVGcmFtZSgpO1xuICAgIGxheWVyLmVsZW1lbnRzLmZvckVhY2goKGVsZW1lbnQ6IEVsZW1lbnRTdGF0ZSkgPT4ge1xuICAgICAgY29uc3QgZWxlbWVudENvbnRhaW5lciA9IGVsZW1lbnQuZGl2Py5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGVsZW1lbnQuc2V0UGxhY2VtZW50RnJvbUNvbnN0cmFpbnQoZWxlbWVudENvbnRhaW5lciwgbGF5ZXIucGFyZW50Py5kaXY/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbiAgICAgIGxheWVyLnBhcmVudD8uZG9BY3Rpb24oTGF5ZXJBY3Rpb25JRC5EdXBsaWNhdGUsIGVsZW1lbnQsIGZhbHNlLCBmYWxzZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgcHJpdmF0ZSBvbkRlY291cGxlRnJhbWUgPSAoKSA9PiB7XG4gICAgYXBwRXZlbnRzLnB1Ymxpc2goXG4gICAgICBuZXcgU2hvd0NvbmZpcm1Nb2RhbEV2ZW50KHtcbiAgICAgICAgdGl0bGU6ICdEZWNvdXBsZSBmcmFtZScsXG4gICAgICAgIHRleHQ6IGBBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gZGVjb3VwbGUgdGhpcyBmcmFtZT9gLFxuICAgICAgICB0ZXh0MjogJ1RoaXMgd2lsbCByZW1vdmUgdGhlIGZyYW1lIGFuZCBwdXNoIG5lc3RlZCBlbGVtZW50cyBpbiB0aGUgbmV4dCBsZXZlbCB1cC4nLFxuICAgICAgICBjb25maXJtVGV4dDogJ1llcycsXG4gICAgICAgIHllc1RleHQ6ICdEZWNvdXBsZScsXG4gICAgICAgIG9uQ29uZmlybTogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZGVjb3VwbGVGcmFtZSgpO1xuICAgICAgICB9LFxuICAgICAgfSlcbiAgICApO1xuICB9O1xuXG4gIHByaXZhdGUgZGVsZXRlRnJhbWUgPSAoKSA9PiB7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSB0aGlzLnByb3BzLml0ZW0uc2V0dGluZ3M7XG5cbiAgICBpZiAoIXNldHRpbmdzPy5sYXllcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHsgbGF5ZXIgfSA9IHNldHRpbmdzO1xuXG4gICAgY29uc3Qgc2NlbmUgPSB0aGlzLmdldFNjZW5lKCk7XG4gICAgc2NlbmU/LmJ5TmFtZS5kZWxldGUobGF5ZXIuZ2V0TmFtZSgpKTtcbiAgICBsYXllci5lbGVtZW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiBzY2VuZT8uYnlOYW1lLmRlbGV0ZShlbGVtZW50LmdldE5hbWUoKSkpO1xuICAgIGxheWVyLnBhcmVudD8uZG9BY3Rpb24oTGF5ZXJBY3Rpb25JRC5EZWxldGUsIGxheWVyKTtcblxuICAgIHRoaXMuZ29VcExheWVyKCk7XG4gIH07XG5cbiAgcHJpdmF0ZSBvbkZyYW1lU2VsZWN0aW9uID0gKCkgPT4ge1xuICAgIGNvbnN0IHNjZW5lID0gdGhpcy5nZXRTY2VuZSgpO1xuICAgIGlmIChzY2VuZSkge1xuICAgICAgc2NlbmUuZnJhbWVTZWxlY3Rpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKCdubyBzY2VuZSEnKTtcbiAgICB9XG4gIH07XG5cbiAgcHJpdmF0ZSBvbkRlbGV0ZUZyYW1lID0gKCkgPT4ge1xuICAgIGFwcEV2ZW50cy5wdWJsaXNoKFxuICAgICAgbmV3IFNob3dDb25maXJtTW9kYWxFdmVudCh7XG4gICAgICAgIHRpdGxlOiAnRGVsZXRlIGZyYW1lJyxcbiAgICAgICAgdGV4dDogYEFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBkZWxldGUgdGhpcyBmcmFtZT9gLFxuICAgICAgICB0ZXh0MjogJ1RoaXMgd2lsbCBkZWxldGUgdGhlIGZyYW1lIGFuZCBhbGwgbmVzdGVkIGVsZW1lbnRzLicsXG4gICAgICAgIGljb246ICd0cmFzaC1hbHQnLFxuICAgICAgICBjb25maXJtVGV4dDogJ0RlbGV0ZScsXG4gICAgICAgIHllc1RleHQ6ICdEZWxldGUnLFxuICAgICAgICBvbkNvbmZpcm06IGFzeW5jICgpID0+IHtcbiAgICAgICAgICB0aGlzLmRlbGV0ZUZyYW1lKCk7XG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgICk7XG4gIH07XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHNldHRpbmdzID0gdGhpcy5wcm9wcy5pdGVtLnNldHRpbmdzO1xuICAgIGlmICghc2V0dGluZ3MpIHtcbiAgICAgIHJldHVybiA8ZGl2Pk5vIHNldHRpbmdzPC9kaXY+O1xuICAgIH1cbiAgICBjb25zdCBsYXllciA9IHNldHRpbmdzLmxheWVyO1xuICAgIGlmICghbGF5ZXIpIHtcbiAgICAgIHJldHVybiA8ZGl2Pk1pc3NpbmcgbGF5ZXI/PC9kaXY+O1xuICAgIH1cblxuICAgIGNvbnN0IG9uRGVsZXRlID0gKGVsZW1lbnQ6IEVsZW1lbnRTdGF0ZSkgPT4ge1xuICAgICAgbGF5ZXIuZG9BY3Rpb24oTGF5ZXJBY3Rpb25JRC5EZWxldGUsIGVsZW1lbnQpO1xuICAgIH07XG5cbiAgICBjb25zdCBvbkR1cGxpY2F0ZSA9IChlbGVtZW50OiBFbGVtZW50U3RhdGUpID0+IHtcbiAgICAgIGxheWVyLmRvQWN0aW9uKExheWVyQWN0aW9uSUQuRHVwbGljYXRlLCBlbGVtZW50KTtcbiAgICB9O1xuXG4gICAgY29uc3QgZ2V0TGF5ZXJJbmZvID0gKGVsZW1lbnQ6IEVsZW1lbnRTdGF0ZSkgPT4ge1xuICAgICAgcmV0dXJuIGVsZW1lbnQub3B0aW9ucy50eXBlO1xuICAgIH07XG5cbiAgICBjb25zdCBvbk5hbWVDaGFuZ2UgPSAoZWxlbWVudDogRWxlbWVudFN0YXRlLCBuYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgIGVsZW1lbnQub25DaGFuZ2UoeyAuLi5lbGVtZW50Lm9wdGlvbnMsIG5hbWUgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGlzRnJhbWUgPSAoZWxlbWVudDogRWxlbWVudFN0YXRlKSA9PiB7XG4gICAgICByZXR1cm4gZWxlbWVudCBpbnN0YW5jZW9mIEZyYW1lU3RhdGU7XG4gICAgfTtcblxuICAgIGNvbnN0IHZlcmlmeUxheWVyTmFtZVVuaXF1ZW5lc3MgPSAobmFtZVRvVmVyaWZ5OiBzdHJpbmcpID0+IHtcbiAgICAgIGNvbnN0IHNjZW5lID0gdGhpcy5nZXRTY2VuZSgpO1xuXG4gICAgICByZXR1cm4gQm9vbGVhbihzY2VuZT8uY2FuUmVuYW1lKG5hbWVUb1ZlcmlmeSkpO1xuICAgIH07XG5cbiAgICBjb25zdCBzZWxlY3Rpb246IHN0cmluZ1tdID0gc2V0dGluZ3Muc2VsZWN0ZWQgPyBzZXR0aW5ncy5zZWxlY3RlZC5tYXAoKHYpID0+IHYuZ2V0TmFtZSgpKSA6IFtdO1xuICAgIHJldHVybiAoXG4gICAgICA8PlxuICAgICAgICB7IWxheWVyLmlzUm9vdCgpICYmIChcbiAgICAgICAgICA8PlxuICAgICAgICAgICAgPEJ1dHRvbiBpY29uPVwiYW5nbGUtdXBcIiBzaXplPVwic21cIiB2YXJpYW50PVwic2Vjb25kYXJ5XCIgb25DbGljaz17dGhpcy5nb1VwTGF5ZXJ9PlxuICAgICAgICAgICAgICBHbyB1cCBsZXZlbFxuICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICA8QnV0dG9uIHNpemU9XCJzbVwiIHZhcmlhbnQ9XCJzZWNvbmRhcnlcIiBvbkNsaWNrPXsoKSA9PiB0aGlzLm9uU2VsZWN0KGxheWVyKX0+XG4gICAgICAgICAgICAgIFNlbGVjdCBmcmFtZVxuICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICA8QnV0dG9uIHNpemU9XCJzbVwiIHZhcmlhbnQ9XCJzZWNvbmRhcnlcIiBvbkNsaWNrPXsoKSA9PiB0aGlzLm9uRGVjb3VwbGVGcmFtZSgpfT5cbiAgICAgICAgICAgICAgRGVjb3VwbGUgZnJhbWVcbiAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgPEJ1dHRvbiBzaXplPVwic21cIiB2YXJpYW50PVwic2Vjb25kYXJ5XCIgb25DbGljaz17KCkgPT4gdGhpcy5vbkRlbGV0ZUZyYW1lKCl9PlxuICAgICAgICAgICAgICBEZWxldGUgZnJhbWVcbiAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgIDwvPlxuICAgICAgICApfVxuICAgICAgICA8TGF5ZXJEcmFnRHJvcExpc3RcbiAgICAgICAgICBvbkRyYWdFbmQ9e3RoaXMub25EcmFnRW5kfVxuICAgICAgICAgIG9uU2VsZWN0PXt0aGlzLm9uU2VsZWN0fVxuICAgICAgICAgIG9uRGVsZXRlPXtvbkRlbGV0ZX1cbiAgICAgICAgICBvbkR1cGxpY2F0ZT17b25EdXBsaWNhdGV9XG4gICAgICAgICAgZ2V0TGF5ZXJJbmZvPXtnZXRMYXllckluZm99XG4gICAgICAgICAgb25OYW1lQ2hhbmdlPXtvbk5hbWVDaGFuZ2V9XG4gICAgICAgICAgdmVyaWZ5TGF5ZXJOYW1lVW5pcXVlbmVzcz17dmVyaWZ5TGF5ZXJOYW1lVW5pcXVlbmVzc31cbiAgICAgICAgICBpc0ZyYW1lPXtpc0ZyYW1lfVxuICAgICAgICAgIGxheWVycz17bGF5ZXIuZWxlbWVudHN9XG4gICAgICAgICAgc2VsZWN0aW9uPXtzZWxlY3Rpb259XG4gICAgICAgIC8+XG4gICAgICAgIDxiciAvPlxuXG4gICAgICAgIDxIb3Jpem9udGFsR3JvdXA+XG4gICAgICAgICAgPEFkZExheWVyQnV0dG9uXG4gICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5vbkFkZEl0ZW19XG4gICAgICAgICAgICBvcHRpb25zPXtjYW52YXNFbGVtZW50UmVnaXN0cnkuc2VsZWN0T3B0aW9ucygpLm9wdGlvbnN9XG4gICAgICAgICAgICBsYWJlbD17J0FkZCBpdGVtJ31cbiAgICAgICAgICAvPlxuICAgICAgICAgIHtzZWxlY3Rpb24ubGVuZ3RoID4gMCAmJiAoXG4gICAgICAgICAgICA8QnV0dG9uIHNpemU9XCJzbVwiIHZhcmlhbnQ9XCJzZWNvbmRhcnlcIiBvbkNsaWNrPXt0aGlzLm9uQ2xlYXJTZWxlY3Rpb259PlxuICAgICAgICAgICAgICBDbGVhciBzZWxlY3Rpb25cbiAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICl9XG4gICAgICAgICAge3NlbGVjdGlvbi5sZW5ndGggPiAxICYmIChcbiAgICAgICAgICAgIDxCdXR0b24gc2l6ZT1cInNtXCIgdmFyaWFudD1cInNlY29uZGFyeVwiIG9uQ2xpY2s9e3RoaXMub25GcmFtZVNlbGVjdGlvbn0+XG4gICAgICAgICAgICAgIEZyYW1lIHNlbGVjdGlvblxuICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgKX1cbiAgICAgICAgPC9Ib3Jpem9udGFsR3JvdXA+XG4gICAgICA8Lz5cbiAgICApO1xuICB9XG59XG4iLCJpbXBvcnQgUmVhY3QsIHsgRkMgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VPYnNlcnZhYmxlIH0gZnJvbSAncmVhY3QtdXNlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgU2VsZWN0YWJsZVZhbHVlLCBTdGFuZGFyZEVkaXRvclByb3BzIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBGaWVsZCwgSW5saW5lRmllbGQsIElubGluZUZpZWxkUm93LCBTZWxlY3QsIFZlcnRpY2FsR3JvdXAgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5pbXBvcnQgeyBIb3Jpem9udGFsQ29uc3RyYWludCwgUGxhY2VtZW50LCBWZXJ0aWNhbENvbnN0cmFpbnQgfSBmcm9tICdhcHAvZmVhdHVyZXMvY2FudmFzJztcbmltcG9ydCB7IE51bWJlcklucHV0IH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2RpbWVuc2lvbnMvZWRpdG9ycy9OdW1iZXJJbnB1dCc7XG5cbmltcG9ydCB7IFBhbmVsT3B0aW9ucyB9IGZyb20gJy4uL21vZGVscy5nZW4nO1xuXG5pbXBvcnQgeyBDYW52YXNFZGl0b3JPcHRpb25zIH0gZnJvbSAnLi9lbGVtZW50RWRpdG9yJztcblxuY29uc3QgcGxhY2VzOiBBcnJheTxrZXlvZiBQbGFjZW1lbnQ+ID0gWyd0b3AnLCAnbGVmdCcsICdib3R0b20nLCAncmlnaHQnLCAnd2lkdGgnLCAnaGVpZ2h0J107XG5cbmNvbnN0IGhvcml6b250YWxPcHRpb25zOiBBcnJheTxTZWxlY3RhYmxlVmFsdWU8SG9yaXpvbnRhbENvbnN0cmFpbnQ+PiA9IFtcbiAgeyBsYWJlbDogJ0xlZnQnLCB2YWx1ZTogSG9yaXpvbnRhbENvbnN0cmFpbnQuTGVmdCB9LFxuICB7IGxhYmVsOiAnUmlnaHQnLCB2YWx1ZTogSG9yaXpvbnRhbENvbnN0cmFpbnQuUmlnaHQgfSxcbiAgeyBsYWJlbDogJ0xlZnQgYW5kIHJpZ2h0JywgdmFsdWU6IEhvcml6b250YWxDb25zdHJhaW50LkxlZnRSaWdodCB9LFxuICB7IGxhYmVsOiAnQ2VudGVyJywgdmFsdWU6IEhvcml6b250YWxDb25zdHJhaW50LkNlbnRlciB9LFxuICB7IGxhYmVsOiAnU2NhbGUnLCB2YWx1ZTogSG9yaXpvbnRhbENvbnN0cmFpbnQuU2NhbGUgfSxcbl07XG5cbmNvbnN0IHZlcnRpY2FsT3B0aW9uczogQXJyYXk8U2VsZWN0YWJsZVZhbHVlPFZlcnRpY2FsQ29uc3RyYWludD4+ID0gW1xuICB7IGxhYmVsOiAnVG9wJywgdmFsdWU6IFZlcnRpY2FsQ29uc3RyYWludC5Ub3AgfSxcbiAgeyBsYWJlbDogJ0JvdHRvbScsIHZhbHVlOiBWZXJ0aWNhbENvbnN0cmFpbnQuQm90dG9tIH0sXG4gIHsgbGFiZWw6ICdUb3AgYW5kIGJvdHRvbScsIHZhbHVlOiBWZXJ0aWNhbENvbnN0cmFpbnQuVG9wQm90dG9tIH0sXG4gIHsgbGFiZWw6ICdDZW50ZXInLCB2YWx1ZTogVmVydGljYWxDb25zdHJhaW50LkNlbnRlciB9LFxuICB7IGxhYmVsOiAnU2NhbGUnLCB2YWx1ZTogVmVydGljYWxDb25zdHJhaW50LlNjYWxlIH0sXG5dO1xuXG5leHBvcnQgY29uc3QgUGxhY2VtZW50RWRpdG9yOiBGQzxTdGFuZGFyZEVkaXRvclByb3BzPGFueSwgQ2FudmFzRWRpdG9yT3B0aW9ucywgUGFuZWxPcHRpb25zPj4gPSAoeyBpdGVtIH0pID0+IHtcbiAgY29uc3Qgc2V0dGluZ3MgPSBpdGVtLnNldHRpbmdzO1xuXG4gIC8vIFdpbGwgZm9yY2UgYSByZXJlbmRlciB3aGVuZXZlciB0aGUgc3ViamVjdCBjaGFuZ2VzXG4gIHVzZU9ic2VydmFibGUoc2V0dGluZ3M/LnNjZW5lID8gc2V0dGluZ3Muc2NlbmUubW92ZWQgOiBuZXcgU3ViamVjdCgpKTtcblxuICBpZiAoIXNldHRpbmdzKSB7XG4gICAgcmV0dXJuIDxkaXY+TG9hZGluZy4uLjwvZGl2PjtcbiAgfVxuXG4gIGNvbnN0IGVsZW1lbnQgPSBzZXR0aW5ncy5lbGVtZW50O1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gPGRpdj4/Pz88L2Rpdj47XG4gIH1cbiAgY29uc3QgeyBvcHRpb25zIH0gPSBlbGVtZW50O1xuICBjb25zdCB7IHBsYWNlbWVudCwgY29uc3RyYWludDogbGF5b3V0IH0gPSBvcHRpb25zO1xuXG4gIGNvbnN0IG9uSG9yaXpvbnRhbENvbnN0cmFpbnRDaGFuZ2UgPSAoaDogU2VsZWN0YWJsZVZhbHVlPEhvcml6b250YWxDb25zdHJhaW50PikgPT4ge1xuICAgIGVsZW1lbnQub3B0aW9ucy5jb25zdHJhaW50IS5ob3Jpem9udGFsID0gaC52YWx1ZTtcbiAgICBlbGVtZW50LnNldFBsYWNlbWVudEZyb21Db25zdHJhaW50KCk7XG4gICAgc2V0dGluZ3Muc2NlbmUucmV2SWQrKztcbiAgICBzZXR0aW5ncy5zY2VuZS5zYXZlKHRydWUpO1xuICB9O1xuXG4gIGNvbnN0IG9uVmVydGljYWxDb25zdHJhaW50Q2hhbmdlID0gKHY6IFNlbGVjdGFibGVWYWx1ZTxWZXJ0aWNhbENvbnN0cmFpbnQ+KSA9PiB7XG4gICAgZWxlbWVudC5vcHRpb25zLmNvbnN0cmFpbnQhLnZlcnRpY2FsID0gdi52YWx1ZTtcbiAgICBlbGVtZW50LnNldFBsYWNlbWVudEZyb21Db25zdHJhaW50KCk7XG4gICAgc2V0dGluZ3Muc2NlbmUucmV2SWQrKztcbiAgICBzZXR0aW5ncy5zY2VuZS5zYXZlKHRydWUpO1xuICB9O1xuXG4gIGNvbnN0IG9uUG9zaXRpb25DaGFuZ2UgPSAodmFsdWU6IG51bWJlciB8IHVuZGVmaW5lZCwgcGxhY2VtZW50OiBrZXlvZiBQbGFjZW1lbnQpID0+IHtcbiAgICBlbGVtZW50Lm9wdGlvbnMucGxhY2VtZW50IVtwbGFjZW1lbnRdID0gdmFsdWUgPz8gZWxlbWVudC5vcHRpb25zLnBsYWNlbWVudCFbcGxhY2VtZW50XTtcbiAgICBlbGVtZW50LmFwcGx5TGF5b3V0U3R5bGVzVG9EaXYoKTtcbiAgICBzZXR0aW5ncy5zY2VuZS5jbGVhckN1cnJlbnRTZWxlY3Rpb24oKTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxkaXY+XG4gICAgICA8VmVydGljYWxHcm91cD5cbiAgICAgICAgPFNlbGVjdCBvcHRpb25zPXt2ZXJ0aWNhbE9wdGlvbnN9IG9uQ2hhbmdlPXtvblZlcnRpY2FsQ29uc3RyYWludENoYW5nZX0gdmFsdWU9e2xheW91dD8udmVydGljYWx9IC8+XG4gICAgICAgIDxTZWxlY3RcbiAgICAgICAgICBvcHRpb25zPXtob3Jpem9udGFsT3B0aW9uc31cbiAgICAgICAgICBvbkNoYW5nZT17b25Ib3Jpem9udGFsQ29uc3RyYWludENoYW5nZX1cbiAgICAgICAgICB2YWx1ZT17b3B0aW9ucy5jb25zdHJhaW50Py5ob3Jpem9udGFsfVxuICAgICAgICAvPlxuICAgICAgPC9WZXJ0aWNhbEdyb3VwPlxuICAgICAgPGJyIC8+XG5cbiAgICAgIDxGaWVsZCBsYWJlbD1cIlBvc2l0aW9uXCI+XG4gICAgICAgIDw+XG4gICAgICAgICAge3BsYWNlcy5tYXAoKHApID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBwbGFjZW1lbnQhW3BdO1xuICAgICAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIDxJbmxpbmVGaWVsZFJvdyBrZXk9e3B9PlxuICAgICAgICAgICAgICAgIDxJbmxpbmVGaWVsZCBsYWJlbD17cH0gbGFiZWxXaWR0aD17OH0gZ3Jvdz17dHJ1ZX0+XG4gICAgICAgICAgICAgICAgICA8TnVtYmVySW5wdXQgdmFsdWU9e3Z9IG9uQ2hhbmdlPXsodikgPT4gb25Qb3NpdGlvbkNoYW5nZSh2LCBwKX0gLz5cbiAgICAgICAgICAgICAgICA8L0lubGluZUZpZWxkPlxuICAgICAgICAgICAgICA8L0lubGluZUZpZWxkUm93PlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KX1cbiAgICAgICAgPC8+XG4gICAgICA8L0ZpZWxkPlxuICAgIDwvZGl2PlxuICApO1xufTtcbiIsImltcG9ydCB7IGdldCBhcyBsb2Rhc2hHZXQgfSBmcm9tICdsb2Rhc2gnO1xuXG5pbXBvcnQgeyBOZXN0ZWRQYW5lbE9wdGlvbnMsIE5lc3RlZFZhbHVlQWNjZXNzIH0gZnJvbSAnQGdyYWZhbmEvZGF0YS9zcmMvdXRpbHMvT3B0aW9uc1VJQnVpbGRlcnMnO1xuaW1wb3J0IHsgQ2FudmFzRWxlbWVudE9wdGlvbnMsIGNhbnZhc0VsZW1lbnRSZWdpc3RyeSwgREVGQVVMVF9DQU5WQVNfRUxFTUVOVF9DT05GSUcgfSBmcm9tICdhcHAvZmVhdHVyZXMvY2FudmFzJztcbmltcG9ydCB7IEVsZW1lbnRTdGF0ZSB9IGZyb20gJ2FwcC9mZWF0dXJlcy9jYW52YXMvcnVudGltZS9lbGVtZW50JztcbmltcG9ydCB7IFNjZW5lIH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2NhbnZhcy9ydW50aW1lL3NjZW5lJztcbmltcG9ydCB7IHNldE9wdGlvbkltbXV0YWJseSB9IGZyb20gJ2FwcC9mZWF0dXJlcy9kYXNoYm9hcmQvY29tcG9uZW50cy9QYW5lbEVkaXRvci91dGlscyc7XG5cbmltcG9ydCB7IFBsYWNlbWVudEVkaXRvciB9IGZyb20gJy4vUGxhY2VtZW50RWRpdG9yJztcbmltcG9ydCB7IG9wdGlvbkJ1aWxkZXIgfSBmcm9tICcuL29wdGlvbnMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIENhbnZhc0VkaXRvck9wdGlvbnMge1xuICBlbGVtZW50OiBFbGVtZW50U3RhdGU7XG4gIHNjZW5lOiBTY2VuZTtcbiAgY2F0ZWdvcnk/OiBzdHJpbmdbXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEVsZW1lbnRFZGl0b3Iob3B0czogQ2FudmFzRWRpdG9yT3B0aW9ucyk6IE5lc3RlZFBhbmVsT3B0aW9uczxDYW52YXNFbGVtZW50T3B0aW9ucz4ge1xuICByZXR1cm4ge1xuICAgIGNhdGVnb3J5OiBvcHRzLmNhdGVnb3J5LFxuICAgIHBhdGg6ICctLScsIC8vIG5vdCB1c2VkIVxuXG4gICAgLy8gTm90ZSB0aGF0IGNhbnZhcyBlZGl0b3Igd3JpdGVzIHRoaW5ncyB0byB0aGUgc2NlbmUhXG4gICAgdmFsdWVzOiAocGFyZW50OiBOZXN0ZWRWYWx1ZUFjY2VzcykgPT4gKHtcbiAgICAgIGdldFZhbHVlOiAocGF0aDogc3RyaW5nKSA9PiB7XG4gICAgICAgIHJldHVybiBsb2Rhc2hHZXQob3B0cy5lbGVtZW50Lm9wdGlvbnMsIHBhdGgpO1xuICAgICAgfSxcbiAgICAgIG9uQ2hhbmdlOiAocGF0aDogc3RyaW5nLCB2YWx1ZTogYW55KSA9PiB7XG4gICAgICAgIGxldCBvcHRpb25zID0gb3B0cy5lbGVtZW50Lm9wdGlvbnM7XG4gICAgICAgIGlmIChwYXRoID09PSAndHlwZScgJiYgdmFsdWUpIHtcbiAgICAgICAgICBjb25zdCBsYXllciA9IGNhbnZhc0VsZW1lbnRSZWdpc3RyeS5nZXRJZkV4aXN0cyh2YWx1ZSk7XG4gICAgICAgICAgaWYgKCFsYXllcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdsYXllciBkb2VzIG5vdCBleGlzdCcsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAuLi5sYXllci5nZXROZXdPcHRpb25zKG9wdGlvbnMpLFxuICAgICAgICAgICAgdHlwZTogbGF5ZXIuaWQsXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zID0gc2V0T3B0aW9uSW1tdXRhYmx5KG9wdGlvbnMsIHBhdGgsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBvcHRzLmVsZW1lbnQub25DaGFuZ2Uob3B0aW9ucyk7XG4gICAgICAgIG9wdHMuZWxlbWVudC51cGRhdGVEYXRhKG9wdHMuc2NlbmUuY29udGV4dCk7XG4gICAgICB9LFxuICAgIH0pLFxuXG4gICAgLy8gRHluYW1pY2FsbHkgZmlsbCB0aGUgc2VsZWN0ZWQgZWxlbWVudFxuICAgIGJ1aWxkOiAoYnVpbGRlciwgY29udGV4dCkgPT4ge1xuICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSBvcHRzLmVsZW1lbnQ7XG4gICAgICBjb25zdCBsYXllclR5cGVzID0gY2FudmFzRWxlbWVudFJlZ2lzdHJ5LnNlbGVjdE9wdGlvbnMoXG4gICAgICAgIG9wdGlvbnM/LnR5cGUgLy8gdGhlIHNlbGVjdGVkIHZhbHVlXG4gICAgICAgICAgPyBbb3B0aW9ucy50eXBlXSAvLyBhcyBhbiBhcnJheVxuICAgICAgICAgIDogW0RFRkFVTFRfQ0FOVkFTX0VMRU1FTlRfQ09ORklHLnR5cGVdXG4gICAgICApO1xuXG4gICAgICBidWlsZGVyLmFkZFNlbGVjdCh7XG4gICAgICAgIHBhdGg6ICd0eXBlJyxcbiAgICAgICAgbmFtZTogdW5kZWZpbmVkIGFzIGFueSwgLy8gcmVxdWlyZWQsIGJ1dCBoaWRlIHNwYWNlXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgb3B0aW9uczogbGF5ZXJUeXBlcy5vcHRpb25zLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIC8vIGZvcmNlIGNsZWFuIGxheWVyIGNvbmZpZ3VyYXRpb25cbiAgICAgIGNvbnN0IGxheWVyID0gY2FudmFzRWxlbWVudFJlZ2lzdHJ5LmdldElmRXhpc3RzKG9wdGlvbnM/LnR5cGUgPz8gREVGQVVMVF9DQU5WQVNfRUxFTUVOVF9DT05GSUcudHlwZSkhO1xuICAgICAgbGV0IGN1cnJlbnRPcHRpb25zID0gb3B0aW9ucztcbiAgICAgIGlmICghY3VycmVudE9wdGlvbnMpIHtcbiAgICAgICAgY3VycmVudE9wdGlvbnMgPSB7XG4gICAgICAgICAgLi4ubGF5ZXIuZ2V0TmV3T3B0aW9ucyhvcHRpb25zKSxcbiAgICAgICAgICB0eXBlOiBsYXllci5pZCxcbiAgICAgICAgICBuYW1lOiBgRWxlbWVudCAke0RhdGUubm93KCl9LiR7TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwKX1gLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgY3R4ID0geyAuLi5jb250ZXh0LCBvcHRpb25zOiBjdXJyZW50T3B0aW9ucyB9O1xuXG4gICAgICBpZiAobGF5ZXI/LnJlZ2lzdGVyT3B0aW9uc1VJKSB7XG4gICAgICAgIGxheWVyLnJlZ2lzdGVyT3B0aW9uc1VJKGJ1aWxkZXIsIGN0eCk7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbkJ1aWxkZXIuYWRkQmFja2dyb3VuZChidWlsZGVyLCBjdHgpO1xuICAgICAgb3B0aW9uQnVpbGRlci5hZGRCb3JkZXIoYnVpbGRlciwgY3R4KTtcblxuICAgICAgYnVpbGRlci5hZGRDdXN0b21FZGl0b3Ioe1xuICAgICAgICBjYXRlZ29yeTogWydMYXlvdXQnXSxcbiAgICAgICAgaWQ6ICdjb250ZW50JyxcbiAgICAgICAgcGF0aDogJ19fJywgLy8gbm90IHVzZWRcbiAgICAgICAgbmFtZTogJ0NvbnN0cmFpbnRzJyxcbiAgICAgICAgZWRpdG9yOiBQbGFjZW1lbnRFZGl0b3IsXG4gICAgICAgIHNldHRpbmdzOiBvcHRzLFxuICAgICAgfSk7XG4gICAgfSxcbiAgfTtcbn1cbiIsImltcG9ydCB7IGdldCBhcyBsb2Rhc2hHZXQgfSBmcm9tICdsb2Rhc2gnO1xuXG5pbXBvcnQgeyBOZXN0ZWRQYW5lbE9wdGlvbnMsIE5lc3RlZFZhbHVlQWNjZXNzIH0gZnJvbSAnQGdyYWZhbmEvZGF0YS9zcmMvdXRpbHMvT3B0aW9uc1VJQnVpbGRlcnMnO1xuaW1wb3J0IHsgRWxlbWVudFN0YXRlIH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2NhbnZhcy9ydW50aW1lL2VsZW1lbnQnO1xuaW1wb3J0IHsgRnJhbWVTdGF0ZSB9IGZyb20gJ2FwcC9mZWF0dXJlcy9jYW52YXMvcnVudGltZS9mcmFtZSc7XG5pbXBvcnQgeyBTY2VuZSB9IGZyb20gJ2FwcC9mZWF0dXJlcy9jYW52YXMvcnVudGltZS9zY2VuZSc7XG5pbXBvcnQgeyBzZXRPcHRpb25JbW11dGFibHkgfSBmcm9tICdhcHAvZmVhdHVyZXMvZGFzaGJvYXJkL2NvbXBvbmVudHMvUGFuZWxFZGl0b3IvdXRpbHMnO1xuXG5pbXBvcnQgeyBJbnN0YW5jZVN0YXRlIH0gZnJvbSAnLi4vQ2FudmFzUGFuZWwnO1xuXG5pbXBvcnQgeyBMYXllckVsZW1lbnRMaXN0RWRpdG9yIH0gZnJvbSAnLi9MYXllckVsZW1lbnRMaXN0RWRpdG9yJztcbmltcG9ydCB7IFBsYWNlbWVudEVkaXRvciB9IGZyb20gJy4vUGxhY2VtZW50RWRpdG9yJztcbmltcG9ydCB7IG9wdGlvbkJ1aWxkZXIgfSBmcm9tICcuL29wdGlvbnMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIExheWVyRWRpdG9yUHJvcHMge1xuICBzY2VuZTogU2NlbmU7XG4gIGxheWVyOiBGcmFtZVN0YXRlO1xuICBzZWxlY3RlZDogRWxlbWVudFN0YXRlW107XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRMYXllckVkaXRvcihvcHRzOiBJbnN0YW5jZVN0YXRlKTogTmVzdGVkUGFuZWxPcHRpb25zPExheWVyRWRpdG9yUHJvcHM+IHtcbiAgY29uc3QgeyBzZWxlY3RlZCwgc2NlbmUgfSA9IG9wdHM7XG5cbiAgaWYgKCFzY2VuZS5jdXJyZW50TGF5ZXIpIHtcbiAgICBzY2VuZS5jdXJyZW50TGF5ZXIgPSBzY2VuZS5yb290IGFzIEZyYW1lU3RhdGU7XG4gIH1cblxuICBpZiAoc2VsZWN0ZWQpIHtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2Ygc2VsZWN0ZWQpIHtcbiAgICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgRnJhbWVTdGF0ZSkge1xuICAgICAgICBzY2VuZS5jdXJyZW50TGF5ZXIgPSBlbGVtZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZW1lbnQucGFyZW50KSB7XG4gICAgICAgIHNjZW5lLmN1cnJlbnRMYXllciA9IGVsZW1lbnQucGFyZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBvcHRpb25zID0gc2NlbmUuY3VycmVudExheWVyLm9wdGlvbnMgfHwgeyBlbGVtZW50czogW10gfTtcblxuICByZXR1cm4ge1xuICAgIGNhdGVnb3J5OiBbJ0xheWVyJ10sXG4gICAgcGF0aDogJy0tJywgLy8gbm90IHVzZWQhXG5cbiAgICAvLyBOb3RlIHRoYXQgY2FudmFzIGVkaXRvciB3cml0ZXMgdGhpbmdzIHRvIHRoZSBzY2VuZSFcbiAgICB2YWx1ZXM6IChwYXJlbnQ6IE5lc3RlZFZhbHVlQWNjZXNzKSA9PiAoe1xuICAgICAgZ2V0VmFsdWU6IChwYXRoOiBzdHJpbmcpID0+IHtcbiAgICAgICAgcmV0dXJuIGxvZGFzaEdldChvcHRpb25zLCBwYXRoKTtcbiAgICAgIH0sXG4gICAgICBvbkNoYW5nZTogKHBhdGg6IHN0cmluZywgdmFsdWU6IGFueSkgPT4ge1xuICAgICAgICBpZiAocGF0aCA9PT0gJ3R5cGUnICYmIHZhbHVlKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCd1bmFibGUgdG8gY2hhbmdlIGxheWVyIHR5cGUnKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYyA9IHNldE9wdGlvbkltbXV0YWJseShvcHRpb25zLCBwYXRoLCB2YWx1ZSk7XG4gICAgICAgIHNjZW5lLmN1cnJlbnRMYXllcj8ub25DaGFuZ2UoYyk7XG4gICAgICAgIHNjZW5lLmN1cnJlbnRMYXllcj8udXBkYXRlRGF0YShzY2VuZS5jb250ZXh0KTtcbiAgICAgIH0sXG4gICAgfSksXG5cbiAgICAvLyBEeW5hbWljYWxseSBmaWxsIHRoZSBzZWxlY3RlZCBlbGVtZW50XG4gICAgYnVpbGQ6IChidWlsZGVyLCBjb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50TGF5ZXIgPSBzY2VuZS5jdXJyZW50TGF5ZXI7XG4gICAgICBpZiAoY3VycmVudExheWVyICYmICFjdXJyZW50TGF5ZXIuaXNSb290KCkpIHtcbiAgICAgICAgLy8gVE9ETzogdGhlIG5vbi1yb290IG5hdiBvcHRpb25cbiAgICAgIH1cblxuICAgICAgYnVpbGRlci5hZGRDdXN0b21FZGl0b3Ioe1xuICAgICAgICBpZDogJ2NvbnRlbnQnLFxuICAgICAgICBwYXRoOiAncm9vdCcsXG4gICAgICAgIG5hbWU6ICdFbGVtZW50cycsXG4gICAgICAgIGVkaXRvcjogTGF5ZXJFbGVtZW50TGlzdEVkaXRvcixcbiAgICAgICAgc2V0dGluZ3M6IHsgc2NlbmUsIGxheWVyOiBzY2VuZS5jdXJyZW50TGF5ZXIsIHNlbGVjdGVkIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgY3R4ID0geyAuLi5jb250ZXh0LCBvcHRpb25zIH07XG4gICAgICBvcHRpb25CdWlsZGVyLmFkZEJhY2tncm91bmQoYnVpbGRlciBhcyBhbnksIGN0eCk7XG4gICAgICBvcHRpb25CdWlsZGVyLmFkZEJvcmRlcihidWlsZGVyIGFzIGFueSwgY3R4KTtcblxuICAgICAgaWYgKGN1cnJlbnRMYXllciAmJiAhY3VycmVudExheWVyLmlzUm9vdCgpKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkQ3VzdG9tRWRpdG9yKHtcbiAgICAgICAgICBjYXRlZ29yeTogWydMYXlvdXQnXSxcbiAgICAgICAgICBpZDogJ2NvbnRlbnQnLFxuICAgICAgICAgIHBhdGg6ICdfXycsIC8vIG5vdCB1c2VkXG4gICAgICAgICAgbmFtZTogJ0NvbnN0cmFpbnRzJyxcbiAgICAgICAgICBlZGl0b3I6IFBsYWNlbWVudEVkaXRvcixcbiAgICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgc2NlbmU6IG9wdHMuc2NlbmUsXG4gICAgICAgICAgICBlbGVtZW50OiBjdXJyZW50TGF5ZXIsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgfTtcbn1cbiIsImltcG9ydCB7IFBhbmVsT3B0aW9uc1N1cHBsaWVyIH0gZnJvbSAnQGdyYWZhbmEvZGF0YS9zcmMvcGFuZWwvUGFuZWxQbHVnaW4nO1xuaW1wb3J0IHsgQmFja2dyb3VuZEltYWdlU2l6ZSwgQ2FudmFzRWxlbWVudE9wdGlvbnMgfSBmcm9tICdhcHAvZmVhdHVyZXMvY2FudmFzJztcbmltcG9ydCB7IENvbG9yRGltZW5zaW9uRWRpdG9yLCBSZXNvdXJjZURpbWVuc2lvbkVkaXRvciB9IGZyb20gJ2FwcC9mZWF0dXJlcy9kaW1lbnNpb25zL2VkaXRvcnMnO1xuXG5pbnRlcmZhY2UgT3B0aW9uU3VwcGxpZXJzIHtcbiAgYWRkQmFja2dyb3VuZDogUGFuZWxPcHRpb25zU3VwcGxpZXI8Q2FudmFzRWxlbWVudE9wdGlvbnM+O1xuICBhZGRCb3JkZXI6IFBhbmVsT3B0aW9uc1N1cHBsaWVyPENhbnZhc0VsZW1lbnRPcHRpb25zPjtcbn1cblxuZXhwb3J0IGNvbnN0IG9wdGlvbkJ1aWxkZXI6IE9wdGlvblN1cHBsaWVycyA9IHtcbiAgYWRkQmFja2dyb3VuZDogKGJ1aWxkZXIsIGNvbnRleHQpID0+IHtcbiAgICBjb25zdCBjYXRlZ29yeSA9IFsnQmFja2dyb3VuZCddO1xuICAgIGJ1aWxkZXJcbiAgICAgIC5hZGRDdXN0b21FZGl0b3Ioe1xuICAgICAgICBjYXRlZ29yeSxcbiAgICAgICAgaWQ6ICdiYWNrZ3JvdW5kLmNvbG9yJyxcbiAgICAgICAgcGF0aDogJ2JhY2tncm91bmQuY29sb3InLFxuICAgICAgICBuYW1lOiAnQ29sb3InLFxuICAgICAgICBlZGl0b3I6IENvbG9yRGltZW5zaW9uRWRpdG9yLFxuICAgICAgICBzZXR0aW5nczoge30sXG4gICAgICAgIGRlZmF1bHRWYWx1ZToge1xuICAgICAgICAgIC8vIENvbmZpZ3VyZWQgdmFsdWVzXG4gICAgICAgICAgZml4ZWQ6ICcnLFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICAgIC5hZGRDdXN0b21FZGl0b3Ioe1xuICAgICAgICBjYXRlZ29yeSxcbiAgICAgICAgaWQ6ICdiYWNrZ3JvdW5kLmltYWdlJyxcbiAgICAgICAgcGF0aDogJ2JhY2tncm91bmQuaW1hZ2UnLFxuICAgICAgICBuYW1lOiAnSW1hZ2UnLFxuICAgICAgICBlZGl0b3I6IFJlc291cmNlRGltZW5zaW9uRWRpdG9yLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIHJlc291cmNlVHlwZTogJ2ltYWdlJyxcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgICAuYWRkUmFkaW8oe1xuICAgICAgICBjYXRlZ29yeSxcbiAgICAgICAgcGF0aDogJ2JhY2tncm91bmQuc2l6ZScsXG4gICAgICAgIG5hbWU6ICdJbWFnZSBzaXplJyxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBvcHRpb25zOiBbXG4gICAgICAgICAgICB7IHZhbHVlOiBCYWNrZ3JvdW5kSW1hZ2VTaXplLk9yaWdpbmFsLCBsYWJlbDogJ09yaWdpbmFsJyB9LFxuICAgICAgICAgICAgeyB2YWx1ZTogQmFja2dyb3VuZEltYWdlU2l6ZS5Db250YWluLCBsYWJlbDogJ0NvbnRhaW4nIH0sXG4gICAgICAgICAgICB7IHZhbHVlOiBCYWNrZ3JvdW5kSW1hZ2VTaXplLkNvdmVyLCBsYWJlbDogJ0NvdmVyJyB9LFxuICAgICAgICAgICAgeyB2YWx1ZTogQmFja2dyb3VuZEltYWdlU2l6ZS5GaWxsLCBsYWJlbDogJ0ZpbGwnIH0sXG4gICAgICAgICAgICB7IHZhbHVlOiBCYWNrZ3JvdW5kSW1hZ2VTaXplLlRpbGUsIGxhYmVsOiAnVGlsZScgfSxcbiAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICBkZWZhdWx0VmFsdWU6IEJhY2tncm91bmRJbWFnZVNpemUuQ292ZXIsXG4gICAgICB9KTtcbiAgfSxcblxuICBhZGRCb3JkZXI6IChidWlsZGVyLCBjb250ZXh0KSA9PiB7XG4gICAgY29uc3QgY2F0ZWdvcnkgPSBbJ0JvcmRlciddO1xuICAgIGJ1aWxkZXIuYWRkU2xpZGVySW5wdXQoe1xuICAgICAgY2F0ZWdvcnksXG4gICAgICBwYXRoOiAnYm9yZGVyLndpZHRoJyxcbiAgICAgIG5hbWU6ICdXaWR0aCcsXG4gICAgICBkZWZhdWx0VmFsdWU6IDIsXG4gICAgICBzZXR0aW5nczoge1xuICAgICAgICBtaW46IDAsXG4gICAgICAgIG1heDogMjAsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgaWYgKGNvbnRleHQub3B0aW9ucz8uYm9yZGVyPy53aWR0aCkge1xuICAgICAgYnVpbGRlci5hZGRDdXN0b21FZGl0b3Ioe1xuICAgICAgICBjYXRlZ29yeSxcbiAgICAgICAgaWQ6ICdib3JkZXIuY29sb3InLFxuICAgICAgICBwYXRoOiAnYm9yZGVyLmNvbG9yJyxcbiAgICAgICAgbmFtZTogJ0NvbG9yJyxcbiAgICAgICAgZWRpdG9yOiBDb2xvckRpbWVuc2lvbkVkaXRvcixcbiAgICAgICAgc2V0dGluZ3M6IHt9LFxuICAgICAgICBkZWZhdWx0VmFsdWU6IHtcbiAgICAgICAgICAvLyBDb25maWd1cmVkIHZhbHVlc1xuICAgICAgICAgIGZpeGVkOiAnJyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbn07XG4iLCJpbXBvcnQgeyBQYW5lbFBsdWdpbiB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgRnJhbWVTdGF0ZSB9IGZyb20gJ2FwcC9mZWF0dXJlcy9jYW52YXMvcnVudGltZS9mcmFtZSc7XG5cbmltcG9ydCB7IENhbnZhc1BhbmVsLCBJbnN0YW5jZVN0YXRlIH0gZnJvbSAnLi9DYW52YXNQYW5lbCc7XG5pbXBvcnQgeyBnZXRFbGVtZW50RWRpdG9yIH0gZnJvbSAnLi9lZGl0b3IvZWxlbWVudEVkaXRvcic7XG5pbXBvcnQgeyBnZXRMYXllckVkaXRvciB9IGZyb20gJy4vZWRpdG9yL2xheWVyRWRpdG9yJztcbmltcG9ydCB7IFBhbmVsT3B0aW9ucyB9IGZyb20gJy4vbW9kZWxzLmdlbic7XG5cbmV4cG9ydCBjb25zdCBwbHVnaW4gPSBuZXcgUGFuZWxQbHVnaW48UGFuZWxPcHRpb25zPihDYW52YXNQYW5lbClcbiAgLnNldE5vUGFkZGluZygpIC8vIGV4dGVuZCB0byBwYW5lbCBlZGdlc1xuICAudXNlRmllbGRDb25maWcoKVxuICAuc2V0UGFuZWxPcHRpb25zKChidWlsZGVyLCBjb250ZXh0KSA9PiB7XG4gICAgY29uc3Qgc3RhdGU6IEluc3RhbmNlU3RhdGUgPSBjb250ZXh0Lmluc3RhbmNlU3RhdGU7XG5cbiAgICBidWlsZGVyLmFkZEJvb2xlYW5Td2l0Y2goe1xuICAgICAgcGF0aDogJ2lubGluZUVkaXRpbmcnLFxuICAgICAgbmFtZTogJ0lubGluZSBlZGl0aW5nJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnRW5hYmxlIGVkaXRpbmcgdGhlIHBhbmVsIGRpcmVjdGx5JyxcbiAgICAgIGRlZmF1bHRWYWx1ZTogdHJ1ZSxcbiAgICB9KTtcblxuICAgIGlmIChzdGF0ZSkge1xuICAgICAgYnVpbGRlci5hZGROZXN0ZWRPcHRpb25zKGdldExheWVyRWRpdG9yKHN0YXRlKSk7XG5cbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGVkO1xuICAgICAgaWYgKHNlbGVjdGlvbj8ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBzZWxlY3Rpb25bMF07XG4gICAgICAgIGlmICghKGVsZW1lbnQgaW5zdGFuY2VvZiBGcmFtZVN0YXRlKSkge1xuICAgICAgICAgIGJ1aWxkZXIuYWRkTmVzdGVkT3B0aW9ucyhcbiAgICAgICAgICAgIGdldEVsZW1lbnRFZGl0b3Ioe1xuICAgICAgICAgICAgICBjYXRlZ29yeTogW2BTZWxlY3RlZCBlbGVtZW50ICgke2VsZW1lbnQub3B0aW9ucy5uYW1lfSlgXSxcbiAgICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgICAgc2NlbmU6IHN0YXRlLnNjZW5lLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiIsImV4cG9ydCBlbnVtIExheWVyQWN0aW9uSUQge1xuICBEZWxldGUgPSAnZGVsZXRlJyxcbiAgRHVwbGljYXRlID0gJ2R1cGxpY2F0ZScsXG4gIE1vdmVUb3AgPSAnbW92ZS10b3AnLFxuICBNb3ZlQm90dG9tID0gJ21vdmUtYm90dG9tJyxcbn1cbiIsIi8qXG5Db3B5cmlnaHQgKGMpIDIwMTkgRGF5YnJ1c2hcbm5hbWU6IGNzcy1zdHlsZWRcbmxpY2Vuc2U6IE1JVFxuYXV0aG9yOiBEYXlicnVzaFxucmVwb3NpdG9yeTogZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS9kYXlicnVzaC9jc3Mtc3R5bGVkLmdpdFxudmVyc2lvbjogMS4wLjBcbiovXG5pbXBvcnQgeyBzcGxpdENvbW1hIH0gZnJvbSAnQGRheWJydXNoL3V0aWxzJztcblxuZnVuY3Rpb24gaGFzaChzdHIpIHtcbiAgdmFyIGhhc2ggPSA1MzgxLFxuICAgICAgaSAgICA9IHN0ci5sZW5ndGg7XG5cbiAgd2hpbGUoaSkge1xuICAgIGhhc2ggPSAoaGFzaCAqIDMzKSBeIHN0ci5jaGFyQ29kZUF0KC0taSk7XG4gIH1cblxuICAvKiBKYXZhU2NyaXB0IGRvZXMgYml0d2lzZSBvcGVyYXRpb25zIChsaWtlIFhPUiwgYWJvdmUpIG9uIDMyLWJpdCBzaWduZWRcbiAgICogaW50ZWdlcnMuIFNpbmNlIHdlIHdhbnQgdGhlIHJlc3VsdHMgdG8gYmUgYWx3YXlzIHBvc2l0aXZlLCBjb252ZXJ0IHRoZVxuICAgKiBzaWduZWQgaW50IHRvIGFuIHVuc2lnbmVkIGJ5IGRvaW5nIGFuIHVuc2lnbmVkIGJpdHNoaWZ0LiAqL1xuICByZXR1cm4gaGFzaCA+Pj4gMDtcbn1cblxudmFyIHN0cmluZ0hhc2ggPSBoYXNoO1xuXG5mdW5jdGlvbiBnZXRIYXNoKHN0cikge1xuICByZXR1cm4gc3RyaW5nSGFzaChzdHIpLnRvU3RyaW5nKDM2KTtcbn1cbmZ1bmN0aW9uIGdldFNoYWRvd1Jvb3QocGFyZW50RWxlbWVudCkge1xuICBpZiAocGFyZW50RWxlbWVudCAmJiBwYXJlbnRFbGVtZW50LmdldFJvb3ROb2RlKSB7XG4gICAgdmFyIHJvb3ROb2RlID0gcGFyZW50RWxlbWVudC5nZXRSb290Tm9kZSgpO1xuXG4gICAgaWYgKHJvb3ROb2RlLm5vZGVUeXBlID09PSAxMSkge1xuICAgICAgcmV0dXJuIHJvb3ROb2RlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybjtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VTdHlsZShjbGFzc05hbWUsIGNzcywgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5vcmlnaW5hbCkge1xuICAgIHJldHVybiBjc3M7XG4gIH1cblxuICByZXR1cm4gY3NzLnJlcGxhY2UoLyhbXn07e1xcc31dW159O3tdKnxeXFxzKil7L21nLCBmdW5jdGlvbiAoXywgc2VsZWN0b3IpIHtcbiAgICB2YXIgdHJpbW1lZFNlbGVjdG9yID0gc2VsZWN0b3IudHJpbSgpO1xuICAgIHJldHVybiAodHJpbW1lZFNlbGVjdG9yID8gc3BsaXRDb21tYSh0cmltbWVkU2VsZWN0b3IpIDogW1wiXCJdKS5tYXAoZnVuY3Rpb24gKHN1YlNlbGVjdG9yKSB7XG4gICAgICB2YXIgdHJpbW1lZFN1YlNlbGVjdG9yID0gc3ViU2VsZWN0b3IudHJpbSgpO1xuXG4gICAgICBpZiAodHJpbW1lZFN1YlNlbGVjdG9yLmluZGV4T2YoXCJAXCIpID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cmltbWVkU3ViU2VsZWN0b3I7XG4gICAgICB9IGVsc2UgaWYgKHRyaW1tZWRTdWJTZWxlY3Rvci5pbmRleE9mKFwiOmdsb2JhbFwiKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiB0cmltbWVkU3ViU2VsZWN0b3IucmVwbGFjZSgvXFw6Z2xvYmFsL2csIFwiXCIpO1xuICAgICAgfSBlbHNlIGlmICh0cmltbWVkU3ViU2VsZWN0b3IuaW5kZXhPZihcIjpob3N0XCIpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIFwiXCIgKyB0cmltbWVkU3ViU2VsZWN0b3IucmVwbGFjZSgvXFw6aG9zdC9nLCBcIi5cIiArIGNsYXNzTmFtZSk7XG4gICAgICB9IGVsc2UgaWYgKHRyaW1tZWRTdWJTZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gXCIuXCIgKyBjbGFzc05hbWUgKyBcIiBcIiArIHRyaW1tZWRTdWJTZWxlY3RvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBcIi5cIiArIGNsYXNzTmFtZTtcbiAgICAgIH1cbiAgICB9KS5qb2luKFwiLCBcIikgKyBcIiB7XCI7XG4gIH0pO1xufVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUoY2xhc3NOYW1lLCBjc3MsIG9wdGlvbnMsIHNoYWRvd1Jvb3QpIHtcbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICBzdHlsZS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwidGV4dC9jc3NcIik7XG4gIHN0eWxlLnNldEF0dHJpYnV0ZShcImRhdGEtc3R5bGVkLWlkXCIsIGNsYXNzTmFtZSk7XG5cbiAgaWYgKG9wdGlvbnMubm9uY2UpIHtcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBvcHRpb25zLm5vbmNlKTtcbiAgfVxuXG4gIHN0eWxlLmlubmVySFRNTCA9IHJlcGxhY2VTdHlsZShjbGFzc05hbWUsIGNzcywgb3B0aW9ucyk7XG4gIChzaGFkb3dSb290IHx8IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuYm9keSkuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICByZXR1cm4gc3R5bGU7XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIHN0eWxlZCBvYmplY3QgdGhhdCBjYW4gYmUgZGVmaW5lZCBhbmQgaW5zZXJ0ZWQgaW50byB0aGUgY3NzLlxuICogQHBhcmFtIC0gY3NzIHN0eWxlc1xuICovXG5cbmZ1bmN0aW9uIHN0eWxlZChjc3MpIHtcbiAgdmFyIGluamVjdENsYXNzTmFtZSA9IFwickNTXCIgKyBnZXRIYXNoKGNzcyk7XG4gIHZhciBpbmplY3RDb3VudCA9IDA7XG4gIHZhciBpbmplY3RFbGVtZW50O1xuICByZXR1cm4ge1xuICAgIGNsYXNzTmFtZTogaW5qZWN0Q2xhc3NOYW1lLFxuICAgIGluamVjdDogZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNoYWRvd1Jvb3QgPSBnZXRTaGFkb3dSb290KGVsKTtcbiAgICAgIHZhciBmaXJzdE1vdW50ID0gaW5qZWN0Q291bnQgPT09IDA7XG4gICAgICB2YXIgc3R5bGVFbGVtZW50O1xuXG4gICAgICBpZiAoc2hhZG93Um9vdCB8fCBmaXJzdE1vdW50KSB7XG4gICAgICAgIHN0eWxlRWxlbWVudCA9IGluamVjdFN0eWxlKGluamVjdENsYXNzTmFtZSwgY3NzLCBvcHRpb25zLCBzaGFkb3dSb290KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZpcnN0TW91bnQpIHtcbiAgICAgICAgaW5qZWN0RWxlbWVudCA9IHN0eWxlRWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzaGFkb3dSb290KSB7XG4gICAgICAgICsraW5qZWN0Q291bnQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoc2hhZG93Um9vdCkge1xuICAgICAgICAgICAgZWwucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcbiAgICAgICAgICAgIHN0eWxlRWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpbmplY3RDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgLS1pbmplY3RDb3VudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGluamVjdENvdW50ID09PSAwICYmIGluamVjdEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgaW5qZWN0RWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGluamVjdEVsZW1lbnQpO1xuICAgICAgICAgICAgICBpbmplY3RFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdHlsZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHlsZWQuZXNtLmpzLm1hcFxuIiwiLypcbkNvcHlyaWdodCAoYykgMjAxOSBEYXlicnVzaFxubmFtZTogcmVhY3QtY29tcGF0LW1vdmVhYmxlXG5saWNlbnNlOiBNSVRcbmF1dGhvcjogRGF5YnJ1c2hcbnJlcG9zaXRvcnk6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXlicnVzaC9tb3ZlYWJsZS9ibG9iL21hc3Rlci9wYWNrYWdlcy9yZWFjdC1jb21wYXQtbW92ZWFibGVcbnZlcnNpb246IDAuMTYuMFxuKi9cbmltcG9ydCBnZXRBZ2VudCBmcm9tICdAZWdqcy9hZ2VudCc7XG5pbXBvcnQgeyBwcmVmaXhOYW1lcywgcmVmLCB3aXRoTWV0aG9kcywgcmVmcywgcHJlZml4Q1NTIH0gZnJvbSAnZnJhbWV3b3JrLXV0aWxzJztcbmltcG9ydCB7IHRocm90dGxlLCBoYXNDbGFzcywgZ2V0UmFkLCBpc0FycmF5LCBzcGxpdFNwYWNlLCB0aHJvdHRsZUFycmF5LCBjb252ZXJ0VW5pdFNpemUsIGlzU3RyaW5nLCBhdmVyYWdlLCBjYWxjdWxhdGVCb3VuZFNpemUsIGdldERpc3QgYXMgZ2V0RGlzdCQxLCBkb3QsIGFkZEV2ZW50LCBmaW5kSW5kZXgsIHJlcXVlc3RBbmltYXRpb25GcmFtZSwgcmVtb3ZlRXZlbnQsIGlzVW5kZWZpbmVkLCBnZXRTaGFwZURpcmVjdGlvbiwgYWRkQ2xhc3MsIHNwbGl0QnJhY2tldCwgc3BsaXRDb21tYSwgc3BsaXRVbml0LCBjYW5jZWxBbmltYXRpb25GcmFtZSwgZ2V0S2V5cywgaXNPYmplY3QsIGlzRnVuY3Rpb24sIFRJTllfTlVNIGFzIFRJTllfTlVNJDEsIHJlbW92ZUNsYXNzIH0gZnJvbSAnQGRheWJydXNoL3V0aWxzJztcbmltcG9ydCB7IGNyZWF0ZUlkZW50aXR5TWF0cml4LCBwbHVzLCBtaW51cywgY2FsY3VsYXRlLCBjb252ZXJ0UG9zaXRpb25NYXRyaXgsIGNvbnZlcnREaW1lbnNpb24sIGlnbm9yZURpbWVuc2lvbiwgaW52ZXJ0LCBjcmVhdGVXYXJwTWF0cml4LCBtdWx0aXBseSwgY29udmVydE1hdHJpeHRvQ1NTLCBjcmVhdGVPcmlnaW5NYXRyaXgsIG11bHRpcGxpZXMsIGZyb21UcmFuc2xhdGlvbiwgcm90YXRlLCBjcmVhdGVSb3RhdGVNYXRyaXgsIGNvbnZlcnRDU1N0b01hdHJpeCwgY3JlYXRlU2NhbGVNYXRyaXgsIGdldE9yaWdpbiB9IGZyb20gJ0BzY2VuYS9tYXRyaXgnO1xuaW1wb3J0IHsgdG9NYXQsIHBhcnNlLCBjYWxjdWxhdGVNYXRyaXhEaXN0LCBwYXJzZU1hdCB9IGZyb20gJ2Nzcy10by1tYXQnO1xuaW1wb3J0IENoaWxkcmVuRGlmZmVyLCB7IGRpZmYgfSBmcm9tICdAZWdqcy9jaGlsZHJlbi1kaWZmZXInO1xuaW1wb3J0IHsgZml0UG9pbnRzLCBnZXRPdmVybGFwU2l6ZSwgZ2V0QXJlYVNpemUsIGlzSW5zaWRlLCBnZXRNaW5NYXhzIH0gZnJvbSAnb3ZlcmxhcC1hcmVhJztcbmltcG9ydCBEcmFnU2Nyb2xsIGZyb20gJ0BzY2VuYS9kcmFnc2Nyb2xsJztcbmltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIFB1cmVDb21wb25lbnQgfSBmcm9tICdyZWFjdC1zaW1wbGUtY29tcGF0JztcbmltcG9ydCBHZXN0byBmcm9tICdnZXN0byc7XG5pbXBvcnQgc3R5bGVkIGZyb20gJ3JlYWN0LWNvbXBhdC1jc3Mtc3R5bGVkJztcblxuLypcbkNvcHlyaWdodCAoYykgMjAxOSBEYXlicnVzaFxubmFtZTogcmVhY3QtbW92ZWFibGVcbmxpY2Vuc2U6IE1JVFxuYXV0aG9yOiBEYXlicnVzaFxucmVwb3NpdG9yeTogaHR0cHM6Ly9naXRodWIuY29tL2RheWJydXNoL21vdmVhYmxlL2Jsb2IvbWFzdGVyL3BhY2thZ2VzL3JlYWN0LW1vdmVhYmxlXG52ZXJzaW9uOiAwLjMxLjBcbiovXG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwge1xuICAgIF9fcHJvdG9fXzogW11cbiAgfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZC5fX3Byb3RvX18gPSBiO1xuICB9IHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTtcbiAgfTtcblxuICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbn07XG5cbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XG4gIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblxuICBmdW5jdGlvbiBfXygpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yID0gZDtcbiAgfVxuXG4gIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn1cbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uICgpIHtcbiAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcbiAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgIHMgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHQ7XG4gIH07XG5cbiAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcbiAgdmFyIHQgPSB7fTtcblxuICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMCkgdFtwXSA9IHNbcF07XG5cbiAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKSBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKSB0W3BbaV1dID0gc1twW2ldXTtcbiAgfVxuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsXG4gICAgICBkO1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO2Vsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59XG5mdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XG4gIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59XG5cbmZ1bmN0aW9uIG1ha2VBYmxlKG5hbWUsIGFibGUpIHtcbiAgdmFyIF9hO1xuXG4gIHJldHVybiBfX2Fzc2lnbih7XG4gICAgZXZlbnRzOiB7fSxcbiAgICBwcm9wczogKF9hID0ge30sIF9hW25hbWVdID0gQm9vbGVhbiwgX2EpLFxuICAgIG5hbWU6IG5hbWVcbiAgfSwgYWJsZSk7XG59XG5cbmZ1bmN0aW9uIGdldFNWR0N1cnNvcihzY2FsZSwgZGVncmVlKSB7XG4gIHJldHVybiBcImRhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LDxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB3aWR0aD1cXFwiXCIgKyAzMiAqIHNjYWxlICsgXCJweFxcXCIgaGVpZ2h0PVxcXCJcIiArIDMyICogc2NhbGUgKyBcInB4XFxcIiB2aWV3Qm94PVxcXCIwIDAgMzIgMzJcXFwiID48cGF0aCBkPVxcXCJNIDE2LDUgTCAxMiwxMCBMIDE0LjUsMTAgTCAxNC41LDIyIEwgMTIsMjIgTCAxNiwyNyBMIDIwLDIyIEwgMTcuNSwyMiBMIDE3LjUsMTAgTCAyMCwgMTAgTCAxNiw1IFpcXFwiIHN0cm9rZS1saW5lam9pbj1cXFwicm91bmRcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4yXFxcIiBmaWxsPVxcXCJibGFja1xcXCIgc3Ryb2tlPVxcXCJ3aGl0ZVxcXCIgc3R5bGU9XFxcInRyYW5zZm9ybTpyb3RhdGUoXCIgKyBkZWdyZWUgKyBcImRlZyk7dHJhbnNmb3JtLW9yaWdpbjogMTZweCAxNnB4XFxcIj48L3BhdGg+PC9zdmc+XCI7XG59XG5cbmZ1bmN0aW9uIGdldEN1cnNvckNTUyhkZWdyZWUpIHtcbiAgdmFyIHgxID0gZ2V0U1ZHQ3Vyc29yKDEsIGRlZ3JlZSk7IC8vIGNvbnN0IHgyID0gZ2V0U1ZHQ3Vyc29yKDIsIGRlZ3JlZSk7XG5cbiAgdmFyIGRlZ3JlZTQ1ID0gTWF0aC5yb3VuZChkZWdyZWUgLyA0NSkgKiA0NSAlIDE4MDtcbiAgdmFyIGRlZmF1bHRDdXJzb3IgPSBcIm5zLXJlc2l6ZVwiO1xuXG4gIGlmIChkZWdyZWU0NSA9PT0gMTM1KSB7XG4gICAgZGVmYXVsdEN1cnNvciA9IFwibndzZS1yZXNpemVcIjtcbiAgfSBlbHNlIGlmIChkZWdyZWU0NSA9PT0gNDUpIHtcbiAgICBkZWZhdWx0Q3Vyc29yID0gXCJuZXN3LXJlc2l6ZVwiO1xuICB9IGVsc2UgaWYgKGRlZ3JlZTQ1ID09PSA5MCkge1xuICAgIGRlZmF1bHRDdXJzb3IgPSBcImV3LXJlc2l6ZVwiO1xuICB9IC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbWF4LWxpbmUtbGVuZ3RoXG5cblxuICByZXR1cm4gXCJjdXJzb3I6XCIgKyBkZWZhdWx0Q3Vyc29yICsgXCI7Y3Vyc29yOiB1cmwoJ1wiICsgeDEgKyBcIicpIDE2IDE2LCBcIiArIGRlZmF1bHRDdXJzb3IgKyBcIjtcIjtcbn1cblxudmFyIGFnZW50ID0gZ2V0QWdlbnQoKTtcbnZhciBJU19XRUJLSVQgPSBhZ2VudC5icm93c2VyLndlYmtpdDtcbnZhciBJU19XRUJLSVQ2MDUgPSBJU19XRUJLSVQgJiYgZnVuY3Rpb24gKCkge1xuICB2YXIgbmF2aSA9IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgPyB7XG4gICAgdXNlckFnZW50OiBcIlwiXG4gIH0gOiB3aW5kb3cubmF2aWdhdG9yO1xuICB2YXIgcmVzID0gL2FwcGxld2Via2l0XFwvKFteXFxzXSspL2cuZXhlYyhuYXZpLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKTtcbiAgcmV0dXJuIHJlcyA/IHBhcnNlRmxvYXQocmVzWzFdKSA8IDYwNSA6IGZhbHNlO1xufSgpO1xudmFyIFBSRUZJWCA9IFwibW92ZWFibGUtXCI7XG52YXIgTU9WRUFCTEVfQ1NTID0gXCJcXG57XFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcblxcdHdpZHRoOiAxcHg7XFxuXFx0aGVpZ2h0OiAxcHg7XFxuXFx0bGVmdDogMDtcXG5cXHR0b3A6IDA7XFxuICAgIHotaW5kZXg6IDMwMDA7XFxuICAgIC0tbW92ZWFibGUtY29sb3I6ICM0YWY7XFxuICAgIC0tem9vbTogMTtcXG4gICAgLS16b29tcHg6IDFweDtcXG4gICAgd2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTtcXG59XFxuLmNvbnRyb2wtYm94IHtcXG4gICAgei1pbmRleDogMDtcXG59XFxuLmxpbmUsIC5jb250cm9sIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcblxcdGxlZnQ6IDA7XFxuICAgIHRvcDogMDtcXG4gICAgd2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTtcXG59XFxuLmNvbnRyb2wge1xcblxcdHdpZHRoOiAxNHB4O1xcblxcdGhlaWdodDogMTRweDtcXG5cXHRib3JkZXItcmFkaXVzOiA1MCU7XFxuXFx0Ym9yZGVyOiAycHggc29saWQgI2ZmZjtcXG5cXHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICBiYWNrZ3JvdW5kOiAjNGFmO1xcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1tb3ZlYWJsZS1jb2xvcik7XFxuXFx0bWFyZ2luLXRvcDogLTdweDtcXG4gICAgbWFyZ2luLWxlZnQ6IC03cHg7XFxuICAgIGJvcmRlcjogMnB4IHNvbGlkICNmZmY7XFxuICAgIHotaW5kZXg6IDEwO1xcbn1cXG4ucGFkZGluZyB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiAwcHg7XFxuICAgIGxlZnQ6IDBweDtcXG4gICAgd2lkdGg6IDEwMHB4O1xcbiAgICBoZWlnaHQ6IDEwMHB4O1xcbiAgICB0cmFuc2Zvcm0tb3JpZ2luOiAwIDA7XFxufVxcbi5saW5lIHtcXG5cXHR3aWR0aDogMXB4O1xcbiAgICBoZWlnaHQ6IDFweDtcXG4gICAgYmFja2dyb3VuZDogIzRhZjtcXG4gICAgYmFja2dyb3VuZDogdmFyKC0tbW92ZWFibGUtY29sb3IpO1xcblxcdHRyYW5zZm9ybS1vcmlnaW46IDBweCA1MCU7XFxufVxcbi5saW5lLmRhc2hlZCB7XFxuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcbn1cXG4ubGluZS5kYXNoZWQuaG9yaXpvbnRhbCB7XFxuICAgIGJvcmRlci10b3A6IDFweCBkYXNoZWQgIzRhZjtcXG4gICAgYm9yZGVyLXRvcC1jb2xvcjogIzRhZjtcXG4gICAgYm9yZGVyLXRvcC1jb2xvcjogdmFyKC0tbW92ZWFibGUtY29sb3IpO1xcbn1cXG4ubGluZS5kYXNoZWQudmVydGljYWwge1xcbiAgICBib3JkZXItbGVmdDogMXB4IGRhc2hlZCAjNGFmO1xcbiAgICBib3JkZXItbGVmdC1jb2xvcjogIzRhZjtcXG4gICAgYm9yZGVyLWxlZnQtY29sb3I6IHZhcigtLW1vdmVhYmxlLWNvbG9yKTtcXG59XFxuLmxpbmUudmVydGljYWwge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSk7XFxufVxcbi5saW5lLmhvcml6b250YWwge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTUwJSk7XFxufVxcbi5saW5lLnZlcnRpY2FsLmJvbGQge1xcbiAgICB3aWR0aDogMnB4O1xcbn1cXG4ubGluZS5ob3Jpem9udGFsLmJvbGQge1xcbiAgICBoZWlnaHQ6IDJweDtcXG59XFxuXFxuLmNvbnRyb2wub3JpZ2luIHtcXG5cXHRib3JkZXItY29sb3I6ICNmNTU7XFxuXFx0YmFja2dyb3VuZDogI2ZmZjtcXG5cXHR3aWR0aDogMTJweDtcXG5cXHRoZWlnaHQ6IDEycHg7XFxuXFx0bWFyZ2luLXRvcDogLTZweDtcXG4gICAgbWFyZ2luLWxlZnQ6IC02cHg7XFxuXFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XFxufVxcblwiICsgWzAsIDE1LCAzMCwgNDUsIDYwLCA3NSwgOTAsIDEwNSwgMTIwLCAxMzUsIDE1MCwgMTY1XS5tYXAoZnVuY3Rpb24gKGRlZ3JlZSkge1xuICByZXR1cm4gXCJcXG4uZGlyZWN0aW9uW2RhdGEtcm90YXRpb249XFxcIlwiICsgZGVncmVlICsgXCJcXFwiXSB7XFxuXFx0XCIgKyBnZXRDdXJzb3JDU1MoZGVncmVlKSArIFwiXFxufVxcblwiO1xufSkuam9pbihcIlxcblwiKSArIFwiXFxuLmdyb3VwIHtcXG4gICAgei1pbmRleDogLTE7XFxufVxcbi5hcmVhIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbn1cXG4uYXJlYS1waWVjZXMge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogMDtcXG4gICAgbGVmdDogMDtcXG4gICAgZGlzcGxheTogbm9uZTtcXG59XFxuLmFyZWEuYXZvaWQsIC5hcmVhLnBhc3Mge1xcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG59XFxuLmFyZWEuYXZvaWQrLmFyZWEtcGllY2VzIHtcXG4gICAgZGlzcGxheTogYmxvY2s7XFxufVxcbi5hcmVhLXBpZWNlIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbn1cXG5cXG5cIiArIChJU19XRUJLSVQ2MDUgPyBcIjpnbG9iYWwgc3ZnICo6YmVmb3JlIHtcXG5cXHRjb250ZW50OlxcXCJcXFwiO1xcblxcdHRyYW5zZm9ybS1vcmlnaW46IGluaGVyaXQ7XFxufVwiIDogXCJcIikgKyBcIlxcblwiO1xudmFyIE5FQVJCWV9QT1MgPSBbWzAsIDEsIDJdLCBbMSwgMCwgM10sIFsyLCAwLCAzXSwgWzMsIDEsIDJdXTtcbnZhciBGTE9BVF9QT0lOVF9OVU0gPSAwLjAwMDE7XG52YXIgVElOWV9OVU0gPSAwLjAwMDAwMDE7XG52YXIgTUlOX1NDQUxFID0gMC4wMDAwMDAwMDE7XG52YXIgTUFYX05VTSA9IE1hdGgucG93KDEwLCAxMCk7XG52YXIgTUlOX05VTSA9IC1NQVhfTlVNO1xudmFyIERJUkVDVElPTlMgPSBbXCJuXCIsIFwid1wiLCBcInNcIiwgXCJlXCIsIFwibndcIiwgXCJuZVwiLCBcInN3XCIsIFwic2VcIl07XG52YXIgRElSRUNUSU9OX0lOREVYRVMgPSB7XG4gIG46IFswLCAxXSxcbiAgczogWzIsIDNdLFxuICB3OiBbMiwgMF0sXG4gIGU6IFsxLCAzXSxcbiAgbnc6IFswXSxcbiAgbmU6IFsxXSxcbiAgc3c6IFsyXSxcbiAgc2U6IFszXVxufTtcbnZhciBESVJFQ1RJT05fUk9UQVRJT05TID0ge1xuICBuOiAwLFxuICBzOiAxODAsXG4gIHc6IDI3MCxcbiAgZTogOTAsXG4gIG53OiAzMTUsXG4gIG5lOiA0NSxcbiAgc3c6IDIyNSxcbiAgc2U6IDEzNVxufTtcbnZhciBNT1ZFQUJMRV9NRVRIT0RTID0gW1wiaXNNb3ZlYWJsZUVsZW1lbnRcIiwgXCJ1cGRhdGVSZWN0XCIsIFwidXBkYXRlVGFyZ2V0XCIsIFwiZGVzdHJveVwiLCBcImRyYWdTdGFydFwiLCBcImlzSW5zaWRlXCIsIFwiaGl0VGVzdFwiLCBcInNldFN0YXRlXCIsIFwiZ2V0UmVjdFwiLCBcInJlcXVlc3RcIiwgXCJpc0RyYWdnaW5nXCIsIFwiZ2V0TWFuYWdlclwiLCBcImZvcmNlVXBkYXRlXCJdO1xuXG5mdW5jdGlvbiBtdWx0aXBseTIocG9zMSwgcG9zMikge1xuICByZXR1cm4gW3BvczFbMF0gKiBwb3MyWzBdLCBwb3MxWzFdICogcG9zMlsxXV07XG59XG5mdW5jdGlvbiBwcmVmaXgoKSB7XG4gIHZhciBjbGFzc05hbWVzID0gW107XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICBjbGFzc05hbWVzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gIH1cblxuICByZXR1cm4gcHJlZml4TmFtZXMuYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFtQUkVGSVhdLCBjbGFzc05hbWVzKSk7XG59XG5mdW5jdGlvbiBnZXRUcmFuc2Zvcm1NYXRyaXgodHJhbnNmb3JtKSB7XG4gIGlmICghdHJhbnNmb3JtIHx8IHRyYW5zZm9ybSA9PT0gXCJub25lXCIpIHtcbiAgICByZXR1cm4gWzEsIDAsIDAsIDEsIDAsIDBdO1xuICB9XG5cbiAgaWYgKGlzT2JqZWN0KHRyYW5zZm9ybSkpIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtO1xuICB9XG5cbiAgdmFyIHZhbHVlID0gc3BsaXRCcmFja2V0KHRyYW5zZm9ybSkudmFsdWU7XG4gIHJldHVybiB2YWx1ZS5zcGxpdCgvcyosXFxzKi9nKS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh2KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRBYnNvbHV0ZU1hdHJpeChtYXRyaXgsIG4sIG9yaWdpbikge1xuICByZXR1cm4gbXVsdGlwbGllcyhuLCBjcmVhdGVPcmlnaW5NYXRyaXgob3JpZ2luLCBuKSwgbWF0cml4LCBjcmVhdGVPcmlnaW5NYXRyaXgob3JpZ2luLm1hcChmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAtYTtcbiAgfSksIG4pKTtcbn1cbmZ1bmN0aW9uIG1lYXN1cmVTVkdTaXplKGVsLCB1bml0LCBpc0hvcml6b250YWwpIHtcbiAgaWYgKHVuaXQgPT09IFwiJVwiKSB7XG4gICAgdmFyIHZpZXdCb3ggPSBnZXRTVkdWaWV3Qm94KGVsLm93bmVyU1ZHRWxlbWVudCk7XG4gICAgcmV0dXJuIHZpZXdCb3hbaXNIb3Jpem9udGFsID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIl0gLyAxMDA7XG4gIH1cblxuICByZXR1cm4gMTtcbn1cbmZ1bmN0aW9uIGdldEJlZm9yZVRyYW5zZm9ybU9yaWdpbihlbCkge1xuICB2YXIgcmVsYXRpdmVPcmlnaW4gPSBnZXRUcmFuc2Zvcm1PcmlnaW4oZ2V0Q29tcHV0ZWRTdHlsZShlbCwgXCI6YmVmb3JlXCIpKTtcbiAgcmV0dXJuIHJlbGF0aXZlT3JpZ2luLm1hcChmdW5jdGlvbiAobywgaSkge1xuICAgIHZhciBfYSA9IHNwbGl0VW5pdChvKSxcbiAgICAgICAgdmFsdWUgPSBfYS52YWx1ZSxcbiAgICAgICAgdW5pdCA9IF9hLnVuaXQ7XG5cbiAgICByZXR1cm4gdmFsdWUgKiBtZWFzdXJlU1ZHU2l6ZShlbCwgdW5pdCwgaSA9PT0gMCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0VHJhbnNmb3JtT3JpZ2luKHN0eWxlKSB7XG4gIHZhciB0cmFuc2Zvcm1PcmlnaW4gPSBzdHlsZS50cmFuc2Zvcm1PcmlnaW47XG4gIHJldHVybiB0cmFuc2Zvcm1PcmlnaW4gPyB0cmFuc2Zvcm1PcmlnaW4uc3BsaXQoXCIgXCIpIDogW1wiMFwiLCBcIjBcIl07XG59XG5mdW5jdGlvbiBnZXRPZmZzZXRJbmZvKGVsLCBsYXN0UGFyZW50LCBpc1BhcmVudCkge1xuICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gIHZhciB0YXJnZXQgPSAhZWwgfHwgaXNQYXJlbnQgPyBlbCA6IGVsLnBhcmVudEVsZW1lbnQ7XG4gIHZhciBpc0VuZCA9IGVsID09PSBsYXN0UGFyZW50IHx8IHRhcmdldCA9PT0gbGFzdFBhcmVudDtcbiAgdmFyIHBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuXG4gIHdoaWxlICh0YXJnZXQgJiYgdGFyZ2V0ICE9PSBib2R5KSB7XG4gICAgaWYgKGxhc3RQYXJlbnQgPT09IHRhcmdldCkge1xuICAgICAgaXNFbmQgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KTtcbiAgICB2YXIgdHJhbnNmb3JtID0gc3R5bGUudHJhbnNmb3JtO1xuICAgIHBvc2l0aW9uID0gc3R5bGUucG9zaXRpb247XG5cbiAgICBpZiAodGFyZ2V0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJzdmdcIiB8fCBwb3NpdGlvbiAhPT0gXCJzdGF0aWNcIiB8fCB0cmFuc2Zvcm0gJiYgdHJhbnNmb3JtICE9PSBcIm5vbmVcIikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudEVsZW1lbnQ7XG4gICAgcG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGlzU3RhdGljOiBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIixcbiAgICBpc0VuZDogaXNFbmQgfHwgIXRhcmdldCB8fCB0YXJnZXQgPT09IGJvZHksXG4gICAgb2Zmc2V0UGFyZW50OiB0YXJnZXQgfHwgYm9keVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0T2Zmc2V0UG9zSW5mbyhlbCwgY29udGFpbmVyLCBzdHlsZSwgaXNGaXhlZCkge1xuICB2YXIgX2E7XG5cbiAgdmFyIHRhZ05hbWUgPSBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHZhciBvZmZzZXRMZWZ0ID0gZWwub2Zmc2V0TGVmdDtcbiAgdmFyIG9mZnNldFRvcCA9IGVsLm9mZnNldFRvcDtcblxuICBpZiAoaXNGaXhlZCkge1xuICAgIHZhciBjb250YWluZXJDbGllbnRSZWN0ID0gKGNvbnRhaW5lciB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIG9mZnNldExlZnQgLT0gY29udGFpbmVyQ2xpZW50UmVjdC5sZWZ0O1xuICAgIG9mZnNldFRvcCAtPSBjb250YWluZXJDbGllbnRSZWN0LnRvcDtcbiAgfSAvLyBzdmdcblxuXG4gIHZhciBpc1NWRyA9IGlzVW5kZWZpbmVkKG9mZnNldExlZnQpO1xuICB2YXIgaGFzT2Zmc2V0ID0gIWlzU1ZHO1xuICB2YXIgb3JpZ2luO1xuICB2YXIgdGFyZ2V0T3JpZ2luOyAvLyBpbm5lciBzdmcgZWxlbWVudFxuXG4gIGlmICghaGFzT2Zmc2V0ICYmIHRhZ05hbWUgIT09IFwic3ZnXCIpIHtcbiAgICBvcmlnaW4gPSBJU19XRUJLSVQ2MDUgPyBnZXRCZWZvcmVUcmFuc2Zvcm1PcmlnaW4oZWwpIDogZ2V0VHJhbnNmb3JtT3JpZ2luKHN0eWxlKS5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQocG9zKTtcbiAgICB9KTtcbiAgICB0YXJnZXRPcmlnaW4gPSBvcmlnaW4uc2xpY2UoKTtcbiAgICBoYXNPZmZzZXQgPSB0cnVlO1xuICAgIF9hID0gZ2V0U1ZHR3JhcGhpY3NPZmZzZXQoZWwsIG9yaWdpbiksIG9mZnNldExlZnQgPSBfYVswXSwgb2Zmc2V0VG9wID0gX2FbMV0sIG9yaWdpblswXSA9IF9hWzJdLCBvcmlnaW5bMV0gPSBfYVszXTtcbiAgfSBlbHNlIHtcbiAgICBvcmlnaW4gPSBnZXRUcmFuc2Zvcm1PcmlnaW4oc3R5bGUpLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdChwb3MpO1xuICAgIH0pO1xuICAgIHRhcmdldE9yaWdpbiA9IG9yaWdpbi5zbGljZSgpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0YWdOYW1lOiB0YWdOYW1lLFxuICAgIGlzU1ZHOiBpc1NWRyxcbiAgICBoYXNPZmZzZXQ6IGhhc09mZnNldCxcbiAgICBvZmZzZXQ6IFtvZmZzZXRMZWZ0IHx8IDAsIG9mZnNldFRvcCB8fCAwXSxcbiAgICBvcmlnaW46IG9yaWdpbixcbiAgICB0YXJnZXRPcmlnaW46IHRhcmdldE9yaWdpblxuICB9O1xufVxuZnVuY3Rpb24gZ2V0Qm9keU9mZnNldChlbCwgaXNTVkcsIHN0eWxlKSB7XG4gIGlmIChzdHlsZSA9PT0gdm9pZCAwKSB7XG4gICAgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgfVxuXG4gIHZhciBib2R5U3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmJvZHkpO1xuICB2YXIgYm9keVBvc2l0aW9uID0gYm9keVN0eWxlLnBvc2l0aW9uO1xuXG4gIGlmICghaXNTVkcgJiYgKCFib2R5UG9zaXRpb24gfHwgYm9keVBvc2l0aW9uID09PSBcInN0YXRpY1wiKSkge1xuICAgIHJldHVybiBbMCwgMF07XG4gIH1cblxuICB2YXIgbWFyZ2luTGVmdCA9IHBhcnNlSW50KGJvZHlTdHlsZS5tYXJnaW5MZWZ0LCAxMCk7XG4gIHZhciBtYXJnaW5Ub3AgPSBwYXJzZUludChib2R5U3R5bGUubWFyZ2luVG9wLCAxMCk7XG5cbiAgaWYgKHN0eWxlLnBvc2l0aW9uID09PSBcImFic29sdXRlXCIpIHtcbiAgICBpZiAoc3R5bGUudG9wICE9PSBcImF1dG9cIiB8fCBzdHlsZS5ib3R0b20gIT09IFwiYXV0b1wiKSB7XG4gICAgICBtYXJnaW5Ub3AgPSAwO1xuICAgIH1cblxuICAgIGlmIChzdHlsZS5sZWZ0ICE9PSBcImF1dG9cIiB8fCBzdHlsZS5yaWdodCAhPT0gXCJhdXRvXCIpIHtcbiAgICAgIG1hcmdpbkxlZnQgPSAwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbbWFyZ2luTGVmdCwgbWFyZ2luVG9wXTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnQzRE1hdHJpeGVzKG1hdHJpeGVzKSB7XG4gIG1hdHJpeGVzLmZvckVhY2goZnVuY3Rpb24gKGluZm8pIHtcbiAgICB2YXIgbWF0cml4ID0gaW5mby5tYXRyaXg7XG5cbiAgICBpZiAobWF0cml4KSB7XG4gICAgICBpbmZvLm1hdHJpeCA9IGNvbnZlcnREaW1lbnNpb24obWF0cml4LCAzLCA0KTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0TWF0cml4U3RhY2tJbmZvKHRhcmdldCwgY29udGFpbmVyLCBjaGVja0NvbnRhaW5lcikge1xuICB2YXIgZWwgPSB0YXJnZXQ7XG4gIHZhciBtYXRyaXhlcyA9IFtdO1xuICB2YXIgcmVxdWVzdEVuZCA9ICFjaGVja0NvbnRhaW5lciAmJiB0YXJnZXQgPT09IGNvbnRhaW5lcjtcbiAgdmFyIGlzRW5kID0gcmVxdWVzdEVuZDtcbiAgdmFyIGlzM2QgPSBmYWxzZTtcbiAgdmFyIG4gPSAzO1xuICB2YXIgdHJhbnNmb3JtT3JpZ2luO1xuICB2YXIgdGFyZ2V0VHJhbnNmb3JtT3JpZ2luO1xuICB2YXIgdGFyZ2V0TWF0cml4O1xuICB2YXIgb2Zmc2V0Q29udGFpbmVyID0gZ2V0T2Zmc2V0SW5mbyhjb250YWluZXIsIGNvbnRhaW5lciwgdHJ1ZSkub2Zmc2V0UGFyZW50O1xuXG4gIHdoaWxlIChlbCAmJiAhaXNFbmQpIHtcbiAgICBpc0VuZCA9IHJlcXVlc3RFbmQ7XG4gICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgdmFyIHBvc2l0aW9uID0gc3R5bGUucG9zaXRpb247XG4gICAgdmFyIGlzRml4ZWQgPSBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiO1xuICAgIHZhciBtYXRyaXggPSBjb252ZXJ0Q1NTdG9NYXRyaXgoZ2V0VHJhbnNmb3JtTWF0cml4KHN0eWxlLnRyYW5zZm9ybSkpOyAvLyBjb252ZXJ0IDMgdG8gNFxuXG4gICAgdmFyIGxlbmd0aCA9IG1hdHJpeC5sZW5ndGg7XG5cbiAgICBpZiAoIWlzM2QgJiYgbGVuZ3RoID09PSAxNikge1xuICAgICAgaXMzZCA9IHRydWU7XG4gICAgICBuID0gNDtcbiAgICAgIGNvbnZlcnQzRE1hdHJpeGVzKG1hdHJpeGVzKTtcblxuICAgICAgaWYgKHRhcmdldE1hdHJpeCkge1xuICAgICAgICB0YXJnZXRNYXRyaXggPSBjb252ZXJ0RGltZW5zaW9uKHRhcmdldE1hdHJpeCwgMywgNCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzM2QgJiYgbGVuZ3RoID09PSA5KSB7XG4gICAgICBtYXRyaXggPSBjb252ZXJ0RGltZW5zaW9uKG1hdHJpeCwgMywgNCk7XG4gICAgfVxuXG4gICAgdmFyIF9hID0gZ2V0T2Zmc2V0UG9zSW5mbyhlbCwgY29udGFpbmVyLCBzdHlsZSwgaXNGaXhlZCksXG4gICAgICAgIHRhZ05hbWUgPSBfYS50YWdOYW1lLFxuICAgICAgICBoYXNPZmZzZXQgPSBfYS5oYXNPZmZzZXQsXG4gICAgICAgIGlzU1ZHID0gX2EuaXNTVkcsXG4gICAgICAgIG9yaWdpbiA9IF9hLm9yaWdpbixcbiAgICAgICAgdGFyZ2V0T3JpZ2luID0gX2EudGFyZ2V0T3JpZ2luLFxuICAgICAgICBvZmZzZXRQb3MgPSBfYS5vZmZzZXQ7XG5cbiAgICB2YXIgb2Zmc2V0TGVmdCA9IG9mZnNldFBvc1swXSxcbiAgICAgICAgb2Zmc2V0VG9wID0gb2Zmc2V0UG9zWzFdO1xuXG4gICAgaWYgKHRhZ05hbWUgPT09IFwic3ZnXCIgJiYgdGFyZ2V0TWF0cml4KSB7XG4gICAgICAvLyBzY2FsZSBtYXRyaXggZm9yIHN2ZydzIFNWR0VsZW1lbnRzLlxuICAgICAgbWF0cml4ZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwidGFyZ2V0XCIsXG4gICAgICAgIHRhcmdldDogZWwsXG4gICAgICAgIG1hdHJpeDogZ2V0U1ZHTWF0cml4KGVsLCBuKVxuICAgICAgfSk7XG4gICAgICBtYXRyaXhlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJvZmZzZXRcIixcbiAgICAgICAgdGFyZ2V0OiBlbCxcbiAgICAgICAgbWF0cml4OiBjcmVhdGVJZGVudGl0eU1hdHJpeChuKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0YWdOYW1lID09PSBcImdcIiAmJiB0YXJnZXQgIT09IGVsKSB7XG4gICAgICBvZmZzZXRMZWZ0ID0gMDtcbiAgICAgIG9mZnNldFRvcCA9IDA7XG4gICAgfVxuXG4gICAgdmFyIF9iID0gZ2V0T2Zmc2V0SW5mbyhlbCwgY29udGFpbmVyKSxcbiAgICAgICAgb2Zmc2V0UGFyZW50ID0gX2Iub2Zmc2V0UGFyZW50LFxuICAgICAgICBpc09mZnNldEVuZCA9IF9iLmlzRW5kLFxuICAgICAgICBpc1N0YXRpYyA9IF9iLmlzU3RhdGljO1xuXG4gICAgaWYgKElTX1dFQktJVCAmJiBoYXNPZmZzZXQgJiYgIWlzU1ZHICYmIGlzU3RhdGljICYmIChwb3NpdGlvbiA9PT0gXCJyZWxhdGl2ZVwiIHx8IHBvc2l0aW9uID09PSBcInN0YXRpY1wiKSkge1xuICAgICAgb2Zmc2V0TGVmdCAtPSBvZmZzZXRQYXJlbnQub2Zmc2V0TGVmdDtcbiAgICAgIG9mZnNldFRvcCAtPSBvZmZzZXRQYXJlbnQub2Zmc2V0VG9wO1xuICAgICAgcmVxdWVzdEVuZCA9IHJlcXVlc3RFbmQgfHwgaXNPZmZzZXRFbmQ7XG4gICAgfVxuXG4gICAgdmFyIHBhcmVudENsaWVudExlZnQgPSAwO1xuICAgIHZhciBwYXJlbnRDbGllbnRUb3AgPSAwO1xuXG4gICAgaWYgKGhhc09mZnNldCAmJiBvZmZzZXRDb250YWluZXIgIT09IG9mZnNldFBhcmVudCkge1xuICAgICAgLy8gYm9yZGVyXG4gICAgICBwYXJlbnRDbGllbnRMZWZ0ID0gb2Zmc2V0UGFyZW50LmNsaWVudExlZnQ7XG4gICAgICBwYXJlbnRDbGllbnRUb3AgPSBvZmZzZXRQYXJlbnQuY2xpZW50VG9wO1xuICAgIH1cblxuICAgIGlmIChoYXNPZmZzZXQgJiYgb2Zmc2V0UGFyZW50ID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICB2YXIgbWFyZ2luID0gZ2V0Qm9keU9mZnNldChlbCwgZmFsc2UsIHN0eWxlKTtcbiAgICAgIG9mZnNldExlZnQgKz0gbWFyZ2luWzBdO1xuICAgICAgb2Zmc2V0VG9wICs9IG1hcmdpblsxXTtcbiAgICB9XG5cbiAgICBtYXRyaXhlcy5wdXNoKHtcbiAgICAgIHR5cGU6IFwidGFyZ2V0XCIsXG4gICAgICB0YXJnZXQ6IGVsLFxuICAgICAgbWF0cml4OiBnZXRBYnNvbHV0ZU1hdHJpeChtYXRyaXgsIG4sIG9yaWdpbilcbiAgICB9KTtcblxuICAgIGlmIChoYXNPZmZzZXQpIHtcbiAgICAgIG1hdHJpeGVzLnB1c2goe1xuICAgICAgICB0eXBlOiBcIm9mZnNldFwiLFxuICAgICAgICB0YXJnZXQ6IGVsLFxuICAgICAgICBtYXRyaXg6IGNyZWF0ZU9yaWdpbk1hdHJpeChbb2Zmc2V0TGVmdCAtIGVsLnNjcm9sbExlZnQgKyBwYXJlbnRDbGllbnRMZWZ0LCBvZmZzZXRUb3AgLSBlbC5zY3JvbGxUb3AgKyBwYXJlbnRDbGllbnRUb3BdLCBuKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHN2Z1xuICAgICAgbWF0cml4ZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwib2Zmc2V0XCIsXG4gICAgICAgIHRhcmdldDogZWwsXG4gICAgICAgIG9yaWdpbjogb3JpZ2luXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIXRhcmdldE1hdHJpeCkge1xuICAgICAgdGFyZ2V0TWF0cml4ID0gbWF0cml4O1xuICAgIH1cblxuICAgIGlmICghdHJhbnNmb3JtT3JpZ2luKSB7XG4gICAgICB0cmFuc2Zvcm1PcmlnaW4gPSBvcmlnaW47XG4gICAgfVxuXG4gICAgaWYgKCF0YXJnZXRUcmFuc2Zvcm1PcmlnaW4pIHtcbiAgICAgIHRhcmdldFRyYW5zZm9ybU9yaWdpbiA9IHRhcmdldE9yaWdpbjtcbiAgICB9XG5cbiAgICBpZiAoaXNFbmQgfHwgaXNGaXhlZCkge1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsID0gb2Zmc2V0UGFyZW50O1xuICAgICAgcmVxdWVzdEVuZCA9IGlzT2Zmc2V0RW5kO1xuICAgIH1cblxuICAgIGlmICghY2hlY2tDb250YWluZXIgfHwgZWwgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgIGlzRW5kID0gcmVxdWVzdEVuZDtcbiAgICB9XG4gIH1cblxuICBpZiAoIXRhcmdldE1hdHJpeCkge1xuICAgIHRhcmdldE1hdHJpeCA9IGNyZWF0ZUlkZW50aXR5TWF0cml4KG4pO1xuICB9XG5cbiAgaWYgKCF0cmFuc2Zvcm1PcmlnaW4pIHtcbiAgICB0cmFuc2Zvcm1PcmlnaW4gPSBbMCwgMF07XG4gIH1cblxuICBpZiAoIXRhcmdldFRyYW5zZm9ybU9yaWdpbikge1xuICAgIHRhcmdldFRyYW5zZm9ybU9yaWdpbiA9IFswLCAwXTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgb2Zmc2V0Q29udGFpbmVyOiBvZmZzZXRDb250YWluZXIsXG4gICAgbWF0cml4ZXM6IG1hdHJpeGVzLFxuICAgIHRhcmdldE1hdHJpeDogdGFyZ2V0TWF0cml4LFxuICAgIHRyYW5zZm9ybU9yaWdpbjogdHJhbnNmb3JtT3JpZ2luLFxuICAgIHRhcmdldE9yaWdpbjogdGFyZ2V0VHJhbnNmb3JtT3JpZ2luLFxuICAgIGlzM2Q6IGlzM2RcbiAgfTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZUVsZW1lbnRJbmZvKHRhcmdldCwgY29udGFpbmVyLCByb290Q29udGFpbmVyLCBpc0Fic29sdXRlM2QpIHtcbiAgdmFyIF9hO1xuXG4gIGlmIChyb290Q29udGFpbmVyID09PSB2b2lkIDApIHtcbiAgICByb290Q29udGFpbmVyID0gY29udGFpbmVyO1xuICB9XG5cbiAgdmFyIHdpZHRoID0gMDtcbiAgdmFyIGhlaWdodCA9IDA7XG4gIHZhciByb3RhdGlvbiA9IDA7XG4gIHZhciBhbGxSZXN1bHQgPSB7fTtcblxuICBpZiAodGFyZ2V0KSB7XG4gICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpO1xuICAgIHdpZHRoID0gdGFyZ2V0Lm9mZnNldFdpZHRoO1xuICAgIGhlaWdodCA9IHRhcmdldC5vZmZzZXRIZWlnaHQ7XG5cbiAgICBpZiAoaXNVbmRlZmluZWQod2lkdGgpKSB7XG4gICAgICBfYSA9IGdldFNpemUodGFyZ2V0LCBzdHlsZSwgdHJ1ZSksIHdpZHRoID0gX2FbMF0sIGhlaWdodCA9IF9hWzFdO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0YXJnZXQpIHtcbiAgICB2YXIgcmVzdWx0ID0gY2FsY3VsYXRlTWF0cml4U3RhY2sodGFyZ2V0LCBjb250YWluZXIsIHJvb3RDb250YWluZXIsIGlzQWJzb2x1dGUzZCk7XG4gICAgdmFyIHBvc2l0aW9uID0gY2FsY3VsYXRlTW92ZWFibGVQb3NpdGlvbihyZXN1bHQuYWxsTWF0cml4LCByZXN1bHQudHJhbnNmb3JtT3JpZ2luLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBhbGxSZXN1bHQgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcmVzdWx0KSwgcG9zaXRpb24pO1xuICAgIHZhciByb3RhdGlvblBvc2l0aW9uID0gY2FsY3VsYXRlTW92ZWFibGVQb3NpdGlvbihyZXN1bHQuYWxsTWF0cml4LCBbNTAsIDUwXSwgMTAwLCAxMDApO1xuICAgIHJvdGF0aW9uID0gZ2V0Um90YXRpb25SYWQoW3JvdGF0aW9uUG9zaXRpb24ucG9zMSwgcm90YXRpb25Qb3NpdGlvbi5wb3MyXSwgcm90YXRpb25Qb3NpdGlvbi5kaXJlY3Rpb24pO1xuICB9XG5cbiAgdmFyIG4gPSBpc0Fic29sdXRlM2QgPyA0IDogMztcbiAgcmV0dXJuIF9fYXNzaWduKHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgcm90YXRpb246IHJvdGF0aW9uLFxuICAgIC8vIHJvb3RNYXRyaXg6IG51bWJlcltdO1xuICAgIC8vIGJlZm9yZU1hdHJpeDogbnVtYmVyW107XG4gICAgLy8gb2Zmc2V0TWF0cml4OiBudW1iZXJbXTtcbiAgICAvLyBhbGxNYXRyaXg6IG51bWJlcltdO1xuICAgIC8vIHRhcmdldE1hdHJpeDogbnVtYmVyW107XG4gICAgLy8gdGFyZ2V0VHJhbnNmb3JtOiBzdHJpbmc7XG4gICAgLy8gdHJhbnNmb3JtT3JpZ2luOiBudW1iZXJbXTtcbiAgICAvLyB0YXJnZXRPcmlnaW46IG51bWJlcltdO1xuICAgIC8vIGlzM2Q6IGJvb2xlYW47XG4gICAgcm9vdE1hdHJpeDogY3JlYXRlSWRlbnRpdHlNYXRyaXgobiksXG4gICAgYmVmb3JlTWF0cml4OiBjcmVhdGVJZGVudGl0eU1hdHJpeChuKSxcbiAgICBvZmZzZXRNYXRyaXg6IGNyZWF0ZUlkZW50aXR5TWF0cml4KG4pLFxuICAgIGFsbE1hdHJpeDogY3JlYXRlSWRlbnRpdHlNYXRyaXgobiksXG4gICAgdGFyZ2V0TWF0cml4OiBjcmVhdGVJZGVudGl0eU1hdHJpeChuKSxcbiAgICB0YXJnZXRUcmFuc2Zvcm06IFwiXCIsXG4gICAgdHJhbnNmb3JtT3JpZ2luOiBbMCwgMF0sXG4gICAgdGFyZ2V0T3JpZ2luOiBbMCwgMF0sXG4gICAgaXMzZDogISFpc0Fic29sdXRlM2QsXG4gICAgLy8gbGVmdDogbnVtYmVyO1xuICAgIC8vIHRvcDogbnVtYmVyO1xuICAgIC8vIHJpZ2h0OiBudW1iZXI7XG4gICAgLy8gYm90dG9tOiBudW1iZXI7XG4gICAgLy8gb3JpZ2luOiBudW1iZXJbXTtcbiAgICAvLyBwb3MxOiBudW1iZXJbXTtcbiAgICAvLyBwb3MyOiBudW1iZXJbXTtcbiAgICAvLyBwb3MzOiBudW1iZXJbXTtcbiAgICAvLyBwb3M0OiBudW1iZXJbXTtcbiAgICAvLyBkaXJlY3Rpb246IDEgfCAtMTtcbiAgICBsZWZ0OiAwLFxuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgb3JpZ2luOiBbMCwgMF0sXG4gICAgcG9zMTogWzAsIDBdLFxuICAgIHBvczI6IFswLCAwXSxcbiAgICBwb3MzOiBbMCwgMF0sXG4gICAgcG9zNDogWzAsIDBdLFxuICAgIGRpcmVjdGlvbjogMVxuICB9LCBhbGxSZXN1bHQpO1xufVxuZnVuY3Rpb24gZ2V0RWxlbWVudEluZm8odGFyZ2V0LCBjb250YWluZXIsIHJvb3RDb250YWluZXIpIHtcbiAgaWYgKHJvb3RDb250YWluZXIgPT09IHZvaWQgMCkge1xuICAgIHJvb3RDb250YWluZXIgPSBjb250YWluZXI7XG4gIH1cblxuICByZXR1cm4gY2FsY3VsYXRlRWxlbWVudEluZm8odGFyZ2V0LCBjb250YWluZXIsIHJvb3RDb250YWluZXIsIHRydWUpO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlTWF0cml4U3RhY2sodGFyZ2V0LCBjb250YWluZXIsIHJvb3RDb250YWluZXIsIGlzQWJzb2x1dGUzZCkge1xuICB2YXIgX2E7XG5cbiAgaWYgKHJvb3RDb250YWluZXIgPT09IHZvaWQgMCkge1xuICAgIHJvb3RDb250YWluZXIgPSBjb250YWluZXI7XG4gIH1cblxuICB2YXIgX2IgPSBnZXRNYXRyaXhTdGFja0luZm8odGFyZ2V0LCBjb250YWluZXIpLFxuICAgICAgbWF0cml4ZXMgPSBfYi5tYXRyaXhlcyxcbiAgICAgIGlzM2QgPSBfYi5pczNkLFxuICAgICAgcHJldlRhcmdldE1hdHJpeCA9IF9iLnRhcmdldE1hdHJpeCxcbiAgICAgIHRyYW5zZm9ybU9yaWdpbiA9IF9iLnRyYW5zZm9ybU9yaWdpbixcbiAgICAgIHRhcmdldE9yaWdpbiA9IF9iLnRhcmdldE9yaWdpbixcbiAgICAgIG9mZnNldENvbnRhaW5lciA9IF9iLm9mZnNldENvbnRhaW5lcjsgLy8gcHJldk1hdHJpeFxuXG5cbiAgdmFyIF9jID0gZ2V0TWF0cml4U3RhY2tJbmZvKG9mZnNldENvbnRhaW5lciwgcm9vdENvbnRhaW5lciwgdHJ1ZSksXG4gICAgICByb290TWF0cml4ZXMgPSBfYy5tYXRyaXhlcyxcbiAgICAgIGlzUm9vdDNkID0gX2MuaXMzZDsgLy8gcHJldlJvb3RNYXRyaXhcbiAgLy8gaWYgKHJvb3RDb250YWluZXIgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgLy8gICAgIGNvbnNvbGUubG9nKG9mZnNldENvbnRhaW5lciwgcm9vdENvbnRhaW5lciwgcm9vdE1hdHJpeGVzKTtcbiAgLy8gfVxuXG5cbiAgdmFyIGlzTmV4dDNkID0gaXNBYnNvbHV0ZTNkIHx8IGlzUm9vdDNkIHx8IGlzM2Q7XG4gIHZhciBuID0gaXNOZXh0M2QgPyA0IDogMztcbiAgdmFyIGlzU1ZHR3JhcGhpY0VsZW1lbnQgPSB0YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcInN2Z1wiICYmIFwib3duZXJTVkdFbGVtZW50XCIgaW4gdGFyZ2V0O1xuICB2YXIgdGFyZ2V0TWF0cml4ID0gcHJldlRhcmdldE1hdHJpeDsgLy8gbGV0IGFsbE1hdHJpeCA9IHByZXZNYXRyaXggPyBjb252ZXJ0RGltZW5zaW9uKHByZXZNYXRyaXgsIHByZXZOISwgbikgOiBjcmVhdGVJZGVudGl0eU1hdHJpeChuKTtcbiAgLy8gbGV0IHJvb3RNYXRyaXggPSBwcmV2Um9vdE1hdHJpeCA/IGNvbnZlcnREaW1lbnNpb24ocHJldlJvb3RNYXRyaXgsIHByZXZOISwgbikgOiBjcmVhdGVJZGVudGl0eU1hdHJpeChuKTtcbiAgLy8gbGV0IGJlZm9yZU1hdHJpeCA9IHByZXZNYXRyaXggPyBjb252ZXJ0RGltZW5zaW9uKHByZXZNYXRyaXgsIHByZXZOISwgbikgOiBjcmVhdGVJZGVudGl0eU1hdHJpeChuKTtcblxuICB2YXIgYWxsTWF0cml4ID0gY3JlYXRlSWRlbnRpdHlNYXRyaXgobik7XG4gIHZhciByb290TWF0cml4ID0gY3JlYXRlSWRlbnRpdHlNYXRyaXgobik7XG4gIHZhciBiZWZvcmVNYXRyaXggPSBjcmVhdGVJZGVudGl0eU1hdHJpeChuKTtcbiAgdmFyIG9mZnNldE1hdHJpeCA9IGNyZWF0ZUlkZW50aXR5TWF0cml4KG4pO1xuICB2YXIgbGVuZ3RoID0gbWF0cml4ZXMubGVuZ3RoO1xuICByb290TWF0cml4ZXMucmV2ZXJzZSgpO1xuICBtYXRyaXhlcy5yZXZlcnNlKCk7XG5cbiAgaWYgKCFpczNkICYmIGlzTmV4dDNkKSB7XG4gICAgdGFyZ2V0TWF0cml4ID0gY29udmVydERpbWVuc2lvbih0YXJnZXRNYXRyaXgsIDMsIDQpO1xuICAgIGNvbnZlcnQzRE1hdHJpeGVzKG1hdHJpeGVzKTtcbiAgfVxuXG4gIGlmICghaXNSb290M2QgJiYgaXNOZXh0M2QpIHtcbiAgICBjb252ZXJ0M0RNYXRyaXhlcyhyb290TWF0cml4ZXMpO1xuICB9IC8vIHJvb3RNYXRyaXggPSAoLi4uKSAtPiBjb250YWluZXIgLT4gb2Zmc2V0IC0+IGFic29sdXRlIC0+IG9mZnNldCAtPiBhYnNvbHV0ZSh0YXJnZXRNYXRyaXgpXG4gIC8vIHJvb3RNYXRyaXhCZWZvcmVPZmZzZXQgPSBsYXN0T2Zmc2V0TWF0cml4IC0+ICguLi4pIC0+IGNvbnRhaW5lclxuICAvLyBiZWZvcmVNYXRyaXggPSAoLi4uIC0+IGNvbnRhaW5lciAtPiBvZmZzZXQgLT4gYWJzb2x1dGUpIC0+IG9mZnNldCAtPiBhYnNvbHV0ZSh0YXJnZXRNYXRyaXgpXG4gIC8vIG9mZnNldE1hdHJpeCA9ICguLi4gLT4gY29udGFpbmVyIC0+IG9mZnNldCAtPiBhYnNvbHV0ZSAtPiBvZmZzZXQpIC0+IGFic29sdXRlKHRhcmdldE1hdHJpeClcblxuXG4gIHJvb3RNYXRyaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgcm9vdE1hdHJpeCA9IG11bHRpcGx5KHJvb3RNYXRyaXgsIGluZm8ubWF0cml4LCBuKTtcbiAgfSk7XG4gIHZhciBvcmlnaW5hbFJvb3RDb250YWluZXIgPSByb290Q29udGFpbmVyIHx8IGRvY3VtZW50LmJvZHk7XG4gIHZhciBlbmRDb250YWluZXIgPSAoKF9hID0gcm9vdE1hdHJpeGVzWzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudGFyZ2V0KSB8fCBnZXRPZmZzZXRJbmZvKG9yaWdpbmFsUm9vdENvbnRhaW5lciwgb3JpZ2luYWxSb290Q29udGFpbmVyLCB0cnVlKS5vZmZzZXRQYXJlbnQ7XG4gIHZhciByb290TWF0cml4QmVmb3JlT2Zmc2V0ID0gcm9vdE1hdHJpeGVzLnNsaWNlKDEpLnJlZHVjZShmdW5jdGlvbiAobWF0cml4LCBpbmZvKSB7XG4gICAgcmV0dXJuIG11bHRpcGx5KG1hdHJpeCwgaW5mby5tYXRyaXgsIG4pO1xuICB9LCBjcmVhdGVJZGVudGl0eU1hdHJpeChuKSk7XG4gIG1hdHJpeGVzLmZvckVhY2goZnVuY3Rpb24gKGluZm8sIGkpIHtcbiAgICBpZiAobGVuZ3RoIC0gMiA9PT0gaSkge1xuICAgICAgLy8gbGVuZ3RoIC0gM1xuICAgICAgYmVmb3JlTWF0cml4ID0gYWxsTWF0cml4LnNsaWNlKCk7XG4gICAgfVxuXG4gICAgaWYgKGxlbmd0aCAtIDEgPT09IGkpIHtcbiAgICAgIC8vIGxlbmd0aCAtIDJcbiAgICAgIG9mZnNldE1hdHJpeCA9IGFsbE1hdHJpeC5zbGljZSgpO1xuICAgIH0gLy8gY2FsY3VsYXRlIGZvciBTVkdFbGVtZW50XG5cblxuICAgIGlmICghaW5mby5tYXRyaXgpIHtcbiAgICAgIHZhciBuZXh0SW5mbyA9IG1hdHJpeGVzW2kgKyAxXTtcbiAgICAgIHZhciBvZmZzZXQgPSBnZXRTVkdPZmZzZXQoaW5mbywgbmV4dEluZm8sIGVuZENvbnRhaW5lciwgbiwgbXVsdGlwbHkocm9vdE1hdHJpeEJlZm9yZU9mZnNldCwgYWxsTWF0cml4LCBuKSk7XG4gICAgICBpbmZvLm1hdHJpeCA9IGNyZWF0ZU9yaWdpbk1hdHJpeChvZmZzZXQsIG4pO1xuICAgIH1cblxuICAgIGFsbE1hdHJpeCA9IG11bHRpcGx5KGFsbE1hdHJpeCwgaW5mby5tYXRyaXgsIG4pO1xuICB9KTtcbiAgdmFyIGlzTWF0cml4M2QgPSAhaXNTVkdHcmFwaGljRWxlbWVudCAmJiBpczNkO1xuXG4gIGlmICghdGFyZ2V0TWF0cml4KSB7XG4gICAgdGFyZ2V0TWF0cml4ID0gY3JlYXRlSWRlbnRpdHlNYXRyaXgoaXNNYXRyaXgzZCA/IDQgOiAzKTtcbiAgfVxuXG4gIHZhciB0YXJnZXRUcmFuc2Zvcm0gPSBtYWtlTWF0cml4Q1NTKGlzU1ZHR3JhcGhpY0VsZW1lbnQgJiYgdGFyZ2V0TWF0cml4Lmxlbmd0aCA9PT0gMTYgPyBjb252ZXJ0RGltZW5zaW9uKHRhcmdldE1hdHJpeCwgNCwgMykgOiB0YXJnZXRNYXRyaXgsIGlzTWF0cml4M2QpO1xuICByb290TWF0cml4ID0gaWdub3JlRGltZW5zaW9uKHJvb3RNYXRyaXgsIG4sIG4pO1xuICByZXR1cm4ge1xuICAgIHJvb3RNYXRyaXg6IHJvb3RNYXRyaXgsXG4gICAgYmVmb3JlTWF0cml4OiBiZWZvcmVNYXRyaXgsXG4gICAgb2Zmc2V0TWF0cml4OiBvZmZzZXRNYXRyaXgsXG4gICAgYWxsTWF0cml4OiBhbGxNYXRyaXgsXG4gICAgdGFyZ2V0TWF0cml4OiB0YXJnZXRNYXRyaXgsXG4gICAgdGFyZ2V0VHJhbnNmb3JtOiB0YXJnZXRUcmFuc2Zvcm0sXG4gICAgdHJhbnNmb3JtT3JpZ2luOiB0cmFuc2Zvcm1PcmlnaW4sXG4gICAgdGFyZ2V0T3JpZ2luOiB0YXJnZXRPcmlnaW4sXG4gICAgaXMzZDogaXNOZXh0M2RcbiAgfTtcbn1cbmZ1bmN0aW9uIG1ha2VNYXRyaXhDU1MobWF0cml4LCBpczNkKSB7XG4gIGlmIChpczNkID09PSB2b2lkIDApIHtcbiAgICBpczNkID0gbWF0cml4Lmxlbmd0aCA+IDk7XG4gIH1cblxuICByZXR1cm4gKGlzM2QgPyBcIm1hdHJpeDNkXCIgOiBcIm1hdHJpeFwiKSArIFwiKFwiICsgY29udmVydE1hdHJpeHRvQ1NTKG1hdHJpeCwgIWlzM2QpLmpvaW4oXCIsXCIpICsgXCIpXCI7XG59XG5mdW5jdGlvbiBnZXRTVkdWaWV3Qm94KGVsKSB7XG4gIHZhciBjbGllbnRXaWR0aCA9IGVsLmNsaWVudFdpZHRoO1xuICB2YXIgY2xpZW50SGVpZ2h0ID0gZWwuY2xpZW50SGVpZ2h0O1xuXG4gIGlmICghZWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMCxcbiAgICAgIGNsaWVudFdpZHRoOiBjbGllbnRXaWR0aCxcbiAgICAgIGNsaWVudEhlaWdodDogY2xpZW50SGVpZ2h0XG4gICAgfTtcbiAgfVxuXG4gIHZhciB2aWV3Qm94ID0gZWwudmlld0JveDtcbiAgdmFyIGJhc2VWYWwgPSB2aWV3Qm94ICYmIHZpZXdCb3guYmFzZVZhbCB8fCB7XG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMFxuICB9O1xuICByZXR1cm4ge1xuICAgIHg6IGJhc2VWYWwueCxcbiAgICB5OiBiYXNlVmFsLnksXG4gICAgd2lkdGg6IGJhc2VWYWwud2lkdGggfHwgY2xpZW50V2lkdGgsXG4gICAgaGVpZ2h0OiBiYXNlVmFsLmhlaWdodCB8fCBjbGllbnRIZWlnaHQsXG4gICAgY2xpZW50V2lkdGg6IGNsaWVudFdpZHRoLFxuICAgIGNsaWVudEhlaWdodDogY2xpZW50SGVpZ2h0XG4gIH07XG59XG5mdW5jdGlvbiBnZXRTVkdNYXRyaXgoZWwsIG4pIHtcbiAgdmFyIF9hID0gZ2V0U1ZHVmlld0JveChlbCksXG4gICAgICB2aWV3Qm94V2lkdGggPSBfYS53aWR0aCxcbiAgICAgIHZpZXdCb3hIZWlnaHQgPSBfYS5oZWlnaHQsXG4gICAgICBjbGllbnRXaWR0aCA9IF9hLmNsaWVudFdpZHRoLFxuICAgICAgY2xpZW50SGVpZ2h0ID0gX2EuY2xpZW50SGVpZ2h0O1xuXG4gIHZhciBzY2FsZVggPSBjbGllbnRXaWR0aCAvIHZpZXdCb3hXaWR0aDtcbiAgdmFyIHNjYWxlWSA9IGNsaWVudEhlaWdodCAvIHZpZXdCb3hIZWlnaHQ7XG4gIHZhciBwcmVzZXJ2ZUFzcGVjdFJhdGlvID0gZWwucHJlc2VydmVBc3BlY3RSYXRpby5iYXNlVmFsOyAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3ByZXNlcnZlQXNwZWN0UmF0aW9cblxuICB2YXIgYWxpZ24gPSBwcmVzZXJ2ZUFzcGVjdFJhdGlvLmFsaWduOyAvLyAxIDogbWVldCAyOiBzbGljZVxuXG4gIHZhciBtZWV0T3JTbGljZSA9IHByZXNlcnZlQXNwZWN0UmF0aW8ubWVldE9yU2xpY2U7XG4gIHZhciBzdmdPcmlnaW4gPSBbMCwgMF07XG4gIHZhciBzY2FsZSA9IFtzY2FsZVgsIHNjYWxlWV07XG4gIHZhciB0cmFuc2xhdGUgPSBbMCwgMF07XG5cbiAgaWYgKGFsaWduICE9PSAxKSB7XG4gICAgdmFyIHhBbGlnbiA9IChhbGlnbiAtIDIpICUgMztcbiAgICB2YXIgeUFsaWduID0gTWF0aC5mbG9vcigoYWxpZ24gLSAyKSAvIDMpO1xuICAgIHN2Z09yaWdpblswXSA9IHZpZXdCb3hXaWR0aCAqIHhBbGlnbiAvIDI7XG4gICAgc3ZnT3JpZ2luWzFdID0gdmlld0JveEhlaWdodCAqIHlBbGlnbiAvIDI7XG4gICAgdmFyIHNjYWxlRGltZW5zaW9uID0gbWVldE9yU2xpY2UgPT09IDIgPyBNYXRoLm1heChzY2FsZVksIHNjYWxlWCkgOiBNYXRoLm1pbihzY2FsZVgsIHNjYWxlWSk7XG4gICAgc2NhbGVbMF0gPSBzY2FsZURpbWVuc2lvbjtcbiAgICBzY2FsZVsxXSA9IHNjYWxlRGltZW5zaW9uO1xuICAgIHRyYW5zbGF0ZVswXSA9IChjbGllbnRXaWR0aCAtIHZpZXdCb3hXaWR0aCkgLyAyICogeEFsaWduO1xuICAgIHRyYW5zbGF0ZVsxXSA9IChjbGllbnRIZWlnaHQgLSB2aWV3Qm94SGVpZ2h0KSAvIDIgKiB5QWxpZ247XG4gIH1cblxuICB2YXIgc2NhbGVNYXRyaXggPSBjcmVhdGVTY2FsZU1hdHJpeChzY2FsZSwgbik7XG4gIHNjYWxlTWF0cml4W24gKiAobiAtIDEpXSA9IHRyYW5zbGF0ZVswXSwgc2NhbGVNYXRyaXhbbiAqIChuIC0gMSkgKyAxXSA9IHRyYW5zbGF0ZVsxXTtcbiAgcmV0dXJuIGdldEFic29sdXRlTWF0cml4KHNjYWxlTWF0cml4LCBuLCBzdmdPcmlnaW4pO1xufVxuZnVuY3Rpb24gZ2V0U1ZHR3JhcGhpY3NPZmZzZXQoZWwsIG9yaWdpbikge1xuICBpZiAoIWVsLmdldEJCb3gpIHtcbiAgICByZXR1cm4gWzAsIDBdO1xuICB9XG5cbiAgdmFyIGJib3ggPSBlbC5nZXRCQm94KCk7XG4gIHZhciB2aWV3Qm94ID0gZ2V0U1ZHVmlld0JveChlbC5vd25lclNWR0VsZW1lbnQpO1xuICB2YXIgbGVmdCA9IGJib3gueCAtIHZpZXdCb3gueDtcbiAgdmFyIHRvcCA9IGJib3gueSAtIHZpZXdCb3gueTtcbiAgcmV0dXJuIFtsZWZ0LCB0b3AsIG9yaWdpblswXSAtIGxlZnQsIG9yaWdpblsxXSAtIHRvcF07XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVQb3NpdGlvbihtYXRyaXgsIHBvcywgbikge1xuICByZXR1cm4gY2FsY3VsYXRlKG1hdHJpeCwgY29udmVydFBvc2l0aW9uTWF0cml4KHBvcywgbiksIG4pO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlUG9zZXMobWF0cml4LCB3aWR0aCwgaGVpZ2h0LCBuKSB7XG4gIHJldHVybiBbWzAsIDBdLCBbd2lkdGgsIDBdLCBbMCwgaGVpZ2h0XSwgW3dpZHRoLCBoZWlnaHRdXS5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgIHJldHVybiBjYWxjdWxhdGVQb3NpdGlvbihtYXRyaXgsIHBvcywgbik7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0UmVjdChwb3Nlcykge1xuICB2YXIgcG9zZXNYID0gcG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICByZXR1cm4gcG9zWzBdO1xuICB9KTtcbiAgdmFyIHBvc2VzWSA9IHBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgcmV0dXJuIHBvc1sxXTtcbiAgfSk7XG4gIHZhciBsZWZ0ID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgcG9zZXNYKTtcbiAgdmFyIHRvcCA9IE1hdGgubWluLmFwcGx5KE1hdGgsIHBvc2VzWSk7XG4gIHZhciByaWdodCA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHBvc2VzWCk7XG4gIHZhciBib3R0b20gPSBNYXRoLm1heC5hcHBseShNYXRoLCBwb3Nlc1kpO1xuICB2YXIgcmVjdFdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICB2YXIgcmVjdEhlaWdodCA9IGJvdHRvbSAtIHRvcDtcbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiBsZWZ0LFxuICAgIHRvcDogdG9wLFxuICAgIHJpZ2h0OiByaWdodCxcbiAgICBib3R0b206IGJvdHRvbSxcbiAgICB3aWR0aDogcmVjdFdpZHRoLFxuICAgIGhlaWdodDogcmVjdEhlaWdodFxuICB9O1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlUmVjdChtYXRyaXgsIHdpZHRoLCBoZWlnaHQsIG4pIHtcbiAgdmFyIHBvc2VzID0gY2FsY3VsYXRlUG9zZXMobWF0cml4LCB3aWR0aCwgaGVpZ2h0LCBuKTtcbiAgcmV0dXJuIGdldFJlY3QocG9zZXMpO1xufVxuZnVuY3Rpb24gZ2V0U1ZHT2Zmc2V0KG9mZnNldEluZm8sIHRhcmdldEluZm8sIGNvbnRhaW5lciwgbiwgYmVmb3JlTWF0cml4KSB7XG4gIHZhciBfYTtcblxuICB2YXIgdGFyZ2V0ID0gb2Zmc2V0SW5mby50YXJnZXQ7XG4gIHZhciBvcmlnaW4gPSBvZmZzZXRJbmZvLm9yaWdpbjtcbiAgdmFyIHRhcmdldE1hdHJpeCA9IHRhcmdldEluZm8ubWF0cml4O1xuXG4gIHZhciBfYiA9IGdldFNpemUodGFyZ2V0LCB1bmRlZmluZWQsIHRydWUpLFxuICAgICAgd2lkdGggPSBfYlswXSxcbiAgICAgIGhlaWdodCA9IF9iWzFdO1xuXG4gIHZhciBjb250YWluZXJDbGllbnRSZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgbWFyZ2luID0gWzAsIDBdO1xuXG4gIGlmIChjb250YWluZXIgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICBtYXJnaW4gPSBnZXRCb2R5T2Zmc2V0KHRhcmdldCwgdHJ1ZSk7XG4gIH1cblxuICB2YXIgcmVjdCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHJlY3RMZWZ0ID0gcmVjdC5sZWZ0IC0gY29udGFpbmVyQ2xpZW50UmVjdC5sZWZ0ICsgY29udGFpbmVyLnNjcm9sbExlZnQgLSAoY29udGFpbmVyLmNsaWVudExlZnQgfHwgMCkgKyBtYXJnaW5bMF07XG4gIHZhciByZWN0VG9wID0gcmVjdC50b3AgLSBjb250YWluZXJDbGllbnRSZWN0LnRvcCArIGNvbnRhaW5lci5zY3JvbGxUb3AgLSAoY29udGFpbmVyLmNsaWVudFRvcCB8fCAwKSArIG1hcmdpblsxXTtcbiAgdmFyIHJlY3RXaWR0aCA9IHJlY3Qud2lkdGg7XG4gIHZhciByZWN0SGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gIHZhciBtYXQgPSBtdWx0aXBsaWVzKG4sIGJlZm9yZU1hdHJpeCwgdGFyZ2V0TWF0cml4KTtcblxuICB2YXIgX2MgPSBjYWxjdWxhdGVSZWN0KG1hdCwgd2lkdGgsIGhlaWdodCwgbiksXG4gICAgICBwcmV2TGVmdCA9IF9jLmxlZnQsXG4gICAgICBwcmV2VG9wID0gX2MudG9wLFxuICAgICAgcHJldldpZHRoID0gX2Mud2lkdGgsXG4gICAgICBwcmV2SGVpZ2h0ID0gX2MuaGVpZ2h0O1xuXG4gIHZhciBwb3NPcmlnaW4gPSBjYWxjdWxhdGVQb3NpdGlvbihtYXQsIG9yaWdpbiwgbik7XG4gIHZhciBwcmV2T3JpZ2luID0gbWludXMocG9zT3JpZ2luLCBbcHJldkxlZnQsIHByZXZUb3BdKTtcbiAgdmFyIHJlY3RPcmlnaW4gPSBbcmVjdExlZnQgKyBwcmV2T3JpZ2luWzBdICogcmVjdFdpZHRoIC8gcHJldldpZHRoLCByZWN0VG9wICsgcHJldk9yaWdpblsxXSAqIHJlY3RIZWlnaHQgLyBwcmV2SGVpZ2h0XTtcbiAgdmFyIG9mZnNldCA9IFswLCAwXTtcbiAgdmFyIGNvdW50ID0gMDtcblxuICB3aGlsZSAoKytjb3VudCA8IDEwKSB7XG4gICAgdmFyIGludmVyc2VCZWZvcmVNYXRyaXggPSBpbnZlcnQoYmVmb3JlTWF0cml4LCBuKTtcbiAgICBfYSA9IG1pbnVzKGNhbGN1bGF0ZVBvc2l0aW9uKGludmVyc2VCZWZvcmVNYXRyaXgsIHJlY3RPcmlnaW4sIG4pLCBjYWxjdWxhdGVQb3NpdGlvbihpbnZlcnNlQmVmb3JlTWF0cml4LCBwb3NPcmlnaW4sIG4pKSwgb2Zmc2V0WzBdID0gX2FbMF0sIG9mZnNldFsxXSA9IF9hWzFdO1xuICAgIHZhciBtYXQyID0gbXVsdGlwbGllcyhuLCBiZWZvcmVNYXRyaXgsIGNyZWF0ZU9yaWdpbk1hdHJpeChvZmZzZXQsIG4pLCB0YXJnZXRNYXRyaXgpO1xuXG4gICAgdmFyIF9kID0gY2FsY3VsYXRlUmVjdChtYXQyLCB3aWR0aCwgaGVpZ2h0LCBuKSxcbiAgICAgICAgbmV4dExlZnQgPSBfZC5sZWZ0LFxuICAgICAgICBuZXh0VG9wID0gX2QudG9wO1xuXG4gICAgdmFyIGRpc3RMZWZ0ID0gbmV4dExlZnQgLSByZWN0TGVmdDtcbiAgICB2YXIgZGlzdFRvcCA9IG5leHRUb3AgLSByZWN0VG9wO1xuXG4gICAgaWYgKE1hdGguYWJzKGRpc3RMZWZ0KSA8IDIgJiYgTWF0aC5hYnMoZGlzdFRvcCkgPCAyKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZWN0T3JpZ2luWzBdIC09IGRpc3RMZWZ0O1xuICAgIHJlY3RPcmlnaW5bMV0gLT0gZGlzdFRvcDtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQocCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlTW92ZWFibGVQb3NpdGlvbihtYXRyaXgsIG9yaWdpbiwgd2lkdGgsIGhlaWdodCkge1xuICB2YXIgaXMzZCA9IG1hdHJpeC5sZW5ndGggPT09IDE2O1xuICB2YXIgbiA9IGlzM2QgPyA0IDogMztcbiAgdmFyIHBvc2VzID0gY2FsY3VsYXRlUG9zZXMobWF0cml4LCB3aWR0aCwgaGVpZ2h0LCBuKTtcbiAgdmFyIF9hID0gcG9zZXNbMF0sXG4gICAgICB4MSA9IF9hWzBdLFxuICAgICAgeTEgPSBfYVsxXSxcbiAgICAgIF9iID0gcG9zZXNbMV0sXG4gICAgICB4MiA9IF9iWzBdLFxuICAgICAgeTIgPSBfYlsxXSxcbiAgICAgIF9jID0gcG9zZXNbMl0sXG4gICAgICB4MyA9IF9jWzBdLFxuICAgICAgeTMgPSBfY1sxXSxcbiAgICAgIF9kID0gcG9zZXNbM10sXG4gICAgICB4NCA9IF9kWzBdLFxuICAgICAgeTQgPSBfZFsxXTtcblxuICB2YXIgX2UgPSBjYWxjdWxhdGVQb3NpdGlvbihtYXRyaXgsIG9yaWdpbiwgbiksXG4gICAgICBvcmlnaW5YID0gX2VbMF0sXG4gICAgICBvcmlnaW5ZID0gX2VbMV07XG5cbiAgdmFyIGxlZnQgPSBNYXRoLm1pbih4MSwgeDIsIHgzLCB4NCk7XG4gIHZhciB0b3AgPSBNYXRoLm1pbih5MSwgeTIsIHkzLCB5NCk7XG4gIHZhciByaWdodCA9IE1hdGgubWF4KHgxLCB4MiwgeDMsIHg0KTtcbiAgdmFyIGJvdHRvbSA9IE1hdGgubWF4KHkxLCB5MiwgeTMsIHk0KTtcbiAgeDEgPSB4MSAtIGxlZnQgfHwgMDtcbiAgeDIgPSB4MiAtIGxlZnQgfHwgMDtcbiAgeDMgPSB4MyAtIGxlZnQgfHwgMDtcbiAgeDQgPSB4NCAtIGxlZnQgfHwgMDtcbiAgeTEgPSB5MSAtIHRvcCB8fCAwO1xuICB5MiA9IHkyIC0gdG9wIHx8IDA7XG4gIHkzID0geTMgLSB0b3AgfHwgMDtcbiAgeTQgPSB5NCAtIHRvcCB8fCAwO1xuICBvcmlnaW5YID0gb3JpZ2luWCAtIGxlZnQgfHwgMDtcbiAgb3JpZ2luWSA9IG9yaWdpblkgLSB0b3AgfHwgMDtcbiAgdmFyIGRpcmVjdGlvbiA9IGdldFNoYXBlRGlyZWN0aW9uKHBvc2VzKTtcbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiBsZWZ0LFxuICAgIHRvcDogdG9wLFxuICAgIHJpZ2h0OiByaWdodCxcbiAgICBib3R0b206IGJvdHRvbSxcbiAgICBvcmlnaW46IFtvcmlnaW5YLCBvcmlnaW5ZXSxcbiAgICBwb3MxOiBbeDEsIHkxXSxcbiAgICBwb3MyOiBbeDIsIHkyXSxcbiAgICBwb3MzOiBbeDMsIHkzXSxcbiAgICBwb3M0OiBbeDQsIHk0XSxcbiAgICBkaXJlY3Rpb246IGRpcmVjdGlvblxuICB9O1xufVxuZnVuY3Rpb24gZ2V0RGlzdFNpemUodmVjKSB7XG4gIHJldHVybiBNYXRoLnNxcnQodmVjWzBdICogdmVjWzBdICsgdmVjWzFdICogdmVjWzFdKTtcbn1cbmZ1bmN0aW9uIGdldERpYWdvbmFsU2l6ZShwb3MxLCBwb3MyKSB7XG4gIHJldHVybiBnZXREaXN0U2l6ZShbcG9zMlswXSAtIHBvczFbMF0sIHBvczJbMV0gLSBwb3MxWzFdXSk7XG59XG5mdW5jdGlvbiBnZXRMaW5lU3R5bGUocG9zMSwgcG9zMiwgem9vbSwgcmFkKSB7XG4gIGlmICh6b29tID09PSB2b2lkIDApIHtcbiAgICB6b29tID0gMTtcbiAgfVxuXG4gIGlmIChyYWQgPT09IHZvaWQgMCkge1xuICAgIHJhZCA9IGdldFJhZChwb3MxLCBwb3MyKTtcbiAgfVxuXG4gIHZhciB3aWR0aCA9IGdldERpYWdvbmFsU2l6ZShwb3MxLCBwb3MyKTtcbiAgcmV0dXJuIHtcbiAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlWSgtNTAlKSB0cmFuc2xhdGUoXCIgKyBwb3MxWzBdICsgXCJweCwgXCIgKyBwb3MxWzFdICsgXCJweCkgcm90YXRlKFwiICsgcmFkICsgXCJyYWQpIHNjYWxlWShcIiArIHpvb20gKyBcIilcIixcbiAgICB3aWR0aDogd2lkdGggKyBcInB4XCJcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldENvbnRyb2xUcmFuc2Zvcm0ocm90YXRpb24sIHpvb20pIHtcbiAgdmFyIHBvc2VzID0gW107XG5cbiAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICBwb3Nlc1tfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBwb3Nlcy5sZW5ndGg7XG4gIHZhciB4ID0gcG9zZXMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBwb3MpIHtcbiAgICByZXR1cm4gcHJldiArIHBvc1swXTtcbiAgfSwgMCkgLyBsZW5ndGg7XG4gIHZhciB5ID0gcG9zZXMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBwb3MpIHtcbiAgICByZXR1cm4gcHJldiArIHBvc1sxXTtcbiAgfSwgMCkgLyBsZW5ndGg7XG4gIHJldHVybiB7XG4gICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVooMHB4KSB0cmFuc2xhdGUoXCIgKyB4ICsgXCJweCwgXCIgKyB5ICsgXCJweCkgcm90YXRlKFwiICsgcm90YXRpb24gKyBcInJhZCkgc2NhbGUoXCIgKyB6b29tICsgXCIpXCJcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldENTU1NpemUodGFyZ2V0KSB7XG4gIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KTtcbiAgcmV0dXJuIFtwYXJzZUZsb2F0KHN0eWxlLndpZHRoKSwgcGFyc2VGbG9hdChzdHlsZS5oZWlnaHQpXTtcbn1cbmZ1bmN0aW9uIGdldFNpemUodGFyZ2V0LCBzdHlsZSwgaXNPZmZzZXQsIGlzQm94U2l6aW5nKSB7XG4gIGlmIChzdHlsZSA9PT0gdm9pZCAwKSB7XG4gICAgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldCk7XG4gIH1cblxuICBpZiAoaXNCb3hTaXppbmcgPT09IHZvaWQgMCkge1xuICAgIGlzQm94U2l6aW5nID0gaXNPZmZzZXQgfHwgc3R5bGUuYm94U2l6aW5nID09PSBcImJvcmRlci1ib3hcIjtcbiAgfVxuXG4gIHZhciB3aWR0aCA9IHRhcmdldC5vZmZzZXRXaWR0aDtcbiAgdmFyIGhlaWdodCA9IHRhcmdldC5vZmZzZXRIZWlnaHQ7XG4gIHZhciBoYXNPZmZzZXQgPSAhaXNVbmRlZmluZWQod2lkdGgpO1xuXG4gIGlmICgoaXNPZmZzZXQgfHwgaXNCb3hTaXppbmcpICYmIGhhc09mZnNldCkge1xuICAgIHJldHVybiBbd2lkdGgsIGhlaWdodF07XG4gIH1cblxuICBpZiAoIWhhc09mZnNldCAmJiB0YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcInN2Z1wiKSB7XG4gICAgdmFyIGJib3ggPSB0YXJnZXQuZ2V0QkJveCgpO1xuICAgIHJldHVybiBbYmJveC53aWR0aCwgYmJveC5oZWlnaHRdO1xuICB9XG5cbiAgd2lkdGggPSB0YXJnZXQuY2xpZW50V2lkdGg7XG4gIGhlaWdodCA9IHRhcmdldC5jbGllbnRIZWlnaHQ7XG5cbiAgaWYgKGlzT2Zmc2V0IHx8IGlzQm94U2l6aW5nKSB7XG4gICAgdmFyIGJvcmRlckxlZnQgPSBwYXJzZUZsb2F0KHN0eWxlLmJvcmRlckxlZnRXaWR0aCkgfHwgMDtcbiAgICB2YXIgYm9yZGVyUmlnaHQgPSBwYXJzZUZsb2F0KHN0eWxlLmJvcmRlclJpZ2h0V2lkdGgpIHx8IDA7XG4gICAgdmFyIGJvcmRlclRvcCA9IHBhcnNlRmxvYXQoc3R5bGUuYm9yZGVyVG9wV2lkdGgpIHx8IDA7XG4gICAgdmFyIGJvcmRlckJvdHRvbSA9IHBhcnNlRmxvYXQoc3R5bGUuYm9yZGVyQm90dG9tV2lkdGgpIHx8IDA7XG4gICAgcmV0dXJuIFt3aWR0aCArIGJvcmRlckxlZnQgKyBib3JkZXJSaWdodCwgaGVpZ2h0ICsgYm9yZGVyVG9wICsgYm9yZGVyQm90dG9tXTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcGFkZGluZ0xlZnQgPSBwYXJzZUZsb2F0KHN0eWxlLnBhZGRpbmdMZWZ0KSB8fCAwO1xuICAgIHZhciBwYWRkaW5nUmlnaHQgPSBwYXJzZUZsb2F0KHN0eWxlLnBhZGRpbmdSaWdodCkgfHwgMDtcbiAgICB2YXIgcGFkZGluZ1RvcCA9IHBhcnNlRmxvYXQoc3R5bGUucGFkZGluZ1RvcCkgfHwgMDtcbiAgICB2YXIgcGFkZGluZ0JvdHRvbSA9IHBhcnNlRmxvYXQoc3R5bGUucGFkZGluZ0JvdHRvbSkgfHwgMDtcbiAgICByZXR1cm4gW3dpZHRoIC0gcGFkZGluZ0xlZnQgLSBwYWRkaW5nUmlnaHQsIGhlaWdodCAtIHBhZGRpbmdUb3AgLSBwYWRkaW5nQm90dG9tXTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Um90YXRpb25SYWQocG9zZXMsIGRpcmVjdGlvbikge1xuICByZXR1cm4gZ2V0UmFkKGRpcmVjdGlvbiA+IDAgPyBwb3Nlc1swXSA6IHBvc2VzWzFdLCBkaXJlY3Rpb24gPiAwID8gcG9zZXNbMV0gOiBwb3Nlc1swXSk7XG59XG5mdW5jdGlvbiBnZXRUYXJnZXRJbmZvKG1vdmVhYmxlRWxlbWVudCwgdGFyZ2V0LCBjb250YWluZXIsIHBhcmVudENvbnRhaW5lciwgcm9vdENvbnRhaW5lcikge1xuICB2YXIgYmVmb3JlRGlyZWN0aW9uID0gMTtcbiAgdmFyIGJlZm9yZU9yaWdpbiA9IFswLCAwXTtcbiAgdmFyIHRhcmdldENsaWVudFJlY3QgPSByZXNldENsaWVudFJlY3QoKTtcbiAgdmFyIGNvbnRhaW5lckNsaWVudFJlY3QgPSByZXNldENsaWVudFJlY3QoKTtcbiAgdmFyIG1vdmVhYmxlQ2xpZW50UmVjdCA9IHJlc2V0Q2xpZW50UmVjdCgpO1xuICB2YXIgcmVzdWx0ID0gY2FsY3VsYXRlRWxlbWVudEluZm8odGFyZ2V0LCBjb250YWluZXIsIHJvb3RDb250YWluZXIsIGZhbHNlKTtcblxuICBpZiAodGFyZ2V0KSB7XG4gICAgdmFyIG4gPSByZXN1bHQuaXMzZCA/IDQgOiAzO1xuICAgIHZhciBiZWZvcmVQb3NpdGlvbiA9IGNhbGN1bGF0ZU1vdmVhYmxlUG9zaXRpb24ocmVzdWx0Lm9mZnNldE1hdHJpeCwgcGx1cyhyZXN1bHQudHJhbnNmb3JtT3JpZ2luLCBnZXRPcmlnaW4ocmVzdWx0LnRhcmdldE1hdHJpeCwgbikpLCByZXN1bHQud2lkdGgsIHJlc3VsdC5oZWlnaHQpO1xuICAgIGJlZm9yZURpcmVjdGlvbiA9IGJlZm9yZVBvc2l0aW9uLmRpcmVjdGlvbjtcbiAgICBiZWZvcmVPcmlnaW4gPSBwbHVzKGJlZm9yZVBvc2l0aW9uLm9yaWdpbiwgW2JlZm9yZVBvc2l0aW9uLmxlZnQgLSByZXN1bHQubGVmdCwgYmVmb3JlUG9zaXRpb24udG9wIC0gcmVzdWx0LnRvcF0pO1xuICAgIHRhcmdldENsaWVudFJlY3QgPSBnZXRDbGllbnRSZWN0KHRhcmdldCk7XG4gICAgY29udGFpbmVyQ2xpZW50UmVjdCA9IGdldENsaWVudFJlY3QoZ2V0T2Zmc2V0SW5mbyhwYXJlbnRDb250YWluZXIsIHBhcmVudENvbnRhaW5lciwgdHJ1ZSkub2Zmc2V0UGFyZW50IHx8IGRvY3VtZW50LmJvZHksIHRydWUpO1xuXG4gICAgaWYgKG1vdmVhYmxlRWxlbWVudCkge1xuICAgICAgbW92ZWFibGVDbGllbnRSZWN0ID0gZ2V0Q2xpZW50UmVjdChtb3ZlYWJsZUVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfX2Fzc2lnbih7XG4gICAgdGFyZ2V0Q2xpZW50UmVjdDogdGFyZ2V0Q2xpZW50UmVjdCxcbiAgICBjb250YWluZXJDbGllbnRSZWN0OiBjb250YWluZXJDbGllbnRSZWN0LFxuICAgIG1vdmVhYmxlQ2xpZW50UmVjdDogbW92ZWFibGVDbGllbnRSZWN0LFxuICAgIGJlZm9yZURpcmVjdGlvbjogYmVmb3JlRGlyZWN0aW9uLFxuICAgIGJlZm9yZU9yaWdpbjogYmVmb3JlT3JpZ2luLFxuICAgIG9yaWdpbmFsQmVmb3JlT3JpZ2luOiBiZWZvcmVPcmlnaW4sXG4gICAgdGFyZ2V0OiB0YXJnZXRcbiAgfSwgcmVzdWx0KTtcbn1cbmZ1bmN0aW9uIHJlc2V0Q2xpZW50UmVjdCgpIHtcbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIHRvcDogMCxcbiAgICBib3R0b206IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwLFxuICAgIGNsaWVudExlZnQ6IDAsXG4gICAgY2xpZW50VG9wOiAwLFxuICAgIGNsaWVudFdpZHRoOiAwLFxuICAgIGNsaWVudEhlaWdodDogMCxcbiAgICBzY3JvbGxXaWR0aDogMCxcbiAgICBzY3JvbGxIZWlnaHQ6IDBcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldENsaWVudFJlY3QoZWwsIGlzRXh0ZW5kcykge1xuICB2YXIgbGVmdCA9IDA7XG4gIHZhciB0b3AgPSAwO1xuICB2YXIgd2lkdGggPSAwO1xuICB2YXIgaGVpZ2h0ID0gMDtcblxuICBpZiAoZWwgPT09IGRvY3VtZW50LmJvZHkgfHwgZWwgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgIHdpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIGxlZnQgPSAtKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCk7XG4gICAgdG9wID0gLShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY2xpZW50UmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxlZnQgPSBjbGllbnRSZWN0LmxlZnQ7XG4gICAgdG9wID0gY2xpZW50UmVjdC50b3A7XG4gICAgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoO1xuICAgIGhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0O1xuICB9XG5cbiAgdmFyIHJlY3QgPSB7XG4gICAgbGVmdDogbGVmdCxcbiAgICByaWdodDogbGVmdCArIHdpZHRoLFxuICAgIHRvcDogdG9wLFxuICAgIGJvdHRvbTogdG9wICsgaGVpZ2h0LFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xuXG4gIGlmIChpc0V4dGVuZHMpIHtcbiAgICByZWN0LmNsaWVudExlZnQgPSBlbC5jbGllbnRMZWZ0O1xuICAgIHJlY3QuY2xpZW50VG9wID0gZWwuY2xpZW50VG9wO1xuICAgIHJlY3QuY2xpZW50V2lkdGggPSBlbC5jbGllbnRXaWR0aDtcbiAgICByZWN0LmNsaWVudEhlaWdodCA9IGVsLmNsaWVudEhlaWdodDtcbiAgICByZWN0LnNjcm9sbFdpZHRoID0gZWwuc2Nyb2xsV2lkdGg7XG4gICAgcmVjdC5zY3JvbGxIZWlnaHQgPSBlbC5zY3JvbGxIZWlnaHQ7XG4gICAgcmVjdC5vdmVyZmxvdyA9IGdldENvbXB1dGVkU3R5bGUoZWwpLm92ZXJmbG93ICE9PSBcInZpc2libGVcIjtcbiAgfVxuXG4gIHJldHVybiByZWN0O1xufVxuZnVuY3Rpb24gZ2V0RGlyZWN0aW9uKHRhcmdldCkge1xuICBpZiAoIXRhcmdldCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBkaXJlY2l0b24gPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1kaXJlY3Rpb25cIik7XG5cbiAgaWYgKCFkaXJlY2l0b24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZGlyID0gWzAsIDBdO1xuICBkaXJlY2l0b24uaW5kZXhPZihcIndcIikgPiAtMSAmJiAoZGlyWzBdID0gLTEpO1xuICBkaXJlY2l0b24uaW5kZXhPZihcImVcIikgPiAtMSAmJiAoZGlyWzBdID0gMSk7XG4gIGRpcmVjaXRvbi5pbmRleE9mKFwiblwiKSA+IC0xICYmIChkaXJbMV0gPSAtMSk7XG4gIGRpcmVjaXRvbi5pbmRleE9mKFwic1wiKSA+IC0xICYmIChkaXJbMV0gPSAxKTtcbiAgcmV0dXJuIGRpcjtcbn1cbmZ1bmN0aW9uIGdldEFic29sdXRlUG9zZXMocG9zZXMsIGRpc3QpIHtcbiAgcmV0dXJuIFtwbHVzKGRpc3QsIHBvc2VzWzBdKSwgcGx1cyhkaXN0LCBwb3Nlc1sxXSksIHBsdXMoZGlzdCwgcG9zZXNbMl0pLCBwbHVzKGRpc3QsIHBvc2VzWzNdKV07XG59XG5mdW5jdGlvbiBnZXRBYnNvbHV0ZVBvc2VzQnlTdGF0ZShfYSkge1xuICB2YXIgbGVmdCA9IF9hLmxlZnQsXG4gICAgICB0b3AgPSBfYS50b3AsXG4gICAgICBwb3MxID0gX2EucG9zMSxcbiAgICAgIHBvczIgPSBfYS5wb3MyLFxuICAgICAgcG9zMyA9IF9hLnBvczMsXG4gICAgICBwb3M0ID0gX2EucG9zNDtcbiAgcmV0dXJuIGdldEFic29sdXRlUG9zZXMoW3BvczEsIHBvczIsIHBvczMsIHBvczRdLCBbbGVmdCwgdG9wXSk7XG59XG5mdW5jdGlvbiByb3VuZFNpZ24obnVtKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKG51bSAlIDEgPT09IC0wLjUgPyBudW0gLSAxIDogbnVtKTtcbn1cbmZ1bmN0aW9uIHVuc2V0KHNlbGYsIG5hbWUpIHtcbiAgdmFyIF9hO1xuXG4gIChfYSA9IHNlbGZbbmFtZV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51bnNldCgpO1xuICBzZWxmW25hbWVdID0gbnVsbDtcbn1cbmZ1bmN0aW9uIGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIHBhcmFtcykge1xuICB2YXIgZGF0YXMgPSBlLmRhdGFzO1xuXG4gIGlmICghZGF0YXMuZGF0YXMpIHtcbiAgICBkYXRhcy5kYXRhcyA9IHt9O1xuICB9XG5cbiAgdmFyIG5leHRQYXJhbXMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcGFyYW1zKSwge1xuICAgIHRhcmdldDogbW92ZWFibGUuc3RhdGUudGFyZ2V0LFxuICAgIGNsaWVudFg6IGUuY2xpZW50WCxcbiAgICBjbGllbnRZOiBlLmNsaWVudFksXG4gICAgaW5wdXRFdmVudDogZS5pbnB1dEV2ZW50LFxuICAgIGN1cnJlbnRUYXJnZXQ6IG1vdmVhYmxlLFxuICAgIG1vdmVhYmxlOiBtb3ZlYWJsZSxcbiAgICBkYXRhczogZGF0YXMuZGF0YXNcbiAgfSk7XG5cbiAgaWYgKGRhdGFzLmlzU3RhcnRFdmVudCkge1xuICAgIGRhdGFzLmxhc3RFdmVudCA9IG5leHRQYXJhbXM7XG4gIH0gZWxzZSB7XG4gICAgZGF0YXMuaXNTdGFydEV2ZW50ID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBuZXh0UGFyYW1zO1xufVxuZnVuY3Rpb24gZmlsbEVuZFBhcmFtcyhtb3ZlYWJsZSwgZSwgcGFyYW1zKSB7XG4gIHZhciBkYXRhcyA9IGUuZGF0YXM7XG4gIHZhciBpc0RyYWcgPSBcImlzRHJhZ1wiIGluIHBhcmFtcyA/IHBhcmFtcy5pc0RyYWcgOiBlLmlzRHJhZztcblxuICBpZiAoIWRhdGFzLmRhdGFzKSB7XG4gICAgZGF0YXMuZGF0YXMgPSB7fTtcbiAgfVxuXG4gIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7XG4gICAgaXNEcmFnOiBpc0RyYWdcbiAgfSwgcGFyYW1zKSwge1xuICAgIG1vdmVhYmxlOiBtb3ZlYWJsZSxcbiAgICB0YXJnZXQ6IG1vdmVhYmxlLnN0YXRlLnRhcmdldCxcbiAgICBjbGllbnRYOiBlLmNsaWVudFgsXG4gICAgY2xpZW50WTogZS5jbGllbnRZLFxuICAgIGlucHV0RXZlbnQ6IGUuaW5wdXRFdmVudCxcbiAgICBjdXJyZW50VGFyZ2V0OiBtb3ZlYWJsZSxcbiAgICBsYXN0RXZlbnQ6IGRhdGFzLmxhc3RFdmVudCxcbiAgICBpc0RvdWJsZTogZS5pc0RvdWJsZSxcbiAgICBkYXRhczogZGF0YXMuZGF0YXNcbiAgfSk7XG59XG5mdW5jdGlvbiB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIG5hbWUsIHBhcmFtcywgaXNNYW5hZ2VyKSB7XG4gIHJldHVybiBtb3ZlYWJsZS50cmlnZ2VyRXZlbnQobmFtZSwgcGFyYW1zLCBpc01hbmFnZXIpO1xufVxuZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZShlbCwgcHNldWRvRWx0KSB7XG4gIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgcHNldWRvRWx0KTtcbn1cbmZ1bmN0aW9uIGZpbHRlckFibGVzKGFibGVzLCBtZXRob2RzLCB0cmlnZ2VyQWJsZXNTaW11bHRhbmVvdXNseSkge1xuICB2YXIgZW5hYmxlZEFibGVzID0ge307XG4gIHZhciBhYmxlR3JvdXBzID0ge307XG4gIHJldHVybiBhYmxlcy5maWx0ZXIoZnVuY3Rpb24gKGFibGUpIHtcbiAgICB2YXIgbmFtZSA9IGFibGUubmFtZTtcblxuICAgIGlmIChlbmFibGVkQWJsZXNbbmFtZV0gfHwgIW1ldGhvZHMuc29tZShmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICByZXR1cm4gYWJsZVttZXRob2RdO1xuICAgIH0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCF0cmlnZ2VyQWJsZXNTaW11bHRhbmVvdXNseSAmJiBhYmxlLmFibGVHcm91cCkge1xuICAgICAgaWYgKGFibGVHcm91cHNbYWJsZS5hYmxlR3JvdXBdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgYWJsZUdyb3Vwc1thYmxlLmFibGVHcm91cF0gPSB0cnVlO1xuICAgIH1cblxuICAgIGVuYWJsZWRBYmxlc1tuYW1lXSA9IHRydWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xufVxuZnVuY3Rpb24gZXF1YWxzKGExLCBhMikge1xuICByZXR1cm4gYTEgPT09IGEyIHx8IGExID09IG51bGwgJiYgYTIgPT0gbnVsbDtcbn1cbmZ1bmN0aW9uIHNlbGVjdFZhbHVlKCkge1xuICB2YXIgdmFsdWVzID0gW107XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICB2YWx1ZXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoIC0gMTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xuXG4gICAgaWYgKCFpc1VuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsdWVzW2xlbmd0aF07XG59XG5mdW5jdGlvbiBncm91cEJ5KGFyciwgZnVuYykge1xuICB2YXIgZ3JvdXBzID0gW107XG4gIHZhciBncm91cEtleXMgPSBbXTtcbiAgYXJyLmZvckVhY2goZnVuY3Rpb24gKGVsLCBpbmRleCkge1xuICAgIHZhciBncm91cEtleSA9IGZ1bmMoZWwsIGluZGV4LCBhcnIpO1xuICAgIHZhciBrZXlJbmRleCA9IGdyb3VwS2V5cy5pbmRleE9mKGdyb3VwS2V5KTtcbiAgICB2YXIgZ3JvdXAgPSBncm91cHNba2V5SW5kZXhdIHx8IFtdO1xuXG4gICAgaWYgKGtleUluZGV4ID09PSAtMSkge1xuICAgICAgZ3JvdXBLZXlzLnB1c2goZ3JvdXBLZXkpO1xuICAgICAgZ3JvdXBzLnB1c2goZ3JvdXApO1xuICAgIH1cblxuICAgIGdyb3VwLnB1c2goZWwpO1xuICB9KTtcbiAgcmV0dXJuIGdyb3Vwcztcbn1cbmZ1bmN0aW9uIGdyb3VwQnlNYXAoYXJyLCBmdW5jKSB7XG4gIHZhciBncm91cHMgPSBbXTtcbiAgdmFyIGdyb3VwS2V5cyA9IHt9O1xuICBhcnIuZm9yRWFjaChmdW5jdGlvbiAoZWwsIGluZGV4KSB7XG4gICAgdmFyIGdyb3VwS2V5ID0gZnVuYyhlbCwgaW5kZXgsIGFycik7XG4gICAgdmFyIGdyb3VwID0gZ3JvdXBLZXlzW2dyb3VwS2V5XTtcblxuICAgIGlmICghZ3JvdXApIHtcbiAgICAgIGdyb3VwID0gW107XG4gICAgICBncm91cEtleXNbZ3JvdXBLZXldID0gZ3JvdXA7XG4gICAgICBncm91cHMucHVzaChncm91cCk7XG4gICAgfVxuXG4gICAgZ3JvdXAucHVzaChlbCk7XG4gIH0pO1xuICByZXR1cm4gZ3JvdXBzO1xufVxuZnVuY3Rpb24gZmxhdChhcnIpIHtcbiAgcmV0dXJuIGFyci5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cikge1xuICAgIHJldHVybiBwcmV2LmNvbmNhdChjdXIpO1xuICB9LCBbXSk7XG59XG5mdW5jdGlvbiBtYXhPZmZzZXQoKSB7XG4gIHZhciBhcmdzID0gW107XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gIH1cblxuICBhcmdzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gTWF0aC5hYnMoYikgLSBNYXRoLmFicyhhKTtcbiAgfSk7XG4gIHJldHVybiBhcmdzWzBdO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlSW52ZXJzZVBvc2l0aW9uKG1hdHJpeCwgcG9zLCBuKSB7XG4gIHJldHVybiBjYWxjdWxhdGUoaW52ZXJ0KG1hdHJpeCwgbiksIGNvbnZlcnRQb3NpdGlvbk1hdHJpeChwb3MsIG4pLCBuKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnREcmFnRGlzdChzdGF0ZSwgZSkge1xuICB2YXIgX2E7XG5cbiAgdmFyIGlzM2QgPSBzdGF0ZS5pczNkLFxuICAgICAgcm9vdE1hdHJpeCA9IHN0YXRlLnJvb3RNYXRyaXg7XG4gIHZhciBuID0gaXMzZCA/IDQgOiAzO1xuICBfYSA9IGNhbGN1bGF0ZUludmVyc2VQb3NpdGlvbihyb290TWF0cml4LCBbZS5kaXN0WCwgZS5kaXN0WV0sIG4pLCBlLmRpc3RYID0gX2FbMF0sIGUuZGlzdFkgPSBfYVsxXTtcbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVQYWRkaW5nKG1hdHJpeCwgcG9zLCB0cmFuc2Zvcm1PcmlnaW4sIG9yaWdpbiwgbikge1xuICByZXR1cm4gbWludXMoY2FsY3VsYXRlUG9zaXRpb24obWF0cml4LCBwbHVzKHRyYW5zZm9ybU9yaWdpbiwgcG9zKSwgbiksIG9yaWdpbik7XG59XG5mdW5jdGlvbiBjb252ZXJ0Q1NTU2l6ZSh2YWx1ZSwgc2l6ZSwgaXNSZWxhdGl2ZSkge1xuICByZXR1cm4gaXNSZWxhdGl2ZSA/IHZhbHVlIC8gc2l6ZSAqIDEwMCArIFwiJVwiIDogdmFsdWUgKyBcInB4XCI7XG59XG5mdW5jdGlvbiBtb3ZlQ29udHJvbFBvcyhjb250cm9sUG9zZXMsIGluZGV4LCBkaXN0LCBpc1JlY3QpIHtcbiAgdmFyIF9hID0gY29udHJvbFBvc2VzW2luZGV4XSxcbiAgICAgIGRpcmVjdGlvbiA9IF9hLmRpcmVjdGlvbixcbiAgICAgIHN1YiA9IF9hLnN1YjtcbiAgdmFyIGRpc3RzID0gY29udHJvbFBvc2VzLm1hcChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFswLCAwXTtcbiAgfSk7XG4gIHZhciBkaXJlY3Rpb25zID0gZGlyZWN0aW9uID8gZGlyZWN0aW9uLnNwbGl0KFwiXCIpIDogW107XG5cbiAgaWYgKGlzUmVjdCAmJiBpbmRleCA8IDgpIHtcbiAgICB2YXIgdmVydGljYWxEaXJlY3Rpb25fMSA9IGRpcmVjdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChkaXIpIHtcbiAgICAgIHJldHVybiBkaXIgPT09IFwid1wiIHx8IGRpciA9PT0gXCJlXCI7XG4gICAgfSlbMF07XG4gICAgdmFyIGhvcml6b250YWxEaXJlY3Rpb25fMSA9IGRpcmVjdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChkaXIpIHtcbiAgICAgIHJldHVybiBkaXIgPT09IFwiblwiIHx8IGRpciA9PT0gXCJzXCI7XG4gICAgfSlbMF07XG4gICAgZGlzdHNbaW5kZXhdID0gZGlzdDtcbiAgICBjb250cm9sUG9zZXMuZm9yRWFjaChmdW5jdGlvbiAoY29udHJvbFBvc2UsIGkpIHtcbiAgICAgIHZhciBjb250cm9sRGlyID0gY29udHJvbFBvc2UuZGlyZWN0aW9uO1xuXG4gICAgICBpZiAoIWNvbnRyb2xEaXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29udHJvbERpci5pbmRleE9mKHZlcnRpY2FsRGlyZWN0aW9uXzEpID4gLTEpIHtcbiAgICAgICAgZGlzdHNbaV1bMF0gPSBkaXN0WzBdO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29udHJvbERpci5pbmRleE9mKGhvcml6b250YWxEaXJlY3Rpb25fMSkgPiAtMSkge1xuICAgICAgICBkaXN0c1tpXVsxXSA9IGRpc3RbMV07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAodmVydGljYWxEaXJlY3Rpb25fMSkge1xuICAgICAgZGlzdHNbMV1bMF0gPSBkaXN0WzBdIC8gMjtcbiAgICAgIGRpc3RzWzVdWzBdID0gZGlzdFswXSAvIDI7XG4gICAgfVxuXG4gICAgaWYgKGhvcml6b250YWxEaXJlY3Rpb25fMSkge1xuICAgICAgZGlzdHNbM11bMV0gPSBkaXN0WzFdIC8gMjtcbiAgICAgIGRpc3RzWzddWzFdID0gZGlzdFsxXSAvIDI7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRpcmVjdGlvbiAmJiAhc3ViKSB7XG4gICAgZGlyZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChkaXIpIHtcbiAgICAgIHZhciBpc1ZlcnRpY2FsID0gZGlyID09PSBcIm5cIiB8fCBkaXIgPT09IFwic1wiO1xuICAgICAgY29udHJvbFBvc2VzLmZvckVhY2goZnVuY3Rpb24gKGNvbnRyb2xQb3NlLCBpKSB7XG4gICAgICAgIHZhciBkaXJEaXIgPSBjb250cm9sUG9zZS5kaXJlY3Rpb24sXG4gICAgICAgICAgICBkaXJIb3Jpem9udGFsID0gY29udHJvbFBvc2UuaG9yaXpvbnRhbCxcbiAgICAgICAgICAgIGRpclZlcnRpY2FsID0gY29udHJvbFBvc2UudmVydGljYWw7XG5cbiAgICAgICAgaWYgKCFkaXJEaXIgfHwgZGlyRGlyLmluZGV4T2YoZGlyKSA9PT0gLTEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBkaXN0c1tpXSA9IFtpc1ZlcnRpY2FsIHx8ICFkaXJIb3Jpem9udGFsID8gMCA6IGRpc3RbMF0sICFpc1ZlcnRpY2FsIHx8ICFkaXJWZXJ0aWNhbCA/IDAgOiBkaXN0WzFdXTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGRpc3RzW2luZGV4XSA9IGRpc3Q7XG4gIH1cblxuICByZXR1cm4gZGlzdHM7XG59XG5mdW5jdGlvbiBnZXRUaW55RGlzdCh2KSB7XG4gIHJldHVybiBNYXRoLmFicyh2KSA8PSBUSU5ZX05VTSA/IDAgOiB2O1xufVxuZnVuY3Rpb24gZGlyZWN0aW9uQ29uZGl0aW9uKG1vdmVhYmxlLCBlKSB7XG4gIGlmIChlLmlzUmVxdWVzdCkge1xuICAgIGlmIChlLnJlcXVlc3RBYmxlID09PSBcInJlc2l6YWJsZVwiIHx8IGUucmVxdWVzdEFibGUgPT09IFwic2NhbGFibGVcIikge1xuICAgICAgcmV0dXJuIGUucGFyZW50RGlyZWN0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGhhc0NsYXNzKGUuaW5wdXRFdmVudC50YXJnZXQsIHByZWZpeChcImRpcmVjdGlvblwiKSk7XG59XG5mdW5jdGlvbiBpbnZlcnRPYmplY3Qob2JqKSB7XG4gIHZhciBuZXh0T2JqID0ge307XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBvYmopIHtcbiAgICBuZXh0T2JqW29ialtuYW1lXV0gPSBuYW1lO1xuICB9XG5cbiAgcmV0dXJuIG5leHRPYmo7XG59XG5mdW5jdGlvbiBnZXRUcmFuc2Zvcm0odHJhbnNmb3JtcywgaW5kZXgpIHtcbiAgdmFyIGJlZm9yZUZ1bmN0aW9uVGV4dHMgPSB0cmFuc2Zvcm1zLnNsaWNlKDAsIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGluZGV4KTtcbiAgdmFyIGJlZm9yZUZ1bmN0aW9uVGV4dHMyID0gdHJhbnNmb3Jtcy5zbGljZSgwLCBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBpbmRleCArIDEpO1xuICB2YXIgdGFyZ2V0RnVuY3Rpb25UZXh0ID0gdHJhbnNmb3Jtc1tpbmRleF0gfHwgXCJcIjtcbiAgdmFyIGFmdGVyRnVuY3Rpb25UZXh0cyA9IGluZGV4IDwgMCA/IFtdIDogdHJhbnNmb3Jtcy5zbGljZShpbmRleCk7XG4gIHZhciBhZnRlckZ1bmN0aW9uVGV4dHMyID0gaW5kZXggPCAwID8gW10gOiB0cmFuc2Zvcm1zLnNsaWNlKGluZGV4ICsgMSk7XG4gIHZhciBiZWZvcmVGdW5jdGlvbnMgPSBwYXJzZShiZWZvcmVGdW5jdGlvblRleHRzKTtcbiAgdmFyIGJlZm9yZUZ1bmN0aW9uczIgPSBwYXJzZShiZWZvcmVGdW5jdGlvblRleHRzMik7XG4gIHZhciB0YXJnZXRGdW5jdGlvbnMgPSBwYXJzZShbdGFyZ2V0RnVuY3Rpb25UZXh0XSk7XG4gIHZhciBhZnRlckZ1bmN0aW9ucyA9IHBhcnNlKGFmdGVyRnVuY3Rpb25UZXh0cyk7XG4gIHZhciBhZnRlckZ1bmN0aW9uczIgPSBwYXJzZShhZnRlckZ1bmN0aW9uVGV4dHMyKTtcbiAgdmFyIGJlZm9yZUZ1bmN0aW9uTWF0cml4ID0gdG9NYXQoYmVmb3JlRnVuY3Rpb25zKTtcbiAgdmFyIGJlZm9yZUZ1bmN0aW9uTWF0cml4MiA9IHRvTWF0KGJlZm9yZUZ1bmN0aW9uczIpO1xuICB2YXIgYWZ0ZXJGdW5jdGlvbk1hdHJpeCA9IHRvTWF0KGFmdGVyRnVuY3Rpb25zKTtcbiAgdmFyIGFmdGVyRnVuY3Rpb25NYXRyaXgyID0gdG9NYXQoYWZ0ZXJGdW5jdGlvbnMyKTtcbiAgdmFyIGFsbEZ1bmN0aW9uTWF0cml4ID0gbXVsdGlwbHkoYmVmb3JlRnVuY3Rpb25NYXRyaXgsIGFmdGVyRnVuY3Rpb25NYXRyaXgsIDQpO1xuICByZXR1cm4ge1xuICAgIHRyYW5zZm9ybXM6IHRyYW5zZm9ybXMsXG4gICAgYmVmb3JlRnVuY3Rpb25NYXRyaXg6IGJlZm9yZUZ1bmN0aW9uTWF0cml4LFxuICAgIGJlZm9yZUZ1bmN0aW9uTWF0cml4MjogYmVmb3JlRnVuY3Rpb25NYXRyaXgyLFxuICAgIHRhcmdldEZ1bmN0aW9uTWF0cml4OiB0b01hdCh0YXJnZXRGdW5jdGlvbnMpLFxuICAgIGFmdGVyRnVuY3Rpb25NYXRyaXg6IGFmdGVyRnVuY3Rpb25NYXRyaXgsXG4gICAgYWZ0ZXJGdW5jdGlvbk1hdHJpeDI6IGFmdGVyRnVuY3Rpb25NYXRyaXgyLFxuICAgIGFsbEZ1bmN0aW9uTWF0cml4OiBhbGxGdW5jdGlvbk1hdHJpeCxcbiAgICBiZWZvcmVGdW5jdGlvbnM6IGJlZm9yZUZ1bmN0aW9ucyxcbiAgICBiZWZvcmVGdW5jdGlvbnMyOiBiZWZvcmVGdW5jdGlvbnMyLFxuICAgIHRhcmdldEZ1bmN0aW9uOiB0YXJnZXRGdW5jdGlvbnNbMF0sXG4gICAgYWZ0ZXJGdW5jdGlvbnM6IGFmdGVyRnVuY3Rpb25zLFxuICAgIGFmdGVyRnVuY3Rpb25zMjogYWZ0ZXJGdW5jdGlvbnMyLFxuICAgIGJlZm9yZUZ1bmN0aW9uVGV4dHM6IGJlZm9yZUZ1bmN0aW9uVGV4dHMsXG4gICAgYmVmb3JlRnVuY3Rpb25UZXh0czI6IGJlZm9yZUZ1bmN0aW9uVGV4dHMyLFxuICAgIHRhcmdldEZ1bmN0aW9uVGV4dDogdGFyZ2V0RnVuY3Rpb25UZXh0LFxuICAgIGFmdGVyRnVuY3Rpb25UZXh0czogYWZ0ZXJGdW5jdGlvblRleHRzLFxuICAgIGFmdGVyRnVuY3Rpb25UZXh0czI6IGFmdGVyRnVuY3Rpb25UZXh0czJcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzQXJyYXlGb3JtYXQoYXJyKSB7XG4gIGlmICghYXJyIHx8ICFpc09iamVjdChhcnIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzQXJyYXkoYXJyKSB8fCBcImxlbmd0aFwiIGluIGFycjtcbn1cbmZ1bmN0aW9uIGdldFJlZlRhcmdldCh0YXJnZXQsIGlzU2VsZWN0b3IpIHtcbiAgaWYgKCF0YXJnZXQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChpc1N0cmluZyh0YXJnZXQpKSB7XG4gICAgaWYgKGlzU2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIGlmIChpc0Z1bmN0aW9uKHRhcmdldCkpIHtcbiAgICByZXR1cm4gdGFyZ2V0KCk7XG4gIH1cblxuICBpZiAoXCJjdXJyZW50XCIgaW4gdGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRhcmdldC5jdXJyZW50O1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIGdldFJlZlRhcmdldHModGFyZ2V0cywgaXNTZWxlY3Rvcikge1xuICBpZiAoIXRhcmdldHMpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgdXNlclRhcmdldHMgPSBpc0FycmF5Rm9ybWF0KHRhcmdldHMpID8gW10uc2xpY2UuY2FsbCh0YXJnZXRzKSA6IFt0YXJnZXRzXTtcbiAgcmV0dXJuIHVzZXJUYXJnZXRzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgdGFyZ2V0KSB7XG4gICAgaWYgKGlzU3RyaW5nKHRhcmdldCkgJiYgaXNTZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgcHJldiksIFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0YXJnZXQpKSk7XG4gICAgfVxuXG4gICAgcHJldi5wdXNoKGdldFJlZlRhcmdldCh0YXJnZXQsIGlzU2VsZWN0b3IpKTtcbiAgICByZXR1cm4gcHJldjtcbiAgfSwgW10pO1xufVxuZnVuY3Rpb24gZ2V0RWxlbWVudFRhcmdldHModGFyZ2V0cywgc2VsZWN0b3JNYXApIHtcbiAgdmFyIGVsZW1lbnRUYXJnZXRzID0gW107XG4gIHRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNTdHJpbmcodGFyZ2V0KSkge1xuICAgICAgaWYgKHNlbGVjdG9yTWFwW3RhcmdldF0pIHtcbiAgICAgICAgZWxlbWVudFRhcmdldHMucHVzaC5hcHBseShlbGVtZW50VGFyZ2V0cywgc2VsZWN0b3JNYXBbdGFyZ2V0XSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbGVtZW50VGFyZ2V0cy5wdXNoKHRhcmdldCk7XG4gIH0pO1xuICByZXR1cm4gZWxlbWVudFRhcmdldHM7XG59XG5mdW5jdGlvbiBnZXRBYnNvbHV0ZVJvdGF0aW9uKHBvczEsIHBvczIsIGRpcmVjdGlvbikge1xuICB2YXIgZGVnID0gZ2V0UmFkKHBvczEsIHBvczIpIC8gTWF0aC5QSSAqIDE4MDtcbiAgZGVnID0gZGlyZWN0aW9uID49IDAgPyBkZWcgOiAxODAgLSBkZWc7XG4gIGRlZyA9IGRlZyA+PSAwID8gZGVnIDogMzYwICsgZGVnO1xuICByZXR1cm4gZGVnO1xufVxuZnVuY3Rpb24gZ2V0RHJhZ0Rpc3RCeVN0YXRlKHN0YXRlLCBkaXN0KSB7XG4gIHZhciByb290TWF0cml4ID0gc3RhdGUucm9vdE1hdHJpeCxcbiAgICAgIGlzM2QgPSBzdGF0ZS5pczNkO1xuICB2YXIgbiA9IGlzM2QgPyA0IDogMztcbiAgdmFyIGludmVyc2VNYXRyaXggPSBpbnZlcnQocm9vdE1hdHJpeCwgbik7XG5cbiAgaWYgKCFpczNkKSB7XG4gICAgaW52ZXJzZU1hdHJpeCA9IGNvbnZlcnREaW1lbnNpb24oaW52ZXJzZU1hdHJpeCwgMywgNCk7XG4gIH1cblxuICBpbnZlcnNlTWF0cml4WzEyXSA9IDA7XG4gIGludmVyc2VNYXRyaXhbMTNdID0gMDtcbiAgaW52ZXJzZU1hdHJpeFsxNF0gPSAwO1xuICByZXR1cm4gY2FsY3VsYXRlTWF0cml4RGlzdChpbnZlcnNlTWF0cml4LCBkaXN0KTtcbn1cblxuLyoqXG4gKiBAbmFtZXNwYWNlIE1vdmVhYmxlLlBpbmNoYWJsZVxuICogQGRlc2NyaXB0aW9uIFdoZXRoZXIgb3Igbm90IHRhcmdldCBjYW4gYmUgcGluY2hlZCB3aXRoIGRyYWdnYWJsZSwgcmVzaXphYmxlLCBzY2FsYWJsZSwgcm90YXRhYmxlIChkZWZhdWx0OiBmYWxzZSlcbiAqL1xuXG52YXIgUGluY2hhYmxlID0gbWFrZUFibGUoXCJwaW5jaGFibGVcIiwge1xuICBldmVudHM6IHtcbiAgICBvblBpbmNoU3RhcnQ6IFwicGluY2hTdGFydFwiLFxuICAgIG9uUGluY2g6IFwicGluY2hcIixcbiAgICBvblBpbmNoRW5kOiBcInBpbmNoRW5kXCIsXG4gICAgb25QaW5jaEdyb3VwU3RhcnQ6IFwicGluY2hHcm91cFN0YXJ0XCIsXG4gICAgb25QaW5jaEdyb3VwOiBcInBpbmNoR3JvdXBcIixcbiAgICBvblBpbmNoR3JvdXBFbmQ6IFwicGluY2hHcm91cEVuZFwiXG4gIH0sXG4gIGRyYWdTdGFydDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBwaW5jaFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB2YXIgZGF0YXMgPSBlLmRhdGFzLFxuICAgICAgICB0YXJnZXRzID0gZS50YXJnZXRzLFxuICAgICAgICBhbmdsZSA9IGUuYW5nbGUsXG4gICAgICAgIG9yaWdpbmFsRGF0YXMgPSBlLm9yaWdpbmFsRGF0YXM7XG4gICAgdmFyIF9hID0gbW92ZWFibGUucHJvcHMsXG4gICAgICAgIHBpbmNoYWJsZSA9IF9hLnBpbmNoYWJsZSxcbiAgICAgICAgYWJsZXMgPSBfYS5hYmxlcztcblxuICAgIGlmICghcGluY2hhYmxlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGV2ZW50TmFtZSA9IFwib25QaW5jaFwiICsgKHRhcmdldHMgPyBcIkdyb3VwXCIgOiBcIlwiKSArIFwiU3RhcnRcIjtcbiAgICB2YXIgY29udHJvbEV2ZW50TmFtZSA9IFwiZHJhZ1wiICsgKHRhcmdldHMgPyBcIkdyb3VwXCIgOiBcIlwiKSArIFwiQ29udHJvbFN0YXJ0XCI7XG4gICAgdmFyIHBpbmNoQWJsZXMgPSAocGluY2hhYmxlID09PSB0cnVlID8gbW92ZWFibGUuY29udHJvbEFibGVzIDogYWJsZXMuZmlsdGVyKGZ1bmN0aW9uIChhYmxlKSB7XG4gICAgICByZXR1cm4gcGluY2hhYmxlLmluZGV4T2YoYWJsZS5uYW1lKSA+IC0xO1xuICAgIH0pKS5maWx0ZXIoZnVuY3Rpb24gKGFibGUpIHtcbiAgICAgIHJldHVybiBhYmxlLmNhblBpbmNoICYmIGFibGVbY29udHJvbEV2ZW50TmFtZV07XG4gICAgfSk7XG4gICAgdmFyIHBhcmFtcyA9IGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIHt9KTtcblxuICAgIGlmICh0YXJnZXRzKSB7XG4gICAgICBwYXJhbXMudGFyZ2V0cyA9IHRhcmdldHM7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgZXZlbnROYW1lLCBwYXJhbXMpO1xuICAgIGRhdGFzLmlzUGluY2ggPSByZXN1bHQgIT09IGZhbHNlO1xuICAgIGRhdGFzLmFibGVzID0gcGluY2hBYmxlcztcbiAgICB2YXIgaXNQaW5jaCA9IGRhdGFzLmlzUGluY2g7XG5cbiAgICBpZiAoIWlzUGluY2gpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBwaW5jaEFibGVzLmZvckVhY2goZnVuY3Rpb24gKGFibGUpIHtcbiAgICAgIG9yaWdpbmFsRGF0YXNbYWJsZS5uYW1lXSA9IG9yaWdpbmFsRGF0YXNbYWJsZS5uYW1lXSB8fCB7fTtcblxuICAgICAgaWYgKCFhYmxlW2NvbnRyb2xFdmVudE5hbWVdKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGFibGVFdmVudCA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwge1xuICAgICAgICBkYXRhczogb3JpZ2luYWxEYXRhc1thYmxlLm5hbWVdLFxuICAgICAgICBwYXJlbnRSb3RhdGU6IGFuZ2xlLFxuICAgICAgICBpc1BpbmNoOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgYWJsZVtjb250cm9sRXZlbnROYW1lXShtb3ZlYWJsZSwgYWJsZUV2ZW50KTtcbiAgICB9KTtcbiAgICBtb3ZlYWJsZS5zdGF0ZS5zbmFwUmVuZGVySW5mbyA9IHtcbiAgICAgIHJlcXVlc3Q6IGUuaXNSZXF1ZXN0LFxuICAgICAgZGlyZWN0aW9uOiBbMCwgMF1cbiAgICB9O1xuICAgIHJldHVybiBpc1BpbmNoO1xuICB9LFxuICBwaW5jaDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIGRhdGFzID0gZS5kYXRhcyxcbiAgICAgICAgcGluY2hTY2FsZSA9IGUuc2NhbGUsXG4gICAgICAgIGRpc3RhbmNlID0gZS5kaXN0YW5jZSxcbiAgICAgICAgb3JpZ2luYWxEYXRhcyA9IGUub3JpZ2luYWxEYXRhcyxcbiAgICAgICAgaW5wdXRFdmVudCA9IGUuaW5wdXRFdmVudCxcbiAgICAgICAgdGFyZ2V0cyA9IGUudGFyZ2V0cyxcbiAgICAgICAgYW5nbGUgPSBlLmFuZ2xlO1xuXG4gICAgaWYgKCFkYXRhcy5pc1BpbmNoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBhcmVudERpc3RhbmNlID0gZGlzdGFuY2UgKiAoMSAtIDEgLyBwaW5jaFNjYWxlKTtcbiAgICB2YXIgcGFyYW1zID0gZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge30pO1xuXG4gICAgaWYgKHRhcmdldHMpIHtcbiAgICAgIHBhcmFtcy50YXJnZXRzID0gdGFyZ2V0cztcbiAgICB9XG5cbiAgICB2YXIgZXZlbnROYW1lID0gXCJvblBpbmNoXCIgKyAodGFyZ2V0cyA/IFwiR3JvdXBcIiA6IFwiXCIpO1xuICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgZXZlbnROYW1lLCBwYXJhbXMpO1xuICAgIHZhciBhYmxlcyA9IGRhdGFzLmFibGVzO1xuICAgIHZhciBjb250cm9sRXZlbnROYW1lID0gXCJkcmFnXCIgKyAodGFyZ2V0cyA/IFwiR3JvdXBcIiA6IFwiXCIpICsgXCJDb250cm9sXCI7XG4gICAgYWJsZXMuZm9yRWFjaChmdW5jdGlvbiAoYWJsZSkge1xuICAgICAgaWYgKCFhYmxlW2NvbnRyb2xFdmVudE5hbWVdKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgYWJsZVtjb250cm9sRXZlbnROYW1lXShtb3ZlYWJsZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7XG4gICAgICAgIGRhdGFzOiBvcmlnaW5hbERhdGFzW2FibGUubmFtZV0sXG4gICAgICAgIGlucHV0RXZlbnQ6IGlucHV0RXZlbnQsXG4gICAgICAgIHBhcmVudERpc3RhbmNlOiBwYXJlbnREaXN0YW5jZSxcbiAgICAgICAgcGFyZW50Um90YXRlOiBhbmdsZSxcbiAgICAgICAgaXNQaW5jaDogdHJ1ZVxuICAgICAgfSkpO1xuICAgIH0pO1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH0sXG4gIHBpbmNoRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB2YXIgZGF0YXMgPSBlLmRhdGFzLFxuICAgICAgICBpc1BpbmNoID0gZS5pc1BpbmNoLFxuICAgICAgICBpbnB1dEV2ZW50ID0gZS5pbnB1dEV2ZW50LFxuICAgICAgICB0YXJnZXRzID0gZS50YXJnZXRzLFxuICAgICAgICBvcmlnaW5hbERhdGFzID0gZS5vcmlnaW5hbERhdGFzO1xuXG4gICAgaWYgKCFkYXRhcy5pc1BpbmNoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGV2ZW50TmFtZSA9IFwib25QaW5jaFwiICsgKHRhcmdldHMgPyBcIkdyb3VwXCIgOiBcIlwiKSArIFwiRW5kXCI7XG4gICAgdmFyIHBhcmFtcyA9IGZpbGxFbmRQYXJhbXMobW92ZWFibGUsIGUsIHtcbiAgICAgIGlzRHJhZzogaXNQaW5jaFxuICAgIH0pO1xuXG4gICAgaWYgKHRhcmdldHMpIHtcbiAgICAgIHBhcmFtcy50YXJnZXRzID0gdGFyZ2V0cztcbiAgICB9XG5cbiAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIGV2ZW50TmFtZSwgcGFyYW1zKTtcbiAgICB2YXIgYWJsZXMgPSBkYXRhcy5hYmxlcztcbiAgICB2YXIgY29udHJvbEV2ZW50TmFtZSA9IFwiZHJhZ1wiICsgKHRhcmdldHMgPyBcIkdyb3VwXCIgOiBcIlwiKSArIFwiQ29udHJvbEVuZFwiO1xuICAgIGFibGVzLmZvckVhY2goZnVuY3Rpb24gKGFibGUpIHtcbiAgICAgIGlmICghYWJsZVtjb250cm9sRXZlbnROYW1lXSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGFibGVbY29udHJvbEV2ZW50TmFtZV0obW92ZWFibGUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwge1xuICAgICAgICBpc0RyYWc6IGlzUGluY2gsXG4gICAgICAgIGRhdGFzOiBvcmlnaW5hbERhdGFzW2FibGUubmFtZV0sXG4gICAgICAgIGlucHV0RXZlbnQ6IGlucHV0RXZlbnQsXG4gICAgICAgIGlzUGluY2g6IHRydWVcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgICByZXR1cm4gaXNQaW5jaDtcbiAgfSxcbiAgcGluY2hHcm91cFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5waW5jaFN0YXJ0KG1vdmVhYmxlLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHtcbiAgICAgIHRhcmdldHM6IG1vdmVhYmxlLnByb3BzLnRhcmdldHNcbiAgICB9KSk7XG4gIH0sXG4gIHBpbmNoR3JvdXA6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiB0aGlzLnBpbmNoKG1vdmVhYmxlLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHtcbiAgICAgIHRhcmdldHM6IG1vdmVhYmxlLnByb3BzLnRhcmdldHNcbiAgICB9KSk7XG4gIH0sXG4gIHBpbmNoR3JvdXBFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiB0aGlzLnBpbmNoRW5kKG1vdmVhYmxlLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHtcbiAgICAgIHRhcmdldHM6IG1vdmVhYmxlLnByb3BzLnRhcmdldHNcbiAgICB9KSk7XG4gIH1cbn0pO1xuLyoqXG4gKiBXaGV0aGVyIG9yIG5vdCB0YXJnZXQgY2FuIGJlIHBpbmNoZWQgd2l0aCBkcmFnZ2FibGUsIHJlc2l6YWJsZSwgc2NhbGFibGUsIHJvdGF0YWJsZSAoZGVmYXVsdDogZmFsc2UpXG4gKiBAbmFtZSBNb3ZlYWJsZS5QaW5jaGFibGUjcGluY2hhYmxlXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICpcbiAqIG1vdmVhYmxlLnBpbmNoYWJsZSA9IHRydWU7XG4gKi9cblxuLyoqXG4gKiBXaGVuIHRoZSBwaW5jaCBzdGFydHMsIHRoZSBwaW5jaFN0YXJ0IGV2ZW50IGlzIGNhbGxlZCB3aXRoIHBhcnQgb2Ygc2NhbGVTdGFydCwgcm90YXRlU3RhcnQsIHJlc2l6ZVN0YXJ0XG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuUGluY2hhYmxlXG4gKiBAZXZlbnQgcGluY2hTdGFydFxuICogQHBhcmFtIHtNb3ZlYWJsZS5QaW5jaGFibGUuT25QaW5jaFN0YXJ0fSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBwaW5jaFN0YXJ0IGV2ZW50XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgICByb3RhdGFibGU6IHRydWUsXG4gKiAgICAgc2NhbGFibGU6IHRydWUsXG4gKiAgICAgcGluY2hhYmxlOiB0cnVlLCAvLyBbXCJyb3RhdGFibGVcIiwgXCJzY2FsYWJsZVwiXVxuICogfSk7XG4gKiBtb3ZlYWJsZS5vbihcInBpbmNoU3RhcnRcIiwgKHsgdGFyZ2V0IH0pID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyh0YXJnZXQpO1xuICogfSk7XG4gKiBtb3ZlYWJsZS5vbihcInJvdGF0ZVN0YXJ0XCIsICh7IHRhcmdldCB9KSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2codGFyZ2V0KTtcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJzY2FsZVN0YXJ0XCIsICh7IHRhcmdldCB9KSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2codGFyZ2V0KTtcbiAqIH0pO1xuICovXG5cbi8qKlxuICogV2hlbiBwaW5jaGluZywgdGhlIHBpbmNoIGV2ZW50IGlzIGNhbGxlZCB3aXRoIHBhcnQgb2Ygc2NhbGUsIHJvdGF0ZSwgcmVzaXplXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuUGluY2hhYmxlXG4gKiBAZXZlbnQgcGluY2hcbiAqIEBwYXJhbSB7TW92ZWFibGUuUGluY2hhYmxlLk9uUGluY2h9IC0gUGFyYW1ldGVycyBmb3IgdGhlIHBpbmNoIGV2ZW50XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgICByb3RhdGFibGU6IHRydWUsXG4gKiAgICAgc2NhbGFibGU6IHRydWUsXG4gKiAgICAgcGluY2hhYmxlOiB0cnVlLCAvLyBbXCJyb3RhdGFibGVcIiwgXCJzY2FsYWJsZVwiXVxuICogfSk7XG4gKiBtb3ZlYWJsZS5vbihcInBpbmNoXCIsICh7IHRhcmdldCB9KSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2codGFyZ2V0KTtcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJyb3RhdGVcIiwgKHsgdGFyZ2V0IH0pID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyh0YXJnZXQpO1xuICogfSk7XG4gKiBtb3ZlYWJsZS5vbihcInNjYWxlXCIsICh7IHRhcmdldCB9KSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2codGFyZ2V0KTtcbiAqIH0pO1xuICovXG5cbi8qKlxuICogV2hlbiB0aGUgcGluY2ggZmluaXNoZXMsIHRoZSBwaW5jaEVuZCBldmVudCBpcyBjYWxsZWQuXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuUGluY2hhYmxlXG4gKiBAZXZlbnQgcGluY2hFbmRcbiAqIEBwYXJhbSB7TW92ZWFibGUuUGluY2hhYmxlLk9uUGluY2hFbmR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIHBpbmNoRW5kIGV2ZW50XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgICByb3RhdGFibGU6IHRydWUsXG4gKiAgICAgc2NhbGFibGU6IHRydWUsXG4gKiAgICAgcGluY2hhYmxlOiB0cnVlLCAvLyBbXCJyb3RhdGFibGVcIiwgXCJzY2FsYWJsZVwiXVxuICogfSk7XG4gKiBtb3ZlYWJsZS5vbihcInBpbmNoRW5kXCIsICh7IHRhcmdldCB9KSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2codGFyZ2V0KTtcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJyb3RhdGVFbmRcIiwgKHsgdGFyZ2V0IH0pID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyh0YXJnZXQpO1xuICogfSk7XG4gKiBtb3ZlYWJsZS5vbihcInNjYWxlRW5kXCIsICh7IHRhcmdldCB9KSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2codGFyZ2V0KTtcbiAqIH0pO1xuICovXG5cbi8qKlxuICogV2hlbiB0aGUgZ3JvdXAgcGluY2ggc3RhcnRzLCB0aGUgYHBpbmNoR3JvdXBTdGFydGAgZXZlbnQgaXMgY2FsbGVkLlxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlBpbmNoYWJsZVxuICogQGV2ZW50IHBpbmNoR3JvdXBTdGFydFxuICogQHBhcmFtIHtNb3ZlYWJsZS5QaW5jaGFibGUuT25QaW5jaEdyb3VwU3RhcnR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGBwaW5jaEdyb3VwU3RhcnRgIGV2ZW50XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgICB0YXJnZXQ6IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi50YXJnZXRcIikpLFxuICogICAgIHBpbmNoYWJsZTogdHJ1ZVxuICogfSk7XG4gKiBtb3ZlYWJsZS5vbihcInBpbmNoR3JvdXBTdGFydFwiLCAoeyB0YXJnZXRzIH0pID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhcIm9uUGluY2hHcm91cFN0YXJ0XCIsIHRhcmdldHMpO1xuICogfSk7XG4gKi9cblxuLyoqXG4gKiBXaGVuIHRoZSBncm91cCBwaW5jaCwgdGhlIGBwaW5jaEdyb3VwYCBldmVudCBpcyBjYWxsZWQuXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuUGluY2hhYmxlXG4gKiBAZXZlbnQgcGluY2hHcm91cFxuICogQHBhcmFtIHtNb3ZlYWJsZS5QaW5jaGFibGUuT25QaW5jaEdyb3VwfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgcGluY2hHcm91cGAgZXZlbnRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICAgIHRhcmdldDogW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnRhcmdldFwiKSksXG4gKiAgICAgcGluY2hhYmxlOiB0cnVlXG4gKiB9KTtcbiAqIG1vdmVhYmxlLm9uKFwicGluY2hHcm91cFwiLCAoeyB0YXJnZXRzLCBldmVudHMgfSkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKFwib25QaW5jaEdyb3VwXCIsIHRhcmdldHMpO1xuICogfSk7XG4gKi9cblxuLyoqXG4gKiBXaGVuIHRoZSBncm91cCBwaW5jaCBmaW5pc2hlcywgdGhlIGBwaW5jaEdyb3VwRW5kYCBldmVudCBpcyBjYWxsZWQuXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuUGluY2hhYmxlXG4gKiBAZXZlbnQgcGluY2hHcm91cEVuZFxuICogQHBhcmFtIHtNb3ZlYWJsZS5QaW5jaGFibGUuT25QaW5jaEdyb3VwRW5kfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgcGluY2hHcm91cEVuZGAgZXZlbnRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICAgIHRhcmdldDogW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnRhcmdldFwiKSksXG4gKiAgICAgcGluY2hhYmxlOiB0cnVlXG4gKiB9KTtcbiAqIG1vdmVhYmxlLm9uKFwicGluY2hHcm91cEVuZFwiLCAoeyB0YXJnZXRzLCBpc0RyYWcgfSkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKFwib25QaW5jaEdyb3VwRW5kXCIsIHRhcmdldHMsIGlzRHJhZyk7XG4gKiB9KTtcbiAqL1xuXG5mdW5jdGlvbiBzZXRDdXN0b21EcmFnKGUsIHN0YXRlLCBkZWx0YSwgaXNQaW5jaCwgaXNDb252ZXJ0KSB7XG4gIHZhciByZXN1bHQgPSBzdGF0ZS5nZXN0by5tb3ZlKGRlbHRhLCBlLmlucHV0RXZlbnQpO1xuICB2YXIgZGF0YXMgPSByZXN1bHQub3JpZ2luYWxEYXRhcyB8fCByZXN1bHQuZGF0YXM7XG4gIHZhciBkcmFnZ2FibGVEYXRhcyA9IGRhdGFzLmRyYWdnYWJsZSB8fCAoZGF0YXMuZHJhZ2dhYmxlID0ge30pO1xuICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGlzQ29udmVydCA/IGNvbnZlcnREcmFnRGlzdChzdGF0ZSwgcmVzdWx0KSA6IHJlc3VsdCksIHtcbiAgICBpc0RyYWc6IHRydWUsXG4gICAgaXNQaW5jaDogISFpc1BpbmNoLFxuICAgIHBhcmVudEV2ZW50OiB0cnVlLFxuICAgIGRhdGFzOiBkcmFnZ2FibGVEYXRhcyxcbiAgICBvcmlnaW5hbERhdGFzOiBlLm9yaWdpbmFsRGF0YXNcbiAgfSk7XG59XG5cbnZhciBDdXN0b21HZXN0byA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEN1c3RvbUdlc3RvKCkge1xuICAgIHRoaXMucHJldlggPSAwO1xuICAgIHRoaXMucHJldlkgPSAwO1xuICAgIHRoaXMuc3RhcnRYID0gMDtcbiAgICB0aGlzLnN0YXJ0WSA9IDA7XG4gICAgdGhpcy5pc0RyYWcgPSBmYWxzZTtcbiAgICB0aGlzLmlzRmxhZyA9IGZhbHNlO1xuICAgIHRoaXMuZGF0YXMgPSB7XG4gICAgICBkcmFnZ2FibGU6IHt9XG4gICAgfTtcbiAgfVxuXG4gIHZhciBfX3Byb3RvID0gQ3VzdG9tR2VzdG8ucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8uZHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGNsaWVudCwgZSkge1xuICAgIHRoaXMuaXNEcmFnID0gZmFsc2U7XG4gICAgdGhpcy5pc0ZsYWcgPSBmYWxzZTtcbiAgICB2YXIgb3JpZ2luYWxEYXRhcyA9IGUub3JpZ2luYWxEYXRhcztcbiAgICB0aGlzLmRhdGFzID0gb3JpZ2luYWxEYXRhcztcblxuICAgIGlmICghb3JpZ2luYWxEYXRhcy5kcmFnZ2FibGUpIHtcbiAgICAgIG9yaWdpbmFsRGF0YXMuZHJhZ2dhYmxlID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCB0aGlzLm1vdmUoY2xpZW50LCBlLmlucHV0RXZlbnQpKSwge1xuICAgICAgdHlwZTogXCJkcmFnc3RhcnRcIlxuICAgIH0pO1xuICB9O1xuXG4gIF9fcHJvdG8uZHJhZyA9IGZ1bmN0aW9uIChjbGllbnQsIGlucHV0RXZlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5tb3ZlKFtjbGllbnRbMF0gLSB0aGlzLnByZXZYLCBjbGllbnRbMV0gLSB0aGlzLnByZXZZXSwgaW5wdXRFdmVudCk7XG4gIH07XG5cbiAgX19wcm90by5tb3ZlID0gZnVuY3Rpb24gKGRlbHRhLCBpbnB1dEV2ZW50KSB7XG4gICAgdmFyIGNsaWVudFg7XG4gICAgdmFyIGNsaWVudFk7XG5cbiAgICBpZiAoIXRoaXMuaXNGbGFnKSB7XG4gICAgICB0aGlzLnByZXZYID0gZGVsdGFbMF07XG4gICAgICB0aGlzLnByZXZZID0gZGVsdGFbMV07XG4gICAgICB0aGlzLnN0YXJ0WCA9IGRlbHRhWzBdO1xuICAgICAgdGhpcy5zdGFydFkgPSBkZWx0YVsxXTtcbiAgICAgIGNsaWVudFggPSBkZWx0YVswXTtcbiAgICAgIGNsaWVudFkgPSBkZWx0YVsxXTtcbiAgICAgIHRoaXMuaXNGbGFnID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xpZW50WCA9IHRoaXMucHJldlggKyBkZWx0YVswXTtcbiAgICAgIGNsaWVudFkgPSB0aGlzLnByZXZZICsgZGVsdGFbMV07XG4gICAgICB0aGlzLmlzRHJhZyA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5wcmV2WCA9IGNsaWVudFg7XG4gICAgdGhpcy5wcmV2WSA9IGNsaWVudFk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZHJhZ1wiLFxuICAgICAgY2xpZW50WDogY2xpZW50WCxcbiAgICAgIGNsaWVudFk6IGNsaWVudFksXG4gICAgICBpbnB1dEV2ZW50OiBpbnB1dEV2ZW50LFxuICAgICAgaXNEcmFnOiB0aGlzLmlzRHJhZyxcbiAgICAgIGRpc3RYOiBjbGllbnRYIC0gdGhpcy5zdGFydFgsXG4gICAgICBkaXN0WTogY2xpZW50WSAtIHRoaXMuc3RhcnRZLFxuICAgICAgZGVsdGFYOiBkZWx0YVswXSxcbiAgICAgIGRlbHRhWTogZGVsdGFbMV0sXG4gICAgICBkYXRhczogdGhpcy5kYXRhcy5kcmFnZ2FibGUsXG4gICAgICBvcmlnaW5hbERhdGFzOiB0aGlzLmRhdGFzLFxuICAgICAgcGFyZW50RXZlbnQ6IHRydWUsXG4gICAgICBwYXJlbnRHZXN0bzogdGhpc1xuICAgIH07XG4gIH07XG5cbiAgcmV0dXJuIEN1c3RvbUdlc3RvO1xufSgpO1xuXG5mdW5jdGlvbiBmaWxsQ2hpbGRFdmVudHMobW92ZWFibGUsIG5hbWUsIGUpIHtcbiAgdmFyIGRhdGFzID0gZS5vcmlnaW5hbERhdGFzO1xuICBkYXRhcy5ncm91cGFibGUgPSBkYXRhcy5ncm91cGFibGUgfHwge307XG4gIHZhciBncm91cGFibGVEYXRhcyA9IGRhdGFzLmdyb3VwYWJsZTtcbiAgZ3JvdXBhYmxlRGF0YXMuY2hpbGREYXRhcyA9IGdyb3VwYWJsZURhdGFzLmNoaWxkRGF0YXMgfHwgW107XG4gIHZhciBjaGlsZERhdGFzID0gZ3JvdXBhYmxlRGF0YXMuY2hpbGREYXRhcztcbiAgcmV0dXJuIG1vdmVhYmxlLm1vdmVhYmxlcy5tYXAoZnVuY3Rpb24gKF8sIGkpIHtcbiAgICBjaGlsZERhdGFzW2ldID0gY2hpbGREYXRhc1tpXSB8fCB7fTtcbiAgICBjaGlsZERhdGFzW2ldW25hbWVdID0gY2hpbGREYXRhc1tpXVtuYW1lXSB8fCB7fTtcbiAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7XG4gICAgICBkYXRhczogY2hpbGREYXRhc1tpXVtuYW1lXSxcbiAgICAgIG9yaWdpbmFsRGF0YXM6IGNoaWxkRGF0YXNbaV1cbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiB0cmlnZ2VyQ2hpbGRHZXN0byhtb3ZlYWJsZSwgYWJsZSwgdHlwZSwgZGVsdGEsIGUsIGlzQ29udmVydCkge1xuICB2YXIgaXNTdGFydCA9ICEhdHlwZS5tYXRjaCgvU3RhcnQkL2cpO1xuICB2YXIgaXNFbmQgPSAhIXR5cGUubWF0Y2goL0VuZCQvZyk7XG4gIHZhciBpc1BpbmNoID0gZS5pc1BpbmNoO1xuICB2YXIgZGF0YXMgPSBlLmRhdGFzO1xuICB2YXIgZXZlbnRzID0gZmlsbENoaWxkRXZlbnRzKG1vdmVhYmxlLCBhYmxlLm5hbWUsIGUpO1xuICB2YXIgbW92ZWFibGVzID0gbW92ZWFibGUubW92ZWFibGVzO1xuICB2YXIgY2hpbGRzID0gZXZlbnRzLm1hcChmdW5jdGlvbiAoZXYsIGkpIHtcbiAgICB2YXIgY2hpbGRNb3ZlYWJsZSA9IG1vdmVhYmxlc1tpXTtcbiAgICB2YXIgY2hpbGRFdmVudCA9IGV2O1xuXG4gICAgaWYgKGlzU3RhcnQpIHtcbiAgICAgIGNoaWxkRXZlbnQgPSBuZXcgQ3VzdG9tR2VzdG8oKS5kcmFnU3RhcnQoZGVsdGEsIGV2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFjaGlsZE1vdmVhYmxlLnN0YXRlLmdlc3RvKSB7XG4gICAgICAgIGNoaWxkTW92ZWFibGUuc3RhdGUuZ2VzdG8gPSBkYXRhcy5jaGlsZEdlc3Rvc1tpXTtcbiAgICAgIH1cblxuICAgICAgY2hpbGRFdmVudCA9IHNldEN1c3RvbURyYWcoZXYsIGNoaWxkTW92ZWFibGUuc3RhdGUsIGRlbHRhLCBpc1BpbmNoLCBpc0NvbnZlcnQpO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSBhYmxlW3R5cGVdKGNoaWxkTW92ZWFibGUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBjaGlsZEV2ZW50KSwge1xuICAgICAgcGFyZW50RmxhZzogdHJ1ZVxuICAgIH0pKTtcblxuICAgIGlmIChpc0VuZCkge1xuICAgICAgY2hpbGRNb3ZlYWJsZS5zdGF0ZS5nZXN0byA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSk7XG5cbiAgaWYgKGlzU3RhcnQpIHtcbiAgICBkYXRhcy5jaGlsZEdlc3RvcyA9IG1vdmVhYmxlcy5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICByZXR1cm4gY2hpbGQuc3RhdGUuZ2VzdG87XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gY2hpbGRzO1xufVxuZnVuY3Rpb24gdHJpZ2dlckNoaWxkQWJsZXMobW92ZWFibGUsIGFibGUsIHR5cGUsIGUsIGVhY2hFdmVudCwgY2FsbGJhY2spIHtcbiAgaWYgKGVhY2hFdmVudCA9PT0gdm9pZCAwKSB7XG4gICAgZWFjaEV2ZW50ID0gZnVuY3Rpb24gKF8sIGV2KSB7XG4gICAgICByZXR1cm4gZXY7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBpc0VuZCA9ICEhdHlwZS5tYXRjaCgvRW5kJC9nKTtcbiAgdmFyIGV2ZW50cyA9IGZpbGxDaGlsZEV2ZW50cyhtb3ZlYWJsZSwgYWJsZS5uYW1lLCBlKTtcbiAgdmFyIG1vdmVhYmxlcyA9IG1vdmVhYmxlLm1vdmVhYmxlcztcbiAgdmFyIGNoaWxkcyA9IGV2ZW50cy5tYXAoZnVuY3Rpb24gKGV2LCBpKSB7XG4gICAgdmFyIGNoaWxkTW92ZWFibGUgPSBtb3ZlYWJsZXNbaV07XG4gICAgdmFyIGNoaWxkRXZlbnQgPSBldjtcbiAgICBjaGlsZEV2ZW50ID0gZWFjaEV2ZW50KGNoaWxkTW92ZWFibGUsIGV2KTtcbiAgICB2YXIgcmVzdWx0ID0gYWJsZVt0eXBlXShjaGlsZE1vdmVhYmxlLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY2hpbGRFdmVudCksIHtcbiAgICAgIHBhcmVudEZsYWc6IHRydWVcbiAgICB9KSk7XG4gICAgcmVzdWx0ICYmIGNhbGxiYWNrICYmIGNhbGxiYWNrKGNoaWxkTW92ZWFibGUsIGV2LCByZXN1bHQsIGkpO1xuXG4gICAgaWYgKGlzRW5kKSB7XG4gICAgICBjaGlsZE1vdmVhYmxlLnN0YXRlLmdlc3RvID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KTtcbiAgcmV0dXJuIGNoaWxkcztcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlUG9pbnRlckRpc3QobW92ZWFibGUsIGUpIHtcbiAgdmFyIGNsaWVudFggPSBlLmNsaWVudFgsXG4gICAgICBjbGllbnRZID0gZS5jbGllbnRZLFxuICAgICAgZGF0YXMgPSBlLmRhdGFzO1xuICB2YXIgX2EgPSBtb3ZlYWJsZS5zdGF0ZSxcbiAgICAgIG1vdmVhYmxlQ2xpZW50UmVjdCA9IF9hLm1vdmVhYmxlQ2xpZW50UmVjdCxcbiAgICAgIHJvb3RNYXRyaXggPSBfYS5yb290TWF0cml4LFxuICAgICAgaXMzZCA9IF9hLmlzM2QsXG4gICAgICBwb3MxID0gX2EucG9zMTtcbiAgdmFyIGxlZnQgPSBtb3ZlYWJsZUNsaWVudFJlY3QubGVmdCxcbiAgICAgIHRvcCA9IG1vdmVhYmxlQ2xpZW50UmVjdC50b3A7XG4gIHZhciBuID0gaXMzZCA/IDQgOiAzO1xuXG4gIHZhciBfYiA9IG1pbnVzKGNhbGN1bGF0ZUludmVyc2VQb3NpdGlvbihyb290TWF0cml4LCBbY2xpZW50WCAtIGxlZnQsIGNsaWVudFkgLSB0b3BdLCBuKSwgcG9zMSksXG4gICAgICBwb3NYID0gX2JbMF0sXG4gICAgICBwb3NZID0gX2JbMV07XG5cbiAgdmFyIF9jID0gZ2V0RHJhZ0Rpc3Qoe1xuICAgIGRhdGFzOiBkYXRhcyxcbiAgICBkaXN0WDogcG9zWCxcbiAgICBkaXN0WTogcG9zWVxuICB9KSxcbiAgICAgIGRpc3RYID0gX2NbMF0sXG4gICAgICBkaXN0WSA9IF9jWzFdO1xuXG4gIHJldHVybiBbZGlzdFgsIGRpc3RZXTtcbn1cbmZ1bmN0aW9uIHNldERyYWdTdGFydChtb3ZlYWJsZSwgX2EpIHtcbiAgdmFyIGRhdGFzID0gX2EuZGF0YXM7XG4gIHZhciBfYiA9IG1vdmVhYmxlLnN0YXRlLFxuICAgICAgYWxsTWF0cml4ID0gX2IuYWxsTWF0cml4LFxuICAgICAgYmVmb3JlTWF0cml4ID0gX2IuYmVmb3JlTWF0cml4LFxuICAgICAgaXMzZCA9IF9iLmlzM2QsXG4gICAgICBsZWZ0ID0gX2IubGVmdCxcbiAgICAgIHRvcCA9IF9iLnRvcCxcbiAgICAgIG9yaWdpbiA9IF9iLm9yaWdpbixcbiAgICAgIG9mZnNldE1hdHJpeCA9IF9iLm9mZnNldE1hdHJpeCxcbiAgICAgIHRhcmdldE1hdHJpeCA9IF9iLnRhcmdldE1hdHJpeCxcbiAgICAgIHRyYW5zZm9ybU9yaWdpbiA9IF9iLnRyYW5zZm9ybU9yaWdpbjtcbiAgdmFyIG4gPSBpczNkID8gNCA6IDM7XG4gIGRhdGFzLmlzM2QgPSBpczNkO1xuICBkYXRhcy5tYXRyaXggPSBhbGxNYXRyaXg7XG4gIGRhdGFzLnRhcmdldE1hdHJpeCA9IHRhcmdldE1hdHJpeDtcbiAgZGF0YXMuYmVmb3JlTWF0cml4ID0gYmVmb3JlTWF0cml4O1xuICBkYXRhcy5vZmZzZXRNYXRyaXggPSBvZmZzZXRNYXRyaXg7XG4gIGRhdGFzLnRyYW5zZm9ybU9yaWdpbiA9IHRyYW5zZm9ybU9yaWdpbjtcbiAgZGF0YXMuaW52ZXJzZU1hdHJpeCA9IGludmVydChhbGxNYXRyaXgsIG4pO1xuICBkYXRhcy5pbnZlcnNlQmVmb3JlTWF0cml4ID0gaW52ZXJ0KGJlZm9yZU1hdHJpeCwgbik7XG4gIGRhdGFzLmFic29sdXRlT3JpZ2luID0gY29udmVydFBvc2l0aW9uTWF0cml4KHBsdXMoW2xlZnQsIHRvcF0sIG9yaWdpbiksIG4pO1xuICBkYXRhcy5zdGFydERyYWdCZWZvcmVEaXN0ID0gY2FsY3VsYXRlKGRhdGFzLmludmVyc2VCZWZvcmVNYXRyaXgsIGRhdGFzLmFic29sdXRlT3JpZ2luLCBuKTtcbiAgZGF0YXMuc3RhcnREcmFnRGlzdCA9IGNhbGN1bGF0ZShkYXRhcy5pbnZlcnNlTWF0cml4LCBkYXRhcy5hYnNvbHV0ZU9yaWdpbiwgbik7XG59XG5mdW5jdGlvbiBnZXRUcmFuc2Zvcm1EaXJlY3Rpb24oZSkge1xuICByZXR1cm4gY2FsY3VsYXRlTW92ZWFibGVQb3NpdGlvbihlLmRhdGFzLmJlZm9yZVRyYW5zZm9ybSwgWzUwLCA1MF0sIDEwMCwgMTAwKS5kaXJlY3Rpb247XG59XG5mdW5jdGlvbiByZXNvbHZlVHJhbnNmb3JtRXZlbnQoZXZlbnQsIGZ1bmN0aW9uTmFtZSkge1xuICB2YXIgZGF0YXMgPSBldmVudC5kYXRhcyxcbiAgICAgIG9yaWdpbmFsRGF0YXMgPSBldmVudC5vcmlnaW5hbERhdGFzLmJlZm9yZVJlbmRlcmFibGU7XG4gIHZhciBpbmRleCA9IGRhdGFzLnRyYW5zZm9ybUluZGV4O1xuICB2YXIgbmV4dFRyYW5zZm9ybXMgPSBvcmlnaW5hbERhdGFzLm5leHRUcmFuc2Zvcm1zO1xuICB2YXIgbmV4dFRyYW5zZm9ybUFwcGVuZGVkSW5kZXhlcyA9IG9yaWdpbmFsRGF0YXMubmV4dFRyYW5zZm9ybUFwcGVuZGVkSW5kZXhlcztcbiAgdmFyIG5leHRJbmRleCA9IDA7XG5cbiAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgIG5leHRJbmRleCA9IG5leHRUcmFuc2Zvcm1zLmxlbmd0aDtcbiAgICBkYXRhcy50cmFuc2Zvcm1JbmRleCA9IG5leHRJbmRleDtcbiAgfSBlbHNlIHtcbiAgICBuZXh0SW5kZXggPSBpbmRleCArIG5leHRUcmFuc2Zvcm1BcHBlbmRlZEluZGV4ZXMuZmlsdGVyKGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gaSA8IGluZGV4O1xuICAgIH0pLmxlbmd0aDtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBnZXRUcmFuc2Zvcm0obmV4dFRyYW5zZm9ybXMsIG5leHRJbmRleCk7XG4gIHZhciB0YXJnZXRGdW5jdGlvbiA9IHJlc3VsdC50YXJnZXRGdW5jdGlvbjtcbiAgdmFyIG1hdEZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uTmFtZSA9PT0gXCJyb3RhdGVcIiA/IFwicm90YXRlWlwiIDogZnVuY3Rpb25OYW1lO1xuICBkYXRhcy5iZWZvcmVGdW5jdGlvblRleHRzID0gcmVzdWx0LmJlZm9yZUZ1bmN0aW9uVGV4dHM7XG4gIGRhdGFzLmFmdGVyRnVuY3Rpb25UZXh0cyA9IHJlc3VsdC5hZnRlckZ1bmN0aW9uVGV4dHM7XG4gIGRhdGFzLmJlZm9yZVRyYW5zZm9ybSA9IHJlc3VsdC5iZWZvcmVGdW5jdGlvbk1hdHJpeDtcbiAgZGF0YXMuYmVmb3JlVHJhbnNmb3JtMiA9IHJlc3VsdC5iZWZvcmVGdW5jdGlvbk1hdHJpeDI7XG4gIGRhdGFzLnRhcmdldFRhbnNmb3JtID0gcmVzdWx0LnRhcmdldEZ1bmN0aW9uTWF0cml4O1xuICBkYXRhcy5hZnRlclRyYW5zZm9ybSA9IHJlc3VsdC5hZnRlckZ1bmN0aW9uTWF0cml4O1xuICBkYXRhcy5hZnRlclRyYW5zZm9ybTIgPSByZXN1bHQuYWZ0ZXJGdW5jdGlvbk1hdHJpeDI7XG4gIGRhdGFzLnRhcmdldEFsbFRyYW5zZm9ybSA9IHJlc3VsdC5hbGxGdW5jdGlvbk1hdHJpeDtcblxuICBpZiAodGFyZ2V0RnVuY3Rpb24uZnVuY3Rpb25OYW1lID09PSBtYXRGdW5jdGlvbk5hbWUpIHtcbiAgICBkYXRhcy5hZnRlckZ1bmN0aW9uVGV4dHMuc3BsaWNlKDAsIDEpO1xuICAgIGRhdGFzLmlzQXBwZW5kVHJhbnNmb3JtID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgZGF0YXMuaXNBcHBlbmRUcmFuc2Zvcm0gPSB0cnVlO1xuICAgIG9yaWdpbmFsRGF0YXMubmV4dFRyYW5zZm9ybUFwcGVuZGVkSW5kZXhlcyA9IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgbmV4dFRyYW5zZm9ybUFwcGVuZGVkSW5kZXhlcyksIFtuZXh0SW5kZXhdKTtcbiAgfVxufVxuZnVuY3Rpb24gY29udmVydFRyYW5zZm9ybUZvcm1hdChkYXRhcywgdmFsdWUsIGRpc3QpIHtcbiAgcmV0dXJuIGRhdGFzLmJlZm9yZUZ1bmN0aW9uVGV4dHMuam9pbihcIiBcIikgKyBcIiBcIiArIChkYXRhcy5pc0FwcGVuZFRyYW5zZm9ybSA/IGRpc3QgOiB2YWx1ZSkgKyBcIiBcIiArIGRhdGFzLmFmdGVyRnVuY3Rpb25UZXh0cy5qb2luKFwiIFwiKTtcbn1cbmZ1bmN0aW9uIGdldFRyYW5zZm9ybURpc3QoX2EpIHtcbiAgdmFyIGRhdGFzID0gX2EuZGF0YXMsXG4gICAgICBkaXN0WCA9IF9hLmRpc3RYLFxuICAgICAgZGlzdFkgPSBfYS5kaXN0WTtcblxuICB2YXIgX2IgPSBnZXRCZWZvcmVEcmFnRGlzdCh7XG4gICAgZGF0YXM6IGRhdGFzLFxuICAgIGRpc3RYOiBkaXN0WCxcbiAgICBkaXN0WTogZGlzdFlcbiAgfSksXG4gICAgICBieCA9IF9iWzBdLFxuICAgICAgYnkgPSBfYlsxXTsgLy8gQiAqIFt0eCwgdHldICogQSA9IFtieCwgYnldICogdGFyZ2V0TWF0cml4O1xuICAvLyBbdHgsIHR5XSA9IEItMSAqIFtieCwgYnldICogdGFyZ2V0TWF0cml4ICogQS0xICogWzAsIDBdO1xuXG5cbiAgdmFyIHJlcyA9IGdldFRyYW5zZnJvbU1hdHJpeChkYXRhcywgZnJvbVRyYW5zbGF0aW9uKFtieCwgYnldLCA0KSk7XG4gIHJldHVybiBjYWxjdWxhdGUocmVzLCBjb252ZXJ0UG9zaXRpb25NYXRyaXgoWzAsIDAsIDBdLCA0KSwgNCk7XG59XG5mdW5jdGlvbiBnZXRUcmFuc2Zyb21NYXRyaXgoZGF0YXMsIHRhcmdldE1hdHJpeCwgaXNBZnRlcikge1xuICB2YXIgYmVmb3JlVHJhbnNmb3JtID0gZGF0YXMuYmVmb3JlVHJhbnNmb3JtLFxuICAgICAgYWZ0ZXJUcmFuc2Zvcm0gPSBkYXRhcy5hZnRlclRyYW5zZm9ybSxcbiAgICAgIGJlZm9yZVRyYW5zZm9ybTIgPSBkYXRhcy5iZWZvcmVUcmFuc2Zvcm0yLFxuICAgICAgYWZ0ZXJUcmFuc2Zvcm0yID0gZGF0YXMuYWZ0ZXJUcmFuc2Zvcm0yLFxuICAgICAgdGFyZ2V0QWxsVHJhbnNmb3JtID0gZGF0YXMudGFyZ2V0QWxsVHJhbnNmb3JtOyAvLyBCICogYWZ0ZXJUYXJnZXRNYXRyaXggKiBBID0gKHRhcmdldE1hdHJpeCAqIHRhcmdldEFsbFRyYW5zZm9ybSlcbiAgLy8gYWZ0ZXJUYXJnZXRNYXRyaXggPSBCLTEgKiB0YXJnZXRNYXRyaXggKiB0YXJnZXRBbGxUcmFuc2Zvcm0gKiBBLTFcbiAgLy8gbmV4dFRhcmdldE1hdHJpeCA9ICh0YXJnZXRNYXRyaXggKiB0YXJnZXRBbGxUcmFuc2Zvcm0pXG5cbiAgdmFyIG5leHRUYXJnZXRNYXRyaXggPSBpc0FmdGVyID8gbXVsdGlwbHkodGFyZ2V0QWxsVHJhbnNmb3JtLCB0YXJnZXRNYXRyaXgsIDQpIDogbXVsdGlwbHkodGFyZ2V0TWF0cml4LCB0YXJnZXRBbGxUcmFuc2Zvcm0sIDQpOyAvLyByZXMxID0gQi0xICogbmV4dFRhcmdldE1hdHJpeFxuXG4gIHZhciByZXMxID0gbXVsdGlwbHkoaW52ZXJ0KGlzQWZ0ZXIgPyBiZWZvcmVUcmFuc2Zvcm0yIDogYmVmb3JlVHJhbnNmb3JtLCA0KSwgbmV4dFRhcmdldE1hdHJpeCwgNCk7IC8vIHJlczMgPSByZXMyICogQS0xXG5cbiAgdmFyIGFmdGVyVGFyZ2V0TWF0cml4ID0gbXVsdGlwbHkocmVzMSwgaW52ZXJ0KGlzQWZ0ZXIgPyBhZnRlclRyYW5zZm9ybTIgOiBhZnRlclRyYW5zZm9ybSwgNCksIDQpO1xuICByZXR1cm4gYWZ0ZXJUYXJnZXRNYXRyaXg7XG59XG5mdW5jdGlvbiBnZXRCZWZvcmVEcmFnRGlzdChfYSkge1xuICB2YXIgZGF0YXMgPSBfYS5kYXRhcyxcbiAgICAgIGRpc3RYID0gX2EuZGlzdFgsXG4gICAgICBkaXN0WSA9IF9hLmRpc3RZOyAvLyBUVCA9IEJUXG5cbiAgdmFyIGludmVyc2VCZWZvcmVNYXRyaXggPSBkYXRhcy5pbnZlcnNlQmVmb3JlTWF0cml4LFxuICAgICAgaXMzZCA9IGRhdGFzLmlzM2QsXG4gICAgICBzdGFydERyYWdCZWZvcmVEaXN0ID0gZGF0YXMuc3RhcnREcmFnQmVmb3JlRGlzdCxcbiAgICAgIGFic29sdXRlT3JpZ2luID0gZGF0YXMuYWJzb2x1dGVPcmlnaW47XG4gIHZhciBuID0gaXMzZCA/IDQgOiAzOyAvLyBBQlNfT1JJR0lOICogW2Rpc3RYLCBkaXN0WV0gPSBCTSAqIChPUklHSU4gKyBbdHgsIHR5XSlcbiAgLy8gQk0gLTEgKiBBQlNfT1JJR0lOICogW2Rpc3RYLCBkaXN0WV0gLSBPUklHSU4gPSBbdHgsIHR5XVxuXG4gIHJldHVybiBtaW51cyhjYWxjdWxhdGUoaW52ZXJzZUJlZm9yZU1hdHJpeCwgcGx1cyhhYnNvbHV0ZU9yaWdpbiwgW2Rpc3RYLCBkaXN0WV0pLCBuKSwgc3RhcnREcmFnQmVmb3JlRGlzdCk7XG59XG5mdW5jdGlvbiBnZXREcmFnRGlzdChfYSwgaXNCZWZvcmUpIHtcbiAgdmFyIGRhdGFzID0gX2EuZGF0YXMsXG4gICAgICBkaXN0WCA9IF9hLmRpc3RYLFxuICAgICAgZGlzdFkgPSBfYS5kaXN0WTtcbiAgdmFyIGludmVyc2VCZWZvcmVNYXRyaXggPSBkYXRhcy5pbnZlcnNlQmVmb3JlTWF0cml4LFxuICAgICAgaW52ZXJzZU1hdHJpeCA9IGRhdGFzLmludmVyc2VNYXRyaXgsXG4gICAgICBpczNkID0gZGF0YXMuaXMzZCxcbiAgICAgIHN0YXJ0RHJhZ0JlZm9yZURpc3QgPSBkYXRhcy5zdGFydERyYWdCZWZvcmVEaXN0LFxuICAgICAgc3RhcnREcmFnRGlzdCA9IGRhdGFzLnN0YXJ0RHJhZ0Rpc3QsXG4gICAgICBhYnNvbHV0ZU9yaWdpbiA9IGRhdGFzLmFic29sdXRlT3JpZ2luO1xuICB2YXIgbiA9IGlzM2QgPyA0IDogMztcbiAgcmV0dXJuIG1pbnVzKGNhbGN1bGF0ZShpc0JlZm9yZSA/IGludmVyc2VCZWZvcmVNYXRyaXggOiBpbnZlcnNlTWF0cml4LCBwbHVzKGFic29sdXRlT3JpZ2luLCBbZGlzdFgsIGRpc3RZXSksIG4pLCBpc0JlZm9yZSA/IHN0YXJ0RHJhZ0JlZm9yZURpc3QgOiBzdGFydERyYWdEaXN0KTtcbn1cbmZ1bmN0aW9uIGdldEludmVyc2VEcmFnRGlzdChfYSwgaXNCZWZvcmUpIHtcbiAgdmFyIGRhdGFzID0gX2EuZGF0YXMsXG4gICAgICBkaXN0WCA9IF9hLmRpc3RYLFxuICAgICAgZGlzdFkgPSBfYS5kaXN0WTtcbiAgdmFyIGJlZm9yZU1hdHJpeCA9IGRhdGFzLmJlZm9yZU1hdHJpeCxcbiAgICAgIG1hdHJpeCA9IGRhdGFzLm1hdHJpeCxcbiAgICAgIGlzM2QgPSBkYXRhcy5pczNkLFxuICAgICAgc3RhcnREcmFnQmVmb3JlRGlzdCA9IGRhdGFzLnN0YXJ0RHJhZ0JlZm9yZURpc3QsXG4gICAgICBzdGFydERyYWdEaXN0ID0gZGF0YXMuc3RhcnREcmFnRGlzdCxcbiAgICAgIGFic29sdXRlT3JpZ2luID0gZGF0YXMuYWJzb2x1dGVPcmlnaW47XG4gIHZhciBuID0gaXMzZCA/IDQgOiAzO1xuICByZXR1cm4gbWludXMoY2FsY3VsYXRlKGlzQmVmb3JlID8gYmVmb3JlTWF0cml4IDogbWF0cml4LCBwbHVzKGlzQmVmb3JlID8gc3RhcnREcmFnQmVmb3JlRGlzdCA6IHN0YXJ0RHJhZ0Rpc3QsIFtkaXN0WCwgZGlzdFldKSwgbiksIGFic29sdXRlT3JpZ2luKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVRyYW5zZm9ybU9yaWdpbih0cmFuc2Zvcm1PcmlnaW4sIHdpZHRoLCBoZWlnaHQsIHByZXZXaWR0aCwgcHJldkhlaWdodCwgcHJldk9yaWdpbikge1xuICBpZiAocHJldldpZHRoID09PSB2b2lkIDApIHtcbiAgICBwcmV2V2lkdGggPSB3aWR0aDtcbiAgfVxuXG4gIGlmIChwcmV2SGVpZ2h0ID09PSB2b2lkIDApIHtcbiAgICBwcmV2SGVpZ2h0ID0gaGVpZ2h0O1xuICB9XG5cbiAgaWYgKHByZXZPcmlnaW4gPT09IHZvaWQgMCkge1xuICAgIHByZXZPcmlnaW4gPSBbMCwgMF07XG4gIH1cblxuICBpZiAoIXRyYW5zZm9ybU9yaWdpbikge1xuICAgIHJldHVybiBwcmV2T3JpZ2luO1xuICB9XG5cbiAgcmV0dXJuIHRyYW5zZm9ybU9yaWdpbi5tYXAoZnVuY3Rpb24gKHBvcywgaSkge1xuICAgIHZhciBfYSA9IHNwbGl0VW5pdChwb3MpLFxuICAgICAgICB2YWx1ZSA9IF9hLnZhbHVlLFxuICAgICAgICB1bml0ID0gX2EudW5pdDtcblxuICAgIHZhciBwcmV2U2l6ZSA9IGkgPyBwcmV2SGVpZ2h0IDogcHJldldpZHRoO1xuICAgIHZhciBzaXplID0gaSA/IGhlaWdodCA6IHdpZHRoO1xuXG4gICAgaWYgKHBvcyA9PT0gXCIlXCIgfHwgaXNOYU4odmFsdWUpKSB7XG4gICAgICAvLyBubyB2YWx1ZSBidXQgJVxuICAgICAgdmFyIG1lYXN1cmVSYXRpbyA9IHByZXZTaXplID8gcHJldk9yaWdpbltpXSAvIHByZXZTaXplIDogMDtcbiAgICAgIHJldHVybiBzaXplICogbWVhc3VyZVJhdGlvO1xuICAgIH0gZWxzZSBpZiAodW5pdCAhPT0gXCIlXCIpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2l6ZSAqIHZhbHVlIC8gMTAwO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFBvc0luZGV4ZXNCeURpcmVjdGlvbihkaXJlY3Rpb24pIHtcbiAgdmFyIGluZGV4ZXMgPSBbXTtcblxuICBpZiAoZGlyZWN0aW9uWzFdID49IDApIHtcbiAgICBpZiAoZGlyZWN0aW9uWzBdID49IDApIHtcbiAgICAgIGluZGV4ZXMucHVzaCgzKTtcbiAgICB9XG5cbiAgICBpZiAoZGlyZWN0aW9uWzBdIDw9IDApIHtcbiAgICAgIGluZGV4ZXMucHVzaCgyKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZGlyZWN0aW9uWzFdIDw9IDApIHtcbiAgICBpZiAoZGlyZWN0aW9uWzBdID49IDApIHtcbiAgICAgIGluZGV4ZXMucHVzaCgxKTtcbiAgICB9XG5cbiAgICBpZiAoZGlyZWN0aW9uWzBdIDw9IDApIHtcbiAgICAgIGluZGV4ZXMucHVzaCgwKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5kZXhlcztcbn1cbmZ1bmN0aW9uIGdldFBvc2VzQnlEaXJlY3Rpb24ocG9zZXMsIGRpcmVjdGlvbikge1xuICAvKlxuICBbLTEsIC0xXShwb3MxKSAgICAgICBbMCwgLTFdKHBvczEscG9zMikgICAgICAgWzEsIC0xXShwb3MyKVxuICBbLTEsIDBdKHBvczEsIHBvczMpICAgICAgICAgICAgICAgICAgICAgICAgICAgWzEsIDBdKHBvczIsIHBvczQpXG4gIFstMSwgMV0ocG9zMykgICAgICAgIFswLCAxXShwb3MzLCBwb3M0KSAgICAgICBbMSwgMV0ocG9zNClcbiAgKi9cbiAgcmV0dXJuIGdldFBvc0luZGV4ZXNCeURpcmVjdGlvbihkaXJlY3Rpb24pLm1hcChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICByZXR1cm4gcG9zZXNbaW5kZXhdO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFBvc0J5RGlyZWN0aW9uKHBvc2VzLCBkaXJlY3Rpb24pIHtcbiAgLypcbiAgWy0xLCAtMV0ocG9zMSkgICAgICAgWzAsIC0xXShwb3MxLHBvczIpICAgICAgIFsxLCAtMV0ocG9zMilcbiAgWy0xLCAwXShwb3MxLCBwb3MzKSAgICAgICAgICAgICAgICAgICAgICAgICAgIFsxLCAwXShwb3MyLCBwb3M0KVxuICBbLTEsIDFdKHBvczMpICAgICAgICBbMCwgMV0ocG9zMywgcG9zNCkgICAgICAgWzEsIDFdKHBvczQpXG4gICovXG4gIHZhciBuZXh0UG9zZXMgPSBnZXRQb3Nlc0J5RGlyZWN0aW9uKHBvc2VzLCBkaXJlY3Rpb24pO1xuICByZXR1cm4gW2F2ZXJhZ2UobmV4dFBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgcmV0dXJuIHBvc1swXTtcbiAgfSkpLCBhdmVyYWdlKG5leHRQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgIHJldHVybiBwb3NbMV07XG4gIH0pKV07XG59XG5mdW5jdGlvbiBnZXRQb3NCeVJldmVyc2VEaXJlY3Rpb24ocG9zZXMsIGRpcmVjdGlvbikge1xuICAvKlxuICBbLTEsIC0xXShwb3M0KSAgICAgICBbMCwgLTFdKHBvczMscG9zNCkgICAgICAgWzEsIC0xXShwb3MzKVxuICBbLTEsIDBdKHBvczIsIHBvczQpICAgICAgICAgICAgICAgICAgICAgICAgICAgWzEsIDBdKHBvczMsIHBvczEpXG4gIFstMSwgMV0ocG9zMikgICAgICAgIFswLCAxXShwb3MxLCBwb3MyKSAgICAgICBbMSwgMV0ocG9zMSlcbiAgKi9cbiAgcmV0dXJuIGdldFBvc0J5RGlyZWN0aW9uKHBvc2VzLCBkaXJlY3Rpb24ubWFwKGZ1bmN0aW9uIChkaXIpIHtcbiAgICByZXR1cm4gLWRpcjtcbiAgfSkpO1xufVxuXG5mdW5jdGlvbiBnZXREaXN0KHN0YXJ0UG9zLCBtYXRyaXgsIHdpZHRoLCBoZWlnaHQsIG4sIGZpeGVkRGlyZWN0aW9uKSB7XG4gIHZhciBwb3NlcyA9IGNhbGN1bGF0ZVBvc2VzKG1hdHJpeCwgd2lkdGgsIGhlaWdodCwgbik7XG4gIHZhciBmaXhlZFBvcyA9IGdldFBvc0J5RGlyZWN0aW9uKHBvc2VzLCBmaXhlZERpcmVjdGlvbik7XG4gIHZhciBkaXN0WCA9IHN0YXJ0UG9zWzBdIC0gZml4ZWRQb3NbMF07XG4gIHZhciBkaXN0WSA9IHN0YXJ0UG9zWzFdIC0gZml4ZWRQb3NbMV07XG4gIHJldHVybiBbZGlzdFgsIGRpc3RZXTtcbn1cblxuZnVuY3Rpb24gZ2V0TmV4dE1hdHJpeChvZmZzZXRNYXRyaXgsIHRhcmdldE1hdHJpeCwgb3JpZ2luLCBuKSB7XG4gIHJldHVybiBtdWx0aXBseShvZmZzZXRNYXRyaXgsIGdldEFic29sdXRlTWF0cml4KHRhcmdldE1hdHJpeCwgbiwgb3JpZ2luKSwgbik7XG59XG5mdW5jdGlvbiBnZXROZXh0VHJhbnNmb3JtTWF0cml4KHN0YXRlLCBkYXRhcywgdHJhbnNmb3JtKSB7XG4gIHZhciB0cmFuc2Zvcm1PcmlnaW4gPSBzdGF0ZS50cmFuc2Zvcm1PcmlnaW4sXG4gICAgICBvZmZzZXRNYXRyaXggPSBzdGF0ZS5vZmZzZXRNYXRyaXgsXG4gICAgICBpczNkID0gc3RhdGUuaXMzZDtcbiAgdmFyIGJlZm9yZVRyYW5zZm9ybSA9IGRhdGFzLmJlZm9yZVRyYW5zZm9ybSxcbiAgICAgIGFmdGVyVHJhbnNmb3JtID0gZGF0YXMuYWZ0ZXJUcmFuc2Zvcm07XG4gIHZhciBuID0gaXMzZCA/IDQgOiAzO1xuICB2YXIgdGFyZ2V0VHJhbnNmb3JtID0gcGFyc2VNYXQoW3RyYW5zZm9ybV0pO1xuICByZXR1cm4gZ2V0TmV4dE1hdHJpeChvZmZzZXRNYXRyaXgsIGNvbnZlcnREaW1lbnNpb24obXVsdGlwbHkobXVsdGlwbHkoYmVmb3JlVHJhbnNmb3JtLCB0YXJnZXRUcmFuc2Zvcm0sIDQpLCBhZnRlclRyYW5zZm9ybSwgNCksIDQsIG4pLCB0cmFuc2Zvcm1PcmlnaW4sIG4pO1xufVxuZnVuY3Rpb24gc2NhbGVNYXRyaXgoc3RhdGUsIHNjYWxlKSB7XG4gIHZhciB0cmFuc2Zvcm1PcmlnaW4gPSBzdGF0ZS50cmFuc2Zvcm1PcmlnaW4sXG4gICAgICBvZmZzZXRNYXRyaXggPSBzdGF0ZS5vZmZzZXRNYXRyaXgsXG4gICAgICBpczNkID0gc3RhdGUuaXMzZCxcbiAgICAgIHRhcmdldE1hdHJpeCA9IHN0YXRlLnRhcmdldE1hdHJpeDtcbiAgdmFyIG4gPSBpczNkID8gNCA6IDM7XG4gIHJldHVybiBnZXROZXh0TWF0cml4KG9mZnNldE1hdHJpeCwgbXVsdGlwbHkodGFyZ2V0TWF0cml4LCBjcmVhdGVTY2FsZU1hdHJpeChzY2FsZSwgbiksIG4pLCB0cmFuc2Zvcm1PcmlnaW4sIG4pO1xufVxuZnVuY3Rpb24gZmlsbFRyYW5zZm9ybVN0YXJ0RXZlbnQoZSkge1xuICB2YXIgb3JpZ2luYWxEYXRhcyA9IGUub3JpZ2luYWxEYXRhcy5iZWZvcmVSZW5kZXJhYmxlO1xuICByZXR1cm4ge1xuICAgIHNldFRyYW5zZm9ybTogZnVuY3Rpb24gKHRyYW5zZm9ybSwgaW5kZXgpIHtcbiAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGluZGV4ID0gLTE7XG4gICAgICB9XG5cbiAgICAgIG9yaWdpbmFsRGF0YXMuc3RhcnRUcmFuc2Zvcm1zID0gaXNBcnJheSh0cmFuc2Zvcm0pID8gdHJhbnNmb3JtIDogc3BsaXRTcGFjZSh0cmFuc2Zvcm0pO1xuICAgICAgc2V0VHJhbnNmb3JtSW5kZXgoZSwgaW5kZXgpO1xuICAgIH0sXG4gICAgc2V0VHJhbnNmb3JtSW5kZXg6IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgc2V0VHJhbnNmb3JtSW5kZXgoZSwgaW5kZXgpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHNldERlZmF1bHRUcmFuc2Zvcm1JbmRleChlLCBwcm9wZXJ0eSkge1xuICB2YXIgb3JpZ2luYWxEYXRhcyA9IGUub3JpZ2luYWxEYXRhcy5iZWZvcmVSZW5kZXJhYmxlO1xuICB2YXIgc3RhcnRUcmFuc2Zvcm1zID0gb3JpZ2luYWxEYXRhcy5zdGFydFRyYW5zZm9ybXM7XG4gIHNldFRyYW5zZm9ybUluZGV4KGUsIGZpbmRJbmRleChzdGFydFRyYW5zZm9ybXMsIGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgcmV0dXJuIGZ1bmMuaW5kZXhPZihwcm9wZXJ0eSArIFwiKFwiKSA9PT0gMDtcbiAgfSkpO1xufVxuZnVuY3Rpb24gc2V0VHJhbnNmb3JtSW5kZXgoZSwgaW5kZXgpIHtcbiAgdmFyIG9yaWdpbmFsRGF0YXMgPSBlLm9yaWdpbmFsRGF0YXMuYmVmb3JlUmVuZGVyYWJsZTtcbiAgdmFyIGRhdGFzID0gZS5kYXRhcztcbiAgZGF0YXMudHJhbnNmb3JtSW5kZXggPSBpbmRleDtcblxuICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHRyYW5zZm9ybSA9IG9yaWdpbmFsRGF0YXMuc3RhcnRUcmFuc2Zvcm1zW2luZGV4XTtcblxuICBpZiAoIXRyYW5zZm9ybSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBpbmZvID0gcGFyc2UoW3RyYW5zZm9ybV0pO1xuICBkYXRhcy5zdGFydFZhbHVlID0gaW5mb1swXS5mdW5jdGlvblZhbHVlO1xufVxuZnVuY3Rpb24gZmlsbE9yaWdpbmFsVHJhbnNmb3JtKGUsIHRyYW5zZm9ybSkge1xuICB2YXIgb3JpZ2luYWxEYXRhcyA9IGUub3JpZ2luYWxEYXRhcy5iZWZvcmVSZW5kZXJhYmxlO1xuICBvcmlnaW5hbERhdGFzLm5leHRUcmFuc2Zvcm1zID0gc3BsaXRTcGFjZSh0cmFuc2Zvcm0pO1xufVxuZnVuY3Rpb24gZ2V0TmV4dFRyYW5zZm9ybVRleHQoZSkge1xuICB2YXIgb3JpZ2luYWxEYXRhcyA9IGUub3JpZ2luYWxEYXRhcy5iZWZvcmVSZW5kZXJhYmxlO1xuICByZXR1cm4gb3JpZ2luYWxEYXRhcy5uZXh0VHJhbnNmb3Jtcy5qb2luKFwiIFwiKTtcbn1cbmZ1bmN0aW9uIGZpbGxUcmFuc2Zvcm1FdmVudChtb3ZlYWJsZSwgbmV4dFRyYW5zZm9ybSwgZGVsdGEsIGlzUGluY2gsIGUpIHtcbiAgZmlsbE9yaWdpbmFsVHJhbnNmb3JtKGUsIG5leHRUcmFuc2Zvcm0pO1xuICByZXR1cm4ge1xuICAgIHRyYW5zZm9ybTogbmV4dFRyYW5zZm9ybSxcbiAgICBkcmFnOiBEcmFnZ2FibGUuZHJhZyhtb3ZlYWJsZSwgc2V0Q3VzdG9tRHJhZyhlLCBtb3ZlYWJsZS5zdGF0ZSwgZGVsdGEsIGlzUGluY2gsIGZhbHNlKSlcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFRyYW5zbGF0ZURpc3QobW92ZWFibGUsIHRyYW5zZm9ybSwgZml4ZWREaXJlY3Rpb24sIGZpeGVkUG9zaXRpb24sIGRhdGFzKSB7XG4gIHZhciBzdGF0ZSA9IG1vdmVhYmxlLnN0YXRlO1xuICB2YXIgbGVmdCA9IHN0YXRlLmxlZnQsXG4gICAgICB0b3AgPSBzdGF0ZS50b3A7XG4gIHZhciBncm91cGFibGUgPSBtb3ZlYWJsZS5wcm9wcy5ncm91cGFibGU7XG4gIHZhciBuZXh0TWF0cml4ID0gZ2V0TmV4dFRyYW5zZm9ybU1hdHJpeChtb3ZlYWJsZS5zdGF0ZSwgZGF0YXMsIHRyYW5zZm9ybSk7XG4gIHZhciBncm91cExlZnQgPSBncm91cGFibGUgPyBsZWZ0IDogMDtcbiAgdmFyIGdyb3VwVG9wID0gZ3JvdXBhYmxlID8gdG9wIDogMDtcbiAgdmFyIG5leHRGaXhlZFBvc2l0aW9uID0gZ2V0RGlyZWN0aW9uT2Zmc2V0KG1vdmVhYmxlLCBmaXhlZERpcmVjdGlvbiwgbmV4dE1hdHJpeCk7XG4gIHZhciBkaXN0ID0gbWludXMoZml4ZWRQb3NpdGlvbiwgbmV4dEZpeGVkUG9zaXRpb24pO1xuICByZXR1cm4gbWludXMoZGlzdCwgW2dyb3VwTGVmdCwgZ3JvdXBUb3BdKTtcbn1cbmZ1bmN0aW9uIGdldFNjYWxlRGlzdChtb3ZlYWJsZSwgc2NhbGVEaXN0LCBmaXhlZERpcmVjdGlvbiwgZml4ZWRQb3NpdGlvbiwgZGF0YXMpIHtcbiAgcmV0dXJuIGdldFRyYW5zbGF0ZURpc3QobW92ZWFibGUsIFwic2NhbGUoXCIgKyBzY2FsZURpc3Quam9pbihcIiwgXCIpICsgXCIpXCIsIGZpeGVkRGlyZWN0aW9uLCBmaXhlZFBvc2l0aW9uLCBkYXRhcyk7XG59XG5mdW5jdGlvbiBnZXRPcmlnaW5EaXJlY3Rpb24obW92ZWFibGUpIHtcbiAgdmFyIF9hID0gbW92ZWFibGUuc3RhdGUsXG4gICAgICB3aWR0aCA9IF9hLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX2EuaGVpZ2h0LFxuICAgICAgdHJhbnNmb3JtT3JpZ2luID0gX2EudHJhbnNmb3JtT3JpZ2luO1xuICByZXR1cm4gWy0xICsgdHJhbnNmb3JtT3JpZ2luWzBdIC8gKHdpZHRoIC8gMiksIC0xICsgdHJhbnNmb3JtT3JpZ2luWzFdIC8gKGhlaWdodCAvIDIpXTtcbn1cbmZ1bmN0aW9uIGdldERpcmVjdGlvbk9mZnNldChtb3ZlYWJsZSwgZGlyZWN0aW9uLCBuZXh0TWF0cml4KSB7XG4gIGlmIChuZXh0TWF0cml4ID09PSB2b2lkIDApIHtcbiAgICBuZXh0TWF0cml4ID0gbW92ZWFibGUuc3RhdGUuYWxsTWF0cml4O1xuICB9XG5cbiAgdmFyIF9hID0gbW92ZWFibGUuc3RhdGUsXG4gICAgICB3aWR0aCA9IF9hLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX2EuaGVpZ2h0LFxuICAgICAgaXMzZCA9IF9hLmlzM2Q7XG4gIHZhciBuID0gaXMzZCA/IDQgOiAzO1xuICB2YXIgbmV4dEZpeGVkT2Zmc2V0ID0gW3dpZHRoIC8gMiAqICgxICsgZGlyZWN0aW9uWzBdKSwgaGVpZ2h0IC8gMiAqICgxICsgZGlyZWN0aW9uWzFdKV07XG4gIHJldHVybiBjYWxjdWxhdGVQb3NpdGlvbihuZXh0TWF0cml4LCBuZXh0Rml4ZWRPZmZzZXQsIG4pO1xufVxuZnVuY3Rpb24gZ2V0Um90YXRlRGlzdChtb3ZlYWJsZSwgcm90YXRlRGlzdCwgZml4ZWRQb3NpdGlvbiwgZGF0YXMpIHtcbiAgdmFyIGZpeGVkRGlyZWN0aW9uID0gZ2V0T3JpZ2luRGlyZWN0aW9uKG1vdmVhYmxlKTtcbiAgcmV0dXJuIGdldFRyYW5zbGF0ZURpc3QobW92ZWFibGUsIFwicm90YXRlKFwiICsgcm90YXRlRGlzdCArIFwiZGVnKVwiLCBmaXhlZERpcmVjdGlvbiwgZml4ZWRQb3NpdGlvbiwgZGF0YXMpO1xufVxuZnVuY3Rpb24gZ2V0UmVzaXplRGlzdChtb3ZlYWJsZSwgd2lkdGgsIGhlaWdodCwgZml4ZWREaXJlY3Rpb24sIGZpeGVkUG9zaXRpb24sIHRyYW5zZm9ybU9yaWdpbikge1xuICB2YXIgZ3JvdXBhYmxlID0gbW92ZWFibGUucHJvcHMuZ3JvdXBhYmxlO1xuICB2YXIgX2EgPSBtb3ZlYWJsZS5zdGF0ZSxcbiAgICAgIHByZXZPcmlnaW4gPSBfYS50cmFuc2Zvcm1PcmlnaW4sXG4gICAgICB0YXJnZXRNYXRyaXggPSBfYS50YXJnZXRNYXRyaXgsXG4gICAgICBvZmZzZXRNYXRyaXggPSBfYS5vZmZzZXRNYXRyaXgsXG4gICAgICBpczNkID0gX2EuaXMzZCxcbiAgICAgIHByZXZXaWR0aCA9IF9hLndpZHRoLFxuICAgICAgcHJldkhlaWdodCA9IF9hLmhlaWdodCxcbiAgICAgIGxlZnQgPSBfYS5sZWZ0LFxuICAgICAgdG9wID0gX2EudG9wO1xuICB2YXIgbiA9IGlzM2QgPyA0IDogMztcbiAgdmFyIG5leHRPcmlnaW4gPSBjYWxjdWxhdGVUcmFuc2Zvcm1PcmlnaW4odHJhbnNmb3JtT3JpZ2luLCB3aWR0aCwgaGVpZ2h0LCBwcmV2V2lkdGgsIHByZXZIZWlnaHQsIHByZXZPcmlnaW4pO1xuICB2YXIgZ3JvdXBMZWZ0ID0gZ3JvdXBhYmxlID8gbGVmdCA6IDA7XG4gIHZhciBncm91cFRvcCA9IGdyb3VwYWJsZSA/IHRvcCA6IDA7XG4gIHZhciBuZXh0TWF0cml4ID0gZ2V0TmV4dE1hdHJpeChvZmZzZXRNYXRyaXgsIHRhcmdldE1hdHJpeCwgbmV4dE9yaWdpbiwgbik7XG4gIHZhciBkaXN0ID0gZ2V0RGlzdChmaXhlZFBvc2l0aW9uLCBuZXh0TWF0cml4LCB3aWR0aCwgaGVpZ2h0LCBuLCBmaXhlZERpcmVjdGlvbik7XG4gIHJldHVybiBtaW51cyhkaXN0LCBbZ3JvdXBMZWZ0LCBncm91cFRvcF0pO1xufVxuZnVuY3Rpb24gZ2V0QWJzb2x1dGVQb3NpdGlvbihtb3ZlYWJsZSwgZGlyZWN0aW9uKSB7XG4gIHJldHVybiBnZXRQb3NCeURpcmVjdGlvbihnZXRBYnNvbHV0ZVBvc2VzQnlTdGF0ZShtb3ZlYWJsZS5zdGF0ZSksIGRpcmVjdGlvbik7XG59XG5cbnZhciBWRVJUSUNBTF9OQU1FUyA9IFtcImxlZnRcIiwgXCJyaWdodFwiLCBcImNlbnRlclwiXTtcbnZhciBIT1JJWk9OVEFMX05BTUVTID0gW1widG9wXCIsIFwiYm90dG9tXCIsIFwibWlkZGxlXCJdO1xudmFyIFZFUlRJQ0FMX05BTUVTX01BUCA9IHtcbiAgc3RhcnQ6IFwibGVmdFwiLFxuICBlbmQ6IFwicmlnaHRcIixcbiAgY2VudGVyOiBcImNlbnRlclwiXG59O1xudmFyIEhPUklaT05UQUxfTkFNRVNfTUFQID0ge1xuICBzdGFydDogXCJ0b3BcIixcbiAgZW5kOiBcImJvdHRvbVwiLFxuICBjZW50ZXI6IFwibWlkZGxlXCJcbn07XG5mdW5jdGlvbiBoYXNHdWlkZWxpbmVzKG1vdmVhYmxlLCBhYmxlTmFtZSkge1xuICB2YXIgX2EgPSBtb3ZlYWJsZS5wcm9wcyxcbiAgICAgIHNuYXBwYWJsZSA9IF9hLnNuYXBwYWJsZSxcbiAgICAgIGJvdW5kcyA9IF9hLmJvdW5kcyxcbiAgICAgIGlubmVyQm91bmRzID0gX2EuaW5uZXJCb3VuZHMsXG4gICAgICB2ZXJ0aWNhbEd1aWRlbGluZXMgPSBfYS52ZXJ0aWNhbEd1aWRlbGluZXMsXG4gICAgICBob3Jpem9udGFsR3VpZGVsaW5lcyA9IF9hLmhvcml6b250YWxHdWlkZWxpbmVzLFxuICAgICAgc25hcEdyaWRXaWR0aCA9IF9hLnNuYXBHcmlkV2lkdGgsXG4gICAgICBzbmFwR3JpZEhlaWdodCA9IF9hLnNuYXBHcmlkSGVpZ2h0LFxuICAgICAgX2IgPSBtb3ZlYWJsZS5zdGF0ZSxcbiAgICAgIGd1aWRlbGluZXMgPSBfYi5ndWlkZWxpbmVzLFxuICAgICAgZW5hYmxlU25hcCA9IF9iLmVuYWJsZVNuYXA7XG5cbiAgaWYgKCFzbmFwcGFibGUgfHwgIWVuYWJsZVNuYXAgfHwgYWJsZU5hbWUgJiYgc25hcHBhYmxlICE9PSB0cnVlICYmIHNuYXBwYWJsZS5pbmRleE9mKGFibGVOYW1lKSA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoc25hcEdyaWRXaWR0aCB8fCBzbmFwR3JpZEhlaWdodCB8fCBib3VuZHMgfHwgaW5uZXJCb3VuZHMgfHwgZ3VpZGVsaW5lcyAmJiBndWlkZWxpbmVzLmxlbmd0aCB8fCB2ZXJ0aWNhbEd1aWRlbGluZXMgJiYgdmVydGljYWxHdWlkZWxpbmVzLmxlbmd0aCB8fCBob3Jpem9udGFsR3VpZGVsaW5lcyAmJiBob3Jpem9udGFsR3VpZGVsaW5lcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldFNuYXBEaXJlY3Rpb25zKHNuYXBEaXJlY3Rpb25zKSB7XG4gIGlmIChzbmFwRGlyZWN0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4ge307XG4gIH0gZWxzZSBpZiAoc25hcERpcmVjdGlvbnMgPT09IHRydWUgfHwgIXNuYXBEaXJlY3Rpb25zKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IHRydWUsXG4gICAgICByaWdodDogdHJ1ZSxcbiAgICAgIHRvcDogdHJ1ZSxcbiAgICAgIGJvdHRvbTogdHJ1ZVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gc25hcERpcmVjdGlvbnM7XG59XG5mdW5jdGlvbiBtYXBTbmFwRGlyZWN0aW9uUG9zZXMoc25hcERpcmVjdGlvbnMsIHNuYXBQb3Nlcykge1xuICB2YXIgbmV4dFNuYXBEaXJlY3Rpb25zID0gZ2V0U25hcERpcmVjdGlvbnMoc25hcERpcmVjdGlvbnMpO1xuICB2YXIgbmV4dFNuYXBQb3NlcyA9IHt9O1xuXG4gIGZvciAodmFyIG5hbWUgaW4gbmV4dFNuYXBEaXJlY3Rpb25zKSB7XG4gICAgaWYgKG5hbWUgaW4gc25hcFBvc2VzICYmIG5leHRTbmFwRGlyZWN0aW9uc1tuYW1lXSkge1xuICAgICAgbmV4dFNuYXBQb3Nlc1tuYW1lXSA9IHNuYXBQb3Nlc1tuYW1lXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV4dFNuYXBQb3Nlcztcbn1cbmZ1bmN0aW9uIHNwbGl0U25hcERpcmVjdGlvblBvc2VzKHNuYXBEaXJlY3Rpb25zLCBzbmFwUG9zZXMpIHtcbiAgdmFyIG5leHRTbmFwUG9zZXMgPSBtYXBTbmFwRGlyZWN0aW9uUG9zZXMoc25hcERpcmVjdGlvbnMsIHNuYXBQb3Nlcyk7XG4gIHZhciBob3Jpem9udGFsTmFtZXMgPSBIT1JJWk9OVEFMX05BTUVTLmZpbHRlcihmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiBuYW1lIGluIG5leHRTbmFwUG9zZXM7XG4gIH0pO1xuICB2YXIgdmVydGljYWxOYW1lcyA9IFZFUlRJQ0FMX05BTUVTLmZpbHRlcihmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiBuYW1lIGluIG5leHRTbmFwUG9zZXM7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGhvcml6b250YWw6IGhvcml6b250YWxOYW1lcy5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHJldHVybiBuZXh0U25hcFBvc2VzW25hbWVdO1xuICAgIH0pLFxuICAgIHZlcnRpY2FsOiB2ZXJ0aWNhbE5hbWVzLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIG5leHRTbmFwUG9zZXNbbmFtZV07XG4gICAgfSlcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldEdhcEd1aWRlbGluZXMobW92ZWFibGUsIHRhcmdldFJlY3QsIHNuYXBUaHJlc2hvbGQpIHtcbiAgdmFyIGVsZW1lbnRSZWN0cyA9IG1vdmVhYmxlLnN0YXRlLmVsZW1lbnRSZWN0cztcbiAgdmFyIGdhcEd1aWRlbGluZXMgPSBbXTtcbiAgW1tcInZlcnRpY2FsXCIsIFZFUlRJQ0FMX05BTUVTX01BUCwgSE9SSVpPTlRBTF9OQU1FU19NQVBdLCBbXCJob3Jpem9udGFsXCIsIEhPUklaT05UQUxfTkFNRVNfTUFQLCBWRVJUSUNBTF9OQU1FU19NQVBdXS5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciB0eXBlID0gX2FbMF0sXG4gICAgICAgIG1haW5OYW1lcyA9IF9hWzFdLFxuICAgICAgICBzaWRlTmFtZXMgPSBfYVsyXTtcbiAgICB2YXIgdGFyZ2V0U3RhcnQgPSB0YXJnZXRSZWN0W21haW5OYW1lcy5zdGFydF07XG4gICAgdmFyIHRhcmdldEVuZCA9IHRhcmdldFJlY3RbbWFpbk5hbWVzLmVuZF07XG4gICAgdmFyIHRhcmdldENlbnRlciA9IHRhcmdldFJlY3RbbWFpbk5hbWVzLmNlbnRlcl07XG4gICAgdmFyIHRhcmdldFN0YXJ0MiA9IHRhcmdldFJlY3Rbc2lkZU5hbWVzLnN0YXJ0XTtcbiAgICB2YXIgdGFyZ2V0RW5kMiA9IHRhcmdldFJlY3Rbc2lkZU5hbWVzLmVuZF07IC8vIGVsZW1lbnQgOiBtb3ZlYWJsZVxuXG4gICAgZnVuY3Rpb24gZ2V0RGlzdChlbGVtZW50UmVjdCkge1xuICAgICAgdmFyIHJlY3QgPSBlbGVtZW50UmVjdC5yZWN0O1xuXG4gICAgICBpZiAocmVjdFttYWluTmFtZXMuZW5kXSA8IHRhcmdldFN0YXJ0ICsgc25hcFRocmVzaG9sZCkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0U3RhcnQgLSByZWN0W21haW5OYW1lcy5lbmRdO1xuICAgICAgfSBlbHNlIGlmICh0YXJnZXRFbmQgLSBzbmFwVGhyZXNob2xkIDwgcmVjdFttYWluTmFtZXMuc3RhcnRdKSB7XG4gICAgICAgIHJldHVybiByZWN0W21haW5OYW1lcy5zdGFydF0gLSB0YXJnZXRFbmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5leHRFbGVtZW50UmVjdHMgPSBlbGVtZW50UmVjdHMuZmlsdGVyKGZ1bmN0aW9uIChlbGVtZW50UmVjdCkge1xuICAgICAgdmFyIHJlY3QgPSBlbGVtZW50UmVjdC5yZWN0O1xuXG4gICAgICBpZiAocmVjdFtzaWRlTmFtZXMuc3RhcnRdID4gdGFyZ2V0RW5kMiB8fCByZWN0W3NpZGVOYW1lcy5lbmRdIDwgdGFyZ2V0U3RhcnQyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldERpc3QoZWxlbWVudFJlY3QpID4gMDtcbiAgICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gZ2V0RGlzdChhKSAtIGdldERpc3QoYik7XG4gICAgfSk7XG4gICAgdmFyIGdyb3VwcyA9IFtdO1xuICAgIG5leHRFbGVtZW50UmVjdHMuZm9yRWFjaChmdW5jdGlvbiAoc25hcFJlY3QxKSB7XG4gICAgICBuZXh0RWxlbWVudFJlY3RzLmZvckVhY2goZnVuY3Rpb24gKHNuYXBSZWN0Mikge1xuICAgICAgICBpZiAoc25hcFJlY3QxID09PSBzbmFwUmVjdDIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVjdDEgPSBzbmFwUmVjdDEucmVjdDtcbiAgICAgICAgdmFyIHJlY3QyID0gc25hcFJlY3QyLnJlY3Q7XG4gICAgICAgIHZhciByZWN0MVN0YXJ0ID0gcmVjdDFbc2lkZU5hbWVzLnN0YXJ0XTtcbiAgICAgICAgdmFyIHJlY3QxRW5kID0gcmVjdDFbc2lkZU5hbWVzLmVuZF07XG4gICAgICAgIHZhciByZWN0MlN0YXJ0ID0gcmVjdDJbc2lkZU5hbWVzLnN0YXJ0XTtcbiAgICAgICAgdmFyIHJlY3QyRW5kID0gcmVjdDJbc2lkZU5hbWVzLmVuZF07XG5cbiAgICAgICAgaWYgKHJlY3QxU3RhcnQgPiByZWN0MkVuZCB8fCByZWN0MlN0YXJ0ID4gcmVjdDFFbmQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBncm91cHMucHVzaChbc25hcFJlY3QxLCBzbmFwUmVjdDJdKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgdmFyIHNuYXBSZWN0MSA9IF9hWzBdLFxuICAgICAgICAgIHNuYXBSZWN0MiA9IF9hWzFdO1xuICAgICAgdmFyIHJlY3QxID0gc25hcFJlY3QxLnJlY3Q7XG4gICAgICB2YXIgcmVjdDIgPSBzbmFwUmVjdDIucmVjdDtcbiAgICAgIHZhciByZWN0MVN0YXJ0ID0gcmVjdDFbbWFpbk5hbWVzLnN0YXJ0XTtcbiAgICAgIHZhciByZWN0MUVuZCA9IHJlY3QxW21haW5OYW1lcy5lbmRdO1xuICAgICAgdmFyIHJlY3QyU3RhcnQgPSByZWN0MlttYWluTmFtZXMuc3RhcnRdO1xuICAgICAgdmFyIHJlY3QyRW5kID0gcmVjdDJbbWFpbk5hbWVzLmVuZF07XG4gICAgICB2YXIgZ2FwID0gMDtcbiAgICAgIHZhciBwb3MgPSAwO1xuICAgICAgdmFyIGlzU3RhcnQgPSBmYWxzZTtcbiAgICAgIHZhciBpc0NlbnRlciA9IGZhbHNlO1xuICAgICAgdmFyIGlzRW5kID0gZmFsc2U7XG5cbiAgICAgIGlmIChyZWN0MUVuZCA8PSB0YXJnZXRTdGFydCAmJiB0YXJnZXRFbmQgPD0gcmVjdDJTdGFydCkge1xuICAgICAgICAvLyAobCllbGVtZW50MShyKSA6IChsKXRhcmdldChyKSA6IChsKWVsZW1lbnQyKHIpXG4gICAgICAgIGlzQ2VudGVyID0gdHJ1ZTtcbiAgICAgICAgZ2FwID0gKHJlY3QyU3RhcnQgLSByZWN0MUVuZCAtICh0YXJnZXRFbmQgLSB0YXJnZXRTdGFydCkpIC8gMjtcbiAgICAgICAgcG9zID0gcmVjdDFFbmQgKyBnYXAgKyAodGFyZ2V0RW5kIC0gdGFyZ2V0U3RhcnQpIC8gMjtcblxuICAgICAgICBpZiAoTWF0aC5hYnMocG9zIC0gdGFyZ2V0Q2VudGVyKSA+IHNuYXBUaHJlc2hvbGQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocmVjdDFFbmQgPCByZWN0MlN0YXJ0ICYmIHJlY3QyRW5kIDwgdGFyZ2V0U3RhcnQgKyBzbmFwVGhyZXNob2xkKSB7XG4gICAgICAgIC8vIChsKWVsZW1lbnQxKHIpIDogKGwpZWxlbWVudDIocikgOiAobCl0YXJnZXRcbiAgICAgICAgaXNTdGFydCA9IHRydWU7XG4gICAgICAgIGdhcCA9IHJlY3QyU3RhcnQgLSByZWN0MUVuZDtcbiAgICAgICAgcG9zID0gcmVjdDJFbmQgKyBnYXA7XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKHBvcyAtIHRhcmdldFN0YXJ0KSA+IHNuYXBUaHJlc2hvbGQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocmVjdDFFbmQgPCByZWN0MlN0YXJ0ICYmIHRhcmdldEVuZCAtIHNuYXBUaHJlc2hvbGQgPCByZWN0MVN0YXJ0KSB7XG4gICAgICAgIC8vIHRhcmdldChyKSA6IChsKWVsZW1lbnQxKHIpIDogKGwpZWxlbWVudDIocilcbiAgICAgICAgaXNFbmQgPSB0cnVlO1xuICAgICAgICBnYXAgPSByZWN0MlN0YXJ0IC0gcmVjdDFFbmQ7XG4gICAgICAgIHBvcyA9IHJlY3QxU3RhcnQgLSBnYXA7XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKHBvcyAtIHRhcmdldEVuZCkgPiBzbmFwVGhyZXNob2xkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghZ2FwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZ2FwR3VpZGVsaW5lcy5wdXNoKHtcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgcG9zOiB0eXBlID09PSBcInZlcnRpY2FsXCIgPyBbcG9zLCAwXSA6IFswLCBwb3NdLFxuICAgICAgICBlbGVtZW50OiBzbmFwUmVjdDIuZWxlbWVudCxcbiAgICAgICAgc2l6ZTogMCxcbiAgICAgICAgY2xhc3NOYW1lOiBzbmFwUmVjdDIuY2xhc3NOYW1lLFxuICAgICAgICBpc1N0YXJ0OiBpc1N0YXJ0LFxuICAgICAgICBpc0NlbnRlcjogaXNDZW50ZXIsXG4gICAgICAgIGlzRW5kOiBpc0VuZCxcbiAgICAgICAgZ2FwOiBnYXAsXG4gICAgICAgIGhpZGU6IHRydWUsXG4gICAgICAgIGdhcFJlY3RzOiBbc25hcFJlY3QxLCBzbmFwUmVjdDJdXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBnYXBHdWlkZWxpbmVzO1xufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdEd1aWRlbGluZXMoaG9yaXpvbnRhbEd1aWRlbGluZXMsIHZlcnRpY2FsR3VpZGVsaW5lcywgd2lkdGgsIGhlaWdodCwgY2xpZW50TGVmdCwgY2xpZW50VG9wLCBzbmFwT2Zmc2V0KSB7XG4gIGlmIChjbGllbnRMZWZ0ID09PSB2b2lkIDApIHtcbiAgICBjbGllbnRMZWZ0ID0gMDtcbiAgfVxuXG4gIGlmIChjbGllbnRUb3AgPT09IHZvaWQgMCkge1xuICAgIGNsaWVudFRvcCA9IDA7XG4gIH1cblxuICBpZiAoc25hcE9mZnNldCA9PT0gdm9pZCAwKSB7XG4gICAgc25hcE9mZnNldCA9IHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB0b3A6IDAsXG4gICAgICByaWdodDogMCxcbiAgICAgIGJvdHRvbTogMFxuICAgIH07XG4gIH1cblxuICB2YXIgZ3VpZGVsaW5lcyA9IFtdO1xuICB2YXIgc25hcE9mZnNldExlZnQgPSBzbmFwT2Zmc2V0LmxlZnQsXG4gICAgICBzbmFwT2Zmc2V0VG9wID0gc25hcE9mZnNldC50b3AsXG4gICAgICBzbmFwT2Zmc2V0Qm90dG9tID0gc25hcE9mZnNldC5ib3R0b20sXG4gICAgICBzbmFwT2Zmc2V0UmlnaHQgPSBzbmFwT2Zmc2V0LnJpZ2h0O1xuICB2YXIgc25hcFdpZHRoID0gd2lkdGggKyBzbmFwT2Zmc2V0UmlnaHQgLSBzbmFwT2Zmc2V0TGVmdDtcbiAgdmFyIHNuYXBIZWlnaHQgPSBoZWlnaHQgKyBzbmFwT2Zmc2V0Qm90dG9tIC0gc25hcE9mZnNldFRvcDtcbiAgaG9yaXpvbnRhbEd1aWRlbGluZXMgJiYgaG9yaXpvbnRhbEd1aWRlbGluZXMuZm9yRWFjaChmdW5jdGlvbiAocG9zKSB7XG4gICAgZ3VpZGVsaW5lcy5wdXNoKHtcbiAgICAgIHR5cGU6IFwiaG9yaXpvbnRhbFwiLFxuICAgICAgcG9zOiBbc25hcE9mZnNldExlZnQsIHRocm90dGxlKHBvcyAtIGNsaWVudFRvcCArIHNuYXBPZmZzZXRUb3AsIDAuMSldLFxuICAgICAgc2l6ZTogc25hcFdpZHRoXG4gICAgfSk7XG4gIH0pO1xuICB2ZXJ0aWNhbEd1aWRlbGluZXMgJiYgdmVydGljYWxHdWlkZWxpbmVzLmZvckVhY2goZnVuY3Rpb24gKHBvcykge1xuICAgIGd1aWRlbGluZXMucHVzaCh7XG4gICAgICB0eXBlOiBcInZlcnRpY2FsXCIsXG4gICAgICBwb3M6IFt0aHJvdHRsZShwb3MgLSBjbGllbnRMZWZ0ICsgc25hcE9mZnNldExlZnQsIDAuMSksIHNuYXBPZmZzZXRUb3BdLFxuICAgICAgc2l6ZTogc25hcEhlaWdodFxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGd1aWRlbGluZXM7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVDb250YWluZXJQb3Mocm9vdE1hdHJpeCwgY29udGFpbmVyUmVjdCwgbikge1xuICB2YXIgY2xpZW50UG9zID0gY2FsY3VsYXRlUG9zaXRpb24ocm9vdE1hdHJpeCwgW2NvbnRhaW5lclJlY3QuY2xpZW50TGVmdCwgY29udGFpbmVyUmVjdC5jbGllbnRUb3BdLCBuKTtcbiAgcmV0dXJuIFtjb250YWluZXJSZWN0LmxlZnQgKyBjbGllbnRQb3NbMF0sIGNvbnRhaW5lclJlY3QudG9wICsgY2xpZW50UG9zWzFdXTtcbn1cbmZ1bmN0aW9uIGdldFNuYXBFbGVtZW50UmVjdHMobW92ZWFibGUsIHZhbHVlcykge1xuICBpZiAoIXZhbHVlcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgc3RhdGUgPSBtb3ZlYWJsZS5zdGF0ZTtcbiAgdmFyIGNvbnRhaW5lckNsaWVudFJlY3QgPSBzdGF0ZS5jb250YWluZXJDbGllbnRSZWN0LFxuICAgICAgX2EgPSBzdGF0ZS50YXJnZXRDbGllbnRSZWN0LFxuICAgICAgY2xpZW50VG9wID0gX2EudG9wLFxuICAgICAgY2xpZW50TGVmdCA9IF9hLmxlZnQsXG4gICAgICByb290TWF0cml4ID0gc3RhdGUucm9vdE1hdHJpeCxcbiAgICAgIGlzM2QgPSBzdGF0ZS5pczNkO1xuICB2YXIgbiA9IGlzM2QgPyA0IDogMztcblxuICB2YXIgX2IgPSBjYWxjdWxhdGVDb250YWluZXJQb3Mocm9vdE1hdHJpeCwgY29udGFpbmVyQ2xpZW50UmVjdCwgbiksXG4gICAgICBjb250YWluZXJMZWZ0ID0gX2JbMF0sXG4gICAgICBjb250YWluZXJUb3AgPSBfYlsxXTtcblxuICB2YXIgcG9zZXMgPSBnZXRBYnNvbHV0ZVBvc2VzQnlTdGF0ZShzdGF0ZSk7XG5cbiAgdmFyIF9jID0gZ2V0TWluTWF4cyhwb3NlcyksXG4gICAgICB0YXJnZXRMZWZ0ID0gX2MubWluWCxcbiAgICAgIHRhcmdldFRvcCA9IF9jLm1pblk7XG5cbiAgdmFyIF9kID0gbWludXMoW3RhcmdldExlZnQsIHRhcmdldFRvcF0sIGNhbGN1bGF0ZUludmVyc2VQb3NpdGlvbihyb290TWF0cml4LCBbY2xpZW50TGVmdCAtIGNvbnRhaW5lckxlZnQsIGNsaWVudFRvcCAtIGNvbnRhaW5lclRvcF0sIG4pKS5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgIHJldHVybiByb3VuZFNpZ24ocG9zKTtcbiAgfSksXG4gICAgICBkaXN0TGVmdCA9IF9kWzBdLFxuICAgICAgZGlzdFRvcCA9IF9kWzFdO1xuXG4gIHJldHVybiB2YWx1ZXMubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciByZWN0ID0gdmFsdWUuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgbGVmdCA9IHJlY3QubGVmdCAtIGNvbnRhaW5lckxlZnQ7XG4gICAgdmFyIHRvcCA9IHJlY3QudG9wIC0gY29udGFpbmVyVG9wO1xuICAgIHZhciBib3R0b20gPSB0b3AgKyByZWN0LmhlaWdodDtcbiAgICB2YXIgcmlnaHQgPSBsZWZ0ICsgcmVjdC53aWR0aDtcblxuICAgIHZhciBfYSA9IGNhbGN1bGF0ZUludmVyc2VQb3NpdGlvbihyb290TWF0cml4LCBbbGVmdCwgdG9wXSwgbiksXG4gICAgICAgIGVsZW1lbnRMZWZ0ID0gX2FbMF0sXG4gICAgICAgIGVsZW1lbnRUb3AgPSBfYVsxXTtcblxuICAgIHZhciBfYiA9IGNhbGN1bGF0ZUludmVyc2VQb3NpdGlvbihyb290TWF0cml4LCBbcmlnaHQsIGJvdHRvbV0sIG4pLFxuICAgICAgICBlbGVtZW50UmlnaHQgPSBfYlswXSxcbiAgICAgICAgZWxlbWVudEJvdHRvbSA9IF9iWzFdO1xuXG4gICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCB2YWx1ZSksIHtcbiAgICAgIHJlY3Q6IHtcbiAgICAgICAgbGVmdDogZWxlbWVudExlZnQgKyBkaXN0TGVmdCxcbiAgICAgICAgcmlnaHQ6IGVsZW1lbnRSaWdodCArIGRpc3RMZWZ0LFxuICAgICAgICB0b3A6IGVsZW1lbnRUb3AgKyBkaXN0VG9wLFxuICAgICAgICBib3R0b206IGVsZW1lbnRCb3R0b20gKyBkaXN0VG9wLFxuICAgICAgICBjZW50ZXI6IChlbGVtZW50TGVmdCArIGVsZW1lbnRSaWdodCkgLyAyICsgZGlzdExlZnQsXG4gICAgICAgIG1pZGRsZTogKGVsZW1lbnRUb3AgKyBlbGVtZW50Qm90dG9tKSAvIDIgKyBkaXN0VG9wXG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0RWxlbWVudEd1aWRlbGluZXMobW92ZWFibGUpIHtcbiAgdmFyIHN0YXRlID0gbW92ZWFibGUuc3RhdGU7XG4gIHZhciBfYSA9IG1vdmVhYmxlLnByb3BzLmVsZW1lbnRHdWlkZWxpbmVzLFxuICAgICAgZWxlbWVudEd1aWRlbGluZXMgPSBfYSA9PT0gdm9pZCAwID8gW10gOiBfYTtcblxuICBpZiAoIWVsZW1lbnRHdWlkZWxpbmVzLmxlbmd0aCkge1xuICAgIHN0YXRlLmVsZW1lbnRSZWN0cyA9IFtdO1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBwcmV2VmFsdWVzID0gKHN0YXRlLmVsZW1lbnRSZWN0cyB8fCBbXSkuZmlsdGVyKGZ1bmN0aW9uIChzbmFwUmVjdCkge1xuICAgIHJldHVybiAhc25hcFJlY3QucmVmcmVzaDtcbiAgfSk7XG4gIHZhciBuZXh0RWxlbWVudEd1aWRlbGluZXMgPSBlbGVtZW50R3VpZGVsaW5lcy5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKGlzT2JqZWN0KGVsKSAmJiBcImVsZW1lbnRcIiBpbiBlbCkge1xuICAgICAgcmV0dXJuIGVsO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBlbGVtZW50OiBnZXRSZWZUYXJnZXQoZWwsIHRydWUpXG4gICAgfTtcbiAgfSkuZmlsdGVyKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5lbGVtZW50O1xuICB9KTtcblxuICB2YXIgX2IgPSBkaWZmKHByZXZWYWx1ZXMubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIHYuZWxlbWVudDtcbiAgfSksIG5leHRFbGVtZW50R3VpZGVsaW5lcy5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gdi5lbGVtZW50O1xuICB9KSksXG4gICAgICBtYWludGFpbmVkID0gX2IubWFpbnRhaW5lZCxcbiAgICAgIGFkZGVkID0gX2IuYWRkZWQ7XG5cbiAgdmFyIG5leHRWYWx1ZXMgPSBbXTtcbiAgbWFpbnRhaW5lZC5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBwcmV2SW5kZXggPSBfYVswXSxcbiAgICAgICAgbmV4dEluZGV4ID0gX2FbMV07XG4gICAgbmV4dFZhbHVlc1tuZXh0SW5kZXhdID0gcHJldlZhbHVlc1twcmV2SW5kZXhdO1xuICB9KTtcbiAgZ2V0U25hcEVsZW1lbnRSZWN0cyhtb3ZlYWJsZSwgYWRkZWQubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHJldHVybiBuZXh0RWxlbWVudEd1aWRlbGluZXNbaW5kZXhdO1xuICB9KSkubWFwKGZ1bmN0aW9uIChyZWN0LCBpKSB7XG4gICAgbmV4dFZhbHVlc1thZGRlZFtpXV0gPSByZWN0O1xuICB9KTtcbiAgc3RhdGUuZWxlbWVudFJlY3RzID0gbmV4dFZhbHVlcztcbiAgdmFyIGVsZW1lbnRTbmFwRGlyZWN0aW9ucyA9IGdldFNuYXBEaXJlY3Rpb25zKG1vdmVhYmxlLnByb3BzLmVsZW1lbnRTbmFwRGlyZWN0aW9ucyk7XG4gIHZhciBuZXh0R3VpZGVsaW5lcyA9IFtdO1xuICBuZXh0VmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHNuYXBSZWN0KSB7XG4gICAgdmFyIGVsZW1lbnQgPSBzbmFwUmVjdC5lbGVtZW50LFxuICAgICAgICBfYSA9IHNuYXBSZWN0LnRvcCxcbiAgICAgICAgdG9wVmFsdWUgPSBfYSA9PT0gdm9pZCAwID8gZWxlbWVudFNuYXBEaXJlY3Rpb25zLnRvcCA6IF9hLFxuICAgICAgICBfYiA9IHNuYXBSZWN0LmxlZnQsXG4gICAgICAgIGxlZnRWYWx1ZSA9IF9iID09PSB2b2lkIDAgPyBlbGVtZW50U25hcERpcmVjdGlvbnMubGVmdCA6IF9iLFxuICAgICAgICBfYyA9IHNuYXBSZWN0LnJpZ2h0LFxuICAgICAgICByaWdodFZhbHVlID0gX2MgPT09IHZvaWQgMCA/IGVsZW1lbnRTbmFwRGlyZWN0aW9ucy5yaWdodCA6IF9jLFxuICAgICAgICBfZCA9IHNuYXBSZWN0LmJvdHRvbSxcbiAgICAgICAgYm90dG9tVmFsdWUgPSBfZCA9PT0gdm9pZCAwID8gZWxlbWVudFNuYXBEaXJlY3Rpb25zLmJvdHRvbSA6IF9kLFxuICAgICAgICBfZSA9IHNuYXBSZWN0LmNlbnRlcixcbiAgICAgICAgY2VudGVyVmFsdWUgPSBfZSA9PT0gdm9pZCAwID8gZWxlbWVudFNuYXBEaXJlY3Rpb25zLmNlbnRlciA6IF9lLFxuICAgICAgICBfZiA9IHNuYXBSZWN0Lm1pZGRsZSxcbiAgICAgICAgbWlkZGxlVmFsdWUgPSBfZiA9PT0gdm9pZCAwID8gZWxlbWVudFNuYXBEaXJlY3Rpb25zLm1pZGRsZSA6IF9mLFxuICAgICAgICBjbGFzc05hbWUgPSBzbmFwUmVjdC5jbGFzc05hbWUsXG4gICAgICAgIHJlY3QgPSBzbmFwUmVjdC5yZWN0O1xuXG4gICAgdmFyIF9nID0gc3BsaXRTbmFwRGlyZWN0aW9uUG9zZXMoe1xuICAgICAgdG9wOiB0b3BWYWx1ZSxcbiAgICAgIHJpZ2h0OiByaWdodFZhbHVlLFxuICAgICAgbGVmdDogbGVmdFZhbHVlLFxuICAgICAgYm90dG9tOiBib3R0b21WYWx1ZSxcbiAgICAgIGNlbnRlcjogY2VudGVyVmFsdWUsXG4gICAgICBtaWRkbGU6IG1pZGRsZVZhbHVlXG4gICAgfSwgcmVjdCksXG4gICAgICAgIGhvcml6b250YWwgPSBfZy5ob3Jpem9udGFsLFxuICAgICAgICB2ZXJ0aWNhbCA9IF9nLnZlcnRpY2FsO1xuXG4gICAgdmFyIHJlY3RUb3AgPSByZWN0LnRvcDtcbiAgICB2YXIgcmVjdExlZnQgPSByZWN0LmxlZnQ7XG4gICAgdmFyIHdpZHRoID0gcmVjdC5yaWdodCAtIHJlY3RMZWZ0O1xuICAgIHZhciBoZWlnaHQgPSByZWN0LmJvdHRvbSAtIHJlY3RUb3A7XG4gICAgdmFyIHNpemVzID0gW3dpZHRoLCBoZWlnaHRdO1xuICAgIHZlcnRpY2FsLmZvckVhY2goZnVuY3Rpb24gKHBvcykge1xuICAgICAgbmV4dEd1aWRlbGluZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwidmVydGljYWxcIixcbiAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgcG9zOiBbdGhyb3R0bGUocG9zLCAwLjEpLCByZWN0VG9wXSxcbiAgICAgICAgc2l6ZTogaGVpZ2h0LFxuICAgICAgICBzaXplczogc2l6ZXMsXG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgICAgICBlbGVtZW50UmVjdDogc25hcFJlY3RcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGhvcml6b250YWwuZm9yRWFjaChmdW5jdGlvbiAocG9zKSB7XG4gICAgICBuZXh0R3VpZGVsaW5lcy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJob3Jpem9udGFsXCIsXG4gICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgIHBvczogW3JlY3RMZWZ0LCB0aHJvdHRsZShwb3MsIDAuMSldLFxuICAgICAgICBzaXplOiB3aWR0aCxcbiAgICAgICAgc2l6ZXM6IHNpemVzLFxuICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgICAgZWxlbWVudFJlY3Q6IHNuYXBSZWN0XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBuZXh0R3VpZGVsaW5lcztcbn1cbmZ1bmN0aW9uIGdldFRvdGFsR3VpZGVsaW5lcyhtb3ZlYWJsZSkge1xuICB2YXIgX2EgPSBtb3ZlYWJsZS5zdGF0ZSxcbiAgICAgIHNuYXBPZmZzZXQgPSBfYS5zbmFwT2Zmc2V0LFxuICAgICAgX2IgPSBfYS5jb250YWluZXJDbGllbnRSZWN0LFxuICAgICAgb3ZlcmZsb3cgPSBfYi5vdmVyZmxvdyxcbiAgICAgIGNvbnRhaW5lckhlaWdodCA9IF9iLnNjcm9sbEhlaWdodCxcbiAgICAgIGNvbnRhaW5lcldpZHRoID0gX2Iuc2Nyb2xsV2lkdGgsXG4gICAgICBjb250YWluZXJDbGllbnRIZWlnaHQgPSBfYi5jbGllbnRIZWlnaHQsXG4gICAgICBjb250YWluZXJDbGllbnRXaWR0aCA9IF9iLmNsaWVudFdpZHRoLFxuICAgICAgY2xpZW50TGVmdCA9IF9iLmNsaWVudExlZnQsXG4gICAgICBjbGllbnRUb3AgPSBfYi5jbGllbnRUb3A7XG4gIHZhciBfYyA9IG1vdmVhYmxlLnByb3BzLFxuICAgICAgX2QgPSBfYy5zbmFwR2FwLFxuICAgICAgc25hcEdhcCA9IF9kID09PSB2b2lkIDAgPyB0cnVlIDogX2QsXG4gICAgICB2ZXJ0aWNhbEd1aWRlbGluZXMgPSBfYy52ZXJ0aWNhbEd1aWRlbGluZXMsXG4gICAgICBob3Jpem9udGFsR3VpZGVsaW5lcyA9IF9jLmhvcml6b250YWxHdWlkZWxpbmVzLFxuICAgICAgX2UgPSBfYy5zbmFwVGhyZXNob2xkLFxuICAgICAgc25hcFRocmVzaG9sZCA9IF9lID09PSB2b2lkIDAgPyA1IDogX2UsXG4gICAgICBfZiA9IF9jLnNuYXBHcmlkV2lkdGgsXG4gICAgICBzbmFwR3JpZFdpZHRoID0gX2YgPT09IHZvaWQgMCA/IDAgOiBfZixcbiAgICAgIF9nID0gX2Muc25hcEdyaWRIZWlnaHQsXG4gICAgICBzbmFwR3JpZEhlaWdodCA9IF9nID09PSB2b2lkIDAgPyAwIDogX2c7XG4gIHZhciBlbGVtZW50R3VpZGVsaW5lcyA9IGdldEVsZW1lbnRHdWlkZWxpbmVzKG1vdmVhYmxlKTtcblxuICB2YXIgdG90YWxHdWlkZWxpbmVzID0gX19zcHJlYWRBcnJheShbXSwgZWxlbWVudEd1aWRlbGluZXMpO1xuXG4gIGlmIChzbmFwR2FwKSB7XG4gICAgdmFyIF9oID0gZ2V0UmVjdChnZXRBYnNvbHV0ZVBvc2VzQnlTdGF0ZShtb3ZlYWJsZS5zdGF0ZSkpLFxuICAgICAgICB0b3AgPSBfaC50b3AsXG4gICAgICAgIGxlZnQgPSBfaC5sZWZ0LFxuICAgICAgICBib3R0b20gPSBfaC5ib3R0b20sXG4gICAgICAgIHJpZ2h0ID0gX2gucmlnaHQ7XG5cbiAgICB0b3RhbEd1aWRlbGluZXMucHVzaC5hcHBseSh0b3RhbEd1aWRlbGluZXMsIGdldEdhcEd1aWRlbGluZXMobW92ZWFibGUsIHtcbiAgICAgIHRvcDogdG9wLFxuICAgICAgbGVmdDogbGVmdCxcbiAgICAgIGJvdHRvbTogYm90dG9tLFxuICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgY2VudGVyOiAobGVmdCArIHJpZ2h0KSAvIDIsXG4gICAgICBtaWRkbGU6ICh0b3AgKyBib3R0b20pIC8gMlxuICAgIH0sIHNuYXBUaHJlc2hvbGQpKTtcbiAgfVxuXG4gIHRvdGFsR3VpZGVsaW5lcy5wdXNoLmFwcGx5KHRvdGFsR3VpZGVsaW5lcywgZ2V0R3JpZEd1aWRlbGluZXMoc25hcEdyaWRXaWR0aCwgc25hcEdyaWRIZWlnaHQsIG92ZXJmbG93ID8gY29udGFpbmVyV2lkdGggOiBjb250YWluZXJDbGllbnRXaWR0aCwgb3ZlcmZsb3cgPyBjb250YWluZXJIZWlnaHQgOiBjb250YWluZXJDbGllbnRIZWlnaHQsIGNsaWVudExlZnQsIGNsaWVudFRvcCkpO1xuICB0b3RhbEd1aWRlbGluZXMucHVzaC5hcHBseSh0b3RhbEd1aWRlbGluZXMsIGdldERlZmF1bHRHdWlkZWxpbmVzKGhvcml6b250YWxHdWlkZWxpbmVzIHx8IGZhbHNlLCB2ZXJ0aWNhbEd1aWRlbGluZXMgfHwgZmFsc2UsIG92ZXJmbG93ID8gY29udGFpbmVyV2lkdGggOiBjb250YWluZXJDbGllbnRXaWR0aCwgb3ZlcmZsb3cgPyBjb250YWluZXJIZWlnaHQgOiBjb250YWluZXJDbGllbnRIZWlnaHQsIGNsaWVudExlZnQsIGNsaWVudFRvcCwgc25hcE9mZnNldCkpO1xuICByZXR1cm4gdG90YWxHdWlkZWxpbmVzO1xufVxuZnVuY3Rpb24gZ2V0R3JpZEd1aWRlbGluZXMoc25hcEdyaWRXaWR0aCwgc25hcEdyaWRIZWlnaHQsIGNvbnRhaW5lcldpZHRoLCBjb250YWluZXJIZWlnaHQsIGNsaWVudExlZnQsIGNsaWVudFRvcCkge1xuICBpZiAoY2xpZW50TGVmdCA9PT0gdm9pZCAwKSB7XG4gICAgY2xpZW50TGVmdCA9IDA7XG4gIH1cblxuICBpZiAoY2xpZW50VG9wID09PSB2b2lkIDApIHtcbiAgICBjbGllbnRUb3AgPSAwO1xuICB9XG5cbiAgdmFyIGd1aWRlbGluZXMgPSBbXTtcblxuICBpZiAoc25hcEdyaWRIZWlnaHQpIHtcbiAgICBmb3IgKHZhciBwb3MgPSAwOyBwb3MgPD0gY29udGFpbmVySGVpZ2h0OyBwb3MgKz0gc25hcEdyaWRIZWlnaHQpIHtcbiAgICAgIGd1aWRlbGluZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwiaG9yaXpvbnRhbFwiLFxuICAgICAgICBwb3M6IFswLCB0aHJvdHRsZShwb3MgLSBjbGllbnRUb3AsIDAuMSldLFxuICAgICAgICBzaXplOiBjb250YWluZXJXaWR0aCxcbiAgICAgICAgaGlkZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHNuYXBHcmlkV2lkdGgpIHtcbiAgICBmb3IgKHZhciBwb3MgPSAwOyBwb3MgPD0gY29udGFpbmVyV2lkdGg7IHBvcyArPSBzbmFwR3JpZFdpZHRoKSB7XG4gICAgICBndWlkZWxpbmVzLnB1c2goe1xuICAgICAgICB0eXBlOiBcInZlcnRpY2FsXCIsXG4gICAgICAgIHBvczogW3Rocm90dGxlKHBvcyAtIGNsaWVudExlZnQsIDAuMSksIDBdLFxuICAgICAgICBzaXplOiBjb250YWluZXJIZWlnaHQsXG4gICAgICAgIGhpZGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBndWlkZWxpbmVzO1xufVxuXG5mdW5jdGlvbiBjaGVja01vdmVhYmxlU25hcFBvc2VzKG1vdmVhYmxlLCBwb3Nlc1gsIHBvc2VzWSwgY3VzdG9tU25hcFRocmVzaG9sZCkge1xuICB2YXIgcHJvcHMgPSBtb3ZlYWJsZS5wcm9wcztcbiAgdmFyIHNuYXBUaHJlc2hvbGQgPSBzZWxlY3RWYWx1ZShjdXN0b21TbmFwVGhyZXNob2xkLCBwcm9wcy5zbmFwVGhyZXNob2xkLCA1KTtcbiAgcmV0dXJuIGNoZWNrU25hcFBvc2VzKG1vdmVhYmxlLnN0YXRlLmd1aWRlbGluZXMsIHBvc2VzWCwgcG9zZXNZLCBzbmFwVGhyZXNob2xkKTtcbn1cbmZ1bmN0aW9uIGNoZWNrU25hcFBvc2VzKGd1aWRlbGluZXMsIHBvc2VzWCwgcG9zZXNZLCBzbmFwVGhyZXNob2xkKSB7XG4gIHJldHVybiB7XG4gICAgdmVydGljYWw6IGNoZWNrU25hcChndWlkZWxpbmVzLCBcInZlcnRpY2FsXCIsIHBvc2VzWCwgc25hcFRocmVzaG9sZCksXG4gICAgaG9yaXpvbnRhbDogY2hlY2tTbmFwKGd1aWRlbGluZXMsIFwiaG9yaXpvbnRhbFwiLCBwb3Nlc1ksIHNuYXBUaHJlc2hvbGQpXG4gIH07XG59XG5mdW5jdGlvbiBjaGVja1NuYXBLZWVwUmF0aW8obW92ZWFibGUsIHN0YXJ0UG9zLCBlbmRQb3MpIHtcbiAgdmFyIGVuZFggPSBlbmRQb3NbMF0sXG4gICAgICBlbmRZID0gZW5kUG9zWzFdO1xuICB2YXIgc3RhcnRYID0gc3RhcnRQb3NbMF0sXG4gICAgICBzdGFydFkgPSBzdGFydFBvc1sxXTtcblxuICB2YXIgX2EgPSBtaW51cyhlbmRQb3MsIHN0YXJ0UG9zKSxcbiAgICAgIGR4ID0gX2FbMF0sXG4gICAgICBkeSA9IF9hWzFdO1xuXG4gIHZhciBpc0JvdHRvbSA9IGR5ID4gMDtcbiAgdmFyIGlzUmlnaHQgPSBkeCA+IDA7XG4gIGR4ID0gZ2V0VGlueURpc3QoZHgpO1xuICBkeSA9IGdldFRpbnlEaXN0KGR5KTtcbiAgdmFyIHZlcnRpY2FsSW5mbyA9IHtcbiAgICBpc1NuYXA6IGZhbHNlLFxuICAgIG9mZnNldDogMCxcbiAgICBwb3M6IDBcbiAgfTtcbiAgdmFyIGhvcml6b250YWxJbmZvID0ge1xuICAgIGlzU25hcDogZmFsc2UsXG4gICAgb2Zmc2V0OiAwLFxuICAgIHBvczogMFxuICB9O1xuXG4gIGlmIChkeCA9PT0gMCAmJiBkeSA9PT0gMCkge1xuICAgIHJldHVybiB7XG4gICAgICB2ZXJ0aWNhbDogdmVydGljYWxJbmZvLFxuICAgICAgaG9yaXpvbnRhbDogaG9yaXpvbnRhbEluZm9cbiAgICB9O1xuICB9XG5cbiAgdmFyIF9iID0gY2hlY2tNb3ZlYWJsZVNuYXBQb3Nlcyhtb3ZlYWJsZSwgZHggPyBbZW5kWF0gOiBbXSwgZHkgPyBbZW5kWV0gOiBbXSksXG4gICAgICB2ZXJ0aWNhbFNuYXBJbmZvID0gX2IudmVydGljYWwsXG4gICAgICBob3Jpem9udGFsU25hcEluZm8gPSBfYi5ob3Jpem9udGFsO1xuXG4gIHZlcnRpY2FsU25hcEluZm8ucG9zSW5mb3MuZmlsdGVyKGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBwb3MgPSBfYS5wb3M7XG4gICAgcmV0dXJuIGlzUmlnaHQgPyBwb3MgPj0gc3RhcnRYIDogcG9zIDw9IHN0YXJ0WDtcbiAgfSk7XG4gIGhvcml6b250YWxTbmFwSW5mby5wb3NJbmZvcy5maWx0ZXIoZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIHBvcyA9IF9hLnBvcztcbiAgICByZXR1cm4gaXNCb3R0b20gPyBwb3MgPj0gc3RhcnRZIDogcG9zIDw9IHN0YXJ0WTtcbiAgfSk7XG4gIHZlcnRpY2FsU25hcEluZm8uaXNTbmFwID0gdmVydGljYWxTbmFwSW5mby5wb3NJbmZvcy5sZW5ndGggPiAwO1xuICBob3Jpem9udGFsU25hcEluZm8uaXNTbmFwID0gaG9yaXpvbnRhbFNuYXBJbmZvLnBvc0luZm9zLmxlbmd0aCA+IDA7XG5cbiAgdmFyIF9jID0gZ2V0TmVhcmVzdFNuYXBHdWlkZWxpbmVJbmZvKHZlcnRpY2FsU25hcEluZm8pLFxuICAgICAgaXNWZXJ0aWNhbFNuYXAgPSBfYy5pc1NuYXAsXG4gICAgICB2ZXJ0aWNhbEd1aWRlbGluZSA9IF9jLmd1aWRlbGluZTtcblxuICB2YXIgX2QgPSBnZXROZWFyZXN0U25hcEd1aWRlbGluZUluZm8oaG9yaXpvbnRhbFNuYXBJbmZvKSxcbiAgICAgIGlzSG9yaXpvbnRhbFNuYXAgPSBfZC5pc1NuYXAsXG4gICAgICBob3Jpem9udGFsR3VpZGVsaW5lID0gX2QuZ3VpZGVsaW5lO1xuXG4gIHZhciBob3Jpem9udGFsUG9zID0gaXNIb3Jpem9udGFsU25hcCA/IGhvcml6b250YWxHdWlkZWxpbmUucG9zWzFdIDogMDtcbiAgdmFyIHZlcnRpY2FsUG9zID0gaXNWZXJ0aWNhbFNuYXAgPyB2ZXJ0aWNhbEd1aWRlbGluZS5wb3NbMF0gOiAwO1xuXG4gIGlmIChkeCA9PT0gMCkge1xuICAgIGlmIChpc0hvcml6b250YWxTbmFwKSB7XG4gICAgICBob3Jpem9udGFsSW5mby5pc1NuYXAgPSB0cnVlO1xuICAgICAgaG9yaXpvbnRhbEluZm8ucG9zID0gaG9yaXpvbnRhbEd1aWRlbGluZS5wb3NbMV07XG4gICAgICBob3Jpem9udGFsSW5mby5vZmZzZXQgPSBlbmRZIC0gaG9yaXpvbnRhbEluZm8ucG9zO1xuICAgIH1cbiAgfSBlbHNlIGlmIChkeSA9PT0gMCkge1xuICAgIGlmIChpc1ZlcnRpY2FsU25hcCkge1xuICAgICAgdmVydGljYWxJbmZvLmlzU25hcCA9IHRydWU7XG4gICAgICB2ZXJ0aWNhbEluZm8ucG9zID0gdmVydGljYWxQb3M7XG4gICAgICB2ZXJ0aWNhbEluZm8ub2Zmc2V0ID0gZW5kWCAtIHZlcnRpY2FsUG9zO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyB5IC0geTEgPSBhICogKHggLSB4MSlcbiAgICB2YXIgYSA9IGR5IC8gZHg7XG4gICAgdmFyIGIgPSBlbmRQb3NbMV0gLSBhICogZW5kWDtcbiAgICB2YXIgeSA9IDA7XG4gICAgdmFyIHggPSAwO1xuICAgIHZhciBpc1NuYXAgPSBmYWxzZTtcblxuICAgIGlmIChpc1ZlcnRpY2FsU25hcCkge1xuICAgICAgeCA9IHZlcnRpY2FsUG9zO1xuICAgICAgeSA9IGEgKiB4ICsgYjtcbiAgICAgIGlzU25hcCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChpc0hvcml6b250YWxTbmFwKSB7XG4gICAgICB5ID0gaG9yaXpvbnRhbFBvcztcbiAgICAgIHggPSAoeSAtIGIpIC8gYTtcbiAgICAgIGlzU25hcCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGlzU25hcCkge1xuICAgICAgdmVydGljYWxJbmZvLmlzU25hcCA9IHRydWU7XG4gICAgICB2ZXJ0aWNhbEluZm8ucG9zID0geDtcbiAgICAgIHZlcnRpY2FsSW5mby5vZmZzZXQgPSBlbmRYIC0geDtcbiAgICAgIGhvcml6b250YWxJbmZvLmlzU25hcCA9IHRydWU7XG4gICAgICBob3Jpem9udGFsSW5mby5wb3MgPSB5O1xuICAgICAgaG9yaXpvbnRhbEluZm8ub2Zmc2V0ID0gZW5kWSAtIHk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB2ZXJ0aWNhbDogdmVydGljYWxJbmZvLFxuICAgIGhvcml6b250YWw6IGhvcml6b250YWxJbmZvXG4gIH07XG59XG5mdW5jdGlvbiBjaGVja1NuYXBzKG1vdmVhYmxlLCByZWN0LCBjdXN0b21TbmFwVGhyZXNob2xkKSB7XG4gIHZhciBwb3NlcyA9IHNwbGl0U25hcERpcmVjdGlvblBvc2VzKG1vdmVhYmxlLnByb3BzLnNuYXBEaXJlY3Rpb25zLCByZWN0KTtcbiAgcmV0dXJuIGNoZWNrTW92ZWFibGVTbmFwUG9zZXMobW92ZWFibGUsIHBvc2VzLnZlcnRpY2FsLCBwb3Nlcy5ob3Jpem9udGFsLCBjdXN0b21TbmFwVGhyZXNob2xkKTtcbn1cbmZ1bmN0aW9uIGdldE5lYXJlc3RTbmFwR3VpZGVsaW5lSW5mbyhzbmFwSW5mbykge1xuICB2YXIgaXNTbmFwID0gc25hcEluZm8uaXNTbmFwO1xuXG4gIGlmICghaXNTbmFwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzU25hcDogZmFsc2UsXG4gICAgICBvZmZzZXQ6IDAsXG4gICAgICBkaXN0OiAtMSxcbiAgICAgIHBvczogMCxcbiAgICAgIGd1aWRlbGluZTogbnVsbFxuICAgIH07XG4gIH1cblxuICB2YXIgcG9zSW5mbyA9IHNuYXBJbmZvLnBvc0luZm9zWzBdO1xuICB2YXIgZ3VpZGVsaW5lSW5mbyA9IHBvc0luZm8uZ3VpZGVsaW5lSW5mb3NbMF07XG4gIHZhciBvZmZzZXQgPSBndWlkZWxpbmVJbmZvLm9mZnNldDtcbiAgdmFyIGRpc3QgPSBndWlkZWxpbmVJbmZvLmRpc3Q7XG4gIHZhciBndWlkZWxpbmUgPSBndWlkZWxpbmVJbmZvLmd1aWRlbGluZTtcbiAgcmV0dXJuIHtcbiAgICBpc1NuYXA6IGlzU25hcCxcbiAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICBkaXN0OiBkaXN0LFxuICAgIHBvczogcG9zSW5mby5wb3MsXG4gICAgZ3VpZGVsaW5lOiBndWlkZWxpbmVcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2hlY2tTbmFwKGd1aWRlbGluZXMsIHRhcmdldFR5cGUsIHRhcmdldFBvc2VzLCBzbmFwVGhyZXNob2xkKSB7XG4gIGlmICghZ3VpZGVsaW5lcyB8fCAhZ3VpZGVsaW5lcy5sZW5ndGgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNTbmFwOiBmYWxzZSxcbiAgICAgIGluZGV4OiAtMSxcbiAgICAgIHBvc0luZm9zOiBbXVxuICAgIH07XG4gIH1cblxuICB2YXIgaXNWZXJ0aWNhbCA9IHRhcmdldFR5cGUgPT09IFwidmVydGljYWxcIjtcbiAgdmFyIHBvc1R5cGUgPSBpc1ZlcnRpY2FsID8gMCA6IDE7XG4gIHZhciBzbmFwUG9zSW5mb3MgPSB0YXJnZXRQb3Nlcy5tYXAoZnVuY3Rpb24gKHRhcmdldFBvcywgaW5kZXgpIHtcbiAgICB2YXIgZ3VpZGVsaW5lSW5mb3MgPSBndWlkZWxpbmVzLm1hcChmdW5jdGlvbiAoZ3VpZGVsaW5lKSB7XG4gICAgICB2YXIgcG9zID0gZ3VpZGVsaW5lLnBvcztcbiAgICAgIHZhciBvZmZzZXQgPSB0YXJnZXRQb3MgLSBwb3NbcG9zVHlwZV07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgZGlzdDogTWF0aC5hYnMob2Zmc2V0KSxcbiAgICAgICAgZ3VpZGVsaW5lOiBndWlkZWxpbmVcbiAgICAgIH07XG4gICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChfYSkge1xuICAgICAgdmFyIGd1aWRlbGluZSA9IF9hLmd1aWRlbGluZSxcbiAgICAgICAgICBkaXN0ID0gX2EuZGlzdDtcbiAgICAgIHZhciB0eXBlID0gZ3VpZGVsaW5lLnR5cGU7XG5cbiAgICAgIGlmICh0eXBlICE9PSB0YXJnZXRUeXBlIHx8IGRpc3QgPiBzbmFwVGhyZXNob2xkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEuZGlzdCAtIGIuZGlzdDtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgcG9zOiB0YXJnZXRQb3MsXG4gICAgICBpbmRleDogaW5kZXgsXG4gICAgICBndWlkZWxpbmVJbmZvczogZ3VpZGVsaW5lSW5mb3NcbiAgICB9O1xuICB9KS5maWx0ZXIoZnVuY3Rpb24gKHNuYXBQb3NJbmZvKSB7XG4gICAgcmV0dXJuIHNuYXBQb3NJbmZvLmd1aWRlbGluZUluZm9zLmxlbmd0aCA+IDA7XG4gIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYS5ndWlkZWxpbmVJbmZvc1swXS5kaXN0IC0gYi5ndWlkZWxpbmVJbmZvc1swXS5kaXN0O1xuICB9KTtcbiAgdmFyIGlzU25hcCA9IHNuYXBQb3NJbmZvcy5sZW5ndGggPiAwO1xuICByZXR1cm4ge1xuICAgIGlzU25hcDogaXNTbmFwLFxuICAgIGluZGV4OiBpc1NuYXAgPyBzbmFwUG9zSW5mb3NbMF0uaW5kZXggOiAtMSxcbiAgICBwb3NJbmZvczogc25hcFBvc0luZm9zXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFNuYXBJbmZvc0J5RGlyZWN0aW9uKG1vdmVhYmxlLCBwb3Nlcywgc25hcERpcmVjdGlvbikge1xuICB2YXIgbmV4dFBvc2VzID0gW107XG5cbiAgaWYgKHNuYXBEaXJlY3Rpb25bMF0gJiYgc25hcERpcmVjdGlvblsxXSkge1xuICAgIG5leHRQb3NlcyA9IFtzbmFwRGlyZWN0aW9uLCBbLXNuYXBEaXJlY3Rpb25bMF0sIHNuYXBEaXJlY3Rpb25bMV1dLCBbc25hcERpcmVjdGlvblswXSwgLXNuYXBEaXJlY3Rpb25bMV1dXS5tYXAoZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuICAgICAgcmV0dXJuIGdldFBvc0J5RGlyZWN0aW9uKHBvc2VzLCBkaXJlY3Rpb24pO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKCFzbmFwRGlyZWN0aW9uWzBdICYmICFzbmFwRGlyZWN0aW9uWzFdKSB7XG4gICAgdmFyIGFsaWduUG9zZXMgPSBbcG9zZXNbMF0sIHBvc2VzWzFdLCBwb3Nlc1szXSwgcG9zZXNbMl0sIHBvc2VzWzBdXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgICBuZXh0UG9zZXMucHVzaChhbGlnblBvc2VzW2ldKTtcbiAgICAgIG5leHRQb3Nlcy5wdXNoKFsoYWxpZ25Qb3Nlc1tpXVswXSArIGFsaWduUG9zZXNbaSArIDFdWzBdKSAvIDIsIChhbGlnblBvc2VzW2ldWzFdICsgYWxpZ25Qb3Nlc1tpICsgMV1bMV0pIC8gMl0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAobW92ZWFibGUucHJvcHMua2VlcFJhdGlvKSB7XG4gICAgICBuZXh0UG9zZXMgPSBbWy0xLCAtMV0sIFstMSwgMV0sIFsxLCAtMV0sIFsxLCAxXSwgc25hcERpcmVjdGlvbl0ubWFwKGZ1bmN0aW9uIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIGdldFBvc0J5RGlyZWN0aW9uKHBvc2VzLCBkaXIpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRQb3NlcyA9IGdldFBvc2VzQnlEaXJlY3Rpb24ocG9zZXMsIHNuYXBEaXJlY3Rpb24pO1xuXG4gICAgICBpZiAobmV4dFBvc2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgbmV4dFBvc2VzLnB1c2goWyhuZXh0UG9zZXNbMF1bMF0gKyBuZXh0UG9zZXNbMV1bMF0pIC8gMiwgKG5leHRQb3Nlc1swXVsxXSArIG5leHRQb3Nlc1sxXVsxXSkgLyAyXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNoZWNrTW92ZWFibGVTbmFwUG9zZXMobW92ZWFibGUsIG5leHRQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgIHJldHVybiBwb3NbMF07XG4gIH0pLCBuZXh0UG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICByZXR1cm4gcG9zWzFdO1xuICB9KSwgMSk7XG59XG5mdW5jdGlvbiBjaGVja1NuYXBCb3VuZFByaW9yaXR5KGEsIGIpIHtcbiAgdmFyIGFEaXN0ID0gTWF0aC5hYnMoYS5vZmZzZXQpO1xuICB2YXIgYkRpc3QgPSBNYXRoLmFicyhiLm9mZnNldCk7XG5cbiAgaWYgKGEuaXNCb3VuZCAmJiBiLmlzQm91bmQpIHtcbiAgICByZXR1cm4gYkRpc3QgLSBhRGlzdDtcbiAgfSBlbHNlIGlmIChhLmlzQm91bmQpIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSBpZiAoYi5pc0JvdW5kKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSBpZiAoYS5pc1NuYXAgJiYgYi5pc1NuYXApIHtcbiAgICByZXR1cm4gYkRpc3QgLSBhRGlzdDtcbiAgfSBlbHNlIGlmIChhLmlzU25hcCkge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIGlmIChiLmlzU25hcCkge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2UgaWYgKGFEaXN0IDwgVElOWV9OVU0pIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIGlmIChiRGlzdCA8IFRJTllfTlVNKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgcmV0dXJuIGFEaXN0IC0gYkRpc3Q7XG59XG5mdW5jdGlvbiBnZXROZWFyT2Zmc2V0SW5mbyhvZmZzZXRzLCBpbmRleCkge1xuICByZXR1cm4gb2Zmc2V0cy5zbGljZSgpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICB2YXIgYVNpZ24gPSBhLnNpZ25baW5kZXhdO1xuICAgIHZhciBiU2lnbiA9IGIuc2lnbltpbmRleF07XG4gICAgdmFyIGFPZmZzZXQgPSBhLm9mZnNldFtpbmRleF07XG4gICAgdmFyIGJPZmZzZXQgPSBiLm9mZnNldFtpbmRleF07IC8vIC0xIFRoZSBwb3NpdGlvbnMgb2YgYSBhbmQgYiBkbyBub3QgY2hhbmdlLlxuICAgIC8vIDEgVGhlIHBvc2l0aW9ucyBvZiBhIGFuZCBiIGFyZSByZXZlcnNlZC5cblxuICAgIGlmICghYVNpZ24pIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoIWJTaWduKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoZWNrU25hcEJvdW5kUHJpb3JpdHkoe1xuICAgICAgaXNCb3VuZDogYS5pc0JvdW5kLFxuICAgICAgaXNTbmFwOiBhLmlzU25hcCxcbiAgICAgIG9mZnNldDogYU9mZnNldFxuICAgIH0sIHtcbiAgICAgIGlzQm91bmQ6IGIuaXNCb3VuZCxcbiAgICAgIGlzU25hcDogYi5pc1NuYXAsXG4gICAgICBvZmZzZXQ6IGJPZmZzZXRcbiAgICB9KTtcbiAgfSlbMF07XG59XG5mdW5jdGlvbiBnZXRDaGVja1NuYXBEaXJlY3Rpb25zKGRpcmVjdGlvbiwga2VlcFJhdGlvKSB7XG4gIHZhciBkaXJlY3Rpb25zID0gW107XG4gIHZhciBmaXhlZERpcmVjdGlvbiA9IFstZGlyZWN0aW9uWzBdLCAtZGlyZWN0aW9uWzFdXTtcblxuICBpZiAoZGlyZWN0aW9uWzBdICYmIGRpcmVjdGlvblsxXSkge1xuICAgIGRpcmVjdGlvbnMucHVzaChbZml4ZWREaXJlY3Rpb24sIFtkaXJlY3Rpb25bMF0sIC1kaXJlY3Rpb25bMV1dXSwgW2ZpeGVkRGlyZWN0aW9uLCBbLWRpcmVjdGlvblswXSwgZGlyZWN0aW9uWzFdXV0pO1xuXG4gICAgaWYgKGtlZXBSYXRpbykge1xuICAgICAgLy8gcGFzcyB0d28gZGlyZWN0aW9uIGNvbmRpdGlvblxuICAgICAgZGlyZWN0aW9ucy5wdXNoKFtmaXhlZERpcmVjdGlvbiwgZGlyZWN0aW9uXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRpcmVjdGlvblswXSkge1xuICAgIC8vIHZlcnRjYWxcbiAgICBpZiAoa2VlcFJhdGlvKSB7XG4gICAgICBkaXJlY3Rpb25zLnB1c2goW2ZpeGVkRGlyZWN0aW9uLCBbZml4ZWREaXJlY3Rpb25bMF0sIC0xXV0sIFtmaXhlZERpcmVjdGlvbiwgW2ZpeGVkRGlyZWN0aW9uWzBdLCAxXV0sIFtmaXhlZERpcmVjdGlvbiwgW2RpcmVjdGlvblswXSwgLTFdXSwgW2ZpeGVkRGlyZWN0aW9uLCBkaXJlY3Rpb25dLCBbZml4ZWREaXJlY3Rpb24sIFtkaXJlY3Rpb25bMF0sIDFdXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpcmVjdGlvbnMucHVzaChbW2ZpeGVkRGlyZWN0aW9uWzBdLCAtMV0sIFtkaXJlY3Rpb25bMF0sIC0xXV0sIFtbZml4ZWREaXJlY3Rpb25bMF0sIDBdLCBbZGlyZWN0aW9uWzBdLCAwXV0sIFtbZml4ZWREaXJlY3Rpb25bMF0sIDFdLCBbZGlyZWN0aW9uWzBdLCAxXV0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChkaXJlY3Rpb25bMV0pIHtcbiAgICAvLyBob3Jpem9udGFsXG4gICAgaWYgKGtlZXBSYXRpbykge1xuICAgICAgZGlyZWN0aW9ucy5wdXNoKFtmaXhlZERpcmVjdGlvbiwgWy0xLCBmaXhlZERpcmVjdGlvblsxXV1dLCBbZml4ZWREaXJlY3Rpb24sIFsxLCBmaXhlZERpcmVjdGlvblsxXV1dLCBbZml4ZWREaXJlY3Rpb24sIFstMSwgZGlyZWN0aW9uWzFdXV0sIFtmaXhlZERpcmVjdGlvbiwgWzEsIGRpcmVjdGlvblsxXV1dLCBbZml4ZWREaXJlY3Rpb24sIGRpcmVjdGlvbl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXJlY3Rpb25zLnB1c2goW1stMSwgZml4ZWREaXJlY3Rpb25bMV1dLCBbLTEsIGRpcmVjdGlvblsxXV1dLCBbWzAsIGZpeGVkRGlyZWN0aW9uWzFdXSwgWzAsIGRpcmVjdGlvblsxXV1dLCBbWzEsIGZpeGVkRGlyZWN0aW9uWzFdXSwgWzEsIGRpcmVjdGlvblsxXV1dKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gWzAsIDBdIHRvIGFsbCBkaXJlY3Rpb25cbiAgICBkaXJlY3Rpb25zLnB1c2goW2ZpeGVkRGlyZWN0aW9uLCBbMSwgMF1dLCBbZml4ZWREaXJlY3Rpb24sIFstMSwgMF1dLCBbZml4ZWREaXJlY3Rpb24sIFswLCAtMV1dLCBbZml4ZWREaXJlY3Rpb24sIFswLCAxXV0sIFtbMSwgMF0sIFsxLCAtMV1dLCBbWzEsIDBdLCBbMSwgMV1dLCBbWzAsIDFdLCBbMSwgMV1dLCBbWzAsIDFdLCBbLTEsIDFdXSwgW1stMSwgMF0sIFstMSwgLTFdXSwgW1stMSwgMF0sIFstMSwgMV1dLCBbWzAsIC0xXSwgWzEsIC0xXV0sIFtbMCwgLTFdLCBbLTEsIC0xXV0pO1xuICB9XG5cbiAgcmV0dXJuIGRpcmVjdGlvbnM7XG59XG5cbmZ1bmN0aW9uIGlzU3RhcnRMaW5lKGRvdCwgbGluZSkge1xuICAvLyBsICAgIG8gICAgID0+IHRydWVcbiAgLy8gbyAgICBsICAgID0+IGZhbHNlXG4gIHZhciBjeCA9IGF2ZXJhZ2UoW2xpbmVbMF1bMF0sIGxpbmVbMV1bMF1dKTtcbiAgdmFyIGN5ID0gYXZlcmFnZShbbGluZVswXVsxXSwgbGluZVsxXVsxXV0pO1xuICByZXR1cm4ge1xuICAgIHZlcnRpY2FsOiBjeCA8PSBkb3RbMF0sXG4gICAgaG9yaXpvbnRhbDogY3kgPD0gZG90WzFdXG4gIH07XG59XG5cbmZ1bmN0aW9uIGhpdFRlc3RMaW5lKGRvdCwgX2EpIHtcbiAgdmFyIHBvczEgPSBfYVswXSxcbiAgICAgIHBvczIgPSBfYVsxXTtcbiAgdmFyIGR4ID0gcG9zMlswXSAtIHBvczFbMF07XG4gIHZhciBkeSA9IHBvczJbMV0gLSBwb3MxWzFdO1xuXG4gIGlmIChNYXRoLmFicyhkeCkgPCBUSU5ZX05VTSkge1xuICAgIGR4ID0gMDtcbiAgfVxuXG4gIGlmIChNYXRoLmFicyhkeSkgPCBUSU5ZX05VTSkge1xuICAgIGR5ID0gMDtcbiAgfVxuXG4gIHZhciB0ZXN0MTtcbiAgdmFyIHRlc3QyO1xuXG4gIGlmICghZHgpIHtcbiAgICB0ZXN0MSA9IHBvczFbMF07XG4gICAgdGVzdDIgPSBkb3RbMF07XG4gIH0gZWxzZSBpZiAoIWR5KSB7XG4gICAgdGVzdDEgPSBwb3MxWzFdO1xuICAgIHRlc3QyID0gZG90WzFdO1xuICB9IGVsc2Uge1xuICAgIHZhciBhID0gZHkgLyBkeDsgLy8geSA9IGEgKiAoeCAtIHBvczEpICsgcG9zMVxuXG4gICAgdGVzdDEgPSBhICogKGRvdFswXSAtIHBvczFbMF0pICsgcG9zMVsxXTtcbiAgICB0ZXN0MiA9IGRvdFsxXTtcbiAgfVxuXG4gIHJldHVybiB0ZXN0MSAtIHRlc3QyO1xufVxuXG5mdW5jdGlvbiBpc1NhbWVTdGFydExpbmUoZG90cywgbGluZSwgZXJyb3IpIHtcbiAgaWYgKGVycm9yID09PSB2b2lkIDApIHtcbiAgICBlcnJvciA9IFRJTllfTlVNO1xuICB9XG5cbiAgdmFyIGNlbnRlclNpZ24gPSBoaXRUZXN0TGluZShkb3RzWzBdLCBsaW5lKSA8PSAwO1xuICByZXR1cm4gZG90cy5zbGljZSgxKS5ldmVyeShmdW5jdGlvbiAoZG90KSB7XG4gICAgdmFyIHZhbHVlID0gaGl0VGVzdExpbmUoZG90LCBsaW5lKTtcbiAgICB2YXIgc2lnbiA9IHZhbHVlIDw9IDA7XG4gICAgcmV0dXJuIHNpZ24gPT09IGNlbnRlclNpZ24gfHwgTWF0aC5hYnModmFsdWUpIDw9IGVycm9yO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY2hlY2tJbm5lckJvdW5kRG90KHBvcywgc3RhcnQsIGVuZCwgaXNTdGFydCwgdGhyZXNob2xkKSB7XG4gIGlmICh0aHJlc2hvbGQgPT09IHZvaWQgMCkge1xuICAgIHRocmVzaG9sZCA9IDA7XG4gIH1cblxuICBpZiAoaXNTdGFydCAmJiBzdGFydCAtIHRocmVzaG9sZCA8PSBwb3MgfHwgIWlzU3RhcnQgJiYgcG9zIDw9IGVuZCArIHRocmVzaG9sZCkge1xuICAgIC8vIGZhbHNlIDQwMiA1NjUgNjAyID0+IDM3IChbMCwgMzddKVxuICAgIC8vIHRydWUgNDAwIDUyNC45NzEyNjAzNTQwMDM2IDYwMCA9PiAxMjQgKFsxMjQsIDBdKVxuICAgIC8vIHRydWUgNDAwIDQxMCA2MDAgPT4gMTAgKFsxMCwgMF0pXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzQm91bmQ6IHRydWUsXG4gICAgICBvZmZzZXQ6IGlzU3RhcnQgPyBzdGFydCAtIHBvcyA6IGVuZCAtIHBvc1xuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGlzQm91bmQ6IGZhbHNlLFxuICAgIG9mZnNldDogMFxuICB9O1xufVxuXG5mdW5jdGlvbiBjaGVja0lubmVyQm91bmQobW92ZWFibGUsIGxpbmUsIGNlbnRlcikge1xuICB2YXIgYm91bmRzID0gbW92ZWFibGUucHJvcHMuaW5uZXJCb3VuZHM7XG5cbiAgaWYgKCFib3VuZHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNBbGxCb3VuZDogZmFsc2UsXG4gICAgICBpc0JvdW5kOiBmYWxzZSxcbiAgICAgIGlzVmVydGljYWxCb3VuZDogZmFsc2UsXG4gICAgICBpc0hvcml6b250YWxCb3VuZDogZmFsc2UsXG4gICAgICBvZmZzZXQ6IFswLCAwXVxuICAgIH07XG4gIH1cblxuICB2YXIgbGVmdCA9IGJvdW5kcy5sZWZ0LFxuICAgICAgdG9wID0gYm91bmRzLnRvcCxcbiAgICAgIHdpZHRoID0gYm91bmRzLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gYm91bmRzLmhlaWdodDtcbiAgdmFyIGxlZnRMaW5lID0gW1tsZWZ0LCB0b3BdLCBbbGVmdCwgdG9wICsgaGVpZ2h0XV07XG4gIHZhciB0b3BMaW5lID0gW1tsZWZ0LCB0b3BdLCBbbGVmdCArIHdpZHRoLCB0b3BdXTtcbiAgdmFyIHJpZ2h0TGluZSA9IFtbbGVmdCArIHdpZHRoLCB0b3BdLCBbbGVmdCArIHdpZHRoLCB0b3AgKyBoZWlnaHRdXTtcbiAgdmFyIGJvdHRvbUxpbmUgPSBbW2xlZnQsIHRvcCArIGhlaWdodF0sIFtsZWZ0ICsgd2lkdGgsIHRvcCArIGhlaWdodF1dO1xuXG4gIHZhciBfYSA9IGlzU3RhcnRMaW5lKGNlbnRlciwgbGluZSksXG4gICAgICBpc0hvcml6b250YWxTdGFydCA9IF9hLmhvcml6b250YWwsXG4gICAgICBpc1ZlcnRpY2FsU3RhcnQgPSBfYS52ZXJ0aWNhbDtcblxuICBpZiAoaXNTYW1lU3RhcnRMaW5lKFtjZW50ZXIsIFtsZWZ0LCB0b3BdLCBbbGVmdCArIHdpZHRoLCB0b3BdLCBbbGVmdCwgdG9wICsgaGVpZ2h0XSwgW2xlZnQgKyB3aWR0aCwgdG9wICsgaGVpZ2h0XV0sIGxpbmUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzQWxsQm91bmQ6IGZhbHNlLFxuICAgICAgaXNCb3VuZDogZmFsc2UsXG4gICAgICBpc1ZlcnRpY2FsQm91bmQ6IGZhbHNlLFxuICAgICAgaXNIb3Jpem9udGFsQm91bmQ6IGZhbHNlLFxuICAgICAgb2Zmc2V0OiBbMCwgMF1cbiAgICB9O1xuICB9IC8vIHRlc3QgdmVydGljYWxcblxuXG4gIHZhciB0b3BCb3VuZEluZm8gPSBjaGVja0xpbmVCb3VuZENvbGxpc2lvbihsaW5lLCB0b3BMaW5lLCBpc1ZlcnRpY2FsU3RhcnQpO1xuICB2YXIgYm90dG9tQm91bmRJbmZvID0gY2hlY2tMaW5lQm91bmRDb2xsaXNpb24obGluZSwgYm90dG9tTGluZSwgaXNWZXJ0aWNhbFN0YXJ0KTsgLy8gdGVzdCBob3Jpem9udGFsXG5cbiAgdmFyIGxlZnRCb3VuZEluZm8gPSBjaGVja0xpbmVCb3VuZENvbGxpc2lvbihsaW5lLCBsZWZ0TGluZSwgaXNIb3Jpem9udGFsU3RhcnQpO1xuICB2YXIgcmlnaHRCb3VuZEluZm8gPSBjaGVja0xpbmVCb3VuZENvbGxpc2lvbihsaW5lLCByaWdodExpbmUsIGlzSG9yaXpvbnRhbFN0YXJ0KTtcbiAgdmFyIGlzQWxsVmVydGljYWxCb3VuZCA9IHRvcEJvdW5kSW5mby5pc0JvdW5kICYmIGJvdHRvbUJvdW5kSW5mby5pc0JvdW5kO1xuICB2YXIgaXNWZXJ0aWNhbEJvdW5kID0gdG9wQm91bmRJbmZvLmlzQm91bmQgfHwgYm90dG9tQm91bmRJbmZvLmlzQm91bmQ7XG4gIHZhciBpc0FsbEhvcml6b250YWxCb3VuZCA9IGxlZnRCb3VuZEluZm8uaXNCb3VuZCAmJiByaWdodEJvdW5kSW5mby5pc0JvdW5kO1xuICB2YXIgaXNIb3Jpem9udGFsQm91bmQgPSBsZWZ0Qm91bmRJbmZvLmlzQm91bmQgfHwgcmlnaHRCb3VuZEluZm8uaXNCb3VuZDtcbiAgdmFyIHZlcnRpY2FsT2Zmc2V0ID0gbWF4T2Zmc2V0KHRvcEJvdW5kSW5mby5vZmZzZXQsIGJvdHRvbUJvdW5kSW5mby5vZmZzZXQpO1xuICB2YXIgaG9yaXpvbnRhbE9mZnNldCA9IG1heE9mZnNldChsZWZ0Qm91bmRJbmZvLm9mZnNldCwgcmlnaHRCb3VuZEluZm8ub2Zmc2V0KTtcbiAgdmFyIG9mZnNldCA9IFswLCAwXTtcbiAgdmFyIGlzQm91bmQgPSBmYWxzZTtcbiAgdmFyIGlzQWxsQm91bmQgPSBmYWxzZTtcblxuICBpZiAoTWF0aC5hYnMoaG9yaXpvbnRhbE9mZnNldCkgPCBNYXRoLmFicyh2ZXJ0aWNhbE9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBbdmVydGljYWxPZmZzZXQsIDBdO1xuICAgIGlzQm91bmQgPSBpc1ZlcnRpY2FsQm91bmQ7XG4gICAgaXNBbGxCb3VuZCA9IGlzQWxsVmVydGljYWxCb3VuZDtcbiAgfSBlbHNlIHtcbiAgICBvZmZzZXQgPSBbMCwgaG9yaXpvbnRhbE9mZnNldF07XG4gICAgaXNCb3VuZCA9IGlzSG9yaXpvbnRhbEJvdW5kO1xuICAgIGlzQWxsQm91bmQgPSBpc0FsbEhvcml6b250YWxCb3VuZDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaXNBbGxCb3VuZDogaXNBbGxCb3VuZCxcbiAgICBpc1ZlcnRpY2FsQm91bmQ6IGlzVmVydGljYWxCb3VuZCxcbiAgICBpc0hvcml6b250YWxCb3VuZDogaXNIb3Jpem9udGFsQm91bmQsXG4gICAgaXNCb3VuZDogaXNCb3VuZCxcbiAgICBvZmZzZXQ6IG9mZnNldFxuICB9O1xufVxuXG5mdW5jdGlvbiBjaGVja0xpbmVCb3VuZENvbGxpc2lvbihsaW5lLCBib3VuZExpbmUsIGlzU3RhcnQsIHRocmVzaG9sZCwgaXNSZW5kZXIpIHtcbiAgdmFyIGRvdDEgPSBsaW5lWzBdO1xuICB2YXIgZG90MiA9IGxpbmVbMV07XG4gIHZhciBib3VuZERvdDEgPSBib3VuZExpbmVbMF07XG4gIHZhciBib3VuZERvdDIgPSBib3VuZExpbmVbMV07XG4gIHZhciBkeTEgPSBnZXRUaW55RGlzdChkb3QyWzFdIC0gZG90MVsxXSk7XG4gIHZhciBkeDEgPSBnZXRUaW55RGlzdChkb3QyWzBdIC0gZG90MVswXSk7XG4gIHZhciBkeTIgPSBnZXRUaW55RGlzdChib3VuZERvdDJbMV0gLSBib3VuZERvdDFbMV0pO1xuICB2YXIgZHgyID0gZ2V0VGlueURpc3QoYm91bmREb3QyWzBdIC0gYm91bmREb3QxWzBdKTsgLy8gZHgyIG9yIGR5MiBpcyB6ZXJvXG5cbiAgaWYgKCFkeDIpIHtcbiAgICAvLyB2ZXJ0aWNhbFxuICAgIGlmIChpc1JlbmRlciAmJiAhZHkxKSB7XG4gICAgICAvLyA5MGRlZ1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNCb3VuZDogZmFsc2UsXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGR4MSkge1xuICAgICAgLy8gY29uc3QgeSA9IGR5MSA/IGR5MSAvIGR4MSAqIChib3VuZERvdDFbMF0gLSBkb3QxWzBdKSArIGRvdDFbMV0gOiBkb3QxWzFdO1xuICAgICAgdmFyIHkgPSBkeTEgLyBkeDEgKiAoYm91bmREb3QxWzBdIC0gZG90MVswXSkgKyBkb3QxWzFdOyAvLyBib3VuZERvdDFbMV0gPD0geSAgPD0gYm91bmREb3QyWzFdXG5cbiAgICAgIHJldHVybiBjaGVja0lubmVyQm91bmREb3QoeSwgYm91bmREb3QxWzFdLCBib3VuZERvdDJbMV0sIGlzU3RhcnQsIHRocmVzaG9sZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvZmZzZXQgPSBib3VuZERvdDFbMF0gLSBkb3QxWzBdO1xuICAgICAgdmFyIGlzQm91bmQgPSBNYXRoLmFicyhvZmZzZXQpIDw9ICh0aHJlc2hvbGQgfHwgMCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc0JvdW5kOiBpc0JvdW5kLFxuICAgICAgICBvZmZzZXQ6IGlzQm91bmQgPyBvZmZzZXQgOiAwXG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIGlmICghZHkyKSB7XG4gICAgLy8gaG9yaXpvbnRhbFxuICAgIGlmIChpc1JlbmRlciAmJiAhZHgxKSB7XG4gICAgICAvLyA5MGRlZ1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNCb3VuZDogZmFsc2UsXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGR5MSkge1xuICAgICAgLy8geSA9IGEgKiAoeCAtIHgxKSArIHkxXG4gICAgICAvLyB4ID0gKHkgLSB5MSkgLyBhICsgeDFcbiAgICAgIC8vIGNvbnN0IGEgPSBkeTEgLyBkeDE7XG4gICAgICAvLyBjb25zdCB4ID0gZHgxID8gKGJvdW5kRG90MVsxXSAtIGRvdDFbMV0pIC8gYSArIGRvdDFbMF0gOiBkb3QxWzBdO1xuICAgICAgdmFyIHggPSAoYm91bmREb3QxWzFdIC0gZG90MVsxXSkgLyAoZHkxIC8gZHgxKSArIGRvdDFbMF07IC8vIGJvdW5kRG90MVswXSA8PSB4ICYmIHggPD0gYm91bmREb3QyWzBdXG5cbiAgICAgIHJldHVybiBjaGVja0lubmVyQm91bmREb3QoeCwgYm91bmREb3QxWzBdLCBib3VuZERvdDJbMF0sIGlzU3RhcnQsIHRocmVzaG9sZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvZmZzZXQgPSBib3VuZERvdDFbMV0gLSBkb3QxWzFdO1xuICAgICAgdmFyIGlzQm91bmQgPSBNYXRoLmFicyhvZmZzZXQpIDw9ICh0aHJlc2hvbGQgfHwgMCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc0JvdW5kOiBpc0JvdW5kLFxuICAgICAgICBvZmZzZXQ6IGlzQm91bmQgPyBvZmZzZXQgOiAwXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaXNCb3VuZDogZmFsc2UsXG4gICAgb2Zmc2V0OiAwXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldElubmVyQm91bmRJbmZvKG1vdmVhYmxlLCBsaW5lcywgY2VudGVyLCBkYXRhcykge1xuICByZXR1cm4gbGluZXMubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBtdWx0aXBsZSA9IF9hWzBdLFxuICAgICAgICBwb3MxID0gX2FbMV0sXG4gICAgICAgIHBvczIgPSBfYVsyXTtcblxuICAgIHZhciBfYiA9IGNoZWNrSW5uZXJCb3VuZChtb3ZlYWJsZSwgW3BvczEsIHBvczJdLCBjZW50ZXIpLFxuICAgICAgICBpc0JvdW5kID0gX2IuaXNCb3VuZCxcbiAgICAgICAgb2Zmc2V0ID0gX2Iub2Zmc2V0LFxuICAgICAgICBpc1ZlcnRpY2FsQm91bmQgPSBfYi5pc1ZlcnRpY2FsQm91bmQsXG4gICAgICAgIGlzSG9yaXpvbnRhbEJvdW5kID0gX2IuaXNIb3Jpem9udGFsQm91bmQ7XG5cbiAgICB2YXIgc2l6ZU9mZnNldCA9IGdldERyYWdEaXN0KHtcbiAgICAgIGRhdGFzOiBkYXRhcyxcbiAgICAgIGRpc3RYOiBvZmZzZXRbMF0sXG4gICAgICBkaXN0WTogb2Zmc2V0WzFdXG4gICAgfSkubWFwKGZ1bmN0aW9uIChzaXplLCBpKSB7XG4gICAgICByZXR1cm4gc2l6ZSAqIChtdWx0aXBsZVtpXSA/IDIgLyBtdWx0aXBsZVtpXSA6IDApO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBzaWduOiBtdWx0aXBsZSxcbiAgICAgIGlzQm91bmQ6IGlzQm91bmQsXG4gICAgICBpc1ZlcnRpY2FsQm91bmQ6IGlzVmVydGljYWxCb3VuZCxcbiAgICAgIGlzSG9yaXpvbnRhbEJvdW5kOiBpc0hvcml6b250YWxCb3VuZCxcbiAgICAgIGlzU25hcDogZmFsc2UsXG4gICAgICBvZmZzZXQ6IHNpemVPZmZzZXRcbiAgICB9O1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldElubmVyQm91bmREcmFnSW5mbyhtb3ZlYWJsZSwgcG9zZXMsIGRhdGFzKSB7XG4gIHZhciBfYTtcblxuICB2YXIgbGluZXMgPSBnZXRDaGVja0lubmVyQm91bmRMaW5lcyhwb3NlcywgWzAsIDBdLCBmYWxzZSkubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBzaWduID0gX2FbMF0sXG4gICAgICAgIHBvczEgPSBfYVsxXSxcbiAgICAgICAgcG9zMiA9IF9hWzJdO1xuICAgIHJldHVybiBbc2lnbi5tYXAoZnVuY3Rpb24gKGRpcikge1xuICAgICAgcmV0dXJuIE1hdGguYWJzKGRpcikgKiAyO1xuICAgIH0pLCBwb3MxLCBwb3MyXTtcbiAgfSk7XG4gIHZhciBpbm5lckJvdW5kSW5mbyA9IGdldElubmVyQm91bmRJbmZvKG1vdmVhYmxlLCBsaW5lcywgZ2V0UG9zQnlEaXJlY3Rpb24ocG9zZXMsIFswLCAwXSksIGRhdGFzKTtcbiAgdmFyIHdpZHRoT2Zmc2V0SW5mbyA9IGdldE5lYXJPZmZzZXRJbmZvKGlubmVyQm91bmRJbmZvLCAwKTtcbiAgdmFyIGhlaWdodE9mZnNldEluZm8gPSBnZXROZWFyT2Zmc2V0SW5mbyhpbm5lckJvdW5kSW5mbywgMSk7XG4gIHZhciB2ZXJ0aWNhbE9mZnNldCA9IDA7XG4gIHZhciBob3Jpem9udGFsT2Zmc2V0ID0gMDtcbiAgdmFyIGlzVmVydGljYWxCb3VuZCA9IHdpZHRoT2Zmc2V0SW5mby5pc1ZlcnRpY2FsQm91bmQgfHwgaGVpZ2h0T2Zmc2V0SW5mby5pc1ZlcnRpY2FsQm91bmQ7XG4gIHZhciBpc0hvcml6b250YWxCb3VuZCA9IHdpZHRoT2Zmc2V0SW5mby5pc0hvcml6b250YWxCb3VuZCB8fCBoZWlnaHRPZmZzZXRJbmZvLmlzSG9yaXpvbnRhbEJvdW5kO1xuXG4gIGlmIChpc1ZlcnRpY2FsQm91bmQgfHwgaXNIb3Jpem9udGFsQm91bmQpIHtcbiAgICBfYSA9IGdldEludmVyc2VEcmFnRGlzdCh7XG4gICAgICBkYXRhczogZGF0YXMsXG4gICAgICBkaXN0WDogLXdpZHRoT2Zmc2V0SW5mby5vZmZzZXRbMF0sXG4gICAgICBkaXN0WTogLWhlaWdodE9mZnNldEluZm8ub2Zmc2V0WzFdXG4gICAgfSksIHZlcnRpY2FsT2Zmc2V0ID0gX2FbMF0sIGhvcml6b250YWxPZmZzZXQgPSBfYVsxXTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdmVydGljYWw6IHtcbiAgICAgIGlzQm91bmQ6IGlzVmVydGljYWxCb3VuZCxcbiAgICAgIG9mZnNldDogdmVydGljYWxPZmZzZXRcbiAgICB9LFxuICAgIGhvcml6b250YWw6IHtcbiAgICAgIGlzQm91bmQ6IGlzSG9yaXpvbnRhbEJvdW5kLFxuICAgICAgb2Zmc2V0OiBob3Jpem9udGFsT2Zmc2V0XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0Q2hlY2tTbmFwTGluZURpcmVjdGlvbnMoZGlyZWN0aW9uLCBrZWVwUmF0aW8pIHtcbiAgdmFyIGxpbmVEaXJlY3Rpb25zID0gW107XG4gIHZhciB4ID0gZGlyZWN0aW9uWzBdO1xuICB2YXIgeSA9IGRpcmVjdGlvblsxXTtcblxuICBpZiAoeCAmJiB5KSB7XG4gICAgbGluZURpcmVjdGlvbnMucHVzaChbWzAsIHkgKiAyXSwgZGlyZWN0aW9uLCBbLXgsIHldXSwgW1t4ICogMiwgMF0sIGRpcmVjdGlvbiwgW3gsIC15XV0pO1xuICB9IGVsc2UgaWYgKHgpIHtcbiAgICAvLyB2ZXJ0Y2FsXG4gICAgbGluZURpcmVjdGlvbnMucHVzaChbW3ggKiAyLCAwXSwgW3gsIDFdLCBbeCwgLTFdXSk7XG5cbiAgICBpZiAoa2VlcFJhdGlvKSB7XG4gICAgICBsaW5lRGlyZWN0aW9ucy5wdXNoKFtbMCwgLTFdLCBbeCwgLTFdLCBbLXgsIC0xXV0sIFtbMCwgMV0sIFt4LCAxXSwgWy14LCAxXV0pO1xuICAgIH1cbiAgfSBlbHNlIGlmICh5KSB7XG4gICAgLy8gaG9yaXpvbnRhbFxuICAgIGxpbmVEaXJlY3Rpb25zLnB1c2goW1swLCB5ICogMl0sIFsxLCB5XSwgWy0xLCB5XV0pO1xuXG4gICAgaWYgKGtlZXBSYXRpbykge1xuICAgICAgbGluZURpcmVjdGlvbnMucHVzaChbWy0xLCAwXSwgWy0xLCB5XSwgWy0xLCAteV1dLCBbWzEsIDBdLCBbMSwgeV0sIFsxLCAteV1dKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gWzAsIDBdIHRvIGFsbCBkaXJlY3Rpb25cbiAgICBsaW5lRGlyZWN0aW9ucy5wdXNoKFtbLTEsIDBdLCBbLTEsIC0xXSwgWy0xLCAxXV0sIFtbMSwgMF0sIFsxLCAtMV0sIFsxLCAxXV0sIFtbMCwgLTFdLCBbLTEsIC0xXSwgWzEsIC0xXV0sIFtbMCwgMV0sIFstMSwgMV0sIFsxLCAxXV0pO1xuICB9XG5cbiAgcmV0dXJuIGxpbmVEaXJlY3Rpb25zO1xufVxuZnVuY3Rpb24gZ2V0Q2hlY2tJbm5lckJvdW5kTGluZXMocG9zZXMsIGRpcmVjdGlvbiwga2VlcFJhdGlvKSB7XG4gIHJldHVybiBnZXRDaGVja1NuYXBMaW5lRGlyZWN0aW9ucyhkaXJlY3Rpb24sIGtlZXBSYXRpbykubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBzaWduID0gX2FbMF0sXG4gICAgICAgIGRpcjEgPSBfYVsxXSxcbiAgICAgICAgZGlyMiA9IF9hWzJdO1xuICAgIHJldHVybiBbc2lnbiwgZ2V0UG9zQnlEaXJlY3Rpb24ocG9zZXMsIGRpcjEpLCBnZXRQb3NCeURpcmVjdGlvbihwb3NlcywgZGlyMildO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaXNCb3VuZFJvdGF0ZShyZWxhdGl2ZVBvc2VzLCBib3VuZERvdHMsIGNlbnRlciwgcmFkKSB7XG4gIHZhciBuZXh0UG9zZXMgPSByYWQgPyByZWxhdGl2ZVBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgcmV0dXJuIHJvdGF0ZShwb3MsIHJhZCk7XG4gIH0pIDogcmVsYXRpdmVQb3NlcztcblxuICB2YXIgZG90cyA9IF9fc3ByZWFkQXJyYXkoW2NlbnRlcl0sIGJvdW5kRG90cyk7XG5cbiAgcmV0dXJuIFtbbmV4dFBvc2VzWzBdLCBuZXh0UG9zZXNbMV1dLCBbbmV4dFBvc2VzWzFdLCBuZXh0UG9zZXNbM11dLCBbbmV4dFBvc2VzWzNdLCBuZXh0UG9zZXNbMl1dLCBbbmV4dFBvc2VzWzJdLCBuZXh0UG9zZXNbMF1dXS5zb21lKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgcmV0dXJuICFpc1NhbWVTdGFydExpbmUoZG90cywgbGluZSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXREaXN0UG9pbnRMaW5lKF9hKSB7XG4gIC8vIHggPSAwLCB5ID0gMFxuICAvLyBkID0gKGF4ICsgYnkgKyBjKSAvIHJvb3QoYTIgKyBiMilcbiAgdmFyIHBvczEgPSBfYVswXSxcbiAgICAgIHBvczIgPSBfYVsxXTtcbiAgdmFyIGR4ID0gcG9zMlswXSAtIHBvczFbMF07XG4gIHZhciBkeSA9IHBvczJbMV0gLSBwb3MxWzFdO1xuXG4gIGlmICghZHgpIHtcbiAgICByZXR1cm4gTWF0aC5hYnMocG9zMVswXSk7XG4gIH1cblxuICBpZiAoIWR5KSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKHBvczFbMV0pO1xuICB9IC8vIHkgLSB5MSA9IGEoeCAtIHgxKVxuICAvLyAwID0gYXggLXkgKyAtYSAqIHgxICsgeTFcblxuXG4gIHZhciBhID0gZHkgLyBkeDtcbiAgcmV0dXJuIE1hdGguYWJzKCgtYSAqIHBvczFbMF0gKyBwb3MxWzFdKSAvIE1hdGguc3FydChNYXRoLnBvdyhhLCAyKSArIDEpKTtcbn1cblxuZnVuY3Rpb24gc29sdmVSZXZlcnNlTGluZShfYSkge1xuICB2YXIgcG9zMSA9IF9hWzBdLFxuICAgICAgcG9zMiA9IF9hWzFdO1xuICB2YXIgZHggPSBwb3MyWzBdIC0gcG9zMVswXTtcbiAgdmFyIGR5ID0gcG9zMlsxXSAtIHBvczFbMV07XG5cbiAgaWYgKCFkeCkge1xuICAgIHJldHVybiBbcG9zMVswXSwgMF07XG4gIH1cblxuICBpZiAoIWR5KSB7XG4gICAgcmV0dXJuIFswLCBwb3MxWzFdXTtcbiAgfVxuXG4gIHZhciBhID0gZHkgLyBkeDsgLy8geSAtIHkxID0gYSAoeCAgLSB4MSlcbiAgLy8geSA9IGF4IC0gYSAqIHgxICsgeTFcblxuICB2YXIgYiA9IC1hICogcG9zMVswXSArIHBvczFbMV07IC8vIHkgPSBheCArIGIgPSAtMS9hIHhcbiAgLy8geCA9IC1iIC8gKGEgKyAxIC8gYSlcbiAgLy8geSA9IGIgLyAoMSArIDEgLyBhXjIpXG5cbiAgcmV0dXJuIFstYiAvIChhICsgMSAvIGEpLCBiIC8gKGEgKiBhICsgMSldO1xufVxuXG5mdW5jdGlvbiBjaGVja1JvdGF0ZUlubmVyQm91bmRzKG1vdmVhYmxlLCBwcmV2UG9zZXMsIG5leHRQb3Nlcywgb3JpZ2luLCByb3RhdGlvbikge1xuICB2YXIgYm91bmRzID0gbW92ZWFibGUucHJvcHMuaW5uZXJCb3VuZHM7XG4gIHZhciByYWQgPSByb3RhdGlvbiAqIE1hdGguUEkgLyAxODA7XG5cbiAgaWYgKCFib3VuZHMpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgbGVmdCA9IGJvdW5kcy5sZWZ0LFxuICAgICAgdG9wID0gYm91bmRzLnRvcCxcbiAgICAgIHdpZHRoID0gYm91bmRzLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gYm91bmRzLmhlaWdodDtcbiAgdmFyIHJlbGF0aXZlTGVmdCA9IGxlZnQgLSBvcmlnaW5bMF07XG4gIHZhciByZWxhdGl2ZVJpZ2h0ID0gbGVmdCArIHdpZHRoIC0gb3JpZ2luWzBdO1xuICB2YXIgcmVsYXRpdmVUb3AgPSB0b3AgLSBvcmlnaW5bMV07XG4gIHZhciByZWxhdGl2ZUJvdHRvbSA9IHRvcCArIGhlaWdodCAtIG9yaWdpblsxXTtcbiAgdmFyIGRvdHMgPSBbW3JlbGF0aXZlTGVmdCwgcmVsYXRpdmVUb3BdLCBbcmVsYXRpdmVSaWdodCwgcmVsYXRpdmVUb3BdLCBbcmVsYXRpdmVMZWZ0LCByZWxhdGl2ZUJvdHRvbV0sIFtyZWxhdGl2ZVJpZ2h0LCByZWxhdGl2ZUJvdHRvbV1dO1xuICB2YXIgY2VudGVyID0gZ2V0UG9zQnlEaXJlY3Rpb24obmV4dFBvc2VzLCBbMCwgMF0pO1xuXG4gIGlmICghaXNCb3VuZFJvdGF0ZShuZXh0UG9zZXMsIGRvdHMsIGNlbnRlciwgMCkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBkb3RJbmZvcyA9IGRvdHMubWFwKGZ1bmN0aW9uIChkb3QpIHtcbiAgICByZXR1cm4gW2dldERpc3RTaXplKGRvdCksIGdldFJhZChbMCwgMF0sIGRvdCldO1xuICB9KTtcbiAgW1tuZXh0UG9zZXNbMF0sIG5leHRQb3Nlc1sxXV0sIFtuZXh0UG9zZXNbMV0sIG5leHRQb3Nlc1szXV0sIFtuZXh0UG9zZXNbM10sIG5leHRQb3Nlc1syXV0sIFtuZXh0UG9zZXNbMl0sIG5leHRQb3Nlc1swXV1dLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICB2YXIgbGluZVJhZCA9IGdldFJhZChbMCwgMF0sIHNvbHZlUmV2ZXJzZUxpbmUobGluZSkpO1xuICAgIHZhciBsaW5lRGlzdCA9IGdldERpc3RQb2ludExpbmUobGluZSk7XG4gICAgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCBkb3RJbmZvcy5maWx0ZXIoZnVuY3Rpb24gKF9hKSB7XG4gICAgICB2YXIgZG90RGlzdCA9IF9hWzBdO1xuICAgICAgcmV0dXJuIGRvdERpc3QgJiYgbGluZURpc3QgPD0gZG90RGlzdDtcbiAgICB9KS5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICB2YXIgZG90RGlzdCA9IF9hWzBdLFxuICAgICAgICAgIGRvdFJhZCA9IF9hWzFdO1xuICAgICAgdmFyIGRpc3RSYWQgPSBNYXRoLmFjb3MoZG90RGlzdCA/IGxpbmVEaXN0IC8gZG90RGlzdCA6IDApO1xuICAgICAgdmFyIG5leHRSYWQxID0gZG90UmFkICsgZGlzdFJhZDtcbiAgICAgIHZhciBuZXh0UmFkMiA9IGRvdFJhZCAtIGRpc3RSYWQ7XG4gICAgICByZXR1cm4gW3JhZCArIG5leHRSYWQxIC0gbGluZVJhZCwgcmFkICsgbmV4dFJhZDIgLSBsaW5lUmFkXTtcbiAgICB9KS5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cikge1xuICAgICAgcHJldi5wdXNoLmFwcGx5KHByZXYsIGN1cik7XG4gICAgICByZXR1cm4gcHJldjtcbiAgICB9LCBbXSkuZmlsdGVyKGZ1bmN0aW9uIChuZXh0UmFkKSB7XG4gICAgICByZXR1cm4gIWlzQm91bmRSb3RhdGUocHJldlBvc2VzLCBkb3RzLCBjZW50ZXIsIG5leHRSYWQpO1xuICAgIH0pLm1hcChmdW5jdGlvbiAobmV4dFJhZCkge1xuICAgICAgcmV0dXJuIHRocm90dGxlKG5leHRSYWQgKiAxODAgLyBNYXRoLlBJLCBUSU5ZX05VTSk7XG4gICAgfSkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNoZWNrSW5uZXJCb3VuZFBvc2VzKG1vdmVhYmxlKSB7XG4gIHZhciBpbm5lckJvdW5kcyA9IG1vdmVhYmxlLnByb3BzLmlubmVyQm91bmRzO1xuXG4gIGlmICghaW5uZXJCb3VuZHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmVydGljYWw6IFtdLFxuICAgICAgaG9yaXpvbnRhbDogW11cbiAgICB9O1xuICB9XG5cbiAgdmFyIF9hID0gbW92ZWFibGUuZ2V0UmVjdCgpLFxuICAgICAgcG9zMSA9IF9hLnBvczEsXG4gICAgICBwb3MyID0gX2EucG9zMixcbiAgICAgIHBvczMgPSBfYS5wb3MzLFxuICAgICAgcG9zNCA9IF9hLnBvczQ7XG5cbiAgdmFyIHBvc2VzID0gW3BvczEsIHBvczIsIHBvczMsIHBvczRdO1xuICB2YXIgY2VudGVyID0gZ2V0UG9zQnlEaXJlY3Rpb24ocG9zZXMsIFswLCAwXSk7XG4gIHZhciBsZWZ0ID0gaW5uZXJCb3VuZHMubGVmdCxcbiAgICAgIHRvcCA9IGlubmVyQm91bmRzLnRvcCxcbiAgICAgIHdpZHRoID0gaW5uZXJCb3VuZHMud2lkdGgsXG4gICAgICBoZWlnaHQgPSBpbm5lckJvdW5kcy5oZWlnaHQ7XG4gIHZhciBsZWZ0TGluZSA9IFtbbGVmdCwgdG9wXSwgW2xlZnQsIHRvcCArIGhlaWdodF1dO1xuICB2YXIgdG9wTGluZSA9IFtbbGVmdCwgdG9wXSwgW2xlZnQgKyB3aWR0aCwgdG9wXV07XG4gIHZhciByaWdodExpbmUgPSBbW2xlZnQgKyB3aWR0aCwgdG9wXSwgW2xlZnQgKyB3aWR0aCwgdG9wICsgaGVpZ2h0XV07XG4gIHZhciBib3R0b21MaW5lID0gW1tsZWZ0LCB0b3AgKyBoZWlnaHRdLCBbbGVmdCArIHdpZHRoLCB0b3AgKyBoZWlnaHRdXTtcbiAgdmFyIGxpbmVzID0gW1twb3MxLCBwb3MyXSwgW3BvczIsIHBvczRdLCBbcG9zNCwgcG9zM10sIFtwb3MzLCBwb3MxXV07XG4gIHZhciBob3Jpem9udGFsUG9zZXMgPSBbXTtcbiAgdmFyIHZlcnRpY2FsUG9zZXMgPSBbXTtcbiAgdmFyIGJvdW5kTWFwID0ge1xuICAgIHRvcDogZmFsc2UsXG4gICAgYm90dG9tOiBmYWxzZSxcbiAgICBsZWZ0OiBmYWxzZSxcbiAgICByaWdodDogZmFsc2VcbiAgfTtcbiAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgIHZhciBfYSA9IGlzU3RhcnRMaW5lKGNlbnRlciwgbGluZSksXG4gICAgICAgIGlzSG9yaXpvbnRhbFN0YXJ0ID0gX2EuaG9yaXpvbnRhbCxcbiAgICAgICAgaXNWZXJ0aWNhbFN0YXJ0ID0gX2EudmVydGljYWw7IC8vIHRlc3QgdmVydGljYWxcblxuXG4gICAgdmFyIHRvcEJvdW5kSW5mbyA9IGNoZWNrTGluZUJvdW5kQ29sbGlzaW9uKGxpbmUsIHRvcExpbmUsIGlzVmVydGljYWxTdGFydCwgMSwgdHJ1ZSk7XG4gICAgdmFyIGJvdHRvbUJvdW5kSW5mbyA9IGNoZWNrTGluZUJvdW5kQ29sbGlzaW9uKGxpbmUsIGJvdHRvbUxpbmUsIGlzVmVydGljYWxTdGFydCwgMSwgdHJ1ZSk7IC8vIHRlc3QgaG9yaXpvbnRhbFxuXG4gICAgdmFyIGxlZnRCb3VuZEluZm8gPSBjaGVja0xpbmVCb3VuZENvbGxpc2lvbihsaW5lLCBsZWZ0TGluZSwgaXNIb3Jpem9udGFsU3RhcnQsIDEsIHRydWUpO1xuICAgIHZhciByaWdodEJvdW5kSW5mbyA9IGNoZWNrTGluZUJvdW5kQ29sbGlzaW9uKGxpbmUsIHJpZ2h0TGluZSwgaXNIb3Jpem9udGFsU3RhcnQsIDEsIHRydWUpO1xuXG4gICAgaWYgKHRvcEJvdW5kSW5mby5pc0JvdW5kICYmICFib3VuZE1hcC50b3ApIHtcbiAgICAgIGhvcml6b250YWxQb3Nlcy5wdXNoKHRvcCk7XG4gICAgICBib3VuZE1hcC50b3AgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChib3R0b21Cb3VuZEluZm8uaXNCb3VuZCAmJiAhYm91bmRNYXAuYm90dG9tKSB7XG4gICAgICBob3Jpem9udGFsUG9zZXMucHVzaCh0b3AgKyBoZWlnaHQpO1xuICAgICAgYm91bmRNYXAuYm90dG9tID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobGVmdEJvdW5kSW5mby5pc0JvdW5kICYmICFib3VuZE1hcC5sZWZ0KSB7XG4gICAgICB2ZXJ0aWNhbFBvc2VzLnB1c2gobGVmdCk7XG4gICAgICBib3VuZE1hcC5sZWZ0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAocmlnaHRCb3VuZEluZm8uaXNCb3VuZCAmJiAhYm91bmRNYXAucmlnaHQpIHtcbiAgICAgIHZlcnRpY2FsUG9zZXMucHVzaChsZWZ0ICsgd2lkdGgpO1xuICAgICAgYm91bmRNYXAucmlnaHQgPSB0cnVlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgaG9yaXpvbnRhbDogaG9yaXpvbnRhbFBvc2VzLFxuICAgIHZlcnRpY2FsOiB2ZXJ0aWNhbFBvc2VzXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNoZWNrQm91bmRQb3Nlcyhib3VuZHMsIHZlcnRpY2FsUG9zZXMsIGhvcml6b250YWxQb3Nlcykge1xuICB2YXIgX2EgPSBib3VuZHMgfHwge30sXG4gICAgICBfYiA9IF9hLnBvc2l0aW9uLFxuICAgICAgcG9zaXRpb24gPSBfYiA9PT0gdm9pZCAwID8gXCJjbGllbnRcIiA6IF9iLFxuICAgICAgX2MgPSBfYS5sZWZ0LFxuICAgICAgbGVmdCA9IF9jID09PSB2b2lkIDAgPyAtSW5maW5pdHkgOiBfYyxcbiAgICAgIF9kID0gX2EudG9wLFxuICAgICAgdG9wID0gX2QgPT09IHZvaWQgMCA/IC1JbmZpbml0eSA6IF9kLFxuICAgICAgX2UgPSBfYS5yaWdodCxcbiAgICAgIHJpZ2h0ID0gX2UgPT09IHZvaWQgMCA/IEluZmluaXR5IDogX2UsXG4gICAgICBfZiA9IF9hLmJvdHRvbSxcbiAgICAgIGJvdHRvbSA9IF9mID09PSB2b2lkIDAgPyBJbmZpbml0eSA6IF9mO1xuXG4gIHZhciBuZXh0Qm91bmRzID0ge1xuICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICBsZWZ0OiBsZWZ0LFxuICAgIHRvcDogdG9wLFxuICAgIHJpZ2h0OiByaWdodCxcbiAgICBib3R0b206IGJvdHRvbVxuICB9O1xuICByZXR1cm4ge1xuICAgIHZlcnRpY2FsOiBjaGVja0JvdW5kcyhuZXh0Qm91bmRzLCB2ZXJ0aWNhbFBvc2VzLCB0cnVlKSxcbiAgICBob3Jpem9udGFsOiBjaGVja0JvdW5kcyhuZXh0Qm91bmRzLCBob3Jpem9udGFsUG9zZXMsIGZhbHNlKVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0Qm91bmRzKG1vdmVhYmxlLCBleHRlcm5hbEJvdW5kcykge1xuICB2YXIgX2EgPSBtb3ZlYWJsZS5zdGF0ZSxcbiAgICAgIF9iID0gX2EuY29udGFpbmVyQ2xpZW50UmVjdCxcbiAgICAgIGNvbnRhaW5lckhlaWdodCA9IF9iLmNsaWVudEhlaWdodCxcbiAgICAgIGNvbnRhaW5lcldpZHRoID0gX2IuY2xpZW50V2lkdGgsXG4gICAgICBjbGllbnRMZWZ0ID0gX2IuY2xpZW50TGVmdCxcbiAgICAgIGNsaWVudFRvcCA9IF9iLmNsaWVudFRvcCxcbiAgICAgIF9jID0gX2Euc25hcE9mZnNldCxcbiAgICAgIHNuYXBPZmZzZXRMZWZ0ID0gX2MubGVmdCxcbiAgICAgIHNuYXBPZmZzZXRUb3AgPSBfYy50b3AsXG4gICAgICBzbmFwT2Zmc2V0UmlnaHQgPSBfYy5yaWdodCxcbiAgICAgIHNuYXBPZmZzZXRCb3R0b20gPSBfYy5ib3R0b207XG4gIHZhciBib3VuZHMgPSBleHRlcm5hbEJvdW5kcyB8fCBtb3ZlYWJsZS5wcm9wcy5ib3VuZHMgfHwge307XG4gIHZhciBwb3NpdGlvbiA9IGJvdW5kcy5wb3NpdGlvbiB8fCBcImNsaWVudFwiO1xuICB2YXIgaXNDU1MgPSBwb3NpdGlvbiA9PT0gXCJjc3NcIjtcbiAgdmFyIF9kID0gYm91bmRzLmxlZnQsXG4gICAgICBsZWZ0ID0gX2QgPT09IHZvaWQgMCA/IC1JbmZpbml0eSA6IF9kLFxuICAgICAgX2UgPSBib3VuZHMudG9wLFxuICAgICAgdG9wID0gX2UgPT09IHZvaWQgMCA/IC1JbmZpbml0eSA6IF9lO1xuICB2YXIgX2YgPSBib3VuZHMucmlnaHQsXG4gICAgICByaWdodCA9IF9mID09PSB2b2lkIDAgPyBpc0NTUyA/IC1JbmZpbml0eSA6IEluZmluaXR5IDogX2YsXG4gICAgICBfZyA9IGJvdW5kcy5ib3R0b20sXG4gICAgICBib3R0b20gPSBfZyA9PT0gdm9pZCAwID8gaXNDU1MgPyAtSW5maW5pdHkgOiBJbmZpbml0eSA6IF9nO1xuXG4gIGlmIChpc0NTUykge1xuICAgIHJpZ2h0ID0gY29udGFpbmVyV2lkdGggKyBzbmFwT2Zmc2V0UmlnaHQgLSBzbmFwT2Zmc2V0TGVmdCAtIHJpZ2h0O1xuICAgIGJvdHRvbSA9IGNvbnRhaW5lckhlaWdodCArIHNuYXBPZmZzZXRCb3R0b20gLSBzbmFwT2Zmc2V0VG9wIC0gYm90dG9tO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiBsZWZ0ICsgc25hcE9mZnNldExlZnQgLSBjbGllbnRMZWZ0LFxuICAgIHJpZ2h0OiByaWdodCArIHNuYXBPZmZzZXRMZWZ0IC0gY2xpZW50TGVmdCxcbiAgICB0b3A6IHRvcCArIHNuYXBPZmZzZXRUb3AgLSBjbGllbnRUb3AsXG4gICAgYm90dG9tOiBib3R0b20gKyBzbmFwT2Zmc2V0VG9wIC0gY2xpZW50VG9wXG4gIH07XG59XG5mdW5jdGlvbiBjaGVja0JvdW5kS2VlcFJhdGlvKG1vdmVhYmxlLCBzdGFydFBvcywgZW5kUG9zKSB7XG4gIHZhciBfYSA9IGdldEJvdW5kcyhtb3ZlYWJsZSksXG4gICAgICBsZWZ0ID0gX2EubGVmdCxcbiAgICAgIHRvcCA9IF9hLnRvcCxcbiAgICAgIHJpZ2h0ID0gX2EucmlnaHQsXG4gICAgICBib3R0b20gPSBfYS5ib3R0b207XG5cbiAgdmFyIGVuZFggPSBlbmRQb3NbMF0sXG4gICAgICBlbmRZID0gZW5kUG9zWzFdO1xuXG4gIHZhciBfYiA9IG1pbnVzKGVuZFBvcywgc3RhcnRQb3MpLFxuICAgICAgZHggPSBfYlswXSxcbiAgICAgIGR5ID0gX2JbMV07XG5cbiAgaWYgKE1hdGguYWJzKGR4KSA8IFRJTllfTlVNKSB7XG4gICAgZHggPSAwO1xuICB9XG5cbiAgaWYgKE1hdGguYWJzKGR5KSA8IFRJTllfTlVNKSB7XG4gICAgZHkgPSAwO1xuICB9XG5cbiAgdmFyIGlzQm90dG9tID0gZHkgPiAwO1xuICB2YXIgaXNSaWdodCA9IGR4ID4gMDtcbiAgdmFyIHZlcnRpY2FsSW5mbyA9IHtcbiAgICBpc0JvdW5kOiBmYWxzZSxcbiAgICBvZmZzZXQ6IDAsXG4gICAgcG9zOiAwXG4gIH07XG4gIHZhciBob3Jpem9udGFsSW5mbyA9IHtcbiAgICBpc0JvdW5kOiBmYWxzZSxcbiAgICBvZmZzZXQ6IDAsXG4gICAgcG9zOiAwXG4gIH07XG5cbiAgaWYgKGR4ID09PSAwICYmIGR5ID09PSAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZlcnRpY2FsOiB2ZXJ0aWNhbEluZm8sXG4gICAgICBob3Jpem9udGFsOiBob3Jpem9udGFsSW5mb1xuICAgIH07XG4gIH0gZWxzZSBpZiAoZHggPT09IDApIHtcbiAgICBpZiAoaXNCb3R0b20pIHtcbiAgICAgIGlmIChib3R0b20gPCBlbmRZKSB7XG4gICAgICAgIGhvcml6b250YWxJbmZvLnBvcyA9IGJvdHRvbTtcbiAgICAgICAgaG9yaXpvbnRhbEluZm8ub2Zmc2V0ID0gZW5kWSAtIGJvdHRvbTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRvcCA+IGVuZFkpIHtcbiAgICAgICAgaG9yaXpvbnRhbEluZm8ucG9zID0gdG9wO1xuICAgICAgICBob3Jpem9udGFsSW5mby5vZmZzZXQgPSBlbmRZIC0gdG9wO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChkeSA9PT0gMCkge1xuICAgIGlmIChpc1JpZ2h0KSB7XG4gICAgICBpZiAocmlnaHQgPCBlbmRYKSB7XG4gICAgICAgIHZlcnRpY2FsSW5mby5wb3MgPSByaWdodDtcbiAgICAgICAgdmVydGljYWxJbmZvLm9mZnNldCA9IGVuZFggLSByaWdodDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGxlZnQgPiBlbmRYKSB7XG4gICAgICAgIHZlcnRpY2FsSW5mby5wb3MgPSBsZWZ0O1xuICAgICAgICB2ZXJ0aWNhbEluZm8ub2Zmc2V0ID0gZW5kWCAtIGxlZnQ7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIHkgLSB5MSA9IGEgKiAoeCAtIHgxKVxuICAgIHZhciBhID0gZHkgLyBkeDtcbiAgICB2YXIgYiA9IGVuZFBvc1sxXSAtIGEgKiBlbmRYO1xuICAgIHZhciB5ID0gMDtcbiAgICB2YXIgeCA9IDA7XG4gICAgdmFyIGlzQm91bmQgPSBmYWxzZTtcblxuICAgIGlmIChpc1JpZ2h0ICYmIHJpZ2h0IDw9IGVuZFgpIHtcbiAgICAgIHkgPSBhICogcmlnaHQgKyBiO1xuICAgICAgeCA9IHJpZ2h0O1xuICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICghaXNSaWdodCAmJiBlbmRYIDw9IGxlZnQpIHtcbiAgICAgIHkgPSBhICogbGVmdCArIGI7XG4gICAgICB4ID0gbGVmdDtcbiAgICAgIGlzQm91bmQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpc0JvdW5kKSB7XG4gICAgICBpZiAoeSA8IHRvcCB8fCB5ID4gYm90dG9tKSB7XG4gICAgICAgIGlzQm91bmQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWlzQm91bmQpIHtcbiAgICAgIGlmIChpc0JvdHRvbSAmJiBib3R0b20gPD0gZW5kWSkge1xuICAgICAgICB5ID0gYm90dG9tO1xuICAgICAgICB4ID0gKHkgLSBiKSAvIGE7XG4gICAgICAgIGlzQm91bmQgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICghaXNCb3R0b20gJiYgZW5kWSA8PSB0b3ApIHtcbiAgICAgICAgeSA9IHRvcDtcbiAgICAgICAgeCA9ICh5IC0gYikgLyBhO1xuICAgICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNCb3VuZCkge1xuICAgICAgdmVydGljYWxJbmZvLmlzQm91bmQgPSB0cnVlO1xuICAgICAgdmVydGljYWxJbmZvLnBvcyA9IHg7XG4gICAgICB2ZXJ0aWNhbEluZm8ub2Zmc2V0ID0gZW5kWCAtIHg7XG4gICAgICBob3Jpem9udGFsSW5mby5pc0JvdW5kID0gdHJ1ZTtcbiAgICAgIGhvcml6b250YWxJbmZvLnBvcyA9IHk7XG4gICAgICBob3Jpem9udGFsSW5mby5vZmZzZXQgPSBlbmRZIC0geTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHZlcnRpY2FsOiB2ZXJ0aWNhbEluZm8sXG4gICAgaG9yaXpvbnRhbDogaG9yaXpvbnRhbEluZm9cbiAgfTtcbn1cblxuZnVuY3Rpb24gY2hlY2tCb3VuZHMoYm91bmRzLCBwb3NlcywgaXNWZXJ0aWNhbCkge1xuICAvLyAwICAgWzEwMCAtIDIwMF0gIDMwMFxuICB2YXIgc3RhcnRCb3VuZFBvcyA9IGJvdW5kc1tpc1ZlcnRpY2FsID8gXCJsZWZ0XCIgOiBcInRvcFwiXTtcbiAgdmFyIGVuZEJvdW5kUG9zID0gYm91bmRzW2lzVmVydGljYWwgPyBcInJpZ2h0XCIgOiBcImJvdHRvbVwiXTsgLy8gNDUwXG5cbiAgdmFyIG1pblBvcyA9IE1hdGgubWluLmFwcGx5KE1hdGgsIHBvc2VzKTtcbiAgdmFyIG1heFBvcyA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHBvc2VzKTtcbiAgdmFyIGJvdW5kSW5mb3MgPSBbXTtcblxuICBpZiAoc3RhcnRCb3VuZFBvcyArIDEgPiBtaW5Qb3MpIHtcbiAgICBib3VuZEluZm9zLnB1c2goe1xuICAgICAgaXNCb3VuZDogdHJ1ZSxcbiAgICAgIG9mZnNldDogbWluUG9zIC0gc3RhcnRCb3VuZFBvcyxcbiAgICAgIHBvczogc3RhcnRCb3VuZFBvc1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKGVuZEJvdW5kUG9zIC0gMSA8IG1heFBvcykge1xuICAgIGJvdW5kSW5mb3MucHVzaCh7XG4gICAgICBpc0JvdW5kOiB0cnVlLFxuICAgICAgb2Zmc2V0OiBtYXhQb3MgLSBlbmRCb3VuZFBvcyxcbiAgICAgIHBvczogZW5kQm91bmRQb3NcbiAgICB9KTtcbiAgfVxuXG4gIGlmICghYm91bmRJbmZvcy5sZW5ndGgpIHtcbiAgICBib3VuZEluZm9zLnB1c2goe1xuICAgICAgaXNCb3VuZDogZmFsc2UsXG4gICAgICBvZmZzZXQ6IDAsXG4gICAgICBwb3M6IDBcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBib3VuZEluZm9zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gTWF0aC5hYnMoYi5vZmZzZXQpIC0gTWF0aC5hYnMoYS5vZmZzZXQpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaXNCb3VuZFJvdGF0ZSQxKHJlbGF0aXZlUG9zZXMsIGJvdW5kUmVjdCwgcmFkKSB7XG4gIHZhciBuZXh0UG9zZXMgPSByYWQgPyByZWxhdGl2ZVBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgcmV0dXJuIHJvdGF0ZShwb3MsIHJhZCk7XG4gIH0pIDogcmVsYXRpdmVQb3NlcztcbiAgcmV0dXJuIG5leHRQb3Nlcy5zb21lKGZ1bmN0aW9uIChwb3MpIHtcbiAgICByZXR1cm4gcG9zWzBdIDwgYm91bmRSZWN0LmxlZnQgJiYgTWF0aC5hYnMocG9zWzBdIC0gYm91bmRSZWN0LmxlZnQpID4gMC4xIHx8IHBvc1swXSA+IGJvdW5kUmVjdC5yaWdodCAmJiBNYXRoLmFicyhwb3NbMF0gLSBib3VuZFJlY3QucmlnaHQpID4gMC4xIHx8IHBvc1sxXSA8IGJvdW5kUmVjdC50b3AgJiYgTWF0aC5hYnMocG9zWzFdIC0gYm91bmRSZWN0LnRvcCkgPiAwLjEgfHwgcG9zWzFdID4gYm91bmRSZWN0LmJvdHRvbSAmJiBNYXRoLmFicyhwb3NbMV0gLSBib3VuZFJlY3QuYm90dG9tKSA+IDAuMTtcbiAgfSk7XG59XG5mdW5jdGlvbiBib3VuZFJvdGF0ZSh2ZWMsIGJvdW5kUG9zLCBpbmRleCkge1xuICB2YXIgciA9IGdldERpc3RTaXplKHZlYyk7XG4gIHZhciBuZXh0UG9zID0gTWF0aC5zcXJ0KHIgKiByIC0gYm91bmRQb3MgKiBib3VuZFBvcykgfHwgMDtcbiAgcmV0dXJuIFtuZXh0UG9zLCAtbmV4dFBvc10uc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBNYXRoLmFicyhhIC0gdmVjW2luZGV4ID8gMCA6IDFdKSAtIE1hdGguYWJzKGIgLSB2ZWNbaW5kZXggPyAwIDogMV0pO1xuICB9KS5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgIHJldHVybiBnZXRSYWQoWzAsIDBdLCBpbmRleCA/IFtwb3MsIGJvdW5kUG9zXSA6IFtib3VuZFBvcywgcG9zXSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gY2hlY2tSb3RhdGVCb3VuZHMobW92ZWFibGUsIHByZXZQb3NlcywgbmV4dFBvc2VzLCBvcmlnaW4sIHJvdGF0aW9uKSB7XG4gIGlmICghbW92ZWFibGUucHJvcHMuYm91bmRzKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIHJhZCA9IHJvdGF0aW9uICogTWF0aC5QSSAvIDE4MDtcblxuICB2YXIgX2EgPSBnZXRCb3VuZHMobW92ZWFibGUpLFxuICAgICAgbGVmdCA9IF9hLmxlZnQsXG4gICAgICB0b3AgPSBfYS50b3AsXG4gICAgICByaWdodCA9IF9hLnJpZ2h0LFxuICAgICAgYm90dG9tID0gX2EuYm90dG9tO1xuXG4gIHZhciByZWxhdGl2ZUxlZnQgPSBsZWZ0IC0gb3JpZ2luWzBdO1xuICB2YXIgcmVsYXRpdmVSaWdodCA9IHJpZ2h0IC0gb3JpZ2luWzBdO1xuICB2YXIgcmVsYXRpdmVUb3AgPSB0b3AgLSBvcmlnaW5bMV07XG4gIHZhciByZWxhdGl2ZUJvdHRvbSA9IGJvdHRvbSAtIG9yaWdpblsxXTtcbiAgdmFyIGJvdW5kUmVjdCA9IHtcbiAgICBsZWZ0OiByZWxhdGl2ZUxlZnQsXG4gICAgdG9wOiByZWxhdGl2ZVRvcCxcbiAgICByaWdodDogcmVsYXRpdmVSaWdodCxcbiAgICBib3R0b206IHJlbGF0aXZlQm90dG9tXG4gIH07XG5cbiAgaWYgKCFpc0JvdW5kUm90YXRlJDEobmV4dFBvc2VzLCBib3VuZFJlY3QsIDApKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBbW3JlbGF0aXZlTGVmdCwgMF0sIFtyZWxhdGl2ZVJpZ2h0LCAwXSwgW3JlbGF0aXZlVG9wLCAxXSwgW3JlbGF0aXZlQm90dG9tLCAxXV0uZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgYm91bmRQb3MgPSBfYVswXSxcbiAgICAgICAgaW5kZXggPSBfYVsxXTtcbiAgICBuZXh0UG9zZXMuZm9yRWFjaChmdW5jdGlvbiAobmV4dFBvcykge1xuICAgICAgdmFyIHJlbGF0aXZlUmFkMSA9IGdldFJhZChbMCwgMF0sIG5leHRQb3MpO1xuICAgICAgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCBib3VuZFJvdGF0ZShuZXh0UG9zLCBib3VuZFBvcywgaW5kZXgpLm1hcChmdW5jdGlvbiAocmVsYXRpdmVSYWQyKSB7XG4gICAgICAgIHJldHVybiByYWQgKyByZWxhdGl2ZVJhZDIgLSByZWxhdGl2ZVJhZDE7XG4gICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKG5leHRSYWQpIHtcbiAgICAgICAgcmV0dXJuICFpc0JvdW5kUm90YXRlJDEocHJldlBvc2VzLCBib3VuZFJlY3QsIG5leHRSYWQpO1xuICAgICAgfSkubWFwKGZ1bmN0aW9uIChuZXh0UmFkKSB7XG4gICAgICAgIHJldHVybiB0aHJvdHRsZShuZXh0UmFkICogMTgwIC8gTWF0aC5QSSwgVElOWV9OVU0pO1xuICAgICAgfSkpO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcmVuZGVyR3VpZGVsaW5lKGluZm8sIFJlYWN0KSB7XG4gIHZhciBfYTtcblxuICB2YXIgZGlyZWN0aW9uID0gaW5mby5kaXJlY3Rpb24sXG4gICAgICBjbGFzc05hbWVzID0gaW5mby5jbGFzc05hbWVzLFxuICAgICAgc2l6ZSA9IGluZm8uc2l6ZSxcbiAgICAgIHBvcyA9IGluZm8ucG9zLFxuICAgICAgem9vbSA9IGluZm8uem9vbSxcbiAgICAgIGtleSA9IGluZm8ua2V5O1xuICB2YXIgaXNIb3Jpem9udGFsID0gZGlyZWN0aW9uID09PSBcImhvcml6b250YWxcIjtcbiAgdmFyIHNjYWxlVHlwZSA9IGlzSG9yaXpvbnRhbCA/IFwiWVwiIDogXCJYXCI7IC8vIGNvbnN0IHNjYWxlVHlwZTIgPSBpc0hvcml6b250YWwgPyBcIllcIiA6IFwiWFwiO1xuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBrZXk6IGtleSxcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZXMuam9pbihcIiBcIiksXG4gICAgc3R5bGU6IChfYSA9IHt9LCBfYVtpc0hvcml6b250YWwgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiXSA9IFwiXCIgKyBzaXplLCBfYS50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIHBvc1swXSArIFwiLCBcIiArIHBvc1sxXSArIFwiKSB0cmFuc2xhdGVcIiArIHNjYWxlVHlwZSArIFwiKC01MCUpIHNjYWxlXCIgKyBzY2FsZVR5cGUgKyBcIihcIiArIHpvb20gKyBcIilcIiwgX2EpXG4gIH0pO1xufVxuZnVuY3Rpb24gcmVuZGVySW5uZXJHdWlkZWxpbmUoaW5mbywgUmVhY3QpIHtcbiAgcmV0dXJuIHJlbmRlckd1aWRlbGluZShfX2Fzc2lnbihfX2Fzc2lnbih7fSwgaW5mbyksIHtcbiAgICBjbGFzc05hbWVzOiBfX3NwcmVhZEFycmF5KFtwcmVmaXgoXCJsaW5lXCIsIFwiZ3VpZGVsaW5lXCIsIGluZm8uZGlyZWN0aW9uKV0sIGluZm8uY2xhc3NOYW1lcykuZmlsdGVyKGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICAgIHJldHVybiBjbGFzc05hbWU7XG4gICAgfSksXG4gICAgc2l6ZTogaW5mby5zaXplIHx8IGluZm8uc2l6ZVZhbHVlICsgXCJweFwiLFxuICAgIHBvczogaW5mby5wb3MgfHwgaW5mby5wb3NWYWx1ZS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiB0aHJvdHRsZSh2LCAwLjEpICsgXCJweFwiO1xuICAgIH0pXG4gIH0pLCBSZWFjdCk7XG59XG5mdW5jdGlvbiByZW5kZXJTbmFwUG9zZXMobW92ZWFibGUsIGRpcmVjdGlvbiwgc25hcFBvc2VzLCBtaW5Qb3MsIHRhcmdldFBvcywgc2l6ZSwgaW5kZXgsIFJlYWN0KSB7XG4gIHZhciB6b29tID0gbW92ZWFibGUucHJvcHMuem9vbTtcbiAgcmV0dXJuIHNuYXBQb3Nlcy5tYXAoZnVuY3Rpb24gKF9hLCBpKSB7XG4gICAgdmFyIHR5cGUgPSBfYS50eXBlLFxuICAgICAgICBwb3MgPSBfYS5wb3M7XG4gICAgdmFyIHJlbmRlclBvcyA9IFswLCAwXTtcbiAgICByZW5kZXJQb3NbaW5kZXhdID0gbWluUG9zO1xuICAgIHJlbmRlclBvc1tpbmRleCA/IDAgOiAxXSA9IC10YXJnZXRQb3MgKyBwb3M7XG4gICAgcmV0dXJuIHJlbmRlcklubmVyR3VpZGVsaW5lKHtcbiAgICAgIGtleTogZGlyZWN0aW9uICsgXCJUYXJnZXRHdWlkZWxpbmVcIiArIGksXG4gICAgICBjbGFzc05hbWVzOiBbcHJlZml4KFwidGFyZ2V0XCIsIFwiYm9sZFwiLCB0eXBlKV0sXG4gICAgICBwb3NWYWx1ZTogcmVuZGVyUG9zLFxuICAgICAgc2l6ZVZhbHVlOiBzaXplLFxuICAgICAgem9vbTogem9vbSxcbiAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uXG4gICAgfSwgUmVhY3QpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHJlbmRlckd1aWRlbGluZXMobW92ZWFibGUsIHR5cGUsIGd1aWRlbGluZXMsIHRhcmdldFBvcywgdGFyZ2V0UmVjdCwgUmVhY3QpIHtcbiAgdmFyIF9hID0gbW92ZWFibGUucHJvcHMsXG4gICAgICB6b29tID0gX2Euem9vbSxcbiAgICAgIGlzRGlzcGxheUlubmVyU25hcERpZ2l0ID0gX2EuaXNEaXNwbGF5SW5uZXJTbmFwRGlnaXQ7XG4gIHZhciBtYWluTmFtZXMgPSB0eXBlID09PSBcImhvcml6b250YWxcIiA/IFZFUlRJQ0FMX05BTUVTX01BUCA6IEhPUklaT05UQUxfTkFNRVNfTUFQO1xuICB2YXIgdGFyZ2V0U3RhcnQgPSB0YXJnZXRSZWN0W21haW5OYW1lcy5zdGFydF07XG4gIHZhciB0YXJnZXRFbmQgPSB0YXJnZXRSZWN0W21haW5OYW1lcy5lbmRdO1xuICByZXR1cm4gZ3VpZGVsaW5lcy5maWx0ZXIoZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGhpZGUgPSBfYS5oaWRlLFxuICAgICAgICBlbGVtZW50UmVjdCA9IF9hLmVsZW1lbnRSZWN0O1xuXG4gICAgaWYgKGhpZGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoaXNEaXNwbGF5SW5uZXJTbmFwRGlnaXQgJiYgZWxlbWVudFJlY3QpIHtcbiAgICAgIC8vIGlubmVyXG4gICAgICB2YXIgcmVjdCA9IGVsZW1lbnRSZWN0LnJlY3Q7XG5cbiAgICAgIGlmIChyZWN0W21haW5OYW1lcy5zdGFydF0gPD0gdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0RW5kIDw9IHJlY3RbbWFpbk5hbWVzLmVuZF0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9KS5tYXAoZnVuY3Rpb24gKGd1aWRlbGluZSwgaSkge1xuICAgIHZhciBwb3MgPSBndWlkZWxpbmUucG9zLFxuICAgICAgICBzaXplID0gZ3VpZGVsaW5lLnNpemUsXG4gICAgICAgIGVsZW1lbnQgPSBndWlkZWxpbmUuZWxlbWVudDtcbiAgICB2YXIgcmVuZGVyUG9zID0gWy10YXJnZXRQb3NbMF0gKyBwb3NbMF0sIC10YXJnZXRQb3NbMV0gKyBwb3NbMV1dO1xuICAgIHJldHVybiByZW5kZXJJbm5lckd1aWRlbGluZSh7XG4gICAgICBrZXk6IHR5cGUgKyBcIi1kZWZhdWx0LWd1aWRlbGluZS1cIiArIGksXG4gICAgICBjbGFzc05hbWVzOiBlbGVtZW50ID8gW3ByZWZpeChcImJvbGRcIildIDogW10sXG4gICAgICBkaXJlY3Rpb246IHR5cGUsXG4gICAgICBwb3NWYWx1ZTogcmVuZGVyUG9zLFxuICAgICAgc2l6ZVZhbHVlOiBzaXplLFxuICAgICAgem9vbTogem9vbVxuICAgIH0sIFJlYWN0KTtcbiAgfSk7XG59XG5mdW5jdGlvbiByZW5kZXJEaWdpdExpbmUobW92ZWFibGUsIHR5cGUsIGxpbmVUeXBlLCBpbmRleCwgZ2FwLCByZW5kZXJQb3MsIGNsYXNzTmFtZSwgUmVhY3QpIHtcbiAgdmFyIF9hO1xuXG4gIHZhciBfYiA9IG1vdmVhYmxlLnByb3BzLFxuICAgICAgX2MgPSBfYi5zbmFwRGlnaXQsXG4gICAgICBzbmFwRGlnaXQgPSBfYyA9PT0gdm9pZCAwID8gMCA6IF9jLFxuICAgICAgX2QgPSBfYi5pc0Rpc3BsYXlTbmFwRGlnaXQsXG4gICAgICBpc0Rpc3BsYXlTbmFwRGlnaXQgPSBfZCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9kLFxuICAgICAgX2UgPSBfYi5zbmFwRGlzdEZvcm1hdCxcbiAgICAgIHNuYXBEaXN0Rm9ybWF0ID0gX2UgPT09IHZvaWQgMCA/IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIHY7XG4gIH0gOiBfZSxcbiAgICAgIHpvb20gPSBfYi56b29tO1xuICB2YXIgc2NhbGVUeXBlID0gdHlwZSA9PT0gXCJob3Jpem9udGFsXCIgPyBcIlhcIiA6IFwiWVwiO1xuICB2YXIgc2l6ZU5hbWUgPSB0eXBlID09PSBcInZlcnRpY2FsXCIgPyBcImhlaWdodFwiIDogXCJ3aWR0aFwiO1xuICB2YXIgYWJzR2FwID0gTWF0aC5hYnMoZ2FwKTtcbiAgdmFyIHNuYXBTaXplID0gaXNEaXNwbGF5U25hcERpZ2l0ID8gcGFyc2VGbG9hdChhYnNHYXAudG9GaXhlZChzbmFwRGlnaXQpKSA6IDA7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBrZXk6IHR5cGUgKyBcIi1cIiArIGxpbmVUeXBlICsgXCItZ3VpZGVsaW5lLVwiICsgaW5kZXgsXG4gICAgY2xhc3NOYW1lOiBwcmVmaXgoXCJndWlkZWxpbmUtZ3JvdXBcIiwgdHlwZSksXG4gICAgc3R5bGU6IChfYSA9IHtcbiAgICAgIGxlZnQ6IHJlbmRlclBvc1swXSArIFwicHhcIixcbiAgICAgIHRvcDogcmVuZGVyUG9zWzFdICsgXCJweFwiXG4gICAgfSwgX2Fbc2l6ZU5hbWVdID0gYWJzR2FwICsgXCJweFwiLCBfYSlcbiAgfSwgcmVuZGVySW5uZXJHdWlkZWxpbmUoe1xuICAgIGRpcmVjdGlvbjogdHlwZSxcbiAgICBjbGFzc05hbWVzOiBbcHJlZml4KGxpbmVUeXBlKSwgY2xhc3NOYW1lXSxcbiAgICBzaXplOiBcIjEwMCVcIixcbiAgICBwb3NWYWx1ZTogWzAsIDBdLFxuICAgIHNpemVWYWx1ZTogYWJzR2FwLFxuICAgIHpvb206IHpvb21cbiAgfSwgUmVhY3QpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IHByZWZpeChcInNpemUtdmFsdWVcIiwgXCJnYXBcIiksXG4gICAgc3R5bGU6IHtcbiAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGVcIiArIHNjYWxlVHlwZSArIFwiKC01MCUpIHNjYWxlKFwiICsgem9vbSArIFwiKVwiXG4gICAgfVxuICB9LCBzbmFwU2l6ZSA+IDAgPyBzbmFwRGlzdEZvcm1hdChzbmFwU2l6ZSkgOiBcIlwiKSk7XG59XG5mdW5jdGlvbiBncm91cEJ5RWxlbWVudEd1aWRlbGluZXModHlwZSwgZ3VpZGVsaW5lcywgdGFyZ2V0UmVjdCwgaXNEaXNwbGF5SW5uZXJTbmFwRGlnaXQpIHtcbiAgdmFyIGluZGV4ID0gdHlwZSA9PT0gXCJ2ZXJ0aWNhbFwiID8gMCA6IDE7XG4gIHZhciBvdGhlckluZGV4ID0gdHlwZSA9PT0gXCJ2ZXJ0aWNhbFwiID8gMSA6IDA7XG4gIHZhciBuYW1lcyA9IGluZGV4ID8gVkVSVElDQUxfTkFNRVNfTUFQIDogSE9SSVpPTlRBTF9OQU1FU19NQVA7XG4gIHZhciB0YXJnZXRTdGFydCA9IHRhcmdldFJlY3RbbmFtZXMuc3RhcnRdO1xuICB2YXIgdGFyZ2V0RW5kID0gdGFyZ2V0UmVjdFtuYW1lcy5lbmRdO1xuICByZXR1cm4gZ3JvdXBCeShndWlkZWxpbmVzLCBmdW5jdGlvbiAoZ3VpZGVsaW5lKSB7XG4gICAgcmV0dXJuIGd1aWRlbGluZS5wb3NbaW5kZXhdO1xuICB9KS5tYXAoZnVuY3Rpb24gKG5leHRHdWlkZWxpbmVzKSB7XG4gICAgdmFyIHN0YXJ0ID0gW107XG4gICAgdmFyIGVuZCA9IFtdO1xuICAgIHZhciBpbm5lciA9IFtdO1xuICAgIG5leHRHdWlkZWxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGd1aWRlbGluZSkge1xuICAgICAgdmFyIF9hLCBfYjtcblxuICAgICAgdmFyIGVsZW1lbnQgPSBndWlkZWxpbmUuZWxlbWVudDtcbiAgICAgIHZhciByZWN0ID0gZ3VpZGVsaW5lLmVsZW1lbnRSZWN0LnJlY3Q7XG5cbiAgICAgIGlmIChyZWN0W25hbWVzLmVuZF0gPCB0YXJnZXRTdGFydCkge1xuICAgICAgICBzdGFydC5wdXNoKGd1aWRlbGluZSk7XG4gICAgICB9IGVsc2UgaWYgKHRhcmdldEVuZCA8IHJlY3RbbmFtZXMuc3RhcnRdKSB7XG4gICAgICAgIGVuZC5wdXNoKGd1aWRlbGluZSk7XG4gICAgICB9IGVsc2UgaWYgKHJlY3RbbmFtZXMuc3RhcnRdIDw9IHRhcmdldFN0YXJ0ICYmIHRhcmdldEVuZCA8PSByZWN0W25hbWVzLmVuZF0gJiYgaXNEaXNwbGF5SW5uZXJTbmFwRGlnaXQpIHtcbiAgICAgICAgdmFyIHBvcyA9IGd1aWRlbGluZS5wb3M7XG4gICAgICAgIHZhciBlbGVtZW50UmVjdDEgPSB7XG4gICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICByZWN0OiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcmVjdCksIChfYSA9IHt9LCBfYVtuYW1lcy5lbmRdID0gcmVjdFtuYW1lcy5zdGFydF0sIF9hKSlcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGVsZW1lbnRSZWN0MiA9IHtcbiAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICAgIHJlY3Q6IF9fYXNzaWduKF9fYXNzaWduKHt9LCByZWN0KSwgKF9iID0ge30sIF9iW25hbWVzLnN0YXJ0XSA9IHJlY3RbbmFtZXMuZW5kXSwgX2IpKVxuICAgICAgICB9O1xuICAgICAgICB2YXIgbmV4dFBvczEgPSBbMCwgMF07XG4gICAgICAgIHZhciBuZXh0UG9zMiA9IFswLCAwXTtcbiAgICAgICAgbmV4dFBvczFbaW5kZXhdID0gcG9zW2luZGV4XTtcbiAgICAgICAgbmV4dFBvczFbb3RoZXJJbmRleF0gPSBwb3Nbb3RoZXJJbmRleF07XG4gICAgICAgIG5leHRQb3MyW2luZGV4XSA9IHBvc1tpbmRleF07XG4gICAgICAgIG5leHRQb3MyW290aGVySW5kZXhdID0gcG9zW290aGVySW5kZXhdICsgZ3VpZGVsaW5lLnNpemU7XG4gICAgICAgIHN0YXJ0LnB1c2goe1xuICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgcG9zOiBuZXh0UG9zMSxcbiAgICAgICAgICBzaXplOiAwLFxuICAgICAgICAgIGVsZW1lbnRSZWN0OiBlbGVtZW50UmVjdDFcbiAgICAgICAgfSk7XG4gICAgICAgIGVuZC5wdXNoKHtcbiAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgIHBvczogbmV4dFBvczIsXG4gICAgICAgICAgc2l6ZTogMCxcbiAgICAgICAgICBlbGVtZW50UmVjdDogZWxlbWVudFJlY3QyXG4gICAgICAgIH0pOyAvLyBpbm5lci5wdXNoKGd1aWRlbGluZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgc3RhcnQuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGIucG9zW290aGVySW5kZXhdIC0gYS5wb3Nbb3RoZXJJbmRleF07XG4gICAgfSk7XG4gICAgZW5kLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLnBvc1tvdGhlckluZGV4XSAtIGIucG9zW290aGVySW5kZXhdO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICB0b3RhbDogbmV4dEd1aWRlbGluZXMsXG4gICAgICBzdGFydDogc3RhcnQsXG4gICAgICBlbmQ6IGVuZCxcbiAgICAgIGlubmVyOiBpbm5lclxuICAgIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVuZGVyRGFzaGVkR3VpZGVsaW5lcyhtb3ZlYWJsZSwgZ3VpZGVsaW5lcywgdGFyZ2V0UG9zLCB0YXJnZXRSZWN0LCBSZWFjdCkge1xuICB2YXIgaXNEaXNwbGF5SW5uZXJTbmFwRGlnaXQgPSBtb3ZlYWJsZS5wcm9wcy5pc0Rpc3BsYXlJbm5lclNuYXBEaWdpdDtcbiAgdmFyIHJlbmRlcmVkID0gW107XG4gIFtcInZlcnRpY2FsXCIsIFwiaG9yaXpvbnRhbFwiXS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIG5leHRHdWlkZWxpbmVzID0gZ3VpZGVsaW5lcy5maWx0ZXIoZnVuY3Rpb24gKGd1aWRlbGluZSkge1xuICAgICAgcmV0dXJuIGd1aWRlbGluZS50eXBlID09PSB0eXBlO1xuICAgIH0pO1xuICAgIHZhciBpbmRleCA9IHR5cGUgPT09IFwidmVydGljYWxcIiA/IDEgOiAwO1xuICAgIHZhciBvdGhlckluZGV4ID0gaW5kZXggPyAwIDogMTtcbiAgICB2YXIgZ3JvdXBzID0gZ3JvdXBCeUVsZW1lbnRHdWlkZWxpbmVzKHR5cGUsIG5leHRHdWlkZWxpbmVzLCB0YXJnZXRSZWN0LCBpc0Rpc3BsYXlJbm5lclNuYXBEaWdpdCk7XG4gICAgdmFyIG1haW5OYW1lcyA9IGluZGV4ID8gSE9SSVpPTlRBTF9OQU1FU19NQVAgOiBWRVJUSUNBTF9OQU1FU19NQVA7XG4gICAgdmFyIHNpZGVOYW1lcyA9IGluZGV4ID8gVkVSVElDQUxfTkFNRVNfTUFQIDogSE9SSVpPTlRBTF9OQU1FU19NQVA7XG4gICAgdmFyIHRhcmdldFN0YXJ0ID0gdGFyZ2V0UmVjdFttYWluTmFtZXMuc3RhcnRdO1xuICAgIHZhciB0YXJnZXRFbmQgPSB0YXJnZXRSZWN0W21haW5OYW1lcy5lbmRdO1xuICAgIGdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgdmFyIHRvdGFsID0gX2EudG90YWwsXG4gICAgICAgICAgc3RhcnQgPSBfYS5zdGFydCxcbiAgICAgICAgICBlbmQgPSBfYS5lbmQsXG4gICAgICAgICAgaW5uZXIgPSBfYS5pbm5lcjtcbiAgICAgIHZhciBzaWRlUG9zID0gdGFyZ2V0UG9zW290aGVySW5kZXhdICsgdG90YWxbMF0ucG9zW290aGVySW5kZXhdIC0gdGFyZ2V0UmVjdFtzaWRlTmFtZXMuc3RhcnRdO1xuICAgICAgdmFyIHByZXZSZWN0ID0gdGFyZ2V0UmVjdDtcbiAgICAgIHN0YXJ0LmZvckVhY2goZnVuY3Rpb24gKGd1aWRlbGluZSkge1xuICAgICAgICB2YXIgbmV4dFJlY3QgPSBndWlkZWxpbmUuZWxlbWVudFJlY3QucmVjdDtcbiAgICAgICAgdmFyIHNpemUgPSBwcmV2UmVjdFttYWluTmFtZXMuc3RhcnRdIC0gbmV4dFJlY3RbbWFpbk5hbWVzLmVuZF07XG5cbiAgICAgICAgaWYgKHNpemUgPiAwKSB7XG4gICAgICAgICAgdmFyIHJlbmRlclBvcyA9IFswLCAwXTtcbiAgICAgICAgICByZW5kZXJQb3NbaW5kZXhdID0gdGFyZ2V0UG9zW2luZGV4XSArIHByZXZSZWN0W21haW5OYW1lcy5zdGFydF0gLSB0YXJnZXRTdGFydCAtIHNpemU7XG4gICAgICAgICAgcmVuZGVyUG9zW290aGVySW5kZXhdID0gc2lkZVBvcztcbiAgICAgICAgICByZW5kZXJlZC5wdXNoKHJlbmRlckRpZ2l0TGluZShtb3ZlYWJsZSwgdHlwZSwgXCJkYXNoZWRcIiwgcmVuZGVyZWQubGVuZ3RoLCBzaXplLCByZW5kZXJQb3MsIGd1aWRlbGluZS5jbGFzc05hbWUsIFJlYWN0KSk7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2UmVjdCA9IG5leHRSZWN0O1xuICAgICAgfSk7XG4gICAgICBwcmV2UmVjdCA9IHRhcmdldFJlY3Q7XG4gICAgICBlbmQuZm9yRWFjaChmdW5jdGlvbiAoZ3VpZGVsaW5lKSB7XG4gICAgICAgIHZhciBuZXh0UmVjdCA9IGd1aWRlbGluZS5lbGVtZW50UmVjdC5yZWN0O1xuICAgICAgICB2YXIgc2l6ZSA9IG5leHRSZWN0W21haW5OYW1lcy5zdGFydF0gLSBwcmV2UmVjdFttYWluTmFtZXMuZW5kXTtcblxuICAgICAgICBpZiAoc2l6ZSA+IDApIHtcbiAgICAgICAgICB2YXIgcmVuZGVyUG9zID0gWzAsIDBdO1xuICAgICAgICAgIHJlbmRlclBvc1tpbmRleF0gPSB0YXJnZXRQb3NbaW5kZXhdICsgcHJldlJlY3RbbWFpbk5hbWVzLmVuZF0gLSB0YXJnZXRTdGFydDtcbiAgICAgICAgICByZW5kZXJQb3Nbb3RoZXJJbmRleF0gPSBzaWRlUG9zO1xuICAgICAgICAgIHJlbmRlcmVkLnB1c2gocmVuZGVyRGlnaXRMaW5lKG1vdmVhYmxlLCB0eXBlLCBcImRhc2hlZFwiLCByZW5kZXJlZC5sZW5ndGgsIHNpemUsIHJlbmRlclBvcywgZ3VpZGVsaW5lLmNsYXNzTmFtZSwgUmVhY3QpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZSZWN0ID0gbmV4dFJlY3Q7XG4gICAgICB9KTtcbiAgICAgIGlubmVyLmZvckVhY2goZnVuY3Rpb24gKGd1aWRlbGluZSkge1xuICAgICAgICB2YXIgbmV4dFJlY3QgPSBndWlkZWxpbmUuZWxlbWVudFJlY3QucmVjdDtcbiAgICAgICAgdmFyIHNpemUxID0gdGFyZ2V0U3RhcnQgLSBuZXh0UmVjdFttYWluTmFtZXMuc3RhcnRdO1xuICAgICAgICB2YXIgc2l6ZTIgPSBuZXh0UmVjdFttYWluTmFtZXMuZW5kXSAtIHRhcmdldEVuZDtcbiAgICAgICAgdmFyIHJlbmRlclBvczEgPSBbMCwgMF07XG4gICAgICAgIHZhciByZW5kZXJQb3MyID0gWzAsIDBdO1xuICAgICAgICByZW5kZXJQb3MxW2luZGV4XSA9IHRhcmdldFBvc1tpbmRleF0gLSBzaXplMTtcbiAgICAgICAgcmVuZGVyUG9zMVtvdGhlckluZGV4XSA9IHNpZGVQb3M7XG4gICAgICAgIHJlbmRlclBvczJbaW5kZXhdID0gdGFyZ2V0UG9zW2luZGV4XSArIHRhcmdldEVuZCAtIHRhcmdldFN0YXJ0O1xuICAgICAgICByZW5kZXJQb3MyW290aGVySW5kZXhdID0gc2lkZVBvcztcbiAgICAgICAgcmVuZGVyZWQucHVzaChyZW5kZXJEaWdpdExpbmUobW92ZWFibGUsIHR5cGUsIFwiZGFzaGVkXCIsIHJlbmRlcmVkLmxlbmd0aCwgc2l6ZTEsIHJlbmRlclBvczEsIGd1aWRlbGluZS5jbGFzc05hbWUsIFJlYWN0KSk7XG4gICAgICAgIHJlbmRlcmVkLnB1c2gocmVuZGVyRGlnaXRMaW5lKG1vdmVhYmxlLCB0eXBlLCBcImRhc2hlZFwiLCByZW5kZXJlZC5sZW5ndGgsIHNpemUyLCByZW5kZXJQb3MyLCBndWlkZWxpbmUuY2xhc3NOYW1lLCBSZWFjdCkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gcmVuZGVyZWQ7XG59XG5mdW5jdGlvbiByZW5kZXJHYXBHdWlkZWxpbmVzKG1vdmVhYmxlLCBndWlkZWxpbmVzLCB0YXJnZXRQb3MsIHRhcmdldFJlY3QsIFJlYWN0KSB7XG4gIHZhciByZW5kZXJlZCA9IFtdO1xuICBbXCJob3Jpem9udGFsXCIsIFwidmVydGljYWxcIl0uZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIHZhciBuZXh0R3VpZGVsaW5lcyA9IGd1aWRlbGluZXMuZmlsdGVyKGZ1bmN0aW9uIChndWlkZWxpbmUpIHtcbiAgICAgIHJldHVybiBndWlkZWxpbmUudHlwZSA9PT0gdHlwZTtcbiAgICB9KTtcbiAgICB2YXIgaW5kZXggPSB0eXBlID09PSBcInZlcnRpY2FsXCIgPyAwIDogMTtcbiAgICB2YXIgb3RoZXJJbmRleCA9IGluZGV4ID8gMCA6IDE7XG4gICAgdmFyIG1haW5OYW1lcyA9IGluZGV4ID8gSE9SSVpPTlRBTF9OQU1FU19NQVAgOiBWRVJUSUNBTF9OQU1FU19NQVA7XG4gICAgdmFyIHNpZGVOYW1lcyA9IGluZGV4ID8gVkVSVElDQUxfTkFNRVNfTUFQIDogSE9SSVpPTlRBTF9OQU1FU19NQVA7XG4gICAgdmFyIHRhcmdldFN0YXJ0ID0gdGFyZ2V0UmVjdFttYWluTmFtZXMuc3RhcnRdO1xuICAgIHZhciB0YXJnZXRFbmQgPSB0YXJnZXRSZWN0W21haW5OYW1lcy5lbmRdO1xuICAgIHZhciB0YXJnZXRTaWRlU3RhcnQgPSB0YXJnZXRSZWN0W3NpZGVOYW1lcy5zdGFydF07XG4gICAgdmFyIHRhcmdldFNpZGVFbmQgPSB0YXJnZXRSZWN0W3NpZGVOYW1lcy5lbmRdO1xuICAgIG5leHRHdWlkZWxpbmVzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICB2YXIgZ2FwID0gX2EuZ2FwLFxuICAgICAgICAgIGdhcFJlY3RzID0gX2EuZ2FwUmVjdHMsXG4gICAgICAgICAgY2xhc3NOYW1lID0gX2EuY2xhc3NOYW1lO1xuICAgICAgdmFyIHNpZGVTdGFydFBvcyA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIF9fc3ByZWFkQXJyYXkoW3RhcmdldFNpZGVTdGFydF0sIGdhcFJlY3RzLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHJlY3QgPSBfYS5yZWN0O1xuICAgICAgICByZXR1cm4gcmVjdFtzaWRlTmFtZXMuc3RhcnRdO1xuICAgICAgfSkpKTtcbiAgICAgIHZhciBzaWRlRW5kUG9zID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgX19zcHJlYWRBcnJheShbdGFyZ2V0U2lkZUVuZF0sIGdhcFJlY3RzLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHJlY3QgPSBfYS5yZWN0O1xuICAgICAgICByZXR1cm4gcmVjdFtzaWRlTmFtZXMuZW5kXTtcbiAgICAgIH0pKSk7XG4gICAgICB2YXIgc2lkZUNlbnRlclBvcyA9IChzaWRlU3RhcnRQb3MgKyBzaWRlRW5kUG9zKSAvIDI7XG5cbiAgICAgIGlmIChzaWRlU3RhcnRQb3MgPT09IHNpZGVFbmRQb3MgfHwgc2lkZUNlbnRlclBvcyA9PT0gKHRhcmdldFNpZGVTdGFydCArIHRhcmdldFNpZGVFbmQpIC8gMikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGdhcFJlY3RzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciByZWN0ID0gX2EucmVjdDtcbiAgICAgICAgdmFyIHJlbmRlclBvcyA9IFt0YXJnZXRQb3NbMF0sIHRhcmdldFBvc1sxXV07XG5cbiAgICAgICAgaWYgKHJlY3RbbWFpbk5hbWVzLmVuZF0gPCB0YXJnZXRTdGFydCkge1xuICAgICAgICAgIHJlbmRlclBvc1tpbmRleF0gKz0gcmVjdFttYWluTmFtZXMuZW5kXSAtIHRhcmdldFN0YXJ0O1xuICAgICAgICB9IGVsc2UgaWYgKHRhcmdldEVuZCA8IHJlY3RbbWFpbk5hbWVzLnN0YXJ0XSkge1xuICAgICAgICAgIHJlbmRlclBvc1tpbmRleF0gKz0gcmVjdFttYWluTmFtZXMuc3RhcnRdIC0gdGFyZ2V0U3RhcnQgLSBnYXA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyUG9zW290aGVySW5kZXhdICs9IHNpZGVDZW50ZXJQb3MgLSB0YXJnZXRTaWRlU3RhcnQ7XG4gICAgICAgIHJlbmRlcmVkLnB1c2gocmVuZGVyRGlnaXRMaW5lKG1vdmVhYmxlLCBpbmRleCA/IFwidmVydGljYWxcIiA6IFwiaG9yaXpvbnRhbFwiLCBcImdhcFwiLCByZW5kZXJlZC5sZW5ndGgsIGdhcCwgcmVuZGVyUG9zLCBjbGFzc05hbWUsIFJlYWN0KSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiByZW5kZXJlZDtcbn1cblxuZnVuY3Rpb24gc29sdmVFcXVhdGlvbihwb3MxLCBwb3MyLCBzbmFwT2Zmc2V0LCBpc1ZlcnRpY2FsKSB7XG4gIHZhciBkeCA9IHBvczJbMF0gLSBwb3MxWzBdO1xuICB2YXIgZHkgPSBwb3MyWzFdIC0gcG9zMVsxXTtcblxuICBpZiAoTWF0aC5hYnMoZHgpIDwgVElOWV9OVU0kMSkge1xuICAgIGR4ID0gMDtcbiAgfVxuXG4gIGlmIChNYXRoLmFicyhkeSkgPCBUSU5ZX05VTSQxKSB7XG4gICAgZHkgPSAwO1xuICB9XG5cbiAgaWYgKCFkeCkge1xuICAgIC8vIHkgPSAwICogeCArIGJcbiAgICAvLyBvbmx5IGhvcml6b250YWxcbiAgICBpZiAoIWlzVmVydGljYWwpIHtcbiAgICAgIHJldHVybiBbMCwgc25hcE9mZnNldF07XG4gICAgfVxuXG4gICAgcmV0dXJuIFswLCAwXTtcbiAgfVxuXG4gIGlmICghZHkpIHtcbiAgICAvLyBvbmx5IHZlcnRpY2FsXG4gICAgaWYgKGlzVmVydGljYWwpIHtcbiAgICAgIHJldHVybiBbc25hcE9mZnNldCwgMF07XG4gICAgfVxuXG4gICAgcmV0dXJuIFswLCAwXTtcbiAgfSAvLyB5ID0gYXggKyBiXG5cblxuICB2YXIgYSA9IGR5IC8gZHg7XG4gIHZhciBiID0gcG9zMVsxXSAtIGEgKiBwb3MxWzBdO1xuXG4gIGlmIChpc1ZlcnRpY2FsKSB7XG4gICAgLy8geSA9IGEgKiB4ICsgYlxuICAgIHZhciB5ID0gYSAqIChwb3MyWzBdICsgc25hcE9mZnNldCkgKyBiO1xuICAgIHJldHVybiBbc25hcE9mZnNldCwgeSAtIHBvczJbMV1dO1xuICB9IGVsc2Uge1xuICAgIC8vIHggPSAoeSAtIGIpIC8gYVxuICAgIHZhciB4ID0gKHBvczJbMV0gKyBzbmFwT2Zmc2V0IC0gYikgLyBhO1xuICAgIHJldHVybiBbeCAtIHBvczJbMF0sIHNuYXBPZmZzZXRdO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNvbHZlTmV4dE9mZnNldChwb3MxLCBwb3MyLCBvZmZzZXQsIGlzVmVydGljYWwsIGRhdGFzKSB7XG4gIHZhciBzaXplT2Zmc2V0ID0gc29sdmVFcXVhdGlvbihwb3MxLCBwb3MyLCBvZmZzZXQsIGlzVmVydGljYWwpO1xuXG4gIGlmICghc2l6ZU9mZnNldCkge1xuICAgIHJldHVybiB7XG4gICAgICBpc091dHNpZGU6IGZhbHNlLFxuICAgICAgb2Zmc2V0OiBbMCwgMF1cbiAgICB9O1xuICB9XG5cbiAgdmFyIHNpemUgPSBnZXREaXN0JDEocG9zMSwgcG9zMik7XG4gIHZhciBkaXN0MSA9IGdldERpc3QkMShzaXplT2Zmc2V0LCBwb3MxKTtcbiAgdmFyIGRpc3QyID0gZ2V0RGlzdCQxKHNpemVPZmZzZXQsIHBvczIpO1xuICB2YXIgaXNPdXRzaWRlID0gZGlzdDEgPiBzaXplIHx8IGRpc3QyID4gc2l6ZTtcblxuICB2YXIgX2EgPSBnZXREcmFnRGlzdCh7XG4gICAgZGF0YXM6IGRhdGFzLFxuICAgIGRpc3RYOiBzaXplT2Zmc2V0WzBdLFxuICAgIGRpc3RZOiBzaXplT2Zmc2V0WzFdXG4gIH0pLFxuICAgICAgd2lkdGhPZmZzZXQgPSBfYVswXSxcbiAgICAgIGhlaWdodE9mZnNldCA9IF9hWzFdO1xuXG4gIHJldHVybiB7XG4gICAgb2Zmc2V0OiBbd2lkdGhPZmZzZXQsIGhlaWdodE9mZnNldF0sXG4gICAgaXNPdXRzaWRlOiBpc091dHNpZGVcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0U25hcEJvdW5kKGJvdW5kSW5mbywgc25hcEluZm8pIHtcbiAgaWYgKGJvdW5kSW5mby5pc0JvdW5kKSB7XG4gICAgcmV0dXJuIGJvdW5kSW5mby5vZmZzZXQ7XG4gIH0gZWxzZSBpZiAoc25hcEluZm8uaXNTbmFwKSB7XG4gICAgcmV0dXJuIGdldE5lYXJlc3RTbmFwR3VpZGVsaW5lSW5mbyhzbmFwSW5mbykub2Zmc2V0O1xuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGNoZWNrVGhyb3R0bGVEcmFnUm90YXRlKHRocm90dGxlRHJhZ1JvdGF0ZSwgX2EsIF9iLCBfYywgX2QpIHtcbiAgdmFyIGRpc3RYID0gX2FbMF0sXG4gICAgICBkaXN0WSA9IF9hWzFdO1xuICB2YXIgaXNWZXJ0aWNhbEJvdW5kID0gX2JbMF0sXG4gICAgICBpc0hvcml6b250YWxCb3VuZCA9IF9iWzFdO1xuICB2YXIgaXNWZXJ0aWNhbFNuYXAgPSBfY1swXSxcbiAgICAgIGlzSG9yaXpvbnRhbFNuYXAgPSBfY1sxXTtcbiAgdmFyIHZlcnRpY2FsT2Zmc2V0ID0gX2RbMF0sXG4gICAgICBob3Jpem9udGFsT2Zmc2V0ID0gX2RbMV07XG4gIHZhciBvZmZzZXRYID0gLXZlcnRpY2FsT2Zmc2V0O1xuICB2YXIgb2Zmc2V0WSA9IC1ob3Jpem9udGFsT2Zmc2V0O1xuXG4gIGlmICh0aHJvdHRsZURyYWdSb3RhdGUgJiYgZGlzdFggJiYgZGlzdFkpIHtcbiAgICBvZmZzZXRYID0gMDtcbiAgICBvZmZzZXRZID0gMDtcbiAgICB2YXIgYWRqdXN0UG9zZXMgPSBbXTtcblxuICAgIGlmIChpc1ZlcnRpY2FsQm91bmQgJiYgaXNIb3Jpem9udGFsQm91bmQpIHtcbiAgICAgIGFkanVzdFBvc2VzLnB1c2goWzAsIGhvcml6b250YWxPZmZzZXRdLCBbdmVydGljYWxPZmZzZXQsIDBdKTtcbiAgICB9IGVsc2UgaWYgKGlzVmVydGljYWxCb3VuZCkge1xuICAgICAgYWRqdXN0UG9zZXMucHVzaChbdmVydGljYWxPZmZzZXQsIDBdKTtcbiAgICB9IGVsc2UgaWYgKGlzSG9yaXpvbnRhbEJvdW5kKSB7XG4gICAgICBhZGp1c3RQb3Nlcy5wdXNoKFswLCBob3Jpem9udGFsT2Zmc2V0XSk7XG4gICAgfSBlbHNlIGlmIChpc1ZlcnRpY2FsU25hcCAmJiBpc0hvcml6b250YWxTbmFwKSB7XG4gICAgICBhZGp1c3RQb3Nlcy5wdXNoKFswLCBob3Jpem9udGFsT2Zmc2V0XSwgW3ZlcnRpY2FsT2Zmc2V0LCAwXSk7XG4gICAgfSBlbHNlIGlmIChpc1ZlcnRpY2FsU25hcCkge1xuICAgICAgYWRqdXN0UG9zZXMucHVzaChbdmVydGljYWxPZmZzZXQsIDBdKTtcbiAgICB9IGVsc2UgaWYgKGlzSG9yaXpvbnRhbFNuYXApIHtcbiAgICAgIGFkanVzdFBvc2VzLnB1c2goWzAsIGhvcml6b250YWxPZmZzZXRdKTtcbiAgICB9XG5cbiAgICBpZiAoYWRqdXN0UG9zZXMubGVuZ3RoKSB7XG4gICAgICBhZGp1c3RQb3Nlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBnZXREaXN0U2l6ZShtaW51cyhbZGlzdFgsIGRpc3RZXSwgYSkpIC0gZ2V0RGlzdFNpemUobWludXMoW2Rpc3RYLCBkaXN0WV0sIGIpKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGFkanVzdFBvcyA9IGFkanVzdFBvc2VzWzBdO1xuXG4gICAgICBpZiAoYWRqdXN0UG9zWzBdICYmIE1hdGguYWJzKGRpc3RYKSA+IFRJTllfTlVNJDEpIHtcbiAgICAgICAgb2Zmc2V0WCA9IC1hZGp1c3RQb3NbMF07XG4gICAgICAgIG9mZnNldFkgPSBkaXN0WSAqIE1hdGguYWJzKGRpc3RYICsgb2Zmc2V0WCkgLyBNYXRoLmFicyhkaXN0WCkgLSBkaXN0WTtcbiAgICAgIH0gZWxzZSBpZiAoYWRqdXN0UG9zWzFdICYmIE1hdGguYWJzKGRpc3RZKSA+IFRJTllfTlVNJDEpIHtcbiAgICAgICAgdmFyIHByZXZEaXN0WSA9IGRpc3RZO1xuICAgICAgICBvZmZzZXRZID0gLWFkanVzdFBvc1sxXTtcbiAgICAgICAgb2Zmc2V0WCA9IGRpc3RYICogTWF0aC5hYnMoZGlzdFkgKyBvZmZzZXRZKSAvIE1hdGguYWJzKHByZXZEaXN0WSkgLSBkaXN0WDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRocm90dGxlRHJhZ1JvdGF0ZSAmJiBpc0hvcml6b250YWxCb3VuZCAmJiBpc1ZlcnRpY2FsQm91bmQpIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKG9mZnNldFgpID4gVElOWV9OVU0kMSAmJiBNYXRoLmFicyhvZmZzZXRYKSA8IE1hdGguYWJzKHZlcnRpY2FsT2Zmc2V0KSkge1xuICAgICAgICAgIHZhciBzY2FsZSA9IE1hdGguYWJzKHZlcnRpY2FsT2Zmc2V0KSAvIE1hdGguYWJzKG9mZnNldFgpO1xuICAgICAgICAgIG9mZnNldFggKj0gc2NhbGU7XG4gICAgICAgICAgb2Zmc2V0WSAqPSBzY2FsZTtcbiAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhvZmZzZXRZKSA+IFRJTllfTlVNJDEgJiYgTWF0aC5hYnMob2Zmc2V0WSkgPCBNYXRoLmFicyhob3Jpem9udGFsT2Zmc2V0KSkge1xuICAgICAgICAgIHZhciBzY2FsZSA9IE1hdGguYWJzKGhvcml6b250YWxPZmZzZXQpIC8gTWF0aC5hYnMob2Zmc2V0WSk7XG4gICAgICAgICAgb2Zmc2V0WCAqPSBzY2FsZTtcbiAgICAgICAgICBvZmZzZXRZICo9IHNjYWxlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZnNldFggPSBtYXhPZmZzZXQoLXZlcnRpY2FsT2Zmc2V0LCBvZmZzZXRYKTtcbiAgICAgICAgICBvZmZzZXRZID0gbWF4T2Zmc2V0KC1ob3Jpem9udGFsT2Zmc2V0LCBvZmZzZXRZKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvZmZzZXRYID0gZGlzdFggfHwgaXNWZXJ0aWNhbEJvdW5kID8gLXZlcnRpY2FsT2Zmc2V0IDogMDtcbiAgICBvZmZzZXRZID0gZGlzdFkgfHwgaXNIb3Jpem9udGFsQm91bmQgPyAtaG9yaXpvbnRhbE9mZnNldCA6IDA7XG4gIH1cblxuICByZXR1cm4gW29mZnNldFgsIG9mZnNldFldO1xufVxuZnVuY3Rpb24gY2hlY2tTbmFwQm91bmRzRHJhZyhtb3ZlYWJsZSwgZGlzdFgsIGRpc3RZLCB0aHJvdHRsZURyYWdSb3RhdGUsIGlzUmVxdWVzdCwgZGF0YXMpIHtcbiAgaWYgKCFoYXNHdWlkZWxpbmVzKG1vdmVhYmxlLCBcImRyYWdnYWJsZVwiKSkge1xuICAgIHJldHVybiBbe1xuICAgICAgaXNTbmFwOiBmYWxzZSxcbiAgICAgIGlzQm91bmQ6IGZhbHNlLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSwge1xuICAgICAgaXNTbmFwOiBmYWxzZSxcbiAgICAgIGlzQm91bmQ6IGZhbHNlLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfV07XG4gIH1cblxuICB2YXIgcG9zZXMgPSBnZXRBYnNvbHV0ZVBvc2VzKGRhdGFzLmFic29sdXRlUG9zZXMsIFtkaXN0WCwgZGlzdFldKTtcblxuICB2YXIgX2EgPSBnZXRSZWN0KHBvc2VzKSxcbiAgICAgIGxlZnQgPSBfYS5sZWZ0LFxuICAgICAgcmlnaHQgPSBfYS5yaWdodCxcbiAgICAgIHRvcCA9IF9hLnRvcCxcbiAgICAgIGJvdHRvbSA9IF9hLmJvdHRvbTtcblxuICB2YXIgYm91bmRQb3NlcyA9IHtcbiAgICBob3Jpem9udGFsOiBwb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgICAgcmV0dXJuIHBvc1sxXTtcbiAgICB9KSxcbiAgICB2ZXJ0aWNhbDogcG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgIHJldHVybiBwb3NbMF07XG4gICAgfSlcbiAgfTtcbiAgdmFyIHNuYXBEaXJlY3Rpb25zID0gZ2V0U25hcERpcmVjdGlvbnMobW92ZWFibGUucHJvcHMuc25hcERpcmVjdGlvbnMpO1xuICB2YXIgc25hcFBvc2VzID0gc3BsaXRTbmFwRGlyZWN0aW9uUG9zZXMoc25hcERpcmVjdGlvbnMsIHtcbiAgICBsZWZ0OiBsZWZ0LFxuICAgIHJpZ2h0OiByaWdodCxcbiAgICB0b3A6IHRvcCxcbiAgICBib3R0b206IGJvdHRvbSxcbiAgICBjZW50ZXI6IChsZWZ0ICsgcmlnaHQpIC8gMixcbiAgICBtaWRkbGU6ICh0b3AgKyBib3R0b20pIC8gMlxuICB9KTtcblxuICB2YXIgX2IgPSBjaGVja01vdmVhYmxlU25hcEJvdW5kcyhtb3ZlYWJsZSwgaXNSZXF1ZXN0LCBzbmFwUG9zZXMsIGJvdW5kUG9zZXMpLFxuICAgICAgdmVydGljYWxTbmFwQm91bmRJbmZvID0gX2IudmVydGljYWwsXG4gICAgICBob3Jpem9udGFsU25hcEJvdW5kSW5mbyA9IF9iLmhvcml6b250YWw7XG5cbiAgdmFyIF9jID0gZ2V0SW5uZXJCb3VuZERyYWdJbmZvKG1vdmVhYmxlLCBwb3NlcywgZGF0YXMpLFxuICAgICAgdmVydGljYWxJbm5lckJvdW5kSW5mbyA9IF9jLnZlcnRpY2FsLFxuICAgICAgaG9yaXpvbnRhbElubmVyQm91bmRJbmZvID0gX2MuaG9yaXpvbnRhbDtcblxuICB2YXIgaXNWZXJ0aWNhbFNuYXAgPSB2ZXJ0aWNhbFNuYXBCb3VuZEluZm8uaXNTbmFwO1xuICB2YXIgaXNIb3Jpem9udGFsU25hcCA9IGhvcml6b250YWxTbmFwQm91bmRJbmZvLmlzU25hcDtcbiAgdmFyIGlzVmVydGljYWxCb3VuZCA9IHZlcnRpY2FsU25hcEJvdW5kSW5mby5pc0JvdW5kIHx8IHZlcnRpY2FsSW5uZXJCb3VuZEluZm8uaXNCb3VuZDtcbiAgdmFyIGlzSG9yaXpvbnRhbEJvdW5kID0gaG9yaXpvbnRhbFNuYXBCb3VuZEluZm8uaXNCb3VuZCB8fCBob3Jpem9udGFsSW5uZXJCb3VuZEluZm8uaXNCb3VuZDtcbiAgdmFyIHZlcnRpY2FsT2Zmc2V0ID0gbWF4T2Zmc2V0KHZlcnRpY2FsU25hcEJvdW5kSW5mby5vZmZzZXQsIHZlcnRpY2FsSW5uZXJCb3VuZEluZm8ub2Zmc2V0KTtcbiAgdmFyIGhvcml6b250YWxPZmZzZXQgPSBtYXhPZmZzZXQoaG9yaXpvbnRhbFNuYXBCb3VuZEluZm8ub2Zmc2V0LCBob3Jpem9udGFsSW5uZXJCb3VuZEluZm8ub2Zmc2V0KTtcblxuICB2YXIgX2QgPSBjaGVja1Rocm90dGxlRHJhZ1JvdGF0ZSh0aHJvdHRsZURyYWdSb3RhdGUsIFtkaXN0WCwgZGlzdFldLCBbaXNWZXJ0aWNhbEJvdW5kLCBpc0hvcml6b250YWxCb3VuZF0sIFtpc1ZlcnRpY2FsU25hcCwgaXNIb3Jpem9udGFsU25hcF0sIFt2ZXJ0aWNhbE9mZnNldCwgaG9yaXpvbnRhbE9mZnNldF0pLFxuICAgICAgb2Zmc2V0WCA9IF9kWzBdLFxuICAgICAgb2Zmc2V0WSA9IF9kWzFdO1xuXG4gIHJldHVybiBbe1xuICAgIGlzQm91bmQ6IGlzVmVydGljYWxCb3VuZCxcbiAgICBpc1NuYXA6IGlzVmVydGljYWxTbmFwLFxuICAgIG9mZnNldDogb2Zmc2V0WFxuICB9LCB7XG4gICAgaXNCb3VuZDogaXNIb3Jpem9udGFsQm91bmQsXG4gICAgaXNTbmFwOiBpc0hvcml6b250YWxTbmFwLFxuICAgIG9mZnNldDogb2Zmc2V0WVxuICB9XTtcbn1cbmZ1bmN0aW9uIGNoZWNrTW92ZWFibGVTbmFwQm91bmRzKG1vdmVhYmxlLCBpc1JlcXVlc3QsIHBvc2VzLCBib3VuZFBvc2VzKSB7XG4gIGlmIChib3VuZFBvc2VzID09PSB2b2lkIDApIHtcbiAgICBib3VuZFBvc2VzID0gcG9zZXM7XG4gIH1cblxuICB2YXIgX2EgPSBjaGVja0JvdW5kUG9zZXMoZ2V0Qm91bmRzKG1vdmVhYmxlKSwgYm91bmRQb3Nlcy52ZXJ0aWNhbCwgYm91bmRQb3Nlcy5ob3Jpem9udGFsKSxcbiAgICAgIGhvcml6b250YWxCb3VuZEluZm9zID0gX2EuaG9yaXpvbnRhbCxcbiAgICAgIHZlcnRpY2FsQm91bmRJbmZvcyA9IF9hLnZlcnRpY2FsO1xuXG4gIHZhciBfYiA9IGlzUmVxdWVzdCA/IHtcbiAgICBob3Jpem9udGFsOiB7XG4gICAgICBpc1NuYXA6IGZhbHNlLFxuICAgICAgaW5kZXg6IC0xXG4gICAgfSxcbiAgICB2ZXJ0aWNhbDoge1xuICAgICAgaXNTbmFwOiBmYWxzZSxcbiAgICAgIGluZGV4OiAtMVxuICAgIH1cbiAgfSA6IGNoZWNrTW92ZWFibGVTbmFwUG9zZXMobW92ZWFibGUsIHBvc2VzLnZlcnRpY2FsLCBwb3Nlcy5ob3Jpem9udGFsKSxcbiAgICAgIGhvcml6b250YWxTbmFwSW5mbyA9IF9iLmhvcml6b250YWwsXG4gICAgICB2ZXJ0aWNhbFNuYXBJbmZvID0gX2IudmVydGljYWw7XG5cbiAgdmFyIGhvcml6b250YWxPZmZzZXQgPSBnZXRTbmFwQm91bmQoaG9yaXpvbnRhbEJvdW5kSW5mb3NbMF0sIGhvcml6b250YWxTbmFwSW5mbyk7XG4gIHZhciB2ZXJ0aWNhbE9mZnNldCA9IGdldFNuYXBCb3VuZCh2ZXJ0aWNhbEJvdW5kSW5mb3NbMF0sIHZlcnRpY2FsU25hcEluZm8pO1xuICB2YXIgaG9yaXpvbnRhbERpc3QgPSBNYXRoLmFicyhob3Jpem9udGFsT2Zmc2V0KTtcbiAgdmFyIHZlcnRpY2FsRGlzdCA9IE1hdGguYWJzKHZlcnRpY2FsT2Zmc2V0KTtcbiAgcmV0dXJuIHtcbiAgICBob3Jpem9udGFsOiB7XG4gICAgICBpc0JvdW5kOiBob3Jpem9udGFsQm91bmRJbmZvc1swXS5pc0JvdW5kLFxuICAgICAgaXNTbmFwOiBob3Jpem9udGFsU25hcEluZm8uaXNTbmFwLFxuICAgICAgc25hcEluZGV4OiBob3Jpem9udGFsU25hcEluZm8uaW5kZXgsXG4gICAgICBvZmZzZXQ6IGhvcml6b250YWxPZmZzZXQsXG4gICAgICBkaXN0OiBob3Jpem9udGFsRGlzdCxcbiAgICAgIGJvdW5kczogaG9yaXpvbnRhbEJvdW5kSW5mb3MsXG4gICAgICBzbmFwOiBob3Jpem9udGFsU25hcEluZm9cbiAgICB9LFxuICAgIHZlcnRpY2FsOiB7XG4gICAgICBpc0JvdW5kOiB2ZXJ0aWNhbEJvdW5kSW5mb3NbMF0uaXNCb3VuZCxcbiAgICAgIGlzU25hcDogdmVydGljYWxTbmFwSW5mby5pc1NuYXAsXG4gICAgICBzbmFwSW5kZXg6IHZlcnRpY2FsU25hcEluZm8uaW5kZXgsXG4gICAgICBvZmZzZXQ6IHZlcnRpY2FsT2Zmc2V0LFxuICAgICAgZGlzdDogdmVydGljYWxEaXN0LFxuICAgICAgYm91bmRzOiB2ZXJ0aWNhbEJvdW5kSW5mb3MsXG4gICAgICBzbmFwOiB2ZXJ0aWNhbFNuYXBJbmZvXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gY2hlY2tTbmFwQm91bmRzKGd1aWRlaW5lcywgYm91bmRzLCBwb3Nlc1gsIHBvc2VzWSwgc25hcFRocmVzaG9sZCkge1xuICB2YXIgX2EgPSBjaGVja0JvdW5kUG9zZXMoYm91bmRzLCBwb3Nlc1gsIHBvc2VzWSksXG4gICAgICBob3Jpem9udGFsQm91bmRJbmZvcyA9IF9hLmhvcml6b250YWwsXG4gICAgICB2ZXJ0aWNhbEJvdW5kSW5mb3MgPSBfYS52ZXJ0aWNhbDsgLy8gb3B0aW9ucy5pc1JlcXVlc3QgPyB7XG4gIC8vICAgICBob3Jpem9udGFsOiB7IGlzU25hcDogZmFsc2UsIGluZGV4OiAtMSB9IGFzIFNuYXBJbmZvLFxuICAvLyAgICAgdmVydGljYWw6IHsgaXNTbmFwOiBmYWxzZSwgaW5kZXg6IC0xIH0gYXMgU25hcEluZm8sXG4gIC8vIH0gOlxuXG5cbiAgdmFyIF9iID0gY2hlY2tTbmFwUG9zZXMoZ3VpZGVpbmVzLCBwb3Nlc1gsIHBvc2VzWSwgc25hcFRocmVzaG9sZCksXG4gICAgICBob3Jpem9udGFsU25hcEluZm8gPSBfYi5ob3Jpem9udGFsLFxuICAgICAgdmVydGljYWxTbmFwSW5mbyA9IF9iLnZlcnRpY2FsO1xuXG4gIHZhciBob3Jpem9udGFsT2Zmc2V0ID0gZ2V0U25hcEJvdW5kKGhvcml6b250YWxCb3VuZEluZm9zWzBdLCBob3Jpem9udGFsU25hcEluZm8pO1xuICB2YXIgdmVydGljYWxPZmZzZXQgPSBnZXRTbmFwQm91bmQodmVydGljYWxCb3VuZEluZm9zWzBdLCB2ZXJ0aWNhbFNuYXBJbmZvKTtcbiAgdmFyIGhvcml6b250YWxEaXN0ID0gTWF0aC5hYnMoaG9yaXpvbnRhbE9mZnNldCk7XG4gIHZhciB2ZXJ0aWNhbERpc3QgPSBNYXRoLmFicyh2ZXJ0aWNhbE9mZnNldCk7XG4gIHJldHVybiB7XG4gICAgaG9yaXpvbnRhbDoge1xuICAgICAgaXNCb3VuZDogaG9yaXpvbnRhbEJvdW5kSW5mb3NbMF0uaXNCb3VuZCxcbiAgICAgIGlzU25hcDogaG9yaXpvbnRhbFNuYXBJbmZvLmlzU25hcCxcbiAgICAgIHNuYXBJbmRleDogaG9yaXpvbnRhbFNuYXBJbmZvLmluZGV4LFxuICAgICAgb2Zmc2V0OiBob3Jpem9udGFsT2Zmc2V0LFxuICAgICAgZGlzdDogaG9yaXpvbnRhbERpc3QsXG4gICAgICBib3VuZHM6IGhvcml6b250YWxCb3VuZEluZm9zLFxuICAgICAgc25hcDogaG9yaXpvbnRhbFNuYXBJbmZvXG4gICAgfSxcbiAgICB2ZXJ0aWNhbDoge1xuICAgICAgaXNCb3VuZDogdmVydGljYWxCb3VuZEluZm9zWzBdLmlzQm91bmQsXG4gICAgICBpc1NuYXA6IHZlcnRpY2FsU25hcEluZm8uaXNTbmFwLFxuICAgICAgc25hcEluZGV4OiB2ZXJ0aWNhbFNuYXBJbmZvLmluZGV4LFxuICAgICAgb2Zmc2V0OiB2ZXJ0aWNhbE9mZnNldCxcbiAgICAgIGRpc3Q6IHZlcnRpY2FsRGlzdCxcbiAgICAgIGJvdW5kczogdmVydGljYWxCb3VuZEluZm9zLFxuICAgICAgc25hcDogdmVydGljYWxTbmFwSW5mb1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY2hlY2tTbmFwUmlnaHRMaW5lKHN0YXJ0UG9zLCBlbmRQb3MsIHNuYXBCb3VuZEluZm8sIGtlZXBSYXRpbykge1xuICB2YXIgcmFkID0gZ2V0UmFkKHN0YXJ0UG9zLCBlbmRQb3MpIC8gTWF0aC5QSSAqIDE4MDtcbiAgdmFyIF9hID0gc25hcEJvdW5kSW5mby52ZXJ0aWNhbCxcbiAgICAgIGlzVmVydGljYWxCb3VuZCA9IF9hLmlzQm91bmQsXG4gICAgICBpc1ZlcnRpY2FsU25hcCA9IF9hLmlzU25hcCxcbiAgICAgIHZlcnRpY2FsRGlzdCA9IF9hLmRpc3QsXG4gICAgICBfYiA9IHNuYXBCb3VuZEluZm8uaG9yaXpvbnRhbCxcbiAgICAgIGlzSG9yaXpvbnRhbEJvdW5kID0gX2IuaXNCb3VuZCxcbiAgICAgIGlzSG9yaXpvbnRhbFNuYXAgPSBfYi5pc1NuYXAsXG4gICAgICBob3Jpem9udGFsRGlzdCA9IF9iLmRpc3Q7XG4gIHZhciByYWQxODAgPSByYWQgJSAxODA7XG4gIHZhciBpc0hvcml6b250YWxMaW5lID0gcmFkMTgwIDwgMyB8fCByYWQxODAgPiAxNzc7XG4gIHZhciBpc1ZlcnRpY2FsTGluZSA9IHJhZDE4MCA+IDg3ICYmIHJhZDE4MCA8IDkzO1xuXG4gIGlmIChob3Jpem9udGFsRGlzdCA8IHZlcnRpY2FsRGlzdCkge1xuICAgIGlmIChpc1ZlcnRpY2FsQm91bmQgfHwgaXNWZXJ0aWNhbFNuYXAgJiYgIWlzVmVydGljYWxMaW5lICYmICgha2VlcFJhdGlvIHx8ICFpc0hvcml6b250YWxMaW5lKSkge1xuICAgICAgcmV0dXJuIFwidmVydGljYWxcIjtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNIb3Jpem9udGFsQm91bmQgfHwgaXNIb3Jpem9udGFsU25hcCAmJiAhaXNIb3Jpem9udGFsTGluZSAmJiAoIWtlZXBSYXRpbyB8fCAhaXNWZXJ0aWNhbExpbmUpKSB7XG4gICAgcmV0dXJuIFwiaG9yaXpvbnRhbFwiO1xuICB9XG5cbiAgcmV0dXJuIFwiXCI7XG59XG5cbmZ1bmN0aW9uIGdldFNuYXBCb3VuZEluZm8obW92ZWFibGUsIHBvc2VzLCBkaXJlY3Rpb25zLCBrZWVwUmF0aW8sIGlzUmVxdWVzdCwgZGF0YXMpIHtcbiAgcmV0dXJuIGRpcmVjdGlvbnMubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBzdGFydERpcmVjdGlvbiA9IF9hWzBdLFxuICAgICAgICBlbmREaXJlY3Rpb24gPSBfYVsxXTtcbiAgICB2YXIgb3RoZXJTdGFydFBvcyA9IGdldFBvc0J5RGlyZWN0aW9uKHBvc2VzLCBzdGFydERpcmVjdGlvbik7XG4gICAgdmFyIG90aGVyRW5kUG9zID0gZ2V0UG9zQnlEaXJlY3Rpb24ocG9zZXMsIGVuZERpcmVjdGlvbik7XG4gICAgdmFyIHNuYXBCb3VuZEluZm8gPSBrZWVwUmF0aW8gPyBjaGVja1NuYXBCb3VuZHNLZWVwUmF0aW8obW92ZWFibGUsIG90aGVyU3RhcnRQb3MsIG90aGVyRW5kUG9zLCBpc1JlcXVlc3QpIDogY2hlY2tNb3ZlYWJsZVNuYXBCb3VuZHMobW92ZWFibGUsIGlzUmVxdWVzdCwge1xuICAgICAgdmVydGljYWw6IFtvdGhlckVuZFBvc1swXV0sXG4gICAgICBob3Jpem9udGFsOiBbb3RoZXJFbmRQb3NbMV1dXG4gICAgfSk7XG4gICAgdmFyIF9iID0gc25hcEJvdW5kSW5mby5ob3Jpem9udGFsLFxuICAgICAgICAvLyBkaXN0OiBvdGhlckhvcml6b250YWxEaXN0LFxuICAgIG90aGVySG9yaXpvbnRhbE9mZnNldCA9IF9iLm9mZnNldCxcbiAgICAgICAgaXNPdGhlckhvcml6b250YWxCb3VuZCA9IF9iLmlzQm91bmQsXG4gICAgICAgIGlzT3RoZXJIb3Jpem9udGFsU25hcCA9IF9iLmlzU25hcCxcbiAgICAgICAgX2MgPSBzbmFwQm91bmRJbmZvLnZlcnRpY2FsLFxuICAgICAgICAvLyBkaXN0OiBvdGhlclZlcnRpY2FsRGlzdCxcbiAgICBvdGhlclZlcnRpY2FsT2Zmc2V0ID0gX2Mub2Zmc2V0LFxuICAgICAgICBpc090aGVyVmVydGljYWxCb3VuZCA9IF9jLmlzQm91bmQsXG4gICAgICAgIGlzT3RoZXJWZXJ0aWNhbFNuYXAgPSBfYy5pc1NuYXA7XG4gICAgdmFyIG11bHRpcGxlID0gbWludXMoZW5kRGlyZWN0aW9uLCBzdGFydERpcmVjdGlvbik7XG5cbiAgICBpZiAoIW90aGVyVmVydGljYWxPZmZzZXQgJiYgIW90aGVySG9yaXpvbnRhbE9mZnNldCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNCb3VuZDogaXNPdGhlclZlcnRpY2FsQm91bmQgfHwgaXNPdGhlckhvcml6b250YWxCb3VuZCxcbiAgICAgICAgaXNTbmFwOiBpc090aGVyVmVydGljYWxTbmFwIHx8IGlzT3RoZXJIb3Jpem9udGFsU25hcCxcbiAgICAgICAgc2lnbjogbXVsdGlwbGUsXG4gICAgICAgIG9mZnNldDogWzAsIDBdXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBzbmFwTGluZSA9IGNoZWNrU25hcFJpZ2h0TGluZShvdGhlclN0YXJ0UG9zLCBvdGhlckVuZFBvcywgc25hcEJvdW5kSW5mbywga2VlcFJhdGlvKTtcblxuICAgIGlmICghc25hcExpbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNpZ246IG11bHRpcGxlLFxuICAgICAgICBpc0JvdW5kOiBmYWxzZSxcbiAgICAgICAgaXNTbmFwOiBmYWxzZSxcbiAgICAgICAgb2Zmc2V0OiBbMCwgMF1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGlzVmVydGljYWwgPSBzbmFwTGluZSA9PT0gXCJ2ZXJ0aWNhbFwiO1xuICAgIHZhciBzaXplT2Zmc2V0ID0gc29sdmVOZXh0T2Zmc2V0KG90aGVyU3RhcnRQb3MsIG90aGVyRW5kUG9zLCAtKGlzVmVydGljYWwgPyBvdGhlclZlcnRpY2FsT2Zmc2V0IDogb3RoZXJIb3Jpem9udGFsT2Zmc2V0KSwgaXNWZXJ0aWNhbCwgZGF0YXMpLm9mZnNldC5tYXAoZnVuY3Rpb24gKHNpemUsIGkpIHtcbiAgICAgIHJldHVybiBzaXplICogKG11bHRpcGxlW2ldID8gMiAvIG11bHRpcGxlW2ldIDogMCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNpZ246IG11bHRpcGxlLFxuICAgICAgaXNCb3VuZDogaXNWZXJ0aWNhbCA/IGlzT3RoZXJWZXJ0aWNhbEJvdW5kIDogaXNPdGhlckhvcml6b250YWxCb3VuZCxcbiAgICAgIGlzU25hcDogaXNWZXJ0aWNhbCA/IGlzT3RoZXJWZXJ0aWNhbFNuYXAgOiBpc090aGVySG9yaXpvbnRhbFNuYXAsXG4gICAgICBvZmZzZXQ6IHNpemVPZmZzZXRcbiAgICB9O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0U25hcEJvdW5kT2Zmc2V0KGJvdW5kSW5mbywgc25hcEluZm8pIHtcbiAgaWYgKGJvdW5kSW5mby5pc0JvdW5kKSB7XG4gICAgcmV0dXJuIGJvdW5kSW5mby5vZmZzZXQ7XG4gIH0gZWxzZSBpZiAoc25hcEluZm8uaXNTbmFwKSB7XG4gICAgcmV0dXJuIHNuYXBJbmZvLm9mZnNldDtcbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBjaGVja1NuYXBCb3VuZHNLZWVwUmF0aW8obW92ZWFibGUsIHN0YXJ0UG9zLCBlbmRQb3MsIGlzUmVxdWVzdCkge1xuICB2YXIgX2EgPSBjaGVja0JvdW5kS2VlcFJhdGlvKG1vdmVhYmxlLCBzdGFydFBvcywgZW5kUG9zKSxcbiAgICAgIGhvcml6b250YWxCb3VuZEluZm8gPSBfYS5ob3Jpem9udGFsLFxuICAgICAgdmVydGljYWxCb3VuZEluZm8gPSBfYS52ZXJ0aWNhbDtcblxuICB2YXIgX2IgPSBpc1JlcXVlc3QgPyB7XG4gICAgaG9yaXpvbnRhbDoge1xuICAgICAgaXNTbmFwOiBmYWxzZVxuICAgIH0sXG4gICAgdmVydGljYWw6IHtcbiAgICAgIGlzU25hcDogZmFsc2VcbiAgICB9XG4gIH0gOiBjaGVja1NuYXBLZWVwUmF0aW8obW92ZWFibGUsIHN0YXJ0UG9zLCBlbmRQb3MpLFxuICAgICAgaG9yaXpvbnRhbFNuYXBJbmZvID0gX2IuaG9yaXpvbnRhbCxcbiAgICAgIHZlcnRpY2FsU25hcEluZm8gPSBfYi52ZXJ0aWNhbDtcblxuICB2YXIgaG9yaXpvbnRhbE9mZnNldCA9IGdldFNuYXBCb3VuZE9mZnNldChob3Jpem9udGFsQm91bmRJbmZvLCBob3Jpem9udGFsU25hcEluZm8pO1xuICB2YXIgdmVydGljYWxPZmZzZXQgPSBnZXRTbmFwQm91bmRPZmZzZXQodmVydGljYWxCb3VuZEluZm8sIHZlcnRpY2FsU25hcEluZm8pO1xuICB2YXIgaG9yaXpvbnRhbERpc3QgPSBNYXRoLmFicyhob3Jpem9udGFsT2Zmc2V0KTtcbiAgdmFyIHZlcnRpY2FsRGlzdCA9IE1hdGguYWJzKHZlcnRpY2FsT2Zmc2V0KTtcbiAgcmV0dXJuIHtcbiAgICBob3Jpem9udGFsOiB7XG4gICAgICBpc0JvdW5kOiBob3Jpem9udGFsQm91bmRJbmZvLmlzQm91bmQsXG4gICAgICBpc1NuYXA6IGhvcml6b250YWxTbmFwSW5mby5pc1NuYXAsXG4gICAgICBvZmZzZXQ6IGhvcml6b250YWxPZmZzZXQsXG4gICAgICBkaXN0OiBob3Jpem9udGFsRGlzdFxuICAgIH0sXG4gICAgdmVydGljYWw6IHtcbiAgICAgIGlzQm91bmQ6IHZlcnRpY2FsQm91bmRJbmZvLmlzQm91bmQsXG4gICAgICBpc1NuYXA6IHZlcnRpY2FsU25hcEluZm8uaXNTbmFwLFxuICAgICAgb2Zmc2V0OiB2ZXJ0aWNhbE9mZnNldCxcbiAgICAgIGRpc3Q6IHZlcnRpY2FsRGlzdFxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNoZWNrTWF4Qm91bmRzKG1vdmVhYmxlLCBwb3NlcywgZGlyZWN0aW9uLCBmaXhlZFBvc2l0aW9uLCBkYXRhcykge1xuICB2YXIgZml4ZWREaXJlY3Rpb24gPSBbLWRpcmVjdGlvblswXSwgLWRpcmVjdGlvblsxXV07XG4gIHZhciBfYSA9IG1vdmVhYmxlLnN0YXRlLFxuICAgICAgd2lkdGggPSBfYS53aWR0aCxcbiAgICAgIGhlaWdodCA9IF9hLmhlaWdodDtcbiAgdmFyIGJvdW5kcyA9IG1vdmVhYmxlLnByb3BzLmJvdW5kcztcbiAgdmFyIG1heFdpZHRoID0gSW5maW5pdHk7XG4gIHZhciBtYXhIZWlnaHQgPSBJbmZpbml0eTtcblxuICBpZiAoYm91bmRzKSB7XG4gICAgdmFyIGRpcmVjdGlvbnMgPSBbW2RpcmVjdGlvblswXSwgLWRpcmVjdGlvblsxXV0sIFstZGlyZWN0aW9uWzBdLCBkaXJlY3Rpb25bMV1dXTtcbiAgICB2YXIgX2IgPSBib3VuZHMubGVmdCxcbiAgICAgICAgbGVmdF8xID0gX2IgPT09IHZvaWQgMCA/IC1JbmZpbml0eSA6IF9iLFxuICAgICAgICBfYyA9IGJvdW5kcy50b3AsXG4gICAgICAgIHRvcF8xID0gX2MgPT09IHZvaWQgMCA/IC1JbmZpbml0eSA6IF9jLFxuICAgICAgICBfZCA9IGJvdW5kcy5yaWdodCxcbiAgICAgICAgcmlnaHRfMSA9IF9kID09PSB2b2lkIDAgPyBJbmZpbml0eSA6IF9kLFxuICAgICAgICBfZSA9IGJvdW5kcy5ib3R0b20sXG4gICAgICAgIGJvdHRvbV8xID0gX2UgPT09IHZvaWQgMCA/IEluZmluaXR5IDogX2U7XG4gICAgZGlyZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChvdGhlckRpcmVjdGlvbikge1xuICAgICAgdmFyIGlzQ2hlY2tWZXJ0aWNhbCA9IG90aGVyRGlyZWN0aW9uWzBdICE9PSBmaXhlZERpcmVjdGlvblswXTtcbiAgICAgIHZhciBpc0NoZWNrSG9yaXpvbnRhbCA9IG90aGVyRGlyZWN0aW9uWzFdICE9PSBmaXhlZERpcmVjdGlvblsxXTtcbiAgICAgIHZhciBvdGhlclBvcyA9IGdldFBvc0J5RGlyZWN0aW9uKHBvc2VzLCBvdGhlckRpcmVjdGlvbik7XG4gICAgICB2YXIgZGVnID0gZ2V0UmFkKGZpeGVkUG9zaXRpb24sIG90aGVyUG9zKSAqIDM2MCAvIE1hdGguUEk7XG5cbiAgICAgIGlmIChpc0NoZWNrSG9yaXpvbnRhbCkge1xuICAgICAgICB2YXIgbmV4dE90aGVyUG9zID0gb3RoZXJQb3Muc2xpY2UoKTtcblxuICAgICAgICBpZiAoTWF0aC5hYnMoZGVnIC0gMzYwKSA8IDIgfHwgTWF0aC5hYnMoZGVnIC0gMTgwKSA8IDIpIHtcbiAgICAgICAgICBuZXh0T3RoZXJQb3NbMV0gPSBmaXhlZFBvc2l0aW9uWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9hID0gc29sdmVOZXh0T2Zmc2V0KGZpeGVkUG9zaXRpb24sIG5leHRPdGhlclBvcywgKGZpeGVkUG9zaXRpb25bMV0gPCBvdGhlclBvc1sxXSA/IGJvdHRvbV8xIDogdG9wXzEpIC0gb3RoZXJQb3NbMV0sIGZhbHNlLCBkYXRhcyksXG4gICAgICAgICAgICBfYiA9IF9hLm9mZnNldCxcbiAgICAgICAgICAgIGhlaWdodE9mZnNldCA9IF9iWzFdLFxuICAgICAgICAgICAgaXNIZWlnaHRPdXRzaWRlID0gX2EuaXNPdXRzaWRlO1xuXG4gICAgICAgIGlmICghaXNOYU4oaGVpZ2h0T2Zmc2V0KSkge1xuICAgICAgICAgIG1heEhlaWdodCA9IGhlaWdodCArIChpc0hlaWdodE91dHNpZGUgPyAxIDogLTEpICogTWF0aC5hYnMoaGVpZ2h0T2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNDaGVja1ZlcnRpY2FsKSB7XG4gICAgICAgIHZhciBuZXh0T3RoZXJQb3MgPSBvdGhlclBvcy5zbGljZSgpO1xuXG4gICAgICAgIGlmIChNYXRoLmFicyhkZWcgLSA5MCkgPCAyIHx8IE1hdGguYWJzKGRlZyAtIDI3MCkgPCAyKSB7XG4gICAgICAgICAgbmV4dE90aGVyUG9zWzBdID0gZml4ZWRQb3NpdGlvblswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfYyA9IHNvbHZlTmV4dE9mZnNldChmaXhlZFBvc2l0aW9uLCBuZXh0T3RoZXJQb3MsIChmaXhlZFBvc2l0aW9uWzBdIDwgb3RoZXJQb3NbMF0gPyByaWdodF8xIDogbGVmdF8xKSAtIG90aGVyUG9zWzBdLCB0cnVlLCBkYXRhcyksXG4gICAgICAgICAgICB3aWR0aE9mZnNldCA9IF9jLm9mZnNldFswXSxcbiAgICAgICAgICAgIGlzV2lkdGhPdXRzaWRlID0gX2MuaXNPdXRzaWRlO1xuXG4gICAgICAgIGlmICghaXNOYU4od2lkdGhPZmZzZXQpKSB7XG4gICAgICAgICAgbWF4V2lkdGggPSB3aWR0aCArIChpc1dpZHRoT3V0c2lkZSA/IDEgOiAtMSkgKiBNYXRoLmFicyh3aWR0aE9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWF4V2lkdGg6IG1heFdpZHRoLFxuICAgIG1heEhlaWdodDogbWF4SGVpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNuYXBTdGFydChtb3ZlYWJsZSkge1xuICB2YXIgc3RhdGUgPSBtb3ZlYWJsZS5zdGF0ZTtcblxuICBpZiAoc3RhdGUuZ3VpZGVsaW5lcyAmJiBzdGF0ZS5ndWlkZWxpbmVzLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjb250YWluZXIgPSBtb3ZlYWJsZS5zdGF0ZS5jb250YWluZXI7XG4gIHZhciBzbmFwQ29udGFpbmVyID0gbW92ZWFibGUucHJvcHMuc25hcENvbnRhaW5lciB8fCBjb250YWluZXI7XG4gIHZhciBjb250YWluZXJDbGllbnRSZWN0ID0gc3RhdGUuY29udGFpbmVyQ2xpZW50UmVjdDtcbiAgdmFyIHNuYXBPZmZzZXQgPSB7XG4gICAgbGVmdDogMCxcbiAgICB0b3A6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIHJpZ2h0OiAwXG4gIH07XG5cbiAgaWYgKGNvbnRhaW5lciAhPT0gc25hcENvbnRhaW5lcikge1xuICAgIHZhciBzbmFwQ29udGFpbmVyVGFyZ2V0ID0gZ2V0UmVmVGFyZ2V0KHNuYXBDb250YWluZXIsIHRydWUpO1xuXG4gICAgaWYgKHNuYXBDb250YWluZXJUYXJnZXQpIHtcbiAgICAgIHZhciBzbmFwQ29udGFpbmVyUmVjdCA9IGdldENsaWVudFJlY3Qoc25hcENvbnRhaW5lclRhcmdldCk7XG4gICAgICB2YXIgb2Zmc2V0MSA9IGdldERyYWdEaXN0QnlTdGF0ZShzdGF0ZSwgW3NuYXBDb250YWluZXJSZWN0LmxlZnQgLSBjb250YWluZXJDbGllbnRSZWN0LmxlZnQsIHNuYXBDb250YWluZXJSZWN0LnRvcCAtIGNvbnRhaW5lckNsaWVudFJlY3QudG9wXSk7XG4gICAgICB2YXIgb2Zmc2V0MiA9IGdldERyYWdEaXN0QnlTdGF0ZShzdGF0ZSwgW3NuYXBDb250YWluZXJSZWN0LnJpZ2h0IC0gY29udGFpbmVyQ2xpZW50UmVjdC5yaWdodCwgc25hcENvbnRhaW5lclJlY3QuYm90dG9tIC0gY29udGFpbmVyQ2xpZW50UmVjdC5ib3R0b21dKTtcbiAgICAgIHNuYXBPZmZzZXQubGVmdCA9IHRocm90dGxlKG9mZnNldDFbMF0sIDAuMSk7XG4gICAgICBzbmFwT2Zmc2V0LnRvcCA9IHRocm90dGxlKG9mZnNldDFbMV0sIDAuMSk7XG4gICAgICBzbmFwT2Zmc2V0LnJpZ2h0ID0gdGhyb3R0bGUob2Zmc2V0MlswXSwgMC4xKTtcbiAgICAgIHNuYXBPZmZzZXQuYm90dG9tID0gdGhyb3R0bGUob2Zmc2V0MlsxXSwgMC4xKTtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5zbmFwT2Zmc2V0ID0gc25hcE9mZnNldDtcbiAgc3RhdGUuZ3VpZGVsaW5lcyA9IGdldFRvdGFsR3VpZGVsaW5lcyhtb3ZlYWJsZSk7XG4gIHN0YXRlLmVuYWJsZVNuYXAgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBnZXROZXh0Rml4ZWRQb3NlcyhtYXRyaXgsIHdpZHRoLCBoZWlnaHQsIGZpeGVkUG9zLCBkaXJlY3Rpb24sIGlzM2QpIHtcbiAgdmFyIG5leHRQb3NlcyA9IGNhbGN1bGF0ZVBvc2VzKG1hdHJpeCwgd2lkdGgsIGhlaWdodCwgaXMzZCA/IDQgOiAzKTtcbiAgdmFyIG5leHRQb3MgPSBnZXRQb3NCeVJldmVyc2VEaXJlY3Rpb24obmV4dFBvc2VzLCBkaXJlY3Rpb24pO1xuICByZXR1cm4gZ2V0QWJzb2x1dGVQb3NlcyhuZXh0UG9zZXMsIG1pbnVzKGZpeGVkUG9zLCBuZXh0UG9zKSk7XG59XG5mdW5jdGlvbiBnZXRTaXplT2Zmc2V0SW5mbyhtb3ZlYWJsZSwgcG9zZXMsIGRpcmVjdGlvbiwga2VlcFJhdGlvLCBpc1JlcXVlc3QsIGRhdGFzKSB7XG4gIHZhciBkaXJlY3Rpb25zID0gZ2V0Q2hlY2tTbmFwRGlyZWN0aW9ucyhkaXJlY3Rpb24sIGtlZXBSYXRpbyk7XG4gIHZhciBsaW5lcyA9IGdldENoZWNrSW5uZXJCb3VuZExpbmVzKHBvc2VzLCBkaXJlY3Rpb24sIGtlZXBSYXRpbyk7XG5cbiAgdmFyIG9mZnNldHMgPSBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIGdldFNuYXBCb3VuZEluZm8obW92ZWFibGUsIHBvc2VzLCBkaXJlY3Rpb25zLCBrZWVwUmF0aW8sIGlzUmVxdWVzdCwgZGF0YXMpKSwgZ2V0SW5uZXJCb3VuZEluZm8obW92ZWFibGUsIGxpbmVzLCBnZXRQb3NCeURpcmVjdGlvbihwb3NlcywgWzAsIDBdKSwgZGF0YXMpKTtcblxuICB2YXIgd2lkdGhPZmZzZXRJbmZvID0gZ2V0TmVhck9mZnNldEluZm8ob2Zmc2V0cywgMCk7XG4gIHZhciBoZWlnaHRPZmZzZXRJbmZvID0gZ2V0TmVhck9mZnNldEluZm8ob2Zmc2V0cywgMSk7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHtcbiAgICAgIGlzQm91bmQ6IHdpZHRoT2Zmc2V0SW5mby5pc0JvdW5kLFxuICAgICAgb2Zmc2V0OiB3aWR0aE9mZnNldEluZm8ub2Zmc2V0WzBdXG4gICAgfSxcbiAgICBoZWlnaHQ6IHtcbiAgICAgIGlzQm91bmQ6IGhlaWdodE9mZnNldEluZm8uaXNCb3VuZCxcbiAgICAgIG9mZnNldDogaGVpZ2h0T2Zmc2V0SW5mby5vZmZzZXRbMV1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiByZWNoZWNrU2l6ZUJ5VHdvRGlyZWN0aW9uKG1vdmVhYmxlLCBwb3Nlcywgd2lkdGgsIGhlaWdodCwgbWF4V2lkdGgsIG1heEhlaWdodCwgZGlyZWN0aW9uLCBpc1JlcXVlc3QsIGRhdGFzKSB7XG4gIHZhciBzbmFwUG9zID0gZ2V0UG9zQnlEaXJlY3Rpb24ocG9zZXMsIGRpcmVjdGlvbik7XG5cbiAgdmFyIF9hID0gY2hlY2tNb3ZlYWJsZVNuYXBCb3VuZHMobW92ZWFibGUsIGlzUmVxdWVzdCwge1xuICAgIHZlcnRpY2FsOiBbc25hcFBvc1swXV0sXG4gICAgaG9yaXpvbnRhbDogW3NuYXBQb3NbMV1dXG4gIH0pLFxuICAgICAgaG9yaXpvbnRhbE9mZnNldCA9IF9hLmhvcml6b250YWwub2Zmc2V0LFxuICAgICAgdmVydGljYWxPZmZzZXQgPSBfYS52ZXJ0aWNhbC5vZmZzZXQ7XG5cbiAgaWYgKHZlcnRpY2FsT2Zmc2V0IHx8IGhvcml6b250YWxPZmZzZXQpIHtcbiAgICB2YXIgX2IgPSBnZXREcmFnRGlzdCh7XG4gICAgICBkYXRhczogZGF0YXMsXG4gICAgICBkaXN0WDogLXZlcnRpY2FsT2Zmc2V0LFxuICAgICAgZGlzdFk6IC1ob3Jpem9udGFsT2Zmc2V0XG4gICAgfSksXG4gICAgICAgIG5leHRXaWR0aE9mZnNldCA9IF9iWzBdLFxuICAgICAgICBuZXh0SGVpZ2h0T2Zmc2V0ID0gX2JbMV07XG5cbiAgICB2YXIgbmV4dFdpZHRoID0gTWF0aC5taW4obWF4V2lkdGggfHwgSW5maW5pdHksIHdpZHRoICsgZGlyZWN0aW9uWzBdICogbmV4dFdpZHRoT2Zmc2V0KTtcbiAgICB2YXIgbmV4dEhlaWdodCA9IE1hdGgubWluKG1heEhlaWdodCB8fCBJbmZpbml0eSwgaGVpZ2h0ICsgZGlyZWN0aW9uWzFdICogbmV4dEhlaWdodE9mZnNldCk7XG4gICAgcmV0dXJuIFtuZXh0V2lkdGggLSB3aWR0aCwgbmV4dEhlaWdodCAtIGhlaWdodF07XG4gIH1cblxuICByZXR1cm4gWzAsIDBdO1xufVxuZnVuY3Rpb24gY2hlY2tTaXplRGlzdChtb3ZlYWJsZSwgZ2V0TmV4dFBvc2VzLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIGZpeGVkUG9zaXRpb24sIGlzUmVxdWVzdCwgZGF0YXMpIHtcbiAgdmFyIHBvc2VzID0gZ2V0QWJzb2x1dGVQb3Nlc0J5U3RhdGUobW92ZWFibGUuc3RhdGUpO1xuICB2YXIga2VlcFJhdGlvID0gbW92ZWFibGUucHJvcHMua2VlcFJhdGlvO1xuICB2YXIgd2lkdGhPZmZzZXQgPSAwO1xuICB2YXIgaGVpZ2h0T2Zmc2V0ID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDI7ICsraSkge1xuICAgIHZhciBuZXh0UG9zZXMgPSBnZXROZXh0UG9zZXMod2lkdGhPZmZzZXQsIGhlaWdodE9mZnNldCk7XG5cbiAgICB2YXIgX2EgPSBnZXRTaXplT2Zmc2V0SW5mbyhtb3ZlYWJsZSwgbmV4dFBvc2VzLCBkaXJlY3Rpb24sIGtlZXBSYXRpbywgaXNSZXF1ZXN0LCBkYXRhcyksXG4gICAgICAgIHdpZHRoT2Zmc2V0SW5mbyA9IF9hLndpZHRoLFxuICAgICAgICBoZWlnaHRPZmZzZXRJbmZvID0gX2EuaGVpZ2h0O1xuXG4gICAgdmFyIGlzV2lkdGhCb3VuZCA9IHdpZHRoT2Zmc2V0SW5mby5pc0JvdW5kO1xuICAgIHZhciBpc0hlaWdodEJvdW5kID0gaGVpZ2h0T2Zmc2V0SW5mby5pc0JvdW5kO1xuICAgIHZhciBuZXh0V2lkdGhPZmZzZXQgPSB3aWR0aE9mZnNldEluZm8ub2Zmc2V0O1xuICAgIHZhciBuZXh0SGVpZ2h0T2Zmc2V0ID0gaGVpZ2h0T2Zmc2V0SW5mby5vZmZzZXQ7XG5cbiAgICBpZiAoaSA9PT0gMSkge1xuICAgICAgaWYgKCFpc1dpZHRoQm91bmQpIHtcbiAgICAgICAgbmV4dFdpZHRoT2Zmc2V0ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0hlaWdodEJvdW5kKSB7XG4gICAgICAgIG5leHRIZWlnaHRPZmZzZXQgPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpID09PSAwICYmIGlzUmVxdWVzdCAmJiAhaXNXaWR0aEJvdW5kICYmICFpc0hlaWdodEJvdW5kKSB7XG4gICAgICByZXR1cm4gWzAsIDBdO1xuICAgIH1cblxuICAgIGlmIChrZWVwUmF0aW8pIHtcbiAgICAgIHZhciB3aWR0aERpc3QgPSBNYXRoLmFicyhuZXh0V2lkdGhPZmZzZXQpICogKHdpZHRoID8gMSAvIHdpZHRoIDogMSk7XG4gICAgICB2YXIgaGVpZ2h0RGlzdCA9IE1hdGguYWJzKG5leHRIZWlnaHRPZmZzZXQpICogKGhlaWdodCA/IDEgLyBoZWlnaHQgOiAxKTtcbiAgICAgIHZhciBpc0dldFdpZHRoT2Zmc2V0ID0gaXNXaWR0aEJvdW5kICYmIGlzSGVpZ2h0Qm91bmQgPyB3aWR0aERpc3QgPCBoZWlnaHREaXN0IDogaXNIZWlnaHRCb3VuZCB8fCAhaXNXaWR0aEJvdW5kICYmIHdpZHRoRGlzdCA8IGhlaWdodERpc3Q7XG5cbiAgICAgIGlmIChpc0dldFdpZHRoT2Zmc2V0KSB7XG4gICAgICAgIC8vIHdpZHRoIDogaGVpZ2h0ID0gPyA6IGhlaWdodE9mZnNldFxuICAgICAgICBuZXh0V2lkdGhPZmZzZXQgPSB3aWR0aCAqIG5leHRIZWlnaHRPZmZzZXQgLyBoZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB3aWR0aCA6IGhlaWdodCA9IHdpZHRoT2Zmc2V0IDogP1xuICAgICAgICBuZXh0SGVpZ2h0T2Zmc2V0ID0gaGVpZ2h0ICogbmV4dFdpZHRoT2Zmc2V0IC8gd2lkdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2lkdGhPZmZzZXQgKz0gbmV4dFdpZHRoT2Zmc2V0O1xuICAgIGhlaWdodE9mZnNldCArPSBuZXh0SGVpZ2h0T2Zmc2V0O1xuICB9XG5cbiAgaWYgKGRpcmVjdGlvblswXSAmJiBkaXJlY3Rpb25bMV0pIHtcbiAgICB2YXIgX2IgPSBjaGVja01heEJvdW5kcyhtb3ZlYWJsZSwgcG9zZXMsIGRpcmVjdGlvbiwgZml4ZWRQb3NpdGlvbiwgZGF0YXMpLFxuICAgICAgICBtYXhXaWR0aCA9IF9iLm1heFdpZHRoLFxuICAgICAgICBtYXhIZWlnaHQgPSBfYi5tYXhIZWlnaHQ7XG5cbiAgICB2YXIgX2MgPSByZWNoZWNrU2l6ZUJ5VHdvRGlyZWN0aW9uKG1vdmVhYmxlLCBnZXROZXh0UG9zZXMod2lkdGhPZmZzZXQsIGhlaWdodE9mZnNldCkubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgIHJldHVybiBwb3MubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiB0aHJvdHRsZShwLCBGTE9BVF9QT0lOVF9OVU0pO1xuICAgICAgfSk7XG4gICAgfSksIHdpZHRoICsgd2lkdGhPZmZzZXQsIGhlaWdodCArIGhlaWdodE9mZnNldCwgbWF4V2lkdGgsIG1heEhlaWdodCwgZGlyZWN0aW9uLCBpc1JlcXVlc3QsIGRhdGFzKSxcbiAgICAgICAgbmV4dFdpZHRoT2Zmc2V0ID0gX2NbMF0sXG4gICAgICAgIG5leHRIZWlnaHRPZmZzZXQgPSBfY1sxXTtcblxuICAgIHdpZHRoT2Zmc2V0ICs9IG5leHRXaWR0aE9mZnNldDtcbiAgICBoZWlnaHRPZmZzZXQgKz0gbmV4dEhlaWdodE9mZnNldDtcbiAgfVxuXG4gIHJldHVybiBbd2lkdGhPZmZzZXQsIGhlaWdodE9mZnNldF07XG59XG5mdW5jdGlvbiBjaGVja1NuYXBSb3RhdGUobW92ZWFibGUsIHJlY3QsIG9yaWdpbiwgcm90YXRpb24pIHtcbiAgaWYgKCFoYXNHdWlkZWxpbmVzKG1vdmVhYmxlLCBcInJvdGF0YWJsZVwiKSkge1xuICAgIHJldHVybiByb3RhdGlvbjtcbiAgfVxuXG4gIHZhciBwb3MxID0gcmVjdC5wb3MxLFxuICAgICAgcG9zMiA9IHJlY3QucG9zMixcbiAgICAgIHBvczMgPSByZWN0LnBvczMsXG4gICAgICBwb3M0ID0gcmVjdC5wb3M0O1xuICB2YXIgcmFkID0gcm90YXRpb24gKiBNYXRoLlBJIC8gMTgwO1xuICB2YXIgcHJldlBvc2VzID0gW3BvczEsIHBvczIsIHBvczMsIHBvczRdLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgcmV0dXJuIG1pbnVzKHBvcywgb3JpZ2luKTtcbiAgfSk7XG4gIHZhciBuZXh0UG9zZXMgPSBwcmV2UG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICByZXR1cm4gcm90YXRlKHBvcywgcmFkKTtcbiAgfSk7XG5cbiAgdmFyIHJlc3VsdCA9IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgY2hlY2tSb3RhdGVCb3VuZHMobW92ZWFibGUsIHByZXZQb3NlcywgbmV4dFBvc2VzLCBvcmlnaW4sIHJvdGF0aW9uKSksIGNoZWNrUm90YXRlSW5uZXJCb3VuZHMobW92ZWFibGUsIHByZXZQb3NlcywgbmV4dFBvc2VzLCBvcmlnaW4sIHJvdGF0aW9uKSk7XG5cbiAgcmVzdWx0LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gTWF0aC5hYnMoYSAtIHJvdGF0aW9uKSAtIE1hdGguYWJzKGIgLSByb3RhdGlvbik7XG4gIH0pO1xuXG4gIGlmIChyZXN1bHQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlc3VsdFswXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcm90YXRpb247XG4gIH1cbn1cbmZ1bmN0aW9uIGNoZWNrU25hcFJlc2l6ZShtb3ZlYWJsZSwgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBmaXhlZFBvc2l0aW9uLCBpc1JlcXVlc3QsIGRhdGFzKSB7XG4gIGlmICghaGFzR3VpZGVsaW5lcyhtb3ZlYWJsZSwgXCJyZXNpemFibGVcIikpIHtcbiAgICByZXR1cm4gWzAsIDBdO1xuICB9XG5cbiAgdmFyIF9hID0gbW92ZWFibGUuc3RhdGUsXG4gICAgICBhbGxNYXRyaXggPSBfYS5hbGxNYXRyaXgsXG4gICAgICBpczNkID0gX2EuaXMzZDtcbiAgcmV0dXJuIGNoZWNrU2l6ZURpc3QobW92ZWFibGUsIGZ1bmN0aW9uICh3aWR0aE9mZnNldCwgaGVpZ2h0T2Zmc2V0KSB7XG4gICAgcmV0dXJuIGdldE5leHRGaXhlZFBvc2VzKGFsbE1hdHJpeCwgd2lkdGggKyB3aWR0aE9mZnNldCwgaGVpZ2h0ICsgaGVpZ2h0T2Zmc2V0LCBmaXhlZFBvc2l0aW9uLCBkaXJlY3Rpb24sIGlzM2QpO1xuICB9LCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIGZpeGVkUG9zaXRpb24sIGlzUmVxdWVzdCwgZGF0YXMpO1xufVxuZnVuY3Rpb24gY2hlY2tTbmFwU2NhbGUobW92ZWFibGUsIHNjYWxlLCBkaXJlY3Rpb24sIGlzUmVxdWVzdCwgZGF0YXMpIHtcbiAgdmFyIHdpZHRoID0gZGF0YXMud2lkdGgsXG4gICAgICBoZWlnaHQgPSBkYXRhcy5oZWlnaHQsXG4gICAgICBmaXhlZFBvc2l0aW9uID0gZGF0YXMuZml4ZWRQb3NpdGlvbjtcblxuICBpZiAoIWhhc0d1aWRlbGluZXMobW92ZWFibGUsIFwic2NhbGFibGVcIikpIHtcbiAgICByZXR1cm4gWzAsIDBdO1xuICB9XG5cbiAgdmFyIGlzM2QgPSBkYXRhcy5pczNkO1xuICB2YXIgc2l6ZURpc3QgPSBjaGVja1NpemVEaXN0KG1vdmVhYmxlLCBmdW5jdGlvbiAod2lkdGhPZmZzZXQsIGhlaWdodE9mZnNldCkge1xuICAgIHJldHVybiBnZXROZXh0Rml4ZWRQb3NlcyhzY2FsZU1hdHJpeChkYXRhcywgcGx1cyhzY2FsZSwgW3dpZHRoT2Zmc2V0IC8gd2lkdGgsIGhlaWdodE9mZnNldCAvIGhlaWdodF0pKSwgd2lkdGgsIGhlaWdodCwgZml4ZWRQb3NpdGlvbiwgZGlyZWN0aW9uLCBpczNkKTtcbiAgfSwgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBmaXhlZFBvc2l0aW9uLCBpc1JlcXVlc3QsIGRhdGFzKTtcbiAgcmV0dXJuIFtzaXplRGlzdFswXSAvIHdpZHRoLCBzaXplRGlzdFsxXSAvIGhlaWdodF07XG59XG5mdW5jdGlvbiBzdGFydENoZWNrU25hcERyYWcobW92ZWFibGUsIGRhdGFzKSB7XG4gIGRhdGFzLmFic29sdXRlUG9zZXMgPSBnZXRBYnNvbHV0ZVBvc2VzQnlTdGF0ZShtb3ZlYWJsZS5zdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGdldFNuYXBHdWlkZWxpbmVzKHBvc0luZm9zKSB7XG4gIHZhciBndWlkZWxpbmVzID0gW107XG4gIHBvc0luZm9zLmZvckVhY2goZnVuY3Rpb24gKHBvc0luZm8pIHtcbiAgICBwb3NJbmZvLmd1aWRlbGluZUluZm9zLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICB2YXIgZ3VpZGVsaW5lID0gX2EuZ3VpZGVsaW5lO1xuXG4gICAgICBpZiAoZ3VpZGVsaW5lcy5pbmRleE9mKGd1aWRlbGluZSkgPiAtMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGd1aWRlbGluZXMucHVzaChndWlkZWxpbmUpO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGd1aWRlbGluZXM7XG59XG5cbmZ1bmN0aW9uIGFkZEJvdW5kR3VpZGVsaW5lcyhtb3ZlYWJsZSwgdmVydGljYWxQb3NlcywgaG9yaXpvbnRhbFBvc2VzLCB2ZXJ0aWNhbFNuYXBQb3NlcywgaG9yaXpvbnRhbFNuYXBQb3NlcywgZXh0ZXJuYWxCb3VuZHMpIHtcbiAgdmFyIF9hID0gY2hlY2tCb3VuZFBvc2VzKGdldEJvdW5kcyhtb3ZlYWJsZSwgZXh0ZXJuYWxCb3VuZHMpLCB2ZXJ0aWNhbFBvc2VzLCBob3Jpem9udGFsUG9zZXMpLFxuICAgICAgdmVydGljYWxCb3VuZEluZm9zID0gX2EudmVydGljYWwsXG4gICAgICBob3Jpem9udGFsQm91bmRJbmZvcyA9IF9hLmhvcml6b250YWw7XG5cbiAgdmVydGljYWxCb3VuZEluZm9zLmZvckVhY2goZnVuY3Rpb24gKGluZm8pIHtcbiAgICBpZiAoaW5mby5pc0JvdW5kKSB7XG4gICAgICB2ZXJ0aWNhbFNuYXBQb3Nlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJib3VuZHNcIixcbiAgICAgICAgcG9zOiBpbmZvLnBvc1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgaG9yaXpvbnRhbEJvdW5kSW5mb3MuZm9yRWFjaChmdW5jdGlvbiAoaW5mbykge1xuICAgIGlmIChpbmZvLmlzQm91bmQpIHtcbiAgICAgIGhvcml6b250YWxTbmFwUG9zZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwiYm91bmRzXCIsXG4gICAgICAgIHBvczogaW5mby5wb3NcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIF9iID0gY2hlY2tJbm5lckJvdW5kUG9zZXMobW92ZWFibGUpLFxuICAgICAgdmVydGljYWxJbm5lckJvdW5kUG9zZXMgPSBfYi52ZXJ0aWNhbCxcbiAgICAgIGhvcml6b250YWxJbm5lckJvdW5kUG9zZXMgPSBfYi5ob3Jpem9udGFsO1xuXG4gIHZlcnRpY2FsSW5uZXJCb3VuZFBvc2VzLmZvckVhY2goZnVuY3Rpb24gKGlubmVyUG9zKSB7XG4gICAgaWYgKGZpbmRJbmRleCh2ZXJ0aWNhbFNuYXBQb3NlcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICB2YXIgdHlwZSA9IF9hLnR5cGUsXG4gICAgICAgICAgcG9zID0gX2EucG9zO1xuICAgICAgcmV0dXJuIHR5cGUgPT09IFwiYm91bmRzXCIgJiYgcG9zID09PSBpbm5lclBvcztcbiAgICB9KSA+PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmVydGljYWxTbmFwUG9zZXMucHVzaCh7XG4gICAgICB0eXBlOiBcImJvdW5kc1wiLFxuICAgICAgcG9zOiBpbm5lclBvc1xuICAgIH0pO1xuICB9KTtcbiAgaG9yaXpvbnRhbElubmVyQm91bmRQb3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbm5lclBvcykge1xuICAgIGlmIChmaW5kSW5kZXgoaG9yaXpvbnRhbFNuYXBQb3NlcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICB2YXIgdHlwZSA9IF9hLnR5cGUsXG4gICAgICAgICAgcG9zID0gX2EucG9zO1xuICAgICAgcmV0dXJuIHR5cGUgPT09IFwiYm91bmRzXCIgJiYgcG9zID09PSBpbm5lclBvcztcbiAgICB9KSA+PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaG9yaXpvbnRhbFNuYXBQb3Nlcy5wdXNoKHtcbiAgICAgIHR5cGU6IFwiYm91bmRzXCIsXG4gICAgICBwb3M6IGlubmVyUG9zXG4gICAgfSk7XG4gIH0pO1xufVxuLyoqXG4gKiBAbmFtZXNwYWNlIE1vdmVhYmxlLlNuYXBwYWJsZVxuICogQGRlc2NyaXB0aW9uIFdoZXRoZXIgb3Igbm90IHRhcmdldCBjYW4gYmUgc25hcHBlZCB0byB0aGUgZ3VpZGVsaW5lLiAoZGVmYXVsdDogZmFsc2UpXG4gKiBAc29ydCAyXG4gKi9cblxuXG52YXIgU25hcHBhYmxlID0ge1xuICBuYW1lOiBcInNuYXBwYWJsZVwiLFxuICBkcmFnUmVsYXRpb246IFwic3Ryb25nXCIsXG4gIHByb3BzOiB7XG4gICAgc25hcHBhYmxlOiBbQm9vbGVhbiwgQXJyYXldLFxuICAgIHNuYXBDb250YWluZXI6IE9iamVjdCxcbiAgICBzbmFwRGlyZWN0aW9uczogW0Jvb2xlYW4sIE9iamVjdF0sXG4gICAgZWxlbWVudFNuYXBEaXJlY3Rpb25zOiBbQm9vbGVhbiwgT2JqZWN0XSxcbiAgICBzbmFwR2FwOiBCb29sZWFuLFxuICAgIHNuYXBHcmlkV2lkdGg6IE51bWJlcixcbiAgICBzbmFwR3JpZEhlaWdodDogTnVtYmVyLFxuICAgIGlzRGlzcGxheVNuYXBEaWdpdDogQm9vbGVhbixcbiAgICBpc0Rpc3BsYXlJbm5lclNuYXBEaWdpdDogQm9vbGVhbixcbiAgICBzbmFwRGlnaXQ6IE51bWJlcixcbiAgICBzbmFwVGhyZXNob2xkOiBOdW1iZXIsXG4gICAgaG9yaXpvbnRhbEd1aWRlbGluZXM6IEFycmF5LFxuICAgIHZlcnRpY2FsR3VpZGVsaW5lczogQXJyYXksXG4gICAgZWxlbWVudEd1aWRlbGluZXM6IEFycmF5LFxuICAgIGJvdW5kczogT2JqZWN0LFxuICAgIGlubmVyQm91bmRzOiBPYmplY3QsXG4gICAgc25hcERpc3RGb3JtYXQ6IEZ1bmN0aW9uXG4gIH0sXG4gIGV2ZW50czoge1xuICAgIG9uU25hcDogXCJzbmFwXCJcbiAgfSxcbiAgY3NzOiBbXCI6aG9zdCB7XFxuICAgIC0tYm91bmRzLWNvbG9yOiAjZDY2O1xcbn1cXG4uZ3VpZGVsaW5lIHtcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuICAgIHotaW5kZXg6IDI7XFxufVxcbi5ndWlkZWxpbmUuYm91bmRzIHtcXG4gICAgYmFja2dyb3VuZDogI2Q2NjtcXG4gICAgYmFja2dyb3VuZDogdmFyKC0tYm91bmRzLWNvbG9yKTtcXG59XFxuLmd1aWRlbGluZS1ncm91cCB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiAwO1xcbiAgICBsZWZ0OiAwO1xcbn1cXG4uZ3VpZGVsaW5lLWdyb3VwIC5zaXplLXZhbHVlIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBjb2xvcjogI2Y1NTtcXG4gICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICBmb250LXdlaWdodDogYm9sZDtcXG59XFxuLmd1aWRlbGluZS1ncm91cC5ob3Jpem9udGFsIC5zaXplLXZhbHVlIHtcXG4gICAgdHJhbnNmb3JtLW9yaWdpbjogNTAlIDEwMCU7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKTtcXG4gICAgbGVmdDogNTAlO1xcbiAgICBib3R0b206IDVweDtcXG59XFxuLmd1aWRlbGluZS1ncm91cC52ZXJ0aWNhbCAuc2l6ZS12YWx1ZSB7XFxuICAgIHRyYW5zZm9ybS1vcmlnaW46IDAlIDUwJTtcXG4gICAgdG9wOiA1MCU7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNTAlKTtcXG4gICAgbGVmdDogNXB4O1xcbn1cXG4uZ3VpZGVsaW5lLmdhcCB7XFxuICAgIGJhY2tncm91bmQ6ICNmNTU7XFxufVxcbi5zaXplLXZhbHVlLmdhcCB7XFxuICAgIGNvbG9yOiAjZjU1O1xcbn1cXG5cIl0sXG4gIHJlbmRlcjogZnVuY3Rpb24gKG1vdmVhYmxlLCBSZWFjdCkge1xuICAgIHZhciBzdGF0ZSA9IG1vdmVhYmxlLnN0YXRlO1xuICAgIHZhciB0YXJnZXRUb3AgPSBzdGF0ZS50b3AsXG4gICAgICAgIHRhcmdldExlZnQgPSBzdGF0ZS5sZWZ0LFxuICAgICAgICBwb3MxID0gc3RhdGUucG9zMSxcbiAgICAgICAgcG9zMiA9IHN0YXRlLnBvczIsXG4gICAgICAgIHBvczMgPSBzdGF0ZS5wb3MzLFxuICAgICAgICBwb3M0ID0gc3RhdGUucG9zNCxcbiAgICAgICAgc25hcFJlbmRlckluZm8gPSBzdGF0ZS5zbmFwUmVuZGVySW5mbztcblxuICAgIGlmICghc25hcFJlbmRlckluZm8gfHwgIWhhc0d1aWRlbGluZXMobW92ZWFibGUsIFwiXCIpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgc3RhdGUuZ3VpZGVsaW5lcyA9IGdldFRvdGFsR3VpZGVsaW5lcyhtb3ZlYWJsZSk7XG4gICAgdmFyIG1pbkxlZnQgPSBNYXRoLm1pbihwb3MxWzBdLCBwb3MyWzBdLCBwb3MzWzBdLCBwb3M0WzBdKTtcbiAgICB2YXIgbWluVG9wID0gTWF0aC5taW4ocG9zMVsxXSwgcG9zMlsxXSwgcG9zM1sxXSwgcG9zNFsxXSk7XG4gICAgdmFyIGV4dGVybmFsUG9zZXMgPSBzbmFwUmVuZGVySW5mby5leHRlcm5hbFBvc2VzIHx8IFtdO1xuICAgIHZhciBwb3NlcyA9IGdldEFic29sdXRlUG9zZXNCeVN0YXRlKG1vdmVhYmxlLnN0YXRlKTtcbiAgICB2YXIgdmVydGljYWxTbmFwUG9zZXMgPSBbXTtcbiAgICB2YXIgaG9yaXpvbnRhbFNuYXBQb3NlcyA9IFtdO1xuICAgIHZhciB2ZXJ0aWNhbEd1aWRlbGluZXMgPSBbXTtcbiAgICB2YXIgaG9yaXpvbnRhbEd1aWRlbGluZXMgPSBbXTtcbiAgICB2YXIgc25hcEluZm9zID0gW107XG5cbiAgICB2YXIgX2EgPSBnZXRSZWN0KHBvc2VzKSxcbiAgICAgICAgd2lkdGggPSBfYS53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX2EuaGVpZ2h0LFxuICAgICAgICB0b3AgPSBfYS50b3AsXG4gICAgICAgIGxlZnQgPSBfYS5sZWZ0LFxuICAgICAgICBib3R0b20gPSBfYS5ib3R0b20sXG4gICAgICAgIHJpZ2h0ID0gX2EucmlnaHQ7XG5cbiAgICB2YXIgdGFyZ2V0UmVjdCA9IHtcbiAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICByaWdodDogcmlnaHQsXG4gICAgICB0b3A6IHRvcCxcbiAgICAgIGJvdHRvbTogYm90dG9tLFxuICAgICAgY2VudGVyOiAobGVmdCArIHJpZ2h0KSAvIDIsXG4gICAgICBtaWRkbGU6ICh0b3AgKyBib3R0b20pIC8gMlxuICAgIH07XG4gICAgdmFyIGhhc0V4dGVybmFsUG9zZXMgPSBleHRlcm5hbFBvc2VzLmxlbmd0aCA+IDA7XG4gICAgdmFyIGV4dGVybmFsUmVjdCA9IGhhc0V4dGVybmFsUG9zZXMgPyBnZXRSZWN0KGV4dGVybmFsUG9zZXMpIDoge307XG5cbiAgICBpZiAoIXNuYXBSZW5kZXJJbmZvLnJlcXVlc3QpIHtcbiAgICAgIGlmIChzbmFwUmVuZGVySW5mby5kaXJlY3Rpb24pIHtcbiAgICAgICAgc25hcEluZm9zLnB1c2goZ2V0U25hcEluZm9zQnlEaXJlY3Rpb24obW92ZWFibGUsIHBvc2VzLCBzbmFwUmVuZGVySW5mby5kaXJlY3Rpb24pKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNuYXBSZW5kZXJJbmZvLnNuYXApIHtcbiAgICAgICAgdmFyIHJlY3QgPSBnZXRSZWN0KHBvc2VzKTtcblxuICAgICAgICBpZiAoc25hcFJlbmRlckluZm8uY2VudGVyKSB7XG4gICAgICAgICAgcmVjdC5taWRkbGUgPSAocmVjdC50b3AgKyByZWN0LmJvdHRvbSkgLyAyO1xuICAgICAgICAgIHJlY3QuY2VudGVyID0gKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNuYXBJbmZvcy5wdXNoKGNoZWNrU25hcHMobW92ZWFibGUsIHJlY3QsIDEpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc0V4dGVybmFsUG9zZXMpIHtcbiAgICAgICAgaWYgKHNuYXBSZW5kZXJJbmZvLmNlbnRlcikge1xuICAgICAgICAgIGV4dGVybmFsUmVjdC5taWRkbGUgPSAoZXh0ZXJuYWxSZWN0LnRvcCArIGV4dGVybmFsUmVjdC5ib3R0b20pIC8gMjtcbiAgICAgICAgICBleHRlcm5hbFJlY3QuY2VudGVyID0gKGV4dGVybmFsUmVjdC5sZWZ0ICsgZXh0ZXJuYWxSZWN0LnJpZ2h0KSAvIDI7XG4gICAgICAgIH1cblxuICAgICAgICBzbmFwSW5mb3MucHVzaChjaGVja1NuYXBzKG1vdmVhYmxlLCBleHRlcm5hbFJlY3QsIDEpKTtcbiAgICAgIH1cblxuICAgICAgc25hcEluZm9zLmZvckVhY2goZnVuY3Rpb24gKHNuYXBJbmZvKSB7XG4gICAgICAgIHZhciB2ZXJ0aWNhbFBvc0luZm9zID0gc25hcEluZm8udmVydGljYWwucG9zSW5mb3MsXG4gICAgICAgICAgICBob3Jpem9udGFsUG9zSW5mb3MgPSBzbmFwSW5mby5ob3Jpem9udGFsLnBvc0luZm9zO1xuICAgICAgICB2ZXJ0aWNhbFNuYXBQb3Nlcy5wdXNoLmFwcGx5KHZlcnRpY2FsU25hcFBvc2VzLCB2ZXJ0aWNhbFBvc0luZm9zLmZpbHRlcihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICB2YXIgZ3VpZGVsaW5lSW5mb3MgPSBfYS5ndWlkZWxpbmVJbmZvcztcbiAgICAgICAgICByZXR1cm4gZ3VpZGVsaW5lSW5mb3Muc29tZShmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBndWlkZWxpbmUgPSBfYS5ndWlkZWxpbmU7XG4gICAgICAgICAgICByZXR1cm4gIWd1aWRlbGluZS5oaWRlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KS5tYXAoZnVuY3Rpb24gKHBvc0luZm8pIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJzbmFwXCIsXG4gICAgICAgICAgICBwb3M6IHBvc0luZm8ucG9zXG4gICAgICAgICAgfTtcbiAgICAgICAgfSkpO1xuICAgICAgICBob3Jpem9udGFsU25hcFBvc2VzLnB1c2guYXBwbHkoaG9yaXpvbnRhbFNuYXBQb3NlcywgaG9yaXpvbnRhbFBvc0luZm9zLmZpbHRlcihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICB2YXIgZ3VpZGVsaW5lSW5mb3MgPSBfYS5ndWlkZWxpbmVJbmZvcztcbiAgICAgICAgICByZXR1cm4gZ3VpZGVsaW5lSW5mb3Muc29tZShmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBndWlkZWxpbmUgPSBfYS5ndWlkZWxpbmU7XG4gICAgICAgICAgICByZXR1cm4gIWd1aWRlbGluZS5oaWRlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KS5tYXAoZnVuY3Rpb24gKHBvc0luZm8pIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJzbmFwXCIsXG4gICAgICAgICAgICBwb3M6IHBvc0luZm8ucG9zXG4gICAgICAgICAgfTtcbiAgICAgICAgfSkpO1xuICAgICAgICB2ZXJ0aWNhbEd1aWRlbGluZXMucHVzaC5hcHBseSh2ZXJ0aWNhbEd1aWRlbGluZXMsIGdldFNuYXBHdWlkZWxpbmVzKHZlcnRpY2FsUG9zSW5mb3MpKTtcbiAgICAgICAgaG9yaXpvbnRhbEd1aWRlbGluZXMucHVzaC5hcHBseShob3Jpem9udGFsR3VpZGVsaW5lcywgZ2V0U25hcEd1aWRlbGluZXMoaG9yaXpvbnRhbFBvc0luZm9zKSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBhZGRCb3VuZEd1aWRlbGluZXMobW92ZWFibGUsIFtsZWZ0LCByaWdodF0sIFt0b3AsIGJvdHRvbV0sIHZlcnRpY2FsU25hcFBvc2VzLCBob3Jpem9udGFsU25hcFBvc2VzKTtcblxuICAgIGlmIChoYXNFeHRlcm5hbFBvc2VzKSB7XG4gICAgICBhZGRCb3VuZEd1aWRlbGluZXMobW92ZWFibGUsIFtleHRlcm5hbFJlY3QubGVmdCwgZXh0ZXJuYWxSZWN0LnJpZ2h0XSwgW2V4dGVybmFsUmVjdC50b3AsIGV4dGVybmFsUmVjdC5ib3R0b21dLCB2ZXJ0aWNhbFNuYXBQb3NlcywgaG9yaXpvbnRhbFNuYXBQb3Nlcywgc25hcFJlbmRlckluZm8uZXh0ZXJuYWxCb3VuZHMpO1xuICAgIH1cblxuICAgIHZhciBhbGxHdWlkZWxpbmVzID0gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCB2ZXJ0aWNhbEd1aWRlbGluZXMpLCBob3Jpem9udGFsR3VpZGVsaW5lcyk7XG5cbiAgICB2YXIgZWxlbWVudEd1aWRlbGluZXMgPSBhbGxHdWlkZWxpbmVzLmZpbHRlcihmdW5jdGlvbiAoZ3VpZGVsaW5lKSB7XG4gICAgICByZXR1cm4gZ3VpZGVsaW5lLmVsZW1lbnQgJiYgIWd1aWRlbGluZS5nYXBSZWN0cztcbiAgICB9KTtcbiAgICB2YXIgZ2FwR3VpZGVsaW5lcyA9IGFsbEd1aWRlbGluZXMuZmlsdGVyKGZ1bmN0aW9uIChndWlkZWxpbmUpIHtcbiAgICAgIHJldHVybiBndWlkZWxpbmUuZ2FwUmVjdHM7XG4gICAgfSk7XG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uU25hcFwiLCB7XG4gICAgICBndWlkZWxpbmVzOiBhbGxHdWlkZWxpbmVzLmZpbHRlcihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBfYS5lbGVtZW50O1xuICAgICAgICByZXR1cm4gIWVsZW1lbnQ7XG4gICAgICB9KSxcbiAgICAgIGVsZW1lbnRzOiBlbGVtZW50R3VpZGVsaW5lcyxcbiAgICAgIGdhcHM6IGdhcEd1aWRlbGluZXNcbiAgICB9LCB0cnVlKTtcbiAgICByZXR1cm4gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIHJlbmRlckRhc2hlZEd1aWRlbGluZXMobW92ZWFibGUsIGVsZW1lbnRHdWlkZWxpbmVzLCBbbWluTGVmdCwgbWluVG9wXSwgdGFyZ2V0UmVjdCwgUmVhY3QpKSwgcmVuZGVyR2FwR3VpZGVsaW5lcyhtb3ZlYWJsZSwgZ2FwR3VpZGVsaW5lcywgW21pbkxlZnQsIG1pblRvcF0sIHRhcmdldFJlY3QsIFJlYWN0KSksIHJlbmRlckd1aWRlbGluZXMobW92ZWFibGUsIFwiaG9yaXpvbnRhbFwiLCBob3Jpem9udGFsR3VpZGVsaW5lcywgW3RhcmdldExlZnQsIHRhcmdldFRvcF0sIHRhcmdldFJlY3QsIFJlYWN0KSksIHJlbmRlckd1aWRlbGluZXMobW92ZWFibGUsIFwidmVydGljYWxcIiwgdmVydGljYWxHdWlkZWxpbmVzLCBbdGFyZ2V0TGVmdCwgdGFyZ2V0VG9wXSwgdGFyZ2V0UmVjdCwgUmVhY3QpKSwgcmVuZGVyU25hcFBvc2VzKG1vdmVhYmxlLCBcImhvcml6b250YWxcIiwgaG9yaXpvbnRhbFNuYXBQb3NlcywgbWluTGVmdCwgdGFyZ2V0VG9wLCB3aWR0aCwgMCwgUmVhY3QpKSwgcmVuZGVyU25hcFBvc2VzKG1vdmVhYmxlLCBcInZlcnRpY2FsXCIsIHZlcnRpY2FsU25hcFBvc2VzLCBtaW5Ub3AsIHRhcmdldExlZnQsIGhlaWdodCwgMSwgUmVhY3QpKTtcbiAgfSxcbiAgZHJhZ1N0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICBtb3ZlYWJsZS5zdGF0ZS5zbmFwUmVuZGVySW5mbyA9IHtcbiAgICAgIHJlcXVlc3Q6IGUuaXNSZXF1ZXN0LFxuICAgICAgc25hcDogdHJ1ZSxcbiAgICAgIGNlbnRlcjogdHJ1ZVxuICAgIH07XG4gICAgc25hcFN0YXJ0KG1vdmVhYmxlKTtcbiAgfSxcbiAgZHJhZzogZnVuY3Rpb24gKG1vdmVhYmxlKSB7XG4gICAgdmFyIHN0YXRlID0gbW92ZWFibGUuc3RhdGU7XG4gICAgc3RhdGUuZ3VpZGVsaW5lcyA9IGdldFRvdGFsR3VpZGVsaW5lcyhtb3ZlYWJsZSk7XG4gIH0sXG4gIHBpbmNoU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xuICAgIHRoaXMudW5zZXQobW92ZWFibGUpO1xuICB9LFxuICBkcmFnRW5kOiBmdW5jdGlvbiAobW92ZWFibGUpIHtcbiAgICB0aGlzLnVuc2V0KG1vdmVhYmxlKTtcbiAgfSxcbiAgZHJhZ0NvbnRyb2xDb25kaXRpb246IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIGlmIChkaXJlY3Rpb25Db25kaXRpb24obW92ZWFibGUsIGUpIHx8IGRyYWdDb250cm9sQ29uZGl0aW9uKG1vdmVhYmxlLCBlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCFlLmlzUmVxdWVzdCAmJiBlLmlucHV0RXZlbnQpIHtcbiAgICAgIHJldHVybiBoYXNDbGFzcyhlLmlucHV0RXZlbnQudGFyZ2V0LCBwcmVmaXgoXCJzbmFwLWNvbnRyb2xcIikpO1xuICAgIH1cbiAgfSxcbiAgZHJhZ0NvbnRyb2xTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlKSB7XG4gICAgbW92ZWFibGUuc3RhdGUuc25hcFJlbmRlckluZm8gPSBudWxsO1xuICAgIHNuYXBTdGFydChtb3ZlYWJsZSk7XG4gIH0sXG4gIGRyYWdDb250cm9sOiBmdW5jdGlvbiAobW92ZWFibGUpIHtcbiAgICB0aGlzLmRyYWcobW92ZWFibGUpO1xuICB9LFxuICBkcmFnQ29udHJvbEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlKSB7XG4gICAgdGhpcy51bnNldChtb3ZlYWJsZSk7XG4gIH0sXG4gIGRyYWdHcm91cFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB0aGlzLmRyYWdTdGFydChtb3ZlYWJsZSwgZSk7XG4gIH0sXG4gIGRyYWdHcm91cDogZnVuY3Rpb24gKG1vdmVhYmxlKSB7XG4gICAgdGhpcy5kcmFnKG1vdmVhYmxlKTtcbiAgfSxcbiAgZHJhZ0dyb3VwRW5kOiBmdW5jdGlvbiAobW92ZWFibGUpIHtcbiAgICB0aGlzLnVuc2V0KG1vdmVhYmxlKTtcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUpIHtcbiAgICBtb3ZlYWJsZS5zdGF0ZS5zbmFwUmVuZGVySW5mbyA9IG51bGw7XG4gICAgc25hcFN0YXJ0KG1vdmVhYmxlKTtcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbDogZnVuY3Rpb24gKG1vdmVhYmxlKSB7XG4gICAgdGhpcy5kcmFnKG1vdmVhYmxlKTtcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlKSB7XG4gICAgdGhpcy51bnNldChtb3ZlYWJsZSk7XG4gIH0sXG4gIHVuc2V0OiBmdW5jdGlvbiAobW92ZWFibGUpIHtcbiAgICB2YXIgc3RhdGUgPSBtb3ZlYWJsZS5zdGF0ZTtcbiAgICBzdGF0ZS5lbmFibGVTbmFwID0gZmFsc2U7XG4gICAgc3RhdGUuZ3VpZGVsaW5lcyA9IFtdO1xuICAgIHN0YXRlLnNuYXBSZW5kZXJJbmZvID0gbnVsbDtcbiAgICBzdGF0ZS5lbGVtZW50UmVjdHMgPSBbXTtcbiAgfVxufTtcbi8qKlxuICogV2hldGhlciBvciBub3QgdGFyZ2V0IGNhbiBiZSBzbmFwcGVkIHRvIHRoZSBndWlkZWxpbmUuIChkZWZhdWx0OiBmYWxzZSlcbiAqIEBuYW1lIE1vdmVhYmxlLlNuYXBwYWJsZSNzbmFwcGFibGVcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGF5YnJ1c2guY29tL21vdmVhYmxlL3JlbGVhc2UvbGF0ZXN0L2RvYy9Nb3ZlYWJsZS5TbmFwcGFibGUuaHRtbCMuU25hcHBhYmxlT3B0aW9uc31cbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XG4gKlxuICogbW92ZWFibGUuc25hcHBhYmxlID0gdHJ1ZTtcbiAqL1xuXG4vKipcbiAqICBBIHNuYXAgY29udGFpbmVyIHRoYXQgaXMgdGhlIGJhc2lzIGZvciBzbmFwLCBib3VuZHMsIGFuZCBpbm5lckJvdW5kcy4gKGRlZmF1bHQ6IG51bGwgPSBjb250YWluZXIpXG4gKiBAbmFtZSBNb3ZlYWJsZS5TbmFwcGFibGUjc25hcENvbnRhaW5lclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kYXlicnVzaC5jb20vbW92ZWFibGUvcmVsZWFzZS9sYXRlc3QvZG9jL01vdmVhYmxlLlNuYXBwYWJsZS5odG1sIy5TbmFwcGFibGVPcHRpb25zfVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLmNvbnRhaW5lclwiKSk7XG4gKlxuICogbW92ZWFibGUuc25hcENvbnRhaW5lciA9IGRvY3VtZW50LmJvZHk7XG4gKi9cblxuLyoqXG4gKiBZb3UgY2FuIHNwZWNpZnkgdGhlIGRpcmVjdGlvbnMgdG8gc25hcCB0byB0aGUgdGFyZ2V0LiAoZGVmYXVsdDogeyBsZWZ0OiB0cnVlLCB0b3A6IHRydWUsIHJpZ2h0OiB0cnVlLCBib3R0b206IHRydWUgfSlcbiAqIEBuYW1lIE1vdmVhYmxlLlNuYXBwYWJsZSNzbmFwRGlyZWN0aW9uc1xuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kYXlicnVzaC5jb20vbW92ZWFibGUvcmVsZWFzZS9sYXRlc3QvZG9jL01vdmVhYmxlLlNuYXBwYWJsZS5odG1sIy5TbmFwcGFibGVPcHRpb25zfVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgIHNuYXBwYWJsZTogdHJ1ZSxcbiAqICAgc25hcERpcmVjdGlvbnM6IHRydWUsXG4gKiB9KTtcbiAqIC8vIHNuYXAgY2VudGVyXG4gKiBtb3ZlYWJsZS5zbmFwRGlyZWN0aW9ucyA9IHsgbGVmdDogdHJ1ZSwgdG9wOiB0cnVlLCByaWdodDogdHJ1ZSwgYm90dG9tOiB0cnVlLCBjZW50ZXI6IHRydWUsIG1pZGRsZTogdHJ1ZSB9O1xuICovXG5cbi8qKlxuICogWW91IGNhbiBzcGVjaWZ5IHRoZSBzbmFwIGRpcmVjdGlvbnMgb2YgZWxlbWVudHMuIChkZWZhdWx0OiB7IGxlZnQ6IHRydWUsIHRvcDogdHJ1ZSwgcmlnaHQ6IHRydWUsIGJvdHRvbTogdHJ1ZSB9KVxuICogQG5hbWUgTW92ZWFibGUuU25hcHBhYmxlI2VsZW1lbnRTbmFwRGlyZWN0aW9uc1xuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kYXlicnVzaC5jb20vbW92ZWFibGUvcmVsZWFzZS9sYXRlc3QvZG9jL01vdmVhYmxlLlNuYXBwYWJsZS5odG1sIy5TbmFwcGFibGVPcHRpb25zfVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgIHNuYXBwYWJsZTogdHJ1ZSxcbiAqICAgZWxlbWVudFNuYXBEaXJlY3Rpb25zOiB0cnVlLFxuICogfSk7XG4gKiAvLyBzbmFwIGNlbnRlclxuICogbW92ZWFibGUuZWxlbWVudFNuYXBEaXJlY3Rpb25zID0geyBsZWZ0OiB0cnVlLCB0b3A6IHRydWUsIHJpZ2h0OiB0cnVlLCBib3R0b206IHRydWUsIGNlbnRlcjogdHJ1ZSwgbWlkZGxlOiB0cnVlIH07XG4gKi9cblxuLyoqXG4gKiBXaGVuIHlvdSBkcmFnLCBtYWtlIHRoZSBnYXAgc25hcCBpbiB0aGUgZWxlbWVudCBndWlkZWxpbmVzLiAoZGVmYXVsdDogdHJ1ZSlcbiAqIEBuYW1lIE1vdmVhYmxlLlNuYXBwYWJsZSNzbmFwR2FwXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RheWJydXNoLmNvbS9tb3ZlYWJsZS9yZWxlYXNlL2xhdGVzdC9kb2MvTW92ZWFibGUuU25hcHBhYmxlLmh0bWwjLlNuYXBwYWJsZU9wdGlvbnN9XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgc25hcHBhYmxlOiB0cnVlLFxuICogICBzbmFwVmVydGljYWw6IHRydWUsXG4gKiAgIHNuYXBIb3Jpem9udGFsOiB0cnVlLFxuICogICBzbmFwRWxlbWVudDogdHJ1ZSxcbiAqICAgc25hcEdhcDogdHJ1ZSxcbiAqIH0pO1xuICpcbiAqIG1vdmVhYmxlLnNuYXBHYXAgPSBmYWxzZTtcbiAqL1xuXG4vKipcbiAqIERpc3RhbmNlIHZhbHVlIHRoYXQgY2FuIHNuYXAgdG8gZ3VpZGVsaW5lcy4gKGRlZmF1bHQ6IDUpXG4gKiBAbmFtZSBNb3ZlYWJsZS5TbmFwcGFibGUjc25hcFRocmVzaG9sZFxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kYXlicnVzaC5jb20vbW92ZWFibGUvcmVsZWFzZS9sYXRlc3QvZG9jL01vdmVhYmxlLlNuYXBwYWJsZS5odG1sIy5TbmFwcGFibGVPcHRpb25zfVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcbiAqXG4gKiBtb3ZlYWJsZS5zbmFwVGhyZXNob2xkID0gNTtcbiAqL1xuXG4vKipcbiAqIEFkZCBndWlkZWxpbmVzIGluIHRoZSBob3Jpem9udGFsIGRpcmVjdGlvbi4gKGRlZmF1bHQ6IFtdKVxuICogQG5hbWUgTW92ZWFibGUuU25hcHBhYmxlI2hvcml6b250YWxHdWlkZWxpbmVzXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RheWJydXNoLmNvbS9tb3ZlYWJsZS9yZWxlYXNlL2xhdGVzdC9kb2MvTW92ZWFibGUuU25hcHBhYmxlLmh0bWwjLlNuYXBwYWJsZU9wdGlvbnN9XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICpcbiAqIG1vdmVhYmxlLmhvcml6b250YWxHdWlkZWxpbmVzID0gWzEwMCwgMjAwLCA1MDBdO1xuICovXG5cbi8qKlxuICogQWRkIGd1aWRlbGluZXMgaW4gdGhlIHZlcnRpY2FsIGRpcmVjdGlvbi4gKGRlZmF1bHQ6IFtdKVxuICogQG5hbWUgTW92ZWFibGUuU25hcHBhYmxlI3ZlcnRpY2FsR3VpZGVsaW5lc1xuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kYXlicnVzaC5jb20vbW92ZWFibGUvcmVsZWFzZS9sYXRlc3QvZG9jL01vdmVhYmxlLlNuYXBwYWJsZS5odG1sIy5TbmFwcGFibGVPcHRpb25zfVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcbiAqXG4gKiBtb3ZlYWJsZS52ZXJ0aWNhbEd1aWRlbGluZXMgPSBbMTAwLCAyMDAsIDUwMF07XG4gKi9cblxuLyoqXG4gKiBBZGQgZ3VpZGVsaW5lcyBmb3IgdGhlIGVsZW1lbnQuIChkZWZhdWx0OiBbXSlcbiAqIEBuYW1lIE1vdmVhYmxlLlNuYXBwYWJsZSNlbGVtZW50R3VpZGVsaW5lc1xuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kYXlicnVzaC5jb20vbW92ZWFibGUvcmVsZWFzZS9sYXRlc3QvZG9jL01vdmVhYmxlLlNuYXBwYWJsZS5odG1sIy5TbmFwcGFibGVPcHRpb25zfVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcbiAqXG4gKiBtb3ZlYWJsZS5lbGVtZW50R3VpZGVsaW5lcyA9IFtcbiAqICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5lbGVtZW50XCIpLFxuICogXTtcbiAqL1xuXG4vKipcbiAqIFlvdSBjYW4gc2V0IHVwIGJvdW5kYXJpZXMuIChkZWZhdWx0OiBudWxsKVxuICogQG5hbWUgTW92ZWFibGUuU25hcHBhYmxlI2JvdW5kc1xuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kYXlicnVzaC5jb20vbW92ZWFibGUvcmVsZWFzZS9sYXRlc3QvZG9jL01vdmVhYmxlLlNuYXBwYWJsZS5odG1sIy5TbmFwcGFibGVPcHRpb25zfVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcbiAqXG4gKiBtb3ZlYWJsZS5ib3VuZHMgPSB7IGxlZnQ6IDAsIHJpZ2h0OiAxMDAwLCB0b3A6IDAsIGJvdHRvbTogMTAwMH07XG4gKi9cblxuLyoqXG4gKiBZb3UgY2FuIHNldCB1cCBpbm5lciBib3VuZGFyaWVzLiAoZGVmYXVsdDogbnVsbClcbiAqIEBuYW1lIE1vdmVhYmxlLlNuYXBwYWJsZSNpbm5lckJvdW5kc1xuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kYXlicnVzaC5jb20vbW92ZWFibGUvcmVsZWFzZS9sYXRlc3QvZG9jL01vdmVhYmxlLlNuYXBwYWJsZS5odG1sIy5TbmFwcGFibGVPcHRpb25zfVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcbiAqXG4gKiBtb3ZlYWJsZS5pbm5lckJvdW5kcyA9IHsgbGVmdDogNTAwLCB0b3A6IDUwMCwgd2lkdGg6IDEwMCwgaGVpZ2h0OiAxMDB9O1xuICovXG5cbi8qKlxuICogc25hcCBkaXN0YW5jZSBkaWdpdHMgKGRlZmF1bHQ6IDApXG4gKiBAbmFtZSBNb3ZlYWJsZS5TbmFwcGFibGUjc25hcERpZ2l0XG4gKiBAc2VlIHtAbGluayBodHRwczovL2RheWJydXNoLmNvbS9tb3ZlYWJsZS9yZWxlYXNlL2xhdGVzdC9kb2MvTW92ZWFibGUuU25hcHBhYmxlLmh0bWwjLlNuYXBwYWJsZU9wdGlvbnN9XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICpcbiAqIG1vdmVhYmxlLnNuYXBEaWdpdCA9IDBcbiAqL1xuXG4vKipcbiAqIElmIHdpZHRoIHNpemUgaXMgZ3JlYXRlciB0aGFuIDAsIHlvdSBjYW4gdmVydGljYWwgc25hcCB0byB0aGUgZ3JpZC4gKGRlZmF1bHQ6IDApXG4gKiBAbmFtZSBNb3ZlYWJsZS5TbmFwcGFibGUjc25hcEdyaWRXaWR0aFxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kYXlicnVzaC5jb20vbW92ZWFibGUvcmVsZWFzZS9sYXRlc3QvZG9jL01vdmVhYmxlLlNuYXBwYWJsZS5odG1sIy5TbmFwcGFibGVPcHRpb25zfVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcbiAqXG4gKiBtb3ZlYWJsZS5zbmFwR3JpZFdpZHRoID0gNTtcbiAqL1xuXG4vKipcbiAqIElmIGhlaWdodCBzaXplIGlzIGdyZWF0ZXIgdGhhbiAwLCB5b3UgY2FuIGhvcml6b250YWwgc25hcCB0byB0aGUgZ3JpZC4gKGRlZmF1bHQ6IDApXG4gKiBAbmFtZSBNb3ZlYWJsZS5TbmFwcGFibGUjc25hcEdyaWRIZWlnaHRcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGF5YnJ1c2guY29tL21vdmVhYmxlL3JlbGVhc2UvbGF0ZXN0L2RvYy9Nb3ZlYWJsZS5TbmFwcGFibGUuaHRtbCMuU25hcHBhYmxlT3B0aW9uc31cbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XG4gKlxuICogbW92ZWFibGUuc25hcEdyaWRIZWlnaHQgPSA1O1xuICovXG5cbi8qKlxuICogV2hldGhlciB0byBzaG93IHNuYXAgZGlzdGFuY2UgKGRlZmF1bHQ6IHRydWUpXG4gKiBAbmFtZSBNb3ZlYWJsZS5TbmFwcGFibGUjaXNEaXNwbGF5U25hcERpZ2l0XG4gKiBAc2VlIHtAbGluayBodHRwczovL2RheWJydXNoLmNvbS9tb3ZlYWJsZS9yZWxlYXNlL2xhdGVzdC9kb2MvTW92ZWFibGUuU25hcHBhYmxlLmh0bWwjLlNuYXBwYWJsZU9wdGlvbnN9XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICpcbiAqIG1vdmVhYmxlLmlzRGlzcGxheVNuYXBEaWdpdCA9IHRydWU7XG4gKi9cblxuLyoqXG4gKiBXaGV0aGVyIHRvIHNob3cgZWxlbWVudCBpbm5lciBzbmFwIGRpc3RhbmNlIChkZWZhdWx0OiBmYWxzZSlcbiAqIEBuYW1lIE1vdmVhYmxlLlNuYXBwYWJsZSNpc0Rpc3BsYXlJbm5lclNuYXBEaWdpdFxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kYXlicnVzaC5jb20vbW92ZWFibGUvcmVsZWFzZS9sYXRlc3QvZG9jL01vdmVhYmxlLlNuYXBwYWJsZS5odG1sIy5TbmFwcGFibGVPcHRpb25zfVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcbiAqXG4gKiBtb3ZlYWJsZS5pc0Rpc3BsYXlJbm5lclNuYXBEaWdpdCA9IHRydWU7XG4gKi9cblxuLyoqXG4gKiBZb3UgY2FuIHNldCB0aGUgdGV4dCBmb3JtYXQgb2YgdGhlIGRpc3RhbmNlIHNob3duIGluIHRoZSBndWlkZWxpbmVzLiAoZGVmYXVsdDogc2VsZilcbiAqIEBuYW1lIE1vdmVhYmxlLlNuYXBwYWJsZSNzbmFwRGlzdEZvcm1hdFxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kYXlicnVzaC5jb20vbW92ZWFibGUvcmVsZWFzZS9sYXRlc3QvZG9jL01vdmVhYmxlLlNuYXBwYWJsZS5odG1sIy5TbmFwcGFibGVPcHRpb25zfVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgc25hcHBhYmxlOiB0cnVlLFxuICogIHNuYXBEaXN0Rm9ybWF0OiB2ID0+IHYsXG4gKiB9KTtcbiAqIG1vdmVhYmxlLnNuYXBEaXN0Rm9ybWF0ID0gdiA9PiBgJHt2fXB4YDtcbiAqL1xuXG4vKipcbiAqIFdoZW4geW91IGRyYWcgb3IgZHJhZ0NvbnRyb2wsIHRoZSBgc25hcGAgZXZlbnQgaXMgY2FsbGVkLlxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlNuYXBwYWJsZVxuICogQGV2ZW50IHNuYXBcbiAqIEBwYXJhbSB7TW92ZWFibGUuU25hcHBhYmxlLk9uU25hcH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHNuYXBgIGV2ZW50XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgICBzbmFwcGFibGU6IHRydWVcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJzbmFwXCIsIGUgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKFwib25TbmFwXCIsIGUpO1xuICogfSk7XG4gKi9cblxuLyoqXG4gKiBAbmFtZXNwYWNlIERyYWdnYWJsZVxuICogQG1lbWJlcm9mIE1vdmVhYmxlXG4gKiBAZGVzY3JpcHRpb24gRHJhZ2dhYmxlIHJlZmVycyB0byB0aGUgYWJpbGl0eSB0byBkcmFnIGFuZCBtb3ZlIHRhcmdldHMuXG4gKi9cblxudmFyIERyYWdnYWJsZSA9IHtcbiAgbmFtZTogXCJkcmFnZ2FibGVcIixcbiAgcHJvcHM6IHtcbiAgICBkcmFnZ2FibGU6IEJvb2xlYW4sXG4gICAgdGhyb3R0bGVEcmFnOiBOdW1iZXIsXG4gICAgdGhyb3R0bGVEcmFnUm90YXRlOiBOdW1iZXIsXG4gICAgc3RhcnREcmFnUm90YXRlOiBOdW1iZXIsXG4gICAgZWRnZURyYWdnYWJsZTogQm9vbGVhblxuICB9LFxuICBldmVudHM6IHtcbiAgICBvbkRyYWdTdGFydDogXCJkcmFnU3RhcnRcIixcbiAgICBvbkRyYWc6IFwiZHJhZ1wiLFxuICAgIG9uRHJhZ0VuZDogXCJkcmFnRW5kXCIsXG4gICAgb25EcmFnR3JvdXBTdGFydDogXCJkcmFnR3JvdXBTdGFydFwiLFxuICAgIG9uRHJhZ0dyb3VwOiBcImRyYWdHcm91cFwiLFxuICAgIG9uRHJhZ0dyb3VwRW5kOiBcImRyYWdHcm91cEVuZFwiXG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gKG1vdmVhYmxlLCBSZWFjdCkge1xuICAgIHZhciBfYSA9IG1vdmVhYmxlLnByb3BzLFxuICAgICAgICB0aHJvdHRsZURyYWdSb3RhdGUgPSBfYS50aHJvdHRsZURyYWdSb3RhdGUsXG4gICAgICAgIHpvb20gPSBfYS56b29tO1xuICAgIHZhciBfYiA9IG1vdmVhYmxlLnN0YXRlLFxuICAgICAgICBkcmFnSW5mbyA9IF9iLmRyYWdJbmZvLFxuICAgICAgICBiZWZvcmVPcmlnaW4gPSBfYi5iZWZvcmVPcmlnaW47XG5cbiAgICBpZiAoIXRocm90dGxlRHJhZ1JvdGF0ZSB8fCAhZHJhZ0luZm8pIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB2YXIgZGlzdCA9IGRyYWdJbmZvLmRpc3Q7XG5cbiAgICBpZiAoIWRpc3RbMF0gJiYgIWRpc3RbMV0pIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB2YXIgd2lkdGggPSBnZXREaXN0U2l6ZShkaXN0KTtcbiAgICB2YXIgcmFkID0gZ2V0UmFkKGRpc3QsIFswLCAwXSk7XG4gICAgcmV0dXJuIFtSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIGNsYXNzTmFtZTogcHJlZml4KFwibGluZVwiLCBcImhvcml6b250YWxcIiwgXCJkcmFnbGluZVwiLCBcImRhc2hlZFwiKSxcbiAgICAgIGtleTogXCJkcmFnUm90YXRlR3VpZGVsaW5lXCIsXG4gICAgICBzdHlsZToge1xuICAgICAgICB3aWR0aDogd2lkdGggKyBcInB4XCIsXG4gICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIgKyBiZWZvcmVPcmlnaW5bMF0gKyBcInB4LCBcIiArIGJlZm9yZU9yaWdpblsxXSArIFwicHgpIHJvdGF0ZShcIiArIHJhZCArIFwicmFkKSBzY2FsZVkoXCIgKyB6b29tICsgXCIpXCJcbiAgICAgIH1cbiAgICB9KV07XG4gIH0sXG4gIGRyYWdTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIGRhdGFzID0gZS5kYXRhcyxcbiAgICAgICAgcGFyZW50RXZlbnQgPSBlLnBhcmVudEV2ZW50LFxuICAgICAgICBwYXJlbnRHZXN0byA9IGUucGFyZW50R2VzdG87XG4gICAgdmFyIHN0YXRlID0gbW92ZWFibGUuc3RhdGU7XG4gICAgdmFyIHRhcmdldCA9IHN0YXRlLnRhcmdldCxcbiAgICAgICAgZ2VzdG8gPSBzdGF0ZS5nZXN0bztcblxuICAgIGlmIChnZXN0bykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHN0YXRlLmdlc3RvID0gcGFyZW50R2VzdG8gfHwgbW92ZWFibGUudGFyZ2V0R2VzdG87XG4gICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpO1xuICAgIGRhdGFzLmRhdGFzID0ge307XG4gICAgZGF0YXMubGVmdCA9IHBhcnNlRmxvYXQoc3R5bGUubGVmdCB8fCBcIlwiKSB8fCAwO1xuICAgIGRhdGFzLnRvcCA9IHBhcnNlRmxvYXQoc3R5bGUudG9wIHx8IFwiXCIpIHx8IDA7XG4gICAgZGF0YXMuYm90dG9tID0gcGFyc2VGbG9hdChzdHlsZS5ib3R0b20gfHwgXCJcIikgfHwgMDtcbiAgICBkYXRhcy5yaWdodCA9IHBhcnNlRmxvYXQoc3R5bGUucmlnaHQgfHwgXCJcIikgfHwgMDtcbiAgICBkYXRhcy5zdGFydFZhbHVlID0gWzAsIDBdO1xuICAgIHNldERyYWdTdGFydChtb3ZlYWJsZSwgZSk7XG4gICAgc2V0RGVmYXVsdFRyYW5zZm9ybUluZGV4KGUsIFwidHJhbnNsYXRlXCIpO1xuICAgIHN0YXJ0Q2hlY2tTbmFwRHJhZyhtb3ZlYWJsZSwgZGF0YXMpO1xuICAgIGRhdGFzLnByZXZEaXN0ID0gWzAsIDBdO1xuICAgIGRhdGFzLnByZXZCZWZvcmVEaXN0ID0gWzAsIDBdO1xuICAgIGRhdGFzLmlzRHJhZyA9IGZhbHNlO1xuICAgIGRhdGFzLmRlbHRhT2Zmc2V0ID0gWzAsIDBdO1xuICAgIGRhdGFzLmRpc3RPZmZzZXQgPSBbMCwgMF07XG4gICAgdmFyIHBhcmFtcyA9IGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIF9fYXNzaWduKHtcbiAgICAgIHNldDogZnVuY3Rpb24gKHRyYW5zbGF0ZSkge1xuICAgICAgICBkYXRhcy5zdGFydFZhbHVlID0gdHJhbnNsYXRlO1xuICAgICAgfVxuICAgIH0sIGZpbGxUcmFuc2Zvcm1TdGFydEV2ZW50KGUpKSk7XG4gICAgdmFyIHJlc3VsdCA9IHBhcmVudEV2ZW50IHx8IHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkRyYWdTdGFydFwiLCBwYXJhbXMpO1xuXG4gICAgaWYgKHJlc3VsdCAhPT0gZmFsc2UpIHtcbiAgICAgIGRhdGFzLmlzRHJhZyA9IHRydWU7XG4gICAgICBtb3ZlYWJsZS5zdGF0ZS5kcmFnSW5mbyA9IHtcbiAgICAgICAgc3RhcnRSZWN0OiBtb3ZlYWJsZS5nZXRSZWN0KCksXG4gICAgICAgIGRpc3Q6IFswLCAwXVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuZ2VzdG8gPSBudWxsO1xuICAgICAgZGF0YXMuaXNQaW5jaCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhcy5pc0RyYWcgPyBwYXJhbXMgOiBmYWxzZTtcbiAgfSxcbiAgZHJhZzogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgaWYgKCFlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmVzb2x2ZVRyYW5zZm9ybUV2ZW50KGUsIFwidHJhbnNsYXRlXCIpO1xuICAgIHZhciBkYXRhcyA9IGUuZGF0YXMsXG4gICAgICAgIHBhcmVudEV2ZW50ID0gZS5wYXJlbnRFdmVudCxcbiAgICAgICAgcGFyZW50RmxhZyA9IGUucGFyZW50RmxhZyxcbiAgICAgICAgaXNQaW5jaCA9IGUuaXNQaW5jaCxcbiAgICAgICAgaXNSZXF1ZXN0ID0gZS5pc1JlcXVlc3Q7XG4gICAgdmFyIGRpc3RYID0gZS5kaXN0WCxcbiAgICAgICAgZGlzdFkgPSBlLmRpc3RZO1xuICAgIHZhciBpc0RyYWcgPSBkYXRhcy5pc0RyYWcsXG4gICAgICAgIHByZXZEaXN0ID0gZGF0YXMucHJldkRpc3QsXG4gICAgICAgIHByZXZCZWZvcmVEaXN0ID0gZGF0YXMucHJldkJlZm9yZURpc3QsXG4gICAgICAgIHN0YXJ0VmFsdWUgPSBkYXRhcy5zdGFydFZhbHVlLFxuICAgICAgICBkaXN0T2Zmc2V0ID0gZGF0YXMuZGlzdE9mZnNldDtcblxuICAgIGlmICghaXNEcmFnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGlzdFggKz0gZGlzdE9mZnNldFswXTtcbiAgICBkaXN0WSArPSBkaXN0T2Zmc2V0WzFdO1xuICAgIHZhciBwcm9wcyA9IG1vdmVhYmxlLnByb3BzO1xuICAgIHZhciBwYXJlbnRNb3ZlYWJsZSA9IHByb3BzLnBhcmVudE1vdmVhYmxlO1xuICAgIHZhciB0aHJvdHRsZURyYWcgPSBwYXJlbnRFdmVudCA/IDAgOiBwcm9wcy50aHJvdHRsZURyYWcgfHwgMDtcbiAgICB2YXIgdGhyb3R0bGVEcmFnUm90YXRlID0gcGFyZW50RXZlbnQgPyAwIDogcHJvcHMudGhyb3R0bGVEcmFnUm90YXRlIHx8IDA7XG4gICAgdmFyIGlzU25hcCA9IGZhbHNlO1xuICAgIHZhciBkcmFnUm90YXRlUmFkID0gMDtcblxuICAgIGlmICghcGFyZW50RXZlbnQgJiYgdGhyb3R0bGVEcmFnUm90YXRlID4gMCAmJiAoZGlzdFggfHwgZGlzdFkpKSB7XG4gICAgICB2YXIgc3RhcnREcmFnUm90YXRlID0gcHJvcHMuc3RhcnREcmFnUm90YXRlIHx8IDA7XG4gICAgICB2YXIgZGVnID0gdGhyb3R0bGUoc3RhcnREcmFnUm90YXRlICsgZ2V0UmFkKFswLCAwXSwgW2Rpc3RYLCBkaXN0WV0pICogMTgwIC8gTWF0aC5QSSwgdGhyb3R0bGVEcmFnUm90YXRlKSAtIHN0YXJ0RHJhZ1JvdGF0ZTtcbiAgICAgIHZhciByeSA9IGRpc3RZICogTWF0aC5hYnMoTWF0aC5jb3MoKGRlZyAtIDkwKSAvIDE4MCAqIE1hdGguUEkpKTtcbiAgICAgIHZhciByeCA9IGRpc3RYICogTWF0aC5hYnMoTWF0aC5jb3MoZGVnIC8gMTgwICogTWF0aC5QSSkpO1xuICAgICAgdmFyIHIgPSBnZXREaXN0U2l6ZShbcngsIHJ5XSk7XG4gICAgICBkcmFnUm90YXRlUmFkID0gZGVnICogTWF0aC5QSSAvIDE4MDtcbiAgICAgIGRpc3RYID0gciAqIE1hdGguY29zKGRyYWdSb3RhdGVSYWQpO1xuICAgICAgZGlzdFkgPSByICogTWF0aC5zaW4oZHJhZ1JvdGF0ZVJhZCk7XG4gICAgfVxuXG4gICAgaWYgKCFpc1BpbmNoICYmICFwYXJlbnRFdmVudCAmJiAhcGFyZW50RmxhZyAmJiAoIXRocm90dGxlRHJhZ1JvdGF0ZSB8fCBkaXN0WCB8fCBkaXN0WSkpIHtcbiAgICAgIHZhciBfYSA9IGNoZWNrU25hcEJvdW5kc0RyYWcobW92ZWFibGUsIGRpc3RYLCBkaXN0WSwgdGhyb3R0bGVEcmFnUm90YXRlLCBpc1JlcXVlc3QsIGRhdGFzKSxcbiAgICAgICAgICB2ZXJ0aWNhbEluZm8gPSBfYVswXSxcbiAgICAgICAgICBob3Jpem9udGFsSW5mbyA9IF9hWzFdO1xuXG4gICAgICB2YXIgaXNWZXJ0aWNhbFNuYXAgPSB2ZXJ0aWNhbEluZm8uaXNTbmFwLFxuICAgICAgICAgIGlzVmVydGljYWxCb3VuZCA9IHZlcnRpY2FsSW5mby5pc0JvdW5kLFxuICAgICAgICAgIHZlcnRpY2FsT2Zmc2V0ID0gdmVydGljYWxJbmZvLm9mZnNldDtcbiAgICAgIHZhciBpc0hvcml6b250YWxTbmFwID0gaG9yaXpvbnRhbEluZm8uaXNTbmFwLFxuICAgICAgICAgIGlzSG9yaXpvbnRhbEJvdW5kID0gaG9yaXpvbnRhbEluZm8uaXNCb3VuZCxcbiAgICAgICAgICBob3Jpem9udGFsT2Zmc2V0ID0gaG9yaXpvbnRhbEluZm8ub2Zmc2V0O1xuICAgICAgaXNTbmFwID0gaXNWZXJ0aWNhbFNuYXAgfHwgaXNIb3Jpem9udGFsU25hcCB8fCBpc1ZlcnRpY2FsQm91bmQgfHwgaXNIb3Jpem9udGFsQm91bmQ7XG4gICAgICBkaXN0WCArPSB2ZXJ0aWNhbE9mZnNldDtcbiAgICAgIGRpc3RZICs9IGhvcml6b250YWxPZmZzZXQ7XG4gICAgfVxuXG4gICAgdmFyIGJlZm9yZVRyYW5zbGF0ZSA9IHBsdXMoZ2V0QmVmb3JlRHJhZ0Rpc3Qoe1xuICAgICAgZGF0YXM6IGRhdGFzLFxuICAgICAgZGlzdFg6IGRpc3RYLFxuICAgICAgZGlzdFk6IGRpc3RZXG4gICAgfSksIHN0YXJ0VmFsdWUpO1xuICAgIHZhciB0cmFuc2xhdGUgPSBwbHVzKGdldFRyYW5zZm9ybURpc3Qoe1xuICAgICAgZGF0YXM6IGRhdGFzLFxuICAgICAgZGlzdFg6IGRpc3RYLFxuICAgICAgZGlzdFk6IGRpc3RZXG4gICAgfSksIHN0YXJ0VmFsdWUpO1xuXG4gICAgaWYgKCF0aHJvdHRsZURyYWdSb3RhdGUgJiYgIWlzU25hcCkge1xuICAgICAgdGhyb3R0bGVBcnJheSh0cmFuc2xhdGUsIHRocm90dGxlRHJhZyk7XG4gICAgICB0aHJvdHRsZUFycmF5KGJlZm9yZVRyYW5zbGF0ZSwgdGhyb3R0bGVEcmFnKTtcbiAgICB9XG5cbiAgICB2YXIgYmVmb3JlRGlzdCA9IG1pbnVzKGJlZm9yZVRyYW5zbGF0ZSwgc3RhcnRWYWx1ZSk7XG4gICAgdmFyIGRpc3QgPSBtaW51cyh0cmFuc2xhdGUsIHN0YXJ0VmFsdWUpO1xuICAgIHZhciBkZWx0YSA9IG1pbnVzKGRpc3QsIHByZXZEaXN0KTtcbiAgICB2YXIgYmVmb3JlRGVsdGEgPSBtaW51cyhiZWZvcmVEaXN0LCBwcmV2QmVmb3JlRGlzdCk7XG4gICAgZGF0YXMucHJldkRpc3QgPSBkaXN0O1xuICAgIGRhdGFzLnByZXZCZWZvcmVEaXN0ID0gYmVmb3JlRGlzdDtcbiAgICBkYXRhcy5wYXNzRGVsdGEgPSBkZWx0YTsgLy9kaXN0WCAtIChkYXRhcy5wYXNzRGlzdFggfHwgMCk7XG4gICAgLy8gZGF0YXMucGFzc0RlbHRhWSA9IGRpc3RZIC0gKGRhdGFzLnBhc3NEaXN0WSB8fCAwKTtcblxuICAgIGRhdGFzLnBhc3NEaXN0ID0gZGlzdDsgLy9kaXN0WDtcbiAgICAvLyBkYXRhcy5wYXNzRGlzdFkgPSBkaXN0WTtcblxuICAgIHZhciBsZWZ0ID0gZGF0YXMubGVmdCArIGJlZm9yZURpc3RbMF07XG4gICAgdmFyIHRvcCA9IGRhdGFzLnRvcCArIGJlZm9yZURpc3RbMV07XG4gICAgdmFyIHJpZ2h0ID0gZGF0YXMucmlnaHQgLSBiZWZvcmVEaXN0WzBdO1xuICAgIHZhciBib3R0b20gPSBkYXRhcy5ib3R0b20gLSBiZWZvcmVEaXN0WzFdO1xuICAgIHZhciBuZXh0VHJhbnNmb3JtID0gY29udmVydFRyYW5zZm9ybUZvcm1hdChkYXRhcywgXCJ0cmFuc2xhdGUoXCIgKyB0cmFuc2xhdGVbMF0gKyBcInB4LCBcIiArIHRyYW5zbGF0ZVsxXSArIFwicHgpXCIsIFwidHJhbnNsYXRlKFwiICsgZGlzdFswXSArIFwicHgsIFwiICsgZGlzdFsxXSArIFwicHgpXCIpO1xuICAgIGZpbGxPcmlnaW5hbFRyYW5zZm9ybShlLCBuZXh0VHJhbnNmb3JtKTtcbiAgICBtb3ZlYWJsZS5zdGF0ZS5kcmFnSW5mby5kaXN0ID0gcGFyZW50RXZlbnQgPyBbMCwgMF0gOiBkaXN0O1xuXG4gICAgaWYgKCFwYXJlbnRFdmVudCAmJiAhcGFyZW50TW92ZWFibGUgJiYgZGVsdGEuZXZlcnkoZnVuY3Rpb24gKG51bSkge1xuICAgICAgcmV0dXJuICFudW07XG4gICAgfSkgJiYgYmVmb3JlRGVsdGEuc29tZShmdW5jdGlvbiAobnVtKSB7XG4gICAgICByZXR1cm4gIW51bTtcbiAgICB9KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBfYiA9IG1vdmVhYmxlLnN0YXRlLFxuICAgICAgICB3aWR0aCA9IF9iLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfYi5oZWlnaHQ7XG4gICAgdmFyIHBhcmFtcyA9IGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIHtcbiAgICAgIHRyYW5zZm9ybTogbmV4dFRyYW5zZm9ybSxcbiAgICAgIGRpc3Q6IGRpc3QsXG4gICAgICBkZWx0YTogZGVsdGEsXG4gICAgICB0cmFuc2xhdGU6IHRyYW5zbGF0ZSxcbiAgICAgIGJlZm9yZURpc3Q6IGJlZm9yZURpc3QsXG4gICAgICBiZWZvcmVEZWx0YTogYmVmb3JlRGVsdGEsXG4gICAgICBiZWZvcmVUcmFuc2xhdGU6IGJlZm9yZVRyYW5zbGF0ZSxcbiAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICB0b3A6IHRvcCxcbiAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgIGJvdHRvbTogYm90dG9tLFxuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICBpc1BpbmNoOiBpc1BpbmNoXG4gICAgfSk7XG4gICAgIXBhcmVudEV2ZW50ICYmIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkRyYWdcIiwgcGFyYW1zKTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9LFxuICBkcmFnQWZ0ZXI6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBkYXRhcyA9IGUuZGF0YXM7XG4gICAgdmFyIF9hID0gZS5kYXRhcyxcbiAgICAgICAgZGVsdGFPZmZzZXQgPSBfYS5kZWx0YU9mZnNldCxcbiAgICAgICAgZGlzdE9mZnNldCA9IF9hLmRpc3RPZmZzZXQ7XG5cbiAgICBpZiAoZGVsdGFPZmZzZXRbMF0gfHwgZGVsdGFPZmZzZXRbMV0pIHtcbiAgICAgIGRhdGFzLmRlbHRhT2Zmc2V0ID0gWzAsIDBdO1xuICAgICAgZGlzdE9mZnNldFswXSA9IGRlbHRhT2Zmc2V0WzBdO1xuICAgICAgZGlzdE9mZnNldFsxXSA9IGRlbHRhT2Zmc2V0WzFdO1xuICAgICAgcmV0dXJuIHRoaXMuZHJhZyhtb3ZlYWJsZSwgZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICBkcmFnRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB2YXIgcGFyZW50RXZlbnQgPSBlLnBhcmVudEV2ZW50LFxuICAgICAgICBkYXRhcyA9IGUuZGF0YXM7XG4gICAgbW92ZWFibGUuc3RhdGUuZ2VzdG8gPSBudWxsO1xuICAgIG1vdmVhYmxlLnN0YXRlLmRyYWdJbmZvID0gbnVsbDtcblxuICAgIGlmICghZGF0YXMuaXNEcmFnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGF0YXMuaXNEcmFnID0gZmFsc2U7XG4gICAgdmFyIHBhcmFtID0gZmlsbEVuZFBhcmFtcyhtb3ZlYWJsZSwgZSwge30pO1xuICAgICFwYXJlbnRFdmVudCAmJiB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25EcmFnRW5kXCIsIHBhcmFtKTtcbiAgICByZXR1cm4gcGFyYW07XG4gIH0sXG4gIGRyYWdHcm91cFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB2YXIgZGF0YXMgPSBlLmRhdGFzLFxuICAgICAgICBjbGllbnRYID0gZS5jbGllbnRYLFxuICAgICAgICBjbGllbnRZID0gZS5jbGllbnRZO1xuICAgIHZhciBwYXJhbXMgPSB0aGlzLmRyYWdTdGFydChtb3ZlYWJsZSwgZSk7XG5cbiAgICBpZiAoIXBhcmFtcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBldmVudHMgPSB0cmlnZ2VyQ2hpbGRHZXN0byhtb3ZlYWJsZSwgdGhpcywgXCJkcmFnU3RhcnRcIiwgW2NsaWVudFggfHwgMCwgY2xpZW50WSB8fCAwXSwgZSwgZmFsc2UpO1xuXG4gICAgdmFyIG5leHRQYXJhbXMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcGFyYW1zKSwge1xuICAgICAgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0cyxcbiAgICAgIGV2ZW50czogZXZlbnRzXG4gICAgfSk7XG5cbiAgICB2YXIgcmVzdWx0ID0gdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uRHJhZ0dyb3VwU3RhcnRcIiwgbmV4dFBhcmFtcyk7XG4gICAgZGF0YXMuaXNEcmFnID0gcmVzdWx0ICE9PSBmYWxzZTtcbiAgICByZXR1cm4gZGF0YXMuaXNEcmFnID8gcGFyYW1zIDogZmFsc2U7XG4gIH0sXG4gIGRyYWdHcm91cDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIGRhdGFzID0gZS5kYXRhcztcblxuICAgIGlmICghZGF0YXMuaXNEcmFnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBhcmFtcyA9IHRoaXMuZHJhZyhtb3ZlYWJsZSwgZSk7XG4gICAgdmFyIHBhc3NEZWx0YSA9IGUuZGF0YXMucGFzc0RlbHRhO1xuICAgIHZhciBldmVudHMgPSB0cmlnZ2VyQ2hpbGRHZXN0byhtb3ZlYWJsZSwgdGhpcywgXCJkcmFnXCIsIHBhc3NEZWx0YSwgZSwgZmFsc2UpO1xuXG4gICAgaWYgKCFwYXJhbXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dFBhcmFtcyA9IF9fYXNzaWduKHtcbiAgICAgIHRhcmdldHM6IG1vdmVhYmxlLnByb3BzLnRhcmdldHMsXG4gICAgICBldmVudHM6IGV2ZW50c1xuICAgIH0sIHBhcmFtcyk7XG5cbiAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25EcmFnR3JvdXBcIiwgbmV4dFBhcmFtcyk7XG4gICAgcmV0dXJuIG5leHRQYXJhbXM7XG4gIH0sXG4gIGRyYWdHcm91cEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIGlzRHJhZyA9IGUuaXNEcmFnLFxuICAgICAgICBkYXRhcyA9IGUuZGF0YXM7XG5cbiAgICBpZiAoIWRhdGFzLmlzRHJhZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZHJhZ0VuZChtb3ZlYWJsZSwgZSk7XG4gICAgdmFyIGV2ZW50cyA9IHRyaWdnZXJDaGlsZEdlc3RvKG1vdmVhYmxlLCB0aGlzLCBcImRyYWdFbmRcIiwgWzAsIDBdLCBlLCBmYWxzZSk7XG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uRHJhZ0dyb3VwRW5kXCIsIGZpbGxFbmRQYXJhbXMobW92ZWFibGUsIGUsIHtcbiAgICAgIHRhcmdldHM6IG1vdmVhYmxlLnByb3BzLnRhcmdldHMsXG4gICAgICBldmVudHM6IGV2ZW50c1xuICAgIH0pKTtcbiAgICByZXR1cm4gaXNEcmFnO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIE1vdmVhYmxlLkRyYWdnYWJsZSNyZXF1ZXN0XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbZV0gLSB0aGUgZHJhZ2dhYmxlJ3MgcmVxdWVzdCBwYXJhbWV0ZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtlLnhdIC0geCBwb3NpdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gW2UueV0gLSB5IHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZS5kZWx0YVhdIC0gWCBudW1iZXIgdG8gbW92ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2UuZGVsdGFZXSAtIFkgbnVtYmVyIHRvIG1vdmVcbiAgICogQHJldHVybiB7TW92ZWFibGUuUmVxdWVzdGVyfSBNb3ZlYWJsZSBSZXF1ZXN0ZXJcbiAgICogQGV4YW1wbGVcbiAgICAqIC8vIEluc3RhbnRseSBSZXF1ZXN0IChyZXF1ZXN0U3RhcnQgLSByZXF1ZXN0IC0gcmVxdWVzdEVuZClcbiAgICogLy8gVXNlIFJlbGF0aXZlIFZhbHVlXG4gICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJkcmFnZ2FibGVcIiwgeyBkZWx0YVg6IDEwLCBkZWx0YVk6IDEwIH0sIHRydWUpO1xuICAgKiAvLyBVc2UgQWJzb2x1dGUgVmFsdWVcbiAgICogbW92ZWFibGUucmVxdWVzdChcImRyYWdnYWJsZVwiLCB7IHg6IDIwMCwgeTogMTAwIH0sIHRydWUpO1xuICAgKlxuICAgKiAvLyByZXF1ZXN0U3RhcnRcbiAgICogY29uc3QgcmVxdWVzdGVyID0gbW92ZWFibGUucmVxdWVzdChcImRyYWdnYWJsZVwiKTtcbiAgICpcbiAgICogLy8gcmVxdWVzdFxuICAgKiAvLyBVc2UgUmVsYXRpdmUgVmFsdWVcbiAgICogcmVxdWVzdGVyLnJlcXVlc3QoeyBkZWx0YVg6IDEwLCBkZWx0YVk6IDEwIH0pO1xuICAgKiByZXF1ZXN0ZXIucmVxdWVzdCh7IGRlbHRhWDogMTAsIGRlbHRhWTogMTAgfSk7XG4gICAqIHJlcXVlc3Rlci5yZXF1ZXN0KHsgZGVsdGFYOiAxMCwgZGVsdGFZOiAxMCB9KTtcbiAgICogLy8gVXNlIEFic29sdXRlIFZhbHVlXG4gICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJkcmFnZ2FibGVcIiwgeyB4OiAyMDAsIHk6IDEwMCB9KTtcbiAgICogbW92ZWFibGUucmVxdWVzdChcImRyYWdnYWJsZVwiLCB7IHg6IDIyMCwgeTogMTAwIH0pO1xuICAgKiBtb3ZlYWJsZS5yZXF1ZXN0KFwiZHJhZ2dhYmxlXCIsIHsgeDogMjQwLCB5OiAxMDAgfSk7XG4gICAqXG4gICAqIC8vIHJlcXVlc3RFbmRcbiAgICogcmVxdWVzdGVyLnJlcXVlc3RFbmQoKTtcbiAgICovXG4gIHJlcXVlc3Q6IGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xuICAgIHZhciBkYXRhcyA9IHt9O1xuICAgIHZhciByZWN0ID0gbW92ZWFibGUuZ2V0UmVjdCgpO1xuICAgIHZhciBkaXN0WCA9IDA7XG4gICAgdmFyIGRpc3RZID0gMDtcbiAgICByZXR1cm4ge1xuICAgICAgaXNDb250cm9sOiBmYWxzZSxcbiAgICAgIHJlcXVlc3RTdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGFzOiBkYXRhc1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHJlcXVlc3Q6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChcInhcIiBpbiBlKSB7XG4gICAgICAgICAgZGlzdFggPSBlLnggLSByZWN0LmxlZnQ7XG4gICAgICAgIH0gZWxzZSBpZiAoXCJkZWx0YVhcIiBpbiBlKSB7XG4gICAgICAgICAgZGlzdFggKz0gZS5kZWx0YVg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXCJ5XCIgaW4gZSkge1xuICAgICAgICAgIGRpc3RZID0gZS55IC0gcmVjdC50b3A7XG4gICAgICAgIH0gZWxzZSBpZiAoXCJkZWx0YVlcIiBpbiBlKSB7XG4gICAgICAgICAgZGlzdFkgKz0gZS5kZWx0YVk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGFzOiBkYXRhcyxcbiAgICAgICAgICBkaXN0WDogZGlzdFgsXG4gICAgICAgICAgZGlzdFk6IGRpc3RZXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgcmVxdWVzdEVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGFzOiBkYXRhcyxcbiAgICAgICAgICBpc0RyYWc6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICB1bnNldDogZnVuY3Rpb24gKG1vdmVhYmxlKSB7XG4gICAgbW92ZWFibGUuc3RhdGUuZHJhZ0luZm8gPSBudWxsO1xuICB9XG59O1xuLyoqXG4gKiBXaGV0aGVyIG9yIG5vdCB0YXJnZXQgY2FuIGJlIGRyYWdnZWQuIChkZWZhdWx0OiBmYWxzZSlcbiAqIEBuYW1lIE1vdmVhYmxlLkRyYWdnYWJsZSNkcmFnZ2FibGVcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XG4gKlxuICogbW92ZWFibGUuZHJhZ2dhYmxlID0gdHJ1ZTtcbiAqL1xuXG4vKipcbiAqIHRocm90dGxlIG9mIHgsIHkgd2hlbiBkcmFnLlxuICogQG5hbWUgTW92ZWFibGUuRHJhZ2dhYmxlI3Rocm90dGxlRHJhZ1xuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcbiAqXG4gKiBtb3ZlYWJsZS50aHJvdHRsZURyYWcgPSAxO1xuICovXG5cbi8qKlxuKiB0aHJvdHRsZSBvZiBhbmdsZSBvZiB4LCB5IHdoZW4gZHJhZy5cbiogQG5hbWUgTW92ZWFibGUuRHJhZ2dhYmxlI3Rocm90dGxlRHJhZ1JvdGF0ZVxuKiBAZXhhbXBsZVxuKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4qXG4qIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuKlxuKiBtb3ZlYWJsZS50aHJvdHRsZURyYWdSb3RhdGUgPSA0NTtcbiovXG5cbi8qKlxuKiBzdGFydCBhbmdsZSBvZiB0aHJvdHRsZURyYWdSb3RhdGUgb2YgeCwgeSB3aGVuIGRyYWcuXG4qIEBuYW1lIE1vdmVhYmxlLkRyYWdnYWJsZSNzdGFydERyYWdSb3RhdGVcbiogQGV4YW1wbGVcbiogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuKlxuKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcbipcbiogLy8gNDUsIDEzNSwgMjI1LCAzMTVcbiogbW92ZWFibGUudGhyb3R0bGVEcmFnUm90YXRlID0gOTA7XG4qIG1vdmVhYmxlLnN0YXJ0RHJhZ1JvdGF0ZSA9IDQ1O1xuKi9cblxuLyoqXG4gKiBXaGVuIHRoZSBkcmFnIHN0YXJ0cywgdGhlIGRyYWdTdGFydCBldmVudCBpcyBjYWxsZWQuXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuRHJhZ2dhYmxlXG4gKiBAZXZlbnQgZHJhZ1N0YXJ0XG4gKiBAcGFyYW0ge01vdmVhYmxlLkRyYWdnYWJsZS5PbkRyYWdTdGFydH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgZHJhZ1N0YXJ0IGV2ZW50XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHsgZHJhZ2dhYmxlOiB0cnVlIH0pO1xuICogbW92ZWFibGUub24oXCJkcmFnU3RhcnRcIiwgKHsgdGFyZ2V0IH0pID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyh0YXJnZXQpO1xuICogfSk7XG4gKi9cblxuLyoqXG4gKiBXaGVuIGRyYWdnaW5nLCB0aGUgZHJhZyBldmVudCBpcyBjYWxsZWQuXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuRHJhZ2dhYmxlXG4gKiBAZXZlbnQgZHJhZ1xuICogQHBhcmFtIHtNb3ZlYWJsZS5EcmFnZ2FibGUuT25EcmFnfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBkcmFnIGV2ZW50XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHsgZHJhZ2dhYmxlOiB0cnVlIH0pO1xuICogbW92ZWFibGUub24oXCJkcmFnXCIsICh7IHRhcmdldCwgdHJhbnNmb3JtIH0pID0+IHtcbiAqICAgICB0YXJnZXQuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICogfSk7XG4gKi9cblxuLyoqXG4gKiBXaGVuIHRoZSBkcmFnIGZpbmlzaGVzLCB0aGUgZHJhZ0VuZCBldmVudCBpcyBjYWxsZWQuXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuRHJhZ2dhYmxlXG4gKiBAZXZlbnQgZHJhZ0VuZFxuICogQHBhcmFtIHtNb3ZlYWJsZS5EcmFnZ2FibGUuT25EcmFnRW5kfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBkcmFnRW5kIGV2ZW50XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHsgZHJhZ2dhYmxlOiB0cnVlIH0pO1xuICogbW92ZWFibGUub24oXCJkcmFnRW5kXCIsICh7IHRhcmdldCwgaXNEcmFnIH0pID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyh0YXJnZXQsIGlzRHJhZyk7XG4gKiB9KTtcbiAqL1xuXG4vKipcbiogV2hlbiB0aGUgZ3JvdXAgZHJhZyBzdGFydHMsIHRoZSBgZHJhZ0dyb3VwU3RhcnRgIGV2ZW50IGlzIGNhbGxlZC5cbiogQG1lbWJlcm9mIE1vdmVhYmxlLkRyYWdnYWJsZVxuKiBAZXZlbnQgZHJhZ0dyb3VwU3RhcnRcbiogQHBhcmFtIHtNb3ZlYWJsZS5EcmFnZ2FibGUuT25EcmFnR3JvdXBTdGFydH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYGRyYWdHcm91cFN0YXJ0YCBldmVudFxuKiBAZXhhbXBsZVxuKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4qXG4qIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiogICAgIHRhcmdldDogW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnRhcmdldFwiKSksXG4qICAgICBkcmFnZ2FibGU6IHRydWVcbiogfSk7XG4qIG1vdmVhYmxlLm9uKFwiZHJhZ0dyb3VwU3RhcnRcIiwgKHsgdGFyZ2V0cyB9KSA9PiB7XG4qICAgICBjb25zb2xlLmxvZyhcIm9uRHJhZ0dyb3VwU3RhcnRcIiwgdGFyZ2V0cyk7XG4qIH0pO1xuKi9cblxuLyoqXG4qIFdoZW4gdGhlIGdyb3VwIGRyYWcsIHRoZSBgZHJhZ0dyb3VwYCBldmVudCBpcyBjYWxsZWQuXG4qIEBtZW1iZXJvZiBNb3ZlYWJsZS5EcmFnZ2FibGVcbiogQGV2ZW50IGRyYWdHcm91cFxuKiBAcGFyYW0ge01vdmVhYmxlLkRyYWdnYWJsZS5PbkRyYWdHcm91cH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYGRyYWdHcm91cGAgZXZlbnRcbiogQGV4YW1wbGVcbiogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuKlxuKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4qICAgICB0YXJnZXQ6IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi50YXJnZXRcIikpLFxuKiAgICAgZHJhZ2dhYmxlOiB0cnVlXG4qIH0pO1xuKiBtb3ZlYWJsZS5vbihcImRyYWdHcm91cFwiLCAoeyB0YXJnZXRzLCBldmVudHMgfSkgPT4ge1xuKiAgICAgY29uc29sZS5sb2coXCJvbkRyYWdHcm91cFwiLCB0YXJnZXRzKTtcbiogICAgIGV2ZW50cy5mb3JFYWNoKGV2ID0+IHtcbiogICAgICAgICAgLy8gZHJhZyBldmVudFxuKiAgICAgICAgICBjb25zb2xlLmxvZyhcIm9uRHJhZyBsZWZ0LCB0b3BcIiwgZXYubGVmdCwgZXYudG9wKTtcbiogICAgICAgICAgLy8gZXYudGFyZ2V0IS5zdHlsZS5sZWZ0ID0gYCR7ZXYubGVmdH1weGA7XG4qICAgICAgICAgIC8vIGV2LnRhcmdldCEuc3R5bGUudG9wID0gYCR7ZXYudG9wfXB4YDtcbiogICAgICAgICAgY29uc29sZS5sb2coXCJvbkRyYWcgdHJhbnNsYXRlXCIsIGV2LmRpc3QpO1xuKiAgICAgICAgICBldi50YXJnZXQhLnN0eWxlLnRyYW5zZm9ybSA9IGV2LnRyYW5zZm9ybTspXG4qICAgICB9KTtcbiogfSk7XG4qL1xuXG4vKipcbiAqIFdoZW4gdGhlIGdyb3VwIGRyYWcgZmluaXNoZXMsIHRoZSBgZHJhZ0dyb3VwRW5kYCBldmVudCBpcyBjYWxsZWQuXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuRHJhZ2dhYmxlXG4gKiBAZXZlbnQgZHJhZ0dyb3VwRW5kXG4gKiBAcGFyYW0ge01vdmVhYmxlLkRyYWdnYWJsZS5PbkRyYWdHcm91cEVuZH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYGRyYWdHcm91cEVuZGAgZXZlbnRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICAgIHRhcmdldDogW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnRhcmdldFwiKSksXG4gKiAgICAgZHJhZ2dhYmxlOiB0cnVlXG4gKiB9KTtcbiAqIG1vdmVhYmxlLm9uKFwiZHJhZ0dyb3VwRW5kXCIsICh7IHRhcmdldHMsIGlzRHJhZyB9KSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coXCJvbkRyYWdHcm91cEVuZFwiLCB0YXJnZXRzLCBpc0RyYWcpO1xuICogfSk7XG4gKi9cblxuZnVuY3Rpb24gcmVuZGVyRGlyZWN0aW9uQ29udHJvbHMobW92ZWFibGUsIGRlZmF1bHREaXJlY3Rpb25zLCBSZWFjdCwgYWRkaXRpb25hbENsYXNzTmFtZSkge1xuICBpZiAoYWRkaXRpb25hbENsYXNzTmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgYWRkaXRpb25hbENsYXNzTmFtZSA9IFwiXCI7XG4gIH1cblxuICB2YXIgX2EgPSBtb3ZlYWJsZS5zdGF0ZSxcbiAgICAgIHJlbmRlclBvc2VzID0gX2EucmVuZGVyUG9zZXMsXG4gICAgICByb3RhdGlvblJhZCA9IF9hLnJvdGF0aW9uLFxuICAgICAgZGlyZWN0aW9uID0gX2EuZGlyZWN0aW9uO1xuICB2YXIgX2IgPSBtb3ZlYWJsZS5wcm9wcyxcbiAgICAgIF9jID0gX2IucmVuZGVyRGlyZWN0aW9ucyxcbiAgICAgIGRpcmVjdGlvbnMgPSBfYyA9PT0gdm9pZCAwID8gZGVmYXVsdERpcmVjdGlvbnMgOiBfYyxcbiAgICAgIHpvb20gPSBfYi56b29tO1xuICB2YXIgZGlyZWN0aW9uTWFwID0ge307XG5cbiAgaWYgKCFkaXJlY3Rpb25zKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIHNpZ24gPSBkaXJlY3Rpb24gPiAwID8gMSA6IC0xO1xuICB2YXIgcmVuZGVyRGlyZWN0aW9ucyA9IGRpcmVjdGlvbnMgPT09IHRydWUgPyBESVJFQ1RJT05TIDogZGlyZWN0aW9ucztcbiAgdmFyIGRlZ1JvdGF0aW9uID0gcm90YXRpb25SYWQgLyBNYXRoLlBJICogMTgwO1xuICByZW5kZXJEaXJlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGRpcikge1xuICAgIGRpcmVjdGlvbk1hcFtkaXJdID0gdHJ1ZTtcbiAgfSk7XG4gIHJldHVybiByZW5kZXJEaXJlY3Rpb25zLm1hcChmdW5jdGlvbiAoZGlyKSB7XG4gICAgdmFyIGluZGV4ZXMgPSBESVJFQ1RJT05fSU5ERVhFU1tkaXJdO1xuXG4gICAgaWYgKCFpbmRleGVzIHx8ICFkaXJlY3Rpb25NYXBbZGlyXSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGRpcmVjdGlvblJvdGF0aW9uID0gKHRocm90dGxlKGRlZ1JvdGF0aW9uLCAxNSkgKyBzaWduICogRElSRUNUSU9OX1JPVEFUSU9OU1tkaXJdICsgNzIwKSAlIDE4MDtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBjbGFzc05hbWU6IHByZWZpeChcImNvbnRyb2xcIiwgXCJkaXJlY3Rpb25cIiwgZGlyLCBhZGRpdGlvbmFsQ2xhc3NOYW1lKSxcbiAgICAgIFwiZGF0YS1yb3RhdGlvblwiOiBkaXJlY3Rpb25Sb3RhdGlvbixcbiAgICAgIFwiZGF0YS1kaXJlY3Rpb25cIjogZGlyLFxuICAgICAga2V5OiBcImRpcmVjdGlvbi1cIiArIGRpcixcbiAgICAgIHN0eWxlOiBnZXRDb250cm9sVHJhbnNmb3JtLmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbcm90YXRpb25SYWQsIHpvb21dLCBpbmRleGVzLm1hcChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHJlbmRlclBvc2VzW2luZGV4XTtcbiAgICAgIH0pKSlcbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiByZW5kZXJMaW5lKFJlYWN0LCBkaXJlY3Rpb24sIHBvczEsIHBvczIsIHpvb20sIGtleSkge1xuICB2YXIgY2xhc3NOYW1lcyA9IFtdO1xuXG4gIGZvciAodmFyIF9pID0gNjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgY2xhc3NOYW1lc1tfaSAtIDZdID0gYXJndW1lbnRzW19pXTtcbiAgfVxuXG4gIHZhciByYWQgPSBnZXRSYWQocG9zMSwgcG9zMik7XG4gIHZhciByb3RhdGlvbiA9IGRpcmVjdGlvbiA/IHRocm90dGxlKHJhZCAvIE1hdGguUEkgKiAxODAsIDE1KSAlIDE4MCA6IC0xO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAga2V5OiBcImxpbmVcIiArIGtleSxcbiAgICBjbGFzc05hbWU6IHByZWZpeC5hcHBseSh2b2lkIDAsIF9fc3ByZWFkQXJyYXkoW1wibGluZVwiLCBcImRpcmVjdGlvblwiLCBkaXJlY3Rpb25dLCBjbGFzc05hbWVzKSksXG4gICAgXCJkYXRhLXJvdGF0aW9uXCI6IHJvdGF0aW9uLFxuICAgIFwiZGF0YS1saW5lLWluZGV4XCI6IGtleSxcbiAgICBcImRhdGEtZGlyZWN0aW9uXCI6IGRpcmVjdGlvbixcbiAgICBzdHlsZTogZ2V0TGluZVN0eWxlKHBvczEsIHBvczIsIHpvb20sIHJhZClcbiAgfSk7XG59XG5mdW5jdGlvbiByZW5kZXJBbGxEaXJlY3Rpb25zKG1vdmVhYmxlLCBSZWFjdCkge1xuICByZXR1cm4gcmVuZGVyRGlyZWN0aW9uQ29udHJvbHMobW92ZWFibGUsIERJUkVDVElPTlMsIFJlYWN0KTtcbn1cbmZ1bmN0aW9uIHJlbmRlckRpYWdvbmFsRGlyZWN0aW9ucyhtb3ZlYWJsZSwgUmVhY3QpIHtcbiAgcmV0dXJuIHJlbmRlckRpcmVjdGlvbkNvbnRyb2xzKG1vdmVhYmxlLCBbXCJud1wiLCBcIm5lXCIsIFwic3dcIiwgXCJzZVwiXSwgUmVhY3QpO1xufVxuXG4vKipcbiAqIEBuYW1lc3BhY2UgUm90YXRhYmxlXG4gKiBAbWVtYmVyb2YgTW92ZWFibGVcbiAqIEBkZXNjcmlwdGlvbiBSb3RhdGFibGUgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRhcmdldCBjYW4gYmUgcm90YXRlZC5cbiAqL1xuXG5mdW5jdGlvbiBzZXRSb3RhdGVTdGFydEluZm8obW92ZWFibGUsIGRhdGFzLCBjbGllbnRYLCBjbGllbnRZLCBvcmlnaW4sIHJlY3QpIHtcbiAgdmFyIG4gPSBtb3ZlYWJsZS5zdGF0ZS5pczNkID8gNCA6IDM7XG4gIHZhciBuZXh0T3JpZ2luID0gY2FsY3VsYXRlUG9zaXRpb24obW92ZWFibGUuc3RhdGUucm9vdE1hdHJpeCwgb3JpZ2luLCBuKTtcbiAgdmFyIHN0YXJ0QWJzb2x1dGVPcmlnaW4gPSBwbHVzKFtyZWN0LmxlZnQsIHJlY3QudG9wXSwgbmV4dE9yaWdpbik7XG4gIGRhdGFzLnN0YXJ0QWJzb2x1dGVPcmlnaW4gPSBzdGFydEFic29sdXRlT3JpZ2luO1xuICBkYXRhcy5wcmV2RGVnID0gZ2V0UmFkKHN0YXJ0QWJzb2x1dGVPcmlnaW4sIFtjbGllbnRYLCBjbGllbnRZXSkgLyBNYXRoLlBJICogMTgwO1xuICBkYXRhcy5wcmV2U25hcERlZyA9IGRhdGFzLnByZXZEZWc7XG4gIGRhdGFzLnN0YXJ0RGVnID0gZGF0YXMucHJldkRlZztcbiAgZGF0YXMubG9vcCA9IDA7XG59XG5cbmZ1bmN0aW9uIGdldFBhcmVudERlZyhtb3ZlYWJsZSwgbW92ZWFibGVSZWN0LCBkYXRhcywgcGFyZW50RGlzdCwgZGlyZWN0aW9uLCBzdGFydFZhbHVlKSB7XG4gIHZhciBwcmV2RGVnID0gZGF0YXMucHJldkRlZzsgLy8gY29uc3QgYWJzb2x1dGVEZWcgPSBzdGFydFZhbHVlICsgcGFyZW50RGlzdDtcblxuICB2YXIgZGlzdCA9IGNoZWNrU25hcFJvdGF0ZShtb3ZlYWJsZSwgbW92ZWFibGVSZWN0LCBkYXRhcy5vcmlnaW4sIHBhcmVudERpc3QpO1xuICBkYXRhcy5wcmV2RGVnID0gZGlzdDtcbiAgdmFyIGRlbHRhID0gZGlzdCAtIHByZXZEZWc7XG4gIHJldHVybiBbZGVsdGEsIGRpc3QsIHN0YXJ0VmFsdWUgKyBkaXN0XTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVnKG1vdmVhYmxlLCBtb3ZlYWJsZVJlY3QsIGRhdGFzLCBkZWcsIGRpcmVjdGlvbiwgc3RhcnRWYWx1ZSwgdGhyb3R0bGVSb3RhdGUsIGlzU25hcCkge1xuICB2YXIgcHJldkRlZyA9IGRhdGFzLnByZXZEZWcsXG4gICAgICBwcmV2U25hcERlZyA9IGRhdGFzLnByZXZTbmFwRGVnLFxuICAgICAgc3RhcnREZWcgPSBkYXRhcy5zdGFydERlZyxcbiAgICAgIHByZXZMb29wID0gZGF0YXMubG9vcDtcblxuICBpZiAocHJldkRlZyA+IGRlZyAmJiBwcmV2RGVnID4gMjcwICYmIGRlZyA8IDkwKSB7XG4gICAgLy8gMzYwID0+IDBcbiAgICArK2RhdGFzLmxvb3A7XG4gIH0gZWxzZSBpZiAocHJldkRlZyA8IGRlZyAmJiBwcmV2RGVnIDwgOTAgJiYgZGVnID4gMjcwKSB7XG4gICAgLy8gMCA9PiAzNjBcbiAgICAtLWRhdGFzLmxvb3A7XG4gIH1cblxuICB2YXIgbG9vcCA9IGRhdGFzLmxvb3A7XG4gIHZhciBhYnNvbHV0ZVByZXZTbmFwRGVnID0gcHJldkxvb3AgKiAzNjAgKyBwcmV2U25hcERlZyAtIHN0YXJ0RGVnICsgc3RhcnRWYWx1ZTtcbiAgdmFyIGFic29sdXRlRGVnID0gbG9vcCAqIDM2MCArIGRlZyAtIHN0YXJ0RGVnICsgc3RhcnRWYWx1ZTtcbiAgZGF0YXMucHJldkRlZyA9IGFic29sdXRlRGVnIC0gbG9vcCAqIDM2MCArIHN0YXJ0RGVnIC0gc3RhcnRWYWx1ZTtcbiAgYWJzb2x1dGVEZWcgPSB0aHJvdHRsZShhYnNvbHV0ZURlZywgdGhyb3R0bGVSb3RhdGUpO1xuICB2YXIgZGlzdCA9IGRpcmVjdGlvbiAqIChhYnNvbHV0ZURlZyAtIHN0YXJ0VmFsdWUpO1xuXG4gIGlmIChpc1NuYXApIHtcbiAgICBkaXN0ID0gY2hlY2tTbmFwUm90YXRlKG1vdmVhYmxlLCBtb3ZlYWJsZVJlY3QsIGRhdGFzLm9yaWdpbiwgZGlzdCk7XG4gICAgYWJzb2x1dGVEZWcgPSBkaXN0IC8gZGlyZWN0aW9uICsgc3RhcnRWYWx1ZTtcbiAgfVxuXG4gIGRhdGFzLnByZXZTbmFwRGVnID0gYWJzb2x1dGVEZWcgLSBsb29wICogMzYwICsgc3RhcnREZWcgLSBzdGFydFZhbHVlO1xuICB2YXIgZGVsdGEgPSBkaXJlY3Rpb24gKiAoYWJzb2x1dGVEZWcgLSBhYnNvbHV0ZVByZXZTbmFwRGVnKTtcbiAgcmV0dXJuIFtkZWx0YSwgZGlzdCwgc3RhcnRWYWx1ZSArIGRpc3RdO1xufVxuXG5mdW5jdGlvbiBnZXRSb3RhdGVJbmZvKG1vdmVhYmxlLCBtb3ZlYWJsZVJlY3QsIGRhdGFzLCBkaXJlY3Rpb24sIGNsaWVudFgsIGNsaWVudFksIHN0YXJ0VmFsdWUsIHRocm90dGxlUm90YXRlKSB7XG4gIHJldHVybiBnZXREZWcobW92ZWFibGUsIG1vdmVhYmxlUmVjdCwgZGF0YXMsIGdldFJhZChkYXRhcy5zdGFydEFic29sdXRlT3JpZ2luLCBbY2xpZW50WCwgY2xpZW50WV0pIC8gTWF0aC5QSSAqIDE4MCwgZGlyZWN0aW9uLCBzdGFydFZhbHVlLCB0aHJvdHRsZVJvdGF0ZSwgdHJ1ZSk7XG59XG5mdW5jdGlvbiBnZXRSb3RhdGlvblBvc2l0aW9ucyhyb3RhdGlvblBvc2l0aW9uLCBfYSwgZGlyZWN0aW9uKSB7XG4gIHZhciBwb3MxID0gX2FbMF0sXG4gICAgICBwb3MyID0gX2FbMV0sXG4gICAgICBwb3MzID0gX2FbMl0sXG4gICAgICBwb3M0ID0gX2FbM107XG5cbiAgaWYgKHJvdGF0aW9uUG9zaXRpb24gPT09IFwibm9uZVwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIF9iID0gKHJvdGF0aW9uUG9zaXRpb24gfHwgXCJ0b3BcIikuc3BsaXQoXCItXCIpLFxuICAgICAgZGlyMSA9IF9iWzBdLFxuICAgICAgZGlyMiA9IF9iWzFdO1xuXG4gIHZhciByYWRQb3NlcyA9IFtwb3MxLCBwb3MyXTsgLy8gaWYgKHNjYWxlWzBdIDwgMCkge1xuICAvLyAgICAgZGlyMSA9IGdldFJldmVyc2VQb3NpdGlvblgoZGlyMSk7XG4gIC8vICAgICBkaXIyID0gZ2V0UmV2ZXJzZVBvc2l0aW9uWChkaXIyKTtcbiAgLy8gfVxuICAvLyBpZiAoc2NhbGVbMV0gPCAwKSB7XG4gIC8vICAgICBkaXIxID0gZ2V0UmV2ZXJzZVBvc2l0aW9uWShkaXIxKTtcbiAgLy8gICAgIGRpcjIgPSBnZXRSZXZlcnNlUG9zaXRpb25ZKGRpcjIpO1xuICAvLyB9XG5cbiAgaWYgKGRpcjEgPT09IFwibGVmdFwiKSB7XG4gICAgcmFkUG9zZXMgPSBbcG9zMywgcG9zMV07XG4gIH0gZWxzZSBpZiAoZGlyMSA9PT0gXCJyaWdodFwiKSB7XG4gICAgcmFkUG9zZXMgPSBbcG9zMiwgcG9zNF07XG4gIH0gZWxzZSBpZiAoZGlyMSA9PT0gXCJib3R0b21cIikge1xuICAgIHJhZFBvc2VzID0gW3BvczQsIHBvczNdO1xuICB9XG5cbiAgdmFyIHBvcyA9IFsocmFkUG9zZXNbMF1bMF0gKyByYWRQb3Nlc1sxXVswXSkgLyAyLCAocmFkUG9zZXNbMF1bMV0gKyByYWRQb3Nlc1sxXVsxXSkgLyAyXTtcbiAgdmFyIHJhZCA9IGdldFJvdGF0aW9uUmFkKHJhZFBvc2VzLCBkaXJlY3Rpb24pO1xuXG4gIGlmIChkaXIyKSB7XG4gICAgdmFyIGlzU3RhcnQgPSBkaXIyID09PSBcInRvcFwiIHx8IGRpcjIgPT09IFwibGVmdFwiO1xuICAgIHZhciBpc1JldmVyc2UgPSBkaXIxID09PSBcImJvdHRvbVwiIHx8IGRpcjEgPT09IFwibGVmdFwiO1xuICAgIHBvcyA9IHJhZFBvc2VzW2lzU3RhcnQgJiYgIWlzUmV2ZXJzZSB8fCAhaXNTdGFydCAmJiBpc1JldmVyc2UgPyAwIDogMV07XG4gIH1cblxuICByZXR1cm4gW3BvcywgcmFkXTtcbn1cbmZ1bmN0aW9uIGRyYWdDb250cm9sQ29uZGl0aW9uKG1vdmVhYmxlLCBlKSB7XG4gIGlmIChlLmlzUmVxdWVzdCkge1xuICAgIHJldHVybiBlLnJlcXVlc3RBYmxlID09PSBcInJvdGF0YWJsZVwiO1xuICB9XG5cbiAgdmFyIHRhcmdldCA9IGUuaW5wdXRFdmVudC50YXJnZXQ7XG5cbiAgaWYgKGhhc0NsYXNzKHRhcmdldCwgcHJlZml4KFwicm90YXRpb24tY29udHJvbFwiKSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciByb3RhdGlvblRhcmdldCA9IG1vdmVhYmxlLnByb3BzLnJvdGF0aW9uVGFyZ2V0O1xuXG4gIGlmIChyb3RhdGlvblRhcmdldCkge1xuICAgIHJldHVybiBnZXRSZWZUYXJnZXRzKHJvdGF0aW9uVGFyZ2V0LCB0cnVlKS5zb21lKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGFyZ2V0ID09PSBlbGVtZW50IHx8IHRhcmdldC5jb250YWlucyhlbGVtZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbnZhciBSb3RhdGFibGUgPSB7XG4gIG5hbWU6IFwicm90YXRhYmxlXCIsXG4gIGNhblBpbmNoOiB0cnVlLFxuICBwcm9wczoge1xuICAgIHJvdGF0YWJsZTogQm9vbGVhbixcbiAgICByb3RhdGlvblBvc2l0aW9uOiBTdHJpbmcsXG4gICAgdGhyb3R0bGVSb3RhdGU6IE51bWJlcixcbiAgICByZW5kZXJEaXJlY3Rpb25zOiBPYmplY3QsXG4gICAgcm90YXRpb25UYXJnZXQ6IE9iamVjdFxuICB9LFxuICBldmVudHM6IHtcbiAgICBvblJvdGF0ZVN0YXJ0OiBcInJvdGF0ZVN0YXJ0XCIsXG4gICAgb25Sb3RhdGU6IFwicm90YXRlXCIsXG4gICAgb25Sb3RhdGVFbmQ6IFwicm90YXRlRW5kXCIsXG4gICAgb25Sb3RhdGVHcm91cFN0YXJ0OiBcInJvdGF0ZUdyb3VwU3RhcnRcIixcbiAgICBvblJvdGF0ZUdyb3VwOiBcInJvdGF0ZUdyb3VwXCIsXG4gICAgb25Sb3RhdGVHcm91cEVuZDogXCJyb3RhdGVHcm91cEVuZFwiXG4gIH0sXG4gIGNzczogW1wiLnJvdGF0aW9uIHtcXG4gICAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgICAgICAgaGVpZ2h0OiA0MHB4O1xcbiAgICAgICAgICAgIHdpZHRoOiAxcHg7XFxuICAgICAgICAgICAgdHJhbnNmb3JtLW9yaWdpbjogNTAlIDEwMCU7XFxuICAgICAgICAgICAgaGVpZ2h0OiBjYWxjKDQwcHggKiB2YXIoLS16b29tKSk7XFxuICAgICAgICAgICAgdG9wOiBhdXRvO1xcbiAgICAgICAgICAgIGxlZnQ6IDA7XFxuICAgICAgICAgICAgYm90dG9tOiAxMDAlO1xcbiAgICAgICAgICAgIHdpbGwtY2hhbmdlOiB0cmFuc2Zvcm07XFxuICAgICAgICB9XFxuICAgICAgICAucm90YXRpb24gLnJvdGF0aW9uLWxpbmUge1xcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xcbiAgICAgICAgICAgIGhlaWdodDogMTAwJTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm0tb3JpZ2luOiA1MCUgNTAlO1xcbiAgICAgICAgfVxcbiAgICAgICAgLnJvdGF0aW9uIC5yb3RhdGlvbi1jb250cm9sIHtcXG4gICAgICAgICAgICBib3JkZXItY29sb3I6ICM0YWY7XFxuICAgICAgICAgICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1tb3ZlYWJsZS1jb2xvcik7XFxuICAgICAgICAgICAgYmFja2dyb3VuZDojZmZmO1xcbiAgICAgICAgICAgIGN1cnNvcjogYWxpYXM7XFxuICAgICAgICB9XCJdLFxuICByZW5kZXI6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgUmVhY3QpIHtcbiAgICB2YXIgX2EgPSBtb3ZlYWJsZS5wcm9wcyxcbiAgICAgICAgcm90YXRhYmxlID0gX2Eucm90YXRhYmxlLFxuICAgICAgICByb3RhdGlvblBvc2l0aW9uID0gX2Eucm90YXRpb25Qb3NpdGlvbixcbiAgICAgICAgem9vbSA9IF9hLnpvb20sXG4gICAgICAgIHJlbmRlckRpcmVjdGlvbnMgPSBfYS5yZW5kZXJEaXJlY3Rpb25zO1xuICAgIHZhciBfYiA9IG1vdmVhYmxlLnN0YXRlLFxuICAgICAgICByZW5kZXJQb3NlcyA9IF9iLnJlbmRlclBvc2VzLFxuICAgICAgICBkaXJlY3Rpb24gPSBfYi5kaXJlY3Rpb247XG5cbiAgICBpZiAoIXJvdGF0YWJsZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHBvc2l0aW9ucyA9IGdldFJvdGF0aW9uUG9zaXRpb25zKHJvdGF0aW9uUG9zaXRpb24sIHJlbmRlclBvc2VzLCBkaXJlY3Rpb24pO1xuICAgIHZhciBqc3hzID0gW107XG5cbiAgICBpZiAocG9zaXRpb25zKSB7XG4gICAgICB2YXIgcG9zID0gcG9zaXRpb25zWzBdLFxuICAgICAgICAgIHJhZCA9IHBvc2l0aW9uc1sxXTtcbiAgICAgIGpzeHMucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAga2V5OiBcInJvdGF0aW9uXCIsXG4gICAgICAgIGNsYXNzTmFtZTogcHJlZml4KFwicm90YXRpb25cIiksXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBtYXgtbGluZS1sZW5ndGhcbiAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKC01MCUpIHRyYW5zbGF0ZShcIiArIHBvc1swXSArIFwicHgsIFwiICsgcG9zWzFdICsgXCJweCkgcm90YXRlKFwiICsgcmFkICsgXCJyYWQpXCJcbiAgICAgICAgfVxuICAgICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogcHJlZml4KFwibGluZSByb3RhdGlvbi1saW5lXCIpLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIHRyYW5zZm9ybTogXCJzY2FsZVgoXCIgKyB6b29tICsgXCIpXCJcbiAgICAgICAgfVxuICAgICAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBjbGFzc05hbWU6IHByZWZpeChcImNvbnRyb2wgcm90YXRpb24tY29udHJvbFwiKSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKDAuNXB4KSBzY2FsZShcIiArIHpvb20gKyBcIilcIlxuICAgICAgICB9XG4gICAgICB9KSkpO1xuICAgIH1cblxuICAgIGlmIChyZW5kZXJEaXJlY3Rpb25zKSB7XG4gICAgICBqc3hzLnB1c2guYXBwbHkoanN4cywgcmVuZGVyRGlyZWN0aW9uQ29udHJvbHMobW92ZWFibGUsIFtdLCBSZWFjdCkpO1xuICAgIH1cblxuICAgIHJldHVybiBqc3hzO1xuICB9LFxuICBkcmFnQ29udHJvbENvbmRpdGlvbjogZHJhZ0NvbnRyb2xDb25kaXRpb24sXG4gIGRyYWdDb250cm9sU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBkYXRhcyA9IGUuZGF0YXMsXG4gICAgICAgIGNsaWVudFggPSBlLmNsaWVudFgsXG4gICAgICAgIGNsaWVudFkgPSBlLmNsaWVudFksXG4gICAgICAgIHBhcmVudFJvdGF0ZSA9IGUucGFyZW50Um90YXRlLFxuICAgICAgICBwYXJlbnRGbGFnID0gZS5wYXJlbnRGbGFnLFxuICAgICAgICBpc1BpbmNoID0gZS5pc1BpbmNoLFxuICAgICAgICBpc1JlcXVlc3QgPSBlLmlzUmVxdWVzdDtcbiAgICB2YXIgX2EgPSBtb3ZlYWJsZS5zdGF0ZSxcbiAgICAgICAgdGFyZ2V0ID0gX2EudGFyZ2V0LFxuICAgICAgICBsZWZ0ID0gX2EubGVmdCxcbiAgICAgICAgdG9wID0gX2EudG9wLFxuICAgICAgICBvcmlnaW4gPSBfYS5vcmlnaW4sXG4gICAgICAgIGJlZm9yZU9yaWdpbiA9IF9hLmJlZm9yZU9yaWdpbixcbiAgICAgICAgZGlyZWN0aW9uID0gX2EuZGlyZWN0aW9uLFxuICAgICAgICBiZWZvcmVEaXJlY3Rpb24gPSBfYS5iZWZvcmVEaXJlY3Rpb24sXG4gICAgICAgIHRhcmdldFRyYW5zZm9ybSA9IF9hLnRhcmdldFRyYW5zZm9ybSxcbiAgICAgICAgbW92ZWFibGVDbGllbnRSZWN0ID0gX2EubW92ZWFibGVDbGllbnRSZWN0O1xuXG4gICAgaWYgKCFpc1JlcXVlc3QgJiYgIXRhcmdldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciByZWN0ID0gbW92ZWFibGUuZ2V0UmVjdCgpO1xuICAgIGRhdGFzLnJlY3QgPSByZWN0O1xuICAgIGRhdGFzLnRyYW5zZm9ybSA9IHRhcmdldFRyYW5zZm9ybTtcbiAgICBkYXRhcy5sZWZ0ID0gbGVmdDtcbiAgICBkYXRhcy50b3AgPSB0b3A7XG4gICAgZGF0YXMuZml4ZWRQb3NpdGlvbiA9IGdldERpcmVjdGlvbk9mZnNldChtb3ZlYWJsZSwgZ2V0T3JpZ2luRGlyZWN0aW9uKG1vdmVhYmxlKSk7XG4gICAgZGF0YXMuYWJzb2x1dGVJbmZvID0ge1xuICAgICAgb3JpZ2luOiByZWN0Lm9yaWdpbixcbiAgICAgIHN0YXJ0VmFsdWU6IHJlY3Qucm90YXRpb25cbiAgICB9O1xuICAgIHNldFJvdGF0ZVN0YXJ0SW5mbyhtb3ZlYWJsZSwgZGF0YXMuYWJzb2x1dGVJbmZvLCBjbGllbnRYLCBjbGllbnRZLCBvcmlnaW4sIG1vdmVhYmxlQ2xpZW50UmVjdCk7XG5cbiAgICBpZiAoaXNSZXF1ZXN0IHx8IGlzUGluY2ggfHwgcGFyZW50RmxhZykge1xuICAgICAgdmFyIGV4dGVybmFsUm90YXRlID0gcGFyZW50Um90YXRlIHx8IDA7XG4gICAgICBkYXRhcy5iZWZvcmVJbmZvID0ge1xuICAgICAgICBvcmlnaW46IHJlY3QuYmVmb3JlT3JpZ2luLFxuICAgICAgICBwcmV2RGVnOiBleHRlcm5hbFJvdGF0ZSxcbiAgICAgICAgc3RhcnREZWc6IGV4dGVybmFsUm90YXRlLFxuICAgICAgICBwcmV2U25hcERlZzogZXh0ZXJuYWxSb3RhdGUsXG4gICAgICAgIGxvb3A6IDBcbiAgICAgIH07XG4gICAgICBkYXRhcy5hZnRlckluZm8gPSB7XG4gICAgICAgIG9yaWdpbjogcmVjdC5vcmlnaW4sXG4gICAgICAgIHByZXZEZWc6IGV4dGVybmFsUm90YXRlLFxuICAgICAgICBzdGFydERlZzogZXh0ZXJuYWxSb3RhdGUsXG4gICAgICAgIHByZXZTbmFwRGVnOiBleHRlcm5hbFJvdGF0ZSxcbiAgICAgICAgbG9vcDogMFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YXMuYmVmb3JlSW5mbyA9IHtcbiAgICAgICAgb3JpZ2luOiByZWN0LmJlZm9yZU9yaWdpblxuICAgICAgfTtcbiAgICAgIGRhdGFzLmFmdGVySW5mbyA9IHtcbiAgICAgICAgb3JpZ2luOiByZWN0Lm9yaWdpblxuICAgICAgfTtcbiAgICAgIHNldFJvdGF0ZVN0YXJ0SW5mbyhtb3ZlYWJsZSwgZGF0YXMuYmVmb3JlSW5mbywgY2xpZW50WCwgY2xpZW50WSwgYmVmb3JlT3JpZ2luLCBtb3ZlYWJsZUNsaWVudFJlY3QpO1xuICAgICAgc2V0Um90YXRlU3RhcnRJbmZvKG1vdmVhYmxlLCBkYXRhcy5hZnRlckluZm8sIGNsaWVudFgsIGNsaWVudFksIG9yaWdpbiwgbW92ZWFibGVDbGllbnRSZWN0KTtcbiAgICB9XG5cbiAgICBkYXRhcy5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgZGF0YXMuYmVmb3JlRGlyZWN0aW9uID0gYmVmb3JlRGlyZWN0aW9uO1xuICAgIGRhdGFzLnN0YXJ0VmFsdWUgPSAwO1xuICAgIGRhdGFzLmRhdGFzID0ge307XG4gICAgc2V0RGVmYXVsdFRyYW5zZm9ybUluZGV4KGUsIFwicm90YXRlXCIpO1xuICAgIHZhciBwYXJhbXMgPSBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCBfX2Fzc2lnbihfX2Fzc2lnbih7XG4gICAgICBzZXQ6IGZ1bmN0aW9uIChyb3RhdGF0aW9uKSB7XG4gICAgICAgIGRhdGFzLnN0YXJ0VmFsdWUgPSByb3RhdGF0aW9uICogTWF0aC5QSSAvIDE4MDtcbiAgICAgIH1cbiAgICB9LCBmaWxsVHJhbnNmb3JtU3RhcnRFdmVudChlKSksIHtcbiAgICAgIGRyYWdTdGFydDogRHJhZ2dhYmxlLmRyYWdTdGFydChtb3ZlYWJsZSwgbmV3IEN1c3RvbUdlc3RvKCkuZHJhZ1N0YXJ0KFswLCAwXSwgZSkpXG4gICAgfSkpO1xuICAgIHZhciByZXN1bHQgPSB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25Sb3RhdGVTdGFydFwiLCBwYXJhbXMpO1xuICAgIGRhdGFzLmlzUm90YXRlID0gcmVzdWx0ICE9PSBmYWxzZTtcbiAgICBtb3ZlYWJsZS5zdGF0ZS5zbmFwUmVuZGVySW5mbyA9IHtcbiAgICAgIHJlcXVlc3Q6IGUuaXNSZXF1ZXN0XG4gICAgfTtcbiAgICByZXR1cm4gZGF0YXMuaXNSb3RhdGUgPyBwYXJhbXMgOiBmYWxzZTtcbiAgfSxcbiAgZHJhZ0NvbnRyb2w6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qO1xuXG4gICAgdmFyIGRhdGFzID0gZS5kYXRhcyxcbiAgICAgICAgY2xpZW50WCA9IGUuY2xpZW50WCxcbiAgICAgICAgY2xpZW50WSA9IGUuY2xpZW50WSxcbiAgICAgICAgcGFyZW50Um90YXRlID0gZS5wYXJlbnRSb3RhdGUsXG4gICAgICAgIHBhcmVudEZsYWcgPSBlLnBhcmVudEZsYWcsXG4gICAgICAgIGlzUGluY2ggPSBlLmlzUGluY2gsXG4gICAgICAgIGdyb3VwRGVsdGEgPSBlLmdyb3VwRGVsdGE7XG4gICAgdmFyIGJlZm9yZURpcmVjdGlvbiA9IGRhdGFzLmJlZm9yZURpcmVjdGlvbixcbiAgICAgICAgYmVmb3JlSW5mbyA9IGRhdGFzLmJlZm9yZUluZm8sXG4gICAgICAgIGFmdGVySW5mbyA9IGRhdGFzLmFmdGVySW5mbyxcbiAgICAgICAgYWJzb2x1dGVJbmZvID0gZGF0YXMuYWJzb2x1dGVJbmZvLFxuICAgICAgICBpc1JvdGF0ZSA9IGRhdGFzLmlzUm90YXRlLFxuICAgICAgICBzdGFydFZhbHVlID0gZGF0YXMuc3RhcnRWYWx1ZSxcbiAgICAgICAgcmVjdCA9IGRhdGFzLnJlY3Q7XG5cbiAgICBpZiAoIWlzUm90YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmVzb2x2ZVRyYW5zZm9ybUV2ZW50KGUsIFwicm90YXRlXCIpO1xuICAgIHZhciB0YXJnZXREaXJlY3Rpb24gPSBnZXRUcmFuc2Zvcm1EaXJlY3Rpb24oZSk7XG4gICAgdmFyIGRpcmVjdGlvbiA9IGJlZm9yZURpcmVjdGlvbiAqIHRhcmdldERpcmVjdGlvbjtcbiAgICB2YXIgX2sgPSBtb3ZlYWJsZS5wcm9wcyxcbiAgICAgICAgX2wgPSBfay50aHJvdHRsZVJvdGF0ZSxcbiAgICAgICAgdGhyb3R0bGVSb3RhdGUgPSBfbCA9PT0gdm9pZCAwID8gMCA6IF9sLFxuICAgICAgICBwYXJlbnRNb3ZlYWJsZSA9IF9rLnBhcmVudE1vdmVhYmxlO1xuICAgIHZhciBkZWx0YTtcbiAgICB2YXIgZGlzdDtcbiAgICB2YXIgcm90YXRlO1xuICAgIHZhciBiZWZvcmVEZWx0YTtcbiAgICB2YXIgYmVmb3JlRGlzdDtcbiAgICB2YXIgYmVmb3JlUm90YXRlO1xuICAgIHZhciBhYnNvbHV0ZURlbHRhO1xuICAgIHZhciBhYnNvbHV0ZURpc3Q7XG4gICAgdmFyIGFic29sdXRlUm90YXRlO1xuICAgIHZhciBzdGFydERlZyA9IDE4MCAvIE1hdGguUEkgKiBzdGFydFZhbHVlO1xuICAgIHZhciBhYnNvbHV0ZVN0YXJ0RGVnID0gYWJzb2x1dGVJbmZvLnN0YXJ0VmFsdWU7XG5cbiAgICBpZiAoIXBhcmVudEZsYWcgJiYgXCJwYXJlbnREaXN0XCIgaW4gZSkge1xuICAgICAgdmFyIHBhcmVudERpc3QgPSBlLnBhcmVudERpc3Q7XG4gICAgICBfYSA9IGdldFBhcmVudERlZyhtb3ZlYWJsZSwgcmVjdCwgYWZ0ZXJJbmZvLCBwYXJlbnREaXN0LCBkaXJlY3Rpb24sIHN0YXJ0RGVnKSwgZGVsdGEgPSBfYVswXSwgZGlzdCA9IF9hWzFdLCByb3RhdGUgPSBfYVsyXTtcbiAgICAgIF9iID0gZ2V0UGFyZW50RGVnKG1vdmVhYmxlLCByZWN0LCBiZWZvcmVJbmZvLCBwYXJlbnREaXN0LCBiZWZvcmVEaXJlY3Rpb24sIHN0YXJ0RGVnKSwgYmVmb3JlRGVsdGEgPSBfYlswXSwgYmVmb3JlRGlzdCA9IF9iWzFdLCBiZWZvcmVSb3RhdGUgPSBfYlsyXTtcbiAgICAgIF9jID0gZ2V0UGFyZW50RGVnKG1vdmVhYmxlLCByZWN0LCBhYnNvbHV0ZUluZm8sIHBhcmVudERpc3QsIGRpcmVjdGlvbiwgYWJzb2x1dGVTdGFydERlZyksIGFic29sdXRlRGVsdGEgPSBfY1swXSwgYWJzb2x1dGVEaXN0ID0gX2NbMV0sIGFic29sdXRlUm90YXRlID0gX2NbMl07XG4gICAgfSBlbHNlIGlmIChpc1BpbmNoIHx8IHBhcmVudEZsYWcpIHtcbiAgICAgIF9kID0gZ2V0RGVnKG1vdmVhYmxlLCByZWN0LCBhZnRlckluZm8sIHBhcmVudFJvdGF0ZSwgZGlyZWN0aW9uLCBzdGFydERlZywgdGhyb3R0bGVSb3RhdGUpLCBkZWx0YSA9IF9kWzBdLCBkaXN0ID0gX2RbMV0sIHJvdGF0ZSA9IF9kWzJdO1xuICAgICAgX2UgPSBnZXREZWcobW92ZWFibGUsIHJlY3QsIGJlZm9yZUluZm8sIHBhcmVudFJvdGF0ZSwgYmVmb3JlRGlyZWN0aW9uLCBzdGFydERlZywgdGhyb3R0bGVSb3RhdGUpLCBiZWZvcmVEZWx0YSA9IF9lWzBdLCBiZWZvcmVEaXN0ID0gX2VbMV0sIGJlZm9yZVJvdGF0ZSA9IF9lWzJdO1xuICAgICAgX2YgPSBnZXREZWcobW92ZWFibGUsIHJlY3QsIGFic29sdXRlSW5mbywgcGFyZW50Um90YXRlLCBkaXJlY3Rpb24sIGFic29sdXRlU3RhcnREZWcsIHRocm90dGxlUm90YXRlKSwgYWJzb2x1dGVEZWx0YSA9IF9mWzBdLCBhYnNvbHV0ZURpc3QgPSBfZlsxXSwgYWJzb2x1dGVSb3RhdGUgPSBfZlsyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2cgPSBnZXRSb3RhdGVJbmZvKG1vdmVhYmxlLCByZWN0LCBhZnRlckluZm8sIGRpcmVjdGlvbiwgY2xpZW50WCwgY2xpZW50WSwgc3RhcnREZWcsIHRocm90dGxlUm90YXRlKSwgZGVsdGEgPSBfZ1swXSwgZGlzdCA9IF9nWzFdLCByb3RhdGUgPSBfZ1syXTtcbiAgICAgIF9oID0gZ2V0Um90YXRlSW5mbyhtb3ZlYWJsZSwgcmVjdCwgYmVmb3JlSW5mbywgYmVmb3JlRGlyZWN0aW9uLCBjbGllbnRYLCBjbGllbnRZLCBzdGFydERlZywgdGhyb3R0bGVSb3RhdGUpLCBiZWZvcmVEZWx0YSA9IF9oWzBdLCBiZWZvcmVEaXN0ID0gX2hbMV0sIGJlZm9yZVJvdGF0ZSA9IF9oWzJdO1xuICAgICAgX2ogPSBnZXRSb3RhdGVJbmZvKG1vdmVhYmxlLCByZWN0LCBhYnNvbHV0ZUluZm8sIGRpcmVjdGlvbiwgY2xpZW50WCwgY2xpZW50WSwgYWJzb2x1dGVTdGFydERlZywgdGhyb3R0bGVSb3RhdGUpLCBhYnNvbHV0ZURlbHRhID0gX2pbMF0sIGFic29sdXRlRGlzdCA9IF9qWzFdLCBhYnNvbHV0ZVJvdGF0ZSA9IF9qWzJdO1xuICAgIH1cblxuICAgIGlmICghYWJzb2x1dGVEZWx0YSAmJiAhZGVsdGEgJiYgIWJlZm9yZURlbHRhICYmICFwYXJlbnRNb3ZlYWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0VHJhbnNmb3JtID0gY29udmVydFRyYW5zZm9ybUZvcm1hdChkYXRhcywgXCJyb3RhdGUoXCIgKyByb3RhdGUgKyBcImRlZylcIiwgXCJyb3RhdGUoXCIgKyBkaXN0ICsgXCJkZWcpXCIpO1xuICAgIHZhciBpbnZlcnNlRGlzdCA9IGdldFJvdGF0ZURpc3QobW92ZWFibGUsIGRpc3QsIGRhdGFzLmZpeGVkUG9zaXRpb24sIGRhdGFzKTtcbiAgICB2YXIgaW52ZXJzZURlbHRhID0gbWludXMocGx1cyhncm91cERlbHRhIHx8IFswLCAwXSwgaW52ZXJzZURpc3QpLCBkYXRhcy5wcmV2SW52ZXJzZURpc3QgfHwgWzAsIDBdKTtcbiAgICBkYXRhcy5wcmV2SW52ZXJzZURpc3QgPSBpbnZlcnNlRGlzdDtcbiAgICB2YXIgcGFyYW1zID0gZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwgX19hc3NpZ24oe1xuICAgICAgZGVsdGE6IGRlbHRhLFxuICAgICAgZGlzdDogZGlzdCxcbiAgICAgIHJvdGF0ZTogcm90YXRlLFxuICAgICAgYmVmb3JlRGlzdDogYmVmb3JlRGlzdCxcbiAgICAgIGJlZm9yZURlbHRhOiBiZWZvcmVEZWx0YSxcbiAgICAgIGJlZm9yZVJvdGF0ZTogYmVmb3JlUm90YXRlLFxuICAgICAgYWJzb2x1dGVEaXN0OiBhYnNvbHV0ZURpc3QsXG4gICAgICBhYnNvbHV0ZURlbHRhOiBhYnNvbHV0ZURlbHRhLFxuICAgICAgYWJzb2x1dGVSb3RhdGU6IGFic29sdXRlUm90YXRlLFxuICAgICAgaXNQaW5jaDogISFpc1BpbmNoXG4gICAgfSwgZmlsbFRyYW5zZm9ybUV2ZW50KG1vdmVhYmxlLCBuZXh0VHJhbnNmb3JtLCBpbnZlcnNlRGVsdGEsIGlzUGluY2gsIGUpKSk7XG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUm90YXRlXCIsIHBhcmFtcyk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfSxcbiAgZHJhZ0NvbnRyb2xFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBkYXRhcyA9IGUuZGF0YXM7XG5cbiAgICBpZiAoIWRhdGFzLmlzUm90YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGF0YXMuaXNSb3RhdGUgPSBmYWxzZTtcbiAgICB2YXIgcGFyYW1zID0gZmlsbEVuZFBhcmFtcyhtb3ZlYWJsZSwgZSwge30pO1xuICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvblJvdGF0ZUVuZFwiLCBwYXJhbXMpO1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH0sXG4gIGRyYWdHcm91cENvbnRyb2xDb25kaXRpb246IGRyYWdDb250cm9sQ29uZGl0aW9uLFxuICBkcmFnR3JvdXBDb250cm9sU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBkYXRhcyA9IGUuZGF0YXM7XG4gICAgdmFyIF9hID0gbW92ZWFibGUuc3RhdGUsXG4gICAgICAgIHBhcmVudExlZnQgPSBfYS5sZWZ0LFxuICAgICAgICBwYXJlbnRUb3AgPSBfYS50b3AsXG4gICAgICAgIHBhcmVudEJlZm9yZU9yaWdpbiA9IF9hLmJlZm9yZU9yaWdpbjtcbiAgICB2YXIgcGFyYW1zID0gdGhpcy5kcmFnQ29udHJvbFN0YXJ0KG1vdmVhYmxlLCBlKTtcblxuICAgIGlmICghcGFyYW1zKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcGFyYW1zLnNldChkYXRhcy5iZWZvcmVEaXJlY3Rpb24gKiBtb3ZlYWJsZS5yb3RhdGlvbik7XG4gICAgdmFyIGV2ZW50cyA9IHRyaWdnZXJDaGlsZEFibGVzKG1vdmVhYmxlLCB0aGlzLCBcImRyYWdDb250cm9sU3RhcnRcIiwgZSwgZnVuY3Rpb24gKGNoaWxkLCBldikge1xuICAgICAgdmFyIF9hID0gY2hpbGQuc3RhdGUsXG4gICAgICAgICAgbGVmdCA9IF9hLmxlZnQsXG4gICAgICAgICAgdG9wID0gX2EudG9wLFxuICAgICAgICAgIGJlZm9yZU9yaWdpbiA9IF9hLmJlZm9yZU9yaWdpbjtcbiAgICAgIHZhciBjaGlsZENsaWVudCA9IHBsdXMobWludXMoW2xlZnQsIHRvcF0sIFtwYXJlbnRMZWZ0LCBwYXJlbnRUb3BdKSwgbWludXMoYmVmb3JlT3JpZ2luLCBwYXJlbnRCZWZvcmVPcmlnaW4pKTtcbiAgICAgIGV2LmRhdGFzLmdyb3VwQ2xpZW50ID0gY2hpbGRDbGllbnQ7XG4gICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGV2KSwge1xuICAgICAgICBwYXJlbnRSb3RhdGU6IDBcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdmFyIG5leHRQYXJhbXMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcGFyYW1zKSwge1xuICAgICAgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0cyxcbiAgICAgIGV2ZW50czogZXZlbnRzXG4gICAgfSk7XG5cbiAgICB2YXIgcmVzdWx0ID0gdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUm90YXRlR3JvdXBTdGFydFwiLCBuZXh0UGFyYW1zKTtcbiAgICBkYXRhcy5pc1JvdGF0ZSA9IHJlc3VsdCAhPT0gZmFsc2U7XG4gICAgcmV0dXJuIGRhdGFzLmlzUm90YXRlID8gcGFyYW1zIDogZmFsc2U7XG4gIH0sXG4gIGRyYWdHcm91cENvbnRyb2w6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBkYXRhcyA9IGUuZGF0YXM7XG5cbiAgICBpZiAoIWRhdGFzLmlzUm90YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBhcmFtcyA9IHRoaXMuZHJhZ0NvbnRyb2wobW92ZWFibGUsIGUpO1xuXG4gICAgaWYgKCFwYXJhbXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGlyZWN0aW9uID0gZGF0YXMuYmVmb3JlRGlyZWN0aW9uO1xuICAgIHZhciBwYXJlbnRSb3RhdGUgPSBwYXJhbXMuYmVmb3JlRGlzdDtcbiAgICB2YXIgZGVnID0gcGFyYW1zLmJlZm9yZURlbHRhO1xuICAgIHZhciByYWQgPSBkZWcgLyAxODAgKiBNYXRoLlBJO1xuICAgIHZhciBldmVudHMgPSB0cmlnZ2VyQ2hpbGRBYmxlcyhtb3ZlYWJsZSwgdGhpcywgXCJkcmFnQ29udHJvbFwiLCBlLCBmdW5jdGlvbiAoXywgZXYpIHtcbiAgICAgIHZhciBfYSA9IGV2LmRhdGFzLmdyb3VwQ2xpZW50LFxuICAgICAgICAgIHByZXZYID0gX2FbMF0sXG4gICAgICAgICAgcHJldlkgPSBfYVsxXTtcblxuICAgICAgdmFyIF9iID0gcm90YXRlKFtwcmV2WCwgcHJldlldLCByYWQgKiBkaXJlY3Rpb24pLFxuICAgICAgICAgIGNsaWVudFggPSBfYlswXSxcbiAgICAgICAgICBjbGllbnRZID0gX2JbMV07XG5cbiAgICAgIHZhciBkZWx0YSA9IFtjbGllbnRYIC0gcHJldlgsIGNsaWVudFkgLSBwcmV2WV07XG4gICAgICBldi5kYXRhcy5ncm91cENsaWVudCA9IFtjbGllbnRYLCBjbGllbnRZXTtcbiAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZXYpLCB7XG4gICAgICAgIHBhcmVudFJvdGF0ZTogcGFyZW50Um90YXRlLFxuICAgICAgICBncm91cERlbHRhOiBkZWx0YVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgbW92ZWFibGUucm90YXRpb24gPSBkaXJlY3Rpb24gKiBwYXJhbXMuYmVmb3JlUm90YXRlO1xuXG4gICAgdmFyIG5leHRQYXJhbXMgPSBfX2Fzc2lnbih7XG4gICAgICB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzLFxuICAgICAgZXZlbnRzOiBldmVudHMsXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChyb3RhdGlvbikge1xuICAgICAgICBtb3ZlYWJsZS5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgICAgfVxuICAgIH0sIHBhcmFtcyk7XG5cbiAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25Sb3RhdGVHcm91cFwiLCBuZXh0UGFyYW1zKTtcbiAgICByZXR1cm4gbmV4dFBhcmFtcztcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIGlzRHJhZyA9IGUuaXNEcmFnLFxuICAgICAgICBkYXRhcyA9IGUuZGF0YXM7XG5cbiAgICBpZiAoIWRhdGFzLmlzUm90YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5kcmFnQ29udHJvbEVuZChtb3ZlYWJsZSwgZSk7XG4gICAgdmFyIGV2ZW50cyA9IHRyaWdnZXJDaGlsZEFibGVzKG1vdmVhYmxlLCB0aGlzLCBcImRyYWdDb250cm9sRW5kXCIsIGUpO1xuICAgIHZhciBuZXh0UGFyYW1zID0gZmlsbEVuZFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xuICAgICAgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0cyxcbiAgICAgIGV2ZW50czogZXZlbnRzXG4gICAgfSk7XG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUm90YXRlR3JvdXBFbmRcIiwgbmV4dFBhcmFtcyk7XG4gICAgcmV0dXJuIGlzRHJhZztcbiAgfSxcblxuICAvKipcbiAgICogQG1ldGhvZCBNb3ZlYWJsZS5Sb3RhdGFibGUjcmVxdWVzdFxuICAgKiBAcGFyYW0ge29iamVjdH0gW2VdIC0gdGhlIFJlc2l6YWJsZSdzIHJlcXVlc3QgcGFyYW1ldGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZS5kZWx0YVJvdGF0ZT0wXSAtICBkZWx0YSBudW1iZXIgb2Ygcm90YXRpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtlLnJvdGF0ZT0wXSAtIGFic29sdXRlIG51bWJlciBvZiBtb3ZlYWJsZSdzIHJvdGF0aW9uXG4gICAqIEByZXR1cm4ge01vdmVhYmxlLlJlcXVlc3Rlcn0gTW92ZWFibGUgUmVxdWVzdGVyXG4gICAqIEBleGFtcGxlXG4gICAgKiAvLyBJbnN0YW50bHkgUmVxdWVzdCAocmVxdWVzdFN0YXJ0IC0gcmVxdWVzdCAtIHJlcXVlc3RFbmQpXG4gICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJyb3RhdGFibGVcIiwgeyBkZWx0YVJvdGF0ZTogMTAgfSwgdHJ1ZSk7XG4gICAqXG4gICAqICogbW92ZWFibGUucmVxdWVzdChcInJvdGF0YWJsZVwiLCB7IHJvdGF0ZTogMTAgfSwgdHJ1ZSk7XG4gICAqXG4gICAqIC8vIHJlcXVlc3RTdGFydFxuICAgKiBjb25zdCByZXF1ZXN0ZXIgPSBtb3ZlYWJsZS5yZXF1ZXN0KFwicm90YXRhYmxlXCIpO1xuICAgKlxuICAgKiAvLyByZXF1ZXN0XG4gICAqIHJlcXVlc3Rlci5yZXF1ZXN0KHsgZGVsdGFSb3RhdGU6IDEwIH0pO1xuICAgKiByZXF1ZXN0ZXIucmVxdWVzdCh7IGRlbHRhUm90YXRlOiAxMCB9KTtcbiAgICogcmVxdWVzdGVyLnJlcXVlc3QoeyBkZWx0YVJvdGF0ZTogMTAgfSk7XG4gICAqXG4gICAqIHJlcXVlc3Rlci5yZXF1ZXN0KHsgcm90YXRlOiAxMCB9KTtcbiAgICogcmVxdWVzdGVyLnJlcXVlc3QoeyByb3RhdGU6IDIwIH0pO1xuICAgKiByZXF1ZXN0ZXIucmVxdWVzdCh7IHJvdGF0ZTogMzAgfSk7XG4gICAqXG4gICAqIC8vIHJlcXVlc3RFbmRcbiAgICogcmVxdWVzdGVyLnJlcXVlc3RFbmQoKTtcbiAgICovXG4gIHJlcXVlc3Q6IGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xuICAgIHZhciBkYXRhcyA9IHt9O1xuICAgIHZhciBkaXN0Um90YXRlID0gMDtcbiAgICB2YXIgc3RhcnRSb3RhdGlvbiA9IG1vdmVhYmxlLmdldFJvdGF0aW9uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzQ29udHJvbDogdHJ1ZSxcbiAgICAgIHJlcXVlc3RTdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGFzOiBkYXRhc1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHJlcXVlc3Q6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChcImRlbHRhUm90YXRlXCIgaW4gZSkge1xuICAgICAgICAgIGRpc3RSb3RhdGUgKz0gZS5kZWx0YVJvdGF0ZTtcbiAgICAgICAgfSBlbHNlIGlmIChcInJvdGF0ZVwiIGluIGUpIHtcbiAgICAgICAgICBkaXN0Um90YXRlID0gZS5yb3RhdGUgLSBzdGFydFJvdGF0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhczogZGF0YXMsXG4gICAgICAgICAgcGFyZW50RGlzdDogZGlzdFJvdGF0ZVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHJlcXVlc3RFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhczogZGF0YXMsXG4gICAgICAgICAgaXNEcmFnOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcbi8qKlxuICogV2hldGhlciBvciBub3QgdGFyZ2V0IGNhbiBiZSByb3RhdGVkLiAoZGVmYXVsdDogZmFsc2UpXG4gKiBAbmFtZSBNb3ZlYWJsZS5Sb3RhdGFibGUjcm90YXRhYmxlXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICpcbiAqIG1vdmVhYmxlLnJvdGF0YWJsZSA9IHRydWU7XG4gKi9cblxuLyoqXG4gKiBZb3UgY2FuIHNwZWNpZnkgdGhlIHBvc2l0aW9uIG9mIHRoZSByb3RhdGlvbi4gKGRlZmF1bHQ6IFwidG9wXCIpXG4gKiBAbmFtZSBNb3ZlYWJsZS5Sb3RhdGFibGUjcm90YXRpb25Qb3NpdGlvblxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgIHJvdGF0aW9uUG9zaXRpb246IFwidG9wXCIsXG4gKiB9KTtcbiAqXG4gKiBtb3ZlYWJsZS5yb3RhdGlvblBvc2l0aW9uID0gXCJib3R0b21cIlxuICovXG5cbi8qKlxuICogdGhyb3R0bGUgb2YgYW5nbGUoZGVncmVlKSB3aGVuIHJvdGF0ZS5cbiAqIEBuYW1lIE1vdmVhYmxlLlJvdGF0YWJsZSN0aHJvdHRsZVJvdGF0ZVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcbiAqXG4gKiBtb3ZlYWJsZS50aHJvdHRsZVJvdGF0ZSA9IDE7XG4gKi9cblxuLyoqXG4gKiBXaGVuIHRoZSByb3RhdGUgc3RhcnRzLCB0aGUgcm90YXRlU3RhcnQgZXZlbnQgaXMgY2FsbGVkLlxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlJvdGF0YWJsZVxuICogQGV2ZW50IHJvdGF0ZVN0YXJ0XG4gKiBAcGFyYW0ge01vdmVhYmxlLlJvdGF0YWJsZS5PblJvdGF0ZVN0YXJ0fSAtIFBhcmFtZXRlcnMgZm9yIHRoZSByb3RhdGVTdGFydCBldmVudFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7IHJvdGF0YWJsZTogdHJ1ZSB9KTtcbiAqIG1vdmVhYmxlLm9uKFwicm90YXRlU3RhcnRcIiwgKHsgdGFyZ2V0IH0pID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyh0YXJnZXQpO1xuICogfSk7XG4gKi9cblxuLyoqXG4qIFdoZW4gcm90YXRpbmcsIHRoZSByb3RhdGUgZXZlbnQgaXMgY2FsbGVkLlxuKiBAbWVtYmVyb2YgTW92ZWFibGUuUm90YXRhYmxlXG4qIEBldmVudCByb3RhdGVcbiogQHBhcmFtIHtNb3ZlYWJsZS5Sb3RhdGFibGUuT25Sb3RhdGV9IC0gUGFyYW1ldGVycyBmb3IgdGhlIHJvdGF0ZSBldmVudFxuKiBAZXhhbXBsZVxuKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4qXG4qIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHsgcm90YXRhYmxlOiB0cnVlIH0pO1xuKiBtb3ZlYWJsZS5vbihcInJvdGF0ZVwiLCAoeyB0YXJnZXQsIHRyYW5zZm9ybSwgZGlzdCB9KSA9PiB7XG4qICAgICB0YXJnZXQuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuKiB9KTtcbiovXG5cbi8qKlxuICogV2hlbiB0aGUgcm90YXRlIGZpbmlzaGVzLCB0aGUgcm90YXRlRW5kIGV2ZW50IGlzIGNhbGxlZC5cbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5Sb3RhdGFibGVcbiAqIEBldmVudCByb3RhdGVFbmRcbiAqIEBwYXJhbSB7TW92ZWFibGUuUm90YXRhYmxlLk9uUm90YXRlRW5kfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSByb3RhdGVFbmQgZXZlbnRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwgeyByb3RhdGFibGU6IHRydWUgfSk7XG4gKiBtb3ZlYWJsZS5vbihcInJvdGF0ZUVuZFwiLCAoeyB0YXJnZXQsIGlzRHJhZyB9KSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2codGFyZ2V0LCBpc0RyYWcpO1xuICogfSk7XG4gKi9cblxuLyoqXG4gKiBXaGVuIHRoZSBncm91cCByb3RhdGUgc3RhcnRzLCB0aGUgYHJvdGF0ZUdyb3VwU3RhcnRgIGV2ZW50IGlzIGNhbGxlZC5cbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5Sb3RhdGFibGVcbiAqIEBldmVudCByb3RhdGVHcm91cFN0YXJ0XG4gKiBAcGFyYW0ge01vdmVhYmxlLlJvdGF0YWJsZS5PblJvdGF0ZUdyb3VwU3RhcnR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGByb3RhdGVHcm91cFN0YXJ0YCBldmVudFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgdGFyZ2V0OiBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFyZ2V0XCIpKSxcbiAqICAgICByb3RhdGFibGU6IHRydWVcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJyb3RhdGVHcm91cFN0YXJ0XCIsICh7IHRhcmdldHMgfSkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKFwib25Sb3RhdGVHcm91cFN0YXJ0XCIsIHRhcmdldHMpO1xuICogfSk7XG4gKi9cblxuLyoqXG4qIFdoZW4gdGhlIGdyb3VwIHJvdGF0ZSwgdGhlIGByb3RhdGVHcm91cGAgZXZlbnQgaXMgY2FsbGVkLlxuKiBAbWVtYmVyb2YgTW92ZWFibGUuUm90YXRhYmxlXG4qIEBldmVudCByb3RhdGVHcm91cFxuKiBAcGFyYW0ge01vdmVhYmxlLlJvdGF0YWJsZS5PblJvdGF0ZUdyb3VwfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgcm90YXRlR3JvdXBgIGV2ZW50XG4qIEBleGFtcGxlXG4qIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbipcbiogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuKiAgICAgdGFyZ2V0OiBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFyZ2V0XCIpKSxcbiogICAgIHJvdGF0YWJsZTogdHJ1ZVxuKiB9KTtcbiogbW92ZWFibGUub24oXCJyb3RhdGVHcm91cFwiLCAoeyB0YXJnZXRzLCBldmVudHMgfSkgPT4ge1xuKiAgICAgY29uc29sZS5sb2coXCJvblJvdGF0ZUdyb3VwXCIsIHRhcmdldHMpO1xuKiAgICAgZXZlbnRzLmZvckVhY2goZXYgPT4ge1xuKiAgICAgICAgIGNvbnN0IHRhcmdldCA9IGV2LnRhcmdldDtcbiogICAgICAgICAvLyBldi5kcmFnIGlzIGEgZHJhZyBldmVudCB0aGF0IG9jY3VycyB3aGVuIHRoZSBncm91cCByb3RhdGUuXG4qICAgICAgICAgY29uc3QgbGVmdCA9IGV2LmRyYWcuYmVmb3JlRGlzdFswXTtcbiogICAgICAgICBjb25zdCB0b3AgPSBldi5kcmFnLmJlZm9yZURpc3RbMV07XG4qICAgICAgICAgY29uc3QgZGVnID0gZXYuYmVmb3JlRGlzdDtcbiogICAgIH0pO1xuKiB9KTtcbiovXG5cbi8qKlxuICogV2hlbiB0aGUgZ3JvdXAgcm90YXRlIGZpbmlzaGVzLCB0aGUgYHJvdGF0ZUdyb3VwRW5kYCBldmVudCBpcyBjYWxsZWQuXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuUm90YXRhYmxlXG4gKiBAZXZlbnQgcm90YXRlR3JvdXBFbmRcbiAqIEBwYXJhbSB7TW92ZWFibGUuUm90YXRhYmxlLk9uUm90YXRlR3JvdXBFbmR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGByb3RhdGVHcm91cEVuZGAgZXZlbnRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICAgIHRhcmdldDogW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnRhcmdldFwiKSksXG4gKiAgICAgcm90YXRhYmxlOiB0cnVlXG4gKiB9KTtcbiAqIG1vdmVhYmxlLm9uKFwicm90YXRlR3JvdXBFbmRcIiwgKHsgdGFyZ2V0cywgaXNEcmFnIH0pID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhcIm9uUm90YXRlR3JvdXBFbmRcIiwgdGFyZ2V0cywgaXNEcmFnKTtcbiAqIH0pO1xuICovXG5cbi8qKlxuICogQG5hbWVzcGFjZSBSZXNpemFibGVcbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZVxuICogQGRlc2NyaXB0aW9uIFJlc2l6YWJsZSBpbmRpY2F0ZXMgd2hldGhlciB0aGUgdGFyZ2V0J3Mgd2lkdGggYW5kIGhlaWdodCBjYW4gYmUgaW5jcmVhc2VkIG9yIGRlY3JlYXNlZC5cbiAqL1xuXG52YXIgUmVzaXphYmxlID0ge1xuICBuYW1lOiBcInJlc2l6YWJsZVwiLFxuICBhYmxlR3JvdXA6IFwic2l6ZVwiLFxuICBjYW5QaW5jaDogdHJ1ZSxcbiAgcHJvcHM6IHtcbiAgICByZXNpemFibGU6IEJvb2xlYW4sXG4gICAgdGhyb3R0bGVSZXNpemU6IE51bWJlcixcbiAgICByZW5kZXJEaXJlY3Rpb25zOiBBcnJheSxcbiAgICBrZWVwUmF0aW86IEJvb2xlYW5cbiAgfSxcbiAgZXZlbnRzOiB7XG4gICAgb25SZXNpemVTdGFydDogXCJyZXNpemVTdGFydFwiLFxuICAgIG9uUmVzaXplOiBcInJlc2l6ZVwiLFxuICAgIG9uUmVzaXplRW5kOiBcInJlc2l6ZUVuZFwiLFxuICAgIG9uUmVzaXplR3JvdXBTdGFydDogXCJyZXNpemVHcm91cFN0YXJ0XCIsXG4gICAgb25SZXNpemVHcm91cDogXCJyZXNpemVHcm91cFwiLFxuICAgIG9uUmVzaXplR3JvdXBFbmQ6IFwicmVzaXplR3JvdXBFbmRcIlxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgUmVhY3QpIHtcbiAgICB2YXIgX2EgPSBtb3ZlYWJsZS5wcm9wcyxcbiAgICAgICAgcmVzaXphYmxlID0gX2EucmVzaXphYmxlLFxuICAgICAgICBlZGdlID0gX2EuZWRnZTtcblxuICAgIGlmIChyZXNpemFibGUpIHtcbiAgICAgIGlmIChlZGdlKSB7XG4gICAgICAgIHJldHVybiByZW5kZXJEaWFnb25hbERpcmVjdGlvbnMobW92ZWFibGUsIFJlYWN0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlbmRlckFsbERpcmVjdGlvbnMobW92ZWFibGUsIFJlYWN0KTtcbiAgICB9XG4gIH0sXG4gIGRyYWdDb250cm9sQ29uZGl0aW9uOiBkaXJlY3Rpb25Db25kaXRpb24sXG4gIGRyYWdDb250cm9sU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBfYTtcblxuICAgIHZhciBpbnB1dEV2ZW50ID0gZS5pbnB1dEV2ZW50LFxuICAgICAgICBpc1BpbmNoID0gZS5pc1BpbmNoLFxuICAgICAgICBwYXJlbnREaXJlY3Rpb24gPSBlLnBhcmVudERpcmVjdGlvbixcbiAgICAgICAgZGF0YXMgPSBlLmRhdGFzLFxuICAgICAgICBwYXJlbnRGbGFnID0gZS5wYXJlbnRGbGFnO1xuICAgIHZhciBkaXJlY3Rpb24gPSBwYXJlbnREaXJlY3Rpb24gfHwgKGlzUGluY2ggPyBbMCwgMF0gOiBnZXREaXJlY3Rpb24oaW5wdXRFdmVudC50YXJnZXQpKTtcbiAgICB2YXIgX2IgPSBtb3ZlYWJsZS5zdGF0ZSxcbiAgICAgICAgdGFyZ2V0ID0gX2IudGFyZ2V0LFxuICAgICAgICB3aWR0aCA9IF9iLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfYi5oZWlnaHQ7XG5cbiAgICBpZiAoIWRpcmVjdGlvbiB8fCAhdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgIWlzUGluY2ggJiYgc2V0RHJhZ1N0YXJ0KG1vdmVhYmxlLCBlKTtcbiAgICBkYXRhcy5kYXRhcyA9IHt9O1xuICAgIGRhdGFzLmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICBkYXRhcy5zdGFydE9mZnNldFdpZHRoID0gd2lkdGg7XG4gICAgZGF0YXMuc3RhcnRPZmZzZXRIZWlnaHQgPSBoZWlnaHQ7XG4gICAgZGF0YXMucHJldldpZHRoID0gMDtcbiAgICBkYXRhcy5wcmV2SGVpZ2h0ID0gMDtcbiAgICBfYSA9IGdldENTU1NpemUodGFyZ2V0KSwgZGF0YXMuc3RhcnRXaWR0aCA9IF9hWzBdLCBkYXRhcy5zdGFydEhlaWdodCA9IF9hWzFdO1xuICAgIHZhciBwYWRkaW5nID0gW01hdGgubWF4KDAsIHdpZHRoIC0gZGF0YXMuc3RhcnRXaWR0aCksIE1hdGgubWF4KDAsIGhlaWdodCAtIGRhdGFzLnN0YXJ0SGVpZ2h0KV07XG4gICAgZGF0YXMubWluU2l6ZSA9IHBhZGRpbmc7XG4gICAgZGF0YXMubWF4U2l6ZSA9IFtJbmZpbml0eSwgSW5maW5pdHldO1xuXG4gICAgaWYgKCFwYXJlbnRGbGFnKSB7XG4gICAgICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldCk7XG4gICAgICB2YXIgcG9zaXRpb24gPSBzdHlsZS5wb3NpdGlvbixcbiAgICAgICAgICBtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoLFxuICAgICAgICAgIG1pbkhlaWdodCA9IHN0eWxlLm1pbkhlaWdodCxcbiAgICAgICAgICBtYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoLFxuICAgICAgICAgIG1heEhlaWdodCA9IHN0eWxlLm1heEhlaWdodDtcbiAgICAgIHZhciBpc1BhcmVudEVsZW1lbnQgPSBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiB8fCBwb3NpdGlvbiA9PT0gXCJyZWxhdGl2ZVwiO1xuICAgICAgdmFyIGNvbnRhaW5lciA9IGlzUGFyZW50RWxlbWVudCA/IHRhcmdldC5wYXJlbnRFbGVtZW50IDogdGFyZ2V0Lm9mZnNldFBhcmVudDtcbiAgICAgIHZhciBjb250YWluZXJXaWR0aCA9IHdpZHRoO1xuICAgICAgdmFyIGNvbnRhaW5lckhlaWdodCA9IGhlaWdodDtcblxuICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICBjb250YWluZXJXaWR0aCA9IGNvbnRhaW5lci5jbGllbnRXaWR0aDtcbiAgICAgICAgY29udGFpbmVySGVpZ2h0ID0gY29udGFpbmVyLmNsaWVudEhlaWdodDtcblxuICAgICAgICBpZiAoaXNQYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgdmFyIGNvbnRhaW5lclN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXIpO1xuICAgICAgICAgIGNvbnRhaW5lcldpZHRoIC09IHBhcnNlRmxvYXQoY29udGFpbmVyU3R5bGUucGFkZGluZ0xlZnQpIHx8IDA7XG4gICAgICAgICAgY29udGFpbmVySGVpZ2h0IC09IHBhcnNlRmxvYXQoY29udGFpbmVyU3R5bGUucGFkZGluZ1RvcCkgfHwgMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBkYXRhcy5taW5TaXplID0gcGx1cyhbY29udmVydFVuaXRTaXplKG1pbldpZHRoLCBjb250YWluZXJXaWR0aCkgfHwgMCwgY29udmVydFVuaXRTaXplKG1pbkhlaWdodCwgY29udGFpbmVySGVpZ2h0KSB8fCAwXSwgcGFkZGluZyk7XG4gICAgICBkYXRhcy5tYXhTaXplID0gcGx1cyhbY29udmVydFVuaXRTaXplKG1heFdpZHRoLCBjb250YWluZXJXaWR0aCkgfHwgSW5maW5pdHksIGNvbnZlcnRVbml0U2l6ZShtYXhIZWlnaHQsIGNvbnRhaW5lckhlaWdodCkgfHwgSW5maW5pdHldLCBwYWRkaW5nKTtcbiAgICB9XG5cbiAgICB2YXIgdHJhbnNmb3JtT3JpZ2luID0gbW92ZWFibGUucHJvcHMudHJhbnNmb3JtT3JpZ2luIHx8IFwiJSAlXCI7XG4gICAgZGF0YXMudHJhbnNmb3JtT3JpZ2luID0gdHJhbnNmb3JtT3JpZ2luICYmIGlzU3RyaW5nKHRyYW5zZm9ybU9yaWdpbikgPyB0cmFuc2Zvcm1PcmlnaW4uc3BsaXQoXCIgXCIpIDogdHJhbnNmb3JtT3JpZ2luO1xuICAgIGRhdGFzLmlzV2lkdGggPSAhZGlyZWN0aW9uWzBdICYmICFkaXJlY3Rpb25bMV0gfHwgZGlyZWN0aW9uWzBdIHx8ICFkaXJlY3Rpb25bMV07XG5cbiAgICBmdW5jdGlvbiBzZXRSYXRpbyhyYXRpbykge1xuICAgICAgZGF0YXMucmF0aW8gPSByYXRpbyAmJiBpc0Zpbml0ZShyYXRpbykgPyByYXRpbyA6IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0Rml4ZWREaXJlY3Rpb24oZml4ZWREaXJlY3Rpb24pIHtcbiAgICAgIGRhdGFzLmZpeGVkRGlyZWN0aW9uID0gZml4ZWREaXJlY3Rpb247XG4gICAgICBkYXRhcy5maXhlZFBvc2l0aW9uID0gZ2V0QWJzb2x1dGVQb3NpdGlvbihtb3ZlYWJsZSwgZml4ZWREaXJlY3Rpb24pO1xuICAgIH1cblxuICAgIHNldFJhdGlvKHdpZHRoIC8gaGVpZ2h0KTtcbiAgICBzZXRGaXhlZERpcmVjdGlvbihbLWRpcmVjdGlvblswXSwgLWRpcmVjdGlvblsxXV0pO1xuICAgIHZhciBwYXJhbXMgPSBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCB7XG4gICAgICBkaXJlY3Rpb246IGRpcmVjdGlvbixcbiAgICAgIHNldDogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBzdGFydFdpZHRoID0gX2FbMF0sXG4gICAgICAgICAgICBzdGFydEhlaWdodCA9IF9hWzFdO1xuICAgICAgICBkYXRhcy5zdGFydFdpZHRoID0gc3RhcnRXaWR0aDtcbiAgICAgICAgZGF0YXMuc3RhcnRIZWlnaHQgPSBzdGFydEhlaWdodDtcbiAgICAgIH0sXG4gICAgICBzZXRNaW46IGZ1bmN0aW9uIChtaW5TaXplKSB7XG4gICAgICAgIGRhdGFzLm1pblNpemUgPSBtaW5TaXplO1xuICAgICAgfSxcbiAgICAgIHNldE1heDogZnVuY3Rpb24gKG1heFNpemUpIHtcbiAgICAgICAgZGF0YXMubWF4U2l6ZSA9IFttYXhTaXplWzBdIHx8IEluZmluaXR5LCBtYXhTaXplWzFdIHx8IEluZmluaXR5XTtcbiAgICAgIH0sXG4gICAgICBzZXRSYXRpbzogc2V0UmF0aW8sXG4gICAgICBzZXRGaXhlZERpcmVjdGlvbjogc2V0Rml4ZWREaXJlY3Rpb24sXG4gICAgICBzZXRPcmlnaW46IGZ1bmN0aW9uIChvcmlnaW4pIHtcbiAgICAgICAgZGF0YXMudHJhbnNmb3JtT3JpZ2luID0gb3JpZ2luO1xuICAgICAgfSxcbiAgICAgIGRyYWdTdGFydDogRHJhZ2dhYmxlLmRyYWdTdGFydChtb3ZlYWJsZSwgbmV3IEN1c3RvbUdlc3RvKCkuZHJhZ1N0YXJ0KFswLCAwXSwgZSkpXG4gICAgfSk7XG4gICAgdmFyIHJlc3VsdCA9IHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvblJlc2l6ZVN0YXJ0XCIsIHBhcmFtcyk7XG5cbiAgICBpZiAocmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgZGF0YXMuaXNSZXNpemUgPSB0cnVlO1xuICAgICAgbW92ZWFibGUuc3RhdGUuc25hcFJlbmRlckluZm8gPSB7XG4gICAgICAgIHJlcXVlc3Q6IGUuaXNSZXF1ZXN0LFxuICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvblxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YXMuaXNSZXNpemUgPyBwYXJhbXMgOiBmYWxzZTtcbiAgfSxcbiAgZHJhZ0NvbnRyb2w6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBfYTtcblxuICAgIHZhciBkYXRhcyA9IGUuZGF0YXMsXG4gICAgICAgIGRpc3RYID0gZS5kaXN0WCxcbiAgICAgICAgZGlzdFkgPSBlLmRpc3RZLFxuICAgICAgICBwYXJlbnRGbGFnID0gZS5wYXJlbnRGbGFnLFxuICAgICAgICBpc1BpbmNoID0gZS5pc1BpbmNoLFxuICAgICAgICBwYXJlbnREaXN0YW5jZSA9IGUucGFyZW50RGlzdGFuY2UsXG4gICAgICAgIHBhcmVudFNjYWxlID0gZS5wYXJlbnRTY2FsZSxcbiAgICAgICAgcGFyZW50S2VlcFJhdGlvID0gZS5wYXJlbnRLZWVwUmF0aW8sXG4gICAgICAgIGRyYWdDbGllbnQgPSBlLmRyYWdDbGllbnQsXG4gICAgICAgIHBhcmVudERpc3QgPSBlLnBhcmVudERpc3QsXG4gICAgICAgIGlzUmVxdWVzdCA9IGUuaXNSZXF1ZXN0O1xuICAgIHZhciBpc1Jlc2l6ZSA9IGRhdGFzLmlzUmVzaXplLFxuICAgICAgICB0cmFuc2Zvcm1PcmlnaW4gPSBkYXRhcy50cmFuc2Zvcm1PcmlnaW4sXG4gICAgICAgIGZpeGVkRGlyZWN0aW9uID0gZGF0YXMuZml4ZWREaXJlY3Rpb24sXG4gICAgICAgIHN0YXJ0V2lkdGggPSBkYXRhcy5zdGFydFdpZHRoLFxuICAgICAgICBzdGFydEhlaWdodCA9IGRhdGFzLnN0YXJ0SGVpZ2h0LFxuICAgICAgICBwcmV2V2lkdGggPSBkYXRhcy5wcmV2V2lkdGgsXG4gICAgICAgIHByZXZIZWlnaHQgPSBkYXRhcy5wcmV2SGVpZ2h0LFxuICAgICAgICBtaW5TaXplID0gZGF0YXMubWluU2l6ZSxcbiAgICAgICAgbWF4U2l6ZSA9IGRhdGFzLm1heFNpemUsXG4gICAgICAgIHJhdGlvID0gZGF0YXMucmF0aW8sXG4gICAgICAgIGlzV2lkdGggPSBkYXRhcy5pc1dpZHRoLFxuICAgICAgICBzdGFydE9mZnNldFdpZHRoID0gZGF0YXMuc3RhcnRPZmZzZXRXaWR0aCxcbiAgICAgICAgc3RhcnRPZmZzZXRIZWlnaHQgPSBkYXRhcy5zdGFydE9mZnNldEhlaWdodDtcblxuICAgIGlmICghaXNSZXNpemUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgX2IgPSBtb3ZlYWJsZS5wcm9wcyxcbiAgICAgICAgX2MgPSBfYi50aHJvdHRsZVJlc2l6ZSxcbiAgICAgICAgdGhyb3R0bGVSZXNpemUgPSBfYyA9PT0gdm9pZCAwID8gMCA6IF9jLFxuICAgICAgICBwYXJlbnRNb3ZlYWJsZSA9IF9iLnBhcmVudE1vdmVhYmxlLFxuICAgICAgICBfZCA9IF9iLnNuYXBUaHJlc2hvbGQsXG4gICAgICAgIHNuYXBUaHJlc2hvbGQgPSBfZCA9PT0gdm9pZCAwID8gNSA6IF9kO1xuICAgIHZhciBkaXJlY3Rpb24gPSBkYXRhcy5kaXJlY3Rpb247XG4gICAgdmFyIHNpemVEaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgdmFyIGRpc3RXaWR0aCA9IDA7XG4gICAgdmFyIGRpc3RIZWlnaHQgPSAwO1xuXG4gICAgaWYgKCFkaXJlY3Rpb25bMF0gJiYgIWRpcmVjdGlvblsxXSkge1xuICAgICAgc2l6ZURpcmVjdGlvbiA9IFsxLCAxXTtcbiAgICB9XG5cbiAgICB2YXIga2VlcFJhdGlvID0gcmF0aW8gJiYgKG1vdmVhYmxlLnByb3BzLmtlZXBSYXRpbyB8fCBwYXJlbnRLZWVwUmF0aW8pO1xuICAgIHZhciBmaXhlZFBvc2l0aW9uID0gZHJhZ0NsaWVudDtcblxuICAgIGlmICghZHJhZ0NsaWVudCkge1xuICAgICAgaWYgKCFwYXJlbnRGbGFnICYmIGlzUGluY2gpIHtcbiAgICAgICAgZml4ZWRQb3NpdGlvbiA9IGdldEFic29sdXRlUG9zaXRpb24obW92ZWFibGUsIFswLCAwXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaXhlZFBvc2l0aW9uID0gZGF0YXMuZml4ZWRQb3NpdGlvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGFyZW50RGlzdCkge1xuICAgICAgZGlzdFdpZHRoID0gcGFyZW50RGlzdFswXTtcbiAgICAgIGRpc3RIZWlnaHQgPSBwYXJlbnREaXN0WzFdO1xuXG4gICAgICBpZiAoa2VlcFJhdGlvKSB7XG4gICAgICAgIGlmICghZGlzdFdpZHRoKSB7XG4gICAgICAgICAgZGlzdFdpZHRoID0gZGlzdEhlaWdodCAqIHJhdGlvO1xuICAgICAgICB9IGVsc2UgaWYgKCFkaXN0SGVpZ2h0KSB7XG4gICAgICAgICAgZGlzdEhlaWdodCA9IGRpc3RXaWR0aCAvIHJhdGlvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwYXJlbnRTY2FsZSkge1xuICAgICAgZGlzdFdpZHRoID0gKHBhcmVudFNjYWxlWzBdIC0gMSkgKiBzdGFydE9mZnNldFdpZHRoO1xuICAgICAgZGlzdEhlaWdodCA9IChwYXJlbnRTY2FsZVsxXSAtIDEpICogc3RhcnRPZmZzZXRIZWlnaHQ7XG4gICAgfSBlbHNlIGlmIChpc1BpbmNoKSB7XG4gICAgICBpZiAocGFyZW50RGlzdGFuY2UpIHtcbiAgICAgICAgZGlzdFdpZHRoID0gcGFyZW50RGlzdGFuY2U7XG4gICAgICAgIGRpc3RIZWlnaHQgPSBwYXJlbnREaXN0YW5jZSAqIHN0YXJ0T2Zmc2V0SGVpZ2h0IC8gc3RhcnRPZmZzZXRXaWR0aDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRpc3QgPSBnZXREcmFnRGlzdCh7XG4gICAgICAgIGRhdGFzOiBkYXRhcyxcbiAgICAgICAgZGlzdFg6IGRpc3RYLFxuICAgICAgICBkaXN0WTogZGlzdFlcbiAgICAgIH0pO1xuICAgICAgZGlzdFdpZHRoID0gc2l6ZURpcmVjdGlvblswXSAqIGRpc3RbMF07XG4gICAgICBkaXN0SGVpZ2h0ID0gc2l6ZURpcmVjdGlvblsxXSAqIGRpc3RbMV07XG5cbiAgICAgIGlmIChrZWVwUmF0aW8gJiYgc3RhcnRPZmZzZXRXaWR0aCAmJiBzdGFydE9mZnNldEhlaWdodCkge1xuICAgICAgICB2YXIgcmFkID0gZ2V0UmFkKFswLCAwXSwgZGlzdCk7XG4gICAgICAgIHZhciBzdGFuZGFyZFJhZCA9IGdldFJhZChbMCwgMF0sIHNpemVEaXJlY3Rpb24pO1xuICAgICAgICB2YXIgc2l6ZSA9IGdldERpc3RTaXplKFtkaXN0V2lkdGgsIGRpc3RIZWlnaHRdKTtcbiAgICAgICAgdmFyIHNpZ25TaXplID0gTWF0aC5jb3MocmFkIC0gc3RhbmRhcmRSYWQpICogc2l6ZTtcblxuICAgICAgICBpZiAoIXNpemVEaXJlY3Rpb25bMF0pIHtcbiAgICAgICAgICAvLyB0b3AsIGJvdHRvbVxuICAgICAgICAgIGRpc3RIZWlnaHQgPSBzaWduU2l6ZTtcbiAgICAgICAgICBkaXN0V2lkdGggPSBkaXN0SGVpZ2h0IC8gcmF0aW87XG4gICAgICAgIH0gZWxzZSBpZiAoIXNpemVEaXJlY3Rpb25bMV0pIHtcbiAgICAgICAgICAvLyBsZWZ0LCByaWdodFxuICAgICAgICAgIGRpc3RXaWR0aCA9IHNpZ25TaXplO1xuICAgICAgICAgIGRpc3RIZWlnaHQgPSBkaXN0V2lkdGggKiByYXRpbztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB0d28td2F5XG4gICAgICAgICAgdmFyIHN0YXJ0V2lkdGhTaXplID0gc2l6ZURpcmVjdGlvblswXSAqIDIgKiBzdGFydE9mZnNldFdpZHRoO1xuICAgICAgICAgIHZhciBzdGFydEhlaWdodFNpemUgPSBzaXplRGlyZWN0aW9uWzFdICogMiAqIHN0YXJ0T2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgIHZhciBkaXN0U2l6ZSA9IGdldERpc3RTaXplKFtzdGFydFdpZHRoU2l6ZSArIGRpc3RbMF0sIHN0YXJ0SGVpZ2h0U2l6ZSArIGRpc3RbMV1dKSAtIGdldERpc3RTaXplKFtzdGFydFdpZHRoU2l6ZSwgc3RhcnRIZWlnaHRTaXplXSk7XG4gICAgICAgICAgdmFyIHJhdGlvUmFkID0gZ2V0UmFkKFswLCAwXSwgW3JhdGlvLCAxXSk7XG4gICAgICAgICAgZGlzdFdpZHRoID0gTWF0aC5jb3MocmF0aW9SYWQpICogZGlzdFNpemU7XG4gICAgICAgICAgZGlzdEhlaWdodCA9IE1hdGguc2luKHJhdGlvUmFkKSAqIGRpc3RTaXplO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFrZWVwUmF0aW8pIHtcbiAgICAgICAgdmFyIG5leHREaXJlY3Rpb24gPSBfX3NwcmVhZEFycmF5KFtdLCBkaXJlY3Rpb24pO1xuXG4gICAgICAgIGlmICghc3RhcnRPZmZzZXRXaWR0aCkge1xuICAgICAgICAgIGlmIChkaXN0WzBdIDwgMCkge1xuICAgICAgICAgICAgbmV4dERpcmVjdGlvblswXSA9IC0xO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZGlzdFswXSA+IDApIHtcbiAgICAgICAgICAgIG5leHREaXJlY3Rpb25bMF0gPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc3RhcnRPZmZzZXRIZWlnaHQpIHtcbiAgICAgICAgICBpZiAoZGlzdFsxXSA8IDApIHtcbiAgICAgICAgICAgIG5leHREaXJlY3Rpb25bMV0gPSAtMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGRpc3RbMV0gPiAwKSB7XG4gICAgICAgICAgICBuZXh0RGlyZWN0aW9uWzFdID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkaXJlY3Rpb24gPSBuZXh0RGlyZWN0aW9uO1xuICAgICAgICBzaXplRGlyZWN0aW9uID0gbmV4dERpcmVjdGlvbjtcbiAgICAgICAgZGlzdFdpZHRoID0gc2l6ZURpcmVjdGlvblswXSAqIGRpc3RbMF07XG4gICAgICAgIGRpc3RIZWlnaHQgPSBzaXplRGlyZWN0aW9uWzFdICogZGlzdFsxXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbmV4dFdpZHRoID0gc2l6ZURpcmVjdGlvblswXSB8fCBrZWVwUmF0aW8gPyBNYXRoLm1heChzdGFydE9mZnNldFdpZHRoICsgZGlzdFdpZHRoLCBUSU5ZX05VTSkgOiBzdGFydE9mZnNldFdpZHRoO1xuICAgIHZhciBuZXh0SGVpZ2h0ID0gc2l6ZURpcmVjdGlvblsxXSB8fCBrZWVwUmF0aW8gPyBNYXRoLm1heChzdGFydE9mZnNldEhlaWdodCArIGRpc3RIZWlnaHQsIFRJTllfTlVNKSA6IHN0YXJ0T2Zmc2V0SGVpZ2h0O1xuXG4gICAgaWYgKGtlZXBSYXRpbyAmJiBzdGFydE9mZnNldFdpZHRoICYmIHN0YXJ0T2Zmc2V0SGVpZ2h0KSB7XG4gICAgICAvLyBzdGFydE9mZnNldFdpZHRoIDogc3RhcnRPZmZzZXRIZWlnaHQgPSBuZXh0V2lkdGggOiBuZXh0SGVpZ2h0XG4gICAgICBpZiAoaXNXaWR0aCkge1xuICAgICAgICBuZXh0SGVpZ2h0ID0gbmV4dFdpZHRoIC8gcmF0aW87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0V2lkdGggPSBuZXh0SGVpZ2h0ICogcmF0aW87XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNuYXBEaXN0ID0gWzAsIDBdO1xuXG4gICAgaWYgKCFpc1BpbmNoKSB7XG4gICAgICBzbmFwRGlzdCA9IGNoZWNrU25hcFJlc2l6ZShtb3ZlYWJsZSwgbmV4dFdpZHRoLCBuZXh0SGVpZ2h0LCBkaXJlY3Rpb24sIGZpeGVkUG9zaXRpb24sIGlzUmVxdWVzdCwgZGF0YXMpO1xuICAgIH1cblxuICAgIGlmIChwYXJlbnREaXN0KSB7XG4gICAgICAhcGFyZW50RGlzdFswXSAmJiAoc25hcERpc3RbMF0gPSAwKTtcbiAgICAgICFwYXJlbnREaXN0WzFdICYmIChzbmFwRGlzdFsxXSA9IDApO1xuICAgIH1cblxuICAgIGlmIChrZWVwUmF0aW8pIHtcbiAgICAgIGlmIChzaXplRGlyZWN0aW9uWzBdICYmIHNpemVEaXJlY3Rpb25bMV0gJiYgc25hcERpc3RbMF0gJiYgc25hcERpc3RbMV0pIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKHNuYXBEaXN0WzBdKSA+IE1hdGguYWJzKHNuYXBEaXN0WzFdKSkge1xuICAgICAgICAgIHNuYXBEaXN0WzFdID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzbmFwRGlzdFswXSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGlzTm9TbmFwID0gIXNuYXBEaXN0WzBdICYmICFzbmFwRGlzdFsxXTtcblxuICAgICAgaWYgKGlzTm9TbmFwKSB7XG4gICAgICAgIGlmIChpc1dpZHRoKSB7XG4gICAgICAgICAgbmV4dFdpZHRoID0gdGhyb3R0bGUobmV4dFdpZHRoLCB0aHJvdHRsZVJlc2l6ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dEhlaWdodCA9IHRocm90dGxlKG5leHRIZWlnaHQsIHRocm90dGxlUmVzaXplKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2l6ZURpcmVjdGlvblswXSAmJiAhc2l6ZURpcmVjdGlvblsxXSB8fCBzbmFwRGlzdFswXSAmJiAhc25hcERpc3RbMV0gfHwgaXNOb1NuYXAgJiYgaXNXaWR0aCkge1xuICAgICAgICBuZXh0V2lkdGggKz0gc25hcERpc3RbMF07XG4gICAgICAgIG5leHRIZWlnaHQgPSBuZXh0V2lkdGggLyByYXRpbztcbiAgICAgIH0gZWxzZSBpZiAoIXNpemVEaXJlY3Rpb25bMF0gJiYgc2l6ZURpcmVjdGlvblsxXSB8fCAhc25hcERpc3RbMF0gJiYgc25hcERpc3RbMV0gfHwgaXNOb1NuYXAgJiYgIWlzV2lkdGgpIHtcbiAgICAgICAgbmV4dEhlaWdodCArPSBzbmFwRGlzdFsxXTtcbiAgICAgICAgbmV4dFdpZHRoID0gbmV4dEhlaWdodCAqIHJhdGlvO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhcnRPZmZzZXRXaWR0aCArIGRpc3RXaWR0aCA8IC1zbmFwVGhyZXNob2xkKSB7XG4gICAgICAgIHNuYXBEaXN0WzBdID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXJ0T2Zmc2V0V2lkdGggKyBkaXN0SGVpZ2h0IDwgLXNuYXBUaHJlc2hvbGQpIHtcbiAgICAgICAgc25hcERpc3RbMV0gPSAwO1xuICAgICAgfVxuXG4gICAgICBuZXh0V2lkdGggKz0gc25hcERpc3RbMF07XG4gICAgICBuZXh0SGVpZ2h0ICs9IHNuYXBEaXN0WzFdO1xuXG4gICAgICBpZiAoIXNuYXBEaXN0WzBdKSB7XG4gICAgICAgIG5leHRXaWR0aCA9IHRocm90dGxlKG5leHRXaWR0aCwgdGhyb3R0bGVSZXNpemUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNuYXBEaXN0WzFdKSB7XG4gICAgICAgIG5leHRIZWlnaHQgPSB0aHJvdHRsZShuZXh0SGVpZ2h0LCB0aHJvdHRsZVJlc2l6ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2EgPSBjYWxjdWxhdGVCb3VuZFNpemUoW25leHRXaWR0aCwgbmV4dEhlaWdodF0sIG1pblNpemUsIG1heFNpemUsIGtlZXBSYXRpbyksIG5leHRXaWR0aCA9IF9hWzBdLCBuZXh0SGVpZ2h0ID0gX2FbMV07XG4gICAgbmV4dFdpZHRoID0gTWF0aC5yb3VuZChuZXh0V2lkdGgpO1xuICAgIG5leHRIZWlnaHQgPSBNYXRoLnJvdW5kKG5leHRIZWlnaHQpO1xuICAgIGRpc3RXaWR0aCA9IG5leHRXaWR0aCAtIHN0YXJ0T2Zmc2V0V2lkdGg7XG4gICAgZGlzdEhlaWdodCA9IG5leHRIZWlnaHQgLSBzdGFydE9mZnNldEhlaWdodDtcbiAgICB2YXIgZGVsdGEgPSBbZGlzdFdpZHRoIC0gcHJldldpZHRoLCBkaXN0SGVpZ2h0IC0gcHJldkhlaWdodF07XG4gICAgZGF0YXMucHJldldpZHRoID0gZGlzdFdpZHRoO1xuICAgIGRhdGFzLnByZXZIZWlnaHQgPSBkaXN0SGVpZ2h0O1xuICAgIHZhciBpbnZlcnNlRGVsdGEgPSBnZXRSZXNpemVEaXN0KG1vdmVhYmxlLCBuZXh0V2lkdGgsIG5leHRIZWlnaHQsIGZpeGVkRGlyZWN0aW9uLCBmaXhlZFBvc2l0aW9uLCB0cmFuc2Zvcm1PcmlnaW4pO1xuXG4gICAgaWYgKCFwYXJlbnRNb3ZlYWJsZSAmJiBkZWx0YS5ldmVyeShmdW5jdGlvbiAobnVtKSB7XG4gICAgICByZXR1cm4gIW51bTtcbiAgICB9KSAmJiBpbnZlcnNlRGVsdGEuZXZlcnkoZnVuY3Rpb24gKG51bSkge1xuICAgICAgcmV0dXJuICFudW07XG4gICAgfSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGFyYW1zID0gZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xuICAgICAgd2lkdGg6IHN0YXJ0V2lkdGggKyBkaXN0V2lkdGgsXG4gICAgICBoZWlnaHQ6IHN0YXJ0SGVpZ2h0ICsgZGlzdEhlaWdodCxcbiAgICAgIG9mZnNldFdpZHRoOiBuZXh0V2lkdGgsXG4gICAgICBvZmZzZXRIZWlnaHQ6IG5leHRIZWlnaHQsXG4gICAgICBkaXJlY3Rpb246IGRpcmVjdGlvbixcbiAgICAgIGRpc3Q6IFtkaXN0V2lkdGgsIGRpc3RIZWlnaHRdLFxuICAgICAgZGVsdGE6IGRlbHRhLFxuICAgICAgaXNQaW5jaDogISFpc1BpbmNoLFxuICAgICAgZHJhZzogRHJhZ2dhYmxlLmRyYWcobW92ZWFibGUsIHNldEN1c3RvbURyYWcoZSwgbW92ZWFibGUuc3RhdGUsIGludmVyc2VEZWx0YSwgISFpc1BpbmNoLCBmYWxzZSkpXG4gICAgfSk7XG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUmVzaXplXCIsIHBhcmFtcyk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfSxcbiAgZHJhZ0NvbnRyb2xBZnRlcjogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIGRhdGFzID0gZS5kYXRhcztcbiAgICB2YXIgaXNSZXNpemUgPSBkYXRhcy5pc1Jlc2l6ZSxcbiAgICAgICAgc3RhcnRPZmZzZXRXaWR0aCA9IGRhdGFzLnN0YXJ0T2Zmc2V0V2lkdGgsXG4gICAgICAgIHN0YXJ0T2Zmc2V0SGVpZ2h0ID0gZGF0YXMuc3RhcnRPZmZzZXRIZWlnaHQsXG4gICAgICAgIHByZXZXaWR0aCA9IGRhdGFzLnByZXZXaWR0aCxcbiAgICAgICAgcHJldkhlaWdodCA9IGRhdGFzLnByZXZIZWlnaHQ7XG5cbiAgICBpZiAoIWlzUmVzaXplKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIF9hID0gbW92ZWFibGUuc3RhdGUsXG4gICAgICAgIHdpZHRoID0gX2Eud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF9hLmhlaWdodDtcbiAgICB2YXIgZXJyb3JXaWR0aCA9IHdpZHRoIC0gKHN0YXJ0T2Zmc2V0V2lkdGggKyBwcmV2V2lkdGgpO1xuICAgIHZhciBlcnJvckhlaWdodCA9IGhlaWdodCAtIChzdGFydE9mZnNldEhlaWdodCArIHByZXZIZWlnaHQpO1xuICAgIHZhciBpc0Vycm9yV2lkdGggPSBNYXRoLmFicyhlcnJvcldpZHRoKSA+IDM7XG4gICAgdmFyIGlzRXJyb3JIZWlnaHQgPSBNYXRoLmFicyhlcnJvckhlaWdodCkgPiAzO1xuXG4gICAgaWYgKGlzRXJyb3JXaWR0aCkge1xuICAgICAgZGF0YXMuc3RhcnRXaWR0aCArPSBlcnJvcldpZHRoO1xuICAgICAgZGF0YXMuc3RhcnRPZmZzZXRXaWR0aCArPSBlcnJvcldpZHRoO1xuICAgICAgZGF0YXMucHJldldpZHRoICs9IGVycm9yV2lkdGg7XG4gICAgfVxuXG4gICAgaWYgKGlzRXJyb3JIZWlnaHQpIHtcbiAgICAgIGRhdGFzLnN0YXJ0SGVpZ2h0ICs9IGVycm9ySGVpZ2h0O1xuICAgICAgZGF0YXMuc3RhcnRPZmZzZXRIZWlnaHQgKz0gZXJyb3JIZWlnaHQ7XG4gICAgICBkYXRhcy5wcmV2SGVpZ2h0ICs9IGVycm9ySGVpZ2h0O1xuICAgIH1cblxuICAgIGlmIChpc0Vycm9yV2lkdGggfHwgaXNFcnJvckhlaWdodCkge1xuICAgICAgcmV0dXJuIHRoaXMuZHJhZ0NvbnRyb2wobW92ZWFibGUsIGUpO1xuICAgIH1cbiAgfSxcbiAgZHJhZ0NvbnRyb2xFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBkYXRhcyA9IGUuZGF0YXM7XG5cbiAgICBpZiAoIWRhdGFzLmlzUmVzaXplKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGF0YXMuaXNSZXNpemUgPSBmYWxzZTtcbiAgICB2YXIgcGFyYW1zID0gZmlsbEVuZFBhcmFtcyhtb3ZlYWJsZSwgZSwge30pO1xuICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvblJlc2l6ZUVuZFwiLCBwYXJhbXMpO1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH0sXG4gIGRyYWdHcm91cENvbnRyb2xDb25kaXRpb246IGRpcmVjdGlvbkNvbmRpdGlvbixcbiAgZHJhZ0dyb3VwQ29udHJvbFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB2YXIgZGF0YXMgPSBlLmRhdGFzO1xuICAgIHZhciBwYXJhbXMgPSB0aGlzLmRyYWdDb250cm9sU3RhcnQobW92ZWFibGUsIGUpO1xuXG4gICAgaWYgKCFwYXJhbXMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgb3JpZ2luYWxFdmVudHMgPSBmaWxsQ2hpbGRFdmVudHMobW92ZWFibGUsIFwicmVzaXphYmxlXCIsIGUpO1xuXG4gICAgZnVuY3Rpb24gc2V0RGlzdChjaGlsZCwgZXYpIHtcbiAgICAgIHZhciBmaXhlZERpcmVjdGlvbiA9IGRhdGFzLmZpeGVkRGlyZWN0aW9uO1xuICAgICAgdmFyIGZpeGVkUG9zaXRpb24gPSBkYXRhcy5maXhlZFBvc2l0aW9uO1xuICAgICAgdmFyIHBvcyA9IGdldEFic29sdXRlUG9zaXRpb24oY2hpbGQsIGZpeGVkRGlyZWN0aW9uKTtcblxuICAgICAgdmFyIF9hID0gY2FsY3VsYXRlKGNyZWF0ZVJvdGF0ZU1hdHJpeCgtbW92ZWFibGUucm90YXRpb24gLyAxODAgKiBNYXRoLlBJLCAzKSwgW3Bvc1swXSAtIGZpeGVkUG9zaXRpb25bMF0sIHBvc1sxXSAtIGZpeGVkUG9zaXRpb25bMV0sIDFdLCAzKSxcbiAgICAgICAgICBvcmlnaW5hbFggPSBfYVswXSxcbiAgICAgICAgICBvcmlnaW5hbFkgPSBfYVsxXTtcblxuICAgICAgZXYuZGF0YXMub3JpZ2luYWxYID0gb3JpZ2luYWxYO1xuICAgICAgZXYuZGF0YXMub3JpZ2luYWxZID0gb3JpZ2luYWxZO1xuICAgICAgcmV0dXJuIGV2O1xuICAgIH1cblxuICAgIHZhciBldmVudHMgPSB0cmlnZ2VyQ2hpbGRBYmxlcyhtb3ZlYWJsZSwgdGhpcywgXCJkcmFnQ29udHJvbFN0YXJ0XCIsIGUsIGZ1bmN0aW9uIChjaGlsZCwgZXYpIHtcbiAgICAgIHJldHVybiBzZXREaXN0KGNoaWxkLCBldik7XG4gICAgfSk7XG5cbiAgICB2YXIgbmV4dFBhcmFtcyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBwYXJhbXMpLCB7XG4gICAgICB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzLFxuICAgICAgZXZlbnRzOiBldmVudHMsXG4gICAgICBzZXRGaXhlZERpcmVjdGlvbjogZnVuY3Rpb24gKGZpeGVkRGlyZWN0aW9uKSB7XG4gICAgICAgIHBhcmFtcy5zZXRGaXhlZERpcmVjdGlvbihmaXhlZERpcmVjdGlvbik7XG4gICAgICAgIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldiwgaSkge1xuICAgICAgICAgIGV2LnNldEZpeGVkRGlyZWN0aW9uKGZpeGVkRGlyZWN0aW9uKTtcbiAgICAgICAgICBzZXREaXN0KG1vdmVhYmxlLm1vdmVhYmxlc1tpXSwgb3JpZ2luYWxFdmVudHNbaV0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciByZXN1bHQgPSB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25SZXNpemVHcm91cFN0YXJ0XCIsIG5leHRQYXJhbXMpO1xuICAgIGRhdGFzLmlzUmVzaXplID0gcmVzdWx0ICE9PSBmYWxzZTtcbiAgICByZXR1cm4gZGF0YXMuaXNSZXNpemUgPyBwYXJhbXMgOiBmYWxzZTtcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIGRhdGFzID0gZS5kYXRhcztcblxuICAgIGlmICghZGF0YXMuaXNSZXNpemUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGFyYW1zID0gdGhpcy5kcmFnQ29udHJvbChtb3ZlYWJsZSwgZSk7XG5cbiAgICBpZiAoIXBhcmFtcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBvZmZzZXRXaWR0aCA9IHBhcmFtcy5vZmZzZXRXaWR0aCxcbiAgICAgICAgb2Zmc2V0SGVpZ2h0ID0gcGFyYW1zLm9mZnNldEhlaWdodCxcbiAgICAgICAgZGlzdCA9IHBhcmFtcy5kaXN0O1xuICAgIHZhciBrZWVwUmF0aW8gPSBtb3ZlYWJsZS5wcm9wcy5rZWVwUmF0aW87XG4gICAgdmFyIHBhcmVudFNjYWxlID0gW29mZnNldFdpZHRoIC8gKG9mZnNldFdpZHRoIC0gZGlzdFswXSksIG9mZnNldEhlaWdodCAvIChvZmZzZXRIZWlnaHQgLSBkaXN0WzFdKV07XG4gICAgdmFyIGZpeGVkUG9zaXRpb24gPSBkYXRhcy5maXhlZFBvc2l0aW9uO1xuICAgIHZhciBldmVudHMgPSB0cmlnZ2VyQ2hpbGRBYmxlcyhtb3ZlYWJsZSwgdGhpcywgXCJkcmFnQ29udHJvbFwiLCBlLCBmdW5jdGlvbiAoXywgZXYpIHtcbiAgICAgIHZhciBfYSA9IGNhbGN1bGF0ZShjcmVhdGVSb3RhdGVNYXRyaXgobW92ZWFibGUucm90YXRpb24gLyAxODAgKiBNYXRoLlBJLCAzKSwgW2V2LmRhdGFzLm9yaWdpbmFsWCAqIHBhcmVudFNjYWxlWzBdLCBldi5kYXRhcy5vcmlnaW5hbFkgKiBwYXJlbnRTY2FsZVsxXSwgMV0sIDMpLFxuICAgICAgICAgIGNsaWVudFggPSBfYVswXSxcbiAgICAgICAgICBjbGllbnRZID0gX2FbMV07XG5cbiAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZXYpLCB7XG4gICAgICAgIHBhcmVudERpc3Q6IG51bGwsXG4gICAgICAgIHBhcmVudFNjYWxlOiBwYXJlbnRTY2FsZSxcbiAgICAgICAgZHJhZ0NsaWVudDogcGx1cyhmaXhlZFBvc2l0aW9uLCBbY2xpZW50WCwgY2xpZW50WV0pLFxuICAgICAgICBwYXJlbnRLZWVwUmF0aW86IGtlZXBSYXRpb1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB2YXIgbmV4dFBhcmFtcyA9IF9fYXNzaWduKHtcbiAgICAgIHRhcmdldHM6IG1vdmVhYmxlLnByb3BzLnRhcmdldHMsXG4gICAgICBldmVudHM6IGV2ZW50c1xuICAgIH0sIHBhcmFtcyk7XG5cbiAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25SZXNpemVHcm91cFwiLCBuZXh0UGFyYW1zKTtcbiAgICByZXR1cm4gbmV4dFBhcmFtcztcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIGlzRHJhZyA9IGUuaXNEcmFnLFxuICAgICAgICBkYXRhcyA9IGUuZGF0YXM7XG5cbiAgICBpZiAoIWRhdGFzLmlzUmVzaXplKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5kcmFnQ29udHJvbEVuZChtb3ZlYWJsZSwgZSk7XG4gICAgdmFyIGV2ZW50cyA9IHRyaWdnZXJDaGlsZEFibGVzKG1vdmVhYmxlLCB0aGlzLCBcImRyYWdDb250cm9sRW5kXCIsIGUpO1xuICAgIHZhciBuZXh0UGFyYW1zID0gZmlsbEVuZFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xuICAgICAgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0cyxcbiAgICAgIGV2ZW50czogZXZlbnRzXG4gICAgfSk7XG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUmVzaXplR3JvdXBFbmRcIiwgbmV4dFBhcmFtcyk7XG4gICAgcmV0dXJuIGlzRHJhZztcbiAgfSxcblxuICAvKipcbiAgICogQG1ldGhvZCBNb3ZlYWJsZS5SZXNpemFibGUjcmVxdWVzdFxuICAgKiBAcGFyYW0ge29iamVjdH0gW2VdIC0gdGhlIFJlc2l6YWJsZSdzIHJlcXVlc3QgcGFyYW1ldGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZS5kaXJlY3Rpb249WzEsIDFdXSAtIERpcmVjdGlvbiB0byByZXNpemVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtlLmRlbHRhV2lkdGhdIC0gZGVsdGEgbnVtYmVyIG9mIHdpZHRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZS5kZWx0YUhlaWdodF0gLSBkZWx0YSBudW1iZXIgb2YgaGVpZ2h0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZS5vZmZzZXRXaWR0aF0gLSBvZmZzZXQgbnVtYmVyIG9mIHdpZHRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZS5vZmZzZXRIZWlnaHRdIC0gb2Zmc2V0IG51bWJlciBvZiBoZWlnaHRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtlLmlzSW5zdGFudF0gLSBXaGV0aGVyIHRvIGV4ZWN1dGUgdGhlIHJlcXVlc3QgaW5zdGFudGx5XG4gICAqIEByZXR1cm4ge01vdmVhYmxlLlJlcXVlc3Rlcn0gTW92ZWFibGUgUmVxdWVzdGVyXG4gICAqIEBleGFtcGxlXG4gICAgKiAvLyBJbnN0YW50bHkgUmVxdWVzdCAocmVxdWVzdFN0YXJ0IC0gcmVxdWVzdCAtIHJlcXVlc3RFbmQpXG4gICAqIC8vIFVzZSBSZWxhdGl2ZSBWYWx1ZVxuICAgKiBtb3ZlYWJsZS5yZXF1ZXN0KFwicmVzaXphYmxlXCIsIHsgZGVsdGFXaWR0aDogMTAsIGRlbHRhSGVpZ2h0OiAxMCB9LCB0cnVlKTtcbiAgICpcbiAgICogLy8gVXNlIEFic29sdXRlIFZhbHVlXG4gICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJyZXNpemFibGVcIiwgeyBvZmZzZXRXaWR0aDogMTAwLCBvZmZzZXRIZWlnaHQ6IDEwMCB9LCB0cnVlKTtcbiAgICpcbiAgICogLy8gcmVxdWVzdFN0YXJ0XG4gICAqIGNvbnN0IHJlcXVlc3RlciA9IG1vdmVhYmxlLnJlcXVlc3QoXCJyZXNpemFibGVcIik7XG4gICAqXG4gICAqIC8vIHJlcXVlc3RcbiAgICogLy8gVXNlIFJlbGF0aXZlIFZhbHVlXG4gICAqIHJlcXVlc3Rlci5yZXF1ZXN0KHsgZGVsdGFXaWR0aDogMTAsIGRlbHRhSGVpZ2h0OiAxMCB9KTtcbiAgICogcmVxdWVzdGVyLnJlcXVlc3QoeyBkZWx0YVdpZHRoOiAxMCwgZGVsdGFIZWlnaHQ6IDEwIH0pO1xuICAgKiByZXF1ZXN0ZXIucmVxdWVzdCh7IGRlbHRhV2lkdGg6IDEwLCBkZWx0YUhlaWdodDogMTAgfSk7XG4gICAqXG4gICAqIC8vIFVzZSBBYnNvbHV0ZSBWYWx1ZVxuICAgKiBtb3ZlYWJsZS5yZXF1ZXN0KFwicmVzaXphYmxlXCIsIHsgb2Zmc2V0V2lkdGg6IDEwMCwgb2Zmc2V0SGVpZ2h0OiAxMDAgfSk7XG4gICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJyZXNpemFibGVcIiwgeyBvZmZzZXRXaWR0aDogMTEwLCBvZmZzZXRIZWlnaHQ6IDEwMCB9KTtcbiAgICogbW92ZWFibGUucmVxdWVzdChcInJlc2l6YWJsZVwiLCB7IG9mZnNldFdpZHRoOiAxMjAsIG9mZnNldEhlaWdodDogMTAwIH0pO1xuICAgKlxuICAgKiAvLyByZXF1ZXN0RW5kXG4gICAqIHJlcXVlc3Rlci5yZXF1ZXN0RW5kKCk7XG4gICAqL1xuICByZXF1ZXN0OiBmdW5jdGlvbiAobW92ZWFibGUpIHtcbiAgICB2YXIgZGF0YXMgPSB7fTtcbiAgICB2YXIgZGlzdFdpZHRoID0gMDtcbiAgICB2YXIgZGlzdEhlaWdodCA9IDA7XG4gICAgdmFyIHJlY3QgPSBtb3ZlYWJsZS5nZXRSZWN0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzQ29udHJvbDogdHJ1ZSxcbiAgICAgIHJlcXVlc3RTdGFydDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhczogZGF0YXMsXG4gICAgICAgICAgcGFyZW50RGlyZWN0aW9uOiBlLmRpcmVjdGlvbiB8fCBbMSwgMV1cbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICByZXF1ZXN0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoXCJvZmZzZXRXaWR0aFwiIGluIGUpIHtcbiAgICAgICAgICBkaXN0V2lkdGggPSBlLm9mZnNldFdpZHRoIC0gcmVjdC5vZmZzZXRXaWR0aDtcbiAgICAgICAgfSBlbHNlIGlmIChcImRlbHRhV2lkdGhcIiBpbiBlKSB7XG4gICAgICAgICAgZGlzdFdpZHRoICs9IGUuZGVsdGFXaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcIm9mZnNldEhlaWdodFwiIGluIGUpIHtcbiAgICAgICAgICBkaXN0SGVpZ2h0ID0gZS5vZmZzZXRIZWlnaHQgLSByZWN0Lm9mZnNldEhlaWdodDtcbiAgICAgICAgfSBlbHNlIGlmIChcImRlbHRhSGVpZ2h0XCIgaW4gZSkge1xuICAgICAgICAgIGRpc3RIZWlnaHQgKz0gZS5kZWx0YUhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YXM6IGRhdGFzLFxuICAgICAgICAgIHBhcmVudERpc3Q6IFtkaXN0V2lkdGgsIGRpc3RIZWlnaHRdXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgcmVxdWVzdEVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGFzOiBkYXRhcyxcbiAgICAgICAgICBpc0RyYWc6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuLyoqXG4gKiBXaGV0aGVyIG9yIG5vdCB0YXJnZXQgY2FuIGJlIHJlc2l6ZWQuIChkZWZhdWx0OiBmYWxzZSlcbiAqIEBuYW1lIE1vdmVhYmxlLlJlc2l6YWJsZSNyZXNpemFibGVcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICAgIHJlc2l6YWJsZTogZmFsc2UsXG4gKiB9KTtcbiAqXG4gKiBtb3ZlYWJsZS5yZXNpemFibGUgPSB0cnVlO1xuICovXG5cbi8qKlxuICogdGhyb3R0bGUgb2Ygd2lkdGgsIGhlaWdodCB3aGVuIHJlc2l6ZS5cbiAqIEBuYW1lIE1vdmVhYmxlLlJlc2l6YWJsZSN0aHJvdHRsZVJlc2l6ZVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgIHJlc2l6YWJsZTogdHJ1ZSxcbiAqICAgdGhyb3R0bGVSZXNpemU6IDAsXG4gKiB9KTtcbiAqXG4gKiBtb3ZlYWJsZS50aHJvdHRsZVJlc2l6ZSA9IDE7XG4gKi9cblxuLyoqXG4gKiBXaGVuIHJlc2l6ZSBvciBzY2FsZSwga2VlcHMgYSByYXRpbyBvZiB0aGUgd2lkdGgsIGhlaWdodC4gKGRlZmF1bHQ6IGZhbHNlKVxuICogQG5hbWUgTW92ZWFibGUuUmVzaXphYmxlI2tlZXBSYXRpb1xuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgIHJlc2l6YWJsZTogdHJ1ZSxcbiAqIH0pO1xuICpcbiAqIG1vdmVhYmxlLmtlZXBSYXRpbyA9IHRydWU7XG4gKi9cblxuLyoqXG4gKiBTZXQgZGlyZWN0aW9ucyB0byBzaG93IHRoZSBjb250cm9sIGJveC4gKGRlZmF1bHQ6IFtcIm5cIiwgXCJud1wiLCBcIm5lXCIsIFwic1wiLCBcInNlXCIsIFwic3dcIiwgXCJlXCIsIFwid1wiXSlcbiAqIEBuYW1lIE1vdmVhYmxlLlJlc2l6YWJsZSNyZW5kZXJEaXJlY3Rpb25zXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgcmVzaXphYmxlOiB0cnVlLFxuICogICByZW5kZXJEaXJlY3Rpb25zOiBbXCJuXCIsIFwibndcIiwgXCJuZVwiLCBcInNcIiwgXCJzZVwiLCBcInN3XCIsIFwiZVwiLCBcIndcIl0sXG4gKiB9KTtcbiAqXG4gKiBtb3ZlYWJsZS5yZW5kZXJEaXJlY3Rpb25zID0gW1wibndcIiwgXCJuZVwiLCBcInN3XCIsIFwic2VcIl07XG4gKi9cblxuLyoqXG4gKiBXaGVuIHRoZSByZXNpemUgc3RhcnRzLCB0aGUgcmVzaXplU3RhcnQgZXZlbnQgaXMgY2FsbGVkLlxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlJlc2l6YWJsZVxuICogQGV2ZW50IHJlc2l6ZVN0YXJ0XG4gKiBAcGFyYW0ge01vdmVhYmxlLlJlc2l6YWJsZS5PblJlc2l6ZVN0YXJ0fSAtIFBhcmFtZXRlcnMgZm9yIHRoZSByZXNpemVTdGFydCBldmVudFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7IHJlc2l6YWJsZTogdHJ1ZSB9KTtcbiAqIG1vdmVhYmxlLm9uKFwicmVzaXplU3RhcnRcIiwgKHsgdGFyZ2V0IH0pID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyh0YXJnZXQpO1xuICogfSk7XG4gKi9cblxuLyoqXG4gKiBXaGVuIHJlc2l6aW5nLCB0aGUgcmVzaXplIGV2ZW50IGlzIGNhbGxlZC5cbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5SZXNpemFibGVcbiAqIEBldmVudCByZXNpemVcbiAqIEBwYXJhbSB7TW92ZWFibGUuUmVzaXphYmxlLk9uUmVzaXplfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSByZXNpemUgZXZlbnRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwgeyByZXNpemFibGU6IHRydWUgfSk7XG4gKiBtb3ZlYWJsZS5vbihcInJlc2l6ZVwiLCAoeyB0YXJnZXQsIHdpZHRoLCBoZWlnaHQgfSkgPT4ge1xuICogICAgIHRhcmdldC5zdHlsZS53aWR0aCA9IGAke2Uud2lkdGh9cHhgO1xuICogICAgIHRhcmdldC5zdHlsZS5oZWlnaHQgPSBgJHtlLmhlaWdodH1weGA7XG4gKiB9KTtcbiAqL1xuXG4vKipcbiAqIFdoZW4gdGhlIHJlc2l6ZSBmaW5pc2hlcywgdGhlIHJlc2l6ZUVuZCBldmVudCBpcyBjYWxsZWQuXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuUmVzaXphYmxlXG4gKiBAZXZlbnQgcmVzaXplRW5kXG4gKiBAcGFyYW0ge01vdmVhYmxlLlJlc2l6YWJsZS5PblJlc2l6ZUVuZH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgcmVzaXplRW5kIGV2ZW50XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHsgcmVzaXphYmxlOiB0cnVlIH0pO1xuICogbW92ZWFibGUub24oXCJyZXNpemVFbmRcIiwgKHsgdGFyZ2V0LCBpc0RyYWcgfSkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKHRhcmdldCwgaXNEcmFnKTtcbiAqIH0pO1xuICovXG5cbi8qKlxuKiBXaGVuIHRoZSBncm91cCByZXNpemUgc3RhcnRzLCB0aGUgYHJlc2l6ZUdyb3VwU3RhcnRgIGV2ZW50IGlzIGNhbGxlZC5cbiogQG1lbWJlcm9mIE1vdmVhYmxlLlJlc2l6YWJsZVxuKiBAZXZlbnQgcmVzaXplR3JvdXBTdGFydFxuKiBAcGFyYW0ge01vdmVhYmxlLlJlc2l6YWJsZS5PblJlc2l6ZUdyb3VwU3RhcnR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGByZXNpemVHcm91cFN0YXJ0YCBldmVudFxuKiBAZXhhbXBsZVxuKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4qXG4qIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiogICAgIHRhcmdldDogW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnRhcmdldFwiKSksXG4qICAgICByZXNpemFibGU6IHRydWVcbiogfSk7XG4qIG1vdmVhYmxlLm9uKFwicmVzaXplR3JvdXBTdGFydFwiLCAoeyB0YXJnZXRzIH0pID0+IHtcbiogICAgIGNvbnNvbGUubG9nKFwib25SZXNpemVHcm91cFN0YXJ0XCIsIHRhcmdldHMpO1xuKiB9KTtcbiovXG5cbi8qKlxuKiBXaGVuIHRoZSBncm91cCByZXNpemUsIHRoZSBgcmVzaXplR3JvdXBgIGV2ZW50IGlzIGNhbGxlZC5cbiogQG1lbWJlcm9mIE1vdmVhYmxlLlJlc2l6YWJsZVxuKiBAZXZlbnQgcmVzaXplR3JvdXBcbiogQHBhcmFtIHtNb3ZlYWJsZS5SZXNpemFibGUub25SZXNpemVHcm91cH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHJlc2l6ZUdyb3VwYCBldmVudFxuKiBAZXhhbXBsZVxuKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4qXG4qIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiogICAgIHRhcmdldDogW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnRhcmdldFwiKSksXG4qICAgICByZXNpemFibGU6IHRydWVcbiogfSk7XG4qIG1vdmVhYmxlLm9uKFwicmVzaXplR3JvdXBcIiwgKHsgdGFyZ2V0cywgZXZlbnRzIH0pID0+IHtcbiogICAgIGNvbnNvbGUubG9nKFwib25SZXNpemVHcm91cFwiLCB0YXJnZXRzKTtcbiogICAgIGV2ZW50cy5mb3JFYWNoKGV2ID0+IHtcbiogICAgICAgICBjb25zdCBvZmZzZXQgPSBbXG4qICAgICAgICAgICAgIGRpcmVjdGlvblswXSA8IDAgPyAtZXYuZGVsdGFbMF0gOiAwLFxuKiAgICAgICAgICAgICBkaXJlY3Rpb25bMV0gPCAwID8gLWV2LmRlbHRhWzFdIDogMCxcbiogICAgICAgICBdO1xuKiAgICAgICAgIC8vIGV2LmRyYWcgaXMgYSBkcmFnIGV2ZW50IHRoYXQgb2NjdXJzIHdoZW4gdGhlIGdyb3VwIHJlc2l6ZS5cbiogICAgICAgICBjb25zdCBsZWZ0ID0gb2Zmc2V0WzBdICsgZXYuZHJhZy5iZWZvcmVEaXN0WzBdO1xuKiAgICAgICAgIGNvbnN0IHRvcCA9IG9mZnNldFsxXSArIGV2LmRyYWcuYmVmb3JlRGlzdFsxXTtcbiogICAgICAgICBjb25zdCB3aWR0aCA9IGV2LndpZHRoO1xuKiAgICAgICAgIGNvbnN0IHRvcCA9IGV2LnRvcDtcbiogICAgIH0pO1xuKiB9KTtcbiovXG5cbi8qKlxuICogV2hlbiB0aGUgZ3JvdXAgcmVzaXplIGZpbmlzaGVzLCB0aGUgYHJlc2l6ZUdyb3VwRW5kYCBldmVudCBpcyBjYWxsZWQuXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuUmVzaXphYmxlXG4gKiBAZXZlbnQgcmVzaXplR3JvdXBFbmRcbiAqIEBwYXJhbSB7TW92ZWFibGUuUmVzaXphYmxlLk9uUmVzaXplR3JvdXBFbmR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGByZXNpemVHcm91cEVuZGAgZXZlbnRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICAgIHRhcmdldDogW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnRhcmdldFwiKSksXG4gKiAgICAgcmVzaXphYmxlOiB0cnVlXG4gKiB9KTtcbiAqIG1vdmVhYmxlLm9uKFwicmVzaXplR3JvdXBFbmRcIiwgKHsgdGFyZ2V0cywgaXNEcmFnIH0pID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhcIm9uUmVzaXplR3JvdXBFbmRcIiwgdGFyZ2V0cywgaXNEcmFnKTtcbiAqIH0pO1xuICovXG5cbi8qKlxuICogQG5hbWVzcGFjZSBTY2FsYWJsZVxuICogQG1lbWJlcm9mIE1vdmVhYmxlXG4gKiBAZGVzY3JpcHRpb24gU2NhbGFibGUgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRhcmdldCdzIHggYW5kIHkgY2FuIGJlIHNjYWxlIG9mIHRyYW5zZm9ybS5cbiAqL1xuXG52YXIgU2NhbGFibGUgPSB7XG4gIG5hbWU6IFwic2NhbGFibGVcIixcbiAgYWJsZUdyb3VwOiBcInNpemVcIixcbiAgY2FuUGluY2g6IHRydWUsXG4gIHByb3BzOiB7XG4gICAgc2NhbGFibGU6IEJvb2xlYW4sXG4gICAgdGhyb3R0bGVTY2FsZTogTnVtYmVyLFxuICAgIHJlbmRlckRpcmVjdGlvbnM6IFN0cmluZyxcbiAgICBrZWVwUmF0aW86IEJvb2xlYW5cbiAgfSxcbiAgZXZlbnRzOiB7XG4gICAgb25TY2FsZVN0YXJ0OiBcInNjYWxlU3RhcnRcIixcbiAgICBvblNjYWxlOiBcInNjYWxlXCIsXG4gICAgb25TY2FsZUVuZDogXCJzY2FsZUVuZFwiLFxuICAgIG9uU2NhbGVHcm91cFN0YXJ0OiBcInNjYWxlR3JvdXBTdGFydFwiLFxuICAgIG9uU2NhbGVHcm91cDogXCJzY2FsZUdyb3VwXCIsXG4gICAgb25TY2FsZUdyb3VwRW5kOiBcInNjYWxlR3JvdXBFbmRcIlxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgUmVhY3QpIHtcbiAgICB2YXIgX2EgPSBtb3ZlYWJsZS5wcm9wcyxcbiAgICAgICAgcmVzaXphYmxlID0gX2EucmVzaXphYmxlLFxuICAgICAgICBzY2FsYWJsZSA9IF9hLnNjYWxhYmxlLFxuICAgICAgICBlZGdlID0gX2EuZWRnZTtcblxuICAgIGlmICghcmVzaXphYmxlICYmIHNjYWxhYmxlKSB7XG4gICAgICBpZiAoZWRnZSkge1xuICAgICAgICByZXR1cm4gcmVuZGVyRGlhZ29uYWxEaXJlY3Rpb25zKG1vdmVhYmxlLCBSZWFjdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZW5kZXJBbGxEaXJlY3Rpb25zKG1vdmVhYmxlLCBSZWFjdCk7XG4gICAgfVxuICB9LFxuICBkcmFnQ29udHJvbENvbmRpdGlvbjogZGlyZWN0aW9uQ29uZGl0aW9uLFxuICBkcmFnQ29udHJvbFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB2YXIgZGF0YXMgPSBlLmRhdGFzLFxuICAgICAgICBpc1BpbmNoID0gZS5pc1BpbmNoLFxuICAgICAgICBpbnB1dEV2ZW50ID0gZS5pbnB1dEV2ZW50LFxuICAgICAgICBwYXJlbnREaXJlY3Rpb24gPSBlLnBhcmVudERpcmVjdGlvbjtcbiAgICB2YXIgZGlyZWN0aW9uID0gcGFyZW50RGlyZWN0aW9uIHx8IChpc1BpbmNoID8gWzAsIDBdIDogZ2V0RGlyZWN0aW9uKGlucHV0RXZlbnQudGFyZ2V0KSk7XG4gICAgdmFyIF9hID0gbW92ZWFibGUuc3RhdGUsXG4gICAgICAgIHdpZHRoID0gX2Eud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF9hLmhlaWdodCxcbiAgICAgICAgdGFyZ2V0VHJhbnNmb3JtID0gX2EudGFyZ2V0VHJhbnNmb3JtLFxuICAgICAgICB0YXJnZXQgPSBfYS50YXJnZXQsXG4gICAgICAgIHBvczEgPSBfYS5wb3MxLFxuICAgICAgICBwb3MyID0gX2EucG9zMixcbiAgICAgICAgcG9zNCA9IF9hLnBvczQ7XG5cbiAgICBpZiAoIWRpcmVjdGlvbiB8fCAhdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFpc1BpbmNoKSB7XG4gICAgICBzZXREcmFnU3RhcnQobW92ZWFibGUsIGUpO1xuICAgIH1cblxuICAgIGRhdGFzLmRhdGFzID0ge307XG4gICAgZGF0YXMudHJhbnNmb3JtID0gdGFyZ2V0VHJhbnNmb3JtO1xuICAgIGRhdGFzLnByZXZEaXN0ID0gWzEsIDFdO1xuICAgIGRhdGFzLmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICBkYXRhcy53aWR0aCA9IHdpZHRoO1xuICAgIGRhdGFzLmhlaWdodCA9IGhlaWdodDtcbiAgICBkYXRhcy5zdGFydFZhbHVlID0gWzEsIDFdO1xuICAgIHZhciBzY2FsZVdpZHRoID0gZ2V0RGlzdCQxKHBvczEsIHBvczIpO1xuICAgIHZhciBzY2FsZUhlaWdodCA9IGdldERpc3QkMShwb3MyLCBwb3M0KTtcbiAgICB2YXIgaXNXaWR0aCA9ICFkaXJlY3Rpb25bMF0gJiYgIWRpcmVjdGlvblsxXSB8fCBkaXJlY3Rpb25bMF0gfHwgIWRpcmVjdGlvblsxXTtcbiAgICBkYXRhcy5zY2FsZVdpZHRoID0gc2NhbGVXaWR0aDtcbiAgICBkYXRhcy5zY2FsZUhlaWdodCA9IHNjYWxlSGVpZ2h0O1xuICAgIGRhdGFzLnNjYWxlWFJhdGlvID0gc2NhbGVXaWR0aCAvIHdpZHRoO1xuICAgIGRhdGFzLnNjYWxlWVJhdGlvID0gc2NhbGVIZWlnaHQgLyBoZWlnaHQ7XG4gICAgc2V0RGVmYXVsdFRyYW5zZm9ybUluZGV4KGUsIFwic2NhbGVcIik7XG4gICAgZGF0YXMuaXNXaWR0aCA9IGlzV2lkdGg7XG5cbiAgICBmdW5jdGlvbiBzZXRSYXRpbyhyYXRpbykge1xuICAgICAgZGF0YXMucmF0aW8gPSByYXRpbyAmJiBpc0Zpbml0ZShyYXRpbykgPyByYXRpbyA6IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0Rml4ZWREaXJlY3Rpb24oZml4ZWREaXJlY3Rpb24pIHtcbiAgICAgIGRhdGFzLmZpeGVkRGlyZWN0aW9uID0gZml4ZWREaXJlY3Rpb247XG4gICAgICBkYXRhcy5maXhlZFBvc2l0aW9uID0gZ2V0QWJzb2x1dGVQb3NpdGlvbihtb3ZlYWJsZSwgZml4ZWREaXJlY3Rpb24pO1xuICAgIH1cblxuICAgIHNldFJhdGlvKGdldERpc3QkMShwb3MxLCBwb3MyKSAvIGdldERpc3QkMShwb3MyLCBwb3M0KSk7XG4gICAgc2V0Rml4ZWREaXJlY3Rpb24oWy1kaXJlY3Rpb25bMF0sIC1kaXJlY3Rpb25bMV1dKTtcbiAgICB2YXIgcGFyYW1zID0gZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwgX19hc3NpZ24oX19hc3NpZ24oe1xuICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChzY2FsZSkge1xuICAgICAgICBkYXRhcy5zdGFydFZhbHVlID0gc2NhbGU7XG4gICAgICB9LFxuICAgICAgc2V0UmF0aW86IHNldFJhdGlvLFxuICAgICAgc2V0Rml4ZWREaXJlY3Rpb246IHNldEZpeGVkRGlyZWN0aW9uXG4gICAgfSwgZmlsbFRyYW5zZm9ybVN0YXJ0RXZlbnQoZSkpLCB7XG4gICAgICBkcmFnU3RhcnQ6IERyYWdnYWJsZS5kcmFnU3RhcnQobW92ZWFibGUsIG5ldyBDdXN0b21HZXN0bygpLmRyYWdTdGFydChbMCwgMF0sIGUpKVxuICAgIH0pKTtcbiAgICB2YXIgcmVzdWx0ID0gdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uU2NhbGVTdGFydFwiLCBwYXJhbXMpO1xuXG4gICAgaWYgKHJlc3VsdCAhPT0gZmFsc2UpIHtcbiAgICAgIGRhdGFzLmlzU2NhbGUgPSB0cnVlO1xuICAgICAgbW92ZWFibGUuc3RhdGUuc25hcFJlbmRlckluZm8gPSB7XG4gICAgICAgIHJlcXVlc3Q6IGUuaXNSZXF1ZXN0LFxuICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvblxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YXMuaXNTY2FsZSA/IHBhcmFtcyA6IGZhbHNlO1xuICB9LFxuICBkcmFnQ29udHJvbDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgcmVzb2x2ZVRyYW5zZm9ybUV2ZW50KGUsIFwic2NhbGVcIik7XG4gICAgdmFyIGRhdGFzID0gZS5kYXRhcyxcbiAgICAgICAgZGlzdFggPSBlLmRpc3RYLFxuICAgICAgICBkaXN0WSA9IGUuZGlzdFksXG4gICAgICAgIHBhcmVudFNjYWxlID0gZS5wYXJlbnRTY2FsZSxcbiAgICAgICAgcGFyZW50RGlzdGFuY2UgPSBlLnBhcmVudERpc3RhbmNlLFxuICAgICAgICBwYXJlbnRLZWVwUmF0aW8gPSBlLnBhcmVudEtlZXBSYXRpbyxcbiAgICAgICAgcGFyZW50RmxhZyA9IGUucGFyZW50RmxhZyxcbiAgICAgICAgaXNQaW5jaCA9IGUuaXNQaW5jaCxcbiAgICAgICAgZHJhZ0NsaWVudCA9IGUuZHJhZ0NsaWVudCxcbiAgICAgICAgcGFyZW50RGlzdCA9IGUucGFyZW50RGlzdCxcbiAgICAgICAgaXNSZXF1ZXN0ID0gZS5pc1JlcXVlc3Q7XG4gICAgdmFyIHByZXZEaXN0ID0gZGF0YXMucHJldkRpc3QsXG4gICAgICAgIGRpcmVjdGlvbiA9IGRhdGFzLmRpcmVjdGlvbixcbiAgICAgICAgd2lkdGggPSBkYXRhcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gZGF0YXMuaGVpZ2h0LFxuICAgICAgICBpc1NjYWxlID0gZGF0YXMuaXNTY2FsZSxcbiAgICAgICAgc3RhcnRWYWx1ZSA9IGRhdGFzLnN0YXJ0VmFsdWUsXG4gICAgICAgIGlzV2lkdGggPSBkYXRhcy5pc1dpZHRoLFxuICAgICAgICByYXRpbyA9IGRhdGFzLnJhdGlvLFxuICAgICAgICBmaXhlZERpcmVjdGlvbiA9IGRhdGFzLmZpeGVkRGlyZWN0aW9uLFxuICAgICAgICBzY2FsZVhSYXRpbyA9IGRhdGFzLnNjYWxlWFJhdGlvLFxuICAgICAgICBzY2FsZVlSYXRpbyA9IGRhdGFzLnNjYWxlWVJhdGlvO1xuXG4gICAgaWYgKCFpc1NjYWxlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIF9hID0gbW92ZWFibGUucHJvcHMsXG4gICAgICAgIHRocm90dGxlU2NhbGUgPSBfYS50aHJvdHRsZVNjYWxlLFxuICAgICAgICBwYXJlbnRNb3ZlYWJsZSA9IF9hLnBhcmVudE1vdmVhYmxlO1xuICAgIHZhciBzaXplRGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuXG4gICAgaWYgKCFkaXJlY3Rpb25bMF0gJiYgIWRpcmVjdGlvblsxXSkge1xuICAgICAgc2l6ZURpcmVjdGlvbiA9IFsxLCAxXTtcbiAgICB9XG5cbiAgICB2YXIga2VlcFJhdGlvID0gcmF0aW8gJiYgKG1vdmVhYmxlLnByb3BzLmtlZXBSYXRpbyB8fCBwYXJlbnRLZWVwUmF0aW8pO1xuICAgIHZhciBzdGF0ZSA9IG1vdmVhYmxlLnN0YXRlO1xuICAgIHZhciBzY2FsZVggPSAxO1xuICAgIHZhciBzY2FsZVkgPSAxO1xuICAgIHZhciBmaXhlZFBvc2l0aW9uID0gZHJhZ0NsaWVudDtcblxuICAgIGlmICghZHJhZ0NsaWVudCkge1xuICAgICAgaWYgKCFwYXJlbnRGbGFnICYmIGlzUGluY2gpIHtcbiAgICAgICAgZml4ZWRQb3NpdGlvbiA9IGdldEFic29sdXRlUG9zaXRpb24obW92ZWFibGUsIFswLCAwXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaXhlZFBvc2l0aW9uID0gZGF0YXMuZml4ZWRQb3NpdGlvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGFyZW50RGlzdCkge1xuICAgICAgc2NhbGVYID0gKHdpZHRoICsgcGFyZW50RGlzdFswXSkgLyB3aWR0aDtcbiAgICAgIHNjYWxlWSA9IChoZWlnaHQgKyBwYXJlbnREaXN0WzFdKSAvIGhlaWdodDtcbiAgICB9IGVsc2UgaWYgKHBhcmVudFNjYWxlKSB7XG4gICAgICBzY2FsZVggPSBwYXJlbnRTY2FsZVswXTtcbiAgICAgIHNjYWxlWSA9IHBhcmVudFNjYWxlWzFdO1xuICAgIH0gZWxzZSBpZiAoaXNQaW5jaCkge1xuICAgICAgaWYgKHBhcmVudERpc3RhbmNlKSB7XG4gICAgICAgIHNjYWxlWCA9ICh3aWR0aCArIHBhcmVudERpc3RhbmNlKSAvIHdpZHRoO1xuICAgICAgICBzY2FsZVkgPSAoaGVpZ2h0ICsgcGFyZW50RGlzdGFuY2UgKiBoZWlnaHQgLyB3aWR0aCkgLyBoZWlnaHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkcmFnRGlzdCA9IGdldERyYWdEaXN0KHtcbiAgICAgICAgZGF0YXM6IGRhdGFzLFxuICAgICAgICBkaXN0WDogZGlzdFgsXG4gICAgICAgIGRpc3RZOiBkaXN0WVxuICAgICAgfSk7XG4gICAgICB2YXIgZGlzdFNjYWxlV2lkdGggPSBzaXplRGlyZWN0aW9uWzBdICogZHJhZ0Rpc3RbMF0gKiBzY2FsZVhSYXRpbztcbiAgICAgIHZhciBkaXN0U2NhbGVIZWlnaHQgPSBzaXplRGlyZWN0aW9uWzFdICogZHJhZ0Rpc3RbMV0gKiBzY2FsZVlSYXRpbztcblxuICAgICAgaWYgKGtlZXBSYXRpbyAmJiB3aWR0aCAmJiBoZWlnaHQpIHtcbiAgICAgICAgaWYgKCFzaXplRGlyZWN0aW9uWzBdKSB7XG4gICAgICAgICAgLy8gdG9wLCBib3R0b21cbiAgICAgICAgICAvLyBkaXN0SGVpZ2h0ID0gc2lnblNpemU7XG4gICAgICAgICAgZGlzdFNjYWxlV2lkdGggPSBkaXN0U2NhbGVIZWlnaHQgKiByYXRpbztcbiAgICAgICAgfSBlbHNlIGlmICghc2l6ZURpcmVjdGlvblsxXSkge1xuICAgICAgICAgIC8vIGxlZnQsIHJpZ2h0XG4gICAgICAgICAgLy8gZGlzdFdpZHRoID0gc2lnblNpemU7XG4gICAgICAgICAgZGlzdFNjYWxlSGVpZ2h0ID0gZGlzdFNjYWxlV2lkdGggLyByYXRpbztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc2l6ZSA9IGdldERpc3RTaXplKFtkaXN0U2NhbGVXaWR0aCwgZGlzdFNjYWxlSGVpZ2h0XSk7IC8vIHR3by13YXlcblxuICAgICAgICAgIHZhciBkcmFnUmFkID0gZ2V0UmFkKFswLCAwXSwgZHJhZ0Rpc3QpO1xuICAgICAgICAgIHZhciBzdGFuZGFyZFJhZCA9IGdldFJhZChbMCwgMF0sIHNpemVEaXJlY3Rpb24pO1xuICAgICAgICAgIHZhciBzaWduU2l6ZSA9IE1hdGguY29zKGRyYWdSYWQgLSBzdGFuZGFyZFJhZCkgKiBzaXplO1xuICAgICAgICAgIHZhciByYXRpb1JhZCA9IGdldFJhZChbMCwgMF0sIFtyYXRpbywgMV0pO1xuICAgICAgICAgIGRpc3RTY2FsZVdpZHRoID0gTWF0aC5jb3MocmF0aW9SYWQpICogc2lnblNpemU7XG4gICAgICAgICAgZGlzdFNjYWxlSGVpZ2h0ID0gTWF0aC5zaW4ocmF0aW9SYWQpICogc2lnblNpemU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2NhbGVYID0gKHdpZHRoICsgZGlzdFNjYWxlV2lkdGggLyBzY2FsZVhSYXRpbykgLyB3aWR0aDtcbiAgICAgIHNjYWxlWSA9IChoZWlnaHQgKyBkaXN0U2NhbGVIZWlnaHQgLyBzY2FsZVlSYXRpbykgLyBoZWlnaHQ7XG4gICAgfVxuXG4gICAgc2NhbGVYID0gc2l6ZURpcmVjdGlvblswXSB8fCBrZWVwUmF0aW8gPyBzY2FsZVggKiBzdGFydFZhbHVlWzBdIDogc3RhcnRWYWx1ZVswXTtcbiAgICBzY2FsZVkgPSBzaXplRGlyZWN0aW9uWzFdIHx8IGtlZXBSYXRpbyA/IHNjYWxlWSAqIHN0YXJ0VmFsdWVbMV0gOiBzdGFydFZhbHVlWzFdO1xuXG4gICAgaWYgKHNjYWxlWCA9PT0gMCkge1xuICAgICAgc2NhbGVYID0gKHByZXZEaXN0WzBdID4gMCA/IDEgOiAtMSkgKiBNSU5fU0NBTEU7XG4gICAgfVxuXG4gICAgaWYgKHNjYWxlWSA9PT0gMCkge1xuICAgICAgc2NhbGVZID0gKHByZXZEaXN0WzFdID4gMCA/IDEgOiAtMSkgKiBNSU5fU0NBTEU7XG4gICAgfVxuXG4gICAgdmFyIGRpc3QgPSBbc2NhbGVYIC8gc3RhcnRWYWx1ZVswXSwgc2NhbGVZIC8gc3RhcnRWYWx1ZVsxXV07XG4gICAgdmFyIHNjYWxlID0gW3NjYWxlWCwgc2NhbGVZXTtcblxuICAgIGlmICghaXNQaW5jaCAmJiBtb3ZlYWJsZS5wcm9wcy5ncm91cGFibGUpIHtcbiAgICAgIHZhciBzbmFwUmVuZGVySW5mbyA9IHN0YXRlLnNuYXBSZW5kZXJJbmZvIHx8IHt9O1xuICAgICAgdmFyIHN0YXRlRGlyZWN0aW9uID0gc25hcFJlbmRlckluZm8uZGlyZWN0aW9uO1xuXG4gICAgICBpZiAoaXNBcnJheShzdGF0ZURpcmVjdGlvbikgJiYgKHN0YXRlRGlyZWN0aW9uWzBdIHx8IHN0YXRlRGlyZWN0aW9uWzFdKSkge1xuICAgICAgICBzdGF0ZS5zbmFwUmVuZGVySW5mbyA9IHtcbiAgICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvbixcbiAgICAgICAgICByZXF1ZXN0OiBlLmlzUmVxdWVzdFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzbmFwRGlzdCA9IFswLCAwXTtcblxuICAgIGlmICghaXNQaW5jaCkge1xuICAgICAgc25hcERpc3QgPSBjaGVja1NuYXBTY2FsZShtb3ZlYWJsZSwgZGlzdCwgZGlyZWN0aW9uLCBpc1JlcXVlc3QsIGRhdGFzKTtcbiAgICB9XG5cbiAgICBpZiAoa2VlcFJhdGlvKSB7XG4gICAgICBpZiAoc2l6ZURpcmVjdGlvblswXSAmJiBzaXplRGlyZWN0aW9uWzFdICYmIHNuYXBEaXN0WzBdICYmIHNuYXBEaXN0WzFdKSB7XG4gICAgICAgIGlmIChNYXRoLmFicyhzbmFwRGlzdFswXSAqIHdpZHRoKSA+IE1hdGguYWJzKHNuYXBEaXN0WzFdICogaGVpZ2h0KSkge1xuICAgICAgICAgIHNuYXBEaXN0WzFdID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzbmFwRGlzdFswXSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGlzTm9TbmFwID0gIXNuYXBEaXN0WzBdICYmICFzbmFwRGlzdFsxXTtcblxuICAgICAgaWYgKGlzTm9TbmFwKSB7XG4gICAgICAgIGlmIChpc1dpZHRoKSB7XG4gICAgICAgICAgZGlzdFswXSA9IHRocm90dGxlKGRpc3RbMF0gKiBzdGFydFZhbHVlWzBdLCB0aHJvdHRsZVNjYWxlKSAvIHN0YXJ0VmFsdWVbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGlzdFsxXSA9IHRocm90dGxlKGRpc3RbMV0gKiBzdGFydFZhbHVlWzFdLCB0aHJvdHRsZVNjYWxlKSAvIHN0YXJ0VmFsdWVbMV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNpemVEaXJlY3Rpb25bMF0gJiYgIXNpemVEaXJlY3Rpb25bMV0gfHwgc25hcERpc3RbMF0gJiYgIXNuYXBEaXN0WzFdIHx8IGlzTm9TbmFwICYmIGlzV2lkdGgpIHtcbiAgICAgICAgZGlzdFswXSArPSBzbmFwRGlzdFswXTtcbiAgICAgICAgdmFyIHNuYXBIZWlnaHQgPSB3aWR0aCAqIGRpc3RbMF0gKiBzdGFydFZhbHVlWzBdIC8gcmF0aW87XG4gICAgICAgIGRpc3RbMV0gPSBzbmFwSGVpZ2h0IC8gaGVpZ2h0IC8gc3RhcnRWYWx1ZVsxXTtcbiAgICAgIH0gZWxzZSBpZiAoIXNpemVEaXJlY3Rpb25bMF0gJiYgc2l6ZURpcmVjdGlvblsxXSB8fCAhc25hcERpc3RbMF0gJiYgc25hcERpc3RbMV0gfHwgaXNOb1NuYXAgJiYgIWlzV2lkdGgpIHtcbiAgICAgICAgZGlzdFsxXSArPSBzbmFwRGlzdFsxXTtcbiAgICAgICAgdmFyIHNuYXBXaWR0aCA9IGhlaWdodCAqIGRpc3RbMV0gKiBzdGFydFZhbHVlWzFdICogcmF0aW87XG4gICAgICAgIGRpc3RbMF0gPSBzbmFwV2lkdGggLyB3aWR0aCAvIHN0YXJ0VmFsdWVbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpc3RbMF0gKz0gc25hcERpc3RbMF07XG4gICAgICBkaXN0WzFdICs9IHNuYXBEaXN0WzFdO1xuXG4gICAgICBpZiAoIXNuYXBEaXN0WzBdKSB7XG4gICAgICAgIGRpc3RbMF0gPSB0aHJvdHRsZShkaXN0WzBdICogc3RhcnRWYWx1ZVswXSwgdGhyb3R0bGVTY2FsZSkgLyBzdGFydFZhbHVlWzBdO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNuYXBEaXN0WzFdKSB7XG4gICAgICAgIGRpc3RbMV0gPSB0aHJvdHRsZShkaXN0WzFdICogc3RhcnRWYWx1ZVsxXSwgdGhyb3R0bGVTY2FsZSkgLyBzdGFydFZhbHVlWzFdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkaXN0WzBdID09PSAwKSB7XG4gICAgICBkaXN0WzBdID0gKHByZXZEaXN0WzBdID4gMCA/IDEgOiAtMSkgKiBNSU5fU0NBTEU7XG4gICAgfVxuXG4gICAgaWYgKGRpc3RbMV0gPT09IDApIHtcbiAgICAgIGRpc3RbMV0gPSAocHJldkRpc3RbMV0gPiAwID8gMSA6IC0xKSAqIE1JTl9TQ0FMRTtcbiAgICB9XG5cbiAgICB2YXIgZGVsdGEgPSBbZGlzdFswXSAvIHByZXZEaXN0WzBdLCBkaXN0WzFdIC8gcHJldkRpc3RbMV1dO1xuICAgIHNjYWxlID0gbXVsdGlwbHkyKGRpc3QsIHN0YXJ0VmFsdWUpO1xuICAgIHZhciBpbnZlcnNlRGlzdCA9IGdldFNjYWxlRGlzdChtb3ZlYWJsZSwgZGlzdCwgZml4ZWREaXJlY3Rpb24sIGZpeGVkUG9zaXRpb24sIGRhdGFzKTtcbiAgICB2YXIgaW52ZXJzZURlbHRhID0gbWludXMoaW52ZXJzZURpc3QsIGRhdGFzLnByZXZJbnZlcnNlRGlzdCB8fCBbMCwgMF0pO1xuICAgIGRhdGFzLnByZXZEaXN0ID0gZGlzdDtcbiAgICBkYXRhcy5wcmV2SW52ZXJzZURpc3QgPSBpbnZlcnNlRGlzdDtcblxuICAgIGlmIChzY2FsZVggPT09IHByZXZEaXN0WzBdICYmIHNjYWxlWSA9PT0gcHJldkRpc3RbMV0gJiYgaW52ZXJzZURlbHRhLmV2ZXJ5KGZ1bmN0aW9uIChudW0pIHtcbiAgICAgIHJldHVybiAhbnVtO1xuICAgIH0pICYmICFwYXJlbnRNb3ZlYWJsZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBuZXh0VHJhbnNmb3JtID0gY29udmVydFRyYW5zZm9ybUZvcm1hdChkYXRhcywgXCJzY2FsZShcIiArIHNjYWxlLmpvaW4oXCIsIFwiKSArIFwiKVwiLCBcInNjYWxlKFwiICsgZGlzdC5qb2luKFwiLCBcIikgKyBcIilcIik7XG4gICAgdmFyIHBhcmFtcyA9IGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIF9fYXNzaWduKHtcbiAgICAgIG9mZnNldFdpZHRoOiB3aWR0aCxcbiAgICAgIG9mZnNldEhlaWdodDogaGVpZ2h0LFxuICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24sXG4gICAgICAvLyBiZWZvcmVTY2FsZSxcbiAgICAgIC8vIGJlZm9yZURpc3QsXG4gICAgICAvLyBiZWZvcmVEZWx0YSxcbiAgICAgIHNjYWxlOiBzY2FsZSxcbiAgICAgIGRpc3Q6IGRpc3QsXG4gICAgICBkZWx0YTogZGVsdGEsXG4gICAgICBpc1BpbmNoOiAhIWlzUGluY2hcbiAgICB9LCBmaWxsVHJhbnNmb3JtRXZlbnQobW92ZWFibGUsIG5leHRUcmFuc2Zvcm0sIGludmVyc2VEZWx0YSwgaXNQaW5jaCwgZSkpKTtcbiAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25TY2FsZVwiLCBwYXJhbXMpO1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH0sXG4gIGRyYWdDb250cm9sRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB2YXIgZGF0YXMgPSBlLmRhdGFzLFxuICAgICAgICBpc0RyYWcgPSBlLmlzRHJhZztcblxuICAgIGlmICghZGF0YXMuaXNTY2FsZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGRhdGFzLmlzU2NhbGUgPSBmYWxzZTtcbiAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25TY2FsZUVuZFwiLCBmaWxsRW5kUGFyYW1zKG1vdmVhYmxlLCBlLCB7fSkpO1xuICAgIHJldHVybiBpc0RyYWc7XG4gIH0sXG4gIGRyYWdHcm91cENvbnRyb2xDb25kaXRpb246IGRpcmVjdGlvbkNvbmRpdGlvbixcbiAgZHJhZ0dyb3VwQ29udHJvbFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB2YXIgZGF0YXMgPSBlLmRhdGFzO1xuICAgIHZhciBwYXJhbXMgPSB0aGlzLmRyYWdDb250cm9sU3RhcnQobW92ZWFibGUsIGUpO1xuXG4gICAgaWYgKCFwYXJhbXMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgb3JpZ2luYWxFdmVudHMgPSBmaWxsQ2hpbGRFdmVudHMobW92ZWFibGUsIFwicmVzaXphYmxlXCIsIGUpO1xuXG4gICAgZnVuY3Rpb24gc2V0RGlzdChjaGlsZCwgZXYpIHtcbiAgICAgIHZhciBmaXhlZERpcmVjdGlvbiA9IGRhdGFzLmZpeGVkRGlyZWN0aW9uO1xuICAgICAgdmFyIGZpeGVkUG9zaXRpb24gPSBkYXRhcy5maXhlZFBvc2l0aW9uO1xuICAgICAgdmFyIHBvcyA9IGdldEFic29sdXRlUG9zaXRpb24oY2hpbGQsIGZpeGVkRGlyZWN0aW9uKTtcblxuICAgICAgdmFyIF9hID0gY2FsY3VsYXRlKGNyZWF0ZVJvdGF0ZU1hdHJpeCgtbW92ZWFibGUucm90YXRpb24gLyAxODAgKiBNYXRoLlBJLCAzKSwgW3Bvc1swXSAtIGZpeGVkUG9zaXRpb25bMF0sIHBvc1sxXSAtIGZpeGVkUG9zaXRpb25bMV0sIDFdLCAzKSxcbiAgICAgICAgICBvcmlnaW5hbFggPSBfYVswXSxcbiAgICAgICAgICBvcmlnaW5hbFkgPSBfYVsxXTtcblxuICAgICAgZXYuZGF0YXMub3JpZ2luYWxYID0gb3JpZ2luYWxYO1xuICAgICAgZXYuZGF0YXMub3JpZ2luYWxZID0gb3JpZ2luYWxZO1xuICAgICAgcmV0dXJuIGV2O1xuICAgIH1cblxuICAgIGRhdGFzLm1vdmVhYmxlU2NhbGUgPSBtb3ZlYWJsZS5zY2FsZTtcbiAgICB2YXIgZXZlbnRzID0gdHJpZ2dlckNoaWxkQWJsZXMobW92ZWFibGUsIHRoaXMsIFwiZHJhZ0NvbnRyb2xTdGFydFwiLCBlLCBmdW5jdGlvbiAoY2hpbGQsIGV2KSB7XG4gICAgICByZXR1cm4gc2V0RGlzdChjaGlsZCwgZXYpO1xuICAgIH0pO1xuXG4gICAgdmFyIG5leHRQYXJhbXMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcGFyYW1zKSwge1xuICAgICAgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0cyxcbiAgICAgIGV2ZW50czogZXZlbnRzLFxuICAgICAgc2V0Rml4ZWREaXJlY3Rpb246IGZ1bmN0aW9uIChmaXhlZERpcmVjdGlvbikge1xuICAgICAgICBwYXJhbXMuc2V0Rml4ZWREaXJlY3Rpb24oZml4ZWREaXJlY3Rpb24pO1xuICAgICAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXYsIGkpIHtcbiAgICAgICAgICBldi5zZXRGaXhlZERpcmVjdGlvbihmaXhlZERpcmVjdGlvbik7XG4gICAgICAgICAgc2V0RGlzdChtb3ZlYWJsZS5tb3ZlYWJsZXNbaV0sIG9yaWdpbmFsRXZlbnRzW2ldKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcmVzdWx0ID0gdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uU2NhbGVHcm91cFN0YXJ0XCIsIG5leHRQYXJhbXMpO1xuICAgIGRhdGFzLmlzU2NhbGUgPSByZXN1bHQgIT09IGZhbHNlO1xuICAgIHJldHVybiBkYXRhcy5pc1NjYWxlID8gbmV4dFBhcmFtcyA6IGZhbHNlO1xuICB9LFxuICBkcmFnR3JvdXBDb250cm9sOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB2YXIgZGF0YXMgPSBlLmRhdGFzO1xuXG4gICAgaWYgKCFkYXRhcy5pc1NjYWxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBhcmFtcyA9IHRoaXMuZHJhZ0NvbnRyb2wobW92ZWFibGUsIGUpO1xuXG4gICAgaWYgKCFwYXJhbXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbW92ZWFibGVTY2FsZSA9IGRhdGFzLm1vdmVhYmxlU2NhbGU7XG4gICAgbW92ZWFibGUuc2NhbGUgPSBbcGFyYW1zLnNjYWxlWzBdICogbW92ZWFibGVTY2FsZVswXSwgcGFyYW1zLnNjYWxlWzFdICogbW92ZWFibGVTY2FsZVsxXV07XG4gICAgdmFyIGtlZXBSYXRpbyA9IG1vdmVhYmxlLnByb3BzLmtlZXBSYXRpbztcbiAgICB2YXIgZGlzdCA9IHBhcmFtcy5kaXN0LFxuICAgICAgICBzY2FsZSA9IHBhcmFtcy5zY2FsZTtcbiAgICB2YXIgZml4ZWRQb3NpdGlvbiA9IGRhdGFzLmZpeGVkUG9zaXRpb247XG4gICAgdmFyIGV2ZW50cyA9IHRyaWdnZXJDaGlsZEFibGVzKG1vdmVhYmxlLCB0aGlzLCBcImRyYWdDb250cm9sXCIsIGUsIGZ1bmN0aW9uIChfLCBldikge1xuICAgICAgdmFyIF9hID0gY2FsY3VsYXRlKGNyZWF0ZVJvdGF0ZU1hdHJpeChtb3ZlYWJsZS5yb3RhdGlvbiAvIDE4MCAqIE1hdGguUEksIDMpLCBbZXYuZGF0YXMub3JpZ2luYWxYICogZGlzdFswXSwgZXYuZGF0YXMub3JpZ2luYWxZICogZGlzdFsxXSwgMV0sIDMpLFxuICAgICAgICAgIGNsaWVudFggPSBfYVswXSxcbiAgICAgICAgICBjbGllbnRZID0gX2FbMV07XG5cbiAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZXYpLCB7XG4gICAgICAgIHBhcmVudERpc3Q6IG51bGwsXG4gICAgICAgIHBhcmVudFNjYWxlOiBzY2FsZSxcbiAgICAgICAgcGFyZW50S2VlcFJhdGlvOiBrZWVwUmF0aW8sXG4gICAgICAgIGRyYWdDbGllbnQ6IHBsdXMoZml4ZWRQb3NpdGlvbiwgW2NsaWVudFgsIGNsaWVudFldKVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB2YXIgbmV4dFBhcmFtcyA9IF9fYXNzaWduKHtcbiAgICAgIHRhcmdldHM6IG1vdmVhYmxlLnByb3BzLnRhcmdldHMsXG4gICAgICBldmVudHM6IGV2ZW50c1xuICAgIH0sIHBhcmFtcyk7XG5cbiAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25TY2FsZUdyb3VwXCIsIG5leHRQYXJhbXMpO1xuICAgIHJldHVybiBuZXh0UGFyYW1zO1xuICB9LFxuICBkcmFnR3JvdXBDb250cm9sRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB2YXIgaXNEcmFnID0gZS5pc0RyYWcsXG4gICAgICAgIGRhdGFzID0gZS5kYXRhcztcblxuICAgIGlmICghZGF0YXMuaXNTY2FsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZHJhZ0NvbnRyb2xFbmQobW92ZWFibGUsIGUpO1xuICAgIHZhciBldmVudHMgPSB0cmlnZ2VyQ2hpbGRBYmxlcyhtb3ZlYWJsZSwgdGhpcywgXCJkcmFnQ29udHJvbEVuZFwiLCBlKTtcbiAgICB2YXIgbmV4dFBhcmFtcyA9IGZpbGxFbmRQYXJhbXMobW92ZWFibGUsIGUsIHtcbiAgICAgIHRhcmdldHM6IG1vdmVhYmxlLnByb3BzLnRhcmdldHMsXG4gICAgICBldmVudHM6IGV2ZW50c1xuICAgIH0pO1xuICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvblNjYWxlR3JvdXBFbmRcIiwgbmV4dFBhcmFtcyk7XG4gICAgcmV0dXJuIGlzRHJhZztcbiAgfSxcblxuICAvKipcbiAgICogQG1ldGhvZCBNb3ZlYWJsZS5TY2FsYWJsZSNyZXF1ZXN0XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbZV0gLSB0aGUgUmVzaXphYmxlJ3MgcmVxdWVzdCBwYXJhbWV0ZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtlLmRpcmVjdGlvbj1bMSwgMV1dIC0gRGlyZWN0aW9uIHRvIHNjYWxlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZS5kZWx0YVdpZHRoXSAtIGRlbHRhIG51bWJlciBvZiB3aWR0aFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2UuZGVsdGFIZWlnaHRdIC0gZGVsdGEgbnVtYmVyIG9mIGhlaWdodFxuICAgKiBAcmV0dXJuIHtNb3ZlYWJsZS5SZXF1ZXN0ZXJ9IE1vdmVhYmxlIFJlcXVlc3RlclxuICAgKiBAZXhhbXBsZVxuICAgICogLy8gSW5zdGFudGx5IFJlcXVlc3QgKHJlcXVlc3RTdGFydCAtIHJlcXVlc3QgLSByZXF1ZXN0RW5kKVxuICAgKiBtb3ZlYWJsZS5yZXF1ZXN0KFwic2NhbGFibGVcIiwgeyBkZWx0YVdpZHRoOiAxMCwgZGVsdGFIZWlnaHQ6IDEwIH0sIHRydWUpO1xuICAgKlxuICAgKiAvLyByZXF1ZXN0U3RhcnRcbiAgICogY29uc3QgcmVxdWVzdGVyID0gbW92ZWFibGUucmVxdWVzdChcInNjYWxhYmxlXCIpO1xuICAgKlxuICAgKiAvLyByZXF1ZXN0XG4gICAqIHJlcXVlc3Rlci5yZXF1ZXN0KHsgZGVsdGFXaWR0aDogMTAsIGRlbHRhSGVpZ2h0OiAxMCB9KTtcbiAgICogcmVxdWVzdGVyLnJlcXVlc3QoeyBkZWx0YVdpZHRoOiAxMCwgZGVsdGFIZWlnaHQ6IDEwIH0pO1xuICAgKiByZXF1ZXN0ZXIucmVxdWVzdCh7IGRlbHRhV2lkdGg6IDEwLCBkZWx0YUhlaWdodDogMTAgfSk7XG4gICAqXG4gICAqIC8vIHJlcXVlc3RFbmRcbiAgICogcmVxdWVzdGVyLnJlcXVlc3RFbmQoKTtcbiAgICovXG4gIHJlcXVlc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YXMgPSB7fTtcbiAgICB2YXIgZGlzdFdpZHRoID0gMDtcbiAgICB2YXIgZGlzdEhlaWdodCA9IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzQ29udHJvbDogdHJ1ZSxcbiAgICAgIHJlcXVlc3RTdGFydDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhczogZGF0YXMsXG4gICAgICAgICAgcGFyZW50RGlyZWN0aW9uOiBlLmRpcmVjdGlvbiB8fCBbMSwgMV1cbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICByZXF1ZXN0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBkaXN0V2lkdGggKz0gZS5kZWx0YVdpZHRoO1xuICAgICAgICBkaXN0SGVpZ2h0ICs9IGUuZGVsdGFIZWlnaHQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YXM6IGRhdGFzLFxuICAgICAgICAgIHBhcmVudERpc3Q6IFtkaXN0V2lkdGgsIGRpc3RIZWlnaHRdXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgcmVxdWVzdEVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGFzOiBkYXRhcyxcbiAgICAgICAgICBpc0RyYWc6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuLyoqXG4gKiBXaGV0aGVyIG9yIG5vdCB0YXJnZXQgY2FuIHNjYWxlZC4gKGRlZmF1bHQ6IGZhbHNlKVxuICogQG5hbWUgTW92ZWFibGUuU2NhbGFibGUjc2NhbGFibGVcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XG4gKlxuICogbW92ZWFibGUuc2NhbGFibGUgPSB0cnVlO1xuICovXG5cbi8qKlxuICogdGhyb3R0bGUgb2Ygc2NhbGVYLCBzY2FsZVkgd2hlbiBzY2FsZS5cbiAqIEBuYW1lIE1vdmVhYmxlLlNjYWxhYmxlI3Rocm90dGxlU2NhbGVcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XG4gKlxuICogbW92ZWFibGUudGhyb3R0bGVTY2FsZSA9IDAuMTtcbiAqL1xuXG4vKipcbiAqIFNldCBkaXJlY3Rpb25zIHRvIHNob3cgdGhlIGNvbnRyb2wgYm94LiAoZGVmYXVsdDogW1wiblwiLCBcIm53XCIsIFwibmVcIiwgXCJzXCIsIFwic2VcIiwgXCJzd1wiLCBcImVcIiwgXCJ3XCJdKVxuICogQG5hbWUgTW92ZWFibGUuU2NhbGFibGUjcmVuZGVyRGlyZWN0aW9uc1xuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgc2NhbGFibGU6IHRydWUsXG4gKiAgIHJlbmRlckRpcmVjdGlvbnM6IFtcIm5cIiwgXCJud1wiLCBcIm5lXCIsIFwic1wiLCBcInNlXCIsIFwic3dcIiwgXCJlXCIsIFwid1wiXSxcbiAqIH0pO1xuICpcbiAqIG1vdmVhYmxlLnJlbmRlckRpcmVjdGlvbnMgPSBbXCJud1wiLCBcIm5lXCIsIFwic3dcIiwgXCJzZVwiXTtcbiAqL1xuXG4vKipcbiAqIFdoZW4gcmVzaXplIG9yIHNjYWxlLCBrZWVwcyBhIHJhdGlvIG9mIHRoZSB3aWR0aCwgaGVpZ2h0LiAoZGVmYXVsdDogZmFsc2UpXG4gKiBAbmFtZSBNb3ZlYWJsZS5TY2FsYWJsZSNrZWVwUmF0aW9cbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICAgIHNjYWxhYmxlOiB0cnVlLFxuICogfSk7XG4gKlxuICogbW92ZWFibGUua2VlcFJhdGlvID0gdHJ1ZTtcbiAqL1xuXG4vKipcbiAqIFdoZW4gdGhlIHNjYWxlIHN0YXJ0cywgdGhlIHNjYWxlU3RhcnQgZXZlbnQgaXMgY2FsbGVkLlxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlNjYWxhYmxlXG4gKiBAZXZlbnQgc2NhbGVTdGFydFxuICogQHBhcmFtIHtNb3ZlYWJsZS5TY2FsYWJsZS5PblNjYWxlU3RhcnR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIHNjYWxlU3RhcnQgZXZlbnRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwgeyBzY2FsYWJsZTogdHJ1ZSB9KTtcbiAqIG1vdmVhYmxlLm9uKFwic2NhbGVTdGFydFwiLCAoeyB0YXJnZXQgfSkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKHRhcmdldCk7XG4gKiB9KTtcbiAqL1xuXG4vKipcbiAqIFdoZW4gc2NhbGluZywgdGhlIHNjYWxlIGV2ZW50IGlzIGNhbGxlZC5cbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5TY2FsYWJsZVxuICogQGV2ZW50IHNjYWxlXG4gKiBAcGFyYW0ge01vdmVhYmxlLlNjYWxhYmxlLk9uU2NhbGV9IC0gUGFyYW1ldGVycyBmb3IgdGhlIHNjYWxlIGV2ZW50XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHsgc2NhbGFibGU6IHRydWUgfSk7XG4gKiBtb3ZlYWJsZS5vbihcInNjYWxlXCIsICh7IHRhcmdldCwgdHJhbnNmb3JtLCBkaXN0IH0pID0+IHtcbiAqICAgICB0YXJnZXQuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICogfSk7XG4gKi9cblxuLyoqXG4gKiBXaGVuIHRoZSBzY2FsZSBmaW5pc2hlcywgdGhlIHNjYWxlRW5kIGV2ZW50IGlzIGNhbGxlZC5cbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5TY2FsYWJsZVxuICogQGV2ZW50IHNjYWxlRW5kXG4gKiBAcGFyYW0ge01vdmVhYmxlLlNjYWxhYmxlLk9uU2NhbGVFbmR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIHNjYWxlRW5kIGV2ZW50XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHsgc2NhbGFibGU6IHRydWUgfSk7XG4gKiBtb3ZlYWJsZS5vbihcInNjYWxlRW5kXCIsICh7IHRhcmdldCwgaXNEcmFnIH0pID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyh0YXJnZXQsIGlzRHJhZyk7XG4gKiB9KTtcbiAqL1xuXG4vKipcbiogV2hlbiB0aGUgZ3JvdXAgc2NhbGUgc3RhcnRzLCB0aGUgYHNjYWxlR3JvdXBTdGFydGAgZXZlbnQgaXMgY2FsbGVkLlxuKiBAbWVtYmVyb2YgTW92ZWFibGUuU2NhbGFibGVcbiogQGV2ZW50IHNjYWxlR3JvdXBTdGFydFxuKiBAcGFyYW0ge01vdmVhYmxlLlNjYWxhYmxlLk9uU2NhbGVHcm91cFN0YXJ0fSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgc2NhbGVHcm91cFN0YXJ0YCBldmVudFxuKiBAZXhhbXBsZVxuKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4qXG4qIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiogICAgIHRhcmdldDogW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnRhcmdldFwiKSksXG4qICAgICBzY2FsYWJsZTogdHJ1ZVxuKiB9KTtcbiogbW92ZWFibGUub24oXCJzY2FsZUdyb3VwU3RhcnRcIiwgKHsgdGFyZ2V0cyB9KSA9PiB7XG4qICAgICBjb25zb2xlLmxvZyhcIm9uU2NhbGVHcm91cFN0YXJ0XCIsIHRhcmdldHMpO1xuKiB9KTtcbiovXG5cbi8qKlxuKiBXaGVuIHRoZSBncm91cCBzY2FsZSwgdGhlIGBzY2FsZUdyb3VwYCBldmVudCBpcyBjYWxsZWQuXG4qIEBtZW1iZXJvZiBNb3ZlYWJsZS5TY2FsYWJsZVxuKiBAZXZlbnQgc2NhbGVHcm91cFxuKiBAcGFyYW0ge01vdmVhYmxlLlNjYWxhYmxlLk9uU2NhbGVHcm91cH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHNjYWxlR3JvdXBgIGV2ZW50XG4qIEBleGFtcGxlXG4qIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbipcbiogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuKiAgICAgdGFyZ2V0OiBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFyZ2V0XCIpKSxcbiogICAgIHNjYWxhYmxlOiB0cnVlXG4qIH0pO1xuKiBtb3ZlYWJsZS5vbihcInNjYWxlR3JvdXBcIiwgKHsgdGFyZ2V0cywgZXZlbnRzIH0pID0+IHtcbiogICAgIGNvbnNvbGUubG9nKFwib25TY2FsZUdyb3VwXCIsIHRhcmdldHMpO1xuKiAgICAgZXZlbnRzLmZvckVhY2goZXYgPT4ge1xuKiAgICAgICAgIGNvbnN0IHRhcmdldCA9IGV2LnRhcmdldDtcbiogICAgICAgICAvLyBldi5kcmFnIGlzIGEgZHJhZyBldmVudCB0aGF0IG9jY3VycyB3aGVuIHRoZSBncm91cCBzY2FsZS5cbiogICAgICAgICBjb25zdCBsZWZ0ID0gZXYuZHJhZy5iZWZvcmVEaXN0WzBdO1xuKiAgICAgICAgIGNvbnN0IHRvcCA9IGV2LmRyYWcuYmVmb3JlRGlzdFsxXTtcbiogICAgICAgICBjb25zdCBzY2FsZVggPSBldi5zY2FsZVswXTtcbiogICAgICAgICBjb25zdCBzY2FsZVkgPSBldi5zY2FsZVsxXTtcbiogICAgIH0pO1xuKiB9KTtcbiovXG5cbi8qKlxuICogV2hlbiB0aGUgZ3JvdXAgc2NhbGUgZmluaXNoZXMsIHRoZSBgc2NhbGVHcm91cEVuZGAgZXZlbnQgaXMgY2FsbGVkLlxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlNjYWxhYmxlXG4gKiBAZXZlbnQgc2NhbGVHcm91cEVuZFxuICogQHBhcmFtIHtNb3ZlYWJsZS5TY2FsYWJsZS5PblNjYWxlR3JvdXBFbmR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGBzY2FsZUdyb3VwRW5kYCBldmVudFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgdGFyZ2V0OiBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFyZ2V0XCIpKSxcbiAqICAgICBzY2FsYWJsZTogdHJ1ZVxuICogfSk7XG4gKiBtb3ZlYWJsZS5vbihcInNjYWxlR3JvdXBFbmRcIiwgKHsgdGFyZ2V0cywgaXNEcmFnIH0pID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhcIm9uU2NhbGVHcm91cEVuZFwiLCB0YXJnZXRzLCBpc0RyYWcpO1xuICogfSk7XG4gKi9cblxuZnVuY3Rpb24gZ2V0TWlkZGxlTGluZVBvcyhwb3MxLCBwb3MyKSB7XG4gIHJldHVybiBwb3MxLm1hcChmdW5jdGlvbiAocG9zLCBpKSB7XG4gICAgcmV0dXJuIGRvdChwb3MsIHBvczJbaV0sIDEsIDIpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0VHJpYW5nbGVSYWQocG9zMSwgcG9zMiwgcG9zMykge1xuICAvLyBwb3MxIFJhZFxuICB2YXIgcmFkMSA9IGdldFJhZChwb3MxLCBwb3MyKTtcbiAgdmFyIHJhZDIgPSBnZXRSYWQocG9zMSwgcG9zMyk7XG4gIHZhciByYWQgPSByYWQyIC0gcmFkMTtcbiAgcmV0dXJuIHJhZCA+PSAwID8gcmFkIDogcmFkICsgMiAqIE1hdGguUEk7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRQb3MocG9zZXMxLCBwb3NlczIpIHtcbiAgdmFyIHJhZDEgPSBnZXRUcmlhbmdsZVJhZChwb3NlczFbMF0sIHBvc2VzMVsxXSwgcG9zZXMxWzJdKTtcbiAgdmFyIHJhZDIgPSBnZXRUcmlhbmdsZVJhZChwb3NlczJbMF0sIHBvc2VzMlsxXSwgcG9zZXMyWzJdKTtcbiAgdmFyIHBpID0gTWF0aC5QSTtcblxuICBpZiAocmFkMSA+PSBwaSAmJiByYWQyIDw9IHBpIHx8IHJhZDEgPD0gcGkgJiYgcmFkMiA+PSBwaSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBAbmFtZXNwYWNlIE1vdmVhYmxlLldhcnBhYmxlXG4gKiBAZGVzY3JpcHRpb24gV2FycGFibGUgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRhcmdldCBjYW4gYmUgd2FycGVkKGRpc3RvcnRlZCwgYmVudGVkKS5cbiAqL1xuXG5cbnZhciBXYXJwYWJsZSA9IHtcbiAgbmFtZTogXCJ3YXJwYWJsZVwiLFxuICBhYmxlR3JvdXA6IFwic2l6ZVwiLFxuICBwcm9wczoge1xuICAgIHdhcnBhYmxlOiBCb29sZWFuLFxuICAgIHJlbmRlckRpcmVjdGlvbnM6IEFycmF5XG4gIH0sXG4gIGV2ZW50czoge1xuICAgIG9uV2FycFN0YXJ0OiBcIndhcnBTdGFydFwiLFxuICAgIG9uV2FycDogXCJ3YXJwXCIsXG4gICAgb25XYXJwRW5kOiBcIndhcnBFbmRcIlxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgUmVhY3QpIHtcbiAgICB2YXIgX2EgPSBtb3ZlYWJsZS5wcm9wcyxcbiAgICAgICAgcmVzaXphYmxlID0gX2EucmVzaXphYmxlLFxuICAgICAgICBzY2FsYWJsZSA9IF9hLnNjYWxhYmxlLFxuICAgICAgICB3YXJwYWJsZSA9IF9hLndhcnBhYmxlLFxuICAgICAgICB6b29tID0gX2Euem9vbTtcblxuICAgIGlmIChyZXNpemFibGUgfHwgc2NhbGFibGUgfHwgIXdhcnBhYmxlKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIF9iID0gbW92ZWFibGUuc3RhdGUsXG4gICAgICAgIHBvczEgPSBfYi5wb3MxLFxuICAgICAgICBwb3MyID0gX2IucG9zMixcbiAgICAgICAgcG9zMyA9IF9iLnBvczMsXG4gICAgICAgIHBvczQgPSBfYi5wb3M0O1xuICAgIHZhciBsaW5lUG9zRnJvbTEgPSBnZXRNaWRkbGVMaW5lUG9zKHBvczEsIHBvczIpO1xuICAgIHZhciBsaW5lUG9zRnJvbTIgPSBnZXRNaWRkbGVMaW5lUG9zKHBvczIsIHBvczEpO1xuICAgIHZhciBsaW5lUG9zRnJvbTMgPSBnZXRNaWRkbGVMaW5lUG9zKHBvczEsIHBvczMpO1xuICAgIHZhciBsaW5lUG9zRnJvbTQgPSBnZXRNaWRkbGVMaW5lUG9zKHBvczMsIHBvczEpO1xuICAgIHZhciBsaW5lUG9zVG8xID0gZ2V0TWlkZGxlTGluZVBvcyhwb3MzLCBwb3M0KTtcbiAgICB2YXIgbGluZVBvc1RvMiA9IGdldE1pZGRsZUxpbmVQb3MocG9zNCwgcG9zMyk7XG4gICAgdmFyIGxpbmVQb3NUbzMgPSBnZXRNaWRkbGVMaW5lUG9zKHBvczIsIHBvczQpO1xuICAgIHZhciBsaW5lUG9zVG80ID0gZ2V0TWlkZGxlTGluZVBvcyhwb3M0LCBwb3MyKTtcbiAgICByZXR1cm4gX19zcHJlYWRBcnJheShbUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBjbGFzc05hbWU6IHByZWZpeChcImxpbmVcIiksXG4gICAgICBrZXk6IFwibWlkZGVMaW5lMVwiLFxuICAgICAgc3R5bGU6IGdldExpbmVTdHlsZShsaW5lUG9zRnJvbTEsIGxpbmVQb3NUbzEsIHpvb20pXG4gICAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgY2xhc3NOYW1lOiBwcmVmaXgoXCJsaW5lXCIpLFxuICAgICAga2V5OiBcIm1pZGRlTGluZTJcIixcbiAgICAgIHN0eWxlOiBnZXRMaW5lU3R5bGUobGluZVBvc0Zyb20yLCBsaW5lUG9zVG8yLCB6b29tKVxuICAgIH0pLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIGNsYXNzTmFtZTogcHJlZml4KFwibGluZVwiKSxcbiAgICAgIGtleTogXCJtaWRkZUxpbmUzXCIsXG4gICAgICBzdHlsZTogZ2V0TGluZVN0eWxlKGxpbmVQb3NGcm9tMywgbGluZVBvc1RvMywgem9vbSlcbiAgICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBjbGFzc05hbWU6IHByZWZpeChcImxpbmVcIiksXG4gICAgICBrZXk6IFwibWlkZGVMaW5lNFwiLFxuICAgICAgc3R5bGU6IGdldExpbmVTdHlsZShsaW5lUG9zRnJvbTQsIGxpbmVQb3NUbzQsIHpvb20pXG4gICAgfSldLCByZW5kZXJBbGxEaXJlY3Rpb25zKG1vdmVhYmxlLCBSZWFjdCkpO1xuICB9LFxuICBkcmFnQ29udHJvbENvbmRpdGlvbjogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgaWYgKGUuaXNSZXF1ZXN0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhc0NsYXNzKGUuaW5wdXRFdmVudC50YXJnZXQsIHByZWZpeChcImRpcmVjdGlvblwiKSk7XG4gIH0sXG4gIGRyYWdDb250cm9sU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBkYXRhcyA9IGUuZGF0YXMsXG4gICAgICAgIGlucHV0RXZlbnQgPSBlLmlucHV0RXZlbnQ7XG4gICAgdmFyIHRhcmdldCA9IG1vdmVhYmxlLnByb3BzLnRhcmdldDtcbiAgICB2YXIgaW5wdXRUYXJnZXQgPSBpbnB1dEV2ZW50LnRhcmdldDtcbiAgICB2YXIgZGlyZWN0aW9uID0gZ2V0RGlyZWN0aW9uKGlucHV0VGFyZ2V0KTtcblxuICAgIGlmICghZGlyZWN0aW9uIHx8ICF0YXJnZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgc3RhdGUgPSBtb3ZlYWJsZS5zdGF0ZTtcbiAgICB2YXIgdHJhbnNmb3JtT3JpZ2luID0gc3RhdGUudHJhbnNmb3JtT3JpZ2luLFxuICAgICAgICBpczNkID0gc3RhdGUuaXMzZCxcbiAgICAgICAgdGFyZ2V0VHJhbnNmb3JtID0gc3RhdGUudGFyZ2V0VHJhbnNmb3JtLFxuICAgICAgICB0YXJnZXRNYXRyaXggPSBzdGF0ZS50YXJnZXRNYXRyaXgsXG4gICAgICAgIHdpZHRoID0gc3RhdGUud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IHN0YXRlLmhlaWdodCxcbiAgICAgICAgbGVmdCA9IHN0YXRlLmxlZnQsXG4gICAgICAgIHRvcCA9IHN0YXRlLnRvcDtcbiAgICBkYXRhcy5kYXRhcyA9IHt9O1xuICAgIGRhdGFzLnRhcmdldFRyYW5zZm9ybSA9IHRhcmdldFRyYW5zZm9ybTtcbiAgICBkYXRhcy53YXJwVGFyZ2V0TWF0cml4ID0gaXMzZCA/IHRhcmdldE1hdHJpeCA6IGNvbnZlcnREaW1lbnNpb24odGFyZ2V0TWF0cml4LCAzLCA0KTtcbiAgICBkYXRhcy50YXJnZXRJbnZlcnNlTWF0cml4ID0gaWdub3JlRGltZW5zaW9uKGludmVydChkYXRhcy53YXJwVGFyZ2V0TWF0cml4LCA0KSwgMywgNCk7XG4gICAgZGF0YXMuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgIGRhdGFzLmxlZnQgPSBsZWZ0O1xuICAgIGRhdGFzLnRvcCA9IHRvcDtcbiAgICBkYXRhcy5wb3NlcyA9IFtbMCwgMF0sIFt3aWR0aCwgMF0sIFswLCBoZWlnaHRdLCBbd2lkdGgsIGhlaWdodF1dLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuIG1pbnVzKHAsIHRyYW5zZm9ybU9yaWdpbik7XG4gICAgfSk7XG4gICAgZGF0YXMubmV4dFBvc2VzID0gZGF0YXMucG9zZXMubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgdmFyIHggPSBfYVswXSxcbiAgICAgICAgICB5ID0gX2FbMV07XG4gICAgICByZXR1cm4gY2FsY3VsYXRlKGRhdGFzLndhcnBUYXJnZXRNYXRyaXgsIFt4LCB5LCAwLCAxXSwgNCk7XG4gICAgfSk7XG4gICAgZGF0YXMuc3RhcnRWYWx1ZSA9IGNyZWF0ZUlkZW50aXR5TWF0cml4KDQpO1xuICAgIGRhdGFzLnByZXZNYXRyaXggPSBjcmVhdGVJZGVudGl0eU1hdHJpeCg0KTtcbiAgICBkYXRhcy5hYnNvbHV0ZVBvc2VzID0gZ2V0QWJzb2x1dGVQb3Nlc0J5U3RhdGUoc3RhdGUpO1xuICAgIGRhdGFzLnBvc0luZGV4ZXMgPSBnZXRQb3NJbmRleGVzQnlEaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICBzZXREcmFnU3RhcnQobW92ZWFibGUsIGUpO1xuICAgIHNldERlZmF1bHRUcmFuc2Zvcm1JbmRleChlLCBcIm1hdHJpeDNkXCIpO1xuICAgIHN0YXRlLnNuYXBSZW5kZXJJbmZvID0ge1xuICAgICAgcmVxdWVzdDogZS5pc1JlcXVlc3QsXG4gICAgICBkaXJlY3Rpb246IGRpcmVjdGlvblxuICAgIH07XG4gICAgdmFyIHBhcmFtcyA9IGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIF9fYXNzaWduKHtcbiAgICAgIHNldDogZnVuY3Rpb24gKG1hdHJpeCkge1xuICAgICAgICBkYXRhcy5zdGFydFZhbHVlID0gbWF0cml4O1xuICAgICAgfVxuICAgIH0sIGZpbGxUcmFuc2Zvcm1TdGFydEV2ZW50KGUpKSk7XG4gICAgdmFyIHJlc3VsdCA9IHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbldhcnBTdGFydFwiLCBwYXJhbXMpO1xuXG4gICAgaWYgKHJlc3VsdCAhPT0gZmFsc2UpIHtcbiAgICAgIGRhdGFzLmlzV2FycCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGFzLmlzV2FycDtcbiAgfSxcbiAgZHJhZ0NvbnRyb2w6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBkYXRhcyA9IGUuZGF0YXMsXG4gICAgICAgIGlzUmVxdWVzdCA9IGUuaXNSZXF1ZXN0O1xuICAgIHZhciBkaXN0WCA9IGUuZGlzdFgsXG4gICAgICAgIGRpc3RZID0gZS5kaXN0WTtcbiAgICB2YXIgdGFyZ2V0SW52ZXJzZU1hdHJpeCA9IGRhdGFzLnRhcmdldEludmVyc2VNYXRyaXgsXG4gICAgICAgIHByZXZNYXRyaXggPSBkYXRhcy5wcmV2TWF0cml4LFxuICAgICAgICBpc1dhcnAgPSBkYXRhcy5pc1dhcnAsXG4gICAgICAgIHN0YXJ0VmFsdWUgPSBkYXRhcy5zdGFydFZhbHVlLFxuICAgICAgICBwb3NlcyA9IGRhdGFzLnBvc2VzLFxuICAgICAgICBwb3NJbmRleGVzID0gZGF0YXMucG9zSW5kZXhlcyxcbiAgICAgICAgYWJzb2x1dGVQb3NlcyA9IGRhdGFzLmFic29sdXRlUG9zZXM7XG5cbiAgICBpZiAoIWlzV2FycCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJlc29sdmVUcmFuc2Zvcm1FdmVudChlLCBcIm1hdHJpeDNkXCIpO1xuXG4gICAgaWYgKGhhc0d1aWRlbGluZXMobW92ZWFibGUsIFwid2FycGFibGVcIikpIHtcbiAgICAgIHZhciBzZWxlY3RlZFBvc2VzID0gcG9zSW5kZXhlcy5tYXAoZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBhYnNvbHV0ZVBvc2VzW2luZGV4XTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoc2VsZWN0ZWRQb3Nlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHNlbGVjdGVkUG9zZXMucHVzaChbKHNlbGVjdGVkUG9zZXNbMF1bMF0gKyBzZWxlY3RlZFBvc2VzWzFdWzBdKSAvIDIsIChzZWxlY3RlZFBvc2VzWzBdWzFdICsgc2VsZWN0ZWRQb3Nlc1sxXVsxXSkgLyAyXSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBfYSA9IGNoZWNrTW92ZWFibGVTbmFwQm91bmRzKG1vdmVhYmxlLCBpc1JlcXVlc3QsIHtcbiAgICAgICAgaG9yaXpvbnRhbDogc2VsZWN0ZWRQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgICAgICAgIHJldHVybiBwb3NbMV0gKyBkaXN0WTtcbiAgICAgICAgfSksXG4gICAgICAgIHZlcnRpY2FsOiBzZWxlY3RlZFBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgICAgcmV0dXJuIHBvc1swXSArIGRpc3RYO1xuICAgICAgICB9KVxuICAgICAgfSksXG4gICAgICAgICAgaG9yaXpvbnRhbFNuYXBJbmZvID0gX2EuaG9yaXpvbnRhbCxcbiAgICAgICAgICB2ZXJ0aWNhbFNuYXBJbmZvID0gX2EudmVydGljYWw7XG5cbiAgICAgIGRpc3RZIC09IGhvcml6b250YWxTbmFwSW5mby5vZmZzZXQ7XG4gICAgICBkaXN0WCAtPSB2ZXJ0aWNhbFNuYXBJbmZvLm9mZnNldDtcbiAgICB9XG5cbiAgICB2YXIgZGlzdCA9IGdldERyYWdEaXN0KHtcbiAgICAgIGRhdGFzOiBkYXRhcyxcbiAgICAgIGRpc3RYOiBkaXN0WCxcbiAgICAgIGRpc3RZOiBkaXN0WVxuICAgIH0sIHRydWUpO1xuICAgIHZhciBuZXh0UG9zZXMgPSBkYXRhcy5uZXh0UG9zZXMuc2xpY2UoKTtcbiAgICBwb3NJbmRleGVzLmZvckVhY2goZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICBuZXh0UG9zZXNbaW5kZXhdID0gcGx1cyhuZXh0UG9zZXNbaW5kZXhdLCBkaXN0KTtcbiAgICB9KTtcblxuICAgIGlmICghTkVBUkJZX1BPUy5ldmVyeShmdW5jdGlvbiAobmVhckJ5UG9zZXMpIHtcbiAgICAgIHJldHVybiBpc1ZhbGlkUG9zKG5lYXJCeVBvc2VzLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gcG9zZXNbaV07XG4gICAgICB9KSwgbmVhckJ5UG9zZXMubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiBuZXh0UG9zZXNbaV07XG4gICAgICB9KSk7XG4gICAgfSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgaCA9IGNyZWF0ZVdhcnBNYXRyaXgocG9zZXNbMF0sIHBvc2VzWzJdLCBwb3Nlc1sxXSwgcG9zZXNbM10sIG5leHRQb3Nlc1swXSwgbmV4dFBvc2VzWzJdLCBuZXh0UG9zZXNbMV0sIG5leHRQb3Nlc1szXSk7XG5cbiAgICBpZiAoIWgubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBCICogQSAqIE1cblxuXG4gICAgdmFyIGFmdGVyTWF0cml4ID0gbXVsdGlwbHkodGFyZ2V0SW52ZXJzZU1hdHJpeCwgaCwgNCk7IC8vIEIgKiBNICogQVxuXG4gICAgdmFyIG1hdHJpeCA9IGdldFRyYW5zZnJvbU1hdHJpeChkYXRhcywgYWZ0ZXJNYXRyaXgsIHRydWUpO1xuICAgIHZhciBkZWx0YSA9IG11bHRpcGx5KGludmVydChwcmV2TWF0cml4LCA0KSwgbWF0cml4LCA0KTtcbiAgICBkYXRhcy5wcmV2TWF0cml4ID0gbWF0cml4O1xuICAgIHZhciB0b3RhbE1hdHJpeCA9IG11bHRpcGx5KHN0YXJ0VmFsdWUsIG1hdHJpeCwgNCk7XG4gICAgdmFyIG5leHRUcmFuc2Zvcm0gPSBjb252ZXJ0VHJhbnNmb3JtRm9ybWF0KGRhdGFzLCBcIm1hdHJpeDNkKFwiICsgdG90YWxNYXRyaXguam9pbihcIiwgXCIpICsgXCIpXCIsIFwibWF0cml4M2QoXCIgKyBtYXRyaXguam9pbihcIiwgXCIpICsgXCIpXCIpO1xuICAgIGZpbGxPcmlnaW5hbFRyYW5zZm9ybShlLCBuZXh0VHJhbnNmb3JtKTtcbiAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25XYXJwXCIsIGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIHtcbiAgICAgIGRlbHRhOiBkZWx0YSxcbiAgICAgIG1hdHJpeDogdG90YWxNYXRyaXgsXG4gICAgICBkaXN0OiBtYXRyaXgsXG4gICAgICBtdWx0aXBseTogbXVsdGlwbHksXG4gICAgICB0cmFuc2Zvcm06IG5leHRUcmFuc2Zvcm1cbiAgICB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIGRyYWdDb250cm9sRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB2YXIgZGF0YXMgPSBlLmRhdGFzLFxuICAgICAgICBpc0RyYWcgPSBlLmlzRHJhZztcblxuICAgIGlmICghZGF0YXMuaXNXYXJwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZGF0YXMuaXNXYXJwID0gZmFsc2U7XG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uV2FycEVuZFwiLCBmaWxsRW5kUGFyYW1zKG1vdmVhYmxlLCBlLCB7fSkpO1xuICAgIHJldHVybiBpc0RyYWc7XG4gIH1cbn07XG4vKipcbiAqIFdoZXRoZXIgb3Igbm90IHRhcmdldCBjYW4gYmUgd2FycGVkLiAoZGVmYXVsdDogZmFsc2UpXG4gKiBAbmFtZSBNb3ZlYWJsZS5XYXJwYWJsZSN3YXJwYWJsZVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcbiAqXG4gKiBtb3ZlYWJsZS53YXJwYWJsZSA9IHRydWU7XG4gKi9cblxuLyoqXG4qIFNldCBkaXJlY3Rpb25zIHRvIHNob3cgdGhlIGNvbnRyb2wgYm94LiAoZGVmYXVsdDogW1wiblwiLCBcIm53XCIsIFwibmVcIiwgXCJzXCIsIFwic2VcIiwgXCJzd1wiLCBcImVcIiwgXCJ3XCJdKVxuKiBAbmFtZSBNb3ZlYWJsZS5XYXJwYWJsZSNyZW5kZXJEaXJlY3Rpb25zXG4qIEBleGFtcGxlXG4qIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbipcbiogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuKiAgICAgd2FycGFibGU6IHRydWUsXG4qICAgICByZW5kZXJEaXJlY3Rpb25zOiBbXCJuXCIsIFwibndcIiwgXCJuZVwiLCBcInNcIiwgXCJzZVwiLCBcInN3XCIsIFwiZVwiLCBcIndcIl0sXG4qIH0pO1xuKlxuKiBtb3ZlYWJsZS5yZW5kZXJEaXJlY3Rpb25zID0gW1wibndcIiwgXCJuZVwiLCBcInN3XCIsIFwic2VcIl07XG4qL1xuXG4vKipcbiogV2hlbiB0aGUgd2FycCBzdGFydHMsIHRoZSB3YXJwU3RhcnQgZXZlbnQgaXMgY2FsbGVkLlxuKiBAbWVtYmVyb2YgTW92ZWFibGUuV2FycGFibGVcbiogQGV2ZW50IHdhcnBTdGFydFxuKiBAcGFyYW0ge01vdmVhYmxlLldhcnBhYmxlLk9uV2FycFN0YXJ0fSAtIFBhcmFtZXRlcnMgZm9yIHRoZSB3YXJwU3RhcnQgZXZlbnRcbiogQGV4YW1wbGVcbiogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuKlxuKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7IHdhcnBhYmxlOiB0cnVlIH0pO1xuKiBtb3ZlYWJsZS5vbihcIndhcnBTdGFydFwiLCAoeyB0YXJnZXQgfSkgPT4ge1xuKiAgICAgY29uc29sZS5sb2codGFyZ2V0KTtcbiogfSk7XG4qL1xuXG4vKipcbiAqIFdoZW4gd2FycGluZywgdGhlIHdhcnAgZXZlbnQgaXMgY2FsbGVkLlxuICogQG1lbWJlcm9mIE1vdmVhYmxlLldhcnBhYmxlXG4gKiBAZXZlbnQgd2FycFxuICogQHBhcmFtIHtNb3ZlYWJsZS5XYXJwYWJsZS5PbldhcnB9IC0gUGFyYW1ldGVycyBmb3IgdGhlIHdhcnAgZXZlbnRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKiBsZXQgbWF0cml4ID0gW1xuICogIDEsIDAsIDAsIDAsXG4gKiAgMCwgMSwgMCwgMCxcbiAqICAwLCAwLCAxLCAwLFxuICogIDAsIDAsIDAsIDEsXG4gKiBdO1xuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwgeyB3YXJwYWJsZTogdHJ1ZSB9KTtcbiAqIG1vdmVhYmxlLm9uKFwid2FycFwiLCAoeyB0YXJnZXQsIHRyYW5zZm9ybSwgZGVsdGEsIG11bHRpcGx5IH0pID0+IHtcbiAqICAgIC8vIHRhcmdldC5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gKiAgICBtYXRyaXggPSBtdWx0aXBseShtYXRyaXgsIGRlbHRhKTtcbiAqICAgIHRhcmdldC5zdHlsZS50cmFuc2Zvcm0gPSBgbWF0cml4M2QoJHttYXRyaXguam9pbihcIixcIil9KWA7XG4gKiB9KTtcbiAqL1xuXG4vKipcbiAqIFdoZW4gdGhlIHdhcnAgZmluaXNoZXMsIHRoZSB3YXJwRW5kIGV2ZW50IGlzIGNhbGxlZC5cbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5XYXJwYWJsZVxuICogQGV2ZW50IHdhcnBFbmRcbiAqIEBwYXJhbSB7TW92ZWFibGUuV2FycGFibGUuT25XYXJwRW5kfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSB3YXJwRW5kIGV2ZW50XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHsgd2FycGFibGU6IHRydWUgfSk7XG4gKiBtb3ZlYWJsZS5vbihcIndhcnBFbmRcIiwgKHsgdGFyZ2V0LCBpc0RyYWcgfSkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKHRhcmdldCwgaXNEcmFnKTtcbiAqIH0pO1xuICovXG5cbnZhciBBUkVBX1BJRUNFUyA9IC8qI19fUFVSRV9fKi9wcmVmaXgoXCJhcmVhLXBpZWNlc1wiKTtcbnZhciBBUkVBX1BJRUNFID0gLyojX19QVVJFX18qL3ByZWZpeChcImFyZWEtcGllY2VcIik7XG52YXIgQVZPSUQgPSAvKiNfX1BVUkVfXyovcHJlZml4KFwiYXZvaWRcIik7XG5cbmZ1bmN0aW9uIHJlc3RvcmVTdHlsZShtb3ZlYWJsZSkge1xuICB2YXIgZWwgPSBtb3ZlYWJsZS5hcmVhRWxlbWVudDtcbiAgdmFyIF9hID0gbW92ZWFibGUuc3RhdGUsXG4gICAgICB3aWR0aCA9IF9hLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xuICByZW1vdmVDbGFzcyhlbCwgQVZPSUQpO1xuICBlbC5zdHlsZS5jc3NUZXh0ICs9IFwibGVmdDogMHB4OyB0b3A6IDBweDsgd2lkdGg6IFwiICsgd2lkdGggKyBcInB4OyBoZWlnaHQ6IFwiICsgaGVpZ2h0ICsgXCJweFwiO1xufVxuXG5mdW5jdGlvbiByZW5kZXJQaWVjZXMoUmVhY3QpIHtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGtleTogXCJhcmVhX3BpZWNlc1wiLFxuICAgIGNsYXNzTmFtZTogQVJFQV9QSUVDRVNcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBBUkVBX1BJRUNFXG4gIH0pLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IEFSRUFfUElFQ0VcbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogQVJFQV9QSUVDRVxuICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBBUkVBX1BJRUNFXG4gIH0pKTtcbn1cblxudmFyIERyYWdBcmVhID0ge1xuICBuYW1lOiBcImRyYWdBcmVhXCIsXG4gIHByb3BzOiB7XG4gICAgZHJhZ0FyZWE6IEJvb2xlYW4sXG4gICAgcGFzc0RyYWdBcmVhOiBCb29sZWFuXG4gIH0sXG4gIGV2ZW50czoge1xuICAgIG9uQ2xpY2s6IFwiY2xpY2tcIixcbiAgICBvbkNsaWNrR3JvdXA6IFwiY2xpY2tHcm91cFwiXG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gKG1vdmVhYmxlLCBSZWFjdCkge1xuICAgIHZhciBfYSA9IG1vdmVhYmxlLnByb3BzLFxuICAgICAgICB0YXJnZXQgPSBfYS50YXJnZXQsXG4gICAgICAgIGRyYWdBcmVhID0gX2EuZHJhZ0FyZWEsXG4gICAgICAgIGdyb3VwYWJsZSA9IF9hLmdyb3VwYWJsZSxcbiAgICAgICAgcGFzc0RyYWdBcmVhID0gX2EucGFzc0RyYWdBcmVhO1xuICAgIHZhciBfYiA9IG1vdmVhYmxlLnN0YXRlLFxuICAgICAgICB3aWR0aCA9IF9iLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfYi5oZWlnaHQsXG4gICAgICAgIHJlbmRlclBvc2VzID0gX2IucmVuZGVyUG9zZXM7XG4gICAgdmFyIGNsYXNzTmFtZSA9IHBhc3NEcmFnQXJlYSA/IHByZWZpeChcImFyZWFcIiwgXCJwYXNzXCIpIDogcHJlZml4KFwiYXJlYVwiKTtcblxuICAgIGlmIChncm91cGFibGUpIHtcbiAgICAgIHJldHVybiBbUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIGtleTogXCJhcmVhXCIsXG4gICAgICAgIHJlZjogcmVmKG1vdmVhYmxlLCBcImFyZWFFbGVtZW50XCIpLFxuICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVxuICAgICAgfSksIHJlbmRlclBpZWNlcyhSZWFjdCldO1xuICAgIH1cblxuICAgIGlmICghdGFyZ2V0IHx8ICFkcmFnQXJlYSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciBoID0gY3JlYXRlV2FycE1hdHJpeChbMCwgMF0sIFt3aWR0aCwgMF0sIFswLCBoZWlnaHRdLCBbd2lkdGgsIGhlaWdodF0sIHJlbmRlclBvc2VzWzBdLCByZW5kZXJQb3Nlc1sxXSwgcmVuZGVyUG9zZXNbMl0sIHJlbmRlclBvc2VzWzNdKTtcbiAgICB2YXIgdHJhbnNmb3JtID0gaC5sZW5ndGggPyBtYWtlTWF0cml4Q1NTKGgsIHRydWUpIDogXCJub25lXCI7XG4gICAgcmV0dXJuIFtSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIGtleTogXCJhcmVhXCIsXG4gICAgICByZWY6IHJlZihtb3ZlYWJsZSwgXCJhcmVhRWxlbWVudFwiKSxcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgdG9wOiBcIjBweFwiLFxuICAgICAgICBsZWZ0OiBcIjBweFwiLFxuICAgICAgICB3aWR0aDogd2lkdGggKyBcInB4XCIsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0ICsgXCJweFwiLFxuICAgICAgICB0cmFuc2Zvcm1PcmlnaW46IFwiMCAwXCIsXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtXG4gICAgICB9XG4gICAgfSksIHJlbmRlclBpZWNlcyhSZWFjdCldO1xuICB9LFxuICBkcmFnU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgX2EpIHtcbiAgICB2YXIgZGF0YXMgPSBfYS5kYXRhcyxcbiAgICAgICAgY2xpZW50WCA9IF9hLmNsaWVudFgsXG4gICAgICAgIGNsaWVudFkgPSBfYS5jbGllbnRZLFxuICAgICAgICBpbnB1dEV2ZW50ID0gX2EuaW5wdXRFdmVudDtcblxuICAgIGlmICghaW5wdXRFdmVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGRhdGFzLmlzRHJhZ0FyZWEgPSBmYWxzZTtcbiAgICB2YXIgYXJlYUVsZW1lbnQgPSBtb3ZlYWJsZS5hcmVhRWxlbWVudDtcbiAgICB2YXIgc3RhdGUgPSBtb3ZlYWJsZS5zdGF0ZTtcbiAgICB2YXIgbW92ZWFibGVDbGllbnRSZWN0ID0gc3RhdGUubW92ZWFibGVDbGllbnRSZWN0LFxuICAgICAgICByZW5kZXJQb3NlcyA9IHN0YXRlLnJlbmRlclBvc2VzLFxuICAgICAgICByb290TWF0cml4ID0gc3RhdGUucm9vdE1hdHJpeCxcbiAgICAgICAgaXMzZCA9IHN0YXRlLmlzM2Q7XG4gICAgdmFyIGxlZnQgPSBtb3ZlYWJsZUNsaWVudFJlY3QubGVmdCxcbiAgICAgICAgdG9wID0gbW92ZWFibGVDbGllbnRSZWN0LnRvcDtcblxuICAgIHZhciBfYiA9IGdldFJlY3QocmVuZGVyUG9zZXMpLFxuICAgICAgICByZWxhdGl2ZUxlZnQgPSBfYi5sZWZ0LFxuICAgICAgICByZWxhdGl2ZVRvcCA9IF9iLnRvcCxcbiAgICAgICAgd2lkdGggPSBfYi53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX2IuaGVpZ2h0O1xuXG4gICAgdmFyIG4gPSBpczNkID8gNCA6IDM7XG5cbiAgICB2YXIgX2MgPSBjYWxjdWxhdGVJbnZlcnNlUG9zaXRpb24ocm9vdE1hdHJpeCwgW2NsaWVudFggLSBsZWZ0LCBjbGllbnRZIC0gdG9wXSwgbiksXG4gICAgICAgIHBvc1ggPSBfY1swXSxcbiAgICAgICAgcG9zWSA9IF9jWzFdO1xuXG4gICAgcG9zWCAtPSByZWxhdGl2ZUxlZnQ7XG4gICAgcG9zWSAtPSByZWxhdGl2ZVRvcDtcbiAgICB2YXIgcmVjdHMgPSBbe1xuICAgICAgbGVmdDogcmVsYXRpdmVMZWZ0LFxuICAgICAgdG9wOiByZWxhdGl2ZVRvcCxcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogcG9zWSAtIDEwXG4gICAgfSwge1xuICAgICAgbGVmdDogcmVsYXRpdmVMZWZ0LFxuICAgICAgdG9wOiByZWxhdGl2ZVRvcCxcbiAgICAgIHdpZHRoOiBwb3NYIC0gMTAsXG4gICAgICBoZWlnaHQ6IGhlaWdodFxuICAgIH0sIHtcbiAgICAgIGxlZnQ6IHJlbGF0aXZlTGVmdCxcbiAgICAgIHRvcDogcmVsYXRpdmVUb3AgKyBwb3NZICsgMTAsXG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCAtIHBvc1kgLSAxMFxuICAgIH0sIHtcbiAgICAgIGxlZnQ6IHJlbGF0aXZlTGVmdCArIHBvc1ggKyAxMCxcbiAgICAgIHRvcDogcmVsYXRpdmVUb3AsXG4gICAgICB3aWR0aDogd2lkdGggLSBwb3NYIC0gMTAsXG4gICAgICBoZWlnaHQ6IGhlaWdodFxuICAgIH1dO1xuICAgIHZhciBjaGlsZHJlbiA9IFtdLnNsaWNlLmNhbGwoYXJlYUVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nLmNoaWxkcmVuKTtcbiAgICByZWN0cy5mb3JFYWNoKGZ1bmN0aW9uIChyZWN0LCBpKSB7XG4gICAgICBjaGlsZHJlbltpXS5zdHlsZS5jc3NUZXh0ID0gXCJsZWZ0OiBcIiArIHJlY3QubGVmdCArIFwicHg7dG9wOiBcIiArIHJlY3QudG9wICsgXCJweDsgd2lkdGg6IFwiICsgcmVjdC53aWR0aCArIFwicHg7IGhlaWdodDogXCIgKyByZWN0LmhlaWdodCArIFwicHg7XCI7XG4gICAgfSk7XG4gICAgYWRkQ2xhc3MoYXJlYUVsZW1lbnQsIEFWT0lEKTtcbiAgICBzdGF0ZS5kaXNhYmxlTmF0aXZlRXZlbnQgPSB0cnVlO1xuICAgIHJldHVybjtcbiAgfSxcbiAgZHJhZzogZnVuY3Rpb24gKG1vdmVhYmxlLCBfYSkge1xuICAgIHZhciBkYXRhcyA9IF9hLmRhdGFzLFxuICAgICAgICBpbnB1dEV2ZW50ID0gX2EuaW5wdXRFdmVudDtcbiAgICB0aGlzLmVuYWJsZU5hdGl2ZUV2ZW50KG1vdmVhYmxlKTtcblxuICAgIGlmICghaW5wdXRFdmVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghZGF0YXMuaXNEcmFnQXJlYSkge1xuICAgICAgZGF0YXMuaXNEcmFnQXJlYSA9IHRydWU7XG4gICAgICByZXN0b3JlU3R5bGUobW92ZWFibGUpO1xuICAgIH1cbiAgfSxcbiAgZHJhZ0VuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdGhpcy5lbmFibGVOYXRpdmVFdmVudChtb3ZlYWJsZSk7XG4gICAgdmFyIGlucHV0RXZlbnQgPSBlLmlucHV0RXZlbnQsXG4gICAgICAgIGRhdGFzID0gZS5kYXRhcztcblxuICAgIGlmICghaW5wdXRFdmVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghZGF0YXMuaXNEcmFnQXJlYSkge1xuICAgICAgcmVzdG9yZVN0eWxlKG1vdmVhYmxlKTtcbiAgICB9XG4gIH0sXG4gIGRyYWdHcm91cFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnU3RhcnQobW92ZWFibGUsIGUpO1xuICB9LFxuICBkcmFnR3JvdXA6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWcobW92ZWFibGUsIGUpO1xuICB9LFxuICBkcmFnR3JvdXBFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWdFbmQobW92ZWFibGUsIGUpO1xuICB9LFxuICB1bnNldDogZnVuY3Rpb24gKG1vdmVhYmxlKSB7XG4gICAgcmVzdG9yZVN0eWxlKG1vdmVhYmxlKTtcbiAgICBtb3ZlYWJsZS5zdGF0ZS5kaXNhYmxlTmF0aXZlRXZlbnQgPSBmYWxzZTtcbiAgfSxcbiAgZW5hYmxlTmF0aXZlRXZlbnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xuICAgIHZhciBzdGF0ZSA9IG1vdmVhYmxlLnN0YXRlO1xuXG4gICAgaWYgKHN0YXRlLmRpc2FibGVOYXRpdmVFdmVudCkge1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3RhdGUuZGlzYWJsZU5hdGl2ZUV2ZW50ID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn07XG4vKipcbiAqIEFkZCBhbiBldmVudCB0byB0aGUgbW92ZWFibGUgYXJlYSBpbnN0ZWFkIG9mIHRoZSB0YXJnZXQgZm9yIHN0b3BQcm9wYWdhdGlvbi4gKGRlZmF1bHQ6IGZhbHNlLCB0cnVlIGluIGdyb3VwKVxuICogQG5hbWUgTW92ZWFibGUjZHJhZ0FyZWFcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogIGRyYWdBcmVhOiBmYWxzZSxcbiAqIH0pO1xuICovXG5cbi8qKlxuICogU2V0IGBwb2ludGVyRXZlbnRzOiBub25lO2AgY3NzIHRvIHBhc3MgZXZlbnRzIGluIGRyYWdBcmVhLiAoZGVmYXVsdDogZmFsc2UpXG4gKiBAbmFtZSBNb3ZlYWJsZSNwYXNzRHJhZ0FyZWFcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogIGRyYWdBcmVhOiBmYWxzZSxcbiAqIH0pO1xuICovXG5cbnZhciBPcmlnaW4gPSBtYWtlQWJsZShcIm9yaWdpblwiLCB7XG4gIHJlbmRlcjogZnVuY3Rpb24gKG1vdmVhYmxlLCBSZWFjdCkge1xuICAgIHZhciB6b29tID0gbW92ZWFibGUucHJvcHMuem9vbTtcbiAgICB2YXIgX2EgPSBtb3ZlYWJsZS5zdGF0ZSxcbiAgICAgICAgYmVmb3JlT3JpZ2luID0gX2EuYmVmb3JlT3JpZ2luLFxuICAgICAgICByb3RhdGlvbiA9IF9hLnJvdGF0aW9uO1xuICAgIHJldHVybiBbUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBjbGFzc05hbWU6IHByZWZpeChcImNvbnRyb2xcIiwgXCJvcmlnaW5cIiksXG4gICAgICBzdHlsZTogZ2V0Q29udHJvbFRyYW5zZm9ybShyb3RhdGlvbiwgem9vbSwgYmVmb3JlT3JpZ2luKSxcbiAgICAgIGtleTogXCJiZWZvcmVPcmlnaW5cIlxuICAgIH0pXTtcbiAgfVxufSk7XG4vKipcbiAqIFdoZXRoZXIgb3Igbm90IHRoZSBvcmlnaW4gY29udHJvbGJveCB3aWxsIGJlIHZpc2libGUgb3Igbm90IChkZWZhdWx0OiB0cnVlKVxuICogQG5hbWUgTW92ZWFibGUjb3JpZ2luXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICpcbiAqIG1vdmVhYmxlLm9yaWdpbiA9IHRydWU7XG4gKi9cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdFNjcm9sbFBvc2l0aW9uKGUpIHtcbiAgdmFyIHNjcm9sbENvbnRhaW5lciA9IGUuc2Nyb2xsQ29udGFpbmVyO1xuICByZXR1cm4gW3Njcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0LCBzY3JvbGxDb250YWluZXIuc2Nyb2xsVG9wXTtcbn1cbi8qKlxuICogQG5hbWVzcGFjZSBNb3ZlYWJsZS5TY3JvbGxhYmxlXG4gKiBAZGVzY3JpcHRpb24gV2hldGhlciBvciBub3QgdGFyZ2V0IGNhbiBiZSBzY3JvbGxlZCB0byB0aGUgc2Nyb2xsIGNvbnRhaW5lciAoZGVmYXVsdDogZmFsc2UpXG4gKi9cblxuXG52YXIgU2Nyb2xsYWJsZSA9IHtcbiAgbmFtZTogXCJzY3JvbGxhYmxlXCIsXG4gIGNhblBpbmNoOiB0cnVlLFxuICBwcm9wczoge1xuICAgIHNjcm9sbGFibGU6IEJvb2xlYW4sXG4gICAgc2Nyb2xsQ29udGFpbmVyOiBPYmplY3QsXG4gICAgc2Nyb2xsVGhyZXNob2xkOiBOdW1iZXIsXG4gICAgZ2V0U2Nyb2xsUG9zaXRpb246IEZ1bmN0aW9uXG4gIH0sXG4gIGV2ZW50czoge1xuICAgIG9uU2Nyb2xsOiBcInNjcm9sbFwiLFxuICAgIG9uU2Nyb2xsR3JvdXA6IFwic2Nyb2xsR3JvdXBcIlxuICB9LFxuICBkcmFnUmVsYXRpb246IFwic3Ryb25nXCIsXG4gIGRyYWdTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIHByb3BzID0gbW92ZWFibGUucHJvcHM7XG4gICAgdmFyIF9hID0gcHJvcHMuc2Nyb2xsQ29udGFpbmVyLFxuICAgICAgICBzY3JvbGxDb250YWluZXIgPSBfYSA9PT0gdm9pZCAwID8gbW92ZWFibGUuZ2V0Q29udGFpbmVyKCkgOiBfYTtcbiAgICB2YXIgZHJhZ1Njcm9sbCA9IG5ldyBEcmFnU2Nyb2xsKCk7XG4gICAgdmFyIHNjcm9sbENvbnRhaW5lckVsZW1lbnQgPSBnZXRSZWZUYXJnZXQoc2Nyb2xsQ29udGFpbmVyLCB0cnVlKTtcbiAgICBlLmRhdGFzLmRyYWdTY3JvbGwgPSBkcmFnU2Nyb2xsO1xuICAgIHZhciBnZXN0b05hbWUgPSBlLmlzQ29udHJvbCA/IFwiY29udHJvbEdlc3RvXCIgOiBcInRhcmdldEdlc3RvXCI7XG4gICAgdmFyIHRhcmdldHMgPSBlLnRhcmdldHM7XG4gICAgZHJhZ1Njcm9sbC5vbihcInNjcm9sbFwiLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgIHZhciBjb250YWluZXIgPSBfYS5jb250YWluZXIsXG4gICAgICAgICAgZGlyZWN0aW9uID0gX2EuZGlyZWN0aW9uO1xuICAgICAgdmFyIHBhcmFtcyA9IGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIHtcbiAgICAgICAgc2Nyb2xsQ29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uXG4gICAgICB9KTtcbiAgICAgIHZhciBldmVudE5hbWUgPSB0YXJnZXRzID8gXCJvblNjcm9sbEdyb3VwXCIgOiBcIm9uU2Nyb2xsXCI7XG5cbiAgICAgIGlmICh0YXJnZXRzKSB7XG4gICAgICAgIHBhcmFtcy50YXJnZXRzID0gdGFyZ2V0cztcbiAgICAgIH1cblxuICAgICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBldmVudE5hbWUsIHBhcmFtcyk7XG4gICAgfSkub24oXCJtb3ZlXCIsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgdmFyIG9mZnNldFggPSBfYS5vZmZzZXRYLFxuICAgICAgICAgIG9mZnNldFkgPSBfYS5vZmZzZXRZO1xuICAgICAgbW92ZWFibGVbZ2VzdG9OYW1lXS5zY3JvbGxCeShvZmZzZXRYLCBvZmZzZXRZLCBlLmlucHV0RXZlbnQsIGZhbHNlKTtcbiAgICB9KTtcbiAgICBkcmFnU2Nyb2xsLmRyYWdTdGFydChlLCB7XG4gICAgICBjb250YWluZXI6IHNjcm9sbENvbnRhaW5lckVsZW1lbnRcbiAgICB9KTtcbiAgfSxcbiAgY2hlY2tTY3JvbGw6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBkcmFnU2Nyb2xsID0gZS5kYXRhcy5kcmFnU2Nyb2xsO1xuXG4gICAgaWYgKCFkcmFnU2Nyb2xsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIF9hID0gbW92ZWFibGUucHJvcHMsXG4gICAgICAgIF9iID0gX2Euc2Nyb2xsQ29udGFpbmVyLFxuICAgICAgICBzY3JvbGxDb250YWluZXIgPSBfYiA9PT0gdm9pZCAwID8gbW92ZWFibGUuZ2V0Q29udGFpbmVyKCkgOiBfYixcbiAgICAgICAgX2MgPSBfYS5zY3JvbGxUaHJlc2hvbGQsXG4gICAgICAgIHNjcm9sbFRocmVzaG9sZCA9IF9jID09PSB2b2lkIDAgPyAwIDogX2MsXG4gICAgICAgIF9kID0gX2EuZ2V0U2Nyb2xsUG9zaXRpb24sXG4gICAgICAgIGdldFNjcm9sbFBvc2l0aW9uID0gX2QgPT09IHZvaWQgMCA/IGdldERlZmF1bHRTY3JvbGxQb3NpdGlvbiA6IF9kO1xuICAgIGRyYWdTY3JvbGwuZHJhZyhlLCB7XG4gICAgICBjb250YWluZXI6IHNjcm9sbENvbnRhaW5lcixcbiAgICAgIHRocmVzaG9sZDogc2Nyb2xsVGhyZXNob2xkLFxuICAgICAgZ2V0U2Nyb2xsUG9zaXRpb246IGZ1bmN0aW9uIChldikge1xuICAgICAgICByZXR1cm4gZ2V0U2Nyb2xsUG9zaXRpb24oe1xuICAgICAgICAgIHNjcm9sbENvbnRhaW5lcjogZXYuY29udGFpbmVyLFxuICAgICAgICAgIGRpcmVjdGlvbjogZXYuZGlyZWN0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBkcmFnOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5jaGVja1Njcm9sbChtb3ZlYWJsZSwgZSk7XG4gIH0sXG4gIGRyYWdFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIGUuZGF0YXMuZHJhZ1Njcm9sbC5kcmFnRW5kKCk7XG4gICAgZS5kYXRhcy5kcmFnU2Nyb2xsID0gbnVsbDtcbiAgfSxcbiAgZHJhZ0NvbnRyb2xTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ1N0YXJ0KG1vdmVhYmxlLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHtcbiAgICAgIGlzQ29udHJvbDogdHJ1ZVxuICAgIH0pKTtcbiAgfSxcbiAgZHJhZ0NvbnRyb2w6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWcobW92ZWFibGUsIGUpO1xuICB9LFxuICBkcmFnQ29udHJvbEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ0VuZChtb3ZlYWJsZSwgZSk7XG4gIH0sXG4gIGRyYWdHcm91cFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnU3RhcnQobW92ZWFibGUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwge1xuICAgICAgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0c1xuICAgIH0pKTtcbiAgfSxcbiAgZHJhZ0dyb3VwOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnKG1vdmVhYmxlLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHtcbiAgICAgIHRhcmdldHM6IG1vdmVhYmxlLnByb3BzLnRhcmdldHNcbiAgICB9KSk7XG4gIH0sXG4gIGRyYWdHcm91cEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ0VuZChtb3ZlYWJsZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7XG4gICAgICB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzXG4gICAgfSkpO1xuICB9LFxuICBkcmFnR3JvdXBDb250cm9sU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWdTdGFydChtb3ZlYWJsZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7XG4gICAgICB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzLFxuICAgICAgaXNDb250cm9sOiB0cnVlXG4gICAgfSkpO1xuICB9LFxuICBkcmFnR3JvdXBDb250cm86IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWcobW92ZWFibGUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwge1xuICAgICAgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0c1xuICAgIH0pKTtcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnRW5kKG1vdmVhYmxlLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHtcbiAgICAgIHRhcmdldHM6IG1vdmVhYmxlLnByb3BzLnRhcmdldHNcbiAgICB9KSk7XG4gIH1cbn07XG4vKipcbiAqIFdoZXRoZXIgb3Igbm90IHRhcmdldCBjYW4gYmUgc2Nyb2xsZWQgdG8gdGhlIHNjcm9sbCBjb250YWluZXIgKGRlZmF1bHQ6IGZhbHNlKVxuICogQG5hbWUgTW92ZWFibGUuU2Nyb2xsYWJsZSNzY3JvbGxhYmxlXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgc2Nyb2xsYWJsZTogdHJ1ZSxcbiAqICAgc2Nyb2xsQ29udGFpbmVyOiBkb2N1bWVudC5ib2R5LFxuICogICBzY3JvbGxUaHJlc2hvbGQ6IDAsXG4gKiAgIGdldFNjcm9sbFBvc2l0aW9uOiAoeyBzY3JvbGxDb250YWluZXIgfSkgPT4gKFtzY3JvbGxDb250YWluZXIuc2Nyb2xsTGVmdCwgc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcF0pLFxuICogfSk7XG4gKlxuICogbW92ZWFibGUuc2Nyb2xsYWJsZSA9IHRydWU7XG4gKi9cblxuLyoqXG4gKiBUaGUgY29udGFpbmVyIHRvIHdoaWNoIHNjcm9sbCBpcyBhcHBsaWVkIChkZWZhdWx0OiBjb250YWluZXIpXG4gKiBAbmFtZSBNb3ZlYWJsZS5TY3JvbGxhYmxlI3Njcm9sbENvbnRhaW5lclxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgIHNjcm9sbGFibGU6IHRydWUsXG4gKiAgIHNjcm9sbENvbnRhaW5lcjogZG9jdW1lbnQuYm9keSxcbiAqICAgc2Nyb2xsVGhyZXNob2xkOiAwLFxuICogICBnZXRTY3JvbGxQb3NpdGlvbjogKHsgc2Nyb2xsQ29udGFpbmVyIH0pID0+IChbc2Nyb2xsQ29udGFpbmVyLnNjcm9sbExlZnQsIHNjcm9sbENvbnRhaW5lci5zY3JvbGxUb3BdKSxcbiAqIH0pO1xuICovXG5cbi8qKlxuICogRXhwYW5kIHRoZSByYW5nZSBvZiB0aGUgc2Nyb2xsIGNoZWNrIGFyZWEuIChkZWZhdWx0OiAwKVxuICogQG5hbWUgTW92ZWFibGUuU2Nyb2xsYWJsZSNzY3JvbGxUaHJlc2hvbGRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICBzY3JvbGxhYmxlOiB0cnVlLFxuICogICBzY3JvbGxDb250YWluZXI6IGRvY3VtZW50LmJvZHksXG4gKiAgIHNjcm9sbFRocmVzaG9sZDogMCxcbiAqICAgZ2V0U2Nyb2xsUG9zaXRpb246ICh7IHNjcm9sbENvbnRhaW5lciB9KSA9PiAoW3Njcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0LCBzY3JvbGxDb250YWluZXIuc2Nyb2xsVG9wXSksXG4gKiB9KTtcbiAqL1xuXG4vKipcbiAqIFNldHMgYSBmdW5jdGlvbiB0byBnZXQgdGhlIHNjcm9sbCBwb3NpdGlvbi4gKGRlZmF1bHQ6IEZ1bmN0aW9uKVxuICogQG5hbWUgTW92ZWFibGUuU2Nyb2xsYWJsZSNnZXRTY3JvbGxQb3NpdGlvblxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgIHNjcm9sbGFibGU6IHRydWUsXG4gKiAgIHNjcm9sbENvbnRhaW5lcjogZG9jdW1lbnQuYm9keSxcbiAqICAgc2Nyb2xsVGhyZXNob2xkOiAwLFxuICogICBnZXRTY3JvbGxQb3NpdGlvbjogKHsgc2Nyb2xsQ29udGFpbmVyIH0pID0+IChbc2Nyb2xsQ29udGFpbmVyLnNjcm9sbExlZnQsIHNjcm9sbENvbnRhaW5lci5zY3JvbGxUb3BdKSxcbiAqIH0pO1xuICpcbiAqL1xuXG4vKipcbiAqIFdoZW4gdGhlIGRyYWcgY3Vyc29yIGxlYXZlcyB0aGUgc2Nyb2xsQ29udGFpbmVyLCB0aGUgYHNjcm9sbGAgZXZlbnQgb2NjdXIgdG8gc2Nyb2xsLlxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlNjcm9sbGFibGVcbiAqIEBldmVudCBzY3JvbGxcbiAqIEBwYXJhbSB7TW92ZWFibGUuU2Nyb2xsYWJsZS5PblNjcm9sbH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHNjcm9sbGAgZXZlbnRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICAgIHRhcmdldDogZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi50YXJnZXRcIiksXG4gKiB9KTtcbiAqIG1vdmVhYmxlLm9uKFwic2Nyb2xsXCIsICh7IHNjcm9sbENvbnRhaW5lciwgZGlyZWN0aW9uIH0pID0+IHtcbiAqICAgc2Nyb2xsQ29udGFpbmVyLnNjcm9sbExlZnQgKz0gZGlyZWN0aW9uWzBdICogMTA7XG4gKiAgIHNjcm9sbENvbnRhaW5lci5zY3JvbGxUb3AgKz0gZGlyZWN0aW9uWzFdICogMTA7XG4gKiB9KTtcbiAqL1xuXG4vKipcbiAqIFdoZW4gdGhlIGRyYWcgY3Vyc29yIGxlYXZlcyB0aGUgc2Nyb2xsQ29udGFpbmVyLCB0aGUgYHNjcm9sbEdyb3VwYCBldmVudCBvY2N1ciB0byBzY3JvbGwgaW4gZ3JvdXAuXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuU2Nyb2xsYWJsZVxuICogQGV2ZW50IHNjcm9sbEdyb3VwXG4gKiBAcGFyYW0ge01vdmVhYmxlLlNjcm9sbGFibGUuT25TY3JvbGxHcm91cH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHNjcm9sbEdyb3VwYCBldmVudFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgdGFyZ2V0OiBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFyZ2V0XCIpKSxcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJzY3JvbGxcIiwgKHsgc2Nyb2xsQ29udGFpbmVyLCBkaXJlY3Rpb24gfSkgPT4ge1xuICogICBzY3JvbGxDb250YWluZXIuc2Nyb2xsTGVmdCArPSBkaXJlY3Rpb25bMF0gKiAxMDtcbiAqICAgc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcCArPSBkaXJlY3Rpb25bMV0gKiAxMDtcbiAqIH0pO1xuICovXG5cbnZhciBEZWZhdWx0ID0ge1xuICBuYW1lOiBcIlwiLFxuICBwcm9wczoge1xuICAgIHRhcmdldDogT2JqZWN0LFxuICAgIGRyYWdUYXJnZXQ6IE9iamVjdCxcbiAgICBjb250YWluZXI6IE9iamVjdCxcbiAgICBwb3J0YWxDb250YWluZXI6IE9iamVjdCxcbiAgICByb290Q29udGFpbmVyOiBPYmplY3QsXG4gICAgdXNlUmVzaXplT2JzZXJ2ZXI6IEJvb2xlYW4sXG4gICAgem9vbTogTnVtYmVyLFxuICAgIHRyYW5zZm9ybU9yaWdpbjogQXJyYXksXG4gICAgZWRnZTogQm9vbGVhbixcbiAgICBhYmxlczogQXJyYXksXG4gICAgY2xhc3NOYW1lOiBTdHJpbmcsXG4gICAgcGluY2hUaHJlc2hvbGQ6IE51bWJlcixcbiAgICBwaW5jaE91dHNpZGU6IEJvb2xlYW4sXG4gICAgdHJpZ2dlckFibGVzU2ltdWx0YW5lb3VzbHk6IEJvb2xlYW4sXG4gICAgY2hlY2tJbnB1dDogQm9vbGVhbixcbiAgICBjc3BOb25jZTogU3RyaW5nLFxuICAgIHRyYW5zbGF0ZVo6IE51bWJlcixcbiAgICBoaWRlRGVmYXVsdExpbmVzOiBCb29sZWFuLFxuICAgIHByb3BzOiBPYmplY3RcbiAgfSxcbiAgZXZlbnRzOiB7fVxufTtcblxudmFyIFBhZGRpbmcgPSBtYWtlQWJsZShcInBhZGRpbmdcIiwge1xuICByZW5kZXI6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgUmVhY3QpIHtcbiAgICB2YXIgcHJvcHMgPSBtb3ZlYWJsZS5wcm9wcztcblxuICAgIGlmIChwcm9wcy5kcmFnQXJlYSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciBwYWRkaW5nID0gcHJvcHMucGFkZGluZyB8fCB7fTtcbiAgICB2YXIgX2EgPSBwYWRkaW5nLmxlZnQsXG4gICAgICAgIGxlZnQgPSBfYSA9PT0gdm9pZCAwID8gMCA6IF9hLFxuICAgICAgICBfYiA9IHBhZGRpbmcudG9wLFxuICAgICAgICB0b3AgPSBfYiA9PT0gdm9pZCAwID8gMCA6IF9iLFxuICAgICAgICBfYyA9IHBhZGRpbmcucmlnaHQsXG4gICAgICAgIHJpZ2h0ID0gX2MgPT09IHZvaWQgMCA/IDAgOiBfYyxcbiAgICAgICAgX2QgPSBwYWRkaW5nLmJvdHRvbSxcbiAgICAgICAgYm90dG9tID0gX2QgPT09IHZvaWQgMCA/IDAgOiBfZDtcbiAgICB2YXIgX2UgPSBtb3ZlYWJsZS5zdGF0ZSxcbiAgICAgICAgcmVuZGVyUG9zZXMgPSBfZS5yZW5kZXJQb3NlcyxcbiAgICAgICAgcG9zMSA9IF9lLnBvczEsXG4gICAgICAgIHBvczIgPSBfZS5wb3MyLFxuICAgICAgICBwb3MzID0gX2UucG9zMyxcbiAgICAgICAgcG9zNCA9IF9lLnBvczQ7XG4gICAgdmFyIHBvc2VzID0gW3BvczEsIHBvczIsIHBvczMsIHBvczRdO1xuICAgIHZhciBwYWRkaW5nRGlyZWN0aW9ucyA9IFtdO1xuXG4gICAgaWYgKGxlZnQgPiAwKSB7XG4gICAgICBwYWRkaW5nRGlyZWN0aW9ucy5wdXNoKFswLCAyXSk7XG4gICAgfVxuXG4gICAgaWYgKHRvcCA+IDApIHtcbiAgICAgIHBhZGRpbmdEaXJlY3Rpb25zLnB1c2goWzAsIDFdKTtcbiAgICB9XG5cbiAgICBpZiAocmlnaHQgPiAwKSB7XG4gICAgICBwYWRkaW5nRGlyZWN0aW9ucy5wdXNoKFsxLCAzXSk7XG4gICAgfVxuXG4gICAgaWYgKGJvdHRvbSA+IDApIHtcbiAgICAgIHBhZGRpbmdEaXJlY3Rpb25zLnB1c2goWzIsIDNdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFkZGluZ0RpcmVjdGlvbnMubWFwKGZ1bmN0aW9uIChfYSwgaSkge1xuICAgICAgdmFyIGRpcjEgPSBfYVswXSxcbiAgICAgICAgICBkaXIyID0gX2FbMV07XG4gICAgICB2YXIgcGFkZGluZ1BvczEgPSBwb3Nlc1tkaXIxXTtcbiAgICAgIHZhciBwYWRkaW5nUG9zMiA9IHBvc2VzW2RpcjJdO1xuICAgICAgdmFyIHBhZGRpbmdQb3MzID0gcmVuZGVyUG9zZXNbZGlyMV07XG4gICAgICB2YXIgcGFkZGluZ1BvczQgPSByZW5kZXJQb3Nlc1tkaXIyXTtcbiAgICAgIHZhciBoID0gY3JlYXRlV2FycE1hdHJpeChbMCwgMF0sIFsxMDAsIDBdLCBbMCwgMTAwXSwgWzEwMCwgMTAwXSwgcGFkZGluZ1BvczEsIHBhZGRpbmdQb3MyLCBwYWRkaW5nUG9zMywgcGFkZGluZ1BvczQpO1xuXG4gICAgICBpZiAoIWgubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAga2V5OiBcInBhZGRpbmdcIiArIGksXG4gICAgICAgIGNsYXNzTmFtZTogcHJlZml4KFwicGFkZGluZ1wiKSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICB0cmFuc2Zvcm06IG1ha2VNYXRyaXhDU1MoaCwgdHJ1ZSlcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn0pO1xuLyoqXG4gKiBBZGQgcGFkZGluZyBhcm91bmQgdGhlIHRhcmdldCB0byBpbmNyZWFzZSB0aGUgZHJhZyBhcmVhLiAoZGVmYXVsdDogbnVsbClcbiAqIEBuYW1lIE1vdmVhYmxlI3BhZGRpbmdcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogIHRhcmdldDogZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi50YXJnZXRcIiksXG4gKiAgcGFkZGluZzogeyBsZWZ0OiAwLCB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAgfSxcbiAqIH0pO1xuICogbW92ZWFibGUucGFkZGluZyA9IHsgbGVmdDogMTAsIHRvcDogMTAsIHJpZ2h0OiAxMCwgYm90dG9tOiAxMCB9LFxuICogbW92ZWFibGUudXBkYXRlUmVjdCgpO1xuICovXG5cbnZhciBSQURJVVNfRElSRUNUSU9OUyA9IFtcIm53XCIsIFwibmVcIiwgXCJzZVwiLCBcInN3XCJdO1xuXG5mdW5jdGlvbiBjYWxjdWxhdGVSYXRpbyh2YWx1ZXMsIHNpemUpIHtcbiAgdmFyIHN1bVNpemUgPSB2YWx1ZXNbMF0gKyB2YWx1ZXNbMV07XG4gIHZhciBzdW1SYXRpbyA9IHN1bVNpemUgPiBzaXplID8gc2l6ZSAvIHN1bVNpemUgOiAxO1xuICB2YWx1ZXNbMF0gKj0gc3VtUmF0aW87XG4gIHZhbHVlc1sxXSA9IHNpemUgLSB2YWx1ZXNbMV0gKiBzdW1SYXRpbztcbiAgcmV0dXJuIHZhbHVlcztcbn1cblxudmFyIEhPUklaT05UQUxfUkFESVVTX09SREVSID0gWzEsIDIsIDUsIDZdO1xudmFyIFZFUlRJQ0FMX1JBRElVU19PUkRFUiA9IFswLCAzLCA0LCA3XTtcbnZhciBIT1JJWk9OVEFMX1JBRElVU19ESVJFQ1RJT05TID0gWzEsIC0xLCAtMSwgMV07XG52YXIgVkVSVElDQUxfUkFESVVTX0RJUkVDVElPTlMgPSBbMSwgMSwgLTEsIC0xXTtcbmZ1bmN0aW9uIGdldFJhZGl1c1N0eWxlcyhwb3NlcywgY29udHJvbFBvc2VzLCBpc1JlbGF0aXZlLCB3aWR0aCwgaGVpZ2h0LCBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b20pIHtcbiAgaWYgKGxlZnQgPT09IHZvaWQgMCkge1xuICAgIGxlZnQgPSAwO1xuICB9XG5cbiAgaWYgKHRvcCA9PT0gdm9pZCAwKSB7XG4gICAgdG9wID0gMDtcbiAgfVxuXG4gIGlmIChyaWdodCA9PT0gdm9pZCAwKSB7XG4gICAgcmlnaHQgPSB3aWR0aDtcbiAgfVxuXG4gIGlmIChib3R0b20gPT09IHZvaWQgMCkge1xuICAgIGJvdHRvbSA9IGhlaWdodDtcbiAgfVxuXG4gIHZhciBjbGlwU3R5bGVzID0gW107XG4gIHZhciBpc1ZlcnRpY2FsID0gZmFsc2U7XG4gIHZhciByYXdzID0gcG9zZXMubWFwKGZ1bmN0aW9uIChwb3MsIGkpIHtcbiAgICB2YXIgX2EgPSBjb250cm9sUG9zZXNbaV0sXG4gICAgICAgIGhvcml6b250YWwgPSBfYS5ob3Jpem9udGFsLFxuICAgICAgICB2ZXJ0aWNhbCA9IF9hLnZlcnRpY2FsO1xuXG4gICAgaWYgKHZlcnRpY2FsICYmICFpc1ZlcnRpY2FsKSB7XG4gICAgICBpc1ZlcnRpY2FsID0gdHJ1ZTtcbiAgICAgIGNsaXBTdHlsZXMucHVzaChcIi9cIik7XG4gICAgfVxuXG4gICAgaWYgKGlzVmVydGljYWwpIHtcbiAgICAgIHZhciByYXdQb3MgPSBNYXRoLm1heCgwLCB2ZXJ0aWNhbCA9PT0gMSA/IHBvc1sxXSAtIHRvcCA6IGJvdHRvbSAtIHBvc1sxXSk7XG4gICAgICBjbGlwU3R5bGVzLnB1c2goY29udmVydENTU1NpemUocmF3UG9zLCBoZWlnaHQsIGlzUmVsYXRpdmUpKTtcbiAgICAgIHJldHVybiByYXdQb3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByYXdQb3MgPSBNYXRoLm1heCgwLCBob3Jpem9udGFsID09PSAxID8gcG9zWzBdIC0gbGVmdCA6IHJpZ2h0IC0gcG9zWzBdKTtcbiAgICAgIGNsaXBTdHlsZXMucHVzaChjb252ZXJ0Q1NTU2l6ZShyYXdQb3MsIHdpZHRoLCBpc1JlbGF0aXZlKSk7XG4gICAgICByZXR1cm4gcmF3UG9zO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgc3R5bGVzOiBjbGlwU3R5bGVzLFxuICAgIHJhd3M6IHJhd3NcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFJhZGl1c1JhbmdlKGNvbnRyb2xQb3Nlcykge1xuICAvLyBbc3RhcnQsIGxlbmd0aF1cbiAgdmFyIGhvcml6b250YWxSYW5nZSA9IFswLCAwXTtcbiAgdmFyIHZlcnRpY2FsUmFuZ2UgPSBbMCwgMF07XG4gIHZhciBsZW5ndGggPSBjb250cm9sUG9zZXMubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgY2xpcFBvc2UgPSBjb250cm9sUG9zZXNbaV07XG5cbiAgICBpZiAoIWNsaXBQb3NlLnN1Yikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGNsaXBQb3NlLmhvcml6b250YWwpIHtcbiAgICAgIGlmIChob3Jpem9udGFsUmFuZ2VbMV0gPT09IDApIHtcbiAgICAgICAgaG9yaXpvbnRhbFJhbmdlWzBdID0gaTtcbiAgICAgIH1cblxuICAgICAgaG9yaXpvbnRhbFJhbmdlWzFdID0gaSAtIGhvcml6b250YWxSYW5nZVswXSArIDE7XG4gICAgICB2ZXJ0aWNhbFJhbmdlWzBdID0gaSArIDE7XG4gICAgfVxuXG4gICAgaWYgKGNsaXBQb3NlLnZlcnRpY2FsKSB7XG4gICAgICBpZiAodmVydGljYWxSYW5nZVsxXSA9PT0gMCkge1xuICAgICAgICB2ZXJ0aWNhbFJhbmdlWzBdID0gaTtcbiAgICAgIH1cblxuICAgICAgdmVydGljYWxSYW5nZVsxXSA9IGkgLSB2ZXJ0aWNhbFJhbmdlWzBdICsgMTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGhvcml6b250YWxSYW5nZTogaG9yaXpvbnRhbFJhbmdlLFxuICAgIHZlcnRpY2FsUmFuZ2U6IHZlcnRpY2FsUmFuZ2VcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFJhZGl1c1ZhbHVlcyh2YWx1ZXMsIHdpZHRoLCBoZWlnaHQsIGxlZnQsIHRvcCwgbWluQ291bnRzKSB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZDtcblxuICBpZiAobWluQ291bnRzID09PSB2b2lkIDApIHtcbiAgICBtaW5Db3VudHMgPSBbMCwgMF07XG4gIH1cblxuICB2YXIgc3BsaXRJbmRleCA9IHZhbHVlcy5pbmRleE9mKFwiL1wiKTtcbiAgdmFyIHNwbGl0TGVuZ3RoID0gKHNwbGl0SW5kZXggPiAtMSA/IHZhbHVlcy5zbGljZSgwLCBzcGxpdEluZGV4KSA6IHZhbHVlcykubGVuZ3RoO1xuICB2YXIgaG9yaXpvbnRhbFZhbHVlcyA9IHZhbHVlcy5zbGljZSgwLCBzcGxpdExlbmd0aCk7XG4gIHZhciB2ZXJ0aWNhbFZhbHVlcyA9IHZhbHVlcy5zbGljZShzcGxpdExlbmd0aCArIDEpO1xuICB2YXIgX2UgPSBob3Jpem9udGFsVmFsdWVzWzBdLFxuICAgICAgbndWYWx1ZSA9IF9lID09PSB2b2lkIDAgPyBcIjBweFwiIDogX2UsXG4gICAgICBfZiA9IGhvcml6b250YWxWYWx1ZXNbMV0sXG4gICAgICBuZVZhbHVlID0gX2YgPT09IHZvaWQgMCA/IG53VmFsdWUgOiBfZixcbiAgICAgIF9nID0gaG9yaXpvbnRhbFZhbHVlc1syXSxcbiAgICAgIHNlVmFsdWUgPSBfZyA9PT0gdm9pZCAwID8gbndWYWx1ZSA6IF9nLFxuICAgICAgX2ggPSBob3Jpem9udGFsVmFsdWVzWzNdLFxuICAgICAgc3dWYWx1ZSA9IF9oID09PSB2b2lkIDAgPyBuZVZhbHVlIDogX2g7XG4gIHZhciBfaiA9IHZlcnRpY2FsVmFsdWVzWzBdLFxuICAgICAgd25WYWx1ZSA9IF9qID09PSB2b2lkIDAgPyBud1ZhbHVlIDogX2osXG4gICAgICBfayA9IHZlcnRpY2FsVmFsdWVzWzFdLFxuICAgICAgZW5WYWx1ZSA9IF9rID09PSB2b2lkIDAgPyB3blZhbHVlIDogX2ssXG4gICAgICBfbCA9IHZlcnRpY2FsVmFsdWVzWzJdLFxuICAgICAgZXNWYWx1ZSA9IF9sID09PSB2b2lkIDAgPyB3blZhbHVlIDogX2wsXG4gICAgICBfbSA9IHZlcnRpY2FsVmFsdWVzWzNdLFxuICAgICAgd3NWYWx1ZSA9IF9tID09PSB2b2lkIDAgPyBlblZhbHVlIDogX207XG4gIHZhciBob3Jpem9udGFsUmF3UG9zZXMgPSBbbndWYWx1ZSwgbmVWYWx1ZSwgc2VWYWx1ZSwgc3dWYWx1ZV0ubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICByZXR1cm4gY29udmVydFVuaXRTaXplKHBvcywgd2lkdGgpO1xuICB9KTtcbiAgdmFyIHZlcnRpY2FsUmF3UG9zZXMgPSBbd25WYWx1ZSwgZW5WYWx1ZSwgZXNWYWx1ZSwgd3NWYWx1ZV0ubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICByZXR1cm4gY29udmVydFVuaXRTaXplKHBvcywgaGVpZ2h0KTtcbiAgfSk7XG4gIHZhciBob3Jpem9udGFsUG9zZXMgPSBob3Jpem9udGFsUmF3UG9zZXMuc2xpY2UoKTtcbiAgdmFyIHZlcnRpY2FsUG9zZXMgPSB2ZXJ0aWNhbFJhd1Bvc2VzLnNsaWNlKCk7XG4gIF9hID0gY2FsY3VsYXRlUmF0aW8oW2hvcml6b250YWxQb3Nlc1swXSwgaG9yaXpvbnRhbFBvc2VzWzFdXSwgd2lkdGgpLCBob3Jpem9udGFsUG9zZXNbMF0gPSBfYVswXSwgaG9yaXpvbnRhbFBvc2VzWzFdID0gX2FbMV07XG4gIF9iID0gY2FsY3VsYXRlUmF0aW8oW2hvcml6b250YWxQb3Nlc1szXSwgaG9yaXpvbnRhbFBvc2VzWzJdXSwgd2lkdGgpLCBob3Jpem9udGFsUG9zZXNbM10gPSBfYlswXSwgaG9yaXpvbnRhbFBvc2VzWzJdID0gX2JbMV07XG4gIF9jID0gY2FsY3VsYXRlUmF0aW8oW3ZlcnRpY2FsUG9zZXNbMF0sIHZlcnRpY2FsUG9zZXNbM11dLCBoZWlnaHQpLCB2ZXJ0aWNhbFBvc2VzWzBdID0gX2NbMF0sIHZlcnRpY2FsUG9zZXNbM10gPSBfY1sxXTtcbiAgX2QgPSBjYWxjdWxhdGVSYXRpbyhbdmVydGljYWxQb3Nlc1sxXSwgdmVydGljYWxQb3Nlc1syXV0sIGhlaWdodCksIHZlcnRpY2FsUG9zZXNbMV0gPSBfZFswXSwgdmVydGljYWxQb3Nlc1syXSA9IF9kWzFdO1xuICB2YXIgbmV4dEhvcml6b250YWxQb3NlcyA9IGhvcml6b250YWxQb3Nlcy5zbGljZSgwLCBNYXRoLm1heChtaW5Db3VudHNbMF0sIGhvcml6b250YWxWYWx1ZXMubGVuZ3RoKSk7XG4gIHZhciBuZXh0VmVydGljYWxQb3NlcyA9IHZlcnRpY2FsUG9zZXMuc2xpY2UoMCwgTWF0aC5tYXgobWluQ291bnRzWzFdLCB2ZXJ0aWNhbFZhbHVlcy5sZW5ndGgpKTtcbiAgcmV0dXJuIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgbmV4dEhvcml6b250YWxQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcywgaSkge1xuICAgIHZhciBkaXJlY3Rpb24gPSBSQURJVVNfRElSRUNUSU9OU1tpXTtcbiAgICByZXR1cm4ge1xuICAgICAgaG9yaXpvbnRhbDogSE9SSVpPTlRBTF9SQURJVVNfRElSRUNUSU9OU1tpXSxcbiAgICAgIHZlcnRpY2FsOiAwLFxuICAgICAgcG9zOiBbbGVmdCArIHBvcywgdG9wICsgKFZFUlRJQ0FMX1JBRElVU19ESVJFQ1RJT05TW2ldID09PSAtMSA/IGhlaWdodCA6IDApXSxcbiAgICAgIHN1YjogdHJ1ZSxcbiAgICAgIHJhdzogaG9yaXpvbnRhbFJhd1Bvc2VzW2ldLFxuICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb25cbiAgICB9O1xuICB9KSksIG5leHRWZXJ0aWNhbFBvc2VzLm1hcChmdW5jdGlvbiAocG9zLCBpKSB7XG4gICAgdmFyIGRpcmVjdGlvbiA9IFJBRElVU19ESVJFQ1RJT05TW2ldO1xuICAgIHJldHVybiB7XG4gICAgICBob3Jpem9udGFsOiAwLFxuICAgICAgdmVydGljYWw6IFZFUlRJQ0FMX1JBRElVU19ESVJFQ1RJT05TW2ldLFxuICAgICAgcG9zOiBbbGVmdCArIChIT1JJWk9OVEFMX1JBRElVU19ESVJFQ1RJT05TW2ldID09PSAtMSA/IHdpZHRoIDogMCksIHRvcCArIHBvc10sXG4gICAgICBzdWI6IHRydWUsXG4gICAgICByYXc6IHZlcnRpY2FsUmF3UG9zZXNbaV0sXG4gICAgICBkaXJlY3Rpb246IGRpcmVjdGlvblxuICAgIH07XG4gIH0pKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVJhZGl1c1Bvcyhjb250cm9sUG9zZXMsIHBvc2VzLCBpbmRleCwgc3RhcnRJbmRleCwgbGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPT09IHZvaWQgMCkge1xuICAgIGxlbmd0aCA9IHBvc2VzLmxlbmd0aDtcbiAgfVxuXG4gIHZhciBfYSA9IGdldFJhZGl1c1JhbmdlKGNvbnRyb2xQb3Nlcy5zbGljZShzdGFydEluZGV4KSksXG4gICAgICBob3Jpem9udGFsUmFuZ2UgPSBfYS5ob3Jpem9udGFsUmFuZ2UsXG4gICAgICB2ZXJ0aWNhbFJhbmdlID0gX2EudmVydGljYWxSYW5nZTtcblxuICB2YXIgcmFkaXVzbEluZGV4ID0gaW5kZXggLSBzdGFydEluZGV4O1xuICB2YXIgZGVsZXRlQ291bnQgPSAwO1xuXG4gIGlmIChyYWRpdXNsSW5kZXggPT09IDApIHtcbiAgICBkZWxldGVDb3VudCA9IGxlbmd0aDtcbiAgfSBlbHNlIGlmIChyYWRpdXNsSW5kZXggPiAwICYmIHJhZGl1c2xJbmRleCA8IGhvcml6b250YWxSYW5nZVsxXSkge1xuICAgIGRlbGV0ZUNvdW50ID0gaG9yaXpvbnRhbFJhbmdlWzFdIC0gcmFkaXVzbEluZGV4O1xuICB9IGVsc2UgaWYgKHJhZGl1c2xJbmRleCA+PSB2ZXJ0aWNhbFJhbmdlWzBdKSB7XG4gICAgZGVsZXRlQ291bnQgPSB2ZXJ0aWNhbFJhbmdlWzBdICsgdmVydGljYWxSYW5nZVsxXSAtIHJhZGl1c2xJbmRleDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb250cm9sUG9zZXMuc3BsaWNlKGluZGV4LCBkZWxldGVDb3VudCk7XG4gIHBvc2VzLnNwbGljZShpbmRleCwgZGVsZXRlQ291bnQpO1xufVxuZnVuY3Rpb24gYWRkUmFkaXVzUG9zKGNvbnRyb2xQb3NlcywgcG9zZXMsIHN0YXJ0SW5kZXgsIGhvcml6b250YWxJbmRleCwgdmVydGljYWxJbmRleCwgZGlzdFgsIGRpc3RZLCByaWdodCwgYm90dG9tLCBsZWZ0LCB0b3ApIHtcbiAgaWYgKGxlZnQgPT09IHZvaWQgMCkge1xuICAgIGxlZnQgPSAwO1xuICB9XG5cbiAgaWYgKHRvcCA9PT0gdm9pZCAwKSB7XG4gICAgdG9wID0gMDtcbiAgfVxuXG4gIHZhciBfYSA9IGdldFJhZGl1c1JhbmdlKGNvbnRyb2xQb3Nlcy5zbGljZShzdGFydEluZGV4KSksXG4gICAgICBob3Jpem9udGFsUmFuZ2UgPSBfYS5ob3Jpem9udGFsUmFuZ2UsXG4gICAgICB2ZXJ0aWNhbFJhbmdlID0gX2EudmVydGljYWxSYW5nZTtcblxuICBpZiAoaG9yaXpvbnRhbEluZGV4ID4gLTEpIHtcbiAgICB2YXIgcmFkaXVzWCA9IEhPUklaT05UQUxfUkFESVVTX0RJUkVDVElPTlNbaG9yaXpvbnRhbEluZGV4XSA9PT0gMSA/IGRpc3RYIC0gbGVmdCA6IHJpZ2h0IC0gZGlzdFg7XG5cbiAgICBmb3IgKHZhciBpID0gaG9yaXpvbnRhbFJhbmdlWzFdOyBpIDw9IGhvcml6b250YWxJbmRleDsgKytpKSB7XG4gICAgICB2YXIgeSA9IFZFUlRJQ0FMX1JBRElVU19ESVJFQ1RJT05TW2ldID09PSAxID8gdG9wIDogYm90dG9tO1xuICAgICAgdmFyIHggPSAwO1xuXG4gICAgICBpZiAoaG9yaXpvbnRhbEluZGV4ID09PSBpKSB7XG4gICAgICAgIHggPSBkaXN0WDtcbiAgICAgIH0gZWxzZSBpZiAoaSA9PT0gMCkge1xuICAgICAgICB4ID0gbGVmdCArIHJhZGl1c1g7XG4gICAgICB9IGVsc2UgaWYgKEhPUklaT05UQUxfUkFESVVTX0RJUkVDVElPTlNbaV0gPT09IC0xKSB7XG4gICAgICAgIHggPSByaWdodCAtIChwb3Nlc1tzdGFydEluZGV4XVswXSAtIGxlZnQpO1xuICAgICAgfVxuXG4gICAgICBjb250cm9sUG9zZXMuc3BsaWNlKHN0YXJ0SW5kZXggKyBpLCAwLCB7XG4gICAgICAgIGhvcml6b250YWw6IEhPUklaT05UQUxfUkFESVVTX0RJUkVDVElPTlNbaV0sXG4gICAgICAgIHZlcnRpY2FsOiAwLFxuICAgICAgICBwb3M6IFt4LCB5XVxuICAgICAgfSk7XG4gICAgICBwb3Nlcy5zcGxpY2Uoc3RhcnRJbmRleCArIGksIDAsIFt4LCB5XSk7XG5cbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh2ZXJ0aWNhbEluZGV4ID4gLTEpIHtcbiAgICB2YXIgcmFkaXVzWSA9IFZFUlRJQ0FMX1JBRElVU19ESVJFQ1RJT05TW3ZlcnRpY2FsSW5kZXhdID09PSAxID8gZGlzdFkgLSB0b3AgOiBib3R0b20gLSBkaXN0WTtcblxuICAgIGlmIChob3Jpem9udGFsUmFuZ2VbMV0gPT09IDAgJiYgdmVydGljYWxSYW5nZVsxXSA9PT0gMCkge1xuICAgICAgdmFyIHBvcyA9IFtsZWZ0ICsgcmFkaXVzWSwgdG9wXTtcbiAgICAgIGNvbnRyb2xQb3Nlcy5wdXNoKHtcbiAgICAgICAgaG9yaXpvbnRhbDogSE9SSVpPTlRBTF9SQURJVVNfRElSRUNUSU9OU1swXSxcbiAgICAgICAgdmVydGljYWw6IDAsXG4gICAgICAgIHBvczogcG9zXG4gICAgICB9KTtcbiAgICAgIHBvc2VzLnB1c2gocG9zKTtcbiAgICB9XG5cbiAgICB2YXIgc3RhcnRWZXJ0aWNhbEluZGV4ID0gdmVydGljYWxSYW5nZVswXTtcblxuICAgIGZvciAodmFyIGkgPSB2ZXJ0aWNhbFJhbmdlWzFdOyBpIDw9IHZlcnRpY2FsSW5kZXg7ICsraSkge1xuICAgICAgdmFyIHggPSBIT1JJWk9OVEFMX1JBRElVU19ESVJFQ1RJT05TW2ldID09PSAxID8gbGVmdCA6IHJpZ2h0O1xuICAgICAgdmFyIHkgPSAwO1xuXG4gICAgICBpZiAodmVydGljYWxJbmRleCA9PT0gaSkge1xuICAgICAgICB5ID0gZGlzdFk7XG4gICAgICB9IGVsc2UgaWYgKGkgPT09IDApIHtcbiAgICAgICAgeSA9IHRvcCArIHJhZGl1c1k7XG4gICAgICB9IGVsc2UgaWYgKFZFUlRJQ0FMX1JBRElVU19ESVJFQ1RJT05TW2ldID09PSAxKSB7XG4gICAgICAgIHkgPSBwb3Nlc1tzdGFydEluZGV4ICsgc3RhcnRWZXJ0aWNhbEluZGV4XVsxXTtcbiAgICAgIH0gZWxzZSBpZiAoVkVSVElDQUxfUkFESVVTX0RJUkVDVElPTlNbaV0gPT09IC0xKSB7XG4gICAgICAgIHkgPSBib3R0b20gLSAocG9zZXNbc3RhcnRJbmRleCArIHN0YXJ0VmVydGljYWxJbmRleF1bMV0gLSB0b3ApO1xuICAgICAgfVxuXG4gICAgICBjb250cm9sUG9zZXMucHVzaCh7XG4gICAgICAgIGhvcml6b250YWw6IDAsXG4gICAgICAgIHZlcnRpY2FsOiBWRVJUSUNBTF9SQURJVVNfRElSRUNUSU9OU1tpXSxcbiAgICAgICAgcG9zOiBbeCwgeV1cbiAgICAgIH0pO1xuICAgICAgcG9zZXMucHVzaChbeCwgeV0pO1xuXG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNwbGl0UmFkaXVzUG9zZXMoY29udHJvbFBvc2VzLCByYXdzKSB7XG4gIGlmIChyYXdzID09PSB2b2lkIDApIHtcbiAgICByYXdzID0gY29udHJvbFBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgICByZXR1cm4gcG9zLnJhdztcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBob3Jpem9udGFscyA9IGNvbnRyb2xQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcywgaSkge1xuICAgIHJldHVybiBwb3MuaG9yaXpvbnRhbCA/IHJhd3NbaV0gOiBudWxsO1xuICB9KS5maWx0ZXIoZnVuY3Rpb24gKHBvcykge1xuICAgIHJldHVybiBwb3MgIT0gbnVsbDtcbiAgfSk7XG4gIHZhciB2ZXJ0aWNhbHMgPSBjb250cm9sUG9zZXMubWFwKGZ1bmN0aW9uIChwb3MsIGkpIHtcbiAgICByZXR1cm4gcG9zLnZlcnRpY2FsID8gcmF3c1tpXSA6IG51bGw7XG4gIH0pLmZpbHRlcihmdW5jdGlvbiAocG9zKSB7XG4gICAgcmV0dXJuIHBvcyAhPSBudWxsO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBob3Jpem9udGFsczogaG9yaXpvbnRhbHMsXG4gICAgdmVydGljYWxzOiB2ZXJ0aWNhbHNcbiAgfTtcbn1cblxudmFyIENMSVBfRElSRUNUSU9OUyA9IFtbMCwgLTEsIFwiblwiXSwgWzEsIDAsIFwiZVwiXV07XG52YXIgQ0xJUF9SRUNUX0RJUkVDVElPTlMgPSBbWy0xLCAtMSwgXCJud1wiXSwgWzAsIC0xLCBcIm5cIl0sIFsxLCAtMSwgXCJuZVwiXSwgWzEsIDAsIFwiZVwiXSwgWzEsIDEsIFwic2VcIl0sIFswLCAxLCBcInNcIl0sIFstMSwgMSwgXCJzd1wiXSwgWy0xLCAwLCBcIndcIl1dOyAvLyAxIDIgNSA2IDAgMyA0IDdcbi8vIDAgMSAyIDMgNCA1IDYgN1xuXG5mdW5jdGlvbiBnZXRDbGlwU3R5bGVzKG1vdmVhYmxlLCBjbGlwUGF0aCwgcG9zZXMpIHtcbiAgdmFyIGNsaXBSZWxhdGl2ZSA9IG1vdmVhYmxlLnByb3BzLmNsaXBSZWxhdGl2ZTtcbiAgdmFyIF9hID0gbW92ZWFibGUuc3RhdGUsXG4gICAgICB3aWR0aCA9IF9hLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xuICB2YXIgX2IgPSBjbGlwUGF0aCxcbiAgICAgIGNsaXBUeXBlID0gX2IudHlwZSxcbiAgICAgIGNsaXBQb3NlcyA9IF9iLnBvc2VzO1xuICB2YXIgaXNSZWN0ID0gY2xpcFR5cGUgPT09IFwicmVjdFwiO1xuICB2YXIgaXNDaXJjbGUgPSBjbGlwVHlwZSA9PT0gXCJjaXJjbGVcIjtcblxuICBpZiAoY2xpcFR5cGUgPT09IFwicG9seWdvblwiKSB7XG4gICAgcmV0dXJuIHBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgICByZXR1cm4gY29udmVydENTU1NpemUocG9zWzBdLCB3aWR0aCwgY2xpcFJlbGF0aXZlKSArIFwiIFwiICsgY29udmVydENTU1NpemUocG9zWzFdLCBoZWlnaHQsIGNsaXBSZWxhdGl2ZSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoaXNSZWN0IHx8IGNsaXBUeXBlID09PSBcImluc2V0XCIpIHtcbiAgICB2YXIgdG9wID0gcG9zZXNbMV1bMV07XG4gICAgdmFyIHJpZ2h0ID0gcG9zZXNbM11bMF07XG4gICAgdmFyIGxlZnQgPSBwb3Nlc1s3XVswXTtcbiAgICB2YXIgYm90dG9tID0gcG9zZXNbNV1bMV07XG5cbiAgICBpZiAoaXNSZWN0KSB7XG4gICAgICByZXR1cm4gW3RvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdF0ubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgcmV0dXJuIHBvcyArIFwicHhcIjtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBjbGlwU3R5bGVzID0gW3RvcCwgd2lkdGggLSByaWdodCwgaGVpZ2h0IC0gYm90dG9tLCBsZWZ0XS5tYXAoZnVuY3Rpb24gKHBvcywgaSkge1xuICAgICAgcmV0dXJuIGNvbnZlcnRDU1NTaXplKHBvcywgaSAlIDIgPyB3aWR0aCA6IGhlaWdodCwgY2xpcFJlbGF0aXZlKTtcbiAgICB9KTtcblxuICAgIGlmIChwb3Nlcy5sZW5ndGggPiA4KSB7XG4gICAgICB2YXIgX2MgPSBtaW51cyhwb3Nlc1s0XSwgcG9zZXNbMF0pLFxuICAgICAgICAgIHN1YldpZHRoID0gX2NbMF0sXG4gICAgICAgICAgc3ViSGVpZ2h0ID0gX2NbMV07XG5cbiAgICAgIGNsaXBTdHlsZXMucHVzaC5hcHBseShjbGlwU3R5bGVzLCBfX3NwcmVhZEFycmF5KFtcInJvdW5kXCJdLCBnZXRSYWRpdXNTdHlsZXMocG9zZXMuc2xpY2UoOCksIGNsaXBQb3Nlcy5zbGljZSg4KSwgY2xpcFJlbGF0aXZlLCBzdWJXaWR0aCwgc3ViSGVpZ2h0LCBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b20pLnN0eWxlcykpO1xuICAgIH1cblxuICAgIHJldHVybiBjbGlwU3R5bGVzO1xuICB9IGVsc2UgaWYgKGlzQ2lyY2xlIHx8IGNsaXBUeXBlID09PSBcImVsbGlwc2VcIikge1xuICAgIHZhciBjZW50ZXIgPSBwb3Nlc1swXTtcbiAgICB2YXIgcnkgPSBjb252ZXJ0Q1NTU2l6ZShNYXRoLmFicyhwb3Nlc1sxXVsxXSAtIGNlbnRlclsxXSksIGlzQ2lyY2xlID8gTWF0aC5zcXJ0KCh3aWR0aCAqIHdpZHRoICsgaGVpZ2h0ICogaGVpZ2h0KSAvIDIpIDogaGVpZ2h0LCBjbGlwUmVsYXRpdmUpO1xuICAgIHZhciBjbGlwU3R5bGVzID0gaXNDaXJjbGUgPyBbcnldIDogW2NvbnZlcnRDU1NTaXplKE1hdGguYWJzKHBvc2VzWzJdWzBdIC0gY2VudGVyWzBdKSwgd2lkdGgsIGNsaXBSZWxhdGl2ZSksIHJ5XTtcbiAgICBjbGlwU3R5bGVzLnB1c2goXCJhdFwiLCBjb252ZXJ0Q1NTU2l6ZShjZW50ZXJbMF0sIHdpZHRoLCBjbGlwUmVsYXRpdmUpLCBjb252ZXJ0Q1NTU2l6ZShjZW50ZXJbMV0sIGhlaWdodCwgY2xpcFJlbGF0aXZlKSk7XG4gICAgcmV0dXJuIGNsaXBTdHlsZXM7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UmVjdFBvc2VzKHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCkge1xuICB2YXIgeHMgPSBbbGVmdCwgKGxlZnQgKyByaWdodCkgLyAyLCByaWdodF07XG4gIHZhciB5cyA9IFt0b3AsICh0b3AgKyBib3R0b20pIC8gMiwgYm90dG9tXTtcbiAgcmV0dXJuIENMSVBfUkVDVF9ESVJFQ1RJT05TLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgZGlyeCA9IF9hWzBdLFxuICAgICAgICBkaXJ5ID0gX2FbMV0sXG4gICAgICAgIGRpciA9IF9hWzJdO1xuICAgIHZhciB4ID0geHNbZGlyeCArIDFdO1xuICAgIHZhciB5ID0geXNbZGlyeSArIDFdO1xuICAgIHJldHVybiB7XG4gICAgICB2ZXJ0aWNhbDogTWF0aC5hYnMoZGlyeSksXG4gICAgICBob3Jpem9udGFsOiBNYXRoLmFicyhkaXJ4KSxcbiAgICAgIGRpcmVjdGlvbjogZGlyLFxuICAgICAgcG9zOiBbeCwgeV1cbiAgICB9O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2xpcFBhdGgodGFyZ2V0LCB3aWR0aCwgaGVpZ2h0LCBkZWZhdWx0Q2xpcCwgY3VzdG9tQ2xpcCkge1xuICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XG5cbiAgdmFyIGNsaXBUZXh0ID0gY3VzdG9tQ2xpcDtcblxuICBpZiAoIWNsaXBUZXh0KSB7XG4gICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpO1xuICAgIHZhciBjbGlwUGF0aCA9IHN0eWxlLmNsaXBQYXRoO1xuICAgIGNsaXBUZXh0ID0gY2xpcFBhdGggIT09IFwibm9uZVwiID8gY2xpcFBhdGggOiBzdHlsZS5jbGlwO1xuICB9XG5cbiAgaWYgKCFjbGlwVGV4dCB8fCBjbGlwVGV4dCA9PT0gXCJub25lXCIgfHwgY2xpcFRleHQgPT09IFwiYXV0b1wiKSB7XG4gICAgY2xpcFRleHQgPSBkZWZhdWx0Q2xpcDtcblxuICAgIGlmICghY2xpcFRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICB2YXIgX2ggPSBzcGxpdEJyYWNrZXQoY2xpcFRleHQpLFxuICAgICAgX2ogPSBfaC5wcmVmaXgsXG4gICAgICBjbGlwUHJlZml4ID0gX2ogPT09IHZvaWQgMCA/IGNsaXBUZXh0IDogX2osXG4gICAgICBfayA9IF9oLnZhbHVlLFxuICAgICAgdmFsdWUgPSBfayA9PT0gdm9pZCAwID8gXCJcIiA6IF9rO1xuXG4gIHZhciBpc0NpcmNsZSA9IGNsaXBQcmVmaXggPT09IFwiY2lyY2xlXCI7XG4gIHZhciBzcGxpdHRlciA9IFwiIFwiO1xuXG4gIGlmIChjbGlwUHJlZml4ID09PSBcInBvbHlnb25cIikge1xuICAgIHZhciB2YWx1ZXMgPSBzcGxpdENvbW1hKHZhbHVlIHx8IFwiMCUgMCUsIDEwMCUgMCUsIDEwMCUgMTAwJSwgMCUgMTAwJVwiKTtcbiAgICBzcGxpdHRlciA9IFwiLFwiO1xuICAgIHZhciBwb3NlcyA9IHZhbHVlcy5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgICAgdmFyIF9hID0gcG9zLnNwbGl0KFwiIFwiKSxcbiAgICAgICAgICB4UG9zID0gX2FbMF0sXG4gICAgICAgICAgeVBvcyA9IF9hWzFdO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB2ZXJ0aWNhbDogMSxcbiAgICAgICAgaG9yaXpvbnRhbDogMSxcbiAgICAgICAgcG9zOiBbY29udmVydFVuaXRTaXplKHhQb3MsIHdpZHRoKSwgY29udmVydFVuaXRTaXplKHlQb3MsIGhlaWdodCldXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBjbGlwUHJlZml4LFxuICAgICAgY2xpcFRleHQ6IGNsaXBUZXh0LFxuICAgICAgcG9zZXM6IHBvc2VzLFxuICAgICAgc3BsaXR0ZXI6IHNwbGl0dGVyXG4gICAgfTtcbiAgfSBlbHNlIGlmIChpc0NpcmNsZSB8fCBjbGlwUHJlZml4ID09PSBcImVsbGlwc2VcIikge1xuICAgIHZhciB4UG9zID0gXCJcIjtcbiAgICB2YXIgeVBvcyA9IFwiXCI7XG4gICAgdmFyIHJhZGl1c1hfMSA9IDA7XG4gICAgdmFyIHJhZGl1c1lfMSA9IDA7XG4gICAgdmFyIHZhbHVlcyA9IHNwbGl0U3BhY2UodmFsdWUpO1xuXG4gICAgaWYgKGlzQ2lyY2xlKSB7XG4gICAgICB2YXIgcmFkaXVzID0gXCJcIjtcbiAgICAgIF9hID0gdmFsdWVzWzBdLCByYWRpdXMgPSBfYSA9PT0gdm9pZCAwID8gXCI1MCVcIiA6IF9hLCBfYiA9IHZhbHVlc1syXSwgeFBvcyA9IF9iID09PSB2b2lkIDAgPyBcIjUwJVwiIDogX2IsIF9jID0gdmFsdWVzWzNdLCB5UG9zID0gX2MgPT09IHZvaWQgMCA/IFwiNTAlXCIgOiBfYztcbiAgICAgIHJhZGl1c1hfMSA9IGNvbnZlcnRVbml0U2l6ZShyYWRpdXMsIE1hdGguc3FydCgod2lkdGggKiB3aWR0aCArIGhlaWdodCAqIGhlaWdodCkgLyAyKSk7XG4gICAgICByYWRpdXNZXzEgPSByYWRpdXNYXzE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB4UmFkaXVzID0gXCJcIjtcbiAgICAgIHZhciB5UmFkaXVzID0gXCJcIjtcbiAgICAgIF9kID0gdmFsdWVzWzBdLCB4UmFkaXVzID0gX2QgPT09IHZvaWQgMCA/IFwiNTAlXCIgOiBfZCwgX2UgPSB2YWx1ZXNbMV0sIHlSYWRpdXMgPSBfZSA9PT0gdm9pZCAwID8gXCI1MCVcIiA6IF9lLCBfZiA9IHZhbHVlc1szXSwgeFBvcyA9IF9mID09PSB2b2lkIDAgPyBcIjUwJVwiIDogX2YsIF9nID0gdmFsdWVzWzRdLCB5UG9zID0gX2cgPT09IHZvaWQgMCA/IFwiNTAlXCIgOiBfZztcbiAgICAgIHJhZGl1c1hfMSA9IGNvbnZlcnRVbml0U2l6ZSh4UmFkaXVzLCB3aWR0aCk7XG4gICAgICByYWRpdXNZXzEgPSBjb252ZXJ0VW5pdFNpemUoeVJhZGl1cywgaGVpZ2h0KTtcbiAgICB9XG5cbiAgICB2YXIgY2VudGVyUG9zXzEgPSBbY29udmVydFVuaXRTaXplKHhQb3MsIHdpZHRoKSwgY29udmVydFVuaXRTaXplKHlQb3MsIGhlaWdodCldO1xuXG4gICAgdmFyIHBvc2VzID0gX19zcHJlYWRBcnJheShbe1xuICAgICAgdmVydGljYWw6IDEsXG4gICAgICBob3Jpem9udGFsOiAxLFxuICAgICAgcG9zOiBjZW50ZXJQb3NfMSxcbiAgICAgIGRpcmVjdGlvbjogXCJuZXN3XCJcbiAgICB9XSwgQ0xJUF9ESVJFQ1RJT05TLnNsaWNlKDAsIGlzQ2lyY2xlID8gMSA6IDIpLm1hcChmdW5jdGlvbiAoZGlyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2ZXJ0aWNhbDogTWF0aC5hYnMoZGlyWzFdKSxcbiAgICAgICAgaG9yaXpvbnRhbDogZGlyWzBdLFxuICAgICAgICBkaXJlY3Rpb246IGRpclsyXSxcbiAgICAgICAgc3ViOiB0cnVlLFxuICAgICAgICBwb3M6IFtjZW50ZXJQb3NfMVswXSArIGRpclswXSAqIHJhZGl1c1hfMSwgY2VudGVyUG9zXzFbMV0gKyBkaXJbMV0gKiByYWRpdXNZXzFdXG4gICAgICB9O1xuICAgIH0pKTtcblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBjbGlwUHJlZml4LFxuICAgICAgY2xpcFRleHQ6IGNsaXBUZXh0LFxuICAgICAgcmFkaXVzWDogcmFkaXVzWF8xLFxuICAgICAgcmFkaXVzWTogcmFkaXVzWV8xLFxuICAgICAgbGVmdDogY2VudGVyUG9zXzFbMF0gLSByYWRpdXNYXzEsXG4gICAgICB0b3A6IGNlbnRlclBvc18xWzFdIC0gcmFkaXVzWV8xLFxuICAgICAgcG9zZXM6IHBvc2VzLFxuICAgICAgc3BsaXR0ZXI6IHNwbGl0dGVyXG4gICAgfTtcbiAgfSBlbHNlIGlmIChjbGlwUHJlZml4ID09PSBcImluc2V0XCIpIHtcbiAgICB2YXIgdmFsdWVzID0gc3BsaXRTcGFjZSh2YWx1ZSB8fCBcIjAgMCAwIDBcIik7XG4gICAgdmFyIHJvdW5kSW5kZXggPSB2YWx1ZXMuaW5kZXhPZihcInJvdW5kXCIpO1xuICAgIHZhciByZWN0TGVuZ3RoID0gKHJvdW5kSW5kZXggPiAtMSA/IHZhbHVlcy5zbGljZSgwLCByb3VuZEluZGV4KSA6IHZhbHVlcykubGVuZ3RoO1xuICAgIHZhciByYWRpdXNWYWx1ZXMgPSB2YWx1ZXMuc2xpY2UocmVjdExlbmd0aCArIDEpO1xuXG4gICAgdmFyIF9sID0gdmFsdWVzLnNsaWNlKDAsIHJlY3RMZW5ndGgpLFxuICAgICAgICB0b3BWYWx1ZSA9IF9sWzBdLFxuICAgICAgICBfbSA9IF9sWzFdLFxuICAgICAgICByaWdodFZhbHVlID0gX20gPT09IHZvaWQgMCA/IHRvcFZhbHVlIDogX20sXG4gICAgICAgIF9vID0gX2xbMl0sXG4gICAgICAgIGJvdHRvbVZhbHVlID0gX28gPT09IHZvaWQgMCA/IHRvcFZhbHVlIDogX28sXG4gICAgICAgIF9wID0gX2xbM10sXG4gICAgICAgIGxlZnRWYWx1ZSA9IF9wID09PSB2b2lkIDAgPyByaWdodFZhbHVlIDogX3A7XG5cbiAgICB2YXIgX3EgPSBbdG9wVmFsdWUsIGJvdHRvbVZhbHVlXS5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgICAgcmV0dXJuIGNvbnZlcnRVbml0U2l6ZShwb3MsIGhlaWdodCk7XG4gICAgfSksXG4gICAgICAgIHRvcCA9IF9xWzBdLFxuICAgICAgICBib3R0b20gPSBfcVsxXTtcblxuICAgIHZhciBfciA9IFtsZWZ0VmFsdWUsIHJpZ2h0VmFsdWVdLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgICByZXR1cm4gY29udmVydFVuaXRTaXplKHBvcywgd2lkdGgpO1xuICAgIH0pLFxuICAgICAgICBsZWZ0ID0gX3JbMF0sXG4gICAgICAgIHJpZ2h0ID0gX3JbMV07XG5cbiAgICB2YXIgbmV4dFJpZ2h0ID0gd2lkdGggLSByaWdodDtcbiAgICB2YXIgbmV4dEJvdHRvbSA9IGhlaWdodCAtIGJvdHRvbTtcbiAgICB2YXIgcmFkaXVzUG9zZXMgPSBnZXRSYWRpdXNWYWx1ZXMocmFkaXVzVmFsdWVzLCBuZXh0UmlnaHQgLSBsZWZ0LCBuZXh0Qm90dG9tIC0gdG9wLCBsZWZ0LCB0b3ApO1xuXG4gICAgdmFyIHBvc2VzID0gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBnZXRSZWN0UG9zZXModG9wLCBuZXh0UmlnaHQsIG5leHRCb3R0b20sIGxlZnQpKSwgcmFkaXVzUG9zZXMpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaW5zZXRcIixcbiAgICAgIGNsaXBUZXh0OiBjbGlwVGV4dCxcbiAgICAgIHBvc2VzOiBwb3NlcyxcbiAgICAgIHRvcDogdG9wLFxuICAgICAgbGVmdDogbGVmdCxcbiAgICAgIHJpZ2h0OiBuZXh0UmlnaHQsXG4gICAgICBib3R0b206IG5leHRCb3R0b20sXG4gICAgICByYWRpdXM6IHJhZGl1c1ZhbHVlcyxcbiAgICAgIHNwbGl0dGVyOiBzcGxpdHRlclxuICAgIH07XG4gIH0gZWxzZSBpZiAoY2xpcFByZWZpeCA9PT0gXCJyZWN0XCIpIHtcbiAgICAvLyB0b3AgcmlnaHQgYm90dG9tIGxlZnRcbiAgICB2YXIgdmFsdWVzID0gc3BsaXRDb21tYSh2YWx1ZSB8fCBcIjBweCwgXCIgKyB3aWR0aCArIFwicHgsIFwiICsgaGVpZ2h0ICsgXCJweCwgMHB4XCIpO1xuICAgIHNwbGl0dGVyID0gXCIsXCI7XG5cbiAgICB2YXIgX3MgPSB2YWx1ZXMubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgIHZhciBwb3NWYWx1ZSA9IHNwbGl0VW5pdChwb3MpLnZhbHVlO1xuICAgICAgcmV0dXJuIHBvc1ZhbHVlO1xuICAgIH0pLFxuICAgICAgICB0b3AgPSBfc1swXSxcbiAgICAgICAgcmlnaHQgPSBfc1sxXSxcbiAgICAgICAgYm90dG9tID0gX3NbMl0sXG4gICAgICAgIGxlZnQgPSBfc1szXTtcblxuICAgIHZhciBwb3NlcyA9IGdldFJlY3RQb3Nlcyh0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInJlY3RcIixcbiAgICAgIGNsaXBUZXh0OiBjbGlwVGV4dCxcbiAgICAgIHBvc2VzOiBwb3NlcyxcbiAgICAgIHRvcDogdG9wLFxuICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgYm90dG9tOiBib3R0b20sXG4gICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICBzcGxpdHRlcjogc3BsaXR0ZXJcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuO1xufVxuXG5mdW5jdGlvbiBhZGRDbGlwUGF0aChtb3ZlYWJsZSwgZSkge1xuICB2YXIgX2EgPSBjYWxjdWxhdGVQb2ludGVyRGlzdChtb3ZlYWJsZSwgZSksXG4gICAgICBkaXN0WCA9IF9hWzBdLFxuICAgICAgZGlzdFkgPSBfYVsxXTtcblxuICB2YXIgX2IgPSBlLmRhdGFzLFxuICAgICAgY2xpcFBhdGggPSBfYi5jbGlwUGF0aCxcbiAgICAgIGluZGV4ID0gX2IuaW5kZXg7XG4gIHZhciBfYyA9IGNsaXBQYXRoLFxuICAgICAgY2xpcFR5cGUgPSBfYy50eXBlLFxuICAgICAgY2xpcFBvc2VzID0gX2MucG9zZXMsXG4gICAgICBzcGxpdHRlciA9IF9jLnNwbGl0dGVyO1xuICB2YXIgcG9zZXMgPSBjbGlwUG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICByZXR1cm4gcG9zLnBvcztcbiAgfSk7XG5cbiAgaWYgKGNsaXBUeXBlID09PSBcInBvbHlnb25cIikge1xuICAgIHBvc2VzLnNwbGljZShpbmRleCwgMCwgW2Rpc3RYLCBkaXN0WV0pO1xuICB9IGVsc2UgaWYgKGNsaXBUeXBlID09PSBcImluc2V0XCIpIHtcbiAgICB2YXIgaG9yaXpvbnRhbEluZGV4ID0gSE9SSVpPTlRBTF9SQURJVVNfT1JERVIuaW5kZXhPZihpbmRleCk7XG4gICAgdmFyIHZlcnRpY2FsSW5kZXggPSBWRVJUSUNBTF9SQURJVVNfT1JERVIuaW5kZXhPZihpbmRleCk7XG4gICAgdmFyIGxlbmd0aCA9IGNsaXBQb3Nlcy5sZW5ndGg7XG4gICAgYWRkUmFkaXVzUG9zKGNsaXBQb3NlcywgcG9zZXMsIDgsIGhvcml6b250YWxJbmRleCwgdmVydGljYWxJbmRleCwgZGlzdFgsIGRpc3RZLCBwb3Nlc1s0XVswXSwgcG9zZXNbNF1bMV0sIHBvc2VzWzBdWzBdLCBwb3Nlc1swXVsxXSk7XG5cbiAgICBpZiAobGVuZ3RoID09PSBjbGlwUG9zZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjbGlwU3R5bGVzID0gZ2V0Q2xpcFN0eWxlcyhtb3ZlYWJsZSwgY2xpcFBhdGgsIHBvc2VzKTtcbiAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uQ2xpcFwiLCBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCB7XG4gICAgY2xpcEV2ZW50VHlwZTogXCJhZGRlZFwiLFxuICAgIGNsaXBUeXBlOiBjbGlwVHlwZSxcbiAgICBwb3NlczogcG9zZXMsXG4gICAgY2xpcFN0eWxlczogY2xpcFN0eWxlcyxcbiAgICBjbGlwU3R5bGU6IGNsaXBUeXBlICsgXCIoXCIgKyBjbGlwU3R5bGVzLmpvaW4oc3BsaXR0ZXIpICsgXCIpXCIsXG4gICAgZGlzdFg6IDAsXG4gICAgZGlzdFk6IDBcbiAgfSkpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVDbGlwUGF0aChtb3ZlYWJsZSwgZSkge1xuICB2YXIgX2EgPSBlLmRhdGFzLFxuICAgICAgY2xpcFBhdGggPSBfYS5jbGlwUGF0aCxcbiAgICAgIGluZGV4ID0gX2EuaW5kZXg7XG4gIHZhciBfYiA9IGNsaXBQYXRoLFxuICAgICAgY2xpcFR5cGUgPSBfYi50eXBlLFxuICAgICAgY2xpcFBvc2VzID0gX2IucG9zZXMsXG4gICAgICBzcGxpdHRlciA9IF9iLnNwbGl0dGVyO1xuICB2YXIgcG9zZXMgPSBjbGlwUG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICByZXR1cm4gcG9zLnBvcztcbiAgfSk7XG4gIHZhciBsZW5ndGggPSBwb3Nlcy5sZW5ndGg7XG5cbiAgaWYgKGNsaXBUeXBlID09PSBcInBvbHlnb25cIikge1xuICAgIGNsaXBQb3Nlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHBvc2VzLnNwbGljZShpbmRleCwgMSk7XG4gIH0gZWxzZSBpZiAoY2xpcFR5cGUgPT09IFwiaW5zZXRcIikge1xuICAgIGlmIChpbmRleCA8IDgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZW1vdmVSYWRpdXNQb3MoY2xpcFBvc2VzLCBwb3NlcywgaW5kZXgsIDgsIGxlbmd0aCk7XG5cbiAgICBpZiAobGVuZ3RoID09PSBjbGlwUG9zZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjbGlwU3R5bGVzID0gZ2V0Q2xpcFN0eWxlcyhtb3ZlYWJsZSwgY2xpcFBhdGgsIHBvc2VzKTtcbiAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uQ2xpcFwiLCBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCB7XG4gICAgY2xpcEV2ZW50VHlwZTogXCJyZW1vdmVkXCIsXG4gICAgY2xpcFR5cGU6IGNsaXBUeXBlLFxuICAgIHBvc2VzOiBwb3NlcyxcbiAgICBjbGlwU3R5bGVzOiBjbGlwU3R5bGVzLFxuICAgIGNsaXBTdHlsZTogY2xpcFR5cGUgKyBcIihcIiArIGNsaXBTdHlsZXMuam9pbihzcGxpdHRlcikgKyBcIilcIixcbiAgICBkaXN0WDogMCxcbiAgICBkaXN0WTogMFxuICB9KSk7XG59XG4vKipcbiAqIEBuYW1lc3BhY2UgTW92ZWFibGUuQ2xpcHBhYmxlXG4gKiBAZGVzY3JpcHRpb24gV2hldGhlciB0byBjbGlwIHRoZSB0YXJnZXQuXG4gKi9cblxuXG52YXIgQ2xpcHBhYmxlID0ge1xuICBuYW1lOiBcImNsaXBwYWJsZVwiLFxuICBwcm9wczoge1xuICAgIGNsaXBwYWJsZTogQm9vbGVhbixcbiAgICBkZWZhdWx0Q2xpcFBhdGg6IFN0cmluZyxcbiAgICBjdXN0b21DbGlwUGF0aDogU3RyaW5nLFxuICAgIGNsaXBSZWxhdGl2ZTogQm9vbGVhbixcbiAgICBjbGlwQXJlYTogQm9vbGVhbixcbiAgICBkcmFnV2l0aENsaXA6IEJvb2xlYW4sXG4gICAgY2xpcFRhcmdldEJvdW5kczogQm9vbGVhbixcbiAgICBjbGlwVmVydGljYWxHdWlkZWxpbmVzOiBBcnJheSxcbiAgICBjbGlwSG9yaXpvbnRhbEd1aWRlbGluZXM6IEFycmF5LFxuICAgIGNsaXBTbmFwVGhyZXNob2xkOiBCb29sZWFuXG4gIH0sXG4gIGV2ZW50czoge1xuICAgIG9uQ2xpcFN0YXJ0OiBcImNsaXBTdGFydFwiLFxuICAgIG9uQ2xpcDogXCJjbGlwXCIsXG4gICAgb25DbGlwRW5kOiBcImNsaXBFbmRcIlxuICB9LFxuICBjc3M6IFtcIi5jb250cm9sLmNsaXAtY29udHJvbCB7XFxuICAgIGJhY2tncm91bmQ6ICM2ZDY7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuLmNvbnRyb2wuY2xpcC1jb250cm9sLmNsaXAtcmFkaXVzIHtcXG4gICAgYmFja2dyb3VuZDogI2Q2NjtcXG59XFxuLmxpbmUuY2xpcC1saW5lIHtcXG4gICAgYmFja2dyb3VuZDogIzZlNjtcXG4gICAgY3Vyc29yOiBtb3ZlO1xcbiAgICB6LWluZGV4OiAxO1xcbn1cXG4uY2xpcC1hcmVhIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB0b3A6IDA7XFxuICAgIGxlZnQ6IDA7XFxufVxcbi5jbGlwLWVsbGlwc2Uge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIGN1cnNvcjogbW92ZTtcXG4gICAgYm9yZGVyOiAxcHggc29saWQgIzZkNjtcXG4gICAgYm9yZGVyOiB2YXIoLS16b29tcHgpIHNvbGlkICM2ZDY7XFxuICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcXG4gICAgdHJhbnNmb3JtLW9yaWdpbjogMHB4IDBweDtcXG59XCIsIFwiOmhvc3Qge1xcbiAgICAtLWJvdW5kcy1jb2xvcjogI2Q2NjtcXG59XCIsIFwiLmd1aWRlbGluZSB7XFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbiAgICB6LWluZGV4OiAyO1xcbn1cIiwgXCIubGluZS5ndWlkZWxpbmUuYm91bmRzIHtcXG4gICAgYmFja2dyb3VuZDogI2Q2NjtcXG4gICAgYmFja2dyb3VuZDogdmFyKC0tYm91bmRzLWNvbG9yKTtcXG59XCJdLFxuICByZW5kZXI6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgUmVhY3QpIHtcbiAgICB2YXIgX2EgPSBtb3ZlYWJsZS5wcm9wcyxcbiAgICAgICAgY3VzdG9tQ2xpcFBhdGggPSBfYS5jdXN0b21DbGlwUGF0aCxcbiAgICAgICAgZGVmYXVsdENsaXBQYXRoID0gX2EuZGVmYXVsdENsaXBQYXRoLFxuICAgICAgICBjbGlwQXJlYSA9IF9hLmNsaXBBcmVhLFxuICAgICAgICB6b29tID0gX2Euem9vbTtcbiAgICB2YXIgX2IgPSBtb3ZlYWJsZS5zdGF0ZSxcbiAgICAgICAgdGFyZ2V0ID0gX2IudGFyZ2V0LFxuICAgICAgICB3aWR0aCA9IF9iLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfYi5oZWlnaHQsXG4gICAgICAgIGFsbE1hdHJpeCA9IF9iLmFsbE1hdHJpeCxcbiAgICAgICAgaXMzZCA9IF9iLmlzM2QsXG4gICAgICAgIGxlZnQgPSBfYi5sZWZ0LFxuICAgICAgICB0b3AgPSBfYi50b3AsXG4gICAgICAgIHBvczEgPSBfYi5wb3MxLFxuICAgICAgICBwb3MyID0gX2IucG9zMixcbiAgICAgICAgcG9zMyA9IF9iLnBvczMsXG4gICAgICAgIHBvczQgPSBfYi5wb3M0LFxuICAgICAgICBjbGlwUGF0aFN0YXRlID0gX2IuY2xpcFBhdGhTdGF0ZSxcbiAgICAgICAgc25hcEJvdW5kSW5mb3MgPSBfYi5zbmFwQm91bmRJbmZvcyxcbiAgICAgICAgcm90YXRpb25SYWQgPSBfYi5yb3RhdGlvbjtcblxuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIGNsaXBQYXRoID0gZ2V0Q2xpcFBhdGgodGFyZ2V0LCB3aWR0aCwgaGVpZ2h0LCBkZWZhdWx0Q2xpcFBhdGggfHwgXCJpbnNldFwiLCBjbGlwUGF0aFN0YXRlIHx8IGN1c3RvbUNsaXBQYXRoKTtcblxuICAgIGlmICghY2xpcFBhdGgpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB2YXIgbiA9IGlzM2QgPyA0IDogMztcbiAgICB2YXIgdHlwZSA9IGNsaXBQYXRoLnR5cGU7XG4gICAgdmFyIGNsaXBQb3NlcyA9IGNsaXBQYXRoLnBvc2VzO1xuICAgIHZhciBwb3NlcyA9IGNsaXBQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgICAgLy8gcmV0dXJuIFt4LCB5XTtcbiAgICAgIHZhciBjYWxjdWxhdGVkUG9zID0gY2FsY3VsYXRlUG9zaXRpb24oYWxsTWF0cml4LCBwb3MucG9zLCBuKTtcbiAgICAgIHJldHVybiBbY2FsY3VsYXRlZFBvc1swXSAtIGxlZnQsIGNhbGN1bGF0ZWRQb3NbMV0gLSB0b3BdO1xuICAgIH0pO1xuICAgIHZhciBjb250cm9scyA9IFtdO1xuICAgIHZhciBsaW5lcyA9IFtdO1xuICAgIHZhciBpc1JlY3QgPSB0eXBlID09PSBcInJlY3RcIjtcbiAgICB2YXIgaXNJbnNldCA9IHR5cGUgPT09IFwiaW5zZXRcIjtcbiAgICB2YXIgaXNQb2x5Z29uID0gdHlwZSA9PT0gXCJwb2x5Z29uXCI7XG5cbiAgICBpZiAoaXNSZWN0IHx8IGlzSW5zZXQgfHwgaXNQb2x5Z29uKSB7XG4gICAgICB2YXIgbGluZVBvc2VzXzEgPSBpc0luc2V0ID8gcG9zZXMuc2xpY2UoMCwgOCkgOiBwb3NlcztcbiAgICAgIGxpbmVzID0gbGluZVBvc2VzXzEubWFwKGZ1bmN0aW9uICh0bywgaSkge1xuICAgICAgICB2YXIgZnJvbSA9IGkgPT09IDAgPyBsaW5lUG9zZXNfMVtsaW5lUG9zZXNfMS5sZW5ndGggLSAxXSA6IGxpbmVQb3Nlc18xW2kgLSAxXTtcbiAgICAgICAgdmFyIHJhZCA9IGdldFJhZChmcm9tLCB0byk7XG4gICAgICAgIHZhciBkaXN0ID0gZ2V0RGlhZ29uYWxTaXplKGZyb20sIHRvKTtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICAgIGtleTogXCJjbGlwTGluZVwiICsgaSxcbiAgICAgICAgICBjbGFzc05hbWU6IHByZWZpeChcImxpbmVcIiwgXCJjbGlwLWxpbmVcIiwgXCJzbmFwLWNvbnRyb2xcIiksXG4gICAgICAgICAgXCJkYXRhLWNsaXAtaW5kZXhcIjogaSxcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgd2lkdGg6IGRpc3QgKyBcInB4XCIsXG4gICAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKFwiICsgZnJvbVswXSArIFwicHgsIFwiICsgZnJvbVsxXSArIFwicHgpIHJvdGF0ZShcIiArIHJhZCArIFwicmFkKSBzY2FsZVkoXCIgKyB6b29tICsgXCIpXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29udHJvbHMgPSBwb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcywgaSkge1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBrZXk6IFwiY2xpcENvbnRyb2xcIiArIGksXG4gICAgICAgIGNsYXNzTmFtZTogcHJlZml4KFwiY29udHJvbFwiLCBcImNsaXAtY29udHJvbFwiLCBcInNuYXAtY29udHJvbFwiKSxcbiAgICAgICAgXCJkYXRhLWNsaXAtaW5kZXhcIjogaSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKFwiICsgcG9zWzBdICsgXCJweCwgXCIgKyBwb3NbMV0gKyBcInB4KSByb3RhdGUoXCIgKyByb3RhdGlvblJhZCArIFwicmFkKSBzY2FsZShcIiArIHpvb20gKyBcIilcIlxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGlmIChpc0luc2V0KSB7XG4gICAgICBjb250cm9scy5wdXNoLmFwcGx5KGNvbnRyb2xzLCBwb3Nlcy5zbGljZSg4KS5tYXAoZnVuY3Rpb24gKHBvcywgaSkge1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgICAga2V5OiBcImNsaXBSYWRpdXNDb250cm9sXCIgKyBpLFxuICAgICAgICAgIGNsYXNzTmFtZTogcHJlZml4KFwiY29udHJvbFwiLCBcImNsaXAtY29udHJvbFwiLCBcImNsaXAtcmFkaXVzXCIsIFwic25hcC1jb250cm9sXCIpLFxuICAgICAgICAgIFwiZGF0YS1jbGlwLWluZGV4XCI6IDggKyBpLFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKFwiICsgcG9zWzBdICsgXCJweCwgXCIgKyBwb3NbMV0gKyBcInB4KSByb3RhdGUoXCIgKyByb3RhdGlvblJhZCArIFwicmFkKSBzY2FsZShcIiArIHpvb20gKyBcIilcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09IFwiY2lyY2xlXCIgfHwgdHlwZSA9PT0gXCJlbGxpcHNlXCIpIHtcbiAgICAgIHZhciBjbGlwTGVmdCA9IGNsaXBQYXRoLmxlZnQsXG4gICAgICAgICAgY2xpcFRvcCA9IGNsaXBQYXRoLnRvcCxcbiAgICAgICAgICByYWRpdXNYID0gY2xpcFBhdGgucmFkaXVzWCxcbiAgICAgICAgICByYWRpdXNZID0gY2xpcFBhdGgucmFkaXVzWTtcblxuICAgICAgdmFyIF9jID0gbWludXMoY2FsY3VsYXRlUG9zaXRpb24oYWxsTWF0cml4LCBbY2xpcExlZnQsIGNsaXBUb3BdLCBuKSwgY2FsY3VsYXRlUG9zaXRpb24oYWxsTWF0cml4LCBbMCwgMF0sIG4pKSxcbiAgICAgICAgICBkaXN0TGVmdCA9IF9jWzBdLFxuICAgICAgICAgIGRpc3RUb3AgPSBfY1sxXTtcblxuICAgICAgdmFyIGVsbGlwc2VDbGlwUGF0aCA9IFwibm9uZVwiO1xuXG4gICAgICBpZiAoIWNsaXBBcmVhKSB7XG4gICAgICAgIHZhciBwaWVjZSA9IE1hdGgubWF4KDEwLCByYWRpdXNYIC8gNSwgcmFkaXVzWSAvIDUpO1xuICAgICAgICB2YXIgYXJlYVBvc2VzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gcGllY2U7ICsraSkge1xuICAgICAgICAgIHZhciByYWQgPSBNYXRoLlBJICogMiAvIHBpZWNlICogaTtcbiAgICAgICAgICBhcmVhUG9zZXMucHVzaChbcmFkaXVzWCArIChyYWRpdXNYIC0gem9vbSkgKiBNYXRoLmNvcyhyYWQpLCByYWRpdXNZICsgKHJhZGl1c1kgLSB6b29tKSAqIE1hdGguc2luKHJhZCldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFyZWFQb3Nlcy5wdXNoKFtyYWRpdXNYLCAtMl0pO1xuICAgICAgICBhcmVhUG9zZXMucHVzaChbLTIsIC0yXSk7XG4gICAgICAgIGFyZWFQb3Nlcy5wdXNoKFstMiwgcmFkaXVzWSAqIDIgKyAyXSk7XG4gICAgICAgIGFyZWFQb3Nlcy5wdXNoKFtyYWRpdXNYICogMiArIDIsIHJhZGl1c1kgKiAyICsgMl0pO1xuICAgICAgICBhcmVhUG9zZXMucHVzaChbcmFkaXVzWCAqIDIgKyAyLCAtMl0pO1xuICAgICAgICBhcmVhUG9zZXMucHVzaChbcmFkaXVzWCwgLTJdKTtcbiAgICAgICAgZWxsaXBzZUNsaXBQYXRoID0gXCJwb2x5Z29uKFwiICsgYXJlYVBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgICAgcmV0dXJuIHBvc1swXSArIFwicHggXCIgKyBwb3NbMV0gKyBcInB4XCI7XG4gICAgICAgIH0pLmpvaW4oXCIsIFwiKSArIFwiKVwiO1xuICAgICAgfVxuXG4gICAgICBjb250cm9scy5wdXNoKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBrZXk6IFwiY2xpcEVsbGlwc2VcIixcbiAgICAgICAgY2xhc3NOYW1lOiBwcmVmaXgoXCJjbGlwLWVsbGlwc2VcIiwgXCJzbmFwLWNvbnRyb2xcIiksXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgd2lkdGg6IHJhZGl1c1ggKiAyICsgXCJweFwiLFxuICAgICAgICAgIGhlaWdodDogcmFkaXVzWSAqIDIgKyBcInB4XCIsXG4gICAgICAgICAgY2xpcFBhdGg6IGVsbGlwc2VDbGlwUGF0aCxcbiAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKFwiICsgKC1sZWZ0ICsgZGlzdExlZnQpICsgXCJweCwgXCIgKyAoLXRvcCArIGRpc3RUb3ApICsgXCJweCkgXCIgKyBtYWtlTWF0cml4Q1NTKGFsbE1hdHJpeClcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIGlmIChjbGlwQXJlYSkge1xuICAgICAgdmFyIF9kID0gZ2V0UmVjdChfX3NwcmVhZEFycmF5KFtwb3MxLCBwb3MyLCBwb3MzLCBwb3M0XSwgcG9zZXMpKSxcbiAgICAgICAgICBhbGxXaWR0aCA9IF9kLndpZHRoLFxuICAgICAgICAgIGFsbEhlaWdodCA9IF9kLmhlaWdodCxcbiAgICAgICAgICBhbGxMZWZ0XzEgPSBfZC5sZWZ0LFxuICAgICAgICAgIGFsbFRvcF8xID0gX2QudG9wO1xuXG4gICAgICBpZiAoaXNQb2x5Z29uIHx8IGlzUmVjdCB8fCBpc0luc2V0KSB7XG4gICAgICAgIHZhciBhcmVhUG9zZXMgPSBpc0luc2V0ID8gcG9zZXMuc2xpY2UoMCwgOCkgOiBwb3NlcztcbiAgICAgICAgY29udHJvbHMucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgICBrZXk6IFwiY2xpcEFyZWFcIixcbiAgICAgICAgICBjbGFzc05hbWU6IHByZWZpeChcImNsaXAtYXJlYVwiLCBcInNuYXAtY29udHJvbFwiKSxcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgd2lkdGg6IGFsbFdpZHRoICsgXCJweFwiLFxuICAgICAgICAgICAgaGVpZ2h0OiBhbGxIZWlnaHQgKyBcInB4XCIsXG4gICAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKFwiICsgYWxsTGVmdF8xICsgXCJweCwgXCIgKyBhbGxUb3BfMSArIFwicHgpXCIsXG4gICAgICAgICAgICBjbGlwUGF0aDogXCJwb2x5Z29uKFwiICsgYXJlYVBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwb3NbMF0gLSBhbGxMZWZ0XzEgKyBcInB4IFwiICsgKHBvc1sxXSAtIGFsbFRvcF8xKSArIFwicHhcIjtcbiAgICAgICAgICAgIH0pLmpvaW4oXCIsIFwiKSArIFwiKVwiXG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNuYXBCb3VuZEluZm9zKSB7XG4gICAgICBbXCJ2ZXJ0aWNhbFwiLCBcImhvcml6b250YWxcIl0uZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aW9uVHlwZSkge1xuICAgICAgICB2YXIgaW5mbyA9IHNuYXBCb3VuZEluZm9zW2RpcmVjdGlvblR5cGVdO1xuICAgICAgICB2YXIgaXNIb3Jpem9udGFsID0gZGlyZWN0aW9uVHlwZSA9PT0gXCJob3Jpem9udGFsXCI7XG5cbiAgICAgICAgaWYgKGluZm8uaXNTbmFwKSB7XG4gICAgICAgICAgbGluZXMucHVzaC5hcHBseShsaW5lcywgaW5mby5zbmFwLnBvc0luZm9zLm1hcChmdW5jdGlvbiAoX2EsIGkpIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSBfYS5wb3M7XG4gICAgICAgICAgICB2YXIgc25hcFBvczEgPSBtaW51cyhjYWxjdWxhdGVQb3NpdGlvbihhbGxNYXRyaXgsIGlzSG9yaXpvbnRhbCA/IFswLCBwb3NdIDogW3BvcywgMF0sIG4pLCBbbGVmdCwgdG9wXSk7XG4gICAgICAgICAgICB2YXIgc25hcFBvczIgPSBtaW51cyhjYWxjdWxhdGVQb3NpdGlvbihhbGxNYXRyaXgsIGlzSG9yaXpvbnRhbCA/IFt3aWR0aCwgcG9zXSA6IFtwb3MsIGhlaWdodF0sIG4pLCBbbGVmdCwgdG9wXSk7XG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyTGluZShSZWFjdCwgXCJcIiwgc25hcFBvczEsIHNuYXBQb3MyLCB6b29tLCBcImNsaXBcIiArIGRpcmVjdGlvblR5cGUgKyBcInNuYXBcIiArIGksIFwiZ3VpZGVsaW5lXCIpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmZvLmlzQm91bmQpIHtcbiAgICAgICAgICBsaW5lcy5wdXNoLmFwcGx5KGxpbmVzLCBpbmZvLmJvdW5kcy5tYXAoZnVuY3Rpb24gKF9hLCBpKSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gX2EucG9zO1xuICAgICAgICAgICAgdmFyIHNuYXBQb3MxID0gbWludXMoY2FsY3VsYXRlUG9zaXRpb24oYWxsTWF0cml4LCBpc0hvcml6b250YWwgPyBbMCwgcG9zXSA6IFtwb3MsIDBdLCBuKSwgW2xlZnQsIHRvcF0pO1xuICAgICAgICAgICAgdmFyIHNuYXBQb3MyID0gbWludXMoY2FsY3VsYXRlUG9zaXRpb24oYWxsTWF0cml4LCBpc0hvcml6b250YWwgPyBbd2lkdGgsIHBvc10gOiBbcG9zLCBoZWlnaHRdLCBuKSwgW2xlZnQsIHRvcF0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlbmRlckxpbmUoUmVhY3QsIFwiXCIsIHNuYXBQb3MxLCBzbmFwUG9zMiwgem9vbSwgXCJjbGlwXCIgKyBkaXJlY3Rpb25UeXBlICsgXCJib3VuZHNcIiArIGksIFwiZ3VpZGVsaW5lXCIsIFwiYm91bmRzXCIsIFwiYm9sZFwiKTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIGNvbnRyb2xzKSwgbGluZXMpO1xuICB9LFxuICBkcmFnQ29udHJvbENvbmRpdGlvbjogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgcmV0dXJuIGUuaW5wdXRFdmVudCAmJiAoZS5pbnB1dEV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiKS5pbmRleE9mKFwiY2xpcFwiKSA+IC0xO1xuICB9LFxuICBkcmFnU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBwcm9wcyA9IG1vdmVhYmxlLnByb3BzO1xuICAgIHZhciBfYSA9IHByb3BzLmRyYWdXaXRoQ2xpcCxcbiAgICAgICAgZHJhZ1dpdGhDbGlwID0gX2EgPT09IHZvaWQgMCA/IHRydWUgOiBfYTtcblxuICAgIGlmIChkcmFnV2l0aENsaXApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5kcmFnQ29udHJvbFN0YXJ0KG1vdmVhYmxlLCBlKTtcbiAgfSxcbiAgZHJhZzogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ0NvbnRyb2wobW92ZWFibGUsIGUpO1xuICB9LFxuICBkcmFnRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnQ29udHJvbEVuZChtb3ZlYWJsZSwgZSk7XG4gIH0sXG4gIGRyYWdDb250cm9sU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBzdGF0ZSA9IG1vdmVhYmxlLnN0YXRlO1xuICAgIHZhciBfYSA9IG1vdmVhYmxlLnByb3BzLFxuICAgICAgICBkZWZhdWx0Q2xpcFBhdGggPSBfYS5kZWZhdWx0Q2xpcFBhdGgsXG4gICAgICAgIGN1c3RvbUNsaXBQYXRoID0gX2EuY3VzdG9tQ2xpcFBhdGg7XG4gICAgdmFyIHRhcmdldCA9IHN0YXRlLnRhcmdldCxcbiAgICAgICAgd2lkdGggPSBzdGF0ZS53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gc3RhdGUuaGVpZ2h0O1xuICAgIHZhciBpbnB1dFRhcmdldCA9IGUuaW5wdXRFdmVudCA/IGUuaW5wdXRFdmVudC50YXJnZXQgOiBudWxsO1xuICAgIHZhciBjbGFzc05hbWUgPSBpbnB1dFRhcmdldCAmJiBpbnB1dFRhcmdldC5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiO1xuICAgIHZhciBkYXRhcyA9IGUuZGF0YXM7XG4gICAgdmFyIGNsaXBQYXRoID0gZ2V0Q2xpcFBhdGgodGFyZ2V0LCB3aWR0aCwgaGVpZ2h0LCBkZWZhdWx0Q2xpcFBhdGggfHwgXCJpbnNldFwiLCBjdXN0b21DbGlwUGF0aCk7XG5cbiAgICBpZiAoIWNsaXBQYXRoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGNsaXBUZXh0ID0gY2xpcFBhdGguY2xpcFRleHQsXG4gICAgICAgIHR5cGUgPSBjbGlwUGF0aC50eXBlLFxuICAgICAgICBwb3NlcyA9IGNsaXBQYXRoLnBvc2VzO1xuICAgIHZhciByZXN1bHQgPSB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25DbGlwU3RhcnRcIiwgZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xuICAgICAgY2xpcFR5cGU6IHR5cGUsXG4gICAgICBjbGlwU3R5bGU6IGNsaXBUZXh0LFxuICAgICAgcG9zZXM6IHBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIHJldHVybiBwb3MucG9zO1xuICAgICAgfSlcbiAgICB9KSk7XG5cbiAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgZGF0YXMuaXNDbGlwU3RhcnQgPSBmYWxzZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBkYXRhcy5pc0NvbnRyb2wgPSBjbGFzc05hbWUgJiYgY2xhc3NOYW1lLmluZGV4T2YoXCJjbGlwLWNvbnRyb2xcIikgPiAtMTtcbiAgICBkYXRhcy5pc0xpbmUgPSBjbGFzc05hbWUuaW5kZXhPZihcImNsaXAtbGluZVwiKSA+IC0xO1xuICAgIGRhdGFzLmlzQXJlYSA9IGNsYXNzTmFtZS5pbmRleE9mKFwiY2xpcC1hcmVhXCIpID4gLTEgfHwgY2xhc3NOYW1lLmluZGV4T2YoXCJjbGlwLWVsbGlwc2VcIikgPiAtMTtcbiAgICBkYXRhcy5pbmRleCA9IGlucHV0VGFyZ2V0ID8gcGFyc2VJbnQoaW5wdXRUYXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1jbGlwLWluZGV4XCIpLCAxMCkgOiAtMTtcbiAgICBkYXRhcy5jbGlwUGF0aCA9IGNsaXBQYXRoO1xuICAgIGRhdGFzLmlzQ2xpcFN0YXJ0ID0gdHJ1ZTtcbiAgICBzdGF0ZS5jbGlwUGF0aFN0YXRlID0gY2xpcFRleHQ7XG4gICAgc2V0RHJhZ1N0YXJ0KG1vdmVhYmxlLCBlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgZHJhZ0NvbnRyb2w6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBfYTtcblxuICAgIHZhciBkYXRhcyA9IGUuZGF0YXMsXG4gICAgICAgIG9yaWdpbmFsRGF0YXMgPSBlLm9yaWdpbmFsRGF0YXM7XG5cbiAgICBpZiAoIWRhdGFzLmlzQ2xpcFN0YXJ0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIF9iID0gZGF0YXMsXG4gICAgICAgIGlzQ29udHJvbCA9IF9iLmlzQ29udHJvbCxcbiAgICAgICAgaXNMaW5lID0gX2IuaXNMaW5lLFxuICAgICAgICBpc0FyZWEgPSBfYi5pc0FyZWEsXG4gICAgICAgIGluZGV4ID0gX2IuaW5kZXgsXG4gICAgICAgIGNsaXBQYXRoID0gX2IuY2xpcFBhdGg7XG5cbiAgICBpZiAoIWNsaXBQYXRoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIF9jID0gZ2V0RHJhZ0Rpc3QoZSksXG4gICAgICAgIGRpc3RYID0gX2NbMF0sXG4gICAgICAgIGRpc3RZID0gX2NbMV07XG5cbiAgICB2YXIgcHJvcHMgPSBtb3ZlYWJsZS5wcm9wcztcbiAgICB2YXIgc3RhdGUgPSBtb3ZlYWJsZS5zdGF0ZTtcbiAgICB2YXIgd2lkdGggPSBzdGF0ZS53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gc3RhdGUuaGVpZ2h0O1xuICAgIHZhciBpc0RyYWdXaXRoVGFyZ2V0ID0gIWlzQXJlYSAmJiAhaXNDb250cm9sICYmICFpc0xpbmU7XG4gICAgdmFyIGNsaXBUeXBlID0gY2xpcFBhdGgudHlwZSxcbiAgICAgICAgY2xpcFBvc2VzID0gY2xpcFBhdGgucG9zZXMsXG4gICAgICAgIHNwbGl0dGVyID0gY2xpcFBhdGguc3BsaXR0ZXI7XG4gICAgdmFyIHBvc2VzID0gY2xpcFBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgICByZXR1cm4gcG9zLnBvcztcbiAgICB9KTtcblxuICAgIGlmIChpc0RyYWdXaXRoVGFyZ2V0KSB7XG4gICAgICBkaXN0WCA9IC1kaXN0WDtcbiAgICAgIGRpc3RZID0gLWRpc3RZO1xuICAgIH1cblxuICAgIHZhciBpc0FsbCA9ICFpc0NvbnRyb2wgfHwgY2xpcFBvc2VzW2luZGV4XS5kaXJlY3Rpb24gPT09IFwibmVzd1wiO1xuICAgIHZhciBpc1JlY3QgPSBjbGlwVHlwZSA9PT0gXCJpbnNldFwiIHx8IGNsaXBUeXBlID09PSBcInJlY3RcIjtcbiAgICB2YXIgZGlzdHMgPSBjbGlwUG9zZXMubWFwKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBbMCwgMF07XG4gICAgfSk7XG5cbiAgICBpZiAoaXNDb250cm9sICYmICFpc0FsbCkge1xuICAgICAgdmFyIF9kID0gY2xpcFBvc2VzW2luZGV4XSxcbiAgICAgICAgICBob3Jpem9udGFsID0gX2QuaG9yaXpvbnRhbCxcbiAgICAgICAgICB2ZXJ0aWNhbCA9IF9kLnZlcnRpY2FsO1xuICAgICAgdmFyIGRpc3QgPSBbZGlzdFggKiBNYXRoLmFicyhob3Jpem9udGFsKSwgZGlzdFkgKiBNYXRoLmFicyh2ZXJ0aWNhbCldO1xuICAgICAgZGlzdHMgPSBtb3ZlQ29udHJvbFBvcyhjbGlwUG9zZXMsIGluZGV4LCBkaXN0LCBpc1JlY3QpO1xuICAgIH0gZWxzZSBpZiAoaXNBbGwpIHtcbiAgICAgIGRpc3RzID0gcG9zZXMubWFwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtkaXN0WCwgZGlzdFldO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIG5leHRQb3NlcyA9IHBvc2VzLm1hcChmdW5jdGlvbiAocG9zLCBpKSB7XG4gICAgICByZXR1cm4gcGx1cyhwb3MsIGRpc3RzW2ldKTtcbiAgICB9KTtcblxuICAgIHZhciBndWlkZVBvc2VzID0gX19zcHJlYWRBcnJheShbXSwgbmV4dFBvc2VzKTtcblxuICAgIHN0YXRlLnNuYXBCb3VuZEluZm9zID0gbnVsbDtcbiAgICB2YXIgaXNDaXJjbGUgPSBjbGlwUGF0aC50eXBlID09PSBcImNpcmNsZVwiO1xuICAgIHZhciBpc0VsbGlwc2UgPSBjbGlwUGF0aC50eXBlID09PSBcImVsbGlwc2VcIjtcblxuICAgIGlmIChpc0NpcmNsZSB8fCBpc0VsbGlwc2UpIHtcbiAgICAgIHZhciBndWlkZVJlY3QgPSBnZXRSZWN0KG5leHRQb3Nlcyk7XG4gICAgICB2YXIgcnkgPSBNYXRoLmFicyhndWlkZVJlY3QuYm90dG9tIC0gZ3VpZGVSZWN0LnRvcCk7XG4gICAgICB2YXIgcnggPSBNYXRoLmFicyhpc0VsbGlwc2UgPyBndWlkZVJlY3QucmlnaHQgLSBndWlkZVJlY3QubGVmdCA6IHJ5KTtcbiAgICAgIHZhciBib3R0b20gPSBuZXh0UG9zZXNbMF1bMV0gKyByeTtcbiAgICAgIHZhciBsZWZ0ID0gbmV4dFBvc2VzWzBdWzBdIC0gcng7XG4gICAgICB2YXIgcmlnaHQgPSBuZXh0UG9zZXNbMF1bMF0gKyByeDsgLy8gcmlnaHRcblxuICAgICAgaWYgKGlzQ2lyY2xlKSB7XG4gICAgICAgIGd1aWRlUG9zZXMucHVzaChbcmlnaHQsIGd1aWRlUmVjdC5ib3R0b21dKTtcbiAgICAgICAgZGlzdHMucHVzaChbMSwgMF0pO1xuICAgICAgfSAvLyBib3R0b21cblxuXG4gICAgICBndWlkZVBvc2VzLnB1c2goW2d1aWRlUmVjdC5sZWZ0LCBib3R0b21dKTtcbiAgICAgIGRpc3RzLnB1c2goWzAsIDFdKTsgLy8gbGVmdFxuXG4gICAgICBndWlkZVBvc2VzLnB1c2goW2xlZnQsIGd1aWRlUmVjdC5ib3R0b21dKTtcbiAgICAgIGRpc3RzLnB1c2goWzEsIDBdKTtcbiAgICB9XG5cbiAgICB2YXIgZ3VpZGVsaW5lcyA9IGdldERlZmF1bHRHdWlkZWxpbmVzKChwcm9wcy5jbGlwSG9yaXpvbnRhbEd1aWRlbGluZXMgfHwgW10pLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIGNvbnZlcnRVbml0U2l6ZShcIlwiICsgdiwgaGVpZ2h0KTtcbiAgICB9KSwgKHByb3BzLmNsaXBWZXJ0aWNhbEd1aWRlbGluZXMgfHwgW10pLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIGNvbnZlcnRVbml0U2l6ZShcIlwiICsgdiwgd2lkdGgpO1xuICAgIH0pLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB2YXIgZ3VpZGVYUG9zZXMgPSBbXTtcbiAgICB2YXIgZ3VpZGVZUG9zZXMgPSBbXTtcblxuICAgIGlmIChpc0NpcmNsZSB8fCBpc0VsbGlwc2UpIHtcbiAgICAgIGd1aWRlWFBvc2VzID0gW2d1aWRlUG9zZXNbNF1bMF0sIGd1aWRlUG9zZXNbMl1bMF1dO1xuICAgICAgZ3VpZGVZUG9zZXMgPSBbZ3VpZGVQb3Nlc1sxXVsxXSwgZ3VpZGVQb3Nlc1szXVsxXV07XG4gICAgfSBlbHNlIGlmIChpc1JlY3QpIHtcbiAgICAgIHZhciByZWN0UG9zZXMgPSBbZ3VpZGVQb3Nlc1swXSwgZ3VpZGVQb3Nlc1syXSwgZ3VpZGVQb3Nlc1s0XSwgZ3VpZGVQb3Nlc1s2XV07XG4gICAgICB2YXIgcmVjdERpc3RzXzEgPSBbZGlzdHNbMF0sIGRpc3RzWzJdLCBkaXN0c1s0XSwgZGlzdHNbNl1dO1xuICAgICAgZ3VpZGVYUG9zZXMgPSByZWN0UG9zZXMuZmlsdGVyKGZ1bmN0aW9uIChfLCBpKSB7XG4gICAgICAgIHJldHVybiByZWN0RGlzdHNfMVtpXVswXTtcbiAgICAgIH0pLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIHJldHVybiBwb3NbMF07XG4gICAgICB9KTtcbiAgICAgIGd1aWRlWVBvc2VzID0gcmVjdFBvc2VzLmZpbHRlcihmdW5jdGlvbiAoXywgaSkge1xuICAgICAgICByZXR1cm4gcmVjdERpc3RzXzFbaV1bMV07XG4gICAgICB9KS5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgICAgICByZXR1cm4gcG9zWzFdO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGd1aWRlWFBvc2VzID0gZ3VpZGVQb3Nlcy5maWx0ZXIoZnVuY3Rpb24gKF8sIGkpIHtcbiAgICAgICAgcmV0dXJuIGRpc3RzW2ldWzBdO1xuICAgICAgfSkubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgcmV0dXJuIHBvc1swXTtcbiAgICAgIH0pO1xuICAgICAgZ3VpZGVZUG9zZXMgPSBndWlkZVBvc2VzLmZpbHRlcihmdW5jdGlvbiAoXywgaSkge1xuICAgICAgICByZXR1cm4gZGlzdHNbaV1bMV07XG4gICAgICB9KS5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgICAgICByZXR1cm4gcG9zWzFdO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGJvdW5kRGVsdGEgPSBbMCwgMF07XG5cbiAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICB2YXIgX2UgPSBjaGVja1NuYXBCb3VuZHMoZ3VpZGVsaW5lcywgcHJvcHMuY2xpcFRhcmdldEJvdW5kcyAmJiB7XG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgcmlnaHQ6IHdpZHRoLFxuICAgICAgICBib3R0b206IGhlaWdodFxuICAgICAgfSwgZ3VpZGVYUG9zZXMsIGd1aWRlWVBvc2VzLCA1KSxcbiAgICAgICAgICBob3Jpem9udGFsU25hcEluZm8gPSBfZS5ob3Jpem9udGFsLFxuICAgICAgICAgIHZlcnRpY2FsU25hcEluZm8gPSBfZS52ZXJ0aWNhbDtcblxuICAgICAgdmFyIHNuYXBPZmZzZXRZID0gaG9yaXpvbnRhbFNuYXBJbmZvLm9mZnNldDtcbiAgICAgIHZhciBzbmFwT2Zmc2V0WCA9IHZlcnRpY2FsU25hcEluZm8ub2Zmc2V0O1xuXG4gICAgICBpZiAoaG9yaXpvbnRhbFNuYXBJbmZvLmlzQm91bmQpIHtcbiAgICAgICAgYm91bmREZWx0YVsxXSArPSBzbmFwT2Zmc2V0WTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZlcnRpY2FsU25hcEluZm8uaXNCb3VuZCkge1xuICAgICAgICBib3VuZERlbHRhWzBdICs9IHNuYXBPZmZzZXRYO1xuICAgICAgfVxuXG4gICAgICBpZiAoKGlzRWxsaXBzZSB8fCBpc0NpcmNsZSkgJiYgZGlzdHNbMF1bMF0gPT09IDAgJiYgZGlzdHNbMF1bMV0gPT09IDApIHtcbiAgICAgICAgdmFyIGd1aWRlUmVjdCA9IGdldFJlY3QobmV4dFBvc2VzKTtcbiAgICAgICAgdmFyIGN5ID0gZ3VpZGVSZWN0LmJvdHRvbSAtIGd1aWRlUmVjdC50b3A7XG4gICAgICAgIHZhciBjeCA9IGlzRWxsaXBzZSA/IGd1aWRlUmVjdC5yaWdodCAtIGd1aWRlUmVjdC5sZWZ0IDogY3k7XG4gICAgICAgIHZhciBkaXN0U25hcFggPSB2ZXJ0aWNhbFNuYXBJbmZvLmlzQm91bmQgPyBNYXRoLmFicyhzbmFwT2Zmc2V0WCkgOiB2ZXJ0aWNhbFNuYXBJbmZvLnNuYXBJbmRleCA9PT0gMCA/IC1zbmFwT2Zmc2V0WCA6IHNuYXBPZmZzZXRYO1xuICAgICAgICB2YXIgZGlzdFNuYXBZID0gaG9yaXpvbnRhbFNuYXBJbmZvLmlzQm91bmQgPyBNYXRoLmFicyhzbmFwT2Zmc2V0WSkgOiBob3Jpem9udGFsU25hcEluZm8uc25hcEluZGV4ID09PSAwID8gLXNuYXBPZmZzZXRZIDogc25hcE9mZnNldFk7XG4gICAgICAgIGN4IC09IGRpc3RTbmFwWDtcbiAgICAgICAgY3kgLT0gZGlzdFNuYXBZO1xuXG4gICAgICAgIGlmIChpc0NpcmNsZSkge1xuICAgICAgICAgIGN5ID0gY2hlY2tTbmFwQm91bmRQcmlvcml0eSh2ZXJ0aWNhbFNuYXBJbmZvLCBob3Jpem9udGFsU25hcEluZm8pID4gMCA/IGN5IDogY3g7XG4gICAgICAgICAgY3ggPSBjeTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjZW50ZXIgPSBndWlkZVBvc2VzWzBdO1xuICAgICAgICBndWlkZVBvc2VzWzFdWzFdID0gY2VudGVyWzFdIC0gY3k7XG4gICAgICAgIGd1aWRlUG9zZXNbMl1bMF0gPSBjZW50ZXJbMF0gKyBjeDtcbiAgICAgICAgZ3VpZGVQb3Nlc1szXVsxXSA9IGNlbnRlclsxXSArIGN5O1xuICAgICAgICBndWlkZVBvc2VzWzRdWzBdID0gY2VudGVyWzBdIC0gY3g7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBndWlkZVBvc2VzLmZvckVhY2goZnVuY3Rpb24gKHBvcywgaikge1xuICAgICAgICAgIHZhciBkaXN0ID0gZGlzdHNbal07XG5cbiAgICAgICAgICBpZiAoZGlzdFswXSkge1xuICAgICAgICAgICAgcG9zWzBdIC09IHNuYXBPZmZzZXRYO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChkaXN0WzFdKSB7XG4gICAgICAgICAgICBwb3NbMV0gLT0gc25hcE9mZnNldFk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyArK2kpIHtcbiAgICAgIHZhciBzdGF0ZV8xID0gX2xvb3BfMSgpO1xuXG4gICAgICBpZiAoc3RhdGVfMSA9PT0gXCJicmVha1wiKSBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgbmV4dENsaXBTdHlsZXMgPSBnZXRDbGlwU3R5bGVzKG1vdmVhYmxlLCBjbGlwUGF0aCwgbmV4dFBvc2VzKTtcbiAgICB2YXIgY2xpcFN0eWxlID0gY2xpcFR5cGUgKyBcIihcIiArIG5leHRDbGlwU3R5bGVzLmpvaW4oc3BsaXR0ZXIpICsgXCIpXCI7XG4gICAgc3RhdGUuY2xpcFBhdGhTdGF0ZSA9IGNsaXBTdHlsZTtcblxuICAgIGlmIChpc0NpcmNsZSB8fCBpc0VsbGlwc2UpIHtcbiAgICAgIGd1aWRlWFBvc2VzID0gW2d1aWRlUG9zZXNbNF1bMF0sIGd1aWRlUG9zZXNbMl1bMF1dO1xuICAgICAgZ3VpZGVZUG9zZXMgPSBbZ3VpZGVQb3Nlc1sxXVsxXSwgZ3VpZGVQb3Nlc1szXVsxXV07XG4gICAgfSBlbHNlIGlmIChpc1JlY3QpIHtcbiAgICAgIHZhciByZWN0UG9zZXMgPSBbZ3VpZGVQb3Nlc1swXSwgZ3VpZGVQb3Nlc1syXSwgZ3VpZGVQb3Nlc1s0XSwgZ3VpZGVQb3Nlc1s2XV07XG4gICAgICBndWlkZVhQb3NlcyA9IHJlY3RQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgICAgICByZXR1cm4gcG9zWzBdO1xuICAgICAgfSk7XG4gICAgICBndWlkZVlQb3NlcyA9IHJlY3RQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgICAgICByZXR1cm4gcG9zWzFdO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGd1aWRlWFBvc2VzID0gZ3VpZGVQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgICAgICByZXR1cm4gcG9zWzBdO1xuICAgICAgfSk7XG4gICAgICBndWlkZVlQb3NlcyA9IGd1aWRlUG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgcmV0dXJuIHBvc1sxXTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHN0YXRlLnNuYXBCb3VuZEluZm9zID0gY2hlY2tTbmFwQm91bmRzKGd1aWRlbGluZXMsIHByb3BzLmNsaXBUYXJnZXRCb3VuZHMgJiYge1xuICAgICAgbGVmdDogMCxcbiAgICAgIHRvcDogMCxcbiAgICAgIHJpZ2h0OiB3aWR0aCxcbiAgICAgIGJvdHRvbTogaGVpZ2h0XG4gICAgfSwgZ3VpZGVYUG9zZXMsIGd1aWRlWVBvc2VzLCAxKTtcblxuICAgIGlmIChvcmlnaW5hbERhdGFzLmRyYWdnYWJsZSkge1xuICAgICAgdmFyIGlzM2QgPSBzdGF0ZS5pczNkLFxuICAgICAgICAgIGFsbE1hdHJpeCA9IHN0YXRlLmFsbE1hdHJpeDtcbiAgICAgIHZhciBuID0gaXMzZCA/IDQgOiAzO1xuICAgICAgX2EgPSBtdWx0aXBseShhbGxNYXRyaXgsIFtib3VuZERlbHRhWzBdLCBib3VuZERlbHRhWzFdLCAwLCAwXSwgbiksIGJvdW5kRGVsdGFbMF0gPSBfYVswXSwgYm91bmREZWx0YVsxXSA9IF9hWzFdO1xuICAgICAgb3JpZ2luYWxEYXRhcy5kcmFnZ2FibGUuZGVsdGFPZmZzZXQgPSBib3VuZERlbHRhO1xuICAgIH1cblxuICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkNsaXBcIiwgZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xuICAgICAgY2xpcEV2ZW50VHlwZTogXCJjaGFuZ2VkXCIsXG4gICAgICBjbGlwVHlwZTogY2xpcFR5cGUsXG4gICAgICBwb3NlczogbmV4dFBvc2VzLFxuICAgICAgY2xpcFN0eWxlOiBjbGlwU3R5bGUsXG4gICAgICBjbGlwU3R5bGVzOiBuZXh0Q2xpcFN0eWxlcyxcbiAgICAgIGRpc3RYOiBkaXN0WCxcbiAgICAgIGRpc3RZOiBkaXN0WVxuICAgIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgZHJhZ0NvbnRyb2xFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHRoaXMudW5zZXQobW92ZWFibGUpO1xuICAgIHZhciBpc0RyYWcgPSBlLmlzRHJhZyxcbiAgICAgICAgZGF0YXMgPSBlLmRhdGFzLFxuICAgICAgICBpc0RvdWJsZSA9IGUuaXNEb3VibGU7XG4gICAgdmFyIGlzTGluZSA9IGRhdGFzLmlzTGluZSxcbiAgICAgICAgaXNDbGlwU3RhcnQgPSBkYXRhcy5pc0NsaXBTdGFydCxcbiAgICAgICAgaXNDb250cm9sID0gZGF0YXMuaXNDb250cm9sO1xuXG4gICAgaWYgKCFpc0NsaXBTdGFydCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkNsaXBFbmRcIiwgZmlsbEVuZFBhcmFtcyhtb3ZlYWJsZSwgZSwge30pKTtcblxuICAgIGlmIChpc0RvdWJsZSkge1xuICAgICAgaWYgKGlzQ29udHJvbCkge1xuICAgICAgICByZW1vdmVDbGlwUGF0aChtb3ZlYWJsZSwgZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzTGluZSkge1xuICAgICAgICAvLyBhZGRcbiAgICAgICAgYWRkQ2xpcFBhdGgobW92ZWFibGUsIGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpc0RvdWJsZSB8fCBpc0RyYWc7XG4gIH0sXG4gIHVuc2V0OiBmdW5jdGlvbiAobW92ZWFibGUpIHtcbiAgICBtb3ZlYWJsZS5zdGF0ZS5jbGlwUGF0aFN0YXRlID0gXCJcIjtcbiAgICBtb3ZlYWJsZS5zdGF0ZS5zbmFwQm91bmRJbmZvcyA9IG51bGw7XG4gIH1cbn07XG4vKipcbiAqIFdoZXRoZXIgdG8gY2xpcCB0aGUgdGFyZ2V0LiAoZGVmYXVsdDogZmFsc2UpXG4gKiBAbmFtZSBNb3ZlYWJsZS5DbGlwcGFibGUjY2xpcHBhYmxlXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgICBjbGlwcGFibGU6IHRydWUsXG4gKiAgICAgZGVmYXVsdENsaXBQYXRoOiBcImluc2V0XCIsXG4gKiAgICAgY3VzdG9tQ2xpcFBhdGg6IFwiXCIsXG4gKiAgICAgY2xpcFJlbGF0aXZlOiBmYWxzZSxcbiAqICAgICBjbGlwQXJlYTogZmFsc2UsXG4gKiAgICAgZHJhZ1dpdGhDbGlwOiB0cnVlLFxuICogfSk7XG4gKiBtb3ZlYWJsZS5vbihcImNsaXBTdGFydFwiLCBlID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcbiAqIH0pLm9uKFwiY2xpcFwiLCBlID0+IHtcbiAqICAgICBpZiAoZS5jbGlwVHlwZSA9PT0gXCJyZWN0XCIpIHtcbiAqICAgICAgICAgZS50YXJnZXQuc3R5bGUuY2xpcCA9IGUuY2xpcFN0eWxlO1xuICogICAgIH0gZWxzZSB7XG4gKiAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmNsaXBQYXRoID0gZS5jbGlwU3R5bGU7XG4gKiAgICAgfVxuICogfSkub24oXCJjbGlwRW5kXCIsIGUgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGUpO1xuICogfSk7XG4gKi9cblxuLyoqXG4gKiAgSWYgY2xpcHBhdGggaXMgbm90IHNldCwgdGhlIGRlZmF1bHQgdmFsdWUgY2FuIGJlIHNldC4gKGRlZmF1bHRDbGlwUGF0aCA8IHN0eWxlIDwgY3VzdG9tQ2xpcFBhdGggPCBkcmFnZ2luZyBjbGlwUGF0aClcbiAqIEBuYW1lIE1vdmVhYmxlLkNsaXBwYWJsZSNkZWZhdWx0Q2xpcFBhdGhcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICAgIGNsaXBwYWJsZTogdHJ1ZSxcbiAqICAgICBkZWZhdWx0Q2xpcFBhdGg6IFwiaW5zZXRcIixcbiAqICAgICBjdXN0b21DbGlwUGF0aDogXCJcIixcbiAqICAgICBjbGlwUmVsYXRpdmU6IGZhbHNlLFxuICogICAgIGNsaXBBcmVhOiBmYWxzZSxcbiAqICAgICBkcmFnV2l0aENsaXA6IHRydWUsXG4gKiB9KTtcbiAqIG1vdmVhYmxlLm9uKFwiY2xpcFN0YXJ0XCIsIGUgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGUpO1xuICogfSkub24oXCJjbGlwXCIsIGUgPT4ge1xuICogICAgIGlmIChlLmNsaXBUeXBlID09PSBcInJlY3RcIikge1xuICogICAgICAgICBlLnRhcmdldC5zdHlsZS5jbGlwID0gZS5jbGlwU3R5bGU7XG4gKiAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgZS50YXJnZXQuc3R5bGUuY2xpcFBhdGggPSBlLmNsaXBTdHlsZTtcbiAqICAgICB9XG4gKiB9KS5vbihcImNsaXBFbmRcIiwgZSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZSk7XG4gKiB9KTtcbiAqL1xuXG4vKipcbiAqICUgQ2FuIGJlIHVzZWQgaW5zdGVhZCBvZiB0aGUgYWJzb2x1dGUgcHggKGByZWN0YCBub3QgcG9zc2libGUpIChkZWZhdWx0OiBmYWxzZSlcbiAqIEBuYW1lIE1vdmVhYmxlLkNsaXBwYWJsZSNjbGlwUmVsYXRpdmVcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICAgIGNsaXBwYWJsZTogdHJ1ZSxcbiAqICAgICBkZWZhdWx0Q2xpcFBhdGg6IFwiaW5zZXRcIixcbiAqICAgICBjdXN0b21DbGlwUGF0aDogXCJcIixcbiAqICAgICBjbGlwUmVsYXRpdmU6IGZhbHNlLFxuICogICAgIGNsaXBBcmVhOiBmYWxzZSxcbiAqICAgICBkcmFnV2l0aENsaXA6IHRydWUsXG4gKiB9KTtcbiAqIG1vdmVhYmxlLm9uKFwiY2xpcFN0YXJ0XCIsIGUgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGUpO1xuICogfSkub24oXCJjbGlwXCIsIGUgPT4ge1xuICogICAgIGlmIChlLmNsaXBUeXBlID09PSBcInJlY3RcIikge1xuICogICAgICAgICBlLnRhcmdldC5zdHlsZS5jbGlwID0gZS5jbGlwU3R5bGU7XG4gKiAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgZS50YXJnZXQuc3R5bGUuY2xpcFBhdGggPSBlLmNsaXBTdHlsZTtcbiAqICAgICB9XG4gKiB9KS5vbihcImNsaXBFbmRcIiwgZSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZSk7XG4gKiB9KTtcbiAqL1xuXG4vKipcbiAqIFlvdSBjYW4gZm9yY2UgdGhlIGN1c3RvbSBjbGlwUGF0aC4gKGRlZmF1bHRDbGlwUGF0aCA8IHN0eWxlIDwgY3VzdG9tQ2xpcFBhdGggPCBkcmFnZ2luZyBjbGlwUGF0aClcbiAqIEBuYW1lIE1vdmVhYmxlLkNsaXBwYWJsZSNjdXN0b21DbGlwUGF0aFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgY2xpcHBhYmxlOiB0cnVlLFxuICogICAgIGRlZmF1bHRDbGlwUGF0aDogXCJpbnNldFwiLFxuICogICAgIGN1c3RvbUNsaXBQYXRoOiBcIlwiLFxuICogICAgIGNsaXBSZWxhdGl2ZTogZmFsc2UsXG4gKiAgICAgY2xpcEFyZWE6IGZhbHNlLFxuICogICAgIGRyYWdXaXRoQ2xpcDogdHJ1ZSxcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJjbGlwU3RhcnRcIiwgZSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZSk7XG4gKiB9KS5vbihcImNsaXBcIiwgZSA9PiB7XG4gKiAgICAgaWYgKGUuY2xpcFR5cGUgPT09IFwicmVjdFwiKSB7XG4gKiAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmNsaXAgPSBlLmNsaXBTdHlsZTtcbiAqICAgICB9IGVsc2Uge1xuICogICAgICAgICBlLnRhcmdldC5zdHlsZS5jbGlwUGF0aCA9IGUuY2xpcFN0eWxlO1xuICogICAgIH1cbiAqIH0pLm9uKFwiY2xpcEVuZFwiLCBlID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcbiAqIH0pO1xuICovXG5cbi8qKlxuICogV2hlbiBkcmFnZ2luZyB0aGUgdGFyZ2V0LCB0aGUgY2xpcCBhbHNvIG1vdmVzLiAoZGVmYXVsdDogdHJ1ZSlcbiAqIEBuYW1lIE1vdmVhYmxlLkNsaXBwYWJsZSNkcmFnV2l0aENsaXBcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICAgIGNsaXBwYWJsZTogdHJ1ZSxcbiAqICAgICBkZWZhdWx0Q2xpcFBhdGg6IFwiaW5zZXRcIixcbiAqICAgICBjdXN0b21DbGlwUGF0aDogXCJcIixcbiAqICAgICBjbGlwUmVsYXRpdmU6IGZhbHNlLFxuICogICAgIGNsaXBBcmVhOiBmYWxzZSxcbiAqICAgICBkcmFnV2l0aENsaXA6IHRydWUsXG4gKiB9KTtcbiAqIG1vdmVhYmxlLm9uKFwiY2xpcFN0YXJ0XCIsIGUgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGUpO1xuICogfSkub24oXCJjbGlwXCIsIGUgPT4ge1xuICogICAgIGlmIChlLmNsaXBUeXBlID09PSBcInJlY3RcIikge1xuICogICAgICAgICBlLnRhcmdldC5zdHlsZS5jbGlwID0gZS5jbGlwU3R5bGU7XG4gKiAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgZS50YXJnZXQuc3R5bGUuY2xpcFBhdGggPSBlLmNsaXBTdHlsZTtcbiAqICAgICB9XG4gKiB9KS5vbihcImNsaXBFbmRcIiwgZSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZSk7XG4gKiB9KTtcbiAqL1xuXG4vKipcbiAqIFlvdSBjYW4gZHJhZyB0aGUgY2xpcCBieSBzZXR0aW5nIGNsaXBBcmVhLiAoZGVmYXVsdDogZmFsc2UpXG4gKiBAbmFtZSBNb3ZlYWJsZS5DbGlwcGFibGUjY2xpcEFyZWFcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICAgIGNsaXBwYWJsZTogdHJ1ZSxcbiAqICAgICBkZWZhdWx0Q2xpcFBhdGg6IFwiaW5zZXRcIixcbiAqICAgICBjdXN0b21DbGlwUGF0aDogXCJcIixcbiAqICAgICBjbGlwUmVsYXRpdmU6IGZhbHNlLFxuICogICAgIGNsaXBBcmVhOiBmYWxzZSxcbiAqICAgICBkcmFnV2l0aENsaXA6IHRydWUsXG4gKiB9KTtcbiAqIG1vdmVhYmxlLm9uKFwiY2xpcFN0YXJ0XCIsIGUgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGUpO1xuICogfSkub24oXCJjbGlwXCIsIGUgPT4ge1xuICogICAgIGlmIChlLmNsaXBUeXBlID09PSBcInJlY3RcIikge1xuICogICAgICAgICBlLnRhcmdldC5zdHlsZS5jbGlwID0gZS5jbGlwU3R5bGU7XG4gKiAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgZS50YXJnZXQuc3R5bGUuY2xpcFBhdGggPSBlLmNsaXBTdHlsZTtcbiAqICAgICB9XG4gKiB9KS5vbihcImNsaXBFbmRcIiwgZSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZSk7XG4gKiB9KTtcbiAqL1xuXG4vKipcbiogV2hldGhlciB0aGUgY2xpcCBpcyBib3VuZCB0byB0aGUgdGFyZ2V0LiAoZGVmYXVsdDogZmFsc2UpXG4qIEBuYW1lIE1vdmVhYmxlLkNsaXBwYWJsZSNjbGlwVGFyZ2V0Qm91bmRzXG4qIEBleGFtcGxlXG4qIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbipcbiogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuKiAgICAgY2xpcHBhYmxlOiB0cnVlLFxuKiAgICAgZGVmYXVsdENsaXBQYXRoOiBcImluc2V0XCIsXG4qICAgICBjdXN0b21DbGlwUGF0aDogXCJcIixcbiogICAgIGNsaXBSZWxhdGl2ZTogZmFsc2UsXG4qICAgICBjbGlwQXJlYTogZmFsc2UsXG4qICAgICBkcmFnV2l0aENsaXA6IHRydWUsXG4qICAgICBjbGlwVGFyZ2V0Qm91bmRzOiB0cnVlLFxuKiB9KTtcbiogbW92ZWFibGUub24oXCJjbGlwU3RhcnRcIiwgZSA9PiB7XG4qICAgICBjb25zb2xlLmxvZyhlKTtcbiogfSkub24oXCJjbGlwXCIsIGUgPT4ge1xuKiAgICAgaWYgKGUuY2xpcFR5cGUgPT09IFwicmVjdFwiKSB7XG4qICAgICAgICAgZS50YXJnZXQuc3R5bGUuY2xpcCA9IGUuY2xpcFN0eWxlO1xuKiAgICAgfSBlbHNlIHtcbiogICAgICAgICBlLnRhcmdldC5zdHlsZS5jbGlwUGF0aCA9IGUuY2xpcFN0eWxlO1xuKiAgICAgfVxuKiB9KS5vbihcImNsaXBFbmRcIiwgZSA9PiB7XG4qICAgICBjb25zb2xlLmxvZyhlKTtcbiogfSk7XG4qL1xuXG4vKipcbiogQWRkIGNsaXAgZ3VpZGVsaW5lcyBpbiB0aGUgdmVydGljYWwgZGlyZWN0aW9uLiAoZGVmYXVsdDogW10pXG4qIEBuYW1lIE1vdmVhYmxlLkNsaXBwYWJsZSNjbGlwVmVydGljYWxHdWlkZWxpbmVzXG4qIEBleGFtcGxlXG4qIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbipcbiogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuKiAgICAgY2xpcHBhYmxlOiB0cnVlLFxuKiAgICAgZGVmYXVsdENsaXBQYXRoOiBcImluc2V0XCIsXG4qICAgICBjdXN0b21DbGlwUGF0aDogXCJcIixcbiogICAgIGNsaXBSZWxhdGl2ZTogZmFsc2UsXG4qICAgICBjbGlwQXJlYTogZmFsc2UsXG4qICAgICBkcmFnV2l0aENsaXA6IHRydWUsXG4qICAgICBjbGlwVmVydGljYWxHdWlkZWxpbmVzOiBbMCwgMTAwLCAyMDBdLFxuKiAgICAgY2xpcEhvcml6b250YWxHdWlkZWxpbmVzOiBbMCwgMTAwLCAyMDBdLFxuKiAgICAgY2xpcFNuYXBUaHJlc2hvbGQ6IDUsXG4qIH0pO1xuKi9cblxuLyoqXG4qIEFkZCBjbGlwIGd1aWRlbGluZXMgaW4gdGhlIGhvcml6b250YWwgZGlyZWN0aW9uLiAoZGVmYXVsdDogW10pXG4qIEBuYW1lIE1vdmVhYmxlLkNsaXBwYWJsZSNjbGlwSG9yaXpvbnRhbEd1aWRlbGluZXNcbiogQGV4YW1wbGVcbiogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuKlxuKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4qICAgICBjbGlwcGFibGU6IHRydWUsXG4qICAgICBkZWZhdWx0Q2xpcFBhdGg6IFwiaW5zZXRcIixcbiogICAgIGN1c3RvbUNsaXBQYXRoOiBcIlwiLFxuKiAgICAgY2xpcFJlbGF0aXZlOiBmYWxzZSxcbiogICAgIGNsaXBBcmVhOiBmYWxzZSxcbiogICAgIGRyYWdXaXRoQ2xpcDogdHJ1ZSxcbiogICAgIGNsaXBWZXJ0aWNhbEd1aWRlbGluZXM6IFswLCAxMDAsIDIwMF0sXG4qICAgICBjbGlwSG9yaXpvbnRhbEd1aWRlbGluZXM6IFswLCAxMDAsIDIwMF0sXG4qICAgICBjbGlwU25hcFRocmVzaG9sZDogNSxcbiogfSk7XG4qL1xuXG4vKipcbiogaXN0YW5jZSB2YWx1ZSB0aGF0IGNhbiBzbmFwIHRvIGNsaXAgZ3VpZGVsaW5lcy4gKGRlZmF1bHQ6IDUpXG4qIEBuYW1lIE1vdmVhYmxlLkNsaXBwYWJsZSNjbGlwU25hcFRocmVzaG9sZFxuKiBAZXhhbXBsZVxuKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4qXG4qIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiogICAgIGNsaXBwYWJsZTogdHJ1ZSxcbiogICAgIGRlZmF1bHRDbGlwUGF0aDogXCJpbnNldFwiLFxuKiAgICAgY3VzdG9tQ2xpcFBhdGg6IFwiXCIsXG4qICAgICBjbGlwUmVsYXRpdmU6IGZhbHNlLFxuKiAgICAgY2xpcEFyZWE6IGZhbHNlLFxuKiAgICAgZHJhZ1dpdGhDbGlwOiB0cnVlLFxuKiAgICAgY2xpcFZlcnRpY2FsR3VpZGVsaW5lczogWzAsIDEwMCwgMjAwXSxcbiogICAgIGNsaXBIb3Jpem9udGFsR3VpZGVsaW5lczogWzAsIDEwMCwgMjAwXSxcbiogICAgIGNsaXBTbmFwVGhyZXNob2xkOiA1LFxuKiB9KTtcbiovXG5cbi8qKlxuICogV2hlbiBkcmFnIHN0YXJ0IHRoZSBjbGlwIGFyZWEgb3IgY29udHJvbHMsIHRoZSBgY2xpcFN0YXJ0YCBldmVudCBpcyBjYWxsZWQuXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuQ2xpcHBhYmxlXG4gKiBAZXZlbnQgY2xpcFN0YXJ0XG4gKiBAcGFyYW0ge01vdmVhYmxlLkNsaXBwYWJsZS5PbkNsaXBTdGFydH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYGNsaXBTdGFydGAgZXZlbnRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICAgIGNsaXBwYWJsZTogdHJ1ZSxcbiAqICAgICBkZWZhdWx0Q2xpcFBhdGg6IFwiaW5zZXRcIixcbiAqICAgICBjdXN0b21DbGlwUGF0aDogXCJcIixcbiAqICAgICBjbGlwUmVsYXRpdmU6IGZhbHNlLFxuICogICAgIGNsaXBBcmVhOiBmYWxzZSxcbiAqICAgICBkcmFnV2l0aENsaXA6IHRydWUsXG4gKiB9KTtcbiAqIG1vdmVhYmxlLm9uKFwiY2xpcFN0YXJ0XCIsIGUgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGUpO1xuICogfSkub24oXCJjbGlwXCIsIGUgPT4ge1xuICogICAgIGlmIChlLmNsaXBUeXBlID09PSBcInJlY3RcIikge1xuICogICAgICAgICBlLnRhcmdldC5zdHlsZS5jbGlwID0gZS5jbGlwU3R5bGU7XG4gKiAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgZS50YXJnZXQuc3R5bGUuY2xpcFBhdGggPSBlLmNsaXBTdHlsZTtcbiAqICAgICB9XG4gKiB9KS5vbihcImNsaXBFbmRcIiwgZSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZSk7XG4gKiB9KTtcbiAqL1xuXG4vKipcbiAqIFdoZW4gZHJhZyB0aGUgY2xpcCBhcmVhIG9yIGNvbnRyb2xzLCB0aGUgYGNsaXBgIGV2ZW50IGlzIGNhbGxlZC5cbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5DbGlwcGFibGVcbiAqIEBldmVudCBjbGlwXG4gKiBAcGFyYW0ge01vdmVhYmxlLkNsaXBwYWJsZS5PbkNsaXB9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGBjbGlwYCBldmVudFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgY2xpcHBhYmxlOiB0cnVlLFxuICogICAgIGRlZmF1bHRDbGlwUGF0aDogXCJpbnNldFwiLFxuICogICAgIGN1c3RvbUNsaXBQYXRoOiBcIlwiLFxuICogICAgIGNsaXBSZWxhdGl2ZTogZmFsc2UsXG4gKiAgICAgY2xpcEFyZWE6IGZhbHNlLFxuICogICAgIGRyYWdXaXRoQ2xpcDogdHJ1ZSxcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJjbGlwU3RhcnRcIiwgZSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZSk7XG4gKiB9KS5vbihcImNsaXBcIiwgZSA9PiB7XG4gKiAgICAgaWYgKGUuY2xpcFR5cGUgPT09IFwicmVjdFwiKSB7XG4gKiAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmNsaXAgPSBlLmNsaXBTdHlsZTtcbiAqICAgICB9IGVsc2Uge1xuICogICAgICAgICBlLnRhcmdldC5zdHlsZS5jbGlwUGF0aCA9IGUuY2xpcFN0eWxlO1xuICogICAgIH1cbiAqIH0pLm9uKFwiY2xpcEVuZFwiLCBlID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcbiAqIH0pO1xuICovXG5cbi8qKlxuICogV2hlbiBkcmFnIGVuZCB0aGUgY2xpcCBhcmVhIG9yIGNvbnRyb2xzLCB0aGUgYGNsaXBFbmRgIGV2ZW50IGlzIGNhbGxlZC5cbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5DbGlwcGFibGVcbiAqIEBldmVudCBjbGlwRW5kXG4gKiBAcGFyYW0ge01vdmVhYmxlLkNsaXBwYWJsZS5PbkNsaXBFbmR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGBjbGlwRW5kYCBldmVudFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgY2xpcHBhYmxlOiB0cnVlLFxuICogICAgIGRlZmF1bHRDbGlwUGF0aDogXCJpbnNldFwiLFxuICogICAgIGN1c3RvbUNsaXBQYXRoOiBcIlwiLFxuICogICAgIGNsaXBSZWxhdGl2ZTogZmFsc2UsXG4gKiAgICAgY2xpcEFyZWE6IGZhbHNlLFxuICogICAgIGRyYWdXaXRoQ2xpcDogdHJ1ZSxcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJjbGlwU3RhcnRcIiwgZSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZSk7XG4gKiB9KS5vbihcImNsaXBcIiwgZSA9PiB7XG4gKiAgICAgaWYgKGUuY2xpcFR5cGUgPT09IFwicmVjdFwiKSB7XG4gKiAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmNsaXAgPSBlLmNsaXBTdHlsZTtcbiAqICAgICB9IGVsc2Uge1xuICogICAgICAgICBlLnRhcmdldC5zdHlsZS5jbGlwUGF0aCA9IGUuY2xpcFN0eWxlO1xuICogICAgIH1cbiAqIH0pLm9uKFwiY2xpcEVuZFwiLCBlID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcbiAqIH0pO1xuICovXG5cbi8qKlxuICogQG5hbWVzcGFjZSBPcmlnaW5EcmFnZ2FibGVcbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZVxuICogQGRlc2NyaXB0aW9uIFdoZXRoZXIgdG8gZHJhZyBvcmlnaW4gKGRlZmF1bHQ6IGZhbHNlKVxuICovXG5cbnZhciBPcmlnaW5EcmFnZ2FibGUgPSB7XG4gIG5hbWU6IFwib3JpZ2luRHJhZ2dhYmxlXCIsXG4gIHByb3BzOiB7XG4gICAgb3JpZ2luRHJhZ2dhYmxlOiBCb29sZWFuLFxuICAgIG9yaWdpblJlbGF0aXZlOiBCb29sZWFuXG4gIH0sXG4gIGV2ZW50czoge1xuICAgIG9uRHJhZ09yaWdpblN0YXJ0OiBcImRyYWdPcmlnaW5TdGFydFwiLFxuICAgIG9uRHJhZ09yaWdpbjogXCJkcmFnT3JpZ2luXCIsXG4gICAgb25EcmFnT3JpZ2luRW5kOiBcImRyYWdPcmlnaW5FbmRcIlxuICB9LFxuICBjc3M6IFtcIjpob3N0W2RhdGEtYWJsZS1vcmlnaW5kcmFnZ2FibGVdIC5jb250cm9sLm9yaWdpbiB7XFxuICAgIHBvaW50ZXItZXZlbnRzOiBhdXRvO1xcbn1cIl0sXG4gIGRyYWdDb250cm9sQ29uZGl0aW9uOiBmdW5jdGlvbiAoXywgZSkge1xuICAgIGlmIChlLmlzUmVxdWVzdCkge1xuICAgICAgcmV0dXJuIGUucmVxdWVzdEFibGUgPT09IFwib3JpZ2luRHJhZ2dhYmxlXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhc0NsYXNzKGUuaW5wdXRFdmVudC50YXJnZXQsIHByZWZpeChcIm9yaWdpblwiKSk7XG4gIH0sXG4gIGRyYWdDb250cm9sU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBkYXRhcyA9IGUuZGF0YXM7XG4gICAgc2V0RHJhZ1N0YXJ0KG1vdmVhYmxlLCBlKTtcbiAgICB2YXIgcGFyYW1zID0gZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xuICAgICAgZHJhZ1N0YXJ0OiBEcmFnZ2FibGUuZHJhZ1N0YXJ0KG1vdmVhYmxlLCBuZXcgQ3VzdG9tR2VzdG8oKS5kcmFnU3RhcnQoWzAsIDBdLCBlKSlcbiAgICB9KTtcbiAgICB2YXIgcmVzdWx0ID0gdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uRHJhZ09yaWdpblN0YXJ0XCIsIHBhcmFtcyk7XG4gICAgZGF0YXMuc3RhcnRPcmlnaW4gPSBtb3ZlYWJsZS5zdGF0ZS50cmFuc2Zvcm1PcmlnaW47XG4gICAgZGF0YXMuc3RhcnRUYXJnZXRPcmlnaW4gPSBtb3ZlYWJsZS5zdGF0ZS50YXJnZXRPcmlnaW47XG4gICAgZGF0YXMucHJldk9yaWdpbiA9IFswLCAwXTtcbiAgICBkYXRhcy5pc0RyYWdPcmlnaW4gPSB0cnVlO1xuXG4gICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgIGRhdGFzLmlzRHJhZ09yaWdpbiA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJhbXM7XG4gIH0sXG4gIGRyYWdDb250cm9sOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB2YXIgZGF0YXMgPSBlLmRhdGFzLFxuICAgICAgICBpc1BpbmNoID0gZS5pc1BpbmNoLFxuICAgICAgICBpc1JlcXVlc3QgPSBlLmlzUmVxdWVzdDtcblxuICAgIGlmICghZGF0YXMuaXNEcmFnT3JpZ2luKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIF9hID0gZ2V0RHJhZ0Rpc3QoZSksXG4gICAgICAgIGRpc3RYID0gX2FbMF0sXG4gICAgICAgIGRpc3RZID0gX2FbMV07XG5cbiAgICB2YXIgc3RhdGUgPSBtb3ZlYWJsZS5zdGF0ZTtcbiAgICB2YXIgd2lkdGggPSBzdGF0ZS53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gc3RhdGUuaGVpZ2h0LFxuICAgICAgICBvZmZzZXRNYXRyaXggPSBzdGF0ZS5vZmZzZXRNYXRyaXgsXG4gICAgICAgIHRhcmdldE1hdHJpeCA9IHN0YXRlLnRhcmdldE1hdHJpeCxcbiAgICAgICAgaXMzZCA9IHN0YXRlLmlzM2Q7XG4gICAgdmFyIF9iID0gbW92ZWFibGUucHJvcHMub3JpZ2luUmVsYXRpdmUsXG4gICAgICAgIG9yaWdpblJlbGF0aXZlID0gX2IgPT09IHZvaWQgMCA/IHRydWUgOiBfYjtcbiAgICB2YXIgbiA9IGlzM2QgPyA0IDogMztcbiAgICB2YXIgZGlzdCA9IFtkaXN0WCwgZGlzdFldO1xuXG4gICAgaWYgKGlzUmVxdWVzdCkge1xuICAgICAgdmFyIGRpc3RPcmlnaW4gPSBlLmRpc3RPcmlnaW47XG5cbiAgICAgIGlmIChkaXN0T3JpZ2luWzBdIHx8IGRpc3RPcmlnaW5bMV0pIHtcbiAgICAgICAgZGlzdCA9IGRpc3RPcmlnaW47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG9yaWdpbiA9IHBsdXMoZGF0YXMuc3RhcnRPcmlnaW4sIGRpc3QpO1xuICAgIHZhciB0YXJnZXRPcmlnaW4gPSBwbHVzKGRhdGFzLnN0YXJ0VGFyZ2V0T3JpZ2luLCBkaXN0KTtcbiAgICB2YXIgZGVsdGEgPSBtaW51cyhkaXN0LCBkYXRhcy5wcmV2T3JpZ2luKTtcbiAgICB2YXIgbmV4dE1hdHJpeCA9IGdldE5leHRNYXRyaXgob2Zmc2V0TWF0cml4LCB0YXJnZXRNYXRyaXgsIG9yaWdpbiwgbik7XG4gICAgdmFyIHJlY3QgPSBtb3ZlYWJsZS5nZXRSZWN0KCk7XG4gICAgdmFyIG5leHRSZWN0ID0gZ2V0UmVjdChjYWxjdWxhdGVQb3NlcyhuZXh0TWF0cml4LCB3aWR0aCwgaGVpZ2h0LCBuKSk7XG4gICAgdmFyIGRyYWdEZWx0YSA9IFtyZWN0LmxlZnQgLSBuZXh0UmVjdC5sZWZ0LCByZWN0LnRvcCAtIG5leHRSZWN0LnRvcF07XG4gICAgZGF0YXMucHJldk9yaWdpbiA9IGRpc3Q7XG4gICAgdmFyIHRyYW5zZm9ybU9yaWdpbiA9IFtjb252ZXJ0Q1NTU2l6ZSh0YXJnZXRPcmlnaW5bMF0sIHdpZHRoLCBvcmlnaW5SZWxhdGl2ZSksIGNvbnZlcnRDU1NTaXplKHRhcmdldE9yaWdpblsxXSwgaGVpZ2h0LCBvcmlnaW5SZWxhdGl2ZSldLmpvaW4oXCIgXCIpO1xuICAgIHZhciBwYXJhbXMgPSBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCB7XG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgIG9yaWdpbjogb3JpZ2luLFxuICAgICAgZGlzdDogZGlzdCxcbiAgICAgIGRlbHRhOiBkZWx0YSxcbiAgICAgIHRyYW5zZm9ybU9yaWdpbjogdHJhbnNmb3JtT3JpZ2luLFxuICAgICAgZHJhZzogRHJhZ2dhYmxlLmRyYWcobW92ZWFibGUsIHNldEN1c3RvbURyYWcoZSwgbW92ZWFibGUuc3RhdGUsIGRyYWdEZWx0YSwgISFpc1BpbmNoLCBmYWxzZSkpXG4gICAgfSk7XG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uRHJhZ09yaWdpblwiLCBwYXJhbXMpO1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH0sXG4gIGRyYWdDb250cm9sRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB2YXIgZGF0YXMgPSBlLmRhdGFzO1xuXG4gICAgaWYgKCFkYXRhcy5pc0RyYWdPcmlnaW4pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25EcmFnT3JpZ2luRW5kXCIsIGZpbGxFbmRQYXJhbXMobW92ZWFibGUsIGUsIHt9KSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIGRyYWdHcm91cENvbnRyb2xDb25kaXRpb246IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWdDb250cm9sQ29uZGl0aW9uKG1vdmVhYmxlLCBlKTtcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB2YXIgcGFyYW1zID0gdGhpcy5kcmFnQ29udHJvbFN0YXJ0KG1vdmVhYmxlLCBlKTtcblxuICAgIGlmICghcGFyYW1zKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIGRyYWdHcm91cENvbnRyb2w6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBwYXJhbXMgPSB0aGlzLmRyYWdDb250cm9sKG1vdmVhYmxlLCBlKTtcblxuICAgIGlmICghcGFyYW1zKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbW92ZWFibGUudHJhbnNmb3JtT3JpZ2luID0gcGFyYW1zLnRyYW5zZm9ybU9yaWdpbjtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgKiBAbWV0aG9kIE1vdmVhYmxlLk9yaWdpbkRyYWdnYWJsZSNyZXF1ZXN0XG4gICogQHBhcmFtIHtvYmplY3R9IGUgLSB0aGUgT3JpZ2luRHJhZ2dhYmxlJ3MgcmVxdWVzdCBwYXJhbWV0ZXJcbiAgKiBAcGFyYW0ge251bWJlcn0gW2UueF0gLSB4IHBvc2l0aW9uXG4gICogQHBhcmFtIHtudW1iZXJ9IFtlLnldIC0geSBwb3NpdGlvblxuICAqIEBwYXJhbSB7bnVtYmVyfSBbZS5kZWx0YVhdIC0geCBudW1iZXIgdG8gbW92ZVxuICAqIEBwYXJhbSB7bnVtYmVyfSBbZS5kZWx0YVldIC0geSBudW1iZXIgdG8gbW92ZVxuICAqIEBwYXJhbSB7YXJyYXl9IFtlLmRlbHRhT3JpZ2luXSAtIGxlZnQsIHRvcCBudW1iZXIgdG8gbW92ZSB0cmFuc2Zvcm0tb3JpZ2luXG4gICogQHBhcmFtIHthcnJheX0gW2Uub3JpZ2luXSAtIHRyYW5zZm9ybS1vcmlnaW4gcG9zaXRpb25cbiAgKiBAcGFyYW0ge251bWJlcn0gW2UuaXNJbnN0YW50XSAtIFdoZXRoZXIgdG8gZXhlY3V0ZSB0aGUgcmVxdWVzdCBpbnN0YW50bHlcbiAgKiBAcmV0dXJuIHtNb3ZlYWJsZS5SZXF1ZXN0ZXJ9IE1vdmVhYmxlIFJlcXVlc3RlclxuICAqIEBleGFtcGxlXG4gICAqIC8vIEluc3RhbnRseSBSZXF1ZXN0IChyZXF1ZXN0U3RhcnQgLSByZXF1ZXN0IC0gcmVxdWVzdEVuZClcbiAgKiAvLyBVc2UgUmVsYXRpdmUgVmFsdWVcbiAgKiBtb3ZlYWJsZS5yZXF1ZXN0KFwib3JpZ2luRHJhZ2dhYmxlXCIsIHsgZGVsdGFYOiAxMCwgZGVsdGFZOiAxMCB9LCB0cnVlKTtcbiAgKiAvLyBVc2UgQWJzb2x1dGUgVmFsdWVcbiAgKiBtb3ZlYWJsZS5yZXF1ZXN0KFwib3JpZ2luRHJhZ2dhYmxlXCIsIHsgeDogMjAwLCB5OiAxMDAgfSwgdHJ1ZSk7XG4gICogLy8gVXNlIFRyYW5zZm9ybSBWYWx1ZVxuICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJvcmlnaW5EcmFnZ2FibGVcIiwgeyBkZWx0YU9yaWdpbjogWzEwLCAwXSB9LCB0cnVlKTtcbiAgKiBtb3ZlYWJsZS5yZXF1ZXN0KFwib3JpZ2luRHJhZ2dhYmxlXCIsIHsgb3JpZ2luOiBbMTAwLCAwXSB9LCB0cnVlKTtcbiAgKiAvLyByZXF1ZXN0U3RhcnRcbiAgKiBjb25zdCByZXF1ZXN0ZXIgPSBtb3ZlYWJsZS5yZXF1ZXN0KFwib3JpZ2luRHJhZ2dhYmxlXCIpO1xuICAqXG4gICogLy8gcmVxdWVzdFxuICAqIC8vIFVzZSBSZWxhdGl2ZSBWYWx1ZVxuICAqIHJlcXVlc3Rlci5yZXF1ZXN0KHsgZGVsdGFYOiAxMCwgZGVsdGFZOiAxMCB9KTtcbiAgKiByZXF1ZXN0ZXIucmVxdWVzdCh7IGRlbHRhWDogMTAsIGRlbHRhWTogMTAgfSk7XG4gICogcmVxdWVzdGVyLnJlcXVlc3QoeyBkZWx0YVg6IDEwLCBkZWx0YVk6IDEwIH0pO1xuICAqIC8vIFVzZSBBYnNvbHV0ZSBWYWx1ZVxuICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJvcmlnaW5EcmFnZ2FibGVcIiwgeyB4OiAyMDAsIHk6IDEwMCB9KTtcbiAgKiBtb3ZlYWJsZS5yZXF1ZXN0KFwib3JpZ2luRHJhZ2dhYmxlXCIsIHsgeDogMjIwLCB5OiAxMDAgfSk7XG4gICogbW92ZWFibGUucmVxdWVzdChcIm9yaWdpbkRyYWdnYWJsZVwiLCB7IHg6IDI0MCwgeTogMTAwIH0pO1xuICAqXG4gICogLy8gcmVxdWVzdEVuZFxuICAqIHJlcXVlc3Rlci5yZXF1ZXN0RW5kKCk7XG4gICovXG4gIHJlcXVlc3Q6IGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xuICAgIHZhciBkYXRhcyA9IHt9O1xuICAgIHZhciByZWN0ID0gbW92ZWFibGUuZ2V0UmVjdCgpO1xuICAgIHZhciBkaXN0WCA9IDA7XG4gICAgdmFyIGRpc3RZID0gMDtcbiAgICB2YXIgdHJhbnNmb3JtT3JpZ2luID0gcmVjdC50cmFuc2Zvcm1PcmlnaW47XG4gICAgdmFyIGRpc3RPcmlnaW4gPSBbMCwgMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzQ29udHJvbDogdHJ1ZSxcbiAgICAgIHJlcXVlc3RTdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGFzOiBkYXRhc1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHJlcXVlc3Q6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChcImRlbHRhT3JpZ2luXCIgaW4gZSkge1xuICAgICAgICAgIGRpc3RPcmlnaW5bMF0gKz0gZS5kZWx0YU9yaWdpblswXTtcbiAgICAgICAgICBkaXN0T3JpZ2luWzFdICs9IGUuZGVsdGFPcmlnaW5bMV07XG4gICAgICAgIH0gZWxzZSBpZiAoXCJvcmlnaW5cIiBpbiBlKSB7XG4gICAgICAgICAgZGlzdE9yaWdpblswXSA9IGUub3JpZ2luWzBdIC0gdHJhbnNmb3JtT3JpZ2luWzBdO1xuICAgICAgICAgIGRpc3RPcmlnaW5bMV0gPSBlLm9yaWdpblsxXSAtIHRyYW5zZm9ybU9yaWdpblsxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoXCJ4XCIgaW4gZSkge1xuICAgICAgICAgICAgZGlzdFggPSBlLnggLSByZWN0LmxlZnQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChcImRlbHRhWFwiIGluIGUpIHtcbiAgICAgICAgICAgIGRpc3RYICs9IGUuZGVsdGFYO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChcInlcIiBpbiBlKSB7XG4gICAgICAgICAgICBkaXN0WSA9IGUueSAtIHJlY3QudG9wO1xuICAgICAgICAgIH0gZWxzZSBpZiAoXCJkZWx0YVlcIiBpbiBlKSB7XG4gICAgICAgICAgICBkaXN0WSArPSBlLmRlbHRhWTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGFzOiBkYXRhcyxcbiAgICAgICAgICBkaXN0WDogZGlzdFgsXG4gICAgICAgICAgZGlzdFk6IGRpc3RZLFxuICAgICAgICAgIGRpc3RPcmlnaW46IGRpc3RPcmlnaW5cbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICByZXF1ZXN0RW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YXM6IGRhdGFzLFxuICAgICAgICAgIGlzRHJhZzogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG4vKipcbiAqIFdoZXRoZXIgdG8gZHJhZyBvcmlnaW4gKGRlZmF1bHQ6IGZhbHNlKVxuICogQG5hbWUgTW92ZWFibGUuT3JpZ2luRHJhZ2dhYmxlI29yaWdpbkRyYWdnYWJsZVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgb3JpZ2luRHJhZ2dhYmxlOiB0cnVlLFxuICogfSk7XG4gKiBsZXQgdHJhbnNsYXRlID0gWzAsIDBdO1xuICogbW92ZWFibGUub24oXCJkcmFnT3JpZ2luU3RhcnRcIiwgZSA9PiB7XG4gKiAgICAgZS5kcmFnU3RhcnQgJiYgZS5kcmFnU3RhcnQuc2V0KHRyYW5zbGF0ZSk7XG4gKiB9KS5vbihcImRyYWdPcmlnaW5cIiwgZSA9PiB7XG4gKiAgICAgdHJhbnNsYXRlID0gZS5kcmFnLmJlZm9yZVRyYW5zbGF0ZTtcbiAqICAgICBlLnRhcmdldC5zdHlsZS5jc3NUZXh0XG4gKiAgICAgICAgID0gYHRyYW5zZm9ybS1vcmlnaW46ICR7ZS50cmFuc2Zvcm1PcmlnaW59O2BcbiAqICAgICAgICAgKyBgdHJhbnNmb3JtOiB0cmFuc2xhdGUoJHt0cmFuc2xhdGVbMF19cHgsICR7dHJhbnNsYXRlWzFdfXB4KWA7XG4gKiB9KS5vbihcImRyYWdPcmlnaW5FbmRcIiwgZSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZSk7XG4gKiB9KTtcbiAqL1xuXG4vKipcbiAqICUgQ2FuIGJlIHVzZWQgaW5zdGVhZCBvZiB0aGUgYWJzb2x1dGUgcHggKGRlZmF1bHQ6IHRydWUpXG4gKiBAbmFtZSBNb3ZlYWJsZS5PcmlnaW5EcmFnZ2FibGUjb3JpZ2luUmVsYXRpdmVcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICAgIG9yaWdpbkRyYWdnYWJsZTogdHJ1ZSxcbiAqICAgICBvcmlnaW5SZWxhdGl2ZTogZmFsc2UsXG4gKiB9KTtcbiAqIG1vdmVhYmxlLm9yaWdpblJlbGF0aXZlID0gdHJ1ZTtcbiAqL1xuXG4vKipcbiogV2hlbiBkcmFnIHN0YXJ0IHRoZSBvcmlnaW4sIHRoZSBgZHJhZ09yaWdpblN0YXJ0YCBldmVudCBpcyBjYWxsZWQuXG4qIEBtZW1iZXJvZiBNb3ZlYWJsZS5PcmlnaW5EcmFnZ2FibGVcbiogQGV2ZW50IGRyYWdPcmlnaW5TdGFydFxuKiBAcGFyYW0ge01vdmVhYmxlLk9yaWdpbkRyYWdnYWJsZS5PbkRyYWdPcmlnaW5TdGFydH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYGRyYWdPcmlnaW5TdGFydGAgZXZlbnRcbiogQGV4YW1wbGVcbiogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuKlxuKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4qICAgICBvcmlnaW5EcmFnZ2FibGU6IHRydWUsXG4qIH0pO1xuKiBsZXQgdHJhbnNsYXRlID0gWzAsIDBdO1xuKiBtb3ZlYWJsZS5vbihcImRyYWdPcmlnaW5TdGFydFwiLCBlID0+IHtcbiogICAgIGUuZHJhZ1N0YXJ0ICYmIGUuZHJhZ1N0YXJ0LnNldCh0cmFuc2xhdGUpO1xuKiB9KS5vbihcImRyYWdPcmlnaW5cIiwgZSA9PiB7XG4qICAgICB0cmFuc2xhdGUgPSBlLmRyYWcuYmVmb3JlVHJhbnNsYXRlO1xuKiAgICAgZS50YXJnZXQuc3R5bGUuY3NzVGV4dFxuKiAgICAgICAgID0gYHRyYW5zZm9ybS1vcmlnaW46ICR7ZS50cmFuc2Zvcm1PcmlnaW59O2BcbiogICAgICAgICArIGB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgke3RyYW5zbGF0ZVswXX1weCwgJHt0cmFuc2xhdGVbMV19cHgpYDtcbiogfSkub24oXCJkcmFnT3JpZ2luRW5kXCIsIGUgPT4ge1xuKiAgICAgY29uc29sZS5sb2coZSk7XG4qIH0pO1xuKi9cblxuLyoqXG4qIFdoZW4gZHJhZyB0aGUgb3JpZ2luLCB0aGUgYGRyYWdPcmlnaW5gIGV2ZW50IGlzIGNhbGxlZC5cbiogQG1lbWJlcm9mIE1vdmVhYmxlLk9yaWdpbkRyYWdnYWJsZVxuKiBAZXZlbnQgZHJhZ09yaWdpblxuKiBAcGFyYW0ge01vdmVhYmxlLk9yaWdpbkRyYWdnYWJsZS5PbkRyYWdPcmlnaW59IC0gUGFyYW1ldGVycyBmb3IgdGhlIGBkcmFnT3JpZ2luYCBldmVudFxuKiBAZXhhbXBsZVxuKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4qXG4qIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiogICAgIG9yaWdpbkRyYWdnYWJsZTogdHJ1ZSxcbiogfSk7XG4qIGxldCB0cmFuc2xhdGUgPSBbMCwgMF07XG4qIG1vdmVhYmxlLm9uKFwiZHJhZ09yaWdpblN0YXJ0XCIsIGUgPT4ge1xuKiAgICAgZS5kcmFnU3RhcnQgJiYgZS5kcmFnU3RhcnQuc2V0KHRyYW5zbGF0ZSk7XG4qIH0pLm9uKFwiZHJhZ09yaWdpblwiLCBlID0+IHtcbiogICAgIHRyYW5zbGF0ZSA9IGUuZHJhZy5iZWZvcmVUcmFuc2xhdGU7XG4qICAgICBlLnRhcmdldC5zdHlsZS5jc3NUZXh0XG4qICAgICAgICAgPSBgdHJhbnNmb3JtLW9yaWdpbjogJHtlLnRyYW5zZm9ybU9yaWdpbn07YFxuKiAgICAgICAgICsgYHRyYW5zZm9ybTogdHJhbnNsYXRlKCR7dHJhbnNsYXRlWzBdfXB4LCAke3RyYW5zbGF0ZVsxXX1weClgO1xuKiB9KS5vbihcImRyYWdPcmlnaW5FbmRcIiwgZSA9PiB7XG4qICAgICBjb25zb2xlLmxvZyhlKTtcbiogfSk7XG4qL1xuXG4vKipcbiogV2hlbiBkcmFnIGVuZCB0aGUgb3JpZ2luLCB0aGUgYGRyYWdPcmlnaW5FbmRgIGV2ZW50IGlzIGNhbGxlZC5cbiogQG1lbWJlcm9mIE1vdmVhYmxlLk9yaWdpbkRyYWdnYWJsZVxuKiBAZXZlbnQgZHJhZ09yaWdpbkVuZFxuKiBAcGFyYW0ge01vdmVhYmxlLk9yaWdpbkRyYWdnYWJsZS5PbkRyYWdPcmlnaW5FbmR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGBkcmFnT3JpZ2luRW5kYCBldmVudFxuKiBAZXhhbXBsZVxuKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4qXG4qIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiogICAgIG9yaWdpbkRyYWdnYWJsZTogdHJ1ZSxcbiogfSk7XG4qIGxldCB0cmFuc2xhdGUgPSBbMCwgMF07XG4qIG1vdmVhYmxlLm9uKFwiZHJhZ09yaWdpblN0YXJ0XCIsIGUgPT4ge1xuKiAgICAgZS5kcmFnU3RhcnQgJiYgZS5kcmFnU3RhcnQuc2V0KHRyYW5zbGF0ZSk7XG4qIH0pLm9uKFwiZHJhZ09yaWdpblwiLCBlID0+IHtcbiogICAgIHRyYW5zbGF0ZSA9IGUuZHJhZy5iZWZvcmVUcmFuc2xhdGU7XG4qICAgICBlLnRhcmdldC5zdHlsZS5jc3NUZXh0XG4qICAgICAgICAgPSBgdHJhbnNmb3JtLW9yaWdpbjogJHtlLnRyYW5zZm9ybU9yaWdpbn07YFxuKiAgICAgICAgICsgYHRyYW5zZm9ybTogdHJhbnNsYXRlKCR7dHJhbnNsYXRlWzBdfXB4LCAke3RyYW5zbGF0ZVsxXX1weClgO1xuKiB9KS5vbihcImRyYWdPcmlnaW5FbmRcIiwgZSA9PiB7XG4qICAgICBjb25zb2xlLmxvZyhlKTtcbiogfSk7XG4qL1xuXG5mdW5jdGlvbiBhZGRCb3JkZXJSYWRpdXMoY29udHJvbFBvc2VzLCBwb3NlcywgbGluZUluZGV4LCBkaXN0WCwgZGlzdFksIHdpZHRoLCBoZWlnaHQpIHtcbiAgdmFyIF9hID0gc3BsaXRSYWRpdXNQb3Nlcyhjb250cm9sUG9zZXMpLFxuICAgICAgaG9yaXpvbnRhbHMgPSBfYS5ob3Jpem9udGFscyxcbiAgICAgIHZlcnRpY2FscyA9IF9hLnZlcnRpY2FscztcblxuICB2YXIgaG9yaXpvbnRhbHNMZW5ndGggPSBob3Jpem9udGFscy5sZW5ndGg7XG4gIHZhciB2ZXJ0aWNhbHNMZW5ndGggPSB2ZXJ0aWNhbHMubGVuZ3RoOyAvLyBsaW5lSW5kZXhcbiAgLy8gMCB0b3BcbiAgLy8gMSByaWdodFxuICAvLyAyIGxlZnRcbiAgLy8gMyBib3R0b21cbiAgLy8gMCB0b3AgLSBsZWZ0XG4gIC8vIDEgdG9wIC0gcmlnaHRcbiAgLy8gMiBib3R0b20gLSByaWdodFxuICAvLyAzIGJvdHRvbSAtIGxlZnRcbiAgLy8gMCBsZWZ0IC0gdG9wXG4gIC8vIDEgcmlnaHQgLSB0b3BcbiAgLy8gMiByaWdodCAtIGJvdHRvbVxuICAvLyAzIGxlZnQgLSBib3R0b21cblxuICB2YXIgaG9yaXpvbnRhbEluZGV4ID0gLTE7XG4gIHZhciB2ZXJ0aWNhbEluZGV4ID0gLTE7XG5cbiAgaWYgKGxpbmVJbmRleCA9PT0gMCkge1xuICAgIGlmIChob3Jpem9udGFsc0xlbmd0aCA9PT0gMCkge1xuICAgICAgaG9yaXpvbnRhbEluZGV4ID0gMDtcbiAgICB9IGVsc2UgaWYgKGhvcml6b250YWxzTGVuZ3RoID09PSAxKSB7XG4gICAgICBob3Jpem9udGFsSW5kZXggPSAxO1xuICAgIH1cbiAgfSBlbHNlIGlmIChsaW5lSW5kZXggPT09IDMpIHtcbiAgICBpZiAoaG9yaXpvbnRhbHNMZW5ndGggPD0gMikge1xuICAgICAgaG9yaXpvbnRhbEluZGV4ID0gMjtcbiAgICB9IGVsc2UgaWYgKGhvcml6b250YWxzTGVuZ3RoIDw9IDMpIHtcbiAgICAgIGhvcml6b250YWxJbmRleCA9IDM7XG4gICAgfVxuICB9XG5cbiAgaWYgKGxpbmVJbmRleCA9PT0gMikge1xuICAgIGlmICh2ZXJ0aWNhbHNMZW5ndGggPT09IDApIHtcbiAgICAgIHZlcnRpY2FsSW5kZXggPSAwO1xuICAgIH0gZWxzZSBpZiAodmVydGljYWxzTGVuZ3RoIDwgNCkge1xuICAgICAgdmVydGljYWxJbmRleCA9IDM7XG4gICAgfVxuICB9IGVsc2UgaWYgKGxpbmVJbmRleCA9PT0gMSkge1xuICAgIGlmICh2ZXJ0aWNhbHNMZW5ndGggPD0gMSkge1xuICAgICAgdmVydGljYWxJbmRleCA9IDE7XG4gICAgfSBlbHNlIGlmICh2ZXJ0aWNhbHNMZW5ndGggPD0gMikge1xuICAgICAgdmVydGljYWxJbmRleCA9IDI7XG4gICAgfVxuICB9XG5cbiAgYWRkUmFkaXVzUG9zKGNvbnRyb2xQb3NlcywgcG9zZXMsIDAsIGhvcml6b250YWxJbmRleCwgdmVydGljYWxJbmRleCwgZGlzdFgsIGRpc3RZLCB3aWR0aCwgaGVpZ2h0KTtcbn1cblxuZnVuY3Rpb24gZ2V0Qm9yZGVyUmFkaXVzKHRhcmdldCwgd2lkdGgsIGhlaWdodCwgbWluQ291bnRzLCBzdGF0ZSkge1xuICBpZiAobWluQ291bnRzID09PSB2b2lkIDApIHtcbiAgICBtaW5Db3VudHMgPSBbMCwgMF07XG4gIH1cblxuICB2YXIgYm9yZGVyUmFkaXVzO1xuICB2YXIgdmFsdWVzID0gW107XG5cbiAgaWYgKCFzdGF0ZSkge1xuICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KTtcbiAgICBib3JkZXJSYWRpdXMgPSBzdHlsZSAmJiBzdHlsZS5ib3JkZXJSYWRpdXMgfHwgXCJcIjtcbiAgfSBlbHNlIHtcbiAgICBib3JkZXJSYWRpdXMgPSBzdGF0ZTtcbiAgfVxuXG4gIGlmICghYm9yZGVyUmFkaXVzIHx8ICFzdGF0ZSAmJiBib3JkZXJSYWRpdXMgPT09IFwiMHB4XCIpIHtcbiAgICB2YWx1ZXMgPSBbXTtcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZXMgPSBzcGxpdFNwYWNlKGJvcmRlclJhZGl1cyk7XG4gIH1cblxuICByZXR1cm4gZ2V0UmFkaXVzVmFsdWVzKHZhbHVlcywgd2lkdGgsIGhlaWdodCwgMCwgMCwgbWluQ291bnRzKTtcbn1cblxuZnVuY3Rpb24gdHJpZ2dlclJvdW5kRXZlbnQobW92ZWFibGUsIGUsIGRpc3QsIGRlbHRhLCBjb250cm9sUG9zZXMsIG5leHRQb3Nlcykge1xuICB2YXIgc3RhdGUgPSBtb3ZlYWJsZS5zdGF0ZTtcbiAgdmFyIHdpZHRoID0gc3RhdGUud2lkdGgsXG4gICAgICBoZWlnaHQgPSBzdGF0ZS5oZWlnaHQ7XG5cbiAgdmFyIF9hID0gZ2V0UmFkaXVzU3R5bGVzKG5leHRQb3NlcywgY29udHJvbFBvc2VzLCBtb3ZlYWJsZS5wcm9wcy5yb3VuZFJlbGF0aXZlLCB3aWR0aCwgaGVpZ2h0KSxcbiAgICAgIHJhd3MgPSBfYS5yYXdzLFxuICAgICAgc3R5bGVzID0gX2Euc3R5bGVzO1xuXG4gIHZhciBfYiA9IHNwbGl0UmFkaXVzUG9zZXMoY29udHJvbFBvc2VzLCByYXdzKSxcbiAgICAgIGhvcml6b250YWxzID0gX2IuaG9yaXpvbnRhbHMsXG4gICAgICB2ZXJ0aWNhbHMgPSBfYi52ZXJ0aWNhbHM7XG5cbiAgdmFyIGJvcmRlclJhZGl1cyA9IHN0eWxlcy5qb2luKFwiIFwiKTtcbiAgc3RhdGUuYm9yZGVyUmFkaXVzU3RhdGUgPSBib3JkZXJSYWRpdXM7XG4gIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvblJvdW5kXCIsIGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIHtcbiAgICBob3Jpem9udGFsczogaG9yaXpvbnRhbHMsXG4gICAgdmVydGljYWxzOiB2ZXJ0aWNhbHMsXG4gICAgYm9yZGVyUmFkaXVzOiBib3JkZXJSYWRpdXMsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIGRlbHRhOiBkZWx0YSxcbiAgICBkaXN0OiBkaXN0XG4gIH0pKTtcbn1cbi8qKlxuICogQG5hbWVzcGFjZSBNb3ZlYWJsZS5Sb3VuZGFibGVcbiAqIEBkZXNjcmlwdGlvbiBXaGV0aGVyIHRvIHNob3cgYW5kIGRyYWcgb3IgZG91YmxlIGNsaWNrIGJvcmRlci1yYWRpdXNcbiAqL1xuXG5cbnZhciBSb3VuZGFibGUgPSB7XG4gIG5hbWU6IFwicm91bmRhYmxlXCIsXG4gIHByb3BzOiB7XG4gICAgcm91bmRhYmxlOiBCb29sZWFuLFxuICAgIHJvdW5kUmVsYXRpdmU6IEJvb2xlYW4sXG4gICAgbWluUm91bmRDb250cm9sczogQXJyYXksXG4gICAgbWF4Um91bmRDb250cm9sczogQXJyYXksXG4gICAgcm91bmRDbGlja2FibGU6IEJvb2xlYW5cbiAgfSxcbiAgZXZlbnRzOiB7XG4gICAgb25Sb3VuZFN0YXJ0OiBcInJvdW5kU3RhcnRcIixcbiAgICBvblJvdW5kOiBcInJvdW5kXCIsXG4gICAgb25Sb3VuZEVuZDogXCJyb3VuZEVuZFwiXG4gIH0sXG4gIGNzczogW1wiLmNvbnRyb2wuYm9yZGVyLXJhZGl1cyB7XFxuICAgIGJhY2tncm91bmQ6ICNkNjY7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG59XCIsIFwiOmhvc3RbZGF0YS1hYmxlLXJvdW5kYWJsZV0gLmxpbmUuZGlyZWN0aW9uIHtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbn1cIl0sXG4gIHJlbmRlcjogZnVuY3Rpb24gKG1vdmVhYmxlLCBSZWFjdCkge1xuICAgIHZhciBfYSA9IG1vdmVhYmxlLnN0YXRlLFxuICAgICAgICB0YXJnZXQgPSBfYS50YXJnZXQsXG4gICAgICAgIHdpZHRoID0gX2Eud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF9hLmhlaWdodCxcbiAgICAgICAgYWxsTWF0cml4ID0gX2EuYWxsTWF0cml4LFxuICAgICAgICBpczNkID0gX2EuaXMzZCxcbiAgICAgICAgbGVmdCA9IF9hLmxlZnQsXG4gICAgICAgIHRvcCA9IF9hLnRvcCxcbiAgICAgICAgYm9yZGVyUmFkaXVzU3RhdGUgPSBfYS5ib3JkZXJSYWRpdXNTdGF0ZTtcbiAgICB2YXIgX2IgPSBtb3ZlYWJsZS5wcm9wcyxcbiAgICAgICAgX2MgPSBfYi5taW5Sb3VuZENvbnRyb2xzLFxuICAgICAgICBtaW5Sb3VuZENvbnRyb2xzID0gX2MgPT09IHZvaWQgMCA/IFswLCAwXSA6IF9jLFxuICAgICAgICBfZCA9IF9iLm1heFJvdW5kQ29udHJvbHMsXG4gICAgICAgIG1heFJvdW5kQ29udHJvbHMgPSBfZCA9PT0gdm9pZCAwID8gWzQsIDRdIDogX2QsXG4gICAgICAgIHpvb20gPSBfYi56b29tO1xuXG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBuID0gaXMzZCA/IDQgOiAzO1xuICAgIHZhciByYWRpdXNWYWx1ZXMgPSBnZXRCb3JkZXJSYWRpdXModGFyZ2V0LCB3aWR0aCwgaGVpZ2h0LCBtaW5Sb3VuZENvbnRyb2xzLCBib3JkZXJSYWRpdXNTdGF0ZSk7XG5cbiAgICBpZiAoIXJhZGl1c1ZhbHVlcykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHZlcnRpY2FsQ291bnQgPSAwO1xuICAgIHZhciBob3Jpem9udGFsQ291bnQgPSAwO1xuICAgIHJldHVybiByYWRpdXNWYWx1ZXMubWFwKGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgICBob3Jpem9udGFsQ291bnQgKz0gTWF0aC5hYnModi5ob3Jpem9udGFsKTtcbiAgICAgIHZlcnRpY2FsQ291bnQgKz0gTWF0aC5hYnModi52ZXJ0aWNhbCk7XG4gICAgICB2YXIgcG9zID0gbWludXMoY2FsY3VsYXRlUG9zaXRpb24oYWxsTWF0cml4LCB2LnBvcywgbiksIFtsZWZ0LCB0b3BdKTtcbiAgICAgIHZhciBpc0Rpc3BsYXkgPSB2LnZlcnRpY2FsID8gdmVydGljYWxDb3VudCA8PSBtYXhSb3VuZENvbnRyb2xzWzFdIDogaG9yaXpvbnRhbENvdW50IDw9IG1heFJvdW5kQ29udHJvbHNbMF07XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIGtleTogXCJib3JkZXJSYWRpdXNDb250cm9sXCIgKyBpLFxuICAgICAgICBjbGFzc05hbWU6IHByZWZpeChcImNvbnRyb2xcIiwgXCJib3JkZXItcmFkaXVzXCIpLFxuICAgICAgICBcImRhdGEtcmFkaXVzLWluZGV4XCI6IGksXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgZGlzcGxheTogaXNEaXNwbGF5ID8gXCJibG9ja1wiIDogXCJub25lXCIsXG4gICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIiArIHBvc1swXSArIFwicHgsIFwiICsgcG9zWzFdICsgXCJweCkgc2NhbGUoXCIgKyB6b29tICsgXCIpXCJcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sXG4gIGRyYWdDb250cm9sQ29uZGl0aW9uOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICBpZiAoIWUuaW5wdXRFdmVudCB8fCBlLmlzUmVxdWVzdCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBjbGFzc05hbWUgPSBlLmlucHV0RXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCI7XG4gICAgcmV0dXJuIGNsYXNzTmFtZS5pbmRleE9mKFwiYm9yZGVyLXJhZGl1c1wiKSA+IC0xIHx8IGNsYXNzTmFtZS5pbmRleE9mKFwibW92ZWFibGUtbGluZVwiKSA+IC0xICYmIGNsYXNzTmFtZS5pbmRleE9mKFwibW92ZWFibGUtZGlyZWN0aW9uXCIpID4gLTE7XG4gIH0sXG4gIGRyYWdDb250cm9sU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBpbnB1dEV2ZW50ID0gZS5pbnB1dEV2ZW50LFxuICAgICAgICBkYXRhcyA9IGUuZGF0YXM7XG4gICAgdmFyIGlucHV0VGFyZ2V0ID0gaW5wdXRFdmVudC50YXJnZXQ7XG4gICAgdmFyIGNsYXNzTmFtZSA9IGlucHV0VGFyZ2V0LmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCI7XG4gICAgdmFyIGlzQ29udHJvbCA9IGNsYXNzTmFtZS5pbmRleE9mKFwiYm9yZGVyLXJhZGl1c1wiKSA+IC0xO1xuICAgIHZhciBpc0xpbmUgPSBjbGFzc05hbWUuaW5kZXhPZihcIm1vdmVhYmxlLWxpbmVcIikgPiAtMSAmJiBjbGFzc05hbWUuaW5kZXhPZihcIm1vdmVhYmxlLWRpcmVjdGlvblwiKSA+IC0xO1xuICAgIHZhciBjb250cm9sSW5kZXggPSBpc0NvbnRyb2wgPyBwYXJzZUludChpbnB1dFRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXJhZGl1cy1pbmRleFwiKSwgMTApIDogLTE7XG4gICAgdmFyIGxpbmVJbmRleCA9IGlzTGluZSA/IHBhcnNlSW50KGlucHV0VGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtbGluZS1pbmRleFwiKSwgMTApIDogLTE7XG5cbiAgICBpZiAoIWlzQ29udHJvbCAmJiAhaXNMaW5lKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvblJvdW5kU3RhcnRcIiwgZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge30pKTtcblxuICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZGF0YXMubGluZUluZGV4ID0gbGluZUluZGV4O1xuICAgIGRhdGFzLmNvbnRyb2xJbmRleCA9IGNvbnRyb2xJbmRleDtcbiAgICBkYXRhcy5pc0NvbnRyb2wgPSBpc0NvbnRyb2w7XG4gICAgZGF0YXMuaXNMaW5lID0gaXNMaW5lO1xuICAgIHNldERyYWdTdGFydChtb3ZlYWJsZSwgZSk7XG4gICAgdmFyIF9hID0gbW92ZWFibGUucHJvcHMsXG4gICAgICAgIHJvdW5kUmVsYXRpdmUgPSBfYS5yb3VuZFJlbGF0aXZlLFxuICAgICAgICBfYiA9IF9hLm1pblJvdW5kQ29udHJvbHMsXG4gICAgICAgIG1pblJvdW5kQ29udHJvbHMgPSBfYiA9PT0gdm9pZCAwID8gWzAsIDBdIDogX2I7XG4gICAgdmFyIHN0YXRlID0gbW92ZWFibGUuc3RhdGU7XG4gICAgdmFyIHRhcmdldCA9IHN0YXRlLnRhcmdldCxcbiAgICAgICAgd2lkdGggPSBzdGF0ZS53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gc3RhdGUuaGVpZ2h0O1xuICAgIGRhdGFzLmlzUm91bmQgPSB0cnVlO1xuICAgIGRhdGFzLnByZXZEaXN0ID0gWzAsIDBdO1xuICAgIHZhciBjb250cm9sUG9zZXMgPSBnZXRCb3JkZXJSYWRpdXModGFyZ2V0LCB3aWR0aCwgaGVpZ2h0LCBtaW5Sb3VuZENvbnRyb2xzKSB8fCBbXTtcbiAgICBkYXRhcy5jb250cm9sUG9zZXMgPSBjb250cm9sUG9zZXM7XG4gICAgc3RhdGUuYm9yZGVyUmFkaXVzU3RhdGUgPSBnZXRSYWRpdXNTdHlsZXMoY29udHJvbFBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgICByZXR1cm4gcG9zLnBvcztcbiAgICB9KSwgY29udHJvbFBvc2VzLCByb3VuZFJlbGF0aXZlLCB3aWR0aCwgaGVpZ2h0KS5zdHlsZXMuam9pbihcIiBcIik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIGRyYWdDb250cm9sOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB2YXIgZGF0YXMgPSBlLmRhdGFzO1xuXG4gICAgaWYgKCFkYXRhcy5pc1JvdW5kIHx8ICFkYXRhcy5pc0NvbnRyb2wgfHwgIWRhdGFzLmNvbnRyb2xQb3Nlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSBkYXRhcy5jb250cm9sSW5kZXg7XG4gICAgdmFyIGNvbnRyb2xQb3NlcyA9IGRhdGFzLmNvbnRyb2xQb3NlcztcblxuICAgIHZhciBfYSA9IGdldERyYWdEaXN0KGUpLFxuICAgICAgICBkaXN0WCA9IF9hWzBdLFxuICAgICAgICBkaXN0WSA9IF9hWzFdO1xuXG4gICAgdmFyIGRpc3QgPSBbZGlzdFgsIGRpc3RZXTtcbiAgICB2YXIgZGVsdGEgPSBtaW51cyhkaXN0LCBkYXRhcy5wcmV2RGlzdCk7XG4gICAgdmFyIF9iID0gbW92ZWFibGUucHJvcHMubWF4Um91bmRDb250cm9scyxcbiAgICAgICAgbWF4Um91bmRDb250cm9scyA9IF9iID09PSB2b2lkIDAgPyBbNCwgNF0gOiBfYjtcbiAgICB2YXIgX2MgPSBtb3ZlYWJsZS5zdGF0ZSxcbiAgICAgICAgd2lkdGggPSBfYy53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX2MuaGVpZ2h0O1xuICAgIHZhciBzZWxlY3RlZENvbnRyb2xQb3NlID0gY29udHJvbFBvc2VzW2luZGV4XTtcbiAgICB2YXIgc2VsZWN0ZWRWZXJ0aWNhbCA9IHNlbGVjdGVkQ29udHJvbFBvc2UudmVydGljYWw7XG4gICAgdmFyIHNlbGVjdGVkSG9yaXpvbnRhbCA9IHNlbGVjdGVkQ29udHJvbFBvc2UuaG9yaXpvbnRhbDsgLy8gMDogWzAsIDEsIDIsIDNdIG1heENvdW50ID09PSAxXG4gICAgLy8gMDogWzAsIDJdIG1heENvdW50ID09PSAyXG4gICAgLy8gMTogWzEsIDNdIG1heENvdW50ID09PSAyXG4gICAgLy8gMDogWzBdIG1heENvdW50ID09PSAzXG4gICAgLy8gMTogWzEsIDNdIG1heENvdW50ID09PSAzXG5cbiAgICB2YXIgZGlzdHMgPSBjb250cm9sUG9zZXMubWFwKGZ1bmN0aW9uIChwb3NlKSB7XG4gICAgICB2YXIgaG9yaXpvbnRhbCA9IHBvc2UuaG9yaXpvbnRhbCxcbiAgICAgICAgICB2ZXJ0aWNhbCA9IHBvc2UudmVydGljYWw7XG4gICAgICB2YXIgcG9zZURpc3QgPSBbaG9yaXpvbnRhbCAqIHNlbGVjdGVkSG9yaXpvbnRhbCAqIGRpc3RbMF0sIHZlcnRpY2FsICogc2VsZWN0ZWRWZXJ0aWNhbCAqIGRpc3RbMV1dO1xuXG4gICAgICBpZiAoaG9yaXpvbnRhbCkge1xuICAgICAgICBpZiAobWF4Um91bmRDb250cm9sc1swXSA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiBwb3NlRGlzdDtcbiAgICAgICAgfSBlbHNlIGlmIChtYXhSb3VuZENvbnRyb2xzWzBdIDwgNCAmJiBob3Jpem9udGFsICE9PSBzZWxlY3RlZEhvcml6b250YWwpIHtcbiAgICAgICAgICByZXR1cm4gcG9zZURpc3Q7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobWF4Um91bmRDb250cm9sc1sxXSA9PT0gMCkge1xuICAgICAgICBwb3NlRGlzdFsxXSA9IHZlcnRpY2FsICogc2VsZWN0ZWRIb3Jpem9udGFsICogZGlzdFswXSAvIHdpZHRoICogaGVpZ2h0O1xuICAgICAgICByZXR1cm4gcG9zZURpc3Q7XG4gICAgICB9IGVsc2UgaWYgKHNlbGVjdGVkVmVydGljYWwpIHtcbiAgICAgICAgaWYgKG1heFJvdW5kQ29udHJvbHNbMV0gPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gcG9zZURpc3Q7XG4gICAgICAgIH0gZWxzZSBpZiAobWF4Um91bmRDb250cm9sc1sxXSA8IDQgJiYgdmVydGljYWwgIT09IHNlbGVjdGVkVmVydGljYWwpIHtcbiAgICAgICAgICByZXR1cm4gcG9zZURpc3Q7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFswLCAwXTtcbiAgICB9KTtcbiAgICBkaXN0c1tpbmRleF0gPSBkaXN0O1xuICAgIHZhciBuZXh0UG9zZXMgPSBjb250cm9sUG9zZXMubWFwKGZ1bmN0aW9uIChwb3MsIGkpIHtcbiAgICAgIHJldHVybiBwbHVzKHBvcy5wb3MsIGRpc3RzW2ldKTtcbiAgICB9KTtcbiAgICBkYXRhcy5wcmV2RGlzdCA9IFtkaXN0WCwgZGlzdFldO1xuICAgIHRyaWdnZXJSb3VuZEV2ZW50KG1vdmVhYmxlLCBlLCBkaXN0LCBkZWx0YSwgY29udHJvbFBvc2VzLCBuZXh0UG9zZXMpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBkcmFnQ29udHJvbEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIHN0YXRlID0gbW92ZWFibGUuc3RhdGU7XG4gICAgc3RhdGUuYm9yZGVyUmFkaXVzU3RhdGUgPSBcIlwiO1xuICAgIHZhciBkYXRhcyA9IGUuZGF0YXMsXG4gICAgICAgIGlzRG91YmxlID0gZS5pc0RvdWJsZTtcblxuICAgIGlmICghZGF0YXMuaXNSb3VuZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciB3aWR0aCA9IHN0YXRlLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBzdGF0ZS5oZWlnaHQ7XG4gICAgdmFyIGlzQ29udHJvbCA9IGRhdGFzLmlzQ29udHJvbCxcbiAgICAgICAgY29udHJvbEluZGV4ID0gZGF0YXMuY29udHJvbEluZGV4LFxuICAgICAgICBpc0xpbmUgPSBkYXRhcy5pc0xpbmUsXG4gICAgICAgIGxpbmVJbmRleCA9IGRhdGFzLmxpbmVJbmRleDtcbiAgICB2YXIgY29udHJvbFBvc2VzID0gZGF0YXMuY29udHJvbFBvc2VzO1xuICAgIHZhciBwb3NlcyA9IGNvbnRyb2xQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgICAgcmV0dXJuIHBvcy5wb3M7XG4gICAgfSk7XG4gICAgdmFyIGxlbmd0aCA9IHBvc2VzLmxlbmd0aDtcbiAgICB2YXIgX2EgPSBtb3ZlYWJsZS5wcm9wcy5yb3VuZENsaWNrYWJsZSxcbiAgICAgICAgcm91bmRDbGlja2FibGUgPSBfYSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9hO1xuXG4gICAgaWYgKGlzRG91YmxlICYmIHJvdW5kQ2xpY2thYmxlKSB7XG4gICAgICBpZiAoaXNDb250cm9sKSB7XG4gICAgICAgIHJlbW92ZVJhZGl1c1Bvcyhjb250cm9sUG9zZXMsIHBvc2VzLCBjb250cm9sSW5kZXgsIDApO1xuICAgICAgfSBlbHNlIGlmIChpc0xpbmUpIHtcbiAgICAgICAgdmFyIF9iID0gY2FsY3VsYXRlUG9pbnRlckRpc3QobW92ZWFibGUsIGUpLFxuICAgICAgICAgICAgZGlzdFggPSBfYlswXSxcbiAgICAgICAgICAgIGRpc3RZID0gX2JbMV07XG5cbiAgICAgICAgYWRkQm9yZGVyUmFkaXVzKGNvbnRyb2xQb3NlcywgcG9zZXMsIGxpbmVJbmRleCwgZGlzdFgsIGRpc3RZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxlbmd0aCAhPT0gY29udHJvbFBvc2VzLmxlbmd0aCkge1xuICAgICAgICB0cmlnZ2VyUm91bmRFdmVudChtb3ZlYWJsZSwgZSwgWzAsIDBdLCBbMCwgMF0sIGNvbnRyb2xQb3NlcywgcG9zZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvblJvdW5kRW5kXCIsIGZpbGxFbmRQYXJhbXMobW92ZWFibGUsIGUsIHt9KSk7XG4gICAgc3RhdGUuYm9yZGVyUmFkaXVzU3RhdGUgPSBcIlwiO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICB1bnNldDogZnVuY3Rpb24gKG1vdmVhYmxlKSB7XG4gICAgbW92ZWFibGUuc3RhdGUuYm9yZGVyUmFkaXVzU3RhdGUgPSBcIlwiO1xuICB9XG59O1xuLyoqXG4gKiBXaGV0aGVyIHRvIHNob3cgYW5kIGRyYWcgb3IgZG91YmxlIGNsaWNrIGJvcmRlci1yYWRpdXMsIChkZWZhdWx0OiBmYWxzZSlcbiAqIEBuYW1lIE1vdmVhYmxlLlJvdW5kYWJsZSNyb3VuZGFibGVcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICAgIHJvdW5kYWJsZTogdHJ1ZSxcbiAqICAgICByb3VuZFJlbGF0aXZlOiBmYWxzZSxcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJyb3VuZFN0YXJ0XCIsIGUgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGUpO1xuICogfSkub24oXCJyb3VuZFwiLCBlID0+IHtcbiAqICAgICBlLnRhcmdldC5zdHlsZS5ib3JkZXJSYWRpdXMgPSBlLmJvcmRlclJhZGl1cztcbiAqIH0pLm9uKFwicm91bmRFbmRcIiwgZSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZSk7XG4gKiB9KTtcbiAqL1xuXG4vKipcbiAqICUgQ2FuIGJlIHVzZWQgaW5zdGVhZCBvZiB0aGUgYWJzb2x1dGUgcHhcbiAqIEBuYW1lIE1vdmVhYmxlLlJvdW5kYWJsZSNyb3VuZFJlbGF0aXZlXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgICByb3VuZGFibGU6IHRydWUsXG4gKiAgICAgcm91bmRSZWxhdGl2ZTogZmFsc2UsXG4gKiB9KTtcbiAqIG1vdmVhYmxlLm9uKFwicm91bmRTdGFydFwiLCBlID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcbiAqIH0pLm9uKFwicm91bmRcIiwgZSA9PiB7XG4gKiAgICAgZS50YXJnZXQuc3R5bGUuYm9yZGVyUmFkaXVzID0gZS5ib3JkZXJSYWRpdXM7XG4gKiB9KS5vbihcInJvdW5kRW5kXCIsIGUgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGUpO1xuICogfSk7XG4gKi9cblxuLyoqXG4gKiBNaW5pbXVtIG51bWJlciBvZiByb3VuZCBjb250cm9scy4gSXQgbW92ZXMgaW4gcHJvcG9ydGlvbiBieSBjb250cm9sLiBbaG9yaXpvbnRhbCwgdmVydGljYWxdIChkZWZhdWx0OiBbMCwgMF0pXG4gKiBAbmFtZSBNb3ZlYWJsZS5Sb3VuZGFibGUjbWluUm91bmRDb250cm9sc1xuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgcm91bmRhYmxlOiB0cnVlLFxuICogICAgIHJvdW5kUmVsYXRpdmU6IGZhbHNlLFxuICogICAgIG1pblJvdW5kQ29udHJvbHM6IFswLCAwXSxcbiAqIH0pO1xuICogbW92ZWFibGUubWF4Um91bmRDb250cm9scyA9IFsxLCAwXTtcbiAqL1xuXG4vKipcbiAqIE1heGltdW0gbnVtYmVyIG9mIHJvdW5kIGNvbnRyb2xzLiBJdCBtb3ZlcyBpbiBwcm9wb3J0aW9uIGJ5IGNvbnRyb2wuIFtob3Jpem9udGFsLCB2ZXJ0aWNhbF0gKGRlZmF1bHQ6IFs0LCA0XSlcbiAqIEBuYW1lIE1vdmVhYmxlLlJvdW5kYWJsZSNtYXhSb3VuZENvbnRyb2xzXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgICByb3VuZGFibGU6IHRydWUsXG4gKiAgICAgcm91bmRSZWxhdGl2ZTogZmFsc2UsXG4gKiAgICAgbWF4Um91bmRDb250cm9sczogWzQsIDRdLFxuICogfSk7XG4gKiBtb3ZlYWJsZS5tYXhSb3VuZENvbnRyb2xzID0gWzEsIDBdO1xuICovXG5cbi8qKlxuICogQHByb3BlcnR5IC0gV2hldGhlciB5b3UgY2FuIGFkZC9kZWxldGUgcm91bmQgY29udHJvbHMgYnkgZG91YmxlLWNsaWNraW5nIGEgbGluZSBvciBjb250cm9sLiAoZGVmYXVsdDogdHJ1ZSlcbiAqIEBuYW1lIE1vdmVhYmxlLlJvdW5kYWJsZSNyb3VuZENsaWNrYWJsZVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgcm91bmRhYmxlOiB0cnVlLFxuICogICAgIHJvdW5kUmVsYXRpdmU6IGZhbHNlLFxuICogICAgIHJvdW5kQ2xpY2thYmxlOiB0cnVlLFxuICogfSk7XG4gKiBtb3ZlYWJsZS5yb3VuZENsaWNrYWJsZSA9IGZhbHNlO1xuICovXG5cbi8qKlxuICogV2hlbiBkcmFnIHN0YXJ0IHRoZSBjbGlwIGFyZWEgb3IgY29udHJvbHMsIHRoZSBgcm91bmRTdGFydGAgZXZlbnQgaXMgY2FsbGVkLlxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlJvdW5kYWJsZVxuICogQGV2ZW50IHJvdW5kU3RhcnRcbiAqIEBwYXJhbSB7TW92ZWFibGUuUm91bmRhYmxlLk9uUm91bmRTdGFydH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHJvdW5kU3RhcnRgIGV2ZW50XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgICByb3VuZGFibGU6IHRydWUsXG4gKiAgICAgcm91bmRSZWxhdGl2ZTogZmFsc2UsXG4gKiB9KTtcbiAqIG1vdmVhYmxlLm9uKFwicm91bmRTdGFydFwiLCBlID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcbiAqIH0pLm9uKFwicm91bmRcIiwgZSA9PiB7XG4gKiAgICAgZS50YXJnZXQuc3R5bGUuYm9yZGVyUmFkaXVzID0gZS5ib3JkZXJSYWRpdXM7XG4gKiB9KS5vbihcInJvdW5kRW5kXCIsIGUgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGUpO1xuICogfSk7XG4gKi9cblxuLyoqXG4gKiBXaGVuIGRyYWcgb3IgZG91YmxlIGNsaWNrIHRoZSBib3JkZXIgYXJlYSBvciBjb250cm9scywgdGhlIGByb3VuZGAgZXZlbnQgaXMgY2FsbGVkLlxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlJvdW5kYWJsZVxuICogQGV2ZW50IHJvdW5kXG4gKiBAcGFyYW0ge01vdmVhYmxlLlJvdW5kYWJsZS5PblJvdW5kfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgcm91bmRgIGV2ZW50XG4gKiBAZXhhbXBsZVxuICAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgcm91bmRhYmxlOiB0cnVlLFxuICogICAgIHJvdW5kUmVsYXRpdmU6IGZhbHNlLFxuICogfSk7XG4gKiBtb3ZlYWJsZS5vbihcInJvdW5kU3RhcnRcIiwgZSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZSk7XG4gKiB9KS5vbihcInJvdW5kXCIsIGUgPT4ge1xuICogICAgIGUudGFyZ2V0LnN0eWxlLmJvcmRlclJhZGl1cyA9IGUuYm9yZGVyUmFkaXVzO1xuICogfSkub24oXCJyb3VuZEVuZFwiLCBlID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcbiAqIH0pO1xuICovXG5cbi8qKlxuICogV2hlbiBkcmFnIGVuZCB0aGUgYm9yZGVyIGFyZWEgb3IgY29udHJvbHMsIHRoZSBgcm91bmRFbmRgIGV2ZW50IGlzIGNhbGxlZC5cbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5Sb3VuZGFibGVcbiAqIEBldmVudCByb3VuZEVuZFxuICogQHBhcmFtIHtNb3ZlYWJsZS5Sb3VuZGFibGUub25Sb3VuZEVuZH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHJvdW5kRW5kYCBldmVudFxuICogQGV4YW1wbGVcbiAgKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICAgIHJvdW5kYWJsZTogdHJ1ZSxcbiAqICAgICByb3VuZFJlbGF0aXZlOiBmYWxzZSxcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJyb3VuZFN0YXJ0XCIsIGUgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGUpO1xuICogfSkub24oXCJyb3VuZFwiLCBlID0+IHtcbiAqICAgICBlLnRhcmdldC5zdHlsZS5ib3JkZXJSYWRpdXMgPSBlLmJvcmRlclJhZGl1cztcbiAqIH0pLm9uKFwicm91bmRFbmRcIiwgZSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZSk7XG4gKiB9KTtcbiAqL1xuXG5mdW5jdGlvbiBpc0lkZW50aXR5TWF0cml4KG1hdHJpeCwgaXMzZCkge1xuICB2YXIgdmFsdWUgPSBpczNkID8gXCJtYXRyaXgzZChcIiArIGNyZWF0ZUlkZW50aXR5TWF0cml4KDQpIDogXCJtYXRyaXgoXCIgKyBjcmVhdGVJZGVudGl0eU1hdHJpeCgzKSArIFwiKVwiO1xuICByZXR1cm4gbWF0cml4ID09PSB2YWx1ZSB8fCBtYXRyaXggPT09IFwibWF0cml4KDEsMCwwLDEsMCwwKVwiO1xufVxuXG52YXIgQmVmb3JlUmVuZGVyYWJsZSA9IHtcbiAgaXNQaW5jaDogdHJ1ZSxcbiAgbmFtZTogXCJiZWZvcmVSZW5kZXJhYmxlXCIsXG4gIHByb3BzOiB7fSxcbiAgZXZlbnRzOiB7XG4gICAgb25CZWZvcmVSZW5kZXJTdGFydDogXCJiZWZvcmVSZW5kZXJTdGFydFwiLFxuICAgIG9uQmVmb3JlUmVuZGVyOiBcImJlZm9yZVJlbmRlclwiLFxuICAgIG9uQmVmb3JlUmVuZGVyRW5kOiBcImJlZm9yZVJlbmRlckVuZFwiLFxuICAgIG9uQmVmb3JlUmVuZGVyR3JvdXBTdGFydDogXCJiZWZvcmVSZW5kZXJHcm91cFN0YXJ0XCIsXG4gICAgb25CZWZvcmVSZW5kZXJHcm91cDogXCJiZWZvcmVSZW5kZXJHcm91cFwiLFxuICAgIG9uQmVmb3JlUmVuZGVyR3JvdXBFbmQ6IFwiYmVmb3JlUmVuZGVyR3JvdXBFbmRcIlxuICB9LFxuICBkcmFnUmVsYXRpb246IFwid2Vha1wiLFxuICBzZXRUcmFuc2Zvcm06IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBfYSA9IG1vdmVhYmxlLnN0YXRlLFxuICAgICAgICBpczNkID0gX2EuaXMzZCxcbiAgICAgICAgdGFyZ2V0ID0gX2EudGFyZ2V0LFxuICAgICAgICB0YXJnZXRNYXRyaXggPSBfYS50YXJnZXRNYXRyaXg7XG4gICAgdmFyIHRyYW5zZm9ybSA9IHRhcmdldCA9PT0gbnVsbCB8fCB0YXJnZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhcmdldC5zdHlsZS50cmFuc2Zvcm07XG4gICAgdmFyIGNzc01hdHJpeCA9IGlzM2QgPyBcIm1hdHJpeDNkKFwiICsgdGFyZ2V0TWF0cml4LmpvaW4oXCIsXCIpICsgXCIpXCIgOiBcIm1hdHJpeChcIiArIGNvbnZlcnRNYXRyaXh0b0NTUyh0YXJnZXRNYXRyaXgsIHRydWUpICsgXCIpXCI7XG4gICAgdmFyIHN0YXJ0VHJhbnNmb3JtID0gIXRyYW5zZm9ybSB8fCB0cmFuc2Zvcm0gPT09IFwibm9uZVwiID8gY3NzTWF0cml4IDogdHJhbnNmb3JtO1xuICAgIGUuZGF0YXMuc3RhcnRUcmFuc2Zvcm1zID0gaXNJZGVudGl0eU1hdHJpeChzdGFydFRyYW5zZm9ybSwgaXMzZCkgPyBbXSA6IHNwbGl0U3BhY2Uoc3RhcnRUcmFuc2Zvcm0pO1xuICB9LFxuICByZXNldFRyYW5zZm9ybTogZnVuY3Rpb24gKGUpIHtcbiAgICBlLmRhdGFzLm5leHRUcmFuc2Zvcm1zID0gZS5kYXRhcy5zdGFydFRyYW5zZm9ybXM7XG4gICAgZS5kYXRhcy5uZXh0VHJhbnNmb3JtQXBwZW5kZWRJbmRleGVzID0gW107XG4gIH0sXG4gIGZpbGxEcmFnU3RhcnRQYXJhbXM6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCB7XG4gICAgICBzZXRUcmFuc2Zvcm06IGZ1bmN0aW9uICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgZS5kYXRhcy5zdGFydFRyYW5zZm9ybXMgPSBpc0FycmF5KHRyYW5zZm9ybSkgPyB0cmFuc2Zvcm0gOiBzcGxpdFNwYWNlKHRyYW5zZm9ybSk7XG4gICAgICB9LFxuICAgICAgaXNQaW5jaDogISFlLmlzUGluY2hcbiAgICB9KTtcbiAgfSxcbiAgZmlsbERyYWdQYXJhbXM6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCB7XG4gICAgICBpc1BpbmNoOiAhIWUuaXNQaW5jaFxuICAgIH0pO1xuICB9LFxuICBkcmFnU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHRoaXMuc2V0VHJhbnNmb3JtKG1vdmVhYmxlLCBlKTtcbiAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25CZWZvcmVSZW5kZXJTdGFydFwiLCB0aGlzLmZpbGxEcmFnU3RhcnRQYXJhbXMobW92ZWFibGUsIGUpKTtcbiAgfSxcbiAgZHJhZzogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdGhpcy5yZXNldFRyYW5zZm9ybShlKTtcbiAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25CZWZvcmVSZW5kZXJcIiwgZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xuICAgICAgaXNQaW5jaDogISFlLmlzUGluY2hcbiAgICB9KSk7XG4gIH0sXG4gIGRyYWdFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkJlZm9yZVJlbmRlckVuZFwiLCBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCB7XG4gICAgICBpc1BpbmNoOiAhIWUuaXNQaW5jaCxcbiAgICAgIGlzRHJhZzogZS5pc0RyYWdcbiAgICB9KSk7XG4gIH0sXG4gIGRyYWdHcm91cFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5kcmFnU3RhcnQobW92ZWFibGUsIGUpO1xuICAgIHZhciBldmVudHMgPSBmaWxsQ2hpbGRFdmVudHMobW92ZWFibGUsIFwiYmVmb3JlUmVuZGVyYWJsZVwiLCBlKTtcbiAgICB2YXIgbW92ZWFibGVzID0gbW92ZWFibGUubW92ZWFibGVzO1xuICAgIHZhciBwYXJhbXMgPSBldmVudHMubWFwKGZ1bmN0aW9uIChjaGlsZEV2ZW50LCBpKSB7XG4gICAgICB2YXIgY2hpbGRNb3ZlYWJsZSA9IG1vdmVhYmxlc1tpXTtcblxuICAgICAgX3RoaXMuc2V0VHJhbnNmb3JtKGNoaWxkTW92ZWFibGUsIGNoaWxkRXZlbnQpO1xuXG4gICAgICByZXR1cm4gX3RoaXMuZmlsbERyYWdTdGFydFBhcmFtcyhjaGlsZE1vdmVhYmxlLCBjaGlsZEV2ZW50KTtcbiAgICB9KTtcbiAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25CZWZvcmVSZW5kZXJHcm91cFN0YXJ0XCIsIGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIHtcbiAgICAgIGlzUGluY2g6ICEhZS5pc1BpbmNoLFxuICAgICAgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0cyxcbiAgICAgIHNldFRyYW5zZm9ybTogZnVuY3Rpb24gKCkge30sXG4gICAgICBldmVudHM6IHBhcmFtc1xuICAgIH0pKTtcbiAgfSxcbiAgZHJhZ0dyb3VwOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5kcmFnKG1vdmVhYmxlLCBlKTtcbiAgICB2YXIgZXZlbnRzID0gZmlsbENoaWxkRXZlbnRzKG1vdmVhYmxlLCBcImJlZm9yZVJlbmRlcmFibGVcIiwgZSk7XG4gICAgdmFyIG1vdmVhYmxlcyA9IG1vdmVhYmxlLm1vdmVhYmxlcztcbiAgICB2YXIgcGFyYW1zID0gZXZlbnRzLm1hcChmdW5jdGlvbiAoY2hpbGRFdmVudCwgaSkge1xuICAgICAgdmFyIGNoaWxkTW92ZWFibGUgPSBtb3ZlYWJsZXNbaV07XG5cbiAgICAgIF90aGlzLnJlc2V0VHJhbnNmb3JtKGNoaWxkRXZlbnQpO1xuXG4gICAgICByZXR1cm4gX3RoaXMuZmlsbERyYWdQYXJhbXMoY2hpbGRNb3ZlYWJsZSwgY2hpbGRFdmVudCk7XG4gICAgfSk7XG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uQmVmb3JlUmVuZGVyR3JvdXBcIiwgZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xuICAgICAgaXNQaW5jaDogISFlLmlzUGluY2gsXG4gICAgICB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzLFxuICAgICAgZXZlbnRzOiBwYXJhbXNcbiAgICB9KSk7XG4gIH0sXG4gIGRyYWdHcm91cEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdGhpcy5kcmFnRW5kKG1vdmVhYmxlLCBlKTtcbiAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25CZWZvcmVSZW5kZXJHcm91cEVuZFwiLCBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCB7XG4gICAgICBpc1BpbmNoOiAhIWUuaXNQaW5jaCxcbiAgICAgIGlzRHJhZzogZS5pc0RyYWcsXG4gICAgICB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzXG4gICAgfSkpO1xuICB9LFxuICBkcmFnQ29udHJvbFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnU3RhcnQobW92ZWFibGUsIGUpO1xuICB9LFxuICBkcmFnQ29udHJvbDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZyhtb3ZlYWJsZSwgZSk7XG4gIH0sXG4gIGRyYWdDb250cm9sRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnRW5kKG1vdmVhYmxlLCBlKTtcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnR3JvdXBTdGFydChtb3ZlYWJsZSwgZSk7XG4gIH0sXG4gIGRyYWdHcm91cENvbnRyb2w6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWdHcm91cChtb3ZlYWJsZSwgZSk7XG4gIH0sXG4gIGRyYWdHcm91cENvbnRyb2xFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWdHcm91cEVuZChtb3ZlYWJsZSwgZSk7XG4gIH1cbn07XG5cbnZhciBSZW5kZXJhYmxlID0ge1xuICBuYW1lOiBcInJlbmRlcmFibGVcIixcbiAgcHJvcHM6IHt9LFxuICBldmVudHM6IHtcbiAgICBvblJlbmRlclN0YXJ0OiBcInJlbmRlclN0YXJ0XCIsXG4gICAgb25SZW5kZXI6IFwicmVuZGVyXCIsXG4gICAgb25SZW5kZXJFbmQ6IFwicmVuZGVyRW5kXCIsXG4gICAgb25SZW5kZXJHcm91cFN0YXJ0OiBcInJlbmRlckdyb3VwU3RhcnRcIixcbiAgICBvblJlbmRlckdyb3VwOiBcInJlbmRlckdyb3VwXCIsXG4gICAgb25SZW5kZXJHcm91cEVuZDogXCJyZW5kZXJHcm91cEVuZFwiXG4gIH0sXG4gIGRyYWdSZWxhdGlvbjogXCJ3ZWFrXCIsXG4gIGRyYWdTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUmVuZGVyU3RhcnRcIiwgZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xuICAgICAgaXNQaW5jaDogISFlLmlzUGluY2hcbiAgICB9KSk7XG4gIH0sXG4gIGRyYWc6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvblJlbmRlclwiLCB0aGlzLmZpbGxEcmFnUGFyYW1zKG1vdmVhYmxlLCBlKSk7XG4gIH0sXG4gIGRyYWdBZnRlcjogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgaWYgKGUucmVzdWx0Q291bnQpIHtcbiAgICAgIHJldHVybiB0aGlzLmRyYWcobW92ZWFibGUsIGUpO1xuICAgIH1cbiAgfSxcbiAgZHJhZ0VuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUmVuZGVyRW5kXCIsIHRoaXMuZmlsbERyYWdFbmRQYXJhbXMobW92ZWFibGUsIGUpKTtcbiAgfSxcbiAgZHJhZ0dyb3VwU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvblJlbmRlckdyb3VwU3RhcnRcIiwgZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xuICAgICAgaXNQaW5jaDogISFlLmlzUGluY2gsXG4gICAgICB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzXG4gICAgfSkpO1xuICB9LFxuICBkcmFnR3JvdXA6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgZXZlbnRzID0gZmlsbENoaWxkRXZlbnRzKG1vdmVhYmxlLCBcImJlZm9yZVJlbmRlcmFibGVcIiwgZSk7XG4gICAgdmFyIG1vdmVhYmxlcyA9IG1vdmVhYmxlLm1vdmVhYmxlcztcbiAgICB2YXIgcGFyYW1zID0gZXZlbnRzLm1hcChmdW5jdGlvbiAoY2hpbGRFdmVudCwgaSkge1xuICAgICAgdmFyIGNoaWxkTW92ZWFibGUgPSBtb3ZlYWJsZXNbaV07XG4gICAgICByZXR1cm4gX3RoaXMuZmlsbERyYWdQYXJhbXMoY2hpbGRNb3ZlYWJsZSwgY2hpbGRFdmVudCk7XG4gICAgfSk7XG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUmVuZGVyR3JvdXBcIiwgZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xuICAgICAgaXNQaW5jaDogISFlLmlzUGluY2gsXG4gICAgICB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzLFxuICAgICAgdHJhbnNmb3JtOiBnZXROZXh0VHJhbnNmb3JtVGV4dChlKSxcbiAgICAgIGV2ZW50czogcGFyYW1zXG4gICAgfSkpO1xuICB9LFxuICBkcmFnR3JvdXBFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgZXZlbnRzID0gZmlsbENoaWxkRXZlbnRzKG1vdmVhYmxlLCBcImJlZm9yZVJlbmRlcmFibGVcIiwgZSk7XG4gICAgdmFyIG1vdmVhYmxlcyA9IG1vdmVhYmxlLm1vdmVhYmxlcztcbiAgICB2YXIgcGFyYW1zID0gZXZlbnRzLm1hcChmdW5jdGlvbiAoY2hpbGRFdmVudCwgaSkge1xuICAgICAgdmFyIGNoaWxkTW92ZWFibGUgPSBtb3ZlYWJsZXNbaV07XG4gICAgICByZXR1cm4gX3RoaXMuZmlsbERyYWdFbmRQYXJhbXMoY2hpbGRNb3ZlYWJsZSwgY2hpbGRFdmVudCk7XG4gICAgfSk7XG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUmVuZGVyR3JvdXBFbmRcIiwgZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xuICAgICAgaXNQaW5jaDogISFlLmlzUGluY2gsXG4gICAgICBpc0RyYWc6IGUuaXNEcmFnLFxuICAgICAgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0cyxcbiAgICAgIGV2ZW50czogcGFyYW1zXG4gICAgfSkpO1xuICB9LFxuICBkcmFnQ29udHJvbFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnU3RhcnQobW92ZWFibGUsIGUpO1xuICB9LFxuICBkcmFnQ29udHJvbDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZyhtb3ZlYWJsZSwgZSk7XG4gIH0sXG4gIGRyYWdDb250cm9sQWZ0ZXI6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWdBZnRlcihtb3ZlYWJsZSwgZSk7XG4gIH0sXG4gIGRyYWdDb250cm9sRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnRW5kKG1vdmVhYmxlLCBlKTtcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnR3JvdXBTdGFydChtb3ZlYWJsZSwgZSk7XG4gIH0sXG4gIGRyYWdHcm91cENvbnRyb2w6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWdHcm91cChtb3ZlYWJsZSwgZSk7XG4gIH0sXG4gIGRyYWdHcm91cENvbnRyb2xFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWdHcm91cEVuZChtb3ZlYWJsZSwgZSk7XG4gIH0sXG4gIGZpbGxEcmFnUGFyYW1zOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xuICAgICAgaXNQaW5jaDogISFlLmlzUGluY2gsXG4gICAgICB0cmFuc2Zvcm06IGdldE5leHRUcmFuc2Zvcm1UZXh0KGUpXG4gICAgfSk7XG4gIH0sXG4gIGZpbGxEcmFnRW5kUGFyYW1zOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xuICAgICAgaXNQaW5jaDogISFlLmlzUGluY2gsXG4gICAgICBpc0RyYWc6IGUuaXNEcmFnXG4gICAgfSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHRyaWdnZXJBYmxlKG1vdmVhYmxlLCBhYmxlVHlwZSwgZXZlbnRPcGVyYXRpb24sIGV2ZW50QWZmaXgsIGV2ZW50VHlwZSwgZSwgcmVxdWVzdEluc3RhbnQpIHtcbiAgdmFyIGlzU3RhcnQgPSBldmVudFR5cGUgPT09IFwiU3RhcnRcIjtcbiAgdmFyIHRhcmdldCA9IG1vdmVhYmxlLnN0YXRlLnRhcmdldDtcbiAgdmFyIGlzUmVxdWVzdCA9IGUuaXNSZXF1ZXN0O1xuXG4gIGlmICghdGFyZ2V0IHx8IGlzU3RhcnQgJiYgZXZlbnRBZmZpeC5pbmRleE9mKFwiQ29udHJvbFwiKSA+IC0xICYmICFpc1JlcXVlc3QgJiYgbW92ZWFibGUuYXJlYUVsZW1lbnQgPT09IGUuaW5wdXRFdmVudC50YXJnZXQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gXCJkcmFnXCIgXCJDb250cm9sXCIgXCJBZnRlclwiXG5cblxuICB2YXIgZXZlbnROYW1lID0gXCJcIiArIGV2ZW50T3BlcmF0aW9uICsgZXZlbnRBZmZpeCArIGV2ZW50VHlwZTtcbiAgdmFyIGNvbmRpdGlvbk5hbWUgPSBcIlwiICsgZXZlbnRPcGVyYXRpb24gKyBldmVudEFmZml4ICsgXCJDb25kaXRpb25cIjtcbiAgdmFyIGlzRW5kID0gZXZlbnRUeXBlID09PSBcIkVuZFwiO1xuICB2YXIgaXNBZnRlciA9IGV2ZW50VHlwZSA9PT0gXCJBZnRlclwiO1xuICB2YXIgaXNGaXJzdFN0YXJ0ID0gaXNTdGFydCAmJiAoIW1vdmVhYmxlLnRhcmdldEdlc3RvIHx8ICFtb3ZlYWJsZS5jb250cm9sR2VzdG8gfHwgIW1vdmVhYmxlLnRhcmdldEdlc3RvLmlzRmxhZygpIHx8ICFtb3ZlYWJsZS5jb250cm9sR2VzdG8uaXNGbGFnKCkpO1xuXG4gIGlmIChpc0ZpcnN0U3RhcnQpIHtcbiAgICBtb3ZlYWJsZS51cGRhdGVSZWN0KGV2ZW50VHlwZSwgdHJ1ZSwgZmFsc2UpO1xuICB9XG5cbiAgaWYgKGV2ZW50VHlwZSA9PT0gXCJcIiAmJiAhaXNSZXF1ZXN0KSB7XG4gICAgY29udmVydERyYWdEaXN0KG1vdmVhYmxlLnN0YXRlLCBlKTtcbiAgfSAvLyBjb25zdCBpc0dyb3VwID0gZXZlbnRBZmZpeC5pbmRleE9mKFwiR3JvdXBcIikgPiAtMTtcblxuXG4gIHZhciBhYmxlcyA9IF9fc3ByZWFkQXJyYXkoW10sIG1vdmVhYmxlW2FibGVUeXBlXSk7XG5cbiAgaWYgKGlzUmVxdWVzdCkge1xuICAgIHZhciByZXF1ZXN0QWJsZV8xID0gZS5yZXF1ZXN0QWJsZTtcblxuICAgIGlmICghYWJsZXMuc29tZShmdW5jdGlvbiAoYWJsZSkge1xuICAgICAgcmV0dXJuIGFibGUubmFtZSA9PT0gcmVxdWVzdEFibGVfMTtcbiAgICB9KSkge1xuICAgICAgYWJsZXMucHVzaC5hcHBseShhYmxlcywgbW92ZWFibGUucHJvcHMuYWJsZXMuZmlsdGVyKGZ1bmN0aW9uIChhYmxlKSB7XG4gICAgICAgIHJldHVybiBhYmxlLm5hbWUgPT09IHJlcXVlc3RBYmxlXzE7XG4gICAgICB9KSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFhYmxlcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgZXZlbnRBYmxlcyA9IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbQmVmb3JlUmVuZGVyYWJsZV0sIGFibGVzKSwgW1JlbmRlcmFibGVdKS5maWx0ZXIoZnVuY3Rpb24gKGFibGUpIHtcbiAgICByZXR1cm4gYWJsZVtldmVudE5hbWVdO1xuICB9KTtcblxuICB2YXIgZGF0YXMgPSBlLmRhdGFzO1xuXG4gIGlmIChpc0ZpcnN0U3RhcnQpIHtcbiAgICBldmVudEFibGVzLmZvckVhY2goZnVuY3Rpb24gKGFibGUpIHtcbiAgICAgIGFibGUudW5zZXQgJiYgYWJsZS51bnNldChtb3ZlYWJsZSk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgaW5wdXRFdmVudCA9IGUuaW5wdXRFdmVudDtcbiAgdmFyIGlucHV0VGFyZ2V0O1xuXG4gIGlmIChpc0VuZCAmJiBpbnB1dEV2ZW50KSB7XG4gICAgaW5wdXRUYXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGUuY2xpZW50WCwgZS5jbGllbnRZKSB8fCBpbnB1dEV2ZW50LnRhcmdldDtcbiAgfVxuXG4gIHZhciByZXN1bHRDb3VudCA9IDA7XG4gIHZhciByZXN1bHRzID0gZXZlbnRBYmxlcy5maWx0ZXIoZnVuY3Rpb24gKGFibGUpIHtcbiAgICB2YXIgYWJsZU5hbWUgPSBhYmxlLm5hbWU7XG4gICAgdmFyIG5leHREYXRhcyA9IGRhdGFzW2FibGVOYW1lXSB8fCAoZGF0YXNbYWJsZU5hbWVdID0ge30pO1xuXG4gICAgaWYgKGlzU3RhcnQpIHtcbiAgICAgIG5leHREYXRhcy5pc0V2ZW50U3RhcnQgPSAhYWJsZVtjb25kaXRpb25OYW1lXSB8fCBhYmxlW2NvbmRpdGlvbk5hbWVdKG1vdmVhYmxlLCBlKTtcbiAgICB9XG5cbiAgICBpZiAobmV4dERhdGFzLmlzRXZlbnRTdGFydCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGFibGVbZXZlbnROYW1lXShtb3ZlYWJsZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7XG4gICAgICAgIHJlc3VsdENvdW50OiByZXN1bHRDb3VudCxcbiAgICAgICAgZGF0YXM6IG5leHREYXRhcyxcbiAgICAgICAgb3JpZ2luYWxEYXRhczogZGF0YXMsXG4gICAgICAgIGlucHV0VGFyZ2V0OiBpbnB1dFRhcmdldFxuICAgICAgfSkpO1xuXG4gICAgICBpZiAoaXNTdGFydCAmJiByZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgIG5leHREYXRhcy5pc0V2ZW50U3RhcnQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0Q291bnQgKz0gcmVzdWx0ID8gMSA6IDA7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG4gIHZhciBpc1VwZGF0ZSA9IHJlc3VsdHMubGVuZ3RoO1xuICB2YXIgaXNGb3JjZUVuZCA9IGZhbHNlOyAvLyBlbmQgYWJsZXNcblxuICBpZiAoaXNTdGFydCAmJiBldmVudEFibGVzLmxlbmd0aCAmJiAhaXNVcGRhdGUpIHtcbiAgICBpc0ZvcmNlRW5kID0gZXZlbnRBYmxlcy5maWx0ZXIoZnVuY3Rpb24gKGFibGUpIHtcbiAgICAgIHZhciBhYmxlTmFtZSA9IGFibGUubmFtZTtcbiAgICAgIHZhciBuZXh0RGF0YXMgPSBkYXRhc1thYmxlTmFtZV07XG5cbiAgICAgIGlmIChuZXh0RGF0YXMuaXNFdmVudFN0YXJ0KSB7XG4gICAgICAgIGlmIChhYmxlLmRyYWdSZWxhdGlvbiA9PT0gXCJzdHJvbmdcIikge1xuICAgICAgICAgIC8vIGNhbmNlbCBkcmFnXG4gICAgICAgICAgbmV4dERhdGFzLmlzRXZlbnRTdGFydCA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSAvLyBzdGFydCBkcmFnXG5cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gLy8gY2FuY2VsIGV2ZW50XG5cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pLmxlbmd0aCA9PT0gMDtcbiAgfVxuXG4gIGlmIChpc0VuZCB8fCBpc0ZvcmNlRW5kKSB7XG4gICAgbW92ZWFibGUuc3RhdGUuZ2VzdG8gPSBudWxsO1xuXG4gICAgaWYgKG1vdmVhYmxlLm1vdmVhYmxlcykge1xuICAgICAgbW92ZWFibGUubW92ZWFibGVzLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkTW92ZWFibGUpIHtcbiAgICAgICAgY2hpbGRNb3ZlYWJsZS5zdGF0ZS5nZXN0byA9IG51bGw7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNGaXJzdFN0YXJ0ICYmIGlzRm9yY2VFbmQpIHtcbiAgICBldmVudEFibGVzLmZvckVhY2goZnVuY3Rpb24gKGFibGUpIHtcbiAgICAgIGFibGUudW5zZXQgJiYgYWJsZS51bnNldChtb3ZlYWJsZSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoaXNTdGFydCAmJiAhaXNSZXF1ZXN0ICYmIGlzVXBkYXRlKSB7XG4gICAgZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH1cblxuICBpZiAobW92ZWFibGUuaXNVbm1vdW50ZWQgfHwgaXNGb3JjZUVuZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghaXNTdGFydCAmJiBpc1VwZGF0ZSAmJiAhcmVxdWVzdEluc3RhbnQgfHwgaXNFbmQpIHtcbiAgICBtb3ZlYWJsZS51cGRhdGVSZWN0KGlzRW5kID8gZXZlbnRUeXBlIDogXCJcIiwgdHJ1ZSwgZmFsc2UpO1xuICAgIG1vdmVhYmxlLmZvcmNlVXBkYXRlKCk7XG4gIH1cblxuICBpZiAoIWlzU3RhcnQgJiYgIWlzRW5kICYmICFpc0FmdGVyICYmIGlzVXBkYXRlICYmICFyZXF1ZXN0SW5zdGFudCkge1xuICAgIHRyaWdnZXJBYmxlKG1vdmVhYmxlLCBhYmxlVHlwZSwgZXZlbnRPcGVyYXRpb24sIGV2ZW50QWZmaXgsIGV2ZW50VHlwZSArIFwiQWZ0ZXJcIiwgZSk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldFRhcmdldEFibGVHZXN0byhtb3ZlYWJsZSwgbW92ZWFibGVUYXJnZXQsIGV2ZW50QWZmaXgpIHtcbiAgdmFyIGNvbnRyb2xCb3ggPSBtb3ZlYWJsZS5jb250cm9sQm94LmdldEVsZW1lbnQoKTtcbiAgdmFyIHRhcmdldHMgPSBbXTtcbiAgdGFyZ2V0cy5wdXNoKGNvbnRyb2xCb3gpO1xuXG4gIGlmICghbW92ZWFibGUucHJvcHMuZHJhZ0FyZWEgfHwgbW92ZWFibGUucHJvcHMuZHJhZ1RhcmdldCkge1xuICAgIHRhcmdldHMucHVzaChtb3ZlYWJsZVRhcmdldCk7XG4gIH1cblxuICB2YXIgc3RhcnRGdW5jID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgZXZlbnRUYXJnZXQgPSBlLmlucHV0RXZlbnQudGFyZ2V0O1xuICAgIHZhciBhcmVhRWxlbWVudCA9IG1vdmVhYmxlLmFyZWFFbGVtZW50O1xuICAgIHJldHVybiBldmVudFRhcmdldCA9PT0gYXJlYUVsZW1lbnQgfHwgIW1vdmVhYmxlLmlzTW92ZWFibGVFbGVtZW50KGV2ZW50VGFyZ2V0KSAmJiAhbW92ZWFibGUuY29udHJvbEJveC5nZXRFbGVtZW50KCkuY29udGFpbnMoZXZlbnRUYXJnZXQpIHx8IGhhc0NsYXNzKGV2ZW50VGFyZ2V0LCBcIm1vdmVhYmxlLWFyZWFcIikgfHwgaGFzQ2xhc3MoZXZlbnRUYXJnZXQsIFwibW92ZWFibGUtcGFkZGluZ1wiKTtcbiAgfTtcblxuICByZXR1cm4gZ2V0QWJsZUdlc3RvKG1vdmVhYmxlLCB0YXJnZXRzLCBcInRhcmdldEFibGVzXCIsIGV2ZW50QWZmaXgsIHtcbiAgICBkcmFnU3RhcnQ6IHN0YXJ0RnVuYyxcbiAgICBwaW5jaFN0YXJ0OiBzdGFydEZ1bmNcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRBYmxlR2VzdG8obW92ZWFibGUsIHRhcmdldCwgYWJsZVR5cGUsIGV2ZW50QWZmaXgsIGNvbmRpdGlvbkZ1bmN0aW9ucykge1xuICBpZiAoY29uZGl0aW9uRnVuY3Rpb25zID09PSB2b2lkIDApIHtcbiAgICBjb25kaXRpb25GdW5jdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfYSA9IG1vdmVhYmxlLnByb3BzLFxuICAgICAgcGluY2hPdXRzaWRlID0gX2EucGluY2hPdXRzaWRlLFxuICAgICAgcGluY2hUaHJlc2hvbGQgPSBfYS5waW5jaFRocmVzaG9sZDtcbiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgcHJldmVudERlZmF1bHQ6IGZhbHNlLFxuICAgIGNvbnRhaW5lcjogd2luZG93LFxuICAgIHBpbmNoVGhyZXNob2xkOiBwaW5jaFRocmVzaG9sZCxcbiAgICBwaW5jaE91dHNpZGU6IHBpbmNoT3V0c2lkZVxuICB9O1xuICB2YXIgZ2VzdG8gPSBuZXcgR2VzdG8odGFyZ2V0LCBvcHRpb25zKTtcbiAgW1wiZHJhZ1wiLCBcInBpbmNoXCJdLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50T3BlcmF0aW9uKSB7XG4gICAgW1wiU3RhcnRcIiwgXCJcIiwgXCJFbmRcIl0uZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRUeXBlKSB7XG4gICAgICBnZXN0by5vbihcIlwiICsgZXZlbnRPcGVyYXRpb24gKyBldmVudFR5cGUsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBldmVudE5hbWUgPSBlLmV2ZW50VHlwZTtcblxuICAgICAgICBpZiAoY29uZGl0aW9uRnVuY3Rpb25zW2V2ZW50TmFtZV0gJiYgIWNvbmRpdGlvbkZ1bmN0aW9uc1tldmVudE5hbWVdKGUpKSB7XG4gICAgICAgICAgZS5zdG9wKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IHRyaWdnZXJBYmxlKG1vdmVhYmxlLCBhYmxlVHlwZSwgZXZlbnRPcGVyYXRpb24sIGV2ZW50QWZmaXgsIGV2ZW50VHlwZSwgZSk7XG5cbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICBlLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gZ2VzdG87XG59XG5cbnZhciBFdmVudE1hbmFnZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFdmVudE1hbmFnZXIodGFyZ2V0LCBtb3ZlYWJsZSwgZXZlbnROYW1lKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRoaXMubW92ZWFibGUgPSBtb3ZlYWJsZTtcbiAgICB0aGlzLmV2ZW50TmFtZSA9IGV2ZW50TmFtZTtcbiAgICB0aGlzLmFibGVzID0gW107XG5cbiAgICB0aGlzLm9uRXZlbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGV2ZW50TmFtZSA9IF90aGlzLmV2ZW50TmFtZTtcbiAgICAgIHZhciBtb3ZlYWJsZSA9IF90aGlzLm1vdmVhYmxlO1xuXG4gICAgICBpZiAobW92ZWFibGUuc3RhdGUuZGlzYWJsZU5hdGl2ZUV2ZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuYWJsZXMuZm9yRWFjaChmdW5jdGlvbiAoYWJsZSkge1xuICAgICAgICBhYmxlW2V2ZW50TmFtZV0obW92ZWFibGUsIHtcbiAgICAgICAgICBpbnB1dEV2ZW50OiBlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHRoaXMudGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodGhpcy5ldmVudE5hbWUudG9Mb3dlckNhc2UoKSwgdGhpcy5vbkV2ZW50KTtcbiAgfVxuXG4gIHZhciBfX3Byb3RvID0gRXZlbnRNYW5hZ2VyLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLnNldEFibGVzID0gZnVuY3Rpb24gKGFibGVzKSB7XG4gICAgdGhpcy5hYmxlcyA9IGFibGVzO1xuICB9O1xuXG4gIF9fcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuZXZlbnROYW1lLnRvTG93ZXJDYXNlKCksIHRoaXMub25FdmVudCk7XG4gICAgdGhpcy50YXJnZXQgPSBudWxsO1xuICAgIHRoaXMubW92ZWFibGUgPSBudWxsO1xuICB9O1xuXG4gIHJldHVybiBFdmVudE1hbmFnZXI7XG59KCk7XG5cbnZhciBNb3ZlYWJsZU1hbmFnZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoTW92ZWFibGVNYW5hZ2VyLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIE1vdmVhYmxlTWFuYWdlcigpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLnN0YXRlID0gX19hc3NpZ24oe1xuICAgICAgY29udGFpbmVyOiBudWxsLFxuICAgICAgZ2VzdG86IG51bGwsXG4gICAgICByZW5kZXJQb3NlczogW1swLCAwXSwgWzAsIDBdLCBbMCwgMF0sIFswLCAwXV0sXG4gICAgICBkaXNhYmxlTmF0aXZlRXZlbnQ6IGZhbHNlXG4gICAgfSwgZ2V0VGFyZ2V0SW5mbyhudWxsKSk7XG4gICAgX3RoaXMuZW5hYmxlZEFibGVzID0gW107XG4gICAgX3RoaXMudGFyZ2V0QWJsZXMgPSBbXTtcbiAgICBfdGhpcy5jb250cm9sQWJsZXMgPSBbXTtcbiAgICBfdGhpcy5yb3RhdGlvbiA9IDA7XG4gICAgX3RoaXMuc2NhbGUgPSBbMSwgMV07XG4gICAgX3RoaXMuaXNVbm1vdW50ZWQgPSBmYWxzZTtcbiAgICBfdGhpcy5ldmVudHMgPSB7XG4gICAgICBcIm1vdXNlRW50ZXJcIjogbnVsbCxcbiAgICAgIFwibW91c2VMZWF2ZVwiOiBudWxsXG4gICAgfTtcbiAgICBfdGhpcy5fcHJldlRhcmdldCA9IG51bGw7XG4gICAgX3RoaXMuX3ByZXZEcmFnQXJlYSA9IGZhbHNlO1xuICAgIF90aGlzLl9vYnNlcnZlciA9IG51bGw7XG4gICAgX3RoaXMuX29ic2VydmVySWQgPSAwO1xuXG4gICAgX3RoaXMub25QcmV2ZW50Q2xpY2sgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIHJlbW92ZUV2ZW50KHdpbmRvdywgXCJjbGlja1wiLCBfdGhpcy5vblByZXZlbnRDbGljaywgdHJ1ZSk7XG4gICAgfTtcblxuICAgIF90aGlzLmNoZWNrVXBkYXRlUmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpcy5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFyZW50TW92ZWFibGUgPSBfdGhpcy5wcm9wcy5wYXJlbnRNb3ZlYWJsZTtcblxuICAgICAgaWYgKHBhcmVudE1vdmVhYmxlKSB7XG4gICAgICAgIHBhcmVudE1vdmVhYmxlLmNoZWNrVXBkYXRlUmVjdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKF90aGlzLl9vYnNlcnZlcklkKTtcbiAgICAgIF90aGlzLl9vYnNlcnZlcklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKF90aGlzLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLnVwZGF0ZVJlY3QoKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX19wcm90byA9IE1vdmVhYmxlTWFuYWdlci5wcm90b3R5cGU7XG5cbiAgX19wcm90by5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHZhciBwYXJlbnRQb3NpdGlvbiA9IHByb3BzLnBhcmVudFBvc2l0aW9uLFxuICAgICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICAgIHByb3BzVGFyZ2V0ID0gcHJvcHMudGFyZ2V0LFxuICAgICAgICB6b29tID0gcHJvcHMuem9vbSxcbiAgICAgICAgY3NwTm9uY2UgPSBwcm9wcy5jc3BOb25jZSxcbiAgICAgICAgdHJhbnNsYXRlWiA9IHByb3BzLnRyYW5zbGF0ZVosXG4gICAgICAgIENvbnRyb2xCb3hFbGVtZW50ID0gcHJvcHMuY3NzU3R5bGVkLFxuICAgICAgICBwb3J0YWxDb250YWluZXIgPSBwcm9wcy5wb3J0YWxDb250YWluZXI7XG4gICAgdGhpcy5jaGVja1VwZGF0ZSgpO1xuICAgIHRoaXMudXBkYXRlUmVuZGVyUG9zZXMoKTtcblxuICAgIHZhciBfYSA9IHBhcmVudFBvc2l0aW9uIHx8IHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB0b3A6IDBcbiAgICB9LFxuICAgICAgICBwYXJlbnRMZWZ0ID0gX2EubGVmdCxcbiAgICAgICAgcGFyZW50VG9wID0gX2EudG9wO1xuXG4gICAgdmFyIGxlZnQgPSBzdGF0ZS5sZWZ0LFxuICAgICAgICB0b3AgPSBzdGF0ZS50b3AsXG4gICAgICAgIHN0YXRlVGFyZ2V0ID0gc3RhdGUudGFyZ2V0LFxuICAgICAgICBkaXJlY3Rpb24gPSBzdGF0ZS5kaXJlY3Rpb247XG4gICAgdmFyIGdyb3VwVGFyZ2V0cyA9IHByb3BzLnRhcmdldHM7XG4gICAgdmFyIGlzRGlzcGxheSA9IChncm91cFRhcmdldHMgJiYgZ3JvdXBUYXJnZXRzLmxlbmd0aCB8fCBwcm9wc1RhcmdldCkgJiYgc3RhdGVUYXJnZXQ7XG4gICAgdmFyIGlzRHJhZ2dpbmcgPSB0aGlzLmlzRHJhZ2dpbmcoKTtcbiAgICB2YXIgYWJsZUF0dHJpYnV0ZXMgPSB7fTtcbiAgICB0aGlzLmdldEVuYWJsZWRBYmxlcygpLmZvckVhY2goZnVuY3Rpb24gKGFibGUpIHtcbiAgICAgIGFibGVBdHRyaWJ1dGVzW1wiZGF0YS1hYmxlLVwiICsgYWJsZS5uYW1lLnRvTG93ZXJDYXNlKCldID0gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudChDb250cm9sQm94RWxlbWVudCwgX19hc3NpZ24oe1xuICAgICAgY3NwTm9uY2U6IGNzcE5vbmNlLFxuICAgICAgcmVmOiByZWYodGhpcywgXCJjb250cm9sQm94XCIpLFxuICAgICAgY2xhc3NOYW1lOiBwcmVmaXgoXCJjb250cm9sLWJveFwiLCBkaXJlY3Rpb24gPT09IC0xID8gXCJyZXZlcnNlXCIgOiBcIlwiLCBpc0RyYWdnaW5nID8gXCJkcmFnZ2luZ1wiIDogXCJcIikgKyBcIiBcIiArIGNsYXNzTmFtZVxuICAgIH0sIGFibGVBdHRyaWJ1dGVzLCB7XG4gICAgICBvbkNsaWNrOiB0aGlzLm9uUHJldmVudENsaWNrLFxuICAgICAgcG9ydGFsQ29udGFpbmVyOiBwb3J0YWxDb250YWluZXIsXG4gICAgICBzdHlsZToge1xuICAgICAgICBcInBvc2l0aW9uXCI6IFwiYWJzb2x1dGVcIixcbiAgICAgICAgXCJkaXNwbGF5XCI6IGlzRGlzcGxheSA/IFwiYmxvY2tcIiA6IFwibm9uZVwiLFxuICAgICAgICBcInRyYW5zZm9ybVwiOiBcInRyYW5zbGF0ZTNkKFwiICsgKGxlZnQgLSBwYXJlbnRMZWZ0KSArIFwicHgsIFwiICsgKHRvcCAtIHBhcmVudFRvcCkgKyBcInB4LCBcIiArIHRyYW5zbGF0ZVogKyBcIilcIixcbiAgICAgICAgXCItLXpvb21cIjogem9vbSxcbiAgICAgICAgXCItLXpvb21weFwiOiB6b29tICsgXCJweFwiXG4gICAgICB9XG4gICAgfSksIHRoaXMucmVuZGVyQWJsZXMoKSwgdGhpcy5fcmVuZGVyTGluZXMoKSk7XG4gIH07XG5cbiAgX19wcm90by5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNvbnRyb2xCb3guZ2V0RWxlbWVudCgpO1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHBhcmVudE1vdmVhYmxlID0gcHJvcHMucGFyZW50TW92ZWFibGUsXG4gICAgICAgIGNvbnRhaW5lciA9IHByb3BzLmNvbnRhaW5lcixcbiAgICAgICAgd3JhcHBlck1vdmVhYmxlID0gcHJvcHMud3JhcHBlck1vdmVhYmxlO1xuXG4gICAgdGhpcy5fdXBkYXRlVGFyZ2V0cygpO1xuXG4gICAgdGhpcy5fdXBkYXRlTmF0aXZlRXZlbnRzKCk7XG5cbiAgICB0aGlzLl91cGRhdGVFdmVudHMoKTtcblxuICAgIGlmICghY29udGFpbmVyICYmICFwYXJlbnRNb3ZlYWJsZSAmJiAhd3JhcHBlck1vdmVhYmxlKSB7XG4gICAgICB0aGlzLnVwZGF0ZVJlY3QoXCJcIiwgZmFsc2UsIHRydWUpO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlQ2hlY2tJbnB1dCgpO1xuXG4gICAgdGhpcy5fdXBkYXRlT2JzZXJ2ZXIodGhpcy5wcm9wcyk7XG4gIH07XG5cbiAgX19wcm90by5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgdGhpcy5fdXBkYXRlTmF0aXZlRXZlbnRzKCk7XG5cbiAgICB0aGlzLl91cGRhdGVFdmVudHMoKTtcblxuICAgIHRoaXMuX3VwZGF0ZVRhcmdldHMoKTtcblxuICAgIHRoaXMudXBkYXRlQ2hlY2tJbnB1dCgpO1xuXG4gICAgdGhpcy5fdXBkYXRlT2JzZXJ2ZXIocHJldlByb3BzKTtcbiAgfTtcblxuICBfX3Byb3RvLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXNVbm1vdW50ZWQgPSB0cnVlO1xuICAgIHVuc2V0KHRoaXMsIFwidGFyZ2V0R2VzdG9cIik7XG4gICAgdW5zZXQodGhpcywgXCJjb250cm9sR2VzdG9cIik7XG4gICAgdmFyIGV2ZW50cyA9IHRoaXMuZXZlbnRzO1xuXG4gICAgZm9yICh2YXIgbmFtZSBpbiBldmVudHMpIHtcbiAgICAgIHZhciBtYW5hZ2VyID0gZXZlbnRzW25hbWVdO1xuICAgICAgbWFuYWdlciAmJiBtYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB9XG4gIH07XG5cbiAgX19wcm90by5nZXRDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9hID0gdGhpcy5wcm9wcyxcbiAgICAgICAgcGFyZW50TW92ZWFibGUgPSBfYS5wYXJlbnRNb3ZlYWJsZSxcbiAgICAgICAgd3JhcHBlck1vdmVhYmxlID0gX2Eud3JhcHBlck1vdmVhYmxlLFxuICAgICAgICBjb250YWluZXIgPSBfYS5jb250YWluZXI7XG4gICAgcmV0dXJuIGNvbnRhaW5lciB8fCB3cmFwcGVyTW92ZWFibGUgJiYgd3JhcHBlck1vdmVhYmxlLmdldENvbnRhaW5lcigpIHx8IHBhcmVudE1vdmVhYmxlICYmIHBhcmVudE1vdmVhYmxlLmdldENvbnRhaW5lcigpIHx8IHRoaXMuY29udHJvbEJveC5nZXRFbGVtZW50KCkucGFyZW50RWxlbWVudDtcbiAgfTtcbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSB0YXJnZXQgaXMgYW4gZWxlbWVudCBpbmNsdWRlZCBpbiB0aGUgbW92ZWFibGUuXG4gICAqIEBtZXRob2QgTW92ZWFibGUjaXNNb3ZlYWJsZUVsZW1lbnRcbiAgICogQHBhcmFtIC0gdGhlIHRhcmdldFxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gICAqXG4gICAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICAgKlxuICAgKiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGUgPT4ge1xuICAgKiAgICAgaWYgKCFtb3ZlYWJsZS5pc01vdmVhYmxlRWxlbWVudChlLnRhcmdldCkpIHtcbiAgICogICAgICAgICBtb3ZlYWJsZS50YXJnZXQgPSBlLnRhcmdldDtcbiAgICogICAgIH1cbiAgICogfSk7XG4gICAqL1xuXG5cbiAgX19wcm90by5pc01vdmVhYmxlRWxlbWVudCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICByZXR1cm4gdGFyZ2V0ICYmICh0YXJnZXQuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIikuaW5kZXhPZihQUkVGSVgpID4gLTE7XG4gIH07XG4gIC8qKlxuICAgKiBZb3UgY2FuIGRyYWcgc3RhcnQgdGhlIE1vdmVhYmxlIHRocm91Z2ggdGhlIGV4dGVybmFsIGBNb3VzZUV2ZW50YG9yIGBUb3VjaEV2ZW50YC4gKEFuZ3VsYXI6IG5nRHJhZ1N0YXJ0KVxuICAgKiBAbWV0aG9kIE1vdmVhYmxlI2RyYWdTdGFydFxuICAgKiBAcGFyYW0gLSBleHRlcm5hbCBgTW91c2VFdmVudGBvciBgVG91Y2hFdmVudGBcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICAgKlxuICAgKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcbiAgICpcbiAgICogZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGUgPT4ge1xuICAgKiAgICAgaWYgKCFtb3ZlYWJsZS5pc01vdmVhYmxlRWxlbWVudChlLnRhcmdldCkpIHtcbiAgICogICAgICAgICAgbW92ZWFibGUuZHJhZ1N0YXJ0KGUpO1xuICAgKiAgICAgfVxuICAgKiB9KTtcbiAgICovXG5cblxuICBfX3Byb3RvLmRyYWdTdGFydCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKHRoaXMudGFyZ2V0R2VzdG8pIHtcbiAgICAgIHRoaXMudGFyZ2V0R2VzdG8udHJpZ2dlckRyYWdTdGFydChlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIEhpdCB0ZXN0IGFuIGVsZW1lbnQgb3IgcmVjdCBvbiBhIG1vdmVhYmxlIHRhcmdldC5cbiAgICogQG1ldGhvZCBNb3ZlYWJsZSNoaXRUZXN0XG4gICAqIEBwYXJhbSAtIGVsZW1lbnQgb3IgcmVjdCB0byB0ZXN0XG4gICAqIEByZXR1cm4gLSBHZXQgaGl0IHRlc3QgcmF0ZSAocmF0ZSA+IDAgaXMgaGl0dGVkKVxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gICAqXG4gICAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICAgKlxuICAgKiBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgZSA9PiB7XG4gICAqICAgICBpZiAobW92ZWFibGUuaGl0VGVzdChlLnRhcmdldCkgPiAwKSB7XG4gICAqICAgICAgICAgIGNvbnNvbGUubG9nKFwiaGlpdGVkXCIpO1xuICAgKiAgICAgfVxuICAgKiB9KTtcbiAgICovXG5cblxuICBfX3Byb3RvLmhpdFRlc3QgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICB2YXIgX2EgPSB0aGlzLnN0YXRlLFxuICAgICAgICB0YXJnZXQgPSBfYS50YXJnZXQsXG4gICAgICAgIHBvczEgPSBfYS5wb3MxLFxuICAgICAgICBwb3MyID0gX2EucG9zMixcbiAgICAgICAgcG9zMyA9IF9hLnBvczMsXG4gICAgICAgIHBvczQgPSBfYS5wb3M0LFxuICAgICAgICB0YXJnZXRDbGllbnRSZWN0ID0gX2EudGFyZ2V0Q2xpZW50UmVjdDtcblxuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICB2YXIgcmVjdDtcblxuICAgIGlmIChlbCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgIHZhciBjbGllbnRSZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICByZWN0ID0ge1xuICAgICAgICBsZWZ0OiBjbGllbnRSZWN0LmxlZnQsXG4gICAgICAgIHRvcDogY2xpZW50UmVjdC50b3AsXG4gICAgICAgIHdpZHRoOiBjbGllbnRSZWN0LndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGNsaWVudFJlY3QuaGVpZ2h0XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZWN0ID0gX19hc3NpZ24oe1xuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwXG4gICAgICB9LCBlbCk7XG4gICAgfVxuXG4gICAgdmFyIHJlY3RMZWZ0ID0gcmVjdC5sZWZ0LFxuICAgICAgICByZWN0VG9wID0gcmVjdC50b3AsXG4gICAgICAgIHJlY3RXaWR0aCA9IHJlY3Qud2lkdGgsXG4gICAgICAgIHJlY3RIZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgICB2YXIgcG9pbnRzID0gZml0UG9pbnRzKFtwb3MxLCBwb3MyLCBwb3M0LCBwb3MzXSwgdGFyZ2V0Q2xpZW50UmVjdCk7XG4gICAgdmFyIHNpemUgPSBnZXRPdmVybGFwU2l6ZShwb2ludHMsIFtbcmVjdExlZnQsIHJlY3RUb3BdLCBbcmVjdExlZnQgKyByZWN0V2lkdGgsIHJlY3RUb3BdLCBbcmVjdExlZnQgKyByZWN0V2lkdGgsIHJlY3RUb3AgKyByZWN0SGVpZ2h0XSwgW3JlY3RMZWZ0LCByZWN0VG9wICsgcmVjdEhlaWdodF1dKTtcbiAgICB2YXIgdG90YWxTaXplID0gZ2V0QXJlYVNpemUocG9pbnRzKTtcblxuICAgIGlmICghc2l6ZSB8fCAhdG90YWxTaXplKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gTWF0aC5taW4oMTAwLCBzaXplIC8gdG90YWxTaXplICogMTAwKTtcbiAgfTtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGNvb3JkaW5hdGVzIGFyZSBpbnNpZGUgTW92ZWFibGVcbiAgICogQG1ldGhvZCBNb3ZlYWJsZSNpc0luc2lkZVxuICAgKiBAcGFyYW0gLSB4IGNvb3JkaW5hdGVcbiAgICogQHBhcmFtIC0geSBjb29yZGluYXRlXG4gICAqIEByZXR1cm4gLSBUcnVlIGlmIHRoZSBjb29yZGluYXRlIGlzIGluIG1vdmVhYmxlIG9yIGZhbHNlXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAgICpcbiAgICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XG4gICAqXG4gICAqIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBlID0+IHtcbiAgICogICAgIGlmIChtb3ZlYWJsZS5pc0luc2lkZShlLmNsaWVudFgsIGUuY2xpZW50WSkpIHtcbiAgICogICAgICAgICAgY29uc29sZS5sb2coXCJpbnNpZGVcIik7XG4gICAqICAgICB9XG4gICAqIH0pO1xuICAgKi9cblxuXG4gIF9fcHJvdG8uaXNJbnNpZGUgPSBmdW5jdGlvbiAoY2xpZW50WCwgY2xpZW50WSkge1xuICAgIHZhciBfYSA9IHRoaXMuc3RhdGUsXG4gICAgICAgIHRhcmdldCA9IF9hLnRhcmdldCxcbiAgICAgICAgcG9zMSA9IF9hLnBvczEsXG4gICAgICAgIHBvczIgPSBfYS5wb3MyLFxuICAgICAgICBwb3MzID0gX2EucG9zMyxcbiAgICAgICAgcG9zNCA9IF9hLnBvczQsXG4gICAgICAgIHRhcmdldENsaWVudFJlY3QgPSBfYS50YXJnZXRDbGllbnRSZWN0O1xuXG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNJbnNpZGUoW2NsaWVudFgsIGNsaWVudFldLCBmaXRQb2ludHMoW3BvczEsIHBvczIsIHBvczQsIHBvczNdLCB0YXJnZXRDbGllbnRSZWN0KSk7XG4gIH07XG4gIC8qKlxuICAgKiBJZiB0aGUgd2lkdGgsIGhlaWdodCwgbGVmdCwgYW5kIHRvcCBvZiBhbGwgZWxlbWVudHMgY2hhbmdlLCB1cGRhdGUgdGhlIHNoYXBlIG9mIHRoZSBtb3ZlYWJsZS5cbiAgICogQG1ldGhvZCBNb3ZlYWJsZSN1cGRhdGVSZWN0XG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAgICpcbiAgICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XG4gICAqXG4gICAqIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGUgPT4ge1xuICAgKiAgICAgbW92ZWFibGUudXBkYXRlUmVjdCgpO1xuICAgKiB9KTtcbiAgICovXG5cblxuICBfX3Byb3RvLnVwZGF0ZVJlY3QgPSBmdW5jdGlvbiAodHlwZSwgaXNUYXJnZXQsIGlzU2V0U3RhdGUpIHtcbiAgICBpZiAoaXNTZXRTdGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICBpc1NldFN0YXRlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBwYXJlbnRNb3ZlYWJsZSA9IHByb3BzLnBhcmVudE1vdmVhYmxlO1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgdmFyIHRhcmdldCA9IHN0YXRlLnRhcmdldCB8fCB0aGlzLnByb3BzLnRhcmdldDtcbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5nZXRDb250YWluZXIoKTtcbiAgICB2YXIgcm9vdENvbnRhaW5lciA9IHBhcmVudE1vdmVhYmxlID8gcGFyZW50TW92ZWFibGUucHJvcHMucm9vdENvbnRhaW5lciA6IHByb3BzLnJvb3RDb250YWluZXI7XG4gICAgdGhpcy51cGRhdGVTdGF0ZShnZXRUYXJnZXRJbmZvKHRoaXMuY29udHJvbEJveCAmJiB0aGlzLmNvbnRyb2xCb3guZ2V0RWxlbWVudCgpLCB0YXJnZXQsIGNvbnRhaW5lciwgY29udGFpbmVyLCByb290Q29udGFpbmVyIHx8IGNvbnRhaW5lciksIHBhcmVudE1vdmVhYmxlID8gZmFsc2UgOiBpc1NldFN0YXRlKTtcbiAgfTtcbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBtb3ZlYWJsZSBzdGF0ZSBpcyBiZWluZyBkcmFnZ2VkLlxuICAgKiBAbWV0aG9kIE1vdmVhYmxlI2lzRHJhZ2dpbmdcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICAgKlxuICAgKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcbiAgICpcbiAgICogLy8gZmFsc2VcbiAgICogY29uc29sZS5sb2cobW92ZWFibGUuaXNEcmFnZ2luZygpKTtcbiAgICpcbiAgICogbW92ZWFibGUub24oXCJkcmFnXCIsICgpID0+IHtcbiAgICogICAvLyB0cnVlXG4gICAqICAgY29uc29sZS5sb2cobW92ZWFibGUuaXNEcmFnZ2luZygpKTtcbiAgICogfSk7XG4gICAqL1xuXG5cbiAgX19wcm90by5pc0RyYWdnaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy50YXJnZXRHZXN0byA/IHRoaXMudGFyZ2V0R2VzdG8uaXNGbGFnKCkgOiBmYWxzZSkgfHwgKHRoaXMuY29udHJvbEdlc3RvID8gdGhpcy5jb250cm9sR2VzdG8uaXNGbGFnKCkgOiBmYWxzZSk7XG4gIH07XG4gIC8qKlxuICAgKiBJZiB0aGUgd2lkdGgsIGhlaWdodCwgbGVmdCwgYW5kIHRvcCBvZiB0aGUgb25seSB0YXJnZXQgY2hhbmdlLCB1cGRhdGUgdGhlIHNoYXBlIG9mIHRoZSBtb3ZlYWJsZS5cbiAgICogQG1ldGhvZCBNb3ZlYWJsZSN1cGRhdGVUYXJnZXRcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICAgKlxuICAgKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcbiAgICpcbiAgICogbW92ZWFibGUudXBkYXRlVGFyZ2V0KCk7XG4gICAqL1xuXG5cbiAgX19wcm90by51cGRhdGVUYXJnZXQgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgIHRoaXMudXBkYXRlUmVjdCh0eXBlLCB0cnVlKTtcbiAgfTtcbiAgLyoqXG4gICAqIFlvdSBjYW4gZ2V0IHRoZSB2ZXJ0ZXggaW5mb3JtYXRpb24sIHBvc2l0aW9uIGFuZCBvZmZzZXQgc2l6ZSBpbmZvcm1hdGlvbiBvZiB0aGUgdGFyZ2V0IGJhc2VkIG9uIHRoZSBjb250YWluZXIuXG4gICAqIEBtZXRob2QgTW92ZWFibGUjZ2V0UmVjdFxuICAgKiBAcmV0dXJuIC0gVGhlIFJlY3QgSW5mb1xuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gICAqXG4gICAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICAgKlxuICAgKiBjb25zdCByZWN0SW5mbyA9IG1vdmVhYmxlLmdldFJlY3QoKTtcbiAgICovXG5cblxuICBfX3Byb3RvLmdldFJlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB2YXIgcG9zZXMgPSBnZXRBYnNvbHV0ZVBvc2VzQnlTdGF0ZSh0aGlzLnN0YXRlKTtcbiAgICB2YXIgcG9zMSA9IHBvc2VzWzBdLFxuICAgICAgICBwb3MyID0gcG9zZXNbMV0sXG4gICAgICAgIHBvczMgPSBwb3Nlc1syXSxcbiAgICAgICAgcG9zNCA9IHBvc2VzWzNdO1xuICAgIHZhciByZWN0ID0gZ2V0UmVjdChwb3Nlcyk7XG4gICAgdmFyIG9mZnNldFdpZHRoID0gc3RhdGUud2lkdGgsXG4gICAgICAgIG9mZnNldEhlaWdodCA9IHN0YXRlLmhlaWdodDtcbiAgICB2YXIgd2lkdGggPSByZWN0LndpZHRoLFxuICAgICAgICBoZWlnaHQgPSByZWN0LmhlaWdodCxcbiAgICAgICAgbGVmdCA9IHJlY3QubGVmdCxcbiAgICAgICAgdG9wID0gcmVjdC50b3A7XG4gICAgdmFyIHN0YXRlUG9zID0gW3N0YXRlLmxlZnQsIHN0YXRlLnRvcF07XG4gICAgdmFyIG9yaWdpbiA9IHBsdXMoc3RhdGVQb3MsIHN0YXRlLm9yaWdpbik7XG4gICAgdmFyIGJlZm9yZU9yaWdpbiA9IHBsdXMoc3RhdGVQb3MsIHN0YXRlLmJlZm9yZU9yaWdpbik7XG4gICAgdmFyIHRyYW5zZm9ybU9yaWdpbiA9IHN0YXRlLnRyYW5zZm9ybU9yaWdpbjtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgdG9wOiB0b3AsXG4gICAgICBwb3MxOiBwb3MxLFxuICAgICAgcG9zMjogcG9zMixcbiAgICAgIHBvczM6IHBvczMsXG4gICAgICBwb3M0OiBwb3M0LFxuICAgICAgb2Zmc2V0V2lkdGg6IG9mZnNldFdpZHRoLFxuICAgICAgb2Zmc2V0SGVpZ2h0OiBvZmZzZXRIZWlnaHQsXG4gICAgICBiZWZvcmVPcmlnaW46IGJlZm9yZU9yaWdpbixcbiAgICAgIG9yaWdpbjogb3JpZ2luLFxuICAgICAgdHJhbnNmb3JtT3JpZ2luOiB0cmFuc2Zvcm1PcmlnaW4sXG4gICAgICByb3RhdGlvbjogdGhpcy5nZXRSb3RhdGlvbigpXG4gICAgfTtcbiAgfTtcbiAgLyoqXG4gICAqIEdldCBhIG1hbmFnZXIgdGhhdCBtYW5hZ2VzIHRoZSBtb3ZlYWJsZSdzIHN0YXRlIGFuZCBwcm9wcy5cbiAgICogQG1ldGhvZCBNb3ZlYWJsZSNnZXRNYW5hZ2VyXG4gICAqIEByZXR1cm4gLSBUaGUgUmVjdCBJbmZvXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAgICpcbiAgICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XG4gICAqXG4gICAqIGNvbnN0IG1hbmFnZXIgPSBtb3ZlYWJsZS5nZXRNYW5hZ2VyKCk7IC8vIHJlYWwgbW92ZWFibGUgY2xhc3MgaW5zdGFuY2VcbiAgICovXG5cblxuICBfX3Byb3RvLmdldE1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX19wcm90by5nZXRSb3RhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2EgPSB0aGlzLnN0YXRlLFxuICAgICAgICBwb3MxID0gX2EucG9zMSxcbiAgICAgICAgcG9zMiA9IF9hLnBvczIsXG4gICAgICAgIGRpcmVjdGlvbiA9IF9hLmRpcmVjdGlvbjtcbiAgICByZXR1cm4gZ2V0QWJzb2x1dGVSb3RhdGlvbihwb3MxLCBwb3MyLCBkaXJlY3Rpb24pO1xuICB9O1xuICAvKipcbiAgICogUmVxdWVzdCBhYmxlIHRocm91Z2ggYSBtZXRob2QgcmF0aGVyIHRoYW4gYW4gZXZlbnQuXG4gICAqIEF0IHRoZSBtb21lbnQgb2YgZXhlY3V0aW9uLCByZXF1ZXN0U3RhcnQgaXMgZXhlY3V0ZWQsXG4gICAqIGFuZCB0aGVuIHJlcXVlc3QgYW5kIHJlcXVlc3RFbmQgY2FuIGJlIGV4ZWN1dGVkIHRocm91Z2ggUmVxdWVzdGVyLlxuICAgKiBAbWV0aG9kIE1vdmVhYmxlI3JlcXVlc3RcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kYXlicnVzaC5jb20vbW92ZWFibGUvcmVsZWFzZS9sYXRlc3QvZG9jL01vdmVhYmxlLkRyYWdnYWJsZS5odG1sI3JlcXVlc3R8RHJhZ2dhYmxlIFJlcXVlc3Rlcn1cbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kYXlicnVzaC5jb20vbW92ZWFibGUvcmVsZWFzZS9sYXRlc3QvZG9jL01vdmVhYmxlLlJlc2l6YWJsZS5odG1sI3JlcXVlc3R8UmVzaXphYmxlIFJlcXVlc3Rlcn1cbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kYXlicnVzaC5jb20vbW92ZWFibGUvcmVsZWFzZS9sYXRlc3QvZG9jL01vdmVhYmxlLlNjYWxhYmxlLmh0bWwjcmVxdWVzdHxTY2FsYWJsZSBSZXF1ZXN0ZXJ9XG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGF5YnJ1c2guY29tL21vdmVhYmxlL3JlbGVhc2UvbGF0ZXN0L2RvYy9Nb3ZlYWJsZS5Sb3RhdGFibGUuaHRtbCNyZXF1ZXN0fFJvdGF0YWJsZSBSZXF1ZXN0ZXJ9XG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGF5YnJ1c2guY29tL21vdmVhYmxlL3JlbGVhc2UvbGF0ZXN0L2RvYy9Nb3ZlYWJsZS5PcmlnaW5EcmFnZ2FibGUuaHRtbCNyZXF1ZXN0fE9yaWdpbkRyYWdnYWJsZSBSZXF1ZXN0ZXJ9XG4gICAqIEBwYXJhbSAtIGFibGVOYW1lXG4gICAqIEBwYXJhbSAtIHJlcXVlc3QgdG8gYmUgYWJsZSBwYXJhbXMuXG4gICAqIEBwYXJhbSAtIElmIGlzSW5zdGFudCBpcyB0cnVlLCByZXF1ZXN0IGFuZCByZXF1ZXN0RW5kIGFyZSBleGVjdXRlZCBpbW1lZGlhdGVseS5cbiAgICogQHJldHVybiAtIEFibGUgUmVxdWVzdGVyLiBJZiB0aGVyZSBpcyBubyByZXF1ZXN0IGluIGFibGUsIG5vdGhpbmcgd2lsbCB3b3JrLlxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gICAqXG4gICAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICAgKlxuICAgKiAvLyBJbnN0YW50bHkgUmVxdWVzdCAocmVxdWVzdFN0YXJ0IC0gcmVxdWVzdCAtIHJlcXVlc3RFbmQpXG4gICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJkcmFnZ2FibGVcIiwgeyBkZWx0YVg6IDEwLCBkZWx0YVk6IDEwIH0sIHRydWUpO1xuICAgKlxuICAgKiAvLyBTdGFydCBtb3ZlXG4gICAqIGNvbnN0IHJlcXVlc3RlciA9IG1vdmVhYmxlLnJlcXVlc3QoXCJkcmFnZ2FibGVcIik7XG4gICAqIHJlcXVlc3Rlci5yZXF1ZXN0KHsgZGVsdGFYOiAxMCwgZGVsdGFZOiAxMCB9KTtcbiAgICogcmVxdWVzdGVyLnJlcXVlc3QoeyBkZWx0YVg6IDEwLCBkZWx0YVk6IDEwIH0pO1xuICAgKiByZXF1ZXN0ZXIucmVxdWVzdCh7IGRlbHRhWDogMTAsIGRlbHRhWTogMTAgfSk7XG4gICAqIHJlcXVlc3Rlci5yZXF1ZXN0RW5kKCk7XG4gICAqL1xuXG5cbiAgX19wcm90by5yZXF1ZXN0ID0gZnVuY3Rpb24gKGFibGVOYW1lLCBwYXJhbSwgaXNJbnN0YW50KSB7XG4gICAgaWYgKHBhcmFtID09PSB2b2lkIDApIHtcbiAgICAgIHBhcmFtID0ge307XG4gICAgfVxuXG4gICAgdmFyIF9hID0gdGhpcy5wcm9wcyxcbiAgICAgICAgYWJsZXMgPSBfYS5hYmxlcyxcbiAgICAgICAgZ3JvdXBhYmxlID0gX2EuZ3JvdXBhYmxlO1xuICAgIHZhciByZXF1c2V0QWJsZSA9IGFibGVzLmZpbHRlcihmdW5jdGlvbiAoYWJsZSkge1xuICAgICAgcmV0dXJuIGFibGUubmFtZSA9PT0gYWJsZU5hbWU7XG4gICAgfSlbMF07XG5cbiAgICBpZiAodGhpcy5pc0RyYWdnaW5nKCkgfHwgIXJlcXVzZXRBYmxlIHx8ICFyZXF1c2V0QWJsZS5yZXF1ZXN0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXF1ZXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIHJlcXVlc3RFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGFibGVSZXF1ZXN0ZXIgPSByZXF1c2V0QWJsZS5yZXF1ZXN0KHRoaXMpO1xuICAgIHZhciByZXF1ZXN0SW5zdGFudCA9IGlzSW5zdGFudCB8fCBwYXJhbS5pc0luc3RhbnQ7XG4gICAgdmFyIGFibGVUeXBlID0gYWJsZVJlcXVlc3Rlci5pc0NvbnRyb2wgPyBcImNvbnRyb2xBYmxlc1wiIDogXCJ0YXJnZXRBYmxlc1wiO1xuICAgIHZhciBldmVudEFmZml4ID0gXCJcIiArIChncm91cGFibGUgPyBcIkdyb3VwXCIgOiBcIlwiKSArIChhYmxlUmVxdWVzdGVyLmlzQ29udHJvbCA/IFwiQ29udHJvbFwiIDogXCJcIik7XG4gICAgdmFyIHJlcXVlc3RlciA9IHtcbiAgICAgIHJlcXVlc3Q6IGZ1bmN0aW9uIChhYmxlUGFyYW0pIHtcbiAgICAgICAgdHJpZ2dlckFibGUoc2VsZiwgYWJsZVR5cGUsIFwiZHJhZ1wiLCBldmVudEFmZml4LCBcIlwiLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgYWJsZVJlcXVlc3Rlci5yZXF1ZXN0KGFibGVQYXJhbSkpLCB7XG4gICAgICAgICAgcmVxdWVzdEFibGU6IGFibGVOYW1lLFxuICAgICAgICAgIGlzUmVxdWVzdDogdHJ1ZVxuICAgICAgICB9KSwgcmVxdWVzdEluc3RhbnQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICByZXF1ZXN0RW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyaWdnZXJBYmxlKHNlbGYsIGFibGVUeXBlLCBcImRyYWdcIiwgZXZlbnRBZmZpeCwgXCJFbmRcIiwgX19hc3NpZ24oX19hc3NpZ24oe30sIGFibGVSZXF1ZXN0ZXIucmVxdWVzdEVuZCgpKSwge1xuICAgICAgICAgIHJlcXVlc3RBYmxlOiBhYmxlTmFtZSxcbiAgICAgICAgICBpc1JlcXVlc3Q6IHRydWVcbiAgICAgICAgfSksIHJlcXVlc3RJbnN0YW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfTtcbiAgICB0cmlnZ2VyQWJsZShzZWxmLCBhYmxlVHlwZSwgXCJkcmFnXCIsIGV2ZW50QWZmaXgsIFwiU3RhcnRcIiwgX19hc3NpZ24oX19hc3NpZ24oe30sIGFibGVSZXF1ZXN0ZXIucmVxdWVzdFN0YXJ0KHBhcmFtKSksIHtcbiAgICAgIHJlcXVlc3RBYmxlOiBhYmxlTmFtZSxcbiAgICAgIGlzUmVxdWVzdDogdHJ1ZVxuICAgIH0pLCByZXF1ZXN0SW5zdGFudCk7XG4gICAgcmV0dXJuIHJlcXVlc3RJbnN0YW50ID8gcmVxdWVzdGVyLnJlcXVlc3QocGFyYW0pLnJlcXVlc3RFbmQoKSA6IHJlcXVlc3RlcjtcbiAgfTtcbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgTW92ZWFibGUgb2JqZWN0IGFuZCB0aGUgZXZlbnRzLlxuICAgKiBAbWV0aG9kIE1vdmVhYmxlI2Rlc3Ryb3lcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICAgKlxuICAgKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcbiAgICpcbiAgICogbW92ZWFibGUuZGVzdHJveSgpO1xuICAgKi9cblxuXG4gIF9fcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG4gIH07XG5cbiAgX19wcm90by51cGRhdGVSZW5kZXJQb3NlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIG9yaWdpbmFsQmVmb3JlT3JpZ2luID0gc3RhdGUub3JpZ2luYWxCZWZvcmVPcmlnaW4sXG4gICAgICAgIHRyYW5zZm9ybU9yaWdpbiA9IHN0YXRlLnRyYW5zZm9ybU9yaWdpbixcbiAgICAgICAgYWxsTWF0cml4ID0gc3RhdGUuYWxsTWF0cml4LFxuICAgICAgICBpczNkID0gc3RhdGUuaXMzZCxcbiAgICAgICAgcG9zMSA9IHN0YXRlLnBvczEsXG4gICAgICAgIHBvczIgPSBzdGF0ZS5wb3MyLFxuICAgICAgICBwb3MzID0gc3RhdGUucG9zMyxcbiAgICAgICAgcG9zNCA9IHN0YXRlLnBvczQsXG4gICAgICAgIHN0YXRlTGVmdCA9IHN0YXRlLmxlZnQsXG4gICAgICAgIHN0YXRlVG9wID0gc3RhdGUudG9wO1xuXG4gICAgdmFyIF9hID0gcHJvcHMucGFkZGluZyB8fCB7fSxcbiAgICAgICAgX2IgPSBfYS5sZWZ0LFxuICAgICAgICBsZWZ0ID0gX2IgPT09IHZvaWQgMCA/IDAgOiBfYixcbiAgICAgICAgX2MgPSBfYS50b3AsXG4gICAgICAgIHRvcCA9IF9jID09PSB2b2lkIDAgPyAwIDogX2MsXG4gICAgICAgIF9kID0gX2EuYm90dG9tLFxuICAgICAgICBib3R0b20gPSBfZCA9PT0gdm9pZCAwID8gMCA6IF9kLFxuICAgICAgICBfZSA9IF9hLnJpZ2h0LFxuICAgICAgICByaWdodCA9IF9lID09PSB2b2lkIDAgPyAwIDogX2U7XG5cbiAgICB2YXIgbiA9IGlzM2QgPyA0IDogMztcbiAgICB2YXIgYWJzb2x1dGVPcmlnaW4gPSBwcm9wcy5ncm91cGFibGUgPyBvcmlnaW5hbEJlZm9yZU9yaWdpbiA6IHBsdXMob3JpZ2luYWxCZWZvcmVPcmlnaW4sIFtzdGF0ZUxlZnQsIHN0YXRlVG9wXSk7XG4gICAgc3RhdGUucmVuZGVyUG9zZXMgPSBbcGx1cyhwb3MxLCBjYWxjdWxhdGVQYWRkaW5nKGFsbE1hdHJpeCwgWy1sZWZ0LCAtdG9wXSwgdHJhbnNmb3JtT3JpZ2luLCBhYnNvbHV0ZU9yaWdpbiwgbikpLCBwbHVzKHBvczIsIGNhbGN1bGF0ZVBhZGRpbmcoYWxsTWF0cml4LCBbcmlnaHQsIC10b3BdLCB0cmFuc2Zvcm1PcmlnaW4sIGFic29sdXRlT3JpZ2luLCBuKSksIHBsdXMocG9zMywgY2FsY3VsYXRlUGFkZGluZyhhbGxNYXRyaXgsIFstbGVmdCwgYm90dG9tXSwgdHJhbnNmb3JtT3JpZ2luLCBhYnNvbHV0ZU9yaWdpbiwgbikpLCBwbHVzKHBvczQsIGNhbGN1bGF0ZVBhZGRpbmcoYWxsTWF0cml4LCBbcmlnaHQsIGJvdHRvbV0sIHRyYW5zZm9ybU9yaWdpbiwgYWJzb2x1dGVPcmlnaW4sIG4pKV07XG4gIH07XG5cbiAgX19wcm90by5jaGVja1VwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2EgPSB0aGlzLnByb3BzLFxuICAgICAgICB0YXJnZXQgPSBfYS50YXJnZXQsXG4gICAgICAgIGNvbnRhaW5lciA9IF9hLmNvbnRhaW5lcixcbiAgICAgICAgcGFyZW50TW92ZWFibGUgPSBfYS5wYXJlbnRNb3ZlYWJsZTtcbiAgICB2YXIgX2IgPSB0aGlzLnN0YXRlLFxuICAgICAgICBzdGF0ZVRhcmdldCA9IF9iLnRhcmdldCxcbiAgICAgICAgc3RhdGVDb250YWluZXIgPSBfYi5jb250YWluZXI7XG5cbiAgICBpZiAoIXN0YXRlVGFyZ2V0ICYmICF0YXJnZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZUFibGVzKCk7XG4gICAgdmFyIGlzQ2hhbmdlZCA9ICFlcXVhbHMoc3RhdGVUYXJnZXQsIHRhcmdldCkgfHwgIWVxdWFscyhzdGF0ZUNvbnRhaW5lciwgY29udGFpbmVyKTtcblxuICAgIGlmICghaXNDaGFuZ2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG1vdmVhYmxlQ29udGFpbmVyID0gY29udGFpbmVyIHx8IHRoaXMuY29udHJvbEJveDtcblxuICAgIGlmIChtb3ZlYWJsZUNvbnRhaW5lcikge1xuICAgICAgdGhpcy51bnNldEFibGVzKCk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVTdGF0ZSh7XG4gICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyXG4gICAgfSk7XG5cbiAgICBpZiAoIXBhcmVudE1vdmVhYmxlICYmIG1vdmVhYmxlQ29udGFpbmVyKSB7XG4gICAgICB0aGlzLnVwZGF0ZVJlY3QoXCJFbmRcIiwgZmFsc2UsIGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgX19wcm90by50cmlnZ2VyRXZlbnQgPSBmdW5jdGlvbiAobmFtZSwgZSkge1xuICAgIHZhciBjYWxsYmFjayA9IHRoaXMucHJvcHNbbmFtZV07XG4gICAgcmV0dXJuIGNhbGxiYWNrICYmIGNhbGxiYWNrKGUpO1xuICB9O1xuXG4gIF9fcHJvdG8udXNlQ1NTID0gZnVuY3Rpb24gKHRhZywgY3NzKSB7XG4gICAgdmFyIGN1c3RvbVN0eWxlTWFwID0gdGhpcy5wcm9wcy5jdXN0b21TdHlsZWRNYXA7XG4gICAgdmFyIGtleSA9IHRhZyArIGNzcztcblxuICAgIGlmICghY3VzdG9tU3R5bGVNYXBba2V5XSkge1xuICAgICAgY3VzdG9tU3R5bGVNYXBba2V5XSA9IHN0eWxlZCh0YWcsIGNzcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1c3RvbVN0eWxlTWFwW2tleV07XG4gIH07XG5cbiAgX19wcm90by51bnNldEFibGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLnRhcmdldEFibGVzLmZvckVhY2goZnVuY3Rpb24gKGFibGUpIHtcbiAgICAgIGlmIChhYmxlLnVuc2V0KSB7XG4gICAgICAgIGFibGUudW5zZXQoX3RoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF9fcHJvdG8udXBkYXRlQWJsZXMgPSBmdW5jdGlvbiAoYWJsZXMsIGV2ZW50QWZmaXgpIHtcbiAgICBpZiAoYWJsZXMgPT09IHZvaWQgMCkge1xuICAgICAgYWJsZXMgPSB0aGlzLnByb3BzLmFibGVzO1xuICAgIH1cblxuICAgIGlmIChldmVudEFmZml4ID09PSB2b2lkIDApIHtcbiAgICAgIGV2ZW50QWZmaXggPSBcIlwiO1xuICAgIH1cblxuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHRyaWdnZXJBYmxlc1NpbXVsdGFuZW91c2x5ID0gcHJvcHMudHJpZ2dlckFibGVzU2ltdWx0YW5lb3VzbHk7XG4gICAgdmFyIGVuYWJsZWRBYmxlcyA9IGFibGVzLmZpbHRlcihmdW5jdGlvbiAoYWJsZSkge1xuICAgICAgcmV0dXJuIGFibGUgJiYgKGFibGUuYWx3YXlzICYmIHByb3BzW2FibGUubmFtZV0gIT09IGZhbHNlIHx8IHByb3BzW2FibGUubmFtZV0pO1xuICAgIH0pO1xuICAgIHZhciBkcmFnU3RhcnQgPSBcImRyYWdcIiArIGV2ZW50QWZmaXggKyBcIlN0YXJ0XCI7XG4gICAgdmFyIHBpbmNoU3RhcnQgPSBcInBpbmNoXCIgKyBldmVudEFmZml4ICsgXCJTdGFydFwiO1xuICAgIHZhciBkcmFnQ29udHJvbFN0YXJ0ID0gXCJkcmFnXCIgKyBldmVudEFmZml4ICsgXCJDb250cm9sU3RhcnRcIjtcbiAgICB2YXIgdGFyZ2V0QWJsZXMgPSBmaWx0ZXJBYmxlcyhlbmFibGVkQWJsZXMsIFtkcmFnU3RhcnQsIHBpbmNoU3RhcnRdLCB0cmlnZ2VyQWJsZXNTaW11bHRhbmVvdXNseSk7XG4gICAgdmFyIGNvbnRyb2xBYmxlcyA9IGZpbHRlckFibGVzKGVuYWJsZWRBYmxlcywgW2RyYWdDb250cm9sU3RhcnRdLCB0cmlnZ2VyQWJsZXNTaW11bHRhbmVvdXNseSk7XG4gICAgdGhpcy5lbmFibGVkQWJsZXMgPSBlbmFibGVkQWJsZXM7XG4gICAgdGhpcy50YXJnZXRBYmxlcyA9IHRhcmdldEFibGVzO1xuICAgIHRoaXMuY29udHJvbEFibGVzID0gY29udHJvbEFibGVzO1xuICB9O1xuXG4gIF9fcHJvdG8udXBkYXRlU3RhdGUgPSBmdW5jdGlvbiAobmV4dFN0YXRlLCBpc1NldFN0YXRlKSB7XG4gICAgaWYgKGlzU2V0U3RhdGUpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUobmV4dFN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcblxuICAgICAgZm9yICh2YXIgbmFtZSBpbiBuZXh0U3RhdGUpIHtcbiAgICAgICAgc3RhdGVbbmFtZV0gPSBuZXh0U3RhdGVbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9fcHJvdG8uZ2V0RW5hYmxlZEFibGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGFibGVzID0gcHJvcHMuYWJsZXM7XG4gICAgcmV0dXJuIGFibGVzLmZpbHRlcihmdW5jdGlvbiAoYWJsZSkge1xuICAgICAgcmV0dXJuIGFibGUgJiYgcHJvcHNbYWJsZS5uYW1lXTtcbiAgICB9KTtcbiAgfTtcblxuICBfX3Byb3RvLnJlbmRlckFibGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciB0cmlnZ2VyQWJsZXNTaW11bHRhbmVvdXNseSA9IHByb3BzLnRyaWdnZXJBYmxlc1NpbXVsdGFuZW91c2x5O1xuICAgIHZhciBSZW5kZXJlciA9IHtcbiAgICAgIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRcbiAgICB9O1xuICAgIHJldHVybiBncm91cEJ5TWFwKGZsYXQoZmlsdGVyQWJsZXModGhpcy5nZXRFbmFibGVkQWJsZXMoKSwgW1wicmVuZGVyXCJdLCB0cmlnZ2VyQWJsZXNTaW11bHRhbmVvdXNseSkubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgdmFyIHJlbmRlciA9IF9hLnJlbmRlcjtcbiAgICAgIHJldHVybiByZW5kZXIoX3RoaXMsIFJlbmRlcmVyKSB8fCBbXTtcbiAgICB9KSkuZmlsdGVyKGZ1bmN0aW9uIChlbCkge1xuICAgICAgcmV0dXJuIGVsO1xuICAgIH0pLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgIHZhciBrZXkgPSBfYS5rZXk7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH0pLm1hcChmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICAgIHJldHVybiBncm91cFswXTtcbiAgICB9KTtcbiAgfTtcblxuICBfX3Byb3RvLnVwZGF0ZUNoZWNrSW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy50YXJnZXRHZXN0byAmJiAodGhpcy50YXJnZXRHZXN0by5vcHRpb25zLmNoZWNrSW5wdXQgPSB0aGlzLnByb3BzLmNoZWNrSW5wdXQpO1xuICB9O1xuXG4gIF9fcHJvdG8uX3VwZGF0ZU9ic2VydmVyID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xuICAgIHZhciBfYTtcblxuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHRhcmdldCA9IHByb3BzLnRhcmdldDtcblxuICAgIGlmICghd2luZG93LlJlc2l6ZU9ic2VydmVyIHx8ICF0YXJnZXQgfHwgIXByb3BzLnVzZVJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICAoX2EgPSB0aGlzLl9vYnNlcnZlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJldlByb3BzLnRhcmdldCA9PT0gdGFyZ2V0ICYmIHRoaXMuX29ic2VydmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKHRoaXMuY2hlY2tVcGRhdGVSZWN0KTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKHRhcmdldCwge1xuICAgICAgYm94OiBcImJvcmRlci1ib3hcIlxuICAgIH0pO1xuICAgIHRoaXMuX29ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgcmV0dXJuO1xuICB9O1xuXG4gIF9fcHJvdG8uX3VwZGF0ZUV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29udHJvbEJveEVsZW1lbnQgPSB0aGlzLmNvbnRyb2xCb3guZ2V0RWxlbWVudCgpO1xuICAgIHZhciBoYXNUYXJnZXRBYmxlID0gdGhpcy50YXJnZXRBYmxlcy5sZW5ndGg7XG4gICAgdmFyIGhhc0NvbnRyb2xBYmxlID0gdGhpcy5jb250cm9sQWJsZXMubGVuZ3RoO1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHRhcmdldCA9IHByb3BzLmRyYWdUYXJnZXQgfHwgcHJvcHMudGFyZ2V0O1xuXG4gICAgdmFyIGlzVW5zZXQgPSAhaGFzVGFyZ2V0QWJsZSAmJiB0aGlzLnRhcmdldEdlc3RvIHx8IHRoaXMuX2lzVGFyZ2V0Q2hhbmdlZCh0cnVlKTtcblxuICAgIGlmIChpc1Vuc2V0KSB7XG4gICAgICB1bnNldCh0aGlzLCBcInRhcmdldEdlc3RvXCIpO1xuICAgICAgdGhpcy51cGRhdGVTdGF0ZSh7XG4gICAgICAgIGdlc3RvOiBudWxsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIWhhc0NvbnRyb2xBYmxlKSB7XG4gICAgICB1bnNldCh0aGlzLCBcImNvbnRyb2xHZXN0b1wiKTtcbiAgICB9XG5cbiAgICBpZiAodGFyZ2V0ICYmIGhhc1RhcmdldEFibGUgJiYgIXRoaXMudGFyZ2V0R2VzdG8pIHtcbiAgICAgIHRoaXMudGFyZ2V0R2VzdG8gPSBnZXRUYXJnZXRBYmxlR2VzdG8odGhpcywgdGFyZ2V0LCBcIlwiKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuY29udHJvbEdlc3RvICYmIGhhc0NvbnRyb2xBYmxlKSB7XG4gICAgICB0aGlzLmNvbnRyb2xHZXN0byA9IGdldEFibGVHZXN0byh0aGlzLCBjb250cm9sQm94RWxlbWVudCwgXCJjb250cm9sQWJsZXNcIiwgXCJDb250cm9sXCIpO1xuICAgIH1cbiAgfTtcblxuICBfX3Byb3RvLl91cGRhdGVUYXJnZXRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdGhpcy5fcHJldlRhcmdldCA9IHByb3BzLmRyYWdUYXJnZXQgfHwgcHJvcHMudGFyZ2V0O1xuICAgIHRoaXMuX3ByZXZEcmFnQXJlYSA9IHByb3BzLmRyYWdBcmVhO1xuICB9O1xuXG4gIF9fcHJvdG8uX3JlbmRlckxpbmVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGVkZ2UgPSBwcm9wcy5lZGdlLFxuICAgICAgICB6b29tID0gcHJvcHMuem9vbSxcbiAgICAgICAgaGlkZURlZmF1bHRMaW5lcyA9IHByb3BzLmhpZGVEZWZhdWx0TGluZXM7XG5cbiAgICBpZiAoaGlkZURlZmF1bHRMaW5lcykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciByZW5kZXJQb3NlcyA9IHRoaXMuc3RhdGUucmVuZGVyUG9zZXM7XG4gICAgdmFyIFJlbmRlcmVyID0ge1xuICAgICAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudFxuICAgIH07XG4gICAgcmV0dXJuIFtyZW5kZXJMaW5lKFJlbmRlcmVyLCBlZGdlID8gXCJuXCIgOiBcIlwiLCByZW5kZXJQb3Nlc1swXSwgcmVuZGVyUG9zZXNbMV0sIHpvb20sIDApLCByZW5kZXJMaW5lKFJlbmRlcmVyLCBlZGdlID8gXCJlXCIgOiBcIlwiLCByZW5kZXJQb3Nlc1sxXSwgcmVuZGVyUG9zZXNbM10sIHpvb20sIDEpLCByZW5kZXJMaW5lKFJlbmRlcmVyLCBlZGdlID8gXCJ3XCIgOiBcIlwiLCByZW5kZXJQb3Nlc1swXSwgcmVuZGVyUG9zZXNbMl0sIHpvb20sIDIpLCByZW5kZXJMaW5lKFJlbmRlcmVyLCBlZGdlID8gXCJzXCIgOiBcIlwiLCByZW5kZXJQb3Nlc1syXSwgcmVuZGVyUG9zZXNbM10sIHpvb20sIDMpXTtcbiAgfTtcblxuICBfX3Byb3RvLl9pc1RhcmdldENoYW5nZWQgPSBmdW5jdGlvbiAodXNlRHJhZ0FyZWEpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciB0YXJnZXQgPSBwcm9wcy5kcmFnVGFyZ2V0IHx8IHByb3BzLnRhcmdldDtcbiAgICB2YXIgcHJldlRhcmdldCA9IHRoaXMuX3ByZXZUYXJnZXQ7XG4gICAgdmFyIHByZXZEcmFnQXJlYSA9IHRoaXMuX3ByZXZEcmFnQXJlYTtcbiAgICB2YXIgZHJhZ0FyZWEgPSBwcm9wcy5kcmFnQXJlYTsgLy8gY2hlY2sgdGFyZ2V0IHdpdGhvdXQgZHJhZ0FyZWFcblxuICAgIHZhciBpc1RhcmdldENoYW5nZWQgPSAhZHJhZ0FyZWEgJiYgcHJldlRhcmdldCAhPT0gdGFyZ2V0O1xuICAgIHZhciBpc0RyYWdBcmVhQ2hhbmdlZCA9ICh1c2VEcmFnQXJlYSB8fCBkcmFnQXJlYSkgJiYgcHJldkRyYWdBcmVhICE9PSBkcmFnQXJlYTtcbiAgICByZXR1cm4gaXNUYXJnZXRDaGFuZ2VkIHx8IGlzRHJhZ0FyZWFDaGFuZ2VkO1xuICB9O1xuXG4gIF9fcHJvdG8uX3VwZGF0ZU5hdGl2ZUV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgdGFyZ2V0ID0gcHJvcHMuZHJhZ0FyZWEgPyB0aGlzLmFyZWFFbGVtZW50IDogdGhpcy5zdGF0ZS50YXJnZXQ7XG4gICAgdmFyIGV2ZW50cyA9IHRoaXMuZXZlbnRzO1xuICAgIHZhciBldmVudEtleXMgPSBnZXRLZXlzKGV2ZW50cyk7XG5cbiAgICBpZiAodGhpcy5faXNUYXJnZXRDaGFuZ2VkKCkpIHtcbiAgICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBldmVudHMpIHtcbiAgICAgICAgdmFyIG1hbmFnZXIgPSBldmVudHNbZXZlbnROYW1lXTtcbiAgICAgICAgbWFuYWdlciAmJiBtYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICAgICAgZXZlbnRzW2V2ZW50TmFtZV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGVuYWJsZWRBYmxlcyA9IHRoaXMuZW5hYmxlZEFibGVzO1xuICAgIGV2ZW50S2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgIHZhciBhYmxlcyA9IGZpbHRlckFibGVzKGVuYWJsZWRBYmxlcywgW2V2ZW50TmFtZV0pO1xuICAgICAgdmFyIGhhc0FibGVzID0gYWJsZXMubGVuZ3RoID4gMDtcbiAgICAgIHZhciBtYW5hZ2VyID0gZXZlbnRzW2V2ZW50TmFtZV07XG5cbiAgICAgIGlmICghaGFzQWJsZXMpIHtcbiAgICAgICAgaWYgKG1hbmFnZXIpIHtcbiAgICAgICAgICBtYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICAgICAgICBldmVudHNbZXZlbnROYW1lXSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghbWFuYWdlcikge1xuICAgICAgICBtYW5hZ2VyID0gbmV3IEV2ZW50TWFuYWdlcih0YXJnZXQsIF90aGlzLCBldmVudE5hbWUpO1xuICAgICAgICBldmVudHNbZXZlbnROYW1lXSA9IG1hbmFnZXI7XG4gICAgICB9XG5cbiAgICAgIG1hbmFnZXIuc2V0QWJsZXMoYWJsZXMpO1xuICAgIH0pO1xuICB9O1xuXG4gIE1vdmVhYmxlTWFuYWdlci5kZWZhdWx0UHJvcHMgPSB7XG4gICAgdGFyZ2V0OiBudWxsLFxuICAgIGRyYWdUYXJnZXQ6IG51bGwsXG4gICAgY29udGFpbmVyOiBudWxsLFxuICAgIHJvb3RDb250YWluZXI6IG51bGwsXG4gICAgb3JpZ2luOiB0cnVlLFxuICAgIGVkZ2U6IGZhbHNlLFxuICAgIHBhcmVudE1vdmVhYmxlOiBudWxsLFxuICAgIHdyYXBwZXJNb3ZlYWJsZTogbnVsbCxcbiAgICBwYXJlbnRQb3NpdGlvbjogbnVsbCxcbiAgICBwb3J0YWxDb250YWluZXI6IG51bGwsXG4gICAgdXNlUmVzaXplT2JzZXJ2ZXI6IGZhbHNlLFxuICAgIGFibGVzOiBbXSxcbiAgICBwaW5jaFRocmVzaG9sZDogMjAsXG4gICAgZHJhZ0FyZWE6IGZhbHNlLFxuICAgIHBhc3NEcmFnQXJlYTogZmFsc2UsXG4gICAgdHJhbnNmb3JtT3JpZ2luOiBcIlwiLFxuICAgIGNsYXNzTmFtZTogXCJcIixcbiAgICB6b29tOiAxLFxuICAgIHRyaWdnZXJBYmxlc1NpbXVsdGFuZW91c2x5OiBmYWxzZSxcbiAgICBwYWRkaW5nOiB7fSxcbiAgICBwaW5jaE91dHNpZGU6IHRydWUsXG4gICAgY2hlY2tJbnB1dDogZmFsc2UsXG4gICAgZ3JvdXBhYmxlOiBmYWxzZSxcbiAgICBoaWRlRGVmYXVsdExpbmVzOiBmYWxzZSxcbiAgICBjc3BOb25jZTogXCJcIixcbiAgICB0cmFuc2xhdGVaOiAwLFxuICAgIGNzc1N0eWxlZDogbnVsbCxcbiAgICBjdXN0b21TdHlsZWRNYXA6IHt9LFxuICAgIHByb3BzOiB7fVxuICB9O1xuICByZXR1cm4gTW92ZWFibGVNYW5hZ2VyO1xufShQdXJlQ29tcG9uZW50KTtcbi8qKlxuICogVGhlIHRhcmdldCB0byBpbmRpY2F0ZSBNb3ZlYWJsZSBDb250cm9sIEJveC5cbiAqIEBuYW1lIE1vdmVhYmxlI3RhcmdldFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcbiAqIG1vdmVhYmxlLnRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIudGFyZ2V0XCIpO1xuICovXG5cbi8qKlxuICogWm9vbXMgaW4gdGhlIGVsZW1lbnRzIG9mIGEgbW92ZWFibGUuXG4gKiBAbmFtZSBNb3ZlYWJsZSN6b29tXG4gKiBAZGVmYXVsdCAxXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICogbW92ZWFibGUuem9vbSA9IDI7XG4gKi9cblxuLyoqXG4gKiBXaGV0aGVyIHRoZSB0YXJnZXQgc2l6ZSBpcyBkZXRlY3RlZCBhbmQgdXBkYXRlZCB3aGVuZXZlciBpdCBjaGFuZ2VzLlxuICogQG5hbWUgTW92ZWFibGUjem9vbVxuICogQGRlZmF1bHQgZmFsc2VcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XG4gKiBtb3ZlYWJsZS51c2VSZXNpemVPYnNlcnZlciA9IHRydWU7XG4gKi9cblxuLyoqXG4gKiBSZXNpemUsIFNjYWxlIEV2ZW50cyBhdCBlZGdlc1xuICogQG5hbWUgTW92ZWFibGUjZWRnZVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcbiAqIG1vdmVhYmxlLmVkZ2UgPSB0cnVlO1xuICovXG5cbi8qKlxuICogWW91IGNhbiBzcGVjaWZ5IHRoZSBjbGFzc05hbWUgb2YgdGhlIG1vdmVhYmxlIGNvbnRyb2xib3guXG4gKiBAbmFtZSBNb3ZlYWJsZSNjbGFzc05hbWVcbiAqIEBkZWZhdWx0IFwiXCJcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICBjbGFzc05hbWU6IFwiXCIsXG4gKiB9KTtcbiAqXG4gKiBtb3ZlYWJsZS5jbGFzc05hbWUgPSBcIm1vdmVhYmxlMVwiO1xuICovXG5cbi8qKlxuICogVGhlIHRhcmdldChzKSB0byBkcmFnIE1vdmVhYmxlIHRhcmdldChzKVxuICogQG5hbWUgTW92ZWFibGUjZHJhZ1RhcmdldFxuICogQGRlZmF1bHQgdGFyZ2V0XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICogbW92ZWFibGUudGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi50YXJnZXRcIik7XG4gKiBtb3ZlYWJsZS5kcmFnVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5kcmFnVGFyZ2V0XCIpO1xuICovXG5cbi8qKlxuICogYHJlbmRlclN0YXJ0YCBldmVudCBvY2N1cnMgYXQgdGhlIGZpcnN0IHN0YXJ0IG9mIGFsbCBldmVudHMuXG4gKiBAbWVtYmVyb2YgTW92ZWFibGVcbiAqIEBldmVudCByZW5kZXJTdGFydFxuICogQHBhcmFtIHtNb3ZlYWJsZS5PblJlbmRlclN0YXJ0fSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgcmVuZGVyU3RhcnRgIGV2ZW50XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgICB0YXJnZXQ6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIudGFyZ2V0XCIpLFxuICogfSk7XG4gKiBtb3ZlYWJsZS5vbihcInJlbmRlclN0YXJ0XCIsICh7IHRhcmdldCB9KSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coXCJvblJlbmRlclN0YXJ0XCIsIHRhcmdldCk7XG4gKiB9KTtcbiAqL1xuXG4vKipcbiAqIGByZW5kZXJgIGV2ZW50IG9jY3VycyBiZWZvcmUgdGhlIHRhcmdldCBpcyBkcmF3biBvbiB0aGUgc2NyZWVuLlxuICogQG1lbWJlcm9mIE1vdmVhYmxlXG4gKiBAZXZlbnQgcmVuZGVyXG4gKiBAcGFyYW0ge01vdmVhYmxlLk9uUmVuZGVyfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgcmVuZGVyYCBldmVudFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgdGFyZ2V0OiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLnRhcmdldFwiKSxcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJyZW5kZXJcIiwgKHsgdGFyZ2V0IH0pID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhcIm9uUmVuZGVyXCIsIHRhcmdldCk7XG4gKiB9KTtcbiAqL1xuXG4vKipcbiAqIGByZW5kZXJFbmRgIGV2ZW50IG9jY3VycyBhdCB0aGUgZW5kIG9mIGFsbCBldmVudHMuXG4gKiBAbWVtYmVyb2YgTW92ZWFibGVcbiAqIEBldmVudCByZW5kZXJFbmRcbiAqIEBwYXJhbSB7TW92ZWFibGUuT25SZW5kZXJFbmR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGByZW5kZXJFbmRgIGV2ZW50XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgICB0YXJnZXQ6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIudGFyZ2V0XCIpLFxuICogfSk7XG4gKiBtb3ZlYWJsZS5vbihcInJlbmRlckVuZFwiLCAoeyB0YXJnZXQgfSkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKFwib25SZW5kZXJFbmRcIiwgdGFyZ2V0KTtcbiAqIH0pO1xuICovXG5cbi8qKlxuICogYHJlbmRlckdyb3VwU3RhcnRgIGV2ZW50IG9jY3VycyBhdCB0aGUgZmlyc3Qgc3RhcnQgb2YgYWxsIGV2ZW50cyBpbiBncm91cC5cbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZVxuICogQGV2ZW50IHJlbmRlckdyb3VwU3RhcnRcbiAqIEBwYXJhbSB7TW92ZWFibGUuT25SZW5kZXJHcm91cFN0YXJ0fSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgcmVuZGVyR3JvdXBTdGFydGAgZXZlbnRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICAgIHRhcmdldDogW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnRhcmdldFwiKSksXG4gKiB9KTtcbiAqIG1vdmVhYmxlLm9uKFwicmVuZGVyR3JvdXBTdGFydFwiLCAoeyB0YXJnZXRzIH0pID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhcIm9uUmVuZGVyR3JvdXBTdGFydFwiLCB0YXJnZXRzKTtcbiAqIH0pO1xuICovXG5cbi8qKlxuICogYHJlbmRlckdyb3VwYCBldmVudCBvY2N1cnMgYmVmb3JlIHRoZSB0YXJnZXQgaXMgZHJhd24gb24gdGhlIHNjcmVlbiBpbiBncm91cC5cbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZVxuICogQGV2ZW50IHJlbmRlckdyb3VwXG4gKiBAcGFyYW0ge01vdmVhYmxlLk9uUmVuZGVyR3JvdXB9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGByZW5kZXJHcm91cGAgZXZlbnRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICAgIHRhcmdldDogW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnRhcmdldFwiKSksXG4gKiB9KTtcbiAqIG1vdmVhYmxlLm9uKFwicmVuZGVyR3JvdXBcIiwgKHsgdGFyZ2V0cyB9KSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coXCJvblJlbmRlckdyb3VwXCIsIHRhcmdldHMpO1xuICogfSk7XG4gKi9cblxuLyoqXG4gKiBgcmVuZGVyR3JvdXBFbmRgIGV2ZW50IG9jY3VycyBhdCB0aGUgZW5kIG9mIGFsbCBldmVudHMgaW4gZ3JvdXAuXG4gKiBAbWVtYmVyb2YgTW92ZWFibGVcbiAqIEBldmVudCByZW5kZXJHcm91cEVuZFxuICogQHBhcmFtIHtNb3ZlYWJsZS5PblJlbmRlckdyb3VwRW5kfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgcmVuZGVyR3JvdXBFbmRgIGV2ZW50XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgICB0YXJnZXQ6IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi50YXJnZXRcIikpLFxuICogfSk7XG4gKiBtb3ZlYWJsZS5vbihcInJlbmRlckdyb3VwRW5kXCIsICh7IHRhcmdldHMgfSkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKFwib25SZW5kZXJHcm91cEVuZFwiLCB0YXJnZXRzKTtcbiAqIH0pO1xuICovXG5cbnZhciBHcm91cGFibGUgPSB7XG4gIG5hbWU6IFwiZ3JvdXBhYmxlXCIsXG4gIHByb3BzOiB7XG4gICAgZGVmYXVsdEdyb3VwUm90YXRlOiBOdW1iZXIsXG4gICAgZGVmYXVsdEdyb3VwT3JpZ2luOiBTdHJpbmcsXG4gICAgZ3JvdXBhYmxlOiBCb29sZWFuXG4gIH0sXG4gIGV2ZW50czoge30sXG4gIHJlbmRlcjogZnVuY3Rpb24gKG1vdmVhYmxlLCBSZWFjdCkge1xuICAgIHZhciB0YXJnZXRzID0gbW92ZWFibGUucHJvcHMudGFyZ2V0cyB8fCBbXTtcbiAgICBtb3ZlYWJsZS5tb3ZlYWJsZXMgPSBbXTtcbiAgICB2YXIgX2EgPSBtb3ZlYWJsZS5zdGF0ZSxcbiAgICAgICAgbGVmdCA9IF9hLmxlZnQsXG4gICAgICAgIHRvcCA9IF9hLnRvcDtcbiAgICB2YXIgcG9zaXRpb24gPSB7XG4gICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgdG9wOiB0b3BcbiAgICB9O1xuICAgIHZhciBwcm9wcyA9IG1vdmVhYmxlLnByb3BzO1xuICAgIHJldHVybiB0YXJnZXRzLm1hcChmdW5jdGlvbiAodGFyZ2V0LCBpKSB7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChNb3ZlYWJsZU1hbmFnZXIsIHtcbiAgICAgICAga2V5OiBcIm1vdmVhYmxlXCIgKyBpLFxuICAgICAgICByZWY6IHJlZnMobW92ZWFibGUsIFwibW92ZWFibGVzXCIsIGkpLFxuICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgb3JpZ2luOiBmYWxzZSxcbiAgICAgICAgY3NzU3R5bGVkOiBwcm9wcy5jc3NTdHlsZWQsXG4gICAgICAgIGN1c3RvbVN0eWxlZE1hcDogcHJvcHMuY3VzdG9tU3R5bGVkTWFwLFxuICAgICAgICB1c2VSZXNpemVPYnNlcnZlcjogcHJvcHMudXNlUmVzaXplT2JzZXJ2ZXIsXG4gICAgICAgIHBhcmVudE1vdmVhYmxlOiBtb3ZlYWJsZSxcbiAgICAgICAgcGFyZW50UG9zaXRpb246IHBvc2l0aW9uXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufTtcblxudmFyIENsaWNrYWJsZSA9IG1ha2VBYmxlKFwiY2xpY2thYmxlXCIsIHtcbiAgcHJvcHM6IHtcbiAgICBjbGlja2FibGU6IEJvb2xlYW5cbiAgfSxcbiAgZXZlbnRzOiB7XG4gICAgb25DbGljazogXCJjbGlja1wiLFxuICAgIG9uQ2xpY2tHcm91cDogXCJjbGlja0dyb3VwXCJcbiAgfSxcbiAgYWx3YXlzOiB0cnVlLFxuICBkcmFnUmVsYXRpb246IFwid2Vha1wiLFxuICBkcmFnU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIGlmICghZS5pc1JlcXVlc3QpIHtcbiAgICAgIGFkZEV2ZW50KHdpbmRvdywgXCJjbGlja1wiLCBtb3ZlYWJsZS5vblByZXZlbnRDbGljaywgdHJ1ZSk7XG4gICAgfVxuICB9LFxuICBkcmFnQ29udHJvbFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB0aGlzLmRyYWdTdGFydChtb3ZlYWJsZSwgZSk7XG4gIH0sXG4gIGRyYWdHcm91cFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB0aGlzLmRyYWdTdGFydChtb3ZlYWJsZSwgZSk7XG4gICAgZS5kYXRhcy5pbnB1dFRhcmdldCA9IGUuaW5wdXRFdmVudCAmJiBlLmlucHV0RXZlbnQudGFyZ2V0O1xuICB9LFxuICBkcmFnRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB0aGlzLmVuZEV2ZW50KG1vdmVhYmxlKTtcbiAgICB2YXIgdGFyZ2V0ID0gbW92ZWFibGUuc3RhdGUudGFyZ2V0O1xuICAgIHZhciBpbnB1dEV2ZW50ID0gZS5pbnB1dEV2ZW50O1xuICAgIHZhciBpbnB1dFRhcmdldCA9IGUuaW5wdXRUYXJnZXQ7XG4gICAgdmFyIGlzTW92ZWFibGVFbGVtZW50ID0gbW92ZWFibGUuaXNNb3ZlYWJsZUVsZW1lbnQoaW5wdXRUYXJnZXQpO1xuICAgIHZhciBjb250YWluc0VsZW1lbnQgPSAhaXNNb3ZlYWJsZUVsZW1lbnQgJiYgbW92ZWFibGUuY29udHJvbEJveC5nZXRFbGVtZW50KCkuY29udGFpbnMoaW5wdXRUYXJnZXQpO1xuXG4gICAgaWYgKCFlLmlzRHJhZyB8fCBjb250YWluc0VsZW1lbnQpIHtcbiAgICAgIHRoaXMudW5zZXQobW92ZWFibGUpO1xuICAgIH1cblxuICAgIGlmICghaW5wdXRFdmVudCB8fCAhaW5wdXRUYXJnZXQgfHwgZS5pc0RyYWcgfHwgbW92ZWFibGUuaXNNb3ZlYWJsZUVsZW1lbnQoaW5wdXRUYXJnZXQpIHx8IGNvbnRhaW5zRWxlbWVudCAvLyBFeHRlcm5hbCBldmVudCBkdXBsaWNhdGUgdGFyZ2V0IG9yIGRyYWdBcmVhRWxlbWVudFxuICAgICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICB2YXIgY29udGFpbnNUYXJnZXQgPSB0YXJnZXQuY29udGFpbnMoaW5wdXRUYXJnZXQpO1xuICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkNsaWNrXCIsIGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIHtcbiAgICAgIGlzRG91YmxlOiBlLmlzRG91YmxlLFxuICAgICAgaW5wdXRUYXJnZXQ6IGlucHV0VGFyZ2V0LFxuICAgICAgaXNUYXJnZXQ6IHRhcmdldCA9PT0gaW5wdXRUYXJnZXQsXG4gICAgICBjb250YWluc1RhcmdldDogY29udGFpbnNUYXJnZXRcbiAgICB9KSk7XG4gIH0sXG4gIGRyYWdHcm91cEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdGhpcy5lbmRFdmVudChtb3ZlYWJsZSk7XG4gICAgdmFyIGlucHV0RXZlbnQgPSBlLmlucHV0RXZlbnQ7XG4gICAgdmFyIGlucHV0VGFyZ2V0ID0gZS5pbnB1dFRhcmdldDtcblxuICAgIGlmICghaW5wdXRFdmVudCB8fCAhaW5wdXRUYXJnZXQgfHwgZS5pc0RyYWcgfHwgbW92ZWFibGUuaXNNb3ZlYWJsZUVsZW1lbnQoaW5wdXRUYXJnZXQpIC8vIEV4dGVybmFsIGV2ZW50IGR1cGxpY2F0ZSB0YXJnZXQgb3IgZHJhZ0FyZWFFbGVtZW50XG4gICAgfHwgZS5kYXRhcy5pbnB1dFRhcmdldCA9PT0gaW5wdXRUYXJnZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0cyA9IG1vdmVhYmxlLnByb3BzLnRhcmdldHM7XG4gICAgdmFyIHRhcmdldEluZGV4ID0gdGFyZ2V0cy5pbmRleE9mKGlucHV0VGFyZ2V0KTtcbiAgICB2YXIgaXNUYXJnZXQgPSB0YXJnZXRJbmRleCA+IC0xO1xuICAgIHZhciBjb250YWluc1RhcmdldCA9IGZhbHNlO1xuXG4gICAgaWYgKHRhcmdldEluZGV4ID09PSAtMSkge1xuICAgICAgdGFyZ2V0SW5kZXggPSBmaW5kSW5kZXgodGFyZ2V0cywgZnVuY3Rpb24gKHBhcmVudFRhcmdldCkge1xuICAgICAgICByZXR1cm4gcGFyZW50VGFyZ2V0LmNvbnRhaW5zKGlucHV0VGFyZ2V0KTtcbiAgICAgIH0pO1xuICAgICAgY29udGFpbnNUYXJnZXQgPSB0YXJnZXRJbmRleCA+IC0xO1xuICAgIH1cblxuICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkNsaWNrR3JvdXBcIiwgZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xuICAgICAgaXNEb3VibGU6IGUuaXNEb3VibGUsXG4gICAgICB0YXJnZXRzOiB0YXJnZXRzLFxuICAgICAgaW5wdXRUYXJnZXQ6IGlucHV0VGFyZ2V0LFxuICAgICAgdGFyZ2V0SW5kZXg6IHRhcmdldEluZGV4LFxuICAgICAgaXNUYXJnZXQ6IGlzVGFyZ2V0LFxuICAgICAgY29udGFpbnNUYXJnZXQ6IGNvbnRhaW5zVGFyZ2V0XG4gICAgfSkpO1xuICB9LFxuICBkcmFnQ29udHJvbEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdGhpcy5kcmFnRW5kKG1vdmVhYmxlLCBlKTtcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdGhpcy5kcmFnRW5kKG1vdmVhYmxlLCBlKTtcbiAgfSxcbiAgZW5kRXZlbnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMudW5zZXQobW92ZWFibGUpO1xuICAgIH0pO1xuICB9LFxuICB1bnNldDogZnVuY3Rpb24gKG1vdmVhYmxlKSB7XG4gICAgcmVtb3ZlRXZlbnQod2luZG93LCBcImNsaWNrXCIsIG1vdmVhYmxlLm9uUHJldmVudENsaWNrLCB0cnVlKTtcbiAgfVxufSk7XG4vKipcbiAqIFdoZW4geW91IGNsaWNrIG9uIHRoZSBlbGVtZW50LCB0aGUgYGNsaWNrYCBldmVudCBpcyBjYWxsZWQuXG4gKiBAbWVtYmVyb2YgTW92ZWFibGVcbiAqIEBldmVudCBjbGlja1xuICogQHBhcmFtIHtNb3ZlYWJsZS5PbkNsaWNrfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgY2xpY2tgIGV2ZW50XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgICB0YXJnZXQ6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIudGFyZ2V0XCIpLFxuICogfSk7XG4gKiBtb3ZlYWJsZS5vbihcImNsaWNrXCIsICh7IGhhc1RhcmdldCwgY29udGFpbnNUYXJnZXQsIHRhcmdldEluZGV4IH0pID0+IHtcbiAqICAgICAvLyBJZiB5b3UgY2xpY2sgb24gYW4gZWxlbWVudCBvdGhlciB0aGFuIHRoZSB0YXJnZXQgYW5kIG5vdCBpbmNsdWRlZCBpbiB0aGUgdGFyZ2V0LCBpbmRleCBpcyAtMS5cbiAqICAgICBjb25zb2xlLmxvZyhcIm9uQ2xpY2tHcm91cFwiLCB0YXJnZXQsIGhhc1RhcmdldCwgY29udGFpbnNUYXJnZXQsIHRhcmdldEluZGV4KTtcbiAqIH0pO1xuICovXG5cbi8qKlxuICogV2hlbiB5b3UgY2xpY2sgb24gdGhlIGVsZW1lbnQgaW5zaWRlIHRoZSBncm91cCwgdGhlIGBjbGlja0dyb3VwYCBldmVudCBpcyBjYWxsZWQuXG4gKiBAbWVtYmVyb2YgTW92ZWFibGVcbiAqIEBldmVudCBjbGlja0dyb3VwXG4gKiBAcGFyYW0ge01vdmVhYmxlLk9uQ2xpY2tHcm91cH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYGNsaWNrR3JvdXBgIGV2ZW50XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgICB0YXJnZXQ6IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi50YXJnZXRcIikpLFxuICogfSk7XG4gKiBtb3ZlYWJsZS5vbihcImNsaWNrR3JvdXBcIiwgKHsgaW5wdXRUYXJnZXQsIGlzVGFyZ2V0LCBjb250YWluc1RhcmdldCwgdGFyZ2V0SW5kZXggfSkgPT4ge1xuICogICAgIC8vIElmIHlvdSBjbGljayBvbiBhbiBlbGVtZW50IG90aGVyIHRoYW4gdGhlIHRhcmdldCBhbmQgbm90IGluY2x1ZGVkIGluIHRoZSB0YXJnZXQsIGluZGV4IGlzIC0xLlxuICogICAgIGNvbnNvbGUubG9nKFwib25DbGlja0dyb3VwXCIsIGlucHV0VGFyZ2V0LCBpc1RhcmdldCwgY29udGFpbnNUYXJnZXQsIHRhcmdldEluZGV4KTtcbiAqIH0pO1xuICovXG5cbmZ1bmN0aW9uIGdldERyYWdnYWJsZUV2ZW50KGUpIHtcbiAgdmFyIGRhdGFzID0gZS5vcmlnaW5hbERhdGFzLmRyYWdnYWJsZTtcblxuICBpZiAoIWRhdGFzKSB7XG4gICAgZS5vcmlnaW5hbERhdGFzLmRyYWdnYWJsZSA9IHt9O1xuICAgIGRhdGFzID0gZS5vcmlnaW5hbERhdGFzLmRyYWdnYWJsZTtcbiAgfVxuXG4gIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHtcbiAgICBkYXRhczogZGF0YXNcbiAgfSk7XG59XG5cbnZhciBlZGdlRHJhZ2dhYmxlID0gbWFrZUFibGUoXCJlZGdlRHJhZ2dhYmxlXCIsIHtcbiAgZHJhZ0NvbnRyb2xDb25kaXRpb246IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIGlmICghbW92ZWFibGUucHJvcHMuZWRnZURyYWdnYWJsZSB8fCAhZS5pbnB1dEV2ZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldCA9IGUuaW5wdXRFdmVudC50YXJnZXQ7XG4gICAgcmV0dXJuIGhhc0NsYXNzKHRhcmdldCwgcHJlZml4KFwiZGlyZWN0aW9uXCIpKSAmJiBoYXNDbGFzcyh0YXJnZXQsIHByZWZpeChcImxpbmVcIikpO1xuICB9LFxuICBkcmFnQ29udHJvbFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gRHJhZ2dhYmxlLmRyYWdTdGFydChtb3ZlYWJsZSwgZ2V0RHJhZ2dhYmxlRXZlbnQoZSkpO1xuICB9LFxuICBkcmFnQ29udHJvbDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgcmV0dXJuIERyYWdnYWJsZS5kcmFnKG1vdmVhYmxlLCBnZXREcmFnZ2FibGVFdmVudChlKSk7XG4gIH0sXG4gIGRyYWdDb250cm9sRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gRHJhZ2dhYmxlLmRyYWdFbmQobW92ZWFibGUsIGdldERyYWdnYWJsZUV2ZW50KGUpKTtcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbENvbmRpdGlvbjogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgaWYgKCFtb3ZlYWJsZS5wcm9wcy5lZGdlRHJhZ2dhYmxlIHx8ICFlLmlucHV0RXZlbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0ID0gZS5pbnB1dEV2ZW50LnRhcmdldDtcbiAgICByZXR1cm4gaGFzQ2xhc3ModGFyZ2V0LCBwcmVmaXgoXCJkaXJlY3Rpb25cIikpICYmIGhhc0NsYXNzKHRhcmdldCwgcHJlZml4KFwibGluZVwiKSk7XG4gIH0sXG4gIGRyYWdHcm91cENvbnRyb2xTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgcmV0dXJuIERyYWdnYWJsZS5kcmFnR3JvdXBTdGFydChtb3ZlYWJsZSwgZ2V0RHJhZ2dhYmxlRXZlbnQoZSkpO1xuICB9LFxuICBkcmFnR3JvdXBDb250cm9sOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gRHJhZ2dhYmxlLmRyYWdHcm91cChtb3ZlYWJsZSwgZ2V0RHJhZ2dhYmxlRXZlbnQoZSkpO1xuICB9LFxuICBkcmFnR3JvdXBDb250cm9sRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gRHJhZ2dhYmxlLmRyYWdHcm91cEVuZChtb3ZlYWJsZSwgZ2V0RHJhZ2dhYmxlRXZlbnQoZSkpO1xuICB9LFxuICB1bnNldDogZnVuY3Rpb24gKG1vdmVhYmxlKSB7XG4gICAgcmV0dXJuIERyYWdnYWJsZS51bnNldChtb3ZlYWJsZSk7XG4gIH1cbn0pO1xuLyoqXG4gKiBXaGV0aGVyIHRvIG1vdmUgYnkgZHJhZ2dpbmcgdGhlIGVkZ2UgbGluZSAoZGVmYXVsdDogZmFsc2UpXG4gKiBAbmFtZSBNb3ZlYWJsZS5EcmFnZ2FibGUjZWRnZURyYWdnYWJsZVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgZHJhZ2dhYmxlOiB0cnVlLFxuICogIGVkZ2VEcmFnZ2FibGU6IGZhbHNlLFxuICogfSk7XG4gKlxuICogbW92ZWFibGUuZWRnZURyYWdnYWJsZSA9IHRydWU7XG4gKi9cblxudmFyIEluZGl2aWR1YWxHcm91cGFibGUgPSB7XG4gIG5hbWU6IFwiaW5kaXZpZHVhbEdyb3VwYWJsZVwiLFxuICBwcm9wczoge1xuICAgIGluZGl2aWR1YWxHcm91cGFibGU6IEJvb2xlYW5cbiAgfSxcbiAgZXZlbnRzOiB7fVxufTtcblxudmFyIE1PVkVBQkxFX0FCTEVTID0gLyojX19QVVJFX18qL1tCZWZvcmVSZW5kZXJhYmxlLCBEZWZhdWx0LCBTbmFwcGFibGUsIFBpbmNoYWJsZSwgRHJhZ2dhYmxlLCBlZGdlRHJhZ2dhYmxlLCBSb3RhdGFibGUsIFJlc2l6YWJsZSwgU2NhbGFibGUsIFdhcnBhYmxlLCBTY3JvbGxhYmxlLCBQYWRkaW5nLCBPcmlnaW4sIE9yaWdpbkRyYWdnYWJsZSwgQ2xpcHBhYmxlLCBSb3VuZGFibGUsIEdyb3VwYWJsZSwgSW5kaXZpZHVhbEdyb3VwYWJsZSwgQ2xpY2thYmxlLCBEcmFnQXJlYSwgUmVuZGVyYWJsZV07XG52YXIgTU9WRUFCTEVfRVZFTlRTX1BST1BTX01BUCA9IC8qI19fUFVSRV9fKi9NT1ZFQUJMRV9BQkxFUy5yZWR1Y2UoZnVuY3Rpb24gKGN1cnJlbnQsIGFibGUpIHtcbiAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBjdXJyZW50KSwgXCJldmVudHNcIiBpbiBhYmxlID8gYWJsZS5ldmVudHMgOiB7fSk7XG59LCB7fSk7XG52YXIgTU9WRUFCTEVfUFJPUFNfTUFQID0gLyojX19QVVJFX18qL01PVkVBQkxFX0FCTEVTLnJlZHVjZShmdW5jdGlvbiAoY3VycmVudCwgYWJsZSkge1xuICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGN1cnJlbnQpLCBhYmxlLnByb3BzKTtcbn0sIHt9KTtcbnZhciBNT1ZFQUJMRV9FVkVOVFNfTUFQID0gLyojX19QVVJFX18qL2ludmVydE9iamVjdChNT1ZFQUJMRV9FVkVOVFNfUFJPUFNfTUFQKTtcbnZhciBNT1ZFQUJMRV9FVkVOVFMgPSBPYmplY3Qua2V5cyhNT1ZFQUJMRV9FVkVOVFNfTUFQKTtcbnZhciBNT1ZFQUJMRV9QUk9QUyA9IE9iamVjdC5rZXlzKE1PVkVBQkxFX1BST1BTX01BUCk7XG5cbmZ1bmN0aW9uIGdldE1heFBvcyhwb3NlcywgaW5kZXgpIHtcbiAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KE1hdGgsIHBvc2VzLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgcG9zMSA9IF9hWzBdLFxuICAgICAgICBwb3MyID0gX2FbMV0sXG4gICAgICAgIHBvczMgPSBfYVsyXSxcbiAgICAgICAgcG9zNCA9IF9hWzNdO1xuICAgIHJldHVybiBNYXRoLm1heChwb3MxW2luZGV4XSwgcG9zMltpbmRleF0sIHBvczNbaW5kZXhdLCBwb3M0W2luZGV4XSk7XG4gIH0pKTtcbn1cblxuZnVuY3Rpb24gZ2V0TWluUG9zKHBvc2VzLCBpbmRleCkge1xuICByZXR1cm4gTWF0aC5taW4uYXBwbHkoTWF0aCwgcG9zZXMubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBwb3MxID0gX2FbMF0sXG4gICAgICAgIHBvczIgPSBfYVsxXSxcbiAgICAgICAgcG9zMyA9IF9hWzJdLFxuICAgICAgICBwb3M0ID0gX2FbM107XG4gICAgcmV0dXJuIE1hdGgubWluKHBvczFbaW5kZXhdLCBwb3MyW2luZGV4XSwgcG9zM1tpbmRleF0sIHBvczRbaW5kZXhdKTtcbiAgfSkpO1xufVxuXG5mdW5jdGlvbiBnZXRHcm91cFJlY3QobW92ZWFibGVzLCByb3RhdGlvbikge1xuICBpZiAoIW1vdmVhYmxlcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gWzAsIDAsIDAsIDBdO1xuICB9XG5cbiAgdmFyIG1vdmVhYmxlUG9zZXMgPSBtb3ZlYWJsZXMubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBzdGF0ZSA9IF9hLnN0YXRlO1xuICAgIHJldHVybiBnZXRBYnNvbHV0ZVBvc2VzQnlTdGF0ZShzdGF0ZSk7XG4gIH0pO1xuICB2YXIgbWluWCA9IE1BWF9OVU07XG4gIHZhciBtaW5ZID0gTUFYX05VTTtcbiAgdmFyIGdyb3VwV2lkdGggPSAwO1xuICB2YXIgZ3JvdXBIZWlnaHQgPSAwO1xuICB2YXIgZml4ZWRSb3RhdGlvbiA9IHRocm90dGxlKHJvdGF0aW9uLCBUSU5ZX05VTSk7XG5cbiAgaWYgKGZpeGVkUm90YXRpb24gJSA5MCkge1xuICAgIHZhciByYWRfMSA9IGZpeGVkUm90YXRpb24gLyAxODAgKiBNYXRoLlBJO1xuICAgIHZhciBhMV8xID0gTWF0aC50YW4ocmFkXzEpO1xuICAgIHZhciBhMl8xID0gLTEgLyBhMV8xO1xuICAgIHZhciBiMU1pbk1heF8xID0gW01JTl9OVU0sIE1BWF9OVU1dO1xuICAgIHZhciBiMk1pbk1heF8xID0gW01JTl9OVU0sIE1BWF9OVU1dO1xuICAgIG1vdmVhYmxlUG9zZXMuZm9yRWFjaChmdW5jdGlvbiAocG9zZXMpIHtcbiAgICAgIHBvc2VzLmZvckVhY2goZnVuY3Rpb24gKHBvcykge1xuICAgICAgICAvLyBheCArIGIgPSB5XG4gICAgICAgIC8vIGIgPSB5IC0gYXhcbiAgICAgICAgdmFyIGIxID0gcG9zWzFdIC0gYTFfMSAqIHBvc1swXTtcbiAgICAgICAgdmFyIGIyID0gcG9zWzFdIC0gYTJfMSAqIHBvc1swXTtcbiAgICAgICAgYjFNaW5NYXhfMVswXSA9IE1hdGgubWF4KGIxTWluTWF4XzFbMF0sIGIxKTtcbiAgICAgICAgYjFNaW5NYXhfMVsxXSA9IE1hdGgubWluKGIxTWluTWF4XzFbMV0sIGIxKTtcbiAgICAgICAgYjJNaW5NYXhfMVswXSA9IE1hdGgubWF4KGIyTWluTWF4XzFbMF0sIGIyKTtcbiAgICAgICAgYjJNaW5NYXhfMVsxXSA9IE1hdGgubWluKGIyTWluTWF4XzFbMV0sIGIyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGIxTWluTWF4XzEuZm9yRWFjaChmdW5jdGlvbiAoYjEpIHtcbiAgICAgIC8vIGExeCArIGIxID0gYTJ4ICsgYjJcbiAgICAgIGIyTWluTWF4XzEuZm9yRWFjaChmdW5jdGlvbiAoYjIpIHtcbiAgICAgICAgLy8gKGExIC0gYTIpeCA9IGIyIC0gYjFcbiAgICAgICAgdmFyIHggPSAoYjIgLSBiMSkgLyAoYTFfMSAtIGEyXzEpO1xuICAgICAgICB2YXIgeSA9IGExXzEgKiB4ICsgYjE7XG4gICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCB4KTtcbiAgICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIHkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdmFyIHJvdGF0ZVBvc2VzID0gbW92ZWFibGVQb3Nlcy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICB2YXIgcG9zMSA9IF9hWzBdLFxuICAgICAgICAgIHBvczIgPSBfYVsxXSxcbiAgICAgICAgICBwb3MzID0gX2FbMl0sXG4gICAgICAgICAgcG9zNCA9IF9hWzNdO1xuICAgICAgcmV0dXJuIFtyb3RhdGUocG9zMSwgLXJhZF8xKSwgcm90YXRlKHBvczIsIC1yYWRfMSksIHJvdGF0ZShwb3MzLCAtcmFkXzEpLCByb3RhdGUocG9zNCwgLXJhZF8xKV07XG4gICAgfSk7XG4gICAgZ3JvdXBXaWR0aCA9IGdldE1heFBvcyhyb3RhdGVQb3NlcywgMCkgLSBnZXRNaW5Qb3Mocm90YXRlUG9zZXMsIDApO1xuICAgIGdyb3VwSGVpZ2h0ID0gZ2V0TWF4UG9zKHJvdGF0ZVBvc2VzLCAxKSAtIGdldE1pblBvcyhyb3RhdGVQb3NlcywgMSk7XG4gIH0gZWxzZSB7XG4gICAgbWluWCA9IGdldE1pblBvcyhtb3ZlYWJsZVBvc2VzLCAwKTtcbiAgICBtaW5ZID0gZ2V0TWluUG9zKG1vdmVhYmxlUG9zZXMsIDEpO1xuICAgIGdyb3VwV2lkdGggPSBnZXRNYXhQb3MobW92ZWFibGVQb3NlcywgMCkgLSBtaW5YO1xuICAgIGdyb3VwSGVpZ2h0ID0gZ2V0TWF4UG9zKG1vdmVhYmxlUG9zZXMsIDEpIC0gbWluWTtcblxuICAgIGlmIChmaXhlZFJvdGF0aW9uICUgMTgwKSB7XG4gICAgICB2YXIgY2hhbmdlZFdpZHRoID0gZ3JvdXBXaWR0aDtcbiAgICAgIGdyb3VwV2lkdGggPSBncm91cEhlaWdodDtcbiAgICAgIGdyb3VwSGVpZ2h0ID0gY2hhbmdlZFdpZHRoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbbWluWCwgbWluWSwgZ3JvdXBXaWR0aCwgZ3JvdXBIZWlnaHRdO1xufVxuLyoqXG4gKiBAbmFtZXNwYWNlIE1vdmVhYmxlLkdyb3VwXG4gKiBAZGVzY3JpcHRpb24gWW91IGNhbiBtYWtlIHRhcmdldHMgbW92ZWFibGUuXG4gKi9cblxuXG52YXIgTW92ZWFibGVHcm91cCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhNb3ZlYWJsZUdyb3VwLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIE1vdmVhYmxlR3JvdXAoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5kaWZmZXIgPSBuZXcgQ2hpbGRyZW5EaWZmZXIoKTtcbiAgICBfdGhpcy5tb3ZlYWJsZXMgPSBbXTtcbiAgICBfdGhpcy50cmFuc2Zvcm1PcmlnaW4gPSBcIjUwJSA1MCVcIjtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX19wcm90byA9IE1vdmVhYmxlR3JvdXAucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8uY2hlY2tVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy51cGRhdGVBYmxlcygpO1xuICB9O1xuXG4gIF9fcHJvdG8udXBkYXRlUmVjdCA9IGZ1bmN0aW9uICh0eXBlLCBpc1RhcmdldCwgaXNTZXRTdGF0ZSkge1xuICAgIGlmIChpc1NldFN0YXRlID09PSB2b2lkIDApIHtcbiAgICAgIGlzU2V0U3RhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5jb250cm9sQm94KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5tb3ZlYWJsZXMuZm9yRWFjaChmdW5jdGlvbiAobW92ZWFibGUpIHtcbiAgICAgIG1vdmVhYmxlLnVwZGF0ZVJlY3QodHlwZSwgZmFsc2UsIGZhbHNlKTtcbiAgICB9KTtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHRhcmdldCA9IHN0YXRlLnRhcmdldCB8fCBwcm9wcy50YXJnZXQ7XG5cbiAgICBpZiAoIWlzVGFyZ2V0IHx8IHR5cGUgIT09IFwiXCIgJiYgcHJvcHMudXBkYXRlR3JvdXApIHtcbiAgICAgIC8vIHJlc2V0IHJvdGF0YWlvblxuICAgICAgdGhpcy5yb3RhdGlvbiA9IHByb3BzLmRlZmF1bHRHcm91cFJvdGF0ZTtcbiAgICAgIHRoaXMudHJhbnNmb3JtT3JpZ2luID0gcHJvcHMuZGVmYXVsdEdyb3VwT3JpZ2luIHx8IFwiNTAlIDUwJVwiO1xuICAgICAgdGhpcy5zY2FsZSA9IFsxLCAxXTtcbiAgICB9XG5cbiAgICB2YXIgcm90YXRpb24gPSB0aGlzLnJvdGF0aW9uO1xuICAgIHZhciBzY2FsZSA9IHRoaXMuc2NhbGU7XG5cbiAgICB2YXIgX2EgPSBnZXRHcm91cFJlY3QodGhpcy5tb3ZlYWJsZXMsIHJvdGF0aW9uKSxcbiAgICAgICAgbGVmdCA9IF9hWzBdLFxuICAgICAgICB0b3AgPSBfYVsxXSxcbiAgICAgICAgd2lkdGggPSBfYVsyXSxcbiAgICAgICAgaGVpZ2h0ID0gX2FbM107IC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbWF4LWxpbmUtbGVuZ3RoXG5cblxuICAgIHZhciB0cmFuc2Zvcm0gPSBcInJvdGF0ZShcIiArIHJvdGF0aW9uICsgXCJkZWcpIHNjYWxlKFwiICsgKHNjYWxlWzBdID49IDAgPyAxIDogLTEpICsgXCIsIFwiICsgKHNjYWxlWzFdID49IDAgPyAxIDogLTEpICsgXCIpXCI7XG4gICAgdGFyZ2V0LnN0eWxlLmNzc1RleHQgKz0gXCJsZWZ0OjBweDt0b3A6MHB4OyB0cmFuc2Zvcm0tb3JpZ2luOiBcIiArIHRoaXMudHJhbnNmb3JtT3JpZ2luICsgXCI7IHdpZHRoOlwiICsgd2lkdGggKyBcInB4OyBoZWlnaHQ6XCIgKyBoZWlnaHQgKyBcInB4O1wiICsgKFwidHJhbnNmb3JtOlwiICsgdHJhbnNmb3JtKTtcbiAgICBzdGF0ZS53aWR0aCA9IHdpZHRoO1xuICAgIHN0YXRlLmhlaWdodCA9IGhlaWdodDtcbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5nZXRDb250YWluZXIoKTtcbiAgICB2YXIgaW5mbyA9IGdldFRhcmdldEluZm8odGhpcy5jb250cm9sQm94LmdldEVsZW1lbnQoKSwgdGFyZ2V0LCB0aGlzLmNvbnRyb2xCb3guZ2V0RWxlbWVudCgpLCB0aGlzLmdldENvbnRhaW5lcigpLCB0aGlzLnByb3BzLnJvb3RDb250YWluZXIgfHwgY29udGFpbmVyKTtcbiAgICB2YXIgcG9zID0gW2luZm8ubGVmdCwgaW5mby50b3BdO1xuXG4gICAgdmFyIF9iID0gZ2V0QWJzb2x1dGVQb3Nlc0J5U3RhdGUoaW5mbyksXG4gICAgICAgIHBvczEgPSBfYlswXSxcbiAgICAgICAgcG9zMiA9IF9iWzFdLFxuICAgICAgICBwb3MzID0gX2JbMl0sXG4gICAgICAgIHBvczQgPSBfYlszXTsgLy8gaW5mby5sZWZ0ICsgaW5mby5wb3MoMSB+IDQpXG5cblxuICAgIHZhciBtaW5Qb3MgPSBnZXRNaW5NYXhzKFtwb3MxLCBwb3MyLCBwb3MzLCBwb3M0XSk7XG4gICAgdmFyIGRlbHRhID0gW21pblBvcy5taW5YLCBtaW5Qb3MubWluWV07XG4gICAgaW5mby5wb3MxID0gbWludXMocG9zMSwgZGVsdGEpO1xuICAgIGluZm8ucG9zMiA9IG1pbnVzKHBvczIsIGRlbHRhKTtcbiAgICBpbmZvLnBvczMgPSBtaW51cyhwb3MzLCBkZWx0YSk7XG4gICAgaW5mby5wb3M0ID0gbWludXMocG9zNCwgZGVsdGEpO1xuICAgIGluZm8ubGVmdCA9IGxlZnQgLSBpbmZvLmxlZnQgKyBkZWx0YVswXTtcbiAgICBpbmZvLnRvcCA9IHRvcCAtIGluZm8udG9wICsgZGVsdGFbMV07XG4gICAgaW5mby5vcmlnaW4gPSBtaW51cyhwbHVzKHBvcywgaW5mby5vcmlnaW4pLCBkZWx0YSk7XG4gICAgaW5mby5iZWZvcmVPcmlnaW4gPSBtaW51cyhwbHVzKHBvcywgaW5mby5iZWZvcmVPcmlnaW4pLCBkZWx0YSk7XG4gICAgaW5mby5vcmlnaW5hbEJlZm9yZU9yaWdpbiA9IHBsdXMocG9zLCBpbmZvLm9yaWdpbmFsQmVmb3JlT3JpZ2luKTsgLy8gaW5mby50cmFuc2Zvcm1PcmlnaW4gPSBtaW51cyhwbHVzKHBvcywgaW5mby50cmFuc2Zvcm1PcmlnaW4hKSwgZGVsdGEpO1xuXG4gICAgdmFyIGNsaWVudFJlY3QgPSBpbmZvLnRhcmdldENsaWVudFJlY3Q7XG4gICAgdmFyIGRpcmVjdGlvbiA9IHNjYWxlWzBdICogc2NhbGVbMV0gPiAwID8gMSA6IC0xO1xuICAgIGNsaWVudFJlY3QudG9wICs9IGluZm8udG9wIC0gc3RhdGUudG9wO1xuICAgIGNsaWVudFJlY3QubGVmdCArPSBpbmZvLmxlZnQgLSBzdGF0ZS5sZWZ0O1xuICAgIHRhcmdldC5zdHlsZS50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIC1kZWx0YVswXSArIFwicHgsIFwiICsgLWRlbHRhWzFdICsgXCJweCkgXCIgKyB0cmFuc2Zvcm07XG4gICAgdGhpcy51cGRhdGVTdGF0ZShfX2Fzc2lnbihfX2Fzc2lnbih7fSwgaW5mbyksIHtcbiAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLFxuICAgICAgYmVmb3JlRGlyZWN0aW9uOiBkaXJlY3Rpb25cbiAgICB9KSwgaXNTZXRTdGF0ZSk7XG4gIH07XG5cbiAgX19wcm90by5nZXRSZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgX3N1cGVyLnByb3RvdHlwZS5nZXRSZWN0LmNhbGwodGhpcykpLCB7XG4gICAgICBjaGlsZHJlbjogdGhpcy5tb3ZlYWJsZXMubWFwKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gY2hpbGQuZ2V0UmVjdCgpO1xuICAgICAgfSlcbiAgICB9KTtcbiAgfTtcblxuICBfX3Byb3RvLnRyaWdnZXJFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBlLCBpc01hbmFnZXIpIHtcbiAgICBpZiAoaXNNYW5hZ2VyIHx8IG5hbWUuaW5kZXhPZihcIkdyb3VwXCIpID4gLTEpIHtcbiAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnRyaWdnZXJFdmVudC5jYWxsKHRoaXMsIG5hbWUsIGUpO1xuICAgIH1cbiAgfTtcblxuICBfX3Byb3RvLnVwZGF0ZUFibGVzID0gZnVuY3Rpb24gKCkge1xuICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlQWJsZXMuY2FsbCh0aGlzLCBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIHRoaXMucHJvcHMuYWJsZXMpLCBbR3JvdXBhYmxlXSksIFwiR3JvdXBcIik7XG4gIH07XG5cbiAgX19wcm90by5fdXBkYXRlVGFyZ2V0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICBfc3VwZXIucHJvdG90eXBlLl91cGRhdGVUYXJnZXRzLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLl9wcmV2VGFyZ2V0ID0gdGhpcy5wcm9wcy5kcmFnVGFyZ2V0IHx8IHRoaXMuYXJlYUVsZW1lbnQ7XG4gIH07XG5cbiAgX19wcm90by5fdXBkYXRlRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgcHJldlRhcmdldCA9IHRoaXMuX3ByZXZUYXJnZXQ7XG4gICAgdmFyIG5leHRUYXJnZXQgPSBwcm9wcy5kcmFnVGFyZ2V0IHx8IHRoaXMuYXJlYUVsZW1lbnQ7XG5cbiAgICBpZiAocHJldlRhcmdldCAhPT0gbmV4dFRhcmdldCkge1xuICAgICAgdW5zZXQodGhpcywgXCJ0YXJnZXRHZXN0b1wiKTtcbiAgICAgIHVuc2V0KHRoaXMsIFwiY29udHJvbEdlc3RvXCIpO1xuICAgICAgc3RhdGUudGFyZ2V0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoIXN0YXRlLnRhcmdldCkge1xuICAgICAgc3RhdGUudGFyZ2V0ID0gdGhpcy5hcmVhRWxlbWVudDtcbiAgICAgIHRoaXMuY29udHJvbEJveC5nZXRFbGVtZW50KCkuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgIHRoaXMudGFyZ2V0R2VzdG8gPSBnZXRUYXJnZXRBYmxlR2VzdG8odGhpcywgbmV4dFRhcmdldCwgXCJHcm91cFwiKTtcbiAgICAgIHRoaXMuY29udHJvbEdlc3RvID0gZ2V0QWJsZUdlc3RvKHRoaXMsIHRoaXMuY29udHJvbEJveC5nZXRFbGVtZW50KCksIFwiY29udHJvbEFibGVzXCIsIFwiR3JvdXBDb250cm9sXCIpO1xuICAgIH1cblxuICAgIHZhciBpc0NvbnRhaW5lckNoYW5nZWQgPSAhZXF1YWxzKHN0YXRlLmNvbnRhaW5lciwgcHJvcHMuY29udGFpbmVyKTtcblxuICAgIGlmIChpc0NvbnRhaW5lckNoYW5nZWQpIHtcbiAgICAgIHN0YXRlLmNvbnRhaW5lciA9IHByb3BzLmNvbnRhaW5lcjtcbiAgICB9XG5cbiAgICB2YXIgX2EgPSB0aGlzLmRpZmZlci51cGRhdGUocHJvcHMudGFyZ2V0cyksXG4gICAgICAgIGFkZGVkID0gX2EuYWRkZWQsXG4gICAgICAgIGNoYW5nZWQgPSBfYS5jaGFuZ2VkLFxuICAgICAgICByZW1vdmVkID0gX2EucmVtb3ZlZDtcblxuICAgIGlmIChpc0NvbnRhaW5lckNoYW5nZWQgfHwgYWRkZWQubGVuZ3RoIHx8IGNoYW5nZWQubGVuZ3RoIHx8IHJlbW92ZWQubGVuZ3RoKSB7XG4gICAgICB0aGlzLnVwZGF0ZVJlY3QoKTtcbiAgICB9XG4gIH07XG5cbiAgX19wcm90by5fdXBkYXRlT2JzZXJ2ZXIgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBNb3ZlYWJsZUdyb3VwLmRlZmF1bHRQcm9wcyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBNb3ZlYWJsZU1hbmFnZXIuZGVmYXVsdFByb3BzKSwge1xuICAgIHRyYW5zZm9ybU9yaWdpbjogW1wiNTAlXCIsIFwiNTAlXCJdLFxuICAgIGdyb3VwYWJsZTogdHJ1ZSxcbiAgICBkcmFnQXJlYTogdHJ1ZSxcbiAgICBrZWVwUmF0aW86IHRydWUsXG4gICAgdGFyZ2V0czogW10sXG4gICAgZGVmYXVsdEdyb3VwUm90YXRlOiAwLFxuICAgIGRlZmF1bHRHcm91cE9yaWdpbjogXCI1MCUgNTAlXCJcbiAgfSk7XG4gIHJldHVybiBNb3ZlYWJsZUdyb3VwO1xufShNb3ZlYWJsZU1hbmFnZXIpO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgTW92ZWFibGUuSW5kaXZpZHVhbEdyb3VwXG4gKiBAZGVzY3JpcHRpb24gQ3JlYXRlIHRhcmdldHMgaW5kaXZpZHVhbGx5LCBub3QgYXMgYSBncm91cC5DcmVhdGUgdGFyZ2V0cyBpbmRpdmlkdWFsbHksIG5vdCBhcyBhIGdyb3VwLlxuICovXG5cbnZhciBNb3ZlYWJsZUluZGl2aWR1YWxHcm91cCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhNb3ZlYWJsZUluZGl2aWR1YWxHcm91cCwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBNb3ZlYWJsZUluZGl2aWR1YWxHcm91cCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLm1vdmVhYmxlcyA9IFtdO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfX3Byb3RvID0gTW92ZWFibGVJbmRpdmlkdWFsR3JvdXAucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgX2EgPSB0aGlzLnByb3BzLFxuICAgICAgICBjc3BOb25jZSA9IF9hLmNzcE5vbmNlLFxuICAgICAgICBDb250cm9sQm94RWxlbWVudCA9IF9hLmNzc1N0eWxlZCxcbiAgICAgICAgdGFyZ2V0cyA9IF9hLnRhcmdldHM7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoQ29udHJvbEJveEVsZW1lbnQsIHtcbiAgICAgIGNzcE5vbmNlOiBjc3BOb25jZSxcbiAgICAgIHJlZjogcmVmKHRoaXMsIFwiY29udHJvbEJveFwiKSxcbiAgICAgIGNsYXNzTmFtZTogcHJlZml4KFwiY29udHJvbC1ib3hcIilcbiAgICB9LCB0YXJnZXRzLm1hcChmdW5jdGlvbiAodGFyZ2V0LCBpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChNb3ZlYWJsZU1hbmFnZXIsIF9fYXNzaWduKHtcbiAgICAgICAga2V5OiBcIm1vdmVhYmxlXCIgKyBpLFxuICAgICAgICByZWY6IHJlZnMoX3RoaXMsIFwibW92ZWFibGVzXCIsIGkpXG4gICAgICB9LCBfdGhpcy5wcm9wcywge1xuICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgd3JhcHBlck1vdmVhYmxlOiBfdGhpc1xuICAgICAgfSkpO1xuICAgIH0pKTtcbiAgfTtcblxuICBfX3Byb3RvLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIF9fcHJvdG8udXBkYXRlUmVjdCA9IGZ1bmN0aW9uICh0eXBlLCBpc1RhcmdldCwgaXNTZXRTdGF0ZSkge1xuICAgIGlmIChpc1NldFN0YXRlID09PSB2b2lkIDApIHtcbiAgICAgIGlzU2V0U3RhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMubW92ZWFibGVzLmZvckVhY2goZnVuY3Rpb24gKG1vdmVhYmxlKSB7XG4gICAgICBtb3ZlYWJsZS51cGRhdGVSZWN0KHR5cGUsIGlzVGFyZ2V0LCBpc1NldFN0YXRlKTtcbiAgICB9KTtcbiAgfTtcblxuICBfX3Byb3RvLmdldFJlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBfc3VwZXIucHJvdG90eXBlLmdldFJlY3QuY2FsbCh0aGlzKSksIHtcbiAgICAgIGNoaWxkcmVuOiB0aGlzLm1vdmVhYmxlcy5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBjaGlsZC5nZXRSZWN0KCk7XG4gICAgICB9KVxuICAgIH0pO1xuICB9O1xuXG4gIF9fcHJvdG8ucmVxdWVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVxdWVzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICByZXF1ZXN0RW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgX19wcm90by5kcmFnU3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX19wcm90by5oaXRUZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAwO1xuICB9O1xuXG4gIF9fcHJvdG8uaXNJbnNpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIF9fcHJvdG8uaXNEcmFnZ2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgX19wcm90by51cGRhdGVSZW5kZXJQb3NlcyA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIF9fcHJvdG8uY2hlY2tVcGRhdGUgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBfX3Byb3RvLnRyaWdnZXJFdmVudCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIF9fcHJvdG8udXBkYXRlQWJsZXMgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBfX3Byb3RvLl91cGRhdGVFdmVudHMgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBfX3Byb3RvLl91cGRhdGVPYnNlcnZlciA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIHJldHVybiBNb3ZlYWJsZUluZGl2aWR1YWxHcm91cDtcbn0oTW92ZWFibGVNYW5hZ2VyKTtcblxudmFyIEluaXRpYWxNb3ZlYWJsZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhJbml0aWFsTW92ZWFibGUsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gSW5pdGlhbE1vdmVhYmxlKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMucmVmVGFyZ2V0cyA9IFtdO1xuICAgIF90aGlzLnNlbGVjdG9yTWFwID0ge307XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9fcHJvdG8gPSBJbml0aWFsTW92ZWFibGUucHJvdG90eXBlO1xuXG4gIEluaXRpYWxNb3ZlYWJsZS5tYWtlU3R5bGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjc3NNYXAgPSB7fTtcbiAgICB2YXIgYWJsZXMgPSB0aGlzLmdldFRvdGFsQWJsZXMoKTtcbiAgICBhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgdmFyIGNzcyA9IF9hLmNzcztcblxuICAgICAgaWYgKCFjc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjc3MuZm9yRWFjaChmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICBjc3NNYXBbdGV4dF0gPSB0cnVlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdmFyIHN0eWxlID0gZ2V0S2V5cyhjc3NNYXApLmpvaW4oXCJcXG5cIik7XG4gICAgdGhpcy5kZWZhdWx0U3R5bGVkID0gc3R5bGVkKFwiZGl2XCIsIHByZWZpeENTUyhQUkVGSVgsIE1PVkVBQkxFX0NTUyArIHN0eWxlKSk7XG4gIH07XG5cbiAgSW5pdGlhbE1vdmVhYmxlLmdldFRvdGFsQWJsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkoW0RlZmF1bHQsIEdyb3VwYWJsZSwgSW5kaXZpZHVhbEdyb3VwYWJsZSwgRHJhZ0FyZWFdLCB0aGlzLmRlZmF1bHRBYmxlcyk7XG4gIH07XG5cbiAgX19wcm90by5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vdmVhYmxlQ29udHJ1Y3RvciA9IHRoaXMuY29uc3RydWN0b3I7XG5cbiAgICBpZiAoIW1vdmVhYmxlQ29udHJ1Y3Rvci5kZWZhdWx0U3R5bGVkKSB7XG4gICAgICBtb3ZlYWJsZUNvbnRydWN0b3IubWFrZVN0eWxlZCgpO1xuICAgIH1cblxuICAgIHZhciBfYSA9IHRoaXMucHJvcHMsXG4gICAgICAgIHVzZXJBYmxlcyA9IF9hLmFibGVzLFxuICAgICAgICB1c2VyUHJvcHMgPSBfYS5wcm9wcyxcbiAgICAgICAgcHJvcHMgPSBfX3Jlc3QoX2EsIFtcImFibGVzXCIsIFwicHJvcHNcIl0pO1xuXG4gICAgdmFyIHJlZlRhcmdldHMgPSB0aGlzLl91cGRhdGVSZWZzKHRydWUpO1xuXG4gICAgdmFyIGVsZW1lbnRUYXJnZXRzID0gZ2V0RWxlbWVudFRhcmdldHMocmVmVGFyZ2V0cywgdGhpcy5zZWxlY3Rvck1hcCk7XG4gICAgdmFyIGlzR3JvdXAgPSBlbGVtZW50VGFyZ2V0cy5sZW5ndGggPiAxO1xuICAgIHZhciB0b3RhbEFibGVzID0gbW92ZWFibGVDb250cnVjdG9yLmdldFRvdGFsQWJsZXMoKTtcblxuICAgIHZhciBhYmxlcyA9IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgdG90YWxBYmxlcyksIHVzZXJBYmxlcyB8fCBbXSk7XG5cbiAgICB2YXIgbmV4dFByb3BzID0gX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oe30sIHByb3BzKSwgdXNlclByb3BzIHx8IHt9KSwge1xuICAgICAgYWJsZXM6IGFibGVzLFxuICAgICAgY3NzU3R5bGVkOiBtb3ZlYWJsZUNvbnRydWN0b3IuZGVmYXVsdFN0eWxlZCxcbiAgICAgIGN1c3RvbVN0eWxlZE1hcDogbW92ZWFibGVDb250cnVjdG9yLmN1c3RvbVN0eWxlZE1hcFxuICAgIH0pO1xuXG4gICAgaWYgKGlzR3JvdXApIHtcbiAgICAgIGlmIChwcm9wcy5pbmRpdmlkdWFsR3JvdXBhYmxlKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KE1vdmVhYmxlSW5kaXZpZHVhbEdyb3VwLCBfX2Fzc2lnbih7XG4gICAgICAgICAga2V5OiBcImluZGl2aWR1YWwtZ3JvdXBcIixcbiAgICAgICAgICByZWY6IHJlZih0aGlzLCBcIm1vdmVhYmxlXCIpXG4gICAgICAgIH0sIG5leHRQcm9wcywge1xuICAgICAgICAgIHRhcmdldDogbnVsbCxcbiAgICAgICAgICB0YXJnZXRzOiBlbGVtZW50VGFyZ2V0c1xuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KE1vdmVhYmxlR3JvdXAsIF9fYXNzaWduKHtcbiAgICAgICAga2V5OiBcImdyb3VwXCIsXG4gICAgICAgIHJlZjogcmVmKHRoaXMsIFwibW92ZWFibGVcIilcbiAgICAgIH0sIG5leHRQcm9wcywge1xuICAgICAgICB0YXJnZXQ6IG51bGwsXG4gICAgICAgIHRhcmdldHM6IGVsZW1lbnRUYXJnZXRzXG4gICAgICB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KE1vdmVhYmxlTWFuYWdlciwgX19hc3NpZ24oe1xuICAgICAgICBrZXk6IFwic2luZ2xlXCIsXG4gICAgICAgIHJlZjogcmVmKHRoaXMsIFwibW92ZWFibGVcIilcbiAgICAgIH0sIG5leHRQcm9wcywge1xuICAgICAgICB0YXJnZXQ6IGVsZW1lbnRUYXJnZXRzWzBdXG4gICAgICB9KSk7XG4gICAgfVxuICB9O1xuXG4gIF9fcHJvdG8uY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fdXBkYXRlUmVmcygpO1xuICB9O1xuXG4gIF9fcHJvdG8uY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3VwZGF0ZVJlZnMoKTtcbiAgfTtcblxuICBfX3Byb3RvLmdldE1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubW92ZWFibGU7XG4gIH07XG5cbiAgX19wcm90by5fdXBkYXRlUmVmcyA9IGZ1bmN0aW9uIChpc1JlbmRlcikge1xuICAgIHZhciBwcmV2UmVmVGFyZ2V0cyA9IHRoaXMucmVmVGFyZ2V0cztcbiAgICB2YXIgbmV4dFJlZlRhcmdldHMgPSBnZXRSZWZUYXJnZXRzKHRoaXMucHJvcHMudGFyZ2V0IHx8IHRoaXMucHJvcHMudGFyZ2V0cyk7XG4gICAgdmFyIGlzQnJvd3NlciA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICB2YXIgaXNVcGRhdGUgPSBwcmV2UmVmVGFyZ2V0cy5sZW5ndGggIT09IG5leHRSZWZUYXJnZXRzLmxlbmd0aCB8fCBwcmV2UmVmVGFyZ2V0cy5zb21lKGZ1bmN0aW9uICh0YXJnZXQsIGkpIHtcbiAgICAgIHZhciBuZXh0VGFyZ2V0ID0gbmV4dFJlZlRhcmdldHNbaV07XG5cbiAgICAgIGlmICghdGFyZ2V0ICYmICFuZXh0VGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAodGFyZ2V0ICE9PSBuZXh0VGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gICAgdmFyIHNlbGVjdG9yTWFwID0gdGhpcy5zZWxlY3Rvck1hcDtcbiAgICB2YXIgbmV4dFNlbGVjdG9yTWFwID0ge307XG4gICAgdGhpcy5yZWZUYXJnZXRzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgaWYgKGlzU3RyaW5nKHRhcmdldCkpIHtcbiAgICAgICAgaWYgKCFzZWxlY3Rvck1hcFt0YXJnZXRdICYmIGlzQnJvd3Nlcikge1xuICAgICAgICAgIGlzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICBuZXh0U2VsZWN0b3JNYXBbdGFyZ2V0XSA9IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0YXJnZXQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0U2VsZWN0b3JNYXBbdGFyZ2V0XSA9IHNlbGVjdG9yTWFwW3RhcmdldF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnJlZlRhcmdldHMgPSBuZXh0UmVmVGFyZ2V0cztcbiAgICB0aGlzLnNlbGVjdG9yTWFwID0gbmV4dFNlbGVjdG9yTWFwO1xuXG4gICAgaWYgKCFpc1JlbmRlciAmJiBpc1VwZGF0ZSkge1xuICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXh0UmVmVGFyZ2V0cztcbiAgfTtcblxuICBJbml0aWFsTW92ZWFibGUuZGVmYXVsdEFibGVzID0gW107XG4gIEluaXRpYWxNb3ZlYWJsZS5jdXN0b21TdHlsZWRNYXAgPSB7fTtcbiAgSW5pdGlhbE1vdmVhYmxlLmRlZmF1bHRTdHlsZWQgPSBudWxsO1xuXG4gIF9fZGVjb3JhdGUoW3dpdGhNZXRob2RzKE1PVkVBQkxFX01FVEhPRFMpXSwgSW5pdGlhbE1vdmVhYmxlLnByb3RvdHlwZSwgXCJtb3ZlYWJsZVwiLCB2b2lkIDApO1xuXG4gIHJldHVybiBJbml0aWFsTW92ZWFibGU7XG59KFB1cmVDb21wb25lbnQpO1xuXG52YXIgTW92ZWFibGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoTW92ZWFibGUsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gTW92ZWFibGUoKSB7XG4gICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgTW92ZWFibGUuZGVmYXVsdEFibGVzID0gTU9WRUFCTEVfQUJMRVM7XG4gIHJldHVybiBNb3ZlYWJsZTtcbn0oSW5pdGlhbE1vdmVhYmxlKTtcblxuZnVuY3Rpb24gbWFrZU1vdmVhYmxlKGFibGVzKSB7XG4gIHZhciBfYTtcblxuICByZXR1cm4gX2EgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTW92ZWFibGUsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBNb3ZlYWJsZSgpIHtcbiAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gTW92ZWFibGU7XG4gIH0oSW5pdGlhbE1vdmVhYmxlKSwgX2EuZGVmYXVsdEFibGVzID0gYWJsZXMsIF9hO1xufVxuXG5leHBvcnQgZGVmYXVsdCBNb3ZlYWJsZTtcbmV4cG9ydCB7IENsaXBwYWJsZSwgRHJhZ2dhYmxlLCBlZGdlRHJhZ2dhYmxlIGFzIEVkZ2VEcmFnZ2FibGUsIEluaXRpYWxNb3ZlYWJsZSwgTU9WRUFCTEVfQUJMRVMsIE1PVkVBQkxFX0VWRU5UUywgTU9WRUFCTEVfRVZFTlRTX01BUCwgTU9WRUFCTEVfRVZFTlRTX1BST1BTX01BUCwgTU9WRUFCTEVfTUVUSE9EUywgTU9WRUFCTEVfUFJPUFMsIE1PVkVBQkxFX1BST1BTX01BUCwgUGluY2hhYmxlLCBSZXNpemFibGUsIFJvdGF0YWJsZSwgUm91bmRhYmxlLCBTY2FsYWJsZSwgU25hcHBhYmxlLCBXYXJwYWJsZSwgZ2V0RWxlbWVudEluZm8sIG1ha2VBYmxlLCBtYWtlTW92ZWFibGUgfTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgUmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xuXG52YXIgX3JlYWN0RHJhZ2dhYmxlID0gcmVxdWlyZShcInJlYWN0LWRyYWdnYWJsZVwiKTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuXG52YXIgX3Byb3BUeXBlcyA9IHJlcXVpcmUoXCIuL3Byb3BUeXBlc1wiKTtcblxudmFyIF9leGNsdWRlZCA9IFtcImNoaWxkcmVuXCIsIFwiY2xhc3NOYW1lXCIsIFwiZHJhZ2dhYmxlT3B0c1wiLCBcIndpZHRoXCIsIFwiaGVpZ2h0XCIsIFwiaGFuZGxlXCIsIFwiaGFuZGxlU2l6ZVwiLCBcImxvY2tBc3BlY3RSYXRpb1wiLCBcImF4aXNcIiwgXCJtaW5Db25zdHJhaW50c1wiLCBcIm1heENvbnN0cmFpbnRzXCIsIFwib25SZXNpemVcIiwgXCJvblJlc2l6ZVN0b3BcIiwgXCJvblJlc2l6ZVN0YXJ0XCIsIFwicmVzaXplSGFuZGxlc1wiLCBcInRyYW5zZm9ybVNjYWxlXCJdO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGVCYWJlbEludGVyb3AgPSBuZXcgV2Vha01hcCgpOyB2YXIgY2FjaGVOb2RlSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IHJldHVybiBub2RlSW50ZXJvcCA/IGNhY2hlTm9kZUludGVyb3AgOiBjYWNoZUJhYmVsSW50ZXJvcDsgfSkobm9kZUludGVyb3ApOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaiwgbm9kZUludGVyb3ApIHsgaWYgKCFub2RlSW50ZXJvcCAmJiBvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IGRlZmF1bHQ6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKGtleSAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbi8vIFRoZSBiYXNlIDxSZXNpemFibGU+IGNvbXBvbmVudC5cbi8vIFRoaXMgY29tcG9uZW50IGRvZXMgbm90IGhhdmUgc3RhdGUgYW5kIHJlbGllcyBvbiB0aGUgcGFyZW50IHRvIHNldCBpdHMgcHJvcHMgYmFzZWQgb24gY2FsbGJhY2sgZGF0YS5cbnZhciBSZXNpemFibGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoUmVzaXphYmxlLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBSZXNpemFibGUoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpIHx8IHRoaXM7XG4gICAgX3RoaXMuaGFuZGxlUmVmcyA9IHt9O1xuICAgIF90aGlzLmxhc3RIYW5kbGVSZWN0ID0gbnVsbDtcbiAgICBfdGhpcy5zbGFjayA9IG51bGw7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFJlc2l6YWJsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5yZXNldERhdGEoKTtcbiAgfTtcblxuICBfcHJvdG8ucmVzZXREYXRhID0gZnVuY3Rpb24gcmVzZXREYXRhKCkge1xuICAgIHRoaXMubGFzdEhhbmRsZVJlY3QgPSB0aGlzLnNsYWNrID0gbnVsbDtcbiAgfSAvLyBDbGFtcCB3aWR0aCBhbmQgaGVpZ2h0IHdpdGhpbiBwcm92aWRlZCBjb25zdHJhaW50c1xuICA7XG5cbiAgX3Byb3RvLnJ1bkNvbnN0cmFpbnRzID0gZnVuY3Rpb24gcnVuQ29uc3RyYWludHMod2lkdGgsIGhlaWdodCkge1xuICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIG1pbkNvbnN0cmFpbnRzID0gX3RoaXMkcHJvcHMubWluQ29uc3RyYWludHMsXG4gICAgICAgIG1heENvbnN0cmFpbnRzID0gX3RoaXMkcHJvcHMubWF4Q29uc3RyYWludHMsXG4gICAgICAgIGxvY2tBc3BlY3RSYXRpbyA9IF90aGlzJHByb3BzLmxvY2tBc3BlY3RSYXRpbzsgLy8gc2hvcnQgY2lyY3VpdFxuXG4gICAgaWYgKCFtaW5Db25zdHJhaW50cyAmJiAhbWF4Q29uc3RyYWludHMgJiYgIWxvY2tBc3BlY3RSYXRpbykgcmV0dXJuIFt3aWR0aCwgaGVpZ2h0XTsgLy8gSWYgY29uc3RyYWluaW5nIHRvIG1pbiBhbmQgbWF4LCB3ZSBuZWVkIHRvIGFsc28gZml0IHdpZHRoIGFuZCBoZWlnaHQgdG8gYXNwZWN0IHJhdGlvLlxuXG4gICAgaWYgKGxvY2tBc3BlY3RSYXRpbykge1xuICAgICAgdmFyIHJhdGlvID0gdGhpcy5wcm9wcy53aWR0aCAvIHRoaXMucHJvcHMuaGVpZ2h0O1xuICAgICAgdmFyIGRlbHRhVyA9IHdpZHRoIC0gdGhpcy5wcm9wcy53aWR0aDtcbiAgICAgIHZhciBkZWx0YUggPSBoZWlnaHQgLSB0aGlzLnByb3BzLmhlaWdodDsgLy8gRmluZCB3aGljaCBjb29yZGluYXRlIHdhcyBncmVhdGVyIGFuZCBzaG91bGQgcHVzaCB0aGUgb3RoZXIgdG93YXJkIGl0LlxuICAgICAgLy8gRS5nLjpcbiAgICAgIC8vIHJhdGlvID0gMSwgZGVsdGFXID0gMTAsIGRlbHRhSCA9IDUsIGRlbHRhSCBzaG91bGQgYmVjb21lIDEwLlxuICAgICAgLy8gcmF0aW8gPSAyLCBkZWx0YVcgPSAxMCwgZGVsdGFIID0gNiwgZGVsdGFXIHNob3VsZCBiZWNvbWUgMTIuXG5cbiAgICAgIGlmIChNYXRoLmFicyhkZWx0YVcpID4gTWF0aC5hYnMoZGVsdGFIICogcmF0aW8pKSB7XG4gICAgICAgIGhlaWdodCA9IHdpZHRoIC8gcmF0aW87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aWR0aCA9IGhlaWdodCAqIHJhdGlvO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBvbGRXID0gd2lkdGgsXG4gICAgICAgIG9sZEggPSBoZWlnaHQ7IC8vIEFkZCBzbGFjayB0byB0aGUgdmFsdWVzIHVzZWQgdG8gY2FsY3VsYXRlIGJvdW5kIHBvc2l0aW9uLiBUaGlzIHdpbGwgZW5zdXJlIHRoYXQgaWZcbiAgICAvLyB3ZSBzdGFydCByZW1vdmluZyBzbGFjaywgdGhlIGVsZW1lbnQgd29uJ3QgcmVhY3QgdG8gaXQgcmlnaHQgYXdheSB1bnRpbCBpdCdzIGJlZW5cbiAgICAvLyBjb21wbGV0ZWx5IHJlbW92ZWQuXG5cbiAgICB2YXIgX3JlZiA9IHRoaXMuc2xhY2sgfHwgWzAsIDBdLFxuICAgICAgICBzbGFja1cgPSBfcmVmWzBdLFxuICAgICAgICBzbGFja0ggPSBfcmVmWzFdO1xuXG4gICAgd2lkdGggKz0gc2xhY2tXO1xuICAgIGhlaWdodCArPSBzbGFja0g7XG5cbiAgICBpZiAobWluQ29uc3RyYWludHMpIHtcbiAgICAgIHdpZHRoID0gTWF0aC5tYXgobWluQ29uc3RyYWludHNbMF0sIHdpZHRoKTtcbiAgICAgIGhlaWdodCA9IE1hdGgubWF4KG1pbkNvbnN0cmFpbnRzWzFdLCBoZWlnaHQpO1xuICAgIH1cblxuICAgIGlmIChtYXhDb25zdHJhaW50cykge1xuICAgICAgd2lkdGggPSBNYXRoLm1pbihtYXhDb25zdHJhaW50c1swXSwgd2lkdGgpO1xuICAgICAgaGVpZ2h0ID0gTWF0aC5taW4obWF4Q29uc3RyYWludHNbMV0sIGhlaWdodCk7XG4gICAgfSAvLyBJZiB0aGUgd2lkdGggb3IgaGVpZ2h0IGNoYW5nZWQsIHdlIG11c3QgaGF2ZSBpbnRyb2R1Y2VkIHNvbWUgc2xhY2suIFJlY29yZCBpdCBmb3IgdGhlIG5leHQgaXRlcmF0aW9uLlxuXG5cbiAgICB0aGlzLnNsYWNrID0gW3NsYWNrVyArIChvbGRXIC0gd2lkdGgpLCBzbGFja0ggKyAob2xkSCAtIGhlaWdodCldO1xuICAgIHJldHVybiBbd2lkdGgsIGhlaWdodF07XG4gIH1cbiAgLyoqXG4gICAqIFdyYXBwZXIgYXJvdW5kIGRyYWcgZXZlbnRzIHRvIHByb3ZpZGUgbW9yZSB1c2VmdWwgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSBoYW5kbGVyTmFtZSBIYW5kbGVyIG5hbWUgdG8gd3JhcC5cbiAgICogQHJldHVybiB7RnVuY3Rpb259ICAgICAgICAgICBIYW5kbGVyIGZ1bmN0aW9uLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZXNpemVIYW5kbGVyID0gZnVuY3Rpb24gcmVzaXplSGFuZGxlcihoYW5kbGVyTmFtZSwgYXhpcykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlLCBfcmVmMikge1xuICAgICAgdmFyIG5vZGUgPSBfcmVmMi5ub2RlLFxuICAgICAgICAgIGRlbHRhWCA9IF9yZWYyLmRlbHRhWCxcbiAgICAgICAgICBkZWx0YVkgPSBfcmVmMi5kZWx0YVk7XG4gICAgICAvLyBSZXNldCBkYXRhIGluIGNhc2UgaXQgd2FzIGxlZnQgb3ZlciBzb21laG93IChzaG91bGQgbm90IGJlIHBvc3NpYmxlKVxuICAgICAgaWYgKGhhbmRsZXJOYW1lID09PSAnb25SZXNpemVTdGFydCcpIF90aGlzMi5yZXNldERhdGEoKTsgLy8gQXhpcyByZXN0cmljdGlvbnNcblxuICAgICAgdmFyIGNhbkRyYWdYID0gKF90aGlzMi5wcm9wcy5heGlzID09PSAnYm90aCcgfHwgX3RoaXMyLnByb3BzLmF4aXMgPT09ICd4JykgJiYgYXhpcyAhPT0gJ24nICYmIGF4aXMgIT09ICdzJztcbiAgICAgIHZhciBjYW5EcmFnWSA9IChfdGhpczIucHJvcHMuYXhpcyA9PT0gJ2JvdGgnIHx8IF90aGlzMi5wcm9wcy5heGlzID09PSAneScpICYmIGF4aXMgIT09ICdlJyAmJiBheGlzICE9PSAndyc7IC8vIE5vIGRyYWdnaW5nIHBvc3NpYmxlLlxuXG4gICAgICBpZiAoIWNhbkRyYWdYICYmICFjYW5EcmFnWSkgcmV0dXJuOyAvLyBEZWNvbXBvc2UgYXhpcyBmb3IgbGF0ZXIgdXNlXG5cbiAgICAgIHZhciBheGlzViA9IGF4aXNbMF07XG4gICAgICB2YXIgYXhpc0ggPSBheGlzW2F4aXMubGVuZ3RoIC0gMV07IC8vIGludGVudGlvbmFsbHkgbm90IGF4aXNbMV0sIHNvIHRoYXQgdGhpcyBjYXRjaGVzIGF4aXMgPT09ICd3JyBmb3IgZXhhbXBsZVxuICAgICAgLy8gVHJhY2sgdGhlIGVsZW1lbnQgYmVpbmcgZHJhZ2dlZCB0byBhY2NvdW50IGZvciBjaGFuZ2VzIGluIHBvc2l0aW9uLlxuICAgICAgLy8gSWYgYSBoYW5kbGUncyBwb3NpdGlvbiBpcyBjaGFuZ2VkIGJldHdlZW4gY2FsbGJhY2tzLCB3ZSBuZWVkIHRvIGZhY3RvciB0aGlzIGluIHRvIHRoZSBuZXh0IGNhbGxiYWNrLlxuICAgICAgLy8gRmFpbHVyZSB0byBkbyBzbyB3aWxsIGNhdXNlIHRoZSBlbGVtZW50IHRvIFwic2tpcFwiIHdoZW4gcmVzaXplZCB1cHdhcmRzIG9yIGxlZnR3YXJkcy5cblxuICAgICAgdmFyIGhhbmRsZVJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICBpZiAoX3RoaXMyLmxhc3RIYW5kbGVSZWN0ICE9IG51bGwpIHtcbiAgICAgICAgLy8gSWYgdGhlIGhhbmRsZSBoYXMgcmVwb3NpdGlvbmVkIG9uIGVpdGhlciBheGlzIHNpbmNlIGxhc3QgcmVuZGVyLFxuICAgICAgICAvLyB3ZSBuZWVkIHRvIGluY3JlYXNlIG91ciBjYWxsYmFjayB2YWx1ZXMgYnkgdGhpcyBtdWNoLlxuICAgICAgICAvLyBPbmx5IGNoZWNraW5nICduJywgJ3cnIHNpbmNlIHJlc2l6aW5nIGJ5ICdzJywgJ3cnIHdvbid0IGFmZmVjdCB0aGUgb3ZlcmFsbCBwb3NpdGlvbiBvbiBwYWdlLFxuICAgICAgICBpZiAoYXhpc0ggPT09ICd3Jykge1xuICAgICAgICAgIHZhciBkZWx0YUxlZnRTaW5jZUxhc3QgPSBoYW5kbGVSZWN0LmxlZnQgLSBfdGhpczIubGFzdEhhbmRsZVJlY3QubGVmdDtcbiAgICAgICAgICBkZWx0YVggKz0gZGVsdGFMZWZ0U2luY2VMYXN0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGF4aXNWID09PSAnbicpIHtcbiAgICAgICAgICB2YXIgZGVsdGFUb3BTaW5jZUxhc3QgPSBoYW5kbGVSZWN0LnRvcCAtIF90aGlzMi5sYXN0SGFuZGxlUmVjdC50b3A7XG4gICAgICAgICAgZGVsdGFZICs9IGRlbHRhVG9wU2luY2VMYXN0O1xuICAgICAgICB9XG4gICAgICB9IC8vIFN0b3JhZ2Ugb2YgbGFzdCByZWN0IHNvIHdlIGtub3cgaG93IG11Y2ggaXQgaGFzIHJlYWxseSBtb3ZlZC5cblxuXG4gICAgICBfdGhpczIubGFzdEhhbmRsZVJlY3QgPSBoYW5kbGVSZWN0OyAvLyBSZXZlcnNlIGRlbHRhIGlmIHVzaW5nIHRvcCBvciBsZWZ0IGRyYWcgaGFuZGxlcy5cblxuICAgICAgaWYgKGF4aXNIID09PSAndycpIGRlbHRhWCA9IC1kZWx0YVg7XG4gICAgICBpZiAoYXhpc1YgPT09ICduJykgZGVsdGFZID0gLWRlbHRhWTsgLy8gVXBkYXRlIHcvaCBieSB0aGUgZGVsdGFzLiBBbHNvIGZhY3RvciBpbiB0cmFuc2Zvcm1TY2FsZS5cblxuICAgICAgdmFyIHdpZHRoID0gX3RoaXMyLnByb3BzLndpZHRoICsgKGNhbkRyYWdYID8gZGVsdGFYIC8gX3RoaXMyLnByb3BzLnRyYW5zZm9ybVNjYWxlIDogMCk7XG4gICAgICB2YXIgaGVpZ2h0ID0gX3RoaXMyLnByb3BzLmhlaWdodCArIChjYW5EcmFnWSA/IGRlbHRhWSAvIF90aGlzMi5wcm9wcy50cmFuc2Zvcm1TY2FsZSA6IDApOyAvLyBSdW4gdXNlci1wcm92aWRlZCBjb25zdHJhaW50cy5cblxuICAgICAgdmFyIF90aGlzMiRydW5Db25zdHJhaW50cyA9IF90aGlzMi5ydW5Db25zdHJhaW50cyh3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgd2lkdGggPSBfdGhpczIkcnVuQ29uc3RyYWludHNbMF07XG4gICAgICBoZWlnaHQgPSBfdGhpczIkcnVuQ29uc3RyYWludHNbMV07XG4gICAgICB2YXIgZGltZW5zaW9uc0NoYW5nZWQgPSB3aWR0aCAhPT0gX3RoaXMyLnByb3BzLndpZHRoIHx8IGhlaWdodCAhPT0gX3RoaXMyLnByb3BzLmhlaWdodDsgLy8gQ2FsbCB1c2VyLXN1cHBsaWVkIGNhbGxiYWNrIGlmIHByZXNlbnQuXG5cbiAgICAgIHZhciBjYiA9IHR5cGVvZiBfdGhpczIucHJvcHNbaGFuZGxlck5hbWVdID09PSAnZnVuY3Rpb24nID8gX3RoaXMyLnByb3BzW2hhbmRsZXJOYW1lXSA6IG51bGw7IC8vIERvbid0IGNhbGwgJ29uUmVzaXplJyBpZiBkaW1lbnNpb25zIGhhdmVuJ3QgY2hhbmdlZC5cblxuICAgICAgdmFyIHNob3VsZFNraXBDYiA9IGhhbmRsZXJOYW1lID09PSAnb25SZXNpemUnICYmICFkaW1lbnNpb25zQ2hhbmdlZDtcblxuICAgICAgaWYgKGNiICYmICFzaG91bGRTa2lwQ2IpIHtcbiAgICAgICAgZS5wZXJzaXN0ID09IG51bGwgPyB2b2lkIDAgOiBlLnBlcnNpc3QoKTtcbiAgICAgICAgY2IoZSwge1xuICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgc2l6ZToge1xuICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGhhbmRsZTogYXhpc1xuICAgICAgICB9KTtcbiAgICAgIH0gLy8gUmVzZXQgaW50ZXJuYWwgZGF0YVxuXG5cbiAgICAgIGlmIChoYW5kbGVyTmFtZSA9PT0gJ29uUmVzaXplU3RvcCcpIF90aGlzMi5yZXNldERhdGEoKTtcbiAgICB9O1xuICB9IC8vIFJlbmRlciBhIHJlc2l6ZSBoYW5kbGUgZ2l2ZW4gYW4gYXhpcyAmIERPTSByZWYuIFJlZiAqbXVzdCogYmUgYXR0YWNoZWQgZm9yXG4gIC8vIHRoZSB1bmRlcmx5aW5nIGRyYWdnYWJsZSBsaWJyYXJ5IHRvIHdvcmsgcHJvcGVybHkuXG4gIDtcblxuICBfcHJvdG8ucmVuZGVyUmVzaXplSGFuZGxlID0gZnVuY3Rpb24gcmVuZGVyUmVzaXplSGFuZGxlKGhhbmRsZUF4aXMsIHJlZikge1xuICAgIHZhciBoYW5kbGUgPSB0aGlzLnByb3BzLmhhbmRsZTsgLy8gTm8gaGFuZGxlIHByb3ZpZGVkLCBtYWtlIHRoZSBkZWZhdWx0XG5cbiAgICBpZiAoIWhhbmRsZSkge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJyZWFjdC1yZXNpemFibGUtaGFuZGxlIHJlYWN0LXJlc2l6YWJsZS1oYW5kbGUtXCIgKyBoYW5kbGVBeGlzLFxuICAgICAgICByZWY6IHJlZlxuICAgICAgfSk7XG4gICAgfSAvLyBIYW5kbGUgaXMgYSBmdW5jdGlvbiwgc3VjaCBhczpcbiAgICAvLyBgaGFuZGxlPXsoaGFuZGxlQXhpcykgPT4gPHNwYW4gY2xhc3NOYW1lPXsuLi59IC8+fWBcblxuXG4gICAgaWYgKHR5cGVvZiBoYW5kbGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBoYW5kbGUoaGFuZGxlQXhpcywgcmVmKTtcbiAgICB9IC8vIEhhbmRsZSBpcyBhIFJlYWN0IGNvbXBvbmVudCAoY29tcG9zaXRlIG9yIERPTSkuXG5cblxuICAgIHZhciBpc0RPTUVsZW1lbnQgPSB0eXBlb2YgaGFuZGxlLnR5cGUgPT09ICdzdHJpbmcnO1xuXG4gICAgdmFyIHByb3BzID0gX29iamVjdFNwcmVhZCh7XG4gICAgICByZWY6IHJlZlxuICAgIH0sIGlzRE9NRWxlbWVudCA/IHt9IDoge1xuICAgICAgaGFuZGxlQXhpczogaGFuZGxlQXhpc1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQoaGFuZGxlLCBwcm9wcyk7XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIC8vIFBhc3MgYWxvbmcgb25seSBwcm9wcyBub3QgbWVhbnQgZm9yIHRoZSBgPFJlc2l6YWJsZT5gLmBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB2YXIgX3RoaXMkcHJvcHMyID0gdGhpcy5wcm9wcyxcbiAgICAgICAgY2hpbGRyZW4gPSBfdGhpcyRwcm9wczIuY2hpbGRyZW4sXG4gICAgICAgIGNsYXNzTmFtZSA9IF90aGlzJHByb3BzMi5jbGFzc05hbWUsXG4gICAgICAgIGRyYWdnYWJsZU9wdHMgPSBfdGhpcyRwcm9wczIuZHJhZ2dhYmxlT3B0cyxcbiAgICAgICAgd2lkdGggPSBfdGhpcyRwcm9wczIud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF90aGlzJHByb3BzMi5oZWlnaHQsXG4gICAgICAgIGhhbmRsZSA9IF90aGlzJHByb3BzMi5oYW5kbGUsXG4gICAgICAgIGhhbmRsZVNpemUgPSBfdGhpcyRwcm9wczIuaGFuZGxlU2l6ZSxcbiAgICAgICAgbG9ja0FzcGVjdFJhdGlvID0gX3RoaXMkcHJvcHMyLmxvY2tBc3BlY3RSYXRpbyxcbiAgICAgICAgYXhpcyA9IF90aGlzJHByb3BzMi5heGlzLFxuICAgICAgICBtaW5Db25zdHJhaW50cyA9IF90aGlzJHByb3BzMi5taW5Db25zdHJhaW50cyxcbiAgICAgICAgbWF4Q29uc3RyYWludHMgPSBfdGhpcyRwcm9wczIubWF4Q29uc3RyYWludHMsXG4gICAgICAgIG9uUmVzaXplID0gX3RoaXMkcHJvcHMyLm9uUmVzaXplLFxuICAgICAgICBvblJlc2l6ZVN0b3AgPSBfdGhpcyRwcm9wczIub25SZXNpemVTdG9wLFxuICAgICAgICBvblJlc2l6ZVN0YXJ0ID0gX3RoaXMkcHJvcHMyLm9uUmVzaXplU3RhcnQsXG4gICAgICAgIHJlc2l6ZUhhbmRsZXMgPSBfdGhpcyRwcm9wczIucmVzaXplSGFuZGxlcyxcbiAgICAgICAgdHJhbnNmb3JtU2NhbGUgPSBfdGhpcyRwcm9wczIudHJhbnNmb3JtU2NhbGUsXG4gICAgICAgIHAgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfdGhpcyRwcm9wczIsIF9leGNsdWRlZCk7IC8vIFdoYXQgd2UncmUgZG9pbmcgaGVyZSBpcyBnZXR0aW5nIHRoZSBjaGlsZCBvZiB0aGlzIGVsZW1lbnQsIGFuZCBjbG9uaW5nIGl0IHdpdGggdGhpcyBlbGVtZW50J3MgcHJvcHMuXG4gICAgLy8gV2UgYXJlIHRoZW4gZGVmaW5pbmcgaXRzIGNoaWxkcmVuIGFzOlxuICAgIC8vIDEuIEl0cyBvcmlnaW5hbCBjaGlsZHJlbiAocmVzaXphYmxlJ3MgY2hpbGQncyBjaGlsZHJlbiksIGFuZFxuICAgIC8vIDIuIE9uZSBvciBtb3JlIGRyYWdnYWJsZSBoYW5kbGVzLlxuXG5cbiAgICByZXR1cm4gKDAsIF91dGlscy5jbG9uZUVsZW1lbnQpKGNoaWxkcmVuLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHApLCB7fSwge1xuICAgICAgY2xhc3NOYW1lOiAoY2xhc3NOYW1lID8gY2xhc3NOYW1lICsgXCIgXCIgOiAnJykgKyBcInJlYWN0LXJlc2l6YWJsZVwiLFxuICAgICAgY2hpbGRyZW46IFtdLmNvbmNhdChjaGlsZHJlbi5wcm9wcy5jaGlsZHJlbiwgcmVzaXplSGFuZGxlcy5tYXAoZnVuY3Rpb24gKGhhbmRsZUF4aXMpIHtcbiAgICAgICAgdmFyIF90aGlzMyRoYW5kbGVSZWZzJGhhbjtcblxuICAgICAgICAvLyBDcmVhdGUgYSByZWYgdG8gdGhlIGhhbmRsZSBzbyB0aGF0IGA8RHJhZ2dhYmxlQ29yZT5gIGRvZXNuJ3QgaGF2ZSB0byB1c2UgUmVhY3RET00uZmluZERPTU5vZGUoKS5cbiAgICAgICAgdmFyIHJlZiA9IChfdGhpczMkaGFuZGxlUmVmcyRoYW4gPSBfdGhpczMuaGFuZGxlUmVmc1toYW5kbGVBeGlzXSkgIT0gbnVsbCA/IF90aGlzMyRoYW5kbGVSZWZzJGhhbiA6IF90aGlzMy5oYW5kbGVSZWZzW2hhbmRsZUF4aXNdID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZVJlZigpO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0RHJhZ2dhYmxlLkRyYWdnYWJsZUNvcmUsIF9leHRlbmRzKHt9LCBkcmFnZ2FibGVPcHRzLCB7XG4gICAgICAgICAgbm9kZVJlZjogcmVmLFxuICAgICAgICAgIGtleTogXCJyZXNpemFibGVIYW5kbGUtXCIgKyBoYW5kbGVBeGlzLFxuICAgICAgICAgIG9uU3RvcDogX3RoaXMzLnJlc2l6ZUhhbmRsZXIoJ29uUmVzaXplU3RvcCcsIGhhbmRsZUF4aXMpLFxuICAgICAgICAgIG9uU3RhcnQ6IF90aGlzMy5yZXNpemVIYW5kbGVyKCdvblJlc2l6ZVN0YXJ0JywgaGFuZGxlQXhpcyksXG4gICAgICAgICAgb25EcmFnOiBfdGhpczMucmVzaXplSGFuZGxlcignb25SZXNpemUnLCBoYW5kbGVBeGlzKVxuICAgICAgICB9KSwgX3RoaXMzLnJlbmRlclJlc2l6ZUhhbmRsZShoYW5kbGVBeGlzLCByZWYpKTtcbiAgICAgIH0pKVxuICAgIH0pKTtcbiAgfTtcblxuICByZXR1cm4gUmVzaXphYmxlO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBSZXNpemFibGU7XG5SZXNpemFibGUucHJvcFR5cGVzID0gX3Byb3BUeXBlcy5yZXNpemFibGVQcm9wcztcblJlc2l6YWJsZS5kZWZhdWx0UHJvcHMgPSB7XG4gIGF4aXM6ICdib3RoJyxcbiAgaGFuZGxlU2l6ZTogWzIwLCAyMF0sXG4gIGxvY2tBc3BlY3RSYXRpbzogZmFsc2UsXG4gIG1pbkNvbnN0cmFpbnRzOiBbMjAsIDIwXSxcbiAgbWF4Q29uc3RyYWludHM6IFtJbmZpbml0eSwgSW5maW5pdHldLFxuICByZXNpemVIYW5kbGVzOiBbJ3NlJ10sXG4gIHRyYW5zZm9ybVNjYWxlOiAxXG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgUmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xuXG52YXIgX3Byb3BUeXBlcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInByb3AtdHlwZXNcIikpO1xuXG52YXIgX1Jlc2l6YWJsZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vUmVzaXphYmxlXCIpKTtcblxudmFyIF9wcm9wVHlwZXMyID0gcmVxdWlyZShcIi4vcHJvcFR5cGVzXCIpO1xuXG52YXIgX2V4Y2x1ZGVkID0gW1wiaGFuZGxlXCIsIFwiaGFuZGxlU2l6ZVwiLCBcIm9uUmVzaXplXCIsIFwib25SZXNpemVTdGFydFwiLCBcIm9uUmVzaXplU3RvcFwiLCBcImRyYWdnYWJsZU9wdHNcIiwgXCJtaW5Db25zdHJhaW50c1wiLCBcIm1heENvbnN0cmFpbnRzXCIsIFwibG9ja0FzcGVjdFJhdGlvXCIsIFwiYXhpc1wiLCBcIndpZHRoXCIsIFwiaGVpZ2h0XCIsIFwicmVzaXplSGFuZGxlc1wiLCBcInN0eWxlXCIsIFwidHJhbnNmb3JtU2NhbGVcIl07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZUJhYmVsSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHZhciBjYWNoZU5vZGVJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgcmV0dXJuIG5vZGVJbnRlcm9wID8gY2FjaGVOb2RlSW50ZXJvcCA6IGNhY2hlQmFiZWxJbnRlcm9wOyB9KShub2RlSW50ZXJvcCk7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqLCBub2RlSW50ZXJvcCkgeyBpZiAoIW5vZGVJbnRlcm9wICYmIG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgZGVmYXVsdDogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoa2V5ICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxudmFyIFJlc2l6YWJsZUJveCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShSZXNpemFibGVCb3gsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFJlc2l6YWJsZUJveCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkgfHwgdGhpcztcbiAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHdpZHRoOiBfdGhpcy5wcm9wcy53aWR0aCxcbiAgICAgIGhlaWdodDogX3RoaXMucHJvcHMuaGVpZ2h0LFxuICAgICAgcHJvcHNXaWR0aDogX3RoaXMucHJvcHMud2lkdGgsXG4gICAgICBwcm9wc0hlaWdodDogX3RoaXMucHJvcHMuaGVpZ2h0XG4gICAgfTtcblxuICAgIF90aGlzLm9uUmVzaXplID0gZnVuY3Rpb24gKGUsIGRhdGEpIHtcbiAgICAgIHZhciBzaXplID0gZGF0YS5zaXplO1xuXG4gICAgICBpZiAoX3RoaXMucHJvcHMub25SZXNpemUpIHtcbiAgICAgICAgZS5wZXJzaXN0ID09IG51bGwgPyB2b2lkIDAgOiBlLnBlcnNpc3QoKTtcblxuICAgICAgICBfdGhpcy5zZXRTdGF0ZShzaXplLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLnByb3BzLm9uUmVzaXplICYmIF90aGlzLnByb3BzLm9uUmVzaXplKGUsIGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLnNldFN0YXRlKHNpemUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBSZXNpemFibGVCb3guZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gZnVuY3Rpb24gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKHByb3BzLCBzdGF0ZSkge1xuICAgIC8vIElmIHBhcmVudCBjaGFuZ2VzIGhlaWdodC93aWR0aCwgc2V0IHRoYXQgaW4gb3VyIHN0YXRlLlxuICAgIGlmIChzdGF0ZS5wcm9wc1dpZHRoICE9PSBwcm9wcy53aWR0aCB8fCBzdGF0ZS5wcm9wc0hlaWdodCAhPT0gcHJvcHMuaGVpZ2h0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogcHJvcHMud2lkdGgsXG4gICAgICAgIGhlaWdodDogcHJvcHMuaGVpZ2h0LFxuICAgICAgICBwcm9wc1dpZHRoOiBwcm9wcy53aWR0aCxcbiAgICAgICAgcHJvcHNIZWlnaHQ6IHByb3BzLmhlaWdodFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICB2YXIgX3Byb3RvID0gUmVzaXphYmxlQm94LnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIC8vIEJhc2ljIHdyYXBwZXIgYXJvdW5kIGEgUmVzaXphYmxlIGluc3RhbmNlLlxuICAgIC8vIElmIHlvdSB1c2UgUmVzaXphYmxlIGRpcmVjdGx5LCB5b3UgYXJlIHJlc3BvbnNpYmxlIGZvciB1cGRhdGluZyB0aGUgY2hpbGQgY29tcG9uZW50XG4gICAgLy8gd2l0aCBhIG5ldyB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGhhbmRsZSA9IF90aGlzJHByb3BzLmhhbmRsZSxcbiAgICAgICAgaGFuZGxlU2l6ZSA9IF90aGlzJHByb3BzLmhhbmRsZVNpemUsXG4gICAgICAgIG9uUmVzaXplID0gX3RoaXMkcHJvcHMub25SZXNpemUsXG4gICAgICAgIG9uUmVzaXplU3RhcnQgPSBfdGhpcyRwcm9wcy5vblJlc2l6ZVN0YXJ0LFxuICAgICAgICBvblJlc2l6ZVN0b3AgPSBfdGhpcyRwcm9wcy5vblJlc2l6ZVN0b3AsXG4gICAgICAgIGRyYWdnYWJsZU9wdHMgPSBfdGhpcyRwcm9wcy5kcmFnZ2FibGVPcHRzLFxuICAgICAgICBtaW5Db25zdHJhaW50cyA9IF90aGlzJHByb3BzLm1pbkNvbnN0cmFpbnRzLFxuICAgICAgICBtYXhDb25zdHJhaW50cyA9IF90aGlzJHByb3BzLm1heENvbnN0cmFpbnRzLFxuICAgICAgICBsb2NrQXNwZWN0UmF0aW8gPSBfdGhpcyRwcm9wcy5sb2NrQXNwZWN0UmF0aW8sXG4gICAgICAgIGF4aXMgPSBfdGhpcyRwcm9wcy5heGlzLFxuICAgICAgICB3aWR0aCA9IF90aGlzJHByb3BzLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfdGhpcyRwcm9wcy5oZWlnaHQsXG4gICAgICAgIHJlc2l6ZUhhbmRsZXMgPSBfdGhpcyRwcm9wcy5yZXNpemVIYW5kbGVzLFxuICAgICAgICBzdHlsZSA9IF90aGlzJHByb3BzLnN0eWxlLFxuICAgICAgICB0cmFuc2Zvcm1TY2FsZSA9IF90aGlzJHByb3BzLnRyYW5zZm9ybVNjYWxlLFxuICAgICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF90aGlzJHByb3BzLCBfZXhjbHVkZWQpO1xuXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KF9SZXNpemFibGUuZGVmYXVsdCwge1xuICAgICAgYXhpczogYXhpcyxcbiAgICAgIGRyYWdnYWJsZU9wdHM6IGRyYWdnYWJsZU9wdHMsXG4gICAgICBoYW5kbGU6IGhhbmRsZSxcbiAgICAgIGhhbmRsZVNpemU6IGhhbmRsZVNpemUsXG4gICAgICBoZWlnaHQ6IHRoaXMuc3RhdGUuaGVpZ2h0LFxuICAgICAgbG9ja0FzcGVjdFJhdGlvOiBsb2NrQXNwZWN0UmF0aW8sXG4gICAgICBtYXhDb25zdHJhaW50czogbWF4Q29uc3RyYWludHMsXG4gICAgICBtaW5Db25zdHJhaW50czogbWluQ29uc3RyYWludHMsXG4gICAgICBvblJlc2l6ZVN0YXJ0OiBvblJlc2l6ZVN0YXJ0LFxuICAgICAgb25SZXNpemU6IHRoaXMub25SZXNpemUsXG4gICAgICBvblJlc2l6ZVN0b3A6IG9uUmVzaXplU3RvcCxcbiAgICAgIHJlc2l6ZUhhbmRsZXM6IHJlc2l6ZUhhbmRsZXMsXG4gICAgICB0cmFuc2Zvcm1TY2FsZTogdHJhbnNmb3JtU2NhbGUsXG4gICAgICB3aWR0aDogdGhpcy5zdGF0ZS53aWR0aFxuICAgIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgc3R5bGU6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc3R5bGUpLCB7fSwge1xuICAgICAgICB3aWR0aDogdGhpcy5zdGF0ZS53aWR0aCArICdweCcsXG4gICAgICAgIGhlaWdodDogdGhpcy5zdGF0ZS5oZWlnaHQgKyAncHgnXG4gICAgICB9KVxuICAgIH0pKSk7XG4gIH07XG5cbiAgcmV0dXJuIFJlc2l6YWJsZUJveDtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUmVzaXphYmxlQm94O1xuUmVzaXphYmxlQm94LnByb3BUeXBlcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgX3Byb3BUeXBlczIucmVzaXphYmxlUHJvcHMpLCB7fSwge1xuICBjaGlsZHJlbjogX3Byb3BUeXBlcy5kZWZhdWx0LmVsZW1lbnRcbn0pOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5yZXNpemFibGVQcm9wcyA9IHZvaWQgMDtcblxudmFyIF9wcm9wVHlwZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpKTtcblxudmFyIF9yZWFjdERyYWdnYWJsZSA9IHJlcXVpcmUoXCJyZWFjdC1kcmFnZ2FibGVcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciByZXNpemFibGVQcm9wcyA9IHtcbiAgLypcbiAgKiBSZXN0cmljdHMgcmVzaXppbmcgdG8gYSBwYXJ0aWN1bGFyIGF4aXMgKGRlZmF1bHQ6ICdib3RoJylcbiAgKiAnYm90aCcgLSBhbGxvd3MgcmVzaXppbmcgYnkgd2lkdGggb3IgaGVpZ2h0XG4gICogJ3gnIC0gb25seSBhbGxvd3MgdGhlIHdpZHRoIHRvIGJlIGNoYW5nZWRcbiAgKiAneScgLSBvbmx5IGFsbG93cyB0aGUgaGVpZ2h0IHRvIGJlIGNoYW5nZWRcbiAgKiAnbm9uZScgLSBkaXNhYmxlcyByZXNpemluZyBhbHRvZ2V0aGVyXG4gICogKi9cbiAgYXhpczogX3Byb3BUeXBlcy5kZWZhdWx0Lm9uZU9mKFsnYm90aCcsICd4JywgJ3knLCAnbm9uZSddKSxcbiAgY2xhc3NOYW1lOiBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nLFxuXG4gIC8qXG4gICogUmVxdWlyZSB0aGF0IG9uZSBhbmQgb25seSBvbmUgY2hpbGQgYmUgcHJlc2VudC5cbiAgKiAqL1xuICBjaGlsZHJlbjogX3Byb3BUeXBlcy5kZWZhdWx0LmVsZW1lbnQuaXNSZXF1aXJlZCxcblxuICAvKlxuICAqIFRoZXNlIHdpbGwgYmUgcGFzc2VkIHdob2xlc2FsZSB0byByZWFjdC1kcmFnZ2FibGUncyBEcmFnZ2FibGVDb3JlXG4gICogKi9cbiAgZHJhZ2dhYmxlT3B0czogX3Byb3BUeXBlcy5kZWZhdWx0LnNoYXBlKHtcbiAgICBhbGxvd0FueUNsaWNrOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbCxcbiAgICBjYW5jZWw6IF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcsXG4gICAgY2hpbGRyZW46IF9wcm9wVHlwZXMuZGVmYXVsdC5ub2RlLFxuICAgIGRpc2FibGVkOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbCxcbiAgICBlbmFibGVVc2VyU2VsZWN0SGFjazogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wsXG4gICAgb2Zmc2V0UGFyZW50OiBfcHJvcFR5cGVzLmRlZmF1bHQubm9kZSxcbiAgICBncmlkOiBfcHJvcFR5cGVzLmRlZmF1bHQuYXJyYXlPZihfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyKSxcbiAgICBoYW5kbGU6IF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcsXG4gICAgbm9kZVJlZjogX3Byb3BUeXBlcy5kZWZhdWx0Lm9iamVjdCxcbiAgICBvblN0YXJ0OiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYyxcbiAgICBvbkRyYWc6IF9wcm9wVHlwZXMuZGVmYXVsdC5mdW5jLFxuICAgIG9uU3RvcDogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmMsXG4gICAgb25Nb3VzZURvd246IF9wcm9wVHlwZXMuZGVmYXVsdC5mdW5jLFxuICAgIHNjYWxlOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyXG4gIH0pLFxuXG4gIC8qXG4gICogSW5pdGlhbCBoZWlnaHRcbiAgKiAqL1xuICBoZWlnaHQ6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIuaXNSZXF1aXJlZCxcblxuICAvKlxuICAqIEN1c3RvbWl6ZSBjdXJzb3IgcmVzaXplIGhhbmRsZVxuICAqICovXG4gIGhhbmRsZTogX3Byb3BUeXBlcy5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlcy5kZWZhdWx0Lm5vZGUsIF9wcm9wVHlwZXMuZGVmYXVsdC5mdW5jXSksXG5cbiAgLypcbiAgKiBJZiB5b3UgY2hhbmdlIHRoaXMsIGJlIHN1cmUgdG8gdXBkYXRlIHlvdXIgY3NzXG4gICogKi9cbiAgaGFuZGxlU2l6ZTogX3Byb3BUeXBlcy5kZWZhdWx0LmFycmF5T2YoX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlciksXG4gIGxvY2tBc3BlY3RSYXRpbzogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wsXG5cbiAgLypcbiAgKiBNYXggWCAmIFkgbWVhc3VyZVxuICAqICovXG4gIG1heENvbnN0cmFpbnRzOiBfcHJvcFR5cGVzLmRlZmF1bHQuYXJyYXlPZihfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyKSxcblxuICAvKlxuICAqIE1pbiBYICYgWSBtZWFzdXJlXG4gICogKi9cbiAgbWluQ29uc3RyYWludHM6IF9wcm9wVHlwZXMuZGVmYXVsdC5hcnJheU9mKF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIpLFxuXG4gIC8qXG4gICogQ2FsbGVkIG9uIHN0b3AgcmVzaXplIGV2ZW50XG4gICogKi9cbiAgb25SZXNpemVTdG9wOiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYyxcblxuICAvKlxuICAqIENhbGxlZCBvbiBzdGFydCByZXNpemUgZXZlbnRcbiAgKiAqL1xuICBvblJlc2l6ZVN0YXJ0OiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYyxcblxuICAvKlxuICAqIENhbGxlZCBvbiByZXNpemUgZXZlbnRcbiAgKiAqL1xuICBvblJlc2l6ZTogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmMsXG5cbiAgLypcbiAgKiBEZWZpbmVzIHdoaWNoIHJlc2l6ZSBoYW5kbGVzIHNob3VsZCBiZSByZW5kZXJlZCAoZGVmYXVsdDogJ3NlJylcbiAgKiAncycgLSBTb3V0aCBoYW5kbGUgKGJvdHRvbS1jZW50ZXIpXG4gICogJ3cnIC0gV2VzdCBoYW5kbGUgKGxlZnQtY2VudGVyKVxuICAqICdlJyAtIEVhc3QgaGFuZGxlIChyaWdodC1jZW50ZXIpXG4gICogJ24nIC0gTm9ydGggaGFuZGxlICh0b3AtY2VudGVyKVxuICAqICdzdycgLSBTb3V0aHdlc3QgaGFuZGxlIChib3R0b20tbGVmdClcbiAgKiAnbncnIC0gTm9ydGh3ZXN0IGhhbmRsZSAodG9wLWxlZnQpXG4gICogJ3NlJyAtIFNvdXRoZWFzdCBoYW5kbGUgKGJvdHRvbS1yaWdodClcbiAgKiAnbmUnIC0gTm9ydGhlYXN0IGhhbmRsZSAodG9wLWNlbnRlcilcbiAgKiAqL1xuICByZXNpemVIYW5kbGVzOiBfcHJvcFR5cGVzLmRlZmF1bHQuYXJyYXlPZihfcHJvcFR5cGVzLmRlZmF1bHQub25lT2YoWydzJywgJ3cnLCAnZScsICduJywgJ3N3JywgJ253JywgJ3NlJywgJ25lJ10pKSxcblxuICAvKlxuICAqIElmIGB0cmFuc2Zvcm06IHNjYWxlKG4pYCBpcyBzZXQgb24gdGhlIHBhcmVudCwgdGhpcyBzaG91bGQgYmUgc2V0IHRvIGBuYC5cbiAgKiAqL1xuICB0cmFuc2Zvcm1TY2FsZTogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcixcblxuICAvKlxuICAgKiBJbml0aWFsIHdpZHRoXG4gICAqL1xuICB3aWR0aDogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlci5pc1JlcXVpcmVkXG59O1xuZXhwb3J0cy5yZXNpemFibGVQcm9wcyA9IHJlc2l6YWJsZVByb3BzOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5jbG9uZUVsZW1lbnQgPSBjbG9uZUVsZW1lbnQ7XG5cbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLy8gUmVhY3QuYWRkb25zLmNsb25lV2l0aFByb3BzIGxvb2stYWxpa2UgdGhhdCBtZXJnZXMgc3R5bGUgJiBjbGFzc05hbWUuXG5mdW5jdGlvbiBjbG9uZUVsZW1lbnQoZWxlbWVudCwgcHJvcHMpIHtcbiAgaWYgKHByb3BzLnN0eWxlICYmIGVsZW1lbnQucHJvcHMuc3R5bGUpIHtcbiAgICBwcm9wcy5zdHlsZSA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZWxlbWVudC5wcm9wcy5zdHlsZSksIHByb3BzLnN0eWxlKTtcbiAgfVxuXG4gIGlmIChwcm9wcy5jbGFzc05hbWUgJiYgZWxlbWVudC5wcm9wcy5jbGFzc05hbWUpIHtcbiAgICBwcm9wcy5jbGFzc05hbWUgPSBlbGVtZW50LnByb3BzLmNsYXNzTmFtZSArIFwiIFwiICsgcHJvcHMuY2xhc3NOYW1lO1xuICB9XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jbG9uZUVsZW1lbnQoZWxlbWVudCwgcHJvcHMpO1xufSIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIHRocm93IG5ldyBFcnJvcihcIkRvbid0IGluc3RhbnRpYXRlIFJlc2l6YWJsZSBkaXJlY3RseSEgVXNlIHJlcXVpcmUoJ3JlYWN0LXJlc2l6YWJsZScpLlJlc2l6YWJsZVwiKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLlJlc2l6YWJsZSA9IHJlcXVpcmUoJy4vYnVpbGQvUmVzaXphYmxlJykuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLlJlc2l6YWJsZUJveCA9IHJlcXVpcmUoJy4vYnVpbGQvUmVzaXphYmxlQm94JykuZGVmYXVsdDtcbiIsImltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgZnJvbSAnLi91c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0JztcbmZ1bmN0aW9uIHVzZU9ic2VydmFibGUob2JzZXJ2YWJsZSQsIGluaXRpYWxWYWx1ZSkge1xuICAgIHZhciBfYSA9IHVzZVN0YXRlKGluaXRpYWxWYWx1ZSksIHZhbHVlID0gX2FbMF0sIHVwZGF0ZSA9IF9hWzFdO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcyA9IG9ic2VydmFibGUkLnN1YnNjcmliZSh1cGRhdGUpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gcy51bnN1YnNjcmliZSgpOyB9O1xuICAgIH0sIFtvYnNlcnZhYmxlJF0pO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydCBkZWZhdWx0IHVzZU9ic2VydmFibGU7XG4iLCIvKlxuQ29weXJpZ2h0IChjKSAyMDE4IERheWJydXNoXG5AbmFtZTogQGRheWJydXNoL3V0aWxzXG5saWNlbnNlOiBNSVRcbmF1dGhvcjogRGF5YnJ1c2hcbnJlcG9zaXRvcnk6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXlicnVzaC91dGlsc1xuQHZlcnNpb24gMS42LjBcbiovXG4vKipcbiogQG5hbWVzcGFjZVxuKiBAbmFtZSBDb25zdHNcbiovXG5cbi8qKlxuKiBnZXQgc3RyaW5nIFwicmdiXCJcbiogQG1lbWJlcm9mIENvbG9yXG4qIEBleGFtcGxlXG5pbXBvcnQge1JHQn0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhSR0IpOyAvLyBcInJnYlwiXG4qL1xudmFyIFJHQiA9IFwicmdiXCI7XG4vKipcbiogZ2V0IHN0cmluZyBcInJnYmFcIlxuKiBAbWVtYmVyb2YgQ29sb3JcbiogQGV4YW1wbGVcbmltcG9ydCB7UkdCQX0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhSR0JBKTsgLy8gXCJyZ2JhXCJcbiovXG5cbnZhciBSR0JBID0gXCJyZ2JhXCI7XG4vKipcbiogZ2V0IHN0cmluZyBcImhzbFwiXG4qIEBtZW1iZXJvZiBDb2xvclxuKiBAZXhhbXBsZVxuaW1wb3J0IHtIU0x9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coSFNMKTsgLy8gXCJoc2xcIlxuKi9cblxudmFyIEhTTCA9IFwiaHNsXCI7XG4vKipcbiogZ2V0IHN0cmluZyBcImhzbGFcIlxuKiBAbWVtYmVyb2YgQ29sb3JcbiogQGV4YW1wbGVcbmltcG9ydCB7SFNMQX0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhIU0xBKTsgLy8gXCJoc2xhXCJcbiovXG5cbnZhciBIU0xBID0gXCJoc2xhXCI7XG4vKipcbiogZ2V0cyBhbiBhcnJheSBvZiBjb2xvciBtb2RlbHMuXG4qIEBtZW1iZXJvZiBDb2xvclxuKiBAZXhhbXBsZVxuaW1wb3J0IHtDT0xPUl9NT0RFTFN9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coQ09MT1JfTU9ERUxTKTsgLy8gW1wicmdiXCIsIFwicmdiYVwiLCBcImhzbFwiLCBcImhzbGFcIl07XG4qL1xuXG52YXIgQ09MT1JfTU9ERUxTID0gW1JHQiwgUkdCQSwgSFNMLCBIU0xBXTtcbi8qKlxuKiBnZXQgc3RyaW5nIFwiZnVuY3Rpb25cIlxuKiBAbWVtYmVyb2YgQ29uc3RzXG4qIEBleGFtcGxlXG5pbXBvcnQge0ZVTkNUSU9OfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKEZVTkNUSU9OKTsgLy8gXCJmdW5jdGlvblwiXG4qL1xuXG52YXIgRlVOQ1RJT04gPSBcImZ1bmN0aW9uXCI7XG4vKipcbiogZ2V0IHN0cmluZyBcInByb3BlcnR5XCJcbiogQG1lbWJlcm9mIENvbnN0c1xuKiBAZXhhbXBsZVxuaW1wb3J0IHtQUk9QRVJUWX0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhQUk9QRVJUWSk7IC8vIFwicHJvcGVydHlcIlxuKi9cblxudmFyIFBST1BFUlRZID0gXCJwcm9wZXJ0eVwiO1xuLyoqXG4qIGdldCBzdHJpbmcgXCJhcnJheVwiXG4qIEBtZW1iZXJvZiBDb25zdHNcbiogQGV4YW1wbGVcbmltcG9ydCB7QVJSQVl9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coQVJSQVkpOyAvLyBcImFycmF5XCJcbiovXG5cbnZhciBBUlJBWSA9IFwiYXJyYXlcIjtcbi8qKlxuKiBnZXQgc3RyaW5nIFwib2JqZWN0XCJcbiogQG1lbWJlcm9mIENvbnN0c1xuKiBAZXhhbXBsZVxuaW1wb3J0IHtPQkpFQ1R9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coT0JKRUNUKTsgLy8gXCJvYmplY3RcIlxuKi9cblxudmFyIE9CSkVDVCA9IFwib2JqZWN0XCI7XG4vKipcbiogZ2V0IHN0cmluZyBcInN0cmluZ1wiXG4qIEBtZW1iZXJvZiBDb25zdHNcbiogQGV4YW1wbGVcbmltcG9ydCB7U1RSSU5HfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKFNUUklORyk7IC8vIFwic3RyaW5nXCJcbiovXG5cbnZhciBTVFJJTkcgPSBcInN0cmluZ1wiO1xuLyoqXG4qIGdldCBzdHJpbmcgXCJudW1iZXJcIlxuKiBAbWVtYmVyb2YgQ29uc3RzXG4qIEBleGFtcGxlXG5pbXBvcnQge05VTUJFUn0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhOVU1CRVIpOyAvLyBcIm51bWJlclwiXG4qL1xuXG52YXIgTlVNQkVSID0gXCJudW1iZXJcIjtcbi8qKlxuKiBnZXQgc3RyaW5nIFwidW5kZWZpbmVkXCJcbiogQG1lbWJlcm9mIENvbnN0c1xuKiBAZXhhbXBsZVxuaW1wb3J0IHtVTkRFRklORUR9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coVU5ERUZJTkVEKTsgLy8gXCJ1bmRlZmluZWRcIlxuKi9cblxudmFyIFVOREVGSU5FRCA9IFwidW5kZWZpbmVkXCI7XG4vKipcbiogQ2hlY2sgd2hldGhlciB0aGUgZW52aXJvbm1lbnQgaXMgd2luZG93IG9yIG5vZGUuanMuXG4qIEBtZW1iZXJvZiBDb25zdHNcbiogQGV4YW1wbGVcbmltcG9ydCB7SVNfV0lORE9XfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKElTX1dJTkRPVyk7IC8vIGZhbHNlIGluIG5vZGUuanNcbmNvbnNvbGUubG9nKElTX1dJTkRPVyk7IC8vIHRydWUgaW4gYnJvd3NlclxuKi9cblxudmFyIElTX1dJTkRPVyA9IHR5cGVvZiB3aW5kb3cgIT09IFVOREVGSU5FRDtcbi8qKlxuKiBDaGVjayB3aGV0aGVyIHRoZSBlbnZpcm9ubWVudCBpcyB3aW5kb3cgb3Igbm9kZS5qcy5cbiogQG1lbWJlcm9mIENvbnN0c1xuKiBAbmFtZSBkb2N1bWVudFxuKiBAZXhhbXBsZVxuaW1wb3J0IHtJU19XSU5ET1d9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coSVNfV0lORE9XKTsgLy8gZmFsc2UgaW4gbm9kZS5qc1xuY29uc29sZS5sb2coSVNfV0lORE9XKTsgLy8gdHJ1ZSBpbiBicm93c2VyXG4qL1xuXG52YXIgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSBVTkRFRklORUQgJiYgZG9jdW1lbnQ7IC8vIEZJWE1FOiB0aGlzIHR5cGUgbWF5YmUgZmFsc2VcbnZhciBwcmVmaXhlcyA9IFtcIndlYmtpdFwiLCBcIm1zXCIsIFwibW96XCIsIFwib1wiXTtcbi8qKlxuICogQG5hbWVzcGFjZSBDcm9zc0Jyb3dzZXJcbiAqL1xuXG4vKipcbiogR2V0IGEgQ1NTIHByb3BlcnR5IHdpdGggYSB2ZW5kb3IgcHJlZml4IHRoYXQgc3VwcG9ydHMgY3Jvc3MgYnJvd3Nlci5cbiogQGZ1bmN0aW9uXG4qIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAtIEEgQ1NTIHByb3BlcnR5XG4qIEByZXR1cm4ge3N0cmluZ30gQ1NTIHByb3BlcnR5IHdpdGggY3Jvc3MtYnJvd3NlciB2ZW5kb3IgcHJlZml4XG4qIEBtZW1iZXJvZiBDcm9zc0Jyb3dzZXJcbiogQGV4YW1wbGVcbmltcG9ydCB7Z2V0Q3Jvc3NCcm93c2VyUHJvcGVydHl9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coZ2V0Q3Jvc3NCcm93c2VyUHJvcGVydHkoXCJ0cmFuc2Zvcm1cIikpOyAvLyBcInRyYW5zZm9ybVwiLCBcIi1tcy10cmFuc2Zvcm1cIiwgXCItd2Via2l0LXRyYW5zZm9ybVwiXG5jb25zb2xlLmxvZyhnZXRDcm9zc0Jyb3dzZXJQcm9wZXJ0eShcImZpbHRlclwiKSk7IC8vIFwiZmlsdGVyXCIsIFwiLXdlYmtpdC1maWx0ZXJcIlxuKi9cblxudmFyIGdldENyb3NzQnJvd3NlclByb3BlcnR5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChwcm9wZXJ0eSkge1xuICBpZiAoIWRvYykge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG5cbiAgdmFyIHN0eWxlcyA9IChkb2MuYm9keSB8fCBkb2MuZG9jdW1lbnRFbGVtZW50KS5zdHlsZTtcbiAgdmFyIGxlbmd0aCA9IHByZWZpeGVzLmxlbmd0aDtcblxuICBpZiAodHlwZW9mIHN0eWxlc1twcm9wZXJ0eV0gIT09IFVOREVGSU5FRCkge1xuICAgIHJldHVybiBwcm9wZXJ0eTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgbmFtZSA9IFwiLVwiICsgcHJlZml4ZXNbaV0gKyBcIi1cIiArIHByb3BlcnR5O1xuXG4gICAgaWYgKHR5cGVvZiBzdHlsZXNbbmFtZV0gIT09IFVOREVGSU5FRCkge1xuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFwiXCI7XG59O1xuLyoqXG4qIGdldCBzdHJpbmcgXCJ0cmFuc2Zyb21cIiB3aXRoIHRoZSB2ZW5kb3IgcHJlZml4LlxuKiBAbWVtYmVyb2YgQ3Jvc3NCcm93c2VyXG4qIEBleGFtcGxlXG5pbXBvcnQge1RSQU5TRk9STX0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhUUkFOU0ZPUk0pOyAvLyBcInRyYW5zZm9ybVwiLCBcIi1tcy10cmFuc2Zvcm1cIiwgXCItd2Via2l0LXRyYW5zZm9ybVwiXG4qL1xuXG52YXIgVFJBTlNGT1JNID0gLyojX19QVVJFX18qL2dldENyb3NzQnJvd3NlclByb3BlcnR5KFwidHJhbnNmb3JtXCIpO1xuLyoqXG4qIGdldCBzdHJpbmcgXCJmaWx0ZXJcIiB3aXRoIHRoZSB2ZW5kb3IgcHJlZml4LlxuKiBAbWVtYmVyb2YgQ3Jvc3NCcm93c2VyXG4qIEBleGFtcGxlXG5pbXBvcnQge0ZJTFRFUn0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhGSUxURVIpOyAvLyBcImZpbHRlclwiLCBcIi1tcy1maWx0ZXJcIiwgXCItd2Via2l0LWZpbHRlclwiXG4qL1xuXG52YXIgRklMVEVSID0gLyojX19QVVJFX18qL2dldENyb3NzQnJvd3NlclByb3BlcnR5KFwiZmlsdGVyXCIpO1xuLyoqXG4qIGdldCBzdHJpbmcgXCJhbmltYXRpb25cIiB3aXRoIHRoZSB2ZW5kb3IgcHJlZml4LlxuKiBAbWVtYmVyb2YgQ3Jvc3NCcm93c2VyXG4qIEBleGFtcGxlXG5pbXBvcnQge0FOSU1BVElPTn0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhBTklNQVRJT04pOyAvLyBcImFuaW1hdGlvblwiLCBcIi1tcy1hbmltYXRpb25cIiwgXCItd2Via2l0LWFuaW1hdGlvblwiXG4qL1xuXG52YXIgQU5JTUFUSU9OID0gLyojX19QVVJFX18qL2dldENyb3NzQnJvd3NlclByb3BlcnR5KFwiYW5pbWF0aW9uXCIpO1xuLyoqXG4qIGdldCBzdHJpbmcgXCJrZXlmcmFtZXNcIiB3aXRoIHRoZSB2ZW5kb3IgcHJlZml4LlxuKiBAbWVtYmVyb2YgQ3Jvc3NCcm93c2VyXG4qIEBleGFtcGxlXG5pbXBvcnQge0tFWUZSQU1FU30gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhLRVlGUkFNRVMpOyAvLyBcImtleWZyYW1lc1wiLCBcIi1tcy1rZXlmcmFtZXNcIiwgXCItd2Via2l0LWtleWZyYW1lc1wiXG4qL1xuXG52YXIgS0VZRlJBTUVTID0gLyojX19QVVJFX18qL0FOSU1BVElPTi5yZXBsYWNlKFwiYW5pbWF0aW9uXCIsIFwia2V5ZnJhbWVzXCIpO1xudmFyIE9QRU5fQ0xPU0VEX0NIQVJBQ1RFUlMgPSBbe1xuICBvcGVuOiBcIihcIixcbiAgY2xvc2U6IFwiKVwiXG59LCB7XG4gIG9wZW46IFwiXFxcIlwiLFxuICBjbG9zZTogXCJcXFwiXCJcbn0sIHtcbiAgb3BlbjogXCInXCIsXG4gIGNsb3NlOiBcIidcIlxufSwge1xuICBvcGVuOiBcIlxcXFxcXFwiXCIsXG4gIGNsb3NlOiBcIlxcXFxcXFwiXCJcbn0sIHtcbiAgb3BlbjogXCJcXFxcJ1wiLFxuICBjbG9zZTogXCJcXFxcJ1wiXG59XTtcbnZhciBUSU5ZX05VTSA9IDAuMDAwMDAwMTtcbnZhciBERUZBVUxUX1VOSVRfUFJFU0VUUyA9IHtcbiAgXCJjbVwiOiBmdW5jdGlvbiAocG9zKSB7XG4gICAgcmV0dXJuIHBvcyAqIDk2IC8gMi41NDtcbiAgfSxcbiAgXCJtbVwiOiBmdW5jdGlvbiAocG9zKSB7XG4gICAgcmV0dXJuIHBvcyAqIDk2IC8gMjU0O1xuICB9LFxuICBcImluXCI6IGZ1bmN0aW9uIChwb3MpIHtcbiAgICByZXR1cm4gcG9zICogOTY7XG4gIH0sXG4gIFwicHRcIjogZnVuY3Rpb24gKHBvcykge1xuICAgIHJldHVybiBwb3MgKiA5NiAvIDcyO1xuICB9LFxuICBcInBjXCI6IGZ1bmN0aW9uIChwb3MpIHtcbiAgICByZXR1cm4gcG9zICogOTYgLyA2O1xuICB9LFxuICBcIiVcIjogZnVuY3Rpb24gKHBvcywgc2l6ZSkge1xuICAgIHJldHVybiBwb3MgKiBzaXplIC8gMTAwO1xuICB9LFxuICBcInZ3XCI6IGZ1bmN0aW9uIChwb3MsIHNpemUpIHtcbiAgICBpZiAoc2l6ZSA9PT0gdm9pZCAwKSB7XG4gICAgICBzaXplID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvcyAvIDEwMCAqIHNpemU7XG4gIH0sXG4gIFwidmhcIjogZnVuY3Rpb24gKHBvcywgc2l6ZSkge1xuICAgIGlmIChzaXplID09PSB2b2lkIDApIHtcbiAgICAgIHNpemUgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvcyAvIDEwMCAqIHNpemU7XG4gIH0sXG4gIFwidm1heFwiOiBmdW5jdGlvbiAocG9zLCBzaXplKSB7XG4gICAgaWYgKHNpemUgPT09IHZvaWQgMCkge1xuICAgICAgc2l6ZSA9IE1hdGgubWF4KHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIH1cblxuICAgIHJldHVybiBwb3MgLyAxMDAgKiBzaXplO1xuICB9LFxuICBcInZtaW5cIjogZnVuY3Rpb24gKHBvcywgc2l6ZSkge1xuICAgIGlmIChzaXplID09PSB2b2lkIDApIHtcbiAgICAgIHNpemUgPSBNYXRoLm1pbih3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9zIC8gMTAwICogc2l6ZTtcbiAgfVxufTtcblxuLyoqXG4qIEBuYW1lc3BhY2VcbiogQG5hbWUgVXRpbHNcbiovXG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW5uZXIgcHJvZHVjdCBvZiB0d28gbnVtYmVycyhgYTFgLCBgYTJgKSBieSB0d28gY3JpdGVyaWEoYGIxYCwgYGIyYCkuXG4gKiBAbWVtYmVyb2YgVXRpbHNcbiAqIEBwYXJhbSAtIFRoZSBmaXJzdCBudW1iZXJcbiAqIEBwYXJhbSAtIFRoZSBzZWNvbmQgbnVtYmVyXG4gKiBAcGFyYW0gLSBUaGUgZmlyc3QgbnVtYmVyIHRvIGJhc2Ugb24gdGhlIGlubmVyIHByb2R1Y3RcbiAqIEBwYXJhbSAtIFRoZSBzZWNvbmQgbnVtYmVyIHRvIGJhc2Ugb24gdGhlIGlubmVyIHByb2R1Y3RcbiAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBpbm5lciBwcm9kdWN0XG5pbXBvcnQgeyBkb3QgfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKGRvdCgwLCAxNSwgMiwgMykpOyAvLyA2XG5jb25zb2xlLmxvZyhkb3QoNSwgMTUsIDIsIDMpKTsgLy8gOVxuY29uc29sZS5sb2coZG90KDUsIDE1LCAxLCAxKSk7IC8vIDEwXG4gKi9cblxuZnVuY3Rpb24gZG90KGExLCBhMiwgYjEsIGIyKSB7XG4gIHJldHVybiAoYTEgKiBiMiArIGEyICogYjEpIC8gKGIxICsgYjIpO1xufVxuLyoqXG4qIENoZWNrIHRoZSB0eXBlIHRoYXQgdGhlIHZhbHVlIGlzIHVuZGVmaW5lZC5cbiogQG1lbWJlcm9mIFV0aWxzXG4qIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrIHRoZSB0eXBlXG4qIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIHR5cGUgaXMgY29ycmVjdCwgZmFsc2Ugb3RoZXJ3aXNlXG4qIEBleGFtcGxlXG5pbXBvcnQge2lzVW5kZWZpbmVkfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKGlzVW5kZWZpbmVkKHVuZGVmaW5lZCkpOyAvLyB0cnVlXG5jb25zb2xlLmxvZyhpc1VuZGVmaW5lZChcIlwiKSk7IC8vIGZhbHNlXG5jb25zb2xlLmxvZyhpc1VuZGVmaW5lZCgxKSk7IC8vIGZhbHNlXG5jb25zb2xlLmxvZyhpc1VuZGVmaW5lZChudWxsKSk7IC8vIGZhbHNlXG4qL1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBVTkRFRklORUQ7XG59XG4vKipcbiogQ2hlY2sgdGhlIHR5cGUgdGhhdCB0aGUgdmFsdWUgaXMgb2JqZWN0LlxuKiBAbWVtYmVyb2YgVXRpbHNcbiogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgdGhlIHR5cGVcbiogQHJldHVybiB7fSB0cnVlIGlmIHRoZSB0eXBlIGlzIGNvcnJlY3QsIGZhbHNlIG90aGVyd2lzZVxuKiBAZXhhbXBsZVxuaW1wb3J0IHtpc09iamVjdH0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhpc09iamVjdCh7fSkpOyAvLyB0cnVlXG5jb25zb2xlLmxvZyhpc09iamVjdCh1bmRlZmluZWQpKTsgLy8gZmFsc2VcbmNvbnNvbGUubG9nKGlzT2JqZWN0KFwiXCIpKTsgLy8gZmFsc2VcbmNvbnNvbGUubG9nKGlzT2JqZWN0KG51bGwpKTsgLy8gZmFsc2VcbiovXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IE9CSkVDVDtcbn1cbi8qKlxuKiBDaGVjayB0aGUgdHlwZSB0aGF0IHRoZSB2YWx1ZSBpcyBpc0FycmF5LlxuKiBAbWVtYmVyb2YgVXRpbHNcbiogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgdGhlIHR5cGVcbiogQHJldHVybiB7fSB0cnVlIGlmIHRoZSB0eXBlIGlzIGNvcnJlY3QsIGZhbHNlIG90aGVyd2lzZVxuKiBAZXhhbXBsZVxuaW1wb3J0IHtpc0FycmF5fSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKGlzQXJyYXkoW10pKTsgLy8gdHJ1ZVxuY29uc29sZS5sb2coaXNBcnJheSh7fSkpOyAvLyBmYWxzZVxuY29uc29sZS5sb2coaXNBcnJheSh1bmRlZmluZWQpKTsgLy8gZmFsc2VcbmNvbnNvbGUubG9nKGlzQXJyYXkobnVsbCkpOyAvLyBmYWxzZVxuKi9cblxuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG4vKipcbiogQ2hlY2sgdGhlIHR5cGUgdGhhdCB0aGUgdmFsdWUgaXMgc3RyaW5nLlxuKiBAbWVtYmVyb2YgVXRpbHNcbiogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgdGhlIHR5cGVcbiogQHJldHVybiB7fSB0cnVlIGlmIHRoZSB0eXBlIGlzIGNvcnJlY3QsIGZhbHNlIG90aGVyd2lzZVxuKiBAZXhhbXBsZVxuaW1wb3J0IHtpc1N0cmluZ30gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhpc1N0cmluZyhcIjEyMzRcIikpOyAvLyB0cnVlXG5jb25zb2xlLmxvZyhpc1N0cmluZyh1bmRlZmluZWQpKTsgLy8gZmFsc2VcbmNvbnNvbGUubG9nKGlzU3RyaW5nKDEpKTsgLy8gZmFsc2VcbmNvbnNvbGUubG9nKGlzU3RyaW5nKG51bGwpKTsgLy8gZmFsc2VcbiovXG5cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFNUUklORztcbn1cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IE5VTUJFUjtcbn1cbi8qKlxuKiBDaGVjayB0aGUgdHlwZSB0aGF0IHRoZSB2YWx1ZSBpcyBmdW5jdGlvbi5cbiogQG1lbWJlcm9mIFV0aWxzXG4qIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrIHRoZSB0eXBlXG4qIEByZXR1cm4ge30gdHJ1ZSBpZiB0aGUgdHlwZSBpcyBjb3JyZWN0LCBmYWxzZSBvdGhlcndpc2VcbiogQGV4YW1wbGVcbmltcG9ydCB7aXNGdW5jdGlvbn0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhpc0Z1bmN0aW9uKGZ1bmN0aW9uIGEoKSB7fSkpOyAvLyB0cnVlXG5jb25zb2xlLmxvZyhpc0Z1bmN0aW9uKCgpID0+IHt9KSk7IC8vIHRydWVcbmNvbnNvbGUubG9nKGlzRnVuY3Rpb24oXCIxMjM0XCIpKTsgLy8gZmFsc2VcbmNvbnNvbGUubG9nKGlzRnVuY3Rpb24oMSkpOyAvLyBmYWxzZVxuY29uc29sZS5sb2coaXNGdW5jdGlvbihudWxsKSk7IC8vIGZhbHNlXG4qL1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IEZVTkNUSU9OO1xufVxuXG5mdW5jdGlvbiBpc0VxdWFsU2VwYXJhdG9yKGNoYXJhY3Rlciwgc2VwYXJhdG9yKSB7XG4gIHZhciBpc0NoYXJhY3RlclNwYWNlID0gY2hhcmFjdGVyID09PSBcIlwiIHx8IGNoYXJhY3RlciA9PSBcIiBcIjtcbiAgdmFyIGlzU2VwYXJhdG9yU3BhY2UgPSBzZXBhcmF0b3IgPT09IFwiXCIgfHwgc2VwYXJhdG9yID09IFwiIFwiO1xuICByZXR1cm4gaXNTZXBhcmF0b3JTcGFjZSAmJiBpc0NoYXJhY3RlclNwYWNlIHx8IGNoYXJhY3RlciA9PT0gc2VwYXJhdG9yO1xufVxuXG5mdW5jdGlvbiBmaW5kT3BlbihvcGVuQ2hhcmFjdGVyLCB0ZXh0cywgaW5kZXgsIGxlbmd0aCwgb3BlbkNsb3NlQ2hhcmFjdGVycykge1xuICB2YXIgaXNJZ25vcmUgPSBmaW5kSWdub3JlKG9wZW5DaGFyYWN0ZXIsIHRleHRzLCBpbmRleCk7XG5cbiAgaWYgKCFpc0lnbm9yZSkge1xuICAgIHJldHVybiBmaW5kQ2xvc2Uob3BlbkNoYXJhY3RlciwgdGV4dHMsIGluZGV4ICsgMSwgbGVuZ3RoLCBvcGVuQ2xvc2VDaGFyYWN0ZXJzKTtcbiAgfVxuXG4gIHJldHVybiBpbmRleDtcbn1cblxuZnVuY3Rpb24gZmluZElnbm9yZShjaGFyYWN0ZXIsIHRleHRzLCBpbmRleCkge1xuICBpZiAoIWNoYXJhY3Rlci5pZ25vcmUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBvdGhlclRleHQgPSB0ZXh0cy5zbGljZShNYXRoLm1heChpbmRleCAtIDMsIDApLCBpbmRleCArIDMpLmpvaW4oXCJcIik7XG4gIHJldHVybiBuZXcgUmVnRXhwKGNoYXJhY3Rlci5pZ25vcmUpLmV4ZWMob3RoZXJUZXh0KTtcbn1cblxuZnVuY3Rpb24gZmluZENsb3NlKGNsb3NlQ2hhcmFjdGVyLCB0ZXh0cywgaW5kZXgsIGxlbmd0aCwgb3BlbkNsb3NlQ2hhcmFjdGVycykge1xuICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgdmFyIGNoYXJhY3RlciA9IHRleHRzW2ldLnRyaW0oKTtcblxuICAgIGlmIChjaGFyYWN0ZXIgPT09IGNsb3NlQ2hhcmFjdGVyLmNsb3NlICYmICFmaW5kSWdub3JlKGNsb3NlQ2hhcmFjdGVyLCB0ZXh0cywgaSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBpXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBuZXh0SW5kZXggPSBpOyAvLyByZSBvcGVuXG5cbiAgICB2YXIgb3BlbkNoYXJhY3RlciA9IGZpbmQob3BlbkNsb3NlQ2hhcmFjdGVycywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICB2YXIgb3BlbiA9IF9hLm9wZW47XG4gICAgICByZXR1cm4gb3BlbiA9PT0gY2hhcmFjdGVyO1xuICAgIH0pO1xuXG4gICAgaWYgKG9wZW5DaGFyYWN0ZXIpIHtcbiAgICAgIG5leHRJbmRleCA9IGZpbmRPcGVuKG9wZW5DaGFyYWN0ZXIsIHRleHRzLCBpLCBsZW5ndGgsIG9wZW5DbG9zZUNoYXJhY3RlcnMpO1xuICAgIH1cblxuICAgIGlmIChuZXh0SW5kZXggPT09IC0xKSB7XG4gICAgICByZXR1cm4gb3V0X2lfMSA9IGksIFwiYnJlYWtcIjtcbiAgICB9XG5cbiAgICBpID0gbmV4dEluZGV4O1xuICAgIG91dF9pXzEgPSBpO1xuICB9O1xuXG4gIHZhciBvdXRfaV8xO1xuXG4gIGZvciAodmFyIGkgPSBpbmRleDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHN0YXRlXzEgPSBfbG9vcF8xKGkpO1xuXG4gICAgaSA9IG91dF9pXzE7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZV8xID09PSBcIm9iamVjdFwiKSByZXR1cm4gc3RhdGVfMS52YWx1ZTtcbiAgICBpZiAoc3RhdGVfMSA9PT0gXCJicmVha1wiKSBicmVhaztcbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gc3BsaXRUZXh0KHRleHQsIHNwbGl0T3B0aW9ucykge1xuICB2YXIgX2EgPSBpc1N0cmluZyhzcGxpdE9wdGlvbnMpID8ge1xuICAgIHNlcGFyYXRvcjogc3BsaXRPcHRpb25zXG4gIH0gOiBzcGxpdE9wdGlvbnMsXG4gICAgICBfYiA9IF9hLnNlcGFyYXRvcixcbiAgICAgIHNlcGFyYXRvciA9IF9iID09PSB2b2lkIDAgPyBcIixcIiA6IF9iLFxuICAgICAgaXNTZXBhcmF0ZUZpcnN0ID0gX2EuaXNTZXBhcmF0ZUZpcnN0LFxuICAgICAgaXNTZXBhcmF0ZU9ubHlPcGVuQ2xvc2UgPSBfYS5pc1NlcGFyYXRlT25seU9wZW5DbG9zZSxcbiAgICAgIF9jID0gX2EuaXNTZXBhcmF0ZU9wZW5DbG9zZSxcbiAgICAgIGlzU2VwYXJhdGVPcGVuQ2xvc2UgPSBfYyA9PT0gdm9pZCAwID8gaXNTZXBhcmF0ZU9ubHlPcGVuQ2xvc2UgOiBfYyxcbiAgICAgIF9kID0gX2Eub3BlbkNsb3NlQ2hhcmFjdGVycyxcbiAgICAgIG9wZW5DbG9zZUNoYXJhY3RlcnMgPSBfZCA9PT0gdm9pZCAwID8gT1BFTl9DTE9TRURfQ0hBUkFDVEVSUyA6IF9kO1xuXG4gIHZhciBvcGVuQ2xvc2VkVGV4dCA9IG9wZW5DbG9zZUNoYXJhY3RlcnMubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBvcGVuID0gX2Eub3BlbixcbiAgICAgICAgY2xvc2UgPSBfYS5jbG9zZTtcblxuICAgIGlmIChvcGVuID09PSBjbG9zZSkge1xuICAgICAgcmV0dXJuIG9wZW47XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wZW4gKyBcInxcIiArIGNsb3NlO1xuICB9KS5qb2luKFwifFwiKTtcbiAgdmFyIHJlZ2V4VGV4dCA9IFwiKFxcXFxzKlwiICsgc2VwYXJhdG9yICsgXCJcXFxccyp8XCIgKyBvcGVuQ2xvc2VkVGV4dCArIFwifFxcXFxzKylcIjtcbiAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cChyZWdleFRleHQsIFwiZ1wiKTtcbiAgdmFyIHRleHRzID0gdGV4dC5zcGxpdChyZWdleCkuZmlsdGVyKEJvb2xlYW4pO1xuICB2YXIgbGVuZ3RoID0gdGV4dHMubGVuZ3RoO1xuICB2YXIgdmFsdWVzID0gW107XG4gIHZhciB0ZW1wVmFsdWVzID0gW107XG5cbiAgZnVuY3Rpb24gcmVzZXRUZW1wKCkge1xuICAgIGlmICh0ZW1wVmFsdWVzLmxlbmd0aCkge1xuICAgICAgdmFsdWVzLnB1c2godGVtcFZhbHVlcy5qb2luKFwiXCIpKTtcbiAgICAgIHRlbXBWYWx1ZXMgPSBbXTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBfbG9vcF8yID0gZnVuY3Rpb24gKGkpIHtcbiAgICB2YXIgY2hhcmFjdGVyID0gdGV4dHNbaV0udHJpbSgpO1xuICAgIHZhciBuZXh0SW5kZXggPSBpO1xuICAgIHZhciBvcGVuQ2hhcmFjdGVyID0gZmluZChvcGVuQ2xvc2VDaGFyYWN0ZXJzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgIHZhciBvcGVuID0gX2Eub3BlbjtcbiAgICAgIHJldHVybiBvcGVuID09PSBjaGFyYWN0ZXI7XG4gICAgfSk7XG4gICAgdmFyIGNsb3NlQ2hhcmFjdGVyID0gZmluZChvcGVuQ2xvc2VDaGFyYWN0ZXJzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgIHZhciBjbG9zZSA9IF9hLmNsb3NlO1xuICAgICAgcmV0dXJuIGNsb3NlID09PSBjaGFyYWN0ZXI7XG4gICAgfSk7XG5cbiAgICBpZiAob3BlbkNoYXJhY3Rlcikge1xuICAgICAgbmV4dEluZGV4ID0gZmluZE9wZW4ob3BlbkNoYXJhY3RlciwgdGV4dHMsIGksIGxlbmd0aCwgb3BlbkNsb3NlQ2hhcmFjdGVycyk7XG5cbiAgICAgIGlmIChuZXh0SW5kZXggIT09IC0xICYmIGlzU2VwYXJhdGVPcGVuQ2xvc2UpIHtcbiAgICAgICAgaWYgKHJlc2V0VGVtcCgpICYmIGlzU2VwYXJhdGVGaXJzdCkge1xuICAgICAgICAgIHJldHVybiBvdXRfaV8yID0gaSwgXCJicmVha1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWVzLnB1c2godGV4dHMuc2xpY2UoaSwgbmV4dEluZGV4ICsgMSkuam9pbihcIlwiKSk7XG4gICAgICAgIGkgPSBuZXh0SW5kZXg7XG5cbiAgICAgICAgaWYgKGlzU2VwYXJhdGVGaXJzdCkge1xuICAgICAgICAgIHJldHVybiBvdXRfaV8yID0gaSwgXCJicmVha1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dF9pXzIgPSBpLCBcImNvbnRpbnVlXCI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjbG9zZUNoYXJhY3RlciAmJiAhZmluZElnbm9yZShjbG9zZUNoYXJhY3RlciwgdGV4dHMsIGkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZvcm1hdDogXCIgKyBjbG9zZUNoYXJhY3Rlci5jbG9zZSk7XG4gICAgfSBlbHNlIGlmIChpc0VxdWFsU2VwYXJhdG9yKGNoYXJhY3Rlciwgc2VwYXJhdG9yKSAmJiAhaXNTZXBhcmF0ZU9ubHlPcGVuQ2xvc2UpIHtcbiAgICAgIHJlc2V0VGVtcCgpO1xuXG4gICAgICBpZiAoaXNTZXBhcmF0ZUZpcnN0KSB7XG4gICAgICAgIHJldHVybiBvdXRfaV8yID0gaSwgXCJicmVha1wiO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0X2lfMiA9IGksIFwiY29udGludWVcIjtcbiAgICB9XG5cbiAgICBpZiAobmV4dEluZGV4ID09PSAtMSkge1xuICAgICAgbmV4dEluZGV4ID0gbGVuZ3RoIC0gMTtcbiAgICB9XG5cbiAgICB0ZW1wVmFsdWVzLnB1c2godGV4dHMuc2xpY2UoaSwgbmV4dEluZGV4ICsgMSkuam9pbihcIlwiKSk7XG4gICAgaSA9IG5leHRJbmRleDtcbiAgICBvdXRfaV8yID0gaTtcbiAgfTtcblxuICB2YXIgb3V0X2lfMjtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHN0YXRlXzIgPSBfbG9vcF8yKGkpO1xuXG4gICAgaSA9IG91dF9pXzI7XG4gICAgaWYgKHN0YXRlXzIgPT09IFwiYnJlYWtcIikgYnJlYWs7XG4gIH1cblxuICBpZiAodGVtcFZhbHVlcy5sZW5ndGgpIHtcbiAgICB2YWx1ZXMucHVzaCh0ZW1wVmFsdWVzLmpvaW4oXCJcIikpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlcztcbn1cbi8qKlxuKiBkaXZpZGUgdGV4dCBieSBzcGFjZS5cbiogQG1lbWJlcm9mIFV0aWxzXG4qIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGV4dCB0byBkaXZpZGVcbiogQHJldHVybiB7QXJyYXl9IGRpdmlkZWQgdGV4dHNcbiogQGV4YW1wbGVcbmltcG9ydCB7c3BsaWNlU3BhY2V9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coc3BsaXRTcGFjZShcImEgYiBjIGQgZSBmIGdcIikpO1xuLy8gW1wiYVwiLCBcImJcIiwgXCJjXCIsIFwiZFwiLCBcImVcIiwgXCJmXCIsIFwiZ1wiXVxuY29uc29sZS5sb2coc3BsaXRTcGFjZShcIidhLGInIGMgJ2QsZScgZiBnXCIpKTtcbi8vIFtcIidhLGInXCIsIFwiY1wiLCBcIidkLGUnXCIsIFwiZlwiLCBcImdcIl1cbiovXG5cbmZ1bmN0aW9uIHNwbGl0U3BhY2UodGV4dCkge1xuICAvLyBkaXZpZGUgY29tbWEoc3BhY2UpXG4gIHJldHVybiBzcGxpdFRleHQodGV4dCwgXCJcIik7XG59XG4vKipcbiogZGl2aWRlIHRleHQgYnkgY29tbWEuXG4qIEBtZW1iZXJvZiBVdGlsc1xuKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRleHQgdG8gZGl2aWRlXG4qIEByZXR1cm4ge0FycmF5fSBkaXZpZGVkIHRleHRzXG4qIEBleGFtcGxlXG5pbXBvcnQge3NwbGl0Q29tbWF9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coc3BsaXRDb21tYShcImEsYixjLGQsZSxmLGdcIikpO1xuLy8gW1wiYVwiLCBcImJcIiwgXCJjXCIsIFwiZFwiLCBcImVcIiwgXCJmXCIsIFwiZ1wiXVxuY29uc29sZS5sb2coc3BsaXRDb21tYShcIidhLGInLGMsJ2QsZScsZixnXCIpKTtcbi8vIFtcIidhLGInXCIsIFwiY1wiLCBcIidkLGUnXCIsIFwiZlwiLCBcImdcIl1cbiovXG5cbmZ1bmN0aW9uIHNwbGl0Q29tbWEodGV4dCkge1xuICAvLyBkaXZpZGUgY29tbWEoLClcbiAgLy8gXCJbXlwiXSpcInwnW14nXSonXG4gIHJldHVybiBzcGxpdFRleHQodGV4dCwgXCIsXCIpO1xufVxuLyoqXG4qIGRpdmlkZSB0ZXh0IGJ5IGJyYWNrZXQgXCIoXCIsIFwiKVwiLlxuKiBAbWVtYmVyb2YgVXRpbHNcbiogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0ZXh0IHRvIGRpdmlkZVxuKiBAcmV0dXJuIHtvYmplY3R9IGRpdmlkZWQgdGV4dHNcbiogQGV4YW1wbGVcbmltcG9ydCB7c3BsaXRCcmFja2V0fSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKHNwbGl0QnJhY2tldChcImEoMSwgMilcIikpO1xuLy8ge3ByZWZpeDogXCJhXCIsIHZhbHVlOiBcIjEsIDJcIiwgc3VmZml4OiBcIlwifVxuY29uc29sZS5sb2coc3BsaXRCcmFja2V0KFwiYSgxLCAyKWJcIikpO1xuLy8ge3ByZWZpeDogXCJhXCIsIHZhbHVlOiBcIjEsIDJcIiwgc3VmZml4OiBcImJcIn1cbiovXG5cbmZ1bmN0aW9uIHNwbGl0QnJhY2tldCh0ZXh0KSB7XG4gIHZhciBtYXRjaGVzID0gLyhbXihdKilcXCgoW1xcc1xcU10qKVxcKShbXFxzXFxTXSopL2cuZXhlYyh0ZXh0KTtcblxuICBpZiAoIW1hdGNoZXMgfHwgbWF0Y2hlcy5sZW5ndGggPCA0KSB7XG4gICAgcmV0dXJuIHt9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICBwcmVmaXg6IG1hdGNoZXNbMV0sXG4gICAgICB2YWx1ZTogbWF0Y2hlc1syXSxcbiAgICAgIHN1ZmZpeDogbWF0Y2hlc1szXVxuICAgIH07XG4gIH1cbn1cbi8qKlxuKiBkaXZpZGUgdGV4dCBieSBudW1iZXIgYW5kIHVuaXQuXG4qIEBtZW1iZXJvZiBVdGlsc1xuKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRleHQgdG8gZGl2aWRlXG4qIEByZXR1cm4ge30gZGl2aWRlZCB0ZXh0c1xuKiBAZXhhbXBsZVxuaW1wb3J0IHtzcGxpdFVuaXR9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coc3BsaXRVbml0KFwiMTBweFwiKSk7XG4vLyB7cHJlZml4OiBcIlwiLCB2YWx1ZTogMTAsIHVuaXQ6IFwicHhcIn1cbmNvbnNvbGUubG9nKHNwbGl0VW5pdChcIi0xMHB4XCIpKTtcbi8vIHtwcmVmaXg6IFwiXCIsIHZhbHVlOiAtMTAsIHVuaXQ6IFwicHhcIn1cbmNvbnNvbGUubG9nKHNwbGl0VW5pdChcImExMCVcIikpO1xuLy8ge3ByZWZpeDogXCJhXCIsIHZhbHVlOiAxMCwgdW5pdDogXCIlXCJ9XG4qL1xuXG5mdW5jdGlvbiBzcGxpdFVuaXQodGV4dCkge1xuICB2YXIgbWF0Y2hlcyA9IC9eKFteXFxkfGV8XFwtfFxcK10qKSgoPzpcXGR8XFwufC18ZS18ZVxcKykrKShcXFMqKSQvZy5leGVjKHRleHQpO1xuXG4gIGlmICghbWF0Y2hlcykge1xuICAgIHJldHVybiB7XG4gICAgICBwcmVmaXg6IFwiXCIsXG4gICAgICB1bml0OiBcIlwiLFxuICAgICAgdmFsdWU6IE5hTlxuICAgIH07XG4gIH1cblxuICB2YXIgcHJlZml4ID0gbWF0Y2hlc1sxXTtcbiAgdmFyIHZhbHVlID0gbWF0Y2hlc1syXTtcbiAgdmFyIHVuaXQgPSBtYXRjaGVzWzNdO1xuICByZXR1cm4ge1xuICAgIHByZWZpeDogcHJlZml4LFxuICAgIHVuaXQ6IHVuaXQsXG4gICAgdmFsdWU6IHBhcnNlRmxvYXQodmFsdWUpXG4gIH07XG59XG4vKipcbiogdHJhbnNmb3JtIHN0cmluZ3MgdG8gY2FtZWwtY2FzZVxuKiBAbWVtYmVyb2YgVXRpbHNcbiogQHBhcmFtIHtTdHJpbmd9IHRleHQgLSBzdHJpbmdcbiogQHJldHVybiB7U3RyaW5nfSBjYW1lbC1jYXNlIHN0cmluZ1xuKiBAZXhhbXBsZVxuaW1wb3J0IHtjYW1lbGl6ZX0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhjYW1lbGl6ZShcInRyYW5zZm9ybS1vcmlnaW5cIikpOyAvLyB0cmFuc2Zvcm1PcmlnaW5cbmNvbnNvbGUubG9nKGNhbWVsaXplKFwiYWJjZF9lZmdcIikpOyAvLyBhYmNkRWZnXG5jb25zb2xlLmxvZyhjYW1lbGl6ZShcImFiY2QgZWZnXCIpKTsgLy8gYWJjZEVmZ1xuKi9cblxuZnVuY3Rpb24gY2FtZWxpemUoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvW1xccy1fXShbYS16XSkvZywgZnVuY3Rpb24gKGFsbCwgbGV0dGVyKSB7XG4gICAgcmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xuICB9KTtcbn1cbi8qKlxuKiB0cmFuc2Zvcm0gYSBjYW1lbGl6ZWQgc3RyaW5nIGludG8gYSBsb3dlcmNhc2VkIHN0cmluZy5cbiogQG1lbWJlcm9mIFV0aWxzXG4qIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gYSBjYW1lbC1jYXNlZCBzdHJpbmdcbiogQHBhcmFtIHtzdHJpbmd9IFtzZXBhcmF0b3I9XCItXCJdIC0gYSBzZXBhcmF0b3JcbiogQHJldHVybiB7c3RyaW5nfSAgYSBsb3dlcmNhc2VkIHN0cmluZ1xuKiBAZXhhbXBsZVxuaW1wb3J0IHtkZWNhbWVsaXplfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKGRlY2FtZWxpemUoXCJ0cmFuc2Zvcm1PcmlnaW5cIikpOyAvLyB0cmFuc2Zvcm0tb3JpZ2luXG5jb25zb2xlLmxvZyhkZWNhbWVsaXplKFwiYWJjZEVmZ1wiLCBcIl9cIikpOyAvLyBhYmNkX2VmZ1xuKi9cblxuZnVuY3Rpb24gZGVjYW1lbGl6ZShzdHIsIHNlcGFyYXRvcikge1xuICBpZiAoc2VwYXJhdG9yID09PSB2b2lkIDApIHtcbiAgICBzZXBhcmF0b3IgPSBcIi1cIjtcbiAgfVxuXG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZywgZnVuY3Rpb24gKGFsbCwgbGV0dGVyLCBsZXR0ZXIyKSB7XG4gICAgcmV0dXJuIFwiXCIgKyBsZXR0ZXIgKyBzZXBhcmF0b3IgKyBsZXR0ZXIyLnRvTG93ZXJDYXNlKCk7XG4gIH0pO1xufVxuLyoqXG4qIHRyYW5zZm9ybXMgc29tZXRoaW5nIGluIGFuIGFycmF5IGludG8gYW4gYXJyYXkuXG4qIEBtZW1iZXJvZiBVdGlsc1xuKiBAcGFyYW0gLSBBcnJheSBmb3JtXG4qIEByZXR1cm4gYW4gYXJyYXlcbiogQGV4YW1wbGVcbmltcG9ydCB7dG9BcnJheX0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zdCBhcnIxID0gdG9BcnJheShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmFcIikpOyAvLyBFbGVtZW50W11cbmNvbnN0IGFycjIgPSB0b0FycmF5KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGw8SFRNTEVsZW1lbnQ+KFwiLmFcIikpOyAvLyBIVE1MRWxlbWVudFtdXG4qL1xuXG5mdW5jdGlvbiB0b0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiBbXS5zbGljZS5jYWxsKHZhbHVlKTtcbn1cbi8qKlxuKiBEYXRlLm5vdygpIG1ldGhvZFxuKiBAbWVtYmVyb2YgQ3Jvc3NCcm93c2VyXG4qIEByZXR1cm4ge251bWJlcn0gbWlsbGlzZWNvbmRzXG4qIEBleGFtcGxlXG5pbXBvcnQge25vd30gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhub3coKSk7IC8vIDEyMTIxMzI0MjQxKG1pbGxpc2Vjb25kcylcbiovXG5cbmZ1bmN0aW9uIG5vdygpIHtcbiAgcmV0dXJuIERhdGUubm93ID8gRGF0ZS5ub3coKSA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xufVxuLyoqXG4qIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBhcnJheSB0aGF0IHNhdGlzZmllcyB0aGUgcHJvdmlkZWQgdGVzdGluZyBmdW5jdGlvbi5cbiogQGZ1bmN0aW9uXG4qIEBtZW1iZXJvZiBDcm9zc0Jyb3dzZXJcbiogQHBhcmFtIC0gVGhlIGFycmF5IGBmaW5kSW5kZXhgIHdhcyBjYWxsZWQgdXBvbi5cbiogQHBhcmFtIC0gQSBmdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggdmFsdWUgaW4gdGhlIGFycmF5IHVudGlsIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUsIGluZGljYXRpbmcgdGhhdCB0aGUgc2F0aXNmeWluZyBlbGVtZW50IHdhcyBmb3VuZC5cbiogQHBhcmFtIC0gUmV0dXJucyBkZWZhdWx0SW5kZXggaWYgbm90IGZvdW5kIGJ5IHRoZSBmdW5jdGlvbi5cbiogQGV4YW1wbGVcbmltcG9ydCB7IGZpbmRJbmRleCB9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuZmluZEluZGV4KFt7YTogMX0sIHthOiAyfSwge2E6IDN9LCB7YTogNH1dLCAoeyBhIH0pID0+IGEgPT09IDIpOyAvLyAxXG4qL1xuXG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyLCBjYWxsYmFjaywgZGVmYXVsdEluZGV4KSB7XG4gIGlmIChkZWZhdWx0SW5kZXggPT09IHZvaWQgMCkge1xuICAgIGRlZmF1bHRJbmRleCA9IC0xO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmIChjYWxsYmFjayhhcnJbaV0sIGksIGFycikpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkZWZhdWx0SW5kZXg7XG59XG4vKipcbiogUmV0dXJucyB0aGUgcmV2ZXJzZSBkaXJlY3Rpb24gaW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIGFycmF5IHRoYXQgc2F0aXNmaWVzIHRoZSBwcm92aWRlZCB0ZXN0aW5nIGZ1bmN0aW9uLlxuKiBAZnVuY3Rpb25cbiogQG1lbWJlcm9mIENyb3NzQnJvd3NlclxuKiBAcGFyYW0gLSBUaGUgYXJyYXkgYGZpbmRMYXN0SW5kZXhgIHdhcyBjYWxsZWQgdXBvbi5cbiogQHBhcmFtIC0gQSBmdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggdmFsdWUgaW4gdGhlIGFycmF5IHVudGlsIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUsIGluZGljYXRpbmcgdGhhdCB0aGUgc2F0aXNmeWluZyBlbGVtZW50IHdhcyBmb3VuZC5cbiogQHBhcmFtIC0gUmV0dXJucyBkZWZhdWx0SW5kZXggaWYgbm90IGZvdW5kIGJ5IHRoZSBmdW5jdGlvbi5cbiogQGV4YW1wbGVcbmltcG9ydCB7IGZpbmRMYXN0SW5kZXggfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmZpbmRMYXN0SW5kZXgoW3thOiAxfSwge2E6IDJ9LCB7YTogM30sIHthOiA0fV0sICh7IGEgfSkgPT4gYSA9PT0gMik7IC8vIDFcbiovXG5cbmZ1bmN0aW9uIGZpbmRMYXN0SW5kZXgoYXJyLCBjYWxsYmFjaywgZGVmYXVsdEluZGV4KSB7XG4gIGlmIChkZWZhdWx0SW5kZXggPT09IHZvaWQgMCkge1xuICAgIGRlZmF1bHRJbmRleCA9IC0xO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgaWYgKGNhbGxiYWNrKGFycltpXSwgaSwgYXJyKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRJbmRleDtcbn1cbi8qKlxuKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgcmV2ZXJzZSBkaXJlY3Rpb24gZWxlbWVudCBpbiB0aGUgYXJyYXkgdGhhdCBzYXRpc2ZpZXMgdGhlIHByb3ZpZGVkIHRlc3RpbmcgZnVuY3Rpb24uXG4qIEBmdW5jdGlvblxuKiBAbWVtYmVyb2YgQ3Jvc3NCcm93c2VyXG4qIEBwYXJhbSAtIFRoZSBhcnJheSBgZmluZExhc3RgIHdhcyBjYWxsZWQgdXBvbi5cbiogQHBhcmFtIC0gQSBmdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggdmFsdWUgaW4gdGhlIGFycmF5LFxuKiBAcGFyYW0gLSBSZXR1cm5zIGRlZmFsdXRWYWx1ZSBpZiBub3QgZm91bmQgYnkgdGhlIGZ1bmN0aW9uLlxuKiBAZXhhbXBsZVxuaW1wb3J0IHsgZmluZCB9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuZmluZChbe2E6IDF9LCB7YTogMn0sIHthOiAzfSwge2E6IDR9XSwgKHsgYSB9KSA9PiBhID09PSAyKTsgLy8ge2E6IDJ9XG4qL1xuXG5mdW5jdGlvbiBmaW5kTGFzdChhcnIsIGNhbGxiYWNrLCBkZWZhbHV0VmFsdWUpIHtcbiAgdmFyIGluZGV4ID0gZmluZExhc3RJbmRleChhcnIsIGNhbGxiYWNrKTtcbiAgcmV0dXJuIGluZGV4ID4gLTEgPyBhcnJbaW5kZXhdIDogZGVmYWx1dFZhbHVlO1xufVxuLyoqXG4qIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBhcnJheSB0aGF0IHNhdGlzZmllcyB0aGUgcHJvdmlkZWQgdGVzdGluZyBmdW5jdGlvbi5cbiogQGZ1bmN0aW9uXG4qIEBtZW1iZXJvZiBDcm9zc0Jyb3dzZXJcbiogQHBhcmFtIC0gVGhlIGFycmF5IGBmaW5kYCB3YXMgY2FsbGVkIHVwb24uXG4qIEBwYXJhbSAtIEEgZnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBlYWNoIHZhbHVlIGluIHRoZSBhcnJheSxcbiogQHBhcmFtIC0gUmV0dXJucyBkZWZhbHV0VmFsdWUgaWYgbm90IGZvdW5kIGJ5IHRoZSBmdW5jdGlvbi5cbiogQGV4YW1wbGVcbmltcG9ydCB7IGZpbmQgfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmZpbmQoW3thOiAxfSwge2E6IDJ9LCB7YTogM30sIHthOiA0fV0sICh7IGEgfSkgPT4gYSA9PT0gMik7IC8vIHthOiAyfVxuKi9cblxuZnVuY3Rpb24gZmluZChhcnIsIGNhbGxiYWNrLCBkZWZhbHV0VmFsdWUpIHtcbiAgdmFyIGluZGV4ID0gZmluZEluZGV4KGFyciwgY2FsbGJhY2spO1xuICByZXR1cm4gaW5kZXggPiAtMSA/IGFycltpbmRleF0gOiBkZWZhbHV0VmFsdWU7XG59XG4vKipcbiogd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgpIG1ldGhvZCB3aXRoIGNyb3NzIGJyb3dzZXIuXG4qIEBmdW5jdGlvblxuKiBAbWVtYmVyb2YgQ3Jvc3NCcm93c2VyXG4qIEBwYXJhbSB7RnJhbWVSZXF1ZXN0Q2FsbGJhY2t9IGNhbGxiYWNrIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBpdCdzIHRpbWUgdG8gdXBkYXRlIHlvdXIgYW5pbWF0aW9uIGZvciB0aGUgbmV4dCByZXBhaW50LlxuKiBAcmV0dXJuIHtudW1iZXJ9IGlkXG4qIEBleGFtcGxlXG5pbXBvcnQge3JlcXVlc3RBbmltYXRpb25GcmFtZX0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKHRpbWVzdGFtcCkgPT4ge1xuICBjb25zb2xlLmxvZyh0aW1lc3RhbXApO1xufSk7XG4qL1xuXG52YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgdmFyIGZpcnN0VGltZSA9IG5vdygpO1xuICB2YXIgcmFmID0gSVNfV0lORE9XICYmICh3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUpO1xuICByZXR1cm4gcmFmID8gcmFmLmJpbmQod2luZG93KSA6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHZhciBjdXJyVGltZSA9IG5vdygpO1xuICAgIHZhciBpZCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxiYWNrKGN1cnJUaW1lIC0gZmlyc3RUaW1lKTtcbiAgICB9LCAxMDAwIC8gNjApO1xuICAgIHJldHVybiBpZDtcbiAgfTtcbn0oKTtcbi8qKlxuKiB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoKSBtZXRob2Qgd2l0aCBjcm9zcyBicm93c2VyLlxuKiBAZnVuY3Rpb25cbiogQG1lbWJlcm9mIENyb3NzQnJvd3NlclxuKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlIC0gdGhlIGlkIG9idGFpbmVkIHRocm91Z2ggcmVxdWVzdEFuaW1hdGlvbkZyYW1lIG1ldGhvZFxuKiBAcmV0dXJuIHt2b2lkfVxuKiBAZXhhbXBsZVxuaW1wb3J0IHsgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBjYW5jZWxBbmltYXRpb25GcmFtZSB9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc3QgaWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKHRpbWVzdGFtcCkgPT4ge1xuICBjb25zb2xlLmxvZyh0aW1lc3RhbXApO1xufSk7XG5cbmNhbmNlbEFuaW1hdGlvbkZyYW1lKGlkKTtcbiovXG5cbnZhciBjYW5jZWxBbmltYXRpb25GcmFtZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIHZhciBjYWYgPSBJU19XSU5ET1cgJiYgKHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tc0NhbmNlbEFuaW1hdGlvbkZyYW1lKTtcbiAgcmV0dXJuIGNhZiA/IGNhZi5iaW5kKHdpbmRvdykgOiBmdW5jdGlvbiAoaGFuZGxlKSB7XG4gICAgY2xlYXJUaW1lb3V0KGhhbmRsZSk7XG4gIH07XG59KCk7XG4vKipcbiogQGZ1bmN0aW9uXG4qIEBtZW1iZXJvZiBVdGlsc1xuKi9cblxuZnVuY3Rpb24gZ2V0S2V5cyhvYmopIHtcbiAgaWYgKE9iamVjdC5rZXlzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaik7XG4gIH1cblxuICB2YXIga2V5cyA9IFtdO1xuXG4gIGZvciAodmFyIG5hbWUgaW4ga2V5cykge1xuICAgIGtleXMucHVzaChuYW1lKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuLyoqXG4qIEBmdW5jdGlvblxuKiBAbWVtYmVyb2YgVXRpbHNcbiovXG5cbmZ1bmN0aW9uIHNvcnRPcmRlcnMoa2V5cywgb3JkZXJzKSB7XG4gIGlmIChvcmRlcnMgPT09IHZvaWQgMCkge1xuICAgIG9yZGVycyA9IFtdO1xuICB9XG5cbiAga2V5cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGluZGV4MSA9IG9yZGVycy5pbmRleE9mKGEpO1xuICAgIHZhciBpbmRleDIgPSBvcmRlcnMuaW5kZXhPZihiKTtcblxuICAgIGlmIChpbmRleDIgPT09IC0xICYmIGluZGV4MSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmIChpbmRleDEgPT09IC0xKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXgyID09PSAtMSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIHJldHVybiBpbmRleDEgLSBpbmRleDI7XG4gIH0pO1xufVxuLyoqXG4qIGNvbnZlcnQgdW5pdCBzaXplIHRvIHB4IHNpemVcbiogQGZ1bmN0aW9uXG4qIEBtZW1iZXJvZiBVdGlsc1xuKi9cblxuZnVuY3Rpb24gY29udmVydFVuaXRTaXplKHBvcywgc2l6ZSkge1xuICB2YXIgX2EgPSBzcGxpdFVuaXQocG9zKSxcbiAgICAgIHZhbHVlID0gX2EudmFsdWUsXG4gICAgICB1bml0ID0gX2EudW5pdDtcblxuICBpZiAoaXNPYmplY3Qoc2l6ZSkpIHtcbiAgICB2YXIgc2l6ZUZ1bmN0aW9uID0gc2l6ZVt1bml0XTtcblxuICAgIGlmIChzaXplRnVuY3Rpb24pIHtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKHNpemVGdW5jdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIHNpemVGdW5jdGlvbih2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKERFRkFVTFRfVU5JVF9QUkVTRVRTW3VuaXRdKSB7XG4gICAgICAgIHJldHVybiBERUZBVUxUX1VOSVRfUFJFU0VUU1t1bml0XSh2YWx1ZSwgc2l6ZUZ1bmN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodW5pdCA9PT0gXCIlXCIpIHtcbiAgICByZXR1cm4gdmFsdWUgKiBzaXplIC8gMTAwO1xuICB9XG5cbiAgaWYgKERFRkFVTFRfVU5JVF9QUkVTRVRTW3VuaXRdKSB7XG4gICAgcmV0dXJuIERFRkFVTFRfVU5JVF9QUkVTRVRTW3VuaXRdKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuKiBjYWxjdWxhdGUgYmV0d2VlbiBtaW4sIG1heFxuKiBAZnVuY3Rpb25cbiogQG1lbWJlcm9mIFV0aWxzXG4qL1xuXG5mdW5jdGlvbiBiZXR3ZWVuKHZhbHVlLCBtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbih2YWx1ZSwgbWF4KSk7XG59XG5mdW5jdGlvbiBjaGVja0JvdW5kU2l6ZSh0YXJnZXRTaXplLCBjb21wYXJlU2l6ZSwgaXNNYXgpIHtcbiAgcmV0dXJuIFtbdGhyb3R0bGUoY29tcGFyZVNpemVbMF0sIFRJTllfTlVNKSwgdGhyb3R0bGUoY29tcGFyZVNpemVbMF0gKiB0YXJnZXRTaXplWzFdIC8gdGFyZ2V0U2l6ZVswXSwgVElOWV9OVU0pXSwgW3Rocm90dGxlKGNvbXBhcmVTaXplWzFdICogdGFyZ2V0U2l6ZVswXSAvIHRhcmdldFNpemVbMV0sIFRJTllfTlVNKSwgdGhyb3R0bGUoY29tcGFyZVNpemVbMV0sIFRJTllfTlVNKV1dLmZpbHRlcihmdW5jdGlvbiAoc2l6ZSkge1xuICAgIHJldHVybiBzaXplLmV2ZXJ5KGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xuICAgICAgcmV0dXJuIGlzTWF4ID8gdmFsdWUgPD0gY29tcGFyZVNpemVbaV0gOiB2YWx1ZSA+PSBjb21wYXJlU2l6ZVtpXTtcbiAgICB9KTtcbiAgfSlbMF0gfHwgdGFyZ2V0U2l6ZTtcbn1cbi8qKlxuKiBjYWxjdWxhdGUgYm91bmQgc2l6ZVxuKiBAZnVuY3Rpb25cbiogQG1lbWJlcm9mIFV0aWxzXG4qL1xuXG5mdW5jdGlvbiBjYWxjdWxhdGVCb3VuZFNpemUoc2l6ZSwgbWluU2l6ZSwgbWF4U2l6ZSwga2VlcFJhdGlvKSB7XG4gIGlmICgha2VlcFJhdGlvKSB7XG4gICAgcmV0dXJuIHNpemUubWFwKGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xuICAgICAgcmV0dXJuIGJldHdlZW4odmFsdWUsIG1pblNpemVbaV0sIG1heFNpemVbaV0pO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIHdpZHRoID0gc2l6ZVswXSxcbiAgICAgIGhlaWdodCA9IHNpemVbMV07IC8vIHdpZHRoIDogaGVpZ2h0ID0gbWluV2lkdGggOiBtaW5IZWlnaHQ7XG5cbiAgdmFyIF9hID0gY2hlY2tCb3VuZFNpemUoc2l6ZSwgbWluU2l6ZSwgZmFsc2UpLFxuICAgICAgbWluV2lkdGggPSBfYVswXSxcbiAgICAgIG1pbkhlaWdodCA9IF9hWzFdO1xuXG4gIHZhciBfYiA9IGNoZWNrQm91bmRTaXplKHNpemUsIG1heFNpemUsIHRydWUpLFxuICAgICAgbWF4V2lkdGggPSBfYlswXSxcbiAgICAgIG1heEhlaWdodCA9IF9iWzFdO1xuXG4gIGlmICh3aWR0aCA8IG1pbldpZHRoIHx8IGhlaWdodCA8IG1pbkhlaWdodCkge1xuICAgIHdpZHRoID0gbWluV2lkdGg7XG4gICAgaGVpZ2h0ID0gbWluSGVpZ2h0O1xuICB9IGVsc2UgaWYgKHdpZHRoID4gbWF4V2lkdGggfHwgaGVpZ2h0ID4gbWF4SGVpZ2h0KSB7XG4gICAgd2lkdGggPSBtYXhXaWR0aDtcbiAgICBoZWlnaHQgPSBtYXhIZWlnaHQ7XG4gIH1cblxuICByZXR1cm4gW3dpZHRoLCBoZWlnaHRdO1xufVxuLyoqXG4qIEFkZCBhbGwgdGhlIG51bWJlcnMuXG4qIEBmdW5jdGlvblxuKiBAbWVtYmVyb2YgVXRpbHNcbiovXG5cbmZ1bmN0aW9uIHN1bShudW1zKSB7XG4gIHZhciBsZW5ndGggPSBudW1zLmxlbmd0aDtcbiAgdmFyIHRvdGFsID0gMDtcblxuICBmb3IgKHZhciBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICB0b3RhbCArPSBudW1zW2ldO1xuICB9XG5cbiAgcmV0dXJuIHRvdGFsO1xufVxuLyoqXG4qIEF2ZXJhZ2UgYWxsIG51bWJlcnMuXG4qIEBmdW5jdGlvblxuKiBAbWVtYmVyb2YgVXRpbHNcbiovXG5cbmZ1bmN0aW9uIGF2ZXJhZ2UobnVtcykge1xuICB2YXIgbGVuZ3RoID0gbnVtcy5sZW5ndGg7XG4gIHZhciB0b3RhbCA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgdG90YWwgKz0gbnVtc1tpXTtcbiAgfVxuXG4gIHJldHVybiBsZW5ndGggPyB0b3RhbCAvIGxlbmd0aCA6IDA7XG59XG4vKipcbiogR2V0IHRoZSBhbmdsZSBvZiB0d28gcG9pbnRzLiAoMCA8PSByYWQgPCAzNTkpXG4qIEBmdW5jdGlvblxuKiBAbWVtYmVyb2YgVXRpbHNcbiovXG5cbmZ1bmN0aW9uIGdldFJhZChwb3MxLCBwb3MyKSB7XG4gIHZhciBkaXN0WCA9IHBvczJbMF0gLSBwb3MxWzBdO1xuICB2YXIgZGlzdFkgPSBwb3MyWzFdIC0gcG9zMVsxXTtcbiAgdmFyIHJhZCA9IE1hdGguYXRhbjIoZGlzdFksIGRpc3RYKTtcbiAgcmV0dXJuIHJhZCA+PSAwID8gcmFkIDogcmFkICsgTWF0aC5QSSAqIDI7XG59XG4vKipcbiogR2V0IHRoZSBhdmVyYWdlIHBvaW50IG9mIGFsbCBwb2ludHMuXG4qIEBmdW5jdGlvblxuKiBAbWVtYmVyb2YgVXRpbHNcbiovXG5cbmZ1bmN0aW9uIGdldENlbnRlclBvaW50KHBvaW50cykge1xuICByZXR1cm4gWzAsIDFdLm1hcChmdW5jdGlvbiAoaSkge1xuICAgIHJldHVybiBhdmVyYWdlKHBvaW50cy5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgICAgcmV0dXJuIHBvc1tpXTtcbiAgICB9KSk7XG4gIH0pO1xufVxuLyoqXG4qIEdldHMgdGhlIGRpcmVjdGlvbiBvZiB0aGUgc2hhcGUuXG4qIEBmdW5jdGlvblxuKiBAbWVtYmVyb2YgVXRpbHNcbiovXG5cbmZ1bmN0aW9uIGdldFNoYXBlRGlyZWN0aW9uKHBvaW50cykge1xuICB2YXIgY2VudGVyID0gZ2V0Q2VudGVyUG9pbnQocG9pbnRzKTtcbiAgdmFyIHBvczFSYWQgPSBnZXRSYWQoY2VudGVyLCBwb2ludHNbMF0pO1xuICB2YXIgcG9zMlJhZCA9IGdldFJhZChjZW50ZXIsIHBvaW50c1sxXSk7XG4gIHJldHVybiBwb3MxUmFkIDwgcG9zMlJhZCAmJiBwb3MyUmFkIC0gcG9zMVJhZCA8IE1hdGguUEkgfHwgcG9zMVJhZCA+IHBvczJSYWQgJiYgcG9zMlJhZCAtIHBvczFSYWQgPCAtTWF0aC5QSSA/IDEgOiAtMTtcbn1cbi8qKlxuKiBHZXQgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy5cbiogQGZ1bmN0aW9uXG4qIEBtZW1iZXJvZiBVdGlsc1xuKi9cblxuZnVuY3Rpb24gZ2V0RGlzdChhLCBiKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coKGIgPyBiWzBdIDogMCkgLSBhWzBdLCAyKSArIE1hdGgucG93KChiID8gYlsxXSA6IDApIC0gYVsxXSwgMikpO1xufVxuLyoqXG4qIHRocm90dGxlIG51bWJlciBkZXBlbmRpbmcgb24gdGhlIHVuaXQuXG4qIEBmdW5jdGlvblxuKiBAbWVtYmVyb2YgVXRpbHNcbiovXG5cbmZ1bmN0aW9uIHRocm90dGxlKG51bSwgdW5pdCkge1xuICBpZiAoIXVuaXQpIHtcbiAgICByZXR1cm4gbnVtO1xuICB9XG5cbiAgcmV0dXJuIE1hdGgucm91bmQobnVtIC8gdW5pdCkgKiB1bml0O1xufVxuLyoqXG4qIHRocm90dGxlIG51bWJlciBhcnJheSBkZXBlbmRpbmcgb24gdGhlIHVuaXQuXG4qIEBmdW5jdGlvblxuKiBAbWVtYmVyb2YgVXRpbHNcbiovXG5cbmZ1bmN0aW9uIHRocm90dGxlQXJyYXkobnVtcywgdW5pdCkge1xuICBudW1zLmZvckVhY2goZnVuY3Rpb24gKF8sIGkpIHtcbiAgICBudW1zW2ldID0gdGhyb3R0bGUobnVtc1tpXSwgdW5pdCk7XG4gIH0pO1xuICByZXR1cm4gbnVtcztcbn1cbi8qKlxuKiBAZnVuY3Rpb25cbiogQG1lbWJlcm9mIFV0aWxzXG4qL1xuXG5mdW5jdGlvbiBjb3VudGVyKG51bSkge1xuICB2YXIgbnVtcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtOyArK2kpIHtcbiAgICBudW1zLnB1c2goaSk7XG4gIH1cblxuICByZXR1cm4gbnVtcztcbn1cbi8qKlxuKiBAZnVuY3Rpb25cbiogQG1lbWJlcm9mIFV0aWxzXG4qL1xuXG5mdW5jdGlvbiByZXBsYWNlT25jZSh0ZXh0LCBmcm9tVGV4dCwgdG9UZXh0KSB7XG4gIHZhciBpc09uY2UgPSBmYWxzZTtcbiAgcmV0dXJuIHRleHQucmVwbGFjZShmcm9tVGV4dCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gW107XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cblxuICAgIGlmIChpc09uY2UpIHtcbiAgICAgIHJldHVybiBhcmdzWzBdO1xuICAgIH1cblxuICAgIGlzT25jZSA9IHRydWU7XG4gICAgcmV0dXJuIGlzU3RyaW5nKHRvVGV4dCkgPyB0b1RleHQgOiB0b1RleHQuYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgfSk7XG59XG5cbi8qKlxuKiBAbmFtZXNwYWNlXG4qIEBuYW1lIENvbG9yXG4qL1xuXG4vKipcbiogUmVtb3ZlIHRoZSAjIGZyb20gdGhlIGhleCBjb2xvci5cbiogQG1lbWJlcm9mIENvbG9yXG4qIEBwYXJhbSB7fSBoZXggLSBoZXggY29sb3JcbiogQHJldHVybiB7fSBoZXggY29sb3JcbiogQGV4YW1wbGVcbmltcG9ydCB7Y3V0SGV4fSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKGN1dEhleChcIiMwMDAwMDBcIikpIC8vIFwiMDAwMDAwXCJcbiovXG5cbmZ1bmN0aW9uIGN1dEhleChoZXgpIHtcbiAgcmV0dXJuIGhleC5yZXBsYWNlKFwiI1wiLCBcIlwiKTtcbn1cbi8qKlxuKiBjb252ZXJ0IGhleCBjb2xvciB0byByZ2IgY29sb3IuXG4qIEBtZW1iZXJvZiBDb2xvclxuKiBAcGFyYW0ge30gaGV4IC0gaGV4IGNvbG9yXG4qIEByZXR1cm4ge30gcmdiIGNvbG9yXG4qIEBleGFtcGxlXG5pbXBvcnQge2hleFRvUkdCQX0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhoZXhUb1JHQkEoXCIjMDAwMDAwMDVcIikpO1xuLy8gWzAsIDAsIDAsIDFdXG5jb25zb2xlLmxvZyhoZXhUb1JHQkEoXCIjMjAxMDQ1XCIpKTtcbi8vIFszMiwgMTYsIDY5LCAxXVxuKi9cblxuZnVuY3Rpb24gaGV4VG9SR0JBKGhleCkge1xuICB2YXIgaCA9IGN1dEhleChoZXgpO1xuICB2YXIgciA9IHBhcnNlSW50KGguc3Vic3RyaW5nKDAsIDIpLCAxNik7XG4gIHZhciBnID0gcGFyc2VJbnQoaC5zdWJzdHJpbmcoMiwgNCksIDE2KTtcbiAgdmFyIGIgPSBwYXJzZUludChoLnN1YnN0cmluZyg0LCA2KSwgMTYpO1xuICB2YXIgYSA9IHBhcnNlSW50KGguc3Vic3RyaW5nKDYsIDgpLCAxNikgLyAyNTU7XG5cbiAgaWYgKGlzTmFOKGEpKSB7XG4gICAgYSA9IDE7XG4gIH1cblxuICByZXR1cm4gW3IsIGcsIGIsIGFdO1xufVxuLyoqXG4qIGNvbnZlcnQgMyhvciA0KS1kaWdpdCBoZXggY29sb3IgdG8gNihvciA4KS1kaWdpdCBoZXggY29sb3IuXG4qIEBtZW1iZXJvZiBDb2xvclxuKiBAcGFyYW0ge30gaGV4IC0gMyhvciA0KS1kaWdpdCBoZXggY29sb3JcbiogQHJldHVybiB7fSA2KG9yIDgpLWRpZ2l0IGhleCBjb2xvclxuKiBAZXhhbXBsZVxuaW1wb3J0IHt0b0Z1bGxIZXh9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2codG9GdWxsSGV4KFwiIzEyM1wiKSk7IC8vIFwiIzExMjIzM1wiXG5jb25zb2xlLmxvZyh0b0Z1bGxIZXgoXCIjMTIzYVwiKSk7IC8vIFwiIzExMjIzM2FhXCJcbiovXG5cbmZ1bmN0aW9uIHRvRnVsbEhleChoKSB7XG4gIHZhciByID0gaC5jaGFyQXQoMSk7XG4gIHZhciBnID0gaC5jaGFyQXQoMik7XG4gIHZhciBiID0gaC5jaGFyQXQoMyk7XG4gIHZhciBhID0gaC5jaGFyQXQoNCk7XG4gIHZhciBhcnIgPSBbXCIjXCIsIHIsIHIsIGcsIGcsIGIsIGIsIGEsIGFdO1xuICByZXR1cm4gYXJyLmpvaW4oXCJcIik7XG59XG4vKipcbiogY29udmVydCBoc2wgY29sb3IgdG8gcmdiYSBjb2xvci5cbiogQG1lbWJlcm9mIENvbG9yXG4qIEBwYXJhbSB7fSBoc2wgLSBoc2wgY29sb3IoaHVlOiAwIH4gMzYwLCBzYXR1cmF0aW9uOiAwIH4gMSwgbGlnaHRuZXNzOiAwIH4gMSwgYWxwaGE6IDAgfiAxKVxuKiBAcmV0dXJuIHt9IHJnYmEgY29sb3JcbiogQGV4YW1wbGVcbmltcG9ydCB7aHNsVG9SR0JBfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKGhzbFRvUkdCQShbMTUwLCAwLjUsIDAuNF0pKTtcbi8vIFs1MSwgMTUzLCAxMDIsIDFdXG4qL1xuXG5mdW5jdGlvbiBoc2xUb1JHQkEoaHNsKSB7XG4gIHZhciBfYTtcblxuICB2YXIgaCA9IGhzbFswXTtcbiAgdmFyIHMgPSBoc2xbMV07XG4gIHZhciBsID0gaHNsWzJdO1xuXG4gIGlmIChoIDwgMCkge1xuICAgIGggKz0gTWF0aC5mbG9vcigoTWF0aC5hYnMoaCkgKyAzNjApIC8gMzYwKSAqIDM2MDtcbiAgfVxuXG4gIGggJT0gMzYwO1xuICB2YXIgYyA9ICgxIC0gTWF0aC5hYnMoMiAqIGwgLSAxKSkgKiBzO1xuICB2YXIgeCA9IGMgKiAoMSAtIE1hdGguYWJzKGggLyA2MCAlIDIgLSAxKSk7XG4gIHZhciBtID0gbCAtIGMgLyAyO1xuICB2YXIgcmdiO1xuXG4gIGlmIChoIDwgNjApIHtcbiAgICByZ2IgPSBbYywgeCwgMF07XG4gIH0gZWxzZSBpZiAoaCA8IDEyMCkge1xuICAgIHJnYiA9IFt4LCBjLCAwXTtcbiAgfSBlbHNlIGlmIChoIDwgMTgwKSB7XG4gICAgcmdiID0gWzAsIGMsIHhdO1xuICB9IGVsc2UgaWYgKGggPCAyNDApIHtcbiAgICByZ2IgPSBbMCwgeCwgY107XG4gIH0gZWxzZSBpZiAoaCA8IDMwMCkge1xuICAgIHJnYiA9IFt4LCAwLCBjXTtcbiAgfSBlbHNlIGlmIChoIDwgMzYwKSB7XG4gICAgcmdiID0gW2MsIDAsIHhdO1xuICB9IGVsc2Uge1xuICAgIHJnYiA9IFswLCAwLCAwXTtcbiAgfVxuXG4gIHJldHVybiBbTWF0aC5yb3VuZCgocmdiWzBdICsgbSkgKiAyNTUpLCBNYXRoLnJvdW5kKChyZ2JbMV0gKyBtKSAqIDI1NSksIE1hdGgucm91bmQoKHJnYlsyXSArIG0pICogMjU1KSwgKF9hID0gaHNsWzNdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxXTtcbn1cbi8qKlxuKiBjb252ZXJ0IHN0cmluZyB0byByZ2JhIGNvbG9yLlxuKiBAbWVtYmVyb2YgQ29sb3JcbiogQHBhcmFtIHt9IC0gMy1oZXgoIzAwMCksIDQtaGV4KCMwMDAwKSA2LWhleCgjMDAwMDAwKSwgOC1oZXgoIzAwMDAwMDAwKSBvciBSR0IoQSksIG9yIEhTTChBKVxuKiBAcmV0dXJuIHt9IHJnYmEgY29sb3JcbiogQGV4YW1wbGVcbmltcG9ydCB7c3RyaW5nVG9SR0JBfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKHN0cmluZ1RvUkdCQShcIiMwMDAwMDBcIikpOyAvLyBbMCwgMCwgMCwgMV1cbmNvbnNvbGUubG9nKHN0cmluZ1RvUkdCQShcInJnYigxMDAsIDEwMCwgMTAwKVwiKSk7IC8vIFsxMDAsIDEwMCwgMTAwLCAxXVxuY29uc29sZS5sb2coc3RyaW5nVG9SR0JBKFwiaHNsKDE1MCwgMC41LCAwLjQpXCIpKTsgLy8gWzUxLCAxNTMsIDEwMiwgMV1cbiovXG5cbmZ1bmN0aW9uIHN0cmluZ1RvUkdCQShjb2xvcikge1xuICBpZiAoY29sb3IuY2hhckF0KDApID09PSBcIiNcIikge1xuICAgIGlmIChjb2xvci5sZW5ndGggPT09IDQgfHwgY29sb3IubGVuZ3RoID09PSA1KSB7XG4gICAgICByZXR1cm4gaGV4VG9SR0JBKHRvRnVsbEhleChjb2xvcikpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaGV4VG9SR0JBKGNvbG9yKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoY29sb3IuaW5kZXhPZihcIihcIikgIT09IC0xKSB7XG4gICAgLy8gaW4gYnJhY2tldC5cbiAgICB2YXIgX2EgPSBzcGxpdEJyYWNrZXQoY29sb3IpLFxuICAgICAgICBwcmVmaXggPSBfYS5wcmVmaXgsXG4gICAgICAgIHZhbHVlID0gX2EudmFsdWU7XG5cbiAgICBpZiAoIXByZWZpeCB8fCAhdmFsdWUpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdmFyIGFyciA9IHNwbGl0Q29tbWEodmFsdWUpO1xuICAgIHZhciBjb2xvckFyciA9IFswLCAwLCAwLCAxXTtcbiAgICB2YXIgbGVuZ3RoID0gYXJyLmxlbmd0aDtcblxuICAgIHN3aXRjaCAocHJlZml4KSB7XG4gICAgICBjYXNlIFJHQjpcbiAgICAgIGNhc2UgUkdCQTpcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNvbG9yQXJyW2ldID0gcGFyc2VGbG9hdChhcnJbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbG9yQXJyO1xuXG4gICAgICBjYXNlIEhTTDpcbiAgICAgIGNhc2UgSFNMQTpcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmIChhcnJbaV0uaW5kZXhPZihcIiVcIikgIT09IC0xKSB7XG4gICAgICAgICAgICBjb2xvckFycltpXSA9IHBhcnNlRmxvYXQoYXJyW2ldKSAvIDEwMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29sb3JBcnJbaV0gPSBwYXJzZUZsb2F0KGFycltpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGhzbCwgaHNsYSB0byByZ2JhXG5cblxuICAgICAgICByZXR1cm4gaHNsVG9SR0JBKGNvbG9yQXJyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFJldHVybnMgYWxsIGVsZW1lbnQgZGVzY2VuZGFudHMgb2Ygbm9kZSB0aGF0XG4gKiBtYXRjaCBzZWxlY3RvcnMuXG4gKi9cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHNwZWNpZmllZCBjbGFzcyB2YWx1ZSBleGlzdHMgaW4gdGhlIGVsZW1lbnQncyBjbGFzcyBhdHRyaWJ1dGUuXG4gKiBAbWVtYmVyb2YgRE9NXG4gKiBAcGFyYW0gLSBBIERPTVN0cmluZyBjb250YWluaW5nIG9uZSBvciBtb3JlIHNlbGVjdG9ycyB0byBtYXRjaFxuICogQHBhcmFtIC0gSWYgbXVsdGkgaXMgdHJ1ZSwgYSBET01TdHJpbmcgY29udGFpbmluZyBvbmUgb3IgbW9yZSBzZWxlY3RvcnMgdG8gbWF0Y2ggYWdhaW5zdC5cbiAqIEBleGFtcGxlXG5pbXBvcnQgeyR9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coJChcImRpdlwiKSk7IC8vIGRpdiBlbGVtZW50XG5jb25zb2xlLmxvZygkKFwiZGl2XCIsIHRydWUpKTsgLy8gW2RpdiwgZGl2XSBlbGVtZW50c1xuKi9cblxuZnVuY3Rpb24gJChzZWxlY3RvcnMsIG11bHRpKSB7XG4gIHJldHVybiBtdWx0aSA/IGRvYy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9ycykgOiBkb2MucXVlcnlTZWxlY3RvcihzZWxlY3RvcnMpO1xufVxuLyoqXG4qIENoZWNrcyBpZiB0aGUgc3BlY2lmaWVkIGNsYXNzIHZhbHVlIGV4aXN0cyBpbiB0aGUgZWxlbWVudCdzIGNsYXNzIGF0dHJpYnV0ZS5cbiogQG1lbWJlcm9mIERPTVxuKiBAcGFyYW0gZWxlbWVudCAtIHRhcmdldFxuKiBAcGFyYW0gY2xhc3NOYW1lIC0gdGhlIGNsYXNzIG5hbWUgdG8gc2VhcmNoXG4qIEByZXR1cm4ge2Jvb2xlYW59IHJldHVybiBmYWxzZSBpZiB0aGUgY2xhc3MgaXMgbm90IGZvdW5kLlxuKiBAZXhhbXBsZVxuaW1wb3J0IHtoYXNDbGFzc30gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhoYXNDbGFzcyhlbGVtZW50LCBcInN0YXJ0XCIpKTsgLy8gdHJ1ZSBvciBmYWxzZVxuKi9cblxuZnVuY3Rpb24gaGFzQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgIHJldHVybiBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpO1xuICB9XG5cbiAgcmV0dXJuICEhZWxlbWVudC5jbGFzc05hbWUubWF0Y2gobmV3IFJlZ0V4cChcIihcXFxcc3xeKVwiICsgY2xhc3NOYW1lICsgXCIoXFxcXHN8JClcIikpO1xufVxuLyoqXG4qIEFkZCB0aGUgc3BlY2lmaWVkIGNsYXNzIHZhbHVlLiBJZiB0aGVzZSBjbGFzc2UgYWxyZWFkeSBleGlzdCBpbiB0aGUgZWxlbWVudCdzIGNsYXNzIGF0dHJpYnV0ZSB0aGV5IGFyZSBpZ25vcmVkLlxuKiBAbWVtYmVyb2YgRE9NXG4qIEBwYXJhbSBlbGVtZW50IC0gdGFyZ2V0XG4qIEBwYXJhbSBjbGFzc05hbWUgLSB0aGUgY2xhc3MgbmFtZSB0byBhZGRcbiogQGV4YW1wbGVcbmltcG9ydCB7YWRkQ2xhc3N9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuYWRkQ2xhc3MoZWxlbWVudCwgXCJzdGFydFwiKTtcbiovXG5cbmZ1bmN0aW9uIGFkZENsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgfSBlbHNlIHtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSArPSBcIiBcIiArIGNsYXNzTmFtZTtcbiAgfVxufVxuLyoqXG4qIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBjbGFzcyB2YWx1ZS5cbiogQG1lbWJlcm9mIERPTVxuKiBAcGFyYW0gZWxlbWVudCAtIHRhcmdldFxuKiBAcGFyYW0gY2xhc3NOYW1lIC0gdGhlIGNsYXNzIG5hbWUgdG8gcmVtb3ZlXG4qIEBleGFtcGxlXG5pbXBvcnQge3JlbW92ZUNsYXNzfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbnJlbW92ZUNsYXNzKGVsZW1lbnQsIFwic3RhcnRcIik7XG4qL1xuXG5mdW5jdGlvbiByZW1vdmVDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHJlZyA9IG5ldyBSZWdFeHAoXCIoXFxcXHN8XilcIiArIGNsYXNzTmFtZSArIFwiKFxcXFxzfCQpXCIpO1xuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWUucmVwbGFjZShyZWcsIFwiIFwiKTtcbiAgfVxufVxuLyoqXG4qIEdldHMgdGhlIENTUyBwcm9wZXJ0aWVzIGZyb20gdGhlIGVsZW1lbnQuXG4qIEBtZW1iZXJvZiBET01cbiogQHBhcmFtIGVsZW1lbnRzIC0gZWxlbWVudHNcbiogQHBhcmFtIHByb3Blcml0ZXMgLSB0aGUgQ1NTIHByb3BlcnRpZXNcbiogQHJldHVybiByZXR1cm5zIENTUyBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMuXG4qIEBleGFtcGxlXG5pbXBvcnQge2Zyb21DU1N9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coZnJvbUNTUyhlbGVtZW50LCBbXCJsZWZ0XCIsIFwib3BhY2l0eVwiLCBcInRvcFwiXSkpOyAvLyB7XCJsZWZ0XCI6IFwiMTBweFwiLCBcIm9wYWNpdHlcIjogMSwgXCJ0b3BcIjogXCIxMHB4XCJ9XG4qL1xuXG5mdW5jdGlvbiBmcm9tQ1NTKGVsZW1lbnRzLCBwcm9wZXJ0aWVzKSB7XG4gIGlmICghZWxlbWVudHMgfHwgIXByb3BlcnRpZXMgfHwgIXByb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgdmFyIGVsZW1lbnQ7XG5cbiAgaWYgKGVsZW1lbnRzIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgIGVsZW1lbnQgPSBlbGVtZW50cztcbiAgfSBlbHNlIGlmIChlbGVtZW50cy5sZW5ndGgpIHtcbiAgICBlbGVtZW50ID0gZWxlbWVudHNbMF07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgdmFyIGNzc09iamVjdCA9IHt9O1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIHZhciBsZW5ndGggPSBwcm9wZXJ0aWVzLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY3NzT2JqZWN0W3Byb3BlcnRpZXNbaV1dID0gc3R5bGVzW3Byb3BlcnRpZXNbaV1dO1xuICB9XG5cbiAgcmV0dXJuIGNzc09iamVjdDtcbn1cbi8qKlxuKiBTZXRzIHVwIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciB0aGUgc3BlY2lmaWVkIGV2ZW50IGlzIGRlbGl2ZXJlZCB0byB0aGUgdGFyZ2V0XG4qIEBtZW1iZXJvZiBET01cbiogQHBhcmFtIC0gZXZlbnQgdGFyZ2V0XG4qIEBwYXJhbSAtIEEgY2FzZS1zZW5zaXRpdmUgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXZlbnQgdHlwZSB0byBsaXN0ZW4gZm9yLlxuKiBAcGFyYW0gLSBUaGUgb2JqZWN0IHdoaWNoIHJlY2VpdmVzIGEgbm90aWZpY2F0aW9uIChhbiBvYmplY3QgdGhhdCBpbXBsZW1lbnRzIHRoZSBFdmVudCBpbnRlcmZhY2UpIHdoZW4gYW4gZXZlbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlIG9jY3Vyc1xuKiBAcGFyYW0gLSBBbiBvcHRpb25zIG9iamVjdCB0aGF0IHNwZWNpZmllcyBjaGFyYWN0ZXJpc3RpY3MgYWJvdXQgdGhlIGV2ZW50IGxpc3RlbmVyLlxuKiBAZXhhbXBsZVxuaW1wb3J0IHthZGRFdmVudH0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5hZGRFdmVudChlbCwgXCJjbGlja1wiLCBlID0+IHtcbiAgY29uc29sZS5sb2coZSk7XG59KTtcbiovXG5cbmZ1bmN0aW9uIGFkZEV2ZW50KGVsLCB0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICBlbC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcbn1cbi8qKlxuKiByZW1vdmVzIGZyb20gdGhlIEV2ZW50VGFyZ2V0IGFuIGV2ZW50IGxpc3RlbmVyIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCB3aXRoIEV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoKVxuKiBAbWVtYmVyb2YgRE9NXG4qIEBwYXJhbSAtIGV2ZW50IHRhcmdldFxuKiBAcGFyYW0gLSBBIGNhc2Utc2Vuc2l0aXZlIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGV2ZW50IHR5cGUgdG8gbGlzdGVuIGZvci5cbiogQHBhcmFtIC0gVGhlIEV2ZW50TGlzdGVuZXIgZnVuY3Rpb24gb2YgdGhlIGV2ZW50IGhhbmRsZXIgdG8gcmVtb3ZlIGZyb20gdGhlIGV2ZW50IHRhcmdldC5cbiogQHBhcmFtIC0gQW4gb3B0aW9ucyBvYmplY3QgdGhhdCBzcGVjaWZpZXMgY2hhcmFjdGVyaXN0aWNzIGFib3V0IHRoZSBldmVudCBsaXN0ZW5lci5cbiogQGV4YW1wbGVcbmltcG9ydCB7YWRkRXZlbnQsIHJlbW92ZUV2ZW50fSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5jb25zdCBsaXN0ZW5lciA9IGUgPT4ge1xuICBjb25zb2xlLmxvZyhlKTtcbn07XG5hZGRFdmVudChlbCwgXCJjbGlja1wiLCBsaXN0ZW5lcik7XG5yZW1vdmVFdmVudChlbCwgXCJjbGlja1wiLCBsaXN0ZW5lcik7XG4qL1xuXG5mdW5jdGlvbiByZW1vdmVFdmVudChlbCwgdHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG59XG5cbmV4cG9ydCB7IFJHQiwgUkdCQSwgSFNMLCBIU0xBLCBDT0xPUl9NT0RFTFMsIEZVTkNUSU9OLCBQUk9QRVJUWSwgQVJSQVksIE9CSkVDVCwgU1RSSU5HLCBOVU1CRVIsIFVOREVGSU5FRCwgSVNfV0lORE9XLCBkb2MgYXMgZG9jdW1lbnQsIGdldENyb3NzQnJvd3NlclByb3BlcnR5LCBUUkFOU0ZPUk0sIEZJTFRFUiwgQU5JTUFUSU9OLCBLRVlGUkFNRVMsIE9QRU5fQ0xPU0VEX0NIQVJBQ1RFUlMsIFRJTllfTlVNLCBERUZBVUxUX1VOSVRfUFJFU0VUUywgY3V0SGV4LCBoZXhUb1JHQkEsIHRvRnVsbEhleCwgaHNsVG9SR0JBLCBzdHJpbmdUb1JHQkEsIGRvdCwgaXNVbmRlZmluZWQsIGlzT2JqZWN0LCBpc0FycmF5LCBpc1N0cmluZywgaXNOdW1iZXIsIGlzRnVuY3Rpb24sIHNwbGl0VGV4dCwgc3BsaXRTcGFjZSwgc3BsaXRDb21tYSwgc3BsaXRCcmFja2V0LCBzcGxpdFVuaXQsIGNhbWVsaXplLCBkZWNhbWVsaXplLCB0b0FycmF5LCBub3csIGZpbmRJbmRleCwgZmluZExhc3RJbmRleCwgZmluZExhc3QsIGZpbmQsIHJlcXVlc3RBbmltYXRpb25GcmFtZSwgY2FuY2VsQW5pbWF0aW9uRnJhbWUsIGdldEtleXMsIHNvcnRPcmRlcnMsIGNvbnZlcnRVbml0U2l6ZSwgYmV0d2VlbiwgY2hlY2tCb3VuZFNpemUsIGNhbGN1bGF0ZUJvdW5kU2l6ZSwgc3VtLCBhdmVyYWdlLCBnZXRSYWQsIGdldENlbnRlclBvaW50LCBnZXRTaGFwZURpcmVjdGlvbiwgZ2V0RGlzdCwgdGhyb3R0bGUsIHRocm90dGxlQXJyYXksIGNvdW50ZXIsIHJlcGxhY2VPbmNlLCAkLCBoYXNDbGFzcywgYWRkQ2xhc3MsIHJlbW92ZUNsYXNzLCBmcm9tQ1NTLCBhZGRFdmVudCwgcmVtb3ZlRXZlbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmVzbS5qcy5tYXBcbiIsIi8qXG5Db3B5cmlnaHQgKGMpIDIwMTUgTkFWRVIgQ29ycC5cbm5hbWU6IEBlZ2pzL2FnZW50XG5saWNlbnNlOiBNSVRcbmF1dGhvcjogTkFWRVIgQ29ycC5cbnJlcG9zaXRvcnk6IGdpdCtodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvYWdlbnQuZ2l0XG52ZXJzaW9uOiAyLjMuMFxuKi9cbmZ1bmN0aW9uIHNvbWUoYXJyLCBjYWxsYmFjaykge1xuICB2YXIgbGVuZ3RoID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGNhbGxiYWNrKGFycltpXSwgaSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGZpbmQoYXJyLCBjYWxsYmFjaykge1xuICB2YXIgbGVuZ3RoID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGNhbGxiYWNrKGFycltpXSwgaSkpIHtcbiAgICAgIHJldHVybiBhcnJbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRVc2VyQWdlbnQoYWdlbnQpIHtcbiAgdmFyIHVzZXJBZ2VudCA9IGFnZW50O1xuXG4gIGlmICh0eXBlb2YgdXNlckFnZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09IFwidW5kZWZpbmVkXCIgfHwgIW5hdmlnYXRvcikge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuXG4gICAgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCBcIlwiO1xuICB9XG5cbiAgcmV0dXJuIHVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gZXhlY1JlZ0V4cChwYXR0ZXJuLCB0ZXh0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAocGF0dGVybiwgXCJnXCIpLmV4ZWModGV4dCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gaGFzVXNlckFnZW50RGF0YSgpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09IFwidW5kZWZpbmVkXCIgfHwgIW5hdmlnYXRvciB8fCAhbmF2aWdhdG9yLnVzZXJBZ2VudERhdGEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgdXNlckFnZW50RGF0YSA9IG5hdmlnYXRvci51c2VyQWdlbnREYXRhO1xuICB2YXIgYnJhbmRzID0gdXNlckFnZW50RGF0YS5icmFuZHMgfHwgdXNlckFnZW50RGF0YS51YUxpc3Q7XG4gIHJldHVybiAhIShicmFuZHMgJiYgYnJhbmRzLmxlbmd0aCk7XG59XG5mdW5jdGlvbiBmaW5kVmVyc2lvbih2ZXJzaW9uVGVzdCwgdXNlckFnZW50KSB7XG4gIHZhciByZXN1bHQgPSBleGVjUmVnRXhwKFwiKFwiICsgdmVyc2lvblRlc3QgKyBcIikoKD86XFxcXC98XFxcXHN8OikoWzAtOXxcXFxcLnxfXSspKVwiLCB1c2VyQWdlbnQpO1xuICByZXR1cm4gcmVzdWx0ID8gcmVzdWx0WzNdIDogXCJcIjtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRWZXJzaW9uKHRleHQpIHtcbiAgcmV0dXJuIHRleHQucmVwbGFjZSgvXy9nLCBcIi5cIik7XG59XG5mdW5jdGlvbiBmaW5kUHJlc2V0KHByZXNldHMsIHVzZXJBZ2VudCkge1xuICB2YXIgdXNlclByZXNldCA9IG51bGw7XG4gIHZhciB2ZXJzaW9uID0gXCItMVwiO1xuICBzb21lKHByZXNldHMsIGZ1bmN0aW9uIChwcmVzZXQpIHtcbiAgICB2YXIgcmVzdWx0ID0gZXhlY1JlZ0V4cChcIihcIiArIHByZXNldC50ZXN0ICsgXCIpKCg/OlxcXFwvfFxcXFxzfDopKFswLTl8XFxcXC58X10rKSk/XCIsIHVzZXJBZ2VudCk7XG5cbiAgICBpZiAoIXJlc3VsdCB8fCBwcmVzZXQuYnJhbmQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB1c2VyUHJlc2V0ID0gcHJlc2V0O1xuICAgIHZlcnNpb24gPSByZXN1bHRbM10gfHwgXCItMVwiO1xuXG4gICAgaWYgKHByZXNldC52ZXJzaW9uQWxpYXMpIHtcbiAgICAgIHZlcnNpb24gPSBwcmVzZXQudmVyc2lvbkFsaWFzO1xuICAgIH0gZWxzZSBpZiAocHJlc2V0LnZlcnNpb25UZXN0KSB7XG4gICAgICB2ZXJzaW9uID0gZmluZFZlcnNpb24ocHJlc2V0LnZlcnNpb25UZXN0LnRvTG93ZXJDYXNlKCksIHVzZXJBZ2VudCkgfHwgdmVyc2lvbjtcbiAgICB9XG5cbiAgICB2ZXJzaW9uID0gY29udmVydFZlcnNpb24odmVyc2lvbik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHByZXNldDogdXNlclByZXNldCxcbiAgICB2ZXJzaW9uOiB2ZXJzaW9uXG4gIH07XG59XG5mdW5jdGlvbiBmaW5kUHJlc2V0QnJhbmQocHJlc2V0cywgYnJhbmRzKSB7XG4gIHZhciBicmFuZEluZm8gPSB7XG4gICAgYnJhbmQ6IFwiXCIsXG4gICAgdmVyc2lvbjogXCItMVwiXG4gIH07XG4gIHNvbWUocHJlc2V0cywgZnVuY3Rpb24gKHByZXNldCkge1xuICAgIHZhciByZXN1bHQgPSBmaW5kQnJhbmQoYnJhbmRzLCBwcmVzZXQpO1xuXG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBicmFuZEluZm8uYnJhbmQgPSBwcmVzZXQuaWQ7XG4gICAgYnJhbmRJbmZvLnZlcnNpb24gPSBwcmVzZXQudmVyc2lvbkFsaWFzIHx8IHJlc3VsdC52ZXJzaW9uO1xuICAgIHJldHVybiBicmFuZEluZm8udmVyc2lvbiAhPT0gXCItMVwiO1xuICB9KTtcbiAgcmV0dXJuIGJyYW5kSW5mbztcbn1cbmZ1bmN0aW9uIGZpbmRCcmFuZChicmFuZHMsIHByZXNldCkge1xuICByZXR1cm4gZmluZChicmFuZHMsIGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBicmFuZCA9IF9hLmJyYW5kO1xuICAgIHJldHVybiBleGVjUmVnRXhwKFwiXCIgKyBwcmVzZXQudGVzdCwgYnJhbmQudG9Mb3dlckNhc2UoKSk7XG4gIH0pO1xufVxuXG52YXIgQlJPV1NFUl9QUkVTRVRTID0gW3tcbiAgdGVzdDogXCJwaGFudG9tanNcIixcbiAgaWQ6IFwicGhhbnRvbWpzXCJcbn0sIHtcbiAgdGVzdDogXCJ3aGFsZVwiLFxuICBpZDogXCJ3aGFsZVwiXG59LCB7XG4gIHRlc3Q6IFwiZWRnaW9zfGVkZ2V8ZWRnXCIsXG4gIGlkOiBcImVkZ2VcIlxufSwge1xuICB0ZXN0OiBcIm1zaWV8dHJpZGVudHx3aW5kb3dzIHBob25lXCIsXG4gIGlkOiBcImllXCIsXG4gIHZlcnNpb25UZXN0OiBcImllbW9iaWxlfG1zaWV8cnZcIlxufSwge1xuICB0ZXN0OiBcIm1pdWlicm93c2VyXCIsXG4gIGlkOiBcIm1pdWkgYnJvd3NlclwiXG59LCB7XG4gIHRlc3Q6IFwic2Ftc3VuZ2Jyb3dzZXJcIixcbiAgaWQ6IFwic2Ftc3VuZyBpbnRlcm5ldFwiXG59LCB7XG4gIHRlc3Q6IFwic2Ftc3VuZ1wiLFxuICBpZDogXCJzYW1zdW5nIGludGVybmV0XCIsXG4gIHZlcnNpb25UZXN0OiBcInZlcnNpb25cIlxufSwge1xuICB0ZXN0OiBcImNocm9tZXxjcmlvc1wiLFxuICBpZDogXCJjaHJvbWVcIlxufSwge1xuICB0ZXN0OiBcImZpcmVmb3h8Znhpb3NcIixcbiAgaWQ6IFwiZmlyZWZveFwiXG59LCB7XG4gIHRlc3Q6IFwiYW5kcm9pZFwiLFxuICBpZDogXCJhbmRyb2lkIGJyb3dzZXJcIixcbiAgdmVyc2lvblRlc3Q6IFwidmVyc2lvblwiXG59LCB7XG4gIHRlc3Q6IFwic2FmYXJpfGlwaG9uZXxpcGFkfGlwb2RcIixcbiAgaWQ6IFwic2FmYXJpXCIsXG4gIHZlcnNpb25UZXN0OiBcInZlcnNpb25cIlxufV07IC8vIGNocm9taXVtJ3MgZW5naW5lKGJsaW5rKSBpcyBiYXNlZCBvbiBhcHBsZXdlYmtpdCA1MzcuMzYuXG5cbnZhciBDSFJPTUlVTV9QUkVTRVRTID0gW3tcbiAgdGVzdDogXCIoPz0uKmFwcGxld2Via2l0Lyg1M1swLTddfDVbMC0yXXxbMC00XSkpKD89LipcXFxcc2Nocm9tZSlcIixcbiAgaWQ6IFwiY2hyb21lXCIsXG4gIHZlcnNpb25UZXN0OiBcImNocm9tZVwiXG59LCB7XG4gIHRlc3Q6IFwiY2hyb21pdW1cIixcbiAgaWQ6IFwiY2hyb21lXCJcbn0sIHtcbiAgdGVzdDogXCJ3aGFsZVwiLFxuICBpZDogXCJjaHJvbWVcIixcbiAgdmVyc2lvbkFsaWFzOiBcIi0xXCIsXG4gIGJyYW5kOiB0cnVlXG59XTtcbnZhciBXRUJLSVRfUFJFU0VUUyA9IFt7XG4gIHRlc3Q6IFwiYXBwbGV3ZWJraXRcIixcbiAgaWQ6IFwid2Via2l0XCIsXG4gIHZlcnNpb25UZXN0OiBcImFwcGxld2Via2l0fHNhZmFyaVwiXG59XTtcbnZhciBXRUJWSUVXX1BSRVNFVFMgPSBbe1xuICB0ZXN0OiBcIig/PShpcGhvbmV8aXBhZCkpKD8hKC4qdmVyc2lvbikpXCIsXG4gIGlkOiBcIndlYnZpZXdcIlxufSwge1xuICB0ZXN0OiBcIig/PShhbmRyb2lkfGlwaG9uZXxpcGFkKSkoPz0uKihuYXZlcnxkYXVtfDsgd3YpKVwiLFxuICBpZDogXCJ3ZWJ2aWV3XCJcbn0sIHtcbiAgLy8gdGVzdCB3ZWJ2aWV3XG4gIHRlc3Q6IFwid2Vidmlld1wiLFxuICBpZDogXCJ3ZWJ2aWV3XCJcbn1dO1xudmFyIE9TX1BSRVNFVFMgPSBbe1xuICB0ZXN0OiBcIndpbmRvd3MgcGhvbmVcIixcbiAgaWQ6IFwid2luZG93cyBwaG9uZVwiXG59LCB7XG4gIHRlc3Q6IFwid2luZG93cyAyMDAwXCIsXG4gIGlkOiBcIndpbmRvd1wiLFxuICB2ZXJzaW9uQWxpYXM6IFwiNS4wXCJcbn0sIHtcbiAgdGVzdDogXCJ3aW5kb3dzIG50XCIsXG4gIGlkOiBcIndpbmRvd1wiXG59LCB7XG4gIHRlc3Q6IFwiaXBob25lfGlwYWR8aXBvZFwiLFxuICBpZDogXCJpb3NcIixcbiAgdmVyc2lvblRlc3Q6IFwiaXBob25lIG9zfGNwdSBvc1wiXG59LCB7XG4gIHRlc3Q6IFwibWFjIG9zIHhcIixcbiAgaWQ6IFwibWFjXCJcbn0sIHtcbiAgdGVzdDogXCJhbmRyb2lkXCIsXG4gIGlkOiBcImFuZHJvaWRcIlxufSwge1xuICB0ZXN0OiBcInRpemVuXCIsXG4gIGlkOiBcInRpemVuXCJcbn0sIHtcbiAgdGVzdDogXCJ3ZWJvc3x3ZWIwc1wiLFxuICBpZDogXCJ3ZWJvc1wiXG59XTtcblxuZnVuY3Rpb24gcGFyc2VVc2VyQWdlbnREYXRhKG9zRGF0YSkge1xuICB2YXIgdXNlckFnZW50RGF0YSA9IG5hdmlnYXRvci51c2VyQWdlbnREYXRhO1xuICB2YXIgYnJhbmRzID0gKHVzZXJBZ2VudERhdGEudWFMaXN0IHx8IHVzZXJBZ2VudERhdGEuYnJhbmRzKS5zbGljZSgpO1xuICB2YXIgaXNNb2JpbGUgPSB1c2VyQWdlbnREYXRhLm1vYmlsZSB8fCBmYWxzZTtcbiAgdmFyIGZpcnN0QnJhbmQgPSBicmFuZHNbMF07XG4gIHZhciBicm93c2VyID0ge1xuICAgIG5hbWU6IGZpcnN0QnJhbmQuYnJhbmQsXG4gICAgdmVyc2lvbjogZmlyc3RCcmFuZC52ZXJzaW9uLFxuICAgIG1ham9yVmVyc2lvbjogLTEsXG4gICAgd2Via2l0OiBmYWxzZSxcbiAgICB3ZWJraXRWZXJzaW9uOiBcIi0xXCIsXG4gICAgY2hyb21pdW06IGZhbHNlLFxuICAgIGNocm9taXVtVmVyc2lvbjogXCItMVwiLFxuICAgIHdlYnZpZXc6ICEhZmluZFByZXNldEJyYW5kKFdFQlZJRVdfUFJFU0VUUywgYnJhbmRzKS5icmFuZFxuICB9O1xuICB2YXIgb3MgPSB7XG4gICAgbmFtZTogXCJ1bmtub3duXCIsXG4gICAgdmVyc2lvbjogXCItMVwiLFxuICAgIG1ham9yVmVyc2lvbjogLTFcbiAgfTtcbiAgYnJvd3Nlci53ZWJraXQgPSAhYnJvd3Nlci5jaHJvbWl1bSAmJiBzb21lKFdFQktJVF9QUkVTRVRTLCBmdW5jdGlvbiAocHJlc2V0KSB7XG4gICAgcmV0dXJuIGZpbmRCcmFuZChicmFuZHMsIHByZXNldCk7XG4gIH0pO1xuICB2YXIgY2hyb21pdW1CcmFuZCA9IGZpbmRQcmVzZXRCcmFuZChDSFJPTUlVTV9QUkVTRVRTLCBicmFuZHMpO1xuICBicm93c2VyLmNocm9taXVtID0gISFjaHJvbWl1bUJyYW5kLmJyYW5kO1xuICBicm93c2VyLmNocm9taXVtVmVyc2lvbiA9IGNocm9taXVtQnJhbmQudmVyc2lvbjtcblxuICBpZiAoIWJyb3dzZXIuY2hyb21pdW0pIHtcbiAgICB2YXIgd2Via2l0QnJhbmQgPSBmaW5kUHJlc2V0QnJhbmQoV0VCS0lUX1BSRVNFVFMsIGJyYW5kcyk7XG4gICAgYnJvd3Nlci53ZWJraXQgPSAhIXdlYmtpdEJyYW5kLmJyYW5kO1xuICAgIGJyb3dzZXIud2Via2l0VmVyc2lvbiA9IHdlYmtpdEJyYW5kLnZlcnNpb247XG4gIH1cblxuICBpZiAob3NEYXRhKSB7XG4gICAgdmFyIHBsYXRmb3JtXzEgPSBvc0RhdGEucGxhdGZvcm0udG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgcmVzdWx0ID0gZmluZChPU19QUkVTRVRTLCBmdW5jdGlvbiAocHJlc2V0KSB7XG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cChcIlwiICsgcHJlc2V0LnRlc3QsIFwiZ1wiKS5leGVjKHBsYXRmb3JtXzEpO1xuICAgIH0pO1xuICAgIG9zLm5hbWUgPSByZXN1bHQgPyByZXN1bHQuaWQgOiBwbGF0Zm9ybV8xO1xuICAgIG9zLnZlcnNpb24gPSBvc0RhdGEucGxhdGZvcm1WZXJzaW9uO1xuICB9XG5cbiAgdmFyIGJyb3dzZXJCcmFuZCA9IGZpbmRQcmVzZXRCcmFuZChCUk9XU0VSX1BSRVNFVFMsIGJyYW5kcyk7XG5cbiAgaWYgKGJyb3dzZXJCcmFuZC5icmFuZCkge1xuICAgIGJyb3dzZXIubmFtZSA9IGJyb3dzZXJCcmFuZC5icmFuZDtcbiAgICBicm93c2VyLnZlcnNpb24gPSBvc0RhdGEgPyBvc0RhdGEudWFGdWxsVmVyc2lvbiA6IGJyb3dzZXJCcmFuZC52ZXJzaW9uO1xuICB9XG5cbiAgaWYgKG5hdmlnYXRvci5wbGF0Zm9ybSA9PT0gXCJMaW51eCBhcm12OGxcIikge1xuICAgIG9zLm5hbWUgPSBcImFuZHJvaWRcIjtcbiAgfSBlbHNlIGlmIChicm93c2VyLndlYmtpdCkge1xuICAgIG9zLm5hbWUgPSBpc01vYmlsZSA/IFwiaW9zXCIgOiBcIm1hY1wiO1xuICB9XG5cbiAgaWYgKG9zLm5hbWUgPT09IFwiaW9zXCIgJiYgYnJvd3Nlci53ZWJ2aWV3KSB7XG4gICAgYnJvd3Nlci52ZXJzaW9uID0gXCItMVwiO1xuICB9XG5cbiAgb3MudmVyc2lvbiA9IGNvbnZlcnRWZXJzaW9uKG9zLnZlcnNpb24pO1xuICBicm93c2VyLnZlcnNpb24gPSBjb252ZXJ0VmVyc2lvbihicm93c2VyLnZlcnNpb24pO1xuICBvcy5tYWpvclZlcnNpb24gPSBwYXJzZUludChvcy52ZXJzaW9uLCAxMCk7XG4gIGJyb3dzZXIubWFqb3JWZXJzaW9uID0gcGFyc2VJbnQoYnJvd3Nlci52ZXJzaW9uLCAxMCk7XG4gIHJldHVybiB7XG4gICAgYnJvd3NlcjogYnJvd3NlcixcbiAgICBvczogb3MsXG4gICAgaXNNb2JpbGU6IGlzTW9iaWxlLFxuICAgIGlzSGludHM6IHRydWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VVc2VyQWdlbnQodXNlckFnZW50KSB7XG4gIHZhciBuZXh0QWdlbnQgPSBnZXRVc2VyQWdlbnQodXNlckFnZW50KTtcbiAgdmFyIGlzTW9iaWxlID0gISEvbW9iaS9nLmV4ZWMobmV4dEFnZW50KTtcbiAgdmFyIGJyb3dzZXIgPSB7XG4gICAgbmFtZTogXCJ1bmtub3duXCIsXG4gICAgdmVyc2lvbjogXCItMVwiLFxuICAgIG1ham9yVmVyc2lvbjogLTEsXG4gICAgd2VidmlldzogISFmaW5kUHJlc2V0KFdFQlZJRVdfUFJFU0VUUywgbmV4dEFnZW50KS5wcmVzZXQsXG4gICAgY2hyb21pdW06IGZhbHNlLFxuICAgIGNocm9taXVtVmVyc2lvbjogXCItMVwiLFxuICAgIHdlYmtpdDogZmFsc2UsXG4gICAgd2Via2l0VmVyc2lvbjogXCItMVwiXG4gIH07XG4gIHZhciBvcyA9IHtcbiAgICBuYW1lOiBcInVua25vd25cIixcbiAgICB2ZXJzaW9uOiBcIi0xXCIsXG4gICAgbWFqb3JWZXJzaW9uOiAtMVxuICB9O1xuXG4gIHZhciBfYSA9IGZpbmRQcmVzZXQoQlJPV1NFUl9QUkVTRVRTLCBuZXh0QWdlbnQpLFxuICAgICAgYnJvd3NlclByZXNldCA9IF9hLnByZXNldCxcbiAgICAgIGJyb3dzZXJWZXJzaW9uID0gX2EudmVyc2lvbjtcblxuICB2YXIgX2IgPSBmaW5kUHJlc2V0KE9TX1BSRVNFVFMsIG5leHRBZ2VudCksXG4gICAgICBvc1ByZXNldCA9IF9iLnByZXNldCxcbiAgICAgIG9zVmVyc2lvbiA9IF9iLnZlcnNpb247XG5cbiAgdmFyIGNocm9taXVtUHJlc2V0ID0gZmluZFByZXNldChDSFJPTUlVTV9QUkVTRVRTLCBuZXh0QWdlbnQpO1xuICBicm93c2VyLmNocm9taXVtID0gISFjaHJvbWl1bVByZXNldC5wcmVzZXQ7XG4gIGJyb3dzZXIuY2hyb21pdW1WZXJzaW9uID0gY2hyb21pdW1QcmVzZXQudmVyc2lvbjtcblxuICBpZiAoIWJyb3dzZXIuY2hyb21pdW0pIHtcbiAgICB2YXIgd2Via2l0UHJlc2V0ID0gZmluZFByZXNldChXRUJLSVRfUFJFU0VUUywgbmV4dEFnZW50KTtcbiAgICBicm93c2VyLndlYmtpdCA9ICEhd2Via2l0UHJlc2V0LnByZXNldDtcbiAgICBicm93c2VyLndlYmtpdFZlcnNpb24gPSB3ZWJraXRQcmVzZXQudmVyc2lvbjtcbiAgfVxuXG4gIGlmIChvc1ByZXNldCkge1xuICAgIG9zLm5hbWUgPSBvc1ByZXNldC5pZDtcbiAgICBvcy52ZXJzaW9uID0gb3NWZXJzaW9uO1xuICAgIG9zLm1ham9yVmVyc2lvbiA9IHBhcnNlSW50KG9zVmVyc2lvbiwgMTApO1xuICB9XG5cbiAgaWYgKGJyb3dzZXJQcmVzZXQpIHtcbiAgICBicm93c2VyLm5hbWUgPSBicm93c2VyUHJlc2V0LmlkO1xuICAgIGJyb3dzZXIudmVyc2lvbiA9IGJyb3dzZXJWZXJzaW9uO1xuXG4gICAgaWYgKGJyb3dzZXIud2VidmlldyAmJiBvcy5uYW1lID09PSBcImlvc1wiICYmIGJyb3dzZXIubmFtZSAhPT0gXCJzYWZhcmlcIikge1xuICAgICAgYnJvd3Nlci53ZWJ2aWV3ID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgYnJvd3Nlci5tYWpvclZlcnNpb24gPSBwYXJzZUludChicm93c2VyLnZlcnNpb24sIDEwKTtcbiAgcmV0dXJuIHtcbiAgICBicm93c2VyOiBicm93c2VyLFxuICAgIG9zOiBvcyxcbiAgICBpc01vYmlsZTogaXNNb2JpbGUsXG4gICAgaXNIaW50czogZmFsc2VcbiAgfTtcbn1cblxuLyoqXG4gKiBAbmFtZXNwYWNlIGVnLmFnZW50XG4gKi9cblxuLyoqXG4qIEV4dHJhY3RzIGFjY3VhdGUgYnJvd3NlciBhbmQgb3BlcmF0aW5nIHN5c3RlbSBpbmZvcm1hdGlvbiBmcm9tIHRoZSB1c2VyIGFnZW50IHN0cmluZyBvciBjbGllbnQgaGludHMuXG4qIEBrbyDsnKDsoIAg7JeQ7J207KCE7Yq4IOusuOyekOyXtCDrmJDripQgY2xpZW50IGhpbnRz7JeQ7IScIOygle2Zle2VnCDruIzrnbzsmrDsoIDsmYAg7Jq07JiB7LK07KCcIOygleuztOulvCDstpTstpztlZzri6QuXG4qIEBmdW5jdGlvbiBlZy5hZ2VudCNnZXRBY2N1cmF0ZUFnZW50XG4qIEBwYXJhbSAtIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGdldCB0aGUgYWNjdWF0ZSBhZ2VudCA8a28+7KCV7ZmV7ZWcIOyXkOydtOyghO2KuOulvCDqsIDsoLjsmKTquLAg7JyE7ZWcIGNhbGxiYWNrIO2VqOyImDwva28+XG4qIEByZXR1cm4gLSBnZXQgdGhlIGFjY3VhdGUgYWdlbnQgcHJvbWlzZS4gSWYgUHJvbWlzZSBhcmUgbm90IHN1cHBvcnRlZCwgbnVsbCBpcyByZXR1cm5lZC4gPGtvPiDsoJXtmZXtlZwg7JeQ7J207KCE7Yq4IHByb21pc2Xrpbwg6rCA7KC47Jio64ukLiBQcm9taXNl66W8IOyngOybkCDtlZjsp4Ag7JWK64qUIOqyveyasCwgbnVsbOydhCDrsJjtmZjtlZzri6QuIDwva28+XG4qIEBleGFtcGxlXG5pbXBvcnQgeyBnZXRBY2N1cmF0ZUFnZW50IH0gZnJvbSBcIkBlZ2pzL2FnZW50XCI7XG4vLyBlZy5hZ2VudC5nZXRBY2N1cmF0ZUFnZW50KClcbmdldEFjY3VyYXRlQWdlbnQoKS50aGVuKGFnZW50ID0+IHtcbiAgIGNvbnN0IHsgb3MsIGJyb3dzZXIsIGlzTW9iaWxlIH0gPSBhZ2VudDtcbn0pO1xuZ2V0QWNjdXJhdGVBZ2VudChhZ2VudCA9PiB7XG4gICAgY29uc3QgeyBvcywgYnJvd3NlciwgaXNNb2JpbGUgfSA9IGFnZW50O1xufSk7XG4qL1xuXG5mdW5jdGlvbiBnZXRBY2N1cmF0ZUFnZW50KGNhbGxiYWNrKSB7XG4gIGlmIChoYXNVc2VyQWdlbnREYXRhKCkpIHtcbiAgICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGEuZ2V0SGlnaEVudHJvcHlWYWx1ZXMoW1wiYXJjaGl0ZWN0dXJlXCIsIFwibW9kZWxcIiwgXCJwbGF0Zm9ybVwiLCBcInBsYXRmb3JtVmVyc2lvblwiLCBcInVhRnVsbFZlcnNpb25cIl0pLnRoZW4oZnVuY3Rpb24gKGluZm8pIHtcbiAgICAgIHZhciBhZ2VudEluZm8gPSBwYXJzZVVzZXJBZ2VudERhdGEoaW5mbyk7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhhZ2VudEluZm8pO1xuICAgICAgcmV0dXJuIGFnZW50SW5mbztcbiAgICB9KTtcbiAgfVxuXG4gIGNhbGxiYWNrICYmIGNhbGxiYWNrKGFnZW50KCkpO1xuXG4gIGlmICh0eXBlb2YgUHJvbWlzZSA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUHJvbWlzZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShhZ2VudCgpKTtcbn1cbi8qKlxuICogRXh0cmFjdHMgYnJvd3NlciBhbmQgb3BlcmF0aW5nIHN5c3RlbSBpbmZvcm1hdGlvbiBmcm9tIHRoZSB1c2VyIGFnZW50IHN0cmluZy5cbiAqIEBrbyDsnKDsoIAg7JeQ7J207KCE7Yq4IOusuOyekOyXtOyXkOyEnCDruIzrnbzsmrDsoIDsmYAg7Jq07JiB7LK07KCcIOygleuztOulvCDstpTstpztlZzri6QuXG4gKiBAZnVuY3Rpb24gZWcuYWdlbnQjYWdlbnRcbiAqIEBwYXJhbSAtIHVzZXIgYWdlbnQgc3RyaW5nIHRvIHBhcnNlIDxrbz7tjIzsi7HtlaAg7Jyg7KCA7JeQ7J207KCE7Yq4IOusuOyekOyXtDwva28+XG4gKiBAcmV0dXJuIC0gYWdlbnQgSW5mbyA8a28+IOyXkOydtOyghO2KuCDsoJXrs7QgPC9rbz5cbiAqIEBleGFtcGxlXG5pbXBvcnQgYWdlbnQgZnJvbSBcIkBlZ2pzL2FnZW50XCI7XG4vLyBlZy5hZ2VudCgpO1xuY29uc3QgeyBvcywgYnJvd3NlciwgaXNNb2JpbGUgfSA9IGFnZW50KCk7XG4gKi9cblxuZnVuY3Rpb24gYWdlbnQodXNlckFnZW50KSB7XG4gIGlmICh0eXBlb2YgdXNlckFnZW50ID09PSBcInVuZGVmaW5lZFwiICYmIGhhc1VzZXJBZ2VudERhdGEoKSkge1xuICAgIHJldHVybiBwYXJzZVVzZXJBZ2VudERhdGEoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGFyc2VVc2VyQWdlbnQodXNlckFnZW50KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBhZ2VudDtcbmV4cG9ydCB7IGdldEFjY3VyYXRlQWdlbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFnZW50LmVzbS5qcy5tYXBcbiIsIi8qXG5Db3B5cmlnaHQgKGMpIDIwMTktcHJlc2VudCBOQVZFUiBDb3JwLlxubmFtZTogQGVnanMvY2hpbGRyZW4tZGlmZmVyXG5saWNlbnNlOiBNSVRcbmF1dGhvcjogTkFWRVIgQ29ycC5cbnJlcG9zaXRvcnk6IGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9lZ2pzLWNoaWxkcmVuLWRpZmZlclxudmVyc2lvbjogMS4wLjFcbiovXG5pbXBvcnQgTGlzdERpZmZlciwgeyBkaWZmIGFzIGRpZmYkMSB9IGZyb20gJ0BlZ2pzL2xpc3QtZGlmZmVyJztcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7XG4gICAgX19wcm90b19fOiBbXVxuICB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBkLl9fcHJvdG9fXyA9IGI7XG4gIH0gfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgfTtcblxuICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbn07XG5cbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XG4gIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cbiAgZnVuY3Rpb24gX18oKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7XG4gIH1cblxuICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59XG5cbi8qXG5lZ2pzLWNoaWxkcmVuLWRpZmZlclxuQ29weXJpZ2h0IChjKSAyMDE5LXByZXNlbnQgTkFWRVIgQ29ycC5cbk1JVCBsaWNlbnNlXG4qL1xudmFyIGZpbmRLZXlDYWxsYmFjayA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IHVuZGVmaW5lZCA6IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNoaWxkcmVuQ291bnQgPSAwO1xuICByZXR1cm4gZnVuY3Rpb24gKGVsKSB7XG4gICAgcmV0dXJuIGVsLl9fRElGRl9LRVlfXyB8fCAoZWwuX19ESUZGX0tFWV9fID0gKytjaGlsZHJlbkNvdW50KTtcbiAgfTtcbn0oKTtcblxuLyoqXG4gKiBBIG1vZHVsZSB0aGF0IGNoZWNrcyBkaWZmIHdoZW4gY2hpbGQgYXJlIGFkZGVkLCByZW1vdmVkLCBvciBjaGFuZ2VkIC5cbiAqIEBrbyDsnpDsi50g64W465Oc65Ok7JeQ7IScIOyekOyLnSDrhbjrk5zqsIAg7LaU6rCA65CY6rGw64KYIOyCreygnOuQmOqxsOuCmCDsiJzshJzqsIAg67OA6rK965CcIOyCrO2VreydhCDssrTtgaztlZjripQg66qo65OI7J6F64uI64ukLlxuICogQG1lbWJlcm9mIGVnXG4gKiBAZXh0ZW5kcyBlZy5MaXN0RGlmZmVyXG4gKi9cblxudmFyIENoaWxkcmVuRGlmZmVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKENoaWxkcmVuRGlmZmVyLCBfc3VwZXIpO1xuICAvKipcbiAgICogQHBhcmFtIC0gSW5pdGlhbGl6aW5nIENoaWxkcmVuIDxrbz4g7LSI6riwIOyEpOygle2VoCDsnpDsi50g64W465Oc65OkPC9rbz5cbiAgICovXG5cblxuICBmdW5jdGlvbiBDaGlsZHJlbkRpZmZlcihsaXN0KSB7XG4gICAgaWYgKGxpc3QgPT09IHZvaWQgMCkge1xuICAgICAgbGlzdCA9IFtdO1xuICAgIH1cblxuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBsaXN0LCBmaW5kS2V5Q2FsbGJhY2spIHx8IHRoaXM7XG4gIH1cblxuICByZXR1cm4gQ2hpbGRyZW5EaWZmZXI7XG59KExpc3REaWZmZXIpO1xuXG4vKlxuZWdqcy1jaGlsZHJlbi1kaWZmZXJcbkNvcHlyaWdodCAoYykgMjAxOS1wcmVzZW50IE5BVkVSIENvcnAuXG5NSVQgbGljZW5zZVxuKi9cbi8qKlxuICpcbiAqIEBtZW1iZXJvZiBlZy5DaGlsZHJlbkRpZmZlclxuICogQHN0YXRpY1xuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0gLSBQcmV2aW91cyBMaXN0IDxrbz4g7J207KCEIOuqqeuhnSA8L2tvPlxuICogQHBhcmFtIC0gTGlzdCB0byBVcGRhdGUgPGtvPiDsl4XrjbDsnbTtirgg7ZWgIOuqqeuhnSA8L2tvPlxuICogQHJldHVybiAtIFJldHVybnMgdGhlIGRpZmYgYmV0d2VlbiBgcHJldkxpc3RgIGFuZCBgbGlzdGAgPGtvPiBgcHJldkxpc3Rg7JmAIGBsaXN0YOydmCDri6Trpbgg7KCQ7J2EIOuwmO2ZmO2VnOuLpC48L2tvPlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGRpZmYgfSBmcm9tIFwiQGVnanMvY2hpbGRyZW4tZGlmZmVyXCI7XG4gKiAvLyBzY3JpcHQgPT4gZWcuQ2hpbGRyZW5EaWZmZXIuZGlmZlxuICogY29uc3QgcmVzdWx0ID0gZGlmZihbMCwgMSwgMiwgMywgNCwgNV0sIFs3LCA4LCAwLCA0LCAzLCA2LCAyLCAxXSk7XG4gKiAvLyBMaXN0IGJlZm9yZSB1cGRhdGVcbiAqIC8vIFsxLCAyLCAzLCA0LCA1XVxuICogY29uc29sZS5sb2cocmVzdWx0LnByZXZMaXN0KTtcbiAqIC8vIFVwZGF0ZWQgbGlzdFxuICogLy8gWzQsIDMsIDYsIDIsIDFdXG4gKiBjb25zb2xlLmxvZyhyZXN1bHQubGlzdCk7XG4gKiAvLyBJbmRleCBhcnJheSBvZiB2YWx1ZXMgYWRkZWQgdG8gYGxpc3RgXG4gKiAvLyBbMCwgMSwgNV1cbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5hZGRlZCk7XG4gKiAvLyBJbmRleCBhcnJheSBvZiB2YWx1ZXMgcmVtb3ZlZCBpbiBgcHJldkxpc3RgXG4gKiAvLyBbNV1cbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5yZW1vdmVkKTtcbiAqIC8vIEFuIGFycmF5IG9mIGluZGV4IHBhaXJzIG9mIGBwcmV2TGlzdGAgYW5kIGBsaXN0YCB3aXRoIGRpZmZlcmVudCBpbmRleGVzIGZyb20gYHByZXZMaXN0YCBhbmQgYGxpc3RgXG4gKiAvLyBbWzAsIDJdLCBbNCwgM10sIFszLCA0XSwgWzIsIDZdLCBbMSwgN11dXG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuY2hhbmdlZCk7XG4gKiAvLyBUaGUgc3Vic2V0IG9mIGBjaGFuZ2VkYCBhbmQgYW4gYXJyYXkgb2YgaW5kZXggcGFpcnMgdGhhdCBtb3ZlZCBkYXRhIGRpcmVjdGx5LiBJbmRpY2F0ZSBhbiBhcnJheSBvZiBhYnNvbHV0ZSBpbmRleCBwYWlycyBvZiBgb3JkZXJlZGAuKEZvcm1hdHRlZCBieTogQXJyYXk8W2luZGV4IG9mIHByZXZMaXN0LCBpbmRleCBvZiBsaXN0XT4pXG4gKiAvLyBbWzQsIDNdLCBbMywgNF0sIFsyLCA2XV1cbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5wdXJlQ2hhbmdlZCk7XG4gKiAvLyBBbiBhcnJheSBvZiBpbmRleCBwYWlycyB0byBiZSBgb3JkZXJlZGAgdGhhdCBjYW4gc3luY2hyb25pemUgYGxpc3RgIGJlZm9yZSBhZGRpbmcgZGF0YS4gKEZvcm1hdHRlZCBieTogQXJyYXk8W3ByZXZJbmRleCwgbmV4dEluZGV4XT4pXG4gKiAvLyBbWzQsIDFdLCBbNCwgMl0sIFs0LCAzXV1cbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5vcmRlcmVkKTtcbiAqIC8vIEFuIGFycmF5IG9mIGluZGV4IHBhaXJzIG9mIGBwcmV2TGlzdGAgYW5kIGBsaXN0YCB0aGF0IGhhdmUgbm90IGJlZW4gYWRkZWQvcmVtb3ZlZCBzbyBkYXRhIGlzIHByZXNlcnZlZFxuICogLy8gW1swLCAyXSwgWzQsIDNdLCBbMywgNF0sIFsyLCA2XSwgWzEsIDddXVxuICogY29uc29sZS5sb2cocmVzdWx0Lm1haW50YWluZWQpO1xuICovXG5cbmZ1bmN0aW9uIGRpZmYocHJldkxpc3QsIGxpc3QpIHtcbiAgcmV0dXJuIGRpZmYkMShwcmV2TGlzdCwgbGlzdCwgZmluZEtleUNhbGxiYWNrKTtcbn1cblxuLypcbmVnanMtY2hpbGRyZW4tZGlmZmVyXG5Db3B5cmlnaHQgKGMpIDIwMTktcHJlc2VudCBOQVZFUiBDb3JwLlxuTUlUIGxpY2Vuc2VcbiovXG5cbmV4cG9ydCBkZWZhdWx0IENoaWxkcmVuRGlmZmVyO1xuZXhwb3J0IHsgZGlmZiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hpbGRyZW4tZGlmZmVyLmVzbS5qcy5tYXBcbiIsIi8qXG5Db3B5cmlnaHQgKGMpIDIwMTktcHJlc2VudCBOQVZFUiBDb3JwLlxubmFtZTogQGVnanMvbGlzdC1kaWZmZXJcbmxpY2Vuc2U6IE1JVFxuYXV0aG9yOiBOQVZFUiBDb3JwLlxucmVwb3NpdG9yeTogaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2VnanMtbGlzdC1kaWZmZXJcbnZlcnNpb246IDEuMC4wXG4qL1xuLypcbmVnanMtbGlzdC1kaWZmZXJcbkNvcHlyaWdodCAoYykgMjAxOS1wcmVzZW50IE5BVkVSIENvcnAuXG5NSVQgbGljZW5zZVxuKi9cbnZhciBQb2x5TWFwID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUG9seU1hcCgpIHtcbiAgICB0aGlzLmtleXMgPSBbXTtcbiAgICB0aGlzLnZhbHVlcyA9IFtdO1xuICB9XG5cbiAgdmFyIF9fcHJvdG8gPSBQb2x5TWFwLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXNbdGhpcy5rZXlzLmluZGV4T2Yoa2V5KV07XG4gIH07XG5cbiAgX19wcm90by5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBrZXlzID0gdGhpcy5rZXlzO1xuICAgIHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlcztcbiAgICB2YXIgcHJldkluZGV4ID0ga2V5cy5pbmRleE9mKGtleSk7XG4gICAgdmFyIGluZGV4ID0gcHJldkluZGV4ID09PSAtMSA/IGtleXMubGVuZ3RoIDogcHJldkluZGV4O1xuICAgIGtleXNbaW5kZXhdID0ga2V5O1xuICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgfTtcblxuICByZXR1cm4gUG9seU1hcDtcbn0oKTtcblxuLypcbmVnanMtbGlzdC1kaWZmZXJcbkNvcHlyaWdodCAoYykgMjAxOS1wcmVzZW50IE5BVkVSIENvcnAuXG5NSVQgbGljZW5zZVxuKi9cbnZhciBIYXNoTWFwID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSGFzaE1hcCgpIHtcbiAgICB0aGlzLm9iamVjdCA9IHt9O1xuICB9XG5cbiAgdmFyIF9fcHJvdG8gPSBIYXNoTWFwLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5vYmplY3Rba2V5XTtcbiAgfTtcblxuICBfX3Byb3RvLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5vYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9O1xuXG4gIHJldHVybiBIYXNoTWFwO1xufSgpO1xuXG4vKlxuZWdqcy1saXN0LWRpZmZlclxuQ29weXJpZ2h0IChjKSAyMDE5LXByZXNlbnQgTkFWRVIgQ29ycC5cbk1JVCBsaWNlbnNlXG4qL1xudmFyIFNVUFBPUlRfTUFQID0gdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiO1xuXG4vKlxuZWdqcy1saXN0LWRpZmZlclxuQ29weXJpZ2h0IChjKSAyMDE5LXByZXNlbnQgTkFWRVIgQ29ycC5cbk1JVCBsaWNlbnNlXG4qL1xudmFyIExpbmsgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMaW5rKCkge31cblxuICB2YXIgX19wcm90byA9IExpbmsucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8uY29ubmVjdCA9IGZ1bmN0aW9uIChwcmV2TGluaywgbmV4dExpbmspIHtcbiAgICB0aGlzLnByZXYgPSBwcmV2TGluaztcbiAgICB0aGlzLm5leHQgPSBuZXh0TGluaztcbiAgICBwcmV2TGluayAmJiAocHJldkxpbmsubmV4dCA9IHRoaXMpO1xuICAgIG5leHRMaW5rICYmIChuZXh0TGluay5wcmV2ID0gdGhpcyk7XG4gIH07XG5cbiAgX19wcm90by5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIEluIGRvdWJsZSBsaW5rZWQgbGlzdCwgZGljb25uZWN0IHRoZSBpbnRlcmNvbm5lY3RlZCByZWxhdGlvbnNoaXAuXG4gICAgdmFyIHByZXZMaW5rID0gdGhpcy5wcmV2O1xuICAgIHZhciBuZXh0TGluayA9IHRoaXMubmV4dDtcbiAgICBwcmV2TGluayAmJiAocHJldkxpbmsubmV4dCA9IG5leHRMaW5rKTtcbiAgICBuZXh0TGluayAmJiAobmV4dExpbmsucHJldiA9IHByZXZMaW5rKTtcbiAgfTtcblxuICBfX3Byb3RvLmdldEluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsaW5rID0gdGhpcztcbiAgICB2YXIgaW5kZXggPSAtMTtcblxuICAgIHdoaWxlIChsaW5rKSB7XG4gICAgICBsaW5rID0gbGluay5wcmV2O1xuICAgICAgKytpbmRleDtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXg7XG4gIH07XG5cbiAgcmV0dXJuIExpbms7XG59KCk7XG5cbi8qXG5lZ2pzLWxpc3QtZGlmZmVyXG5Db3B5cmlnaHQgKGMpIDIwMTktcHJlc2VudCBOQVZFUiBDb3JwLlxuTUlUIGxpY2Vuc2VcbiovXG5cbmZ1bmN0aW9uIG9yZGVyQ2hhbmdlZChjaGFuZ2VkLCBmaXhlZCkge1xuICAvLyBJdCBpcyByb3VnaGx5IGluIHRoZSBvcmRlciBvZiB0aGVzZSBleGFtcGxlcy5cbiAgLy8gNCwgNiwgMCwgMiwgMSwgMywgNSwgN1xuICB2YXIgZnJvbUxpbmtzID0gW107IC8vIDAsIDEsIDIsIDMsIDQsIDUsIDYsIDdcblxuICB2YXIgdG9MaW5rcyA9IFtdO1xuICBjaGFuZ2VkLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGZyb20gPSBfYVswXSxcbiAgICAgICAgdG8gPSBfYVsxXTtcbiAgICB2YXIgbGluayA9IG5ldyBMaW5rKCk7XG4gICAgZnJvbUxpbmtzW2Zyb21dID0gbGluaztcbiAgICB0b0xpbmtzW3RvXSA9IGxpbms7XG4gIH0pOyAvLyBgZnJvbUxpbmtzYCBhcmUgY29ubmVjdGVkIHRvIGVhY2ggb3RoZXIgYnkgZG91YmxlIGxpbmtlZCBsaXN0LlxuXG4gIGZyb21MaW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5rLCBpKSB7XG4gICAgbGluay5jb25uZWN0KGZyb21MaW5rc1tpIC0gMV0pO1xuICB9KTtcbiAgcmV0dXJuIGNoYW5nZWQuZmlsdGVyKGZ1bmN0aW9uIChfLCBpKSB7XG4gICAgcmV0dXJuICFmaXhlZFtpXTtcbiAgfSkubWFwKGZ1bmN0aW9uIChfYSwgaSkge1xuICAgIHZhciBmcm9tID0gX2FbMF0sXG4gICAgICAgIHRvID0gX2FbMV07XG5cbiAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgIHJldHVybiBbMCwgMF07XG4gICAgfVxuXG4gICAgdmFyIGZyb21MaW5rID0gZnJvbUxpbmtzW2Zyb21dO1xuICAgIHZhciB0b0xpbmsgPSB0b0xpbmtzW3RvIC0gMV07XG4gICAgdmFyIGZyb21JbmRleCA9IGZyb21MaW5rLmdldEluZGV4KCk7IC8vIERpc2Nvbm5lY3QgdGhlIGxpbmsgY29ubmVjdGVkIHRvIGBmcm9tTGlua2AuXG5cbiAgICBmcm9tTGluay5kaXNjb25uZWN0KCk7IC8vIENvbm5lY3QgYGZyb21MaW5rYCB0byB0aGUgcmlnaHQgb2YgYHRvTGlua2AuXG5cbiAgICBpZiAoIXRvTGluaykge1xuICAgICAgZnJvbUxpbmsuY29ubmVjdCh1bmRlZmluZWQsIGZyb21MaW5rc1swXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyb21MaW5rLmNvbm5lY3QodG9MaW5rLCB0b0xpbmsubmV4dCk7XG4gICAgfVxuXG4gICAgdmFyIHRvSW5kZXggPSBmcm9tTGluay5nZXRJbmRleCgpO1xuICAgIHJldHVybiBbZnJvbUluZGV4LCB0b0luZGV4XTtcbiAgfSk7XG59XG5cbnZhciBSZXN1bHQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSZXN1bHQocHJldkxpc3QsIGxpc3QsIGFkZGVkLCByZW1vdmVkLCBjaGFuZ2VkLCBtYWludGFpbmVkLCBjaGFuZ2VkQmVmb3JlQWRkZWQsIGZpeGVkKSB7XG4gICAgdGhpcy5wcmV2TGlzdCA9IHByZXZMaXN0O1xuICAgIHRoaXMubGlzdCA9IGxpc3Q7XG4gICAgdGhpcy5hZGRlZCA9IGFkZGVkO1xuICAgIHRoaXMucmVtb3ZlZCA9IHJlbW92ZWQ7XG4gICAgdGhpcy5jaGFuZ2VkID0gY2hhbmdlZDtcbiAgICB0aGlzLm1haW50YWluZWQgPSBtYWludGFpbmVkO1xuICAgIHRoaXMuY2hhbmdlZEJlZm9yZUFkZGVkID0gY2hhbmdlZEJlZm9yZUFkZGVkO1xuICAgIHRoaXMuZml4ZWQgPSBmaXhlZDtcbiAgfVxuXG4gIHZhciBfX3Byb3RvID0gUmVzdWx0LnByb3RvdHlwZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwib3JkZXJlZFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuY2FjaGVPcmRlcmVkKSB7XG4gICAgICAgIHRoaXMuY2FjdWxhdGVPcmRlcmVkKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNhY2hlT3JkZXJlZDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJwdXJlQ2hhbmdlZFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuY2FjaGVQdXJlQ2hhbmdlZCkge1xuICAgICAgICB0aGlzLmNhY3VsYXRlT3JkZXJlZCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jYWNoZVB1cmVDaGFuZ2VkO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG5cbiAgX19wcm90by5jYWN1bGF0ZU9yZGVyZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9yZGVyZWQgPSBvcmRlckNoYW5nZWQodGhpcy5jaGFuZ2VkQmVmb3JlQWRkZWQsIHRoaXMuZml4ZWQpO1xuICAgIHZhciBjaGFuZ2VkID0gdGhpcy5jaGFuZ2VkO1xuICAgIHZhciBwdXJlQ2hhbmdlZCA9IFtdO1xuICAgIHRoaXMuY2FjaGVPcmRlcmVkID0gb3JkZXJlZC5maWx0ZXIoZnVuY3Rpb24gKF9hLCBpKSB7XG4gICAgICB2YXIgZnJvbSA9IF9hWzBdLFxuICAgICAgICAgIHRvID0gX2FbMV07XG4gICAgICB2YXIgX2IgPSBjaGFuZ2VkW2ldLFxuICAgICAgICAgIGZyb21CZWZvcmUgPSBfYlswXSxcbiAgICAgICAgICB0b0JlZm9yZSA9IF9iWzFdO1xuXG4gICAgICBpZiAoZnJvbSAhPT0gdG8pIHtcbiAgICAgICAgcHVyZUNoYW5nZWQucHVzaChbZnJvbUJlZm9yZSwgdG9CZWZvcmVdKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5jYWNoZVB1cmVDaGFuZ2VkID0gcHVyZUNoYW5nZWQ7XG4gIH07XG5cbiAgcmV0dXJuIFJlc3VsdDtcbn0oKTtcblxuLyoqXG4gKlxuICogQG1lbWJlcm9mIGVnLkxpc3REaWZmZXJcbiAqIEBzdGF0aWNcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIC0gUHJldmlvdXMgTGlzdCA8a28+IOydtOyghCDrqqnroZ0gPC9rbz5cbiAqIEBwYXJhbSAtIExpc3QgdG8gVXBkYXRlIDxrbz4g7JeF642w7J207Yq4IO2VoCDrqqnroZ0gPC9rbz5cbiAqIEBwYXJhbSAtIFRoaXMgY2FsbGJhY2sgZnVuY3Rpb24gcmV0dXJucyB0aGUga2V5IG9mIHRoZSBpdGVtLiA8a28+IOyVhOydtO2FnOydmCDtgqTrpbwg67CY7ZmY7ZWY64qUIOy9nOuwsSDtlajsiJjsnoXri4jri6QuPC9rbz5cbiAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBkaWZmIGJldHdlZW4gYHByZXZMaXN0YCBhbmQgYGxpc3RgIDxrbz4gYHByZXZMaXN0YOyZgCBgbGlzdGDsnZgg64uk66W4IOygkOydhCDrsJjtmZjtlZzri6QuPC9rbz5cbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBkaWZmIH0gZnJvbSBcIkBlZ2pzL2xpc3QtZGlmZmVyXCI7XG4gKiAvLyBzY3JpcHQgPT4gZWcuTGlzdERpZmZlci5kaWZmXG4gKiBjb25zdCByZXN1bHQgPSBkaWZmKFswLCAxLCAyLCAzLCA0LCA1XSwgWzcsIDgsIDAsIDQsIDMsIDYsIDIsIDFdLCBlID0+IGUpO1xuICogLy8gTGlzdCBiZWZvcmUgdXBkYXRlXG4gKiAvLyBbMSwgMiwgMywgNCwgNV1cbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5wcmV2TGlzdCk7XG4gKiAvLyBVcGRhdGVkIGxpc3RcbiAqIC8vIFs0LCAzLCA2LCAyLCAxXVxuICogY29uc29sZS5sb2cocmVzdWx0Lmxpc3QpO1xuICogLy8gSW5kZXggYXJyYXkgb2YgdmFsdWVzIGFkZGVkIHRvIGBsaXN0YFxuICogLy8gWzAsIDEsIDVdXG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuYWRkZWQpO1xuICogLy8gSW5kZXggYXJyYXkgb2YgdmFsdWVzIHJlbW92ZWQgaW4gYHByZXZMaXN0YFxuICogLy8gWzVdXG4gKiBjb25zb2xlLmxvZyhyZXN1bHQucmVtb3ZlZCk7XG4gKiAvLyBBbiBhcnJheSBvZiBpbmRleCBwYWlycyBvZiBgcHJldkxpc3RgIGFuZCBgbGlzdGAgd2l0aCBkaWZmZXJlbnQgaW5kZXhlcyBmcm9tIGBwcmV2TGlzdGAgYW5kIGBsaXN0YFxuICogLy8gW1swLCAyXSwgWzQsIDNdLCBbMywgNF0sIFsyLCA2XSwgWzEsIDddXVxuICogY29uc29sZS5sb2cocmVzdWx0LmNoYW5nZWQpO1xuICogLy8gVGhlIHN1YnNldCBvZiBgY2hhbmdlZGAgYW5kIGFuIGFycmF5IG9mIGluZGV4IHBhaXJzIHRoYXQgbW92ZWQgZGF0YSBkaXJlY3RseS4gSW5kaWNhdGUgYW4gYXJyYXkgb2YgYWJzb2x1dGUgaW5kZXggcGFpcnMgb2YgYG9yZGVyZWRgLihGb3JtYXR0ZWQgYnk6IEFycmF5PFtpbmRleCBvZiBwcmV2TGlzdCwgaW5kZXggb2YgbGlzdF0+KVxuICogLy8gW1s0LCAzXSwgWzMsIDRdLCBbMiwgNl1dXG4gKiBjb25zb2xlLmxvZyhyZXN1bHQucHVyZUNoYW5nZWQpO1xuICogLy8gQW4gYXJyYXkgb2YgaW5kZXggcGFpcnMgdG8gYmUgYG9yZGVyZWRgIHRoYXQgY2FuIHN5bmNocm9uaXplIGBsaXN0YCBiZWZvcmUgYWRkaW5nIGRhdGEuIChGb3JtYXR0ZWQgYnk6IEFycmF5PFtwcmV2SW5kZXgsIG5leHRJbmRleF0+KVxuICogLy8gW1s0LCAxXSwgWzQsIDJdLCBbNCwgM11dXG4gKiBjb25zb2xlLmxvZyhyZXN1bHQub3JkZXJlZCk7XG4gKiAvLyBBbiBhcnJheSBvZiBpbmRleCBwYWlycyBvZiBgcHJldkxpc3RgIGFuZCBgbGlzdGAgdGhhdCBoYXZlIG5vdCBiZWVuIGFkZGVkL3JlbW92ZWQgc28gZGF0YSBpcyBwcmVzZXJ2ZWRcbiAqIC8vIFtbMCwgMl0sIFs0LCAzXSwgWzMsIDRdLCBbMiwgNl0sIFsxLCA3XV1cbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5tYWludGFpbmVkKTtcbiAqL1xuXG5mdW5jdGlvbiBkaWZmKHByZXZMaXN0LCBsaXN0LCBmaW5kS2V5Q2FsbGJhY2spIHtcbiAgdmFyIG1hcENsYXNzID0gU1VQUE9SVF9NQVAgPyBNYXAgOiBmaW5kS2V5Q2FsbGJhY2sgPyBIYXNoTWFwIDogUG9seU1hcDtcblxuICB2YXIgY2FsbGJhY2sgPSBmaW5kS2V5Q2FsbGJhY2sgfHwgZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gZTtcbiAgfTtcblxuICB2YXIgYWRkZWQgPSBbXTtcbiAgdmFyIHJlbW92ZWQgPSBbXTtcbiAgdmFyIG1haW50YWluZWQgPSBbXTtcbiAgdmFyIHByZXZLZXlzID0gcHJldkxpc3QubWFwKGNhbGxiYWNrKTtcbiAgdmFyIGtleXMgPSBsaXN0Lm1hcChjYWxsYmFjayk7XG4gIHZhciBwcmV2S2V5TWFwID0gbmV3IG1hcENsYXNzKCk7XG4gIHZhciBrZXlNYXAgPSBuZXcgbWFwQ2xhc3MoKTtcbiAgdmFyIGNoYW5nZWRCZWZvcmVBZGRlZCA9IFtdO1xuICB2YXIgZml4ZWQgPSBbXTtcbiAgdmFyIHJlbW92ZWRNYXAgPSB7fTtcbiAgdmFyIGNoYW5nZWQgPSBbXTtcbiAgdmFyIGFkZGVkQ291bnQgPSAwO1xuICB2YXIgcmVtb3ZlZENvdW50ID0gMDsgLy8gQWRkIHByZXZLZXlzIGFuZCBrZXlzIHRvIHRoZSBoYXNobWFwLlxuXG4gIHByZXZLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSwgcHJldkxpc3RJbmRleCkge1xuICAgIHByZXZLZXlNYXAuc2V0KGtleSwgcHJldkxpc3RJbmRleCk7XG4gIH0pO1xuICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSwgbGlzdEluZGV4KSB7XG4gICAga2V5TWFwLnNldChrZXksIGxpc3RJbmRleCk7XG4gIH0pOyAvLyBDb21wYXJlIGBwcmV2S2V5c2AgYW5kIGBrZXlzYCBhbmQgYWRkIHRoZW0gdG8gYHJlbW92ZWRgIGlmIHRoZXkgYXJlIG5vdCBpbiBga2V5c2AuXG5cbiAgcHJldktleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5LCBwcmV2TGlzdEluZGV4KSB7XG4gICAgdmFyIGxpc3RJbmRleCA9IGtleU1hcC5nZXQoa2V5KTsgLy8gSW4gcHJldkxpc3QsIGJ1dCBub3QgaW4gbGlzdCwgaXQgaXMgcmVtb3ZlZC5cblxuICAgIGlmICh0eXBlb2YgbGlzdEluZGV4ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICArK3JlbW92ZWRDb3VudDtcbiAgICAgIHJlbW92ZWQucHVzaChwcmV2TGlzdEluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlZE1hcFtsaXN0SW5kZXhdID0gcmVtb3ZlZENvdW50O1xuICAgIH1cbiAgfSk7IC8vIENvbXBhcmUgYHByZXZLZXlzYCBhbmQgYGtleXNgIGFuZCBhZGQgdGhlbSB0byBgYWRkZWRgIGlmIHRoZXkgYXJlIG5vdCBpbiBgcHJldktleXNgLlxuXG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5LCBsaXN0SW5kZXgpIHtcbiAgICB2YXIgcHJldkxpc3RJbmRleCA9IHByZXZLZXlNYXAuZ2V0KGtleSk7IC8vIEluIGxpc3QsIGJ1dCBub3QgaW4gcHJldkxpc3QsIGl0IGlzIGFkZGVkLlxuXG4gICAgaWYgKHR5cGVvZiBwcmV2TGlzdEluZGV4ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBhZGRlZC5wdXNoKGxpc3RJbmRleCk7XG4gICAgICArK2FkZGVkQ291bnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1haW50YWluZWQucHVzaChbcHJldkxpc3RJbmRleCwgbGlzdEluZGV4XSk7XG4gICAgICByZW1vdmVkQ291bnQgPSByZW1vdmVkTWFwW2xpc3RJbmRleF0gfHwgMDtcbiAgICAgIGNoYW5nZWRCZWZvcmVBZGRlZC5wdXNoKFtwcmV2TGlzdEluZGV4IC0gcmVtb3ZlZENvdW50LCBsaXN0SW5kZXggLSBhZGRlZENvdW50XSk7XG4gICAgICBmaXhlZC5wdXNoKGxpc3RJbmRleCA9PT0gcHJldkxpc3RJbmRleCk7XG5cbiAgICAgIGlmIChwcmV2TGlzdEluZGV4ICE9PSBsaXN0SW5kZXgpIHtcbiAgICAgICAgY2hhbmdlZC5wdXNoKFtwcmV2TGlzdEluZGV4LCBsaXN0SW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pOyAvLyBTb3J0IGJ5IGFzY2VuZGluZyBvcmRlciBvZiAndG8obGlzdCdzIGluZGV4KS5cblxuICByZW1vdmVkLnJldmVyc2UoKTtcbiAgcmV0dXJuIG5ldyBSZXN1bHQocHJldkxpc3QsIGxpc3QsIGFkZGVkLCByZW1vdmVkLCBjaGFuZ2VkLCBtYWludGFpbmVkLCBjaGFuZ2VkQmVmb3JlQWRkZWQsIGZpeGVkKTtcbn1cblxuLyoqXG4gKiBBIG1vZHVsZSB0aGF0IGNoZWNrcyBkaWZmIHdoZW4gdmFsdWVzIGFyZSBhZGRlZCwgcmVtb3ZlZCwgb3IgY2hhbmdlZCBpbiBhbiBhcnJheS5cbiAqIEBrbyDrsLDsl7Qg65iQ64qUIOyYpOu4jOygne2KuOyXkOyEnCDqsJLsnbQg7LaU6rCA65CY6rGw64KYIOyCreygnOuQmOqxsOuCmCDsiJzshJzqsIAg67OA6rK97IKs7ZWt7J2EIOyytO2BrO2VmOuKlCDrqqjrk4jsnoXri4jri6QuXG4gKiBAbWVtYmVyb2YgZWdcbiAqL1xuXG52YXIgTGlzdERpZmZlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gLSBJbml0aWFsaXppbmcgRGF0YSBBcnJheS4gPGtvPiDstIjquLAg7ISk7KCV7ZWgIOuNsOydtO2EsCDrsLDsl7QuPC9rbz5cbiAgICogQHBhcmFtIC0gVGhpcyBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm5zIHRoZSBrZXkgb2YgdGhlIGl0ZW0uIDxrbz4g7JWE7J207YWc7J2YIO2CpOulvCDrsJjtmZjtlZjripQg7L2c67CxIO2VqOyImOyeheuLiOuLpC48L2tvPlxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgTGlzdERpZmZlciBmcm9tIFwiQGVnanMvbGlzdC1kaWZmZXJcIjtcbiAgICogLy8gc2NyaXB0ID0+IGVnLkxpc3REaWZmZXJcbiAgICogY29uc3QgZGlmZmVyID0gbmV3IExpc3REaWZmZXIoWzAsIDEsIDIsIDMsIDQsIDVdLCBlID0+IGUpO1xuICAgKiBjb25zdCByZXN1bHQgPSBkaWZmZXIudXBkYXRlKFs3LCA4LCAwLCA0LCAzLCA2LCAyLCAxXSk7XG4gICAqIC8vIExpc3QgYmVmb3JlIHVwZGF0ZVxuICAgKiAvLyBbMSwgMiwgMywgNCwgNV1cbiAgICogY29uc29sZS5sb2cocmVzdWx0LnByZXZMaXN0KTtcbiAgICogLy8gVXBkYXRlZCBsaXN0XG4gICAqIC8vIFs0LCAzLCA2LCAyLCAxXVxuICAgKiBjb25zb2xlLmxvZyhyZXN1bHQubGlzdCk7XG4gICAqIC8vIEluZGV4IGFycmF5IG9mIHZhbHVlcyBhZGRlZCB0byBgbGlzdGAuXG4gICAqIC8vIFswLCAxLCA1XVxuICAgKiBjb25zb2xlLmxvZyhyZXN1bHQuYWRkZWQpO1xuICAgKiAvLyBJbmRleCBhcnJheSBvZiB2YWx1ZXMgcmVtb3ZlZCBpbiBgcHJldkxpc3RgLlxuICAgKiAvLyBbNV1cbiAgICogY29uc29sZS5sb2cocmVzdWx0LnJlbW92ZWQpO1xuICAgKiAvLyBBbiBhcnJheSBvZiBpbmRleCBwYWlycyBvZiBgcHJldkxpc3RgIGFuZCBgbGlzdGAgd2l0aCBkaWZmZXJlbnQgaW5kZXhlcyBmcm9tIGBwcmV2TGlzdGAgYW5kIGBsaXN0YC5cbiAgICogLy8gW1swLCAyXSwgWzQsIDNdLCBbMywgNF0sIFsyLCA2XSwgWzEsIDddXVxuICAgKiBjb25zb2xlLmxvZyhyZXN1bHQuY2hhbmdlZCk7XG4gICAqIC8vIFRoZSBzdWJzZXQgb2YgYGNoYW5nZWRgIGFuZCBhbiBhcnJheSBvZiBpbmRleCBwYWlycyB0aGF0IG1vdmVkIGRhdGEgZGlyZWN0bHkuIEluZGljYXRlIGFuIGFycmF5IG9mIGFic29sdXRlIGluZGV4IHBhaXJzIG9mIGBvcmRlcmVkYC4oRm9ybWF0dGVkIGJ5OiBBcnJheTxbaW5kZXggb2YgcHJldkxpc3QsIGluZGV4IG9mIGxpc3RdPilcbiAgICogLy8gW1s0LCAzXSwgWzMsIDRdLCBbMiwgNl1dXG4gICAqIGNvbnNvbGUubG9nKHJlc3VsdC5wdXJlQ2hhbmdlZCk7XG4gICAqIC8vIEFuIGFycmF5IG9mIGluZGV4IHBhaXJzIHRvIGJlIGBvcmRlcmVkYCB0aGF0IGNhbiBzeW5jaHJvbml6ZSBgbGlzdGAgYmVmb3JlIGFkZGluZyBkYXRhLiAoRm9ybWF0dGVkIGJ5OiBBcnJheTxbcHJldkluZGV4LCBuZXh0SW5kZXhdPilcbiAgICogLy8gW1s0LCAxXSwgWzQsIDJdLCBbNCwgM11dXG4gICAqIGNvbnNvbGUubG9nKHJlc3VsdC5vcmRlcmVkKTtcbiAgICogLy8gQW4gYXJyYXkgb2YgaW5kZXggcGFpcnMgb2YgYHByZXZMaXN0YCBhbmQgYGxpc3RgIHRoYXQgaGF2ZSBub3QgYmVlbiBhZGRlZC9yZW1vdmVkIHNvIGRhdGEgaXMgcHJlc2VydmVkLlxuICAgKiAvLyBbWzAsIDJdLCBbNCwgM10sIFszLCA0XSwgWzIsIDZdLCBbMSwgN11dXG4gICAqIGNvbnNvbGUubG9nKHJlc3VsdC5tYWludGFpbmVkKTtcbiAgICovXG4gIGZ1bmN0aW9uIExpc3REaWZmZXIobGlzdCwgZmluZEtleUNhbGxiYWNrKSB7XG4gICAgaWYgKGxpc3QgPT09IHZvaWQgMCkge1xuICAgICAgbGlzdCA9IFtdO1xuICAgIH1cblxuICAgIHRoaXMuZmluZEtleUNhbGxiYWNrID0gZmluZEtleUNhbGxiYWNrO1xuICAgIHRoaXMubGlzdCA9IFtdLnNsaWNlLmNhbGwobGlzdCk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZSBsaXN0LlxuICAgKiBAa28g66as7Iqk7Yq466W8IOyXheuNsOydtO2KuOulvCDtlanri4jri6QuXG4gICAqIEBwYXJhbSAtIExpc3QgdG8gdXBkYXRlIDxrbz4g7JeF642w7J207Yq47ZWgIOumrOyKpO2KuCA8L2tvPlxuICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgcmVzdWx0cyBvZiBhbiB1cGRhdGUgZnJvbSBgcHJldkxpc3RgIHRvIGBsaXN0YC48a28+IGBwcmV2TGlzdGDsl5DshJwgYGxpc3Rg66GcIOyXheuNsOydtO2KuO2VnCDqsrDqs7zrpbwg67CY7ZmY7ZWc64ukLiA8L2tvPlxuICAgKi9cblxuXG4gIHZhciBfX3Byb3RvID0gTGlzdERpZmZlci5wcm90b3R5cGU7XG5cbiAgX19wcm90by51cGRhdGUgPSBmdW5jdGlvbiAobGlzdCkge1xuICAgIHZhciBuZXdEYXRhID0gW10uc2xpY2UuY2FsbChsaXN0KTtcbiAgICB2YXIgcmVzdWx0ID0gZGlmZih0aGlzLmxpc3QsIG5ld0RhdGEsIHRoaXMuZmluZEtleUNhbGxiYWNrKTtcbiAgICB0aGlzLmxpc3QgPSBuZXdEYXRhO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgcmV0dXJuIExpc3REaWZmZXI7XG59KCk7XG5cbi8qXG5lZ2pzLWxpc3QtZGlmZmVyXG5Db3B5cmlnaHQgKGMpIDIwMTktcHJlc2VudCBOQVZFUiBDb3JwLlxuTUlUIGxpY2Vuc2VcbiovXG5cbmV4cG9ydCBkZWZhdWx0IExpc3REaWZmZXI7XG5leHBvcnQgeyBkaWZmIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saXN0LWRpZmZlci5lc20uanMubWFwXG4iLCIvKlxuQ29weXJpZ2h0IChjKSAyMDE5IERheWJydXNoXG5uYW1lOiBAc2NlbmEvZHJhZ3Njcm9sbFxubGljZW5zZTogTUlUXG5hdXRob3I6IERheWJydXNoXG5yZXBvc2l0b3J5OiBnaXQraHR0cHM6Ly9naXRodWIuY29tL2RheWJydXNoL2RyYWdzY3JvbGwuZ2l0XG52ZXJzaW9uOiAxLjEuMVxuKi9cbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnQHNjZW5hL2V2ZW50LWVtaXR0ZXInO1xuaW1wb3J0IHsgbm93IH0gZnJvbSAnQGRheWJydXNoL3V0aWxzJztcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7XG4gICAgX19wcm90b19fOiBbXVxuICB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBkLl9fcHJvdG9fXyA9IGI7XG4gIH0gfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgfTtcblxuICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbn07XG5cbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XG4gIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cbiAgZnVuY3Rpb24gX18oKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7XG4gIH1cblxuICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59XG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbiAoKSB7XG4gIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XG4gICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBzID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xuICB9O1xuXG4gIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdFNjcm9sbFBvc2l0aW9uKGUpIHtcbiAgdmFyIGNvbnRhaW5lciA9IGUuY29udGFpbmVyO1xuXG4gIGlmIChjb250YWluZXIgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICByZXR1cm4gW2NvbnRhaW5lci5zY3JvbGxMZWZ0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0LCBjb250YWluZXIuc2Nyb2xsVG9wIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3BdO1xuICB9XG5cbiAgcmV0dXJuIFtjb250YWluZXIuc2Nyb2xsTGVmdCwgY29udGFpbmVyLnNjcm9sbFRvcF07XG59XG5cbnZhciBEcmFnU2Nyb2xsID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKERyYWdTY3JvbGwsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gRHJhZ1Njcm9sbCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLl9zdGFydFJlY3QgPSBudWxsO1xuICAgIF90aGlzLl9zdGFydFBvcyA9IFtdO1xuICAgIF90aGlzLl9wcmV2VGltZSA9IDA7XG4gICAgX3RoaXMuX3RpbWVyID0gMDtcbiAgICBfdGhpcy5fcHJldlNjcm9sbFBvcyA9IFswLCAwXTtcbiAgICBfdGhpcy5faXNXYWl0ID0gZmFsc2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9fcHJvdG8gPSBEcmFnU2Nyb2xsLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLmRyYWdTdGFydCA9IGZ1bmN0aW9uIChlLCBvcHRpb25zKSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IG9wdGlvbnMuY29udGFpbmVyO1xuICAgIHZhciB0b3AgPSAwO1xuICAgIHZhciBsZWZ0ID0gMDtcbiAgICB2YXIgd2lkdGggPSAwO1xuICAgIHZhciBoZWlnaHQgPSAwO1xuXG4gICAgaWYgKGNvbnRhaW5lciA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgIGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB0b3AgPSByZWN0LnRvcDtcbiAgICAgIGxlZnQgPSByZWN0LmxlZnQ7XG4gICAgICB3aWR0aCA9IHJlY3Qud2lkdGg7XG4gICAgICBoZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgICB9XG5cbiAgICB0aGlzLl9zdGFydFBvcyA9IFtlLmNsaWVudFgsIGUuY2xpZW50WV07XG4gICAgdGhpcy5fc3RhcnRSZWN0ID0ge1xuICAgICAgdG9wOiB0b3AsXG4gICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICB9O1xuICAgIHRoaXMuX3ByZXZTY3JvbGxQb3MgPSB0aGlzLl9nZXRTY3JvbGxQb3NpdGlvbihbMCwgMF0sIG9wdGlvbnMpO1xuICB9O1xuXG4gIF9fcHJvdG8uZHJhZyA9IGZ1bmN0aW9uIChlLCBvcHRpb25zKSB7XG4gICAgdmFyIGNsaWVudFggPSBlLmNsaWVudFgsXG4gICAgICAgIGNsaWVudFkgPSBlLmNsaWVudFk7XG4gICAgdmFyIF9hID0gb3B0aW9ucy50aHJlc2hvbGQsXG4gICAgICAgIHRocmVzaG9sZCA9IF9hID09PSB2b2lkIDAgPyAwIDogX2E7XG5cbiAgICB2YXIgX2IgPSB0aGlzLFxuICAgICAgICBfc3RhcnRSZWN0ID0gX2IuX3N0YXJ0UmVjdCxcbiAgICAgICAgX3N0YXJ0UG9zID0gX2IuX3N0YXJ0UG9zO1xuXG4gICAgdmFyIGRpcmVjdGlvbiA9IFswLCAwXTtcblxuICAgIGlmIChfc3RhcnRSZWN0LnRvcCA+IGNsaWVudFkgLSB0aHJlc2hvbGQpIHtcbiAgICAgIGlmIChfc3RhcnRQb3NbMV0gPiBfc3RhcnRSZWN0LnRvcCB8fCBjbGllbnRZIDwgX3N0YXJ0UG9zWzFdKSB7XG4gICAgICAgIGRpcmVjdGlvblsxXSA9IC0xO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoX3N0YXJ0UmVjdC50b3AgKyBfc3RhcnRSZWN0LmhlaWdodCA8IGNsaWVudFkgKyB0aHJlc2hvbGQpIHtcbiAgICAgIGlmIChfc3RhcnRQb3NbMV0gPCBfc3RhcnRSZWN0LnRvcCArIF9zdGFydFJlY3QuaGVpZ2h0IHx8IGNsaWVudFkgPiBfc3RhcnRQb3NbMV0pIHtcbiAgICAgICAgZGlyZWN0aW9uWzFdID0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoX3N0YXJ0UmVjdC5sZWZ0ID4gY2xpZW50WCAtIHRocmVzaG9sZCkge1xuICAgICAgaWYgKF9zdGFydFBvc1swXSA+IF9zdGFydFJlY3QubGVmdCB8fCBjbGllbnRYIDwgX3N0YXJ0UG9zWzBdKSB7XG4gICAgICAgIGRpcmVjdGlvblswXSA9IC0xO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoX3N0YXJ0UmVjdC5sZWZ0ICsgX3N0YXJ0UmVjdC53aWR0aCA8IGNsaWVudFggKyB0aHJlc2hvbGQpIHtcbiAgICAgIGlmIChfc3RhcnRQb3NbMF0gPCBfc3RhcnRSZWN0LmxlZnQgKyBfc3RhcnRSZWN0LndpZHRoIHx8IGNsaWVudFggPiBfc3RhcnRQb3NbMF0pIHtcbiAgICAgICAgZGlyZWN0aW9uWzBdID0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuXG4gICAgaWYgKCFkaXJlY3Rpb25bMF0gJiYgIWRpcmVjdGlvblsxXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9jb250aW51ZURyYWcoX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7XG4gICAgICBkaXJlY3Rpb246IGRpcmVjdGlvbixcbiAgICAgIGlucHV0RXZlbnQ6IGUsXG4gICAgICBpc0RyYWc6IHRydWVcbiAgICB9KSk7XG4gIH07XG5cbiAgX19wcm90by5jaGVja1Njcm9sbCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmICh0aGlzLl9pc1dhaXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgX2EgPSBvcHRpb25zLnByZXZTY3JvbGxQb3MsXG4gICAgICAgIHByZXZTY3JvbGxQb3MgPSBfYSA9PT0gdm9pZCAwID8gdGhpcy5fcHJldlNjcm9sbFBvcyA6IF9hLFxuICAgICAgICBkaXJlY3Rpb24gPSBvcHRpb25zLmRpcmVjdGlvbixcbiAgICAgICAgX2IgPSBvcHRpb25zLnRocm90dGxlVGltZSxcbiAgICAgICAgdGhyb3R0bGVUaW1lID0gX2IgPT09IHZvaWQgMCA/IDAgOiBfYixcbiAgICAgICAgaW5wdXRFdmVudCA9IG9wdGlvbnMuaW5wdXRFdmVudCxcbiAgICAgICAgaXNEcmFnID0gb3B0aW9ucy5pc0RyYWc7XG5cbiAgICB2YXIgbmV4dFNjcm9sbFBvcyA9IHRoaXMuX2dldFNjcm9sbFBvc2l0aW9uKGRpcmVjdGlvbiB8fCBbMCwgMF0sIG9wdGlvbnMpO1xuXG4gICAgdmFyIG9mZnNldFggPSBuZXh0U2Nyb2xsUG9zWzBdIC0gcHJldlNjcm9sbFBvc1swXTtcbiAgICB2YXIgb2Zmc2V0WSA9IG5leHRTY3JvbGxQb3NbMV0gLSBwcmV2U2Nyb2xsUG9zWzFdO1xuICAgIHZhciBuZXh0RGlyZWN0aW9uID0gZGlyZWN0aW9uIHx8IFtvZmZzZXRYID8gTWF0aC5hYnMob2Zmc2V0WCkgLyBvZmZzZXRYIDogMCwgb2Zmc2V0WSA/IE1hdGguYWJzKG9mZnNldFkpIC8gb2Zmc2V0WSA6IDBdO1xuICAgIHRoaXMuX3ByZXZTY3JvbGxQb3MgPSBuZXh0U2Nyb2xsUG9zO1xuXG4gICAgaWYgKCFvZmZzZXRYICYmICFvZmZzZXRZKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy50cmlnZ2VyKFwibW92ZVwiLCB7XG4gICAgICBvZmZzZXRYOiBuZXh0RGlyZWN0aW9uWzBdID8gb2Zmc2V0WCA6IDAsXG4gICAgICBvZmZzZXRZOiBuZXh0RGlyZWN0aW9uWzFdID8gb2Zmc2V0WSA6IDAsXG4gICAgICBpbnB1dEV2ZW50OiBpbnB1dEV2ZW50XG4gICAgfSk7XG5cbiAgICBpZiAodGhyb3R0bGVUaW1lICYmIGlzRHJhZykge1xuICAgICAgdGhpcy5fdGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLl9jb250aW51ZURyYWcob3B0aW9ucyk7XG4gICAgICB9LCB0aHJvdHRsZVRpbWUpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIF9fcHJvdG8uZHJhZ0VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICB9O1xuXG4gIF9fcHJvdG8uX2dldFNjcm9sbFBvc2l0aW9uID0gZnVuY3Rpb24gKGRpcmVjdGlvbiwgb3B0aW9ucykge1xuICAgIHZhciBjb250YWluZXIgPSBvcHRpb25zLmNvbnRhaW5lcixcbiAgICAgICAgX2EgPSBvcHRpb25zLmdldFNjcm9sbFBvc2l0aW9uLFxuICAgICAgICBnZXRTY3JvbGxQb3NpdGlvbiA9IF9hID09PSB2b2lkIDAgPyBnZXREZWZhdWx0U2Nyb2xsUG9zaXRpb24gOiBfYTtcbiAgICByZXR1cm4gZ2V0U2Nyb2xsUG9zaXRpb24oe1xuICAgICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICBkaXJlY3Rpb246IGRpcmVjdGlvblxuICAgIH0pO1xuICB9O1xuXG4gIF9fcHJvdG8uX2NvbnRpbnVlRHJhZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBjb250YWluZXIgPSBvcHRpb25zLmNvbnRhaW5lcixcbiAgICAgICAgZGlyZWN0aW9uID0gb3B0aW9ucy5kaXJlY3Rpb24sXG4gICAgICAgIHRocm90dGxlVGltZSA9IG9wdGlvbnMudGhyb3R0bGVUaW1lLFxuICAgICAgICB1c2VTY3JvbGwgPSBvcHRpb25zLnVzZVNjcm9sbCxcbiAgICAgICAgaXNEcmFnID0gb3B0aW9ucy5pc0RyYWcsXG4gICAgICAgIGlucHV0RXZlbnQgPSBvcHRpb25zLmlucHV0RXZlbnQ7XG5cbiAgICBpZiAoaXNEcmFnICYmIHRoaXMuX2lzV2FpdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBub3dUaW1lID0gbm93KCk7XG4gICAgdmFyIGRpc3RUaW1lID0gTWF0aC5tYXgodGhyb3R0bGVUaW1lICsgdGhpcy5fcHJldlRpbWUgLSBub3dUaW1lLCAwKTtcblxuICAgIGlmIChkaXN0VGltZSA+IDApIHtcbiAgICAgIHRoaXMuX3RpbWVyID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5fY29udGludWVEcmFnKG9wdGlvbnMpO1xuICAgICAgfSwgZGlzdFRpbWUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuX3ByZXZUaW1lID0gbm93VGltZTtcblxuICAgIHZhciBwcmV2U2Nyb2xsUG9zID0gdGhpcy5fZ2V0U2Nyb2xsUG9zaXRpb24oZGlyZWN0aW9uLCBvcHRpb25zKTtcblxuICAgIHRoaXMuX3ByZXZTY3JvbGxQb3MgPSBwcmV2U2Nyb2xsUG9zO1xuXG4gICAgaWYgKGlzRHJhZykge1xuICAgICAgdGhpcy5faXNXYWl0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLnRyaWdnZXIoXCJzY3JvbGxcIiwge1xuICAgICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICBkaXJlY3Rpb246IGRpcmVjdGlvbixcbiAgICAgIGlucHV0RXZlbnQ6IGlucHV0RXZlbnRcbiAgICB9KTtcbiAgICB0aGlzLl9pc1dhaXQgPSBmYWxzZTtcbiAgICByZXR1cm4gdXNlU2Nyb2xsIHx8IHRoaXMuY2hlY2tTY3JvbGwoX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7XG4gICAgICBwcmV2U2Nyb2xsUG9zOiBwcmV2U2Nyb2xsUG9zLFxuICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24sXG4gICAgICBpbnB1dEV2ZW50OiBpbnB1dEV2ZW50XG4gICAgfSkpO1xuICB9O1xuXG4gIHJldHVybiBEcmFnU2Nyb2xsO1xufShFdmVudEVtaXR0ZXIpO1xuXG5leHBvcnQgZGVmYXVsdCBEcmFnU2Nyb2xsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZHJhZ3Njcm9sbC5lc20uanMubWFwXG4iLCIvKlxuQ29weXJpZ2h0IChjKSAyMDE5IERheWJydXNoXG5uYW1lOiBAc2NlbmEvZXZlbnQtZW1pdHRlclxubGljZW5zZTogTUlUXG5hdXRob3I6IERheWJydXNoXG5yZXBvc2l0b3J5OiBnaXQraHR0cHM6Ly9naXRodWIuY29tL2RheWJydXNoL2dlc3R1cmUuZ2l0XG52ZXJzaW9uOiAxLjAuNVxuKi9cbmltcG9ydCB7IGlzT2JqZWN0LCBmaW5kSW5kZXggfSBmcm9tICdAZGF5YnJ1c2gvdXRpbHMnO1xuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xudmFyIF9fYXNzaWduID0gZnVuY3Rpb24gKCkge1xuICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xuICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdDtcbiAgfTtcblxuICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5mdW5jdGlvbiBfX3NwcmVhZEFycmF5cygpIHtcbiAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG5cbiAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKSBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKykgcltrXSA9IGFbal07XG5cbiAgcmV0dXJuIHI7XG59XG5cbi8qKlxuICogSW1wbGVtZW50IEV2ZW50RW1pdHRlciBvbiBvYmplY3Qgb3IgY29tcG9uZW50LlxuICovXG5cbnZhciBFdmVudEVtaXR0ZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBhIGxpc3RlbmVyIHRvIHRoZSByZWdpc3RlcmVkIGV2ZW50LlxuICAgKiBAcGFyYW0gLSBOYW1lIG9mIHRoZSBldmVudCB0byBiZSBhZGRlZFxuICAgKiBAcGFyYW0gLSBsaXN0ZW5lciBmdW5jdGlvbiBvZiB0aGUgZXZlbnQgdG8gYmUgYWRkZWRcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tIFwiQHNjZW5hL2V2ZW50LWVtaXR0ZXJcIjtcbiAgICogY29zbnQgZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICpcbiAgICogLy8gQWRkIGxpc3RlbmVyIGluIFwiYVwiIGV2ZW50XG4gICAqIGVtaXR0ZXIub24oXCJhXCIsICgpID0+IHtcbiAgICogfSk7XG4gICAqIC8vIEFkZCBsaXN0ZW5lcnNcbiAgICogZW1pdHRlci5vbih7XG4gICAqICBhOiAoKSA9PiB7fSxcbiAgICogIGI6ICgpID0+IHt9LFxuICAgKiB9KTtcbiAgICovXG5cblxuICB2YXIgX19wcm90byA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGU7XG5cbiAgX19wcm90by5vbiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKGlzT2JqZWN0KGV2ZW50TmFtZSkpIHtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gZXZlbnROYW1lKSB7XG4gICAgICAgIHRoaXMub24obmFtZSwgZXZlbnROYW1lW25hbWVdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYWRkRXZlbnQoZXZlbnROYW1lLCBsaXN0ZW5lciwge30pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogUmVtb3ZlIGxpc3RlbmVycyByZWdpc3RlcmVkIGluIHRoZSBldmVudCB0YXJnZXQuXG4gICAqIEBwYXJhbSAtIE5hbWUgb2YgdGhlIGV2ZW50IHRvIGJlIHJlbW92ZWRcbiAgICogQHBhcmFtIC0gbGlzdGVuZXIgZnVuY3Rpb24gb2YgdGhlIGV2ZW50IHRvIGJlIHJlbW92ZWRcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tIFwiQHNjZW5hL2V2ZW50LWVtaXR0ZXJcIjtcbiAgICogY29zbnQgZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICpcbiAgICogLy8gUmVtb3ZlIGFsbCBsaXN0ZW5lcnMuXG4gICAqIGVtaXR0ZXIub2ZmKCk7XG4gICAqXG4gICAqIC8vIFJlbW92ZSBhbGwgbGlzdGVuZXJzIGluIFwiQVwiIGV2ZW50LlxuICAgKiBlbWl0dGVyLm9mZihcImFcIik7XG4gICAqXG4gICAqXG4gICAqIC8vIFJlbW92ZSBcImxpc3RlbmVyXCIgbGlzdGVuZXIgaW4gXCJhXCIgZXZlbnQuXG4gICAqIGVtaXR0ZXIub2ZmKFwiYVwiLCBsaXN0ZW5lcik7XG4gICAqL1xuXG5cbiAgX19wcm90by5vZmYgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIGlmICghZXZlbnROYW1lKSB7XG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGV2ZW50TmFtZSkpIHtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gZXZlbnROYW1lKSB7XG4gICAgICAgIHRoaXMub2ZmKG5hbWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWxpc3RlbmVyKSB7XG4gICAgICB0aGlzLl9ldmVudHNbZXZlbnROYW1lXSA9IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzW2V2ZW50TmFtZV07XG5cbiAgICAgIGlmIChldmVudHMpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gZmluZEluZGV4KGV2ZW50cywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICByZXR1cm4gZS5saXN0ZW5lciA9PT0gbGlzdGVuZXI7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgZXZlbnRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIEFkZCBhIGRpc3Bvc2FibGUgbGlzdGVuZXIgYW5kIFVzZSBwcm9taXNlIHRvIHRoZSByZWdpc3RlcmVkIGV2ZW50LlxuICAgKiBAcGFyYW0gLSBOYW1lIG9mIHRoZSBldmVudCB0byBiZSBhZGRlZFxuICAgKiBAcGFyYW0gLSBkaXNwb3NhYmxlIGxpc3RlbmVyIGZ1bmN0aW9uIG9mIHRoZSBldmVudCB0byBiZSBhZGRlZFxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gXCJAc2NlbmEvZXZlbnQtZW1pdHRlclwiO1xuICAgKiBjb3NudCBlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgKlxuICAgKiAvLyBBZGQgYSBkaXNwb3NhYmxlIGxpc3RlbmVyIGluIFwiYVwiIGV2ZW50XG4gICAqIGVtaXR0ZXIub25jZShcImFcIiwgKCkgPT4ge1xuICAgKiB9KTtcbiAgICpcbiAgICogLy8gVXNlIFByb21pc2VcbiAgICogZW1pdHRlci5vbmNlKFwiYVwiKS50aGVuKGUgPT4ge1xuICAgKiB9KTtcbiAgICovXG5cblxuICBfX3Byb3RvLm9uY2UgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgIHRoaXMuX2FkZEV2ZW50KGV2ZW50TmFtZSwgbGlzdGVuZXIsIHtcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBfdGhpcy5fYWRkRXZlbnQoZXZlbnROYW1lLCByZXNvbHZlLCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogRmlyZXMgYW4gZXZlbnQgdG8gY2FsbCBsaXN0ZW5lcnMuXG4gICAqIEBwYXJhbSAtIEV2ZW50IG5hbWVcbiAgICogQHBhcmFtIC0gRXZlbnQgcGFyYW1ldGVyXG4gICAqIEByZXR1cm4gSWYgZmFsc2UsIHN0b3AgdGhlIGV2ZW50LlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gXCJAc2NlbmEvZXZlbnQtZW1pdHRlclwiO1xuICAgKlxuICAgKlxuICAgKiBjb25zdCBlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgKlxuICAgKiBlbWl0dGVyLm9uKFwiYVwiLCBlID0+IHtcbiAgICogfSk7XG4gICAqXG4gICAqXG4gICAqIGVtaXR0ZXIuZW1pdChcImFcIiwge1xuICAgKiAgIGE6IDEsXG4gICAqIH0pO1xuICAgKi9cblxuXG4gIF9fcHJvdG8uZW1pdCA9IGZ1bmN0aW9uIChldmVudE5hbWUsIHBhcmFtKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmIChwYXJhbSA9PT0gdm9pZCAwKSB7XG4gICAgICBwYXJhbSA9IHt9O1xuICAgIH1cblxuICAgIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHNbZXZlbnROYW1lXTtcblxuICAgIGlmICghZXZlbnROYW1lIHx8ICFldmVudHMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBpc1N0b3AgPSBmYWxzZTtcbiAgICBwYXJhbS5ldmVudFR5cGUgPSBldmVudE5hbWU7XG5cbiAgICBwYXJhbS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgaXNTdG9wID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgcGFyYW0uY3VycmVudFRhcmdldCA9IHRoaXM7XG5cbiAgICBfX3NwcmVhZEFycmF5cyhldmVudHMpLmZvckVhY2goZnVuY3Rpb24gKGluZm8pIHtcbiAgICAgIGluZm8ubGlzdGVuZXIocGFyYW0pO1xuXG4gICAgICBpZiAoaW5mby5vbmNlKSB7XG4gICAgICAgIF90aGlzLm9mZihldmVudE5hbWUsIGluZm8ubGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuICFpc1N0b3A7XG4gIH07XG4gIC8qKlxuICAgKiBGaXJlcyBhbiBldmVudCB0byBjYWxsIGxpc3RlbmVycy5cbiAgICogQHBhcmFtIC0gRXZlbnQgbmFtZVxuICAgKiBAcGFyYW0gLSBFdmVudCBwYXJhbWV0ZXJcbiAgICogQHJldHVybiBJZiBmYWxzZSwgc3RvcCB0aGUgZXZlbnQuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSBcIkBzY2VuYS9ldmVudC1lbWl0dGVyXCI7XG4gICAqXG4gICAqXG4gICAqIGNvbnN0IGVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAqXG4gICAqIGVtaXR0ZXIub24oXCJhXCIsIGUgPT4ge1xuICAgKiB9KTtcbiAgICpcbiAgICpcbiAgICogZW1pdHRlci5lbWl0KFwiYVwiLCB7XG4gICAqICAgYTogMSxcbiAgICogfSk7XG4gICAqL1xuXG4gIC8qKlxuICAqIEZpcmVzIGFuIGV2ZW50IHRvIGNhbGwgbGlzdGVuZXJzLlxuICAqIEBwYXJhbSAtIEV2ZW50IG5hbWVcbiAgKiBAcGFyYW0gLSBFdmVudCBwYXJhbWV0ZXJcbiAgKiBAcmV0dXJuIElmIGZhbHNlLCBzdG9wIHRoZSBldmVudC5cbiAgKiBAZXhhbXBsZVxuICAqXG4gICogaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tIFwiQHNjZW5hL2V2ZW50LWVtaXR0ZXJcIjtcbiAgKlxuICAqXG4gICogY29uc3QgZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgKlxuICAqIGVtaXR0ZXIub24oXCJhXCIsIGUgPT4ge1xuICAqIH0pO1xuICAqXG4gICogLy8gZW1pdFxuICAqIGVtaXR0ZXIudHJpZ2dlcihcImFcIiwge1xuICAqICAgYTogMSxcbiAgKiB9KTtcbiAgKi9cblxuXG4gIF9fcHJvdG8udHJpZ2dlciA9IGZ1bmN0aW9uIChldmVudE5hbWUsIHBhcmFtKSB7XG4gICAgaWYgKHBhcmFtID09PSB2b2lkIDApIHtcbiAgICAgIHBhcmFtID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZW1pdChldmVudE5hbWUsIHBhcmFtKTtcbiAgfTtcblxuICBfX3Byb3RvLl9hZGRFdmVudCA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICBldmVudHNbZXZlbnROYW1lXSA9IGV2ZW50c1tldmVudE5hbWVdIHx8IFtdO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBldmVudHNbZXZlbnROYW1lXTtcbiAgICBsaXN0ZW5lcnMucHVzaChfX2Fzc2lnbih7XG4gICAgICBsaXN0ZW5lcjogbGlzdGVuZXJcbiAgICB9LCBvcHRpb25zKSk7XG4gIH07XG5cbiAgcmV0dXJuIEV2ZW50RW1pdHRlcjtcbn0oKTtcblxuZXhwb3J0IGRlZmF1bHQgRXZlbnRFbWl0dGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXZlbnQtZW1pdHRlci5lc20uanMubWFwXG4iLCIvKlxuQ29weXJpZ2h0IChjKSAyMDIwIERheWJydXNoXG5uYW1lOiBAc2NlbmEvbWF0cml4XG5saWNlbnNlOiBNSVRcbmF1dGhvcjogRGF5YnJ1c2hcbnJlcG9zaXRvcnk6IGdpdCtodHRwczovL2dpdGh1Yi5jb20vZGF5YnJ1c2gvbWF0cml4XG52ZXJzaW9uOiAxLjEuMVxuKi9cbmltcG9ydCB7IHRocm90dGxlLCBUSU5ZX05VTSwgYXZlcmFnZSB9IGZyb20gJ0BkYXlicnVzaC91dGlscyc7XG5cbmZ1bmN0aW9uIGFkZChtYXRyaXgsIGludmVyc2VNYXRyaXgsIHN0YXJ0SW5kZXgsIGZyb21JbmRleCwgbiwgaykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuICAgIHZhciB4ID0gc3RhcnRJbmRleCArIGkgKiBuO1xuICAgIHZhciBmcm9tWCA9IGZyb21JbmRleCArIGkgKiBuO1xuICAgIG1hdHJpeFt4XSArPSBtYXRyaXhbZnJvbVhdICogaztcbiAgICBpbnZlcnNlTWF0cml4W3hdICs9IGludmVyc2VNYXRyaXhbZnJvbVhdICogaztcbiAgfVxufVxuXG5mdW5jdGlvbiBzd2FwKG1hdHJpeCwgaW52ZXJzZU1hdHJpeCwgc3RhcnRJbmRleCwgZnJvbUluZGV4LCBuKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgdmFyIHggPSBzdGFydEluZGV4ICsgaSAqIG47XG4gICAgdmFyIGZyb21YID0gZnJvbUluZGV4ICsgaSAqIG47XG4gICAgdmFyIHYgPSBtYXRyaXhbeF07XG4gICAgdmFyIGl2ID0gaW52ZXJzZU1hdHJpeFt4XTtcbiAgICBtYXRyaXhbeF0gPSBtYXRyaXhbZnJvbVhdO1xuICAgIG1hdHJpeFtmcm9tWF0gPSB2O1xuICAgIGludmVyc2VNYXRyaXhbeF0gPSBpbnZlcnNlTWF0cml4W2Zyb21YXTtcbiAgICBpbnZlcnNlTWF0cml4W2Zyb21YXSA9IGl2O1xuICB9XG59XG5cbmZ1bmN0aW9uIGRpdmlkZShtYXRyaXgsIGludmVyc2VNYXRyaXgsIHN0YXJ0SW5kZXgsIG4sIGspIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICB2YXIgeCA9IHN0YXJ0SW5kZXggKyBpICogbjtcbiAgICBtYXRyaXhbeF0gLz0gaztcbiAgICBpbnZlcnNlTWF0cml4W3hdIC89IGs7XG4gIH1cbn1cbi8qKlxuICpcbiAqIEBuYW1lc3BhY2UgTWF0cml4XG4gKi9cblxuLyoqXG4gKiBAbWVtYmVyb2YgTWF0cml4XG4gKi9cblxuXG5mdW5jdGlvbiBpZ25vcmVEaW1lbnNpb24obWF0cml4LCBtLCBuKSB7XG4gIGlmIChuID09PSB2b2lkIDApIHtcbiAgICBuID0gTWF0aC5zcXJ0KG1hdHJpeC5sZW5ndGgpO1xuICB9XG5cbiAgdmFyIG5ld01hdHJpeCA9IG1hdHJpeC5zbGljZSgpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgbmV3TWF0cml4W2kgKiBuICsgbSAtIDFdID0gMDtcbiAgICBuZXdNYXRyaXhbKG0gLSAxKSAqIG4gKyBpXSA9IDA7XG4gIH1cblxuICBuZXdNYXRyaXhbKG0gLSAxKSAqIChuICsgMSldID0gMTtcbiAgcmV0dXJuIG5ld01hdHJpeDtcbn1cbi8qKlxuICogQG1lbWJlcm9mIE1hdHJpeFxuICovXG5cbmZ1bmN0aW9uIGludmVydChtYXRyaXgsIG4pIHtcbiAgaWYgKG4gPT09IHZvaWQgMCkge1xuICAgIG4gPSBNYXRoLnNxcnQobWF0cml4Lmxlbmd0aCk7XG4gIH1cblxuICB2YXIgbmV3TWF0cml4ID0gbWF0cml4LnNsaWNlKCk7XG4gIHZhciBpbnZlcnNlTWF0cml4ID0gY3JlYXRlSWRlbnRpdHlNYXRyaXgobik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAvLyBkaWFnb25hbFxuICAgIHZhciBpZGVudGl0eUluZGV4ID0gbiAqIGkgKyBpO1xuXG4gICAgaWYgKCF0aHJvdHRsZShuZXdNYXRyaXhbaWRlbnRpdHlJbmRleF0sIFRJTllfTlVNKSkge1xuICAgICAgLy8gbmV3TWF0cml4W2lkZW50aXR5SW5kZXhdID0gMDtcbiAgICAgIGZvciAodmFyIGogPSBpICsgMTsgaiA8IG47ICsraikge1xuICAgICAgICBpZiAobmV3TWF0cml4W24gKiBpICsgal0pIHtcbiAgICAgICAgICBzd2FwKG5ld01hdHJpeCwgaW52ZXJzZU1hdHJpeCwgaSwgaiwgbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRocm90dGxlKG5ld01hdHJpeFtpZGVudGl0eUluZGV4XSwgVElOWV9OVU0pKSB7XG4gICAgICAvLyBubyBpbnZlcnNlIG1hdHJpeFxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGRpdmlkZShuZXdNYXRyaXgsIGludmVyc2VNYXRyaXgsIGksIG4sIG5ld01hdHJpeFtpZGVudGl0eUluZGV4XSk7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG47ICsraikge1xuICAgICAgdmFyIHRhcmdldFN0YXJ0SW5kZXggPSBqO1xuICAgICAgdmFyIHRhcmdldEluZGV4ID0gaiArIGkgKiBuO1xuICAgICAgdmFyIHRhcmdldCA9IG5ld01hdHJpeFt0YXJnZXRJbmRleF07XG5cbiAgICAgIGlmICghdGhyb3R0bGUodGFyZ2V0LCBUSU5ZX05VTSkgfHwgaSA9PT0gaikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgYWRkKG5ld01hdHJpeCwgaW52ZXJzZU1hdHJpeCwgdGFyZ2V0U3RhcnRJbmRleCwgaSwgbiwgLXRhcmdldCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGludmVyc2VNYXRyaXg7XG59XG4vKipcbiAqIEBtZW1iZXJvZiBNYXRyaXhcbiAqL1xuXG5mdW5jdGlvbiB0cmFuc3Bvc2UobWF0cml4LCBuKSB7XG4gIGlmIChuID09PSB2b2lkIDApIHtcbiAgICBuID0gTWF0aC5zcXJ0KG1hdHJpeC5sZW5ndGgpO1xuICB9XG5cbiAgdmFyIG5ld01hdHJpeCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBuOyArK2opIHtcbiAgICAgIG5ld01hdHJpeFtqICogbiArIGldID0gbWF0cml4W24gKiBpICsgal07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld01hdHJpeDtcbn1cbi8qKlxuICogQG1lbWJlcm9mIE1hdHJpeFxuICovXG5cbmZ1bmN0aW9uIGdldE9yaWdpbihtYXRyaXgsIG4pIHtcbiAgaWYgKG4gPT09IHZvaWQgMCkge1xuICAgIG4gPSBNYXRoLnNxcnQobWF0cml4Lmxlbmd0aCk7XG4gIH1cblxuICB2YXIgb3JpZ2luTWF0cml4ID0gW107XG4gIHZhciB3ID0gbWF0cml4W24gKiBuIC0gMV07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuIC0gMTsgKytpKSB7XG4gICAgb3JpZ2luTWF0cml4W2ldID0gbWF0cml4W24gKiAobiAtIDEpICsgaV0gLyB3O1xuICB9XG5cbiAgb3JpZ2luTWF0cml4W24gLSAxXSA9IDA7XG4gIHJldHVybiBvcmlnaW5NYXRyaXg7XG59XG4vKipcbiAqIEBtZW1iZXJvZiBNYXRyaXhcbiAqL1xuXG5mdW5jdGlvbiBmcm9tVHJhbnNsYXRpb24ocG9zLCBuKSB7XG4gIHZhciBuZXdNYXRyaXggPSBjcmVhdGVJZGVudGl0eU1hdHJpeChuKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG4gLSAxOyArK2kpIHtcbiAgICBuZXdNYXRyaXhbbiAqIChuIC0gMSkgKyBpXSA9IHBvc1tpXSB8fCAwO1xuICB9XG5cbiAgcmV0dXJuIG5ld01hdHJpeDtcbn1cbi8qKlxuICogQG1lbWJlcm9mIE1hdHJpeFxuICovXG5cbmZ1bmN0aW9uIGNvbnZlcnRQb3NpdGlvbk1hdHJpeChtYXRyaXgsIG4pIHtcbiAgdmFyIG5ld01hdHJpeCA9IG1hdHJpeC5zbGljZSgpO1xuXG4gIGZvciAodmFyIGkgPSBtYXRyaXgubGVuZ3RoOyBpIDwgbiAtIDE7ICsraSkge1xuICAgIG5ld01hdHJpeFtpXSA9IDA7XG4gIH1cblxuICBuZXdNYXRyaXhbbiAtIDFdID0gMTtcbiAgcmV0dXJuIG5ld01hdHJpeDtcbn1cbi8qKlxuICogQG1lbWJlcm9mIE1hdHJpeFxuICovXG5cbmZ1bmN0aW9uIGNvbnZlcnREaW1lbnNpb24obWF0cml4LCBuLCBtKSB7XG4gIGlmIChuID09PSB2b2lkIDApIHtcbiAgICBuID0gTWF0aC5zcXJ0KG1hdHJpeC5sZW5ndGgpO1xuICB9IC8vIG4gPCBtXG5cblxuICBpZiAobiA9PT0gbSkge1xuICAgIHJldHVybiBtYXRyaXg7XG4gIH1cblxuICB2YXIgbmV3TWF0cml4ID0gY3JlYXRlSWRlbnRpdHlNYXRyaXgobSk7XG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihuLCBtKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aCAtIDE7ICsraSkge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoIC0gMTsgKytqKSB7XG4gICAgICBuZXdNYXRyaXhbaSAqIG0gKyBqXSA9IG1hdHJpeFtpICogbiArIGpdO1xuICAgIH1cblxuICAgIG5ld01hdHJpeFsoaSArIDEpICogbSAtIDFdID0gbWF0cml4WyhpICsgMSkgKiBuIC0gMV07XG4gICAgbmV3TWF0cml4WyhtIC0gMSkgKiBtICsgaV0gPSBtYXRyaXhbKG4gLSAxKSAqIG4gKyBpXTtcbiAgfVxuXG4gIG5ld01hdHJpeFttICogbSAtIDFdID0gbWF0cml4W24gKiBuIC0gMV07XG4gIHJldHVybiBuZXdNYXRyaXg7XG59XG4vKipcbiAqIEBtZW1iZXJvZiBNYXRyaXhcbiAqL1xuXG5mdW5jdGlvbiBtdWx0aXBsaWVzKG4pIHtcbiAgdmFyIG1hdHJpeGVzID0gW107XG5cbiAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICBtYXRyaXhlc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgfVxuXG4gIHZhciBtID0gY3JlYXRlSWRlbnRpdHlNYXRyaXgobik7XG4gIG1hdHJpeGVzLmZvckVhY2goZnVuY3Rpb24gKG1hdHJpeCkge1xuICAgIG0gPSBtdWx0aXBseShtLCBtYXRyaXgsIG4pO1xuICB9KTtcbiAgcmV0dXJuIG07XG59XG4vKipcbiAqIEBtZW1iZXJvZiBNYXRyaXhcbiAqL1xuXG5mdW5jdGlvbiBtdWx0aXBseShtYXRyaXgsIG1hdHJpeDIsIG4pIHtcbiAgaWYgKG4gPT09IHZvaWQgMCkge1xuICAgIG4gPSBNYXRoLnNxcnQobWF0cml4Lmxlbmd0aCk7XG4gIH1cblxuICB2YXIgbmV3TWF0cml4ID0gW107IC8vIDEgeTogblxuICAvLyAxIHg6IG1cbiAgLy8gMiB4OiBtXG4gIC8vIDIgeToga1xuICAvLyBuICogbSBYIG0gKiBrXG5cbiAgdmFyIG0gPSBtYXRyaXgubGVuZ3RoIC8gbjtcbiAgdmFyIGsgPSBtYXRyaXgyLmxlbmd0aCAvIG07XG5cbiAgaWYgKCFtKSB7XG4gICAgcmV0dXJuIG1hdHJpeDI7XG4gIH0gZWxzZSBpZiAoIWspIHtcbiAgICByZXR1cm4gbWF0cml4O1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGs7ICsraikge1xuICAgICAgbmV3TWF0cml4W2ogKiBuICsgaV0gPSAwO1xuXG4gICAgICBmb3IgKHZhciBsID0gMDsgbCA8IG07ICsrbCkge1xuICAgICAgICAvLyBtMSB4OiBtKGwpLCB5OiBuKGkpXG4gICAgICAgIC8vIG0yIHg6IGsoaik6ICB5OiBtKGwpXG4gICAgICAgIC8vIG53IHg6IG4oaSksIHk6IGsoailcbiAgICAgICAgbmV3TWF0cml4W2ogKiBuICsgaV0gKz0gbWF0cml4W2wgKiBuICsgaV0gKiBtYXRyaXgyW2ogKiBtICsgbF07XG4gICAgICB9XG4gICAgfVxuICB9IC8vIG4gKiBrXG5cblxuICByZXR1cm4gbmV3TWF0cml4O1xufVxuLyoqXG4gKiBAbWVtYmVyb2YgTWF0cml4XG4gKi9cblxuZnVuY3Rpb24gcGx1cyhwb3MxLCBwb3MyKSB7XG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihwb3MxLmxlbmd0aCwgcG9zMi5sZW5ndGgpO1xuICB2YXIgbmV4dFBvcyA9IHBvczEuc2xpY2UoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgbmV4dFBvc1tpXSA9IG5leHRQb3NbaV0gKyBwb3MyW2ldO1xuICB9XG5cbiAgcmV0dXJuIG5leHRQb3M7XG59XG4vKipcbiAqIEBtZW1iZXJvZiBNYXRyaXhcbiAqL1xuXG5mdW5jdGlvbiBtaW51cyhwb3MxLCBwb3MyKSB7XG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihwb3MxLmxlbmd0aCwgcG9zMi5sZW5ndGgpO1xuICB2YXIgbmV4dFBvcyA9IHBvczEuc2xpY2UoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgbmV4dFBvc1tpXSA9IG5leHRQb3NbaV0gLSBwb3MyW2ldO1xuICB9XG5cbiAgcmV0dXJuIG5leHRQb3M7XG59XG4vKipcbiAqIEBtZW1iZXJvZiBNYXRyaXhcbiAqL1xuXG5mdW5jdGlvbiBjb252ZXJ0Q1NTdG9NYXRyaXgoYSwgaXMyZCkge1xuICBpZiAoaXMyZCA9PT0gdm9pZCAwKSB7XG4gICAgaXMyZCA9IGEubGVuZ3RoID09PSA2O1xuICB9XG5cbiAgaWYgKGlzMmQpIHtcbiAgICByZXR1cm4gW2FbMF0sIGFbMV0sIDAsIGFbMl0sIGFbM10sIDAsIGFbNF0sIGFbNV0sIDFdO1xuICB9XG5cbiAgcmV0dXJuIGE7XG59XG4vKipcbiAqIEBtZW1iZXJvZiBNYXRyaXhcbiAqL1xuXG5mdW5jdGlvbiBjb252ZXJ0TWF0cml4dG9DU1MoYSwgaXMyZCkge1xuICBpZiAoaXMyZCA9PT0gdm9pZCAwKSB7XG4gICAgaXMyZCA9IGEubGVuZ3RoID09PSA5O1xuICB9XG5cbiAgaWYgKGlzMmQpIHtcbiAgICByZXR1cm4gW2FbMF0sIGFbMV0sIGFbM10sIGFbNF0sIGFbNl0sIGFbN11dO1xuICB9XG5cbiAgcmV0dXJuIGE7XG59XG4vKipcbiAqIEBtZW1iZXJvZiBNYXRyaXhcbiAqL1xuXG5mdW5jdGlvbiBjYWxjdWxhdGUobWF0cml4LCBtYXRyaXgyLCBuKSB7XG4gIGlmIChuID09PSB2b2lkIDApIHtcbiAgICBuID0gbWF0cml4Mi5sZW5ndGg7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbXVsdGlwbHkobWF0cml4LCBtYXRyaXgyLCBuKTtcbiAgdmFyIGsgPSByZXN1bHRbbiAtIDFdO1xuICByZXR1cm4gcmVzdWx0Lm1hcChmdW5jdGlvbiAodikge1xuICAgIHJldHVybiB2IC8gaztcbiAgfSk7XG59XG4vKipcbiAqIEBtZW1iZXJvZiBNYXRyaXhcbiAqL1xuXG5mdW5jdGlvbiByb3RhdGVYM2QobWF0cml4LCByYWQpIHtcbiAgcmV0dXJuIG11bHRpcGx5KG1hdHJpeCwgWzEsIDAsIDAsIDAsIDAsIE1hdGguY29zKHJhZCksIE1hdGguc2luKHJhZCksIDAsIDAsIC1NYXRoLnNpbihyYWQpLCBNYXRoLmNvcyhyYWQpLCAwLCAwLCAwLCAwLCAxXSwgNCk7XG59XG4vKipcbiAqIEBtZW1iZXJvZiBNYXRyaXhcbiAqL1xuXG5mdW5jdGlvbiByb3RhdGVZM2QobWF0cml4LCByYWQpIHtcbiAgcmV0dXJuIG11bHRpcGx5KG1hdHJpeCwgW01hdGguY29zKHJhZCksIDAsIC1NYXRoLnNpbihyYWQpLCAwLCAwLCAxLCAwLCAwLCBNYXRoLnNpbihyYWQpLCAwLCBNYXRoLmNvcyhyYWQpLCAwLCAwLCAwLCAwLCAxXSwgNCk7XG59XG4vKipcbiAqIEBtZW1iZXJvZiBNYXRyaXhcbiAqL1xuXG5mdW5jdGlvbiByb3RhdGVaM2QobWF0cml4LCByYWQpIHtcbiAgcmV0dXJuIG11bHRpcGx5KG1hdHJpeCwgY3JlYXRlUm90YXRlTWF0cml4KHJhZCwgNCkpO1xufVxuLyoqXG4gKiBAbWVtYmVyb2YgTWF0cml4XG4gKi9cblxuZnVuY3Rpb24gc2NhbGUzZChtYXRyaXgsIF9hKSB7XG4gIHZhciBfYiA9IF9hWzBdLFxuICAgICAgc3ggPSBfYiA9PT0gdm9pZCAwID8gMSA6IF9iLFxuICAgICAgX2MgPSBfYVsxXSxcbiAgICAgIHN5ID0gX2MgPT09IHZvaWQgMCA/IDEgOiBfYyxcbiAgICAgIF9kID0gX2FbMl0sXG4gICAgICBzeiA9IF9kID09PSB2b2lkIDAgPyAxIDogX2Q7XG4gIHJldHVybiBtdWx0aXBseShtYXRyaXgsIFtzeCwgMCwgMCwgMCwgMCwgc3ksIDAsIDAsIDAsIDAsIHN6LCAwLCAwLCAwLCAwLCAxXSwgNCk7XG59XG4vKipcbiAqIEBtZW1iZXJvZiBNYXRyaXhcbiAqL1xuXG5mdW5jdGlvbiByb3RhdGUocG9zLCByYWQpIHtcbiAgcmV0dXJuIGNhbGN1bGF0ZShjcmVhdGVSb3RhdGVNYXRyaXgocmFkLCAzKSwgY29udmVydFBvc2l0aW9uTWF0cml4KHBvcywgMykpO1xufVxuLyoqXG4gKiBAbWVtYmVyb2YgTWF0cml4XG4gKi9cblxuZnVuY3Rpb24gdHJhbnNsYXRlM2QobWF0cml4LCBfYSkge1xuICB2YXIgX2IgPSBfYVswXSxcbiAgICAgIHR4ID0gX2IgPT09IHZvaWQgMCA/IDAgOiBfYixcbiAgICAgIF9jID0gX2FbMV0sXG4gICAgICB0eSA9IF9jID09PSB2b2lkIDAgPyAwIDogX2MsXG4gICAgICBfZCA9IF9hWzJdLFxuICAgICAgdHogPSBfZCA9PT0gdm9pZCAwID8gMCA6IF9kO1xuICByZXR1cm4gbXVsdGlwbHkobWF0cml4LCBbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgdHgsIHR5LCB0eiwgMV0sIDQpO1xufVxuLyoqXG4gKiBAbWVtYmVyb2YgTWF0cml4XG4gKi9cblxuZnVuY3Rpb24gbWF0cml4M2QobWF0cml4MSwgbWF0cml4Mikge1xuICByZXR1cm4gbXVsdGlwbHkobWF0cml4MSwgbWF0cml4MiwgNCk7XG59XG4vKipcbiAqIEBtZW1iZXJvZiBNYXRyaXhcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVSb3RhdGVNYXRyaXgocmFkLCBuKSB7XG4gIHZhciBjb3MgPSBNYXRoLmNvcyhyYWQpO1xuICB2YXIgc2luID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIG0gPSBjcmVhdGVJZGVudGl0eU1hdHJpeChuKTsgLy8gY29zIC1zaW5cbiAgLy8gc2luIGNvc1xuXG4gIG1bMF0gPSBjb3M7XG4gIG1bMV0gPSBzaW47XG4gIG1bbl0gPSAtc2luO1xuICBtW24gKyAxXSA9IGNvcztcbiAgcmV0dXJuIG07XG59XG4vKipcbiAqIEBtZW1iZXJvZiBNYXRyaXhcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVJZGVudGl0eU1hdHJpeChuKSB7XG4gIHZhciBsZW5ndGggPSBuICogbjtcbiAgdmFyIG1hdHJpeCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBtYXRyaXhbaV0gPSBpICUgKG4gKyAxKSA/IDAgOiAxO1xuICB9XG5cbiAgcmV0dXJuIG1hdHJpeDtcbn1cbi8qKlxuICogQG1lbWJlcm9mIE1hdHJpeFxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVNjYWxlTWF0cml4KHNjYWxlLCBuKSB7XG4gIHZhciBtID0gY3JlYXRlSWRlbnRpdHlNYXRyaXgobik7XG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihzY2FsZS5sZW5ndGgsIG4gLSAxKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgbVsobiArIDEpICogaV0gPSBzY2FsZVtpXTtcbiAgfVxuXG4gIHJldHVybiBtO1xufVxuLyoqXG4gKiBAbWVtYmVyb2YgTWF0cml4XG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlT3JpZ2luTWF0cml4KG9yaWdpbiwgbikge1xuICB2YXIgbSA9IGNyZWF0ZUlkZW50aXR5TWF0cml4KG4pO1xuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4ob3JpZ2luLmxlbmd0aCwgbiAtIDEpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBtW24gKiAobiAtIDEpICsgaV0gPSBvcmlnaW5baV07XG4gIH1cblxuICByZXR1cm4gbTtcbn1cbi8qKlxuICogQG1lbWJlcm9mIE1hdHJpeFxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVdhcnBNYXRyaXgocG9zMCwgcG9zMSwgcG9zMiwgcG9zMywgbmV4dFBvczAsIG5leHRQb3MxLCBuZXh0UG9zMiwgbmV4dFBvczMpIHtcbiAgdmFyIHgwID0gcG9zMFswXSxcbiAgICAgIHkwID0gcG9zMFsxXTtcbiAgdmFyIHgxID0gcG9zMVswXSxcbiAgICAgIHkxID0gcG9zMVsxXTtcbiAgdmFyIHgyID0gcG9zMlswXSxcbiAgICAgIHkyID0gcG9zMlsxXTtcbiAgdmFyIHgzID0gcG9zM1swXSxcbiAgICAgIHkzID0gcG9zM1sxXTtcbiAgdmFyIHUwID0gbmV4dFBvczBbMF0sXG4gICAgICB2MCA9IG5leHRQb3MwWzFdO1xuICB2YXIgdTEgPSBuZXh0UG9zMVswXSxcbiAgICAgIHYxID0gbmV4dFBvczFbMV07XG4gIHZhciB1MiA9IG5leHRQb3MyWzBdLFxuICAgICAgdjIgPSBuZXh0UG9zMlsxXTtcbiAgdmFyIHUzID0gbmV4dFBvczNbMF0sXG4gICAgICB2MyA9IG5leHRQb3MzWzFdO1xuICB2YXIgbWF0cml4ID0gW3gwLCAwLCB4MSwgMCwgeDIsIDAsIHgzLCAwLCB5MCwgMCwgeTEsIDAsIHkyLCAwLCB5MywgMCwgMSwgMCwgMSwgMCwgMSwgMCwgMSwgMCwgMCwgeDAsIDAsIHgxLCAwLCB4MiwgMCwgeDMsIDAsIHkwLCAwLCB5MSwgMCwgeTIsIDAsIHkzLCAwLCAxLCAwLCAxLCAwLCAxLCAwLCAxLCAtdTAgKiB4MCwgLXYwICogeDAsIC11MSAqIHgxLCAtdjEgKiB4MSwgLXUyICogeDIsIC12MiAqIHgyLCAtdTMgKiB4MywgLXYzICogeDMsIC11MCAqIHkwLCAtdjAgKiB5MCwgLXUxICogeTEsIC12MSAqIHkxLCAtdTIgKiB5MiwgLXYyICogeTIsIC11MyAqIHkzLCAtdjMgKiB5M107XG4gIHZhciBpbnZlcnNlTWF0cml4ID0gaW52ZXJ0KG1hdHJpeCwgOCk7XG5cbiAgaWYgKCFpbnZlcnNlTWF0cml4Lmxlbmd0aCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBoID0gbXVsdGlwbHkoaW52ZXJzZU1hdHJpeCwgW3UwLCB2MCwgdTEsIHYxLCB1MiwgdjIsIHUzLCB2M10sIDgpO1xuICBoWzhdID0gMTtcbiAgcmV0dXJuIGNvbnZlcnREaW1lbnNpb24odHJhbnNwb3NlKGgpLCAzLCA0KTtcbn1cbi8qKlxuICogQG1lbWJlcm9mIE1hdHJpeFxuICovXG5cbmZ1bmN0aW9uIGdldENlbnRlcihwb2ludHMpIHtcbiAgcmV0dXJuIFswLCAxXS5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICByZXR1cm4gYXZlcmFnZShwb2ludHMubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgIHJldHVybiBwb3NbaV07XG4gICAgfSkpO1xuICB9KTtcbn1cblxuZXhwb3J0IHsgY2FsY3VsYXRlLCBjb252ZXJ0Q1NTdG9NYXRyaXgsIGNvbnZlcnREaW1lbnNpb24sIGNvbnZlcnRNYXRyaXh0b0NTUywgY29udmVydFBvc2l0aW9uTWF0cml4LCBjcmVhdGVJZGVudGl0eU1hdHJpeCwgY3JlYXRlT3JpZ2luTWF0cml4LCBjcmVhdGVSb3RhdGVNYXRyaXgsIGNyZWF0ZVNjYWxlTWF0cml4LCBjcmVhdGVXYXJwTWF0cml4LCBmcm9tVHJhbnNsYXRpb24sIGdldENlbnRlciwgZ2V0T3JpZ2luLCBpZ25vcmVEaW1lbnNpb24sIGludmVydCwgbWF0cml4M2QsIG1pbnVzLCBtdWx0aXBsaWVzLCBtdWx0aXBseSwgcGx1cywgcm90YXRlLCByb3RhdGVYM2QsIHJvdGF0ZVkzZCwgcm90YXRlWjNkLCBzY2FsZTNkLCB0cmFuc2xhdGUzZCwgdHJhbnNwb3NlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRyaXguZXNtLmpzLm1hcFxuIiwiLypcbkNvcHlyaWdodCAoYykgMjAxOSBEYXlicnVzaFxubmFtZTogY3NzLXRvLW1hdFxubGljZW5zZTogTUlUXG5hdXRob3I6IERheWJydXNoXG5yZXBvc2l0b3J5OiBnaXQraHR0cHM6Ly9naXRodWIuY29tL2RheWJydXNoL2Nzcy10by1tYXQuZ2l0XG52ZXJzaW9uOiAxLjAuM1xuKi9cbmltcG9ydCB7IHNwbGl0QnJhY2tldCwgc3BsaXRDb21tYSwgc3BsaXRVbml0LCBpc0FycmF5LCBzcGxpdFNwYWNlIH0gZnJvbSAnQGRheWJydXNoL3V0aWxzJztcbmltcG9ydCB7IGNhbGN1bGF0ZSwgbWF0cml4M2QsIGludmVydCwgdHJhbnNsYXRlM2QsIHNjYWxlM2QsIHJvdGF0ZVozZCwgcm90YXRlWDNkLCByb3RhdGVZM2QgfSBmcm9tICdAc2NlbmEvbWF0cml4JztcblxuZnVuY3Rpb24gY3JlYXRlTWF0cml4KCkge1xuICByZXR1cm4gWzEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDFdO1xufVxuZnVuY3Rpb24gcGFyc2VNYXQodHJhbnNmb3JtKSB7XG4gIHJldHVybiB0b01hdChwYXJzZSh0cmFuc2Zvcm0pKTtcbn1cbmZ1bmN0aW9uIGdldEVsZW1lbnRNYXRyaXgoZWwpIHtcbiAgcmV0dXJuIHBhcnNlTWF0KGdldENvbXB1dGVkU3R5bGUoZWwpLnRyYW5zZm9ybSk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVNYXRyaXhEaXN0KG1hdHJpeCwgcG9zKSB7XG4gIHZhciByZXMgPSBjYWxjdWxhdGUobWF0cml4LCBbcG9zWzBdLCBwb3NbMV0gfHwgMCwgcG9zWzJdIHx8IDAsIDFdLCA0KTtcbiAgdmFyIHcgPSByZXNbM10gfHwgMTtcbiAgcmV0dXJuIFtyZXNbMF0gLyB3LCByZXNbMV0gLyB3LCByZXNbMl0gLyB3XTtcbn1cbmZ1bmN0aW9uIGdldERpc3RFbGVtZW50TWF0cml4KGVsLCBjb250YWluZXIpIHtcbiAgaWYgKGNvbnRhaW5lciA9PT0gdm9pZCAwKSB7XG4gICAgY29udGFpbmVyID0gZG9jdW1lbnQuYm9keTtcbiAgfVxuXG4gIHZhciB0YXJnZXQgPSBlbDtcbiAgdmFyIG1hdHJpeCA9IGNyZWF0ZU1hdHJpeCgpO1xuXG4gIHdoaWxlICh0YXJnZXQpIHtcbiAgICB2YXIgdHJhbnNmb3JtID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpLnRyYW5zZm9ybTtcbiAgICBtYXRyaXggPSBtYXRyaXgzZChwYXJzZU1hdCh0cmFuc2Zvcm0pLCBtYXRyaXgpO1xuXG4gICAgaWYgKHRhcmdldCA9PT0gY29udGFpbmVyKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50RWxlbWVudDtcbiAgfVxuXG4gIG1hdHJpeCA9IGludmVydChtYXRyaXgsIDQpO1xuICBtYXRyaXhbMTJdID0gMDtcbiAgbWF0cml4WzEzXSA9IDA7XG4gIG1hdHJpeFsxNF0gPSAwO1xuICByZXR1cm4gbWF0cml4O1xufVxuZnVuY3Rpb24gdG9NYXQobWF0cml4SW5mb3MpIHtcbiAgdmFyIHRhcmdldCA9IGNyZWF0ZU1hdHJpeCgpO1xuICBtYXRyaXhJbmZvcy5mb3JFYWNoKGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgdmFyIG1hdHJpeEZ1bmN0aW9uID0gaW5mby5tYXRyaXhGdW5jdGlvbixcbiAgICAgICAgZnVuY3Rpb25WYWx1ZSA9IGluZm8uZnVuY3Rpb25WYWx1ZTtcblxuICAgIGlmICghbWF0cml4RnVuY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0YXJnZXQgPSBtYXRyaXhGdW5jdGlvbih0YXJnZXQsIGZ1bmN0aW9uVmFsdWUpO1xuICB9KTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIHBhcnNlKHRyYW5zZm9ybSkge1xuICB2YXIgdHJhbnNmb3JtcyA9IGlzQXJyYXkodHJhbnNmb3JtKSA/IHRyYW5zZm9ybSA6IHNwbGl0U3BhY2UodHJhbnNmb3JtKTtcbiAgcmV0dXJuIHRyYW5zZm9ybXMubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgdmFyIF9hID0gc3BsaXRCcmFja2V0KHQpLFxuICAgICAgICBuYW1lID0gX2EucHJlZml4LFxuICAgICAgICB2YWx1ZSA9IF9hLnZhbHVlO1xuXG4gICAgdmFyIG1hdHJpeEZ1bmN0aW9uID0gbnVsbDtcbiAgICB2YXIgZnVuY3Rpb25OYW1lID0gbmFtZTtcbiAgICB2YXIgZnVuY3Rpb25WYWx1ZSA9IFwiXCI7XG5cbiAgICBpZiAobmFtZSA9PT0gXCJ0cmFuc2xhdGVcIiB8fCBuYW1lID09PSBcInRyYW5zbGF0ZVhcIiB8fCBuYW1lID09PSBcInRyYW5zbGF0ZTNkXCIpIHtcbiAgICAgIHZhciBfYiA9IHNwbGl0Q29tbWEodmFsdWUpLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2KTtcbiAgICAgIH0pLFxuICAgICAgICAgIHBvc1ggPSBfYlswXSxcbiAgICAgICAgICBfYyA9IF9iWzFdLFxuICAgICAgICAgIHBvc1kgPSBfYyA9PT0gdm9pZCAwID8gMCA6IF9jLFxuICAgICAgICAgIF9kID0gX2JbMl0sXG4gICAgICAgICAgcG9zWiA9IF9kID09PSB2b2lkIDAgPyAwIDogX2Q7XG5cbiAgICAgIG1hdHJpeEZ1bmN0aW9uID0gdHJhbnNsYXRlM2Q7XG4gICAgICBmdW5jdGlvblZhbHVlID0gW3Bvc1gsIHBvc1ksIHBvc1pdO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJ0cmFuc2xhdGVZXCIpIHtcbiAgICAgIHZhciBwb3NZID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICBtYXRyaXhGdW5jdGlvbiA9IHRyYW5zbGF0ZTNkO1xuICAgICAgZnVuY3Rpb25WYWx1ZSA9IFswLCBwb3NZLCAwXTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwidHJhbnNsYXRlWlwiKSB7XG4gICAgICB2YXIgcG9zWiA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgbWF0cml4RnVuY3Rpb24gPSB0cmFuc2xhdGUzZDtcbiAgICAgIGZ1bmN0aW9uVmFsdWUgPSBbMCwgMCwgcG9zWl07XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSBcInNjYWxlXCIgfHwgbmFtZSA9PT0gXCJzY2FsZTNkXCIpIHtcbiAgICAgIHZhciBfZSA9IHNwbGl0Q29tbWEodmFsdWUpLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2KTtcbiAgICAgIH0pLFxuICAgICAgICAgIHN4ID0gX2VbMF0sXG4gICAgICAgICAgX2YgPSBfZVsxXSxcbiAgICAgICAgICBzeSA9IF9mID09PSB2b2lkIDAgPyBzeCA6IF9mLFxuICAgICAgICAgIF9nID0gX2VbMl0sXG4gICAgICAgICAgc3ogPSBfZyA9PT0gdm9pZCAwID8gMSA6IF9nO1xuXG4gICAgICBtYXRyaXhGdW5jdGlvbiA9IHNjYWxlM2Q7XG4gICAgICBmdW5jdGlvblZhbHVlID0gW3N4LCBzeSwgc3pdO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJzY2FsZVhcIikge1xuICAgICAgdmFyIHN4ID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICBtYXRyaXhGdW5jdGlvbiA9IHNjYWxlM2Q7XG4gICAgICBmdW5jdGlvblZhbHVlID0gW3N4LCAxLCAxXTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwic2NhbGVZXCIpIHtcbiAgICAgIHZhciBzeSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgbWF0cml4RnVuY3Rpb24gPSBzY2FsZTNkO1xuICAgICAgZnVuY3Rpb25WYWx1ZSA9IFsxLCBzeSwgMV07XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSBcInNjYWxlWlwiKSB7XG4gICAgICB2YXIgc3ogPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgIG1hdHJpeEZ1bmN0aW9uID0gc2NhbGUzZDtcbiAgICAgIGZ1bmN0aW9uVmFsdWUgPSBbMSwgMSwgc3pdO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJyb3RhdGVcIiB8fCBuYW1lID09PSBcInJvdGF0ZVpcIiB8fCBuYW1lID09PSBcInJvdGF0ZVhcIiB8fCBuYW1lID09PSBcInJvdGF0ZVlcIikge1xuICAgICAgdmFyIF9oID0gc3BsaXRVbml0KHZhbHVlKSxcbiAgICAgICAgICB1bml0ID0gX2gudW5pdCxcbiAgICAgICAgICB1bml0VmFsdWUgPSBfaC52YWx1ZTtcblxuICAgICAgdmFyIHJhZCA9IHVuaXQgPT09IFwicmFkXCIgPyB1bml0VmFsdWUgOiB1bml0VmFsdWUgKiBNYXRoLlBJIC8gMTgwO1xuXG4gICAgICBpZiAobmFtZSA9PT0gXCJyb3RhdGVcIiB8fCBuYW1lID09PSBcInJvdGF0ZVpcIikge1xuICAgICAgICBmdW5jdGlvbk5hbWUgPSBcInJvdGF0ZVpcIjtcbiAgICAgICAgbWF0cml4RnVuY3Rpb24gPSByb3RhdGVaM2Q7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwicm90YXRlWFwiKSB7XG4gICAgICAgIG1hdHJpeEZ1bmN0aW9uID0gcm90YXRlWDNkO1xuICAgICAgfSBlbHNlIGlmIChuYW1lID09PSBcInJvdGF0ZVlcIikge1xuICAgICAgICBtYXRyaXhGdW5jdGlvbiA9IHJvdGF0ZVkzZDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb25WYWx1ZSA9IHJhZDtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwibWF0cml4M2RcIikge1xuICAgICAgbWF0cml4RnVuY3Rpb24gPSBtYXRyaXgzZDtcbiAgICAgIGZ1bmN0aW9uVmFsdWUgPSBzcGxpdENvbW1hKHZhbHVlKS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodik7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwibWF0cml4XCIpIHtcbiAgICAgIHZhciBtID0gc3BsaXRDb21tYSh2YWx1ZSkubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHYpO1xuICAgICAgfSk7XG4gICAgICBtYXRyaXhGdW5jdGlvbiA9IG1hdHJpeDNkO1xuICAgICAgZnVuY3Rpb25WYWx1ZSA9IFttWzBdLCBtWzFdLCAwLCAwLCBtWzJdLCBtWzNdLCAwLCAwLCAwLCAwLCAxLCAwLCBtWzRdLCBtWzVdLCAwLCAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnVuY3Rpb25OYW1lID0gXCJcIjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGZ1bmN0aW9uTmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgbWF0cml4RnVuY3Rpb246IG1hdHJpeEZ1bmN0aW9uLFxuICAgICAgZnVuY3Rpb25WYWx1ZTogZnVuY3Rpb25WYWx1ZVxuICAgIH07XG4gIH0pO1xufVxuXG5leHBvcnQgeyBjYWxjdWxhdGVNYXRyaXhEaXN0LCBjcmVhdGVNYXRyaXgsIGdldERpc3RFbGVtZW50TWF0cml4LCBnZXRFbGVtZW50TWF0cml4LCBwYXJzZSwgcGFyc2VNYXQsIHRvTWF0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jc3MtdG8tbWF0LmVzbS5qcy5tYXBcbiIsIi8qXG5Db3B5cmlnaHQgKGMpIDIwMTkgRGF5YnJ1c2hcbm5hbWU6IGZyYW1ld29yay11dGlsc1xubGljZW5zZTogTUlUXG5hdXRob3I6IERheWJydXNoXG5yZXBvc2l0b3J5OiBnaXQraHR0cHM6Ly9naXRodWIuY29tL2RheWJydXNoL2ZyYW1ld29yay11dGlscy5naXRcbnZlcnNpb246IDEuMS4wXG4qL1xuZnVuY3Rpb24gcHJlZml4TmFtZXMocHJlZml4KSB7XG4gIHZhciBjbGFzc05hbWVzID0gW107XG5cbiAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICBjbGFzc05hbWVzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICB9XG5cbiAgcmV0dXJuIGNsYXNzTmFtZXMubWFwKGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICByZXR1cm4gY2xhc3NOYW1lLnNwbGl0KFwiIFwiKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHJldHVybiBuYW1lID8gXCJcIiArIHByZWZpeCArIG5hbWUgOiBcIlwiO1xuICAgIH0pLmpvaW4oXCIgXCIpO1xuICB9KS5qb2luKFwiIFwiKTtcbn1cbmZ1bmN0aW9uIHByZWZpeENTUyhwcmVmaXgsIGNzcykge1xuICByZXR1cm4gY3NzLnJlcGxhY2UoLyhbXn17XSopey9nbSwgZnVuY3Rpb24gKF8sIHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHNlbGVjdG9yLnJlcGxhY2UoL1xcLihbXnssXFxzXFxkLl0rKS9nLCBcIi5cIiArIHByZWZpeCArIFwiJDFcIikgKyBcIntcIjtcbiAgfSk7XG59XG4vKiByZWFjdCAqL1xuXG5mdW5jdGlvbiByZWYodGFyZ2V0LCBuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgIGUgJiYgKHRhcmdldFtuYW1lXSA9IGUpO1xuICB9O1xufVxuZnVuY3Rpb24gcmVmcyh0YXJnZXQsIG5hbWUsIGkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgZSAmJiAodGFyZ2V0W25hbWVdW2ldID0gZSk7XG4gIH07XG59XG4vKiBDbGFzcyBEZWNvcmF0b3IgKi9cblxuZnVuY3Rpb24gUHJvcGVydGllcyhwcm9wZXJ0aWVzLCBhY3Rpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICB2YXIgcHJvdG90eXBlID0gY29tcG9uZW50LnByb3RvdHlwZTtcbiAgICBwcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICBhY3Rpb24ocHJvdG90eXBlLCBwcm9wZXJ0eSk7XG4gICAgfSk7XG4gIH07XG59XG4vKiBQcm9wZXJ0eSBEZWNvcmF0b3IgKi9cblxuZnVuY3Rpb24gd2l0aE1ldGhvZHMobWV0aG9kcywgZHVwbGljYXRlKSB7XG4gIGlmIChkdXBsaWNhdGUgPT09IHZvaWQgMCkge1xuICAgIGR1cGxpY2F0ZSA9IHt9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChwcm90b3R5cGUsIHByb3BlcnR5TmFtZSkge1xuICAgIG1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIG1ldGhvZE5hbWUgPSBkdXBsaWNhdGVbbmFtZV0gfHwgbmFtZTtcblxuICAgICAgaWYgKG1ldGhvZE5hbWUgaW4gcHJvdG90eXBlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG5cbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSAoX2EgPSB0aGlzW3Byb3BlcnR5TmFtZV0pW25hbWVdLmFwcGx5KF9hLCBhcmdzKTtcblxuICAgICAgICBpZiAocmVzdWx0ID09PSB0aGlzW3Byb3BlcnR5TmFtZV0pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xufVxuXG5leHBvcnQgeyBQcm9wZXJ0aWVzLCBwcmVmaXhDU1MsIHByZWZpeE5hbWVzLCByZWYsIHJlZnMsIHdpdGhNZXRob2RzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5lc20uanMubWFwXG4iLCIvKlxuQ29weXJpZ2h0IChjKSAyMDE5IERheWJydXNoXG5uYW1lOiBnZXN0b1xubGljZW5zZTogTUlUXG5hdXRob3I6IERheWJydXNoXG5yZXBvc2l0b3J5OiBnaXQraHR0cHM6Ly9naXRodWIuY29tL2RheWJydXNoL2dlc3RvLmdpdFxudmVyc2lvbjogMS43LjBcbiovXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ0BzY2VuYS9ldmVudC1lbWl0dGVyJztcbmltcG9ydCB7IHJlbW92ZUV2ZW50LCBub3csIGFkZEV2ZW50IH0gZnJvbSAnQGRheWJydXNoL3V0aWxzJztcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7XG4gICAgX19wcm90b19fOiBbXVxuICB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBkLl9fcHJvdG9fXyA9IGI7XG4gIH0gfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgfTtcblxuICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbn07XG5cbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XG4gIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cbiAgZnVuY3Rpb24gX18oKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7XG4gIH1cblxuICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59XG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbiAoKSB7XG4gIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XG4gICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBzID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xuICB9O1xuXG4gIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuZnVuY3Rpb24gZ2V0UmFkKHBvczEsIHBvczIpIHtcbiAgdmFyIGRpc3RYID0gcG9zMlswXSAtIHBvczFbMF07XG4gIHZhciBkaXN0WSA9IHBvczJbMV0gLSBwb3MxWzFdO1xuICB2YXIgcmFkID0gTWF0aC5hdGFuMihkaXN0WSwgZGlzdFgpO1xuICByZXR1cm4gcmFkID49IDAgPyByYWQgOiByYWQgKyBNYXRoLlBJICogMjtcbn1cbmZ1bmN0aW9uIGdldFJvdGF0aWlvbih0b3VjaGVzKSB7XG4gIHJldHVybiBnZXRSYWQoW3RvdWNoZXNbMF0uY2xpZW50WCwgdG91Y2hlc1swXS5jbGllbnRZXSwgW3RvdWNoZXNbMV0uY2xpZW50WCwgdG91Y2hlc1sxXS5jbGllbnRZXSkgLyBNYXRoLlBJICogMTgwO1xufVxuZnVuY3Rpb24gaXNNdWx0aVRvdWNoKGUpIHtcbiAgcmV0dXJuIGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID49IDI7XG59XG5mdW5jdGlvbiBnZXRFdmVudENsaWVudHMoZSkge1xuICBpZiAoZS50b3VjaGVzKSB7XG4gICAgcmV0dXJuIGdldENsaWVudHMoZS50b3VjaGVzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW2dldENsaWVudChlKV07XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFBvc2l0aW9uKGNsaWVudHMsIHByZXZDbGllbnRzLCBzdGFydENsaWVudHMpIHtcbiAgdmFyIGxlbmd0aCA9IHN0YXJ0Q2xpZW50cy5sZW5ndGg7XG5cbiAgdmFyIF9hID0gZ2V0QXZlcmFnZUNsaWVudChjbGllbnRzLCBsZW5ndGgpLFxuICAgICAgY2xpZW50WCA9IF9hLmNsaWVudFgsXG4gICAgICBjbGllbnRZID0gX2EuY2xpZW50WSxcbiAgICAgIG9yaWdpbmFsQ2xpZW50WCA9IF9hLm9yaWdpbmFsQ2xpZW50WCxcbiAgICAgIG9yaWdpbmFsQ2xpZW50WSA9IF9hLm9yaWdpbmFsQ2xpZW50WTtcblxuICB2YXIgX2IgPSBnZXRBdmVyYWdlQ2xpZW50KHByZXZDbGllbnRzLCBsZW5ndGgpLFxuICAgICAgcHJldlggPSBfYi5jbGllbnRYLFxuICAgICAgcHJldlkgPSBfYi5jbGllbnRZO1xuXG4gIHZhciBfYyA9IGdldEF2ZXJhZ2VDbGllbnQoc3RhcnRDbGllbnRzLCBsZW5ndGgpLFxuICAgICAgc3RhcnRYID0gX2MuY2xpZW50WCxcbiAgICAgIHN0YXJ0WSA9IF9jLmNsaWVudFk7XG5cbiAgdmFyIGRlbHRhWCA9IGNsaWVudFggLSBwcmV2WDtcbiAgdmFyIGRlbHRhWSA9IGNsaWVudFkgLSBwcmV2WTtcbiAgdmFyIGRpc3RYID0gY2xpZW50WCAtIHN0YXJ0WDtcbiAgdmFyIGRpc3RZID0gY2xpZW50WSAtIHN0YXJ0WTtcbiAgcmV0dXJuIHtcbiAgICBjbGllbnRYOiBvcmlnaW5hbENsaWVudFgsXG4gICAgY2xpZW50WTogb3JpZ2luYWxDbGllbnRZLFxuICAgIGRlbHRhWDogZGVsdGFYLFxuICAgIGRlbHRhWTogZGVsdGFZLFxuICAgIGRpc3RYOiBkaXN0WCxcbiAgICBkaXN0WTogZGlzdFlcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldERpc3QoY2xpZW50cykge1xuICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGNsaWVudHNbMF0uY2xpZW50WCAtIGNsaWVudHNbMV0uY2xpZW50WCwgMikgKyBNYXRoLnBvdyhjbGllbnRzWzBdLmNsaWVudFkgLSBjbGllbnRzWzFdLmNsaWVudFksIDIpKTtcbn1cbmZ1bmN0aW9uIGdldENsaWVudHModG91Y2hlcykge1xuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4odG91Y2hlcy5sZW5ndGgsIDIpO1xuICB2YXIgY2xpZW50cyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjbGllbnRzLnB1c2goZ2V0Q2xpZW50KHRvdWNoZXNbaV0pKTtcbiAgfVxuXG4gIHJldHVybiBjbGllbnRzO1xufVxuZnVuY3Rpb24gZ2V0Q2xpZW50KGUpIHtcbiAgcmV0dXJuIHtcbiAgICBjbGllbnRYOiBlLmNsaWVudFgsXG4gICAgY2xpZW50WTogZS5jbGllbnRZXG4gIH07XG59XG5mdW5jdGlvbiBnZXRBdmVyYWdlQ2xpZW50KGNsaWVudHMsIGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID09PSB2b2lkIDApIHtcbiAgICBsZW5ndGggPSBjbGllbnRzLmxlbmd0aDtcbiAgfVxuXG4gIHZhciBzdW1DbGllbnQgPSB7XG4gICAgY2xpZW50WDogMCxcbiAgICBjbGllbnRZOiAwLFxuICAgIG9yaWdpbmFsQ2xpZW50WDogMCxcbiAgICBvcmlnaW5hbENsaWVudFk6IDBcbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGNsaWVudCA9IGNsaWVudHNbaV07XG4gICAgc3VtQ2xpZW50Lm9yaWdpbmFsQ2xpZW50WCArPSBcIm9yaWdpbmFsQ2xpZW50WFwiIGluIGNsaWVudCA/IGNsaWVudC5vcmlnaW5hbENsaWVudFggOiBjbGllbnQuY2xpZW50WDtcbiAgICBzdW1DbGllbnQub3JpZ2luYWxDbGllbnRZICs9IFwib3JpZ2luYWxDbGllbnRZXCIgaW4gY2xpZW50ID8gY2xpZW50Lm9yaWdpbmFsQ2xpZW50WSA6IGNsaWVudC5jbGllbnRZO1xuICAgIHN1bUNsaWVudC5jbGllbnRYICs9IGNsaWVudC5jbGllbnRYO1xuICAgIHN1bUNsaWVudC5jbGllbnRZICs9IGNsaWVudC5jbGllbnRZO1xuICB9XG5cbiAgaWYgKCFsZW5ndGgpIHtcbiAgICByZXR1cm4gc3VtQ2xpZW50O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjbGllbnRYOiBzdW1DbGllbnQuY2xpZW50WCAvIGxlbmd0aCxcbiAgICBjbGllbnRZOiBzdW1DbGllbnQuY2xpZW50WSAvIGxlbmd0aCxcbiAgICBvcmlnaW5hbENsaWVudFg6IHN1bUNsaWVudC5vcmlnaW5hbENsaWVudFggLyBsZW5ndGgsXG4gICAgb3JpZ2luYWxDbGllbnRZOiBzdW1DbGllbnQub3JpZ2luYWxDbGllbnRZIC8gbGVuZ3RoXG4gIH07XG59XG5cbnZhciBDbGllbnRTdG9yZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENsaWVudFN0b3JlKGNsaWVudHMpIHtcbiAgICB0aGlzLnByZXZDbGllbnRzID0gW107XG4gICAgdGhpcy5zdGFydENsaWVudHMgPSBbXTtcbiAgICB0aGlzLm1vdmVtZW50ID0gMDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5zdGFydENsaWVudHMgPSBjbGllbnRzO1xuICAgIHRoaXMucHJldkNsaWVudHMgPSBjbGllbnRzO1xuICAgIHRoaXMubGVuZ3RoID0gY2xpZW50cy5sZW5ndGg7XG4gIH1cblxuICB2YXIgX19wcm90byA9IENsaWVudFN0b3JlLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLmdldEFuZ2xlID0gZnVuY3Rpb24gKGNsaWVudHMpIHtcbiAgICBpZiAoY2xpZW50cyA9PT0gdm9pZCAwKSB7XG4gICAgICBjbGllbnRzID0gdGhpcy5wcmV2Q2xpZW50cztcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0Um90YXRpaW9uKGNsaWVudHMpO1xuICB9O1xuXG4gIF9fcHJvdG8uZ2V0Um90YXRpb24gPSBmdW5jdGlvbiAoY2xpZW50cykge1xuICAgIGlmIChjbGllbnRzID09PSB2b2lkIDApIHtcbiAgICAgIGNsaWVudHMgPSB0aGlzLnByZXZDbGllbnRzO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRSb3RhdGlpb24oY2xpZW50cykgLSBnZXRSb3RhdGlpb24odGhpcy5zdGFydENsaWVudHMpO1xuICB9O1xuXG4gIF9fcHJvdG8uZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoY2xpZW50cywgaXNBZGQpIHtcbiAgICBpZiAoY2xpZW50cyA9PT0gdm9pZCAwKSB7XG4gICAgICBjbGllbnRzID0gdGhpcy5wcmV2Q2xpZW50cztcbiAgICB9XG5cbiAgICB2YXIgcG9zaXRpb24gPSBnZXRQb3NpdGlvbihjbGllbnRzIHx8IHRoaXMucHJldkNsaWVudHMsIHRoaXMucHJldkNsaWVudHMsIHRoaXMuc3RhcnRDbGllbnRzKTtcbiAgICB2YXIgZGVsdGFYID0gcG9zaXRpb24uZGVsdGFYLFxuICAgICAgICBkZWx0YVkgPSBwb3NpdGlvbi5kZWx0YVk7XG4gICAgdGhpcy5tb3ZlbWVudCArPSBNYXRoLnNxcnQoZGVsdGFYICogZGVsdGFYICsgZGVsdGFZICogZGVsdGFZKTtcbiAgICB0aGlzLnByZXZDbGllbnRzID0gY2xpZW50cztcbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH07XG5cbiAgX19wcm90by5nZXRQb3NpdGlvbnMgPSBmdW5jdGlvbiAoY2xpZW50cykge1xuICAgIGlmIChjbGllbnRzID09PSB2b2lkIDApIHtcbiAgICAgIGNsaWVudHMgPSB0aGlzLnByZXZDbGllbnRzO1xuICAgIH1cblxuICAgIHZhciBwcmV2Q2xpZW50cyA9IHRoaXMucHJldkNsaWVudHM7XG4gICAgcmV0dXJuIHRoaXMuc3RhcnRDbGllbnRzLm1hcChmdW5jdGlvbiAoc3RhcnRDbGllbnQsIGkpIHtcbiAgICAgIHJldHVybiBnZXRQb3NpdGlvbihbY2xpZW50c1tpXV0sIFtwcmV2Q2xpZW50c1tpXV0sIFtzdGFydENsaWVudF0pO1xuICAgIH0pO1xuICB9O1xuXG4gIF9fcHJvdG8uZ2V0TW92ZW1lbnQgPSBmdW5jdGlvbiAoY2xpZW50cykge1xuICAgIHZhciBtb3ZlbWVudCA9IHRoaXMubW92ZW1lbnQ7XG5cbiAgICBpZiAoIWNsaWVudHMpIHtcbiAgICAgIHJldHVybiBtb3ZlbWVudDtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudENsaWVudCA9IGdldEF2ZXJhZ2VDbGllbnQoY2xpZW50cywgdGhpcy5sZW5ndGgpO1xuICAgIHZhciBwcmV2Q2xpZW50ID0gZ2V0QXZlcmFnZUNsaWVudCh0aGlzLnByZXZDbGllbnRzLCB0aGlzLmxlbmd0aCk7XG4gICAgdmFyIGRlbHRhWCA9IGN1cnJlbnRDbGllbnQuY2xpZW50WCAtIHByZXZDbGllbnQuY2xpZW50WDtcbiAgICB2YXIgZGVsdGFZID0gY3VycmVudENsaWVudC5jbGllbnRZIC0gcHJldkNsaWVudC5jbGllbnRZO1xuICAgIHJldHVybiBNYXRoLnNxcnQoZGVsdGFYICogZGVsdGFYICsgZGVsdGFZICogZGVsdGFZKSArIG1vdmVtZW50O1xuICB9O1xuXG4gIF9fcHJvdG8uZ2V0RGlzdGFuY2UgPSBmdW5jdGlvbiAoY2xpZW50cykge1xuICAgIGlmIChjbGllbnRzID09PSB2b2lkIDApIHtcbiAgICAgIGNsaWVudHMgPSB0aGlzLnByZXZDbGllbnRzO1xuICAgIH1cblxuICAgIHJldHVybiBnZXREaXN0KGNsaWVudHMpO1xuICB9O1xuXG4gIF9fcHJvdG8uZ2V0U2NhbGUgPSBmdW5jdGlvbiAoY2xpZW50cykge1xuICAgIGlmIChjbGllbnRzID09PSB2b2lkIDApIHtcbiAgICAgIGNsaWVudHMgPSB0aGlzLnByZXZDbGllbnRzO1xuICAgIH1cblxuICAgIHJldHVybiBnZXREaXN0KGNsaWVudHMpIC8gZ2V0RGlzdCh0aGlzLnN0YXJ0Q2xpZW50cyk7XG4gIH07XG5cbiAgX19wcm90by5tb3ZlID0gZnVuY3Rpb24gKGRlbHRhWCwgZGVsdGFZKSB7XG4gICAgdGhpcy5zdGFydENsaWVudHMuZm9yRWFjaChmdW5jdGlvbiAoY2xpZW50KSB7XG4gICAgICBjbGllbnQuY2xpZW50WCAtPSBkZWx0YVg7XG4gICAgICBjbGllbnQuY2xpZW50WSAtPSBkZWx0YVk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIENsaWVudFN0b3JlO1xufSgpO1xuXG52YXIgSU5QVVRfVEFHTkFNRVMgPSBbXCJ0ZXh0YXJlYVwiLCBcImlucHV0XCJdO1xuLyoqXG4gKiBZb3UgY2FuIHNldCB1cCBkcmFnLCBwaW5jaCBldmVudHMgaW4gYW55IGJyb3dzZXIuXG4gKi9cblxudmFyIEdlc3RvID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEdlc3RvLCBfc3VwZXIpO1xuICAvKipcbiAgICpcbiAgICovXG5cblxuICBmdW5jdGlvbiBHZXN0byh0YXJnZXRzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5vcHRpb25zID0ge307XG4gICAgX3RoaXMuZmxhZyA9IGZhbHNlO1xuICAgIF90aGlzLnBpbmNoRmxhZyA9IGZhbHNlO1xuICAgIF90aGlzLmRhdGFzID0ge307XG4gICAgX3RoaXMuaXNEcmFnID0gZmFsc2U7XG4gICAgX3RoaXMuaXNQaW5jaCA9IGZhbHNlO1xuICAgIF90aGlzLmlzTW91c2UgPSBmYWxzZTtcbiAgICBfdGhpcy5pc1RvdWNoID0gZmFsc2U7XG4gICAgX3RoaXMuY2xpZW50U3RvcmVzID0gW107XG4gICAgX3RoaXMudGFyZ2V0cyA9IFtdO1xuICAgIF90aGlzLnByZXZUaW1lID0gMDtcbiAgICBfdGhpcy5kb3VibGVGbGFnID0gZmFsc2U7XG4gICAgX3RoaXMuX2RyYWdGbGFnID0gZmFsc2U7XG5cbiAgICBfdGhpcy5vbkRyYWdTdGFydCA9IGZ1bmN0aW9uIChlLCBpc1RydXN0ZWQpIHtcbiAgICAgIGlmIChpc1RydXN0ZWQgPT09IHZvaWQgMCkge1xuICAgICAgICBpc1RydXN0ZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV90aGlzLmZsYWcgJiYgZS5jYW5jZWxhYmxlID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBfYSA9IF90aGlzLm9wdGlvbnMsXG4gICAgICAgICAgY29udGFpbmVyID0gX2EuY29udGFpbmVyLFxuICAgICAgICAgIHBpbmNoT3V0c2lkZSA9IF9hLnBpbmNoT3V0c2lkZSxcbiAgICAgICAgICBwcmV2ZW50UmlnaHRDbGljayA9IF9hLnByZXZlbnRSaWdodENsaWNrLFxuICAgICAgICAgIHByZXZlbnREZWZhdWx0ID0gX2EucHJldmVudERlZmF1bHQsXG4gICAgICAgICAgY2hlY2tJbnB1dCA9IF9hLmNoZWNrSW5wdXQ7XG4gICAgICB2YXIgaXNUb3VjaCA9IF90aGlzLmlzVG91Y2g7XG4gICAgICB2YXIgaXNEcmFnU3RhcnQgPSAhX3RoaXMuZmxhZztcblxuICAgICAgaWYgKGlzRHJhZ1N0YXJ0KSB7XG4gICAgICAgIHZhciBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICB2YXIgdGFnTmFtZSA9IHRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBoYXNJbnB1dCA9IElOUFVUX1RBR05BTUVTLmluZGV4T2YodGFnTmFtZSkgPiAtMTtcbiAgICAgICAgdmFyIGhhc0NvbnRlbnRFZGl0YWJsZSA9IHRhcmdldC5pc0NvbnRlbnRFZGl0YWJsZTtcblxuICAgICAgICBpZiAoaGFzSW5wdXQgfHwgaGFzQ29udGVudEVkaXRhYmxlKSB7XG4gICAgICAgICAgaWYgKGNoZWNrSW5wdXQgfHwgYWN0aXZlRWxlbWVudCA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICAvLyBmb3JjZSBmYWxzZSBvciBhbHJlYWR5IGZvY3VzZWQuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSAvLyBubyBmb2N1c1xuXG5cbiAgICAgICAgICBpZiAoYWN0aXZlRWxlbWVudCAmJiBoYXNDb250ZW50RWRpdGFibGUgJiYgYWN0aXZlRWxlbWVudC5pc0NvbnRlbnRFZGl0YWJsZSAmJiBhY3RpdmVFbGVtZW50LmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoKHByZXZlbnREZWZhdWx0IHx8IGUudHlwZSA9PT0gXCJ0b3VjaHN0YXJ0XCIpICYmIGFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICB2YXIgYWN0aXZlVGFnTmFtZSA9IGFjdGl2ZUVsZW1lbnQudGFnTmFtZTtcblxuICAgICAgICAgIGlmIChhY3RpdmVFbGVtZW50LmlzQ29udGVudEVkaXRhYmxlIHx8IElOUFVUX1RBR05BTUVTLmluZGV4T2YoYWN0aXZlVGFnTmFtZSkgPiAtMSkge1xuICAgICAgICAgICAgYWN0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuY2xpZW50U3RvcmVzID0gW25ldyBDbGllbnRTdG9yZShnZXRFdmVudENsaWVudHMoZSkpXTtcbiAgICAgICAgX3RoaXMuZmxhZyA9IHRydWU7XG4gICAgICAgIF90aGlzLmlzRHJhZyA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5fZHJhZ0ZsYWcgPSB0cnVlO1xuICAgICAgICBfdGhpcy5kYXRhcyA9IHt9O1xuXG4gICAgICAgIGlmIChwcmV2ZW50UmlnaHRDbGljayAmJiAoZS53aGljaCA9PT0gMyB8fCBlLmJ1dHRvbiA9PT0gMikpIHtcbiAgICAgICAgICBfdGhpcy5pbml0RHJhZygpO1xuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuZG91YmxlRmxhZyA9IG5vdygpIC0gX3RoaXMucHJldlRpbWUgPCAyMDA7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IF90aGlzLmVtaXQoXCJkcmFnU3RhcnRcIiwgX19hc3NpZ24oe1xuICAgICAgICAgIGRhdGFzOiBfdGhpcy5kYXRhcyxcbiAgICAgICAgICBpbnB1dEV2ZW50OiBlLFxuICAgICAgICAgIGlzVHJ1c3RlZDogaXNUcnVzdGVkLFxuICAgICAgICAgIGlzRG91YmxlOiBfdGhpcy5kb3VibGVGbGFnXG4gICAgICAgIH0sIF90aGlzLmdldEN1cnJlbnRTdG9yZSgpLmdldFBvc2l0aW9uKCksIHtcbiAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJldmVudERyYWc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9kcmFnRmxhZyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgX3RoaXMuaW5pdERyYWcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLmZsYWcgJiYgcHJldmVudERlZmF1bHQgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV90aGlzLmZsYWcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGltZXIgPSAwO1xuXG4gICAgICBpZiAoaXNEcmFnU3RhcnQgJiYgaXNUb3VjaCAmJiBwaW5jaE91dHNpZGUpIHtcbiAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBhZGRFdmVudChjb250YWluZXIsIFwidG91Y2hzdGFydFwiLCBfdGhpcy5vbkRyYWdTdGFydCwge1xuICAgICAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNEcmFnU3RhcnQgJiYgaXNUb3VjaCAmJiBwaW5jaE91dHNpZGUpIHtcbiAgICAgICAgcmVtb3ZlRXZlbnQoY29udGFpbmVyLCBcInRvdWNoc3RhcnRcIiwgX3RoaXMub25EcmFnU3RhcnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3RoaXMuZmxhZyAmJiBpc011bHRpVG91Y2goZSkpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcblxuICAgICAgICBpZiAoaXNEcmFnU3RhcnQgJiYgZS50b3VjaGVzLmxlbmd0aCAhPT0gZS5jaGFuZ2VkVG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIV90aGlzLnBpbmNoRmxhZykge1xuICAgICAgICAgIF90aGlzLm9uUGluY2hTdGFydChlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5vbkRyYWcgPSBmdW5jdGlvbiAoZSwgaXNTY3JvbGwpIHtcbiAgICAgIGlmICghX3RoaXMuZmxhZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBjbGllbnRzID0gZ2V0RXZlbnRDbGllbnRzKGUpO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gX3RoaXMubW92ZUNsaWVudHMoY2xpZW50cywgZSwgZmFsc2UpO1xuXG4gICAgICBpZiAoX3RoaXMuX2RyYWdGbGFnKSB7XG4gICAgICAgIGlmIChfdGhpcy5waW5jaEZsYWcgfHwgcmVzdWx0LmRlbHRhWCB8fCByZXN1bHQuZGVsdGFZKSB7XG4gICAgICAgICAgdmFyIGRyYWdSZXN1bHQgPSBfdGhpcy5lbWl0KFwiZHJhZ1wiLCBfX2Fzc2lnbih7fSwgcmVzdWx0LCB7XG4gICAgICAgICAgICBpc1Njcm9sbDogISFpc1Njcm9sbCxcbiAgICAgICAgICAgIGlucHV0RXZlbnQ6IGVcbiAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBpZiAoZHJhZ1Jlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIF90aGlzLnN0b3AoKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfdGhpcy5waW5jaEZsYWcpIHtcbiAgICAgICAgICBfdGhpcy5vblBpbmNoKGUsIGNsaWVudHMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF90aGlzLmdldEN1cnJlbnRTdG9yZSgpLmdldFBvc2l0aW9uKGNsaWVudHMsIHRydWUpO1xuICAgIH07XG5cbiAgICBfdGhpcy5vbkRyYWdFbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKCFfdGhpcy5mbGFnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIF9hID0gX3RoaXMub3B0aW9ucyxcbiAgICAgICAgICBwaW5jaE91dHNpZGUgPSBfYS5waW5jaE91dHNpZGUsXG4gICAgICAgICAgY29udGFpbmVyID0gX2EuY29udGFpbmVyO1xuXG4gICAgICBpZiAoX3RoaXMuaXNUb3VjaCAmJiBwaW5jaE91dHNpZGUpIHtcbiAgICAgICAgcmVtb3ZlRXZlbnQoY29udGFpbmVyLCBcInRvdWNoc3RhcnRcIiwgX3RoaXMub25EcmFnU3RhcnQpO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5mbGFnID0gZmFsc2U7XG5cbiAgICAgIHZhciBwb3NpdGlvbiA9IF90aGlzLl9nZXRQb3NpdGlvbigpO1xuXG4gICAgICB2YXIgY3VycmVudFRpbWUgPSBub3coKTtcbiAgICAgIHZhciBpc0RvdWJsZSA9ICFfdGhpcy5pc0RyYWcgJiYgX3RoaXMuZG91YmxlRmxhZztcbiAgICAgIF90aGlzLnByZXZUaW1lID0gX3RoaXMuaXNEcmFnIHx8IGlzRG91YmxlID8gMCA6IGN1cnJlbnRUaW1lO1xuXG4gICAgICBfdGhpcy5lbWl0KFwiZHJhZ0VuZFwiLCBfX2Fzc2lnbih7XG4gICAgICAgIGRhdGFzOiBfdGhpcy5kYXRhcyxcbiAgICAgICAgaXNEb3VibGU6IGlzRG91YmxlLFxuICAgICAgICBpc0RyYWc6IF90aGlzLmlzRHJhZyxcbiAgICAgICAgaXNDbGljazogIV90aGlzLmlzRHJhZyxcbiAgICAgICAgaW5wdXRFdmVudDogZVxuICAgICAgfSwgcG9zaXRpb24pKTtcblxuICAgICAgaWYgKF90aGlzLnBpbmNoRmxhZykge1xuICAgICAgICBfdGhpcy5vblBpbmNoRW5kKGUpO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5jbGllbnRTdG9yZXMgPSBbXTtcbiAgICB9O1xuXG4gICAgX3RoaXMub25CbHVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMub25EcmFnRW5kKCk7XG4gICAgfTtcblxuICAgIHZhciBlbGVtZW50cyA9IFtdLmNvbmNhdCh0YXJnZXRzKTtcbiAgICBfdGhpcy5vcHRpb25zID0gX19hc3NpZ24oe1xuICAgICAgY2hlY2tJbnB1dDogZmFsc2UsXG4gICAgICBjb250YWluZXI6IGVsZW1lbnRzLmxlbmd0aCA+IDEgPyB3aW5kb3cgOiBlbGVtZW50c1swXSxcbiAgICAgIHByZXZlbnRSaWdodENsaWNrOiB0cnVlLFxuICAgICAgcHJldmVudERlZmF1bHQ6IHRydWUsXG4gICAgICBjaGVja1dpbmRvd0JsdXI6IGZhbHNlLFxuICAgICAgcGluY2hUaHJlc2hvbGQ6IDAsXG4gICAgICBldmVudHM6IFtcInRvdWNoXCIsIFwibW91c2VcIl1cbiAgICB9LCBvcHRpb25zKTtcbiAgICB2YXIgX2EgPSBfdGhpcy5vcHRpb25zLFxuICAgICAgICBjb250YWluZXIgPSBfYS5jb250YWluZXIsXG4gICAgICAgIGV2ZW50cyA9IF9hLmV2ZW50cyxcbiAgICAgICAgY2hlY2tXaW5kb3dCbHVyID0gX2EuY2hlY2tXaW5kb3dCbHVyO1xuICAgIF90aGlzLmlzVG91Y2ggPSBldmVudHMuaW5kZXhPZihcInRvdWNoXCIpID4gLTE7XG4gICAgX3RoaXMuaXNNb3VzZSA9IGV2ZW50cy5pbmRleE9mKFwibW91c2VcIikgPiAtMTtcbiAgICBfdGhpcy50YXJnZXRzID0gZWxlbWVudHM7XG5cbiAgICBpZiAoX3RoaXMuaXNNb3VzZSkge1xuICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgYWRkRXZlbnQoZWwsIFwibW91c2Vkb3duXCIsIF90aGlzLm9uRHJhZ1N0YXJ0KTtcbiAgICAgIH0pO1xuICAgICAgYWRkRXZlbnQoY29udGFpbmVyLCBcIm1vdXNlbW92ZVwiLCBfdGhpcy5vbkRyYWcpO1xuICAgICAgYWRkRXZlbnQoY29udGFpbmVyLCBcIm1vdXNldXBcIiwgX3RoaXMub25EcmFnRW5kKTtcbiAgICAgIGFkZEV2ZW50KGNvbnRhaW5lciwgXCJjb250ZXh0bWVudVwiLCBfdGhpcy5vbkRyYWdFbmQpO1xuICAgIH1cblxuICAgIGlmIChjaGVja1dpbmRvd0JsdXIpIHtcbiAgICAgIGFkZEV2ZW50KHdpbmRvdywgXCJibHVyXCIsIF90aGlzLm9uQmx1cik7XG4gICAgfVxuXG4gICAgaWYgKF90aGlzLmlzVG91Y2gpIHtcbiAgICAgIHZhciBwYXNzaXZlXzEgPSB7XG4gICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICB9O1xuICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgYWRkRXZlbnQoZWwsIFwidG91Y2hzdGFydFwiLCBfdGhpcy5vbkRyYWdTdGFydCwgcGFzc2l2ZV8xKTtcbiAgICAgIH0pO1xuICAgICAgYWRkRXZlbnQoY29udGFpbmVyLCBcInRvdWNobW92ZVwiLCBfdGhpcy5vbkRyYWcsIHBhc3NpdmVfMSk7XG4gICAgICBhZGRFdmVudChjb250YWluZXIsIFwidG91Y2hlbmRcIiwgX3RoaXMub25EcmFnRW5kLCBwYXNzaXZlXzEpO1xuICAgICAgYWRkRXZlbnQoY29udGFpbmVyLCBcInRvdWNoY2FuY2VsXCIsIF90aGlzLm9uRHJhZ0VuZCwgcGFzc2l2ZV8xKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFN0b3AgR2VzdG8ncyBkcmFnIGV2ZW50cy5cbiAgICovXG5cblxuICB2YXIgX19wcm90byA9IEdlc3RvLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc0RyYWcgPSBmYWxzZTtcbiAgICB0aGlzLmZsYWcgPSBmYWxzZTtcbiAgICB0aGlzLmNsaWVudFN0b3JlcyA9IFtdO1xuICAgIHRoaXMuZGF0YXMgPSB7fTtcbiAgfTtcbiAgLyoqXG4gICAqIFRoZSB0b3RhbCBtb3ZlZCBkaXN0YW5jZVxuICAgKi9cblxuXG4gIF9fcHJvdG8uZ2V0TW92ZW1lbnQgPSBmdW5jdGlvbiAoY2xpZW50cykge1xuICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRTdG9yZSgpLmdldE1vdmVtZW50KGNsaWVudHMpICsgdGhpcy5jbGllbnRTdG9yZXMuc2xpY2UoMSkucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXIpIHtcbiAgICAgIHJldHVybiBwcmV2ICsgY3VyLm1vdmVtZW50O1xuICAgIH0sIDApO1xuICB9O1xuICAvKipcbiAgICogV2hldGhlciB0byBkcmFnXG4gICAqL1xuXG5cbiAgX19wcm90by5pc0RyYWdnaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmlzRHJhZztcbiAgfTtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3RhcnQgZHJhZ1xuICAgKi9cblxuXG4gIF9fcHJvdG8uaXNGbGFnID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmZsYWc7XG4gIH07XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHN0YXJ0IHBpbmNoXG4gICAqL1xuXG5cbiAgX19wcm90by5pc1BpbmNoRmxhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5waW5jaEZsYWc7XG4gIH07XG4gIC8qKlxuICAqIFdoZXRoZXIgdG8gc3RhcnQgZG91YmxlIGNsaWNrXG4gICovXG5cblxuICBfX3Byb3RvLmlzRG91YmxlRmxhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5kb3VibGVGbGFnO1xuICB9O1xuICAvKipcbiAgICogV2hldGhlciB0byBwaW5jaFxuICAgKi9cblxuXG4gIF9fcHJvdG8uaXNQaW5jaGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1BpbmNoO1xuICB9O1xuICAvKipcbiAgICogSWYgYSBzY3JvbGwgZXZlbnQgb2NjdXJzLCBpdCBpcyBjb3JyZWN0ZWQgYnkgdGhlIHNjcm9sbCBkaXN0YW5jZS5cbiAgICovXG5cblxuICBfX3Byb3RvLnNjcm9sbEJ5ID0gZnVuY3Rpb24gKGRlbHRhWCwgZGVsdGFZLCBlLCBpc0NhbGxEcmFnKSB7XG4gICAgaWYgKGlzQ2FsbERyYWcgPT09IHZvaWQgMCkge1xuICAgICAgaXNDYWxsRHJhZyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmZsYWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmNsaWVudFN0b3Jlc1swXS5tb3ZlKGRlbHRhWCwgZGVsdGFZKTtcbiAgICBpc0NhbGxEcmFnICYmIHRoaXMub25EcmFnKGUsIHRydWUpO1xuICB9O1xuICAvKipcbiAgICogQ3JlYXRlIGEgdmlydHVhbCBkcmFnIGV2ZW50LlxuICAgKi9cblxuXG4gIF9fcHJvdG8ubW92ZSA9IGZ1bmN0aW9uIChfYSwgaW5wdXRFdmVudCkge1xuICAgIHZhciBkZWx0YVggPSBfYVswXSxcbiAgICAgICAgZGVsdGFZID0gX2FbMV07XG4gICAgdmFyIHN0b3JlID0gdGhpcy5nZXRDdXJyZW50U3RvcmUoKTtcbiAgICB2YXIgbmV4dENsaWVudHMgPSBzdG9yZS5wcmV2Q2xpZW50cztcbiAgICByZXR1cm4gdGhpcy5tb3ZlQ2xpZW50cyhuZXh0Q2xpZW50cy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICB2YXIgY2xpZW50WCA9IF9hLmNsaWVudFgsXG4gICAgICAgICAgY2xpZW50WSA9IF9hLmNsaWVudFk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjbGllbnRYOiBjbGllbnRYICsgZGVsdGFYLFxuICAgICAgICBjbGllbnRZOiBjbGllbnRZICsgZGVsdGFZLFxuICAgICAgICBvcmlnaW5hbENsaWVudFg6IGNsaWVudFgsXG4gICAgICAgIG9yaWdpbmFsQ2xpZW50WTogY2xpZW50WVxuICAgICAgfTtcbiAgICB9KSwgaW5wdXRFdmVudCwgdHJ1ZSk7XG4gIH07XG4gIC8qKlxuICAgKiBUaGUgZHJhZ1N0YXJ0IGV2ZW50IGlzIHRyaWdnZXJlZCBieSBhbiBleHRlcm5hbCBldmVudC5cbiAgICovXG5cblxuICBfX3Byb3RvLnRyaWdnZXJEcmFnU3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgIHRoaXMub25EcmFnU3RhcnQoZSwgZmFsc2UpO1xuICB9O1xuICAvKipcbiAgICogU2V0IHRoZSBldmVudCBkYXRhIHdoaWxlIGRyYWdnaW5nLlxuICAgKi9cblxuXG4gIF9fcHJvdG8uc2V0RXZlbnREYXRhcyA9IGZ1bmN0aW9uIChkYXRhcykge1xuICAgIHZhciBjdXJyZW50RGF0YXMgPSB0aGlzLmRhdGFzO1xuXG4gICAgZm9yICh2YXIgbmFtZSBpbiBkYXRhcykge1xuICAgICAgY3VycmVudERhdGFzW25hbWVdID0gZGF0YXNbbmFtZV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgZXZlbnQgc3RhdGUgd2hpbGUgZHJhZ2dpbmcuXG4gICAqL1xuXG5cbiAgX19wcm90by5nZXRDdXJyZW50RXZlbnQgPSBmdW5jdGlvbiAoaW5wdXRFdmVudCkge1xuICAgIHJldHVybiBfX2Fzc2lnbih7XG4gICAgICBkYXRhczogdGhpcy5kYXRhc1xuICAgIH0sIHRoaXMuX2dldFBvc2l0aW9uKCksIHtcbiAgICAgIG1vdmVtZW50OiB0aGlzLmdldE1vdmVtZW50KCksXG4gICAgICBpc0RyYWc6IHRoaXMuaXNEcmFnLFxuICAgICAgaXNQaW5jaDogdGhpcy5pc1BpbmNoLFxuICAgICAgaXNTY3JvbGw6IGZhbHNlLFxuICAgICAgaW5wdXRFdmVudDogaW5wdXRFdmVudFxuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogR2V0ICYgU2V0IHRoZSBldmVudCBkYXRhIHdoaWxlIGRyYWdnaW5nLlxuICAgKi9cblxuXG4gIF9fcHJvdG8uZ2V0RXZlbnREYXRhcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhcztcbiAgfTtcbiAgLyoqXG4gICAqIFVuc2V0IEdlc3RvXG4gICAqL1xuXG5cbiAgX19wcm90by51bnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHRhcmdldHMgPSB0aGlzLnRhcmdldHM7XG4gICAgdmFyIGNvbnRhaW5lciA9IHRoaXMub3B0aW9ucy5jb250YWluZXI7XG4gICAgdGhpcy5vZmYoKTtcbiAgICByZW1vdmVFdmVudCh3aW5kb3csIFwiYmx1clwiLCB0aGlzLm9uQmx1cik7XG5cbiAgICBpZiAodGhpcy5pc01vdXNlKSB7XG4gICAgICB0YXJnZXRzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICByZW1vdmVFdmVudCh0YXJnZXQsIFwibW91c2Vkb3duXCIsIF90aGlzLm9uRHJhZ1N0YXJ0KTtcbiAgICAgIH0pO1xuICAgICAgcmVtb3ZlRXZlbnQoY29udGFpbmVyLCBcIm1vdXNlbW92ZVwiLCB0aGlzLm9uRHJhZyk7XG4gICAgICByZW1vdmVFdmVudChjb250YWluZXIsIFwibW91c2V1cFwiLCB0aGlzLm9uRHJhZ0VuZCk7XG4gICAgICByZW1vdmVFdmVudChjb250YWluZXIsIFwiY29udGV4dG1lbnVcIiwgdGhpcy5vbkRyYWdFbmQpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzVG91Y2gpIHtcbiAgICAgIHRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIHJlbW92ZUV2ZW50KHRhcmdldCwgXCJ0b3VjaHN0YXJ0XCIsIF90aGlzLm9uRHJhZ1N0YXJ0KTtcbiAgICAgIH0pO1xuICAgICAgcmVtb3ZlRXZlbnQoY29udGFpbmVyLCBcInRvdWNoc3RhcnRcIiwgdGhpcy5vbkRyYWdTdGFydCk7XG4gICAgICByZW1vdmVFdmVudChjb250YWluZXIsIFwidG91Y2htb3ZlXCIsIHRoaXMub25EcmFnKTtcbiAgICAgIHJlbW92ZUV2ZW50KGNvbnRhaW5lciwgXCJ0b3VjaGVuZFwiLCB0aGlzLm9uRHJhZ0VuZCk7XG4gICAgICByZW1vdmVFdmVudChjb250YWluZXIsIFwidG91Y2hjYW5jZWxcIiwgdGhpcy5vbkRyYWdFbmQpO1xuICAgIH1cbiAgfTtcblxuICBfX3Byb3RvLm9uUGluY2hTdGFydCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHBpbmNoVGhyZXNob2xkID0gdGhpcy5vcHRpb25zLnBpbmNoVGhyZXNob2xkO1xuXG4gICAgaWYgKHRoaXMuaXNEcmFnICYmIHRoaXMuZ2V0TW92ZW1lbnQoKSA+IHBpbmNoVGhyZXNob2xkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHN0b3JlID0gbmV3IENsaWVudFN0b3JlKGdldEV2ZW50Q2xpZW50cyhlKSk7XG4gICAgdGhpcy5waW5jaEZsYWcgPSB0cnVlO1xuICAgIHRoaXMuY2xpZW50U3RvcmVzLnNwbGljZSgwLCAwLCBzdG9yZSk7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuZW1pdChcInBpbmNoU3RhcnRcIiwgX19hc3NpZ24oe1xuICAgICAgZGF0YXM6IHRoaXMuZGF0YXMsXG4gICAgICBhbmdsZTogc3RvcmUuZ2V0QW5nbGUoKSxcbiAgICAgIHRvdWNoZXM6IHRoaXMuZ2V0Q3VycmVudFN0b3JlKCkuZ2V0UG9zaXRpb25zKClcbiAgICB9LCBzdG9yZS5nZXRQb3NpdGlvbigpLCB7XG4gICAgICBpbnB1dEV2ZW50OiBlXG4gICAgfSkpO1xuXG4gICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMucGluY2hGbGFnID0gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIF9fcHJvdG8ub25QaW5jaCA9IGZ1bmN0aW9uIChlLCBjbGllbnRzKSB7XG4gICAgaWYgKCF0aGlzLmZsYWcgfHwgIXRoaXMucGluY2hGbGFnIHx8IGNsaWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzdG9yZSA9IHRoaXMuZ2V0Q3VycmVudFN0b3JlKCk7XG4gICAgdGhpcy5pc1BpbmNoID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXQoXCJwaW5jaFwiLCBfX2Fzc2lnbih7XG4gICAgICBkYXRhczogdGhpcy5kYXRhcyxcbiAgICAgIG1vdmVtZW50OiB0aGlzLmdldE1vdmVtZW50KGNsaWVudHMpLFxuICAgICAgYW5nbGU6IHN0b3JlLmdldEFuZ2xlKGNsaWVudHMpLFxuICAgICAgcm90YXRpb246IHN0b3JlLmdldFJvdGF0aW9uKGNsaWVudHMpLFxuICAgICAgdG91Y2hlczogc3RvcmUuZ2V0UG9zaXRpb25zKGNsaWVudHMpLFxuICAgICAgc2NhbGU6IHN0b3JlLmdldFNjYWxlKGNsaWVudHMpLFxuICAgICAgZGlzdGFuY2U6IHN0b3JlLmdldERpc3RhbmNlKGNsaWVudHMpXG4gICAgfSwgc3RvcmUuZ2V0UG9zaXRpb24oY2xpZW50cyksIHtcbiAgICAgIGlucHV0RXZlbnQ6IGVcbiAgICB9KSk7XG4gIH07XG5cbiAgX19wcm90by5vblBpbmNoRW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoIXRoaXMucGluY2hGbGFnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGlzUGluY2ggPSB0aGlzLmlzUGluY2g7XG4gICAgdGhpcy5pc1BpbmNoID0gZmFsc2U7XG4gICAgdGhpcy5waW5jaEZsYWcgPSBmYWxzZTtcbiAgICB2YXIgc3RvcmUgPSB0aGlzLmdldEN1cnJlbnRTdG9yZSgpO1xuICAgIHRoaXMuZW1pdChcInBpbmNoRW5kXCIsIF9fYXNzaWduKHtcbiAgICAgIGRhdGFzOiB0aGlzLmRhdGFzLFxuICAgICAgaXNQaW5jaDogaXNQaW5jaCxcbiAgICAgIHRvdWNoZXM6IHN0b3JlLmdldFBvc2l0aW9ucygpXG4gICAgfSwgc3RvcmUuZ2V0UG9zaXRpb24oKSwge1xuICAgICAgaW5wdXRFdmVudDogZVxuICAgIH0pKTtcbiAgICB0aGlzLmlzUGluY2ggPSBmYWxzZTtcbiAgICB0aGlzLnBpbmNoRmxhZyA9IGZhbHNlO1xuICB9O1xuXG4gIF9fcHJvdG8uaW5pdERyYWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jbGllbnRTdG9yZXMgPSBbXTtcbiAgICB0aGlzLnBpbmNoRmxhZyA9IGZhbHNlO1xuICAgIHRoaXMuZG91YmxlRmxhZyA9IGZhbHNlO1xuICAgIHRoaXMucHJldlRpbWUgPSAwO1xuICAgIHRoaXMuZmxhZyA9IGZhbHNlO1xuICB9O1xuXG4gIF9fcHJvdG8uZ2V0Q3VycmVudFN0b3JlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudFN0b3Jlc1swXTtcbiAgfTtcblxuICBfX3Byb3RvLm1vdmVDbGllbnRzID0gZnVuY3Rpb24gKGNsaWVudHMsIGlucHV0RXZlbnQsIGlzQWRkKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gdGhpcy5fZ2V0UG9zaXRpb24oY2xpZW50cywgaXNBZGQpO1xuXG4gICAgaWYgKHBvc2l0aW9uLmRlbHRhWCB8fCBwb3NpdGlvbi5kZWx0YVkpIHtcbiAgICAgIHRoaXMuaXNEcmFnID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gX19hc3NpZ24oe1xuICAgICAgZGF0YXM6IHRoaXMuZGF0YXNcbiAgICB9LCBwb3NpdGlvbiwge1xuICAgICAgbW92ZW1lbnQ6IHRoaXMuZ2V0TW92ZW1lbnQoY2xpZW50cyksXG4gICAgICBpc0RyYWc6IHRoaXMuaXNEcmFnLFxuICAgICAgaXNQaW5jaDogdGhpcy5pc1BpbmNoLFxuICAgICAgaXNTY3JvbGw6IGZhbHNlLFxuICAgICAgaW5wdXRFdmVudDogaW5wdXRFdmVudFxuICAgIH0pO1xuICB9O1xuXG4gIF9fcHJvdG8uX2dldFBvc2l0aW9uID0gZnVuY3Rpb24gKGNsaWVudHMsIGlzQWRkKSB7XG4gICAgdmFyIHN0b3JlID0gdGhpcy5nZXRDdXJyZW50U3RvcmUoKTtcbiAgICB2YXIgcG9zaXRpb24gPSBzdG9yZS5nZXRQb3NpdGlvbihjbGllbnRzLCBpc0FkZCk7XG5cbiAgICB2YXIgX2EgPSB0aGlzLmNsaWVudFN0b3Jlcy5zbGljZSgxKS5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cikge1xuICAgICAgdmFyIHN0b3JlUG9zaXRpb24gPSBjdXIuZ2V0UG9zaXRpb24oKTtcbiAgICAgIHByZXYuZGlzdFggKz0gc3RvcmVQb3NpdGlvbi5kaXN0WDtcbiAgICAgIHByZXYuZGlzdFkgKz0gc3RvcmVQb3NpdGlvbi5kaXN0WTtcbiAgICAgIHJldHVybiBwcmV2O1xuICAgIH0sIHBvc2l0aW9uKSxcbiAgICAgICAgZGlzdFggPSBfYS5kaXN0WCxcbiAgICAgICAgZGlzdFkgPSBfYS5kaXN0WTtcblxuICAgIHJldHVybiBfX2Fzc2lnbih7fSwgcG9zaXRpb24sIHtcbiAgICAgIGRpc3RYOiBkaXN0WCxcbiAgICAgIGRpc3RZOiBkaXN0WVxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBHZXN0bztcbn0oRXZlbnRFbWl0dGVyKTtcblxuZXhwb3J0IGRlZmF1bHQgR2VzdG87XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXN0by5lc20uanMubWFwXG4iLCIvKlxuQ29weXJpZ2h0IChjKSBEYXlicnVzaFxubmFtZToga2V5Y29uXG5saWNlbnNlOiBNSVRcbmF1dGhvcjogRGF5YnJ1c2hcbnJlcG9zaXRvcnk6IGdpdCtodHRwczovL2dpdGh1Yi5jb20vZGF5YnJ1c2gva2V5Y29uLmdpdFxudmVyc2lvbjogMS4xLjJcbiovXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHtcbiAgICBfX3Byb3RvX186IFtdXG4gIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikge1xuICAgIGQuX19wcm90b19fID0gYjtcbiAgfSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICB9O1xuXG4gIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xufTtcblxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblxuICBmdW5jdGlvbiBfXygpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yID0gZDtcbiAgfVxuXG4gIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn1cblxuLypcbkNvcHlyaWdodCAoYykgMjAxOCBEYXlicnVzaFxuQG5hbWU6IEBkYXlicnVzaC91dGlsc1xubGljZW5zZTogTUlUXG5hdXRob3I6IERheWJydXNoXG5yZXBvc2l0b3J5OiBodHRwczovL2dpdGh1Yi5jb20vZGF5YnJ1c2gvdXRpbHNcbkB2ZXJzaW9uIDEuMC4wXG4qL1xuLyoqXG4qIGdldCBzdHJpbmcgXCJvYmplY3RcIlxuKiBAbWVtYmVyb2YgQ29uc3RzXG4qIEBleGFtcGxlXG5pbXBvcnQge09CSkVDVH0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhPQkpFQ1QpOyAvLyBcIm9iamVjdFwiXG4qL1xuXG52YXIgT0JKRUNUID0gXCJvYmplY3RcIjtcbi8qKlxuKiBnZXQgc3RyaW5nIFwic3RyaW5nXCJcbiogQG1lbWJlcm9mIENvbnN0c1xuKiBAZXhhbXBsZVxuaW1wb3J0IHtTVFJJTkd9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coU1RSSU5HKTsgLy8gXCJzdHJpbmdcIlxuKi9cblxudmFyIFNUUklORyA9IFwic3RyaW5nXCI7XG4vKipcbiogQ2hlY2sgdGhlIHR5cGUgdGhhdCB0aGUgdmFsdWUgaXMgb2JqZWN0LlxuKiBAbWVtYmVyb2YgVXRpbHNcbiogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgdGhlIHR5cGVcbiogQHJldHVybiB7fSB0cnVlIGlmIHRoZSB0eXBlIGlzIGNvcnJlY3QsIGZhbHNlIG90aGVyd2lzZVxuKiBAZXhhbXBsZVxuaW1wb3J0IHtpc09iamVjdH0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhpc09iamVjdCh7fSkpOyAvLyB0cnVlXG5jb25zb2xlLmxvZyhpc09iamVjdCh1bmRlZmluZWQpKTsgLy8gZmFsc2VcbmNvbnNvbGUubG9nKGlzT2JqZWN0KFwiXCIpKTsgLy8gZmFsc2VcbmNvbnNvbGUubG9nKGlzT2JqZWN0KG51bGwpKTsgLy8gZmFsc2VcbiovXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IE9CSkVDVDtcbn1cbi8qKlxuKiBDaGVjayB0aGUgdHlwZSB0aGF0IHRoZSB2YWx1ZSBpcyBpc0FycmF5LlxuKiBAbWVtYmVyb2YgVXRpbHNcbiogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgdGhlIHR5cGVcbiogQHJldHVybiB7fSB0cnVlIGlmIHRoZSB0eXBlIGlzIGNvcnJlY3QsIGZhbHNlIG90aGVyd2lzZVxuKiBAZXhhbXBsZVxuaW1wb3J0IHtpc0FycmF5fSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKGlzQXJyYXkoW10pKTsgLy8gdHJ1ZVxuY29uc29sZS5sb2coaXNBcnJheSh7fSkpOyAvLyBmYWxzZVxuY29uc29sZS5sb2coaXNBcnJheSh1bmRlZmluZWQpKTsgLy8gZmFsc2VcbmNvbnNvbGUubG9nKGlzQXJyYXkobnVsbCkpOyAvLyBmYWxzZVxuKi9cblxuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG4vKipcbiogQ2hlY2sgdGhlIHR5cGUgdGhhdCB0aGUgdmFsdWUgaXMgc3RyaW5nLlxuKiBAbWVtYmVyb2YgVXRpbHNcbiogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgdGhlIHR5cGVcbiogQHJldHVybiB7fSB0cnVlIGlmIHRoZSB0eXBlIGlzIGNvcnJlY3QsIGZhbHNlIG90aGVyd2lzZVxuKiBAZXhhbXBsZVxuaW1wb3J0IHtpc1N0cmluZ30gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhpc1N0cmluZyhcIjEyMzRcIikpOyAvLyB0cnVlXG5jb25zb2xlLmxvZyhpc1N0cmluZyh1bmRlZmluZWQpKTsgLy8gZmFsc2VcbmNvbnNvbGUubG9nKGlzU3RyaW5nKDEpKTsgLy8gZmFsc2VcbmNvbnNvbGUubG9nKGlzU3RyaW5nKG51bGwpKTsgLy8gZmFsc2VcbiovXG5cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFNUUklORztcbn1cbi8qKlxuKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgYXJyYXkgdGhhdCBzYXRpc2ZpZXMgdGhlIHByb3ZpZGVkIHRlc3RpbmcgZnVuY3Rpb24uXG4qIEBmdW5jdGlvblxuKiBAbWVtYmVyb2YgQ3Jvc3NCcm93c2VyXG4qIEBwYXJhbSAtIFRoZSBhcnJheSBgZmluZEluZGV4YCB3YXMgY2FsbGVkIHVwb24uXG4qIEBwYXJhbSAtIEEgZnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBlYWNoIHZhbHVlIGluIHRoZSBhcnJheSB1bnRpbCB0aGUgZnVuY3Rpb24gcmV0dXJucyB0cnVlLCBpbmRpY2F0aW5nIHRoYXQgdGhlIHNhdGlzZnlpbmcgZWxlbWVudCB3YXMgZm91bmQuXG4qIEBwYXJhbSAtIFJldHVybnMgZGVmYXVsdEluZGV4IGlmIG5vdCBmb3VuZCBieSB0aGUgZnVuY3Rpb24uXG4qIEBleGFtcGxlXG5pbXBvcnQgeyBmaW5kSW5kZXggfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmZpbmRJbmRleChbe2E6IDF9LCB7YTogMn0sIHthOiAzfSwge2E6IDR9XSwgKHsgYSB9KSA9PiBhID09PSAyKTsgLy8gMVxuKi9cblxuZnVuY3Rpb24gZmluZEluZGV4KGFyciwgY2FsbGJhY2ssIGRlZmF1bHRJbmRleCkge1xuICBpZiAoZGVmYXVsdEluZGV4ID09PSB2b2lkIDApIHtcbiAgICBkZWZhdWx0SW5kZXggPSAtMTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoY2FsbGJhY2soYXJyW2ldLCBpLCBhcnIpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGVmYXVsdEluZGV4O1xufVxuLyoqXG4qIFNldHMgdXAgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIHRoZSBzcGVjaWZpZWQgZXZlbnQgaXMgZGVsaXZlcmVkIHRvIHRoZSB0YXJnZXRcbiogQG1lbWJlcm9mIERPTVxuKiBAcGFyYW0gLSBldmVudCB0YXJnZXRcbiogQHBhcmFtIC0gQSBjYXNlLXNlbnNpdGl2ZSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBldmVudCB0eXBlIHRvIGxpc3RlbiBmb3IuXG4qIEBwYXJhbSAtIFRoZSBvYmplY3Qgd2hpY2ggcmVjZWl2ZXMgYSBub3RpZmljYXRpb24gKGFuIG9iamVjdCB0aGF0IGltcGxlbWVudHMgdGhlIEV2ZW50IGludGVyZmFjZSkgd2hlbiBhbiBldmVudCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUgb2NjdXJzXG4qIEBwYXJhbSAtIEFuIG9wdGlvbnMgb2JqZWN0IHRoYXQgc3BlY2lmaWVzIGNoYXJhY3RlcmlzdGljcyBhYm91dCB0aGUgZXZlbnQgbGlzdGVuZXIuIFRoZSBhdmFpbGFibGUgb3B0aW9ucyBhcmU6XG4qIEBleGFtcGxlXG5pbXBvcnQge2FkZEV2ZW50fSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmFkZEV2ZW50KGVsLCBcImNsaWNrXCIsIGUgPT4ge1xuICBjb25zb2xlLmxvZyhlKTtcbn0pO1xuKi9cblxuZnVuY3Rpb24gYWRkRXZlbnQoZWwsIHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpO1xufVxuLyoqXG4qIHJlbW92ZXMgZnJvbSB0aGUgRXZlbnRUYXJnZXQgYW4gZXZlbnQgbGlzdGVuZXIgcHJldmlvdXNseSByZWdpc3RlcmVkIHdpdGggRXZlbnRUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigpXG4qIEBtZW1iZXJvZiBET01cbiogQHBhcmFtIC0gZXZlbnQgdGFyZ2V0XG4qIEBwYXJhbSAtIEEgY2FzZS1zZW5zaXRpdmUgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXZlbnQgdHlwZSB0byBsaXN0ZW4gZm9yLlxuKiBAcGFyYW0gLSBUaGUgRXZlbnRMaXN0ZW5lciBmdW5jdGlvbiBvZiB0aGUgZXZlbnQgaGFuZGxlciB0byByZW1vdmUgZnJvbSB0aGUgZXZlbnQgdGFyZ2V0LlxuKiBAZXhhbXBsZVxuaW1wb3J0IHthZGRFdmVudCwgcmVtb3ZlRXZlbnR9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcbmNvbnN0IGxpc3RlbmVyID0gZSA9PiB7XG4gIGNvbnNvbGUubG9nKGUpO1xufTtcbmFkZEV2ZW50KGVsLCBcImNsaWNrXCIsIGxpc3RlbmVyKTtcbnJlbW92ZUV2ZW50KGVsLCBcImNsaWNrXCIsIGxpc3RlbmVyKTtcbiovXG5cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50KGVsLCB0eXBlLCBsaXN0ZW5lcikge1xuICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKTtcbn1cblxuLypcbkNvcHlyaWdodCAoYykgMjAxOSBEYXlicnVzaFxubmFtZTogQHNjZW5hL2V2ZW50LWVtaXR0ZXJcbmxpY2Vuc2U6IE1JVFxuYXV0aG9yOiBEYXlicnVzaFxucmVwb3NpdG9yeTogZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS9kYXlicnVzaC9nZXN0dXJlLmdpdFxudmVyc2lvbjogMS4wLjJcbiovXG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbiAoKSB7XG4gIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XG4gICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBzID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xuICB9O1xuXG4gIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbmZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xuICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcblxuICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKSByW2tdID0gYVtqXTtcblxuICByZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnQgRXZlbnRFbWl0dGVyIG9uIG9iamVjdCBvciBjb21wb25lbnQuXG4gKi9cblxudmFyIEV2ZW50RW1pdHRlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgfVxuICAvKipcbiAgICogQWRkIGEgbGlzdGVuZXIgdG8gdGhlIHJlZ2lzdGVyZWQgZXZlbnQuXG4gICAqIEBwYXJhbSAtIE5hbWUgb2YgdGhlIGV2ZW50IHRvIGJlIGFkZGVkXG4gICAqIEBwYXJhbSAtIGxpc3RlbmVyIGZ1bmN0aW9uIG9mIHRoZSBldmVudCB0byBiZSBhZGRlZFxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gXCJAc2NlbmEvZXZlbnQtZW1pdHRlclwiO1xuICAgKiBjb3NudCBlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgKlxuICAgKiAvLyBBZGQgbGlzdGVuZXIgaW4gXCJhXCIgZXZlbnRcbiAgICogZW1pdHRlci5vbihcImFcIiwgKCkgPT4ge1xuICAgKiB9KTtcbiAgICogLy8gQWRkIGxpc3RlbmVyc1xuICAgKiBlbWl0dGVyLm9uKHtcbiAgICogIGE6ICgpID0+IHt9LFxuICAgKiAgYjogKCkgPT4ge30sXG4gICAqIH0pO1xuICAgKi9cblxuXG4gIHZhciBfX3Byb3RvID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLm9uID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAoaXNPYmplY3QoZXZlbnROYW1lKSkge1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBldmVudE5hbWUpIHtcbiAgICAgICAgdGhpcy5vbihuYW1lLCBldmVudE5hbWVbbmFtZV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hZGRFdmVudChldmVudE5hbWUsIGxpc3RlbmVyLCB7fSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBSZW1vdmUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgaW4gdGhlIGV2ZW50IHRhcmdldC5cbiAgICogQHBhcmFtIC0gTmFtZSBvZiB0aGUgZXZlbnQgdG8gYmUgcmVtb3ZlZFxuICAgKiBAcGFyYW0gLSBsaXN0ZW5lciBmdW5jdGlvbiBvZiB0aGUgZXZlbnQgdG8gYmUgcmVtb3ZlZFxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gXCJAc2NlbmEvZXZlbnQtZW1pdHRlclwiO1xuICAgKiBjb3NudCBlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgKlxuICAgKiAvLyBSZW1vdmUgYWxsIGxpc3RlbmVycy5cbiAgICogZW1pdHRlci5vZmYoKTtcbiAgICpcbiAgICogLy8gUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgaW4gXCJBXCIgZXZlbnQuXG4gICAqIGVtaXR0ZXIub2ZmKFwiYVwiKTtcbiAgICpcbiAgICpcbiAgICogLy8gUmVtb3ZlIFwibGlzdGVuZXJcIiBsaXN0ZW5lciBpbiBcImFcIiBldmVudC5cbiAgICogZW1pdHRlci5vZmYoXCJhXCIsIGxpc3RlbmVyKTtcbiAgICovXG5cblxuICBfX3Byb3RvLm9mZiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKCFldmVudE5hbWUpIHtcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoZXZlbnROYW1lKSkge1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBldmVudE5hbWUpIHtcbiAgICAgICAgdGhpcy5vZmYobmFtZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghbGlzdGVuZXIpIHtcbiAgICAgIHRoaXMuX2V2ZW50c1tldmVudE5hbWVdID0gW107XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHNbZXZlbnROYW1lXTtcblxuICAgICAgaWYgKGV2ZW50cykge1xuICAgICAgICB2YXIgaW5kZXggPSBmaW5kSW5kZXgoZXZlbnRzLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHJldHVybiBlLmxpc3RlbmVyID09PSBsaXN0ZW5lcjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICBldmVudHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogQWRkIGEgZGlzcG9zYWJsZSBsaXN0ZW5lciBhbmQgVXNlIHByb21pc2UgdG8gdGhlIHJlZ2lzdGVyZWQgZXZlbnQuXG4gICAqIEBwYXJhbSAtIE5hbWUgb2YgdGhlIGV2ZW50IHRvIGJlIGFkZGVkXG4gICAqIEBwYXJhbSAtIGRpc3Bvc2FibGUgbGlzdGVuZXIgZnVuY3Rpb24gb2YgdGhlIGV2ZW50IHRvIGJlIGFkZGVkXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSBcIkBzY2VuYS9ldmVudC1lbWl0dGVyXCI7XG4gICAqIGNvc250IGVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAqXG4gICAqIC8vIEFkZCBhIGRpc3Bvc2FibGUgbGlzdGVuZXIgaW4gXCJhXCIgZXZlbnRcbiAgICogZW1pdHRlci5vbmNlKFwiYVwiLCAoKSA9PiB7XG4gICAqIH0pO1xuICAgKlxuICAgKiAvLyBVc2UgUHJvbWlzZVxuICAgKiBlbWl0dGVyLm9uY2UoXCJhXCIpLnRoZW4oZSA9PiB7XG4gICAqIH0pO1xuICAgKi9cblxuXG4gIF9fcHJvdG8ub25jZSA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgdGhpcy5fYWRkRXZlbnQoZXZlbnROYW1lLCBsaXN0ZW5lciwge1xuICAgICAgICBvbmNlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIF90aGlzLl9hZGRFdmVudChldmVudE5hbWUsIHJlc29sdmUsIHtcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAgKiBGaXJlcyBhbiBldmVudCB0byBjYWxsIGxpc3RlbmVycy5cbiAgICogQHBhcmFtIC0gRXZlbnQgbmFtZVxuICAgKiBAcGFyYW0gLSBFdmVudCBwYXJhbWV0ZXJcbiAgICogQHJldHVybiBJZiBmYWxzZSwgc3RvcCB0aGUgZXZlbnQuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSBcIkBzY2VuYS9ldmVudC1lbWl0dGVyXCI7XG4gICAqXG4gICAqXG4gICAqIGNvbnN0IGVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAqXG4gICAqIGVtaXR0ZXIub24oXCJhXCIsIGUgPT4ge1xuICAgKiB9KTtcbiAgICpcbiAgICpcbiAgICogZW1pdHRlci5lbWl0KFwiYVwiLCB7XG4gICAqICAgYTogMSxcbiAgICogfSk7XG4gICAqL1xuXG5cbiAgX19wcm90by5lbWl0ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgcGFyYW0pIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKHBhcmFtID09PSB2b2lkIDApIHtcbiAgICAgIHBhcmFtID0ge307XG4gICAgfVxuXG4gICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50c1tldmVudE5hbWVdO1xuXG4gICAgaWYgKCFldmVudE5hbWUgfHwgIWV2ZW50cykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGlzU3RvcCA9IGZhbHNlO1xuICAgIHBhcmFtLmV2ZW50VHlwZSA9IGV2ZW50TmFtZTtcblxuICAgIHBhcmFtLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpc1N0b3AgPSB0cnVlO1xuICAgIH07XG5cbiAgICBwYXJhbS5jdXJyZW50VGFyZ2V0ID0gdGhpcztcblxuICAgIF9fc3ByZWFkQXJyYXlzKGV2ZW50cykuZm9yRWFjaChmdW5jdGlvbiAoaW5mbykge1xuICAgICAgaW5mby5saXN0ZW5lcihwYXJhbSk7XG5cbiAgICAgIGlmIChpbmZvLm9uY2UpIHtcbiAgICAgICAgX3RoaXMub2ZmKGV2ZW50TmFtZSwgaW5mby5saXN0ZW5lcik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gIWlzU3RvcDtcbiAgfTtcbiAgLyoqXG4gICAqIEZpcmVzIGFuIGV2ZW50IHRvIGNhbGwgbGlzdGVuZXJzLlxuICAgKiBAcGFyYW0gLSBFdmVudCBuYW1lXG4gICAqIEBwYXJhbSAtIEV2ZW50IHBhcmFtZXRlclxuICAgKiBAcmV0dXJuIElmIGZhbHNlLCBzdG9wIHRoZSBldmVudC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tIFwiQHNjZW5hL2V2ZW50LWVtaXR0ZXJcIjtcbiAgICpcbiAgICpcbiAgICogY29uc3QgZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICpcbiAgICogZW1pdHRlci5vbihcImFcIiwgZSA9PiB7XG4gICAqIH0pO1xuICAgKlxuICAgKlxuICAgKiBlbWl0dGVyLmVtaXQoXCJhXCIsIHtcbiAgICogICBhOiAxLFxuICAgKiB9KTtcbiAgICovXG5cbiAgLyoqXG4gICogRmlyZXMgYW4gZXZlbnQgdG8gY2FsbCBsaXN0ZW5lcnMuXG4gICogQHBhcmFtIC0gRXZlbnQgbmFtZVxuICAqIEBwYXJhbSAtIEV2ZW50IHBhcmFtZXRlclxuICAqIEByZXR1cm4gSWYgZmFsc2UsIHN0b3AgdGhlIGV2ZW50LlxuICAqIEBleGFtcGxlXG4gICpcbiAgKiBpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gXCJAc2NlbmEvZXZlbnQtZW1pdHRlclwiO1xuICAqXG4gICpcbiAgKiBjb25zdCBlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAqXG4gICogZW1pdHRlci5vbihcImFcIiwgZSA9PiB7XG4gICogfSk7XG4gICpcbiAgKiAvLyBlbWl0XG4gICogZW1pdHRlci50cmlnZ2VyKFwiYVwiLCB7XG4gICogICBhOiAxLFxuICAqIH0pO1xuICAqL1xuXG5cbiAgX19wcm90by50cmlnZ2VyID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgcGFyYW0pIHtcbiAgICBpZiAocGFyYW0gPT09IHZvaWQgMCkge1xuICAgICAgcGFyYW0gPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5lbWl0KGV2ZW50TmFtZSwgcGFyYW0pO1xuICB9O1xuXG4gIF9fcHJvdG8uX2FkZEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgIGV2ZW50c1tldmVudE5hbWVdID0gZXZlbnRzW2V2ZW50TmFtZV0gfHwgW107XG4gICAgdmFyIGxpc3RlbmVycyA9IGV2ZW50c1tldmVudE5hbWVdO1xuICAgIGxpc3RlbmVycy5wdXNoKF9fYXNzaWduKHtcbiAgICAgIGxpc3RlbmVyOiBsaXN0ZW5lclxuICAgIH0sIG9wdGlvbnMpKTtcbiAgfTtcblxuICByZXR1cm4gRXZlbnRFbWl0dGVyO1xufSgpO1xuXG5mdW5jdGlvbiBjcmVhdGVDb21tb25qc01vZHVsZShmbiwgbW9kdWxlKSB7XG4gIHJldHVybiBtb2R1bGUgPSB7XG4gICAgZXhwb3J0czoge31cbiAgfSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xufVxuXG52YXIga2V5Y29kZSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbi8vIFNvdXJjZTogaHR0cDovL2pzZmlkZGxlLm5ldC92V3g4Vi9cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTYwMzE5NS9mdWxsLWxpc3Qtb2YtamF2YXNjcmlwdC1rZXljb2Rlc1xuXG4vKipcbiAqIENvbmVuaWVuY2UgbWV0aG9kIHJldHVybnMgY29ycmVzcG9uZGluZyB2YWx1ZSBmb3IgZ2l2ZW4ga2V5TmFtZSBvciBrZXlDb2RlLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGtleUNvZGUge051bWJlcn0gb3Iga2V5TmFtZSB7U3RyaW5nfVxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGtleUNvZGUoc2VhcmNoSW5wdXQpIHtcbiAgLy8gS2V5Ym9hcmQgRXZlbnRzXG4gIGlmIChzZWFyY2hJbnB1dCAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIHNlYXJjaElucHV0KSB7XG4gICAgdmFyIGhhc0tleUNvZGUgPSBzZWFyY2hJbnB1dC53aGljaCB8fCBzZWFyY2hJbnB1dC5rZXlDb2RlIHx8IHNlYXJjaElucHV0LmNoYXJDb2RlO1xuICAgIGlmIChoYXNLZXlDb2RlKSBzZWFyY2hJbnB1dCA9IGhhc0tleUNvZGU7XG4gIH1cblxuICAvLyBOdW1iZXJzXG4gIGlmICgnbnVtYmVyJyA9PT0gdHlwZW9mIHNlYXJjaElucHV0KSByZXR1cm4gbmFtZXNbc2VhcmNoSW5wdXRdXG5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIChjYXN0IHRvIHN0cmluZylcbiAgdmFyIHNlYXJjaCA9IFN0cmluZyhzZWFyY2hJbnB1dCk7XG5cbiAgLy8gY2hlY2sgY29kZXNcbiAgdmFyIGZvdW5kTmFtZWRLZXkgPSBjb2Rlc1tzZWFyY2gudG9Mb3dlckNhc2UoKV07XG4gIGlmIChmb3VuZE5hbWVkS2V5KSByZXR1cm4gZm91bmROYW1lZEtleVxuXG4gIC8vIGNoZWNrIGFsaWFzZXNcbiAgdmFyIGZvdW5kTmFtZWRLZXkgPSBhbGlhc2VzW3NlYXJjaC50b0xvd2VyQ2FzZSgpXTtcbiAgaWYgKGZvdW5kTmFtZWRLZXkpIHJldHVybiBmb3VuZE5hbWVkS2V5XG5cbiAgLy8gd2VpcmQgY2hhcmFjdGVyP1xuICBpZiAoc2VhcmNoLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHNlYXJjaC5jaGFyQ29kZUF0KDApXG5cbiAgcmV0dXJuIHVuZGVmaW5lZFxufVxuXG4vKipcbiAqIENvbXBhcmVzIGEga2V5Ym9hcmQgZXZlbnQgd2l0aCBhIGdpdmVuIGtleUNvZGUgb3Iga2V5TmFtZS5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBLZXlib2FyZCBldmVudCB0aGF0IHNob3VsZCBiZSB0ZXN0ZWRcbiAqIEBwYXJhbSB7TWl4ZWR9IGtleUNvZGUge051bWJlcn0gb3Iga2V5TmFtZSB7U3RyaW5nfVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cbmtleUNvZGUuaXNFdmVudEtleSA9IGZ1bmN0aW9uIGlzRXZlbnRLZXkoZXZlbnQsIG5hbWVPckNvZGUpIHtcbiAgaWYgKGV2ZW50ICYmICdvYmplY3QnID09PSB0eXBlb2YgZXZlbnQpIHtcbiAgICB2YXIga2V5Q29kZSA9IGV2ZW50LndoaWNoIHx8IGV2ZW50LmtleUNvZGUgfHwgZXZlbnQuY2hhckNvZGU7XG4gICAgaWYgKGtleUNvZGUgPT09IG51bGwgfHwga2V5Q29kZSA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlmICh0eXBlb2YgbmFtZU9yQ29kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIGNoZWNrIGNvZGVzXG4gICAgICB2YXIgZm91bmROYW1lZEtleSA9IGNvZGVzW25hbWVPckNvZGUudG9Mb3dlckNhc2UoKV07XG4gICAgICBpZiAoZm91bmROYW1lZEtleSkgeyByZXR1cm4gZm91bmROYW1lZEtleSA9PT0ga2V5Q29kZTsgfVxuICAgIFxuICAgICAgLy8gY2hlY2sgYWxpYXNlc1xuICAgICAgdmFyIGZvdW5kTmFtZWRLZXkgPSBhbGlhc2VzW25hbWVPckNvZGUudG9Mb3dlckNhc2UoKV07XG4gICAgICBpZiAoZm91bmROYW1lZEtleSkgeyByZXR1cm4gZm91bmROYW1lZEtleSA9PT0ga2V5Q29kZTsgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG5hbWVPckNvZGUgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gbmFtZU9yQ29kZSA9PT0ga2V5Q29kZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBrZXlDb2RlO1xuXG4vKipcbiAqIEdldCBieSBuYW1lXG4gKlxuICogICBleHBvcnRzLmNvZGVbJ2VudGVyJ10gLy8gPT4gMTNcbiAqL1xuXG52YXIgY29kZXMgPSBleHBvcnRzLmNvZGUgPSBleHBvcnRzLmNvZGVzID0ge1xuICAnYmFja3NwYWNlJzogOCxcbiAgJ3RhYic6IDksXG4gICdlbnRlcic6IDEzLFxuICAnc2hpZnQnOiAxNixcbiAgJ2N0cmwnOiAxNyxcbiAgJ2FsdCc6IDE4LFxuICAncGF1c2UvYnJlYWsnOiAxOSxcbiAgJ2NhcHMgbG9jayc6IDIwLFxuICAnZXNjJzogMjcsXG4gICdzcGFjZSc6IDMyLFxuICAncGFnZSB1cCc6IDMzLFxuICAncGFnZSBkb3duJzogMzQsXG4gICdlbmQnOiAzNSxcbiAgJ2hvbWUnOiAzNixcbiAgJ2xlZnQnOiAzNyxcbiAgJ3VwJzogMzgsXG4gICdyaWdodCc6IDM5LFxuICAnZG93bic6IDQwLFxuICAnaW5zZXJ0JzogNDUsXG4gICdkZWxldGUnOiA0NixcbiAgJ2NvbW1hbmQnOiA5MSxcbiAgJ2xlZnQgY29tbWFuZCc6IDkxLFxuICAncmlnaHQgY29tbWFuZCc6IDkzLFxuICAnbnVtcGFkIConOiAxMDYsXG4gICdudW1wYWQgKyc6IDEwNyxcbiAgJ251bXBhZCAtJzogMTA5LFxuICAnbnVtcGFkIC4nOiAxMTAsXG4gICdudW1wYWQgLyc6IDExMSxcbiAgJ251bSBsb2NrJzogMTQ0LFxuICAnc2Nyb2xsIGxvY2snOiAxNDUsXG4gICdteSBjb21wdXRlcic6IDE4MixcbiAgJ215IGNhbGN1bGF0b3InOiAxODMsXG4gICc7JzogMTg2LFxuICAnPSc6IDE4NyxcbiAgJywnOiAxODgsXG4gICctJzogMTg5LFxuICAnLic6IDE5MCxcbiAgJy8nOiAxOTEsXG4gICdgJzogMTkyLFxuICAnWyc6IDIxOSxcbiAgJ1xcXFwnOiAyMjAsXG4gICddJzogMjIxLFxuICBcIidcIjogMjIyXG59O1xuXG4vLyBIZWxwZXIgYWxpYXNlc1xuXG52YXIgYWxpYXNlcyA9IGV4cG9ydHMuYWxpYXNlcyA9IHtcbiAgJ3dpbmRvd3MnOiA5MSxcbiAgJ+KHpyc6IDE2LFxuICAn4oylJzogMTgsXG4gICfijIMnOiAxNyxcbiAgJ+KMmCc6IDkxLFxuICAnY3RsJzogMTcsXG4gICdjb250cm9sJzogMTcsXG4gICdvcHRpb24nOiAxOCxcbiAgJ3BhdXNlJzogMTksXG4gICdicmVhayc6IDE5LFxuICAnY2Fwcyc6IDIwLFxuICAncmV0dXJuJzogMTMsXG4gICdlc2NhcGUnOiAyNyxcbiAgJ3NwYyc6IDMyLFxuICAnc3BhY2ViYXInOiAzMixcbiAgJ3BndXAnOiAzMyxcbiAgJ3BnZG4nOiAzNCxcbiAgJ2lucyc6IDQ1LFxuICAnZGVsJzogNDYsXG4gICdjbWQnOiA5MVxufTtcblxuLyohXG4gKiBQcm9ncmFtYXRpY2FsbHkgYWRkIHRoZSBmb2xsb3dpbmdcbiAqL1xuXG4vLyBsb3dlciBjYXNlIGNoYXJzXG5mb3IgKGkgPSA5NzsgaSA8IDEyMzsgaSsrKSBjb2Rlc1tTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGkgLSAzMjtcblxuLy8gbnVtYmVyc1xuZm9yICh2YXIgaSA9IDQ4OyBpIDwgNTg7IGkrKykgY29kZXNbaSAtIDQ4XSA9IGk7XG5cbi8vIGZ1bmN0aW9uIGtleXNcbmZvciAoaSA9IDE7IGkgPCAxMzsgaSsrKSBjb2Rlc1snZicraV0gPSBpICsgMTExO1xuXG4vLyBudW1wYWQga2V5c1xuZm9yIChpID0gMDsgaSA8IDEwOyBpKyspIGNvZGVzWydudW1wYWQgJytpXSA9IGkgKyA5NjtcblxuLyoqXG4gKiBHZXQgYnkgY29kZVxuICpcbiAqICAgZXhwb3J0cy5uYW1lWzEzXSAvLyA9PiAnRW50ZXInXG4gKi9cblxudmFyIG5hbWVzID0gZXhwb3J0cy5uYW1lcyA9IGV4cG9ydHMudGl0bGUgPSB7fTsgLy8gdGl0bGUgZm9yIGJhY2t3YXJkIGNvbXBhdFxuXG4vLyBDcmVhdGUgcmV2ZXJzZSBtYXBwaW5nXG5mb3IgKGkgaW4gY29kZXMpIG5hbWVzW2NvZGVzW2ldXSA9IGk7XG5cbi8vIEFkZCBhbGlhc2VzXG5mb3IgKHZhciBhbGlhcyBpbiBhbGlhc2VzKSB7XG4gIGNvZGVzW2FsaWFzXSA9IGFsaWFzZXNbYWxpYXNdO1xufVxufSk7XG52YXIga2V5Y29kZV8xID0ga2V5Y29kZS5jb2RlO1xudmFyIGtleWNvZGVfMiA9IGtleWNvZGUuY29kZXM7XG52YXIga2V5Y29kZV8zID0ga2V5Y29kZS5hbGlhc2VzO1xudmFyIGtleWNvZGVfNCA9IGtleWNvZGUubmFtZXM7XG52YXIga2V5Y29kZV81ID0ga2V5Y29kZS50aXRsZTtcblxudmFyIGNvZGVEYXRhID0ge1xuICBcIitcIjogXCJwbHVzXCIsXG4gIFwibGVmdCBjb21tYW5kXCI6IFwibWV0YVwiLFxuICBcInJpZ2h0IGNvbW1hbmRcIjogXCJtZXRhXCJcbn07XG52YXIga2V5c1NvcnQgPSB7XG4gIHNoaWZ0OiAxLFxuICBjdHJsOiAyLFxuICBhbHQ6IDMsXG4gIG1ldGE6IDRcbn07XG4vKipcbiAqIEBtZW1iZXJvZiBLZXlDb250cm9sbGVyXG4gKi9cblxuZnVuY3Rpb24gZ2V0S2V5KGtleUNvZGUpIHtcbiAgdmFyIGtleSA9IGtleWNvZGVfNFtrZXlDb2RlXSB8fCBcIlwiO1xuXG4gIGZvciAodmFyIG5hbWUgaW4gY29kZURhdGEpIHtcbiAgICBrZXkgPSBrZXkucmVwbGFjZShuYW1lLCBjb2RlRGF0YVtuYW1lXSk7XG4gIH1cblxuICByZXR1cm4ga2V5LnJlcGxhY2UoL1xccy9nLCBcIlwiKTtcbn1cbi8qKlxuICogQG1lbWJlcm9mIEtleUNvbnRyb2xsZXJcbiAqL1xuXG5mdW5jdGlvbiBnZXRDb21iaShlLCBrZXkpIHtcbiAgaWYgKGtleSA9PT0gdm9pZCAwKSB7XG4gICAga2V5ID0gZ2V0S2V5KGUua2V5Q29kZSk7XG4gIH1cblxuICB2YXIga2V5cyA9IGdldE1vZGlmaWVyQ29tYmkoZSk7XG4gIGtleXMuaW5kZXhPZihrZXkpID09PSAtMSAmJiBrZXlzLnB1c2goa2V5KTtcbiAgcmV0dXJuIGtleXMuZmlsdGVyKEJvb2xlYW4pO1xufVxuLyoqXG4gKiBAbWVtYmVyb2YgS2V5Q29udHJvbGxlclxuICovXG5cbmZ1bmN0aW9uIGdldE1vZGlmaWVyQ29tYmkoZSkge1xuICB2YXIga2V5cyA9IFtlLnNoaWZ0S2V5ICYmIFwic2hpZnRcIiwgZS5jdHJsS2V5ICYmIFwiY3RybFwiLCBlLmFsdEtleSAmJiBcImFsdFwiLCBlLm1ldGFLZXkgJiYgXCJtZXRhXCJdO1xuICByZXR1cm4ga2V5cy5maWx0ZXIoQm9vbGVhbik7XG59XG5cbmZ1bmN0aW9uIGdldEFycmFuZ2VDb21iaShrZXlzKSB7XG4gIHZhciBhcnJhbmdlS2V5cyA9IGtleXMuc2xpY2UoKTtcbiAgYXJyYW5nZUtleXMuc29ydChmdW5jdGlvbiAocHJldiwgbmV4dCkge1xuICAgIHZhciBwcmV2U2NvcmUgPSBrZXlzU29ydFtwcmV2XSB8fCA1O1xuICAgIHZhciBuZXh0U2NvcmUgPSBrZXlzU29ydFtuZXh0XSB8fCA1O1xuICAgIHJldHVybiBwcmV2U2NvcmUgLSBuZXh0U2NvcmU7XG4gIH0pO1xuICByZXR1cm4gYXJyYW5nZUtleXM7XG59XG5cbnZhciBnbG9iYWxLZXlDb250cm9sbGVyO1xuLyoqXG4gKi9cblxudmFyIEtleUNvbnRyb2xsZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoS2V5Q29udHJvbGxlciwgX3N1cGVyKTtcbiAgLyoqXG4gICAqXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gS2V5Q29udHJvbGxlcihjb250YWluZXIpIHtcbiAgICBpZiAoY29udGFpbmVyID09PSB2b2lkIDApIHtcbiAgICAgIGNvbnRhaW5lciA9IHdpbmRvdztcbiAgICB9XG5cbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIC8qKlxuICAgICAqL1xuXG4gICAgX3RoaXMuY3RybEtleSA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqL1xuXG4gICAgX3RoaXMuYWx0S2V5ID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cblxuICAgIF90aGlzLnNoaWZ0S2V5ID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cblxuICAgIF90aGlzLm1ldGFLZXkgPSBmYWxzZTtcblxuICAgIF90aGlzLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuY3RybEtleSA9IGZhbHNlO1xuICAgICAgX3RoaXMuYWx0S2V5ID0gZmFsc2U7XG4gICAgICBfdGhpcy5zaGlmdEtleSA9IGZhbHNlO1xuICAgICAgX3RoaXMubWV0YUtleSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH07XG5cbiAgICBfdGhpcy5rZXlkb3duRXZlbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgX3RoaXMudHJpZ2dlckV2ZW50KFwia2V5ZG93blwiLCBlKTtcbiAgICB9O1xuXG4gICAgX3RoaXMua2V5dXBFdmVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBfdGhpcy50cmlnZ2VyRXZlbnQoXCJrZXl1cFwiLCBlKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuYmx1ciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLmNsZWFyKCk7XG5cbiAgICAgIF90aGlzLnRyaWdnZXIoXCJibHVyXCIpO1xuICAgIH07XG5cbiAgICBhZGRFdmVudChjb250YWluZXIsIFwiYmx1clwiLCBfdGhpcy5ibHVyKTtcbiAgICBhZGRFdmVudChjb250YWluZXIsIFwia2V5ZG93blwiLCBfdGhpcy5rZXlkb3duRXZlbnQpO1xuICAgIGFkZEV2ZW50KGNvbnRhaW5lciwgXCJrZXl1cFwiLCBfdGhpcy5rZXl1cEV2ZW50KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX19wcm90byA9IEtleUNvbnRyb2xsZXIucHJvdG90eXBlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoS2V5Q29udHJvbGxlciwgXCJnbG9iYWxcIiwge1xuICAgIC8qKlxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGdsb2JhbEtleUNvbnRyb2xsZXIgfHwgKGdsb2JhbEtleUNvbnRyb2xsZXIgPSBuZXcgS2V5Q29udHJvbGxlcigpKTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcblxuICBLZXlDb250cm9sbGVyLnNldEdsb2JhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5nbG9iYWw7XG4gIH07XG4gIC8qKlxuICAgKlxuICAgKi9cblxuXG4gIF9fcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgdGhpcy5jbGVhcigpO1xuICAgIHRoaXMub2ZmKCk7XG4gICAgcmVtb3ZlRXZlbnQoY29udGFpbmVyLCBcImJsdXJcIiwgdGhpcy5ibHVyKTtcbiAgICByZW1vdmVFdmVudChjb250YWluZXIsIFwia2V5ZG93blwiLCB0aGlzLmtleWRvd25FdmVudCk7XG4gICAgcmVtb3ZlRXZlbnQoY29udGFpbmVyLCBcImtleXVwXCIsIHRoaXMua2V5dXBFdmVudCk7XG4gIH07XG4gIC8qKlxuICAgKlxuICAgKi9cblxuXG4gIF9fcHJvdG8ua2V5ZG93biA9IGZ1bmN0aW9uIChjb21iLCBjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLmFkZEV2ZW50KFwia2V5ZG93blwiLCBjb21iLCBjYWxsYmFjayk7XG4gIH07XG4gIC8qKlxuICAgKlxuICAgKi9cblxuXG4gIF9fcHJvdG8ub2ZmS2V5ZG93biA9IGZ1bmN0aW9uIChjb21iLCBjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLnJlbW92ZUV2ZW50KFwia2V5ZG93blwiLCBjb21iLCBjYWxsYmFjayk7XG4gIH07XG4gIC8qKlxuICAgKlxuICAgKi9cblxuXG4gIF9fcHJvdG8ub2ZmS2V5dXAgPSBmdW5jdGlvbiAoY29tYiwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5yZW1vdmVFdmVudChcImtleXVwXCIsIGNvbWIsIGNhbGxiYWNrKTtcbiAgfTtcbiAgLyoqXG4gICAqXG4gICAqL1xuXG5cbiAgX19wcm90by5rZXl1cCA9IGZ1bmN0aW9uIChjb21iLCBjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLmFkZEV2ZW50KFwia2V5dXBcIiwgY29tYiwgY2FsbGJhY2spO1xuICB9O1xuXG4gIF9fcHJvdG8uYWRkRXZlbnQgPSBmdW5jdGlvbiAodHlwZSwgY29tYiwgY2FsbGJhY2spIHtcbiAgICBpZiAoaXNBcnJheShjb21iKSkge1xuICAgICAgdGhpcy5vbih0eXBlICsgXCIuXCIgKyBnZXRBcnJhbmdlQ29tYmkoY29tYikuam9pbihcIi5cIiksIGNhbGxiYWNrKTtcbiAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKGNvbWIpKSB7XG4gICAgICB0aGlzLm9uKHR5cGUgKyBcIi5cIiArIGNvbWIsIGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vbih0eXBlLCBjb21iKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfX3Byb3RvLnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24gKHR5cGUsIGNvbWIsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGlzQXJyYXkoY29tYikpIHtcbiAgICAgIHRoaXMub2ZmKHR5cGUgKyBcIi5cIiArIGdldEFycmFuZ2VDb21iaShjb21iKS5qb2luKFwiLlwiKSwgY2FsbGJhY2spO1xuICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcoY29tYikpIHtcbiAgICAgIHRoaXMub2ZmKHR5cGUgKyBcIi5cIiArIGNvbWIsIGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vZmYodHlwZSwgY29tYik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX19wcm90by50cmlnZ2VyRXZlbnQgPSBmdW5jdGlvbiAodHlwZSwgZSkge1xuICAgIHRoaXMuY3RybEtleSA9IGUuY3RybEtleTtcbiAgICB0aGlzLnNoaWZ0S2V5ID0gZS5zaGlmdEtleTtcbiAgICB0aGlzLmFsdEtleSA9IGUuYWx0S2V5O1xuICAgIHRoaXMubWV0YUtleSA9IGUubWV0YUtleTtcbiAgICB2YXIga2V5ID0gZ2V0S2V5KGUua2V5Q29kZSk7XG4gICAgdmFyIGlzVG9nZ2xlID0ga2V5ID09PSBcImN0cmxcIiB8fCBrZXkgPT09IFwic2hpZnRcIiB8fCBrZXkgPT09IFwibWV0YVwiIHx8IGtleSA9PT0gXCJhbHRcIjtcbiAgICB2YXIgcGFyYW0gPSB7XG4gICAgICBrZXk6IGtleSxcbiAgICAgIGlzVG9nZ2xlOiBpc1RvZ2dsZSxcbiAgICAgIGlucHV0RXZlbnQ6IGUsXG4gICAgICBrZXlDb2RlOiBlLmtleUNvZGUsXG4gICAgICBjdHJsS2V5OiBlLmN0cmxLZXksXG4gICAgICBhbHRLZXk6IGUuYWx0S2V5LFxuICAgICAgc2hpZnRLZXk6IGUuc2hpZnRLZXksXG4gICAgICBtZXRhS2V5OiBlLm1ldGFLZXlcbiAgICB9O1xuICAgIHRoaXMudHJpZ2dlcih0eXBlLCBwYXJhbSk7XG4gICAgdGhpcy50cmlnZ2VyKHR5cGUgKyBcIi5cIiArIGtleSwgcGFyYW0pO1xuICAgIHZhciBjb21iaSA9IGdldENvbWJpKGUsIGtleSk7XG4gICAgY29tYmkubGVuZ3RoID4gMSAmJiB0aGlzLnRyaWdnZXIodHlwZSArIFwiLlwiICsgY29tYmkuam9pbihcIi5cIiksIHBhcmFtKTtcbiAgfTtcblxuICByZXR1cm4gS2V5Q29udHJvbGxlcjtcbn0oRXZlbnRFbWl0dGVyKTtcblxuZXhwb3J0IGRlZmF1bHQgS2V5Q29udHJvbGxlcjtcbmV4cG9ydCB7IGdldENvbWJpLCBnZXRLZXksIGdldE1vZGlmaWVyQ29tYmkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWtleWNvbi5lc20uanMubWFwXG4iLCIvKlxuQ29weXJpZ2h0IChjKSAyMDE5IERheWJydXNoXG5uYW1lOiBtb3ZlYWJsZVxubGljZW5zZTogTUlUXG5hdXRob3I6IERheWJydXNoXG5yZXBvc2l0b3J5OiBnaXQraHR0cHM6Ly9naXRodWIuY29tL2RheWJydXNoL21vdmVhYmxlLmdpdFxudmVyc2lvbjogMC4yOC4wXG4qL1xuaW1wb3J0IHsgcmVmLCBQcm9wZXJ0aWVzIH0gZnJvbSAnZnJhbWV3b3JrLXV0aWxzJztcbmltcG9ydCB7IGNyZWF0ZVBvcnRhbCwgY3JlYXRlRWxlbWVudCwgQ29tcG9uZW50LCByZW5kZXIgfSBmcm9tICdyZWFjdC1zaW1wbGUtY29tcGF0JztcbmltcG9ydCBNb3ZlYWJsZSQxLCB7IE1PVkVBQkxFX1BST1BTLCBNT1ZFQUJMRV9NRVRIT0RTLCBNT1ZFQUJMRV9FVkVOVFMsIE1PVkVBQkxFX1BST1BTX01BUCwgZ2V0RWxlbWVudEluZm8gYXMgZ2V0RWxlbWVudEluZm8kMSwgbWFrZUFibGUgYXMgbWFrZUFibGUkMSB9IGZyb20gJ3JlYWN0LWNvbXBhdC1tb3ZlYWJsZSc7XG5pbXBvcnQgeyBpc09iamVjdCwgZmluZEluZGV4LCBjYW1lbGl6ZSwgaXNBcnJheSB9IGZyb20gJ0BkYXlicnVzaC91dGlscyc7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XG5cbnZhciBJbm5lck1vdmVhYmxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKElubmVyTW92ZWFibGUsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gSW5uZXJNb3ZlYWJsZShwcm9wcykge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMuc3RhdGUgPSB7fTtcbiAgICBfdGhpcy5zdGF0ZSA9IF90aGlzLnByb3BzO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfX3Byb3RvID0gSW5uZXJNb3ZlYWJsZS5wcm90b3R5cGU7XG5cbiAgX19wcm90by5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVBvcnRhbChjcmVhdGVFbGVtZW50KE1vdmVhYmxlJDEsIF9fYXNzaWduKHtcbiAgICAgIHJlZjogcmVmKHRoaXMsIFwibW92ZWFibGVcIilcbiAgICB9LCB0aGlzLnN0YXRlKSksIHRoaXMuc3RhdGUucGFyZW50RWxlbWVudCk7XG4gIH07XG5cbiAgcmV0dXJuIElubmVyTW92ZWFibGU7XG59KENvbXBvbmVudCk7XG5cbnZhciBQUk9QRVJUSUVTID0gTU9WRUFCTEVfUFJPUFM7XG52YXIgTUVUSE9EUyA9IE1PVkVBQkxFX01FVEhPRFM7XG52YXIgRVZFTlRTID0gTU9WRUFCTEVfRVZFTlRTO1xudmFyIFBST1BTX01BUCA9IE1PVkVBQkxFX1BST1BTX01BUDtcblxuLypcbkNvcHlyaWdodCAoYykgMjAxOSBEYXlicnVzaFxubmFtZTogQHNjZW5hL2V2ZW50LWVtaXR0ZXJcbmxpY2Vuc2U6IE1JVFxuYXV0aG9yOiBEYXlicnVzaFxucmVwb3NpdG9yeTogZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS9kYXlicnVzaC9nZXN0dXJlLmdpdFxudmVyc2lvbjogMS4wLjNcbiovXG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG52YXIgX19hc3NpZ24kMSA9IGZ1bmN0aW9uICgpIHtcbiAgX19hc3NpZ24kMSA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xuICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdDtcbiAgfTtcblxuICByZXR1cm4gX19hc3NpZ24kMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbmZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xuICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcblxuICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKSByW2tdID0gYVtqXTtcblxuICByZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnQgRXZlbnRFbWl0dGVyIG9uIG9iamVjdCBvciBjb21wb25lbnQuXG4gKi9cblxudmFyIEV2ZW50RW1pdHRlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgfVxuICAvKipcbiAgICogQWRkIGEgbGlzdGVuZXIgdG8gdGhlIHJlZ2lzdGVyZWQgZXZlbnQuXG4gICAqIEBwYXJhbSAtIE5hbWUgb2YgdGhlIGV2ZW50IHRvIGJlIGFkZGVkXG4gICAqIEBwYXJhbSAtIGxpc3RlbmVyIGZ1bmN0aW9uIG9mIHRoZSBldmVudCB0byBiZSBhZGRlZFxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gXCJAc2NlbmEvZXZlbnQtZW1pdHRlclwiO1xuICAgKiBjb3NudCBlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgKlxuICAgKiAvLyBBZGQgbGlzdGVuZXIgaW4gXCJhXCIgZXZlbnRcbiAgICogZW1pdHRlci5vbihcImFcIiwgKCkgPT4ge1xuICAgKiB9KTtcbiAgICogLy8gQWRkIGxpc3RlbmVyc1xuICAgKiBlbWl0dGVyLm9uKHtcbiAgICogIGE6ICgpID0+IHt9LFxuICAgKiAgYjogKCkgPT4ge30sXG4gICAqIH0pO1xuICAgKi9cblxuXG4gIHZhciBfX3Byb3RvID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLm9uID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAoaXNPYmplY3QoZXZlbnROYW1lKSkge1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBldmVudE5hbWUpIHtcbiAgICAgICAgdGhpcy5vbihuYW1lLCBldmVudE5hbWVbbmFtZV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hZGRFdmVudChldmVudE5hbWUsIGxpc3RlbmVyLCB7fSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBSZW1vdmUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgaW4gdGhlIGV2ZW50IHRhcmdldC5cbiAgICogQHBhcmFtIC0gTmFtZSBvZiB0aGUgZXZlbnQgdG8gYmUgcmVtb3ZlZFxuICAgKiBAcGFyYW0gLSBsaXN0ZW5lciBmdW5jdGlvbiBvZiB0aGUgZXZlbnQgdG8gYmUgcmVtb3ZlZFxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gXCJAc2NlbmEvZXZlbnQtZW1pdHRlclwiO1xuICAgKiBjb3NudCBlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgKlxuICAgKiAvLyBSZW1vdmUgYWxsIGxpc3RlbmVycy5cbiAgICogZW1pdHRlci5vZmYoKTtcbiAgICpcbiAgICogLy8gUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgaW4gXCJBXCIgZXZlbnQuXG4gICAqIGVtaXR0ZXIub2ZmKFwiYVwiKTtcbiAgICpcbiAgICpcbiAgICogLy8gUmVtb3ZlIFwibGlzdGVuZXJcIiBsaXN0ZW5lciBpbiBcImFcIiBldmVudC5cbiAgICogZW1pdHRlci5vZmYoXCJhXCIsIGxpc3RlbmVyKTtcbiAgICovXG5cblxuICBfX3Byb3RvLm9mZiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKCFldmVudE5hbWUpIHtcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoZXZlbnROYW1lKSkge1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBldmVudE5hbWUpIHtcbiAgICAgICAgdGhpcy5vZmYobmFtZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghbGlzdGVuZXIpIHtcbiAgICAgIHRoaXMuX2V2ZW50c1tldmVudE5hbWVdID0gW107XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHNbZXZlbnROYW1lXTtcblxuICAgICAgaWYgKGV2ZW50cykge1xuICAgICAgICB2YXIgaW5kZXggPSBmaW5kSW5kZXgoZXZlbnRzLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHJldHVybiBlLmxpc3RlbmVyID09PSBsaXN0ZW5lcjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICBldmVudHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogQWRkIGEgZGlzcG9zYWJsZSBsaXN0ZW5lciBhbmQgVXNlIHByb21pc2UgdG8gdGhlIHJlZ2lzdGVyZWQgZXZlbnQuXG4gICAqIEBwYXJhbSAtIE5hbWUgb2YgdGhlIGV2ZW50IHRvIGJlIGFkZGVkXG4gICAqIEBwYXJhbSAtIGRpc3Bvc2FibGUgbGlzdGVuZXIgZnVuY3Rpb24gb2YgdGhlIGV2ZW50IHRvIGJlIGFkZGVkXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSBcIkBzY2VuYS9ldmVudC1lbWl0dGVyXCI7XG4gICAqIGNvc250IGVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAqXG4gICAqIC8vIEFkZCBhIGRpc3Bvc2FibGUgbGlzdGVuZXIgaW4gXCJhXCIgZXZlbnRcbiAgICogZW1pdHRlci5vbmNlKFwiYVwiLCAoKSA9PiB7XG4gICAqIH0pO1xuICAgKlxuICAgKiAvLyBVc2UgUHJvbWlzZVxuICAgKiBlbWl0dGVyLm9uY2UoXCJhXCIpLnRoZW4oZSA9PiB7XG4gICAqIH0pO1xuICAgKi9cblxuXG4gIF9fcHJvdG8ub25jZSA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgdGhpcy5fYWRkRXZlbnQoZXZlbnROYW1lLCBsaXN0ZW5lciwge1xuICAgICAgICBvbmNlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIF90aGlzLl9hZGRFdmVudChldmVudE5hbWUsIHJlc29sdmUsIHtcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAgKiBGaXJlcyBhbiBldmVudCB0byBjYWxsIGxpc3RlbmVycy5cbiAgICogQHBhcmFtIC0gRXZlbnQgbmFtZVxuICAgKiBAcGFyYW0gLSBFdmVudCBwYXJhbWV0ZXJcbiAgICogQHJldHVybiBJZiBmYWxzZSwgc3RvcCB0aGUgZXZlbnQuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSBcIkBzY2VuYS9ldmVudC1lbWl0dGVyXCI7XG4gICAqXG4gICAqXG4gICAqIGNvbnN0IGVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAqXG4gICAqIGVtaXR0ZXIub24oXCJhXCIsIGUgPT4ge1xuICAgKiB9KTtcbiAgICpcbiAgICpcbiAgICogZW1pdHRlci5lbWl0KFwiYVwiLCB7XG4gICAqICAgYTogMSxcbiAgICogfSk7XG4gICAqL1xuXG5cbiAgX19wcm90by5lbWl0ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgcGFyYW0pIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKHBhcmFtID09PSB2b2lkIDApIHtcbiAgICAgIHBhcmFtID0ge307XG4gICAgfVxuXG4gICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50c1tldmVudE5hbWVdO1xuXG4gICAgaWYgKCFldmVudE5hbWUgfHwgIWV2ZW50cykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGlzU3RvcCA9IGZhbHNlO1xuICAgIHBhcmFtLmV2ZW50VHlwZSA9IGV2ZW50TmFtZTtcblxuICAgIHBhcmFtLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpc1N0b3AgPSB0cnVlO1xuICAgIH07XG5cbiAgICBwYXJhbS5jdXJyZW50VGFyZ2V0ID0gdGhpcztcblxuICAgIF9fc3ByZWFkQXJyYXlzKGV2ZW50cykuZm9yRWFjaChmdW5jdGlvbiAoaW5mbykge1xuICAgICAgaW5mby5saXN0ZW5lcihwYXJhbSk7XG5cbiAgICAgIGlmIChpbmZvLm9uY2UpIHtcbiAgICAgICAgX3RoaXMub2ZmKGV2ZW50TmFtZSwgaW5mby5saXN0ZW5lcik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gIWlzU3RvcDtcbiAgfTtcbiAgLyoqXG4gICAqIEZpcmVzIGFuIGV2ZW50IHRvIGNhbGwgbGlzdGVuZXJzLlxuICAgKiBAcGFyYW0gLSBFdmVudCBuYW1lXG4gICAqIEBwYXJhbSAtIEV2ZW50IHBhcmFtZXRlclxuICAgKiBAcmV0dXJuIElmIGZhbHNlLCBzdG9wIHRoZSBldmVudC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tIFwiQHNjZW5hL2V2ZW50LWVtaXR0ZXJcIjtcbiAgICpcbiAgICpcbiAgICogY29uc3QgZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICpcbiAgICogZW1pdHRlci5vbihcImFcIiwgZSA9PiB7XG4gICAqIH0pO1xuICAgKlxuICAgKlxuICAgKiBlbWl0dGVyLmVtaXQoXCJhXCIsIHtcbiAgICogICBhOiAxLFxuICAgKiB9KTtcbiAgICovXG5cbiAgLyoqXG4gICogRmlyZXMgYW4gZXZlbnQgdG8gY2FsbCBsaXN0ZW5lcnMuXG4gICogQHBhcmFtIC0gRXZlbnQgbmFtZVxuICAqIEBwYXJhbSAtIEV2ZW50IHBhcmFtZXRlclxuICAqIEByZXR1cm4gSWYgZmFsc2UsIHN0b3AgdGhlIGV2ZW50LlxuICAqIEBleGFtcGxlXG4gICpcbiAgKiBpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gXCJAc2NlbmEvZXZlbnQtZW1pdHRlclwiO1xuICAqXG4gICpcbiAgKiBjb25zdCBlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAqXG4gICogZW1pdHRlci5vbihcImFcIiwgZSA9PiB7XG4gICogfSk7XG4gICpcbiAgKiAvLyBlbWl0XG4gICogZW1pdHRlci50cmlnZ2VyKFwiYVwiLCB7XG4gICogICBhOiAxLFxuICAqIH0pO1xuICAqL1xuXG5cbiAgX19wcm90by50cmlnZ2VyID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgcGFyYW0pIHtcbiAgICBpZiAocGFyYW0gPT09IHZvaWQgMCkge1xuICAgICAgcGFyYW0gPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5lbWl0KGV2ZW50TmFtZSwgcGFyYW0pO1xuICB9O1xuXG4gIF9fcHJvdG8uX2FkZEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgIGV2ZW50c1tldmVudE5hbWVdID0gZXZlbnRzW2V2ZW50TmFtZV0gfHwgW107XG4gICAgdmFyIGxpc3RlbmVycyA9IGV2ZW50c1tldmVudE5hbWVdO1xuICAgIGxpc3RlbmVycy5wdXNoKF9fYXNzaWduJDEoe1xuICAgICAgbGlzdGVuZXI6IGxpc3RlbmVyXG4gICAgfSwgb3B0aW9ucykpO1xuICB9O1xuXG4gIHJldHVybiBFdmVudEVtaXR0ZXI7XG59KCk7XG5cbi8qKlxuICogTW92ZWFibGUgaXMgRHJhZ2dhYmxlISBSZXNpemFibGUhIFNjYWxhYmxlISBSb3RhdGFibGUhXG4gKiBAc29ydCAxXG4gKiBAYWxpYXMgTW92ZWFibGVcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICovXG5cbnZhciBNb3ZlYWJsZU1hbmFnZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoTW92ZWFibGVNYW5hZ2VyLCBfc3VwZXIpO1xuICAvKipcbiAgICpcbiAgICovXG5cblxuICBmdW5jdGlvbiBNb3ZlYWJsZU1hbmFnZXIocGFyZW50RWxlbWVudCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMudGVtcEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG4gICAgdmFyIG5leHRPcHRpb25zID0gX19hc3NpZ24oe30sIG9wdGlvbnMpO1xuXG4gICAgdmFyIGV2ZW50cyA9IHt9O1xuICAgIEVWRU5UUy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBldmVudHNbY2FtZWxpemUoXCJvbiBcIiArIG5hbWUpXSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy50cmlnZ2VyKG5hbWUsIGUpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICByZW5kZXIoY3JlYXRlRWxlbWVudChJbm5lck1vdmVhYmxlLCBfX2Fzc2lnbih7XG4gICAgICByZWY6IHJlZihfdGhpcywgXCJpbm5lck1vdmVhYmxlXCIpLFxuICAgICAgcGFyZW50RWxlbWVudDogcGFyZW50RWxlbWVudFxuICAgIH0sIG5leHRPcHRpb25zLCBldmVudHMpKSwgX3RoaXMudGVtcEVsZW1lbnQpO1xuICAgIHZhciB0YXJnZXQgPSBuZXh0T3B0aW9ucy50YXJnZXQ7XG5cbiAgICBpZiAoaXNBcnJheSh0YXJnZXQpICYmIHRhcmdldC5sZW5ndGggPiAxKSB7XG4gICAgICBfdGhpcy51cGRhdGVSZWN0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9fcHJvdG8gPSBNb3ZlYWJsZU1hbmFnZXIucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8uc2V0U3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5pbm5lck1vdmVhYmxlLnNldFN0YXRlKHN0YXRlLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgX19wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHJlbmRlcihudWxsLCB0aGlzLnRlbXBFbGVtZW50KTtcbiAgICB0aGlzLm9mZigpO1xuICAgIHRoaXMudGVtcEVsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuaW5uZXJNb3ZlYWJsZSA9IG51bGw7XG4gIH07XG5cbiAgX19wcm90by5nZXRNb3ZlYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbm5lck1vdmVhYmxlLm1vdmVhYmxlO1xuICB9O1xuXG4gIE1vdmVhYmxlTWFuYWdlciA9IF9fZGVjb3JhdGUoW1Byb3BlcnRpZXMoTUVUSE9EUywgZnVuY3Rpb24gKHByb3RvdHlwZSwgcHJvcGVydHkpIHtcbiAgICBpZiAocHJvdG90eXBlW3Byb3BlcnR5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHByb3RvdHlwZVtwcm9wZXJ0eV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYXJncyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWxmID0gdGhpcy5nZXRNb3ZlYWJsZSgpO1xuXG4gICAgICBpZiAoIXNlbGYgfHwgIXNlbGZbcHJvcGVydHldKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGZbcHJvcGVydHldLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIH07XG4gIH0pLCBQcm9wZXJ0aWVzKFBST1BFUlRJRVMsIGZ1bmN0aW9uIChwcm90b3R5cGUsIHByb3BlcnR5KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgcHJvcGVydHksIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRNb3ZlYWJsZSgpLnByb3BzW3Byb3BlcnR5XTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgX2E7XG5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSgoX2EgPSB7fSwgX2FbcHJvcGVydHldID0gdmFsdWUsIF9hKSk7XG4gICAgICB9LFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9KV0sIE1vdmVhYmxlTWFuYWdlcik7XG4gIHJldHVybiBNb3ZlYWJsZU1hbmFnZXI7XG59KEV2ZW50RW1pdHRlcik7XG5cbnZhciBNb3ZlYWJsZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhNb3ZlYWJsZSwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBNb3ZlYWJsZSgpIHtcbiAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICByZXR1cm4gTW92ZWFibGU7XG59KE1vdmVhYmxlTWFuYWdlcik7XG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRJbmZvKHRhcmdldCwgY29udGFpbmVyLCByb290Q29udGFpbmVyKSB7XG4gIHJldHVybiBnZXRFbGVtZW50SW5mbyQxKHRhcmdldCwgY29udGFpbmVyLCByb290Q29udGFpbmVyKTtcbn1cbmZ1bmN0aW9uIG1ha2VBYmxlKG5hbWUsIGFibGUpIHtcbiAgcmV0dXJuIG1ha2VBYmxlJDEobmFtZSwgYWJsZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1vdmVhYmxlO1xuZXhwb3J0IHsgRVZFTlRTLCBNRVRIT0RTLCBQUk9QRVJUSUVTLCBQUk9QU19NQVAsIGdldEVsZW1lbnRJbmZvLCBtYWtlQWJsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW92ZWFibGUuZXNtLmpzLm1hcFxuIiwiLypcbkNvcHlyaWdodCAoYykgMjAyMCBEYXlicnVzaFxubmFtZTogb3ZlcmxhcC1hcmVhXG5saWNlbnNlOiBNSVRcbmF1dGhvcjogRGF5YnJ1c2hcbnJlcG9zaXRvcnk6IGdpdCtodHRwczovL2dpdGh1Yi5jb20vZGF5YnJ1c2gvb3ZlcmxhcC1hcmVhLmdpdFxudmVyc2lvbjogMS4wLjBcbiovXG5pbXBvcnQgeyBzdW0sIGZpbmRJbmRleCwgZ2V0U2hhcGVEaXJlY3Rpb24sIGdldERpc3QgfSBmcm9tICdAZGF5YnJ1c2gvdXRpbHMnO1xuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XG4gIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuXG4gIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKykgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspIHJba10gPSBhW2pdO1xuXG4gIHJldHVybiByO1xufVxuXG4vKipcbiAqIEBuYW1lc3BhY2UgT3ZlcmxhcEFyZWFcbiAqL1xuXG4vKipcbiAqIEdldHMgdGhlIHNpemUgb2YgYSBzaGFwZSAocG9seWdvbikgbWFkZSBvZiBwb2ludHMuXG4gKiBAbWVtYmVyb2YgT3ZlcmxhcEFyZWFcbiAqL1xuXG5mdW5jdGlvbiBnZXRBcmVhU2l6ZShwb2ludHMpIHtcbiAgaWYgKHBvaW50cy5sZW5ndGggPCAzKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gTWF0aC5hYnMoc3VtKHBvaW50cy5tYXAoZnVuY3Rpb24gKHBvaW50LCBpKSB7XG4gICAgdmFyIG5leHRQb2ludCA9IHBvaW50c1tpICsgMV0gfHwgcG9pbnRzWzBdO1xuICAgIHJldHVybiBwb2ludFswXSAqIG5leHRQb2ludFsxXSAtIG5leHRQb2ludFswXSAqIHBvaW50WzFdO1xuICB9KSkpIC8gMjtcbn1cbi8qKlxuICogR2V0IHBvaW50cyB0aGF0IGZpdCB0aGUgcmVjdCxcbiAqIEBtZW1iZXJvZiBPdmVybGFwQXJlYVxuICovXG5cbmZ1bmN0aW9uIGZpdFBvaW50cyhwb2ludHMsIHJlY3QpIHtcbiAgdmFyIHdpZHRoID0gcmVjdC53aWR0aCxcbiAgICAgIGhlaWdodCA9IHJlY3QuaGVpZ2h0LFxuICAgICAgbGVmdCA9IHJlY3QubGVmdCxcbiAgICAgIHRvcCA9IHJlY3QudG9wO1xuXG4gIHZhciBfYSA9IGdldE1pbk1heHMocG9pbnRzKSxcbiAgICAgIG1pblggPSBfYS5taW5YLFxuICAgICAgbWluWSA9IF9hLm1pblksXG4gICAgICBtYXhYID0gX2EubWF4WCxcbiAgICAgIG1heFkgPSBfYS5tYXhZO1xuXG4gIHZhciByYXRpb1ggPSB3aWR0aCAvIChtYXhYIC0gbWluWCk7XG4gIHZhciByYXRpb1kgPSBoZWlnaHQgLyAobWF4WSAtIG1pblkpO1xuICByZXR1cm4gcG9pbnRzLm1hcChmdW5jdGlvbiAocG9pbnQpIHtcbiAgICByZXR1cm4gW2xlZnQgKyAocG9pbnRbMF0gLSBtaW5YKSAqIHJhdGlvWCwgdG9wICsgKHBvaW50WzFdIC0gbWluWSkgKiByYXRpb1ldO1xuICB9KTtcbn1cbi8qKlxuICogR2V0IHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIHBvaW50cyBvZiB0aGUgcG9pbnRzLlxuICogQG1lbWJlcm9mIE92ZXJsYXBBcmVhXG4gKi9cblxuZnVuY3Rpb24gZ2V0TWluTWF4cyhwb2ludHMpIHtcbiAgdmFyIHhzID0gcG9pbnRzLm1hcChmdW5jdGlvbiAocG9pbnQpIHtcbiAgICByZXR1cm4gcG9pbnRbMF07XG4gIH0pO1xuICB2YXIgeXMgPSBwb2ludHMubWFwKGZ1bmN0aW9uIChwb2ludCkge1xuICAgIHJldHVybiBwb2ludFsxXTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgbWluWDogTWF0aC5taW4uYXBwbHkoTWF0aCwgeHMpLFxuICAgIG1pblk6IE1hdGgubWluLmFwcGx5KE1hdGgsIHlzKSxcbiAgICBtYXhYOiBNYXRoLm1heC5hcHBseShNYXRoLCB4cyksXG4gICAgbWF4WTogTWF0aC5tYXguYXBwbHkoTWF0aCwgeXMpXG4gIH07XG59XG4vKipcbiAqIFdoZXRoZXIgdGhlIHBvaW50IGlzIGluIHNoYXBlXG4gKiBAcGFyYW0gLSBwb2ludCBwb3NcbiAqIEBwYXJhbSAtIHNoYXBlIHBvaW50c1xuICogQHBhcmFtIC0gd2hldGhlciB0byBjaGVjayBleGNlcHQgbGluZVxuICogQG1lbWJlcm9mIE92ZXJsYXBBcmVhXG4gKi9cblxuZnVuY3Rpb24gaXNJbnNpZGUocG9zLCBwb2ludHMsIGV4Y2x1ZGVMaW5lKSB7XG4gIHZhciB4ID0gcG9zWzBdLFxuICAgICAgeSA9IHBvc1sxXTtcblxuICB2YXIgX2EgPSBnZXRNaW5NYXhzKHBvaW50cyksXG4gICAgICBtaW5YID0gX2EubWluWCxcbiAgICAgIG1pblkgPSBfYS5taW5ZLFxuICAgICAgbWF4WCA9IF9hLm1heFgsXG4gICAgICBtYXhZID0gX2EubWF4WTtcblxuICB2YXIgeExpbmUgPSBbW21pblgsIHldLCBbbWF4WCwgeV1dO1xuICB2YXIgeUxpbmUgPSBbW3gsIG1pblldLCBbeCwgbWF4WV1dO1xuICB2YXIgeExpbmVhckNvbnN0YW50cyA9IGdldExpbmVhckNvbnN0YW50cyh4TGluZVswXSwgeExpbmVbMV0pO1xuICB2YXIgeUxpbmVhckNvbnN0YW50cyA9IGdldExpbmVhckNvbnN0YW50cyh5TGluZVswXSwgeUxpbmVbMV0pO1xuICB2YXIgbGluZXMgPSBjb252ZXJ0TGluZXMocG9pbnRzKTtcbiAgdmFyIGludGVyc2VjdGlvblhQb2ludHMgPSBbXTtcbiAgdmFyIGludGVyc2VjdGlvbllQb2ludHMgPSBbXTtcbiAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgIHZhciBsaW5lYXJDb25zdGFudHMgPSBnZXRMaW5lYXJDb25zdGFudHMobGluZVswXSwgbGluZVsxXSk7XG4gICAgdmFyIHhQb2ludHMgPSBnZXRQb2ludHNPbkxpbmVzKGdldEludGVyc2VjdGlvblBvaW50c0J5Q29uc3RhbnRzKHhMaW5lYXJDb25zdGFudHMsIGxpbmVhckNvbnN0YW50cyksIFt4TGluZSwgbGluZV0pO1xuICAgIHZhciB5UG9pbnRzID0gZ2V0UG9pbnRzT25MaW5lcyhnZXRJbnRlcnNlY3Rpb25Qb2ludHNCeUNvbnN0YW50cyh5TGluZWFyQ29uc3RhbnRzLCBsaW5lYXJDb25zdGFudHMpLCBbeUxpbmUsIGxpbmVdKTtcblxuICAgIGlmICh4UG9pbnRzLmxlbmd0aCA9PT0gMSA/IGxpbmVbMF1bMV0gIT09IHkgOiB0cnVlKSB7XG4gICAgICBpbnRlcnNlY3Rpb25YUG9pbnRzLnB1c2guYXBwbHkoaW50ZXJzZWN0aW9uWFBvaW50cywgeFBvaW50cyk7XG4gICAgfVxuXG4gICAgaWYgKHlQb2ludHMubGVuZ3RoID09PSAxID8gbGluZVswXVswXSAhPT0geCA6IHRydWUpIHtcbiAgICAgIGludGVyc2VjdGlvbllQb2ludHMucHVzaC5hcHBseShpbnRlcnNlY3Rpb25ZUG9pbnRzLCB5UG9pbnRzKTtcbiAgICB9XG5cbiAgICBpZiAoIWxpbmVhckNvbnN0YW50c1swXSkge1xuICAgICAgaW50ZXJzZWN0aW9uWFBvaW50cy5wdXNoLmFwcGx5KGludGVyc2VjdGlvblhQb2ludHMsIHhQb2ludHMpO1xuICAgIH1cblxuICAgIGlmICghbGluZWFyQ29uc3RhbnRzWzFdKSB7XG4gICAgICBpbnRlcnNlY3Rpb25ZUG9pbnRzLnB1c2guYXBwbHkoaW50ZXJzZWN0aW9uWVBvaW50cywgeVBvaW50cyk7XG4gICAgfVxuICB9KTtcblxuICBpZiAoIWV4Y2x1ZGVMaW5lKSB7XG4gICAgaWYgKGZpbmRJbmRleChpbnRlcnNlY3Rpb25YUG9pbnRzLCBmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuIHBbMF0gPT09IHg7XG4gICAgfSkgPiAtMSB8fCBmaW5kSW5kZXgoaW50ZXJzZWN0aW9uWVBvaW50cywgZnVuY3Rpb24gKHApIHtcbiAgICAgIHJldHVybiBwWzFdID09PSB5O1xuICAgIH0pID4gLTEpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpbnRlcnNlY3Rpb25YUG9pbnRzLmZpbHRlcihmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBwWzBdID4geDtcbiAgfSkubGVuZ3RoICUgMiAmJiBpbnRlcnNlY3Rpb25ZUG9pbnRzLmZpbHRlcihmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBwWzFdID4geTtcbiAgfSkubGVuZ3RoICUgMikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBHZXQgdGhlIGNvZWZmaWNpZW50IG9mIHRoZSBsaW5lYXIgZnVuY3Rpb24uIFthLCBiLCBjXSAoYXggKyBieSArIGMgPSAwKVxuICogQHJldHVybiBbYSwgYiwgY11cbiAqIEBtZW1iZXJvZiBPdmVybGFwQXJlYVxuICovXG5cbmZ1bmN0aW9uIGdldExpbmVhckNvbnN0YW50cyhwb2ludDEsIHBvaW50Mikge1xuICB2YXIgeDEgPSBwb2ludDFbMF0sXG4gICAgICB5MSA9IHBvaW50MVsxXTtcbiAgdmFyIHgyID0gcG9pbnQyWzBdLFxuICAgICAgeTIgPSBwb2ludDJbMV07IC8vIGF4ICsgYnkgKyBjID0gMFxuXG4gIGlmICh4MSA9PT0geDIgJiYgeTEgPT09IHkyKSB7XG4gICAgcmV0dXJuIFswLCAwLCAwXTtcbiAgfVxuXG4gIGlmICh4MSA9PT0geDIpIHtcbiAgICAvLyB4ID0geDFcbiAgICByZXR1cm4gWzEsIDAsIC14MV07XG4gIH0gZWxzZSBpZiAoeTEgPT09IHkyKSB7XG4gICAgLy8geSA9IHkxXG4gICAgcmV0dXJuIFswLCAxLCAteTFdO1xuICB9IGVsc2Uge1xuICAgIC8vIHgxICsgYSAqIHkxICsgYiA9IDBcbiAgICAvLyB4MiArIGEgKiB5MiArIGIgPSAwXG4gICAgLy8gKHgxIC14MikgKyAoeTEgLSB5MikgKiBhID0gMFxuICAgIC8vIGEgPSAoeDIgLSB4MSkgLyAoeTEgLSB5MilcbiAgICAvLyB4MSArICh4MiAtIHgxKSAvICh5MSAtIHkyKVxuICAgIHZhciBhXzEgPSAoeDIgLSB4MSkgLyAoeTEgLSB5Mik7XG4gICAgdmFyIGJfMSA9IC14MSAtIGFfMSAqIHkxO1xuICAgIHJldHVybiBbMSwgYV8xLCBiXzFdO1xuICB9XG59XG4vKipcbiAqIEdldCBpbnRlcnNlY3Rpb24gcG9pbnRzIHdpdGggbGluZWFyIGZ1bmN0aW9ucy5cbiAqIEBtZW1iZXJvZiBPdmVybGFwQXJlYVxuICovXG5cbmZ1bmN0aW9uIGdldEludGVyc2VjdGlvblBvaW50c0J5Q29uc3RhbnRzKGxpbmVhckNvbnN0YW50czEsIGxpbmVhckNvbnN0YW50czIpIHtcbiAgdmFyIGExID0gbGluZWFyQ29uc3RhbnRzMVswXSxcbiAgICAgIGIxID0gbGluZWFyQ29uc3RhbnRzMVsxXSxcbiAgICAgIGMxID0gbGluZWFyQ29uc3RhbnRzMVsyXTtcbiAgdmFyIGEyID0gbGluZWFyQ29uc3RhbnRzMlswXSxcbiAgICAgIGIyID0gbGluZWFyQ29uc3RhbnRzMlsxXSxcbiAgICAgIGMyID0gbGluZWFyQ29uc3RhbnRzMlsyXTtcbiAgdmFyIGlzWmVyb0EgPSBhMSA9PT0gMCAmJiBhMiA9PT0gMDtcbiAgdmFyIGlzWmVyb0IgPSBiMSA9PT0gMCAmJiBiMiA9PT0gMDtcblxuICBpZiAoaXNaZXJvQSAmJiBpc1plcm9CKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9IGVsc2UgaWYgKGlzWmVyb0EpIHtcbiAgICAvLyBiMSAqIHkgKyBjMSA9IDBcbiAgICAvLyBiMiAqIHkgKyBjMiA9IDBcbiAgICB2YXIgeTEgPSAtYzEgLyBiMTtcbiAgICB2YXIgeTIgPSAtYzIgLyBiMjtcblxuICAgIGlmICh5MSAhPT0geTIpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtbLUluZmluaXR5LCB5MV0sIFtJbmZpbml0eSwgeTFdXTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNaZXJvQikge1xuICAgIC8vIGExICogeCArIGMxID0gMFxuICAgIC8vIGEyICogeCArIGMyID0gMFxuICAgIHZhciB4MSA9IC1jMSAvIGExO1xuICAgIHZhciB4MiA9IC1jMiAvIGEyO1xuXG4gICAgaWYgKHgxICE9PSB4Mikge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW1t4MSwgLUluZmluaXR5XSwgW3gxLCBJbmZpbml0eV1dO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhMSA9PT0gMCkge1xuICAgIC8vIGIxICogeSArIGMxID0gMFxuICAgIC8vIHkgPSAtIGMxIC8gYjE7XG4gICAgLy8gYTIgKiB4ICsgYjIgKiB5ICsgYzIgPSAwXG4gICAgdmFyIHkgPSAtYzEgLyBiMTtcbiAgICB2YXIgeCA9IC0oYjIgKiB5ICsgYzIpIC8gYTI7XG4gICAgcmV0dXJuIFtbeCwgeV1dO1xuICB9IGVsc2UgaWYgKGEyID09PSAwKSB7XG4gICAgLy8gYjIgKiB5ICsgYzIgPSAwXG4gICAgLy8geSA9IC0gYzIgLyBiMjtcbiAgICAvLyBhMSAqIHggKyBiMSAqIHkgKyBjMSA9IDBcbiAgICB2YXIgeSA9IC1jMiAvIGIyO1xuICAgIHZhciB4ID0gLShiMSAqIHkgKyBjMSkgLyBhMTtcbiAgICByZXR1cm4gW1t4LCB5XV07XG4gIH0gZWxzZSBpZiAoYjEgPT09IDApIHtcbiAgICAvLyBhMSAqIHggKyBjMSA9IDBcbiAgICAvLyB4ID0gLSBjMSAvIGExO1xuICAgIC8vIGEyICogeCArIGIyICogeSArIGMyID0gMFxuICAgIHZhciB4ID0gLWMxIC8gYTE7XG4gICAgdmFyIHkgPSAtKGEyICogeCArIGMyKSAvIGIyO1xuICAgIHJldHVybiBbW3gsIHldXTtcbiAgfSBlbHNlIGlmIChiMiA9PT0gMCkge1xuICAgIC8vIGEyICogeCArIGMyID0gMFxuICAgIC8vIHggPSAtIGMyIC8gYTI7XG4gICAgLy8gYTEgKiB4ICsgYjEgKiB5ICsgYzEgPSAwXG4gICAgdmFyIHggPSAtYzIgLyBhMjtcbiAgICB2YXIgeSA9IC0oYTEgKiB4ICsgYzEpIC8gYjE7XG4gICAgcmV0dXJuIFtbeCwgeV1dO1xuICB9IGVsc2Uge1xuICAgIC8vIGExICogeCArIGIxICogeSArIGMxID0gMFxuICAgIC8vIGEyICogeCArIGIyICogeSArIGMyID0gMFxuICAgIC8vIGIyICogYTEgKiB4ICsgYjIgKiBiMSAqIHkgKyBiMiAqIGMxID0gMFxuICAgIC8vIGIxICogYTIgKiB4ICsgYjEgKiBiMiAqIHkgKyBiMSAqIGMyID0gMFxuICAgIC8vIChiMiAqIGExIC0gYjEgKiBhMikgICogeCA9IChiMSAqIGMyIC0gYjIgKiBjMSlcbiAgICB2YXIgeCA9IChiMSAqIGMyIC0gYjIgKiBjMSkgLyAoYjIgKiBhMSAtIGIxICogYTIpO1xuICAgIHZhciB5ID0gLShhMSAqIHggKyBjMSkgLyBiMTtcbiAgICByZXR1cm4gW1t4LCB5XV07XG4gIH1cbn1cbi8qKlxuICogR2V0IGludGVyc2VjdGlvbiBwb2ludHMgdG8gdGhlIHR3byBsaW5lcy5cbiAqIEBtZW1iZXJvZiBPdmVybGFwQXJlYVxuICovXG5cbmZ1bmN0aW9uIGdldEludGVyc2VjdGlvblBvaW50cyhsaW5lMSwgbGluZTIsIGlzTGltaXQpIHtcbiAgdmFyIHBvaW50cyA9IGdldEludGVyc2VjdGlvblBvaW50c0J5Q29uc3RhbnRzKGdldExpbmVhckNvbnN0YW50cyhsaW5lMVswXSwgbGluZTFbMV0pLCBnZXRMaW5lYXJDb25zdGFudHMobGluZTJbMF0sIGxpbmUyWzFdKSk7XG5cbiAgaWYgKGlzTGltaXQpIHtcbiAgICByZXR1cm4gZ2V0UG9pbnRzT25MaW5lcyhwb2ludHMsIFtsaW5lMSwgbGluZTJdKTtcbiAgfVxuXG4gIHJldHVybiBwb2ludHM7XG59XG4vKipcbiAqIEdldCB0aGUgcG9pbnRzIG9uIHRoZSBsaW5lcyAoYmV0d2VlbiB0d28gcG9pbnRzKS5cbiAqIEBtZW1iZXJvZiBPdmVybGFwQXJlYVxuICovXG5cbmZ1bmN0aW9uIGdldFBvaW50c09uTGluZXMocG9pbnRzLCBsaW5lcykge1xuICB2YXIgbWluTWF4cyA9IGxpbmVzLm1hcChmdW5jdGlvbiAobGluZSkge1xuICAgIHJldHVybiBbMCwgMV0ubWFwKGZ1bmN0aW9uIChvcmRlcikge1xuICAgICAgcmV0dXJuIFtNYXRoLm1pbihsaW5lWzBdW29yZGVyXSwgbGluZVsxXVtvcmRlcl0pLCBNYXRoLm1heChsaW5lWzBdW29yZGVyXSwgbGluZVsxXVtvcmRlcl0pXTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgaWYgKHBvaW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgX2EgPSBwb2ludHNbMF0sXG4gICAgICAgIHggPSBfYVswXSxcbiAgICAgICAgeSA9IF9hWzFdO1xuXG4gICAgaWYgKHggPT09IHBvaW50c1sxXVswXSkge1xuICAgICAgLy8vIE1hdGgubWF4KG1pblkxLCBtaW5ZMilcbiAgICAgIHZhciB0b3AgPSBNYXRoLm1heC5hcHBseShNYXRoLCBtaW5NYXhzLm1hcChmdW5jdGlvbiAobWluTWF4KSB7XG4gICAgICAgIHJldHVybiBtaW5NYXhbMV1bMF07XG4gICAgICB9KSk7IC8vLyBNYXRoLm1pbihtYXhZMSwgbWlheDIpXG5cbiAgICAgIHZhciBib3R0b20gPSBNYXRoLm1pbi5hcHBseShNYXRoLCBtaW5NYXhzLm1hcChmdW5jdGlvbiAobWluTWF4KSB7XG4gICAgICAgIHJldHVybiBtaW5NYXhbMV1bMV07XG4gICAgICB9KSk7XG5cbiAgICAgIGlmICh0b3AgPiBib3R0b20pIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW1t4LCB0b3BdLCBbeCwgYm90dG9tXV07XG4gICAgfSBlbHNlIGlmICh5ID09PSBwb2ludHNbMV1bMV0pIHtcbiAgICAgIC8vLyBNYXRoLm1heChtaW5ZMSwgbWluWTIpXG4gICAgICB2YXIgbGVmdCA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIG1pbk1heHMubWFwKGZ1bmN0aW9uIChtaW5NYXgpIHtcbiAgICAgICAgcmV0dXJuIG1pbk1heFswXVswXTtcbiAgICAgIH0pKTsgLy8vIE1hdGgubWluKG1heFkxLCBtaWF4MilcblxuICAgICAgdmFyIHJpZ2h0ID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgbWluTWF4cy5tYXAoZnVuY3Rpb24gKG1pbk1heCkge1xuICAgICAgICByZXR1cm4gbWluTWF4WzBdWzFdO1xuICAgICAgfSkpO1xuXG4gICAgICBpZiAobGVmdCA+IHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtbbGVmdCwgeV0sIFtyaWdodCwgeV1dO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwb2ludHMuZmlsdGVyKGZ1bmN0aW9uIChwb2ludCkge1xuICAgIHJldHVybiBtaW5NYXhzLmV2ZXJ5KGZ1bmN0aW9uIChtaW5NYXgpIHtcbiAgICAgIHJldHVybiBtaW5NYXhbMF1bMF0gPD0gcG9pbnRbMF0gJiYgcG9pbnRbMF0gPD0gbWluTWF4WzBdWzFdICYmIG1pbk1heFsxXVswXSA8PSBwb2ludFsxXSAmJiBwb2ludFsxXSA8PSBtaW5NYXhbMV1bMV07XG4gICAgfSk7XG4gIH0pO1xufVxuLyoqXG4qIENvbnZlcnQgdHdvIHBvaW50cyBpbnRvIGxpbmVzLlxuKiBAZnVuY3Rpb25cbiogQG1lbWJlcm9mIE92ZXJsYXBBcmVhXG4qL1xuXG5mdW5jdGlvbiBjb252ZXJ0TGluZXMocG9pbnRzKSB7XG4gIHJldHVybiBfX3NwcmVhZEFycmF5cyhwb2ludHMuc2xpY2UoMSksIFtwb2ludHNbMF1dKS5tYXAoZnVuY3Rpb24gKHBvaW50LCBpKSB7XG4gICAgcmV0dXJuIFtwb2ludHNbaV0sIHBvaW50XTtcbiAgfSk7XG59XG4vKipcbiogR2V0IHRoZSBwb2ludHMgb2YgdGhlIG92ZXJsYXBwZWQgcGFydCBvZiB0d28gc2hhcGVzLlxuKiBAZnVuY3Rpb25cbiogQG1lbWJlcm9mIE92ZXJsYXBBcmVhXG4qL1xuXG5mdW5jdGlvbiBnZXRPdmVybGFwUG9pbnRzKHBvaW50czEsIHBvaW50czIpIHtcbiAgdmFyIHRhcmdldFBvaW50czEgPSBwb2ludHMxLnNsaWNlKCk7XG4gIHZhciB0YXJnZXRQb2ludHMyID0gcG9pbnRzMi5zbGljZSgpO1xuXG4gIGlmIChnZXRTaGFwZURpcmVjdGlvbih0YXJnZXRQb2ludHMxKSA9PT0gLTEpIHtcbiAgICB0YXJnZXRQb2ludHMxLnJldmVyc2UoKTtcbiAgfVxuXG4gIGlmIChnZXRTaGFwZURpcmVjdGlvbih0YXJnZXRQb2ludHMyKSA9PT0gLTEpIHtcbiAgICB0YXJnZXRQb2ludHMyLnJldmVyc2UoKTtcbiAgfVxuXG4gIHZhciBsaW5lczEgPSBjb252ZXJ0TGluZXModGFyZ2V0UG9pbnRzMSk7XG4gIHZhciBsaW5lczIgPSBjb252ZXJ0TGluZXModGFyZ2V0UG9pbnRzMik7XG4gIHZhciBsaW5lYXJDb25zdGFudHNzMSA9IGxpbmVzMS5tYXAoZnVuY3Rpb24gKGxpbmUxKSB7XG4gICAgcmV0dXJuIGdldExpbmVhckNvbnN0YW50cyhsaW5lMVswXSwgbGluZTFbMV0pO1xuICB9KTtcbiAgdmFyIGxpbmVhckNvbnN0YW50c3MyID0gbGluZXMyLm1hcChmdW5jdGlvbiAobGluZTIpIHtcbiAgICByZXR1cm4gZ2V0TGluZWFyQ29uc3RhbnRzKGxpbmUyWzBdLCBsaW5lMlsxXSk7XG4gIH0pO1xuICB2YXIgb3ZlcmxhcEluZm9zID0gW107XG4gIGxpbmVhckNvbnN0YW50c3MxLmZvckVhY2goZnVuY3Rpb24gKGxpbmVhckNvbnN0YW50czEsIGkpIHtcbiAgICB2YXIgbGluZTEgPSBsaW5lczFbaV07XG4gICAgdmFyIGxpbmVQb2ludEluZm9zID0gW107XG4gICAgbGluZWFyQ29uc3RhbnRzczIuZm9yRWFjaChmdW5jdGlvbiAobGluZWFyQ29uc3RhbnRzMiwgaikge1xuICAgICAgdmFyIGludGVyc2VjdGlvblBvaW50cyA9IGdldEludGVyc2VjdGlvblBvaW50c0J5Q29uc3RhbnRzKGxpbmVhckNvbnN0YW50czEsIGxpbmVhckNvbnN0YW50czIpO1xuICAgICAgdmFyIHBvaW50cyA9IGdldFBvaW50c09uTGluZXMoaW50ZXJzZWN0aW9uUG9pbnRzLCBbbGluZTEsIGxpbmVzMltqXV0pO1xuICAgICAgbGluZVBvaW50SW5mb3MucHVzaC5hcHBseShsaW5lUG9pbnRJbmZvcywgcG9pbnRzLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaW5kZXgxOiBpLFxuICAgICAgICAgIGluZGV4MjogaixcbiAgICAgICAgICBwb3M6IHBvc1xuICAgICAgICB9O1xuICAgICAgfSkpO1xuICAgIH0pO1xuICAgIGxpbmVQb2ludEluZm9zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBnZXREaXN0KGxpbmUxWzBdLCBhLnBvcykgLSBnZXREaXN0KGxpbmUxWzBdLCBiLnBvcyk7XG4gICAgfSk7XG4gICAgb3ZlcmxhcEluZm9zLnB1c2guYXBwbHkob3ZlcmxhcEluZm9zLCBsaW5lUG9pbnRJbmZvcyk7XG5cbiAgICBpZiAoaXNJbnNpZGUobGluZTFbMV0sIHRhcmdldFBvaW50czIpKSB7XG4gICAgICBvdmVybGFwSW5mb3MucHVzaCh7XG4gICAgICAgIGluZGV4MTogaSxcbiAgICAgICAgaW5kZXgyOiAtMSxcbiAgICAgICAgcG9zOiBsaW5lMVsxXVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgbGluZXMyLmZvckVhY2goZnVuY3Rpb24gKGxpbmUyLCBpKSB7XG4gICAgaWYgKGlzSW5zaWRlKGxpbmUyWzFdLCB0YXJnZXRQb2ludHMxKSkge1xuICAgICAgdmFyIGlzTmV4dF8xID0gZmFsc2U7XG4gICAgICB2YXIgaW5kZXggPSBmaW5kSW5kZXgob3ZlcmxhcEluZm9zLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGluZGV4MiA9IF9hLmluZGV4MjtcblxuICAgICAgICBpZiAoaW5kZXgyID09PSBpKSB7XG4gICAgICAgICAgaXNOZXh0XzEgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc05leHRfMSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgaXNOZXh0XzEgPSBmYWxzZTtcbiAgICAgICAgaW5kZXggPSBmaW5kSW5kZXgob3ZlcmxhcEluZm9zLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICB2YXIgaW5kZXgxID0gX2EuaW5kZXgxLFxuICAgICAgICAgICAgICBpbmRleDIgPSBfYS5pbmRleDI7XG5cbiAgICAgICAgICBpZiAoaW5kZXgxID09PSAtMSAmJiBpbmRleDIgKyAxID09PSBpKSB7XG4gICAgICAgICAgICBpc05leHRfMSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzTmV4dF8xKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgIG92ZXJsYXBJbmZvcy5wdXNoKHtcbiAgICAgICAgICBpbmRleDE6IC0xLFxuICAgICAgICAgIGluZGV4MjogaSxcbiAgICAgICAgICBwb3M6IGxpbmUyWzFdXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3ZlcmxhcEluZm9zLnNwbGljZShpbmRleCwgMCwge1xuICAgICAgICAgIGluZGV4MTogLTEsXG4gICAgICAgICAgaW5kZXgyOiBpLFxuICAgICAgICAgIHBvczogbGluZTJbMV1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTsgLy8gY29uc29sZS5sb2cob3ZlcmxhcEluZm9zKTtcblxuICB2YXIgb3ZlcmxhcFBvaW50cyA9IG92ZXJsYXBJbmZvcy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIHBvcyA9IF9hLnBvcztcbiAgICByZXR1cm4gcG9zO1xuICB9KTtcbiAgdmFyIHBvaW50TWFwID0ge307XG4gIHJldHVybiBvdmVybGFwUG9pbnRzLmZpbHRlcihmdW5jdGlvbiAocG9pbnQpIHtcbiAgICB2YXIga2V5ID0gcG9pbnRbMF0gKyBcInhcIiArIHBvaW50WzFdO1xuXG4gICAgaWYgKHBvaW50TWFwW2tleV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBwb2ludE1hcFtrZXldID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG59XG4vKipcbiogR2V0cyB0aGUgc2l6ZSBvZiB0aGUgb3ZlcmxhcHBlZCBwYXJ0IG9mIHR3byBzaGFwZXMuXG4qIEBmdW5jdGlvblxuKiBAbWVtYmVyb2YgT3ZlcmxhcEFyZWFcbiovXG5cbmZ1bmN0aW9uIGdldE92ZXJsYXBTaXplKHBvaW50czEsIHBvaW50czIpIHtcbiAgdmFyIHBvaW50cyA9IGdldE92ZXJsYXBQb2ludHMocG9pbnRzMSwgcG9pbnRzMik7XG4gIHJldHVybiBnZXRBcmVhU2l6ZShwb2ludHMpO1xufVxuXG5leHBvcnQgeyBjb252ZXJ0TGluZXMsIGZpdFBvaW50cywgZ2V0QXJlYVNpemUsIGdldEludGVyc2VjdGlvblBvaW50cywgZ2V0SW50ZXJzZWN0aW9uUG9pbnRzQnlDb25zdGFudHMsIGdldExpbmVhckNvbnN0YW50cywgZ2V0TWluTWF4cywgZ2V0T3ZlcmxhcFBvaW50cywgZ2V0T3ZlcmxhcFNpemUsIGdldFBvaW50c09uTGluZXMsIGlzSW5zaWRlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vdmVybGFwLWFyZWEuZXNtLmpzLm1hcFxuIiwiLypcbkNvcHlyaWdodCAoYykgRGF5YnJ1c2hcbm5hbWU6IHJlYWN0LWNvbXBhdC1jc3Mtc3R5bGVkXG5saWNlbnNlOiBNSVRcbmF1dGhvcjogRGF5YnJ1c2hcbnJlcG9zaXRvcnk6IGdpdCtodHRwczovL2dpdGh1Yi5jb20vZGF5YnJ1c2gvY3NzLXN0eWxlZC5naXRcbnZlcnNpb246IDEuMC44XG4qL1xuaW1wb3J0IGNzc1N0eWxlZCBmcm9tICdjc3Mtc3R5bGVkJztcbmltcG9ydCB7IHZlcnNpb24sIGNyZWF0ZUVsZW1lbnQsIENvbXBvbmVudCB9IGZyb20gJ3JlYWN0LXNpbXBsZS1jb21wYXQnO1xuaW1wb3J0IHsgcmVmIH0gZnJvbSAnZnJhbWV3b3JrLXV0aWxzJztcblxuLypcbkNvcHlyaWdodCAoYykgMjAxOSBEYXlicnVzaFxubmFtZTogcmVhY3QtY3NzLXN0eWxlZFxubGljZW5zZTogTUlUXG5hdXRob3I6IERheWJydXNoXG5yZXBvc2l0b3J5OiBodHRwczovL2dpdGh1Yi5jb20vZGF5YnJ1c2gvY3NzLXN0eWxlZC90cmVlL21hc3Rlci9wYWNrYWdlcy9yZWFjdC1jc3Mtc3R5bGVkXG52ZXJzaW9uOiAxLjAuM1xuKi9cblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7XG4gICAgX19wcm90b19fOiBbXVxuICB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBkLl9fcHJvdG9fXyA9IGI7XG4gIH0gfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgfTtcblxuICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbn07XG5cbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XG4gIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cbiAgZnVuY3Rpb24gX18oKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7XG4gIH1cblxuICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59XG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbiAoKSB7XG4gIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XG4gICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBzID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xuICB9O1xuXG4gIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XG4gIHZhciB0ID0ge307XG5cbiAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApIHRbcF0gPSBzW3BdO1xuXG4gIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIikgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSkgdFtwW2ldXSA9IHNbcFtpXV07XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5cbnZhciBTdHlsZWRFbGVtZW50ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFN0eWxlZEVsZW1lbnQsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gU3R5bGVkRWxlbWVudCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLmluamVjdFJlc3VsdCA9IG51bGw7XG4gICAgX3RoaXMudGFnID0gXCJkaXZcIjtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX19wcm90byA9IFN0eWxlZEVsZW1lbnQucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfYSA9IHRoaXMucHJvcHMsXG4gICAgICAgIF9iID0gX2EuY2xhc3NOYW1lLFxuICAgICAgICBjbGFzc05hbWUgPSBfYiA9PT0gdm9pZCAwID8gXCJcIiA6IF9iLFxuICAgICAgICBjc3BOb25jZSA9IF9hLmNzcE5vbmNlLFxuICAgICAgICBwb3J0YWxDb250YWluZXIgPSBfYS5wb3J0YWxDb250YWluZXIsXG4gICAgICAgIGF0dHJpYnV0ZXMgPSBfX3Jlc3QoX2EsIFtcImNsYXNzTmFtZVwiLCBcImNzcE5vbmNlXCIsIFwicG9ydGFsQ29udGFpbmVyXCJdKTtcblxuICAgIHZhciBjc3NJZCA9IHRoaXMuaW5qZWN0b3IuY2xhc3NOYW1lO1xuICAgIHZhciBUYWcgPSB0aGlzLnRhZztcbiAgICB2YXIgcG9ydGFsQXR0cmlidXRlcyA9IHt9O1xuXG4gICAgaWYgKCh2ZXJzaW9uIHx8IFwiXCIpLmluZGV4T2YoXCJzaW1wbGVcIikgPiAtMSAmJiBwb3J0YWxDb250YWluZXIpIHtcbiAgICAgIHBvcnRhbEF0dHJpYnV0ZXMgPSB7XG4gICAgICAgIHBvcnRhbENvbnRhaW5lcjogcG9ydGFsQ29udGFpbmVyXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KFRhZywgX19hc3NpZ24oe1xuICAgICAgXCJyZWZcIjogcmVmKHRoaXMsIFwiZWxlbWVudFwiKSxcbiAgICAgIFwiZGF0YS1zdHlsZWQtaWRcIjogY3NzSWQsXG4gICAgICBcImNsYXNzTmFtZVwiOiBjbGFzc05hbWUgKyBcIiBcIiArIGNzc0lkXG4gICAgfSwgcG9ydGFsQXR0cmlidXRlcywgYXR0cmlidXRlcykpO1xuICB9O1xuXG4gIF9fcHJvdG8uY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pbmplY3RSZXN1bHQgPSB0aGlzLmluamVjdG9yLmluamVjdCh0aGlzLmVsZW1lbnQsIHtcbiAgICAgIG5vbmNlOiB0aGlzLnByb3BzLmNzcE5vbmNlXG4gICAgfSk7XG4gIH07XG5cbiAgX19wcm90by5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmluamVjdFJlc3VsdC5kZXN0cm95KCk7XG4gICAgdGhpcy5pbmplY3RSZXN1bHQgPSBudWxsO1xuICB9O1xuXG4gIF9fcHJvdG8uZ2V0RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50O1xuICB9O1xuXG4gIHJldHVybiBTdHlsZWRFbGVtZW50O1xufShDb21wb25lbnQpO1xuXG5mdW5jdGlvbiBzdHlsZWQodGFnLCBjc3MpIHtcbiAgdmFyIGluamVjdG9yID0gY3NzU3R5bGVkKGNzcyk7XG4gIHJldHVybiAoXG4gICAgLyojX19QVVJFX18qL1xuICAgIGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyhTdHlsZWQsIF9zdXBlcik7XG5cbiAgICAgIGZ1bmN0aW9uIFN0eWxlZCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICAgICAgX3RoaXMuaW5qZWN0b3IgPSBpbmplY3RvcjtcbiAgICAgICAgX3RoaXMudGFnID0gdGFnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBTdHlsZWQ7XG4gICAgfShTdHlsZWRFbGVtZW50KVxuICApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdHlsZWQ7XG5leHBvcnQgeyBTdHlsZWRFbGVtZW50IH07XG4iLCIvKlxuQ29weXJpZ2h0IChjKSBEYXlicnVzaFxubmFtZTogcmVhY3Qtc2ltcGxlLWNvbXBhdFxubGljZW5zZTogTUlUXG5hdXRob3I6IERheWJydXNoXG5yZXBvc2l0b3J5OiBnaXQraHR0cHM6Ly9naXRodWIuY29tL2RheWJydXNoL3JlYWN0LXNpbXBsZS1jb21wYXQuZ2l0XG52ZXJzaW9uOiAxLjIuMVxuKi9cbmltcG9ydCB7IGRpZmYgfSBmcm9tICdAZWdqcy9saXN0LWRpZmZlcic7XG5pbXBvcnQgeyBpc0FycmF5LCBpc1N0cmluZywgaXNOdW1iZXIsIGlzVW5kZWZpbmVkLCBkZWNhbWVsaXplIH0gZnJvbSAnQGRheWJydXNoL3V0aWxzJztcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7XG4gICAgX19wcm90b19fOiBbXVxuICB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBkLl9fcHJvdG9fXyA9IGI7XG4gIH0gfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgfTtcblxuICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbn07XG5cbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XG4gIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cbiAgZnVuY3Rpb24gX18oKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7XG4gIH1cblxuICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59XG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbiAoKSB7XG4gIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XG4gICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBzID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xuICB9O1xuXG4gIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XG4gIHZhciB0ID0ge307XG5cbiAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApIHRbcF0gPSBzW3BdO1xuXG4gIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIikgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSkgdFtwW2ldXSA9IHNbcFtpXV07XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBfX3NwcmVhZEFycmF5cygpIHtcbiAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG5cbiAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKSBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKykgcltrXSA9IGFbal07XG5cbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGlzRGlmZihhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIgaSBpbiBhKSB7XG4gICAgaWYgKCEoaSBpbiBiKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSBpbiBiKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZGlmZk9iamVjdChhLCBiKSB7XG4gIHZhciBrZXlzMSA9IE9iamVjdC5rZXlzKGEpO1xuICB2YXIga2V5czIgPSBPYmplY3Qua2V5cyhiKTtcbiAgdmFyIHJlc3VsdCA9IGRpZmYoa2V5czEsIGtleXMyLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGtleTtcbiAgfSk7XG4gIHZhciBhZGRlZCA9IHt9O1xuICB2YXIgcmVtb3ZlZCA9IHt9O1xuICB2YXIgY2hhbmdlZCA9IHt9O1xuICByZXN1bHQuYWRkZWQuZm9yRWFjaChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICB2YXIgbmFtZSA9IGtleXMyW2luZGV4XTtcbiAgICBhZGRlZFtuYW1lXSA9IGJbbmFtZV07XG4gIH0pO1xuICByZXN1bHQucmVtb3ZlZC5mb3JFYWNoKGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHZhciBuYW1lID0ga2V5czFbaW5kZXhdO1xuICAgIHJlbW92ZWRbbmFtZV0gPSBhW25hbWVdO1xuICB9KTtcbiAgcmVzdWx0Lm1haW50YWluZWQuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgaW5kZXggPSBfYVswXTtcbiAgICB2YXIgbmFtZSA9IGtleXMxW2luZGV4XTtcbiAgICB2YXIgdmFsdWVzID0gW2FbbmFtZV0sIGJbbmFtZV1dO1xuXG4gICAgaWYgKGFbbmFtZV0gIT09IGJbbmFtZV0pIHtcbiAgICAgIGNoYW5nZWRbbmFtZV0gPSB2YWx1ZXM7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBhZGRlZDogYWRkZWQsXG4gICAgcmVtb3ZlZDogcmVtb3ZlZCxcbiAgICBjaGFuZ2VkOiBjaGFuZ2VkXG4gIH07XG59XG5cbmZ1bmN0aW9uIGV4ZWN1dGVIb29rcyhob29rcykge1xuICBob29rcy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gICAgaG9vaygpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZmlsbEtleXMoa2V5cykge1xuICB2YXIgaW5kZXggPSAwO1xuICByZXR1cm4ga2V5cy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBrZXkgPT0gbnVsbCA/IFwiJGNvbXBhdFwiICsgKytpbmRleCA6IFwiXCIgKyBrZXk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQcm92aWRlcihlbCwga2V5LCBpbmRleCwgY29udGFpbmVyKSB7XG4gIGlmIChpc1N0cmluZyhlbCkgfHwgaXNOdW1iZXIoZWwpKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0UHJvdmlkZXIoXCJ0ZXh0X1wiICsgZWwsIGtleSwgaW5kZXgsIGNvbnRhaW5lciwgbnVsbCwge30pO1xuICB9XG5cbiAgdmFyIHByb3ZpZGVyQ2xhc3MgPSB0eXBlb2YgZWwudHlwZSA9PT0gXCJzdHJpbmdcIiA/IEVsZW1lbnRQcm92aWRlciA6IGVsLnR5cGUucHJvdG90eXBlLnJlbmRlciA/IENvbXBvbmVudFByb3ZpZGVyIDogRnVuY3Rpb25Qcm92aWRlcjtcbiAgcmV0dXJuIG5ldyBwcm92aWRlckNsYXNzKGVsLnR5cGUsIGtleSwgaW5kZXgsIGNvbnRhaW5lciwgZWwucmVmLCBlbC5wcm9wcyk7XG59XG5cbmZ1bmN0aW9uIGZsYXQoYXJyKSB7XG4gIHZhciBhcnIyID0gW107XG4gIGFyci5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgIGFycjIgPSBhcnIyLmNvbmNhdChpc0FycmF5KGVsKSA/IGZsYXQoZWwpIDogZWwpO1xuICB9KTtcbiAgcmV0dXJuIGFycjI7XG59XG5cbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZXMocHJvcHMpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIG90aGVyUHJvcHMgPSBfX3Jlc3QocHJvcHMsIFtcImNsYXNzTmFtZVwiXSk7XG5cbiAgaWYgKGNsYXNzTmFtZSAhPSBudWxsKSB7XG4gICAgb3RoZXJQcm9wcy5jbGFzcyA9IGNsYXNzTmFtZTtcbiAgfVxuXG4gIGRlbGV0ZSBvdGhlclByb3BzLnN0eWxlO1xuICBkZWxldGUgb3RoZXJQcm9wcy5jaGlsZHJlbjtcbiAgcmV0dXJuIG90aGVyUHJvcHM7XG59XG5cbmZ1bmN0aW9uIGZpbGxQcm9wcyhwcm9wcywgZGVmYXVsdFByb3BzKSB7XG4gIGlmICghZGVmYXVsdFByb3BzKSB7XG4gICAgcmV0dXJuIHByb3BzO1xuICB9XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICBpZiAoaXNVbmRlZmluZWQocHJvcHNbbmFtZV0pKSB7XG4gICAgICBwcm9wc1tuYW1lXSA9IGRlZmF1bHRQcm9wc1tuYW1lXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcHJvcHM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodHlwZSwgcHJvcHMpIHtcbiAgdmFyIGNoaWxkcmVuID0gW107XG5cbiAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICBjaGlsZHJlbltfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcbiAgfVxuXG4gIHZhciBfYSA9IHByb3BzIHx8IHt9LFxuICAgICAga2V5ID0gX2Eua2V5LFxuICAgICAgcmVmID0gX2EucmVmLFxuICAgICAgb3RoZXJQcm9wcyA9IF9fcmVzdChfYSwgW1wia2V5XCIsIFwicmVmXCJdKTtcblxuICByZXR1cm4ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IF9fYXNzaWduKF9fYXNzaWduKHt9LCBvdGhlclByb3BzKSwge1xuICAgICAgY2hpbGRyZW46IGZsYXQoY2hpbGRyZW4pLmZpbHRlcihmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkICE9IG51bGwgJiYgY2hpbGQgIT09IGZhbHNlO1xuICAgICAgfSlcbiAgICB9KVxuICB9O1xufVxuXG52YXIgUHJvdmlkZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQcm92aWRlcih0eXBlLCBrZXksIGluZGV4LCBjb250YWluZXIsIHJlZiwgcHJvcHMpIHtcbiAgICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgICAgcHJvcHMgPSB7fTtcbiAgICB9XG5cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLnJlZiA9IHJlZjtcbiAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgdGhpcy5fcHJvdmlkZXJzID0gW107XG4gIH1cblxuICB2YXIgX19wcm90byA9IFByb3ZpZGVyLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLl9zaG91bGQgPSBmdW5jdGlvbiAobmV4dFByb3BzLCBuZXh0U3RhdGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBfX3Byb3RvLl91cGRhdGUgPSBmdW5jdGlvbiAoaG9va3MsIG5leHRFbGVtZW50LCBuZXh0U3RhdGUsIGlzRm9yY2VVcGRhdGUpIHtcbiAgICBpZiAodGhpcy5iYXNlICYmICFpc1N0cmluZyhuZXh0RWxlbWVudCkgJiYgIWlzRm9yY2VVcGRhdGUgJiYgIXRoaXMuX3Nob3VsZChuZXh0RWxlbWVudC5wcm9wcywgbmV4dFN0YXRlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMub3JpZ2luYWwgPSBuZXh0RWxlbWVudDtcblxuICAgIHRoaXMuX3NldFN0YXRlKG5leHRTdGF0ZSk7IC8vIHJlbmRlclxuXG5cbiAgICB2YXIgcHJldlByb3BzID0gdGhpcy5wcm9wcztcblxuICAgIGlmICghaXNTdHJpbmcobmV4dEVsZW1lbnQpKSB7XG4gICAgICB0aGlzLnByb3BzID0gbmV4dEVsZW1lbnQucHJvcHM7XG4gICAgICB0aGlzLnJlZiA9IG5leHRFbGVtZW50LnJlZjtcbiAgICB9XG5cbiAgICB0aGlzLl9yZW5kZXIoaG9va3MsIHRoaXMuYmFzZSA/IHByZXZQcm9wcyA6IHt9LCBuZXh0U3RhdGUpO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgX19wcm90by5fbW91bnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVmID0gdGhpcy5yZWY7XG4gICAgcmVmICYmIHJlZih0aGlzLmJhc2UpO1xuICB9O1xuXG4gIF9fcHJvdG8uX3NldFN0YXRlID0gZnVuY3Rpb24gKG5leHRzdGF0ZSkge1xuICAgIHJldHVybjtcbiAgfTtcblxuICBfX3Byb3RvLl91cGRhdGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZWYgPSB0aGlzLnJlZjtcbiAgICByZWYgJiYgcmVmKHRoaXMuYmFzZSk7XG4gIH07XG5cbiAgX19wcm90by5fZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVmID0gdGhpcy5yZWY7XG4gICAgcmVmICYmIHJlZihudWxsKTtcbiAgfTtcblxuICByZXR1cm4gUHJvdmlkZXI7XG59KCk7XG5cbmZ1bmN0aW9uIGRpZmZBdHRyaWJ1dGVzKGF0dHJzMSwgYXR0cnMyLCBlbCkge1xuICB2YXIgX2EgPSBkaWZmT2JqZWN0KGF0dHJzMSwgYXR0cnMyKSxcbiAgICAgIGFkZGVkID0gX2EuYWRkZWQsXG4gICAgICByZW1vdmVkID0gX2EucmVtb3ZlZCxcbiAgICAgIGNoYW5nZWQgPSBfYS5jaGFuZ2VkO1xuXG4gIGZvciAodmFyIG5hbWUgaW4gYWRkZWQpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUobmFtZSwgYWRkZWRbbmFtZV0pO1xuICB9XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBjaGFuZ2VkKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKG5hbWUsIGNoYW5nZWRbbmFtZV1bMV0pO1xuICB9XG5cbiAgZm9yICh2YXIgbmFtZSBpbiByZW1vdmVkKSB7XG4gICAgZWwucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRpZmZFdmVudHMoZXZlbnRzMSwgZXZlbnRzMiwgcHJvdmllcikge1xuICB2YXIgX2EgPSBkaWZmT2JqZWN0KGV2ZW50czEsIGV2ZW50czIpLFxuICAgICAgYWRkZWQgPSBfYS5hZGRlZCxcbiAgICAgIHJlbW92ZWQgPSBfYS5yZW1vdmVkLFxuICAgICAgY2hhbmdlZCA9IF9hLmNoYW5nZWQ7XG5cbiAgZm9yICh2YXIgbmFtZSBpbiByZW1vdmVkKSB7XG4gICAgcHJvdmllci5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUpO1xuICB9XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBhZGRlZCkge1xuICAgIHByb3ZpZXIuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBhZGRlZFtuYW1lXSk7XG4gIH1cblxuICBmb3IgKHZhciBuYW1lIGluIGNoYW5nZWQpIHtcbiAgICBwcm92aWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSk7XG4gICAgcHJvdmllci5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGNoYW5nZWRbbmFtZV1bMV0pO1xuICB9XG5cbiAgZm9yICh2YXIgbmFtZSBpbiByZW1vdmVkKSB7XG4gICAgcHJvdmllci5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRpZmZTdHlsZShzdHlsZTEsIHN0eWxlMiwgZWwpIHtcbiAgdmFyIHN0eWxlID0gZWwuc3R5bGU7XG5cbiAgdmFyIF9hID0gZGlmZk9iamVjdChzdHlsZTEsIHN0eWxlMiksXG4gICAgICBhZGRlZCA9IF9hLmFkZGVkLFxuICAgICAgcmVtb3ZlZCA9IF9hLnJlbW92ZWQsXG4gICAgICBjaGFuZ2VkID0gX2EuY2hhbmdlZDtcblxuICBmb3IgKHZhciBiZWZvcmVOYW1lIGluIGFkZGVkKSB7XG4gICAgdmFyIG5hbWUgPSBkZWNhbWVsaXplKGJlZm9yZU5hbWUsIFwiLVwiKTtcblxuICAgIGlmIChzdHlsZS5zZXRQcm9wZXJ0eSkge1xuICAgICAgc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgYWRkZWRbYmVmb3JlTmFtZV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZVtuYW1lXSA9IGFkZGVkW2JlZm9yZU5hbWVdO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGJlZm9yZU5hbWUgaW4gY2hhbmdlZCkge1xuICAgIHZhciBuYW1lID0gZGVjYW1lbGl6ZShiZWZvcmVOYW1lLCBcIi1cIik7XG5cbiAgICBpZiAoc3R5bGUuc2V0UHJvcGVydHkpIHtcbiAgICAgIHN0eWxlLnNldFByb3BlcnR5KG5hbWUsIGNoYW5nZWRbYmVmb3JlTmFtZV1bMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZVtuYW1lXSA9IGNoYW5nZWRbYmVmb3JlTmFtZV1bMV07XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgYmVmb3JlTmFtZSBpbiByZW1vdmVkKSB7XG4gICAgdmFyIG5hbWUgPSBkZWNhbWVsaXplKGJlZm9yZU5hbWUsIFwiLVwiKTtcblxuICAgIGlmIChzdHlsZS5yZW1vdmVQcm9wZXJ0eSkge1xuICAgICAgc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlW25hbWVdID0gXCJcIjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3BsaXRQcm9wcyhwcm9wcykge1xuICB2YXIgYXR0cmlidXRlcyA9IHt9O1xuICB2YXIgZXZlbnRzID0ge307XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBwcm9wcykge1xuICAgIGlmIChuYW1lLmluZGV4T2YoXCJvblwiKSA9PT0gMCkge1xuICAgICAgZXZlbnRzW25hbWUucmVwbGFjZShcIm9uXCIsIFwiXCIpLnRvTG93ZXJDYXNlKCldID0gcHJvcHNbbmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGF0dHJpYnV0ZXNbbmFtZV0gPSBwcm9wc1tuYW1lXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXMsXG4gICAgZXZlbnRzOiBldmVudHNcbiAgfTtcbn1cblxudmFyIFRleHRQcm92aWRlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhUZXh0UHJvdmlkZXIsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gVGV4dFByb3ZpZGVyKCkge1xuICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfX3Byb3RvID0gVGV4dFByb3ZpZGVyLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLl9yZW5kZXIgPSBmdW5jdGlvbiAoaG9va3MpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGlzTW91bnQgPSAhdGhpcy5iYXNlO1xuXG4gICAgaWYgKGlzTW91bnQpIHtcbiAgICAgIHRoaXMuYmFzZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMudHlwZS5yZXBsYWNlKFwidGV4dF9cIiwgXCJcIikpO1xuICAgIH1cblxuICAgIGhvb2tzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGlzTW91bnQpIHtcbiAgICAgICAgX3RoaXMuX21vdW50ZWQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLl91cGRhdGVkKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgX19wcm90by5fdW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmJhc2UucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmJhc2UpO1xuICB9O1xuXG4gIHJldHVybiBUZXh0UHJvdmlkZXI7XG59KFByb3ZpZGVyKTtcblxudmFyIEVsZW1lbnRQcm92aWRlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhFbGVtZW50UHJvdmlkZXIsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gRWxlbWVudFByb3ZpZGVyKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMuZXZlbnRzID0ge307XG4gICAgX3RoaXMuX2lzU1ZHID0gZmFsc2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9fcHJvdG8gPSBFbGVtZW50UHJvdmlkZXIucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8uYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaykge1xuICAgIHZhciBldmVudHMgPSB0aGlzLmV2ZW50cztcblxuICAgIGV2ZW50c1tuYW1lXSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBlLm5hdGl2ZUV2ZW50ID0gZTtcbiAgICAgIGNhbGxiYWNrKGUpO1xuICAgIH07XG5cbiAgICB0aGlzLmJhc2UuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBldmVudHNbbmFtZV0pO1xuICB9O1xuXG4gIF9fcHJvdG8ucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIGV2ZW50cyA9IHRoaXMuZXZlbnRzO1xuICAgIHRoaXMuYmFzZS5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGV2ZW50c1tuYW1lXSk7XG4gICAgZGVsZXRlIGV2ZW50c1tuYW1lXTtcbiAgfTtcblxuICBfX3Byb3RvLl9zaG91bGQgPSBmdW5jdGlvbiAobmV4dFByb3BzKSB7XG4gICAgcmV0dXJuIGlzRGlmZih0aGlzLnByb3BzLCBuZXh0UHJvcHMpO1xuICB9O1xuXG4gIF9fcHJvdG8uX3JlbmRlciA9IGZ1bmN0aW9uIChob29rcywgcHJldlByb3BzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBpc01vdW50ID0gIXRoaXMuYmFzZTtcblxuICAgIGlmIChpc01vdW50KSB7XG4gICAgICB2YXIgaXNTVkcgPSB0aGlzLl9oYXNTVkcoKTtcblxuICAgICAgdGhpcy5faXNTVkcgPSBpc1NWRztcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5wcm9wcy5wb3J0YWxDb250YWluZXI7XG5cbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuICAgICAgICBpZiAoaXNTVkcpIHtcbiAgICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgdHlwZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5iYXNlID0gZWxlbWVudDtcbiAgICB9XG5cbiAgICByZW5kZXJQcm92aWRlcnModGhpcywgdGhpcy5fcHJvdmlkZXJzLCB0aGlzLnByb3BzLmNoaWxkcmVuLCBob29rcywgbnVsbCk7XG4gICAgdmFyIGJhc2UgPSB0aGlzLmJhc2U7XG5cbiAgICB2YXIgX2EgPSBzcGxpdFByb3BzKHByZXZQcm9wcyksXG4gICAgICAgIHByZXZBdHRyaWJ1dGVzID0gX2EuYXR0cmlidXRlcyxcbiAgICAgICAgcHJldkV2ZW50cyA9IF9hLmV2ZW50cztcblxuICAgIHZhciBfYiA9IHNwbGl0UHJvcHModGhpcy5wcm9wcyksXG4gICAgICAgIG5leHRBdHRyaWJ1dGVzID0gX2IuYXR0cmlidXRlcyxcbiAgICAgICAgbmV4dEV2ZW50cyA9IF9iLmV2ZW50cztcblxuICAgIGRpZmZBdHRyaWJ1dGVzKGdldEF0dHJpYnV0ZXMocHJldkF0dHJpYnV0ZXMpLCBnZXRBdHRyaWJ1dGVzKG5leHRBdHRyaWJ1dGVzKSwgYmFzZSk7XG4gICAgZGlmZkV2ZW50cyhwcmV2RXZlbnRzLCBuZXh0RXZlbnRzLCB0aGlzKTtcbiAgICBkaWZmU3R5bGUocHJldlByb3BzLnN0eWxlIHx8IHt9LCB0aGlzLnByb3BzLnN0eWxlIHx8IHt9LCBiYXNlKTtcbiAgICBob29rcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpc01vdW50KSB7XG4gICAgICAgIF90aGlzLl9tb3VudGVkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy5fdXBkYXRlZCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIF9fcHJvdG8uX3VubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV2ZW50cyA9IHRoaXMuZXZlbnRzO1xuICAgIHZhciBiYXNlID0gdGhpcy5iYXNlO1xuXG4gICAgZm9yICh2YXIgbmFtZSBpbiBldmVudHMpIHtcbiAgICAgIGJhc2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBldmVudHNbbmFtZV0pO1xuICAgIH1cblxuICAgIHRoaXMuX3Byb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgcHJvdmlkZXIuX3VubW91bnQoKTtcbiAgICB9KTtcblxuICAgIHRoaXMuZXZlbnRzID0ge307XG5cbiAgICBpZiAoIXRoaXMucHJvcHMucG9ydGFsQ29udGFpbmVyKSB7XG4gICAgICBiYXNlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYmFzZSk7XG4gICAgfVxuICB9O1xuXG4gIF9fcHJvdG8uX2hhc1NWRyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5faXNTVkcgfHwgdGhpcy50eXBlID09PSBcInN2Z1wiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgY29udGFpbmVyTm9kZSA9IGZpbmRDb250YWluZXJOb2RlKHRoaXMuY29udGFpbmVyKTtcbiAgICByZXR1cm4gY29udGFpbmVyTm9kZSAmJiBcIm93bmVyU1ZHRWxlbWVudFwiIGluIGNvbnRhaW5lck5vZGU7XG4gIH07XG5cbiAgcmV0dXJuIEVsZW1lbnRQcm92aWRlcjtcbn0oUHJvdmlkZXIpO1xuXG5mdW5jdGlvbiBmaW5kQ29udGFpbmVyTm9kZShwcm92aWRlcikge1xuICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgYmFzZSA9IHByb3ZpZGVyLmJhc2U7XG5cbiAgaWYgKGJhc2UgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cblxuICByZXR1cm4gZmluZENvbnRhaW5lck5vZGUocHJvdmlkZXIuY29udGFpbmVyKTtcbn1cblxuZnVuY3Rpb24gZmluZERPTU5vZGUoY29tcCkge1xuICBpZiAoIWNvbXApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChjb21wIGluc3RhbmNlb2YgTm9kZSkge1xuICAgIHJldHVybiBjb21wO1xuICB9XG5cbiAgdmFyIHByb3ZpZGVycyA9IGNvbXAuJF9wcm92aWRlci5fcHJvdmlkZXJzO1xuXG4gIGlmICghcHJvdmlkZXJzLmxlbmd0aCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGZpbmRET01Ob2RlKHByb3ZpZGVyc1swXS5iYXNlKTtcbn1cblxudmFyIEZ1bmN0aW9uUHJvdmlkZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoRnVuY3Rpb25Qcm92aWRlciwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBGdW5jdGlvblByb3ZpZGVyKCkge1xuICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfX3Byb3RvID0gRnVuY3Rpb25Qcm92aWRlci5wcm90b3R5cGU7XG5cbiAgX19wcm90by5fcmVuZGVyID0gZnVuY3Rpb24gKGhvb2tzKSB7XG4gICAgdmFyIHRlbXBsYXRlID0gdGhpcy50eXBlKHRoaXMucHJvcHMpO1xuICAgIHJlbmRlclByb3ZpZGVycyh0aGlzLCB0aGlzLl9wcm92aWRlcnMsIHRlbXBsYXRlID8gW3RlbXBsYXRlXSA6IFtdLCBob29rcyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgX19wcm90by5fdW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9wcm92aWRlcnMuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgIHByb3ZpZGVyLl91bm1vdW50KCk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIEZ1bmN0aW9uUHJvdmlkZXI7XG59KFByb3ZpZGVyKTtcblxudmFyIENvbnRhaW5lclByb3ZpZGVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKENvbnRhaW5lclByb3ZpZGVyLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIENvbnRhaW5lclByb3ZpZGVyKGJhc2UpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBcImNvbnRhaW5lclwiLCBcImNvbnRhaW5lclwiLCAwLCBudWxsKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMuYmFzZSA9IGJhc2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9fcHJvdG8gPSBDb250YWluZXJQcm92aWRlci5wcm90b3R5cGU7XG5cbiAgX19wcm90by5fcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIF9fcHJvdG8uX3VubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuO1xuICB9O1xuXG4gIHJldHVybiBDb250YWluZXJQcm92aWRlcjtcbn0oUHJvdmlkZXIpO1xuXG52YXIgQ29tcG9uZW50UHJvdmlkZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoQ29tcG9uZW50UHJvdmlkZXIsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gQ29tcG9uZW50UHJvdmlkZXIodHlwZSwga2V5LCBpbmRleCwgY29udGFpbmVyLCByZWYsIHByb3BzKSB7XG4gICAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICAgIHByb3BzID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIGtleSwgaW5kZXgsIGNvbnRhaW5lciwgcmVmLCBmaWxsUHJvcHMocHJvcHMsIHR5cGUuZGVmYXVsdFByb3BzKSkgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfX3Byb3RvID0gQ29tcG9uZW50UHJvdmlkZXIucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8uX3Nob3VsZCA9IGZ1bmN0aW9uIChuZXh0UHJvcHMsIG5leHRTdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLmJhc2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKGZpbGxQcm9wcyhuZXh0UHJvcHMsIHRoaXMudHlwZS5kZWZhdWx0UHJvcHMpLCBuZXh0U3RhdGUgfHwgdGhpcy5iYXNlLnN0YXRlKTtcbiAgfTtcblxuICBfX3Byb3RvLl9yZW5kZXIgPSBmdW5jdGlvbiAoaG9va3MsIHByZXZQcm9wcywgbmV4dFN0YXRlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMucHJvcHMgPSBmaWxsUHJvcHModGhpcy5wcm9wcywgdGhpcy50eXBlLmRlZmF1bHRQcm9wcyk7XG4gICAgdmFyIGlzTW91bnQgPSAhdGhpcy5iYXNlO1xuXG4gICAgaWYgKGlzTW91bnQpIHtcbiAgICAgIHRoaXMuYmFzZSA9IG5ldyB0aGlzLnR5cGUodGhpcy5wcm9wcyk7XG4gICAgICB0aGlzLmJhc2UuJF9wcm92aWRlciA9IHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYmFzZS5wcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgfVxuXG4gICAgdmFyIGJhc2UgPSB0aGlzLmJhc2U7XG4gICAgdmFyIHByZXZTdGF0ZSA9IGJhc2Uuc3RhdGU7XG4gICAgdmFyIHRlbXBsYXRlID0gYmFzZS5yZW5kZXIoKTtcblxuICAgIGlmICh0ZW1wbGF0ZSAmJiB0ZW1wbGF0ZS5wcm9wcyAmJiAhdGVtcGxhdGUucHJvcHMuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICB0ZW1wbGF0ZS5wcm9wcy5jaGlsZHJlbiA9IHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgfVxuXG4gICAgcmVuZGVyUHJvdmlkZXJzKHRoaXMsIHRoaXMuX3Byb3ZpZGVycywgdGVtcGxhdGUgPyBbdGVtcGxhdGVdIDogW10sIGhvb2tzLCBuZXh0U3RhdGUsIG51bGwpO1xuICAgIGhvb2tzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGlzTW91bnQpIHtcbiAgICAgICAgX3RoaXMuX21vdW50ZWQoKTtcblxuICAgICAgICBiYXNlLmNvbXBvbmVudERpZE1vdW50KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy5fdXBkYXRlZCgpO1xuXG4gICAgICAgIGJhc2UuY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBfX3Byb3RvLl9zZXRTdGF0ZSA9IGZ1bmN0aW9uIChuZXh0U3RhdGUpIHtcbiAgICBpZiAoIW5leHRTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBiYXNlID0gdGhpcy5iYXNlO1xuICAgIGJhc2Uuc3RhdGUgPSBuZXh0U3RhdGU7XG4gIH07XG5cbiAgX19wcm90by5fdW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9wcm92aWRlcnMuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgIHByb3ZpZGVyLl91bm1vdW50KCk7XG4gICAgfSk7XG5cbiAgICBjbGVhclRpbWVvdXQodGhpcy5iYXNlLiRfdGltZXIpO1xuICAgIHRoaXMuYmFzZS5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICB9O1xuXG4gIHJldHVybiBDb21wb25lbnRQcm92aWRlcjtcbn0oUHJvdmlkZXIpO1xuXG52YXIgQ29tcG9uZW50ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29tcG9uZW50KHByb3BzKSB7XG4gICAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICAgIHByb3BzID0ge307XG4gICAgfVxuXG4gICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgIHRoaXMuc3RhdGUgPSB7fTtcbiAgICB0aGlzLiRfdGltZXIgPSAwO1xuICAgIHRoaXMuJF9zdGF0ZSA9IHt9O1xuICB9XG5cbiAgdmFyIF9fcHJvdG8gPSBDb21wb25lbnQucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8uc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZnVuY3Rpb24gKHByb3BzLCBzdGF0ZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIF9fcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIF9fcHJvdG8uc2V0U3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUsIGNhbGxiYWNrLCBpc0ZvcmNlVXBkYXRlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmICghdGhpcy4kX3RpbWVyKSB7XG4gICAgICB0aGlzLiRfc3RhdGUgPSB7fTtcbiAgICB9XG5cbiAgICBjbGVhclRpbWVvdXQodGhpcy4kX3RpbWVyKTtcbiAgICB0aGlzLiRfdGltZXIgPSAwO1xuICAgIHRoaXMuJF9zdGF0ZSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCB0aGlzLiRfc3RhdGUpLCBzdGF0ZSk7XG5cbiAgICBpZiAoIWlzRm9yY2VVcGRhdGUpIHtcbiAgICAgIHRoaXMuJF90aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy4kX3RpbWVyID0gMDtcblxuICAgICAgICBfdGhpcy4kX3NldFN0YXRlKGNhbGxiYWNrLCBpc0ZvcmNlVXBkYXRlKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiRfc2V0U3RhdGUoY2FsbGJhY2ssIGlzRm9yY2VVcGRhdGUpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfTtcblxuICBfX3Byb3RvLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7fSwgY2FsbGJhY2ssIHRydWUpO1xuICB9O1xuXG4gIF9fcHJvdG8uY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBfX3Byb3RvLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIChwcmV2UHJvcHMsIHByZXZTdGF0ZSkge307XG5cbiAgX19wcm90by5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIF9fcHJvdG8uJF9zZXRTdGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaywgaXNGb3JjZVVwZGF0ZSkge1xuICAgIHZhciBob29rcyA9IFtdO1xuICAgIHZhciBwcm92aWRlciA9IHRoaXMuJF9wcm92aWRlcjtcbiAgICB2YXIgaXNVcGRhdGUgPSByZW5kZXJQcm92aWRlcnMocHJvdmlkZXIuY29udGFpbmVyLCBbcHJvdmlkZXJdLCBbcHJvdmlkZXIub3JpZ2luYWxdLCBob29rcywgX19hc3NpZ24oX19hc3NpZ24oe30sIHRoaXMuc3RhdGUpLCB0aGlzLiRfc3RhdGUpLCBpc0ZvcmNlVXBkYXRlKTtcblxuICAgIGlmIChpc1VwZGF0ZSkge1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGhvb2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgfVxuXG4gICAgICBleGVjdXRlSG9va3MoaG9va3MpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gQ29tcG9uZW50O1xufSgpO1xuXG52YXIgUHVyZUNvbXBvbmVudCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhQdXJlQ29tcG9uZW50LCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFB1cmVDb21wb25lbnQoKSB7XG4gICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9fcHJvdG8gPSBQdXJlQ29tcG9uZW50LnByb3RvdHlwZTtcblxuICBfX3Byb3RvLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZ1bmN0aW9uIChwcm9wcywgc3RhdGUpIHtcbiAgICByZXR1cm4gaXNEaWZmKHRoaXMucHJvcHMsIHByb3BzKSB8fCBpc0RpZmYodGhpcy5zdGF0ZSwgc3RhdGUpO1xuICB9O1xuXG4gIHJldHVybiBQdXJlQ29tcG9uZW50O1xufShDb21wb25lbnQpO1xuXG52YXIgX1BvcnRhbCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhfUG9ydGFsLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIF9Qb3J0YWwoKSB7XG4gICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9fcHJvdG8gPSBfUG9ydGFsLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfYSA9IHRoaXMucHJvcHMsXG4gICAgICAgIGVsZW1lbnQgPSBfYS5lbGVtZW50LFxuICAgICAgICBjb250YWluZXIgPSBfYS5jb250YWluZXI7XG4gICAgdGhpcy5fcG9ydGFsUHJvdmlkZXIgPSBuZXcgQ29udGFpbmVyUHJvdmlkZXIoY29udGFpbmVyKTtcbiAgICByZW5kZXJQcm92aWRlcihlbGVtZW50LCBjb250YWluZXIsIHRoaXMuX3BvcnRhbFByb3ZpZGVyKTtcbiAgfTtcblxuICBfX3Byb3RvLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2EgPSB0aGlzLnByb3BzLFxuICAgICAgICBlbGVtZW50ID0gX2EuZWxlbWVudCxcbiAgICAgICAgY29udGFpbmVyID0gX2EuY29udGFpbmVyO1xuICAgIHJlbmRlclByb3ZpZGVyKGVsZW1lbnQsIGNvbnRhaW5lciwgdGhpcy5fcG9ydGFsUHJvdmlkZXIpO1xuICB9O1xuXG4gIF9fcHJvdG8uY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IHRoaXMucHJvcHMuY29udGFpbmVyO1xuICAgIHJlbmRlclByb3ZpZGVyKG51bGwsIGNvbnRhaW5lciwgdGhpcy5fcG9ydGFsUHJvdmlkZXIpO1xuICAgIHRoaXMuX3BvcnRhbFByb3ZpZGVyID0gbnVsbDtcbiAgfTtcblxuICByZXR1cm4gX1BvcnRhbDtcbn0oUHVyZUNvbXBvbmVudCk7XG5cbmZ1bmN0aW9uIHVwZGF0ZVByb3ZpZGVyKHByb3ZpZGVyLCBjaGlsZHJlbiwgbmV4dFN0YXRlKSB7XG4gIHZhciBob29rcyA9IFtdO1xuICByZW5kZXJQcm92aWRlcnMocHJvdmlkZXIsIHByb3ZpZGVyLl9wcm92aWRlcnMsIGNoaWxkcmVuLCBob29rcywgbmV4dFN0YXRlKTtcbiAgZXhlY3V0ZUhvb2tzKGhvb2tzKTtcbn1cblxuZnVuY3Rpb24gZ2V0TmV4dFNpYmlsaW5nKHByb3ZpZGVyLCBjaGlsZFByb3ZpZGVyKSB7XG4gIHZhciBjaGlsZFByb3ZpZGVycyA9IHByb3ZpZGVyLl9wcm92aWRlcnM7XG4gIHZhciBsZW5ndGggPSBjaGlsZFByb3ZpZGVycy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IGNoaWxkUHJvdmlkZXIuaW5kZXggKyAxOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgZWwgPSBmaW5kRE9NTm9kZShjaGlsZFByb3ZpZGVyc1tpXS5iYXNlKTtcblxuICAgIGlmIChlbCkge1xuICAgICAgcmV0dXJuIGVsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBkaWZmUHJvdmlkZXJzKGNvbnRhaW5lclByb3ZpZGVyLCBwcm92aWRlcnMsIGNoaWxkcmVuKSB7XG4gIHZhciBjaGlsZHJlbktleXMgPSBjaGlsZHJlbi5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gaXNTdHJpbmcocCkgPyBudWxsIDogcC5rZXk7XG4gIH0pO1xuICB2YXIga2V5czEgPSBmaWxsS2V5cyhwcm92aWRlcnMubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIHAua2V5O1xuICB9KSk7XG4gIHZhciBrZXlzMiA9IGZpbGxLZXlzKGNoaWxkcmVuS2V5cyk7XG4gIHZhciByZXN1bHQgPSBkaWZmKGtleXMxLCBrZXlzMiwgZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBrZXk7XG4gIH0pO1xuICByZXN1bHQucmVtb3ZlZC5mb3JFYWNoKGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHByb3ZpZGVycy5zcGxpY2UoaW5kZXgsIDEpWzBdLl91bm1vdW50KCk7XG4gIH0pO1xuICByZXN1bHQub3JkZXJlZC5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBmcm9tID0gX2FbMF0sXG4gICAgICAgIHRvID0gX2FbMV07XG4gICAgdmFyIGNoaWxkcmVuUHJvdmlkZXIgPSBwcm92aWRlcnMuc3BsaWNlKGZyb20sIDEpWzBdO1xuICAgIHByb3ZpZGVycy5zcGxpY2UodG8sIDAsIGNoaWxkcmVuUHJvdmlkZXIpO1xuICAgIHZhciBlbCA9IGZpbmRET01Ob2RlKGNoaWxkcmVuUHJvdmlkZXIuYmFzZSk7XG4gICAgdmFyIG5leHQgPSBmaW5kRE9NTm9kZShwcm92aWRlcnNbdG8gKyAxXSAmJiBwcm92aWRlcnNbdG8gKyAxXS5iYXNlKTtcblxuICAgIGlmIChlbCkge1xuICAgICAgZWwucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWwsIG5leHQpO1xuICAgIH1cbiAgfSk7XG4gIHJlc3VsdC5hZGRlZC5mb3JFYWNoKGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHByb3ZpZGVycy5zcGxpY2UoaW5kZXgsIDAsIGNyZWF0ZVByb3ZpZGVyKGNoaWxkcmVuW2luZGV4XSwgY2hpbGRyZW5LZXlzW2luZGV4XSwgaW5kZXgsIGNvbnRhaW5lclByb3ZpZGVyKSk7XG4gIH0pO1xuICB2YXIgY2hhbmdlZCA9IHJlc3VsdC5tYWludGFpbmVkLmZpbHRlcihmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgXyA9IF9hWzBdLFxuICAgICAgICB0byA9IF9hWzFdO1xuICAgIHZhciBlbCA9IGNoaWxkcmVuW3RvXTtcbiAgICB2YXIgY2hpbGRQcm92aWRlciA9IHByb3ZpZGVyc1t0b107XG4gICAgdmFyIHR5cGUgPSBpc1N0cmluZyhlbCkgPyBcInRleHRfXCIgKyBlbCA6IGVsLnR5cGU7XG5cbiAgICBpZiAodHlwZSAhPT0gY2hpbGRQcm92aWRlci50eXBlKSB7XG4gICAgICBjaGlsZFByb3ZpZGVyLl91bm1vdW50KCk7XG5cbiAgICAgIHByb3ZpZGVycy5zcGxpY2UodG8sIDEsIGNyZWF0ZVByb3ZpZGVyKGVsLCBjaGlsZHJlbktleXNbdG9dLCB0bywgY29udGFpbmVyUHJvdmlkZXIpKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGNoaWxkUHJvdmlkZXIuaW5kZXggPSB0bztcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pO1xuICByZXR1cm4gX19zcHJlYWRBcnJheXMocmVzdWx0LmFkZGVkLCBjaGFuZ2VkLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgXyA9IF9hWzBdLFxuICAgICAgICB0byA9IF9hWzFdO1xuICAgIHJldHVybiB0bztcbiAgfSkpO1xufVxuXG5mdW5jdGlvbiByZW5kZXJQcm92aWRlcnMoY29udGFpbmVyUHJvdmlkZXIsIHByb3ZpZGVycywgY2hpbGRyZW4sIHVwZGF0ZWRIb29rcywgbmV4dFN0YXRlLCBpc0ZvcmNlVXBkYXRlKSB7XG4gIHZhciByZXN1bHQgPSBkaWZmUHJvdmlkZXJzKGNvbnRhaW5lclByb3ZpZGVyLCBwcm92aWRlcnMsIGNoaWxkcmVuKTtcbiAgdmFyIHVwZGF0ZWQgPSBwcm92aWRlcnMuZmlsdGVyKGZ1bmN0aW9uIChjaGlsZFByb3ZpZGVyLCBpKSB7XG4gICAgcmV0dXJuIGNoaWxkUHJvdmlkZXIuX3VwZGF0ZSh1cGRhdGVkSG9va3MsIGNoaWxkcmVuW2ldLCBuZXh0U3RhdGUsIGlzRm9yY2VVcGRhdGUpO1xuICB9KTtcbiAgdmFyIGNvbnRhaW5lck5vZGUgPSBmaW5kQ29udGFpbmVyTm9kZShjb250YWluZXJQcm92aWRlcik7XG5cbiAgaWYgKGNvbnRhaW5lck5vZGUpIHtcbiAgICByZXN1bHQucmV2ZXJzZSgpLmZvckVhY2goZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICB2YXIgY2hpbGRQcm92aWRlciA9IHByb3ZpZGVyc1tpbmRleF07XG4gICAgICB2YXIgZWwgPSBmaW5kRE9NTm9kZShjaGlsZFByb3ZpZGVyLmJhc2UpO1xuXG4gICAgICBpZiAoIWVsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbnRhaW5lck5vZGUgIT09IGVsICYmICFlbC5wYXJlbnROb2RlKSB7XG4gICAgICAgIHZhciBuZXh0RWxlbWVudCA9IGdldE5leHRTaWJpbGluZyhjb250YWluZXJQcm92aWRlciwgY2hpbGRQcm92aWRlcik7XG4gICAgICAgIGNvbnRhaW5lck5vZGUuaW5zZXJ0QmVmb3JlKGVsLCBuZXh0RWxlbWVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdXBkYXRlZC5sZW5ndGggPiAwO1xufVxuXG5mdW5jdGlvbiByZW5kZXJQcm92aWRlcihlbGVtZW50LCBjb250YWluZXIsIHByb3ZpZGVyKSB7XG4gIGlmIChwcm92aWRlciA9PT0gdm9pZCAwKSB7XG4gICAgcHJvdmlkZXIgPSBjb250YWluZXIuX19SRUFDVF9DT01QQVRfXztcbiAgfVxuXG4gIHZhciBpc1Byb3ZpZGVyID0gISFwcm92aWRlcjtcblxuICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgcHJvdmlkZXIgPSBuZXcgQ29udGFpbmVyUHJvdmlkZXIoY29udGFpbmVyKTtcbiAgfVxuXG4gIHVwZGF0ZVByb3ZpZGVyKHByb3ZpZGVyLCBlbGVtZW50ID8gW2VsZW1lbnRdIDogW10pO1xuXG4gIGlmICghaXNQcm92aWRlcikge1xuICAgIGNvbnRhaW5lci5fX1JFQUNUX0NPTVBBVF9fID0gcHJvdmlkZXI7XG4gIH1cblxuICByZXR1cm4gcHJvdmlkZXI7XG59XG5cbmZ1bmN0aW9uIHJlbmRlcihlbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gIHZhciBwcm92aWRlciA9IGNvbnRhaW5lci5fX1JFQUNUX0NPTVBBVF9fO1xuXG4gIGlmIChlbGVtZW50ICYmICFwcm92aWRlcikge1xuICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBcIlwiO1xuICB9XG5cbiAgcmVuZGVyUHJvdmlkZXIoZWxlbWVudCwgY29udGFpbmVyLCBwcm92aWRlcik7XG4gIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG59XG5mdW5jdGlvbiBjcmVhdGVQb3J0YWwoZWwsIGNvbnRhaW5lcikge1xuICByZXR1cm4gY3JlYXRlRWxlbWVudChfUG9ydGFsLCB7XG4gICAgZWxlbWVudDogZWwsXG4gICAgY29udGFpbmVyOiBjb250YWluZXJcbiAgfSk7XG59XG52YXIgdmVyc2lvbiA9IFwic2ltcGxlLTEuMS4wXCI7XG5cbmV4cG9ydCB7IENvbXBvbmVudCwgUHVyZUNvbXBvbmVudCwgY3JlYXRlRWxlbWVudCwgY3JlYXRlUG9ydGFsLCBmaW5kRE9NTm9kZSwgcmVuZGVyLCB2ZXJzaW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wYXQuZXNtLmpzLm1hcFxuIiwiLypcbkNvcHlyaWdodCAoYykgMjAyMCBEYXlicnVzaFxubmFtZTogc2VsZWN0b1xubGljZW5zZTogTUlUXG5hdXRob3I6IERheWJydXNoXG5yZXBvc2l0b3J5OiBnaXQraHR0cHM6Ly9naXRodWIuY29tL2RheWJydXNoL3NlbGVjdG8uZ2l0XG52ZXJzaW9uOiAxLjE1LjBcbiovXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ0BzY2VuYS9ldmVudC1lbWl0dGVyJztcbmltcG9ydCBHZXN0byBmcm9tICdnZXN0byc7XG5pbXBvcnQgeyBQcm9wZXJ0aWVzIH0gZnJvbSAnZnJhbWV3b3JrLXV0aWxzJztcbmltcG9ydCB7IGhhc0NsYXNzLCBhZGRDbGFzcywgY2FsY3VsYXRlQm91bmRTaXplLCBpc09iamVjdCwgaXNTdHJpbmcsIHJlbW92ZUV2ZW50LCBhZGRFdmVudCwgc3BsaXRVbml0LCBiZXR3ZWVuLCBpc0FycmF5LCBjYW1lbGl6ZSB9IGZyb20gJ0BkYXlicnVzaC91dGlscyc7XG5pbXBvcnQgeyBkaWZmIH0gZnJvbSAnQGVnanMvY2hpbGRyZW4tZGlmZmVyJztcbmltcG9ydCBEcmFnU2Nyb2xsIGZyb20gJ0BzY2VuYS9kcmFnc2Nyb2xsJztcbmltcG9ydCBLZXlDb250cm9sbGVyLCB7IGdldENvbWJpIH0gZnJvbSAna2V5Y29uJztcbmltcG9ydCB7IGZpdFBvaW50cywgaXNJbnNpZGUsIGdldE92ZXJsYXBQb2ludHMsIGdldEFyZWFTaXplIH0gZnJvbSAnb3ZlcmxhcC1hcmVhJztcbmltcG9ydCB7IGNyZWF0ZU1hdHJpeCwgZ2V0RGlzdEVsZW1lbnRNYXRyaXgsIGNhbGN1bGF0ZU1hdHJpeERpc3QgfSBmcm9tICdjc3MtdG8tbWF0JztcbmltcG9ydCBzdHlsZWQgZnJvbSAnY3NzLXN0eWxlZCc7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwge1xuICAgIF9fcHJvdG9fXzogW11cbiAgfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZC5fX3Byb3RvX18gPSBiO1xuICB9IHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gIH07XG5cbiAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG59O1xuXG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xuICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXG4gIGZ1bmN0aW9uIF9fKCkge1xuICAgIHRoaXMuY29uc3RydWN0b3IgPSBkO1xuICB9XG5cbiAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufVxudmFyIF9fYXNzaWduID0gZnVuY3Rpb24gKCkge1xuICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xuICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdDtcbiAgfTtcblxuICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5mdW5jdGlvbiBfX3Jlc3QocywgZSkge1xuICB2YXIgdCA9IHt9O1xuXG4gIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKSB0W3BdID0gc1twXTtcblxuICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpIHRbcFtpXV0gPSBzW3BbaV1dO1xuICB9XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYyxcbiAgICAgIGQ7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7ZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn1cbmZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xuICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcblxuICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKSByW2tdID0gYVtqXTtcblxuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gZ2V0Q2xpZW50KGUpIHtcbiAgaWYgKFwidG91Y2hlc1wiIGluIGUpIHtcbiAgICB2YXIgdG91Y2ggPSBlLnRvdWNoZXNbMF0gfHwgZS5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgY2xpZW50WDogdG91Y2guY2xpZW50WCxcbiAgICAgIGNsaWVudFk6IHRvdWNoLmNsaWVudFlcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICBjbGllbnRYOiBlLmNsaWVudFgsXG4gICAgICBjbGllbnRZOiBlLmNsaWVudFlcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KGpzeCwgcHJldlRhcmdldCwgY29udGFpbmVyKSB7XG4gIHZhciB0YWcgPSBqc3gudGFnLFxuICAgICAgY2hpbGRyZW4gPSBqc3guY2hpbGRyZW4sXG4gICAgICBhdHRyaWJ1dGVzID0ganN4LmF0dHJpYnV0ZXMsXG4gICAgICBjbGFzc05hbWUgPSBqc3guY2xhc3NOYW1lLFxuICAgICAgc3R5bGUgPSBqc3guc3R5bGU7XG4gIHZhciBlbCA9IHByZXZUYXJnZXQgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuXG4gIGZvciAodmFyIG5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgIGVsLnNldEF0dHJpYnV0ZShuYW1lLCBhdHRyaWJ1dGVzW25hbWVdKTtcbiAgfVxuXG4gIHZhciBlbENoaWxkcmVuID0gZWwuY2hpbGRyZW47XG4gIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkLCBpKSB7XG4gICAgY3JlYXRlRWxlbWVudChjaGlsZCwgZWxDaGlsZHJlbltpXSwgZWwpO1xuICB9KTtcblxuICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgY2xhc3NOYW1lLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBpZiAoIWhhc0NsYXNzKGVsLCBuYW1lKSkge1xuICAgICAgICBhZGRDbGFzcyhlbCwgbmFtZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoc3R5bGUpIHtcbiAgICB2YXIgZWxTdHlsZSA9IGVsLnN0eWxlO1xuXG4gICAgZm9yICh2YXIgbmFtZSBpbiBzdHlsZSkge1xuICAgICAgZWxTdHlsZVtuYW1lXSA9IHN0eWxlW25hbWVdO1xuICAgIH1cbiAgfVxuXG4gIGlmICghcHJldlRhcmdldCAmJiBjb250YWluZXIpIHtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwpO1xuICB9XG5cbiAgcmV0dXJuIGVsO1xufVxuZnVuY3Rpb24gaCh0YWcsIGF0dHJzKSB7XG4gIHZhciBjaGlsZHJlbiA9IFtdO1xuXG4gIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgY2hpbGRyZW5bX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gIH1cblxuICB2YXIgX2EgPSBhdHRycyB8fCB7fSxcbiAgICAgIF9iID0gX2EuY2xhc3NOYW1lLFxuICAgICAgY2xhc3NOYW1lID0gX2IgPT09IHZvaWQgMCA/IFwiXCIgOiBfYixcbiAgICAgIF9jID0gX2Euc3R5bGUsXG4gICAgICBzdHlsZSA9IF9jID09PSB2b2lkIDAgPyB7fSA6IF9jLFxuICAgICAgYXR0cmlidXRlcyA9IF9fcmVzdChfYSwgW1wiY2xhc3NOYW1lXCIsIFwic3R5bGVcIl0pO1xuXG4gIHJldHVybiB7XG4gICAgdGFnOiB0YWcsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgc3R5bGU6IHN0eWxlLFxuICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXMsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gIH07XG59XG5mdW5jdGlvbiBkaWZmVmFsdWUocHJldiwgY3VyLCBmdW5jKSB7XG4gIGlmIChwcmV2ICE9PSBjdXIpIHtcbiAgICBmdW5jKHByZXYsIGN1cik7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFJlY3QoZSwgcmF0aW8sIGJvdW5kQXJlYSkge1xuICB2YXIgX2E7XG5cbiAgaWYgKGJvdW5kQXJlYSA9PT0gdm9pZCAwKSB7XG4gICAgYm91bmRBcmVhID0gZS5kYXRhcy5ib3VuZEFyZWE7XG4gIH1cblxuICB2YXIgX2IgPSBlLmRpc3RYLFxuICAgICAgZGlzdFggPSBfYiA9PT0gdm9pZCAwID8gMCA6IF9iLFxuICAgICAgX2MgPSBlLmRpc3RZLFxuICAgICAgZGlzdFkgPSBfYyA9PT0gdm9pZCAwID8gMCA6IF9jO1xuICB2YXIgX2QgPSBlLmRhdGFzLFxuICAgICAgc3RhcnRYID0gX2Quc3RhcnRYLFxuICAgICAgc3RhcnRZID0gX2Quc3RhcnRZO1xuXG4gIGlmIChyYXRpbyA+IDApIHtcbiAgICB2YXIgbmV4dEhlaWdodCA9IE1hdGguc3FydCgoZGlzdFggKiBkaXN0WCArIGRpc3RZICogZGlzdFkpIC8gKDEgKyByYXRpbyAqIHJhdGlvKSk7XG4gICAgdmFyIG5leHRXaWR0aCA9IHJhdGlvICogbmV4dEhlaWdodDtcbiAgICBkaXN0WCA9IChkaXN0WCA+PSAwID8gMSA6IC0xKSAqIG5leHRXaWR0aDtcbiAgICBkaXN0WSA9IChkaXN0WSA+PSAwID8gMSA6IC0xKSAqIG5leHRIZWlnaHQ7XG4gIH1cblxuICB2YXIgd2lkdGggPSBNYXRoLmFicyhkaXN0WCk7XG4gIHZhciBoZWlnaHQgPSBNYXRoLmFicyhkaXN0WSk7XG4gIHZhciBtYXhXaWR0aCA9IGRpc3RYIDwgMCA/IHN0YXJ0WCAtIGJvdW5kQXJlYS5sZWZ0IDogYm91bmRBcmVhLnJpZ2h0IC0gc3RhcnRYO1xuICB2YXIgbWF4SGVpZ2h0ID0gZGlzdFkgPCAwID8gc3RhcnRZIC0gYm91bmRBcmVhLnRvcCA6IGJvdW5kQXJlYS5ib3R0b20gLSBzdGFydFk7XG4gIF9hID0gY2FsY3VsYXRlQm91bmRTaXplKFt3aWR0aCwgaGVpZ2h0XSwgWzAsIDBdLCBbbWF4V2lkdGgsIG1heEhlaWdodF0sICEhcmF0aW8pLCB3aWR0aCA9IF9hWzBdLCBoZWlnaHQgPSBfYVsxXTtcbiAgZGlzdFggPSAoZGlzdFggPj0gMCA/IDEgOiAtMSkgKiB3aWR0aDtcbiAgZGlzdFkgPSAoZGlzdFkgPj0gMCA/IDEgOiAtMSkgKiBoZWlnaHQ7XG4gIHZhciB0eCA9IE1hdGgubWluKDAsIGRpc3RYKTtcbiAgdmFyIHR5ID0gTWF0aC5taW4oMCwgZGlzdFkpO1xuICB2YXIgbGVmdCA9IHN0YXJ0WCArIHR4O1xuICB2YXIgdG9wID0gc3RhcnRZICsgdHk7XG4gIHJldHVybiB7XG4gICAgbGVmdDogbGVmdCxcbiAgICB0b3A6IHRvcCxcbiAgICByaWdodDogbGVmdCArIHdpZHRoLFxuICAgIGJvdHRvbTogdG9wICsgaGVpZ2h0LFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdEVsZW1lbnRSZWN0KGVsKSB7XG4gIHZhciByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBsZWZ0ID0gcmVjdC5sZWZ0LFxuICAgICAgdG9wID0gcmVjdC50b3AsXG4gICAgICB3aWR0aCA9IHJlY3Qud2lkdGgsXG4gICAgICBoZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgcmV0dXJuIHtcbiAgICBwb3MxOiBbbGVmdCwgdG9wXSxcbiAgICBwb3MyOiBbbGVmdCArIHdpZHRoLCB0b3BdLFxuICAgIHBvczM6IFtsZWZ0LCB0b3AgKyBoZWlnaHRdLFxuICAgIHBvczQ6IFtsZWZ0ICsgd2lkdGgsIHRvcCArIGhlaWdodF1cbiAgfTtcbn1cbmZ1bmN0aW9uIHBhc3NUYXJnZXRzKGJlZm9yZVRhcmdldHMsIGFmdGVyVGFyZ2V0cykge1xuICB2YXIgX2EgPSBkaWZmKGJlZm9yZVRhcmdldHMsIGFmdGVyVGFyZ2V0cyksXG4gICAgICBsaXN0ID0gX2EubGlzdCxcbiAgICAgIHByZXZMaXN0ID0gX2EucHJldkxpc3QsXG4gICAgICBhZGRlZCA9IF9hLmFkZGVkLFxuICAgICAgcmVtb3ZlZCA9IF9hLnJlbW92ZWQ7XG5cbiAgcmV0dXJuIGFkZGVkLm1hcChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICByZXR1cm4gbGlzdFtpbmRleF07XG4gIH0pLmNvbmNhdChyZW1vdmVkLm1hcChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICByZXR1cm4gcHJldkxpc3RbaW5kZXhdO1xuICB9KSk7XG59XG5cbnZhciBpbmplY3RvciA9IHN0eWxlZChcIlxcbjpob3N0IHtcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcbiAgICBkaXNwbGF5OiBub25lO1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjNGFmO1xcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDY4LCAxNzAsIDI1NSwgMC41KTtcXG4gICAgei1pbmRleDogMTAwO1xcbn1cXG46aG9zdCB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuXCIpO1xuLyoqXG4gKiBAbWVtYmVyb2YgU2VsZWN0b1xuICovXG5cbnZhciBDTEFTU19OQU1FID0gXCJzZWxlY3RvLXNlbGVjdGlvbiBcIiArIGluamVjdG9yLmNsYXNzTmFtZTtcbnZhciBQUk9QRVJUSUVTID0gW1wiYm91bmRDb250YWluZXJcIiwgXCJzZWxlY3RhYmxlVGFyZ2V0c1wiLCBcInNlbGVjdEJ5Q2xpY2tcIiwgXCJzZWxlY3RGcm9tSW5zaWRlXCIsIFwiY29udGludWVTZWxlY3RcIiwgXCJ0b2dnbGVDb250aW51ZVNlbGVjdFwiLCBcImtleUNvbnRhaW5lclwiLCBcImhpdFJhdGVcIiwgXCJzY3JvbGxPcHRpb25zXCIsIFwiY2hlY2tJbnB1dFwiLCBcInByZXZlbnREZWZhdWx0XCIsIFwicmF0aW9cIiwgXCJnZXRFbGVtZW50UmVjdFwiLCBcInByZXZlbnREcmFnRnJvbUluc2lkZVwiLCBcInJvb3RDb250YWluZXJcIiwgXCJkcmFnQ29uZGl0aW9uXCIsIFwiY2xpY2tCeVNlbGVjdEVuZFwiXTtcbi8qKlxuICogQG1lbWJlcm9mIFNlbGVjdG9cbiAqL1xuXG52YXIgT1BUSU9OUyA9IF9fc3ByZWFkQXJyYXlzKFsvLyBpZ25vcmUgdGFyZ2V0LCBjb250YWluZXIsXG5cImRyYWdDb250YWluZXJcIiwgXCJjc3BOb25jZVwiXSwgUFJPUEVSVElFUyk7XG52YXIgT1BUSU9OX1RZUEVTID0ge1xuICBib3VuZENvbnRhaW5lcjogbnVsbCxcbiAgcG9ydGFsQ29udGFpbmVyOiBudWxsLFxuICBjb250YWluZXI6IG51bGwsXG4gIGRyYWdDb250YWluZXI6IG51bGwsXG4gIHNlbGVjdGFibGVUYXJnZXRzOiBBcnJheSxcbiAgc2VsZWN0QnlDbGljazogQm9vbGVhbixcbiAgc2VsZWN0RnJvbUluc2lkZTogQm9vbGVhbixcbiAgY29udGludWVTZWxlY3Q6IEJvb2xlYW4sXG4gIHRvZ2dsZUNvbnRpbnVlU2VsZWN0OiBBcnJheSxcbiAga2V5Q29udGFpbmVyOiBudWxsLFxuICBoaXRSYXRlOiBOdW1iZXIsXG4gIHNjcm9sbE9wdGlvbnM6IE9iamVjdCxcbiAgY2hlY2tJbnB1dDogQm9vbGVhbixcbiAgcHJldmVudERlZmF1bHQ6IEJvb2xlYW4sXG4gIGNzcE5vbmNlOiBTdHJpbmcsXG4gIHJhdGlvOiBOdW1iZXIsXG4gIGdldEVsZW1lbnRSZWN0OiBGdW5jdGlvbixcbiAgcHJldmVudERyYWdGcm9tSW5zaWRlOiBCb29sZWFuLFxuICByb290Q29udGFpbmVyOiBPYmplY3QsXG4gIGRyYWdDb25kaXRpb246IEZ1bmN0aW9uLFxuICBjbGlja0J5U2VsZWN0RW5kOiBCb29sZWFuXG59O1xuLyoqXG4gKiBAbWVtYmVyb2YgU2VsZWN0b1xuICovXG5cbnZhciBFVkVOVFMgPSBbXCJkcmFnU3RhcnRcIiwgXCJkcmFnXCIsIFwiZHJhZ0VuZFwiLCBcInNlbGVjdFN0YXJ0XCIsIFwic2VsZWN0XCIsIFwic2VsZWN0RW5kXCIsIFwia2V5ZG93blwiLCBcImtleXVwXCIsIFwic2Nyb2xsXCJdO1xuLyoqXG4gKiBAbWVtYmVyb2YgU2VsZWN0b1xuICovXG5cbnZhciBNRVRIT0RTID0gW1wiY2xpY2tUYXJnZXRcIiwgXCJnZXRTZWxlY3RhYmxlRWxlbWVudHNcIiwgXCJzZXRTZWxlY3RlZFRhcmdldHNcIiwgXCJnZXRFbGVtZW50UG9pbnRzXCIsIFwiZ2V0U2VsZWN0ZWRUYXJnZXRzXCIsIFwiZmluZFNlbGVjdGFibGVUYXJnZXRzXCIsIFwidHJpZ2dlckRyYWdTdGFydFwiLCBcImNoZWNrU2Nyb2xsXCJdO1xuXG4vKipcbiAqIFNlbGVjdG8uanMgaXMgYSBjb21wb25lbnQgdGhhdCBhbGxvd3MgeW91IHRvIHNlbGVjdCBlbGVtZW50cyBpbiB0aGUgZHJhZyBhcmVhIHVzaW5nIHRoZSBtb3VzZSBvciB0b3VjaC5cbiAqIEBzb3J0IDFcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICovXG5cbnZhciBTZWxlY3RvID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFNlbGVjdG8sIF9zdXBlcik7XG4gIC8qKlxuICAgKlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIFNlbGVjdG8ob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMuc2VsZWN0ZWRUYXJnZXRzID0gW107XG4gICAgX3RoaXMuZHJhZ1Njcm9sbCA9IG5ldyBEcmFnU2Nyb2xsKCk7XG5cbiAgICBfdGhpcy5fb25EcmFnU3RhcnQgPSBmdW5jdGlvbiAoZSwgY2xpY2tlZFRhcmdldCkge1xuICAgICAgdmFyIGRhdGFzID0gZS5kYXRhcyxcbiAgICAgICAgICBjbGllbnRYID0gZS5jbGllbnRYLFxuICAgICAgICAgIGNsaWVudFkgPSBlLmNsaWVudFksXG4gICAgICAgICAgaW5wdXRFdmVudCA9IGUuaW5wdXRFdmVudDtcbiAgICAgIHZhciBfYSA9IF90aGlzLm9wdGlvbnMsXG4gICAgICAgICAgY29udGludWVTZWxlY3QgPSBfYS5jb250aW51ZVNlbGVjdCxcbiAgICAgICAgICBzZWxlY3RGcm9tSW5zaWRlID0gX2Euc2VsZWN0RnJvbUluc2lkZSxcbiAgICAgICAgICBzZWxlY3RCeUNsaWNrID0gX2Euc2VsZWN0QnlDbGljayxcbiAgICAgICAgICByb290Q29udGFpbmVyID0gX2Eucm9vdENvbnRhaW5lcixcbiAgICAgICAgICBib3VuZENvbnRhaW5lciA9IF9hLmJvdW5kQ29udGFpbmVyLFxuICAgICAgICAgIF9iID0gX2EucHJldmVudERyYWdGcm9tSW5zaWRlLFxuICAgICAgICAgIHByZXZlbnREcmFnRnJvbUluc2lkZSA9IF9iID09PSB2b2lkIDAgPyB0cnVlIDogX2IsXG4gICAgICAgICAgY2xpY2tCeVNlbGVjdEVuZCA9IF9hLmNsaWNrQnlTZWxlY3RFbmQsXG4gICAgICAgICAgZHJhZ0NvbmRpdGlvbiA9IF9hLmRyYWdDb25kaXRpb247XG5cbiAgICAgIGlmIChkcmFnQ29uZGl0aW9uICYmICFkcmFnQ29uZGl0aW9uKGUpKSB7XG4gICAgICAgIGUuc3RvcCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIF90aGlzLmZpbmRTZWxlY3RhYmxlVGFyZ2V0cyhkYXRhcyk7XG5cbiAgICAgIGRhdGFzLnN0YXJ0U2VsZWN0ZWRUYXJnZXRzID0gX3RoaXMuc2VsZWN0ZWRUYXJnZXRzO1xuICAgICAgZGF0YXMuc2NhbGVNYXRyaXggPSBjcmVhdGVNYXRyaXgoKTtcbiAgICAgIGRhdGFzLmNvbnRhaW5lclggPSAwO1xuICAgICAgZGF0YXMuY29udGFpbmVyWSA9IDA7XG4gICAgICB2YXIgYm91bmRBcmVhID0ge1xuICAgICAgICBsZWZ0OiAtSW5maW5pdHksXG4gICAgICAgIHRvcDogLUluZmluaXR5LFxuICAgICAgICByaWdodDogSW5maW5pdHksXG4gICAgICAgIGJvdHRvbTogSW5maW5pdHlcbiAgICAgIH07XG5cbiAgICAgIGlmIChyb290Q29udGFpbmVyKSB7XG4gICAgICAgIHZhciBjb250YWluZXJSZWN0ID0gX3RoaXMuY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIGRhdGFzLmNvbnRhaW5lclggPSBjb250YWluZXJSZWN0LmxlZnQ7XG4gICAgICAgIGRhdGFzLmNvbnRhaW5lclkgPSBjb250YWluZXJSZWN0LnRvcDtcbiAgICAgICAgZGF0YXMuc2NhbGVNYXRyaXggPSBnZXREaXN0RWxlbWVudE1hdHJpeChfdGhpcy5jb250YWluZXIsIHJvb3RDb250YWluZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYm91bmRDb250YWluZXIpIHtcbiAgICAgICAgdmFyIGJvdW5kSW5mbyA9IGlzT2JqZWN0KGJvdW5kQ29udGFpbmVyKSAmJiBcImVsZW1lbnRcIiBpbiBib3VuZENvbnRhaW5lciA/IF9fYXNzaWduKHtcbiAgICAgICAgICBsZWZ0OiB0cnVlLFxuICAgICAgICAgIHRvcDogdHJ1ZSxcbiAgICAgICAgICBib3R0b206IHRydWUsXG4gICAgICAgICAgcmlnaHQ6IHRydWVcbiAgICAgICAgfSwgYm91bmRDb250YWluZXIpIDoge1xuICAgICAgICAgIGVsZW1lbnQ6IGJvdW5kQ29udGFpbmVyLFxuICAgICAgICAgIGxlZnQ6IHRydWUsXG4gICAgICAgICAgdG9wOiB0cnVlLFxuICAgICAgICAgIGJvdHRvbTogdHJ1ZSxcbiAgICAgICAgICByaWdodDogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgYm91bmRFbGVtZW50ID0gYm91bmRJbmZvLmVsZW1lbnQ7XG4gICAgICAgIHZhciByZWN0RWxlbWVudCA9IHZvaWQgMDtcblxuICAgICAgICBpZiAoYm91bmRFbGVtZW50KSB7XG4gICAgICAgICAgaWYgKGlzU3RyaW5nKGJvdW5kRWxlbWVudCkpIHtcbiAgICAgICAgICAgIHJlY3RFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihib3VuZEVsZW1lbnQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYm91bmRFbGVtZW50ID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZWN0RWxlbWVudCA9IF90aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVjdEVsZW1lbnQgPSBib3VuZEVsZW1lbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJlY3QgPSByZWN0RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAgIGlmIChib3VuZEluZm8ubGVmdCkge1xuICAgICAgICAgICAgYm91bmRBcmVhLmxlZnQgPSByZWN0LmxlZnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGJvdW5kSW5mby50b3ApIHtcbiAgICAgICAgICAgIGJvdW5kQXJlYS50b3AgPSByZWN0LnRvcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYm91bmRJbmZvLnJpZ2h0KSB7XG4gICAgICAgICAgICBib3VuZEFyZWEucmlnaHQgPSByZWN0LnJpZ2h0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChib3VuZEluZm8uYm90dG9tKSB7XG4gICAgICAgICAgICBib3VuZEFyZWEuYm90dG9tID0gcmVjdC5ib3R0b207XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGRhdGFzLmJvdW5kQXJlYSA9IGJvdW5kQXJlYTtcbiAgICAgIHZhciBoaXRSZWN0ID0ge1xuICAgICAgICBsZWZ0OiBjbGllbnRYLFxuICAgICAgICB0b3A6IGNsaWVudFksXG4gICAgICAgIHJpZ2h0OiBjbGllbnRYLFxuICAgICAgICBib3R0b206IGNsaWVudFksXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDBcbiAgICAgIH07XG4gICAgICB2YXIgZmlyc3RQYXNzZWRUYXJnZXRzID0gW107XG5cbiAgICAgIGlmIChzZWxlY3RCeUNsaWNrICYmICFjbGlja0J5U2VsZWN0RW5kKSB7XG4gICAgICAgIHZhciBwb2ludFRhcmdldCA9IF90aGlzLl9maW5kRWxlbWVudChjbGlja2VkVGFyZ2V0IHx8IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoY2xpZW50WCwgY2xpZW50WSksIGRhdGFzLnNlbGVjdGFibGVUYXJnZXRzKTtcblxuICAgICAgICBmaXJzdFBhc3NlZFRhcmdldHMgPSBwb2ludFRhcmdldCA/IFtwb2ludFRhcmdldF0gOiBbXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGhhc0luc2lkZVRhcmdldHMgPSBmaXJzdFBhc3NlZFRhcmdldHMubGVuZ3RoID4gMDtcbiAgICAgIHZhciBpc1ByZXZlbnRTZWxlY3QgPSAhc2VsZWN0RnJvbUluc2lkZSAmJiBoYXNJbnNpZGVUYXJnZXRzOyAvLyBwcmV2ZW50IGRyYWcgZnJvbSBpbnNpZGUgd2hlbiBzZWxlY3RCeUNsaWNrIGlzIGZhbHNlXG5cbiAgICAgIGlmIChpc1ByZXZlbnRTZWxlY3QgJiYgIXNlbGVjdEJ5Q2xpY2spIHtcbiAgICAgICAgZS5zdG9wKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGUgPSBpbnB1dEV2ZW50LnR5cGU7XG4gICAgICB2YXIgaXNUcnVzdGVkID0gdHlwZSA9PT0gXCJtb3VzZWRvd25cIiB8fCB0eXBlID09PSBcInRvdWNoc3RhcnRcIjtcbiAgICAgIC8qKlxuICAgICAgICogV2hlbiB0aGUgZHJhZyBzdGFydHMgKHRyaWdnZXJzIG9uIG1vdXNlZG93biBvciB0b3VjaHN0YXJ0KSwgdGhlIGRyYWdTdGFydCBldmVudCBpcyBjYWxsZWQuXG4gICAgICAgKiBDYWxsIHRoZSBzdG9wICgpIGZ1bmN0aW9uIGlmIHlvdSBoYXZlIGEgc3BlY2lmaWMgZWxlbWVudCBvciBkb24ndCB3YW50IHRvIHJhaXNlIGEgc2VsZWN0XG4gICAgICAgKiBAbWVtYmVyb2YgU2VsZWN0b1xuICAgICAgICogQGV2ZW50IGRyYWdTdGFydFxuICAgICAgICogQHBhcmFtIHtPbkRyYWdTdGFydH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgZHJhZ1N0YXJ0IGV2ZW50XG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogaW1wb3J0IFNlbGVjdG8gZnJvbSBcInNlbGVjdG9cIjtcbiAgICAgICAqXG4gICAgICAgKiBjb25zdCBzZWxlY3RvID0gbmV3IFNlbGVjdG8oe1xuICAgICAgICogICBjb250YWluZXI6IGRvY3VtZW50LmJvZHksXG4gICAgICAgKiAgIHNlbGVjdEJ5Q2xpY2s6IHRydWUsXG4gICAgICAgKiAgIHNlbGVjdEZyb21JbnNpZGU6IGZhbHNlLFxuICAgICAgICogfSk7XG4gICAgICAgKlxuICAgICAgICogc2VsZWN0by5vbihcImRyYWdTdGFydFwiLCBlID0+IHtcbiAgICAgICAqICAgaWYgKGUuaW5wdXRFdmVudC50YXJnZXQudGFnTmFtZSA9PT0gXCJTUEFOXCIpIHtcbiAgICAgICAqICAgICBlLnN0b3AoKTtcbiAgICAgICAqICAgfVxuICAgICAgICogfSkub24oXCJzZWxlY3RcIiwgZSA9PiB7XG4gICAgICAgKiAgIGUuYWRkZWQuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgKiAgICAgZWwuY2xhc3NMaXN0LmFkZChcInNlbGVjdGVkXCIpO1xuICAgICAgICogICB9KTtcbiAgICAgICAqICAgZS5yZW1vdmVkLmZvckVhY2goZWwgPT4ge1xuICAgICAgICogICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoXCJzZWxlY3RlZFwiKTtcbiAgICAgICAqICAgfSk7XG4gICAgICAgKiB9KTtcbiAgICAgICAqL1xuXG4gICAgICB2YXIgcmVzdWx0ID0gIWUuaXNDbGljayAmJiBpc1RydXN0ZWQgPyBfdGhpcy5lbWl0KFwiZHJhZ1N0YXJ0XCIsIF9fYXNzaWduKHt9LCBlKSkgOiB0cnVlO1xuXG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICBlLnN0b3AoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWNvbnRpbnVlU2VsZWN0KSB7XG4gICAgICAgIGRhdGFzLnN0YXJ0UGFzc2VkVGFyZ2V0cyA9IFtdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlyc3RQYXNzZWRUYXJnZXRzID0gcGFzc1RhcmdldHMoX3RoaXMuc2VsZWN0ZWRUYXJnZXRzLCBmaXJzdFBhc3NlZFRhcmdldHMpO1xuICAgICAgICBkYXRhcy5zdGFydFBhc3NlZFRhcmdldHMgPSBfdGhpcy5zZWxlY3RlZFRhcmdldHM7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnNlbGVjdChfdGhpcy5zZWxlY3RlZFRhcmdldHMsIGZpcnN0UGFzc2VkVGFyZ2V0cywgaGl0UmVjdCwgaW5wdXRFdmVudCwgdHJ1ZSk7XG5cbiAgICAgIGRhdGFzLnN0YXJ0WCA9IGNsaWVudFg7XG4gICAgICBkYXRhcy5zdGFydFkgPSBjbGllbnRZO1xuICAgICAgZGF0YXMuc2VsZWN0RmxhZyA9IGZhbHNlO1xuICAgICAgZGF0YXMucHJldmVudERyYWdGcm9tSW5zaWRlID0gZmFsc2U7XG4gICAgICB2YXIgb2Zmc2V0UG9zID0gY2FsY3VsYXRlTWF0cml4RGlzdChkYXRhcy5zY2FsZU1hdHJpeCwgW2NsaWVudFggLSBkYXRhcy5jb250YWluZXJYLCBjbGllbnRZIC0gZGF0YXMuY29udGFpbmVyWV0pO1xuICAgICAgZGF0YXMuYm91bmRzQXJlYSA9IF90aGlzLnRhcmdldC5zdHlsZS5jc3NUZXh0ICs9IFwicG9zaXRpb246IFwiICsgKHJvb3RDb250YWluZXIgPyBcImFic29sdXRlXCIgOiBcImZpeGVkXCIpICsgXCI7XCIgKyBcImxlZnQ6MHB4O3RvcDowcHg7XCIgKyAoXCJ0cmFuc2Zvcm06IHRyYW5zbGF0ZShcIiArIG9mZnNldFBvc1swXSArIFwicHgsIFwiICsgb2Zmc2V0UG9zWzFdICsgXCJweClcIik7XG5cbiAgICAgIGlmIChpc1ByZXZlbnRTZWxlY3QgJiYgc2VsZWN0QnlDbGljayAmJiAhY2xpY2tCeVNlbGVjdEVuZCkge1xuICAgICAgICBpbnB1dEV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIHByZXZlbnQgZHJhZyBmcm9tIGluc2lkZSB3aGVuIHNlbGVjdEJ5Q2xpY2sgaXMgdHJ1ZSBhbmQgZm9yY2UgY2FsbCBgc2VsZWN0RW5kYFxuXG4gICAgICAgIGlmIChwcmV2ZW50RHJhZ0Zyb21JbnNpZGUpIHtcbiAgICAgICAgICBfdGhpcy5zZWxlY3RFbmQoZGF0YXMuc3RhcnRTZWxlY3RlZFRhcmdldHMsIGRhdGFzLnN0YXJ0UGFzc2VkVGFyZ2V0cywgaGl0UmVjdCwgZSk7XG5cbiAgICAgICAgICBkYXRhcy5wcmV2ZW50RHJhZ0Zyb21JbnNpZGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhcy5zZWxlY3RGbGFnID0gdHJ1ZTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gXCJ0b3VjaHN0YXJ0XCIpIHtcbiAgICAgICAgICBpbnB1dEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2Nyb2xsT3B0aW9ucyA9IF90aGlzLm9wdGlvbnMuc2Nyb2xsT3B0aW9ucztcblxuICAgICAgICBpZiAoc2Nyb2xsT3B0aW9ucyAmJiBzY3JvbGxPcHRpb25zLmNvbnRhaW5lcikge1xuICAgICAgICAgIF90aGlzLmRyYWdTY3JvbGwuZHJhZ1N0YXJ0KGUsIHNjcm9sbE9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNsaWNrQnlTZWxlY3RFbmQpIHtcbiAgICAgICAgICBkYXRhcy5zZWxlY3RGbGFnID0gZmFsc2U7XG4gICAgICAgICAgZS5wcmV2ZW50RHJhZygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBfdGhpcy5fb25EcmFnID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBfYTtcblxuICAgICAgaWYgKGUuZGF0YXMuc2VsZWN0RmxhZykge1xuICAgICAgICB2YXIgc2Nyb2xsT3B0aW9ucyA9IF90aGlzLnNjcm9sbE9wdGlvbnM7IC8vIElmIGl0IGlzIGEgc2Nyb2xsaW5nIHBvc2l0aW9uLCBwYXNzIGRyYWdcblxuICAgICAgICBpZiAoKChfYSA9IHNjcm9sbE9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250YWluZXIpICYmIF90aGlzLmRyYWdTY3JvbGwuZHJhZyhlLCBzY3JvbGxPcHRpb25zKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfdGhpcy5fY2hlY2tTZWxlY3RlZChlKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuX29uRHJhZ0VuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgZGF0YXMgPSBlLmRhdGFzLFxuICAgICAgICAgIGlucHV0RXZlbnQgPSBlLmlucHV0RXZlbnQ7XG4gICAgICB2YXIgcmVjdCA9IGdldFJlY3QoZSwgX3RoaXMub3B0aW9ucy5yYXRpbyk7XG4gICAgICB2YXIgc2VsZWN0RmxhZyA9IGRhdGFzLnNlbGVjdEZsYWc7XG4gICAgICAvKipcbiAgICAgICAqIFdoZW4gdGhlIGRyYWcgZW5kcyAodHJpZ2dlcnMgb24gbW91c2V1cCBvciB0b3VjaGVuZCBhZnRlciBkcmFnKSwgdGhlIGRyYWdFbmQgZXZlbnQgaXMgY2FsbGVkLlxuICAgICAgICogQG1lbWJlcm9mIFNlbGVjdG9cbiAgICAgICAqIEBldmVudCBkcmFnRW5kXG4gICAgICAgKiBAcGFyYW0ge19PbkRyYWdFbmR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGRyYWdFbmQgZXZlbnRcbiAgICAgICAqL1xuXG4gICAgICBpZiAoaW5wdXRFdmVudCAmJiAhZS5pc0NsaWNrKSB7XG4gICAgICAgIF90aGlzLmVtaXQoXCJkcmFnRW5kXCIsIF9fYXNzaWduKF9fYXNzaWduKHtcbiAgICAgICAgICBpc0RvdWJsZTogISFlLmlzRG91YmxlLFxuICAgICAgICAgIGlzRHJhZzogZmFsc2UsXG4gICAgICAgICAgaXNTZWxlY3Q6IHNlbGVjdEZsYWdcbiAgICAgICAgfSwgZSksIHtcbiAgICAgICAgICBpc0NsaWNrOiAhIWUuaXNDbGljayxcbiAgICAgICAgICByZWN0OiByZWN0XG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMudGFyZ2V0LnN0eWxlLmNzc1RleHQgKz0gXCJkaXNwbGF5OiBub25lO1wiO1xuXG4gICAgICBpZiAoc2VsZWN0RmxhZykge1xuICAgICAgICBkYXRhcy5zZWxlY3RGbGFnID0gZmFsc2U7XG5cbiAgICAgICAgX3RoaXMuZHJhZ1Njcm9sbC5kcmFnRW5kKCk7XG4gICAgICB9IGVsc2UgaWYgKF90aGlzLnNlbGVjdEJ5Q2xpY2sgJiYgX3RoaXMuY2xpY2tCeVNlbGVjdEVuZCkge1xuICAgICAgICAvLyBvbmx5IGNsaWNrQnlTZWxlY3RFbmRcbiAgICAgICAgdmFyIHBvaW50VGFyZ2V0ID0gX3RoaXMuX2ZpbmRFbGVtZW50KGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZS5jbGllbnRYLCBlLmNsaWVudFkpLCBkYXRhcy5zZWxlY3RhYmxlVGFyZ2V0cyk7XG5cbiAgICAgICAgX3RoaXMuc2VsZWN0KF90aGlzLnNlbGVjdGVkVGFyZ2V0cywgcG9pbnRUYXJnZXQgPyBbcG9pbnRUYXJnZXRdIDogW10sIHJlY3QsIGlucHV0RXZlbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRhdGFzLnByZXZlbnREcmFnRnJvbUluc2lkZSkge1xuICAgICAgICBfdGhpcy5zZWxlY3RFbmQoZGF0YXMuc3RhcnRTZWxlY3RlZFRhcmdldHMsIGRhdGFzLnN0YXJ0UGFzc2VkVGFyZ2V0cywgcmVjdCwgZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLl9vbktleURvd24gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKCFfdGhpcy5fc2FtZUNvbWJpS2V5KGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuY29udGludWVTZWxlY3QgPSB0cnVlO1xuICAgICAgLyoqXG4gICAgICAgKiBXaGVuIHlvdSBrZXlkb3duIHRoZSBrZXkgeW91IHNwZWNpZmllZCBpbiB0b2dnbGVDb250aW51ZVNlbGVjdCwgdGhlIGtleWRvd24gZXZlbnQgaXMgY2FsbGVkLlxuICAgICAgICogQG1lbWJlcm9mIFNlbGVjdG9cbiAgICAgICAqIEBldmVudCBrZXlkb3duXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogaW1wb3J0IFNlbGVjdG8gZnJvbSBcInNlbGVjdG9cIjtcbiAgICAgICAqXG4gICAgICAgKiBjb25zdCBzZWxlY3RvID0gbmV3IFNlbGVjdG8oe1xuICAgICAgICogICBjb250YWluZXI6IGRvY3VtZW50LmJvZHksXG4gICAgICAgKiAgIHRvZ2dsZUNvbnRpbnVlU2VsZWN0OiBcInNoaWZ0XCI7XG4gICAgICAgKiAgIGtleUNvbnRhaW5lcjogd2luZG93LFxuICAgICAgICogfSk7XG4gICAgICAgKlxuICAgICAgICogc2VsZWN0by5vbihcImtleWRvd25cIiwgKCkgPT4ge1xuICAgICAgICogICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLmJ1dHRvblwiKS5jbGFzc0xpc3QuYWRkKFwic2VsZWN0ZWRcIik7XG4gICAgICAgKiB9KS5vbihcImtleXVwXCIsICgpID0+IHtcbiAgICAgICAqICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5idXR0b25cIikuY2xhc3NMaXN0LnJlbW92ZShcInNlbGVjdGVkXCIpO1xuICAgICAgICogfSkub24oXCJzZWxlY3RcIiwgZSA9PiB7XG4gICAgICAgKiAgIGUuYWRkZWQuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgKiAgICAgZWwuY2xhc3NMaXN0LmFkZChcInNlbGVjdGVkXCIpO1xuICAgICAgICogICB9KTtcbiAgICAgICAqICAgZS5yZW1vdmVkLmZvckVhY2goZWwgPT4ge1xuICAgICAgICogICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoXCJzZWxlY3RlZFwiKTtcbiAgICAgICAqICAgfSk7XG4gICAgICAgKiB9KTtcbiAgICAgICAqL1xuXG4gICAgICBfdGhpcy5lbWl0KFwia2V5ZG93blwiLCB7fSk7XG4gICAgfTtcblxuICAgIF90aGlzLl9vbktleVVwID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICghX3RoaXMuX3NhbWVDb21iaUtleShlLCB0cnVlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIF90aGlzLmNvbnRpbnVlU2VsZWN0ID0gZmFsc2U7XG4gICAgICAvKipcbiAgICAgICAqIFdoZW4geW91IGtleXVwIHRoZSBrZXkgeW91IHNwZWNpZmllZCBpbiB0b2dnbGVDb250aW51ZVNlbGVjdCwgdGhlIGtleXVwIGV2ZW50IGlzIGNhbGxlZC5cbiAgICAgICAqIEBtZW1iZXJvZiBTZWxlY3RvXG4gICAgICAgKiBAZXZlbnQga2V5dXBcbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKiBpbXBvcnQgU2VsZWN0byBmcm9tIFwic2VsZWN0b1wiO1xuICAgICAgICpcbiAgICAgICAqIGNvbnN0IHNlbGVjdG8gPSBuZXcgU2VsZWN0byh7XG4gICAgICAgKiAgIGNvbnRhaW5lcjogZG9jdW1lbnQuYm9keSxcbiAgICAgICAqICAgdG9nZ2xlQ29udGludWVTZWxlY3Q6IFwic2hpZnRcIjtcbiAgICAgICAqICAga2V5Q29udGFpbmVyOiB3aW5kb3csXG4gICAgICAgKiB9KTtcbiAgICAgICAqXG4gICAgICAgKiBzZWxlY3RvLm9uKFwia2V5ZG93blwiLCAoKSA9PiB7XG4gICAgICAgKiAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuYnV0dG9uXCIpLmNsYXNzTGlzdC5hZGQoXCJzZWxlY3RlZFwiKTtcbiAgICAgICAqIH0pLm9uKFwia2V5dXBcIiwgKCkgPT4ge1xuICAgICAgICogICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLmJ1dHRvblwiKS5jbGFzc0xpc3QucmVtb3ZlKFwic2VsZWN0ZWRcIik7XG4gICAgICAgKiB9KS5vbihcInNlbGVjdFwiLCBlID0+IHtcbiAgICAgICAqICAgZS5hZGRlZC5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAqICAgICBlbC5jbGFzc0xpc3QuYWRkKFwic2VsZWN0ZWRcIik7XG4gICAgICAgKiAgIH0pO1xuICAgICAgICogICBlLnJlbW92ZWQuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgKiAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShcInNlbGVjdGVkXCIpO1xuICAgICAgICogICB9KTtcbiAgICAgICAqIH0pO1xuICAgICAgICovXG5cbiAgICAgIF90aGlzLmVtaXQoXCJrZXl1cFwiLCB7fSk7XG4gICAgfTtcblxuICAgIF90aGlzLl9vbkJsdXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoX3RoaXMudG9nZ2xlQ29udGludWVTZWxlY3QgJiYgX3RoaXMuY29udGludWVTZWxlY3QpIHtcbiAgICAgICAgX3RoaXMuY29udGludWVTZWxlY3QgPSBmYWxzZTtcblxuICAgICAgICBfdGhpcy5lbWl0KFwia2V5dXBcIiwge30pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5fb25Eb2N1bWVudFNlbGVjdFN0YXJ0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICghX3RoaXMuZ2VzdG8uaXNGbGFnKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZHJhZ0NvbnRhaW5lciA9IF90aGlzLmRyYWdDb250YWluZXI7XG5cbiAgICAgIGlmIChkcmFnQ29udGFpbmVyID09PSB3aW5kb3cpIHtcbiAgICAgICAgZHJhZ0NvbnRhaW5lciA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRhaW5lcnMgPSBkcmFnQ29udGFpbmVyIGluc3RhbmNlb2YgRWxlbWVudCA/IFtkcmFnQ29udGFpbmVyXSA6IFtdLnNsaWNlLmNhbGwoZHJhZ0NvbnRhaW5lcik7XG4gICAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICBjb250YWluZXJzLnNvbWUoZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgICAgICBpZiAoY29udGFpbmVyID09PSB0YXJnZXQgfHwgY29udGFpbmVyLmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfdGhpcy50YXJnZXQgPSBvcHRpb25zLnBvcnRhbENvbnRhaW5lcjtcbiAgICBfdGhpcy5jb250YWluZXIgPSBvcHRpb25zLmNvbnRhaW5lciB8fCBkb2N1bWVudC5ib2R5O1xuICAgIF90aGlzLm9wdGlvbnMgPSBfX2Fzc2lnbih7XG4gICAgICBwb3J0YWxDb250YWluZXI6IG51bGwsXG4gICAgICBjb250YWluZXI6IG51bGwsXG4gICAgICBkcmFnQ29udGFpbmVyOiBudWxsLFxuICAgICAgc2VsZWN0YWJsZVRhcmdldHM6IFtdLFxuICAgICAgc2VsZWN0QnlDbGljazogdHJ1ZSxcbiAgICAgIHNlbGVjdEZyb21JbnNpZGU6IHRydWUsXG4gICAgICBjbGlja0J5U2VsZWN0RW5kOiBmYWxzZSxcbiAgICAgIGhpdFJhdGU6IDEwMCxcbiAgICAgIGNvbnRpbnVlU2VsZWN0OiBmYWxzZSxcbiAgICAgIHRvZ2dsZUNvbnRpbnVlU2VsZWN0OiBudWxsLFxuICAgICAga2V5Q29udGFpbmVyOiBudWxsLFxuICAgICAgc2Nyb2xsT3B0aW9uczogdW5kZWZpbmVkLFxuICAgICAgY2hlY2tJbnB1dDogZmFsc2UsXG4gICAgICBwcmV2ZW50RGVmYXVsdDogZmFsc2UsXG4gICAgICBib3VuZENvbnRhaW5lcjogZmFsc2UsXG4gICAgICBwcmV2ZW50RHJhZ0Zyb21JbnNpZGU6IHRydWUsXG4gICAgICBkcmFnQ29uZGl0aW9uOiBudWxsLFxuICAgICAgcm9vdENvbnRhaW5lcjogbnVsbCxcbiAgICAgIGdldEVsZW1lbnRSZWN0OiBnZXREZWZhdWx0RWxlbWVudFJlY3QsXG4gICAgICBjc3BOb25jZTogXCJcIixcbiAgICAgIHJhdGlvOiAwXG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICBfdGhpcy5pbml0RWxlbWVudCgpO1xuXG4gICAgX3RoaXMuaW5pdERyYWdTY3JvbGwoKTtcblxuICAgIF90aGlzLnNldEtleUNvbnRyb2xsZXIoKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogWW91IGNhbiBzZXQgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCB0YXJnZXRzLlxuICAgKlxuICAgKi9cblxuXG4gIHZhciBfX3Byb3RvID0gU2VsZWN0by5wcm90b3R5cGU7XG5cbiAgX19wcm90by5zZXRTZWxlY3RlZFRhcmdldHMgPSBmdW5jdGlvbiAoc2VsZWN0ZWRUYXJnZXRzKSB7XG4gICAgdGhpcy5zZWxlY3RlZFRhcmdldHMgPSBzZWxlY3RlZFRhcmdldHM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBZb3UgY2FuIGdldCB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHRhcmdldHMuXG4gICAqL1xuXG5cbiAgX19wcm90by5nZXRTZWxlY3RlZFRhcmdldHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWRUYXJnZXRzO1xuICB9O1xuXG4gIF9fcHJvdG8uc2V0S2V5Q29udGFpbmVyID0gZnVuY3Rpb24gKGtleUNvbnRhaW5lcikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBkaWZmVmFsdWUob3B0aW9ucy5rZXlDb250YWluZXIsIGtleUNvbnRhaW5lciwgZnVuY3Rpb24gKCkge1xuICAgICAgb3B0aW9ucy5rZXlDb250YWluZXIgPSBrZXlDb250YWluZXI7XG5cbiAgICAgIF90aGlzLnNldEtleUNvbnRyb2xsZXIoKTtcbiAgICB9KTtcbiAgfTtcblxuICBfX3Byb3RvLnNldFRvZ2dsZUNvbnRpbnVlU2VsZWN0ID0gZnVuY3Rpb24gKHRvZ2dsZUNvbnRpbnVlU2VsZWN0KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGRpZmZWYWx1ZShvcHRpb25zLnRvZ2dsZUNvbnRpbnVlU2VsZWN0LCB0b2dnbGVDb250aW51ZVNlbGVjdCwgZnVuY3Rpb24gKCkge1xuICAgICAgb3B0aW9ucy50b2dnbGVDb250aW51ZVNlbGVjdCA9IHRvZ2dsZUNvbnRpbnVlU2VsZWN0O1xuXG4gICAgICBfdGhpcy5zZXRLZXlFdmVudCgpO1xuICAgIH0pO1xuICB9O1xuXG4gIF9fcHJvdG8uc2V0UHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLmdlc3RvLm9wdGlvbnMucHJldmVudERlZmF1bHQgPSB2YWx1ZTtcbiAgfTtcblxuICBfX3Byb3RvLnNldENoZWNrSW5wdXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLmdlc3RvLm9wdGlvbnMuY2hlY2tJbnB1dCA9IHZhbHVlO1xuICB9O1xuICAvKipcbiAgICogYE9uRHJhZ1N0YXJ0YCBpcyB0cmlnZ2VyZWQgYnkgYW4gZXh0ZXJuYWwgZXZlbnQuXG4gICAqIEBwYXJhbSAtIGV4dGVybmFsIGV2ZW50XG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCBTZWxlY3RvIGZyb20gXCJzZWxlY3RvXCI7XG4gICAqXG4gICAqIGNvbnN0IHNlbGVjdG8gPSBuZXcgU2VsZWN0bygpO1xuICAgKlxuICAgKiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBlID0+IHtcbiAgICogICBzZWxlY3RvLnRyaWdnZXJEcmFnU3RhcnQoZSk7XG4gICAqIH0pO1xuICAgKi9cblxuXG4gIF9fcHJvdG8udHJpZ2dlckRyYWdTdGFydCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdGhpcy5nZXN0by50cmlnZ2VyRHJhZ1N0YXJ0KGUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogRGVzdHJveSBlbGVtZW50cywgcHJvcGVydGllcywgYW5kIGV2ZW50cy5cbiAgICovXG5cblxuICBfX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5vZmYoKTtcbiAgICB0aGlzLmtleWNvbiAmJiB0aGlzLmtleWNvbi5kZXN0cm95KCk7XG4gICAgdGhpcy5nZXN0by51bnNldCgpO1xuICAgIHRoaXMuaW5qZWN0UmVzdWx0LmRlc3Ryb3koKTtcbiAgICByZW1vdmVFdmVudChkb2N1bWVudCwgXCJzZWxlY3RzdGFydFwiLCB0aGlzLl9vbkRvY3VtZW50U2VsZWN0U3RhcnQpO1xuICAgIHRoaXMua2V5Y29uID0gbnVsbDtcbiAgICB0aGlzLmdlc3RvID0gbnVsbDtcbiAgICB0aGlzLmluamVjdFJlc3VsdCA9IG51bGw7XG4gICAgdGhpcy50YXJnZXQgPSBudWxsO1xuICAgIHRoaXMuY29udGFpbmVyID0gbnVsbDtcbiAgICB0aGlzLm9wdGlvbnMgPSBudWxsO1xuICB9O1xuXG4gIF9fcHJvdG8uZ2V0RWxlbWVudFBvaW50cyA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICB2YXIgZ2V0RWxlbWVudFJlY3QgPSB0aGlzLmdldEVsZW1lbnRSZWN0IHx8IGdldERlZmF1bHRFbGVtZW50UmVjdDtcbiAgICB2YXIgaW5mbyA9IGdldEVsZW1lbnRSZWN0KHRhcmdldCk7XG4gICAgdmFyIHBvaW50cyA9IFtpbmZvLnBvczEsIGluZm8ucG9zMiwgaW5mby5wb3M0LCBpbmZvLnBvczNdO1xuXG4gICAgaWYgKGdldEVsZW1lbnRSZWN0ICE9PSBnZXREZWZhdWx0RWxlbWVudFJlY3QpIHtcbiAgICAgIHZhciByZWN0ID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgcmV0dXJuIGZpdFBvaW50cyhwb2ludHMsIHJlY3QpO1xuICAgIH1cblxuICAgIHJldHVybiBwb2ludHM7XG4gIH07XG4gIC8qKlxuICAgKiBHZXQgYWxsIGVsZW1lbnRzIHNldCBpbiBgc2VsZWN0YWJsZVRhcmdldHNgLlxuICAgKi9cblxuXG4gIF9fcHJvdG8uZ2V0U2VsZWN0YWJsZUVsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxlY3RhYmxlRWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLm9wdGlvbnMuc2VsZWN0YWJsZVRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICBpZiAoaXNPYmplY3QodGFyZ2V0KSkge1xuICAgICAgICBzZWxlY3RhYmxlRWxlbWVudHMucHVzaCh0YXJnZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHRhcmdldCkpO1xuICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgIHNlbGVjdGFibGVFbGVtZW50cy5wdXNoKGVsKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlbGVjdGFibGVFbGVtZW50cztcbiAgfTtcbiAgLyoqXG4gICAqIElmIHNjcm9sbCBvY2N1cnMgZHVyaW5nIGRyYWdnaW5nLCB5b3UgY2FuIG1hbnVhbGx5IGNhbGwgdGhpcyBtZXRob2QgdG8gY2hlY2sgdGhlIHBvc2l0aW9uIGFnYWluLlxuICAgKi9cblxuXG4gIF9fcHJvdG8uY2hlY2tTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9hO1xuXG4gICAgaWYgKCF0aGlzLmdlc3RvLmlzRmxhZygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNjcm9sbE9wdGlvbnMgPSB0aGlzLnNjcm9sbE9wdGlvbnM7IC8vIElmIGl0IGlzIGEgc2Nyb2xsaW5nIHBvc2l0aW9uLCBwYXNzIGRyYWdcblxuICAgICgoX2EgPSBzY3JvbGxPcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGFpbmVyKSAmJiB0aGlzLmRyYWdTY3JvbGwuY2hlY2tTY3JvbGwoX19hc3NpZ24oe1xuICAgICAgaW5wdXRFdmVudDogdGhpcy5nZXN0by5nZXRDdXJyZW50RXZlbnQoKVxuICAgIH0sIHNjcm9sbE9wdGlvbnMpKTtcbiAgfTtcbiAgLyoqXG4gICAqIEZpbmQgZm9yIHNlbGVjdGFibGVUYXJnZXRzIGFnYWluIGR1cmluZyBkcmFnIGV2ZW50XG4gICAqL1xuXG5cbiAgX19wcm90by5maW5kU2VsZWN0YWJsZVRhcmdldHMgPSBmdW5jdGlvbiAoZGF0YXMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKGRhdGFzID09PSB2b2lkIDApIHtcbiAgICAgIGRhdGFzID0gdGhpcy5nZXN0by5nZXRFdmVudERhdGFzKCk7XG4gICAgfVxuXG4gICAgdmFyIHNlbGVjdGFibGVUYXJnZXRzID0gdGhpcy5nZXRTZWxlY3RhYmxlRWxlbWVudHMoKTtcbiAgICB2YXIgc2VsZWN0YWJsZVBvaW50cyA9IHNlbGVjdGFibGVUYXJnZXRzLm1hcChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICByZXR1cm4gX3RoaXMuZ2V0RWxlbWVudFBvaW50cyh0YXJnZXQpO1xuICAgIH0pO1xuICAgIGRhdGFzLnNlbGVjdGFibGVUYXJnZXRzID0gc2VsZWN0YWJsZVRhcmdldHM7XG4gICAgZGF0YXMuc2VsZWN0YWJsZVBvaW50cyA9IHNlbGVjdGFibGVQb2ludHM7XG4gIH07XG4gIC8qKlxuICAgKiBFeHRlcm5hbCBjbGljayBvciBtb3VzZSBldmVudHMgY2FuIGJlIGFwcGxpZWQgdG8gdGhlIHNlbGVjdG8uXG4gICAqIEBwYXJhbXMgLSBFeHRlbmFsIGNsaWNrIG9yIG1vdXNlIGV2ZW50XG4gICAqIEBwYXJhbXMgLSBTcGVjaWZ5IHRoZSBjbGlja2VkIHRhcmdldCBkaXJlY3RseS5cbiAgICovXG5cblxuICBfX3Byb3RvLmNsaWNrVGFyZ2V0ID0gZnVuY3Rpb24gKGUsIGNsaWNrZWRUYXJnZXQpIHtcbiAgICB2YXIgX2EgPSBnZXRDbGllbnQoZSksXG4gICAgICAgIGNsaWVudFggPSBfYS5jbGllbnRYLFxuICAgICAgICBjbGllbnRZID0gX2EuY2xpZW50WTtcblxuICAgIHZhciBkcmFnRXZlbnQgPSB7XG4gICAgICBkYXRhczoge1xuICAgICAgICBzZWxlY3RGbGFnOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGNsaWVudFg6IGNsaWVudFgsXG4gICAgICBjbGllbnRZOiBjbGllbnRZLFxuICAgICAgaW5wdXRFdmVudDogZSxcbiAgICAgIGlzQ2xpY2s6IHRydWUsXG4gICAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHRoaXMuX29uRHJhZ1N0YXJ0KGRyYWdFdmVudCwgY2xpY2tlZFRhcmdldCkpIHtcbiAgICAgIHRoaXMuX29uRHJhZ0VuZChkcmFnRXZlbnQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9fcHJvdG8uc2V0S2V5Q29udHJvbGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2EgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIGtleUNvbnRhaW5lciA9IF9hLmtleUNvbnRhaW5lcixcbiAgICAgICAgdG9nZ2xlQ29udGludWVTZWxlY3QgPSBfYS50b2dnbGVDb250aW51ZVNlbGVjdDtcblxuICAgIGlmICh0aGlzLmtleWNvbikge1xuICAgICAgdGhpcy5rZXljb24uZGVzdHJveSgpO1xuICAgICAgdGhpcy5rZXljb24gPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0b2dnbGVDb250aW51ZVNlbGVjdCkge1xuICAgICAgdGhpcy5rZXljb24gPSBuZXcgS2V5Q29udHJvbGxlcihrZXlDb250YWluZXIgfHwgd2luZG93KTtcbiAgICAgIHRoaXMua2V5Y29uLmtleWRvd24odGhpcy5fb25LZXlEb3duKS5rZXl1cCh0aGlzLl9vbktleVVwKS5vbihcImJsdXJcIiwgdGhpcy5fb25CbHVyKTtcbiAgICB9XG4gIH07XG5cbiAgX19wcm90by5zZXRLZXlFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdG9nZ2xlQ29udGludWVTZWxlY3QgPSB0aGlzLm9wdGlvbnMudG9nZ2xlQ29udGludWVTZWxlY3Q7XG5cbiAgICBpZiAoIXRvZ2dsZUNvbnRpbnVlU2VsZWN0IHx8IHRoaXMua2V5Y29uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zZXRLZXlDb250cm9sbGVyKCk7XG4gIH07XG5cbiAgX19wcm90by5pbml0RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnRhcmdldCA9IGNyZWF0ZUVsZW1lbnQoaChcImRpdlwiLCB7XG4gICAgICBjbGFzc05hbWU6IENMQVNTX05BTUVcbiAgICB9KSwgdGhpcy50YXJnZXQsIHRoaXMuY29udGFpbmVyKTtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7XG4gICAgdmFyIF9hID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBkcmFnQ29udGFpbmVyID0gX2EuZHJhZ0NvbnRhaW5lcixcbiAgICAgICAgY2hlY2tJbnB1dCA9IF9hLmNoZWNrSW5wdXQsXG4gICAgICAgIHByZXZlbnREZWZhdWx0ID0gX2EucHJldmVudERlZmF1bHQ7XG4gICAgdGhpcy5kcmFnQ29udGFpbmVyID0gdHlwZW9mIGRyYWdDb250YWluZXIgPT09IFwic3RyaW5nXCIgPyBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZHJhZ0NvbnRhaW5lcikpIDogZHJhZ0NvbnRhaW5lciB8fCB0aGlzLnRhcmdldC5wYXJlbnROb2RlO1xuICAgIHRoaXMuZ2VzdG8gPSBuZXcgR2VzdG8odGhpcy5kcmFnQ29udGFpbmVyLCB7XG4gICAgICBjaGVja1dpbmRvd0JsdXI6IHRydWUsXG4gICAgICBjb250YWluZXI6IHdpbmRvdyxcbiAgICAgIGNoZWNrSW5wdXQ6IGNoZWNrSW5wdXQsXG4gICAgICBwcmV2ZW50RGVmYXVsdDogcHJldmVudERlZmF1bHRcbiAgICB9KS5vbih7XG4gICAgICBkcmFnU3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuICAgICAgZHJhZzogdGhpcy5fb25EcmFnLFxuICAgICAgZHJhZ0VuZDogdGhpcy5fb25EcmFnRW5kXG4gICAgfSk7XG4gICAgYWRkRXZlbnQoZG9jdW1lbnQsIFwic2VsZWN0c3RhcnRcIiwgdGhpcy5fb25Eb2N1bWVudFNlbGVjdFN0YXJ0KTtcbiAgICB0aGlzLmluamVjdFJlc3VsdCA9IGluamVjdG9yLmluamVjdCh0YXJnZXQsIHtcbiAgICAgIG5vbmNlOiB0aGlzLm9wdGlvbnMuY3NwTm9uY2VcbiAgICB9KTtcbiAgfTtcblxuICBfX3Byb3RvLmhpdFRlc3QgPSBmdW5jdGlvbiAoc2VsZWN0UmVjdCwgY2xpZW50WCwgY2xpZW50WSwgdGFyZ2V0cywgc2VsZWN0YWJsZVBvaW50cykge1xuICAgIHZhciBfYSA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgaGl0UmF0ZSA9IF9hLmhpdFJhdGUsXG4gICAgICAgIHNlbGVjdEJ5Q2xpY2sgPSBfYS5zZWxlY3RCeUNsaWNrO1xuICAgIHZhciBsZWZ0ID0gc2VsZWN0UmVjdC5sZWZ0LFxuICAgICAgICB0b3AgPSBzZWxlY3RSZWN0LnRvcCxcbiAgICAgICAgcmlnaHQgPSBzZWxlY3RSZWN0LnJpZ2h0LFxuICAgICAgICBib3R0b20gPSBzZWxlY3RSZWN0LmJvdHRvbTtcbiAgICB2YXIgcmVjdFBvaW50cyA9IFtbbGVmdCwgdG9wXSwgW3JpZ2h0LCB0b3BdLCBbcmlnaHQsIGJvdHRvbV0sIFtsZWZ0LCBib3R0b21dXTtcbiAgICByZXR1cm4gdGFyZ2V0cy5maWx0ZXIoZnVuY3Rpb24gKF8sIGkpIHtcbiAgICAgIHZhciBwb2ludHMgPSBzZWxlY3RhYmxlUG9pbnRzW2ldO1xuICAgICAgdmFyIGluQXJlYSA9IGlzSW5zaWRlKFtjbGllbnRYLCBjbGllbnRZXSwgcG9pbnRzKTtcblxuICAgICAgaWYgKHNlbGVjdEJ5Q2xpY2sgJiYgaW5BcmVhKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3ZlcmxhcFBvaW50cyA9IGdldE92ZXJsYXBQb2ludHMocmVjdFBvaW50cywgcG9pbnRzKTtcblxuICAgICAgaWYgKCFvdmVybGFwUG9pbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBvdmVybGFwU2l6ZSA9IGdldEFyZWFTaXplKG92ZXJsYXBQb2ludHMpO1xuICAgICAgdmFyIHRhcmdldFNpemUgPSBnZXRBcmVhU2l6ZShwb2ludHMpO1xuICAgICAgdmFyIGhpdFJhdGVWYWx1ZSA9IHNwbGl0VW5pdChcIlwiICsgaGl0UmF0ZSk7XG5cbiAgICAgIGlmIChoaXRSYXRlVmFsdWUudW5pdCA9PT0gXCJweFwiKSB7XG4gICAgICAgIHJldHVybiBvdmVybGFwU2l6ZSA+PSBoaXRSYXRlVmFsdWUudmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmF0ZSA9IGJldHdlZW4oTWF0aC5yb3VuZChvdmVybGFwU2l6ZSAvIHRhcmdldFNpemUgKiAxMDApLCAwLCAxMDApO1xuICAgICAgICByZXR1cm4gcmF0ZSA+PSBNYXRoLm1pbigxMDAsIGhpdFJhdGVWYWx1ZS52YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX19wcm90by5pbml0RHJhZ1Njcm9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5kcmFnU2Nyb2xsLm9uKFwic2Nyb2xsXCIsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgdmFyIGNvbnRhaW5lciA9IF9hLmNvbnRhaW5lcixcbiAgICAgICAgICBkaXJlY3Rpb24gPSBfYS5kaXJlY3Rpb247XG5cbiAgICAgIF90aGlzLmVtaXQoXCJzY3JvbGxcIiwge1xuICAgICAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb25cbiAgICAgIH0pO1xuICAgIH0pLm9uKFwibW92ZVwiLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgIHZhciBvZmZzZXRYID0gX2Eub2Zmc2V0WCxcbiAgICAgICAgICBvZmZzZXRZID0gX2Eub2Zmc2V0WSxcbiAgICAgICAgICBpbnB1dEV2ZW50ID0gX2EuaW5wdXRFdmVudDtcbiAgICAgIHZhciBnZXN0byA9IF90aGlzLmdlc3RvO1xuXG4gICAgICBpZiAoIWdlc3RvIHx8ICFnZXN0by5pc0ZsYWcoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBkYXRhcyA9IF90aGlzLmdlc3RvLmdldEV2ZW50RGF0YXMoKTtcblxuICAgICAgdmFyIGJvdW5kQXJlYSA9IGRhdGFzLmJvdW5kQXJlYTtcbiAgICAgIGRhdGFzLnN0YXJ0WCAtPSBvZmZzZXRYO1xuICAgICAgZGF0YXMuc3RhcnRZIC09IG9mZnNldFk7XG4gICAgICBkYXRhcy5zZWxlY3RhYmxlUG9pbnRzLmZvckVhY2goZnVuY3Rpb24gKHBvaW50cykge1xuICAgICAgICBwb2ludHMuZm9yRWFjaChmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgICAgcG9zWzBdIC09IG9mZnNldFg7XG4gICAgICAgICAgcG9zWzFdIC09IG9mZnNldFk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBib3VuZEFyZWEubGVmdCAtPSBvZmZzZXRYO1xuICAgICAgYm91bmRBcmVhLnJpZ2h0IC09IG9mZnNldFg7XG4gICAgICBib3VuZEFyZWEudG9wIC09IG9mZnNldFk7XG4gICAgICBib3VuZEFyZWEuYm90dG9tIC09IG9mZnNldFk7XG5cbiAgICAgIF90aGlzLmdlc3RvLnNjcm9sbEJ5KG9mZnNldFgsIG9mZnNldFksIGlucHV0RXZlbnQuaW5wdXRFdmVudCwgZmFsc2UpO1xuXG4gICAgICBfdGhpcy5fY2hlY2tTZWxlY3RlZChfdGhpcy5nZXN0by5nZXRDdXJyZW50RXZlbnQoKSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX19wcm90by5zZWxlY3QgPSBmdW5jdGlvbiAocHJldlNlbGVjdGVkVGFyZ2V0cywgc2VsZWN0ZWRUYXJnZXRzLCByZWN0LCBpbnB1dEV2ZW50LCBpc1N0YXJ0KSB7XG4gICAgdmFyIF9hID0gZGlmZihwcmV2U2VsZWN0ZWRUYXJnZXRzLCBzZWxlY3RlZFRhcmdldHMpLFxuICAgICAgICBhZGRlZCA9IF9hLmFkZGVkLFxuICAgICAgICByZW1vdmVkID0gX2EucmVtb3ZlZCxcbiAgICAgICAgcHJldkxpc3QgPSBfYS5wcmV2TGlzdCxcbiAgICAgICAgbGlzdCA9IF9hLmxpc3Q7XG5cbiAgICB0aGlzLnNlbGVjdGVkVGFyZ2V0cyA9IHNlbGVjdGVkVGFyZ2V0cztcblxuICAgIGlmIChpc1N0YXJ0KSB7XG4gICAgICAvKipcbiAgICAgICAqIFdoZW4gdGhlIHNlbGVjdChkcmFnKSBzdGFydHMsIHRoZSBzZWxlY3RTdGFydCBldmVudCBpcyBjYWxsZWQuXG4gICAgICAgKiBAbWVtYmVyb2YgU2VsZWN0b1xuICAgICAgICogQGV2ZW50IHNlbGVjdFN0YXJ0XG4gICAgICAgKiBAcGFyYW0ge1NlbGVjdG8uT25TZWxlY3R9IC0gUGFyYW1ldGVycyBmb3IgdGhlIHNlbGVjdFN0YXJ0IGV2ZW50XG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogaW1wb3J0IFNlbGVjdG8gZnJvbSBcInNlbGVjdG9cIjtcbiAgICAgICAqXG4gICAgICAgKiBjb25zdCBzZWxlY3RvID0gbmV3IFNlbGVjdG8oe1xuICAgICAgICogICBjb250YWluZXI6IGRvY3VtZW50LmJvZHksXG4gICAgICAgKiAgIHNlbGVjdEJ5Q2xpY2s6IHRydWUsXG4gICAgICAgKiAgIHNlbGVjdEZyb21JbnNpZGU6IGZhbHNlLFxuICAgICAgICogfSk7XG4gICAgICAgKlxuICAgICAgICogc2VsZWN0by5vbihcInNlbGVjdFN0YXJ0XCIsIGUgPT4ge1xuICAgICAgICogICBlLmFkZGVkLmZvckVhY2goZWwgPT4ge1xuICAgICAgICogICAgIGVsLmNsYXNzTGlzdC5hZGQoXCJzZWxlY3RlZFwiKTtcbiAgICAgICAqICAgfSk7XG4gICAgICAgKiAgIGUucmVtb3ZlZC5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAqICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKFwic2VsZWN0ZWRcIik7XG4gICAgICAgKiAgIH0pO1xuICAgICAgICogfSkub24oXCJzZWxlY3RFbmRcIiwgZSA9PiB7XG4gICAgICAgKiAgIGUuYWZ0ZXJBZGRlZC5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAqICAgICBlbC5jbGFzc0xpc3QuYWRkKFwic2VsZWN0ZWRcIik7XG4gICAgICAgKiAgIH0pO1xuICAgICAgICogICBlLmFmdGVyUmVtb3ZlZC5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAqICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKFwic2VsZWN0ZWRcIik7XG4gICAgICAgKiAgIH0pO1xuICAgICAgICogfSk7XG4gICAgICAgKi9cbiAgICAgIHRoaXMuZW1pdChcInNlbGVjdFN0YXJ0XCIsIHtcbiAgICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkVGFyZ2V0cyxcbiAgICAgICAgYWRkZWQ6IGFkZGVkLm1hcChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gbGlzdFtpbmRleF07XG4gICAgICAgIH0pLFxuICAgICAgICByZW1vdmVkOiByZW1vdmVkLm1hcChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gcHJldkxpc3RbaW5kZXhdO1xuICAgICAgICB9KSxcbiAgICAgICAgcmVjdDogcmVjdCxcbiAgICAgICAgaW5wdXRFdmVudDogaW5wdXRFdmVudFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFkZGVkLmxlbmd0aCB8fCByZW1vdmVkLmxlbmd0aCkge1xuICAgICAgLyoqXG4gICAgICAgKiBXaGVuIHRoZSBzZWxlY3QgaW4gcmVhbCB0aW1lLCB0aGUgc2VsZWN0IGV2ZW50IGlzIGNhbGxlZC5cbiAgICAgICAqIEBtZW1iZXJvZiBTZWxlY3RvXG4gICAgICAgKiBAZXZlbnQgc2VsZWN0XG4gICAgICAgKiBAcGFyYW0ge1NlbGVjdG8uT25TZWxlY3R9IC0gUGFyYW1ldGVycyBmb3IgdGhlIHNlbGVjdCBldmVudFxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqIGltcG9ydCBTZWxlY3RvIGZyb20gXCJzZWxlY3RvXCI7XG4gICAgICAgKlxuICAgICAgICogY29uc3Qgc2VsZWN0byA9IG5ldyBTZWxlY3RvKHtcbiAgICAgICAqICAgY29udGFpbmVyOiBkb2N1bWVudC5ib2R5LFxuICAgICAgICogICBzZWxlY3RCeUNsaWNrOiB0cnVlLFxuICAgICAgICogICBzZWxlY3RGcm9tSW5zaWRlOiBmYWxzZSxcbiAgICAgICAqIH0pO1xuICAgICAgICpcbiAgICAgICAqIHNlbGVjdG8ub24oXCJzZWxlY3RcIiwgZSA9PiB7XG4gICAgICAgKiAgIGUuYWRkZWQuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgKiAgICAgZWwuY2xhc3NMaXN0LmFkZChcInNlbGVjdGVkXCIpO1xuICAgICAgICogICB9KTtcbiAgICAgICAqICAgZS5yZW1vdmVkLmZvckVhY2goZWwgPT4ge1xuICAgICAgICogICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoXCJzZWxlY3RlZFwiKTtcbiAgICAgICAqICAgfSk7XG4gICAgICAgKiB9KTtcbiAgICAgICAqL1xuICAgICAgdGhpcy5lbWl0KFwic2VsZWN0XCIsIHtcbiAgICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkVGFyZ2V0cyxcbiAgICAgICAgYWRkZWQ6IGFkZGVkLm1hcChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gbGlzdFtpbmRleF07XG4gICAgICAgIH0pLFxuICAgICAgICByZW1vdmVkOiByZW1vdmVkLm1hcChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gcHJldkxpc3RbaW5kZXhdO1xuICAgICAgICB9KSxcbiAgICAgICAgcmVjdDogcmVjdCxcbiAgICAgICAgaW5wdXRFdmVudDogaW5wdXRFdmVudFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIF9fcHJvdG8uc2VsZWN0RW5kID0gZnVuY3Rpb24gKHN0YXJ0U2VsZWN0ZWRUYXJnZXRzLCBzdGFydFBhc3NlZFRhcmdldHMsIHJlY3QsIGUpIHtcbiAgICB2YXIgaW5wdXRFdmVudCA9IGUuaW5wdXRFdmVudCxcbiAgICAgICAgaXNEb3VibGUgPSBlLmlzRG91YmxlO1xuXG4gICAgdmFyIF9hID0gZGlmZihzdGFydFNlbGVjdGVkVGFyZ2V0cywgdGhpcy5zZWxlY3RlZFRhcmdldHMpLFxuICAgICAgICBhZGRlZCA9IF9hLmFkZGVkLFxuICAgICAgICByZW1vdmVkID0gX2EucmVtb3ZlZCxcbiAgICAgICAgcHJldkxpc3QgPSBfYS5wcmV2TGlzdCxcbiAgICAgICAgbGlzdCA9IF9hLmxpc3Q7XG5cbiAgICB2YXIgX2IgPSBkaWZmKHN0YXJ0UGFzc2VkVGFyZ2V0cywgdGhpcy5zZWxlY3RlZFRhcmdldHMpLFxuICAgICAgICBhZnRlckFkZGVkID0gX2IuYWRkZWQsXG4gICAgICAgIGFmdGVyUmVtb3ZlZCA9IF9iLnJlbW92ZWQsXG4gICAgICAgIGFmdGVyUHJldkxpc3QgPSBfYi5wcmV2TGlzdCxcbiAgICAgICAgYWZ0ZXJMaXN0ID0gX2IubGlzdDtcblxuICAgIHZhciB0eXBlID0gaW5wdXRFdmVudCAmJiBpbnB1dEV2ZW50LnR5cGU7XG4gICAgdmFyIGlzRHJhZ1N0YXJ0ID0gdHlwZSA9PT0gXCJtb3VzZWRvd25cIiB8fCB0eXBlID09PSBcInRvdWNoc3RhcnRcIjtcbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSBzZWxlY3QoZHJhZ0VuZCBvciBjbGljaykgZW5kcywgdGhlIHNlbGVjdEVuZCBldmVudCBpcyBjYWxsZWQuXG4gICAgICogQG1lbWJlcm9mIFNlbGVjdG9cbiAgICAgKiBAZXZlbnQgc2VsZWN0RW5kXG4gICAgICogQHBhcmFtIHtTZWxlY3RvLk9uU2VsZWN0RW5kfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBzZWxlY3RFbmQgZXZlbnRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGltcG9ydCBTZWxlY3RvIGZyb20gXCJzZWxlY3RvXCI7XG4gICAgICpcbiAgICAgKiBjb25zdCBzZWxlY3RvID0gbmV3IFNlbGVjdG8oe1xuICAgICAqICAgY29udGFpbmVyOiBkb2N1bWVudC5ib2R5LFxuICAgICAqICAgc2VsZWN0QnlDbGljazogdHJ1ZSxcbiAgICAgKiAgIHNlbGVjdEZyb21JbnNpZGU6IGZhbHNlLFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogc2VsZWN0by5vbihcInNlbGVjdFN0YXJ0XCIsIGUgPT4ge1xuICAgICAqICAgZS5hZGRlZC5mb3JFYWNoKGVsID0+IHtcbiAgICAgKiAgICAgZWwuY2xhc3NMaXN0LmFkZChcInNlbGVjdGVkXCIpO1xuICAgICAqICAgfSk7XG4gICAgICogICBlLnJlbW92ZWQuZm9yRWFjaChlbCA9PiB7XG4gICAgICogICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoXCJzZWxlY3RlZFwiKTtcbiAgICAgKiAgIH0pO1xuICAgICAqIH0pLm9uKFwic2VsZWN0RW5kXCIsIGUgPT4ge1xuICAgICAqICAgZS5hZnRlckFkZGVkLmZvckVhY2goZWwgPT4ge1xuICAgICAqICAgICBlbC5jbGFzc0xpc3QuYWRkKFwic2VsZWN0ZWRcIik7XG4gICAgICogICB9KTtcbiAgICAgKiAgIGUuYWZ0ZXJSZW1vdmVkLmZvckVhY2goZWwgPT4ge1xuICAgICAqICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKFwic2VsZWN0ZWRcIik7XG4gICAgICogICB9KTtcbiAgICAgKiB9KTtcbiAgICAgKi9cblxuICAgIHRoaXMuZW1pdChcInNlbGVjdEVuZFwiLCB7XG4gICAgICBzZWxlY3RlZDogdGhpcy5zZWxlY3RlZFRhcmdldHMsXG4gICAgICBhZGRlZDogYWRkZWQubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdFtpbmRleF07XG4gICAgICB9KSxcbiAgICAgIHJlbW92ZWQ6IHJlbW92ZWQubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICByZXR1cm4gcHJldkxpc3RbaW5kZXhdO1xuICAgICAgfSksXG4gICAgICBhZnRlckFkZGVkOiBhZnRlckFkZGVkLm1hcChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGFmdGVyTGlzdFtpbmRleF07XG4gICAgICB9KSxcbiAgICAgIGFmdGVyUmVtb3ZlZDogYWZ0ZXJSZW1vdmVkLm1hcChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGFmdGVyUHJldkxpc3RbaW5kZXhdO1xuICAgICAgfSksXG4gICAgICBpc0RyYWdTdGFydDogaXNEcmFnU3RhcnQsXG4gICAgICBpc0NsaWNrOiAhIWUuaXNDbGljayxcbiAgICAgIGlzRG91YmxlOiAhIWlzRG91YmxlLFxuICAgICAgcmVjdDogcmVjdCxcbiAgICAgIGlucHV0RXZlbnQ6IGlucHV0RXZlbnRcbiAgICB9KTtcbiAgfTtcblxuICBfX3Byb3RvLl9jaGVja1NlbGVjdGVkID0gZnVuY3Rpb24gKGUsIHJlY3QpIHtcbiAgICBpZiAocmVjdCA9PT0gdm9pZCAwKSB7XG4gICAgICByZWN0ID0gZ2V0UmVjdChlLCB0aGlzLm9wdGlvbnMucmF0aW8pO1xuICAgIH1cblxuICAgIHZhciBkYXRhcyA9IGUuZGF0YXMsXG4gICAgICAgIGlucHV0RXZlbnQgPSBlLmlucHV0RXZlbnQ7XG4gICAgdmFyIHRvcCA9IHJlY3QudG9wLFxuICAgICAgICBsZWZ0ID0gcmVjdC5sZWZ0LFxuICAgICAgICB3aWR0aCA9IHJlY3Qud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICAgIHZhciBzZWxlY3RGbGFnID0gZGF0YXMuc2VsZWN0RmxhZztcbiAgICB2YXIgY29udGFpbmVyWCA9IGRhdGFzLmNvbnRhaW5lclgsXG4gICAgICAgIGNvbnRhaW5lclkgPSBkYXRhcy5jb250YWluZXJZLFxuICAgICAgICBzY2FsZU1hdHJpeCA9IGRhdGFzLnNjYWxlTWF0cml4O1xuICAgIHZhciBvZmZzZXRQb3MgPSBjYWxjdWxhdGVNYXRyaXhEaXN0KHNjYWxlTWF0cml4LCBbbGVmdCAtIGNvbnRhaW5lclgsIHRvcCAtIGNvbnRhaW5lclldKTtcbiAgICB2YXIgb2Zmc2V0U2l6ZSA9IGNhbGN1bGF0ZU1hdHJpeERpc3Qoc2NhbGVNYXRyaXgsIFt3aWR0aCwgaGVpZ2h0XSk7XG4gICAgdmFyIHByZXZTZWxlY3RlZFRhcmdldHMgPSBbXTtcbiAgICB2YXIgc2VsZWN0ZWRUYXJnZXRzID0gW107XG5cbiAgICBpZiAoc2VsZWN0RmxhZykge1xuICAgICAgdGhpcy50YXJnZXQuc3R5bGUuY3NzVGV4dCArPSBcImRpc3BsYXk6IGJsb2NrO1wiICsgXCJsZWZ0OjBweDt0b3A6MHB4O3BvaW50ZXItZXZlbnRzOiBub25lO1wiICsgKFwidHJhbnNmb3JtOiB0cmFuc2xhdGUoXCIgKyBvZmZzZXRQb3NbMF0gKyBcInB4LCBcIiArIG9mZnNldFBvc1sxXSArIFwicHgpO1wiKSArIChcIndpZHRoOlwiICsgb2Zmc2V0U2l6ZVswXSArIFwicHg7aGVpZ2h0OlwiICsgb2Zmc2V0U2l6ZVsxXSArIFwicHg7XCIpO1xuICAgICAgdmFyIHBhc3NlZFRhcmdldHMgPSB0aGlzLmhpdFRlc3QocmVjdCwgZGF0YXMuc3RhcnRYLCBkYXRhcy5zdGFydFksIGRhdGFzLnNlbGVjdGFibGVUYXJnZXRzLCBkYXRhcy5zZWxlY3RhYmxlUG9pbnRzKTtcbiAgICAgIHByZXZTZWxlY3RlZFRhcmdldHMgPSB0aGlzLnNlbGVjdGVkVGFyZ2V0cztcbiAgICAgIHNlbGVjdGVkVGFyZ2V0cyA9IHBhc3NUYXJnZXRzKGRhdGFzLnN0YXJ0UGFzc2VkVGFyZ2V0cywgcGFzc2VkVGFyZ2V0cyk7XG4gICAgICB0aGlzLnNlbGVjdGVkVGFyZ2V0cyA9IHNlbGVjdGVkVGFyZ2V0cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hlbiB0aGUgZHJhZywgdGhlIGRyYWcgZXZlbnQgaXMgY2FsbGVkLlxuICAgICAqIENhbGwgdGhlIHN0b3AgKCkgZnVuY3Rpb24gaWYgeW91IGhhdmUgYSBzcGVjaWZpYyBlbGVtZW50IG9yIGRvbid0IHdhbnQgdG8gcmFpc2UgYSBzZWxlY3RcbiAgICAgKiBAbWVtYmVyb2YgU2VsZWN0b1xuICAgICAqIEBldmVudCBkcmFnXG4gICAgICogQHBhcmFtIHtPbkRyYWd9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGRyYWcgZXZlbnRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGltcG9ydCBTZWxlY3RvIGZyb20gXCJzZWxlY3RvXCI7XG4gICAgICpcbiAgICAgKiBjb25zdCBzZWxlY3RvID0gbmV3IFNlbGVjdG8oe1xuICAgICAqICAgY29udGFpbmVyOiBkb2N1bWVudC5ib2R5LFxuICAgICAqICAgc2VsZWN0QnlDbGljazogdHJ1ZSxcbiAgICAgKiAgIHNlbGVjdEZyb21JbnNpZGU6IGZhbHNlLFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogc2VsZWN0by5vbihcImRyYWdcIiwgZSA9PiB7XG4gICAgICogICBlLnN0b3AoKTtcbiAgICAgKiB9KS5vbihcInNlbGVjdFwiLCBlID0+IHtcbiAgICAgKiAgIGUuYWRkZWQuZm9yRWFjaChlbCA9PiB7XG4gICAgICogICAgIGVsLmNsYXNzTGlzdC5hZGQoXCJzZWxlY3RlZFwiKTtcbiAgICAgKiAgIH0pO1xuICAgICAqICAgZS5yZW1vdmVkLmZvckVhY2goZWwgPT4ge1xuICAgICAqICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKFwic2VsZWN0ZWRcIik7XG4gICAgICogICB9KTtcbiAgICAgKiB9KTtcbiAgICAgKi9cblxuXG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuZW1pdChcImRyYWdcIiwgX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7XG4gICAgICBpc1NlbGVjdDogc2VsZWN0RmxhZyxcbiAgICAgIHJlY3Q6IHJlY3RcbiAgICB9KSk7XG5cbiAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgdGhpcy50YXJnZXQuc3R5bGUuY3NzVGV4dCArPSBcImRpc3BsYXk6IG5vbmU7XCI7XG4gICAgICBlLnN0b3AoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc2VsZWN0RmxhZykge1xuICAgICAgdGhpcy5zZWxlY3QocHJldlNlbGVjdGVkVGFyZ2V0cywgc2VsZWN0ZWRUYXJnZXRzLCByZWN0LCBpbnB1dEV2ZW50KTtcbiAgICB9XG4gIH07XG5cbiAgX19wcm90by5fc2FtZUNvbWJpS2V5ID0gZnVuY3Rpb24gKGUsIGlzS2V5dXApIHtcbiAgICB2YXIgdG9nZ2xlQ29udGludWVTZWxlY3QgPSBbXS5jb25jYXQodGhpcy5vcHRpb25zLnRvZ2dsZUNvbnRpbnVlU2VsZWN0KTtcbiAgICB2YXIgY29tYmkgPSBnZXRDb21iaShlLmlucHV0RXZlbnQsIGUua2V5KTtcbiAgICB2YXIgdG9nZ2xlS2V5cyA9IGlzQXJyYXkodG9nZ2xlQ29udGludWVTZWxlY3RbMF0pID8gdG9nZ2xlQ29udGludWVTZWxlY3QgOiBbdG9nZ2xlQ29udGludWVTZWxlY3RdO1xuXG4gICAgaWYgKGlzS2V5dXApIHtcbiAgICAgIHZhciBzaW5nbGVLZXlfMSA9IGUua2V5O1xuICAgICAgcmV0dXJuIHRvZ2dsZUtleXMuc29tZShmdW5jdGlvbiAoa2V5cykge1xuICAgICAgICByZXR1cm4ga2V5cy5zb21lKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICByZXR1cm4ga2V5ID09PSBzaW5nbGVLZXlfMTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdG9nZ2xlS2V5cy5zb21lKGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICByZXR1cm4ga2V5cy5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBjb21iaS5pbmRleE9mKGtleSkgPiAtMTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIF9fcHJvdG8uX2ZpbmRFbGVtZW50ID0gZnVuY3Rpb24gKGNsaWNrZWRUYXJnZXQsIHNlbGVjdGFibGVUYXJnZXRzKSB7XG4gICAgdmFyIHBvaW50VGFyZ2V0ID0gY2xpY2tlZFRhcmdldDtcblxuICAgIHdoaWxlIChwb2ludFRhcmdldCkge1xuICAgICAgaWYgKHNlbGVjdGFibGVUYXJnZXRzLmluZGV4T2YocG9pbnRUYXJnZXQpID4gLTEpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHBvaW50VGFyZ2V0ID0gcG9pbnRUYXJnZXQucGFyZW50RWxlbWVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9pbnRUYXJnZXQ7XG4gIH07XG5cbiAgU2VsZWN0byA9IF9fZGVjb3JhdGUoW1Byb3BlcnRpZXMoUFJPUEVSVElFUywgZnVuY3Rpb24gKHByb3RvdHlwZSwgcHJvcGVydHkpIHtcbiAgICB2YXIgYXR0cmlidXRlcyA9IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1twcm9wZXJ0eV07XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgc2V0dGVyID0gY2FtZWxpemUoXCJzZXQgXCIgKyBwcm9wZXJ0eSk7XG5cbiAgICBpZiAocHJvdG90eXBlW3NldHRlcl0pIHtcbiAgICAgIGF0dHJpYnV0ZXMuc2V0ID0gZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIHRoaXNbc2V0dGVyXSh2YWx1ZSk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBhdHRyaWJ1dGVzLnNldCA9IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICB0aGlzLm9wdGlvbnNbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICB9O1xuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsIHByb3BlcnR5LCBhdHRyaWJ1dGVzKTtcbiAgfSldLCBTZWxlY3RvKTtcbiAgcmV0dXJuIFNlbGVjdG87XG59KEV2ZW50RW1pdHRlcik7XG5cbnZhciBTZWxlY3RvJDEgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoU2VsZWN0bywgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBTZWxlY3RvKCkge1xuICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHJldHVybiBTZWxlY3RvO1xufShTZWxlY3RvKTtcblxuZXhwb3J0IGRlZmF1bHQgU2VsZWN0byQxO1xuZXhwb3J0IHsgQ0xBU1NfTkFNRSwgRVZFTlRTLCBNRVRIT0RTLCBPUFRJT05TLCBPUFRJT05fVFlQRVMsIFBST1BFUlRJRVMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlbGVjdG8uZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbIlJlYWN0IiwiVmFsdWVQaWNrZXIiLCJBZGRMYXllckJ1dHRvbiIsIm9uQ2hhbmdlIiwib3B0aW9ucyIsImxhYmVsIiwiY3NzIiwiY3giLCJEcmFnRHJvcENvbnRleHQiLCJEcmFnZ2FibGUiLCJEcm9wcGFibGUiLCJjb25maWciLCJJY29uIiwiSWNvbkJ1dHRvbiIsInN0eWxlc0ZhY3RvcnkiLCJMYXllck5hbWUiLCJMYXllckRyYWdEcm9wTGlzdCIsImxheWVycyIsImdldExheWVySW5mbyIsIm9uRHJhZ0VuZCIsIm9uU2VsZWN0Iiwib25EZWxldGUiLCJvbkR1cGxpY2F0ZSIsImlzRnJhbWUiLCJzZWxlY3Rpb24iLCJleGNsdWRlQmFzZUxheWVyIiwib25OYW1lQ2hhbmdlIiwidmVyaWZ5TGF5ZXJOYW1lVW5pcXVlbmVzcyIsInN0eWxlIiwic3R5bGVzIiwidGhlbWUiLCJnZXRSb3dTdHlsZSIsImlzU2VsZWN0ZWQiLCJyb3ciLCJzZWwiLCJwcm92aWRlZCIsInNuYXBzaG90IiwiZHJvcHBhYmxlUHJvcHMiLCJpbm5lclJlZiIsInJvd3MiLCJsYXN0TGF5ZXJJbmRleCIsInNob3VsZFJlbmRlckRyYWdJY29uTGVuZ3RoVGhyZXNob2xkIiwiaSIsImxlbmd0aCIsImVsZW1lbnQiLCJ1aWQiLCJnZXROYW1lIiwiQm9vbGVhbiIsImluY2x1ZGVzIiwicHVzaCIsImRyYWdnYWJsZVByb3BzIiwiZHJhZ0hhbmRsZVByb3BzIiwidiIsInVuZGVmaW5lZCIsInRleHRXcmFwcGVyIiwiYWN0aW9uSWNvbiIsImRyYWdJY29uIiwicGxhY2Vob2xkZXIiLCJkZWZhdWx0UHJvcHMiLCJpc0dyb3VwIiwid3JhcHBlciIsInNwYWNpbmciLCJtZCIsInhzIiwic20iLCJib3JkZXIiLCJyYWRpdXMiLCJjb2xvcnMiLCJiZzIiLCJmb3JtSW5wdXRIZWlnaHQiLCJmb3JtSW5wdXRCb3JkZXIiLCJmb3JtSW5wdXRCb3JkZXJIb3ZlciIsImZvcm1JbnB1dEJvcmRlckFjdGl2ZSIsInRleHRXZWFrIiwidGV4dCIsInR5cGVXcmFwcGVyIiwidGV4dEJsdWUiLCJ1c2VTdGF0ZSIsIklucHV0IiwiRmllbGRWYWxpZGF0aW9uTWVzc2FnZSIsInVzZVN0eWxlcyIsIm5hbWUiLCJnZXRTdHlsZXMiLCJpc0VkaXRpbmciLCJzZXRJc0VkaXRpbmciLCJ2YWxpZGF0aW9uRXJyb3IiLCJzZXRWYWxpZGF0aW9uRXJyb3IiLCJvbkVkaXRMYXllciIsImV2ZW50Iiwib25FbmRFZGl0TmFtZSIsIm5ld05hbWUiLCJvbklucHV0Q2hhbmdlIiwiY3VycmVudFRhcmdldCIsInZhbHVlIiwidHJpbSIsIm9uRWRpdExheWVyQmx1ciIsIm9uS2V5RG93biIsImtleSIsInRhcmdldCIsIm9uRm9jdXMiLCJzZWxlY3QiLCJsYXllck5hbWVXcmFwcGVyIiwibGF5ZXJOYW1lIiwibGF5ZXJFZGl0SWNvbiIsImxheWVyTmFtZUlucHV0IiwiYmczIiwiYm9yZGVyMyIsInR5cG9ncmFwaHkiLCJ3ZWlnaHQiLCJzZW1pYm9sZCIsIlB1cmVDb21wb25lbnQiLCJCdXR0b24iLCJUZXh0RGltZW5zaW9uRWRpdG9yIiwiQVBJRWRpdG9yIiwiY2FsbEFwaSIsIkJ1dHRvbkRpc3BsYXkiLCJyZW5kZXIiLCJkYXRhIiwicHJvcHMiLCJvbkNsaWNrIiwiYXBpIiwiYnV0dG9uSXRlbSIsImlkIiwiZGVzY3JpcHRpb24iLCJkaXNwbGF5IiwiZGVmYXVsdFNpemUiLCJ3aWR0aCIsImhlaWdodCIsImdldE5ld09wdGlvbnMiLCJwcmVwYXJlRGF0YSIsImN0eCIsImNmZyIsImdldFRleHQiLCJyZWdpc3Rlck9wdGlvbnNVSSIsImJ1aWxkZXIiLCJjYXRlZ29yeSIsImFkZEN1c3RvbUVkaXRvciIsInBhdGgiLCJlZGl0b3IiLCJ1c2VTdHlsZXMyIiwiU2NhbGFyRGltZW5zaW9uRWRpdG9yIiwiRHJvbmVGcm9udERpc3BsYXkiLCJkcm9uZUZyb250VHJhbnNmb3JtU3R5bGUiLCJyb2xsQW5nbGUiLCJkcm9uZUZyb250IiwidHJhbnNmb3JtIiwiZHJvbmVGcm9udEl0ZW0iLCJnZXRTY2FsYXIiLCJEcm9uZVNpZGVEaXNwbGF5IiwiZHJvbmVTaWRlUGl0Y2hUcmFuc2Zvcm1TdHlsZSIsInBpdGNoQW5nbGUiLCJkcm9uZVNpZGUiLCJkcm9uZVNpZGVJdGVtIiwiRHJvbmVUb3BEaXNwbGF5IiwiZlJpZ2h0Um90b3JBbmltYXRpb24iLCJmUmlnaHRSb3RvclJQTSIsIk1hdGgiLCJhYnMiLCJmTGVmdFJvdG9yQW5pbWF0aW9uIiwiZkxlZnRSb3RvclJQTSIsImJSaWdodFJvdG9yQW5pbWF0aW9uIiwiYlJpZ2h0Um90b3JSUE0iLCJiTGVmdFJvdG9yQW5pbWF0aW9uIiwiYkxlZnRSb3RvclJQTSIsImRyb25lVG9wVHJhbnNmb3JtU3R5bGUiLCJ5YXdBbmdsZSIsInByb3BlbGxlciIsInByb3BlbGxlckNXIiwiYW5pbWF0aW9uIiwicHJvcGVsbGVyQ0NXIiwiZHJvbmVUb3BJdGVtIiwiaXNTdHJpbmciLCJTVkciLCJSZXNvdXJjZURpbWVuc2lvbk1vZGUiLCJnZXRQdWJsaWNPckFic29sdXRlVXJsIiwiQ29sb3JEaW1lbnNpb25FZGl0b3IiLCJSZXNvdXJjZURpbWVuc2lvbkVkaXRvciIsInN2Z1N0cm9rZVBhdGhDbGFzcyIsIkljb25EaXNwbGF5Iiwic3ZnU3R5bGUiLCJmaWxsIiwic3Ryb2tlIiwic3Ryb2tlQ29sb3IiLCJzdHJva2VXaWR0aCIsImljb25JdGVtIiwicGxhY2VtZW50IiwidG9wIiwibGVmdCIsIm1vZGUiLCJGaXhlZCIsImZpeGVkIiwiZ2V0UmVzb3VyY2UiLCJnZXRDb2xvciIsImNvbG9yIiwic2V0dGluZ3MiLCJyZXNvdXJjZVR5cGUiLCJkZWZhdWx0VmFsdWUiLCJhZGRTbGlkZXJJbnB1dCIsIm1pbiIsIm1heCIsInNob3dJZiIsIk5vdEZvdW5kRGlzcGxheSIsIkpTT04iLCJzdHJpbmdpZnkiLCJub3RGb3VuZEl0ZW0iLCJBbGlnbiIsIlZBbGlnbiIsIlRleHRCb3hEaXNwbGF5IiwidGhlbWUyIiwiY29udGFpbmVyIiwic3BhbiIsInZhbGlnbiIsImFsaWduIiwic2l6ZSIsInRleHRCb3hJdGVtIiwiYmFja2dyb3VuZCIsIkxlZnQiLCJNaWRkbGUiLCJDZW50ZXIiLCJhZGRSYWRpbyIsIlJpZ2h0IiwiVG9wIiwiQm90dG9tIiwiYWRkTnVtYmVySW5wdXQiLCJXaW5kVHVyYmluZURpc3BsYXkiLCJ3aW5kVHVyYmluZUFuaW1hdGlvbiIsInJwbSIsImJsYWRlIiwid2luZFR1cmJpbmVJdGVtIiwiQ2FudmFzRnJhbWVPcHRpb25zIiwiUmVnaXN0cnkiLCJERUZBVUxUX0NBTlZBU19FTEVNRU5UX0NPTkZJRyIsInR5cGUiLCJjYW52YXNFbGVtZW50UmVnaXN0cnkiLCJCYWNrZ3JvdW5kSW1hZ2VTaXplIiwiSG9yaXpvbnRhbENvbnN0cmFpbnQiLCJWZXJ0aWNhbENvbnN0cmFpbnQiLCJjb3VudGVyIiwiRWxlbWVudFN0YXRlIiwiY29uc3RydWN0b3IiLCJpdGVtIiwicGFyZW50IiwiZGl2IiwiYXBwbHlMYXlvdXRTdHlsZXNUb0RpdiIsImNvbnN0cmFpbnQiLCJ2ZXJ0aWNhbCIsImhvcml6b250YWwiLCJUb3BCb3R0b20iLCJib3R0b20iLCJMZWZ0UmlnaHQiLCJyaWdodCIsImRlbHRhWCIsImRlbHRhIiwiZGVsdGFZIiwiZGlyTFIiLCJkaXJlY3Rpb24iLCJkaXJUQiIsImZhbGxiYWNrTmFtZSIsIkRhdGUiLCJub3ciLCJzY2VuZSIsImdldFNjZW5lIiwiZ2V0TmV4dEVsZW1lbnROYW1lIiwiYnlOYW1lIiwic2V0IiwidHJhdiIsImlzUm9vdCIsInBvc2l0aW9uIiwidHJhbnNsYXRlIiwiU2NhbGUiLCJzaXplU3R5bGUiLCJkYXRhU3R5bGUiLCJzZXRQbGFjZW1lbnRGcm9tQ29uc3RyYWludCIsImVsZW1lbnRDb250YWluZXIiLCJwYXJlbnRDb250YWluZXIiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJwYXJlbnRFbGVtZW50IiwicmVsYXRpdmVUb3AiLCJyb3VuZCIsInJlbGF0aXZlQm90dG9tIiwicmVsYXRpdmVMZWZ0IiwicmVsYXRpdmVSaWdodCIsImVsZW1lbnRDZW50ZXIiLCJwYXJlbnRDZW50ZXIiLCJkaXN0YW5jZUZyb21DZW50ZXIiLCJyZXZJZCIsInVwZGF0ZURhdGEiLCJiYWNrZ3JvdW5kQ29sb3IiLCJpbWFnZSIsImJhY2tncm91bmRJbWFnZSIsIkNvbnRhaW4iLCJiYWNrZ3JvdW5kU2l6ZSIsImJhY2tncm91bmRSZXBlYXQiLCJDb3ZlciIsIk9yaWdpbmFsIiwiVGlsZSIsIkZpbGwiLCJib3JkZXJXaWR0aCIsImJvcmRlclN0eWxlIiwiYm9yZGVyQ29sb3IiLCJiYWNrZ3JvdW5kT3JpZ2luIiwidmlzaXQiLCJ2aXNpdG9yIiwiZ2V0SWZFeGlzdHMiLCJvbGROYW1lIiwic2F2ZSIsImRlbGV0ZSIsImdldFNhdmVNb2RlbCIsImluaXRFbGVtZW50IiwiVUlEIiwiY2xvbmVEZWVwIiwiTGF5ZXJBY3Rpb25JRCIsImZyYW1lSXRlbUR1bW15IiwiRnJhbWVTdGF0ZSIsImFjdGlvbiIsInVwZGF0ZU5hbWUiLCJzaGlmdEl0ZW1zT25EdXBsaWNhdGUiLCJEZWxldGUiLCJlbGVtZW50cyIsImZpbHRlciIsImUiLCJyZWluaXRpYWxpemVNb3ZlYWJsZSIsIkR1cGxpY2F0ZSIsImNvbnNvbGUiLCJsb2ciLCJvcHRzIiwib2xkUGxhY2VtZW50IiwiY29weSIsImNvbnRleHQiLCJjIiwiZWxlbSIsInJlb3JkZXIiLCJzdGFydEluZGV4IiwiZW5kSW5kZXgiLCJyZXN1bHQiLCJBcnJheSIsImZyb20iLCJyZW1vdmVkIiwic3BsaWNlIiwiY2xlYXJDdXJyZW50U2VsZWN0aW9uIiwic2V0VGltZW91dCIsImluaXRNb3ZlYWJsZSIsImlzRWRpdGluZ0VuYWJsZWQiLCJvdmVyZmxvdyIsIm1hcCIsIlJvb3RFbGVtZW50IiwiY2hhbmdlQ2FsbGJhY2siLCJyZXN0Iiwic2V0Um9vdFJlZiIsIk1vdmVhYmxlIiwiUmVwbGF5U3ViamVjdCIsIlN1YmplY3QiLCJmaXJzdCIsIlNlbGVjdG8iLCJnZXRDb2xvckRpbWVuc2lvbkZyb21EYXRhIiwiZ2V0U2NhbGVEaW1lbnNpb25Gcm9tRGF0YSIsImdldFJlc291cmNlRGltZW5zaW9uRnJvbURhdGEiLCJnZXRUZXh0RGltZW5zaW9uRnJvbURhdGEiLCJnZXRTY2FsYXJEaW1lbnNpb25Gcm9tRGF0YSIsIlNjZW5lIiwiZW5hYmxlRWRpdGluZyIsIm9uU2F2ZSIsIk1hcCIsImlkeCIsImhhcyIsImdldFNjYWxlIiwic2NhbGUiLCJzY2FsYXIiLCJyZXMiLCJtaW5Ub3AiLCJJbmZpbml0eSIsIm1pbkxlZnQiLCJtYXhSaWdodCIsIm1heEJvdHRvbSIsImZvckVhY2giLCJ1cGRhdGVNb3ZlYWJsZSIsInJvb3QiLCJzdGFjayIsImN1cnJlbnRFbGVtZW50Iiwic2hpZnQiLCJuZXN0ZWRFbGVtZW50cyIsIm5lc3RlZEVsZW1lbnQiLCJ1bnNoaWZ0Iiwic2NlbmVDb250YWluZXIiLCJzZWxlY3RvIiwic2V0U2VsZWN0ZWRUYXJnZXRzIiwidGFyZ2V0cyIsInVwZGF0ZVNlbGVjdGlvbiIsIm1vdmVhYmxlIiwic2tpcE5leHRTZWxlY3Rpb25Ccm9hZGNhc3QiLCJmcmFtZSIsIm5leHQiLCJzIiwidCIsImZpbmRFbGVtZW50QnlUYXJnZXQiLCJyb290RWxlbWVudHMiLCJ0YXJnZXRFbGVtZW50cyIsImRlc3Ryb3lTZWxlY3RvIiwiYWxsb3dDaGFuZ2VzIiwiZ2VuZXJhdGVUYXJnZXRFbGVtZW50cyIsImRlc3Ryb3kiLCJzZWxlY3RhYmxlVGFyZ2V0cyIsInNlbGVjdEJ5Q2xpY2siLCJkcmFnZ2FibGUiLCJyZXNpemFibGUiLCJvcmlnaW4iLCJvbiIsImNsaWNrVGFyZ2V0IiwiaW5wdXRFdmVudCIsImlucHV0VGFyZ2V0IiwidGFyZ2V0ZWRFbGVtZW50IiwiYXBwbHlEcmFnIiwiZXZlbnRzIiwibW92ZWQiLCJhcHBseVJlc2l6ZSIsInNlbGVjdGVkVGFyZ2V0IiwiaXNUYXJnZXRNb3ZlYWJsZUVsZW1lbnQiLCJpc01vdmVhYmxlRWxlbWVudCIsInNvbWUiLCJjb250YWlucyIsInN0b3AiLCJzZWxlY3RlZCIsImlzRHJhZ1N0YXJ0IiwicHJldmVudERlZmF1bHQiLCJkcmFnU3RhcnQiLCJsb2FkIiwiY3VycmVudExheWVyIiwidXBkYXRlU2l6ZSIsImdldFNlbGVjdGVkVGFyZ2V0cyIsImZyYW1lU2VsZWN0aW9uIiwicGlwZSIsInN1YnNjcmliZSIsImN1cnJlbnRTZWxlY3RlZEVsZW1lbnRzIiwibmV3TGF5ZXIiLCJmcmFtZVBsYWNlbWVudCIsImdlbmVyYXRlRnJhbWVDb250YWluZXIiLCJkb0FjdGlvbiIsIk1vdXNlRXZlbnQiLCJ1cGRhdGVDdXJyZW50TGF5ZXIiLCJ3cmFwIiwic2V0UmVmIiwidG9vbGJhciIsIkNvbXBvbmVudCIsIlN1YnNjcmlwdGlvbiIsImxvY2F0aW9uU2VydmljZSIsIlBhbmVsQ29udGV4dFJvb3QiLCJQYW5lbEVkaXRFbnRlcmVkRXZlbnQiLCJQYW5lbEVkaXRFeGl0ZWRFdmVudCIsIklubGluZUVkaXQiLCJjYW52YXNJbnN0YW5jZXMiLCJhY3RpdmVDYW52YXNQYW5lbCIsImlzSW5saW5lRWRpdE9wZW4iLCJhY3RpdmVQYW5lbFN1YmplY3QiLCJDYW52YXNQYW5lbCIsImdldFNlYXJjaE9iamVjdCIsImVkaXRQYW5lbCIsIm9uT3B0aW9uc0NoYW5nZSIsInNldFN0YXRlIiwicmVmcmVzaCIsInN0YXRlIiwiZm9yY2VVcGRhdGUiLCJzZXRBY3RpdmVQYW5lbCIsIm9wZW5JbmxpbmVFZGl0IiwicGFuZWwiLCJpbmxpbmVFZGl0QnV0dG9uQ2xvc2UiLCJpbmxpbmVFZGl0aW5nIiwib25VcGRhdGVTY2VuZSIsInN1YnMiLCJhZGQiLCJldmVudEJ1cyIsImV2dCIsInBheWxvYWQiLCJuZWVkc1JlbG9hZCIsImNvbXBvbmVudERpZE1vdW50IiwicGFuZWxDb250ZXh0Iiwib25JbnN0YW5jZVN0YXRlQ2hhbmdlIiwibGF5ZXIiLCJjYW52YXNJbnN0YW5jZSIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwidW5zdWJzY3JpYmUiLCJjaSIsInNob3VsZENvbXBvbmVudFVwZGF0ZSIsIm5leHRQcm9wcyIsIm5leHRTdGF0ZSIsImNoYW5nZWQiLCJzaG91bGRVcGRhdGVTY2VuZUFuZFBhbmVsIiwiaW5saW5lRWRpdGluZ1N3aXRjaGVkIiwiaW5saW5lRWRpdEJ1dHRvbiIsImlubGluZUVkaXRCdXR0b25DbGljayIsInJlbmRlcklubGluZUVkaXQiLCJ1c2VSZWYiLCJSZXNpemFibGUiLCJQb3J0YWwiLCJzdG9yZSIsIklubGluZUVkaXRCb2R5IiwiT0ZGU0VUX1giLCJvbkNsb3NlIiwiYnRuSW5saW5lRWRpdCIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsInJlZiIsImlubGluZUVkaXRLZXkiLCJkZWZhdWx0TWVhc3VyZW1lbnRzIiwiZGVmYXVsdFgiLCJ4IiwiZGVmYXVsdFkiLCJ5Iiwic2F2ZWRQbGFjZW1lbnQiLCJnZXRPYmplY3QiLCJ3IiwiaCIsIm1lYXN1cmVtZW50cyIsInNldE1lYXN1cmVtZW50cyIsInNldFBsYWNlbWVudCIsIm9uRHJhZ1N0b3AiLCJkcmFnRWxlbWVudCIsInNhdmVUb1N0b3JlIiwib25SZXNpemVTdG9wIiwic2V0T2JqZWN0IiwiZHJhZ2dhYmxlV3JhcHBlciIsImlubGluZUVkaXRvckNvbnRhaW5lciIsImlubGluZUVkaXRvckhlYWRlciIsImlubGluZUVkaXRvckNsb3NlIiwiaW5saW5lRWRpdG9yQ29udGVudFdyYXBwZXIiLCJpbmxpbmVFZGl0b3JDb250ZW50IiwidjEiLCJwYW5lbEJnIiwiY2FudmFzIiwid2VhayIsImdldCIsImxvZGFzaEdldCIsInVzZU1lbW8iLCJ1c2VPYnNlcnZhYmxlIiwiT3B0aW9uc1BhbmVDYXRlZ29yeURlc2NyaXB0b3IiLCJmaWxsT3B0aW9uc1BhbmVJdGVtcyIsInNldE9wdGlvbkltbXV0YWJseSIsImdldEVsZW1lbnRFZGl0b3IiLCJnZXRMYXllckVkaXRvciIsImFjdGl2ZVBhbmVsIiwiaW5zdGFuY2VTdGF0ZSIsInBhbmUiLCJ0aXRsZSIsInN1cHBsaWVyIiwiYWRkTmVzdGVkT3B0aW9ucyIsImdldE9wdGlvbnNQYW5lQ2F0ZWdvcnlEZXNjcmlwdG9yIiwiaXRlbXMiLCJjYXRlZ29yaWVzIiwiaW5wdXQiLCJnZXRPcHRpb25zUGFuZUNhdGVnb3J5IiwiY2F0ZWdvcnlOYW1lcyIsInN1YiIsImZpbmQiLCJhY2Nlc3MiLCJnZXRWYWx1ZSIsInVzZUNhbGxiYWNrIiwiQXBwRXZlbnRzIiwiZ2V0QmFja2VuZFNydiIsIklubGluZUZpZWxkIiwiSW5saW5lRmllbGRSb3ciLCJKU09ORm9ybWF0dGVyIiwiU3RyaW5nVmFsdWVFZGl0b3IiLCJhcHBFdmVudHMiLCJkdW1teVN0cmluZ1NldHRpbmdzIiwiaXNUZXN0IiwiZmV0Y2giLCJ1cmwiLCJlbmRwb2ludCIsIm1ldGhvZCIsImVycm9yIiwiZW1pdCIsImFsZXJ0RXJyb3IiLCJjb21wbGV0ZSIsImFsZXJ0U3VjY2VzcyIsImxhYmVsV2lkdGgiLCJvbkVuZHBvaW50Q2hhbmdlIiwib25EYXRhQ2hhbmdlIiwicmVuZGVySlNPTiIsImpzb24iLCJwYXJzZSIsIm1lc3NhZ2UiLCJyZW5kZXJUZXN0QVBJQnV0dG9uIiwiZGlzYWJsZVNhbml0aXplSHRtbCIsIkhvcml6b250YWxHcm91cCIsIlNob3dDb25maXJtTW9kYWxFdmVudCIsIkxheWVyRWxlbWVudExpc3RFZGl0b3IiLCJuZXdFbGVtZW50T3B0aW9ucyIsIm5ld0VsZW1lbnQiLCJ0YXJnZXRFbGVtZW50IiwiZGVzdGluYXRpb24iLCJjb3VudCIsInNyYyIsInNvdXJjZSIsImluZGV4IiwiZHN0IiwiZGVsZXRlRnJhbWUiLCJwdWJsaXNoIiwidGV4dDIiLCJjb25maXJtVGV4dCIsInllc1RleHQiLCJvbkNvbmZpcm0iLCJkZWNvdXBsZUZyYW1lIiwiZ29VcExheWVyIiwid2FybiIsImljb24iLCJuYW1lVG9WZXJpZnkiLCJjYW5SZW5hbWUiLCJvbkRlY291cGxlRnJhbWUiLCJvbkRlbGV0ZUZyYW1lIiwib25BZGRJdGVtIiwic2VsZWN0T3B0aW9ucyIsIm9uQ2xlYXJTZWxlY3Rpb24iLCJvbkZyYW1lU2VsZWN0aW9uIiwiRmllbGQiLCJTZWxlY3QiLCJWZXJ0aWNhbEdyb3VwIiwiTnVtYmVySW5wdXQiLCJwbGFjZXMiLCJob3Jpem9udGFsT3B0aW9ucyIsInZlcnRpY2FsT3B0aW9ucyIsIlBsYWNlbWVudEVkaXRvciIsImxheW91dCIsIm9uSG9yaXpvbnRhbENvbnN0cmFpbnRDaGFuZ2UiLCJvblZlcnRpY2FsQ29uc3RyYWludENoYW5nZSIsIm9uUG9zaXRpb25DaGFuZ2UiLCJwIiwib3B0aW9uQnVpbGRlciIsInZhbHVlcyIsImJ1aWxkIiwibGF5ZXJUeXBlcyIsImFkZFNlbGVjdCIsImN1cnJlbnRPcHRpb25zIiwiZmxvb3IiLCJyYW5kb20iLCJhZGRCYWNrZ3JvdW5kIiwiYWRkQm9yZGVyIiwiUGFuZWxQbHVnaW4iLCJwbHVnaW4iLCJzZXROb1BhZGRpbmciLCJ1c2VGaWVsZENvbmZpZyIsInNldFBhbmVsT3B0aW9ucyIsImFkZEJvb2xlYW5Td2l0Y2giXSwic291cmNlUm9vdCI6IiJ9